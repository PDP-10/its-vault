Subject:  The revolution will not be televised
To: TK@AI.AI.MIT.EDU
cc: ALAN@AI.AI.MIT.EDU
Message-ID: <532461.890205.ALAN@AI.AI.MIT.EDU>

More crazed ideas that new programming languages should consider:

1.  Lamping's parameterization ideas.

2.  Smith's reconstruction of quotation and evaluation as normalization.
    (The interesting idea from 2-LISP.)

3.  Smith's notion of a tower of interpreters.  (The interesting idea from
    3-LISP.)

4.  Connections are better than pointers!

5.  Dependency directed interpreters.

6.  Ontic.  (I believe that DAM now claims that all you need is Lisp + AMB
    + EXISTS.)

7.  ML-style type systems.

8.  FX-style type systems.

9.  Various object-oriented abstraction schemes:  Zippel's Capsules, DAM's
    Boolean classes, etc.

10.  GLD's Object-Lisp.  (Might have something to do with Lamping's ideas?)

11.  Waters' Synchronizable Series Expressions.

12.  "Super" Compilers that rewrite your program to use a completely
     different (and presumably better) algorithm.

13.  Constraint languages.

14.  Spreadsheets.

15.  Programming by example.

16.  Knowledge Based Editors.

17.  Multi-media programming.  (Using smells, gestures, textures, 
     sounds, etc...) 

18.  I've always wanted to see what Lisp would be like if -all- procedures
     uniformly took keyword arguments.

Yesterday I recall we discussed:

1.  Boxer and other "graphical" programming languages.

2.  Logic variables and pattern matching.

3.  Algebraic specifications for abstract datatypes.

4.  My claim that the proper way to generalize lexical scoping when your
    program is a (possibly cyclic) graph is to use dominance.

5.  Dimensional analysis.

6.  Transaction semantics.

7.  The vague feeling everybody has that we spend too much time describing
    our algorithms explicitly in terms of our chosen representations.

8.  The fact that most algorithms consist mostly of boundary conditions.
    (Note that this might not be bad.  Perhaps in a really good programming
    language algorithms would consist -entirely- of boundary cases!)

9.  I wanted to be able to view method-oriented progams with the methods
    grouped either by operation, or by datatype.
