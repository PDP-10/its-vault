
                     APPLE II DOS INTERNALS
                     ----- -- --- ---------

                          BY MARK PUMP

          [Parts one and two originally appeared on
          the Illini Microcomputer Abbs, Naperville,
          Illinois. Downloaded and edited by Bill
          Blue. Part three by Ted Burns, from The
          Apple Orchard, March/April 1980 issue.]


    NOTE: ADDRESSES GIVEN ARE FOR APPLE II DOS ON 48K SYSTEM
WITH DISK II CONTROLLER IN SLOT 6, AND LANGUAGE CARD MOD NOT
INSTALLED ON DISK CONTROLLER. FOR APPLE II CONFIGURATIONS
WHICH ARE DIFFERENT THAN THIS, THE RAM ADDRESSES USED BY DOS
ARE $4000 (HEX 4000) LESS THAN THOSE GIVEN FOR A 32K MACHINE
AND $8000 LESS FOR A 16K MACHINE. THE ADDRESSES FOR THE DISK
CONTROLLER CARD ROM START AT LOCATION 'CX00', WHERE 'X' IS THE
SLOT NUMBER. THE ADDRESS FOR THE DISK CONTROLLER DEVICE SELECT
STARTS AT LOCATION C080+X0, WHERE 'X' IS THE SLOT NUMBER.

    THIS REPORT IS COMPOSED OF THE FOLLOWING SECTIONS:

    PART ONE
              SECTION A: DISK CONTROLLER CARD ROM
              SECTION B: MEMORY MAP OF DOS

    PART TWO
              SECTION C: DOS MEMORY/DISK CROSS-REF.
              SECTION D: DISK II DEVICE SELECT ADDRS.
              SECTION E: DOS 3.2 ERRATA
              SECTION F: MISC. NOTES & OTHER GOODIES
              SECTION G: SECTOR SKEW FACTOR

    PART THREE
              SECTION H: APPLE DOS BOOTING PROCESS
                         BY TED BURNS


          -----SECTION A --- DISK CONTROLLER ROM-----

    THE 256 BYTES OF ROM ON THE DISK II CONTROLLER WHICH IS
AVAILABLE TO THE APPLE STARTS AT $C600. THIS ADDRESS IS
BRANCHED TO WHENEVER PR#6 IS ISSUED IN BASIC OR 6(CNTL-K) OR
6(CNTL-P) IS DONE IN THE MONITOR.

    THE SECTION OF CODE FROM C600 TO C61C SETS UP THE AREA IN
MEMORY 08AB-08FF. WHAT SEEMS TO BE HAPPENING HERE IS THAT THE
32 VALUES 1F,1E,1D,...,01,00 ARE STORED IN DECREASING (BUT NOT
NECES- SARILY CONTIGUOUS) MEMORY LOCATIONS FROM 08FF ON DOWN.
A VALUE IS STORED IN A LOCATION ONLY IF THE LOW ORDER BYTE OF
THE ADDRESS OF THE LOCATION DOES NOT CONTAIN 2 ADJACENT ZERO
BITS. ALSO, AN EXCEPTION IS MADE FOR ADDRESS 08D5, WHICH IS
NOT STORED EVEN THOUGH 'D5' (BINARY 11010101) DOES NOT CONTAIN
2 ADJACENT ZERO BITS.  'D5' IS USED AS THE START OF AN ADDRESS
MARKER BEFORE EACH SECTOR ON THE DISK.

    THE SECTION OF CODE FROM C61E TO C62F CALLS A DUMMY
SUBROUTINE IN THE MONITOR TO STORE THE CURRENT ADDRESS IN THE
STACK. THEN THE HIGH ORDER BYTE OF THE ADDRESS IS SHIFTED 4
BITS TO OBTAIN THE SLOT NUMBER TIMES 16, WHICH IS STORED FOR
LATER. THE STACK IS THEN SET UP SO THAT THE RTS AT C6D0
CAUSES CONTROL TO BE GIVEN TO C6D1.

    THE SECTION OF CODE FROM C630 TO C651 SELECTS DRIVE 1,
STARTS THE DRIVE, AND LOOPS PULSING THE STEPPER MOTOR TO A
LOWER TRACK ADDRESS. THIS IS WHAT CAUSES THE FUNNY NOISE AT
THE START OF BOOT- THE HEAD STEPPING AGAINST A STOP WHEN IT
REACHES TRACK ZERO.

    THE SECTION OF CODE FROM C653 IS WHERE THE ACTUAL DATA IS
READ FROM THE DISK. THE FEW INSTRUCTIONS AT C6F7 TEST THE
CHECKSUM AND JUMP TO THE MONITOR IF BAD TO PRINT THE 'ERR'
MESSAGE.

    HERE IS A METHOD TO BOOT FROM DRIVE 2 IF YOU EVER NEED TO.
IN THE MONITOR,

    *1600<C600.C6FFM
    *1637:8B
    *1600G

    WILL CAUSE DRIVE 2 TO BE BOOTED INSTEAD OF DRIVE 1.



           -----SECTION B --- MEMORY MAP OF DOS-----

    AT BOOT, DOS IS LOADED TO ADDRESSES 3600-3FFF, FOLLOWED BY
ADDRESSES 1D00-35FF. IT THEN RELOCATES ITSELF TO RESIDE AT
9600- BFFF ON A 48K APPLE. (SEE SECTION 3)

    IN ADDITION TO THE MAIN DOS CODE AT 9600-BFFF, THERE ARE 7
DOS ROUTINES THAT HAVE ENTRY POINTS IN PAGE 3. THEY ARE:

    03D0 - RESTART DOS, SAVING CURRENT BASIC PROGRAM.
    03D3 - RESTART DOS, KILLING CURRENT BASIC PROGRAM.
    03D6 - ENTER DOS I/O PACKAGE.
    03D9 - ENTER RWTS SUBROUTINE.
    03DC - LOAD Y,A WITH ADDRESS OF THE END OF THE SYSTEM
           BUFFER.
    03E3 - LOAD Y,A WITH ADDRESS OF THE DOS IOB.
    03EA - CAUSE DOS TO SAVE THE ADDRESSES OF THE CHARACTER
           INPUT AND OUTPUT ROUTINES CURRENTLY IN USE, AND
           RECONNECT DOS I/O.

    THE DOS MAINLINE AT 9600-BFFF IS COMPOSED OF SEVERAL
SECTIONS.  THESE SECTIONS ARE LISTED BELOW AND DESCRIBED
SEPARATELY IN DETAIL.

    9600-9CFF: USER FILE BUFFERS
    9D00-9D83: DOS ADDRESS CONSTANTS
    9D84-A883: SYSTEM CODE SECTION
    A884-AAFC: DATA AREA FOR SYSTEM SECTION
    AAFD-B396: I/O PACKAGE
    B397-B6FF: DATA AREA INCLUDING SYSTEM BUFFER
    B700-B7DE: CODE INCLUDING RWTS ENTRY
    B7DF-B7FF: DATA AREA INCLUDING IOB, DCT
    B800-BA8F: CODE
    BA90-BCFF: DATA AREA: FUNCTION UNKNOWN
    BD00-BFFF: MAINLINE RWTS CODE

    9600-9CFF ARE USED FOR USER FILE BUFFERS (NORMALLY 3), AND
ARE ALLOCATED AS FOLLOWS:

    9600-9852: USER FILE BUFFER # 3
    9853-9AA5: USER FILE BUFFER # 2
    9AA6-9CF8: USER FILE BUFFER # 1

    THE HIGHEST NUMBERED BUFFER IS USED FIRST BY DOS.  NOTE
THAT IF MAXFILES IS GREATER THAN 3, MEMORY LOCATIONS BELOW
9600 WILL BE USED.  EACH BUFFER OCCUPIES 595 ($253) BYTES AND
CONSISTS OF 3 SECTIONS.  SECTION 1 RESIDES AT 00-FF WITHIN THE
BUFFER AND IS THE CONTENTS OF THE CURRENT DATA SECTOR. SECTION
2 RESIDES AT 100- 1FF WITHIN THE BUFFER AND CONTAINS THE
CURRENT TRACK/SECTOR LIST (TSL) SECTOR. SECTION 3 RESIDES AT
200-252 WITHIN THE BUFFER AND CONTAINS MISCELLANEOUS
INFORMATION ABOUT THE FILE:

    +22D: CONTAINS THE FILENAME OF THIS BUFFER. IF THE BUFFER
          IS CLOSED, THE 1ST BYTE OF THE NAME IS SET TO 00.
    +24B: ADDRESS OF SECTION 1 OF THIS BUFFER.
    +24D: ADDRESS OF SECTION 2 OF THIS BUFFER.
    +24F: ADDRESS OF SECTION 3 OF THIS BUFFER.
    +251: ADDRESS OF NEXT BUFFERS FILENAME OR ZERO IF THIS IS
          THE LAST (HIGHEST NUMBERED) BUFFER.

    IMMEDIATELY FOLLOWING THE FILE BUFFERS ARE 7 UNUSED BYTES
FROM 9CF9-9CFF.

9D00-9D83 CONTAINS A LIST OF 2-BYTE ADDRESS CONSTANTS USED BY
    DOS. INCLUDED IN THIS LIST AT 9D1E-9D55 IS THE DOS COMMAND
    BRANCH VECTOR. THESE ARE THE ADDRESSES MINUS ONE OF THE
    DOS ROUTINES FOR THE INDIVIDUAL DOS COMMANDS SUCH AS
    INIT,LOAD,SAVE,RUN... ETC.

9D84-A883 IS THE SYSTEM CODE SECTION OF THE DOS.  ENTRY POINT
    9D84 AND 9DBF ARE GIVEN CONTROL DIRECTLY FROM PAGE 3
    BRANCHES AT 03D3 AND 03D0.  A229-A60D CONTAINS CODE TO
    HANDLE THE INDIVIDUAL DOS COMMANDS. THE ADDRESSES FOR EACH
    DOS COMMAND ARE AS FOLLOWS:

       A229 - PR#          A22E - IN#          A233 - MON
       A23D - NOMON        A251 - MAXFILES     A263 - DELETE
       A271 - LOCK         A275 - UNLOCK       A27D - VERIFY
       A281 - RENAME       A298 - APPEND       A2A3 - OPEN
       A2EA - CLOSE        A331 - BSAVE        A35D - BLOAD
       A38E - BRUN         A397 - SAVE         A413 - LOAD
       A4D1 - RUN          A4F0 - CHAIN        A510 - WRITE
       A51B - READ         A54F - INIT         A563 - CATALOG
       A57A - FP           A59E - INT          A5C6 - EXEC
       A5DD - POSITION

A6D2 IS THE START OF THE DOS ERROR PROCESSING ROUTINE.  THIS
    ROUTINE IS ENTERED WITH THE ERROR NUMBER IN THE A-
    REGISTER. A702 IS THE ROUTINE WHICH PRINTS THE APPROPRIATE
    DOS ERROR MESSAGES. ENTRY POINT A851 IS GIVEN CONTROL
    DIRECTLY FROM A PAGE 3 BRANCH AT 03EA.

A884-A907 IS THE DOS COMMAND WORD LIST. ALL OF THE DOS
    COMMANDS EXIST HERE, WITH THE HIGH ORDER BIT SET ON IN THE
    LAST BYTE OF EACH COMMAND NAME. IF YOU WISH TO CHANGE SOME
    OF YOUR DOS COMMAND NAMES, HERE IS THE PLACE TO DO IT.

A941-A94A CONTAIN THE SINGLE CHARACTER KEYWORDS WHICH MAY
    APPEAR ON DOS COMMANDS.

A971-AA3D CONTAIN THE TEXT FOR DOS ERROR MESSAGES.  AA3F-AA4F
    IS THE INDEX TABLE FOR THE DOS MESSAGES AT A971.

AA53 IS THE ADDRESS OF THE CHARACTER OUTPUT ROUTINE WHICH WAS
    IN CONTROL WHEN DOS WAS RECONNECTED. LIKEWISE, AA55 IS THE
    ADDRESS OF THE CHARACTER INPUT ROUTINE.

AA57 CONTAINS THE NUMBER OF BUFFERS DEFINED. THIS IS SET BY
    MAXFILES. AA5C CONTAINS THE DOS ERROR CODE UPON
    ENCOUNTERING A DOS ERROR. THIS ERROR CODE IS USED AS AN
    INDEX INTO TABLE AT AA3F TO INDEX TEXT AT A971.

AA60 CONTAINS THE LENGTH OF THE LAST BLOADED PROGRAM.  AA72
    CONTAINS THE ADDRESS OF THE LAST BLOADED PROGRAM.

AA68 AND AA6A CONTAIN THE DEFAULT DRIVE AND SLOT NUMBERS,
    RESPECTIVELY. THESE ARE SET TO THE DISK ADDRESS OF THE
    LAST DOS COMMAND.

AA75 CONTAINS THE LAST FILENAME USED IN A DOS COMMAND.
    INITIALLY (AT BOOT), THIS AREA CONTAINS THE NAME OF THE
    GREETING PROGRAM.  THIS FIELD IS SET TO BLANKS WHEN A RUN
    COMMAND IS ISSUED WITHOUT A FILENAME GIVEN.

AAB8 CONTAINS THE WORD 'APPLESOFT' FOR THE FP COMMAND.

AAC1 CONTAINS THE ADDRESS OF THE IOB USED BY DOS.  THIS IS
    LOADED INTO THE Y AND A-REGISTERS WHEN 03E3 IS BRANCHED
    TO.

AAFD IS THE ENTRY POINT FOR THE DOS I/O PACKAGE.  IT IS
    REFERENCED FROM PAGE 3 BY A BRANCH FROM 03D6.

AE39 IS THE LOCATION OF THE JSR INSTRUCTION RESPONSIBLE FOR
    PAUSING DURING A CATALOG LISTING. TO DISABLE THIS
    INSTRUCTION, SIMPLY PATCH OVER IT WITH 3 NOP'S.

    THE DATA AREA BEGINNING AT B397 CONTAINS THE FOLLOWING ITEMS:

B397 CONTAINS THE TRACK AND SECTOR ADDRESS OF THE MOST
    RECENTLY READ DIRECTORY (CATALOG) SECTOR.

B3A7 CONTAINS THE 4 FILETYPE CHARACTERS T, I, A, AND B.

B3AF-B3BA CONTAIN THE CHARACTER STRING 'DISK VOLUME ' FOR THE
    CATALOG COMMAND. THIS STRING IS IN REVERSE ORDER.

B3BB-B4BA CONTAINS THE MASTER TRACK/ SECTOR BIT MAP SECTOR OR
    VOLUME TABLE OF CONTENTS (VTOC).

B4BB-B5BA CONTAINS THE LAST ACCESSED DIRECTORY SECTOR. THIS
    LAST ACCESS MAY HAVE BEEN A CATALOG COMMAND OR OTHER DOS
    COMMAND REQUIRING A DIRECTORY SEARCH.

B5BB IS THE 1ST BYTE BEYOND THE SYSTEM BUFFER. THE ROUTINE IN
    PAGE 3 AT 03DC LOADS THE Y AND A-REGISTERS TO POINT HERE.

B7B5 IS THE START OF THE RWTS ROUTINE (READ OR WRITE A TRACK
    AND SECTOR). THE CODE HERE DOESN'T DO MUCH OF ANYTHING
    EXCEPT DISABLE INTERRUPTS BEFORE CALLING THE REAL RWTS
    ROUTINE WHICH IS LOCATED AT BD00.  AFTER THE REAL RWTS
    ROUTINE RETURNS, THIS ROUTINE ENABLES INTERRUPTS AND
    PASSES BACK THE RETURN CODE FROM RWTS IN THE FORM OF THE
    CARRY FLAG.

THE DOS SYSTEM IOB STARTS AT B7E8 AND ITS ASSOCIATED DCT IS AT
    B7FB.  THIS IOB IS SETUP ACCORDING TO THE LAST DOS
    OPERATION THAT OCCURRED. IF YOU ARE USING RWTS, YOU MAY
    USE THIS IOB, BUT IT IS MUCH SAFER TO USE YOUR OWN, AS IF
    THIS ONE IS MESSED UP, DOS WILL NOT FUNCTION.

B800 STARTS MORE MACHINE CODE, AND B86A IS THE START OF THE
    CODE WHICH REFERENCES ADDRESSES WHICH ACTUALLY CONTROL THE
    DISK INTERFACE. THESE ADDRESSES ARE CALLED DEVICE SELECT
    ADDRESSES. (SEE SECTION 4)

BA1E IS THE ONLY ROUTINE IN THE ENTIRE DOS THAT STEPS THE
    READ/ WRITE HEAD UP AND DOWN. THE INSTRUCTION WHICH TURNS
    ON THE STEPPER MOTOR PULSE IS AT BA59 FOLLOWED BY A JSR TO
    BA7F WHICH IS A ROUTINE TO DELAY AN INTERVAL BASED ON THE
    LAST 2 BYTES OF THE DCT. THE INSTRUCTION AT BA6A TURNS OFF
    THE STEPPER MOTOR PULSE.

BA90 STARTS A DATA AREA. THE AREA AT BB00-BC98 IS VERY
    PECULIAR (AND VERY INTERESTING) BUT I DON'T KNOW WHAT ITS
    FUNCTION IS. IT IS 408(DECIMAL) BYTES LONG, AND IS ALL
    ZEROES EXCEPT FOR 8 BUNCHES OF 20(DECIMAL) BYTES WHICH
    CONTAIN VALUES WITH THE LOW 3 BITS ALWAYS OFF, AND
    SEEMINGLY RANDOM 5 HIGH ORDER BITS. THESE BUNCHES OF NON-
    ZERO DATA BYTES ARE 51(DECIMAL) BYTES APART. I THINK THAT
    THIS AREA IS USED AS A BUCKET TO STORE THE RAW DATA AS IT
    IS BEING READ FROM THE DISK.

BC9A-BCB9 IS A 32(DECIMAL) BYTE TABLE OF CHARACTERS AND
    CONTAINS THE VALUES FROM AB TO FF EXCEPT THOSE VALUES THAT
    CONTAIN 2 ADJACENT ZERO BITS, AND ALSO EXCEPT THE VALUE
    D5. CODE AT C600-C61C IN THE DISK INTERFACE ROM CONSTRUCTS
    A TABLE SIMILAR TO THIS ONE, EXCEPT IT APPEARS TO BE THE
    INVERSE OF THIS ONE. (SEE PART 1)

BCD0-BCDC IS 13 BYTES LONG AND CONTAINS A PERMUTATION (ADD 5
    MOD 13) OF THE VALUES FROM 00 TO 0C. DO THESE HAVE
    SOMETHING TO DO WITH SECTORS ON DISK ?

    AND NOW, LETS GET DOWN TO SOME USEFUL INFORMATION ABOUT
RWTS AND HOW IT WORKS.  THE MAIN RWTS CODE STARTS AT BD00 AND
IS CALLED FROM A SIMPLE FRONT END THAT DOES NOTHING EXCEPT
DISABLE INTERRUPTS AND PASS RWTS RETURN CODE IN THE CARRY
FLAG. AT BD00, RWTS FIRST SAVES THE ADDRESS OF THE IOB AT LOC
48 AND 49. AT BD08, IT PLACES THE SLOT# * 16 IN X-REG AND
COMPARES IT WITH THE PREVIOUS SLOT# WHICH IS ALSO IN THE IOB.
IF THE SLOT NUMBER HAS CHANGED, AT BD19, THE OLD SLOT NUMBER
IS ADDRESSED AND THE DATA LINE FROM THE DISK IS MONITORED
UNTIL 8 IDENTICAL CHARACTERS ARE FOUND.  THIS MEANS THAT THE
DISK IN THE PREVIOUS SLOT HAS STOPPED. THIS CODE WAITS UNTIL
THE PREVIOUS SLOT HAS STOPPED TO PREVENT AN OVERLOAD ON THE
APPLE POWER SUPPLY, WHICH IS NOT MEANT TO DRIVE MORE THAN ONE
DISK AT A TIME. AT BD2D, THE NEW SLOT NUMBER IS ADDRESSED, THE
SLOT# * 16 IS SAVED FOR LATER BY BD38, AND THE DISK DRIVE IS
TURNED ON AT BD3F.  AT BD44, THE ADDRESS OF THE DCT AND BUFFER
ARE MOVED FROM THE IOB INTO LOCS 3C,3D,3E, AND 3F, WHERE THEY
CAN BE INDIRECTLY ADDRESSED.  AT BD50, THE DRIVE NUMBER IS
GOTTEN FROM THE IOB. IT IS COMPARED TO THE PREVIOUS DRIVE, AND
THE PREVIOUS DRIVE FIELD OF THE IOB IS UPDATED. AT BD5F,
EITHER DRIVE 1 OR 2 IS SELECTED, AND BYTE 2 AND 3 OF THE DCT
IS STORED AT LOCS 46,47. THESE ARE USED FOR TIMING OF THE HEAD
STEPPER MOTOR. AT BD75, THE DESIRED TRACK NUMBER IS GOTTEN
FROM THE IOB, AND THE TRACK SEEK ROUTINE IS CALLED. THE CODE
AT BD7D DOES SOMETHING WITH THE DCT TIMING COUNT, AND AT BD8A,
THE COMMAND CODE BYTE IS FETCHED FROM THE IOB. IF THE VALUE IS
ZERO (NOP), BDE5 GETS CONTROL TO EFFECT A NOP. IF THE VALUE IS
4 (INITIALIZE), BDE7 GETS CONTROL. IF THE VALUE IS 2 (WRITE),
B800 IS CALLED FROM BD98. AND FINALLY, IF THE COMMAND CODE IS
1 (READ), EXECUTION CONTINUES AT BD9B.

    AND NOW, IN A LITTLE LESS DETAIL, IS WHAT HAPPENS
ELSEWHERE IN RWTS... THE CODE FOR INIT STORES THE VOLUME
NUMBER TO BE INITIALIZED AT 2F, AND BRANCHES TO BE9C, WHERE
THE INITIALIZATION TAKES PLACE.  BEAE IS THE START OF CODE TO
INITIALIZE A SINGLE TRACK. CALLS TO BA1E AT BEA5 AND BFA7 ARE
TO SWITCH TRACKS DURING INIT. BFA2 TESTS TO SEE IF ALL $22
TRACKS HAVE BEEN INITIALIZED YET, AND IF SO, EXITS RWTS AT
BFB8.  AT BEC7-BECD, BEDC-BEE6, BF43-BF47, BF80-BF87, AND BFCA-
BFCD ARE UNUSUAL COMBINATIONS OF PHA, PLA, AND NOP
INSTRUCTIONS. THESE DO NOTHING EXCEPT PROVIDE SMALL DELAYS
NEEDED FOR TIMING WHILE WRITING DATA.

    THE ROUTINE AT BE3B IS THE START OF THE SEEK TRACK
ROUTINE. IT GETS THE PHASE COUNT FROM THE DCT AND SETS UP THE
PROPER CALL TO BE4C, WHICH TURNS OFF ALL STEPPING MOTOR LINES,
AND BRANCHES TO THE STEPPER ROUTINE AT BA1E.

    FINALLY, FOLKS, AT BE27 IS THE CODE TO CLEAR THE CARRY
FLAG AND RETURN TO THE CALLER OF RWTS BECAUSE ALL WENT OK. IF
ANYTHING WENT WRONG, BE29 IS BRANCHED TO. IT APPEARS THAT BE29
IS IN THE MIDDLE OF A 'BIT' INSTRUCTION AT BE28, BUT THE 'BIT'
INSTRUCTION DOES NOTHING MORE THAN HIDE THE 'SEC' INSTRUCTION
FROM BEING EXECUTED AFTER THE 'CLC'. BE29 SETS THE CARRY FLAG
ON TO INDICATE THAT SOMETHING WENT WRONG.

                  ----- END OF PART ONE -----




                     APPLE II DOS INTERNALS
                     ----- -- --- ---------
                            PART TWO


                      -----SECTION C-----

           DOS MEMORY/DISK ADDRESSES CROSS REFERENCE


    THE FOLLOWING TABLE DESCRIBES WHICH TRACK AND SECTOR
ADDRESSES OF DOS GET LOADED IN WHICH MEMORY ADDRESSES. ALSO
SHOWN IS THE ADDRESS TO WHICH THE ORIGINAL ADDRESS IS
RELOCATED TO ON A 48K APPLE II.  THE FORMAT OF THE DOS IS
SLIGHTLY DIFFERENT, DEPENDING UPON WHETHER IT WAS LOADED TO
THE DISK BY THE UPDATE 3.2 PROGRAM (MASTER) OR WHETHER IT WAS
PLACED THERE BY THE 'INIT'COMMAND (SLAVE).  BECAUSE OF THIS
DIFFERENCE, TWO TRACK/ SECTOR COLUMNS ARE SHOWN IN THE TABLE.
DOS OCCUPIES ALL OF TRACKS 0 AND 1 AND SECTORS 0 TO 8 OR 0 TO
A OF TRACK 2, DEPENDING UPON WHETHER A MASTER OR A SLAVE,
ALTHOUGH THE VTOC MASTER TRACK/SECTOR MAP SHOWS THE ENTIRE TRK
2 MASKED AS UNAVAILABLE.

                MASTER  SLAVE
                DISK    DISK
                TRACK/  TRACK/  LOAD   RELOCATED
                SECTOR  SECTOR ADDRESS  ADDRESS
                ------- ------ ------- ---------
                00 00   00 00   3600    B600
                00 01   00 01   3700    B700
                00 02   00 02   3800    B800
                00 03   00 03   3900    B900
                00 04   00 04   3A00    BA00
                00 05   00 05   3B00    BB00
                00 06   00 06   3C00    BC00
                00 07   00 07   3D00    BD00
                00 08   00 08   3E00    BE00
                00 09   00 09   3F00    BF00
                00 0A   -- --   1B00    ----
                00 0B   -- --   1C00    ----
                00 0C   00 0A   1D00    9D00
                01 00   00 0B   1E00    9E00
                01 01   00 0C   1F00    9F00
                01 02   01 00   2000    A000
                01 03   01 01   2100    A100
                01 04   01 02   2200    A200
                01 05   01 03   2300    A300
                01 06   01 04   2400    A400
                01 07   01 05   2500    A500
                01 08   01 06   2600    A600
                01 09   01 07   2700    A700
                01 0A   01 08   2800    A800
                01 0B   01 09   2900    A900
                01 0C   01 0A   2A00    AA00
                02 00   01 0B   2B00    AB00
                02 01   01 0C   2C00    AC00
                02 02   02 00   2D00    AD00
                02 03   02 01   2E00    AE00
                02 04   02 02   2F00    AF00
                02 05   02 03   3000    B000
                02 06   02 04   3100    B100
                02 07   02 05   3200    B200
                02 08   02 06   3300    B300
                02 09   02 07   3400    B400
                02 0A   02 08   3500    B500

    NOTE THAT DOS ADDRESSES 9600-9CFF DO NOT RESIDE ON DISK.
THE DOS FILE BUFFERS (NORMALLY 3) ARE AT THESE ADDRESSES.

    YOU CAN DETERMINE WHETHER A DISKETTE IS A MASTER OR A
SLAVE BY THE FOLLOWING PROCEDURE: POWER OFF THE APPLE AND
POWER IT UP AGAIN TO CLEAR MEMORY.  BOOT THE DISKETTE IN
QUESTION. ENTER THE MONITOR AND TYPE: *3300<B300.B380V IF THE
AREAS ARE THE SAME (NO LINES ARE PRINTED), THE DISKETTE IS A
MASTER. IF THE AREAS ARE DIFFERENT (MANY LINES ARE PRINTED),
THE DISKETTE IS A SLAVE.



      -----SECTION D----- DISK II DEVICE SELECT ADDRESSES ---

    THERE ARE 16 DEVICE SELECT ADDRESSES RESERVED FOR EACH
SLOT ON THE APPLE II.

    THE DEVICE SELECT ADDRESSES FOR SLOT 6 ARE $C0E0-$C0EF.
IN THE DOS CODE, INSTRUCTIONS ARE CODED AS INDEXED FROM $C080-
$C08F WITH THE INDEX EQUAL TO $10 TIMES THE SLOT NUMBER.

    IMPORTANT NOTE --- IF YOU PLAN TO EXPERIMENT WITH THE
DEVICE SELECT ADDRESSES, MAKE SURE A SCRATCH DISKETTE IS IN
THE DRIVE, AS IT IS EASY TO CLOBBER DATA.

C0E9 - THIS ADDRESS STARTS THE DISK MOTOR. BASIC PROGRAMS CAN
    POKE TO THIS ADDRESS TO START THE DISK BEFORE THEY ISSUE A
    DOS COMMAND TO INCREASE ACCESS SPEED.

C0E8 - THIS ADDRESS, WHEN REFERENCED, TURNS OFF THE DISK
    MOTOR.

C0EA - THIS ADDRESS SELECTS DRIVE 1.

C0EB - THIS ADDRESS SELECTS DRIVE 2.

C0E0-C0E7 - THESE ADDRESSES ARE USED TO PULSE THE HEAD
    STEPPING MOTOR. THESE 8 ADDRESSES OCCUR IN PAIRS. ODD
    ADDRESSES APPLY A VOLTAGE TO A LINE AND EVEN ONES TURN IT
    OFF AGAIN. THERE ARE 4 CONTROL LINES TO THE STEPPING MOTOR
    (SEE P. 145-146). IF THESE ADDRESSES ARE REFERENCED IN
    DESCENDING ORDER, THE HEAD STEPS TO A LOWER TRACK, & VICE-
    VERSA.

C0EC-C0EF - THESE FOUR ADDRESSES CONTROL WHETHER THE DISK II
    CONTROLLER IS TO READ, WRITE, OR RETURN STATUS OF THE
    WRITE/ PROTECT MICROSWITCH. THESE ADDRESSES ARE ALSO USED
    FOR PASSING READ/WRITE DATA IN GROUPS OF 4 BITS. (HALF
    BYTES, OR NYBBLES)

    THESE ADDRESSES ARE REFERENCED IN SETS OF TWO, AND ACT AS
SWITCHES TO THE DISK II CONTROLLER.  FOR EACH DESIRED
FUNCTION, ONE OF THE BYTES C08C OR C08D IS SELECTED ALONG WITH
ONE OF THE BYTES C08E OR C08F.

    HERE IS WHAT THEY MEAN:

C08E,C08C - SET READ MODE AND READ A NYBBLE OF DATA FROM THE
    DISK.

C08D,C08E - SENSE WRITE PROTECT AND RETURN BYTE WITH NEGATIVE
    FLAG SET IF WRITE PROTECTED.

C08C,C08F - WRITE A NYBBLE OF DATA TO THE DISK. C08E,C08F -
    USED IN CONJUNCTION WITH WRITING DATA.



                 -----SECTION E----- DOS ERRATA ---

    THE FOLLOWING ERRORS EXIST EITHER IN THE DOCUMENTATION FOR
DOS 3.2 OR IN THE DOS CODE ITSELF.  PAGE REFERENCES ARE TO THE
DOS 3.2 MANUAL.

PAGE 95 - THE MACHINE LANGUAGE SUB- ROUTINE LISTED DOES NOT
    TEST FOR CARRY FLAG CLEAR, AS INDICATED ON PAGE 97.  SINCE
    THE BASIC PROGRAM CANNOT TEST THE CARRY FLAG, THIS RESULTS
    IN FALSE ERROR INDICATIONS TO THE BASIC PROGRAM.  THE
    ERROR CODE FIELD OF THE IOB IS SET TO THE LAST BYTE OF THE
    BUFFER WHICH WAS JUST READ AND IS NOT RESET TO 00 WHEN NO
    ERROR HAS OCCURRED.

PAGE 130 - THE DOCUMENTATION INDICATES THAT RELATIVE BYTE $22
    INTO THE DIRECTORY ENTRY FOR A FILE IS AN END MARK
    (NORMALLY ZERO) THAT IS CHANGED TO THE TRACK LOCATION OF
    THE TRACK/SECTOR LIST.  ACTUALLY, DUE TO AN ERROR IN THE
    DOS CODE, RELATIVE BYTE $20 GETS THIS FIELD WHICH IS
    COPIED FROM BYTE $00 WHEN A FILE IS DELETED.  THIS ERROR
    IS ONLY IMPORTANT IF ONE WISHES TO RESURRECT A DELETED
    FILE.

APPEND - SEVERAL BUGS EXIST WITH THE DOS CODE THAT HANDLES THE
    APPEND COMMAND.

    1. WHEN THE LAST BYTE OF THE LAST DATA SECTOR IS NON-ZERO
        (I.E., THE LAST DATA SECTOR IS COMPLETELY FULL),
        APPEND ACTS LIKE AN OPEN, AND INSTEAD OF APPENDING
        DATA TO THE END OF THE FILE, DATA IS WRITTEN OVER THE
        START OF THE FILE.  NOTE THAT THE CHANCES OF THIS
        OCCURRING ARE 1 IN EVERY 256 APPEND OPERATIONS.  THIS
        RATHER SERIOUS BUG IS NEW WITH DOS 3.2, AND DID NOT
        EXIST IN DOS 3.1.  DOS 3.2.1 DOES NOT FIX THIS BUG, AS
        DOS 3.2.1 IS SIMPLY A CHANGE TO THE RWTS ROUTINE AND
        ITS ASSOCIATED SEEK ROUTINE.  THERE IS NO
        CIRCUMVENTION FOR THIS BUG, OTHER THAN TO NOT USE
        APPEND.  HOWEVER, THE PRESENCE OF THE BUG CAN BE
        DETECTED IF ONE DOES A READ OPERATION IMMEDIATELY
        AFTER AN APPEND. END-OF-DATA CONDITION SHOULD
        RESULT.  IF IT DOES NOT, THE APPEND HAS JUST BEEN
        TREATED AS AN OPEN.

    2. WHEN APPEND DOES WORK, IT READS EACH AND EVERY DATA
        SECTOR INTO MEMORY.  THIS IS WASTEFUL AND NOT
        NECESSARY AS IT IS ONLY NECESSARY TO READ IN THE LAST
        DATA SECTOR OF THE LAST TRACK/SECTOR LIST.

VERIFY - WHEN VERIFYING A DIRECT ACCESS FILE WHICH CONTAINS
    GAPS IN THE TSL WHICH ARE CAUSED BY NON-WRITTEN DIRECT-
    ACCESS RECORDS, THE VERIFY OPERATION IS TERMINATED
    PREMATURELY AND THE DATA SECTORS AFTER THE GAP DO NOT GET
    VERIFIED.

BSAVE - WORKS OK IN 3.1, BUT IN 3.2 AND 3.2.1, THE NUMBER OF
    BYTES SAVED IS ONE MORE THAN THE LENGTH SPECIFIED IN THE
    COMMAND.  FOR EXAMPLE, IF THE BSAVE COMMAND IS GIVEN WITH
    THE PARAMETERS A$300,L$40, DATA WOULD BE SAVED FROM
    LOCATIONS $300 THROUGH $340, INCLUSIVE (A LENGTH OF $41
    BYTES.) THIS WAS PROBABLY DONE DELIBERATELY TO INSURE THAT
    ENOUGH DATA WAS BSAVED AS OPPOSED TO NOT ENOUGH, BUT KEEP
    IN MIND THAT 4 ADDITIONAL BYTES ARE ALWAYS SAVED WITH THE
    DATA OF A BSAVE (A 2-BYTE ADDRESS AND A 2-BYTE LENGTH).
    THIS MEANS THAT IF YOU SAVED A DATA AREA OF LENGTH 252
    WITH THE BSAVE COMMAND, A 4- BYTE PREFIX WOULD BE SAVED
    WITH IT, FOR A TOTAL OF 256 BYTES.  THIS NORMALLY WOULD
    FIT IN A SINGLE SECTOR, EXCEPT THAT BECAUSE OF THIS BUG,
    AN ADDITIONAL SECTOR WOULD BE ALLOCATED AND WOULD CONTAIN
    NO USEFUL DATA.  WHEN BSAVEING HIRES SCREENS TO DISK, IT
    WILL SAVE AN ENTIRE SECTOR OF DISK PER SCREEN IF A LENGTH
    OF $1FFB IS USED INSTEAD OF THE $2000 WHICH IS USUALLY
    USED.  A HIRES SCREEN THEN TAKES UP ONLY 33 SECTORS (32
    DATA + 1 TSL) INSTEAD OF THE USUAL 34 SECTORS (33 DATA + 1
    TSL).



             -----SECTION F----- MISC. GOODIES ---

    SOME OF THIS IS NOT RELATED TO DOS, BUT IT MAY BE USEFUL
ANYWAY...

    WHEN SAVING BINARY DATA WITH BSAVE, A LENGTH OF $FB WILL
FIT ON A SINGLE SECTOR (NOT INCLUDING THE TRACK/SECTOR LIST
SECTOR) BUT A LENGTH OF $FC WILL TAKE UP AN ADDITIONAL
SECTOR.  IN FACT, A LENGTH GREATER THAN $XXFB WILL ALWAYS TAKE
UP ONE MORE SECTOR. TO SAVE AN ENTIRE SECTOR PER FILE WHEN
SAVING HIRES SCREENS (AT $2000 OR $4000), SAVE THEM WITH A
LENGTH OF $1FFB INSTEAD OF $2000 AS IS USUALLY DONE. THE EXTRA
SECTOR ONLY CONTAINS 4 BYTES WHICH ARE NOT EVEN DISPLAYED ON
THE HIRES SCREEN. USING THIS METHOD MEANS YOU CAN SAVE 12
HIRES SCREENS PER DISKETTE INSTEAD OF ONLY 11 AND STILL HAVE
ROOM FOR A 7 SECTOR PROGRAM TO USE THEM.

    IF YOU'VE EVER ACCIDENTALLY PRESSED RESET WHILE AN INTEGER
BASIC PROGRAM WAS RUNNING, THIS IS FOR YOU. IN THE MONITOR,
ENTER:

    *E3E3G

    AND THE STATEMENT NUMBER WHICH WAS LAST EXECUTED IS
DISPLAYED. PRESS RESET AGAIN AND RE-ENTER DOS WITH *3D0G. THIS
METHOD CAN ALSO BE USED TO FIND THE STATEMENT NUMBER OF AN
OUTSTANDING INTEGER BASIC INPUT STATEMENT.  WHEN THE INPUT
PROMPT OCCURS, PRESS RESET & *E3E3G TO FIND THE STATEMENT
NUMBER. EXITING THE PROGRAM WITH CONTROL-C WILL NOT SHOW THE
STATEMENT NUMBER IF AN INPUT STATEMENT WAS ACTIVE. THIS METHOD
WILL NOT WORK WITH THE AUTO START ROM INSTALLED.

    THE FOLLOWING MONITOR COMMAND WILL PERFORM A BULK MEMORY
CLEAR. SET THE FIRST BYTE OF THE AREA TO THE DESIRED CLEAR
VALUE, AND THEN USE THE MEMORY MOVE COMMAND TO CLEAR THE REST
OF THE AREA.  FOR EXAMPLE:

    *800:00
    *801<800.3FFEM

    WILL CLEAR THE AREA 0800-3FFF TO '00'.

    TO DO A BULK MEMORY VERIFY (TO INSURE THAT A LARGE MEMORY
AREA CONTAINS THE SAME VALUES), USE THE SAME COMMANDS, EXCEPT
USE THE MONITOR 'VERIFY' INSTEAD OF THE 'MOVE'.

    TO REPEAT A MONITOR COMMAND OR A SEQUENCE OF MONITOR
COMMANDS AGAIN AND AGAIN, PRECEED THE COMMANDS WITH 'N' AND
END THE LINE WITH '34:XX ' WHERE 'XX' IS THE DISPLACEMENT IN
THE LINE OF THE MONITOR COMMAND WHICH IS TO BE REPEATED. NOTE
THE BLANK AFTER 'XX' WHICH MUST BE TYPED BEFORE 'RETURN'. FOR
EXAMPLE:

    *N 800L L 34:7

    WOULD CAUSE INSTRUCTIONS STARTING AT 0800 TO BE
DISASSEMBLED. THE 2ND 'L' WOULD BE REPEATEDLY INVOKED.  THIS
IS USEFUL WHEN DISASSEMBLING TO A PRINTER AND NOT WANTING TO
TYPE A WHOLE BUNCH OF L'S.



           -----SECTION G----- SECTOR SKEW FACTOR ---

    IT IS GENERALLY KNOWN THAT THERE EXIST 13 SECTORS OF 256
BYTES ON EACH TRACK OF THE DISK II.  THESE 13 SECTORS DO NOT,
HOWEVER, FOLLOW EACH OTHER IN A SIMPLE ASCENDING ORDER AROUND
THE DISK.  IN FACT, THE ACTUAL PHYSICAL ORDER OF THE SECTORS
ON A NORMALLY INITIALIZED DISK IS AS FOLLOWS:

    0,10,7,4,1,11,8,5,2,12,9,6,3,0.

    THIS ORDER MAY SEEM AT FIRST TO BE RANDOM, BUT UPON CLOSER
INSPECTION, IT CAN BE SEEN THAT THE SECTOR NUMBER IS THE
NUMBER OF THE PREVIOUS SECTOR +10 MODULO 13.  WE SHALL REFER
TO THIS ATTRIBUTE AS SECTOR SKEW FACTOR, THE SECTOR SKEW
FACTOR IN THIS EXAMPLE HAVING THE VALUE 10. THE PURPOSE OF
THIS SKEW FACTOR IS TO ALLOW FOR PROCESSING TIME DURING THE
READING OF DISK DATA BEFORE THE NEXT SEQUENTIAL SECTOR APPEARS
UNDER THE DISK READ HEAD.

    FILES ARE NORMALLY ALLOCATED ON DISK STARTING WITH SECTOR
$0C AND ALLOCATING IN DESCENDING ORDER TO SECTOR $00. THE DOS,
ITSELF IS ALLOCATED ON DISK ON TRACKS 0, 1, AND 2 IN ASCENDING
SECTOR ORDER. WHEN THE DOS IS BOOTED, SECTORS ARE READ IN
ASCENDING ORDER, I.E, FROM SECTOR $00 UP TO SECTOR $0C.
BECAUSE DOS BOOT DATA AND FILE DATA ARE RECORDED IN OPPOSITE
ORDER, IT WOULD BE EXPECTED THAT VARYING THE SKEW FACTOR WOULD
HAVE AN OPPOSITE EFFECT ON THE PERFORMANCE OF BOOT AND READING
NORMAL DOS FILES. THIS IS, IN FACT, TRUE.

    THE FOLLOWING CHART SHOWS HOW BOOT TIME AND FILE READ TIME
VARY WITH DISKS RECORDED WITH DIFFERENT SKEW FACTORS.  ALL
TIMES ARE IN SECONDS AND THE FILE READ TIME WAS FROM A BLOAD
OF A 130 SECTOR FILE.

                  SKEW      BOOT    FILE READ
                  FACTOR    TIME       TIME
                  ------    -----   ---------
                    1       10.1        27
                    7        3.8        25
                    9        4.5        23
                   10        5.2        21
                    8        5.8        19
                   11        6.2        17
                    2        6.7        15
                    5        7.1        36
                    3        7.6        35
                    4        8.0        34
                    6        8.5        32
                   12        9.1        31

    NOTE THAT BOOT TIME IS MINIMUM AT SKEW FACTOR 7 AND FILE
READ TIME IS MINIMUM AT SKEW FACTOR 2.  ALSO NOTE THAT THE
DEFAULT SKEW FACTOR, 10, ACCOMPLISHES NEITHER MINIMUM BOOT
TIME OR MINIMUM FILE READ TIME, BUT IS INSTEAD A COMPROMISE
BETWEEN THE TWO. ONE COULD INITIALIZE DISKS WITH SKEW FACTORS
DIFFERENT THAN THE DEFAULT TO ACCOMPLISH DIFFERENT GOALS. IF
ONE WANTED TO HAVE VERY FAST SYSTEM BOOT AT THE EXPENSE OF
SLOWER FILE READ TIMES, HE COULD USE A SKEW FACTOR OF 7.
HOWEVER, A FAST SYSTEM BOOT, BECAUSE OF THE INFREQUENCY OF
BOOT, IS OF DOUBTFUL BENEFIT.  IT IS USEFUL, HOWEVER, TO SET
THE SKEW FACTOR TO 2 TO CAUSE FILE READS AND PROGRAM LOADING
TO PERFORM THE FASTEST, AT THE EXPENSE OF SLIGHTLY SLOWER
BOOT. ONE CAN CHANGE THE SKEW FACTOR, BY SETTING LOCATION
$BF62 (NORMALLY $0A) TO THE DESIRED SKEW FACTOR AND THEN
INITIALIZING A NEW DISK.  THE NEW DISK WILL HAVE THE DESIRED
SKEW FACTOR AND FUTURE DISKS INITIALIZED USING THE DOS OF THIS
MODIFIED DISK WILL ALSO HAVE THE NEW SKEW FACTOR. IT SHOULD BE
NOTED THAT IF ONE WISHES TO COPY THE DISK WITH THE MODIFIED
SKEW FACTOR, THE COPY PROGRAM NEED ALSO BE CHANGED, OR THE
COPY WILL BE OF THE DEFAULT SKEW FACTOR OF 10.

                   ----- END PART TWO -----



                     ----- PART THREE -----


          -----Section H----- Dos Booting Process ---
                              by Ted Burns

          [from The Apple Orchard, March/April issue.]

    The disk booting process is done in three stages. Stage 1
is done by the code on the disk controller card located at
Cn00 (where N is the slot of your disk controller). This reads
in track sector 0 (0,0) from the diskette.  This information
is scrambled due to code space limitations on the boot PROM.

    The very last 2 bytes of sector (0,0) are in normal
format.  They are used as parameters to the second stage boot
routine.  After this CODE is loaded into page 3 ($300.$3FF),
the disk controller software then jumps to location $301.  The
code at location $301 performs the second stage boot.

    The SECOND stage boot reads in from disk, sectors (0,0) to
(0,N) where n is specified by the last byte of sector (0,0).
That last byte is equal to N*8. So to find out how many
sectors to load, we divide this byte by 8. Normally, a value
of $48 is assigned to this byte, which is equal to 9 sectors.
Tracks (0,2) through (0,9) on the diskette contain the code
for the RWTS (Read Write Track Sector) routines which get read
by the second level boot routine.

    The second to the last byte in (0,0) contains the page
number minus one of where the code is located that boots in
the rest of the DOS.  Normally, this byte is a $B6 for a 48k
Apple system. This means that the second stage boot routine
will jump to memory location $B700. This code, which gets
loaded into $B700, is located on (0,1) on the diskette. The
second stage boot procedure can be modified by the user to put
substitute code for the RWTS, although this is risky unless
you know what you are doing.

    The THIRD stage boot is DOS defined and we can change it
whenever we want. Normal Apple DOS builds a special table
called the I.O.B. This table is read by the RWTS routines
which specify desired TRACK/SECTOR, DRIVE, READ/WRITE MODE,
SLOT and other important parameters needed to operated the
disk.  Some description of the I.O.B. is described in the
Apple II DOS 3.2 manual. Finally it jumps to $9D84 at which
point DOS takes over (for 48k).

    The disk controller card collects 5 bits at a time from
the diskette and passes it to the computer.  This 5 bit chunk
of data is a nybble. A set of routines called DOS core
routines are located from $B800 to $BC77 (in the RWTS). These
routines convert normal data to nybblized format & vice versa.

    Since a nybble has five bits of data, there are 32
different data nybbles. Two specified nybbles ($DA & $AA) are
NOT data nybbles. These nybbles are used to format the
diskette.

    A sector consists of 2 parts: An address mark and a data
mark.  The address mark contains addressing information like
track, sector, volume number and sync data. The DATA mark is
the data sector where the disk data is actually stored.  Each
data sector has 430 nybbles which correspond to the 256 bytes
which get stored on the diskette.

    To write a sector, we must first PRE-NYBBLIZE our data
into a form where it gets stored onto the diskette. The RWTS
routines automatically do this so we never have to worry about
it. Each chunk is then indexed by a table located a $BC9A in
ram. It then gets stored into a buffer located somewhere
around $BAAA to $BB00. An ADDRESS MARK can be broken down into
the following:

    1. Sync nybble -- This is a mark on the diskette which
marks the beginning of the address mark.

    2. Two special nybbles, ($D5, $AA) are used to check for
proper sync.

    3. Mark type nybble --($B5) follows this special sync
information.

    4. Mark information -- Track, sector, volume number of
this location.

    5. Checksum -- An error detecting nybble which checks for
possible bit errors.

    6. End mark -- Marks the end of the address mark block of
data.

    The Data mark is where 256 bits of data are kept.  This
accounts for approximately 430 nybbles of data.


                   ----- End part three -----

DOS Internals information:    (part four)

Thanks to Christian Menteel, 13 Nutting Ave., Amherst, Mass. 
01002 (tel. 413-549-4379). In the states until June 8.  
Further info provided by Steve Hain. (SLH@AI).  Edited and 
reformatted by Bill Blue. (BLUE@MC)

"MAXFILES 1" lifts HIMEM about 1K to 9AA6

"CATALOG" -> JSR A56E

BLOAD, BSAVE, DELETE -> Similar JSR's, after putting the 
filename and parameters in the proper locations (possibly 
AA75; see the code at AB28-ABDC)

Command Parser and I/O Package can be removed.

Can zap Initializations (B600-B7FF) (not entirely true in 3.3)

Can zap Error messages at A6D2-A850 and A971-AA3D

Leave RWTS alone (B800-BFFF)

Decrease DOS, relocate and append to interpreter. It must be 
able to boot itself and the interpreter into memory from a 
boot disk.

From the Article: 
     (much of this appeared in MICRO, Sept-79 --Web)

(Note: Information is for DOS 3.2, but most should apply to 
DOS 3.3, except RWTS has been completely changed.)

Boot from master diskette:  Loaded to 3600-3FFF, then 1D00-
3FFF. Relocates to 9600-BFFF

Page 3 Entry points (we can ignore, but they'll show us 
addresses that  might be useful):

     03D0 Restart DOS, saving curent BASIC program
     03D3 Restart DOS, killing current BASIC program
     03D6 Enter DOS I/O Package
     03D9 Enter RWTS Subroutine
     03DC Load Y,A with end of system address buffer plus 1
     03E3 Load Y,A with DOS I/O Bloack address
     03EA Pass to and install in DOS the addresses of the 
          I/O routines in use, and reconnect DOS I/O.


DOS Mainline code (9600-BFFF):

     9600-9CFF User file buffers:

     9600-9852 User file buffer #3 - we can ignore 
               this after "MAXFILES 1"

     9853-9AA5 User file buffer #2 - we can ignore this after 
               "MAXFILES 1"

     9AA6-9CF8 User file buffer #1:

     9AA6-9BA5 Current data sector

     9BA6-9CA5 Current Track/Sector List (TSL) sector

     9CA6-9CF8 Miscellaneous:

     9CA6-9CD2 ??

     9CD3-9CF0 File name of buffer's file (first byte 0 if 
               file closed)

     9CF1-9CF2 Address of section 1 of this buffer

     9CF3-9CF4 Address of section 2 of this buffer

     9CF5-9CF6 Address of section 3 of this buffer

     9CF7-9CF8 Address of next buffer's file name (0 if this 
               is last buffer)

     9CF9-9CFF Unused

     9D00-9D83 DOS address constants

     9D1E-9D55 DOS Command branch vectors (addresses minus 1; 
               INIT, LOAD, etc.)

     9D84-A883 System code section

     A229-A60D Individual DOS Commands:

               A229 PR#
               A233 MON
               A251 MAXFILES (call originally)
               A271 LOCK
               A27D VERIFY
               A298 APPEND
               A2EA CLOSE
               A35D BLOAD (we should call directly)
               A397 SAVE
               A4D1 RUN
               A510 WRITE
               A54F INIT
               A57A FP
               A5C6 EXEC
               A22E IN#
               A23D NOMON
               A263 DELETE (we should call directly)
               A275 UNLOCK
               A281 RENAME
               A2A3 OPEN
               A331 BSAVE (we should call directly)
               A38E BRUN
               A413 LOAD
               A4F0 CHAIN
               A51B READ
               A56E CATALOG (we should call directly)
               A59E INT
               A5DD POSITION

     A6D2 DOS Error processing routine (entered with error 
          code in A)

     A702 Prints appropriate error message

     A851 Character-in and Character-out switches

     A884-AAFC Data area for system section

     A884-A907 Command names (28.) High bit set on last 
               character of each name.

     A909-A940 Operand descriptions for commands (28.) Two 
               bytes each:

     Bit descriptions:

          8000 If operand is omitted, pass command to BASIC
          4000 File name is optional
          2000 File name is allowed
          1000 Two file names are required
          0800 Operand must be within range 0-7.
          0400 Operand must be within range 1-16.
          0100 File name need not exist
          0080 I, O, C allowed
          0040 V allowed
          0020 D allowed
          0010 S allowed
          0008 L allowed
          0004 R allowed
          0002 B allowed
          0001 A allowed

     A941-A94A Ten single-character operands 
               (V,D,S,L,R,B,A,C,I,O)

     A94B-A954 Ten operand masks for above (high bit clear 
               means a numeric is asssociated with the operand)

     A955-A970 Minimum and maximum values of parameters 
               (V,D,S,L,R,B,A)

     A971-AA3D Ascii text for DOS error messages

     AA3F-AA4F Index table for error messages

     AA53-AA54 Address of user's character output routine

     AA55-AA56 Address of user's character input routine

     AA57      Number of buffers specified by MAXFILES

     AA5C      DOS Error code location

     AA60-AA61 Length of last file BLOADed

     AA72-AA73 Address of last file BLOADed

     AA68      Default drive number

     AA6A      Default slot number

     AA75      Last file name used in a DOS command (initially 
               the greeting program!)

     AAB8-AAC0 The word "APPLESOFT"

     AAC1-AAC2 Address of DOS I/O Block

     AAFD-B396 I/O Package

     AE39      A JSR which causes a pause before CATALOG, is 
               not  necessary

     B397-B6FF Data area including system buffer

     B397      Track and sector of the directory (catalog) 
               sector most recently read

     B3A7      Six file type characters: T, I, A, S, R (what's 
               the seventh??)

     B3AF-B3BA Ascii string "DISK VOLUME" stored in reverse 
               order

     B3BB-B4BA Master track/sector bit map sector or Volume 
               Table of Contents (VTOC)

     B4BB-B5BA Number of the last directory sector accessed

     B5BB      First byte beyond the system buffer

     B700-B7DE Code, including RWTS entry

     B7B5      Start of RWTS Routine (Read or Write a Track 
               and Sector)

     B7DF-B7FF Data area, including IOB and DCT

     B7E8 DOS I/O Block (IOB)

     B7FB Device Characteristics Table (DCT)

     B800-BA8F Code

     BA90-BAFF Data area

     BB00-BCB9 RWTS nybble buffers

     BD00-BFFF Mainline RWTS code


Boot Process Overview:

Stage 1: The code at C600 (Disk controller ROM) reads Track 0, 
         Sector 0 from disk into memory at 300, then jumps to 
         301;

Stage 2: The code at 301 reads Track 0, Sector 0 through Track 
         0, Sector 9 from disk into memory at B600 (48K slave) 
         or 3600 (48K master) and jumps to B700 (slave) or 
         3700 (master);

Stage 3: The code at B700 or 3700 reads Track 0, Sector A 
         through the last used sector of Track 2 (into memory 
         at what location??) and jumps to it.

Relocation: If a Master: The code at 1B00 relocates DOS; if a 
         Slave: the code at 9D84 initiates DOS processing of 
         the greeting program.

Modifications to DOS should also be written onto the disk on 
which DOS is stored, at the correct track and sector locations 
(use Disk Zap, Diskpak 6-B).

Binary greeting program: set 9E42 to 34

Eliminate pause during CATALOG: set AE39-AE3B to EA EA EA

Other miscellaneous notes: --Web

Dos 3.3 zeroes location $E000 on the language card during a 
boot, forcing you to reload the card every time.  At $BFD3 in 
Dos 3.3.A, the 'STA' instruction has been changed to a 'BIT' 
($2C), so that the language systems contents are preserved.  
To make this change on a master or slave disk, modify track 2, 
sector 9, byte $D3 from the current $8D to a $2C. [Tom Neff]
