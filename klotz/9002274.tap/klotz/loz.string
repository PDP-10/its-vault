Date: Tue, 17 Feb 87 18:14:10 EST
From: "Leigh L. Klotz" <KLOTZ@AI.AI.MIT.EDU>
Subject:  object-oriented conference paper review
To: mcvax!inria!cointe@SEISMO.CSS.GOV
cc: KLOTZ@AI.AI.MIT.EDU, mcvax!cmirh!pc@SEISMO.CSS.GOV
Message-ID: <155563.870217.KLOTZ@AI.AI.MIT.EDU>

Henry Lieberman gave me the "Turtlekit" paper to review.  He had
mailed me a copy but it apparently never arrived.  Last week he gave me
another copy.

I cannot recommend the Turtlekit paper for inclusion in this conference.
The ideas it presents in turtle graphics are not new.  Danny Hillis's
AI Lab Memo "Ten Things to Do with a Better Computer" gives a basic
description of an object-oriented turtle graphics system, but more
significantly, the ideas were around before then.  The paper describes no
new ideas in turtle graphics and presents little new information on
object-oriented programming in Scheme.

One of the best fits of solution to problem domain in computer science
is that of object-oriented programming to graphics systems; in particular,
turtle graphics, with its turtle object with local state, is particularly
suited to an object oriented approach.  Almost any implementation of
turtle graphics in an OOPS is likely to look like a textbook example.

---
TurtleKit describes a mechanism for turtle graphics wherein each turtle is
a procedure which accepts "messages" and looks up the definitions on an
internal alist.

A special message adds messages to the alist; some hair is necessary here
to make sure the LAMBDA which is to be put on the alist closes over the
turtle's environment rather than the definition-message senders
environment.  It seems to me that this is a mildly interesting issue, yet
the paper glosses over it.

To avoid alist lookups the TurtleKit supplies a METHOD message which
returns the result of the lookup operation, allowing the definition
program to cache the method handler for the operation.  Of course,
procedures which use such cached methods will not make use of further
redefined message names.

TurtleKit does indeed allow redefinition or re-specification of message
names.  The one interesting idea I see in the paper comes in this section
(section 5).  In order to both redefine a message and allow the new
message to call the old message, TurtleKit lets the user use the METHOD
message described above to cache-in the old message handler for use in the
new function.  In some other object-oriented systems (Flavors) this
operation is fairly difficult.  In Gary Drescher's Object Lisp, a special
"USUAL" operation takes a message name and executes the old method.  In
TurtleKit, it is easy and natural to access the old method definition
using the METHOD operation and to keep track of the definition using
Scheme's lexical scoping.

The "Turtle Appearences" section (6) describes an elegant means of
describing turtle shapes.  It is not, however, new.  Jeremey Rochelle's
MIT bachelor's thesis describes a graphics system for Boxer which uses
generalized turtles to provide shape definitions.  It further caches the
vector operations involved to speed up the drawing process.  Turtle
graphics systems from long ago have used turtle graphics to draw the
turtle triangle internally, but did not give access to these functions for
shape definition.

The two-page listing of the instance variables of the 3600 Common Lisp
listener window is superfluous.
---
The implementation is fairly simple and clean; however, as I said before,
turtle graphics lends itself so well to the object-oriented paradigm that
such an object-oriented implementation almost suggests itself.

Drescher's Object Lisp system and the Coral Software Object Logo
derivative are prior implementations of a more interesting combination
turtle graphics and object-oriented programming.  SCOOPS, for example,
is just one of many interesting object-oriented programming systems in
Scheme.  The main advantage of TurtleKit is its simplicity, and the degree
to which it approaches unadorned Scheme code.  Indeed, if you used the Scheme
ACCESS primitive instead of alist lookup, and used Scheme environments
instead of alists, the TurtleKit system would nearly disappear.  The
section 5 method of accessing a shadowed message handler, for instance,
requires no special procedures or macros, but instead is simply a
programming paradigm.

