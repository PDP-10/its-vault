

>cd ../bin

>cat info
apropos| This is the apropos command. Type "apropos foo bar baz" to find out about commands "foo",
apropos| "bar",and "baz". If you discover that a command you feel useful is not here,
apropos| feel free to add it, being careful to preserve the syntax of the file.
apropos| Please send me mail before changing something which is already here.
apropos| Leigh Klotz. (KLOTZ)
cal| cal month year
cal| no month defaults to whole year.
chmod| Change the read/write mode of a file.
chmod| 1 - execute/search
chmod| 2 - write
chmod| 4 - read
chmod| These are added together to get three digits for the file mode. The
chmod| executing files, and search is for directory listings.
chmod| first digit is the owners privileges, the second is for people in the
chmod| owners group, and the third is for users in general. Execute refers to
df| default devices are rdk32, rdv0, and rdv1 (?)
df| df [filesystem]
dmesg| print system error messages.
dsw| delete interactively -- type delete key to remove file.
dsw| dsw [dirname]
foo| Foo is an example name. List the file "/sub/student/klotz/bin/info to
foo| to see the WHOLE thing. Do apropos apropos to before adding documentation.
grep| Pattern matching program.
grep| grep [-v] [-b] [-c] [-n] <string> [file] ...
grep| Looks in file (or s.i.) and prints out lines (or number of occurences)
grep| on which a particular string occurs.
grep| Options:
grep| b - block number
grep| c - count matching lines
grep| n - print line number of matching lines
grep| v - print lines which don't match
hmu| found in /sub/student/mp/bin. returns the number of users.
lisp| Command line (i.e. when you start lisp) options.
lisp| f=###### or free=######: set free cons cell storage to number of bytes.
lisp| The default (8000 bytes) is usually enough, but (backtrace t)=>"no free
lisp| storage" can be fixed with a new lisp free=123456 or such.
lisp| gl: Causes all prog labels to be global.
lisp| Leigh: Put in other options here, such as g, a, etc.
mips| measure system performance
mips| real and virtual speed in millions of (inc r1) instructions per second.
mips| virtual time takes into account a system loading factor.
msgp| In /mnt/odonnell/.search. Tells who is accepting messages. With an arg,
msgp| tells if that user is in am mode.
print| Print is a filter optimized for decwriter use. When printing out
print| files on a decwriter -- especially lisp code -- use print, as it
print| is faster. In /mnt/odonnell/.search/print
primes| max arg is 2^56, or 7.2x10^16. -- This program is a loss.
primes| primes
primes| takes input, then prints out primes less than input.
ps| THE LINES IN THIS ITEM ARE OUT OF ORDER. WILL BE FIXED SOON. -llk
ps|       10-being swapped  20-being traced by another process
ps| Command / arguments.
ps| Event for which sleeping or waiting
ps| O-nonexistent   S-sleeping      W-waiting       R-running       Z-terminated
ps| Priority of process -- high is low priority
ps| Process id of process
ps| Size in blocks of core image
ps| T-stopped
ps| User id of process owner
ps| flags 01-in core        02-system process    04-locked in code for phys.io
ps| p  -akix namelist
ps| state of the process
sort| b - leading blanks/tabs not included in keys
sort| d - only letters, digits, and blanks are significant in comparisons. Dictionary.
sort| example: sort -t\: +2n /etc/passwd sorts password file by userid.
sort| f - fold lower case into upper case
sort| i - ignore non-printing, non-blank characters in non-numeric comparisons.
sort| sort [ -mubdfinrtX ] +pos -pos -o name name
sort| tX-x is tab char. between fields.
time| elapsed time during the command, to second
time| time command
time| time spend in execution, to 1/60th second
time| time spent in system, to 1/60th second
tty| returns the ttynumber in the form tty#
who.old| A shorter form of who, which also takes less time.

>cd ../lo\o\isp

>cat diff
||| -*- LISP -*-
||| Differentiation

(defun infix (exp) |Takes binary and unary expressions only.
       (cond ((null exp) nil)
             ((atom exp) exp)
             ((eq (length exp) 2) (cons (car exp)
                                      (infix (cdr exp))))
             (t (list (infix (cadr exp))
                      (car exp)
                      (infix (caddr exp))))))

(defun prefix (exp)
       (cond ((null exp) nil)
             ((atom exp) exp)
             ((eq (length exp) 2) exp)
             ((member '+ exp)
              (list '+ (prefix (before '+ exp)) (prefix (after '+ exp))))
             ((member '* exp)
              (list '* (prefix (before '* exp)) (prefix (after '* exp))))
             ((member '- exp)
              (list '- (prefix (before '* exp)) (prefix (after '* exp))))
             ((member '/ exp)
              (list '/ (prefix (before '/ exp)) (prefix (after '/ exp))))
             (t exp)))

(defun after (op exp)
       (cond ((null exp) ())
             ((equal (car exp) op) (cdr exp))
             (t (after op (cdr exp)))))

(defun before (op exp)
       (cond ((equal op (car exp)) nil)
             (t (cons (car exp)
                      (before op (cdr exp))))))

(defun simplify (epî       (cond ((atom exp) ex)     IB        ((eq (Ocar expIBIBOIB) '+)
        O      (coIBOnd ((eq (adr exp) 0) (caddr exp))
                   ((eq (caddr eIBOxp) 0) (cadr exp))
 IBO                   ((and (numberp (cadr exp)) (numberp (caddr exp)))
                     (+ (cadr exp) (caddr exp))î                    ((eq (cadr exp) (caddr exIBOIBOp)) (list '* 2 (cadr exp)))
                    (t exp)))
             ((eq (car exp) '*)
              (cond ((eq (cadr exp) 0) 0)
                    ((eq (caddr exp) 0) 0)
                    ((eq (cadr exp) 1) (caddr exp))
                   ((eq (caddr exp) 1) (cadr exp))
    IBO                ((and (numberp (cadr exp)) (numberp (caddr exp)))
                     (* (cadr exp) (caddr exp)))
                    (t exp)))
             ((or
               (eq (car exp) 'sin)
               (eq (car exp) 'cos)
               (eq (car exp) 'tan))
              (cond ((numberp (cadr exp)) (eval exp))
                    (t exp)))


             (t exp)))




(defun d (exp var)
       (setq var (caddr (explode var)))
       (diff exp))

(defun diff (exp)
       (cond ((null exp) nil)
             ((atom exp)
              (cond ((eq exp var) 1)
                    (t 0)))
             ((eq (car exp) '+)
              (simplify (list '+ (diff (cadr exp)) (caddr exp))))
             ((eq (car exp) '*)
              (simplify (list '+
                              (simplify (list '*
                                              (diff (cadr exp))
                                              (caddr exp)))
                              (simplify (list '*
                                              (diff (caddr exp))
                                              (cadr exp))))))
             ((eq (car exp) 'sin)
              (list '*
                    (list 'cos (cadr exp))
                    (diff (cadr exp))))
             ((eq (car exp) 'cos)
              (list '*
                    (append '(- 0) (list 'sin (cadr exp)))
                    (diff (cadr exp))))
             ((eq (car exp) 'tan)
              (list '* (list '* (list 'sec (cadr exp))
                             (list 'sec (cadr exp)))
                    (diff (cadr exp))))))

>cat alisp
IBOIBIBOIBOIBOIBOIBOIBOIBOIBOcat: not found

>^Q


>cat alisp
||| -*-LISP-*-
||| Leigh L. Klotz, Jr. '83, 6.031 Section 5, Prof. Papadimitriou, Bier TA


|Routines like arsetq, etc. should go here.


(defun arcar (i)
             (aref AR i))

(defun arcdr (i)
       (aref DR i))

(defun aratom (i)
       (null (aref AR i)))

(defun arnull (i)
       (or (and (null (arcar i)) (null (arcdr i)))
           (and (= 99 (arcar i)) (= 99 (arcdr i)))))

(defun areq (i j)
       (and (= (arcar i) (arcar j))
            (= (arcdr i) (arcdr j))))

(defun arrplacd (i j)
       (cond ((aratom i) (error_handler '(ERROR: First argument to arrplacd is atomic.)))
             (t (aset j DR i) |Change cdr pointer in list to point to other structure.
                j)))          |Return the new cdr.

(defun arrplaca (i j)
       (cond ((aratom i) (error_handler '(ERROR: First arg to arrplacd is atomic)))
             (t (aset j AR i)
                j)))

(defun arcons (i j)
       (cond ((no_free_cons_cells_p) (error_handler '(ERROR: No free cons cells.))) |A garbage collection routine would be better, but.
             (t (setq c-cell f) |Place for new object.
                (setq newf (arcdr f)) |New beginning of free cons cell list.
                (aset i AR c-cell)    |New object has i for a car
                (aset j DR c-cell)    |and j for a cdr.
                (setq f newf)         |Reflect change in free cons cells.
                c-cell)))))           |Return number of new cons.


(defun no_free_cons_cells_p ()
       (= f 99))

(defun error_handler (message)
       (princ message)
       '*)

(defun gc_setup ()
       (aset nil AR 99)
       (aset nil DR 99)
       (setq f 0)
       (do ((i 0 (add1 i)))
           ((= 98 i))
           (aset 99 AR i)
           (aset (add1 i) DR i)))))

(defun argetal (n) |printout what is stored in cells up to n.
       (do ((i 0 (add1 i)))
           ((= i n))
           (princ i) (princ '\->) (princ (arcar i)) (princ '!) (print (arcdr i))))

(defun atom-intern (atm) |Doesn't do checking for no free storage.
       (setq fsave (arcdr f))
       (aset nil AR f)
       (aset atm DR f)
       (setq f fsave)
       (sub1 f))

(setq arnil 99)
(setq AR (make_array 't '(100)))
(setq DR (make_array 't '(100)))
(gc_setup)
(print 'FOO)


>l
total 27
   5 -rw-r--r--  1 klotz    2241 Dec  2 16:47 alisp
   7 -rw-r--r--  1 klotz    3454 Dec  2 16:47 diff
  10 -rwxr-xr-x  1 klotz    4590 Dec  2 16:48 graph
   5 -rwxr-xr-x  1 klotz    2323 Dec  2 16:48 gtest1

>who
-Name-       -tty- ----time----     -location-
zarmer       tty5  Dec  3 00:04     38-344 VT-52
klotz        ttyk  Dec  3 01:02     Dialup 30CPS x8-6058
dobbs        ttyl  Dec  2 17:03     Dialup 30CPS x8-6058
robertso     ttym  Dec  3 00:01     Dialup 30CPS x8-6058

>