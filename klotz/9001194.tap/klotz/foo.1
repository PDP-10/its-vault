
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by  on Thu Apr  9 15:40:19 CDT 1987
# Contents:  README README.SPOOL Makefile laser-prep-12.pro laser-prep-40.pro
#	laser-prep-49.pro maclaser.csh psfilter.csh psmac.csh macfilter.csh
#	paintps.c ps8.c paintps.1 maclaser.1
 
echo x - README
sed 's/^@//' > "README" <<'@//E*O*F README//'

     This shell archive contains a program called paintps which will convert
a MacPaint file (uploaded from a Mac) to PostScript for printing on a
LaserWriter.  It reads a plain MacPaint document as input and produces 
postscript output in the same style as that produced by the 1.1 version
of the Mac LaserWriter driver.  Paintps runs on unix and will automatically
spool its output for printing if no output redirection has been done.
The advantage of paintps is that MacPaint pictures are usually less than
25K, while the resulting PostScript often exceeds 100K.  This obviously
reduces the file transfer time.

     Also included are several versions of the LaserPrep file, slightly
modified from Apple's versions, and a shell script called maclaser, which is
called by paintps to spool its output.  Maclaser is simply a front end to lpr,
and depends on the spooler setup described in the file README.SPOOL.
     
     This code has been used with 4.2 and 4.3BSD; vaxen, Sun and Sequent
hardware.  We use the TranScript package from Adobe to drive the LaserWriter.
If you're using some other set of PostScript drivers, the spooler hacks
are basically the same, since there are no changes to the drivers themselves.

     Paintps is distantly related to a program called paintimp, originally
written by Dave Johnson at Brown University.  It converted MacPaint pictures
to Impress for printing on Imagens.  Ron Hitchens at the University of
Texas hacked on it a bit and added some features.  When we got a LW,
Brian Powell at UT was inspired to do something similar for PostScript.
The resulting paintps is very different from paintimp, but paintimp did
provide the structure and a few subroutines.  Maclaser and the spooler hacks
were conceived by Ron Hitchens' twisted mind.

     There are several different critters in this distribution.  They 
probably won't all want to live in the same place.  A makefile is included
for paintps, mainly because it was already there.  Use your local customs
for determining where things should go.  "macfilter.csh" in particular, needs
to know several specific paths.  You also should put the proper paths at the
bottom of the man pages, if they are different from what we use.

     NOTE:  Maclaser can print PostScript generated by any Macintosh program,
not just MacPaint.  (See the man page for maclaser for details.)  Currently,
it supports output from three different versions of the LaserWriter driver:
version 1.1 (which came with Finder 4.1), 3.1 (Finder 5.3), and 3.3 (Finder
5.4).  
     You do not have to have the LaserWriter printer driver on the Macintosh
to use paintps, but for other programs where you generate the PostScript on
the Macintosh, you have to use one of the above versions.
     I try to keep this software update with the new versions of the
LaserWriter driver.  I always try to continue supporting the old versions when
possible, but that isn't always feasible.  When System 4.1 comes out, I may
have to stop supporting the 3.3 LW driver.

-------------------------
Brian Powell	brian@sally.utexas.edu
Ron Hitchens	hitchens@sally.utexas.edu

Updated April 9, 1987.
@//E*O*F README//
chmod u=rw,g=r,o=r README
 
echo x - README.SPOOL
sed 's/^@//' > "README.SPOOL" <<'@//E*O*F README.SPOOL//'

   Paintps depends on the "Mac environment" being present in the LaserWriter
at the time its Postscript output is processed.  This environment is setup
by the laser-prep prolog file which is prepended by the Mac print drivers
when a Mac prints directly to a LaserWriter.  Since paintps basically
mimics what MacPaint does when it prints a file on a LW, something needs
to be done to provide the Mac environment in the LW with the Unix system.

   The same applies to any "Mac PostScript" file produced on a Mac and
captured with the Command-F sequence and then uploaded to a Unix machine.
The remaining discussion concerns printing Mac files to a LaserWriter
being driven by a Unix (4.2 or 4.3 BSD) spooler and which is primarily
used for general text processing, not for Mac output.  The output of
paintps is considered a "Mac file", even though it's produced on a
Unix system, and is included in the general discussion below.

   The first step is to get the laser-prep prolog file, so that it can be
sent to the LW via the spooler.  The laser-prep file must be modified
for use with the spooler.  There are two reasons why.
	1) The standard laser-prep installs itself permanently, on the
	   assumption that the LW is living in a Mac-only universe.  The
	   amount of memory it consumes is substantial and we aren't
	   willing to give it away to accomodate the occasional Mac
	   job sent via the Unix spooler.  Removing a few specific lines
	   at the beginning which escape from the server loop is
	   sufficient to prevent permanent residency.
	2) The encrypted smoothing function in the laser-prep is fed
	   as stdin to an eexec command which will read until eof.  Since
	   what we're trying to accomplish is to have the laser-prep only
	   live for the duration of a single job, this presents a problem.
	   Luckily the eexec command will also accept a string argument
	   on the stack, so by placing hex quotes (<>) around the smoothing
	   code and calling eexec after it has been placed on the stack,
	   we get the same effect plus the ability to continue sending
	   PostScript code afterwards.  Hence, we can simply concatenate
	   the modified laser-prep and the Mac PostScript file and send
	   it to the printer, the Mac environment will be there for the
	   job and will be flushed afterwards.  [We recently learned that
	   there are ways to work around this.  We don't understand how they
	   work; they just do.  You might examine the version 49 Prep to see
	   the solution there. -- BHP]
   This also allow us to support more than one version of the LaserWriter
driver.  Since the laser-prep won't be in the LW RAM, we can prepend any
laser-prep without causing a conflict.

   Now, there are a couple of ways to handle a Mac PostScript job via
the Unix spooler.
	1) On the front end of the spooler thru lpr, such as:
		paintps foo.mp > foo.ps
		cat /usr/local/lib/laser-prep-40.pro foo.ps | ps8 | lpr -Plw
	   This is the most generic and doesn't require anything special
	   be done on the unix system.  The drawbacks are that a current
	   copy of the laser-prep must be present on every system that might
	   spool a job, that users know where it is, and that they know
	   the proper incantations.  A shell script could be written to
	   hide the above commands, but that still requires multiple
	   copies of the laser-prep file.
	2) In the back end of the spooler, by having a filter automatically
	   prepend the laser-prep to all Mac PostScript jobs.  This is 
	   the most elegant way to handle it, since only one copy of the
	   laser-prep need exist on the system where the printer is, and
	   the details of handling Mac specific files are hidden from
	   the user.  This method requires selecting a "file type" for
	   spooling Mac jobs and specifying the proper handlers on the
	   system where the printer is.  At UT we chose the "Fortran"
	   file type, since it was unused.  Others could be used but
	   there aren't many candidates, especially if you already
	   support ditroff and/or TeX.  We handle spooling of Mac files
	   with a shell script which simply calls lpr and adds the -f
	   file type flag.

   The discussion below assumes the reader is familiar with how the 
Berkeley spooler works and knows how to setup filters.  The person
who does this must have super-user access anyway.  Once again there
are two ways to go about setting up your spooler to handle Mac PostScript
files:
	1) If you're using the standard Transcript setup, use the psmac
	   shell script included.  Put it in /usr/local/lib, or where
	   you keep the rest of your filters, and put its name in the
	   printcap slot for whichever file type you use (the rf field
	   is for the Fortran type, go figure).  You also need to put the
	   macfilter shell script in the same directory.
	2) If you're using an Imagen-style shell script which is called
	   by several different names, use our psfilter (included) as
	   a guide and include a case for handling Mac files as shown.
	   This approach is kind of odd, and can lead to various problems,
	   but allows more flexibility and enables you to do things
	   like complex pipelines and problem notification.  Psfilter
	   is what we use at UT, you may or may not find it useful.
	   In any case you can ignore the local hacks for dealing
	   with LaserWriters on Bridges (unless you have some; I might
	   be able to help).  The macfilter shell script should reside in
	   the same directory.

   The program ps8, named in macfilter, does nothing more than convert any
non-printable characters in the data stream to the octal equivalent.  Apple
broke the rules and used non-printable characters (specifically non-ascii >
128) for certain symbols.  These don't survive the unix device driver (they
lose the high bit) and raw mode is not possible because the LW needs to use
flow control.

   Here is the /etc/printcap we use here at UT:
#
#
# Apple LaserWriter
# sb MUST be specified, psof depends on it.  psof prints job header page.
# rw must be specified, printer talks back to psif

lw-generic|Apple Laserwriter:\
	:rw:br#9600:ff=:tr=^D:sc:sb:\
	:of=/usr/local/lib/psof:\
	:df=/usr/local/lib/psdvi:\
	:nf=/usr/local/lib/psditroff:\
	:tf=/usr/local/lib/pscat:\
	:if=/usr/local/lib/psasc:\
	:cf=/usr/local/lib/psbad:\
	:gf=/usr/local/lib/psbad:\
	:vf=/usr/local/lib/psbad:\
	:rf=/usr/local/lib/psmac:

Lazarus|lw1|lw|lazarus|LW connected to im4u:\
	:lp=/dev/lw:sd=/usr/spool/lw1:\
	:xs#040400:fc#070:fs#00302:\
	:lf=/usr/adm/log-lw1:\
	:af=/usr/adm/lw.acct/lw1:\
	:tc=lw-generic:
-------------------
Ron Hitchens	University of Texas at Austin, Computer Science
hitchens@sally.utexas.edu
hitchens@ut-sally.UUCP

Updated April 9, 1987:
Brian H. Powell		brian@sally.utexas.edu
@//E*O*F README.SPOOL//
chmod u=rw,g=r,o=r README.SPOOL
 
echo x - Makefile
sed 's/^@//' > "Makefile" <<'@//E*O*F Makefile//'
SRCS= paintps.c
OBJS= paintps.o
COMMANDS= paintps
CFLAGS= -O
BIN= /usr/local
MAN= /usr/man/manl

SPOOLCMD= "maclaser"

all: $(COMMANDS)

paintps: paintps.c
	$(CC) $(CFLAGS) paintps.c -o paintps '-DSPOOLCMD=$(SPOOLCMD)'

install: $(COMMANDS)
	install -s -m 0775 paintps ${DESTDIR}/${BIN}
	install -c -m 0444 paintps.1 ${DESTDIR}/${MAN}

clean:
	rm -f *.o a.out core $(COMMANDS)
@//E*O*F Makefile//
chmod u=rw,g=r,o=r Makefile
 
echo x - laser-prep-12.pro
sed 's/^@//' > "laser-prep-12.pro" <<'@//E*O*F laser-prep-12.pro//'
%!Laser Prep version 12.  
% Decompiled with rekamr and then cleaned up and slightly modified
% for downloading over rs232 by Alan Crosswell,  Columbia U.
% Modification to eexec to work when cat'ed with a data file.  This
% version is not installed permanently, must precede each Mac file.
% Ron Hitchens, Brian Powell - U of Texas Austin.

%{appledict version #12
/md 200 dict def md begin
/av 12 def
/mtx matrix currentmatrix def
/s30 30 string def
/s1 ( ) def
/pys 1 def
/pxs 1 def
/pyt 760 def
/pxt 29.5 def
/por true def
/xl{translate}def
/fp{pnsh 0 ne pnsv 0 ne and}def
/vrb [
{fp{gsave 1 setlinewidth pnsh pnsv scale stroke grestore}if newpath}
{eofill}
dup
{newpath}
2 index
dup
{initclip eoclip newpath}
{}
dup
2 copy
] def
/xdf{exch def}def
currentscreen /spf xdf /rot xdf /freq xdf
/doop {vrb exch get exec} def
/psu{2 index .72 mul exch div /pys xdf div .72 mul /pxs xdf /pyt xdf /pxt xdf /por xdf}def
/txpose{dup 1680 eq userdict /note known{{legal}{note}ifelse}{pop}ifelse
dup 1212 eq{54 32.4 xl}if 1321 eq{8.64 -.6 xl}if
pxs pys scale pxt pyt xl por not{270 rotate}if 1 -1 scale}def
/obl {{0.212557 mul}{pop 0} ifelse} def
/sfd {[ps 0 ps 6 -1 roll obl ps neg 0 0] makefont dup setfont} def
/fnt{findfont sfd}def
/bt{1 index and 0 ne exch}def
/sa 6 array def
/fs{1 bt
    2 bt
    4 bt
    8 bt
   16 bt
   sa astore pop
}def
/mx1 matrix def
/mx2 matrix def
/gf{currentfont}def

/tc{32768 div add 3 1 roll 32768 div add 2t astore pop}def
/3a [0 0 0] def
/2t 2 array def
/tp{3a astore pop}def
/ee{}def
/tt{gsave currentpoint 2 copy 2t aload pop qa 2 copy xl 3a aload pop exch dup 0 eq
{pop}{1 eq{-1 1}{1 -1}ifelse scale}ifelse rotate pop neg exch neg exch xl moveto}def
/te{currentpoint currentfont grestore setfont moveto}def
/tb{/tg currentgray def 3 -1 roll 3 eq{1 setgray}if /ml 0 def /al 0 def}def
/am{ml add /ml xdf}def
/aa{[currentgray /setgray cvx]cvx exch dup wi pop dup al add /al xdf exch}def
/th{3 -1 roll div 3 1 roll exch div 2 copy mx1 scale pop scale /scaleflag true def}def
/tu{1 1 mx1 itransform scale /scaleflag false def}def
/ts{1 1 mx1 transform scale /scaleflag true def}def
/fz{/ps xdf}def
/fx{dup exec}def
/st{show pop pop}def
/tm{
      {
      dup type dup /integertype eq exch /realtype eq or
         {
         dup ml mul
         }
         {
         dup type /stringtype eq
            {
            rs
            }
            {
            dup type /dicttype eq
               {
               setfont
               }
               {
               dup type /arraytype eq
                  {
                  exec
                  }
                  {
                  pop
                  }ifelse
               }ifelse
            }ifelse
         }ifelse
      }forall
   }def
/es{3 -1 roll dup sa 5 get dup type /nulltype eq
{pop4 pop}
{
sa 1 get {/ml ml .2 ps mul sub def}if  %Italic Hack Hack Hack
   ne{fs}{pop}ifelse exch
   dup 1 eq
   {pop
      al ml gt{/tv{ll}/ml ml al dup 0 ne{div}{pop}ifelse def}{/tv{st}/ml 1 def}ifelse def
      tm
   }
   {
   dup 3 eq
   {pop
   al ml gt{/tv{ll}/ml ml al dup 0 ne{div}{pop}ifelse def}{ml al sub 0 rmoveto /tv{st}/ml 1 def}ifelse def
      tm
   }
   {
   2 eq
   {
   al ml gt{/tv{ll}/ml ml al dup 0 ne{div}{pop}ifelse def}{ml al sub 2 div 0 rmoveto /tv{st}/ml 1 def}ifelse def
      tm
   }
   {
   /tv{ll}def
   /ml ml al dup 0 ne{div}{pop}ifelse def
      tm
   }ifelse}ifelse}ifelse
   }ifelse
tg setgray
}def

/pop4 {pop pop pop pop} def
/gm{scaleflag{mx1 itransform}if moveto}def
/ly{exch pop currentpoint exch pop sub 0 exch rmoveto}def
/page{1 add /#copies xdf showpage}def
/sk{systemdict /statusdict known}def
/jn{sk{statusdict /jobname 3 -1 roll put}{pop}ifelse}def
/pen {/pnsv xdf /pnsh xdf pnsh setlinewidth} def
/dlin{currentpoint newpath moveto lineto currentpoint stroke grestore moveto}def
/lin {currentpoint /pnlv xdf /pnlh xdf gsave newpath /@y xdf /@x xdf fp{pnlh @x lt {pnlv @y ge
{pnlh pnlv moveto @x @y lineto pnsh 0 rlineto
0 pnsv rlineto pnlh pnsh add pnlv pnsv add lineto pnsh neg 0 rlineto}
{pnlh pnlv moveto pnsh 0 rlineto @x pnsh add @y lineto 0 pnsv rlineto
pnsh neg 0 rlineto pnlh pnlv pnsv add lineto} ifelse} {pnlv @y gt
{@x @y moveto pnsh 0 rlineto pnlh pnsh add pnlv lineto 0 pnsv rlineto
pnsh neg 0 rlineto @x @y pnsv add lineto} {pnlh pnlv moveto pnsh 0 rlineto
0 pnsv rlineto @x pnsh add @y pnsv add lineto pnsh neg 0 rlineto
0 pnsv neg rlineto} ifelse} ifelse
closepath fill}if @x @y grestore moveto} def
/barc {/@f xdf /@op xdf /@e xdf /@s xdf /@r xdf
/@b xdf /@l xdf /@t xdf gsave
@@r @l add 2 div @b @t add 2 div xl 0 0 moveto
@@r @l sub @b @t sub mtx currentmatrix pop scale @f {newpath} if
0 0 0.5 @s @e arc
mtx setmatrix @op doop grestore} def
/doarc {dup 0 eq barc} def
/doval {0 exch 360 exch true barc} def
/dorect {/@op xdf currentpoint 6 2 roll newpath 4 copy
4 2 roll exch moveto 6 -1 roll lineto lineto lineto closepath
@@op doop moveto} def
/dorrect {/@op xdf 2. div /@h xdf 2. div /@w xdf
/@r xdf /@b xdf /@l xdf /@t xdf
@@t @b eq @l @r eq or{@t @l @b @r @op dorect}
   {
   @r @l sub 2. div dup @w lt{/@w xdf}{pop}ifelse
   @b @t sub 2. div dup @w lt{/@w xdf}{pop}ifelse
   @op 0 eq{/@w @w pnsh 2 div sub def}if    %this helps solve overlap gap for wide line widths
   currentpoint
   newpath
   @r @l add 2. div @t moveto
   @r @t @r @b @w arcto pop4
   @r @b @l @b @w arcto pop4
   @l @b @l @t @w arcto pop4
   @l @t @r @t @w arcto pop4
   closepath @op doop
   moveto
   }ifelse
} def
/pr{gsave newpath /pl{moveto /pl{lineto}def}def}def
/pl{lineto}def
/ep{dup 0 eq
   {
   {moveto}{lin}{}{}pathforall  %nothing but movetos and linetos should be called
   pop grestore
   }
   {
   doop grestore
   }ifelse
}def
/bs 8 string def
/bd{/bs xdf}def
/bit {bs exch get exch 7 sub bitshift 1 and} def
/bix {1 add 4 mul cvi} def
/pp{exch bix exch bix bit}def
/grlevel {64. div setgray} def
/setpat {/bs xdf 9.375 0{pp}setscreen grlevel} def
/setgry {freq rot {spf} setscreen grlevel} def
/x4 {2 bitshift} def
/d4 {-2 bitshift} def
/xf {.96 mul exch 2 sub .96 mul exch} def
/dobits
{
/bmode xdf
save 9 1 roll
   {
   x4 /@dy xdf 2 sub x4 /@dx xdf /@idx xdf
   .96 mul exch 2 sub exch xl 0 0 moveto xf
   0 2 2 index 4 index 1.759 add 10 dorect clip newpath 0 0 moveto scale
   bmode 0 eq bmode 4 eq or{1 setgray 1 @dy div 1 @dx div 1 1 2 dorect}if
   bmode 3 eq bmode 7 eq or{1}{0}ifelse setgray
   @idx 5 bitshift @dy bmode 4 eq bmode 5 eq bmode 7 eq or or [@dx 0 0 @dy 0 0]
     {(%stdin)(r) file @dy d4 4 add @idx mul string readhexstring pop
     dup length @idx x4 sub 4 bitshift string
     dup 3 1 roll @dx 8 add d4 smooth} imagemask
   }
   {
   /@dy xdf 2 sub /@dx xdf /@idx xdf
   /@xs @idx string def
   /@f (%stdin)(r) file def
   /@p{@f @xs readhexstring pop}def
   .96 mul xl 0 0 moveto xf scale
   0 0 1 1 10 dorect clip newpath 0 0 moveto
   bmode 0 eq bmode 4 eq or{1 setgray .25 @dy div .25 @dx div 1 1 2 dorect}if
   bmode 3 eq bmode 7 eq or{1}{0}ifelse setgray
   @p @p
   @idx 3 bitshift @dy bmode 0 eq bmode 1 eq bmode 3 eq or or [@dx 0 0 @dy 0 0]
   {@p} imagemask
   @p @p pop4
   }ifelse
restore
} bind def

/mfont 14 dict def
/wd 14 dict def
/mdef {mfont wcheck not{/mfont 14 dict def}if mfont begin xdf end} def
/dc {transform round .5 sub exch round .5 sub exch itransform} def
/cf{{1 index /FID ne {tmp 3 1 roll put}{pop pop}ifelse}forall}def
/mv{tmp /Encoding macvec put}def
/bf{
mfont begin
/FontType 3 def
/FontMatrix [1 0 0 1 0 0] def
/FontBBox [0 0 1 1] def
/Encoding macvec def
/BuildChar
  {
  wd begin
    /cr xdf
    /fd xdf
    fd /low get cr get 2 get -1 ne
    {
    fd begin
      low cr get aload pop
      sd
      low cr 1 add get 0 get
      sh
      sw
    end
    /sw xdf
    /sh xdf
    sw div /clocn xdf
    dup 0 ne {0 exch sh div neg dc xl}{pop}ifelse
    exch sw div /coff xdf
    exch sw div /cloc xdf
    /bitw clocn cloc sub def
    sw sh div 1 scale
    sw div 0 coff 0 bitw coff add 1 setcachedevice
    coff cloc sub 0 dc xl
    cloc .5 sw div add 0 dc newpath moveto
    bitw 0 ne
      {0 1 rlineto bitw .5 sw div sub 0 rlineto 0 -1 rlineto
        closepath clip
      sw sh false [sw 0 0 sh neg 0 sh]{fd /hm get}imagemask}if
    } if
  end
  } def
end
mfont definefont pop
} def
/wi{save exch /show{pop}def
stringwidth 3 -1 roll restore}def
/aps {0 get 124 eq}def
/apn {s30 cvs aps} def
/xc{s30 cvs dup}def
/xp{put cvn}def
/scs{xc 3 67 put dup 0 95 xp}def
/sos{xc 3 79 xp}def
/sbs{xc 1 66 xp}def
/sis{xc 2 73 xp}def
/sob{xc 2 79 xp}def
/sss{xc 4 83 xp}def
/dd{exch 1 index add 3 1 roll add exch} def
/smc{moveto dup show} def
/kwn{dup FontDirectory exch known{findfont exch pop}}def
/fb{/ps ps 1 add def}def

/mb
{dup sbs kwn
   {
   exch{pop}{bbc}{} mm
   }ifelse
sfd
}def
/mo
{dup sos kwn
   {
   exch{pop}{boc}{} mm
   }ifelse
sfd
}def
/ms
{dup sss kwn
   {
   exch{pop}{bsc}{} mm
   }ifelse
sfd
}def
/ao
{dup sos kwn
   {
   exch dup ac pop
   {scs findfont /df2 xdf}{aoc}{} mm
   }ifelse
sfd
}def
/as
{dup sss kwn
   {
   exch dup ac pop
   {scs findfont /df2 xdf}{asc}{} mm
   }ifelse
sfd
}def
/ac
   {
   dup scs kwn
      {exch /ofd exch findfont def
      /tmp ofd maxlength 1 add dict def
      ofd cf mv
      tmp /PaintType 1 put
      tmp definefont}ifelse
   }def
/mm{
/mfont 10 dict def
mfont begin
/FontMatrix [1 0 0 1 0 0] def
/FontType 3 def
/Encoding macvec def
/df 4 index findfont def
/FontBBox [0 0 1 1] def
/xda xdf
/mbc xdf
/BuildChar { wd begin
  /cr xdf
  /fd xdf
  /cs s1 dup 0 cr put def
  fd /mbc get exec
  end
} def
exec
end
mfont definefont} def
/bbc
{
  /da .03 def
  fd /df get setfont
  gsave
    cs wi exch da add exch
  grestore
  setcharwidth
  cs 0  0 smc
    da  0 smc
    da da smc
     0 da moveto show
} def
/boc
{
  /da 1 ps div def
  fd /df get setfont
  gsave
    cs wi
    exch da add exch
  grestore
  setcharwidth
  cs 0  0 smc
    da  0 smc
    da da smc
     0 da smc
  1 setgray
     da 2. div dup moveto show
} def
/bsc
{
  /da 1 ps div def
  /ds .05 def %da dup .03 lt {pop .03}if def
  /da2 da 2. div def
  fd /df get setfont
  gsave
    cs wi
    exch ds add da2 add exch
  grestore
  setcharwidth
  cs ds da2 add .01 add 0 smc
      0 ds da2 sub xl
      0  0 smc
     da  0 smc
     da da smc
      0 da smc
  1 setgray
      da 2. div dup moveto show
} def
/aoc
{
  fd /df get setfont
  gsave
    cs wi
  grestore
  setcharwidth
  1 setgray
  cs 0 0 smc
  fd /df2 get setfont
  0 setgray
  0 0 moveto show
}def
/asc
{
  /da .05 def
  fd /df get setfont
  gsave
    cs wi
    exch da add exch
  grestore
  setcharwidth
  cs da .01 add 0 smc
      0 da xl
  1 setgray
      0 0 smc
  0 setgray
  fd /df2 get setfont
      0 0 moveto show
}def

/mf{gsave
32 760 xl 1 -1 scale
1 1 pen
128 152 moveto
27.5 27.5 693.5 522.5 0 dorect
6 6 pen
63. 63. 657. 486. 0 dorect
48 fz F /|B---1Times fnt pop
(Manual Feed)show
118 275 moveto
14 fz F /|----1Times fnt pop
(document: )show
sk{statusdict /jobname get dup null ne{show}{pop}ifelse}if
118 362 moveto
(Manual Feed Instructions)show
127 398 moveto
(1.  Wait until the yellow light on the front of your)show
145 416 moveto
(LaserWriter comes on steadily \(not flashing\).)show
127 458 moveto
(2.  Insert your paper or envelope in the manual feed)show
145 478 moveto
(guide on the right side of the LaserWriter.)show
127 517 moveto
(3.  Repeat steps 1 and 2 until your document is)show
145 537 moveto
(completed.)show
0 page
sk{statusdict /manualfeed true put 5 dly}if
grestore}def
/dly{
usertime exch 1000 mul add
   {
   dup usertime le{exit}if
   }loop
pop
}def
/lsf {FontDirectory {pop dup apn{= flush}{pop}ifelse}forall /* = flush}def
/dl{gsave 0 setlinewidth 0 setgray}def

/T true def
/F false def
/6a 6 array def
/2a 2 array def
/5a 5 array def
/qs{3 -1 roll sub exch 3 -1 roll sub exch}def
/qa{3 -1 roll add exch 3 -1 roll add exch}def
%multiply point: pt factor qm newpt
/qm{3 -1 roll 1 index mul 3 1 roll mul}def
/qn{6a exch get mul}def
/qA .166667 def /qB .833333 def /qC .5 def
/qx{
   6a astore pop
   qA 0 qn qB 2 qn add   qA 1 qn qB 3 qn add
   qB 2 qn qA 4 qn add   qB 3 qn qA 5 qn add
   qC 2 qn qC 4 qn add   qC 3 qn qC 5 qn add
}def
/qp{6 copy 12 -2 roll pop pop}def
/qc{qp qx curveto}def
/qi{{4 copy 2a astore aload pop qa .5 qm newpath moveto}{2 copy 6 -2 roll 2 qm qs 4 2 roll}ifelse}def
/qq{{qc 2a aload pop qx curveto}{4 copy qs qa qx curveto}ifelse}def
/pt{gsave currentpoint newpath moveto}def
/qf{gsave eofill grestore}def
/tr{currentgray currentscreen bs 5a astore pop /fillflag 1 def}def
/bc{/fillflag 0 def}def
/ec{
   1 and 0 ne
   {currentgray currentscreen bs 5a aload pop bd setscreen setgray 0 doop bd setscreen setgray}
   {newpath}ifelse
}def
/bp{currentpoint newpath 2 copy moveto currentgray currentscreen bs 5a astore pop}def
/eu{
   fillflag 0 ne
   {
   gsave currentgray currentscreen bs
   5a aload pop bd setscreen setgray
   4 ep
   bd setscreen setgray
   }if
   fp{0 ep}{grestore newpath}ifelse
}def

/sm
{
dup 0 exch
{32 eq{1 add}if}forall
}
def
/ll
{
3 1 roll exch dup .0001 lt 1 index -.0001 gt and
{pop pop pop}
{sub dup 0 eq
   {
   pop show
   }
   {
   1 index sm dup 0 eq 3 index 0 le or
      {
      pop length div
      0 3 -1 roll ashow
      }
      {
      10 mul exch length add div
      dup 10 mul 0 32 4 -1 roll 0 6 -1 roll awidthshow
      }ifelse
   }ifelse
}ifelse
}def
/ss
{  /pft currentfont def sa aload pop pop /|----2Symbol 4 1 roll
   {pop{as}}
   {{{ao}}{{fnt}}ifelse}ifelse
   exch pop exec exch pop
}def
/pf{pft dup setfont}def
/rs
{
   sa 2 get
   {
   gsave
   1 index 0
   currentfont
   dup /FontInfo known
      {
      /FontInfo get
      dup /UnderlinePosition known
         {
         dup /UnderlinePosition get 1000 div ps mul
         }
         {
         ps 10 div neg   %15 makes line closer to text
         }ifelse
      exch
      dup /UnderlineThickness known
         {
         /UnderlineThickness get 1000 div ps mul
         }
         {
         pop
         ps 15 div       %20 makes slightly narrower line
         }ifelse
      }
      {
      pop
      ps 10 div neg   %15 makes line closer to text
      ps 15 div       %20 makes slightly narrower line
      }ifelse
   setlinewidth
   0 setgray
   currentpoint 3 -1 roll sub moveto
   sa 4 get{gsave currentlinewidth 2. div dup rmoveto currentpoint xl 2 copy rlineto
   stroke grestore}if
   sa 3 get sa 4 get or 3 1 roll 2 index{gsave 1 setgray 2 copy rlineto stroke grestore}if
   rlineto{strokepath 0 setlinewidth}if stroke
   grestore
   }if
   tv
}
def

/macvec 256 array def
macvec 0
/Times-Roman findfont /Encoding get
0 128 getinterval putinterval macvec 39 /quotesingle put
 /dotlessi /grave /circumflex /tilde /cedilla /registerserif /copyrightserif /trademarkserif
macvec 0 8 getinterval astore pop
 /Adieresis /Aring /Ccedilla /Eacute /Ntilde /Odieresis /Udieresis /aacute
 /agrave /acircumflex /adieresis /atilde /aring /ccedilla /eacute /egrave
 /ecircumflex /edieresis /iacute /igrave /icircumflex /idieresis /ntilde /oacute
 /ograve /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis
 /dagger /ring /cent /sterling /section /bullet /paragraph /germandbls
 /registersans /copyrightsans /trademarksans /acute /dieresis /notequal /AE /Oslash
 /infinity /plusminus /lessequal /greaterequal /yen /mu /partialdiff /summation
 /product /pi /integral /ordfeminine /ordmasculine /Omega /ae /oslash
 /questiondown /exclamdown /logicalnot /radical /florin /approxequal /Delta /guillemotleft
 /guillemotright /ellipsis /space /Agrave /Atilde /Otilde /OE /oe
 /endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright /divide /lozenge
 /ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright /fi /fl
 /daggerdbl /periodcentered /quotesinglbase /quotedblbase /perthousand /Acircumflex /Ecircumflex /Aacute
 /Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex
 /apple /Ograve /Uacute /Ucircumflex /Ugrave /dotlessi /asciicircum /asciitilde
 /macron /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
macvec 128 128 getinterval astore pop
FontDirectory
{exch dup s30 cvs /@s xdf @s aps
   {pop pop}
   {exch dup length dict /tmp xdf
      cf
      /Symbol ne {mv} if
      /@i false def /@o false def /@b false def
      mark @s (Italic) search {/@i true def} if (Oblique) search {/@o true def} if
      (Bold) search {/@b true def} if (Roman) search pop (-) search pop /@s xdf cleartomark
      @s cvn dup /Symbol eq{pop 50}{/Courier eq{51}{49}ifelse}ifelse
      s30 0 @s length 6 add getinterval dup 6 @s putinterval dup 0 (|-----) putinterval
      @b {dup 1 66 put} if @i @o or {dup 2 73 put} if % @o {dup 2 79 put} if
      dup 5 4 -1 roll put
      cvn tmp definefont pop
   }ifelse
}forall
/_--C-2Symbol /Symbol findfont /tmp 1 index maxlength 1 add dict def cf tmp /PaintType 1 put tmp definefont
/|----4Seattle /Helvetica findfont dup length 1 add dict /tmp xdf cf mv
/mxv [/zero /one /two /three /four /five /six /seven /eight /nine /comma /period /dollar /numbersign
/percent /plus /hyphen /E /parenleft /parenright /space] def
tmp /Metrics 21 dict dup begin mxv{600 def}forall end put
tmp begin /FontBBox FontBBox [0 0 0 0] astore def end
tmp definefont pop
/od{txpose 10 fz 0 fs F /|----3Courier fnt pop}def
/op{/scaleflag false def /pm save def}def
/cp{pm restore}def
end
%
% eexec reads the PSHX resources
%currentfile eexec
<652E29AE551935C9A82086907FB876D510EC4D451220E0F80D63DBC0EA379346
C055B673F7BED773F332BDE5107DC0B1322DF36267320C226DBEBD9299B29C86
5D1876ABB7E19F6A45F52C588810FD0A9FFBB1073AD1B6BDCA3D2BAE3283AC88
35259ADDA98433676B8B757B19473F2C0C3D36AF93B3DD15AFC47F4D3BECB87B
ABAAB5613FCD319A712E7D4A8C5A3C0BA96A376CC93C52ABDE43A980670C1E6B
78E4D14D5CA032FE07255D5E5A084CCF4B8E23C64F574932EA53E8CD7F00F47B
4179A6DAFE3BC43B1D091902E6E4B5699C7322FC23B5FBE833E4114C4544E29E
6225A5B48E6F2A840F44E827681E1AC9F28EB8FEC32105CA4056D863BCAECE65
1AAF3B12BC38A77CA241A66FAE92939A6EFACD49711E5D7355E634041C378FFC
1F3BF8B903E5F8961E7480259EB0AA90B0C38E75D264ACE71F1307D4894BFDCF
9C9D0F3C026BA190A3F6F7E06F3ED092E8CF0D4F22AD6C55C6FED836290F9611
442BF4DEDBBA0B67D2AF782A796D474ECE7B2B788B4771D4BBCDF0E8F48A2874
D1CF78D3B1C5AA2987C6A22135B1508C7C5EC5AD86ABAE8D1E34A5314F703337
C7A2C0CF52DBBF046F0BD67BE5E65AAD9CE43FAB6E7C9F669801849C9366E5AE
76C77D8DDBF188CD18C120FEA4C1B510FC00434A2629BB82A9336EB36A5D5552
F4971ED40EF839771762E60509A2A3214DEA9C58C2E53E76CE24B99E3C472719
C66B31A38DE21135FF1390CCA7E0F6B92CEEAF9524317A427DA7CB9B4ED08BF0
9868FCD9ECAAFF2C520E0EAAB8730FD6CE85B4ACAEE82FC53C5D948C8858A8A3
CF945546556FB3DC9CE69D87BD793DAC57E3F4FB9D056C163C3EE134EDDF7B7D
186C9A0D79759CD9BF94A4B1E2A6070727DFC08806828B53799090725D4B2D6E
9BCB6C2B90AA4E47D1774F3A58868E4EB3464C7FB07854CE66E3AB03A5D515A1
69AC0EA62BAE9A2A419C9AAB14F09A864F4228A098FB288B60E87B85EB16A6D4
EF27B835BAC40E45BF48F78E6CE74AE0C1E81316F630BFE0D7661116B6A92187
9A1036437280BDA64F85CB37CA0DDBF827C3E4885F1C75E3C84CB8EBED892810
450DA08029A611AEE126FD6BEFF6830EDA28E4C54649D93C23270703B2F7FEAA
A6524192A2D7F1151B2827EF4B27C823D385EA683F024299B1EFE64871AFD4CD
6C54C484AA53030CC7F8254BF9E525A00E51867660A3409BECA98DEB37A568F6
D1026ECBFCCF8C9B9BFD11CE017CB2271E7BDEE1D459FFA23062D5B42552C04B
9BC02C0D7F5CC926ABE694A185FDE2ECC76506DEF1435CBC1225475E4D98A04C
2CF1DD03915DEB659BC23DE29A6E6734CF49CE39A1BF450A55B0F14D350E79B0
5C690B84003AB669678B3A416828F376F78946C44009A14A49ED90980B6E4589
56D188D9AC3FA7F781C8670C83B403B73237B6B0C2862C51C33D559C005D6C9D
D39914B79DBE81291EF8D7CE3EC844176FB7C08A6F344E26C0563C29FCC3B0CB
2CCCF9412832300CBCDE6BFF39A8804ACCB8375752EEECB1BBA0851ED8DF9E17
4A5C747E354402DE217C6A7DE35BDE29F50284F66EC5F9DC0032FE3E05842472
6F9E50555FCBEFF246264D503DCFEB5C5F3384798E5C622FD0450DC62DCE36CA
9007DBA236A7CE56A57C0B0C531AC5766684DE4BDD2DFEC3BA4D99B930B2EDB2
0C2AC0F032BB6E5C75AF97AE24DD7FF33FA0F643BBB39331E7E4A474ED5612A1
7AEF558F8281D4E9EC01AC3D04C4A4C4B8A67F7A6199BA35448298E177554A20
81DFA1E8D1BC88BDB9938CFEC498918BF3AD690924F295A03D17F28C5FF47F43
D495B74827BD54A2524F53750D4C030843986C97B59A63E08EFB9B14582088BA
FC257BCEF07F2E4B8DCADCC9FAEF7388055483470D5FA4A8CE8CC118CA91FAA5
B0DCCC7F3638A2F9F40628186990C2EE0E25B0FB34DAD8521A6735485ADBE4DD
7A937036C5EF7E741FF4543FDEE19DD0CFF59A89656F80F8E5E84C10878CB651
0DD3C3C7A346AC1877FFA88E5ADDCFF95D37163A5350AA5C71BB801ACB0D0FA1
154DE2C2D039CAAB85F389554044E8F90F9992DEBCCBEACE55F69E31061FB052
A25343ECBEDE16C8999218AF370378901B36655D83D4B9BC5F4F43B361BB2134
3A88E0350E5C4342407DEFA79877B3C5DAFE15B0F58520FDBE5B8362BE3549AE
03BD77CDFEC962C539252312ECC5D841F55BEBAD9F7BB03A2D2CAC844E82A568
7CB2D8E599E356D9A23802439B056F1CC104F9F0D3F01EE2593C59483154FCCA
3973F487593C9DE94FC0863B6669100B46AFC5B261493A4B50CB9F802EBC31AB
7B7903A1957EA078A0C4D90E204E44335131C9B65F15D3E5C9A87ADAA7FE5E49
D3654F021F460E5E2AC56A69E8F50E45B0D859D8EC27333DF2AE409015973D7E
ED59F45720DD271D081F3DF62032358E0D4B1D4A528FB4E96A6B2007E13E55E2
10DAED32AF76F3396D60295D116EC4EE4D42DF4BC764ED9BC11A369FE070815F
FEB5662551561354788EFA98612D09BC964428767E0CBE5DC3EC5B599E9B2074
AA3D446752A4E34485C3D111034676AF67EE5345263E883CF46C8BEF1BD4D51D
D2B625481880254888AB0C186E2D0549F657E59026E2A3C49FE0DFD2A2CAD076
586B6F248C11E81C41F9525A5D2F77CE5D76FD9104F39F4E4E31CF75045A9061
B16B20CDC2AFD0595F5B6ADF45CA0DC6A37C4ED090AADCFE9EA7847217777A8E
88C7FBC247EC02973EF656BF1A4A2E71ED21142EC48CC9FDBF5EAE8B46C3E477
59D9C304C6862D43AF1DE66B44B4AC18B47C6518FA5747D3D8C9A19612DAEE4E
83C141561421A1360FD847997148932568D3E6CA93BF0D5874BCD90A3A363739
1FAD35F574797D6160BD4F1AEC3A326D5D73C9BD699C41524B18BC6CDF9169E7
51FFAB19B9FD7ABE3B2F9D3E0F67ADB05CA85D484ACBC84E287DAA1EDC3BCD95
694EF05F77A59004B1C3E223AA4A5A063EC238B4A5A25D335FA51B165963621F
57B7F2C54E59CFED574370399A03E2DFB0F1E35678A6A509A912ED27AD755C67
E045CC1CFEFE41CAD8EA73DD666757D90170EF9C3F218120F38FC1D38224160E
7F5DE6BDF39665FF231079296B94A7DE674847D299C711E77C9DA408FF9CDCFA
8F7FE175BE275EB0AE21512D074DBDDCF1CDF75642EF656E2555F9F3E60A2822
F214CC81EEF0E4866387799F21B1F4B296E7F3A2206795457A33E85B397A5F20
10809D1F43B2267BD762A6CC12DF31BB0817496FE666A6955CD2BA96549B4D1F
827E54A835ABA03B1079F1F5C3C4D2F4F698D3C235BDFA829F079A0DCF788913
77B31EBACF4E61A01487ED1F80ABBF5CF000B1EAA8527EC6064AB06B921916CB
65045B86E9BB2D2E854C5124C218B6FDA0732ABF424EE1696BC86F8987E48CC5
038C8A557E9534A48E7C55F21F021AA7A370A7CC1B55E777972883433F454450
D18ABFC489D5AA518171884FB7103D92E479ECAEA449341F7C8DB1BD39ECB1ED
45AF5D9628EF37CAF8DB3C9A65856A97FB9698DD68F8BE27B3C4174F1838C7A0
674A9460333A059BF214C0690F35BC0352AF9B82CB0F46EAE63A3C0302B4118D
9E65479030F1EFE34909FA458E31A500483B68601B480D51B7FFCD004A1B5360
905B88019BC3EF0FF064AC6477442573C18EF7090E2C08EAA1A9>
eexec
@//E*O*F laser-prep-12.pro//
chmod u=rw,g=r,o=r laser-prep-12.pro
 
echo x - laser-prep-40.pro
sed 's/^@//' > "laser-prep-40.pro" <<'@//E*O*F laser-prep-40.pro//'
%!
%0000000000
% (c) CopyRight Apple Computer, Inc. 1984, 1985   All Rights Reserved.
%{appledict version #40
%serverdict begin exitserver
systemdict /currentpacking known{currentpacking true setpacking}if
/LW{save statusdict /product get(LaserWriter)anchorsearch
exch pop{length 0 eq{1}{2}ifelse}{0}ifelse exch restore}bind def
/LW+{LW 2 eq}bind def
/ok{systemdict /statusdict known dup{LW 0 gt and}if}bind def
%ok{statusdict begin 9 sccinteractive 3 ne exch 0 ne or{9 0 3 setsccinteractive}if
%waittimeout 300 lt{/waittimeout 300 def}if end}if
/md 250 dict def md begin
/av 40 def
/T true def
/F false def
/ci 0 def
/ml 0 def
/al 0 def
/tg 0 def
/sb 500 string def
/mtx matrix def
/s75 75 string def
/s8 8 string def
/s1 ( ) def
/pxs 1 def
/pys 1 def
/nlw .24 def
/ppr [-32 -29.52 762 582.48] def
/pgs 1320 def
/por true def
/xb 500 array def
/so true def
/fillflag false def
/pnm 1 def
/fmv true def
/sfl false def
/ma 0 def
/fkb true def
/fg (Rvd\001\001\000\000\177) def
/bdf{bind def}bind def
/xdf{exch def}bdf
/xl{neg exch neg translate}bdf
/fp{pnsh 0 ne pnsv 0 ne and}bdf
/vrb[
{fp{gsave 1 setlinewidth pnsh pnsv scale stroke grestore}if newpath}bind
/eofill load
dup
/newpath load
2 index
dup
{clip newpath}bind
{}bind
dup
2 copy
]def
currentscreen /spf xdf /rot xdf /freq xdf
/doop{vrb exch get exec}bdf
/psu{/pgs xdf 2 index .72 mul exch div /pys xdf div .72 mul /pxs xdf ppr astore pop /por xdf sn and /so xdf}bdf
/txpose{userdict /note known pgs 1680 eq 1 index and{legal}if
pgs 1212 eq{dup{note}if 54 32.4 translate}if pgs 1403 eq userdict /a4small known and{a4small}if
pgs 1320 eq and{note}if pxs pys scale ppr aload pop por{pop exch neg exch translate pop}
{translate pop pop 270 rotate}ifelse 1 -1 scale}bdf
/fr{3 index 3 index xl ppr aload pop 3 -1 roll 2 mul add 3 1 roll exch 2 mul add
6 2 roll 3 -1 roll sub 3 1 roll exch sub 3 1 roll exch 3 -1 roll div 3 1 roll div exch scale}bdf
/lws{show}bdf
/tv{show pop pop}bdf
/obl{{0.212557 mul}{pop 0}ifelse}bdf
/pw{fg 7 /PreserveWidth kif{pop}{127}ifelse put}bdf
/sfd{ps fg 5 -1 roll get mul 100 div 0 ps 5 -1 roll obl ps neg 0 0 6a astore makefont setfont}bdf
/fnt{findfont sfd}bdf
/bt{sa 3 1 roll 3 index and put}bdf
/sa(\000\000\000\000\000\000\000\000\000)def
/fs{0 1 bt 1 2 bt 2 4 bt 3 8 bt 4 16 bt 5 32 bt 6 64 bt 7 128 bt sa exch 8 exch put}bdf
/mx1 matrix def
/mx2 matrix def
/mx3 matrix def
/dgf{fg 7 get currentfont}bdf
/gf{}bdf
/bu{currentpoint currentgray currentlinewidth currentlinecap currentlinejoin currentdash exch aload length
fg 5 sfl{1}{0}ifelse put ml al tg ci pnsv pnsh
2t aload pop 3a aload pop mx2 aload pop mx1 aload pop mtx currentmatrix aload pop
mx3 aload pop ps pm restore /ps xdf mx3 astore pop}bdf
/bn{/pm save def mx3 setmatrix newpath 0 0 moveto ct dup 39 get 0 exch getinterval cvx exec
mtx astore setmatrix mx1 astore pop mx2 astore pop 3a astore pop
2t astore pop /pnsh xdf /pnsv xdf gw /ci xdf /tg xdf /al xdf /ml xdf
/sfl fg 5 get 0 ne def array astore exch setdash setlinejoin setlinecap
setlinewidth setgray moveto}bdf
/fc{save vmstatus exch sub 50000 lt
{(%%[|0|]%%)=print flush}if pop restore}bdf
/tc{32768 div add 3 1 roll 32768 div add 2t astore pop}bdf
/3a [0 0 0] def
/2t 2 array def
/tp{3a astore pop}bdf
/tt{mx2 currentmatrix pop currentpoint 2 copy 2t aload pop qa 2 copy translate 3a aload pop exch dup 0 eq
{pop}{1 eq{-1 1}{1 -1}ifelse scale}ifelse rotate pop neg exch neg exch translate moveto}bdf
/te{mx2 setmatrix}bdf
/dtb{/fkb false def /tg currentgray def /ci 0 def /ml 0 def /al 0 def 3 eq{1 setgray}if}bdf
/tb{3 eq{1 setgray}if pop pop pop}bdf
/dam{ml add /ml xdf dup length sb exch ci exch dup
ci add /ci xdf getinterval copy dup wi pop dup al add /al xdf
currentgray{setgray dup ml mul 3 -1 roll rs}}bdf
/am{pop sa 2 get 0 ne{dup wi pop dup 3 -1 roll rs}{show}ifelse}bdf
/th{3 -1 roll div 3 1 roll exch div 2 copy mx1 scale pop scale /sfl true def}bdf
/tu{1 1 mx1 itransform scale /sfl false def}bdf
/ts{1 1 mx1 transform scale /sfl true def}bdf
/fz{/ps xdf}bdf
/dfs{dup fs{fs}}bdf
/dfz{dup fz{fz}}bdf
/tm{save exch{dup type dup /arraytype eq exch /packedarraytype eq or
{exec}{dup type /dicttype eq{fkb{setfont fg exch 7 exch put}{pop pop}ifelse}if}ifelse}forall
currentpoint 3 -1 roll restore moveto}bdf
/dkb{counttomark xb exch 0 exch getinterval astore exch pop es}bdf
/kb{}bdf
/dv{dup 0 ne{div}{pop}ifelse}bdf
/es{3 -1 roll dup sa 8 get
sa 1 get 0 ne{/ml ml .2 ps mul sub def}if
ne{fs}{pop}ifelse exch dup 1 eq
{pop /tv al ml gt{/ll load /ml ml al dv def}{{show pop pop}/ml 1 def}ifelse def}{dup 3 eq
{pop /tv al ml gt{/ll load /ml ml al dv def}{ml al sub 0 rmoveto{show pop pop}/ml 1 def}ifelse def}{2 eq
{/tv al ml gt{/ll load /ml ml al dv def}{ml al sub 2 div 0 rmoveto{show pop pop}/ml 1 def}ifelse def}
{/tv /ll load /ml ml al dv def def}ifelse}ifelse}ifelse tm tg setgray}bdf
/pop4{pop pop pop pop}bdf
/it{sfl{mx1 itransform}if}bdf
/gm{exch it moveto}bdf
/lm{dlm exec}bdf
/dlm{{pop currentpoint sfl{mx1 transform}if exch pop sub 0 exch it rmoveto}}bdf
/fm{statusdict /manualfeed known}bdf
/se{statusdict exch /manualfeed exch put}bdf
/mf{dup /ma exch def 0 gt{fm se /t1 5 st ok ma 1 gt and{/t2 0 st /t3 0 st
statusdict /manualfeedtimeout 3600 put
}if}if}bdf
/jn{ok{statusdict exch /jobname exch put}{pop}ifelse}bdf
/pen{pnm mul /pnsh xdf pnm mul /pnsv xdf pnsh setlinewidth}bdf
/min{2 copy gt{exch}if pop}bdf
/max{2 copy lt{exch}if pop}bdf
/dh{fg 6 1 put array astore exch pop exch pop exch setdash}bdf
/ih[currentdash]def
/rh{fg 6 0 put ih aload pop setdash}bdf
/dl{gsave nlw pys div setlinewidth 0 setgray}bdf
/dlin{exch currentpoint newpath moveto lineto currentpoint stroke grestore moveto}bdf
/lin{fg 6 get 0 ne{lineto currentpoint 0 doop moveto}
{exch currentpoint /pnlv xdf /pnlh xdf gsave newpath /@y xdf /@x xdf fp{pnlh @x lt{pnlv @y ge
{pnlh pnlv moveto @x @y lineto pnsh 0 rlineto
0 pnsv rlineto pnlh pnsh add pnlv pnsv add lineto pnsh neg 0 rlineto}
{pnlh pnlv moveto pnsh 0 rlineto @x pnsh add @y lineto 0 pnsv rlineto
pnsh neg 0 rlineto pnlh pnlv pnsv add lineto}ifelse}{pnlv @y gt
{@x @y moveto pnsh 0 rlineto pnlh pnsh add pnlv lineto 0 pnsv rlineto
pnsh neg 0 rlineto @x @y pnsv add lineto}{pnlh pnlv moveto pnsh 0 rlineto
0 pnsv rlineto @x pnsh add @y pnsv add lineto pnsh neg 0 rlineto
0 pnsv neg rlineto}ifelse}ifelse
closepath fill}if @x @y grestore moveto}ifelse}bdf
/gw{/pnm fg 3 get fg 4 get div def}bdf
/lw{fg exch 4 exch put fg exch 3 exch put gw pnsv pnsh pen}bdf
/barc{/@f xdf /@op xdf /@e xdf /@s xdf /@r xdf
/@b xdf /@l xdf /@t xdf gsave
@@r @l add 2 div @b @t add 2 div translate newpath 0 0 moveto
@@r @l sub @b @t sub mtx currentmatrix pop scale @f{newpath}if
0 0 0.5 @s @e arc
mtx setmatrix @op doop grestore}bdf
/ar{dup 0 eq barc}bdf
/ov{0 exch 360 exch true barc}bdf
/rc{/@op xdf currentpoint 6 2 roll newpath 4 copy
4 2 roll exch moveto 6 -1 roll lineto lineto lineto closepath
@@op doop moveto}bdf
/mup{dup pnsh 2 div le exch pnsv 2 div le or}bdf
/rr{/@op xdf 2. div /@w xdf 2. div /@h xdf
/@r xdf /@b xdf /@l xdf /@t xdf
@@t @b eq @l @r eq @w mup or or{@t @l @b @r @op rc}
{@r @l sub 2. div dup @w lt{/@w xdf}{pop}ifelse
@@b @t sub 2. div dup @w lt{/@w xdf}{pop}ifelse
@@op 0 eq{/@w @w pnsh 2 div 2 copy gt{sub def}{0 pop4}ifelse}if
currentpoint newpath
@@r @l add 2. div @t moveto
@@r @t @r @b @w arcto pop4
@@r @b @l @b @w arcto pop4
@@l @b @l @t @w arcto pop4
@@l @t @r @t @w arcto pop4
closepath @op doop moveto}ifelse}bdf
/pr{gsave newpath /pl{exch moveto /pl{exch lineto}def}def}bdf
/pl{exch lineto}bdf
/ep{dup 0 eq{{moveto}{exch lin}{}{(%%[|1|]%%)= flush}pathforall
pop grestore}{doop grestore}ifelse currentpoint newpath moveto}bdf
/gr{64. div setgray}bdf
/pat{s8 copy pop 9.375 0{1 add 4 mul cvi s8 exch get exch 1 add 4 mul cvi 7 sub bitshift 1 and}setscreen gr}bdf
/sg{freq rot /spf load setscreen gr}bdf
/dc{transform round .5 sub exch round .5 sub exch itransform}bdf
/sn{userdict /smooth known}bdf
/x8{3 bitshift}bdf
/x4{2 bitshift}bdf
/d4{-2 bitshift}bdf
/xf{.12 mul exch 8. div}bdf
/db{/bmode xdf
save 9 1 roll sn and 8 4 roll xf exch dc translate newpath 0 0 moveto
2 copy xf .96 mul exch scale pop
0 0 1 1 5 -1 roll 7 index 2 sub exch div 1200 div sub 10 rc clip newpath 0 0 moveto
bmode 0 eq bmode 4 eq or{1 setgray .5 .5 idtransform abs exch abs
2 copy neg 1 add exch neg 1 add exch 2 rc}if
bmode 3 eq bmode 7 eq or{1}{0}ifelse setgray
/@f (%stdin)(r) file def
{x4 /@dy xdf 2 sub x4 /@dx xdf /@idx xdf
@@idx 5 bitshift @dy bmode 0 eq bmode 1 eq bmode 3 eq or or @dx 0 0 @dy 8 0 6a astore
{@f @dy d4 4 add @idx mul string readhexstring pop
dup length @idx x4 sub 4 bitshift string
dup 3 1 roll @dx 8 add d4 smooth}imagemask}
{/@dy xdf 2 sub /@dx xdf /@idx xdf
/@xs @idx string def
/@p{@f @xs readhexstring pop}def
@@p @p @idx 3 bitshift @dy bmode 0 eq bmode 1 eq bmode 3 eq or or @dx 0 0 @dy 0 0 6a astore
{@p}imagemask @p @p pop4}ifelse restore}bdf
/wd 14 dict def
/mfont 14 dict def
/mdf{mfont wcheck not{/mfont 14 dict def}if mfont begin xdf end}bdf
/cf{{1 index /FID ne{tmp 3 1 roll put}{pop pop}ifelse}forall}bdf
/macvec 256 array def
/mv{fmv{tmp /Encoding macvec put}if}bdf
/du{findfont dup length dict /tmp exch def cf}bdf
/nf{tmp definefont pop}bdf
/rf{/fmv exch def du mv nf}bdf
/fe{tmp /Encoding 2 copy get dup length array copy put}bdf
/ce{tmp /Encoding get 3 1 roll put}bdf
/xs{\312\312 serverdict begin exitserver}bdf
/bmbc{wd begin
/cr xdf /fd xdf save fd /low get cr x4 6 getinterval dup 3 get 255 eq{pop 0 0 0 0 0 0 setcachedevice}{fd begin
dup 4 get 8 bitshift 1 index 5 get add
exch dup 0 get 8 bitshift 1 index 1 get add exch dup 2 get km add exch 3 get xm aload pop
end dup scale /sh xdf /sw xdf neg /desc xdf
/hwd load 0 get div 4 1 roll /coff xdf dup /cloc xdf sub /bitw xdf
0 coff desc bitw coff add sh setcachedevice
bitw 0 ne{coff desc translate newpath 0 0 moveto
mark cloc 8 mod dup bitw add dup 8 div ceiling cvi 1 add dup 1 and 0 ne{1 add}if /byw xdf
[2 7 4 index sub bitshift 1 sub 2 7 4 index 8 mod sub bitshift 1 sub not
3 index 8 idiv 1 sub dup 0 ge{{255 exch}repeat}{pop and}ifelse 0 0]
/rg byw sh so{4 add}if mul string def
sw 8 idiv fd /hm get cloc 8 idiv so{byw 1 bitshift}{0}ifelse
sh{2 index 2 index byw getinterval rg 2 index byw getinterval copy pop
byw add exch 3 index add exch}repeat
0 1 rg length 1 sub{rg 1 index get 6 index 2 index byw mod get and rg 3 1 roll put}for
byw x8 dup sh scale so{x4 sh x4 true 2 index 0 0 sh x4 neg
13 index x4 8 add 1 index neg 6a astore{byw sh mul 16 mul string rg 1 index byw x8 smooth}imagemask}
{sh true 2 index 0 0 sh neg 13 index sh 6a astore{rg}imagemask}ifelse cleartomark}if
}ifelse restore end}bdf
/bb{3 index div 4 1 roll
2 index div 1 5 2 roll
exch div 4 1 roll
4 array astore /FontBBox mdf
}bdf
/hwd LW+{.96}{1.}ifelse
/exch load /div load 4 /array load /astore load /xm /mdf cvx
8 LW+{packedarray}{array astore}ifelse cvx bdf
/bf{
mfont begin
/FontType 3 def
/FontMatrix [1 0 0 1 0 0] def
/Encoding macvec def
/BuildChar /bmbc load def
end
mfont definefont pop
}bdf
/wi LW+{/stringwidth load}
{{gsave 0 0 0 0 0 0 0 0 moveto lineto lineto lineto closepath clip stringwidth grestore}bind}ifelse def
/aps{0 get 124 eq}bdf
/apn{s75 cvs aps}bdf
/xc{s75 cvs dup}bdf
/xp{put cvn}bdf
/scs{xc 3 67 put dup 0 95 xp}bdf
/sos{xc 3 79 xp}bdf
/sbs{xc 1 66 xp}bdf
/sis{xc 2 73 xp}bdf
/sob{xc 2 79 xp}bdf
/sss{xc 4 83 xp}bdf
/dd{exch 1 index add 3 1 roll add exch}bdf
/smc{moveto dup lws}bdf
/kwn{dup FontDirectory exch known{findfont exch pop}}bdf
/gl{1 currentgray sub setgray}bdf
/mm{/mfont 10 dict def mfont begin
/FontMatrix [1 0 0 1 0 0] def
/FontType 3 def
/Encoding macvec def
/df 4 index findfont def
/FontBBox [0 0 1 1] def
/xda xdf /mbc xdf
/BuildChar{wd begin /cr xdf /fd xdf /cs s1 dup 0 cr put def fd /mbc get exec end}def
exec end mfont definefont}bdf
/ac{dup scs kwn{exch /ofd exch findfont def /tmp ofd maxlength 1 add dict def ofd cf mv
tmp dup dup /StrokeWidth nlw 1000 mul pys div ps div dup 12 lt{pop 12}if put
/PaintType 2 put definefont}ifelse}bdf
/mb{dup sbs kwn{exch{pop}{bbc}{}mm}ifelse sfd}bdf
/mo{dup sos kwn{exch{pop}{boc}{}mm}ifelse sfd}bdf
/ms{dup sss kwn{exch{pop}{bsc}{}mm}ifelse sfd}bdf
/ou{dup sos kwn{exch dup ac pop{scs findfont /df2 xdf}{aoc}{}mm}ifelse sfd}bdf
/su{dup sss kwn{exch dup ac pop{scs findfont /df2 xdf}{asc}{}mm}ifelse sfd}bdf
/ao{/fmv true def ou}bdf /as{/fmv true def su}bdf /vo{/fmv false def ou}bdf /vs{/fmv false def su}bdf
/bbc{/da .03 def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs 0 0 smc da 0 smc da da smc 0 da moveto lws}bdf
/boc{/da 1 ps div def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs 0 0 smc da 0 smc da da smc 0 da smc gl da 2. div dup moveto lws}bdf
/bsc{/da 1 ps div def
/ds .05 def /da2 da 2. div def fd /df get setfont
gsave cs wi exch ds add da2 add exch grestore setcharwidth
cs ds da2 add .01 add 0 smc 0 ds da2 sub translate 0 0 smc
da 0 smc da da smc 0 da smc gl da 2. div dup moveto lws}bdf
/aoc{fd /df get setfont
gsave cs wi grestore setcharwidth
gl cs 0 0 smc fd /df2 get setfont gl 0 0 moveto lws}bdf
/asc{/da .05 def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs da .01 add 0 smc 0 da translate gl 0 0 smc gl fd /df2 get setfont 0 0 moveto lws}bdf
/dly{/@t exch st{@t the{exit}if}loop}bdf
/st{1000 mul usertime add dup 2147483647 gt{2147483647 sub}if def}bdf
/the{usertime sub dup 0 lt exch -2147483648 gt and}bdf
/lsf{FontDirectory{pop dup apn{= flush}{dup s75 dup 0 (|______) putinterval
7 68 getinterval cvs length 7 add s75 0 3 -1 roll getinterval cvn
FontDirectory exch known{pop}{= flush}ifelse}
ifelse}forall /* = flush}bdf
/6a 6 array def
/2a 2 array def
/3q 3 array def
/qs{3 -1 roll sub exch 3 -1 roll sub exch}bdf
/qa{3 -1 roll add exch 3 -1 roll add exch}bdf
/qm{3 -1 roll 1 index mul 3 1 roll mul}bdf
/qn{6a exch get mul}bdf
/qA .166667 def /qB .833333 def /qC .5 def
/qx{6a astore pop
qA 0 qn qB 2 qn add   qA 1 qn qB 3 qn add
qB 2 qn qA 4 qn add   qB 3 qn qA 5 qn add
qC 2 qn qC 4 qn add   qC 3 qn qC 5 qn add}bdf
/qp{6 copy 12 -2 roll pop pop}bdf
/qc{exch qp qx curveto}bdf
/qi{{exch 4 copy 2a astore aload pop qa .5 qm newpath moveto}{exch 2 copy 6 -2 roll 2 qm qs 4 2 roll}ifelse}bdf
/qq{{qc 2a aload pop qx curveto}{exch 4 copy qs qa qx curveto}ifelse}bdf
/pt{currentpoint newpath moveto}bdf
/qf{/fillflag true def}bdf
/ec{1 and 0 ne{0 doop}if grestore currentpoint newpath moveto /fillflag false def}bdf
/eu{currentpoint fp{0 ep}{grestore newpath}ifelse moveto /fillflag false def}bdf
/bp{currentpoint newpath 2 copy moveto}bdf
/ef{gsave fillflag{gsave eofill grestore}if}bdf
/sm{dup 0 exch{32 eq{1 add}if}forall}bdf
/ll{3 1 roll exch dup abs .001 lt{pop pop pop}
{sub dup abs .5 lt{pop show}{1 index sm
fg 7 get dup 127 ne{4 1 roll exch pop dv 0 4 -2 roll exch widthshow}
{pop dup 0 eq 3 index 0 le or{pop length div 0 3 -1 roll ashow}
{10 mul exch length add div dup 10 mul 0 32 4 -1 roll 0 6 -1 roll awidthshow
}ifelse}ifelse}ifelse}ifelse}bdf
/dss{currentfont bu 0 sa 6 get 0 ne{pop 1}{sa 7 get 0 eq{pop 2}if}ifelse sa 1 get 0 ne
/|______Symbol sa 4 get 0 ne{vs}{sa 3 get 0 ne{vo}{fnt}ifelse}ifelse bn fg 7 get currentfont}bdf
/ss{dss pop pop}bdf
/dpf{fg 7 get 8 -1 roll dup setfont}bdf
/pf{setfont}bdf
/mc{0 3 1 roll transform neg exch pop}bdf
/rs{sa 2 get 0 ne{gsave 1 index 0
/UnderlinePosition kif{mc}{ps -10 div}ifelse
/UnderlineThickness kif{mc}{ps 15 div}ifelse
setlinewidth currentpoint 3 -1 roll sub moveto
sa 4 get 0 ne{gsave currentlinewidth 2. div dup rmoveto currentpoint translate 2 copy rlineto
stroke grestore}if sa 3 get sa 4 get or 0 ne 3 1 roll 2 index{gsave gl 2 copy rlineto stroke grestore}if
rlineto{strokepath nlw pys div setlinewidth}if stroke grestore}if tv}bdf
/sgt{2 copy known{get true}{pop pop false}ifelse}bdf
/kif{currentfont dup /FontMatrix get exch /FontInfo sgt{true}{currentfont /df sgt
{dup /FontInfo sgt{3 1 roll /FontMatrix get mtx concatmatrix exch true}{pop pop pop false}
ifelse}{pop pop false}ifelse}ifelse{3 -1 roll sgt{exch true}{pop false}ifelse}{false}ifelse}bdf
/blank /Times-Roman findfont /CharStrings get /space get def
/NUL /SOH /STX /ETX /EOT /ENQ /ACK /BEL /BS /HT /LF /VT /FF /CR /SO /SI
/DLE /DC1 /DC2 /DC3 /DC4 /NAK /SYN /ETB /CAN /EM /SUB /ESC /FS /GS /RS /US
macvec 0 32 getinterval astore pop
macvec 32 /Times-Roman findfont /Encoding get
32 96 getinterval putinterval macvec dup 39 /quotesingle put 96 /grave put
/Adieresis /Aring /Ccedilla /Eacute /Ntilde /Odieresis /Udieresis /aacute
/agrave /acircumflex /adieresis /atilde /aring /ccedilla /eacute /egrave
/ecircumflex /edieresis /iacute /igrave /icircumflex /idieresis /ntilde /oacute
/ograve /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis
/dagger /degree /cent /sterling /section /bullet /paragraph /germandbls
/registered /copyright /trademark /acute /dieresis /notequal /AE /Oslash
/infinity /plusminus /lessequal /greaterequal /yen /mu /partialdiff /summation
/product /pi /integral /ordfeminine /ordmasculine /Omega /ae /oslash
/questiondown /exclamdown /logicalnot /radical /florin /approxequal /Delta /guillemotleft
/guillemotright /ellipsis /blank /Agrave /Atilde /Otilde /OE /oe
/endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright /divide /lozenge
/ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright /fi /fl
/daggerdbl /periodcentered /quotesinglbase /quotedblbase /perthousand /Acircumflex /Ecircumflex /Aacute
/Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex
/apple /Ograve /Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde
/macron /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
macvec 128 128 getinterval astore pop
/|______Courier /Courier T rf
/|______Seattle /Helvetica findfont dup length 1 add dict /tmp xdf cf mv
/mxv[/zero /one /two /three /four /five /six /seven /eight /nine /comma /period /dollar /numbersign
/percent /plus /hyphen /E /parenleft /parenright /space]def
tmp /Metrics 21 dict dup begin mxv{600 def}forall end put
tmp begin /FontBBox FontBBox [0 0 0 0] astore def end
tmp definefont pop
false{
/rd{/@t 5 st 0{readRS232{exch 1 add exch 1 index 3 eq{exit}
{pop}ifelse}{@t the{0 exit}if}ifelse}loop exch pop}bdf
/sf{66 writeRS232 rd 64 eq (BBFGB) ty get writeRS232 rd 64 eq and}bdf
/af{rd 64 ne{/@x 4.5 st{sf{exit}if @x the
{/@x 4.5 st(%%[status: problem with external paper feeder]%%)= flush}if}loop}if}bdf
/kf{af hp (BBDCE) ty get writeRS232}bdf
/hp{{t1 the{/t1 t2 the ty 4 eq or{{t3 the{exit}if}loop 18 st 18}{9 st 9}ifelse
dup 2 add /t2 exch st 4.5 add /t3 exch st exit}if}loop}bdf
/fx{ma 1 gt ok and{ma 5 eq{/@t 4.5 st{po 524288 and 0 eq{exit}if
@@t the{(%%[status: paper jam]%%) = flush /@t 4.5 st}if}loop /@x 4.5 st
rd 64 eq sf and{{66 writeRS232 kf exit}{/ty (\0000\0000\0003\0002) ty get def}ifelse @x the
{(%%[status: external feeder out of paper]%%)= flush /@x 4.5 st}if sf}loop}{kf}ifelse}if}bdf
/sp{#copies dup userdict /#copies 1 put 1 ge{1 sub{fx copypage}repeat fx showpage}{1 ge{fx showpage}{erasepage}ifelse}ifelse}bdf
/pp{#copies userdict /#copies 1 put{fx copypage}repeat}bdf
}{/sp /showpage load def /pp /copypage load def}ifelse
/od{(Rvd\001\001\000\000\177) fg copy pop txpose newpath clippath mark
{transform{itransform moveto}}{transform{itransform lineto}}
{6 -2 roll transform 6 -2 roll transform 6 -2 roll transform
{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll curveto}}
{{closepath}}pathforall newpath counttomark array astore /gc xdf pop ct 39 0 put
10 fz 0 fs 2 F /|______Courier fnt}bdf
/cd{}bdf
/op{/sfl false def /pm save def}bdf
/cp{not{userdict /#copies 0 put}if ma 0 gt{{t1 the{exit}if}loop}if{pp}{sp}ifelse pm restore}bdf
/px{0 3 1 roll tp tt}bdf
/py{}bdf
/psb{/us save def}bdf
/pse{us restore}bdf
/ct 40 string def
/nc{currentpoint initclip newpath gc{dup type dup /arraytype eq exch /packedarraytype eq or{exec}if}
forall clip newpath moveto}bdf
/kp{ct 0 2 index length 2 index 39 2 index put getinterval copy cvx exec mx3 currentmatrix pop}bdf
end
LW 1 eq userdict /a4small known not and{/a4small
[[300 72 div 0 0 -300 72 div -120 3381]
280 3255
{statusdict /jobstate (printing) put 0 setblink
margins
exch 196 add exch 304 add 8 div round cvi frametoroket
statusdict /jobstate (busy) put
1 setblink}
/framedevice load
60 45{dup mul exch dup mul add 1.0 exch sub}/setscreen load
{}/settransfer load /initgraphics load /erasepage load]cvx
statusdict begin bind end readonly def}if
systemdict /currentpacking known{setpacking}if
%currentfile ok userdict /smooth known not and{eexec}{flushfile}ifelse
<1A73D71A961FBB2AC19BE58D26A29D58EC3A474CFEE3DEF290EEB285241ADA25BE96DD2E
A0CA0831BC1011013EED016DC1DECEF5EF1349B00F24B41DB158F3DDFDA4B7A557E5AC1E
6799E46CC291B0BDB8548E68AB6FF3BD5F735AE6D54C516A33C2B6DC3C671368D1BC01D3
CB154E6BB2A0A86AC449E18EB87DAE408DC2AB4A6A01BDAB8AD7AB8285C1178A2F59CF91
C4F840A4849B106B3545A51E3972E65F83A65F6B1A96E8F4F5AFE9987AD56C52E8EBDB26
A9D6F6FCB73042AB28DC9F91B6AE4928ECE56A278E0A67D269DDE6CC187A6C07D0878B46
5F9590AA780185E9C05087ABC09C1E3E2E5E055EA5AB02EA14EF88EDF28EB1ACEC5FED79
60FA3901E1EAC09C4E515C4BEEDE037CEE04DF6CE10A872517ACF7C73173BE38478E8979
5BC992BE84A72C4AF420A20D7D6A098D7E0B4A3578C1E0F3C0D37BCED8AC23A5C2C66AAA
FC278927EEDB8C46F3F5480BD3680698759C97A717AE5143F654D858D3A32E3B7D255420
4719774F50B7CA6CE7B9CD6984820A2F3A9BF131A3FF2C4A8DDDA5CABE8B4E03B959F998
A331DCB6EB452F36905852159DE67ED7BE09C9546F98F64B5923B121D7BB51AAE57E2747
4F58FA52A68A4472E340C76CE965DF8EC65B33AB0BFB59DBBD888B66789A3C69A9181455
E1A6F1163CF7EBA3B909F6C63AB12A24BE7B73976EEE05A03A882A77D2B5A10C9E51E43B
08D3F1D8DE6B56F2BD61EBED3545E3E7D713BB7F1EBB11B9E411B9C19A6D3FE3605E8CD9
A4B632BAAF049D1D8BE0294D97074468DB092B997FBF64A28BC713013C6ECABA91B5C6A0
484EC2CAA5B027D4B068F7D7399F82ADCC8B005AAEF549053C2B212F5247E0FF4B2C155D
EB96500EAD0D6C26B34C4F6284F8BD813DEF2E1898131FAB7BCF63F3634DDC89C658BF91
A4E59010E79E171E8E9BE44382136546FF6547E76CA8E14C4A4BBE177C74934DEB4A7DF8
23A1E76B1A91D79F5D009F3DC992C79ECD9DB46FEAFD164D464B06DCE9BDB33CD9F11076
2A77E486819BA99805E45E3AEF15AFA176B5278665F2DC065A60A3B2CEB8FDA49C778339
E20B251917F749F3BB9A2061038EC56D9BA691303B84881D0A59FD71769049B496A8BA77
8E64429D1B8A89831568F926DD235000D0CD3A0D2A5C74558225BD05ACDEDA4DEFF48E39
1E7A1A2D5FB3607E2A9E3B3D7AF6A891CE404AC20F6AA4A5A48AB94849596925A2030543
8255FAD30052E8D1CAAA36E9FFB826F80F4B79AF0335DB19204506A8ADD569C221364126
AF26CE964BF40DE30BF59CB849E61A1CC79BBD446D789083F96F9803A3B713695F2945CC
38EC6330808A2C2C15C52F1CBF1C33B38B0F23AA32515D3FF758748B3EE5EDC79EAF3BA8
7A00443D4662DA93A5B399C91BF3B169ECCD2EA9A8BF3292CDA540414E175A083E921563
459492F21E21551B4BDAFF3F3927125A307AF4F35672274F606E69C4229A6466C3DBC78B
69FF6A9D027BABDC76E84B3EA71277611D75A496262FF441BA66CC9BA1A84F16B68ECB92
9BA8C15B836CE6DC38CFEEFCC38123B714F11F93C191731CF14A5448EE31E2FB86F5B775
83378BD0E6B9ABF237F70DBE7E85362EF3ADE1DB6D00EBF76C9C513A164436FFED364133
A08F48518DEB441102B5B18CC74F066FB6E76EC359E3ABE1E88DD595E5FC953A5F938014
F53FF0B4090DEFB3D273C5C2AAC19E68232A9160219FCADB518E97D98D11980287C23592
85E73AAD1714F4C4B10F2661ECF12F4FABCA00A497DCA02258CA43A228EFF0DD37D1D586
126B06DAB569261B0BC89289F85D7D4FB88D6778245DE208AAC0412E587D3F001A37BCBD
57976DC85DE0C27E56C859384C1DB196D536265141BF17D4E04EFCA8CDD17203560043FD
7588C101EE32C7A222518EFCFAA953CD5D973E962712B6454B805757513A14CE9B7B3551
520B5FAB59255D6AFB013D37435B64CB516CDDFF8236EDAEDF8345DE7909A116D9F420D8
F6E9997DD0FE10C881AE887ACEB111974D058C5B531282F15105E77663A65A33AD7E9AC7
7EE48FD4F8B6385B99379C86B4482A32AE0C12337B0D92C35613D6CD6F7E6B1B8BA72713
C24D45C13765FD5F73F3DBAB82ABB35A106A1EC281FAB335D48D48D3B25DA195F9E0FD91
E3A8FAEB18F2BC3E48E68488A9417A9277DFDFFA461081C75703C0BAE6914F9AF8D39322
37B72F0C9C98EB697D7E1107E354329F58B072188FAE858915EC6C54C5332B6EAD052347
A616C9BC86A285493509B8DA8608DD8751214091D19DC58439EB7954E44D9A04CAE77461
C6692F7B2DF43F7587E09E27FD2928B8D07810B459B11363CC4B4C9A1302662EA1F4218A
172E5EA3A4AF9BF3A489CC96E7EF6E03985723426D461F4B082DBF0814179953C2BE574F
4298BBD20A4F9DA830B78FD225055110E6E5BC072C28067E0968FFF2733D9BFD8642588F
F384A8749569DD5DE35D847351C012E706FB77C771D983EB8197A04557AABFF0BFD3E26A
4F6C36305B3D7B6A6E86D2B5D44FA23527DE6D27A2D52B814A0C87AE77D0C6FF88851AB4
58663C0DBC36C4C4E02A76E13E2BC64AD3F4B24AA097C08D7B956D5EFFE794CAF954CE17
2FD5728AC926D1F8F934E2D5E103E4A9A0220BF17F4A8389A88069620B0A00B41506261B
87803E21DDEAF18BB7383165BA52038286C3870B10B787EC06620547317DEF718DB35CC7
EFD9AE3AD52048C5B1F0057935496618EFA953055E953BC60ABB477B894685DC7B250A21
EA0CF52C8105152AC5543A324E55AAED07B0FA2BE805E91328B00E23C7E2CBC7CBFDD8FD
B268A2B3A7D7ADCC99B64B4D230648E9CC986A347619B2B1D17194591FBE068137BB5CD2
DA481B0CF874B3673301FFB9C5C107FAC927C5653B418E7EC3B5F7BBED5C45BD3773788B
5B08D9F9827E4B5043882DEA8647F9BA70B33F3E01818E20766336EAC4CDE32D5039933A
0EBBCBEFFEAB37E5086674546AC164717D9209BFF10C76C89E06FBE0E9773570FB590D86
3522C37FE8D8EA55E66DA56E5599C9AB8085736BF06AE34F6C8415C6F55BA43882B62644
8EFC5EC18A52E418E2A6476A48B598C08C69446912092D720EF83E86D37423710E564FED
AF505CFE8B0C2A709D72422C2E87ED3B3A7B4E7334330CED6DFC15B7DE3137BF91AC87D1
269148FAEDA86A7695569777597C2A862080C47CD54C5F273B51C5744E2B6253DB9695FC
C2E876714C8B47AA9DB92F763F3C48CFEF27183E39DC041EB6DB7E5BE10B2C38BA95A3B8
B23E80C2C1B2A131AAF1D138CB24FCFCF9F18582D1E3DCDA44542851B5F4E919CCEE7CDF
E6C3CE7C83979550CE71E159945C7E7F2E241BEBEC3B70C85D6E22C22E24D4E46012BAC4
CC399E1C429FA922F6EFC8BC34E97F5FC8AB9105D08598AB3D70F43C7FB9DF6C566FFE16
3C97C9C5799A64A566BB8CD40D8E23700D53B5877AF22A0B5156DF046CF37F6178C107EF
D8B29839063F28AFECF894C3054AC81FBFB6D1616E22082C81B71B5A09793E7263C6C6EE
1C72F536BA9F2FB977ACE68E716A1C382176AA8797105ABC2C90C46FEB9CD7C7F17A02A7
E88C9FAAC033B20D4102DA13B2380525F47E>
ok userdict /smooth known not and{eexec}{pop}ifelse
%!
% fontprep.ps				greid Thu Sep 25 15:40:03 1986
%
% Assumes the presence of the "md" dictionary which is where the Apple
% LaserPrep routines are stored.  Works with version 40.0 of the
% LaserPrep file, and perhaps earlier ones.

userdict /md known not {
    (LaserPrep not loaded.  Cannot find "md" dictionary.\n) print flush
    stop
} if

md begin
/scratch 100 string def
FontDirectory {
  pop scratch cvs dup 0 get dup 65 lt exch 90 gt or {
    pop   %% ignore any font name that doesn't start with a letter
  }{
    %% set up and call the /rf routine in md dictionary:
    dup length string copy /#nm exch def
    #nm length 7 add string
    dup 0 (|______) putinterval
    dup 7 #nm putinterval cvn
    dup FontDirectory exch known {
	clear
    }{
        #nm cvn dup
        findfont /Encoding get StandardEncoding eq
        {true}{false}ifelse
	rf	% stack: /|______FontName /FontName <boolean>
    } ifelse
  } ifelse
} bind forall
end %md
@//E*O*F laser-prep-40.pro//
chmod u=rw,g=r,o=r laser-prep-40.pro
 
echo x - laser-prep-49.pro
sed 's/^@//' > "laser-prep-49.pro" <<'@//E*O*F laser-prep-49.pro//'
%!
%0000000000
% CopyRight Apple Computer, Inc. 1984, 1985, 1986, 1987   All Rights Reserved.
%{appledict version #49
%serverdict begin exitserver
systemdict /currentpacking known{currentpacking true setpacking}if
/LW{save statusdict /product get(LaserWriter)anchorsearch
exch pop{length 0 eq{1}{2}ifelse}{0}ifelse exch restore}bind def
/LW+{LW 2 eq}bind def
/ok{systemdict /statusdict known dup{LW 0 gt and}if}bind def
%ok{statusdict begin 9 sccinteractive 3 ne exch 0 ne or{9 0 3 setsccinteractive}if end}if
/md 250 dict def md begin
/av 49 def
/T true def
/F false def
/ci 0 def
/ml 0 def
/al 0 def
/tg 0 def
/sb 500 string def
/mtx matrix def
/s75 75 string def
/s8 8 string def
/s1 ( ) def
/pxs 1 def
/pys 1 def
1 0 mtx defaultmatrix dtransform exch atan /pa exch def
/nlw .24 def
/ppr [-32 -29.52 762 582.48] def
/pgs 1320 def
/por true def
/xb 500 array def
/so true def
/fillflag false def
/pnm 1 def
/fmv true def
/sfl false def
/ma 0 def
/fkb true def
/fg (Rvd\001\001\000\000\177) def
/bdf{bind def}bind def
/xdf{exch def}bdf
/xl{neg exch neg translate}bdf
/fp{pnsh 0 ne pnsv 0 ne and}bdf
/vrb[
{fp{gsave 1 setlinewidth pnsh pnsv scale stroke grestore}if newpath}bind
/eofill load
dup
/newpath load
2 index
dup
{clip newpath}bind
{}bind
dup
2 copy
]def
currentscreen /spf xdf /rot xdf /freq xdf
/doop{vrb exch get exec}bdf
/psu{/pgs xdf 2 index .72 mul exch div /pys xdf div .72 mul /pxs xdf ppr astore pop /por xdf sn and /so xdf}bdf
/txpose{userdict /note known pgs 1680 eq 1 index and{legal}if
pgs 1212 eq{dup{note}if 54 32.4 translate}if pgs 1403 eq userdict /a4small known and{a4small}if
pgs 1320 eq and{note}if pxs pys scale ppr aload pop por{pop exch neg exch translate pop}
{translate pop pop 270 rotate}ifelse 1 -1 scale
%statusdict begin waittimeout 300 lt{/waittimeout 300 def}if end
}bdf
/fr{3 index 3 index xl ppr aload pop 3 -1 roll 2 mul add 3 1 roll exch 2 mul add
6 2 roll 3 -1 roll sub 3 1 roll exch sub 3 1 roll exch 3 -1 roll div 3 1 roll div exch scale}bdf
/lws{show}bdf
/tv{show pop pop}bdf
/obl{{0.212557 mul}{pop 0}ifelse}bdf
/pw{fg 7 /PreserveWidth kif{pop}{127}ifelse put}bdf
/sfd{ps fg 5 -1 roll get mul 100 div 0 ps 5 -1 roll obl ps neg 0 0 6a astore makefont setfont}bdf
/fnt{findfont sfd}bdf
/bt{sa 3 1 roll 3 index and put}bdf
/sa(\000\000\000\000\000\000\000\000\000)def
/fs{0 1 bt 1 2 bt 2 4 bt 3 8 bt 4 16 bt 5 32 bt 6 64 bt 7 128 bt sa exch 8 exch put}bdf
/mx1 matrix def
/mx2 matrix def
/mx3 matrix def
/dgf{fg 7 get currentfont}bdf
/gf{}bdf
/bu{currentpoint currentgray currentlinewidth currentlinecap currentlinejoin currentdash exch aload length
fg 5 sfl{1}{0}ifelse put ml al tg ci pnsv pnsh
2t aload pop 3a aload pop mx2 aload pop mx1 aload pop mtx currentmatrix aload pop
mx3 aload pop ps pm restore /ps xdf mx3 astore pop}bdf
/bn{/pm save def mx3 setmatrix newpath 0 0 moveto ct dup 39 get 0 exch getinterval cvx exec
mtx astore setmatrix mx1 astore pop mx2 astore pop 3a astore pop
2t astore pop /pnsh xdf /pnsv xdf gw /ci xdf /tg xdf /al xdf /ml xdf
/sfl fg 5 get 0 ne def array astore exch setdash setlinejoin setlinecap
setlinewidth setgray moveto}bdf
/fc{save vmstatus exch sub 50000 lt
{(%%[|0|]%%)=print flush}if pop restore}bdf
/tc{32768 div add 3 1 roll 32768 div add 2t astore pop}bdf
/3a [0 0 0] def
/2t 2 array def
/tp{3a astore pop}bdf
/tt{mx2 currentmatrix pop currentpoint 2 copy 2t aload pop qa 2 copy translate 3a aload pop exch dup 0 eq
{pop}{1 eq{-1 1}{1 -1}ifelse scale}ifelse rotate pop neg exch neg exch translate moveto}bdf
/te{mx2 setmatrix}bdf
/dtb{/fkb false def /tg currentgray def /ci 0 def /ml 0 def /al 0 def 3 eq{1 setgray}if}bdf
/tb{3 eq{1 setgray}if pop pop pop}bdf
/dam{ml add /ml xdf dup length sb exch ci exch dup
ci add /ci xdf getinterval copy dup wi pop dup al add /al xdf
currentgray{setgray dup ml mul 3 -1 roll rs}}bdf
/am{pop sa 2 get 0 ne{dup wi pop dup 3 -1 roll rs}{show}ifelse}bdf
/th{3 -1 roll div 3 1 roll exch div 2 copy mx1 scale pop scale /sfl true def}bdf
/tu{1 1 mx1 itransform scale /sfl false def}bdf
/ts{1 1 mx1 transform scale /sfl true def}bdf
/fz{/ps xdf}bdf
/dfs{dup fs{fs}}bdf
/dfz{dup fz{fz}}bdf
/tm{save exch{dup type dup /arraytype eq exch /packedarraytype eq or
{exec}{dup type /dicttype eq{fkb{setfont fg exch 7 exch put}{pop pop}ifelse}if}ifelse}forall
currentpoint 3 -1 roll restore moveto}bdf
/dkb{counttomark xb exch 0 exch getinterval astore exch pop es}bdf
/kb{}bdf
/dv{dup 0 ne{div}{pop}ifelse}bdf
/es{3 -1 roll dup sa 8 get
sa 1 get 0 ne{/ml ml .2 ps mul sub def}if
ne{fs}{pop}ifelse exch dup 1 eq
{pop /tv al ml gt{/ll load /ml ml al dv def}{{show pop pop}/ml 1 def}ifelse def}{dup 3 eq
{pop /tv al ml gt{/ll load /ml ml al dv def}{ml al sub 0 rmoveto{show pop pop}/ml 1 def}ifelse def}{2 eq
{/tv al ml gt{/ll load /ml ml al dv def}{ml al sub 2 div 0 rmoveto{show pop pop}/ml 1 def}ifelse def}
{/tv /ll load /ml ml al dv def def}ifelse}ifelse}ifelse tm tg setgray}bdf
/pop4{pop pop pop pop}bdf
/it{sfl{mx1 itransform}if}bdf
/gm{exch it moveto}bdf
/lm{dlm exec}bdf
/dlm{{pop currentpoint sfl{mx1 transform}if exch pop sub 0 exch it rmoveto}}bdf
/fm{statusdict /manualfeed known}bdf
/se{statusdict exch /manualfeed exch put}bdf
/mf{dup /ma exch def 0 gt{fm se /t1 5 st ok ma 1 gt and{/t2 0 st /t3 0 st
statusdict /manualfeedtimeout 3600 put
}if}if}bdf
/jn{ok{statusdict exch /jobname exch put}{pop}ifelse}bdf
/pen{pnm mul /pnsh xdf pnm mul /pnsv xdf pnsh setlinewidth}bdf
/min{2 copy gt{exch}if pop}bdf
/max{2 copy lt{exch}if pop}bdf
/dh{fg 6 1 put array astore exch pop exch pop exch setdash}bdf
/ih[currentdash]def
/rh{fg 6 0 put ih aload pop setdash}bdf
/dl{gsave nlw pys div setlinewidth 0 setgray}bdf
/dlin{exch currentpoint currentlinewidth 2 div dup
translate newpath moveto lineto currentpoint stroke grestore moveto}bdf
/lin{fg 6 get 0 ne{lineto currentpoint 0 doop moveto}
{exch currentpoint /pnlv xdf /pnlh xdf gsave newpath /@1 xdf /@2 xdf fp{pnlh @2 lt{pnlv @1 ge
{pnlh pnlv moveto @2 @1 lineto pnsh 0 rlineto
0 pnsv rlineto pnlh pnsh add pnlv pnsv add lineto pnsh neg 0 rlineto}
{pnlh pnlv moveto pnsh 0 rlineto @2 pnsh add @1 lineto 0 pnsv rlineto
pnsh neg 0 rlineto pnlh pnlv pnsv add lineto}ifelse}{pnlv @1 gt
{@2 @1 moveto pnsh 0 rlineto pnlh pnsh add pnlv lineto 0 pnsv rlineto
pnsh neg 0 rlineto @2 @1 pnsv add lineto}{pnlh pnlv moveto pnsh 0 rlineto
0 pnsv rlineto @2 pnsh add @1 pnsv add lineto pnsh neg 0 rlineto
0 pnsv neg rlineto}ifelse}ifelse
closepath fill}if @2 @1 grestore moveto}ifelse}bdf
/gw{/pnm fg 3 get fg 4 get div def}bdf
/lw{fg exch 4 exch put fg exch 3 exch put gw pnsv pnsh pen}bdf
/barc{/@1 xdf /@2 xdf /@3 xdf /@4 xdf /@5 xdf
/@6 xdf /@7 xdf /@8 xdf gsave
@@5 @7 add 2 div @6 @8 add 2 div translate newpath 0 0 moveto
@@5 @7 sub @6 @8 sub mtx currentmatrix pop scale @1{newpath}if
0 0 0.5 @4 @3 arc @4 @3 sub abs 360 ge{closepath}if
mtx setmatrix @2 doop grestore}bdf
/ar{dup 0 eq barc}bdf
/ov{0 exch 360 exch true barc}bdf
/rc{/@t xdf currentpoint 6 2 roll newpath 4 copy 4 2 roll exch moveto
6 -1 roll lineto lineto lineto closepath @t doop moveto}bdf
/mup{dup pnsh 2 div le exch pnsv 2 div le or}bdf
/rr{/@1 xdf 2. div /@2 xdf 2. div /@3 xdf
/@4 xdf /@5 xdf /@6 xdf /@7 xdf
@@7 @5 eq @6 @4 eq @2 mup or or{@7 @6 @5 @4 @1 rc}
{@4 @6 sub 2. div dup @2 lt{/@2 xdf}{pop}ifelse
@@5 @7 sub 2. div dup @2 lt{/@2 xdf}{pop}ifelse
@@1 0 eq{/@2 @2 pnsh 2 div 2 copy gt{sub def}{0 pop4}ifelse}if
currentpoint newpath
@@4 @6 add 2. div @7 moveto
@@4 @7 @4 @5 @2 arcto pop4
@@4 @5 @6 @5 @2 arcto pop4
@@6 @5 @6 @7 @2 arcto pop4
@@6 @7 @4 @7 @2 arcto pop4
closepath @1 doop moveto}ifelse}bdf
/pr{gsave newpath /pl{exch moveto /pl{exch lineto}def}def}bdf
/pl{exch lineto}bdf
/ep{dup 0 eq{{moveto}{exch lin}{}{(%%[|1|]%%)= flush}pathforall
pop grestore}{doop grestore}ifelse currentpoint newpath moveto}bdf
/gr{64. div setgray}bdf
/pat{s8 copy pop 9.375 pa por not{90 add}if{1 add 4 mul cvi s8 exch get exch 1 add 4 mul cvi 7 sub bitshift 1 and}setscreen gr}bdf
/sg{freq rot /spf load setscreen gr}bdf
/dc{transform round .5 sub exch round .5 sub exch itransform}bdf
/sn{userdict /smooth4 known}bdf
/x8{3 bitshift}bdf
/x4{2 bitshift}bdf
/d4{-2 bitshift}bdf
/d8{-3 bitshift}bdf
/xf{.12 mul exch .125 mul}bdf
/rb{31 add -5 bitshift 2 bitshift}bdf
/db{save 10 1 roll
/@1 xdf /@2 xdf /@3 xdf /@4 xdf /@5 xdf
/@6 @5 @3 4 add mul def
xf exch dc translate
/@7 xdf /@8 xdf
@@8 @7 xf 0.96 mul exch scale
0 0 1 1 10 rc clip
@@1 0 eq @1 4 eq or{1 setgray 0 1 1 idtransform exch pop add 0 1 1 2 rc}if
@@1 3 eq @1 7 eq or{1}{0}ifelse setgray
/@9 @1 0 eq @1 1 eq @1 3 eq or or def
/@10 @4 x4 def /@11 @3 x4 def
/@12 @10 rb def /@13 @12 @11 mul def
/@15 1 1 dtransform round cvi /@14 exch def round cvi def
/@16 @15 rb def /@17 @16 @14 mul def
sn{
@@17 60000 lt{
@@16 x8 @14 @9 [@15 0 0 @14 0 0]{
@@17 string @13 string
currentfile @6 string readhexstring pop
1 index @4 @3 @5 @12 @2 smooth4
@@10 @11 @12 dup string 5 index @15 @14 @16 dup string stretch
}imagemask
}{
@@12 x8 @11 @9 [@10 0 0 @11 0 0]{
@@13 string
currentfile @6 string readhexstring pop
1 index @4 @3 @5 @12 @2 smooth4
}imagemask
}ifelse}
{@5 3 bitshift @3 4 add @9 [@4 0 0 @3 0 2]
{currentfile @6 string readhexstring pop}imagemask
}ifelse
restore
}bdf
/wd 16 dict def
/mfont 14 dict def
/mdf{mfont wcheck not{/mfont 14 dict def}if mfont begin xdf end}bdf
/cf{{1 index /FID ne{tmp 3 1 roll put}{pop pop}ifelse}forall}bdf
/mv{fmv{tmp /Encoding macvec put}if}bdf
/du{FontDirectory 2 index known{pop pop false}
{findfont dup length dict /tmp exch def cf true}ifelse}bdf
/nf{{tmp definefont pop}if}bdf
/rf{/fmv exch def du dup{mv}if nf}bdf
/fe{dup{tmp /Encoding 2 copy get dup length array copy put}if}bdf
/ce{tmp /Encoding get 3 1 roll put}bdf
/xs{\312\312 serverdict begin exitserver}bdf
/mywidth{bitwidth 3 lt{3}{bitwidth}ifelse}bdf
/bmbc{exch begin wd begin
/cr xdf
save
CharTable cr 6 mul 6 getinterval{}forall
/bitheight xdf /bitwidth xdf
@.96 div /width xdf
Gkernmax add /XOffset xdf Gdescent add /YOffset xdf /rowbytes xdf
rowbytes 255 eq{0 0 0 0 0 0 setcachedevice}
{Gnormsize dup scale
width 0 XOffset YOffset bitwidth XOffset add bitheight YOffset add
setcachedevice
rowbytes 0 ne{
XOffset YOffset translate newpath 0 0 moveto
bitwidth bitheight scale
sn{
/xSmt bitwidth x4 def
/ySmt bitheight x4 def
/rSmt xSmt rb def
rSmt x8 ySmt true
[xSmt 0 0 ySmt neg 0 ySmt]
{rSmt ySmt mul string CharData cr get
1 index mywidth bitheight rowbytes rSmt so smooth4}
}{rowbytes 3 bitshift bitheight 4 add true
[bitwidth 0 0 bitheight neg 0 bitheight 2 add]
{CharData cr get}
}ifelse
imagemask
}if
}ifelse
restore
end end
}bdf
/bb{.96 exch div /Gnormsize mdf 2 index
/Gkernmax mdf 1 index /Gdescent mdf
3 index div 4 1 roll
2 index div 1. 5 2 roll
exch div 4 1 roll
4 array astore /FontBBox mdf
}bdf
/cdf{mfont /CharData get 3 1 roll put}bdf
/bf{
mfont begin
/FontType 3 def
/FontMatrix [1 0 0 1 0 0] def
/Encoding macvec def
/BuildChar /bmbc load def
end
mfont definefont pop
}bdf
/wi LW+{/stringwidth load}
{{gsave 0 0 0 0 0 0 0 0 moveto lineto lineto lineto closepath clip stringwidth grestore}bind}ifelse def
/aps{0 get 124 eq}bdf
/xc{s75 cvs dup}bdf
/xp{put cvn}bdf
/scs{xc 3 67 put dup 0 95 xp}bdf
/sos{xc 3 79 xp}bdf
/sbs{xc 1 66 xp}bdf
/sis{xc 2 73 xp}bdf
/sob{xc 2 79 xp}bdf
/sss{xc 4 83 xp}bdf
/dd{exch 1 index add 3 1 roll add exch}bdf
/smc{moveto dup lws}bdf
/kwn{dup FontDirectory exch known{findfont exch pop}}bdf
/gl{1 currentgray sub setgray}bdf
/mm{/mfont 10 dict def mfont begin
/FontMatrix [1 0 0 1 0 0] def
/FontType 3 def
/Encoding macvec def
/df 4 index findfont def
/FontBBox [0 0 1 1] def
/xda xdf /mbc xdf
/BuildChar{wd begin /cr xdf /fd xdf /cs s1 dup 0 cr put def fd /mbc get exec end}def
exec end mfont definefont}bdf
/ac{dup scs kwn{exch /ofd exch findfont def /tmp ofd maxlength 1 add dict def ofd cf mv
tmp dup dup /StrokeWidth nlw 1000 mul pys div ps div dup 12 lt{pop 12}if put
/PaintType 2 put definefont}ifelse}bdf
/mb{dup sbs kwn{exch{pop}{bbc}{}mm}ifelse sfd}bdf
/mo{dup sos kwn{exch{pop}{boc}{}mm}ifelse sfd}bdf
/ms{dup sss kwn{exch{pop}{bsc}{}mm}ifelse sfd}bdf
/ou{dup sos kwn{exch dup ac pop{scs findfont /df2 xdf}{aoc}{}mm}ifelse sfd}bdf
/su{dup sss kwn{exch dup ac pop{scs findfont /df2 xdf}{asc}{}mm}ifelse sfd}bdf
/ao{/fmv true def ou}bdf /as{/fmv true def su}bdf /vo{/fmv false def ou}bdf /vs{/fmv false def su}bdf
/bbc{/da .03 def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs 0 0 smc da 0 smc da da smc 0 da moveto lws}bdf
/boc{/da 1 ps div def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs 0 0 smc da 0 smc da da smc 0 da smc gl da 2. div dup moveto lws}bdf
/bsc{/da 1 ps div def
/ds .05 def /da2 da 2. div def fd /df get setfont
gsave cs wi exch ds add da2 add exch grestore setcharwidth
cs ds da2 add .01 add 0 smc 0 ds da2 sub translate 0 0 smc
da 0 smc da da smc 0 da smc gl da 2. div dup moveto lws}bdf
/aoc{fd /df get setfont
gsave cs wi grestore setcharwidth
gl cs 0 0 smc fd /df2 get setfont gl 0 0 moveto lws}bdf
/asc{/da .05 def fd /df get setfont
gsave cs wi exch da add exch grestore setcharwidth
cs da .01 add 0 smc 0 da translate gl 0 0 smc gl fd /df2 get setfont 0 0 moveto lws}bdf
/dly{/@t exch st{@t the{exit}if}loop}bdf
/st{1000 mul usertime add dup 2147483647 gt{2147483647 sub}if def}bdf
/the{usertime sub dup 0 lt exch -2147483648 gt and}bdf
/lsf{save FontDirectory{pop = flush}forall
systemdict /filenameforall known
{(fonts/*){dup length 6 sub 6 exch getinterval = flush}s75 filenameforall}if
/* = flush restore}bdf
/6a 6 array def
/2a 2 array def
/3q 3 array def
/qs{3 -1 roll sub exch 3 -1 roll sub exch}bdf
/qa{3 -1 roll add exch 3 -1 roll add exch}bdf
/qm{3 -1 roll 1 index mul 3 1 roll mul}bdf
/qn{6a exch get mul}bdf
/qA .166667 def /qB .833333 def /qC .5 def
/qx{6a astore pop
qA 0 qn qB 2 qn add   qA 1 qn qB 3 qn add
qB 2 qn qA 4 qn add   qB 3 qn qA 5 qn add
qC 2 qn qC 4 qn add   qC 3 qn qC 5 qn add}bdf
/qp{6 copy 12 -2 roll pop pop}bdf
/qc{exch qp qx curveto}bdf
/qi{{exch 4 copy 2a astore aload pop qa .5 qm newpath moveto}{exch 2 copy 6 -2 roll 2 qm qs 4 2 roll}ifelse}bdf
/qq{{qc 2a aload pop qx curveto}{exch 4 copy qs qa qx curveto}ifelse}bdf
/pt{currentpoint newpath moveto}bdf
/qf{/fillflag true def}bdf
/ec{1 and 0 ne{0 doop}if grestore currentpoint newpath moveto /fillflag false def}bdf
/eu{currentpoint fp{0 ep}{grestore newpath}ifelse moveto /fillflag false def}bdf
/bp{currentpoint newpath 2 copy moveto}bdf
/ef{gsave fillflag{gsave eofill grestore}if}bdf
/sm{dup 0 exch{32 eq{1 add}if}forall}bdf
/ll{3 1 roll exch
sub dup abs .5 lt{pop show}{1 index sm
fg 7 get dup 127 ne{4 1 roll exch pop dv 0 4 -2 roll exch widthshow}
{pop dup 0 eq 3 index 0 le or{pop length div 0 3 -1 roll ashow}
{10 mul exch length add div dup 10 mul 0 32 4 -1 roll 0 6 -1 roll awidthshow
}ifelse}ifelse}ifelse}bdf
/dss{currentfont bu 0 sa 6 get 0 ne{pop 1}{sa 7 get 0 eq{pop 2}if}ifelse sa 1 get 0 ne
/|______Symbol sa 4 get 0 ne{vs}{sa 3 get 0 ne{vo}{fnt}ifelse}ifelse bn fg 7 get currentfont}bdf
/ss{dss pop pop}bdf
/dpf{fg 7 get 8 -1 roll dup setfont}bdf
/pf{setfont}bdf
/mc{0 3 1 roll transform neg exch pop}bdf
/rs{sa 2 get 0 ne{gsave 1 index 0
/UnderlinePosition kif{mc}{ps -10 div}ifelse
/UnderlineThickness kif{mc}{ps 15 div}ifelse
setlinewidth currentpoint 3 -1 roll sub moveto
sa 4 get 0 ne{gsave currentlinewidth 2. div dup rmoveto currentpoint translate 2 copy rlineto
stroke grestore}if sa 3 get sa 4 get or 0 ne 3 1 roll 2 index{gsave gl 2 copy rlineto stroke grestore}if
rlineto{strokepath nlw pys div setlinewidth}if stroke grestore}if tv}bdf
/sgt{2 copy known{get true}{pop pop false}ifelse}bdf
/kif{currentfont dup /FontMatrix get exch /FontInfo sgt{true}{currentfont /df sgt
{dup /FontInfo sgt{3 1 roll /FontMatrix get mtx concatmatrix exch true}{pop pop pop false}
ifelse}{pop pop false}ifelse}ifelse{3 -1 roll sgt{exch true}{pop false}ifelse}{false}ifelse}bdf
/blank /Times-Roman findfont /CharStrings get /space get def
/macvec 256 array def
/NUL /SOH /STX /ETX /EOT /ENQ /ACK /BEL /BS /HT /LF /VT /FF /CR /SO /SI
/DLE /DC1 /DC2 /DC3 /DC4 /NAK /SYN /ETB /CAN /EM /SUB /ESC /FS /GS /RS /US
macvec 0 32 getinterval astore pop
macvec 32 /Times-Roman findfont /Encoding get
32 96 getinterval putinterval macvec dup 39 /quotesingle put 96 /grave put
/Adieresis /Aring /Ccedilla /Eacute /Ntilde /Odieresis /Udieresis /aacute
/agrave /acircumflex /adieresis /atilde /aring /ccedilla /eacute /egrave
/ecircumflex /edieresis /iacute /igrave /icircumflex /idieresis /ntilde /oacute
/ograve /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis
/dagger /degree /cent /sterling /section /bullet /paragraph /germandbls
/registered /copyright /trademark /acute /dieresis /notequal /AE /Oslash
/infinity /plusminus /lessequal /greaterequal /yen /mu /partialdiff /summation
/product /pi /integral /ordfeminine /ordmasculine /Omega /ae /oslash
/questiondown /exclamdown /logicalnot /radical /florin /approxequal /Delta /guillemotleft
/guillemotright /ellipsis /blank /Agrave /Atilde /Otilde /OE /oe
/endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright /divide /lozenge
/ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright /fi /fl
/daggerdbl /periodcentered /quotesinglbase /quotedblbase /perthousand /Acircumflex /Ecircumflex /Aacute
/Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex
/apple /Ograve /Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde
/macron /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
macvec 128 128 getinterval astore pop
/|______Courier /Courier T rf
/|______Symbol /Symbol F rf
/|______Seattle /Helvetica findfont dup length 1 add dict /tmp xdf cf mv
/mxv[/zero /one /two /three /four /five /six /seven /eight /nine /comma /period /dollar /numbersign
/percent /plus /hyphen /E /parenleft /parenright /space]def
tmp /Metrics 21 dict dup begin mxv{600 def}forall end put
tmp begin /FontBBox FontBBox [0 0 0 0] astore def end
tmp definefont pop
/od{(Rvd\001\001\000\000\177) fg copy pop txpose
1 0 mtx defaultmatrix dtransform exch atan /pa exch def
newpath clippath mark
{transform{itransform moveto}}{transform{itransform lineto}}
{6 -2 roll transform 6 -2 roll transform 6 -2 roll transform
{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll curveto}}
{{closepath}}pathforall newpath counttomark array astore /gc xdf pop ct 39 0 put
10 fz 0 fs 2 F /|______Courier fnt}bdf
/cd{}bdf
/op{/sfl false def /pm save def}bdf
/cp{not{userdict /#copies 0 put}if ma 0 gt{{t1 the{exit}if}loop}if{copypage}{showpage}ifelse pm restore}bdf
/px{0 3 1 roll tp tt}bdf
/py{}bdf
/psb{/us save def}bdf
/pse{us restore}bdf
/ct 40 string def
/nc{currentpoint initclip newpath gc{dup type dup /arraytype eq exch /packedarraytype eq or{exec}if}
forall clip newpath moveto}bdf
/kp{ct 0 2 index length 2 index 39 2 index put getinterval copy cvx exec mx3 currentmatrix pop}bdf
end
LW 1 eq userdict /a4small known not and{/a4small
[[300 72 div 0 0 -300 72 div -120 3381]
280 3255
{statusdict /jobstate (printing) put 0 setblink
margins
exch 196 add exch 304 add 8 div round cvi frametoroket
statusdict /jobstate (busy) put
1 setblink}
/framedevice load
60 45{dup mul exch dup mul add 1.0 exch sub}/setscreen load
{}/settransfer load /initgraphics load /erasepage load]cvx
statusdict begin bind end readonly def}if
systemdict /currentpacking known{setpacking}if
currentfile ok userdict /stretch known not and{eexec}{flushfile}ifelse
65AA4A713677354B973A18568FC280503CC41B6B93EF08197CF9B804786C66F3
D886695F12CD7851878AAC202A10EF606A27EEA3B092C7CBD2364DAC4E59CB7A
75BE1F9C3577E27C721433A0A158DE9BFC0F767AA5740EB06613B805377B178B
4BA4C41D1C02FBF108A1705699BEDEE47CB87F09E2168112A37556F1BA074D1B
50155F9C3FFBC61304BFFAEDF2F7D8DF9BA9C32CF213EEFEBED2C6AE2BE6893E
C203EE89F4EA8C9C8E0721FF85A1F3C42311E34CFCC03B0321050AE6E1999072
F3C51F8B450D3AE2051DDBD07FBF11CB867F0E79185CBCCD8EA7EAC1E564395F
838B9502D36700643B87675BB64504D1498D4F2442E9D2E5862ACFAC1B4987F1
5D68CB23017186524A26DA756CF9F9A35356440CF114148421B8BA6B80A08F7E
06B6195C8E741686D092F33A9D9EA512E02BE29C066BE09E71A41BC80BB3BA52
491783CDD48B80BD8F447AFBB6CABAFB42316002DCFCCD055266D2455AD82544
2A347F2D1355E7D88B770B3874F3DFF58E340EF88D0A0B871349BED4E35F1C2A
ADED8DB73C2FE38FFF3B3027BFAA005F5B3B46AD8EBE5EA5FC919C6AC5491EF2
0F006BECE44E4C88EDFF5362BFFC5EABCC08C72C07E81510423EB92C778CE755
A7F1C8A83B71C0A61A024DCA73D9BE4ACE7A4722DA1FB1C7FF5E6B1A8DC88F09
40AF6284FEF434FCAD47C814DEEB2A366F62177D0212051E1AB60145EDBFF2DE
CAC7783355F1148260756BCE0B52CB5D656205B63C0E17DB754B0181403343CC
5CA34D7F05E249C954CDC2B444D469F1E57A1BDC0ECDD24F05E4C7462FBBF26D
9393DA54DAC459C2BE2E43395F7AE075CE60B7E5D4AF0C11270D6E2864F9E81D
C056DCCA55FE8A99982B72FB32A426A1BA8D16E4AC78991BBBCE64A83B7C0343
4A3106ECD1AE93F848BB06F0833A065CC0930B65330B5ABCE6512F6B4B9F6006
2080BDE64EE6413B8B06A06D50D6AC85523A41774E3B8B05F7E90162186FF271
ECBE624285475DF352D540FE7E30C66E03304D19096C933FC41945219F6820C2
57007007FD314C8814598A67DD30351862495B476390A3410AB96A74EB58C9EF
92499372DE0EF8A8E4C6EA819035411667346C30C29663FAF3B741CC833F72A7
ACCAFB99209A28C59B89D962D37E7034D18EE6937A1D7C4F52B6EEE385CFD51E
CDCF59BB6E93C2E33B4F6450150E37C40019F685F6C5A717AB0BF130152FB2E2
FE67590FCFF41D697307665C1D3FCF9EC5C7D1F6FB700B80B4C5DE72B8265F15
5A802E2B990CF1F2C6A7F2A3476B6180551DA8CA880A95D7C350CF90E13076CE
6BC91B49A6DAEFDAD43B2529719113A6A09102DFDF62D57EEBF5FD7B9E439255
62EF789F1A3F265B163FCF5AF6BA6D3BD1FBB11421460A8BD53E8D1EAF2ECCF7
764435D68C9E159843F7A1C5A0F2AE37686CA9984B219C5F58E342D7794C15D3
4C556EC31DDC4B720BDD6FBCB29ADE9DE0DACE89AF5FD6E1499FE84DBBC9F47E
4BC2AB37A5817750890BDBC7667B7A307C27B7E8B5017286CA1E1B9B2494E51A
166348B588AF2FB7855D35BD60D528E6749513668DF15E5F4919907B387611BD
84836925889E1A65C6CE8450E3466720E007C5FF001DC9065719F8D04E7EAAA1
DFDD8DD85ECD32393A46385A161EA1ACAB1B5C0E3F666BCEB135B696E41D7500
00000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
currentfile ok userdict /smooth4 known not and{eexec}{flushfile}ifelse
F94E00EE41A71C59E5CAEED1EDBCF23D1DBA1EE99B9BB356492923BD8B1BA83A
87CEB0E07377A31FD6241E814681118E17DC7CACE570399506E6E441B871B604
3831BD03EFC11DBBD8001EE2FF8CFBD485065D455A2E15AC36F1A84AD8789FA6
461199C7CD14CB9FD64D4B06452B7FC0A8FC263F70F1CCB893295D4DE70ADAB7
71C0F84396FA98C60B11DA02ABA157298DF0A23621853BEF167443A985ADC09B
EFFD51CB4D29179E2B34609EF38A49DA61F4BFC256A3DE0732D7D29754A19485
7B9C9E9971227AA1DD0611FBB10E44E5FF66C062D9C24ED3290529330BC31782
5E876929582DB0E39B9FC5EFD20CC1D4F94920EB9C534D0DA90DE70D25BC7287
319CF28602B3F46633C242CAFC8905E960317E3C2FA20AB8DB06ADBAF292FC7B
A2CA14EE65DF28B99CC11666B70AD33E8E1D57D63D4B89ECC615AE5747C1CA75
2C833D8D6DE54CD4A0350B44310555CE3BD2C615ADD27B634CDB350AF3A432CE
78AACD2909A5B586F666CD87919A36DB1CBE86B3CE281DFD01CD7E1B8A18A4B4
15CECBFF79A5C4390A15EA77D14D6BE12BAB5A8268C3F286D0590060647CABED
674443CD258F11415E866AB330A251691B61F2422A61AFE59B6B4FBDCF85ED9B
A0F8E483C034089E6877FF5923698D3A0DC0EED6B9CFD32DF0839BC4EA5F6D1F
CB6DD0920391E57E84745131D02D100179F4E0A68EC0A5FF6680A6F463D038B0
4AF63FFA13D743B995A26A743C26D387209023C91DE43DF047A16F328AC9DDC0
8573B38BE9EA341EA16C78EC32F3A1B36B90D95A50610F4D050EC1C33497F3F3
A81A1B4C8BEF0BA84EE2FAA32DC112DAC490AF53E1749C4A0D866CAF7B893E52
383B0D38065C333FB122B700D7246F7EE87D942AE3DB5C1DD77E9E76C80CC5AD
63D28DFED0E229CE604673F78CD47F258FDF5BF3A3EAEC5C9BC8E482D8DBA9D2
68A35DA8C095A690679ED2123E8B8F5E4826FA3B199EAA5D482D4B6AA86572E3
87CECEB7149C8947F41D6339328A748A17F8C4AD3B0555F1E409450BA0C564F1
F488BB5096EB003568D4D5EF6489897E27409547D0EE4487D30184793B0F27BD
265A64BDB3EA6761569DA955620C612E718677B77D6D81B999C6298877AFE0D1
D6F6F358377A8BD2402F669C64B972B3A065EF7DD4BDEFFFE17E63DB8898FA6E
69166B710AAD6BA2EA9AF61E4B8C8701638D4D6E4DFFFC192AEF6BC027095C4C
72D748979675BA29FAF61E75343E14E61034602E5A79CD2519796ED6A9CC4EDE
A46A9B59D4A807E786B5EE46F25B0360BC8E7C12D723122CDEEF247C9776F4C9
9C8EBED6828AA19744B5ADF0D07D95D98B3072372388D41B0FAB1CCE27751706
79575ECDCA13B22A17FE9C6605C3445F58F1A829512DAB6C528F83580C8AA53C
35D605F626F5AD0B7FC1EA87D69A835E3F53A1F450FB0AF42A5772F89D92A50D
10F15BDBDA409F50C0B8AB93FE8A16D029DD8BB5C480D1466735ED4D9CAF637E
5ECD6C2ECB6BF3B3EFBEE7AB936D2C568E3009D156B87CACB1FB3A48A70BC91B
2EC35CC9147FFB1A524E2B2F2E4E2C1B12F1C1C63768BB95CD62FEC01CBA79B9
FA282DD4DF49990F27FF8EE4E2DDE2F0ACD83BC9D4BE0090192C7A799967EC4D
C2D63C0835E22D4C4B366D7FDCF3A05A4B53DF780F986EF25C79B665D5C00EFF
7F17C0BB6D544F9D83A7FDAC47D9C5683A656011374253C918FF6EA64749DD97
1B2300DD5320033E01EC591F6318CCE94CE2B81C04322EC52B624E50643B5239
1CCD2AB56396A2AD8E2D3CA61B80D9D4CC363B2DF7863526958CDF3497E36648
406C317E58EC563E7C26149A2A3C643ADFB39A8DD92974C6D2A2A9D7B71CDF3F
EBBF32BB02E7B45CF53AAEAD5E963A4AA4AF9A149A08A4EC303D5F2369977E93
F54897EEAD31B06C5845D63F49D65F8E5573962241A57CCD717CE6CA8C784A11
192943616EA059B51BC38429E18D0121FCBB6FBD5D909B0D89E616C66DEF6A0F
165A7030BD911A1B120468329CBB006C8D37720E531CF31E878CB4AAAC137633
675C3D546F5162487AB35F470C042BDEB945E0F2532BF92AA6FD53434440221E
CD3533A7AA89900CB19EFE2CD872DF8B7969AF0D3B72BF31DC5DD69CA6460966
F61AB17CB507964098DBA3AF122EEC3128A9BAFE1034493F372B36BD1351205E
9043A67C544402D8BCE24358C8A5CE33867A00794CF7097D59C88279A11EE9C8
54E7E7AAE881F9828C569D208F5F33375F59E9A3818CFA38AAD0CBFBA32F9F44
A8BB79DE4C40E3886457C16DA4A27953AA1E99472E35F2323F0BAA5E37DC28CB
A46FEFB73B190016055ADD4D27615D748499A0E1C4B8C7EC339C1C4D95A813A8
5918A8D01EEB485DDCDCEA6EA3F2C2A9D85C139CD90CCB352634F9AFE836BCAC
0C274E352BA2071B5269D5DE4CCDE3FF990CBA974980C7332AE1545A9C60D5D1
459D3AE95C1AC065733AF14FADB440A110DD539563B8D850CD0704C52F3F7CCC
B53630D776560CBD22D8FF08F5B354487A171AEC15F5F54DE9CAB668BCAC573E
788D92762EF63E76087005F4AC2D02E0CAC173C11BE62ACE5DC4D3374F2F9746
C9981E125FF9AB8CAE76D13039E2C54DFD708E028A619EA1ED78E6B46F06DF0D
0B74BBEDD8C190C7C0CEBDE8F7A4888CC36575313478DD2CFE392E9BB7B24169
55D44B7024A3BA43FBF37293B386D64746D7748895411D243FAEC50638F2AA33
337D7FA018ADDAC5835A0DDFAE99AD6299DFB4CA6872C59853E3AC12FC9E3D26
629C5B49CF844C87B3C4BFBE3074E3A1CE6984758C20C661084381CD6B4582D8
4F19C0000B5FC0DCB42B567E396031601C095D7016283EBE5F13CD8A3A374A74
DDBBABD36081149F8BC242085F2F7297CC97FD3B8BAD206D8AC9707A39ECCC79
63B522E08DA391A1EF12DD4D746DBDDDCC0834F88160CF189A9645567CEC2F02
3A571AF0DFD15DB85B744C28C000DF53B05F8F210841F6E87A04F20C777B7C0B
E6182BE2E90226E5301A12532A745F2FAAA81637CF11B78CD2B99A4D18B862D6
C5DBD31793FB16A2D9AAD376D4484D75AA833D0068B1D34DB74E3302480854E3
B5484D8A47E39A89A2FA927BC3641EA7F8E004FDE4C2F08D40D99F1ACB47CAF6
887629BF6DFE12968D297596D28CE0CF148B12E7DCB49FB94F5ADBD214C3A6CE
1E249831BA9EB8A189F2CE1ABE39A7B537253E369A508A2AF2ADB9463F9B56BB
BFF31D535FF997F537C6675C196E7ECBD493F652FA7CC6D9C1CA3379BFDB5AF7
513C6E834054494296B91A6EE800114363D5D5D0759F41B4DECB653B9DE3E945
83579EF549ED5F3FAFB12661ABC0C57A332406517ED3454EDED34B386C60F78D
C976266E0EAF54FC245FB0E3EFC8016236436B599C1C97A8C5E0AC8F78361618
73C71F01ED9CC25C236420F41FD8277993D3959205912FA0927B59E3DAE7377D
82079447D6E41EE5AEC0DFFF79AF8F4ED47F17EE708FEA45877860D56F8CBCE6
5A061E8E1CA4A5FBAF0E13429A7F0ADB6F178FA449F46CC539BBC0107E3A53B1
C362A04B20E6D721E7E6E1E4976A11DDC98C7614D22B53DFBB6DAE533AC9BE88
2021A735C30DAA4A44AED09F49A390E8CFF59BD9C30667AF21B03EC5CEBD5C2C
3AA2769E8D714191A48E7DDF50B13D1560E82EFB65FCE601AE9E8C351FBA1DED
80B7351314E7F9F9A784BFE3759B7E322A84E7B51F9DC5F5D9C8050CD79B27C0
A4B0DD68A3C27A948AD6858E35B960D2DEA838C479CAEA83B1A912174ACB2100
E55E7A14892D7A9B3711FF0B20065C1995B49E1F23464A92DD140642E3A7B197
3849E64D1A3CF600000000000000000000000000000000000000000000000000
00000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EOF
@//E*O*F laser-prep-49.pro//
chmod u=rw,g=r,o=r laser-prep-49.pro
 
echo x - maclaser.csh
sed 's/^@//' > "maclaser.csh" <<'@//E*O*F maclaser.csh//'
#! /bin/csh -f

# A simple script to spool files prepared on a Macintosh for printing on
# the LaserWriter.  It expilictly spools to the lw printer and flags the
# file as "Fortran" type.  This file type is redefined locally to mean
# a mac Postscript file, causing the Apple laser-prep file to be prepended
# to provide the standard Mac environment in the printer when the file
# is processed.
# Files spooled with maclaser should have been created on the Mac with
# the COMMAND-F sequence and the resulting PostScript file uploaded  [RH]
#
#  April 1986	Generalized to handle arbitrary option args and accept
#		multiple file names.  This is now a general filter for
#		calling lpr.  Options and file names can be mixed up in
#		the "wrong" order and they will be given to lpr in the 
#		order it wants them.  The 'always' variable is what makes
#		this a script specific to handling Mac Postscript.
#		Ron Hitchens (hitchens@sally), Brian Powell (brian@sally)
#

set lpr = /usr/ucb/lpr
set lw = -Plw
set always = (-f)		# this means Mac PostScript (local spooler hack)
set flags = ()
set files = ()

top:
	if ($#argv > 0) then
		switch ($argv[1])
		case -P*:		# need to look for this one specifically
			set lw=$argv[1]	# since we've setup a default
			shift argv
			goto top
		case -:			# pretend this means read stdin
			shift argv	# lpr reads stdin if no files names
			goto top	# are given anyway.  Ignore it.
		case -*:
			set flags = ($flags $argv[1])
			shift argv
			goto top
		default:
			set files = ($files $argv[1])
			shift argv
			goto top
		endsw
	endif

exec $lpr $always $lw $flags $files
@//E*O*F maclaser.csh//
chmod u=rwx,g=rx,o=rx maclaser.csh
 
echo x - psfilter.csh
sed 's/^@//' > "psfilter.csh" <<'@//E*O*F psfilter.csh//'
#! /bin/csh -f
#
# psfilter - filter for the Apple LaserWriter (Postscript) printer
#
#  DON'T edit this file directly, edit the source in 
#  /usr/src/local/prop/transcript/src/psfilter.csh, run make psfilter
#  and install the result.  I had to retrofit changes once, please consider
#  the poor slob who has to change it next time.  (R.H. 5/85)
#
# Each of these files is merely a link to the current file, and we look at
# argument 0 to see which one we are being called by.  Alternatively, you
# may wish to modify printjob.c (/usr/src/usr.lib/lpr/printjob.c) to pass
# the name of the filter you wish to use as the argument following the -f
# switch.
#


set name host filter x y indent width length acct pid printer title
setenv TERMCAP /etc/printcap
umask 0

if ($?0) set filter = $0

top:
	if($#argv > 0) then
		switch ($argv[1])
		case -f:	# filter desired
			shift argv
			if ($#argv > 0) then
				set filter = $argv[1]
				shift argv
			endif
			goto top

		case -h:	# host spooling file
			shift argv
			if ($#argv > 0) then
				set host = $argv[1]
				shift argv
			endif
			goto top

		case -i*:	# indentation, ignored for now
			set i=$argv[1]
			shift argv
			goto top

		case -l*:	# page length, ignored for now
			set l=$argv[1]
			shift argv
			goto top

		case -n:	# uid of spooling user
			shift argv
			if ($#argv > 0) then
				set name = $argv[1]
				shift argv
			endif
			goto top

		case -p:	# printer to be used
			shift argv
			if ($#argv > 0) then
				set printer = (-i $argv[1])
				set pset
				shift argv
			endif
			goto top

		case -w*:	# page width, ignored for now
			set width=$argv[1]
			shift argv
			goto top

		case -x*:	# starting x position, ignored for now
			set x=$argv[1]
			shift argv
			goto top

		case -y*:	# starting y position, ignored for now
			set y=$argv[1]
			shift argv
			goto top

		default:	# currently assumed to be the accounting file
				# This name is defined as af in printcap
				# tail of name must match printer name
			set acct=$argv[1]
			set pid=(-P$argv[1]:t)
			set logfile=/usr/adm/log-$argv[1]:t
			shift argv
			goto top
		endsw
	endif


set lockfile=lock				# doubtful anything else
set cffile=`cat $lockfile | grep cf | head -1`	# grok the name of the cf
set title=`grep N $cffile | head -1 | sed s/N//`	# get job title
set mtmp="/tmp/spoolmail$$"			# name of temp mail file
set policy=.policy				# text file to be mailed
if ( ! -f $policy ) set policy=/dev/null	# subject will have to do
set taunt="Permission to use laser printer denied"

# Contrary to it's name, psif is the filter which talks to the printer. It's
# intended to be specified as the 'if' filter in the printcap.  This works
# fine if everything is processed to PostScript before being spooled, but in
# this setup it is used as the tail of the filter chain.  Psof should be
# specified as the 'of' entry in the printcap and the sh (short header) boolean
# should be set.  It formats a banner maker and psif sends it after EOF on
# the file it is processing.

# Modified June 86 to support LW's on Bridges also.  The printer name in
# the form -Pname (as determined above) is passed to psif.  Psif does a
# gethostbyname call, if the printer name is defined (in /etc/hosts or to
# the nameserver as applicable) then a network socket is opened to that
# address.  The address for the name is actually assigned to a Bridge serial
# port to which the LW is connected.  Psif then treats the socket as its
# stdout and does its normal processing, the output stream will flow across
# the net to the remote LW.  If the gethostbyname call fails then nothing
# special is done and psif behaves as before, assuming its stdout is
# connected to the physical printer device (as setup by lpd).
#  Ron Hitchens

onintr intrupt					# vector int's to error section

# Get the filetype portion of the filter name
switch ($filter:r)

	case /usr/local/lib/psasc:			# ascii document
	case psasc:
		set filtype="ascii"
		if ( "$title" == "" ) set title="ascii document"
# -------------------------------------
# Permission checking/accounting hacks should be hooked in here
# similar entries for each case below
#		/usr/local/lib/laser_ok $host $name # returns 0 if valid user
#		if ( $status ) then
#			Mail -s "$taunt" $name@$host < $policy
#			exit 2		# spool file is discarded
#		endif
# -------------------------------------

		/usr/local/lib/psif -h $host -n $name $pid $acct
		if ( $status ) breaksw			# go handle error
		exit 0					# all is well

	case /usr/local/lib/psdvi:			# TeX document
	case psdvi:
		set filtype="TeX"
		if ( "$title" == "" ) set title="TeX document"
		/usr/local/lib/dvi2ps -i -q  \
			-h /usr/local/lib/allfonts/postscript/tex.ps \
			| /usr/local/lib/psif -h $host -n $name $pid $acct
		if ( $status ) breaksw		# drop down and handle error
		exit 0				# success

	case /usr/local/lib/psditroff:			# ditroff document
	case psditroff:
		set filtype="Ditroff"
		if ( "$title" == "" ) set title="Ditroff document"
		/usr/local/lib/psdit | /usr/local/lib/psrev | \
			/usr/local/lib/psif -h $host -n $name $pid $acct
		if ( $status ) breaksw			# go handle error
		exit 0

	case /usr/local/lib/psmac:		# PS file made by a mac
	case psmac:				# uses rf (fortran) type
		set filtype="Macintosh"
		if ( "$title" == "" ) set title="Mac laser document"
		/usr/local/lib/macfilter | \
			/usr/local/lib/psif -h $host -n $name $pid $acct
		if ( $status ) breaksw		# go handle error
		exit 0

	case /usr/local/lib/pscat:			# old troff, no no
	case pscat:
		set filtype="old style troff"
		if ( "$title" == "" ) set title="old troff document"
		echo "Old style troff is not supported on the LaserWriter" \
			> $mtmp
		echo "Please use ditroff instead." >> $mtmp
		set nolog
		breaksw
		exit 0		# superstition

	default:
		set filtype="LaserWriter"
		if ( "$title" == "" ) set title="document"
		echo "No support for that file type on the LaserWriter" > $mtmp
		set nolog
		breaksw
		exit 0		# superstition

endsw

intrupt:			# a place to catch interrupts, hopefully these
				# shell vars have been set, will be if lpd 
				# kills a running filter, like psif

if ( ! $?nolog ) then
  echo "Error returned by $filtype filter.  Here are the last few lines from" \
	> $mtmp
  echo "the error log, yours should be last:" >> $mtmp
  echo "" >> $mtmp
  tail -8 $logfile >> $mtmp
endif

Mail -s "Error spooling $title to $pid" $name@$host < $mtmp
rm $mtmp

echo "There was a problem with your $filtype job spooled for $pid" > $mtmp
echo "A mail message was sent to you at $host with further details" >> $mtmp
( /usr/local/telegram $name@$host < $mtmp > /dev/null ; rm $mtmp ) &

exit 2				# throw the file away
@//E*O*F psfilter.csh//
chmod u=rwx,g=rx,o=rx psfilter.csh
 
echo x - psmac.csh
sed 's/^@//' > "psmac.csh" <<'@//E*O*F psmac.csh//'
#!/bin/csh -f

# PS file made by a mac, uses rf (fortran) type

# This script is intended to be named in the printcap
# as the "rf" filter.  We chose that because it is for
# files of the "Fortran" type (whatever that means) and
# was unused.  Any of the unused printcap filter slots will
# do as well, so long as Mac postscript files are spooled
# with the proper flag to lpr.  We use a shell script called
# maclaser to do that and hide it from the user.

# macfilter is a shell script that figures out which laser-prep file to
# prepend.
# Ron Hitchens	U of Texas CS	(hitchens@sally.utexas.edu)
# Updated April 9, 1987:  Brian H. Powell (brian@sally.utexas.edu)

/usr/local/lib/macfilter | \
	/usr/local/lib/psif -h $host -n $name $pid $acct

if ( $status ) exit 2		# An error, throw the job away
exit 0
@//E*O*F psmac.csh//
chmod u=rwx,g=rx,o=rx psmac.csh
 
echo x - macfilter.csh
sed 's/^@//' > "macfilter.csh" <<'@//E*O*F macfilter.csh//'
#!/bin/csh -f
#	macfilter
#  Filter for Macintosh-generated PostScript code.
#  By Ron Hitchens & Brian Powell
#	hitchens@sally.utexas.edu	brian@sally.utexas.edu
#	hitchens@ut-sally.UUCP		brian@ut-sally.UUCP
#
#   This filter prepends the necessary LaserPrep file to the Mac file, then
# sends it through a filter to escape 8-bit characters (otherwise lost by the
# UNIX printer driver.)  This version supports the Macintosh LaserWriter driver
# versions 1.1 (LaserPrep version 12), 3.1 (LaserPrep version 40), and 3.3
# (LaserPrep version 49).
#   The difference between the three versions is deduced by looking at the
# first line of the input to this script.  The first line from the 1.1 driver
# consists entirely of "md begin".  The first line from the 3.1 driver consists
# of "%!PS-Adobe-1.0".  The first line from the 3.3 driver consists of
# "%!PS-Adobe-1.2".  This script fgreps for "Adobe-1.2" in the first line and
# if found, prepends the version 49 prep.  Then it fgreps for "Adobe-1.0" and
# if found, prepends the version 40 prep.  Otherwise, it prepends the
# version 12 prep.
#   NOTE:  Other versions of the LaserWriter driver (most notably version 3.0)
# produce output that is not easily distinguishable from output from Laser-
# Writer driver 3.1.  For this reason, this filter cannot provide warnings
# about incorrect input.  In general, the different versions are incompatible,
# and correct output from anything other than PostScript from the Macintosh
# LaserWriter drivers 1.1, 3.1 and 3.3 cannot be expected.


set prepdir=/usr/local/lib/allfonts/postscript	# dir where the prep files live

cat > /tmp/mac$$			# save stdin so we can look at it

# search the first line of stdin for "Adobe-1.2" and "Adobe-1.0".  The
# variable stat1 is true if "Adobe-1.2" isn't found, and the variable stat2
# is true if "Adobe-1.0" isn't found.

head -1 /tmp/mac$$ | fgrep -s Adobe-1.2 >& /dev/null
set stat1=$status
head -1 /tmp/mac$$ | fgrep -s Adobe-1.0 >& /dev/null
set stat2=$status

if ( ! $stat1 ) then
	set prep=laser-prep-49.pro	# found "Adobe-1.2"; use version 49
else if ( ! $stat2 ) then
	set prep=laser-prep-40.pro	# found "Adobe-1.0"; use version 40
else
	set prep=laser-prep-12.pro	# not found; assume version 12
endif

# Concatenate the prep and the Mac job.  The combined Postscript is then
# piped thru a filter to escape any chars with the high bit set (Apple
# dropped the ball on that one).  The final result goes down our stdout
# which is usually being piped into the printer driver (psif or pscomm)

cat $prepdir/$prep /tmp/mac$$ | /usr/local/lib/ps8

set result=$status		# save the result for our exit code

rm -f /tmp/mac$$		# make sure rm runs silently

exit $result			# that all
@//E*O*F macfilter.csh//
chmod u=rwx,g=rx,o=rx macfilter.csh
 
echo x - paintps.c
sed 's/^@//' > "paintps.c" <<'@//E*O*F paintps.c//'
#ifndef lint
static	char sccsid[] = "@(#)paintps.c	1.7 6/11/86 (UT)";
#endif

/*
 * paintps -- Convert MacPaint document to PostScript document 
 * 
 * Brian H. Powell, University of Texas at Austin
 *	brian@sally.UTEXAS.EDU
 *	brian@ut-sally.UUCP
 *	CS.Powell@r20.UTEXAS.EDU
 *
 * This program may be used but not sold without permission.
 *
 * Modification History
 * 	BHP	7/25/85	Created.
 *	BHP	7/31/85	Optimized output routines for execution speed.
 *	BHP	4/22/86	Added -P option, extracted spool command to Makefile.
 *	BHP	6/ 3/86 Fixed bug causing (rare) small white gaps between
 *			bitmaps.
 */

#include <stdio.h>
#include <ctype.h>

#define FALSE 0
#define TRUE  (-1)

#define MACPAINT_HDRSIZE	512
#define MACRASTER_BITWIDTH	576
#define	MACPAINT_BITHEIGHT	720

			/* DEFAULT OPTIONS */
int smooth = TRUE;		/* smoothing enabled */
int copies = 1;			/* one copy of the painting */
char *printername = NULL;	/* default printer */

char hexbuffer[MACPAINT_BITHEIGHT][MACRASTER_BITWIDTH/8];
int blank[MACPAINT_BITHEIGHT + 4];	/* we need the four extra blank */
					/* lines as filler for output */

char usage[] = "paintps [-d] [-#<n>] [-P<printer>] file";

main(ac, av)
char **av;
{
   ac--; av++;
   while (ac && (av[0][0] == '-') && av[0][1]) {
      switch (av[0][1]) {
	 case 'd':			/* "draft" option */
	    smooth = FALSE;
	    break;

	 case '#':			/* number of copies */
	    copies = atoi (&av[0][2]);
	    break;

	 case 'P':			/* printer name */
	    printername = av[0];
	    break;

	 default:
	    goto bad_usage;
      }
      ac--; av++;
   }
   open_output();		/* also starts spooling to the spool cmd. */
   paintfilter(av[0]);
   exit(0);

bad_usage:
   fprintf(stderr, "usage: %s\n", usage);
   exit(1);
}

/* convert from MacPaint to PostScript */

paintfilter(name)
char *name;
{
   register int x, y;
   FILE *fp;
   register int c;
   int blankline;

   fp = fopen(name, "r");		/* open the MacPaint file. */
   if (fp == NULL) {
      perror(name);
      return;
   }

   (void) fseek(fp, (long)MACPAINT_HDRSIZE, 0);	/* skip the MacPaint patterns */

   begin_image();				/* print postscript header */

/*  We skip horizontal whitespace.  "blankline" is used to diagnose this
    for the current line.  The boolean array "blank[y]" shows which lines
    in the entire painting are blank. */

   for (y = 0; y < MACPAINT_BITHEIGHT; y++) {
				/* for each pixel row... */
      blankline = TRUE;
      for (x = 0; x < MACRASTER_BITWIDTH/8; x++) {

         if ((c = getbits(fp)) == EOF) {
            fprintf(stderr, "Unexpected EOF, stopped.\n");
            for ( ; y < MACPAINT_BITHEIGHT; y++)		/* Mark the */
               blank[y] = TRUE;				/* rest of the page */
            blankline = TRUE;		       /* blank, print it and quit. */
            break;

         } else {
            hexbuffer[y][x] = (char) c;	  /* else record the character and */
            if (c)			  /* mark the line as non-blank. */
               blankline = FALSE;
         }
      }
      blank[y] = blankline;
   }
   blank[y++] = TRUE;		/* put four blank lines at end */
   blank[y++] = TRUE;		/* (I think this is needed for smoothing.) */
   blank[y++] = TRUE;
   blank[y] = TRUE;
   dump_buffer(hexbuffer, blank);	/* print the buffer (entire page) */

   end_imag(copies);		/* print the postscript trailer. */
   (void) fclose(fp);		/* close the file. */
}

/* macpaint input routines */

getbits(fp)		/* this routine scarfed from paintimp. */
FILE *fp;
{
/* This routine expands the PackBits encoded MacPaint file,
   delivering one byte per call.
*/

   static int count, rep, chr;
   int c;

   if (rep) {		/* if we are repeating a previous character, */
      rep--;		/* reduce the repeat count and return the char. */
      return chr;
   }
   if (count) {		/* if we are in an unrepeated section, reduce */
      count--;		/* the count and return next char from the file. */
      return getc(fp);
   }
   c = getc(fp);	/* otherwise, get the next repeat count.  */
   if (c & 0x80) {	/* if negative, repeat the next */
      rep = 0x100 - c;	/* byte (2's comp(c)+1) times. */
      chr = getc(fp);		/* the character to repeat */
      return chr;
   }
   else {		/* if repeat count is positive, next "count" bytes */
      count = c;   	/* are unencoded.  */
      return getc(fp);
   }
}

/* PostScript output routines */

open_output()
{
   char lpr [64];
   FILE *popen();

/* if stdout is going to the terminal, call the spool command to spool the
   output, otherwise assume it's being piped somewhere else
   or directed into a file.
*/
   if (isatty (fileno (stdout)))
   {
      (void) sprintf (lpr, "%s %s", SPOOLCMD,
			printername ? printername : "");
		/* include printer name if it was specified.  */

	/* disconnect stdout from the tty and pipe it to lpr */
      (void) fclose (stdout);
      if (popen (lpr, "w") == NULL) {
         fprintf(stderr, "%s failed, giving up.\n", lpr);
         exit(2);
      }
      fprintf(stderr, "Spooling to '%s'.\n", lpr);
   }

}

begin_image()		/* print the postscript header. */
{
   printf("%%!\n");		/* TranScript PostScript flag "%!" */
   printf("md begin\n");	/* standard apple header */
   printf("1320 od\n");
   printf("(; user: )jn\n");
   printf("%%%%EndProlog\n");
   printf("%%%%Page: ? ?\n");
   printf("op\n");
   printf("0 0 moveto\n");
}

/* The reason the following routine isn't called "end_image" is because */
/* of a bug in the Sequent C compiler.  */
end_imag(copies)	/* print the postscript trailer. */
int copies;		/* copies == number of copies to print */
{
   printf("%d page\n", copies - 1);	/* "page" takes # of pages to */
   printf("cp\n");           		/* print minus 1 */
   printf("%%%%Trailer\n");
   printf("end\n");
}

#define OUTBUF_SIZE	28
#define XSCALE		578
#define XLOC		0
#define ROWBYTES	74
#define SRCMODE		1

	/* Modular code purists can close their eyes for the following */
	/* routine.  */
dump_buffer(hexbuffer, blank)
char hexbuffer[MACPAINT_BITHEIGHT][MACRASTER_BITWIDTH/8];
int blank[MACPAINT_BITHEIGHT];
   /* hexbuffer contains the entire unencoded MacPaint file. */
   /* blank is a boolean array for each row.  TRUE means the horizontal
      line is blank. */
{
   int xscale, yscale, xloc, yloc, xactual, yactual;
   char smoothing;
   int i, j;
   int curline, top_of_sect, begin_line, numblanks, lines_used;
   char outstring[MACRASTER_BITWIDTH/4];

   xscale = XSCALE;		/* Postscript parameters describing the */
   xloc = XLOC;			/* size of the image area.  */
   xactual = XSCALE;
   smoothing = smooth ? 'T' : 'F';

/*  The postscript output consists of calls to "dobits" for each group of */
/* non-blank horizontal lines.  Due to LaserWriter memory limitations,    */
/* only about 28 lines at a time can be sent per command.  Also, lines    */
/* adjacent to the current section must be included (presumably for the   */
/* smoothing function to work.)						  */

   curline = 0;
   top_of_sect = TRUE;		/* begin a "dobits" call. */

   while (curline < MACPAINT_BITHEIGHT) {
			/* for the entire picture... */

/*  If a previous section terminated because of white space, skip the */
/* blank lines that precede the next section.  */
      if (top_of_sect)
	 while ((curline < MACPAINT_BITHEIGHT) && blank[curline])
            curline++;

/* check for end of page. */
      if (curline >= MACPAINT_BITHEIGHT)
         break;

      if (top_of_sect) {	/* At top of non-white section, include */
         begin_line = curline - 2;	/* previous two lines; */
         lines_used = 2;
         top_of_sect = FALSE;
      } else {			/* if continuing a non-white section, don't. */
         begin_line = curline;
         lines_used = 0;
      }

      numblanks = 0;		/* compute height of non-white area. */
      for (i = lines_used; i < (OUTBUF_SIZE - 1); i++) {
         if (blank[curline++])
            numblanks++;
         else
            numblanks = 0;   /* reset counter */
         if (numblanks >= 4) {	/* Too much white space: break and print it. */
      				/* The four blanks at the end of the */
				/* page will stop us at the bottom */
            curline--;		/* We want curline to point */
      				/* to the fourth blank line. */
            break;
         }
      }
      if (numblanks > 0)	/* If the bitmap ended in any whitespace, */
	 top_of_sect = TRUE;	/* we skip it the next time around.  */
      curline++;
      yactual = i - 3;		/* Height of current bitmap section. */
      yscale = yactual;		/* Scale it 1 to 1.  */
      yloc = begin_line + 2;

/* print the "dobits" call. */
      printf("%d %d %d %d %d %d %d %c %d dobits\n",
		xscale, yscale, xloc, yloc, ROWBYTES,
		xactual, yactual, smoothing, SRCMODE);
/* print the corresponding horizontal lines. */
      for (i = begin_line; i < curline; i++) {
         if ((i < 0) || blank[i])
			/* if blank, print all zeros. */
            for (j = 0; j< MACRASTER_BITWIDTH/4; j++)
               putchar('0');
         else {
			/* else convert to a hex string and print it. */
            tohex(hexbuffer[i], MACRASTER_BITWIDTH/8,
               outstring);
            printf("%s", outstring);
         }
		/* Put four extra nibbles at the ends of lines.  I think */
		/* are for smoothing.  */
	 if ((i == (-2)) || blank[i+1])	/* Include the first four nibbles of */
            printf("0000\n");		/* the next line.  */
	 else {
	    tohex(hexbuffer[i+1], 2, outstring);
	    printf("%s\n", outstring);
	 }
      }
      if (!top_of_sect)
         curline -= 4;		/* we'll have to overlap the next section */
   }				/* with this one, so back up four lines. */
}

tohex(hexline, size, outstring)   /* convert binary bytes to a hex string. */
char hexline[];
int size;		/* number of bytes to convert. */
char outstring[];
{
   int i, j;
   register char c, c1;

   j = 0;
   for (i = 0 ; i < size ; i++) {
      c = hexline[i];
      c1 = (c >> 4) & 0x0F;
      c1 = (c1 <= 9) ? (c1 + '0') : (c1 - 10 + 'A');
      outstring[j++] = c1;
      c1 = c & 0x0F;
      c1 = (c1 <= 9) ? (c1 + '0') : (c1 - 10 + 'A');
      outstring[j++] = c1;
   }
   outstring[j] = NULL;
}
@//E*O*F paintps.c//
chmod u=rw,g=r,o=r paintps.c
 
echo x - ps8.c
sed 's/^@//' > "ps8.c" <<'@//E*O*F ps8.c//'

/*
 * ps8       -  Convert non-ascii characters to octal excapes for the 
 *		LaserWriter printer.  This usually only happens with Postscript
 *		files generated by the Macintosh, it isn't supposed to do that
 *		but sometimes it does.  This little guy makes it all better
 *		again.
 *		Author: Brian Powell, brian@ut-sally
 */

/* ps8 - formerly called macfilter, but we wanted to use that name for the
 *	 filter called from psmac which prepends the LaserPrep.  Macfilter then
 *	 calls ps8.
 */

#include <stdio.h>
#include <ctype.h>

main()
{
	register char c;

	while ((c = getchar()) != EOF) {
		if (!isascii(c))
			printf("\\%03o", ((int)c) & 0377);
		else
			putchar(c);
	}
	exit (0);	/* set explicit exit code for the spooler */
}
@//E*O*F ps8.c//
chmod u=rw,g=r,o=r ps8.c
 
echo x - paintps.1
sed 's/^@//' > "paintps.1" <<'@//E*O*F paintps.1//'
@.TH PAINTPS local "31 March 1987"
@.UC 4
@.SH NAME
paintps - Convert MacPaint document into PostScript
@.SH SYNOPSIS
@.B paintps
file
@.br
@.B paintps
[
@.B \-d
] [
@.BI \-#<n>
] [
@.BI \-P<printer>
] file
@.SH DESCRIPTION
@.I Paintps
translates a MacPaint document, uploaded from a Macintosh,
into the PostScript language.  It can also spool output to maclaser (local)
for printing on a LaserWriter or other PostScript device.
@.PP
If the output of paintps hasn't been redirected or piped, then paintps
automatically spools the output to the printer specified with the -P option.
@.PP
Note that the resulting PostScript file requires certain function
definitions that aren't normally present on the LaserWriter.  Therefore,
the output of paintps must eventually be printed using "maclaser" instead of,
for example, "lpr -Plw".
@.PP
The order of command line arguments is not important, except that the options
must precede the filename.  The available command line options are:
@.TP
@.B -d
Specifies Draft Mode.  This turns off the smoothing function for graphics.
This option is of dubious usefulness since the smoothing overhead is small.
@.TP
@.BI -#<n>
Specifies the number (n) of copies to be printed.
@.TP
@.BI -P<printer>
Specifies the printer to be used as the output device.  This option is ignored
if the output of paintps has been redirected to a file or piped to another
process.
@.SH UPLOADING\ MACPAINT\ FILES\ TO\ UNIX
There are several ways to upload MacPaint files to a UNIX machine.
For example, you may use the command
@.PP
% macget -d
@.PP
to upload MacPaint files from the Macintosh to UNIX with MacTerminal.  See
macget(local) for more information.  Other file transfer programs are also
available, such as Kermit.
@.SH BUGS
This version of paintps generates output intended to be very similar to the
output that would be created by the version 1.1 Macintosh LaserWriter driver.
This
driver is now outdated, as far as Macintosh system software is concerned.
Maclaser must support the version 1.1 driver for paintps to work.
@.SH DIAGNOSTICS
If the LaserWriter produces an error page saying "/md undefined", this
probably means you spooled the output with lpr instead of maclaser.
@.SH AUTHOR
Brian H. Powell, The University of Texas at Austin
@.SH SEE\ ALSO
maclaser(local), macget(local), kermit(1C)
@//E*O*F paintps.1//
chmod u=r,g=r,o=r paintps.1
 
echo x - maclaser.1
sed 's/^@//' > "maclaser.1" <<'@//E*O*F maclaser.1//'
@.TH MACLASER local "31 March 1987"
@.UC 4
@.SH NAME
maclaser - Spool Macintosh PostScript files to the LaserWriter printers
@.SH SYNOPSIS
@.B maclaser
[
@.BI \-P<printer>
]
file
@.SH DESCRIPTION
@.I Maclaser
is a program which spools Macintosh-generated PostScript files to any of the
LaserWriters.  It defines function definitions that the
Macintosh PostScript file uses.
@.PP
The -P option is used to specify the output device.  If the option is
omitted, the default LaserWriter (-Plw) is used.
@.PP
For MacPaint pictures, PostScript files may be generated using paintps
(local) or using the method described below.
@.PP
For other output, you must (currently) use the procedure described below
to get the Macintosh to create the PostScript file.
@.SH GENERATING\ MACINTOSH\ POSTSCRIPT\ FILES
This section describes how to generate PostScript files on the Macintosh
for uploading and eventual printing.  Most programs need at least 200K of
memory to produce PostScript.  (In other words, 128K Mac owners can give up
now.)
@.PP
Make sure the LaserWriter printer driver file is installed on your system
disk.  You may use the "Chooser" desk accessory to select the
LaserWriter driver.  You may have to turn on AppleTalk first.  "Chooser" will
give you instructions.
@.PP
Use the Page Setup menu item to specify whether you want the
LaserWriter to substitute its built-in fonts for the Macintosh fonts,
whether you want smoothing, and so forth.
@.PP
Open the document with the required application and choose the "Print..."
menu item.  In most applications (such as MacWrite) a dialog box will
appear.  Answer the questions and click OK.  After you click OK, hold down
the command key (cloverleaf) and hold down the "f" key.  When a box
appears saying "Creating PostScript File", you may
release the cmd-F keys.  If instead a box appears saying "Looking for
LaserWriter", you did not press cmd-F at the right time.
@.PP
NOTE:  MacPaint is slightly different.  "Print Draft" prints without
smoothing, and "Print Final" prints with smoothing.  Also, no dialog
box appears when you choose "Print ..", so hold down cmd-F right after
you choose one of the print commands.
@.PP
A file called PostScript will appear on your disk.  This file is a plain text
file readable by MacWrite and most other editors and word processors.
This file is often extremely large (> 100K), so you might make sure you
have lots of room on the disk before creating it.
You will not be warned if you run out of space.
@.PP
Now upload the PostScript file to your favorite UNIX machine.  Several file
transfer programs exist.  For instance,
using MacTerminal connected to a UNIX machine, you can give the UNIX command
@.PP
% macget -u
@.PP
Then choose "Send File" in MacTerminal and select PostScript.  This will
leave a file in your current UNIX directory called "PostScript.text".
@.PP
Another common file transfer program is Kermit.  While running MacKermit,
issue the UNIX command
@.PP
% kermit -x
@.PP
Then choose "Send File" in MacKermit and select PostScript.  When it finishes,
choose "Finish".  This should leave a file in your current UNIX directory
called "postscript".
@.PP
Now you may finally give UNIX the command:
@.PP
% maclaser PostScript.text
@.PP
to print the file "PostScript.text" on the default LaserWriter.
@.SH COMPATIBILITY
I try to support as many versions of the Macintosh LaserWriter driver as
possible.  The current version of maclaser supports version 1.1 (distributed
with Finder 4.1), version 3.1 (with Finder 5.3), and version 3.3 (with Finder
5.4).
@.SH BUGS
Certain characters in the Zapf Dingbats font don't print correctly when using
the 3.1 LaserWriter driver.  I probably won't ever fix this bug since it works
in the newer version of the driver.  (And we don't use Dingbats much anyway.)
@.SH FILES
/usr/local/lib/allfonts/postscript/laser-prep-12.pro
@.br
	LaserPrep version 12, for LaserWriter version 1.1
@.PP
/usr/local/lib/allfonts/postscript/laser-prep-40.pro
@.br
	LaserPrep version 40, for LaserWriter version 3.1
@.PP
/usr/local/lib/allfonts/postscript/laser-prep-49.pro
@.br
	LaserPrep version 49, for LaserWriter version 3.3
@.SH SEE\ ALSO
paintps(local), macget(local), kermit(1C), lpr(1), printers(4L)
@//E*O*F maclaser.1//
chmod u=r,g=r,o=r maclaser.1
 
exit 0
  