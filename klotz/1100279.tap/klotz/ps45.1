% -*- Mode: TeX -*-
% This is a LaTeX file
% This is 6.821 Fall-87 Handout #45
\documentstyle[11pt,6821]{article}

\include{6821-macros}

\newcommand{\ts}{\:\vdash\:}			% turnstyle
\newcommand{\tag}{{\it tag}}
\newcommand{\rulename}[1]{{[{\it#1}\/]}}
\newcommand{\ruledef}[1]{\rulename{#1}\nobreak\vspace{-3ex}\nobreak} % kludge!
\newcommand{\incl}{\mbox{$\sqsubseteq$}}

\newcommand{\kproc}{\keyword{PROC}}
\newcommand{\kpoly}{\keyword{POLY}}
\newcommand{\koneof}{\keyword{ONEOF}}

\parskip=3ex

\handout{$45$}{3 November 1987}
\handouttitle{Types II: Type Inclusion and Type Checking}

\begin{body}

As mentioned in the introduction to types, a type description
corresponds to a set of values.  We define the inclusion relation on
types to correspond to set inclusion on these sets of values.

{\bf Definition}.  The inclusion relation \incl\ on type descriptions is
the partial order generated by the inference rules below.  We say that
$t$ is a {\em subtype} of $t'$ iff $t\ \incl\ t'$.

The type inclusion inference rule for the type constructor \kproc\ 
reflects the fact that \kproc\ is {\em monotonic} in its return
type component, but {\em anti-monotonic} in its parameter type components.
This follows from its interpretation as a generalization of the type
constructor $~\rightarrow~$ in the typed $\lambda$-calculus.

\ruledef{proc-\incl}
$$    {T\ \incl\ T' ~~;~~ \forall i~(T'_i\ \incl\ T_i)}
\over {      \code{(PROC ($T_1$  $\ldots$ $T_n$)  $T$)}
       \incl \code{(PROC ($T'_1$ $\ldots$ $T'_n$) $T'$)}}
$$

The rule for the type constructor \kpoly\ reflects the fact that \kpoly\ 
is monotonic in its return type component. Note that $\alpha$-renaming
of the \kpoly\ bound type parameters may be necessary.

\ruledef{poly-\incl}
$$    {T\ \incl\ T'}
\over {      \code{(POLY ($t_1$ $\ldots$ $t_n$) $T$)}
       \incl \code{(POLY ($t_1$ $\ldots$ $t_n$) $T'$)}}
$$

The rule for the type constructor \koneof\ reflects the fact that the
subtype \koneof\ may have fewer tag fields than the supertype \koneof\
but that each tag in the subtype must appear in the supertype. Moreover,
the \koneof\ must be monotonic in the types associated with matching
\code{tag}s.

\ruledef{oneof-\incl}
$$    {m \leq n ~~;~~ 
       \forall \tag_i\; \exists \tag'_j~(\tag_i = \tag'_j ~~\wedge~~ T_i\ \incl\ T'_j)}
\over {      \code{(ONEOF ($\tag_1$ $T_1$) $\ldots$ ($\tag_m$ $T_m$))}
       \incl \code{(ONEOF ($\tag'_1$ $T'_1$) $\ldots$ ($\tag'_n$ $T'_n$))} }
$$

\newpage

\section*{Type Environments}

We have seen how values --- such as numbers, booleans, procedures, pairs,
\code{ONEOF}s, etc. --- can be assigned types, but we still do not have a
concise definition of what consitutes a well-typed program.  Today we
will consider how type checking can be accomplished.

In order to determine if an expression such as \code{(+ 1 x)} is well-typed,
we need to determine the types of the variables \code{+} and \code{x}.  Just as
values are determined by an environment, we introduce the notion of a
type environment to keep track of the types of variables.

We will say that a type environment ``assigns'' a type to a variable if
the variable is in the type environment.  For example, the following
type enviroment assigns types to \code{+} and \code{x}:
 $$E = \{\code{+}: \code{(PROC (NUM NUM) NUM)},\; \code{x}: \code{NUM}\}$$

Type environments cannot be modified, but they can be extended to
create new type environments.  Assume that $A$ is a type environment.  We
can specify a new type environment that extends $A$ with the convention
``$x: T, A$''.  The type environment denoted by ``$x: T, A$''
assigns the type $T$ to variable $x$, along with the assignments
for any other variables that happen to be in $A$.  Note that if $A$ also
assigns a type to $x$ then this assignment is overridden or
``shadowed'' by the extension that we have made.

An expression (which may be an entire program) is type checked with
respect to a particular type environment.  We assume that there is a
type environment $G$ that assigns types of the {\sc Scheme} variables
that are available in the global environment:
  $$G = \{\code{\#t}: \code{BOOL},\;
          \code{\#f}: \code{BOOL},\;
	  \code{=}:   \code{(PROC (NUM NUM) BOOL)} \ldots \}$$
When we say that an expression is well-typed without specifying an
environment, $G$ will be implied.

When an expression $E$ can be demonstrated to have type $T$ with respect to
type environment $A$, we will call such a conclusion a ``typing'' and write
it as:
  $$A \ts E: T$$

\newpage

\section*{Type Checking}

We will now introduce some simple rules that can be used to infer valid
typings of expressions.  Each rule has the form:

$$    {\it Premise;\; \ldots ;\; Premise}
\over {\it Conclusion} $$

If all of the typings in the premises of a given rule are valid, then
the typing in the conclusion of the rule will be valid.   The typings
represented by the rules are prototypical, so the precise
variable names used in a rule can be changed without changing the
validity of the rule.  Thus, certain symbols in the rules are called
{\em meta-variables}.  When a general rule is refined by replacing its
meta-variables by particular instances of the meta-variables, it is
called a ``rule instance''.

We now have a procedure for type checking.  A given expression is
well-typed if and only if it has a provable typing.  A given typing can
be proved to be valid by giving a list of typings, ending with the
typing in question, where each typing is the conclusion of an instance
of a rule whose premises occur earlier in the list of typings
(Reynolds).


\newpage
{\bf Typing Rules}

\ruledef{v}
$$    {\hbox{type environment $A$ assigns type $T$ to variable $x$}}
\over {A \ts x: T} $$
   
\ruledef{the}
$$    {A \ts E: T}
\over {A \ts \code{(THE $T$ $E$)}: T} $$

\ruledef{if}
$$    {A \ts E: \code{BOOL} ~~;~~
       A \ts E_1: T;\;
       A \ts E_2: T}
\over {A \ts \code{(IF $E$ $E_1$ $E_2$)}: T} $$

\ruledef{$\lambda$}
$$    {x_1: T_1, \ldots, x_n: T_n, A  \ts E: T}
\over {A \ts \code{(LAMBDA (($x_1$ $T_1$) $\ldots$ ($x_n$ $T_n$)) $E$)}:
	      \code{(PROC ($T_1$ $\ldots$ $T_n$) $T$)}} $$

\ruledef{ap}
$$    {{\displaystyle A \ts E: \code{(PROC ($T_1$ $\ldots$ $T_n$) $T$)};}
\atop  {\displaystyle \forall i~(A \ts E_i: t_i ~~\wedge~~ t_i\ \incl\ T_i)}}
\over {A \ts \code{($E$ $E_1$ $\ldots$ $E_n$)}: T} $$

\ruledef{one}
$$    {A \ts E: T_E ~~;~~ \code{(ONEOF ($\tag$ $T_E$))}\ \incl\ T}
\over {A \ts \code{(ONE $T$ $\tag$ $E$)}: \code{$T$}}$$

\ruledef{tc}
$$   {{\displaystyle A \ts x: T_x ~~;~~ T_x\ \incl\ \code{(ONEOF ($\tag_1$ $T_1$)
                                                        $\ldots$ ($\tag_n$ $T_n$))};}
\atop {\displaystyle \forall i~(x:T_i, A \ts E_i: T)}}
\over {A \ts \code{(TAGCASE $x$ ($\tag_1$ $E_1$) $\ldots$ ($\tag_n$ $E_n$))} : T} $$

\ruledef{p$\lambda$}
$$    {{\displaystyle A \ts E: T;}
\atop  \hbox{No $t_i$ appears free in the type of any free variable of $E$}}
\over {A \ts \code{(PLAMBDA ($t_1$ $\ldots$ $t_n$) $E$)}: 
             \code{(POLY ($t_1$ $\ldots$ $t_n$) $T$)}} $$

\ruledef{proj}
$$    {A \ts E: \code{(POLY ($t_1$ $\ldots$ $t_n$) $T$)}}
\over {A \ts \code{(PROJ $E$ $T_1$ $\ldots$ $T_n$)}: [T_1/t_1,\ldots T_n/t_n]T} $$

\newpage
{\bf Examples}


Following are some well-typed expressions along with proofs of their
types.

1. $I = \{\code{1+}: \code{(PROC (NUM) NUM)},\; \code{1}: \code{NUM}\}$

\begin{tabular}{ll}
$I \ts \code{1}: \code{NUM}    		  $ & \rulename{v} \\
$I \ts \code{1+}: \code{(PROC (NUM) NUM)} $ & \rulename{v} \\
$I \ts \code{(1+ 1)}: \code{NUM}	  $ & \rulename{ap} \\
\end{tabular}

2. $I = \{\code{1}: \code{NUM},\; \code{+}: \code{(PROC (NUM NUM) NUM)}\}$

\begin{tabular}{ll}
$\code{x}: \code{NUM}, I \ts \code{x}: \code{NUM} $ & \rulename{v} \\
$\code{x}: \code{NUM}, I \ts \code{1}: \code{NUM} $ & \rulename{v} \\
$\code{x}: \code{NUM}, I \ts \code{+}: \code{(PROC (NUM NUM) NUM)} $ & \rulename{v} \\
$\code{x}: \code{NUM}, I \ts \code{(+ 1 x)}: \code{NUM}$           & \rulename{ap} \\
$I \ts \code{(LAMBDA ((x NUM)) (+ 1 x))}:
       \code{(PROC (NUM) NUM)} $
      & \rulename{$\lambda$} \\
\end{tabular}

3. $I = \{\code{+}: \code{(PROC (NUM) NUM)}\}$

\begin{tabular}{ll}
$\code{y}: \code{NUM}, \code{x}: \code{NUM}, I \ts \code{y}: \code{NUM}  $ & \rulename{v} \\
$\code{y}: \code{NUM}, \code{x}: \code{NUM}, I \ts \code{x}: \code{NUM}  $ & \rulename{v} \\
$\code{y}: \code{NUM}, \code{x}: \code{NUM}, I \ts \code{+}: \code{(PROC (NUM NUM) NUM)} $
     & \rulename{v} \\
$\code{y}: \code{NUM}, \code{x}: \code{NUM}, I \ts \code{(+ x y)}: \code{NUM} $
     & \rulename{ap} \\
$\code{x}: \code{NUM}, I \ts
  \code{(LAMBDA ((y NUM)) (+ x y))}: \code{(PROC (NUM) NUM)} $
     & \rulename{$\lambda$} \\
$I \ts \code{(LAMBDA ((x NUM)) (LAMBDA ((y NUM)) (+ x y)))}: $ & \\
 \hspace*{3em} $\code{(PROC (NUM) (PROC (NUM) NUM))}  $
     & \rulename{$\lambda$} \\
\end{tabular}

4. $I = \{\code{not}: \code{(PROC (BOOL) BOOL)},\;
          \code{1}: \code{NUM},\;
	  \code{3}: \code{NUM},\;
	  \code{=}: \code{(PROC (NUM NUM) BOOL)}\}$

\begin{tabular}{ll}
$\code{y}: \code{BOOL}, I \ts \code{y}: \code{BOOL} $                & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{not}: \code{(PROC (BOOL) BOOL)} $  & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{(not y)}: \code{BOOL}  $	     & \rulename{ap} \\
$\code{y}: \code{BOOL}, I \ts \code{y}: \code{BOOL} $		     & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{3}: \code{NUM}$		     & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{1}: \code{NUM}$		     & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{=}: \code{(PROC (NUM NUM) BOOL)}$  & \rulename{v} \\
$\code{y}: \code{BOOL}, I \ts \code{(= 1 3)}: \code{BOOL}$	     & \rulename{ap} \\
$\code{y}: \code{BOOL}, I \ts \code{(IF (= 1 3) y (not y))}: \code{BOOL}$
     & \rulename{if} \\
$I \ts \code{(LAMBDA ((y BOOL)) (IF (= 1 3) y (not y)))}:$ &\\
 \hspace*{3em} $\code{(PROC (BOOL) BOOL)}$
     & \rulename{$\lambda$} \\
\end{tabular}


\end{body}