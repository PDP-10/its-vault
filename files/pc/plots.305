;<PLOT>PLOTS.FAI.6,  3-Dec-76 19:36:45, EDIT BY HELLIWELL
DEFINE VERSION ' (V) <V'5>
VERSION SUBTTL PLOTS V
VERSION VPLOTS__

TITLE PLOTS
;THESE ARE THE PLOT ROUTINES FOR THE CALCOMP PLOTTER
;THE CALLING SEQUENCE IS ASSUMED TO BE THE SAME AS THAT
;USED BY FORTRAN IV.

XALL

DEFINE SETSW $ (NAME,DEFVAL)
<	IFNDEF NAME$SW,<NAME$SW__IFIDN <DEFVAL> <> <0;> DEFVAL
>
	NAME$SW__NAME$SW
>

DEFINE ONOFSW $ (NAME,DEFVAL)
<	SETSW(NAME,DEFVAL)
	IFN NAME$SW,<NAME$SW__-1>	;MAKE IT NICE FOR  AND 
>
DEFINE DEFSW $ (NAME)
<	DEFINE NAME,<IFN NAME$SW>
	DEFINE NO$NAME,<IFE NAME$SW>
>
DEFINE MAKESW(NAME,VAL)
<	ONOFSW(NAME,VAL)
	DEFSW(NAME)
>

MAKESW(STAN)
MAKESW(DEC)
MAKESW(CMU)
MAKESW(ITS)
MAKESW(III)

DEFINE STANFO,<STAN>		;LONG FORM FOR HYSTERICAL RAISINS

DEFINE CHECK $ (SITE,VAR) <IFDEF VAR,<SITE$SW__-1;>>
IFE STANSW!DECSW!CMUSW!ITSSW!IIISW,<
;IF NO SITE SET MANUALLY ABOVE, WE MUST DECIDE FOR OURSELVES WHERE WE ARE
CHECK(ITS,.IOT) CHECK(CMU,CMUDEC) CHECK(STAN,SPWBUT) DECSW__-1
>

MAKESW(PPWR,DECSW)

NOITS,<
PENUP__40
PENDWN__20
MVLFT__2
MVRT__1
MVDWN__10
MVUP__4
>;NOITS
ITS,<
MVDWN__2
MVUP__1
MVRT__4
MVLFT__10
PENUP__20
PENDWN__40
>;ITS
EXTERNAL DOPLT,.JBFF,CHRTBL
REF__-1

;PLOTTER CHANNEL
NOITS,<	PCHN__17	>
ITS,<	PCHN__10	>	;ITS COMPATIBILITY PACKAGE USES 17


;PLOTTER BYTE SIZE
NOITS,<	PLTSIZ__6>	;6 BITS IN PLOTTER COMMAND
ITS,<	PLTSIZ__7>	;EXCEPT ON ITS

INTERNAL SETXY,REF,ROTIT,XTHICK,VPLOTS,PLOTS,PLOT,PLT1,SYMBOL,WHERE

NOSTAN,<
	OPDEF	EXIT	[CALLI 12]
	OPDEF	DEVTYP	[CALLI 53]
>;NOSTAN
;SETXY
SETXY:	0
	HRREM 1,Y
	HLREM 1,X
	SETZM PEN
	JRA 16,(16)
;PLOTS IS THE ROUTINE WHICH INITIALIZES EVERYTHING
PLOTS:	0
	MOVEM 16,SV16
	SKIPN DOPLT
	JRST NOINIT
	SKIPN 16,@(16)
STANFO,<MOVSI 16,'PTP'>	;CALCOMP REPLACES PTP
NOSTANFO,<MOVSI 16,'PLT'>
	MOVEM 16,PLTDEV
NOITS,<	INIT PCHN,13	>
ITS,<	INIT PCHN,10	>;ASCII MODE PLEASE
PLTDEV:	0
	XWD POB,0
	JRST FOOP	;ERROR RETURN
NOINIT:	SETZM X#	;INITIALIZE X,Y TO 0 PEN TO UP
	SETZM Y#
	SETZM PEN#	;0 IS UP, 1 DOWN
	SETZM ROTIT#	;START WITH UPRIGHT PIC
	SETZM XTHICK#
STANFO,<	SETZM XPEN#	;START WITH MANY PEN COMMANDS
	MOVE 16,SV16
	SKIPE @(16)
	SETOM XPEN
>;STANFO
	SKIPN DOPLT
	JRST NOUT
	MOVSI 16,PLTSIZ*100	;BYTE SIZE
	MOVEM 16,POB+1
	MOVEI 16,PTPBUF
	EXCH 16,.JBFF
	OUTBUF PCHN,3
	MOVEM 16,.JBFF
PPWR,<MOVEM 17,TMP17
	MOVEI 17,PCHN
	DEVTYP 17,
	MOVEI 17,77		;INVENT CODE WHICH CAN'T BE PLOTTER IF UUO FAILURE
	ANDI 17,77
	SETZM ISPLTR#		;ASSUME NOT A PLOTTER
	CAIN 17,13		;PLOTTER CODE
	SETOM ISPLTR
	JSR PCHECK		;CHECK PLOTTER POWER
	MOVE 17,TMP17
>;PPWR
NOUT:	MOVE 16,SV16
	SETZM @(16)	;SETS PARAMETER TO 0 IF OK
	JRA  16,1(16)

FOOP:	MOVE 16,SV16
	SETOM @(16)	;ELSE TO -1
	JRA 16,1(16)
;PLOT HAS X,Y,PEN AS PARAMETERS. PEN HAS CODES: 1 SAME
;2 DOWN 3 UP. IF CODE IS MINUS CLEAR BUFFER RESET X,Y TO 0.
PLOT:	0
	MOVEM 16,SV16	;SAVE RETURN
	MOVE 16,@(16)	;GET ARGUMENTS
	MOVEM 16,SVX#
	MOVE 16,SV16
	MOVE 16,@1(16)
	MOVEM 16,SVY#
	MOVE 16,SV16
	MOVE 16,@2(16)
	MOVEM 16,SVPEN#
	MOVE 16,SV16
	MOVEM 17,SV17	;NOW SAVE ACS
	MOVEI 17,SV0
	BLT 17,SV0+16
	MOVM 2,SVPEN		;GET ABS OF PEN CODE
	CAIN 2,1	;SEE IF IT NEEDS CHANGING
	JRST PENOK
	SUBI 2,3
	CAMN 2,PEN
	JRST PENOK
	MOVEI 17,PENUP	;IT DOES, DECIDE HOW
	SKIPGE 2
	MOVEI 17,PENDWN
	JSR PLT1B	;TO WAIT
PENOK:	MOVEM 2,PEN	;SAVE CURRENT STATUS
	MOVE 0,SVX
	MOVE 1,SVY
	SUB 0,X		;GET X DIFFERENCE
	SETZM 16	;16 WILL HAVE THE X CODE TO USE
	SKIPG 0		;EITHER RIGHT, LEFT OR NONE
	MOVEI 16,MVLFT
	SKIPL 0
	MOVEI 16,MVRT
	SETZM 15	;NOW THE SAME FOR Y AND 15
	SUB 1,Y
	SKIPG 1
	MOVEI 15,MVDWN
	SKIPL 1
	MOVEI 15,MVUP
	MOVMS 1		;GET MAGNITUDES OF X AND Y CHANGES
	MOVMS 0
	CAMG 1,0	;FIND GREATEST
	JRST NOEX
	EXCH 1,0	;AND GET IT IN AC 0
	EXCH 15,16	;AND MOVEMENT CODE IN AC 16
NOEX:	JUMPE NOMOVE	;SPECIAL CHECK FOR NO MOVEMENT
	JUMPE 1,NORM
	MOVEI 3,0	;NOW CONVERT TO
NY:	TLNE 1,200000	;SHIFT SMALLER LEFT AS FAR AS POSSIBLE
	JRST NX
	LSH 1,1
	TRO 1,1
	AOJA 3,NY
NX:	SUBI 3,=34
MKSC:	IDIV 1,0	;NOW DIVIDE BY LARGER
	MOVNS 3		;GET REMAINING SHIFT AMOUNT
	LSH 1,(3)	;SHIFT THAT AMOUNT
NORM:	MOVEM 1,STEP#	;SAVE MAGIC NUMBER
	SETZM 1		;ZERO AC 1
	IOR 15,16	;WILL EITHER TAKE BOTH STEPS OR ONE FOR
			;LARGER NUMBER
    

INLOOP:	ADD 1,STEP	;ADD AND CHECK FOR OVERFLOW
	MOVE 17,16	;ON NO OVERFLOW USE ONLY INC IN LARGEST
			;DIRECTION
	TLZE 1,200000	;OVERFLOW CHECK AND CLEAR
	MOVE 17,15	;OTHERWISE STEP IN BOTH DIRECTIONS
	JSR PLT1	;ISSUE PLOT COMMAND
	SOJG INLOOP	;COUNT DOWN ON LARGER INCREMENT
	MOVE 1,SVX
	MOVEM 1,X	;RESET CURRENT X AND Y POSITIONS
	MOVE 1,SVY
	MOVEM 1,Y
NOMOVE:	SKIPL SVPEN	;SHOULD WE FORCE OUTPUT AND RESET X Y
	JRST ENDOUT
PPWR,<SKIPE DOPLT
	JSR PCHECK
>;PPWR
NOPPWR,<CLOSE PCHN,>
	SETZM X
	SETZM Y
ENDOUT:	HRLZI 17,SV0	;RESTORE AC'S
	BLT 17,16
	MOVE 17,SV17
	JRA 16,3(16)
;ROUTINES TO PUT THINGS IN OUTPUT BUFFER

DEFINE PLTCMD (A,B,C,D,E)
<
BYTE (=36-5*PLTSIZ)0(PLTSIZ)E,D,C,B,A
>;PLTCMD

PLT1:	0
	SKIPN DOPLT
	JRST @PLT1
	MOVEM 17,TMP17#
	SKIPN ROTIT
	JRST NOROT
	MOVEM 0,TMP0#
	MOVE 0,17
	TRZ 17,MVRT!MVLFT!MVDWN!MVUP
	TRNE MVLFT
	TRO 17,MVDWN
	TRNE MVDWN
	TRO 17,MVRT
	TRNE MVRT
	TRO 17,MVUP
	TRNE MVUP
	TRO 17,MVLFT
	MOVE 0,TMP0
NOROT:	SKIPGE PEN	;IF PEN IS UP
	SKIPN XTHICK	;OR NOT DOUBLE THICKNESS
	JRST PLTIT	;THEN DO NOTHING SPECIAL
	CAIN 17,MVLFT
	MOVE 17,[PLTCMD(MVUP!MVLFT,MVDWN)]
	CAIN 17,MVRT
	MOVE 17,[PLTCMD(MVRT,MVRT!MVUP,MVDWN,MVLFT)]
	CAIN 17,MVUP
	MOVE 17,[PLTCMD(MVUP,MVRT!MVUP,MVLFT,MVDWN)]
	CAIN 17,MVDWN
	MOVE 17,[PLTCMD(MVDWN!MVRT,MVLFT)]
	CAIN 17,MVUP!MVRT
	MOVE 17,[PLTCMD(MVUP!MVRT,MVRT,MVUP,MVLFT,MVDWN)]
	CAIN 17,MVDWN!MVLFT
	MOVE 17,[PLTCMD(MVLFT,MVRT!MVDWN,MVLFT)]
	CAIN 17,MVUP!MVLFT
	MOVE 17,[PLTCMD(MVUP,MVUP,MVLFT,MVDWN)]
	CAIN 17,MVDWN!MVRT
	MOVE 17,[PLTCMD(MVRT,MVRT,MVDWN,MVLFT)]
PLTIT:	JSR POUT
	LSH 17,-PLTSIZ
	JUMPN 17,PLTIT	;AND DO IT AGAIN IF ANY MORE
	MOVE 17,TMP17
	JRST @PLT1

PLT1B:	0
	SKIPN DOPLT
	JRST @PLT1B
STANFO,<
	MOVEI 16,=60	;PEN MOVES SLOWLY, THIS IS HOW LONG
	JSR POUT	;TO WAIT
	SKIPN XPEN
	SOJG 16,.-2
>;STANFO
NOSTAN,<JSR POUT>
	CAIE 17,PENUP	;IF IT WAS A PEN UP
	SKIPN XTHICK	;OR WE ARE NOT DOING DOUBLE THICK LINES
	JRST @PLT1B	;THEN THAT'S ALL
;	MOVEM 17,TMP17	;THIS IS NOT NEEDED
	MOVEI 17,MVUP	;ELSE THICKEN THIS POINT
	JSR POUT
	MOVEI 17,MVRT
	JSR POUT
	MOVEI 17,MVDWN
	JSR POUT
	MOVEI 17,MVLFT
	JSR POUT
;	MOVE 17,TMP17	;THIS IS NOT NEEDED
	JRST @PLT1B

DOUT:	0
DOUT1:	OUT PCHN,
	JRST @DOUT
	OUTSTR[ASCIZ/PLOTTER OUTPUT ERROR, CONTINUE TO TRY AGAIN.
/]
	EXIT 1,
	JRST DOUT1

POUT:	0
	SOSLE POB+2
	JRST PUTCHR
	JSR DOUT
PPWR,<	SKIPN ISPLTR
	JRST PUTCHR
	MOVEM 17,TMP17
	MOVEI 17,PCHN
	DEVSTS 17,
	MOVEI 17,1B30		;FAKE A POWER ON BIT IF NOT IMPLEMENTED
	TRNN 17,1B30
	JSR PCHECK		;NOW CHECK AGAIN
	MOVE 17,TMP17
>;PPWR
PUTCHR:	IDPB 17,POB+1

	JRST @POUT

PPWR,<
PCHECK:	0
	SKIPN ISPLTR
	JRST @PCHECK
PCHK1:	SOSG POB+2
	JSR DOUT
PCHK3:	MOVEI 17,0
	IDPB 17,POB+1
	JSR DOUT
	WAIT PCHN,
	MOVEI 17,PCHN
	DEVSTS 17,
	MOVEI 17,1B30
	TRNE 17,1B30
	JRST PCHKE
	GETLIN 17,
	TLNN 17,-1
	JRST PCHK2
	OUTSTR[ASCIZ/PLOTTER NOT READY, CONTINUE WHEN READY.
/]
	EXIT 1,
	JRST PCHK1

PCHK2:	MOVEI 17,10
	SLEEP 17,
	JRST PCHK1

PCHKE:	AOS POB+2	;FUDGE COUNT
	JRST @PCHECK
>;PPWR

POB:	BLOCK 3		;DEVICE BLOCK

PTPBUF:
	BLOCK 3*<200+3>		;ENOUGH FOR DISK

SV0:	BLOCK 17	;AC STORAGE
SV17:	0
SV16:	0
;SYMBOL ROUTINE. NOTE: ASSUMES ALL STROKES ARE VERTICAL
;HORIZONTAL, OR SOME 45 DEGREE ANGLE
;PARAMETERS ARE X,Y,SIZE, ORIENTATION, TEXT, CHAR. COUNT...
TX_6
TY_7
TPEN_10
SYMBOL:	0
	MOVEM 17,SV17T	;NOW SAVE ACS
	MOVEM 16,SV16	;SAVE RETURN
	MOVE 16,@(16)
	MOVEM 16,SVX
	MOVE 16,SV16
	MOVE 16,@1(16)
	MOVEM 16,SVY
	MOVE 16,SV16
	MOVE 16,@2(16)
	IDIVI 16,8		;SIZE*8 FROM PCP
	JUMPN 16,GETSZ1
	ADDI 16,1		;0 SIZE CHAR IS TOO SMALL, USE 1
	SUBI 17,8		; BUT FUDGE POSTION BACK
GETSZ1:	MOVEM 17,SVFDG#
	MOVEM 16,SVSZ#
	MOVE 16,SV16
	MOVE 16,@3(16)
	MOVEM 16,SVOR#
	MOVE 16,SV16
	MOVEI 16,@4(16)
	MOVEM 16,SVTXT#
	MOVE 16,SV16
	MOVEI 17,SV0T
	BLT 17,SV0T+16
	MOVE 0,SVX
	MOVE 1,SVY
	MOVEI 2,3
	JSA 16,PLOT
	0
	1
	2
	MOVE 13,SVSZ
	JUMPLE 13,ENDTXT
	IMULI 13,6	;CALCULATE BASE
	MOVEM 13,CBASE#
	MOVE 14,SVOR
	ANDI 14,3	;MAKE ORIENTATION 0,1,2,OR 3
	MOVE 0,SVTXT	;POINTER
	HRLI 440700	;TURN IT INTO A BYTE POINTER
LP1:	ILDB 1,0
	JUMPE 1,ENDTXT	;0 CHARACTER IS END OF TEXT
	MOVE 4,[POINT 5,0]	;READY TO GET BYTES FOR CHARACTER
	HRR 4,@CHRTBL		;GET ADDRESS OF BYTES FOR THIS CHARACTER
	HLRZ 5,@CHRTBL		;GET NUMBER OF STROKES
	MOVEI 2,0	;PRESENT X POS IN MATRIX
	MOVE 3,CBASE	;Y POS
	JUMPE 5,ENDLT	;NO STROKES, IGNORE CHARACTER
OUT1:	ILDB TPEN,4	;GET NEXT 3 BYTES
	ILDB TX,4
	IMUL TX,SVSZ
	ILDB TY,4
	IMUL TY,SVSZ
	JSR OUTXY
	SOJG 5,OUT1	;NEXT STROKE IF THERE IS ONE
	SKIPN TX,SVFDG	;FUDGING END POSITION?
	JRST ENDLT	;NO
	ADD TX,2	;FAKE UP FINAL MOVE
	MOVE TY,3
	SETZ TPEN,
	JSR OUTXY
ENDLT:	JSR XYFIX
	ADDM 2,X
	ADDM 3,Y
	JRST LP1

OUTXY:	0
	MOVNS TPEN	;THIS IS 0 UP 1 DOWN
	CAMN TPEN,PEN	;OTHER IS 0 UP -1 DOWN
	JRST PENK
	MOVEM TPEN,PEN	;SAME AS IN PLOT
	MOVEI 17,PENDWN
	SKIPN TPEN
	MOVEI 17,PENUP
	JSR PLT1B
PENK:	SUB 2,TX	;GET INCREMENTS
	SUB 3,TY
	JUMPE 2,OUT2	;IF EITHER 0 USE SPECIAL ROUTINE
	JUMPE 3,OUT2
	MOVM 16,2	;GET MAGNITUDES
	MOVM 15,3
	CAMN 15,16	;IF NEITHER 0 AND NOT SAME MAGNITUDE
	JRST OUT2	;MUST BE PEN UP, ELSE USE SPECIAL ROUTINE
	SKIPE TPEN	;PEN UP OR DOWN?
	JRST OUT4	;PEN DOWN, MUST BE CAREFUL
	SETZM 17	;DECIDE ON MOVEMENTS AS IN PLOT
	SKIPGE 2
	MOVEI 17,MVRT
	SKIPLE 2
	MOVEI 17,MVLFT
	MOVMS 2
	LDB 17,BPTB(14)	;EXCEPT THAT IT IS INFLUENCED BY
			;ORINTATION PARAMETER
	JSR PLT1	;MAKE MOVEMENT
	SOJG 2,.-1
	SETZM 17	;SAME FOR Y
	SKIPGE 3
	MOVEI 17,MVUP
	SKIPLE 3
	MOVEI 17,MVDWN
	MOVMS 3
	LDB 17,BPTB(14)
	JSR PLT1
	SOJG 3,.-1
	JRST OUT3

OUT2:	SETZM 17	;SPECIAL ROUTINE WILL HANDLE 45 DEGREE
	SKIPGE 2	;LINES. FIRST SET UP MOVEMENTS
	MOVEI 17,MVRT
	SKIPLE 2
	MOVEI 17,MVLFT
	SKIPGE 3
	IORI 17,MVUP	;ONLY THIS TIME OR TOGETHER SINCE
	SKIPLE 3	;ALL STROKES IN SAME DIRECTION
	IORI 17,MVDWN
	MOVMS 2
	MOVMS 3
	CAMG 2,3	;GET LARGER MAGNITUDE FOR COUNT
	EXCH 2,3
	LDB 17,BPTB(14)	;CORRECT FOR ORIENTATION
	JSR PLT1	;DRAW
	SOJG 2,.-1
	JRST OUT3
    
OUT4:	MOVN 2,2
	MOVN 3,3
	ADD 3,CBASE	;FORCE RELATIVE CALC
	JSR XYFIX	;GET ABSOLUTE X,Y FOR END OF THIS STROKE
	MOVEM 2,TMPX#
	MOVE 2,X
	ADDM 2,TMPX
	MOVEM 3,TMPY#
	MOVE 3,Y
	ADDM 3,TMPY
	JSA 16,PLOT	;LET THIS ROUTINE DO THE REST
	JUMP TMPX
	JUMP TMPY
	JUMP [2]
	MOVEM 2,X		;RESTORE OLD VALUES OF X AND Y
	MOVEM 3,Y
OUT3:	MOVE 2,TX	;SAVE NEW X,Y
	MOVE 3,TY
	JRST @OUTXY

XYFIX:	0
	SUB 3,CBASE
	TRNN 14,2
	JRST XYFIX1
	MOVNS 2
	MOVNS 3
XYFIX1:	TRNN 14,1
	JRST @XYFIX
	MOVNS 3
	EXCH 2,3
	JRST @XYFIX

ENDTXT:	HRLZI 17,SV0T	;RESTORE AC'S
	BLT 17,16
	MOVE 17,SV17T
	JRA 16,5(16)
SV0T:	BLOCK 17
SV17T:	0
BPTB:	FOO_3	;TABLE TO GET PROPER BITS DEPENDING ON ORIENTATION PARAMETER
	REPEAT 4,<POINT 4,BT(17),FOO
FOO_FOO+4
>
BT:	0
	RT__<BYTE(4)MVRT,MVUP,MVLFT,MVDWN>
	UP__<BYTE(4)MVUP,MVLFT,MVDWN,MVRT>
	LFT__<BYTE(4)MVLFT,MVDWN,MVRT,MVUP>
	DWN__<BYTE(4)MVDWN,MVRT,MVUP,MVLFT>
	
	RELOC BT+MVRT
		RT
	RELOC BT+MVLFT
		LFT
	RELOC BT+MVDWN
		DWN
	RELOC BT+MVUP
		UP
	RELOC BT+MVRT+MVUP
		RT+UP
	RELOC BT+MVRT+MVDWN
		RT+DWN
	RELOC BT+MVLFT+MVUP
		LFT+UP
	RELOC BT+MVLFT+MVDWN
		LFT+DWN
	RELOC BT+20
    

		;ROUTINE TO GIVE BACK CURRENT X,Y POSITION
WHERE:	0
	MOVEM 16,SV16
	MOVEI 16,@(16)
	MOVEM 16,SVY
	MOVE 16,X
	MOVEM 16,@SVY
	MOVE 16,SV16
	MOVEI 16,@1(16)
	MOVEM 16,SVY
	MOVE 16,Y
	MOVEM 16,@SVY
	MOVE 16,SV16
	JRA 16,2(16)

END
