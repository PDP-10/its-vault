.c This file is part of the Lisp Machine manual.  -*-Text-*-

.chapter Processes
.cindex process
.cindex multiprocessing
.setq process page
.cindex wait
	2Processes* are used to implement multi-processing.
Several computations can be executed "concurrently" by placing
each in a separate process.  A computation in a process may
also 2wait* for something to happen, during which time it
does not execute at all.

	A 2process* is a Lisp structure with the following components:
.ftable 3
.item process-name
The name of the process, as a string.  This string is only used
for the process's printed representation, and for programs
to print out; it can be anything reasonably mnemonic.
.item process-stack-group
The stack group currently associated with this process.  When the process
is run, this stack group will be resumed.  See below.
.item process-wait-function
A function, applied to the argument list in the process's 3process-wait-argument-list*
to determine whether the process is runnable.  The function should return 3nil*
if the process is not ready to run.
.item process-wait-argument-list
The arguments to which the 3process-wait-function* is applied.
.item process-whostate
The reason this process is waiting, as a string.  This is only 
used for display by the who-line or various programs; it can
be anything reasonably mnemonic.
.item process-job
The job associated with this process, or 3nil* if the process
is not associated with any job.  See the chapter on jobs ((job)).
.item process-initial-stack-group
The function 3process-preset* (see (process-preset-fun))
will make the 3process-stack-group* be this stack group.
.end_table

.setq scheduler page
.cindex scheduler
	At any time there is a set of 2active processes*.  Each active
process is either trying to run, or waiting for some condition to become true.
The active
processes are managed by a special stack group called the 2scheduler*,
which repeatedly cycles through the active processes, determining
for each process whether it is ready to be run, or whether it is
waiting.  The scheduler determines whether a process is ready to run by applying the process's
2wait-function* to its 2wait-argument-list*.  If the
wait-function returns a non-3nil* value, then the process is ready to run;
otherwise, it is waiting.  If the process is ready to run,
the scheduler resumes the 3process-stack-group* of the process.
For example, if a process were waiting for input from the keyboard,
its wait-function might be 3kbd-char-available*, which returns
non-3nil* if there is a character available from the keyboard.
Since 3kbd-char-available* takes no arguments, the wait-argument-list
of the process would be 3nil*.

	When a process's wait-function returns non-3nil*, the scheduler
will resume its stack group and let it proceed.  The process is now the
2current process*, that is, the one process that is running
on the machine.  The scheduler sets the variable 3current-process*
to it.  It will remain the current process and continue to
run until either it decides to wait, or a 2sequence break* occurs.
A process can wait for some condition to become true by calling
3process-wait* (see (process-wait-fun)),
which will set up its wait-function and wait-argument-list accordingly,
and resume the scheduler stack group.  A sequence break is a kind of interrupt
that is generated by the Lisp system for any of a variety of reasons;
when it occurs, the scheduler is resumed.  In either case, the scheduler
will continue cycling through the active processes.
This way, each process that is ready to run will get its share of
time in which to execute.

	Note: Sequence breaks are not yet implemented, and so the scheduler
only regains control when the running process calls 3process-wait*.
Any process that simply computes for a long time without waiting will 
keep all of the other processes from running.  In the future, seqence
breaks will happen periodically and at interesting times when some process's
wait condition may have become true.

.section Functions for Manipulating Processes

.defun process-create name job &rest options
3process-create* creates and returns a new process.  2name* may be any
string, 2job* is usually 3t*, and there are usually no options.
The options are used in creating the stack group which executes on behalf of this process.

The fields of the new process are set up as follows:
.table 3 
.item process-name
2name*, which should be a string.
.item process-job
2job*.  If 2job* is 3t*, the current job is used instead.
Otherwise 2job* should be 3nil* (meaning that the process
is not associated with any job), or a job.
.item process-stack-group
A newly created stack group.  The 2options* argument to 3process-create*
are the options passed to 3make-stack-group* (see (make-stack-group-fun))
used when creating this stack group.
.item process-initial-stack-group
The same as the 3process-stack-group*.
.end_table

The rest of the fields are set to 3nil*; the process should not be enabled
until 3process-preset* (see below) is called.
.end_defun

.defun process-preset process initial-function &rest options
3process-preset* initializes the state of a process.
First, it restores the 3process-stack-group* from the
3process-initial-stack-group*.  Then it presets
the stack group, passing the 3initial-function* and 3options*
arguments to 3stack-group-preset* (see (stack-group-preset-fun)).
Finally it sets
the 3process-wait-function* and 3process-argument-list*
to return 3t*, so that the process will be ready to run.
The process is now ready to be enabled (see 3process-enable*
below).
.end_defun

.defun process-kill process
This deactivates 2process* if it is active, and dissociates it from
its associated job (if any).
.end_defun

.defun process-enable process
Enable 3process*.  If 2process* has no associated job, or if its
job if process-enabled, 2process* is activated.
.end_defun

.defun process-disable process
Disable 2process*.  If it was active, deactivate it.
.end_defun

.defun process-wait whostate function &rest arguments
3process-wait* sets the current-process's 3process-whostate*,
3process-wait-function*, and 3process-wait-argument-list* from
its three arguments, which makes the current process wait until the
application of 2function* to 2arguments* returns non-3nil*
(at which time 3process-wait* returns).  Note that 2function* is applied
in the environment of the scheduler, not the environment of the 3process-wait*,
so bindings in effect when 3process-wait* was called will 2not* be
in effect when 2function* is applied.  Be careful when using any free
references in 2function*.
.lisp
.exdent 96 Example:
;; This won't work.
((lambda (until)
    (process-wait "sleep" '(lambda () (> (time) until))))
 500)

;; This is the right way to do it.
(process-wait "sleep" '(lambda (until) (> (time) until)) 500)
.end_lisp

When running the 3process-wait-function*, the scheduler sets the
variables 3current-process* and 3current-job*
to the process being considered and its job, so the 3process-wait-function*
can use them; for example:
.lisp
;; Wait until I get the keyboard.
(process-wait "kbd" '(lambda () (eq kbd-job current-job)))
.end_lisp
.end_defun

.defun process-sleep interval
This simply waits for 2interval* sixtieths of a second, and then returns.
It uses 3process-wait*.
.end_defun

.defun process-allow-schedule
This function simply waits for a condition which is always true;
all other processes will get a chance to run before the current process runs again.
.end_defun

.defspec without-interrupts
The 3without-interrupts* special form allows you to perform 2atomic operations*.
Within the body of this form, control is guaranteed to remain in the current process.
.lisp
.exdent 96 Examples:
(without-interrupts
  (push item list))

(without-interrupts
  (cond ((memq item list)
	 (setq list (delq item list))
	 t)
	(t nil)))
.end_lisp
.end_defspec


.section "Locks"
'cindex "lock"

	A 2lock* is a software construct used for synchronization
of two processes.  A lock is either held by some process, or is free.
When a process tries to seize a lock, it waits until the lock is free,
and then it becomes the process holding the lock.  When it is finished,
it should unlock the lock.

	In the Lisp Machine, a lock is a locative pointer to a cell.
If the lock is free, the cell contains 3nil*; otherwise it contains
the process that holds the lock.  The 3process-lock* and 3process-unlock*
functions are written in such a way as to guarantee that two processes
can never both think that they hold a certain lock; only one process
can ever hold a lock at a time.

.defun process-lock locative
This is used to seize the lock which 2locative* points to.
If necessary, 3process-lock* will wait until the lock becomes free.
When 3process-lock* returns, the lock has been seized.
.end_defun

.defun process-unlock locative
This is used to unlock the lock which 2locative* points to.
If the lock is free or was locked by some other process, an
error is signaled.  Otherwise the lock is unlocked.
.end_defun

	It is a good idea to use 3unwind-protect* to make sure that
you unlock any lock that you seize.  For example, if you write
.lisp
(unwind-protect
   (progn (process-lock lock-3)
	  (function-1)
	  (function-2))
   (process-unlock lock-3))
.end_lisp
then even if 3function-1* or 3function-2* does a 3*throw*,
3lock-3* will get unlocked correctly.

	3process-lock* and 3process-unlock* are written by
use of a sub-primitive function called 3%store-conditional*
(see (%store-conditional-fun)), which
is sometimes useful in its own right.

.eof
