Documentation on PACK4.   -*-Text-*-

*) The Need for Multiple Contexts.

	A Lisp program is a collection of function definitions.
The functions are known by their names, and so each must have its
own name to identify it.  Clearly a programmer must not use the same
name for two different functions.

	The Lisp machine consists of a huge Lisp world, in which many
programs must coexist. All of the "operating system", the compiler, the
EINE editor, and a wide variety of programs are provided in the initial
environment.  Furthermore, every program which the user uses during
his session must be loaded into the same environment.  Each of these
programs is composed of a group of functions; apparently each function
must have its own distinct name to avoid conflicts.  For example, if
the compiler had a function named PULL, and the user loaded a program
which had its own function named PULL, the compiler's PULL would be
pulled out from under it, probably breaking the compiler.

	It would not really be possible to prevent these conflicts,
since the programs are written by many different people who could
never get together to hash out who gets the privilige of using
a specific name such as PULL.

	Now, if we are to enable both programs to coexist in the Lisp
world, each with its own function PULL, then each program must have
its own symbol named "PULL", because there can't be two function
definitions on the same symbol.  This means that separate "name
spaces" -- mappings between names and symbols -- must be provided for
them.  The package system is designed to do just that.

	Under the package system,  the author of a program or a group
of closely related programs identifies them together as a "package".
The package system associates a distinct name space with each package.

	Here is an example: suppose there are two programs named CHAOS
and ARPA, for handling the Chaos net and Arpanet respectively.  The
author of each program wants to have a function called GET-PACKET,
which reads in a packet from the network (or something).  Also, each
wants to have a function called ALLOCATE-PBUF, which allocates the
packet buffer.  Each "get" routine first allocates a packer buffer,
and then reads bits into the buffer; therefore, each version of
GET-PACKET should call the respective version of ALLOCATE-PBUF.

	Without the package system, the two programs could not coexist
in the same Lisp environment.  But the package feature can be used to
provide a separate name space for each program.  What is required is
to declare a package named CHAOS to contain the Chaos net program, and
another package ARPA to hold the Arpanet program.  When the Chaos net
program is read into the machine, its symbols would be entered in the
CHAOS package's name space.  So when the Chaos net program's
GET-PACKET referred to ALLOCATE-PBUF, the ALLOCATE-PBUF in the CHAOS
name space would be found, which would be the ALLOCATE-PBUF of the
Chaos net program -- the right one.  Similarly, the Arpanet program's
GET-PACKET would be read in using the ARPA package's name space and
would refer to the Arpanet program's ALLOCATE-PBUF.

	An additional function of packages is to remember the names of
the files which constitute each program, making it easy to ask to load
or recompile all of them at once.

	To understand what is going on here, you should keep in mind
how Lisp reading and loading works.  When a file is gotten into the
Lisp machine, either by being read or by being fasloaded, the file itself
obviously cannot contain Lisp objects; it contains printed representations
of those objects.  When READ encounters a printed representation of a symbol,
it calls in INTERN to look up that string in some name space and find
a corresponding symbol to return.

*) The Organization of Name Spaces.

	We could simply let every name space be implemented as one
obarray, e.g. one big table of symbols.  The problem with this is
that just about every name space wants to include the whole
Lisp language: CAR, CDR, and so on should be availible to every
program.  We would like to share the main Lisp system between
all other name spaces without making many copies.

	Instead, we arrange packages in a tree.  Each package has a
"superpackage" or "parent", from which it "inherits" symbols.  Also,
each package has an table, or "obarray", of its own additional
symbols.  The symbols belonging to a package are simply those in the
package's own obarray, followed by those belonging to the
superpackage.  The root of the tree of packages is the package called
SYSTEM, which has no superpackage.  SYSTEM contains CAR and CDR and
all the rest of the standard Lisp system.  In our example, we might
have two other obarrays called CHAOS and ARPA, each of which would
have SYSTEM as its parent.  Here is a picture of the resulting tree
structure:

                    SYSTEM
                       |
          /----------------------------\
          |                            |
        CHAOS                         ARPA

	In order to make the sharing of the SYSTEM package work, the
INTERN function is made more complicated than in basic Lisp.  In
addition to the string or symbol to intern, it must be told which
package to do it in.  First it searches for a symbol with the
specified name in the obarray of the specified package.  If nothing is
found there, INTERN looks at its superpackage, and then at the
superpackage's superpackage, and so on, until the name is found or a
root package such as SYSTEM is reached.  When that happens, INTERN
decides that there is no symbol known with that name, and adds a
symbol to the originally specified package.

	Since you don't normally want to sorry about specifying
packages, INTERN normally uses the "current" package, which is the
value of the symbol PACKAGE.  This symbol serves the function of the
symbol OBARRAY in Maclisp.

	Here's how that works in the above example.  When the Chaos
net program is read into the Lisp world, the current package would be
the CHAOS package.  Thus all of the symbols in the Chaos net program
would be interned on the CHAOS package.  If there is a reference to
some well known system symbol such as APPEND, INTERN would look for
"APPEND" on the CHAOS package, not find it, look for "APPEND" on
SYSTEM, and find the regular Lisp APPEND symbol, and return that.  If,
however, there is a reference to a symbol which the user made up
himself (say it is called GET-PACKET), the first time he uses it,
INTERN won't find it on either CHAOS nor SYSTEM.  So INTERN will make
a new symbol named GET-PACKET, and install it on the CHAOS package.
When GET-PACKET is refered to later in the Chaos net program, INTERN
will find GET-PACKET on the CHAOS package.

	When the Arpanet program is read in, the current package would
be ARPA instead of CHAOS.  When the ArpaNet program refers
to APPEND, it gets the SYSTEM one; that is, it shares the same one
that the Chaos net program got.  However, if it refers to GET-PACKET,
it will NOT get the same one the Chaos net program got, because
the CHAOS pacakge is not being searched.  Rather, the ARPA and SYSTEM
packages are getting searched.  So INTERN will create a new GET-PACKET
and install it on the ARPA package.

	So what has happened is that there are two GET-PACKETs: one for
CHAOS and one for ARPA.  The two programs are loaded together without name
conflicts.

*) Shared Programs.

	Now, a very important feature of the Lisp machine is that of
"shared programs"; if one person writes a function to, say, print
numbers in Roman numerals, any other function can call it to print
Roman numerals.  This contrasts sharply with PDP-10 system programs,
in which Roman numerals have been independently reimplemented several
times (and the ITS filename parser several dozen times).

	For example, the routines to manipulate a robot arm might be
separate program called ARM, residing in a package named ARM.  If we
have a second program called BLOCKS (the blocks world, of course)
which wanted to manipulate the arm, it would want to call functions
which are defined on the ARM obarray, and therefore not in BLOCKS's
own name space.  Without special provision, there would be no way for
any symbols not in the BLOCKS name space to be part of any BLOCKS
functions.

	The package system includes a readmacro character ":", which
enables the programmer to refer to symbols in packages other than the
current one.  The name of the package precedes the colon, and the name
of the symbol in that package follows the colon.  The way BLOCKS would
call a function named GO-UP defined in ARM would be by asking to call
ARM:GO-UP.  What this means precisely is "The symbol named GO-UP in
the name space of the package ARM."  The definition of the colon
character would do (INTERN "GO-UP" "ARM").

	Similarly, if the CHAOS program wanted to refer to the ARPA
program's ALLOCATE-PBUF function (for some reason), it would simply
call ARPA:ALLOCATE-PBUF.

	An important question which should occur at this point is how
the names of packages are associated with their obarrays and other
data.  This is done by means of the "refname-alist" which each package
has.  This alist associates names (strings) with the packages they
name.  Normally, a package's refname-alist contains an entry for each
subpackage, associating the subpackage with its name.  In addition,
every package has its own name defined as a refname, referring to
itself.  However, the user can add any other refnames, associating
them with any packages he likes.  This is useful when multiple versions
of a program are loaded into different packages.  Of course, each
package inherits its superpackage's refnames just as it does symbols.

	In our example, since ARM is a subpackage of SYSTEM, the name
ARM is on SYSTEM's refname-alist, associated with the ARM package.
Since BLOCKS is also a subpackage of SYSTEM, when ARM:GO-UP is seen
the string "ARM" is found on SYSTEM's refname alist.

	When you want to refer to a symbol in a package which you and
your superpackages have no refnames for -- say, a subpackage named FOO
of a package named BAR which is under SYSTEM -- you can use multiple
colons.  For example, the symbol FINISH in that package FOO could be
referred to as FOO:BAR:FINISH.  What happens here is that the second
name, BAR, is interpreted as a refname in the context of the package
FOO.

*) Declaring Packages.

  Before any package can be referred to or loaded, it must be declared.
This is done with the function PACKAGE-DECLARE, and tells the machine
all sorts of things, including the name of the package, the place in the
package hierarchy for the new package to go, its estimated size, the
files which belong in it, and the symbols which belong in it.

  Here is a sample declaration:

(PACKAGE-DECLARE FOO SYSTEM 1000
       (("LISPM;FOO QFASL")
	("LISPM;BAR QFASL")
	("LISPM;BARMAC >" DEFS))
       (SHADOW ARRAY-PUSH ADJUST-ARRAY-SIZE)
       (EXTERN FOO-ENTRY))

  What this declaration says is that a package named FOO should be
created as an inferior of SYSTEM, the package which contains advertised
system functions.  It should initially be large enough to hold 1000
symbols, though it will grow automatically if that isn't enough.
Unless there is a specific reason to do otherwise, you should make all
of your packages direct inferiors of SYSTEM.

  After the size comes the "file-alist".  The files in the FOO package
are LISPM;FOO and LISPM;BAR, both of which should be compiled, and
LISPM;BARMAC, which should be read in as a text file.  In addition,
BARMAC is marked as a DEFS file, which means that the latest version of
BARMAC must always be loaded before attempting to compile or load any of
the other files.  All the source files should start with

			(PKG-CONTAINED-IN "FOO")

to help detect processing them in the wrong package.  Soon it will
automatically cause them to be processed in the right package, even if
copied under strange names.  (NOTE: THIS ISN'T LOADED YET!  DON'T USE)

  Finally, the FOO package "shadows" ARRAY-PUSH and ADJUST-ARRAY-SIZE,
and "externs" FOO-ENTRY.  What shadowing means is that the FOO package
should have its own versions of those symbols, rather than inheriting
its superpackage's versions.  This allows the FOO package to redefine
those functions for itself without redefining them in the SYSTEM
package for everyone else.  What externing means is that the FOO
package is allowed to redefine FOO-ENTRY as inherited from the SYSTEM
package, so that it IS redefined for everybody.  If FOO attempts to
redefine a function such as CAR which is present in the SYSTEM package
but neither shadowed nor externed, confirmation from the user is
necessary (this is not implemented yet).

  Note that externing doesn't actually put any symbols into the SYSTEM
package.  It just asserts permission to redefine symbols already there.
This is deliberate; the intent is to enable the maintainers of the
SYSTEM package to keep control over what symbols are present in it.
Because inserting a new symbol into the SYSTEM package can cause trouble
to unsuspecting programs which expect that symbol to be private, this is
not supposed to be done in a decentralized manner by programs written by
one user and used by another unsuspecting user.
While all the definitions of the functions in SYSTEM are actually
supplied by subpackages which extern them (SYSTEM contains no files of
its own), the list of symbol names is centralized in one place, the file
LISPM;SYSPKG >, and this file is not changed without notifying everyone,
and updating the SYSTEM documentation.

  Certain other things may be found in the declarations of system
packages.  They are arcane and needed only to compensate for the fact
that parts of those packages are actually loaded before the package
manager is.  They should not be needed by any user package.

  Your package declarations should go into separate files containing
only package declarations.  Group them however you like, one to a file
or all in one file.  Such files can be read with LOAD.  It doesn't
matter what package you load them into, so use USER, since that has to
be safe.

  If the declaration for a package is read in twice, no harm is done.
If you edit the size to replace it with a larger one, the package will
be expanded.  If you change the file-alist, the new one will replace the
old.  At the moment, however, there is no way to change the list of
shadowings or externals;  such changes will be ignored.  Also, you can't
change the superpackage.  If you edit the superpackage name and read the
declaration in again, you will create a new, distinct package without
changing the old one.

*) Packages and Writing Code.

  The unsophisticated user need never be aware of the existence of
packages when writing his programs.  He should just load all of his
programs into the package USER, which is also what console type-in is
interned in.  Since all the functions which users are likely to need are
provided in the SYSTEM package, which is USER's superpackage, they are
all available.

  However, if you are writing a generally useful tool, you should not
put it in USER, so that its internal functions will not conflict with
names other users use.  Whether for this reason or for any other, if you
are loading your programs into packages other than USER there are
special constructs that you will need to know about.

  One time when you as the programmer must be aware of the existence or
packages is when you want to use a function or variable in another
package.  To do this, write the name of the package, a colon, and then
the name of the symbol, as in EINE:ED-GET-DEFAULTED-FILE-NAME.  You will
notice that symbols in other packages print out that way, too.
Sometimes you may need to refer to a symbol in a package whose superior
is not SYSTEM.  When this happens, use multiple colons, as in
FOO:BAR:UGH, to refer to the symbol UGH in the package named BAR which
is under the package named FOO.

  Another time that packages intrude is when you use a "keyword": when
you check for EQness against a constant symbol, or pass a constant
symbol to someone else who will check for it using EQ.  This includes
using the symbol as either argument to GET.  In such cases, the usual
convention is that the symbol should reside in the USER package,
rather than in the package with which its meaning is associated.  To
make it easy to specify USER, a colon before a symbol, as in :SELECT,
is equivalent to specifying USER by name, as in USER:SELECT.

  Why is this convention used?  Well, consider the function
TV-DEFINE-PC-PPR, which takes any number of keyword arguments.
For example,

     (TV-DEFINE-PC-PPR 'FOO (LIST TVFONT) 'VSP 6 'SIDEWAYS-P T)

specifies, after the two peculiar mandatory arguments, two options with
names VSP and SIDEWAYS-P and values 6 and T.  The file containing this
function's definition is in the SYSTEM-INTERNALS package, but the
function is available to everyone without the use of a colon prefix
because the symbol TV-DEFINE-PC-PPR is itself inherited from SYSTEM.
But all the keyword names, such as VSP, are short and should not have
to exist in SYSTEM.  However, it would be a shame if all callers of
TV-DEFINE-PC-PPR had to specify SYSTEM-INTERNALS: before the name of
each keyword.  After all, those callers can include programs loaded into
USER, which should by rights not have to know about packages at all.
Putting those keywords in the USER package solves this problem.

  Exactly when should a symbol go in USER?  At least, all symbols
which the user needs to be able to pass as an argument to any function
in SYSTEM must be in USER if they aren't themselves in SYSTEM.
Symbols used as keywords for arguments by any function should usually
be in USER, to keep things consistent.  However, when a program uses a
specific property name to associate its own internal memoranda with
symbols passed in from outside, the property name should belong to the
program's package, so that two programs using the same property name
in that way don't conflict.

*) Shadowing.

  Suppose the user doesn't like the system NTH function;  he might be
a former INTERLISP user, and expecting a completely different meaning
from it.  Were he to say (DEFUN NTH ---) in his INTERLOSS program, he
would clobber the SYSTEM symbol named "NTH", and so affect the "NTH"
in everyone else's name space (actually, if he had not "externed" the
symbol "NTH", the redefinition would not take place).

  In order to allow the INTERLOSS package to have its own (DEFUN NTH
---) without interfering with the rest of the Lisp environment, it
must "shadow" out the system symbol "NTH" by putting a new symbol
named "NTH" on its own obarray.  Normally, this is done by writing
(SHADOW NTH) in the declaration of the INTERLOSS package.  Since
INTERN looks on the subpackage's obarray before SYSTEM, it will find
the programmer's own NTH, and never the system one.  Since the system
one is now impossible to see, we say it has been "shadowed."

  Having shadowed NTH, if it is sometimes necessary to refer to the
system definition, this can be done by writing SYSTEM:NTH.  This works
because the refname SYSTEM is defined in the SYSTEM package as a name
for the SYSTEM package.  Since SYSTEM is the superpackage of the
INTERLOSS package, all refnames defined by SYSTEM, including SYSTEM,
are available in INTERLOSS.

*) Packages and INTERN.

  The function INTERN allows you to specify a package as the second
argument.  It can be specified either by giving the package object
itself, or by giving a string or symbol which is the name of the
package.  When typing on the terminal, it is often convenient to use
the construct PACKAGENAME: to specify a package;  this puts the package
object itself, quoted, into the input expression.  Thus, SYSTEM: can
be written to get a pointer to the SYSTEM package.

  INTERN returns three values.  The first is the interned symbol.  The
second is T if the symbol is old (was already present, not just added to
the obarray).  The third is the package in which the symbol was actually
found.  This can be either the specified package or one of its
superiors.

  When you don't specify the second argument to INTERN, the current
package, which is the value of the symbol PACKAGE, is used.  This
happens, in particular, when you call READ.  Bind the symbol PACKAGE
temporarily to the desired package, before calling things which call
INTERN, when you want to sepcify the package.  When you do this, the
function PKG-FIND-PACKAGE, which converts a string into the package it
names, may be useful.  While most functions that use packages will do
this themselves, it is better to do it only once when PACKAGE is bound.
The function PKG-GOTO sets PACKAGE to a package specified by a string.
You shouldn't usually need to do this.

  There are actually four forms of INTERN function:  regular INTERN,
INTERN-SOFT, INTERN-LOCAL, and INTERN-LOCAL-SOFT.  -SOFT means that the
symbol should not be added to the package if there isn't already one;
in that case, all three values are NIL.  -LOCAL means that the
superpackages should not be searched.  Thus, INTERN-LOCAL can be used to
cause shadowing.  INTERN-LOCAL-SOFT is a good low-level primitive for
when you want complete control of what to search and when to add atoms.
All four forms of INTERN return the same three values, except when those
values are trivial, except that the SOFT forms return NIL NIL NIL when
the symbol isn't found.

  Each symbol rememberes which package it belongs to.  While you can
intern a symbol in any number of packages, the symbol will only remmeber
one:  normally, the first one it was interned in, unless you clobber it.
This package is available as (CDR (PACKAGE-CELL-LOCATION symbol)).
If the value is NIL, the symbol believes that it is uninterned.

  Among the functions which uses implicitly the value of PACKAGE is
PRIN1!  Yes, PRIN1 uses PACKAGE in deciding whether a symbol should be
printed with a colon prefix.  Symbols which could be typed in without a
prefix aren't given one when printed.  PRINC never prints a prefix.

  REMOB is always "local", in that it removes only from the specified
package and not from any superpackages.  It returns T if the symbol was
found to be removed.  It also allows the package to be specified as the
second argumemt.

  MAPATOMS too lets you specify the package as the second argument.  The
third argument, which by default is T, says whether to process the
superpackages of that package.  If that is done, shadowed symbols will
be processed just like visible ones.  Too bad.  If that is a problem,
you can try INTERNing each symbol in the original package and ignore the
symbol if it isn't EQ to the result of the INTERN.

  MAPATOMS-ALL maps over all the atoms in all the packages INFERIOR to a
given one, directly or indirectly.  It is used by things like APROPOS
and WHO-CALLS to map over "the whole world".

  SI:PKG-CREATE-PACKAGE creates a package.  SI:PKG-FIND-FILE-PACKAGE will
tell you which package a given file belongs to, asking the user if
necessary.  SI:PKG-MAP-REFNAMES is a functional which embodies the
algorithm which decides when colon-prefixes must be used in printing a
symbol.

*) Status Information.

  The current package -- where your type-in is being interned -- is
always the value of the symbol PACKAGE.  A package is a named
structure which prints out very nicely, so examining the value of
PACKAGE is the best way to find out what the current package is.
Normally, it should be USER, except when in the error handler inside
compilation or loading of a file belonging to some other package.

  To get more information on the current package or any other, use the
function PKG-DESCRIBE.  Specify either a package object or a string
which is the refname for the desired package as the argument.  This will
print out everything except a list of all the symbols in the package.
If you want THAT, use (MAPATOMS 'PRINT package NIL).

*) How Packages Affect Loading and Compilation.

  It's obvious that every file has to be loaded into the right package
to serve its purpose.  It may not be so obvious that every file must be
compiled in the right package, but it's just as true.  Luckily, this
usually happens automatically.

  When you have mentioned a file in a package's file-alist, requesting
to compile that file with QC-FILE or load it with LOAD automatically
selects that package to perform the operation.  This is done by
inverting the package-to-file correspondence described by the
file-alists and remembering the inversion in the form of SI:FILE-PACKAGES
properties on symbols in the FILES package (the symbol representing the
file is (INTERN (FILE-EXPAND-PATHNAME filename) "FILES")).

  If the file is one which is unknown, not mentioned in any package's
declaration, then you will be asked which package to load or compile it
in, but only the first time;  from then on, the system will remember.
This doesn't change the file-alist, though;  merely the FILES package
data base.

  If a file is known as belonging to TWO packages (say, mentioned on two
file-alists), you will always be asked which one to load or compile it in.

  To clear all information about a file's packages from the FILES
package, use the function PKG-LOSE-FILE-PACKAGE on the filename.  This
doesn't remove the file from any file-alists, but does make LOAD and
QC-FILE ask you about the file next time.  What you tell them that time
will go into the FILES package and be remembered from then on.

*) Loading and Compiling Whole Packages.

  Because each package has a file-alist, it is possible to request that
the files of a package be compiled or loaded, as needed.  This is done
with the PKG-LOAD function, which takes as arguments a package and a
list of keywords (or one keyword) specifying the precise nature of the
operation.  For example, (PKG-LOAD "EINE" 'COMPILE) would recompile and
reload the files of the EINE package, such as require it.

  The keywords defined include:

CONFIRM, meaning ask for confirmation before doing it (this is the default);
NOCONFIRM, meaning don't ask for confirmation;
COMPILE, meaning compile files before loading;
NOCOMPILE, meaning do not compile (this is the default);
LOAD, meaning load files (the default);
NOLOAD, meaning don't load (but compile, if that was specified);
SELECTIVE, meaning ask about each file;
COMPLETE, meaning don't ask about each file (the default);
RELOAD, meaning compile or load even files which appear not to need it;
NORELOAD, meaning only process files which have newer versions on disk (the default);
RECURSIVE, meaning also process packages this one refers to;
DEFS, meaning process only DEFS files.

  There is also a function (RECOMPILE-WORLD) which uses PKG-LOAD to
recompile several system packages.  It takes any number of arguments,
which are keywords the same as above.  Unlike PKG-LOAD, it defaults
to NOLOAD and COMPILE.

*) Subpackages.

  Usually, each independent program occupies one package, which is
directly under SYSTEM in the hierarchy.  But large programs, such as
MACSYMA, are usually made up of a number of sub-programs, each of
which is maintained by a small number of people.  We would like each
sub-program to have its own name space, since the program as a whole
has too many names for anyone to remember.  So, we can make each
sub-program into its own package.  However, this practice requires
special care.

  It is likely that there will be a fair number of functions and
symbols which should shared by all of the sub-programs of MACSYMA.
These symbols should reside in a package named MACSYMA, which would be
directly under system.  Then, each part of MACSYMA (such as SIN,
RISCH, INPUT, and so on) would have its own package, with the MACSYMA
packages as its superpackage.  To do this, first declare the MACSYMA
package, and then declare the RISCH, SIN, etc. packages, specifying
MACSYMA as the superpackage for each of them.  This way, each
sub-program gets its own name space.

  However, to avoid a subtle pitfall (described in detail in the
appendix), it is necessary that the MACSYMA package itself contain no
files;  only a set of symbols specified at declaration time.  This
list of symbols is specified using SHADOW in the declaration of the
MACSYMA package.  At the same time, the file-alist specified in the
declaration must be NIL (otherwise, you will not be allowed to create
the subpackages).  The symbols residing in the MACSYMA package can
have values and definitions, but these must all be supplied by files
in MACSYMA's subpackages (which must EXTERN those symbols as
necessary).  Note that this is exactly the same treatment that SYSTEM
receives:  all its functions are actually defined in files which are
loaded into SYSTEM-INTERNALS (SI), COMPILER, etc.

  To demonstrate the full power and convenience {i.e. winnitude} of
this scheme, suppose there were a second huge program called OWL which
also had a subprogram called INPUT (which, presumably, does all of the
INPUTting for OWL), and one called DATABASE.  Then a picture of the
hierarchy of packages would look like this:

			SYSTEM
			   |
		/--------------------------------\
		|                                |
	     MACSYMA		                OWL
		|                                |
 -----------------------------           -------------------------
  | | |      |       |       |           |         |         | | |
(others)   RISCH    SIN    INPUT       INPUT   DATABASE      (others)

(Probably there would be more subprograms; this is a partial figure)

  Now, the RISCH program and the SIN program both do intergration, and
so it would be natural for each to have a function called INTEGRATE.
From inside SIN, SIN's INTEGRATE would be referred to as "INTEGRATE"
(no prefix needed), which RISCH's would be referred to as
"RISCH:INTEGRATE".  Similarly, from inside RISCH, RISCH's own
INTEGRATE would be called "INTEGRATE", wheras SIN's would be referred
to as "SIN:INTEGRATE".

  If SIN's INTEGRATE were a recursive function, the implementor would
be referring to it from within SIN itself, and would be happy that he
need not type out "SIN:INTEGRATE" every time; he can just say
"INTEGRATE".  {As opposed to previous PACK2 schemata, in which that
symbol would be getting put in other people's search rules and have to
have a name like SIN-INTEGRATE in order to not conflict with the RISCH
one.}

  From inside the MACSYMA package or any of its other sub-packages,
the two functions would be referred to as "SIN:INTEGRATE" and as
"RISCH:INTEGRATE".  {Doesn't that sound like the right thing?}  From
anywere else in the hierarchy, they would have to be called
"MACSYMA:SIN:INTEGRATE" and "MACSYMA:RISCH:INTEGRATE".

  Similarly, assume that each of the INPUT packages has a function
called GET-LINE.  From inside MACSYMA or any of MACSYMA's subprograms
(other than INPUT), the relevant function would be called
INPUT:GET-LINE, and the irrelevant one OWL:INPUT:GET-LINE.  The
converse is true for OWL and its sub-programs.  Note that there is no
problem arising from the fact that both OWL and MACSYMA have
subprograms of the same name (INPUT).

*) Initialization of the Package System.

  When the world begins to be loaded, there is no package system.
There is one "obarray", whose format is different from that used by
the package system.  After sufficiently much of the Lisp environment
is present for it to be possible to initialize the package system,
that is done.  At that time, it is necessary to split the symbols of
the old-style obarray up among the various initial packages.

  The first packages created by initialization are the most important
ones:  SYSTEM, USER, and SYSTEM-INTERNALS.  All of the symbols already
present are placed in one of those packages.  By default, a symbol
goes into SYSTEM-INTERNALS.  Only those placed on special lists go
into one of the others.  These lists are the file LISPM;SYSPKG > of
symbols which belong in SYSTEM, and the file LISPM;KWDPKG > of symbols
which belong in USER (at the moment, these are actually loaded into
SYSTEM, because not everybody has been converted to use colons where
necessary).

  After the three basic packages exist, the package system's
definition of INTERN is installed, and packages exist.  Then, the
other initial packages FORMAT, COMPILER, EINE, etc. are declared and
loaded using PACKAGE-DECLARE and PKG-LOAD, in almost the normal
manner.  The exception is that a few of the symbols present before
packages exist really belong in one of these packages.  Their package
declarations contain calls to FORWARD and BORROW, which exist only for
this purpose and are meaningful only in package declarations, are used
to move the symbols as appropriate.  These declarations are kept in
the file LISPM;PKGDCL >.

  Sometimes it will be discovered that a symbol which ought to be in
SYSTEM is not there, and the file defining it has already been loaded,
thus mistakenly creating a symbol with that name in a package which
ought just to inherit the one from SYSTEM.  When this happens, you can
correct the situation by doing (SYSTEMATIZE "symbol name").  This
function creates a symbol with the desired name in SYSTEM, merges
whatever value, function definition, and properties can be found on
symbols of that name together into the new symbol (complaining if
there are conflicts), and forwards those slots of the existing symbols
to the slots of the new one using one-q-forward pointers, so that they
will appear to be one and the same symbol as far as value, function
definition, and property list are concerned.  They cannot all be made
EQ to each other, but SYSTEMATIZE does the next-best thing:  it takes
an existing symbol from USER, if there is one, to put it in SYSTEM.
Since people who check for EQ are normally supposed to specify USER
anyway, they will not perceive any effect from moving the symbol from
USER into SYSTEM.

  If SYSTEMATIZE is given a symbol instead of a string as argument,
the exact symbol specified is put into SYSTEM.  You can use this when
a symbol in another package, which should have been inherited from
SYSTEM, is being checked for with EQ -- as long as there are not TWO
different packages doing so.  But, if the symbol is supposed to be in
SYSTEM, there usually should not be.

*) Initial Packages.

  The initially present packages include:

SYSTEM, which contains advertised system functions.
USER, which is used to intern the user's type-in, and which contains all
  keywords.
SI or SYSTEM-INTERNALS, which contains subroutines of many advertised
  system functions.
COMPILER, which contains the compiler and fasload.
EINE, which contains the editor.
SCREEN, which contains the screen manager.
LCHAOS, which contains the CHAOS net controller.
LSOUP, which contains SUPDUP.
FORMAT, which contains the function FORMAT.

  Packages which are used for special sorts of data:

FONTS, which contains the names of all fonts.
FILES, which contains the file-symbols of all files.
  Many properties are kept on these symbols to remember information
  about files which are in use.
FORMAT, which contains the keywords for FORMAT, as well as the code.

*) Multiple Instantiations of a Program.

	This isn't finished yet, which is why we don't say how to do
any of this.

	Suppose the maintainer of EINE (the Lisp Machine editor) has
made some changes to EINE, and would like to debug them.  He has a
problem: if he reads in the new version, which presumably may be full
of bugs, then he will not be able to do any editing!  This would be
annoying, since the editor is very useful.

	We would like both the regular and the experimental versions
of the editor to BOTH be loaded into the Lisp world.  In order for two
definitions of each editor function to coexist, we need to load the
new version into a separate package, which must have a different name
(not named "EINE", like the package the original editor is in).  If
the test version's package is called "TEST-EINE", then the user can
try it by calling (TEST:ED), and edit it using (ED).

	However, there is a problem to be faced.  The editor redefines
a few entry-point functions (ED, EDPROP, etc) which reside in SYSTEM.
If the test editor redefined them, the whole point of the separate
package would be lost.  So, the TEST-EINE package must SHADOW all the
symbols which the regular EINE package EXTERNs.

	Further complications are needed to make it possible to test
one program using another instead of by hand.  Suppose that there is a
program named RANDOM residing in its own package, and containing a
function named NUMBER.  Suppose that we have a debugged program, DP
(Dissociated Press) which uses RANDOM:NUMBER.  And now, we have
written a new version of RANDOM and want to test it using DP, without
installing it and breaking system tools which use RANDOM.  What we
want to do is to load in a test version of RANDOM, TEST-RANDOM, and a
also a TEST-DP which will refer to it, to test it with.

	This can be done if we can make the TEST-DP package
"translate" the name "RANDOM" into "TEST-RANDOM".  All this takes is
an entry on TEST-DP's refname-alist, associating the name "RANDOM"
with the TEST-RANDOM package.  Then, when RANDOM:NUMBER is seen in the
course of reading in the old DP program into TEST-DP,
TEST-RANDOM:NUMBER will actually be used.  Note that normally TEST-DP
wouldn't have ANYTHING on its own refname-alist for "RANDOM";  it
would inherit the association from SYSTEM.  We are actually
"shadowing" in TEST-DP the definition of "RANDOM" as a package refname
which is present in SYSTEM.  Here is what we will get.

                        SYSTEM  [RANDOM -> RANDOM]
                           |
          /---------------------------------------\
          |        |              |               |
         DP  =>  RANDOM        TEST-DP  =>      TEST-RANDOM
			[RANDOM -> TEST-RANDOM]

    ("=>" indicates who calls whom;  "->" indicates a refname).

	So far, every package has had its own name as a refname for
itself.  A test package, however, shouldn't have its actual name as a
refname for itself, but the name its program expects:  "RANDOM", not
"TEST-RANDOM".  This is necessary to handle test packages with
subpackages right, together with shadowing.  In fact every package has
a "program name" as well as a "name".  For ordinary packages, they are
the same, but for a test package, the program name is identical to
that of the original package.

  Suppose we have the MACSYMA program with all of its sub-packages as
described above. Further assume that the INPUT sub-program's author
has his own symbol named SIMP, and he calls MACSYMA:SIMP to get the
one in the MACSYMA package.  Now, say someone wants to load an
experimental MACSYMA into the machine: he would name the new obarray
TEST-MACSYMA or something.  In order to assure that the reference to
MACSYMA:SIMP is properly resolved, the refname-alist of TEST-MACSYMA
must contain TEST-MACSYMA under the name MACSYMA.

*) Appendix: Arguments and Screws

 A) Why a package with subpackages can't have files.

  This is somewhat tricky.  Suppose we are loading program FOO,
and come across an attempt to intern "B:C:D", where a package B is under
SYSTEM and has a subpackage named C.  Apparently we must create a symbol
named "D" and install it on "C".  If B has any files which are not
loaded yet, this can cause a screw, as follows:
  Suppose that, for some reason, one of those files uses a symbol "D".
Had we loaded "B" and its subprograms, the right thing would be for a
symbol "D" to be installed on the "B" obarray, and so for the name "D"
in "C"'s context to refer to the symbol "D" on the "B" obarray.  (Recall
that "C"'s name space would be (C B SYSTEM) ).  But in our example, we
have installed a "D" on "C", when in fact there never should have been
one there.  The string "B:C:D" refers to whatever the symbol "D" means
in the "B:C" context, and the symbol "D" in that context meant a symbol
"D" on "B"; there should be no "D" on "C".  (This might be a little
opaque, and possible should be read twice.)
  Requiring that "B" have no files since it has subpackages prevents
this problem from occurring.
  Other solutions considered include:
    Automatically load up "B" when "B:C:D" is seen, before interning D.
    Say that colon does not ever search superpackages of the specified
package, and the user of colon must always specify the exact package
that contains the desired symbol.  Although inadvertant shadowings can't
be prevented, they can always be detected after the fact, and the user
can be told.  However, this restriction of how colon works is a bad
screw in itself.

 B) Why the package used for user type-in can't ever have subpackages.

  Because the user can type absolutely anything, causing it to exist in
the package used to intern his type-in.  If the user types MUMBLE in a
package which then has two subpackages loaded, each of which tries to
have its own symbol MUMBLE, they will interfere with each other.

 C) Why the package used for keywords can't have subpackages.

  It's the same as B).  Since any package can use any keyword, any
symbol whatever might be created in the keyword package at any time.
This could cause two subpackages using that name to interfere with each
other.

 D) Why the user package can't be under the keyword package,
    or vice versa.

  Because in either case you would get different and perplexing results
depending on whether you used (or looked for) a symbol as a keyword
before or after you typed it on the terminal.

 E) Why each package can't specify an arbitrary sequence of packages
    to inherit symbols from.

  Suppose that FOO searches BAR, MUMBLE and SYSTEM, while BAR
searches only SYSTEM.  Creating the symbol X in BAR, perfectly
legitimate, will cause FOO not to see a symbol X in MUMBLE, which it
had expected to see.
 
  This problem can always occur the search lists are arranged to form
precisely the hierarchical structure that is actually used.

 F) Why not have each package place its external entry points into a
    package higher up in the hierarchy, so that everyone can refer to
    them without using ":"?

  This does not do anything to prevent name conflicts for the externed
symbols; and in the case of the CHAOS program, nearly every function
would have to be so externed.  It is better to have the decisions
about what symbols are to appear in SYSTEM be kept all together in one
place, so that possible conflicts will be detected and dealt with.

*) Future Possibilities and Issues.

 A) Right now, a package must be declared before it can be referred to
with colon from other packages.  It has been suggested that there be a
search mechanism which finds and processes the declaration of a package
if it is referred to before it is declared.  I (RMS) think this should
wait until we have the file computer, at which time it can be integrated
with the new file system in a very winning way.

 B) Should the error handler be able to load a package automatically
(ie, should all packages "autoload")?  Right now, you can load in the
package and continue using the error handler, unless you get screwed by
the fact that you can only have one input file.  It wouldn't be hard to
implement the autoloading, since each symbol points at its package.  A
possible bell or whistle is to have the package declaration supply a
list of permissible entry points which should cause autoloading.

 C) Eventually it should actually be made convenient to load up multiple
copies of a program, one of them for debugging.  PKG-DEBUG-COPY is an
attempt at this, but maybe it's wrong;  maybe the right way is for the
function to allow you to specify just what should be different, or maybe
you should have a bunch of package declarations ground into a buffer for
you to edit.

 D) And along those lines, it should be possible to alter EXTERNs, at
least, by reading in a declaration for a second time.  But you can't
just execute the whole declaration body again, since that is dangerous.
And what about shadowing?

 E) There should be a convenient way to empty out an obarray, redeclare
it, and reload it all.

 F) Actually implement package-dependent FASLOAD warnings.
And DEFUN and MACRO should also warn, if read from files.

 G) Is is desirable to create special search-rules for the USER package?
Is this in conflict with the use of USER as the keywords package?
