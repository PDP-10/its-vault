   A LONG STANDING PROBLEM IN LISP HAS BEEN THAT THE FUNCTION PASSED AS A
FUNCTIONAL ARGUMENT CANNOT REFERENCE LOCAL VARIABLES BOUND IN THE 
FUNCTION WHICH PASSED IT, EVEN THOUGH THE FUNCTION BEING PASSED IS WRITTEN
ENTIRELY WITHIN THE LEXICAL SCOPE OF THE FUNCTION DOING THE PASSING.
  THIS PROBLEM HAS TYPICALLY BEEN SOLVED IN
A SOMEWHAT UNSATISFACTORY WAY BY REQUIRING THE VARIABLES IN QUESTION
BE DECLARED SPECIAL.
   IN LISP, DECLARING A VARIABLE SPECIAL MEANS TWO THINGS:
1) THE VARIABLE IS HOOKED INTO THE SYSTEM WIDE NAMING CONVENTIONS (VIA ATOMS,
   OBLISTS, ETC.)
2) THE VARIABLE IS STORED IN A "VALUE-CELL" INSTEAD OF A PDL FRAME, ETC.
   BIND AND UNBIND BECOME NECESSARY AND ARE PROVIDED BY THE SYSTEM, ETC.

   NOTE THAT THE UNDESIRABLE FEATURES OF REQUIRING THESE VARIABLES SPECIAL ARE
CONNECTED WITH 1, WHILE 2 IS WHAT MAKES IT WORK!  FURTHERMORE, 1 AND 2 ARE NOT
NECESARILY RELATED!  WE THEREFORE POSTULATE A NEW SORT OF VARIABLE
CALLED A REMOTE VARIABLE, WHICH HAS PROPERTY 2 BUT NOT 1.
   THE USER IS NEVER CONCERNED ABOUT REMOTE VARIABLES.  HE JUST TREATS THEM
AS LOCALS.  THE COMPILER IS ABLE TO AUTOMATICALLY DETERMINE THAT A PARTICULAR
VARIABLE NEEDS TO BE REMOTE, AND MAKE IT SO.  THIS IS ALL THAT IS REQUIRED
IF THE FUNCTIONAL ARGUMENT IS PASSED ONLY IN THE DOWNWARD DIRECTION AND USED
IN AN ELEMENTARY FASHION (SEE BELOW FOR A DISCUSSION OF WHAT THIS MEANS).

   IF IT IS DESIRED THAT UPWARD PASSING WORK (OR NON-ELEMENTARY DOWNWARD
FUNARGS, AGAIN SEE BELOW),
NOTE THAT THE USUAL CLOSURE MECHANISM CAN WORK WITH REMOTE VARIABLES.
IN FACT, THE SYSTEM CAN EASILY PROVIDE A PSEUDO-MACRO WHICH EXPANDS INTO
THE SET OF REMOTE VARIABLES IN ALL LOWER FUNCTIONS.  THUS BY WRITING
(FUNCTION (CLAMBDA ...)) INSTEAD OF (FUNCTION (LAMBDA ..)), THE REQUIRED
CLOSURE WOULD AUTOMATICALLY BE GENERATED. (THIS LAST IDEA WAS SUGGESTED BY RMS).

   THE IMPLEMENTATION IN THE COMPILER IS FAIRLY STRAIGHTFORWARD.  WHEN THE
COMPILER CALLS ITSELF RECURSIVELY TO COMPILE THE FUNCTIONAL, IT SUPPLIES THE
LOWER INSTANTIATION WITH A LIST OF THE CURRENT SO-FAR LOCAL VARIABLES.
IF THE COMPILER IS ABOUT TO  "BARF XXX DECLARED SPECIAL", IT CHECKS THIS LIST.
IF THE VARIABLE IS FOUND THERE, IT IS DECLARED REMOTE.  THE COMPILER RETURNS
THE LIST OF THE REMOTE VARIABLES, SO THAT THE HIGHER LEVEL CAN ALSO
ADJUST THESE VARIABLES FROM LOCAL TO REMOTE, ETC.  FORTUNATELY, FUNCTION BREAKING
OFF OCCURS DURING PASS 1, SO NO INCORRECT CODE HAS BEEN GENERATED, AND
THE READJUSTMENT REQUIRED TO COMPILER DATA STRUCTURES IS RELATIVELY MODEST.

   A MODEST MECHANISM IS NEEDED IN THE LOADER TO ALLOCATE THE VALUE CELL(S)
WHEN A FUNCTION CONTAINING REMOTE VARIABLE(S) GETS LOADED.  
A SMALL DATA STRUCTURE IS ALSO REQUIRED SO THAT THE VARIABLE IN THE BROKEN
OFF FUNCTION(S) AND THE MAIN ONE WIND UP SHARING THE SAME VALUE CELL.

******************************************************************************************
ON "DOWNWARD" FUNARGS, ELEMENTARY AND NON-ELEMENTARY.

   THE USUAL DISCUSSION OF "THE FUNARG PROBLEM" AND IN PARTICULAR "THE
DOWNWARD FUNARG PROBLEM" MISSES AN IMPORTANT POINT.  USUALLY, THE
PROBLEM IS ILLUSTRATED AS A CHANCE CONFLICT IN THE NAMES WHICH HAPPENED
TO BE USED FOR VARIABLES 
IN TWO FUNCTIONS, WHICH IN TURN CAUSES IMPROPER OPERATION.  IT SHOULD BE 
POINTED OUT, THOUGH, THAT IT IS QUITE POSSIBLE FOR A SINGLE FUNCTION
TO CONFLICT WITH ITSELF.  FURTHERMORE, IN THAT CASE, NO VARIABLE RENAMING
WILL HELP.  SPECIAL (OR EQUIVALANTLY REMOTE) VARIABLES ARE BY THEMSELVES
QUITE INADEQUATE, AND THE ONLY WAY TO OBTAIN CORRECT OPERATION IS WITH
CLOSURES, ALL THIS EVEN THOUGH FUNCTIONAL ARGUMENTS ARE PASSED ONLY IN THE
DOWNWARD DIRECTION.
   TO ILLUSTRATE, CONSIDER:

(DEFUN COMPLEX-TESTER (X Y D)
  (COND ((NULL X) (COMPLEX-TESTER (FUNCTION (LAMBDA NIL (PRINT (LIST 1 D)))) NIL (1+ D)))
	((NULL Y) (COMPLEX-TESTER (FUNCTION (LAMBDA NIL (PRINT (LIST 2 D)))) X (1+ D)))
	(T (FUNCALL X) (FUNCALL Y))))

WE THEN EVALUATE (COMPLEX-TESTER NIL NIL 0).  (2 2) (1 2) WILL BE PRINTED INSTEAD
OF THE CORRECT (2 1) (1 0) .  MAKING D SPECIAL (OR REMOTE) WILL NOT HELP,
NOR WILL ANY NAME CHANGING.  THE ONLY SOLUTION (AT LEAST AMONG THE MECHANISMS
PROVIDED BY LISP MACHINE LISP) IS TO USE A CLOSURE IE

(DEFUN COMPLEX-TESTER (X Y D)
  (COND ((NULL X) (COMPLEX-TESTER 
		    (CLOSURE '(D) (FUNCTION (LAMBDA NIL (PRINT (LIST 1 D))))) NIL (1+ D)))
	((NULL Y) (COMPLEX-TESTER 
		    (CLOSURE '(D) (FUNCTION (LAMBDA NIL (PRINT (LIST 2 D))))) X (1+ D)))
	(T (FUNCALL X) (FUNCALL Y))))

   THUS, WE IDENTIFY THE "ELEMENTARY DOWNWARD FUNARG PROBLEM" WITH THE USUAL EXAMPLE
WHICH CAN BE SOLVED BY VARIABLE RENAMING (OR MAKING THE VARIABLES REMOTE),
AND THE "NON-ELEMENTARY DOWNWARD FUNARG PROBLEM" WHICH CAN NOT BE SOLVED
BY THESE MEANS.

   (COMPLEX-TESTER NIL NIL 0)  WILL ESTABLISH THREE BINDING ENVIRONMENTS, THE
ORIGINAL CALL AND TWO RECURSIONS.  CALL THESE LEVELS 1, 2 AND 3 RESPECTIVELY.
THEN THERE IS A CERTAIN DISTINCTION BETWEEN THE LOSSAGE THAT OCCURS BETWEEN LEVELS
2 AND 3, AND THAT BETWEEN 1 AND 2.  2 VS 3 IS IN SOME SENSE A LOCAL VS EXTERNAL
CONFLICT WHILE 1 VS 2 IS A EXTERNAL VS EXTERNAL CONFLICT.

******************************************************************************************
LOSSAGE...
  LOCAL CLOSURES ARE A DEVICE TO ALLOW A FUNCTION BEING PASSED AS A FUNCTIONAL
ARGUMENT BY ANOTHER FUNCTION TO LATER REFERENCE LOCAL VARIABLES BOUND 
BY THE INSTANTIATION OF THE PASSING FUNCTION.  CURRENTLY, SUCH VARIABLES
MUST BE DECLARED SPECIAL IN ORDER TO WORK, WHICH IS UNDESIRABLE.
  THE NORMAL CLOSURE MECHANISM REQUIRES THE USER TO LIST THE VARIABLES
TO BE CLOSED OVER.  IN ADDITION, IT NORMALLY REFERS ONLY TO SPECIAL VARIABLES.

*****************************************************************************************
MORE LOSSAGE...
  LOCAL FUNARGS ARE A DEVICE TO ALLOW A FUNCTION BEING PASSED AS A FUNCTIONAL
ARGUMENT BY ANOTHER FUNCTION TO LATER REFERENCE LOCAL VARIABLES BOUND
BY THE INSTANTIATION OF THE PASSING FUNCTION.  CURRENTLY, SUCH VARIABLES
MUST BE DECLARED SPECIAL IN ORDER TO WORK, WHICH IS UNDESIRABLE.
  THE PRESENT LOCAL FUNARG MECHANISM IS RESTRICTED TO THE "DOWNWARD DIRECTION".

  THE NAME LOCAL FUNARG IS PREFERRED TO THE PREVIOUS LOCAL CLOSURE BECAUSE
WITH THE ONE MECHANISM ALL LOCAL VARIABLES ARE MADE AVAILABLE (THEY NEED NOT BE
LISTED, ETC) AND BECAUSE THIS MECHANISM CAN BE AUTOMATICALLY APPLIED BY THE
COMPILER WITHOUT INTERVENTION ON THE PART OF THE USER.
  THE CAPABILITY IMPLEMENTED BY LOCAL FUNARG IS SOMEWHAT SIMILAR TO THAT USUALLY PROVIDED
BY LEXICALLY SCOPED LANGUAGES SUCH AS ALGOL.  IN MOST CASES, IF THE CODE FOR THE
FUNCTION BEING PASSED THE FUNCTIONAL ARGUMENT (AND ITS SUBFUNCTIONS LEADING TO 
THE FUNCTIONAL ARGUMENT BEING APPLIED, ETC) WERE AVAILABLE TO THE COMPILER,
THE COMPILER COULD COMPUTE DIRECTLY THE REQUIRED OFFSET BACK UP THE STACK.
(THIS OFFSET COULD BE EXPRESSED EITHER IN FRAMES OR WORDS, AS REQUIRED).
