;	Interim NCP for DM/CG

BBLK

;	STATUS
;
;	STATE IN 2.4-2.9
HSNET:	HLRZ	B,FISKT+3(A)
	DPB	B,[140600,,D]
	POPJ	P,

;NETBLock
;AC  / CHNL,,STATE
;AC+1/ TIME
ANETBL:	XCTR XRW,[MOVES 1(J)]	;BLESS THE SECOND ARG
	XCTR XRW,[MOVES R,(J)]	;BLESS, FETCH FIRST ARG
	HLRZS R		;GET CHAN TO RH(R)
	CAIL	R,20		;A LEGITITATE CHANNEL?
	JRST	ILUUO
	ADDI	R,IOCHNM(U)	;IOCHNM*
	HLLZ	T,(R)		;LOSR
	XCTR XR,[HRR	T,(J)]	;STATE
	XCTR XR,[MOVN	TT,1(J)] ;NEG OF TIME
	JUMPGE	TT,ANTBL1	;ALLOWS ABSOLUTE`TIME AND PREVENTS LOSAGE
				;FROM PC_LOSR_IOG
	SUB	TT,TIME		;NOW TIME FROM T0
	XCTR XRW,[MOVEM	TT,1(J)] ;STORE BACK TO WIN ON JUMPGE
	MOVMS	TT		;MAKE POSITIVE
ANTBL1:	MOVEM	TT,EPDL(U)	;TEMP STORAGE
	PUSHJ	P,ANTBL2
	PUSHJ	P,UFLS		;SNORE
	MOVE	TT,EPDL(U)
	JUMPE	TT,ANTBL4	;JUMP IF NO TIME WAS SPECIFIED
	SUB	TT,TIME
	XCTR XRW,[MOVEM	TT,1(J)]
	SKIPE	TT		;TIME OUT?
ANTBL4:	AOS	(P)		;NO
	HLRZ	TT,(R)	;LOSER
	HLRZ	TT,FISKT+3(TT)	;STATE
	XCTR XRW,[HRRM	TT,(J)]	;GIVE IT TO THE USER
	POPJ	P,

ANTBL2:	PUSH	P,A
	PUSH	P,T
	HLRZ	A,T		;LOSR
	HRRZS	T		;OLD STATE
	HLRZ	A,FISKT+3(A)	;CURRENT STATE
	CAME	T,A		;SAME?
	JRST	ANTBL3		;NO - WIN
	SKIPN	A,EPDL(U)	;TIME
	JRST	ANTBL5
	CAMG	A,TIME		;TIMED OUT?
ANTBL3:	AOS	-2(P)		;YES
ANTBL5:	POP	P,T
	JRST	POPAJ

;.NETUTility
;CALL WITH .NETUT AC,
;AC/ DISPATCH #
ANETUT:	XCTR XR,[HRRZ	C,(J)]	;WHICH ONE
	CAIL	C,AFIUTL
	JRST	ILUUO		;LOSE IF YOU DONT KNOW WHAT YOU ARE DOING
	JRST	@.+1(C)
AFIUTB:	CPOPJ	;0 - NOP
	AFIUSD	;1 - NET DOWN WHEN FISKT EMPTY
	AFIUNS	;2 - NOT DOWN  "     "    "
	AFIUKN	;3 - NET DOWN NOW!
	AFIUZS	;4 - ZERO SOCKET TABLE
AFIUTL==.-AFIUTB

AFIUSD:	SETZM	FIBND
	POPJ	P,

AFIUNS:	SETOM	FIBND
	POPJ	P,

AFIUKN:	XCTR XR,[HLRE	B,(J)]
	JUMPL	B,FIFIN		;ONLY WIN WITH -1,,3
	POPJ	P,


AFIUZS:	XCTR XR,[HLRE	B,(J)]
	SKIPL	B	;ONLY WINS WITH -1,,4
	POPJ	P,
	SETZM	FISKT
	MOVE	B,[FISKT,,FISKT+1]
	BLT	B,FISKTB
	JRST	FIFIN		;REINIT THE WORLD
;.NETBYte size
;CALL WITH .NETBY AC,
;	AC/CHNL,,LOC
;RETURNS:
;	LOC/ STATE OF SOCKET,,BYTE SIZE OF CONNECTION

ANETBY:	XCTR XR,[HLRZ	R,(J)]	;CHANNEL
	CAIL	R,20		;LEGITIMATE CHANNEL NO.?
	JRST	ILUUO
	ADDI	R,IOCHNM(U)
	XCTR XR,[HRRZ	J,(J)]	;ADDR
	MOVE	E,(R)
	LDB	E,[300600,,STATB(E)]  ;DEV TYPE
	CAIE	E,42		;IS IT THE NET?
	POPJ	P,		;NO

	HLRZ	E,(R)		;LOSER
	HRRZ	A,FISKT+7(E)	;BYTE SIZE
	HLL	A,FISKT+3(E)	;STATE
	XCTR XRW,[MOVEM	A,(J)]
	POPJ	P,

;.NETLIsten
;CALLED WITH .NETLI AC,
;	AC/CHNL,,ADDR
;	ADDR/ # OF BITS
;	ADDR+1/ # OF MSGS (IF WRITE CHNL)

ANETLI:	XCTR XR,[HLRZ	R,(J)]	;CHNL
	CAIL	R,20	;LEGIT CHANNEL?
	JRST	ILUUO	;NO
	ADDI	R,IOCHNM(U)
	XCTR XR,[HRRZ	J,(J)]	;ADDR
	MOVE	E,(R)
	LDB	E,[300600,,STATB(E)]	;DEV TYPE
	CAIE	E,42	;IS IT THE NET?
	POPJ	P,	;NO

	XCTR XRW,[MOVES (J)]
	XCTR XRW,[MOVES 1(J)]	;BLESS ADDR
	HLRZ	E,(R)	;LOSR
	MOVE	A,FISKT+1(E)
	TLNE	A,200000	;WR[TE?
	JRST	ANTLI2		;YES
	MOVEI	T,1		;DETERMINE BYTES/WD
	TLNE	A,100000	;ASCII?
	MOVEI	T,4		;YES
	MOVE	A,FISKT+2(E)	;
	TLNE	A,200000	;1 BIT BYTES?
	MOVEI	T,36.		;YES
	MOVE	A,E
	PUSHJ	P,FIBUFF	;BUFR ADDR IN A
	MOVE	Q,A
	PUSHJ	P,FIHMB
	JRST	ANTLI1		;BUFR MUNGED
	TLZ	I,400000	;TURN OFF 4.9 BIT
	SETZM	TT
	CAIN	T,1		;DETERMINE BITS/BYTE
	MOVEI	TT,36.
	CAIN	T,4
	MOVEI	TT,7
	CAIN	T,36.
	MOVEI	TT,1
	IMUL	I,TT		;# BITS
	MOVEM	I,(J)
	POPJ	P,

ANTLI1:	XCTR XRW,[SETOM	(J)]	;BUFR MUNGED
	POPJ	P,

ANTLI2:	LDB	A,[4000,,FISKT+4(E)]	;BIT ALLOC
	XCTR XRW,[MOVEM	A,(J)]
	HRRZ	A,FISKT+6(E)		;MSG ALLOC
	XCTR XRW,[MOVEM	A,1(J)]
	POPJ	P,


;	 RCHST (READ CHANNEL STATUS)
;FOR HOST,,(SIXBIT/NET/)
;LOC SOC
;FOR SOC
;-1 IF NETWORK INT - 0 IF NOT (CLEARS THAT FLAG)
;STATE
;
;J/ PNTR TO 5 WORDS
;A/ LOSR
STNET:	MOVE E,A
	LDB	A,FIFHST
	XCTR XRW,[HRLM	A,(J)]
	LDB	A,FIFSOC
	XCTR XRW,[MOVEM	A,2(J)]
	LDB	A,FILSOC
	XCTR XRW,[MOVEM	A,1(J)]
	XCTR XRW,[SETZM	3(J)]
	MOVE	A,FISKT+1(E)
	TLZE	A,400000	;INTERUPT?
	XCTR XRW,[SETOM	3(J)]
	MOVEM	A,FISKT+1(E)
	MOVE	A,[SIXBIT/NET/]
	XCTR XRW,[HLRM	A,(J)]
	HLRZ	A,FISKT+3(E)	;STATE
	XCTR XRW,[MOVEM	A,4(J)]
	POPJ	P,
	; .NETACcept
ANETAC:	MOVE	E,(R)
	LDB	E,[300600,,STATB(E)]	;DEVICE TYPE
	CAIE	E,42	;IS IT THE NET?
	POPJ	P,
	HLRZ	E,(R)		;LOSR
	HLRZ	B,FISKT+3(E)	;STATE
	CAIE	B,2
	POPJ	P,
	LDB	B,FILSOC
	ROT	B,-1		;NEG IF ODD - STR
	JUMPL	B,.+3
	PUSHJ	P,FIMRTS	;GET A RTS
	JRST	.+2
	PUSHJ	P,FIMSTR	;GET A STR
	PUSHJ	P,FICQW	;SEND IT
	LDB	H,FIFHST
	LDB	Q,FILINK
	MOVEI	R,FIMSGS		;MSGS
	MOVEI	W,FIBITS		;BITS
	SKIPL	B		;DONT ALLOCATE ON WRITE CHANNEL
	PUSHJ	P,FISALL	;SEND ALLOC
	MOVEI	B,5
	HRLM	B,FISKT+3(E)
	POPJ	P,
	; .NETREject
ANETRE:	MOVE	E,(R)
	LDB	E,[300600,,STATB(E)]	;DEVICE TYPE
	CAIE	E,42	;IS IT THE NET?
	POPJ	P,
	HLRZ	E,(R)		;LOSR
	HLRZ	A,FISKT+3(E)	;STATE
	JRST	@.+1(A)
	ANETR2	;0
	CPOPJ	;1
	ANETR1	;2
	ANETR2	;3
	ANETR1	;4
	ANETR1	;5
	ANETR1	;6
	CPOPJ	;7
	ANETR1	;10
	ANETR1	;11
	CPOPJ	;12
	ANETR2	;13
ANETR1:	PUSHJ	P,FIMCLS	;GET A CLS
	PUSHJ	P,FICQW	;SEND IT
ANETR2:	LDB	TT,FILSOC
	PUSHJ	P,FIFPQ		;ANYTHING WAITING IN PENDING QUEUE?
	JRST	ANETR3
	MOVE	TT,1(T)		;FOR SOC
	DPB	TT,FIFSOC
	ROT	TT,-1		;ODD MEANS STR
	JUMPL	TT,.+3
	HLRZ	TT,3(T)		;LINK
	DPB	TT,FILINK
	HRRZ	TT,3(T)
	DPB	TT,FIFHST
	MOVEI	TT,2
	HRLM	TT,FISKT+3(E)	;STATE 2
	PUSH	P,C
	MOVE	C,E		;C/ ALSO LOSR
	PUSHJ	P,FIINTU	;INTERRUPT THE USER
	POP	P,C
	POPJ	P,

ANETR3:	SETZM	TT
	DPB	TT,FIFHST
	DPB	TT,FIFSOC
	MOVEI	TT,1
	HRLM	TT,FISKT+3(E)	;STATE 1
	POPJ	P,

	; .NETIN-TERUPT
	;CALLED WITH .NETIN CH,
	;SENDS A NCP INS OR INR

ANETIN:	MOVE	E,(R)
	LDB	E,[300600,,STATB(E)]	;DEVICE TYPE
	CAIE	E,42	;IS IT THE NET?
	POPJ	P,
	HLRZ	E,(R)		;LOSR
	HLRZ	B,FISKT+3(E)	;STATE
	CAIN	B,5
	JRST ANTIN1
	CAIN	B,6
	JRST ANTIN1
	CAIE	B,11
	POPJ	P,
ANTIN1:	PUSHJ	P,SWTL	;GET USE OF FIORFC
	NETSW
	MOVEI	A,3	;3 WORD CONTROL MESSAGE
	MOVEM	A,FIORFC
	LDB	A,FIFHST	;WHO TO SEND TO
	LSH	A,20.		;POSITIONED
	MOVEM	A,FIORFC+1
	MOVE	A,[1000,,1000]	;2 BYTES 8 BITS
	MOVEM	A,FIORFC+2
	MOVEI	A,7
	MOVE	B,FISKT+1(E)	;LOC SOC
	ROT	B,-1	;SEX NOW HIORDER BIT
	SKIPGE	B	;SKIP IF INR - WRITE SOC
	AOS	A		;INS - READ SOC
	LSH	A,28.
	LDB	B,FILINK	;LINK
	LSH	B,20.
	IOR	A,B	;OP CODE AND LINK
	MOVEM	A,FIORFC+3
	MOVEI	W,FIORFC
	PUSHJ	P,FICQI
	JFCL		;FOR NOW, WILL BE UFLS OF FICQFR
	PUSHJ	P,LSWPOP
	POPJ	P,

;CALLED BY CLOCK CODE EVERY 15 MINS
DEM15M:	PUSH	P,A
	MOVE	A,[SIXBIT /DEM15M/]	;LOAD ATSIGN DEM15M
	PUSHJ	P,DEMSIG
	POP	P,A
	MOVEI	T,DEMKI
	MOVEI	C,DM15MN
	JRST	CLQREE

EBLK


;
;	NETWORK VARIABLES
;
;	CONSTANTS

FINOQ==40	;# OF ENTRIES IN OUTPUT QUEUE
FINSKT==40	;# OF ENTRIES IN SOCKET MAP
FILSKT==8.	;# OF WORDS IN EACH FISKT ENTRY
FINPQ==40	;# OF ENTRIES IN PENDING QUEUE
FINCQ==20	;# OF ENTRIES IN CONTROL QUEUE
FINKQ==20	;# OF ENTRIES IN KLOCK QUEUE
FINHTT==20	;# OF ENTRIES IN HOST TABLE

FIMSGS==20.		;# MSGS TO BE ALLOCATED
FIBITS==2908.		;# BITS TO BE ALLOCATED



FIMXMG==-20000.	;LONGEST ALLOWABLE MESSAGE
FISMLK==1	;SMALLEST LINK # TO BE USED
FIMXLK==32.	;LARGEST LINK # TO BE USED

NETOC==3
NETON==TTYON\200_<-NETOC>
NETOFF==TTYOFF\200_<-NETOC>
PI6INT==4002

NETNCP==1	;TO GET PROPER VERSION OF ITSIMP

FIBFLG==176	;LENGTH OF USERS BUFFER -2

FILKOU==0	;0=> MPG/PI LOCKOUT TEST OFF  -1=> ON
NCPDBG==-1	;0=> NO DEBUG FEATURES   -1=> YES DEBUG FEATURES
FCNTEM==0	;-1=> MOBY INSTRUMENTATION COUNTERS

;
;
;IOCER2 => MSG TOO LONG
;IOCER3 => FATAL ERROR OR WRONG USER
;IOCER4 => IMP DOWN - NOW OR ABOUT TO
;IOCER5 => ERROR BIT ON NON-FATAL ERROR, CAN BE TRIED AGAIN
;IOCER9 => FIGBUF OR FIWQI FOUND FULL TABLES (FIOQ NETRAC)
;
;12 => PROTOCOL ERROR
;13 => INPUT BUFFER MUNGED
;14 => IMP DOWN
;15 => DATA LOST IN TRANSMISSION
;16 => ILLEGAL STATE
;
;HOST-HOST PROTOCOL ERRORS
;1 => CNTL OP_CODE OUT OF BOUNDS
;2 => DATA RCVD WHILE IN A NOT OPEN STATE
;3 => BBYTES COUNTED OUT WHILE PARSING A CNTL MSG
;4 => CANT FIND LOSR -GVB
;5 => DATA FOR NON-X USR
;6 => RRP RECEIVED WITHOUT HAVING SENT RST
;7 => XTRA RFNM
	; STORAGE

FIPARB:	L,,FIPARB		; NETWORK PARAMS FOR "NETWRK" START HERE.
	UNAME,,JNAME
	FISKT
	FILSKT,,FINSKT
	FIPQST
	FIERBK
	FIRSTT
FISKT:	BLOCK FILSKT*FINSKT	; SOCKET MAP -

	; +0=> 4.9 UFLS BIT
	;      4.8 ERROR BIT - NON FATAL
	;      4.7 FATAL ERROR
	;      4.6 UNIT ASCII 8 BIT BYTE
	;      4.5-1.1 HEADER
	; +1=> 4.9 INTERUPT BIT
	;      4.8 WRITE BIT
	;      4.7 ASCII BIT
	;      4.6 'ONED' BY CLOSE CODE WHEN ENTERED
	;      4.5-1.1 LOC SOC
	; +2=> 4.9 32 BIT MODE
	;      4.8 1 BIT BYTE FOR READ
	;      4.7 NON STANDARD BYTE SIZE (IMAGE)
	;      4.6 SET BY PI WHEN MSG WRAP OCCURS - SKIP 1 MSG ALLOC
	;      4.5-1.1 FOR SOC
	; +3=> LH STATE
	;      RH BUFR PNTR 
	; +4=> BIT ALLOC (WRITE)
	; +5=> LH CHANNEL
	;      RH USER
	; +6=> LH ERROR STATE
	;      RH MSG ALLOC (WRITE)
	; +7=> RH BYTE SIZE
	;      LH TEMP STORAGE FOR UUOs

FISKTB==.-1	;BOTTOM OF SOCKET TABLE




;	STATES
;0	CLOSED		FROM OUTSIDE. NO DATA
;1	LISTENING	WAITING FOR RFC
;2	RFC-RCVD	RFC RECEIVED IN RESPONSE TO A LISTEN. USER CAN DO A .NETAC,
;			.NETRE, OR A .CLOSE
;3	ABORT		RFC RCVD IN RESPONSE TO LISTEN, BUT CLS RCVD BEFORE USER
;			COULD DO A .NETAC  ONLY .NETRE OR .CLOSE CAN NOW BE USED.
;4	RFC-SENT	USER HAS DONE A .OPEN CAUSING AN RFC TO BE SENT.
;5	OPEN		CONNECTION IS OPEN, I/O MAY PROCEED.
;6	RFNM-WAIT	WRITE CONNECTION AWAITING RFNM ON ITS DATA LINK. IOT WILL
;			HANG UNTIL RFNM IS RCVD OR AN ERROR OCCURS (E.G. FOREIGN IMP DOWN)
;7	CLS-WAIT	USER HAS DONE A .CLOSE, AWAITING CORRESPONDING CLS OR TIME OUT.
;10	CLS-READ	CONNECTION CLOSED BUT DATA STILL PRESENT, EOF IN DATA STREAM
;11	DATA-PRESENT	OPEN READ CONNECTION. DATA AVAILABLE FOR READING.
;12
;13	FOR-HOST/IMP DEAD
	; NETWORK BUFFER CONTROL

NETRAC:	BLOCK NNETCH	; BUFFER STORAGE
	; 4.9 LOCKED BY CORE ALLOCATOR
	; 4.8 ACTIVE AT MPG LEVEL
	; 4.7 SIGNAL TO CORE ALLOCATOR TO INTERUPT WHEN
	;     DONE SHUFFELING THIS READ BUFFER
	; 4.6 SAME AS 4.7 BUT WRITE  BUFFERS
	; 3.1 ENTRY BEING USED
	; RH  IOBFT ADDRESS

FI32B:	0	; FLAG TO WRITE IN 32 0R 36 BIT MODE

FINMEM:	0	; FLAG FROM CORE ALLOCATOR THAT IT HAS CAUSED AN INT


FIORFC:	BLOCK 6	; SPACE FOR MAKING UP RFC AT MPG LEVEL
FIPRFC:	BLOCK 6	; AS FIO, BUT AT PI LEVEL

FI1ERR:	0	; COUNT OF CONTROL LINKERROR MSGS


FIBDLK:	0	; COUNT OF DATA MSGS WITH LOSR NOT FOUND

FIHSTT:	BLOCK FINHTT	; TABLE OF HOSTS YET TO RFNM ON CONTROL LINK

FIRSTT:	BLOCK 22.	;STATUS OF HOSTS 3 BITS EACH
			;STARTING WITH ZERO
			;0=> NO INFORMATION
			;1=> RST SENT
			;2=> UP

FIEND==.-1



FIWERR:	0	; WHICH ERROR MSG WE WANT SYS JOB TO PRINT
	0		; WHO
FIVERR:	0	; PROTOCOL ERROR NUMBER



FIFFM:	0	; 0=> NOT SET,   -1=> FLUSH INPUT MESSGE (FOR FIRST MSG)

NETRC:	NNETCH

NETNOP:	1
	10430,,1	; NOP MSG (HOST TO IMP)


FIFLSR:	0	; LAST LOSR - OFFSET IN FISKT
	; POINTS TO LOSER FOUND IN LEVEL 3 (PI) SEARCH

FINOPF:	0	; # OF NO OPS TO BE SENT


FIAZCT:	0	; STORAGE WORD FOR NETABI

NETSW:	-1	; SWITCH
	0

FIP6SV:	BLOCK 20	; SAVE ACS

FIPQFR:	FIPQ	; START OF FREE CHAIN FOR PENDING QUEUE
FICQFR:	FICQ	;                         CONTROL
FIKQFR:	FIKQ	;                         KLOCK
FIOQFR:	FIOQ	;                         OUTPUT

FIPQST:	0
FICQST:	0
FIKQST:	0
FIOQST:	0


FIPQ:	REPEAT FINPQ-1,[
	.+4
	BLOCK 3
]
	0
	BLOCK 3
FICQ:	REPEAT FINCQ-1,[
	.+7
	BLOCK 6
]
	0
	BLOCK 6
FIKQ:	REPEAT FINKQ-1,[
	.+5
	0
	-1
	JRST	FICLKQ
	0
]
	0
	0
	-1
	JRST	FICLKQ
	0
FIOQ:	REPEAT FINOQ-1,[
	.+2
	0
]
	BLOCK 2

FILLSR:	-1	; LAST LOSR TO DO OUTPUTING (-1 IF NONE)


FIPDSV:	0	; STORAGE FOR CORE ALLOC HANGAGE
FIPTSV:	0	; "

FIW15S:	-1	; FLAG TO WAIT 15 SECS FOR IMP
	0


FI1GBL:	0	;SET TO -1 TO INHIBIT 1 GARBLED LEADER MSG

NTCSTO:	60*15	; CLOSE TIME OUT  IN 60TH OF SEC

NTRSTO:	30*15	; RESET TIME OUT  IN 30TH OF SEC

NTRKTO:	30.*15.	; NO OF SECS BEFORE HOSST DEAD

FIBND:	-1	;0 =>BRING DOWN IF NO USERS
		;-1=>DONT BRING DOWN


FIERBK:	BLOCK 10	;FOR H-H PROTOCOL ERROR ANALYSIS


;DEMON TABLE FOR NETWORK - 2 WORD ENTRIES
FIDMTB:	1		;1st WORD IS LOCAL SOCKET TO WAKE UP ON
	SIXBIT/LOGGER/	;2nd WORD IS NAME OF DEMON
	3
	SIXBIT /FTPS/	;FILE TRANSFER PROTOCOL SERVER
	7
	SIXBIT /DEMECO/	;ECHOS CHARACERS SENT TO IT
	9.
	SIXBIT /DEMDSC/	;DISCARDS CHARACTERS SENT TO IT
	245.
	SIXBIT /IEC/	;INTER-ENTITY-COMMUNICATION
FIDMCT==<.-FIDMTB>/2	;LENGTH OF TABLE
	BLOCK 6
FIDMLS:	0		;COUNT OF TIMES THAT LOST DUE TO NO ROOM IN DEMTBL

FIRSTH:	0		;HOST TO BE RESET

FINUPY:	0	;NOT UP YET - SETOM BY FIINI - SETZM WHEN NOPs TAKEN

IFN FCNTEM,[
FRMSGS:	BLOCK 128.	;COUNT READ MESSAGES
FWMSGS:	BLOCK 128.	;COUNT WRITE MSGS
FRBITS:	BLOCK 256.	;COUNT READ BITS
FWBITS:	BLOCK 256.	;COUNT WRITE BITS
FCIMP:	BLOCK 15.	;COUNT IMP MESSAGES
]

FIPARE==.-1	; END OF NETWRK PARAMS AREA
;	BYTE POINTERS

FILINK:	101000,,FISKT(E)	;LINK POINTER
FIFHST:	201000,,FISKT(E)	;FOR HOST
FIMTYP:	300400,,FISKT(E)	;MSG TYPE
FILSOC:	  4000,,FISKT+1(E)	;LOC SOCKET
FILAEN:	  1000,,FISKT+1(E)	;LOC AEN
FILUSR:	103000,,FISKT+1(E)	;LOC USER
FIFSOC:	  4000,,FISKT+2(E)	;FOR SOCKET
FIFAEN:	  1000,,FISKT+2(E)	;FOR AEN
FIFUSR:	103000,,FISKT+2(E)	;FOR USER
FIUFLB:	430100,,FISKT(R)	;UFLS BIT
FIBRFC:	341000,,FIORFC+2


BBLK

;	NETWORK OPEN ROUTINE - NETOA
;A/ 1.1-1.8 FOR HOST, 1.9-4.5 HI ORDER 24 BIT OF LOC SOC IF NOT DEFAULT
;	4.8 MEANS 4.7-4.6 ARE HI 2 BITS OF LOW 8 BITS OF LOC SOC (A CROCK!)
;B/ 1.1-4.5 FOR SOC ID
;C/ MODE,,'DEV
;D/ MODE ROT -1
;I/ LOC SOC (LO 8 BITS)
;R/ IOCHNM ENTRY
;U/ USR
NETOA:	JUMPGE	A,.+3
	SETZM	J
	JRST	NETOA1
	LDB	J,[103000,,A]	;LOC LSR ID
	JUMPG	J,NETOA1	;NON-ZERO?
	LDB	J,[143000,,UNAME(U)]
NETOA1:	DPB	J,[103000,,I]	;I/LOC SOC ID
	TLNN	A,200000	;4.8?
	JRST	.+5		;NO
	TLNE	A,100000	;+200?
	TRO	I,200		;YES
	TLNE	A,40000		;+100?
	TRO	I,100
	SKIPN	FINCON
	JRST NETOA6
	MOVSI	E,-FINSKT	;LOOP THROUGH SOCKET TABLE
	LDB	J,[1000,,A]	;FOR HOST
NETOA2:	LDB	TT,FILSOC
	CAME	TT,I
	JRST	NETOA4	;NOT EQUAL
	JUMPG	J,NETOA3	;JUMP IF NOT A LISTEN
	HLRZ	TT,FISKT+3(E)	;STATE
	JFCL
;	CAIN	TT,1
	JRST	OPNL13		;ALREADY OPEN	
	JRST	NETOA4
NETOA3:	LDB	TT,FIFHST
	CAME	J,TT	;SAME?
	JRST	NETOA4	;NO
	LDB	TT,FIFSOC
	CAMN	TT,B	;SAME?
	JRST	OPNL13	;YES, ALREADY OPEN	
NETOA4:	ADDI	E,FILSKT-1
	AOBJN	E,NETOA2

;NOW TEST GENDER OF SOC
	MOVE	J,I
	ROT	J,-1	;J/NEG IF SOC # ODD
	JUMPL	D,NETOA5	;JUMP IF WRITE CHNL
	JUMPGE	J,NETOA6	;JUMP IF READ SOC
	JRST	OPNL2		;WRONG SEX	
NETOA5:	SKIPL	J
	JRST	OPNL2		;WRONG SEX	
NETOA6:	SKIPN	FINCON		;NETWORK ENABLED?
	JRST	NETA2		;NO, GO DO IT
	PUSHJ	P,NETA3	;SEE IF ANY STATE 4S
	JRST	NETO15

;DON'T PUT ANYTHING HERE 'CAUSE NETA2 RETURNS TO NETA1

;NOW GET SOME MEM
;W/CHNL		Q/ADDR
NETA1:	SKIPE	FINUPY		;WAIT TIL IMP THINKS WERE UP
	PUSHJ	P,UFLS
	LDB	H,[1000,,A]
	SKIPG	H		; HOST=0, NO RESETS (LISTEN)
	JRST	NETAR		; SKIP RESET STUFF
	PUSHJ	P,FISRST	; RESET RELATED
	JRST	OPNL20		; OPEN ERROR
	JRST	OPNL4		; HOST DEAD
NETAR:	PUSH	P,A
	PUSH	P,D
	PUSHJ	P,FIGBUF
	PUSHJ	P,FIWMEM
	MOVE	Q,A
	MOVE	W,D
	POP	P,D
	POP	P,A
NETOA7:	PUSHJ	P,SWTL		;GOBBLE SWITCH
	NETSW
	SETZM	E		;TEMP AC
NETOA8:	SKIPN	FISKT+5(E)	;IS USER NO WORD 0
	JRST	NETOA9		;YES, EMPTY SLOT
	ADDI	E,FILSKT		;NO, CHECK NEXT
	CAIGE	E,FINSKT*FILSKT	;END OF TABLE?
	JRST	NETOA8		;NO, LOOP
	JRST	NTOADF		;YES, DEVICE FULL
NETOA9:	HRLM	E,(R)		;SAVE OFFSET INTO SOCKET MAP
;E/ FISKT ENTRY
	DPB	I,FILSOC
	DPB	A,FIFHST
	DPB	B,FIFSOC
	MOVSI	TT,400000
	CAMN	D,[400000,,1]	;ABO?
	IORM	TT,FISKT+2(E)	;YES, SET 32 BIT BIT
	SETZM	FISKT+4(E)	;
  ;NON STANDARD BYTE SIZE?
	TRNN	D,2	;IMAGE?
	JRST	NETA6	;NO
	TRNE	D,4	;BYTE SIZE BIT?
	JRST	.+4	;YES
	MOVEI	TT,36.	;NO - BYTE SIZE IS 36.
	HRRM	TT,FISKT+7(E)
	JRST	NETA4
	MOVSI	TT,300000	;YES
	IORM	TT,FISKT+2(E)	;MARK IT AND 1 BIT BYTE
	LDB	TT,[300600,,C]	;BYTE SIZE
	SKIPE	TT		;MAY NOT BE ZERO
	CAILE	TT,36.		;OR GREATER THAN 36.
	JRST	NTOBBS		;BAD_BYTE_SIZE
	HRRM	TT,FISKT+7(E)	;STORE IT
  ;ANY ASCII INPUT?
NETA4:	MOVSI	TT,400000	;4.9 BIT IS 32 BIT READ-IN
	JUMPL	D,.+3
	TRNN	D,2
	IORM	TT,FISKT+2(E)	;YES
	MOVSI	TT,100000
	TRNN	D,2		;SKIP IF NOT ASCII
	IORM	TT,FISKT+1(E)
	JUMPGE	D,NETO10	;JUMP IF READ

;WRITE
	MOVSI	TT,200000
	IORM	TT,FISKT+1(E)	;SET WRITE BIT
	SETZM	FISKT+6(E)	;ERROR AND MSG ALLOC
	HRRM	W,FISKT+3(E)	;BUFR
	SETZM	FISKT+4(E)
	JRST	NETO11

;READ
NETO10:	HRRM	W,FISKT+3(E)	;INPUT BUF
	MOVSI	TT,-1
	MOVEM	TT,(Q)	;RING BUF PNTR
	SETZM	FISKT+4(E)
	SETZM	FISKT+6(E)	;ERROR

;BOTH
NETO11:	MOVE	TT,R
	SUBI	TT,IOCHNM(U)	;TT/CHNL
	HRLM	TT,FISKT+5(E)
	HRRM	U,FISKT+5(E)
	LDB	T,FIFHST
	JUMPG	T,NETO12
;LISTENING
	PUSHJ	P,ANETR2	;CHECK PENDING QUEUE
	JRST	NETO14

;INITIATE CONTACT
NETO12:	JUMPL	D,.+3
	PUSHJ	P,FIMRTS
	JRST	NETO13
	PUSHJ	P,FIMSTR
	JRST	NETO13

NETO13:	MOVEI	TT,4
	HRLM	TT,FISKT+3(E)	;STATE 4
	MOVEI	W,FIORFC
	CONO	PI,NETOFF
	PUSHJ	P,FICQI
	JRST	NTOIDF
	CONO	PI,NETON
	PUSHJ	P,FISTRT
	CONO	PI,NETOFF	;TURN OFF INTERRUPTS
	LDB	B,FIFSOC	;MAKE SURE HI 4 BITS ARE OFF
	PUSHJ	P,FISPQ		;ALREADY HERE?
	JRST	NETO17	;NO
	MOVEI	TT,5
	HRLM	TT,FISKT+3(E)
	JUMPGE	D,NETO18	;JUMP IF READ
	HLRZ	TT,3(T)	;LINK
	DPB	TT,FILINK
	JRST	NETO17
NETO16:	PUSH	P,R
	MOVEI	W,FIBITS
	MOVEI	R,FIMSGS
	LDB	Q,FILINK	;LINK
	LDB	H,FIFHST	;FOR HOST
	PUSHJ	P,FISALL
	POP	P,R
NETO14:	PUSHJ	P,LSWPOP	;RELEASE SWITCH
	HLRS	A,C		;SAVE MODE FOR .STATUS
	JSP	Q,NETA5		;SET UP IOCHNM AND EXIT
	NTAUI,,NTAUO
	NTABI,,NTABO
	NTIUI,,NTIUO
	NTIBI,,NTIBO

NETA6:	MOVEI	TT,8.	;ASCII BYTE SIZE IS 8
	HRRM	TT,FISKT+7(E)
	MOVSI	TT,40000
	TRNE	D,3	;ASCII UNIT?
	JRST	NETA4	;NO
	TRNE	D,4	;BYTE SIZE BIT?
	IORM	TT,FISKT(E)	;YES, SET 8 BIT ASCII BIT
	JRST	NETA4

NTOIDF:	CONO	PI,NETON
	HRRZ	D,FISKT+3(E)	;BUF CHNL
	JRST	.+2
NTOADF:	MOVE	D,W
	PUSHJ	P,LSWPOP
	SKIPLE	NETRAC(D)
	PUSHJ	P,FIFBUF
	JRST	OPNL6

NTOBBS:	MOVE	D,W		;BAD BYTE SIZE
	PUSHJ	P,LSWPOP
	SKIPLE	NETRAC(D)
	PUSHJ	P,FIFBUF
	JRST	OPNL22

NETO17:	CONO	PI,NETON
	JRST	NETO14

NETO18:	CONO	PI,NETON
	JRST	NETO16

NTODF1:	PUSHJ	P,LSWPOP
	JRST	OPNL6

;
;
;	OPEN
;
NETA5:	ANDI	C,7
	ROT	C,-1
	ADDI	C,(Q)
	HRR	A,(C)
	SKIPL	C
	HLR	A,(C)	
	HRRM	A,(R)
	JRST	CLKOJ1

NETIUI:	JRST IOCER4



;HERE IF STATE 4S
NETO15:	PUSHJ	P,FIINI
	JRST	OPNL7
	SETOM	FI1GBL
	JRST	NETA1


;	THIS ROUTINE TEST FIICON AND FIOCON AND RETURNS
;	IT SKIPS IF NEITHER IS IN STATE 4
;	IT DOESN'T SKIP IF EITHER IS IN STATE 4
;
NETA3:	MOVE	TT,FIICON
	CAIN	TT,4
	JRST	NTOA3A
	MOVE	TT,FIOCON
	CAIN	TT,4
	JRST	NTOA3A
	AOS	(P)
NTOA3A:	POPJ	P,


;	THIS ROUTINE REINITIALIZES THE IMP INTERFACE
;
NETA2:	PUSHJ	P,FIINIW	;THE WORLD
	JRST	OPNL7		;ERROR
	PUSH	P,A
	PUSHJ	P,FIGET	;INACTIVE TO LISTENING
	POP	P,A
	PUSHJ	P,NETA3
	JRST	OPNL7
	JRST	NETA1
	; BRING UP WORLD - WONT CRY IF LOSES

NETUP:	PUSH	P,T
	PUSH	P,TT
	PUSHJ	P,FIINIW
	JRST	NETUP1
	PUSH	P,A
	PUSHJ	P,FIGET		;GO TO LISTENING
	POP	P,A
NETUP1:	POP	P,TT
	JRST	POPTJ

	; NETWORK CLOSE ROUTINE
;
;A/ STATE
;E/ LH OF IOCHNM (OFFSET IN FISKT)
NETCLS:	MOVE	E,A
NTCLSA:
IFN NCPDBG,[
	MOVSI	D,40000
	IORM	D,FISKT+1(E)
	HRRZ	D,FISKT+3(E)	;NETRAC
	HLRZ	TT,FISKT+3(E)	;STATE
	SKIPE	NETRAC(D)	;DONT FOOL WITH ALREADY ZEROED ENTRY
	DPB	TT,[300600,,NETRAC(D)]
]
	HRRZ	TT,FISKT+5(E)	;USR OF THIS SOC
	HRRZ	A,U		;USR NOW RUNNING
	CAME	A,TT		;SAME
	JRST	NTCLS7		;NO, MUST HAVE BEEN PC-LOSRED
	HLRZ	A,FISKT+3(E)	;STATE
	CAILE	A,13
	JRST	4,CPOPJ	;STATE WAS >13
	JRST	@.+1(A)
	NTCLS1	;0
	NTCLS1	;1
	NTCLS2	;2	WAS CLS2
	NTCLS1	;3
	NTCLS2	;4	WAS CLS2
	NTCLS2	;5	WAS CLS2
	NTCLS6	;6
	CPOPJ	;7
	NTCLS1	;10
	NTCLS2	;11	WAS CLS2
	CPOPJ	;12
	NTCLS1	;13
	; IF READ - FREE BUFR
;FLUSH ANY ENTRIES IN PENDING QUEUE
;KILL SOCKET
NTCLS1:	PUSHJ	P,NTCLS4	;DO IT
	JRST	NTCS1D

NTCLS4:	MOVE	TT,FISKT+1(E)	;? NEEDED ?
	LSH	TT,1	;? NEEDED ?
	HRRZ	D,FISKT+3(E)	;NETTRAC INDEX
	MOVE	T,D
	PUSHJ	P,NTCS4A	;WAIT FOR BUFFER TO BE UNLOCKED
	PUSHJ	P,UFLS
	PUSHJ	P,FICOMF	;AVOID EMBARASSMENT
	HRRZ	TT,D
	SKIPLE	NETRAC(D)	;DON'T FREE A ZERO BUFFER
	PUSHJ	P,FIFBUF	;FREE THIS BUFFER
	JRST	NTCS1B

NTCS1A:	MOVE	R,FILLSR	;LAST LOSR
	CAMN	E,R
	SETOM	FILLSR

;FLUSH PENDING QUEUE
NTCS1B:	LDB	TT,FILSOC
;	PUSHJ	P,FIFPQ		NOT SURE I WANT THIS
	POPJ	P,	;NONE
NTCS1C:	MOVE	W,T
	PUSHJ	P,FIPCL1	;SEND CLS
   ;IF I=-1, NO ROOM IN FICQ
	JUMPGE	I,.+4	;MORE ROOM?
	SKIPG	FICQFR		;WAIT FOR ROOM
	PUSHJ	P,UFLS
	JRST	NTCS1C
	POPJ	P,

NTCS1D:	MOVE	T,E	;INDEX
;	PUSHJ	P,FIKRST	;KILL HOST?
	MOVEI	TT,FILSKT	;# WORDS TO BOMB
	SETZM	FISKT(T)
	AOS	T
	SOJG	TT,.-2

	IFN NCPDBG,[
	PUSH	P,E
	IDIVI	E,FILSKT
	SETZM	FDRFTS(E)	; CLEAR RFNM STATE
	POP	P,E
	]

NTCS1E:	SKIPE	FIBND			;DO WE WANT NCP DOWN IF POSSIBLE?
	POPJ	P,			;NO
	MOVSI	TT,-FINSKT*FILSKT	;LOOP TO SEE IF SOC MAP EMPTY
	SKIPE	FISKT(TT)	;IS THIS EMPTY?
	POPJ	P,		;NO, SOMETHING NOT EMPTY
	AOBJN	TT,.-2		;YES
	PUSHJ	P,FIFIN
	POPJ	P,

;GO TO STATE 7 AND SEND OUT A CLS
NTCLS2:	MOVEI	TT,7
	HRLM	TT,FISKT+3(E)	;STATE 7
	PUSHJ	P,NTCLS5	;TIME OUT
	MOVE	T,E
	PUSHJ	P,NTCLS4
	PUSHJ	P,FIMCLS	;GET A CLS
	PUSHJ	P,FICQW		;SEND IT
	MOVE	T,E		;LOSR INDEX
	HRL	T,U		;LOSR NUMBER
	PUSHJ	P,FICSTS	;HANG TIL THEY ARE DIFFERENT
	PUSHJ	P,UFLS
NTCLS7:	MOVE	TT,E		;TT/LOSR - ARGUMENT FOR FIFKQ
	PUSHJ	P,FIFKQ		;REMOVE ENTRY FROM CLOCK Q - IF STILL THERE
	FICLKQ			;ARGUMENT FOR FIFKQ
	POPJ	P,		;NOT THERE, WAS TIMED OUT
	PUSHJ	P,CLQDEL	;NOW REMOVE IT
	1(T)
	POPJ	P,

;SEND A CLS	CLOSE SOCKET
NTCLS3:	PUSHJ	P,FIMCLS	;GET A CLS
	PUSHJ	P,FICQW	;SEND IT OUT
	JRST	NTCLS1		;FLUSH SOC
	; TIME OUT - TIME IN NTCSTO IN 60TH OF A SEC

NTCLS5:	PUSHJ	P,FIKQI	;GET A BLOCK
	JRST	NTCS5A
	AOS	C,TT	;1ST USEFUL WD
	MOVE	C,[JRST FICLKQ]
	MOVEM	C,2(TT)
	MOVEM	E,3(TT)
	MOVE	T,NTCSTO	;TIME
	PUSH	P,E
	PUSHJ	P,CLQADD
	(TT)
	JRST	POPEJ

NTCS5A:	SKIPG	FIKQFR
	PUSHJ	P,UFLS
	JRST	NTCLS5

FICSTS:	PUSH	P,A
	PUSH	P,B
	HLRZ	A,T	;OLD USR
	HRRZ	B,FISKT+5(T)	;NEW USR (IF ANY)
	CAME	A,B	;IS THIS SOCKET GONE YET?
	AOS	-2(P)	;YES, SKIP
	POP	P,B
	JRST	POPAJ

;DONT SKIP IF 4.9 AND (NOT 4.8)
NTCS4A:	PUSH	P,A
	MOVE	A,NETRAC(T)
	JUMPGE	A,POPAJ1
	TLNE	A,200000
	AOS	-1(P)
	JRST	POPAJ

;LSR IN RFNM_WAIT
NTCLS6:	PUSHJ	P,FIKQI	;GET A BLOCK IN CLOCK QUEUE
	JRST	NTCS6A	;FULL - WAIT FOR ONE
	AOS	C,TT	;FIRST USABLE SLOT
	MOVE	C,[JRST FICLKR]	;WHERE WE WANT TO GO
	MOVEM	C,2(TT)
	MOVEM	E,3(TT)	;LOSR
	MOVE	T,NTCSTO	;WAITING TIME
	PUSH	P,E
	PUSHJ	P,CLQADD
	(TT)
	POP	P,E
	MOVEI	T,6	;RFNM_WAIT
	HRL	T,E	;LOSR
	SETZM	EPDL(U)		;WAIT FOREVER
	PUSHJ	P,ANTBL2	;SKIPS WHEN NO LONGER IN STATE 6
	PUSHJ	P,UFLS		;THIS CALL USED TO BE TO ANETB1
	MOVE	TT,E
	PUSHJ	P,FIFKQ	;TAKE OUT OF NCP CLOCK Q - IF STILL THERE
	FICLKR		;ARGUMENT FOR FIFKQ
	JRST	NTCLSA	;NOT THERE
	PUSHJ	P,CLQDEL	;REMOVE FROM SYSTEM CLK QUEUE
	1(T)
	JRST	NTCLSA
î
;TIME OUT ON RFNM_WAIT
FICLKR:	PUSH	P,E
	PUSH	P,TT
	PUSH	P,T
	PUSHJ	P,FISKQ	;FIND THE NOW IDLE BLOCK
	JRST	FICKR1	;CANT
	MOVE	E,4(T)	;LOSR
	HLRZ	TT,FISKT+3(E)	;STATE
	CAIE	TT,6	;STILL IN RFNM WAIT?
	JRST	FICKR1	;NO
	MOVEI	TT,5	;PRETEND HE GOT ONE
	HRLM	TT,FISKT+3(E)
FICKR1:	POP	P,T
	POP	P,TT
	POP	P,E
	JRST	CLQRET

NTCS6A:	SKIPG	FIKQFR
	PUSHJ	P,UFLS
	JRST	NTCLS6
NETCLK:	POPJ	P,	;DUMMY CALL


;INIT THE WORLD - SKIPS IF WINS
FIINIW:	PUSHJ	P,FIINI
	POPJ	P,
	SETOM	FI1GBL		;INHIBIT 1ST GARBLED LEADER

	PUSHJ	P,FIZBUF
	SETZM	FISKT
	MOVE	0,[FISKT,,FISKT+1]
	BLT	0,FIEND
	SETOM	FILLSR

	MOVEI	0,NNETCH
	MOVEM	0,NETRC
	PUSHJ	P,FINTPQ
	PUSHJ	P,FINTCQ
	AOS	(P)
	POPJ	P,


;INIT THE QUEUES
FINTPQ:	MOVSI	T,-FINPQ+1
	MOVEI	TT,FIPQ
	MOVEM	TT,FIPQFR
FINPQ1:	ADDI	TT,4
	MOVEM	TT,FIPQ(T)
	ADDI	T,3
	AOBJN	T,FINPQ1
	SETZM	FIPQ(T)
	SETZM	FIPQST
	POPJ	P,



FINTCQ:	MOVSI	T,-FINCQ+1
	MOVEI	TT,FICQ
	MOVEM	TT,FICQFR
FINCQ1:	ADDI	TT,7
	MOVEM	TT,FICQ(T)
	ADDI	T,6
	AOBJN	T,FINCQ1
	SETZM	FICQ(T)
	SETZM	FICQST
	POPJ	P,




;CAUSE IOCER - LOSR IN A
FIOCER:	HLRZ	TT,FISKT+6(A)	;ERROR STATE
	JRST	IOCERX+1
;
;	FREE A BUFFER
;
;CALL WITH CHNL IN D
FIFBUF:	PUSHJ	P,SWTL
	NETSW
	PUSHJ	P,FIIFBF
	PUSHJ	P,LSWPOP
	POPJ	P,
;
FIIFBF:	PUSH	P,A
	HRRZ	A,NETRAC(D)
	CONSO	PI,77400	;SKIP IF PI IN PROGRESS
	JRST	FIIFB1
	CONO	PI,UTCOFF-1	;DONT DISTURB PI 7 WHOSE STATUS IS UNKNOWN
	PUSHJ	P,IBRTN
	CONO	PI,UTCON-1
	SKIPA
FIIFB1:	PUSHJ	P,BRTN
	SETZM	NETRAC(D)
	AOS	NETRC
	POP	P,A
	POPJ	P,



;
;	NEW GET A BUFFER
;
;CHNL OUT IN D, MEMORY ADDR IN A
;	SKIPS IF WINS
;	IF LOSES, NO CHANNELS - A=-1
;	          NO BUFFERS  - A=0
;
FIGBUF:	PUSH	P,T
	PUSHJ	P,SWTL
	NETSW
	PUSHJ	P,FIIGBF
	JRST	FIGBF5
	PUSHJ	P,LSWPOP
	AOS	-1(P)
	JRST	POPTJ
FIGBF5:	PUSHJ	P,LSWPOP
	JRST	POPTJ
;
;
FIIGBF:	PUSH	P,B
	PUSH	P,E
	PUSH	P,TT
	SKIPG	NETRC	;ANY LEFT
	JRST	FIGBF4	;NO
	MOVSI	D,-NNETCH
	SKIPN	NETRAC(D)	;IS THIS A FREE ENTRY?
	JRST	FIGBF1		;YES
	AOBJN	D,.-2		;LOOP
FIGBF4:	SETOM	A		;INDICATE NO CHANNELS
	JRST	FIGBF3	;ERROR
FIGBF1:	PUSH	P,D
	ADDI	D,NUTIC+NUTOC+NCLCH+1
	PUSHJ	P,TCALL		;GET A BUFFER
	JRST	IUTCONS
	JRST	FIGBF2		;NO BUFFERS
	POP	P,D
	MOVEM	A,NETRAC(D)	;STORE BUFFER ID
	MOVSI	TT,1
	IORM	TT,NETRAC(D)	;MARK IT ACTIVE
	LDB	A,[IOSA,,IOBFT(A)]	;GET REAL MEM BLOCK
	LSH	A,6		;GET REAL MEM ADDR
	HRRZS	D
	SOS	NETRC
	AOS	-3(P)		;SKIP
	JRST	.+3
FIGBF2:	SETZM	A		;INDICATE NO MEM
	POP	P,D
FIGBF3:	POP	P,TT
	POP	P,E
	POP	P,B
	POPJ	P,

;ROUTINE TO FREE ALL UNLOCKED BUFFERS
FIZBUF:	PUSH	P,D
	PUSH	P,T
	MOVSI	T,-NNETCH
FIZBF1:	HRRZ	D,T
	PUSHJ	P,FICOMT
	JRST	FIZBF2
	PUSHJ	P,FICOMF
	SKIPE	NETRAC(D)
	PUSHJ	P,FIIFBF
FIZBF2:	AOBJN	T,FIZBF1
	POP	P,T
POPDJ:	POP	P,D
	POPJ	P,




;MEMORY HANG
;IF A=-1, HANGS ON NETRC
;IF A=0,  HANGS ON FIWBUF
;***** DOES A SOS (P) ON RETURN! *****
FIWMEM:JUMPL	A,FIWMM1
	PUSHJ	P,FIWBUF
	PUSHJ	P,UFLS
	JRST	FIWMM2
FIWMM1:	SKIPG	NETRC
	PUSHJ	P,UFLS
FIWMM2:	SOS	(P)
	SOS	(P)
	POPJ	P,


;THIS ROUTINE WITH W/PNTR TO A PENDING Q BLOCK,
;SENDS A CLS
FIPCL1:	PUSH	P,I
	PUSH	P,FIPCL2
	PUSH	P,W
	JRST	FIPQR1
POPIJ:	POP	P,I
FIPCL2:	POPJ	P,POPIJ



;
;	FISTRT - TO START UP WRITING

FISTRT:	SKIPN	FINCON
	POPJ	P,
	CONO	PI,NETOFF
	SKIPN	FIOCON	;ACTIVE NOW?
	CONO	FI,FIOUT+FIINIT	;NO, SET DONE (CAUSE INTERUPT)
	CONO	PI,NETON
	POPJ	P,


;TEST ROUTINE TO WAIT FOR RFNM - IF APPLICABLE
FIOTST:	MOVE	T,R
	HLRZ	TT,FISKT+3(R)	;THIS LOSER'S STATE
	JUMPE	TT,CPOPJ	;A WRITE IN STATE 0 IS ILLEGAL - DO A NO_SKIP RETURN
	PUSHJ	P,FIOTS1	;NOT STATE 6?
	PUSHJ	P,UFLS
	HLRZ	TT,FISKT+3(R)	;STATE
	JUMPE	TT,CPOPJ	;ONLY STATES 1, 2, 4, AND 5 AREVALID
	CAIG	TT,5
	CAIN	TT,3
	POPJ	P,
IFN NCPDBG,[
	PUSH	P,R
	PUSH	P,W
	IDIVI	R,FILSKT	;POSITION IN FISKT (1,2,3, ETC.)
	SKIPE	FDRFTS(R)	;SKIP IF NO OUTSTANDING RFNMs
	JRST	4,.+1	;OOPS  TRYING TO OUTPUT A MSG ON A BLOCKED LINK
	POP	P,W
	POP	P,R
]
	MOVE	TT,FISKT(R)	;SEE WHAT WE GOT
	TLZ	TT,400000	;TURN OFF UFLS FLAG
	TLZN	TT,200000	;ALSO GET AN ERROR?
	AOS	(P)	;NO - WILL SKIP
	MOVEM	TT,FISKT(R)	;RESTORE WORD
	POPJ	P,



FIOTS1:	PUSH	P,A	;SKIP IF NOT IN STATE 6
	HLRZ	A,FISKT+3(T)	;STATE
	CAIE	A,6
	AOS	-1(P)
	JRST	POPAJ
;
;	NETAUO
;
;	A/ MEMPNTR
;	C/ IOT PNTR
;	D/ CHNL
;	R/LOSR

NETAUO:	MOVE	T,A
	MOVE	R,A	;NEED A FOR BUFR PNTR
	PUSHJ	P,FIOTST	;WAIT FOR NOT RFNM-WAIT
	JRST	IOCER9
	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIWAL3
	PUSHJ	P,UFLS
	PUSHJ	P,FICOMO
	LDB	B,[4000,,FISKT(R)]	;LEADER
	LSH	B,4
	MOVEM	B,1(A)
	MOVEI	B,3
	MOVEM	B,(A)
	MOVE	B,[1000,,400]	;1 BYTE, 8 BITS
	MOVEM	B,2(A)
	XCTR XR,[MOVE B,(C)]
	ANDI B,377		;GET 8 BIT BYTE
	MOVE	TT,FISKT(R)
	TLNN	TT,40000	;8 BIT BYTE?
	TRZ	B,200		;NO 7 BIT BYTE
	DPB	B,[341000,,3(A)]
	PUSHJ	P,FICOMF
	PUSHJ	P,FIWQI	;PUT IT IN WRITE QUEUE
	JRST	IOCER9	;NO ROOM
	SOS	FISKT+6(T)
	MOVNI	TT,8.
	ADDM	TT,FISKT+4(T)
	POPJ	P,	;RETURN

;HERE TO WAIT FOR ALLOC TO BE: >=8BITS  >=1MSG
FIWAL3:	PUSH	P,TT
	MOVE	TT,FISKT+4(T)	;BIT ALLOC
	CAIGE	TT,8.
	JRST	POPTTJ
	HRRZ	TT,FISKT+6(T)	;MSG ALLOC
	SKIPLE	TT
	AOS	-1(P)
	JRST	POPTTJ
;
;	NETIUO
;
;	A/ MEMPNTR
;C/ IOT PNTR
;	D/ CHNL
;	R/LOSR

NETIUO:	MOVE	T,A
	MOVE	R,A	;NEED A FOR BUFR PNTR
	PUSHJ	P,FIOTST	;WAIT FOR NOT RFNM-WAIT
	JRST	IOCER9
	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIWAL1
	PUSHJ	P,UFLS
	PUSHJ	P,FICOMO
	MOVEI	B,3
	MOVEM	B,(A)
	LDB	B,[4000,,FISKT(R)]	;LEADER
	LSH	B,4
	MOVEM	B,1(A)
	MOVE	B,[4400,,400]	;1 BYTE, 36 BITS
	MOVEM	B,2(A)
	XCTR XR,[MOVE	B,(C)]
	MOVEM	B,3(A)
	PUSHJ	P,FICOMF
	PUSHJ	P,FIWQI	;PUT IT IN WRITE QUEUE
	JRST	IOCER9	;NO ROOM
	MOVNI	TT,36.
	ADDM	TT,FISKT+4(R)
	SOS	FISKT+6(R)
	POPJ	P,	;RETURN


;
; IOT - IMAGE,BLOCK,OUTPUT
;WILL BE: E/WORDS TO OUTPUT	H/BYTE SIZE
;
NETIBO:	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIPROT	;PROTECT
	JRST	IOADC		;LOST
	MOVE	R,A		;R/ OFFSET INTO FISKT
	MOVE	T,A	;FOR UFLS
NTIBO1:	XCTR XRW,[MOVES J,(C)]	;FETCH -N,,ADR
	HLRES	J		;MAKE -N
	JUMPGE	J,CPOPJ		;EXIT IF COUNT DONE
	PUSHJ	P,FIOTST	;WAIT FOR NOT RFNM-WAIT
	JRST	IOCER9
	HRRZ	H,FISKT+7(R)	;BYTE SIZE
	MOVNS	TT,J
	PUSHJ	P,NTIBOA	;REDUCE MSG
	PUSHJ	P,NTIBOB
	PUSHJ	P,FICOMO
	LDB	B,[4000,,FISKT(R)]	;LEADER
	LSH	B,4
	MOVEM	B,1(A)
	MOVE	B,J	;# WDS TO OUTPUT
	LSH	B,8.
	MOVE	TT,H	;BYTE SIZE
	DPB	TT,[301000,,B]
	MOVEM	B,2(A)
	MOVE	W,J
	MOVE	TT,FISKT+2(R)
	TLNE	TT,100000	;IS BIT ON?
	JRST	NTIBO2
	ADDI	J,2	;ACTUAL # TO GO OUT
	MOVEM	J,(A)
	ADD	J,A	;J/PNTR TO LAST ADDR TO BE USED
	XCTR XR,[MOVS TT,(C)]	;TT/ USR LOC,,xxx (FROM)
	HRR	TT,A	;'TO'
	ADDI	TT,3	;COUNT+LEADER+EXLEADER
	XCTR XR,[BLT TT,(J)]
NTIBO4:	PUSHJ	P,FICOMF
	PUSHJ	P,FIWQI
	JRST	IOCER9
	MOVE	TT,W
	PUSHJ	P,FIFIXL
	IMUL	TT,H	;# BITS TO OUTPUT
	MOVNS	TT
	ADDM	TT,FISKT+4(R)	;FIX ALLOCATE
	SOS	FISKT+6(R)
	JRST	NTIBO1
	; HERE IF MSG > ALLOC

NTIBOA:	PUSHJ	P,FIWAL1	;WAIT FOR ALLOC >(BYTE SIZE) BITS
	PUSHJ	P,UFLS
	MOVE	TT,J
	IMUL	TT,H	;# WE WANT TO SEND OUT
	CAMG	TT,FISKT+4(R)
	POPJ	P,
	MOVE	TT,FISKT+4(T)
	IDIV	TT,H		;TT/WHOLE WDS AVAIL
	SUB	J,TT		;J/ WDS LEFT OVER
	SUB	Q,J		;Q/TOTAL WDS LEFT OVER (NEG)
	MOVE	J,TT
	POPJ	P,

	; HERE TO WAIT FOR ALLOC TO BE > 36. BITS  MSGS>=1

FIWAL1:	PUSH	P,TT
	PUSH	P,H
	HRRZ	H,FISKT+7(T)	; FOO! BYTE SIZE NO DOUBT
	HRRZ	TT,FISKT+6(T)	;MSGS
	JUMPLE	TT,FIWL1A
	MOVE	TT,FISKT+4(T)	;ALLOC
	CAML	TT,H
	AOS	-2(P)
FIWL1A:	POP	P,H
	JRST	POPTTJ


;J=W=WD CNT=BUFR CNT
NTIBO2:	MOVE	TT,J
	IMUL	TT,H
	PUSH	P,TT
	IDIVI	TT,36.	;# WDS WILL OCCUPY
	SKIPE	I	;REMAINDER?
	AOS	TT	;YES
	ADDI	TT,2	;+COUNT+LEADER(2)
	MOVEM	TT,(A)
	POP	P,TT
	MOVE	I,TT	;BIT CNT
;E/USR PNTR     Q/BUFR PNTR
	XCTR XR,[HRRZ	E,(C)]
	PUSH	P,J	;SAVE COUNT
NTIBO3:	MOVN	I,H		;BITS IN BYTE
	XCTR XR,[MOVE TT,(E)]	;FETCH USER WORD WITH BYTE
	ROT	TT,(I)		;ROTATE RRIGHT, AROUND TO HIGH END
	ROT	TT,1		;ROTATE ONE BIT IN
	IDPB	TT,Q		;STASH IN OUT BUFFER
	AOJL	I,.-2		;LOOP ON BITS IN BYTE
	SOJG	J,NTIBO3	;LOOP ON BYTES FOR USER
	POP	P,J		;RESTORE COUNT
	JRST	NTIBO4



NTIBOB:	MOVE	TT,J
	IMUL	TT,H		;# BITS TO GO OUT
	CAIG	TT,125.*36.	;WILL FIT IN ONE BUF?
	POPJ	P,		;YES
	MOVEI	TT,125.*36.
	IDIV	TT,H		;ONLY SSEND OUT THE # OF BYTES THAT WILL FIT
	MOVE	J,TT
	POPJ	P,



;
;  NETABO
;
; A/ MEM PNTR
; C/ IOT PNTR
; D/ NETRAC CHNL
; E/ DATA PNTR
; R/ LOSER
;LEADER WILL BE SETUP IN 32 BIT MODE

NETABO:	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIPROT	;PROTECT
	JRST	IOADC	;MPV
	MOVE	R,A	;NEED A FOR MEM PNTR
	MOVE	T,A	;FOR UFLS
NTABO1:	XCTR XR,[HLRE	J,(C)]	;NEG COUNT
	SKIPL	J		;ANY MORE TO DO?
	POPJ	P,		;NO GO AWAY
	PUSHJ	P,FIOTST	;WAIT FOR NOT RFNM-WAIT
	JRST	IOCER9
	MOVNS	TT,J	;POS COUNT
	PUSHJ	P,NTABOA
	CAILE	J,100.	;COMPARE W/BUFR
	MOVEI	J,100.
	PUSHJ	P,FICOMO
	LDB	B,[4000,,FISKT(R)]	;LEADER
	LSH	B,4
	MOVEM	B,1(A)
	MOVE	E,J	;WDS
	IMULI	E,5	;CHARS
	AOS	E	;FOR BYTE OF EX-LEADER STICKING INTO MSG
	IDIVI	E,4	;REAL WDS
	SKIPE	TT
	AOS	E
	ADDI	E,2	;FOR LEADER
	MOVEM	E,(A)
	MOVE	B,J
	IMULI	B,5	;CHARS
	LSH	B,4.
	MOVEI	TT,8.
	DPB	TT,[241000,,B]
	MOVEM	B,2(A)
	XCTR XR,[HRRZ	E,(C)]
	PUSH	P,J		;SAVE IT
	MOVE	T,[341000,,3(A)]	;GET PTR TO OUT BUF
NTABO2:	XCTR XR,[MOVE H,(E)]	;GET WORD OF CHARS
	MOVE	TT,[440700,,H]	;BYT PTR TO AC
NTABO3:	ILDB	B,TT	;GET BYTE
	IDPB	B,T	;STASH BYTE
	TLNE	TT,760000	;POINTER AT END OF WORD?
	JRST	NTABO3	;NO, LOOP THRU 5 OF THEM
	SOJG	J,NTABO2	;LOOP THRU ALL WORDS
	POP	P,J		;RESTORE COUNT
	PUSHJ	P,FICOMF
	PUSHJ	P,FIWQI
	JRST	IOCER9	;NO ROOM IN Q
	MOVE	TT,J
	PUSHJ	P,FIFIXL	;FIX UP LOSR
	IMULI	TT,40.	;BITS
	MOVNS	TT
	ADDM	TT,FISKT+4(R)	;ALLOC
	SOS	FISKT+6(R)
	JRST	NTABO1



;HERE IF MSG>ALLOC
NTABOA:	PUSHJ	P,FIWAL2	;WAIT FOR ALLOC>40. BITS, MSG>=1
	PUSHJ	P,UFLS
	MOVE	TT,J
	IMULI	TT,40.	;# WANT TO SEND OUT
	CAMG	TT,FISKT+4(R)
	POPJ	P,
	MOVE	TT,FISKT+4(T)	;BITS
	IDIVI	TT,40.	;TT/WHOLE WDS AVAIL.
	MOVE	J,TT
	POPJ	P,


;HERE TO WAIT FOR ALLOC>40. BITS
FIWAL2:	PUSH	P,TT
	HRRZ	TT,FISKT+6(T)	;MSGS
	JUMPLE	TT,POPTTJ
	MOVE	TT,FISKT+4(T)	;ALLOC
	CAIL	TT,40.
	AOS	-1(P)
	JRST	POPTTJ


;NETAUI - ASCII UNIT INPUT
;
NETAUI:	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FICOMI	;SEE SAME
	JFCL			; FAILED ON RELOCATION OF BLOCK TYPE POINTER
	MOVE	TT,FISKT+2(A)
	TLNE	TT,200000
	JRST	NTAUIB	;1 BIT BYTES
	MOVEI	T,4	;T/ BYTES PER WD
	PUSHJ	P,FIHMBF

;B/PNTR TO BUF SEG    R/# CHARS
	JRST	NTAUIE	;EOF
	HLRZ	TT,(B)
	IDIVI	TT,4	;TT/OFSET OF WD NO  I/BYTE POSITION
	ADDI	TT,1(Q)	;ADDR OF 1ST WD
	MOVE	J,[441000,,(TT)]
	JUMPE	I,NTAUI1
	IBP	J
	SOJA	I,.-2
;J/BUF BYTE PNTR
NTAUI1:	ILDB	I,J
	ANDI	I,377
	MOVE	TT,FISKT(A)
	TLNN	TT,40000	;8 BIT ASCII?
	TRZ	I,200		;NO ZERO 8th BIT
	XCTR XRW,[MOVEM	I,(C)]
	HLRZ	TT,(B)	;FIRST
	AOS	TT
	HRRZ	I,(B)	;LAST
	CAMLE	TT,I
	JRST	NTAUI2	;THIS BUF SEG EMPTY
	HRLM	TT,(B)	;NEW FIRST
	JRST	FICOMF


NTAUI2:	PUSHJ	P,FIPSAL
	PUSHJ	P,FIRALL
	PUSHJ	P,NTABC
	JRST	FICOMF

NTAUIB:	JRST	NTABIB


NTAUIE:	MOVE	TT,[-1,,3]	;EOF,,^C
	XCTR XRW,[MOVEM	TT,(C)]
	JRST	FICOMF


;BUFFER MUNGED - ERROR CODE 13
NTIBFM:	MOVEI	TT,13
	HRLM	TT,FISKT+6(A)
	JRST	FIOCER

;BAD STATE - ERROR CODE 16
NTIBST:	MOVEI	TT,16
	HRLM	TT,FISKT+6(A)
	JRST	FIOCER




;
;	NETIBI	IMAGE BLOCK INPUT
;
; SEE FICOMI

NETIBI:	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIPROT	;PROTECT LOSR
	JRST IOADC	;MPV
	XCTR XR,[SKIPL	(C)]	;DONT SKIP IF POSITIVE .IOT POINTER
	POPJ	P,

NTIBI1:	PUSHJ	P,FICOMI	;SEE SAME
	JRST	NTIBST
	MOVE	TT,FISKT+2(A)
	TLNE	TT,200000
	JRST	NTIBIB	;BITS
;BYTE SIZE=36.
	MOVEI	T,1	;BYTES PER WD
	PUSHJ	P,FIHMBF
	JRST	NIBIE1	;EOF
	CAMGE	E,R
	JRST	NTIBI2


;HERE IF USE UP BUFR
	PUSHJ	P,NTIBIT	;BLT
	PUSHJ	P,FIPSAL
	PUSHJ	P,FIRALL
	MOVE	I,R
	MOVEI	R,1
	PUSHJ	P,NTABIC
	PUSHJ	P,FICOMF
	XCTR XR,[SKIPL	(C)]	;WANT MORE?
	POPJ	P,	;NO
	JRST	NTIBI1	;YES

;HERE IF WANT LESS THAN BUFR
NTIBI2:	MOVE	R,E
	PUSHJ	P,NTIBIT	;BLT
	HLRZ	TT,(B)		;FIRST
	ADD	TT,E		;AMOUNT RCVD
	HRLM	TT,(B)
	XCTR XRW,[HRRZS	(C)]
	XCTR XRW,[ADDM	E,(C)]		;FIX LOSR
	JRST	FICOMF		;FREE BUF AMD GO AWAY


;HERE IF BIT BY BIT
NTIBIB:	MOVEI	T,36.	;BYTES PER WORD
	MOVE	W,[440100,,(H)]	; LOSR BYTE PNTR
	HRRZ	TT,FISKT+7(A)	;USER'S BYTE SIZE
	DPB	TT,[360600,,W]	;ACTUAL BYTE POSITION
NIBIB7:	PUSHJ	P,NIBIBW	;WAIT FOR 1 BYTE OR EOF
	JRST	NTIBFM		;MUNGED BUFR
	PUSHJ	P,FIHMBF	;IS THERE DATA IN FIRST SEG?
	JRST	NIBIE1		;NO, EOF
	PUSH	P,C
	PUSH	P,D
	PUSH	P,U
	HRRZ	U,FISKT+7(A)
	HRRZ	C,I
	IDIV	C,U		;# WHOLE BYTES THERE ARE
	IMUL	C,U		;C/ # BIT IN BUF (MOD BYTE SIZE)
	MOVE	D,E
	IMUL	D,U		;# BITS LOSR WANTS
	MOVNS	C
	MOVNS	D
	HRLZS	C
	HRLZS	D


NIBIB1:	PUSHJ	P,FIHMBF	;BITS IN FIRST SEG
	JRST	4,.		;CONTRADICTS NIBIBW
	HLRZ	TT,(B)		;1ST BYTE
	IDIVI	TT,36.		;1ST WD #
	MOVE	J,[440100,,(Q)] ;BUF BYTE PNTR
	ADDI	J,1(TT)
	JUMPE	I,.+3
	IBP	J
	SOJA	I,.-2
	MOVNS	R		;R/ # BYTES FROM FIHMBF
	HRLZS	R


	;W/LOSR BYTE PNTR	J/BUF BYTE PNTR		U/BYTE SIZE
	;AOBJNS:  C/TOTAL BUF  D/LOSR WANTS  R/BUFR SEG
NIBIB2:	LDB	TT,[360600,,W]	;# BITS OVER - IF 0, RESET
	JUMPG	TT,NIBIB8		;DONT RESET
	DPB	U,[360600,,W]	;RESET BYTE POSITION
	AOS	W		;NEXT WORD
NIBIB8:	ILDB	I,J
	PUSHJ	P,IDPBIW	;FUNNY ROUTINE TO DO IDPB I,W
	AOBJP	R,NIBIB4	;BUF SEG EMTY
	AOBJP	D,NIBIB3	;LOSR HAPPY
	AOBJN	C,NIBIB2	;JUMP IF TOT BUF NOT EMPTY



	;HERE IF ALL WHOLE WDS USED, BUF SEG NOT EMPTY, LOSR NOT HAPPY
	HRRZ	TT,R		;# BYTES USED
	HLRZ	I,(B)		;OLD FIRST BYTE #
	ADD	I,TT
	HRLM	I,(B)

	;BUF SEG FIXED
NIBIB5:	HRRZ	TT,D		;# LOSR GOT
	IDIV	TT,U		;# BYTES (=WDS) LOSR GOT
	POP	P,U
	POP	P,D
	POP	P,C
	PUSHJ	P,FIFIXL
	SUB	E,TT		;UPDATE NUMBER LOSR STILL WANTS
	JRST	NIBIB7


	;HERE IF LOSR HAPPY, BUF NOT EMPTY
NIBIB3:	HRRZ	TT,R		;# USED
	HLRZ	I,(B)		;OLD 1ST
	ADD	I,TT
	HRLM	I,(B)		;NEW FIRST

	;BUF SEG FIXED
NIBIB6:	POP	P,U
	POP	P,D
	POP	P,C
	XCTR XRW,[HRRZS	(C)]		;FIX LOSR
	HRRZS	E
	XCTR XRW,[ADDM	E,(C)]
	JRST FICOMF		;EXIT




	;HERE IF BUF SEG EMPTY
NIBIB4:	PUSH	P,W
	PUSHJ	P,FIPSAL
	PUSHJ	P,FIRALL
	POP	P,W
	PUSHJ	P,NTABC		;MOVE TO NEXT SEG
	AOBJP	D,NIBIB6	;LOSR ALSO HAPPY
	AOBJP	C,NIBIB5	;NO MORE WHOLE WDS
	JRST	NIBIB1		;CONTIN



	;HERE TO TRANSFER WHOLE WORDS
NTIBIT:	PUSH	P,R
	HLRZ	I,(B)		;FIRST
	ADDI	I,1(Q)		;ADDR OF SAME
	HRLZ	TT,I		;'FROM'
	HRR	TT,H		;'TO'
	MOVE	I,R		;I/BYTE LOSR GOT
	SOS	R
	ADD	R,H		;'UNTIL'
	XCTR XW,[BLT TT,@R]
	MOVEI	T,1
	MOVEI	R,1		;1 BYTE PER WORD
	JRST	POPRJ



	;HERE IF EOF ON WORD XFER
NIBIE1:	JRST	FICOMF


	;HERE IF EOF IN BIT MODE  W/LOSR BYTE PNTR
NIBIE2:	HLRZ	TT,(B)		;1ST BYTE
	IDIVI	TT,36.		;1ST WD #
	MOVE	J,[440100,,(Q)]
	ADDI	J,1(TT)
	JUMPE	I,.+3
	IBP	J
	SOJA	I,.-2
	ILDB	I,J
	PUSHJ P,IDPBIW	;FUNN ROUTINE!!
	SOJG	R,.-2
	PUSHJ	P,NTABC
	MOVEI	TT,1
	PUSHJ	P,FIFIXL
	JRST	NIBIE1

; THIS IS ONE (OF MANY ) REASONS WHY THE NCP SHOULD BE REDONE
; THIS ROUTINE TAKES A BYTE IN I, AND A BYTE POINTER IN W, AND STORES IN USERLAND

IDPBIW:	IBP	W		;INCREMENT THE POINTER
	XCTR XR,[PUSH P,(W)]	;FETCH USER WORD
	PUSH	P,W		;SAVE POINTER
	HRRI	W,-1(P)		;MAKE PTR TO USER WORD
	DPB	I,W		;STASH THE BYTE
	POP	P,W		;RESTORE ORIGINAL
	XCTR XW,[POP P,(W)]	;RUN WORD BACK TO USER
	POPJ	P,
	;ABI TEST - SEE IF ONE WORD PRESENT
NTABIT:	PUSH	P,T
	HRL	T,A		;MEM ADDR IN T-LH  BYTES/WD IN T-RH
	PUSHJ	P,FICOMF	;UNLOCK BUFR
	PUSHJ	P,CWAIT		;RETURNS WITH CLOCK OFF
	PUSHJ	P,NTABT1	;WAIT FOR 5 CHARS
NABIT1:	MOVSI	T,600000	;'ACTIVE AT MPG LEVEL' BITS
	IORM	T,NETRAC(D)
	CONO	PI,CLKON	;CWAIT HAD TURNED IT OFF
	POP	P,T
	PUSHJ	P,FIHMB
	POPJ	P,		;BUFR MUNGED
	JRST	POPJ1		;OK

	;IMAGE TEST FOR 36 BYTES (BITS)
	;AS ABOVE
NIBIBW:	PUSH	P,T
	HRL	T,A		; LOSR,,BYTES/WRD
	PUSHJ	P,FICOMF	;UNLOCK THOSE BUFFERS
	PUSHJ	P,CWAIT
	PUSHJ	P,NTABT4
	JRST	NABIT1

	;ROUTINES TO COUNT NUMBER OF BYTES
NTABT4:	PUSH	P,T
	PUSH	P,I
	PUSH	P,Q
	PUSH	P,A
	HLRZ	Q,T		;LOSR
	HRR	Q,FISKT+7(Q)	;BYTE SIZE
	JRST	NTABT2
NTABT1:	PUSH	P,T
	PUSH	P,I
	PUSH	P,Q
	PUSH	P,A
	MOVEI	Q,5		;WANT 5 BYTES

NTABT2:	HLRZ	A,T		;LOSER
	HRRZS	T		;BYTE SIZE
	PUSHJ	P,FIBUFF	;RETURNS IN A/ BUFR ADDR
	EXCH	Q,A		;NOW=> A/# BYTES WANTED Q/MEM ADDR
	PUSHJ	P,FIHMB		;HOW MANY BYTES
	JRST	NTABT3		;BUFR MUNGED, DON'T WANT TO HANG
	JUMPL	I,NTABT3	;EOF
	CAML	I,A		;ENOUGH BYTES?
NTABT3:	AOS	-4(P)
	POP	P,A
	POP	P,Q
	POP	P,I
	JRST	POPTJ

	;ABI COMMON  IN- 
	;I-RH/# BYTES LOSR GOT
	;B/ PNTR TO BUF ENTRY
	;T/BYTES PER WD
	;Q/BUFR PNTR
	;R/BYTES PER USR WD
	;	DOES-
	;FREE BUFFER ENTRY
	;FIX UP LOSR (FIFIXL)
NTABIC:	HRRZ	TT,I
	IDIV	TT,R
	PUSHJ	P,FIFIXL
NTABC:	HRRZ	TT,(B)		;LAST
	IDIV	TT,T		;WORD # OF LAST BYTE OF DATA
	AOS	TT		;WORD # OF NEXT POSSIBLE SEGMENT LOCATION	
	CAIL	TT,FIBFLG
	SETZM	TT		;OFFSET OF ZERO
	CONO	PI,NETOFF	; AVOID PROBLEMS DURING CRITICAL SECTION
	HRRZ	I,(Q)		;NEXT FREE
	CAME	TT,I		;ARE WE THERE?
	JRST	NTABC1
NTABC3:	MOVSI	TT,-1		;-1,,0 MEANS NO DATA PRESENT, BUFR EMPTY
	MOVEM	TT,(Q)		;SOCK IT AWAY
	HLRZ	TT,FISKT+3(A)	;STATE
	CAIE	TT,11		;DATA PRES?
	JRST	NETONJ
	MOVEI	TT,5
	HRLM	TT,FISKT+3(A)
NETONJ:	CONO	PI,NETON
	POPJ	P,
NTABC1:	HRLM	TT,(Q)		;NEXT BUSY
	ADDI	TT,1(Q)		;ADDR OF NEXT BUSY
	SKIPL	(TT)		; EOF? IN THE NEXT SLOT?
	JRST	NETONJ		;NO
	HLRZ	TT,FISKT+3(A)	;YES, STATE?
	CAIN	TT,10		;CLOSED WITH DATA?
	HRRZS	FISKT+3(A)	;CHANGE TO CLOSED WITHOUT DATA
	CONO	PI,NETON
NTABC2:	POPJ	P,

NTABIB:	PUSHJ	P,FICOMF
	MOVSI	TT,200000
	IORM	TT,FISKT(A)
	POPJ	P,

	;EOF HANDLER W/LOSR BYTE PNTR
NABIE1:	PUSHJ	P,FIHMBF
	JRST	NABIE3		;NONE
	HLRZ	TT,(B)		;1ST BYTE
	IDIVI	TT,4
	MOVE	J,[441000,,(B)]
	ADDI	J,1(TT)		;CORRECTED
	JUMPE	I,.+3
	IBP	J
	SOJA	I,.-2
	MOVEI	TT,5
	;TT/ CHAR SLOTS IN WD   R/CHARS AVAIL
	ILDB	I,J
	IDPB	I,W
	SOS	TT
	SOJG	R,.-3
NABIE2:	MOVEI	I,3		;ASCII ^C
	IDPB	I,W
	SOJG	TT,.-1
	JRST NABIE4

NABIE3:	MOVEI	TT,5
	JRST	NABIE2		;5 ^CS

NABIE4:	MOVEI	TT,1
	PUSHJ	P,FIFIXL
	JRST	FICOMF		;EXIT

;	MPG - ASCII,BLOCK,INPUT
;	SEE ACCUM USSAGE FOR FICOMI
;
NETABI:	PUSHJ	P,FITEST
	JRST	IOCER3	;FATAL ERROR
	JRST	IOCER5	;NON-FATAL ERROR - CAN BE RETRIED
	PUSHJ	P,FIPROT	;PROTECT LOSR CORE
	JRST	IOADC
NTABI1:	PUSHJ	P,FICOMI	;SEE SAME
	JRST	NTIBST	;ERROR RETURN
	SETZM	T
	MOVE	TT,FISKT+2(A)
	TLNE	TT,200000	;ASCII?
	ADDI	T,32.		;NO, 36. BYTES PER WORD
	ADDI	T,4.		;IF ASCII, 4 BYTES PER WORD
	CAIE	T,4
	JRST	NTABIB		;BIT AT A TIME
NTABI0:	MOVE	W,[440700,,(H)]	;LOSR BYTE PNTR
	PUSHJ	P,NTABIT	;HAVE WE GOT AT LEAST ONE WORD?
	JRST	NTIBFM	;INPUT BUFFER MUNGED
 ;WE NOW HAVE AT LEAST ONE WORD
	PUSHJ	P,FIHMBF	;HOW MANY BYTES IN FIRST BUF?
	JRST	NABIE1		;NONE, BUT IS AN EOF
	PUSH	P,C
	PUSH	P,D
	MOVE	C,I		;# CHARS THERE ARE
	IDIVI	C,5		;C/ WHOLE WDS THERE ARE
	IMULI	C,5		;# CHARS IN WHOLE WD MSG
	MOVE	D,E		;# LOSR WDS
	IMULI	D,5		;# LOSR CHARS
	MOVNS	C
	MOVNS	D
	HRLZS	C
	HRLZS	D		;D/LOSR AOBJN   C/BUFR AOBJN


NTABI2:	PUSHJ	P,FIHMBF
	JRST	4,.		;CONTRADICTS NTABIT
	HLRZ	TT,(B)		;FIRST BYTE
	IDIVI	TT,4		;1ST WD #
	MOVE	J,[441000,,(Q)]	;BUF BYTE PNTR
	ADDI	J,1(TT)
	JUMPE	I,.+3
	IBP	J
	SOJA	I,.-2
;R/ # BYTES FROM FIHMBF
	MOVNS	R
	HRLZS	R
;W/LOSR BYTE PNTR	J/BUF BYTE PNTR
;AOBJNS: C/COUNT IN WHOLE BUF  D/LSR CNT  R/BUF SEG CNT


NTABI3:	ILDB	I,J
	PUSHJ	P,IDPBIW	;ROUTINE TO DO IDPB I,W
	AOBJP	R,NTABI7	;BUF SEG EMPTY
	AOBJP	D,NTABI5	;LOSR HAPPY
	AOBJN	C,NTABI3	;JUMP IF TOT BUF NOT EMPTY


;HERE IF WHOLE WDS USED UP, BUF SEG NOT EMPTY, LSR NOT HAPPY
;FIRST UPDATE BUF SEG
	HRRZ	TT,R		;NO BYTES USED
	HLRZ	I,(B)		;OLD FIRST
	ADD	I,TT
	HRLM	I,(B)		;NEW FIRST
;NOW FIX LOSR
NTABI4:	HRRZ	TT,D	;# HE GOT
	IDIVI	TT,5	;# WDS HE GOT
	POP	P,D
	POP	P,C
	PUSHJ	P,FIFIXL
	JRST	NTABI0+1



;HERE IF LOSR HAPPY,BUF SEG NOT EMPTY
NTABI5:	HRRZ	TT,R	;# BYTES USED
	HLRZ	I,(B)	;OLD FIRST
	ADD	I,TT
	HRLM	I,(B)	;NEW FIRST
  ;HERE IF BUF SEG NOT EMPTY
NTABI6:	POP	P,D
	POP	P,C
	XCTR XRW,[HRRZS	(C)]	;FIX LOSR
	XCTR XRW,[ADDM	E,(C)]
	JRST	FICOMF	;EXIT



;HERE IF BUF SEG EMPTY
NTABI7:	PUSH	P,W
	PUSHJ	P,FIPSAL
	PUSHJ	P,FIRALL
	POP	P,W
	PUSHJ	P,NTABC		;UPDATE SEG POINTER
	AOBJP	D,NTABI6	;LOSR HAPPY ALSO
	AOBJP	C,NTABI4	;NO MORE WHOLE WDS
	JRST	NTABI2		;CONTINUE






;
;	FICOMI
;
; DOES UFLSING, GETTING BUFR,  SKIPS IF WINNS
; TRUE ON OUTPUT:
; A/ FISKT INDEX
; C/ IOT PNTR
; D/ NETRAC OFFSET
; E/ USER MSG LENGTH (+)
; Q/ BUFR PNTR
; H/ USER DATA PNTR, RELOCATED
; U/ USER INDEX
; ALSO MUNGS B AND TT
FICOMI:	HRRZ	D,FISKT+3(A)	;BUF PNTR
	CONO	PI,CLKOFF
	MOVE	T,D
	PUSHJ	P,FICOMQ	;BUFFER LOCKED BY CORE ALLOC OR DATA NOT PRESENT?
	JRST	.+2
	JRST	FICMI2
	CONO	PI,CLKON
	PUSHJ	P,CWAIT
	PUSHJ	P,FICOMQ	;WAIT FOR NEITHER OR BOTH 4.8 AND 4.9 AND DATA
FICMI2:	MOVSI	B,600000	;ACTIVE AT MPG LEVEL
	IORM	B,NETRAC(D)
	CONO	PI,CLKON
	HRRZ	B,NETRAC(D)	;IOBUF PNTR
	LDB	Q,[IOSA,,IOBFT(B)]
	LSH	Q,6	;Q/ BUFR PNTR
	XCTR XR,[HLRE	E,(C)]	;E/ NEG WORD COUNT
	MOVNS	E	;E/ POS WD CNT
	XCTR XR,[HRRZ	H,(C)]
	XCTR XRW,[MOVES (H)]	;WILL CHECK, FAIL IMMEDIATE!!
	JRST	POPJ1

;
;HANDY DANDY SUBROUTINE TO BE EXECUTED TO FIND REAL ADDR OF BUFR
;IN => A/LOSR
;OUT=> A/MEM ADDR
FIBUFF:	HRRZ	A,FISKT+3(A)	;BUFR PNTR
	HRRZ	A,NETRAC(A)	;IOBFT PNTR
	LDB	A,[IOSA,,IOBFT(A)]	;BLOCK #
	LSH	A,6
	POPJ	P,



;WAIT FOR UNLOCKED BUFR AND DATA
FICOMQ:	PUSHJ	P,FICOMT	;BUFR LOCKED BY CORE ALLOC?
	POPJ	P,	;YES
	PUSH	P,A
	HRRZ	A,NETRAC(T)	;PNTR INTO IOBFT
	LDB	A,[IOSA,,IOBFT(A)]	;BLOCK #
	LSH	A,6
	SKIPL	(A)	;ANY DATA?
	AOS	-1(P)	;YES
	JRST	POPAJ


;UNLOCK BUFFER

FICOMF:	PUSH	P,A
	MOVSI	A,600000
	ANDCAM	A,NETRAC(D)
IFN FILKOU,[
	MOVE	A,NETRAC(D)
	TLZN	A,20000
	JRST	POPAJ
	MOVEM	A,NETRAC(D)
	SETOM	FINMEM
	CONO	PI,PI6INT
]
	JRST	POPAJ

FICOMT:	SKIPL	NETRAC(T)
	JRST	POPJ1
	PUSH	P,A
	MOVE	A,NETRAC(T)
	TLNE	A,200000
	AOS	-1(P)
	POP	P,A
	POPJ	P,


;COMon Output routine
;CALLED BY ALL OUTPUT IOTS - WAITS FOR CORE ALLOCATOR TO BE DONE

FICOMO:	PUSH	P,T
	HRRZ	D,FISKT+3(R)	;BUF PNTR
	CONO	PI,CLKOFF
	MOVE	T,D
	PUSHJ	P,FICOMT	;BUFFER LOCKED BY CORE ALLOC?
	JRST	.+2
	JRST	FICMO1
	CONO	PI,CLKON
	PUSHJ	P,CWAIT
	PUSHJ	P,FICOMT
FICMO1:	MOVSI	B,600000	;ACTIVE AT MPG LEVEL
	IORM	B,NETRAC(D)
	CONO	PI,CLKON
	HRRZ	B,NETRAC(D)	;IOBUF PNTR
	LDB	A,[IOSA,,IOBFT(B)]
	LSH	A,6	;A/ BUFR PNTR
	JRST	POPTJ

;
;	THIS ROUTINE PROTECTS
;	C/ RELOCATED IOT POINTER
;
;	SKIPS IF WINS
;
FIPROT:	JUMPL	C,[JRST 4,.]	;FLAG FOR EXEC IO
	PUSH	P,D
	PUSH	P,TT
	XCTR XRW,[HRRZ	D,(C)]		;STARTING LOC
	XCTR XRW,[HLRE	TT,(C)]		;NEG LENGTH
	SKIPL	TT		;POP IF LENGTH 0 OR >2**17
	JRST	FIPRT1	;SKIP
	MOVNS	TT		;POS LENGTH
	XCTR XRW,[MOVES (D)]	;CHECK FIRST ADR
	ADD	D,TT	;GET LAST ADR
FIPRT3:	XCTR XRW,[MOVES -1(D)]	;BLESS LAST ADR
	SUBI	TT,2000	;DROP COUNT
	SUBI	D,2000	;DROP ADDR
	JUMPGE	TT,FIPRT3	;LOOP BACK IF MORE THAN ONE BLOCK
FIPRT1:	AOS	-2(P)
FIPRT2:	POP	P,TT
	POP	P,D
	POPJ	P,


;
;	FIFIXL
;
; FIX THE LOSRS PNTRS
; INPUT IN TT
FIFIXL:	PUSH	P,J	;STORAGE
	XCTR XRW,[HLRE	J,(C)]	;COUNT
	ADD	J,TT
	XCTR XRW,[HRLM	J,(C)]
	XCTR XRW,[HRRZ	J,(C)]	;USR DATA PNTR
	ADD	J,TT
	XCTR XRW,[HRRM	J,(C)]
	POP	P,J
	POPJ	P,
;
;	FIWBUF
;
;	SEE IF A BUF IS AVAILABLE
FIWBUF:	SKIPLE	UTTBF
	JRST	POPJ1
	SKIPG	IOBFC
	POPJ	P,
	SKIPE	MEMFRZ
	POPJ	P,
	PUSH	P,A
	MOVE	A,MEMFR
	SUB	A,NCBCOM

	SUBI	A,3
	JUMPLE	A,POPAJ
	JRST POPAJ1

; THIS ROUTINE TESTS FOR THE CORRECT USER AND ERROR BITS
; IF IT IS THE WRONG USER OR A FATAL ERROR, A NO SKIP RESULTS
; IF A NON-FATAL ERROR HAS OCCURED, ONE SKIP RESULTS
; IF NON OF THE ABOVE, THIS SKIPS TWICE
FITEST:	PUSH	P,C
	HRRZ	C,FISKT+5(A)	;USER
	HRRZ	TT,U		;LEFT OF U MAY BE NON-ZERO
	CAME	C,TT
	JRST	POPCJ	;LOSE BIG
	MOVE	C,FISKT(A)	;WORD WITH ERROR BITS
	TLNE	C,100000	;FATAL ERROR?
	JRST	POPCJ	;YES, LOSE BIG
	TLZN	C,200000	;NON-FATAL?
	AOS	-1(P)		;WIN
	JRST	POPCJ1	;LOSE LITTLE


;	THIS PUTS A BUFFER IN THE WRITE QUEUE
;	CLOBBERS T,TT
;	D/ NETRAC CHNL NUMBER
;	R/ OFFSET IN SOCKET MAP
;
;	A/ ADDR OF BBUFFER
FIWQI:	SKIPG	FIOQFR	;ANY ROOM IN OUTPUT Q?
	PUSHJ	P,UFLS
	CONO	PI,NETOFF
	PUSHJ	P,FIOQI	;GET A SPACE IN FIOQ
	JRST	FIWQI1	;NONE
	MOVEM	R,1(TT)	;NOW IN Q
	MOVEI	TT,6	;STATE 6 - RFNM WAIT
	HRLM	TT,FISKT+3(R)	;NEW STATE
	CONO	PI,NETON
	PUSHJ	P,FISTRT	;START UP OUTPUT
	AOS	(P)
	POPJ	P,


FIWQI1:	CONO	PI,NETON
	JRST	FIWQI


;PENDING QUEUE INSERT
;OUT - TT/PNTR TO BLOCK
;IF NONE FREE, FREES OLDEST AND SENDS CLS
FIPQI:	PUSH	P,I
	PUSH	P,A
	SKIPG	FIPQFR		;ANY FREE
	PUSHJ	P,FIPQRG	;SEND CLS TO 1ST AND FREE IT
	MOVE	TT,FIPQFR	;TT/PNTR TO FREE BLK
	MOVE	I,@FIPQFR	;I/PNTR	TO NNXT FREE, 0 IF NONE
	SETZM	(TT)		;END OF BUSY CHAIN
	MOVEM	I,FIPQFR	;SHORTEN FREE CHAIN
	MOVEI	I,FIPQST
	SKIPN	A,(I)	;FIND LAST ENTRY IN CHAIN
	JRST	.+3
	MOVE	I,A
	JRST	.-3
	MOVEM	TT,(I)		;ADD TO ENND OF CHAIN
	POP	P,A
	JRST	POPIJ



;FIND IN PENDING QUEUE
;	1st WORD - FORWARD POINTER
;	2nd WORD - FOR SOC + 4.9 USED BY TIME OUT
;	3rd WORD - LOC SOC
;	4th WORD - LH--LINK OR BYTE SIZE   RH--HOST
;IN - TT/LOC SOC     OUT - T/PNTR TO BLK
;SKIPS IF WINS
FIFPQ:	PUSH	P,A
	PUSH	P,TT
	MOVEI	A,FIPQST
	SKIPG	T,(A)		;ANY IN QUEUE?
	JRST	FIFPQ3		;NO
FIFPQ1:	CAMN	TT,2(T)		;THIS ENTRY FOR ME?
	JRST	FIFPQ2		;YES
	MOVE	A,T		;GET NEXT
	SKIPG	T,(T)		;NEXT ACTIVE?
	JRST	FIFPQ3		;NO
	JRST	FIFPQ1		;YES, LOOP


FIFPQ2:	MOVE	TT,(T)		;NEXT IN CHAIN
	MOVEM	TT,(A)		;SHORTENN CHAIN
	MOVE	A,FIPQFR	;START OF FREE CHAIN
	MOVEM	T,FIPQFR	;NEW ONE
	MOVEM	A,(T)		;CONTINUE SAME
	AOS	-2(P)		;SKIP
FIFPQ3:	POP	P,TT
	JRST	POPAJ
;ROUTINE TO SEND CLS TO FIRST RFC IN QUEUE
;MUNGS I
FIPQRG:	PUSH	P,W		;PENDING QUEUE RING
	MOVE	W,FIPQST	;PNTR TO 1ST ENTRY
	MOVEM	W,FIPQFR	;MAKE IT FREE
	MOVE	I,@FIPQST	;2ND ENTRY
	MOVEM	I,FIPQST	;NOW 1ST ENTRY
	SETZM	@FIPQFR
;CREATE	CLOSE IN FIPRFC
;W/STILL PNTR TO BLOCK
FIPQR1:	MOVEI	I,4
	MOVEM	I,FIPRFC	;WORD CNT
	MOVEI	I,3
	DPB	I,[341000,,FIPRFC+3]	;CLS=3
	MOVE	I,2(W)		;LOC SOC
	DPB	I,[400400,,FIPRFC+4]	;MUST GET SPLIT
	LSH	I,-4
	DPB	I,[3400,,FIPRFC+3]
	MOVE	I,1(W)		;FOR SOC
	DPB	I,[4000,,FIPRFC+4]
	MOVE	I,3(W)		;LINK,,HOST
	DPB	I,[241000,,FIPRFC+1]	;HOST IN LEADER, LINK 0
	MOVEI	I,9.		;# BYTES
	LSH	I,8.		;POSITIONED
	TLO	I,1000		;8 BIT BYTES
	MOVEM	I,FIPRFC+2	;EXTENDED LEADER
	MOVEI	W,FIPRFC
	PUSHJ	P,FICQI		;SEND IT OUT
	SETOM	I		;TOO BAD
	POP	P,W
	POPJ	P,


;ROUTINE TO FLUSH THE PENDING Q
FIPQRP:	PUSH	P,I
	SKIPG	FIPQST
	JRST	POPIJ
	PUSHJ	P,FIPQRG	;SEND A CLOSE TO 1st ENTRY AND EXCISE IT
	JRST .-3


;KLOCK QUEUE INSERT
;SKIPS IF WINS
;TT/PNTR TO 5 WD BLK
FIKQI:	PUSH	P,I
	PUSH	P,A
	SKIPG	FIKQFR		;ANY FREE
	JRST	FIKQI1
	MOVE	TT,FIKQFR	;TT/PNTR TO FREE BLK
	MOVE	I,@FIKQFR	;I/PNTR	TO NNXT FREE, 0 IF NONE
	SETZM	(TT)		;END OF BUSY CHAIN
	MOVEM	I,FIKQFR	;SHORTEN FREE CHAIN
	MOVEI	I,FIKQST
	SKIPN	A,(I)	;FIND LAST ENTRY IN CHAIN
	JRST	.+3
	MOVE	I,A
	JRST	.-3
	MOVEM	TT,(I)		;ADD TO ENND OF CHAIN
	AOS	-2(P)
FIKQI1:	POP	P,A
	JRST	POPIJ



;FIND IN KLOCK QUEUE
;CALLED WITH FOO FROM [JRST FOO] IN NEXT WORD
;IN/TT/LOSR   OUT T/PNTR TO BLOCK
;DOUBLE SKIPS IF WINS
FIFKQ:	PUSH	P,A
	PUSH	P,TT
	MOVEI	A,FIKQST
	SKIPG	T,(A)		;ANY IN QUEUE?
	JRST	FIFKQ3		;NO
FIFKQ1:	CAME	TT,4(T)		;THIS ENTRY FOR ME?
	JRST	FIFKQ4		;NO
	HRRZ	TT,3(T)		;RESTART ADDR  'FOO'
	CAMN	TT,@-2(P)		;THE ONE CALLED WITH?
	JRST	FIFKQ2		;YES
FIFKQ4:	MOVE	A,T		;GET NEXT
	SKIPG	T,(T)		;NEXT ACTIVE?
	JRST	FIFKQ3		;NO
	JRST	FIFKQ1		;YES, LOOP


FIFKQ2:	MOVE	TT,(T)		;NEXT IN CHAIN
	MOVEM	TT,(A)		;SHORTENN CHAIN
	MOVE	A,FIKQFR	;START OF FREE CHAIN
	MOVEM	T,FIKQFR	;NEW ONE
	MOVEM	A,(T)		;CONTINUE SAME
	AOS	-2(P)		;SKIP
FIFKQ3:	AOS	-2(P)		;DOUBLE
	POP	P,TT
	JRST	POPAJ





;OUTPUT Q INSERT
;SKIPS IF WINS
;TT/PNTR TO 2 WD BLK
FIOQI:	PUSH	P,I
	PUSH	P,A
	SKIPG	FIOQFR		;ANY FREE
	JRST	FIOQI1
	MOVE	TT,FIOQFR	;TT/PNTR TO FREE BLK
	MOVE	I,@FIOQFR	;I/PNTR	TO NNXT FREE, 0 IF NONE
	SETZM	(TT)		;END OF BUSY CHAIN
	MOVEM	I,FIOQFR	;SHORTEN FREE CHAIN
	MOVEI	I,FIOQST
	SKIPN	A,(I)	;FIND LAST ENTRY IN CHAIN
	JRST	.+3
	MOVE	I,A
	JRST	.-3
	MOVEM	TT,(I)	;ADD TO END OF CHAIN
	AOS	-2(P)
FIOQI1:	POP	P,A
	JRST	POPIJ
;SEARCH IN KLOCK QUEUE
;LOOKS FOR IDLE BLOCKS
;SKIPS IF WINS
FISKQ:	PUSH	P,A
	PUSH	P,TT
	MOVEI	A,FIKQST
	SKIPG	T,(A)		;ANY IN QUEUE?
	JRST	FISKQ3		;NO
FISKQ1:	SKIPGE	2(T)
	JRST	FISKQ2		;YES
	MOVE	A,T		;GET NEXT
	SKIPG	T,(T)		;NEXT ACTIVE?
	JRST	FISKQ3		;NO
	JRST	FISKQ1		;YES, LOOP

FISKQ2:	MOVE	TT,(T)		;NEXT IN CHAIN
	MOVEM	TT,(A)		;SHORTEN CHAIN
	MOVE	A,FIKQFR	;START OF FREE CHAIN
	MOVEM	T,FIKQFR	;NEW ONE
	MOVEM	A,(T)		;CONTINUE SAME
	AOS	-2(P)
FISKQ3:	POP	P,TT
	JRST	POPAJ




;FIND IN PENDING QUEUE
;IN - I/LOC SOC     B/FOR SOC     OUT - T/PNTR TO BLK
;SKIPS IF WINS
FISPQ:	PUSH	P,A
	PUSH	P,TT
	MOVEI	A,FIPQST
	SKIPG	T,(A)		;ANY IN QUEUE?
	JRST	FIFPQ3		;NO
FISPQ1:	CAME	I,2(T)	;LOC SOC SAME?
	JRST	.+3	;NO
	CAMN	B,1(T)	;FOR SOC SAME?
	JRST	FIFPQ2		;YES
	MOVE	A,T		;GET NEXT
	SKIPG	T,(T)		;NEXT ACTIVE?
	JRST	FIFPQ3		;NO
	JRST	FISPQ1		;YES, LOOP


;TIME OUT ON CLOSE SOCKET
FICLKQ:	PUSH	P,E
	PUSH	P,TT
	PUSH	P,T
	PUSHJ	P,FISKQ	;FIND IDLE BLOCK
	JRST	FICKQ1	;NO
	MOVE	E,4(T)	;LOSR
	HLRZ	TT,FISKT+3(E)	;STATE
	CAIE	TT,7		;CLOSED?
	CAIN	TT,13		;HOST DEAD?
	PUSHJ	P,NTCS1D	;YES, KILL SOC
FICKQ1:	POP	P,T
	POP	P,TT
	POP	P,E
	JRST	CLQRET


;CONTROL QUEUE INSERT
;IN - W/PNTR TO 6 WD BLOCK
;SKIPS IF WINS -UFLS CAN BE DONNE ON FICQFR
FICQI:	SKIPG	FICQFR		;ANY FREE
	POPJ	P,		;NO
	PUSH	P,A
	PUSH	P,E
	PUSH	P,D
	MOVE	E,FICQFR	;E/PNTR TO FREE BLK
	JUMPG	E,.+3
	SETZM	D
	JRST	.+2
	MOVE	D,@FICQFR	;I/PNTR	TO NNXT FREE, 0 IF NONE
	SETZM	(E)		;ENND OF BUSY CHAIN
	MOVEM	D,FICQFR	;SHORTEN FREE CHAIN
	MOVEI	D,FICQST
	SKIPN	A,(D)
	JRST	.+3
	MOVE	D,A
	JRST	.-3
	MOVEM	E,(D)		;ADD TO ENND OF CHAIN
  ;E/ PNTR TO FREE BLK
  ;BLT
	MOVE	D,E
	AOS	E
	HRL	E,W
	BLT	E,6(D)
IFN NCPDBG,[	AOS	E,D
	PUSH	P,E
	PUSHJ	P,FDCVB6
	POP	P,E
	]
	POP	P,D
	POP	P,E
	PUSHJ	P,FISTRT
	JRST	POPAJ1

;ROUTINE TO WRITE OUT CONTROL MSGS
;WRITE OUT FIORFC - ONLY GOOF FROM MPG
FICQW:	PUSH	P,W	;CONTROL QUEUE WRITE
	MOVEI	W,FIORFC
	CONO	PI,NETOFF
	PUSHJ	P,FICQI
	JRST	FICQW1	;LOSE
	CONO	PI,NETON
	JRST	POPWJ

FICQW1:	POP	P,W
	CONO	PI,NETON
	SKIPG	FICQFR
	PUSHJ	P,UFLS
	JRST	FICQW


;ADD HOST TO RFNM BLOCKED TABLE
;IN/ HOST IN H
;SKIP IF WIN - DON'T SKIP IF ALREADY THERE
FIAHST:	PUSH	P,T
	PUSH	P,W
	SETOM	W
	MOVSI	T,-FINHTT
FIAHS1:	CAMN	H,FIHSTT(T)
	JRST	FIAHS3		;ALREADY THERE
	SKIPE	FIHSTT(T)	;FREE ENTRY?
	JRST	FIAHS2		;NO, CONTINUE SEARCH
	SKIPGE	W		;IS IT FIRST?
	HRRZ	W,T		;YES
FIAHS2:	AOBJN	T,FIAHS1
  ;HERE IF NOT FOUND	W/1ST EMPTY OR -1
	JUMPL	W,FIAHS3
	MOVEM	H,FIHSTT(W)
	AOS	-2(P)
FIAHS3:	POP	P,W
	JRST	POPTJ



;DELETE HOST FROM TABLE
;IN - HOST IN B
FIDHST:	PUSH	P,A
	MOVSI	A,-FINHTT
FIDHS1:	CAME	B,FIHSTT(A)
	JRST	FIDHS2
	SETZM	FIHSTT(A)
	JRST	.+2
FIDHS2:	AOBJN	A,FIDHS1
	JRST	POPAJ






;LINK GOBBLER
;OUT- TT/LINK

;CALLED WITH LOSR IN C
FIGLKC:	PUSH	P,E
	MOVE	E,C
	JRST	FIGLNK

;CALLED WITH LOSR IN E
FIGLKE:	PUSH	P,E

FIGLNK:	PUSH	P,I
	MOVE	TT,E
	IDIVI	TT,FILSKT	;ENTRY # OF LSR (0-N)
	ADDI	TT,2		;LINK # (2 -> N+2)
	POP	P,I
	JRST	POPEJ
;SET UP CONTROL MESSAGE AT PI LEVEL
;IN - C/LOSR    OUT - MSG IN FIPRFC
FIPRTS:	EXCH	C,E
	PUSH	P,T
	PUSH	P,TT
	LDB	T,FIFHST	;FOR HST
	PUSHJ	P,FIGLKC
	DPB	TT,FILINK
	DPB	TT,[341000,,FIPRFC+5]	;LINK
	MOVEI	TT,1		;XTRA WD FOR LNK
	MOVEI	T,1		;RTS=1
	JRST	FIPFC

FIPSTR:	PUSH	P,T
	PUSH	P,TT
	SETZM	TT
	MOVE	T,FISKT+1(E)
	TLNN	T,100000	;SKIP IF ASCII
	ADDI	TT,28.
	ADDI	TT,8.
	DPB	TT,[341000,,FIPRFC+5]	;BYTE SIZE
	EXCH	C,E
	MOVEI	T,2		;STR=2
	MOVEI	TT,1		;BYTE SIZE
	JRST	FIPFC

FIPCLS:	PUSH	P,T
	PUSH	P,TT
	EXCH	C,E
	MOVEI	T,3		;CLS=3
	SETZM	TT		;NO LINK
	JRST	FIPFC


FIPFC:	DPB	T,[341000,,FIPRFC+3]
	LDB	T,FIFHST
	LSH	T,20.		;LINK 0
	MOVEM	T,FIPRFC+1
	LDB	T,FIFSOC
	MOVEM	T,FIPRFC+4	;FOR SOC
	LDB	T,FILSOC
	DPB	T,[400400,,FIPRFC+4]	;2ND PT LOC SOC
	LSH	T,-4
	DPB	T,[3400,,FIPRFC+3]	;1ST PT LOC SOC
	ADDI	TT,4	;# WDS
	MOVEM	TT,FIPRFC
	ADDI	TT,5		;# BYTES
	LSH	TT,8.
	TLO	TT,1000		;8 BIT BYTES
	MOVEM	TT,FIPRFC+2
	EXCH	E,C
	POP	P,TT
	JRST	POPTJ


;SET UP CONTROL MESSAGE AT MPG LEVEL
;IN - E/LOSR    OUT - MSG IN FIORFC
FIMRTS:	PUSH	P,T
	PUSH	P,TT
	LDB	T,FIFHST	;FOR HST
	PUSHJ	P,FIGLKE
	DPB	TT,FILINK
	DPB	TT,[341000,,FIORFC+5]	;LINK
	MOVEI	TT,1		;XTRA WD FOR LNK
	MOVEI	T,1		;RTS=1
	JRST	FIMFC

FIMSTR:	PUSH	P,T
	PUSH	P,TT
	SETZM	TT
	MOVE	T,FISKT+1(E)
	TLNN	T,100000	;SKIP IF ASCII
	ADDI	TT,28.
	ADDI	TT,8.
	MOVE	T,FISKT+2(E)
	TLNE	T,100000	;NON STANDARD BYTE SIZE?
	HRRZ	TT,FISKT+7(E)
	DPB	TT,[341000,,FIORFC+5]
	MOVEI	T,2		;STR=2
	MOVEI	TT,1		;BYTE SIZE
	JRST	FIMFC

FIMCLS:	PUSH	P,T
	PUSH	P,TT
	MOVEI	T,3		;CLS=3
	SETZM	TT		;NO LINK
	JRST	FIMFC


FIMFC:	DPB	T,[341000,,FIORFC+3]
	LDB	T,FIFHST
	LSH	T,20.		;LINK 0
	MOVEM	T,FIORFC+1
	LDB	T,FIFSOC
	MOVEM	T,FIORFC+4	;FOR SOC
	LDB	T,FILSOC
	DPB	T,[400400,,FIORFC+4]	;2ND PT LOC SOC
	LSH	T,-4
	DPB	T,[3400,,FIORFC+3]	;1ST PT LOC SOC
	ADDI	TT,4	;# WDS
	MOVEM	TT,FIORFC
	ADDI	TT,5		;# BYTES
	LSH	TT,8.
	TLO	TT,1000		;8 BIT BYTES
	MOVEM	TT,FIORFC+2
	POP	P,TT
	JRST	POPTJ




;SEND AN ALLOCATE
;W/BITS TO BE ALLOCATED
;R/MSGS "  "  "
;Q/LINK	H/HOST
FISALL:	CONSO	PI,FIPICM		;PI 6 IN PROG?
	CONO	PI,CLKOFF
	PUSHJ	P,FIMALL
	MOVEI	W,FIPRFC
	CONSO	PI,FIPICM
	CONO	PI,NETOFF
	PUSHJ	P,FICQI
	JFCL
	CONSO	PI,FIPICM
	CONO	PI,NETON
	POPJ	P,
;MAKE AN ALLOCATE
;W/BITS TO BE ALLOCATED
;R/MSGS "  "  "
;Q/LINK	H/HOST
FIMALL:	PUSH	P,W
	PUSH	P,R
	MOVEI	TT,4	;WD CNT
	MOVEM	TT,FIPRFC
	MOVE	TT,H	;HOST, LINK 0
	LSH	TT,20.
	MOVEM	TT,FIPRFC+1
	MOVEI	TT,8.	;# BYTES
	LSH	TT,8.
	TLO	TT,1000	;8 BIT  BYTES
	MOVEM	TT,FIPRFC+2
	MOVEI	TT,4	;ALL=4
	LSH	TT,28.
	DPB	Q,[241000,,TT]	;LINK
	LSH	W,8.		;BIT COUNT
	MOVEM	W,FIPRFC+4
	LSH	R,4
	IOR	TT,R		;ALL-LINK-MSGS
	MOVEM	TT,FIPRFC+3
	POP	P,R
POPWJ:	POP	P,W
	POPJ	P,

;REALLOCATE A MSG
;W/BITS	A/LOSR
FIRALL:	PUSH	P,R
	HLRZ	R,FISKT+3(A)	;STATE - ONLY ALLOW 5 OR 11
	CAIN	R,5	;OPEN?
	JRST	FIRAL1	;YES, GO AHEAD
	CAIE	R,11	;OPEN W/DATA?
	JRST	POPRJ	;NO - GO AWAY
FIRAL1:	PUSH	P,H
	PUSH	P,Q
	PUSH	P,E
	MOVE	E,A
	MOVEI	R,1
	MOVE	Q,FISKT+2(A)	;SEE IF WANT TO SKIP 1 MSG DUE TO WRAPAROUND
	TLZE	Q,40000
	SETZM	R		;YES
	MOVEM	Q,FISKT+2(A)
	LDB	Q,FILINK
	LDB	H,FIFHST
	PUSHJ	P,FISALL
	POP	P,E
	POP	P,Q
	POP	P,H
POPRJ:	POP	P,R
	POPJ	P,



;PICK SIZE OF ALLOC
;IN - B/PNTR TO BUF SEG   A/LOSR
;OUT-W/# BITS
FIPSAL:	PUSH	P,C
	PUSH	P,D
	MOVEI	D,36.	;IF IMAGE, 36 BIT BYTES
	MOVE	C,FISKT+1(A)
	TLNE	C,100000	;ASCII
	MOVEI	D,8.	;YES
	MOVE	C,FISKT+2(A)
	TLNE	C,200000
	MOVEI	D,1
	MOVE	C,B
	SUBI	C,(Q)	;OFFSET OF 1ST DATA SLOT
	IMUL	C,T	;BYTE #
	HRRZ	W,(B)	;W/ LAST
	SUB	W,C
	AOS	W	;# THERE WERE
	IMUL	W,D
	POP	P,D
	JRST	POPCJ



;FISSOC
;IN - D/FOR SOC     I/LOC SOC     H/HOST
;OUT - C/LOSR       SKIP IF WINS
FISSOC:	PUSH	P,E
	MOVSI	E,-FINSKT
FISSC1:	LDB	C,FIFHST
	CAME	C,H
	JRST	FISSC2	;NO
	LDB	C,FILSOC
	CAME	C,I
	JRST	FISSC2	;NO
	LDB	C,FIFSOC
	CAMN	C,D
	JRST	FISSC3	;WIN
FISSC2:	ADDI	E,FILSKT-1
	AOBJN	E,FISSC1
	JRST	.+2
FISSC3:	AOS	-1(P)
	HRRZ	C,E
	JRST	POPEJ

;SEARCH ONLY FOR LISTENING SOC
;FILSOC
;IN -  I/LOC SOC  
;OUT - C/LOSR       SKIP IF WINS
FISLSC:	PUSH	P,E
	MOVSI	E,-FINSKT
FISLS1:	LDB	C,FILSOC
	CAME	C,I
	JRST	FISLS2	;NO
	HLRZ	C,FISKT+3(E)	;STATE
	CAIN	C,1		;LISTENING?
	JRST	FISLS3	;WIN
FISLS2:	ADDI	E,FILSKT-1
	AOBJN	E,FISLS1
	JRST	.+2
FISLS3:	AOS	-1(P)
	HRRZ	C,E
POPEJ:	POP	P,E
	POPJ	P,


;ROUTINE TO WRITE OUT CONTROL MSGS
;SKIPS IF NONE TO WRITE OUT
;W RITE  C ONTROL  M ESSAGE
FIWCM:	MOVEI	B,FICQST
FIWCM1:	MOVE	A,B
	MOVE	B,(A)		;START OF CHAIN
	JUMPE	B,POPJ1
	LDB	H,[241000,,2(B)]	;HOST
	PUSHJ	P,FIAHST	;PUT IN HOST TABLE, SKIP IF WIN
	JRST	FIWCM1		;ALREADY THERE
  ;B/BLK TO BE OUTPUTTED    A/TO PREVIOUS BLK
	MOVEI	C,1(B)		;SET UP OUT PNTR
  ;NOW FREE BLK
	MOVE	D,(B)
	MOVEM	D,(A)
	MOVE	D,FICQFR
	MOVEM	D,(B)
	MOVEM	B,FICQFR
  ;NOW OUTPUT
	SETZM	FI32B		;WANNT 36 BIT OUTPUT
	SETOM	FILLSR	;LAST LOSR =-1
IFN NCPDBG,[	PUSH	P,C
	PUSHJ	P,FDCVB6
	POP	P,C
	]
	PUSHJ	P,FIPUT
	POPJ	P,



;ROUTINE TO WIGHT REGULAR MSGS
;W RITE   O UTPUT   Q  UEUE
;NO SKIP IF Q EMPTY
;SETS 4.6 BIT OF ANY BUFR LOCKED 
FIWOQ:	MOVEI	B,FIOQST	;START OF CHAIN
FIWOQ1:	MOVE	A,B
	MOVE	B,(A)	;FIRST ENTRY
	JUMPE	B,CPOPJ
	MOVE	E,1(B)	;LOSR
	HRRZ	D,FISKT+3(E)	;BUFR
	SKIPL	NETRAC(D)	;LOCKED?
	JRST	FIWOQ2	;NO
	MOVSI	E,40000
	IORM	E,NETRAC(D)
	JRST	FIWOQ1

FIWOQ2:	MOVE	TT,(B)
	MOVEM	TT,(A)
	MOVE	TT,FIOQFR
	MOVEM	TT,(B)
	MOVEM	B,FIOQFR
	JRST	POPJ1


;REMOVE (mAYBE) HOST FROM READY LIST
;IN	E/LOSR
FIKRST:	PUSH	P,I
	PUSH	P,H
	PUSH	P,E
	LDB	H,FIFHST	;FORGN HOST
	JUMPE	H,FIKRS2	;ZERO ISNT REAL
	MOVSI	E,-FINSKT
FIKRS1:	LDB	TT,FIFHST	;FOR HOST OF THIS SLOT
	CAMN	TT,H		;SAME?
	JRST	FIKRS2
	ADDI	E,FILSKT-1
	AOBJN	E,FIKRS1

	PUSHJ	P,FIFRST
	SETZM	TT
	DPB	TT,T
FIKRS2:	POP	P,E
	POP	P,H
	JRST	POPIJ

;SEND A RESET
;CALL WITH H/HOST
;HANGS TILL SOMETHING HAPPENS -
;CALLED WITH - PUSHJ P,FISRST
;	R0 - TIME OUT ON RESET
;	R1 - HOST DEAD
;	R2 - HAPPY

FISRST: IRP X,,[T,W,R,J,Q,I,TT]
	PUSH	P,X
	TERMIN

	PUSHJ	P,FIFRST	;FIND THE GUY IN THE TABLE
	SOS	TT		;TT/+1=OK  0=SENT  -1=DOWN
	JUMPG	TT,FISRS6	;GO AWAY IF OK
	JUMPE	TT,FISRS2	;DONT SEND IT TWICE
	MOVEI	TT,1
	DPB	TT,T		;MARK IT SENT

;MAKE A RST IN ACS  I-R
	MOVEI	I,3		;# WDS
	MOVE	Q,H		;HOST
	LSH	Q,20.		;LINK=0
	MOVEI	J,1_8.		;1 BYTE
	TLO	J,1000		;8 BIT BYTES
	HRLZI	R,12._10.	;OP CODE FOR RST
	MOVEI	W,I

FISRS1:	PUSHJ	P,FICQI		;SEND IT OUT
	JRST	FISRS4		;NO ROOM, WAIT
	
FISRS2:	PUSHJ	P,FIRTMO	;RESET TIME OUT
	PUSHJ	P,FIWRST	;WAIT FOR REPLY
	PUSHJ	P,UFLS
	PUSH	P,T
	MOVE	TT,H		;HOST
	PUSHJ	P,FIFKQ		;DE QUEUE
	FICLRS			;ARGUMENT FOR SAME
	JRST	FISRS5
	PUSHJ	P,CLQDEL	;REMOVE FROM SYSTEM QUEUE
	1(T)
	AOS	-8(P)
FISRS5:	POP	P,T
	LDB	TT,T
	SKIPE	TT		;DOWN?
FISRS3:	AOS	-7(P)		;NO
	IRP	X,,[TT,I,Q,J,R,W,T]
	POP	P,X
	TERMIN
	POPJ	P,

FISRS6:	AOS	-7(P)
	JRST	FISRS3

;NO ROOM IN FICQ
FISRS4:	SKIPG	FICQFR
	PUSHJ	P,UFLS
	JRST	FISRS1

;WAIT FOR STATUS TO CHANGE
FIWRST:	PUSH	P,A
	LDB	A,T
	CAIE	A,1
	AOS	-1(P)
	JRST	POPAJ


;FIND A HOST IN FIRSTT
;IN=> H/HOST
;OUT=>T/BYTE PNTR   TT/BYTE   
FIFRST:	PUSH	P,I
	MOVE	TT,H
	IDIVI	TT,12.		;TT/WD  I/POSITION
	MOVEI	T,FIRSTT
	ADD	T,TT
	HRLI	T,440300	;T/BYTE PNTR
	IBP	T
	SOJG	I,.-1
	LDB	TT,T
	JRST	POPIJ


;RESET TIME OUT
FIRTMO:	PUSHJ	P,FISKQH	;HOST ALREADY IN Q?
	POPJ	P,		;YES
	PUSHJ	P,FIKQI		;GET A BLOCK
	JRST	FIRTO1		;NONE AVAILABLE
	AOS	C,TT		;FIRST USEABLE WORD
	MOVE	C,[JRST	FICLRS]	;RESTART LOC
	MOVEM	C,2(TT)
	MOVEM	H,3(TT)		;HOST
	PUSH	P,E
	PUSH	P,T
	MOVE	T,NTRSTO
	PUSHJ	P,CLQADD
	(TT)
	POP	P,T
	JRST	POPEJ

FIRTO1:	SKIPG	FIKQFR
	PUSHJ	P,UFLS
	JRST	FIRTMO

;SEARCH CLOCK Q FOR HOST
;NO SKIP IF THERE
FISKQH:	PUSH	P,A
	MOVEI	A,FIKQST
FISQH1:	SKIPG	A,(A)
	JRST	FISQH2
	CAME	H,4(A)
	JRST	FISQH1
	HRRZ	TT,3(A)
	CAIE	TT,FICLRS
	JRST	FISQH1
	JRST	.+2
FISQH2:	AOS	-1(P)
	JRST	POPAJ


;TIME OUT OCCURED
FICLRS:	PUSH	P,T
	PUSH	P,TT
	PUSH	P,H
	PUSHJ	P,FISKQ		;FIND IDLE BLOCK
	JRST	FICRS1		;NO
	MOVE	H,4(T)		;HOST
	PUSHJ	P,FIFRST	;FIND STATUS OF HOST
	CAIE	TT,1		;IS HE IN RST WAIT?
	JRST	FICRS1		;NO
	SETZM	TT		;YES, MARK HIM DOWN
	DPB	TT,T
FICRS1:	POP	P,H
	POP	P,TT
	POP	P,T
	JRST	CLQRET


;HOW MANY BYTES IN BUFFER - HMB
;IN-	Q/PNTR TO BUFFER
;	T/BYTES PER WORD
;OUT-	I/NO OF BYTES
;SKIPS IF WINS - ELSE BUFR MUNGED
FIHMB:	PUSH	P,E
	PUSH	P,R
	PUSH	P,A
	PUSH	P,B
	PUSH	P,TT
	MOVEI	A,FIBFLG/2	;MAX # OF SEGMENTS
	SETZM	I
	SKIPGE	(Q)
	JRST	FIHMB3
	HLRZ	B,(Q)	;B/ OFFSET OF FIRST GROUP
	ADDI	B,1(Q)	;B/  ADDR  "   "      "
FIHMB1:	SKIPGE	(B)	;EOF?
	JRST	FIHMB2	;YES
	HRRZ	TT,(B)	;LAST
	HLRZ	R,(B)	;FIRST
	SUB	TT,R	;L-F
	AOS	TT	;L-F+1=# THERE ARE
	ADD	I,TT
	HRRZ	E,(B)	;LAST
	IDIV	E,T	;OFFSET OF LAST USED
	AOS	B,E
	ADDI	B,1(Q)	;ADDR OF NEXT BLOCK, MAYBE
	MOVE	TT,B
	SUBI	TT,1(Q)	;IF <177 OK, ELSE RING TO 0
	CAIL	TT,FIBFLG
	MOVEI	B,1(Q)	;B/PNTR TO NEXT FREE
	MOVE	TT,B
	SUBI	TT,1(Q)	;REAL NEXT ONE
	HRRZ	E,(Q)	;NEXT FREE
	CAMN	TT,E	;ARE WE THERE YET?
	JRST	FIHMB3	;YES
	SOJL	A,FIHMB4	;JUMP IF LOOPED TOO MANY TIMES
	JRST	FIHMB1	;CONTINUE

FIHMB3:	AOS	-5(P)
FIHMB4:	POP	P,TT
	POP	P,B
	POP	P,A
	POP	P,R
	JRST	POPEJ


FIHMB2:	TLO	I,400000	;EOF
	JRST	FIHMB3


;HOW MANY BYTES IN FIRST GROUP
;IN-	Q/PNTR TO BUFR
;OUT-	B/PNTR TO GROUP
;	R/NO OF BYTES
;MUNGS TT
;SKIPS IF NO EOF
FIHMBF:	HLRZ	B,(Q)
	ADDI	B,1(Q)
	SKIPGE	(B)
	POPJ	P,
	HRRZ	R,(B)

	HLRZ	TT,(B)
	SUB	R,TT
	AOS	R
	JRST	POPJ1


;HERE IF CORE ALLOC FINISHED WITH BUF WE WANTED
FIPI6G:	MOVEM	17,FIP6SV+17
	MOVEI	17,FIP6SV
	BLT	17,FIP6SV+16
	MOVE	D,FIPDSV
	MOVE	T,FIPTSV
	JRST	FIIRG3







;PI LEVEL 6 - READ CODE
;MUNGS WITH HEADER
FIIPI6:	MOVEM	17,FIP6SV+17
	MOVEI	17,FIP6SV
	BLT	17,FIP6SV+16
FIIP61:	SKIPGE	FICHUK		;IF THIS IS -1, MEANS IGNORE THIS MSG (SET BY INPUT OVERFLOW)
	JRST	FIPSUX
	LDB	A,[340400,,FIIBUF]	;MSG TYPE
	CAIL	A,16.
	JRST	FIPER5	;MESS OUT OF RANGE
IFN FCNTEM, AOS FCIMP(A)
	JRST	@.+1(A)
	FIIREG	;0 - REG MSG
	FIGBLD	;1 - GARBLED LEADER
	FIGODN	;2 - IMP GOINNG DN
	FIMOBL	;3 - MSG ON BKLD LINK
	FIPSUX	;4 - NOP
	FIIRFM	;5 - RFNM
	FIPFLL	;6 - LINK TABLE FULL
	FIIHID	;7 - FOR HOST/IMP DOWN
	FIPFLL	;8 - ERR W/MSG IDEN.
	FIIHID	;9 - INCOMPLETE XMISSION
	FIPSUX	;10- C ON L
	FIPSUX	;11- CEASE TIMEOUT
	FIPSUX	;12- CEASE SENT
	FIPSUX	;13 - FOR EXPANSION
	FIPSUX	;14 - FOR EXPANSION
	FIPSUX	;15 - FOR EXPANSIION


;EXIT
FIPIEX:	HRLZI	17,FIP6SV
	BLT	17,17
	JRST	FIPICX


;PSEUDO EXIT (PSU X)
;FLUSH THE BUFR
FIPSUX:	SETZM	FICHUK
	SETZM	FIICON
	AOS	FIIMCT
	AOS	FINMCT
	PUSHJ	P,FILIST	;GO BACK TO LISTENING
	JRST	FIPIEX		;EXIT



;RFNM (REQUEST FOR NEXT MESSAGE) HANDLER
FIIRFM:	LDB	B,[141000,,FIIBUF]	;LINK
	JUMPG	B,FIRFM1	;JUMP IF NNOT CONTROL LINK
	LDB	B,[241000,,FIIBUF]	;HOST
	PUSHJ	P,FIDHST	;REMOVE HOST FROM LIST
	PUSHJ	P,FISTRT
	JRST	FIPSUX		;EXIT

FIRFM1:	MOVEI	TT,1	;LOOKING FOR WRITE SOC
	PUSHJ	P,FIPI6Z	;FIND THE LOSR
	JRST	FIPSUX	;CANT, MUST BE SPIRIOUS
IFN NCPDBG,[	PUSH	P,C
	PUSH	P,D
	IDIVI	C,FILSKT	;POSITION IN FISKT (1,2,3, ETC.)
	AOSN	FDRFTS(C)	;-1 MEANT WAITING_FOR_RFNM - 0 MEANS ONE_RECEIVED
	JRST	.+5		;WE WERE IN THE RIGHT STATE
	SETZM	FDRFTS(C)
	POP	P,D
	POP	P,C
	JRST	FIPER7
	POP	P,D
	POP	P,C
]
	MOVSI	A,400000	;SET UFLS BIT
	IORM	A,FISKT(C)
	HLRZ	A,FISKT+3(C)	;STATE
	CAIE	A,6	;RFNM_WAIT?
	JRST	FIPSUX	;NO
	MOVEI	A,5	;OPEN
	HRLM	A,FISKT+3(C)	;NEW STATE
	PUSHJ	P,FIINTU	;INTERUPT USR
	JRST	FIPSUX




;HERE IF RANDOM ERROR - FIX LOSR
FIPI6E:	SETOM	TT		;READ OR WRITE SOC
	PUSHJ	P,FIPI6Z	;FIND LOSR
	JRST	FIPSUX		;CANT
	MOVSI	A,600000
	IORM	A,FISKT(C)
	JRST	FIPSUX	;GO AWAY


;FIND & FLAG LAST LOSR
FIPFLL:	LDB	TT,[141000,,FIIBUF]	;LINK
	JUMPE	TT,FIPSUX
	MOVE	TT,FILLSR	;LAST LOSR
	JUMPL	TT,FIPSUX
	MOVSI	A,600000
	IORM	A,FISKT(TT)
	MOVEI	TT,4
	JRST	FISUPC




;GARBLED LEADER
FIGBLD:	SKIPGE	FI1GBL	;WANT TO IGNORE THIS GARBLED LEADER?
	JRST	FIPSUX
	MOVEI	TT,1
FISUPC:	MOVEM	TT,FIWERR
	MOVSI	TT,20
	IORM	TT,SUPCOR
	JRST	FIPSUX


;IMP GOING DOWN
FIGODN:	MOVEI	TT,2
	JRST	FISUPC


;MSG ON BLOCKED LINK
FIMOBL:	MOVEI	TT,3
	JRST	FISUPC




;HERE TO FIND LOSR - RETURNS IN C
	;TT WILL CONTAIN: +1 IF WRITE SOC
	;                  0 IF READ SOC
	;                 -1 IF EITHER
FIPI6Z:	LDB	A,[142000,,FIIBUF]	;SOURCE+LINK
	MOVSI	C,-FINSKT
FIP6Z1:	LDB	B,[102000,,FISKT(C)]	;S+L OF THIS LOSR
	CAME	A,B	;RIGHT ONE?
	JRST	FIP6Z3	;NO
	JUMPL	TT,FIP6Z2	;YES, READ OR WRITE!
	LDB	B,[420100,,FISKT+1(C)]	;1 IF WRITE
	CAMN	B,TT
	JRST	FIP6Z2	;WINNER
FIP6Z3:	ADDI	C,FILSKT-1
	AOBJN	C,FIP6Z1	;CONTINUE SEARCH
	POPJ	P,	;NOT FOUND (ERROR RETURN)
FIP6Z2:	HRRZS	C	;FOUND, ANS IN C
	AOS	(P)	
	POPJ	P,	;WINNING RETURN



;FIND LOSR GIVEN LINK
;Search for LiNK
;IN - A/LINK    OUT - C/LOSR    MUNGS - TT
FISLNK:	SUBI	A,2	;ENTRY #
	IMULI	A,FILSKT	;OFFSET
	LDB	TT,[102000,,FISKT(A)]	;S+L - LOSR
	LDB	C,[142000,,FIIBUF]	;S+L - MSG
	CAMN	C,TT
	AOS	(P)
	MOVE	C,A
	POPJ	P,
;REGULAR MESSAGES
FIIREG:	LDB	A,[141000,,FIIBUF]	;LINK
	LDB	H,[241000,,FIIBUF]	;HOST
IFN FCNTEM,[
	MOVE	TT,H	;HOST
	ROT	TT,1
	JUMPGE	TT,FCIN1
	AOS	FRMSGS(TT)
	JRST	FCIN2

FCIN1:	MOVSI	D,1
	ADDM	D,FRMSGS(TT)

;NOW HACK BITS
FCIN2:	MOVE	D,FIICNT
	MOVN	TT,FIIBUF-1(D)
	AND	TT,FIIBUF-1(D)
	JFFO	TT,.+1
	MOVEI	TT,-1(D)
	IMULI	TT,44	;# BITS IN WHOLE WORDS
	ADD	TT,I	;TOTAL
	ADDM	TT,FRBITS(H)
]
	JUMPE	A,FICNTL	;JUMP IF CONTROL LINK
	PUSHJ	P,FISLNK	;FIND LOSR
	JRST	FIIRG5		;CANT
	HLRZ	TT,FISKT+3(C)	;STATE
	CAIN	TT,11		;OPEN W/DATA
	JRST	FIIRG1
	CAIN	TT,5	;OPEN W/O DATA?
	JRST	FIIRG2	;YES
	CAIE	TT,7	;CLOSED BY LOSR?
	JRST	FIIRG4	;NO, PROTOCOL ERROR
	JRST	FIPSUX	;YES, GO AWAY
FIIRG2:	MOVEI	TT,11
	HRLM	TT,FISKT+3(C)
	PUSHJ	P,FIINTU	;INTERUPT LOSR
FIIRG1:	MOVE	T,C		;LOSR
	HRRZ	D,FISKT+3(C)	;BUF PNTR
	SKIPL	C,NETRAC(D)
	JRST	FIIRG3
;BUFFER MAY BE LOCKED!
IFE FILKOU,[
	TLNE	C,200000	;SKIP IF NOT 'ACTIVE AT MPG LEVEL'
	JRST	FIIRG3
]
IFN FILKOU,[
	TLNN	C,200000
	JRST	.+6
	MOVSI	TT,20000
	IORM	TT,NETRAC(D)
	MOVEM	D,FIPDSV
	MOVEM	T,FIPTSV
	JRST	FIPIEX
]
	MOVSI	TT,100000
	IORM	TT,NETRAC(D)	;ALERT CORE ALLOCATOR TO RETURN HERE
	MOVEM	D,FIPDSV
	MOVEM	T,FIPTSV
	JRST	FIPIEX	;EXIT FOR NOW, STILL PREGNANT
FIIRG3:	HRRZ	A,NETRAC(D)
	LDB	C,[IOSA,,IOBFT(A)]
	LSH	C,6		;MEM ADDR
	PUSHJ	P,FIGET
	JRST	FIPIEX		;GO AWAY


;DATA ON A NOT OPEN LINK
FIIRG4:	LDB	H,[241000,,FIIBUF]	;HOST
	MOVEM	H,FIWERR+1	;HOST - WHO DONIT
	MOVEI	TT,2		;ERROR #2
	MOVEM	TT,FIVERR
	MOVEI	TT,10.		;MSG #
	JRST	FISUPC		;CAUSE IT TO BE PRINTED

FIIRG5:	AOS	FIBDLK	;COUNT OF THESE
	JRST	FIPSUX	;OK, EXIT


;HERE IF INCOMPLETE XMISSION OR HOST DEAD
FIIHID:	LDB	B,[241000,,FIIBUF]	;HOST
	PUSHJ	P,FIMHD		;MARK HOST DOWN
FIIINC:	MOVEM	B,FIWERR+1
	MOVEI	TT,5
	MOVEM	TT,FIWERR
	MOVSI	TT,20
;	IORM	TT,SUPCOR
	SETOM	TT	;READ OR WRITE
	PUSHJ	P,FIDHST	;DELETE HOST FROM RFNM WAIT
	JRST	FIPSUX


;MARK HOST DOWN
;IN - B/HOST	MUNGES: TT
FIMHD:	PUSH	P,H
	PUSH	P,T
	MOVE	H,B
	PUSHJ	P,FIFRST
	SETZM	TT
	DPB	TT,T
	POP	P,T
	POP	P,H
	PUSH	P,E
	PUSH	P,C
	MOVSI	E,-FINSKT
FIMHD1:	LDB	TT,[201000,,FISKT(E)]	;HOST FOR THIS SOC
	CAME	TT,B
	JRST	FIMHD2
	HLRZ	TT,FISKT+3(E)
	CAIN	TT,13		;ONLY MARK LOSR ONCE
	JRST	FIMHD2
	CAIE	TT,7	;CLS_WAIT?
	JRST	FIMHD3		;NO
	PUSH	P,B
	MOVEI	TT,FILSKT
	SETZM	FISKT(B)
	AOS	B
	SOJG	TT,.-2
	POP	P,B
	PUSHJ	P,NTCS1E	;SEE IF EMPTY
	JRST	FIMHD2
FIMHD3:	MOVSI	TT,600000
	IORM	TT,FISKT(E)
	MOVEI	TT,13
	HRLM	TT,FISKT+3(E)	;STATE 13 - HOST DOWN
	MOVE	C,E
	PUSHJ	P,FIINTU	;INTERUPT LOSR
FIMHD2:	ADDI	E,FILSKT-1
	AOBJN	E,FIMHD1
	POP	P,C
	JRST	POPEJ



;INTERUPT LOSR
;NETWORK INTERUPT
FIINT:	MOVE	D,B	;7=>INR  8=>INS
	MOVE	B,H	;HOST
	LSH	B,8.
	ILDB	TT,A	;LINK
	SOJL	J,FIPSUX
	IOR	B,TT	;B/HOST-LINK
	SETZM	TT
	CAIE	D,7	;INR? 
	AOS	TT	;NO - INS, LOOKING FOR WRITE SOC
	EXCH	A,B
	MOVSI	C,-FINSKT
	PUSHJ	P,FIP6Z1	;FIND LOSR
	JRST	FIINT1
	EXCH	A,B
	MOVSI	TT,400000
	IORM	TT,FISKT+1(C)
	HLRZ	TT,FISKT+5(C)	;TT/CHNL
	HRRZ	B,FISKT+5(C)	;B/USER
	MOVEI	C,1
	LSH	C,@TT
	IORM	C,IFPIR(B)
	JRST	FICTL1

FIINT1:	EXCH	A,B
	JRST	FICTL1





;CONTROL LINK MESSAGE
FICNTL:	LDB	H,[241000,,FIIBUF]	;HOST
	MOVE	A,[441000,,FIIBUF+2]	;8 BIT BYTE PNTR
	LDB	J,[102000,,FIIBUF+1]	;J/BYTE COUNT
FICTL1:	ILDB	B,A	;B/OP CODE
	SOJL	J,FIPSUX	;NO MORE
	CAIL	B,14.
	JRST	FIPR1	;CONTROL ERROR MESSAGE
	JRST	@.+1(B)
	FINOP	;0
	FIRFC	;1
	FIRFC	;2
	FICLS	;3
	FIALL	;4
	FIGVB	;5
	FIRET	;6 
	FIINT	;7 - INR
	FIINT	;8 - INS
	FIECO	;9
	FINOP	;10 - ERP
	FIERR	;11
	FIRST	;12
	FIRRP	;13 - RRP

FIPR1:	MOVE	TT,[FIIBUF,,FIERBK]
	BLT	TT,FIERBK+7
	JRST	FIPER1

;ROUTINE TO CAUSE ERROR MSG ON SYS CONSOLE
FICMER:	MOVEM	B,FIVERR
	MOVEM	H,FIWERR+1	;HOST
	MOVEI	B,10.	;ERROR MSG #
	MOVEM	B,FIWERR
	MOVSI	B,20
	IORM	B,SUPCOR
	JRST	FIPSUX


;ROUTINES FOR ALL eRROR MSGS
IRPC FIXXX,,[123456789]
FIPER!FIXXX:	MOVEI	B,FIXXX
	JRST	FICMER
TERMIN



;NOP - 8 BIT NUL BYTE
FINOP:	JRST	FICTL1


;ERROR MESSAGES
FIERR:	MOVEI	TT,11.
	IBP	A	;FLUSH REST OF MESSAGE
	SOJL	J,FIPER3
	SOJG	TT,.-1
	AOS	FI1ERR
	JRST	FICTL1



;GVB

FIGVB:	ILDB	C,A		;C/LINK
	SOJL	J,FIPER3
	ILDB	D,A		;D/MSG FRAC
	SOJL	J,FIPER3
	ILDB	I,A		;I/BIT FRAC
	SOJL	J,FIPER3

	PUSH	P,A
	EXCH	C,A		;A/LINK
	DPB	H,[101000,,A]	;A/HOST-LINK
	MOVSI	C,-FINSKT
	MOVEI	TT,1		;LOOKING FOR WRITE SOC
	PUSHJ	P,FIP6Z1	;FIND HIM
	JRST	FIGVB3		;CANT
	POP	P,A		;C/LOSR

	PUSH	P,J		;NEED AC & AC+1 FOR MUL
	MOVE	W,FISKT+4(C)	;BIT ALLOC
	TRNE	I,200		;1.8 BIT MEANS GVB ALL
	JRST	FIGVB1		;YES
	MUL	R,I		;MUL BY NUMERATOR
	LSHC	R,-7		;DEVIDE BY DENOMINATOR

FIGVB1:	MOVE	TT,FISKT+4(C)	;W/ NUMBER OF BITS TO RETURN
	SUB	TT,W		;# TO KEEP
	MOVEM	TT,FISKT+4(C)

	HRRZ	R,FISKT+6(C)	;MSG ALLOC
	TRNE	D,200
	JRST	FIGVB2
	MUL	J,D
	LSHC	J,-7

FIGVB2:	HRRZ	TT,FISKT+6(C)	;R/# MSGS TO RETURN
	SUB	TT,R
	HRRM	TT,FISKT+6(C)
	MOVE	E,C		;E/LOSR
	LDB	Q,FILINK	;Q/LINK
	POP	P,J
	PUSHJ	P,FIMALL	;CREATE AN ALLOCATE
	MOVEI	TT,6		;OP CODE FOR RET
	DPB	TT,[341000,,FIPRFC+3]	;CONVERT ALLOC TO RET
	MOVEI	W,FIPRFC
	PUSHJ	P,FICQI		;SEND IT OUT
	JFCL
	JRST	FICTL1

FIGVB3:	POP	P,A
	JRST	FIPER4


;RET
;   TEMP IGNORED
FIRET:	MOVEI	TT,7
	IBP	A
	SOJL	J,FIPER3
	SOJG	TT,.-2
	JRST	FICTL1


;RESET  - WILL MARK HOST AS DOWN, CAUSING IOCERS
FIRST:	PUSHJ	P,FIFRST
	JUMPE	TT,FIRST2
	CAIE	TT,2
	JRST	FIRST2
FIRST1:	EXCH	B,H
	PUSHJ	P,FIMHD
	EXCH	B,H
	; MAKE A RRP IN FIPRFC

FIRST2:	MOVEI	TT,2
	DPB	TT,T
	MOVEI	TT,3	;# WORDS
	MOVEM	TT,FIPRFC
	MOVE	TT,H	;HOST
	LSH	TT,20.
	MOVEM	TT,FIPRFC+1
	MOVEI	TT,1	;1 BYTE
	LSH	TT,8.
	TLO	TT,1000	;8 BIT BYTES
	MOVEM	TT,FIPRFC+2
	MOVEI	TT,13.	;OP CODE FOR RRP
	LSH	TT,28.
	MOVEM	TT,FIPRFC+3
	MOVEI	W,FIPRFC
	PUSHJ	P,FICQI
	AOS	FI1ERR
	JRST	FICTL1


;RESET REPLY
FIRRP:	PUSHJ	P,FIFRST	;FIND ENTRY
	JUMPE	TT,FIPSUX	;STATE 0 ILLEAGLE
	CAIG	TT,1
	MOVEI	TT,2
	DPB	TT,T		;MARK HIM UP
	JRST	FICTL1






;RTS AND STR
;B/ OP CODE	Q/LINK OR BYTE SIZE	H/HOST
;NEXT 4 BYTES ARE FOR SOC
FIRFC:	SETZB	D,I
	MOVE T,[401000,,D]	;D/ FOR SOC
	MOVEI	TT,4
	ILDB	C,A
	SOJL	J,FIPER3
	IDPB	C,T
	SOJG	TT,.-3
	MOVE	T,[401000,,I]	;I/LOC SOC
	MOVEI	TT,4
	ILDB	C,A
	SOJL	J,FIPER3
	IDPB	C,T
	SOJG	TT,.-3
	ILDB	Q,A	;LINK OR BYTE SIZE
	SOJL	J,FIPER3
	PUSHJ	P,FISSOC	;FIND LOSR
	JRST	FIRFC2		;CANT, PUT IT IN THE QUEUE
  ;C/ LOSR
FIRFC1:	HLRZ	TT,FISKT+3(C)	;STATE
	CAIN	TT,1		;LISTEN
	JRST	FIRFCL		;YES
	CAIN	TT,4		;RFC-SENT?
	JRST	FIRFCS		;YES
	JRST	FIRFCQ		;NO, QUEUE IT



;MAYBE HE'S LISTENING
FIRFC2:	PUSHJ	P,FISLSC
	JRST	FIRFCQ		;NO
	JRST	FIRFC1		;YES



;RFC RCVD WHILE LISTENING
;B/OP CODE     C/LOSR     D/FOR SOC     I/LOC SOC     H/HOST
;Q/LINK OR BYTE SIZE
FIRFCL:	MOVE	E,C	;E/ALSO LOSR
	DPB	H,FIFHST
	DPB	D,FIFSOC
	CAIN	B,1	;RTS?
	DPB	Q,FILINK ;YES
	MOVEI	TT,2	;STATE=2=RFC-RCVD
	HRLM	TT,FISKT+3(C)
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	JRST	FICTL1



;RFC RCVD IN REPLY TO RFC
;ACS AS ABOVE
FIRFCS:	MOVE	E,C	;E ALSO LOSR
	CAIE	B,1	;RTS?
	JRST	FIRCS1	;NO, STR
	DPB	Q,FILINK
	JRST	FIRCS2

FIRCS1:	LDB	Q,FILINK
	MOVEI	R,FIMSGS	;MSGS
	MOVEI	W,FIBITS	;BITS
	PUSHJ	P,FISALL	;SEND ALLOC

FIRCS2:	MOVEI	TT,5
	HRLM	TT,FISKT+3(C)
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	JRST	FICTL1


;HERE TO PUT RFC IN QUEUE
;ACS AS ABOVE
FIRFCQ:	MOVSI	T,-FIDMCT	;CHECK DEMON TABLE
FIRFQ1:	CAME	I,FIDMTB(T)	;IS THIS THE RIGHT ENTRY?
	AOJA	T,FIRFQ2	;NO CONTINUE
	PUSH	P,A
	MOVE	A,FIDMTB+1(T)
	PUSHJ	P,DEMSIG
	AOS	FIDMLS		;NO ROOM IN TABLE
	POP	P,A
	JRST	.+2
FIRFQ2:	AOBJN	T,FIRFQ1
	PUSHJ	P,FIFRST	;STATE OF RST IN TT
	SOS	TT		;NOW -1,0,+1
	JUMPE	TT,FICTL1	;RST ON THE WAY *** IGNORE THIS RFC ***
	JUMPG	TT,.+3		;CONTINUE
	MOVEI	TT,2		;MARK HIM UP
	DPB	TT,T
	PUSHJ	P,FIPQI		;RETURNNS TT PNTR TO BLOCK
	MOVEM	D,1(TT)
	MOVEM	I,2(TT)
	MOVEM	H,3(TT)
	HRLM	Q,3(TT)
	JRST	FICTL1




;CLS
;B/OP CODE     H/HOST
FICLS:	SETZB	D,I
	MOVE	T,[401000,,D]	;D/ FOR HOST
	MOVEI	TT,4
	ILDB	C,A
	SOJL	J,FIPER3
	IDPB	C,T
	SOJG	TT,.-3
	MOVE	T,[401000,,I]	;I/LOC SOC
	MOVEI	TT,4
	ILDB	C,A
	SOJL	J,FIPER3
	IDPB	C,T
	SOJG	TT,.-3
	PUSHJ	P,FISSOC	;FIND LOSR - ANS IN C
	JRST	FICLSQ		;CANT LOOK IN Q
	HLRZ	TT,FISKT+3(C)	;STATE
	CAILE	TT,13
	JRST	4,FICTL1
	JRST	@.+1(TT)
	FICTL1	;0
	FICTL1	;1
	FI3CLS	;2
	FICTL1	;3
	FI0CLS	;4
	FI5CLS	;5
	FI5CLS	;6
	FIKCLS	;7
	FICTL1	;10
	FI8CLS	;11
	FICTL1	;12
	FICTL1	;13

FICLSQ:	MOVE	TT,I	;TT/ LOC SOC
	PUSHJ	P,FIFPQ
	JRST	FICTL1	;NONE
	MOVE	W,T
	PUSHJ	P,FIPCL1	;SEND HIM A CLOSE
	JRST	FICLSQ


;SEND A  CLS FROM LOSR IN (C)
FISCLS:	PUSHJ	P,FIPCLS	;CLS MSG IN FIPRFC 
	MOVEI	W,FIPRFC
	PUSHJ	P,FICQI
	JFCL			;TOO BAD IF LOSES
	JRST	FICTL1


;GO TO STATE 3, SEND CLS
FI3CLS:	MOVEI	TT,3
	HRLM	TT,FISKT+3(C)
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	JRST	FISCLS		;SEND CLS



;GO TO  STATE ZERO, SEND CLS
FI0CLS:	HRRZS	FISKT+3(C)	;STATE 0
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	JRST	FISCLS



;KILL SOCKET
FIKCLS:	MOVE	T,C
	PUSH	P,E
	MOVE	E,C
;	PUSHJ	P,FIKRST		;KILL HOST?
	POP	P,E
	MOVEI	TT,FILSKT
	SETZM	FISKT(T)
	AOS	T
	SOJG	TT,.-2
IFN NCPDBG,[
	PUSH	P,C
	PUSH	P,D
	IDIVI	C,FILSKT
	SETZM	FDRFTS(C)	;RESET DEBUG SWITCH
	POP	P,D
	POP	P,C
]
	PUSHJ	P,NTCS1E	;TEST TO SEE IF ANY MORE ACTIVE
	JRST	FICTL1


;IF  READ, GO TO STATE  10 IF DATA PRES.,ELSE GO TO STATE 0
FI5CLS:	MOVE	TT,FISKT+1(C)
	TLNE	TT,200000	;SKIP IF READ
	JRST	FI5CL1
FI8CLS:	HRRZ	T,FISKT+3(C)	;BUF PNTR
	HRRZ	B,NETRAC(T)
	LDB	Q,[IOSA,,IOBFT(B)]	;Q IS MEM ADR
	LSH	Q,6
	SKIPGE	(Q)
	JRST	FI5CL2	;NO NEXT ACTIVE, MUST BE NO DATA
	MOVEI	TT,10
	HRLM	TT,FISKT+3(C)
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	HRRZ	TT,(Q)	;NEXT FREE
	ADDI	TT,(Q)	;TT/ADDR OF NEXT FREE-1
	SETOM	1(TT)
	AOS	(Q)	;UPDATE NEXT FREE
	JRST	FISCLS


FI5CL1:	HRRZS	FISKT+3(C)	;STATE 0
	PUSHJ	P,FIINTU	;INTERUPT LOSR
	JRST	FISCLS


FI5CL2:	MOVEI	TT,1	;THIS BUFR WILL BE MARKED AS
	MOVEM	TT,(Q)	;CONTAINING 1 BYTE,
	SETOM	1(Q)	;AN EOF.
	JRST	FI5CL1	;PUT IN STATE 0, INTERUPT HIM




;ECO REPLYER
FIECO:	MOVEI	TT,3	;WD CNT
	MOVEM	TT,FIPRFC
	MOVE	TT,H	;HOST, LINK 0
	LSH	TT,20.
	MOVEM	TT,FIPRFC+1
	MOVEI	TT,2	;# BYTES
	LSH	TT,8.
	TLO	TT,1000	;8  BIT BYTES
	MOVEM	TT,FIPRFC+2
	MOVEI	TT,10.	;ERP
	LSH	TT,28.
	ILDB	W,A
	SOJL	J,FIPER3
	LSH	W,20.
	IOR	TT,W
	MOVEM	TT,FIPRFC+3
	MOVEI	W,FIPRFC
	PUSHJ	P,FICQI
	JFCL
	JRST	FICTL1




;RECEIVE ALLOCATE
FIALL:	SETZB	B,W
	MOVE	T,H	;HOST
	LSH	T,8.
	ILDB	TT,A	;LINK
	SOJL	J,FIPER3
	IOR	T,TT
	MOVEI	TT,2
	MOVE	I,[201000,,B]
	ILDB	D,A
	SOJL	J,FIPSUX
	IDPB	D,I
	SOJG	TT,.-3	;B/ MSG ALLOC
	MOVEI	TT,4
	MOVE	I,[401000,,W]
	ILDB	D,A
	SOJL	J,FIPER3
	IDPB	D,I
	SOJG	TT,.-3	;W/SPACE ALLOC
	MOVSI	C,-FINSKT
FIALL1:	LDB	TT,[102000,,FISKT(C)]	;S+L
	CAME	TT,T	;RIGHT?
	JRST	FIALL2	;NO
	MOVE	TT,FISKT+1(C)
	TLNN	TT,200000	;SKIP IF WRITE
	JRST	FIALL2	;NO, READ
	HLRZ	TT,FISKT+3(C)	;STATE
	CAIE	TT,5		;OPEN - OK
	CAIN	TT,6		;RFNM - OK
	JRST	FIALL3		;WIN
FIALL2:	ADDI	C,FILSKT-1
	AOBJN	C,FIALL1
   ;CANT FIND
	JRST	FIPER6
FIALL3:	ADDM	W,FISKT+4(C)
	ADDM	B,FISKT+6(C)
	JRST	FICTL1

;GENERATE INTERUPT FOR LOSR
FIINTU:	PUSH	P,A
	PUSH	P,TT
	PUSH	P,U
	HRRZ	U,FISKT+5(C)	;U/LOSR
	HLRZ	A,FISKT+5(C)	;A/CHNL
	MOVEI	TT,1
	LSH	TT,@A		;POSITIONED
	IORM	TT,IFPIR(U)
	POP	P,U
	POP	P,TT
	JRST	POPAJ



;	INTERRUPT LEVEL WRITE
;
FIWINT:	CONO	FI,FIOUT+FIREST	;PUT OUTPUT TO REST
	MOVEM	17,FIP6SV+17
	MOVEI	17,FIP6SV
	BLT	17,FIP6SV+16
	SKIPG	FINOPF	;WANT TO SEND ANY NOPS?
	JRST	FIWIN6	;GUESS NOT
	SOS	FINOPF
	MOVEI	C,NETNOP
	PUSHJ	P,FIPUT
	JRST	FIWIN5
FIWIN6:	SETZM	FINUPY	;UFLSed ON IN OPEN CODE
	SKIPL	FIW15S
	JRST	FIWIN5
	PUSHJ	P,FIWCM	;SKIP IF NO CONTROL MSGS TO WRITE
	JRST	FIWIN5
	PUSHJ	P,FIWOQ	;RETURNS  E/LOSR  D/BUFR
	JRST	FIWIN5		;NONE
	MOVEM	 E,FILLSR
IFN NCPDBG,[	PUSH	P,E
	PUSH	P,TT
	IDIVI	E,FILSKT	;POSITION IN FISKT (1,2,3, ETC.)
	SKIPE	TT	;TT HAS REMAINDER OF DIVISION
	JRST	4,.+1	;MEANS E WAS NOT A LEGITIMATE SOCKET OFFSET
	SKIPE	FDRFTS(E)	;0 MEANS NOT WAITING FOR RFNM
	JRST	4,.+1
	SOS	FDRFTS(E)	;-1 MEANS WAITING_FOR_RFNM
	POP	P,TT
	POP	P,E
]

; HERE TO OUTPUT MSG
FIWIN4:	MOVE	A,NETRAC(D)	;GET MEM PNTR
	LDB	C,[IOSA,,IOBFT(A)]	;GET RREAL MEM BLOCK
	LSH	C,6		;GET REAL MEM ADDR
	SKIPL	FISKT+2(E)	;32 BIT MODE SET?
	JRST	FIWIN3	;NO
	SETOM	FI32B	;YES
IFN NCPDBG,[	PUSH	P,C
	PUSHJ	P,FDCVB2
	POP	P,C
	]
	JRST	FIWIN7
FIWIN3:	SETZM	FI32B	;NO, CLEAR IT
IFN NCPDBG,[	PUSH	P,C
	PUSHJ	P,FDCVB6
	POP	P,C
	]
FIWIN7:	PUSHJ	P,FIPUT	;OUT PUT MSG
; NOW DISMISS
FIWIN5:	HRLZI	17,FIP6SV
	BLT	17,17
	JRST	FIPICX

;
;
;	FLAG LOSRS WHEN
;	SOME ERROR (IN A) OCCURS
;
FIDFIX:	PUSH	P,C
	PUSH	P,B
	MOVSI	C,-FINSKT
	MOVSI	B,700000
FIDFX1:	IORM	B,FISKT(C)	;UFLS AND ERROR - WILL GET IOC ERR
	HRRZS	FISKT+3(C)	;STATE 0 - (STATE IN LH)
	PUSHJ	P,FIINTU	;INTERRUPT LOSR
	ADDI	C,FILSKT-1
	AOBJN	C,FIDFX1
	MOVEM	A,FIWERR
	MOVSI	C,20
	IORM	C,SUPCOR
	POP	P,B
	JRST	POPCJ

EBLK


.INSRT	ITSIMP >

