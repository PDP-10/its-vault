;;; -*- Mode:LISP; Package:MACSYMA -*-

;	** (c) Copyright 1980 Massachusetts Institute of Technology **

(DECLARE (GENPREFIX ED)
	 (SPECIAL ST CR TAB FF VT BSP ALT RUBOUT COMMAND WINDOW ^W ^S
		  BEFORE AFTER AVANT APRES GSTRING ^R $CURSOR REPRINT
		  POS ERRSET ERRBREAK2 OLDST ^HMSG EDITMSG
		  STATE-PDL BACKRUB READING)
	 (*EXPR REPRINT)
	 (FIXNUM WINDOW AVANT APRES COUNT SCOUNT LENGTH CNT N (TYI1))
	 (NOTYPE (PRIN NOTYPE FIXNUM) (CHARACTER FIXNUM) (REV* FIXNUM)))

(DEFUN READ1UCCH MACRO (L) '(READ1CH))  ; temporary

(SETQ EDITMSG '(|In editor:  (Type just <Alt><Alt> to exit.)/
| . |In editor:/
|) $CURSOR '&$ WINDOW -1 *NOPOINT (SETQ IBASE (SETQ BASE (+ 5 5))))

(DEFUN EDIT* (AFTER)
  (LET ((STATE-PDL (CONS 'EDIT STATE-PDL)))
       (PROG (COMMAND STRING TEST N BEFORE AVANT APRES SSTRING ISTRING GSTRING COUNT
	      FLAG ^R REPRINT POS RSSTRING RISTRING LENGTH CLEARP
	      GRINDP MFRP QUIETP)
	     (COND (^S (SETQ ^W NIL ^S NIL)))
	     (SETQ AVANT 0 APRES (LENGTH AFTER))
	     (TERPRI)
	     (COND ((CAR EDITMSG)
		    (PRINC (CAR EDITMSG)) (SETQ EDITMSG (CONS NIL (CDR EDITMSG))))
		   (T (PRINC (CDR EDITMSG))))
	     (PRINC (STRIPDOLLAR $CURSOR))
	     (PRAFTER)
	A    (SETQ POS (CURSORPOS))
	RDLOOP
	     (SETQ TEST (ASCII (SETQ N ((LAMBDA (READING) (TYI1)) T))))
		; Besides doing a (TYI), TYI1 also converts lower-case to upper-case.
	     (COND ((AND (NULL COMMAND) (OR (EQ TEST '/ ) (EQ TEST CR) (EQ TEST TAB)
					    (EQ TEST '/;) (EQ TEST '$)))
		    (GO RDLOOP))
		   ((EQ TEST ALT)
		    (COND ((AND (EQ (CAR COMMAND) ALT) (NULL (CDR COMMAND))) (GO EXIT))
			  ((AND (EQ (CAR COMMAND) ALT)
				(OR (NOT (EQ (CADR COMMAND) '\))
				    (AND (CDDR COMMAND) (EQ (CADDR COMMAND) '\))))
			   (SETQ COMMAND (NREVERSE COMMAND))
			   (SETQ REPRINT NIL) (GO LOOP))))
		   ((EQ TEST VT) (GO VT))
		   ((EQ TEST BSP)
		    (COND (BACKRUB (COND (COMMAND (SETQ COMMAND (CDR COMMAND)))) (GO RDLOOP))
			  (T (PRINC ^HMSG) (GO VT))))
		   ((EQ TEST FF) (FORMFEED) (PRTEXT) (GO VT))
		   ((EQ TEST '?)
		    (COND ((AND (EQ (CAR COMMAND) '?)
				(OR (NOT (AND (CDR COMMAND) (EQ (CADR COMMAND) '\)))
				    (AND (CDDR COMMAND) (EQ (CADDR COMMAND) '\))))
			   (SETQ COMMAND NIL) (TERPRI) (GO RDLOOP))))
		   ((OR (EQ TEST CR) (EQ TEST TAB)))
		   ((< N 32.) (SETQ REPRINT T) (GO RDLOOP))  ; Test for control chars.
		   ((AND (EQ TEST '\) (SETQ COMMAND (CONS TEST COMMAND) TEST (READCH)) NIL))
		   ((EQ TEST RUBOUT) (RUBOUT* COMMAND)
				     (COND (COMMAND (SETQ COMMAND (CDR COMMAND))))
				     (GO RDLOOP)))
	     (SETQ COMMAND (CONS TEST COMMAND))
	     (GO RDLOOP)
	VT   (REPRINT COMMAND (EQ TEST FF)) (GO RDLOOP)
	LOOP (COND ((NULL COMMAND) (PRTEXT) (GO A))
		   ((OR (EQ (SETQ TEST (READ1UCCH)) ALT) (EQ TEST '/ )
			(EQ TEST CR) (EQ TEST TAB))
		    (GO LOOP)))
	     (SETQ COUNT 0 STRING NIL FLAG NIL CLEARP NIL GRINDP NIL MFRP NIL)
	     (COND ((EQ TEST '-) (GO MINUS))
		   ((GET TEST 'NUMBER) (SETQ FLAG T))
		   (T (SETQ COUNT 1) (GO X)))
	NUM  (SETQ STRING (CONS TEST STRING))
	     (COND ((GET (SETQ TEST (READ1UCCH)) 'NUMBER) (GO NUM)))
	     (SETQ COUNT (READLIST (NREVERSE STRING)) STRING NIL)
	X1   (COND ((OR (EQ TEST '/ ) (EQ TEST CR) (EQ TEST TAB))
		    (SETQ TEST (READ1UCCH)) (GO X1))
		   ((MEMQ TEST '(B G I J P T V /( /) [ ] M Y Q Z))
		    (TERPRI) (COND ((NULL FLAG) (PRINC '-))) (GO NOGO1))
		   ((AND (NULL FLAG) (PLUSP COUNT)) (GO MX))
		   ((OR (PLUSP COUNT) (EQ TEST 'W)))
		   ((MEMQ TEST '(L K)) (GO MX))
		   (T (GO NOGO)))
	X    (COND ((MEMQ TEST '(J T)) (GO T))
		   ((EQ TEST 'C) (GO C))
		   ((EQ TEST 'R) (GO R))
		   ((EQ TEST 'I) (GO SI))
		   ((EQ TEST 'G)
		    (COND ((MEMQ (SETQ TEST (READ1UCCH)) '(V F)) (SETQ GRINDP T) (GO Y))
			  ((EQ TEST 'R) (INSERT (APPEND GSTRING NIL)) (GO LOOP))
			  (T (SETQ FLAG 'G) (GO NOGO))))
		   ((EQ TEST 'B) (GO B))
		   ((EQ TEST 'P) (GO LOOP))
		   ((EQ TEST 'Q)
		    (COND ((CDR COMMAND) (GO NOGO))) (SETQ QUIETP T) (GO EXIT))
		   ((EQ TEST 'V) (SETQ WINDOW -1) (GO LOOP))
		   ((EQ TEST 'W) (SETQ WINDOW COUNT) (GO LOOP))
		   ((MEMQ TEST '(D S K L))
		    (COND ((ZEROP APRES) (GO WHAT))
			  ((EQ TEST 'D) (DELETE* T (MIN COUNT APRES)))
			  ((EQ TEST 'S) (SETQ FLAG T) (GO SI))
			  ((EQ TEST 'K) (KILL* COUNT))
			  (T (LINE* COUNT)))
		    (GO LOOP))
		   ((EQ TEST 'Y)
		    (COND ((MEMQ (SETQ TEST (READ1UCCH)) '(V F)) (GO Y))
			  (T (SETQ FLAG (COND (GRINDP 'G) (T 'Y))) (GO NOGO))))
		   ((MEMQ TEST '(/( [))
		    (COND ((ZEROP AVANT) (GO WHAT)) ((NULL (MOVE TEST NIL NIL)) (GO ERR)))
		    (GO LOOP))
		   ((MEMQ TEST '(/) ]))
		    (COND ((ZEROP APRES) (GO WHAT)) ((NULL (MOVE TEST T NIL)) (GO ERR)))
		    (GO LOOP))
		   ((EQ TEST 'M)
		    (SETQ FLAG 'M)
		    (COND ((EQ (SETQ TEST (READ1UCCH)) 'Y) (SETQ CLEARP T) (GO X))
			  ((EQ TEST 'G) (SETQ TEST 'Y GRINDP T CLEARP T) (GO X))
			  ((EQ TEST 'F) (SETQ MFRP T) (GO X))
			  ((MEMQ TEST '(/) ]))
			   (COND ((ZEROP APRES) (GO WHAT))
				 ((NULL (MOVE TEST T T)) (GO ERR)))
			   (GO LOOP))
			  ((MEMQ TEST '(/( [))
			   (COND ((ZEROP AVANT) (GO WHAT))
				 ((NULL (MOVE TEST NIL T)) (GO ERR)))
			   (GO LOOP))
			  (T (GO NOGO))))
		   ((EQ TEST 'Z)
		    (COND ((EQ (SETQ TEST (READ1UCCH)) 'J) (GO B)) (T (SETQ FLAG 'Z) (GO NOGO))))
		   ((AND (EQ TEST 'F) (PROG2 (SETQ FLAG 'F) (EQ (SETQ TEST (READ1UCCH)) 'R)))
		    (GO FR))
		   (T (GO NOGO)))
	MINUS(COND ((GET (SETQ TEST (READ1UCCH)) 'NUMBER) (SETQ FLAG NIL) (GO NUM)))
	     (SETQ COUNT 1)
	MX   (COND ((EQ TEST 'C) (GO R))
		   ((EQ TEST 'R) (GO C))
		   ((MEMQ TEST '(D S K L))
		    (COND ((ZEROP AVANT) (COND ((NOT (ZEROP COUNT)) (PRINC '|/
-|) (GO WHAT1))))	  ((EQ TEST 'D) (DELETE* NIL (MIN COUNT AVANT)))
			  ((EQ TEST 'S) (SETQ FLAG NIL) (GO SI))
			  ((EQ TEST 'K) (MKILL* COUNT))
			  (T (MLINE COUNT)))
		    (GO LOOP))
		   (T (PRINC '|/
-|) (GO NOGO1)))
	SI   (COND ((AND (NULL (SETQ STRING (READSTRING)))
			 (NULL (SETQ STRING (COND ((EQ TEST 'S) SSTRING) (T ISTRING))))))
		   ((EQ TEST 'S)
		    (COND ((NULL (SEARCH (SETQ SSTRING STRING) FLAG COUNT NIL)) (GO ERR))))
		   (T (INSERT (REVERSE (SETQ ISTRING STRING)))))
	     (GO LOOP)
	FR   (COND ((ZEROP APRES) (GO WHAT))
		   ((NULL (SETQ STRING (READSTRING)))
		    (COND ((NULL RSSTRING) (GO LOOP))))
		   (T (SETQ RSSTRING STRING RISTRING (AND COMMAND (READSTRING)))))
	     (SETQ LENGTH (LENGTH RSSTRING))
	FR1  (COND ((NULL (SEARCH RSSTRING T 1 MFRP)) (COND (MFRP (GO LOOP))) (GO ERR)))
	     (DELETE* NIL LENGTH)
	     (COND (RISTRING (INSERT (REVERSE RISTRING))))
	     (COND ((AND (NOT MFRP) (ZEROP (SETQ COUNT (1- COUNT)))) (GO LOOP)))
	     (GO FR1)
	C    (COND ((NOT (< APRES COUNT)) (CHARACTER COUNT) (GO LOOP)))
	B    (COND ((PLUSP APRES) (CHARACTER APRES)))
	     (GO LOOP)
	R    (COND ((NOT (< AVANT COUNT)) (REV* COUNT) (GO LOOP)))
	T    (COND ((PLUSP AVANT) (REV* AVANT)))
	     (GO LOOP)
	Y    (COND ((NULL (YANK TEST CLEARP GRINDP)) (GO ERR)) (CLEARP (GO T)))
	     (GO LOOP)
	WHAT (TERPRI)
	WHAT1(COND ((NOT (= COUNT 1)) (PRINC COUNT)))
	     (COND ((MEMQ FLAG '(F M)) (PRINC FLAG)))
	     (PRINC TEST) (PRINC '| impossible|) (GO ERR)
	NOGO (TERPRI)
	NOGO1(COND ((NOT (= COUNT 1)) (PRINC COUNT)))
	     (COND (CLEARP (PRINC 'M)))
	     (COND ((MEMQ FLAG '(F Y G M Z)) (PRINC FLAG)))
	     (PRINC TEST) (PRINC '| incorrect command|)
	ERR  (SETQ COMMAND NIL) (PRTEXT) (GO A)
	EXIT (COND ((PLUSP APRES) (CHARACTER APRES)))
	     (SETQ ST BEFORE) (RETURN QUIETP))))

(DEFUN READ1CH NIL (PROG2 NIL (CAR COMMAND) (SETQ COMMAND (CDR COMMAND))))

(DEFUN READ1UCCH NIL  ; Read one upper case character
 (PROG2 NIL
        ((LAMBDA (N) (COND ((AND (> N 96.) (< N 123.)) (ASCII (- N 32.))) (T (CAR COMMAND))))
	 (GETCHARN (CAR COMMAND) 1))
        (SETQ COMMAND (CDR COMMAND))))

(DEFUN PRTEXT NIL (PRBEFORE) (PRINC (STRIPDOLLAR $CURSOR)) (PRAFTER))

(DEFUN PRBEFORE NIL
       (TERPRI)
       (COND ((OR (MINUSP WINDOW) (< AVANT WINDOW))
	      (PRIN (REVERSE BEFORE) AVANT))
	     (T ((LAMBDA (X1 X2) (DO N WINDOW (1- N) (ZEROP N)
				     (SETQ X2 (CONS (CAR X1) X2) X1 (CDR X1)))
				 (PRIN X2 WINDOW))
		 BEFORE NIL))))

(DEFUN PRAFTER NIL
       (PRIN AFTER (COND ((OR (MINUSP WINDOW) (< APRES WINDOW)) APRES) (T WINDOW)))
       (TERPRI))

(DEFUN PRIN (X1 N) (DO N N (1- N) (ZEROP N) (PRINC (CAR X1)) (SETQ X1 (CDR X1))))

(DEFUN READSTRING NIL
       (PROG (CHAR STRING)
	LOOP (COND ((EQ (SETQ CHAR (READ1CH)) '\)
		    (SETQ STRING (CONS '\ STRING)) (SETQ CHAR (READ1CH)))
		   ((EQ CHAR ALT) (RETURN STRING))
		   ((AND (MEMQ CHAR '(/; $)) (NOT (EQ (CAR STRING) '\)))
		    (SETQ STRING (CONS '\ STRING))))
	     (SETQ STRING (CONS CHAR STRING))
	     (GO LOOP)))

(DEFUN DELETE* (FLAG COUNT)
       (PROG (SAVE)
	     (SETQ SAVE (COND (FLAG (SETQ APRES (- APRES COUNT)) AFTER)
			      (T (SETQ AVANT (- AVANT COUNT)) BEFORE))
		   GSTRING NIL)
	LOOP (SETQ GSTRING (CONS (CAR SAVE) GSTRING) SAVE (CDR SAVE))
	     (COND ((PLUSP (SETQ COUNT (1- COUNT))) (GO LOOP))
		   (FLAG (SETQ AFTER SAVE GSTRING (NREVERSE GSTRING)))
		   (T (SETQ BEFORE SAVE)))
	     (RETURN NIL)))

(DEFUN YANK (TEST CLEARP GRINDP)
       (PROG (ST ITEM)
	     (COND ((NULL (SETQ ST (READSTRING))) (RETURN T))
		   ((AND (EQ TEST 'V) (EQUAL ST '(^))) (SETQ ITEM (REVERSE OLDST)) (GO END))
		   ((NULL (SETQ ITEM (PARSE2))) (RETURN NIL)))
	     (SETQ ITEM (CAR ITEM))
	     ((LAMBDA (ERRSET)
	       (COND ((NULL
		       (SETQ ITEM (ERRSET
				   (PROG2 (SETQ ITEM (COND ((EQ TEST 'F) (CONSFUNDEF ITEM NIL NIL))
							   (T (STRMEVAL ITEM))))
					  (COND (GRINDP (MAKSTRGRIND ITEM))
						(T (MAKSTRING ITEM)))))))
		      (RETURN NIL))))
	      'ERRBREAK2)
	     (SETQ ITEM (CAR ITEM))
	END  (COND (CLEARP (SETQ BEFORE NIL AFTER NIL AVANT 0 APRES 0)))
	     (INSERT ITEM)
	     (RETURN T)))

(DEFUN SEARCH (STRING FLAG COUNT MFRP)
       (PROG (PROV SAVE SCOUNT LENGTH)
	     (SETQ LENGTH (LENGTH STRING) SCOUNT 0)
	     (COND (FLAG (SETQ STRING (REVERSE STRING))))
	START(SETQ PROV STRING SAVE (COND (FLAG AFTER) (T BEFORE)))
	LOOP (COND ((NULL PROV) (COND (FLAG (CHARACTER LENGTH)) (T (REV* LENGTH)))
				(COND ((ZEROP (SETQ COUNT (1- COUNT))) (RETURN T)))
				(SETQ SCOUNT 0) (GO START))
		   ((NULL SAVE)
	     	    (COND ((NOT (ZEROP SCOUNT))
			   (COND (FLAG (REV* SCOUNT)) (T (CHARACTER SCOUNT)))))
		    (COND ((NOT MFRP) (PRINC '|/
Search failed|)))   (RETURN NIL))
		   ((NOT (EQ (CAR PROV) (CAR SAVE)))
		    (COND (FLAG (CHARACTER 1)) (T (REV* 1)))
		    (SETQ SCOUNT (1+ SCOUNT)) (GO START)))
	     (SETQ PROV (CDR PROV) SAVE (CDR SAVE))
	     (GO LOOP)))

(DEFUN MOVE (TEST FLAG DELP)
       (PROG (N SCOUNT SAVE OTHER)
	     (SETQ N 0 SCOUNT 1 SAVE (COND (FLAG AFTER) (T BEFORE))
		   OTHER (CDR (ASSQ TEST '((/( . /)) ([ . ]) (/) . /() (] . [)))))
	LOOP (COND ((NULL SAVE)
		    (COND ((ZEROP N) (PRINC '|/
No |) (PRINC OTHER) (PRINC '|s encountered|))
			  (T (TERPRI) (PRINC N)
			     (PRINC '| too few |) (PRINC TEST) (PRINC '|s|)))
		    (RETURN NIL))
		   ((EQ (CAR SAVE) OTHER) (SETQ N (1+ N)))
		   ((EQ (CAR SAVE) TEST)
		    (COND ((ZEROP N) (TERPRI) (PRINC TEST)
				     (PRINC '| seen before |) (PRINC OTHER) (RETURN NIL))
			  ((ZEROP (SETQ N (1- N)))
			   (COND (DELP (DELETE* FLAG SCOUNT))
				 (FLAG (CHARACTER SCOUNT))
				 (T (REV* SCOUNT)))
			   (RETURN T))))
		   ((EQ (CAR SAVE) '\) (SETQ SCOUNT (1+ SCOUNT) SAVE (CDR SAVE))))
	     (SETQ SCOUNT (1+ SCOUNT) SAVE (CDR SAVE))
	     (GO LOOP)))

(DEFUN INSERT (STRING)
       (PROG (SAVE)
	     (SETQ AVANT (+ AVANT (LENGTH STRING)))
	LOOP (COND ((NULL STRING) (RETURN NIL)))
	     (SETQ STRING (CDR (SETQ SAVE STRING)) BEFORE (RPLACD SAVE BEFORE))
	     (GO LOOP)))
 
(DEFUN CHARACTER (COUNT)
       (PROG (SAVE)
	     (SETQ APRES (- APRES COUNT) AVANT (+ AVANT COUNT))
	LOOP (SETQ AFTER (CDR (SETQ SAVE AFTER)) BEFORE (RPLACD SAVE BEFORE))
	     (COND ((PLUSP (SETQ COUNT (1- COUNT))) (GO LOOP)))
	     (RETURN NIL)))
 
(DEFUN REV* (COUNT)
       (PROG (SAVE)
	     (SETQ AVANT (- AVANT COUNT) APRES (+ APRES COUNT))
	LOOP (SETQ BEFORE (CDR (SETQ SAVE BEFORE)) AFTER (RPLACD SAVE AFTER))
	     (COND ((PLUSP (SETQ COUNT (1- COUNT))) (GO LOOP)))
	     (RETURN NIL)))
 
(DEFUN LINE* (COUNT)
       (PROG NIL
	LOOP (CHARACTER 1)
	     (COND ((ZEROP APRES))
		   ((OR (NOT (EQ (CAR BEFORE) CR)) (PLUSP (SETQ COUNT (1- COUNT)))) (GO LOOP)))
	     (RETURN NIL)))
 
(DEFUN KILL* (COUNT)
       (PROG (CHAR)
	     (SETQ GSTRING NIL)
	LOOP (SETQ GSTRING (NCONC GSTRING (NCONS (SETQ CHAR (CAR AFTER)))) AFTER (CDR AFTER))
	     (COND ((ZEROP (SETQ APRES (1- APRES))))
		   ((OR (NOT (EQ CHAR CR)) (PLUSP (SETQ COUNT (1- COUNT)))) (GO LOOP)))
	     (RETURN NIL)))

(DEFUN MLINE (COUNT)
       (PROG NIL
	     (SETQ COUNT (1+ COUNT))
	LOOP (COND ((AND (EQ (CAR BEFORE) CR) (ZEROP (SETQ COUNT (1- COUNT))))
		    (RETURN NIL)))
	     (REV* 1)
	     (COND ((PLUSP AVANT) (GO LOOP)))
	     (RETURN NIL)))
 
(DEFUN MKILL* (COUNT)
       (PROG NIL
	     (SETQ GSTRING NIL COUNT (1+ COUNT))
	LOOP (COND ((OR (NOT (EQ (CAR BEFORE) CR)) (PLUSP (SETQ COUNT (1- COUNT))))
		    (SETQ GSTRING (CONS (CAR BEFORE) GSTRING) BEFORE (CDR BEFORE))
		    (COND ((PLUSP (SETQ AVANT (1- AVANT))) (GO LOOP)))))
	     (RETURN NIL)))
