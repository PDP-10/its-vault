TITLE SURVEY

.INSRT NETWRK;NCPMAC >

ACDEFS

GNCPTR==15	; TABLE PTR USED BY GETNXC
GNSPTR==16	; TABLE PTR USED BY GETNXS
TESTS==96.	; ROOM FOR THIS MANY SURVEYS ON CURRENT FILE
WORDS==8.	; # OF WORDS OF SURVEY DATA FOR EACH HOST IN CURRENT FILE
FIN==1		; CURRENT FILE INPUT CHANNEL
MIN==2		; MASTER FILE INPUT CHANNEL
FOUT==3		; CURRENT FILE OUTPUT CHANNEL
MOUT==4		; MASTER FILE OUTPUT CHANNEL
NETIN==5	; ICP INPUT CHANNEL
NETOUT==6	; NETWORK OUTPUT CHANNEL FOR TESTING
TNETIN==8.	; TELNET INPUT CHANNEL
TNETOU==9.	; TELNET OUTPUT CHANNEL
NDBOUT==10.	; CHANNEL FOR WRITING OUT NEW DATA BASE TO DISK
DSKIN==11.	; CHANNEL TO CHECK EXISTENCE OF FILES TO BE SENT TO DC
SCHIN==12.		; CHANNEL TO READ IN HOST SCHEDULES

WAIT==600.	; WAIT UP TO 15 SECONDS FOR A REPLY FROM A HOST


  ; HOST TABLE - SOCKET # IN L.H., HOST # IN R.H.

HLIST:	1,,1		; UCLA-SEX
	1,,2		; SRI
	1,,3		; UCSB
	1,,4		; UTAH
	1,,7		; RAND
	1,,10		; SDC
	1,,11		; HARVARD
	1,,12		; LINCOLN LABS - 67
	1,,13		; STANFORD AI
	1,,14		; ILL-CAC (ADDED 750120 per GEOFF@ARC)
;	1,,15		; CASE (NO LONGER EXISTS 750107)
	1,,16		; CARNEGIE
	1,,17		; I4-TENEX
	1,,20		; AMES-67
	1,,25		; LLL-RISOS (USER)
	1,,26		; ISI-SPEECH1 (USER)
	1,,27		; USC-44
	1,,32		; SDAC-44 (ADDED 750120 per GEOFF@ARC)
	1,,37		; CCA - DATACOMPUTER
	1,,40		; XEROX PARC-MAXC
	1,,43		; UCSD-CC
	1,,44		; HAWAII-ALOHA (ADDED 750120 per GEOFF@ARC)
	1,,52		; UNIV OF LONDON PDP-9/360-195
	1,,53		; OFFICE-1
	1,,54		; MULTICS
	1,,61		; BBN-TENEXB
	1,,63		; SRI-NSC11
	1,,66		; SCRL-ELFDEVEL (ADDED 750120 per GEOFF@ARC)
	1,,67		; ARGONNE (750121 per HOSTS.TXT)
	1,,101		; UCLA-CCN
	1,,102		; SRI-AI
;	1,,103		; SCRL-ELF (ADDED 750109, CHANGED TO 166 750120 per GEOFF@ARC)
;	1,,105		; BBN-TENEX (CHANGED TO 361 750107)
	1,,106		; MIT-DMS
	1,,107		; RAND-ISD (ADDED 741107)
	1,,110		; SDC-CC
	1,,112		; LINCOLN LABS - TX-2
	1,,113		; SU-DSL (OLD # 302)
	1,,114		; ILL-NTS (ADDED 750120 per GEOFF@ARC)
	1,,116		; CMU ALTERNATE SYSTEM
	1,,126		; USC-ISI (PREV RAND TENEX)
	1,,137		; LL-ANTS (ADDED 750120 per GEOFF@ARC)
	1,,142		; (ADDED 750109)
	1,,152		; LONDON-VDH (ADDED 741107)
	1,,153		; SUMEX (ADDED 741111)
	1,,161		; ELGIN
	1,,162		; BBN-TENEXD (OLD # 205)
	1,,166		; SCRL-ELF (OLD # 103)
	1,,201		; UCLA-CCBS
	1,,202		; SRI-11
	1,,203		; CHII
	1,,204		; UTAH-TIP
;	1,,205		; BBN-TENEXD (CHANGED TO 162 750107)
	1,,206		; MIT-AI
	1,,217		; I4B-TENEX (ADDED 750120 per GEOFF@ARC)
	1,,220		; AMES-TIP
	1,,221		; MITRE-TIP
	1,,222		; RADC-TIP
	1,,223		; NBS-TIP
	1,,224		; ETAC-TIP
	1,,226		; USC-ISIB
	1,,227		; USC-TIP
	1,,230		; GWC-TIP
	1,,231		; DOCB-TIP
	1,,232		; SDAC-TIP
	1,,234		; ARPA-TIP
	1,,236		; BBN-TESTIP
	1,,237		; CCA-TIP
	1,,241		; FNWC-TIP
	1,,244		; ALOHA-TIP
	1,,245		; RML (PATRICK)-TIP
	1,,250		; BBN-TIP
	1,,251		; NORSAR-TIP
	1,,252		; UKICS-TIP
	1,,253		; TYMSHARE-TIP
	1,,256		; RUTGERS-TIP
	1,,257		; WPAFP-TIP
	1,,260		; AFWL-TIP
	1,,261		; BBN10X-TIP
	1,,264		; ISI-TIP (ADDED 741107)
;	1,,302		; SU-DSL (CHANGED 113 750107)
	1,,305		; BBN-TENEXA
	1,,306		; MATHLAB
	1,,320		; (ADDED 750109)
	1,,326		; ISI-TSP
	1,,327		; USC-ECL TENEX
;	1,,344		; HAWAII-500	(temp remove 750121 per Lloyd Ebisu@344)
	1,,361		; BBN-TENEX (OLD # 105)
	103,,37		; DATA COMPUTER

NUMHOS==.-HLIST		; # OF HOST SOCKET COMBINATION BEING SURVEYED

DCBLEN==NUMHOS*23./5+1

HLAST:	-1		; DUMMY HOST (SIGNALS END OF TABLE)
	-1		; CLUDGE FOR STOPPING READ

PDL:	BLOCK	50
FINOPN:	0		; -1 => CURRENT FILE OPEN FOR READ
REINIT:	0		; -1 => REINITIALIZE CSDATA NOW FILE
MINOPN:	0		; -1 => MASTER FILE OPEN FOR READ
DCDPTR:	0		; BYTE POINTER FOR DC DATA
DCDBUF:  BLOCK	DCBLEN	; BUFFER FOR DATA COMPUTER
FOOBAR:	BLOCK	100
BUFLEN:	0		; # OF WORDS TO WRITE OUT TO THE NDCDAT FILE FOR EACH SURVEY
EPNTR:	0		; BYTE POINTER FOR DEPOSITING SURVEY STATUS IN CURRENT FILE
HEADER:	0		; # OF VALID ENTRIES,, # OF TESTS SINCE LAST SUMMARIZATION
	0		; DATE OF INITIALIZATION OF CURRENT FILE
	0		; TIME OF INITIALIZATION OF CURRENT FILE
	0		; DATE OF LAST SURVEY
	0		; TIME OF LAST SURVEY
DATBGN:	0		; DATE OF BEGINNING OF SURVEY IN CURRENT
TIMBGN:	0		; TIME OF BEGINNING OF SURVEY
DATEND:	0		; DATE OF COMPLETION OF SURVEY
TIMEND:	0		; TIME OF COMPLETION OF SURVEY
DATTIM:	BLOCK	96.*4	; OLD DATE AND TIME READ IN FROM CSDATA FILE
MHEAD:	BLOCK	5	; MASTER FILE HEADER
ENTRY:	0		; SOCKET,, HOST
	0		; TOTAL RESPONSE TIME
	BLOCK	10	; 8 WORDS OF SURVEY DATA FOR EACH HOST
MENTRY:	BLOCK	10	; MASTER FILE ENTRY
FSUM:	BLOCK	10
DCIOTP:	0		; PTR FOR IOTING TO DC (NETWORK BLOCK ASCII HACK)
TIME:	0
GNCBUF:	BLOCK	10.	; BUFFER USED BY GETNXC
GNSBUF:	BLOCK	10	; BUFFER USED BY GETNXS
FILLER:	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
ZEROS:	BLOCK	10
DEMSIG:	SETZ
	SIXBIT/DEMSIG/
	.+2
	SETZ .+2
	SIXBIT/SURSND/
	0
HOSTAT:	BLOCK	8.
SCHBUF:	BLOCK	100.
BFPNTR:	0
SCHFLG:	0




; CHKIOT MACRO CHECKS TO MAKE SURE IOT COMPLETED CORRECTLY.

DEFINE	CHKIOT	AC
	JUMPL	AC,DIE
TERMIN


RCHSTB:	BLOCK	7	; BLOCK FOR READ CHANNEL STATUS

LOGBLK:	SETZ
	SIXBIT /LOGIN/
	A
	400000,,.+1
	0

FILLEN: SETZ
        SIXBIT/FILLEN/
	C
        402000,,B

NETBLK:	40056,,(SIXBIT/NET/)
	0
	0
	0

NET1:	60,,(SIXBIT/NET/)	; LISTENING SOCKET FOR INITIAL CHECKING
	6
	0
	0

NET2:	51,,(SIXBIT/NET/)	; SENDING SOCKET FOR INITIAL CHECKING
	0
	6
	106

DCICPB: 40056,, (SIXBIT/NET/)
	0
	103
	37

CSDATI:	6,,(SIXBIT/DSK/)	; TO READ CURRENT SURVEY FILE
	SIXBIT/CSDATA/
	SIXBIT/NOW/

CSDATO:	7,,(SIXBIT/DSK/)	; TO WRITE CURRENT SURVEY FILE
	SIXBIT/CSDATA/
	SIXBIT/TRASH/
	0			; USE FOR DELETING EXTRA TRASH
	0

CSDATR:	0			; FOR RENAMING CURRENT OUTPUT FILE
	0
	FOUT
	SIXBIT/CSDATA/
	SIXBIT/NOW/

SUMRYI:	6,,(SIXBIT/DSK/)	; TO INPUT SUMMARY FILE
	SIXBIT/CSMSTR/
	SIXBIT/NOW/

SUMRYO:	7,,(SIXBIT/DSK/)	; TO OUTPUT SUMMARY FILE
	SIXBIT/CSMSTR/
	SIXBIT/TRASH /
	0			; TO DELETE EXTRA OUTPUT FILE ALSO
	0

SUMRYR:	0			; TO RENAME SUMMARY OUTPUT FILE
	0
	MOUT
	SIXBIT/CSMSTR/
	SIXBIT/NOW/


; PROGRAM BEGINS EXECUTION EACH TIME AT SURVEY

SURVEY: .SUSET	[.RUNAME,,A]	; GET UNAME TO SEE IF AT TOP LEVEL
	AOSE	A		; TOP LEVEL UNAME = -1
	JRST	TOP		; SKIP DEMON SECTION - IN DEBUG MODE
SLEEP:	.DEMON			; FIND OUT REQUEST COUNT
	JFCL
	MOVE	A,[SIXBIT/SURVEY/]
	.CALL	LOGBLK		; LOGIN IN AS "SURVEY"
	JRST	DIE		; QUIT IF CAN'T LOGIN
TOP:	.SUSET	[.SSNAME,,[SIXBIT/NETWRK/]]	; SET SNAME TO NETWRK TO USE THAT DIR
	MOVE	P,[-50,,PDL-1]	; OPEN SMALL PDL FOR NETWAIT
	.DIETIM	A,		; SEE IF SYSTEM GOING DOWN
	JUMPLE	A,TOPGO		; IF NOT GO ON
	CAIGE	A,9000.	 	; WILL IT DIE WITHIN 5 MINUTS
	JRST	DIE		; YES - QUIT NOW
TOPGO:	.OPEN	NETIN,NET1	; CHECK TO MAKE SURE NETWORK IS UP
	JRST	NDEAD		; BY TRYING TO CONNECT TO SELF
	.OPEN	NETOUT,NET2	; CONNECT TO SOCKET JUST OPENED
	JRST	NDEAD
	MOVEI	A,5*30.
	.SLEEP	A,		; ALLOW 5 SECONS FOR OPENS TO MATCH (AVOID NETRFC)
	.CLOSE	NETIN,
	.CLOSE	NETOUT,
	MOVE	A,[JRST TSINT]	; SET UP FOR INTERRUPTS
	MOVEM	A,42
	MOVEI	A,400		; LOOK FOR IOC ERROR
	SETZM	B
	.SETM2	A,		; SET INTERRUPT MASK
	SETZM	FINOPN		; MARK FILE NOT OPEN FIRST
	.OPEN	FIN,CSDATI	; TRY TO OPEN CURRENT SUMMARY FILE
	JRST	INIT		; OPEN FAILED - THERE IS NO CURRENT FILE - START ONE
	SETOM	FINOPN		; MARK FILE OPEN

; FALL THROUGH TO READ THE FILE IF THE OPEN SUCCEEDS

READ:	SETZM	REINIT
	MOVE	B,[-5,,HEADER]
	.IOT	FIN,B		; READ IN CURRENT FILE HEADER
	HRRZ	B,HEADER	; GET NUMBER OF TESTS ALREADY ON THIS FILE
	JUMPE	B,INIT		; IF FILE IS EMPTY - GO INITIALIIZE
	CAIN	B,TESTS		; SEE IF MORE ON FILE
	PUSHJ	P,FULL		; GO SUMMARIZE AND WIPEOUT IF FULL
	JRST	BGLOOP		; GO RUN A SURVEY

; INIT EXECUTED ONLY WHEN FIRST SURVEY IS PUT INTO A FILE

INIT:	.RTIME	A,		; COME HERE TO INITIALIZE THE FILE WITH TIME AND DATE
	MOVEM	A,HEADER+1
	.RDATE	A,
	ROT	A,12.		; REARRANGE DATE
	MOVEM	A,HEADER+2
	SETZM	HEADER
	HRLI	A,-96.*4	; ZERO OUT TIME AND DATE FOR EACH OF 96 ENTRIES
	HRRI	A,DATTIM
	SETZM	(A)
	AOBJN	A,.-1
; THE FOLLOWING MUST BE DONE AT THE BEGINNING OF EACH SURVEY

BGLOOP:	HLRZ	A,HEADER	; GET # OF VALID ENTRIES IN FILE
	AOS	A		; INCREMENT
	CAIG	A,96.		; MAXIMUM OF 96
	HRLM	A,HEADER	; STORE IN HEADER
	.RTIME	A,		; GET CURRENT TIME
	MOVEM	A,HEADER+3	; STORE AS TIME OF MOST RECENT SURVEY
	MOVEM	A,TIMBGN
	.RDATE	A,		; GET CURRENT DATE
	ROT	A,12.
	MOVEM	A,HEADER+4	; STORE AS DATE OF MOST RECENT SURVEY
	MOVEM	A,DATBGN
	MOVE	A,[440300,,ENTRY+2]
	HRRZ	C,HEADER	; # OF SURVEYS SINCE LAST SUMMARIZATION
	JUMPE	C,SAVPTR
	IDIVI	C,12.		; GET WORD # TO ENTER STATUS
	IMULI	D,3
	MOVEI	B,44
	SUB	B,D
	DPB	B,[360600,,A]	; SET UP BYTE PTR TO ENTER STATUS CODE
SAVPTR:	ADD	A,C
	MOVEM	A,EPNTR		; SAVE POINTER
	AOS	HEADER		; INCREMENT SURVEY COUNT SINCE LAST SUMMARIZATION
	.FDELE	CSDATO		; BEFORE OPENING OUTPUT, DELETE EXTRA TRASH
	JFCL			; IF CAN'T, DON'T WORRY - MAYBE ISN'T ONE
	.OPEN	FOUT,CSDATO	; OPEN THE OUTPUT FILE
	JRST	DIE		; IF CAN'T - QUIT BEFORE DAMAGE DONE
	MOVE	B,[-5,,HEADER]
	.IOT	FOUT,B		; OUTPUT THE HEADER TO THE NEW FILE
	MOVEI	A,NUMHOS	; number of hosts in ac A
	IMULI	A,23.		; multiply by number of char per host
	IDIVI	A,5		; divide by 5 to get buffer length
	SKIPE	B		; if remainder is 0,buffer size is OK
	ADDI	A,1		; remainder not 0, increase buffer length by 1
	MOVEM	A,BUFLEN	; SAVE LENGTH OF BUFFER
	MOVE	C,B
	SKIPN	B
	MOVEI	C,5
	ADDI	C,2
	MOVNS	A		; set up iot ptr (net block ascii hack)
	HRL	A,A
	DPB	C,[410300,,A]
	MOVEM	A,DCIOTP
	MOVE	A,[440700,,DCDBUF]	; setting up incremental byte ptr
	JUMPE	B,CON
	MOVEI	C,5
	SUB	C,B
	MOVEI	B,12		; pad with this
PAD:	SOJL	C,CON		; as many characters as are "extra"
	IDPB	B,A
	JRST	PAD
CON:	MOVEM	A,DCDPTR	; save adjust byte ptr
	SETZM	GNCPTR		; INITIALIZE HOST TABLE PTR


; routine to determine if individual hosts in the network are
; scheduled to be up in the current time slot

;	a/	host number
;	b/	number of entries for this host
;	c/	begin date or day
;	d/	end date or day
;	e/	begin time
;	f/	end time
;	g/	current time
;	h/	current date
;	i/	current day of week

CKSCHD:	SETZM	SCHFLG		; MARK SCHEDULE OF ALL HOSTS UNKNOWN
	.OPEN	SCHIN,[SIXBIT/  &DSKSURVEYDWNTIM/]	; OPEN SCHEDULE FILE
	JRST	STLOOP		; SKIP OVER REST
	SETOM	SCHFLG		; MARK SCHEDULE OF INDIVIDUAL HOSTS KNOWN
	.RDATIM	G,		; GET TIME AND DATE
	.RYEAR	I,		; GET YEAR
	LDB	I,[320300,,I]	; GET DAY OF WEEK
CKSCH1:	PUSHJ	P,READ2		; GET 2 WORDS FROM FILE
	JRST	STLOOP		; EOF REACHED
	IDIVI	B,4		; 4 WORDS FOR EACH ENTRY
	JUMPE	B,CKSCH1	; TRY ANOTHER HOST IF NO INFO FOR THIS ONE
CKSCH2:	PUSHJ	P,READ4		; GET 4 WORDS FROM FILE
	JRST	STLOOP		; EOF
	MOVE	J,D		; COPY END DATE/DAY
	SUB	J,C		; SUBTRACT BEGIN DATE/DAY
	TDNN	C,[777777,,777770]	; SKIP IF IN DATE  FORM
	JRST	CKDAY		; IN DAY FORM
CKDAT:	JUMPN	J,CKDAT1	; HANDLE DIFFERENTLY IF BEGIN AND END ON DIFFERENT DATES
	CAME	C,H		; BEGIN DATE EQUALS CURRENT DATE
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	CAML	E,G		; SCHEDULED DOWNTIME BEGUN ALREADY?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	CAMG	F,G		; SCHEDULED DOWNTIME ENDED ALREADY?
	JRST	CKNEXT		; YES, CHECK NEXT ENTRY
	JRST	MARKDN		; MARK THIS HOST SCHEDULED DOWN

CKDAT1:	CAME	C,H		; BEGIN DATE EQUALS CURRENT DATE?
	JRST	CKDAT2		; NO
	CAML	E,G		; DOWN TIME BEGUN ALREADY?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	JRST	MARKDN		; MARK THIS HOST SCHEDULED DOWN

CKDAT2:	CAML	C,H		; BEGIN DATE LESS THAN CURRENT DATE?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	CAMG	H,D		; CURRENT DATE LESS THAN END DATE?
	JRST	MARKDN		; YES, MARK THIS HOST SCHEDULED DOWN

CKDAT3:	CAME	D,H		; CURRENT DATE EQUAL END DATE?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	CAMG	F,G		; END TIME GREATER THAN CURRENT TIME?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	JRST	MARKDN		; MARK THIS HOST SCHEDULED DOWN

CKDAY:	JUMPN	J,CKDAY1	; HANDLE DIFFERENTLY IF BEGIN AND END ON DIFFERENT DAYS
	CAME	C,I		; BEGIN DAY EQUALS CURRENT DAY?
	JRST	CKNEXT		; NO, CHECK NEXT ENTRY
	CAML	E,G		; SCHEDULED DOWN TIME BEGUN ALREADY?
	JRST	CKNEXT		; NO
	CAMG	F,G		; SCHEDULED DOWN TIME ENDED ALREADY?
	JRST	CKNEXT		; YES
	JRST	MARKDN		; MARK THIS HOST SCHEDULED DOWN

CKDAY1:	SKIPG	J		; SKIP IF BEGIN AND END ON SAME WEEK
	JRST	CKDAY3
	CAME	C,I		; BEGIN DAY EQUALS CURRENT DAY?
	JRST	CKDAY2		; NO
CKDAY5:	CAML	E,G		; DOWN TIME BEGUN ALREADY?
	JRST	CKNEXT		; NO
	JRST	MARKDN		; YES, MARK THIS HOST SCHEDULED DOWN

CKDAY2:	CAMLE	D,I		; END DAY GREATER THAN CURRENT DAY?
	JRST	MARKDN		; YES
	CAME	D,I		; END DAY EQUALS CURRENT DAY?
	JRST	CKNEXT		; NO
CKDAY6:	CAMG	F,G		; END TIME GREATER THAN CURRENT TIME?
	JRST	CKNEXT		; NO
	JRST	MARKDN		; YES

CKDAY3:	CAMGE	C,I		; BEGIN DAY LESS THAN CURRENT DAY?
	JRST	MARKDN		; YES, MARK HOST DOWN
	CAMLE	D,I		; END DAY GREATER THAN CURRENT DAY?
	JRST	MARKDN

CKDAY4:	CAMN	C,I		; BEGIN DAY EQUALS CURRENT DAY?
	JRST	CKDAY5		; YES
	CAMN	D,I		; END DAY EQUALS CURRENT DAY?
	JRST	CKDAY6
	JRST	CKNEXT

CKNEXT:	SOSG	B		; DECREMENT NO. OF ENTRY FOR THIS HOST
	JRST	CKSCH1		; TRY NEXT HOST
	JRST	CKSCH2		; TRY NEXT ENTRY FOR THIS HOST

MARKDN:	MOVE	C,A		; HOST NO.
	IDIVI	C,36.		; GET WORD NO. IN BIT TABLE
	MOVEI	E,35.
	SUB	E,D
	LSH	E,12.
	HRL	E,E
	HRRI	E,HOSTAT
	ADD	E,C
	TLO	E,100
	MOVEI	D,1
	DPB	D,E
MARKD1:	SOSG	B
	JRST	CKSCH1
	PUSHJ	P,READ4
	JRST	STLOOP
	JRST	MARKD1

READ2:	SKIPGE	B,BFPNTR	; SKIP IF BUFFER EMPTY
	JRST	READ2A
	MOVE	A,[-100.,,SCHBUF]
	.IOT	SCHIN,A
	HLRE	B,A
	ADDI	B,100.		; FIND NO. OF WORDS READ
	MOVE	C,B
	IDIVI	C,2		; NO. OF WORDS READ MUST BE EVEN
	SKIPN	C
	POPJ	P,		; EOF REACHED
	SKIPE	D
	POPJ	P,
	MOVNS	B
	HRL	B,B
	HRRI	B,SCHBUF
READ2A:	HLRE	A,B
	ADDI	A,2
	SKIPLE	A
	POPJ	P,
	MOVE	A,(B)
	ADD	B,[2,,2]
	MOVEM	B,BFPNTR
	MOVE	B,-1(B)
	AOS	(P)
	POPJ	P,

READ4:	PUSH	P,A
	PUSH	P,B
	PUSHJ	P,READ2
	JRST	READ4A
	PUSH	P,A
	PUSH	P,B
	PUSHJ	P,READ2
	JRST	READ4A
	MOVE	E,A
	MOVE	F,B
	AOS	-4(P)
READ4A:	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,

GHSTAT:	MOVEI	C,2
	SKIPL	SCHFLG
	POPJ	P,
	IDIVI	A,36.
	MOVEI	C,35.
	SUB	C,B
	LSH	C,30.
	HRRI	C,HOSTAT
	ADD	C,A
	TLO	C,100
	LDB	C,C
	POPJ	P,

; THE FOLLOWING IS THE SURVEY ITSELF IT WILL BE EXECUTED ONCE FOR
; EACH HOST IN THE HOST TABLE (BLOCK)

STLOOP:	PUSHJ	P,GETNXC	; GET NEXT ENTRY FROM CURRENT FILE
	SKIPG	ENTRY		; LAST ENTRY MARKED BY -1
	JRST	ADDNDB		; END OF HOST TABLE REACHED
	SKIPE	REINIT
	SETZM	ENTRY+1		; ZERO OUT TOTAL RESPONSE TIME IF CSMSTR FILE JUST UPDATED

;TRANSLATING DATE AND TIME AND ADDING THEM TO DC BUFFER

	.RDATE	E,
	MOVE	A,[440600,,E]	; BYTE POINTER---FIRST DIGIT SKIPPED
	MOVEI	C,6		; LOOP 4 TIME
SIXASC: ILDB	D,A		; GET NEXT DIGIT AND PUT IN D
	ADDI	D,40		; CHANGE TO ASCII
	IDPB	D,DCDPTR	; DEPOSIT ASCII DIGIT IN BUFFER
	SOJN	C,SIXASC	; LOOP UNTIL C IS 0
	.RTIME  E,		; GET TIME IN HHMMSS
	MOVE	A,[440600,,E]	; SET UP BYTE POINTER
	MOVEI	C,4		; LOOP 4 TIMES
SIXAS2: ILDB	D,A		; GET NEXT DIGIT
	ADDI   	D,40		; CHANGE TO ASCII
	IDPB	D,DCDPTR	; PUT CHAR IN BUFFER
	SOJN	C,SIXAS2	; LOOP UNTIL FOUR DIGITS ARE DONE

; NOW ADDING HOST TO DC BUFFER

	HRRZ 	C,ENTRY		; PUT OCTAL HOST # IN C
	MOVEM	C,NETBLK+3	; PUT IN OPEN BLOCK
	MOVEI	D,3		; SETTING UP FOR CALL, 3 DIGITS IN HOST #
	PUSHJ	P,NUMOUT	; CALL ROUTINE THAT CHANGES OCTALTO ASCII DECIMAL
				; ROUTINE ALSO ADDS HOST TO DC BUFFER
	HLRZ	C,ENTRY		; GET SOCKET #
	MOVEM	C,NETBLK+2	; STORE IN OPEN BLOCK
SURICP:	.OPEN	NETIN,NETBLK	; ATTEMPT NETWORK CONNECTION
	JRST	DEAD		; OPEN REJECTED - HOST DEAD
	.RDTIME	E,		; GET CLOCK READING
	MOVEM	E,TIME
	MOVE	B,[NETIN,,RCHSTB]	; ARG FOR .RCHST
	.RCHST	B,		; GET CHANNEL STATUS
	MOVE	C,RCHSTB+1	; GET SOCKET U
	ADDI	C,2		; U+2
	MOVE	B,[60,,(SIXBIT/NET/)]
	.OPEN	TNETIN,B	; RECONNECT INPUT
	JFCL
	HRLI	B,61		; OUTPUT MODE
	ADDI	C,1		; U+3
	.OPEN	TNETOU,B	; RECONNECT OUTPUT
	JFCL
	MOVEI	B,WAIT		; (B)=TIME WILLING TO WAIT FOR RESPONSE
	NETWAIT	NETIN,4,[5,10,11][(B)]
	JRST	TIMEUP		; TIME LIMIT REACHED
	JRST	ERROR		; ERROR DETECTED
; SUCCESFUL CONNECTION FALLS THROUGH

 	MOVEI	B,5		;STATUS=5 (SUCCESSFUL CONNECTION)
ELOOP:	NETWAIT	TNETIN,1,2,150.
	JRST	TIMEUP
	JRST	ERROR
	.NETAC	TNETIN,
	JRST	ERROR
	NETWAIT	TNETOU,1,2,150.
	JRST	TIMEUP
	JRST	ERROR
	.NETAC	TNETOU,
	JRST	ERROR
	.CLOSE	TNETIN,
	.CLOSE	TNETOU,
	.RDTIME	E,		; GET CLOCK READING NOW
	SUB	E,TIME		; GET ELAPSED TIME
	ADDM	E,ENTRY+1	; UPDATE TIME RECORDS IN TABLE
	MOVEI	B,5		; STATUS CODE FOR LOGGER AVAILABLE
	JRST	ELOOP1		; STORE STATUS AND RESPONSE TIME IN BUFFER

DEAD:	.STATUS	NETIN,A		; GET CHANNEL STATUS
	LDB	A,[220600,,A]	; GET ERROR CODE IN B
	MOVEI	B,0		; CODE FOR STATUS OF UNDETERMINED
	CAIN	A,20		; 20 IS REALLY DOWN
	MOVEI	B,1		; STATUS=1 (HOST DEAD)
	JRST	ELOOP1		; STORE STATUS IN BUFFER

TIMEUP:	MOVEI	B,3		; STATUS=3 (NO RESPONSE)
	JRST	ELOOP1		; STORE STATUS

REJLOG:	MOVEI	B,4		; STATUS=4 (LOGGER REJECTING)
	JRST	ELOOP1		; STORE STATUS

ERROR:	.STATUS	NETIN,B		; ERROR OCCURRED - DETERMINE STATUS
	LDB	B,[140600,,B]	; GET NEEDED BITS
	SKIPN	B	
	JRST	REJLOG		; NONE SET - LOGGER REJECTING
 	MOVEI	B,0		; STATUS=0 (UNDETERMINED)

ELOOP1:	.CLOSE	NETIN,
	.CLOSE	TNETIN,
	.CLOSE	TNETOU,
	MOVE 	C,B		; PUT STATUS IN C
	MOVEI	D,1		; ONE DIGIT ONLY IN STATUS
	PUSHJ	P,NUMOUT	; CONVERT TO ASCII DECIMAL AND ADD TO DC BUFFER
	CAIE	B,5		; IF UP, DON'T PUT IN DEFAULT RESPNSETIME
	SETZM	E		; NO RESPONSE TIMEIF LOGGER UNAVAILABLE
	MOVE	C,E		; THAT'S THE RESPONSE TIME
	IDIVI	C,3		; GET TENTHS OF SECOND
	MOVEI   D,3		; 3 DIGITS IN RESPONSETIME
	PUSHJ	P,NUMOUT	; CONVERT AND ADD TO DC BUFFER
	HLRZ	C,ENTRY		; GET SOCKET #
	MOVEI	D,3		; 3 DIGITS
	PUSHJ	P,NUMOUT	; PUT IN BUFFER
	HRRZ	A,ENTRY		; HOST #
	PUSHJ	P,GHSTAT	; GET SCHEDULE OF HOST
	MOVEI	D,1
	PUSHJ	P,NUMOUT	; STORE CODE IN BUFFER
KAMMEL:  MOVEI 	C,15		; CR
	IDPB	C,DCDPTR	; PUT IN BUFFER
	MOVEI 	C,12		; LF TO FOLLOW CR AT END
	IDPB	C,DCDPTR	; PUT IN BUFFER
	MOVE	C,EPNTR		; GET BYTE POINTER
	IDPB	B,C		; STORE THIS STATUS IN HOST'S TABLE
	MOVE	B,[-WORDS-2,,ENTRY]
	.IOT	FOUT,B		; PUT UPDATED ENTRY ON NEW CURRENT FILE
	JRST	STLOOP		; GO BACK FOR MORE HOSTS
; THE FOLLOWING ROUTINE CONVERTS OCTAL NUMBERS TO ASCII DECIMAL
; AND ADDS THEM TO THE DATACOMPUTER BUFFER

NUMOUT: PUSH	P,A
	PUSH	P,B
	PUSH	P,[-1]
	MOVE	A,C
NMLP:	IDIVI	A,10.
	ADDI	B,"0
	PUSH	P,B
	SOJG	D,NMLP
NMLP2:  POP	P,B
	JUMPL	B,NMPLX
	IDPB	B,DCDPTR
	JRST	NMLP2
NMPLX:  POP	P,B
	POP	P,A
	POPJ	P,

; FOLLOWING ROUTINE RECEIVES TWO RIGHT JUSTIFIED ASCII STRINGS IN
; AC A AND AC B. IT LISTENS ON THE DC SOCKET FOR THE ARRIVAL OF
; STRING IN A OR 1ST 3 CH IN B IN B. (3RD CHAR IN B MAY ALSO BE
; - OR ?) IF A ARRIVES, RETURN IS +1, IF B ARRIVES RETURN IS NO SKIP.

WAITFS:	PUSH	P,F
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVE 	D,[440700,,B]		; SET UP PTR (WORD IS RT JUSTIFIED)
	MOVE 	C,[440700,,A]
WAITL:	.IOT	TNETIN,E
	CAMN	C,[010700,,A]		; RETURN+1?
	JRST	ENDA
	CAMN	D,[170700,,B]		; RETURN?
	JRST	ENDB
	ILDB	F,C			; GET A CHAR FROM A
	CAME	F,E			; IS IT EQUAL TO CHAR WE GOT?
	MOVE	C,[440700,,A]		; NO, START BACK AT BEG.
	ILDB	F,D			; GET CHAR
	CAME	D,[170700,,B]
	JRST	GHALTA			; NO,CONTINUE LOOP
	CAMN	F,E			; 3RD CHAR "+?
	JRST	ENDB			; ERROR AT DC, QUIT
	CAIN	E,"-			; 3RD CHAR "-?
	JRST	ENDB			; YES, ERROR AT DC, QUIT
	CAIN	E,"?			; 3RD CHAR "??
	JRST	ENDB			; YES, ERROR AT DC, QUIT
	MOVE	D,[440700,,B]		; START ALL OVER
	JRST 	WAITL
GHALTA: CAME	F,E			; CR OR LF?
	MOVE	D,[440700,,B]		; START AT BEG
	JRST 	WAITL
ENDA:	POP	P,E
	POP	P,D
	HRRZ	B,P			; IN B RIGHT WE HAVE ADDRESS OF TOP OF STACK
	MOVE	C,(B)-2			; TOP OF STACK NOW IN C
	ADDI	C,1			; WANT RETURN+1
	MOVEM	C,(B)-2			; PUT NEW ADDRESS ON TOP OF STACK
	POP	P,C
	POP	P,F
	POPJ	P,
ENDB:	POP	P,E
	POP	P,D
	POP	P,C
	POP	P,F
	POPJ	P,


; routine to add data to new data base; a separate file is used to contain the survey
; data for each day.  The first file name will be NDCDAT, and the second file name will
; be the date read from a .rdate system call.  Eventually, sending of the survey
; data will be done by a separate demon program once a day, using this new data base.

ADDNDB:	MOVE	A,[100007,,(SIXBIT/DSK/)]	; ATTEMPT TO OPEN IN WRITE OVER MODE
	MOVE	B,[SIXBIT/NDCDAT/]	; FN1
	.RDATE	C,			; FN2
	.OPEN	NDBOUT,A		; OPEN
	JRST	CRNFIL			; CREATE NEW FILE
	MOVEI	C,NDBOUT		; CHAN #
	.CALL	FILLEN			; FIND LENGTH OF FILE
	JRST	CLDATF			; FAIL, GO CLOSE CSDATA FILE
	.ACCESS	NDBOUT,B		; SET PTR TO END OF FILE
	JRST	WRTNDB			; WRITE
CRNFIL:	HRLI	A,7			; CHANGE OPEN MODE
	.OPEN	NDBOUT,A		; TRY TO OPEN AGAIN
	JRST	CLDATF
	HRROI	A,[1]
	.IOT	NDBOUT,A	; INITIALIZE ACCESS POINTER
WRTNDB:	SETOM	C		; WORD TO MARK BEGINNING OF AN ENTRY
	MOVE	D,DCIOTP	; LEFT HALF OF IOT PTR
	MOVE	B,[-2,,C]	; IOT PTR
	.IOT	NDBOUT,B	; WRITE OUT MARKER AND DATA COUNT
	MOVN	B,BUFLEN
	HRL	B,B		; SET UP IOT PTR FOR DATA
	HRRI	B,DCDBUF	; BUFFER ADDRESS
	.IOT	NDBOUT,B	; WRITE OUT THE DATA
	.CLOSE	NDBOUT,		; CLOSE CHANNEL

CLDATF:	SETOM	ENTRY		; WRITE OUT A TRAILER FOR CURRENT FILE
	MOVE	B,[-WORDS-2,,ENTRY]
	.IOT	FOUT,B		; OUTPUT TO THE END OF THE CURRENT FILE
	.RDATE	A,
	ROT	A,12.
	MOVEM	A,DATEND
	.RTIME	A,
	MOVEM	A,TIMEND
	MOVE	B,[-96.*4,,DATTIM]
	SKIPE	FINOPN
	.IOT	FIN,B
	MOVE	B,[-96.*4,,DATBGN]
	.IOT	FOUT,B
	.CLOSE	FIN,		; CLOSE INPUT FILE
	.FDELE	CSDATR		; IF WE MAKE IT BACK RENAME THE FILE TO A GOOD NAME
	JRST	DIE		; QUIT
LPDONE:	.CLOSE	FOUT,		; CLOSE THE FILE
	.OPEN	DSKIN,[SIXBIT/   DSKNDCDAT</]
	JRST	LPDON1
	MOVE	A,[DSKIN,,A]
	.RCHST	A,		; FIND FILE NAME
	.RDATE	D,
	CAMN	C,D		; CHECK IF THERE EXISTS A FILE NOT CREATED TODAY
	JRST	LPDON1
	.CALL	DEMSIG		; SIGNAL SENDING PROCESS
	JFCL
LPDON1:	.LOGOUT			; ALL FINISHED - LOGOUT
	.VALUE			; IF IN DEBUG MODE, LOGOUT WILL FAIL.  INCLUDE A .VALUE
; FULL WILL BE JUMPD TO WHEN SURVEY READS IN A FILE THAT HAS NO MORE
; ROOM ON IT.  IT READS IN A SUMMARY FILE, UPDATES IT WITH THE CURRENT
; INFORMATION AND WRITES IT BACK OUT.  IT THEN ZEROS THE CURRENT ARRAY
; AND STARTS FRESH.

FULL:	SETZM	GNCPTR		; INITIALIZE HOST TABLE PTRS
	SETZM	GNSPTR
	SETZM	MINOPN		; MARK CHAN NOT OPEN
	.OPEN	MIN,SUMRYI	; OPEN THE LATEST SUMMARY FILE
	JRST	NOSUM		; IF THERE ISN'T ONE - ASSUME AN ALL ZERO SUMMARY
	SETOM	MINOPN		; MARK CHAN OPEN
FULL2:	MOVE	A,[-5,,MHEAD]
	.IOT	MIN,A		; READ IN THE MASTER FILE HEADER
	CHKIOT	A

SUMUP:	HRRZ	A,HEADER	; GET CURRENT TEST COUNT
	ADDM	A,MHEAD		; ADD IT TO SUMMARY TEST COUNT
	MOVE	I,A		; GET TODAYS COUNT IN I
	HRRZ	G,MHEAD		; AND TOTAL COUNT IN G
	MOVE	A,HEADER+3	; GET LAST TIME
	MOVEM	A,MHEAD+3	; MAKE IT LAST SUMMARY TIME
	MOVE	A,HEADER+4	; GET LAST DATE
	MOVEM	A,MHEAD+4	; MAKE IT LAST SUMMARY DATE
	SKIPE	MHEAD+1		; SEE IF SUMMARY FIRST TIME IS ZERO
	JRST	FSETUP		; NO - GO ON
	MOVE	B,HEADER+1	; YES - GET FIRST DATE AND TIME FROM CURRENT TO SUMMARY
	MOVEM	B,MHEAD+1	; INIT TIME
	MOVE	B,HEADER+2
	MOVEM	B,MHEAD+2	; INIT TIME
FSETUP:	.OPEN	MOUT,SUMRYO	; OPEN THE MASTER OUTPUT FILE (WITH FAKE NAME)
	JRST	DIE		; DIE IF CAN'T
	MOVE	B,[-5,,MHEAD]
	.IOT	MOUT,B		; OUTPUT HEADER TO NEW MASTER FILE
FLOOP:	PUSHJ	P,GETNXS	; GET NEXT ENTRY FROM MASTER SUMMARY FILE
FFIN:	PUSHJ	P,GETNXC	; GET NEXT ENTRY FROM CURRENT FILE
	MOVE	C,ENTRY		; GET CURRENT HOST NUMBER
FCHECK:	MOVE	B,MENTRY	; GET MASTER HOST NUMBER
	JUMPL	B,FCK2		; END OF MASTER FILE REACHED
	CAML	B,C		; COMPARE
	JRST	FCK2		; GO DO MORE CHECKING
	MOVE	B,[-8.,,MENTRY]
	.IOT	MOUT,B		; OUTPUT THE MASTER ENTRY (HOST IS NO LONGER IN TABLES)
	PUSHJ	P,GETNXS	; GET NEXT ENTRY FROM MASTER SUMMARY FILE
	JRST	FCHECK		; GO BACK TO CHECK IT

FCK2:	CAME	B,C		; SEE IF HOST NUMBERS ARE THE SAME
	JRST	FCK2ON		; NO - KEEP CHECKING
	JUMPL	B,FLDONE	; DONE IF -1 READ
FCK2ON:	MOVEI	D,6		; WILL NEED SUM OF CURRENT ENTRY SO COMPUTE IT
FZLP:	SETZM	FSUM+1(D)	; ZERO OUT THE CURRENT ENTRY SUM AREA
	SOJGE	D,FZLP
	HRLI	D,440300	; SET UP BYTE POINTER TO STATUS LIST
	HRRI	D,ENTRY+2
	MOVE	E,ENTRY+1	; GET TOTAL RESPONSE TIME
	MOVEM	E,FSUM+1
	HRRZ	E,HEADER	; GET TEST COUNT
FSMLP:	ILDB	F,D		; GET NEXT STATUS
	CAIGE	F,6		; NOT INTERESTED IN STATUS OVER 5
	AOS	FSUM+2(F)	; ADD ONE TO COUNT FOR THIS STATUS
	SOJG	E,FSMLP		; LOOP UNTIL ALL STATUSES COUNTED
	CAME	B,C		; NOW COMPARE CURRENT AND MASTER HOST NUMBERS AGAIN
	JRST	FUENT		; CURRENT SMALLER THAN MASTER - PASS CURRENT ONLY
	MOVEI	F,6		; NUMBERS THE SAME - ADD CURRENT COUNT LIST TO MASTER LIST
FSMLP2:	MOVE	B,FSUM+1(F)	; GET SUM FROM CURRENT COUNT LIST
	ADDM	B,MENTRY+1(F)	; UPDATE MASTER COUNT LIST
	SOJGE	F,FSMLP2
	MOVE	F,[-8.,,MENTRY]
	.IOT	MOUT,F		; PASS UPDATED MASTER COUNT LIST
	JRST	FLOOP		; GO BACK FOR ANOTHER HOST IF NO DUMP NEEDED
; NEED THE CURRENT COUNT LIST ONLY.  COME TO HERE ONLY IF THE CURRENT HOST
; DOES NOT APPEAR ON THE MASTER FILE. THIS MEANS THAT IT WAS ADDED TO THE
; SURVEY LIST SINCE THE LAST SUMMARIZE.

FUENT:	MOVE	F,ENTRY		; PUT HOST NUMBER IN THE NEW ENTRY
	MOVEM	F,FSUM
	MOVE	F,ENTRY+1	; PUT THE TOTAL RESPONSE TIME IN THE NEW ENTRY
	MOVEM	F,FSUM+1
	MOVE	F,[-8.,,FSUM]
	.IOT	MOUT,F		; OUTPUT TO THE NEW MASTER FILE 
	JRST	FFIN		; GO BACK AND READ ANOTHER CURRENT ENTRY

; SUMMARIZING IS FINISHED.  WRITE THE TRAILER AND CLOSE THE FILE

FLDONE:	SETOM	ENTRY		; MARK END OF HOST DATA
	MOVE	B,[-8.,,ENTRY]
	.IOT	MOUT,B		; OUTPUT THIS FAKE ENTRY TO THE MASTER FILE
NOCTPL:	.CLOSE	MIN,		; CLOSE THE MASTER INPUT FILE
	.FDELE	SUMRYR		; RENAME CURRENT OUTPUT CSMSTR NOW
	JRST	DIE		; QUIT IF CAN'T
	.CLOSE	MOUT,		; CLOSE THE FILE

; NOW WE HAVE SUMMARIZED THE CURRENT FILE, SO ZERO IT OUT AND START OVER AGAIN

CLEAR:	SETZM	A
	HRRM	A,HEADER	; ZERO OUT COUNT IN HEADER
	MOVEI	A,5
	.ACCES	FIN,A		; RESET ACCESS POINTER
	SETOM	REINIT		; SET FLAG TO REINITIALIZE TOTAL REPONSE TIME
				; IN CURRENT FILE
	POPJ	P,		; RETURN


NOSUM:	MOVEI	A,4		; ZERO OUT THE MASTER FILE HEADER
NSLOOP:	SETZM	MHEAD(A)
	SOJGE	A,NSLOOP
	JRST	SUMUP		; GO SUMMARIZE THE CURRENT FILE

NDEAD:	.CLOSE	NETIN,
	.CLOSE	NETOUT,

DIE:	.LOGOUT			; IF ANYTHING GOES WRONG, QUIT BEFORE DAMAGE IS DONE
	.VALUE			; IF IN DEBUG MODE, LOGOUT WLL FAIL

TSINT:	0
	0
	.DISMIS	[0,,DIE]

GETNXC:	SKIPL	FINOPN		; SKIP IF FILE OPEN
	JRST	GNC2		; INITIALIZE
	SKIPE	A,GNCBUF	; CHECK IF GOT ANYTHING IN BUFFER
	JRST	GNC1		; YES
GNC0:	MOVE	A,[-10.,,GNCBUF]	; IOT PTR
	.IOT	FIN,A		; READ IN
GNC1:	MOVE	A,GNCBUF	; GET HOST AND SOCK #s
	CAMGE	A,HLIST(GNCPTR)
	JRST	GNC0		; NO LONGER IN SURVEY TABLE
	CAME	A,HLIST(GNCPTR)
	JRST	GNC2		; NOT EQUAL OR LESS THAN
	AOS	GNCPTR		; INCREMENT TABLE PTR
	MOVE	A,[GNCBUF,,ENTRY]	; BLT PTR
	MOVEI	B,ENTRY+9.	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; MOVE BLOCK FROM BUFFER TO ENTRY
	SETZM	GNCBUF		; MARK NOTHING LEFT IN BUFFER
	POPJ	P,		; RETURN

GNC2:	MOVE	A,HLIST(GNCPTR)
	AOS	GNCPTR		; INCREMENT TABLE PTR
	MOVEM	A,ENTRY
	SETZM	ENTRY+1		; ZERO OUT RESPONSE TIME
	MOVE	A,[FILLER,,ENTRY+2]	; BLT PTR
	MOVEI	B,ENTRY+9.	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; PUT FILLERS IN ENTRY
	POPJ	P,
GETNXS:	SKIPL	MINOPN		; SKIP IF FILE OPEN
	JRST	GNS2		; INITIALIZE
	SKIPE	A,GNSBUF	; CHECK IF GOT ANYTHING IN BUFFER
	JRST	GNS1		; YES
	MOVE	A,[-10,,GNSBUF]	; IOT PTR
	.IOT	MIN,A		; READ IN
GNS1:	MOVE	A,GNSBUF	; GET HOST AND SOCK #s
	CAMLE	A,HLIST(GNSPTR)
	JRST	GNS2		; NOT EQUAL OR LESS THAN
	CAML	A,HLIST(GNSPTR)
	AOS	GNSPTR		; INCREMENT TABLE PTR
	MOVE	A,[GNSBUF,,MENTRY]	; BLT PTR
	MOVEI	B,MENTRY+7	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; MOVE BLOCK FROM BUFFER TO ENTRY
	SETZM	GNSBUF		; MARK BUFFER EMPTY
	POPJ	P,		; RETURN

GNS2:	MOVE	A,HLIST(GNSPTR)	; GET HOST AND SOCKET FROM TABLE
	MOVEM	A,MENTRY
	AOS	GNSPTR		; INCREMENT TABLE PTR
	MOVE	A,[ZEROS,,MENTRY+1]	; BLT PTR
	MOVEI	B,MENTRY+7	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; PUT FILLERS IN ENTRY
	POPJ	P,

END	SURVEY
