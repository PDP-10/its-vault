TITLE DPRESS -- PROGRAM TO DISPLAY PRESS FILES ON TV'S

;; This is now designed to use only Alto fonts, and not try and hack
;; the full complexity of the DOVER fonts, although, if someone
;; wanted to hack it, they hopefully will be able to without too
;; much trouble.


ZR==0				;SUPER TEMP
A=1				;GENERAL PURPOSE ACCUMULATORS
B=2
C=3
D=4
E=5
F=6
G=7
H=10
NUMCOM=11		;NUMBER OF BYTES LEFT TO PROCESS IN THE CURRENT ENTITY LIST
COM=12			;THE COMMAND ITSELF

T=13				;A TEMPORARY ACCUMULATOR
TT=14				;ANOTHER

EL=15			;BYTE POINTER FOR ENTITY LIST
DL=16			;BYTE POINTER FOR DATA LIST
P=17

FILBEG==200000		;STARTING ADRESS OF FILE (POST MAPPED)
BUFSIZ==6000		;SIZE OF BUFFER
PDLLEN==40		;LENGTH OF PDL

TTYOCH==1			;normal tty output
DSKICH==2			;FOR THE FILE WE ARE READING
FNTICH==3			;TEMPORARY CHANNEL WHEN READING FONTS
TTYICH==4			;INPUT FROM THE TTY, FULL CHARACTER SET
ERRICH==5			;ASCII INPUT FROM ERR DEVICE
IMAGE==6			;IMAGE OUTPUT FOR THE PLASMA TV'S

%TXTOP==4000		;"TOP" KEY
%TXSFL==2000		;"SHIFT-LOCK" KEY
%TXSFT==1000		;"SHIFT" KEY
%TXMTA==0400		;"META" KEY
%TXCTL==0200		;"CONTROL" KEY
%TXASC==0177		;MASK FOR THE ASCII PART OF THE CHARACTER

%TIFUL==400		;1 => Use the full TV character set if possible
%TJDIS==4000		;1 => recognize CTRL/P codes for displaying

%TDCLR==220		; TD CODE FOR CLEAR SCREEN
%TDCHR==234		; TD CODE TO RETURN TO CHARACTER MODE
%TDSET==235		; TD CODE TO SET GRAPHIC CURSOR POSITION
%TDBIT==233		; TD CODE TO START AN IMAGE MODE TRANSFER
%TDLNG==236		; TD CODE FOR DRAWING LONG VECTORS
%TDNOP==210		; TD CODE TO DO NOTHING

;; SCREEN CHARACTERISTICS
SCRE.W==512./32.	; WIDTH OF THE PLASMA TV'S (IN PDP-10 WORDS)
SCRE.H==500.		; LEAVE SOME ROOM AT THE BOTTOM

;; DOVER PAGE CONSTANTS in the alto font saize reolution
RES.DV==384.		;THE RESOLUTION OF THE DOVER IN PIXELS PER INCH
RES.VD==96.		;THE RESOLUTION OF THE VIRTUAL DOVER (ALTO FONTS)

BITS.W==RES.VD*17./2.	;NUMBER OF BITS FOR A SCAN LINE (8.5 INCHES WIDE)
BITS.H==RES.VD*11.	;NUMBER OF BITS VERTICALLY (11.0 INCHES)

WORD.W==<BITS.W+31.>/32.; NUMBER OF WORDS NEEDED TO HOLD A SCAN LINE
WORD.H==BITS.H		; NUMBER OF SCAN LINES
VPSIZE==WORD.W*WORD.H	; NUMBER OF WORDS NEEDED FOR A PAGE

;; IN MICAS, THIS IS
P.WIDE==2540.*17./2	; 8 1/2 INCHES
P.HIGH==2540.*11.	; 11 INCHES
VP.WID==P.WIDE/2	;ASSUME WE CAN LOOK AT HALF A PAGE
VP.HIG==VP.WID		;SQUARE SCREEN

MOVINC==2500		; LEFT/RIGHT/UP/DOWN INCREMENT FACTOR



.XCREF A,B,C,P

PJRST==JRST		;FOR PUSHJ P, FOLLOWED BY POPJ P,

DEFINE	CONC A,B
A!B!TERMIN

LOC 42
	JSR TSINT			;INTERRUPT HANDLER ROUTINE FOR TTY INPUT.
LOC 100



SUBTTL HERE WE GO

;; This is the main loop. We init the pdl, then init the system,
;; Query for a file, get it, process the fonts, and then enter the
;; main process loop

GO:	MOVE P,[-PDLLEN,,PDB-1]
	PUSHJ P,GETTTY		; OPEN THE TTY IN VARIOUS WAYS
	PUSHJ P,INIVAR		; INIT VARIABLES
	PUSHJ P,FRESTO		; SET UP FREE STORAGE

GO1:				; COME HERE FOR NEW FILE
	PUSHJ P,GETFIL		; GET THE FILE TO PROCESS, FROM JCL OR TTY

GO2:				;COME HERE FOR LOOPING
	PUSHJ P,NWPAGE		;COMPUTE NEW PAGE IF NEEDED
	PUSHJ P,REDISP		;REDISPLAY IT
	PUSHJ P,WORK		;GET COMMAND, AND PROCESS IT
	JRST	GO2		;LOOP


SUBTTL INIT VARIOUS VARIABLES

;; This code is entered when the program is started or <alt>G It is
;; done only once. Things that get done for each file should be done
;; in the get file section.

INIVAR:	MOVEI A,FS
	MOVEM A,FREEM	;NEXT USABLE WORD OF FREE STORAGE
	MOVEI A,FS/2000
	MOVEM A,FREEPG	;NEXT PAGE TO GRAB WHEN REQUESTING MORE MEMORY

	SETOM JCLP
	.SUSET [.RSNAME,,FILDIR]	; SET UP DEFAULT DIRECTORY

	.CALL [SETZ
		SIXBIT /OPEN/
		[.BII,,FNTICH]
		JFFO ERRCOD
		[SIXBIT /DSK/]
		[SIXBIT /FONTS/]
		[SIXBIT /WIDTHS/]
		[SIXBIT /FONTS/]
		SETZ]
	JRST [MOVEI A,[ASCIZ /CAN'T OPEN FONTS;FONTS WIDTHS -- UNRECOVERABLE ERROR/]
		PUSHJ P,OUTSTR
		JRST DONE]
	.CALL [SETZ
		SIXBIT /FILLEN/
		MOVEI FNTICH
		SETZM FILLEN]
	 .LOSE 1000
	MOVE T,FREEM
	MOVE A,T
	ADD T,FILLEN
	MOVEM T,FREEM
	PUSHJ P,GETUPT
	MOVN B,FILLEN
	HRL A,B
	.IOT FNTICH,A
	.CLOSE FNTICH,
	POPJ P,


SUBTTL OPEN THE TTY

GETTTY:				; OPEN THE TTY FOR:
				;	FULL CHARACTER SET IMPUT
				;	^P OUTPUT
				;	IMAGE OUTPUT
	
	.CALL  [SETZ			;TTY INPUT
		SIXBIT /OPEN/
		[%TIFUL+.UAI,,TTYICH]	;USE FULL CHAR SET
		SETZ [SIXBIT /TTY/]]
	 .LOSE 1000

	.CALL [SETZ			;TTY OUTPUT
		SIXBIT /OPEN/
		[%TJDIS+.UAO,,TTYOCH]	; USE ^P CURSOR CODES
		SETZ [SIXBIT /TTY/]]
	 .LOSE 1000

	.CALL [SETZ			; GET THE TCTYP WORD
		SIXBIT /CNSGET/
		MOVEI TTYOCH
		MOVEM
		MOVEM
		SETZM A]
	 .LOSE 1000
	CAIE A,%TNSFW			; IS THIS A TV?
	 .VALUE [ASCIZ /:SORRY, DPRESS ONLY WORKS ON SOFTWARE TTY'S
KILL /]

	.OPEN IMAGE,[SIXBIT /  ETTY/]	; OPEN TV FOR IMAGE MODE
	 .LOSE 1000

	POPJ P,

SUBTTL SET UP FREE STORAGE

FRESTO:

;; Things to change. We will be keeping a full copy of the page in
;; memory. The resolution of the DOVER is 384 bits per inch. This is
;; 147456 bits ber square inch. An 8.5x11 inch peice of paper
;; therefore contains 13787136 bits. Now it is time to show we can
;; keep all of this in memory. first of all, one alto dot is ????
;; dover dots, which means we really only have ????? bits to worry
;; about. At 32 bits per word, this is only ??? words.


	MOVE A,[-<<VPSIZE+1777>/2000>,,VPAGE/2000]
			;THE NUMBER OF PAGES NEEDED AND THE PAGE TO START AT
	.CALL [SETZ
		SIXBIT /CORBLK/
		MOVEI %CBWRT+%CBRED	;TRY FOR READ AND WRITE ACCESS
		MOVEI -1		;HACK MY OWN CORE
		A			;BLOCK MODE, GET ALL 10 PAGES OF TV BUFFER
					;   AND PUT THEM AT PAGE
		MOVEI %JSNEW		;NEW PAGES, NOT VIDEO
		SETZ]			;STARTING AT ZERO PAGE OF THE TV BUFFER
	 .LOSE 1000

	POPJ P,


SUBTTL GET A NEW FILE FOR DISPLAYING

GETFIL:	SETZM ERRFLG	;NO ERRORS YET
	PUSHJ P,GETNAM	;QUERY FOR THE NAME
	PUSHJ P,PARSE	;PARSE IT INTO SIXBIT
	PUSHJ P,FILOPN	;TRY AND OPEN IT, READ IT, AND MAP IT
	 SKIPE ERRFLG	;HAS THERE BEEN AN ERROR
	  JRST GETFIL	; YES, GO BACK AND TRY AGAIN
	 SETZM ERRFLG	;RESET IT FOR THE INITIALIZATION
	PUSHJ P,INIFIL	;INIT IT, IE, GET THE NECESSARY INFO AND FONTS
	 SKIPE ERRFLG	;AN ERROR HERE?
	  JRST GETFIL	;GO BACK AND TRY AGAIN
	 POPJ P,	; FINISH IF OK

GETNAM:	SKIPN JCLP			; SHOULD WE LOOK FOR A JCL
	 JRST FRMTTY			; GO TO TTY FOR THE FILE
	.SUSET [.ROPTION,,A]		; IS THERE JCL
	TLNN A,%OPCMD
	 JRST FRMTTY			; NO, GET FROM THE TTY
	.BREAK 12,[..RJCL,,FILSPC]	;YES, READ IT IN
	POPJ P,

FRMTTY:	MOVEI A,[ASCIZ /INPUT FILE NAME: /]	;PROMPT HIM
	PUSHJ P,OUTSTR
	MOVE H,[441000,,FILSPC]	;HERE TO PUT IT
	SETZI D,		;WE HAVEN'T READ ANY CHARACTERS YET

FT.LOO:	.IOT TTYICH,A	;GET A CHARACTER
	PUSHJ P,MAKASC	; MAKE IT ASCII
	CAIN A,177	; RUBOUT?
	 JRST FT.RUB	;TAKE CARE OF IT IF IT IS
	AOS D		;WE HAVE READ ANOTHER CHARACTER
	IDPB A,H	;PUT IT IN OUR BUFFER
	CAIN A,15	;IF <CR>, PARSE
	 POPJ P,	; IF IT IS, WE HAVE FINISHED READING
	CAIN A,7	;IF CTRL/G,
	 JRST DONE	; FINISHED
	CAIN A,32	;IF CTRL/Z,
	 JRST DONE	; FINISHED
	JRST FT.LOO	;ELSE, GET MORE

FT.RUB:	JUMPE D,FT.LOO	;WE CAN'T RUB OUT NON-EXISTANT CHARACTERS
	IBP H
	IBP H
	IBP H		;ADVANCE THREE CHARACTERS
	SUBI H,1	;AND BACKWARDS FOUR (EIGHT BIT BYTE POINTER)
	.IOT TTYOCH,[^P]	;RUB IT OUT
	.IOT TTYOCH,["X]	;ON THE SCREEN
	SOJA D,FT.LOO	;ONE LESS CHARACTER, AND GO BACK FOR MORE

PARSE:	SETZM JCLP		;NO CHANCE FOR A JCL FROM NOW ON
	MOVE A,[FILDEV,,XDEV]	;SET UP DEFAULTS
	BLT A,XDEV+4		; TRANSFER 4
	MOVE H,[441000,,FILSPC]	;BYTE POINTER TO PARSE FROM
	PUSHJ P,READER		;READ IN A FILENAME
	MOVE A,[XDEV,,FILDEV]	;SET UP THE FILE SPEC
	BLT A,FILDEV+4		; TRANSFER 4
	POPJ P,		;AND FINISH

FILOPN:	.CALL [	SETZ
		SIXBIT /OPEN/
		[.UII,,DSKICH]
		JFFO ERRCOD	; ERROR CODE
		FILDEV
		FILFN1
		FILFN2
		SETZ FILDIR]
	 JRST FILERR		;IF UNSUCCESSFUL, TELL THE USER
	.CALL [SETZ
		SIXBIT /FILLEN/	;GET THE LENGTH (NUMBER OF WORDS)
		MOVEI DSKICH
		SETZM FILLEN]
	 .LOSE 1000
	MOVE A,[-200,,FILBEG/2000]	;MAP THE FILE INTO OUR ADDRESS SPACE 
				; STARTING AT LOCATION FILBEG (200000)
	SETZ B,
	.CALL [SETZ			;MAP IT IN
		SIXBIT /CORBLK/
		MOVEI %CBRED		;TRY FOR READ ACCESS
		MOVEI -1		;HACK MY OWN CORE
		A			;BLOCK MODE, GRAB AS MUCH AS POSSIBLE
		MOVEI DSKICH		;CHANNEL
		SETZ B]			;STARTING AT BEGINNING OF DISK FILE
	 .LOSE 1000
	.CLOSE DSKICH,
	POPJ P,			;AND RETURN

FILERR:				;COME HERE WHEN OPENING THE FILE LOSES
	MOVEI A,[ASCIZ /ERROR -- /]
	PUSHJ P,OUTST1
;;; Print out error message.  Expects to find error code in ERRCOD.
ERRPRN:	.CALL [	SETZ
		SIXBIT/OPEN/
		[.UAI,,ERRICH]
		[SIXBIT /ERR/]
		MOVEI 4
		SETZ ERRCOD]
	 .LOSE 1400
ERRPR1:	.IOT ERRICH,A
	CAIGE A,40
	 JRST [.close errich,	;CLOSE THE ERR DEVICE
		SETOM ERRFLG	;WE HAVE COMMITTED A NO NO
		POPJ P,]	;AND GET OUT
	.IOT TTYOCH,A
	JRST ERRPR1


SUBTTL INIT THE FILE, POINTERS AND ALL

INIFIL:	MOVE A,FILLEN	; LENGTH IN 36 BIT WORDS
	ADDI A,FILBEG-128.	;128. WORDS FROM THE END IS THE DOC DIR
	HRLI A,442000	; 16 BIT WORDS
	MOVEM A,DOCDIR	; THIS IS THE DOCUMENTATION DIRECTORY
	AOS A		; SKIP THE PASSWORD AND NUMBER OF RECORDS
	ILDB B,A	; NUMBER OF PARTS
	MOVEM B,PARTS	; STORE IT
	ILDB B,A	; FIRST RECORD OF PART DIR
	IMULI B,128.	; OFFSET from beginning in words
	ADDI B,FILBEG	; ADDRESS in our memory
	HRLI B,442000	; 16 BIT BYTE POINTER
	MOVEM B,PRTDIR	; STORE IT
	SETZM LSTPAG	; FOOL IT - THE LAST PAGE WE COMPUTED WAS ZERO
	MOVEI A,1	;  AND THE PAGE WE WANT TO SEE IS ONE (1)
	MOVEM A,PAGNUM

;get the fonts so we can really look at it
	move b,prtdir	;get the part dir address
	hrli b,242000	;and make a 16. bit pointer of it
	setzi c,	;we have looked at 0 parts so far
gfnt.a:	ldb e,b		;get the part type
	cain e,1	;1 stands for font type
	 pushj p,[push p,b ? push p,c ? pushj p,fntred ? pop p,c ? pop p,b ? popj p,]
	aos c
	caml c,parts	;if we have looked at too many
	 jrst gfnt.z	;we can finish
	addi b,2	;2 words to the next entry (4 16. bit words)
	jrst gfnt.a	;loop

gfnt.z:	POPJ P,

fntred:	ildb dl,b	;get the starting record number
	imuli dl,128.	;128 pdp-10 words per record
	addi dl,filbeg	;point it into the file
	hrli dl,441000	;make an 8 bit pointer out of it

	popj p,		;finish this later


;; When we really get going, there are a few things this section
;; must do that it doesn't do now. What it does now is toss things
;; out to the ascii output tty. This is wrong. What wants to be done
;; is figure out if a new page neds to be computed. If so, we must
;; clear our virtual page in memory, and then write on to it the new
;; data. Then it needs to set the NEED REDISPLAY flag, which
;; probably isn't even in the program yet.

;; NWPAGE:	MOVE A,LSTPAG	;THE LAST PAGE COMPUTED
;; 	CAIN A,PAGNUM	;THE REQUESTED PAGE
;; 	 POPJ P,	; IF THE SAME, JUST GET OUT


NWPAGE:	.IOT IMAGE,[%TDCLR]	;DELETE THIS LATER
	SKIPG A,PAGNUM	;GET PAGE NUM AND MAKE SURE IT IS POSITIVE
	 MOVEI A,1	;ELSE MAKE IT REASONABLE
	MOVE B,PRTDIR	;START FROM THE BASE OF THE PRTDIR
	HRLI B,242000	;MAKE A 16. BIT BYTE POINTER
	 MOVE F,B	; DEFAULT FIRST PAGE
	SETZI C,	;THIS IS PAGE ZERO
	SETZI D,	;THE PART NUMBER WE ARE ATTEMPTING

NWPG.2:	LDB E,B		;GET THE PART TYPE
	JUMPN E,NWPG.3	;IF A PAGE PART
	 AOS C		; INCREMENT C
	 MOVE F,B	; AND F IS THE LAST VALID PAGE PART POINTER
NWPG.3:	CAMN A,C	;IF WE HAVE FOUND A MATCH
	 JRST NWPG.4	; EXIT THE LOOP
	AOS D		;INCREMENT NUMBER OF PARTS SKIPPED
	CAML D,PARTS	;IF STILL LESS THAN, OK
	 JRST NWPG.4	; ELSE OVERFLOW AND EXIT
	ADDI B,2	;2 WORDS TO THE NEXT ENTRY (4 16. BITTERS)
	JRST NWPG.2	;TRY AGAIN
NWPG.4:	MOVEM C,PAGNUM	;C HAS THE PAGE NUM, REGARDLESS OF OVERFLOW
			; AND F HAS THE LAST VALID POINTER
	ILDB DL,F	;GET THE STARTING RECORD NUMBER FOR THE PAGE PART
	ILDB C,F	;GET THE NUMBER OF RECORDS IN FOR THIS PART
	ILDB D,F	;AND THE NUMBER OF LEFT OVER WORDS
	ADD C,DL	;C NOW POINTS TO THE RECORD JUST BEYOND THE PART
	IMULI DL,128.	;128. PDP-10 WORDS PER RECORD
	IMULI C,128.	; AND AGAIN
	ADDI DL,FILBEG	;POINT IT INTO THE FILE
	ADDI C,FILBEG	; AND AGAIN
	HRLI DL,441000	;THE DATA LIST IS 8 BIT BYTES
	MOVEM DL,PPBOT	;SAVE THE BASE IN CASE WE NEED TO START OVER WITH IT
;; FIGURE OUT HOW MANY ENTITIES THERE ARE
	MOVE A,D	;GET THE LENGTH OF THE ENTITY
	LSH A,-1	;DIVIDE BY TWO (OUR WORDS ARE 32., NOT 16.
	SUBI C,1(A)	;SUBTRACT IT FROM THE VERY TOP, AND AN EXTRA WORD
	HRLI C,442000	;MAKE A BYTE POINTER OUT OF IT
	TRNN D,1	;TEST D FOR ODDNESS
	 IBP C		; GETS TO THE RIGHT BYTE IF IT WAS ODD
	MOVEM C,PPTOP	;THIS IS THE VERY TOP OF THE ENTITIES FOR THIS PAGE
	ILDB D,C	;GET THE LENGTH OF THIS ENTITY (IN 16. BIT WORDS)
	SETZ E,		;START WITH ZERO ELEMENTS
NWPG.6:	AOS E		;INCREMENT THE ENTITY COUNT
	MOVE A,D	;THIS HACK AGAIN
	LSH A,-1	;DIV BY TWO
	SUBI C,1(A)	;GO BACKWARDS
	TRNN D,1	;DO WE NEED TO GO FORWARD?
	 IBP C		; DO IT IF SO
	ILDB D,C	;GET THE NUMBER OF WORDS(16) IN THIS ENTITY
	JUMPN D,NWPG.6	;IF NOT ZERO, THERE ARE MORE ENTITIES
	MOVEM E,NUMENT	;SAVE THE NUMBER OF ENTITIES
;; PERFORM THE INSTRUCTIONS OF EACH ENTITY
	SETZM ENTNUM	;STARTING FROM THE LOWER SECTIONS
NWPG.A:	AOS A,ENTNUM	;START SCANING FOR THE NEXT ELEMENT
	CAMLE A,NUMENT	;SKIP IF MORE ELEMENTS TO BE PROCESSED
	 JRST NWPG.X	;IF FOUND, EXIT THE LOOP SO WE CAN PROCESS IT
	MOVE B,NUMENT	;COUNT-DOWN COUNTER
	MOVE C,PPTOP	;START FROM THE TOP
NWPG.C:	CAMN B,A	;IF WE HAVE FOUND THE ELEMENT WE WANT
	 JRST NWPG.E	; EXIT THE LOOP, WE HAVE FOUND IT
	SOJ B,		;COUNT-DOWN POINTERS ARE FOR COUNTING DOWN
	ILDB D,C	;GET THE LENGTH OF THE ENTITY
	MOVE E,D
	LSH D,-1
	SUBI C,1(D)
	TRNN D,1
	 IBP C
	JRST NWPG.C
NWPG.E:	MOVEM C,ENTTOP	;SAVE THE ILDB'ABLE POINTER TO THE TOP OF THE ENTITY
	ILDB A,C	;THE LENGTH OF THE ENTITY
	SUBI C,6.	;THERE ARE 12 USEFUL WORDS OF INFO IN THE TRAILER
	SUB C,[001000,,0]	;CONVERT IT FROM 16. BIT TO 8. BIT POINTER
	MOVEI B,ENTTRL	;POINT AT THE ENTITY TYPE
	HRLI B,-2	;TWO BYTES
NWPG.G:	ILDB D,C	;GET A BYTE
	MOVEM D,(B)	;STORE IT
	AOBJN B,NWPG.G	;INCREMENT LOCATION, AND COUNTER
	ADD C,[001000,,0]	;GO BACK TO 16. BIT MODE
	HRLI B,-2	;TWO 32. BIT WORDS
NWPG.I:	ILDB E,C	;GET THE HIGH ORDER WORD
	LSH E,16.	;TIMES 2^16
	ILDB D,C	;LOW ORDER
	ADD D,E		;THE 32. BIT QUANTITY
	MOVEM D,(B)	;STORE IT
	AOBJN B,NWPG.I	;NEXT 32. BIT VALUE
	HRLI B,-7	;7 WORDS OF INTEREST HERE
NWPG.K:	ILDB D,C	;GET IT
	MOVEM D,(B)	;STORE IT
	AOBJN B,NWPG.K	;AND KEEP GOING
	AOS B,D		;GO BACK (N+1)/2 WORDS AND FORWARD AS NECCESARY
	LSH D,-1	;DIV BY TWO
	SUB C,D		;BACK UP
	TRNN B,1	;GO FORWARD
	 IBP C		; IF WAS ODD (MADE EVEN BY INCREMENTATION)
	SUB C,[001000,,0]	;MAKE IT AN 8. BIT POINTER
	MOVEM C,ENTBOT	;THE POINTER TO START THE ENTITY LIST
	MOVE EL,C	;ALSO IN THE REGISTER
	MOVE 

	MOVE NUMCOM,ENTLEN	;LENGTH OF ENTITY
	SUBI NUMCOM,12.	;MINUS THE TRAILER
	LSH NUMCOM,1	;TIMES TWO, GIVES THE NUMBER OF BYTES FOR COMMANDS
NWPG.M:	JUMPLE NUMCOM,NWPG.A	;IF WE ARE FINISHED, GO DO NEXT ENTITY
	ILDB COM,EL	;GET A COMMAND
	SOS NUMCOM	;DECREMENT COUNT
	MOVE A,[JRST NWPG.M]	;COMMAND TO EXECUTE WHEN RETURNING
	MOVEM A,RETXCT		; FROM COMMAND PROCESSING

;; For speed, This is NOT an association table 

	CAIGE COM,40
	 JRST SHOWSH	;[0,37] = SHOW CHARACTERS SHORT
	CAIGE COM,100
	 JRST SKIPSH	;[40,77] = SKIP CHARACTERS SHORT
	CAIGE COM,140
	 JRST SHWSKP	;[100,137] = SHOW CHARACTERS AND SKIP
	CAIGE COM,150
	 JRST SSPXSH	;[140,147] = SET SPACE X SHORT
	CAIGE COM,160
	 JRST SSPYSH	;[150,157] = SET SPACE Y SHORT
	CAIGE COM,200
	 JRST FONT	;[160,177] = FONT
	CAIGE COM,240
	 JRST AVAIL	;[200,237] = AVAILABLE
	CAIGE COM,353
	 JRST SPARE	;[240,352] = SPARE
	JRST @COMTBL-353(COM)
COMTBL:	SKPCBI		;SKIP CONTROL BYTES IMMEDIATE
	ALTERN		;ALTERNATE
	ONLYON		;ONLY ON COPY
	SETX		;SET X
	SETY		;SET Y
	SHOWCH		;SHOW CHARACTERS
	SKIPCH		;SKIP CHARACTERS
	SKIPCB		;SKIP CONTROL BYTES
	SHOWI		;SHOW CHARACTER IMMEDIATE
	SETSPX		;SET SPACE X
	SETSPY		;SET SPACE Y
	RSETSP		;RESET SPACE
	SPACE		;SPACE
	SETBRI		;SET BRIGHTNESS
	SETHUE		;SET HUE
	SETSAT		;SET SATURATION
	SHOWOB		;SHOW OBJECT
	SHOWDT		;SHOW DOTS
	SHWDTO		;SHOW DOTS OPAQUE
	SHOWRE		;SHOW RECTANGLE
	NOP		;NOP

NWPG.X:	MOVE A,PAGNUM
	MOVEM A,LSTPAG
	POPJ P,


SHOWSH:	ADDI COM,1	;COM=0+N-1 ==> N=COM+1
	JRST SHOW
SKIPSH:	SUBI COM,<40-1>	;COM=40+N-1 ==> N=COM-<40-1>
	JRST SKIPDO
SHWSKP:	PUSH P,RETXCT	;SAVE RETURN INSTRUCTION
	MOVE A,[POPJ P,]
	MOVEM A,RETXCT	;NEW RETURN
	SUBI COM,<100-1>	;COM=100+N-1 ==> N=COM-<100-1>
	PUSHJ P,SHOW	;SHOW THE CHARS
	POP P,RETXCT	;RESTORE THE RETURN INSTRUCTION
	MOVEI COM,1
	JRST SKIPDO	;SKIP ONE CHARACTER
SSPXSH:	XCT RETXCT	;NOT YET THOUGHT ABOUT
SSPYSH:	XCT RETXCT
FONT:	XCT RETXCT

define defmly family,entry
	[asciz /family/],,entry
termin

define fontto points,size,face,fn1,fn2
	<size_9+face>,,[sixbit /fn1/ ? sixbit /fn2/]
termin

fmlies:	defmly TIMESROMAN,F$TR
	defmly LPT,F$LPT
	defmly GACHA,F$GACH
	defmly HELVETICA,F$HELV
	defmly APL,F$APL
	defmly CMB,F$CMB
	defmly CMI,F$CMI
	defmly CMR,F$CMR
	defmly CMSC,F$CMSC
	defmly CMSY,F$CMSY
	defmly CMTI,F$CMTI
	defmly CMU,F$CMU
	defmly CREAM,F$CREA
	defmly DOTS,F$DOTS
	defmly ELITE,F$ELIT
	defmly GATES,F$GATE
	defmly HIPPO,F$HIPP
	defmly MATH,F$MATH
	defmly SAIL,F$SAIL
	defmly SLIDESCMATHX,F$SCMX
	defmly SLIDESCMI,F$SCMI
	defmly SLIDESCMR,F$SCMR
	defmly SLIDESCMSY,F$SCMS
	defmly SYMBOL,F$SYMB
	defmly TEMPLATE,F$TEMP
	defmly TIMESROMAND,F$TRD
	defmly TIMESROMANSC,F$TRSC
	0,,0

;; For the face:
;; 	Bold=1
;; 	Light=2
;; 	--------
;; 	Italic=4
;; 	

RADIX 10.
F$TR:	;fontto 6,212		;these don't exist for altos
	;fontto 7,247
	;fontto 8,282
	;fontto 9,317
	fontto 10,423,0,tr10,>
	fontto 10,423,1,tr10b,>
	fontto 10,423,4,tr10i,>
	fontto 12,423,0,tr12,>
	fontto 12,423,1,tr12b,>
	fontto 12,423,4,tr12i,>
	;fontto 17,599
	fontto 18,635,0,tr18,>
	0,,0			;TIMESROMAN
F$LPT:	0,,0			;LPT
F$GACH:	0,,0			;GACHA
F$HELV:	0,,0			;HELVETICA
F$APL:	fontto 8,282,0,apl,>
	fontto 12,353,0,apl,>
	0,,0			;APL
F$CMB:	0,,0			;CMB
F$CMI:	0,,0			;CMI
F$CMR:	0,,0			;CMR
F$CMSC:	0,,0			;CMSC
F$CMSY:	0,,0			;CMSY
F$CMTI:	0,,0			;CMTI
F$CMU:	0,,0			;CMU
F$CREA:	0,,0			;CREAM
F$DOTS:	0,,0			;DOTS
F$ELIT:	0,,0			;ELITE
F$GATE:	0,,0			;GATES
F$HIPP:	0,,0			;HIPPO
F$MATH:	0,,0			;MATH
F$SAIL:	0,,0			;SAIL
F$SCMX:	0,,0			;SLIDESCMATHX
F$SCMI:	0,,0			;SLIDESCMI
F$SCMR:	0,,0			;SLIDESCMR
F$SCMS:	0,,0			;SLIDESCMSY
F$SYMB:	0,,0			;SYMBOL
F$TEMP:	0,,0			;TEMPLATE
F$TRD:	0,,0			;TIMESROMAND
F$TRSC:	0,,0			;TIMESROMANSC

RADIX 8.




AVAIL:	XCT RETXCT	;EFFECTIVLY A NOP
SPARE:	XCT RETXCT	;ALSO A NOP
SKPCBI:	PUSHJ P,ARG1	;GET A 1 BYTE ARG
	SUB NUMCOM,A	;WE ARE SKIPPING ENTITY LIST CONTROL BYTES
	IDIVI A,4	;GET NUMBER OF PDP-12 WORDS
	ADD EL,A	;SKIP MOST OF THEM
	JUMPE A+1,SKPC.1	;IF THE REMAINDER IS 0, FINISHED
	IBP EL		;THERE IS A NEED TO SKIP ONE
	SOJG A+1,.-1	;KEEP GOING
SKPC.1:	XCT RETXCT	;FINISHED
ALTERN:	PUSHJ P,ARG2	;TAKES A WORD ARG (2 BYTES)
	PUSHJ P,ARG4	;AND A QUAD BYTE
	PUSHJ P,ARG4	;AND ANOTHER
	XCT RETXCT
ONLYON:	PUSHJ P,ARG1	;TAKES A BYTE ARG
	XCT RETXCT
SETX:	PUSHJ P,ARG2	;TAKES A TWO BYTE ARG
	ADD A,XE	;OFFSET WITH XE
	MOVEM A,GXPOS	;SET THE GRPAHIC X POSITION
	PUSHJ P,SETPNT
	XCT RETXCT
SETY:	PUSHJ P,ARG2	;TAKES A TWO BYTE ARG
	ADD A,YE	;OFFSET WITH YE
	MOVEM A,GYPOS	;SET THE GRPAHIC Y POSITION
	PUSHJ P,SETPNT
	XCT RETXCT
SHOWCH:	PUSHJ P,ARG1	;TAKES A BYTE
	MOVE COM,A	;THE SHOW ROUTINE TAKES THE NUMBER IN COM
	JRST SHOW
SKIPCH:	PUSHJ P,ARG1	;TAKES A BYTE
	MOVE COM,A	;THE SKIP ROUTINE TAKES THE NUMBER IN COM
	JRST SKIPDO
SKIPCB:	PUSHJ P,ARG2	;TAKES A WORD ARG
	MOVE COM,A	;PUT IT IN A
	PUSHJ P,ARG1	;GET THE 'TYPE' FOR THIS COMMAND
	JRST SKIPDO	;SKIP THE CHARS
SHOWI:	PUSHJ P,ARG1	;TAKES A BYTE TO DISPLAY
	PUSHJ P,SHOWIT	;SHOW THE BYTE
	XCT RETXCT
SETSPX:	PUSHJ P,ARG2	;TAKES A WORD
	XCT RETXCT
SETSPY:	PUSHJ P,ARG2	;TAKES A WORD
	XCT RETXCT
RSETSP:	XCT RETXCT	;RESET THE SPACING PARAMETER
SPACE:	XCT RETXCT
SETBRI:
SETHUE:
SETSAT:	PUSHJ P,ARG1
	XCT RETXCT
SHOWOB:	PUSHJ P,ARG2
	MOVE COM,A
	JRST SKIPDO	;TREAT THIS AS A NOP FOR NOW
SHOWDT:	PUSHJ P,ARG4	;TAKES A QUAD BYTE
	XCT RETXCT
SHWDTO:	PUSHJ P,ARG4	;SAME AS SHOW DOTS
	XCT RETXCT
SHOWRE:	PUSHJ P,ARG2	;GET THE WIDTH
	PUSHJ P,ARG2	;GET THE HEIGHT
	XCT RETXCT
NOP:	XCT RETXCT


ARG1:	MOVEI C,1
	JRST .+4
ARG2:	MOVEI C,2
	SKIPA
ARG4:	MOVEI C,4
	SETZ A,
ARGLOO:	LSH A,8
	ILDB B,EL
	ADD A,B
	SOS NUMCOM
	SOJG C,ARGLOO
	POPJ P,

SHOW:	SKIPN COM	;CHECK FOR FINISHED
	 XCT RETXCT	; IF SO
	ILDB A,DL	;GET A BYTE FROM THE DATA LIST
	PUSHJ P,SHOWIT	;SHOW THE CHARACTER
	SOJA COM,SHOW	;DECREMENT AND JUMP

SHOWIT:	.IOT IMAGE,A
	POPJ P,

SKIPDO:	IDIVI COM,4	;FOUR BYTES TO THE WORD
	ADD DL,COM	;DO THE SKIPING
	JUMPE COM+1,CPOPJ	;IF EXACTLY FOUR, WE'RE GOLDEN
	IBP DL		;THERE IS A NEED TO SKIP
	SOJG COM+1,.-1	;KEEP GOING IF NECESSARY
	POPJ P,

SETPNT:	.IOT IMAGE,[%TDSET]
	MOVE A,GXPOS
	SUBI A,4000.
	PUSHJ P,FOO
	MOVE A,GYPOS
	PUSHJ P,FOO
	.IOT IMAGE,[%TDCHR]
	POPJ P,
FOO:	SUBI A,12700.
	IDIVI A,40
	SKIPGE B,A
	 MOVN B,B
	MOVEI C,100
	SKIPGE A
	 AOS C
	MOVE D,B
	ANDI D,37
	LSH D,1
	ADD C,D
	.IOT IMAGE,C
	MOVEI C,100
	MOVE D,B
	LSH D,-5
	ANDI D,37
	ADD C,D
	.IOT IMAGE,C
	POPJ P,
	

REDISP:	JUMPA PROMPT	;DELETE THIS LATER
	MOVEI C,64.
RD.2:	.IOT IMAGE,[%TDNOP]
	SOJG C,RD.2
	.IOT IMAGE,[%TDCLR]

;; CONSIDERING I CHANGED THE WAY MEMORY IS ORGANIZED, PERHAPS
;; THIS SHOULD BE REWRITTEN
;; Well here goes the attempt.

;; COMPUTE THE ACTUAL WIDTH (IN BITS) OF EACH SCAN LINE WE WILL OUTPUT
;; 	H GETS THE NUMBER OF BLANK BITS ON THE LEFT OF THE SCREEN
;; 	G GETS THE STARTING BIT(WORD) IN MEMORY TO START
;; 	F GETS THE NUMBER OF BITS ACTUALLY OUTPUT

	.IOT IMAGE,[%TDCHR]	;GO BACK TO CHARACTER MODE

PROMPT:	.IOT TTYOCH,[^P]		;HOME DOWN CURSOR
	.IOT TTYOCH,["Z]
	.IOT TTYOCH,[^P]
	.IOT TTYOCH,["L]		;CLEAR TO END OF LINE
	MOVEI A,[ASCIZ /PAGE #/]
	PUSHJ P,OUTST1
	MOVE A,PAGNUM
	PUSHJ P,DECTYP			;TYPE OUT THE PAGE NUMBER
	MOVEI A,[ASCIZ / -->/]
	PUSHJ P,OUTST1
	POPJ P,

DECTYP:	SETZ C,			;TYPE OUT A POSITIVE DECIMAL INTEGER IN A.
DECT1:	IDIVI A,10.		;   CLOBBERS B & C & A
	ADDI B,60		;MAKE IT ASCII
	PUSH P,B
	ADDI C,1
	JUMPN A,DECT1
DECT2:	POP P,A
	.IOT TTYOCH,A
	SOJG C,DECT2
	POPJ P,

tvbox:	<<<%tdset_8+121>_8+120>_8+174>_4	; complete and utter hair
	<<<117_8+%tdlng>_8+144>_8+132>_4	; what this does is draw
	<<<120_8+120>_8+%tdlng>_8+120>_4	; the box around the xgp
	<<<120_8+141>_8+133>_8+%tdlng>_4	; page when we are in 
	<<<145_8+132>_8+120>_8+120>_4		; mini-mode. For details,
	<<<%tdlng_8+120>_8+120>_8+140>_4	; see  .INFO.;ARDS >
	<<<133_8>_8>_8>_4

TVSET:	<<<%TDSET_8+121>_8+120>_8+120>_4
	<<<120_8+%TDBIT>_8+<SCRE.W*4>>_8+000>_4



WORK:	SETZ H,		;THE NUMERIC ARG
	SETZ G,		;THE MINUS FLAG
	SETZI F,	;NUMBER OF CHARS READ
WORK.1:	.IOT TTYICH,A

;; THIS IS A CROCK. IT SHOULD REALLY HAVE AN INPUT BUFFER THAT GETS
;; SCANNED ON ACTIVATION CHARACTERS, AND SHORTENED BY RUBOUTS

	CAIE A,40	;IGNORE A SPACE
	 JRST WORK.3
	  .IOT TTYOCH,[^P]
	  .IOT TTYOCH,["X]	;ERASE THE CHARACTER
	  JRST WORK.1
WORK.3:	SETZM TOPSET
	AOJ F,
	MOVEI B,1	;THE MULTIPLIER
	TRZ A,%TXSFL+%TXSFT
	TRZE A,%TXTOP
	 SETOM TOPSET
	TRZE A,%TXMTA
	 LSH B,2	;META BY 4
	TRZE A,%TXCTL
	 LSH B,1	;CONTROL BY 2

	CAIGE A,"0
	 JRST WORK.A
	CAILE A,"9
	 JRST WORK.A	;IF NOT A NUMBER, DO TABLE HAIR
	IMULI H,12.
	ADDI H,-"0(A)
	JRST WORK.1

WORK.A:	PUSHJ P,MAKASC	;UPPER CASIFY THE CHAR
	SKIPE TOPSET	;IF TOP WAS SET,
	 IORI A,%TXTOP	; SET IT BACK
	MOVEI C,KEYTBL	;THE KEYBOARD TABLE
WORK.C:	HRRZ D,(C)	;GET THE NEXT CHARACTER FOR COMPARISON
	SKIPN D		;IF IT EXISTS, WE ARE OK
	 JRST PROMPT	; ELSE WE DON'T KNOW WHAT THIS MEANS
	CAMN A,D
	 JRST WORK.G
	AOJA C,WORK.C	;INCREMENT TABLE AND TRY AGAIN
WORK.E:	.IOT TTYOCH,[7]
	SOS (P)		;COME BACK TO THE KEYBOARD ROUTINE AFTER PROMPTING
	JRST PROMPT
WORK.G:	HLRZ D,(C)
	JRST (D)

WRKARG:	SKIPE G		;IF MINUS WAS STRUCK
	 SOS F		;DON'T COUNT IT AS A CHARACTER
	CAIN F,1	;IF ONE CHARACTER
	 MOVEI H,1	;MAKE ARG A 1
	SKIPE G		;IF MINUS STRUCK
	 MOVN H,H	;NEGATE THE POSITIVE ARG
	POPJ P,


KEYTBL:	LEFT,,"[
	LEFT,,"{
	RIGHT,,"]
	RIGHT,,"}
	UP,,"\
	UP,,"|
	DOWN,,"/
	DOWN,,^N		;INFINITY SIGN

	LEFT,,"L+%TXTOP
	RIGHT,,"R+%TXTOP
	UP,,"U+%TXTOP
	DOWN,,"D+%TXTOP

	HOME,,"H
	CENTER,,"C
	TOPCEN,,^F	;TOP C
	GOLEFT,,^M	;return

	QUAD1,,"C+%TXTOP	;CLEAR key
	QUAD2,,^I		;TAB
	QUAD3,,^L		;FORM
	QUAD4,,^K		;VT

	QUAD1,,"1+%TXTOP
	QUAD2,,"2+%TXTOP
	QUAD3,,"3+%TXTOP
	QUAD4,,"4+%TXTOP

	NEXT,,"N
	NEXT,,"A
	PREV,,"P
	DONE,,"Q
	FULL,,"R
	GOPAGE,,"G
	HELP,,"?
	help,,"?+%txtop	;sipb keyboard lossage
	MINI,,"M
	MINUS,,"-
	RUBOUT,,177	;RUBOUT
	WORK.1,,40

	0,,0


RIGHT:	MOVN B,B	;MAKE ARG NEGATIVE
LEFT:	IMULI B,MOVINC	;MULTIPLY IT BY THE INCREMENT
	ADDM B,XOFF	;SAVE IT
	JRST FULL

UP:	MOVN B,B
DOWN:	IMULI B,MOVINC
	ADDM B,XOFF
	JRST FULL

HOME:	SETZM YOFF
GOLEFT:	SETZM XOFF
	JRST FULL

CENTER:	MOVEI A,P.WIDE/2-VP.WID/2	;THIS HAIR PUTS THE UPPER
	MOVEM A,XOFF			;LEFT HAND CORNER OF THE
	MOVEI A,P.HIGH/2-VP.HIG/2	;SCREEN AT THE CENTER OF THE
	MOVEM A,YOFF			;PAGE, ADJUSTED FOR HOW MUCH
	JRST FULL			;OF THE PAGE WE ARE ABLE TO SEE

TOPCEN:	MOVEI A,P.WIDE/2-VP.WID/2
	MOVEM A,XOFF
	SETZM YOFF
	JRST FULL

QUAD1:	MOVEI T,P.WIDE/3-VP.WID/2
	SKIPA
QUAD2:	MOVEI T,2*P.WIDE/3-VP.WID/2
	MOVEM T,XOFF
	MOVEI T,P.HIGH/3-VP.HIG/2
	MOVEM T,YOFF
	JRST FULL

QUAD3:	MOVEI T,P.WIDE/3-VP.WID/2
	SKIPA
QUAD4:	MOVEI T,2*P.WIDE/3-VP.WID/2
	MOVEM T,XOFF
	MOVEI T,2*P.HIGH/3-VP.HIG/2
	MOVEM T,YOFF
	JRST FULL


MINI:	SETOM MODE
	POPJ P,
FULL:	SETZM MODE
	POPJ P,

HELP:	MOVEI A,[ASCIZ#  DPRESS COMMANDS:
nN---NEXT PAGE(S)
nP--PREVIOUS PAGE(S)
H---HOME WINDOW TO TOP LEFT
C---CENTER WINDOW ON PAGE
TOP-C MOVE WINDOW TO TOP CENTER OF PAGE
Q---QUIT
R---REDISPLAY PAGE
M--REDISPLAY PAGE IN MINI-DISPLAY MODE
nA--ADVANCE n PAGES
nG--GO TO nTH PAGE
?---TYPE THIS CRUFT
[---MOVE PAGE LEFT  \  /  CTRL MULTIPLIES BY 2
]---MOVE PAGE RIGHT |--|  META MULTIPLIES BY 4
\---MOVE PAGE UP    |  |  TOP  MULTIPLIES BY 16
/---MOVE PAGE DOWN  /  \  SHIFT IS IGNORED
RETURN--GO TO THE LEFT OF THE PAPER

FOR MORE DETAILED INSTRUCTIONS, SEE .INFO.;XD ORDER.
#]
	PUSHJ P,OUTSTR	;OUTPUT THE HELP MESSAGE
	PUSHJ P,PROMPT	;REDISPLAY THE PROMPT
	JRST WORK	;GO AFTER A KEYBOARD COMMAND

PREV:	PUSHJ P,WRKARG	;GET THE ARG
	MOVN H,H	;PREVIOUS IS A BACKWWARDS OPERATION
	SKIPA		;DON'T NEED THE ARG TWICE
NEXT:	PUSHJ P,WRKARG
	ADDM H,PAGNUM
	POPJ P,
GOPAGE:	PUSHJ P,WRKARG	;GET THE ARG
	MOVEM H,PAGNUM
	POPJ P,

MINUS:	CAIE F,1	;IS THIS THE FIRST CHARACTER?
	 JRST WORK.E	;IF NOT BARF AND RESTART
	SETO G,		;SET THE MINUS FLAG
	JRST WORK.1	;GO AFTER NEXT CHARACTER

RUBOUT: SOJE F,WORK	;SUBTRACT THE RUBOUT
	.IOT TTYOCH,[^P]
	.IOT TTYOCH,["X]	;ERASE THE LAST CHARACTER
	SOJE F,WORK	;DECREMENT NUMBER OF CHARACTERS IN, AND IF NONE, START OVER
	IDIVI H,12.	;GET RID OF LAST CHARACTER
	JRST WORK.1	;GO AFTER NEXT CHARACTER


SUBTTL SUPPORT ROUTINES

;; Get pages so that we can put data in words up to, BUT NOT
;; INCLUDING the adress of T

GETUPT:	PUSH P,T
	PUSH P,TT
	SOS T		;HERE IS OUR NOT INCLUDING PART
	IDIVI T,2000	;CHANGE THE ADRESS TO A PAGE NUMBER
GETUP2:	CAMGE T,FREEPG	;SKIP IF WE NEED TO GET A PAGE
	 JRST [POP P,TT ? POP P,T ? POPJ P,]
	.CALL [SETZ
		SIXBIT /CORBLK/
		MOVEI %CBNDW	;MUST HAVE IT
		MOVEI %JSELF
		FREEPG
		SETZI %JSNEW]
	 .LOSE 1000
	AOS FREEPG
	JRST GETUP2

OUTSTR:	.IOT TTYOCH,[15]
	.IOT TTYOCH,[12]
OUTST1:	PUSH P,B
	MOVE B,A
	HRLI B,440700
OUTS1:	ILDB A,B
	JUMPE A,CPOPBJ
	CAIN A,14	    ;IT SHOULD STOP ON SEEING FORMFEED, FOR THE ERR DEVICE
	 JRST CPOPBJ
	.IOT TTYOCH,A
	JRST OUTS1

CPOPBJ:	POP P,B
CPOPJ:	POPJ P,

MAKASC:	TRNE A,%TXCTL
	 ANDI A,37
	CAIL A,"a
	 CAILE A,"z
	  POPJ P,
	SUBI A,40
	POPJ P,


SUBTTL FILE NAME READER

;; This takes an eight bit byte pointer in H and parses it into
;; sixbit, putting the resultant DEVICE, DIRECTORY, FN1 and FN2 in
;; XDEV, XDIR, XFN1, XFN2, and returning after encountering a comma,
;; or anything less than 40(octal)


;; ZR is a flag indicatin whether the next filename token goes in FN1 or FN2
;; A holds the temporary character
;; B holds the token as it is being accumulated
;; C is the number of characters in the token

READER:	SETZI ZR,	;CLEAR THE MAGIC FLAG
READE2:	SETZI B,	;NO TOKEN
	SETZI C,	;NO CHARACTERS YET
REANEX:	ILDB A,H	; GET A CHAR INTO AC A
	CAIN A,":
	 JRST READEV
	CAIN A,";
	 JRST READIR
	CAIG A,40
	 JRST READEL	;IF NOT >40, DELIMITER
	CAIN A,",
	 JRST READEL	;COMMA IS A DELIMITER
	CAIL A,"a
	 CAILE A,"z
	  SUBI A,40	;IF NOT LOWER CASE, CONVERT TO SIXBIT
			;  (LOWER CASE IS ALREADY SIXBIT)
	LSH B,6		;MAKE ROOM FOR THE NEXT CHARACTER
	ADD B,A		;ADD IT IN
	TRO ZR,1
	AOJA C,REANEX	;WE HAVE READ ANOTHER CHARACTER, SO GO BACK

READEV:	PUSHJ P,READ.C	;CANONICALIZE
	MOVEM B,XDEV	; COLON, THIS IS THE DEVICE NAME
	TRZ ZR,2	;GO BACK AND PICK UP FN1 ON THE NEXT ROUND
	JRST READE2

READIR:	PUSHJ P,READ.C	;CANONICALIZE
	MOVEM B,XDIR	; SEMI, THIS IS THE SNAME
	TRZ ZR,2	;GO BACK AND PICK UP FN1 ON THE NEXT ROUND
	JRST READE2

READEL:	PUSHJ P,READ.C	;CANONICALIZE
	JUMPE B,READE1	; DELIMITER, IF NOTHING INPUT THEN DONT CLOBBER ANYTHING
	TRNE ZR,2
	 MOVEM B,XFN2	;  IT IS SET, SO WE ALREADY GOT THE FN1
	TRNN ZR,2
	 MOVEM B,XFN1	; THIS IS THE FIRST TIME, STORE IN FN1 AND SET THE FLAG
	XORI ZR,2	;COMPLEMENT THE BIT
READE1:	CAIN A,40	; IF NOT A SPACE, RETURN, LEAVING
	 JRST READE2	;     WHATEVER IT WAS IN AC A
	TRNE ZR,1
	 POPJ P,	; (IF NOTHIG HAS HAPPENED)
	TLO A,-1	; IF NOTHING WAS EVER READ, SET LEFT HALF OF A TO -1
	POPJ P,

READ.C:	CAIL C,6	;DO WE HAVE AT LEAST CHARACTERS
	 POPJ P,	; YES
	LSH B,6		;ELSE ADD A SPACE
	AOJA C,READ.C	;INC CHAR COUNT AND LOOP

DONE:	.VALUE [ASCIZ /: TEST ENDING 
/]
	JRST GO
	.BREAK 16,160000


GXPOS:	0		;X POSTITION OF GRAPHIC CURSOR
GYPOS:	0		;Y POSTITION OF GRAPHIC CURSOR

topset:	0		;TELLS IF THE TOP BIT WAS SET FOR THIS KEY

ERRFLG:	0		;STATE OF THE WORLD (INDICATION OF)
FILDEV:	SIXBIT /DSK/	;DEFAULTS
FILFN1:	SIXBIT /.FOO./
FILFN2:	SIXBIT /PRESS/
FILDIR:	0		;INIT'ED TO THE MSNAME

XDEV:	0		;TEMPORARIES
XFN1:	0
XFN2:	0
XDIR:	0

ERRCOD:	0			; CODE OF ERROR COMMITED, FOR THE ERRDEV SUBROUTINE
RXCT:	0			; WHERE THE APPROPRIATE BYTE INCREMENT
				;  GETS PUT FOR FILE PARSING

DOCDIR:	0		;ADDRESS OF THE DOCUMENTATION DIRECTORY
PARTS:	0		;THE NUMBER OF PARTS FOR THIS FILE
PRTDIR:	0		;THE ADDRESS FOR THE DIRECTORY FOR THE PARTS
PPBOT:	0		;THE BOTTOM OF THE PAGE PART (DATA LIST)
PPTOP:	0		;TOP OF THE PAGE PART. (IN ILDB FORMAT, NOT LDB)
ENTTOP:	0		;TOP OF THE CURRENT ENTITY
ENTBOT:	0		;BOTTOM OF THE CURRENT ENTITY LIST (ILDB FORMAT)
NUMENT:	0		;NUMBER OF ENTITIES IN THIS PAGE PART

ENTNUM:	0		;NUMBER OF THE ENTITY BEING PROCESSED

;; THIS IS THE ENTITY TRAILER:
ENTTRL:
ENTTYP:	0		;THE ENTITY TYPE
FNTSET:	0		;THE FONT SET
BEGBYT:	0		;OFFSET OF START INTO THE DATA LIST
BYTLEN:	0		;NUMBER OF BYTES IN THE DATA LIST
YE:	0		;Y OFFSET OF THIS ENTITY
XE:	0		;X OFFSET OF THIS ENTITY
PGLEFT:	0		;LEFT BOUNDS (NOT CONFUSED WITH THE LEFT COMMAND)
BOTTOM:	0		;BOTTOM BOUNDS
WIDTH:	0		;WIDTH OF DISPLAY REGION
HEIGHT:	0		;HEIGHT OF DISPLAY REGION
ENTLEN:	0		;LENGTH OF THIS ENTITY IN 16. BIT WORDS

RETXCT:	0		;THE INSTRUCTION FOR RETURNING FROM A COMMAND PROCESS
LSTPAG:	0		;THE LAST PAGE THAT WAS COMPUTED
PAGNUM:	1		;THE PAGE BEING VIEWED


;; PAGE OREIANTATION VALUES
MODE:	0		;-1 <=> MINI MODE , 0 <=> FULL MODE
XOFF:	0		;WHERE THE LEFT HAND SIDE OF SCREEN IS, IN MICAS
YOFF:	0		;WHERE THE TOP OF THE SCREEN IS, IN MICAS


FREEM:	FS		;THE ADDRESS OF THE LAST FREE WORD
FREEPG:	FS/2000		;THE LAST PAGE WE KNOW ABOUT
FILLEN:	0		;LENGTH OF THE FILE, IN WORDS
JCLP:	-1		;JCL IS TESTED WHEN WE ENTER
FILSPC:	BLOCK 120	; FILE SPEC, FROM JCL OR TTY
PDB:	BLOCK PDLLEN


	CONSTANTS

	LOC <.+1777>/2000*2000	;ALIGN THE PAGE BOUNDARY
VPAGE=.
	LOC <<.+VPSIZE>+1777>/2000*2000	;THE ALTO IMAGE OF THE DOVER PAGE


FS=.	;BEGINING OF FREE STORAGE

	END GO


;Local Modes:
;Mode:MIDAS
;COMMENT COLUMN:24
;END:
