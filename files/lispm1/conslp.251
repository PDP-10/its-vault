;;;     CONS MICRO ASSEMBLER			-*-LISP-*-
; THIS IS GOING TO HAVE TO BE FIXED TO REPLACE MANY NUMBERS
; AND BYTE-FIELDS WITH SYMBOLS, FOR CADR.


(DECLARE (CLOSED T))
;(SETQ DEFUN T)

(DECLARE (FIXNUM (LOGLDB FIXNUM NOTYPE)))

(IF-FOR-MACLISP
 (DEFUN LOGAND MACRO (X)
	(CONS 'BOOLE (CONS 1 (CDR X))))

 (DEFUN LOGIOR MACRO (X)
	(CONS 'BOOLE (CONS 7 (CDR X))))

 (DEFUN LOGXOR MACRO (X)
	(CONS 'BOOLE (CONS 6 (CDR X)))))
		 
;SYMBOLS IN CONS-LAP:
; A SYMBOL IN CONS-LAP HAS AS ITS VALUE A PROGRAM!
;  THE PROGRAM IS EVALUATED BY RECURSIVE CALLS TO CONS-LAP-EVAL.
;  IF THE ARGUMENT TO CONS-LAP-EVAL IS NUMERIC, IT IS RETURNED AS THE VALUE.
;  IF NIL, THIS SPECIFIES THE NULL VALUE.
;  IF A SYMBOL, ITS VALUE IS RUN AS A PROGRAM AND RETURNED.
;  IF A LIST, CAR OF THE LISP IS THE FUNCTION AND THE REST OF THE LIST
;   ARGUMENTS, LISP STYLE.  UNLESS OTHERWISE NOTED BELOW, ALL FUNCTIONS
;   EVALUATE THEIR ARGS (LISP STYLE) AND ACTUALLY DO SOMETHING ONLY
;   AFTER THE EVALUATION OF THEIR ARGUMENTS HAS FINISHED.

;AVAILABLE FUNCITONS:
; FUNCTIONS OF ONE ARGUMENT
;  SPECIFERS OF LOCALITY: A-MEM, M-MEM, I-MEM, D-MEM.
;	RETURN VALUE INDICATING THAT THEIR ARGUMENT CORRESPONDS TO AN
;	ADDRESS IN THE SPECIFIED MEMORY.
;  CONDITIONALS:  DESTINATION-P, SOURCE-P, DISPATCH-INSTRUCTION-P, JUMP-INSTRUCTION-P 
;       ALU-INSTRUCTION-P, BYTE-INSTRUCTION-P. EVALUATE AND RETURN ARGUMENT
;       ONLY IF SPECIFIED CONDITION TRUE (NAMELY: ASSEMBLING A DESTINATION FIELD,
;	A SOURCE FIELD, OR THE TYPE OF INSTRUCTION INDICATED). RETURN NIL
;	IF CONDITION FALSE. 
;  NEGATION: NOT. MUST BE NESTED WITH ONE OF THE CONDITIONALS ABOVE AS IS
;	(NOT (DESTINATION (...))).
;  OR. RETURNS FIRST NON-NIL VALUE LIKE LISP OR.
;  PLUS. COMBINES THE VALUES / PROPERTIES REPRESENTED BY ALL ITS ARGUMENTS.
;       TWO ARGS ONLY.
;  DIFFERENCE.  LIKEWISE.
;  INSTRUCTION-TYPE FORCE: FORCE-DISPATCH, FORCE-JUMP, FORCE-ALU, FORCE-BYTE.
;       FORCE-DISPATCH-OR-BYTE, FORCE-ALU-OR-BYTE.
;  DEFAULT-CONDITION.  DEFAULT-BTYE. IF DISPATCH IS FORCED, RETURN NIL.
;	OTHERWISE FORCE BYTE.
;  BYTE-FIELD <BITS BITS-OVER>. DEFAULTS BYTE-INSTRUCTION.  ERROR IF OTHER THAN
;	BYTE INSTRUCTION OR DISPATCH INSTRUCTION (OR IF A ONE BIT FIELD,
;	JUMP INSTRUCTION).  ASSEMBLES THE RIGHT THING
;	TO REFERENCE BYTE, AS PER WHAT INSTRUCTION TYPE IS.
;  LISP-BYTE <%% FORM BYTE SPECIFIER>.  SIMILIAR TO BYTE-FIELD, BUT BYTE DESCRIPTION IS 
;	OBTAINED BY EVAL ING ARGUMENT AND INTERPRETING IT AS A BYTE SPECIFIER.
;       I.E. PPSS WHERE PP GIVES POSITION AND SS GIVES SIZE A LA PDP-10 
;	BYTE INSTRUCTION.
;  ALL-BUT-LISP-BYTE <%% FORM BYTE SPECIFIER>.  SIMILAR, BUT ADDRESSES BITS NOT IN
;	<BYTE>.  <BYTE> MUST BE EITHER LEFT OR RIGHT ADJUSTED IN 32. BITS.
;  BYTE-MASK <SYMBOLIC BYTE SPECIFIER>.  ARG CAN BE SYMBOL OR COMPOSITION OF
;	OPS AND SYMBOLS SPECIFYING A BYTE (IE CONTAINING SOMEWHERE IN THERE
;	A BYTE-FIELD OR LISP-BYTE OPERATION).  THIS IS DUG OUT BY BYTE-MASK
;	AND IS RETURNS THE VALUE OF ALL 1'S IN THE SPECIFIED BYTE.
;  BYTE-VALUE <SYMBOLIC BYTE SPECIFIER> <VALUE TO STORE IN BYTE>
;	RETURNS A VALUE OF THE SPECIFIED NUMBER IN THE SPECIFIED BYTE.
;	FOR CONVENIENCE, THE VALUE MAY BE EITHER A CONS-LAP SYMBOL OR A LISP SYMBOL.
;  FIELDS: (FIELD <FIELD NAME> <VALUE>).  NOTATION IS MADE THAT <FIELD NAME>
;	HAS BEEN SPECIFIED.  THE VALUE IS OBTAINED AS FOLLOWS:  THE PROGRAM
;	ASSOCIATED WITH <FIELD NAME> AS A SYMBOL IS RUN AND ITS VALUE MULTIPLIED
;	BY <VALUE> (THIS IS DONE RATHER THAN SHIFTING SO BIGNUMS WORK CONVIENTLY).
;	ADDITIONALLY, IF A CONS-LAP-ADDITIVE-CONSTANT
;	PROPERTY IS PRESENT ON <FIELD NAME> IT WILL BE ADDED IN AFTER MULTIPLING.
;	ANY PROPERTIES SPECIFIED IN THE	RUNNING OF <FIELD NAME> STICK.
;  I-ARG.  ASSEMBLES ITS ARGUMENT INTO THE IMMEDIATE ARGUMENT FIELD OF A DISPATCH
;	INSTRUCTION.
;  ((ARG-CALL ADR) .. ) OR ((ARG-JUMP ADR) .. ).  ASSEMBLES A DISPATCH INSTRUCTION
;       WHICH DISPATCHES ON ZERO BITS TO A D-MEM ENTRY WHICH DOES A CALL (OR JUMP)
;	TO ADR.  USE IF IT IS DESIRED TO SUPPLY AN I-ARG ON AN UNCONDITIONAL
;	CALL (OR JUMP).  ((ARG-CALL-XCT-NEXT ADR) .. ) AND ((ARG-JUMP-XCT-NEXT ADR) ..)
;	ARE ALSO AVAILABLE.
;  EVAL <ARG>.  CALLS LISP EVAL ON ARG AND RETURNS (NUMERIC HOPEFULLY) VALUE.
;  LOC <ARG> SETS LOCATION COUNTER TO <ARG>.
;  MODULO <ARG> SETS LOCATION COUNTER TO BE ON A MOD <ARG> BOUNDARY.

;  INSTRUCTIONS FOR ASSEMBLING VALUES FOR USE WITH OA REGISTER.  (RECALL? THAT
;	THE OA "REGISTER" IS THE HACK WHEREBY THE NEXT MICRO-INSTRUCTION GETS
;	IOR-ED WITH DATA PRODUCED BY THIS ONE).
;    OA-LOW-CONTEXT OA-HIGH-CONTEXT <I-MEM STORAGE-WORD>.  ASSEMBLES <I-MEM STORAGE
;	WORD> AND RETURN EITHER HI OR LOW PART AS NUMBER FOR USE WITH DESTINATIONS
;	OA-REG-HI OR OA-REG-LOW.
; SYMBOLS MAY BE EITHER ON THE SYMTAB OR ON THE PROPERTY LIST UNDER THE INDICATOR
;  CONS-LAP-SYM.

;THE TYPE OF INSTRUCTION THAT GETS ASSEMBLED IN A GIVEN STORAGE WORD IS DETERMINED
;AS FOLLOWS:
;  FIRST THERE IS A DEFAULT, ALU-INSTRUCTION.  IT IS OVERRIDDEN BY ANY OTHER SPECIFIER.
;	THIS IS THE ONLY SPECIFIER THAT
;	CAN BE "OUT-OF-HARMONY" WITH ANY OTHER PRESENT SPECIFIER WITHOUT CAUSING AN 
;	ERROR. 
;  IF A DESTINATION IS PRESENT, INSTRUCTION MUST BE ALU-INSTRUCTION OR BYTE-INSTRUCTION.
;  IF AN I-MEM CONTEXT SYMBOL IS PRESENT, INSTRUCTION MUST BE JUMP-INSTRUCTION.
;  IF A D-MEM CONTEXT SYMBOL IS PRESENT, INSTRUCTION MUST BE DISPATCH-INSTRUCTION.
;  IF BOTH A M-MEM AND A A-MEM SYMBOL ARE PRESENT, INSTRUCTION MUST BE ALU-INSTRUCTION
;	OF BYTE-INSTRUCTION.
;  INSTRUCTION CAN BE FORCED BY A FORCE-INSTRUCTION PROPERTY ON ANY SYMBOL IN THE
;	WORD.
;  TWO A-MEM OR TWO M-MEM SYMBOLS IN ONE INSTRUCTION IS AN ERROR.

;ONCE INSTRUCTION TYPE IS DETERMINED, A CHECK IS MADE TO SEE THAT ALL NECESSARY
; FIELDS IN IT HAVE BEEN SPECIFIED, AND DEFAULTS SUPPLIED FOR VARIOUS OPTIONAL
; FIELDS AND MODES IF THEY WERE NOT SPECIFIED.

;RANDOM CONVENTIONS --
; LOCATION TAGS ARE DEFINED AS FIELDS. IE (FIELD JUMP-ADDRESS-MULTIPLIER NNN)
; FOR SYMBOLS IN I-MEM. (A-SOURCE-MULTIPLIER, M-SOURCE-MULTIPLIER, AND 
; DISPATCH-ADDRESS-MULTIPLIER ARE THE CORRESPONDING FIELDS FOR A-MEM, M-MEM,
; AND D-MEM RESPECTIVELY).  THUS, WHEN NORMALLY EVALUATED, THEY HAVE
; THEIR VALUES IN THESE "PLACES".  THIS IS THE RIGHT THING EXCEPT FOR THESE
; CASES: 1)  DESTINATIONS.  CONVERT-VALUE-TO-DESTINATION COMPUTES AN APPROPRIATE
;		"SHIFT"
;	 2)  LOCALITY D-MEM.  CONS-LAP-PASS2 DOES THE RIGHT THING.  THIS INVOLVES
;		SHIFTING THE I-MEM ADR BACK TO THE LOW PART AND MOVING THE RPN
;		BITS UP (FROM THEIR NORMAL POSITION IN A JUMP INSTRUCTION).
; OTHER FEATURES/CROCKS
;   WHEN A BYTE-FIELD OPERATION IS ENCOUNTERED BY CONS-LAP-EVAL,
;	THE INSTRUCTION CONTEXT IS FORCED TO BYTE IF IT HAS NOT ALREADY
;	BEEN COMPLETELY SPECIFIED.  THEN THE BYTE REFERENCE IS ASSEMBLED
;	IN THE MANNER APPROPRIATE TO THE INSTRUCTION CONTEXT.
;   THE SR-BIT IS STORED INVERTED (SO THAT IT WILL OFF FOR NORMAL LDB).
;	CONS-LAP-DEFAULT-AND-BUGGER REVERSES SR-BIT IF IT'S A BYTE INSTRUCTION
;   UNFORTUNATELY, ON THE PROTOTYPE CONS MACHINE, THE HARDWARE IMPLEMENTS
;       A LEFT ROTATE FOR THE M-ROTATE FIELD (IN DISPATCH, BYTE AND TEST-BIT
;	JUMP INSTRUCTIONS).  IT WAS DETERMINED TO BE A LOSS TO SPECIFY BYTE
;       FIELDS IN THIS MANNER, BECAUSE 1) IT IS NOT COMPATABLE WITH LDB
;	ON THE PDP-10 2) SPECIFING THEM THIS WAY MAKES THE SPECIFICATION DEPENDANT
;	ON THE MACHINE WORD BIT LENGTH, WHICH IS UNDESIRABLE.  FUTURE MACHINES
;	WILL ROTATE THE OTHER WAY [I DOUBT IT - MOON], BUT FOR NOW,
;	CONS-LAP-DEFAULT-AND-BUGGER
;	WILL REPLACE THE M-ROTATE FIELD OF APPROPRIATE INSTRUCTIONS WITH
;	ITS 32. INVERSE (IE ( 32. - M-ROTATE) MOD 32.)
;	CODE USING THE OA-REGISTER FEATURE TO MODIFY BYTE TYPE INSTRUCTIONS
;	MUST BE AWARE OF THIS, AND WILL EVENTUALLY HAVE TO BE CHANGED.
;  TO PUT THE ADDRESS OF A MICRO CODE LOCATION INTO A CONSTANT IN A OR M
;	MEMORY, USE THE KLUDGEY CONSTRUCTION (I-MEM-LOC <TAG>).
;  SIMILARLY, A-MEM-LOC, M-MEM-LOC, D-MEM-LOC PSEUDO-OPS EXIST.

;   OPERATION OF THE ARG-CALL, ETC, FEATURE IN DISPATCH INSTRUCTIONS.
;	SOMETIMES IT IS DESIRABLE TO USE A DISPATCH INSTRUCTION WHEN
;	REALLY ONLY AN UNCONDITIONAL TRANSFER (CALL, ETC) IS DESIRED
;	IN ORDER TO BE ABLE TO LOAD THE DISPATCH-CONSTANT REGISTER IN THE
;	SAME INSTRUCTION.  IT WOULD BE A PAIN TO HAVE TO DEFINE A ONE REGISTER
;	DISPATCH TABLE, ETC IN THIS CASE.  SO THE ASSEMBLER PROVIDES A FEATURE
;	WHEREBY ARG-CALL, ARG-JUMP, ARG-CALL-XCT-NEXT, AND ARG-JUMP-XCT-NEXT
;	ARE SPECIALLY RECOGNIZED.  USING THESE PSEUDO-OPS, THE INSTRUCTION
;	MAY BE WRITTEN AS "NORMAL" AND THE ASSEMBLER WILL TAKE CARE OF
;	ALLOCATING A D-MEM LOCATION AND MOVING THE RPN BITS AND I-MEM JUMP ADDRESS
;	BITS THERE.  THIS D-MEM LOCATION IS AUTOMATICALLY PLUGGED INTO THE
;	DISPATCH OFFSET.
;   ON A NORMAL PDP-10 STYLE LOAD BYTE, THE A-MEM ADDRESS MUST CONTAIN 0
;	FOR CORRECT OPERATION.  ALTHO A-MEM LOCATION 0 COULD BE USED FOR THIS,
;	IT IS CLOBBERED WHEN M-MEM LOCATION 0 IS WRITTEN INTO, WHICH IS THE
;	DEFAULT GARBAGE LOCATION USED BY THE CONSOLE PROGRAM.  THEREFORE A-MEM
;	LOCATION 2 IS CHOSEN TO CONTAIN ZERO, AND LOCATION 3 TO CONTAIN -1,
;	MAKING A CONVENIENT PAIR FOR DOING SIGN-EXTENSION.  THE A-MEM ADDRESS
;	OF A LOAD-BYTE INSTRUCTION WILL BE DEFAULTED TO 2 IF NOT SPECIFIED.

;ENTRY POINTS INTO MICRO-CODE FROM MACRO-CODE, ETC:
;   THE MICRO-CODE-SYMBOL AREA CONTAINS ALL (INITIAL) ENTRY POINTS INTO
;  MICRO-CODE.  THE FIRST 600 Q'S OF MICRO-CODE-SYMBOL AREA GIVE THE CONTROL-MEMORY
;  TRANSFER ADDRESSES FOR MACRO-CODE MISC-INSTRUCTIONS 200-777.  FOLLOWING THAT
;  ARE OTHER ENTRY POINTS, MOSTLY FOR MICRO-COMPILED RUNTIME ROUTINES, ETC.
;  THESE LAST ARE NOT REFERENCED DYNAMICALLY, BUT JUST BY LOADERS, ETC.
;   THE MICRO-CODE-SYMBOL AREA IS COMPLETELY DETERMINED BY CONSLP UNDER CONTROL
;  OF THE (MISC-INST-ENTRY <NAME>) AND (MICRO-CODE-ENTRY <NAME>) PSEUDO-OPERATIONS.
;     (MISC-INST-ENTRY <NAME>) DECLARES THAT THE CURRENT LOCATION IS THE ENTRY POINT 
;	WHEN <NAME> IS EXECUTED AS A MACRO-INSTRUCTION. CONSLP LOOKS ON THE PROPERTY
;	LIST OF <NAME> TO FIND THE QLVAL PROPERTY (WHICH HAD BETTER BE THERE OR ERROR).
;	THESE QLVAL NORMALLY APPEAR VIA READING IN THE LISPM;QL > WHICH OCCURS DURING
;	CONSLP INITIALIZATION.  CONSLP THEN ARRANGES FOR . TO APPEAR IN THE APPROPRIATE
;	LOCATION OF MICRO-CODE-SYMBOL AREA.
;     (MICRO-CODE-ENTRY <NAME>) IS SIMILAR EXCEPT THE LOCATION IN MICRO-CODE-SYMBOL AREA
;	IS FOUND BY ADDING 600 TO THE POSITION <NAME> IS IN THE MICRO-CODE-SYMBOL-VECTOR
;	LIST.
; IN ADDITION, (MICRO-CODE-ILLEGAL-ENTRY-HERE), ENCOUNTERED AT ANY TIME, FILLS
;	ALL UNUSED ENTRIES OF MICRO-CODE-SYMBOL AREA WITH THE CURRENT LOCATION.
;	(IT IS OK IF SOME OF THEM LATER GET STORED OVER WITH OTHER STUFF...)

;THE ERROR TABLE:
; THE PSEUDO-OP (ERROR-TABLE FOO BAR BAZ...)
; WILL ADD THE LINE (LOC FOO BAR BAZ...) TO THE ERROR TABLE, WHERE LOC IS
; THE ADDRESS OF THE PRECEEDING I-MEM INSTRUCTION.  THE ERROR TABLE IS
; AN OUTPUT FILE, UCONS TABLE, WHICH CAN BE READ IN TO LISP.  IT CONTAINS
; A SETQ OF MICROCODE-ERROR-TABLE TO A LIST OF ERROR TABLE ENTRIES,
; AND A SETQ OF MICROCODE-ERROR-TABLE-VERSION TO THE SOURCE FILE VERSION
; NUMBER, WHICH CAN BE COMPARED AGAINST %MICROCODE-VERSION-NUMBER.

(DECLARE (SPECIAL DESTINATION-CONTEXT LOCALITY I-MEM-LOC D-MEM-LOC
	   A-MEM-CREVICE-LIST A-CONSTANT-LOC M-CONSTANT-LOC
	   ERROR-TABLE-FILE CONSLP-INPUT CONSLP-OUTPUT VERSION-NUMBER ;SETQED IN UCONS >
           A-MEM-LOC M-MEM-LOC D-MEM-FREE-BLOCKS FIELD-INDICATORS COMBINED-VALUE 
	   COMBINED-INDICATORS INSTRUCTION-CONTEXT IN-DISPATCH-BLOCK 
	   DISPATCH-BLOCK-LIMIT DISPATCH-ARM DISPATCH-CONSTANT M-CONSTANT-LIST 
	   A-CONSTANT-LIST A-CONSTANT-BASE M-CONSTANT-BASE CONS-LAP-LAST-SYM 
	   CONS-LAP-WDS-SINCE-LAST-SYM CONS-LAP-SAVED-SYMTAB SR-BIT 
	   ARG-CALL-LIST CURRENT-WORD MICRO-CODE-SYMBOL-VECTOR 
	   RM-AREA-SIZES PAGE-SIZE CONS-LAP-PASS2)
	 (*EXPR CONS-LAP-PASS2))

;THE ARG CALL LIST IS AN ASSOCIATION LIST WHERE THE KEY IS THE I-MEM LOCATION
;AT WHICH AN ((ARG-CALL) ..) TYPE INSTRUCTION HAS APPEARED, AND THE VALUE
;IS THE D-MEM LOCATION THAT HAS BEEN ALLOCATED TO IT.


(DEFUN BIGNUM-LOGAND-LOW (X BIG)	;BIG MAY BE A BIGNUM
  (LOGAND X (LOGLDB 0043 BIG)))

;ARRAYS WHICH RECEIVE THE OUTPUT OF THE ASSEMBLY
(DECLARE (ARRAY* (NOTYPE (I-MEM 10000) (A-MEM 400) (M-MEM 40) (D-MEM 2000))
		 (NOTYPE (MICRO-CODE-SYMBOL-IMAGE NIL)) ))

;UTILITY FUNCTIONS USED, DECLARED TO AVOID COMPILER MESSAGE
(DECLARE (*EXPR FIND-POSITION-IN-LIST-EQUAL LOGDPB LOGLDB LOGAND
		ALLREMPROP))

(DEFUN CONS-LAP-BARF (A B C)
  (TERPRI)
  (PRIN1 (LIST CONS-LAP-LAST-SYM CONS-LAP-WDS-SINCE-LAST-SYM))
  (PRIN1 (LIST A B C))
  (COND ((NOT (EQ C 'WARN))(BREAK 'FOO T))))

(DEFUN CONS-LAP-INITIALIZE NIL 
  (PROG NIL 
	(SETQ I-MEM-LOC 0)
	(SETQ D-MEM-LOC 0)
	(SETQ A-MEM-LOC 0)
	(SETQ M-MEM-LOC 0)
	(SETQ A-MEM-CREVICE-LIST NIL)
	(SETQ D-MEM-FREE-BLOCKS (LIST NIL (CONS 2000 0)))
					;A BLOCK OF 2000 STARTING AT 0
	(ALLREMPROP 'CONS-LAP-USER-SYMBOL)
	(SETQ M-CONSTANT-LIST NIL)
	(SETQ A-CONSTANT-LIST NIL)
	(*ARRAY 'I-MEM T 10000)
	(*ARRAY 'A-MEM T 400)
	(*ARRAY 'M-MEM T 40)
	(*ARRAY 'D-MEM T 2000)
	(*ARRAY 'MICRO-CODE-SYMBOL-IMAGE T (* PAGE-SIZE 
					     (LIST-ASSQ 'MICRO-CODE-SYMBOL-AREA 
							 RM-AREA-SIZES)))
	(ALLREMPROP 'CONS-LAP-B-PTR)
))

(DEFUN CONS-LAP-PASS2-INITIALIZE NIL 
  (PROG NIL 
	(SETQ I-MEM-LOC 0)
	(SETQ D-MEM-LOC 0)
	(SETQ A-MEM-LOC 0)
	(SETQ M-MEM-LOC 0)
))

(DEFUN CONS-LAP (U-PROG)
  (PROG (I-MEM-LOC D-MEM-LOC A-MEM-LOC M-MEM-LOC LOCALITY 
         IN-DISPATCH-BLOCK CONS-LAP-LAST-SYM CONS-LAP-WDS-SINCE-LAST-SYM 
	 DISPATCH-BLOCK-LIMIT T1 DISPATCH-ARM CONS-LAP-PASS2
         DISPATCH-CONSTANT ARG-CALL-LIST M-CONSTANT-LOC A-CONSTANT-LOC
	 M-CONSTANT-LIST A-CONSTANT-LIST M-CONSTANT-BASE A-CONSTANT-BASE)
	(SETQ A-CONSTANT-BASE NIL)		;SEE CONS-LAP-LOC-MODULO
	(SETQ CONS-LAP-WDS-SINCE-LAST-SYM 0)
	(SETQ ERROR-TABLE-FILE NIL)
	(CONS-LAP-INITIALIZE)
 	(SETQ T1 U-PROG)
L1	(COND ((NULL T1) (GO L2)))
	(CONS-LAP-PASS1 (CAR T1))
	(SETQ T1 (CDR T1))
	(GO L1)
L2	(SETQ M-CONSTANT-LOC (SETQ M-CONSTANT-BASE M-MEM-LOC))
	(SETQ A-CONSTANT-LOC (SETQ A-CONSTANT-BASE A-MEM-LOC))
	(SETQ CONS-LAP-LAST-SYM NIL)
	(SETQ CONS-LAP-WDS-SINCE-LAST-SYM 0)
	(SETQ CONS-LAP-PASS2 T)
	(CONS-LAP-PASS2-INITIALIZE)
	(SETQ T1 U-PROG)
L3	(COND ((NULL T1) (GO L4)))
	(CONS-LAP-PASS2 (CAR T1))
	(SETQ T1 (CDR T1))
	(GO L3)
L4	(COND ((NOT (= M-MEM-LOC M-CONSTANT-BASE))
		(CONS-LAP-BARF (LIST M-MEM-LOC M-CONSTANT-BASE) 'CLD-M-MEM 'BARF)))
	(COND ((NOT (= A-MEM-LOC A-CONSTANT-BASE))
		(CONS-LAP-BARF (LIST A-MEM-LOC A-CONSTANT-BASE) 'CLD-A-MEM 'BARF)))
	(SETQ LOCALITY 'M-MEM)
	(CONS-LAP-STORE-CONSTANT-LIST (GET 'M-MEM 'ARRAY) M-CONSTANT-LIST)
	(SETQ LOCALITY 'A-MEM)
	(CONS-LAP-STORE-CONSTANT-LIST (GET 'A-MEM 'ARRAY) A-CONSTANT-LIST)
	(COND ((NOT (NULL ERROR-TABLE-FILE))
	       ;|((|
	       (PRINC '|))| ERROR-TABLE-FILE)
	       (TERPRI ERROR-TABLE-FILE)
	       (CLOSE ERROR-TABLE-FILE)))
	(UWRITE DSK LISPM1)		;MAKE UCONS LOCS FILE
	(SETQ ^R T ^W NIL)
	(PRINT 'LOCATIONS-USED)
	(PRINT (LIST 'A-MEM (MAX A-MEM-LOC A-CONSTANT-LOC)))
	(PRINT (LIST 'M-MEM (MAX M-MEM-LOC M-CONSTANT-LOC)))
	(PRINT (LIST 'I-MEM I-MEM-LOC))
	(PRINT (LIST 'D-MEM (- 2000 (GET-D-MEM-FREE-LOCS (CDR D-MEM-FREE-BLOCKS)))))
	(TERPRI)
	(SETQ ^R NIL)
	(APPLY 'UFILE (LIST CONSLP-OUTPUT 'LOCS))
	(BREAK 'FINISHED 'T)			;USER MUST STILL DO CONS-DUMP-MEMORIES
	(RETURN T)))

(DEFUN GET-D-MEM-FREE-LOCS (X)
  (COND ((NULL X) 0)
        (T (+ (CAAR X) (GET-D-MEM-FREE-LOCS (CDR X))))))

(DEFUN CONS-LAP-STORE-CONSTANT-LIST (MEM L)
  (PROG NIL 
 L	(COND ((NULL L) (RETURN NIL)))
	(STORE (ARRAYCALL NIL MEM (CADAR L)) (CAAR L))
	(SETQ L (CDR L))
	(GO L)))

;CONSTANT LISTS.
;A LIST OF LISTS.  CAR IS VALUE OF CONSTANT, CADR IS ADDRESS, CADDR IS #USERS, CADDDR IS 
;	LAST PC TO USE IT.

		;ARG IS A-CONSTANT-LIST OR M-CONSTANT-LIST
(DEFUN CONS-LAP-REPORT-CONSTANTS-USAGE (L)
  (SETQ L (SORT (APPEND L NIL) (FUNCTION (LAMBDA (X Y) (< (CADDR X) (CADDR Y))))))
  (TERPRI)
  (PRINC '|#USES	VALUE	USEPC|)
  (DO L L (CDR L) (NULL L)
    (PRINT (CADDR (CAR L)))
    (TYO 11)
    (PRIN1 (CAAR L))
    (TYO 11)
    (PRIN1 (CADDDR (CAR L))))
  (TERPRI))

(DEFUN CONS-LAP-PASS1 (WD) 
  (PROG (CURRENT-WORD)
	(SETQ CURRENT-WORD WD)			;FOR DEBUGGING
	(COND ((ATOM WD) (SETQ CONS-LAP-LAST-SYM WD)
			 (SETQ CONS-LAP-WDS-SINCE-LAST-SYM 0)
			 (CONS-LAP-DEFSYM 
			    WD 
			    (LIST LOCALITY 
			      (CONS 'FIELD 
				(COND ((EQ LOCALITY 'I-MEM)
					(LIST 'JUMP-ADDRESS-MULTIPLIER I-MEM-LOC))
				      ((EQ LOCALITY 'A-MEM) 
					(LIST 'A-SOURCE-MULTIPLIER A-MEM-LOC))
				      ((EQ LOCALITY 'M-MEM) 
					(LIST 'M-SOURCE-MULTIPLIER M-MEM-LOC))
				      ((EQ LOCALITY 'D-MEM) 
					(LIST 'DISPATCH-ADDRESS-MULTIPLIER D-MEM-LOC))
				      (T (CONS-LAP-BARF LOCALITY 
							'BAD-LOCALITY 
							'BARF))) )) ))
	      ((EQ (CAR WD) 'DEF-DATA-FIELD)
		(DEF-DATA-FIELD (CADR WD) 
				(CONS-LAP-ARG-EVAL (CADDR WD))
				(CONS-LAP-ARG-EVAL (CADDDR WD))))
	      ((EQ (CAR WD) 'DEF-BIT-FIELD-IN-REG)
		(DEF-BIT-FIELD-IN-REG (CADR WD)
				      (CONS-LAP-ARG-EVAL (CADDR WD))
				      (CONS-LAP-ARG-EVAL (CADDDR WD))
				      (CAR (CDDDDR WD))))
	      ((EQ (CAR WD) 'ASSIGN)
		(CONS-LAP-DEFSYM (CADR WD)
				 (CADDR WD)))
	      ((EQ (CAR WD) 'ASSIGN-EVAL)
		(CONS-LAP-DEFSYM (CADR WD)
				 (CONS-LAP-ARG-EVAL (CADDR WD))))
	      ((EQ (CAR WD) 'DEF-NEXT-BIT)
		(DEF-NEXT-FIELD (CADR WD) 1 (CADDR WD)))
	      ((EQ (CAR WD) 'RESET-BIT-POINTER)
		(RESET-BIT-POINTER (CADR WD)))
	      ((EQ (CAR WD) 'DEF-NEXT-FIELD)
		(DEF-NEXT-FIELD (CADR WD) 
				(CONS-LAP-ARG-EVAL (CADDR WD))
				(CADDDR WD)))
	      ((EQ (CAR WD) 'LOCALITY)
		(SETQ LOCALITY (CADR WD))
		(COND ((NOT (MEMQ LOCALITY '(M-MEM A-MEM D-MEM I-MEM)))
			(CONS-LAP-BARF LOCALITY 'BAD-LOCALITY 'BARF))))
	      ((EQ (CAR WD) 'START-DISPATCH)
		(COND ((NOT (EQ LOCALITY 'D-MEM))
			(CONS-LAP-BARF LOCALITY 'BAD-START-DISPATCH 'BARF)))
		(COND (IN-DISPATCH-BLOCK 
			(CONS-LAP-BARF WD 'ALREADY-IN-DISPATCH 'DATA)))
		(SETQ D-MEM-LOC (FIND-D-MEM-SPACE (EXPT 2 (CADR WD))))
		(SETQ IN-DISPATCH-BLOCK T))
	      ((EQ (CAR WD) 'END-DISPATCH)
		(COND ((NULL IN-DISPATCH-BLOCK)
			(CONS-LAP-BARF WD 'NOT-IN-DISPATCH-BLOCK 'DATA)))
		(COND ((> D-MEM-LOC DISPATCH-BLOCK-LIMIT)
			(CONS-LAP-BARF D-MEM-LOC  
				       'DISPATCH-BLOCK-OVERFLOW 
				       'DATA))
		      ((NOT (= D-MEM-LOC DISPATCH-BLOCK-LIMIT))
			(CONS-LAP-BARF (LIST D-MEM-LOC DISPATCH-BLOCK-LIMIT)
			      'DISPATCH-BLOCK-UNDERFLOW 
			      'WARN)))
		(SETQ IN-DISPATCH-BLOCK NIL))
	      ((MEMQ (CAR WD) '(LOC MODULO))
		(CONS-LAP-LOC-MODULO WD))
	      ((EQ (CAR WD) 'REPEAT)
		(CONS-LAP-REPEAT-1 (CONS-LAP-ARG-EVAL (CADR WD))
				   (CADDR WD)))
	      ((MEMQ (CAR WD) '(MISC-INST-ENTRY MICRO-CODE-ENTRY 
				 MICRO-CODE-ILLEGAL-ENTRY-HERE ERROR-TABLE))
		(GO X))
	      ((EQ (CAR WD) 'COMMENT))
	      (T (CONS-LAP-PASS1-WD WD)
		 (GO W1)))
X	(RETURN NIL)
W1	(SETQ CONS-LAP-WDS-SINCE-LAST-SYM (1+ CONS-LAP-WDS-SINCE-LAST-SYM))
	(COND ((EQ LOCALITY 'A-MEM)
		(SETQ A-MEM-LOC (1+ A-MEM-LOC)))
	      ((EQ LOCALITY 'M-MEM)
		(SETQ M-MEM-LOC (1+ M-MEM-LOC)))
	      ((EQ LOCALITY 'D-MEM)
		(COND ((NOT IN-DISPATCH-BLOCK)
			(CONS-LAP-BARF WD 'STORAGE-WD-NOT-IN-DISPATCH-BLOCK 'DATA)))
		(SETQ D-MEM-LOC (1+ D-MEM-LOC)))
	      ((EQ LOCALITY 'I-MEM)
		(SETQ I-MEM-LOC (1+ I-MEM-LOC)))
	      (T (CONS-LAP-BARF WD 'STORAGE-WD-IN-BAD-LOCALITY 'DATA)))
	(RETURN NIL)))

(DEFUN CONS-LAP-LOC-MODULO (WD)
   ((LAMBDA (POINT ITEM)
	(AND (EQ (CAR WD) 'MODULO)
	     (SETQ ITEM (* ITEM (// (+ (SYMEVAL POINT) ITEM -1) ITEM))))
	(AND (< ITEM (SYMEVAL POINT))
	     (CONS-LAP-BARF WD 'BACKWARDS 'DATA))
	(AND (EQ LOCALITY 'D-MEM)
	     (CONS-LAP-D-MEM-LOC ITEM))
	(AND (NULL A-CONSTANT-BASE)	;ON PASS 1
	     (EQ LOCALITY 'A-MEM)	;KLUDGE TO USE SKIPPED AREA FOR CONSTANTS
	     (DO I A-MEM-LOC (1+ I) (= I ITEM)
		(OR (< I 40)
		    (SETQ A-MEM-CREVICE-LIST (CONS I A-MEM-CREVICE-LIST)))))
	(SET POINT ITEM))
     (CDR (ASSQ LOCALITY '((A-MEM . A-MEM-LOC)
			   (M-MEM . M-MEM-LOC)
			   (D-MEM . D-MEM-LOC)
			   (I-MEM . I-MEM-LOC))))
     (CADR WD)))

;ALLOCATE ONE D-MEM WORD AT A SPECIFIC ADDRESS
(DEFUN CONS-LAP-D-MEM-LOC (L)
  (OR CONS-LAP-PASS2
      (DO ((BL D-MEM-FREE-BLOCKS (CDR BL))
	   (TEM))
	  ((NULL (CDR BL)) (BREAK CONS-LAP-D-MEM-LOC T))
	(SETQ TEM (CADR BL))				;A BLOCK
	(COND ((AND (NOT (< L (CDR TEM)))		;IF LOC IS IN THIS BLOCK
		    (< L (+ (CDR TEM) (CAR TEM))))
	       (RPLACD BL (CDDR BL))			;PATCH OUT THIS BLOCK
	       (CONS-LAP-D-MEM-LOC-SPLITUP BL (CDR TEM) L)	;INSTALL BLOCKS BEFORE LOC
	       (CONS-LAP-D-MEM-LOC-SPLITUP BL (1+ L)	;INSTALL BLOCKS AFTER LOC
					   (+ (CAR TEM) (CDR TEM)))
	       (RETURN NIL)))))
  (SETQ D-MEM-LOC L
	IN-DISPATCH-BLOCK T
	DISPATCH-BLOCK-LIMIT (1+ L)))

;SPLIT UP INTO POWER OF 2 BLOCKS
;******* KNOWS THAT D MEM IS 2000 LOCATIONS *******
(DEFUN CONS-LAP-D-MEM-LOC-SPLITUP (BL LOW HIGH)
  (DECLARE (FIXNUM LOW HIGH))
  (PROG (BLOCKSIZE)
    (DECLARE (FIXNUM BLOCKSIZE))
RCR (COND ((= LOW HIGH) (RETURN NIL)))
		 ;COMPUTE LARGEST POWER OF 2 BLOCK STARTING AT LOW
    (SETQ BLOCKSIZE (BOOLE 1 (+ 2000 LOW) (- 2000 LOW)))
A   (COND ((> (+ LOW BLOCKSIZE) HIGH)
	   (SETQ BLOCKSIZE (// BLOCKSIZE 2))
	   (GO A)))
    (RPLACD BL (CONS (CONS BLOCKSIZE LOW) (CDR BL)))	;PUT IN THIS BLOCK
    (SETQ BL (CDR BL)	;DO THE REMAINDER
	  LOW (+ LOW BLOCKSIZE))
    (GO RCR)))

(DEFUN CONS-LAP-REPEAT-1 (COUNT ITEM)
 (PROG NIL 
	(COND ((ATOM ITEM) (SETQ ITEM (LIST ITEM))))
L	(COND ((ZEROP COUNT) (RETURN NIL)))
	(CONS-LAP-PASS1 ITEM)
	(SETQ COUNT (1- COUNT))
	(GO L)))

(DEFUN CONS-LAP-PASS1-WD (WD)
  (PROG () 
 L 	(COND ((ATOM WD) (RETURN NIL))
	      ((ATOM (CAR WD)))			;FLUSH
	      ((MEMQ (CAAR WD)
		     '(ARG-CALL ARG-JUMP ARG-CALL-XCT-NEXT ARG-JUMP-XCT-NEXT))
		(SETQ ARG-CALL-LIST 
			(CONS (CONS I-MEM-LOC (FIND-D-MEM-SPACE 1))
			      ARG-CALL-LIST)))
	      ((MEMQ (CAAR WD) '(OA-LOW-CONTEXT OA-HI-CONTEXT))
		(CONS-LAP-PASS1-WD (CDAR WD))))
	(SETQ WD (CDR WD))
	(GO L)))

(DEFUN FIND-D-MEM-SPACE (L)
  (PROG (B P S)
  L0	(SETQ S 10000)	;SIZE OF BEST BLOCK TO SPLIT SO FAR
	(SETQ P D-MEM-FREE-BLOCKS)
  L	(COND ((NULL (CDR P)) (GO S))
	      ((= L (CAADR P))
		(GO X))
	      ((AND (> (CAADR P) L)
		    (< (CAADR P) S))
		(SETQ B P)
		(SETQ S (CAADR P))))
	(SETQ P (CDR P))
	(GO L)
  X	(SETQ B (CADR P))
	(RPLACD P (CDDR P))
	(SETQ DISPATCH-BLOCK-LIMIT (+ (CAR B) (CDR B)))
	(RETURN (CDR B))
  S	(COND ((NULL B)
		(CONS-LAP-BARF L 'OUT-OF-D-MEM 'BARF)))
	(RPLACA (CADR B) (LSH S -1))
	(RPLACD D-MEM-FREE-BLOCKS 
		(CONS (CONS (LSH S -1)
			    (+ (LSH S -1) (CDADR B)))
		      (CDR D-MEM-FREE-BLOCKS)))
	(SETQ B NIL)
	(GO L0) ))

(DEFUN CONS-LAP-DEFSYM (SYM VAL)
  (PROG (TM) 
	(COND ((SETQ TM (CONS-LAP-SYMEVAL SYM))
		(COND ((NOT (EQUAL VAL TM))
			(CONS-LAP-BARF (LIST VAL TM) 'MULT-DEF-SYM 'DATA))))
	      (T (PUTPROP SYM VAL 'CONS-LAP-USER-SYMBOL)))
	(RETURN NIL)))

(DEFUN CONS-LAP-SYMEVAL (SYM)
  (OR (GET SYM 'CONS-LAP-SYM) (GET SYM 'CONS-LAP-USER-SYMBOL)))

(DEFUN DEF-DATA-FIELD (SYM BITS BITS-OVER)
  (PROG ()
	(CONS-LAP-DEFSYM SYM 
	  (LIST 'M-MEM (LIST 'BYTE-FIELD BITS BITS-OVER))) 
	(RETURN NIL)))

(DEFUN DEF-BIT-FIELD-IN-REG (SYM BITS BITS-OVER REG)
  (PROG ()
	(CONS-LAP-DEFSYM SYM 
	  (LIST 'PLUS 
		(LIST 'BYTE-FIELD BITS BITS-OVER)
		REG))
	(RETURN NIL)))


(DEFUN RESET-BIT-POINTER (SYM)
  (PROG () 
	(PUTPROP SYM 0 'CONS-LAP-B-PTR)))

(DEFUN DEF-NEXT-FIELD (SYM BITS IN-SYM)
  (PROG (B-PTR IN-SYM-V N-B-PTR)
	(COND ((NOT (ATOM IN-SYM))
		(CONS-LAP-BARF IN-SYM 'BAD-NEXT-FIELD 'DATA)
		(RETURN NIL)))
	(SETQ B-PTR (COND ((GET IN-SYM 'CONS-LAP-B-PTR))
			  (T '0)))
	(COND ((NULL (SETQ IN-SYM-V (CONS-LAP-SYMEVAL IN-SYM)))
		(CONS-LAP-BARF IN-SYM 'UNDEF-IN-DEF-NEXT-FIELD 'DATA)
		(RETURN NIL)))
	(COND ((> (SETQ N-B-PTR (+ BITS B-PTR)) 32.)
		(CONS-LAP-BARF IN-SYM 'OUT-OF-BITS 'DATA)
		(RETURN NIL)))
	(CONS-LAP-DEFSYM SYM (LIST 'PLUS (LIST 'BYTE-FIELD BITS B-PTR)
				   IN-SYM-V))
	(PUTPROP IN-SYM N-B-PTR 'CONS-LAP-B-PTR)
))
;##
(DEFUN CONS-LAP-PASS2 (WD)
  (PROG (V)
	(COND ((ATOM WD)
		(SETQ CONS-LAP-LAST-SYM WD)
		(SETQ CONS-LAP-WDS-SINCE-LAST-SYM 0)
		(COND ((AND DISPATCH-ARM 
			    (EQ LOCALITY 'D-MEM))
			(SETQ D-MEM-LOC (LOGLDB 1612 (CONS-LAP-ARG-EVAL WD)))
			(SETQ DISPATCH-ARM NIL))
		      ((NOT (EQUAL 
			     (CONS-LAP-SYMEVAL WD)
			      (LIST LOCALITY 
			       (CONS 'FIELD 
				(COND ((EQ LOCALITY 'I-MEM)
					(LIST 'JUMP-ADDRESS-MULTIPLIER I-MEM-LOC))
				      ((EQ LOCALITY 'A-MEM) 
					(LIST 'A-SOURCE-MULTIPLIER A-MEM-LOC))
				      ((EQ LOCALITY 'M-MEM) 
					(LIST 'M-SOURCE-MULTIPLIER M-MEM-LOC))
				      ((EQ LOCALITY 'D-MEM) 
					(LIST 'DISPATCH-ADDRESS-MULTIPLIER D-MEM-LOC))
				      (T (CONS-LAP-BARF LOCALITY 
							'BAD-LOCALITY 
							'BARF))) )) ))
			(CONS-LAP-BARF WD 'DEF-DFRS-ON-PASS2 'BARF))))
	     ((MEMQ (CAR WD) '(DEF-DATA-FIELD ASSIGN ASSIGN-EVAL DEF-NEXT-BIT 
			       RESET-BIT-POINTER 
			       DEF-NEXT-FIELD END-DISPATCH 
			       DEF-BIT-FIELD-IN-REG)))
	     ((EQ (CAR WD) 'LOCALITY)
		(SETQ LOCALITY (CADR WD)))
	     ((EQ (CAR WD) 'START-DISPATCH)
		(SETQ DISPATCH-CONSTANT (CONS-LAP-ARG-EVAL (CADDR WD)))
		(SETQ DISPATCH-ARM T))	;SET D-MEM-LOC TO NEXT D-MEM SYMBOL ENCOUNTERED
					;ERROR IF STORAGE WORD BEFORE THAT.
	     ((MEMQ (CAR WD) '(LOC MODULO))
		(CONS-LAP-LOC-MODULO WD))
	     ((EQ (CAR WD) 'REPEAT)
		(CONS-LAP-REPEAT-2 (CONS-LAP-ARG-EVAL (CADR WD))
				   (CADDR WD)))
	     ((EQ (CAR WD) 'MISC-INST-ENTRY)
		(CONS-LAP-STORE-UCODE-ENTRY (CADR WD) (GET (CADR WD) 'QLVAL) -200))
	     ((EQ (CAR WD) 'MICRO-CODE-ENTRY)
		(CONS-LAP-STORE-UCODE-ENTRY (CADR WD) 
			(FIND-POSITION-IN-LIST (CADR WD)
					       MICRO-CODE-SYMBOL-VECTOR)
			600))
	     ((EQ (CAR WD) 'MICRO-CODE-ILLEGAL-ENTRY-HERE)
		(CONS-LAP-WIPE-SYMBOL-VECTOR I-MEM-LOC))
	     ((EQ (CAR WD) 'ERROR-TABLE)
	      (COND ((NULL ERROR-TABLE-FILE)
		     (SETQ ERROR-TABLE-FILE (OPEN (LIST '(DSK LISPM1) CONSLP-OUTPUT 'TABLE)
						  '(OUT BLOCK)))
		     (PRINT (LIST 'SETQ 'MICROCODE-ERROR-TABLE-VERSION-NUMBER VERSION-NUMBER)
			    ERROR-TABLE-FILE)
		     (TERPRI ERROR-TABLE-FILE)
		     (PRINC '|(SETQ MICROCODE-ERROR-TABLE '(| ERROR-TABLE-FILE) ;|))|
		     ))
	      (PRINT (CONS (1- I-MEM-LOC) (CDR WD)) ERROR-TABLE-FILE))
	     ((EQ (CAR WD) 'COMMENT))
	     (T (GO W1)))
X	(RETURN NIL)
W1	(SETQ CONS-LAP-WDS-SINCE-LAST-SYM (1+ CONS-LAP-WDS-SINCE-LAST-SYM))
	(COND (DISPATCH-ARM 
		(CONS-LAP-BARF WD 'STORAGE-WD-IN-UNLOCATED-DISPATCH-BLOCK 'DATA)))
	(SETQ V (CONS-WORD-EVAL WD))
	(COND ((EQ LOCALITY 'A-MEM)
		(STORE (A-MEM A-MEM-LOC) V)
		(SETQ A-MEM-LOC (1+ A-MEM-LOC)))
	      ((EQ LOCALITY 'M-MEM)
		(STORE (M-MEM M-MEM-LOC) V)
		(SETQ M-MEM-LOC (1+ M-MEM-LOC)))
	      ((EQ LOCALITY 'D-MEM)
		(SETQ V (+ V DISPATCH-CONSTANT))	;CONSTANT FOR ENTIRE BLOCK
		(SETQ V (+ (LSH (LOGLDB 703 V) 12.)	;RPN BITS FROM JUMP
			   (LOGLDB 1414 V)))		;PC FROM JUMP
		(STORE (D-MEM D-MEM-LOC) V)
		(SETQ D-MEM-LOC (1+ D-MEM-LOC)))
	      ((EQ LOCALITY 'I-MEM)
		(STORE (I-MEM I-MEM-LOC) V)
		(SETQ I-MEM-LOC (1+ I-MEM-LOC)))
	      (T (CONS-LAP-BARF WD 'STORAGE-WD-IN-BAD-LOCALITY 'DATA)))
	 (RETURN NIL)
))

(DEFUN CONS-LAP-WIPE-SYMBOL-VECTOR (QUAN)
  (PROG (IDX END-TEST)
	(SETQ IDX 0)
	(SETQ END-TEST (CADR (ARRAYDIMS 'MICRO-CODE-SYMBOL-IMAGE)))
  L	(COND ((NOT (< IDX END-TEST))
		(RETURN T))
	      ((NULL (MICRO-CODE-SYMBOL-IMAGE IDX))
		(STORE (MICRO-CODE-SYMBOL-IMAGE IDX) QUAN)))
	(SETQ IDX (1+ IDX))
	(GO L)))

(DEFUN CONS-LAP-STORE-UCODE-ENTRY (NAME IDX OFFSET)
        (COND ((NULL IDX) (CONS-LAP-BARF NAME 'NO-UCODE-ENTRY-INDEX 'WARN))
	      (T (STORE (MICRO-CODE-SYMBOL-IMAGE (+ IDX OFFSET)) I-MEM-LOC))))

(DEFUN CONS-LAP-REPEAT-2 (COUNT ITEM)
  (PROG NIL 
	(COND ((ATOM ITEM) (SETQ ITEM (LIST ITEM))))
 L	(COND ((ZEROP COUNT) (RETURN NIL)))
	(CONS-LAP-PASS2 ITEM)
	(SETQ COUNT (1- COUNT))
	(GO L)))

(DEFUN CONS-WORD-EVAL (WD)
  (PROG (COMBINED-VALUE COMBINED-INDICATORS DESTINATION-CONTEXT 
	 INSTRUCTION-CONTEXT FIELD-INDICATORS FIELD-VALUE TEM TEM1 TEM2 
	 DESTINATION-INDICATORS CURRENT-WORD)
	(SETQ COMBINED-VALUE 0)		;CAUTION! COMBINED-VALUE CAN BE A BIGNUM
	(SETQ CURRENT-WORD WD)		;SO CAN SEE IT WHEN STUFF COMPILED
	(SETQ INSTRUCTION-CONTEXT 'INSTRUCTION)
L	(SETQ FIELD-INDICATORS NIL)
	(COND ((NULL WD) (RETURN 
			   (CONS-LAP-DEFAULT-AND-BUGGER 
				INSTRUCTION-CONTEXT 
				COMBINED-VALUE
				COMBINED-INDICATORS 
				DESTINATION-INDICATORS)))
	      ((NUMBERP (CAR WD))
		(SETQ FIELD-VALUE (CAR WD)))
	      ((ATOM (CAR WD))
		(SETQ FIELD-VALUE (CONS-LAP-SYM-RUN (CAR WD))))
	      ((EQ (CAAR WD) 'M-CONSTANT)
		(SETQ FIELD-VALUE (CONS-M-CONSTANT (CADAR WD))))
	      ((EQ (CAAR WD) 'A-CONSTANT)
		(SETQ FIELD-VALUE (CONS-A-CONSTANT (CADAR WD))))
	      ((SETQ TEM 
		   (ASSQ (CAAR WD) 
			'( (ARG-CALL . 3_12.)		;P-BIT N-BIT
			   (ARG-JUMP . 1_12.)		;N-BIT
			   (ARG-CALL-XCT-NEXT . 2_12.)	;P-BIT
			   (ARG-JUMP-XCT-NEXT . 0_12.) ))) ; NONE
		(SETQ TEM1 (CONS-LAP-ARG-EVAL (CADAR WD))) ;TAG
		(SETQ TEM2 (ASSOC I-MEM-LOC ARG-CALL-LIST))
		(COND ((NULL TEM2) 
			(CONS-LAP-BARF I-MEM-LOC 
					'NO-D-MEM-RESERVED-FOR-ARG-CALL 
					'BARF)))
		(STORE (D-MEM (CDR TEM2))
		       (+ (CDR TEM) (LSH TEM1 -12.)))
		(CONS-GET-NEW-CONTEXT 'FORCE-DISPATCH)
		(ADD-FIELD-INDICATORS 'D-MEM)
		(SETQ FIELD-VALUE (* (CDR TEM2) 1_14.)))
	      ((MEMQ (CAAR WD) '(BYTE-FIELD LISP-BYTE ALL-BUT-LISP-BYTE 
				 FIELD BYTE-MASK BYTE-VALUE PLUS DIFFERENCE 
				 OA-HIGH-CONTEXT OA-LOW-CONTEXT EVAL I-ARG
				 I-MEM-LOC D-MEM-LOC A-MEM-LOC M-MEM-LOC))
		(SETQ FIELD-VALUE (CONS-LAP-EVAL (CAR WD))))
	      (T
		(CONS-GET-NEW-CONTEXT 'FORCE-ALU-OR-BYTE)
		(SETQ FIELD-VALUE (CONS-DESTINATION (CAR WD)))

		(SETQ FIELD-VALUE 
		     (CONVERT-VALUE-TO-DESTINATION FIELD-VALUE FIELD-INDICATORS))
		(SETQ DESTINATION-INDICATORS FIELD-INDICATORS)
		(SETQ FIELD-INDICATORS NIL)) )
	(SETQ COMBINED-VALUE (PLUS COMBINED-VALUE FIELD-VALUE))
;	(PRINT (LIST (CAR WD) FIELD-VALUE FIELD-INDICATORS))
	(SETQ COMBINED-INDICATORS (MERGE-INDICATORS 
					FIELD-INDICATORS COMBINED-INDICATORS))
	(SETQ WD (CDR WD))
	(GO L)
))

(DEFUN CONS-LAP-DEFAULT-AND-BUGGER 
	(INSTRUCTION-CONTEXT COMBINED-VALUE COMBINED-INDICATORS DESTINATION-INDICATORS)
  (PROG (T1 T2 INST TEM)
;	(PRINT (LIST INSTRUCTION-CONTEXT 
;		     COMBINED-VALUE 
;		     COMBINED-INDICATORS 
;		     DESTINATION-INDICATORS))
	(COND ((NOT (EQ LOCALITY 'I-MEM))
		(GO X))
	      ((MEMQ INSTRUCTION-CONTEXT '(FORCE-ALU FORCE-ALU-OR-BYTE INSTRUCTION))
		(GO ALU))
	      ((EQ INSTRUCTION-CONTEXT 'FORCE-DISPATCH)
		(GO DISPATCH))
	      ((EQ INSTRUCTION-CONTEXT 'FORCE-BYTE)
		(GO BYTE))
	      ((EQ INSTRUCTION-CONTEXT 'FORCE-JUMP)
		(GO JUMP))
	      (T (CONS-LAP-BARF (LIST INSTRUCTION-CONTEXT 
				      COMBINED-VALUE COMBINED-INDICATORS
				      DESTINATION-INDICATORS)
		       'BAD-INSTRUCTION-TYPE
		       'WARN)
		 (GO X)))
   ALU	(COND ((NULL (MEMQ 'ALU-OUTPUT-BUS-SELECTOR-MULTIPLIER 	;DEFAULT OUTPUT BUS
			   COMBINED-INDICATORS))		;SELECTOR IF NOT SPECD
		(SETQ COMBINED-VALUE (PLUS COMBINED-VALUE 1_12.))))
	(COND ((MEMQ 'ALU-OP COMBINED-INDICATORS)
		(GO ALU-1)))
	(SETQ T1 (MEMQ 'A-MEM COMBINED-INDICATORS))		;DEFAULT ALU OP IF NOT
	(SETQ T2 (MEMQL '(M-MEM FUNCTION-SOURCE) COMBINED-INDICATORS))	;SPECD
	(COND ((AND T1 T2)			;(ALU MUST BE ACTING AS A SELECTOR)
		(CONS-LAP-BARF COMBINED-INDICATORS 
			       'ALU-INST-ADRS-A-AND-M-WITHOUT-ALU-OP 
				'WARN))
	      (T1 (SETQ COMBINED-VALUE 
			(PLUS COMBINED-VALUE 32_4)))	;SETA
	      (T2 (SETQ COMBINED-VALUE 
			(PLUS COMBINED-VALUE 37_4)))	;SETM
	      (T  (SETQ COMBINED-VALUE 
			(PLUS COMBINED-VALUE 23_4))))	;NEITHER SPECD? SETZ I GUESS
  ALU-1	(GO X)
   BYTE	(COND ((NULL (MEMQ 'A-MEM COMBINED-INDICATORS))	;DEFAULT A-MEM ADR TO
		(SETQ COMBINED-VALUE 			;A-ZERO IF NOT SUPPLIED,
			(PLUS COMBINED-VALUE 2_30.))))	;THIS RIGHT FOR BOTH LDB AND DPB
	(SETQ INST 30000000000000)			;BYTE INST
	(SETQ TEM (LOGLDB 0505 COMBINED-VALUE))
	(COND ((NOT (= 0 TEM))   ;IF 0 LEAVE IT ALONE SINCE
		(SETQ COMBINED-VALUE   ;ITS PROBABLY OA- HACKERY
			(LOGDPB (1- TEM) ;BUGGER BECAUSE
			 	0505 		;BYTE LENGTH IS <BYTL -1>
				COMBINED-VALUE))))
	(SETQ T1 (LOGLDB 1401 COMBINED-VALUE))	;GET SR-BIT
	(SETQ COMBINED-VALUE (LOGDPB (- 1 T1)	;STORE IT BACK COMPLEMENTED
		1401 COMBINED-VALUE))
	(COND ((> (LOGLDB 1402 COMBINED-VALUE) 1)
		(GO X1)))	;DONT BUGGER DPB OR SEL DEPOS
   M-ROTATE-BUGGER					;32. REFLECT M-ROTATE FIELD
	(SETQ T1 (BIGNUM-LOGAND-LOW  6037 COMBINED-VALUE))	;GOBBLE MISC FCTN
								;AND M-ROTATE
   M-ROTATE-BUGGER-1
	(COND ((= 6000 (LOGAND 6000 T1))	;MISC-FCTN 3 IS IOR LOW-ORDER-PC-BIT
		(SETQ T1 (LOGAND 37 T1))	;THUS, 20 REFLECT IT INSTEAD OF 40
		(SETQ T2 (- 20 T1))
		(COND ((MINUSP T2)
			(CONS-LAP-BARF T1 'M-ROTATE-GREATER-THAN-17-IN-MF3 'WARN)
			(SETQ T2 0))))
	      (T (SETQ T1 (LOGAND 37 T1))
		 (SETQ T2 (LOGAND 37 (- 40 T1)))))
	(SETQ COMBINED-VALUE (PLUS COMBINED-VALUE (- T2 T1)))
   X1	(SETQ COMBINED-VALUE (PLUS COMBINED-VALUE INST))
   X	(RETURN COMBINED-VALUE)
   DISPATCH 
	(SETQ INST 50000000000000)	;DISPATCH INSTRUCTION PLUS I-LONG
        ;(SETQ INST 10000000000000)	;JUST DISPATCH INSTRUCTION
	(GO M-ROTATE-BUGGER)
   JUMP 
	(SETQ INST 20000000000000)
	(SETQ T1 (BIGNUM-LOGAND-LOW 6077 COMBINED-VALUE))
	(COND ((> (LOGAND T1 77) 37) (GO X1)))	;TEST-CONDITION, DONT HACK
	(GO M-ROTATE-BUGGER-1)		;RANDOMLY SAVE A BIGNUM OP
))

;CONSTANT LISTS.
;A LIST OF LISTS.  CAR IS VALUE OF CONSTANT, CADR IS ADDRESS, CADDR IS #USERS, CADDDR IS 
;	LAST PC TO USE IT.

(DEFUN CONS-M-CONSTANT (C)
  (PROG (TEM V)
	(SETQ V (CONS-LAP-ARG-EVAL C))
	(COND ((= V 0) 
		(SETQ TEM 2))	;M LOCN 2 ALWAYS HAS 0
	      ((OR (= V 37777777777) (= V -1))
	       (SETQ TEM 3))	;M LOCN 3 ALWAYS HAS -1 (TO 32 BITS)
	      ((SETQ TEM (ASSOC V M-CONSTANT-LIST))
	        (RPLACA (CDDR TEM) (1+ (CADDR TEM)))
		(RPLACA (CDDDR TEM) CONS-LAP-LAST-SYM)
		(SETQ TEM (CADR TEM)))
	      (T
		(SETQ TEM M-CONSTANT-LOC M-CONSTANT-LOC (1+ M-CONSTANT-LOC))
		(SETQ M-CONSTANT-LIST (CONS (LIST V TEM 1 CONS-LAP-LAST-SYM) M-CONSTANT-LIST))))
	(OR (< TEM 40) (CONS-LAP-BARF (LIST TEM C) 'M-CONST-ADDR-OOB 'BARF))
	(ADD-FIELD-INDICATORS 'M-MEM)
	(RETURN (LSH TEM 24.)) ))

(DEFUN CONS-A-CONSTANT (C)
  (PROG (TEM V)
	(SETQ V (CONS-LAP-ARG-EVAL C))
	(COND ((= V 0) 
		(SETQ TEM 2))	;A LOCN 2 ALWAYS HAS 0
	      ((OR (= V 37777777777) (= V -1))
	       (SETQ TEM 3))	;A LOCN 3 ALWAYS HAS -1 (TO 32 BITS)
	      ((SETQ TEM (ASSOC V A-CONSTANT-LIST))
	        (RPLACA (CDDR TEM) (1+ (CADDR TEM)))
		(RPLACA (CDDDR TEM) CONS-LAP-LAST-SYM)
		(SETQ TEM (CADR TEM)))
	      ((SETQ TEM (ASSOC V M-CONSTANT-LIST))	;A=M!!
	        (RPLACA (CDDR TEM) (1+ (CADDR TEM)))
		(RPLACA (CDDDR TEM) CONS-LAP-LAST-SYM)
		(SETQ TEM (CADR TEM)))
	      ((NOT (NULL A-MEM-CREVICE-LIST))	;TRY TO FILL IN CREVICES IN MEMORY
		(SETQ TEM (CAR A-MEM-CREVICE-LIST))
		(SETQ A-MEM-CREVICE-LIST (CDR A-MEM-CREVICE-LIST))
		(SETQ A-CONSTANT-LIST (CONS (LIST V TEM 1 CONS-LAP-LAST-SYM) A-CONSTANT-LIST)))
	      (T
		(SETQ TEM A-CONSTANT-LOC A-CONSTANT-LOC (1+ A-CONSTANT-LOC))
		(SETQ A-CONSTANT-LIST (CONS (LIST V TEM 1 CONS-LAP-LAST-SYM)
					    A-CONSTANT-LIST))))
	(OR (< TEM 400) (CONS-LAP-BARF (LIST TEM C) 'A-CONST-ADDR-OOB 'BARF))
	(ADD-FIELD-INDICATORS 'A-MEM)
	(RETURN (LOGDPB TEM 3610 0)) ))

(DEFUN CONVERT-VALUE-TO-DESTINATION (VALUE INDICATORS)
  (PROG (V)
	(SETQ V (LOGLDB 0012 VALUE))	;GOBBLE BYTE INFO, IF ANY (HOPE HOPE)
	(COND ((MEMQ 'A-MEM INDICATORS)
		(COND ((MEMQL '(M-MEM FUNCTION-DESTINATION) INDICATORS)
			(CONS-LAP-BARF (LIST VALUE INDICATORS) 'BAD-DESTINATION 'DATA)))
		(SETQ V (+ V (LSH (LOGLDB 3610 VALUE) 14.))))
	      ((MEMQ 'M-MEM INDICATORS)
		(SETQ V (+ V (LSH (LOGLDB 3006 VALUE) 14.)))))
	(COND ((MEMQ 'FUNCTION-DESTINATION INDICATORS)
		(SETQ V (+ V (LOGAND 17_19. 
				     VALUE)))))
	(COND ((MEMQ 'A-MEM INDICATORS)
		(SETQ V (+ V 1_23.))))
	(RETURN V)
))

(DEFUN MERGE-INDICATORS (A B) (MERGE A B))

(DEFUN MERGE (A B)
  (PROG NIL 
	(COND ((NULL B) (RETURN A)))
  L	(COND ((NULL A) (RETURN B))
	      ((NOT (MEMQ (CAR A) B))
		(SETQ B (CONS (CAR A) B))))
	(SETQ A (CDR A))
	(GO L)))

(DEFUN CONS-DESTINATION (X)
  (PROG (DESTINATION-CONTEXT V)
	(SETQ V 0)
	(SETQ DESTINATION-CONTEXT 'DESTINATION)
	(COND ((NULL (CDR X))	;SAVE A PLUS IN COMMON CASE..
		(RETURN (CONS-LAP-SYM-RUN (CAR X)))))
L	(COND ((NULL X) (RETURN V)))
	(SETQ V (PLUS V (CONS-LAP-SYM-RUN (CAR X))))
	(SETQ X (CDR X))
	(GO L)
))

(DEFUN CONS-LAP-SYM-RUN (SYM)
  (PROG (TEM)
	(COND ((NULL (SETQ TEM (CONS-LAP-SYMEVAL SYM)))
		(CONS-LAP-BARF SYM 'UNDEFINED-SYM 'WARN)
		(RETURN 0))
	      (T (RETURN (CONS-LAP-EVAL TEM))))))

(DEFUN CONS-LAP-ARG-EVAL (ARG)
  (PROG (COMBINED-VALUE COMBINED-INDICATORS DESTINATION-CONTEXT 
         INSTRUCTION-CONTEXT FIELD-INDICATORS)
	(SETQ INSTRUCTION-CONTEXT 'INSTRUCTION)
	(RETURN (CONS-LAP-EVAL ARG))))

(DEFUN CONS-LAP-EVAL (EXP)      ;EXP A SYMBOL "PROGRAM".
				;RETURNS EITHER A NUMBERIC VALUE OR NIL, AND
				;MAY HAVE THE SIDE EFFECT OF MODIFING 
				;INSTRUCTION-CONTEXT AND/OR FIELD-INDICATORS

  (PROG (VAL V TEM)
L	(COND ((NULL EXP) (GO X))
	      ((NUMBERP EXP)
		(SETQ V EXP)
		(GO C-V))
	      ((ATOM EXP) 
		(SETQ V (CONS-LAP-SYM-RUN EXP))
		(GO C-V))
	      ((MEMQ (CAR EXP) '(A-MEM M-MEM I-MEM D-MEM))
		(GO L2))
	      ((EQ (CAR EXP) 'SOURCE-P) (GO S-P))
	      ((EQ (CAR EXP) 'DESTINATION-P) (GO D-P))
	      ((MEMQ (CAR EXP) '(FORCE-DISPATCH FORCE-JUMP FORCE-ALU FORCE-BYTE 
			FORCE-DISPATCH-OR-BYTE FORCE-ALU-OR-BYTE))
		(CONS-GET-NEW-CONTEXT (CAR EXP))
		(GO L2))
	      ((SETQ TEM (ASSQ (CAR EXP) '( (DISPATCH-INSTRUCTION-P . FORCE-DISPATCH)
		(BYTE-INSTRUCTION-P . FORCE-BYTE) (JUMP-INSTRUCTION-P . FORCE-JUMP)
		(ALU-INSTRUCTION-P . FORCE-ALU))))
		(GO I-P))
	      ((EQ (CAR EXP) 'NOT)
		(GO N1))
	      ((EQ (CAR EXP) 'OR)
		(GO OR-1))
	      ((SETQ V (ASSQ (CAR EXP)
			     '((I-MEM-LOC . I-MEM) (D-MEM-LOC . D-MEM)
			       (A-MEM-LOC . A-MEM) (M-MEM-LOC . M-MEM))))
		(SETQ TEM (CONS-LAP-SYMEVAL (CADR EXP)))
		(OR (EQ (CAR TEM) (CDR V))
		    (CONS-LAP-BARF EXP 'LOSES 'DATA))
		(SETQ V (CADDR (CADR TEM)))
		(GO C-V))
	      ((EQ (CAR EXP) 'FIELD)
		(SETQ TEM (CONS-LAP-SYM-RUN (CADR EXP)))
		(SETQ V (TIMES (CONS-LAP-EVAL (CADDR EXP)) TEM))
		(COND ((SETQ TEM (GET (CADR EXP) 'CONS-LAP-ADDITIVE-CONSTANT))
			(SETQ V (PLUS V TEM))))
		(ADD-FIELD-INDICATORS (CADR EXP))
		(GO C-V))
	      ((EQ (CAR EXP) 'PLUS)
		(SETQ V (PLUS (CONS-LAP-EVAL (CADR EXP))
			   (CONS-LAP-EVAL (CADDR EXP))))
		(GO C-V))
	      ((EQ (CAR EXP) 'DIFFERENCE)
		(SETQ V (DIFFERENCE (CONS-LAP-EVAL (CADR EXP))
				    (CONS-LAP-EVAL (CADDR EXP))))
		(GO C-V))
	      ((EQ (CAR EXP) 'BYTE-FIELD)
		(COND ((MEMQ INSTRUCTION-CONTEXT '(INSTRUCTION FORCE-DISPATCH-OR-BYTE 
							FORCE-ALU-OR-BYTE))
			(CONS-GET-NEW-CONTEXT 'FORCE-BYTE)))
		(COND ((EQ INSTRUCTION-CONTEXT 'FORCE-BYTE)
			(SETQ V (+ (* 1_5 (CADR EXP))
				   (CADDR EXP))))
		      ((EQ INSTRUCTION-CONTEXT 'FORCE-DISPATCH)
			(SETQ V (+ (* 1_5. (CADR EXP))
				   (CADDR EXP))))
		      ((EQ INSTRUCTION-CONTEXT 'FORCE-JUMP)
			(COND ((NOT (= 1 (CADR EXP)))
				(CONS-LAP-BARF (CADR EXP) 
						'CAN-ONLY-TEST-ONE-BIT-FIELD-WITH-JUMP 
						 'DATA)))
			(SETQ V (CADDR EXP)))
		      (T (CONS-LAP-BARF INSTRUCTION-CONTEXT 
					'BYTE-FIELD-IN-BAD-CONTEXT 
					'DATA)))
		(GO C-V))
	      ((EQ (CAR EXP) 'LISP-BYTE)
		(SETQ V (CONS-LAP-EVAL (CONVERT-LISP-BYTE (CADR EXP))))
		(GO C-V))
	      ((EQ (CAR EXP) 'ALL-BUT-LISP-BYTE)
		(SETQ V (CONS-LAP-EVAL (CONVERT-ALL-BUT-LISP-BYTE (CADR EXP))))
		(GO C-V))
	      ((EQ (CAR EXP) 'BYTE-MASK)
		(SETQ V (CONS-LAP-GET-BYTE-VALUE (CADR EXP) -1))
		(GO C-V))
	      ((EQ (CAR EXP) 'BYTE-VALUE)
		(SETQ V (CONS-LAP-GET-BYTE-VALUE (CADR EXP) (CADDR EXP)))
		(GO C-V))
	      ((EQ (CAR EXP) 'EVAL)
		(SETQ V (EVAL (CADR EXP)))
		(GO C-V))
	      ((EQ (CAR EXP) 'I-ARG)
		(SETQ V (LOGDPB (CONS-LAP-EVAL (CADR EXP))
				3610 
				0))
		(GO C-V))
	      ((EQ (CAR EXP) 'OA-HIGH-CONTEXT)
		(SETQ V (LOGLDB 3025 (CONS-WORD-EVAL (CADR EXP)))) ;ALL ABOVE 24. BITS
		(GO C-V))
	      ((EQ (CAR EXP) 'OA-LOW-CONTEXT)
		(SETQ V (LOGLDB 0030 (CONS-WORD-EVAL (CADR EXP)))) ;LOW 24. BITS
		(GO C-V))
	      (T (CONS-LAP-BARF EXP 'UNRECGONIZED-OP 'DATA)
		 (GO X)))
OR-2	(COND ((NULL (CDR (SETQ EXP (CDR EXP))))
		(GO X)))				;ALL NIL
OR-1	(SETQ TEM (CONS-LAP-EVAL (CADR EXP)))
	(COND ((NULL TEM) (GO OR-2)))	;THAT ONE EVALUATED TO NIL
MERGE-V	(COND ((NULL VAL) (SETQ VAL TEM))
	      (T (SETQ VAL (PLUS VAL TEM))))
	(GO X)
N1	(SETQ TEM (CONS-LAP-EVAL (LIST (CAADR EXP) 1)))
	(COND ((= TEM 1) (GO X))   ;THAT CONDITION TRUE, THIS FALSE
	      (T (SETQ EXP (CADR EXP))	;THAT CONDITION FALSE, THIS TRUE
		 (GO L1)))
D-P	(COND (DESTINATION-CONTEXT (GO L1)))
	(GO X)
S-P	(COND (DESTINATION-CONTEXT (GO X)))
	(GO L1)

L2	(ADD-FIELD-INDICATORS (CAR EXP))
L1	(SETQ EXP (CADR EXP))
	(GO L)
I-P	(COND ((EQ (CDR TEM) INSTRUCTION-CONTEXT)
		(GO L1))		;CONDITION TRUE
	      ((EQ INSTRUCTION-CONTEXT 'INSTRUCTION)
		(CONS-LAP-BARF EXP 'UNDETERMINED-CONDITION 'WARN)))
	(GO X)		;CONDITION FALSE
C-V	(COND ((NULL VAL) (SETQ VAL 0)))
	(COND ((NULL V)
	       (CONS-LAP-BARF EXP 'EVALUATED-TO-NIL 'DATA))
	      (T (SETQ VAL (PLUS VAL V))))
X	(RETURN VAL) ))

(DEFUN CONVERT-LISP-BYTE (X)  ;CONVERT LISP-BYTE TO CORRESPONDING BYTE-FIELD
  (PROG (TEM)
	(SETQ TEM (EVAL X))
	(RETURN (LIST 'BYTE-FIELD (LOGAND TEM 77) 
				  (LOGLDB 0606 TEM)
))))

(DEFUN CONVERT-ALL-BUT-LISP-BYTE (X)	;ADDRESS ALL BITS NOT IN BYTE. BYTE MUST BE
  (PROG (TEM BITS OVER)			;LEFT OR RIGHT ADJUSTED IN 32. BITS
	(SETQ TEM (EVAL X))
	(SETQ BITS (LOGAND TEM 77) OVER (LOGLDB 0606 TEM))
	(COND ((= 0 OVER)
		(SETQ OVER BITS)
		(SETQ BITS (- 32. BITS)))
	      ((= 32. (+ BITS OVER))
		(SETQ BITS (- 32. BITS))
		(SETQ OVER 0))
	      (T (CONS-LAP-BARF X 'ALL-BUT-BYTE-NOT-LEFT-OR-RIGHT-ADJUSTED 'DATA)))
	(RETURN (LIST 'BYTE-FIELD BITS OVER))))

(DEFUN CONS-LAP-GET-BYTE-VALUE (EXP VAL);"EVALUATE" EXP SIMILIAR TO CONS-LAP-EVAL
  (PROG (TEM)				;BUT RETURN NIL FOR ANYTHING BUT BYTE-FIELD,
	(COND ((NUMBERP VAL))		;FOR WHICH RETURN VAL IN FIELD OF BYTE
	      ((NOT (ATOM VAL))
	       (SETQ VAL (CONS-LAP-ARG-EVAL VAL)))
	      ((SETQ TEM (CONS-LAP-SYMEVAL VAL))
	       (SETQ VAL TEM))
	      ((SETQ VAL (SYMEVAL VAL))))
	(COND ((NULL EXP) (RETURN NIL))
	      ((NUMBERP EXP)
		(RETURN (CONS-LAP-GET-BYTE-VALUE (CONVERT-LISP-BYTE EXP) VAL)))
	      ((ATOM EXP)
		(RETURN (CONS-LAP-GET-BYTE-VALUE
			  (OR (CONS-LAP-SYMEVAL EXP) (SYMEVAL EXP)) VAL)))
	      ((MEMQ (CAR EXP) '(M-MEM FORCE-DISPATCH FORCE-BYTE FORCE-DISPATCH-OR-BYTE 
				 FORCE-ALU-OR-BYTE))
		(RETURN (CONS-LAP-GET-BYTE-VALUE (CADR EXP) VAL)))
	      ((MEMQ (CAR EXP) '(A-MEM I-MEM D-MEM SOURCE-P DESTINATION-P FORCE-JUMP
				FORCE-ALU NOT OR FIELD EVAL))
		(RETURN NIL))
	      ((EQ (CAR EXP) 'PLUS)
		(RETURN (OR (CONS-LAP-GET-BYTE-VALUE (CADR EXP) VAL)
			    (CONS-LAP-GET-BYTE-VALUE (CADDR EXP) VAL))))
	      ((EQ (CAR EXP) 'LISP-BYTE)
		(RETURN (CONS-LAP-GET-BYTE-VALUE (CONVERT-LISP-BYTE (CADR EXP)) VAL)))
	      ((EQ (CAR EXP) 'BYTE-FIELD)
		(RETURN (LOGDPB VAL (+ (LSH (CADDR EXP) 6) (CADR EXP)) 0)))
	      (T (CONS-LAP-BARF EXP 'CONS-LAP-GET-BYTE-VALUE 'WARN)))
))

(DEFUN ADD-FIELD-INDICATORS (X)
  (PROG NIL 
	(COND ((AND DESTINATION-CONTEXT   ;BETTER NOT PUT IN MORE THAN ONE OF THESE
		    (MEMQ X '(A-MEM M-MEM I-MEM D-MEM))  ;SINCE GOING TO DIVIDE IT OUT.
		    (MEMQL '(A-MEM M-MEM I-MEM D-MEM) FIELD-INDICATORS))
		(GO E1)))
	(COND ((EQ X 'A-MEM)
		(GO ADD-A))
	      ((EQ X 'M-MEM)
		(GO X))
	      ((EQ X 'I-MEM)
		(GO ADD-I))
	      ((EQ X 'D-MEM)
		(GO ADD-D))
	      ((EQ X 'FORCE-DISPATCH)
		(GO F-D))
	      ((EQ X 'FORCE-BYTE)
		(GO F-B))
	      ((EQ X 'FORCE-ALU)
		(GO F-A))
	      ((EQ X 'FORCE-JUMP)
		(GO F-J)))
   X	(COND ((NOT (MEMQ X FIELD-INDICATORS))
		(SETQ FIELD-INDICATORS (CONS X FIELD-INDICATORS))))
	(RETURN NIL)
 F-B	(COND ((MEMQL '(I-MEM D-MEM) COMBINED-INDICATORS)
		(GO E1)))
	(GO X)
 ADD-A	(COND ((OR (EQ INSTRUCTION-CONTEXT 'FORCE-DISPATCH)
		   (MEMQ 'D-MEM COMBINED-INDICATORS))
		(GO E1)))
	(GO X)
 F-A	(COND ((OR (MEMQ INSTRUCTION-CONTEXT '(FORCE-DISPATCH FORCE-JUMP))
		   (MEMQL '(I-MEM D-MEM) COMBINED-INDICATORS))
		(GO E1)))
	(GO X)
 F-J 
 ADD-I	(COND ((MEMQ INSTRUCTION-CONTEXT '(FORCE-DISPATCH FORCE-BYTE FORCE-ALU))
		(GO E1)))
	(GO X)
 F-D 
 ADD-D	(COND ((OR (MEMQ INSTRUCTION-CONTEXT '(FORCE-JUMP FORCE-BYTE FORCE-ALU))
		   (MEMQL '(A-MEM I-MEM) COMBINED-INDICATORS))
		(GO E1)))
	(GO X)
  E1	(CONS-LAP-BARF (LIST X FIELD-INDICATORS COMBINED-INDICATORS)
	      'INDICATOR-CONFLICT 
	      'DATA)
	(RETURN NIL)
))

(DEFUN MEMQL (A B)
  (PROG NIL 
L	(COND ((NULL A) (RETURN NIL))
	      ((MEMQ (CAR A) B) (RETURN A)))
	(SETQ A (CDR A))
	(GO L)))

(DEFUN CONS-GET-NEW-CONTEXT (NEW-CONTEXT)
  (PROG NIL
	(COND ((ATOM NEW-CONTEXT) 
		(RETURN (CONS-GET-NEW-CONTEXT-1 NEW-CONTEXT))))
L	(COND ((NULL NEW-CONTEXT) (RETURN T))
	      (T (CONS-GET-NEW-CONTEXT-1 (CAR NEW-CONTEXT))))
	(SETQ NEW-CONTEXT (CDR NEW-CONTEXT))
	(GO L)))

(DEFUN CONS-GET-NEW-CONTEXT-1 (NEW)
  (PROG NIL 
	(COND ((OR (EQ INSTRUCTION-CONTEXT NEW)
		   (NOT (MEMQ NEW '(FORCE-DISPATCH FORCE-JUMP FORCE-ALU FORCE-BYTE 
			FORCE-DISPATCH-OR-BYTE FORCE-ALU-OR-BYTE))))
		(RETURN NIL))
	      ((EQ INSTRUCTION-CONTEXT 'INSTRUCTION)
		(GO N1))
	      ((AND (EQ INSTRUCTION-CONTEXT 'FORCE-BYTE)
		    (MEMQ NEW '(FORCE-DISPATCH-OR-BYTE FORCE-ALU-OR-BYTE)))
		(RETURN NIL))
	      ((AND (EQ INSTRUCTION-CONTEXT 'FORCE-ALU)
		    (EQ NEW 'FORCE-ALU-OR-BYTE))
		(RETURN NIL))
	      ((AND (EQ NEW 'FORCE-BYTE)
		    (MEMQ INSTRUCTION-CONTEXT
			  '(FORCE-DISPATCH-OR-BYTE FORCE-ALU-OR-BYTE)))
		(GO N1))
	      ((AND (EQ NEW 'FORCE-ALU)
		    (EQ INSTRUCTION-CONTEXT 'FORCE-ALU-OR-BYTE))
		(GO N1))
	      ((OR (AND (EQ INSTRUCTION-CONTEXT 'FORCE-DISPATCH-OR-BYTE)
			(EQ NEW 'FORCE-ALU-OR-BYTE))
		   (AND (EQ NEW 'FORCE-ALU-OR-BYTE)
			(EQ INSTRUCTION-CONTEXT 'FORCE-DISPATCH-OR-BYTE)))
		(SETQ NEW 'FORCE-BYTE)
		(GO N1)))
	(CONS-LAP-BARF (LIST INSTRUCTION-CONTEXT NEW) 'CONFLICTING-CONTEXT 'DATA)
	(RETURN NIL)
  N1	(SETQ INSTRUCTION-CONTEXT NEW)
	(RETURN T)
))

