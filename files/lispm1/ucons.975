;;;CONS MACHINE MICROCODE		-*-FUNDAMENTAL-*- TO THE OPERATION OF THE SYSTEM

;	HERE COMES A MAN
;	TO LEAD YOU TO
;	YOUR VERY OWN MACHINE! 
;		TOMMY, THE WHO

; "Microprogramming is a wasteland of time and too dependant on
;	the technology of implementation."  --Gordon Bell


(SETQ VERSION-NUMBER ((LAMBDA (IBASE)
			 (READLIST (EXPLODEN (CADDR (TRUENAME INFILE)))))
		      10.))

(SETQ UCONS '(

;Notes re the ERROR-TABLE pseudo-op:
;  If the error list contains the symbol CALLS-SUB, the entry serves only
;to mark an interesting item for the user on the micro-stack.  Accordingly,
;the entry should be positioned to match with whats on the stack at the time of
;the error. In particular, it should be after the following instruction in case of
;CALL-XCT-NEXT, etc.  No EHS- properties or routines are associated in this case.
;  Otherwise, the entry is intended to match with trap location saved at location
;TRAP.  In this case, the entry should immediately follow the instruction that may
;transfer to TRAP, whether or not it is XCT-NEXT.  These entries (may well) 
;coordinate with error recovery/printout routines in LISPM2;EHR >.  So check
;LISPM2;EHR > when making changes in the vicinity of an ERROR-TABLE which does not
;have a CALLS-SUB.  In particular, if the ERROR-TABLE entry is proceedable or to be made
;proceedable, make sure relavant quantities are all held in ACs that get saved
;(M-A, etc) as opposed to ones that dont (M-1, A-TEM1 etc).

;  To mark a point in the code to which proceed-routines may want to go,
;put an (ERROR-TABLE RESTART <name>) BEFORE the instruction.  <name> is any
;arbitrary symbol that does not conflict with any other used.

(ASSIGN-EVAL NQZUSD (EVAL (- 32. (LENGTH Q-DATA-TYPES))))	;# UNUSED DATA-TYPES
(ASSIGN-EVAL NATUSD (EVAL (- 32. (LENGTH ARRAY-TYPES))))	;# UNUSED ARRAY-TYPES
(ASSIGN-EVAL VERSION-NUMBER (EVAL VERSION-NUMBER)) ;MAKE SOURCE VERSION A CONSLP SYMBOL

;THESE SYMBOLS GET DEFINED SUITABLY FOR USE IN BYTE INSTRUCTIONS
;DATA LOADED WITH THESE MUST COME FROM M BUS

(DEF-DATA-FIELD Q-CDR-CODE 2 36)
(DEF-DATA-FIELD Q-FLAG-BIT 1 35)
(DEF-DATA-FIELD Q-DATA-TYPE 5 30)
(DEF-DATA-FIELD Q-DATA-TYPE-PLUS-ONE-BIT 6 27)
(DEF-DATA-FIELD Q-POINTER 30 0)
(DEF-DATA-FIELD Q-POINTER-WITHIN-PAGE 7 0)

(DEF-DATA-FIELD Q-TYPED-POINTER 35 0)	;POINTER+DATA-TYPE
(DEF-DATA-FIELD Q-ALL-BUT-TYPED-POINTER 3 35)
(DEF-DATA-FIELD Q-ALL-BUT-POINTER 10 30)
(DEF-DATA-FIELD Q-ALL-BUT-CDR-CODE 36 0)
(DEF-DATA-FIELD Q-ALL-BUT-POINTER-WITHIN-PAGE 31 7)

(DEF-DATA-FIELD BOXED-SIGN-BIT 1 23.)  ;SIGN OF A BOXED FIXNUM

(ASSIGN BITS-IN-AREA 8)	;BITS TO HOLD AREA NUMBER [NOT USED I HOPE]

;"INVOKE" OPS	;GIVEN TO INVOKED ROUTINE TO TELL IT WHAT IS TRYING TO BE DONE TO IT
(ASSIGN CAR-INVOKE-OP 1)
(ASSIGN CDR-INVOKE-OP 2)
(ASSIGN RPLACA-INVOKE-OP 3)
(ASSIGN RPLACD-INVOKE-OP 4)
(ASSIGN ARRAY-HEAD-INVOKE-OP 5)
(ASSIGN DATA-TYPE-INVOKE-OP 6)
(ASSIGN NILP-INVOKE-OP 7)

;EXTRA BITS ON MICRO STACK
(DEF-DATA-FIELD %%-PPBINF 2 12.)  ;IF THESE NON-ZERO, THEY SIGNAL PRESENCE OF ADDTL INFO
 (DEF-DATA-FIELD %%-PPBMIA 1 12.)	;MICRO-TO-MICRO CALL
 (DEF-DATA-FIELD %%-PPBMAA 1 13.)	;MICRO-TO-MACRO CALL
(DEF-DATA-FIELD %%-PPBSPC 1 14.)  ;DO BBLKP (POPPING A BLOCK OFF LINEAR BINDING PDL)
		; ON EXIT FROM THIS FCTN. FCTN MUST EXIT TO CBBLKP OR MRNMV TO CAUSE
		; THIS TO GET LOOKED AT.  ALSO, VARIOUS PDL GRUBLING ROUTINES 
		; LOOK AT THIS. 

(ASSIGN *CATCH-U-CODE-ENTRY-/# 0)	;MUST KNOW ABOUT THESE WHEN GRUBBLING STACK.. 
					; NOTE U-CODE ENTRY #'S ARE NORMALLY 
					; UNCONSTRAINED AND DETERMINE ONLY POSITION
					; IN MICRO-CODE-ENTRY-AREA, ETC. 
(ASSIGN PG-FAULT-OR-INTERRUPT JUMP-ON-PAGE-FAULT-OR-INTERRUPT-PENDING-CONDITION)
(ASSIGN PG-FAULT JUMP-ON-PAGE-FAULT-CONDITION)
(ASSIGN NO-PG-FAULT (PLUS JUMP-ON-PAGE-FAULT-CONDITION INVERT-JUMP-SENSE))
(ASSIGN INTERRUPT JUMP-ON-INTERRUPT-PENDING-CONDITION)

(ASSIGN LOWEST-A-MEM-VIRTUAL-ADDRESS 36776000)	;MUST BE 0 MODULO SIZE OF A-MEM
(ASSIGN LOWEST-IO-SPACE-VIRTUAL-ADDRESS 37000000)  ;BEGINING OF X-BUS IO SPACE
(ASSIGN LOWEST-UNIBUS-VIRTUAL-ADDRESS 37400000)    ;END OF X-BUS, BEGINNING OF UNIBUS

(DEF-DATA-FIELD OAL-BYTL-1 5 5)		;MICRO INSTRUCTION FIELDS
(DEF-DATA-FIELD OAL-MROT 5 0)
(DEF-DATA-FIELD OAH-A-SRC 8 6)
(DEF-DATA-FIELD OAH-M-SRC 6 0)
(DEF-DATA-FIELD OAL-DEST 8 14.)	  ;THIS DEFINITION DOES NOT WIN FOR FUNCTIONAL DESTINATIONS
(DEF-DATA-FIELD OAL-JUMP 12. 12.)
(DEF-DATA-FIELD OAL-DISP 10. 14.)

(ASSIGN PDL-BUFFER-LOW-WARNING 20.)  ;MAX LENGTH BASIC FRAME + ADI
(ASSIGN PDL-BUFFER-SLOP 40.)	;NUMBER OF EXTRA WORDS TO LEAVE "UNUSED" AT END OF PDL BUFFER
				;4 FOR RANDOM UNCHECKED PUSHES, 10. FOR DISK HANDLER,
				; PLUS 26. FOR GOOD MEASURE. 
(ASSIGN PDL-BUFFER-HIGH-LIMIT ;MAX VALUE FOR M-PDL-BUFFER-ACTIVE-QS.  THIS ALLOWS MAX SIZE 
	(DIFFERENCE 2000 (PLUS 400 PDL-BUFFER-SLOP))) ;ACTIVE FRAME. 

;MODIFIERS FOR THE DISPATCH INSTRUCTION, USED TO INVOKE THE TRANSPORTER
; ((VMA-START-READ M-VMA-HELD) ---)
; (CALL-CONDITIONAL ...)
; ...
; ((VMA) READ-MEMORY-DATA) ;TO ADDRESS MAP (OLD MACHINE ONLY)
; (DISPATCH TRANSPORT-xxx) ;IF THIS DROPS THROUGH, OLD->NEW SPACE TRANSPORTATION
;			   ; HAS BEEN DONE AND INVISIBLE POINTERS HAVE BEEN FOLLOWED.
;			   ; M-VMA-HELD HAS THE ADDRESS, READ-MEMORY-DATA HAS THE CONTENTS,
;			   ; VMA IS RANDOM (ON NEW MACHINE, VMA WILL BE GOOD, FLUSH M-VMA-HELD)
; IT IS OK TO USE POPJ-AFTER-NEXT ANYWHERE IN THE VICINITY.
; DON'T USE POPJ-AFTER-NEXT OR JUMP-XCT-NEXT IN THE INSTRUCTION BEFORE
; A TRANSPORT.  ON THE NEXT MACHINE THESE PROBABLY WON'T WORK (FOR THE SAKE OF SPEED)

;THE NAMES OF SOME OF THESE SHOULD BE CHANGED....
(ASSIGN TRANSPORT (PLUS (PLUS (I-ARG 1) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-NO-TRAP (PLUS (PLUS (I-ARG 21) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-CDR (PLUS (PLUS (I-ARG 12) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-WRITE (PLUS (PLUS (I-ARG 23) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
;	NEXT ONE KLUDGED UP TO NOT BARF AT TRAP TYPES SO BIND WILL WORK.
;	THIS HAS TO BE FIXED UP BETTER LATER.  WELL, MAYBE THIS IS REALLY RIGHT?
(ASSIGN TRANSPORT-NO-EVCP (PLUS (PLUS (I-ARG 20) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-NO-EVCP-WRITE
	(PLUS (PLUS (I-ARG 22) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-HEADER (PLUS (PLUS (I-ARG 4) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
(ASSIGN TRANSPORT-AC (PLUS (PLUS (I-ARG 24) Q-DATA-TYPE-PLUS-ONE-BIT) D-TRANSPORT))
	;I-ARG BIT 0 => MAKE DTP-EXTERNAL-VALUE-CELL-POINTER INVISIBLE
	;I-ARG BIT 1 => DON'T TRANSPORT (WRITING OVER THIS Q ANYWAY)
	;I-ARG BIT 2 => BARF ON DTP-ONE-Q-FORWARD, DTP-EXTERNAL-VALUE-CELL-POINTER
	;I-ARG BIT 3 => ONE-Q-FORWARD NOT INVISIBLE (JUST LOOKING FOR CDR CODE)
	;I-ARG BIT 4 => CAUSES IT NOT TO BARF IF TRAP DATATYPE IS SEEN

	;LATER THESE MAY USE MULTIPLE DISPATCH TABLES RATHER THAN I-ARG'S
	;LATER THESE WILL TEST THE SPACE-BIT FROM THE MAP (HARDWARE NOT SET UP YET)

(LOCALITY M-MEM)	;ANYTHING WHICH IT IS DESIRED TO LDB OUT OF MUST BE IN M-MEM

M-GARBAGE	(0)	;THIS REG RANDOMLY STORED IN WHEN STORING IN FUNCTION 
			;DESTINATIONS AND NOT SIMULTANEOUSLY IN M-MEM

M-PGF-TEM (0)		;TEMPORARY LOCATION USED BY PAGE FAULT HANDLER

M-ZERO	(0)		;CONSTANT 0, USED FOR LDB OPERATIONS  (MUST BE IN LOCATION 2)
M-MINUS-ONE (-1)	;CONSTANT -1, USED FOR SIGN EXTENSION (MUST BE IN LOCATION 3)

;LETTERED REGISTERS, OR "PDP-10 ACS"
;THESE ARE PRESERVED BY INTERRUPTS AND PAGE FAULTS, AND MARKED-THROUGH
;BY THE GARBAGE COLLECTOR.  THEY MUST ALWAYS CONTAIN TYPED DATA.  SMALL
;NUMBERS (WITH TYPE-FIELD OF 0 OR 37) ARE ACCEPTABLE BY SPECIAL DISPENSATION.

M-ZR	(0)		;..
M-A	(0)		;.. 
M-B	(0)		;.. 
M-C	(0)		;.. 
M-D	(0)		;.. 
M-E	(0)		;.. 
M-T	(0)		;..	RESULT REGISTER, PSEUDO INDICATORS
M-R	(0)		;.. 
M-Q	(0)		;.. 
M-I	(0)		;.. 
M-J	(0)		;.. 
M-S	(0)		;.. 
M-K	(0)		;..
			;INTERRUPTS ALSO SAVE VMA, AND SAVE READ-MEMORY-DATA
			;BY RE-READING FROM VMA ON DISMISS.  WRITE-MEMORY-DATA
			;IS CLOBBERED BY INTERRUPTS.  THE RE-READING OF
			;READ-MEMORY-DATA MEANS THE INTERRUPT IS EFFECTIVELY
			;INSERTED -BEFORE- THE READ CYCLE.  NOTE THAT THIS
			;ORDERING ALLOWS AN EFFECTIVE READ-PAUSE-WRITE CYCLE
			;TO BE DONE JUST BY DOING A READ THEN A WRITE, EVEN
			;THOUGH AFTER EACH CYCLE IS STARTED INTERRUPTS ARE CHECKED. 

M-AP	(0)		;POINTS AT EXECUTING FRAME
			;CAUTION: M-AP HOLDS A PDL BUFFER ADDRESS
			;TO GET CORRESPONDING MEMORY ADDRESS, 
			;USE CONVERT-PDL-BUFFER-ADDRESS
			;CAUTION: M-AP MUST NOT CONTAIN ANY GARBAGE IN THE HIGH BITS. 

M-PC	(0)		;INTERPRETED PC (# HALFWORDS FROM BASE OF MEMORY)

;"NUMBERED REGISTERS".  THESE ARE TEMPORARIES WHICH ARE NOT MARKED THROUGH
;BY THE GARBAGE COLLECTOR AND NOT SAVED IN STACK GROUPS (THEREFORE CLOBBERED
;BY INTERRUPTS.)  M-1 AND M-2 ARE USED TO HOLD UNBOXED FIXNUMS OR FLONUM MANTISSAS;
;THEY ARE THE FIRST AND SECOND ARGUMENTS RESPECTIVELY.  M-3 IS A TEMPORARY WHICH
;IS -NOT- PRESERVED BY PAGE FAULTS, IT SHOULD ONLY BE USED
;OVER A LOCALITY OF A FEW INSTRUCTIONS.  M-1 AND M-2 ARE PRESERVED BY PAGE-FAULTS,
;BUT CAUTION SHOULD BE EXERCISED, GENERALLY THESE SHOULD ONLY BE VALID OVER
;A LOCALITY OF A FEW INSTRUCTIONS.
M-1	(0)
M-2	(0)
M-3	(0)	;WARNING! THIS ONE IS CLOBBERED BY PAGE FAULTS

(LOC 26)  ;%MODE-FLAGS LISP VARIABLE IS MAPPED TO THIS LOCATION, SEE QCOM
M-FLAGS			;"MACHINE STATE FLAGS"
;FIRST COME "PROCESSOR FLAGS" IE THOSE SAVED AND RESTORED OVER MACRO CALL-RETURN
  (DEF-NEXT-BIT M-QBBFL M-FLAGS)	;BIND BLOCK PUT ON SPECIAL PDL (IN MACRO-CODE)
					;BIND BLOCK "OPEN" SIGNAL TO LOW LEVEL ROUTINES
					; IN MICRO-COMPILED FCTNS
 (DEF-DATA-FIELD M-FLAGS-PROCESSOR-FLAGS 1 0)	;BYTE POINTER TO PROCESSOR FLAGS
 (DEF-DATA-FIELD M-FLAGS-EXCEPT-PROCESSOR-FLAGS 37 1)
;END "PROCESSOR FLAGS", BEGIN PROCESSOR "MODES"
  (DEF-NEXT-FIELD M-CAR-SYM-MODE 2 M-FLAGS)	;CAR OF SYM GIVES: 
						;  ERROR
						;  ERROR EXCEPT (CAR NIL) = NIL
						;  NIL
						;  P-STRING ARRAY POINTER
  (DEF-NEXT-FIELD M-CAR-NUM-MODE 2 M-FLAGS)	;CAR OF NUMBER GIVES: 
						;  ERROR
						;  NIL
						;  "WHATEVER IT IS"
  (DEF-NEXT-FIELD M-CDR-SYM-MODE 2 M-FLAGS)	;CDR OF SYM GIVES: 
						;  ERROR
						;  ERROR EXCEPT (CDR NIL) = NIL
						;  NIL
						;  PROPERTY LIST
  (DEF-NEXT-FIELD M-CDR-NUM-MODE 2 M-FLAGS)	;CDR OF NUM GIVES: 
						;  ERROR
						;  NIL
						;  "WHATEVER IT IS"

  (DEF-NEXT-BIT M-DONT-SWAP-IN M-FLAGS)		;MAGIC FLAG FOR CREATING FRESH PAGES

  (DEF-NEXT-BIT M-TRAP-ENABLE M-FLAGS)		;1 ENABLE ERROR TRAPPING

  (DEF-NEXT-FIELD M-MAR-MODE 2 M-FLAGS)		;1 IS READ-TRAP, 2 IS WRITE-TRAP

  (DEF-NEXT-BIT M-PGF-WRITE M-FLAGS)		;1 IF CURRENT PG FAULT IS WRITING

    (DEF-BIT-FIELD-IN-REG M-FLAGS-MAR-DISP 3 11. M-FLAGS)
		;INCLUDES M-MAR-MODE AND M-PGF-WRITE

  ( (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;SAME STUFF ALSO IN A-FLAGS
     (PLUS (BYTE-VALUE M-CAR-SYM-MODE 1)		;INITIAL MODE STATE
      (PLUS (BYTE-VALUE M-CAR-NUM-MODE 0)
       (PLUS (BYTE-VALUE M-CDR-SYM-MODE 1)
       	(PLUS (BYTE-VALUE M-CDR-NUM-MODE 0)
	 (PLUS (BYTE-VALUE M-DONT-SWAP-IN 0)
	  (PLUS (BYTE-VALUE M-TRAP-ENABLE 0)
	   (PLUS (BYTE-VALUE M-MAR-MODE 0)
		 (BYTE-VALUE M-PGF-WRITE 0))))))))))

M-PDL-BUFFER-ACTIVE-QS (0)	;HOLDS QS BETWEEN A-PDL-BUFFER-HEAD AND M-AP
				; SEE DISCUSSION ON PDL-BUFFER DUMP/REFILL

M-ERROR-SUBSTATUS  (0)	;IDENTIFING INFO WHEN TAKING ERROR.  IF NON-ZERO, THERE IS AN
			;ERROR PENDING
			;FOR NOW, AT LEAST, THIS IS ONLY USED BY FUNCTION-ENTRY ERRORS.
			;SYMBOL ASSIGNMENTS ARE UNIQUE TO EACH ERROR
  (DEF-NEXT-BIT M-QBTFA M-ERROR-SUBSTATUS)	;TOO FEW ARGS
  (DEF-NEXT-BIT M-QBTMA M-ERROR-SUBSTATUS)	;TOO MANY ARGS
  (DEF-NEXT-BIT M-QBEQTA M-ERROR-SUBSTATUS)	;ERRONEOUS QUOTED ARG
  (DEF-NEXT-BIT M-QBEEVA M-ERROR-SUBSTATUS)	;ERRONEOUS EVALUATED ARG
  (DEF-NEXT-BIT M-QBBDT M-ERROR-SUBSTATUS)	;BAD DATA TYPE
  (DEF-NEXT-BIT M-QBBQTS M-ERROR-SUBSTATUS)	;BAD QUOTE STATUS
 (RESET-BIT-POINTER M-ERROR-SUBSTATUS)

M-INST-BUFFER  (0)	;LAST MACRO INSTRUCTION Q FETCHED (2 INSTRUCTIONS)
  (DEF-BIT-FIELD-IN-REG M-INST-DEST 3 15 (PLUS M-INST-BUFFER 
				      LOW-PC-BIT-SELECTS-HALF-WD))
  (DEF-BIT-FIELD-IN-REG M-INST-OP 4 11 (PLUS M-INST-BUFFER 
				      LOW-PC-BIT-SELECTS-HALF-WD))
  (DEF-BIT-FIELD-IN-REG M-INST-ADR 11 0 (PLUS M-INST-BUFFER 
				      LOW-PC-BIT-SELECTS-HALF-WD))
  (DEF-BIT-FIELD-IN-REG M-INST-REGISTER 3 6 (PLUS M-INST-BUFFER 
				      LOW-PC-BIT-SELECTS-HALF-WD))
  (DEF-BIT-FIELD-IN-REG M-INST-DELTA 6 0 (PLUS M-INST-BUFFER 
				      LOW-PC-BIT-SELECTS-HALF-WD))

M-LAST-MICRO-ENTRY	(0)	;HOLDS LAST MICRO ENTRY ADDRESS TRANSFERRED TO
				;IN THE JUMP FIELD.  SOMETIMES CLOBBERED W/O JUMP? 

M-VMA-HELD (0)		;USED BY TRANSPORTER.  NOT CLOBBERED BY PAGE FAULTS,
			; RELOADED FROM VMA BY INTERRUPTS.

(LOCALITY A-MEM)

;;; THE FIRST 32. LOCATIONS SHADOW M-MEMORY. 
;;; THE M-LOCATIONS ARE CONSIDERED PRIMARY.  THE M-LOCATION SHOULD
;;; ALWAYS BE USED IN THE DESTINATION, SINCE WRITING IN M-MEMORY CLOBBERS
;;; A-MEMORY BUT WRITING IN A-MEMORY DOESN'T CLOBBER M-MEMORY.  THE A-LOCATION
;;; CAN BE USED AS A SOURCE WHEN NECESSARY TO GET IT INTO THE CORRECT
;;; SIDE OF THE ADDER OR TO OPERATE ON TWO M-LOCATIONS IN THE SAME INSTRUCTION. 

A-GARBAGE (0)
A-PGF-TEM (0)
A-ZERO	(0)		;CONSTANT 0 USED FOR LDB OPERATIONS-- MUST BE 2
A-MINUS-ONE (-1)	;CONSTANT -1 -- MUST BE 3
A-ZR	(0)		;SEE COMMENTS ON CORRESPONDING M-LOCATIONS
A-A	(0)
A-B	(0)
A-C	(0)
A-D	(0)
A-E	(0)
A-T	(0)
A-R	(0)
A-Q	(0)
A-I	(0)
A-J	(0)
A-S	(0)
A-K	(0)
A-AP	(0)
A-PC	(0)
A-1	(0)
A-2	(0)
A-3	(0)
A-FLAGS
  ( (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
     (PLUS (BYTE-VALUE M-CAR-SYM-MODE 1)		;INITIAL MODE STATE
      (PLUS (BYTE-VALUE M-CAR-NUM-MODE 0)
       (PLUS (BYTE-VALUE M-CDR-SYM-MODE 1)
       	(PLUS (BYTE-VALUE M-CDR-NUM-MODE 0)
	 (PLUS (BYTE-VALUE M-DONT-SWAP-IN 0)
	  (PLUS (BYTE-VALUE M-TRAP-ENABLE 0)
	   (PLUS (BYTE-VALUE M-MAR-MODE 0)
		 (BYTE-VALUE M-PGF-WRITE 0))))))))))

A-PDL-BUFFER-ACTIVE-QS (0)
A-ERROR-SUBSTATUS (0)
A-INST-BUFFER (0)
A-LAST-MICRO-ENTRY (0)
A-VMA-HELD (0)

(LOC 40);SKIP OVER M-CONSTANTS

;FOLLWING VECTOR OF A-MEM LOCATIONS ARE REFERENCED EXTERNALLY.  ORDER HERE MUST
; AGREE WITH A-MEMORY-LOCATION-NAMES IN QCOM


A-VERSION	((PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		       VERSION-NUMBER)) ;VERSION NUMBER FROM SECOND FILE NAME OF SOURCE
A-/#-AREAS	(0)	;COUNT OF AREAS, OK IF HAS TYPE
A-AMCENT	(0)	;NUMBER OF ACTIVE MICRO-CODE ENTRIES, MUST BE TYPELESS
A-CNSADF	(0)	;DEFAULT AREA TO DO CONSES IN, OK IF HAS TYPE

;"SCRATCHPAD" CONSTANTS AND MODES
;INITIALIZED FROM SCRATCHPAD-INIT-AREA ON STARTUP.

A-SCRATCH-PAD-BEG  
A-INITIAL-FEF	(0)	;POINTER TO FEF OF FUNCTION TO START UP IN
A-QTRSTKG	(0)	;POINTER TO TRAP HANDLER STACK-GROUP
A-QCSTKG	(0)	;POINTER TO CURRENT STACK-GROUP
A-QISTKG	(0)	;POINTER TO INITIAL STACK-GROUP
A-SCRATCH-PAD-END 

;STACK-GROUP RELATED
A-SG-STATE	(0)	;SG-STATE Q OF CURRENT STACK GROUP
A-SG-PREVIOUS-STACK-GROUP (0)
A-SG-CALLING-ARGS-POINTER (0)
A-SG-CALLING-ARGS-NUMBER (0)
;A-SG-FOLLOWING-STACK-GROUP (0)

A-TRAP-MICRO-PC (0)	;PC GOTTEN BY TRAP OUT OF OPC S
;A-QTRSTKG	(0)	;POINTER TO TRAP HANDLER STACK-GROUP

;PAGING METERS AND CONTROLS
;FOR NOW, WE JUST HOPE THAT THESE COUNTS DON'T OVERFLOW 24 BITS.
A-FIRST-LEVEL-MAP-RELOADS ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;# FIRST LEVEL MAP RELOADS
A-SECOND-LEVEL-MAP-RELOADS ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;# SECOND LEVEL MAP RELOADS
A-PDL-BUFFER-READ-FAULTS
	((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;# TOOK PGF AND DID READ FROM PDL-BUFFER
A-PDL-BUFFER-WRITE-FAULTS
	 ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;# TOOK PGF AND DID WRITE TO PDL-BUFFER
A-PDL-BUFFER-MEMORY-FAULTS
	((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;# TOOK PGF FOR PDL-BUF, BUT DATA IN MAIN MEM.
A-DISK-PAGE-READ-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;COUNT OF PAGES READ FROM DISK
A-DISK-PAGE-WRITE-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;COUNT OF PAGES WRITTEN TO DISK
A-DISK-ERROR-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))		;COUNT OF RECOVERABLE ERRS
A-FRESH-PAGE-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))		;COUNT OF FRESH PAGES 
						 ;GENERATED IN CORE INSTEAD OF READ FROM DISK
A-AGING-RATE ((BYTE-VALUE Q-DATA-TYPE DTP-FIX) 8)	;NUMBER OF AGE STEPS PER DISK READ
A-PAGE-AGE-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;NUMBER OF TIMES AGER SET AGE TRAP
A-PAGE-FLUSH-COUNT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))	;NUMBER OF TIMES AGE TRAP -> FLUSHABLE

A-MAR-LOW ((BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;CDR CODE MUST BE ZERO!
	   77777777)		;LOWEST ADDRESS MAR IS SET ON, WITH FIXNUM TYPE
A-MAR-HIGH ((BYTE-VALUE Q-DATA-TYPE DTP-FIX)
	    77777776)		;HIGHEST ADDRESS MAR IS SET ON, FIXNUM TYPE (NOT +1)
				;IT'S UNCLEAR HOW THESE GET RELOCATED BY GC,
				;WILL HAVE TO FIX UP LATER.
A-SELF	       ((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL))  ;LAST DTP-INSTANCE, ETC INVOKED
A-METHOD-CLASS ((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL))  ;CLASS IN WHICH CURRENT METHOD FOUND.
;END OF VECTOR AREA

;A-MEM EXTREMELY TEMPORARY WORKING REGISTERS. 
;CLOBBERED BY BOTH PAGE FAULTS AND INTERRUPTS. 
A-TEM1	(0)	;VERY TEMPORARY
A-TEM2	(0)	;VERY TEMPORARY
A-TEM3	(0)	;VERY TEMPORARY

;A-MEM WORKING REGISTERS, CLOBBERED BY INTERRUPTS (BUT NOT BY PAGE FAULTS)
A-TEM	(0)	;NOT CLOBBERED BY ARRAY REF ROUTINES.  USED ONLY BY XFARY. 
		; ALSO USED BY PDL-BUFFER LOADING/DUMPING ROUTINES
A-LCTYP	(0)	;LINEAR-CALL-TYPE DURING QLENTR (NORMAL, LEXPR, FEXPR, ETC)
A-NWADI (0)	;NUMBER WORDS "ADDITIONAL INFORMATION" PUSHED SO FAR
A-TRANS-DATA (0) ;TEMPORARY IN THE TRANSPORTER (SAVES Q BEING TRANSPORTED)

;WORKING REGISTERS CLOBBERED BY PAGE FAULTS
A-PGF-VMA (0)	;PAGE FAULT HANDLER SAVES VMA HERE
A-PGF-WMD (0)	;PAGE FAULT HANDLER SAVES WRITE-MEMORY-DATA HERE
A-PGF-T   (0)	;PAGE FAULT HANDLER SAVES M-T HERE
A-PGF-A   (0)	;PAGE FAULT HANDLER SAVES M-A HERE
A-PGF-B   (0)	;PAGE FAULT HANDLER SAVES M-B HERE

;PAGING VARIABLES AND CONSTANTS
A-PHT-INDEX-MASK ((EVAL (- SIZE-OF-PAGE-TABLE 2))) ;MASK FOR PAGE HASH TBL INDICES
A-FINDCORE-SCAN-POINTER (0)	;PHT INDEX OF LAST PLACE LOOKED AT BY FINDCORE
A-AGING-SCAN-POINTER (0)	;PHT INDEX OF NEXT PLACE AGER WILL LOOK AT
A-DISK-REGS-BASE (37777340)	;UNIBUS ADDRESS 776700
A-DISK-PAGE-MAP-ADDR (37772150)	;UNIBUS ADDRESS 764320 (MAPPING REGISTER 8)
A-DISK-PAGE-ADDR (150000)	;UNIBUS ADDRESS POINTING TO MAPPING REGISTER 8
;A-DISK-OFFSET (0)		;DISK ADDRESS (IN QS, I.E. BLOCKS LSH 7) OF VIRTUAL LOC 0
A-DISK-MAXIMUM (6200000)	;1+ MAXIMUM ALLOWED VIRTUAL ADDRESS TO DISK (80 CYLINDERS)
A-DISK-RUN-LIGHT (37577712)	;LOCATION IN TV BUFFER ILLUMINATED WHEN DISK TRANSFERRING
				;THAT + 2 IS THE COMPLEMENT (FOR EASY COMPARISON)
(ASSIGN DISK-READ-COMMAND 5)	;WHAT TO STORE IN CSR TO START A READ
(ASSIGN DISK-WRITE-COMMAND 7)	;TO START A WRITE

A-TV-PLANE-SELECT  (37777330)	;UNIBUS ADDRESS OF TV-CONSOLE-SELECT-REGISTER
				; (ACTIVE PLANE IS SELECTED BY HIGH BYTE IN 16 BIT WD)
;PARAMETERS OF THE CURRENTLY SELECTED SCREEN (SEE TV-SELECT-SCREEN)
A-TV-CURRENT-SCREEN (0)		;CURRENTLY-SELECTED SCREEN, JUST FOR AN EFFICIENCY HACK
A-TV-SCREEN-BUFFER-ADDRESS (0)	;START ADDRESS OF BUFFER (IN VIRTUAL ADDRESS SPACE)
A-TV-SCREEN-BUFFER-END-ADDRESS (0)	;LAST BUFFER VIRTUAL ADDRESS +1
A-TV-SCREEN-LOCATIONS-PER-LINE (0)	;AMOUNT TO ADD TO ADDRESS TO GET TO NEXT RASTER LINE

;"Q" STORAGE STARTS HERE.. IE THIS CAN "POTENTIALLY" BE RELOCATED DURING A GC

;AREA ORIGIN POINTERS  (THESE ARE VIRTUAL ADDRESSES)
; THESE EXIST IN A-MEMORY ONLY TO SAVE TO ENABLE THEM TO BE REFERENCED
; WITHOUT A MEMORY CYCLE.  THEY ARE IN ORDER OF AREA NUMBER, AND ARE INITIALIZED
; AT UCONS STARTUP (BEG) AND NEVER CHANGED. 
A-V-RESIDENT-SYMBOL-AREA	(0)	;RESIDENT SYM AREA
A-V-SYSTEM-COMMUNICATIONS-AREA	(0)	;MUST BE AT LOC 200
A-V-SCRATCH-PAD-INIT-AREA	(0)	;MUST BE AT LOC 400
A-V-MICRO-CODE-SYMBOL-AREA	(0)	;FIRST 600 LOCS ARE UCODE STARTING ADRS
					; FOR (MACRO-CODE) MISC-INST S 200-777
					;FOLLOWING ARE OTHER RANDOM UCODE ENTRIES. 
A-V-PAGE-TABLE-AREA	(0)
A-V-PHYSICAL-PAGE-AREA-NUMBER (0)
A-V-AREA-ORIGIN		(0)	;AREA-ORIGIN AREA
A-V-AREA-LENGTH		(0)	;AREA-LENGTH AREA
A-V-AREA-MODE-BITS	(0)	;VARIOUS MODES
A-V-AREA-SORTED-BY-ORIGIN (0)
A-V-AREA-NAME		(0)
A-V-AREA-FREE-POINTER	(0)	;AREA-FREE-POINTER AREA
A-V-AREA-PARTIALLY-FREE-PAGE (0)	;AREA-PARTIALLY-FREE-PAGE AREA
A-V-AREA-FREE-PAGE-LIST	(0)	;AREA-FREE-PAGE-LIST AREA
A-V-SUPPORT-ENTRY-VECTOR	(0)
A-V-CONSTANTS-AREA	(0)	;CONSTANTS PAGE (REF'ED IN ADR OF MACRO-CODE)
A-V-MICRO-CODE-ENTRY-AREA	(0)	;MICRO-CODE-ENTRY-AREA
A-V-MICRO-CODE-ENTRY-NAME-AREA	(0)
A-V-MICRO-CODE-ENTRY-/#-ARGS (0)	;MICRO-CODE-ENTRY-#-ARGS
A-V-MICRO-CODE-ENTRY-MAX-PDL-USAGE (0)	;MAXIMUM DEPTH ON PDL BEFORE MICRO TO MACRO CALL
A-V-MICRO-CODE-EXIT-AREA	(0)	;MICRO-CODE-EXIT-AREA

A-V-NIL		((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0)	;POINTER TO NIL
A-V-TRUE	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 5)	;POINTER TO T
A-V-MISC-BASE	(0)	;BASE OF DISPATCH TABLE FOR MISC-INST . 
			; = A-V-MICRO-CODE-SYMBOL-AREA - 200

A-QLARYH	(0)	;POINTER TO HEADER OF LAST ARRAY REFERENCED
;END "Q" STORAGE

A-IPMARK	(0)	;POINTER TO LAST OPEN CALL BLOCK ON IP STACK, (= AP IF NONE)
			; CAUTION! THIS IS A PDL-BUFFER ADDRESS NOT A VIRTUAL ONE. 
A-PDL-BUFFER-VIRTUAL-ADDRESS	(0)	;VIRTUAL ADDRESS OF "HEAD" OF PDL BUFFER
		;IE THAT LOCATION OF PDL BUFFER THAT CORRESPONDS TO LOWEST VIRTUAL MEMORY
		;LOCATION AT THE CURRENT TIME. PURE NUMBER WITH NO GARBAGE IN HIGH BITS
A-PDL-BUFFER-HEAD	(0)	;PDL BUFFER INDEX CONSIDERED TO BE THE "HEAD"
		;IE THAT LOCATION OF PDL BUFFER THAT CORRESPONDS TO LOWEST VIRTUAL 
		;MEMORY LOCATION AT THE CURRENT TIME.  PURE NUMBER, WITH NO GARBAGE IN
		;HIGH BITS. 
A-QLARYL	(0)	;ELEMENT # OF LAST ARRAY REFERENCED (W/ DTP-FIX DATA-TYPE)

;UNTYPED LOCATIONS

A-NARGS	(0)		;NUMBER ARGS FOR FUNCTION CURRENTLY ENTERING (TYPELESS)
A-LNUSV	(0)		;NUMBER UNSUPPLIED VALUES ON LAST MULTIPLE-VALUE CALL
A-QLOCO	(0)		;OFFSET BETWEEN LOCAL BLOCK AND ARG PNTR FOR CURRENT FCTN

;TEMPORARIES IN FUNCTION ENTRY CODE
 ;TO SAVE SPACE, SHARED WITH *THROW TEMPORARIES

;TEMPORARIES IN *CATCH, *THROW, ETC
A-TEMPC			;TEMPORARY PC
A-CATCH-MARK	(0)	;MARK, IE, WHAT MUST BE IN FEF POINTER OF DESIRED FRAME

A-SG-TEM2            ;ANOTHER SG TEMP.
A-ARGS-LEFT		;NUMBER OF ARGS LEFT TO DO
A-CATCH-TAG	(0)	;WHAT MUST BE IN FIRST ARG POSITION OF THAT FRAME

A-SG-TEM 		;TEMPS USED BY SG-CODE.  HOLD INFO OVER SGENT MOSTLY
A-CATCH-COUNT	(0)  ;CAUSES THROWAGE TO STOP, WITH THE CURRENT ACTIVE FRAME
		     ; RETURNING TO THE PREVIOUS FRAME, IF ZERO.  IF NIL, DOESN'T APPLY.
A-SG-TEM1		; CAN'T USE PDL BUFFER FOR THESE SINCE BEING SWAPPED.
A-CATCH-ACTION  (0)  ;IF NON-NIL, CAUSES RETURN TO ERROR SG INSTEAD OF RESUMING
		     ; CURRENT SG AT CONCLUSION OF THROW.

;CONNECTED WITH PDL-BUFFER MANAGEMENT
A-PDL-BUFFER-HIGH-WARNING  (PDL-BUFFER-HIGH-LIMIT)	;GO TO PDL-BUFFER-DUMP IF PUSH
			;FRAME AND M-PDL-BUFFER-ACTIVE-QS GREATER OR EQUAL TO THIS. 
			;NORMALLY STAYS AT PDL-BUFFER-HIGH-LIMIT, BUT WILL BE LESS
			;IF A-PDL-BUFFER-VIRTUAL-ADDRESS WITHIN 2000 OF A-QLPDLH. 
			;(THUS CAUSING XFER TO PDL-BUFFER-DUMP ON PUSH-DOWN-LIST 
			;OVERFLOW). 

;PDL POINTERS AND LIMITS.  INITIALIZED BY STACK-GROUP STUFF
A-QLBNDP	(0)	;POINTER TO LINEAR MODE BIND STACK
A-QLBNDO	(0)	;LOW LIMIT OF LINEAR MODE BINDING AREA  --WILL BE PURE NUMBER
A-QLBNDH	(0)	;HIGH LIMIT OF LINEAR MODE BINDING AREA --WILL BE PURE NUMBER
A-QLPDLO	(0)	;LOW LIMIT OF LINEAR MODE PDL BLOCK     --WILL BE PURE NUMBER
A-QLPDLH	(0)	;HIGH LIMIT OF LINEAR MODE PDL BLOCK    --WILL BE PURE NUMBER

;FIRST LEVEL MAP STUFF

A-SECOND-LEVEL-MAP-REUSE-POINTER	
	(35)		;-> BLOCK OF SECOND LEVEL MAP NEXT TO BE REUSED
A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT
	(0)		;-> LOWEST NUMBERED BLOCK SAFE TO REUSE
;(MODULO 40)
;A-REVERSE-FIRST-LEVEL-MAP	
;	(0)		;FOR EACH BLOCK OF SECOND LEVEL MAP, SAYS WHICH FIRST
;(REPEAT 36 (-1))	;LEVEL MAP WORD POINTS TO THIS BLOCK CURRENTLY. 
;			;IS IN FORM OF A VMA TO ADDRESS THAT 1ST LVL MAP ENTRY. 
;A-REVERSE-FIRST-LEVEL-MAP-INIT-VALUE
;	(-1)	;THIS ONE IS NEVER CHANGED (ENTRY #37)

;;; DISPATCH TABLES

(LOCALITY D-MEM)

(LOC 1777) ;LAST LOCATION IN D-MEMORY MUST BE DROP THROUGH FOR TRANSPORTER TO WORK RIGHT.
	(P-BIT R-BIT)
(END-DISPATCH)

;DISPATCH ON MACRO OP CODE
;INSTRUCTION IN M-INST-BUFFER, M-PC HAS ADDRESS OF NEXT INSTRUCTION, LOW-PC-BIT
;PROPERLY SET UP, AND M-1 HAS DELTA FIELD IN CASE IT'S NEEDED. 
;EFFECTIVE ADDRESS NOT PROCESSED YET, DISPATCH ON QADCM1-QADCM5 TO GET IT.
(START-DISPATCH 4 P-BIT)	;DO CALL XCT NEXT
OPDTB	(QICALL)	;0 CALL
	(QICAL0)	;1 CALL0
	(QIMOVE)	;2 MOVE
	(QICAR)		;3 CAR
	(QICDR)		;4 CDR
	(QICADR)	;5 CADR
	(QICDDR)	;6 CDDR
	(QICDAR)	;7 CDAR
	(QICAAR)	;10 CAAR
	(QIND1)		;11 ND1
	(QIND2)		;12 ND2
	(QIND3)		;13 ND3
	(QIBRN)		;14 BRANCH
	(MISC)		;15 MISC
	(TRAP)		;16 UNUSED
	(TRAP)		;17 UNUSED
(END-DISPATCH)

(START-DISPATCH 3 0)
;DESTINATION CODE DISPATCH, VALUE IN M-T
;EACH USE OF THIS DISPATCH TABLE MUST BE FOLLOWED BY A PUSH OF M-T WITH CDR-NEXT SET
QMDTBD	(R-BIT INHIBIT-XCT-NEXT-BIT)		;IGNORE (POPJ IMMEDIATELY)
	(R-BIT)					;TO STACK
	(R-BIT)					;TO NEXT
	(QMDDL INHIBIT-XCT-NEXT-BIT)		;TO LAST
	(QMDDR INHIBIT-XCT-NEXT-BIT)		;TO RETURN
	(R-BIT)					;TO NEXT "QUOTE =1" QUOTE BIT FEATURE LOSES
	(QMDDLQ INHIBIT-XCT-NEXT-BIT)		;TO LAST "QUOTE =1"        ..
	(QMDDNL INHIBIT-XCT-NEXT-BIT)		;TO NEXT LIST
(END-DISPATCH)

;DISPATCH ON REG FIELD FOR COMPUTE EFF ADR, USUAL CASE.
;WILL FETCH OPERAND INTO M-T
(START-DISPATCH 3 P-BIT)  ;DOES CALL-XCT-NEXT
QADCM1	(QAFE0)		;FEF
	(QAFE)		;FEF+100
	(QAFE)		;FEF+200
	(QAFE)		;FEF+300
	(QAQT)		;CONSTANTS PAGE
	(QADLOC)	;LOCAL BLOCK
	(QADARG)	;ARG POINTER
	(QADPDL)	;PDL
(END-DISPATCH)

;THIS ONE IS THE SAME EXCEPT THAT IT DOESN'T XCT-NEXT.  USEFUL MAINLY TO SPEED UP NON-DEST.
(START-DISPATCH 3 (PLUS P-BIT INHIBIT-XCT-NEXT-BIT))
QADCM5	(QAFE0)		;FEF
	(QAFE)		;FEF+100
	(QAFE)		;FEF+200
	(QAFE)		;FEF+300
	(QAQT)		;CONSTANTS PAGE
	(QADLOC)	;LOCAL BLOCK
	(QADARG)	;ARG POINTER
	(QADPDL)	;PDL
(END-DISPATCH)

(START-DISPATCH 3 0)	;DOES XCT NEXT
;DISPATCH ON REGISTER FIELD FOR STORE CYCLE, VALUE IN M-T, DELTA IN M-1.
;USE THIS ONE IF A READ CYCLE HASN'T BEEN DONE YET
QADCM2	(QSTFE)		;FEF
	(QSTFE)		;FEF+100
	(QSTFE)		;FEF+200
	(QSTFE)		;FEF+300
	(P-BIT ILLOP)	;CONSTANTS PAGE (ILLEGAL)
	(QSTLOC)	;LOCAL BLOCK
	(QSTARG)	;ARGUMENT BLOCK
	(P-BIT ILLOP)	;PDL (ILLEGAL)
(END-DISPATCH)

(START-DISPATCH 3 0)	;DOES XCT NEXT
;DISPATCH ON REGISTER FIELD FOR STORE CYCLE, VALUE IN M-T, DELTA IN M-1.
;USE THIS ONE IF YOU ALREADY DID A READ CYCLE AND M-VMA-HELD IS STILL SET UP.
QADCM4	(QSTFE1)	;FEF
	(QSTFE1)	;FEF+100
	(QSTFE1)	;FEF+200
	(QSTFE1)	;FEF+300
	(P-BIT ILLOP)	;CONSTANTS PAGE (ILLEGAL)
	(QSTLOC)	;LOCAL BLOCK
	(QSTARG)	;ARGUMENT BLOCK
	(P-BIT ILLOP)	;PDL (ILLEGAL)
(END-DISPATCH)

(START-DISPATCH 3 0) ;JUMP-XCT-NEXT
;DISPATCH ON REGISTER FIELD FOR OPERATIONS WHICH REQUIRE A TRULY EFFECTIVE ADDRESS
;IN THE VMA.  IF FEF, DO THAT.  OTHERWISE, CONVERT PDL BUFFER ADDRESS.
;POPJS WITH A LOCATIVE EFF ADDR ON THE PDL.
;THIS IS ONLY USED BY THE PUSH-E INSTRUCTION.
QADCM3	(QEAFE0)	;FEF
	(QEAFE)		;FEF+100
	(QEAFE)		;FEF+200
	(QEAFE)		;FEF+300
	(P-BIT ILLOP)	;CONSTANTS PAGE (ILLEGAL)
	(QVMALCL)	;LOCAL BLOCK
	(QVMAARG)	;ARGUMENT BLOCK
	(P-BIT ILLOP)	;PDL (ILLEGAL)
(END-DISPATCH)

;DISPATCH FOR GETTING EFFECTIVE ADDRESS FOR BIND.
;THIS HAS TO HAVE A SPECIAL KLUDGE FOR DOING EXACTLY ONE LEVEL
;OF INDIRECTION ON DATA IN THE FEF.
(START-DISPATCH 3 P-BIT) ;CALL-XCT-NEXT
QADCM6	(QBAFE0)	;FEF
	(QBAFE)		;FEF+100
	(QBAFE)		;FEF+200
	(QBAFE)		;FEF+300
	(ILLOP)		;CONSTANTS PAGE (ILLEGAL)
	(QVMALCL)	;LOCAL BLOCK
	(QVMAARG)	;ARGUMENT BLOCK
	(ILLOP)		;PDL (ILLEGAL)
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE.  DROPS THROUGH IN EITHER CASE BUT SKIPS IF ATOM. 
;AN ATOM IS ANYTHING OTHER THAN A LIST.
SKIP-IF-ATOM	
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FORWARD
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(P-BIT R-BIT 0)				;LIST -- don't skip
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;U CODE ENTRY
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;FEF
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE.  DROPS THROUGH IN EITHER CASE BUT SKIPS IF LIST.
SKIP-IF-LIST	
	(P-BIT R-BIT 0)			;TRAP
	(P-BIT R-BIT 0)			;NULL
	(P-BIT R-BIT 0)			;FREE
	(P-BIT R-BIT 0)			;SYMBOL
	(P-BIT R-BIT 0)			;SYMBOL-HEADER
	(P-BIT R-BIT 0)			;FIX
	(P-BIT R-BIT 0)			;EXTENDED NUMBER
	(P-BIT R-BIT 0)			;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT R-BIT 0)			;FORWARD
	(P-BIT R-BIT 0)			;LOCATIVE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;LIST
	(P-BIT R-BIT 0)			;U CODE ENTRY
	(P-BIT R-BIT 0)			;FEF
	(P-BIT R-BIT 0)			;ARRAY-POINTER
	(P-BIT R-BIT 0)			;ARRAY-HEADER
	(P-BIT R-BIT 0)			;STACK-GROUP
	(P-BIT R-BIT 0)			;CLOSURE [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;SMALL-FLONUM 
	(P-BIT R-BIT 0)			;SELECT-METHOD [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;INSTANCE [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;INSTANCE-HEADER [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;ENTITY [NOT A LIST FOR PURPOSES OF THIS]
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA-TYPE OF FUNCTION GETTING CALLED (AT QMRCL OR MMCALL). 
;THE FUNCTION MUST BE IN BOTH M-A AND C-PDL-BUFFER-INDEX
;JUMPS TO APPROPRIATE CODE TO CALL THAT KIND OF FUNCTION, OR INTERPRETER TRAP. 
; INHIBIT-XCT-NEXT-BIT IS OFF IF A "LEAVE" IS INDICATED. 
;  A "LEAVE" IS INDICATED UNLESS
;	(1) A LOOP AROUND TYPE OPERATION IS PLANNED, IE SYM, INVZ
;	(2) DTP-ARRAY-POINTER.  HERE A LEAVE IS UNNECESSARY BECAUSE THE LINEAR PDL STATE
;		ISNT REALLY GOING TO GET CLOBBERED. 
;THIS DISPATCH IS DESIGNED TO BE USED FROM BOTH QMRCL AND MMCAL5. 

D-QMRCL	(P-BIT ILLOP)			;TRAP
	(P-BIT ILLOP)			;NULL
	(P-BIT ILLOP)			;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT QMRCL1)	;SYMBOL
	(P-BIT ILLOP)				;SYMBOL-HEADER
	(P-BIT ILLOP)			;FIX
	(P-BIT ILLOP)			;EXTENDED NUMBER
	(P-BIT ILLOP)			;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FORWARD
	(INTP1)				;LOCATIVE
	(INTP1)				;LIST
	(QME1)				;U CODE ENTRY
	(QLENTR)			;FEF
	(INHIBIT-XCT-NEXT-BIT QARYR)	;ARRAY-POINTER
	(INTP1)				;ARRAY-HEADER
	(SG-CALL)			;STACK-GROUP
	(QCLS)				;CLOSURE
	(P-BIT ILLOP)			;SMALL-FLONUM 
	(CALL-SELECT-METHOD)		;SELECT-METHOD
	(P-BIT ILLOP)			;INSTANCE (TEMP)***
	(P-BIT ILLOP)			;INSTANCE-HEADER
	(P-BIT ILLOP)			;ENTITY (TEMP)***
 (REPEAT NQZUSD (INTP1))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE BEFORE TAKING CAR
;IF DROPS THROUGH, NORMAL LIST-TYPE CAR
CAR-PRE-DISPATCH 
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT QCARSY)		;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT QCARNM)		;FIX
	(INHIBIT-XCT-NEXT-BIT QCARNM)		;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FORWARD
	(P-BIT R-BIT)				;LOCATIVE
	(P-BIT R-BIT)				;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT R-BIT)				;CLOSURE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(P-BIT R-BIT)				;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON INPUT DATA TYPE WHEN TAKING CDR
;DROP THROUGH IF NORMAL LIST-TYPE CDR
CDR-PRE-DISPATCH
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT QCDRSY)		;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT QCDRNM)		;FIX
	(INHIBIT-XCT-NEXT-BIT QCDRNM)		;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FORWARD
	(INHIBIT-XCT-NEXT-BIT QCAR3)		;LOCATIVE.  NOTE CAR!!
	(P-BIT R-BIT)				;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT R-BIT)				;FRAME (LEGAL ???)
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT R-BIT)				;CLOSURE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(P-BIT R-BIT)				;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 2 0)	;MAYBE DOES XCT-NEXT
;DISPATCH ON CDR-CODE WHEN TAKING CDR
;POPJ-XCT-NEXT IF CDR-NEXT (PROBABLY MOST FREQUENT CASE)
CDR-CDR-DISPATCH 
	(INHIBIT-XCT-NEXT-BIT CDR-FULL-NODE)	;FULL-NODE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CDR NOT
	(INHIBIT-XCT-NEXT-BIT CDR-IS-NIL)	;CDR NIL
	(R-BIT)					;CDR NEXT
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CAR-SYM-MODE WHEN TAKING CAR OF SYM
CAR-SYM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(QCASE1)	;ERROR EXCEPT (CAR NIL) = NIL
	(XFALSE)	;NIL
	(QCAR3)		;"WHATEVER IT IS"
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CAR-NUM-MODE WHEN TAKING CAR OF NUM
CAR-NUM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(XFALSE)	;NIL
	(QCAR3)		;"WHATEVER IT IS"
	(P-BIT TRAP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CDR-SYM-MODE WHEN TAKING CDR OF SYM
CDR-SYM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(QCASE1)	;ERROR EXCEPT (CDR NIL) = NIL
	(XFALSE)	;NIL
	(QCDPRP)	;PROPERTY LIST
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CDR-NUM-MODE WHEN TAKING CDR OF NUM
CDR-NUM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(XFALSE)	;NIL
	(QCDR3)		;"WHATEVER IT IS"
	(P-BIT TRAP)
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACA OF SYMBOL
RPLACA-SYM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ALSO ERROR IF (CAR NIL) = NIL
	(P-BIT TRAP)	;OR IF (CAR SYM) = NIL
	(QRAR3)		;SMASH P-STRING POINTER
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACA OF NUMBER
RPLACA-NUM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(QRAR3)		;SMASH "WHATEVER IT IS"
	(P-BIT TRAP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACD OF SYM
RPLACD-SYM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(QRDPRP)	;SMASH PROP LIST
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACD OF NUM
RPLACD-NUM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(QRAR3)		;SMASH "WHATEVER IT IS"
	(P-BIT TRAP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 2 0)	;DOES XCT-NEXT
;DISPATCH ON CDR-CODE WHEN DOING RPLACD
RPLACD-CDR-DISPATCH
	(RPLACD-FULL-NODE)	;FULL NODE
	(P-BIT TRAP)		;CDR NOT
	(RPLACD-NEXT-NIL)	;CDR NIL
	(RPLACD-CDR-NEXT)	;CDR NEXT
(END-DISPATCH)

(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)
;DISP ON DATA TYPE OF POINTER-TO-SMASH-CONTENTS-OF WHEN DOING RPLACA
QRACDT	(P-BIT TRAP)	;TRAP
	(P-BIT TRAP)	;NULL
	(P-BIT TRAP)	;FREE
	(QRASYM)	;SYMBOL
	(P-BIT TRAP)	;SYMBOL-HEADER
	(QRANUM)	;FIX
	(QRANUM)	;EXTENDED NUMBER
	(P-BIT TRAP)	;HEADER
	(P-BIT TRAP)	;GC-FORWARD
	(P-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT TRAP)	;FORWARD
	(QRAR3)		;LOCATIVE
	(QRAR3)		;LIST
	(P-BIT TRAP)	;U CODE ENTRY
	(QRAR3)		;FRAME
	(P-BIT TRAP)	;ARRAY-POINTER
	(P-BIT TRAP)	;ARRAY-HEADER
	(P-BIT TRAP)	;STACK-GROUP
	(QRAR3)		;CLOSURE
	(P-BIT TRAP)	;SMALL-FLONUM 
	(QRAR3)		;SELECT-METHOD
	(P-BIT TRAP)	;INSTANCE
	(P-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DATA TYPE OF POINTER-TO-SMASH-CONTENTS-OF WHEN DOING RPLACD
QRDCDT	(P-BIT TRAP)	;TRAP
	(P-BIT TRAP)	;NULL
	(P-BIT TRAP)	;FREE
	(QRDRSY)	;SYMBOL
	(P-BIT TRAP)	;SYMBOL-HEADER
	(QRDRNM)	;FIX
	(QRDRNM)	;EXTENDED NUMBER
	(P-BIT TRAP)	;HEADER
	(P-BIT TRAP)	;GC-FORWARD
	(P-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT TRAP)	;FORWARD
	(QRAR3)		;LOCATIVE. NOTE CAR!!
	(QRDR3)		;LIST
	(P-BIT TRAP)	;U CODE ENTRY
	(QRDR3)		;FRAME
	(P-BIT TRAP)	;ARRAY-POINTER
	(P-BIT TRAP)	;ARRAY-HEADER
	(P-BIT TRAP)	;STACK-GROUP
	(P-BIT TRAP)	;CLOSURE
	(P-BIT TRAP)	;SMALL-FLONUM 
	(QRDR3)		;SELECT-METHOD
	(P-BIT TRAP)	;INSTANCE
	(P-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;ILLOP UNLESS DATA TYPE IS FIX -- SEE ALSO TRAP-UNLESS-FIX BELOW
ERROR-UNLESS-FIX
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL-HEADER
	(R-BIT)		;FIX  P-BIT AND R-BIT CAUSE DISPATCH TO BE A NO-OP
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTENDED NUMBER - IS THIS RIGHT?
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;FORWARD
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;LIST
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;FEF
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;TRAP UNLESS DATA TYPE IS FIX.  HAVING THIS SEPARATE FROM ILLOP-UNLESS-FIX
; JUST FOR CONVENIENCE IN DEBUGGING.  THIS COULD BE FLUSHED IF D-MEM GETS TIGHT.
TRAP-UNLESS-FIX
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(R-BIT)		;FIX  P-BIT AND R-BIT CAUSE DISPATCH TO BE A NO-OP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTENDED NUMBER - IS THIS RIGHT?
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;ERROR IF DATA-TYPE IS CAN NOT BE LEGAL IN FUNCTION CONTEXT
ILLOP-ON-BAD-FUNCTION-DATA-TYPE
	(ILLOP)			;TRAP
	(ILLOP)			;NULL
	(ILLOP)			;FREE
	(R-BIT)			;SYMBOL
	(ILLOP)			;SYMBOL-HEADER
	(ILLOP)			;FIX
	(ILLOP)			;EXTENDED NUMBER
	(ILLOP)			;HEADER
	(ILLOP)			;GC-FORWARD
	(ILLOP)			;EXTERNAL-VALUE-CELL-POINTER
	(ILLOP)			;ONE-Q-FORWARD
	(R-BIT)			;FORWARD
	(R-BIT)			;LOCATIVE
	(R-BIT)			;LIST, P-BIT+R-BIT = NO-OP
	(R-BIT)			;U CODE ENTRY
	(R-BIT)			;FEF
	(R-BIT)			;ARRAY-POINTER
	(ILLOP)			;ARRAY-HEADER
	(R-BIT)			;STACK-GROUP
	(R-BIT)			;CLOSURE
	(ILLOP)			;SMALL-FLONUM 
	(R-BIT)			;SELECT-METHOD
	(ILLOP)			;INSTANCE
	(ILLOP)			;INSTANCE-HEADER
	(ILLOP)			;ENTITY
 (REPEAT NQZUSD (ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT);DOES CALL-XCT-NEXT
;DISPATCH ON ARRAY TYPE WHEN REF ING ARRAY
ARRAY-TYPE-REF-DISPATCH
	(TRAP)
	(QB1RY)		;BIT ARRAY
	(QB2RY)		;2 BIT ARRAY
	(QB4RY)		;4 BIT ARRAY
	(QBARY)		;8 BIT ARRAY
	(QB16RY)	;16 BIT ARRAY
	(QB32RY)	;32 BIT ARRAY
	(QQARY)		;Q ARRAY
	(QQARY)		;LIST Q ARRAY
	(QBARY)		;STRING ARRAY
	(QQARY)		;STACK-GROUP HEAD
	(QQARY)		;STACK-SEGMENT
	(QTVARY)	;TV BUFFER
	(QQARY)		;REG-PDL
	(QBTPXL)	;TV-BUFFER-PIXEL 
 (REPEAT NATUSD (TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0)	;DOES XCT-NEXT
;DISPATCH ON ARRAY TYPE WHEN STORING INTO ARRAY
ARRAY-TYPE-STORE-DISPATCH
	(P-BIT TRAP)
	(QS1RY)		;BIT ARRAY
	(QS2RY)		;2 BIT ARRAY
	(QS4RY)		;4 BIT ARRAY
	(QSBARY)	;8 BIT ARRAY
	(QS16RY)	;16 BIT ARRAY
	(QS32RY)	;32 BIT ARRAY
	(QS32RY)	;Q ARRAY
	(QSQARY)	;LIST Q ARRAY
	(QSBARY)	;BYTE ARRAY
	(QS32RY)	;STACK-GROUP HEAD
	(QS32RY)	;STACK-SEGMENT
	(QSTVRY)	;TV BUFFER
	(QS32RY)	;REG-PDL
	(QSTPXL)	;TV-BUFFER-PIXEL 
 (REPEAT NATUSD (P-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 (PLUS P-BIT INHIBIT-XCT-NEXT-BIT))
;DISPATCH ON ARRAY TYPE AT XFARY
ARRAY-TYPE-FILL-DISPATCH 
	(TRAP)
	(QS1RY)		;BIT ARRAY
	(QS2RY)		;2
	(QS4RY)		;4
	(QSBARY)	;8
	(QS16RY)	;16
	(QS32RY)	;32
	(QSQARY)	;Q ARRAY
	(XFALAR)	;LIST -- SPECIAL HACKERY WITH CDR CODES TO EXTEND "LIST"
	(QSBARY)	;BYTE
	(QSQARY)	;STACK-GROUP HEAD
	(QSQARY)	;STACK-SEGMENT
	(QSTVRY)	;TV-BUFFER
	(QSQARY)	;REG-PDL
	(QSTPXL)	;TV-BUFFER-PIXEL 
 (REPEAT NATUSD (TRAP))
(END-DISPATCH)

;DISPATCH ON "DESTINATION" FIELD OF BRANCH
(START-DISPATCH 3 0)	;DOES XCT-NEXT
BRDTAB	(QBRALW)
	(QBRNL)
	(QBRNNL)
	(QBRNLP)
	(QBRNNP)
	(QBRAT)
	(QBRNAT)
	(ILLOP)
(END-DISPATCH)

;DISPATCH ON ADDITIONAL INFO TYPE AT QLEAI3
(START-DISPATCH 3 0)	;USUALLY R-P NOOP
D-QLEAI3
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;0 ERR
	(INHIBIT-XCT-NEXT-BIT QLEAI4)	;1 MULT RET
	(INHIBIT-XCT-NEXT-BIT QLEAI4)	;2 RESTART PC
	(R-BIT P-BIT)			;3 FEXPR CALL
	(R-BIT P-BIT)			;4 LEXPR CALL
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;5 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;6 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;7 ERR
(END-DISPATCH)

;DISPATCH ON TYPE OF ARG, ARG IS SUPPLIED
(START-DISPATCH 3 0)
QREDT1	(QBRQA)		;REQUIRED ARG
	(QBROP1)	;OPTIONAL ARG
	(QBRA)		;REST ARG
	(QBTMA2)	;AUX VAR, (HAVE REACHED END OF ARG SECT, WITH MORE ARGS)
	(QBTMA2)	;FREE,      ..
	(QBTMA2)	;INTERNAL,  ..
	(QBTMA2)	;INTERNAL-AUX,  ..
	(P-BIT ILLOP)	;UNUSED
(END-DISPATCH)

;DISPATCH ON INITIALIZING OPTION, OPT ARG HAS BEEN SUPPLIED
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
QBOPNP	(QBRQA)		;NONE
	(QBRQA)		;NIL
	(QBOSP)		;INIT TO POINTER (SPACE PAST)
	(QBOSP)		;INIT TO C(POINTER) (LIKEWISE)
	(QBOASA)	;ALT STARTING ADR, START THERE TO AVOID CLOBBERING IT
	(QBRQA)		;INIT BY COMPILED CODE
	(QBOSP)		;INIT TO C(EFF ADR)
	(QBRQA)		;INIT TO SELF
(END-DISPATCH)

;DISPATCH ON TYPE OF NEXT B-D-L ENTRY AFTER ALL PRESENT ARGS HAVE BEEN PROCESSED
(START-DISPATCH 3 0)	;DOES XCT-NEXT
QBDT2	(QBTFA1)	;THIS WAS A REQUIRED ARG, BARF
	(QBOPT1)	;THIS WAS AN OPT ARG, NOT PRESENT
	(QBRA1)		;THIS WAS A REST ARG, SET IT TO NIL
	(QBDAUX)	;AUX VAR, REALLY END OF ARG PART OF B-D-L
	(QBDFRE)	;FREE,     ..
	(QBDINT)	;INTERNAL, ..
	(QBDINT)	;INTERNAL-AUX, ..
	(P-BIT ILLOP)
(END-DISPATCH)

;DISPATCH ON INTIALIZING OPTION, GOING TO INITIALIZE VARIABLE
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
QBOPTT	(QBOPT3)	;NONE
	(QBOPT2)	;NIL
	(QBOPNR)	;INIT TO POINTER
	(QBOCPT)	;INIT TO C(POINTER)
	(QBOPT5)	;OPT ARG, ALT SA
			;ARG NOT PRESENT, SO LEAVE STARTING ADR ALONE 
			;AND LET CODE INIT IT
	(QBOPT3)	;INIT BY COMPILED CODE
	(QBOEFF)	;INIT TO CONTENTS OF "EFFECTIVE ADDRESS"
	(QBOPT3)	;INIT TO SELF (SAME AS NONE)
(END-DISPATCH)

;DISPATCH ON DESIRED DATA TYPE FOR ARG
(START-DISPATCH 4 0)	;DOES NXT INSTR
QBDDT	(R-BIT P-BIT)	;0 NO DATA TYPE CHECKING
	(QDTN)		;1 NUMBER
	(QDTFXN)	;2 FIXNUM
	(QDTSYM)	;3 SYMBOL
	(QDTATM)	;4 ATOM
	(QDTLST)	;5 LIST
	(QDTFRM)	;6 FRAME
(REPEAT 11 (P-BIT ILLOP))	;UNDEF CODE
(END-DISPATCH)

;DISPATCH ON DESIRED EVAL/QUOTE STATUS FOR ARG
;(START-DISPATCH 2 0)	;DOES NXT INSTR
;QBEQC	(R-BIT P-BIT)	;0 NO CHECKING
;	(QBEQE)		;1 DESIRED EVALUATED
;	(QBEQQ)		;2 DESIRED QUOTED
;	(QBEQQ)		;3 DESIRED BROKEN-OFF
;(END-DISPATCH)

;DISPATCH ON REGISTER FIELD OF EFF ADDR FOR INITIALIZING AUX VAR/OPT ARG
(START-DISPATCH 3 0)	;DOES NXT INSTR
QBOFDT	(QBFE0)
	(QBFE)
	(QBFE)
	(QBFE)
	(QBQT)
	(QBDLOC)
	(QBDARG)
	(P-BIT ILLOP)	;PDL ILLEGAL
(END-DISPATCH)

(START-DISPATCH 3 0)  ;WANT XCT-NEXT
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-1 INSTRUCTIONS
;OPERAND FETCHED INTO M-T, VMA -> OPERAND
D-ND1	(ILLOP P-BIT)
	(QIADD)
	(QISUB)
	(QIMUL)
	(QIDIV)
	(QIAND)
	(QIXOR)
	(QIIOR)
(END-DISPATCH)

(START-DISPATCH 3 0)	;WANT XCT-NEXT
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-2 INSTRUCTIONS
;OPERAND FETCHED INTO M-T, VMA -> OPERAND
D-ND2	(QIEQL)
	(QIGRP)
	(QILSP)
	(QIEQ)
	(QISCDR)
	(QISCDDR)
	(QISP1)
	(QISM1)
(END-DISPATCH)

(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-3 INSTRUCTIONS
;OPERAND NOT FETCHED YET
D-ND3	(QIBND)
	(QIBNDN)
	(QIBNDP)
	(QISETN)
	(QISETZ)
	(QIPSHE)
	(QIMVM)
	(QIPOP)
(END-DISPATCH)

;DISPATCH ON RETURN STORING OPTION IN MVR (ADI IN PDL BUFFER)
(START-DISPATCH 3 0)	;DOES NXT INSTR
D-MVR	(P-BIT ILLOP)	;ERROR
	(MVRB)		;BLOCK
	(P-BIT ILLOP)	;STORE INTO LIST
	(MVRC)		;CONS UP LIST
	(MVRI)		;INDIRECT POINTER
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
(END-DISPATCH)

;DISPATCH ON RETURN STORING OPTION IN MVR (ADI NOT KNOWN TO BE IN PDL BUFFER)
(START-DISPATCH 3 0)	;DOES NXT INSTR
D-MVRV	(P-BIT ILLOP)	;ERROR
	(MVRBV)		;BLOCK
	(P-BIT ILLOP)	;STORE INTO LIST
	(MVRCV)		;CONS UP LIST
	(MVRIV)		;INDIRECT POINTER
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;TRAP UNLESS DATA TYPE IS SYM
TRAP-UNLESS-SYM
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(R-BIT)				;SYM  P-BIT & R-BIT CAUSE DISPATCH TO BE A NO-OP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FIX
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTENDED NUMBER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0) ;DOES XCT-NEXT UNLESS ILLOPS
;POPJ IF DATA TYPE IS NOT NUMERIC
POPJ-IF-NOT-NUMBER 
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(R-BIT)					;NULL, POPJ
	(R-BIT)					;FREE, POPJ
	(R-BIT)					;SYM, POPJ
	(R-BIT)					;SYMBOL-HEADER, POPJ
	(P-BIT R-BIT)				;FIX, FALL-THROUGH
	(P-BIT R-BIT)				;EXTENDED NUMBER, FALL-THROUGH
	(R-BIT)					;HEADER, POPJ
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FORWARD
	(R-BIT)					;LOCATIVE, POPJ
	(R-BIT)					;LIST, POPJ
	(R-BIT)					;U CODE ENTRY, POPJ
	(R-BIT)					;FEF, POPJ 
	(R-BIT)					;ARRAY-POINTER, POPJ
	(R-BIT)					;ARRAY-HEADER, POPJ
	(R-BIT)					;STACK-GROUP, POPJ
	(R-BIT)					;CLOSURE, POPJ
	(P-BIT R-BIT)				;SMALL-FLONUM, FALL-THROUGH
	(R-BIT)					;SELECT-METHOD, POPJ
	(R-BIT)					;INSTANCE, POPJ
	(R-BIT)					;INSTANCE-HEADER, POPJ
	(R-BIT)					;ENTITY, POPJ
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)  ;INHIBIT-XCT-NEXT-BIT UNLESS CANT FIGURE IT OUT 
		      ; (IE INTERPRETER TRAP)
XARGI-DISPATCH
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(R-BIT)					;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(XARGI3 INHIBIT-XCT-NEXT-BIT)		;SYM, REPLACE WITH FCTN CELL 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER	
	(R-BIT)					;FIX
	(R-BIT)					;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FORWARD
	(R-BIT)					;LOCATIVE
	(R-BIT)					;LIST, (GO TO INTERPRETER)
	(XAGUE1 INHIBIT-XCT-NEXT-BIT)		;U CODE ENTRY
	(XAGM1 INHIBIT-XCT-NEXT-BIT)		;FEF, RETURN FAST OPT Q
	(XAGAR1 INHIBIT-XCT-NEXT-BIT)		;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(XAGISG INHIBIT-XCT-NEXT-BIT)		;STACK-GROUP
	(XAGICL INHIBIT-XCT-NEXT-BIT)		;CLOSURE
	(R-BIT)					;SMALL-FLONUM
	(R-BIT)					;SELECT-METHOD.  CAN'T SAY WITHOUT KEY,
						; SO BE CONSERVATIVE.
	(R-BIT)					;INSTANCE
	(R-BIT)					;INSTANCE-HEADER
	(R-BIT)					;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

;DISPATCH ON FUNCTION TYPE WHEN RETURNING FROM QMEX1
(START-DISPATCH 5 0)	;XCT-NEXT UNLESS ILLOP
QMXRT	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(QMMRL)					;LIST
	(QMMR2)					;UCODE-ENTRY
	(QMEXF)					;FEF
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

;DISPATCH ON FUNCTION TYPE WHEN RETURNING FROM QBARY2
(START-DISPATCH 5 0)		;XCT-NEXT UNLESS ILLOP
QMXRT1	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LIST
	(QBARY2)				;UCODE ENTRY
	(QBARY1)				;FEF
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON AREA FREE-STORAGE MODE TO ROUTINE TO ALLOCATE 2Q S FROM AREA
AREA-FS-MODE-DISP-2Q
	(P-BIT ILLOP)		;ERROR
	(IA2QL)			;LINEARLY ADVANCING
	;(IA2QQ)		;Q ALLOCATED
	(P-BIT ILLOP)		;Q ALLOCATED
	(P-BIT ILLOP)		;PAGE ALLOCATED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
(END-DISPATCH)

(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON AREA FREE-STORAGE MODE TO ROUTINE TO ALLOCATE A BLOCK OF Q S FROM AREA
AREA-FS-MODE-DISP-BLOCK
	(P-BIT ILLOP)		;ERROR
	(IABL)			;LINEARLY ADVANCING
	(P-BIT ILLOP)		;Q ALLOCATED ;FOR NOW. FOR EVER?
;	(IABQ)			;Q ALLOCATED
	(P-BIT ILLOP)		;PAGE ALLOCATED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
	(P-BIT ILLOP)		;UNUSED
(END-DISPATCH)

(START-DISPATCH 6 P-BIT)	;TRANSPORTER DISPATCH ON DATA TYPE AND MAP BIT
;EITHER DROPS THROUGH (P-R) OR CALLS (P-N) MAGIC ROUTINE.
D-TRANSPORT
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;0 TRAP
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 TRAP
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;0 NULL
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 NULL
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;0 FREE
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 FREE
	(R-BIT)					;0 SYMBOL
	(R-BIT)					;1 SYMBOL
	(R-BIT)					;0 SYMBOL-HEADER
	(R-BIT)					;1 SYMBOL-HEADER
	(R-BIT)					;0 FIX
	(R-BIT)					;1 FIX
	(R-BIT)					;0 EXTENDED-NUMBER
	(R-BIT)					;1 EXTENDED-NUMBER
	(R-BIT)					;0 HEADER
	(R-BIT)					;1 HEADER
	(INHIBIT-XCT-NEXT-BIT ILLOP)		;0 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT ILLOP)		;1 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT TRANS-EVCP)	;0 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRANS-EVCP)	;1 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRANS-OQF)	;0 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-OQF)	;1 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-FWD)	;0 FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-FWD)	;1 FORWARD
	(R-BIT)					;0 LOCATIVE
	(R-BIT)					;1 LOCATIVE
	(R-BIT)					;0 LIST
	(R-BIT)					;1 LIST
	(R-BIT)					;0 U CODE ENTRY
	(R-BIT)					;1 U CODE ENTRY
	(R-BIT)					;0 FEF-POINTER
	(R-BIT)					;1 FEF-POINTER
	(R-BIT)					;0 ARRAY-POINTER
	(R-BIT)					;1 ARRAY-POINTER
	(R-BIT)					;0 ARRAY-HEADER
	(R-BIT)					;1 ARRAY-HEADER
	(R-BIT)					;0 STACK-GROUP
	(R-BIT)					;1 STACK-GROUP
	(R-BIT)					;0 CLOSURE
	(R-BIT)					;1 CLOSURE
	(R-BIT)					;0 SMALL-FLONUM
	(R-BIT)					;1 SMALL-FLONUM
	(R-BIT)					;0 SELECT-METHOD
	(R-BIT)					;1 SELECT-METHOD
	(R-BIT)					;0 INSTANCE
	(R-BIT)					;1 INSTANCE
	(R-BIT)					;0 INSTANCE-HEADER
	(R-BIT)					;1 INSTANCE-HEADER
	(R-BIT)					;0 ENTITY
	(R-BIT)					;1 ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRANS-TRAP))
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRANS-TRAP))
(END-DISPATCH)

;;; INITIALIZATION

(LOCALITY I-MEM)

ZERO	(JUMP ZERO HALT-CONS)		;WILD TRANSFER TO ZERO

BEG	((M-ZERO) SETZ)				;DON'T GET SCREWED BY CLOBBERED LOC 1
	((M-DONT-SWAP-IN) DPB M-ZERO A-FLAGS)	;DON'T GET SCREWED IF THIS CLOBBERED
	((A-TV-CURRENT-SCREEN) SETZ)
	(CALL INITIAL-MAP)			;SET UP MAP
	((VMA) (BYTE-FIELD 8 0) (M-CONSTANT -1)) ;377 ;SCRATCH-PAD-INIT-AREA MINUS ONE
	((M-K) (A-CONSTANT (A-MEM-LOC A-SCRATCH-PAD-BEG))) ;FIRST A MEM LOC TO BLT INTO
BEG00	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((OA-REG-LOW) DPB M-K OAL-DEST A-ZERO)	;DESTINATION
	((A-GARBAGE) READ-MEMORY-DATA)
	(JUMP-EQUAL M-K (A-CONSTANT (A-MEM-LOC A-SCRATCH-PAD-END)) BEG01)
	(JUMP-XCT-NEXT BEG00)
       ((M-K) ADD M-K (A-CONSTANT 1))

BEG01	((VMA-START-READ) (A-CONSTANT 431))	;FETCH MISCELLANEOUS SCRATCHPAD LOCS
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((A-AMCENT) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT 421))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((A-CNSADF) Q-TYPED-POINTER READ-MEMORY-DATA)
 	((M-FLAGS) (A-CONSTANT		;REINITIALIZE ALL MODES TO
		     (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;AVOID EMBARASSMENT
		      (PLUS (BYTE-VALUE M-CAR-SYM-MODE 1)
		       (PLUS (BYTE-VALUE M-CAR-NUM-MODE 0)
		        (PLUS (BYTE-VALUE M-CDR-SYM-MODE 1)
			 (PLUS (BYTE-VALUE M-CDR-NUM-MODE 0)
			  (PLUS (BYTE-VALUE M-DONT-SWAP-IN 0)
			   (PLUS (BYTE-VALUE M-TRAP-ENABLE 0)
			    (PLUS (BYTE-VALUE M-MAR-MODE 0)
				  (BYTE-VALUE M-PGF-WRITE 0)))))))))))
	((VMA-START-READ) (A-CONSTANT (EVAL (PLUS 200 %SYS-COM-/#-AREAS))))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((A-/#-AREAS) Q-TYPED-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT (EVAL (PLUS 200 %SYS-COM-AREA-ORIGIN-PNTR))))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((VMA) SUB READ-MEMORY-DATA (A-CONSTANT 1)) ;1- ADDR OF AREA-ORIGIN TABLE
	((M-K) (A-CONSTANT (A-MEM-LOC A-V-RESIDENT-SYMBOL-AREA)))
BEG02	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((OA-REG-LOW) DPB M-K OAL-DEST A-ZERO)	;DESTINATION
	((A-GARBAGE) READ-MEMORY-DATA)
	(JUMP-EQUAL M-K (A-CONSTANT (A-MEM-LOC A-V-MICRO-CODE-EXIT-AREA)) BEG03)
	(JUMP-XCT-NEXT BEG02)
       ((M-K) ADD M-K (A-CONSTANT 1))

BEG03	((M-K) SUB M-ZERO (A-CONSTANT 200))
	((A-V-MISC-BASE) ADD M-K A-V-MICRO-CODE-SYMBOL-AREA)
	((VMA-START-READ M-VMA-HELD) A-INITIAL-FEF)	;INDIRECT
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((A-INITIAL-FEF) READ-MEMORY-DATA)

	(CALL-XCT-NEXT SG-LOAD-STATIC-STATE)	;INITIALIZE PDL LIMITS ETC
       ((A-QCSTKG) A-QISTKG)			;FROM INITIAL STACK-GROUP
	((A-QLBNDP) ADD (M-CONSTANT -1) A-QLBNDO) ;INITIALIZE BINDING PDL POINTER
			; POINTS AT VALID LOCATION, OF WHICH THERE ARENT ANY YET.
	((A-PDL-BUFFER-HEAD) A-ZERO)
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) A-QLPDLO)
	((PDL-BUFFER-POINTER) A-PDL-BUFFER-HEAD)
	((A-PDL-BUFFER-HIGH-WARNING) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))  ;INITAL STACK
					;HAD BETTER AT LEAST BIG ENUF FOR P.B.
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-A C-PDL-BUFFER-POINTER-PUSH) A-INITIAL-FEF)
	((M-K) Q-DATA-TYPE M-A)
	(CALL-NOT-EQUAL M-K (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
	((M-AP) PDL-BUFFER-POINTER)
	((M-PDL-BUFFER-ACTIVE-QS) (A-CONSTANT 4))
	((VMA-START-READ M-VMA-HELD) M-A)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((A-TEMPC) (LISP-BYTE %%FEFH-PC) READ-MEMORY-DATA)
BEG06	(CALL-NOT-EQUAL MICRO-STACK-PNTR-AND-DATA 	;CLEAR THE MICRO STACK PNTR
			(A-CONSTANT (PLUS 1 (I-MEM-LOC BEG06))) BEG06)
	(JUMP-XCT-NEXT QLENX)			;CALL INITIAL FUNCTION, NEVER RETURNS
       ((M-ERROR-SUBSTATUS) M-ZERO)

;;; MAIN INSTRUCTION EXECUTING LOOP

QMLPTP	((M-INST-BUFFER) READ-MEMORY-DATA)
QMLP-EVEN	;BRANCH RETURNS HERE IF PC LOADED EVEN, NEXT INSTRUCTION IS IN M-INST-BUFFER
	(DISPATCH-CALL-XCT-NEXT M-INST-OP OPDTB)	;GO EXECUTE EVEN INSTRUCTION
   (ERROR-TABLE ILLEGAL-INSTRUCTION)
       ((M-1) M-INST-DELTA) 
;RETURN TO QMLPOD1 IF PC LOADED EVEN BUT NEEDS TO BE INCREMENTED, NEXT INST IN BUFFER
QMLPOD1	((M-PC) M-PC A-ZERO ADD ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)
QMLP-ODD	;BRANCH RETURNS HERE IF PC LOADED ODD, NEXT INSTRUCTION IS IN M-INST-BUFFER
	(DISPATCH-CALL-XCT-NEXT M-INST-OP OPDTB)	;GO EXECUTE ODD INSTRUCTION
   (ERROR-TABLE ILLEGAL-INSTRUCTION)
       ((M-1) M-INST-DELTA) 
;RETURN HERE IF PC LOADED IS EVEN, BUT NEXT INSTRUCTION IS NOT IN M-INST-BUFFER
QMLP    ((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	(JUMP-XCT-NEXT QMLPTP)
QMLPEV1((M-PC) M-PC A-ZERO ADD ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)
	(JUMP QMLP-EVEN)			;HACK HACK
;RETURN TO QMLPEV1 IF PC LOADED ODD BUT NEEDS TO BE INCREMENTED, NEXT INST IN BUFFER

;;; EFFECTIVE ADDRESS COMPUTATION ROUTINES.
;   THESE ARE ENTERED FROM QADCM1, THEY PUT THE OPERAND INTO M-T AND POPJ.

QAFE	((M-1) M-INST-ADR)			;FULL DELTA
QAFE0	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA) ADD C-PDL-BUFFER-INDEX A-1)
QADR4	((VMA-START-READ M-VMA-HELD) DPB VMA Q-POINTER	;VMA POINTS INTO FEF OR QUOTE PAGE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))	;SO MAKE IT LOCATIVE
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;FOLLOW ALL INVZ
       ((M-T) READ-MEMORY-DATA)			;RETURN C(E) IN M-T

;GET EFFECTIVE ADDRESS, NOT PLANNING TO READ CONTENTS.  POPJ WITH EFF ADR ON PDL
;MUSTN'T TRANSPORT, NOR BARF AT TRAP, BUT MUST FOLLOW EXTERNAL VALUE CELL POINTER
QEAFE	((M-1) M-INST-ADR)			;FULL DELTA
QEAFE0	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA-START-READ M-VMA-HELD) ADD C-PDL-BUFFER-INDEX A-1)
	(CALL-CONDITIONAL PG-FAULT PGF-R)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA) ;FOLLOW ALL INVZ
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-VMA-HELD ;SHOULD BE LOCATIVE ALREADY, BUT...
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

;REF LOCAL BLOCK.  CANNOT BE INVISIBLE POINTER.
;IF THIS IS EVER CHANGED TO ALLOW INVISIBLE POINTERS, GOT TO FOOL AROUND
;WITH THE QADCM3 DISPATCH AND THE THINGS THAT USE IT, AND DECIDE WHICH
;FLAVORS OF INVISIBILITY DO WHAT WITH RESPECT TO VALUE-CELL-LOCATION.
QADLOC	((M-1) ADD M-1 A-QLOCO)
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1)
       ((M-T) C-PDL-BUFFER-INDEX)

;REF ARGUMENT BLOCK.  CANNOT BE INVISIBLE POINTER.
QADARG	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1 ALU-CARRY-IN-ONE) ;%LP-INITIAL-LOCAL-BLOCK-OFFSET=1
       ((M-T) C-PDL-BUFFER-INDEX)

;REF CONSTANTS PAGE.
QAQT	(JUMP-XCT-NEXT QADR4)
       ((VMA) ADD M-1 A-V-CONSTANTS-AREA)

;REF PDL.  CANNOT BE INVISIBLE POINTER.
;WE ONLY SUPPORT (SP)+ TYPE PDL ADDRESSING (PDL 77) 
QADPDL	(POPJ-AFTER-NEXT
	 (M-T) C-PDL-BUFFER-POINTER-POP)
       (CALL-NOT-EQUAL M-1 (A-CONSTANT 77) TRAP)	;UNSUPPORTED ADDRESS TYPE
   (ERROR-TABLE ILLEGAL-INSTRUCTION)
							;NOTE THAT PDL HAS BEEN POPPED

;;; STORE CYCLE
;   VALUE IN M-T.  A READ-TYPE EFF ADDR COMPUTATION MAY OR MAY NOT
;   HAVE TAKEN PLACE ALREADY.
;   EXITS VIA POPJ BACK TO MAIN LOOP.

QIMVM	((M-T) C-PDL-BUFFER-POINTER)			;MOVEM INSTRUCTION
STOCYC	(DISPATCH-XCT-NEXT M-INST-REGISTER QADCM2)	;DISPATCH ON ADDRESS TYPE
       ((M-1) M-INST-DELTA)				;WITH DELTA IN M-1

;USE THIS ONE IF ALREADY DID A READ CYCLE
RPWCYC	(DISPATCH-XCT-NEXT M-INST-REGISTER QADCM4)	;DISPATCH ON ADDRESS TYPE
       ((M-1) M-INST-DELTA)				;WITH DELTA IN M-1

;STOCYC AND RPWCYC END UP HERE IF USING FEF ADDRESSING.
;STORE IN FEF, NO READ CYCLE TOOK PLACE, SO MUST COMPUTE VMA AND CHECK FOR INVZ
QSTFE	((M-1) M-INST-ADR)				;FULL DELTA
	((PDL-BUFFER-INDEX) M-AP)			;0(AP) -> FEF
	((VMA) ADD C-PDL-BUFFER-INDEX A-1)
	((VMA-START-READ M-VMA-HELD) DPB VMA Q-POINTER	;VMA POINTS INTO FEF OR QUOTE PAGE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))	;SO MAKE IT LOCATIVE
QSTFE2	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;FOLLOW ALL INVZ
	((VMA) M-VMA-HELD)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

;HERE FROM RPWCYC
;IN ORDER TO AVOID SMASHING THE CDR CODE OF THE LOCATION STORED INTO,
;WE MUST RE-READ IT.  PERHAPS THIS CAN BE DONE BETTER IN THE FUTURE.
QSTFE1	(JUMP-XCT-NEXT QSTFE2)
       ((VMA-START-READ) M-VMA-HELD)

;STORE IN LOCAL BLOCK
QSTLOC	((M-1) ADD M-1 A-QLOCO)
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1)
       ((C-PDL-BUFFER-INDEX) M-T)

;STORE IN ARGUMENT BLOCK
QSTARG	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1 ALU-CARRY-IN-ONE)
       ((C-PDL-BUFFER-INDEX) M-T)

;STORE IN PDL
;QSTPDL	(CALL-EQUAL M-1 (A-CONSTANT 77) ILLOP)
;	((M-A) PDL-BUFFER-POINTER)
;	(POPJ-AFTER-NEXT
;	 (PDL-BUFFER-INDEX) SUB M-A A-1)
;       ((C-PDL-BUFFER-INDEX) M-T)

;PUSH LOCATIVE POINTER TO ADDRESS OF LOCAL VARIABLE ONTO THE PDL
QVMALCL	((M-1) ADD M-1 A-QLOCO)
	((M-1) SUB M-1 (A-CONSTANT 1)) ;COMPENSATE FOR +1 BELOW
;PUSH LOCATIVE POINTER TO ADDRESS OF ARGUMENT VARIABLE ONTO THE PDL
QVMAARG (CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) ADD M-AP A-1 ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (C-PDL-BUFFER-POINTER-PUSH) DPB M-K Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (NO-OP)

;;; VARIOUS TRAPS

;PUSHJ HERE FOR FATAL ERRORS, E.G. THINGS THAT CAN'T HAPPEN.
;ALSO FOR THINGS WHICH DON'T HAVE ERROR-TABLE ENTRIES YET.
  (MICRO-CODE-ILLEGAL-ENTRY-HERE)	;FILL IN UNUSED ENTRIES IN 
					; MICRO-CODE-SYMBOL-AREA
ILLOP	(JUMP HALT-CONS ILLOP)		;NO HANDLER YET

;PUSHJ HERE FOR ERRORS WHICH CAN TRAP TO MACROCODE
;INITIAL SETUP IS TO SAVE ADDRESS TRAPPED FROM OUT OF THE OPCS.
;SMASHES VMA, SMASHES READ-MEMORY-DATA, BUT M-VMA-HELD POINTS TO IT ANYWAY.
;FIX THIS UP BETTER ON THE NEXT MACHINE.
TRAP	(JUMP-IF-BIT-CLEAR M-TRAP-ENABLE ILLOP)	;TURN INTO ILLOP UNLESS TRAPS ENABLED
	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO UNIBUS
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 637772001)) ;LOCATION 764000
	((VMA-START-READ) (A-CONSTANT 1))	;FETCH LOCATION 764002
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULDN'T HAPPEN
	((A-TRAP-MICRO-PC) DPB READ-MEMORY-DATA (BYTE-FIELD 12. 0)
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;CATCH RETURN ADDRESS
						;OUT OF THE OPCS.  NOTE CAREFUL TIMING,
						;6 INSTRUCTIONS TO HERE!
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP
	((M-3) A-SG-STATE)			;RECURSIVE TRAP?
	(CALL-IF-BIT-SET (LISP-BYTE %%SG-ST-PROCESSING-ERROR) M-3 ILLOP)	;IF SO, HALT
	((A-SG-STATE) DPB (M-CONSTANT -1) (LISP-BYTE %%SG-ST-PROCESSING-ERROR) A-3)
	((A-TEM3) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-QTRSTKG)
	((M-3) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-QCSTKG)
	(CALL-EQUAL M-3 A-TEM3 ILLOP)		;RECURSIVE ERRORS
	(CALL-XCT-NEXT SGLV)			;STORE CURRENT STATUS
       ((M-3) (A-CONSTANT (EVAL SG-STATE-AWAITING-ERROR-RECOVERY))) ;AND SWAP SPECIAL-PDL
	((A-SG-TEM) A-V-NIL)	;Transmit NIL (do not change, EH knows about this.)
	;((A-SG-TEM1) A-V-NIL)	;Pass no arguments
	;((A-NARGS) SETZ)	;..
	(JUMP-XCT-NEXT SG-ENTER)			;"CALL" TRAP HANDLER STACK GROUP
       ((M-A) A-QTRSTKG)

;PUSHJ HERE ON ACTIVATE INVOKE.  OPERATION TYPE FROM I-ARG.
;INVOKE-ACTIVATE
;	(CALL-XCT-NEXT TRAP)	;NO HANDLER YET
;       ((C-PDL-BUFFER-POINTER-PUSH) DPB READ-I-ARG Q-POINTER	;SAVE OP-CODE
;			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
;       (ERROR-TABLE INVOKE)

;;; BASIC INSTRUCTIONS
;   OPERAND IS NOT FETCHED YET, SO FETCH IT INTO M-T, THEN
;   PRODUCE RESULT IN M-T, AND DISPATCH ON DESTINATION FIELD

QICDDR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCDR)

QICDR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

QICADR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCAR)

QICAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

QICAAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCAR)

QICDAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCDR)

QIMOVE	(DISPATCH-CALL M-INST-REGISTER QADCM5)
QIMOVE1	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;HERE TO TAKE DESTINATION FIELD FROM M-C INSTEAD OF INSTRUCTION
QIMOVE-EXIT
	(DISPATCH (BYTE-FIELD 3 0) M-C QMDTBD)	;MAY EXECUTE NEXT INSTRUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;ALL OF THESE WANT OPERAND FETCHED.
QIND1	(DISPATCH-XCT-NEXT M-INST-DEST D-ND1)
       (DISPATCH-CALL M-INST-REGISTER QADCM5)

;ALL OF THESE WANT OPERAND FETCHED.
QIND2	(DISPATCH-XCT-NEXT M-INST-DEST D-ND2)
       (DISPATCH-CALL M-INST-REGISTER QADCM5)

;THESE DON'T WANT THEIR OPERAND FETCHED.
QIND3	(DISPATCH M-INST-DEST D-ND3)

;CALL WITH NO ARGS
QICAL0	(DISPATCH-CALL M-INST-REGISTER QADCM5)		;FETCH C(E)
	(JUMP-XCT-NEXT QMRCL)				;ACTIVATE, BUT FIRST
       (CALL CBM)					;OPEN CALL BLOCK

;CALL WITH ARGS.  JUST OPEN A CALL BLOCK.
QICALL	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)	;FETCH C(E)
CBM    ((M-C) M-INST-DEST)		;EVENTUAL DESTINATION
CBM0					;%OPEN-CALL-BLOCK CALLS IN HERE
					;LEAVES M-ZR A COPY OF PDL-BUFFER-POINTER
	((M-ZR) PDL-BUFFER-POINTER)		;OPEN MACRO-TO-XXX CALL BLOCK
	((M-ZR) ADD M-ZR (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	((M-K) SUB M-ZR A-IPMARK)	;COMPUTE DELTA TO PREV OPEN BLOCK
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-K) SUB M-ZR A-AP)		;COMPUTE DELTA TO PREV ACTIVE BLOCK
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) A-TEM1)
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPCLS Q
	    DPB M-C (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) A-TEM1)
;QBNEAF QBALM WOULD GO HERE IF EVER REVIVED
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPEXS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPENS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT 
	  (C-PDL-BUFFER-POINTER-PUSH) M-T)		;PUSH LPFEF Q
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;A-IPMARK -> NEW OPEN BLOCK

;;; MISC INSTRUCTION
MISC	((M-B) M-INST-ADR)	;GET LOW 9 BITS OF INST
	(JUMP-LESS-THAN	M-B (A-CONSTANT 200) QMSCO1)	;LIST GROUPS
	((VMA-START-READ) ADD A-V-MISC-BASE M-B)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(CALL 0)		;CALL EXECUTION ROUTINE
	(DISPATCH M-INST-DEST QMDTBD)	;M-INST-BUFFER STILL SET UP, STORE IN DEST
					;MAY EXECUTE NEXT INSTRUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;LIST GROUP, ALLOCATE NUMBER OF Q'S GIVEN BY BITS 1.5-1.1 OF INSTRUCTION.
;     LISTIFY THEM, AND PUSH ON PDL THREE QS.
;	(1) POINTER TO BLOCK 
;	(2) DESTINATION FIELD OF MISC-INSTRUCTION
;	(3) ANOTHER COPY POINTER TO BLOCK.
;    THIS INTERFACES APPROPRIATELY WITH THE STORE-NEXT-LIST DESTINATION,
;	WITH THE NET EFFECT OF CREATING A N-ELEMENT LIST AND FINALLY STORING
;	A POINTER TO IT IN THE SPECIFIED DESTINATION.
;  Q'S COME FROM AREA IN A-CNSADF OR SPECIFIED AREA DEPENDING ON WHETHER 1.6 IS
;    0 OR 1 RESPECTIVELY.

QMSCO1	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 6) M-B QMSCO2)  ;JUMP ON USE DEFAULT 
       ((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)		;AREA (IE M-B 0 - 77 )
	((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;LIST IN SPECD AREA
QMSCO2	(CALL-XCT-NEXT IALLB)			;ALLOCATE Q'S IN B IN AREA IN S
       ((M-B) (BYTE-FIELD 6 0) M-B)		;FLUSH 100 BIT
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;POINTER TO ALLOCATED BLOCK
	((M-C) M-INST-DEST)
	(POPJ-AFTER-NEXT 
	 (C-PDL-BUFFER-POINTER-PUSH)
	    DPB M-C Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)

;THESE VARIOUS CONSING ROUTINES HAD BETTER NOT CLOBBER M-C.  OTHER REGS PROBABLY OK.

XXCONS (MISC-INST-ENTRY XCONS)			;XCONS
	(JUMP-XCT-NEXT XXCON1)
       ((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)		;USE DEFAULT AREA

XXCONA (MISC-INST-ENTRY XCONS-IN-AREA)		;XCONS, WITH AREA AS THIRD ARG
	((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)
XXCON1	((M-B) C-PDL-BUFFER-POINTER-POP)	;EXCH ARGS
	((M-A) C-PDL-BUFFER-POINTER-POP)
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	(JUMP-XCT-NEXT QCONS)
       ((C-PDL-BUFFER-POINTER-PUSH) M-A)

XNCONS (MISC-INST-ENTRY NCONS)			;NCONS
	(JUMP-XCT-NEXT XNCON1)
       ((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)

XNCONA (MISC-INST-ENTRY NCONS-IN-AREA)		;NCONS, WITH AREA AS SECOND ARG
	((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)
XNCON1	(JUMP-XCT-NEXT QCONS)
       ((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)

XCONS (MISC-INST-ENTRY CONS)			;CONS
	((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)	;USE DEFAULT AREA
QCONS	(CALL IALL2Q)				;ALLOCATE 2 Q'S, RETURN POINTER IN M-T
	((WRITE-MEMORY-DATA) DPB Q-TYPED-POINTER
		C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-ERROR)))
	((VMA-START-WRITE) ADD M-T (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)
	((WRITE-MEMORY-DATA) DPB Q-TYPED-POINTER 
		C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NORMAL)))
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE M-T) DPB M-T Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XCONSA (MISC-INST-ENTRY CONS-IN-AREA)		;CONS, WITH AREA AS THIRD ARG
	(JUMP-XCT-NEXT QCONS)
       ((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)


;;; STORAGE ALLOCATION STUFF
;   PROTECTED FROM INTERRUPTS TO AVOID GETTING FREE POINTERS
;   OUT OF PHASE AND TO AVOID GETTING SCREWED BY SOME OTHER
;   PROCESS DOING A STORAGE REORGANIZATION.  HOWEVER,
;   CAN TRIGGER A GARBAGE COLLECTION INTERRUPT.

;ALLOCATE A CONS, M-S/ AREA
IALL2Q	(CALL-GREATER-THAN M-S (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)) ILLOP)
	((VMA-START-READ) ADD M-S A-V-AREA-MODE-BITS)  ;GET FS MODE OF AREA
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(DISPATCH (LISP-BYTE %%AREA-MODE-FREE-STORAGE)
		READ-MEMORY-DATA AREA-FS-MODE-DISP-2Q)

IA2QL	((VMA-START-READ) ADD M-S A-V-AREA-LENGTH) ;LINEARLY ADVANCING AREA
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-K) Q-POINTER READ-MEMORY-DATA)	;FIRST GET AREA SIZE
	((VMA-START-READ) ADD M-S A-V-AREA-FREE-POINTER)  ;NOW GET FREE POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM1) SUB M-K (A-CONSTANT 2))	;GOING TO ALLOC 2, SO FREE POINTER HAD 
						;BETTER BE LESS THAN THIS
	((M-K) Q-POINTER READ-MEMORY-DATA)
	(JUMP-GREATER-THAN M-K A-TEM1 IALLGC)	;GC NEEDED
	((WRITE-MEMORY-DATA-START-WRITE)
	   ADD READ-MEMORY-DATA (A-CONSTANT 2))	;BUMP FREE POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA-START-READ) ADD M-S A-V-AREA-ORIGIN)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(POPJ-AFTER-NEXT 
	  (M-T) ADD READ-MEMORY-DATA A-K)
       ((M-T) Q-POINTER M-T)

;ALLOCATE A BLOCK (LIST), M-S/ AREA, M-B/ NUMBER OF QS
IALLB	(CALL-GREATER-THAN M-S (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)) ILLOP)
	(CALL-LESS-THAN M-B (A-CONSTANT 1) TRAP)
(ERROR-TABLE IALLB-TOO-SMALL M-B)
	((VMA-START-READ) ADD M-S A-V-AREA-MODE-BITS)  ;GET FS MODE OF AREA
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(DISPATCH (LISP-BYTE %%AREA-MODE-FREE-STORAGE)
		READ-MEMORY-DATA AREA-FS-MODE-DISP-BLOCK)

IABL	((VMA-START-READ) ADD M-S A-V-AREA-LENGTH)	;ALLOC BLOCK FROM LIN ALL AREA
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-K) Q-POINTER READ-MEMORY-DATA)		;AREA LENGTH
	((VMA-START-READ) ADD M-S A-V-AREA-FREE-POINTER)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-E) Q-POINTER READ-MEMORY-DATA)		;OLD FREE POINTER
	((M-T) ADD M-E A-B)				;NEW FREE POINTER
	(JUMP-GREATER-THAN M-T A-K IALLGC)		;JUMP IF WON'T FIT
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT ;UPDATE FREE POINTER
		Q-ALL-BUT-POINTER READ-MEMORY-DATA A-T)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA-START-READ) ADD M-S A-V-AREA-ORIGIN)	;GET AREA ORIGIN AND RELOCATE
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) ADD READ-MEMORY-DATA A-E)		;UNTYPED PNTR TO BLOCK
	((M-E) Q-POINTER-WITHIN-PAGE M-T)		;SEE IF ON PAGE BOUNDARY
	(JUMP-NOT-EQUAL M-E A-ZERO IABLS)
	((M-DONT-SWAP-IN) DPB (M-CONSTANT -1) A-FLAGS)	;YES, BEGINNING FRESH PAGE
IABLS	((WRITE-MEMORY-DATA) (A-CONSTANT (PLUS		;NULL OUT THE LIST
		(BYTE-VALUE Q-CDR-CODE CDR-NEXT)
		(BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL))))
	((M-E) SUB M-T (A-CONSTANT 1))
	(JUMP-LESS-OR-EQUAL M-B (A-CONSTANT 1) IABLS2)
IABLS1	((M-E VMA-START-WRITE) ADD M-E (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((M-DONT-SWAP-IN) DPB (M-CONSTANT -1) A-FLAGS)	;PAGES TOUCHED AFTER THIS ARE EITHER
	(JUMP-GREATER-THAN-XCT-NEXT M-B (A-CONSTANT 2) IABLS1)	;FRESH OR ALREADY SWAPPED IN
       ((M-B) SUB M-B (A-CONSTANT 1))
IABLS2	((WRITE-MEMORY-DATA) (A-CONSTANT (PLUS
		(BYTE-VALUE Q-CDR-CODE CDR-NIL)
		(BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL))))
	((VMA-START-WRITE) ADD M-E (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(POPJ-AFTER-NEXT
	 (M-DONT-SWAP-IN) DPB M-ZERO A-FLAGS)		;CLEAR MAGIC FLAG
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))

IALLGC	(JUMP HALT-CONS IALLGC)		;SOMEWHAT SIMPLIFIED GARBAGE COLLECTOR

;EVERYTHING ON THIS PAGE IS OBSOLETE
(COMMENT 
IA2QQ	((VMA-START-READ) ADD M-S A-V-AREA-FREE-POINTER) ;Q ALLOCATED AREA
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) Q-POINTER READ-MEMORY-DATA)		;GET FREE LIST
	(JUMP-EQUAL M-T (A-CONSTANT (BYTE-MASK Q-POINTER)) IA2Q1) ;JUMP IF EMPTY
	((VMA-START-READ) ADD M-S A-V-AREA-LENGTH)	;VERIFY THAT FREE POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;IS WITHIN BOUNDS
	((A-TEM1) Q-POINTER READ-MEMORY-DATA)
	(CALL-GREATER-OR-EQUAL M-T A-TEM1 ILLOP)
	((VMA-START-READ) ADD M-S A-V-AREA-ORIGIN)	;RELOCATE FREE PNTR
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM1) Q-POINTER READ-MEMORY-DATA)
	((M-T VMA-START-READ) ADD M-T A-TEM1)		;GET NEXT FREE NODE
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)		;UPDATE FREE POINTER
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-S A-V-AREA-FREE-POINTER)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

IA2Q1	((VMA-START-READ) ADD M-S A-V-AREA-PARTIALLY-FREE-PAGE)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) Q-POINTER READ-MEMORY-DATA)		;NEXT LOC IN PARTIALLY FREE PG
	(JUMP-EQUAL M-T A-ZERO IA2Q2)			;JUMP IF NO PARTIALLY FREE PAGE
	((M-1) ADD M-T (A-CONSTANT 2))			;ADVANCE FREE POINTER
	((M-K) Q-POINTER-WITHIN-PAGE M-1)
	(JUMP-GREATER-THAN M-K (A-CONSTANT (BYTE-MASK Q-POINTER-WITHIN-PAGE))
		IA2Q2A)					;NOT ENOUGH ROOM
	((WRITE-MEMORY-DATA) DPB M-1 Q-POINTER
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-S A-V-AREA-PARTIALLY-FREE-PAGE)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

IA2Q2A	((M-K) Q-POINTER-WITHIN-PAGE M-T)		;CLEAR CRUFT AT END OF PAGE
	(JUMP-EQUAL M-K A-ZERO IA2Q2B)
	((WRITE-MEMORY-DATA) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-TRAP)))
	((VMA-START-WRITE) M-T)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(JUMP-XCT-NEXT IA2Q2A)
       ((M-T) ADD M-T (A-CONSTANT 1))

IA2Q2B	((VMA) ADD M-S A-V-AREA-PARTIALLY-FREE-PAGE)	;NO PART FREE PG ANY MORE
	((WRITE-MEMORY-DATA-START-WRITE) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
IA2Q2	((VMA-START-READ) ADD M-S A-V-AREA-FREE-PAGE-LIST) ;GET NEW PAGE
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) Q-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-T A-ZERO IALLGC)			;NO PAGES, GC NEEDED
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)		;MAKE THIS PAGE PARTIALLY FREE
	((VMA-START-WRITE) ADD M-S A-V-AREA-PARTIALLY-FREE-PAGE)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA-START-READ) M-T)				;THREAD TO NEXT FREE PAGE
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-S A-V-AREA-FREE-PAGE-LIST)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(JUMP IA2Q1)
);END OF COMMENT

;;; SAFE ALLOCATION AND INITIALIZATION OF STRUCTURES

;(%ALLOCATE-AND-INITIALIZE <data type for return> <data type for header> <header> 
;				<value for second word> <area> <nqs>)
XAAI (MISC-INST-ENTRY %ALLOCATE-AND-INITIALIZE)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER)	;CHECK FOR ALLOC AT LEAST 2 WORDS
	(CALL-LESS-THAN M-1 (A-CONSTANT 2) ILLOP)
	(CALL XALLB)			;ALLOCATE BLOCK, RETURN IN M-T W/O INTERRUPTS
	((VMA) ADD M-T (A-CONSTANT 1))	;-> SECOND WORD
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((A-TEM1) C-PDL-BUFFER-POINTER-POP)	;HEADER Q (POINTER PART)
	((WRITE-MEMORY-DATA) DPB C-PDL-BUFFER-POINTER-POP	;SET DATA TYPE, ETC.
		Q-ALL-BUT-POINTER A-TEM1)
	(POPJ-AFTER-NEXT			;WRITE THE HEADER, AND
	 (VMA-START-WRITE M-T) DPB C-PDL-BUFFER-POINTER-POP	; RETURN POINTER TO BLOCK,
		Q-ALL-BUT-POINTER A-T)		; WITH CORRECT TYPE
       (CALL-CONDITIONAL PG-FAULT PGF-W)

;(%ALLOCATE-AND-INITIALIZE-ARRAY <header as fixnum> <index length> <leader length> 
;					<area> <nqs>)
XAAIA (MISC-INST-ENTRY %ALLOCATE-AND-INITIALIZE-ARRAY)
	(CALL XALLB)			;ALLOCATE BLOCK, RETURN IN M-T W/O INTERRUPTS
	((M-1) (A-CONSTANT (EVAL DTP-ARRAY-POINTER)))
	((VMA M-T) DPB M-1 Q-ALL-BUT-POINTER A-T)	;VMA -> START OF BLOCK, M-T RIGHT MAYBE
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;LEADER LENGTH
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;INDEX LENGTH
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-LEADER-BIT)
		C-PDL-BUFFER-POINTER XAAIA1)
       ((M-2) DPB C-PDL-BUFFER-POINTER-POP	;HEADER
	    Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-HEADER)))
	((WRITE-MEMORY-DATA-START-WRITE) ADD M-C	;STORE LEADER HEADER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE %%HEADER-TYPE-FIELD
						    %HEADER-TYPE-ARRAY-LEADER))
				  2)))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA M-T) ADD M-T A-C ALU-CARRY-IN-ONE)	;POINTS ONE BEFORE HEADER
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-C
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA M-T) ADD M-T (A-CONSTANT 1))	;POINTS TO HEADER
XAAIA1	((WRITE-MEMORY-DATA-START-WRITE) M-2)	;STORE HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(POPJ-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-2)
	((VMA) ADD M-T (A-CONSTANT 1))
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) DPB M-B Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (CALL-CONDITIONAL PG-FAULT PGF-W)

;;; BRANCH INSTRUCTION

QIBRN	(DISPATCH-XCT-NEXT M-INST-DEST BRDTAB)	;DISP ON BRANCH TYPE
       ((M-B) M-INST-ADR)			;M-B GETS DELTA FROM ADR FIELD

;HERE WHEN YOU'VE DECIDED TO BRANCH
QBRALW	(JUMP-IF-BIT-SET (BYTE-FIELD 1 8) 	;EXTEND SIGN IF NECESSARY
		M-B QBRALW-1)
QBRLZ2	((M-PC) ADD M-PC A-B LOAD-LOW-PC-BIT)	;INCR PC BY AMOUNT IN M-B
QBRNT1	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)  ;GET MAIN LOOP BACK
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	      ;INTO PHASE
	((M-ZR) MICRO-STACK-DATA-POP)		;FLUSH OLD MICRO RETURN
	((M-PC) M-PC A-ZERO ADD ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-PC QBR-PC-ODD)  ;PC HAS BEEN INCR'ED
	(JUMP-XCT-NEXT QMLP-EVEN)			;PC EVEN
       ((M-INST-BUFFER) READ-MEMORY-DATA)

QBR-PC-ODD
	(JUMP-XCT-NEXT QMLP-ODD)		;PC ODD
       ((M-INST-BUFFER) READ-MEMORY-DATA)

;BRANCH DELTA NEGATIVE
QBRALW-1((M-B) SELECTIVE-DEPOSIT (M-CONSTANT -1)
		(BYTE-FIELD 24. 8.) A-B)	;EXTEND SIGN
	(JUMP-NOT-EQUAL M-B (A-CONSTANT -1) QBRLZ2)	;DROP THRU ON DOUBLE WORD BRANCH
QBRALZ	((M-PC) ADD M-PC A-ZERO ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0)
		 M-PC QBRLZ3)		 ;XFER ON DELTA IN OTHER HALF OF CURRENT PC WORD
	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	((M-INST-BUFFER) READ-MEMORY-DATA)
QBRLZ3	((M-B) (BYTE-FIELD 16. 0) M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 15.) M-B QBRLZ2)  ;DROP THRU ON EXTEND SIGN
	(JUMP-XCT-NEXT QBRLZ2)
       ((M-B) SELECTIVE-DEPOSIT (M-CONSTANT -1)
		(BYTE-FIELD 16. 16.) A-B)

QBRNL	((M-K) Q-TYPED-POINTER M-T)		;BRANCH ON NIL
	(JUMP-EQUAL M-K A-V-NIL QBRALW)

;HERE WHEN YOU'VE DECIDED NOT TO BRANCH
QBRNOT	(POPJ-NOT-EQUAL M-B (A-CONSTANT 777))
	(JUMP-XCT-NEXT QBRNT1)			;GET MAIN LOOP BACK INTO PHASE
       ((M-PC) ADD M-PC A-ZERO ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)  ;SKIP OVER 2ND WD

QBRNNL	((M-K) Q-TYPED-POINTER M-T)		;BRANCH ON NOT NIL
	(JUMP-NOT-EQUAL M-K A-V-NIL QBRALW)
	(JUMP QBRNOT)

QBRAT	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)	;BRANCH ON ATOM
	(JUMP QBRNOT)
	(JUMP QBRALW)

QBRNAT	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)	;BRANCH ON NOT-ATOM
	(JUMP QBRALW)
	(JUMP QBRNOT)

QBRNLP	((M-K) Q-TYPED-POINTER M-T)		;BR NIL, POP IF NOT
	(JUMP-EQUAL M-K A-V-NIL QBRALW)
	(JUMP-XCT-NEXT QBRNOT)
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

QBRNNP	((M-K) Q-TYPED-POINTER M-T)		;BR NOT NIL, POP IF
	(JUMP-NOT-EQUAL M-K A-V-NIL QBRALW)
	(JUMP-XCT-NEXT QBRNOT)
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

;;; NON-DESTINATION GROUP 1
;   E IN VMA, C(E) IN M-T, MOSTLY EXIT BY PUTTING RESULT ON STACK

;GET TWO PDL ARGUMENTS, FIRST TO M-1, SECOND TO M-2
FXGTPP	((M-T) C-PDL-BUFFER-POINTER-POP)	;GET 2ND ARG, DROP THROUGH

;GET ADDR ARG IN M-2, PDL ARG IN M-1, ERROR UNLESS BOTH FIXNUMS
FIXGET	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		;GET PDL ARG
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE M-T TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM M-T 1)
	((OA-REG-HI) BOXED-SIGN-BIT M-T)		;SIGN EXTEND (MUNG M SOURCE)
	((M-2) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-T)
	(POPJ-AFTER-NEXT
	 (OA-REG-HI) BOXED-SIGN-BIT M-1)		;SIGN EXTEND
       ((M-1) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-1)

QIADD	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *PLUS)
	((M-1) ADD M-1 A-2)
FIXRET	(DISPATCH-POPJ-XCT-NEXT (I-ARG 1) 
		(BYTE-FIELD 2 23.) M-1 D-FXOVCK)	;TEST FOR OVERFLOW
   (ERROR-TABLE FIXNUM-OVERFLOW M-T PUSH)
       ((C-PDL-BUFFER-POINTER-PUSH M-T) DPB M-1 Q-POINTER	;RESULT TO PDL WITH DATA TYPE
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
				  (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))
(LOCALITY D-MEM)
;DISPATCH TABLE FOR CHECKING FOR SINGLE-BIT ADD/SUBTRACT-TYPE FIXNUM OVERFLOW
;ON VALUE WHICH IS UNBOXED IN M-1.  DISPATCH ON SIGN BIT AND LOW DATA TYPE BIT.
;EVENTUALLY WILL JUMP OFF TO BIGNUM ROUTINES.  I-ARG SHOULD BE 0 IF RESULT
;ONLY TO M-T, OR 1 IF ALSO TO PDL.  IN ANY CASE, DOES ESSENTIALLY POPJ-XCT-NEXT.
;NEXT SHOULD BE INSTRUCTION TO BOX M-1 AS A FIXNUM.
(START-DISPATCH 2 0)
D-FXOVCK	
	(R-BIT)					 ;BITS AGREE NO OVERFLOW
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	 ;DISAGREE => OVERFLOW
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	 ;DISAGREE => OVERFLOW
	(R-BIT)					 ;BITS AGREE NO OVERFLOW
(END-DISPATCH)
(LOCALITY I-MEM)

QISUB	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *DIF)
	(JUMP-XCT-NEXT FIXRET)
       ((M-1) SUB M-1 A-2)

QIAND	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *AND)
	(JUMP-XCT-NEXT FIXRET)
       ((M-1) AND M-1 A-2)

QIXOR	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *XOR)
	(JUMP-XCT-NEXT FIXRET)
       ((M-1) XOR M-1 A-2)

QIIOR	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *IOR)
	(JUMP-XCT-NEXT FIXRET)
       ((M-1) IOR M-1 A-2)

QIMUL	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *TIMES)
	(CALL-XCT-NEXT MPY)	;LOW PRODUCT TO Q-R, HIGH TO M-2
       ((Q-R) M-2)
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
	(JUMP-EQUAL-XCT-NEXT M-2 A-ZERO FIXRET)	;JUMP IF NON-OVERFLOWING POSITIVE RESULT
       ((M-1) Q-POINTER Q-R A-2)	;SIGN EXTEND (IF NON-OVERFLOWING)
	(JUMP-EQUAL M-2 (A-CONSTANT -1) FIXRET)	;JUMP IF NON-OVERFLOWING NEGATIVE
	(CALL TRAP)		;RESULT REALLY SHOULD BE A BIGNUM
   (ERROR-TABLE FIXNUM-OVERFLOW M-T PUSH)

QIDIV	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB *QUO)
	(CALL DIV)
        (POPJ-AFTER-NEXT 		;DIVIDE CAN'T OVERFLOW
	 (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH M-T) DPB M-T Q-TYPED-POINTER	;RESULT TO PDL
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

XMINUS (MISC-INST-ENTRY MINUS)
   ;(ERROR-TABLE MINUS)  ** DT CHECKING **
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(CALL-EQUAL M-T (A-CONSTANT 40000000) TRAP)  ;MOBY NEG NUMBER OVERFLOW
  (ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)
	(POPJ-AFTER-NEXT 
	 (M-T) SUB M-ZERO A-T)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XABS (MISC-INST-ENTRY ABS)
   ; (ERROR-TABLE ABS)  ** DT CHECKING **
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT C-PDL-BUFFER-POINTER XMINUS)
	(POPJ-AFTER-NEXT (M-T) C-PDL-BUFFER-POINTER-POP)
       (NO-OP)

XHAUL (MISC-INST-ENTRY HAULONG)	;TAKES ONE ARG, RETURNS # SIGNIFICANT BITS
   ; (ERROR-TABLE HAULONG) ** DT CHECKING **
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;  IN WORD
	((M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XHAUL1	(POPJ-EQUAL M-1 A-ZERO)
	((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)	;COUNT
	(JUMP-XCT-NEXT XHAUL1)
       ((M-1) (BYTE-FIELD 31. 1) M-1)		;SHIFT RIGHT

;GCD ROUTINE.

XGCD (MISC-INST-ENTRY \\)				;GCD, STEIN'S ALGORITHM.
	(CALL-XCT-NEXT FXGTPP)
       ((M-A Q-R) (A-CONSTANT (OA-LOW-CONTEXT (Q-POINTER))))
  (ERROR-TABLE CALLS-SUB M-\\)				;CLEAR Q SO OUTPUT SELECTOR WINS.
	(JUMP-GREATER-OR-EQUAL M-1 A-ZERO XGCD0)	;TAKE ABS OF ARGS
	((M-1) SUB M-ZERO A-1)
XGCD0	(JUMP-GREATER-OR-EQUAL M-2 A-ZERO XGCDL)
	((M-2) SUB M-ZERO A-2)
XGCDL	(JUMP-EQUAL M-2 A-ZERO XGCD5)
	(JUMP-GREATER-THAN M-1 A-2 XGCD1)
	((C-PDL-BUFFER-POINTER-PUSH) M-1)		;EXCHANGE ARGS SO M-1 IS THE BIGGER
	((M-1) M-2)
	((M-2) C-PDL-BUFFER-POINTER-POP)
XGCD1	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-1 XGCD2)
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-2 XGCD3)
	((M-A) SUB M-A (A-CONSTANT 37))			;BOTH EVEN
							;ADD1 TO ROTATE FIELD, SUB1 FROM LENGTH
        ((M-2) M-2 OUTPUT-SELECTOR-RIGHTSHIFT-1)
XGCD3	(JUMP-XCT-NEXT XGCDL)				;M-1 EVEN
       ((M-1) M-1 OUTPUT-SELECTOR-RIGHTSHIFT-1)

XGCD2	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-2 XGCD4)
	(JUMP-XCT-NEXT XGCDL)				;M-2 EVEN
       ((M-2) M-2 OUTPUT-SELECTOR-RIGHTSHIFT-1)

XGCD4	((C-PDL-BUFFER-POINTER-PUSH) M-2)		;BOTH ODD
	((M-2) SUB M-1 A-2)
	(JUMP-XCT-NEXT XGCDL)
       ((M-1) C-PDL-BUFFER-POINTER-POP)

XGCD5	(POPJ-AFTER-NEXT (OA-REG-LOW) M-A)		;FINAL SHIFTING STEP
       ((M-T) DPB M-1 (BYTE-FIELD 0 0) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;FIXNUM EXPONENTIATION ROUTINE.
;M-B HOLDS THE EXPONENT, AND GETS SHIFTED AND TESTED.
;M-1 HOLDS THE FIRST ARG, SQUARED N TIMES.
;M-T HOLDS THE PARTIAL PRODUCTS

XUPARROW (MISC-INST-ENTRY ^)
	(CALL FXGTPP)					;FIRST IN M-1, SECOND IN M-2
  (ERROR-TABLE CALLS-SUB ^)
	((M-3) (A-CONSTANT 1))				;INITIALIZE RESULT
	((M-B) M-2)					;SAVE THE EXPONENT
	(JUMP-EQUAL M-2 A-ZERO XUP3)			;ANYTHING ^ 0 = 1
XUP1	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-B XUP2)
	(CALL-XCT-NEXT MPY)				;M-1 TIMES M-3 TO Q-R
       ((Q-R) M-3)
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
							;M-3 IS 32 BITS, BUT FIXED BIN(23,0)
	(JUMP-EQUAL-XCT-NEXT M-2 A-ZERO XUP2)		;JUMP IF POSITIVE NO OVERFLOW
       ((M-3) Q-R)					;PRODUCT BACK TO M-3
	(CALL-NOT-EQUAL M-2 (A-CONSTANT -1) TRAP)	;DROP THROUGH IF OK NEG, ELSE OVFL
		(ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)
XUP2	((M-B) M-B OUTPUT-SELECTOR-RIGHTSHIFT-1)	;(SETQ M-B (ASH M-B -1))
XUP3	(POPJ-EQUAL-XCT-NEXT M-B A-ZERO)		;IF ZERO, RESULT IS IN T
       ((M-T) DPB M-3 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT MPY)				;OTHERWISE COMPUTE NEXT POWER
       ((Q-R) M-1)					;I.E. Q-R GETS M-1 TIMES M-1
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
	(CALL-NOT-EQUAL M-2 A-ZERO TRAP)		;OVERFLOW (RESULT IS ALWAYS POSITIVE)
		(ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)
	(JUMP-XCT-NEXT XUP1)
       ((M-1) Q-R)					;(SETQ M-1 (* M-1 M-1))

;;; NON-DESTINATION-GROUP-2
;   E IN VMA, C(E) IN M-T

;THESE COMPARE C(E) TO TOP OF STACK, POP,
; AND LEAVE T OR NIL IN M-T IN LIEUE OF SETTING INDICATORS

XMEQ (MISC-INST-ENTRY M-EQ)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIEQ	((M-2) Q-TYPED-POINTER M-T)
	((M-1) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
QIEQL1
  (ERROR-TABLE CALLS-SUB M-=)          ;"GETS" HERE FROM QIEQL
	(JUMP-NOT-EQUAL M-1 A-2 XFALSE)
  (MISC-INST-ENTRY TRUE)
XTRUE	(POPJ-AFTER-NEXT (M-T) A-V-TRUE)
       (NO-OP)

XMEQL (MISC-INST-ENTRY M-=)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIEQL	(JUMP-XCT-NEXT QIEQL1)
       (CALL FIXGET)			;ARGS TO M-1, M-K

XMGRTH (MISC-INST-ENTRY M->)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIGRP	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB M->)
	(JUMP-XCT-NEXT XFALSE)
       (JUMP-GREATER-THAN M-1 A-2 XTRUE)

XMLESS (MISC-INST-ENTRY M-<)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QILSP	(CALL FIXGET)
   (ERROR-TABLE CALLS-SUB M-<)
	(JUMP-XCT-NEXT XFALSE)
       (JUMP-LESS-THAN M-1 A-2 XTRUE)

;THESE MODIFY THE CONTENTS OF THEIR EFFECTIVE ADDRESS

QISCDDR	(CALL-XCT-NEXT QMDD)	;CDDR THE ARGUMENT
       ((C-PDL-BUFFER-POINTER-PUSH) M-VMA-HELD) ;PRESERVING THE VMA
	(JUMP-XCT-NEXT RPWCYC)	;RETURN IT, RESTORING THE VMA
       ((M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)

QISCDR	(CALL-XCT-NEXT QMD)	;CDR THE ARGUMENT
       ((C-PDL-BUFFER-POINTER-PUSH) M-VMA-HELD) ;PRESERVING THE VMA
	(JUMP-XCT-NEXT RPWCYC)	;RETURN IT, RESTORING THE VMA
       ((M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)

QISM1	(JUMP-XCT-NEXT QISP1-1)
       ((M-K) (A-CONSTANT -1))

QISP1	((M-K) (A-CONSTANT 1))
QISP1-1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE M-T TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM M-T T)
	((OA-REG-HI) BOXED-SIGN-BIT M-T)		;SIGN-EXTEND
	((M-1) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-T)
	(CALL-XCT-NEXT FIXRET)	;ADD +1 OR -1 AND CONVERT TO APPROPRIATE TYPE
       ((M-1) ADD M-1 A-K)				;ALSO CHECKS FOR OVERFLOW
	(JUMP-XCT-NEXT RPWCYC)		;NOW STORE BACK INTO C(E)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

;;; NON-DESTINATION-GROUP-3
;   EFFECTIVE ADDRESS NOT YET COMPUTED, M-T NOT VALID.

QIPOP	(JUMP-XCT-NEXT STOCYC)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QIPSHE	(DISPATCH-XCT-NEXT M-INST-REGISTER QADCM3)	;EFF ADR TO PDL AND POPJ
       ((M-1) M-INST-DELTA)

QISETN	(JUMP-XCT-NEXT STOCYC)
       ((M-T) A-V-NIL)

QISETZ	(JUMP-XCT-NEXT STOCYC)
       ((M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

QIBNDN	(CALL QBND1)		;SAVE PRESENT BINDING
	((M-T) A-V-NIL)		;AND RE-BIND TO NIL
QIBDN1	((VMA-START-READ M-VMA-HELD) DPB M-B Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)  ;CHASE DTP-FORWARD IF ANY
	((VMA) M-VMA-HELD)    ;RESTORE VMA
	(POPJ-AFTER-NEXT 
	 (M-T WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT M-E
		Q-ALL-BUT-TYPED-POINTER A-T)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

QIBNDP	(CALL QBND1)		;SAVE PRESENT BINDING
	(JUMP-XCT-NEXT QIBDN1)	;AND REBIND TO POP(PDL)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

XBIND (MISC-INST-ENTRY BIND)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;ARG 2, NEW VALUE TO GIVE
   (ERROR-TABLE RESTART XBIND)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER)	;ARG 1, POINTER TO CELL TO BIND
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) TRAP)
   (ERROR-TABLE ARGTYP LOCATIVE PP 0 XBIND)
XBIND1	(JUMP-XCT-NEXT QIBDN1)
       (CALL QBND2)

QIBND 				;SAVE CURRENT CONTENTS, DON'T CHANGE
				;LEAVE M-E SET TO OLD CONTENTS (MAINLY FOR CDR CODE)
QBND1	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM6)	;EFF ADR TO PDL
       ((M-1) M-INST-DELTA)
QBND2	((M-1) ADD (M-CONSTANT 22.) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 TRAP)  ;RESULT HAD BETTER BE NEGATIVE
   (ERROR-TABLE PDL-OVERFLOW SPECIAL)			 ; (AS 24 BIT QUANTITY).
	((VMA-START-READ M-B) C-PDL-BUFFER-POINTER-POP)	;FETCH CURRENT CONTENTS
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	;INT OK, HAVEN'T HACKED YET
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;DON'T FOLLOW EXTERNAL-VALUE-CELL-PTR
;LOGICALLY SIMILAR CODE TO BELOW EXISTS AT QBSPCL
;******* Consider the implications of ((M-B) VMA) here instead of
;******* the transport back at QIBDN1.  Is it right?
	((M-E) READ-MEMORY-DATA)		;SAVE CDR CODE
	((M-1 WRITE-MEMORY-DATA) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL QBND3)	 ;JUMP IF NOT FIRST IN BLOCK
       ((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE) ;ADVANCE BINDING PDL PNTR
	((WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-1)
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
QBND3	((VMA-START-WRITE) A-QLBNDP)		;STORE PREV CONTENTS
	(CALL-CONDITIONAL PG-FAULT PGF-W)	;HAVE INCRD A-QLBNDP
	((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) M-B)		;LOCATIVE PNTR TO BOUND LOCN
	(POPJ-AFTER-NEXT 
	 (VMA-START-WRITE) A-QLBNDP)		;STORE POINTER TO BOUND CELL
       (CALL-CONDITIONAL PG-FAULT PGF-W)	;NO INTERRUPT, BIND NOT REALLY FINISHED

;SPECIAL KLUDGEY ADDRESS ROUTINE FOR BIND.  ALWAYS INDIRECTS ONE LEVEL.
;RETURNS WITH ADDRESS ON PDL.
QBAFE	((M-1) M-INST-ADR)			;FULL DELTA
QBAFE0	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA-START-READ M-VMA-HELD) ADD C-PDL-BUFFER-INDEX A-1)
	(CALL-CONDITIONAL PG-FAULT PGF-R)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;ONLY TRANSPORT, DON'T DO INVZ
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)	;MAKE SURE IT WAS AN EVCP
	(POPJ-AFTER-NEXT			;AND RETURN LOCATIVE ON PDL
	 (C-PDL-BUFFER-POINTER-PUSH) DPB READ-MEMORY-DATA
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-EXTERNAL-VALUE-CELL-POINTER)) ILLOP)

;;; DESTINATION HANDLERS
;   DATA TO STORE IN M-T

;THESE DESTINATIONS ARE NOW HANDLED BY THE INSTRUCTION FOLLOWING THE DESTINATION DISPATCH
;QMDDNQ		;NEXT (ARG), QUOTED
;QMDDN		;NEXT (ARG)
;QMDDS		;STACK

;DESTINATION NEXT-LIST
QMDDNL	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER)	;PTR TO NEXT PLACE IN LIST
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)
	((VMA) M-VMA-HELD)			;RESTORE VMA
	((WRITE-MEMORY-DATA-START-WRITE)	;GET RANDOM BITS FROM PLACE STORING TO
	    SELECTIVE-DEPOSIT READ-MEMORY-DATA
		Q-ALL-BUT-TYPED-POINTER A-T)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;CDR TO NEXT PLACE IN LIST
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)
	(POPJ-AFTER-NEXT			;NOT THROUGH WITH LIST
	 (C-PDL-BUFFER-POINTER-PUSH) M-T)
	(NO-OP)
	((M-C) C-PDL-BUFFER-POINTER-POP)	;THROUGH, GET ORIGINAL DESTINATION
	(JUMP-XCT-NEXT QIMOVE-EXIT)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;POINTER TO HEAD OF LIST

;;; DESTINATION LAST

QMDDLQ		;LAST, QUOTED
QMDDL	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))

;;;ACTIVATE PENDING CALL
QMRCL	((M-K) PDL-BUFFER-POINTER)
	((M-K) SUB M-K A-IPMARK)		;COUNT ARGUMENTS
	((A-NARGS) (BYTE-FIELD 7 0) M-K)
	((PDL-BUFFER-INDEX M-S) A-IPMARK)	;GET FEF POINTER POINTER
	((M-A) C-PDL-BUFFER-INDEX)		;M-A := FUNCTION TO CALL
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;DISPATCH ON DATA TYPE
       (CALL QLLV)				;DOES LINEAR LEAVE IF NECC.

;CONVERT PDL BUFFER ADDRESS IN M-K TO VIRTUAL ADDRESS IN M-K WITH LOCATIVE
; DATA-TYPE.  ANY REFERENCE VIRTUAL ADDRESS WHICH MAY BE IN PDL-BUFFER WILL TRAP,
; AND PAGE FAULT HANDLER WILL FIGURE OUT WHAT TO DO.

CONVERT-PDL-BUFFER-ADDRESS	
	((M-K) SUB M-K A-PDL-BUFFER-HEAD)
	(POPJ-AFTER-NEXT 
	 (M-K) DPB M-K (BYTE-FIELD 10. 0)	;ASSURE POSITIVE OFFSET IN CASE OF WRAPAROUND
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       ((M-K) ADD M-K A-PDL-BUFFER-VIRTUAL-ADDRESS)

; CONVERT VIRTUAL ADDRESS IN M-K INTO PDL-BUFFER-INDEX (ASSUMING IT REFERENCES THE CURRENT
;STACK GROUP).  NOTE THIS DOES NOT ASSURE THAT SECTION OF PDL SWAPPED IN OR ANYTHING.
;IF AND WHEN IT IS SWAPPED IN, HOWEVER, IT WILL OCUPPY THE INDICATED PDL-BUFFER ADDRESS.

GET-PDL-BUFFER-INDEX
	((M-K) SUB M-K A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(POPJ-AFTER-NEXT 
	 (M-K) ADD M-K A-PDL-BUFFER-HEAD)
       ((M-K) (BYTE-FIELD 10. 0) M-K)

;TAKE INTERPRETER TRAP

INTP1	((M-B) SUB M-S A-AP)		;COMPUTE INCREMENT TO M-AP
	((M-B) (BYTE-FIELD 10. 0) M-B)  ;AVOID LOSSAGE FROM WRAPAROUND
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
	((M-AP) M-S)
	(JUMP-EQUAL A-NARGS M-ZERO INTP1A)	;NO ARGS
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;TO VIRTUAL ADDRESS
       ((M-K) ADD A-ZERO M-AP ALU-CARRY-IN-ONE)	;RETURN RESULT IN M-K WITH NO GARBAGE 
	((M-T) DPB M-K Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))	;ARG LIST PTR
INTP1B	((PDL-BUFFER-INDEX) ADD (A-CONSTANT (EVAL %LP-CALL-STATE)) M-AP)
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX INTP5)
							;DUMMY UP ADDTL INFO
INTP5R1	(CALL P3ZERO)
INTP5R	((ARG-CALL REF-SUPPORT-VECTOR) (I-ARG SVCAPL))	;GET FTCN CELL OF APPLY-LAMBDA
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;PUSH IT
	((PDL-BUFFER-INDEX) M-AP)
	((C-PDL-BUFFER-POINTER-PUSH) DPB C-PDL-BUFFER-INDEX ;ARG 1 = FCN BEING CALLED
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T		 ;ARG 2 = ARG LIST
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	((ARG-CALL MMCALL) (I-ARG 2))
INTRET	(JUMP QMEX1)

INTP1A	(JUMP-XCT-NEXT INTP1B)
       ((M-T) A-V-NIL)			;ARG LIST IS NIL

;SENDING ADI CALL TO INTERPRETER.. LOOK AT ADI AND MAYBE HACK...
INTP5	((PDL-BUFFER-INDEX M-R) SUB M-S (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	((M-A) SETZ A-ZERO M-ZERO)	;M-A HAS 0 OR BFLAG, AS APPRO TO IOR WITH
					;ANY ADI PUSHED. IN NON-ZERO AT END, SOME ADI
					;HAS BEEN PUSHED.
	((M-B) PDL-BUFFER-POINTER)	;SAVE STACK POSITION OF LAST ARG (SEE INTP20)
INTP6	(DISPATCH (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX
			INTP-ADI-DISPATCH)
(LOCALITY D-MEM)
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
INTP-ADI-DISPATCH
	(P-BIT ILLOP)	;ERR
	(INTP10)	;MULTIPLE-VALUE-RETURN
	(INTP7)		;RESTART-PC
	(INTP20)	;FEXPR CALL
	(INTP20)	;LEXPR CALL
  (REPEAT 3 (P-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

INTP7	((PDL-BUFFER-INDEX M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX INTP9)
	(JUMP-XCT-NEXT INTP6)
       ((PDL-BUFFER-INDEX M-R) SUB M-R (A-CONSTANT 1))

INTP10	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;FOUND VALUE RETURNNING ADI
       ((M-K) M-R)					;PUSH INDIRECT POINTER TO IT
	((C-PDL-BUFFER-POINTER-PUSH) IOR A-A M-K)
	((M-A) DPB (M-CONSTANT -1) Q-FLAG-BIT A-ZERO)   ;ADI FROM NOW ON HAS THIS BIT ON.
	(JUMP-XCT-NEXT INTP7)
       ((C-PDL-BUFFER-POINTER-PUSH) IOR M-A (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%ADI-TYPE (EVAL ADI-RETURN-INFO)))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION (EVAL ADI-ST-INDIRECT)))))

INTP20	((M-1) A-NARGS)		;HERE IF LAST SLOT HAS REST ARG.
	((PDL-BUFFER-INDEX) M-B)	;SAVED PDL POSITION OF LAST ARG
	(JUMP-GREATER-THAN M-1 (A-CONSTANT 1) INTP21)
	(JUMP-XCT-NEXT INTP7)	;FIRST (AND LAST) SLOT IS ALREADY LIST OF ARGS
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX) ;SO REPLACE LIST-OF-ARGS POINTER WITH IT.

;GET HERE IF FCTN WAS CALLED WITH BOTH SPREAD AND REST ARGS.  MUNGE CDR CODES
; OF LAST SPREAD ARG AND THE REST ARG TO FULL-NODE, THUS NCONC ING THEM TOGETHER.
INTP21	((C-PDL-BUFFER-INDEX) DPB C-PDL-BUFFER-INDEX Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-ERROR)))		;REST ARG
	((PDL-BUFFER-INDEX) SUB M-B (A-CONSTANT 1))		;TO POINT TO LAST SPREAD ARG
	(JUMP-XCT-NEXT INTP7)
       ((C-PDL-BUFFER-INDEX) DPB C-PDL-BUFFER-INDEX Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NORMAL)))

INTP9	(JUMP-EQUAL M-A A-ZERO INTP5R1)	;NO ADI PUSHED, IGNORE THE WHOLE THING
	(CALL UAPLY4)		;LIKE P3ZERO, BUT SET LPADL BIT
	(JUMP INTP5R)

REF-SUPPORT-VECTOR	
	((VMA-START-READ) ADD READ-I-ARG A-V-SUPPORT-ENTRY-VECTOR)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	(POPJ)

(ASSIGN SVCAPL 3)	;APPLY-LAMBDA

;CALLING SYMBOL AS FUNCTION
QMRCL1	((VMA-START-READ M-VMA-HELD) ADD M-A	;GET FUNCTION CELL
		(A-CONSTANT 2))
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE 
		READ-MEMORY-DATA ILLOP-ON-BAD-FUNCTION-DATA-TYPE)
	((M-ZR) MICRO-STACK-DATA-POP)		;NOTE THIS DOES A LDB TYPE OP
	((M-ZR) ADD M-ZR (A-CONSTANT -1))	;PREPARE TO UNSKIP ON RETURN
	((OA-REG-LOW) DPB M-ZR OAL-JUMP A-ZERO)
	(JUMP-XCT-NEXT 0)				;UNSKIP AND REDISPATCH
       ((C-PDL-BUFFER-INDEX M-A) READ-MEMORY-DATA)	;STORE NEW FROB TO CALL

;CALLING CLOSURE AS FUNCTION
QCLS	(CALL-XCT-NEXT QCAR)		;INTERRUPT IS OK HERE, ISNT IT?
       ((M-T C-PDL-BUFFER-POINTER-PUSH) M-A)
	((PDL-BUFFER-INDEX) M-S)
	((C-PDL-BUFFER-INDEX M-A) M-T)	;REPLACE CLOSURE WITH CLOSED FCTN
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)	;GET BACK CLOSURE AND CDR IT.
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-CLOSURE-BINDING-BLOCK-PUSHED)
		C-PDL-BUFFER-INDEX QCLS1) ;JUMP ON CLOSURE BLOCK IN PROGRESS, APPEND THIS ONE	
	((M-QBBFL) DPB M-ZERO A-FLAGS)	;THIS WILL BE A NEW BLOCK
QCLS1	(JUMP-EQUAL M-T A-V-NIL QCLS2)
	(CALL-XCT-NEXT QCAR)
       ((M-D) M-T)
	((M-B) M-T)			;LOCN TO BIND
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-D)
	(CALL-XCT-NEXT QCAR)		;GET NEW BINDING
       ((M-D) M-T)
	(CALL-XCT-NEXT QBND2)		;SAVE PREVIOUS BINDING
       ((C-PDL-BUFFER-POINTER-PUSH M-B) DPB M-B Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	((VMA-START-READ M-VMA-HELD) M-B)	;READ OUT THE CELL BEING BOUND
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	  ;IF THIS CAN LOSE, THERES OTHERS
	;((VMA) READ-MEMORY-DATA)	;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)
	((VMA) M-VMA-HELD)		;RESTORE VMA
	((M-T) DPB M-T Q-POINTER        ;SWITCH DATA TYPE.. (DOING IT THIS WAY AVOIDS PROBLEMS
				        ;WITH CAR ABOVE AS WELL AS GENERALLY REDUCING 
					;PROFUSION OF FUNNY DATA TYPES)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTERNAL-VALUE-CELL-POINTER)))
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT Q-ALL-BUT-TYPED-POINTER 
		READ-MEMORY-DATA A-T)		;WRITE BACK NEW VALUE (AN EVCP)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-D)
	(JUMP QCLS1)

QCLS2	(JUMP-IF-BIT-CLEAR M-QBBFL QCLS2A)
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((C-PDL-BUFFER-INDEX) IOR C-PDL-BUFFER-INDEX 
		(A-CONSTANT (BYTE-MASK %%LP-CLS-CLOSURE-BINDING-BLOCK-PUSHED)))
QCLS2A	((PDL-BUFFER-INDEX) M-S)
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)
       (NO-OP)			;LEAVE, IF ANY, ALREADY DONE


CALL-SELECT-METHOD
	(CALL-EQUAL M-ZERO A-NARGS TRAP)	;NOT ENUF ARGS
  (ERROR-TABLE TOO-FEW-ARGS-TO-SELECT-METHOD M-A)
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT 1))  ;FETCH MESSAGE KEY
	((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	((M-T) DPB M-A Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
CSM-3	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((M-ZR) Q-DATA-TYPE M-T)		;M-T HAS ASSQ-LIST ELEMENT
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) CSM-1)   ;NOT METHOD-KEY, METHOD PAIR
	(CALL-XCT-NEXT QCAR)
       ((M-J) M-T)
	(JUMP-EQUAL M-T A-C CSM-2)	;FOUND IT
	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) CSM-7)  ;ASSQ KEY A LIST, DO MEMQ ON IT
CSM-5  ((M-T) C-PDL-BUFFER-POINTER-POP)
	(CALL QCDR)
	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) CSM-3)
	(CALL-EQUAL M-T A-V-NIL TRAP)			;SELECTED METHOD NOT FOUND
  (ERROR-TABLE SELECTED-METHOD-NOT-FOUND M-A)
	((VMA-START-READ M-VMA-HELD) ADD M-T   ;NON-NIL TERMINATION IS SUPER-CLASS POINTER
		(A-CONSTANT 2))		       ; ACCESS ITS FUNCTION CELL, AND CONTINUE
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT CSM-3)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

CSM-7	((C-PDL-BUFFER-POINTER-PUSH) M-A)   ;ASSQ KEY A LIST, DO MEMQ ON IT
	(CALL-XCT-NEXT XMEMQ1)		    ; TAKES ARGS IN M-A, M-T
       ((M-A) M-C)
	(JUMP-EQUAL-XCT-NEXT M-T A-V-NIL CSM-5)
       ((M-A) C-PDL-BUFFER-POINTER-POP)    ;RESTORE M-A
CSM-2	(CALL-XCT-NEXT QCDR)		;FOUND DESIRED METHOD KEY.  GET ASSOC FCTN
       ((M-T) SETA A-J C-PDL-BUFFER-POINTER-POP) ; FROM ASSQ ELEMENT, FLUSH GARBAGE FROM STACK
CSM-6	((PDL-BUFFER-INDEX) M-S)
	((C-PDL-BUFFER-INDEX M-A) SELECTIVE-DEPOSIT Q-ALL-BUT-TYPED-POINTER 
		C-PDL-BUFFER-INDEX A-T)	;CLOBBER INTO LP-FEF SLOT, REPLACING DTP-SELECT-METHOD
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)
       (NO-OP)

CSM-1	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FIX)) CSM-4)
	((M-1) Q-POINTER M-T)			;ASSQ ELEMENT A FIXNUM. THAT MEANS
	(CALL-GREATER-THAN M-1 A-NARGS TRAP)	; IT GIVES THE NUMBER OF ARG TO
 (ERROR-TABLE SELECT-METHOD-FIXNUM-INDEX-HIGHER-THAN-NUMBER-OF-ARGS M-A)
	((PDL-BUFFER-INDEX) ADD M-S A-1)	; BE USED TO DO SELECTION
	(JUMP-XCT-NEXT CSM-5)
       ((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)

CSM-4	(JUMP-XCT-NEXT CSM-6)	;ASSQ ELEMENT NOT LIST, NOT FIXNUM.  ASSUME IT IS
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP) ;FUNCTION TO BE USED IN OTHERWISE CASE

;;; STUFF FOR CALLS WITH NUMBER OF ARGUMENTS NOT KNOW AT COMPILE TIME

;NOTE %PUSH AND %OPEN-CALL-BLOCK SHOULD CHECK FOR MAKING A FRAME BIGGER THAN 400
; AND %ASSURE-PDL-ROOM SHOULD BE FLUSHED.  MAKE SURE QMOD REALLY CALLS %PUSH.

XOCB  (MISC-INST-ENTRY %OPEN-CALL-BLOCK)  ;<FCTN><ADI-PAIRS><DEST>
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL M-C (A-CONSTANT 4) XOCB0)	;NOT DEST RETURN D-RETURN
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-CLEAR C-PDL-BUFFER-INDEX (LISP-BYTE %%LP-CLS-ADI-PRESENT) XOCB0)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))	;RETURNS MEM-POINTER  IN M-K
	((C-PDL-BUFFER-POINTER-PUSH) M-K)		;STORE INDIRECT ADI POINTER
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%ADI-TYPE (EVAL ADI-RETURN-INFO )))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION (EVAL ADI-ST-INDIRECT)))))
	((M-A) ADD M-A (A-CONSTANT 1))			;ONE MORE ADI PAIR.
XOCB0	(JUMP-EQUAL M-A A-ZERO CBM0)		;IF NO ADI, PUSH REGULAR CALL BLOCK
	((PDL-BUFFER-INDEX M-K) PDL-BUFFER-POINTER)
	((M-A) ADD M-A A-A)			;2 QS PER ADI PAIR
XOCB1	((A-TEM1) C-PDL-BUFFER-INDEX)		;TO SAVE AN A-CONSTANT
	((C-PDL-BUFFER-INDEX) DPB (M-CONSTANT -1) Q-FLAG-BIT A-TEM1)
	((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
	(JUMP-NOT-EQUAL-XCT-NEXT M-A (A-CONSTANT 2) XOCB1)
       ((M-A) SUB M-A (A-CONSTANT 1))
	((A-TEM1) C-PDL-BUFFER-INDEX)		;TO SAVE AN A-CONSTANT
	(CALL-XCT-NEXT CBM0)		;PUT ON CALL BLOCK BUT TAKE DEST FROM M-C
       ((C-PDL-BUFFER-INDEX)		;CLEAR FLAG BIT IN LAST WD OF ADI
		DPB M-ZERO Q-FLAG-BIT A-TEM1)
	(POPJ-AFTER-NEXT		;M-ZR LEFT COPY OF C-PDL-BUFFER-POINTER
	 (PDL-BUFFER-INDEX) ADD M-ZR (A-CONSTANT (EVAL %LP-CALL-STATE)))
       ((C-PDL-BUFFER-INDEX) IOR C-PDL-BUFFER-INDEX
		(A-CONSTANT (BYTE-MASK %%LP-CLS-ADI-PRESENT)))

	
XAOCB (MISC-INST-ENTRY %ACTIVATE-OPEN-CALL-BLOCK)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DONT RETURN TO MISC
	(JUMP-XCT-NEXT QMRCL)
       ((C-PDL-BUFFER-POINTER) DPB C-PDL-BUFFER-POINTER
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
		
XPUSH (MISC-INST-ENTRY %PUSH)
	(POPJ-AFTER-NEXT 
	  (M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
       (NO-OP)

XAPDLR (MISC-INST-ENTRY %ASSURE-PDL-ROOM)
	(POPJ-AFTER-NEXT		;***** NOT REALLY IMPLEMENTED YET
	 (M-T) C-PDL-BUFFER-POINTER-POP)
       (NO-OP)

;(%SPREAD D-NEXT) sends the elements of the list which is
;on the top of the stack to D-NEXT.  (%SPREAD D-LAST) is similar
;but sends the last one to D-LAST.
XSPREAD (MISC-INST-ENTRY %SPREAD)
	((A-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XSPREAD-1
	(JUMP-EQUAL M-T A-V-NIL XSPREAD-EMPTY)
	(CALL-XCT-NEXT QMA)
       ((M-A) A-T)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T
		Q-TYPED-POINTER (A-CONSTANT (BYTE-VALUE CDR-CODE CDR-NEXT)))
	(CALL-XCT-NEXT QMD)
       ((M-T) A-A)
	(JUMP XSPREAD-1)

XSPREAD-EMPTY
	((M-T) M-INST-DEST)
	(JUMP-EQUAL M-T (A-CONSTANT D-LAST) XAOCB)
	((M-GARBAGE) MICRO-STACK-DATA-POP)
	(POPJ)
	
;DO "LINEAR" LEAVE, I.E. STORE EXIT STATE WORD
;  (CALL QLLV) SHOULD BE AFTER DISPATCH ON M-QMRCL IF CURRENT EXECUTION MODE
;	IS RUNNING MACRO-CODE.
QLLV	((PDL-BUFFER-INDEX) M-AP)		;GET POINTER TO
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)	; CURRENTLY RUNNING FEF
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
	((A-TEM1) Q-POINTER C-PDL-BUFFER-INDEX)
	((M-D) SUB M-PC A-TEM1)			;MAKE PC RELATIVE TO IT
	((M-D) SUB M-D A-TEM1)			;..
	((A-TEM2) DPB M-FLAGS (LISP-BYTE %%LP-EXS-PC-STATUS)  ;SAVE STATUS BITS
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT 
	 (PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
       ((C-PDL-BUFFER-INDEX) 
	   DPB M-D (LISP-BYTE %%LP-EXS-EXIT-PC) A-TEM2)	;STORE EXIT STATE WORD

;GET HERE WHEN RESUMING A STACK GROUP WHOSE ACTIVE FRAME IS A FEF.
;DONT RESTORE M-FLAGS, ETC, BECAUSE THAT IS HANDLED BY SG RESUME MECHANISM.
QLLENT	((M-A) C-PDL-BUFFER-INDEX)	;SET UP FROM M-AP
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((A-QLOCO) (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((A-TEM1) (LISP-BYTE %%LP-EXS-EXIT-PC) C-PDL-BUFFER-INDEX)
	((A-TEM1) ADD A-TEM1 M-A)
	((M-PC) ADD A-TEM1 M-A LOAD-LOW-PC-BIT)		      ;RESTORE PC
;PC HAS BEEN INCREMENTED, COMPENSATE WHEN LOADING M-INST-BUFFER
	((VMA-START-READ) SUB M-PC (A-CONSTANT 1)
		OUTPUT-SELECTOR-RIGHTSHIFT-1)  ;GET MAIN LOOP BACK
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	      ;INTO PHASE
	((M-2) MICRO-STACK-DATA-POP)		;SAVE RETURN TO QLLENT
	((A-GARBAGE) MICRO-STACK-DATA-POP)	;FLUSH OLD MAIN LOOP RETURN
	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 0) M-PC QLLENT-PC-ODD)
       ((M-1) (A-CONSTANT (I-MEM-LOC QMLPOD1)))
	((M-1) (A-CONSTANT (I-MEM-LOC QMLP)))	;M-INST-BUFFER HAS CURRENT INSTRUCTION, NOT
						; NEXT INSTRUCTION, SO GO TO QMLP, NOT QMLPEV1
QLLENT-PC-ODD
	((MICRO-STACK-DATA-PUSH) M-1) 	        ;PUSH A NEW ONE OF THE RIGHT FLAVOR
	((OA-REG-LOW) DPB M-2 OAL-JUMP A-ZERO)
	(JUMP-XCT-NEXT 0)
       ((M-INST-BUFFER) READ-MEMORY-DATA)	;AND RESTORE INSTRUCTION BUFFER

;DO "MICRO" LEAVE, I.E. STORE EXIT STATE IF CURRENT EXECUTION MODE
;	IS RUNNING A MICRO-CODED FUNCTION (NORMALLLY MICRO-COMPILED FCTNS).
; (CALL MLLV) SHOULD APPEAR AFTER THE DISPATCH ON D-QMRCL IN THIS CASE.
;   THE MAIN WORK DONE HERE IS TRANSFERING THE U-STACK TO A USTACK BLOCK
;   IN MAIN MEMORY.  HOWEVER, THE TOP ENTRY ON THE USTACK IS THE RETURN ADDRESS
;   PUT ON BY THE (CALL MLLV).
;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
MLLV	((M-2) MICRO-STACK-DATA-POP)
	(CALL QMMPSH)
	((MICRO-STACK-DATA-PUSH) M-2)	;PUT BACK "REAL" RETURN
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	(POPJ-AFTER-NEXT 
	 (A-TEM1) C-PDL-BUFFER-INDEX)
       ((C-PDL-BUFFER-INDEX) DPB M-T A-TEM1 (LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT))

;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
QMMPSH	((M-ZR) MICRO-STACK-DATA-POP)	;GET REAL RETURN OFF MICRO-STACK
	((M-1) ADD (M-CONSTANT 40) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 TRAP)  ;RESULT HAD BETTER BE NEGATIVE
  (ERROR-TABLE PDL-OVERFLOW SPECIAL)			 ; (AS A 24. QUANTITY)
	((M-T) A-ZERO)
MLLV1	((M-Q) MICRO-STACK-POINTER)	;NOTE THIS INVOLVES A LDB TYPE OPERATION
	(JUMP-EQUAL M-Q A-ZERO MLLV2)	;XFER ON THRU WITH PDL TRANSFER
					; IE ALL OFF BUT RETURN TO MAIN LOOP
	((M-Q) MICRO-STACK-DATA-POP)	;NOTE THIS INVOLVES A LDB TYPE OPERATION
	(JUMP-NOT-EQUAL-XCT-NEXT M-T A-ZERO MLLV3)
       ((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE) 
	((M-Q) DPB (M-CONSTANT -1) Q-FLAG-BIT A-Q)	;FIRST IN BLOCK
MLLV3	((WRITE-MEMORY-DATA) IOR M-Q 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) A-QLBNDP)
	(CALL-CONDITIONAL PG-FAULT PGF-W)  ;NO INT BECAUSE BIND STACK STATE NOT
	(JUMP-XCT-NEXT MLLV1)		   ; REALLY CONSISTENT NOW (IE XFER COUNT NOT
       ((M-T) ADD M-T (A-CONSTANT 1))	   ; STORED)

MLLV2	((OA-REG-LOW) DPB M-ZR OAL-JUMP A-ZERO)
	(JUMP 0)			;RETURN

;OPEN MICRO-TO-MACRO CALL BLOCK
P3ZERO	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
MMASU1	((M-ZR) PDL-BUFFER-POINTER)
	((M-ZR) ADD (A-CONSTANT (EVAL (1- %LP-CALL-BLOCK-LENGTH))) M-ZR) ;1- BECAUSE OF PUSH JUST DONE
	((M-K) SUB M-ZR A-IPMARK)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) A-ZERO)
	((M-K) SUB M-ZR A-AP)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) A-TEM1)
	((C-PDL-BUFFER-POINTER)		;IOR WITH LPCLS Q ALREADY PUSHED
	  IOR C-PDL-BUFFER-POINTER A-TEM1)
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPEXS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT 				;PUSH LPENS Q
	  (C-PDL-BUFFER-POINTER-PUSH)
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)		;CALLER MUST PUSH LPFEF Q

;ENTER MICRO-CODE ENTRY FCTN
; M-S HAS NEW VALUE FOR M-AP, 0(M-S) IS FUNCTION BEING
; CALLED (ALSO IN M-A), 1(M-S) IS 1ST ARG, 2(M-S) IS 2ND, ETC.
; A-IPMARK AND A-NARGS ARE SET UP AND CALLING FCN HAS BEEN LEFT.

QME1	((M-D) Q-POINTER M-A)
	(CALL-GREATER-OR-EQUAL M-D A-AMCENT TRAP)	;OUT OF RANGE
  (ERROR-TABLE ILLEGAL-INSTRUCTION)
	((M-B) SUB M-S A-AP)		;COMPUTE INCREMENT TO M-AP
	((M-B) (BYTE-FIELD 10. 0) M-B) ;AVOID LOSSAGE FROM WRAPAROUND
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN M-PDL-BUFFER-ACTIVE-QS 	;CLOBBERS VMA
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
	((VMA-START-READ) ADD M-D A-V-MICRO-CODE-ENTRY-AREA)  ;GET STARTING ADR
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	((M-AP) M-S)
	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-ZERO)
							;CLEAR OUT FLAGS
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) QME1A)
;DTP-U-ENTRY "INDIRECTS" THE REFERENCE TO MISC-INST N.  THIS FEATURE IS PROVIDED
;SO THAT IT IS NOT NECESSARY TO RE-COLD-LOAD WHEN NEW MICRO-CODE WITH DIFFERENT
;ENTRY POINTS IS LOADED.
	((VMA-START-READ) ADD READ-MEMORY-DATA A-V-MICRO-CODE-SYMBOL-AREA)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
QME1A	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT)
		C-PDL-BUFFER-INDEX QME2)	;JUMP IF THIS AN ADDTL INFO CALL
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(CALL 0)			;CALL THE MICRO ENTRY
QMER	(JUMP QMEX1)

QME2	((MICRO-STACK-DATA-PUSH)
		(A-CONSTANT (PLUS (BYTE-MASK %%-PPBMAA)
				  (I-MEM-LOC QMER))))  ;PUSH FUNNY RETURN
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(JUMP 0)

;;; DESTINATION RETURN
QMDDR	(CALL-IF-BIT-SET M-QBBFL BBLKP)		;POP BINDING BLOCK (IF STORED ONE)
QMEX1	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-B) C-PDL-BUFFER-INDEX)		;M-B := CALL STATE
	(CALL-IF-BIT-SET M-B (LISP-BYTE %%LP-CLS-CLOSURE-BINDING-BLOCK-PUSHED) BBLKP)
	((PDL-BUFFER-POINTER) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH))) ;FLUSH PDL
	(CALL-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) M-B QRAD1)  ;FLUSH ADDTL INFO
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-B)
	(JUMP-EQUAL M-ZERO A-TEM1 QMXSG)	;RETURNING OUT TOP OF STACK-GROUP
	((M-ZR) SUB M-AP A-TEM1)		;COMPUTE PREV A-IPMARK
	((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;RESTORE THAT
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) M-B)
	((PDL-BUFFER-INDEX) SUB M-AP A-TEM1)		;RESTORE M-AP
	((M-AP) PDL-BUFFER-INDEX)		;THIS OPERATION MASKS M-AP TO 10 BITS.
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-PDL-BUFFER-ACTIVE-QS A-TEM1)
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS 
			(A-CONSTANT PDL-BUFFER-LOW-WARNING) PDL-BUFFER-REFILL)
	(DISPATCH-XCT-NEXT (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE 
		C-PDL-BUFFER-INDEX QMXRT)
       ((M-A) Q-POINTER C-PDL-BUFFER-INDEX)		;FUNCTION RETURNNING TO

;	(CALL-NOT-EQUAL M-J (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
QMEXF	((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) M-B)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((A-QLOCO) (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
;	((A-TEM1) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX)
;	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS	;RESTORE "PROCESSOR FLAGS"
;			M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-TEM1)
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	((A-TEM1) (LISP-BYTE %%LP-EXS-EXIT-PC) C-PDL-BUFFER-INDEX)
	((A-TEM1) ADD A-TEM1 M-A)
	((M-PC) ADD A-TEM1 M-A LOAD-LOW-PC-BIT)		      ;RESTORE PC
	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)  ;GET MAIN LOOP BACK
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	      ;INTO PHASE
	((A-GARBAGE) MICRO-STACK-DATA-POP)		      ;FLUSH OLD MICRO RETURN
	((M-INST-BUFFER) READ-MEMORY-DATA)		      ;PUSH A NEW ONE OF THE
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-PC QMDDR-PC-ODD)  ;RIGHT FLAVOR
	(JUMP-XCT-NEXT QIMOVE-EXIT)		;PC EVEN
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMLPEV1)))

QMDDR-PC-ODD
	(JUMP-XCT-NEXT QIMOVE-EXIT)		;PC ODD
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMLPOD1)))

;FUNCTION TYPE= LIST, RETURN TO INTERPRETER
QMMRL	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-LAST-MICRO-ENTRY) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-LAST-MICRO-ENTRY (A-CONSTANT (I-MEM-LOC INTRET)) ILLOP)
;DROPS IN-- FUNCTION TYPE= UCODE-ENTRY.
QMMR2	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
;	((A-TEM1) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX)
;	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS	;RESTORE "PROCESSOR FLAGS"
;			M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-TEM1)
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	((M-LAST-MICRO-ENTRY) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	(CALL QMMPOP)		;RESTORE USTACK FROM BINDING STACK
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB M-LAST-MICRO-ENTRY OAL-JUMP A-ZERO)
	(JUMP 0)

QMMPOP	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((M-J) (LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT) C-PDL-BUFFER-INDEX)
;*** A MICRO-INSTRUCTION COULD BE SAVED HERE IF THE ALL-BUT-LISP-BYTE PSEUDO EXISTED
	((M-ZR) C-PDL-BUFFER-INDEX)	;DONT LEAVE GARBAGE AROUND IN XFER COUNT
	((C-PDL-BUFFER-INDEX) DPB M-ZERO 
		(LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT) A-ZR)
QMMPO1	((M-S) MICRO-STACK-DATA-POP)	;POP OFF RETURN  ENTER HERE FROM SG STUFF.
	(JUMP-EQUAL M-J A-ZERO QMMPOX)
QMMPO2	((VMA-START-READ M-ZR) A-QLBNDP)	;NO TRANSPORT, KNOWN TO BE A FIXNUM
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;BIND STACK NOT REALLY CONSISTENT, NO INTR
	((M-J) SUB M-J (A-CONSTANT 1))
	((A-QLBNDP) SUB M-ZR (A-CONSTANT 1))
	((MICRO-STACK-DATA-PUSH) READ-MEMORY-DATA)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FIX)) ILLOP)
	(JUMP-EQUAL M-J (A-CONSTANT 0) QMMPO3)	;THIS TO BE LAST TIME?
	(JUMP-XCT-NEXT QMMPO2)
       (CALL-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA ILLOP)  ;FIRST WD OF BLOCK?

QMMPO3	(CALL-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA ILLOP) ;LAST WD SHOULD HAVE BIT
QMMPOX	((OA-REG-LOW) DPB M-S OAL-JUMP A-ZERO)
	(JUMP 0)

;GET HERE WHEN RETURNING OUT TOP OF STACK GROUP
QMXSG	((PDL-BUFFER-POINTER) M-AP)	;AVOID GROSS SCREW WHERE P-F ROUTINES GET CONFUSED
		;ABOUT WHATS IN THE PDL-BUFFER DUE TO FACT PDL-BUFFER-POINTER WAS DECREMENTED
		;TO BEFORE ACTIVE CALL BLOCK (IE 1777 IF SG STARTED OFF AT 0@P)
	((VMA) A-QCSTKG)	;ERROR CHECK TO SEE IF DELTA S SCREWWED OR SOMETHING
	((VMA-START-READ M-VMA-HELD) SUB VMA
		 (A-CONSTANT (PLUS 2 (EVAL SG-INITIAL-FCTN-INDEX))))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-SG-TEM) M-T)	;VALUE GETTING RETURNED
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-1) Q-POINTER READ-MEMORY-DATA)
	(CALL-NOT-EQUAL M-AP A-1 ILLOP)
	(JUMP-XCT-NEXT SG-RETURN-2)	;RETURN THIS LAST VALUE AND GO TO EXHAUSTED STATE
       ((M-3) (A-CONSTANT (EVAL SG-STATE-EXHAUSTED)))


;STORE LAST VALUE IN ADI CALL, FLUSH ADI FROM PDL
QRAD1	((PDL-BUFFER-INDEX M-K) PDL-BUFFER-POINTER)	;IN CASE ENTERED FROM ARRAY CODE
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QRAD1R)))  ;DONT CARE IF THIS 
							; LAST OR NOT.
	(CALL-XCT-NEXT MVR0)	;STORE THE LAST VALUE INTO MV IF ANY
       ((M-S) A-ZERO)
QRAD1R	((PDL-BUFFER-INDEX M-K) SUB M-AP
		(A-CONSTANT (PLUS 1 (EVAL %LP-CALL-BLOCK-LENGTH)))) ;FLUSH ADI FROM PDL
QRAD2	(POPJ-IF-BIT-CLEAR-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX)
       ((PDL-BUFFER-POINTER) SUB M-K (A-CONSTANT 1))
	(JUMP-XCT-NEXT QRAD2)
       ((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 2))

XRETN (MISC-INST-ENTRY %RETURN-N)		;RETURN N VALUES, LAST ARG IS N.
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;NOT RETURNING TO 'MISC'
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-POINTER ERROR-UNLESS-FIX)
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP) ;NUMBER OF VALUES TO RETURN
XRETN1	((M-C) SUB M-C (A-CONSTANT 1))
	(JUMP-LESS-OR-EQUAL M-C A-ZERO XRETN2) ;LAST
	((M-1) PDL-BUFFER-POINTER)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB M-1 A-C)		;NEXT ARGUMENT SLOT
	(JUMP XRETN1)

XRET2 (MISC-INST-ENTRY %RETURN-2)
	(JUMP-XCT-NEXT XRET2A)
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'

XRET3 (MISC-INST-ENTRY %RETURN-3)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((M-1) PDL-BUFFER-POINTER)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 2))
XRET2A	((M-1) PDL-BUFFER-POINTER)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 1))
XRETN2	(JUMP-XCT-NEXT QMDDR)			;RETURN LAST VALUE REGULAR WAY
       ((M-T) C-PDL-BUFFER-POINTER)

XRETURN-LIST (MISC-INST-ENTRY RETURN-LIST)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XRETURN-LIST-1
	; After exhausting arg, return a NIL back to MISC, which will give it to D-RETURN.
	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QMA)
       ((M-C) A-T)
	;Next element in M-T, list tail in M-C.  Return the element.
	;Push the address to return to if have no more values wanted.
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XRETURN-LIST-2)))
	(CALL XRNVR)
	(CALL-XCT-NEXT QMD)
       ((M-T) A-C)
	(JUMP XRETURN-LIST-1)

	;No more values wanted => return to MISC which will go to D-RETURN routines.
XRETURN-LIST-2
	(POPJ)

XRNV (MISC-INST-ENTRY RETURN-NEXT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;GO TO QMDDR IF LAST
						;  VALUE.
	(CALL-XCT-NEXT XRNVR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FROB TO RETURN
	(JUMP QIMOVE1)				;STORE IN DESTINATION

;XRNVX MOVED BELOW
;XRNVX	(JUMP-XCT-NEXT QMDDR)			;NO MORE ADI, RETURN LAST VALUE REGULAR
;       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;WAY, FLUSHING XRNVR'S POPJ ADDRESS.

;RETURN NEXT VALUE.  SEE COMMENTS BELOW FOR INFO ON SPECIAL CALLING SEQUENCE.
XRNVRPI	((M-T) C-PDL-BUFFER-INDEX)
XRNVR	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX XRNVX)
	((M-S) (A-CONSTANT 1))			;SET FLAG AND DROP INTO MVR

;STORE A RETURN VALUE (FROM M-T) IN A MULTIPLE-VALUE CALL
;M-S 1 IF CALLING FROM %RETURN-NEXT-VALUE, 0 IF FROM FROM DESTINATION RETURN
;THIS CONTROLS THE HACK OF %RETURN-NEXT-VALUE TURNING INTO DESTINATION
;RETURN WHEN RETURNING THE LAST VALUE THE CALLER WANTED.
;ALSO, WHEN M-S IS 0 THE MULTIPLE VALUE ADI INTO WHICH THE RETURN
;VALUE IS ACTUALLY STORED (IF ANY) IS CHANGED FROM ADI-RETURN-INFO
;TO ADI-USED-UP-RETURN-INFO.  THIS ENSURES THAT THE LAST VALUE ISN'T
;RETURNED N TIMES WHEN N TAIL-RECURSIVE CALLS ARE CHAINED TOGETHER
;WITH INDIRECT ADI POINTERS, AS HAPPENS WITH 'EVAL' FOR INSTANCE.

;PROPOSED NEW FROB..
;  CALL WITH VALUE TO RETURN IN M-T PLUS TWO FROBS ON USTACK AND ALSO AN ARG IN M-S.
;M-S -> 0 DOING A "REGULAR" RETURN.  IN ADDITION TO RETURNING VALUE, THE CALL IS
;  "CLOSED OFF", RETURNING NULL VALUES FOR ANY ADDITIONAL VALUES THAT MIGHT HAVE
;BEEN REQUESTED.
;M-S -> 1 DOING A "RETURN-NEXT-VALUE".  THIS SIGNIFIES AN INTENTION TO EVENTUALLY
;RETURN MORE VALUES.
;  ON "RETURN-NEXT-VALUE" CONTROL RETURNS TO FIRST RETURN IF THIS WAS LAST VALUE EXPECTED,
;OTHERWISE SECOND RETURN.  
;  ON "REGULAR-RETURN", CONTROL MAY RETURN TO EITHER RETURN (DEPENDING ON A FEW NOT
;TOO RANDOM THINGS).  HOWEVER, IN THIS CASE, BOTH RETURNS ARE NORMALLY THE SAME SO
;IT DOESNT MAKE ANY DIFFERENCE.
;  IN ANY CASE, BOTH RETURNS ARE FLUSHED FROM THE STACK.

;  ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC <THAT-WAS-LAST-VALUE-RETURN>)))
;  (CALL MVR)
;  ... STILL EXPECTING MORE VALUES

;SEQUENCE TO RETURN TO FIRST RETURN <THAT-WAS-LAST-VALUE-EXPECTED>
;  ((M-GARBAGE) MICRO-STACK-DATA-POP)
;  (POPJ)

;SEQUENCE TO RETURN TO SECOND RETURN <MORE-VALUES-ARE-EXPECTED>
;  (POPJ-XCT-NEXT)
; ((M-GARBAGE) MICRO-STACK-DATA-POP)

;CLOBBERS A-TEM1, M-I, M-J, M-S, M-R, M-K PLUS CALLS QRDR1 (WHICH DOESNT CLOBBER ANY MORE)
;PLUS CALLS CONS, WHICH CLOBBERS MORE.  PROTECTS M-C BUT PROBABLY NOT ANYTHING ELSE.

;DROPS IN FROM ABOVE
MVR	((PDL-BUFFER-INDEX M-K) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
MVR0	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-INDEX ERROR-UNLESS-FIX)
	((M-J) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-J (A-CONSTANT (EVAL ADI-RETURN-INFO)) MVR1)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ADI-RET-STORING-OPTION)
		C-PDL-BUFFER-INDEX D-MVR)
       ((M-I) (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) C-PDL-BUFFER-INDEX)

MVR1	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)	;INFO OUT OF PHASE
	((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX MVR0) ;MORE
       ((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
MVR2  ;NO ADI, THIS THE LAST VALUE
XRNVX	((M-GARBAGE) MICRO-STACK-DATA-POP)	;FLUSH SECOND RETURN
	(POPJ)					;THAT WAS LAST VALUE, TAKE FIRST RETURN

;	(JUMP-EQUAL M-S (A-CONSTANT 1) XRNVX)	;CAN'T FIND MV ADI, RET REGULAR WAY
;	(POPJ)					;OH, WELL
	
;BLOCK, PNTR TO IT IN PDL BUFFER, BLOCK MAY OR MAY NOT BE
MVRB	(CALL-LESS-OR-EQUAL M-I A-ZERO ILLOP)		;RETURNING TOO MANY VALUES
;LAST
	(JUMP-EQUAL M-I A-S XRNVX)	;LAST AND NOT DOING RETURN, TURN INTO QMDDR!!
	((M-I) SUB M-I (A-CONSTANT 1))
	((M-J) C-PDL-BUFFER-INDEX)
	((C-PDL-BUFFER-INDEX M-J) DPB M-I (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) A-J)
	(JUMP-NOT-EQUAL M-S A-ZERO MVRB0)
	((C-PDL-BUFFER-INDEX M-J) DPB (M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-J)
MVRB0	((PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	((C-PDL-BUFFER-INDEX M-I) ADD C-PDL-BUFFER-INDEX (A-CONSTANT 1))
MVRB1	((VMA-START-READ) SUB M-I (A-CONSTANT 1))	;NO TRANSP, SINCE WRITING AND NO
MVRB2	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NEED TO FOLLOW INVISIBLE PNTRS HERE
;	POPJ-AFTER-NEXT			;STORE THE VALUE
	((WRITE-MEMORY-DATA-START-WRITE)
		SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
        (CALL-CONDITIONAL PG-FAULT PGF-W)
	(POPJ-XCT-NEXT)		;MORE EXPECTED, OR DOING RETURN AND THAT WAS LAST
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;TAKE SECOND RETURN AND FLUSH FIRST

;BLOCK, NOT KNOWN WHETHER ANYTHING IN PDL BUFFER
MVRBV	(CALL-LESS-OR-EQUAL M-I A-ZERO ILLOP)		;RETURNING TOO MANY VALUES
	(JUMP-EQUAL M-I A-S XRNVX)			;LAST, TURN INTO QMDDR!!
	((M-I) SUB M-I (A-CONSTANT 1))
	((A-TEM1) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-S A-ZERO MVRBV0)
	((A-TEM1) DPB (M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-TEM1)
MVRBV0	((WRITE-MEMORY-DATA-START-WRITE)
		DPB M-I (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) A-TEM1)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSP SINCE IT IS A FIXNUM
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((WRITE-MEMORY-DATA-START-WRITE M-I) ADD READ-MEMORY-DATA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(JUMP MVRB1)

;CONS UP LIST, PNTR TO LIST TAIL IN PDL BUFFER
MVRC	(CALL CONVERT-PDL-BUFFER-ADDRESS)
	((VMA) M-K)				;LOCATIVE TO ADI TO VMA, DROP THROUGH

;CONS UP LIST
;2ND (LOWER) ADI WORD POINTS TO LIST TAIL.  INITIALLY IT IS A LOCATIVE
;TO THE LOCATION WHICH WILL EVENTUALLY HOLD THE LIST OF RETURNED VALUES,
;WHICH SHOULD BE INITIALIZED TO NIL.
;AFTER THE FIRST TIME, IT IS A LIST-POINTER TO THE LAST CONS IN THE LIST.
;XNCONS MUSTN'T CLOBBER M-C, M-I, M-R; QRDR1 MUSTN'T CLOBBER M-C OR M-R
MVRCV	((VMA-START-READ M-I) VMA)		;SAVE PNTR+1 TO PNTR TO LIST TAIL
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;GET HIGHER ADI WORD
	(JUMP-NOT-EQUAL M-S A-ZERO MVRCV0)	;NO TRANSPORT SINCE IT IS A FIXNUM
	((A-TEM1) READ-MEMORY-DATA)		;FROM QMDDR, CHANGE TO USED-UP-ADI
	((WRITE-MEMORY-DATA-START-WRITE) DPB
		(M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-TEM1)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
MVRCV0	(CALL-XCT-NEXT XNCONS)			;CONS UP A CONS, CDR NIL, TO M-T
       ((C-PDL-BUFFER-POINTER-PUSH M-R) M-T)	;SAVE VALUE RETURNING, WILL BE CAR
	((VMA-START-READ M-VMA-HELD) SUB M-I (A-CONSTANT 1))	;GET PNTR TO LIST TAIL
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-S) READ-MEMORY-DATA)		;SAVE PNTR TO LIST TAIL
	((VMA) M-VMA-HELD)			;RESTORE THE VMA
	((WRITE-MEMORY-DATA-START-WRITE) M-T)	;CHANGE PNTR TO NEW LIST TAIL
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT PGF-W)
	(CALL QRDR1)				;RPLACD TAIL OF LIST
	(POPJ-XCT-NEXT)		;MORE <INFINITE> VALUES EXPECTED
       ((M-T) SETA A-R MICRO-STACK-PNTR-AND-DATA-POP)    ;RESTORE VALUE BEING RETURNED 
		;AND FLUSH FIRST RETURN. (PNTR-AND-DATA NECC. TO AVOID A BYTE-OP)
;MORE <INFINITE> VALUES EXPECTED.

;INDIRECT POINTER, PNTR TO IT IN PDL BUFFER
MVRI	((PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	((VMA-START-READ) C-PDL-BUFFER-INDEX)	;NO TRANSPORT SINCE IT'S A FIXNUM
;IN THIS PART OF THE CODE WE DON'T KNOW IF ANYTHING IS IN THE PDL BUFFER
MVRV0	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE READ-MEMORY-DATA ERROR-UNLESS-FIX)
	((M-J) (LISP-BYTE %%ADI-TYPE) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-J (A-CONSTANT (EVAL ADI-RETURN-INFO)) MVRV1)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ADI-RET-STORING-OPTION)
		READ-MEMORY-DATA D-MVRV)
       ((M-I) (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) READ-MEMORY-DATA)

MVRV1	(CALL-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA ILLOP)	;INFO OUT OF PHASE
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSPORT SINCE IT'S A FIXNUM
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA MVR2)	;NO MORE ADI
	(JUMP-XCT-NEXT MVRV0)
       ((VMA-START-READ) SUB VMA (A-CONSTANT 2))	;NO TRANSPORT SINCE IT'S A FIXNUM
	
;INDIRECT POINTER, NOT KNOWN WHETHER ANYTHING IN PDL BUFFER
MVRIV	((VMA-START-READ M-VMA-HELD) SUB VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT MVRV0)
       ((VMA-START-READ) READ-MEMORY-DATA)	;NO TRANSPORT SINCE IT'S A FIXNUM

;;; THROW CODE (*THROW, *UNWIND-STACK)
;;; Register Conventions:
;;; A-CATCH-MARK is the function for which an open call is what we want (usually %CATCH)
;;; A-CATCH-TAG is the first argument to that function.  Except, A-CATCH-TAG
;;;  is T if we are throwing all the way.
;;; A-CATCH-COUNT contains a count of active frames.  If this reaches zero, we resume
;;;  that frame instead of throwing farther.  If this is NIL, no count.
;;; A-CATCH-ACTION contains the "action", which is usually NIL, but T to coroutine back
;;;  when we reach the resumption point instead of resuming.

;;; Special *CATCH tags are:
;;;  NIL  CATCH-ALL
;;;  T    UNWIND-PROTECT.  The difference between UNWIND-PROTECT and CATCH-ALL
;;;	  is that UNWIND-PROTECT will always continue throwing, and without
;;;	  messing up the previous stack group pointer, either.

;;; The arguments to *THROW are a tag and a value.  If the tag is NIL
;;; we throw all the way out the top of the stack group, then coroutine
;;; back to the previous stack group.  In this case we bypass CATCH-ALLs.
;;; This is used for unwinding "old" stack groups.
;;; If the tag is not NIL, we throw to the nearest catch with that tag,
;;; or UNWIND-PROTECT, or CATCH-ALL.

;;; *UNWIND-STACK is a generalized *THROW, used by the error handler and
;;; by UNWIND-PROTECT.  The first two arguments are the same as to *THROW.
;;; The third argument is a count; if this NIL things are the same as *THROW,
;;; otherwise if this many frames are passed we resume as if a catch had been found.
;;; The fourth argument, if non-NIL, means that instead of resuming when
;;; we find the point to throw to, we coroutine back.  This is for the error
;;; handler.

XUWSTK (MISC-INST-ENTRY *UNWIND-STACK)
   (ERROR-TABLE RESTART *UNWIND-STACK)
	((A-CATCH-ACTION) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((A-CATCH-COUNT) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT XUWS0)
      ;((A-CATCH-MARK) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
      ;					  *CATCH-U-CODE-ENTRY-/#)))

XTHROW (MISC-INST-ENTRY *THROW)
   (ERROR-TABLE RESTART *THROW)
		;Note the following instruction is also XCT-NEXT'ed from above
	((A-CATCH-MARK) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
					  *CATCH-U-CODE-ENTRY-/#)))
XERR0	((A-CATCH-ACTION) A-V-NIL)
	((A-CATCH-COUNT) A-V-NIL)
XUWS0	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;Value thrown
	((M-1) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;Tag
	(JUMP-EQUAL-XCT-NEXT M-1 A-V-TRUE XTHRW7)	  ;Tag of T means all the way
       ((A-CATCH-TAG) M-1)				  ; so don't check first
;DROPS THROUGH
;DROPS IN
;Before actually going and munging anything, follow the open-call-block chain
;and find out whether the catch tag we're looking for actually exists.
;Register usage:
;  M-A	Virtual address of next call block (typeless) (either active or open)
;  M-B	Virtual address of next active call block (typeless)
;  M-C	Pdl buffer address of next call block (only low 10 bits valid)
;  M-1	arg into / result out of XTHCG
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-AP)
	((M-B) Q-POINTER M-K)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) A-IPMARK)
	((M-A) Q-POINTER M-K)
	((M-C) A-IPMARK)
	(JUMP-NOT-EQUAL M-A A-B XTHC2)			;JUMP IF FOUND OPEN CALL BLOCK
XTHC1	(CALL-XCT-NEXT XTHCG)				;GET CALL STATE Q
       ((M-1) ADD M-A (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) M-1)
	(JUMP-EQUAL M-ZR A-ZERO XTHC-ERROR)	        ;REACHED END OF PDL DIDN'T FIND MARK.
	((M-B) SUB M-B A-ZR)
XTHC4	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-1)
	((M-A) SUB M-A A-ZR)
	(JUMP-EQUAL-XCT-NEXT M-A A-B XTHC1)
       ((M-C) SUB M-C A-ZR)
XTHC2	(CALL-XCT-NEXT XTHCG)				;GET LPFEF Q
       ((M-1) M-A)
	(JUMP-NOT-EQUAL M-1 A-CATCH-MARK XTHC3)		;NO GOOD
	(CALL-XCT-NEXT XTHCG)
       ((M-1) ADD M-A (A-CONSTANT 1))			;GET FIRST ARG
	(JUMP-EQUAL M-1 A-CATCH-TAG XTHRW7)		;FOUND THE ONE WE'RE LOOKING FOR,
							;IT'S NOW SAFE TO GO THROW FOR REAL.
	(JUMP-EQUAL M-1 A-V-NIL XTHRW7)			;FOUND CATCH-ALL, THATS OK TOO.
XTHC3	(CALL-XCT-NEXT XTHCG)				;GET CALL STATE Q
       ((M-1) ADD M-A (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP XTHC4)

XTHC-ERROR
	((M-A) A-CATCH-TAG)
	((M-B) A-CATCH-COUNT)
	((M-C) A-CATCH-ACTION)
	(CALL TRAP)
   (ERROR-TABLE THROW-TAG-NOT-SEEN)	;The EH knows specially about this entry.
					;It knows the tag is in M-A, the value is in M-T,
					;the count is in M-B, and the action is in M-C.
					;It restarts at *THROW (should use *UNWIND-STACK)

;GET A WORD WHOSE UNTYPED VIRTUAL ADDRESS IS IN M-1.  FOR SPEED, ATTEMPTS
;TO FIGURE OUT IF IT IS IN THE PDL BUFFER AND IF SO GET IT DIRECTLY
;WITHOUT BOTHERING WITH PAGE TRAPS.  BASHES M-1 TO Q-TYPED-POINTER OF THE FETCHED DATA.
XTHCG	(JUMP-LESS-THAN M-1 A-PDL-BUFFER-VIRTUAL-ADDRESS XTHCG1)
	((M-1) SUB M-1 A-A)
	(POPJ-AFTER-NEXT (PDL-BUFFER-INDEX) ADD M-1 A-C)
       ((M-1) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)

XTHCG1	((VMA-START-READ M-VMA-HELD) M-1)
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;WILL PROBABLY ALWAYS FAULT
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-1) Q-TYPED-POINTER READ-MEMORY-DATA)

;This is the main throw loop.  Come here for each frame.
XTHRW7	(JUMP-EQUAL-XCT-NEXT M-AP A-IPMARK XTHRW1) ;LAST FRAME ACTIVE, UNWIND IT
       ((M-R) A-V-NIL)				;GET NIL ON THE M SIDE FOR LATER
	((M-I PDL-BUFFER-INDEX) A-IPMARK)	;LAST FRAME OPEN, NOTE IT MUST ALREADY BE IN
						; PDL BUFFER, SINCE ENTIRE ACTIVE FRAME IS.
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-A A-CATCH-MARK XTHRW2)	;THATS NOT WHAT LOOKING FOR
	((PDL-BUFFER-INDEX) ADD A-IPMARK M-ZERO ALU-CARRY-IN-ONE)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-A A-V-TRUE XTHRW4)	;FOUND UNWIND-PROTECT, RESUME IT
	((M-1) A-V-TRUE)
	(JUMP-EQUAL A-CATCH-TAG M-1 XTHRW2)	;IF UNWINDING ALL THE WAY, KEEP LOOKING
	(JUMP-EQUAL M-A A-V-NIL XTHRW4)		;FOUND CATCH-ALL, RESUME IT
	(JUMP-NOT-EQUAL M-A A-CATCH-TAG XTHRW2)	;DIDN'T FIND RIGHT TAG, KEEP LOOKING
;FOUND FRAME TO RESUME
XTHRW4	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-B) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)	;PRESERVE FOR USE BELOW
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX 
		XTHRW9)		;NO ADI, HAD BETTER BE DESTINATION RETURN
	((PDL-BUFFER-INDEX M-D) SUB M-I (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
XTHRW3	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) 
		     Q-DATA-TYPE C-PDL-BUFFER-INDEX ERROR-UNLESS-FIX)
	((M-A) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-A (A-CONSTANT (EVAL ADI-RESTART-PC)) XTHRW8)
	((M-J) (LISP-BYTE %%ADI-RPC-MICRO-STACK-LEVEL) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) SUB M-D (A-CONSTANT 1))
	((M-E) Q-POINTER C-PDL-BUFFER-INDEX)	    ;RESTART PC
	((PDL-BUFFER-INDEX) M-AP)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)	    ;SIMULATES THRWD1 DISP IN LMI
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-B) C-PDL-BUFFER-INDEX)		    ;SO CAN BE DPB ED INTO EASILY
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) XTHWM1)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) XTHWU1)
	(CALL ILLOP)

XTHWU1	((C-PDL-BUFFER-INDEX) DPB M-E A-B (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC))
XTHRW5	((M-ZR) MICRO-STACK-POINTER)		;INVOLVES A LDB OP
	(JUMP-EQUAL A-ZR M-J XTHRW6)
	((M-ZR) MICRO-STACK-DATA-POP)
	(CALL-IF-BIT-SET %%-PPBSPC M-ZR BBLKP)
	(JUMP XTHRW5)

XTHWM1	(JUMP-XCT-NEXT XTHRW5)		;NOTE WHAT GETS POPPED FROM MICRO STACK VIA THIS PATH
       ((C-PDL-BUFFER-INDEX) DPB M-E A-B (LISP-BYTE %%LP-EXS-EXIT-PC))  ;HAD BETTER NOT HAVE
				;%%-PPSPC SET.  THIS WOULD CORRESPOND TO A MISC-INST MAKING
				;A BINDING BLOCK, WHICH IS ILLEGAL.

XTHRW6A	(CALL QUNBND)		;POP BINDING AND DROP THRU. CLOBBERS M-C.
 ;ON ENTRY HERE, M-D HAS PDL-BUFFER INDEX OF ADI-RESTART-PC ADI, OR -1 IF NONE.
XTHRW6	(JUMP-LESS-THAN M-D A-ZERO XTHRW6B)	;IF ENCOUNTERED *CATCH W/O ADI-RESTART-PC ADI,
			;DONT TRY TO HACK BIND STACK.  THIS CAN HAPPEN VIA INTERPRETED 
			;*CATCH S.  SINCE FRAME DESTINATION MUST BE D-RETURN,
			;NO NEED TO HACK BIND STACK ANYWAY.
	((PDL-BUFFER-INDEX) SUB M-D (A-CONSTANT 3))  ;MOVE BACK TO THE DATA Q 
		;PREVIOUS ADI BLOCK WHICH HAD BETTER BE AN ADI-BIND-STACK-LEVEL BLOCK
	((M-B) Q-POINTER C-PDL-BUFFER-INDEX)	;GET BIND-STACK-LEVEL
	(JUMP-IF-BIT-CLEAR BOXED-SIGN-BIT M-B XTHRW6C)  ;SIGN EXTEND SINCE EMPTY STACK
	((M-B) SELECTIVE-DEPOSIT M-B Q-POINTER (A-CONSTANT -1)) ;IS LEVEL OF -1
XTHRW6C	((M-J) A-QLBNDP)		; COMPUTE CURRENT RELATIVE STACK LEVEL
	((M-J) SUB M-J A-QLBNDO)
	(CALL-LESS-THAN M-J A-B ILLOP)	;ALREADY OVERPOPPED?
	(JUMP-NOT-EQUAL M-J A-B XTHRW6A) ;EVIDENTLY A BIND WAS DONE WITHIN THIS BLOCK ..
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))  ;STORE BACK QBBFL
	((M-B) C-PDL-BUFFER-INDEX)		;WHICH MAY HAVE BEEN CLEARED
	((C-PDL-BUFFER-INDEX) DPB M-FLAGS (LISP-BYTE %%LP-EXS-PC-STATUS) A-B)
XTHRW6B	((M-B) SUB M-I A-AP)			;THIS EFFECTIVELY CANCELS WHAT WILL BE
	((M-B) (BYTE-FIELD 10. 0) M-B)		; DONE AT QMEX1
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	((M-AP) (BYTE-FIELD 10. 0) M-I)		;SIMULATE ACTIVATING CATCH FRAME
	(JUMP-NOT-EQUAL A-CATCH-ACTION M-R XUWR2);ACTION NON-NIL => DONT REALLY RESUME
						; EXECUTION, COROUTINE BACK INSTEAD.
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMEX1)))
	(CALL XRNVR)				;FIRST VALUE IS VALUE THROWN (STILL IN M-T)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMEX1)))
	(CALL-XCT-NEXT XRNVR)			;SECOND VALUE IS TAG
       ((M-T) A-CATCH-TAG)
	(JUMP-XCT-NEXT QMEX1)			;THIRD VALUE IS COUNT, ACTION KNOWN TO BE NIL
       ((M-T) A-CATCH-COUNT)			; SO WE DON'T BOTHER RETURNING THAT 4TH VALUE

XTHRW8	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)
	((PDL-BUFFER-INDEX M-D) SUB M-D (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX XTHRW9)
	((PDL-BUFFER-INDEX M-D) SUB M-D (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTHRW3)
       ((M-D) (BYTE-FIELD 10. 0) M-D)	;ASSURE M-D POSITIVE SO CHECK AT XTHRW6 WINS.

;RAN OUT OF ADI.  THE SAVED DESTINATION HAD BETTER BE D-RETURN OR ERROR.  THIS
;CAN HAPPEN MAINLY THRU INTERPRETED CALLS TO *CATCH.
XTHRW9	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-C (A-CONSTANT 4) ILLOP)	;D-RETURN
	((M-D) (M-CONSTANT -1))		;SET FLAG THAT RESTART-PC ADI NOT FOUND, SO
				;BIND PDL HACKERY NOT ATTEMPTED.
	((M-S) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) C-PDL-BUFFER-INDEX)
	((M-I) SUB M-I A-S)
	(JUMP-XCT-NEXT XTHRW5)
       ((M-J) M-ZERO)

;SKIP THIS OPEN FRAME
XTHRW2	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK)  C-PDL-BUFFER-INDEX)
	((M-ZR) SUB M-I A-ZR)
	(JUMP-XCT-NEXT XTHRW7)
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;ASSURE NO GARBAGE IN A-IPMARK

;UNWIND AN ACTIVE FRAME
XTHRW1	((M-ZR) MICRO-STACK-POINTER)		;INVOLVES A LDB OP
	(JUMP-EQUAL M-ZR A-ZERO XTHRW1A)	;FLUSH MICRO-STACK
	((M-ZR) MICRO-STACK-DATA-POP)
	(CALL-IF-BIT-SET %%-PPBSPC M-ZR BBLKP)
	(JUMP XTHRW1)

XTHRW1A	(JUMP-EQUAL M-R A-CATCH-COUNT XTHRW1B)	;JUMP IF NO COUNT
	((A-CATCH-COUNT Q-R) ADD A-CATCH-COUNT (M-CONSTANT -1))
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 23.) Q-R XUWR1)  ;REACHED MAGIC COUNT, RESUME BY RETURNING
XTHRW1B	((PDL-BUFFER-INDEX) M-AP)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)	;SIMULATES THRWD2 DISP IN LMI
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) XTHWU2)
	(CALL-IF-BIT-SET M-QBBFL BBLKP)  ;MACRO-COMPILED FRAME, CHECK FOR BINDING BLOCK
XTHWU2	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-B) C-PDL-BUFFER-INDEX)
	(CALL-IF-BIT-SET M-B (LISP-BYTE %%LP-CLS-CLOSURE-BINDING-BLOCK-PUSHED) BBLKP)
	((PDL-BUFFER-POINTER) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH))) ;FLUSH PDL
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-B)
	((M-ZR) SUB M-AP A-TEM1)		;COMPUTE PREV A-IPMARK
	((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;RESTORE THAT
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) M-B)
	(JUMP-EQUAL A-TEM1 M-ZERO XTHRWX)	;OFF THE BOTTOM OF THE STACK
	((PDL-BUFFER-INDEX) SUB M-AP A-TEM1)	;RESTORE M-AP
	((M-AP) PDL-BUFFER-INDEX)	;THIS MASKS M-AP TO 10 BITS
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-PDL-BUFFER-ACTIVE-QS A-TEM1)
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS 
			(A-CONSTANT PDL-BUFFER-LOW-WARNING) PDL-BUFFER-REFILL)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)		;SIMULATES THRWD3 DISP IN LMI
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) XTHWL3)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) XTHWU3)  ;MICRO-CODE OR STACK-GROUP
XTHWM3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
;	((A-TEM1) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX)
	(JUMP-XCT-NEXT XTHRW7)
       ((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)

;      ((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS	;RESTORE "PROCESSOR FLAGS"
;			M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-TEM1)

;NOT NECESSARY TO SET UP MACRO-PC SINCE WILL GO THRU QMEX1 BEFORE TRYING TO RUN FRAME
;	((A-TEM1) (LISP-BYTE %%LP-EXS-EXIT-PC) C-PDL-BUFFER-INDEX)
;	((A-TEM1) ADD A-TEM1 M-A)
;	((M-PC) ADD A-TEM1 M-A)			;RESTORE PC

XTHWL3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-LAST-MICRO-ENTRY) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-LAST-MICRO-ENTRY (A-CONSTANT (I-MEM-LOC INTRET)) ILLOP)
XTHWU3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
;	((A-TEM1) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX)
;	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS	;RESTORE "PROCESSOR FLAGS"
;			M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-TEM1)
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	(CALL QMMPOP)		;RESTORE USTACK FROM BINDING STACK
	(JUMP XTHRW7)

;DROPPED OFF BOTTOM OF PDL
XTHRWX	((M-1) A-V-TRUE)
	(JUMP-EQUAL A-CATCH-TAG M-1 XUWR2)	;SUPPOSED TO THROW ALL THE WAY
	(CALL ILLOP)				;NOT SUPPOSED TO, BARF, SHOULD HAVE DETECTED
						;THIS ON THE FIRST PASS

;HERE WHEN THE COUNT RUNS OUT
XUWR1	(JUMP-EQUAL A-CATCH-ACTION M-R QMEX1)  ;CAUSE ACTIVE FRAME TO RETURN VALUE
;HERE TO COROUTINE BACK (ACTION NOT NIL)
XUWR2	((M-A) A-SG-PREVIOUS-STACK-GROUP)       ;FAKE UP A CALL TO THE ERROR SG.
	((A-SG-TEM) A-V-NIL)	;VALUE TO TRANSMIT.
	((A-SG-TEM1) A-V-NIL)	;ARGUMENT LIST.
	((A-NARGS) M-ZERO)	;NO ARGUMENTS.
	(JUMP-XCT-NEXT SG-CALL-2)
       ((M-B) SETO)	;THIS IS A SIMPLICFICATION FOR THE TIME BEING TO SAVE UCODE.
			; SHOULD FETCH STATE OF SG, WORRY ABOUT CALLING-ARGS-POINTER, ETC.
			; BUT THIS SHOULD DO THE RIGHT THING FOR THE TIME BEING.
			;The SETO is so that a swap will happen.

XCATCH (MISC-INST-ENTRY *CATCH)		;ONLY GET HERE WHEN NO *THROW 
	(POPJ-AFTER-NEXT 		;*CATCH WHICH COMPLETES RETURNS NIL AS SECOND VALUE
	 (M-T) C-PDL-BUFFER-POINTER-POP) ;VALUE OF FROB
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

;	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC CPOPJ)))  ;IF ONLY ONE VALUE
;				;DESIRED, JUST POPJ
;;NOTE THIS ONLY WINS FOR MACRO-MICRO CALL. TO WIN FOR MICRO-MICRO, IT WOULD HAVE TO
;;  GO THRU HAIR TO LOCATE THE ADI, ETC ETC
;	(CALL-XCT-NEXT XRNVR)
;       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)  ;FLUSH FIRST ARG (WHICH WAS CATCH TAG)
;	(POPJ-AFTER-NEXT 
;	 (M-T) A-V-TRUE)  ;SECOND VALUE OF T SIGNALS EVALUATION COMPLETED NORMALLY
;       (NO-OP)

XCTO (MISC-INST-ENTRY %CATCH-OPEN)
	((M-T) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
				  *CATCH-U-CODE-ENTRY-/#)))
XERO1	((M-GARBAGE) MICRO-STACK-DATA-POP)
;;;RESTART ADR ON PDL WITH FLAG-BIT CLEAR.  LEAVE IT THERE TO BECOME FIRST WD OF ADI
	(CALL-XCT-NEXT SBPL-ADI)	;PUSH ADI-BIND-STACK-LEVEL BLOCK
       ((M-S) C-PDL-BUFFER-POINTER-POP)		;GET RESTART PC OFF STACK
	((C-PDL-BUFFER-POINTER-PUSH)
		DPB (M-CONSTANT -1) Q-FLAG-BIT A-S)	;PUSH RESTART PC
	((M-R) MICRO-STACK-POINTER)			;BACK.
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-R (BYTE-FIELD 5. 0)
	     (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RESTART-PC))))
	
SBPL-ADI((M-1) A-QLBNDP)		;STORE ADI-BIND-STACK-LEVEL ADI BLOCK
	((M-1) SUB M-1 A-QLBNDO)
	(POPJ-AFTER-NEXT 
	 (C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH) 
		(A-CONSTANT (PLUS (PLUS 
		  (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		  (BYTE-VALUE Q-FLAG-BIT 1))
		  (BYTE-VALUE %%ADI-TYPE ADI-BIND-STACK-LEVEL))))

XCTOM (MISC-INST-ENTRY %CATCH-OPEN-MV)
	((M-T) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
				  *CATCH-U-CODE-ENTRY-/#)))
XEROM1	((M-GARBAGE) MICRO-STACK-DATA-POP)
	((M-D) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;# VALS TO BE RECVD
	(CALL-XCT-NEXT LMVRB)				;LEAVE RM ON PDL TO RECEIVE VALS
       ((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;RESTART PC
	(CALL SBPL-ADI)		;PUSH ADI-BIND-STACK-LEVEL BLOCK
	((C-PDL-BUFFER-POINTER-PUSH) DPB (M-CONSTANT -1) Q-FLAG-BIT A-S)
	((M-R) MICRO-STACK-POINTER)
        ((C-PDL-BUFFER-POINTER-PUSH) DPB M-R (BYTE-FIELD 5. 0)
	     (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RESTART-PC))))
	(JUMP-XCT-NEXT XCTOM1)
       ((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K) ;THIS ISN'T LAST ADI

XLEC (MISC-INST-ENTRY %LEXPR-CALL)
	(JUMP-XCT-NEXT XLEC1)
       ((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-LEXPR-CALL))))

XFEC (MISC-INST-ENTRY %FEXPR-CALL)
	((M-S) (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
XLEC1	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((M-T) C-PDL-BUFFER-POINTER-POP)	;FUNCTION TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH) M-S)	;STORE ADI

XLECM (MISC-INST-ENTRY %LEXPR-CALL-MV)
	(JUMP-XCT-NEXT XLECM1)
       ((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-LEXPR-CALL))))

XFECM (MISC-INST-ENTRY %FEXPR-CALL-MV)
	((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
XLECM1	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((M-D) C-PDL-BUFFER-POINTER-POP)	;NUMBER OF VALUES DESIRED
	(CALL-XCT-NEXT LMVRB)			;MAKE ROOM ON PDL
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FCN TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) M-S)	;STORE ADI
	(JUMP-XCT-NEXT XCTOM1)
       ((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K) ;THIS ISN'T LAST ADI

XC0MVL (MISC-INST-ENTRY %CALL0-MULT-VALUE-LIST)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	(CALL XCMVL0)
	(JUMP QMRCL)

XCMVL (MISC-INST-ENTRY %CALL-MULT-VALUE-LIST)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
XCMVL0	((M-T) C-PDL-BUFFER-POINTER-POP)	;FCN TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;INIT CDR OF LIST, ON RET WILL BE LIST
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) PDL-BUFFER-POINTER)		;GET LOCATIVE POINTER TO THAT NIL
	((C-PDL-BUFFER-POINTER-PUSH) M-K)	;AS 2ND ADI WORD
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH)		;ADI FOR RETURN VALUES INFO
	     (A-CONSTANT (PLUS (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-MAKE-LIST))))

XC0MV (MISC-INST-ENTRY %CALL0-MULT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	(CALL XCMV0)
	(JUMP QMRCL)

XCMV (MISC-INST-ENTRY %CALL-MULT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
XCMV0	((M-D) C-PDL-BUFFER-POINTER-POP)	;# VALUES DESIRED
XCMV1	(CALL-XCT-NEXT LMVRB)			;MAKE ROOM ON PDL
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FCN TO CALL
XCTOM1	((C-PDL-BUFFER-POINTER-PUSH) M-K)	;RETURN VALUES BLOCK POINTER
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-D	;ADI FOR RETURN VALUES INFO
	  (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING)
	     (A-CONSTANT (PLUS (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-BLOCK))))
XCTO1	(CALL CBM)				;STORE CALL BLOCK
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-ZR (A-CONSTANT (EVAL %LP-CALL-STATE)))
       ((C-PDL-BUFFER-INDEX) IOR C-PDL-BUFFER-INDEX
		(A-CONSTANT (BYTE-MASK %%LP-CLS-ADI-PRESENT)))

LMVRB	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE M-D ERROR-UNLESS-FIX)
	((M-D) Q-POINTER M-D)
	(CALL-GREATER-THAN M-D (A-CONSTANT 100) TRAP)
   (ERROR-TABLE MVR-BAD-NUMBER M-D)
ULMVRB	(CALL-EQUAL M-D A-ZERO TRAP)
   (ERROR-TABLE MVR-BAD-NUMBER M-D)
	((M-K) PDL-BUFFER-POINTER)		;LOC OF BLOCK AS PDL INDEX
	((M-E) M-D)
LMVRB1	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;RESERVE SLOTS, FILL WITH NIL
	(JUMP-GREATER-THAN-XCT-NEXT M-E (A-CONSTANT 1) LMVRB1)
       ((M-E) SUB M-E (A-CONSTANT 1))
	(JUMP-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;RET BLK PNTR AS LOCATIVE
       ((M-K) ADD M-K (A-CONSTANT 1))		;FIX POINTER

;;; "LINEAR" ENTER
;   M-A HAS PNTR TO FEF TO CALL
;   M-S HAS EVENTUAL NEW ARG POINTER
;NO INTERRUPTS CAN BE TAKEN IN HERE, MOSTLY BECAUSE ALL KINDS OF
;FUNNY DATA ARE FLYING AROUND IN THE ACS, BUT ALSO BECAUSE THE  
;PDL STRUCTURE MAY NOT BE TOTALLY CONSISTENT.
;ALSO, WE DON'T SUPPORT USER COPYING AND FORWARDING OF FEFS,
;SO IT'S NOT NECESSARY TO CALL THE TRANSPORTER EVERYWHERE.  NOTE THAT
;IF THE FEF GETS TRANSPORTED BY SOME OPERATION IN HERE SUCH AS A SPECIAL
;VARIABLE ACCESS CAUSING A FLIP, WE RELY ON OUR REGISTER M-A TO GET FIXED UP.

QLENTR	((M-B) SUB M-S A-AP)			;ASSURE ROOM IN PDL-BUFFER
	((M-B) (BYTE-FIELD 10. 0) M-B)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
	((M-AP) M-S)	;NEW ARG POINTER (DO THIS RIGHT AWAY TO MINIMIZE PROBLEMS IF ERR OUT)
	((VMA-START-READ) M-A)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-ERROR-SUBSTATUS) M-ZERO)	;CLEAR OUT ERRORS AND "PROCESSOR" FLAGS
	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-ZERO)
	((A-LCTYP) M-ZERO)		;CLEAR OUT LINEAR-CALL-TYPE 
	((M-D) READ-MEMORY-DATA)	;GET FEF HEADER WORD
	((M-B) (LISP-BYTE %%HEADER-TYPE-FIELD) M-D)
	(CALL-NOT-EQUAL M-B (A-CONSTANT (EVAL %HEADER-TYPE-FEF)) ILLOP)	;NOT FEF
	((A-TEMPC) (LISP-BYTE %%FEFH-PC) M-D)	;MAY GET CHANGED DUE TO OPTIONAL ARGS.
					; ALSO NOTE RELATIVE TO FEF STILL
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) 
			C-PDL-BUFFER-INDEX QLEAI1)  ;FEXPR OR LEXPR ?
QLEAI2	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEFH-FAST-ARG) M-D QRENT)  ;NO FAST-OPTION
;NEED ERRONEOUS QUOTED ARG CHECK
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-FAST-ARG-OPT)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;GET FAST-OPTION WORD
	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA ERROR-UNLESS-FIX)
	((M-C) (LISP-BYTE %%FEFHI-FSO-MIN-ARGS) READ-MEMORY-DATA)
	(CALL-GREATER-THAN M-C A-NARGS SET-TOO-FEW-ARGS)
	((M-E) (LISP-BYTE %%FEFHI-FSO-MAX-ARGS) READ-MEMORY-DATA)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-QUOTED-REST) READ-MEMORY-DATA QLFOA1)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-EVALED-REST) READ-MEMORY-DATA QLFOA1)
	((A-QLOCO Q-R) ADD M-E (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	((A-TEM1) DPB Q-R (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-Q) A-NARGS)
	((M-C) DPB M-Q (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-TEM1)
QLEAI5	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((C-PDL-BUFFER-INDEX) M-C)		;STORE ENTRY STATE Q
	(CALL-LESS-THAN M-E A-NARGS SET-TOO-MANY-ARGS)
QFL2	(JUMP-LESS-OR-EQUAL M-E A-NARGS QFL1)
	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;DEFAULT UNSUPPLIED ARGS TO NIL
	(JUMP-XCT-NEXT QFL2)
       ((M-E) SUB M-E (A-CONSTANT 1))

SET-TOO-FEW-ARGS
	(POPJ-AFTER-NEXT (M-QBTFA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
       (NO-OP)

SET-TOO-MANY-ARGS
	(POPJ-AFTER-NEXT (M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
       (NO-OP)

;HAVE SET UP ARGS
QFL1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
QFL1C	(JUMP-EQUAL M-T A-ZERO QFL1A)
QFL1B	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL) 	;INIT LOCAL BLOCK TO NIL
	(JUMP-GREATER-THAN-XCT-NEXT M-T (A-CONSTANT 1) QFL1B)
       ((M-T) SUB M-T (A-CONSTANT 1))
QFL1A	(CALL-IF-BIT-SET (LISP-BYTE %%FEFH-SV-BIND) M-D FRMBN1)  ;MOVE S-V BINDINGS TO
		;S-V-CELLS AND PUSH PREVIOUS BINDINGS ON BINDING PDL (M-D HAS %FEFHI-IPC STILL)
;FINISH LINEARLY ENTERING
QLENX	((A-IPMARK) (BYTE-FIELD 10. 0) M-AP)	;NO OPEN CALL BLOCK YET
	((M-K) M+M M-A)				;NOW UNRELOCATE PC
	((M-PC) ADD M-K A-TEMPC)
	((M-PC) Q-POINTER M-PC)			;FLUSH RANDOM HIGH BITS
	(JUMP-NOT-EQUAL M-ERROR-SUBSTATUS A-ZERO QLEERR)
	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)  ;GET MAIN LOOP BACK
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	      ;INTO PHASE
	((M-PC) M-PC A-ZERO ADD ALU-CARRY-IN-ONE LOAD-LOW-PC-BIT)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;FLUSH OLD RETURN TO MAIN LOOP
	((M-INST-BUFFER) READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QMLP-EVEN)		;AND RETURN TO MAIN LOOP
       (JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-PC QMLP-ODD)  ;(PC HAS BEEN INCR'ED)

QLEERR	((C-PDL-BUFFER-POINTER-PUSH) DPB M-ERROR-SUBSTATUS Q-POINTER ;PUSH M-ERROR-SUBSTATUS 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ; ONTO STACK SO ERROR HANDLER
	(CALL TRAP)					       ; CAN FIND IT.
   (ERROR-TABLE FUNCTION-ENTRY) ;This table entry is specially known about.

;HERE IF FCTN HAS REST ARG. M-E HAS # REG+OPT ARGS
QLFOA1	((M-J) A-NARGS)
	(JUMP-NOT-EQUAL M-E A-ZERO QLFOA2)	;SOME ARGS BEING HANDLED BOTH WAYS
	(JUMP-EQUAL A-LCTYP M-ZERO QLFOA3)	;XFER ARGS SPREAD BY CALLER
	((A-QLOCO Q-R) (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
					;ARG BLOCK EMPTY SINCE REST ARG IS FIRST LOCAL
QLFOA5	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((C-PDL-BUFFER-INDEX) DPB Q-R (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
QLFOA4	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-T) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QFL1C)
       ((M-T) SUB M-T (A-CONSTANT 1))	;LOCAL PART OF LOCAL BLOCK IS ONE LESS

QLFOA3	(JUMP-EQUAL M-ZERO A-NARGS QLFOA6)	;IF NO ARGS, REST POINTER GETS NIL
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) ADD M-S (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	((C-PDL-BUFFER-POINTER-PUSH)
	   DPB Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
QLFOA7	(JUMP-XCT-NEXT QLFOA5)
       ((A-QLOCO Q-R) ADD M-J (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
			;M-J HAS A-NARGS

QLFOA6	(JUMP-XCT-NEXT QLFOA7)
       ((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)

QLFOA2	(CALL-IF-BIT-SET (LISP-BYTE %%FEFH-NO-ADL) 
			   M-D ILLOP)	;BOTH FLAVOR ARGS
	(JUMP QRENT)

;ADDITIONAL INFO, SEE IF LEXPR OR FEXPR CALL
QLEAI1	((M-K PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL (1- %LP-CALL-STATE))))
QLEAI3	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-INDEX ERROR-UNLESS-FIX)
	(DISPATCH (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX D-QLEAI3)
	(JUMP-XCT-NEXT QLEAI2)	;FEXPR OR LEXPR, REMEMBER WIERD CALL TYPE
       ((A-LCTYP) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)

QLEAI4	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)	;IGNORE OTHER ADI
	((M-K PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX QLEAI2);ALL ADI DONE
	(JUMP-XCT-NEXT QLEAI3)
       ((M-K PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))

;LINEAR ENTER WITHOUT FAST OPTION
QRENT	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-D PDL-BUFFER-INDEX) ADD M-S
		(A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))        ;-> FIRST ARG
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)));-> S-V SLOTS
	((A-ARGS-LEFT) A-NARGS)					      ;# ARGS YET TO DO
	((A-TEM1) (LISP-BYTE %%FEFHI-MS-ARG-DESC-ORG) READ-MEMORY-DATA)
	((M-I) ADD A-TEM1 M-A)					    ;-> FIRST BIND DESC
	((M-R) (LISP-BYTE %%FEFHI-MS-BIND-DESC-LENGTH) READ-MEMORY-DATA)  ;# BIND DESCS
	((A-QLOCO) SETCA A-ZERO)		    ;SIGNAL LOCAL BLOCK NOT YET LOCATED
;	((A-QRSPCF) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;NO SPECIALS-IN-BLOCK
	(JUMP-EQUAL A-LCTYP M-ZERO QBINDL)
	((A-ARGS-LEFT) ADD (M-CONSTANT -1) A-ARGS-LEFT) ;WAS FEXPR OR LEXPR CALL
			;FLUSH NO-SPREAD-ARG AND PROCESS ANY SPREAD ARGS
;BIND LOOP USED WHILE ARGS REMAIN TO BE PROCESSED
QBINDL	(JUMP-GREATER-OR-EQUAL M-ZERO A-ARGS-LEFT QBD0)	;OUT OF SPREAD ARGS
	(JUMP-LESS-THAN
		M-R (A-CONSTANT 1) QBTMA1) ;OUT OF BIND DESC, TOO MANY ARGS
	((VMA-START-READ) M-I)		;ACCESS WORD OF BINDING OPTIONS
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA QBNDL1)
	((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)	;SKIP NAME Q IF PRESENT
QBNDL1	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QREDT1)
       ((M-Q) READ-MEMORY-DATA)		;SAVE BIND DESC IN M-Q

QREW1	(CALL-LESS-THAN M-R (A-CONSTANT 1) ILLOP)
	((VMA-START-READ) M-I)		;ACCESS WORD OF BINDING OPTIONS
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-R) SUB M-R (A-CONSTANT 1))
	((M-Q) READ-MEMORY-DATA)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) M-Q QBNDL2)
	((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)	;SKIP NAME Q IF PRESENT
QBNDL2	((M-E) (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q)
	(JUMP-NOT-EQUAL M-E (A-CONSTANT 2) ILLOP)	;WASN'T REST ARG??
	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;SET UP LOCAL BLOCK OVER ARG
	((PDL-BUFFER-POINTER) M-D)		;SO DONT STORE LOCALS OVER ARG
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;OPTIONAL ARG IS PRESENT, SPACE PAST INITIALIZATION INFO IF ANY
QBROP1	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPNP)

QBOSP	(JUMP-XCT-NEXT QBRQA)
       ((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)

QBOASA	((VMA-START-READ M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEMPC) Q-POINTER READ-MEMORY-DATA)	;START LATER TO AVOID CLOBBERING

;REQUIRED ARGUMENT IS PRESENT
QBRQA	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBSPCL)

;ENTER HERE WHEN ARG HAS BEEN BOUND.  THESE CHECKS ONLY CAUSE EXCEPTIONS
QBDL1	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-DES-DT) M-Q QBDDT)
       ((M-C) Q-DATA-TYPE C-PDL-BUFFER-INDEX)
QBDDT1	;(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-QUOTE-STATUS) M-Q QBEQC)
       ;((M-C) Q-FLAG-BIT C-PDL-BUFFER-INDEX)
QBEQC1	((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE) ;NEXT ARG SLOT
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE) ;NEXT BIND DESC ENTRY
	(JUMP-XCT-NEXT QBINDL)			;PROCEED TO NEXT ARG
       ((A-ARGS-LEFT) ADD (M-CONSTANT -1) A-ARGS-LEFT)

;REST ARG - FOR NOW I ASSUME MICRO-COMPILED FUNCTIONS DO STORE CDR CODES
QBRA	(CALL-NOT-EQUAL A-LCTYP M-ZERO ILLOP)	;IF A NON-SPREAD ARG, SHOULD NOT
						;GET TO REST ARG HERE.
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;MAKE PNTR TO LIST OF ARGS
       ((M-K) M-D)
	(CALL-GREATER-THAN-XCT-NEXT M-ZERO A-QLOCO QLLOCB)
       ((M-D) ADD M-D A-ARGS-LEFT)	 	;LOCATE LOCAL BLOCK AFTER LAST ARG
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-K	;STORE REST ARG AS FIRST LOCAL
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;ADVANCE TO NEXT BIND DESC

QBD0	(JUMP-NOT-EQUAL A-LCTYP M-ZERO QREW1)	;ALSO IS A NO-SPREAD ARG
;BINDING LOOP FOR WHEN ALL ARGS HAVE BEEN USED UP
QBD1	(JUMP-LESS-THAN
		M-R (A-CONSTANT 1) QBD2)	;JUMP IF FINISHED ALL BINDING
	((VMA-START-READ) M-I)			;GET NEXT BINDING DESC Q
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA QBD2A)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;SKIP NAME IF PRESENT
QBD2A	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QBDT2)
       ((M-Q) READ-MEMORY-DATA)			;SAVE BINDING DESC IN M-Q

;LOCATE LOCAL BLOCK TO WHERE M-D POINTS
;AFTER THIS HAS BEEN CALLED, USE C-PDL-BUFFER-POINTER-PUSH TO STORE LOCALS
QLLOCB	(POPJ-AFTER-NEXT		;PDL-BUFFER-PTR SHOULD BE SET ALREADY?
					;  --NOT IF TOO FEW ARGS FOR ONE--.
	 (PDL-BUFFER-POINTER) SUB M-D (A-CONSTANT 1))	;FIRST PUSH WILL STORE @ M-D
       ((A-QLOCO) SUB M-D A-S)			;OFFSET FROM AP TO LOCALS

;GOT ARG DESCRIPTOR WHEN OUT OF ARGS
QBTFA1	((M-QBTFA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)	 ;TOO FEW ARGS
	((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE) ;GENERATE A NULL ARG.
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-INDEX) A-V-NIL)

QBRA1	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;REST ARG MISSING, MAKE 1ST LOCAL NIL	
QBOPT2	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;STORE MISSING ARG AS NIL (CDR CODE?)
QBD1A	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
       ((M-D) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
QBDIN1	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;INTERNAL
QBDINT	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN2)
	(JUMP-XCT-NEXT QBDIN1)	;IF SPECIAL, NO LOCAL SLOT, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

QBDIN2	(JUMP-XCT-NEXT QBOPT2)	;IF LOCAL, IGNORE AT BIND TIME BUT RESERVE LOCAL SLOT
       (CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;ALSO MUST LOCATE LOCAL BLOCK


;FREE
QBDFRE	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN1) ;TAKES NO LCL SLOT
	(JUMP-XCT-NEXT QBDIN1)				    ;IF SPECIAL, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

;AUX
QBDAUX	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;LOCATE LOCAL BLOCK, 
						; THEN DROP THROUGH TO INITIALIZE
QBOPT4	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPTT)

;OPTIONAL NOT PRESENT
QBOPT1	(JUMP-GREATER-THAN M-ZERO A-QLOCO QBOPT4)
	(CALL ILLOP)		;SHOULDN'T HAVE ARGS AFTER LOCAL BLOCK IS LOCATED

;OPTIONAL ARGUMENT INIT VIA ALTERNATE STARTING ADDRESS AND NOT PRESENT
;LEAVE STARTING ADDRESS ALONE AND INIT TO SELF, COMPILED CODE WILL
;RE-INIT.  BUT DON'T FORGET TO SKIP OVER THE START ADDRESS.
QBOPT5	((M-I) ADD M-I (A-CONSTANT 1))
;OPTIONAL OR AUX, INIT TO SELF OR NONE, LATER MAY BE REINITED BY COMPILED CODE
QBOPT3	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT)
			M-Q QBOPT2)		;LOCAL, INIT TO NIL
	((VMA-START-READ M-VMA-HELD) M-T)	;SPECIAL, GET POINTER TO VALUE CELL
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-TRAP READ-MEMORY-DATA)	;FETCH EXTERNAL VALUE CELL.
							;MUST GET CURRENT VALUE, BUT NOT BARF
							;IF DTP-NULL.  MUST NOT LEAVE AN EVCP
							;SINCE THAT WOULD SCREW PREVIOUS
							;BINDING IF IT WAS SETQ'ED.
	(JUMP-XCT-NEXT QBD1A)			;GO PUSH SPECIAL PDL AND SO FORTH
       ((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)

;INIT TO POINTER
QBOPNR	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ M-VMA-HELD) M-I)	;FETCH THING TO INIT TOO, TRANSPORT IT
QBDR1	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)

;INIT TO C(POINTER)
QBOCPT	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ M-VMA-HELD) M-I)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ M-VMA-HELD) READ-MEMORY-DATA)

;INIT TO CONTENTS OF "EFFECTIVE ADDRESS"
QBOEFF	((M-I VMA-START-READ) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 6) READ-MEMORY-DATA QBOFDT) ;DISPATCH ON REG
       ((M-1) (BYTE-FIELD 6 0) READ-MEMORY-DATA)	;PICK UP DELTA FIELD

QBFE	((M-1) (BYTE-FIELD 8 0) READ-MEMORY-DATA)	;FULL DELTA
QBFE0	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ M-VMA-HELD) ADD M-A A-1)	;FETCH FROM FEF OF FCN ENTERING

QBQT	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ M-VMA-HELD) ADD M-1 A-V-CONSTANTS-AREA)	;FETCH FROM CONSTANTS PAGE

QBDLOC	(CALL-GREATER-THAN M-ZERO A-QLOCO ILLOP) ;TRYING TO ADDRESS LOCALS BEFORE LOCATED
	((M-1) ADD M-1 A-QLOCO)
	((PDL-BUFFER-INDEX) ADD M-1 A-S)	 ;FETCH LOCAL
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

QBDARG	((PDL-BUFFER-INDEX) ADD M-1 A-S ALU-CARRY-IN-ONE)	;FETCH ARG
	(JUMP-XCT-NEXT QBD1A)		;(%LP-INITIAL-LOCAL-BLOCK-OFFSET = 1)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

;TOO MANY ARGS
QBTMA2	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	(DISPATCH-XCT-NEXT  (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q QBDT2) ;FINISH BIND DESCS
       ((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCING LCL PNTR PAST THE EXTRA ARGS

;TOO MANY ARGS AND BIND DESC LIST ALL USED UP
QBTMA1	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCE LCL PNTR PAST THE EXTRA ARGS

;HERE WHEN BIND DESC LIST HAS BEEN USED UP
QBD2	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)  ;SET UP LOCAL BLOCK
	((M-K) A-QLOCO)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;ASSEMBLE ENTRY STATE Q
			;WAS A-QRSPCF
	((M-K) A-NARGS)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	(JUMP-XCT-NEXT QLENX)
       ((C-PDL-BUFFER-INDEX) DPB M-K
		(LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-TEM1)

;COME HERE WHEN BINDING A SPECIAL TO A LOCAL
QBLSPCL	((PDL-BUFFER-INDEX) PDL-BUFFER-POINTER)

;COME HERE WHEN BINDING A SPECIAL
; NOTE CODE BELOW CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C.  THIS IS FOR THE BENEFIT OF
;FRMBN1.  ITS A CROCK, BUT NON-MODULARITY WAS DEEMED WORTH IT BECAUSE OTHERWISE
;CLEAR WOULD HAVE TO BE DONE IN A LOOP.
QBSPCL	((VMA-START-READ M-VMA-HELD) M-T)	;GET SPECIAL VALUE CELL POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-1) ADD (M-CONSTANT 22.) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 ILLOP)  ;RESULT HAD BETTER BE NEGATIVE
						; (AS 24 BIT QUANTITY).
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA) ;TRANSPORT THE SPECIAL VALUE CELL PTR
	((VMA-START-READ M-VMA-HELD) DPB READ-MEMORY-DATA Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;GET CONTENTS OF INTERNAL VALUE CELL
;CODE BELOW IS LOGICALLY SOMEWHAT SIMILAR TO QBND2.
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((M-1) C-PDL-BUFFER-INDEX)		;GET VAL TO BIND TO (ARG OR LOCAL)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)	;CHASE DTP-FORWARD IF ANY
	((M-B VMA) M-VMA-HELD)			;SAVE LOCATIVE TO LOCATION ACTUALLY BOUND
						; AND RESTORE THE VMA
	((M-K) Q-TYPED-POINTER READ-MEMORY-DATA) ;BINDING TO SAVE
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT 
		Q-ALL-BUT-TYPED-POINTER READ-MEMORY-DATA 
		A-1)		;NEW VALUE CELL CONTENTS
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((M-C) DPB M-ZERO (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) A-C) ;FOR FRMBN1'S BENEFIT
						;IF WE ARE COMING FROM THERE.
	((WRITE-MEMORY-DATA) M-K)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL QBSPCL1)	;JUMP IF NOT FIRST IN BLOCK
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)	 ;ADVANCE TO NEXT S-V SLOT
	((M-K WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K)
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
QBSPCL1 ((VMA-START-WRITE) A-QLBNDP)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) M-B)
	(POPJ-AFTER-NEXT 
	 (VMA-START-WRITE) A-QLBNDP)
       (CALL-CONDITIONAL PG-FAULT PGF-W)


;DATA TYPE CHECKS
QDTATM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
QDTN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-EXTENDED-NUMBER)) QBDDT1)
QBDDT3	(JUMP-XCT-NEXT QBDDT1)		;BAD DATA TYPE
       ((M-QBBDT) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)

QDTFXN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP QBDDT3)

QDTSYM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
	(JUMP QBDDT3)

QDTLST	((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-C A-V-NIL QBDDT1)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-INDEX SKIP-IF-LIST)
	 (JUMP QBDDT3)
	(JUMP QBDDT1)

QDTFRM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FEF-POINTER)) QBDDT1)
	(JUMP QBDDT3)

;EVAL/QUOTE CHECKS
;QBEQE	(JUMP-EQUAL M-C A-ZERO QBEQC1)
;QBEQQ1	(JUMP-XCT-NEXT QBEQC1)
;      ((M-QBBQTS) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
;
;QBEQQ	(JUMP-NOT-EQUAL M-C A-ZERO QBEQC1)
;	(JUMP QBEQQ1)

;;FRAME BIND. BIND S-V S FROM FRAME FAST ENTERED USING S.V. MAP
FRMBN1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-SV-BITMAP)))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-D PDL-BUFFER-INDEX) M-AP)
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)))
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%FEFHI-SVM-ACTIVE) 
		READ-MEMORY-DATA ILLOP)  ;FOO FAST OPT 
			;SHOULD NOT BE ON UNLESS SVM IS. (IT ISNT WORTH IT TO HAVE
			;ALL THE HAIRY MICROCODE TO SPEED THIS CASE UP A TAD.)
	((M-C) (LISP-BYTE %%FEFHI-SVM-BITS) READ-MEMORY-DATA)
FRMBN2	(POPJ-EQUAL M-C A-ZERO)	  ;POPJ IF NO MORE BITS
	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) 
			M-C QBSPCL)	;QBSPCL CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C
       ((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT FRMBN2)
       ((M-C) M+M M-C A-ZERO)

;POP A BLOCK OF BINDINGS
BBLKP	(JUMP-XCT-NEXT BBLKP1)
       ((M-ZR) SETCA A-ZERO)

;POP A BINDING (MUSTN'T BASH M-T, M-J, M-R, M-D)
QUNBND	((M-ZR) A-ZERO)
BBLKP1	((VMA-START-READ M-VMA-HELD) A-QLBNDP)	;GET PNTR TO BOUND CELL
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-Q) READ-MEMORY-DATA)
	((M-C) Q-DATA-TYPE M-Q)
	(CALL-NOT-EQUAL M-C (A-CONSTANT (EVAL DTP-LOCATIVE)) ILLOP)
BBLKP3	((VMA-START-READ M-VMA-HELD) A-QLBNDP)	;PREV CONTENTS
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-C) READ-MEMORY-DATA)
	((VMA-START-READ M-VMA-HELD) M-Q)	;ACCESS BOUND CELL
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO INTERRUPT, CONTENTS PICKED UP
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)	;FOLLOW ONE-Q-FORWARD
	((VMA) M-VMA-HELD)			;RESTORE VMA
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-C)
	(CALL-CONDITIONAL PG-FAULT PGF-W)	;NO INTERRUPT, M-QBBFL INCONSISTENT
	(JUMP-IF-BIT-SET Q-FLAG-BIT M-C BBLKP2)	;JUMP IF LAST BINDING IN BLOCK
	(POPJ-EQUAL M-ZR A-ZERO)		;POPJ IF QUNBND
	(JUMP BBLKP1)				;LOOP IF BBLKP

BBLKP2	(POPJ-AFTER-NEXT
	 (M-QBBFL) DPB M-ZERO A-FLAGS)		;NO MORE B.B.
       (NO-OP)	

XUB (MISC-INST-ENTRY UNBIND-0)			;UNBIND N BLOCKS
    (MISC-INST-ENTRY UNBIND-1)
    (MISC-INST-ENTRY UNBIND-2)
    (MISC-INST-ENTRY UNBIND-3)
    (MISC-INST-ENTRY UNBIND-4)
    (MISC-INST-ENTRY UNBIND-5)
    (MISC-INST-ENTRY UNBIND-6)
    (MISC-INST-ENTRY UNBIND-7)
    (MISC-INST-ENTRY UNBIND-10)
    (MISC-INST-ENTRY UNBIND-11)
    (MISC-INST-ENTRY UNBIND-12)
    (MISC-INST-ENTRY UNBIND-13)
    (MISC-INST-ENTRY UNBIND-14)
    (MISC-INST-ENTRY UNBIND-15)
    (MISC-INST-ENTRY UNBIND-16)
    (MISC-INST-ENTRY UNBIND-17)
	((M-D) (BYTE-FIELD 4 0) M-B)	;GET # BINDINGS TO POP MINUS ONE
XUB1	(CALL-IF-BIT-CLEAR M-QBBFL ILLOP)	;TRYING TO OVERPOP FRAME
	(CALL QUNBND)	
	(POPJ-EQUAL M-D A-ZERO)
	(JUMP-XCT-NEXT XUB1)
       ((M-D) SUB M-D (A-CONSTANT 1))

XPOPIP (MISC-INST-ENTRY POPPDL-0)
       (MISC-INST-ENTRY POPPDL-1)
       (MISC-INST-ENTRY POPPDL-2)
       (MISC-INST-ENTRY POPPDL-3)
       (MISC-INST-ENTRY POPPDL-4)
       (MISC-INST-ENTRY POPPDL-5)
       (MISC-INST-ENTRY POPPDL-6)
       (MISC-INST-ENTRY POPPDL-7)
       (MISC-INST-ENTRY POPPDL-10)
       (MISC-INST-ENTRY POPPDL-11)
       (MISC-INST-ENTRY POPPDL-12)
       (MISC-INST-ENTRY POPPDL-13)
       (MISC-INST-ENTRY POPPDL-14)
       (MISC-INST-ENTRY POPPDL-15)
       (MISC-INST-ENTRY POPPDL-16)
       (MISC-INST-ENTRY POPPDL-17)
	((M-B) (BYTE-FIELD 4 0) M-B)	;POP PDL 1-16.  NOTE THIS CAN NOT BE CALLED BY
	(POPJ-AFTER-NEXT		;COMPILED MICROCODE SINCE B WONT BE SET UP
	 (M-A) PDL-BUFFER-POINTER)
       ((PDL-BUFFER-POINTER) SUB M-A A-B)

XMOVE-PDL-TOP (MISC-INST-ENTRY MOVE-PDL-TOP)
	(POPJ-AFTER-NEXT (M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
       (NO-OP)

XSHRINK-PDL-SAVE-TOP (MISC-INST-ENTRY SHRINK-PDL-SAVE-TOP)
	((M-2) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;AMT TO DECREMENT PP BY
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;THING TO RETURN
	(POPJ-AFTER-NEXT (M-1) PDL-BUFFER-POINTER)
       ((PDL-BUFFER-POINTER) SUB M-1 A-2)

XSPECIAL-PDL-INDEX (MISC-INST-ENTRY SPECIAL-PDL-INDEX)
	((M-T) A-QLBNDP)
	(POPJ-AFTER-NEXT (M-T) SUB M-T A-QLBNDO)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XUNBIND-TO-INDEX-MOVE (MISC-INST-ENTRY UNBIND-TO-INDEX-MOVE)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;VALUE TO RETURN LATER
XUNBIND-TO-INDEX (MISC-INST-ENTRY UNBIND-TO-INDEX)
	((M-D) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-D) ADD M-D A-QLBNDO)
XUNBIND-TO-INDEX-1
	(POPJ-GREATER-OR-EQUAL M-D A-QLBNDP)
	(CALL-IF-BIT-CLEAR M-QBBFL ILLOP)
	(JUMP-XCT-NEXT XUNBIND-TO-INDEX-1)
       (CALL QUNBND)

;;; CAR AND CDR
;   NOTE- ALWAYS RETURNS 0 IN FIELDS OTHER THAN POINTER AND DATA TYPE

QTADDD (MISC-INST-ENTRY CADDDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADDD (MICRO-CODE-ENTRY QMADDD)
	(CALL QMD)
QMADD (MICRO-CODE-ENTRY QMADD)
	(CALL QMD)
QMAD (MICRO-CODE-ENTRY QMAD)
	(CALL QMD)
QMA  (MICRO-CODE-ENTRY QMA) 
   (ERROR-TABLE RESTART CAR)
QCAR	(DISPATCH (I-ARG CAR-INVOKE-OP) Q-DATA-TYPE M-T CAR-PRE-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CAR)
				;DROP THROUGH IF NORMAL CAR
QCAR3	((VMA-START-READ M-VMA-HELD) M-T)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)	;CHECK FOR INVZ, GC
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

QCARSY	(DISPATCH M-CAR-SYM-MODE CAR-SYM-DISPATCH)	;CAR OF A SYMBOL
   (ERROR-TABLE ARGTYP CONS M-T T CAR)

QCARNM	(DISPATCH M-CAR-NUM-MODE CAR-NUM-DISPATCH)	;CAR OF A NUMBER
   (ERROR-TABLE ARGTYP CONS M-T T CAR)

QTDDDD (MISC-INST-ENTRY CDDDDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDDD (MICRO-CODE-ENTRY QMDDDD)
	(CALL QMD)
QMDDD (MICRO-CODE-ENTRY QMDDD)
	(CALL QMD)
QMDD (MICRO-CODE-ENTRY QMDD)
	(CALL QMD)
QMD  (MICRO-CODE-ENTRY QMD) 
   (ERROR-TABLE RESTART CDR)
QCDR	(DISPATCH (I-ARG CDR-INVOKE-OP) Q-DATA-TYPE M-T CDR-PRE-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)
					;DROP THROUGH IF NORMAL LIST CDR
QCDR3	((VMA-START-READ M-VMA-HELD) M-T)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-CDR READ-MEMORY-DATA)	;CHECK FOR INVZ, DON'T REALLY TRANSPORT
	(DISPATCH Q-CDR-CODE READ-MEMORY-DATA CDR-CDR-DISPATCH)
   (ERROR-TABLE BAD-CDR-CODE RMD)				;POPJ-XCT-NEXT IF CDR NEXT
       ((M-T) ADD M-VMA-HELD (A-CONSTANT 1))		;SAME DATA TYPE AS ARG

QCDRSY	(DISPATCH M-CDR-SYM-MODE CDR-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)

QCDRNM	(DISPATCH M-CDR-NUM-MODE CDR-NUM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)

CDR-FULL-NODE 
	((VMA-START-READ M-VMA-HELD) ADD M-VMA-HELD (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)  
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;CHECK FOR INVISIBLE, GC
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

QCASE1	((M-K) Q-TYPED-POINTER M-T)	;HANDLE TAKING CAR OR CDR OF NIL
	(CALL-NOT-EQUAL M-K A-V-NIL TRAP)
   (ERROR-TABLE ARGTYP (CONS NIL) M-T T CDR)
CDR-IS-NIL 
   (MISC-INST-ENTRY FALSE)
XFALSE 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (NO-OP)

QCDPRP	((M-T) Q-TYPED-POINTER M-T)		;TAKING CDR OF SYMBOL (IN P-LIST MODE)
	(JUMP-EQUAL M-T A-V-NIL XFALSE)		;CDR OF NIL IS NIL,
 	((M-T) ADD (A-CONSTANT 3) M-T)		;OTHERWISE IS THE SYMBOL'S PLIST
	(JUMP-XCT-NEXT QCDR)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

QTAAAA (MISC-INST-ENTRY CAAAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAAAA (MICRO-CODE-ENTRY QMAAAA)
	(CALL QMA)
QMAAA  (MICRO-CODE-ENTRY QMAAA)
	(CALL QMA)
QMAA   (MICRO-CODE-ENTRY QMAA)
	(CALL QMA)
	(JUMP QMA)

QTAAAD (MISC-INST-ENTRY CAAADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAAAD (MICRO-CODE-ENTRY QMAAAD)
	(CALL QMD)
	(JUMP QMAAA)

QTDDDA (MISC-INST-ENTRY CDDDAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDDA (MICRO-CODE-ENTRY QMDDDA)
	(CALL QMA)
	(JUMP QMDDD)

QTAADD (MISC-INST-ENTRY CAADDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAADD (MICRO-CODE-ENTRY QMAADD)
	(CALL QMD)
QMAAD  (MICRO-CODE-ENTRY QMAAD)
	(CALL QMD)
	(JUMP QMAA)

QTAADA (MISC-INST-ENTRY CAADAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAADA (MICRO-CODE-ENTRY QMAADA)
	(CALL QMA)
	(JUMP QMAAD)

QTDDAA (MISC-INST-ENTRY CDDAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDAA (MICRO-CODE-ENTRY QMDDAA)
	(CALL QMA)
QMDDA  (MICRO-CODE-ENTRY QMDDA)
	(CALL QMA)
	(JUMP QMDD)

QTDDAD (MISC-INST-ENTRY CDDADR)	
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDAD (MICRO-CODE-ENTRY QMDDAD)
	(CALL QMD)
	(JUMP QMDDA)

QTADAA (MISC-INST-ENTRY CADAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADAA (MICRO-CODE-ENTRY QMADAA)
	(CALL QMA)
QMADA  (MICRO-CODE-ENTRY QMADA)
	(CALL QMA)
	(JUMP QMAD)

QTADAD (MISC-INST-ENTRY CADADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADAD (MICRO-CODE-ENTRY QMADAD)
	(CALL QMD)
	(JUMP QMADA)

QTADDA (MISC-INST-ENTRY CADDAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADDA (MICRO-CODE-ENTRY QMADDA)
	(CALL QMA)
	(JUMP QMADD)

QTDADA (MISC-INST-ENTRY CDADAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDADA (MICRO-CODE-ENTRY QMDADA)
	(CALL QMA)
QMDAD  (MICRO-CODE-ENTRY QMDAD)
	(CALL QMD)
	(JUMP QMDA)

QTDADD (MISC-INST-ENTRY CDADDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDADD (MICRO-CODE-ENTRY QMDADD)
	(CALL QMD)
	(JUMP QMDAD)

QTDAAA (MISC-INST-ENTRY CDAAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDAAA (MICRO-CODE-ENTRY QMDAAA)
	(CALL QMA)
QMDAA  (MICRO-CODE-ENTRY QMDAA)
	(CALL QMA)
QMDA   (MICRO-CODE-ENTRY QMDA)
	(CALL QMA)
	(JUMP QMD)

QTDAAD (MISC-INST-ENTRY CDAADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDAAD (MICRO-CODE-ENTRY QMDAAD)
	(CALL QMD)
	(JUMP QMDAA)


QTAAA (MISC-INST-ENTRY CAAAR)
	(JUMP-XCT-NEXT QMAAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAAD (MISC-INST-ENTRY CAADR)
	(JUMP-XCT-NEXT QMAAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTADA (MISC-INST-ENTRY CADAR)
	(JUMP-XCT-NEXT QMADA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTADD (MISC-INST-ENTRY CADDR)
	(JUMP-XCT-NEXT QMADD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDAA (MISC-INST-ENTRY CDAAR)
	(JUMP-XCT-NEXT QMDAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDAD (MISC-INST-ENTRY CDADR)
	(JUMP-XCT-NEXT QMDAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDDA (MISC-INST-ENTRY CDDAR)
	(JUMP-XCT-NEXT QMDDA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDDD (MISC-INST-ENTRY CDDDR)
	(JUMP-XCT-NEXT QMDDD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAA  (MISC-INST-ENTRY M-CAAR)
	(JUMP-XCT-NEXT QMAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAD  (MISC-INST-ENTRY M-CADR)
	(JUMP-XCT-NEXT QMAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDA  (MISC-INST-ENTRY M-CDAR)
	(JUMP-XCT-NEXT QMDA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDD  (MISC-INST-ENTRY M-CDDR)
	(JUMP-XCT-NEXT QMDD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTA   (MISC-INST-ENTRY M-CAR)
	(JUMP-XCT-NEXT QMA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTD   (MISC-INST-ENTRY M-CDR)
	(JUMP-XCT-NEXT QMD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

 
;;; RPLACA AND RPLACD

  (MISC-INST-ENTRY RPLACA)
XRPLCA	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART RPLACA)
QRAR1	(DISPATCH (I-ARG RPLACA-INVOKE-OP) Q-DATA-TYPE M-S QRACDT)

QRASYM	(CALL-EQUAL M-S A-V-NIL TRAP)		;RPLACA ING NIL ALWAYS ERROR
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACA)
	(DISPATCH M-CAR-SYM-MODE RPLACA-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACA)

QRANUM	(DISPATCH M-CAR-NUM-MODE RPLACA-NUM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACA)

QRAR3	((VMA-START-READ M-VMA-HELD) M-S)	;FETCH WORD TO BE SMASHED
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO INT, CALLED BY MVR
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;CHASE INVISIBLES
	((VMA) M-VMA-HELD)			;RESTORE VMA
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)	;STORE M-T INTO Q-TYPED-PNTR
	(CALL-CONDITIONAL PG-FAULT PGF-W)	;NO INT, CALLED BY MVR
       (POPJ-AFTER-NEXT (M-T) M-S)
	(NO-OP)

   (MISC-INST-ENTRY RPLACD)
;MUSTN'T CLOBBER M-C OR M-R BECAUSE CALLED BY MULTIPLE-VALUE-LIST
;NOW CLOBBERS M-S, M-T, M-I, M-A
XRPLCD	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART RPLACD)
QRDR1	(DISPATCH (I-ARG RPLACD-INVOKE-OP) Q-DATA-TYPE M-S QRDCDT)

QRDRSY	(DISPATCH M-CDR-SYM-MODE RPLACD-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACD)

QRDRNM	(DISPATCH M-CDR-NUM-MODE RPLACD-NUM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACD)

QRDPRP 	((M-S) ADD (A-CONSTANT 3) M-S)		;RPLACD ING SYMBOL (IN P-LIST MODE)
	(JUMP-XCT-NEXT QRDR1)
       ((M-S) DPB M-S Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

QRDR3	((VMA-START-READ M-VMA-HELD) M-S)	;GET CAR OF CONS TO BE SMASHED
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO INTR, CDR CODE IN HAND, ALSO MVR
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(DISPATCH TRANSPORT-CDR READ-MEMORY-DATA) ;CHASE INVISIBLE, NO NEED TO TRANSPORT
	(DISPATCH-XCT-NEXT Q-CDR-CODE READ-MEMORY-DATA RPLACD-CDR-DISPATCH)
   (ERROR-TABLE BAD-CDR-CODE RMD)
       ((M-I) READ-MEMORY-DATA)

RPLACD-FULL-NODE
	((VMA-START-READ M-VMA-HELD) ADD M-VMA-HELD (A-CONSTANT 1))	;GET WORD TO SMASH
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO INTERRUPT, WORD IN HAND, ALSO MVR
	;((VMA) READ-MEMORY-DATA)		;ADDRESS MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;CHASE INVISIBLES
	((VMA) M-VMA-HELD)			;RESTORE VMA
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT	;STORE M-T INTO Q-TYPED-PNTR
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
	(CALL-CONDITIONAL PG-FAULT PGF-W)	;NO INT, CALLED BY MVR
       (POPJ-AFTER-NEXT (M-T) M-S)
	(NO-OP)

RPLACD-CDR-NEXT 
RPLACD-NEXT-NIL 
;THIS CODE IS INTERRUPTABLE!!! BEWARE!!!
	((C-PDL-BUFFER-POINTER-PUSH) M-VMA-HELD)	;ADDR OF CELL TO BE FORWARDED
	((C-PDL-BUFFER-POINTER-PUSH) M-S)		;SAVE THIS SO WE CAN RETURN IT
	((C-PDL-BUFFER-POINTER-PUSH) M-I)		;CAR OF NEW CELL
	((C-PDL-BUFFER-POINTER-PUSH) M-T)		;CDR OF NEW CELL
	(CALL-XCT-NEXT XARN00)				;IN WHAT AREA WAS THE CONS?
       ((M-A) Q-POINTER M-VMA-HELD)			; (ARG IN M-A, RETURNS IN M-T)
	(CALL-XCT-NEXT QCONS)
       ((M-S) Q-POINTER M-T)				;PASS ON THE AREA NUMBER
	((WRITE-MEMORY-DATA) DPB M-T Q-POINTER		;CLOBBER ORIGINAL "CAR"
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FORWARD)))
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;RETURN THE ORIGINAL FIRST ARG
	(POPJ-AFTER-NEXT 
	   (VMA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

;;; ARRAYS

;GENERAL ON ARRAY REFERENCING--
; CODE TO DEAL WITH NON-DISPLACED ARRAYS IS CODED OPEN, WHILE THAT TO
;DEAL WITH DISPLACED ARRAYS IS IN DSP-ARRAY-SETUP.  SINCE THE DISPLACED 
;CASE EVENTUALLY DROPS INTO THE NORMAL CASE, CERTAIN CONVENTIONS ARE NECESSARY.
; THE NORMAL SEQUENCE OF CODE IS
;      1: GET ARRAY-POINTER Q INTO M-A
;      2: CALL GAHD1 TO FETCH ARRAY-HEADER Q INTO M-B.  GAHD1 MAKES SURE IT
;	    IS THE RIGHT TYPE, ETC.  M-D GET NUMBER DIMENSIONS, M-E DATA ORIGIN,
;	    M-S DATA STORAGE LENGTH IN ELEMENTS (NOT QS).
;      3: GET ELEMENT NUMBER WANT TO REF IN M-Q.
;      4: DO (CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B DSP-ARRAY-SETUP)
;	    THIS WILL CHANGE M-E AND M-S, AND MAY CHANGE M-Q.
;	    DSP-ARRAY-SETUP IS TRANSPARENT TO M-A, M-B, AND M-D.
;	    DSP-ARRAY-SETUP KNOWS ABOUT INDIRECT ARRAYS, AND WILL FOLLOW
;		DISPLACED CHAINS, ETC.
;      5: BARF IF M-Q IS GREATER THAN OR EQUAL TO M-S (INDEX OUT OF BOUNDS).
;      6: DISPATCH ON ARRAY-TYPE TO APPROPRIATE REFERENCE ROUTINE.

;M-Q, M-S, M-D, M-E PURE (TYPE-LESS) NUMBERS

;NO INTERRUPTS ALLOWED ANYWHERE IN THIS CODE.  THIS (1) CAUSES STORES
;INTO BYTE ARRAYS TO NOT LOSE SIMULTANEOUS STORES INTO OTHER BYTES SAME WORD
;(2) PREVENTS LOSSAGE FROM ONE PROCESS *REARRAYING WHILE ANOTHER IS REFERENCING
;(3) ALLOWS TWO PROCESSES TO CALL ARRAY-PUSH WITH NO TIMING ERRORS

QARYR	(CALL GAHD1)				;REFERENCE ARRAY
	(CALL-NOT-EQUAL A-NARGS M-D TRAP)	;WRONG # DIM S
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS A-NARGS M-D)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP NIL)
	((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL (A-CONSTANT 1) M-D QARY-MULTI)	;MULTI DIM ARRAY
QARY-M1	
QARYR1	((A-QLARYL) DPB M-Q Q-POINTER 	;LAST ELEMENT # REF ED
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		 M-B DSP-ARRAY-SETUP)		;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-CALL-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-REF-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((A-QLARYH) Q-TYPED-POINTER M-A)	;PNTR TO HEADER OF LAST ARRAY REF ED
;DROPS THROUGH TO RETURN THE ARRAY CONTENTS (IN M-T)

;DROPS IN.  RETURN FROM X-TO-MACRO CALL TO AN ARRAY.
QARYR5	((M-3) A-IPMARK)		;GET POINTER TO (OLD) OPEN BLOCK
	((PDL-BUFFER-INDEX) ADD M-3 (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-C) C-PDL-BUFFER-INDEX)	;IN CASE CALL QRAD1 AND CLOBBER PDL INDEX
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-C)
	((M-1) SUB M-3 A-TEM1)
	((A-IPMARK) (BYTE-FIELD 10. 0) M-1)
	((PDL-BUFFER-POINTER) SUB M-3 (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	(CALL-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT)
			 M-C		;MULTI-VALUE CALL, STORE LAST VALUE
			 QRAD1)		;IN RIGHT PLACE, ETC
	((PDL-BUFFER-INDEX) M-AP)	;DISPATCH ON FCTN TYPE RE-ENTERING
	(DISPATCH-XCT-NEXT (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE 
		C-PDL-BUFFER-INDEX QMXRT1)
       (NO-OP)				;THERE MUST BE SOMETHING TO DO IN THIS INST

;QBNEAF AND QBALM FLUSHED
QBARY1	(JUMP-XCT-NEXT QIMOVE-EXIT)		;STORE VALUE
       ((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION)
	      M-C)

QBARY2	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-K) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC)
	       C-PDL-BUFFER-INDEX)
	((OA-REG-LOW) DPB M-K OAL-JUMP A-ZERO)
	(JUMP 0)

;MULTI-DIMENSIONAL ARRAY
QARY-MULTI
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)	;SPACE PAST LONG LENGTH IF
	((VMA-START-READ M-J) ADD M-A A-1 ALU-CARRY-IN-ONE)	; PRESENT
QARY-MULTI-1					;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-D) SUB M-D (A-CONSTANT 1))
	((Q-R) M-Q)
	(CALL-XCT-NEXT MPY)			;MULTIPLY M-1 
       ((M-1) Q-POINTER READ-MEMORY-DATA)	;BY CONTENTS OF Q-R, RESULT TO Q-R, BASH M-2
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP NIL)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-Q) ADD Q-R A-1)			;ADD NEXT SUBSCRIPT
	(JUMP-EQUAL (A-CONSTANT 1) M-D QARY-M1)	;JUMP IF THROUGH, FINAL SUBSC IN M-Q
	(JUMP-XCT-NEXT QARY-MULTI-1)
       ((VMA-START-READ M-J) ADD M-J A-ZERO ALU-CARRY-IN-ONE)

GAHD4	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-STACK-GROUP)) GAHD1)	;SG OK
	(CALL TRAP)			;BAD D.T. IN ARRAY-POINTER
   (ERROR-TABLE ARGTYP ARRAY M-A NIL GAHDR)

GAHDRA	((M-A) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART GAHDR)
GAHDR	((M-ZR) Q-DATA-TYPE M-A)	;FOR USE WHEN A IS NOT ALREADY KNOW TO BE
					; ARRAY-POINTER
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) GAHD4)
GAHD1	((VMA-START-READ M-VMA-HELD) M-A)	;GET ARRAY HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)	;ADDRESS MAP
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)	;GC, FOLLOW INVZ
	((M-A) M-VMA-HELD)		;MAY HAVE FORWARDED, GET REAL ADDRESS
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)	;VERIFY ARRAY HEADER DATA TYPE
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-HEADER)) ILLOP)
	((M-B) Q-POINTER READ-MEMORY-DATA)	;SAVE ARRAY HEADER Q
	((M-E) Q-POINTER M-A)		;INITIAL TYPELESS PNTR TO FIRST DATA ELEMENT
	((M-D) (LISP-BYTE %%ARRAY-NUMBER-DIMENSIONS) M-B)
	((M-E) ADD M-E A-D)		;ADDR OF FIRST DATA ELEMENT OF ARRAY (TYPELESS)
	(POPJ-AFTER-NEXT
	 (M-S) (LISP-BYTE %%ARRAY-INDEX-LENGTH-IF-SHORT) M-B)	;INDEX LENGTH
       (CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B GAHD3)

GAHD3	((VMA-START-READ) ADD M-A (A-CONSTANT 1))	;LONG ARRAY, GET INDEX LENGTH Q
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP SINCE JUST TOUCHED HEADER
	(POPJ-AFTER-NEXT (M-E) ADD M-E (A-CONSTANT 1))	;SPACE OVER INDEX Q
       ((M-S) Q-POINTER READ-MEMORY-DATA)

XAIXL (MISC-INST-ENTRY ARRAY-LENGTH)
	(CALL GAHDRA)
  (ERROR-TABLE CALLS-SUB ARRAY-LENGTH)
XAIXL1	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B)
       ((M-T) DPB M-S Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-READ) ADD M-E (A-CONSTANT 1))	;DISPLACED, GET INDEX LENGTH
XAIXL2	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	;NO TRANSPORT SINCE JUST TOUCHED HDR
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XAAIXL (MISC-INST-ENTRY ARRAY-ACTIVE-LENGTH)
	(CALL GAHDRA)
   (ERROR-TABLE CALLS-SUB ARRAY-ACTIVE-LENGTH)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B XAIXL1)
	(JUMP-XCT-NEXT XAIXL2)			;HAS LEADER, PICK UP FILL POINTER
       ((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HDR

DSP-ARRAY-SETUP   ;CALL WITH ARRAY POINTER IN M-A, HEADER IN M-B, 
		  ; FIRST DATA ELEM IN M-E, DESIRED ELEMENT NUMBER IN M-Q.
		  ;RETURNS WITH DATA ORIGIN IN M-E, M-S CHANGED TO REFLECT ARRAY
		  ; BEING REF'ED AND POSSIBLY ADJUSTED M-Q.
	((VMA-START-READ M-VMA-HELD) ADD A-ZERO M-E ALU-CARRY-IN-ONE)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)	;TRANSPORT IN CASE POINTS TO OLDSPACE
	((M-S) Q-POINTER READ-MEMORY-DATA)	;GET NEW DATA LENGTH LIMIT
	((VMA-START-READ M-VMA-HELD) M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)	;TRANSPORT IN CASE POINTS TO OLDSPACE
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) M-ZR DSP-ARRAY-INDIRECT)
	(POPJ-AFTER-NEXT 
	  (M-E) Q-POINTER READ-MEMORY-DATA)
       (NO-OP)

;OPERATION OF QDACMP:
; M-E HAS DATA BASE OF INDIRECT ARRAY HEADER
; M-Q HAS ENTRY NUMBER DESIRED
; READ-MEMORY-DATA HAS MEM(M-E), THE DATA TYPE OF WHICH IS ARRAY POINTER,
;  WHICH IS WHY WE GOT HERE.
;QDACMP PUSHES THE INFO RELATIVE TO THE INDIRECT ARRAY (M-A, M-B, M-D).
; M-E EVENTUALLY GETS THE DATA BASE OF THE POINTED TO ARRAY.
; M-S GETS MIN(M-S FROM INDIRECT ARRAY + INDEX OFFSET, INDEX LENGTH OF POINTED TO ARRAY).
; IN THE PROCESS, M-Q WILL BE ADJUSTED IF AN INDEX OFFSET IS ENCOUNTERED
; AFTER THE FINAL DATA BASE IS DETERMINED, M-A, M-B AND M-D ARE RESTORED.

DSP-ARRAY-INDIRECT 
QDACMP	((C-PDL-BUFFER-POINTER-PUSH) M-A)
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-D)
	((C-PDL-BUFFER-POINTER-PUSH)	;SAVE ARRAY-TYPE OF ORIGINALLY REF'ED ARRAY
		(LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)  ;THIS MUST BE IN 0@PP BELOW
QDACM2	((M-A) READ-MEMORY-DATA)	;POINTED-TO ARRAY
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA QDACM4)  ;HAS INDEX OFFSET
QDACM5	(CALL-XCT-NEXT GAHD1)		;SETS UP M-E, M-S
       ((C-PDL-BUFFER-POINTER-PUSH) M-S)	;SAVE POINTER'S INDEX LENGTH
  (ERROR-TABLE CALLS-SUB ARRAY-INDIRECT)
	((M-D) C-PDL-BUFFER-POINTER-POP)	;NOW TAKE MINIMUM OF THE TWO LENGTHS
	((M-1) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)  ;CHECK IF SAME ARRAY-TYPE AS ORIG REF
	(JUMP-NOT-EQUAL C-PDL-BUFFER-POINTER A-1 QDACM8)  ;NO, ORIG MUST CONTROL
	(JUMP-GREATER-OR-EQUAL M-D A-S QDACM7)
QDACM8	((M-S) M-D)
QDACM7	(JUMP-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B QDACM6) ;FURTHER INDIR
QDACM1	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH ARRAY TYPE
	((M-D) C-PDL-BUFFER-POINTER-POP) ;GOT ALL INFO, RESTORE M-A, M-B, M-D
	(POPJ-AFTER-NEXT 
	 (M-B) C-PDL-BUFFER-POINTER-POP)
       ((M-A) C-PDL-BUFFER-POINTER-POP)

QDACM6	((VMA-START-READ M-VMA-HELD) M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) M-ZR QDACM2) ;DOUBLE INDIRECT
	(JUMP-XCT-NEXT QDACM1)				;JUST DISPLACED
       ((M-E) READ-MEMORY-DATA)

QDACM4	((VMA-START-READ M-VMA-HELD) ADD (A-CONSTANT 2) M-E)	;HAS INDEX OFFSET
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE READ-MEMORY-DATA ERROR-UNLESS-FIX)
	((M-D) Q-POINTER READ-MEMORY-DATA)		;FETCH INDEX OFFSET
	((M-S) ADD M-S A-D)				;ADJUST INDEX LIMIT
	(JUMP-XCT-NEXT QDACM5)
       ((M-Q) ADD M-Q A-D)				;ADJUST CURRENT INDEX

QBARY	((M-J) (BYTE-FIELD 2 0) M-Q)		;BYTE ARRAY
	((A-TEM1) (BYTE-FIELD 26 2) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 2 3))	;LSH M-J 3 BECAUSE EA BYTE 8 BITS
	((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 10 0)))) )
QBFXIT	((M-J) SUB (M-CONSTANT 40) A-TEM2)	;REFLECT BECAUSE OF SHIFTER LOSSAGE
QBFXIT1	((OA-REG-LOW) DPB M-J A-TEM3 OAL-MROT)	;MODIFY NEXT INSTRUCTION
		;DPB NECESSARY BECAUSE M-J = 40 IF A-TEM2 WAS 0
	(POPJ-AFTER-NEXT 
	 BYTE-INST (M-T) READ-MEMORY-DATA)
       ((M-T) IOR (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) M-T)

QB1RY	((A-TEM1) (BYTE-FIELD 23 5) M-Q)	;BIT ARRAY
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) (BYTE-FIELD 5 0) M-Q)
	(JUMP-XCT-NEXT QBFXIT)			;NO LSH SINCE EA ELEMENT ONE BIT
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))) )

QB2RY	((M-J) (BYTE-FIELD 4 0) M-Q)		;2 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 24 4) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 4 1))	;LSH M-J 1
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 2 0)))) )

QB4RY	((M-J) (BYTE-FIELD 3 0) M-Q)		;4 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 25 3) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 3 2))	;LSH M-J 2
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 4 0)))) )

QB16RY	((M-J) (BYTE-FIELD 1 0) M-Q)		;16 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 27 1) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 1 4))	;LSH M-J 4
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 20 0)))) )

QB32RY	((VMA-START-READ) ADD A-Q M-E)		;32 BIT ARRAY (REALLY POINTER SIZE AND FORCE
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;FIXNUM DATA-TYPE) USEFUL FOR TV-BUFFER
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

QQARY	((VMA-START-READ M-VMA-HELD) ADD A-Q M-E)	;Q ARRAY
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

QTVARY	((A-TEM1) (BYTE-FIELD 24 4) M-Q)	;TV BUFFER ARRAY, BIT ARRAY WITH 16 BITS
	((VMA-START-READ) ADD A-TEM1 M-E)	;PER WORD.  ALSO BITS GO LEFT TO RIGHT!
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) (BYTE-FIELD 4 0) M-Q)
	((M-J) ADD M-J (A-CONSTANT 21))		;0 => BIT 17', 1 => BIT 16', 17 => BIT 0
	(JUMP-XCT-NEXT QBFXIT1)			;NO LSH SINCE EA ELEMENT ONE BIT
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))) )

;QBTPXL OUTLINE (SEE QSTPXL)
;  SAVE CHANNEL SELECT WD     M-R
;  ACCESS PLAN-ACTIVE WD      M-2
;  INITIALIZE PLANE-SELECT 0  M-1
;  INITIALIZE RESULT 0        M-S
;  INITIALIZE BIT-SHIFT 0     M-ZR
; L  PLANE-ACTIVE = 0 -> DONE (RESTORE CHNL SELECT)
;    PLANE-ACTIVE LSB = 0 -> GO X1
;    CALL QTVARY  GET RESULT IN M-T
;    DPB LOW BIT OF M-T INTO RESULT SHIFTED BY BIT-SHIFT
;    INCR BIT-SHIFT
; X1 LSH PLANE-ACTIVE -1
;    INCR PLANE-SELECT
;    GO L
QBTPXL	((VMA-START-READ) A-TV-PLANE-SELECT)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-R) (BYTE-FIELD 20 0) READ-MEMORY-DATA)
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-2) (BYTE-FIELD 10 0) READ-MEMORY-DATA)   ;BITS FOR MAX # OF PLANES
	((M-1) (BYTE-FIELD 10 0) M-R)                ;PLANE-SELECT
	((M-S) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))    ;BUILD UP RESULT
	((M-ZR) (M-CONSTANT -1))			     ;SHIFT AMT
QBTPX1	(JUMP-EQUAL M-2 A-ZERO QBTPXX)
	(JUMP-IF-BIT-CLEAR M-2 (BYTE-FIELD 1 0) QBTPX2)
	((VMA) A-TV-PLANE-SELECT)
	((WRITE-MEMORY-DATA-START-WRITE) M-1)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(CALL QTVARY)
	((OA-REG-LOW M-ZR) ADD M-ZR (A-CONSTANT 1))   ;INTO OAL-MROT FIELD
	((M-S) DPB M-T (BYTE-FIELD 1 0) A-S)          ;STORE BIT INTO RESULT
QBTPX2	((M-2) (BYTE-FIELD 7 1) M-2)
	(JUMP-XCT-NEXT QBTPX1)
       ((M-1) ADD M-1 (A-CONSTANT 400))

QBTPXX  (JUMP-XCT-NEXT QBTPX3)
       ((M-T) M-S)     ;GET RESULT AND GO TO RESTORE PLANE SELECT


   (MISC-INST-ENTRY GET-LOCATIVE-POINTER-INTO-ARRAY)
XGLOPR  ((M-R) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE))
		    C-PDL-BUFFER-POINTER-POP)	;FLUSH ARGUMENT
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)		;CONCEIVABLY SHOULD CHECK TO MAKE SURE Q ORIENTED
  (ERROR-TABLE CALLS-SUB GET-LOCATIVE-POINTER-INTO-ARRAY)
	(JUMP-XCT-NEXT XGLOP1)	;ARRAY
       ((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)

   (MISC-INST-ENTRY GET-LIST-POINTER-INTO-ARRAY)
XGLPA	((M-R) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST))
		     C-PDL-BUFFER-POINTER-POP)	;IGNORE ARGUMENT
					;GET LIST POINTER TO LAST ARRAY ELEMENT REF ED
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)
   (ERROR-TABLE CALLS-SUB GET-LIST-POINTER-INTO-ARRAY)
	((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)		;ENTRY NUMBER
XGLPA1	((M-ZR) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL (FIND-POSITION-IN-LIST 
						  'ART-Q-LIST 
						   ARRAY-TYPES))) TRAP)
   (ERROR-TABLE ARGTYP ART-Q-LIST-ARRAY M-A T NIL)
XGLOP1	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B 
		DSP-ARRAY-SETUP)  		;DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(POPJ-AFTER-NEXT 
	 (A-TEM3) IOR A-R M-Q)
      ((M-T) ADD A-TEM3 M-E)

     (MISC-INST-ENTRY G-L-P)		;(G-L-P <ARRAY-POINTER-TO-ART-Q-LIST-ARRAY>)
XGLPAR	(CALL-XCT-NEXT GAHD1)		; RETURNS LIST POINTER TO ARRAY CONTENTS
       ((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;IF FILL-POINTER 0, RETURN NIL
  (ERROR-TABLE CALLS-SUB G-L-P)
	(JUMP-IF-BIT-CLEAR M-B (LISP-BYTE %%ARRAY-LEADER-BIT) XGLPA2) ;JUMP ON NO LEADER
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HDR
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-ZR) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-ZR (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) XFALSE)
XGLPA2	((M-R) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(JUMP-XCT-NEXT XGLPA1)  ;RETURN POINTER TO ELEMENT NUMBER 0
       ((M-Q) A-ZERO)

XXSTOR (MISC-INST-ENTRY XSTORE)
	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;STORE IN LAST ARRAY ELEM REF ED
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)
   (ERROR-TABLE CALLS-SUB STORE)
	((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)
	(CALL-IF-BIT-SET M-B (LISP-BYTE %%ARRAY-DISPLACED-BIT) DSP-ARRAY-SETUP)
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ARRAY-TYPE-FIELD) 
		M-B ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((M-T) C-PDL-BUFFER-POINTER-POP)


;NOTE REFLECTING ABOUT 40 HACK NOT NECESSARY FOR DPB
QSBARY	((M-J) (BYTE-FIELD 2 0) M-Q)	;STORE IN BYTE ARRAY (8 BIT)
	((A-TEM1) (BYTE-FIELD 26 2) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) DPB M-J A-ZERO (BYTE-FIELD 2 3))	;LSH M-J 3 BECAUSE EA BYTE 8 BITS
	((M-J) ADD (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 10 0)))) M-J)
QSAXIT	((A-TEM1) READ-MEMORY-DATA)
	((OA-REG-LOW) M-J)			;MODIFY FOLLOWING INST FOR RIGH
       ((WRITE-MEMORY-DATA-START-WRITE) DPB M-T A-TEM1)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
CPOPJ	(POPJ)

QS1RY	((M-J) (BYTE-FIELD 5 0) M-Q)	;BIT ARRAY
	((A-TEM1) (BYTE-FIELD 23 5) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(JUMP-XCT-NEXT QSAXIT)
       ((M-J) ADD (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))) M-J)

QS2RY	((M-J) (BYTE-FIELD 4 0) M-Q)	;2 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 24 4) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) DPB M-J A-ZERO (BYTE-FIELD 4 1))	;LSH M-J 1
	(JUMP-XCT-NEXT QSAXIT)
       ((M-J) ADD (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 2 0)))) M-J)

QS4RY	((M-J) (BYTE-FIELD 3 0) M-Q)	;4 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 25 3) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) DPB M-J A-ZERO (BYTE-FIELD 3 2))	;LSH M-J 2
	(JUMP-XCT-NEXT QSAXIT)
       ((M-J) ADD (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 4 0)))) M-J)

QS16RY	((M-J) (BYTE-FIELD 1 0) M-Q)	;16 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 27 1) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) DPB M-J A-ZERO (BYTE-FIELD 1 4))	;LSH M-J 4
	(JUMP-XCT-NEXT QSAXIT)
       ((M-J) ADD (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 20 0)))) M-J)

QS32RY	((VMA) ADD A-Q M-E)	;32 BIT ARRAY
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) M-T)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

QSQARY	((VMA-START-READ) ADD A-Q M-E)	;Q ARRAY
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO TRANSPORT SINCE STORING AND JUST
	(JUMP-XCT-NEXT QSAXIT)			;TOUCHED HEADER AND DON'T ALLOW ONE-Q-FORWARD
       ((M-J) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-TYPED-POINTER))))

QSTVRY	((A-TEM1) (BYTE-FIELD 24 4) M-Q)	;TV BUFFER ARRAY.  ALSO REACHED FROM
	((VMA-START-READ) ADD A-TEM1 M-E)	; QSTPXL.
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) SETCM M-Q)			;LOW 4 BITS := 17 - M-Q
	(JUMP-XCT-NEXT QSAXIT)
       ((M-J) DPB M-J (BYTE-FIELD 4 0)
		 (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))))

;QSTPXL OUTLINE
;  SAVE CHANNEL SELECT WD 776660 (ACTUAL SELECT IS HIGH BYTE)  M-R
;  ACCESS PLANE-ACTIVE WD (ARRAY-LEADER 0)        M-2
;  INITIALIZE PLANE-SELECT 0                      M-1
; L  PLANE-ACTIVE = 0 -> DONE (RESTORE CHNL SELECT)
;    PLANE-ACTIVE LSB = 0 -> GO X1
;    CALL QSTVRY
;    LSH M-T,-1
; X1 LSH PLANE-ACTIVE -1
;    INCR PLANE-SELECT
;    GO L
QSTPXL	((C-PDL-BUFFER-POINTER-PUSH) M-T)   ;SAVE SO CAN BE RETURNED
	((VMA-START-READ) A-TV-PLANE-SELECT)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-R) (BYTE-FIELD 20 0) READ-MEMORY-DATA)
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-2) (BYTE-FIELD 10 0) READ-MEMORY-DATA)  ;BITS FOR MAX # OF PLANES
	((M-1) (BYTE-FIELD 10 0) M-R)    ;INITIALIZE CONSOLE-SELECT PART TO 0
QSTPX1	(JUMP-EQUAL M-2 A-ZERO QSTPXX)
	(JUMP-IF-BIT-CLEAR M-2 (BYTE-FIELD 1 0) QSTPX2)
	((VMA) A-TV-PLANE-SELECT)
	((WRITE-MEMORY-DATA-START-WRITE) M-1)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(CALL QSTVRY)
	((M-T) (BYTE-FIELD 27 1) M-T)
QSTPX2	((M-2) (BYTE-FIELD 7 1) M-2)
	(JUMP-XCT-NEXT QSTPX1)
       ((M-1) ADD M-1 (A-CONSTANT 400))

QSTPXX 	((M-T) C-PDL-BUFFER-POINTER-POP)   ;RETURN REASONABLE VALUE
QBTPX3	((VMA) A-TV-PLANE-SELECT)
	(POPJ-AFTER-NEXT 
	 (WRITE-MEMORY-DATA-START-WRITE) M-R)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

				
   (MISC-INST-ENTRY ARRAY-PUSH)
XFARY	((M-T) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDR)
       ((M-A) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB ARRAY-PUSH)
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B TRAP)
   (ERROR-TABLE ARRAY-HAS-NO-LEADER M-A)
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;REF FILL POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE READ-MEMORY-DATA TRAP-UNLESS-FIX)
   (ERROR-TABLE FILL-POINTER-NOT-FIXNUM M-A)
	((M-Q) Q-POINTER READ-MEMORY-DATA)	;THIS ONE GETS RELOCATED IF INDIRECT ARY
	((A-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)  ;A-TEM NOT CLOBBERED BY ARY ROUTINES
						;THIS COPY USED FOR INCREMENTING AND 
						;STORING BACK
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B 
			 DSP-ARRAY-SETUP)
	(JUMP-GREATER-OR-EQUAL M-Q A-S XFALSE)	;INDEX OUT OF BOUNDS, RETURN NIL, DON'T STORE
	((VMA) SUB M-A (A-CONSTANT 2))		;KNOW WILL WIN NOW, MUNG
	((WRITE-MEMORY-DATA-START-WRITE) ADD A-TEM M-ZERO ALU-CARRY-IN-ONE)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(DISPATCH-CALL (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B 
			ARRAY-TYPE-FILL-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
	(POPJ-AFTER-NEXT 	;RETURN ELEMENT NUMBER STORED INTO.
	 (M-T) A-TEM)
       ((M-T) IOR (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) M-T)

XFALAR	((A-TEM1) M-Q)			;HERE FROM ARRAY-TYPE-FILL-DISPATCH FOR Q-LIST-ARRAY
	((VMA) ADD A-TEM1 M-E)		;MUST HACK CDR CODES
	((WRITE-MEMORY-DATA-START-WRITE)  ;NO TRANSPORTER HACKERY NEEDED SINCE ADDRESSING
	     DPB M-T Q-TYPED-POINTER      ;A "FRESH" Q.
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(POPJ-EQUAL A-TEM M-ZERO)	;FIRST ENTRY, DO NOTHING
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSPORT NEEDED (JUST FIDDLING
	(CALL-CONDITIONAL PG-FAULT PGF-R)               ;CDR CODE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE)
	     DPB READ-MEMORY-DATA Q-TYPED-POINTER
		    (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
       (CALL-CONDITIONAL PG-FAULT PGF-W)

   (MISC-INST-ENTRY STORE-ARRAY-LEADER)
XSALDR	(CALL XFLAD1)		;STORE IN ARRAY LEADER
;NEEDS TRANSPORTER HACKERY HERE IF ONE-Q-FORWARD S IN ARRAY-LEADERS ARE TO BE SUPPORTED.
	(POPJ-AFTER-NEXT (M-T WRITE-MEMORY-DATA-START-WRITE) 
		Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)	;INTERRUPT O.K. HERE

   (MISC-INST-ENTRY ARRAY-LEADER)
XFALDR	(CALL XFLAD1)			;FETCH ELEMENT IN ARRAY LEADER
  (ERROR-TABLE CALLS-SUB ARRAY-LEADER)
	((VMA-START-READ M-VMA-HELD) VMA)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)		;INTERRUPT O.K. HERE
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XFLAD1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX) ;COMPUTE ADDRESS
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;OR ARRAY LEADER ELEMENT
	(CALL-XCT-NEXT GAHDR)
       ((M-A) C-PDL-BUFFER-POINTER-POP)
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B TRAP)	;NO LEADER
   (ERROR-TABLE ARRAY-HAS-NO-LEADER M-A)
   (ERROR-TABLE RESTART XFLAD1-A)
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;GET LENGTH OF ARRAY LEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	((A-TEM1) Q-POINTER READ-MEMORY-DATA)
	(CALL-GREATER-OR-EQUAL M-Q A-TEM1 TRAP)		;SUBSCRIPT OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q RMD XFLAD1-A)
	(POPJ-AFTER-NEXT (A-TEM1) ADD M-Q (A-CONSTANT 2))
       ((VMA M-VMA-HELD) SUB M-A A-TEM1)	;SET UP BOTH.. NEEDS M-VMA-HELD AT XAPLD

XAHLP  (MISC-INST-ENTRY ARRAY-HAS-LEADER-P)
	(CALL GAHDRA)
  (ERROR-TABLE CALLS-SUB ARRAY-HAS-LEADER-P)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B XFALSE)
	(JUMP XTRUE)

XAR1   (MISC-INST-ENTRY AR-1)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
  (ERROR-TABLE CALLS-SUB AR-1)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 1) TRAP)
  (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 1)
XAR1A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-Q TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM M-Q 1)
	((M-Q) Q-POINTER M-Q)
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		M-B DSP-ARRAY-SETUP)	;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
  (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-CALL-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-REF-DISPATCH)
  (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       (NO-OP)
	(POPJ)

XAPLD (MISC-INST-ENTRY AP-LEADER)	;RETURN LOCATIVE POINTER TO LEADER ELEMENT
	(CALL XFLAD1)			;SET UP M-VMA-HELD
  (ERROR-TABLE CALLS-SUB AP-LEADER)
	(JUMP XAP1B)

XAP1  (MISC-INST-ENTRY AP-1)	;RETURN LOCATIVE POINTER TO ARRAY ELEMENT REF'ED
	(CALL XAR1)		;REF ARRAY, LEAVING M-B AND M-VMA-HELD SET UP
  (ERROR-TABLE CALLS-SUB AP-1)
XAP1A	((M-1) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)	;COULD USE DISPATCH HERE ...
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-Q ARRAY-TYPES))) XAP1B)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-Q-LIST ARRAY-TYPES))) XAP1B)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-REG-PDL ARRAY-TYPES))) XAP1B)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-SPECIAL-PDL ARRAY-TYPES))) TRAP)
  (ERROR-TABLE NUMBER-ARRAY-NOT-ALLOWED M-B)
XAP1B	(POPJ-AFTER-NEXT 
	 (M-T) DPB M-VMA-HELD Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (NO-OP)


XAS1  (MISC-INST-ENTRY AS-1)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB AS-1)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 1) TRAP)
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 1)
XAS1A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-Q TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM M-Q 2)
	((M-Q) Q-POINTER M-Q)
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		M-B DSP-ARRAY-SETUP)		;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((M-T) C-PDL-BUFFER-POINTER-POP)	;DATA TO STORE

XAP2  (MISC-INST-ENTRY AP-2)
	(CALL XAR2)		;DO IT THIS WAY TO SAVE A RANDOM A-CONSTANT
   (ERROR-TABLE CALLS-SUB AP-2)
	(JUMP XAP1A)

XAS2  (MISC-INST-ENTRY AS-2)
	(JUMP-XCT-NEXT XAS2B)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAS1A)))

XAR2  (MISC-INST-ENTRY AR-2)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAR1A)))
XAS2B	((M-J) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
  (ERROR-TABLE CALLS-SUB AX-2)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 2) TRAP)
  (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 2)
XAR2A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-J TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM M-J 2)
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)   ;SPACE PAST LONG-LENGTH Q IF
	((VMA-START-READ) ADD M-A A-1 ALU-CARRY-IN-ONE)	   ; PRESENT
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSPORT SINCE JUST TOUCHED HDR
	((M-1) Q-POINTER M-J)
	(CALL-XCT-NEXT MPY)
       ((Q-R) READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT 
	 (A-TEM1) Q-POINTER Q-R)
       ((M-Q) ADD M-Q A-TEM1)

XAP3  (MISC-INST-ENTRY AP-3)
	(CALL XAR3)
  (ERROR-TABLE CALLS-SUB AP-3)
	(JUMP XAP1A)

XAS3  (MISC-INST-ENTRY AS-3)
	(JUMP-XCT-NEXT XAS3B)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAS1A)))

XAR3  (MISC-INST-ENTRY AR-3)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAR1A)))
XAS3B	((M-I) C-PDL-BUFFER-POINTER-POP)
	((M-J) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB AX-3)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 3) TRAP)
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 3)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-I TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM M-I 3)
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)
	((M-1) ADD M-1 (A-CONSTANT 2))   ;TO SECOND DIMENSION
	((VMA-START-READ) ADD M-A A-1)   ;SPACE PAST LONG-LENGTH Q IF PRESENT
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSPORT SINCE JUST TOUCHED HEADER
	((M-1) Q-POINTER M-I)
	(CALL-XCT-NEXT MPY)
       ((Q-R) READ-MEMORY-DATA)
	((A-TEM1) Q-POINTER Q-R)
	(JUMP-XCT-NEXT XAR2A)
       ((M-J) ADD M-J A-TEM1)

XCARCL (MISC-INST-ENTRY COPY-ARRAY-CONTENTS-AND-LEADER)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;TO
	((M-C) C-PDL-BUFFER-POINTER-POP)		;FROM
	(CALL-XCT-NEXT GALPTR)
       ((M-A) M-C)
	((M-Q) M-S)					;LENGTH OF FROM LEADER
	((M-J) M-E)					;HIGH ADDRESS OF FROM LEADER
	(CALL-XCT-NEXT GALPTR)
       ((M-A) M-T)
	((M-I) A-ZERO)					;CURRENT ARRAY LEADER INDEX
XCALD1	(JUMP-GREATER-OR-EQUAL M-I A-S XCARC0)		;TO LEADER DONE, GO COPY DATA
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-I A-Q XCALD2)
       ((WRITE-MEMORY-DATA) A-V-NIL)			;IF FROM LEADER EXHAUSTED, USE NIL
	((VMA-START-READ M-VMA-HELD) M-J)		;GET FROM ARRAY LEADER ITEM
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-J) SUB M-J (A-CONSTANT 1))
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)
XCALD2	((VMA-START-WRITE) M-E)				;STORE IN TO ARRAY LEADER ITEM
	(CALL-CONDITIONAL PG-FAULT PGF-W)		;NO TRANSP HERE SINCE TOUCHED HEADER?
	((M-E) SUB M-E (A-CONSTANT 1))
	(JUMP-XCT-NEXT XCALD1)
       ((M-I) ADD M-I (A-CONSTANT 1))
	
;NOTE:  AN OPTIMIZATION TO DO IT WORD BY WORD MIGHT BE HANDY...
XCARC (MISC-INST-ENTRY COPY-ARRAY-CONTENTS)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;TO
	((M-C) C-PDL-BUFFER-POINTER-POP)		;FROM
XCARC0	(CALL-XCT-NEXT GADPTR)
       ((M-A) M-C)
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-CONTENTS)
	((M-R) M-S)					;FROM LENGTH
	((M-C) M-E)					;FROM ADDRESS
	((M-I) M-Q)					;FROM INITIAL INDEX
	((M-K) M-B)					;FROM ARRAY HEADER
	(CALL-XCT-NEXT GADPTR)
       ((M-A) M-T)
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-CONTENTS)
	((M-Q) SUB M-Q (A-CONSTANT 1))			;KLUDGE
XCARC1	((M-Q) ADD M-Q (A-CONSTANT 1))
	(JUMP-GREATER-OR-EQUAL M-Q A-S XTRUE)		;TO ARRAY DONE, RETURN
	(JUMP-GREATER-OR-EQUAL M-I A-R XCARC3)		;JUMP IF FROM ARRAY EXHAUSTED
	((C-PDL-BUFFER-POINTER-PUSH) M-Q)
	((C-PDL-BUFFER-POINTER-PUSH) M-E)
	((M-Q) M-I)
	(DISPATCH-CALL-XCT-NEXT				;M-T := FROM ITEM, CLOBBER M-J
		(LISP-BYTE %%ARRAY-TYPE-FIELD) M-K ARRAY-TYPE-REF-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-K)
       ((M-E) M-C)
	((M-E) C-PDL-BUFFER-POINTER-POP)
	((M-Q) C-PDL-BUFFER-POINTER-POP)
XCARC4	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XCARC1)))
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((M-I) ADD M-I (A-CONSTANT 1))

;COMPUTE FILLER VALUE IN M-T, REENTER AT XCARC4
XCARC3	((M-J) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)
	(JUMP-LESS-THAN-XCT-NEXT M-J (A-CONSTANT 7) XCARC4)
       ((M-T) A-ZERO)			;ONE OF THE SIX BYTE ARRAYS, PAD WITH ZERO
	(JUMP-NOT-EQUAL-XCT-NEXT M-J (A-CONSTANT 9) XCARC4)
       ((M-T) A-V-NIL)			;SOME KIND OF Q ARRAY, PAD WITH NIL
	(JUMP-XCT-NEXT XCARC4)
       ((M-T) (A-CONSTANT 200))		;STRING, PAD WITH NULL

;GET ADDRESS AND LENGTH OF ARRAY LEADER
GALPTR	(CALL GAHDR)
	((M-E) SUB M-A (A-CONSTANT 2))		;ADDRESS
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-LEADER-BIT) M-B)
       ((M-S) A-ZERO)				;LENGTH
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(POPJ-AFTER-NEXT
	 (M-S) Q-POINTER READ-MEMORY-DATA)
       (NO-OP)

;GET ADDRESS, LENGTH, AND INITIAL INDEX OF ARRAY
GADPTR	(CALL GAHDR)
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B)
       ((M-Q) A-ZERO)
	(JUMP DSP-ARRAY-SETUP)

XNUMBP (MISC-INST-ENTRY NUMBERP)
	((M-K) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-K POPJ-IF-NOT-NUMBER)
       ((M-T) A-V-NIL)
	(JUMP XTRUE)

XDATTP (MISC-INST-ENTRY %DATA-TYPE)
	(POPJ-AFTER-NEXT 
	 (M-T)  C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		Q-DATA-TYPE)
       (NO-OP)

XDAT   (MISC-INST-ENTRY %POINTER)
	(POPJ-AFTER-NEXT 
	 (M-T)  C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		Q-POINTER)
       (NO-OP)

XSDATP (MISC-INST-ENTRY %MAKE-POINTER)
	((A-TEM1) C-PDL-BUFFER-POINTER-POP)    ;ARG2, THE POINTER
	(POPJ-AFTER-NEXT 
	 (M-T) C-PDL-BUFFER-POINTER-POP)       ;ARG1, THE DATA TYPE
       ((M-T) DPB M-T Q-DATA-TYPE A-TEM1)
	
XSTND (MISC-INST-ENTRY %P-STORE-CONTENTS)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;NEED IN M-T FOR RETURNED VALUE
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)
	((VMA) M-VMA-HELD)
	(POPJ-AFTER-NEXT 
	 (WRITE-MEMORY-DATA-START-WRITE)
	    SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XOPLDB(MISC-INST-ENTRY %P-LDB-OFFSET)
	(JUMP-XCT-NEXT XOPLD1)			;JOIN XLDB, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION

XPLDB (MISC-INST-ENTRY %P-LDB)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;VMA MAY POINT AT UNBOXED DATA.
XOPLD1	(JUMP-XCT-NEXT XPLDB1)
       ((M-1) READ-MEMORY-DATA)			;VMA MAY BE LEFT POINTING AT UNBOXED DATA..

XLDB  (MISC-INST-ENTRY LDB)
	((M-1) C-PDL-BUFFER-POINTER-POP)   ;ARG2, THING TO LDB OUT OF
XPLDB1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) ;ARG1, BYTE POINTER.  MUST BE FIXNUM.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XLDB-ZERO)  ;WANT 0 BITS, RETURN 0
					   ; (THIS IS A FAIRLY RANDOM THING TO CHECK FOR
					   ; BUT IF WE DIDNT, IT WOULD CAUSE LOSSAGE)
	((M-J) SUB M-K (A-CONSTANT 1))	   ;BECAUSE BITS IN LDB IS +1
	((A-TEM2) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	((A-TEM2) SUB (M-CONSTANT 40) A-TEM2)	  ;COMPENSATE FOR SHIFTER LOSSAGE
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-J A-TEM2 OAL-BYTL-1)
       ((M-T) BYTE-INST 
		M-1 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XLSH-ZERO 
XLDB-ZERO 
	(POPJ-AFTER-NEXT 
	 (M-T) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) ;RESULT = 0
		    C-PDL-BUFFER-POINTER-POP)	;DON'T FORGET TO POP ARG1
       (NO-OP)

XOPDPB(MISC-INST-ENTRY %P-DPB-OFFSET)
	(JUMP-XCT-NEXT XOPDP1)			;JOIN XDPB, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE DATA AND SET VMA

XPDPB (MISC-INST-ENTRY %P-DPB)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;VMA MAY POINT TO UNBOXED DATA
XOPDP1	(CALL-XCT-NEXT XPDPB1)
       ((A-TEM3) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) M-T)	;VMA CAN BE LEFT POINTING AT UNBOXED DATA
 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (CALL-CONDITIONAL PG-FAULT PGF-W)	;PRESUMABLY, THIS IS OK...
       
XDPB (MISC-INST-ENTRY DPB)
	((A-TEM3) DPB C-PDL-BUFFER-POINTER-POP ;ARG3, DATA TO STORE IN
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XPDPB1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		 ;ARG2, BYTE POINTER
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER) ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XDPB-ZERO)
	((M-K) SUB M-K (A-CONSTANT 1))
	((A-TEM1) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-K A-TEM1 OAL-BYTL-1)
       ((M-T) DPB C-PDL-BUFFER-POINTER-POP A-TEM3)

XDPB-ZERO (POPJ-AFTER-NEXT 			;RESULT IS ARG3
	    (M-T) SETA A-TEM3 C-PDL-BUFFER-POINTER-POP)
	 ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;AND POP OTHER TWO ARGS

XOPMF (MISC-INST-ENTRY %P-MASK-FIELD-OFFSET)
	(JUMP-XCT-NEXT XOPMF1)			;JOIN XMF, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION

XPMF  (MISC-INST-ENTRY %P-MASK-FIELD)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
XOPMF1	(JUMP-XCT-NEXT XPFM1)
       ((M-1) READ-MEMORY-DATA)

XMF   (MISC-INST-ENTRY MASK-FIELD)	;LIKE LDB BUT DATA IN ORIGINAL POSITION IN Q
	((M-1) C-PDL-BUFFER-POINTER-POP)	;DATA TO EXTRACT
XPFM1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) ;ARG1, BYTE POINTER.  MUST BE FIXNUM.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XLDB-ZERO)  ;WANT 0 BITS, RETURN 0
					   ; (THIS IS A FAIRLY RANDOM THING TO CHECK FOR
					   ; BUT IF WE DIDNT, IT WOULD CAUSE LOSSAGE)
	((M-J) SUB M-K (A-CONSTANT 1))	   ;BECAUSE BITS IN LDB IS +1
	((A-TEM2) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	(POPJ-AFTER-NEXT 		   ;NO "SHIFTER LOSSAGE" ON SELECTIVE-DEPOSIT
	 (OA-REG-LOW) DPB M-J A-TEM2 OAL-BYTL-1)
       ((M-T) SELECTIVE-DEPOSIT 
		M-1 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XOPDF(MISC-INST-ENTRY %P-DEPOSIT-FIELD-OFFSET)
	(JUMP-XCT-NEXT XOPDF1)			;JOIN XDF, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION AND SET VMA

XPDF (MISC-INST-ENTRY %P-DEPOSIT-FIELD)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
XOPDF1	(CALL-XCT-NEXT XPDF1)
       ((A-TEM3) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) M-T)
 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

XDF  (MISC-INST-ENTRY DEPOSIT-FIELD)
	((A-TEM3) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG3, DATA TO STORE IN
XPDF1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		 ;ARG2, BYTE POINTER
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER) ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XDPB-ZERO)
	((M-K) SUB M-K (A-CONSTANT 1))
	((A-TEM1) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-K A-TEM1 OAL-BYTL-1)
       ((M-T) SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER-POP A-TEM3)

XCMBS (MISC-INST-ENTRY %P-STORE-TAG-AND-POINTER)
	((A-TEM3) Q-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG3, VALUE FOR POINTER FIELD
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)	      ;ARG3 ANY TYPE, MISCBITS MUST BE FIXNUM
			Q-DATA-TYPE C-PDL-BUFFER-POINTER ERROR-UNLESS-FIX)
	((WRITE-MEMORY-DATA) DPB C-PDL-BUFFER-POINTER-POP ;ARG2, VALUE FOR TYPE, ETC.
		Q-ALL-BUT-POINTER A-TEM3)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE M-T) C-PDL-BUFFER-POINTER-POP) ;ARG1, WHERE TO STORE
       (CALL-CONDITIONAL PG-FAULT PGF-W)

XPDAT (MISC-INST-ENTRY %P-POINTER)
	((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-POINTER))))
XPDAT1  ((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	(POPJ-AFTER-NEXT
	 (OA-REG-LOW) M-K)
       ((M-T) BYTE-INST READ-MEMORY-DATA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XPDATP (MISC-INST-ENTRY %P-DATA-TYPE)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-DATA-TYPE))))

XPCDRC (MISC-INST-ENTRY %P-CDR-CODE)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-CDR-CODE))))

XPFLAG (MISC-INST-ENTRY %P-FLAG-BIT)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-FLAG-BIT))))

XSPDTP (MISC-INST-ENTRY %P-STORE-DATA-TYPE)
	((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-DATA-TYPE))))
XSPDTP1 ((M-T) C-PDL-BUFFER-POINTER-POP)	;DATA TO DPB IN (ALSO RETURN AS VALUE)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO INTERRUPT TO PRESERVE M-K
	((A-TEM2) READ-MEMORY-DATA)
	((OA-REG-LOW) M-K)
	(POPJ-AFTER-NEXT 
	 (WRITE-MEMORY-DATA-START-WRITE)
	   DPB M-T A-TEM2)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XSPDAT (MISC-INST-ENTRY %P-STORE-POINTER)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-POINTER))))

XSPCDR (MISC-INST-ENTRY %P-STORE-CDR-CODE)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-CDR-CODE))))

XSPUSR (MISC-INST-ENTRY %P-STORE-FLAG-BIT)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-FLAG-BIT))))

;PROVIDES A WAY TO PICK UP EXTERNAL VALUE CELL POINTERS.  SHOULD
;IT NOT FOLLOW OTHER INVISIBLES?
XPCAL (MISC-INST-ENTRY %P-CONTENTS-AS-LOCATIVE)
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)	;GET SPECD LOCATION
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
XPCAL1	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(POPJ-AFTER-NEXT
	  DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;FLUSH OLDSPACE POINTER
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

XPCALO (MISC-INST-ENTRY %P-CONTENTS-AS-LOCATIVE-OFFSET)
	(JUMP-XCT-NEXT XPCAL1)
       (CALL XOMR0)					;GET SPECD LOCATION
	
XPDIF (MISC-INST-ENTRY %POINTER-DIFFERENCE)
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	  (M-T) SUB C-PDL-BUFFER-POINTER-POP A-T)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;; Give this an offset into the IO part of the XBUS, not an XBUS address.
;; Someday it will return a bignum; for now, it returns the low 24 bits.
XXBR (MISC-INST-ENTRY %XBUS-READ)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;XBUS WORD ADDR
	(JUMP-XCT-NEXT XUBR1)
       ((VMA-START-READ) ADD M-A (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS))

XUBR (MISC-INST-ENTRY %UNIBUS-READ)
	((M-A) (BYTE-FIELD 17. 1) C-PDL-BUFFER-POINTER-POP)	;UBUS WORD ADDR
	((VMA-START-READ) ADD M-A (A-CONSTANT LOWEST-UNIBUS-VIRTUAL-ADDRESS))
XUBR1	(CALL-CONDITIONAL PG-FAULT PGF-R)	;MUSTN'T CHECK FOR INTERRUPTS SINCE
				;ON SOME UNIBUS DEVICES READING HAS SIDE EFFECTS AND
				;IF AN INTERRUPT OCCURRED WE WOULD READ IT TWICE
	(POPJ-AFTER-NEXT
	 (M-T) DPB READ-MEMORY-DATA Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

;; See comments on %XBUS-READ above.
XXBW (MISC-INST-ENTRY %XBUS-WRITE)
	((M-T WRITE-MEMORY-DATA) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;WORD TO WRITE
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-A (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS))
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XUBW (MISC-INST-ENTRY %UNIBUS-WRITE)
	((M-T WRITE-MEMORY-DATA) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;WORD TO WRITE
	((M-A) (BYTE-FIELD 17. 1) C-PDL-BUFFER-POINTER-POP)	;UBUS WORD ADDR
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-A (A-CONSTANT LOWEST-UNIBUS-VIRTUAL-ADDRESS))
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XGET (MISC-INST-ENTRY GET)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG2, PROPERTY NAME
	(CALL-XCT-NEXT PLGET) ;ARG2, FROB TO GET FROM, GET ITS PLIST INTO M-T
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XGET1	(POPJ-EQUAL M-T A-V-NIL)		;END OF PLIST REACHED
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE THIS PLIST NODE
	(JUMP-EQUAL M-T A-A QTAD)		;GOT IT, RETURN CADR OF NODE
	(JUMP-XCT-NEXT XGET1)
       (CALL QTDD)				;TAKE CDDR AND LOOK AGAIN

;SUBROUTINE TO PICK UP THE PLIST OF THE OBJECT IN M-T, RETURNING IT IN M-T.
;RETURNS NIL IF A RANDOM TYPE, FOR MACLISP COMPATIBILITY.  UNFORTUNATELY
;NOT USEFUL FOR PLIST-CHANGING THINGS, BUT THOSE AREN'T CURRENTLY IN MICROCODE ANYWAY.
PLGET	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) PLGET2)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) QCDR) ;"DISEMBODIED" PROPERTY LIST
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) QCDR) ;"DISEMBODIED" PROPERTY LIST
	(JUMP XFALSE)				;GET OF RANDOM THINGS NIL IN MACLISP, SO ...

PLGET2	((VMA-START-READ M-VMA-HELD) ADD M-T		;ARG1, SYMBOL TO GET FROM
			      (A-CONSTANT 3))		;GET PLIST CELL OF ARG1
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XGETL (MISC-INST-ENTRY GETL)
	((M-S) C-PDL-BUFFER-POINTER-POP)	;ARG2, LIST OF PROPERTIES
	(CALL-XCT-NEXT PLGET)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;ARG1, THING TO GET FROM
XGETL1	(POPJ-EQUAL M-T A-V-NIL)		;EXHAUSTED THE PLIST
	(CALL-XCT-NEXT QCAR)			;GET NEXT INDICATOR
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE CURRENT PLIST NODE
	((M-A) Q-TYPED-POINTER M-T)		;SAVE IT
	((M-T) Q-TYPED-POINTER M-S)		;GET LIST OF PROPERTY NAMES
XGETL2	(JUMP-EQUAL M-T A-V-NIL XGETL3)		;NO MATCH THIS ONE
	(CALL-XCT-NEXT QCAR)			;GET NEXT PROP NAME TO TRY
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL M-T A-A POP1TJ)		;GOT IT
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;TRY NEXT PROP NAME
	(JUMP XGETL2)

XGETL3	(JUMP-XCT-NEXT XGETL1)       
       (CALL QTDD)				;TRY NEXT PROPERTY

POP1TJ	(POPJ-AFTER-NEXT
	  (M-GARBAGE) C-PDL-BUFFER-POINTER-POP)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

XASSQ (MISC-INST-ENTRY ASSQ)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG2
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG1
XASSQ1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QMAA)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL M-T A-A QTA)
	(JUMP-XCT-NEXT XASSQ1)
       (CALL QTD)

POPTJ	(POPJ-AFTER-NEXT
	  (M-T) C-PDL-BUFFER-POINTER-POP)
       (NO-OP)

XLAST (MISC-INST-ENTRY LAST)
	((M-T) C-PDL-BUFFER-POINTER)
XLAST1	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP POPTJ)
	(CALL-XCT-NEXT QCDR)
       ((C-PDL-BUFFER-POINTER) M-T)
	(JUMP XLAST1)

XLENGT (MISC-INST-ENTRY LENGTH)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART LENGTH)
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (CALL-NOT-EQUAL M-T A-V-NIL TRAP)
   (ERROR-TABLE ARGTYP LIST M-T T LENGTH)
	((C-PDL-BUFFER-POINTER-PUSH) 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XLEN1	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP POPTJ)
	(CALL QCDR)
	(JUMP-XCT-NEXT XLEN1)
       ((C-PDL-BUFFER-POINTER) ADD C-PDL-BUFFER-POINTER (A-CONSTANT 1))

X1PLS (MISC-INST-ENTRY 1+)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP T)
	(POPJ-AFTER-NEXT
	 (M-K) ADD C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1))
       ((M-T) DPB M-K Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

X1MNS (MISC-INST-ENTRY 1-)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP T)
	(POPJ-AFTER-NEXT
	 (M-K) SUB C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1))
       ((M-T) DPB M-K Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XZEROP (MISC-INST-ENTRY ZEROP)
	((M-K) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-K POPJ-IF-NOT-NUMBER)
       ((M-T) A-V-NIL)
	(POPJ-NOT-EQUAL M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP XTRUE)

XSET (MISC-INST-ENTRY SET)
	((M-T) C-PDL-BUFFER-POINTER-POP) 		;ARG2, NEW VALUE & RESULT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		;ARG1, THE SYMBOL TO SET
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP 0)
	((VMA-START-READ M-VMA-HELD) ADD C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1)) ;ACCESS V.C.
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)	;READ VALUE CELL FIRST
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;FOLLOW INVISIBLES
	((VMA) M-VMA-HELD)				;RESTORE VMA
	(POPJ-AFTER-NEXT			       	;WRITE NEW VALUE
	 (WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT Q-ALL-BUT-TYPED-POINTER 
	    READ-MEMORY-DATA A-T)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XNOT (MISC-INST-ENTRY NOT)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-T A-V-NIL XTRUE)
	(JUMP XFALSE)

XATOM (MISC-INST-ENTRY ATOM)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-ATOM)
	(JUMP XFALSE)
	(JUMP XTRUE)

XHALT (MISC-INST-ENTRY %HALT)
	(JUMP HALT-CONS XHALT)
	(JUMP XFALSE)

XGPN  (MISC-INST-ENTRY GET-PNAME)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-POINTER)))

XBOOLE (MISC-INST-ENTRY *BOOLE)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 2)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG3, SECOND NUMBER
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG2, FIRST NUMBER
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)	    ;ARG1, FUNCTION CODE
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-1) (BYTE-FIELD 2 2) C-PDL-BUFFER-POINTER)
	((A-TEM2) XOR M-1 (A-CONSTANT 3))		;CONVERT 6205 TO 74S181
	((M-1) DPB C-PDL-BUFFER-POINTER (BYTE-FIELD 1 3) A-TEM2)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 1) C-PDL-BUFFER-POINTER-POP XBOOLE1)
	((M-1) IOR M-1 (A-CONSTANT 4))
XBOOLE1	((OA-REG-LOW) DPB M-1 (BYTE-FIELD 4 4) A-ZERO)
	(POPJ-AFTER-NEXT (M-K) SETCM M-K A-S)	    ;SETCM=BOOLEAN OP 0
       ((M-T) DPB M-K Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XPLUSP (MISC-INST-ENTRY PLUSP)
	((M-K) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-K POPJ-IF-NOT-NUMBER)
       ((M-T) A-V-NIL)
	(POPJ-IF-BIT-SET BOXED-SIGN-BIT M-K)	;POPJ IF NEGATIVE
	(POPJ-EQUAL M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;POPJ IF ZERO
	(JUMP XTRUE)					;STRICTLY > 0, RETURN T

XMINUSP (MISC-INST-ENTRY MINUSP)
	((M-K) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-K POPJ-IF-NOT-NUMBER)
       ((M-T) A-V-NIL)
	(POPJ-IF-BIT-CLEAR BOXED-SIGN-BIT M-K)
	(JUMP XTRUE)

; SHIFTING WITH CONS ...
;   THE CONS HARDWARE TAKES THE OPPOSITE APPROACH FROM MOST MACHINES IN THAT
; LDB AND DPB ARE PRIMITIVE AND SHIFTS HAVE TO BE BUILT UP OUT OF THEM INSTEAD
; OF THE OTHER WAY AROUND.  FOR THE PURPOSES OF CONS, THIS IS USUALLY A GREAT
; WIN, BUT IT DOES MAKE FOR A CERTAIN AMOUNT OF PAIN WHEN REALLY TRYING TO DO A SHIFT.
;   FURTHER PAIN IS CAUSED WHEN THE AMOUNT OF THE SHIFT MUST COME FROM THE
; "DATA" SIDE OF THE MACHINE (AS WITH ROT AND LSH) INSTEAD OF BEING A CONSTANT AMOUNT
; KNOWN AT MICRO-ASSEMBLY TIME.  WHEN THIS IS THE CASE,
;  (1) THE ARGUMENT MUST BE "MOVED" FROM THE DATA SIDE TO THE CONTROL SIDE BY THE USE
;	OF OA- TYPE DESTINATIONS.  AS A COLLARY OF THIS, IT IS NECESSARY TO MASK THINGS
;	CAREFULLY TO AVOID RANDOMNESS, AND THERE IS NOT MUCH FLEXIBILITY AS TO 
;	WHAT SIGNS THINGS HAVE ETC.  VARIOUS "QUIRKS" OF THE HARDWARE, NORMALLY
;	COMPENSATED FOR BY THE MICRO-ASSEMBLER, MUST BE DELT WITH BY THE USER:
;	(A) THE BYTE LENGTH FIELD IS REALLY THE	<BYTE-LENGTH-1> FIELD.
;	    ALSO, BECAUSE THE FIELD IS 5 BITS LONG, ZERO BIT BYTES DONT WIN
;	    AT ALL (THEY "BECOME" 32. BYTES).
;	(B) ONE MUST REMEMBER THE M-ROTATE IS ALWAYS A LEFT ROTATE.  THIS IS 
;	    "NATURAL" FOR DPB, BUT ON LDB THE MICROASSEMBLER NORMALLY HAS TO 
;	    BUGGER THINGS TO COMPENSATE AND MAKE IT APPEAR A RIGHT SHIFT IS
;	    BEING DONE.  NATURALLY, USING OA- MODIFIERS, THERE IS NO OPPORTUNITY
;	    FOR THIS TO HAPPEN WITHOUT BEING EXPLICITLY CODED IN MICRO-INSTRUCTIONS.
;	    THE BUGGER REQUIRED IS TO "REPLACE" THE M-ROTATE FIELD WITH
;	      (LOGAND 37 (- 40 <"NATURAL" M-ROTATE>)).
;	    IF MF3 (LOW-PC-BIT-SELECTS-HW) IS BEING USED, THE CONSTANTS ARE 17 AND 20.
;	    FORTUNATELY, THIS IS VERY RARE AND DOES NOT OCCUR HERE.
;  (2) THE POSSIBITY OF CONSTRUCTING AN "ILLEGAL" BYTE POINTER ON A DPB MUST BE 
;	CAREFULLY CONSIDERED.  BRIEFLY, THE SUM <BYTE-LENGTH-1> + <M-ROTATE> MUST BE
;	LESS THAN OR EQUAL TO 37 OCTAL.  IF IT IS GREATER, THE HARDWARE WILL
;	PRODUCE AN ALL-ZERO ANSWER (ACTUALLY, IT IS COMPLETELY IDENTICALLY EQUAL TO THE
;	A-SOURCE).  HERE A LDB DOESNT GIVE SO MUCH PROBLEM SINCE
;	THE HARDWARE JUST ROTATES THE INDICATED AMOUNT AND TAKES THE LOW N BITS.

XLSH  (MISC-INST-ENTRY LSH)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG2, AMT TO SHIFT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT M-K XLSH1)  ;SHIFT TO RIGHT
LSH-LEFT
	((M-1) SUB (M-CONSTANT 23.) A-K)	;COMPUTE BYTE LENGTH <24.-SHIFT-1>
	(JUMP-LESS-THAN M-1 A-ZERO XLSH-ZERO)
	(POPJ-AFTER-NEXT
	 (OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-K)
       ((M-T) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 0 0) 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XLSH1	(JUMP-LESS-THAN M-K (A-CONSTANT (PLUS 1_24. -23.)) XLSH-ZERO) ;SHIFT RIGHT
	((A-TEM1) ADD M-K (A-CONSTANT (PLUS (EVAL (LSH -1 24.))  ;TO SIGN EXTEND TO 32.
					 40)))	;COMPUTE 40-N .
	((M-1) ADD M-K (A-CONSTANT (PLUS (EVAL (LSH -1 24.))
					 23.)))	;COMPUTE 24.-N-1
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-TEM1)
       ((M-T) BYTE-INST (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
			C-PDL-BUFFER-POINTER-POP)

XROT  (MISC-INST-ENTRY ROT)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG2, AMT TO ROT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG1, DATA TO ROT
XROT3 ;	(CALL-CONDITIONAL JUMP-ON-INTERRUPT-PENDING-CONDITION
      ;		INTSER)			;THIS SEEMS LIKE A GOOD IDEA (SOMEDAY, MAYBE)
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT M-K XROT1)  ;ROT TO RIGHT
	(JUMP-EQUAL M-K A-ZERO CPOPJ)			;NO CHANGE (AVOID BYTL-1 LOSS)
	(JUMP-GREATER-OR-EQUAL M-K (A-CONSTANT 24.) XROT2)
;GENERAL IDEA: (1) SHIFT A 24.-N BIT PIECE N PLACES LEFT
;		    (ACTUALLY, A TRUE SHIFT OF A UNMASKED 32 BIT PIECE WOULD DO.
;		     ON THE OTHER HAND, WE HAVE THE UNSAFE BYTE POINTER PROBLEM.)
;	       (2) LDB A N BIT PIECE FROM 24-N BITS OVER
;	       (3) IOR THE TWO.
XROT3A	;REALLY DO THE WORK. BY NOW, 0 < M-K < 24.
						;DO LSH OF STEP ONE
	((M-1) SUB (M-CONSTANT 23.) A-K)	;COMPUTE BYTE LENGTH
;	(JUMP-LESS-THAN M-1 A-ZERO XLSH-ZERO)   ;CANT BE
	((OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-K)
	((A-TEM3) DPB M-T (BYTE-FIELD 0 0) A-ZERO)	;PART 1 DONE
	((A-TEM2) ADD M-K (A-CONSTANT 8))		;COMPUTE 40-<24.-N>
	((M-ZR) SUB M-K (A-CONSTANT 1))		;BYTE LENGTH MINUS ONE
	((OA-REG-LOW) DPB M-ZR OAL-BYTL-1 A-TEM2)
	(POPJ-AFTER-NEXT			;PART 2 DONE
	  (M-T) BYTE-INST M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) IOR M-T A-TEM3)			;PART 3

XROT2	(JUMP-XCT-NEXT XROT3)			;LOOP UNTIL RESULT AFTER
       ((M-K) SUB M-K (A-CONSTANT 24.))		;SUBTRACTION IS LESS THAN 24.

;ROTATE TO RIGHT.  CONVERT TO EQUIVALENT LEFT ROTATE (24.- <-N>)
XROT1	((M-K) SELECTIVE-DEPOSIT M-K Q-POINTER (A-CONSTANT -1))	;EXTEND SIGN
	(JUMP-XCT-NEXT XROT3)
       ((M-K) ADD M-K (A-CONSTANT 24.))

XPNPCL (MISC-INST-ENTRY PRINT-NAME-CELL-LOCATION)
	((A-TEM1) A-ZERO)
XCL1	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	(POPJ-AFTER-NEXT 
	 (M-T) DPB Q-POINTER C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       ((M-T) ADD M-T A-TEM1)

XVCL  (MISC-INST-ENTRY VALUE-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 1))

XFCL  (MISC-INST-ENTRY FUNCTION-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 2))

XPRPCL (MISC-INST-ENTRY PROPERTY-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 3))

XPACKCL (MISC-INST-ENTRY PACKAGE-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 4))


XFCTEV (MISC-INST-ENTRY FSYMEVAL)
	(JUMP-XCT-NEXT XSYME2)
       ((M-1) (A-CONSTANT 2))

XSYMEV (MISC-INST-ENTRY SYMEVAL)
	((M-1) (A-CONSTANT 1))
XSYME2	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
	 	  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	((VMA-START-READ M-VMA-HELD) ADD C-PDL-BUFFER-POINTER-POP A-1)
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;VMA DATA TYPE NOT KOSHER FOR INT.
	;((VMA) READ-MEMORY-DATA)	;ADDRESS MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;GC, FOLLOW INVZ
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XALLB (MISC-INST-ENTRY MAKE-LIST)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIX)
  (ERROR-TABLE ARGTYP FIXNUM PP 2)
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG 2 NUMBER OF QS
	(JUMP-IF-BIT-CLEAR BOXED-SIGN-BIT M-B XALLB0)	;SIGN EXTEND SO ERROR CHECK WILL
	((M-B) DPB M-B Q-POINTER (A-CONSTANT -1))	;   WORK
  (ERROR-TABLE RESTART XALLB0)
XALLB0	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XALLB1)
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FIX)) TRAP)
  (ERROR-TABLE ARGTYP (FIXNUM SYMBOL) PP 1 XALLB0)
	(JUMP-XCT-NEXT IALLB)
       ((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG 1 AREA

XALLB1  ((VMA-START-READ M-VMA-HELD) ADD C-PDL-BUFFER-POINTER (A-CONSTANT 1)) ;VALUE CELL
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-ZR C-PDL-BUFFER-POINTER) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR A-V-NIL XALLB0)	;BEWARE! NO PASS AROUND PATH ON PDL BUFFER
	((C-PDL-BUFFER-POINTER) A-CNSADF)
	(JUMP XALLB0)

XMEMQ (MISC-INST-ENTRY MEMQ)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XMEMQ1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(POPJ-EQUAL-XCT-NEXT M-T A-A)
       ((M-T) C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT XMEMQ1)
       (CALL QCDR)

XFPIL (MISC-INST-ENTRY FIND-POSITION-IN-LIST)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-B) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XFPIL1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL-XCT-NEXT M-T A-A XFPLX)
       ((M-T) C-PDL-BUFFER-POINTER-POP)
	((M-B) ADD M-B A-ZERO ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT XFPIL1)
       (CALL QCDR)

XFPLX	(POPJ-AFTER-NEXT 
	 (M-T) M-B)
       (NO-OP)

   (MISC-INST-ENTRY LISTP)
XLISTP	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-LIST)
	(JUMP XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY NLISTP)
XNLSTP	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-ATOM)
	(JUMP XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY SYMBOLP)
XSYMP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY NSYMBOLP)
XNSYMP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY ARRAYP)
XARRYP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY STRINGP)
XSTRNP	((M-A) C-PDL-BUFFER-POINTER-POP)
	((M-ZR) Q-DATA-TYPE M-A)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) XFALSE)
	((VMA-START-READ M-VMA-HELD) M-A)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-ZR) (LISP-BYTE %%ARRAY-TYPE-FIELD) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-STRING ARRAY-TYPES))) XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY FBOUNDP)
XFCTNP	(JUMP-XCT-NEXT XBOUNP1)
       ((M-1) (A-CONSTANT 2))

   (MISC-INST-ENTRY BOUNDP)
XBOUNP	((M-1) (A-CONSTANT 1))
XBOUNP1	((M-A) C-PDL-BUFFER-POINTER-POP)
	((M-ZR) Q-DATA-TYPE M-A)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XFALSE)
	((VMA-START-READ M-VMA-HELD) ADD M-A A-1)
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;NOT USING CONTENTS, DON'T BARF IF NULL
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)		;AND DON'T TRANSPORT
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-NULL)) XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY CLOSURE)	;(CLOSURE <CLOSURE-LIST> <FCTN>)
XCLOS	((M-1) PDL-BUFFER-POINTER)
	((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 1))
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	((M-B) (A-CONSTANT 1))
XCLOS1	(JUMP-EQUAL M-T A-V-NIL XCLOS2)		;DETERMINE SIZE OF CLOSURE BLOCK REQD
	(CALL-XCT-NEXT QCAR)
       ((M-C) M-T)
;CHECK FOR & MUMBLES ..
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-C)
	(JUMP-XCT-NEXT XCLOS1)
       ((M-B) ADD M-B (A-CONSTANT 2))

XCLOS2	(CALL-XCT-NEXT IALLB)
       ((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)
	((M-1) C-PDL-BUFFER-POINTER-POP)	;FCTN
	((M-S C-PDL-BUFFER-POINTER-PUSH) M-T)	;INTO POSITION FOR RPLACA AND SAVE COPY
	(CALL-XCT-NEXT QRAR1)			;(RPLACA <CLOSURE-BLOCK> <FCTN>)
       ((M-T) M-1)				;FCTN
	(CALL QCDR)				;STEP BLOCK POINTER
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((M-1) PDL-BUFFER-POINTER)
	((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 2))
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
;0(IP) -> FILL POINTER, -1(IP) -> CLOSURE BLOCK, -2(IP) CLOSURE-LIST
XCLOS4	(JUMP-EQUAL M-T A-V-NIL XCLOSX)		;BLOCK PNTR IN M-T
	(CALL QCAR)
	(DISPATCH Q-DATA-TYPE M-T TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL M-T NIL)
	((M-S) C-PDL-BUFFER-POINTER-POP)		;FILL POINTER  (IN POSITION FOR RPLACA)
	((M-T) DPB M-T Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CALL-XCT-NEXT QRAR1)
       ((M-T C-PDL-BUFFER-POINTER-PUSH) ADD M-T A-ZERO ALU-CARRY-IN-ONE)
					;POINTER TO INTERNAL VALUE CELL
	(CALL QCDR)		;UPDATE FILL POINTER
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)	;READ INTERNAL VALUE CELL
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE FILL POINTER
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-1) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL DTP-EXTERNAL-VALUE-CELL-POINTER)) 
			XCLOS3A)	;XFER ON EXTERNAL VALUE CELL ALREADY EXISTS
	((C-PDL-BUFFER-POINTER-PUSH) M-VMA-HELD)	;SAVE POINTER TO INTERNAL VALUE CELL
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;SAVE INTERNAL VALUE CELL CONTENTS
	((M-B) (A-CONSTANT 1))
	(CALL-XCT-NEXT IALLB)
       ((M-S) DPB M-ZERO Q-ALL-BUT-POINTER A-CNSADF)
	((WRITE-MEMORY-DATA) DPB C-PDL-BUFFER-POINTER Q-TYPED-POINTER  ;V-C CONTENTS
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	((VMA-START-WRITE) M-T)		;WRITE INTO NEW EXTERNAL V-C
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((M-T) DPB M-T Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTERNAL-VALUE-CELL-POINTER)))
	((WRITE-MEMORY-DATA) SELECTIVE-DEPOSIT Q-ALL-BUT-TYPED-POINTER 
		C-PDL-BUFFER-POINTER-POP A-T)
	((VMA-START-WRITE) C-PDL-BUFFER-POINTER-POP)	;WRITE INTO INTERNAL V-C
	(CALL-CONDITIONAL PG-FAULT PGF-W)
XCLOS3	((M-T) DPB M-T Q-POINTER       ;TO AVOID PROFUSION OF RANDOM D.T.S.  AVOIDS LOSSAGE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE))) ;WITH CAR IN QCLS1
					;QCLS1 CHANGES BACK TO DTP-EXT-V-C EVENTUALLY
	(CALL-XCT-NEXT QRAR1)				;FORWARDING PNTR IN M-T
       ((M-S) C-PDL-BUFFER-POINTER-POP)			;GET BACK FILL POINTER
	(CALL QCDR)			;BUMP FILL POINTER
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((M-1) PDL-BUFFER-POINTER)	;BUMP BLOCK POINTER
	((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 2))
	(CALL-XCT-NEXT QCDR)
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	((M-1) PDL-BUFFER-POINTER)	;PDL-BUFFER-INDEX NOT SAVED ACROSS INTERRUPTS
	((PDL-BUFFER-INDEX) SUB M-1 (A-CONSTANT 2))
	(JUMP-XCT-NEXT XCLOS4)
       ((C-PDL-BUFFER-INDEX) M-T)

XCLOS3A	(JUMP-XCT-NEXT XCLOS3)
       ((M-T) READ-MEMORY-DATA)		;POINTER TO EXTERNAL V-C

XCLOSX	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH FILL POINTER
	(POPJ-AFTER-NEXT 
	 (M-T) DPB C-PDL-BUFFER-POINTER-POP Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-CLOSURE)))
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH CLOSURE-LIST
	    
;;; MULTIPLY SUBROUTINE
;M-1 TIMES Q-R, RESULT TO Q-R, LEAVES CORRECT HIGH HALF IN M-2.
;CALLER MUST CHECK FOR OVERFLOW, IF SHE CARES.

MPY	((M-2) MULTIPLY-STEP A-1 M-ZERO)
(REPEAT 30. ((M-2) MULTIPLY-STEP A-1 M-2))
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 0) Q-R)
       ((M-2) MULTIPLY-STEP A-1 M-2)
	(POPJ-AFTER-NEXT
	 (M-2) M-2 SUB A-1)		;FINAGLE IF NEGATIVE VALUE INITIALLY IN Q-R
       (NO-OP)

;;; DIVIDE SUBROUTINE
;   DIVIDEND IN M-1, DIVISOR IN M-2
;   QUOTIENT IN Q-R, REMAINDER IN M-1, CLOBBERS A-TEM1

DIV	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-1 A-ZERO DIV1)
       ((A-TEM1 Q-R) M-1)	;Q GETS MAGNITUDE OF DIVIDEND, A-TEM1 SAVES ORIGINAL
	((Q-R) SUB M-ZERO A-TEM1)
DIV1	((M-1) DIVIDE-FIRST-STEP M-ZERO A-2)
DIV1A	(CALL-IF-BIT-SET (BYTE-FIELD 1 0) Q-R TRAP)	;DIVIDE OVERFLOW
  (ERROR-TABLE DIVIDE-BY-ZERO)
(REPEAT 31. ((M-1) DIVIDE-STEP M-1 A-2))
	((M-1) DIVIDE-LAST-STEP M-1 A-2)
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-ZERO A-TEM1 DIV2) ;JUMP IF POSITIVE DIVIDEND
       ((M-1) DIVIDE-REMAINDER-CORRECTION-STEP M-1 A-2) ;M-1 GETS MAGNITUDE OF REMAINDER
	((M-1) SUB M-ZERO A-1)		;NEGATIVE DIVIDEND => NEGATIVE REMAINDER
DIV2	((A-TEM1) XOR M-2 A-TEM1)	;IF SIGNS OF DIVIDEND AND DIVISOR ARE DIFFERENT,
	(POPJ-LESS-OR-EQUAL M-ZERO A-TEM1)
	(POPJ-AFTER-NEXT
	 (A-TEM1) Q-R)
       ((Q-R) SUB M-ZERO A-TEM1)	;THEN QUOTIENT IS NEGATIVE

;RUNTIME SUPPORT FOR MICRO COMPILED CODE (MOSTLY, ANYWAY)

XMAPLY 
UAPLY  (MISC-INST-ENTRY M-APPLY)
	((M-R) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
	(CALL-XCT-NEXT XARGI0)		;RETURN ARG-INFO IN M-T
       ((A-NWADI) A-ZERO)		;GO TO UAPFX TO LEAVE THEM LISTIFIED
	((M-1) (LISP-BYTE %%ARG-DESC-MAX-ARGS) M-T)
	(JUMP-NOT-EQUAL M-1 A-ZERO UAPLY1)	;IF ANY SPREAD ARGS, SPREAD THEM
				;ABOVE 2 INSTRUCTIONS ARE ONLY HERE BECAUSE
				;LINEAR ENTER WOULD BOMB OUT OTHERWISE
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-QUOTED-REST) M-T UAPFX)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-EVALED-REST) M-T UAPFX)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-INTERPRETED) M-T UAPFX) ;BE CONSERVATIVE
UAPLY1	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;GET BACK FCTN
	((M-C) MICRO-STACK-DATA-POP)		;MICRO RETURN ADDRESS
	(CALL P3LNK)				;PUSH CALL BLOCK, POSSIBLY WITH ADI
						; MV LINK
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;FINISH CALL BLOCK BY PUSHING FCTN
	((M-S) A-ZERO)				;COUNT OF # ARGS PUSHED
	(DISPATCH Q-DATA-TYPE M-R SKIP-IF-LIST)
	 (JUMP MMCAL4)
UAPLY5	(CALL-XCT-NEXT QCAR)
       ((M-T) M-R)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-TYPED-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-R)
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP UAPLY6)
	((M-R) M-T)
	(JUMP-XCT-NEXT UAPLY5)
       ((M-S) ADD M-S (A-CONSTANT 1))
	
UAPLY6	((C-PDL-BUFFER-POINTER) DPB C-PDL-BUFFER-POINTER Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(JUMP-XCT-NEXT MMCAL4)
       ((M-S) ADD M-S (A-CONSTANT 1))

UAPFX	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;GET BACK FUNCTION.
	((M-C) MICRO-STACK-DATA-POP)		;MICRO RETURN ADDRESS
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
	(CALL-XCT-NEXT P3LNK)
       ((A-NWADI) (A-CONSTANT 2))
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((C-PDL-BUFFER-POINTER-PUSH) M-R)
	(JUMP-XCT-NEXT MMCAL4)
       ((M-S) (A-CONSTANT 1))

P3LNK   (JUMP-IF-BIT-SET %%-PPBMAA M-C P3LNK1)  ;M-C HAS POPPED MICRO-STACK-DATA, SEE IF
        (JUMP-IF-BIT-SET %%-PPBMIA M-C P3LNK1)	; INDIRECT POINTER TO ADI ON STACK 
						; NEEDED
P3LNK2	(JUMP-EQUAL A-NWADI M-ZERO P3ZERO)	;NO ADI HACKERY
UAPLY4	(JUMP-XCT-NEXT MMASU1)
       ((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%LP-CLS-ADI-PRESENT 1))))

P3LNK1	((M-J) PDL-BUFFER-POINTER)		;SEE IF INDIRECT ADI POINTER NEEDED
	((M-J) SUB M-J A-NWADI)
	(JUMP-IF-BIT-SET %%-PPBMIA M-C P3LNK1A)
	((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
P3LNK1A	((M-K) M-J)		;HEAD OF ADI
P3LNK1B	(DISPATCH Q-DATA-TYPE ERROR-UNLESS-FIX C-PDL-BUFFER-INDEX)
	((M-ZR) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL ADI-RETURN-INFO)) UAPY3B)	
						 ;YEP, FOUND RETURN VALUE ADI
	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)
	((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT 1))
	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX P3LNK1B)
       ((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT 1))
	(JUMP P3LNK2)

UAPY3B	(CALL CONVERT-PDL-BUFFER-ADDRESS)	;CONVERT M-K TO VIRTUAL ADDRESS
	(JUMP-EQUAL A-NWADI M-ZERO UAPY3B1)
	((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K)
UAPY3B1	((C-PDL-BUFFER-POINTER-PUSH) M-K)
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS (PLUS 
		(BYTE-VALUE Q-FLAG-BIT 1)
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-INDIRECT))))
	((M-1) (A-CONSTANT 2))
	(JUMP-XCT-NEXT UAPLY4)
       ((A-NWADI) ADD M-1 A-NWADI)

;%ARGS-INFO <FUNCTION>   FUNCTION CAN BE ANYTHING MEANINGFUL IN
;FUNCTION CONTEXT. RETURNS FIXNUM.  FIELDS AS IN NUMERIC-ARG-DESC-INFO IN QCOM.

XARGI (MISC-INST-ENTRY %ARGS-INFO)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
;ENTER HERE FROM APPLY, ALSO REENTER TO TRY AGAIN (CLOSURE, ETC).
XARGI0	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-S XARGI-DISPATCH)  ;INHIBIT-XCT-NEXT UNLESS
       ((M-T) (A-CONSTANT (PLUS (PLUS 			    ; INTERPRETER TRAP
 		(BYTE-VALUE Q-DATA-TYPE DTP-FIX) 
		(BYTE-MASK %%ARG-DESC-INTERPRETED))
		(BYTE-MASK %%ARG-DESC-MAX-ARGS))))

XAGISG	(POPJ-AFTER-NEXT				;STACK GROUP ACCEPTS ANY NUMBER
	 (M-T) DPB (M-CONSTANT -1) (LISP-BYTE %%ARG-DESC-MAX-ARGS)	;OF EVALED ARGS
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XAGUE1	(JUMP-XCT-NEXT XAGUE2)				    ;UCODE-ENTRY
       ((VMA-START-READ) ADD M-S A-V-MICRO-CODE-ENTRY-/#-ARGS)

XAGICL	(CALL-XCT-NEXT QCAR)				    ;CLOSURE
       ((M-T) M-S)			;REPLACE BY CAR OF IT AND TRY AGAIN.
	(JUMP-XCT-NEXT XARGI0)
       ((M-S) M-T)

XAGAR1	((VMA-START-READ M-VMA-HELD) M-S)		;ARRAY-POINTER
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT 
	 (M-T)
	  (LISP-BYTE %%ARRAY-NUMBER-DIMENSIONS)
	 	 READ-MEMORY-DATA
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) DPB M-T (LISP-BYTE %%ARG-DESC-MIN-ARGS) A-T)  ;COPY INTO BOTH MAX AND MIN

XAGM1	((VMA-START-READ M-VMA-HELD) ADD
		 M-S (A-CONSTANT (EVAL %FEFHI-FAST-ARG-OPT)));MACRO-COMPILED
XAGUE2	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XARGI3	((VMA-START-READ M-VMA-HELD) ADD M-S (A-CONSTANT 2))	;SYM, REPLACE W FCTN CELL
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT XARGI0)
       ((M-S) Q-TYPED-POINTER READ-MEMORY-DATA)

;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
MMCALL	((M-C) MICRO-STACK-DATA-POP)
MMCAL1	((M-S) READ-I-ARG)	;DISPATCH CONSTANT GIVES NUMBER OF ARGS BEING PASSED
MMCAL4	;PDP10 INTERPRETER ERROR CHECKS ON DATA-TYPE OF M-AP@P, BUT THATS A
	;FAIRLY RANDOM CHECK SO IT IS OMMITTED HERE.
MMCAL5	
MMCAL5A	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((C-PDL-BUFFER-INDEX) DPB M-C Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((A-NARGS) M-S)
	((M-S) PDL-BUFFER-POINTER)
	((M-S) SUB M-S A-NARGS)
	((M-S PDL-BUFFER-INDEX) (BYTE-FIELD 10. 0) M-S)
	(CALL-NOT-EQUAL M-S A-IPMARK ILLOP)
	((M-A) C-PDL-BUFFER-INDEX)		;GET FUNCTION TO CALL
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;DOES MLLV IF NECC
       (CALL MLLV)

XOMR (MISC-INST-ENTRY %P-CONTENTS-OFFSET)
	(CALL XOMR0)				;READ THE SPECIFIED LOCATION
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)	;RETURN ITS CONTENTS

XOMR0	((M-B) C-PDL-BUFFER-POINTER-POP)	;GET THE OFFSET
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)	;READ THE HEADER WORD
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)	;FOLLOW DTP-FORWARD
	(POPJ-AFTER-NEXT
	 (VMA-START-READ) ADD M-VMA-HELD A-B)	;NOW REFERENCE THE SPECIFIED LOCATION
       (CALL-CONDITIONAL PG-FAULT PGF-R)	;VMA COULD BE POINTING INTO UNFORWARDED DATA

XOMS  (MISC-INST-ENTRY %P-STORE-CONTENTS-OFFSET)
	(CALL XOMR0)				;READ THE SPECIFIED LOCATION, SET VMA
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT			;STORE INTO Q-TYPED-POINTER
	 (WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

;%MAKE-POINTER-OFFSET <new data type> <pointer> <offset> returns a pointer whose pointer
;   is (+ (%POINTER <pointer>) <offset>) and whose data type is <new data type>.  No data
;   type checks.
XMOP (MISC-INST-ENTRY %MAKE-POINTER-OFFSET)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
		(M-T) ADD C-PDL-BUFFER-POINTER-POP A-T)
       ((M-T) DPB Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP A-T)

XSTACQ (MISC-INST-ENTRY %STORE-CONDITIONAL) ;args are pointer, old-val, new-val
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;new
	((M-B) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;old
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP) ;pntr
	(CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER)
	;((VMA) READ-MEMORY-DATA)		;address the map
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-1) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-B A-1 XFALSE)		;Return NIL if old-val was wrong
	((M-T) A-V-TRUE)			;Otherwise, store new-val
	((VMA) M-VMA-HELD)			;Restore VMA
	(POPJ-AFTER-NEXT			; and return T
	 (WRITE-MEMORY-DATA-START-WRITE) DPB
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-A)
       (CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT INTSER-WRITE)

XSFP (MISC-INST-ENTRY %STACK-FRAME-POINTER)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-AP)
	(POPJ-AFTER-NEXT (M-T) M-K)
       (NO-OP)

XMADD (MISC-INST-ENTRY M-+)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M-+)
	((M-1) ADD M-1 A-2)
	(DISPATCH-POPJ-XCT-NEXT (BYTE-FIELD 2 23.) M-1 D-FXOVCK)	;CHECK FOR OVERFLOW
   (ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMSUB (MISC-INST-ENTRY M--)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M--)
	((M-1) SUB M-1 A-2)
	(DISPATCH-POPJ-XCT-NEXT (BYTE-FIELD 2 23.) M-1 D-FXOVCK)	;CHECK FOR OVERFLOW
   (ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMMUL (MISC-INST-ENTRY M-*)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M-*)
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-2)
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
	(POPJ-EQUAL-XCT-NEXT M-2 A-ZERO)	;RETURN IF NON-OVERFLOWING POSITIVE RESULT
       ((M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-EQUAL M-2 (A-CONSTANT -1))	;RETURN IF NON-OVERFLOWING NEGATIVE
	(CALL TRAP)				;RESULT SHOULD BE A BIGNUM
   (ERROR-TABLE FIXNUM-OVERFLOW M-T NOPUSH)

;TEMPORARY DOUBLE PRECISION KLUDGE.  DOESN'T CHECK FOR OVERFLOW (PRESUMABLY CAN'T ANYWAY!)
XMUL-FRACTIONS (MISC-INST-ENTRY %MULTIPLY-FRACTIONS)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %MULTIPLY-FRACTIONS)
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-2)
	(POPJ-AFTER-NEXT
	 (M-T) (BYTE-FIELD 8 24.) Q-R (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) DPB M-2 (BYTE-FIELD 16. 8) A-T)

;SPECIAL NON-OVERFLOW-CHECKING FUNCTIONS FOR WEIRD HACKS
X24ADD (MISC-INST-ENTRY %24-BIT-PLUS)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %24-BIT-PLUS)
	(POPJ-AFTER-NEXT (M-1) ADD M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

X24SUB (MISC-INST-ENTRY %24-BIT-DIFFERENCE)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %24-BIT-DIFFERENCE)
	(POPJ-AFTER-NEXT (M-1) SUB M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

X24MUL (MISC-INST-ENTRY %24-BIT-TIMES)
	(CALL FXGTPP)
    (ERROR-TABLE CALLS-SUB %24-BIT-TIMES)
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-2)
	(POPJ-AFTER-NEXT (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XMDIV (MISC-INST-ENTRY M-//)
	(CALL FXGTPP)
    (ERROR-TABLE CALLS-SUB M-//)
	(CALL DIV)
XMDIV1	(POPJ-AFTER-NEXT
	 (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XREM (MISC-INST-ENTRY \)
	(CALL FXGTPP)
    (ERROR-TABLE CALLS-SUB \)
	(CALL DIV)
XREM1	(POPJ-AFTER-NEXT
	 (M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XDIV-DOUBLE (MISC-INST-ENTRY %DIVIDE-DOUBLE)
	(JUMP-XCT-NEXT XMDIV1)
       (CALL XDIVD1)					;CALL DOUBLE PRECISION DIVIDE

XREM-DOUBLE (MISC-INST-ENTRY %REMAINDER-DOUBLE)
	(JUMP-XCT-NEXT XREM1)
       (CALL XDIVD1)					;CALL DOUBLE PRECISION DIVIDE

;DOUBLE PRECISION DIVIDE.  ARGS ON PDL ARE DIVIDEND HIGH, DIVIDEND LOW, DIVISOR
XDIVD1	(CALL FXGTPP)					;M-1 GETS DIVIDEND LOW, M-2 DIVISOR
	(CALL-XCT-NEXT FIXGET)				;M-1 GETS DIVDND HIGH, M-2 DIVSR AGAIN
       ((M-A) M-1)					;SAVE DIVIDEND LOW
	((M-3) DPB M-1 (BYTE-FIELD 8 24.) A-A)		;LOW WORD HAS 32 BITS
	((M-A) (BYTE-FIELD 24. 8) M-1 A-1)		;ARITH SHIFT M-1 RIGHT 8 FOR HIGH WORD
	(JUMP-GREATER-OR-EQUAL M-1 A-ZERO XDIVD3)	;MAKE DIVIDEND POSITIVE
	(JUMP-NOT-EQUAL-XCT-NEXT M-3 A-ZERO XDIVD2)	;DOUBLE PRECISION NEGATE M-A|M-3
       ((M-3) SUB M-ZERO A-3)
	((M-A) SUB M-A (A-CONSTANT 1))			;BORROW IF LOW WORD IS ZERO
XDIVD2	((M-A) SETCM M-A)				;ONES COMPLEMENT HIGH WORD
XDIVD3	;DIVIDEND IS IN M-A (HIGH), M-3 (LOW), DIVISOR IS IN M-2
	((A-TEM1) M-1)	;ORIGINAL SIGN OF DIVIDEND IS IN SIGN(A-TEM1) FOR DIVIDE
	((Q-R) M-3)					;LOW DIVIDEND TO Q-R FOR DIVIDE
	(JUMP-XCT-NEXT DIV1A)				;JOIN NORMAL DIVIDE ROUTINE
       ((M-1) DIVIDE-FIRST-STEP M-A A-2)		;BUT WITH DIFFERENT FIRST STEP

XMAND (MISC-INST-ENTRY M-LOGAND)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M-LOGAND)
	(POPJ-AFTER-NEXT
	 (M-1) AND M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMXOR (MISC-INST-ENTRY M-LOGXOR)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M-LOGXOR)
	(POPJ-AFTER-NEXT
	 (M-1) XOR M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMIOR (MISC-INST-ENTRY M-LOGIOR)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB M-LOGIOR)
	(POPJ-AFTER-NEXT
	 (M-1) IOR M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMAX (MISC-INST-ENTRY *MAX)
	(CALL FXGTPP)			;ARGS TO M-1 AND M-2
   (ERROR-TABLE CALLS-SUB *MAX)
	((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT POPJ-GREATER-OR-EQUAL M-1 A-2)
       ((M-T) DPB M-2 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XMIN (MISC-INST-ENTRY *MIN)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB *MIN)
	((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-1 A-2)
       ((M-T) DPB M-2 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;;; THE TRANSPORTER

;		"Energize!"
;		     -- J. T. Kirk
;
;	SIMPLIFIED INITIAL VERSION WHICH DOESN'T ACTUALLY TRANSPORT ANYTHING,
;	JUST HACKS INVISIBLE POINTERS
;MAY USE A-TEM1, A-TEM2, A-TEM3, M-1 BUT NOTE PAGE FAULTS CLOBBER THESE

;THE INITIAL SETUP SAVES THE MEMORY DATA INTO A-TRANS-DATA AND SETS
;UP THE MICRO STACK SO THAT THERE ARE TWO RETURN ADDRESSES; THE UPPER
;ONE IS THE ADDRESS OF THE DISPATCH INSTRUCTION AND THE ONE BELOW THAT
;IS THE INSTRUCTION TO BE EXECUTED IMMEDIATELY AFTER THE DISPATCH (IF
;IT DROPS THROUGH.)

;ENTER HERE FOR TRAPPING DATA TYPE.  OK IF GOING TO WRITE
TRANS-TRAP
	((A-TRANS-DATA) READ-MEMORY-DATA)	;VMA ALREADY SAVED IN M-VMA-HELD
	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO UNIBUS
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 637772001)) ;LOCATION 764000
	((VMA-START-READ) (A-CONSTANT 1))	;FETCH LOCATION 764002
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULDN'T HAPPEN
	((MICRO-STACK-DATA-PUSH)
		 (BYTE-FIELD 12. 0) READ-MEMORY-DATA) ;CATCH RETURN ADDRESS
						;OUT OF THE OPCS.  NOTE CAREFUL TIMING,
						;6 INSTRUCTIONS TO HERE!
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP
	(CALL-IF-BIT-CLEAR (BYTE-FIELD 1 4) READ-I-ARG TRAP)	;BARF IF READING RANDOM DATA
  (ERROR-TABLE TRANS-TRAP) ;This is a special entry, which the EH knows all about.
	;RETURN TO CALLER, CAUSING DISPATCH TO DROP THROUGH BY OA-MODIFYING IT.
TRANS-DROP-THROUGH	
	((VMA) (A-CONSTANT 376))		;ON THIS MACHINE, RESTORING R-M-D IS KLUDGEY
	((WRITE-MEMORY-DATA-START-WRITE) A-TRANS-DATA)
	(NO-OP)
	(POPJ-AFTER-NEXT
	 (VMA-START-READ) VMA)
       (POPJ-AFTER-NEXT
	 (OA-REG-LOW) DPB (M-CONSTANT -1) OAL-DISP A-ZERO)	;FORCE DISP TO LOC 1777

;ENTER HERE FOR EXTERNAL-VALUE-CELL-POINTER
TRANS-EVCP
	((A-TRANS-DATA) READ-MEMORY-DATA)	;VMA ALREADY SAVED IN M-VMA-HELD
	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO UNIBUS
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 637772001)) ;LOCATION 764000
	((VMA-START-READ) (A-CONSTANT 1))	;FETCH LOCATION 764002
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULDN'T HAPPEN
	((MICRO-STACK-DATA-PUSH)
		 (BYTE-FIELD 12. 0) READ-MEMORY-DATA) ;CATCH RETURN ADDRESS
						;OUT OF THE OPCS.  NOTE CAREFUL TIMING,
						;6 INSTRUCTIONS TO HERE!
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) READ-I-ARG TRANS-INVZ) ;JUMP IF EVCP SHOULD INVZ
	(JUMP-XCT-NEXT TRANS-DROP-THROUGH)	;SHOULDN'T INVZ, GO SIMULATE DROP THROUGH
       (CALL-IF-BIT-SET (BYTE-FIELD 1 2) READ-I-ARG ILLOP)	;BARF IF TRANSPORT-HEADER

;ENTER HERE FOR ONE-Q-FORWARD
TRANS-OQF
	((A-TRANS-DATA) READ-MEMORY-DATA)	;VMA ALREADY SAVED IN M-VMA-HELD
	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO UNIBUS
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 637772001)) ;LOCATION 764000
	((VMA-START-READ) (A-CONSTANT 1))	;FETCH LOCATION 764002
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULDN'T HAPPEN
	((MICRO-STACK-DATA-PUSH)
		 (BYTE-FIELD 12. 0) READ-MEMORY-DATA) ;CATCH RETURN ADDRESS
						;OUT OF THE OPCS.  NOTE CAREFUL TIMING,
						;6 INSTRUCTIONS TO HERE!
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 3) READ-I-ARG TRANS-DROP-THROUGH) ;IGNORE OQF IF JUST
	(JUMP-XCT-NEXT TRANS-INVZ)					 ;CHECKING CDR CODE
       (CALL-IF-BIT-SET (BYTE-FIELD 1 2) READ-I-ARG ILLOP)	;BARF IF TRANSPORT-HEADER

;ENTER HERE FOR PLAIN FORWARDING POINTER, ALWAYS FORWARDS
TRANS-FWD
	((A-TRANS-DATA) READ-MEMORY-DATA)	;VMA ALREADY SAVED IN M-VMA-HELD
	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO UNIBUS
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 637772001)) ;LOCATION 764000
	((VMA-START-READ) (A-CONSTANT 1))	;FETCH LOCATION 764002
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULDN'T HAPPEN
	((MICRO-STACK-DATA-PUSH)
		 (BYTE-FIELD 12. 0) READ-MEMORY-DATA) ;CATCH RETURN ADDRESS
						;OUT OF THE OPCS.  NOTE CAREFUL TIMING,
						;6 INSTRUCTIONS TO HERE!
	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP
;CHASE FORWARDING POINTER, RESTART CYCLE
TRANS-INVZ	
	((VMA-START-READ M-VMA-HELD) SELECTIVE-DEPOSIT M-VMA-HELD	;RETAIN DATA TYPE,
			 Q-ALL-BUT-POINTER A-TRANS-DATA)		;ALTER POINTER
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(POPJ-AFTER-NEXT NO-OP)
       (POPJ-AFTER-NEXT (VMA) READ-MEMORY-DATA)	;VMA ADDRESSES MAP.

;;; TV ROUTINES

;(TV-DRAW-CHAR FONT-ARRAY-PNTR CHAR-CODE X-BIT-POS Y-BIT-POS ALU-FUNC)
;THE X-BIT-POS AND Y-BIT-POS ARE OF THE TOP LEFT CORNER OF THE CHARACTER.
; (0,0) IS THE TOP LEFT CORNER OF THE SCREEN
;THE ALU-FUNC IS SUITABLE FOR OA-REG-LOW.  GOOD VALUES ARE:
;	IOR	740
;	XOR	540
;	ANDCA	560
;	SETA	640

;(TV-ERASE WIDTH HEIGHT X-BIT-POS Y-BIT-POS ALU-FUNC)
;WIDTH AND HEIGHT ARE IN BITS.  A RECTANGLE OF THE INDICATED
;SIZE, OF ALL 1S, IS CREATED AND STORED INTO THE SPECIFIED
;PART OF THE TV BUFFER USING THE SPECIFIED ALU-FUNC.  USUALLY
;THE ANDCA FUNCTION IS USED FOR ERASING, BUT XOR COULD BE USED
;FOR THE BLINKING CURSOR ETC.

;A FONT ARRAY MAY NOT BE DISPLACED OR ANYTHING HAIRY LIKE THAT.
;ITS ARRAY LEADER CONTAINS:
;	0	NOT USED IN CASE MIGHT BE FILL POINTER?
;	1	FONT (NAMED-STRUCTURE-SYMBOL)
;	2	NAME OF FONT
;	3	CHARACTER CELL HEIGHT
;	4	CHARACTER CELL WIDTH (USED IF ITEM 7 IS NIL)
;	5	RASTER HEIGHT
;	6	RASTER WIDTH
;	7	FLOOR 32./RASTER WIDTH (# ROWS PER WORD)
;	8	CEILING RASTER HEIGHT/#5 (# WORDS PER CHAR)
;	9	NIL OR ARRAY POINTER TO CHARACTER WIDTH TABLE
;	10	NIL OR ARRAY POINTER TO LEFT KERN TABLE

;THE DATA PART OF THE ARRAY CONTAINS AN INTEGRAL NUMBER OF WORDS
;PER CHARACTER.  EACH WORD CONTAINS AN INTEGRAL NUMBER OF ROWS
;OF RASTER, LEFT ADJUSTED AND PROCESSED FROM LEFT TO RIGHT.
;ALL 32 BITS OF EACH Q IN THIS ARRAY ARE USED.  FOR EASIEST PROCESSING
;BY LISP PROGRAMS, IT SHOULD BE OF 1-BIT BYTE ARRAY TYPE.

;TV-DRAW-CHAR ONLY WORKS FOR RASTER WIDTHS OF AT MOST 16 (DECIMAL).
;FOR LARGER WIDTHS IT TRAPS TO ILLOP, BUT MIGHT LATER
;TRAP OUT TO A SLOWER, MORE GENERAL ROUTINE.  IN THE CASE OF LARGE
;CHARACTERS, THE FORM OF THE DATA PART OF THE FONT ARRAY MIGHT
;CONCEIVABLY BE DIFFERENT.  ONE WAY TO DO THIS IS TO MAKE A BIG
;CHARACTER BE SEVERAL SMALLER "CHARACTERS" SIDE BY SIDE.

;THIS ROUTINE DEPENDS ON A-TV-SCREEN-LOCATIONS-PER-LINE, WHICH FOR NOW IS JUST
;A CONSTANT, AND A-TV-SCREEN-BUFFER-ADDRESS.
;FOR THE MOMENT IT JUST CALLS THE REGULAR MULTIPLY ROUTINE,
;LATER IT COULD BE HACKED UP TO USE A FASTER VERSION THAT ONLY
;DOES SAY 12 BITS INSTEAD OF 32.

;NO INTERRUPTS IN TV ROUTINES DUE TO LARGE NUMBER OF ACS USED

;;; SELECT A TV SCREEN FOR USE BY THE OTHER FUNCTIONS
;;; HERE'S WHAT WE KNOW ABOUT SCREEN OBJECTS: (SUBSCRIPTS IN THE ARRAY)
(ASSIGN SCREEN-PLANE-MASK-IDX 2)
(ASSIGN SCREEN-BUFFER-IDX 14)
(ASSIGN SCREEN-HEIGHT-IDX 3)
(ASSIGN SCREEN-LOCATIONS-PER-LINE-IDX 15)
;;; HERE ARE VARIABLES WE SET UP:
;;; A-TV-CURRENT-SCREEN A-TV-SCREEN-BUFFER-ADDRESS A-TV-SCREEN-BUFFER-END-ADDRESS
;;; A-TV-SCREEN-LOCATIONS-PER-LINE 
;;; ALSO WE SET UP THE PLANE SELECT REGISTER IF USING A 16-BIT TV

XTVSELSCRN (MISC-INST-ENTRY TV-SELECT-SCREEN)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-EQUAL M-A A-TV-CURRENT-SCREEN)	;Nothing to be done
	(CALL-XCT-NEXT GAHDR)			;M-E gets base data address
       ((A-TV-CURRENT-SCREEN) M-A)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-BUFFER-IDX))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TV-SCREEN-BUFFER-ADDRESS) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-LOCATIONS-PER-LINE-IDX))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TV-SCREEN-LOCATIONS-PER-LINE) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-HEIGHT-IDX))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((Q-R) A-TV-SCREEN-LOCATIONS-PER-LINE)
	(CALL-XCT-NEXT MPY)			;Q-R gets product
       ((M-1) Q-POINTER READ-MEMORY-DATA)	;Number of raster lines
	((A-TV-SCREEN-BUFFER-END-ADDRESS) ADD Q-R A-TV-SCREEN-BUFFER-ADDRESS)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-PLANE-MASK-IDX))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-3) Q-POINTER READ-MEMORY-DATA)
	(CALL-EQUAL M-3 A-ZERO TRAP)	;32-bit
    (ERROR-TABLE JE-N/'AI-PAS-DE-32-BIT-TV/'S)
;16-bit, select one plane that has a bit on in the mask.  Multiple bits lose.
;In fact, we will choose the highest bit that is on.
	((M-B) SUB M-ZERO (A-CONSTANT 400))	;Plane number shifted left 8
	((M-1) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) A-TV-PLANE-SELECT)	;Get plane select register
	(CALL-CONDITIONAL PG-FAULT PGF-R)
XTVSS1	((M-1) (BYTE-FIELD 37 1) M-1)		;Shift mask right
	(JUMP-NOT-EQUAL-XCT-NEXT M-1 A-ZERO XTVSS1)	;Loop until all bits gone
       ((M-B) ADD M-B (A-CONSTANT 400))
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE)	;Select desired plane, other bits unchanged
		DPB READ-MEMORY-DATA (BYTE-FIELD 8 0) A-B)
       (CALL-CONDITIONAL PG-FAULT PGF-W)	;Clobbers Vertical Increment Mode, so what?

;POP OFF Y-BIT-POS AND X-BIT-POS AND CONVERT TO WORD AND BIT ADDRESS
;M-E ABSOLUTE WORD ADDRESS, M-T BIT OFFSET FROM LEFT (REALLY FROM MIDDLE
;SINCE ONLY 16 BITS PER WORD IN TV MEMORY).  CLOBBER M-1, M-2 (VIA MPY).
TVXYADR	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;Y POSN
	(CALL-XCT-NEXT MPY)				;Q-R := ADDR OF LINE BEG
       ((Q-R) A-TV-SCREEN-LOCATIONS-PER-LINE)
	((M-1) (BYTE-FIELD 24 4) C-PDL-BUFFER-POINTER) ;X POSN HALFWORDS
	((M-E) ADD Q-R A-1)				;REL WORD ADDR START OF CHAR
	(POPJ-AFTER-NEXT
	 (M-E) ADD M-E A-TV-SCREEN-BUFFER-ADDRESS)	;ABS WORD ADDRESS
       ((M-T) (BYTE-FIELD 4 0) C-PDL-BUFFER-POINTER-POP) ;BIT OFFSET START OF CHAR

XTVERS (MISC-INST-ENTRY TV-ERASE)
	(CALL-XCT-NEXT TVXYADR)				;M-E := ADDR, M-T := BIT OFFSET
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ALU FUNC
	((M-D) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;HEIGHT IN RASTER LINES
	((M-C C-PDL-BUFFER-POINTER) ADD A-T		;ADJUST WIDTH TO PRETEND
			C-PDL-BUFFER-POINTER)		;STARTING ON WORD BOUNDARY
	((M-C) (BYTE-FIELD 24 4) M-C)			;WIDTH IN WORDS
	((M-Q) (BYTE-FIELD 4 0) (M-CONSTANT -1))	;17 ;LOAD HANDY CONSTANT, USED LATER
	((M-K) SUB M-Q A-T)				;BYTL-1 FOR FIRST WORD
	((OA-REG-LOW) DPB M-K OAL-BYTL-1 A-ZERO)
	((M-K) (BYTE-FIELD 0 0) (M-CONSTANT -1))	;GET 16-BIT MASK
	(JUMP-EQUAL-XCT-NEXT M-C A-ZERO XTVERS3)	;JUMP IF NARROW
XTVERS0((M-B) M-D)					;COPY OF HEIGHT
	((VMA-START-READ) M-E)				;NO TRANSP SINCE TOUCHED HEADER
XTVERS1	(CALL-CONDITIONAL PG-FAULT PGF-R)		;DO FIRST COLUMN
	(JUMP-LESS-OR-EQUAL M-B A-ZERO XTVERS2)		;JUMP IF COLUMN ALL DONE
	(CALL-GREATER-OR-EQUAL VMA A-TV-SCREEN-BUFFER-END-ADDRESS TRAP)
  (ERROR-TABLE TV-ERASE-OFF-SCREEN)			;This is special.
	((OA-REG-LOW) M-J)
	((WRITE-MEMORY-DATA-START-WRITE) SETCM READ-MEMORY-DATA A-K)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((M-B) SUB M-B (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTVERS1)
       ((VMA-START-READ) ADD VMA A-TV-SCREEN-LOCATIONS-PER-LINE)

XTVERS2	((M-E) ADD M-E (A-CONSTANT 1))			;NEXT COLUMN
	((M-C) SUB M-C (A-CONSTANT 1))
	(JUMP-GREATER-THAN-XCT-NEXT M-C A-ZERO XTVERS0)
       ((M-K) SETO)
	(JUMP-LESS-THAN M-C A-ZERO XFALSE)		;ALL DONE
XTVERS3	((M-B) (BYTE-FIELD 4 0) C-PDL-BUFFER-POINTER-POP) ;BITS TO DO IN LAST COLUMN
	(JUMP-EQUAL M-B A-ZERO XFALSE)			;NO LAST COLUMN, RETURN NIL
	((M-B) SUB M-Q A-B)				;BYTL-1 FOR BITS OF MASK TO ZERO OUT
	((OA-REG-LOW) DPB M-B OAL-BYTL-1 A-ZERO)
	((M-K) SELECTIVE-DEPOSIT M-ZERO (BYTE-FIELD 0 0) A-K)
	(JUMP XTVERS0)

XTVCHR (MISC-INST-ENTRY TV-DRAW-CHAR)
	(CALL-XCT-NEXT TVXYADR)
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ALU FUNC
	((M-I) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;CHAR CODE
	(CALL-XCT-NEXT GAHDRA)				;M-A ARRAY PNTR, M-E DATA ADDRESS
       ((M-C) M-E)					;M-C TV BUFFER ADDRESS
  (ERROR-TABLE CALLS-SUB TV-DRAW-CHAR)
	((VMA-START-READ) SUB M-A (A-CONSTANT 7))	;GET RASTER HEIGHT
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP SINCE JUST TOUCHED HDR
	((M-T) SUB (M-CONSTANT 40) A-T)			;PREPARE DPB ALIGNMENT PNTR
	((M-D) Q-POINTER READ-MEMORY-DATA)
;DROPS THROUGH
;DROPS IN
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;GET RASTER WIDTH
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP BECAUSE JUST TOUCHED HDR
	((M-B) Q-POINTER READ-MEMORY-DATA)
	(CALL-GREATER-THAN M-B (A-CONSTANT 16.) ILLOP)	;TOO WIDE FOR THIS ROUTINE
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;GET # ROWS PER WORD
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP BECAUSE JUST TOUCHED HDR
	((M-K) SUB M-B (A-CONSTANT 1))			;MAKE UP BYTL-1,MROT TO
	((M-Q) DPB M-K OAL-BYTL-1 A-B)			;LDB LEFTMOST RASTER ROW
	((M-T) SUB M-T A-B)				;MROT TO LEFT ADJUST BYTE
	((M-R) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;GET # WORDS PER CHAR
	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP BECAUSE JUST TOUCHED HDR
	((M-T) DPB M-K OAL-BYTL-1 A-T)			;GET ALIGNMENT BYTL,MROT
	((Q-R) M-I)					;Q-R := CHARACTER CODE
	(CALL-XCT-NEXT MPY)				;Q-R := REL ADDR OF FONT RASTER
       ((M-1) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ M-E) ADD Q-R A-E)		;FETCH FIRST WORD OF RASTER
XTVCH1	(CALL-CONDITIONAL PG-FAULT PGF-R)		;NO TRANSP BECAUSE TOUCHED HDR
	((M-S) M-R)					;THIS MANY ROWS IN THIS WORD
	((M-I) M-Q)					;RESET BYTE PNTR TO LEFTMOST
	((M-1) READ-MEMORY-DATA)			;GET WORD FROM FONT ARRAY
;M-1	WORD FROM FONT ARRAY - BETTER NOT TAKE ANY PAGE FAULTS OR INTERRUPTS IN HERE
;M-B	RASTER WIDTH
;M-C	WORD ADDRESS IN TV BUFFER
;M-D	RASTER HEIGHT (LINES TO GO)
;M-E	ADDRESS OF WORD IN FONT ARRAY
;M-Q	BYTL,MROT TO LDB OFF LEFTMOST ROW OF RASTER
;M-R	# ROWS PER WORD
;M-S	# ROWS TO GO, THIS WORD
;M-T	BYTL,MROT TO DPB RASTER ROW INTO POSN TO STORE INTO TV
;M-I	BYTL,MROT TO LDB OFF NEXT ROW OF RASTER
;M-J	ALU FUNC
XTVCH2	((OA-REG-LOW) M-I)
	((M-K) (BYTE-FIELD 0 0) M-1)			;GET A RASTER ROW
	((OA-REG-LOW) M-T)
	((M-K) DPB M-K (BYTE-FIELD 0 0) A-ZERO)		;ALIGN
	((VMA-START-READ) M-C)				;GET TV BUFFER HALFWORD
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((A-TEM2) (BYTE-FIELD 20 20) M-K)		;GET FIRST CHAR HALFWORD
	((OA-REG-LOW) M-J)				;HACK ALU FUNC AND
	((WRITE-MEMORY-DATA-START-WRITE) SETCM		;STORE BACK
		READ-MEMORY-DATA A-TEM2)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((A-TEM2) (BYTE-FIELD 20 0) M-K)		;GET SECOND CHAR HALFWORD
	(JUMP-EQUAL M-ZERO A-TEM2 XTVCH3)		;SPEED HACK, OFTEN ZERO
	((VMA-START-READ) ADD M-C (A-CONSTANT 1))	;GET 2ND TV BUFFER HALFWORD
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((OA-REG-LOW) M-J)				;HACK ALU FUNC AND
	((WRITE-MEMORY-DATA-START-WRITE) SETCM		;STORE BACK
		READ-MEMORY-DATA A-TEM2)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
XTVCH3	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-D (A-CONSTANT 1) XFALSE) ;IF DONE, RETURN NIL
       ((M-D) SUB M-D (A-CONSTANT 1))
	((M-C) ADD M-C A-TV-SCREEN-LOCATIONS-PER-LINE)	;ADVANCE TO NEXT LINE
	((M-I) ADD M-B A-I)				;ADV BYTE PNTR TO NEXT ROW
	(JUMP-GREATER-THAN-XCT-NEXT M-S (A-CONSTANT 1) XTVCH2)
       ((M-S) SUB M-S (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTVCH1)				;NEED NEW WORD FROM FONT ARRAY
       ((VMA-START-READ M-E) ADD M-E (A-CONSTANT 1))

;;; PAGE FAULT HANDLER            (VERSION 0.1)

;PAGE FAULTS GENERALLY DO NOT CLOBBER ANYTHING.
;EXCEPTIONS:
;	THE A-PGF-MUMBLE REGISTERS ARE CLOBBERED.  ONLY THE PAGE FAULT
;		ROUTINES SHOULD USE THEM.
;	M-1, A-TEM1, A-TEM2, AND A-TEM3 ARE CLOBBERED.  THEY ARE SUPER-TEMPORARY.
;	THE DISPATCH CONSTANT AND THE Q REGISTER ARE CLOBBERED.
;	WRITE CYCLES CLOBBER READ-MEMORY-DATA
;	READ CYCLES CLOBBER WRITE-MEMORY-DATA
;
;IF AN INTERRUPT IS ALLOWED AND OCCURS, IT OCCURS AFTER A WRITE CYCLE
;IS SUCCESSFULLY COMPLETED, BUT EFFECTIVELY BEFORE A READ CYCLE.
;THE WRITE-MEMORY-DATA IS CLOBBERED.  THE READ-MEMORY-DATA
;IS RESET FROM THE VMA.  THE LETTERED M ACS ARE SAVED,
;AND MUST CONTAIN GC MARKABLE STUFF OR DTP TRAP (OR -1).  RANDOM
;MISCELLANEOUS ACS LIKE A-TEM ARE CLOBBERED BY INTERRUPTS.

; DEFINITIONS OF FIELDS IN THE MAP HARDWARE

(DEF-DATA-FIELD MAP-READ-FAULT-BIT 1 0)
(DEF-DATA-FIELD MAP-WRITE-FAULT-BIT 1 1)
(DEF-DATA-FIELD MAP-PHYSICAL-PAGE-NUMBER 13. 7)
(DEF-DATA-FIELD MAP-META-BITS 3 20.)
(DEF-DATA-FIELD MAP-STATUS-CODE 3 23.)
(DEF-DATA-FIELD MAP-ACCESS-CODE 2 25.)		;NOTE BIT 25 IS IN TWO FIELDS
(DEF-DATA-FIELD MAP-FIRST-LEVEL-MAP 5 27.)
(DEF-DATA-FIELD MAP-STATUS-CODE-LOW-BIT 1 23.)
(DEF-DATA-FIELD MAP-ACCESS-STATUS-AND-META-BITS 7 20.)
(DEF-DATA-FIELD MAP-HARDWARE-READ-ACCESS 1 26.)	;HARDWARE PERMITS (AT LEAST) READ ACCESS
						; IF THIS BIT SET.
; DEFINITIONS OF FIELDS IN PAGE HASH TABLE

 ;WORD 1
(DEF-DATA-FIELD PHT1-VIRTUAL-PAGE-NUMBER 16. 7)	;ALIGNED SAME AS VMA
(DEF-DATA-FIELD PHT1-SWAP-STATUS-CODE 3 0)
 (DEF-DATA-FIELD PHT1-ALL-BUT-SWAP-STATUS-CODE 29. 3)
(DEF-DATA-FIELD PHT1-VALID-BIT 1 6)
 ;WORD 2
(DEF-DATA-FIELD PHT2-META-BITS 3 0)
(DEF-DATA-FIELD PHT2-MAP-STATUS-CODE 3 3)
(DEF-DATA-FIELD PHT2-MAP-ACCESS-CODE 2 5)
 (DEF-DATA-FIELD PHT2-ACCESS-STATUS-AND-META-BITS 7 0)
 (DEF-DATA-FIELD PHT2-ALL-BUT-ACCESS-STATUS-AND-META-BITS 31 7)
(DEF-DATA-FIELD PHT2-PHYSICAL-PAGE-NUMBER 16. 7) ;ALIGNED SAME AS VMA

; DEFINITIONS OF FIELDS IN THE ADDRESS

(DEF-DATA-FIELD VMA-MAP-BLOCK-PART 11. 12.)	;ADDRESS BLOCK OF 32. PAGES
(DEF-DATA-FIELD VMA-PAGE-ADDR-PART 16. 7)	;VIRTUAL PAGE NUMBER
(DEF-DATA-FIELD VMA-PHYS-PAGE-ADDR-PART 13. 7)	;PHYSICAL PAGE NUMBER
(DEF-DATA-FIELD VMA-LOW-BITS 7 0)		;ADDR WITHIN PAGE

;NOTE: PGF-R, ETC CAN BE ENTERED RECURSIVELY IF THE PAGE IS SWAPPED OUT AND THE DISK 
;ROUTINES FAULT WHEN REFERENCING THE DISK CONTROL VIA THE UNIBUS.

;PUSHJ HERE ON PAGE FAULT OR INTERRUPT REQUEST DURING READ CYCLE
;INTERRUPT MAY BE INSERTED -AFTER- THE READ CYCLE, HOWEVER
;IT IS EFFECTIVELY BEFORE SINCE ON DISMISS READ-MEMORY-DATA RESTORED FROM VMA!!
;NOTE THAT THIS ORDERING ALLOWS AN EFFECTIVE READ-PAUSE-WRITE CYCLE
;TO BE DONE JUST BY DOING A READ THEN A WRITE, EVEN
;THOUGH AFTER EACH CYCLE IS STARTED INTERRUPTS ARE CHECKED.
INTSER	(JUMP-CONDITIONAL NO-PG-FAULT INTR)	;IF NO PG FAULT, TAKE INTERRUPT

;PUSHJ HERE ON READ CYCLE PAGE FAULT WHEN DESIRE NOT TO TAKE INTERRUPT
;GUARANTEED TO RETURN WITHOUT ANY INTERRUPTS HAPPENING, OR ELSE TO GO TO ILLOP
PGF-R	(CALL-IF-BIT-SET (BYTE-FIELD 1 23.) VMA ILLOP)	  ;THIS MACHINE REALLY ONLY HAS 23...
	(DISPATCH-XCT-NEXT MAP-STATUS-CODE MEMORY-MAP-DATA D-PGF-R)
       ((M-PGF-WRITE) DPB (M-CONSTANT 0) A-FLAGS)
;IF IT RETURNS HERE, WE RESTART THE READ REFERENCE
	((VMA-START-READ) A-PGF-VMA)		
	(JUMP-CONDITIONAL PG-FAULT PGF-R)	;WOOPS (YES, IT CAN HAPPEN)
	(POPJ)

;PUSHJ HERE ON PAGE FAULT OR INTERRUPT REQUEST DURING WRITE CYCLE
;INTERRUPT MAY BE INSERTED -AFTER- THE WRITE CYCLE
INTSER-WRITE
	(JUMP-CONDITIONAL NO-PG-FAULT INTR)	;NO PAGE FAULT, THEN TAKE INTERRUPT

;PUSHJ HERE ON PAGE FAULT WHEN DESIRE NOT TO TAKE INTERRUPT
;GUARANTEED TO RETURN WITH NO INTERRUPT, OR TO GO TO ILLOP
PGF-W	(CALL-IF-BIT-SET (BYTE-FIELD 1 23.) VMA ILLOP)	;THIS MACHINE REALLY ONLY HAS 23...
	(DISPATCH-XCT-NEXT MAP-STATUS-CODE MEMORY-MAP-DATA D-PGF-W)
       ((M-PGF-WRITE) DPB (M-CONSTANT -1) A-FLAGS)
;IF IT RETURNS HERE, WE RESTART THE WRITE REFERENCE
PGF-WRET((WRITE-MEMORY-DATA) A-PGF-WMD)		;IF MICRO-RETURN IS HERE, PGF-SPECIAL-A...
	((VMA-START-WRITE) A-PGF-VMA)		; ASSUMES WE WERE TRYING TO DO A WRITE CYCLE
	(JUMP-CONDITIONAL PG-FAULT PGF-W)	;WOOPS (YES, IT CAN HAPPEN)
	(POPJ)

(LOCALITY D-MEM)
(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-PGF-R	(P-BIT PGF-LEVEL-1)	;0 LEVEL 1 MAP NOT VALID
	(P-BIT PGF-LEVEL-2)	;1 LEVEL 2 MAP NOT VALID
	(P-BIT ILLOP)		;2 READ ONLY
	(P-BIT ILLOP)		;3 READ/WRITE FIRST
	(P-BIT ILLOP)		;4 READ/WRITE
	(PGF-R-PDL)		;5 MAY BE IN PDL BUFFER
	(PGF-MAR)		;6 POSSIBLE MAR BREAK
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-PGF-W	(P-BIT PGF-LEVEL-1)	;0 LEVEL 1 MAP NOT VALID
	(P-BIT PGF-LEVEL-2)	;1 LEVEL 2 MAP NOT VALID
	(TAKE-MPV-FAULT)	;2 WRITE IN READ ONLY
	(P-BIT PGF-RWF)		;3 WRITE IN READ/WRITE FIRST
	(P-BIT ILLOP)		;4 READ/WRITE
	(PGF-W-PDL)		;5 MAY BE IN PDL BUFFER
	(PGF-MAR)		;6 POSSIBLE MAR BREAK
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)
(LOCALITY I-MEM)

;PDL BUFFER HANDLING CONVENTIONS:
;  THE LINEAR PUSHDOWN LIST MUST ALWAYS BE COMPOSED OF PAGES FROM AN AREA WHOSE
;AREA-MODE-BITS Q HAS %PHT-MAP-STATUS-PDL-BUFFER IN THE MAP STATUS PORTION OF ITS
;%%AREA-MODE-ACCESS-STATUS-AND-META-BITS FIELD.  THUS ANY MEMORY CYCLE REF'ING 
;SUCH AN AREA WILL TRAP AND COME HERE, WHERE THE CODE CHECKS TO SEE IF IT IS REALLY
;IN THE PDL-BUFFER NOW.  IF NOT, IT TURNS ON R/W ACCESS TEMPORARILY AND PERFORMS THE
;REQUESTED CYCLE, ETC.
;  THESE PAGES ARE TREATED ENTIRELY AS NORMAL PAGES FOR SWAPPING PURPOSES, AND MAY
;EVEN BE SWAPPED OUT WHILE ACTUALLY RESIDENT IN THE PDL-BUFFER! THE ONLY DIFFERENCE
;IS THAT THE PAGE MUST ALWAYS BE WRITTEN TO THE DISK ON SWAP-OUT, SINCE THE R-W-F
;MECHANISM IS NOT AVAILABLE TO KEEP TRACK OF WHETHER IT HAS ACTUALLY BEEN MODIFIED.
;  PDL-BUFFER-POINTER IS TAKEN TO MARK THE HIGHEST PDL-BUFFER LOCN WHICH IS REALLY VALID.

;READ REFERENCE TO LOCATION THAT MAY BE IN THE PDL BUFFER
PGF-R-PDL	
	((M-PGF-TEM) PDL-BUFFER-POINTER)		;DOES A LDB TYPE OPERATION.
	((M-PGF-TEM) SUB M-PGF-TEM A-PDL-BUFFER-HEAD)
	((M-PGF-TEM) (BYTE-FIELD 10. 0) M-PGF-TEM)	;COMPUTE # ACTIVE WDS IN PDL-BUFFER
	((A-PGF-B) ADD M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-PGF-TEM) Q-POINTER VMA)	;GET ADDRESS BEING REFERENCED SANS EXTRA BITS
	(JUMP-LESS-THAN M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS PGF-R-NOT-REALLY-IN-PDL-BUFFER)
	(JUMP-GREATER-THAN M-PGF-TEM A-PGF-B PGF-R-NOT-REALLY-IN-PDL-BUFFER) ;GREATER BECAUSE 
							;(PP) IS A VALID WD.
			;READ REFERENCE TO LOCATION THAT IS IN THE PDL BUFFER
	((M-PGF-TEM) SUB M-PGF-TEM 
		A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;GET RELATIVE PDL LOC REFERENCED
	((A-PGF-A) PDL-BUFFER-INDEX)	;DON'T CLOBBER PDL-BUFFER-INDEX
	((PDL-BUFFER-INDEX) ADD M-PGF-TEM A-PDL-BUFFER-HEAD)	;TRUNCATES TO 10 BITS
	((A-PGF-VMA) VMA)		;DON'T CLOBBER VMA
	((WRITE-MEMORY-DATA) C-PDL-BUFFER-INDEX) ;GET TO READ-MEMORY-DATA VIA MEMORY
	((VMA-START-WRITE) (A-CONSTANT 376))	;CLOBBERING LOCATION 376
	((PDL-BUFFER-INDEX) A-PGF-A)	;ASSUME MAP IS SET UP OK FOR PAGE 1
	((A-PDL-BUFFER-READ-FAULTS) ADD A-PDL-BUFFER-READ-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ) (A-CONSTANT 376))
	(POPJ-AFTER-NEXT		;RETURN FROM FAULT
		NO-OP)			;DELAYING FOR ONE CYCLE FOR MEM REF TO START
       ((VMA) A-PGF-VMA)		;THEN RESTORING VMA

;READ REFERENCE TO LOCATION NOT IN THE PDL BUFFER, BUT IT MIGHT HAVE BEEN.
PGF-R-NOT-REALLY-IN-PDL-BUFFER	
	((A-PGF-WMD) WRITE-MEMORY-DATA)	;DON'T CLOBBER
	((M-PGF-TEM) MEMORY-MAP-DATA)	;SAVE MAP
	((WRITE-MEMORY-DATA-WRITE-MAP) IOR	;TURN ON ACCESS
		 MEMORY-MAP-DATA (A-CONSTANT 600000001)) ;AND SELECT WRITE IN LEVEL 2 MAP
	((VMA-START-READ) VMA)			;READ THE LOCATION
	((A-PDL-BUFFER-MEMORY-FAULTS) ADD A-PDL-BUFFER-MEMORY-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM	;TURN ACCESS BACK OFF 
		 			(A-CONSTANT 1)) ;AND SELECT LEVEL 2 MAP
       ((WRITE-MEMORY-DATA) A-PGF-WMD)		;RESTORE REGS AND RETURN FROM FAULT

;WRITE REFERENCE TO LOCATION THAT MAY BE IN THE PDL BUFFER
PGF-W-PDL	
	((M-PGF-TEM) PDL-BUFFER-POINTER)		;DOES A LDB TYPE OPERATION.
	((M-PGF-TEM) SUB M-PGF-TEM A-PDL-BUFFER-HEAD)
	((M-PGF-TEM) (BYTE-FIELD 10. 0) M-PGF-TEM)	;COMPUTE # ACTIVE WDS IN PDL-BUFFER
	((A-PGF-B) ADD M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS) ;HIGHEST VIRT LOC IN P.B,
	((M-PGF-TEM) Q-POINTER VMA)	;GET ADDRESS BEING REFERENCED SANS EXTRA BITS
	(JUMP-LESS-THAN M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS PGF-W-NOT-REALLY-IN-PDL-BUFFER)
	(JUMP-GREATER-THAN M-PGF-TEM A-PGF-B PGF-W-NOT-REALLY-IN-PDL-BUFFER) ;GREATER BECAUSE
							;(PP) IS A VALID WD
			;WRITE REFERENCE TO LOCATION THAT IS IN THE PDL BUFFER
	((A-PDL-BUFFER-WRITE-FAULTS) ADD A-PDL-BUFFER-WRITE-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((M-PGF-TEM) SUB M-PGF-TEM 
		A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;GET RELATIVE PDL LOC REFERENCED
	((A-PGF-A) PDL-BUFFER-INDEX)	;DON'T CLOBBER PDL-BUFFER-INDEX
	((PDL-BUFFER-INDEX) ADD M-PGF-TEM A-PDL-BUFFER-HEAD)	;TRUNCATES TO 10 BITS
	(POPJ-AFTER-NEXT
	 (C-PDL-BUFFER-INDEX) WRITE-MEMORY-DATA) ;DO THE WRITE
       ((PDL-BUFFER-INDEX) A-PGF-A)	;RESTORE REGS AND RETURN FROM FAULT

;WRITE REFERENCE TO LOCATION NOT IN THE PDL BUFFER, BUT IT MIGHT HAVE BEEN
PGF-W-NOT-REALLY-IN-PDL-BUFFER	
	((A-PGF-WMD) WRITE-MEMORY-DATA)		;DON'T CLOBBER
	((M-PGF-TEM) MEMORY-MAP-DATA)	;SAVE MAP
	((WRITE-MEMORY-DATA-WRITE-MAP) IOR	;TURN ON ACCESS
		 MEMORY-MAP-DATA (A-CONSTANT 600000001)) ;AND SELECT WRITE IN LEVEL 2 MAP
	((WRITE-MEMORY-DATA-START-WRITE) A-PGF-WMD) ;WRITE THE DATA
	((A-PDL-BUFFER-MEMORY-FAULTS) ADD A-PDL-BUFFER-MEMORY-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM 	;TURN ACCESS BACK OFF 
		 			(A-CONSTANT 1)) ;AND SELECT LEVEL 2 MAP
       ((WRITE-MEMORY-DATA) A-PGF-WMD)		;RESTORE REGS AND RETURN FROM FAULT

;SAVE REGISTERS UPON ENTERING PAGE FAULT HANDLER
PGF-SAVE((A-PGF-VMA) VMA)
	((A-PGF-WMD) WRITE-MEMORY-DATA)
	((A-PGF-A) M-A)
	(POPJ-AFTER-NEXT (A-PGF-B) M-B)
       ((A-PGF-T) M-T)

;RESTORE REGISTERS AND LEAVE PAGE FAULT HANDLER
;DOESN'T RESTORE VMA SINCE CYCLE RESTARTER (POPJED TO) WILL DO THAT
PGF-RESTORE	
	((M-A) A-PGF-A)
	(POPJ-AFTER-NEXT (M-B) A-PGF-B)
       ((M-T) A-PGF-T)

;ROUTINE TO ADVANCE SECOND LEVEL MAP REUSE POINTER, WITH CARE.  CLOBBERS M-T
ADVANCE-SECOND-LEVEL-MAP-REUSE-POINTER	
	((M-T) ADD M-ZERO A-SECOND-LEVEL-MAP-REUSE-POINTER ALU-CARRY-IN-ONE)
	(JUMP-LESS-THAN M-T (A-CONSTANT 37) ASLMRP1)
	((M-T) A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT)	;WRAP AROUND TO AFTER THE WIRED ONES
ASLMRP1	(POPJ-AFTER-NEXT (A-SECOND-LEVEL-MAP-REUSE-POINTER) M-T)
       (NO-OP)

;REFERENCE FAULTED BECAUSE FIRST LEVEL MAP NOT SET UP
PGF-LEVEL-1	
	(CALL PGF-SAVE)
	((A-FIRST-LEVEL-MAP-RELOADS) ADD A-FIRST-LEVEL-MAP-RELOADS M-ZERO ALU-CARRY-IN-ONE)
	((M-T) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)	;VERIFY NOT GETTING SCREWED
	(CALL-NOT-EQUAL M-T (A-CONSTANT 37) ILLOP)	;BY CLOBBERED MAP
	((M-T) A-SECOND-LEVEL-MAP-REUSE-POINTER)	;ALLOCATE A BLOCK OF LVL 2 MAP
	((VMA M-A) SELECTIVE-DEPOSIT VMA VMA-MAP-BLOCK-PART A-ZERO) ;-> 1ST ENTRY IN BLOCK
	((WRITE-MEMORY-DATA-WRITE-MAP) DPB M-T MAP-FIRST-LEVEL-MAP A-ZERO) ;PNT 1ST LVL AT IT
;	((OA-REG-HI) DPB M-T OAH-A-SRC A-ZERO)		;ADDRESS REVERSE 1ST LVL MAP
;	((VMA) A-REVERSE-FIRST-LEVEL-MAP)		;ADDRESS PREV 1ST LVL MAP ENTRY
	((M-PGF-TEM) ADD M-T (A-CONSTANT 40))		;REVERSE 1ST LVL MAP IN 40-77 OF
	((VMA-START-READ) ADD M-PGF-TEM A-V-SYSTEM-COMMUNICATIONS-AREA)  ;SYS COM AREA.
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((VMA) READ-MEMORY-DATA)
	(JUMP-LESS-THAN VMA A-ZERO PGF-L1C)		;DON'T WRITE MAP IF NO PREVIOUS
	((WRITE-MEMORY-DATA-WRITE-MAP) DPB		;AND 37-IFY OLD 1ST LVL MAP
		 (M-CONSTANT -1) MAP-FIRST-LEVEL-MAP A-ZERO)  ;ENTRY SO WILL FAULT IF USED
PGF-L1C;((OA-REG-LOW) DPB M-T OAL-DEST A-ZERO)		;UPDATE REVERSE FIRST LVL MAP
;	((A-REVERSE-FIRST-LEVEL-MAP) M-A)
	((VMA) ADD M-PGF-TEM A-V-SYSTEM-COMMUNICATIONS-AREA)
	((WRITE-MEMORY-DATA-START-WRITE) M-A)		;UPDATE REVERSE FIRST LVL MAP
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((VMA) M-A)					;ADDRESS FIRST ENTRY IN BLOCK
	((M-T) (M-CONSTANT 40))				;DO ALL 32. ENTRIES IN BLOCK
PGF-L1A	((WRITE-MEMORY-DATA-WRITE-MAP) DPB		;RESET 2ND LVL MAP TO STS=1, MEANING
		 (M-CONSTANT -1) MAP-STATUS-CODE-LOW-BIT (A-CONSTANT 1)) ;LVL 2 NOT SET UP
	((VMA M-A) ADD M-A (A-CONSTANT (BYTE-VALUE VMA-PAGE-ADDR-PART 1)))
	(JUMP-GREATER-THAN-XCT-NEXT M-T (A-CONSTANT 1) PGF-L1A)
       ((M-T) SUB M-T (A-CONSTANT 1))
	((VMA) A-PGF-VMA)  ;SO ERROR CHECK AT PGF-L1B WILL WIN.  
			   ;ALSO A GOOD IDEA FOR OTHER REASONS
	(JUMP-XCT-NEXT PGF-L1B)				;JOIN PGF-LEVEL-2 FAULT
       (CALL ADVANCE-SECOND-LEVEL-MAP-REUSE-POINTER)

;REFERENCE FAULTED BECAUSE SECOND LEVEL MAP NOT SET UP
PGF-LEVEL-2	
	(CALL PGF-SAVE)
PGF-L1B	((A-SECOND-LEVEL-MAP-RELOADS) ADD A-SECOND-LEVEL-MAP-RELOADS M-ZERO ALU-CARRY-IN-ONE)
	((M-T) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)	;VERIFY NOT GETTING SCREWED
	(CALL-EQUAL M-T (A-CONSTANT 37) ILLOP)		;BY CLOBBERED MAP
	((M-T) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA)
	(JUMP-LESS-THAN M-T (A-CONSTANT LOWEST-A-MEM-VIRTUAL-ADDRESS) PGF-L2A)
	(JUMP-LESS-THAN M-T (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS)
		PGF-SPECIAL-A-MEMORY-REFERENCE)
;REFERENCE TO UNIBUS OR X-BUS IO VIRTUAL ADDRESS.  FAKE UP PAGE HASH TABLE ENTRY
	((M-T) SELECTIVE-DEPOSIT M-T MAP-PHYSICAL-PAGE-NUMBER (A-CONSTANT 1))
	((M-A) DPB (M-CONSTANT -1)
		 (BYTE-FIELD 2 5) A-ZERO)	;140 ;RW ACCESS, STATUS=4, META BITS=0
	((VMA) A-PGF-VMA)
	(JUMP-XCT-NEXT PGF-RESTORE)
       ((WRITE-MEMORY-DATA-WRITE-MAP) DPB
		 M-A MAP-ACCESS-STATUS-AND-META-BITS A-T)

;REFERENCE TO ORDINARY VIRTUAL ADDRESS.  LOOK IN PAGE HASH TABLE
PGF-L2A	(CALL SEARCH-PAGE-HASH-TABLE)
	(DISPATCH PHT1-SWAP-STATUS-CODE READ-MEMORY-DATA D-PGF-PHT) ;FOUND, CHK SW STS

(LOCALITY D-MEM)
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)	;DISPATCH ON SWAP STATUS
D-PGF-PHT	
	(SWAPIN)		;0 PHT ENTRY INVALID, GET PAGE FROM DISK
	(PGF-RL)		;1 NORMAL, RELOAD PAGE MAP
	(PGF-FL)		;2 FLUSHABLE, CHANGE BACK TO NORMAL
	(P-BIT ILLOP)		;3 NOT USED, WAS PDL BUFFER
	(PGF-AG)		;4 AGE, CHANGE BACK TO NORMAL
	(PGF-RL)		;5 WIRED DOWN, RELOAD PAGE MAP
	(P-BIT ILLOP)		;6 NOT USED
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)	;DROP THROUGH IF MAR BREAK NOT TO GO OFF, ELSE CALL TRAP
D-MAR	(P-BIT R-BIT)			;0 READ, MAR DISABLED
	(INHIBIT-XCT-NEXT-BIT TRAP)	;1 READ, READ-TRAP
	(P-BIT R-BIT)			;2 READ, WRITE-TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;3 READ, READ-WRITE-TRAP
	(P-BIT R-BIT)			;4 WRITE, MAR DISABLED
	(P-BIT R-BIT)			;5 WRITE, READ-TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;6 WRITE, WRITE-TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;7 WRITE, READ-WRITE-TRAP
(END-DISPATCH)
(LOCALITY I-MEM)

;HERE ON REFERENCE TO PAGE CONTAINING THE MAR'ED LOCATION
PGF-MAR	((M-PGF-TEM) Q-POINTER VMA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP-LESS-THAN M-PGF-TEM A-MAR-LOW PGF-MAR1)	;CHECK ADDRESS BOUNDS
	(JUMP-GREATER-THAN M-PGF-TEM A-MAR-HIGH PGF-MAR1)
	(DISPATCH M-FLAGS-MAR-DISP D-MAR)	;TAKE MAR BREAK IF NECESSARY
   (ERROR-TABLE MAR-BREAK) ;This is a special entry which the EH knows all about.
PGF-MAR1	
	;FALSE ALARM, SIMULATE THE MEMORY CYCLE
	;BUT IT MIGHT BE IN THE PDL BUFFER, SO SIMULATE THAT TRAP
	(JUMP-IF-BIT-CLEAR M-PGF-WRITE PGF-R-PDL)
	(JUMP PGF-W-PDL)

PGF-SPECIAL-A-MEMORY-REFERENCE
	(JUMP-IF-BIT-SET-XCT-NEXT M-PGF-WRITE PGF-SA-W)	;JUMP IF CYCLE IS A WRITE
       ((M-GARBAGE) MICRO-STACK-PNTR-AND-DATA-POP)	;FLUSH RETRY-CYCLE RETURN
	((OA-REG-HI) DPB VMA OAH-A-SRC A-ZERO)	 ;NOTE LOWEST-A-MEM-VIRTUAL-ADDRESS 
	((WRITE-MEMORY-DATA) A-GARBAGE)		 ;MUST BE 0 MODULO A-MEMORY SIZE
	((VMA-START-WRITE) (A-CONSTANT 376))	 
	(NO-OP)		 			;WRITE CYCLE REALLY STARTS HERE.
	((VMA-START-READ) (A-CONSTANT 376))
	(JUMP-XCT-NEXT PGF-RESTORE)
       ((VMA) A-PGF-VMA)		;NOBODY ELSE WILL PUT BACK VMA

PGF-SA-W((M-A) (BYTE-FIELD 10 0) VMA)
	(JUMP-LESS-THAN M-A (A-CONSTANT 40) PGF-SM-W)  ;LOCN REALLY IN M-MEM.  ON NEXT
	((OA-REG-LOW) DPB VMA OAL-DEST A-ZERO)	; MACH, THIS TEST WILL NOT BE NECC.
	((A-GARBAGE) A-PGF-WMD)		;HAD BETTER NOT TRY TO WRITE LOCNS <= 37 WITH THIS
	(JUMP PGF-RESTORE)			;VMA NOT CLOBBERED


PGF-SM-W((OA-REG-LOW) DPB VMA OAL-DEST A-ZERO)
	((M-GARBAGE) A-PGF-WMD)
	(JUMP PGF-RESTORE)

TAKE-MPV-FAULT				
	(JUMP HALT-CONS TAKE-MPV-FAULT)

;HERE FOR READ-WRITE-FIRST TRAP
;FIND PAGE HASH TABLE ENTRY, CHANGE STATUS TO READ/WRITE, AND RELOAD MAP
PGF-RWF	(CALL PGF-SAVE)
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)
       ((M-T) A-PGF-VMA)
	(CALL-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA ILLOP)	;NOT IN PHT??
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))	;GET SECOND WORD
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;TABLE SUPPOSED TO BE WIRED
	((M-A) A-PGF-A)					;RESTORE REGS DURING MEM CYCLE
	((M-T) (A-CONSTANT 4))				;NORMAL STATUS
	((M-B) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-T
		PHT2-MAP-STATUS-CODE A-B)
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-B) A-PGF-B)
	((VMA) A-PGF-VMA)				;RESTORE VMA
	((M-T) SELECTIVE-DEPOSIT WRITE-MEMORY-DATA
		MAP-PHYSICAL-PAGE-NUMBER (A-CONSTANT 1))
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-WRITE-MAP) DPB		;SET UP 2ND LEVEL MAP
		 WRITE-MEMORY-DATA MAP-ACCESS-STATUS-AND-META-BITS A-T)
       ((M-T) A-PGF-T)					;GO RETRY MEMORY CYCLE

;REFERENCE TO PAGE MARKED FLUSHABLE.  WE WANT THIS PAGE AFTER ALL, CHANGE BACK TO NORMAL
PGF-FL	
;REFERENCE TO PAGE WITH AGE TRAP.  CHANGE BACK TO NORMAL TO INDICATE PAGE
;HAS BEEN REFERENCED, AND SHOULDN'T BE SWAPPED OUT OR MADE FLUSHABLE.
PGF-AG	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
		PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT 1))	;SW STS := NORMAL
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;THEN DROP THROUGH

;RELOAD HARDWARE MAP FROM PAGE HASH TABLE
PGF-RL	((VMA-START-READ) ADD VMA (A-CONSTANT 1))	;GET SECOND WORD
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;TABLE SUPPOSED TO BE WIRED
	((M-A) A-PGF-A)					;RESTORE REGS DURING MEM CYCLE
	((M-B) A-PGF-B)
	((VMA) A-PGF-VMA)
	((M-T) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)
	(CALL-EQUAL M-T (A-CONSTANT 37) ILLOP)		;ABOUT TO CLOBBER
	(DISPATCH (LISP-BYTE %%PHT2-MAP-STATUS-CODE)
			READ-MEMORY-DATA D-SWAPAR)	;VERIFY THE BITS
	((M-T) SELECTIVE-DEPOSIT READ-MEMORY-DATA
		MAP-PHYSICAL-PAGE-NUMBER (A-CONSTANT 1))
	(POPJ-AFTER-NEXT				;SET UP 2ND LVL MAP
	 (WRITE-MEMORY-DATA-WRITE-MAP) DPB
		 READ-MEMORY-DATA MAP-ACCESS-STATUS-AND-META-BITS A-T)
       ((M-T) A-PGF-T)

;ROUTINE TO LOOK FOR PAGE ADDRESSED BY M-T IN THE PAGE HASH TABLE
;RETURNS WITH VMA AND READ-MEMORY-DATA POINTING TO PHT1 WORD,
;OR VMA POINTING TO FIRST HOLE IN HASH TABLE AND PHT1-VALID-BIT
;OF READ-MEMORY-DATA ZERO.  IN THIS CASE, THE SWAP STATUS FIELD
;OF READ-MEMORY-DATA WILL ALSO BE ZERO.  CLOBBERS M-A, M-B, M-T, A-TEM1.

SEARCH-PAGE-HASH-TABLE	
	((A-PGF-VMA) M-T)
	(CALL COMPUTE-PAGE-HASH)		;M-T := HASH (M-T)
SPHT1	((M-T) AND M-T A-PHT-INDEX-MASK)
	((VMA-START-READ) ADD A-V-PAGE-TABLE-AREA M-T)	;GET PHT ENTRY
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SUPPOSED TO BE WIRED
	((M-T) ADD M-T (A-CONSTANT 2))		;BUMP INDEX IN CASE
	(POPJ-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA) ;PAGE NOT IN PHT
	((M-A) XOR A-PGF-VMA READ-MEMORY-DATA)	;XOR VIRTUAL ADDRESSES
	(POPJ-AFTER-NEXT			;(HOPING WE'LL WIN AND RETURN)
	 (M-B) PHT1-VIRTUAL-PAGE-NUMBER M-A)	;ZERO IF MATCH
	(CALL-NOT-EQUAL M-B A-ZERO SPHT1)	;IF NOT FOUND, TRY NEXT

XCPH (MISC-INST-ENTRY %COMPUTE-PAGE-HASH)
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)
COMPUTE-PAGE-HASH	
	(CALL-IF-BIT-SET (BYTE-FIELD 1 23.) M-T ILLOP)  ;THIS MACHINE ONLY HAS 23.
	((A-TEM1) (BYTE-FIELD 10. 13.) M-T)	;VMA<22:13>
	((M-T) (BYTE-FIELD 18. 5) M-T)		;VMA<22:7>x4+C
	((M-T) ANDCA M-T (A-CONSTANT 3))	;-C
	((M-T) XOR M-T A-TEM1)
	(POPJ-AFTER-NEXT
	 (M-T) AND M-T A-PHT-INDEX-MASK)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;COMES HERE WHEN A PAGE NEEDS TO BE READ IN FROM DISK.
;
;FIRST, FIND SOME MEMORY.  ENTER A PIPELINED LOOP THAT SEARCHES PAGE HASH TABLE
;AT MEMORY SPEED, STARTING FROM LAST PLACE STOPPED, FOR A FLUSHABLE PAGE.  IF NONE
;FOUND, SEARCH INSTEAD FOR ANY NON WIRED PAGE. (THE EMERGENCY CASE.)
;
;HAVING FOUND A PAGE TO REPLACE, WRITE IT TO THE DISK IF NECESSARY.  THEN DELETE
;THAT ENTRY FROM THE PAGE HASH TABLE (HARD), AND FROM THE HARDWARE MAP (EASY).
;
;PERFORM THE DISK READ INTO THE CORE PAGE THUS MADE FREE.
;
;USE A PIPELINED LOOP TO SEARCH THE AREA TABLES AT MEMORY SPEED TO FIND THE
;AREA CONTAINING THE PAGE BEING REFERENCED, AND GET THE META BITS.
;
;NOW RE-HASH THE ADDRESS ORIGINALLY BEING
;REFERENCED TO FIND THE FIRST HOLE (MAY HAVE MOVED DUE TO DELETION) AND PUT
;IN AN ENTRY FOR THAT PAGE.  RESTART THE REFERENCE (SET UP THE MAP FIRST?)
;
;
;THIS IS FIRST TRY AT THIS CODE.  MAKES NO ATTEMPT TO OVERLAP TABLE LOOK UPS
;WITH DISK I/O.  MAKES NO ATTEMPT TO DO DISK WRITES WHILE THE MACHINE IS RUNNING.
;MAKES NO ATTEMPT TO RECOVER FROM DISK ERRORS.  MAKES NO ATTEMPT TO USE SYSTEM
;COMMUNICATIONS AREA, NOR TO SIGNAL SWAP-SCHEDULER PROCESS WHEN FLUSHABLE MEMORY
;GETS LOW, NOR EVEN TO KEEP TRACK OF AMOUNT OF FLUSHABLE MEMORY.
;
;NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
;THIS CODE ASSUMES THAT THE LOCATION IMMEDIATELY FOLLOWING PAGE-TABLE-AREA
;IS WIRED.  THIS SIMPLIFIES THE TERMINATION CONDITION FOR "PIPELINED" SEARCHES.

SWAPIN	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SWAPIN1))) ;CONTINUATION AFTER FINDCORE
	((M-B) A-V-PAGE-TABLE-AREA)
	((M-T) ADD M-B A-FINDCORE-SCAN-POINTER)	;RESUME SCAN FROM WHERE LEFT OFF
	((M-B) ADD M-B A-PHT-INDEX-MASK)	;BOUND (HIGHEST PHT ENTRY ADDRESS)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT
			M-T A-B FINDCORE2)	;IF ALREADY AT END, SKIP FIRST LOOP
       ((M-A) A-ZERO)				;PRELOAD BUFFER WITH INVALID CODE	
						;DROP INTO PIPELINE LOOP
;SEARCH THROUGH PHT FOR A FLUSHABLE PAGE, AT MEMORY SPEED.  NOTE PAGE FAULTS CAN'T HAPPEN.
;THIS LOOP GOES FROM THE STARTING POINT TO THE END OF THE TABLE.
FINDCORE1
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A D-FINDCORE)	;SEE IF PREVIOUS ONE WINS
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE1)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE

;SECOND TIME AROUND.  SEARCH THE WHOLE TABLE.  PRESUMABLY WILL FIND SOMETHING
;BEFORE WE REACH ORIGINAL STARTING POINT.
FINDCORE2
	((M-T) A-V-PAGE-TABLE-AREA)			;START FROM BEGINNING
	((M-T) SUB M-T (A-CONSTANT 2))
	((M-A) A-ZERO)
FINDCORE3	
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A D-FINDCORE)	;SEE IF PREVIOUS ONE WINS
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE3)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE

;*EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY*
;CAN'T FIND ANY CORE.  WELL, JUST GRAB ANY PAGE AT RANDOM, MORE OR LESS.
	((M-T) A-FINDCORE-SCAN-POINTER)			;START FROM "RANDOM" PLACE
FINDCORE4	
	((M-T) ADD M-T A-V-PAGE-TABLE-AREA)
	((M-A) A-ZERO)					;INIT THE PIPELINE
FINDCORE5	
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A		;SEE IF PREVIOUS ONE WINS
			 D-FINDCORE-EMERGENCY)
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE5)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE
	(JUMP-XCT-NEXT FINDCORE4)			;OUT OF BOUNDS, WRAP AROUND
       ((M-T) SUB M-ZERO (A-CONSTANT 2))		;IF NO FREE MEM, INFINITE LOOP

(LOCALITY D-MEM)
(START-DISPATCH 3 0)		;DISPATCH TABLE TO LOOK FOR FLUSHABLE PAGES
D-FINDCORE			;DISPATCH ON SWAP STATUS
	(P-BIT R-BIT)			;0 ILLEGAL
	(P-BIT R-BIT)			;1 NORMAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);2 FLUSHABLE
	(P-BIT R-BIT)			;3 NOT USED, WAS PDL BUFFER
	(P-BIT R-BIT)			;4 AGE TRAP
	(P-BIT R-BIT)			;5 WIRED DOWN
	(P-BIT R-BIT)			;6 NOT USED
	(P-BIT R-BIT)			;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;SAME FOR WHEN DESPERATE
D-FINDCORE-EMERGENCY		;DISPATCH ON SWAP STATUS
	(P-BIT R-BIT)			;0 ILLEGAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);1 NORMAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);2 FLUSHABLE
	(P-BIT R-BIT)			;3 NOT USED, WAS PDL BUFFER
	(INHIBIT-XCT-NEXT-BIT COREFOUND);4 AGE TRAP
	(P-BIT R-BIT)			;5 WIRED DOWN
	(P-BIT R-BIT)			;6 NOT USED
	(P-BIT R-BIT)			;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;DISPATCH TABLE TO DROP THROUGH IF PAGE NEEDS WRITING
D-WRITEBACK-NEEDED		;DISPATCH ON MAP STATUS
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;0 ILLEGAL (LVL 1 MAP)
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;1 ILLEGAL (LVL 2 MAP)
	(COREFOUND2)				;2 READ ONLY
	(COREFOUND2)				;3 READ/WRITE FIRST
	(P-BIT R-BIT)				;4 READ/WRITE - INDICATES PAGE MODIFIED
	(P-BIT R-BIT)				;5 PDL BUFFER, ALWAYS WRITE PDL-BUFFER PAGES
						;   SINCE R/W/F MECHANISM NOT AVAILABLE.
	(P-BIT R-BIT)				;6 MAR BREAK, ALWAYS WRITE FOR SAME REASON
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;7 ILLEGAL (NOT USED)
(END-DISPATCH)
(LOCALITY I-MEM)

;HERE WHEN WE'VE FOUND A PAGE TO EVICT
COREFOUND	
	(JUMP-LESS-OR-EQUAL M-T A-V-PAGE-TABLE-AREA COREFOUND1)  ;IF WRAP AROUND, ALREADY IN B
	((M-B) SUB M-T (A-CONSTANT 2))		;COMPUTE PHT ENTRY ADDRESS
;CALL HERE FROM XDPPG
COREFOUND1
	((VMA-START-READ) ADD M-B (A-CONSTANT 1))	;GET PHT2
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;PHT SHOULD BE ADDRESSABLE
	((A-FINDCORE-SCAN-POINTER)
		SUB M-B A-V-PAGE-TABLE-AREA)		;STORE BACK SCAN POINTER
	((M-A) SELECTIVE-DEPOSIT M-A PHT1-VIRTUAL-PAGE-NUMBER A-ZERO) ;DISK ADDRESS
	(DISPATCH-XCT-NEXT PHT2-MAP-STATUS-CODE
		 READ-MEMORY-DATA D-WRITEBACK-NEEDED)	;SEE IF NEEDS WRITING
       ((M-B) SELECTIVE-DEPOSIT READ-MEMORY-DATA
		     PHT2-PHYSICAL-PAGE-NUMBER A-ZERO)	;CORE ADDRESS
	((C-PDL-BUFFER-POINTER-PUSH) VMA)		;NEEDS WRITING, SAVE ADDR(PHT2)
	(CALL-XCT-NEXT DISK-SWAP-HANDLER)			;DO THE WRITE
       ((M-T) (A-CONSTANT DISK-WRITE-COMMAND))
	((A-DISK-PAGE-WRITE-COUNT) ADD M-ZERO A-DISK-PAGE-WRITE-COUNT ALU-CARRY-IN-ONE)
	((VMA) C-PDL-BUFFER-POINTER-POP)		;RESTORE PHT ENTRY ADDRESS+1
;DROPS THROUGH
;DROPS IN
;AT THIS POINT, VMA HAS ADDR+1 OF PHT ENTRY TO BE DELETED,
;M-A HAS ITS VIRTUAL ADDRESS, M-B HAS ITS CORE ADDRESS
;DELETION WORKS BY FINDING PAGES THAT SHOULD HAVE HASHED TO THE
;HOLE WHERE THE THING WAS DELETED, AND EXCHANGING THEM WITH THE HOLE.
;NOTE THAT THE ALGORITHM IN THE PAGING MEMO IS WRONG.
;CONVENTIONS: M-B POINTS AT THE HOLE, VMA POINTS AT THE ITEM SUSPECTED
;OF BEING IN THE WRONG PLACE, M-PGF-TEM POINTS AT THE UPPERMOST ENTRY IN THE PHT,
;M-T POINTS AT WHERE (VMA) SHOULD HAVE HASHED TO. THESE ARE TYPELESS ABSOLUTE ADDRESSES.

COREFOUND2	
	((C-PDL-BUFFER-POINTER-PUSH) M-B)		;SAVE PHYSICAL ADDRESS
	((M-B) SUB VMA (A-CONSTANT 1))			;-> PHT ENTRY TO DELETE
	((M-PGF-TEM) DPB M-ZERO Q-ALL-BUT-POINTER A-V-PAGE-TABLE-AREA)
	((M-PGF-TEM) ADD M-PGF-TEM A-PHT-INDEX-MASK)	;-> LAST ENTRY ON TABLE
PHTDEL1	((WRITE-MEMORY-DATA)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;DELETE PHT ENTRY
	((VMA-START-WRITE M-B) Q-POINTER M-B)
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SUPPOSED TO BE WIRED
PHTDEL2	(JUMP-GREATER-OR-EQUAL VMA A-PGF-TEM PHTDEL5)	;JUMP IF WRAP AROUND
	((VMA-START-READ) ADD VMA (A-CONSTANT 2))	;CHECK LOCATION FOLLOWING HOLE
PHTDEL3	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA PHTDELX)
	((M-T) SELECTIVE-DEPOSIT READ-MEMORY-DATA	;CHECK FOR DUMMY ENTRY
		PHT1-VIRTUAL-PAGE-NUMBER (A-CONSTANT -1))	;WHICH HAS AN ADDRESS OF -1
	(JUMP-EQUAL-XCT-NEXT M-T (A-CONSTANT -1) PHTDEL7)	;DUMMY ALWAYS HASHES
       ((M-T) M-B)					; TO THE HOLE
	(CALL-XCT-NEXT COMPUTE-PAGE-HASH)		;SOMETHING THERE, REHASH IT
       ((M-T) READ-MEMORY-DATA)
	((M-T) ADD M-T A-V-PAGE-TABLE-AREA)		;CONVERT FIXNUM HASH TO ADDRESS
	((M-T) Q-POINTER M-T)				;SANS EXTRA BITS
PHTDEL7	(JUMP-LESS-THAN VMA A-T PHTDEL4)		;JUMP ON FUNNY WRAP AROUND CASE
	(JUMP-GREATER-THAN M-T A-B PHTDEL2)		;JUMP IF HOLE IS NOT BETWEEN WHERE
	(JUMP-LESS-THAN VMA A-B PHTDEL2)		; THE FROB IS AND WHERE IT HASHES TO
PHTDEL6	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;MOVE THE CELL INTO THE HOLE
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-T) SUB VMA (A-CONSTANT 1))			;SAVE PNTR TO MOVED CELL
	((VMA) ADD M-B (A-CONSTANT 1))			;ADDRESS THE HOLE
	((WRITE-MEMORY-DATA-START-WRITE) READ-MEMORY-DATA)	;STORE PHT2
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((VMA) SUB VMA (A-CONSTANT 1))
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP) ;STORE PHT1
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-XCT-NEXT PHTDEL1)				;MAKE THE MOVED CELL INTO NEW HOLE
       ((M-B) M-T)

PHTDEL4	(JUMP-LESS-OR-EQUAL M-T A-B PHTDEL6)		;JUMP IF HOLE IS BETWEEN WHERE THE
	(JUMP-GREATER-OR-EQUAL VMA A-B PHTDEL6)		; FROB IS AND WHERE IT HASHES TO
	(JUMP PHTDEL2)					;IT'S NOT, LOOP MORE

PHTDEL5	(JUMP-XCT-NEXT PHTDEL3)				;WRAP AROUND TO BEG OF PHT
       ((VMA-START-READ) DPB M-ZERO Q-ALL-BUT-POINTER A-V-PAGE-TABLE-AREA)

PHTDELX	((M-B) C-PDL-BUFFER-POINTER-POP)		;RESTORE PHYSICAL ADDR OF FOUND PG
	((VMA) M-A)					;ACCESS MAP FOR VIRT PAGE DELETED
	((M-PGF-TEM) MAP-STATUS-CODE MEMORY-MAP-DATA)
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-PGF-TEM	;POPJ, MAYBE XCT NEXT
	  (A-CONSTANT (EVAL %PHT-MAP-STATUS-SECOND-LEVEL-MAP-NOT-VALID)))
       ((WRITE-MEMORY-DATA-WRITE-MAP) DPB (M-CONSTANT -1) ;FLUSH 2ND LVL MAP, IF ANY
		MAP-STATUS-CODE-LOW-BIT (A-CONSTANT 1))

;WE HAVE FOUND CORE, CONTINUE SWAPPING IN.  NEXT STEP IS TO
; SEARCH AREA TABLES TO FIND META BITS.

SWAPIN1	((M-A) DPB M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA)	;M-A DISK ADDRESS TO BE READ IN
							;M-B CORE ADDRESS TO READ IT INTO
	(CALL-XCT-NEXT XARN00)				;ADDR IN M-A => AREA NUMBER IN M-T
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-B Q-POINTER	;PRESERVE AND PROTECT CORE ADDRESS
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-EQUAL M-T A-V-NIL ILLOP)			;SWAPPING IN A PAGE NOT IN AN AREA
	((WRITE-MEMORY-DATA) DPB M-T Q-POINTER		;SET UP PHYSICAL-PAGE-AREA-NUMBER ENTRY
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-PGF-TEM) VMA-PHYS-PAGE-ADDR-PART C-PDL-BUFFER-POINTER)
	((VMA-START-WRITE) ADD M-PGF-TEM A-V-PHYSICAL-PAGE-AREA-NUMBER)
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULD BE WIRED DOWN	
	((VMA-START-READ) ADD M-T A-V-AREA-MODE-BITS)	;GET MODES WORD
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULD BE WIRED DOWN
	((M-B) C-PDL-BUFFER-POINTER)			;RESTORE PHYS ADDRESS
	((M-3 C-PDL-BUFFER-POINTER-PUSH)		;SAVE THE MISC BITS FOR MAP
	    (LISP-BYTE %%AREA-MODE-ACCESS-STATUS-AND-META-BITS) READ-MEMORY-DATA)
	((M-T) A-MAR-LOW)				;CHECK VMA AGAINST MAR
	((M-T) SELECTIVE-DEPOSIT M-T VMA-PAGE-ADDR-PART A-ZERO)
	(JUMP-LESS-THAN M-A A-T NOMAR)
	((M-T) A-MAR-HIGH)
	((M-T) SELECTIVE-DEPOSIT M-T VMA-PAGE-ADDR-PART A-ZERO)
	(JUMP-GREATER-THAN M-A A-T NOMAR)
	((M-T) (A-CONSTANT (EVAL %PHT-MAP-STATUS-MAR)))
	((C-PDL-BUFFER-POINTER) DPB M-T PHT2-MAP-STATUS-CODE A-3) ;YEP, CHANGE MAP STATUS
NOMAR	(JUMP-IF-BIT-SET M-DONT-SWAP-IN CZRR)		;IF FRESH PAGE DON'T REALLY SWAP IN
	(CALL-XCT-NEXT DISK-SWAP-HANDLER)		;READ THE PAGE IN FROM DISK
       ((M-T) (A-CONSTANT DISK-READ-COMMAND))
	((A-DISK-PAGE-READ-COUNT) ADD M-ZERO A-DISK-PAGE-READ-COUNT ALU-CARRY-IN-ONE)
SWAPIN2	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)		;FIND HOLE IN PHT FOR IT
       ((M-T) A-PGF-VMA)
	(CALL-IF-BIT-SET PHT1-VALID-BIT READ-MEMORY-DATA ILLOP)	;SUPPOSED TO BE A HOLE!
	((M-A) A-PGF-VMA)
	((WRITE-MEMORY-DATA-START-WRITE)		;CONSTRUCT AND STORE PHT1 WORD
	    SELECTIVE-DEPOSIT M-A PHT1-VIRTUAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
					(BYTE-VALUE PHT1-VALID-BIT 1))
				  (BYTE-VALUE PHT1-SWAP-STATUS-CODE 1))))
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULD BE WIRED
	((M-PGF-TEM) C-PDL-BUFFER-POINTER-POP)		;RESTORE ACCESS, STATUS, AND META BITS
	(DISPATCH (LISP-BYTE %%PHT2-MAP-STATUS-CODE) M-PGF-TEM D-SWAPAR) ;VERIFY THE BITS
	((VMA) ADD VMA (A-CONSTANT 1))			;ADDRESS PHT2
	((WRITE-MEMORY-DATA-START-WRITE)		;CONSTRUCT AND STORE PHT2 WORD
	    SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER-POP
	    PHT2-ALL-BUT-ACCESS-STATUS-AND-META-BITS A-PGF-TEM)
	(CALL-CONDITIONAL PG-FAULT ILLOP)		;SHOULD BE WIRED
	(JUMP PGF-RESTORE)				;TAKE FAULT AGAIN SINCE DISK XFER
				;MAY HAVE FAULTED AND FLUSHED SECOND LEVEL MAP BLOCK.

(LOCALITY D-MEM)
(START-DISPATCH 3 0)				;DISPATCH ON MAP-STATUS
D-SWAPAR					;VERIFY MAP STATUS CODE FROM CORE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;0 FIRST LEVEL MAP NOT SET UP ERRONEOUS
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;1 SECOND LEVEL MAP NOT SET UP ERRONEOUS
	(P-BIT R-BIT)				;2 READ ONLY
	(P-BIT R-BIT)				;3 READ WRITE FIRST
	(P-BIT R-BIT)				;4 READ WRITE
	(P-BIT R-BIT)				;5 PDL BUFFER
	(P-BIT R-BIT)				;6 MAR BREAK
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 UNUSED CODE
(END-DISPATCH)
(LOCALITY I-MEM)

;INITIALIZE A FRESH PAGE BY FILLING IT WITH <DTP-TRAP .>
;M-A/ VIRTUAL ADDR (NO TYPE BITS), M-B/ PHYSICAL ADDR
CZRR	((VMA) A-ZERO)				;CLOBBER MAP 0 TO POINT TO PAGE
	((WRITE-MEMORY-DATA-WRITE-MAP) SELECTIVE-DEPOSIT M-B MAP-PHYSICAL-PAGE-NUMBER
		(A-CONSTANT 600000001))
CZRR1	((WRITE-MEMORY-DATA-START-WRITE)	;STORE TRAPS
		ADD VMA A-A)			;NOTE DTP-TRAP = 0
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-LESS-THAN-XCT-NEXT VMA (A-CONSTANT 177) CZRR1)
       ((VMA) ADD VMA (A-CONSTANT 1))
	((A-FRESH-PAGE-COUNT) ADD M-ZERO A-FRESH-PAGE-COUNT ALU-CARRY-IN-ONE)
	((VMA) A-ZERO)
	(JUMP-XCT-NEXT SWAPIN2)			;RETURN TO MAIN SWAP-IN CODE
       ((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 600000001))	;RESTORE LOC 0 MAP


;AGER. CALLED FROM DISK-SWAP-HANDLER, MAY CLOBBER M-C, M-1, A-TEM1, A-TEM2, A-TEM3.
;THIS ADVANCES A-AGING-SCAN-POINTER C(A-AGING-RATE) STEPS THROUGH THE PHT.
;IF A PAGE IS FOUND WITH NORMAL SWAP-STATUS, IT IS CHANGED TO AGE TRAP.
;IF A PAGE IS FOUND WITH AGE-TRAP STATUS, IT IS CHANGED TO FLUSHABLE.
AGER	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER A-AGING-RATE) ;GET NUMBER OF TIMES AROUND LOOP
	(POPJ-EQUAL M-1 A-ZERO)				;RETURN AT ONCE IF AGING IS OFF
	((M-C) A-AGING-SCAN-POINTER)			;GET SCAN POINTER ON M SIDE
AGER0	((VMA-START-READ) ADD M-C A-V-PAGE-TABLE-AREA)	;GET A PHT1 WORD
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-LESS-THAN M-C A-PHT-INDEX-MASK AGER1)	;JUMP IF NO WRAP AROUND
	((M-C) SUB M-ZERO (A-CONSTANT 2))		;OTHERWISE WILL RESET TO ZERO
AGER1	(DISPATCH-XCT-NEXT PHT1-SWAP-STATUS-CODE READ-MEMORY-DATA D-AGER)
       ((M-C) ADD M-C (A-CONSTANT 2))			;ADVANCE POINTER
	(JUMP-GREATER-THAN-XCT-NEXT M-1 (A-CONSTANT 1) AGER0)	;LOOP
       ((M-1) SUB M-1 (A-CONSTANT 1))
	(POPJ-AFTER-NEXT				;DONE, RETURN
	 (A-AGING-SCAN-POINTER) M-C)			;UPDATING SCAN POINTER
       (NO-OP)

(LOCALITY D-MEM)
(START-DISPATCH 3 0) ;XCT-NEXT
D-AGER	(P-BIT R-BIT)	;0 PHT ENTRY INVALID, IGNORE
	(P-BIT AGER2)	;1 NORMAL, SET AGE TRAP
	(P-BIT R-BIT)	;2 FLUSHABLE, IGNORE
	(P-BIT ILLOP)	;3 NOT USED (FORMERLY PDL BUFFER)
	(P-BIT AGER3)	;4 AGE TRAP, CHANGE TO FLUSHABLE
	(P-BIT R-BIT)	;5 WIRED, IGNORE
	(P-BIT ILLOP)	;6 NOT USED, ERROR
	(P-BIT ILLOP)	;7 NOT USED, ERROR
(END-DISPATCH)
(LOCALITY I-MEM)

;CHANGE NORMAL TO AGE-TRAP, ALSO TURN OFF HARDWARE MAP ACCESS
AGER2	((A-PAGE-AGE-COUNT) ADD M-ZERO A-PAGE-AGE-COUNT ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
	    PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT (EVAL %PHT-SWAP-STATUS-AGE-TRAP)))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-XCT-NEXT CLRPGM)
       ((VMA) SELECTIVE-DEPOSIT WRITE-MEMORY-DATA PHT1-VIRTUAL-PAGE-NUMBER A-ZERO)	

;CHANGE AGE-TRAP TO FLUSHABLE
AGER3	((A-PAGE-FLUSH-COUNT) ADD M-ZERO A-PAGE-FLUSH-COUNT ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
	    PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT (EVAL %PHT-SWAP-STATUS-FLUSHABLE)))
       (CALL-CONDITIONAL PG-FAULT ILLOP)

;GIVEN AN ADDRESS FIND WHAT AREA IT IS IN.  RETURNS THE AREA NUMBER OR NIL
;IF NOT IN ANY AREA.  MUST CLOBBER ONLY M-T, M-3, Q-R, A-TEM1, A-TEM2, A-TEM3, M-B
;SINCE IT IS CALLED BY THE PAGE FAULT ROUTINES.
;TAKES ARG IN M-A, WHICH IT MUST NOT CLOBBER.  RETURNS IN M-T.
XARN (MISC-INST-ENTRY %AREA-NUMBER)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;AN ADDRESS IN THE AREA
XARN00	((M-T Q-R) A-V-AREA-SORTED-BY-ORIGIN)	;LOWER BOUND FOR LOG SEARCH
						;ALSO CLEARS Q0 SO SHIFT RIGHT 1 WINS
	((A-TEM1) DPB M-ZERO Q-ALL-BUT-POINTER A-/#-AREAS)	;WILL HAVE HALF RANGE
	((A-TEM3) ADD M-T A-TEM1)		;UPPER LIMIT
XARN0	(JUMP-EQUAL Q-R (A-CONSTANT 1) XARN2)	;MOVING DOWN AND RANGE = 1 => DONE
XARN1	((A-TEM1 Q-R) ADD M-ZERO A-TEM1 ALU-CARRY-IN-ONE	;DECREASES RANGE BY 1/2
		 OUTPUT-SELECTOR-RIGHTSHIFT-1)
	((VMA-START-READ M-3) ADD M-T A-TEM1)	;PROBE CENTER OF TABLE
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULD BE WIRED
	(JUMP-GREATER-OR-EQUAL VMA A-TEM3 XARN0) ;IF RUN OFF TOP OF TABLE, MOVE DOWN
	((VMA-START-READ) ADD READ-MEMORY-DATA A-V-AREA-ORIGIN)
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;SHOULD BE WIRED
	((A-TEM2) Q-POINTER READ-MEMORY-DATA)	;GET ORIGIN OF AREA PROBING AT
	(JUMP-LESS-THAN M-A A-TEM2 XARN0)	;JUMP IF MOVE DOWN
	(JUMP-XCT-NEXT XARN1)
       ((M-T) M-3)				;MOVE UP

;HERE WHEN HAVE NARROWED IT TO ONE ITEM, VMA AND READ-MEMORY-DATA
;HAVE THE AREA-ORIGIN ENTRY FOR THE WRONG AREA, BUT M-T POINTS
;AT THE AREA-SORTED-BY-ORIGIN ENTRY FOR THE ONLY POSSIBLE CORRECT AREA PROBABLY
XARN2	((VMA-START-READ M-3) M-T)		;DIG UP THE AREA NUMBER, SAVE M-T
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-T A-V-AREA-ORIGIN) ;GET ORIGIN OF CORRECT AREA
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-B) Q-POINTER READ-MEMORY-DATA)
	(CALL-LESS-THAN M-A A-B XFALSE)		;OUTSIDE AREA
	((VMA-START-READ) ADD M-T A-V-AREA-LENGTH)
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;GET LENGTH, SHOULD BE WIRED
	((A-TEM2) Q-POINTER READ-MEMORY-DATA)
	((M-B) ADD M-B A-TEM2)			;UPPER BOUND OF THIS AREA
	(POPJ-LESS-THAN M-A A-B)		;RETURN IF INSIDE AREA, # IN M-T
	(JUMP-NOT-EQUAL A-TEM2 M-ZERO XFALSE)	;IT'S ABOVE THIS AREA
	(JUMP-XCT-NEXT XARN1)			;ZERO LENGTH, TRY NEXT AREA SAME ORIGIN
       ((M-T) ADD M-3 (A-CONSTANT 1))

;DISK HANDLER FOR PHOENIX DISK (XYLOGICS)
;ENTER WITH M-A/ VIRTUAL ADDR, M-B/ PHYSICAL ADDR, M-T/ DISK COMMAND
;CLOBBERS A-TEM1, A-TEM2, A-TEM3, VMA, M-T.  M-A MUST NOT HAVE ANY EXTRA BITS ON.

DISK-SWAP-HANDLER
	(CALL-GREATER-OR-EQUAL M-A A-DISK-MAXIMUM ILLOP)	;ADDRESS OUT OF BOUNDS
	;((M-A) ADD M-A A-DISK-OFFSET)			;RELOCATE TO APPROPRIATE PART OF DISK
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-VMA)		;SAVE PAGE FAULT HANDLER VARIABLES
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-WMD)		;IN CASE OF RECURSIVE FAULT
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-T)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-A)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-C)		;ARG TO DISK ROUTINE
	((C-PDL-BUFFER-POINTER-PUSH) M-1)		;CLOBBERED BY DISK ROUTINE
	((C-PDL-BUFFER-POINTER-PUSH) M-2)		;..
	((WRITE-MEMORY-DATA) SETO)			;TURN ON DISK RUN LIGHT
	((VMA-START-WRITE) A-DISK-RUN-LIGHT)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) SETZ)			;TURN OFF CPU RUN LIGHT
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 2))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
DISK-SWAP-RETRY 
	(CALL-XCT-NEXT DISK-OP)				;CALL DISK ROUTINE
       ((M-C) DPB (M-CONSTANT -1) (BYTE-FIELD 24. 8) A-ZERO) ;-400 ;NEGATIVE 16BIT WD COUNT
	(CALL AGER)					;RUN AGER WHILE IN DISK WAIT
	(CALL-XCT-NEXT DISK-WAIT)			;NOW WAIT FOR OPERATION TO COMPLETE
       ((M-2) M-T)		;SAVE OP IN CASE NEEDED FOR RETRY
	(JUMP-NOT-EQUAL M-T A-V-NIL DISK-SWAP-ERR)	;IF DISK ERROR OCCURRED
	((WRITE-MEMORY-DATA) SETZ)			;TURN OFF DISK RUN LIGHT
	((VMA-START-WRITE) A-DISK-RUN-LIGHT)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) SETO)			;TURN ON CPU RUN LIGHT
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 2))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	;((M-A) SUB M-A A-DISK-OFFSET)			;FIX M-A
	((M-2) C-PDL-BUFFER-POINTER-POP)		;RESTORE REGISTERS
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((M-C) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-B) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-A) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-T) C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	 (A-PGF-WMD) C-PDL-BUFFER-POINTER-POP)
       ((A-PGF-VMA) C-PDL-BUFFER-POINTER-POP)

DISK-SWAP-ERR
	(CALL-IF-BIT-SET (BYTE-FIELD 1 37) M-2 ILLOP)	;LOST TWICE IN A ROW
	((A-DISK-ERROR-COUNT) ADD M-ZERO A-DISK-ERROR-COUNT ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT DISK-SWAP-RETRY)		;RESTORE OP, BUT SET SIGN IN CASE LOSE AGAIN
       ((M-T) DPB (M-CONSTANT -1) (BYTE-FIELD 1 37) A-2)

DISK-OP	((VMA-START-READ) A-DISK-REGS-BASE)		;WAIT FOR DISK TO BE NOT BUSY
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 7) READ-MEMORY-DATA DISK-OP)
	((WRITE-MEMORY-DATA) VMA-PHYS-PAGE-ADDR-PART M-B (A-CONSTANT 100000)) ;WRITE PERMIT
	((VMA-START-WRITE) A-DISK-PAGE-MAP-ADDR)	;SET UP THE MAP TO PHYSICAL ADDRESS
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((M-1) VMA-PAGE-ADDR-PART M-A)			;GET DISK BLOCK NUMBER
	(CALL-XCT-NEXT DIV)				;DIVIDE TO GET CYLINDER IN Q-R,
       ((M-2) (A-CONSTANT 160.))			;REMAINDER IN M-1
        ((C-PDL-BUFFER-POINTER-PUSH) Q-R)		;SAVE CYLINDER (PG FAULT MIGHT ALTER Q)
	((M-2) (BYTE-FIELD 3 5) M-1)			;GET HEAD (32. SECTORS PER TRACK)
	((M-2) DPB M-2 (BYTE-FIELD 3 2) A-ZERO)		;TIMES 4
	((WRITE-MEMORY-DATA) DPB M-2 (BYTE-FIELD 11. 5) A-1)	;MAKE HEAD-SECTOR ADDRESS
	((VMA-START-WRITE) ADD M-ZERO A-DISK-REGS-BASE ALU-CARRY-IN-ONE) ;STORE
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) A-DISK-PAGE-ADDR)		;STORE BUS ADDRESS
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) M-C)			;STORE COUNT OF 16 BIT WORDS
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) C-PDL-BUFFER-POINTER-POP)	;STORE CYLINDER 
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) M-T)			;STORE COMMAND
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) A-DISK-REGS-BASE)
       (CALL-CONDITIONAL PG-FAULT PGF-W)

;WAIT FOR DISK COMPLETION, RETURN NIL IF OK OR ELSE ERROR STATUS (?)
DISK-WAIT	
	((M-T) (A-CONSTANT 25.))	;wait approx 10usec
DISK-WAIT-LOOP
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-T A-ZERO DISK-WAIT-LOOP)
       ((M-T) SUB M-T (A-CONSTANT 1))
	((VMA-START-READ) A-DISK-REGS-BASE)		;AWAIT DONE
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 7) READ-MEMORY-DATA DISK-WAIT)
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 15.) READ-MEMORY-DATA XTRUE) ;ERROR
       (JUMP XFALSE)					;NO ERROR, RESULT IS NIL

;;; MISCELLANEOUS FUNCTIONS FOR LISP PROGRAMS TO HACK THE PAGE HASH TABLE

XCPGS (MISC-INST-ENTRY %CHANGE-PAGE-STATUS)
	;ARGS ARE VIRTUAL ADDRESS, SWAP STATUS CODE, ACCESS STATUS AND META BITS
	;DOESN'T DO ERROR CHECKING, IF YOU DO THE WRONG THING YOU WILL LOSE.
	((M-E) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ACCESS STATUS AND META BITS
	((M-D) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;SWAP STATUS CODE
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)
       ((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;VIRTUAL ADDRESS
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA XFALSE)	;NOT SWAPPED IN
	((A-TEM1) READ-MEMORY-DATA)
	(JUMP-EQUAL M-D A-V-NIL XCPGS1)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-D PHT1-SWAP-STATUS-CODE A-TEM1)
	(CALL-CONDITIONAL PG-FAULT ILLOP)
XCPGS1	(JUMP-EQUAL M-E A-V-NIL XCPGS2)
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((A-TEM2) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-E PHT2-ACCESS-STATUS-AND-META-BITS A-TEM2)
	(CALL-CONDITIONAL PG-FAULT ILLOP)
XCPGS2	((M-T) A-V-TRUE)			;GET READY TO RETURN T
	((VMA) A-TEM1)				;ADDRESS LOCATION BEING HACKED
;CALL HERE TO CLEAR THE LOCATION IN VMA OUT OF THE LEVEL 2 MAP, BASHES M-3
CLRPGM	((M-3) MAP-STATUS-CODE MEMORY-MAP-DATA)
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-3	;POPJ, MAYBE XCT NEXT
	  (A-CONSTANT (EVAL %PHT-MAP-STATUS-SECOND-LEVEL-MAP-NOT-VALID)))
       ((WRITE-MEMORY-DATA-WRITE-MAP) DPB (M-CONSTANT -1) ;FLUSH 2ND LVL MAP, IF ANY
		MAP-STATUS-CODE-LOW-BIT (A-CONSTANT 1))

XCPPG (MISC-INST-ENTRY %CREATE-PHYSICAL-PAGE)
	;ARG IS PHYSICAL ADDRESS
	((VMA-START-READ) A-V-PAGE-TABLE-AREA)		;FIND FIRST HOLE
XCPPG0	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-3) SUB VMA A-V-PAGE-TABLE-AREA)
	(CALL-GREATER-THAN M-3 A-PHT-INDEX-MASK ILLOP)	;OUT OF BOUNDS
	(JUMP-IF-BIT-SET-XCT-NEXT PHT1-VALID-BIT READ-MEMORY-DATA XCPPG0)
       ((VMA-START-READ) ADD VMA (A-CONSTANT 2))
	(NO-OP)						;USELESS MEM CYCLE
	((VMA) SUB VMA (A-CONSTANT 2))			;ADDRESS PHT1 OF HOLE
	((WRITE-MEMORY-DATA-START-WRITE) DPB (M-CONSTANT -1)	;FAKE VIRTUAL ADDRESS
		PHT1-VIRTUAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE PHT1-SWAP-STATUS-CODE 2) ;FLUSHABLE
					(BYTE-VALUE PHT1-VALID-BIT 1))
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((VMA) ADD VMA (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTRUE)
       ((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		C-PDL-BUFFER-POINTER-POP PHT2-PHYSICAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (BYTE-VALUE PHT2-ACCESS-STATUS-AND-META-BITS 120) ;RO
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

XDPPG (MISC-INST-ENTRY %DELETE-PHYSICAL-PAGE)
	;ARG IS PHYSICAL ADDRESS
	((M-T) PHT2-PHYSICAL-PAGE-NUMBER C-PDL-BUFFER-POINTER-POP)
	((M-A) ADD M-ZERO A-V-PAGE-TABLE-AREA ALU-CARRY-IN-ONE)	;SCAN THROUGH ALL OF PHT
	((M-Q VMA-START-READ) ADD M-A A-PHT-INDEX-MASK)	;IN BACKWARDS ORDER, READING PHT2'S
XDPPG0	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((A-TEM1) PHT2-PHYSICAL-PAGE-NUMBER READ-MEMORY-DATA)
	(JUMP-EQUAL M-T A-TEM1 XDPPG2)			;SEEMS TO MATCH
XDPPG1	(JUMP-GREATER-THAN-XCT-NEXT M-Q A-A XDPPG0)
       ((M-Q VMA-START-READ) SUB M-Q (A-CONSTANT 2))
	(JUMP XFALSE)					;NOT FOUND

XDPPG2	((M-B VMA-START-READ) SUB M-Q (A-CONSTANT 1))	;CHECK PHT1
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA XDPPG1) ;FALSE ALARM
	(CALL-XCT-NEXT COREFOUND1)			;SWAP IT OUT, DELETE PHT ENTRY
       ((M-A) READ-MEMORY-DATA)
	(JUMP XTRUE)					;DONE

;PDL-BUFFER LOADING CONVENTIONS:
;   1. THE CURRENT RUNNING FRAME IS ALWAYS COMPLETELY CONTAINED WITHIN THE PDL-BUFFER.
;   2. SO IS ITS CALLING ADI (LOCATED IMMEDIATELY BEFORE IT ON PDL).
;   3. POINTERS ASSOCIATED WITH ADI (SUCH AS MULTIPLE VALUE STORING POINTERS
;	AND INDIRECT-ADI POINTERS) MAY POINT AT REGIONS OF THE PDL WHICH
;	ARE NOT CONTAINED WITHIN THE PDL-BUFFER.

;CHECKING TO SEE IF PDL-BUFFER NEEDS TO BE REFILLED:
;   SINCE M-AP CHANGES MUCH LESS FREQUENTLY THAN THE PDL-BUFFER POINTER ITSELF,
; ALL TESTING FOR PDL-BUFFER DUMPING/REFILLING IS DONE WITH REFERENCE TO M-AP.
; AS A RESULT, 400 (OCTAL) WORDS (THE MAXIMUM FRAME SIZE) EXTRA SLOP MUST BE LEFT.
; M-PDL-BUFFER-ACTIVE-QS CONTAINS THE NUMBER OF QS BETWEEN A-PDL-BUFFER-HEAD
; AND M-AP (MOMENTARILY, IT MAY BE NEGATIVE).
; WHENEVER M-AP IS CHANGED, M-PDL-BUFFER-ACTIVE-QS MUST LIKEWISE BE ADJUSTED.
;    CLEARLY, M-PDL-BUFFER-ACTIVE-QS MUST BE AT LEAST 4 FOR ANY CODE TO BE RUNNABLE.
; IN ADDITION, THE ADI OF THE RUNNING FRAME, IF ANY, MUST ALSO BE IN THE PDL-BUFFER.
; IF M-PDL-BUFFER-ACTIVE-QS IS GREATER THAN THE CONSTANT PDL-BUFFER-LOW-WARNING
; (SET TO 4 + MAX LENGTH OF ADI), IT MAY SAFELY BE ASSUMED THAT THE ADI, IF ANY,
; IS IN.
;    WHENEVER M-AP IS ADJUSTED DOWNWARD (POPPED), M-AP SHOULD BE ADJUSTED BEFORE
; M-PDL-BUFFER-ACTIVE-QS TESTED, SO THAT M-AP IS AT ITS NEW VALUE IF AND WHEN 
; PDL-BUFFER-REFILL IS REACHED.

;ROUTINE TO UNLOAD PDL-BUFFER INTO MAIN MEMORY, MAKING AT LEAST N WDS
; OF ROOM IN PDL BUFFER.  GENERAL IDEA IS START AT PDL-BUFFER INDEX A-PDL-BUFFER-HEAD
; AND VIRTUAL ADDRESS A-PDL-BUFFER-VIRTUAL-ADDRESS, WRITING OUT CRUFT AND INCREMENTING
; BOTH POINTERS.  ONE OPTIMIZATION IS WE FIDDLE MAP TO AVOID GOING THRU
; PAGE FAULT HANDLER ON EVERY CYCLE (WHICH WOULDNT QUITE WORK ANYWAY SINCE IT
; WOULD WRITE THE STUFF BACK IN THE PDL-BUFFER).  THUS, WE HAVE TO KEEP TRACK OF
; WHICH MAP PAGE WE HAVE HACKED AND PUT IT BACK AT END.  ALSO, CHECK IF MOVING TO A
; NEW PAGE, ETC.

PDL-BUFFER-DUMP 
	((M-2) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
	(CALL-NOT-EQUAL M-2 A-PDL-BUFFER-HIGH-WARNING TRAP)	;PUSH-DOWN CAPACITY EXCEEDED
   (ERROR-TABLE PDL-OVERFLOW REGULAR)	;I.E. ALREADY NEAR END, THERE IS PROBABLY JUST
					;ENOUGH SPACE LEFT TO DUMP WHAT'S IN THE PDL BUFFER NOW
			;HERE I AM ASSUMING THAT A-PDL-BUFFER-HIGH-WARNING IS GUARANTEED
			;NOT TO COME OUT NEGATIVE AFTER PDL-BUFFER-MAKE-ROOM RETURNS,
			;BECAUSE OF THE CHECK ABOVE.  THIS USED TO BE CHECKED.
;ARG IN M-2 -> HIGHEST "SATISFACTORY" VALUE FOR M-PDL-BUFFER-ACTIVE-QS.
; COMMON VALUES ARE PDL-BUFFER-HIGH-LIMIT TO UNBLOAT PDL-BUFFER OR
;   0 TO COMPLETELY DUMP PDL-BUFFER (THRU M-AP) OR
; - (PP + 1 - M-AP) TO REALLY COMPLETELY DUMP PDL-BUFFER
PDL-BUFFER-MAKE-ROOM 			;ARG IN M-2
	((A-TEM) PDL-BUFFER-INDEX)	;PRESERVE..
P-B-MR0
	((VMA-START-READ) A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;TAKE A READ CYCLE TO
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;MAKE SURE 2ND LVL MAP SET UP, ETC
		;NOTE A REFERENCE IS GUARANTEED TO SET UP 2ND LEVEL MAP
		;EVEN IF IT TURNS OUT TO BE IN THE PDL-BUFFER AND NO MAIN MEMORY
		;CYCLE IS MADE.
	((M-PGF-TEM) MEMORY-MAP-DATA)		;SAVE CORRECT MAP CONTENTS
						;OK TO USE M-PGF-TEM SINCE NOT GOING TO FAULT
	((WRITE-MEMORY-DATA-WRITE-MAP) IOR	;TURN ON ACCESS
	   MEMORY-MAP-DATA (A-CONSTANT 600000001))  ;AND SELECT WRITE IN LEVEL 2 MAP
P-B-MR1	(JUMP-LESS-OR-EQUAL M-PDL-BUFFER-ACTIVE-QS A-2 P-B-MRX)	;THRU, CLEAN UP
	((PDL-BUFFER-INDEX) A-PDL-BUFFER-HEAD)
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-INDEX)
	(CALL-CONDITIONAL PG-FAULT ILLOP)	;WRITE-ACCESS SUPPOSEDLY TURNED ON.
	((M-PDL-BUFFER-ACTIVE-QS) SUB 
		M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))		;MADE ONE Q WORTH OF ROOM
	((M-1) ADD M-ZERO A-PDL-BUFFER-HEAD ALU-CARRY-IN-ONE)
	((A-PDL-BUFFER-HEAD) DPB M-1 A-ZERO (BYTE-FIELD 10. 0))
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) 
	    ADD M-ZERO A-PDL-BUFFER-VIRTUAL-ADDRESS ALU-CARRY-IN-ONE)
	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER-WITHIN-PAGE A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(JUMP-EQUAL M-ZERO A-1 P-B-MR2)		;MOVING TO A NEW PAGE, UNFROB THAT ONE, ETC
	(JUMP-XCT-NEXT P-B-MR1)
       ((VMA) A-PDL-BUFFER-VIRTUAL-ADDRESS)

;HERE TO RESTORE THE MAP.  VMA POINTS AT THE LAST LOCATION ON THE PAGE.
P-B-MR2	(JUMP-XCT-NEXT P-B-MR0)		;LOOP BACK BECAUSE 2ND LVL MAP FOR NEW
						; PAGE MAY NOT BE SET UP.
       ((WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM	;RESTORE THE MAP
	   			(A-CONSTANT 1))

;HERE WHEN WE'RE DONE, BUT STILL HAVE TO UNMUNG THE MAP.
P-B-MRX	((WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM (A-CONSTANT 1)) 
P-B-X1	((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-QLPDLH)	;RECOMPUTE A-PDL-BUFFER-HIGH-WARNING
	((M-2) SUB M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-2) SUB M-2 (A-CONSTANT 2000))  ;GET NEGATIVE NUMBER IF NOT ENUF ROOM IN STACK IN
								;MAIN MEM TO HOLD ENTIRE P.B
	(JUMP-LESS-THAN M-2 A-ZERO P-B-SL-1)
	(POPJ-AFTER-NEXT			;ENUF ROOM, ALLOW P.B. TO FILL
	 (A-PDL-BUFFER-HIGH-WARNING) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
       ((PDL-BUFFER-INDEX) A-TEM)		;RESTORE

;GETTING NEAR THE END OF THE STACK.  SET A-PDL-BUFFER-HIGH-WARNING
;SO THAT WE WILL TRAP TO PDL-BUFFER-DUMP BEFORE GETTING MORE STUFF
;INTO THE PDL BUFFER THAN THERE IS ROOM TO STORE INTO MAIN MEMORY.
;NOTE THAT THIS RESULT CAN ACTUALLY BE NEGATIVE IF WE ARE CURRENTLY
;IN THE PROCESS OF TAKING A PDL-OVERFLOW TRAP.
P-B-SL-1(POPJ-AFTER-NEXT
	 (A-PDL-BUFFER-HIGH-WARNING) ADD M-2 (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
	((PDL-BUFFER-INDEX) A-TEM)		;RESTORE

PDL-BUFFER-REFILL	;ATTEMPT TO REFILL PDL-BUFFER FROM MAIN MEMORY SUCH THAT
			;M-PDL-BUFFER-ACTIVE-QS IS AT LEAST PDL-BUFFER-LOW-WARNING.
	((A-TEM) PDL-BUFFER-INDEX)	;PRESERVE IT.
	((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-QLPDLO)	;SO AS TO HAVE A COPY IN M-MEM, 
					; ALSO FLUSH GARBAGE.
P-R-0	(JUMP-GREATER-OR-EQUAL M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS 
				P-R-AT-BOTTOM);NO MORE PDL TO RELOAD, MAP NOT HACKED.
	((VMA-START-READ) ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;TAKE CYCLE TO ASSURE 2ND LVL MAP SET UP
	((M-PGF-TEM) MEMORY-MAP-DATA)		;SAVE CORRECT MAP CONTENTS, BETTER NOT PF
	((WRITE-MEMORY-DATA-WRITE-MAP) IOR	;ALLOW ACCESS TO MEMORY WHICH SHADOWS PDL BUF
	    MEMORY-MAP-DATA (A-CONSTANT 600000001))
P-R-1	(JUMP-GREATER-OR-EQUAL M-PDL-BUFFER-ACTIVE-QS 
	   (A-CONSTANT PDL-BUFFER-LOW-WARNING) P-B-MRX)	;ENUF IN THERE TO WIN.
	(JUMP-GREATER-OR-EQUAL M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS 
			P-R-AT-BOTTOM-1)	;NO MORE PDL TO RELOAD, MAP IS HACKED.
	((VMA-START-READ M-VMA-HELD) ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((PDL-BUFFER-INDEX) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)
P-R-3	((M-1) Q-DATA-TYPE READ-MEMORY-DATA)	;SHOULD PROBABLY EVENTUALLY BE A DISPATCH
;ASSURE THESE DATA-TYPES DONT MOVE ACROSS THE "BARRIER".
;******* LATER THIS WILL HAVE TO CHECK FOR POINTERS TO OLDSPACE *******
;******* CAN'T USE THE REGULAR TRANSPORT MECHANISM HERE BECAUSE THE MAP IS MUNGED *******
;	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL DTP-GC-FORWARD)) P-R-2) ;CAN NEVER APPEAR IN NEWSPACE
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL DTP-FORWARD)) P-R-2)
					;SHOULD ALSO CHECK ONE-Q-FORWARD AND EVCP, I GUESS
	((C-PDL-BUFFER-INDEX) READ-MEMORY-DATA)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))
	((A-PDL-BUFFER-HEAD) PDL-BUFFER-INDEX)	;ALSO EFFECTIVELY PERFORMS MASKING
	((A-PDL-BUFFER-VIRTUAL-ADDRESS)
	    ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER-WITHIN-PAGE A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(JUMP-NOT-EQUAL M-1 A-ZERO P-R-1)	;XFER ON NEXT WORD IN SAME PAGE AS THIS
	(JUMP-XCT-NEXT P-R-0)
       ((WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM	;RESTORE MAP
				(A-CONSTANT 1))	;NOTE VMA MUST STILL BE SET UP.

P-R-2	((WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM	;RESTORE MAP SO WE DON'T GET SCREWED
				(A-CONSTANT 1))	;NOTE VMA MUST STILL BE SET UP.
	;((VMA) READ-MEMORY-DATA)	;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)	;NOW INVOKE THE TRANSPORTER
	((PDL-BUFFER-INDEX) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)	;RESTORE BASHED P.I.
	((C-PDL-BUFFER-INDEX) READ-MEMORY-DATA)	;SAVE THE TRANSPORTED DATUM ON THE PDL
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))
	((A-PDL-BUFFER-HEAD) PDL-BUFFER-INDEX)	;ALSO EFFECTIVELY PERFORMS MASKING
	((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-QLPDLO)	;RESTORE M-2 PROBABLY SMASHED BY TRANSP
;******* PROBABLY A-TEM IS ALSO SMASHED, BUT IT PROBABLY DOESN'T MATTER ANYWAY *******
	(JUMP-XCT-NEXT P-R-0)			;NOW RE-START FAST LOOP FOR NEXT WORD
       ((A-PDL-BUFFER-VIRTUAL-ADDRESS)
	    ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)

P-R-AT-BOTTOM-1 
	((WRITE-MEMORY-DATA-WRITE-MAP) IOR M-PGF-TEM 	;RESTORE MAP
	    			(A-CONSTANT 1))  ;NOTE VMA MUST STILL BE SET UP.
P-R-AT-BOTTOM
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 4) ILLOP)	;OVER POP ..
	(JUMP P-B-X1)

;STACK-GROUP STUFF
; THE STACK GROUP QS MAY BE CONSIDERED TO BE DIVIDED INTO THREE GROUPS:
;   STATIC POINTERS, DYNAMIC STATE, AND LINKAGE QS.
; STATIC POINTERS ARE THINGS LIKE PDL ORIGINS.  THEY ARE LOADED, BUT NEVER STORED
;  BY STACK GROUP HACKING ROUTINES.
; DYNAMIC STATE ARE THINGS WHICH ARE CHANGED DURING THE OPERATION OF THE MACHINE.
;  THEY ARE BOTH LOADED AND STORED.
; LINKAGE QS ARE THINGS LIKE SG-STATE, SG-PREVIOUS-STACK-GROUP, ETC.  THEY ARE NOT
;  LOADED AND UNLOADED FROM A-MEMORY BY THE LOW LEVEL ROUTINES, BUT NOT "UPDATED".
;EACH OF THESE GROUPS IS ALLOCATED A CONTIGIOUS AREA WITHIN THE STACK-GROUP-HEADER.

; WHEN SAVING STATE, THINGS ARE FIRST SAVED IN THE PDL-BUFFER.  THE ENTIRE BLOCK
;IS THEN WRITTEN TO MAIN MEMORY.  WHEN RESTORING, THE ENTIRE BLOCK IS READ INTO
;THE PDL BUFFER, THEN RESTORED TO THE APPROPRIATE PLACES.  SINCE GENERALLY THE MOST
;"VOLATILE" THINGS WANT TO BE SAVED FIRST AND RESTORED LAST, A SORT OF PUSH DOWN LIKE
;OPERATION IS APPROPRIATE.  THUS THE VMA PUSHED ONTO THE PDL-BUFFER FIRST.
;ON THE STORE INTO MAIN MEMORY, IT IS STORED LAST.  THE STORING PROCEEDS IN LEADER
;INDEX ORDER (IE COUNTING DOWN IN MEMORY).  THUS THE VMA WINDS UP IN THE LOWEST
;Q OF THE ARRAY LEADER (JUST BEYOND THE LEADER-HEADER).  ON THE RELOAD,
;THE VMA IS THE FIRST THING READ FROM MEMORY.  IT THUS BECOMES DEEPEST ON THE PDL-BUFFER
;STACK, AND IS THE LAST THING RESTORED TO THE REAL MACHINE.  (ACTUALLY, THE VERY FIRST
;THING SAVED IS THE PDL-BUFFER-PHASING Q, WHICH IS SOMEWHAT SPECIAL SINCE IT IS ACTUALLY
;"USED" WHEN FIRST READ ON THE RELOAD).

;STORE DYNAMIC STATE OF MACHINE IN CURRENT STACK GROUP
;  MUST NOT CLOBBER M-A ON IMMEDIATE RETURN (THAT CAN HAVE SG-GOING-TO)
SGLV		;STORE EVERYTHING IN PDL-BUFFER IN REVERSE ORDER ITS TO BE WRITTEN TO MEMORY
		;M-3 HAS DESIRED NEW STATE FOR CURRENT STACK GROUP.  SWAP L-B-P OF
		;CURRENT STACK GROUP UNLESS 1.7 OF M-3 IS 1.
	((M-1) A-QCSTKG)
	((M-1) Q-DATA-TYPE M-1)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL DTP-STACK-GROUP)) ILLOP)

	((A-SG-STATE) DPB M-3 (LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
	((M-2) PDL-BUFFER-POINTER)		;SAVE ORIGINAL PDL LVL

	((C-PDL-BUFFER-POINTER-PUSH) DPB M-2 Q-POINTER 		;SAVE PDL-BUFFER-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	; FOR PHASING.
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-VMA-HELD Q-POINTER   ;SORT OF THE RIGHT THING..
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	((M-1) (A-CONSTANT (M-MEM-LOC M-ZR)))   ;SAVE REGS M-ZR THROUGH M-K
SGLV0	((OA-REG-HI) DPB M-1 OAH-M-SRC A-ZERO)
	((C-PDL-BUFFER-POINTER-PUSH) M-GARBAGE)		;M-GARBAGE = 0@M
	(JUMP-LESS-THAN-XCT-NEXT M-1 (A-CONSTANT (M-MEM-LOC M-K)) SGLV0)
       ((M-1) ADD M-1 (A-CONSTANT 1))

	(JUMP-IF-BIT-SET-XCT-NEXT M-3 (BYTE-FIELD 1 6) SGLV2)	;WANT TO SWAP THIS GUY' L-B-P?
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-FLAGS Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-J) A-QLBNDP)
SGLV3	(JUMP-LESS-OR-EQUAL M-J A-QLBNDO SGLV4)		;XFER ON THRU
	((VMA-START-READ M-VMA-HELD) M-J)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) SGLV5)
SGVSP	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT READ-MEMORY-DATA SGLV3)  ;NOT BINDING BLOCK
       ((M-J) SUB M-J (A-CONSTANT 1))				      ; SPACE PAST.
	(JUMP-LESS-OR-EQUAL M-J A-QLBNDO SGLV4)
	((VMA-START-READ) M-J)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(JUMP SGVSP)

SGLV5	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-C) READ-MEMORY-DATA)		;POINTER TO INTERNAL V.C.
	((VMA-START-READ M-J) SUB M-J (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	((M-VMA-HELD) VMA)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-D) READ-MEMORY-DATA)		;OLD BINDING TO BE RESTORED
	((VMA-START-READ M-VMA-HELD) M-C)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-ZR) READ-MEMORY-DATA)		;NEW BINDING TO BE SAVED
	((VMA) M-VMA-HELD)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-D Q-TYPED-POINTER A-ZR)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) DPB M-ZR Q-TYPED-POINTER A-D)
	((VMA-START-WRITE) M-J)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(JUMP-XCT-NEXT SGLV3)		;IN THIS DIRECTION, NO NEED TO CHECK FLAG BITS
       ((M-J) SUB M-J (A-CONSTANT 1))	;SINCE THINGS MUST REMAIN PAIRED AS LONG AS IN BINDINGS

SGLV4	((A-SG-STATE) DPB (M-CONSTANT -1) (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) A-SG-STATE)
SGLV2	((C-PDL-BUFFER-POINTER-PUSH) A-QLARYL)
	((C-PDL-BUFFER-POINTER-PUSH) A-QLARYH)

;	((C-PDL-BUFFER-POINTER-PUSH) A-QTRSTKG)
	((C-PDL-BUFFER-POINTER-PUSH) A-TRAP-MICRO-PC)

	((PDL-BUFFER-INDEX) M-AP)		;IF RUNNING MACRO-CODE, SAVE MACRO PC
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;SIMULATES SGSTR DISPATCH IN LMI
	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) QLLV)

	((M-B) MICRO-STACK-DATA-POP)		;TAKE OFF RETURN FOR SGLV (AC'S SAVED NOW)
;	((PDL-BUFFER-INDEX) M-AP)		;UNCOMMENT THIS CODE WHEN MICROCOMPILED FCTNS
;	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ; REALLY EXIST. WOULD JUST WASTE SPACE TILL
;	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) MLLV)  ;THEN.  IDEA IS TO STORE
						;USTACK IN STANDARD FORM; (1) FOR CONSISTANCY
						;(2) BECAUSE IT MAY BE RESPONSIBLE FOR 
						;SPECIAL-PDL BINDING BLOCKS.
	(CALL QMMPSH)				;TRANSFER USTACK TO SPECIAL-PDL
	((MICRO-STACK-DATA-PUSH) M-B)		;PUT BACK RETURN FOR SGLV
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-POINTER 		;RECORD # QS XFER ED
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  ;SG-U-STACK-QS

	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)		;SAVE A-IPMARK
       ((M-K) A-IPMARK)
	((M-K) SUB M-K A-QLPDLO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB Q-POINTER M-K 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)		;SAVE M-AP
       ((M-K) M-AP)
	((M-K) SUB M-K A-QLPDLO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB Q-POINTER M-K 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

	((M-1) A-QLBNDP)
	((M-1) SUB M-1 A-QLBNDO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 		;SAVE L-B-P LEVEL
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-2)			;SAVE P-B-POINTER AS RELATIVE ADR TO ENTIRE PDL
	((M-1) SUB M-K A-QLPDLO)	; ARRAY
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 		;SAVE PDL LEVEL
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;	((C-PDL-BUFFER-POINTER-PUSH) A-SG-FOLLOWING-STACK-GROUP)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-CALLING-ARGS-NUMBER)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-CALLING-ARGS-POINTER)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-PREVIOUS-STACK-GROUP)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-STATE)

	((M-2) M-A-1 M-AP A-2)		;GET - QS IN ACTIVE FRAME (AS 10. BIT NEG NUMBER OR 0)
	(JUMP-EQUAL M-2 A-ZERO SGLV1)
	((M-2) (BYTE-FIELD 10. 0) M-2 (A-CONSTANT -1))	;EXTEND SIGN TO MAKE REAL NEG NUMBER.
SGLV1	(CALL PDL-BUFFER-MAKE-ROOM) ;CAUSE ENTIRE PDL-BUFFER TO GET WRITTEN OUT.


	((VMA) A-QCSTKG)
	((VMA) SUB VMA (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))  ;2 FOR LEADER HEADER
	(CALL-XCT-NEXT SG-WRITE-BLOCK-FROM-PDL-BUFFER)
      ((M-ZR) ADD M-ZERO (A-CONSTANT (DIFFERENCE (EVAL SG-PDL-PHASE) (EVAL SG-STATE)))
			ALU-CARRY-IN-ONE)	;WANT PHASE-STATE+1
	(POPJ)

SG-WRITE-BLOCK-FROM-PDL-BUFFER 
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(POPJ-EQUAL M-ZR A-ZERO)
	((M-ZR) SUB M-ZR (A-CONSTANT 1))
	(JUMP-XCT-NEXT SG-WRITE-BLOCK-FROM-PDL-BUFFER)
       ((VMA) SUB VMA (A-CONSTANT 1))

SG-LOAD-BLOCK-INTO-PDL-BUFFER 
	((VMA-START-READ M-VMA-HELD) VMA)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(POPJ-EQUAL M-ZR A-ZERO)
	((M-ZR) SUB M-ZR (A-CONSTANT 1))
	;((VMA) READ-MEMORY-DATA)		;ADDRESS THE MAP
	(DISPATCH TRANSPORT-AC READ-MEMORY-DATA)
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)
SG-L-P-B-1
	(JUMP-XCT-NEXT SG-LOAD-BLOCK-INTO-PDL-BUFFER)
       ((VMA) ADD M-VMA-HELD (A-CONSTANT 1))

SG-LOAD-STATIC-STATE 		;LOAD STATIC STATE FOR STACK GROUP
	((M-A) A-QCSTKG)
	((M-1) Q-DATA-TYPE M-A)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL DTP-STACK-GROUP)) ILLOP)
	((VMA-START-READ M-VMA-HELD) SUB M-A (A-CONSTANT (PLUS 2 (EVAL SG-REG-PDL-ARRAY))))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)	;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(CALL-XCT-NEXT GAHD1)		;SET UP ARRAY LENGTH IN M-S AND DATA ORIGIN IN M-E
       ((M-A) READ-MEMORY-DATA)
  (ERROR-TABLE CALLS-SUB SG-REG-PDL)
	((A-QLPDLO) M-E)
	((A-QLPDLH) ADD M-E A-S)
	((M-A) A-QCSTKG)
	((VMA-START-READ M-VMA-HELD)
		 SUB M-A (A-CONSTANT (PLUS 2 (EVAL SG-LINEAR-BINDING-ARRAY))))
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)	;ADDRESS THE MAP
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(CALL-XCT-NEXT GAHD1)		;COMPUTE SAME THINGS FOR LINEAR-BINDING-ARRAY
       ((M-A) READ-MEMORY-DATA)
   (ERROR-TABLE CALLS-SUB SG-SPECIAL-PDL)
	(POPJ-AFTER-NEXT 
	 (A-QLBNDO) M-E)
       ((A-QLBNDH) ADD M-E A-S)

;PDL BUFFER "PHASING".  IF A STACK-GROUP IS INTERRUPTED AND LATER RESUMED,
;  IT HAS BEEN DECIDED TO PRESERVE THE "PHASING" OF THE PDL-BUFFER.
;  THIS MEANS THAT (FOR EXAMPLE) M-AP, A-IPMARK, PP, ETC, WILL HAVE THE
;  SAME OCTAL VALUES AS THEY DID (NOT MERELY POINT TO THE SAME QS, ETC).
;  IF THIS WERE NOT DONE, ONE COULD NOT "HOLD" A PDL-BUFFER INDEX ACROSS A 
;  POSSIBLE PAGE-FAULT BOUNDARY.  ALTHOUGH THAT MIGHT BE A LIVABLE-WITHABLE RESTRICTION,
;  IT SEEMS WORTH IT TO AVOID THAT CLASS OF POSSIBLE BUGS.

;CHANGE STACK-GROUP STATE TO ACTIVE.  RETURN IN M-3 PREVIOUS STATE.  IF L-B-P WAS
; SWAPPED, SWAP IT BACK.
SGENT	(CALL SG-LOAD-STATIC-STATE)
	((VMA) A-QCSTKG)
	((VMA-START-READ M-VMA-HELD) SUB VMA (A-CONSTANT (PLUS 2 (EVAL SG-PDL-PHASE))))
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO TRANSPORT SINCE IT'S A FIXNUM
	((PDL-BUFFER-POINTER) READ-MEMORY-DATA)		;RESTORE PP WITH CORRECT PHASING
	((M-1) Q-POINTER READ-MEMORY-DATA)
	((A-PDL-BUFFER-HEAD) ADD M-1 (A-CONSTANT 1))	;POINTS AT PDL-BUFFER LOCN WITH VALID
						;DATA (IE NONE YET)
	(CALL-XCT-NEXT SG-L-P-B-1)
       ((M-ZR) ADD M-ZERO		;-1 BECAUSE ONE FROB ALREADY HACKED, BUT +1 BECAUSE
	   (A-CONSTANT (DIFFERENCE (EVAL SG-PDL-PHASE) (EVAL SG-STATE))))  ;WANT PHASE-STATE+1

	((A-SG-STATE) C-PDL-BUFFER-POINTER-POP)
	((A-SG-PREVIOUS-STACK-GROUP) C-PDL-BUFFER-POINTER-POP)
	((A-SG-CALLING-ARGS-POINTER) C-PDL-BUFFER-POINTER-POP)
	((A-SG-CALLING-ARGS-NUMBER) C-PDL-BUFFER-POINTER-POP)
;	((A-SG-FOLLOWING-STACK-GROUP) C-PDL-BUFFER-POINTER-POP)

		;GET PDL-BUFFER RELOAD POINTER BACK INTO PHASE
	((M-1) ADD A-QLPDLO C-PDL-BUFFER-POINTER-POP ALU-CARRY-IN-ONE)  ;V.A. OF P.B. LOCN W/
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) Q-POINTER M-1)		;VALID DATA (IE NONE YET).
	((M-1) ADD A-QLBNDO C-PDL-BUFFER-POINTER-POP)
	((A-QLBNDP) Q-POINTER M-1)
	(CALL-XCT-NEXT GET-PDL-BUFFER-INDEX)
       ((M-K) ADD C-PDL-BUFFER-POINTER-POP A-QLPDLO)
	((M-AP) M-K)					;RESTORE M-AP
	(CALL-XCT-NEXT GET-PDL-BUFFER-INDEX)
       ((M-K) ADD C-PDL-BUFFER-POINTER-POP A-QLPDLO)
	((A-IPMARK) M-K)				;RESTORE A-IPMARK
	((M-LAST-MICRO-ENTRY) MICRO-STACK-DATA-POP)	;SAVE RETURN TO SGENT

;COMPUTE LENGTH OF ACTIVE FRAME AND LOAD MINUS THAT INTO M-PDL-BUFFER-ACTIVE-QS.
;THEN PDL-BUFFER-REFILL WILL RELOAD ENTIRE ACTIVE FRAME PLUS PDL-BUFFER-LOW-WARNING
;WORTH OF OTHER STUFF.
	((M-1) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)   ;WHAT PP WILL BE WHEN ALL THIS IS OVER
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-AP A-1) 	;GET - LENGTH OF ACTIVE FRAME MODULO
	(JUMP-EQUAL M-PDL-BUFFER-ACTIVE-QS A-ZERO SGENT1)  ;P.B. WRAPAROUND PROBLEMS
	((M-PDL-BUFFER-ACTIVE-QS) (BYTE-FIELD 10. 0) M-PDL-BUFFER-ACTIVE-QS 
		 (A-CONSTANT -1))		;EXTEND SIGN TO MAKE REAL NEG NUMBER.
SGENT1	(CALL PDL-BUFFER-REFILL)		;REFILL PDL-BUFFER WITH GOOD STUFF
	(CALL-GREATER-THAN M-ZERO A-PDL-BUFFER-HIGH-WARNING TRAP)  ;LOSEY LOSEY IT CANT EVEN
   (ERROR-TABLE PDL-OVERFLOW REGULAR)				   ; HOLD MAXIMUM SIZE FRAME
	((PDL-BUFFER-INDEX) M-AP)		;IF RUNNING MACRO-CODE, RESTORE MACRO PC
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;SIMULATES SGLOD DISPATCH IN LMI
	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) QLLENT)  ;GETS MAIN LOOP BACK
						;INTO PHASE AND PUSHES RIGHT RETURN ON USTACK

;	((PDL-BUFFER-INDEX) M-AP)		;UNCOMMENT THIS WHEN MICROCOMPILED FCTNS
;	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;REALLY EXIST
;	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) QMMPOP)

	(CALL-XCT-NEXT QMMPO1)			;TRANSFER OTHER STUFF BACK TO USTACK
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)

	((MICRO-STACK-DATA-PUSH) M-LAST-MICRO-ENTRY)	;PUSH BACK RETURN FROM SGENT

	((A-TRAP-MICRO-PC) C-PDL-BUFFER-POINTER-POP)
;	((A-QTRSTKG) C-PDL-BUFFER-POINTER-POP)

	((A-QLARYH) C-PDL-BUFFER-POINTER-POP)
	((A-QLARYL) C-PDL-BUFFER-POINTER-POP)
	((M-FLAGS) C-PDL-BUFFER-POINTER-POP)

	((M-1) A-SG-STATE)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) M-1 
		SGENT2)		;FALL THRU ON L-B-P SWAPPED
	((M-A) A-QLBNDO)	;POINTS TO FIRST WD OF FIRST BLOCK.
SGENT3	((VMA-START-READ M-A) ADD M-A (A-CONSTANT 1))	;IS 2ND WD OF BLOCK PNTR TO VALUE
	(CALL-CONDITIONAL PG-FAULT PGF-R)		; CELL?
	(JUMP-GREATER-THAN M-A A-QLBNDP SGENT4)		;XFER ON THRU
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA SGENT3)  ;MUST NOT BE 1ST WD OF BLOCK
							;IF IT IS, LOOP BACK FOR THAT BLOCK
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) SGENT6)
SGENT5	((M-VMA-HELD) VMA)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-C) READ-MEMORY-DATA)			;M-C HAS POINTER TO INTERNAL V.C.
	((VMA-START-READ M-VMA-HELD) SUB M-A (A-CONSTANT 1)) ;FIRST WD OF PAIR HOLDS INACTIVE 
	(CALL-CONDITIONAL PG-FAULT PGF-R)		; BINDING
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-D) READ-MEMORY-DATA)			;M-D HAS NEW VALUE BEING RESTORED
	((VMA-START-READ M-VMA-HELD) M-C)
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	;((VMA) READ-MEMORY-DATA)			;ADDRESS THE MAP
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-ZR) READ-MEMORY-DATA)			;M-ZR HAS OLD VALUE BEING SAVED
	((VMA) M-VMA-HELD)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-D Q-TYPED-POINTER A-ZR)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((WRITE-MEMORY-DATA) DPB M-ZR Q-TYPED-POINTER A-D)
	((VMA-START-WRITE) SUB M-A (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	(JUMP-XCT-NEXT SGENT3)
       ((M-A) ADD M-A (A-CONSTANT 1))			;SPACE TO FIRST Q OF NEXT PAIR

SGENT6	((VMA-START-READ M-A) ADD M-A (A-CONSTANT 1))  ;THIS NOT A BINDING BLOCK, SPACE OVER
	(CALL-CONDITIONAL PG-FAULT PGF-R)	       ; IT.
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA SGENT3)  ;FOUND FIRST Q OF NEXT BLOCK
	(JUMP-GREATER-OR-EQUAL M-A A-QLBNDP SGENT4)
	(JUMP SGENT6)					;KEEP LOOKING

SGENT4	((A-SG-STATE) DPB M-ZERO (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) A-SG-STATE)
SGENT2
	((M-1) (A-CONSTANT (M-MEM-LOC M-K)))   		;RESTORE REGS
SGENT0	((OA-REG-LOW) DPB M-1 OAL-DEST A-ZERO)
	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)		;M-GARBAGE = 0@M
	(JUMP-GREATER-THAN-XCT-NEXT M-1 (A-CONSTANT (M-MEM-LOC M-ZR)) SGENT0)
       ((M-1) SUB M-1 (A-CONSTANT 1)) 

	((M-2) A-QCSTKG)				;CHANGE SG-STATE TO ACTIVE
	((VMA) SUB M-2 (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))
	((M-1) (A-CONSTANT (EVAL SG-STATE-ACTIVE)))
	((WRITE-MEMORY-DATA-START-WRITE M-2)
		DPB M-1 (LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
	(CALL-CONDITIONAL PG-FAULT PGF-W)
	((VMA-START-READ M-VMA-HELD) C-PDL-BUFFER-POINTER-POP)     ;RESTORE VMA AND MRD
	(CALL-CONDITIONAL PG-FAULT PGF-R)
	(POPJ-AFTER-NEXT				;PGF-x SMASHES M-3, DELAY LOADING
		(M-3) DPB M-ZERO (ALL-BUT-LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
       ((A-SG-STATE) M-2)

;; High-level stack group stuff.

;; Takes a stack group in M-2, returns the SG-STATE word in M-3,
;; and the state subfield in M-1.
GET-SG-STATE
	((VMA-START-READ) SUB M-2 (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))
	(CALL-CONDITIONAL PG-FAULT PGF-R)	;NO TRANSPORT SINCE IT'S A FIXNUM
	(POPJ-AFTER-NEXT 
	 (M-3) READ-MEMORY-DATA)
      ((M-1) (LISP-BYTE %%SG-ST-CURRENT-STATE) READ-MEMORY-DATA)

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
TRAP-ON-BAD-SG-STATE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ERROR
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ACTIVE
	(P-BIT R-BIT)				;SG-STATE-RESUMABLE
	(P-BIT R-BIT)				;SG-STATE-AWAITING-RETURN
	(P-BIT R-BIT)				;SG-STATE-INVOKE-CALL-ON-RETURN
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INTERRUPTED-DIRTY
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-ERROR-RECOVERY
	(P-BIT R-BIT)				;SG-STATE-AWAITING-CALL 
	(P-BIT R-BIT)				;SG-STATE-AWAITING-INITIAL-CALL
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-EXHAUSTED
(REPEAT 6 (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)
(LOCALITY I-MEM)

;;     This routine handles a stack group's being called as a function;
;; it is reached from the D-QMRCL dispatch.  Thus, M-A contains the new stack group.
;;  First, error checking: if both SG's are SAFE, then the called one has to be
;; in the AWAITING-CALL or AWAITING-INITIAL-CALL state.
SG-CALL	(CALL-XCT-NEXT GET-SG-STATE)        ;GET STATE OF SG GOING TO.  ALSO USE THIS BELOW.
       ((M-2) M-A)
	(DISPATCH (BYTE-FIELD 4 0) M-1 TRAP-ON-BAD-SG-STATE)
    (ERROR-TABLE WRONG-SG-STATE M-A)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-SAFE) M-3 SG-CALL-1)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)) SG-CALL-1)
	((M-2) A-SG-STATE)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-SAFE) M-2 SG-CALL-1)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-INITIAL-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE M-A)

SG-CALL-1		;SG-STATE OF SG GOING TO IN M-3 HERE.
;; Now assure that there is room for us in the PDL buffer.
	((M-B) SUB M-S A-AP)
	((M-B) (BYTE-FIELD 10. 0) M-B)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)  ;CLOBBERS M-2, M-3
       ((M-B) M-3)	;SAVE SG-STATE
	((M-AP) M-S)
;; Set up the argument list.
	((A-SG-TEM) A-V-NIL)
	(JUMP-EQUAL-XCT-NEXT M-ZERO A-NARGS SG-CALL-2)
       ((A-SG-TEM1) A-V-NIL)			; No args, list is NIL.
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT 1))		; List pointer to arg list.
	((A-SG-TEM1) M-K)
	((A-SG-TEM) C-PDL-BUFFER-INDEX)

;We enter here from *UNWIND-STACK, at the label XUWR2, slight hack.
SG-CALL-2
;; Leave old SG in awaiting-return, and don't swap if both of these bits are off.
	((M-2) (A-CONSTANT (EVAL SG-STATE-AWAITING-RETURN)))
	((M-C) A-SG-STATE)
	(JUMP-IF-BIT-SET (LISP-BYTE %%SG-ST-SWAP-SV-ON-CALL-OUT) M-C SG-CALL-3)
	(JUMP-IF-BIT-SET (LISP-BYTE %%SG-ST-SWAP-SV-OF-SG-THAT-CALLS-ME) M-B SG-CALL-3)
	((M-2) DPB (M-CONSTANT -1) (BYTE-FIELD 1 6) A-2)	;Set 100 bit; don't swap L-B-P
SG-CALL-3
	(CALL-XCT-NEXT SGLV)			; Leave!
       ((M-3) M-2)   ;M-3 has the new state, plus 100 bit says to not swap L-B-P.
;; Drops through.

;; More high-level stack group stuff.

;; Drops in.

SG-ENTER
; This is the common routine for activating a new stack group.  It takes the following
; things:  the new stack group itself in M-A, the transmitted value in A-SG-TEM,
; the argument list in A-SG-TEM1, and the argument count in A-NARGS.
	((A-SG-TEM2) A-QCSTKG)
	(CALL-XCT-NEXT SGENT)
       ((A-QCSTKG) M-A)
	((A-SG-PREVIOUS-STACK-GROUP) A-SG-TEM2)
SG-ENTER-1
	((A-SG-CALLING-ARGS-POINTER) A-SG-TEM1)
	((M-1) A-NARGS)
	((A-SG-CALLING-ARGS-NUMBER) DPB M-1 Q-POINTER	;A-NARGS is typeless.
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
;; Now dispatch to separate routines, based on what state the new SG is in.
;; SGENT left that state in M-3.  It only dispatches on the low four bits
;; of the state because there are only 10. states implemented, and although
;; the state is a 6 bit field, it would waste lot of D-MEM to make the table
;; that large.
	(DISPATCH (BYTE-FIELD 4 0) M-3 D-SG-ENTER)
       ((M-T) A-SG-TEM)				;SOMETIMES executes next!!

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-SG-ENTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ERROR
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ACTIVE
	(R-BIT INHIBIT-XCT-NEXT-BIT)		;SG-STATE-RESUMABLE
	(QMEX1)					;SG-STATE-AWAITING-RETURN
	(SG-ENTER-CALL INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INVOKE-CALL-ON-RETURN
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INTERRUPTED-DIRTY
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-ERROR-RECOVERY
	(R-BIT)					;SG-STATE-AWAITING-CALL 
	(SG-ENTER-CALL INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-INITIAL-CALL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-EXHAUSTED
(REPEAT 6 (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)
(LOCALITY I-MEM)

SG-ENTER-CALL
;; This is similar to QMRCL, but it never does a "leave".
	((M-K) PDL-BUFFER-POINTER)
	((M-K) SUB M-K A-IPMARK)		;Count arguments
	((A-NARGS) (BYTE-FIELD 7 0) M-K)
	((PDL-BUFFER-INDEX M-S) A-IPMARK)	;Get fef pointer pointer
	((M-A) C-PDL-BUFFER-INDEX)		;M-A := Function to call
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;Dispatch on data type
       (NO-OP)					;No leave neccesary.

;; More high-level stack group stuff.
;; This page contains STACK-GROUP-RETURN, and the SG-ENTER-NO-PREV entry-point.

     (MISC-INST-ENTRY STACK-GROUP-RETURN)
SG-RETURN
	((M-2) A-SG-STATE)
	(CALL-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%SG-ST-SAFE) M-2 TRAP)
    (ERROR-TABLE SG-RETURN-UNSAFE)
       ((A-SG-TEM1) A-V-NIL)			; Arg list (just in case...)
	(CALL-XCT-NEXT GET-SG-STATE)		; Get state of prev. SG in M-1
       ((M-2) A-SG-PREVIOUS-STACK-GROUP)
	(CALL-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)
	(CALL-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-INITIAL-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)
	(DISPATCH (BYTE-FIELD 4 0) M-1 TRAP-ON-BAD-SG-STATE)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)

SG-RETURN-1
	((A-SG-TEM) C-PDL-BUFFER-POINTER-POP)	; Get the value being transmitted.
	((M-3) (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)))
SG-RETURN-2  ; Entrypoint from QMXSG, which is where we exit the top of a stack group.
	(CALL SGLV)
	((M-A) A-SG-PREVIOUS-STACK-GROUP)
;; Falls into:


; This is like SG-ENTER (q.v.) except that it doesn't set up the PREVIOUS-STACK-GROUP
; at all, and so it takes no arg in A-SG-TEM2.
SG-ENTER-NO-PREV
	(CALL-XCT-NEXT SGENT)
       ((A-QCSTKG) M-A)
	(JUMP SG-ENTER-1)

;LOADING THE INITIAL MAP.
; THE FIRST STEP IS TO ADDRESS THE SYSTEM COMMUNICATION AREA AND FIND
; OUT MUCH VIRTUAL MEMORY SHOULD BE WIRED AND STRAIGHT-MAPPED (%SYS-COM-WIRED-SIZE).
; THE MAP IS THEN SET UP FOR THOSE PAGES.  THE REMAINDER OF VIRTUAL
; SPACE IS MADE "FIRST LEVEL MAP NOT SET UP."  STUFF WILL THEN BE PICKED
; UP OUT OF THE PAGE HASH TABLE.  IT IS ALSO NECESSARY TO SET UP THE
; LAST BLOCK OF LEVEL 2 MAP TO "FIRST LEVEL MAP NOT SET UP (ZERO)".

INITIAL-MAP					;FIRST SET ALL LEVEL 1 MAP TO 37
	((VMA) DPB (M-CONSTANT -1) MAP-FIRST-LEVEL-MAP A-ZERO)
INIMAP1	((WRITE-MEMORY-DATA-WRITE-MAP) VMA)
	((VMA) ADD VMA (A-CONSTANT 10000))
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 23.) VMA INIMAP1)
						;THEN ADDRESS SYSTEM COMMUNICATION AREA
	((WRITE-MEMORY-DATA-WRITE-MAP) DPB (M-CONSTANT -1)
		(BYTE-FIELD 1 7) (A-CONSTANT 600000001))	;-> LOCATION 200
	((VMA-START-READ) SELECTIVE-DEPOSIT VMA
		VMA-PAGE-ADDR-PART (A-CONSTANT (EVAL %SYS-COM-WIRED-SIZE)))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((M-A) Q-POINTER READ-MEMORY-DATA)	;SAVE NUMBER OF WIRED WORDS
						;THEN ZERO LAST BLOCK OF LEVEL 2 MAP
INIMAP2	((WRITE-MEMORY-DATA-WRITE-MAP) (A-CONSTANT 1))
	((VMA) ADD VMA (A-CONSTANT 200))
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 12.) VMA INIMAP2)
						;NOW SET UP WIRED LEVEL 1 MAP
	((M-C VMA) A-ZERO)
INIMAP7	((WRITE-MEMORY-DATA-WRITE-MAP) M-C)
	((VMA) ADD VMA (A-CONSTANT 10000))
	(JUMP-LESS-THAN-XCT-NEXT VMA A-A INIMAP7)
       ((M-C) ADD M-C (A-CONSTANT (BYTE-VALUE MAP-FIRST-LEVEL-MAP 1)))
	((A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT) MAP-FIRST-LEVEL-MAP M-C) ;FIRST NON-WIRED
						;THEN SET UP WIRED LEVEL 2 MAP
	((VMA) (A-CONSTANT 600000001))		;2ND LEVEL MAP 0->0 RW, RW
	((M-B) ADD VMA A-A)			;SET UP LOOP LIMIT VALUE
INIMAP3	((WRITE-MEMORY-DATA-WRITE-MAP) VMA)
	((VMA) ADD VMA (A-CONSTANT 200))	;ADV PHY + VIR ADDRESSES
	(JUMP-LESS-THAN VMA A-B INIMAP3)	;LOOP UNTIL DONE ALL WIRED ADDRESSES

INIM3A	((M-1) (BYTE-FIELD 5 7) VMA)		;IF NOT AT EVEN 1ST LVL MAP BOUNDARY...
	(JUMP-EQUAL M-1 A-ZERO INIM3B)		; INITIALIZE REST OF 2ND LVL BLOCK TO
	((WRITE-MEMORY-DATA-WRITE-MAP) DPB	; SECOND LVL MAP NOT SET UP.
	   (M-CONSTANT -1) MAP-STATUS-CODE-LOW-BIT (A-CONSTANT 1))
	(JUMP-XCT-NEXT INIM3A)
       ((VMA) ADD VMA (A-CONSTANT 200))
INIM3B
						;INITIALIZE REVERSE 1ST LVL MAP
	((A-SECOND-LEVEL-MAP-REUSE-POINTER) A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT)
					;REVERSE 1ST LVL MAP LOCS 40-77
	((WRITE-MEMORY-DATA) M-ZERO)	;VALUE TO GO IN WIRED ENTRIES
	((VMA) XOR (M-CONSTANT 40)
		 (A-CONSTANT 277))	;237 ;A-V-SYSTEM-COMMUNICATIONS-AREA IS 200
INIMAP5	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CALL-CONDITIONAL PG-FAULT ILLOP)
	((WRITE-MEMORY-DATA) ADD WRITE-MEMORY-DATA (A-CONSTANT 10000))
	(JUMP-LESS-THAN WRITE-MEMORY-DATA A-A INIMAP6)	;JUMP IF STILL WIRED
	((M-A WRITE-MEMORY-DATA) (M-CONSTANT -1))	;REST OF ENTRYS ARE -1.
INIMAP6	(JUMP-LESS-THAN VMA (A-CONSTANT 277) INIMAP5)
	(POPJ)

))
;;---					T H E   E N D
