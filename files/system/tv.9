.SBTTL MACROS AND CONDITIONAL ASSEMBLY

;AI PDP-11 TV CONSOLE PROGRAM
;	USER WHO-LINE VARIABLES CODE ADDED 7/28/75 BY GLS

FONTSW==1	;COMPILE FONTS
FONTMS==0	;USE MACROS TO COMPILE FONTS

.IIF E FONTSW,.TITLE TV NOFONTS

.IF NE FONTSW
.TITLE TV
.IF NE FONTMS
.NLIST	;WE'RE ONLY INTERESTED IN FONTS
.IF1
.PRINT /THIS ASSEMBLY WILL TAKE FOREVER!
/
.ENDC	;.IF1
.ENDC	;.IF NE FONTMS
.ENDC	;.IF NE FONTSW

.MACRO	PUSH A
.NLIST
	MOV	A,-(SP)
.LIST
.ENDM

.MACRO	POP A
.NLIST
	MOV	(SP)+,A
.LIST
.ENDM

.MACRO REPORT TEXT,NUM
.NLIST
.IF2
.LIST
.PRINT /TEXT'NUM
/
.NLIST
.ENDC
.LIST
.ENDM

.MACRO CHROFF
.NLIST
	MOVB	PS,-(SP)
	MOVB	#LKLVL,PS
.LIST
.ENDM

.MACRO CHRON
.NLIST
	MOVB	(SP)+,PS
.LIST
.ENDM

.MACRO BLKOFF A
.NLIST
	INCB	BLKSWT(A)
.LIST
.ENDM

.MACRO BLKON A
.NLIST
	DECB	BLKSWT(A)
	BGE	.+4
	BPT
.LIST
.ENDM

.MACRO TENWRD
.NLIST
.IIF NE .&3,.=<.&177774>+4
.LIST
.ENDM

.MACRO CHECK TAG,LENGTH
.NLIST
.IF NE .-<TAG>-<LENGTH>
.ERROR TAG WRONG LENGTH
.ENDC
.EVEN
.LIST
.ENDM

.MACRO TYPOUT A
.NLIST
	JSR	PC,OUTSTR
	.ASCIZ A
	.EVEN
.LIST
.ENDM

.MACRO DECTYPE	NUM
.NLIST
	MOV	NUM,A
	JSR	PC,DECPNT
.LIST
.ENDM

.MACRO	OCTYPE	NUM
.NLIST
	MOV	NUM,A
	JSR	PC,OCTPNT
.LIST
.ENDM

.MACRO ZAPFLG	FLAG
.NLIST
%COMPAT==0
	MOV	PC,FLAG
%COMPAT==1
.LIST
.ENDM

.MACRO CONC A,B,C,D,E,F,G,H,I
A'B'C'D'E'F'G'H'I
.ENDM

.MACRO LCONC A,B,C,D,E,F,G,H,I
.LIST
A'B'C'D'E'F'G'H'I
.XLIST
.ENDM

.MACRO PRGMAP ORG,END,DESC,EXTRA,EXTRA1
LCONC <;>,\<ORG>,<	>,\<END-ORG>,<	>,<DESC>,<EXTRA>,<EXTRA1>
.ENDM
.EJECT
;PROGRAM MAP

;	SIZE	DESCRIPTION
.NLIST
.IF2
PRGMAP 0,PDLORG,TRAP VECTORS
PRGMAP PDLORG,KBDBUF,PUSH DOWN LIST
PRGMAP KBDBUF,GO,KBD BUFFER
PRGMAP GO,XTAB,PROGRAM
PRGMAP XTAB,FNTORG,KEYBOARD TRANSLATION TABLE
PRGMAP FNTORG,VARORG,FONT DEFINITION
PRGMAP VARORG,MISORG,LINE EDITOR/PAGE PRINTER VARIABLES
PRGMAP MISORG,PATCH,MISCELLANEOUS TABLES AND VARIABLES
PRGMAP PATCH,LEBUFS,PATCH AREA
PRGMAP LEBUFS,RUGSA,FREE STORAGE (,\NLBUFS,< BUFFERS)>
.ENDC
.LIST
.SBTTL HOW IT WORKS
.REPT 0
channel header pointer (location 40, read only)

	ADDRESS(channel header area)
	ADDRESS(pointer area)
	I/O version number
	source file version number
	0	always 0
	INITED	non-zero indicates PDP-11 is running ok(can be cleared by PDP-10)
	0	always 0
	GDOWN	used as flag by PDP-10 to acknowledge clear of INITED

channel header area (aligned on PDP-10 word)

    KBD channel:
	KBDFLG	cleared by 10/set by 11 (chain of activated KBD buffers)
	0	allows PDP-10 to do SKIPN for activation test
    DPY channel: (1 per console)
	DPYCHN	buffer assigned to channel, if zero then DPY channel is closed
	DPYKBD	.BYTE KBD#, DPY# (377 for either implies not assigned)
    KBD flags: (1 per console)
	ECOFLG	Set by PDP-10.  Next time DPYBUF is empty clear ECOFLG
		and put flag on KBD ring to signal this condition
	CHNCLS	if -1, log this guy out!!!!
    WHO flags: (1 per console)
	WHOLIN	who line variables for this console
	WHOUSR	-1=>user who line, 0=>system who line

format of KBD buffer (aligned on PDP-10 word)

	KBDSTS	negative=>-(data byte count), 0=>free
	0
	KBDRNG	next KBD buffer associated with this KBD
	KBDLST	next buffer on activated list (0=>end of chain)
	KBDCHN	keyboard channel
	0	not used
	KBDATA	key board data area (1 PDP-11 word/character)

format of DPY buffer (aligned on PDP-10 word)

	DPY10B	word PDP-10 is hacking (used only for initailization)
	DPY11B	word PDP-11 is hacking
	DPYPP	page printer variables
	DPYLGL	last legal address in this buffer
	DPYSIZ	size of data area in bytes
	0	not used
	DPYATA	display data area (1 PDP-11 word/character)

format of pointer area (aligned on PDP-10 word)

	ADDRESS(system who line variables)
	ADDRESS(PDP-10/PDP-11 communication area)
	TENWHO	-1=>PDP-10 should update who lines
	TENWH1	pads TENWHO

Notes:

1.	All addresses and pointers are in PDP-11 address space.

2.	KBD buffers are ringed two per channel.  While the PDP-10 is
	emptying one, the PDP-11 can fill the other.

3.	There is only one DPY buffer per channel.  When the buffer is filled
	with negative numbers, it is free.  When the PDP-10 writes a positive
	number in the current word: then the PDP-11 processes the data in that
	word, sets that word to a negative number, and advances to the next word.
WHO LINE VARIABLES

SYSTEM WHO LINE (ALIGNED ON PDP-10 WORD)
    ITSTDP	# total # dpy's (read only for PDP-10)
    ITSFDP	# free  dpys (read only for PDP-10)
    ITSVER	ITS version #
    ITSJOB	total jobs
    ITSCOR	total core
    ITSRU	runnable users
    ITSWBJ	# jobs swap blocked
    ITSJWP	# jobs waiting for pages
    ITSTRC	total runable core
    ITSCFU	core available for users
    ITSDAT	date [byte (7) year (4) month (5) day]
    ITSDBG	system debug flag
    ITSTIM	time of day (# half seconds since midnight) aligned on PDP-10 word
    ITSTI1	low order of time
    ITSUSR	total number of users

USER WHO LINE (ALIGNED ON PDP-10 WORD)
    WHJOB	job #, -1=>who line not in use
    WHJOB1	if negative then clear who line
    WHMODE	mode	0=>follow keyboard
			1=>freeze
			2=>next higher (when PDP-10 sees this state, it searches
			   user variables for next higher job index number with same
			   uname.  When it finds it, it stores the number in job #
			   and changes mode to 1
			3=>next lower
    WHMOD1	pads WHMODE
    WHUNAM	uname in sixbit (left 18 bits in first two words, right in next two)
    WHUNM1
    WHUNM2
    WHUNM3
    WHJNAM	jname in sixbit
    WHJNM1
    WHJNM2
    WHJNM3
    WHSNAM	sname in sixbit
    WHSNM1
    WHSNM2
    WHSNM3
    WHSTAT	status in sixbit, 0=>job does not exist
    WHSTA1
    WHSTA2
    WHSTA3
    WHJ%RT	job % run time
    WHJTRT	job total run time (in tenth's of seconds)
    WHT%RT	tree % run time
    WHTPAG	job total pages

NOTE:	The PDP-11 will not update who lines until it sees that ITSTIM
	has changed.
PDP-10/PDP-11 COMMAND CHANNEL

    CMDFLG	aligned on PDP-10
		0=>buffer is free (PDP-10 can write CMDBUF)
		positive=>command # from PDP-10 (PDP-11 can write CMDBUF)
		negative=>affirmative reply from PDP-11 (0=>command failed)
		PDP-10 can read CMDBUF, then must zero CMDFLG
    CMDFL1	always 0
    CMDBUF	each arg takes 4 bytes (1 PDP-10 word)

    PDP-10/PDP-11 COMMANDS

	1	video switch
		arg1:	video switch input #  (set by PDP-10)
		arg2:	video switch output # ( "  "   "  " )

	2	reserve DPY
		arg1:	DPY reserved (set by PDP-11)

	3	free DPY
		arg1:	DPY to free (set by PDP-10)

	4	read video switch
		arg1:	< 0 for default setting, > 0 for current setting (set by PDP-10)
			1=>tty chnl, 2=>KBD, 3=>video switch output
		arg2:	# described by arg1 (set by PDP-10)
		arg3:	input (set by PDP-11)
		arg4:	input (set by PDP-11)
		arg5:	output(set by PDP-11)

	5	audio switch
		arg1:	audio switch input #  (set by PDP-10)
		arg2:	audio switch output # (set by PDP-10)

	6	read audio switch
		arg1:	< 0 for default setting, > 0 for current setting (set by PDP-10)
			1=>tty chnl, 2=>KBD, 3=>audio switch output
		arg2:	# described by arg1 (set by PDP-10)
		arg3:	input (set by PDP-11)
		arg4:	output(set by PDP-11)

;other 10-11 commuincation issues ..

;go down resetting video switch vs not
;PDP-11 indicates it has reset video switch
	;(PDP-10 then detaches all jobs with tv ttys)
;console scroll register	6/23/74

CSA==157776		;selects where video scan starts in video buffer

__|_____|_____|_____|_____|_____|
15    1211			|
|  3  |1|           12		|
|_____|_|_______________________|
   |   |	     |
   |   |	     |----------------->scroll offset (start video scan at n*4 PDP-11 words from TVLO)
   |   |
   |   |------------------------------->black on white bit (1=>black on white)
   |
   |----------------------------------->not used



;console register		6/24/74

CREG==164044		;selects video buffer memory

__|_____|_____|_____|_____|_____|
15              7		|
|	8	|	8	|
|_______________|_______________|
	|		|
	|		|-------------->console # (TVLO-TVHI on unibus is video bit map)
	|
	|------------------------------>ALU function

;video switch	4/17/74

VSW==164060		;sets video switch

__|_____|_____|_____|_____|_____|
15  13    10    7       3       |
| 2 |  3  |  3  |   4   |   4   |
|___|_____|_____|_______|_______|
  |    |     |      |       |
  |    |     |      |       |---------->video source
  |    |     |      |
  |    |     |      |------------------>not used
  |    |     |
  |    |     |------------------------->|	      |card section
  |    |				|switch output|
  |    |------------------------------->|	      |card select
  |
  |------------------------------------>not used
;keyboard multiplexor	3/15/74

KBDPC==340	;interupt vector
KBDLVL==5_7	;interupts on level 5

KMS==164050	;keyborad status

__|_____|_____|_____|_____|_____|
151413121110    7 6 5 4     1   |
|1|1|1|1|1|  3  |1|1|1|  3  | 2 |
|_|_|_|_|_|_____|_|_|_|_____|___|
 | | | | |  |    | | |   |    |
 | | | | |  |    | | |   |    |------>KMA extension (bits 17 and 16)
 | | | | |  |    | | |   |
 | | | | |  |    | | |   |----------->not used
 | | | | |  |    | | |
 | | | | |  |    | | |--------------->interupt enable
 | | | | |  |    | |
 | | | | |  |    | |----------------->direct memory access enable
 | | | | |  |    |
 | | | | |  |    |------------------->waiting to hack memory
 | | | | |  |
 | | | | |  |------------------------>not used
 | | | | |
 | | | | |--------------------------->buzz the 9th floor door
 | | | |
 | | | |----------------------------->generate copy from second source
 | | |
 | | |------------------------------->generate copy from first source
 | |
 | |--------------------------------->ready line
 |
 |----------------------------------->waiting to interupt

KMA==165052	;keyboard memory address register

__|_____|_____|_____|_____|_____|
15		  7	    1   |
|         9       |    5    | 2 |
|_________________|_________|___|
          |            |      |
          |            |      |----->always 0
	  |	       |
	  |	       |------------>binary counter (overflow lost)
	  |
	  |------------------------->buffer origin
;keyboard multiplexor	3/15/74
;format of data written into memory (each record is two words)

;first word

__|_____|_____|_____|_____|_____|
151413  11  9   7   5           |
|1|1| 2 | 2 | 2 | 2 |     6     |
|_|_|___|___|___|___|___________|
 | |  |   |   |   |	  |
 | |  |   |   |   |       |--------->key struck
 | |  |   |   |   |
 | |  |   |   |   |----------------->shift (7-left, 6-right)
 | |  |   |   |
 | |  |   |   |--------------------->top (9-left, 8-right)
 | |  |   |
 | |  |   |------------------------->control (11-left, 10-right)
 | |  |
 | |  |----------------------------->meta (13-left, 12-right)
 | |
 | |-------------------------------->shift lock
 |
 |---------------------------------->always 1

;second word

__|_____|_____|_____|_____|_____|
15  13          7               |
| 2 |     6     |       8       |
|___|___________|_______________|
  |	  |		|
  |	  |		|----------->high order bits of character (ignored)
  |	  |
  |	  |------------------------->console number
  |
  |--------------------------------->always 0

.ENDR

;CHARACTER FORMAT WRITTEN BY KBD MULTIPLEXOR

RCHAR==177700	;6 BITS FOR KEY STRUCK
RSHBIT==300	;SHIFT BITS
RTPBIT==1400	;TOP BITS
RCLBIT==6000	;CONTROL BITS
RMTBIT==30000	;META BITS
RSLBIT==40000	;SHIFT LOCK
RXTRA==100000	;UNUSED BITS

;XTAB BITS USED FOR XTAB LOOK UP

XTPBIT==400	;TOP
XSLBIT==200	;SHIFT LOCK
XSHBIT==100	;SHIFT

;POSITION OF META BITS, ASCII COMPATIBLE

ACTBIT==SNB		;CAUSES CHARACTER TO ACT AS ACTIVATOR
ACLBIT==200		;CONTROL
AMTBIT==400		;META
ASHBIT==XSHBIT_3	;SHIFT
ASLBIT==XSLBIT_3	;SHIFT LOCK
ATPBIT==XTPBIT_3	;TOP
ACMBIT==AMTBIT+ACLBIT	;CONTROL AND META TOGETHER
.SBTTL ASSIGNMENTS

;REGISTER ASSIGNMENTS

A=%0		;ASCII CHARACTER
B=%1		;META BITS
C=%2		;C, T, AND TT ARE TEMPORARIES
T=%3
TT=%4
U=%5		;LINE EDITOR OR PAGE PRINTER
SP=%6
PC=%7

;GEOMETRY

BITPL==1100		;BITS PER LINE
NLINS==706		;LINES ON SCREEN
BYTPL==BITPL/10		;BYTES PER LINE
WRDPL==BYTPL/2		;WORDS PER LINE

CHRWD==6		;CHARACTER WIDTH ON TEXT LINE
GRIDWD==5		;WIDTH OF CHARACTER GRID
CHRHT==12		;CHARACTER HEIGHT
CHRVSP==2		;BLANK RASTER LINES BETWEEN CHARACTER LINES
LINHT==CHRHT+CHRVSP	;CHRACTER LINE HEIGHT
CHRPL==BITPL/CHRWD	;CHARACTERS PER LINE
CHRLN==NLINS/LINHT	;CHARACTER LINES ON SCREEN

;MEMORY MAP

NXMPC==   4		;BUS ERROR VECTOR
NXMPSW==  6
RESPC==  10		;RESERVED INTRUCTION VECTOR
RESPSW== 12
BPTPC==  14		;BREAK POINT VECTOR
BPTPSW== 16
IOTPC==  20		;IOT VECTOR
IOTPSW== 22
PWRPC==  24		;POWER FAIL TRAP VECTOR
PWRPSW== 26
EMTPC==  30		;EMULATE TRAP VECTOR
EMTPSW== 32
TRPPC==  34		;TRAP INSTRUCTION VECTOR
TRPPSW== 36
TYIPC==  60		;TTY INPUT INTERUPT VECTOR
TYIPSW== 62
LKPC==  100		;LINE CLOCK INTERUPT VECTOR
LKPSW== 102
KLIPC== 320		;KL11 INPUT INTERUPT VECTOR
KLIPSW==322
KBDPC== 340		;KEYBORAD MULTIPLEXOR INTERUPT VECTOR
KBDPSW==342

PDLORG==400			;ORIGIN OF PUSH DOWN LIST
TVLO=60000			;ORIGIN OF DISPLAY MEMORY
TVFENCE=TVHI-<LINHT*BYTPL>	;DON'T START CHARACTER LINE PAST THIS POINT
TVHI=TVLO+<BYTPL*NLINS>-2	;HIGHEST LEGAL DISPLAY ADDRESS
CSA=157776			;DISPLAY REFRESH STARTING ADDRESS (STARTS AT 0)

CREG==  164044		;UNIBUS CONSOLE REGISTER ADDRESS
CALU==  164045		;CONSOLE REGISTER LOGICAL FUNCTION ADDR
KMS==   164050		;KEYBOARD MULTIPLEXOR STATUS
KMA==   164052		;KEYBOARD MULTIPLEXOR MEMORY ADDRESS
VSW==   164060		;VIDEO SWITCH
ASW==   170670		;AUDIO SWITCH
KLIS==  174000		;KL11 INPUT STATUS
KLIB==  174002		;KL11 INPUT BUFFER
KLOS==  174004		;KL11 OUTPUT STATUS
KLOB==  174006		;KL11 OUTPUT BUFFER
DIV==   177300		;EAE GOODIES
AC==    177302
MQ==    177304
MUL==   177306
SC==    177310
SR==    177311
NOR==   177312
LSH==   177314
ASH==   177316
LKS==   177546		;LINE CLOCK STATUS
TKS==   177560		;TTY KEYBOARD STATUS
TKB==   177562		;TTY KEYBOARD BUFFER
TPS==   177564		;TTY PRINTER STATUS
TPB==   177566		;TTY PRINTER BUFFER
CSR==   177570		;CONSOLE SWITCH REGISTER
PS==    177776		;PROCESSOR STATUS REGISTER

;TEN/11 COMMUNICATIONS AREA

CHAP==40		;CHANNEL HEADER AREA POINTER
POINTP==42		;POINTER TO POINTER AREA
CIOVER==44		;HOLDS I/O VERSION FOR PDP-10 TO LOOK AT
CVERSE==46		;ASSEMBLY VERSION FOR PDP-10
	;50		;ALWAYS 0
INITED==52		;INITED FLAG, SET BY 11 CLEARED BY 10
	;54		;ALWAYS 0
GDOWN==56		;INTERLOCKS WITH INITED, CLEARED BY 11 SET BY 10

;CONSOLE REGISTER FUNCTIONS

CSETC==0
CNOR==1
CANDC==2
CSETZ==3
CNAND==4
CCOMP==5
CXOR==6
CANCSD==7
CEQV==11
CORCSD==10
CSAME==12
CAND==13
CORSCD==13
CSETO==14
CIOR==16
CSET==17

;INTERUPT LEVELS

KBDLVL==5_5	;KEYBOARD MULTIPLEXOR
LKLVL==6_5	;LINE CLOCK
ERRLVL==7_5	;PROCESSOR ERRORS

;MISCELLANEOUS ASSIGNMENTS

IOVER==2	;I/O VERSION FOR ITS
PDL==400	;PUSH DOWN LIST SIZE
MAXKBD==40	;MAXIMUM # OF KEYBOARDS
MAXTV==12.	;MAX NUMBER OF TV DISPLAYS
MAXPP==MAXTV	;MAXIMUM # PAGE PRINTERS
MAXLE==MAXPP	;MAXIMUM # LINE EDITORS
MAXBLK==MAXTV	;MAXIMUM # OF BLINKERS
MAXASI==20	;AUDIO SWITCH INPUTS
MAXASO==100	;AUDIO SWITCH OUTPUTS
ASWSEC==1	;# AUDIO SWITCH SECTIONS
ASWINC==0	;INCREMENTS AUDIO SWITCH SECTION #
MAXVSI==20	;VIDEO SWITCH OUTPUTS
MAXVSO==40	;VIDEO SWITCH INPUTS
VSWSEC==2	;# VIDEO SWITCH SECTIONS
VSWINC==MAXVSO_10	;INCREMENTS VIDEO SWITCH SECTION NUMBER
QPYVSW==27	;VIDEO SWITCH OUTPUT FOR TEKTRONIX VIDEO HARD COPY UNIT
QPTIME==8.*60.	;8 SECONDS BETWEEN COPIES
QPYKMS==20000	;GENERATE COPY FROM FIRST SOURCE (IN KEYBOARD STATUS, NATURALLY)
BUZKMS==10000	;BUZZ DOOR (ALSO IN KEYBOARD STATUS)
BUZTIM==3*60.	;LEAVE THE DOOR BUZZING FOR 3 SECONDS
MAXBEL==4	;MAXIMUM # OF BELLS ALLOWED
GLITIM==60.*60.*2	;# CLOCK TICKS BETWEEN GLITCHES ON CONSOLE FREE DPY
NCQSLT==100	;# CLOCK QUEUE SLOTS
KBDBFL==200	;SIZE OF KEYBOARD BUFFER
LBLEN==200	;LINE BUFFER SIZE (BETTER BE DIVISIBLE BY 4)
LBCHRS==LBLEN/2	;# CHARACTERS IN LINE EDITOR BUFFER
BOWBIT==10000	;CSA BLACK ON WHITE BIT
SAMSK==BOWBIT-1	;MASK FOR SCROLL REGISTER
CSAMSK==170000	;COMPLEMENT OF SAMSK
BLKTIM==15.	;CLOCK TICKS BETWEEN BLINKS
SNB==100000	;SIGN BIT
PATL==400	;SIZE OF PATCH AREA
CMDARG==10	;# ARGUMENTS WHICH WILL FIT INTO PDP-10/PDP-11 COMMAND BUFFER
RUGSA==57100	;STARTING ADDRESS OF RUG
...==0
....==0

.ABS
.XCREF	A,B,C,T,TT,U,SP,PC,...,....
.SBTTL GO CODE, PDL, AND KBD BUFFER

;PUSH DOWN LIST AND KEYBOARD BUFFER

.=PDLORG+PDL
.IIF NE .&177,.=<.&177600>+200	;ALIGN ON 200 BYTE BOUNDARY
PDBUF==.

KBDBUF:
.=.+KBDBFL
KBDEND==.

REPORT GO=,\GO

GO:	RESET			;IN THE PRIVACY OF YOUR OWN HOME
	CLR	PS
	MOV	#PDBUF,SP	;SET UP PUSH DOWN POINTER
	MOV	#ERRLVL,C	;ALL PROCESSOR TRAPS GO ON 7
	MOV	#NXMPC,B
	MOV	#NXMBRK,(B)+	;BUS TIME OUT
	MOV	C,(B)+
	MOV	#RESBRK,(B)+	;RESERVED INSTRUCTION
	MOV	C,(B)+
	MOV	(B),T		;BREAK POINT
	BNE	.+6
	MOV	#BPTBRK,T
	MOV	T,(B)+
	MOV	C,(B)+
	MOV	#IOTBRK,(B)+	;IOT TRAP
	MOV	C,(B)+
	MOV	#PWRBRK,(B)+	;POWER FAILURE
	MOV	C,(B)+
	MOV	#EMTBRK,(B)+	;EMT
	MOV	C,(B)+
	MOV	#TRPBRK,(B)+	;"TRAP" TRAP (LEV 7)
	MOV	C,(B)+
	MOV	#CHA,(B)+	;CHANNEL HEADER AREA
	MOV	#POINTA,(B)+	;POINTER AREA POINTER
	MOV	#IOVER,(B)+	;I/O VERSION
	MOV	VERSE,(B)+	;ASSEMBLY VERSION
	CLR	(B)+		;INITED
	CLR	(B)+
	MOV	C,(B)+		;NON-ZERO SUFFICES
	MOV	C,(B)+		;GDOWN
	MOV	#CLKBRK,LKPC	;CLOCK
	MOV	#LKLVL,LKPSW
	MOV	#KBDBRK,KBDPC	;KBD
	MOV	#KBDLVL,KBDPSW

;FALLS THROUGH
;INITIALIZE VARIBLES	FALLS THROUGH

	JSR	PC,INIT

;ENABLE INTERUPTS

	MOV	#100,LKS	;CLOCK
	MOV	#KBDBUF,KMA
	MOV	#KBDBUF,OLDKMA
	MOV	#140,KMS	;KEYBORAD MULTIPLEXOR
	MOV	#-1,INITED

;THE MAIN LOOP

MAIN:	MOV	#MAXPP-1,U		;CHANNEL
	CMP	WHOTIM,ITSTI1		;TIME FOR WHO LINES?
	BEQ	MAIN1
	ZAPFLG	WHOFLG			;TRIGGER WHO LINES
MAIN1:	TST	INITED
	BEQ	GO			;RESET THE WORLD
	TST	CSR
	BLT	GOZRUG
	JSR	PC,DPYDPY
	MOV	CMDFLG,A		;PDP-10 GIVING COMMAND?
	BLE	MAIN2
	PUSH	U
	JSR	PC,TENCMD		;PROCESS THE COMMAND
	POP	U
MAIN2:	DEC	U
	BGE	MAIN1			;CYCLED THROUGH ALL CHANNELS?
	CLR	WHOFLG			;TURN OFF WHO LINES
	BR	MAIN

GOZRUG:	BPT
.SBTTL INITIALIZATION

INIT:	CLR	TICKS
	CLR	TICKS1
	CLR	KBDFLG
	CLR	KBDFLG+2
	CLR	KBDACT
	CLR	KBDLAST
	CLR	CMDFLG
	CLR	CMDFLG+2
	CLR	WHOTIM
	CLR	ITSTI1
	CLR	WHOFLG
	CLR	TENWHO
	CLR	QPYSWT
	CLR	BUZSWT
	JSR	PC,REVSW		;RESET VIDEO SWITCH

	MOV	#LEBUFS,U		;INITIALIZE FREE STORAGE
	MOV	U,FSP
	MOV	#NLBUFS-1,B
INIT6:	MOV	U,TT
	ADD	#<LHLEN+LBLEN>,TT
	MOV	TT,LHFS(U)
	MOV	TT,U
	DEC	B
	BGT	INIT6
	CLR	LHFS(U)			;END OF LIST

	MOV	#-1,A
	MOV	#PPUVAR,U		;MARK ALL PAGE PRINTERS FREE
INIT3:	MOV	A,PPCHN(U)
	ADD	#PPLEN,U
	CMP	#PPUEND,U
	BHI	INIT3

	MOV	#LEUVAR,U		;MARK ALL LINE EDITORS FREE
INIT4:	MOV	A,LEKBD(U)
	ADD	#LELEN,U
	CMP	#LEUEND,U
	BHI	INIT4

	CLR	BLINK
	MOV	#BLINKS,A
	MOV	#BELCNT,C
	MOV	#-1,T			;SET UP BELL COUNTS
	MOV	#MAXTV-1,B		;CLEAR ALL BLINKING SWITCHES
	CLR	ITSTDP
INIT5:	CLRB	BLKSWT(B)
	TSTB	DPYUSE(B)
	BLT	INIT5A
	INC	ITSTDP
	CLRB	DPYUSE(B)
INIT5A:	CLR	(A)+
	MOV	T,(C)+
	DEC	B
	BGE	INIT5
	MOV	ITSTDP,ITSFDP		;# FREE DPY'S

	MOV	#MAXBLK,B		;RESET ALL BLINKERS
	MOV	#BLKVAR,U
INIT7:	MOV	U,TT
	ADD	#BLLEN,TT
	MOV	TT,BLNEXT(U)
	CLRB	BLON(U)
	MOV	TT,U
	DEC	B
	BGT	INIT7
	CLR	<BLNEXT-BLLEN>(U)

	MOV	#MAXPP-1,A
	CLR	B
	MOV	#WHVARS,C
INIT2:	JSR	PC,CHNSET		;SET UP THAT CHANNEL
	CLRB	CHNUSE(A)
	MOV	U,DPYCHN(B)
	MOV	#-1,DPYKBD(B)
	MOV	#-1,CHNCLS(B)
	CLR	ECOFLG(B)
	MOV	C,WHOLIN(B)
	MOV	#-1,(C)
	ADD	#WHLEN,C
	CMP	(B)+,(B)+
	DEC	A
	BGE	INIT2			;MORE DPY CHANNELS TO SET UP?

	JSR	PC,PPCONS		;GET PAGE PRINTER FOR FREE MESSAGE
	BNE	.+4
	BPT
	CLR	PPCHN(U)		;PAGE PRINTER IN USE (USING CHANNEL 0)
	INCB	CHNUSE
	INCB	CHNUSE			;MAKE SURE CHANNEL 0 IS NEVER RETURNED
	MOV	#377,CHNCLS		;CHANNEL OPEN WITH ILLEGAL KBD
	MOV	WHOLIN,TT		;WANT SYSTEM WHO LINE ON CONSOLE FREE DPY
	MOV	#NWHCMD,WHMODE(TT)
	MOV	DPYCHN,TT
	MOV	U,DPYPP(TT)		;USING THIS PAGE PRINTER
	MOV	U,MSGPP			;PAGE PRINTER PRINTING FREE MESSAGE
	JSR	PC,DPCONS		;GET A DPY TO PRINT ON
	BGE	.+4
	BPT				;NO PAGE PRINTER AVAILABLE
	MOV	TT,DPYFRE		;REMEMBER # OF DPY USED FOR FREE SCREENS.
	INCB	DPYUSE(TT)		;MAKE SURE THIS DPY IS NEVER GOBBLED
	MOVB	TT,CREG			;SET UP CONSOLE REGEISTER FOR PRINT
	MOVB	TT,PPCREG(U)
	JSR	PC,CLRSCR		;CLEAR SCREEN
	CLR	CSA
	TYPOUT	</TV's ready, but not in operation
/>
	MOVB	PPCREG(U),C		;DPY
	ASL	C
	MOV	#MAXVSO-1,B		;SWITCH TO ALL OUTPUTS
INIT1:	MOV	DPYVSW(C),TT		;VIDEO SWITCH INPUT
	MOV	B,T			;SWITCH OUTPUT
	JSR	PC,VSWIT
	DEC	B
	BGE	INIT1

	MOV	#MAXKBD,A		;CLEAR KBDLE
	CLR	B
INIT8:	CLR	KBDLE(B)
	TST	(B)+
	DEC	A
	BGT	INIT8

	MOV	#NCQSLT-1,C		;INITIALIZE CLOCK QUEUE
	CLR	CLOCKQ
	MOV	#CQUEUE,A
	MOV	A,CLOCKF
INIT9:	MOV	A,B
	ADD	#CQLEN,B
	MOV	B,(A)
	MOV	B,A
	DEC	C
	BGT	INIT9
	CLR	(A)
	MOVB	#CSET,CALU
	MOV	CREG,T			;SEED QUEUE WITH GLITCH CONSOLE FREE
	JSR	TT,ADQUE
		GLITIM
		MSGLIT
	RTS	PC
.SBTTL MAIN PROGRAM LEVEL ROUTINES

;HERE TO GET CHARACTER FROM OPEN CHANNEL
;LOOPS UNTIL NO MORE CHARACTERS AVAILABLE

DPYDPY:	PUSH	U
DPYDP1:	ASL	U
	ASL	U
	MOV	U,B			;FOR DPYDON
	MOV	DPYCHN(U),U
	JSR	PC,GETCHR
	BLT	DPYDON			;DID WE GET A CHARACTER?
	MOV	U,C			;FOR SETCUR
	MOV	DPYPP(U),U		;SET UP PAGE PRINTER VARIABLES
	BEQ	DPYDX1			;LOOK FOR SCREW CASE
	BIC	#177400,A		;CLEAR OUT GARBAGE
	MOVB	PPCREG(U),T		;THE DPY
	MOVB	T,CREG

	BLKOFF	T			;TURN OFF THE BLINKERS
	PUSH	T
	JSR	PC,CLBLIN		;CLEAR THEM ALL
	MOV	PPCPC(U),TT		;ARE WE GOBBLING ARGS TO A CONTROL COMMAND?
	BEQ	DPYDP2
	MOV	PPSVB(U),B		;YES, RESTORE B AND PC FOR CORETURN FROM THE
	CLR	PPCPC(U)		;GETCHC THAT DIDN'T FIND ANY CHARS.
	JMP	(TT)

DPYDP2:	TSTB	A
	BLT	DPYCTL			;CONTROL CODE?
	CMP	#12,A
	BEQ	DPYCRF
	CMP	#15,A
	BEQ	DPYCRF
	CMP	#7,A			;BELL?
	BEQ	DPYBEL
DPYTVO:	JSR	PC,TVO			;GENERATE CHARACTER AND ADVANCE CURSOR
DPYXIT:	POP	T
	BLKON	T			;TURN THE BLINKER BACK ON

DPYDX1:	MOV	(SP),U			;DPY CHANNEL
	BR	DPYDP1			;LOOP BACK FOR NEXT CHARACTER

DPYBEL:	JSR	PC,BELL
	BR	DPYXIT

;HERE IF NO CHARACTER AVAILABLE

DPYDON:	TST	CHNCLS(B)
	BLT	DPYFLS			;FLUSH DPY CHANNEL?
	TST	ECOFLG(B)
	BEQ	DPYD2			;CAUSE PSEUDO ACTIVATION?
	MOV	PPLE(U),TT		;LINE EDITOR VARIABLES
	BEQ	DPYD1			;LINE EDITOR?
	MOV	TT,T
	ADD	#LEZER0,T

	CHROFF
	MOV	KBDACT,LELIST(TT)	;PUT LINE EDITOR ON ACTIVE RING
	MOV	T,KBDACT
	TST	KBDFLG
	BNE	DPYD0
	MOV	T,KBDFLG
	CLR	KBDACT
	CLR	KBDLAST
DPYD0:	CHRON

DPYD1:	CLR	ECOFLG(B)
DPYD2:	TST	WHOFLG			;DO WHO LINES?
	BEQ	DPYD3
	MOV	WHOLIN(B),T
	TST	WHMODE(T)
	BMI	DPYD4			;DON'T DO WHO LINE, BUT MIGHT WANT TO CLEAR IT
	TST	WHO1(T)
	BMI	DPYD4			;USER WHO MODE VAR CAN ALSO DISABLE WHO LINE
	JSR	PC,DOWHO		;DO THE WHO LINE FOR THIS GUY
DPYD3:	POP	U
	RTS	PC

;HERE IF NO WHO LINE IS TO BE DONE, WE MIGHT WANT TO CLEAR IT

DPYD4:	MOV	WHOLIN(B),T
	TST	2(T)			;IF NEGATIVE, THEN CLEAR IT
	BGE	DPYD3
	CLR	2(T)			;ZAP THE SWITCH
	JSR	PC,ZAPWHL		;CLEAR THE LINE
	BR	DPYD3

;HERE IF CONTROL CODE FOUND

DPYCRF:	SUB	#5,A
DPYCTL:	BIC	#200,A		;DISPATCH ON CONTROL CODE
	CMP	#ILLCTL,A
	BLOS	DPYTVO		;BRANCH IF ILLEGAL CODE
	ASL	A
	JSR	PC,@CTLTAB(A)
	BR	DPYXIT

CTLTAB:	SETCUR		;200
	RTSPC		;201
	CLEOF		;202
	CLEOL		;203
	CLRCHR		;204	DELETE FORWARD
	LF		;205	(12-5)
	RTSPC		;206
	RTSPC		;207
	CR		;210	(15-5)
ILLCTL==<.-CTLTAB>/2

;HERE TO SET CURSOR POSITION

SETCUR:	JSR	PC,GETCHC	;OLD VERTICAL AND HORIZONTAL
	JSR	PC,GETCHC
	JSR	PC,GETCHC	;NEW VERTICAL
	MOV	A,B
	JSR	PC,GETCHC	;NEW HORIZONTAL
				;NOTE GETCHC MAY RETURN AND BE REENTERED,
				;RESETTING ALL ACS BUT B.
	JMP	SETXY		;SET THE CURSOR

;HERE TO FLUSH DPY CHANNEL

DPYFLS:	CHROFF
	JSR	PC,DPYFL0
	CHRON
	BR	DPYD2

DPYFL0:	PUSH	B		;DPYCHN*4
	BEQ	DPYFL2		;DON'T FLUSH CHANNEL 0 (CONSOLE FREE MESSAGE)
	MOV	#-1,DPYKBD(B)	;TELL THE PDP-10 WE'RE LOGGING OUT
	MOV	WHOLIN(B),T	;FLUSH THE WHO LINE
	MOV	#-1,WHMODE(T)
	PUSH	U		;CHANNEL HEADER
	MOV	DPYPP(U),U	;PAGE PRINTER
	BEQ	DPYNPP		;A PAGE PRINTER?
	PUSH	U
	MOV	PPLE(U),U	;LINE EDITOR
	BEQ	DPYFL1		;LINE EDITOR THERE?
	MOV	LEKBD(U),T	;THE KEYBOARD
	BLT	DPYFL1
	MOVB	KBDVSW(T),T	;VSW THE OUTPUT
	BLT	DPYFL3
	PUSH	T
	JSR	PC,VSWNUL	;SWITCH NULL TO THAT OUTPUT
	POP	T		;OUTPUT
	MOV	MSGPP,TT	;CONSOLE FREE PAGE PRINTER
	MOVB	PPCREG(TT),TT	;MESSAGE DPY
	ASL	TT		;BYTES
	MOV	DPYVSW(TT),TT
	JSR	PC,VSWIT	;GIVE HIM THE CONSOLE FREE MESSAGE
DPYFL3:	JSR	PC,LERETN	;RETURN LINE EDITOR
DPYFL1:	POP	U		;PAGE PRINTER
	MOVB	PPCREG(U),TT
	BLT	DPYFL4
	JSR	PC,DPRETN	;RETURN THAT DPY
	BGE	.+4
	BPT			;NEGATIVE GUYS LOOKING AT THIS DPY
	ASL	TT		;BYTE INDEX
	TST	BELCNT(TT)	;ANY BELLS PENDING?
	BMI	DPYFL4
	CLR	BELCNT(TT)	;THE NEXT FLASH WILL BE THE LAST
DPYFL4:	JSR	PC,PPRETN	;FLUSH THE PAGE PRINTER
	POP	U		;CHANNEL VARIBLES
	CLR	DPYPP(U)
	POP	T
	ASR	T
	ASR	T		;DPY CHANNEL
	JMP	CHRETN

;HERE IF TRYING TO FLUSH CHANNEL 0

DPYFL2:	POP	B
	RTS	PC

;HERE IF DPYFLS CALLED WITH NO PAGE PRINTER SET UP

DPYNPP:	CMP	(SP)+,(SP)+	;CLEANSE STACK
	RTS	PC

;HERE TO RESTART, NOTIFY THE PDP-10

GODOWN:	RESET
	CLR	PS
	MOV	#INITED-2,B
	CLR	(B)+
	CLR	(B)+		;INITED
	CLR	(B)+
	CLR	(B)+		;GDOWN
	TST	GDOWN		;WAIT FOR THE PDP-10 TO REPLY
	BEQ	.-4
	JMP	GO
.SBTTL WHO LINE ROUTINES

;PRINTS WHO LINE, TAKES 10/11 CHANNEL IN B

DOWHO:	PUSH	B		;SAVE 10/11 CHANNEL
	MOV	ITSTI1,WHOTIM	;TIME WE DID WHO LINE
	MOV	#WHOPP,TT	;SET DEFAULTS FOR WHO PAGE PRINTER
	MOV	#PPDFLT,T
	MOV	#PPLEN,U
	JSR	PC,CALCPY	;ZAP
	MOV	#WHOPP,U	;SET UP PAGE PRINTER INDEX
	CLR	A		;CHARACTER X
	MOV	#CHRLN,B	;CHARACTER Y, PAST LAST LINE
	JSR	PC,SETXY0
	MOV	(SP),B		;RESTORE 10/11 CHANNEL INDEX
	JSR	PC,ZAPWHL	;CLEAR OUT THE WHO LINE
WHINIT:	MOV	(SP),B		;10/11 CHANNEL INDEX
	MOV	WHOLIN(B),TT
	CMP	#NWHCMD,WHMODE(TT)
	BHI	DATIME		;NO VERSION NUMBER FOR USER WHO LINE
	TYPOUT	/ITS /
	DECTYP	ITSVER		;TYPE VERSION NUMBER
	TST	ITSDBG
	BEQ	DATIME
	TYPOUT	/ BEING DEBUGGED/

;TYPES DAY TIME AND DATE

DATIME:	JSR	PC,SPACE	;PUT IN LEADING SPACE
	MOV	#MQ,B
	MOV	ITSTI1,(B)
	MOV	ITSTIM,-(B)
	JSR	PC,TIMTY1	;TYPE DAY TIME FIRST
	JSR	PC,SPACE
	MOV	ITSDAT,A	;PRINT PACKED DATE
	JSR	PC,DATTYP	; 7 BITS YEAR, 4 MONTH, 5 DAY
	JSR	PC,SPACE
	POP	B		;10/11 CHANNEL
	MOV	WHOLIN(B),TT
	CMP	#NWHCMD,WHMODE(TT)
	BHI	UWHLDO		;DO USER WHO LINE?

;SYSTEM WHO LINE
;ITS XXX {BEING DEBUGGED} HH:MM:SS MM/DD/YY ITSFDP/ITSTDP USR RU/JOB WBJ JWP TRC/COR CFU

SWLDO:	TYPOUT	/TVS: /
	DECTYP	ITSFDP		;# FREE DPYS
	JSR	PC,SLASH
	DECTYP	ITSTDP		;TOTAL DPYS
	TYPOUT	/ USERS: /
	DECTYP	ITSUSR		;# SYSTEM USERS
	JSR	PC,SPACE
	DECTYP	ITSRU		;RUNABLE JOBS/
	JSR	PC,SLASH
	DECTYP	ITSJOB		;# SYSTEM JOBS
	JSR	PC,SPACE
	DECTYP	ITSWBJ		;SWAP BLOCKED JOBS
	JSR	PC,SPACE
	DECTYP	ITSJWP		;JOBS WAITING FOR PAGES
	TYPOUT	/ CORE: /
	DECTYP	ITSTRC		;RUNABLE CORE
	JSR	PC,SLASH
	DECTYP	ITSCOR		;TOTAL CORE
	JSR	PC,SPACE
	DECTYP	ITSCFU		;CORE FOR USERS
	RTS	PC

;USER WHO LINE
;ITS XXX HH:MM:SS MM/DD/YY JOB UNAME JNAME SNAME STATUS J%RT HH:MM:SS.S T%RT TPAG

WHNOJB:	TYPOUT / JOB SLOT VACANT/		;HERE IF JOB SLOT VACANT
	RTS	PC

UWHLDO:	OCTYPE	WHJOB(TT)	;JOB #
	TST	WHSTAT(TT)
	BEQ	WHNOJB		;VACANT JOB SLOT?
	JSR	PC,SPACE
	MOV	#WHUNAM,T
	ADD	TT,T
	JSR	PC,SIXPNT	;UNAME
	JSR	PC,SPACE
	JSR	PC,SIXPNT	;JNAME
	JSR	PC,SPACE
	JSR	PC,SIXPNT	;SNAME
	JSR	PC,SPACE
	JSR	PC,SIXPNT	;STATUS
	JSR	PC,SPACE
	DECTYP	WHJ%RT(TT)	;JOB % RUN TIME
	JSR	PC,PERCNT
	JSR	PC,SPACE
	MOV	WHJTRT(TT),A	;JOB RUNTIME IN .1-SEC TICKS
	JSR	PC,TIMTEN
	JSR	PC,SPACE
	DECTYP	WHTPAG(TT)	;# PAGES OF CORE
	MOV	#'K,A
	JSR	PC,TVO
	PUSH	WHO1(TT)	;PRINT FIRST USER WHO VAR
	MOV	#WHO2,T
	JSR	PC,UWVDO
	PUSH	WHO1A(TT)	;MAYBE PRINT SPACE
	BMI	UWHLD1
	JSR	PC,SPACE
UWHLD1:	MOV	#WHO3,T		;NOW SECOND USER WHO VAR
;TAKE CONTROL WORD ON STACK, OFFSET (OFF TT) TO FOUR WORDS IN T, PRINT USER WHO VAR
;CONTROL WORD:
;	15	USED ELSEWHERE - IGNORE HERE
;	14	SUPPRESS SPACE BETWEEN TWO HALVES
;	13-11	MODE FOR FIRST HALF
;	10-08	MODE FOR SECOND HALF
;	07	DOUBLE 06-00
;	06-00	CHARACTER TO PRINT AFTER FIRST HALF, BEFORE SPACE
UWVDO:	ADD	TT,T		;T POINT TO VAR
	MOVB	1(SP),A
	ASR	A		;GET FIRST MODE
	ASR	A
	ASR	A
	JSR	PC,UWVDO4
	MOVB	(SP),A
	BEQ	UWVDO1
	BIT	#200,A
	BEQ	UWVDO3
	JSR	PC,TVOMSK
UWVDO3:	JSR	PC,TVOMSK
UWVDO1:	BITB	#100,1(SP)
	BNE	UWVDO2
	JSR	PC,SPACE
UWVDO2:	MOVB	1(SP),A
	TST	(SP)+
UWVDO4:	BIC	#177770,A
	ASL	A
	JMP	@UWVDTB(A)

UWVDTB:	RTSPC			;0	DON'T PRINT
	UWVDAT			;1	PACKED DATE AS MM/DD/YY
	UWVTEN			;2	TIME IN .025 SECONDS AS HH:MM:SS.T
	UWVHAK			;3	TIME IN .5 SECONDS AS HH:MM:SS
	UWVHAK			;4	OCTAL (18. BITS)
	UWVHAK			;5	DECIMAL (18. BITS)
	SIXPN1			;6	THREE SIXBIT CHARS
	RTSPC			;7	RESERVED FOR EXPANSION

UWVHAK:	MOV	#MQ,B
	TST	(T)+
	MOV	(T),(B)
	MOV	-(T),-(B)
	CMP	(T)+,(T)+
	MOV	#-14.,LSH
	JMP	@UWVDT1-3(A)

UWVDT1:	TIMTY1
	UWVOCT
	UWVDEC

UWVOCT:	MOV	#10,B
	BR	UWVDC1

UWVDEC:	MOV	#10.,B
UWVDC1:	PUSH	RADIX
	MOV	B,RADIX
	JSR	PC,DECPN9
	POP	RADIX
	RTS	PC

UWVTEN:	MOV	(T)+,A
	TST	(T)+
	JMP	TIMTEN

UWVDAT:	MOV	(T)+,A
	TST	(T)+
	JMP	DATTYP

;SOME WHO LINE UTILITY ROUTINES

PERCNT:	MOV	#'%,A
JMPTVO:	JMP	TVO

SPACE:	MOV	#40,A
	BR	JMPTVO

SLASH:	MOV	#'/,A
	BR	JMPTVO

;TAKES POINTER TO SIXBIT IN T AND TYPES IT (ADVANCING T)

SIXPNT:	MOV	#MUL,B
	MOV	#LSH,C
	JSR	PC,SIXPN1	;DO FIRST SET OF THREE CHARS
	CMP	(B)+,(B)+	;RESET B FOR SECOND SET
SIXPN1:	CMP	(T)+,(T)+	;BAG BITING EAE HAS TO LOADED IN JUST THE RIGHT ORDER
	MOV	-(T),-(B)	;LOW ORDER FIRST
	MOV	-(T),-(B)
	CMP	(T)+,(T)+
	MOV	#-10.,(C)	;FIRST CHARCTER IN AC, THE REST IN MQ
	JSR	PC,SIXPN2	;PRINT FIRST CHAR
	JSR	PC,SIXPN2	;PRINT SECOND, FALL IN FOR THIRD
SIXPN2:	MOV	(B)+,A		;SIXBIT
	ADD	#40,A		;ASCII
	PUSH	(B)+
	JSR	PC,TVO
	POP	-(B)
	CLR	-(B)		;CLEAR AC
	MOV	#6,(C)		;NEXT CHARACTER INTO AC
	RTS	PC

;TAKES TENTHS OF SECONDS IN A AND PRINTS AS HH:MM:SS.T

TIMTEN:	MOV	#MQ,T
	MOV	A,(T)
	CLR	-(T)
	MOV	#10.,-(T)	;DO DIVIDE
	TST	(T)+
	PUSH	(T)+		;TENTH'S OF SECONDS
	MOV	(T),A
	ASL	A		;# HALF SECONDS JOB HAS BEEN RUNNING
	JSR	PC,TIMTYP	;TYPE TIME
	MOV	#'.,A
	JSR	PC,TVO
	POP	A		;TENTH'S OF SECONDS
	JMP	DECPNT

;TAKES # HALF SECONDS IN A AND TYPES TIME IN HH:MM:SS FORMAT

TIMTYP:	MOV	#MQ,B
	MOV	A,(B)
	CLR	-(B)
;TAKE # HALF SECONDS IN EAE AC-MQ AND TYPE AS HH:MM:SS
TIMTY1:	MOV	#120.,-(B)	;MINUTES SINCE MIDNIGHT
	TST	(B)+
	PUSH	(B)		;REMAINDER IS SS*2
	ASR	(SP)
	CLR	(B)		;CLEAR AC
	MOV	#60.,-(B)	;HOURS SINCE MIDNIGHT
	TST	(B)+
	PUSH	(B)+		;REMAINDER IS MM
	MOV	(B),A		;HH
	JSR	PC,DECPNT
	MOV	#':,C		;COLON SEPARATES GOODIES
	POP	A
	JSR	PC,MSDPNT	;PRINTS COLON AND PADS WITH LEADING ZERO IF NECESSARY
	POP	A
MSDPNT:	PUSH	A
	MOV	C,A		;PRINT SEPARATING CHARACTER
	JSR	PC,TVO
	CMP	#10.,(SP)
	BLE	MSDPN1		;PAD WITH LEADING ZERO?
	MOV	#'0,A
	JSR	PC,TVO
MSDPN1:	POP	A
	JMP	DECPNT		;PRINT NUMBER

;TAKE DATE PACKED AS 7 BITS YEAR, 4 MONTH, 5 DAY AND PRINT AS MM/DD/YY

DATTYP:	MOV	#MQ,B
	MOV	A,(B)
	CLR	-(B)		;CLEAR AC
	MOV	#LSH,C
	MOV	#7,(C)		;YEAR
	PUSH	(B)
	CLR	(B)
	MOV	#4,(C)		;MONTH
	MOV	(B),A
	CLR	(B)
	MOV	#5,(C)		;DAY
	PUSH	(B)
	JSR	PC,DECPNT	;PRINT MONTH
	MOV	#'/,C		;USE SLASH AS SEPARATOR
	POP	A
	JSR	PC,MSDPNT	;PRINT DAY
	POP	A
	JMP	MSDPNT		;PRINT YEAR

.SBTTL PDP-10 COMMAND PROCESSOR SWITCH VIDEO SWITCH, ETC.

TENCMD:	CMP	#MAXCMD,A	;LEGAL COMMAND?
	BLOS	TENCFL		;NO, COMMAND FAILS
	ASL	A		;BYTES FOR DISPATCH
	JMP	@TENDSP(A)

;PDP-10 COMMAND DISPATCH

TENDSP:	TENCFL	;0 ILLEGAL
	TENVSW	;1 VIDEO SWITCH
	TENDPC	;2 CONS DPY FOR PDP-10
	TENDPR	;3 RETURN DPY
	TENRVS	;4 READ VIDEO SWITCH
	TENASW	;5 AUDIO SWITCH
	TENRAS	;6 READ AUDIO SWITCH
MAXCMD==<.-TENDSP>/2

;HERE TO SWITCH VIDEO SWITCH

TENVSW:	MOV	CMDBUF,TT	;SWITCH INPUT
	MOV	CMDBUF+4,T	;SWITCH OUTPUT
	CHROFF			;INHIBIT INTERUPTS WHILE WE DO THIS
	JSR	PC,VSWCMD	;CHECKS FOR LEGAL BEFORE SWITCHING
	CHRON
TENCSD:	MOV	#-1,CMDFLG	;COMMAND SUCCEEDS
	RTS	PC

;HERE TO CONS UP DPY FOR PDP-10

TENDPC:	CHROFF			;INHIBIT INTERUPTS AGAIN
	JSR	PC,DPCONS
	CHRON
	MOV	TT,CMDBUF	;ARGUMENT RETURNED
	BGE	TENCSD		;MAYBE WE LOST?
TENCFL:	CLR	CMDFLG		;NO, COMMAND LOST
	RTS	PC

;HERE TO RETURN DPY ON COMMAND

TENDPR:	MOV	CMDBUF,TT	;THE DPY TO RETURN
	CMP	#MAXTV,TT
	BLOS	TENCSD		;ILLEGAL, BUT COMMAND ALWAYS SUCCEEDS
	JSR	PC,DPRETN	;RETURN THE DPY
	BR	TENCSD

;HERE RETURN STATE OF VIDEO SWITCH

TENRVS:	JSR	PC,SWTARG	;SET UP 10-11 CHANNEL ARGUMENT
	BLOS	TENCFL		;ILLEGAL ARG MAKES COMMAND FAIL
	JMP	@RVSDSP(T)
RVSDSP:	TENCFL			;0 IS ILLEGAL
	RVSCHN			;1 10/11 CHANNEL #
	RVSKBD			;2 KBD #
	RVSOUT			;3 VIDEO SWITCH OUTPUT #
NSWTRG==<.-RVSDSP>/2

;HERE TO RETURN STATE OF AUDIO SWITCH

TENRAS:	JSR	PC,SWTARG
	BLOS	TENCFL
	JMP	@RASDSP(T)
RASDSP:	TENCFL
	RASCHN
	RASKBD
	RASOUT
CHECK RASDSP,NSWTRG*2

RASCHN:	JSR	PC,CHNKBD	;GETS KBD IN T
	BLOS	TENCFL
RASCH1:	MOVB	KBDASW(T),TT
RASCH2:	MOV	TT,CMDBUF+<3*4>
	CLR	CMDBUF+<2*4>
	TST	CMDBUF
	BMI	RASDF		;BRANCH IF HE WANTS DEFAULTS
	ASL	TT		;BYTE INDEX
	MOVB	ASWO0(TT),CMDBUF+<2*4>
	BR	TENCSD
RASDF:	RTS	PC		;THE NULL INPUT IS ALWAYS THE DEFAULT INPUT

RASKBD:	JSR	PC,CHKKBD
	BHI	RASCH1
	BR	TENCFL

RASOUT:	MOV	CMDBUF+4,TT
	MOV	#-1,T		;ILLEGAL KBD #
	CMP	#MAXASO,TT
	BLOS	TENCFL
	BR	RASCH2

;HERE TO READ STATE OF VIDEO SWITCH

RVSCHN:	JSR	PC,CHNKBD	;GET KBD # IN T
	BLOS	TENCFL
RVSCH1:	MOVB	KBDVSW(T),TT	;GET VIDEO SWITCH OUTPUT INTO TT
RVSCH2:	MOV	TT,CMDBUF+<4*4>	;PUT VIDEO SWITCH OUTPUT INTO COMMAND BUFFER
	CLR	CMDBUF+<3*4>	;CLEAR BOTH INPUT ARGS
	CLR	CMDBUF+<2*4>
	TST	CMDBUF
	BMI	RVSDF		;BRANCH IF HE WANTS DEFAULTS
	ASL	TT		;BYTE INDEX
	MOVB	VSWO0(TT),CMDBUF+<2*4>
	MOVB	VSWO1(TT),CMDBUF+<3*4>
	BR	TENCSD

RVSDF:	ASL	T		;MAKE IT BYTE INDEX
	BMI	RVSNL		;NEGATIVE IF NOT LOGGED IN
	MOV	KBDLE(T),U
	BEQ	RVSNL		;KBD NOT LOGGED IN, ITS THE DEFAULT
	MOV	LEPP(U),U	;THE PAGE PRINTER
RVSDF1:	MOVB	PPCREG(U),TT	;THE REGISTER HE HACKS
	CMP	#MAXTV,TT
	BLOS	TENCFL		;BRANCH IF ILLEGAL CONSOLE #
	ASL	TT		;MAKE IT A BYTE INDEX
	MOV	DPYVSW(TT),TT	;VIDEO SWITCH INPUT
	MOV	TT,CMDBUF+<2*4>	;INTO COMMAND BUFFER
	BIC	#<-1#VSWINC>,TT
	BNE	TENCSD		;BRANCH IF NON-NULL INPUT IN SECOND SECTION
	MOV	#VSWINC,CMDBUF+<3*4>
	BR	TENCSD

RVSNL:	MOV	DPYCHN,U	;CHANNEL 0 IS CONSOLE FREE CHANNEL
	MOV	DPYPP(U),U	;THE PAGE PRINTER VARIABLES
	BR	RVSDF1		;AND BACK INTO MAIN STREAM

RVSKBD:	JSR	PC,CHKKBD	;PICK UP KBD #
	BHI	RVSCH1		;IF LEGAL, FALL INTO MAIN LINE CODE
	BR	TENCFL		;ILLEGAL, TELL HIM SO

RVSOUT:	MOV	CMDBUF+4,TT	;VIDEO SWITCH OUTPUT
	MOV	#-1,T		;ILLEGAL KBD #
	CMP	#MAXVSO,TT	;CHECK FOR LEGAL
	BHI	RVSCH2		;FALL INTO MAIN LINE CODE
	BR	TENCFL		;HERE IF ILLEGAL	
	
;SWITCH AUDIO SWITCH UPON COMMAND FROM PDP-10

TENASW:	MOV	CMDBUF,TT	;SWITCH INPUT
	MOV	CMDBUF+4,T	;SWITCH OUTPUT
	CHROFF
	JSR	PC,ASWCMD
	CHRON
	JMP	TENCSD

;GIVEN 10/11 CHANNEL # AND RETURNS KBD IN T

CHNKBD:	MOV	CMDBUF+4,T	;PICK UP CHANNEL #
	CMP	#MAXPP,T
	BLOS	CHNKB2
	ASL	T		;MAKE CHANNEL # INTO INDEX INTO CHANNEL TABLES
	ASL	T
	TST	CHNCLS(T)	;MAKE SURE CHANNEL IS OPEN
	BNE	CHNKB3
	MOVB	DPYKBD(T),T	;PICK UP KBD #
CHNKB1:	CMP	#MAXKBD,T	;FIX CONDITION CODES FOR SUCCESSFUL RETURN
CHNKB2:	RTS	PC

CHNKB3:	MOV	#MAXKBD+1,T	;HERE IF CHANNEL CLOSED
	BR	CHNKB1		;CONS UP ILLEGAL KBD #

CHKKBD:	MOV	CMDBUF+4,T	;CHECK FOR REASONABLE KBD #
	BR	CHNKB1

;HERE TO SET UP SWITCH ARG FOR 10-11 COMMAND RETURN IN CONDITION CODES
;IS THE RESULT OF CMP #NCHARG,<argument type> TO CHECK FOR LEGALITY

SWTARG:	MOV	CMDBUF,T	;ARGUMENT TYPE
	BPL	.+4		;MAKE SURE WE HAVE A POSITIVE #
	NEG	T
	ASL	T		;MAKE IT INTO A BYTE INDEX
	CMP	#NSWTRG*2,T	;TEST FOR LEGAL
	RTS	PC
	
;ERROR TRAPS HERE

NXMBRK:	BPT
RESBRK:	BPT
BPTBRK:	HALT
IOTBRK:	BPT
PWRBRK:	BPT
EMTBRK:	BPT
TRPBRK:	BPT
.SBTTL CLOCK ROUTINES CAUSE BLINKING

CLKBRK:	PUSH	T
	ADD	#1,TICKS1	;INC DOES NOT AFFECT C-BIT (SIGH)
	ADC	TICKS
	TST	KBDFLG
	BNE	CLKBR1		;HAS PDP-10 HACKED THE LAST BUNCH?
	MOV	KBDACT,KBDFLG	;YES, GIVE HIM THE NEW BUNCH
	CLR	KBDFLG+2	;PARANOIA REIGNS SUPREME
	CLR	KBDACT
	CLR	KBDLAST		;POINTS TO END OF ACTIVE CHAIN

;CLOCK QUEUE DISPATCH

CLKBR1:	MOV	CLOCKQ,T
	BEQ	CLKBR2		;ANYTHING ON CLOCK QUEUE?
	TST	(T)+		;IGNORE CDR
	CMP	(T)+,TICKS	;HIGH ORDER
	BHI	CLKBR2
	CMP	(T)+,TICKS1	;LOW ORDER
	BHI	CLKBR2
	PUSH	CLOCKQ		;CDR THE CLOCK QUEUE
	MOV	@(SP),CLOCKQ
	JSR	PC,@(T)+	;CALL CLOCK LEVEL ROUTINE, T POINTS TO ARGUMENT
	POP	T
	MOV	CLOCKF,(T)	;PUT OLD SLOT ON FREE LIST
	MOV	T,CLOCKF
	BR	CLKBR1		;CHECK AGAIN IF SOMETHING STILL ON QUEUE

CLKBR2:	DEC	BLINK
	BGE	.+10
	MOV	#BLKTIM,BLINK
	CMP	BLINK,#MAXTV
	BHIS	CLKR1
	MOV	BLINK,T
	TSTB	BLKSWT(T)	;HACK THIS ONE?
	BNE	CLKR1
	PUSH	U
	PUSH	CREG
	PUSH	AC
	PUSH	MQ
	MOVB	T,CREG
	ASL	T
	MOV	BLINKS(T),T	;BLINK CHAIN FOR THIS DPY
	BEQ	CLKRET
CLKLOP:	MOV	BLCURS(T),U	;CURSOR TO BLINK
	JSR	PC,XORCHR
	COMB	BLON(T)		;CHANGE STATE OF BLINK
	MOV	BLNEXT(T),T
	BNE	CLKLOP
CLKRET:	POP	MQ
	POP	AC
	POP	CREG
	POP	U
CLKR1:	POP	T
CRTI:	RTI

;CLEARS ALL BLINKERS ON THIS DPY

CLBLIN:	PUSH	U
	MOVB	CREG,T
	BIC	#177400,T
	ASL	T
	MOV	BLINKS(T),T
	BEQ	CLBL2
CLBL0:	TSTB	BLON(T)		;BLINK ON?
	BEQ	CLBL1
	MOV	BLCURS(T),U
	JSR	PC,XORCHR
	CLRB	BLON(T)
CLBL1:	MOV	BLNEXT(T),T
	BNE	CLBL0
CLBL2:	POP	U
	RTS	PC
;CLOCK QUEUE ROUTINES

;ADQUE	CALLED WITH ARG IN T, CALLING SEQUENCE IS:

;	JSR	TT,ADQUE
;		DELTA T
;		ROUTINE TO CALL AT CLOCK LEVEL

ADQUE:	PUSH	T		;ARG FOR ROUTINE
	MOV	CLOCKF,T	;GET FREE CLOCK QUEUE SLOT
	BEQ	ADQFL		;IF THERE IS A FREE ONE
	TST	(T)+		;IGNORE CDR
	MOV	TICKS,(T)+	;MOVE IN CURRENT TIME
	MOV	TICKS1,(T)
	ADD	(TT)+,(T)+	;TIME TO CALL ROUTINE
	ADC	-4(T)
	MOV	(TT)+,(T)+	;ROUTINE TO CALL
	MOV	(SP)+,(T)	;AND ITS ARG
	PUSH	TT		;RETURN ADDRESS
	MOV	CLOCKF,TT	;ADDRESS OF THIS CLOCK QUEUE SLOT
	MOV	(TT),CLOCKF	;CDR THE FREE LIST
	PUSH	TT		;ADDRESS OF ONE TO ADD
	PUSH	#CLOCKQ		;ADDRESS OF PREVIOUS CLOCK QUEUE ENTRY
ADQUE1:	MOV	@(SP),TT	;CURRENT ENTRY IN QUEUE
	BEQ	ADQUE2		;END OF QUEUE?
	MOV	2(SP),T		;THE ONE WE WANT TO ADD
	CMP	(T)+,(TT)+	;IGNORE CDR'S
	CMP	(T)+,(TT)+	;HIGH ORDER OF TIME
	BLO	ADQUE2		;GO SPLICE IT IN HERE
	CMP	(T)+,(TT)+	;LOW ORDER
	BLOS	ADQUE2
	MOV	@(SP),(SP)	;CDR THE QUEUE
	BR	ADQUE1

;HERE TO SPLICE ENTRY INTO CLOCK QUEUE

ADQUE2:	MOV	@(SP),@2(SP)	;CDR OF QUEUE, GOES TO CDR OF NEW ENTRY
	MOV	2(SP),@(SP)	;CURRENT SLOT GOES TO CDR OF PREVIOUS
	CMP	(SP)+,(SP)+	;CLEANSE STACK
	POP	TT
	RTS	TT

;HERE FOR NO FREE CLOCK QUEUE SLOTS

ADQFL:	CMP	(TT)+,(TT)+	;SKIP OVER ARGS
	POP	T		;CLEANSE STACK
	RTS	TT

;CAUSES CONSOLE FREE DPY TO GLITCH

MSGLIT:	PUSH	CREG
	MOV	(T),T
	MOV	T,CREG
	JSR	TT,ADQUE
		GLITIM
		MSGLIT
	MOV	CSA,T
	PUSH	T
	BIC	#-BOWBIT,T		;CLEAR BOW AND OTHER GARBAGE
	ADD	#LINHT*BYTPL/10,T	;GLITCH ONE CHARACTER LINE
	CMP	#LINHT*BYTPL*CHRLN/10,T
	BHI	.+4			;WRAP AROUND?
	CLR	T
	BIC	#-1#<-BOWBIT>,(SP)
	BIS	T,(SP)
	POP	CSA		;ZAP
	POP	CREG
	RTS	PC

;HERE TO RING BELL ON DPY

BELL:	PUSH	T
	MOV	CREG,T
	MOVB	T,TT		;DOUBLE DPY # FOR BYTE INDEX
	ASL	TT

	CHROFF			;INHIBIT INTERUPTS WHILE WE HACK CLOCK QUEUE, ETC.
	INC	BELCNT(TT)	;FLASH SCREEN AT LEAST ONCE
	BEQ	BELL0		;IF NONE PENDING, FLASH IT NOW
	INC	BELCNT(TT)	;IF BELLS PENDING THEN FLASH TWICE
	CMP	BELCNT(TT),#MAXBEL
	BLOS	BELL0A
	DEC	BELCNT(TT)
	DEC	BELCNT(TT)
	BR	BELL0A

;HERE IF NO BELLS PENDING, FLASH SCREEN RIGHT AWAY, ADD CLOCK QUEUE ENTRY

BELL0:	JSR	PC,BOWXOR	;FLASH THE SCREEN NOW!
	JSR	PC,BELL1A	;ADD CLOCK QUEUE ENTRY
BELL0A:	CHRON

	POP	T
	RTS	PC

;CLOCK LEVEL BELL ROUTINE

BELL1:	PUSH	CREG
	MOV	(T),T		;THE DESIRED CONSOLE REGISTER
	MOV	T,CREG
	MOV	#BOWBIT,CSA	;FLASH THE SCREEN
	BIC	#177400,T	;THE DPY #
	ASL	T		;BYTE INDEX
	DEC	BELCNT(T)	;WE JUST DID THAT ONE
	BMI	BELL1B		;ANY MORE PENDING?
	JSR	PC,BELL1A	;YES, PUT ANOTHER ON QUEUE
BELL1B:	POP	CREG
	RTS	PC

BELL1A:	MOV	CREG,T		;PUT ANOTHER BELL ON CLOCK QUEUE
	JSR	TT,ADQUE
		BLKTIM
		BELL1
	RTS	PC
.SBTTL KEYBOARD INTERUPT ROUTINES

;KEYBOARD BREAK ROUTINES  THE LINE EDITOR RUNS AT THIS LEVEL

KBDBRK:	JSR	U,ACSAV		;PUT AC'S ON STACK
	PUSH	CREG
	PUSH	AC
	PUSH	MQ
KBDLOP:	MOV	OLDKMA,A
	CMP	#KBDEND,A	;CHECK WRAP AROUND
	BHI	.+6
	MOV	#KBDBUF,A
	CMP	KMA,A
	BEQ	KBDRET		;NO MORE CHARACTERS
	MOV	(A)+,B		;RAW CHARACTER
	TSTB	(A)+		;GARBAGE
	MOVB	(A)+,-(SP)	;KEYBOARD #
	MOV	A,OLDKMA

;GET ASCII REPRESENTATION OF CHARACTER
;	ASCII CODE IN A, META BITS IN B

	MOV	B,C		;TWO COPIES OF RAW CHARACTER
	BIC	#RCHAR,B	;KEY STRUCK
	BIT	#RTPBIT,C	;TOP?
	BEQ	KBDX1
	BIS	#XTPBIT,B
	BR	KBDX2
KBDX1:	BIT	#RSLBIT,C	;SHIFT LOCK?
	BEQ	.+6
	BIS	#XSLBIT,B
	BIT	#RSHBIT,C	;SHIFT?
	BEQ	KBDX2
	BIS	#XSHBIT,B
KBDX2:	MOVB	XTAB(B),A	;ASCII REPRESENTATION
	BIC	#<<XSLBIT!XSHBIT!XTPBIT>#-1>,B	;FLUSH ALL UNINTERESTING BITS
	ASL	B		;XTAB TO ASCII REPRESENTATION
	ASL	B
	ASL	B
	BIT	#RMTBIT,C	;META?
	BEQ	.+6
	BIS	#AMTBIT,B
	BIT	#RCLBIT,C	;CONTROL?
	BEQ	.+6
	BIS	#ACLBIT,B
	MOVB	(SP)+,C		;KEYBOARD #
	ASL	C		;BYTE FOR INDEX INTO KBDLE
	TST	A
	BLT	NONASC		;NON-ASCII
	MOV	KBDLE(C),U	;ASSOCIATED LINE EDITOR?
	BEQ	KBDLOP
	MOVB	LECREG(U),CREG	;SET UP CONSOLE REGISTER

;DECIDE WHAT TO DO WITH THIS CHARACTER

	TSTB	LEBRK(U)	;ESCAPE OR BREAK IN PROG?
	BNE	ESCBRK
	BIS	#ACTBIT,B
	JSR	PC,PUTCHR
	BR	KBDLOP
;KEYBOARD RETURN

KBDRET:	POP	MQ
	POP	AC
	POP	CREG
	POP	A
	POP	B
	POP	C
	POP	T
	POP	TT
	POP	U
	RTI

;NON-ASCII CHARACTERS COME HERE

NONASC:	NEG	A
	CMP	#MAXNAS,A
	BHIS	.+4
NONAS1:	BPT			;ILLEGAL CHARACTER
	CMP	#<MAXKBD*2>,C	;C HAS BEEN DOUBLED
	BHI	.+4
	BPT			;GARBAGE KBD #
	ASL	A		;BYTES
	JSR	PC,@NASCTB(A)	;DISPATCH TO ROUTINE
JBDLOP:	JMP	KBDLOP

;PROCESS ESCAPE AND BREAK COMMANDS

ESCBRK:	JSR	PC,UPPER	;CONVERT LOWER CASE TO UPPER CASE
	MOV	#ESCHAR,T
ESCBR1:	CMPB	(T),A		;MATCH?
	BEQ	DOESC
	TSTB	(T)+		;END OF TABLE?
	BNE	ESCBR1
ESCBR2:	CLRB	LEBRK(U)	;NO COMMAND
	BR	JBDLOP

DOESC:	SUB	#ESCHAR,T
	PUSH	T
	ASL	T		;BYTES
	JSR	PC,@ESCTAB(T)
	CMP	#7,(SP)+	;DIGIT?
	BGE	JBDLOP
	BR	ESCBR2
.SBTTL LINE EDITOR ROUTINES

;LEDADC ADVANCES LINE EDITOR CURSOR
;TAKES AND PRESERVES CHAR IN A
TVOMSK:	BIC	#177600,A	;HERE IF YOU DON'T TRUST THE HIGH BITS
TVO:	JSR	PC,GENCHR	;GENERATES CHARACTER AND ADVANCES CURSOR
LEDADC:	TST	LEPHS(U)
	BGE	LEDAD1
	ADD	#20,LEPHS(U)	;# BITS/WORD
	ADD	#2,LECC(U)	;ADVANCE TO NEXT WORD IN DISPLAY
	CMP	LECC(U),#TVHI
	BLOS	LEDAD1
	MOV	#TVLO,LECC(U)
LEDAD1:	SUB	#CHRWD,LEPHS(U)
	ADD	#CHRWD,LEX(U)
	RTS	PC

;RETREATS LINE EDITOR CURSOR

LEDREC:	ADD	#CHRWD,LEPHS(U)
	SUB	#CHRWD,LEX(U)
	CMP	#<20-CHRWD>,LEPHS(U)
	BGE	LEDRE1
	SUB	#20,LEPHS(U)	;BACKUP A WORD IN DISPLAY
	SUB	#2,LECC(U)
	CMP	LECC(U),#TVLO
	BHIS	LEDRE1
	MOV	#TVHI,LECC(U)
LEDRE1:	RTS	PC

;THESE ROUTINES ADVANCE CURSOR AND CHECK FOR OFF SCREEN ETC.
;RESULTS ARE RETURNED IN CONDITION CODES IN PROCESSOR STATUS

CHKADV:	TST	LEX(U)
	BGE	CHKAD1		;CHARACTER OFF SCREEN
	JSR	PC,LEDADC
CHKAD0:	TST	#-1		;RETURN NEGATIVE
CHKAD1:	RTS	PC

CHKRTR:	CMP	LEEDIT(U),LEDCNT(U)	;AT BEGINING?
	BGE	CHKAD0
	JSR	PC,LEDREC
	TST	#1
	RTS	PC
;HERE FOR POSSIBLE GLITCHING
;CR TRANSFORMED INTO CRLF,  LF LEFT UNCHANGED

PPCR:	JSR	PC,CR			;DO A CARRIAGE RETURN
PPLF:	DECB	PPLPG(U)		;THIS GLITCH FULL?
	BGT	LF
	MOVB	PPLPGK(U),PPLPG(U)
	DECB	PPNGL(U)		;ALL GLITCHES ON SCREEN?
	BGT	LF
	MOV	CSA,-(SP)		;SCROLL REGISTER
	BIC	#CSAMSK,(SP)
	MOVB	PPLPGK(U),-(SP)		;GLITCH
	MOV	PPORG(U),T
GLITCH:	JSR	PC,CLRCHL		;CLEAR CHARACTER LINE
	ADD	#WRDPL*LINHT/4,2(SP)
	CMP	#TVFENCE,T		;IS THIS LINE SPLIT?
	BHI	GLIT1
	CLR	2(SP)			;WRAP AROUND TO TVLO
	MOV	#TVLO,T
GLIT1:	DECB	(SP)
	BGT	GLITCH
	TST	(SP)+
	MOV	T,PPORG(U)		;ORIGIN OF PIECE OF PAPER IN MEMORY
	MOV	CSA,T
	BIC	#SAMSK,T
	BIS	(SP)+,T
	MOVB	#CSET,CALU
	TSTB	PPLPGK(U)		;WRAP AROUND OR GLITCH?
	BEQ	LF
	MOV	T,CSA			;GLITCH
	MOV	#MQ,T			;FIXUP PPY
	MOVB	PPLPGK(U),(T)+
	CLRB	(T)+
	MOV	#LINHT,(T)
	SUB	-(T),PPY(U)

;HERE FOR LINE FEED, NO FRILLS

LF:	ADD	#<BYTPL*LINHT>,PPLCC(U)
	ADD	#<BYTPL*LINHT>,PPCC(U)
	CMP	#TVFENCE,PPLCC(U)
	BHI	LF1
	SUB	PPLCC(U),PPCC(U)
	ADD	#TVLO,PPCC(U)
	MOV	#TVLO,PPLCC(U)
LF1:	ADD	#LINHT,PPY(U)
	CMP	#-LINHT,PPY(U)
	BGT	LF2
	MOV	#-NLINS,PPY(U)
LF2:	RTS	PC

;HERE FOR CARRIAGE RETURN

CR:	MOV	PPLCC(U),PPCC(U)	;ORIGIN OF THIS LINE
	CLR	PPDCNT(U)
CR1:	MOV	#20-CHRWD,PPPHS(U)	;PHASE
	MOV	#-BITPL,PPX(U)		;RESET X
	RTS	PC
;DATA POINT ROUTINES

;CLEARS TO END OF LINE

CLEOL:	PUSH	PPCC(U)
	PUSH	PPPHS(U)
	PUSH	PPX(U)
	JSR	PC,CLEOL1	;DO THE DIRTY WORK
CLEOX:	POP	PPX(U)
	POP	PPPHS(U)
	POP	PPCC(U)
	RTS	PC

CLEOL1:	TST	PPX(U)		;ALREADY AT END OF LINE?
	BGE	CLEOLX
	JSR	PC,CLRCHR
	JSR	PC,LEDADC	;ADVANCE CURSOR
	TST	PPPHS(U)	;DOES CHARACTER OVER LAP?
	BGT	CLEOL1

	JSR	PC,CLRCHR
	MOV	PPX(U),TT	;CHARACTER POSITION
	BGE	CLEOLX
	ADD	#17,TT
	ASR	TT
	ASR	TT
	ASR	TT
	ASR	TT		;-(# WORDS TO CLEAR)
	BGE	CLEOLX		;ALREADY AT END?
	PUSH	TT
	PUSH	PPCC(U)
	ADD	#2,(SP)		;FIRST WORD TO CLEAR
	PUSH	#LINHT		;# LINES TO PROCESS
	MOVB	#CSET,CALU
CLEOL3:	MOV	2(SP),T		;START CLEARING HERE
CLEOL4:	CLR	(T)+
	INC	TT
	BLT	CLEOL4
	ADD	#BYTPL,2(SP)
	MOV	4(SP),TT	;-(# WORDS TO CLEAR)
	DEC	(SP)
	BGT	CLEOL3
	ADD	#6,SP		;CLEANSE STACK
	MOV	T,PPCC(U)
	BR	CR1		;RESET X AND PHASE

CLEOLX:	MOV	PPLCC(U),T
	ADD	#<LINHT*BYTPL>,T	;HERE IF ALREADY AT END OF LINE
	MOV	T,PPCC(U)
	BR	CR1
;DATA POINT ROUTINES CONTINUED

;CLEARS TO END OF SCREEN

CLEOF:	PUSH	PPCC(U)
	PUSH	PPPHS(U)
	PUSH	PPX(U)
	PUSH	PPY(U)
	JSR	PC,CLEOL1	;CLEAR TO END OF LINE FIRST
	ADD	#LINHT,PPY(U)
CLEOF0:	CMP	#TVFENCE,T	;PAST FENCE?
	BHI	CLEOF1
	MOV	#TVLO,T
CLEOF1:	ADD	#LINHT,PPY(U)
	BGE	CLEOFX		;WILL RUN OFF END?
	JSR	PC,CLRCHL	;CLEAR NEXT CHARACTER LINE
	BR	CLEOF1

CLEOFX:	POP	PPY(U)
	BR	CLEOX		;RESTORE ALL THAT OTHER STUFF

;HERE TO HOME UP

HU:	MOV	PPORG(U),PPCC(U)	;RESET MA
	MOV	PPORG(U),PPLCC(U)
	MOV	#-NLINS,PPY(U)
	BR	CR1			;SET CHARACTER PHASE AND X

;HERE TO FORWARD SPACE

FS:	JMP	LEDADC
;DATA POINT ROUTINES CONTINUED

;HERE TO SET CURSOR GIVEN A DATAPOINT COORDINATE PAIR (X,Y)
;X AND Y ARE IN A AND B RESPECTIVELY, (0,0) IS UPPER LEFTHAND CORNER
;(1,3) IS THE SECOND CHARACTER OF FOURTH LINE

SETXY:	CMP	#CHRPL,A		;CHECK FOR LEGAL POSITION
	BLOS	SETXY1
	CMP	#CHRLN,B
	BLOS	SETXY1
SETXY0:	MOV	#MQ,T			;FOR THE MYRIAD MULTIPLIES AND DIVIDES
	MOV	B,(T)+			;Y POSITION
	MOV	#BYTPL*LINHT,(T)	;FIND ORIGIN OF LINE IN MEMORY
	MOV	-(T),PPCC(U)
	MOV	(T),PPLCC(U)
	MOV	A,(T)+			;X POSITION
	MOV	#CHRWD,(T)
	MOV	-(T),PPX(U)		;BITS FROM LEFT OF SCREEN
	CLR	-(T)			;CLEAR OUT AC
	MOV	#20,-(T)		;DIVIDE GIVES WORDS FROM LEFT AND PHASE
	TST	(T)+
	MOV	(T)+,PPPHS(U)		;PHASE
	ASL	(T)			;BYTES FROM BEGIN OF LINE
	ADD	(T),PPCC(U)		;LEAVE T POINTING AT MQ
	ADD	#-BITPL,PPX(U)		;THAT'S ALL DONE
	NEG	PPPHS(U)
	ADD	#20-CHRWD,PPPHS(U)	;PHASE IS SET
	MOV	B,(T)+			;Y POSITION AGAIN
	MOV	#LINHT,(T)
	MOV	-(T),PPY(U)
	ADD	#-NLINS,PPY(U)		;PPY SET
	CMP	PPORG(U),#TVLO
	BEQ	.+4
	BPT				;NOT PREPARED TO HANDLE THAT PROBLEM
	ADD	PPORG(U),PPCC(U)
	ADD	PPORG(U),PPLCC(U)
	BIT	#1,PPCC(U)		;MAKE SURE IT LINES UP ON WORD BOUNDARY
	BEQ	.+4
	BPT
SETXY1:	RTS	PC

;OUTSTR TAKES STRING TO PRINT IN B

OUTSTR:
OUTS1:	MOVB	@(SP),A
	INC	(SP)
	TST	A
	BEQ	OUTSX
	CMP	#12,A
	BEQ	OUTSLF
	CMP	#15,A
	BEQ	OUTSCR
	JSR	PC,TVO
	BR	OUTS1
OUTSLF:	JSR	PC,LF
	BR	OUTS1
OUTSCR:	JSR	PC,CR
	BR	OUTS1
OUTSX:	ASR	(SP)	;MAKE SURE WE RETURN TO EVEN ADDRESS
	ADC	(SP)
	ASL	(SP)
	RTS	PC

;TAKES # IN A AND PRINTS AS UNSIGNED INTEGER

OCTPNT:	PUSH	RADIX
	MOV	#10,RADIX
OCTPN1:	JSR	PC,DECPN0
	POP	RADIX
	RTS	PC

DECPNT:	PUSH	RADIX
	MOV	#10.,RADIX	;FOR DECIMAL PRINTING
	BR	OCTPN1

DECPN0:	MOV	A,MQ		;INTO EAE
DECPN9:	MOV	#AC,A		;FOR FAST ACCESS
DECPN1:	MOV	RADIX,-(A)	;DIVIDE BY RADIX
	TST	(A)+		;POINTS AT AC
	MOV	(A)+,-(SP)	;REMAINDER
	ADD	#'0,(SP)
	TST 	(A)		;QUOTIENT IS IN MQ
	BEQ	DECPN2
	CLR	-(A)		;FLUSH OUT AC, LEAVING MQ UNTOUCHED
	JSR	PC,DECPN1	;RECURSIVE YET!
DECPN2:	POP	A		;TYPE OUT THAT DIGIT
	JMP	TVO		;TYPES DIGIT AND ADVANCES CURSOR
.SBTTL CALL, BREAK AND ESCAPE ROUTINES

;LEGAL ESCAPE AND BREAK COMMAND TABLE

ESCHAR:	.BYTE '0,'1,'2,'3,'4,'5,'6,'7		;OCTAL ONLY, DON'T DISTURB DIGITS
	.BYTE 'C,'R,'S,'W,'U,'Q,'F,'D
NESCMD==.-ESCHAR
	.BYTE 0					;MARKS END OF TABLE
	.EVEN

;DISPATCH TABLE

ESCTAB:	.REPT 10
	.NLIST
	ESCDIG		;DIGIT
	.LIST
	.ENDR
	BOWXOR		;TOGGLE BLACK ON WHITE BIT
	ESCCLR		;CLEAR SCREEN
	VSWSEL		;SELECT VIDEO CHANNEL
	ESCWHO		;WHO LINE CONTROL
	ESCWHO		;WHO LINE CONTROL
	ESCQPY		;CAUSE A HARD COPY TO EXIST
	ESCFRE		;SAME AS S, BUT TO CONSOLE FREE BUFFER
	ESCBUZ		;BUZZ 9TH FLOOR DOOR
CHECK ESCTAB,NESCMD*2

;HERE FOR BREAK

BREAK:	BPT
RTSPC4:	RTS	PC

;HERE FOR ESCAPE

ESCAPE:	MOV	KBDLE(C),U	;LINE EDITOR THERE?
	BEQ	RTSPC4
	MOVB	A,LEBRK(U)	;TRIP SWITCH
	CLR	LEBARG(U)	;DEFAULT TO ZERO
	RTS	PC

;ACCUMULATE ARGS FOR ESCAPE AND BREAK

ESCDIG:	ASR	T		;DIGIT
	MOV	LEBARG(U),A	;MULTIPLY ACCUMULATED VALUE BY 8
	ASL	A
	ASL	A
	ASL	A
	ADD	T,A
	MOV	A,LEBARG(U)
	RTS	PC

;TAKES CHARACTER IN A AND CONVERTS IT UPPER CASE

UPPER:	TST	A		;MAKE SURE ITS LEGAL ASCII
	BLE	UPPER1
	CMP	#'a,A		;LOWER CASE?
	BGT	UPPER1
	CMP	#'z,A
	BLT	UPPER1
	SUB	#'a-'A,A	;MAKE IT UPPER CASE
UPPER1:	RTS	PC

;CHANGE STATE OF BOW BIT

BOWXOR:	MOVB	#CXOR,CALU
	MOV	#BOWBIT,CSA
	RTS	PC

;HERE TO CLEAR SCREEN

ESCCLR:	MOVB	CREG,T		;THE SCREEN TO CLEAR
	PUSH	T

	BLKOFF	T
	JSR	PC,CLBLIN	;CLEAR ALL BLINKERS
	JSR	PC,CLRSCR	;CLEAR THE SCREEN
	BIC	#CSAMSK,CSA	;RESET THE SCROLL REGISTER
	POP	T
	BLKON	T

	RTS	PC

;HERE TO SELECT VIDEO SWITCH INPUT

VSWSEL:	MOV	LEKBD(U),T	;KEYBOARD
	BLT	RTSPC4		;GARBAGE?
	MOVB	KBDVSW(T),T	;OUTPUT TO DRIVE
	BLT	RTSPC4		;NO DEFAULT?
VSWSL0:	MOV	LEBARG(U),TT	;GET ARG
	BNE	VSWSL1		;SELECT DEFAULT?

	MOVB	LECREG(U),TT	;GET DPY # TO SET DEFAULT
	BLT	RTSPC4		;GARBAGE?
	ASL	TT
	MOV	DPYVSW(TT),TT	;DEFAULT VIDEO SWITCH INPUT
	BR	VSWL2		;DON'T NEED TO CHECK THIS

VSWCMD:	CMP	#VSWO,T		;CHECK FOR LEGAL OUTPUT
	BLOS	RTSPC4
VSWSL1:	CMP	#MAXVSI*VSWSEC,TT
	BLOS	RTSPC4		;REASONABLE?
	PUSH	TT		;CALCULATE SECTION AND INPUT
	MOV	#MQ,TT
	MOV	(SP),(TT)
	CLR	-(TT)
	MOV	#MAXVSI,-(TT)	;DIVIDE
	TST	(TT)+
	MOV	(TT)+,(SP)	;INPUT # TO STACK
	TST	(TT)+		;SKIP OVER SECTION #
	MOV	#VSWINC,(TT)	;MULTIPLY
	BIS	-(TT),(SP)	;SECTION AND INPUT
	POP	TT
VSWL2:	PUSH	T
	PUSH	TT
	JSR	PC,VSWNUL	;SEND NULL TO THAT OUTPUT
	POP	TT
	POP	T
	JMP	VSWIT		;SWITCH THE SWITCH

ESCFRE:	MOV	LEKBD(U),T	;NADLE [ESC]F - SPY ON FREE-CONSOLE SCREEN.
	BLT	RTSPC4
	MOVB	KBDVSW(T),T	;THIS PART IS LIKE [ESC]S.
	BLT	RTSPC4
	MOV	DPYFRE,TT	;GET DPY # OF FREE CONSOLE SCREEN
	ASL	TT
	MOV	DPYVSW(TT),TT	;AND GET VIDEO SWITCH SECTION AND INPUT FOR IT.
	BR	VSWL2
;HERE TO GENERATE VIDEO HARD COPY

ESCQPY:	TST	QPYSWT		;IS THE SWITCH LOCKED?
	BEQ	ESCQP1
	JMP	BELL		;SOME ONE ELSE IS COPYING, GIVE HIM A BELL
ESCQP1:	MOV	LEKBD(U),T	;TO USE THE CLOCK QUEUE MECHANISM
	BLT	RTSPC4
	MOV	#QPYVSW,T	;THE VIDEO SWITCH OUTPUT FOR THE HARD COPY UNIT
	JSR	PC,VSWSL0	;PROCESS THE ARG
	CHROFF
	ZAPFLG	QPYSWT		;LOCK THE SWITCH
	BIS	#QPYKMS,KMS	;CAUSE THE COPY
	JSR	TT,ADQUE	;SCHEDULE THE UNCOPY
		2
		ESCQP2
	JSR	TT,ADQUE	;SCHEDULE THE SWITCH UNLOCK
		QPTIME
		ESCQP3
RTSON:	CHRON
	RTS	PC	

ESCQP2:	BIC	#QPYKMS,KMS	;UNCAUSE THE COPY
	RTS	PC

ESCQP3:	CLR	QPYSWT
	RTS	PC

;HERE TO BUZZ 9TH FLOOR DOOR
ESCBUZ:	TST	BUZSWT		;IS THE SWITCH LOCKED?
	BEQ	ESCBZ1
	JMP	BELL
ESCBZ1:	CHROFF
	ZAPFLG	BUZSWT		;LOCK SWITCH
	BIS	#BUZKMS,KMS	;BUZZ THE DOOR
	JSR	TT,ADQUE	;SCHEDULE THE UNBUZZ
		BUZTIM
		ESCBZ2
	BR	RTSON

ESCBZ2:	BIC	#BUZKMS,KMS	;UNBUZZ THE DOOR
	CLR	BUZSWT		;UNLOCK THE SWITCH
	RTS	PC
;HERE TO CONTROL WHO LINE

;	  [ESC]<N>W		      WHMODE
;	N=0	TURN OFF WHO LINE      -1
;	  1	FOLLOW KEYBORAD		0
;	  2	FREEZE			1
;	  3	NEXT HIGHER		2
;	  4	NEXT LOWER		3
;ALL OTHERS	SYSTEM WHO LINE

;	  [ESC]<N>U
;FREEZES WHOLINE ON JOB WHOSE USER INDEX IS N*L (L IS THE ITS SYMBOL).

NWHCMD==5	;NUMBER OF WHO COMMANDS

ESCWHO:	MOV	LEPP(U),TT	;PAGE PRINTER
	MOV	PPCHN(TT),TT	;10/11 CHANNEL
	ASL	TT		;MAKE IT CHANNEL INDEX
	ASL	TT
	MOV	WHOLIN(TT),TT	;WHO LINE VARIABLES
	CMPB	A,#'U
	BEQ	ESCWHU
	MOV	LEBARG(U),T	;ARGUMENT
	DEC	T		;HACK
	BMI	ESCWH2		;TURN IT OFF?
	MOV	T,WHMODE(TT)	;SET THE MODE WE WANT
ESCWU1:	CLR	WHMOD1(TT)	;JUST TO BE SURE
	MOV	#-1,TENWHO	;TELL PDP-10 TO UPDATE WHO LINES
	RTS	PC

;TURNS OFF WHO LINE

ESCWH2:	;CLEAR WHO LINE AT MAIN PROGRAM LEVEL TOO
	MOV	T,2(TT)		;(T HAS -1 IN IT)
	MOV	T,WHMODE(TT)	;AND TURN IT OFF
	BR	CLRWHL

ZAPWHL:	MOV	DPYCHN(B),A	;SET UP CREG
	MOV	DPYPP(A),A
	MOVB	PPCREG(A),CREG
CLRWHL:	MOV	#TVLO+<LINHT*CHRLN*BYTPL>,T
	MOV	#CHRHT-1,TT
	JMP	CLRCL0

ESCWHU:	MOV	#1,WHMODE(TT)
	MOV	LEBARG(U),WHJOB(TT)
	CLR	WHJOB1(TT)
	BR	ESCWU1
;COME HERE FOR CALL KEY

CALL:	MOV	KBDLE(C),U	;LINE EDITOR VARIABLES
	BNE	UPTREE		;GET FRESH LINE EDITOR?
	JSR	PC,LECONS	;CONS UP LINE EDITOR VARIABLES
	PUSH	U
	BEQ	CNOLE		;FAILURE?
	ASR	C		;GET BACK REAL KBD
	TSTB	KBDVSW(C)	;DOES THIS KBD HAVE VIDEO?
	BLT	NODPY1		;RETURNS THE KBD BUFFERS
	MOV	C,LEKBD(U)	;INTO LINE EDITOR VARIABLES
	JSR	PC,DPCONS	;FIND FREE DPY
	PUSH	TT
	BLT	CNODPY		;FAILURE?
	JSR	PC,PPCONS	;GET PAGE PRINTER
	MOV	U,TT
	BEQ	CNOPP		;FAILURE?
	POP	C		;DPY
	POP	U		;LINE EDITOR
	MOV	LEKBD(U),T	;SET UP KBDLE
	ASL	T
	MOV	U,KBDLE(T)
	MOV	U,PPLE(TT)	;LET PAGE PRINTER KNOW ABOUT LINE EDITOR
	MOV	TT,LEPP(U)	;AND VICE VERSA
	MOV	C,PPCREG(TT)
	MOV	C,LECREG(U)
	JSR	PC,CHCONS	;GET 10/11 DPY CHANNEL
	BGE	.+4
	BPT			;THERE OUGHT TO BE ONE IF THERE'S A PAGE PRINTER
	MOV	T,PPCHN(TT)	;PAGE PRINTER IN USE
	MOV	C,CREG
	ASL	T		;SET DPYPP
	ASL	T
	MOV	DPYCHN(T),T
	MOV	TT,DPYPP(T)
	JSR	PC,CLRSCR	;THIS DOES NOT WANT TO HAPPEN AT INTERUPT LEVEL!!
	CLR	CSA		;CLRSCR SETS UP CALU
	MOV	LEKBD(U),T	;GET KEYBOARD MUBER
	MOVB	KBDVSW(T),T	;VIDEO SWITCH OUTPUT
	JSR	PC,VSWNUL	;SEND NULL TO THAT TV
	ASL	C		;GET BLINKER FOR LINE EDITOR CURSOR
	MOV	DPYVSW(C),TT	;SWITCH VIDEO SWITCH, GET INPUT AND SECTION
	JSR	PC,VSWIT	;SWITCHES THE SWITCH
	MOV	FBLINK,T	;CONS UP A BLINKER FOR THE CURSOR
	BEQ	UPTREE		;ARE THERE FREE BLINKERS?

	CHROFF
	MOV	BLNEXT(T),FBLINK
	MOV	BLINKS(C),BLNEXT(T)
	MOV	T,BLINKS(C)	;THE BLINKER
	MOV	T,LEBLNK(U)
	TST	(T)+
	MOV	LEPP(U),(T)+	;FOLLOW PAGE PRINTER
	CLRB	(T)+		;BLON
	MOVB	#177,(T)+	;DEFAULT BLINKER
	CHRON

	MOV	LEPP(U),TT
	MOV	PPCHN(TT),C	;PLANT DPY CHANNEL # IN KEYBOARD RING INSTEAD
	MOV	C,LECHN(U)
	ASL	C		;OF KBDNUM (SIGH)
	MOV	LEBUF(U),T
	JSR	PC,CLRING
	ASL	C
	MOV	LEKBD(U),CHNCLS(C)
	MOVB	LEKBD(U),DPYKBD(C)	;TELL THE PDP-10
	MOVB	LECREG(U),DPYKBD+1(C)	;ABOUT THE DPY TOO
	MOV	WHOLIN(C),A
	MOV	#-1,WHMODE(A)	;TURN OFF WHO LINE
;HERE IF CALL AND LINE EDITOR

UPTREE:	MOV	#32,A		;CONTROL-Z (SIGH)
	BIS	#ACTBIT,B	;ACTIVATES BUFFER
	JMP	PUTCHR		;SEND THAT CHARACTER TO PDP-10

;VARIOUS ERROR RETURNS COME HERE

CNOPP:	POP	TT		;NO PAGE PRINTER, FREE THE DPY AND LINE EDITOR
	JSR	PC,DPRETN	;FREE THE DPY
	BR	NODPY1

CNODPY:	POP	U		;NO DPY, FREE LINE EDITOR
NODPY1:	POP	U
	JMP	LERETN		;FREE LINE EDITOR VARIABLES

CNOLE:	POP	 U		;NO LINE EDITOR, CLEANSE STACK AND RETURN
RTSPC2:	RTS	PC
;HERE TO CONS UP A SET OF LINE EDITOR VARIABLES

LECONS:	MOV	#LEUVAR,U	;START SEARCH HERE	
LECON1:	TST	LEKBD(U)	;IS THIS SET FREE?
	BLT	LECON2
	ADD	#LELEN,U	;TRY NEXT SET
	CMP	#LEUEND,U
	BHI	LECON1
	BR	CLRUJ

;FOUND FREE SET OF VARIABLES, SET DEFAULTS AND GET KBD RING

LECON2:	PUSH	U
	MOV	U,TT		;SET DEFAULTS
	MOV	#LEDFLT,T
	MOV	#LELEN,U
	JSR	PC,CALCPY	;DEFAULT IS FOR FREE VARIABLES
	POP	U
	MOV	FSP,T		;FIRST FREE BUFFER
	BEQ	CLRUJ
	MOV	LHFS(T),TT	;NEXT BUFFER
	BEQ	CLRUJ
	MOV	LHFS(TT),FSP	;TAKE THOSE TWO
	MOV	T,LHNEXT(TT)
	MOV	TT,LHNEXT(T)	;ALL NICE AND COZY
	MOV	T,LEBUF(U)	;POINTER TO RING
	JSR	PC,CLRING	;CLEARS THE RING
	ADD	#LHLEN,T
	MOV	T,LECHR(U)	;BUFFER ACCESS POINTER
	MOV	T,LECUR(U)	;CURSOR POSITION
	TST	U
	RTS	PC

;HERE TO RETURN A LINE EDITOR VARIABLES

LERETN:	MOV	LEBUF(U),T	;RETURN BUFERS IN RING
	BEQ	LERT2A		;BUFFERS TO RETURN?
	PUSH	T
LERET1:	MOV	LHNEXT(T),LHFS(T)
	CMP	LHFS(T),(SP)
	BEQ	LERET2
	MOV	LHFS(T),T
	BR	LERET1
LERET2:	MOV	FSP,LHFS(T)	;CUT RING, PATCH ON TO FREE LIST
	POP	FSP
	CLR	LEBUF(U)	;MARK AS FREE
LERT2A:	MOV	LEKBD(U),T
	BLT	LERT2B		;A KEYBOARD?
	ASL	T		;BYTES
	CLR	KBDLE(T)
LERT2B:	MOVB	LECREG(U),T	;RETURN ALL THE BLINKERS
	BLT	LERET5		;A DPY?
	MOVB	#-1,LECREG(U)	;INVALIDATE DPY #
	ASL	T
	MOV	BLINKS(T),TT
	BEQ	LERET5
LERET3:	TST	BLNEXT(TT)
	BEQ	LERET4
	MOV	BLNEXT(TT),TT
	BR	LERET3
LERET4:	MOV	FBLINK,BLNEXT(TT)
	MOV	BLINKS(T),FBLINK
	CLR	BLINKS(T)
LERET5:	MOV	#-1,LEKBD(U)
CLRUJ:	CLR	U		;SEARCH FAILED
	RTS	PC
;HERE TO FIND FREE DPY, RETURNS DPY IN TT

DPCONS:	MOV	#MAXTV-1,TT	;START SEARCH HERE
DPCON1:	TSTB	DPYUSE(TT)	;THIS INPUT FREE
	BEQ	DPCON2
	DEC	TT		;ADVANCE TO NEXT
	BGE	DPCON1
DPCON3:	RTS	PC		;NONE FREE
DPCON2:	DEC	ITSFDP
	INCB	DPYUSE(TT)	;INCREMENT USE COUNT
	BGT	DPCON3
	BPT			;ILLEGAL

;HERE TO FREE DPY

DPRETN:	INC	ITSFDP
	DECB	DPYUSE(TT)	;DECREMENT FREE COUNT
	BGE	DPCON3
	BPT			;ILLEGAL

;HERE TO CONS UP A DPY CHANNEL

CHCONS:	MOV	#MAXPP-1,T
CHCON1:	TSTB	CHNUSE(T)
	BEQ	CHCON2
	DEC	T
	BGE	CHCON1
	RTS	PC		;NO FREE CHANNEL

CHCON2:	INCB	CHNUSE(T)	;FOUND A CHANNEL
	RTS	PC

;HERE TO RETURN DPY CHANNEL

CHRETN:	DECB	CHNUSE(T)
	BGE	.+4
	BPT
	RTS	PC
;HERE TO CONS UP PAGE PRINTER AND DPY BUFFER, CALL WITH KBD IN C

PPCONS:	MOV	#PPUVAR,U	;START HERE
PPCON1:	TST	PPCHN(U)	;ARE THESE FREE
	BLT	PPCON2
	ADD	#PPLEN,U	;ADVANCE TO NEXT
	CMP	#PPUEND,U	;PAST END?
	BHI	PPCON1
	BR	CLRUJ		;NONE FOUND

;HERE TO GET DPY BUFFER

PPCON2:	PUSH	U
	MOV	U,TT		;SET DEFAULTS
	MOV	#PPLEN,U
	MOV	#PPDFLT,T
	JSR	PC,CALCPY
	POP	U
	RTS	PC

;HERE TO RETURN PAGE PRINTER VARIABLES

PPRETN:	MOV	#-1,PPCHN(U)
	RTS	PC

;HERE TO SET UP A DPY CHANNEL	RETURNS CHANNEL HEADER IN U

CHNSET:	CHROFF
	MOV	FSP,T		;GET FREE DPY BUFFER
	BEQ	CHNS0		;ANY FREE?
	MOV	LHFS(T),FSP	;TAKE THAT ONE
	MOV	T,TT
CHNS0:	CHRON

	MOV	T,U
	BEQ	CLRUJ
	ADD	#DPDATA,TT	;ORIGIN OF DATA AREA
	MOV	TT,(T)+
	MOV	TT,(T)+		;DPY11B
	CLR	(T)+		;DPYPP
	ADD	#LBLEN-DPDATA+DPLEN-2,TT	;LAST LEGAL BUFFER ADDRESS
	MOV	TT,(T)+		;DPYLGL
	MOV	#LBLEN,TT	;DPYSIZ
	MOV	TT,(T)+
	CLR	(T)+		;DPYZER
	ASR	TT		;WORD COUNT
CHNS1:	MOV	#-1,(T)+	;FILL WITH -1
	DEC	TT
	BGT	CHNS1
	RTS	PC
.SBTTL VIDEO AND AUDIO SWITCH ROUTINES
.XLIST
.IF1
.MACRO SWCODE X

;RESET VIDEO SWITCH

RE'X'SW:	CLR	C		;HOLDS SWITCH SECTION
	CLR	T		;X'SW, USE INPUT 0
	MOV	#X'SW,TT
	MOV	#X'SWSEC,A	;# SWITCH SECTIONS
RE'X'SW0:	MOV	#MAX'X'SO,B	;# OUTPUTS
RE'X'SW1:	MOV	T,(TT)		;ZAP SWITCH
	ADD	#400,T		;INCREMENT SECTION FIELD
	DEC	B		;ONCE FOR EACH OUTPUT
	BGT	RE'X'SW1
	ADD	#X'SWINC,C	;ADVANCE TO NEXT SECTION
	MOV	C,T
	DEC	A
	BGT	RE'X'SW0

;NOW RESET THE INPUT TABLES

	MOV	#<X'SWSEC-1>*2,A
RE'X'SW2:	MOV	#MAX'X'SI-1,C	;ONCE FOR EACH INPUT
	MOV	X'SWI(A),B	;ORIGIN OF SECTION TABLE
	CLRB	(B)+		;INPUT ZERO DRIVES OUTPUT 0
RE'X'SW3:	MOVB	#-1,(B)+	;ALL OTHER INPUTS UNUSED
	DEC	C
	BGT	RE'X'SW3
	SUB	#2,A		;ADVANCE TO NEXT SECTION OF SWITCH
	BGE	RE'X'SW2

;NOW RESET THE OUTPUT TABLES

	MOV	#<X'SWSEC-1>*2,A
RE'X'SW4:	MOV	#MAX'X'SO,C	;ONCE FOR EACH OUTPUT
	MOV	X'SWO(A),B	;ORIGIN OF OUTPUT TABLE
	CLR	T		;USED TO RING TO NEXT OUTPUT
RE'X'SW5:	CLRB	(B)+		;INPUT 0 DRIVES THIS OUTPUT
	INC	T
	MOVB	T,(B)+		;RING THE OUTPUTS
	DEC	C
	BGT	RE'X'SW5
	CLRB	-(B)		;CLOSE THE RING ON THIS SECTION
	SUB	#2,A		;ADVANCE TO NEXT SECTION
	BGE	RE'X'SW4
	RTS	PC		;WHEW!!

;HERE SEND NULL VIDEO TO OUTPUT SPCEIFIED IN T

X'SWNUL:	PUSH	T		;OUTPUT
	PUSH	#0		;SECTION AND INPUT
	PUSH	#X'SWSEC		;# SECTIONS
X'SWN1:	MOV	4(SP),T		;OUTPUT
	MOV	2(SP),TT	;SECTION AND INPUT
	JSR	PC,X'SWIT	;SWITCH IT
	ADD	#X'SWINC,2(SP)	;ADVANCE TO NEXT SECTION
	DEC	(SP)
	BGT	X'SWN1		;MORE
	CMP	(SP)+,(SP)+	;CLEANSE STACK
	POP	T
	RTS	PC
;HERE TO SWITCH VIDEO SWITCH (OUTPUT IN T, INPUT AND SWITCH SECTION IN TT)

X'SWIT:	PUSH	A
	PUSH	B		;SAVE THESE AC'S
	PUSH	C
	PUSH	TT
	MOV	TT,AC		;EXTRACT SECTION #
	MOV	#-15,LSH	;FLUSH GARBAGE
	MOV	AC,C		;SECTION
	ASL	C		;BYTES
	MOV	C,B		;SAVE SECTION*2
	BIC	#177400,TT	;FLUSH SECTION INFO
	MOV	X'SWO(C),C	;FIND OUPUT TABLE ENTRY
	MOV	T,A		;OUTPUT
	ASL	A		;OUTPUT*2
	ADD	A,C
	CMPB	(C),TT		;DO WE REALLY NEED TO SWITCH THE SWITCH?
	BNE	X'SWIT1
	TST	(SP)+		;CLEANSE STACK
X'SWIT0:	POP	C
	POP	B
	POP	A
	RTS	PC

;WE ARE NOW COMMITTED TO SWITCHING THE SWITCH

X'SWIT1:	SWAB	T		;PUT OUTPUT IN RIGHT PLACE
	BIS	T,(SP)
	POP	X'SW		;SWITCHES SWITCH
	SWAB	T
	PUSH	B		;SECTION*2
	PUSH	C		;WILL BE OUTPUT SECTION TABLE
	SUB	A,(SP)		;ORIGIN OF OUTPUT TABLE
	MOV	C,A		;WHERE WE STARTED
X'SWIT2:	CMPB	1(C),T		;MATCH?
	BEQ	X'SWIT3		;FOUND PREVIOUS RING ENTRY
	JSR	PC,X'SWIT9	;ADVANCE TO NEXT ON RING
	CMP	A,C		;ALL THE WAY AROUND RING?
	BNE	X'SWIT2
	BPT			;INPUT NOT ON THIS RING

X'SWIT3:	MOV	2(SP),A
	JSR	PC,X'SWIT8	;GETS INPUT ENTRY POINTING TO RING
	MOV	C,B		;POINT AT PREVIOUS NODE ON RING
	JSR	PC,X'SWIT9	;C POINTS AT THIS ONE
	CMP	B,C
	BNE	X'SWT3A		;ARE WE FREEING THIS INPUT?
	MOVB	#-1,(A)
	BR	X'SWT3B
X'SWT3A:	MOVB	1(C),1(B)	;PATCHES THIS ONE OUT
	MOVB	1(C),(A)	;MAKE INPUT TABLE POINT TO KNOWN WINNER
X'SWT3B:	MOVB	TT,(C)		;FIX THE INPUT DRIVING THIS ONE
	MOVB	T,1(C)		;MAKE IT POINT TO ITSELF
	POP	B		;CLEANSE STACK
	MOV	(SP),A		;SWITCH SECTION
	JSR	PC,X'SWIT8
	TSTB	(A)		;THIS INPUT USED?
	BGE	X'SWIT4
	MOVB	T,(A)		;INPUT UNUSED, CLOBBER

X'SWIT4:	POP	TT		;SWITCH SECTION
	MOV	X'SWO(TT),TT
	MOVB	(A),B		;OUTPUT ON RING
	ASL	B		;BYTES
	ADD	TT,B		;POINTS INTO TABLE
	MOVB	1(B),1(C)	;PUT INTO RING
	MOVB	T,1(B)
	BR	X'SWIT0

;HERE TO ADVANCE TO NEXT NODE ON RING

X'SWIT9:	MOVB	1(C),C		;OUTPUT #
	BIC	#177400,C
	ASL	C		;BYTES
	ADD	2(SP),C		;TABLE ORIGIN
	RTS	PC

;TAKES OUTPUT TABLE ENTRY POINTER IN C
;RETURNS POINTER TO INPUT TABLE ENTRY IN A

X'SWIT8:	PUSH	C
	MOVB	(C),C		;INPUT
	MOV	X'SWI(A),A	;APPROPRIATE TABLE
	ADD	C,A		;THAT'S THE ONE
	POP	C
	RTS	PC
;VIDEO SWITCH TABLES (ONE INPUT CAN DRIVE MANY OUTPUTS)

;THE SWITCH IS COMPOSED OF SEVERAL IDENTICAL SECTIONS, THE CORRESPONDING
;OUTPUTS OF EACH SECTION ARE MIXED TOGETHER TO FORM THE FINAL VIDEO THAT IS
;SENT TO THE MONITOR.  INPUT 0 OF EACH SECTION OF THE SWITCH IS THE NULL INPUT,
;HENCE WE USUALLY USE THAT INPUT WHEN USING A MONITOR AS A DISPLAY.

;EACH SECTION OF THE SWITCH AS TWO TABLES.  

;X'SWI	ONE ENTRY FOR EACH INPUT (EACH ENTRY 1 BYTE)
;	OUTPUT BEING DRIVEN BY THIS INPUT

;X'SWO	ONE ENTRY FOR EACH OUTPUT (EACH ENTRY 1 WORD)
;	OUTPUT,,INPUT	OUTPUTS DRIVEN BY THE SAME INPUT ARE RINGED TOGETHER

.MACRO X'SWIO SEC
X'SWI'SEC:	.=.+MAX'X'SI
X'SWO'SEC:	.=.+<MAX'X'SO*2>
.ENDM

.MACRO X'SWTAB

.REPT X'SWSEC
.NLIST
X'SWIO \.RPCNT
.LIST
.ENDR

X'SWI:	.REPT X'SWSEC
.NLIST
	CONC X'SWI,\.RPCNT
.LIST
	.ENDR

X'SWO:	.REPT X'SWSEC
.NLIST
	CONC X'SWO,\.RPCNT
.LIST
	.ENDR
.ENDM	;X'SWTAB
.ENDM	;SWCODE
.ENDC	;IF1
.LIST

SWCODE V
SWCODE A

.SBTTL 10/11 INPUT/OUTPUT ROUTINES

;CLEARS HEADERS OF BUFFER RING, CALLED WITH RING IN A, KBD*2 IN C

CLRING:	PUSH	T
	MOV	C,TT
	ASR	TT
CLRNG1:	CLR	(T)+	;LHFLAG
	CLR	(T)+	;LHZERO
	TST	(T)+	;LHNEXT
	CLR	(T)+	;LHALST
	MOV	TT,(T)	;LHKBD
	TST	-(T)
	MOV	-(T),T	;NEXT ON RING
	CMP	(SP),T
	BNE	CLRNG1
	POP	T
	RTS	PC

;HERE TO COPY A BLOCK OF CORE
:	TT SOURCE
;	 T DESTINATION
;	 U BYTE COUNT (ONLY EVEN NUMBERS WILL WORK)

CALCPY:	INC	U		;MAKE A WORD COUNT
	ASR	U
CALCP1:	MOV	(T)+,(TT)+
	DEC	U
	BGT	CALCP1
	RTS	PC

;HERE TO COMPLEMENT STATE OF BOW BIT WHEN PDP-10 FALLS BEHIND ON KBD

SLOW10:	MOVB	LECREG(U),CREG
	JMP	BELL		;RING BELL


;PUT CHARACTER INTO BUFFER ACTIVATES IF
;	1	FINDS ACTIVATION CHARACTER
;	2	BUFFER FILLS

PUTCHR:	TST	@LEBUF(U)
	BGT	PUTCH0			;BUFFER BEING FILLED?
	BLT	SLOW10			;HAS PDP-10 FALLEN BEHIND?
	MOV	#LBCHRS,@LEBUF(U)	;MARK BUFFER BUSY WITH # FREE CHARACTERS
PUTCH0:	TST	LEFREE(U)		;ANY ROOM LEFT IN BUFFER?
	BGT	PUTCH2
	BEQ	.+4			;NOPE, DO SOME ERROR CHECKING
	BPT				;LOSE IF LESS THAN NO ROOM
	MOV	LEBUF(U),T
	TST	LHQUED(T)		;OK IF QUEUED TO ACTIVATE LATER
	BEQ	SLOW10
	BPT				;FULL BUT NOT ACTIVATED OR QUEUED - LOSE
PUTCH2:	MOV	A,@LECHR(U)
	BIS	B,@LECHR(U)
	ADD	#2,LECHR(U)
	DEC	LEFREE(U)		;BUFFER FULL?
	BGT	PUTCH4
	BEQ	.+4			;WE MUST ACTIVATE ANYWAY
	BPT
	MOV	LEBUF(U),T
	TST	LHQUED(T)		;IF ALREADY QUEUED TO ACTIVATE,
	BEQ	ACTIVA			; DON'T ACTIVATE NOW
	RTS	PC

PUTCH4:	TST	B
	BGE	RTSPC1			;NOT ACTIVATING
	MOV	LEBUF(U),T		;ACTIVATION CHAR, MUST ACTIVATE
	TST	LHQUED(T)		;IF ALREADY QUEUED TO ACTIVATE,
	BNE	RTSPC1			; DON'T ACTIVATE NOW
	TST	@LHNEXT(T)		;TEST NEXT BUFFER IN RING
	BMI	QBFR			;IF NOT FREE, TRY ACTIVATION ON NEXT CLOCK TICK

;HERE TO ACTIVATE BUFFER

ACTIVA:	SUB	#LBCHRS,LEFREE(U)	;NEGATIVE OF ACTIVE CHARS
	BLT	.+4
	BPT				;HAD BETTER BE NEGATIVE
	MOV	LEBUF(U),T		;THE BUFFER TO ACTIVATE
	MOV	LEFREE(U),LHFLAG(T)	;THAT ACTIVATES IT

	CHROFF
	CLR	LHALST(T)		;PUT THIS ONE AT END CHAIN
	PUSH	KBDLAST
	MOV	T,KBDLAST
	POP	T
	BNE	ACTIV0			;EMPTY ACTIVATION LIST?
	MOV	KBDLAST,KBDACT		;YES, MAKE ACTIVE LIST POINT TO THIS ONE
	BR	ACTV0A
ACTIV0:	MOV	KBDLAST,LHALST(T)	;OLD LAST POINTS TO NEW LAST
ACTV0A:	MOV	KBDLAST,T		;IN ANY EVENT THIS THE ONE JUST ADDED
	TST	KBDFLG			;DOES THE PDP-10 WANT MORE
	BNE	ACTIV1
	MOV	KBDACT,KBDFLG		;ACTIVATE THIS LIST
	CLR	KBDACT			;AND PREPARE FOR NEXT
	CLR	KBDLAST
ACTIV1:	CHRON

	MOV	LHNEXT(T),T		;NEXT ON RING
	MOV	#LHLEN,TT
	ADD	T,TT			;FIRST FREE CHARACTER
	MOV	T,LEBUF(U)		;NEW BUFFER
	TST	(T)+			;LHFLAG IS SET AT PUTCHR
	CLR	(T)+			;LHZERO
;	CMP	(T)+,(T)+		;DON'T HACK LHNEXT AND LHALST
	MOV	TT,LECHR(U)		;FIRST FREE CHARACTER
	MOV	TT,LECUR(U)		;AND THE CURSOR
	MOV	#LBCHRS,LEFREE(U)	;FREE CHARACTERS IN BUFFER
RTSPC1:	RTS	PC

;HERE AT CLOCK LEVEL TO ACTIVATE BUFFER

CLKACT:	PUSH	TT
	PUSH	U
	MOV	(T),U			;THE LINE EDITOR
	MOV	LEBUF(U),T		;THE BUFFER
	TST	LHFLAG(T)
	BGE	.+4
	BPT				;CAN'T ACTIVATE AN ALREADY ACTIVATED BUFFFER
	TST	@LHNEXT(T)		;THE NEXT BUFFER
	BMI	CLKAC1			;ACTIVATE IF READY
	CLR	LHQUED(T)
	JSR	PC,ACTIVA
CLKAC2:	POP	U
	POP	TT
	RTS	PC

CLKAC1:	JSR	PC,QBFR			;NOT, READY TRY ANOTHER CLOCK TICK
	BR	CLKAC2

;HERE IF NEXT BUFFER ON RING IS NOT FREE, TRY ACTIVATION AT NEXT CLOCK TICK

QBFR:	ZAPFLG	LHQUED(T)		;SET FLAG THAT SAYS WE'RE QUEUED
	MOV	U,T			;ARG
	CHROFF				;INHIBIT INTERUPTS WHILE WE DO THIS
	JSR	TT,ADQUE		;PUT ON CLOCK QUEUE
		1			;AT NEXT TICK
		CLKACT			;CLOCK LEVEL ACTIVATION
	CHRON
	RTS	PC

;SAVE ALL ACS ON STACK

ACSAV:	PUSH	TT
	PUSH	T
	PUSH	C
	PUSH	B
	PUSH	A
	PUSH	U		;RETURN ADDRESS
	MOV	14(SP),U	;RESTORE U
	RTS	PC
;GETS NEXT CHARACTER FROM DPY BUFFER

GETCHR:	MOV	@DPY11B(U),A
	BLT	RTSPC1			;HAS TEN PUT GOODIES THERE?
	BIS	#SNB,@DPY11B(U)		;MARK AS TAKEN
	BIT	#2,DPY11B(U)		;AVOID HARDWARE SCREW
	BEQ	GETCH0
	BIC	#2,DPY11B(U)
	BIS	#SNB,@DPY11B(U)
	ADD	#2,DPY11B(U)		;ADVANCE TO NEXT TEN WORD
GETCH0:	ADD	#2,DPY11B(U)
	CMP	DPY11B(U),DPYLGL(U)	;PAST END
	BLOS	GETCH1
	MOV	U,DPY11B(U)
	ADD	#DPDATA,DPY11B(U)	;FIRST WORD OF DATA AREA
GETCH1:	CMP	#177,A			;IGNORE RUBOUTS
	BEQ	GETCHR
	TST	A			;RETURN IN CONDITION CODES
	RTS	PC

;GET NEXT CHARACTER BUT IF NOT AVAILABLE DO A COROUTINE-RETURN
;FROM THE CHARACTER-READING LOOP, SO THAT WHEN THE NEXT CHARACTER
;IS READ THIS CALL WILL BE RETURNED FROM. CLOBBERS T. ASSUMES
;THAT C CONTAINS THE DPY BUFFER HEADER, AND MAY RESET ALL ACS
;BUT B TO WHAT THEY HOLD AT DPYCTL. B IS ALWAYS PRESERVED.
GETCHC:	MOV	U,T
	MOV	C,U
	JSR	PC,GETCHR
	BLT	GETCH2
	MOV	T,U
	RTS	PC

GETCH2:	MOV	B,PPSVB(T)
	POP	PPCPC(T)
	BR	DPYXIT
.SBTTL CHARACTER GENERATOR ROUTINES

;CLEARS CHARACTER AT LINE EDITOR CURSOR

CLRCHR:	JSR	U,ACSAV
	MOVB	#CANDC,CALU
CLCHR1:	MOV	CTAB+<177*2>,T	;RUBOUT MASKS ENTIRE CHARACTER
CLCHR2:	MOV	LEPHS(U),C
	MOV	LECC(U),TT
	JSR	PC,GENCH1
	BR	ACRES

;BLINK CHARACTER AT CURSOR

XORCHR:	JSR	U,ACSAV
	MOVB	#CXOR,CALU
	MOVB	BLCHAR(T),T	;CHARACTER TO BLINK
	ASL	T		;BYTE INDEX
	MOV	CTAB(T),T
	BR	CLCHR2
;the lowest level character generators
;initial AC settings

;A	LSH address of EAE shift counter
;B	MQ address of EAE regiseter
;C	number of desired shifts
;T	points into font description
;TT	points into display memory
;U	number of bytes per line of display memory

;initial memory settings

;AC	0, EAE register
;CREG	CIOR,,console number, console register
;;NOTE THAT MQ=AC+2

;CALL WITH CHARACTER IN A AND PAGE PRINTER IN U
;MUST PRESERVE A -- SEE UWVDO (VIA TVOMSK)

GENCHR:	JSR	U,ACSAV
	MOV	PPPHS(U),C
	MOV	PPCC(U),TT
	MOVB	#CIOR,CALU
	ASL	A		;MAKE IT A BYTE OFFSET
	MOV	CTAB(A),T	;POINTS AT FONT DESCRIPTION
	JSR	PC,GENCH1
ACRES:	POP	A
	POP	B
	POP	C
	POP	T
	POP	TT
	POP	U
	RTS	PC

GENCH1:	MOV	#LSH,A
	TST	C
	BLT	OVRLAP
EZCASE:	MOV	#BYTPL,U
	MOV	#AC,B
	CLR	(B)+		;CLEAR AC

.REPT CHRHT
.NLIST
	MOVB	(T)+,(B)	;5.2	;CHARACTER RASTER LINE INTO MQ
	MOV	C,(A)		;3.7	;INITIATE SHIFT
	MOV	(B),(TT)	;5.2	;OUT OF MQ INTO DISPLAY MEMORY
	ADD	U,TT		;2.3	;GET TO NEXT RASTER LINE
;			TOTAL	16.4 MICRO-SECONDS
.LIST
.ENDR
	RTS	PC

;initial settings same as EZCASE with one exception
;U	<number of bytes per line of display memory>-2

OVRLAP:	MOV	#BYTPL-2,U
	MOV	#MQ+2,B

.REPT CHRHT
.NLIST
	CLR	-(B)		;3.7	;CLEAR MQ
	CLRB	-(B)		;2.3	;CLEAR HIGH ORDER OF AC
	MOVB	(T)+,-(B)	;5.2	;LOAD AC WITH CHARACTER LINE
	MOV	C,(A)		;3.7	;INIATE SHIFT
	MOV	(B)+,(TT)+	;5.2	;AC TO DISPLAY MEMORY
	MOV	(B)+,(TT)	;5.2	;MQ TO DISPLAY MEMORY
	ADD	U,TT		;2.3	;SET TO NEXT RASTER LINE
;			TOTAL	27.6 MICRO-SECONDS
.LIST
.ENDR
RTSPC:	RTS	PC
;SOME LOW LEVEL GOODIES

;CLEARS ONE RASTER LINE

CLRRST:	MOVB	#CSET,CALU
CLRRS1:	.REPT WRDPL
	.NLIST
	CLR	(T)+
	.LIST
	.ENDR
	RTS	PC

;CLEARS ONE CHARACTER LINE

CLRCHL:	MOV	#LINHT-1,TT
CLRCL0:	JSR	PC,CLRRST
CLRCH1:	JSR	PC,CLRRS1
	DEC	TT
	BGT	CLRCH1
	RTS	PC

;CLEAR ENTIRE SCREEN

CLRSCR:	MOV	#TVLO,T
	JSR	PC,CLRRST
	MOV	#NLINS-1,TT
CLRSC1:	JSR	PC,CLRRS1
	DEC	TT
	BGT	CLRSC1
	RTS	PC

;COPIES ONE RASTER LINE

CPYRST:	MOVB	#CSET,CALU
CPYRS1:	.REPT WRDPL
	.NLIST
	MOV	(T)+,(TT)+
	.LIST
	.ENDR
	RTS	PC

;COPIES ONE CHARACTER LINE

CPYCHL:	PUSH	A
	MOV	#LINHT-1,A
	JSR	PC,CPYRST
CPYCH1:	JSR	PC,CPYRS1
	DEC	A
	BGT	CPYCH1
	POP	A
	RTS	PC
.SBTTL KEYBOARD TABLES

.MACRO KBDKEY N,PLAIN,SH,SL,SLSH,TOP
.XLIST
.=XTAB+N
.BYTE PLAIN
.=XTAB+N+100
.BYTE SH
.=XTAB+N+200
.BYTE SL
.=XTAB+N+300
.BYTE SLSH
.=XTAB+N+400
.BYTE TOP
.LIST
.ENDM

;WHAT FOLLOWS IS THE GRAND CHARACTER CONVERSION TABLE

;AN 8 BIT QUANTITY IS USED TO INDEX INTO THE XTAB
;	0-5	KEYBOARD KEY NUMBER
;	  6	SHIFT
;	  7	SHIFT LOCK
;	  8	TOP (6 AND 7 GUARANTEED TO BE ZERO)

;IF THE BYTE PICKED IS NEGATIVE, YOU HAVE STRUCK A KEY THAT DOES NOT
;HAVE AN ASCII CODE.  THESE CODES ARE ASSIGNED AS FOLLOWS:

NASCTB:	NONAS1	;	 0	ILLEGAL
	RTSPC	;	-1	BREAK
	ESCAPE	;	-2	ESCAPE
	CALL	;	-3	CALL
	RTSPC	;	-4	CLEAR
	RTSPC	;	-5	CAP DELTA
	RTSPC	;	-6	CIRCLE MINUS
	RTSPC	;	-7	DEL
	RTSPC	;	-10	CIRCLE PLUS
	RTSPC	;	-11	BACK
	RTSPC	;	-12	NEXT
	RTSPC	;	-13	HELP
	RTSPC	;	-14	BACK SPACE
MAXNAS==<<.-NASCTB>/2>-1	;MAXIMUM # NON-ASCII CHARACTERS

;GOODIES TO PRINT TO REPRESENT META BITS

METATB:	.BYTE 0,2,3,6	;NOTHING, ALPHA, BETA, EPSILON
.EVEN

XTAB:
KBDKEY	0,	-1,	-1,	-1,	-1,	-1	;BREAK
KBDKEY	1,	-2,	-2,	-2,	-2,	-2	;ESCAPE
KBDKEY	2,	'1,	'!,	'1,	'!,	'!
KBDKEY	3,	'2,	'",	'2,	'",	'"
KBDKEY	4,	'3,	'#,	'3,	'#,	'#
KBDKEY	5,	'4,	'$,	'4,	'$,	'$
KBDKEY	6,	'5,	'%,	'5,	'%,	'%
KBDKEY	7,	'6,	'&,	'6,	'&,	'&
KBDKEY	10,	'7,	'',	'7,	'',	''
KBDKEY	11,	'8,	'(,	'8,	'(,	'(
KBDKEY	12,	'9,	'),	'9,	'),	')
KBDKEY	13,	'0,	'_,	'0,	'_,	'_
KBDKEY	14,	'-,	'=,	'-,	'=,	'=
KBDKEY	15,	'@,	'`,	'@,	'`,	'`
KBDKEY	16,	'^,	'~,	'^,	'~,	'~
KBDKEY	17,	-14,	-14,	-14,	-14,	-14	;BACK SPACE
KBDKEY	20,	-3,	-3,	-3,	-3,	-3	;CALL
KBDKEY	21,	-4,	-4,	-4,	-4,	-4	;CLEAR
KBDKEY	22,	11,	11,	11,	11,	11	;TAB
KBDKEY	23,	33,	33,	33,	33,	33	;ALT-MODE
KBDKEY	24,	'q,	'Q,	'Q,	'Q,	4,	;and
KBDKEY	25,	'w,	'W,	'W,	'W,	37	;or
KBDKEY	26,	'e,	'E,	'E,	'E,	22	;intersection
KBDKEY	27,	'r,	'R,	'R,	'R,	23	;union
KBDKEY	30,	't,	'T,	'T,	'T,	20	;subset
KBDKEY	31,	'y,	'Y,	'Y,	'Y,	21	;superset
KBDKEY	32,	'u,	'U,	'U,	'U,	5	;not
KBDKEY	33,	'i,	'I,	'I,	'I,	26	;xor
KBDKEY	34,	'o,	'O,	'O,	'O,	1	;down arrow
KBDKEY	35,	'p,	'P,	'P,	'P,	13	;up arrow
KBDKEY	36,	'[,	'{,	'[,	'{,	'{
KBDKEY	37,	'],	'},	'],	'},	'}
KBDKEY	40,	'\,	'|,	'\,	'|,	'|
KBDKEY	41,	'/,	16,	'/,	16,	16	;infinity
KBDKEY	42,	-6,	-5,	-6,	-5,	-5	;circle minus, cap delta
KBDKEY	43,	-10,	-7,	-10,	-7,	-7	;circle plus, cap del
KBDKEY	44,	14,	14,	14,	14,	14	;form
KBDKEY	45,	13,	13,	13,	13,	13	;vertical tab
KBDKEY	46,	177,	177,	177,	177,	177	;rubout
KBDKEY	47,	'a,	'A,	'A,	'A,	34	;.leq.
KBDKEY	50,	's,	'S,	'S,	'S,	35	;.geq
KBDKEY	51,	'd,	'D,	'D,	'D,	36	;equivalence
KBDKEY	52,	'f,	'F,	'F,	'F,	17	;delta (partial derivative)
KBDKEY	53,	'g,	'G,	'G,	'G,	32	;not equals
KBDKEY	54,	'h,	'H,	'H,	'H,	-13	;HELP!!!!!
KBDKEY	55,	'j,	'J,	'J,	'J,	30	;back arrow
KBDKEY	56,	'k,	'K,	'K,	'K,	31	;forward arrow
KBDKEY	57,	'l,	'L,	'L,	'L,	27	;both ways arrow
KBDKEY	60,<';>,	'+,<';>,	'+,	'+
KBDKEY	61,	':,	'*,	':,	'*,	'*
KBDKEY	62,	15,	15,	15,	15,	15	;carriage return
KBDKEY	63,	12,	12,	12,	12,	12	;line feed
KBDKEY	64,	37,	37,	37,	37,	37	;next, back gives ^_
;KBDKEY	64,	-12,	-11,	-12,	-11,	-11	;next, back
KBDKEY	65,	'z,	'Z,	'Z,	'Z,	2	;alpha
KBDKEY	66,	'x,	'X,	'X,	'X,	3	;beta
KBDKEY	67,	'c,	'C,	'C,	'C,	6	;epsilon
KBDKEY	70,	'v,	'V,	'V,	'V,	10	;lambda
KBDKEY	71,	'b,	'B,	'B,	'B,	7	;pi
KBDKEY	72,	'n,	'N,	'N,	'N,	24	;for all
KBDKEY	73,	'm,	'M,	'M,	'M,	25	;there exists
KBDKEY	74,<',>,	'<,<',>,	'<,	'<
KBDKEY	75,	'.,	'>,	'.,	'>,	'>
KBDKEY	76,	'/,	'?,	'/,	'?,	'?
KBDKEY	77,	40,	40,	40,	40,	40	;space
.SBTTL FONT MACROS AND DEFINITION

.IIF E FONTSW,CTAB==0
.IF NE FONTSW
FNTORG==.
	.MACRO CTBENT A
	.XCREF ...'A
	...'A
	.ENDM

CTAB:	.REPT 200
	.NLIST
	CTBENT \.RPCNT
	.LIST
	.ENDR

.MACRO	FONT A
.NLIST
....==0
...==1_GRIDWD

.IRPC	CHR,A
...==..._<-1>
.IF NB	CHR
....==....!...
.ENDC
.ENDM

.IF NE	...-1
ERROR	\CURCHR
.ENDC

;...FOO==%XLIST
;.REPT ...FOO
;.LIST
;.ENDR
.BYTE	....
;.XLIST
;%XLIST=...FOO
.LIST
.ENDM

.MACRO CDEF A
.NLIST
CURCHR==''A
CDEF1	\CURCHR
.LIST
.ENDM

.MACRO	CDEF1 A
.NLIST
.XCREF ...'A
CURCHR==A
;...FOO==%XLIST
;.REPT ...FOO
;.LIST
;.ENDR
...'A==.
;.XLIST
;%XLIST=...FOO
.LIST
.ENDM

.MACRO	ERROR NUM
.IF1
.ERROR	;FONT LOSSAGE NUM
.ENDC
.ENDM
.ENDC
.XLIST
.IF NE FONTSW
.IF NE FONTMS
.XCREF CURCHR,FONT,CDEF1,CDEF

CDEF1 0
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 1
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 2
FONT <     >
FONT <     >
FONT <     >
FONT < ** *>
FONT <*  * >
FONT <*  * >
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF1 3
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <**** >
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >

CDEF1 4
FONT <     >
FONT <     >
FONT <     >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 5
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <    *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 6
FONT <     >
FONT <     >
FONT <     >
FONT <  ** >
FONT < *   >
FONT < *** >
FONT < *   >
FONT <  ** >
FONT <     >
FONT <     >

CDEF1 7
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT < * * >
FONT < * * >
FONT < * * >
FONT < * * >
FONT <     >
FONT <     >

CDEF1 10
FONT <     >
FONT <     >
FONT <*    >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF1 11
FONT <***  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <     >
FONT <  ** >
FONT <  * *>
FONT <  ** >
FONT <  * *>
FONT <  ** >

CDEF1 12
FONT <*    >
FONT <*    >
FONT <*    >
FONT <***  >
FONT <     >
FONT <  ***>
FONT <  *  >
FONT <  ** >
FONT <  *  >
FONT <     >

CDEF1 13
FONT <     >
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 14
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 15
FONT < *** >
FONT <*    >
FONT <*    >
FONT < *** >
FONT <     >
FONT < *** >
FONT < *  *>
FONT < *** >
FONT < *  *>
FONT < *  *>

CDEF1 16
FONT <     >
FONT <     >
FONT <     >
FONT < * * >
FONT <* * *>
FONT <* * *>
FONT < * * >
FONT <     >
FONT <     >
FONT <     >

CDEF1 17
FONT <     >
FONT < **  >
FONT <   * >
FONT <    *>
FONT < ****>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF1 20
FONT <     >
FONT <     >
FONT < ****>
FONT <*    >
FONT <*    >
FONT <*    >
FONT < ****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 21
FONT <     >
FONT <     >
FONT <**** >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <**** >
FONT <     >
FONT <     >
FONT <     >

CDEF1 22
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 23
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 24
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT < * * >
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 25
FONT <     >
FONT <*****>
FONT <    *>
FONT <    *>
FONT < ****>
FONT <    *>
FONT <    *>
FONT <*****>
FONT <     >
FONT <     >

CDEF1 26
FONT <     >
FONT <     >
FONT < *** >
FONT <** **>
FONT <* * *>
FONT <** **>
FONT < *** >
FONT <     >
FONT <     >
FONT <     >

CDEF1 27
FONT <     >
FONT <  *  >
FONT <   * >
FONT <*****>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT < *   >
FONT <  *  >

CDEF1 30
FONT <     >
FONT <     >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT < *   >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF1 31
FONT <     >
FONT <     >
FONT <  *  >
FONT <   * >
FONT <*****>
FONT <   * >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF1 32
FONT <     >
FONT <    *>
FONT <   * >
FONT <*****>
FONT <  *  >
FONT <*****>
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >

CDEF1 33
FONT <     >
FONT <  *  >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 34
FONT <     >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <     >
FONT < *** >
FONT <     >
FONT <     >

CDEF1 35
FONT <     >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <     >
FONT < *** >
FONT <     >
FONT <     >

CDEF1 36
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 37
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF < >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <!>
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <     >
FONT <     >

CDEF <">
FONT < * * >
FONT < * * >
FONT < * * >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <#>
FONT <     >
FONT <     >
FONT < * * >
FONT <*****>
FONT < * * >
FONT < * * >
FONT <*****>
FONT < * * >
FONT <     >
FONT <     >

CDEF <$>
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <* *  >
FONT < *** >
FONT <  * *>
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT <     >

CDEF <%>
FONT <     >
FONT <*****>
FONT <**  *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*  **>
FONT <*  **>
FONT <     >
FONT <     >

CDEF <&>
FONT <     >
FONT < *   >
FONT <* *  >
FONT <* *  >
FONT < *   >
FONT <* * *>
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF <'>
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <(>
FONT <     >
FONT <    *>
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <   * >
FONT <    *>
FONT <     >
FONT <     >

CDEF <)>
FONT <     >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >

CDEF <*>
FONT <     >
FONT <  *  >
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <  *  >
FONT <     >
FONT <     >

CDEF <+>
FONT <     >
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF <,>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >

CDEF <->
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <.>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT <     >

CDEF </>
FONT <     >
FONT <     >
FONT <    *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >
FONT <     >

CDEF 0
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*  **>
FONT <* * *>
FONT <**  *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 1
FONT <     >
FONT <  *  >
FONT < **  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *** >
FONT <     >
FONT <     >

CDEF 2
FONT <     >
FONT < *** >
FONT <*   *>
FONT <    *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT <     >
FONT <     >

CDEF 3
FONT <     >
FONT < *** >
FONT <*   *>
FONT <    *>
FONT <  ** >
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 4
FONT <     >
FONT <   * >
FONT <  ** >
FONT < * * >
FONT <*  * >
FONT <*****>
FONT <   * >
FONT <   * >
FONT <     >
FONT <     >

CDEF 5
FONT <     >
FONT <*****>
FONT <*    >
FONT <**** >
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 6
FONT <     >
FONT <  ** >
FONT < *   >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 7
FONT <     >
FONT <*****>
FONT <    *>
FONT <   * >
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF 8
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 9
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT <   * >
FONT < **  >
FONT <     >
FONT <     >

CDEF <:>
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT <     >

CDEF <;>
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >

CDEF1 74
FONT <     >
FONT <     >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <     >
FONT <     >
FONT <     >

CDEF <=>
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 76
FONT <     >
FONT <     >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <     >
FONT <     >
FONT <     >

CDEF <?>
FONT <     >
FONT < *** >
FONT <*   *>
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <     >
FONT <     >

CDEF <@>
FONT <     >
FONT < *** >
FONT <*   *>
FONT <* ***>
FONT <* * *>
FONT <* ***>
FONT <*    >
FONT < *** >
FONT <     >
FONT <     >

CDEF A
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF B
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <     >
FONT <     >

CDEF C
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF D
FONT <     >
FONT <**** >
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT <**** >
FONT <     >
FONT <     >

CDEF E
FONT <     >
FONT <*****>
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF F
FONT <     >
FONT <*****>
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF G
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT <*  **>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF H
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF I
FONT <     >
FONT < *** >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *** >
FONT <     >
FONT <     >

CDEF J
FONT <     >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF K
FONT <     >
FONT <*   *>
FONT <*  * >
FONT <* *  >
FONT <**   >
FONT <* *  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF L
FONT <     >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF M
FONT <     >
FONT <*   *>
FONT <** **>
FONT <* * *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF N
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <**  *>
FONT <* * *>
FONT <*  **>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF O
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF P
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF Q
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF R
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <* *  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF S
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT < *** >
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF T
FONT <     >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF U
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF V
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF W
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <** **>
FONT <*   *>
FONT <     >
FONT <     >

CDEF X
FONT <     >
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF Y
FONT <     >
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF Z
FONT <     >
FONT <*****>
FONT <    *>
FONT <   * >
FONT <*****>
FONT < *   >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF <[>
FONT <  ***>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  ***>
FONT <     >

CDEF <\>
FONT <     >
FONT <     >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <    *>
FONT <     >
FONT <     >
FONT <     >

CDEF <]>
FONT <***  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <***  >
FONT <     >

CDEF <^>
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <_>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>

CDEF <`>
FONT <  ** >
FONT <  ** >
FONT <   **>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF a
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <    *>
FONT < ****>
FONT <*   *>
FONT < ****>
FONT <     >
FONT <     >

CDEF b
FONT <     >
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <     >
FONT <     >

CDEF c
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT < ****>
FONT <     >
FONT <     >

CDEF d
FONT <     >
FONT <    *>
FONT <    *>
FONT < ****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <     >
FONT <     >

CDEF e
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <**** >
FONT <*    >
FONT < *** >
FONT <     >
FONT <     >

CDEF f
FONT <     >
FONT <  ** >
FONT < *  *>
FONT < *   >
FONT <***  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <     >
FONT <     >

CDEF g
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT < *** >

CDEF h
FONT <     >
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF i
FONT <     >
FONT <     >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF j
FONT <     >
FONT <     >
FONT <    *>
FONT <     >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >

CDEF k
FONT <     >
FONT <*    >
FONT <*    >
FONT <*   *>
FONT <*  * >
FONT <***  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF l
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF m
FONT <     >
FONT <     >
FONT <     >
FONT <** * >
FONT <* * *>
FONT <* * *>
FONT <* * *>
FONT <* * *>
FONT <     >
FONT <     >

CDEF n
FONT <     >
FONT <     >
FONT <     >
FONT <* ** >
FONT <**  *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF o
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF p
FONT <     >
FONT <     >
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >

CDEF q
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT <    *>

CDEF r
FONT <     >
FONT <     >
FONT <     >
FONT <* ** >
FONT <**  *>
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF s
FONT <     >
FONT <     >
FONT <     >
FONT < ****>
FONT <*    >
FONT < *** >
FONT <    *>
FONT <**** >
FONT <     >
FONT <     >

CDEF t
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <   **>
FONT <     >
FONT <     >

CDEF u
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF v
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF w
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <* * *>
FONT < * * >
FONT <     >
FONT <     >

CDEF x
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF y
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < *   >
FONT <*    >

CDEF z
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <   * >
FONT < *** >
FONT < *   >
FONT <*****>
FONT <     >
FONT <     >

CDEF1 173
FONT <    *>
FONT <   * >
FONT <   * >
FONT <   * >
FONT <  *  >
FONT <   * >
FONT <   * >
FONT <   * >
FONT <    *>
FONT <     >

CDEF1 174
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >

CDEF1 175
FONT <*    >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <  *  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <*    >
FONT <     >

CDEF1 176
FONT < ** *>
FONT <* ** >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 177
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
.ENDC	;.IF NE FONTMS
.IF E FONTMS
...0==.
.BYTE 140,140,140,140,140,140,140,140,140,140
...1==.
.BYTE 000,004,004,004,004,025,016,004,000,000
...2==.
.BYTE 000,000,000,015,022,022,022,015,000,000
...3==.
.BYTE 000,000,000,016,021,036,021,036,020,020
...4==.
.BYTE 000,000,000,004,012,021,000,000,000,000
...5==.
.BYTE 000,000,000,000,037,001,000,000,000,000
...6==.
.BYTE 000,000,000,006,010,016,010,006,000,000
...7==.
.BYTE 000,000,000,037,012,012,012,012,000,000
...10==.
.BYTE 000,000,020,020,010,004,012,021,000,000
...11==.
.BYTE 034,010,010,010,000,006,005,006,005,006
...12==.
.BYTE 020,020,020,034,000,007,004,006,004,000
...13==.
.BYTE 000,004,016,025,004,004,004,004,000,000
...14==.
.BYTE 000,004,004,037,004,004,037,000,000,000
...15==.
.BYTE 016,020,020,016,000,016,011,016,011,011
...16==.
.BYTE 000,000,000,012,025,025,012,000,000,000
...17==.
.BYTE 000,014,002,001,017,021,021,016,000,000
...20==.
.BYTE 000,000,017,020,020,020,017,000,000,000
...21==.
.BYTE 000,000,036,001,001,001,036,000,000,000
...22==.
.BYTE 000,000,016,021,021,021,000,000,000,000
...23==.
.BYTE 000,000,021,021,021,016,000,000,000,000
...24==.
.BYTE 000,021,021,037,021,012,012,004,000,000
...25==.
.BYTE 000,037,001,001,017,001,001,037,000,000
...26==.
.BYTE 000,000,016,033,025,033,016,000,000,000
...27==.
.BYTE 000,004,002,037,002,004,010,037,010,004
...30==.
.BYTE 000,000,004,010,037,010,004,000,000,000
...31==.
.BYTE 000,000,004,002,037,002,004,000,000,000
...32==.
.BYTE 000,001,002,037,004,037,010,020,000,000
...33==.
.BYTE 000,004,004,012,021,012,004,004,000,000
...34==.
.BYTE 000,002,004,010,004,002,000,016,000,000
...35==.
.BYTE 000,010,004,002,004,010,000,016,000,000
...36==.
.BYTE 000,000,037,000,037,000,037,000,000,000
...37==.
.BYTE 000,000,000,021,012,004,000,000,000,000
...40==.
.BYTE 000,000,000,000,000,000,000,000,000,000
...41==.
.BYTE 000,004,004,004,004,004,000,004,000,000
...42==.
.BYTE 012,012,012,000,000,000,000,000,000,000
...43==.
.BYTE 000,000,012,037,012,012,037,012,000,000
...44==.
.BYTE 004,016,025,024,016,005,025,016,004,000
...45==.
.BYTE 000,037,031,002,004,010,023,023,000,000
...46==.
.BYTE 000,010,024,024,010,025,022,015,000,000
...47==.
.BYTE 014,014,030,000,000,000,000,000,000,000
...50==.
.BYTE 000,001,002,004,004,004,002,001,000,000
...51==.
.BYTE 000,020,010,004,004,004,010,020,000,000
...52==.
.BYTE 000,004,025,016,004,016,025,004,000,000
...53==.
.BYTE 000,000,004,004,037,004,004,000,000,000
...54==.
.BYTE 000,000,000,000,000,000,014,014,030,000
...55==.
.BYTE 000,000,000,000,037,000,000,000,000,000
...56==.
.BYTE 000,000,000,000,000,000,014,014,000,000
...57==.
.BYTE 000,000,001,002,004,010,020,000,000,000
...60==.
.BYTE 000,016,021,023,025,031,021,016,000,000
...61==.
.BYTE 000,004,014,004,004,004,004,016,000,000
...62==.
.BYTE 000,016,021,001,002,004,010,037,000,000
...63==.
.BYTE 000,016,021,001,006,001,021,016,000,000
...64==.
.BYTE 000,002,006,012,022,037,002,002,000,000
...65==.
.BYTE 000,037,020,036,001,001,021,016,000,000
...66==.
.BYTE 000,006,010,020,036,021,021,016,000,000
...67==.
.BYTE 000,037,001,002,002,004,004,004,000,000
...70==.
.BYTE 000,016,021,021,016,021,021,016,000,000
...71==.
.BYTE 000,016,021,021,017,001,002,014,000,000
...72==.
.BYTE 000,000,000,014,014,000,014,014,000,000
...73==.
.BYTE 000,000,000,014,014,000,014,014,030,000
...74==.
.BYTE 000,000,002,004,010,004,002,000,000,000
...75==.
.BYTE 000,000,000,037,000,037,000,000,000,000
...76==.
.BYTE 000,000,010,004,002,004,010,000,000,000
...77==.
.BYTE 000,016,021,002,004,004,000,004,000,000
...100==.
.BYTE 000,016,021,027,025,027,020,016,000,000
...101==.
.BYTE 000,016,021,021,037,021,021,021,000,000
...102==.
.BYTE 000,036,021,021,036,021,021,036,000,000
...103==.
.BYTE 000,016,021,020,020,020,021,016,000,000
...104==.
.BYTE 000,036,011,011,011,011,011,036,000,000
...105==.
.BYTE 000,037,020,020,036,020,020,037,000,000
...106==.
.BYTE 000,037,020,020,036,020,020,020,000,000
...107==.
.BYTE 000,016,021,020,020,023,021,016,000,000
...110==.
.BYTE 000,021,021,021,037,021,021,021,000,000
...111==.
.BYTE 000,016,004,004,004,004,004,016,000,000
...112==.
.BYTE 000,001,001,001,001,001,021,016,000,000
...113==.
.BYTE 000,021,022,024,030,024,022,021,000,000
...114==.
.BYTE 000,020,020,020,020,020,020,037,000,000
...115==.
.BYTE 000,021,033,025,021,021,021,021,000,000
...116==.
.BYTE 000,021,021,031,025,023,021,021,000,000
...117==.
.BYTE 000,016,021,021,021,021,021,016,000,000
...120==.
.BYTE 000,036,021,021,036,020,020,020,000,000
...121==.
.BYTE 000,016,021,021,021,025,022,015,000,000
...122==.
.BYTE 000,036,021,021,036,024,022,021,000,000
...123==.
.BYTE 000,016,021,020,016,001,021,016,000,000
...124==.
.BYTE 000,037,004,004,004,004,004,004,000,000
...125==.
.BYTE 000,021,021,021,021,021,021,016,000,000
...126==.
.BYTE 000,021,021,021,021,012,012,004,000,000
...127==.
.BYTE 000,021,021,021,021,025,033,021,000,000
...130==.
.BYTE 000,021,021,012,004,012,021,021,000,000
...131==.
.BYTE 000,021,021,012,004,004,004,004,000,000
...132==.
.BYTE 000,037,001,002,037,010,020,037,000,000
...133==.
.BYTE 007,004,004,004,004,004,004,004,007,000
...134==.
.BYTE 000,000,020,010,004,002,001,000,000,000
...135==.
.BYTE 034,004,004,004,004,004,004,004,034,000
...136==.
.BYTE 004,012,021,000,000,000,000,000,000,000
...137==.
.BYTE 000,000,000,000,000,000,000,000,000,037
...140==.
.BYTE 006,006,003,000,000,000,000,000,000,000
...141==.
.BYTE 000,000,000,016,001,017,021,017,000,000
...142==.
.BYTE 000,020,020,036,021,021,021,036,000,000
...143==.
.BYTE 000,000,000,016,021,020,020,017,000,000
...144==.
.BYTE 000,001,001,017,021,021,021,017,000,000
...145==.
.BYTE 000,000,000,016,021,036,020,016,000,000
...146==.
.BYTE 000,006,011,010,034,010,010,010,000,000
...147==.
.BYTE 000,000,000,016,021,021,021,017,001,016
...150==.
.BYTE 000,020,020,036,021,021,021,021,000,000
...151==.
.BYTE 000,000,004,000,004,004,004,004,000,000
...152==.
.BYTE 000,000,001,000,001,001,001,001,021,016
...153==.
.BYTE 000,020,020,021,022,034,022,021,000,000
...154==.
.BYTE 000,004,004,004,004,004,004,004,000,000
...155==.
.BYTE 000,000,000,032,025,025,025,025,000,000
...156==.
.BYTE 000,000,000,026,031,021,021,021,000,000
...157==.
.BYTE 000,000,000,016,021,021,021,016,000,000
...160==.
.BYTE 000,000,000,036,021,021,021,036,020,020
...161==.
.BYTE 000,000,000,016,021,021,021,017,001,001
...162==.
.BYTE 000,000,000,026,031,020,020,020,000,000
...163==.
.BYTE 000,000,000,017,020,016,001,036,000,000
...164==.
.BYTE 000,004,004,037,004,004,004,003,000,000
...165==.
.BYTE 000,000,000,021,021,021,021,016,000,000
...166==.
.BYTE 000,000,000,021,021,021,012,004,000,000
...167==.
.BYTE 000,000,000,021,021,025,025,012,000,000
...170==.
.BYTE 000,000,000,021,012,004,012,021,000,000
...171==.
.BYTE 000,000,000,021,021,021,012,004,010,020
...172==.
.BYTE 000,000,000,037,002,016,010,037,000,000
...173==.
.BYTE 001,002,002,002,004,002,002,002,001,000
...174==.
.BYTE 004,004,004,004,004,004,004,004,004,004
...175==.
.BYTE 020,010,010,010,004,010,010,010,020,000
...176==.
.BYTE 015,026,000,000,000,000,000,000,000,000
...177==.
.BYTE 037,037,037,037,037,037,037,037,037,037
.ENDC	;.IF E FONTMS
.LIST

.IIF E FONTSW,.=.+3000		;APPROXIMATE SIZE OF FONT

REPORT FONT SIZE=,\.-FNTORG
.NLIST
.ENDC	;.IF NE FONTSW
.LIST
.SBTTL LINE EDITOR AND PAGE PRINTER VARIABLES
VARORG==.

.MACRO ...TEN
.=<.+3>&<-4>
.ENDM

;DEFINE LINE EDITOR AND PAGE PRINTER VARIABLES
;WE GO TO GREAT PAINS TO MAKE PAGE PRINTER AND LINE EDITOR
;LOOK THE SAME SO THAT COMMON CHARACTER GENERATOR ROUTINES AND 
;CURSOR FOLLOWING ARE FACILITATED

LEDFLT:		.OFFSET -.
LECC::		TVLO		;ADDRESS OF CURSOR
LEPHS::		20-CHRWD	;PHASE OF CURSOR
LEX::		-BITPL		;X POSITON OF LE CURSOR
LEPP::		0		;POINTS AT PAGE VARIABLES TO FOLLOW (0=>DISPLAY IN FIXED LOCATION)
LECREG::	.BYTE -1	;CONSOLE REGISTER FOR THIS LE DISPLAY
LEDCNT::	0		;COUNT OF CHARACTERS IN THIS DISPLAY
...TEN

LEZER0::	0		;FAKE LINE BUFFER HEADER
LEZER1::	0
LEBUF::		0		;CURRENT TEXT BUFFER
LELIST::	0		;KEYBOARD BUFFER CHAIN
LECHN::		-1		;ASSOCIATED DPY CHANNEL (SIGH)
LEKBD::		-1		;KEYBOARD DRIVING THIS LINE EDITOR, -1=>LE IS FREE
LEY::		-NLINS		;Y COORDINATE OF LINE EDITOR DISPLAY
LECCO::		TVLO		;ADDRESS OF DISPLAY
LEPHSO::	20-CHRWD	;PHASE OF DISPLAY
LEFREE::	LBCHRS		;FREE CHARACTER COUNT
LECHR::		0		;POINTS AT FREE CHARACTER IN BUFFER
LEACTB::	0		;POINTS TO ACTIVATION TABLE, (0=> ACTIVATE ON ALL)
LEEDIT::0			;NON-ZERO=>EDIT MODE(# CHARACTERS RIGHT OF CURSOR), 0=>INPUT MODE
LESRCH::	0		;SWITCH FOR SEARCH OR KILL
LEARG::		0		;USED TO ACCUMULATE NUMERIC ARGS
LECUR::		0		;LINE EDITOR CURSOR (FOLLOWS LECHR UNLESS IN EDIT MODE)
LEBRK::		.BYTE 0		;BREAK OR ESCAPE LAST TYPED
LEINS::		.BYTE 0		;INSERT MODE FLAG
LEBARG::	0		;ACCUMULATES ARG FOR ESCAPE AND BREAK
LEBLNK::	0		;LINE EDITOR BLINKER
...TEN
LELEN::		.OFFSET 0

PPDFLT:		.OFFSET -.	;PAGE PRINTER VARIABLES.
PPCC::		TVLO		;ADDRESS WHERE NEXT CHARACTER GOES
PPPHS::		20-CHRWD	;CHARACTER PHASE
PPX::		-BITPL		;X POSITION OF CHARACTER
PPLE::		0		;LINE EDITOR ASSOCIATED WITH PAGE
PPCREG::	.BYTE -1	;CONSOLE REGISTER #
PPDCNT::	0		;ONLY PROVIDES SYMETRY WITH LE VARS

PPCHN::		-1		;PAGE PRINTER CHANNEL, -1=>THESE VARIABLES UNUSED
PPY::		-NLINS		;Y POSITION
PPLCC::		TVLO		;ORIGIN OF THIS LINE IN MEMORY
PPORG::		TVLO		;ORIGIN OF THIS PIECE OF PAPER IN MEMORY
PPXORG::	-BITPL		;X ORIGIN OF PAGE
PPYORG::	-NLINS		;Y ORIGIN OF PAGE
PPFONT::	CTAB		;FONT WE ARE PRINTING WITH
PPLPG::		.BYTE 4		;LINES/GLITCH COUNTER
PPLPGK::	.BYTE 4		;LINES/GLITCH CONSTANT (0=>WRAP AROUND)
PPNGL::		.BYTE 11	;# GLITCHES/PAGE COUNTER
PPNGLK::	.BYTE 11	;# GLITCHES/PAGE CONSTANT
PPCPC::		0		;COROUTINE SAVED PC FOR SETCUR
PPSVB::		0		;SAVED B FOR SETCUR COROUTINE.
PPLEN::		.OFFSET 0

;CHECK AND MAKE SURE THESE ARE THE SAME FOR PAGE PRINTER AND LINE EDITOR

.IIF N PPCC-LECC,.ERROR PPCC NOT = LECC
.IIF N PPPHS-LEPHS,.ERROR PPPHS NOT = LEPHS
.IIF N PPX-LEX,.ERROR PPX NOT = LEX
.IIF N PPLEPP,PPLE-LELEPP,.ERROR PPLEPP NOT = LELEPP
.IIF N PPCREG-LECREG,.ERROR PPCREG NOT = LECREG
.IIF N PPDCNT-LEDCNT,.ERROR PPDCNT NOT = LEDCNT

LEPLEN==PPDCNT+<PPDCNT&1>	;SIZE OF COMMON FORMAT AREA

;CLOCK QUEUE ENTRY

		.OFFSET -.	;CLOCK QUEUE ENTRY
CQNEXT::	.=.+2		;CDR OF QUEUE
CQTIME::	.=.+2		;HIGH ORDER OF TIME
CQTIM1::	.=.+2		;LOW ORDER
CQROUT::	.=.+2		;ROUTINE TO CALL AT CLOCK LEVEL
CQARG::		.=.+2		;ARGUMENT FOR CLOCK LEVEL ROUTINE
CQLEN::		.OFFSET 0

		.OFFSET -.	;LINE BUFFER HEADER AREA
				;DON'T ADD NEW VARS WITHOUT CHANGING PDP10 CODE
				;IN TT11IN.
LHFLAG::	.=.+2		;0=>FREE, POS=>BUSY, NEG=>FULL
LHZERO::	.=.+2		;BETTER BE ZERO SO THAT PDP-10 CAN TEST LHFLAG
LHNEXT::	.=.+2		;NEXT BUFFER ON RING
LHALST::	.=.+2		;NEXT BUFFER ON LIST
LHKBD::		.=.+2		;KEY BOARD #
LHFS::		.=.+2		;CHAINS FREE STORAGE BLOCKS
LHQUED::	.=.+2		;NON-ZERO => THIS BUFFER CLOCK QUEUED FOR ACTIVATION (SEE QBFR)
...TEN
LHLEN::		.OFFSET 0

		.OFFSET -.	;DPY BUFFER HEADER
DPY10B::	.=.+2		;WORD PDP-10 IS HACKING (USED FOR INITIALIZATION ONLY)
DPY11B::	.=.+2		;WORD PDP-11 IS HACING
DPYPP::		.=.+2		;PAGE PRINTER VARIABLES
DPYLGL::	.=.+2		;HIGHEST LEGAL BUFFER CELL
DPYSIZ::	.=.+2		;SIZE OF DATA AREA
DPYFS::		.=.+2		;NOT USED
...TEN
DPLEN::		.OFFSET 0

DPDATA==DPLEN		;TEMPORARY KLUDGE

		.OFFSET -.	;BLINKER VARIABLES
BLNEXT::	0		;NEXT BLINKER ON LIST
BLCURS::	0		;POINTS AT CURSOR VARIABLES
BLON::		.BYTE 0		;0 IF BLINK IS OFF
BLCHAR::	.BYTE 177	;CHARACTER THAT BLINKS
BLLEN::		.OFFSET 0

		.OFFSET -.	;USER WHO LINE
WHJOB::		.=.+2		;job #
WHJOB1::	.=.+2		;if negative then clear who line
WHMODE::	.=.+2		;mode
				;-1=>who line is off
				; 0=>follow keyboard
				; 1=>freeze
				; 2=>next higher (when PDP-10 sees this state, it searches
				;   user variables for next higher job index number with same
				;   uname.  When it finds it, it stores the number in job #
				;   and changes mode to 1
				; 3=>next lower
				;any other=>system who line
WHMOD1::	.=.+2		;pads WHMODE
WHUNAM::	.=.+2		;uname in sixbit (left 18 bits in first two words, right in next two)
WHUNM1::	.=.+2
WHUNM2::	.=.+2
WHUNM3::	.=.+2
WHJNAM::	.=.+2		;jname in sixbit
WHJNM1::	.=.+2
WHJNM2::	.=.+2
WHJNM3::	.=.+2
WHSNAM::	.=.+2		;sname in sixbit
WHSNM1::	.=.+2
WHSNM2::	.=.+2
WHSNM3::	.=.+2
WHSTAT::	.=.+2		;status in sixbit, 0=>job does not exist
WHSTA1::	.=.+2
WHSTA2::	.=.+2
WHSTA3::	.=.+2
WHJ%RT::	.=.+2		;job % run time
WHJTRT::	.=.+2		;job total run time (in tenth's of seconds)
WHT%RT::	.=.+2		;tree % run time
WHTPAG::	.=.+2		;job total pages
WHO1::		.=.+2		;user who mode control word
WHO1A::		.=.+2
WHO2::		.=.+2		;first user who line var
WHO2A::		.=.+2
WHO2B::		.=.+2
WHO2C::		.=.+2
WHO3::		.=.+2		;second user who line var
WHO3A::		.=.+2
WHO3B::		.=.+2
WHO3C::		.=.+2
...TEN
WHLEN::		.OFFSET 0

;LINE EDITOR AND PAGE PRINTER VARIABLE AREAS, INDEXED BY KBD #

TENWRD
LEUVAR:	.=.+<MAXLE*LELEN>
LEUEND==.

PPUVAR:	.=.+<MAXPP*PPLEN>
PPUEND==.

;THE WHO LINE PAGE PRINTER IS DIFFERENT AND APART FROM ALL THE REST

WHOPP:	.=.+PPLEN
.SBTTL MISCELLANEOUS TABLES
MISORG==.

;KEYBOARD/VIDEO SWITCH DEFAULTS
;INDEXED BY KBD #, GIVES NEAREST VIDEO SWITCH OUTPUT, -1=>NO DEFAULT

KBDVSW:	.BYTE	 0	; 0	809 FAHLMAN, HOLLOWAY, KNIGHT
	.BYTE	-1	; 1
	.BYTE	-1	; 2
	.BYTE	20	; 3	812 GOODMAN
	.BYTE	 6	; 4	813 HEWITT
	.BYTE	 7	; 5	814 BROWN, MCDERMOTT, SUSSMAN
	.BYTE	 3	; 6	815 FREILING, MCDONALD, RUBIN
	.BYTE	-1	; 7
	.BYTE	 4	;10	817 BISHOP, MATSON, STEIGER
	.BYTE	-1	;11
	.BYTE	-1	;12
	.BYTE	10	;13	819 GOLDSTEIN, WOODS
	.BYTE	 1	;14	820 MINSKY
	.BYTE	-1	;15
	.BYTE	-1	;16
	.BYTE	11	;17	822 HORN, WINSTON
	.BYTE	-1	;20
	.BYTE	 2	;21	824 FININ, LOZANO-PEREZ, WOODHAM
	.BYTE	 5	;22	825 FREUDER
	.BYTE	-1	;23
	.BYTE	-1	;24
	.BYTE	-1	;25
	.BYTE	-1	;26
	.BYTE	-1	;27
	.BYTE	15	;30	925 JARVIS
	.BYTE	16	;31	918 FREEMAN
	.BYTE	17	;32	920 PDP-11 CONSOLE
	.BYTE	14	;33	334 LEBEL
	.BYTE	13	;34	913 BAISLEY, GREENBLATT
	.BYTE	12	;35	915 COHEN
	.BYTE	21	;36	912 9TH FLOOR LOUNGE
	.BYTE	22	;37	914 LARSON, LEBEL, MOUSOURISS
CHECK KBDVSW,MAXKBD

;DPYUSE TABLE (INDEXED BY DPY #) # GUYS USING THIS DPY

DPYUSE:	.BYTE 0,0,-1,-1,0,0,0,0,0,0,0,0	;SOME ARE NOT WIRED YET!
CHECK DPYUSE,MAXTV

;VIDEO SWITCH INPUT INDEXED BY DPY #, HIGH ORDER BYTE GIVES SWITCH SECTION

DPYVSW:	1		; 0
	2		; 1
	3		; 2
	4		; 3
	5		; 4
	6		; 5
	7		; 6
	10		; 7
	VSWINC!1	;10 THESE INPUTS ARE IN SECOND SECTION
	VSWINC!2	;11
	VSWINC!3	;12
	VSWINC!4	;13	THIS IS THE CONSOLE FREE BUFFER (SEE ESCFRE)
CHECK DPYVSW,MAXTV*2
;AUDIO SWITCH TABLES (INDEXED BY KBD #, GIVES AUDIO SWITCH OUTPUT #)

KBDASW:	.BYTE -1	; 0
	.BYTE -1	; 1
	.BYTE -1	; 2
	.BYTE -1	; 3
	.BYTE -1	; 4
	.BYTE -1	; 5
	.BYTE -1	; 6
	.BYTE -1	; 7
	.BYTE -1	;10
	.BYTE -1	;11
	.BYTE -1	;12
	.BYTE -1	;13
	.BYTE -1	;14
	.BYTE -1	;15
	.BYTE -1	;16
	.BYTE -1	;17
	.BYTE -1	;20
	.BYTE -1	;21
	.BYTE -1	;22
	.BYTE -1	;23
	.BYTE -1	;24
	.BYTE -1	;25
	.BYTE -1	;26
	.BYTE -1	;27
	.BYTE -1	;30
	.BYTE -1	;31
	.BYTE -1	;32
	.BYTE -1	;33
	.BYTE -1	;34
	.BYTE -1	;35
	.BYTE -1	;36
	.BYTE -1	;37
CHECK KBDASW,MAXKBD
;POINTER AREA

TENWRD

POINTA:	ITSWHO
	CMDFLG
TENWHO:	0		;-1=>PDP-10 SHOULD UPDATE WHO LINES
TENWH1:	0		;FILLS OUT TENWHO
.=.+10			;LEAVE A LITTLE ROOM FOR GROWTH

;10/11 CHANNEL HEADER AREA

TENWRD

CHA==.
KBDFLG:	0		;KEYBOARD ACTIVATED LIST (SET BY 11 CLEARED BY 10)
	0		;ALWAYS ZERO
DPYCHN:	0		;THE DPY BUFFER FOR THIS CHANNEL
DPYKBD:	0		;.BYTE KBD#, DPY#
	.=.+<<MAXPP-1>*4>
ECOFLG:	0
CHNCLS:	0		;FLAGS DPY CHANNEL AS OPEN (SET TO -1 BY TEN)
	.=.+<<MAXPP-1>*4>
WHOLIN:	0		;POINTS TO WHO LINE VARIABLES FOR THIS CHANNEL
	0		;NOT USED
	.=.+<<MAXPP-1>*4>

;PDP-10/PDP-10 COMMAND BUFFER

TENWRD

CMDFLG:	0		;0=>TEN CAN WRITE, POSITIVE=>ELEVEN CAN WRITE, NEGATVE=>TEN WON
	0		;FULL PDP-10 WORD BOUNDARY
CMDBUF:	.=.+<CMDARG*4>	;EACH ARG IN COMMAND BUFFER IS PDP-10 WORD

;SYSTEM WHO LINE

TENWRD

ITSWHO==.
ITSTDP:	0	;# total # dpy's (read only for PDP-10)
ITSFDP:	0	;# free  dpys (read only for PDP-10)
ITSVER:	0	;ITS version #
ITSJOB:	0	;total jobs
ITSCOR:	0	;total core
ITSRU:	0	;runnable users
ITSWBJ:	0	;# jobs swap blocked
ITSJWP:	0	;# jobs waiting for pages
ITSTRC:	0	;total runable core
ITSCFU:	0	;core available for users
ITSDAT:	0	;date [byte (7) year (4) month (5) day]
ITSDBG:	0	;system debug flag
ITSTIM:	0	;time of day (# half seconds since midnight) aligned on PDP-10 word
ITSTI1:	0	;low order of time
ITSUSR:	0	;total number of users

;USER WHO LINE VARIABLES

TENWRD

WHVARS:	.=.+<WHLEN*MAXPP>

;CHANNEL USE FLAGS NON-ZERO MEANS CHANNEL IN USE

CHNUSE:	.=.+MAXPP
	.EVEN
.SBTTL MISCELLENOUS VARIABLES AND FREE STORAGE

;VIDEO AND AUDIO SWITCH TABLES

ASWTAB
VSWTAB

;BLINKERS (INDEXED BY TVDPY #)

BLINKS:	.=.+<MAXTV*2>

;BELLS PENDING COUNTS

BELCNT:	.=.+<MAXTV*2>

;KEYBOARD/LINE EDITOR ASSOCIATION

KBDLE:	.=.+<MAXKBD*2>

;BLINKING NON-SENSE

BLKVAR:	.=.+<MAXBLK*BLLEN>
BLKSWT:	.=.+MAXBLK
	.EVEN

;CLOCK QUEUE

CLOCKF:	0	;CLOCK QUEUE FREE LIST
CLOCKQ:	0	;FIRST ENTRY ON CLOCK QUEUE
CQUEUE:	.=.+<CQLEN*NCQSLT>

;MISCELLANEOUS VARIBLES

FSP:	0	;POINTS TO LEBUFS
OLDKMA:	0	;LAST KMA
BLINK:	0	;PAGE PRINTER TO BLINK
FBLINK:	BLKVAR	;LIST OF FREE BLINKERS
TICKS:	0	;HIGH ORDER OF TIME
TICKS1:	0	;LOW ORDER OF TIME
QPYSWT:	0	;INTER LOCK TO SAVE COPY PAPER
BUZSWT:	0	;INTERLOCK FOR BUZZING 9TH FLOOR DOOR
RADIX:	0	;HOLDS OUTPUT RADIX
VERSE:	%FNAM2	;SOURCE FILE VERSION #
MSGPP:	-1	;PAGE PRINTER FOR CONSOLE FREE MESSAGE
KBDACT:	0	;KEYBOARD ACTIVE LIST (NOT YET SEEN BY PDP-10)
KBDLAST:0	;POINTS TO LAST BUFFER ON ACTIVE LIST
WHOTIM:	0	;LAST TIME WE DID WHO LINES
WHOFLG:	0	;DO WHO LINES FLAG
DPYFRE:	0	;DPY # OF FREE-CONSOLE CHANNEL.

;PATCH AREA

PATCH:	.=.+PATL

;LINE EDITOR BUFFER RINGS

TENWRD
NLBUFS==<RUGSA-.>/<LHLEN+LBLEN>

REPORT NLBUFS=,\NLBUFS

LEBUFS:	.=.+<NLBUFS*<LHLEN+LBLEN>>

REPORT TOTAL SIZE=,\.

.END	GO
WRD
     SIZE