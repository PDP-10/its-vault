SUBTTL	ARPANET HARDWARE DEFINITIONS

IMPVRS==.IFNM2	;VERSION OF IMP/NET CODE

IFE DMI,[	;HARDWARE DESCRIPTION OF AI/ML IMP INTERFACE, DEVICE "IMP"

;CONI BITS
		;1.1-1.3 => PIA
IMPID==10	;INPUT DONE
IMPI32==20	;INPUT IN 32 BIT MODE
;IMPIB==40	;INPUT BUSY
IMPOD==100	;OUTPUT DONE
;IMPO32==200	;OUTPUT IN 32 BIT MODE
;IMPOB==400	;OUTPUT BUSY
IMPERR==1000	;IMP ERROR
IMPR==2000	;IMP READY
;IMPIC==4000	;IMP INTERRUPT CONDITION (0 = ERROR, 1= READY)
IMPHER==10000	;HOST ERROR
;IMPHR==20000	;HOST READY
;IMPIHE==40000	;INTERRUPT INHIBITED ON HOST ERROR
IMPLW==100000	;LAST IMP WORD

;CONO BITS
		;1.1=1.3 => PIA
IMPIDC==10	;CLEAR INPUT DONE
IMI32S==20	;SET INPUT TO 32 BIT MODE
IMI32C==40	;CLEAR INPUT IN 32 BIT MODE
IMPODC==100	;CLEAR OUTPUT DONE
IMO32S==200	;SET OUTPUT TO 32 BIT MODE
IMO32C==400	;CLEAR OUTPUT IN 32 BIT MODE
IMPODS==1000	;SET OUTPUT DONE
IMPIR==4000	;ENABLE INTERRUPT ON IMP READY
IMPHEC==10000	;CLEAR HOST ERROR
;IMIIHE==40000	;INHIBIT INTERRUPT ON HOST ERROR
IMPLHW==200000	;SET LAST HOST WORD

];DMI
IFN DMI,[	;HARDWARE DESCRIPTION OF DM IMP INTERFACE (PER RMM)

	;IMP INTERFACE CONO FLAG DESCRIPTION

;COMMON FLAG BITS TO CONTROLLER

		;18-> 0 FOR INPUT SIDE, 1 FOR OUTPUT SIDE
		;19->CLEAR TEST MODE (200000)
		;20->SET TEST MODE (100000)

		;21->CLEAR HOST READY
		;22->SET HOST READY (20000)
		;23->CLEAR IMP-WAS-DOWN (10000)

		;24->FI DEVICE RESET (CLEAR ALL INPUT AND OUTPUT FLAGS) (4000)

;CONO FI (424) TO OUTPUT SIDE
	;BIT	;18->IS '1' INDICATING TO OUTPUT
		;25->CLEAR OUTPUT 32-BIT MODE
		;26->SET OUTPUT 32-BIT MODE

		;27->SET OUTPUT EOT (CLEAR DONE, SET BUSY) (400)
		;28->SET OUTPUT DONE (200)
		;29->RESET OUTPUT (CLEAR ALL OUTPUT FLAGS) (100)

		;30-32->CONTROL PI ASSIGNMENT

		;33-35->OUTPUT DONE PI ASSIGNMENT

;CONO FI (424) TO INPUT SIDE
	;BIT	;18->IS '0' INDICATING TO INPUT
		;25->CLEAR 32-BIT MODE (2000)
		;26->SET 32-BIT MODE (1000)

		;27->SUSPEND INPUT (400) DATAI WONT SET BUSY NOW
		;28->SET INPUT BUSY (LISTENING TO NETWORK) (200)
		;29->RESET INPUT (CLEAR ALL INPUT FLAGS!) (100)

		;30-32->CONTROL PI ASSIGNMENT

		;33-35->INPUT DONE PI ASSIGNMENT

	;FI CONI FLAG DESCRIPTION

	;BIT	;00->TEST MODE IS ENABLED
		;08->OUTPUT IS IN 32-BIT MODE
		;17->INPUT IS IN 32-BIT MODE

		;18->IMP IS DOWN
		;19->IMP WAS DOWN
		;20->HOST READY (?)

		;21->OUTPUT EOT ON
		;22->OUTPUT BUSY
		;23->OUTPUT DONE
		;24-26->OUTPUT-DONE PI ASSIGNMENT

		;27->INPUT EOT ON
		;28->INPUT BUSY
		;29->INPUT DONE

		;30-32->CONTROL INTERRUPT PI ASSIGNMENT

		;33-35->INPUT DONE PI ASSIGNMENT

;	SYMBOL ASSIGNMENTS FOR DM HARDWARE

;	CONO BITS

FIIN==000000	;(SIC) SPECIFY CONO FOR INPUT
FIOUT==400000	;SPECIFY CONO FOR OUTPUT SIDE
;FITSTC==200000	;CLEAR TEST MODE
;FITSTS==100000	;SET TEST MODE

;FIHSTC==040000	;CLEAR HOST READY
FIHSTS==020000	;SET HOST READY
FIIWDC==010000	;CLEAR "IMP WAS DOWN"

FIRSET==004000	;DO LOCAL IOB RESET FOR FI DEVICE

;INPUT SIDE ONLY

FII32C==002000	;CLEAR 32 BIT MODE, INPUT
FII32S==001000	;SET 32 BIT MODE, INPUT

FISUSP==000400	;"SUSPEND INPUT" CLEAR FLAG, NOT SET BUSY
FIIBSY==000200	;SET INPUT BUSY, ALLOWS BITS IN FROM IMP
FIIDC==000100	;CLEAR INPUT DONE

;	0000X0	;CONTROL PIA

;	00000X	;INPUT DONE PIA

;OUTPUT SIDE ONLY

FIO32C==402000	;CLEAR 32 BIT MODE, OUTPUT
FIO32S==401000	;SET 32 BIT MODE, OUTPUT

FILHW==400400	;SET "LAST HOST BIT TO IMP"
FIODS==400200	;SET OUTPUT DONE
FIODC==400100	;CLR OUTPUT DONE

;	0000X0	;CONTROL PIA

;	40000X	;OUTPUT DONE PIA

;	CONI BITS

;	LEFT HALF OF CONI WORD FOR FOLLOWING 3 BITS

;FITSTM==400000	;TEST MODE IS ON
;FIO32==001000	;OUTPUT IS IN 32 BIT MODE
FII32==000001	;INPUT IS IN 32 BIT MODE

;	RIGHT HALF OF CONI

FIDOWN==400000	;IMP IS DOWN
FIWASD==200000	;IMP WAS DOWN (OR IS) SINCE LAST RESET
;FIHSTR==100000	;HOST READY IS SET ON

;FIOEOT==040000	;OUTPUT LAST IMP BIT IS ON
;FIOBSY==020000	;OUTPUT IS BUSY AFTER DATAO
FIOD==010000	;OUTPUT IS DONE, (INTERRUPTING)

;	00X000	;OUTPUT DONE PIA

FILW==000400	;LAST BIT SET FROM IMP
FIIBSY==000200	;INPUT IS BUSY, WORD BEING ASSEMBLED FROM IMP
FIID==000100	;INPUT IS DONE (INTERRUPTING) TO DO DATAI

;	0000X0	;CONTROL PIA

;	00000X	;INPUT PIA

IMPLW==FILW	;USEFUL TO TEST IN AC
IMP==FI		;USEFUL FOR BLKO, DATAO INSTR
]

;PROTOCOL INFORMATION (EXTENDED-LEADER VERSION)

;THE LEADER IS 6 36-BIT WORDS.  THE FIRST 5 ARE THE IMP-HOST
;PROTOCOL, THE 6TH WORD IS THE HOST-HOST PROTOCOL AND ONLY
;PRESENT IN TYPE-0 MESSAGES.  5 16-BIT WORDS OF PADDING ARE
;USED TO MAKE THE LEADER COME OUT TO A MULTIPLE OF A WORD.

;HERE ARE THE WORD FORMATS:
;
;1:  4.9-4.6 not used (0)
;    4.5-4.2 all 1's for new format, else old msg type (4=old nop)
;    4.1-3.3 network number (0)
;    3.2-2.8 not used (0)
;        2.7 trace (ignore)
;    2.6-2.4 leader flags (2.6 is to be ignored, 2.5-2.4 are not used!)
;    2.3-1.5 message type (as of yore, but more bits) (see IMTDT)
;    1.4-1.1 high 4 bits of handling type (0)
;
;2:  4.9-4.6 Low bits of handling type (7 for big buffers, 4 for small buffers,
;    4.5-3.7 host number			and 0 for the control link)
;    3.6-1.9 Imp number
;    1.8-1.1 Link number (high 8 bits of message-id)
;
;3:  4.9-4.6 Low 4 bits of message-id (0)
;    4.5-4.2 Sub-type (as of yore)
;    4.1-2.4 Message length (ignored)
;    2.3-1.1 Padding
;
;4:  4.9-1.1 Padding
;
;5:  4.9-1.5 Padding
;    1.4-1.1 Host-host padding
;
;6:  4.9-4.6 Host-host padding   (this word only present in type-0 messages)
;    4.5-3.7 byte size
;    3.6-1.9 byte count
;    1.8-1.1 host-host padding

;In message types 2 and 6, the going-down status 16-bit word is
;in word 2 1.8-1.1 and word 3 4.9-4.2.

;4.5-4.2 of word 3 are the padding count for type 4 (nop) from host.
;This is 5.  Padding is only put on type-0 messages.

IMTBP:	041000,,IMPILB+0	;BYTE POINTER FOR MESSAGE TYPE FIELD
IMOTBP:	340400,,IMPILB+0	;BYTE POINTER FOR OLD MESSAGE TYPE (17=NEW)
IMLNBP:	001000,,IMPILB+1	;BYTE POINTER FOR LINK NUMBER FIELD
IMSHBP:	301000,,IMPILB+1	;BYTE POINTER FOR SOURCE HOST FIELD
IMSIBP:	102000,,IMPILB+1	;BYTE POINTER FOR SOURCE IMP FIELD
IMCBBP:	301000,,IMPILB+5	;BYTE POINTER FOR CONNECTION BYTE SIZE FIELD
IMBCBP:	102000,,IMPILB+5	;BYTE POINTER FOR BYTE COUNT FIELD

SUBTTL	ARPANET VARIABLES AND TABLES

IMPSTL==NNETCH	;SOCKET TABLE LENGTH (MUST BE .LE. 70)
IFG NNETCH-70,.ERR NNETCH SHOULD BE LESS THAN 70 OCTAL, PER BBN SPECS

EBLK

IMPN::		;IMP DATA AREA CLEARED WHEN IMPUP
IFE DMI,[
IMPI:	0	;-1 => IMPCHN INPUT INTERRUPT OCCURRED
IMPO:	0	;-1 => IMPCHN OUTPUT INTERRUPT OCCURRED
IMPB:	0	;-1 => IMPCHN FLAG INTERRUPT OCCURRED
IMPIH:	0	;-1 => INPUT WANTS PIA = IMPCHN
IMPOH:	0	;-1 => OUTPUT WANTS PIA = IMPCHN
]
IMPIS:	0	;INPUT STATE
		;-1 => NETWORK SHUT OFF
		;0 => NOT EXPECTING INPUT (I.E. BETWEEN MESSAGES)
		;1 => IGNORE INPUT UNTIL END OF CURRENT MESSAGE
		;2 => EXPECTING END OF LEADER
		;3 => END OF CONTROL MESSAGE
		;4 => END OF DATA MESSAGE
IMPOS:	0	;OUTPUT STATE
		;0 => NOT EXPECTING OUTPUT DONE (I.E. BETWEEN MESSAGES)
		;1 => SENDING CONTROL MESSAGE OR NOP
		;2 => SENDING DATA MESSAGE
IMPHI:	0	;-1 TO HOLD UP INPUT
		;-2 INPUT IS SUCCESSFULLY HELD UP
IMRFCT:	0	;NUMBER OF HOST TABLE ENTRIES WITH PENDING
		;TIMEOUTS FOR CONTROL-LINK RFNM OR RST-RRP.

;HOST TABLE.  ENTRIES HEREIN ARE ALLOCATED AS NEEDED, USING GARBAGE
;COLLECTION.  MOST "HOST NUMBER" FIELDS ARE REALLY INDICES INTO
;THIS TABLE.
LIMPHT==NNETCH/2+3
IMPHTN:	BLOCK LIMPHT	;HOST NUMBER.  1.1-1.8 HOST, 2.1-3.7 IMP
IMPHTB:	BLOCK LIMPHT	;BITS:
		;4.9 1=RFNM WAIT ON LINK 0
		;4.8 GC MARK BIT
		;4.7-4.3 UNUSED
		;4.2-4.1 STATUS OF HOST 0 DOWN, 1 RST SENT, 2 UP
		;3.9-3.1 TIME (MOD 2**9) LAST RFNM SENT ON LINK 0
.SEE IMPHDS	;RH   LAST MESSAGE FROM IMP ABOUT "HOST DEAD STATUS"
IMNCS:	0	;NUMBER OF CHANNELS BEING CLOSED
IMNAS:	0	;NUMBER OF CHANNELS WITH 4.8 IN IMSOC5 SET
LIMPN==.-1 ;LAST LOCATION BLT'ED TO ZERO WHEN INITIALIZED
IMPHTF:	-1	;HOST TABLE FREE LIST, THREADED THROUGH IMPHTB, END WITH -1
IMPUP:	-1	;0 => IMP UP  ;-1 => DOWN  ;-2 => COMING UP, PI LVL STILL OFF
		;1 => DOWN FOR GOOD, UNTIL NEXT TIME IMP READY LINE CHANGES
IMPTCU:	0	;0 IMP UP/DOWN STATUS NOT CHANGING
		;>0 TRYING TO REINITIALIZE, SYS JOB HASN'T DONE SO YET
		;-1 HAS BEEN REINITIALIZED, HAVEN'T EXCHANGED NOPS YET
IMPUCT:	0	;IMP COMING UP TIMEOUT, IF 4 NOOPS DON'T GO THROUGH PROMPTLY.
IMPDWN:	BLOCK 3	;LAST MESSAGE FROM IMP THAT IT IS GOING DOWN
		;WD0 "REASON" CLAIMED BY IMP (SEE CH 3 OF BBN REPORT 1822)
		;WD1 TIME WHEN EXPECTED DOWN
		;WD2 TIME WHEN EXPECTED UP (SYS TIME=1/30 SEC SINCE UP)
IFE DMI,IMPPIA: 0	;CURRENT IMP PIA
IMPCNI:	0	;CONI INTO HERE AT SLOW CLOCK LEVEL
IMERCN:	-1	;CONI INTO HERE WHEN NET GOES DOWN
IMNOPC:	0	;< 0 => SEND NOPS
IMPA:	0	;SAVE A AT IMPCHN PI LEVEL
IMPOAC:	-1	;-1 => OUTPUT INACTIVE
IMPERB:	BLOCK 5	;LAST "ERR" MESSAGE FROM A HOST
		;WD 0 TIME WHEN RCVD, WD 1 HOST, WD2-4 11. 9-BIT BYTES OF DATA
IFN DMI,IMPSUS: 0	;HOLDS INPUT WORD WHILE INPUT IS HELD UP
IMPILB:	BLOCK 6		;INPUT LEADER BUFFER
IMPINB:	BLOCK 30.+5	;30. WORDS @ 32 BITS/WD = 120. 8 BIT BYTES
			;+5 WORDS FOR GOOD MEASURE
			;THIS BUFFER IS FOR CONTROL-LINK MESSAGES
BBLK

IMHSBT:	330200,,IMPHTB(H)	;RST/RRP STATUS

EBLK

IMPCSH:	0	;CURRENT SOURCE HOST (IMPHTB INDEX).  -1 WHEN IDLE.
IMPCLN:	0	;CURRENT LINK NUMBER
IMPCBS:	0	;CURRENT BYTE SIZE
IMPCBC:	0	;CURRENT BYTE COUNT
IMPNIW:	0	;EXPECTED LAST BLKI ADDRESS
IMNWSI:	0	;SECOND BLKI POINTER, ZERO IF NONE
IMPSVP:	0	;SAVE PIA AT IMPRMP
IMPSVQ:	0	;SAVE CONTROL MESSAGE QUEUE POINTER AT IMPOB2
IMBLKI:	0	;PLACE TO STORE BLKI POINTER
IMBLKO:	0	;PLACE TO STORE BLKO POINTER
IMPNBI:	0	;AMOUNT TO INCREMENT IMSMPC(I) BY, I.E. # OF DATA BYTES
		; IN MESSAGE CURRENTLY COMING IN AT P.I. LEVEL
IMPNBO:	0	;AMOUNT TO INCREMENT IMSMPC(I) BY, I.E. # OF DATA BYTES THAT WILL BE
		; MADE FREE IN BUFFER BY MESSAGE CURRENTLY GOING OUT AT P.I. LEVEL
IMPNBT:	0	;# BITS ACTUALLY BEING SENT, USED TO ADJUST ALLOCATION
IMPNPT:	0	;NEW VALUE FOR IMSPIP(I) AFTER MSG IS SENT
IMPIPI:	-1	;IMSOC INDEX ACTIVE FOR INPUT AT P.I. LEVEL, OR -1 IF NONE
IMPOPI:	-1	;IMSOC INDEX ACTIVE FOR OUTPUT AT P.I. LEVEL, OR -1 IF NONE
IMOB0Z:	0	;IMSMPP AT IMOBD1, FOR DEBUGGING

;IMP OUTPUT LIST.  EXECUTED AT PI LEVEL 1.
;NEGATIVE = BLKO POINTER, 0=STOP, 1=SET LAST WORD, 2=32-BIT MODE, 3=NOP
IMOPNT:	0	;INDEX OF NEXT "INSTRUCTION" IN IMP OUTPUT LIST:
IMOLST:	0	;BLKO FOR SECOND THROUGH SIXTH LEADER WORDS (FIRST IS DATAO'ED)
IMOMOD:	2	;SWITCH TO 32-BIT MODE IF NECESSARY
IMOBK1:	0	;FIRST BLKO POINTER
IMOBK2:	0	;SECOND BLKO POINTER
	1	;SET LAST WORD
IMOBK3:	0	;THIRD BLKO POINTER (SEND LAST WORD, NOT USED WITH DM INTERFACE)
	0	;STOP
IMOLDR:	BLOCK 6	;BUILD PREAMBLE HERE FOR DATA MESSAGES

IMPNEA:	0	;NUMBER OF ECOS IN COMMAND MESSAGE THAT HAVE BEEN ANSWERED
IMPNRA:	0	;NUMBER OF RSTS ANSWERED

;METERS
IMNOSH:	0	;# OF SHUFFLES OF NET OUTPUT BUFFERS
IMNISH:	0	;# OF SHUFFLES OF NET IMPUT BUFFERS
IMPNPE:	0	;NUMBER OF PROTOCOL ERRORS
IMNSCM:	0	;NUMBER OF SHORT CONTROL LINK MESSAGES
IMPNEI:	0	;NUMBER OF ERPS NOT SENT
IMPNRI:	0	;NUMBER OF RRPS NOT SENT
IMNRFC:	0	;NUMBER OF RFCS CLSED
IMNRFI:	0	;NUMBER OF RFCS IGNORED
IMNCLI:	0	;NUMBER OF CLS IGNORED
IMNALI:	0	;NUMBER OF ALLS IGNORED
IMNPIL:	0	;NUMBER OF TIMES PI CONTROL QUEUE EXCEEDED
IMNCNS:	0	;NUMBER OF CLS NOT SENT
IMNANS:	0	;NUMBER OF ALLS NOT SENT
IMNMNC:	0	;NUMBER OF REGULAR MESSAGES FOR NON-EXISTANT CONNECTIONS
IMNSRF:	0	;NUMBER OF SPURIOUS RFNMS ON REG CONNECTIONS
IMNSRC:	0	;NUMBER OF SPURIOUS RFNMS ON CONTROL LINK
IMNRFN:	0	;NUMBER OF RFNMS NOT SENT
IMNMAE:	0	;NUMBER OF TIMES MSG ALL EXCEEDED
IMNMSS:	0	;NUMBER OF TIMES MSG SHORT
IMNBAE:	0	;NUMBER OF TIMES BIT ALL EXCEEDED
IMSTAS:	0	;STATUS OF INPUT AT TIME HELD UP
IMPNIH:	0	;NUMBER OF TIMES INPUT SUCCESSFULLY HELD UP
IMPNUH:	0	;NUMBER OF TIMES INPUT HOLDUP UNDONE
IMNORH:	0	;NUMBER OF STYNET OUTPUT RESETS DELAYED
;IMPRTO==30.*60.	;RESET TIME OUT (IDENTICALLY = IMRFTO)
IMPCTO==30.*30.	;CLS TIME OUT
IMRFTO==60.*30.	;RFNM WAIT TIME OUT
IMFCTO==55.*30.	;RFC QUEUE TIME OUT - SHOULD BE LESS THAN 2*IMPCTO
IMPMSR:	BLOCK 20	;COUNT OF IMP MESSAGES RCD
IMPMSS:	BLOCK 1		;COUNT OF IMP MSG SENT (WE ONLY SEND REGULAR MSGS)
IMPCMR:	BLOCK 20	;COUNT OF CONTROL MESSAGES RCD
IMPCMS:	BLOCK 20	;COUNT OF CTL MSG SENT
IMCT1:	0	;# TIMES AT IMPBKZ
IMCT2:	0	;# TIMES AT IMPIBZ
IMCT3:	0	;# TIMES AT IMPOBZ

IMPMQS==13.	;MESSAGE QUEUE SIZE (LENGTH WORD, 6-WORD LEADER, 6-WORD TEXT)
;MAIN PROGRAM CONTROL MESSAGE VARIABLES
IMPMPU:	-1	;-1 => FREE
	0	;SWTL THREAD
IMPMPL:	-1	;LINK WORD FOR CONTROL LINK QUEUE
IMPMPC:	BLOCK IMPMQS	;FIRST WORD HAS IMPHTB INDEX,,LENGTH OF TEXT

;PI CONTROL MESSAGE VARIABLES
IMNPIC==NNETCH+3	;NUMBER OF BLOCKS IN PI CONTROL QUEUE
;HOPEFULLY THIS IS ENOUGH.  THE CODE RESPONDS VERY UNGRACEFULLY TO THIS
;QUEUE FILLING UP.  IN PARTICULAR, WHEN IT HOLDS UP INPUT IT CAN CAUSE
;A DEADLOCK BY PREVENTING ITSELF FROM SEEING A CONTROL-LINK RFNM IT
;NEEDS IN ORDER TO SEND SOMETHING THAT'S IN THE QUEUE AND FREE UP SOME
;SPACE.  FURTHERMORE THE IMP IS UNGRACEFUL AND WILL SOMETIMES REFUSE TO
;READ INPUT FROM US (EVEN IN THE MIDDLE OF A MESSAGE) UNTIL WE READ
;INPUT FROM IT.  BUT WE DO THE SAME THING WHEN THIS QUEUE FILLS UP.
;FURTHERMORE SOMETIMES THE CORE JOB WILL WAIT FOR A NETWORK
;TRANSMISSION TO COMPLETE SO IT CAN MOVE A NETWORK BUFFER, HANGING THE
;ENTIRE SYSTEM.  THE CORE-JOB WILL UNHANG AFTER THE IMP TIMES OUT AND
;FLASHES ITS READY LINE (SEE IMPBER).
;** BUT SOMETIMES THE IMP NEVER TIMES OUT AND SO THE SYSTEM IS HUNG **

IMPCQ:	REPEAT IMNPIC-1,[
	.+IMPMQS+1	;POINTER TO NEXT FREE OR NEXT IN QUEUE
	BLOCK IMPMQS	;FIRST WORD HAS IMPHTB INDEX,,LENGTH OF TEXT
]
	-1
	BLOCK IMPMQS
IMPNCQ:	-1	;NEXT ENTRY TO BE SENT.  -1 IF NONE
IMPLCQ:	-1	;POINTER TO LAST ENTRY IN CONTROL QUEUE
IMFFCQ:	IMPCQ	;POINTER TO FIRST FREE.  -1 IF NONE
IMFCQL:	IMNPIC	;NUMBER FREE CONTROL QUEUE ENTRIES LEFT

;PENDING RFC QUEUE
IMNPQ==20	;NUMBER OF PENDING QUEUE ENTRIES
;(0)	POINTER TO NEXT IN CHAIN OR NEXT FREE.  -1 IF NONE
;(1)	LOCAL SOCKET NUMBER
;(2)	FOREIGN SOCKET NUMBER
;(3)	4.9 = 1 => RTS  = 0 => STR
;	1.1-1.8 = LINK NUMBER OR BYTE SIZE
;	1.9-2.7 = FOREIGN HOST NUMBER
;	3.1-3.9 = TIME RFC RECEIVED, IN SECONDS MOD 512.
	IMPPQ		;IMPBPQ-1 IS BEGINNING OF GETSYS BLOCK, THIS WORD FOR UNRELOCATION
IMPBPQ:	-1	;BEGINNING OF PENDING QUEUE.  -1 IF EMPTY
IMPPQ:	REPEAT IMNPQ-1,[
	.+4
	BLOCK 3
]
	-1
	BLOCK 3
IMPEPQ:	-1	;END OF PENDING QUEUE.  -1 IF EMPTY (IMPEPQ IS END FOR GETSYS BLOCK)
IMFFPQ:	IMPPQ	;FIRST FREE PENDING QUEUE ENTRY.  -1 IF NONE

;SOCKET TABLE

IMSOKB:	IMPSTL		;BEGIN OF GETSYS BLOCK, LENGTH STORED HERE

IMSOC1:	REPEAT IMPSTL,0		;0 => FREE
				;>0 MEANS ALLOCATED, NOT SET UP YET
				;4.9 = 1 => SOCKET IN USE
				;4.8 = 1 => CHNL TRYING TO BE CLOSED
				;3.1-4.7 = MASK FOR CHANNEL SOCKET IS OPEN ON.
				;RH = USER INDEX

IMSOC2:	BLOCK IMPSTL		;1.1-4.5 = LOCAL SOCKET NUMBER
				;4.6-4.9  0 (MAKES COMPARISONS EASIER)
IMSOC3:	BLOCK IMPSTL		;1.1-4.5 = FOREIGN SOCKET NUMBER
				;4.6-4.9 = 0
IMSOC4:	BLOCK IMPSTL		;3.1-3.8 = LINK NUMBER
				;3.9-4.7 = FOREIGN HOST NUMBER (IMPHTB INDEX)
				;	   377 MEANS NOT USING ANY HOST
				;4.8 = SET BY RCV CLS - MAKES MATCH USING IMSCHD FAIL
				;4.9 = SEND THIS BUFFER NOW
	.SEE %NS		;RH = SOCKET STATE
IMSOC5:	BLOCK IMPSTL		;1.1 - 1.9 => TTY # OF STY, IF CONNECTED TO ONE.
				;2.1-2.9 = CLOSE-REASON
				;3.1-3.8 = CONNECTION BYTE SIZE
				;3.9 => ASCII MODE - 7 BIT
				;4.1 => ASCII MODE - 8 BIT
				;4.2 => 1 BIT BYTES
				;4.3 => NET INT (INR\INS) RECEIVED
				;4.4 => HAVE BEGUN COUNTING THE CLOSE TIME-OUT.
				;4.5 => CLOSED WHILE IN RFNM WAIT, EXPECT ANOTHER RFNM
				;4.6 => CONNECTED DIRECTLY TO A STY.
				;4.7 => DON'T BUFFER MORE OUTPUT THAN ALLOCATION
				;4.8 => STY WANTS WAKEUP AT 1/2 SEC CLK
				;4.9 => TRANSFER IN 32 BIT MODE
IMSOC6:	BLOCK IMPSTL		;RH => BUFFER ADDRESS
				;4.9 => LOCKED BY CORE JOB
				;4.8 => ACTIVE AT PI LEVEL
				;4.7 => INPUT OCCURRED WHILE BUFFER LOCKED
				;3.1-3.8 => IOBFT INDEX (377 IF USING BIG BUFFER)
IMSOC7:	BLOCK IMPSTL		;BIT ALLOCATION
IMSOC8:	BLOCK IMPSTL		;MESSAGE ALLOCATION
IMSC7I:	BLOCK IMPSTL		;AMT TO INCREASE BIT ALLOCATION BY IN NEXT ALLOC MSG (INPUT)
				;FOR OUTPUT, HAS NUMBER OF BITS IN BUFFER
IMSC8I:	BLOCK IMPSTL		;AMT TO INCREASE MESSAGE ALLOCATION BY NEXT ALLOC MSG (INPUT)
IMSOCT:	BLOCK IMPSTL		;TIME WHEN FIRST MESS PUT INTO BUF
				;(DURING INPUT HAS NUMBER OF DATA BYTES LEFT IN CUR MSG)
				;(DURING CLOSE HAS TIME TIME-OUT STARTED)
IMSMPP:	BLOCK IMPSTL		;MAIN PROGRAM POINTER, ILDB OR IDPB FOR NEXT BYTE
IMSMPC:	BLOCK IMPSTL		;MAIN PROGRAM COUNTER, FOR OUTPUT HAS NUMBER OF DATA
				; BYTES OF ROOM LEFT IN BUFFER.  FOR INPUT HAS TOTAL
				; NUMBER OF DATA BYTES IN BUFFER.
IMSPIP:	BLOCK IMPSTL		;INTERRUPT LEVEL POINTER, FOR OUTPUT ILDB TO GET NEXT
				; BYTE OUT AT P.I. LEVEL.  FOR INPUT POINTS TO WHERE
				; HEADER WORD OF NEXT MESSAGE IN WILL BE STORED.
IMSBFE:	BLOCK IMPSTL		;BYTE POINTER TO LAST BYTE IN BUFFER
				;USE CAILE X,@IMSBFE(I) TO CHECK A WORD ADDRESS
IMSOKE==.-1		;END OF BLOCK FOR GETSYS CALL

BBLK

IMSCLN:	221000,,IMSOC4(I)	;LINK NUMBER
IMSCBS:	221000,,IMSOC5(I)	;BYTE SIZE
IMSCLS:	111100,,IMSOC5(I)	;CLOSE REASON
IMSCFH:	321000,,IMSOC4(I)	;FOREIGN HOST
IMSCHD:	222100,,IMSOC4(I)	;FOREIGN HOST AND LINK NUMBER
				; EXTRA BIT, SET WHEN RCV CLS
IMSCHL:	222000,,IMSOC4(I)	;FOREIGN HOST AND LINK WITHOUT EXTRA BIT

NTRFCL:	SIXBIT /NETRFC/		;FOR ICP ON ANY SOCKET < 1000
EBLK
	0

NETSRS==1000	;SMALLEST USER RECEIVE SOCKET NUMBER
NRSOC:	NETSRS	;NUMBER OF NEXT RECEIVE SOCKET TO BE GENERATED
NETOSW:	-1	;SWITCH LOCKED AT NET OPEN
	0
NETHSW:	-1	;SWITCH LOCKED IF HACKING HOST TABLE (IMPHTB)
	0
NETLST:	0	;LIST OF USERS IN NETWORK OPEN CODE

;INPUT BUFFER FORMAT:
;THE BUFFER IS CIRCULAR, AND EITHER 200 OR 2000 WORDS LONG.
;MAY CONTAIN SEVERAL MESSAGES.  EACH CONSISTS OF A HEADER WORD CONTAINING
; THE NUMBER OF BYTES IN THE MESSAGE, FOLLOWED BY THE BYTES, FOLLOWED BY
; UNUSED BITS UP TO THE NEXT WORD BOUNDARY.  THIS WEIRD FORMAT IS USED
; TO AVOID HAVING TO DO BYTE OPERATIONS AT P.I. LEVEL.
;A HEADER WORD OF -1 MEANS THAT THAT MESSAGE HAS NOT YET BEEN STORED.
;IMSPIP(I) ALWAYS CONTAINS THE ADDRESS OF A HEADER WORD OF -1.
;IMSMPP(I) HAS A BYTE POINTER TO THE NEXT DATA BYTE TO BE READ.
;P.I. LEVEL CAN STORE A MESSAGE INTO THE PART OF THE BUFFER FROM
;@IMSPIP TO @IMSMPP-1.
;IMSOCT(I) HAS THE NUMBER OF BYTES THAT MAIN PROGRAM LEVEL CAN
; READ BEFORE IT GETS TO THE END OF THE CURRENT MESSAGE AND HAS
; TO CHECK THE NEXT HEADER.
;IMSMPC(I) HAS THE TOTAL NUMBER OF DATA BYTES IN ALL THE MESSAGES
; IN THE BUFFER.

;OUTPUT BUFFER FORMAT:
;THE BUFFER IS CIRCULAR, AND EITHER 200 OR 2000 WORDS LONG.
;IT SIMPLY CONTAINS A STRING OF BYTES.
;IMSMPP(I) HAS A BYTE POINTER TO WHERE THE NEXT BYTE TO BE OUTPUT WILL BE DEPOSITED.
;IMSPIP(I) HAS A BYTE POINTER TO WHERE THE NEXT BYTE TO BE SENT OUT AT P.I.
; LEVEL WILL COME FROM.  P.I. LEVEL TRIES TO KEEP EVERYTHING ALIGNED ON
; WORD BOUNDARIES SO THAT IT DOESN'T HAVE TO DO BYTE OPERATIONS.
;IMSMPC(I) HAS THE NUMBER OF BYTES THAT MP LEVEL MAY STORE BEFORE RUNNING
; INTO OLD BYTES THAT HAVEN'T YET BEEN TRANSMITTED.
;IMSOCT(I) IS SET TO THE TIME THE FIRST BYTE IS PUT INTO THE BUFFER.
; IT IS CLEARED WHENEVER THE BUFFER GETS EMPTIED.

BBLK

SUBTTL	ARPANET MAIN-PROGRAM LEVEL

IMPINI:
IFE DMI,[
	CONO IMP,IMI32C
	DATAI IMP,A
	CONO IMP,IMPODC	;CLEAR OUTPUT DONE AND PIA
	CONSZ IMP,IMPOD+7	;CHECK OUTPUT DONE, PIA, CAUSE HOST READY
	 JRST 4,.	;CONO DIDN'T CLEAR SOME BITS
	CONO IMP,IMPIR+IMPHEC	;CLEAR HOST ERR, ENABLE INT ON IMP READY
]
IFN DMI,[
	CONO FI,FIRSET	;RESET IMP INTERFACE, SET HOST READY
	CONO FI,FIHSTS
]
	SETOM IMPIPI
	SETOM IMPOPI
	MOVE T,TIME
	ADDI T,15.
	CAMLE T,TIME
	 PUSHJ P,UFLS	;WAIT FOR HALF SECOND
IFE DMI,[
	CONO IMP,0	;CLEAR "ENABLE IMP READY" INT (TURNS OFF IMP ERROR)
	MOVEI A,NETCHN	;IDLE PIA
	MOVEM A,IMPPIA
	MOVE A,[JSR IMPIBK]
	MOVEM A,IMPILC
	MOVE A,[JSR IMPOBK]
	MOVEM A,IMPOLC
]
IFN DMI,CONO FI,FIIWDC	;CLEAR "IMP WAS DOWN"
	MOVSI I,-IMPSTL
IMPINA:	SKIPE IMSOC6(I)
	 JRST 4,.
	SETZM IMSOC1(I)
	AOBJN I,IMPINA
	SETZM IMPILC+1
	SETZM IMPOLC+1
	SETOM IMPOAC
	SETOM IMPMPU
	SETOM IMPUP	;NOT UP YET
	MOVNI A,20.	;ALLOW 10 SECONDS TO COME UP
	MOVEM A,IMPUCT
	SETOM IMPTCU	;TRYING TO COME UP
	SETOM IMPMPL
	SETOM IMPNCQ
	SETOM IMPLCQ
	SETOM IMPHTF	;WILL GC IMPHTB ON FIRST REFERENCE
	MOVEI I,IMNPIC
	MOVEM I,IMFCQL
	MOVEI A,IMPCQ
	MOVEM A,IMFFCQ
	JRST IMPIN1

IMPIN2:	ADDI A,IMPMQS+1
	MOVEM A,-IMPMQS-1(A)
IMPIN1:	SOJG I,IMPIN2
	SETOM (A)
	SETOM IMPBPQ
	SETOM IMPEPQ
	MOVEI A,IMPPQ
	MOVEM A,IMFFPQ
	MOVEI I,IMNPQ
	JRST IMPIN4

IMPIN3:	ADDI A,4
	MOVEM A,-4(A)
IMPIN4:	SOJG I,IMPIN3
	SETOM (A)
	MOVEI A,NETSRS
	MOVEM A,NRSOC
	MOVE A,[IMPN,,IMPN+1]
	SETZM IMPN
	BLT A,LIMPN
	SETOM IMPIS
	MOVE T,TIME
	MOVEM T,LNETIM
IFE DMI,CONO IMP,NETCHN
IFN DMI,[
	CONSZ FI,FIDOWN+FIWASD	;SKIP IF STILL UP
	 POPJ P,	;LOSE IF NOT IMP UP
	CONO FI,FIIN\FIIBSY+NETCHN*11
	CONO FI,FIOUT+NETCHN*11
]
	SETOM IMPDWN+1	;TIME FOR IMP TO GO DOWN, NOT KNOWN
	;MOVE T,TIME
	ADDI T,15.
	CAMLE T,TIME
	 PUSHJ P,UFLS
	SETZM IMPIS
	MOVNI A,4
	MOVEM A,IMNOPC	;SEND 4 NOPS
IMPOST:	CONO PI,NETOFF
IFN DMI,[
	CONSO FI,70	;SKIP IF PIA NON-ZERO
	 JRST NETONJ	;IF NO PIA, THEN DONT SET INT
]
IFE DMI,MOVE TT,IMPPIA	;MAIN PROGRAM OUTPUT START
	AOSN IMPOAC	;SKIP IF OUTPUT ALREADY ACTIVE
IFE DMI, CONO IMP,IMPODS(TT)	;GENERATE OUTPUT INTERRUPT
IFN DMI, CONO FI,FIODS+NETCHN*11
	JRST NETONJ

IMPIOS:
IFE DMI,[
	AOSE IMPOAC	;PI LEVEL OUTPUT START
	 POPJ P,
	PUSH P,TT
	CONO PI,400	;TURN PI OFF, IMP MAY HAVE PIA = 1
	MOVE TT,IMPPIA
	CONO IMP,IMPODS(TT)
	CONO PI,200
	POP P,TT
]IFN DMI,[
	AOSN IMPOAC
	 CONO FI,FIODS+NETCHN*11
]
	POPJ P,

;NET .CALL RCHST/RFNAME
NETRCH:	MOVEI W,8		;WE RETURN 8 VALUES.
	HRRE I,A
	JUMPL I,NETRC3		;NET WENT DOWN AFTER THIS CHANNEL WAS OPENED.
	MOVE B,IMSOC2(I)	;LOCAL SOCKET NUMBER
	MOVE C,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	LDB TT,IMSCFH		;FOREIGN HOST FOR 4TH WORD.
	CAIN TT,377
	 TDZA Q,Q
	  MOVE Q,IMPHTN(TT)
	LDB D,[112000,,Q]	;TRANSLATE NEW HOST NUMBER TO OLD
	ANDI Q,377		;IF IT WILL FIT IN OLD NOTATION
	CAIGE D,100
	 CAIL Q,4
	  SKIPA D,IMPHTN(TT)
	   DPB Q,[060200,,D]
	LDB Q,IMSCBS		;GET BYTE SIZE FOR HERE AND BELOW
;FOLLOWING LINE HAS BEEN PUNTED, AN INCOMPATIBLE CHANGE
;	DPB Q,[111100,,D]	;INTO 2.9-2.1 OF 4TH WORD
	MOVE A,IMSOC5(I)	;RANDOM WORD
	TLNE A,4000		;SKIP IF 4.3 BIT OFF (NETWRK INT)
	 TLO D,400000		;SET FOR USER
	PUSHJ P,NETRC1		;GET TIME IMP GOING DOWN,
	HRR TT,IMSOC4(I)	;MERGE IN SOCKET STATE.
	IMUL Q,IMSMPC(I)	;MULTIPLY BYTE SIZE BY BYTES AVAIL TO GET BITS AVAIL
	LDB I,IMSCLS		;CLS REASON
	POPJ P,

NETRC3:	MOVEI I,%NCNCP		;GIVE CLOSE REASON THAT OUR NCP WENT DOWN.
NETRC1:	SKIPG TT,IMPDWN+1	;SYS TIME AT WHICH IMP IS GOING DOWN
	 JRST NETRC2
	SUB TT,TIME		;(TIME TIL IMP DOWN -1=NOT. 0=DOWN, +=GOING DOWN, N/30. SEC)
	SKIPG TT
	 MOVEI TT,1		;IF SET TO GO DOWN, AND TIME "PASSED", SAY SOON IF NOT ALREADY DOWN
NETRC2:	HRLZS TT
	POPJ P,

;NET .CALL STATUS - SOCKET STATE IN BITS 2.4-2.9
STANET:	TRNN A,400000		;SKIP IF NET WENT DOWN ON THIS LOSER
	 SKIPA E,IMSOC4(A)	;GET STATE
	  MOVEI E,0		;IF NCP WENT DOWN, STATE IS "CLOSED"
	DPB E,[140600,,D]
	POPJ P,

;NET .CALL RESET - ONLY RESETS "INT FM NETWORK" BIT (INR/INS)
NETRS:	HLRZ A,(R)		;GET LH IOCHNM
	MOVSI B,4000		;4.3 BIT
	TRNN A,400000		;SKIP IF SET TO -1 (NET WENT DOWN ON THIS CHAN)
	 ANDCAM B,IMSOC5(A)	;CLEAR BIT
	POPJ P,

;NET .CALL IOPUSH/IOPOP - ALTER THE CHANNEL-OPEN MASK IN IMSOC1.
NETIOP:	HRRZ T,UUAC(U)
	IMUL I,CHNBIT(T)	;PUSHING => 0; ELSE BIT FOR CHANNEL BEING POPPED.
	HLRZ T,(R)		;GET SOCKET TABLE IDX
	TRNN T,400000		;SKIP IF NET WENT DOWN ON THIS LOSER
	 DPB I,[222000,,IMSOC1(T)] ;STORE MASK AWAY.
	POPJ P,

;NET .CALL WHYINT
;RESULTS ARE %WYNET, SOCKET STATE, BYTES AVAIL, CLS REASON
NETWHY:	HRRE I,A		;GET IMSOC INDEX
	MOVEI A,%WYNET		;FIRST RESULT IS DEVICE CODE
	SETZB B,C		;SET UP RESULTS 2-4 IN CASE NCP WENT DOWN
	MOVEI D,%NCNCP
	JUMPL I,POPJ1		;RETURN IF NCP WENT DOWN ON THIS LOSER
	HRRZ B,IMSOC4(I)	;SECOND RESULT IS SOCKET STATE
	MOVE Q,IMSOC5(I)
	TLNE Q,4000
	 TLO B,400000		;SIGN OF SECOND RESULT SET IF NETWRK INT
	TLNE Q,40000		;DIRECT CONNECTED?
	 TDZA C,C		;YES, NO BYTES AVAILABLE FOR INPUT
	  MOVE C,IMSMPC(I)	;THIRD RESULT IS BYTES AVAILABLE
	LDB D,IMSCLS		;FOURTH RESULT IS CLOSE REASON
	JRST POPJ1

;AIDS TO NETWORK OPEN AND NETHST CALLS

;SET THINGS UP AND ALLOCATE AN IMSOC INDEX.
;SKIP RETURNS WITH NETLST AND IMSOC1(I) LOCKED.
;OR, RETURNS NO-SKIP WITH NOTHING LOCKED AND AN ERROR SIGNALLED.
NETO00:	PUSHJ P,LSTSET	;ADD THIS JOB TO LIST OF NET OPENERS
	    NETLST
	PUSHJ P,SWTL	;GET AN IMSOC ENTRY TO GC-PROTECT OUR IMPHTB ENTRY
	    NETOSW
	MOVSI I,-IMPSTL
	SKIPE IMSOC1(I)
	 AOBJN I,.-1
	JUMPG I,OPNL6	;DEVICE FULL
	MOVEI H,377	;NO HOST YET
	DPB H,IMSCFH
	HRRZM U,IMSOC1(I) ;IMSOC1 POSITIVE MEANS ALLOCATED BUT NOT INITED YET
	PUSHJ P,LSWPOP	;NETOSW
	PUSHJ P,LOSSET	;RETURN IMSOC ENTRY IF PCLSR
	    NETIRT
	JRST POPJ1

;LOSSET ROUTINE TO RETURN IMSOC ENTRY
NETIRT:	MOVE T,AC0S+I(U)
	HRRZ A,U
	CAME A,IMSOC1(T)
	 JRST 4,.
	SETZM IMSOC1(T)
	POPJ P,

;SUBROUTINE TO STANDARDIZE HOST NUMBER, OPNL25 IF NO GOOD
;PROCESSES HOST NUMBER IN T, MUNGS H, CALLED BY JSP J,STDHST
STDHST:	LDB H,[331000,,T]	;GET NETWORK-NUMBER FIELD
	CAIE H,12		;ONLY 12 OR 0 IS ACCEPTABLE
	 JUMPN H,OPNL25
	TDNE T,[400600,,400]	;MAKE SURE OTHER RANDOM BITS AREN'T ON
	 JRST OPNL25
	TLZ T,777000		;CLEAR NETWORK NUMBER
	JUMPE T,OPNL25		;0 IS NOT ACCEPTABLE
	CAIL T,400		;SKIP IF OLD-STYLE HOST NUMBER
	 JRST (J)
	LDB H,[060200,,T]	;GET HOST FIELD
	ANDI T,77		;GET IMP FIELD
	EXCH H,T
	DPB H,[112000,,T]	;RECOMBINE
	JRST (J)
	
;SUBROUTINE TO OPEN UP COMMUNICATIONS WITH THE DESIRED HOST.
;ENTER WITH HOST NUMBER IN SRN3(U), SKIP-RETURN WITH HOST
;UP AND IMPHTB INDEX IN H AND IMSCFH.  OR NON-SKIP RETURN WITH ERROR SIGNALLED.
NETOR:	MOVE T,SRN3(U)	;USER-SPECIFIED HOST NUMBER
	JSP J,STDHST	;STANDARDIZE, OPNL25 IF IT IS NO GOOD
	CONO PI,NETOFF
	PUSHJ P,FNDHST	;H GETS HOST TABLE INDEX
	 JRST OPNL6	;DEVICE FULL (HOST TABLE FULL)
	DPB H,IMSCFH	;PROTECT IN IMSOC4
	CONO PI,NETON
	PUSHJ P,SWTL	;POSSIBLY SEND RST TO HOST OPENING CONNECTION TO
	    NETHSW
	LDB J,IMHSBT	;GET STATUS
	SOJG J,NETORS	;-1 => DOWN, 0 => RST SENT, 1 => UP
	JUMPE J,NETOR1	;WAIT FOR REPLY
	PUSHJ P,NETOW	;WAIT FOR IMPMPC TO BE FREE
	LDB W,[051100,,TIME]
	DPB W,[221100,,IMPHTB(H)]
	MOVEI J,1
	DPB J,IMHSBT	;MARK AS SENT
	AOS IMRFCT
	PUSHJ P,STHSTM	;STORE HOST#, LINK 0 , MESSAGE TYPE 0
	MOVE W,[8_24.+1_8]	;BYTE SIZE = 8, BYTE COUNT = 1
	MOVEM W,IMPMPC+6
	MOVE W,[12._28.]	;RST
	MOVEM W,IMPMPC+7
	MOVEI W,1
	HRRM W,IMPMPC	;MESSAGE LENGTH
	PUSHJ P,IMPMPQ	;SEND IT OUT
NETOR1:	PUSHJ P,LSWPOP	;NETHSW
	PCLT
	MOVSI T,1000
	TDNE T,IMPHTB(H) ;RRP -> 2000,  DOWN -> 0000
	 PUSHJ P,UFLS
	LDB J,IMHSBT	;GET STATUS
	SOJL J,OPNL41	;HOST DOWN
	JUMPE J,NETOR	;TRY ALL THIS AGAIN
	JRST POPJ1	;HOST UP

NETORS:	PUSHJ P,LSWPOP	;NETHSW
	JRST POPJ1	;HOST IS UP

;NETWORK OPEN

;	.OPEN CH,BLK
;	ERROR RETURN
;	NORMAL RETURN

;BLK:	MODE BITS,,(SIXBIT /NET/)
;	LOCAL SOCKET NUMBER (1.1-4.5)
;	FOREIGN SOCKET NUMBER (1.1-4.5)
;	FOREIGN HOST NUMBER

;BLK:	3.1-3.3 => STANDARD ASCII/IMAGE, UNIT/BLOCK, INPUT/OUTPUT
;	3.4 = 1 => GENERATE UNIQUE LOCAL RECEIVE (SEND) SOCKET NUMBER
;	3.4 = 0 => USE LOCAL SOCKET NUMBER SPECIFIED IN BLK+1
;	3.5 => OPEN SOCKET IN LISTEN MODE
;	3.6 => IF IMAGE MODE, USE BYTE SIZE IN 4.1-4.6
;	       IF ASCII MODE, USE 8 BIT BYTES RATHER THAN 7
;	3.7 => USE BIG BUFFER (2000 WORDS INSTEAD OF 200)
;	3.8 => DON'T BUFFER MORE OUTPUT THAN ALLOCATION
;	4.1-4.6 = BYTE SIZE IN IMAGE MODE


;OPEN CODE
NETO:	SKIPN IMPUP
	 JRST NETOUP
	SKIPL IMPUP
	 JRST OPNL7	;DEVICE NOT READY
	CONO PI,NETOFF
	SKIPN IMPTCU
	 AOS IMPTCU
	CONO PI,NETON
	MOVSI I,SCLIMP
	IORM I,SUPCOR	;HAVE SYS JOB BRING UP THE NETWORK
	PCLT
	SKIPE IMPTCU	;WAIT WHILE IT TRIES TO COME UP
	 PUSHJ P,UFLS
	SKIPE IMPUP
	 JRST OPNL7	;LOSE IF NOT UP BY NOW
NETOUP:	TLZ A,740000	;IGNORE EXTRA BITS IN SOCKET NUMBERS
	TLZ B,740000
	PUSHJ P,NETO00	;INITIALIZE THINGS
	 POPJ P,	;NETWORK NOT UP OR FULL
	TLNE C,20	;SKIP IF NOT LISTEN
	 JRST NETO10
	PUSHJ P,NETOR	;DO RESET STUFF, OPEN COMMUNICATIONS WITH HOST
	 POPJ P,	;HOST DOWN OR ILLEGAL
	MOVE J,B	;CHECK GENDER OF FOREIGN SOCKET
	ROT J,-1
	XOR J,D
	JUMPGE J,OPNL2	;WRONG DIRECTION
;DROPS THROUGH
;DROPS IN
NETO10:	PUSHJ P,SWTL	;ONLY ONE PROCESS AT A TIME COMPARING SOCKET NUMBERS
	    NETOSW
	TLNN C,20	;SKIP IF LISTEN
	 PUSHJ P,NETOW	;GOBBLE MP CONTROL LINK BLOCK (FOR NETOS)
	TLNN C,10
	 JRST NETO1	;USE SOCKET NUMBER GIVEN IN WORD 2
	MOVEI A,10	;ADVANCE SYSTEM UNIQUE SOCKET NUMBER
	ADDB A,NRSOC
	SUBI A,10	;UNIQUE RECEIVE SOCKET NUMBER
	SKIPGE D	;SKIP IF OPEN IS FOR READ (RECEIVE)
	 IORI A,1	;MAKE INTO SEND SOCKET
	JRST NETO6

NETO1:	MOVE J,A	;USER SPECIFIED SOCKET NUMBER
	ROT J,-1	;J 4.9: 0 => RECEIVE  1 => SEND
	EQV J,D		;D 4.9: 0 => READ  1 => WRITE
	JUMPGE J,OPNL2	;WRONG DIRECTION
	MOVE J,A
	CAIL A,NETSRS	;SKIP IF SPECIAL SOCKET
	 TRZA J,7	;J HAS BASE OF SOCKET GROUP
	  MOVNI J,1	; OR -1 IF NOT IN A GROUP
	MOVSI Q,-IMPSTL
	MOVEI E,0
NETO2:	SKIPL W,IMSOC1(Q)
	 JRST NETO3	;NOT HOOKED UP
	CAMN A,IMSOC2(Q)
	 JRST NETO2A	;DUPLICATE LOCAL SOC #
	MOVE T,IMSOC2(Q)
	TRZ T,7
	CAMN J,T
	 JRST NETO4	;JUMP IF PART OF SOCKET GROUP
NETO3:	AOBJN Q,NETO2
	SKIPL J		;SKIP IF NOT PART OF A SOCKET GROUP
	 JUMPE E,OPNL23	;FOUND NO EVIDENCE THAT THIS GUY OWNS THIS GROUP
	JRST NETO6	;WINNING

NETO2A:	TLNN W,200000	;SKIP IF BEING CLOSED
	 JRST OPNL13	;NO, GIVE ERROR
	TLNN C,20
	 PUSHJ P,LSWPOP	;POP MP CONTROL LINK BLOCK
	PUSHJ P,LSWPOP	;NETOSW
	MOVSI T,200000
	PCLT
	TDNE T,IMSOC1(Q)
	 PUSHJ P,UFLS	;WAIT TILL CLOSED
	JRST NETO10	;TRY AGAIN

NETO4:	CAIE U,(W)
	 JRST OPNL23	;SOMEONE ELSE HAS IT
	MOVNI E,1	;OK IF NO OTHER CONFLICTS
	JRST NETO3

;HERE WITH SUITABLE LOCAL SOCKET IN A
NETO6:	TLNN C,4	;SKIP IF IMAGE MODE
	 JRST NETOC	;ASCII MODE
	MOVEI TT,36.
	TLNN C,40	;SKIP IF BYTE SIZE SUPPLIED
	 JRST NETOB
	LDB E,[330600,,C]	;USE USER SUPPLIED BYTE SIZE
	IDIVI E,36.	;TT GETS BYTE SIZE MOD 36.
	JUMPN TT,NETOB
	MOVEI TT,36.	;36 BITS ANYWAY
NETOB:	PUSH P,TT
	MOVEI E,36.
	IDIV E,TT	;36/BS
	JUMPE TT,NETOB1	;EXACT
	MOVEI E,32.
	IDIV E,(P)	;32/BS
	JUMPE TT,[MOVEI TT,400000	;32BIT MODE FLAG
		 JRST NETOB1]
	MOVEI TT,2000		;FUNNY BYTESIZE FLAG
NETOB1:	POP P,E		;BS
	ADD TT,E	;FLAGS+BS
	JRST NETOA

NETOC:	MOVEI TT,400410		;7 BIT
	TLNE C,40
	 MOVEI TT,401010	;8 BIT
NETOA:	TLNE C,200
	 TRO TT,100000		;DON'T BUFFER MORE OUTPUT THAN ALLOCATION
	HRLZM TT,IMSOC5(I)	;STORE FLAGS AND BC, CLEAR CLOSE REASON
	MOVEM A,IMSOC2(I)	;LOCAL SOCKET NUMBER
	MOVEM B,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	SETZM IMSOCT(I)		;IF INPUT, NOT IN MIDDLE OF A MESSAGE
	MOVEI W,%NSRFS
	TLNE C,20		;3.5 LISTEN
	 MOVEI W,%NSLSN
	DPB H,[321000,,W]	;DON'T CHANGE HOST NUMBER FIELD OF IMSOC4
	MOVEM W,IMSOC4(I)	;SET INITIAL STATE, CLEAR FLAGS
	SKIPE IMSOC6(I)		;SKIP IF HAVEN'T ASSIGNED BUFFER YET
	 JRST 4,.
	PUSH P,A
	PUSH P,B
	PUSH P,D
NETOE1:	TLNN C,100		;LAST PLACE TO PCLSR (REALLY NETMW)
	 JRST NETOE7
	PUSHJ P,TCALL		;GET FULL-PAGE BUFFER
	    JRST IOMQ
	 JRST NETMW
	MOVEI W,MUNET
	DPB W,[MUR,,MEMBLT(A)]
	DPB I,[MNUMB,,MEMBLT(A)]
	LSH A,10.
	MOVE W,A		;BUFFER START ADDRESS
	HRLI W,377		;NOT AN IOBFT-TYPE BUFFER
	MOVEI A,1777(A)		;BUFFER END ADDRESS
	JRST NETOE4

NETOE7:	MOVEI D,NFNETC(I)
	PUSHJ P,TCALL
	    JRST IUTCO1		;GET 200-WD BUFFER
	 JRST NETMW		;NO MEM AVAIL
	LDB W,[IOSA,,IOBFT(A)]
	LSH W,6			;STARTING ADDRESS
	HRL W,A			;IOBFT INDEX
	MOVEI A,177(W)		;BUFFER END ADDRESS
NETOE4:	MOVEM A,IMSBFE(I)	;(LH WILL BE STORED LATER)
	MOVEM W,IMSOC6(I)
;CLEAR THE BUFFER FOR EASE IN DEBUGGING.  COMMENT USED TO CLAIM
;THAT CLEARING IT WAS NECESSARY IN ORDER TO OUTPUT CORRECT HEADERS,
;BUT THAT WAS FRAUDULENT SINCE HEADERS NEVER COME FROM THE BUFFER.
	MOVEI D,1(W)
	HRLI D,(W)
	SETZM (W)
	BLT D,(A)
	POP P,D
	POP P,B
	POP P,A
;DROPS THROUGH
;DROPS IN

	MOVSI Q,000100		;SET UP THE VARIOUS BYTE POINTERS
	LDB TT,IMSCBS		;TO POINT TO END OF BUFFER
	MOVE E,IMSOC5(I)	;SO ILDB WILL GET FIRST BYTE IN BUFFER
	TLNN E,2000		;SKIP IF ONE BIT BYTES
	 DPB TT,[300600,,Q]	;OTHERWISE USE USER BYTE SIZE
	SKIPGE E
	 TLO Q,040000		;32 BIT WORD ENDS 4 BITS OVER
	HRR Q,IMSBFE(I)
	MOVEM Q,IMSMPP(I)
	MOVEM Q,IMSPIP(I)
	MOVEM Q,IMSBFE(I)
	MOVE T,C		;GET 3.5 BIT OF C INTO
	LSH T,13.		;4.9 OF T
	JUMPL D,NETOE5		;JUMP IF SENDER
	SETOM (W)		;NULL FIRST HEADER WORD
	TLO Q,440000		;-> LEFT END OF WORD
	HRR Q,W
	MOVEM Q,IMSPIP(I)	;SET PI PNTR TO POINT TO FIRST MESSAGE HEADER
	SETZM IMSMPC(I)		;NO INPUT BYTES AVAILABLE YET
	MOVEI TT,20.		;MESSAGE ALLOCATION ALWAYS 20
	MOVEM TT,IMSOC8(I)
	HRRZ TT,IMSBFE(I)	;COMPUTE BIT ALLOCATION
	SUBI TT,2*20.(W)	;TT := # WORDS IN BUFFER, -1 FOR LUCK, -2 FOR EACH MSG
	SKIPGE IMSOC5(I)	; (-1 FOR HEADER WORD, AND -1 FOR BREAKAGE)
	 IMULI TT,32.		;CONVERT TO # BITS
	SKIPL IMSOC5(I)
	 IMULI TT,36.
	LDB Q,IMSCBS		;BREAKAGE WAS OVER-ESTIMATED BY 1 BYTE PER MSG
	IMULI Q,20.
	ADD TT,Q
	MOVEM TT,IMSOC7(I)	;STORE CORRECT BIT ALLOCATION
	SETZM IMSC8I(I)
	SETZM IMSC7I(I)
	MOVEI Q,2(I)		;LINK #
	DPB Q,IMSCLN		;STORE IN LINK # FIELD
	JRST NETOE6

NETOE5:	SETZM IMSOC7(I)		;INITIALIZE SENDER'S ALLOCATIONS
	SETZM IMSC7I(I)
	SETZM IMSOC8(I)
	HRRZ TT,IMSBFE(I)
	SUBI TT,(W)		;# BUFFER WORDS, -1 FOR LUCK
	SKIPGE IMSOC5(I)	;SKIP IF 36BIT
	 IMULI TT,32.		;ALLOW 32 BITS PER WORD
	SKIPL IMSOC5(I)
	 IMULI TT,36.		;OR 36 BITS PER WORD
	LDB E,IMSCBS
	IDIVM TT,E		;CONVERT TO NUMBER OF BYTES
	MOVEM E,IMSMPC(I)	;THAT MANY ARE FREE AT FIRST
NETOE6:	PUSHJ P,IMPSPQ		;SEARCH PENDING QUEUE (LEAVES UTCOFF)
	 JRST NETOG		;NOTHING THERE
	JUMPGE T,NETOH		;JUMP IF NOT LISTENING STATE
	MOVE W,2(Q)		;FOREIGN SOCKET NUMBER
	MOVEM W,IMSOC3(I)
	LDB H,[101000,,3(Q)]	;FOREIGN HOST IMPHTB INDEX
	DPB H,IMSCFH
	SKIPA W,[%NSRFC]
NETOH:	 MOVEI W,%NSOPN
	HRRM W,IMSOC4(I)
	JUMPGE D,NETOD1		;JUMP IF RECEIVER
	SKIPL W,3(Q)		;SKIP IF RTS, GET LINK #
	 JRST 4,.		;HE SENT STR
	DPB W,IMSCLN		;STORE LINK NUMBER
NETOD:	HRRZ Q,UUAC(U)		;CHANNEL OPEN ON
	MOVE Q,CHNBIT(Q)
	PUSHJ P,IMPUIM		;INTERRUPT SELF
	JRST NETOG		;GO FINISH THE OPEN

NETOD1:	SKIPGE W,3(Q)		;SKIP IF STR, GET BYTE SIZE
	 JRST 4,.		;HE SENT RTS
	ANDI W,377
	LDB Q,IMSCBS
	CAMN W,Q
	 JRST NETOD		;BYTE SIZES DIFFER, LOSE
	PUSHJ P,IMPBRT		;RETURN THE BUFFER
	JRST OPNL22		;SELF-CONTRADICTORY OPEN?

NETOG:	HRRZ W,UUAC(U)
	MOVS W,CHNBIT(W)
	TLO W,400000		;IN USE
	HRR W,U			;SETZ+<<INT MASK>,,<USER WHO HAS SOCKET>>
	MOVEM W,IMSOC1(I)	;WE ARE NOW FULLY SET UP TO THIS SOCKET
	CONO PI,NETON
	TLNN C,20		;SKIP IF LISTENING TYPE SOCKET
	 PUSHJ P,NETOS		;SEND RFC (CAN'T HANG, ALREADY GOT NETOW)
	PUSHJ P,LSWPOP		;UNLOCK NETOSW, NOW THAT IMSOC1 4.9 IS SET
	PUSHJ P,LSWDEL		;UNLOCK IMSOC1(I)
	PUSHJ P,LSWPOP		;REMOVE FROM LIST OF NETWORK OPENS IN PROGRESS
	HRLZ A,I		;LEFT HALF OF IOCHNM GETS SOCKET INDEX
	HLRZS C
	JSP Q,OPSLC7
	    NETDUI,,NETDUO
	    NETDBI,,NETDBO
	    NETDUI,,NETDUO
	    NETDBI,,NETDBO

;GOBBLE MAIN PROGRAM CONTROL LINK BLOCK

NETOW:	JUMPL U,NETOW1		;FROM STYNET CLOCK LEVEL
	PCLT
	SKIPGE IMPHTB(H)	;SKIP IF NOT RFNM WAIT ON LINK 0
	 PUSHJ P,UFLS
	PUSHJ P,SWTL		;GRAB CONTROL LINK BLOCK
	    IMPMPU
	SKIPL IMPHTB(H)		;DID CTL LINK TO THIS HOST GET BACK INTO RFNM WAIT?
	 POPJ P,		;NO, OK
	PUSHJ P,LSWPOP		;YES, RELEASE RESOURCE WHILE AWAITING RFNM
	JRST NETOW

;FROM NETIDC (AT CLOCK INTERRUPT LEVEL)
NETOW1:	SKIPL IMPHTB(H)
	 AOSE IMPMPU
	  CAIA		;INPUT CAN'T BE READ YET.
	   POPJ P,
	CONO PI,NETOFF
	PUSHJ P,IMPUIN	;REACTIVATE SO WILL CHECK AGAIN
	SUB P,[2,,2]	;THROW THROUGH NETI6, NETID
	JRST NETOJ1	;TAKE NO-INPUT-AVAILABLE EXIT

;WAIT FOR MEMORY SO CAN ALLOCATE BUFFER

NETMW:	PCLT			
	MOVEI T,3
	CAMG T,LMEMFR
	 JRST [	PUSHJ P,UDELAY	;MAYBE MEMORY FROZEN, GIVE CORE JOB
		JRST NETOE1 ]	;A CHANCE TO PCLSR US, THEN TRY AGAIN
	CAMLE T,LMEMFR	;SKIP WHEN MORE THAN 3K FREE
	 PUSHJ P,UFLS
	JRST NETOE1

;SEND RFC AND MAYBE ALLOCATE.  IMSOC INDEX IN I, HOST INDEX IN H.

NETOS:	PUSHJ P,STHSTM		;STORE HOST ADDRESS IN IMPMPC+n, ALSO MESSAGE TYPE
	MOVE J,[8_24.+13._8]	;BYTE SIZE = 8, BYTE COUNT = 13.
	MOVEM J,IMPMPC+6
	MOVEI J,1_4		;3 NOPS + RTS
	SKIPGE D		;SKIP IF INPUT
	 MOVEI J,2_4		;3 NOPS + STR
	MOVEM J,IMPMPC+7
	LSH A,4			;LOCAL SOCKET NUMBER
	MOVEM A,IMPMPC+10
	LSH B,4			;FOREIGN SOCKET NUMBER
	MOVEM B,IMPMPC+11
	MOVEI TT,2(I)		;LINK NUMBER FOR RECEIVE SOCKET
	SKIPGE D
	 LDB TT,IMSCBS		;BYTE SIZE FOR SEND SOCKET
	LSH TT,28.
	HRRZ J,IMSOC4(I)
	CAIE J,%NSRFC
	 CAIN J,%NSOPN		;SKIP IF CONNECTION NOT YET OPEN
	  JUMPGE D,NETOS2	;JUMP IF CONNECTION OPEN AND READ
	MOVEM TT,IMPMPC+12
	MOVEI TT,4		;TEXT LENGTH
NETOS3:	HRRM TT,IMPMPC
	JRST IMPMPQ

NETOS2:	MOVEI J,<4_8>+2(I)	;NOP + ALL + LINK #
	LSH J,4
	IOR TT,J
	MOVEM TT,IMPMPC+12
	MOVE TT,IMSOC8(I)	;SEND MESSAGE ALLOC
	LSH TT,16.+4
	MOVEM TT,IMPMPC+13
	MOVE TT,IMSOC7(I)	;SEND BIT ALLOC
	LSH TT,16.+4
	MOVEM TT,IMPMPC+14
	MOVE TT,[8_24.+22._8]	;BYTE COUNT = 22.
	MOVEM TT,IMPMPC+6
	MOVEI TT,6		;MESSAGE LENGTH
	JRST NETOS3

;HOST-TABLE MANAGEMENT

;CALL HERE WITH HOST/IMP IN T, RETURNS HOST TABLE INDEX IN H.
;SKIP RETURNS IF SUCCEEDS, NON-SKIP IF HOST-TABLE IS FULL.
;CALL WITH NETOFF OR IN PROGRESS.  SMASHES W.
FNDHST:	MOVEI H,LIMPHT-1	;SEARCH FOR AN ENTRY FOR THIS HOST
	CAME T,IMPHTN(H)
	 SOJGE H,.-1
	JUMPGE H,POPJ1		;FOUND
	SKIPGE H,IMPHTF		;NOT FOUND, CONS ONE OFF FREE LIST
	 JRST FNDHS1		;OOPS, MUST GARBAGE COLLECT
	MOVE W,IMPHTB(H)
	MOVEM W,IMPHTF
	MOVEM T,IMPHTN(H)
	SETZM IMPHTB(H)		;NOTHING IS KNOWN ABOUT THIS HOST
	JRST POPJ1

;GC MARK PHASE.  POINTERS ARE IMSOC4<3.9-4.7>, IMPCSH, RFC QUEUE,
;PI CONTROL MESSAGE QUEUE, AND RFNM-WAIT AND RST-SENT BITS.
FNDHS1:	PUSH P,I
	MOVSI W,200000		;MARK BIT
	MOVEI H,LIMPHT-1	;CLEAR ALL MARK BITS
	ANDCAM W,IMPHTB(H)
	SOJGE H,.-1
	SKIPL H,IMPCSH		;MARK FROM IMPCSH
	 IORM W,IMPHTB(H)
	MOVEI I,IMPSTL-1	;MARK FROM IMSOC4
FNDHS2:	SKIPN IMSOC1(I)		;SKIP IF IMSOC4 IS BEING USED BY ANYONE
	 SOJGE I,FNDHS2
	JUMPL I,FNDHS3
	LDB H,IMSCFH
	CAIE H,377
	 IORM W,IMPHTB(H)
	SOJGE I,FNDHS2
FNDHS3:	MOVE I,IMPBPQ		;MARK RFC PENDING QUEUE
	JUMPGE I,[ LDB H,[101000,,3(I)]
		   IORM W,IMPHTB(H)
		   MOVE I,(I)
		   JRST . ]
	MOVE I,IMPNCQ		;MARK CONTROL QUEUE
	JUMPGE I,[ HLRZ H,1(I)
		   IORM W,IMPHTB(H)
		   MOVE I,(I)
		   JRST . ]
;SWEEP PHASE
	SETO I,			;FREE POINTER
	MOVEI H,LIMPHT-1
	MOVSI W,601000		;PROTECT IF RFNM-WAIT, RST-WAIT, OR MARKED
FNDHS4:	TDNE W,IMPHTB(H)
	 SOJGE H,FNDHS4
	JUMPL H,FNDHS5
	SETZM IMPHTN(H)		;DON'T BELONG TO ANY HOST
	MOVEM I,IMPHTB(H)	;CONS ONTO FREE LIST
	MOVE I,H
	SOJGE H,FNDHS4
FNDHS5:	MOVEM I,IMPHTF		;FREE LIST
	POP P,I
	SKIPGE IMPHTF
	 POPJ P,		;GC-OVERFLOW
	JRST FNDHST		;TRY AGAIN, SHOULD WIN

;.NETAC CH,	;ACCEPT CONNECTION
;ERROR RETURN
;NORMAL RETURN

ANETAC:	JSP T,NETCHK
	HRRZ T,IMSOC4(I)	;SOCKET STATE
	CAIE T,%NSRFC
	 JRST OPNL41		;NOT IN RFC RECEIVED STATE
	LDB H,IMSCFH
	PUSHJ P,NETOW		;GET IMPMPC
	MOVE A,IMSOC2(I)	;LOCAL SOCKET NUMBER
	MOVE B,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	MOVE D,A
	ROT D,-1
	PUSHJ P,NETOS		;SEND RFC (AND MAYBE ALL)
	CONO PI,NETOFF
	HRRZ T,IMSOC4(I)
	MOVEI TT,%NSOPN
	CAIN T,%NSRFC
	 HRRM TT,IMSOC4(I)	;CONNECTION OPEN
	JRST NETOJ1

NETCHK:	HRRZ A,(R)
	CAIL A,NETDUI
	CAILE A,NETDBO
	 JRST OPNL34	;NOT A NETWORK CHANNEL
	HLRE I,(R)	;SOCKET TABLE INDEX
	JUMPGE I,(T)
	JRST OPNL41	;OTHER END OF PIPELINE GONE (NET WENT DOWN)
	
;.NETS CH,	;SEND BUFFER NOW
;RETURN

NETFRC:	JSP T,NETCHK	;ENTRY FROM .CALL FORCE
	MOVE T,IMSOC2(I)
	TRNN T,1
	 JRST OPNL2	;NOT SEND SOCKET
	CONO PI,NETOFF
	MOVE T,IMSMPP(I)
	CAMN T,IMSPIP(I)
	 JRST NETOJ1	;BUF EMPTY
	MOVSI TT,400000	;TURN ON SEND BUFFER BIT
	IORM TT,IMSOC4(I)
	PUSHJ P,IMPOST	;TURNS NETON
	JRST POPJ1

NETFIN:	HRRZ TT,IMSBFE(I)	;ENTRY FROM .CALL FINISH (NETFRC HAS BEEN CALLED)
	SUB TT,IMSOC6(I)	.SEE NETOE5 ;FOR COMMENTS FOR THIS CODE
	HRRZS TT
	SKIPGE IMSOC5(I)
	 IMULI TT,32.
	SKIPL IMSOC5(I)
	 IMULI TT,36.
	LDB T,IMSCBS
	IDIVM TT,T		;T NOW HAS SIZE OF OUTPUT BUFFER IN BYTES
	CAME T,IMSMPC(I)	;WAIT FOR BUFFER TO EMPTY OUT
	 PUSHJ P,UFLS
	MOVEI T,%NSRFN		;WAIT FOR RFNM
	HLL T,IMSOC4(I)		;4.9 IS KNOWN TO BE OFF NOW!
	CAMN T,IMSOC4(I)
	 PUSHJ P,UFLS
	JRST POPJ1

;.NETINT CH,	;SEND NETWORK INTERRUPT "INR" OR "INS"
	;INR FROM RECEIVER TO SENDER (LOCAL SOCKET EVEN, FOREIGN ODD)
	;INS FROM SND TO RCV ( -", -")
;ALSO .CALL NETINT, ARG 1 IS CH

NNETINT:JSP T,NETCHK
	AOSA (P)	;GOING TO WIN, SKIP RETURN
ANETINT: JSP T,NETCHK	;I<- SOCKET TABLE INDEX
	LDB H,IMSCFH	;HOST INDEX FOR NETOW
	PUSHJ P,NETOW	;WAIT FOR IMPMPU
	MOVEI A,1	;SET COUNT
	MOVEM A,IMPMPC
	PUSHJ P,STHSTM	;STORE HOST ADDRESS
	MOVE A,[8_24.+2_8]	;BYTE SIZE 8, COUNT 2
	MOVEM A,IMPMPC+6
	MOVE A,IMSOC2(I)	;LCL SOCK #
	MOVSI B,7_10.	;INR
	TRNE A,1	;SKIP IF RCV
	 MOVSI B,8_10.	;INS
	LDB A,IMSCLN	;LINK #
	DPB A,[241000,,B]
	MOVEM B,IMPMPC+7
	JRST IMPMPQ	;QUE IT, START OUTPUT (IMPOST)

;STORE HOST ADDRESS FROM H INTO LEADER IN IMPMPC.  BASHES W, Q.
STHSTM:	MOVEI Q,IMPMPL
	HRLM H,IMPMPC		;ALSO SAVE HOST INDEX FOR PI LEVEL
;STORE HOST ADDRESS FROM H INTO LEADER IN (Q), BASHES W.
STHSTP:	MOVE W,IMPHTN(H)	;FOREIGN HOST NUMBER
	DPB W,[301000,,3(Q)]	;STORE HOST NUMBER
	LSH W,-9
	DPB W,[102000,,3(Q)]	;STORE IMP NUMBER
	MOVSI W,17_10.		;NEW-FORMAT FLAG
	MOVEM W,2(Q)		;MESSAGE TYPE 0 (LINK, ETC. ARE ALWAYS ZERO)
	POPJ P,

;.CALL NETBLK		;WAIT FOR STATE TO CHANGE OR TIME OUT
; ARG 1 - CHANNEL
; ARG 2 - STATE
; ARG 3 - TIME, AS IN .SLEEP (OPTIONAL) (WRITTEN BACK)
; VAL 1 - NEW STATE
; VAL 2 - TIME LEFT

ANETBLK:JSP T,NETCHK
	MOVE T,I	;SAVE INDEX IN T
	HRL T,B		;STATE ALSO
	CAIGE W,3	;SKIP IF 3 ARGS (TIME GIVEN)
	 JRST ANETB3	;USE DEFAULT TIME
	TLNE C,1000	;SKIP IF POINTER, RATHER THAN IMMEDIATE
	 JRST ANETB5
	XCTR XRW,[MOVES B,(C)]	;GET TIME FROM USER (CHECK WRITE ALSO)
	JUMPL B,ANETB1	;NEG MEANS ALREADY ABS TIME
	MOVNS B		;MAKE NEG
	SUB B,TIME	;-TIME TO GO TO
ANETB1:	XCTR XW,[MOVEM B,(C)]	;STORE NEG TIME FOR PCLSR
	MOVNS B		;MAKE +
ANETB4:	MOVEM B,EPDL(U)	;ALSO USED IN B LATER
	PUSHJ P,ANETB2	;SKIP IF STATE CHANGE OR TIMEOUT
	 PUSHJ P,UFLS
	SUB B,TIME	;HOW MUCH USED?
	HRRZ A,IMSOC4(I)	;RETURN STATE
	JRST POPJ1

ANETB2:	HLR A,T		;DESIRED STATE
	XOR A,IMSOC4(T)	;CURRENT STATE
	TRNE A,-1	;SKIP IF STILL MATCH
	 JRST POPJ1
	MOVE A,EPDL(U)	;SAVED TIME HERE
	CAMG A,TIME
	 AOS (P)	;TIME OUT!
	POPJ P,

ANETB3:	HRLOI B,377777	;NO TIME SUPPLIED, USE INFINITY
	JRST ANETB4

ANETB5: HRRZ B,C	;IMMEDIATE TIME SUPPLIED
	ADD B,TIME	;(TIMEOUT WILL RESTART ON EACH PCLSR, TOO BAD)
	JRST ANETB4

;NETHST (HOST INFO)
; ARG 1 - HOST => VAL 1 - STATUS, VAL 2 - HOST NUMBER
; ARG 1 - -1 => VAL 1 - (STATUS), VAL 2 - OUR HOST NUMBER
;NOT CURRENTLY IMPLEMENTED- ARG 1 - -1, ARG 2 - OUR GOING-DOWN REASON

ANETHST:HRRE T,A		;LET IMMEDIATE -1 WIN (777777 NOT A VALID HOST)
	AOJE T,ANETH2		;JUMP IF WANT LOCAL STATUS AND HOST NUMBER
	MOVE T,A
	JSP J,STDHST		;STANDARDIZE AND ERROR-CHECK HOST NUMBER
	MOVE B,T		;RETURN NEW FORMAT *******
	MOVEI H,LIMPHT-1
	CONO PI,NETOFF		;DO WE HAVE STATUS?
	CAME A,IMPHTN(H)
	 SOJGE H,.-1
	JUMPGE H,ANETH1		;YES, RETURN IT
	CONO PI,NETON		;NO, HAVE TO GO GET IT
	MOVEM T,SRN3(U)
	PUSHJ P,NETO00		;GET IMSOC, RETURN WITH NETLST, IMSOC LOCKED
	 POPJ P,		;DEVICE FULL OR SOMETHING
	PUSHJ P,NETOR		;OPEN COMMUNICATIONS WITH HOST
	 JFCL			;IT'S DOWN, THAT'S OK
ANETH1:	MOVE A,IMPHTB(H)	;GET STATUS
	CONO PI,NETON
	JRST LSWCJ1		;RETURN IMSOC, NETLST IF NOT DONE ALREADY

ANETH2:	;CAIL W,2		;(THIS IS A CROCK)
	 ;MOVEM B,NTHDSW	;IF 2 ARGS, SET OUR REASON FOR GOING DOWN.
	SKIPE IMPUP		;FAKE UP OUR STATUS
	 TDZA A,A		;WE'RE DOWN
	  MOVSI A,2000		;WE ARE UP
	MOVEI B,IMPUS		;AND OUR HOST #.
	JRST POPJ1


;NETIMP (REASON,TIMEDOWN,TIMEUP)  READ/SET

ANETIMP:JUMPLE W,ANETM1	;NO ARGS, RETURN
	CAIGE W,3	;MUST HAVE 3 ARGS IF ANY
	 JRST OPNL30
	MOVEM A,IMPDWN
	MOVEM B,IMPDWN+1
	MOVEM C,IMPDWN+2
	JRST POPJ1

ANETM1:	MOVE A,IMPDWN
	MOVE B,IMPDWN+1
	MOVE C,IMPDWN+2
	SKIPE IMPUP
	 TLO A,400000
	JRST POPJ1

;.CALL STYNET
;ARG 1 - STY CHANNEL
;ARG 2 - NET INPUT CHANNEL TO CONNECT STY OUTPUT TO, OR -1 TO DISCONNECT
;ARG 3 - NET OUTPUT CHANNEL TO CONNECT STY INPUT TO
;ARG 4 - CHARS TO SEND WHEN OUTPUT .RESET HAPPENS ON STY'S TTY
;	   UP TO 3 8-BIT CHARACTERS, LEFT JUSTIFIED.

NSTYNT:	TLNN R,%CLSST
	 JRST OPNL34		;1ST ARG NOT A STY CHANNEL.
	HLRZ I,(R)		;GET TTY # OF STY
	HRRES B			;ALLOW IMMEDIATE -1
	JUMPGE B,NSTYN2		;JUMP IF CONNECTING.
	PUSHJ P,NSTYN0		;DISCONNECT
	 JRST OPNL41		;WASN'T CONNECTED
	JRST POPJ1

;VARIOUS ROUTINES CALL HERE WITH THE TTY# OF A STY IN I, TO DISCONNECT THE
; STY FROM THE NETWORK.  NOTE THIS ROUTINE MUST NOT CHANGE U AND MUST NOT
; LSWCLR, SINCE IT COULD BE CALLED FROM IODCL VIA STYCLS OR NETCLS.

NSTYN0:	MOVSI B,%SSNET		;DISCONNECTING BOTH SIDES.
	CONO PI,NETOFF
	TDNN B,STYSTS-NFSTTY(I)
	 POPJ P,			;THIS STY NOT CONNECTED?
	ANDCAB B,STYSTS-NFSTTY(I)	;MARK AS NO LONGER CONNECTED
	MOVE C,STYNTL-NFSTTY(I)		;REMOVE THIS STY FROM ACTIVATION LIST
	MOVEI D,STYNTA-STYNTL+NFSTTY
NSTYN1:	CAMN I,STYNTL-NFSTTY(D)		;FIND THE STY THAT POINTS TO THIS ONE,
	 MOVEM C,STYNTL-NFSTTY(D)	;AND PATCH US OUT OF THE LIST.
	SKIPE D,STYNTL-NFSTTY(D) 	;SEARCH WHOLE LIST TILL FIND WHO POINTS TO US.
	 JRST NSTYN1
	SETOB C,STYNTL-NFSTTY(I)
	EXCH C,STYNTI-NFSTTY(I)	;MARK THIS STY AS HAVING NO CONNECTION, GET SOCKET INDICES
IFN CHAOSP,[
	TLNE B,%SSCHA
	 JRST [	MOVSI B,%SSCHA	;DISCONNECT FROM CHAOS NET
		ANDCAM B,STYSTS-NFSTTY(I)
		MOVSI B,%CFSTY
		TDNN B,CHSSTA(C)
		 JRST 4,.	;CHAOS DOESN'T THINK IT WAS CONNECTED?
		ANDCAM B,CHSSTA(C)
		JRST NETOJ1 ]
];CHAOSP
	MOVE B,[40000,,777]
	TDNN B,IMSOC5(C)
	 JRST 4,.		;SOCKET DOESN'T THINK IT WAS CONNECTED?
	ANDCAM B,IMSOC5(C)	;AND MARK SOCKETS WE WERE CONNECTED TO AS DISCONNECTED
	MOVSS C
	TDNN B,IMSOC5(C)
	 JRST 4,.		;SOCKET DOESN'T THINK IT WAS CONNECTED?
	ANDCAM B,IMSOC5(C)
	JRST NETOJ1

NSTYN2:	MOVE Q,I		;SAVE TTY # OF STY
	MOVEI E,1
	MOVE A,B		;DECODE THE NETWORK INPUT CHANNEL
	JSP T,CHNDCD
IFN CHAOSP,[
	HRRZ A,(R)
	CAIE A,CHAIDN
	 CAIN A,CHAODN
	  JRST [ HLRZ I,(R)	;CONNECT TO CHAOS NET
		 CONO PI,NETOFF
		 MOVSI B,%CFSTY
		 TDNE B,CHSSTA(I)
		  JRST OPNL23	;ALREADY CONNECTED, FILE LOCKED
		 MOVSI C,%SSNET+%SSCHA
		 TDNE C,STYSTS-NFSTTY(Q)
		  JRST OPNL23	;ALREADY CONNECTED, FILE LOCKED
		 IORM B,CHSSTA(I)	;OK, HOOK UP
		 DPB Q,[$CFTTN,,CHSSTA(I)]
		 JRST NSTYN3 ]
];CHAOSP
	JSP T,NETCHK	;TEST LEGALITY;  OPNL IF LOSES
	TDNE E,IMSOC2(I)
	 JRST OPNL2		;WRONG DIRECTION IF IT'S AN OUTPUT CHANNEL
	MOVE B,I		;SAVE INPUT IMSOC INDEX
	MOVE A,C		;DECODE OUTPUT CHANNEL
	JSP T,CHNDCD
	JSP T,NETCHK
	TDNN E,IMSOC2(I)
	 JRST OPNL2		;WRONG DIRECTION IF INPUT SOCKET
	CONO PI,NETOFF
	MOVE E,[40000,,777]
	TDNN E,IMSOC5(B)	;ERROR IF EITHER CHANNEL ALREADY CONNECTED
	 TDNE E,IMSOC5(I)
	  JRST OPNL23		;"FILE LOCKED"
	MOVSI C,%SSNET
	TDNE C,STYSTS-NFSTTY(Q)
	 JRST OPNL23		;SIMILAR ERROR IF STY ALREADY CONNECTED
	HRR E,Q			;GET 40000,,TTY #
	IORM E,IMSOC5(I)
	IORM E,IMSOC5(B)	;MARK SOCKETS AS CONNECTED
NSTYN3:	SKIPGE STYNTL-NFSTTY(Q)	;HALT IF STY'S VARS ARE NOT CORRECT FOR A 
	 SKIPL STYNTI-NFSTTY(Q)	;NON-CONNECTED STY.
	  JRST 4,.
	IORM C,STYSTS-NFSTTY(Q)	;ALL ERROR CAUGHT, SO MARK STY CONNECTED.
	HRL B,I			;PUT INPUT IMSOC IDX,, OUTPUT IMSOC IDX
	MOVSM B,STYNTI-NFSTTY(Q) ;INTO THE STY
	TRZ D,7777		;STORE THE OUTPUT RESET CHARACTERS - AT MOST 3
	MOVEM D,STYORC-NFSTTY(Q)
IFN CHAOSP,[			;ACTIVATE IN CASE HAS UNREAD INPUT
	TLNN C,%SSCHA
	 PUSHJ P,IMPUIN
	TLNE C,%SSCHA
	 PUSHJ P,CHINTI
];CHAOSP
.ELSE	PUSHJ P,IMPUIN
	JRST NETOJ1

SUBTTL	ARPANET MP I/O ROUTINES

;CALL STYNTC AT CLOCK LEVEL TO PROCESS ALL NECESSARY TRANSFERS OF DATA
;BETWEEN CONNECTED STYS AND NET SOCKETS

STYNTC:	CONO PI,NETOFF
	SKIPN I,STYNTA		;GET HEAD OF ACTIVATE LIST
	 JRST NETONJ		;EMPTY
	SETZM STYNTA		;COPY LIST IN CASE A STY IS PUT BACK ON
	CONO PI,NETON
STYNT7:	MOVE A,STYNTL-NFSTTY(I)	;GET NEXT ON LIST
	MOVEM A,STYNTB		;SAVE FOR NEXT TIME AROUND LOOP
	SETOM STYNTL-NFSTTY(I)	;THIS ONE IS NO LONGER ON ACTIVATE LIST
	MOVE A,STYSTS-NFSTTY(I)
	TLNN A,%SSNET
	 JRST 4,.		;STY CLAIMS NOT TO BE CONNECTED??
	MOVE R,I		;SAVE TTY #
IFN CHAOSP,[
	TLNE A,%SSCHA
	 JRST STYCHA		;CONNECTED TO CHAOS NET
];CHAOSP
	SKIPGE TTYOAC(I)
	 JRST STYNT1		;NO OUTPUT, CHECK FOR INPUT
;HANDLE OUTPUT TO NET
	HRRZ I,STYNTI-NFSTTY(I)	;GET IMSOC IDX OF OUTPUT CHANNEL
	MOVSI A,40000
	TDNN A,IMSOC5(I)
	 JRST 4,.		;SOCKET CLAIMS NOT TO BE CONNECTED??
STYNT5:	CONO PI,NETOFF		;INCLUDES TTYOFF
	PUSHJ P,NSOSE0		;CAN WE OUTPUT TO NET NOW?
	 JRST STYNT6		;NO, WAIT TILL LATER, PI LVL WILL REACTIVATE WHEN STATE CHANGES
	LDB T,IMSCBS		;SINCE THIS IS PI LEVEL,
	MOVE Q,IMSOC7(I)	;NO POINT IN SENDING MORE OUTPUT THAN ALLOCATED
	SUB Q,IMSC7I(I)
	IDIVM Q,T		;T GETS NUMBER OF BYTES ALLOCATED AND NOT BUFFERED
	CAMLE E,T
	 MOVE E,T
	JUMPLE E,STYNT6		;NO ALLOC, SEND NOTHING
	EXCH R,I		;BEFORE EXCH, R HAS TTY #, I HAS NET IMSOC IDX
	MOVEM D,DBBBP		;SET UP BUFFER-POINTING VARS FOR TTY OUTPUT INTERRUPT LEVEL
	MOVEM E,DBBCC
	MOVEM E,DBBCC1
	PUSH P,R
	SETOM TYPNTF
	PUSHJ P,TYP		;OUTPUT THROUGH THOSE POINTERS, INTO THE NET CHNL BUFFER
	SETZM TYPNTF
	POP P,R
	EXCH I,R
	MOVE D,DBBBP
	MOVE E,DBBCC
	MOVE Q,DBBCC1
	PUSHJ P,NSOFIN		;FIGURE OUT HOW MANY CHARS WERE TYPED, AND UPDATE SOCKET.
	 JRST STYNT4		;MORE ROOM IN BUFFER => MAYBE TYPE SOME MORE.
	JRST STYNT6		;ELSE TRY INPUT FROM NET, BUT SEND WHATEVER WE GOT

STYNT4:	SKIPL TTYOAC(R)		;MORE OUTPUT IN TTY BUFFER?
	 JRST STYNT5		;YES, PROCESS IT
STYNT6:	PUSHJ P,NSOFN1		;NO, BE SURE NET BUFFER GETS SENT SOON

;HERE TO TRY TO HANDLE INPUT FROM NET
STYNT1:	HLRZ I,STYNTI-NFSTTY(R)	;INPUT IMSOC INDEX
	MOVSI A,40000
	TDNN A,IMSOC5(I)
	 JRST 4,.		;SOCKET CLAIMS NOT TO BE CONNECTED?
STYNT2:	PUSHJ P,NETIDC		;GET CHAR FROM NET SOCKET
	 JRST STYNT3		 ;GOT CHAR IN W
	 JRST STYNT8		 ;NO CHAR AVAIL, HANDLE OTHER STYS
				 ;2 SKIPS => GIVE UP, SPECIAL CHARACTER SEEN, OR BAD STATE
	PUSHJ P,IMPUIP		;WAKE UP THE TELNET SERVER
	MOVE I,R		;DISCONNECT THE STY AND SOCKETS
	PUSHJ P,NSTYN0
	 JRST 4,.
STYNT8:	SKIPE I,STYNTB		;GET NEXT STY FROM COPIED ACTIVATION LIST
	 JRST STYNT7
	POPJ P,

STYNT3:	EXCH I,R		;HERE IF GET CHAR FROM NET IN W.  I GETS TTY #.
	PUSH P,R
	PUSH P,I
	MOVE A,W
	CONO PI,TTYOFF
	PUSHJ P,NTYI5		;GIVE CHARACTER TO TTY INPUT INTERRUPT LEVEL.
	CONO PI,TTYON
	POP P,R			;TTY #;  POP IN REVERSE ORDER TO UNDO THE EXCH
	POP P,I			;IMSOC IDX
	JRST STYNT2		;TRY TO GET ANOTHER INPUT CHARACTER.

;STYNTC'S INTERFACE TO NET INPUT IOT.
;I HAS IMSOC IDX OF INPUT SOCKET.
;1 SKIP => NO DATA AVAILABLE.
;2 SKIPS => TELNET CONTROL CHARACTER FOUND, SO DISCONNECT STY AND
;INTERRUPT THE USER PROGRAM.
NETIDC:	MOVNI U,1		;U=-1 TELLS NETI IT CAME FROM HERE
	HRRZ H,IMSOC4(I)	;CHECK SOCKET STATE
	CAIN H,%NSOPN
	 JRST POPJ1		;NO DATA
	CAIGE H,%NSCLI		;SKIP IF IN ONE OF THE TWO INPUT AVAILABLE STATES
	 JRST POPJ2		;STATE IS ABNORMAL, SO DISCONNECT FROM STY.
	JRST NETID		;ELSE TRY AN IOT.

;NETWORK UNIT INPUT.
NETI:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,IOCER1
NETIB:	MOVE A,IMSOC5(I) ;ENTER HERE FROM BLOCK-MODE INPUT
	TLNE A,40000
	 JRST IOCR10	;CAN'T IOT AT M.P. LEVEL WHILE SOCKET CONNECTED TO A STY.
NETID:	MOVE A,IMSC8I(I)
	LDB B,IMSCBS
	IMUL B,IMSMPC(I)
	ADD B,IMSOC7(I)	;TOTAL NUMBER OF BITS YET TO BE READ
	CAIGE A,8.	;IF MESS REALL OF 8 OR MORE
	 CAMG B,IMSC7I(I) ;OR BIT REALL SATISFIES "DOUBLE BUFFERING" CRITERION
	  PUSHJ P,NETI6	;THEN SEND ALLOCATE
	JUMPL U,NETI4	;JUMP IF READING INPUT TO GIVE DIRECTLY TO A STY
NETI0:	CONO PI,NETOFF	;DON'T ALLOW INTO IMPUIN WHILE CHECKING STATE, #BITS
	HRRZ A,IMSOC4(I)
	JUMPE A,NETIB1	;CONNECTION CLOSED
	CAIE A,%NSINP
	 CAIN A,%NSCLI
	  JRST .+3
	   CAIE A,%NSOPN
	    JRST IOCR10		;SOCKET IN BAD STATE
	PCLT
	SKIPG IMSMPC(I) 	;WAIT FOR BITS TO ARRIVE
	 PUSHJ P,UFLS
	CONO PI,NETON	  	;NETON IN CASE DIDN'T UFLS
	SKIPG IMSMPC(I) 	;DID THEY?
	 JRST NETI0		;NO, STATE MUST HAVE CHANGED, CHECK IT AGAIN

NETI4:	SOSL IMSOCT(I)		;TAKE BYTE
	 JRST NETI4A
	MOVE A,IMSMPP(I)	;END OF MESSAGE, FIND ADDRESS OF NEXT HEADER WORD
	MOVEI A,1(A)		;WHICH IS IN NEXT WORD AFTER LAST BYTE LOADED
	CAILE A,@IMSBFE(I)
	 HRRZ A,IMSOC6(I)	;WRAP AROUND
	SOSGE B,(A)		;GET HEADER WORD, COUNT DOWN FOR BYTE ABOUT TO TAKE
	 JRST 4,.		;NO MESSAGE, ALTHOUGH IMSMPC > 0
	MOVEM B,IMSOCT(I)	;SAVE # BYTES LEFT IN THIS MESSAGE
	HLL A,IMSBFE(I)		;SET UP BYTE POINTER LH TO LAST BYTE IN WORD
	MOVEM A,IMSMPP(I)	; SO ILDB WILL GET FIRST DATA BYTE OF THIS MSG
	AOS IMSC8I(I)		;INCREASE MESSAGE ALLOCATION
NETI4A:	MOVE TT,IMSMPP(I)	;CHECK FOR WRAP-AROUND
	MOVE H,IMSOC5(I)
	TLNE H,2000
	 JRST NETI2		;JUMP IF ONE BIT BYTES
	CAMN TT,IMSBFE(I)
	 JRST [	HRRZ TT,IMSOC6(I)
		HLL TT,IMSPIP(I)	;B.P. TO FIRST BYTE IN BUFFER
		JRST .+1 ]
	ILDB W,TT
	JRST NETI3

NETI2:	LDB E,IMSCBS		;BITS PER BYTE
	MOVEI W,0
NETI1:	CAME TT,IMSBFE(I)
	 JRST NETI1A
	HRRZ TT,IMSOC6(I)	;WRAP AROUND
	HLL TT,IMSPIP(I)
NETI1A:	ILDB A,TT
	LSH W,1
	IORI W,(A)
	SOJG E,NETI1
;DROPS THROUGH
;DROPS IN

NETI3:	TRNN W,200		;IS THIS A TELNET CONTROL CHAR (>= 200)?
	 JRST NETI3A
	JUMPL U,[AOS IMSOCT(I)	;YES;  IF DIRECT-CONNECTED TO A STY, BREAK CONNECTION.
		 JRST POPJ2]	; WITHOUT GOBBLING THAT CHARACTER
	TLNE H,400		;IF 7-BIT ASCII MODE, REPLACE CHARACTER BY ^@.
	 SETZ W,
NETI3A:	MOVEM TT,IMSMPP(I)
	LDB TT,IMSCBS
	ADDM TT,IMSC7I(I)	;INCREASE BIT ALLOCATION
	CONO PI,NETOFF		;WHILE CHANGING STATE
	SOSLE IMSMPC(I)		;ONE LESS BYTE IN BUFFER
	 JRST NETONJ		;OK, THERE IS MORE IN BUFFER
	MOVNI E,1		;YES, STATE IS CHANGING.
	HRRZ A,IMSOC4(I)
	CAIN A,%NSCLI
	 MOVEI E,%NSCLS
	CAIN A,%NSINP
	 MOVEI E,%NSOPN		;NO INPUT AVAILABLE
	JUMPL E,[JRST 4,.]	;WAS IN SOME RANDOM STATE
	CAIN E,%NSCLS
	 PUSHJ P,IMPUIP		;IF STATE CHANGING TO "CLOSED", GIVE USER AN INTERRUPT.
	HRRM E,IMSOC4(I)
	JRST NETONJ

;COME HERE WHEN INPUT IOT FINDS THAT CONNECTION IS CLOSED
NETIB1:	CONO PI,NETON
	LDB D,IMSCLS
	CAIE D,%NCFRN
	 JRST IOCR10	;ABNORMAL CLOSURE, GIVE IOCER INSTEAD OF EOF
	MOVE TT,IMSOC5(I)
	POP P,D		;GET OUR RETURN ADDRESS.
	ANDI D,-1
	CAIE D,AIOT3	;IF WE ARE NOT DOING A UNIT MODE IOT,
	 JRST 1(D)	;JUST RETURN WITH 1 SKIP.
	TLNN TT,1400	;SKIP IF ASCII MODE
	 JRST IOCER2	;EOF IN IMAGE MODE IS IOCERROR.
	HRROI W,EOFCH	;EOF IN ASCII MODE RETURNS ^C.
	JRST 1(D)

NETI6:	HRRZ H,IMSOC4(I)	;SEND ALL MSG
	CAIE H,%NSINP
	 CAIN H,%NSOPN
	  CAIA
	   POPJ P,	;CLOSED, DON'T SEND ALLOCATE
	LDB H,IMSCFH	;HOST INDEX FOR NETOW
	PUSHJ P,NETOW	;GOBBLE MAIN PROG CONTROL LINK BLOCK
	MOVEI J,2(I)	;LINK #
	IORI J,<4_8>	;SEND ALLOC
	LSH J,16.
	ADD J,IMSC8I(I)
	LSH J,4
	MOVEM J,IMPMPC+7
	MOVE J,IMSC7I(I)
	LSH J,4
	MOVEM J,IMPMPC+10
	PUSHJ P,STHSTM		;STORE HOST ADDRESS, MESSAGE TYPE
	MOVE J,[8_24.+8_8]
	MOVEM J,IMPMPC+6
	MOVEI J,2
	HRRM J,IMPMPC	;TEXT LENGTH
	SETZB A,TT
	EXCH A,IMSC8I(I)
	EXCH TT,IMSC7I(I)
	ADDM A,IMSOC8(I)
	ADDM TT,IMSOC7(I)
	JRST IMPMPQ

;UNIT MODE NETWORK OUTPUT (DOESN'T CLOBBER C)
	JRST NETSIO	;SIOT VECTOR
NETW:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,IOCER1
	SKIPGE C
	 SKIPA A,(C)
	  XCTR XR,[MOVE A,(C)]
NETWB:	CONO PI,NETOFF		;BYTE TO OUTPUT IN A. HERE FROM BLOCK MODE.
	HRRZ B,IMSOC4(I)
	CAIE B,%NSOPN
	CAIN B,%NSRFN
	 JRST .+2
	  JRST IOCR10
	SKIPG IMSMPC(I)		;SKIP IF ROOM TO PUT BYTE IN BUF
	 JRST [	MOVSI B,400000
		IORM B,IMSOC4(I) ;SET TO SEND IT NOW
	IFN DMI,CONSZ FI,70
		 PUSHJ P,IMPIOS
		SKIPG IMSMPC(I)  ;WAIT FOR AT LEAST ONE BYTE OF ROOM
		 PUSHJ P,UFLS
		CONO PI,NETON
		SKIPG IMSMPC(I)
		 JRST NETWB	;NO ROOM, STATE MUST HAVE CHANGED
		JRST .+1]
	MOVE E,IMSOC5(I)
	MOVE T,IMSOC7(I)
	TLNE E,100000
	 CAML T,IMSC7I(I)
	  JRST NETW4
	MOVSI B,400000		;ALLOCATION USED UP (AND FEATURE ENABLED)
	IORM B,IMSOC4(I)	;SEND BUFFER NOW
	PUSHJ P,IMPOST
	CAMN T,IMSOC7(I)	;WAIT FOR DATA TO GO OUT OR ALLOC TO COME IN
	 PUSHJ P,UFLS
	JRST NETWB		;TRY AGAIN

NETW4:	MOVE T,IMSMPP(I)	;GET POINTER
	MOVE E,TIME
	CAMN T,IMSPIP(I)	;SKIP UNLESS BUFFER EMPTY
	 MOVEM E,IMSOCT(I)	;SET TIME FOR FIRST BITS INTO BUF
	LDB B,IMSCBS		;BYTE SIZE
	MOVE E,IMSOC5(I)	;FLAGS
	CONO PI,NETOFF		;WANT TO MUNG POINTERS WITHOUT PI INTERFERENCE
	TLNE E,2000		;SKIP IF BYTES FIT EXACTLY IN WORD
	 TLNN T,770000		;SKIP IF NOT AT RIGHT END OF WORD
	  JRST NETW2		;IDPB, CHECK FOR POINTER WRAP
	LDB TT,[360600,,T]	;GET BYTE POS
	CAML TT,B		;SKIP IF BYTE SPLITS ACROSS WORDS
	 JRST NETW1		;JUST DO IDPB
	DPB TT,[301400,,T]	;SET BYTE TO STORE IN RIGHT OF THIS WORD
	SUB TT,B		;=> -(# OVERFLOW BITS)
	ROT A,(TT)		;HIGH PART OF BYTE IN RIGHT END OF A
	DPB A,T			;STORE PART BYTE
	AOS T,IMSMPP(I)		;INCR TO NEXT WORD
	MOVEI E,(T)
	CAILE E,@IMSBFE(I)
	 HRR T,IMSOC6(I)	;WRAP
	MOVEM A,@T		;STASH REST OF BYTE IN LEFT PART OF NEXT WORD
	ADDI TT,36.		;SET TO NEW POSITION
	DPB TT,[360600,,T]	;NEW BYT POS
	MOVEM T,IMSMPP(I)	;STORE UPDATED PTR
	JRST NETW3		;WRAP UP

;DEPOSIT A BYTE WHICH MAY WRAP AROUND

NETW2:	CAME T,IMSBFE(I)
	 JRST NETW1		;NO WRAP
	HRR T,IMSOC6(I)
	TLO T,440000
	MOVEM T,IMSMPP(I)

;DEPOSIT BYTE KNOWN TO FIT IN WORD

NETW1:	IDPB A,IMSMPP(I)	;STORE IT

;COUNT THE BITS NOW

NETW3:	SOS IMSMPC(I)		;1 BYTE LESS FREE
	LDB T,IMSCBS
	ADDM T,IMSC7I(I)
	JRST NETONJ

;NETWORK OUTPUT SIOT
NETSIO:	CONO PI,NETOFF
	PUSHJ P,NSOSET		;SET UP FOR FAST SIOT
	 JRST NSIOT1		;CHANNEL ISN'T SET UP FOR IT => USE NORMAL SIOT LOOP.
	PUSH P,B
	PUSH P,C
NETSO0:	XCTR XRW,[MOVES B,@-1(P)]	;COPY ARGS
	XCTR XRW,[MOVES C,@(P)]
NETSO1:	IBP B		.SEE NSIOOL ;FOR WHY THIS HAIR IS NEEDED
	XCTRI XR,[MOVE TT,(B)]
	 SKIPA T,B
	  JRST NETSO3		;PAGE FAULT, CLEAN UP IMSMPP BEFORE TAKING IT
	HRRI T,TT
	LDB TT,T
	IDPB TT,D
	SOS E
	XCTR XW,[MOVEM B,@-1(P)]	;UPDATE USER'S ARGS
	XCTR XRW,[SOSLE C,@(P)]
	 JUMPG E,NETSO1		;LOOP IF BOTH USER AND SYSTEM WILLING
	SKIPL E
	 SKIPGE C
	  JRST 4,.		;WENT TOO FAR!!
	PUSHJ P,NSOFIN		;FINISH UP HACKING NET CHANNEL.
	 JRST NETSO2		;OUTPUT BUFFER HAS MORE ROOM
	JUMPLE C,PPBAJ1		;NO ROOM BUT DON'T WANT ANY MORE ANYWAY, SO RETURN
	SKIPG IMSMPC(I)		;NO ROOM, WAIT FOR SOME
	 PUSHJ P,UFLS		;NOTE ANY STATE CHANGE WILL UNHANG
	POP P,C			;NOW TRY TO SIOT SOME MORE
	POP P,B
	MOVE D,IOTTB(H)		;RESTORE D IN CASE GOES TO NSIOT1
	JRST NETSIO

NETSO3:	PUSHJ P,NSOFIN		;TOOK PAGE FAULT, CLEAN UP
	 JFCL
	PUSHJ P,TPFLT
NETSO2:	JUMPLE C,PPBAJ1		;BUFFER HAS ROOM BUT NO DESIRE TO SEND ANY MORE, RETURN
	CONO PI,NETOFF
	PUSHJ P,NSOSE0		;SET UP TO SEND MORE
	 JRST IOCR10		;STATE MUST HAVE GONE BAD
	JRST NETSO0		;OK, SEND MORE

;SET UP FOR NET OUTPUT SIOT, OR (NSOSE0) FOR DIRECT OUTPUT FROM STY.
;AT ENTRY, A HAS LH(IOCHNM).
;CALL WITH NETOFF, AND DON'T TURN IT BACK ON BEFORE CALLING NSOFIN,
;BECAUSE WE HAVE A COPY OF IMSMPP IN D, AND PI LEVEL MIGHT BE TRYING TO MUNG IT.
;SETS D TO POINTER, E TO COUNT OF CHARS OF SPACE, AND Q TO COPY OF COUNT.
;SETS I TO IMSOC IDX.  CLOBBERS T AND TT.
;NO SKIP => CAN'T USE FAST SIOT, OR CAN'T DO DIRECT OUTPUT AT THIS MOMENT.
;IN THAT CASE, D HASN'T BEEN CLOBBERED YET.
NSOSET:	HRRE I,A
	JUMPL I,IOCER1
NSOSE0:	MOVE E,IMSOC5(I)
	HRRZ T,IMSOC4(I)
	CAIE T,%NSOPN
	 CAIN T,%NSRFN		;STATE BAD, OR BYTES CROSS WORD BOUNDARIES,
	  TLNE E,2000
	   JRST NETONJ		;IMPLIES CAN'T WIN THIS WAY.
	SKIPG E,IMSMPC(I)
	 JRST NSOFN1		;JUMP IF BUFFER FULL, SET SEND BUFFER AND NETONJ
	MOVE D,IMSMPP(I)
	CAME D,IMSBFE(I)
	 JRST NSOSE2
	HRR D,IMSOC6(I)		;IF BUFFER STORING PTR POINTS AT END OF BUFFER,
	TLO D,440000		;WRAP AROUND.
NSOSE2:	LDB Q,IMSCBS
	MOVEI TT,36.
	SKIPGE IMSOC5(I)
	 MOVEI TT,32.
	IDIVM TT,Q		;GET # BYTES/WD OF CONNECTION.
	HRRZ TT,IMSBFE(I)
	SUBI TT,(D)
	IMUL TT,Q		;# BYTES BETWEEN POINTER AND END OF BUFFER.
	LDB T,[360600,,D]
	LDB Q,IMSCBS
	IDIVM T,Q		;# BYTES NOT STORED IN WORD POINTER POINTS AT
	ADD TT,Q		;THEY ARE AVAILABLE, TOO.
	CAML E,TT
	 MOVE E,TT		;GET MINIMUM OF FULL BYTES AND BYTES AFTER THE POINTER.
	MOVE T,TIME
	MOVE Q,IMSMPP(I)
	CAMN Q,IMSPIP(I)	;SKIP IF BUFFER NOT EMPTY
	 MOVEM T,IMSOCT(I)	;TIME FOR FIRST BITS INTO BUF.
	CAILE E,600		;DON'T LEAVE NETOFF FOR MORE THAN ONE CLOCK TICK OR SO
	 MOVEI E,600
	MOVE Q,E		;ORIGINAL E. (FOR NSOFIN)
	JRST POPJ1

;FINISH UP AFTER NET OUTPUT SIOT OR DIRECT OUTPUT FROM STY.
;SKIP IF BUFFER FULL
;ASSUME Q,I LEFT OVER FROM NSOSET, AND D,E ADVANCED BY STORING CHARS.
NSOFIN:	PI2SAF			;NETOFF SHOULD STILL BE IN EFFECT FROM NSOSET
	SUBM E,Q		;- <# BYTES XFERED>
	JUMPE Q,NETONJ		;IF OUTPUT NO BYTES, DON'T CHANGE IMSMPP (IMPORTANT!)
	MOVEM D,IMSMPP(I)	;UPDATE STORING POINTER OF SOCKET BUFFER
	LDB TT,IMSCBS
	IMUL TT,Q
	MOVNS TT
	ADDM TT,IMSC7I(I)	;INCREASE COUNT OF BITS IN BUFFER
	ADDB Q,IMSMPC(I)	;UPDATE COUNT OF FREE SPACE IN BUFFER.
	JUMPG Q,.+2		;ANY SPACE LEFT => NO SKIP.
	 AOS (P)		
	JUMPG E,NETONJ		;ONLY SEND BUFFER IF CALL OUTPUT ALL IT COULD
NSOFN1:	MOVSI TT,400000		;SEND BUFFER NOW.
	IORM TT,IMSOC4(I)
	JRST IMPOST		;TURNS NETON

NETBO:	HRRE I,A
	JUMPL I,IOCER1
	XCTR XRW,[MOVES D,(C)]	;TAKE TRAP GETTING POINTER IF SWAPPED OUT
	MOVE E,IMSOC5(I)
	TLNE E,1400	;SKIP IF IMAGE MODE
	 JRST NETBOA	;ASCII MODE
	JUMPGE D,CPOPJ		;TRANSFER NO WORDS
NETBO1:	XCTR XW,[MOVEM D,(C)]
	XCTR XR,[MOVE A,(D)]
	PUSHJ P,NETWB
	XCTR XR,[MOVE D,(C)]
	AOBJN D,NETBO1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETBOA:	TLNN E,400	;SKIP IF 7 BIT
	 JRST NETBA8
	MOVEI E,NETBOR
	JRST NBTOCH

NETBOR:	PUSH P,D
	PUSH P,TT
	PUSHJ P,NETWB
	POP P,TT
	POP P,D
	MOVEI E,NETBOR
	POPJ P,

NETBA8:	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]
	CAIGE TT,4	;ONLY 4 BYTES PER WORD (3 < CNT < 8)
	 POPJ P,
	SKIPA TT,NETCHT-4(TT)
NTBA8A:	 XCTR XW,[MOVEM D,(C)]
	XCTR XR,[MOVE W,(D)]
	ILDB A,TT
	PUSH P,TT
	PUSHJ P,NETWB
	POP P,TT
	XCTR XR,[MOVE D,(C)]
	ADD D,[700000,,]	;ADVANCE CHAR CNT
	JUMPL D,NTBA8A		;GO TO NEXT CHAR
	MOVE TT,NETCHT+3
	ADD D,[400001,,1]	;INCR TO NEXT WORD
	JUMPL D,NTBA8A
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETCHT:	REPEAT 4,<44-<3-.RPCNT>*10>_12.+1000,,W

NETBI:	HRRE I,A
	JUMPL I,IOCER1
	XCTR XRW,[MOVES D,(C)]	;ENSURE POINTER WILL BE WRITABLE
	MOVE E,IMSOC5(I)
	TLNE E,1400	;SKIP IF IMAGE MODE
	 JRST NETBIA	;ASCII MODE
NETBI1:	XCTR XW,[MOVEM D,(C)]	;STORE BACK POINTER
	XCTR XRW,[MOVES (D)]	;ENSURE BYTE WILL BE WRITABLE
	PUSH P,C
	PUSHJ P,NETIB	;GET NEXT BYTE
	 CAIA		;NORMAL RETURN.
	  JRST POP1J	;NO INPUT AVAIL.
	POP P,C
	XCTR XR,[MOVE D,(C)]
	XCTR XW,[MOVEM W,(D)]
	AOBJN D,NETBI1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETBIA:	TLNN E,400	;SKIP IF 7 BIT ASCII
	 JRST NTBIA8
	MOVEI E,NETBIR
	JRST INBTCH

NETBIR:	PUSHJ P,NETI
	 JRST [ MOVEI E,NETBIR	;INPUT IN W
		POPJ P, ]
	MOVE E,[600000,,NETBCC] ;NO INPUT AVAIL
	JRST POPJ1

NETBCC:	MOVEI H,EOFCH
	JRST POPJ2

NTBIA8:	HRRZS E			;8-BIT ASCII BLOCK MODE
	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]
	CAIGE TT,4
	 POPJ P,
	SKIPA TT,NETCHT-4(TT)
NTBI8A:	 XCTR XW,[MOVEM D,(C)]
	XCTR XRW,[MOVES (D)]
	JUMPL E,NTBI8B
	PUSH P,C
	PUSH P,TT
	PUSHJ P,NETIB
	 JRST [ MOVEI E,0
		JRST NETBI5 ]	;NORMAL RETURN - BYTE IN W.
	MOVSI E,600000		;NO BYTES AVAIL - SOCKET CLOSED.
NETBI5:	MOVE H,W
	POP P,TT
	POP P,C
	XCTR XR,[MOVE D,(C)]
	LDB W,[410300,,D]
	CAIN W,7
	 TLNN E,200000
	  JRST NTBI8C
	POPJ P,
NTBI8C:	XCTR XR,[MOVE W,(D)]
	IDPB H,TT
	XCTR XW,[MOVEM W,(D)]
	ADD D,[700000,,]
	JUMPL D,NTBI8A
	MOVE TT,NETCHT+3
	ADD D,[400001,,1]
	SKIPL E
	 JUMPL D,NTBI8A
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NTBI8B:	MOVEI H,EOFCH
	XCTR XR,[MOVE D,(C)]
	JRST NTBI8C

NETCLS:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,CPOPJ
	MOVE T,IMSOC2(I)
	TRNN T,1	;SKIP IF SEND SOCKET
	 JRST NETCL2
	MOVSI T,400000
	IORM T,IMSOC4(I)	;CAUSE BUFFER TO BE SENT
	PUSHJ P,IMPOST
NETCL2:	MOVSI B,600000
	CONO PI,CLKOFF
	IORM B,IMSOC1(I)	;MARK CHANNEL TO BE CLOSED
	AOS IMNCS
	HRRZ R,UUAC(U)
	MOVE A,CHNBIT(R)
	TDNE A,MSKST2(U)
	 ANDCAM A,IFPIR(U)
	MOVE I,IMSOC5(I)	;IF CHANNEL CONNECTED TO A STY,
	TLNN I,40000
	 JRST CLKONJ
	ANDI I,777		;DISCONNECT THEM.
	PUSHJ P,NSTYN0
	 JRST 4,.
	JRST CLKONJ

;SEARCH PENDING QUEUE FOR LOCAL SOCKET NUMBER IN A,
;T 4.9 = 1 => LISTENING, 4.9 => 0 => ALSO CHECK
;FOREIGN SOCKET NUMBER IN B AND FOREIGN HOST NUMBER (IMPHTB INDEX) IN H
;SKIPS IF ENTRY IS FOUND.  RETURNS ENTRY TO FREE LIST.
;Q GETS ADDRESS OF ENTRY BLOCK.  RETURN WITH NETOFF

IMPSPQ:	CONO PI,NETOFF
IMSPQP:	SKIPGE Q,IMPBPQ	;BEGINNING OF QUEUE
	 POPJ P,	;QUEUE EMPTY
	MOVNI J,1	;PREVIOUS ENTRY
IMSPQL:	CAME A,1(Q)	;SKIP IF SAME LOCAL SOCKET NUMBER
	 JRST IMSPQ1	;TRY NEXT
	JUMPL T,IMSPQW	;WIN IF LISTENING SOCKET
	LDB W,[101000,,3(Q)]	;FOREIGN HOST IMPHTB INDEX
	CAMN W,H	;SKIP IF WRONG FOREIGN HOST
	 CAME B,2(Q)	;SKIP IF FOREIGN SOCKET NUMBER AGREES
	  JRST IMSPQ1	;TRY NEXT
IMSPQW:	SKIPGE W,(Q)	;FOUND IT
	 MOVEM J,IMPEPQ	;PATCH OUT OF THE QUEUE
	SKIPGE J
	 MOVEI J,IMPBPQ
	MOVEM W,(J)
	MOVE W,IMFFPQ	;ADD TO FREE LIST
	MOVEM W,(Q)
	MOVEM Q,IMFFPQ
	JRST POPJ1

IMSPQ1:	MOVE J,Q	;PREVIOUS ENTRY
	SKIPL Q,(Q)	;NEXT ENTRY
	 JRST IMSPQL	;LOOP
	POPJ P,		;NOT FOUND

SUBTTL	ARPANET CLOCK LEVEL

OVHMTR IMP	;NETWORK INTERRUPT LEVEL (NOT STYNET STUFF)

IMRSTO:	SKIPN IMRFCT	;CALLED AT 15 SEC CLK LEVEL TO UNHANG RFNM WAITS
	 JRST IMFCT1
	MOVEI H,LIMPHT-1	;SOME CONTROL LINKS WAITING FOR RFNM, CHECK FOR TIME OUT
	MOVSI TT,401000	;4.9 AND 4.1 - RFNM AND RRP TIMEOUTS
	TDNN TT,IMPHTB(H)
IMRS4:	 SOJGE H,.-1
	JUMPL H,IMFCT1
	CONO PI,NETOFF
	SKIPE IMPHTN(H)		;MAKE SURE IT'S A REAL HOST, NOT A FREE ENTRY
	 TDNN TT,IMPHTB(H)	;AND THAT THE BITS DIDN'T TURN OFF DUE TO INTERRUPT
	  JRST IMRS1
	LDB E,[221100,,IMPHTB(H)]
	LDB D,[051100,,TIME]	;GET TIME IN SECONDS (APPROX)
	CAMLE E,D
	 ADDI D,1_9
	SUB D,E
	CAIGE D,IMRFTO_<-5>
	 JRST IMRS1	;HASN'T TIMED OUT YET.
	LDB D,IMHSBT	;TIMED OUT.  CHECK RST/RRP STATUS.
	SOJE D,IMRS2
	MOVSI D,400000
	ANDCAM D,IMPHTB(H)	;RFNM SENT, CLEAR IT
	AOS IMNRFN
	SOS IMRFCT
	BUG INFO,[NET: CTL LNK RFNM TIMEOUT HST],OCT,IMPHTN(H)
IMRS1:	CONO PI,NETON
	JRST IMRS4

IMRS2:	DPB D,IMHSBT	;RST SENT, SET STATE TO DOWN
	BUG INFO,[NET: RST TIMEOUT HST=],OCT,IMPHTN(H)
	SOS IMRFCT
	JRST IMRS1

;HERE TO TIME OUT THE RFC QUEUE
IMFCT1:	CONO PI,NETOFF
	SKIPGE Q,IMPBPQ
	 JRST NETONJ	;... IF QUEUE IS EMPTY
	MOVNI J,1	;J HAS PTR TO PREV ELT OF LIST, FOR IMSPQW TO PATCH (DELQ).
IMFCT2:	LDB E,[221100,,3(Q)]	;TIME IN 16/15'THS, MOD 512., THAT RFC WAS RECEIVED
	LDB TT,[051100,,TIME]	;TIME, IN SAME UNITS, NOW.
	CAMLE E,TT		;MAKE SURE THE SUB TT,E GIVES A POSITIVE ANSWER.
	 ADDI TT,1_9		;WE ASSUME THAT TIME >= TIME OF RECEIPT.
	SUB TT,E
	CAIGE TT,IMFCTO_<-5>
	 JRST IMFCT3		;THIS RFC HASN'T TIMED OUT - LOOK AT NEXT
	PUSHJ P,IMSPQW		;IT HAS - FLUSH IT
	 JFCL
	JRST IMFCT1		;AND START AGAIN LOOKING FOR RFC'S TO FLUSH

IMFCT3:	MOVE J,Q
	SKIPL Q,(Q)
	 JRST IMFCT2
	JRST NETONJ	;END OF QUEUE

;FLUSH CLOSED NETWORK CHANNELS (CALLED AT HALF SEC CLOCK)
IMPCCL:	MOVSI I,-IMPSTL
IMPCCR:	CONO PI,NETON
	MOVSI T,200000
IMPCCZ:	TDNN T,IMSOC1(I)	;LOOK FOR CHANNELS NO LONGER OPEN.
	 AOBJN I,IMPCCZ
	JUMPL I,IMPCCA
	POPJ P,

IMPCCA:	CONO PI,NETOFF
	MOVE B,IMSOC6(I)
	TLNE B,600000	;ACTIVE AT PI LEVEL OR LOCKED BY CORE JOB
	 JRST IMPCCS
	HRRZ B,IMSOC4(I) ;DISPATCH ON SOCKET STATE.
	JRST @IMPCCT(B)

IMPCCT:	OFFSET -.
%NSCLS::IMPCC1
%NSLSN::IMPCC1
%NSRFC::IMPCC2
%NSRCL::IMPCC1
%NSRFS::IMPCC2
%NSOPN::IMPCC5
%NSRFN::IMPCC6
%NSCLW::IMPCC7
%NSCLI::IMPCC1
%NSINP::IMPCC2
	OFFSET 0

;IMP BUFFER RETURN
IMPBRT:	SKIPN IMSOC6(I)
	 POPJ P,	;NO BUF??
	LDB A,[221000,,IMSOC6(I)]
	CAIE A,377
	 JRST IMBRT1
	LDB A,[121000,,IMSOC6(I)]
	PUSHJ P,IMEMR
	CAIA
IMBRT1:	 PUSHJ P,IBRTN
	SETZM IMSOC6(I)
	POPJ P,

IMPCC1:	PUSHJ P,IMPBRT
	MOVSI A,20000
	TDNE A,IMSOC5(I)
	 JSP T,IMPC5D	;WAITING FOR FINAL RFNM
	SETZM IMSOC1(I)
	SOS IMNCS	;WE HAVE FINISHED CLOSING ONE SOCKET
IMPCCS:	AOBJN I,IMPCCR	;WE CLOSED ONE, OR GAVE UP ON ONE; LOOK AT NEXT
	JRST NETONJ	;OR WE'RE FINISHED LOOKING AT ALL.

IMPCC2:	PUSHJ P,IMPBRT
	SKIPLE T,IMFCQL
	 CAIG T,2	;SKIP IF MORE THAN 2 FREE
	  JRST IMPCCS	;NOT ENUF PI CONTROL QUEUE BLOCKS AVAIL
	LDB A,IMSCFH	;GET HOST#
	SKIPGE IMPHTB(A)	;SKIP IF NO RFNM WAIT ON LINK 0
	 JRST IMPCCS	;NOT NOW!
	PUSH P,IMPCSH
	MOVEM A,IMPCSH
	JSP T,IMSTCM
	    12.,,3	;12. BYTES, 3 WORDS
	 JRST 4,.	;NO SLOTS AVAIL.  CHECKED BEFORE
	MOVEI H,3_4	;3 NOPS + CLS
	MOVEM H,10(Q)
	MOVE H,IMSOC2(I)	;LOCAL SOCKET
	LSH H,4		;MOVE INTO 32 BIT FIELD
	MOVEM H,11(Q)
	MOVE H,IMSOC3(I)	;FOREIGN SOCKET
	LSH H,4
	MOVEM H,12(Q)
	PUSHJ P,IMWCQ	;SEND CLS
	POP P,IMPCSH
	MOVEI H,%NSCLW
	HRRM H,IMSOC4(I)
	MOVE H,TIME
	MOVEM H,IMSOCT(I)	;TIME CLS SENT
	JRST IMPCCS

IMPCC5:	MOVE H,IMSOC2(I)
	TRNN H,1	;SKIP IF SEND SOCKET
	 JRST IMPC5B	;RECEIVE SOCKET
	MOVE A,IMSPIP(I)
	CAMN A,IMSMPP(I) ;IS THERE STILL DATA TO SEND? AT MP LEVEL
	 CAMN I,IMPOPI	;OR PI LEVEL? OR RFNM WAIT?
IMPCC6:	  JSP T,IMPC5D	;YES, SEND IT AND GET RFNM BEFORE SENDING CLS
IMPC5B:	MOVEI H,%NSRFS	;NO, OK TO SEND A CLS NOW.
	HRRM H,IMSOC4(I);SET STATE SO WILL LOOP BACK TO IMPCC2
	JRST @IMPCCT(H)

IMPC5A:	IORM H,IMSOC5(I)
	MOVE H,TIME
	MOVEM H,IMSOCT(I)
	JRST IMPCCS

IMPC5D:	MOVSI H,10000
	TDNN H,IMSOC5(I)
	 JRST IMPC5A	;TIME-OUT NOT ALREADY STARTED - START IT.
IMPC7A:	MOVE H,TIME	;ALREADY STARTED, OVER YET?
	SUB H,IMSOCT(I)
	CAIG H,IMPCTO	;SKIP IF TIMED OUT
	 JRST IMPCCS	;NOT YET
	JRST (T)

IMPCC7:	JSP T,IMPC7A	;IF CLOSE TIME-OUT ISN'T UP, GIVE UP TO IMPCCS.
	JRST IMPCC1	;ELSE FLUSH.

;HERE FROM 1/2 SECOND CLOCK IF IMNAS IS NON-ZERO.
;WE WAKE UP ANY STYNET CHANNELS THAT NEED IT.
IMPAAA:	SOS IMNAS	;DECREASE NEED-THIS-ROUTINE COUNT
	MOVSI I,-IMPSTL
IMPAA1:	MOVSI T,200000
	TDNN T,IMSOC5(I)
	 AOBJN I,.-1
	JUMPGE I,CPOPJ
	CONO PI,NETOFF
	ANDCAM T,IMSOC5(I)
	PUSHJ P,IMPUIN
	CONO PI,NETON
	JRST IMPAA1

SUBTTL	ARPANET INPUT INTERRUPT LEVEL

;HERE AT PI LEVEL 2 (NETCHN) WHEN IMP INTERFACE IS INTERRUPTING
IMPINT:
IFE DMI,[
	AOSN IMPB
	 JRST IMPBKZ
	AOSN IMPI
	 JRST IMPIBZ
	AOSN IMPO
	 JRST IMPOBZ
	TRNE TT,IMPLW+IMPHER+IMPERR
	 JRST IMPBKZ
	TRNE TT,IMPID
	 JRST IMPIBZ
	TRNE TT,IMPOD
	 JRST IMPOBZ
]IFN DMI,[
	TRNE TT,FILW+FIWASD+FIDOWN
	 JRST IMPBKZ
	TRNE TT,FIID
	 JRST IMPIBZ
	TRNE TT,FIOD
	 JRST IMPOBZ
]
	JRST 4,.

IFE DMI,[

EBLK
IMPIBK:	0	;HERE IF INPUT INTERRUPT, PIA=IMPCHN BUT INPUT PIA WANTS TO BE NETCHN
BBLK
	SETOM IMPI		;RE-INTERRUPT AND HANDLE AT NETCHN
	CONO IMP,NETCHN
	JRST 12,@IMPIBK
]

IFE DMI,[

EBLK
IMPBRK:	0	;HERE IF CONTROL INTERRUPT, PIA=IMPCHN BECAUSE OF OUTPUT
BBLK		;THIS INTERRUPT IS TO 42, MAY NOT BE THE IMP
	CONSO IMP,IMPLW+IMPHER+IMPERR	;THIS REALLY FROM THE IMP?
IFE NEWDTP,JRST RC1INT
IFN NEWDTP,JRST IMPBR1
	SETOM IMPB		;YES, RE-INTERRUPT AND HANDLE AT NETCHN
	CONO IMP,NETCHN
	JRST 12,@IMPBRK

IFN NEWDTP,[
IMPBR1:	CONSZ DTC,70
	 JRST 12,@IMPBRK
]

RC1INT:	MOVEM 17,R1NTAC+17
	MOVEI 17,R1NTAC
	BLT 17,R1NTAC+16
	MOVEI J,1
	JSP E,SPUR
	MOVSI 17,R1NTAC
	BLT 17,17
	JRST 12,@IMPBRK
];DMI

EBLK
IMPRM4:	0
BBLK

;BLKI HAS RUN OUT BUT HAVE NOT YET GOTTEN
;LAST IMP WORD.  EITHER READ MORE OR IGNORE UNTIL LAST IMP WORD.
	MOVEM A,IMPA
	SKIPL A,IMNWSI	;SECOND BLKI POINTER
	 JRST IMPRM6	;NONE NOW
	MOVEM A,IMBLKI	;STORE
	SETZM IMNWSI	;CLEAR THIS FLAG
	MOVE A,IMPA	;RETURN
	JRST 12,@IMPRM4

IMPRM6:	MOVE A,[JSR IMPRM5]	;IGNORE ADDITIONAL INPUT
	MOVEM A,IMPILC
	MOVE A,IMPA
	JRST 12,@IMPRM4

EBLK
IMPRM5:	0	;HMM? FLUSH INPUT AT PI 1
BBLK
	DATAI IMP,IMPA
	JRST 12,@IMPRM5

;GET HERE PI IN PROG ON NETCHN, INPUT DONE, NOT LAST IMP WORD
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPIBZ:	AOS IMCT2
IFN DMI,[
	TRC TT,IMPCHN	;FIND IF INPUT PIA=IMPCHN
	TRNN TT,7
	 JRST IMPRET	;YES, ALREADY HANDLED BY IMPCHN
	TLNE TT,FII32
];DMI
IFE DMI,TRNE TT,IMPI32
	 JRST 4,.	;SHOULD HAVE BEEN READ IN 36-BIT MODE
	MOVE C,IMPHI
	SKIPN B,IMPIS
	 AOJE C,IMPBKW	;INPUT TO BE HELD UP (CAN ONLY DO AT START OR END OF MESSAGE)
	CAILE B,2
	 JRST 4,.
	JRST @.+2(B)	;DISPATCH, NOTE DATA NOT READ YET
	IMPIGN		;NETWORK DOWN (-1)
	IMSTR1		;START OF MESSAGE (0)
	IMPIGN		;IGNORE (1)
	IMPLD2		;LEADER (2)

IMPIGN:	DATAI IMP,A	;IGNORE
	;JRST IMPRET

IMPRET:
IFN DMI,CONI FI,A
	SKIPN IMPIS	;SKIP IF NOT IN NORMAL STATE
IFE DMI, CONSO IMP,IMPI32	;SKIP IF INPUT IN 32 BIT MODE
IFN DMI, TLNN A,FII32
	  JRST .+2
	   JRST 4,.	;SHOULDNT BE IN 32 BIT MODE IN NORMAL STATE
IFE DMI,CONO IMP,@IMPPIA
	JRST IMPEX

;GET HERE PI IN PROG ON NETCHN, CONTROL INTERRUPT
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPBKZ:	AOS IMCT1
IFE DMI,TRNE TT,IMPERR+IMPHER
IFN DMI,TRNE TT,FIWASD+FIDOWN
	 JRST IMPBER	;IMP ERROR OR HOST ERROR
	MOVE B,IMPHI
	AOJN B,IMPBKX	;JUMP IF INPUT NOT TO BE HELD UP
IMPBKW:
IFE DMI,CONO IMP,IMPIDC	;CLEAR INPUT DONE
IFN DMI,[
	CONO FI,FISUSP	;SUSPEND INPUT, NO BITS ACCEPTED AFTER DATAI
	DATAI FI,IMPSUS	;HAVE TO READ WORD NOW
	CONO FI,FIIDC+NETCHN_3	;HAVE TO DO THIS TO CLEAR IMP LAST WORD (ALSO CLR PIA)
]
	SOS IMPHI	;INDICATE SUCCESSFULLY HELD UP
	MOVEM TT,IMSTAS	;SAVE STATUS
	AOS IMPNIH
	JRST IMPRET

;GET HERE PI IN PROGRESS ON NETCHN
;HAVE GOT LAST IMP WORD 

IMPBKX:
IFE DMI,[
	MOVE A,[JSR IMPIBK]	;GET RID OF INPUT BLKI
	MOVEM A,IMPILC
	SETZM IMPIH
	MOVEI A,NETCHN
	SKIPL IMPOH
	 MOVEM A,IMPPIA
	CONO IMP,IMI32C		;PUT BACK IN 36 BIT MODE
	DATAI IMP,A		;GET INPUT WORD, WILL BE DISPOSED OF BELOW
]IFN DMI,[
	CONO FI,FII32C+FISUSP	;HOLD UP BITS FOR FOLLOWING CLEAR
	DATAI FI,A
	CONO FI,FIIDC+FIIBSY+NETCHN*11	;CLEAR IMP LAST BIT
]
IMPBKV:	SKIPGE B,IMPIS		;ENTER HERE IF INPUT WAS HELD UP, DATA IN A
	 JRST IMPRET
	JRST @IMSDT2(B)

IMSDT2:	IMPBKN	;NORMAL INPUT BUT LEADER ONLY 1 WORD LONG (0)
	IMPIRT	;IGNORE (1)
	IMPLD1	;END OF LEADER (2)
	IMPBK3	;END OF CONTROL MESSAGE (3)
	IMPRMB	;END OF DATA INPUT (4)

;HERE FOR OLD-TYPE LEADER
IMPBKN:	MOVEM A,IMPILB		;STORE FIRST (AND ONLY) WORD OF LEADER
IMPBN1:	LDB A,IMOTBP		;MESSAGE TYPE
	CAIE A,4		;OLD-TYPE NOP?
	 BUG INFO,[NET: OLD-TYPE-LEADER],OCT,IMPILB
	JRST IMPIRT		;IGNORE REST OF MESSAGE, IF ANY

IMSTR1:	DATAI IMP,A
;HERE WITH FIRST WORD OF LEADER IN A, NOT LAST WORD
;SET UP A BLKI TO GET THE REST OF THE LEADER
IMSTRT:	MOVEM A,IMPILB		;STORE FIRST WORD OF LEADER
	MOVEI C,2		;SET UP TO READ REST OF LEADER
	MOVE B,[-4,,IMPILB]	;GET REST OF IMP LEADER.  IF THERE IS A HOST
				;LEADER, WILL GET TO IMPLD2 BEFORE DATAI'ING IT
				;SO WE HAVE A CHANCE TO SWITCH TO 32-BIT MODE.
	JRST IMPRM9		;GO READ IT

;HERE FOR A LEADER NOT FOLLOWED BY A MESSAGE.  LAST WORD IN A, IMPLW IN TT.
IMPLD1:	AOS B,IMBLKI		;STORE LAST WORD
	MOVEM A,(B)
IMPLD2:	;COMES HERE IF WE HAVE THE HOST-LEADER WORD (6TH WORD)
	;IN THE INTERFACE, AND THERE IS MORE TO COME.  DON'T DATAI
	;IT YET, UNTIL WE KNOW WHAT MODE TO READ THE MESSAGE TEXT IN.
IFE DMI,TRNE TT,IMPI32
IFN DMI,TLNE TT,FII32
	 JRST 4,.		;INPUT WAS IN 32 BIT MODE
	LDB T,IMOTBP		;GET OLD MESSAGE TYPE
	CAIE T,17		;17 FOR NEW FORMAT
	 JRST IMPBN1		;SOMETHING ELSE, GO DISCARD
	HRRZ B,IMBLKI		;-> LAST WORD READ
	CAIGE B,IMPILB+2	;MUST BE AT LEAST 3 WORDS TO BE VALID
	 JRST IMPLD3
	LDB T,IMLNBP		;EXTRACT LINK NUMBER
	MOVEM T,IMPCLN
	LDB T,IMSHBP		;SOURCE HOST
	LDB A,IMSIBP		;SOURCE IMP
	DPB A,[112000,,T]	;FORM HOST ADDRESS
	PUSHJ P,FNDHST		;H GETS HOST TABLE INDEX
	 JRST IMPLD9		;HOST TABLE FULL
	MOVEM H,IMPCSH		;SAVE CURRENT HOST
	LDB A,IMTBP		;GET MESSAGE TYPE IN A
	CAILE A,9
	 JRST IMPUN		;UNKNOWN TYPE
	AOS IMPMSR(A)		;COUNT IMP MSGS RCD
	JRST @IMTDT(A)		;DISPATCH

IMTDT:	IMPRM	;REGULAR MESSAGE		 (0)
	IMPBE1	;ERROR W/O MESSAGE ID		 (1)
	IMPGD	;IMP GOING DOWN			 (2)
	IMPUN	;BLOCKED LINK			 (3)
	IMPIN	;NOP				 (4)
	IMPRFN	;RFNM				 (5)
	IMPHDS	;HOST DEAD STATUS		 (6)
	IMPDHD	;DESTINATION HOST DEAD		 (7)
	IMPBE1	;ERROR W/ MESSAGE ID		 (8)
	IMPINC	;INCOMPLETE TRANSMISSION	 (9)

IMPLD9:	BUG INFO,[NET: MESSAGE DISCARDED DUE TO HOST TABLE FULL],OCT,IMPILB,OCT,IMPILB+1,OCT,IMPILB+2
	JRST IMPIRT

;HERE IF LEADER IS TOO SHORT
IMPLD3:	SUBI B,IMPILB-1		;# WDS READ
	BUG INFO,[NET: SHORT LEADER, ],DEC,B,[WDS WD1=],OCT,IMPILB,[WD2=],OCT,IMPILB+1
	;JRST IMPIRT		;FLUSH REST OF MESSAGE
IMPIN:	JRST IMPIRT	;ONE MORE NOP FROM IMP

IMPUN:	BUG INFO,[NET: UNKNOWN IMP MSG],OCT,IMPILB,OCT,IMPILB+1,OCT,IMPILB+2
	;JRST IMPIRT

;HERE TO FLUSH REST OF THIS MESSAGE.  TT SAYS WHETHER THERE IS ANY MORE.
IMPIRT:	SETZM IMPIS	;END OF MESSAGE RESET TO NORMAL STATE
	TRNN TT,IMPLW
	 AOSA IMPIS	;BUT FIRST WAIT FOR IMP TO FINISH CRUFT AT END OF THIS MSG
;HERE TO RESET FOR NEXT MESSAGE, TT NOT VALID, THIS MSG KNOWN TO BE OVER
IMPIR1:	  SETZM IMPIS	;RESET TO NORMAL STATE
	SETOM IMPCSH	;NO CURRENT HOST
IFE DMI,CONO IMP,IMI32C	;PUT WORLD BACK IN 36 BIT INPUT MODE
IFN DMI,CONO FI,FII32C+NETCHN*11
	JRST IMPRET

;HAVE LEADER FOR REGULAR MESSAGE
;THE HOST-LEADER WORD (6TH WORD) HAS NOT BEEN READ YET (IF IMPLW ISN'T SET)
IMPRM:	TRNE TT,IMPLW
	 JRST IMPRM3	;FOO, MESSAGE SHOULDN'T END SO SOON
	CAIE B,IMPILB+4	;CHECK THAT HOST-HOST LEADER WORD IS NEXT IN
	 JRST IMPLD3	;BARF
	SKIPE IMPCLN	;SKIP IF LINK 0
	 JRST IMPRMD	;DATA MESSAGE, GO READ
IFE DMI,CONO IMP,IMI32S	;CONTROL MESSAGE, SET 32-BIT MODE
IFN DMI,CONO FI,FII32S+NETCHN*11
	DATAI IMP,IMPILB+5	;GET HOST-HOST LEADER WORD
	LDB A,IMCBBP
	MOVEM A,IMPCBS		;BYTE SIZE
	LDB B,IMBCBP
	MOVEM B,IMPCBC	;BYTE COUNT
	CAIN A,8	;BYTE SIZE SHOULD BE 8
	 CAILE B,120.	;BYTE COUNT SHOULDN'T BE > 120.
	  JRST IMPBCM
	ADDI B,3
	LSH B,-2	;NUMBER OF WORDS NECESSARY
	MOVEM B,IMPNIW	;NUMBER OF INPUT WORDS EXPECTED
	HRLOI B,-1(B)
	EQVI B,IMPINB-1	;BLKI POINTER
	MOVEI C,3
;SET UP BLKI.  POINTER IN B, STATE IN C.
IMPRM9:	MOVEM C,IMPIS
	MOVEM B,IMBLKI
	MOVE B,[BLKI IMP,IMBLKI]
	MOVEM B,IMPILC
	MOVE B,IMPBRO(C)	;GET BLKI RUNOUT INSTRUCTION
	MOVEM B,IMPILC+1
IFE DMI,[
	SETOM IMPIH
	MOVEI B,IMPCHN
	MOVEM B,IMPPIA
];DMI
IFN DMI,CONO FI,NETCHN_3+IMPCHN
	JRST IMPRET

IMPBRO:	JRST 4,.		;0 IDLE
	JRST 4,.		;1 IGNORE
	JSR IMPLD4		;2 END OF LEADER
	JSR IMPRM4		;3 END OF CONTROL MESSAGE
	JSR IMPRM4		;4 END OF DATA MESSAGE

IMPRM3:	LDB B,IMBCBP	;BYTE COUNT OF EMPTY CONTROL LINK MESSAGE
	JUMPE B,IMPIRT
	AOS IMPNPE	;NO TEXT BUT BYTE COUNT NOT ZERO
	BUG INFO,[NET: CTL MSG NO TXT, BC NOT 0. HST ],OCT,IMPHTN(H),[BC],DEC,B
	JRST IMPIRT

EBLK

IMPLD4:	0	;JSR HERE ON BLKI RUNOUT AFTER READING LEADER
		;THERE IS STILL ONE WORD TO GO, TO BE GOTTEN AT NETCHN LEVEL
BBLK
IFE DMI,[
	MOVEM A,IMPILC
	SETZM IMPIH
	MOVEI A,NETCHN
	SKIPL IMPOH
	 MOVEM A,IMPPIA
	CONO IMP,@IMPPIA
	MOVE A,[JSR IMPIBK]
	EXCH A,IMPILC
];DMI
IFN DMI, CONO FI,NETCHN*11
	JRST 12,@IMPLD4

IMPBCM: BUG INFO,[NET: CTL MSG BS NOT 8 OR CT>120. HST ],OCT,IMPHTN(H),[BS ],DEC,IMPCBS,[BC ],DEC,IMPCBC
	JRST IMPIRT

;HOST DOWN STATUS, HOST INDEX IN H
IMPHDS:	MOVE A,IMPILB+1		;1.8-1.1 AND 4.9-4.2 ARE THE INFO
	MOVE B,IMPILB+2
	LSHC A,8
	ANDI A,177777
	HRRM A,IMPHTB(H)	;STORE, HOPE USER READ RFC 611
	JRST IMPIRT

;ERROR MESSAGE FROM IMP
IMPBE1:	MOVE T,TIME
	SUB T,LNETIM
	CAIL T,60.	;IGNORE ERROR DURING INITIAL SYNCHRONIZATION
	 BUG INFO,[NET: ERR MSG FM IMP],OCT,IMPILB,OCT,IMPILB+1,OCT,IMPILB+2
	JRST IMPIRT

IMPBER:	SKIPGE IMPUP	;SKIP IF UP, OR THOUGHT TO BE BROKEN
	 JRST IMPBE2	;ALREADY DOWN, LET IT COME UP IN PEACE
	MOVSI J,SCLNET	;THINKS IT'S UP, RESET IT
	IORM J,SUPCOR
	CONI IMP,IMERCN	;RECORD IF IMP ERROR FLIP/FLOP SET
	SETOM IMPUP	;IMP IS DOWN
	SETZM IMPTCU	;AND NOT TRYING TO COME UP
	MOVSI T,200000	;CLEAR ALL BUFFERS ACTIVE AT PI LEVEL
	MOVSI I,-IMPSTL	;SINCE CORE JOB MAY BE WAITING ON THIS
	ANDCAM T,IMSOC6(I)
	AOBJN I,.-1
IMPBE2:
IFE DMI,[
	SETZM IMPPIA
	CONO IMP,0
]
IFN DMI,CONO FI,FIRSET
	JRST IMPEX

;IMP GOING DOWN MESSAGE RECEIVED
IMPGD:	LDB B,[060200,,IMPILB+1]	;WHY
	MOVEM B,IMPDWN
	LDB B,[020400,,IMPILB+1]	;HOW SOON GOING DOWN * 5 MINS
	MOVE H,B
	IMULI B,5*60.*30.	;TICKS IN 5 MINS
	ADD B,TIME
	MOVEM B,IMPDWN+1
	MOVE C,IMPILB+1		;HOW LONG TO BE DOWN, SPANS WORD BOUNDARY
	MOVE D,IMPILB+2
	LSHC C,8
	ANDI C,1777
	MOVE Q,C
	IMULI C,5*60.*30.
	ADD C,B			;ADD TO TIME DOWN
	MOVEM C,IMPDWN+2	;STORE TIME WHEN WILL BE UP
	IMULI H,5		;MINUTES
	IMULI Q,5
	BUG INFO,[NET: IMP GOING DOWN, RSN=],DEC,IMPDWN,[HOW SOON=],DEC,H,[HOW LONG=],DEC,Q
	JRST IMPIRT

;HERE WHEN RFNM ARRIVES
IMPRFN:	SKIPE IMPCLN	;LINK NUMBER
	 JRST IMRFN1	;DATA LINK
IMRFN6:	SKIPL IMPHTB(H)
	 JRST IMRFN7
	MOVSI D,400000
	ANDCAM D,IMPHTB(H)	;SET RFNM RECEIVED
	SOS IMRFCT
	SKIPL IMPNCQ		;SKIP IF NO PENDING CONTROL-LINK OUTPUT
	 PUSHJ P,IMPIOS		;START OUTPUT
	JRST IMPIRT

IMRFN7:	AOS IMNSRC
	BUG INFO,[NET: SPURIOUS RFNM HST ],OCT,IMPHTN(H),[LNK 0]
	JRST IMPIRT

IMRFN1:	MOVE A,IMPCSH
	LSH A,8
	IOR A,IMPCLN	;HEADER
	MOVSI I,-IMPSTL
	MOVEI W,1
IMRFN2:	LDB D,IMSCHL	;HEADER
	SKIPGE IMSOC1(I)	;SKIP IF SLOT NOT IN USE
	 CAME A,D	;SKIP IF HEADER AGREES
	  JRST IMRFN3
	HRRZ J,IMSOC4(I)	;STATE
	MOVEI W,0
	CAIN J,%NSRFN
	 SOJA J,IMRFN4	;RFNM WAIT
	MOVSI J,20000	;MIGHT BE EXPECTING RFNM AFTER CLOSE
	TDNE J,IMSOC5(I)
	 JRST [ ANDCAM J,IMSOC5(I)
		JRST IMPIRT ]
IMRFN3:	AOBJN I,IMRFN2
	BUG INFO,[NET: SPURIOUS RFNM HST ],OCT,IMPHTN(H),[LNK],OCT,IMPCLN,SIXBIT,[(W)[SIXBIT/NOWAITNOLINK/]]
	AOS IMNSRF
	JRST IMPIRT

IMRFN4:	HRRM J,IMSOC4(I)	;CONNECTION OPEN
	MOVSI J,30000		;TURN OFF CLOSE-AWAITING-RFNM BIT, AND
	ANDCAM J,IMSOC5(I)	; RFNM-TIMEOUT-DURING-CLOSE BIT
	MOVE T,IMSPIP(I)
	CAME T,IMSMPP(I)	;SKIP IF OUTPUT BUFFER EMPTY
	 PUSHJ P,IMPIOS		;START OUTPUT
	JRST IMPIRT

;HERE FOR INCOMPLETE TRANSMISSION OR DESTINATION HOST DEAD FROM IMP
IMPINC:	SKIPA E,[%NCINC]
IMPDHD:	 MOVEI E,%NCDED
	MOVSI C,1000		;RST SENT?
	TDNE C,IMPHTB(H)
	 SOS IMRFCT		;GOING TO CLEAR IT, DECREASE TIMEOUT RQ
	MOVSI C,3000
	ANDCAM C,IMPHTB(H)	;CLEAR RST STATUS, RFNM SIMULATED LATER
	MOVSI I,-IMPSTL
IMDHD:	LDB T,IMSCFH
	SKIPGE C,IMSOC1(I)	;SKIP IF NOT IN USE
	 CAME T,IMPCSH
	  JRST IMDHDA
	HRRZ T,IMSOC4(I)
	TLNN C,200000	;THIS GUY IS CLOSING ANYWAY
	 CAIG T,%NSLSN
	  JRST IMDHDA	;THIS SOCKET'S HOST NUMBER FIELD IS MEANINGLESS
	CAIGE T,%NSCLI .SEE %NSINP
	 TDZA T,T .SEE %NSCLS
	  MOVEI T,%NSCLI
	HRRM T,IMSOC4(I)
	DPB E,IMSCLS	;CLS REASON
	PUSHJ P,IMPUIN
IMDHDA:	AOBJN I,IMDHD
	JRST IMRFN6	;CONTROL LINK, TAKE AS RFNM SO AS NOT TO HANG THINGS

;GET HERE PI IN PROG ON NETCHN
;IMP HAS NETCHN PIA, TT HAS CONI WORD, A HAS LAST WD OF CONTROL LINK MSG
;PROCESS THE CONTROL LINK HOST-HOST PROTOCOL OPCODES.
IMPBK3:	AOS B,IMBLKI	;STORE LAST WORD AS IF BLKI HAD
	MOVEM A,(B)
	MOVEI B,-IMPINB+1(B)	;B HAS NUMBER OF WORDS READ
	CAMGE B,IMPNIW
	 JRST IMPCIS	;MESSAGE IS SHORT
	MOVE A,IMPCBC	;NUMBER OF BYTES
	MOVE B,[441000,,IMPINB]	;8 BIT BYTE POINTER TO MESSAGE
	SETZM IMPNEA
	SETZM IMPNRA
IMPBKL:	SOJL A,IMPIR1	;LOOP HERE TO PROCESS CONTROL MESSAGE
	MOVE H,IMPCSH	;RESTORE HOST INDEX
	ILDB C,B
	CAIL C,IMPCDL
	 JRST IMPCIG	;ILLEGAL OPCODE
	AOS IMPCMR(C)	;COUNT CTL MSG RCD
	JRST @IMPCDT(C)	;DISPATCH ON OPCODE

IMPCIG:	BUG INFO,[NET: NEW CTL MSG FM HST ],OCT,IMPHTN(H),[COD=],OCT,C,[CT=],OCT,A
	JRST IMPIR1

IMPCIS:	MOVE H,IMPCSH
	BUG INFO,[NET: SHORT CTL MSG FM HST ],OCT,IMPHTN(H)
	AOS IMNSCM
	JRST IMPIR1

IMPCDT:	IMPBKL	;NOP	( 0)
	IMPRFC	;RTS	( 1)
	IMPRFC	;STR	( 2)
	IMPCLS	;CLS	( 3)
	IMPALL	;ALL	( 4)
	IMPCIG	;GVB	( 5)
	IMPCIG	;RET	( 6)
	IMPINR	;INR	( 7)
	IMPINS	;INS	(10)
	IMPECO	;ECO	(11)
	IMPCIG	;ERP	(12)
	IMPERM	;ERR	(13)
	IMPRST	;RST	(14)
	IMPRRP	;RRP	(15)
	IMPCIG	;RAR	(16)
	IMPCIG	;RAS	(17)
	IMPCIG	;RAP	(20)
	IMPNXR	;NXR	(21)
	IMPNXR	;NXS	(22)
IMPCDL==.-IMPCDT

IMSHRT:	MOVNS A
	BUG INFO,[NET: SHORT CTL MSG HST ],OCT,IMPHTN(H),[COD=],OCT,C,[MISSING],OCT,A
	JRST IMPIR1

IMPNXR:	ILDB C,B	;LINK NUMBER FOR NXR OR NXS
	SOJA A,IMPBKL	;JUST IGNORE IT, USELESS ANYWAY

;RFC RECEIVED  C HAS OPCODE
IMPRFC:	SUBI A,9	;MUST BE AT LEAST 9 MORE BYTES
	JUMPL A,IMSHRT	;MESSAGE IS SHORT
	ILDB D,B	;D GETS 32 BIT FOREIGN SOCKET NUMBER
REPEAT 3,[
	LSH D,8
	ILDB T,B
	IORI D,(T)
]
	ILDB E,B	;E GETS 32 BIT LOCAL SOCKET NUMBER
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	ILDB R,B	;LINK NUMBER OR BYTE SIZE
	MOVE Q,E
	EQVI Q,(C)	;Q 1.1 = 1 IF E 1.1 = C 1.1
	ANDI Q,1
	JUMPE Q,IMPRF3	;WRONG DIRECTION RFC
	CAIE C,2	;SKIP IF STR
	 JRST IMPRF5
	CAILE R,36.	;SKIP IF STR AND BYTE SIZE < 37
	 JRST IMREFU	;REFUSE CONNECTION
IMPRF5:	PUSHJ P,IMPLLS	;LOOK FOR LOCAL SOCKET (RET INDEX IN I)
	 JRST IMPRFQ	;NO SUCH SOCKET.  QUEUE IT
	HRRZ W,IMSOC4(I)	;SOCKET STATE
	CAIE W,%NSLSN	;SKIP IF LISTENING
	 JRST IMPRF4
	MOVEM D,IMSOC3(I)	;STORE FOREIGN SOCKET NUMBER
	DPB H,IMSCFH		;STORE FOREIGN HOST INDEX
	MOVEI Q,%NSRFC
	HRRM Q,IMSOC4(I)	;RFC RECEIVED STATE
	CAIN C,2	;SKIP IF RTS
	 JRST [	LDB Q,IMSCBS	;STR, CHECK CONNECTION BYTE SIZE
		CAME Q,R
		 JRST IMCLDA
		JRST .+2 ]
	  DPB R,IMSCLN	;RTS, STORE LINK #
	PUSHJ P,IMPUIN	;INTERRUPT USER
IMRFCX:	LDB Q,IMHSBT
	CAIN Q,1
	 SOS IMRFCT
	MOVEI Q,2
	DPB Q,IMHSBT	;MARK HOST UP
	JRST IMPBKL

IMPRF3:	BUG INFO,[NET: WRONG DIR RFC HST ],OCT,IMPHTN(H),[OP ],SIXBIT,[(C)[SIXBIT /RTS   STR/]-1],[SOK],OCT,E
	JRST IMPBKL

IMPRF4:	CAIE W,%NSRFS	;SKIP IF IN RFC SENT STATE
	 JRST IMPRFQ	;QUEUE IT
	LDB Q,IMSCFH
	CAMN Q,IMPCSH
	 CAME D,IMSOC3(I)	;FROM CORRECT FOREIGN SOCKET?
	  JRST IMREFU	;NO, REFUSE
	AOS IMSOC4(I)	;PUT INTO STATE 5 - OPEN
	CAIE C,1	;SKIP IF RTS
	 JRST IMPRF2	;STR
	DPB R,IMSCLN	;STORE LINK #
IMPRF1:	PUSHJ P,IMPUIN	;INTERRUPT USER
	JRST IMPBKL

IMPRF2:	LDB Q,IMSCBS
	CAME Q,R
	 JRST IMCLDA	;BYTE SIZES DIFFER, REFUSE
	JSP T,IMSTCM
	    8,,2	;TEXT: 8 BYTES, 2 WORDS
	 JRST [	AOS IMNANS
		JRST IMPRF1 ]
	MOVEI H,2(I)
	LSH H,16.	;LINK #
	IOR H,IMSOC8(I) ;MSG ALLOC
	LSH H,4
	TLO H,(4_28.)	;ALL
	MOVEM H,10(Q)
	MOVE H,IMSOC7(I) ;BIT ALLOC
	LSH H,4
	MOVEM H,11(Q)
	PUSHJ P,IMWCQ	;SEND IT OUT
	JRST IMPRF1

IMPRFQ:	CAIL E,NETSRS	;IF < 1000, START JOB "NETRFC"
	 JRST IMRFQ5
	MOVE T,IMPHTN(H)
	CAIE T,<IMPUS_-6>+<IMPUS&77>_9
	 SKIPL NETUSW
	  CAIA
	   JRST IMREFU	;REFUSE CONNECTION
	HRROI T,NTRFCL
	PUSHJ P,NUJBST	;LOAD SERVER
	 JRST IMREFU	;RING BUFFER FULL
IMRFQ5:	SKIPGE Q,IMFFPQ	;SKIP IF ANY FREE SLOTS
	 JRST IMRFQ1	;CLS OLDEST
	MOVE W,(Q)
	MOVEM W,IMFFPQ	;NEW FIRST FREE
IMRFQ9:	SETOM (Q)	;END OF QUEUE
	MOVEM E,1(Q)	;LOCAL SOCKET NUMBER
	MOVEM D,2(Q)	;FOREIGN SOCKET NUMBER
	CAIE C,2	;SKIP IF STR
	 TLO R,400000	;MARK AS RTS
	MOVEM R,3(Q)	;LINK NUMBER OR BYTE SIZE
	DPB H,[101000,,3(Q)]	;FOREIGN HOST INDEX
	LDB W,[051100,,TIME]	;STORE TIME OF RECEIPT, IN 16/15 MOD 512.
	DPB W,[221100,,3(Q)]
	SKIPGE W,IMPEPQ	;END OF QUEUE
	 JRST IMRFQ2	;QUEUE EMPTY
	MOVEM Q,(W)	;PUT IN AT END OF QUEUE
	MOVEM Q,IMPEPQ	;NEW END OF QUEUE
	JRST IMRFCX

IMRFQ2:	MOVEM Q,IMPEPQ	;END OF QUEUE
	MOVEM Q,IMPBPQ	;AND BEGINNING OF QUEUE
	JRST IMRFCX

IMRFQ1:	MOVE J,IMPBPQ	;BEGINNING OF PENDING QUEUE
	MOVE E,1(J)	;LOCAL SOCKET
	MOVE D,2(J)	;FOREIGN SOCKET
	PUSH P,IMPCSH
	LDB H,[101000,,3(J)]	;FOREIGN HOST INDEX
	MOVEM H,IMPCSH
	PUSHJ P,IMPSCL	;SEND CLS
	 JRST IMRFQ3	;NO BUFFERS AVAILABLE
	AOSA IMNRFC	;# RFCS CLOSED
IMRFQ3:	 AOS IMNRFI	;# RFCS IGNORED
	POP P,IMPCSH
	MOVE H,IMPCSH
	MOVE Q,IMPBPQ	;FLUSH FIRST ENTRY ON PENDING QUEUE
	MOVE W,(Q)
	MOVEM W,IMPBPQ
	JRST IMRFQ9

IMREFU:	PUSHJ P,IMPSCL	;SEND CLS
	 AOS IMNCNS	;CAN'T
	AOS IMNRFI
	JRST IMPBKL

IMPCLS:	SUBI A,8	;MUST BE AT LEAST 8 MORE BYTES
	JUMPL A,IMSHRT	;MESSAGE IS SHORT
	ILDB D,B	;D GETS 32 BIT FOREIGN SOCKET NUMBER
REPEAT 3,[
	LSH D,8
	ILDB T,B
	IORI D,(T)
]
	ILDB E,B	;E GETS 32 BIT LOCAL SOCKET NUMBER
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	PUSHJ P,IMPLC	;LOOK FOR CONNECTION
	 JRST IMCLSQ	;LOOK IN QUEUE
	MOVSI W,200000	;SET CLS RCD BIT
	IORB W,IMSOC4(I)	;RH IS STATE FOR DISPATCH
	JRST @IMCLDT(W)

IMCLDT:	OFFSET -.
%NSCLS::IMPCLI
%NSLSN::IMPCLI
%NSRFC::IM2CLS
%NSRCL::IMPCLI
%NSRFS::IM4CLS
%NSOPN::IM5CLS
%NSRFN::IM6CLS
%NSCLW::IM7CLS
%NSCLI::IMPCLI
%NSINP::IMECLS
	OFFSET 0

IM4CLS:	HLLZS IMSOC4(I)	.SEE %NSCLS
	MOVEI W,%NCRFS
	JRST IMCLDB

IMECLS:	MOVEI W,%NSCLI
	JRST IMCCLS

IMCLDA:	HLLZS IMSOC4(I)	.SEE %NSCLS
	MOVEI W,%NCBYT	;BYTE MISMATCH
	JRST IMCLDB

IM6CLS:	MOVSI W,20000	;CLSED DURING RFNM WAIT
	IORM W,IMSOC5(I)
IM5CLS:	TDZA W,W	.SEE %NSCLS
IM2CLS:	 MOVEI W,%NSRCL
IMCCLS:	HRRM W,IMSOC4(I)	;CHANGE STATE
	MOVEI W,%NCFRN
IMCLDB:	DPB W,IMSCLS	;CLS REASON
	PUSHJ P,IMPUIN	;INTERRUPT USER
IMCLQ2:	PUSHJ P,IMPSCL	;SEND CLS
	 AOS IMNCNS
	JRST IMPBKL

IMPSCL:	JSP T,IMSTCM	;SEND A CLS TO LOCAL SOCKET IN E AND FOREIGN SOCKET IN D (CLOBBERS D AND E)
	    12.,,3	;TEXT: 12 BYTES, 3 WORDS
	 POPJ P,
	MOVEI H,3_4	;3 NOPS + CLS
	MOVEM H,10(Q)
	LSH E,4
	MOVEM E,11(Q)	;LOCAL SOCKET NUMBER
	LSH D,4
	MOVEM D,12(Q)	;FOREIGN SOCKET NUMBER
	PUSHJ P,IMWCQ	;SEND CLS
	JRST POPJ1

IMPCLI:	AOS IMNCLI
	JRST IMPBKL

IM7CLS:	HLLZS IMSOC4(I)	.SEE %NSCLS
	JRST IMPBKL

IMCLSQ:	PUSH P,A
	PUSH P,B
	MOVE A,E	;LOCAL SOCKET NUMBER
	MOVEI T,0
	MOVE B,D	;FOREIGN SOCKET NUMBER
	PUSHJ P,IMSPQP	;SEARCH PENDING QUEUE
	 JRST IMCLQ1	;NOT THERE
	MOVE E,A
	POP P,B
	POP P,A
	JRST IMCLQ2	;SEND HIM A CLS

IMCLQ1:	POP P,B
	POP P,A
	JRST IMPCLI	;CAN'T FIND HIM.  IGNORE

IMPALL:	SUBI A,7	;MUST BE AT LEAST 7 MORE BYTES
	JUMPL A,IMSHRT	;MESSAGE IS SHORT
	ILDB R,B	;LINK #
	ILDB D,B
	LSH D,8
	ILDB T,B
	IORI D,(T)	;D GETS MESSAGE ALLOCATION
	ILDB E,B	;E GETS BIT ALLOCATION
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	MOVE T,IMPCSH	;FOREIGN HOST
	LSH T,8
	IOR R,T		;HEADER (HOST AND LINK #)
	MOVEI W,1	;TO TEST DIRECTION OF SOCKET
	MOVSI I,-IMPSTL
IMPAL2:	LDB T,IMSCHD	;FOREIGN HOST AND LINK NUMBER
	SKIPGE IMSOC1(I)	;SKIP IF SLOT NOT IN USE
	 CAME T,R	;SKIP IF HEADER AGREES
	  JRST IMPAL1
	TDNE W,IMSOC2(I)	;SKIP IF NOT SEND
	 JRST IMPAL3
IMPAL1:	AOBJN I,IMPAL2
	ANDI R,377
	BUG INFO,[NET: IGNORED ALLOC HST ],OCT,IMPHTN(H),[LNK],OCT,R
	AOS IMNALI
	JRST IMPBKL	;IGNORE

IMPAL3:	SKIPL D
	 SKIPGE E
	  JRST 4,.
	LDB T,IMSCBS		;GET BYTESIZE
	IDIV E,T		;TRUNCATE TO 0 MODULO BYTESIZE
	IMUL E,T		;(CLOBBER TT)
	SKIPL IMSOC8(I)
	 SKIPGE IMSOC7(I)
	  JRST 4,.
	ADDB D,IMSOC8(I)	;INCREASE ALLOCATIONS
	ADDB E,IMSOC7(I)
	MOVE Q,IMSOC5(I)
	TLNE Q,140000		;ACTIVATE IF USER (OR DIRECT CONN) CHECKING ALLOC
	 PUSHJ P,IMPUIN
	MOVE T,IMSPIP(I)
	CAME T,IMSMPP(I)	;SKIP IF OUTPUT BUFFER EMPTY
	 PUSHJ P,IMPIOS		;THIS GUY MAY HAVE STUFF TO GO OUT
	JRST IMPBKL

IMPLLS:	MOVSI I,-IMPSTL	;LOOK FOR SOCKET IN E
	MOVSI W,200000
IMPLL2:	TDNN W,IMSOC1(I)
	 SKIPL IMSOC1(I)	;NOT IN USE
	  JRST IMPLL1
	CAME E,IMSOC2(I)	;SKIP IF RIGHT LOCAL SOCKET NUMBER
IMPLL1:	 AOBJN I,IMPLL2
	JUMPL I,POPJ1	;RETURN SOCKET TABLE INDEX IN RH OF I
	POPJ P,		;NOT FOUND

;INTERRUPT USER ASSOCIATED WITH CHANNEL IN I
IMPUIN:	MOVSI U,200000
	TDNE U,IMSOC1(I)
	 POPJ P,		;CHNL BEING CLOSED
	MOVE U,IMSOC5(I)
	TLNE U,40000
	 JRST IMPUIS		;JUMP IF SOCKET IS CONNECTED TO A STY.
IMPUIP:	HRRZ U,IMSOC1(I)	;USER INDEX
	LDB Q,[222000,,IMSOC1(I)]	;MASK FOR CHANNEL OPEN ON
IMPUIM:	AND Q,MSKST2(U)		;ONLY ENABLED CHANNELS.
	PUSH P,T		;VALIDATE THE USER INDEX
	MOVEI T,LUBLK
	IDIVM U,T
	IMULI T,LUBLK
	CAMN T,U
	 CAML U,USRHI
	  JRST 4,.
	MOVSI T,(SETZ)		;PCLSR SO IT GETS IOC ERROR IF NEEDFUL
	IORM T,PIRQC(U)		; EVEN IF IT DOESN'T HAVE NORMAL INTERRUPTS ENABLED
	POP P,T
	IORM Q,IFPIR(U)		;GEN SECOND WORD INTERRUPT
	POPJ P,

IMPUIS:	PI2SAF			;HERE FOR INT. ON SOCKET CONNECTED TO A STY:
	ANDI U,777
	SKIPL STYNTL-NFSTTY(U)
	 POPJ P,		;ALREADY ACTIVATED
	MOVE Q,STYNTA		;PUT THAT STY ON THE XFER ACTIVATION LIST.
	MOVEM Q,STYNTL-NFSTTY(U)
	MOVEM U,STYNTA		;THEN RETURN.  DON'T ACTUALLY INTERRUPT THE JOB;
	POPJ P,			;IF ANYTHING FUNNY HAS HAPPENED, STYNTC WILL INTERRUPT.

;LOOK FOR CONNECTION: LOCAL SOCKET IN E, FOREIGN SOCKET IN D, FOREIGN HOST IN H
IMPLC:	MOVSI I,-IMPSTL
IMPLC2:	SKIPGE IMSOC1(I)	;NOT IN USE
	 CAME E,IMSOC2(I)	;LOCAL SOCKET NUMBER
	  JRST IMPLC1
	LDB T,IMSCFH
	CAMN D,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	 CAME H,T
IMPLC1:	  AOBJN I,IMPLC2
	JUMPL I,POPJ1
	POPJ P,

IMPINR:	SOJL A,IMSHRT	;SHORT COUNT
	ILDB D,B	;LINK #
	DPB H,[101000,,D] ;CONCAT HOST&LINK
	MOVSI I,-IMPSTL
	LDB E,IMSCHD	;GET HOST FOR SOCKET
	CAME D,E
	 AOBJN I,.-2	;SEARCH FOR MATCHING HOST&LINK
	JUMPGE I,IMPILS	;NOT FOUND
IMPIRS:	HRRZ E,IMSOC4(I)	;STATE
	MOVE E,CHNBIT(E)	;BIT TO CORRESPOND
	TRNN E,1_%NSRFC+1_%NSRFS+1_%NSOPN+1_%NSRFN+1_%NSCLW+1_%NSINP
			;OK STATES RFCRCV, RFCSNT, OPEN, RNMWT, CLSSNT, DATA
	 JRST IMPILS	;IN BAD STATE
	TRNE E,1_%NSCLW	;IGNORE INT IF CLSSNT STATE (NOT ERROR)
	 JRST IMPBKL
	MOVSI D,4000
	IORM D,IMSOC5(I)	;INT FLAG 4.3 BIT OF IMSOC5(SOCK)
	PUSHJ P,IMPUIN	;INT TO USER
	JRST IMPBKL

IMPINS:	SOJL A,IMSHRT	;SHORT
	ILDB D,B	;LINK
	MOVEI I,-2(D)	;0,1 -> 777776,777777 ILLEGAL LINKS
	CAIGE I,IMPSTL	;CHECK IN RANGE 2 TO IMPSTL+1
	 SKIPL IMSOC1(I);AND IN USE
	  JRST IMPILS	;BAD LINK
	LDB T,IMSCFH
	CAMN T,IMPCSH	;SKIP IF HOST NOT MATCHED BY MSG
	 JRST IMPIRS
IMPILS:	BUG INFO,[NET: BAD INT CTL MSG HST ],OCT,IMPHTN(H),[LNK ],OCT,D,[IMSOC4],OCT,IMSOC4(I)
	JRST IMPBKL	;NOTE- I MAY BE -1 OR -2  OR UP TO 256, IF LNK BAD, IGNORE

IMPECI:	AOS IMPNEI	;WILL EVENTUALLY GIVE JOB TO MAIN PROG
	JRST IMPBKL

IMPECO:	ILDB D,B	;GET 8 BIT DATA TO ECHO
	SOJL A,IMSHRT
	SKIPE IMPNEA
	 JRST IMPECI	;ONLY ONE TO A CUSTOMER
	JSP T,IMSTCM
	    2,,1	;TEXT: 2 BYTES, 1 WORD
	 JRST IMPECI
	LSH D,20.	;DATA TO BE ECHOED
	TLO D,(10._28.)	;ERP
	MOVEM D,10(Q)
	PUSHJ P,IMWCQ	;SEND IT OUT
	AOS IMPNEA
	JRST IMPBKL

IMPERM:	SUBI A,11.	;COUNT BYTES
	MOVE C,TIME
	MOVEM C,IMPERB
	MOVE C,IMPHTN(H)	;REAL HOST NUMBER
	MOVEM C,IMPERB+1
	MOVE C,[441100,,IMPERB+2]
	MOVEI D,11.	;BYTES TO COPY
	ILDB T,B	;COPY BYTES FROM THEIR MSG
	IDPB T,C
	SOJG D,.-2
	BUG INFO,[NET: ERR MSG FM HST ],OCT,IMPERB+1,[MSG],OCT,IMPERB+2,OCT,IMPERB+3
			;ONLY PRINTS FIRST 8 BYTES OF ERR INFO
	JUMPGE A,IMPBKL	;IF COUNT OK, GET MORE
	JRST IMSHRT	;SHORT COUNT

IMPRSI:	AOS IMPNRI
	JRST IMPBKL

IMPRST:	MOVE T,IMPHTN(H)
	CAIE T,<IMPUS_-6>+<IMPUS&77>_9	;IF RST FROM OURSELVES, JUST SEND RRP
	 PUSHJ P,IMPRSR
	SKIPE IMPNRA
	 JRST IMPRSI
	JSP T,IMSTCM
	    1,,1	;TEXT: 1 BYTE, 1 WORD
	 JRST IMPRSI
	MOVSI D,(13._28.)	;RRP
	MOVEM D,10(Q)
	PUSHJ P,IMWCQ	;SEND IT OUT
	PUSHJ P,IMPIOS
	AOS IMPNRA
	JRST IMPBKL

IMPRSR:	MOVSI I,-IMPSTL	;LOOK FOR USERS OF THIS HOST
	MOVSI TT,200000
IMPRS2:	TDNN TT,IMSOC1(I)	;GUY GOING AWAY ANYHOW
	 SKIPL IMSOC1(I)
	  JRST IMPRS1
	LDB C,IMSCFH	;FOREIGN HOST
	CAME C,IMPCSH
	 JRST IMPRS1	;WRONG HOST
	HRRZ C,IMSOC4(I)
	MOVEI D,%NSCLS
	CAIN C,%NSINP
	 MOVEI D,%NSCLI	;INPUT STILL AVAILABLE
	HRRM D,IMSOC4(I)
	MOVEI D,%NCRST
	DPB D,IMSCLS	;CLS REASON IS RST
	PUSHJ P,IMPUIN	;INTERRUPT USER
IMPRS1:	AOBJN I,IMPRS2
	;IF HOST CAN SEND A RST, IT IS UP, BUT DON'T
	;REALLY CONSIDER IT UP UNTIL RRP, RTS, OR STR IS RECEIVED
	;I DON'T KNOW WHY IT'S DONE THIS WAY
	POPJ P,

IMPRRP:	LDB J,IMHSBT
	SOJL J,IMPRR1
	JUMPG J,IMPBKL	;ALREADY UP, MAYBE BECAUSE OF PRIOR RTS,STR
	MOVEI J,2
	DPB J,IMHSBT	;MARK HIM UP
	SOS IMRFCT
	JRST IMPBKL

IMPRR1:	BUG INFO,[NET: RRP W-O RST HST],OCT,IMPHTN(H)
	JRST IMPBKL

;GET CONTROL QUEUE SLOT
IMGCQS:	SKIPG IMFCQL	;SKIP IF ANY LEFT
	 JRST IMGCQL	;NONE
	SKIPG Q,IMFFCQ	;POINTER TO SLOT
	 JRST 4,.
	MOVE W,(Q)
	MOVEM W,IMFFCQ	;PATCH OUT OF FREE LIST
	SETOM (Q)
	SOS W,IMFCQL	;NUMBER FREE LEFT
	CAIN W,1	;SKIP IF MORE THAN ONE LEFT
	 SETOM IMPHI	;SET FLAG TO HOLD UP INPUT
	JRST POPJ1

IMGCQL:	AOS IMNPIL
	POPJ P,

IMWCQ:	PUSHJ P,IMWPCQ
	JRST IMPIOS	;START OUTPUT

;ADD BLOCK IN Q TO OUTPUT CONTROL QUEUE, BASHES W
IMWPCQ:	SETOM (Q)
	SKIPGE W,IMPLCQ
	 JRST IMWCQ1	;CONTROL QUEUE EMPTY
	AOSE (W)
	 JRST 4,.	;END OF QUEUE DIDN'T POINT TO -1
	MOVEM Q,(W)
	MOVEM Q,IMPLCQ
	POPJ P,

IMWCQ1:	MOVEM Q,IMPLCQ
	MOVEM Q,IMPNCQ
	POPJ P,

;ADD MAIN PROGRAM BLOCK TO PI QUEUE (CALL AT MP LEVEL)
IMPMPQ:	MOVSI Q,777
	IORM Q,IMPMPU+1	;NOT LOCKED BY THIS JOB ANY MORE
	SKIPL U		;SKIP IF CALLED FROM DIRECT-CONNECT CLOCK LEVEL
	 PUSHJ P,LSWDEL	;PI LEVEL WILL UNLOCK
	CONO PI,NETOFF
	MOVEI Q,IMPMPL
	PUSHJ P,IMWPCQ
	CONO PI,NETON
	JRST IMPOST

;CALL BY JSP T,IMSTCM
;SET UP STANDARD PI CONTROL MESSAGE
;BYTE COUNT,,TEXT LENGTH 
;ERROR RETURN

IMSTCM:	PUSHJ P,IMGCQS	;GET CONTROL QUEUE SLOT IN Q
	 JRST 1(T)	;NONE AVAILABLE
	MOVSI H,17_10.	;MESSAGE TYPE = 0, LINK # = 0, NEW FMT
	MOVEM H,2(Q)
	MOVE H,IMPCSH	;GET IMP AND HOST
	MOVE H,IMPHTN(H)
	DPB H,[301000,,3(Q)] ;STORE HOST
	LSH H,-9
	DPB H,[102000,,3(Q)] ;STORE IMP
	HLRZ H,(T)	;BYTE COUNT
	LSH H,8
	IOR H,[8_24.]	;BYTE SIZE = 8
	MOVEM H,7(Q)
	HRLZ H,(T)
	HRR H,IMPCSH
	MOVSM H,1(Q)	;HOST INDEX,,TEXT LENGTH
	JRST 2(T)	;NORMAL RETURN (NOTE THAT H HAS BEEN RESTORED TO IMPCSH)

;RECEIVED LEADER OF REGULAR MESSAGE NOT ON CONTROL LINK
;THE HOST-HOST LEADER WORD (WD 6) HAS NOT YET BEEN DATAI'ED.
;SWITCH TO 32-BIT MODE FIRST IF NECESSARY.
IMPRMD:	MOVE D,IMPCSH
	LSH D,8
	MOVE I,IMPCLN
	IOR D,I		;HEADER
	SUBI I,2	;SOCKET TABLE INDEX
	JUMPL I,IMPRM7	;BAD LINK #
	SKIPGE A,IMSOC1(I)
	 TLNE A,200000	;SKIP IF NOT BEING CLOSED
	  JRST IMPRM7	;SOCKET DOESNT EXIST OR BEING CLOSED
	MOVEI A,1
	CAIGE I,IMPSTL
	 TDNE A,IMSOC2(I)	;SKIP IF RECEIVER
	  JRST IMPRM7	;BAD LINK # OR MESSAGE FOR A SENDER
	LDB C,IMSCHD	;HEADER
	CAME D,C	;SEE IF HEADERS AGREE
	 JRST IMPRM7	;NOPE, I.E. FROM WRONG HOST OR CLOSED
	HRRZ D,IMSOC4(I)
	CAIE D,%NSOPN
	 CAIN D,%NSINP
	  JRST IMPRMA
	JRST IMPRM7
IMPRMA:	SKIPGE IMSOC6(I)	;SKIP IF NOT LOCKED BY CORE JOB
	 JRST IMPRMP		;LOCKED, COME BACK LATER
IFE DMI,[
	SKIPL IMSOC5(I)		;SKIP IF 32 BIT TRANSFER
	 CONO IMP,IMI32C	;SET 36 BIT INPUT
	SKIPGE IMSOC5(I)	;SKIP IF NOT 32 BIT TRANSFER
	 CONO IMP,IMI32S	;SET 32 BIT INPUT
]IFN DMI,[
	SKIPL IMSOC5(I)		;SKIP IF 32BIT
	 CONO FI,FII32C		;SET 36BIT
	SKIPGE IMSOC5(I)	;SKIP IF 36 BIT
	 CONO FI,FII32S		;SET 32 BIT
]
	DATAI IMP,IMPILB+5	;GET THE HEADER WORD
	LDB A,IMCBBP
	MOVEM A,IMPCBS
	LDB B,IMSCBS		;Check for fraudulent byte size
	CAME A,B
	 JRST IMPRMZ		;Discard message
	LDB B,IMBCBP
	MOVEM B,IMPCBC
	MOVEM B,IMPNBI		;SAVE BYTE COUNT FOR LATER
	SOSGE IMSOC8(I)
	 JRST IMRMAF		;MESSAGE ALLOCATION EXCEEDED
	JUMPE B,IMPIRT		;ZERO LENGTH MESSAGE
	IMUL A,B		;BIT COUNT
	MOVN D,A
	ADDB D,IMSOC7(I)	;REMAINING BIT ALLOCATION
	JUMPL D,IMRMAH		;BIT ALLOCATION EXCEEDED
	TRNE TT,IMPLW
	 JRST IMRMAG		;MESSAGE IS SHORT
	MOVSI D,200000
	IORB D,IMSOC6(I)	;ACTIVE AT PI LEVEL
	SKIPGE IMSOC5(I)
	 IDIVI A,32.
	SKIPL IMSOC5(I)
	 IDIVI A,36.
	SKIPE B
	 ADDI A,1		;NUMBER OF WORDS MESSAGE WILL TAKE
	HRRZ B,IMSPIP(I) 	;ADDRESS WHERE MESSAGE HEADER WILL GO
	SKIPL (B)
	 JRST 4,.		;HEADER WORD SHOULD BE -1
	HRRZ C,IMSBFE(I)	;GET ADDRESS OF LAST WORD IN BUFFER
	CAML B,C
	 MOVEI B,-1(D)		;HEADER IS LAST IN BUFFER, SO DATA IS FIRST
	MOVE E,B		;RH(BLKI POINTER) IN E
	ADD A,B			;ADDRESS WHERE LAST WORD OF MESSAGE WILL GET STORED
	SETZM IMNWSI		;ASSUME WILL ONLY NEED ONE BLKI
	CAMG A,C
	 JRST IMPRM8		;JUMP IF NO WRAP
;DROPS THROUGH
;DROPS IN
	SUB B,C			;- # WDS TO READ FIRST TIME
	SUB A,C			;+ # WDS TO READ SECOND TIME
	SKIPGE B
	 SKIPG A
	  JRST 4,.		;SCREW
	MOVN C,A		;NEG OF REMAINING WORD COUNT
	MOVSS C			;TO LEFT HALF FOR BLKI POINTER
	HRRI C,-1(D)		;RING AROUND TO BEGIN OF BUFFER
	MOVEM C,IMNWSI		;STORE FOR INTCHN BLKI RUNOUT (FLAG IF -)
	ADD C,A			;ADR+COUNT
	HRRZM C,IMPNIW		;EXPECTED END OF BLKI
	SKIPA A,B
IMPRM8:	 SUBM B,A		;A GETS - # WORDS TO READ
	MOVE B,E
	HRL B,A			;BLKI POINTER
	SUB E,A			;EXPECTED LAST WORD
	SKIPE IMNWSI		;IF DOING 2 BLKIS, EXPECTED END ALREADY STORED
	 SKIPA E,IMPNIW
	  MOVEM E,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	HRRZ A,IMSPIP(I)	;SEE IF CLOBBERING GOOD-DATA PART OF BUFFER
	CAIL A,@IMSMPP(I)	;SKIP IF MPP > PIP
	 JRST [	CAIG E,(A)
		 CAIGE E,@IMSMPP(I)
		  JRST IMPRMT
		JRST 4,. ]
	CAIGE E,@IMSMPP(I)
	 CAIG E,(A)
	  JRST 4,.
IMPRMT:	HRRZ A,IMSOC6(I)	;SEE IF CLOBBERING CORE NOT PART OF BUFFER
	CAIL E,(A)
	 CAILE E,@IMSBFE(I)
	  JRST 4,.
	HRRZM I,IMPIPI		;THIS SOCKET NOW ACTIVE AT P.I. LEVEL
	MOVEI C,4
	JRST IMPRM9		;START READING

IMPRMP:	MOVSI D,100000		;SET INPUT HELD UP BY CORE JOB
	IORM D,IMSOC6(I)
IFE DMI,[
	MOVE D,IMPPIA
	MOVEM D,IMPSVP
	SETZM IMPPIA	;TURN OFF NETWORK FOR A WHILE
]
IFN DMI,CONO FI,FIIN+0	;SET PIA TO 0 FOR A WHILE, CORE JOB WILL GET BACK
	JRST IMPRET

IMRMAH:	AOSA IMNBAE
IMRMAF:	 AOS IMNMAE
	JRST IMPIRT

IMPRM7:	AOSA IMNMNC
IMRMAG:	 AOS IMNMSS
	JRST IMPIRT

;GOT LAST IMP WORD (IN A) OF REGULAR NON-CONTROL-LINK MESSAGE
IMPRMB:	MOVE I,IMPIPI
	MOVE B,IMBLKI
	CAMN B,IMPNIW
	 JRST IMPRMC	;ONE EXTRA WORD OF IMP PADDING, IGNORE IT
	ADD B,[1,,1]	;ADDR TO NEXT WORD, COUNT TO ZERO
	CAME B,IMPNIW
	 JRST IMPRMY
	MOVEM A,(B)	;STORE LAST WORD
IMPRMC:	MOVE E,IMPNBI		;# BYTES IN
	ADDM E,IMSMPC(I)	;MAKE AVAIL TO M.P.
	MOVEM E,@IMSPIP(I)	;STORE HEADER
	AOS E,IMPNIW		;WORD AFTER MSG WILL BE NEXT HEADER
	CAILE E,@IMSBFE(I)
	 HRRZ E,IMSOC6(I)	;WRAP
	HRRM E,IMSPIP(I)	;LEAVE LH OF IMSPIP ALONE
	CAIN E,@IMSMPP(I)
	 JRST 4,.		;BUFFER 1 WORD TOO SMALL?
	SETOM (E)
	MOVEI E,%NSINP
	HRRM E,IMSOC4(I)	;INPUT AVAILABLE
	PUSHJ P,IMPUIN		;INTERRUPT USER
	MOVSI D,200000		;CLEAR ACTIVE AT P.I. LEVEL
	ANDCAM D,IMSOC6(I)
	SETOM IMPIPI
	JRST IMPIR1

IMPRMY:	HRRZ E,IMPNIW		;NOT ENDING WHERE IT'S SUPPOSED TO
	SUBI E,(B)		;E GETS NUMBER OF MISSING WORDS
	MOVE H,IMPCSH
	BUG INFO,[NET: MSG FM HST ],OCT,IMPHTN(H),[SHORT ],DEC,E,[WDS, BC],DEC,IMPCBC
	JRST IMPRMC		;PRETEND HOST TRANSMITTING GARBAGE

IMPRMZ:	MOVE H,IMPCSH
	BUG INFO,[NET: HST ],OCT,IMPHTN(H),[SENT BYTE SIZE ],DEC,A,[SHOULD BE],DEC,B
	JRST IMPIRT		;Discard message

SUBTTL	ARPANET OUTPUT INTERRUPT LEVEL

;IMP OUTPUT CHANNEL 1 - JSR HERE WHEN OUTPUT DONE

EBLK
IMPCH1:	0
BBLK
	MOVEM A,IMPOLC		;SAVE AC
	MOVE A,IMOPNT
IMCH1A:	SKIPGE A,IMOLST(A)	;GET NEXT "INSTRUCTION"
	 JRST IMCH1B		;JUMP IF BLKO
	CAILE A,3
	 JRST 4,.
	XCT IMCH1I(A)
	AOS A,IMOPNT
	JRST IMCH1A

IMCH1I:	JRST IMCH1C		;0 STOP
IFE DMI,CONO IMP,IMPLHW+IMPCHN	;1 SET LAST WORD
IFN DMI,CONO FI,FILHW+11*NETCHN
IFE DMI,CONO IMP,IMO32S+IMPCHN	;2 SET 32-BIT MODE
IFN DMI,CONO FI,FIO32S+10*NETCHN+IMPCHN
	JFCL			;3 NOP

IMCH1B:	MOVEM A,IMBLKO		;SET UP BLKO
	MOVE A,[JSR IMCH1D]
	MOVEM A,IMPOLC+1
	MOVE A,[BLKO IMP,IMBLKO]
	EXCH A,IMPOLC
	AOS IMOPNT
	JRST 12,@IMPCH1		;WILL INTERRUPT IMMEDIATELY FOR FIRST BLKO WORD

;JSR HERE ON BLKO RUNOUT
EBLK
IMCH1D:	0
BBLK
	MOVEM A,IMPOLC
	MOVE A,[JSR IMPCH1]	;INTERRUPT BACK WHEN OUTPUT OF LAST WORD DONE
	EXCH A,IMPOLC
	JRST 12,@IMCH1D

IMCH1C:				;DONE
IFN DMI,[
	CONO FI,FIOUT+11*NETCHN
	MOVE A,[JSR RINT1]
]
IFE DMI,[
	SETZM IMPOH
	MOVEI A,NETCHN
	SKIPL IMPIH
	 MOVEM A,IMPPIA
	CONO IMP,NETCHN
	SETOM IMPO		;WILL RE-INTERRUPT AND COME BACK ON NETCHN
	MOVE A,[JSR IMPOBK]
]
	EXCH A,IMPOLC
	JRST 12,@IMPCH1

IFE DMI,[

EBLK
IMPOBK:	0			;INT HERE ON CH1 WHEN REALLY WANTED TO BE ON CH2
BBLK
	SETOM IMPO
	CONO IMP,NETCHN
	JRST 12,@IMPOBK
]

;GET HERE PI IN PROG ON NETCHN, OUTPUT DONE
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPOBZ:	AOS IMCT3
IFN DMI,[
	TRC TT,IMPCHN_9	;CHECK IF OUTPUT PIA=IMPCHN
	TRNN TT,7_9
	 JRST IMPRET	;IGNORE, ALREADY HANDLED BY IMPCHN
]
	SKIPL B,IMPOS
	 CAIL B,IMPODL
	  JRST 4,.
	JRST @IMPODT(B)

IMPODT:	OFFSET -.
	IMPOB1	;0 IDLE, LOOK FOR SOMETHING TO DO
IMPCLW::IMPOB6	;1 FINISHED CONTROL MESSAGE
IMPDLW::IMPOBG	;2 FINISHED DATA MESSAGE
IMPODL::OFFSET 0

;LOOK FOR OUTPUT
IMPOB1:	HRRZ T,IMPUP
	CAIE T,-2	;DON'T SAY IT'S UP WHEN IT'S STILL GOING DOWN
	 CAIN T,1	;OR WHEN IT IS BROKEN
	  JRST IMPOB9
	AOSG IMNOPC
	 JRST IMONOP	;OUTPUT A NOP
	SETZM IMPUP	;IMP IS UP
	SETZM IMPTCU	;NO LONGER TRYING TO COME UP

;CHECK OUTPUT QUEUES
	MOVEI T,IMPNCQ
IMPOBV:	SKIPGE A,(T)
	 JRST IMPOBW
	HLRZ B,1(A)		;HOST TABLE INDEX
	SKIPL IMPHTB(B)		;SKIP IF WAITING FOR RFNM
	 JRST IMPOB2
	MOVE T,A
	JRST IMPOBV

IMPOBW:	MOVSI I,-IMPSTL
	MOVEI W,1
IMPOBB:	SKIPGE IMSOC1(I)	;SKIP IF NOT IN USE
	 TDNN W,IMSOC2(I)	;SKIP IF SEND
	  JRST IMPOBA
	HRRZ A,IMSOC4(I)
	CAIN A,%NSOPN		;SKIP IF WRONG STATE
	 SKIPGE IMSOC6(I)	;SKIP IF NOT LOCKED BY CORE JOB
IMPOBA:	  AOBJN I,IMPOBB
	JUMPL I,IMPOBD
IMPOB9:	SETOM IMPOAC	;NO MORE OUTPUT
IFE DMI,CONO IMP,IMPODC	;CLEAR OUTPUT DONE
IFN DMI,CONO FI,FIODC+NETCHN*11
	JRST IMPRET

;SEND A NOP

IMONOP:	MOVEI A,IMPNOP-2
	SETZM IMPSVQ	;FLAG THAT THIS MSG DIDN'T REALLY COME FROM THE CONTROL QUEUE
	MOVEI B,1	;NO TEXT, BUT ONE EXTRA WORD (NECESSARY TO MAKE BLKOS WIN)
	JRST IMPOB3

;NOP HOST-IMP LEADER
IMPNOP:	17_10.,,4_4	;NEW FORMAT, TYPE 4 = NOP
	0
	5_10.,,0	;5 16-BIT WORDS OF PADDING DESIRED

;SEND A CONTROL MESSAGE

IMPOB2:	HRL A,T
	MOVEM A,IMPSVQ	;SAVE CTL MSG QUEUE PNTR
	HRRE B,1(A)	;GET COUNT 
	JUMPG B,IMPOB3
	 JRST 4,.	;ERROR, COUNT NOT > 0
IMPOB3:
IFE DMI,CONO IMP,IMO32C
IFN DMI,CONO FI,FIO32C	;SET 36 BIT MODE FOR LEADER, CLEAR PIA
	DATAO IMP,2(A)	;OUTPUT FIRST LEADER WORD
	MOVEI C,2(A)	;SET UP BLKO POINTER FOR REST OF LEADER
	SKIPN IMPSVQ
	 JRST [	HRLI C,-2	;KLUDGE, SENDING NOP
		JRST IMPOB4 ]
	HRLI C,-5
	AOS IMPMSS+0	;COUNT REGULAR MSGS SENT
	LDB T,[341000,,10(A)] ;FIRST BYTE OF CONTROL MESSAGE
	CAIGE T,20
	 AOS IMPCMS(T)
IMPOB4:	MOVEM C,IMOLST	;STORE BLKO POINTER THAT SENDS LEADER
	MOVEI C,2	;DO TEXT WORDS IN 32-BIT MODE
	MOVEM C,IMOMOD
IFN DMI,MOVNI B,(B)	;GET MINUS WORD COUNT
IFE DMI,MOVNI B,-1(B)	;ALSO -1 FOR LAST WORD SENT SEPARATELY.
	HRLI B,7(A)	;ADDR-1 FOR BLKO
	MOVSM B,IMOBK1	;STORE FOR PI 1
IFE DMI,[
	MOVNI B,(B)
	ADD B,IMOBK1	;LAST WORD SENT SEPARATELY
	HRROM B,IMOBK3
	MOVEI B,3	;CHECK FOR SCREW CASE, ONLY SENDING ONE WORD, IT'S THE
	SKIPL IMOBK1	; LAST, SO NOP OUT THE MAIN BLKO
	 MOVEM B,IMOBK1
]
.ELSE	MOVEI B,3
	MOVEM B,IMOBK2	;NO 2ND BLKO
	MOVEI C,IMPCLW	;STATE FOR CONTROL RETURN TO NETCHN
IMOB9:	MOVEM C,IMPOS
	SETZM IMOPNT
	MOVE C,[JSR IMPCH1]
	MOVEM C,IMPOLC
IFE DMI,[
	SETOM IMPOH	;OUTPUT SIDE WANTS IMP TO RUN ON CHANNEL 1
	MOVEI A,IMPCHN
	MOVEM A,IMPPIA
]
IFN DMI,CONO FI,FIOUT+NETCHN_3+IMPCHN	;SET PIA FOR OUTPUT
	JRST IMPRET

;HERE ON COMPLETION OF TRANSMISSION OF CONTROL MESSAGE

IMPOB6:	SETZM IMPOS
	SKIPN A,IMPSVQ
	 JRST IMPRET		;THAT WAS A NOP
	HLRZ B,1(A)		;HOST TABLE INDEX
	MOVSI D,400000
	IORM D,IMPHTB(B)	;SET RFNM WAIT BIT
	AOS IMRFCT
	LDB D,[051100,,TIME]
	DPB D,[221100,,IMPHTB(B)] ;STORE TIME TOO
	HLRZ T,A
	HRRZS A
	MOVE B,(A)
	MOVEM B,(T)
	JUMPGE B,IMOB7A
	CAME A,IMPLCQ
	 JRST 4,.	;IMPLCQ GAVE WRONG LAST MESS NO.
	MOVEM T,IMPLCQ
	CAIN T,IMPNCQ
	 SETOM IMPLCQ
IMOB7A:	CAIN A,IMPMPL	;SKIP IF NOT MAIN PROG BLOCK
	 JRST [	SETOM IMPMPU
		JRST IMPRET ]
	MOVE B,IMFFCQ
	CAIN B,(A)
	 JRST 4,.	;MAKING INFINITE LOOP
	MOVEM B,(A)
	MOVEM A,IMFFCQ
	AOS A,IMFCQL
	SKIPGE B,IMPHI	;RETURN IF INPUT NOT HELD UP
	 CAIG A,1	;SKIP IF INPUT HELD UP AND NOW ENOUGH FREE
	  JRST IMPRET
	SETZM IMPHI
	AOJE B,IMPRET	;INPUT WAS NOT YET SUCCESSFULLY HELD UP
	AOJN B,[JRST 4,.]	;IMPHI SHOULD HAVE BEEN -2
	AOS IMPNUH
	MOVE TT,IMSTAS	;GET OLD CONI
	TRNE TT,IMPLW
IFE DMI,[
	 CONO IMP,IMI32C
	DATAI IMP,A
];DMI
IFN DMI,[
	 CONO FI,FII32C
	MOVE A,IMPSUS
];DMI
	TRNE TT,IMPLW	;RESUME INPUT
	 JRST IMPBKV
	SKIPE IMPIS
	 JRST 4,.
	JRST IMSTRT

;HERE ON COMPLETION OF TRANSMISSION OF DATA MESSAGE

IMPOBG:	SETZM IMPOS
	MOVE I,IMPOPI
	HRRZ Q,IMSOC4(I)
	CAIN Q,%NSOPN
	 AOS IMSOC4(I) .SEE %NSRFN	;PUT INTO RFNM WAIT STATE
	MOVSI A,20000
	CAIN Q,%NSCLS
	 IORM A,IMSOC5(I)
	MOVSI Q,200000
	ANDCAB Q,IMSOC6(I)	;NO LONGER ACTIVE AT P.I. LEVEL
	SETOM IMPOPI
	MOVN A,IMPNBT		;BITS SENT
	ADDM A,IMSC7I(I)	;DECREASE BITS IN BUFFER
	ADDB A,IMSOC7(I)	;DECREASE ALLOCATION
	SKIPL A			;SKIP IF ALLOC LOST
	SOSGE IMSOC8(I)		;SKIP IF MSG ALLOC DIDN'T LOSE
	 JRST 4,.		;LOST
	MOVE Q,IMSOC5(I)
	TLNN Q,140000		;INTERRUPT USER IF DIRECT CONNECT (CHEAP), DEPEND ON ALLOC,
	 SKIPN IMSMPC(I)	; OR IF OUTPUT BUFFER WAS FULL,
	  PUSHJ P,IMPUIN	; SINCE HE MAY WANT TO SEND MORE
	MOVE A,IMPNBO		;# BYTES FREED IN BUFFER BY REMOVAL OF MSG
	ADDM A,IMSMPC(I)	;SPACE USED BY MESSAGE NOW FREE
	MOVE A,IMPNPT		;UPDATE IMSPIP
	HRRZ Q,IMSOC6(I)	;VALIDATE THIS
	CAILE Q,(A)
	 JRST 4,.		;POINTS BEFORE BUFFER
	HRRZ Q,IMSBFE(I)
	CAIGE Q,(A)
	 JRST 4,.		;POINTS AFTER BUFFER
	MOVEM A,IMSPIP(I)	;..
	JRST IMPRET

;OUTPUT A DATA MESSAGE.

IMPOBD:	MOVE T,TIME
	SUB T,IMSOCT(I)
	SKIPL IMSOC4(I)	;SKIP IF WANT TO SEND THIS BUFFER
	 CAIL T,30.*2	;SKIP IF BUFFER FIRST WRITTEN LESS THAN 2 SEC AGO
	  JRST IMOBD1
	JRST IMPOBA	;DON'T SEND NOW, GO BACK AND LOOK FOR OTHERS

IMOBD1:	MOVE TT,IMSPIP(I)
	CAMN TT,IMSMPP(I)	;SKIP IF ANY BITS TO SEND
	 JRST IMPOBA		;NO
	SKIPE IMSOC7(I)		;SKIP IF NO BITS ALLOCATED
	 SKIPN IMSOC8(I)	;SKIP IF MSG ALLOCATED
	  JRST IMPOBA		;NO BITS OR NO MSGS ALLOWED
	MOVSI Q,200000
	IORB Q,IMSOC6(I)	;ACTIVE AT PI LEVEL

;CODE TO SEND OUT A BUFFER OR PARTIAL BUFFER
;ON ENTRY - I/ SOCKET TABLE INDEX
;	    Q/ BUFFER POINTER FROM IMSOC6
;	   TT/ BYTE POINTER TO FIRST BYTE TO SEND
;SETS UP  - T/ WORD SIZE (32 OR 36)
;	    E/ FLAGS FROM IMSOC5
;	    B/ BYTE SIZE
;	    C/ # BITS TO SEND

	SETZM IMPNBO
	MOVE T,IMSMPP(I)
	MOVEM T,IMOB0Z		;SAVE FOR DEBUGGING
	MOVEI T,32.
	SKIPL E,IMSOC5(I)	;SKIP IF IN 32BIT MODE
	 MOVEI T,36.		;SET 36BIT
	LDB B,IMSCBS		;BYTE SIZE
	HRRZ C,IMSMPP(I)	;COMPUTE # OF BYTES TO SEND
	SUBI C,(TT)
	JUMPL C,[MOVE D,IMSBFE(I) ;WRAPS AROUND
		 SUB D,Q
		 ADDI C,1(D)	;SO ADD # WDS IN BUFFER
		 JRST .+1]
	IMUL C,T		;FIRST GUESS AT NUMBER OF BITS
	LDB A,[360600,,TT]	;GETS POSITION FIELD OF BYTE PTR
	LDB D,[360600,,IMSMPP(I)]
	SUBM A,D		;CORRECTION TO NUMBER OF BITS
	ADD C,D			;C NOW HAS NUMBER OF SENDABLE BITS IN BUFFER
	SKIPL E			;SKIP IF 32BIT
	 JUMPN A,IMOB5A		;36BIT - JUMP IF NOT 0 (MIDDLE OF WORD)
	CAILE A,4		;32BIT - SKIP IF 4, OR 36BIT 0 - SKIP IF NOT MID-WORD
	 JRST IMOB5B		;32BIT MID-WORD - SEND PART OR REST OF WORD
	CAME TT,IMSBFE(I)	;AT RIGHT OF WORD, IS IT LAST WORD?
	 AOSA TT		;NO, ADVANCE TO NEXT
	  HRR TT,Q		;YES, WRAP AROUND TO FIRST	 
	TLO TT,440000		;SWITCH FROM RIGHT OF WORD TO LEFT OF WORD
	CAMG C,IMSOC7(I)	;SKIP IF TOO BIG FOR ALLOCATE
	 CAILE C,8000.		;FITS IN ALLOCATE, SKIP IF FITS IN IMP MESSAGE
	  JRST IMOB1		;MUST SEND LESS THAN ALL THE BITS IN BUFFER
IMOB0F:	MOVE D,IMSMPP(I)	;SENDING WHOLE BUFFER
	LDB J,[360600,,D]	;ADVANCE IMSMPP TO NEXT WORD BOUNDARY
	ADDI J,-36.(T)		;RH(J) := # BITS TO ADVANCE TO WORD BOUNDARY
	MOVNI J,(J)
	IDIV J,B
	ADDM J,IMSMPC(I)	;SUBTRACT FROM FREE THE BYTES SKIPPED OVER
	MOVNM J,IMPNBO		;BUT RETURN TO FREE AFTER TRANSMISSION
	HLL D,IMSBFE(I)		;NOW ADVANCE IMSMPP TO RIGHT END OF WORD
	MOVEM D,IMSMPP(I)	;AND IMSPIP WILL GET SET EQUAL TO IMSMPP
IMOB0A:	MOVEM D,IMPNPT		;ILDB -> FIRST BYTE TO SEND OUT NEXT TIME
	JUMPLE C,[JRST 4,.]	;SOMEBODY COMPUTED BAD # BITS
	MOVE A,C
	IDIV C,B		;C := # BYTES GETTING SENT
	JUMPN D,[JRST 4,.]	;LOSS, TRYING TO SEND PARTIAL BYTE
	ADDM C,IMPNBO		;# BYTES TO RETURN TO FREE AFTER MSG SENT
	MOVEM A,IMPNBT		;# BITS TO SUBTRACT FROM ALLOCATION THEN
;DROPS THROUGH
;DROPS IN
;NOW SET UP BUFFER HEADER FOR IMP MESSAGE IN IMOLDR
; TT -> FIRST WORD TO SEND
; A NUMBER OF BITS TO SEND
; C NUMBER OF BYTES
; B BYTE SIZE
; T WORD SIZE
; E FLAGS

	LDB H,IMSCFH		;HOST TABLE INDEX
	MOVEI Q,IMOLDR-2	;HACK HACK
	PUSHJ P,STHSTP		;STORE HOST NUMBER, MESSAGE TYPE 0
	LDB Q,IMSCLN		;LINK NUMBER
	DPB Q,[001000,,IMOLDR+1]
	LDB Q,[221000,,IMSOC6(I)] ;GET BUFFER TYPE
	MOVEI D,4
	CAIN Q,377
	 MOVEI D,7
	DPB D,[400400,,IMOLDR+1]	;STORE HANDLING TYPE, DEPENDING ON BUFFER SIZE
	DPB B,[201000,,C]	;STORE SIZE IN SAME WD AS COUNT
	LSH C,8
	MOVEM C,IMOLDR+5	;HOST-HOST HEADER - 00,SIZE,BYTE-COUNT,0000
IFE DMI,CONO IMP,IMO32C
IFN DMI,CONO FI,FIO32C		;36BIT MODE FOR HEADER, AND NO PIA YET
	DATAO IMP,IMOLDR	;OUTPUT THE FIRST LEADER WORD
	SETZM IMOPNT		;START AT BEGINNING OF IMOLST
	MOVE B,[-5,,IMOLDR]	;SEND REST OF LEADER
	MOVEM B,IMOLST
	MOVEI B,3
	SKIPGE E
	 MOVEI B,2
	MOVEM B,IMOMOD		;SEND DATA IN 32 OR 36 BIT MODE AS APPROPRIATE
	ADDI A,-1(T)		;ROUND UP IF NOT EXACT
	IDIV A,T		;# WDS TO SEND
	MOVEI D,-1(TT)		;FIRST WORD TO SEND MINUS ONE
	ADDI D,(A)		;LAST WORD TO SEND
	CAIG D,@IMSBFE(I)	;SKIP IF WRAP
	 JRST IMOB7
	HRRZ B,IMSBFE(I)	;COMPUTE # TO SEND FIRST TIME
	SUBI B,-1(TT)		;B GETS PLUS NUMBER TO SEND FIRST TIME
	SUBM B,A		;A GETS MINUS NUMBER TO SEND SECOND TIME
	MOVNI C,(B)
	HRLI C,-1(TT)		;C GETS SWAPPED BLKO POINTER FOR FIRST TIME
	MOVE Q,IMSOC6(I)	;POINTER TO BUFFER
IFE DMI,[
	MOVEI B,3		;SEND LAST WORD SEPARATELY
	MOVEM B,IMOBK2
	AOJE A,.+3
]	 HRLI A,-1(Q)		;BLKO POINTER FOR SECOND TIME	
	 MOVSM A,IMOBK2
IFE DMI,[
	MOVNI A,(A)
	ADDI A,-1(Q)
	HRROM A,IMOBK3		;STORE BLKO POINTER TO LAST WORD
]
	JRST IMOB8		

IMOB7:	MOVSI C,3		;NO WRAP, SO NO SECOND BLKO
	MOVSM C,IMOBK2
IFE DMI,[
	SOS D
	HRROM D,IMOBK3		;DO LAST WORD SEPARATELY
	SOJE A,IMOB8		;SPECIAL CASE LAST WORD IS ONLY WORD
]
	MOVNI C,(A)		;MAKE BLKO POINTER
	HRLI C,-1(TT)
IMOB8:	MOVSM C,IMOBK1
	MOVSI TT,400000		;TURN OFF "SEND ME"
	ANDCAM TT,IMSOC4(I)
	HRRZM I,IMPOPI		;SAVE INDEX FOR BLKO RUNOUT
	AOS IMPMSS+0
	MOVEI C,IMPDLW		;STATE FOR "END OF DATA"
	JRST IMOB9

;BUFFER CANNOT BE SENT AS 1 MSG.  GRT ALLOC OR 8000 BITS.

IMOB1:	MOVE C,IMSOC7(I)	;ALLOC
	CAILE C,8000.
	 MOVEI C,8000.		;C := MIN(BITS IN BUFFER, ALLOC, MAX IMP MSG SIZE)
	TLNE E,2000		;SKIP IF BYTES EXACTLY FIT IN WORD
	 JRST IMOB3		;MUST SEND MULTI WORDS
	CAMGE C,T		;SKIP IF ALLOC GEQ WDSIZ
	 JRST IMOB2		;MUST SEND PART WORD
	IDIV C,T		;#WDS
	MOVE D,C
	IMUL C,T		;#BITS IN THOSE WDS
IMOB1A:	ADDI D,-1(TT)		;LAST WORD OUTPUT
	CAIG D,@IMSBFE(I)
	 JRST .+3
	  SUBI D,@IMSBFE(I)	;WRAP AROUND
	  ADDI D,-1(Q)
	HLL D,IMSBFE(I)		;PUT IN BYTE PART (RIGHT END OF WORD)
	JRST IMOB0A		;BUILD HEADER AND OUTPUT

;SEND PART OF WORD BECAUSE ALLOC IS TOO SMALL

IMOB2:	MOVE D,TT		;-> FIRST BYTE TO BE SENT
	MOVNI A,-36.(C)		;36-BITS SENT
	DPB A,[360600,,D]	;IS NEXT BYTE TO GO
	JRST IMOB0A

;SEND PARTIAL BUFFER OF BYTES WHICH DO NOT FIT EXACTLY IN WORDS (E.G. 7BIT BYTES)
;MUST SEND A "QUANTUM" WHICH FOR LAZINESS' SAKE IS 36 BYTES

IMOB3:	MOVEI A,36.		;#BITS IN A WORD
	IMUL A,B		;#BITS IN A QUANTUM
	IDIV C,A		;# QUANTA
	JUMPE C,IMOB4		;NOT ENOUGH ALLOC FOR EVEN 1 QUANTUM, SORRY CHARLIE
	MOVE D,C
	IMUL C,A		;#BITS TO SEND
	IMUL D,B		;#WDS TO SEND (36 BYTES TAKE <BYTESIZE> WDS)
	JRST IMOB1A

;NEED MORE ALLOCATE TO SEND A BUFFER FOR THIS ODD-SIZE CONNECTION

IMOB4:	MOVSI T,200000
	ANDCAM T,IMSOC6(I)	;CLEAR "ACTIVE AT PI LEVEL" BIT
	JRST IMPOBA		;MAYBE TRY ANOTHER ONE

;SENDING REST OF PARTIAL WORD (PI PTR NOT AT WORD BOUNDARY)
;A/ BITS LEFT IN WORD

IMOB5A:	SKIPA C,A		;36BIT GETS WHOLE WD
IMOB5B:	 HRREI C,-4(A)		;32BIT GETS 4 LESS
	MOVNI J,-36.(A)		;# BITS SHIFT TO LEFT JUSTIFY
	HRRZ D,TT
	CAIN D,@IMSMPP(I)	;IF WHOLE REST OF BUFFER IS IN THIS WORD
	 JRST [	LDB D,[360600,,IMSMPP(I)]
		SUB A,D		;A := NUMBER OF BITS TO SEND
		MOVE C,(TT)	;ALIGN BITS TO BE SENT IN LEFT OF WORD
		LSH C,(J)
		MOVEM C,(TT)
		MOVE C,A
		JRST IMOB0F ]	;RE-ALIGN POINTERS TO WORD BOUNDARY
	CAMLE C,IMSOC7(I)	;SKIP IF WILL FIT IN ALLOC
	 JRST IMOB6		;MUST SEND BYTES NOT LEFT JUST IN WD, AND MORE TO RIGHT
	MOVE D,(TT)		;GET WORD
	LSH D,(J)		;LEFT JUSTIFY
	MOVEM D,(TT)
	MOVE D,TT
	HLL D,IMSBFE(I)		;ADVANCE PI POINTER TO END OF THIS WORD
	JRST IMOB0A		;BUILD HDR & SEND

;SEND MIDDLE PART OF WORD. BECAUSE OF SMALL ALLOCATES, THE LEFT END OF THE
;   WORD WAS SENT AND ALSO THERE IS NOT ENOUGH ALLOCATE TO SEND THE REST
;   OF THE ONE WORD.  THIS MIGHT NEVER OCCUR EXCEPT FOR 8 BIT BYTES.
;MUST MOVE GOOD BITS TO LEFT END OF WORD, WITHOUT DISTURBING BITS TO THE RIGHT

IMOB6:	MOVE C,IMSOC7(I)	;CAN ONLY SEND ALLOC BITS
	SUB A,C			;POS OF LO BIT TO PICK UP
	DPB A,[360600,,TT]	;POS IN BYTE PTR
	MOVE D,TT		;SAVE ADVANCED PI PNTR
	DPB C,[300600,,TT]	;STORE AS SIZE OF BYTE
	LDB R,TT		;GET BYTE
	MOVNI A,-36.(C)		;POS OF LO BIT TO STORE
	DPB A,[360600,,TT]	;POS IN B PTR
	DPB R,TT		;STORE BYTE AWAY
	JRST IMOB0A		;SEND THE BYTE(S)

OVHMTR UUO	;YET MORE RANDOM UUOS
