
.SYMTAB 10001.
TITLE ITS

.NSTGWD		.SEE PATB	;NO STORAGE WORDS ALLOWED UNTIL PATB

IF1 [ PRINTX \MACHINE NAME = \
;WELL-KNOWN MACHINE NAMES ARE:
;	AI	AI LAB KA10
;	ML	MATHLAB KA10
;	DM	DYNAMIC MODELING KA10
;	MC	MACSYMA CONSORTIUM KL10
;THE FILE "CONFIG" HAS ASSEMBLY SWITCHES AS A FUNCTION OF MACHINE.
DEFINE MCHNIRP A,B	;IRP OVER ALL KNOWN MACHINES.
IRPS A,,AI ML DM MC
B
TERMIN TERMIN

.TTYMAC A
DEFINE MCOND X		;0 IFF THIS IS MACHINE X.
<IFSN X,A,[1]>,TERMIN
DEFINE MNAME X		;USED TO SUBSTITUTE IN THIS MACHINE'S NAME.
X!!A!!TERMIN
FOO==.TTYFLG		;MAKE ERR FILE LOOK NICE
.TTYFLG==1
PRINTX/A
/
.TTYFLG==FOO
TERMIN  ]
AI==IFE MCOND AI,1	;MAKE OLD CONDITIONALS WORK.

OQDTSW==1	;NON ZERO => STORE OLD STYLE DATE ON DSK (EVENTUALLY FLUSH)
IFNDEF PCLSW,PCLSW==1		;1 => ASSEMBLE PCLSR TEST FEATURE
IFNDEF TT11BY,TT11BY==20	;PDP11-TV OUTPUT BUFFER BYTE SIZE.
.MLLIT==1	;MULTI-LINE LITERAL MODE

;AC DEFS

A=1
B=2
C=3
D=4
E=5
TT=6
I=7
Q=10
J=11
R=12
W=13
H=14
P=15	;DO NOT CHANGE!	;PDL POINTER
T=16	;"
U=17	;"		;USER INDEX

.XCREF A,B,C,D,E,TT,I,Q,J,R,W,H,P,T,U

IF1 EXPUNGE APR,OCT,DEC	;FOR NEW CALENDAR HACK

NULBLK==4	;NUMBER OF LOCKED SWITCH BLKS IN USR VARIABLES
		;USES 2 WDS OF USER VAR PER

NPVSEC==30.	;NUMBER OF SECONDS A USER IS ALLOWED TO BE IN THE PRIVILEDGED SWAPPING CLASS
IF2 LIOBLK==1+<USRSTG+LUBLK*MAXJ>_-10.	;LOWEST BLOCK NEVER TO BE SHUFFLED
			;ALSO MAX # OF BLOCKS SYS JOB MAY HAVE

NIOCHN==20	;NUMBER OF I/O CHANNELS PER USER

DEFINE SUBTTL X/
TERMIN		;WINNING @ SUBTITLES
SUBTTL DEFINITIONS

DEFINE $FNAME FOO	;PRINTX A FILE NAME GIVEN NUMERIC SIXBIT
ZZX==<FOO>
REPEAT 6,[
IRPNC ZZX_-36,1,1,Q,,[ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ(\)^_]
IFSN [Q][ ]	PRINTX |Q|
TERMIN
ZZX==ZZX_6
]
TERMIN

DEFINE $INSRT $%$%$%	;PRINTX MESSAGE WHEN FILE GETS INSERTED
	.INSRT $%$%$% >
	PRINTX \    ==> INSERTED:  \
	$FNAME .IFNM1
	PRINTX \ \
	$FNAME .IFNM2
PRINTX \
\
TERMIN

$INSRT BITS		;DEFINITIONS OF MANY BIT NAMES

;IN BADBTS => CLASS 2 OR 1 INTERRUPT   ;IN VBDBTS=> CLASS 1 INTERRUPT
VBDBTS==%PIB42\%PIVAL\%PIBRK\%PIC.Z\%PI1PR\%PITRP
BADBTS==VBDBTS\%PIMPV\%PIIOC\%PIILO\%PIMAR\%PIDIS\%PIOOB\%PIRSR\%PIFET\%PIWRO\%PIPAR\%PITTY

UUOMIN==40000,,	;SMALLEST NUM THAT COULD BE A SYSTEM CALL
UUOMAX==50000,,	;ONE GREATER THAN LARGEST NUM "
UIOT=UUOMAX	;USE FOR USER I/O INST TRAP
ITSVRS==.FNAM2
IF1,[ASMDAT==.OP <.OPER@> 0,.RDATE
ASMTIM==.OP <.OPER@> 0,.RTIME
]

	;MAX DYN ALLOC ALLOC IO BUFFERS
MXIOB==100	;MAX POSSIBLE

SIOMT==30	;MAX SIZE TRANSLATION TABLE

LUPDL==50	;LENGTH USER PDL MUST BE >= 40 FOR 2311 GC
LUIOP==20	;LENGTH OF USER IO PDL
CPDLL==40	;LENGTH CLOCK CHANNEL PDL
LUTCP==20	;LENGTH UTC PDL
LSYSP==40	;SYSTEM JOB PDL
LTTYP==40	;LENGTH OF TTY (INTERRUPT LEVEL) PDL

DMNSZ==5	;# ENTRIES IN DEMON BUFFER (DMNBF)

MXCZS==5	;MAX NUMBER ^Z'S PER CLOCK BREAK

SCLKI==30.	;60'THS PER SLOW CLOCK
VSCLKI==2*60.*60.	;60'THS PER VERY SLOW CLOCK TICK
MXOPT==8.	;SLOW CLOCK  MAX UT OP CAN TAKE
NINFP==8.	.SEE UFIN	;MAX # OF DIRECT INFERIORS A PROCEDURE MAY HAVE

SSCHDB==100	;LENGTH OF SCHEDULER HISTORY BUFFER

$INSRT CONFIG		;CONFIGURATION SWITCHES FOR ALL KNOWN MACHINES

IFN XGP\N11TYS,[IFE TEN11P,[
	.ERR XGP OR N11TYS WITHOUT TEN11P
	N11TYS==0
	XGP==0
]
]
IFNDEF UNSPLP,UNSPLP==<TTLPTP+OLPTP+NLPTP>*DEMON*<1-TPLP>
	;1 IF THE "UNSPOO" PROGRAM DOES LPT SPOOLING.

IFNDEF TSYSM,[
MNAME PRINTX \NO PARAMS KNOWN FOR , MACHINE.
\
.INSRT TTY:
]

IF2,[
;TTY LINES DEFINITIONS

;MACRO WHICH RETURNS THE %TY BIT FOR THE CONTROLLER ACCORDING TO THE LINE NUMBER

DEFINE CNTRLR N
IRPS F,,[0	NFETY	NFNTY	NFNVTY	NFDPTY	NFMTY	NFDLTY	NFSTTY	NF11TY
   ]NT,,[NOTYS	NETYS	NNTYS	NNVTTS	NDPTYS	NMTYS	NDLTYS	NSTTYS	N11TYS
   ]FG,,[%TYOTY	%TYETY	%TYNTY	%TYNVA	%TYDPK	%TYMTY	%TYDL	%TYSTY	%TY11T]
 IFGE <N>-F,[IFL <N>-<F+NT>,[FG]]TERMIN TERMIN

;MACRO WHICH RETURNS $TTISP, $TTOSP BITS GIVEN BAUD RATES

DEFINE SPEED IBAUD,IDFLT,OBAUD,ODFLT
<IFB IBAUD,[SPEED1 IDFLT,] IFNB IBAUD,[SPEED1 IBAUD,]>*8+<IFB OBAUD,[IFNB IBAUD,[SPEED1 IBAUD,] IFB IBAUD,[SPEED1 ODFLT,]] IFNB OBAUD,[SPEED1 OBAUD,]>TERMIN

DEFINE SPEED1 BAUD
IRPS BD,,[134 600 110 150 300 1200 2400 4800 9600 25K 50K
    ]CD,,[0   1   2   3   4   5    6    7    7    7   7]
IFSE BAUD,BD,[CD] TERMIN TERMIN

;DEFINE TTY N AS PRINTING, SPEC'D SPEED, TTYTYP LH, TTYTYP RH.
;IF SPEED IS 2 (10CPS), ASSUME TTY IS TELETYPE,
;MEANING CAN'T BS, STANDARDIZE ALTMODES.
;IF KA10 CONSOLE TTY OR TK10 TTY, NEED PARITY
DEFINE TTDPRT N,IBAUD,OBAUD,TT,TY
T!N!$HOR==72.+IFE 300-IBAUD,8
T!N!$VER==MOVE
T!N!$OPT==%TOOVR+%TOALT+IFN 110-IBAUD,[%TOMVB-%TOALT+IFN TY&%TYDIL,[%TORAW]],,<1+IFE IBAUD-300,[IFE TY&%TYDIL,[3]]>*%TPPCR+%TPORS
T!N!$TYP==TT\<SPEED IBAUD,110,OBAUD,110,>\<IFE N,[IFN NOTYS,[%TTPAR]]>\<IFGE N-NFNTY,[IFL N-<NFNTY+NNTYS>,[%TTPAR]]>,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS MEMOREX, SPEC ONLY TTYTYP LH AND RH.
DEFINE TTDMRX N,TT,TY
T!N!$HOR==120.
T!N!$VER==MOVE
T!N!$OPT==%TOOVR+%TOMVB+%TOLWR,,1*%TPPLF+6*%TPPCR+%TPORS
T!N!$TYP==TT+11,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS TERMINET.
;SPEC INPUT SPEED (OSPEED ALWAYS 1200), TTYTYP LH AND RH.
DEFINE TTDTRM N,IBAUD,OBAUD,TT,TY
T!N!$HOR==120.
T!N!$VER==MOVE
T!N!$OPT==%TOOVR+%TOMVB+%TOLWR,,5*%TPPLF
T!N!$TYP==TT+<SPEED IBAUD,1200,OBAUD,1200,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNTRM
TERMIN

;DEFINE TTY AS A LPT. SPEC ONLY TTYTYP LH AND RH.
DEFINE TTDLPT N,TT,TY
T!N!$HOR==200.
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR,,
T!N!$TYP==%TTDDI+TT,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS A DIABLO (SIPB HAS ONE)
DEFINE TTDSIPB N,IBAUD,OBAUD,TT,TY
T!N!$HOR==131.
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR+%TOLWR,,%TPORS
T!N!$TYP==TT+<SPEED IBAUD,300,OBAUD,300,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS AN LA36 DECWRITER
DEFINE TTDLA36 N,TT,TY
T!N!$HOR==110.		;ASSUME NARROWEST PAPER
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR+%TOLWR,,%TPORS
T!N!$TYP==TT+44,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS ARDS. SPEC ONLY TTYTYP LH AND RH.
DEFINE TTDARD N,IBAUD,OBAUD,TT,TY
T!N!$HOR==81.
T!N!$VER==52.
T!N!$OPT==%TOOVR+%TOLWR+%TOMVU+%TOMVB+%TOALT,,
T!N!$TYP==TT+<SPEED IBAUD,1200,OBAUD,50K,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNARD
TERMIN

;DEFINE TTY AS HORIZONAL ARDS
DEFINE TTDARH N,IBAUD,OBAUD,TT,TY
T!N!$HOR==104.
T!N!$VER==40.
T!N!$OPT==%TOOVR+%TOLWR+%TOMVU+%TOMVB+%TOALT,,
T!N!$TYP==TT+<SPEED IBAUD,1200,OBAUD,50K,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNARH
TERMIN

;DEFINE TTY AS IMLAC. SPEC ISPEED, TTYTYP LH, TTYTYP RH.
DEFINE TTDIML N,IBAUD,OBAUD,VERT,TT,TY
T!N!$HOR==89.
T!N!$VER==VERT+IFB VERT,44.
T!N!$OPT==%TOOVR+%TOLWR+%TOMVB+%TOMVU+%TOERS+%TOIML,,
T!N!$TYP==%TTDDI+TT+<SPEED IBAUD,25K,OBAUD,50K,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNIML
TERMIN

;DEFINE TTY AS TEKTRONIX.  SPEC SPEED,TTYTYP LH,TTYTYP RH
DEFINE TTDTEK N,IBAUD,OBAUD,TT,TY
T!N!$HOR==73.
T!N!$VER==34.
T!N!$OPT==%TOOVR+%TOMVB+%TOLWR,,%TPORS
T!N!$TYP==TT+<SPEED IBAUD,1200,OBAUD,1200,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE TTY AS A LOSING DATAPOINT
DEFINE TTDLSR N,TT,TY
T!N!$TCT==%TNODP
T!N!$HOR==71.-IFE MCOND ML,1	;ML DATAPOINTS HAVE SHORTER SCREENS.
T!N!$VER==25.
T!N!$OPT==%TOMVB+%TOMVU+%TOERS,,4*%TPPCR+%TPORS
T!N!$TYP==TT+66,,TY+<CNTRLR N,>
TERMIN

;DEFINE TTY AS DATAPOINT.
DEFINE TTDDPT N,TT,TY
T!N!$TCT==%TNDP
T!N!$HOR==72.-IFE MCOND ML,1	;ML DATAPOINTS HAVE SHORTER SCREENS.
T!N!$VER==25.
T!N!$OPT==%TOMVB+%TOMVU+%TOERS,,4*%TPPCR+%TPORS
T!N!$TYP==TT+66,,TY+<CNTRLR N,>
TERMIN

;DEFINE A TTY THAT IS A GT40.
DEFINE TTDGT40 N,IBAUD,OBAUD,VERT,TT,TY
T!N!$HOR==72.
T!N!$VER==VERT+IFB VERT,40
T!N!$OPT==%TOMVB+%TOERS+%TOMVU+%TOOVR+%TOLWR,,%TPORS
T!N!$TYP==TT+<SPEED IBAUD,4800,OBAUD,4800,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNDP
TERMIN

;DEFINE A TTY THAT IS A LINE TO A PDP11.
DEFINE TTD11 N,IBAUD,OBAUD,TT,TY
T!N!$HOR==72.
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR+%TOALT,,
T!N!$TYP==TT+%TTDDI+<SPEED IBAUD,4800,OBAUD,4800,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE A PDP11 TV COMMUNICATING VIA THE DATAPOINT CONTROLLER.
DEFINE TTDTMP N,IBAUD,OBAUD,TT,TY
T!N!$HOR==82.
T!N!$VER==45
T!N!$OPT==%TOMVB+%TOMVU+%TOERS+%TOSAI+%TOLWR,,
T!N!$TYP==TT+%TTDDI+<SPEED IBAUD,4800,OBAUD,4800,>,,TY+<CNTRLR N,>
T!N!$TCT==%TNDP
TERMIN

;DEFINE A PDP11 TV COMMUNICATING VIA TEN-11 INTERFACE.
DEFINE TTDTV N,TT,TY
T!N!$HOR==96.
T!N!$VER==45
T!N!$OPT==%TOMVB+%TOMVU+%TOERS+%TOSAI+%TOLWR+%TOOVR+%TOFCI,,%TP11T
T!N!$TYP==TT+%TTLCL+77,,TY+%TY11T
T!N!$TCT==%TNTV
TERMIN

;DEFINE A TTY THAT IS A 2741 OR SIMILAR.
;THE "CODE" ARG SHOULD BE 1 IFF TTY USES CORRESPONDENCE CODE.
DEFINE TTD2741 N,CODE,TT,TY
IFL N-NF2741,.ERR NF2741 OR N2741 IS WRONG?
IFGE N-NF2741-N2741,.ERR NF2741 OR N2741 IS WRONG?
T!N!$HOR==120.
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR+%TOLWR+%TOHDX,,5*%TPPCR+1*%TPPLF+%TPORS+%TPIBM+%TPIBC*CODE
T!N!$TYP==TT+%TTIBM+%TTDDI,,TY+<CNTRLR N,>
T!N!$TCT==%TNPRT
TERMIN

;DEFINE AN STY LINE
DEFINE TTDSTY N
T!N!$HOR==81.
T!N!$VER==MOVE
T!N!$OPT==%TOMVB+%TOOVR+%TOLWR+%TORAW,,%TPORS
T!N!$TYP==%TYSTY
T!N!$TCT==%TNPRT
TERMIN

DEFINE MCONDX MCHN
IFE MCOND MCHN,TERMIN

;;; THE NEXT TWO MACROS CAUSE FILES INSERTED BY BOTH
;;; PDP-10 AND PDP-11 PROGRAMS TO WIN.

DEFINE .ENDC
TERMIN

DEFINE .ENDR
TERMIN

	.CRFOFF
$INSRT TTYTYP
	.CRFON
EXPUNGE TTDPRT,TTDTRM,TTDDPT,TTDMRX,TTDGT40,TTD11,TTDTMP
EXPUNGE TTDTV,TTD2741,TTDSTY,TTDLPT,TTDIML,TTDARD,TTDSIPB,TTDARH
EXPUNGE SPEED,SPEED1,CNTRLR,MCONDX,.ENDC,.ENDR
]		;END OF IF2

LPTP==OLPTP+NLPTP+GLPTP
IFE TM10A,TM10B==1	;DATA CHANNEL MAG TAPE
IFN TM10A,TM10B==0
IFN TABP,	TABCLK==0	;1=>PUT TABLET ON CLOCK CHNL

;PRIORITY INTERRUPT CHANNEL ASSIGNMENTS
	DCCHN==1	;DC CHANNEL
	DCLOC=40+2*DCCHN	;DC INTERRUPT LOCATION
IFN NETP,[
	IMPCHN==1	;IMP STUFF
	NETCHN==2	;SOFTWARE ACTIVATED...
]
	UTCCHN==2	;UTC CHANNEL
	DSKCHN==UTCCHN	;2314 CHANNEL
IFN NMTCS,	MTCCHN==UTCCHN	;MAG TAPE CONTROL CHANNEL
IFN LPTP,	LPTCHN==4	;LINE PRINTER CHANNEL
		TTYCHN==3	;TTY CHANNEL
IFN PLTP,	PLTCHN==4	;PLOTTER CHANNEL
		PCHCHN==4	;PTP CHANNEL
		PTRCHN==4	;PAPER TAPE READER CHANNEL
IFN 340P,	SDCHN==4	;DISPLAY SPECIAL CHANNEL
IFN DSDP,	DSDCHN==4	;INTERRUPT FROM OTHER PROCESSOR
IFN ARMP,	TIPBCH==5	;ARM TIP BREAK CHNL
IFN OMXP,	OMPCHN==5	;OUTPUT MULTIPLEXOR
IFN VIDP,	NVDCHN==5	;NEW VIDI
IFN TABP,	IFE TABCLK,	TABCHN==5	;TABLET
IFN 340P\E.SP,	DISCHN==6	;DISPLAY DATA CHNL
IFN TABP,	IFN TABCLK,	TABCHN==7	;TABLET
		APRCHN==7	;DO NOT CHANGE

		PICOFF==1200	;TURN OFF PI CHANNEL
		PICON==2200	;TURN ON PI CHANNEL
		PICIRQ==4200	;REQUEST INTERRUPT ON PI CHANNEL
		CLKON==2201	;ABSOLUTE
		CLKOFF==1201
IFN OMXP,	OMXON==CLKON\<400_-OMPCHN-1>
IFN OMXP,	OMXOFF==CLKOFF\<400_-OMPCHN-1>
IFN LPTP,	LPTON==CLKON\<400_-LPTCHN-1>
IFN LPTP,	LPTOFF==CLKOFF\<400_-LPTCHN-1>
		PTPON==CLKON\<400_-PCHCHN-1>
		PTROFF==CLKOFF\<400_-PCHCHN-1>
		PTRON==CLKON\<400_-PTRCHN-1>
		PTROFF==CLKOFF\<400_-PTRCHN-1>
		TTYON==CLKON\<400_-TTYCHN-1>
		TTYOFF==CLKOFF\<400_-TTYCHN-1>
		UTCON==CLKON\<400_-UTCCHN-1>
		UTCOFF==CLKOFF\<400_-UTCCHN-1>
IFN NETP,[
		NETON==UTCON
		NETOFF==UTCOFF
]
IFN KL10P,[
	DTEON==CLKON
	DTEOFF==CLKOFF
]
	DSKRQ==PICIRQ\PICON\<200_-DSKCHN>	;RQ INT + TURN ON FOR SAKE OF KL
	MTCRQ==PICIRQ\PICON\<200_-MTCCHN>
	UTCRQ==PICIRQ\PICON\<200_-UTCCHN>
	TTYRQ==PICIRQ\PICON\<200_-TTYCHN>
	CLKRQ==PICIRQ\PICON\<200_-APRCHN>
IFN TABP,[
IFN TABCLK,[
TABON==CLKON
TABOFF==CLKOFF
]
IFE TABCLK,[
TABON==CLKON\<400_-TABCHN-1>
TABOFF==CLKOFF\<400_-TABCHN-1>
]
]

IFN NUNITS, IFE NEWDTP, CUINT==5000+UTCCHN	;CONO TO UTC TO ACTIVATE UTAPE INTERRUPT

PMLCAD==(.BP <PMRCM,,>)	;BYTE POINTER TO L.H. REAL CORE ADR
PMRCAD==(.BP PMRCM)		;BYTE POINTER TO R.H. REAL CORE ADR

;DEVICE CODES
IFN STKP,	STK==70		;STANFORD KEYBOARD
IFN OLPTP,	OLPT==124	;LINE PRINTER
IFN NLPTP,	NLPT==464
IFN NMTCS,	MTC==340	;MAG TAPE CONTROL
IFN NMTCS,	MTS==344	;MAG TAPE STATUS
IFN VIDP,	NVDX==620	;NEW VIDI X
IFN VIDP,	NVDY==624	;NEW VIDI Y
IFN VIDP,	NVDT==630	;NEW VIDI T (DEFLECTION DELAY)
IFN PLTP,	PLT==654	;CAL COMP PLOTTER
IFN HCLKP,	CLK1==710	;HOLLOWAY CLOCK
IFN HCLKP,	CLK2==714	; "
IFN IMXP,	MPX==574	;INPUT MULTIPLEXOR
IFN OMXP,	OMPX==570	;OUTPUT MULTIPLEXOR
IFN TK10P,	NTY==600	;KNIGHT TTY KLUDGE
IFN MTYP,	MTY==400
IFN NDLTYS,	DLB==60		;DL10 BASE
.ALSO		DLC==64		;DL10 CONTROL
IFN PDCLKP,	PDCLK==500	;DE-CORIOLIS CLOCK (FOR ML AND DM, CALENDAR CLOCK)
IFN DSDP,	DSDEV==20	;DE SELECTION AND INTER COM DEVICE
IFN DSDP,	DSDEVN==24	;DE SELECTION DEV (FOR DEVICES YOU DATAO DEV CODE TO DSDEVN)
IFN ARMP,	TIPDEV==504	;TIP BREAK DEVICE
IFN RBTCP,	RBTCON==514	;ROBOT CONSOLE
IFN DPKPP,	DPK==604	;DATA POINT KLUDGE
IFN DC10P,	DC0==610	;2314 DISK CONTROL
IFN DC10P,	DC1==614	;2314 DISK CONTROL
IFN RP10P,	DPC==250	;RP10 DISK CONTROL
IFN RH10P,	DSK==270	;RH10 DISK CONTROL
IFN NETP,[
	IFE DMI,IMP==460	;NET INTERFACE
	IFN DMI,FI==424		;DM NET HARDWARE
]
IFN NUNITS,[
IFN NEWDTP,[
	DTC==320
	DTS==324
]		;END OF IFN NEWDTP
]		;END OF IFN NUNITS

IFN NETP,[
	IFE MCOND AI,IMPUS==206	;HOST # THIS MACHINE.
	IFE MCOND ML,IMPUS==306
	IFE MCOND DM,IMPUS==106
	IFE MCOND MC,IMPUS==154
]

IFN DSDP,	IFN VIDP,	DSNVID==200000,,	;DEASSIGN BIT FOR NVD
IFN DSDP,	IFN 340P,	DSNDIS==4000,,	;DEASSIGN BIT FOR DIS
IFN DSDP,	IFN NMTCS,	DSMTC==1,,	;DEASSIGN BIT FOR MAG TAPE

IFN RBTCP,	RLTSWC==17	;ROBOT CONSOLE SELECT FOR LIGHTS AND SWITCHES
IFN RBTCP,	IFN TABP,	RTABC==16	;ROBOT CONSOLE SELECT FOR TABLET

IFN IMXP,	LCHN==177	;MULTIPLEXOR LIMIT ON READ IN

;IOBFT CHANNEL NUMBERS
IFN NUNITS,	NUTIC==8	;NUMBER UT IN CHNLS
.ELSE		NUTIC==0
IFN NUNITS,	NUTOC==8	;NUMBER UT OUT CHNLS
.ELSE		NUTOC==0
		NFCLC==NUTIC+NUTOC+1	;# OF FIRST CORE LINK CHNL
		NCLCH==14	;NUMBER CORE LINK CHNLS
		NFNETC==NFCLC+NCLCH	;# OF FIRST NET CHNL
IFN NETP,	NNETCH==20.+IFE MCOND MC,28.	;# NET CHNLS (EXTRA ON MC)
IFE NETP,	NNETCH==0	;SO WILL BE DEFINED
				;77 MEANS "FREE"
IFG NFNETC-NNETCH-76, .ERR TOO MANY IOBFT CHANNELS

		NUDCH==14	;NUMBER DIRECTORY CHNLS
IFN IMXP,	NPOTCH==20.	;NUMBER POT CHANNELS
		NQCHN==30.	;NUMBER 2314 CHNLS
IFG NQCHN+1+NQS-77, .ERR MORE THAN 6 BITS OF DISK CHANNEL NUMBER

IFN CODP,	CODBFL==5	;CODE BUFFER
		PUNSIZ==20	;PTP BUF SIZ
		REDSIZ==200	;PTR BUF SIZ
IFN PLTP,	LPLBUF==200	;PLT BUF SIZ
IFN LPTP,	LPTBSZ==1000	;LPT BUF SIZ
IFN VIDP,	NVDLNG==340	;NVD BUF SIZE
IFN TPLP,	TPLBSZ==100	;TPL BUFFER SIZE IN SYS JOB
IFN TABP,	LTABBF==100	;TABLET BUFFER
IFN N11TYS,	TT11CR==764044	;UNIBUS ADR OF TV11 CONSOLE REG

EOFCH==3	;SYSTEM END OF FILE CHR
EOFWRD=REPEAT 5,[EOFCH_<.RPCNT*7+1>\]0	;WORD OF EOFCH'S

IFN 340P,	DVEF==4000	;DISPLAY VERTICAL EDGE FLAG
IFN 340P,	DHEF==1000	;DISPLAY HOR EDGE FLAG

IFN 340P,	EWRT==400./12.	;EQIV "COST" IN DISPLAY WRDS FOR TRIP THRU RECYC
IFN 340P,	MDISWD=70000	;MAX # WDS SENT TO SCOPE IN 1/2 SEC

NSWPV==E.SP\340P+VIDP+IMXP	;# OF DEVICES THAT CAN SWAPIN PAGES

IFN C1MXP,[
IFN NMTCS,	MAGLOC==76	;INTERRUPT LOCS FOR MAGTAPE
		DCMLOC==74	;"      "    FOR DC
		IMXLC==66	;"     "   IMX
IFN NETP,[
		IMPILC==70	;INPUT FROM IMP
		IMPOLC==72	;OUTPUT TO IMP
]
]

IFE C1MXP,[
IFN NMTCS,	MAGLOC==42
		DCMLOC==42
]

;DEFINE PAGING BOX INSTRUCTIONS & c.

IFE KL10P,[
LPM=102000,,	;LOAD PG MEM STATE VECTOR DONT CLR ASSOC MEM
LPMR= LPM 2,	;CLEAR ASSOC MEM AND LOAD
SPM= LPM 1,	;STORE PG MEM STATE VECTOR
LPMRI=LPM 6,	;LOAD PM, CLEAR ASSOC REG, AND CAUSE INTERRUPT
EXPGNG==4	.SEE UPQUAN	;4 TO TURN ON EXEC PAGING
XCTR=103000,,	;VIOLATION CAUSES USER MEM PROTECT INTERRUPT UNLESS INHIBITED
		;VIOLATION ALSO SKIPS BUT THIS IS OF NO CONSEQUENCE UNLESS
		;INTERRUPT IS INHIBITED SINCE PC WILL BE RESET FROM OPC
XCTRI= XCTR 4,	;XCTR WITH PAGE FAULT INHIBITED (SKIPS ON FAULT)
		; AC FIELD VALUES FOR XCTR AND XCTRI
	XR==1	;MAP READ MAIN OPERAND OF SIMPLE INSTRUCTION (MOVE, SKIPL, HLL)
	XW==2	;MAP WRITE MAIN OPERAND OF SIMPLE INSTRUCTION (MOVEM)
	XRW==3	;MAP READ/WRITE OPERAND OF SIMPLE INSTRUCTION (E.G. IORM)
	XBYTE==3;MAP BYTE DATA AND BYTE POINTER (ILDB, IDPB)
	XBR==1	;MAP BLT READ
	XBW==2	;MAP BLT WRITE
	XBRW==3	;MAP BOTH OPERANDS OF BLT
		;KA10 PAGING BOX GOES BY WHETHER IT'S A READ OR WRITE (OR RW) CYCLE
		;KL10 PAGING BOX WORKS DIFFERENTLY (SEE BELOW)
		;DO NOT USE MULTI-OPERAND INSTRUCTIONS (DMOVE, PUSH, ETC.) WITH XCTR

DEFINE CLRPGM U	;CLEAR PAGER ASSOCIATIVE MEMORY.  ARG IS USUALLY "(U)".
 SPM UPGML!U	;STORE SO DON'T LOSE QUANTUM TIMER
 LPMR UPGML!U
TERMIN

PI0LOC==40	;INTERRUPT VECTOR BASE

DEFINE UUOH	;UUO HANDLER LOCATIONMS ARE REFERENCED THROUGH THESE MACROS
XUUOH!TERMIN

DEFINE FORTY
40!TERMIN
]		;END OF IFE KL10P

IFN KL10P,[
XCTR=074000,,	;EXECUTE INSTRUCTION WITH MAPPING, PAGE FAILS ENABLED
XCTRI=075000,,	;SAME BUT SKIPS IF THERE IS PAGE FAIL (DONE SNEAKILY BY SOFTWARE)
LPMR=076000,,	;LOAD PAGER MEMORY (JPC, DBRS) AND CLEAR PT DIR
SPM=077000,,	;STORE PAGER MEMORY
		;AC FIELD VALUES FOR XCTR AND XCTRI
	XR==4	;MAP MAIN OPERAND OF SIMPLE INSTRUCTION (FOR READING)
	XW==4	;MAP MAIN OPERAND OF SIMPLE INSTRUCTION (FOR WRITING)
	XRW==4	;MAP MAIN OPERAND OF SIMPLE INSTRUCTION (FOR READING AND WRITING)
	XBYTE==5;MAP BYTE DATA AND BYTE POINTER
	XBR==1	;MAP BLT SOURCE
	XBW==4	;MAP BLT DESTINATION
	XBRW==5	;MAP BOTH BLT OPERANDS
		;IN KL10 BITS ARE:  10 @ AND XR IN PREV CONTEXT
		;		     4 MAIN OPERAND "  "  " ALSO BYTE WRITE
		;		     2 @ AND XR IN BYTE PTRS
		;		     1 2ND OPND - BLT SOURCE, BYTE READ, STACK DATA

DEFINE CLRPGM U	;CLEAR PT DIR WITHOUT SWITCHING USERS.  ARG IS USUALLY "(U)".
 CONO PAG,660000+<EPT/1000>
TERMIN

;;; INTERNAL I/O DEVICES

PAG==10		;CONO, DATAO PAG SET UP PAGING
CCA==14		;CACHE OPERATIONS
TIM==20		;TIMER DEVICE
MTR==24		;METERS DEVICE

;;; SPECIAL INSTRUCTIONS

SWPIA=DATAI CCA,	;INVALIDATE WHOLE CACHE
SWPIO=CONI CCA,		;INVALIDATE ONE PAGE OF CACHE
SWPUO=CONSO CCA,	;UNLOAD ONE PAGE OF CACHE
SWPUA=DATAO CCA,	;UNLOAD WHOLE CACHE
WRPAE=702100,,		;WRITE PERFORMANCE-COUNTER ENABLES
APRID==BLKI		;READ CPU SERIAL NUMBER AND OPTIONS
RDERA=BLKI PI,		;READ ERROR ADDRESS
RCCL=DATAI TIM,		;READ CALENDAR CLOCK (DOUBLE WORD)
RPERFC=BLKI TIM,	;READ PERFORMANCE COUNTER (DOUBLE WORD)
REBOXC=DATAI MTR,	;READ EBOX CYCLE COUNTER (DOUBLE WORD)
RMBOXC==BLKI MTR,	;READ MBOX CYCLE COUNTER (DOUBLE WORD)

;INSTRUCTIONS THAT OUGHT TO BE DEFINED IN MIDAS, BUT AREN'T, YET

DADD=114000,,
DSUB=115000,,
DMUL=116000,,
DDIV=117000,,
DMOVE=120000,,
DMOVN=121000,,
DMOVEM=122000,,
DMOVNM=123000,,

;EPT LOCATIONS

$INSRT EPT

;PAGE FAIL WORD - UPFW(U)

 %PF==1,,405000
 %PFUSR==400000		;USER PAGE
 %PFCOD==370000		;FAILURE CODE:
  %PFPRO==210000	;PROPRIETARY VIOLATION
  %PFMAR==230000	;MAR BREAK
  %PFILW==240000	;ILLEGAL WRITE IN READ ONLY
  %PFPNA==330000	;PAGE NO ACCESS
  %PFPTP==250000	;PAGE TABLE PARITY
  %PFPAR==260000	;PARITY ERROR, DATA IN AR
  %PFPRX==270000	;PARITY ERROR, DATA IN ARX
 %PFPUB==4000		;PUBLIC PAGE
 %PFCCH==2000		;CACHED
 %PFPAG==1000		;PAGED
 $PFPNO==121000		;VIRTUAL PAGE NUMBER
			;1.1-3.5 VIRTUAL ADDRESS

DEFINE UUOH	;UUO HANDLER LOCATIONS REFERENCED THROUGH THESE MACROS
XUUOH(U)TERMIN

DEFINE FORTY
MUUODP(U)TERMIN
]		;END OF IFN KL10P
IFN PLTP,[
;PLOTTER CONTROL BITS
SD==4000
PD==10000
PUP==200
PDN==400
SDC==20000
PDC==40000
SDS==1000
PDS==2000
]

;SYS PERIPHERAL DEVICE CODES

;1.6 INDICATES DIRECTORY DEVICE
;1.5 INDICATES NON PHYSICAL DEVICE

SNTTY==1
SNTDS==2	;TERMINAL DISPLAY
SNLPD==3	;DATA PRODUCTS LPT
SNVID==4
SNBAT==5
SNPLT==6
SNPTP==7
SNIMPX==10
SNOMPX==11
SNPTR==12
SN340==13	;340 AS ASCII DEVICE
;SN340I==14	;INTERPRETED DISPLAY ON 340
SNMTC==15	;MAGTAPE
SNCOD==16	;CODE DEVICE
SNTAB==17
SNNUL==21
SNJOB==22
SNBOJ==23
SNSPY==24
SNSTY==25
SNNET==26	;NETWORK
SNLPV==27	;VOGUE LPT
SNSTK==30	;STANFORD KEYBOARD
SNMSP==31	;CROCK "IPC" FOR NOW
SNUTC==41
SN2311==43
SNFUSR==60
SNUSR==61
SNCLK==62	;CLO, CLU, & CLI
SNDIR==63
SNPDP==64	;PDP6

SPD==60.*60.*24.	;# SECS IN A DAY (FITS IN A HALFWORD)
	PDUPS==60.	;# PDCLK INCREMENTS/SEC

OPNCOM==410300	;COMMAND FIELD IN LH OF FIRST OPEN WORD

;SYS IOC STATUS WORD FORMAT

;RIGHT HALF WORD DEVICE STATUS
;1.1-1.6 SYS PHYSICAL DEVICE CODE
;1.7-1.9 OPEN MODE
;2.1 SYS BUFF CAP FULL
;2.2 "   "    "  EMPTY
;2.9-2.3 DEVICE DEPENDANT

;LEFT HALF WORD CHANNEL STATUS 
;3.6-3.1 SET BY OPENS THAT DONT SKIP
;4.5-3.7 SET BY IOC ERRORS (INTERRUPTS) AT IOT OR OPER TIME
 ;3.9-3.7 ARE FOR 340 OR E&S ERRORS
 ;4.5-4.1 ARE FOR OTHER DEVICES
;A LIST OF ERROR CODES FOR OPEN FAILURES ARE IN THE FILE  BITS.

NDOPL==7	;NUM OF DIS OPNL

;4.5-3.7 SET BY IOC ERRORS AT IOT OR OPER TIME

;3.9-3.7 SET BY 340 ROUTINES
;1 ILLEGAL SCOPE MODE
;2 SCOPE HUNG
;3 MORE THAN 1K SYS SCOPE BUF
;4 MEMORY PROTECT
;5 ILLEGAL SCOPE OP
;6 MEMORY PROTECT ON PDL POINTER
;7 ILLEGAL PARAMETER SET

;4.5-4.1
;DECIMAL CODE
;11 ILLEGAL CHR AFTER ^P ON TTY DISPLAY
;10 CHNL IN ILLEGAL MODE WHEN .IOT ATTEMPTED
;9 DEVICE FULL
;8 CHANNEL NOT OPEN
;7 CHANNEL DOES NOT HAVE A USER OPEN ON IT
;6 ATTEMPT TO OVER IOPUSH
;5 ATTEMPT TO OVER IOPOP
;4 NON-EXISTANT SUB DEVICE
;3 NON-RECOVERABLE DATA ERROR ;NON-EX-MEM ON PDP10 REF
;2 ATT TO RANDOM ACCESS BEYOND END OF FILE
;1 ILLEGAL HARDWARE OPERATION ATTEMPTED OR DEVICE HUNG

MIOTER==1	;LOWEST IOCERR CODE USED
NIOTER==13	;NUMBER "  "

;4.9-4.5 ALWAYS ZERO (USED BY IOPUSH FOR CHNL NUM)

FNM==.FNAM2	;SRI GETS VERSION NUMBER
		;WORKS FOR DECIMAL IGNORES LOW ORDER NON-NUMERIC CHRS
DEFINE VNAM
.TAG FOO
	ZZZQ==FNM&77
	IFGE ZZZQ-'0,IFLE ZZZQ-'9,.GO BAR
	FNM==FNM_-6
	.GO FOO
.TAG BAR
	ZZZQ==1
	SRI==0
.TAG MUM
	IFE FNM,.GO END
	ZCHR==FNM&77-'0
	IFL ZCHR,.GO END
	IFG ZCHR-9,.GO END
	SRI==SRI+ZZZQ*ZCHR
	ZZZQ==ZZZQ*10.
	FNM==FNM_-6
	.GO MUM
.TAG END
	TERMIN

IF1 VNAM

DEFINE SRITYP A
ZZZ==10	;SAVE OLD RADIX
RADIX 10.
	MOVEI I,[MNAME [.ASCII ?
] ITS !SRI A?]
RADIX ZZZ
	TERMIN

		;"MONTHS OF THE YEAR" MACRO

DEFINE MNIRP A
IRPS M,,[JAN:FEB:MAR:APR:
MAY:JUN:JUL:AUG:
SEP:OCT:NOV:DEC:]L,,[31. 29. 31. 30.
31. 30. 31. 31.
30. 31. 30. 31.]
A
TERMIN
TERMIN

FOO==-1	;ACCUMULATED VALUE FOR FOLLOWING DEFINITION:

MNIRP [M==FOO
FOO==FOO+L]	;JAN=-1, FEB=30., MAR=59., ETC.

DEFINE CONC A,B
A!B!TERMIN

DEFINE INFORM A,B
IF1,[PRINTX \A = B
\]TERMIN

ZZZ==10
RADIX 10.
INFORM VERSION,\SRI
RADIX ZZZ

SSYS==0	;LENGTH OF SYS CODE

DEFINE EBLK
IFN CKPAR,.ERR LOSS AT EBLK
CKPAR==1
IFE .-CKZZ,.STOP		;NO WORDS BETWEEN BBLK AND EBLK
CONC CK,\CKNUM,==CKZZ-.,,CKZZ
CKNUM==CKNUM+1
SSYS==SSYS+.-CKZZ
TERMIN

DEFINE BBLK
CKZZ==.
IFE CKPAR,.ERR LOSS AT BBLK
CKPAR==0
TERMIN

CKPAR==1
CKNUM==0


;INSERT CALL TO THIS MACRO AT ANY PLACE IT IS POSSIBLE TO PCLSR
;(IF IT IS DESIRED FOR PCLSR TEST FEATURE TO TEST THAT SECTION)

DEFINE PCLT
IFN PCLSW,[
	SKIPE PCLDBM
	PUSHJ P,PCLTST
]
TERMIN

DEFINE	PCLTH A
IFN PCLSW,[
	SKIPN PCLDBM
	JRST .+3
	PUSHJ P,PCLTSH
	A
]
TERMIN

DEFINE	PI2SAF
	CONSO PI,20000
	CONSO PI,40
	JRST .+2
	JRST 4,.	;PI 2 NOT OFF AND NOT IN PROGRESS
TERMIN

	NMMP==4		;# EXEC PAGES FOR MMP TABLE
IFN 340P,N340PB==10.	;# EXEC PGS USED FOR 340 DATA MUST BE EVEN
IFN N11TYS,[
	NTTPG==6	;# EXEC PGS FOR PDP11 TV TTYS.
	NTVBP==11	;THESE PAGES ADDRESS THE WHOLE VIDEO BUFFER MEMORY ADDRESS
			;SPACE OF THE TV 11.  THE LAST OF THESE ADDRESSES THE
			;TV CONSOLE REGISTER
]
	NUVPG==256.	;SIZE USR PRGM THAT PAGE TABLE VARS CAN BE
			;ACCOMODATED IN USR VARIABLES
;CIRCULAR PAGE LINK FORM
;2.9=0
;1.1-1.8 PAGE #
;2.8-1.9 USER #
;2.9=1
;2.8=0 2.7-1.1 LINK TO MMP TABLE
;2.8=1 2.7-1.1 LINK TO MEM PNT TABLE
;EXCEPT 2.9-1.1=777777 => ABSOLUTE PAGE, NOT LINKED

;EXECUTIVE PAGE

EXPGN==0

DEFINE EXECPG X
X==EXPGN
EXPGN==EXPGN+1
ZZQ==<X+1>&1
ZZQQ==X_-1
.!X==220000*ZZQ+2200,,ZZQQ
TERMIN

SYSUSM==TSYSM-DDTPGS	;LEFT AFTER ROOM FOR DDT
;EXEC MAP ASSIGNMENTS
IFN 340P,[
EXECPG 340P1,	;USED TO FETCH + TRACE 340 PNTRS
EXECPG 340P2,
REPEAT N340PB,CONC [EXECPG DPG]\.RPCNT,;	;DATA AREA PNTRS FOR 340 DATA
]
EXECPG CORJF,	;CORE JOB FROM PAGE
EXECPG CORJT,	;CORE JOB TO PAGE
IFN VIDP,[
EXECPG VSB1,	;.VSCAN B1
EXECPG VSB2,	;.VSCAN B2
]
IFN TEN11P,[
EXECPG T11CP,	;TEN11 CONTROL PAGE
]
REPEAT NMMP,CONC [EXECPG MMP]\.RPCNT,;	;MMP TABLE
 MMP=MMP0*2000+400000	;VIRTUAL ADDRESS OF MMP
EXECPG PAREP,	;USED BY SYSTEM IN ITS DILIGENT EFFORTS TO FIX PARITY ERRORS

IFN XGP,[
EXECPG XGPC,	;LOW 2K OF XGP PDP-11	(USED TO TRACE BUFF POINTERS)
EXECPG XGPB,	;2K BUFFER IN PDP-11 (CHANGES LOCATION)
EXECPG XGPUB,	;XGP USER CORE EXEC PG SETUP TO POINT TO USER CORE DURING XGPIM SYSTEM CALL
]
IFN N11TYS,[
REPEAT NTTPG,[CONC [EXECPG TTPG]\.RPCNT,
]
REPEAT NTVBP,[CONC [EXECPG TTR]\.RPCNT,
]]
IFG NTUTBL-1,[			;TUTS ACCESSED VIA EXEC PAGES
REPEAT NQS*NTUTBL,[CONC [EXECPG TUT]\.RPCNT,
]]
EXPUNGE EXECPG
NEXPGS==EXPGN	;# EXEC PGS USED

SUBTTL LOW CORE

.YSTGWD		;STORAGE WORDS OKAY NOW

IFN KL10P, LOC EPT+1000	;OR WHEREVER

PATB:
LOC 20
	BBLK

IFN TM10B,[
	LOC 30
	EBLK
MICWA:	MIOWD
	0
IFE RP10P+RH10P,BBLK
]
IFN RP10P+RH10P,[
	LOC 32
IFE TM10B,EBLK
QICWA:	QIOWD
	0
	BBLK
]
IFN E.SP,[
	LOC 34
	E.SPM	;POINTER , NEVER CHANGES
]

LOC 37
	EBLK
LOC 41
IFE KL10P, JSR UUOH	;UUO TRAP
IFN KL10P, JSR LUUOEX	;USER UUO IN EXEC MODE (ERROR)

LOC PI0LOC+2
	REPEAT 2,	JSR RINT1
	REPEAT 6*2,	JSR RINT	;INITIALIZE ANY UNUSED PI LOCNS

LOC 61
IFE KL10P, JSR 60H		;60 TRAP
IFN C1MXP, REPEAT 2*7.,	JSR RINT1	;INITIALIZE C1MPX LOCNS

LOC PI0LOC+2*APRCHN
	JSR CLKBRK	;PROCESSOR OR CLOCK INTERRUPT
	JRST 4,.

LOC PI0LOC+2*PCHCHN
	JSR LPTBRK	;LPT,DISPLAY,PTP,PTR,OTHER PROCESSOR
IFN 340P,	JSR DRECYC	;HACK HACK

LOC PI0LOC+2*TTYCHN
	JSR TTYBRK	;TTY,DATAPOINT KLUDGE
	JRST 4,.

LOC PI0LOC+2*UTCCHN
	JSR UTCBRK	;MICRO TAPE OR DISK (S)
	JRST 4,.

IFN E.SP,[
LOC PI0LOC+2*DISCHN
	JSR ESBRK
	JRST 4,.
]
IFN 340P,[
LOC PI0LOC+2*DISCHN
	JSR DIGNOR	;340 DISPLAY BLKO GETS PATCHED IN HERE
	CONO PI,4000+200_<-SDCHN>	;HACK HACK
]

IFN VIDP,[
LOC PI0LOC+2*OMPCHN
	JSR OMPXBK	;OUTPUT MPXR, NVID, ETC.
	JRST 4,.
]
IFN NETP,[
IFE DMI,[
LOC PI0LOC+2*IMPCHN
	JSR IMPBRK
LOC IMPILC
	JSR IMPIBK
	0
LOC IMPOLC
	JSR IMPOBK
	0
]		;END OF IFE DMI
]		;END OF IFN NETP

IFN KL10P,[
LOC PFOPC
PFOPC:	0		;PAGE FAIL OLD PC STORED HERE
PFNPC:	PFAIL		;WHERE TO GO FOR PAGE FAIL

LOC EPTDIA
EPTDIA:	JRST SALV	;STD COMMAND START ADDRESS ("DIAGNOSTIC")
EPTDDT:	JRST DDT	;DDT COMMAND START ADDRESS
EPTSTL:	JRST DSKDMP	;STL COMMAND START ADDRESS ("LOADER")
EPTITS:	JRST BEG	;STM COMMAND START ADDRESS ("MONITOR")
			;SALV THEN GO
LOC EPTTR1
EPTTR1:	CAI		;ARITH OVERFLOW EXEC MODE IGNORED
EPTTR2:	JSR ILLTRP	;PDL OVERFLOW EXEC MODE IS AN ERROR
EPTTR3:	JSR ILLTRP	;ONE PROC CODE?

LOC DTEBPO
DTEBPO:	0		;BYTE TRANSFER NOT USED
DTEBPI:	0		;BYTE TRANSFER NOT USED
DTELOC:	JSR DTEBRK	;INTERRUPT FROM CONSOLE 11
	0		;UNUSED WORD
DTEPRO:	0		;NO PROTECTED EXAMINES
DTERLO:	0		;..
DTEPRI:	0		;NOR PROTECTED DEPOSITS
DTERLI:	0		;..

LOC EPT+430
REPEAT 8,MUUOEX		;HALT IF UUO IN PROCESSOR BREAK ROUTINES

LOC EPTEBC
EPTEBC:	0 ? 0		;EBOX COUNT FOR PROC BRK ROUTINES AND NULL JOB
EPTMBC:	0 ? 0		;MBOX DITTO
]		;END OF IFN KL10P

IFN DL10P,[	;DL10 COMMUNICATIONS AREA IN NON-ENCACHED LOW CORE
IFE KL10P, .ERR DL10 LOW CORE AREA NOT RESERVED
LOC 200

DL10AR:	JSR TTDLBRK	;INTERRUPT INSTRUCTION

;FOLLOWING LOCATIONS MUST AGREE WITH IOELEVEN PROGRAM

DL10VR:	NDLTYS_8+NFDLTY	;"I/O VERSION NUMBER"
DL10UP:	0		;SET BY -11 WHEN IT COMES UP, THEN CLEARED BY -10.
DL10DN:	0		;ZEROED BY -10 EVERY 1/2 SECOND TO SHOW IT IS NOT DOWN.

DL10IL:	0		;LINE # WITH INPUT AVAILABLE.  CLEARED BY -10 AFTER CHAR READ.
DL10IC:	0		;CHARACTER RECEIVED FROM THAT LINE.

DL10OD:	0		;LINE # WITH OUTPUT DONE.  CLEARED BY -10 WHEN PROCESSED.
DL10BS:	0		;BUFFER SIZE FOR THAT LINE.

DL10BP:	0		;WIERD DL10 BYTE POINTER TO TTY OUTPUT BUFFER.
DL10CC:	0		;NUMBER OF CHARACTERS BEING OUTPUT TO TTY.
DL10LN:	0		;LINE # OUTPUT BEING SENT TO.  CLEARED BY -11 WHEN GOBBLED.

DL10CL:	0		;DIALUP LINE CONNECT OR DISCONNECT INFO. SET BY 11, 0'D BY 10.
			;0000NN => LINE # NN DISCONNECTED.
			;01RTNN => LINE # NN CONNECTED, %TTISP=R, %TTOSP=T.

DL10PL:	0		;LINE # TO SET PARAMETERS OF.  CLEARED BY -11 WHEN PROCESSED.
DL10PR:	0		;VALUE OF DH11 LPR REGISTER.
DL10PS:	0		;NUMBER OF BYTES OF OUTPUT BUFFERING DESIRED.

DL10XD:	0		;1=EXAMINE -11 CORE, 2=DEPOSIT.  CLEARED BY -11 WHEN DONE.
DL10XA:	0		;EXAMINE/DEPOSIT ADDRESS
DL10XW:	0		;EXAMINE/DEPOSIT WORD

GLPTBP:	0		;BYTE POINTER TO BUFFER FOR GOULD LPT
GLPTBC:	0		;BYTE COUNT " " - IF NONZERO BUFFER IS ACTIVE BY PDP11.

;^ ADD MORE HERE

IFG .-DL10AR-100, .ERR DL-10 AREA TOO BIG, CHANGE CONO IN TSS INITIALIZATION
LOC DL10AR+100		;FILL OUT TO 64. WORDS

DL10BF:	BLOCK <261.+3>/4	;OUTPUT BUFFER, 8-BIT BYTES.  HAS TO BE NON-ENCACHED.

DL10SO:	0			;LH AND RH ARE LINE #'S STARTING OUTPUT ON OR ZERO

IFN GLPTP,[
GLPBSZ==255.	;BUFFER SIZE IN WORDS.  MAXIMUM POSSIBLE WITHOUT MODIFYING (ELIMINATING)
		;"WORD COUNT" HARDWARE IN DL-10.
GLPMPP:	0	;MAIN PROGRAM POINTER - IF NONZERO BUFFER IS ACTIVE BY M.P. LEVEL (PDP10)
GLPMPC:	0	;MAIN PROGRAM COUNTER
GLPTBF:	BLOCK GLPBSZ	;ONE BUFFER FOR NOW
IFG .-EPT,.ERR GOULD LPT BUFFER TOO BIG
]	;END IFN GLPTP
]	;END IFN DL10P

LOC PATB

	;FOR VARIABLES (MONITORABLE WITH KEYS)
NSKED:	0	;# TIMES SCHED RUN (LOCATION 100)
NUINT:	0	;# TIMES USER GIVEN INTERRUPT
NAUINT:	0	;# ATTEMPTED USER INT (POSSIBLY UNSUCCESSFUL DUE TO PG FAULT)
NPCLSR:	0	;# ATT TO PCLSR
NSOUSR:	0	;# ATT TO SWAP OUT USR
NSOPGS:	0	;# TIMES THRU LOOP LOOKING FOR PG TO SWAP OUT
NPGSO:	0	;# TIMES AT SWOPG
NPGFLT:	0	;# PAGE FAULT (ALL CAUSES)
NCLKI:	0	;# CHNL 7 INTS (ALL CAUSES) (LOCATION 110)
NPGLD:	0	;# TIMES AT PGLDU
NUFLS:	0	;# TIMES AT UFLS
NTUSB:	0	;# TIMES USER SWAP BLOCKED
NTSBUP:	0	;# TIMES SWAP BLOCKED USER TOOK PAGE FAULT AND LET IN
NTSBUB:	0	;# TIMES SWAP BLOCKED USER TOOK PAGE FAULT AND BLOCKED
NTSBUU:	0	;# TIMES SWAP BLOCKED USER UNBLOCKED BEFORE TIME (MEM APPARENTLY AVAIL)

;THE FOLLOWING FOUR MUST BE CONSECUTIVE
NRPI:	0	;# REFS TO PAGE IN (BUT MAP WAS NOT SET UP, ETC)
NRPCI:	0	;# PAGE FAULTS REFS TO PAGE COMMING IN (LOC. 120)
NRPO:	0	;# REFS TO PAGE OUT
NRPGO:	0	;# TO PAGES GOING OUT
CLKBRS:	0	;CLKBRK COPIED INTO HERE (SINCE CLKBRK GETS CHANGED)

PAT:
LOC PATB+40

BBLK

PATCH:	BLOCK 140	;PATCH SPACE CODE AND CONSTANTS

EBLK

VPATCH:
VPAT:
BLOCK 40	;PATCH SPACE VARIABLES

SUBTTL PROCESSOR BREAK ROUTINES

DEFINE CLKSAV BRK=CLKBRK
IFN KL10P,	XCT CLCXSV	;DATAI PAG,CLCX(U)
	XCT CLUSAV		;STORE U IN AC17S FOR CURRENT USER (UNLESS NULL JOB)
	MOVE U,BRK		;SAVE AWAY BRK
	MOVEM U,CLKBRS
IFSN BRK,CLKBRK, MOVEM U,CLKBRK	;SAVE IN CLKBRK IF NOT CLKBRK
TERMIN

IFN KL10P,[
DEFINE CLKLEV			;ENTER CLOCK-LEVEL CONTEXT
	DATAO PAG,[700100,,EPT/1000]	;AC BLK 0, PREV 1, UPT=EPT
	MOVE U,USER
	JRST 2,@.+1		;MAKE XCTR WORK RIGHT
	  %PSPCU,,.+1
	MOVE P,CPDLP
TERMIN
]
IFE KL10P,[
DEFINE CLKLEV
	MOVE P,CPDLP
TERMIN
]

IFN KL10P,[

;HACKING THE DTE:

;THE TTY CODE ASSUMES, SINCE THE DTE20 IS USED BY ITS SOLELY AS
;THE INTERFACE TO THE CONSOLE TTY AND THE LINE-FREQUENCY CLOCK,
;THAT IT MAY FREELY GIVE THE "MONITOR TTY OUTPUT" COMMAND WHEN
;THE "MONITOR TTY OUTPUT DONE" INTERRUPT IS RECEIVED.  ANY CODE
;WHICH HACKS THE DTE OTHER THAN AT PI LEVEL OR IN ITS INITIALIZATION
;MUST THEREFORE OBSERVE THE FOLLOWING PROTOCOL:
;	CONO PI,DTEOFF
;	SKIPN DTEFLG		;WAIT FOR MONITOR TTY OUTPUT TO GO THROUGH
;	 JRST .-1
;	SETZM DTEFLG
;	 ;HERE SET DTECMD
;	CONO DTE,%DBL11
;	SKIPN DTEFLG		;WAIT FOR THIS COMMAND TO GO THROUGH
;	 JRST .-1
;	CONO PI,DTEON
;
;PRESENTLY NO ONE ELSE PLANS TO HACK THE DTE EXCEPT MAYBE ARDSW

DTEBRK:	0
BBLK
INFORM DTEBRK+1,\.
	CONSO PI,1_<7-APRCHN>	;TEMPORARY (I HOPE) HARDWARE BUG IN KL10 PI HARDWARE
	 JRST 12,@DTEBRK
	SKIPN SYSDBG		;IN DEBUG MODE, GO TO DDT IF SIGN BIT OF SWITCHES IS SET.
	 JRST DTEBR1
	SKIPE DTESWR
	 JSR GODDT
DTEBR1:	CONSO DTE,%DBL10
	 JRST 4,.		;SPURIOUS INTERRUPT FROM 11
	CONO DTE,%DBL10		;CLEAR INTERRUPT FLAG
	SKIPN DTEMTI
	 SKIPE DTEMTO
	  CONO PI,TTYRQ		;TTY INTERRUPT - TAKE ON TTY PI  CHANNEL
	JFCL
	JFCL			;SHORT DELAY FOR CONO TO TAKE EFFECT
	SKIPN DTECLK
	 JRST 12,@DTEBRK
	SETZM DTECLK		;LINE FREQUENCY CLOCK INTERRUPT
	CLKSAV DTEBRK
	JRST CLKB2A
EBLK
]

CLKBSW:	0		;READ SWITCHES INTO HERE TO DECIDE WHETHER TO GO TO DDT.

CLKBRK:	0		;PC SAVED HERE BY JSR FOR CLOCK INT.

BBLK
IFN KL10P,[
	CONSO PI,1_<7-APRCHN>	;HARDWARE BUG IN KL10 PI SYSTEM
	 JRST 12,@CLKBRK
	CONO PI,020000+200_<-APRCHN>	;BAG-BITING DEC LOSERS CHANGED FUNCTIONAL
]					;SPECIFICATION OF PROGRAMMED REQUESTS
IFE KL10P,[
	SKIPE SYSDBG
	 JRST [	DATAI CLKBSW
		SKIPGE CLKBSW
		 JSR GODDT
		JRST .+1]
]
CLKBR2:	CLKSAV		;SAVE AC BLK STATUS AND U.
CLKB2A:	AOS NCLKI
	SKIPGE U,USER	;PICK UP INDEX OF CURRENT USER, SKIP UNLESS NULL JOB
	JRST	[SPM UPGML
		JRST CLKBKR]
;JUMP IF NULL JOB WAS RUNNING
	SPM UPGML(U)	;STORE PAGE MAP AWAY
	AOSN UFLSF	;SKIP UNLESS GOT HERE FROM UFL6
	JRST CLUFLS
	MOVEM T,AC16S(U)	;STORE AWAY T
	MOVEI T,AC0S(U)
	BLT T,AC15S(U)	;STORE REST OF ACS
CLKBKR:	CLKLEV		;SET UP CROCK-LEVEL CONTEXT HARDWARE

;;; CHECK FOR THINGS OTHER THAN CLOCK TICKS (PAR ERR, PG FAULT, NXM, PDLOV, AROV
;;;  AND ARFOV ARE POSSIBLE ON ONE MACHINE OR THE OTHER).

IFE KL10P,[
	CONSZ 270220	;CHECK PDL OV, MEM PROTECT, NXM, FOV, AR OV
	 JRST CLKB1	;JUMP ON LOSSAGE
CLKB1D:	CONSZ PI,200000
	JRST CLKB1E	;PARITY
	CONSO 1000	;SKIP ON CLOCK BREAK
	JRST CLK1F	;SPURIOUS INTERRUPT
]		;END IFE KL10P
IFN KL10P,[
	CONSZ 7740
	 JRST CLKB2	;APR ERROR INTERRUPT
]		;END IFN KL10P

;DROP THROUGH FOR PLAIN CLOCK-TICK.

;
; 60-CYCLE CLOCK INTERRUPT
;

CLKTIC:
;IFN 340P,	DATAI CLK1,LQTIM
	SOSG @CLROOT	;COUNT DOWN, SKIP IF NOT TO NEXT REQUEST
	JRST CLQBRK	;SERVICE CLOCK QUEUE REQUEST
CLQBRT:
IFE KL10P, CONO 1000+APRCHN	;RESET CLOCK INTERRUPT
IFN XGP,[
	SKIPL XGPUSR
	PUSHJ P,XGPCLK
]
IFN 340P,[
	AOSGE T,DTIME
	JRST DSTPD	;WAIT IF DTIME CLOBERED DUE TO RATE EXCEEDED
	CAILE T,2
	MOVEI T,2
	MOVEM T,DTIME
	SKIPL CDISOF
	SKIPGE DISOFF
	JRST DSTPD
	AOSG DISON
	CONO DIS,1100\SDCHN_3\DISCHN	;RESTART DISPLAY
DSTPD:
]
IFN E.SP,[
	SKIPN	T,E.SPGW	; E&S WAITING FOR PAGE
	JRST	E.SOK
	HRRZM	T,DISSPG	; SAVE FOR SWPPIN
	SKIPL	T,DISUSR	; -1 IMPLIES NO USER
	MOVEM	T,DISSWI	; USER INDEX FOR SWPPIN
E.SOK:
]
IFN N2741,[
	SKIPGE 27FCLK	;HANDLE 2741'S IN MODE-CHANGING SEQUENCES, ETC.
	 PUSHJ P,TYP27S
]
IFN N11TYS,[
	SKIPE @TT11HD	;ANY INPUT FROM PDP11?
	 PUSHJ P,TT11IN	;YES, DO INPUT INT LVL STUFF FOR IT,.
]
	MOVS T,TTERQS
	CAIE T,(MOVE)
	PUSHJ P,TTECH	;CHARACTERS TO BE ECHO ED
	SETCMM CLKFL1
	SKIPL CLKFL1
	AOS TIME	;GET HERE EVERY THIRTIETH OF A SECOND
	AOSG SCHFLG
	JRST CLKB5	;TIME NOT UP
	JRST SCHED	;SCHEDULE

CLUFLS:	CONO PI,CLKON	;FROM UFLS
	CLKLEV
	MOVE T,UPC(U)
	MOVEM T,CLKBRK
	MOVEM T,CLKBRS
	AOS NUFLS
	JRST SCHED2

IFN KL10P,[
CLKB2:	CONSZ 2000		;NXM
	 PUSHJ P,MEMHNG
	CONSZ 1040		;POWER FAIL OR I/O PAGE FAIL
	 JRST 4,.
	CONSZ 300		;CACHE DIR OR PT DIR PAR ERR.
	 JRST 4,.
	CONSO 4400		;SBUS ERR OR MB PAR ERR
	 JRST SCHED		;CALLED MEMHNG, AND NOTHING ELSE => SCHEDULE.
	SETOM PARRSN		;TEL PAR ERR SCANNER THIS IS AN INTERRUPT, NOT A PG FAIL.
	RDERA PARERA		;STORE ADDR OF PAR ERR.
	JRST CLKB1E
]

	;CLOCK QUEUE SERVICE
CLQBRK:	SKIPG U,CLROOT	;GET POINTER TO CURRENT BLOCK
	 JRST 4,.	;CLK QUEUE SCREWED
	SKIPG T,1(U)	;GET POINTER TO NEXT BLOCK
	 JRST 4,.	;CLK QUEUE SCREWED
	MOVEM T,CLROOT	;SET UP POINTER FOR NEXT BLOCK
	SETOM 1(U)	;INDICATE CURRENT BLOCK IDLE
	XCT 2(U)	;EXECUTE REQUEST (PROBABLY A JRST)
		;FALL THROUGH IF SINGLE INST RQ
CLQRET:		;RETURN FROM REQUEST
	SKIPN @CLROOT	;SKIP IF TIME TILL NEXT RQ NONZERO
	JRST CLQBRK	;ZERO TIME DELTA, DO NEXT RQ
	JRST CLQBRT	;RETURN TO CLOCK ROUTINE

CLQTTR:	JUMPE TT,CLQRET	;COMMON RETURN FOR TT IDLE FLAG
CLQREE:	MOVEI E,CLQRET	;RE ENTER RQ

;CLOCK OFF OR IN PROGRESS LEVEL ADD TO CLOCK QUEUE, CALL BY JSP E,
	; T HAS TIME TILL RQ IN 60'THS
	; C POINTS TO THREE WORD BLOCK, RQ'ED INST IS IN THIRD
CLQPUT:	MOVEI B,CLROOT-1
CLQPU2:	MOVE A,B	;REPLACE POINTER TO PREV BLOCK WITH CURRENT
	SKIPG B,1(B)	;GET LINK TO NEXT BLOCK
	JRST 4,.
	SUB T,(B)	;SUBTRACT TIME DELTA FOR NEXT BLOCK
	JUMPG T,CLQPU2	;JUMP IF RQ LATER THAN CURRENT BLOCK
	JUMPE T,CLQPU6	;JUMP IF RQ SAME AS " " (COULD USE PU2 BUT THIS FASTER)
	ADD T,(B)	;RQ EARLIER, ADD BACK
	MOVEM T,(C)	;SET DELTA OF BLOCK BEING ADDED
	SUB T,(B)	;COMPUTE NEG OF DELTA FOR NEXT BLOCK
	MOVNM T,(B)	;SET TIME DELTA FOR NEXT BLOCK
	MOVEM B,1(C)	;SET LINK OF NEW BLOCK TO NEXT
	MOVEM C,1(A)	;SET LINK OF PREV BLOCK TO NEW
	JRST (E)

CLQPU6:	SETZM (C)	;SET TIME DELTA OF NEW BLOCK TO ZERO
	MOVE A,1(B)	;GET POINTER TO NEXT BLOCK
	MOVEM A,1(C)	;SET POINTER OF NEW TO NEXT BLOCK
	MOVEM C,1(B)	;SET POINT OF CURRENT TO NEW BLOCK
	JRST (E)

;MAIN PROG LEVEL ADD TO CLOCK QUEUE
;CALL BY PUSHJ P,CLQADD
;WITH POINTER TO BLOCK IN NEXT WORD AND TIME TILL RQ IN T IN 60'THS
;POINTER TO BLOCK SHOULD NOT BE INDEXED BY C

CLQAD1:	MOVEI T,1	;RQ IN ONE TICK
CLQADD:	PUSH P,C
	MOVE C,@-1(P)	;GET BLOCK POINTER
	MOVEI C,@C
	SKIPL 1(C)	;SKIP IF IDLE
	JRST POPCJ1	;IGNORE THIS RQ, BLOCK ALREADY ACTIVE
	PUSH P,A
	PUSH P,B
	PUSH P,E
	SKIPN (C)	;DELTA WORD OF IDLE BLOCK SHOULD BE ZERO
	SKIPG T		;TIME SHOULD BE NON-ZERO
	JRST 4,.
	CONO PI,CLKOFF
	JSP E,CLQPUT	;ADD RQ
CLQDE4:	CONO PI,CLKON
	POP P,E
	POP P,B
	POP P,A
	JRST POPCJ1

;DELETE CLOCK QUEUE ENTRY
;CALL BY PUSHJ P,CLQDEL WITH POINTER TO BLOCK IN NEXT WORD
CLQDEL:	PUSH P,C
	MOVE C,@-1(P)	;GET BLOCK POINTER
	MOVEI C,@C
	CONO PI,CLKOFF
	SKIPGE 1(C)	;IGNORE RQ TO DELETE  IF IDLE
	JRST CKOCJ1
	PUSH P,A
	PUSH P,B
	PUSH P,E
	JSP E,CLQCLR
	JRST CLQDE4

CLQCLR:	MOVEI B,CLROOT-1	;CLOCK OFF OR IN PROGRESS VERSION
CLQDE2:	MOVE A,B
	SKIPG B,1(B)	;GET POINTER TO NEXT BLOCK
	 JRST 4,.	;CLK QUEUE SCREWED
	CAME B,C	;SKIP IF FOUND BLOCK TO DELETE
	 JRST CLQDE2
	SKIPG B,1(B)	;GET POINTER TO BLOCK AFTER ONE TO DELETE
	 JRST 4,.	;CLK QUEUE SCREWED
	MOVEM B,1(A)	;PATCH AROUND DELETED BLOCK
	MOVE A,(C)
	ADDM A,(B)	;ADD DELTA OF DELETED BLOCK TO NEXT
	SETZM (C)	;CLEAR DEL
	SETOM 1(C)	;MARK IDLE
	JRST (E)

IFN KL10P,[
EBLK
PFAILU:	0	;SAVED U AS OF A PAGE FAILURE
PFINST:	0
BBLK

;PAGE FAULTS COME HERE, WITH PC IN PFOPC, AND PI SYSTEM TURNED OFF.

PFAIL:	MOVEM U,PFAILU
	MOVE U,PFOPC
	TLNE U,%PCUSR
	 JRST PFA2
	LDB U,[331100,,(U)]	;GET OPCODE OF LOSING INSTRUCTION.
				;ASSUME THAT IN EXEC MODE VIRTUAL
				; AND PHYSICAL ADDRESSES ARE IDENTICAL
				; FOR INSTRUCTION FETCHES.  ALSO ASSUME
				; THAT NOBODY DOES XCT OF XCT OF XCTR.
PFA4:	CAIE U,XCTRI_-33	;SKIP IF "XCTR WITH INHIBIT"
	 JRST PFA1
REPEAT 2, AOS PFOPC		;ONCE COMPENSATING FOR INSTR ABORT, AND ONCE TO SKIP
	MOVE U,PFAILU
	JRST 17,@PFOPC		;KL-10 CROCK: JRST 17, TURNS ON PI SYSTEM

PFA1:	CAIE U,XCTR_-33		;SKIP IF "XCTR WITH NO INHIBIT"
	 JRST PFA3
PFA2:	CONSO PI,77400		;PI IN PROGRESS?
	 CONSO PI,1		;CHANNEL 7 ENABLED?
	  JRST 4,.		;IF YES IOR NO, THEN PAGE FAULT OR PAR ERR FROM LOSING PLACE
	MOVE U,PFAILU		;RESTORE U SO CLKSAV CAN RE-SAVE IT
	CONO PI,CLKOFF		;CLOCK OFF, AND (NOTE WELL!) PI SYSTEM ON
PFA6:	CLKSAV PFOPC
	SKIPG U,USER
	 JRST 4,.		;NULL JOB GOT PAGE FAILURE?
	SETOM PFAILF
	MOVEM T,AC16S(U)
	MOVEI T,AC0S(U)
	BLT T,AC15S(U)
	CLKLEV
	SPM UPGML(U)		;STORE PAGE FAIL WORD
;	MOVE T,PFOPC
;	MOVEM T,UPOPC(U)	;SOLELY FOR THE .OPC USER VARIABLE
	LDB E,[$PFPNO,,UPFW(U)]	;FAILING PAGE NO
	HLRZ D,UPFW(U)
	ANDI D,%PFCOD		;GET THE PAGE-FAULT CODE.
	MOVEI A,0		;INIT USER INT BITS
	CAIE D,%PFPNA
	CAIN D,%PFILW
	 JRST PFA5		;REAL PAGE FAULT OR RWF
	CAIE D,%PFMAR
	CAIN D,%PFPRO
	 JRST PFA7		;OTHER RANDOM BREAKS
	SETZM PARRSN		;SAY THIS IS PAR ERR TRAP, NOT PAR ERR INTERRUPT.
	MOVE D,UPFW(U)
	MOVEM D,PARPFW		;SAVE PFW OF PAR ERR FOR SCANNER
	DATAO PAG,[407700,,400000]
	MOVEM 0,PARWRD		;SAVE THE AC THAT HOLDS THE BAD WORD
	DATAO PAG,[400100,,400000] ;AND RESET THE DATAO PAG TO NORMAL VALUE
	JRST CLKB1E		;GO SCAN FOR THE ERROR.

PFA3:	CAIE U,XCT_-33
	 JRST 4,.		;BARF! IT WAS A REAL LIVE EXEC PAGE FAULT
	MOVE U,@PFOPC		;QUUX! LET ONE LEVEL OF XCT WIN
	MOVEM U,PFINST
	MOVE U,PFAILU
	LDB U,[331100,,@PFINST]
	JRST PFA4
]

IFE KL10P,[
CLKB1:	MOVE T,CLKBRK
	CONSZ 200
	 JRST CLKFO1	;FLOATING OVERFLOW ENABLED
CLKFO2:	CONSZ 20	;SKIP IF AR OV INT NOT ENABLED
	 CONSO 10	;OV ENABLED, SKIP IF OV
	  CONSZ 270000	;NOT OV, CHECK PDL OV, MEM PROTECT, NXM
	   JRST CLKB1C	;PDL OV, NXM, ETC
	JRST CLKB1D	;ONLY CLOCK BREAK, AR OV JUST ENABLED

CLKFO1:	CONSO 100	;SKIP ON FLOATING OVERFLOW
	 JRST CLKFO2	;NOT REALLY FLOATING OVERFLOW
CLKB1C:	JUMPL U,CNLJL	;NULL JOB LOST
	MOVEI A,0	;SET UP INTERRUPT BITS FOR USER
	CONSZ 20	;SKIP IF OV NOT ENABLED
	 CONSO 10	;OV ENABLED, SKIP ON OV
	  JRST CLB1A	;NOT AROV
	PUSHJ P,AROV
CLB1A:	CONSZ 200	;SKIP IF FL OV NOT ENABLED
	 CONSO 100	;FL OV ENABLED, SKIP ON FL OV
	  JRST CLB1B	;NOT FLOATING OVERFLOW
	PUSHJ P,ARFOV
CLB1B:	CONSO 270000	;SKIP IF PDL OV, NXM, OR MEM PROTECT
	 JRST CLB1X
	CONSZ 10000	;NON EX MEM
	 PUSHJ P,MEMHNG
	CONSO 200000
	 JRST CLKB1H
	CONSO 30000	;SUPPRESS PDL OVF IF INSTRUCTION ABORTED
	 TRO A,%PIPDL	;PDL OVFLO
	TLNN T,%PCUSR	;SKIP IF IN USER MODE
	 JRST 4,.	;PDL OV IN EXEC MODE
CLKB1H:	CONSO 20000	;MEM PROTECT
	 JRST CLKB1G
	HLLZ D,UPQUAN(U)	;PICK UP FAULT BITS
	TLNE D,1000
	TLNN D,770	;ALL CONDITIONS WHICH ABORT INSTRUCTION
	JRST CLKB1J	;(PLUS PAGE NXM FOR RANDOMNESS)
	HLLZ T,UPOPC(U)
	LSH T,5
	HRR T,UPOPC(U)	;FIX UP OPC
	MOVEM T,CLKBRK	;RESET PC FROM OPC
	AOS NPGFLT
	HLRZ E,UPJPC(U)	;GET VIRTUAL PAGE # (LH OF JPC)
	TRNN E,400
	 JRST 4,CFHFPF	;EXEC PG FAULT
	ANDI E,377	;FLUSH AGE ETC
]		;END OF IFE KL10P
	;DROP THROUGH INTO PFA5

;COME HERE WITH
;  A	BITS FOR USER'S PIRQC
;  D	PAGE FAULT BITS OR CODE
;  E	VIRTUAL PAGE NUMBER OF PAGE FAILURE

IFN KL10P, PFA5:
		MOVE TT,LUMPS
		HRRZ W,USER
IFE KL10P,	TLNE D,320	;SKIP IF REALLY PAGE FAULT
     .ALSO	 JRST CFH4	;OTHERWISE WRITE IN READ ONLY OR EXECUTING IMPURE PAGE
CFHSW1:		HRRZM E,CFHUVP	;USER'S VIRTUAL PAGE NUMBER
		TRZE E,200	;W 4.9 SET IF ENTERED FROM SWPPIN
		 JRST CFH1	;VIRTUAL ADDRESS IN USER'S HIGH SEG
		MOVE C,UCPB1(W)
		TLNN TT,200000
		 JRST CFH2	;MY LOWER DBR NOT HACKED
CFH3:		MOVE C,UCPB1(TT)
		TLNN TT,40000
		 MOVE C,UCPB2(TT)
CFH2:		ROT E,-1
		ADD C,E
		HRLI C,222200
		SKIPGE E
		 HRLI C,2200
		MOVE T,C	;CALCULATE MAP ENTRY B.P. FROM CIRC PTR B.P.
		ADD T,[(200000-2000)UPGMP-UPGCP]
		LDB E,C		;CIRC MEM USE POINTER FOR PAGE FAULT ADDRESS IS IN
		JUMPE E,CFH4	;REAL ILM
		CAIN E,-1
		 JRST CFH4	;ON REFERENCE TO ABS PAGE ALSO ILM
IFN KL10P,[	CAIE D,%PFILW
		 JRST CFHW1
		LDB I,T
		JRST .+1(I)
		  JRST 4,.	;?
		  JRST CFH4	;WRITE IN READ ONLY?
		  JRST CFHRWF	;READ WRITE FIRST
		  JRST 4,.	;?
]
IFE KL10P,[
		TLNE D,40
		 JRST CFHRWF
]
CFHW1:		SKIPGE RPCL(W)
		 JUMPGE W,CFF1	;BEING RPCLSRED?
		MOVEM A,CFHAS
		AOSE CIRPSW
		 JRST CFH5	;NOT AVAILABLE
		TRZE E,400000
		 TRNE E,200000
		  JRST CFHSW3
		CAML E,MMPMX
		 JRST 4,.	;MMP OUT OF RANGE
		MOVE C,E	;CIRC PNTR ALREADY POINTS TO MMP
		ADD C,MMPEAD
CFHSW4:		LDB D,[410200,,(C)]	;TWO BITS OF MMP ENTRY GIVES DISPOSITION OF PAGE
		AOS NRPI(D)
		JRST @CFHDT(D)

CFHSW3:		PUSHJ P,UCPRL	;FIND MMP
		  200000,,.+2
		 JRST 4,.	;NONE?
		SUB P,[4,,4]
		JRST CFHSW4

CFH1:	MOVE C,UCPB2(W)
	TLNE TT,100000
	 JRST CFH3
	TLNE TT,10000
	 MOVE C,UCPB2(TT)
	JRST CFH2

CFHRWF:			;HANDLE "WRITE IN READ-WRITE-FIRST PAGE" PAGE FAULT.
IFE KL10P,[
	TLNE D,10
	 JRST CFHW1	;SOMETIMES NO ACCESS SEEMS TO BE ON TOO
	LDB I,T
	CAIE I,2
	 JRST 4,.	;GOT "WRITE IN R-W-F PAGE" BUT PAGE ISN'T R-W-F.
];END IFE KL10P
	MOVEI I,3
	DPB I,T
	MOVEM A,CFHAS
	JRST CFHX1

;COME HERE FOR PAGE WHICH SEEMS TO BE IN CORE, BUT HAD A PAR ERR RECENTLY.
;"SWAP IT OUT", SO IF IT'S PURE IT WILL JUST BE READ BACK FROM DISK.
CFHPB:	PUSH P,W
	MOVE A,T
	SETOM CIRPSW	;UNLOCK, SO SWPOPG CAN RE-LOCK.
	MOVE C,USER	;TELL SWPOPG WHICH JOB SHOULDN'T BE PCLSR'ED.
	PUSHJ P,SWPOPG	;"SWAP OUT" THE PAGE
	 JRST 4,.	;FAILED TO GO OUT.  MUST BE EXEC PAGE SET UP TO IT, OR BUG.
	POP P,W
	AOSE CIRPSW	;SWPOPG UNLOCKS; RE-LOCK.
	 JRST CFH5	;OR ELSE GO INTO PAGE-WAIT TILL CIRPSW FREE.
	MOVE C,SWOMMP
	JRST CFHSW4	;TRY AGAIN TO REFERENCE PAGE, SWAPPING IT BACK IN.

CFHDT:	CFHPI	;IN
	CFHPCI	;COMING IN
	CFHPO	;OUT
	CFHPGO	;GOING OUT

CFHPI:	MOVE D,(C)
	HRLI C,2200
	PUSHJ P,UCPRL	;PAGE REALLY IN.  JUST SET UP MAP
	100000,,.+2	;RETURN ON MEMPNT
	JRST 4,.
	SUB P,[4,,4]	;FIND MEMBLT INDEX
	TLNE D,MMPBAD	;WAS THIS PAGE RECENTLY A PAR ERR VICTIM?
	 JRST CFHPB	;YES; READ IT BACK OFF THE DISK IF POSSIBLE.
IFN E.SP,[
	JUMPGE	W,E.SBAR	; IF NOT CALLED FROM SWPPIN
	HRRZ	H,DISUSR	; CHECK TO SEE IF SERVICING E&S
	CAIN	H,(W)		; NOT DISPLAY, THEN SKIP
	PUSHJ	P,E.SPGI	; ELSE TIE DOWN PAGE
E.SBAR:
]
	MOVE A,T
	HLLZS MMSWP(A)	;CLEAR LENGTH OF CIRC LIST (BUT NOT EXEC PGS COUNT)
	PUSHJ P,UCPRL	;STORE IN ALL MAPS LINKED
	400000,,QSWI1	;INSERT INTO MAPS AND COUNT OF USERS IN CP LIST
IFN E.SP,SETZM	E.SPGH	; CLEAR QSWI1 FLAG
	JUMPL W,SCRPSJ	;DONT HACK FLSINS
	MOVEI C,0
	MOVNI A,1
CFHX:	SETOM CIRPSW
	TLNN W,200000
	JUMPL W,CPOPJ
CFH5A:	MOVSI D,200000
	JUMPN C,CFH5B	;XFER ON WILL BECOME NON-0
	SKIPN FLSINS(W)
CFH5B:	IORM D,USWST(W)	;WAITING FOR PAGE
	SKIPN FLSINS(W)
	MOVEM C,FLSINS(W)
	SKIPE FLSINS(W)
	CLEARM DLSRCH
	JUMPL W,CPOPJ
CFHX1:	MOVE A,CFHAS
IFE KL10P,	MOVSI D,1770	;CLEAR FAULT STATUS BITS
	MOVE U,USER
	JRST CFH6

CFH5:	JUMPL W,CPOPJ
	MOVE C,[SKIPL CIRPSW]
	JRST CFH5A

SCRPSJ:	SETOM CIRPSW
	POPJ P,

CFHPCI:
CFHPGO:
CFHPO2:	MOVSI D,100000	;BIT ON IF PAGE "IN TRANSIT"
	MOVNI A,1	;SIGNAL "SUCCESS"
	TLNN W,200000
	JUMPL W,SCRPSJ
	SKIPN FLSINS(W)
	MOVEM D,EPDL2(W)	;HANG USER UNTIL PAGE GETS WHERE IT'S GOING
	HRLI C,(TDNE T,)	;COMBINE WITH ADDRESS OF MMP
	JRST CFHX

CFHPO:	SKIPGE USWSCD(W)
	 JRST CFBO1	;GUY LOCKED OUT
CFBO2:	MOVSI E,MMPISW	;PAGE OUT, SWAP IN
	AND E,(C)
	CONO PI,UTCOFF-1
	JUMPN E,CFHPO5	;INITIAL SWAPIN
CFHPO7:	PUSHJ P,HMRQC
	 JRST CFHPO1	;MEM NOT AVAILABLE
	MOVEI B,1
	DPB B,[410200,,(C)]	;INDICATE COMING IN
	HRRZ B,(C)		;OLD CP OF MMP
	MOVEM B,MEMPNT(A)	;BECOMES LINK OUT OF CORE BLOCK
	LDB B,[DADTNL+1(C)]	;B := DISK ADDRESS
	LDB I,[DADDNL+1(C)]	;I := DISK NUMBER
	CAIL I,NQS
	 JRST 4,.
	HRLM B,MEMPNT(A)	;SET DISK ADDRESS CORE BLOCK COMING FROM
	JUMPN E,CFHPO8	;INITIAL SWAPIN
CFHPO9:	CAIGE A,TSYSM
	CAIGE A,SYSB
	 JRST 4,.	;SHOULDN'T HAVE TO SWAP IN THE SYSTEM
	CONO PI,UTCON-1
	SOS NPGSWO
	AOS SWIPRQ	;TOTAL SWAP IN REQUESTS
	MOVEI B,MUSWPG
	DPB B,[MUR,,MEMBLT(A)]
	MOVEI B,600000(A)
	HRRM B,(C)	;MAKE CP OF MMP POINT TO MEMPNT
	PUSH P,C
	SUB C,MMPEAD
	DPB C,[MMMPX,,MEMBLT(A)]	;STORE MMP INDEX IN MEMBLT
	MOVEI C,.BM MLO
	ANDCAM C,MEMBLT(A)	;SET END OF LIST IN THIS BLOCK
	CONO PI,UTCOFF-1
	HLRZ C,SINLST(I)	;GET PREV BLOCK
	SKIPE C
	 DPB A,[MLO,,MEMBLT(C)]	;CHAIN TO PREV BLOCK
	SKIPN C
	 MOVEM A,SINLST(I)	;OR TO HEADER IF FIRST
	HRLM A,SINLST(I)	;AND SET NEW LAST BLOCK
	AOS SILNG
	PUSHJ P,QSTRT1
	CONO PI,UTCON-1
	POP P,C
	MOVSI D,100000		;SWAPPING IN A PAGE FOR THIS GUY 
	TLNE W,-1
	 ANDCAM D,USWST(W)	;SO CLEAR BEST EFORT MADE TO SWAP OUT BIT
	TLNN W,200000
	 JUMPL W,CFHPO2
	AOS USIPRQ(W)
	JRST CFHPO2	;HANG USER UNTIL PAGE IN

CFHPO5:	LDB I,[DADDNL+1(C)]	;GET DSK #
	CAIL I,NQS
	 JRST 4,.
	SKIPL QTUTO(I)
	 JRST CFHPO7	;DISK TUT AVAIL
	CONO PI,UTCON-1
	MOVEI A,0	; LOCKED
	TLNN W,200000	;SCHEDULER
	 JUMPL W,SCRPSJ
	MOVE C,[SKIPGE QTUTO]
	ADD C,I
	JRST CFHX

CFHPO8:	ANDCAM E,(C)	;CLEAR INITIAL SWAPIN BIT
	MOVE D,B	;GET TRK #
	PUSHJ P,TUTPNT
	CAIGE B,TUTMNY
	 SOS B
	DPB B,D
	HRRZS 1(C)	;CLEAR ASSIGNED TRACK NUMBER SO NEW SPACE ASSIGNED ON SWAPOUT
	JRST CFHPO9

CFHPO1:	CONO PI,UTCON-1	;NO MEM AVAILABLE TO SWAP INTO
	MOVEI A,0	;INDICATE NO PROGRESS POSSIBLE
	TLNN W,200000	;SCHEDULER
	 JUMPL W,SCRPSJ
	SKIPGE MEMFRZ
	 JRST CFHPO4
	MOVE C,[SKIPL MEMFRZ]
	JRST CFHX

CFHPO4:	MOVE C,[PUSHJ P,CFHPO3]
	MOVN D,SOLNG
	SUB D,SWPOPR	;- # PGS GOING OUT
	ADDI D,10.	;MAKE SURE AT LEAST 10. GOING OUT
	JUMPLE D,.+2
	 ADDM D,SWPOPR
	MOVEI D,1
	SKIPN FLSINS(W)
	 MOVEM D,EPDL2(W)
	JRST CFHX

CFHPO3:	PUSH P,A	;FLSINS ROUTINE (NEEDED MEM)
	MOVE A,MEMFR
	SUB A,NCBCOM
	CAIL A,5(T)
	 JRST POPAJ1	;NEEDED MEM AVAILABLE
	ADD A,SOLNG
	ADD A,SWPOPR
	SUBI A,10.(T)
	JUMPGE A,POPAJ	;WILL EVENTUALLY WIN
	MOVNS A
	ADDM A,SWPOPR	;LOSING - SWAP SOME MORE STUFF OUT
	JRST POPAJ

CFF1:	MOVE C,CLKBRK
	TLNE C,%PCUSR
	 JRST 4,.	;BEING RPCLSRED IN USER MODE
IFE KL10P,[
	MOVSI D,1770
	ANDCAM D,UPQUAN(W)	;CLR PG FLT
	LPMR UPGML(W)
	CONO 470000+APRCHN	;CLR PDL OV + QT OV + MPV + NXM
]
	MOVE T,[BADBTS]
	IOR T,MSKST(W)
	AND T,A
	IORM T,PIRQC(W)
IFE KL10P,[
	CONO PI,CLKOFF
	JRST 10,UFL1
]
IFN KL10P, JRST UFL1

CFBO1:	MOVE E,MEMFR	;GUY SWAPPED BLOCKED
	SUB E,NCBCOM
	SUB E,AUSOPG
	SUB E,SILNG
	ADD E,SOLNG
	JUMPGE E,CFBO3	;SEEMS TO BE ROOM SO LET IT COME IN
	AOS NTSBUB
	MOVEI A,0	;HANG GUY UNTIL SWAP BLOCK GOES AWAY
	MOVE C,[SKIPGE USWSCD]
	ADDI C,(W)
	JRST CFHX

CFBO3:	AOS NTSBUP
	JRST CFBO2

CFH4:	JUMPL W,SWIILM
PFA7:	AOS T,CLKBRK
	TLNE T,%PCUSR
	 JRST CLKB1J
	MOVEI C,IOADCR		;FROM EXEC MODE SO RESET PC TO IOADCR
	EXCH C,CLKBRK
	MOVEM C,LEXFDR(U)	;AND SAVE FAULT EXEC ADR FOR DEBUGGING
	CLEARM DLSRCH		;IN CASE IT WAS SET
	CLEARM UMAPS(U)		;RESTORE NORMAL MAP IN CASE RANDOM ONE WAS IN USE
CLKB1J:	MOVEM D,LPFBTS(U)	;SAVE FOR DEBUGGING PURPOSES
IFE KL10P,	TLZE D,210	;NO ACCESS OR DBL
IFN KL10P,	CAIN D,%PFPNA
		 TRO A,%PIMPV	;ILM
IFE KL10P,	TLZE D,20	;PURE
IFN KL10P,	CAIN D,%PFPRO
		 TLO A,(%PIFET)
IFE KL10P,	TLZE D,100	;W IN RD ONLY
IFN KL10P,	CAIN D,%PFILW
		 TLO A,(%PIWRO)
		TDNE A,[%PIMPV\%PIWRO]
		 PUSHJ P,MPVMAS		;SAVE FAULT PAGE # FOR DEBUGGING
;NO ABORT-TYPE FAULTS, CHECK OTHERS
IFN KL10P,CLKB1Q:
IFN KL10P,	CAIN D,%PFMAR
IFE KL10P,	TLZE D,2
		 PUSHJ P,PCMARB
IFE KL10P,[	TLZE D,2000
		 PUSHJ P,CPROC1	;ONE PROCEED
		ANDCA D,UPQUAN(U)	;GET BITS FLUSHED BY TLZE'S
]			;END OF IFE KL10P
CFH6:
IFE KL10P,[
	ANDCMI D,-1	;DON'T CLOBBER USER'S RUNTIME.
	TLZ D,4		;DON'T CLOBBER EXEC PAGING FLAG.
	TLO D,1		;IGNORE QUANTUM-TIMEOUT INT.
	ANDCAM D,UPQUAN(U)
]
CLKB1K:	LPMR UPGML(U)
CLKB1G:	IFE KL10P,CONO 470000+APRCHN	;RESET
CLB1X:	MOVE T,[BADBTS]
	IOR T,MSKST(U)	;GET OR OF ENABLED AND BAD BITS
	AND T,A		;GET AND WITH BITS ACTUALLY ON
	JUMPE T,CLB1XA	;NOT BAD OR ENABLED, FORGET ABOUT IT
	IORM T,PIRQC(U)	;BLAME IT ON THE USER
	MOVE T,CLKBRK
	MOVEM T,UPC(U)
	JRST SCHED2

CLB1XA:	SKIPE FLSINS(U)
	 JRST SCHED	;INTERRUPT USER
	JRST CLKB5	;OR PROCEED HIM

IFE KL10P,[
CNLJL:	CONSZ 230220	;SKIP ON JUST "ADDR BREAK" (QUANTUM OVERFLOW)
	 JRST 4,.+1	;NULL JOB LOST
	CONO 470000+APRCHN
	JRST SCHED

CFHFPF:	MOVSI D,1770	;FALSE PAGE FAULT
	MOVEI A,0
	JRST CFH6
]
.ELSE CNLJL: JRST 4,.	;NULL JOB LOST
EBLK
RINT:	0
BBLK
	JRST 4,.+1	;RANDOM INT
	JRST 12,@RINT

EBLK
R1NTAC:	BLOCK 20
RINT1:	0
BBLK
	MOVEM 17,R1NTAC+17
	MOVEI 17,R1NTAC
	BLT 17,R1NTAC+16
	MOVEI J,1
	JSP E,SPUR
	MOVSI 17,R1NTAC
	BLT 17,17
	JRST 12,@RINT1

PCMARB:
IFE KL10P,[
	HLLZ B,UPOPC(U)	;FLAGS
	LSH B,5
	HRR B,UPOPC(U)	;PC
]
IFN KL10P,[
	MOVE B,CLKBRK	;PC OF FAULTING INST
;	MOVEM B,UPOPC(U)	;SOLELY FOR .OPC USER VAR
]
	TLNE B,%PCUSR
	 JRST PCMAR1		;USR MODE, USE PC FROM PAGER
	MOVE B,UUOH		;EXEC MODE, USE USER PC (UUO)
	SOS B
PCMAR1:	MOVEM B,UMARPC(U)
	TRO A,%PIMAR
	MOVEI B,0
IFE KL10P,	DPB B,[220300,,UPMAR(U)]	;DISABLE MAR
IFN KL10P,[	DPB B,[270400,,UPMAR(U)]	;DISABLE MAR
;		MOVSI B,%PSINH			;+ INHIBIT MAR BREAK WHEN PROCEED
;		IORM B,CLKBRK	;*** I THINK THIS IS UNNEC BECAUSE DDT HACKS IT - DAM
	  ]
	POPJ P,

IFE KL10P,[
CPROC1:	MOVE T,CLKBRK
	TLNN T,%PCUSR	;SKIP IF FROM USER MODE
	JRST CPRUUO
	TRO A,%PI1PR	;GIVE USER INTERRUPT
	POPJ P,

CPRUUO:	MOVE T,[JRST ONEPROC]	;ONE PROCEED INT. FROM EXEC. MODE
	MOVEM T,UEXIT	;CLOBBER EXIT TO RUN SYS CALL TO COMPLETION
	POPJ P,

AROV:	TLZE T,400000
	TLNN T,%PCUSR
	JRST AROV2	;NOT REALLY SET OR SET BY SYS
	MOVEM T,CLKBRK
	SKIPE PICLR(U)	;SKIP IF INTERRUPTS TO USER NOT ENABLED
	TRO A,%PIARO	;GIVE USER INTERRUPT
	POPJ P,

AROV2:	MOVEM T,CLKBRK
	POPJ P,

ARFOV:	TLZE T,40000
	TLNN T,%PCUSR
	JRST AROV2
	MOVEM T,CLKBRK
	SKIPE PICLR(U)
	TLO A,(%PIFOV)
	POPJ P,
];END IFE KL10P

;;; HANDLE PARITY ERRORS.

CLKB1E:	SETZM PARDIE	;AT FIRST ASSUME THE PAR ERR ISN'T FATAL.
	CONO PI,400	;TURN OFF WORLD
IFE KL10P,CONO PI,240000	;RESET
	MOVSI B,SCLPAR
	TDNE B,SUPCOR
	 JRST 4,.	;MAKING ERRORS IN REAL TIME
	IORM B,SUPCOR	;TELL SYS JOB TO PRINT OUR DATA WHEN WE FINISH.
	AOS PARERR	;COUNT # OF PAR ERRS SINCE SYSTEM STARTED.
	SETOM PARAND	;INIT LOGAND AND LOGOR OF ALL BAD DATA WORDS
	SETZM PARIOR
	SETOM PARAAN	;AND SIMILAR FOR ADDRESSES OF PAR ERRS.
	SETZM PARAOR
	MOVE T,CLKBRK
	MOVEM T,PARPC
	MOVE T,USER
	JUMPL T,PARSCJ	;PAR ERR IN NULL JOB? OR WHAT?
	MOVEM T,PARUSR	;REMEMBER WHICH JOB GOT THE PAR ERR.
	CAIG T,LUBLK
	 SETOM PARDIE	;PAR ERR IN A SUPERVISOR-MODE JOB IS HOPELESS.
	MOVSI TT,(%PIPAR)
IFN KL10P,SKIPN PARRSN	;PAR ERR IN WORD NOT REFERENCED DOESN'T SCREW THE RUNNING JOB.
	 IORM TT,PIRQC(T)	;GIVE RUNNING USER A PARITY ERROR (A CLASS 1 INTERRUPT)
PARSCJ:	SPM PARPG
IFN KL10P,[
	PUSH P,PFNPC	;MAKE SURE THE PAR ERRS WE DETECT WHILE SCANNING DON'T
	MOVEI D,PARFX4	;CALL US RECURSIVELY (ON KA, THAT'S DONE BY HAVING CLKCHN OFF)
	MOVEM D,PFNPC
]
	MOVEI D,0	;POINTER TO ERROR BUFFER
	MOVSI TT,-TSYSM
	PUSHJ P,PARSCN	;SCAN MAIN MEM BLOCKS
IFN PDP6P,[
	MOVE TT,[-LPDP6M,,PDP6BM_-10.]	;SCAN PDP6 MEM FOR PARITY ERRORS
	SKIPGE PDP6UP			;BUT NOT IF PDP6 IS DOWN.
	 PUSHJ P,PARSCN
]
IFN KL10P,[
	POP P,PFNPC
	CONO 024400+APRCHN	;CLEAR PAR ERR FLAGS.
]
	MOVEI A,0
	DPB A,[.PAREP+EXEUMP]
	LPMR PARPG	;SET UP MAP WITH PARPG SET TO MPV.
	MOVEM D,PARCNT	;SAVE AWAY COUNT OF ERRORS IN BUFFER
	SKIPE PARDIE
	JRST 4,.	;FATAL ERROR (DONT ALLOW CONTINUE SINCE ERR IS KNOW TO BE A LOSER)
	CONO PI,200	;TURN WORLD BACK ON
	JRST SCHED


PARSCN:
PARFX3:	HRRZ T,TT	;SCAN AOBJN POINTER IN TT
	CAIL T,TSYSM
	JRST PARFX7
	LDB T,[MUR,,MEMBLT(TT)]
	CAIN T,MUHOLE
	JRST PARFX8	;HOLE THERE
PARFX7:	MOVEI T,600000(TT)
	DPB T,[.PAREP+EXEUMP]
	LPMR PARPG	;SET UP TO CHECK PAGE # IN TT
PARFX1:
IFE KL10P,CONO PI,200000	;CLEAR PAR ERR
	MOVEI B,0	;ADDRESS WITHIN PAGE
PARFX5:	MOVE C,400000+PAREP*2000(B)	;REFERENCE EVERY MEMORY LOCATION
IFE KL10P,[
	CONSZ PI,200000	;PARITY ERR? ON KA, MUST CHECK EXPLICITLY.
	 JRST PARFX4	;YES.        ON KL, PAR ERR WILL TRAP RIGHT TO PARFX4.
]
	CAIGE B,1777	;SKIP ON FINISHED WITH BLOCK
	 AOJA B,PARFX5
PARFX8:	AOBJN TT,PARFX3	;CHECK NEXT PAGE
	POPJ P,		;DONE

PARFX4:
IFN KL10P,[
	HRRZ T,PFOPC	;DID THIS TRAP COME FROM SCAN LOOP WHERE WE EXPECT THEM?
	CAIE T,PARFX5
	 JRST 4,.
]
	SETO T,		;MAKE SURE T ISN'T ACCIDENTALLY 0 AT PARFX6.
	HRRZ E,TT
	LSH E,10.
	IOR E,B	;MAKE MEM ADR
	CAIGE E,20	;PAR ERR IN SHADOW ACS ISN'T SERIOUS.
	 JRST PARFX6
	ANDM E,PARAAN	;UPDATE ANDS AND ORS OF DATA AND ADRS
	IORM E,PARAOR
	ANDM C,PARAND
	IORM C,PARIOR
	MOVE A,USRHI
	CAIGE E,USRSTG(A)
	 SETOM PARDIE	;PARITY ERROR IN EXEC CORE
	HRRZ T,TT
	CAIL T,TSYSM
	 JRST PARFX6
	LDB T,[MUR,,MEMBLT(TT)]
	CAIE T,MUFR
	 CAIN T,MUINP
	  JRST PARFX6
	CAIE T,MUDISB
	 CAIN T,MUFRT
	  JRST PARFX6
	CAIN T,MUDDT
	 JRST PARFX6
	SOJE T,PARFX6	;USER
	SETOM PARDIE	;ERR IN CRITICAL MEMORY (DISK DIR, ETC)
PARFX6:	MOVEM C,400000+PAREP*2000(B)	;FIX UP MEMORY AS BEST WE CAN
	MOVEM C,PARCON(D)	;SAVE LOSING CONTENTS
	MOVEM E,PARADR(D)	;SAVE LOSING ADDRESS
	CAIL D,MXPARS-1	;OVERFLOWING BUFFER?
	 SOS D		;JUST DON'T CLOBBER STUFF. AT LEAST PARAND, ETC. WILL BE VALID.
	JUMPN T,PARFX9
	PUSH P,D	;PAR. ERR IN USER MEMORY,
	HRRZ D,TT
	CAIL D,TSYSM
	 JRST PARFXA
	PUSHJ P,UCPRL4	;HAS ANY JOB WRITTEN IN THIS PAGE?
	 400000,,PARFU1
	JUMPL D,PARFXB	;SOMEONE HAS; JUST GIVE EVERYONE AN INTERRUPT.
	PUSHJ P,UCPRL4	;DOES MMP SAY PAGE WAS WRITTEN? IF SO, SET SIGN(D);
	 200000,,PARFU2	;OTHERWISE, SET MMPBAD, CAUSING PAGE TO BE RELOADED FROM DISK.
	JUMPGE D,PARFXA
PARFXB:	PUSHJ P,UCPRL4	;PAGE HAS BEEN WRITTEN SINCE LAST ON DISK, SO WE CAN'T ESCAPE
	 400000,,PARFU3	;GIVING EVERY JOB AN INTERRUPT.
PARFXA:	POP P,D
PARFX9:	AOJA D,PARFX1

PARFU1:	CAIG U,LUBLK
	 JRST 4,.+1	;SYS JOB OR CORE JOB HAS PAGE
	PUSH P,Q
	MOVE A,I	;FIND PAGE-MPAP HALFWORD FOR THIS PAGE
	PUSHJ P,UPLC
	POP P,Q
	LDB A,T
	LSH A,-20
	CAIN A,1	;AND IF IT SAYS "READ-ONLY", MAKE PAGE APPEAR SWAPPED OUT
	 DPB A,T	;SO NEXT ACCESS WILL TRAP AND GO TO CFHPB - IN CASE WE WILL SET MMPBAD.
	CAIL A,3
PARFU4:	 TLO D,400000	;IF THIS JOB HAS WRITTEN THE PAGE, SET SIGN (D)
	POPJ P,		;TO SIGNAL THAT SETTING MMPBAD IS NO USE.

PARFU2:	MOVE T,(C)	;C HAS ADDR OF MMP ENTRY; HAS PAGE BEEN WRITTEN BY A JOB
	TLNN T,MMPWRT	;THAT NO LONGER HAS IT IN MAP?
	 TLNN T,MMPWOD	;OR HAS IT NEVER BEEN ON DISK?
	  JRST PARFU4	;IF SO, AVOID SETTING MMPBAD, AND INTERRUPT EVERYONE.
	HLRZ T,1(C)
	JUMPE T,PARFU4	;DITTO IF THERE IS NO DISK SPACE ASSIGNED.
	MOVSI T,MMPBAD
	IORM T,(C)
	POPJ P,

PARFU3:	MOVSI T,(%PIPAR)
	IORM T,PIRQC(U)
	POPJ P,

CLK1F:;	MOVEI J,APRCHN	;DO NOT TAKE THESE OUT WITHOUT SEEING RG!!!!
;	JSP E,SPUR
;	JRST SCHED
	AOS CHSPUR+APRCHN	;COUNT SPURIOUS INT
	JRST CLKB5


MEMHNG:
IFN PDP6P,[
	LDB B,[221100,,UPJPC(U)]	;FAULT ADDR
	TRZE B,400
	JRST MEMHN1
	HRRZ C,UDBR1(U)
	TRZE B,200
	HRRZ C,UDBR2(U)
	ROT B,-1
	ADDI C,(B)
	HRLI C,PMLCAD		;POINTER TO CORE ADR FIELD OF LH PAGE IN MAP WD
	SKIPGE B
	HRLI C,PMRCAD		;RH MAP WD
	LDB C,B	;C GETS PAGE #
	CAIGE C,<PDP6BM_-10.>+LPDP6M
	CAIGE C,PDP6BM_-10.
	JRST MEMHN1
	MOVE B,CLKBRK
	TLNE B,%PCUSR
	JRST MEMHN3	;USER MODE PDP6 NXM
	MOVEI B,IOCER3	;PDP6 MEM
	HRRM B,CLKBRK
	JRST MEMHN2
]

MEMHN1:	JRST 4,.+1	;NXM
MEMHN2:
IFE KL10P,CONO 10000+APRCHN	;CLEAR NON EX MEM AFTER HALT TO RESET MEMORY
IFN KL10P,CONO 22000+APRCHN
	MOVSI B,SCLNXM
	IORM B,SUPCOR
	MOVE T,CLKBRK
	MOVEM T,NXMPC
	MOVE T,USER
	MOVEM T,NXMUSR
	AOS NXMERR
	POPJ P,

IFN PDP6P,[
MEMHN3:	MOVSI B,%PIMPV	;PDP6 NXM GIVE MPV INTERRUPT
	IORM B,PIRQC(U)
	JRST MEMHN2
]

SUBTTL SLOW CLOCK SERVICE ROUTINE

SSLCK:	SKIPGE SHUTDN	;SYSTEM "DEAD" =>
	 PUSHJ P,COFFIN	;GO TO DDT AFTER RIGOR MORTIS SETS IN.
	SETCMB A,SCKPHS	;CHECK SYSTEM CHECKSUMS EVERY OTHER SLOW CLOCK TICK
	MOVEI T,SCRCKS	;WHICH IS ONCE PER SECOND.
	SKIPE A
	 IORM T,SUPCOR
IFN DPKPP,[
	CONSO DPK,7
	 CONO DPK,TTYCHN	;CROCK - IF DPK LOSES ITS PIA, GIVE IT BACK.
]
	MOVE A,UTTBF
	CAIGE A,30
	 JRST SSLCK2
	SETOM UTBFLF	;SIGNAL CORE JOB TO FLUSH UTAPE BUFFERS
	AOS NCORRQ
SSLCK2:	SKIPE UTTYCT	;SKIP IF NO NEW USERS
	 SKIPL TREESW	;SKIP UNLESS SOMEBODY'S MUNGING THE TREE STRUCTURE.
	  CAIA
	   PUSHJ P,USTART ;NEW USER TO START
IFN 340P,[
	SKIPL T,DWDS
	 MOVEI T,0
	ADDI T,MDISWD
	MOVEM T,DWDS	;RESET DISPLAY RATE COUNTER
]
	CONO PI,UTCOFF	;UTC OFF WHILE HACKING UTAPE, MTAPE, DISK, ETC.
IFN NUNITS,[
IFE NEWDTP,[
	MOVE T,TIME
	AOSN UIDLE	;SKIP IF DEC TAPE NOT IDLE
	 JRST [MOVEM T,LUTOTM ? JRST SSLCK1]	;DEC TAPE IDLE
	SUB T,LUTOTM	;SUBTRACT LAST UTC OPERATION TIME
	CONSO UTC,4000
	 CAIGE T,MXOPT*SCLKI	;SKIP IF DEC TAPE HUNG TOO LONG ON ONE OPERATION
	  JRST SSLCK3	;OK
	SETOM UTHERR	;SET UTC HUNG ERR FLAG
SSLCK1:	CONO UTC,CUINT	;CAUSE DEC TAPE INTERRUPT ROUTINE TO RUN
SSLCK3:
]
IFN NEWDTP,[
	MOVE T,TIME
	AOSN UIDLE
	 JRST [MOVEM T,LUTOTM ? JRST SSLCK1]
	SUB T,LUTOTM
	CAIGE T,MXOPT*SCLKI
	 JRST SSLCK3
	SETOM UTHERR
SSLCK1:	SETOM CUINT
	CONO PI,UTCRQ
SSLCK3:
]]	;END IFN NUNITS

IFN RP10P+RH10P,PUSHJ P,QSTRT1
IFN DC10P,	CONO DC0,DCSET+DCIENB+DSKCHN	;ACTIVATE IDLE
IFN NMTCS,	PUSHJ P,MSTRTR
	CONO PI,UTCON
;FALLS THROUGH

;FALLS THROUGH
IFG NMTYS,[			;TRY TO UNHANG MORTON TTY CARDS
	MOVE I,[-NMTYS,,NFMTY]
	MOVE T,TIME
	SUBI T,60.	;IF HAVEN'T TYPED FOR 2 SECONDS
SSLCM1:	SKIPL TTYOAC(I)	;YET SUPPOSED TO BE TYPING
	 CAMGE T,TTLTM(I)
	  JRST SSLCM2
	CONO PI,TTYOFF-1
	CONO MTY,@TTYLT(I)	;SELECT THE LINE
	DATAO MTY,[0]		;AND BANG ON IT
	CONO PI,TTYON-1		;MAYBE IF WE'RE LUCKY ITS DONE FLAG WILL COME ON 
SSLCM2:	AOBJN I,SSLCM1
]		;END IFG NMTYS
IFN NETP,[
IFE DMI,CONI IMP,IMPCNI	;KEEPS HOST READY ON
	PUSHJ P,IMPOST	;START UP OUTPUT
	SKIPLE IMNCS
	 PUSHJ P,IMPCCL	;CLOSE NETWORK CHANNELS
];DROPS THROUGH

;DROPS IN
IFN PDP6P,[
	SKIPL PDPISR
	 CONO DSDEV,DSDCHN	;ENABLE INTERRUPTS FROM 6
]
IFN N11TYS,[
;SEE IF THE TV PDP11 WANTS TO GO DOWN.
	SKIPN TEN11F	;PROVIDED THE PDP11 IS THERE,
	 SKIPN TT11P	;AND WE'RE TRYING TO USE IT,
	  JRST SSLCK5
	LDB A,[061600,,TT11HA]	;DOES 11 WANT WHO LINES UPDATED?
	SKIPGE 1+400000+TTPG0*2000(A)
	 JRST [	MOVEI T,SCRWHO	;YES
		IORM T,SUPCOR
		CLEARM 1+400000+TTPG0*2000(A)
		JRST .+1]
	SKIPE TT11DN	;IF IT IS REQUESTING TO GO DOWN,
	 JRST SSLCK5
	SETZM TT11P	;DON'T USE IT & WAIT FOR IT TO RE-INIT,
	MOVSI T,1
	MOVEM T,TT11DN	;GIVE IT OUR PERMISSION TO GO DOWN.
	MOVEI T,SCR11D	;CAUSE "11 DOWN" MESSAGE
	IORM T,SUPCOR
SSLCK5:	SKIPN TEN11F
	 SKIPG TT11P	;WAITING FOR 11 TO BE UP?
	  JRST SSLCK6
	SKIPN TT11UP	;SKIP ON 11 UP
	 JRST SSLCK6
	MOVEI T,SCR11U
	IORM T,SUPCOR	;INIT THE TTYS
SSLCK6:
]
;FALLS THROUGH

;FALLS THROUGH
IFN DL10P,[
	SKIPN DL10F
	 JRST SSLCKA
	SETZM DL10UP
	SETZM DL10DN
	DATAI DLC,A
	TRNE A,20	;SEE IF PDP11 HALTED.  (WHAT ABOUT RUG BREAKPOINTS?)
	 JRST SSLCKA
	PUSHJ P,SYSMSG
	    400000,,[ASCIZ|I/O PDP11 WENT DOWN|]
	SETZM DL10F
SSLCKA:	]
	AOS QACTTM
	SKIPE SWPOPR
	 JRST SSKQ2
	MOVN A,LMEMFR
	ADDI A,10.
	SKIPLE A
	 ADDM A,SWPOPR	;INADEQUATE SPACE IN LOW HALF, SWAP OUT TO MAKE ROOM
SSKQ2:
IFN 340P,[
	SKIPL DISUSR
	 PUSHJ P,DISCHK	;CHECK FOR 340 DEATH
]
	PUSHJ P,PDCCHK	;CHECK ON REAL-TIME HACKS
IFN PTRP,[
	PUSHJ P,PTRCHK	;CHECK ON PAPER TAPE READER
	PUSHJ P,PTPCHK	;CHECK ON PAPER TAPE PUNCH
]
	SKIPN CCSDEV
	 JRST SCDCK3
	SETZM CCSDEV
	MOVSI I,-128.
SCDCK1:	SKIPGE A,DCHNTC(I)
	 TLNE A,300000
	  JRST SCDCK2
	AOS CCSDEV
	SUB A,[1,,]
	TLNN A,777
	 TLZ A,400000
	MOVEM A,DCHNTC(I)
SCDCK2:	AOBJN I,SCDCK1
SCDCK3:;	JSP E,CHECK	;CHECK FOR CLOBBERED DEVICES
;DROPS THROUGH

;DROPS IN
ALCR0:	MOVE E,[ALCR1,,A]
	BLT E,E
	MOVSI U,-NCT
	JRST A

ALCR1:	MOVN T,USRRCE(U)	;A
	ASH T,-4		;B
	ADDM T,USRRCE(U)	;C
	AOBJN U,A		;D
	JRST .+1		;E

	MOVN T,USRRCE+NCT
	ASH T,-4-2	;DISOWNED JOBS
	ADDM T,USRRCE+NCT
	MOVN T,USRRCE+NCT+1
	ASH T,-4+1	;SYS AND CORE JOBS
	ADDM T,USRRCE+NCT+1
	MOVEI T,0
	MOVE W,[ALCR4,,A]
	BLT W,W
	JRST A

ALCR4:	MOVN H,JTMU(T)	;A
	ASH H,-4
	ADDM H,JTMU(T)
	MOVE H,MSKST(T)
	ANDI H,%PICLK	;E
	SKIPE UNAME(T)	;TT
	 IORM H,PIRQC(T);I
	ADDI T,LUBLK	;Q
	CAMGE T,USRHI	;J
	 JRST A		;R
	JRST .+1	;W

	SKIPGE 37	;CHECK FOR PLANNED SYSTEM DEATH
	 PUSHJ P,DEATH	;ABOUT TO START DYING
	  JFCL
	MOVE A,NULTM1	;ROLL NULJOB MICROSECONDS
	IDIV A,[1000000.]	;CONVERT TO SECONDS
	ADDM A,NULTM3	;STORE AS NULTIME SECONDS
	IMULI A,60.	;CONVERT TO 60THS
	ADDM A,NULTIM	;ADD TO 60THS USED
	MOVEM B,NULTM1	;SAVE REMAINDER
	MOVE A,USRTM1	;GET USER TIME (4 USEC TICKS)
	IDIVI A,250000.	;CONVERT TO SECONDS
	ADDM A,USRTIM
	MOVEM B,USRTM1	;SAVE REMAINDER FOR NEXT TIME
	MOVEI T,SCLKI
	MOVEI C,SSLCKB
	JRST CLQREE	;RE-ENTER RQ FOR SLOW CLOCK BREAK

VSSLCK:	MOVSI T,SCLVSK
	IORM T,SUPCOR	;CAUSE VERY SLOW CLOCK TO RUN
	MOVEI T,VSCLKI
	MOVEI C,VSLCKB
	JRST CLQREE

IFN CCLKP,[
RCCLK:	DATAI 374,T	;HACK CHESS CLOCK
	TRNE T,4000
	 AOSA CCLK1
	  AOS CCLK2
	MOVEI T,6
	MOVEI C,CCLKB
	JRST CLQREE
]

IFN N11TYS,[
WHOSET:	MOVEI T,SCRWHO	;CAUSE SYS TO UPDATE WHO LINES
	IORM T,SUPCOR
	MOVEI T,5.*60.
	MOVEI C,WHOCLB
	JRST CLQREE
]

;SYSTEM IN FINAL THROES OF COMING DOWN, SEE IF IT'S OVER YET

COFFIN:	SKIPGE QSGL+NQCHN	;DW CHANNEL ACTIVE
	 SKIPL QSDU		;OR DISK RUNNING
	  POPJ P,
	MOVSI T,040000
	MOVE TT,QACTB	;SEE IF DISK STUFF NOT OUT YET
	TDNE TT,QMDRO
	 POPJ P,	;MFD NOT OUT
	MOVSI A,-NQS
COFFI8:	TDNE T,QTUTO(A)
	 JRST COFFI9	;TUT NEVER CAME IN
	TDNE TT,QTUTO(A)
	 POPJ P,	;TUT NOT OUT
COFFI9:	AOBJN A,COFFI8
	MOVSI A,-QNUD
COFFI1:	SKIPN QSNUD(A)
	 JRST COFFI2
	TDNE TT,QSNLCN(A)
	 POPJ P,	;UFD NOT WRITTEN
COFFI2:	AOBJN A,COFFI1

IFN NUNITS,[
	MOVSI A,-NUNITS
	SKIPGE UFLAPF(A)
	 POPJ P,	;TAPE STILL FLAPPING
	AOBJN A,.-2
]

	MOVE A,SYSCN	;SYSTEM CONSOLE STILL TYPING OUT
	SKIPL TTYOAC(A)
	 JUMPGE A,CPOPJ

	MOVEI A,2*LUBLK
COFFI7:	CAML A,USRHI
	 JRST [	JSR GODDT	;SYSTEM FULLY DOWN; GO TO DDT.
		POPJ P, ]
	SKIPE UNAME(A)
	 POPJ P,	;JOBS STILL EXIST
	ADDI A,LUBLK
	JRST COFFI7

EBLK

GODDT:	0		;JSR GODDT TO CALL DDT.
BBLK
	JRST DDT

XDDT=JRST 2,@GODDT	;XDDT$X TO RETURN FROM DDT ENTERED VIA GODDT

XREVIV=JRST .		;XREVIV$X TO RETURN FROM DDT AND REVIVE SYSTEM
	SETZM SHUTDN
	SETZM DEDTIM
	XDDT

IFN 340P,[

DISCHK:	SKIPGE DISOFF
	POPJ P,
	AOSLE DISDIE
	SKIPGE CDISOFF
	POPJ P,
	MOVEI T,1
	MOVEM T,DTIME
DISZAP:	MOVE T,[JSR DBLKPB]
	MOVEM T,40+2*DISCHN
	MOVEI T,DIS300-1	;CAUSE 340 TO STOP AND INTERRUPT SOON
	MOVEM T,DBLKOP
	CLEARM DISOFF
	CONO DIS,5100+SDCHN_3+DISCHN
	POPJ P,
]

DEATH:	SKIPL SHUTLK
	POPJ P,
	SETZM 37	;CLEAR START DYING FLAG
	MOVEI T,60.*5.*60.	;5 MIN
	MOVEM T,DEDTIM
	LSH T,-1
	ADD T,TIME
	MOVEM T,SHUTDN
	PUSHJ P,CLQDEL
	 DEDBLK
DEATHX:	SKIPN T,DEDTIM
	POPJ P,
	AOS (P)
	MOVEI TT,0
	CAIGE T,40.*60.
	JRST DEATHY
	MOVE TT,T
	LSH TT,-2
DEATHY:	MOVEM TT,DEDTIM
	SUB T,TT
	PUSHJ P,CLQADD
	 DEDBLK
DEATHM:	MOVEI A,%PIDWN
	PUSHJ P,INTALL	;TELL THE WORLD
	MOVSI T,SCLSHD	;CAUSE TYPE OUT ON UNLOGGED-IN CONSOLES
SUPSET:	IORM T,SUPCOR
	POPJ P,

;15 SECOND CLOCK
15SCLK:
IFN NETP,	PUSHJ P,IMRSTO	;RESET CONTROL LINK RFNM WAIT FOR LOSING IMP.
	MOVSI B,100000	;SET UP TO CLEAR "BEST EFFORT TO SWAP OUT BIT"
	SETOM SBEFLG	;NOT YET DESPERATE ENOUGH TO TRY USERS WHOSE BEST EFFORT BITS ARE SET
	CLEARB T,NUSWB	;# USERS LOCKED OUT
	SETOM BUSR	;SMALLEST SWAPPED BLOCKED USER
	MOVE D,[37777,,777777]
	MOVEM D,BUSIZ	;SIZE OF SMALLEST SWAP-BLOCKED USER.
	CLEARM ASBUM	;REAL MEM OCC BY ACTIVE SWAPPED BLOCKED LOSERS
	MOVSI D,400000	;TO CLEAR SWAPPED BLOCKED BIT
15S1:	CAML T,USRHI
	JRST 15S2
	SKIPN UNAME(T)
	JRST 15S3
	MOVN C,USWPRI(T)
	ASH C,-2
	ADDM C,USWPRI(T)	;DECAY JOB SWAP PRI'S
	MOVE C,NMPGS(T)
	SUBI C,1	;COMPENSATE FOR PAGE ZERO ALWAYS IN
	CAMLE C,NSWPGS(T)	;SKIP ON NOT COMPLETELY OUT
	ANDCAM B,USWST(T)
	SKIPGE USWSCD(T)
	JRST 15S4	;CLEAR SWAPPED BLOCK BIT AND MAYBE ADD TO AUSOPG AND TRUMM (IF HE WAS HUNG ON IT)
15S3:	ADDI T,LUBLK
	JRST 15S1

15S2:IFN SWBLK,	PUSHJ P,SWSCD	;SWAP BLOCK LOSERS IF NECESSARY
	MOVSI T,-NCT-2
15S5:	MOVN C,SWRCE(T)	;DECAY TREE SWAP PRI'S
	ASH C,-2
	ADDM C,SWRCE(T)
	AOBJN T,15S5
	MOVEI T,15.*60.
	MOVEI C,15SCLB
	JRST CLQREE

15S4:	ANDCAM D,USWSCD(T)	;CLEAR SWAP BLOCK BIT
	SKIPN TT,FLSINS(T)	;WAS HE HUNG TESTING IT
	JRST 15S3
	SUBI TT,(T)
	CAME TT,[SKIPGE USWSCD]
	JRST 15S3	;HE WASN'T HUNG ON THIS
	CLEARM FLSINS(T)	;HE WAS SO NOW HES ACTIVE
	MOVE TT,NMPGS(T)
	ADDM TT,TRUMM	;GUY IS NOW RUNNABLE
	SUB TT,NSWPGS(T)	;ANY PAGES HE MAY HAVE IN MEM NO LONGER BELONG TO A BLOCKED USER
	MOVNS TT
	ADDB TT,BUMPGS
	SKIPGE TT
	CLEARB TT,BUMPGS
	MOVE TT,NSWPGS(T)	;ANY SWAPPED OUT PAGES BELONG TO AN ACTIVE USER
	ADDM TT,AUSOPG
	JRST 15S3
IFE SWBLK,[
PRVCLK:	MOVSI B,4000
	SKIPL U,PRVUSR
	 ANDCAM B,USWST(U)
	SETOM PRVUSR	;TURN OFF CURRENT PRIVILEDGED USER
	MOVEI J,2*LUBLK
PRVCK1:	CAML J,USRHI
	 JRST PRVCK2
	SKIPN UNAME(J)
	 JRST PRVCK3
	MOVE B,UTRNTM(J)	;GET USER RUN TIME
	SUB B,LTRNTM(J)
	MOVE A,USIPRQ(J)
	SUB A,LSIPRQ(J)
	IMUL A,[NPVSEC*125000.]	;1/2 NUMBER OF 4 MICROSECOND INTERVALS IN THE PRIV INTERVAL
	SKIPE B
	 IDIV A,B
	MOVE B,UPGSEC(J)
	LSH B,-1		;DIVIDE LAST VALUE BY TWO
	ADD A,B
	MOVEM A,UPGSEC(J)	; LAST/2 + CURRENT
IFE KL10P,[
	MOVE A,UTRNTM(J)
	MOVEM A,LTRNTM(J)
]
IFN KL10P,MOVEM C,LTRNTM(J)
	MOVE A,USIPRQ(J)
	MOVEM A,LSIPRQ(J)	;SAVE OLD VARIABLES
PRVCK3:	ADDI J,LUBLK
	JRST PRVCK1

PRVCK2:	PUSHJ P,NPRVUS	;GET NEXT PRIV USR
	MOVEI T,NPVSEC*60.
	MOVEI C,PRVCLB
	JRST CLQREE

NPRVUS:	MOVEI J,2*LUBLK
	SETOM U
	MOVNI T,30.*2	;DON'T LET A BLOCKED OR STOPPED PERSON BE PRIVILEDGED
	ADD T,TIME
	MOVE B,PRVCUT
	HRLOI E,377777
NPVUS1:	CAML J,USRHI
	JRST NPVUS2
	CAMGE T,LUBTM(J)	;BLOCKED TOO LONG?
	SKIPN UNAME(J)
	JRST NPVUS3
	CAMG B,UPGSEC(J)
	CAMG E,LPRVTM(J)
	JRST NPVUS3
	MOVE U,J
	MOVE E,LPRVTM(J)
NPVUS3:	ADDI J,LUBLK
	JRST NPVUS1

NPVUS2:	MOVEM U,PRVUSR
	SKIPG U
	POPJ P,
	MOVSI B,4000
	IORM B,USWST(U)
	MOVE T,TIME
	MOVEM T,LPRVTM(U)
	POPJ P,
]

SUBTTL SCHEDULER AND SWAPPER

SWSCD:	MOVE E,TRUMM	;SEE IF NECESSARY TO SWAP BLOCK SOMEONE
	CAIGE E,SYSUSM-SYSB-40
	POPJ P,	;NO SHOULD FIT
	MOVE E,MEMFR
	SUB E,NCBCOM
	ADD E,SOLNG
	SUB E,SILNG
	SUB E,AUSOPG
	ADD E,BUMPGS	;WILL SWAP OUT BLOCKED USERS FIRST
	ADD E,ASBUM
	SUBI E,20	;SLOP
	JUMPGE E,CPOPJ	;SHOULD HAVE ROOM FOR EVERYBODY
	MOVMM E,SWSCT1	;SAVE # PGS REQ
	MOVNI E,1	;NEED TO GRONK USER (MAYBE)
	CLEARB T,TT	;TT SWP PRI OF PROCESS
	MOVEI R,0	;R SWP PRI OF TREE
SWSCP1:	CAML T,USRHI
	JRST SWSCP2
	SKIPE UNAME(T)
	SKIPE USTP(T)
	JRST SWSCP7
	SKIPGE USWSCD(T)
	JRST SWSCP7	;GUY ALREADY LOCKED OUT
	SKIPE FLSINS(T)
	JRST SWSCP4	;SEE IF REALLY BLOCKED OR JUST PAGE WAIT
SWSCP5:	MOVE B,UTMPTR(T)
	CAML R,SWRCE-USRRCE(B)
	CAMG TT,USWPRI(T)
	JRST SWSCP6	;THIS GUY A BIGGER LOSER THAT PREV BIGGEST
SWSCP7:	ADDI T,LUBLK
	JRST SWSCP1

SWSCP6:	MOVE E,T
	MOVE R,SWRCE-USRRCE(B)
	MOVE TT,USWPRI(T)
	JRST SWSCP7	;GUY REALLY BLOCKED

SWSCP4:	MOVE B,USWST(T)
	TLNE B,200000
	JRST SWSCP5
	JRST SWSCP7


SWSCP2:	JUMPL E,CPOPJ	;NO VICTIM
	MOVE B,NMPGS(E)
	CAIGE B,SYSUSM-SYSB-30
	JRST SWSCP9	;"SMALL LOSER"
	SUB B,NSWPGS(E)
	CAMLE B,SWSCT1	;SKIP ON WILL STILL NEED TO BLOCK MORE LOSERS
	POPJ P,
SWSCP9:	MOVSI B,400000
	IORM B,USWSCD(E)	;SWAP BLOCK LOSER
	AOS NUSWB
	AOS NTUSB
	MOVE TT,NMPGS(E)
	CAMLE TT,BUSIZ
	JRST SWSCP8
	MOVEM TT,BUSIZ
	MOVEM E,BUSR
SWSCP8:	SUB TT,NSWPGS(E)
	SOSGE TT
	MOVEI TT,0
	ADDM TT,ASBUM	;THIS GUY SWAPPED BLOCKED
	MOVN TT,NMPGS(E)
	ADDM TT,TRUMM	;DOESNT COUNT ANY MORE
	SKIPGE TRUMM
	CLEARM TRUMM
	MOVN TT,NSWPGS(E)
	ADDM TT,AUSOPG	;NOT REALLY ACTIVE ANY MORE
	JRST SWSCD	;SEE IF THATS ENUF
;
; USER SCHEDULER
;
SCHED:	SKIPGE U,USER
	 JRST SCHED9
	MOVE T,CLKBRK
	MOVEM T,UPC(U)
	SETZM SCHMNY
	SKIPA
SCHED2:	 SETOM SCHMNY	;ENTERED FROM UFLS OR PAGE FAULT, CHECK FOR AUXIL PERSON TO RUN
	AOS NSKED
	MOVSI T,UEXIT	;GET HERE FROM CLUFLS
	HRRI T,UUO(U)
	BLT T,SUEXND-1(U)
IFN N11TYS,[
	SKIPGE TT11P
	 SKIPE TEN11F
	  JRST SSTVR1		;DONT HACK 11
	SKIPL TVCREG(U)		;DO WE WANT TO SAVE TV CONSOLE REG FOR THIS GUY?
	 SKIPN T,400000+TTR10*2000 ;0 IS NOT A (VERY) LEGITIMATE CONSOLE REG FCN
	  JRST SSTVR2		;SO ASSUME 11 STOPPED, DONT CLOBBER PREV THING
	MOVEM T,TVCREG(U)
SSTVR2:	SKIPGE T,TVVBN(U)	;DID WE SET RUNNING BLINKER FOR THIS GUY?
	 JRST SSTVR1		;NO
	MOVEM T,400000+TTR10*2000	;SET TO VIDEO BUFFER WE SET IT IN
	MOVE A,TVBLAD		;ADDR IN VIDEO BUFFER WE FLASHED
	CLEARM 400000+TTR0*2000(A)	;CLEAR IT
SSTVR1:]
IFE KL10P, LDB A,[022100,,UPQUAN(U)]	;GET TIME USED IN 4.069 USEC UNITS
IFN KL10P,[
	CAMN U,MTRJOB		;IF LEAVING JOB BEING METERED, STOP METER AND
	 WRPAE PAEOFF
	CAMN U,MTRJOB		;STOP THE TIME BASE.
	 CONO MTR,4000
	DMOVE A,MBOXCT(U)	;COMPUTE EQV CPU TIME FROM MBOX+EBOX ACCT
	DMUL A,KLMBCC
	DADD B,EBOXCT(U)
	DMUL B,KLEBCC
	MOVE A,D
	SUB A,UTRNTM(U)		;GET INCREMENTAL RUNTIME
]
	ADDM A,USRTM1		;SYSTEM TOTAL USER RUN TIME
	ADDM A,UTRNTM(U)	;INCREASE RUN TIME
	ADDM A,JTMU(U)		;DECREASE PROCEDURE PRIORITY
	MOVEI B,1000.(A)	;ACCOUNT FOR OVERHEAD IN STARTING UP
	ADDM B,@UTMPTR(U)	;DECREASE PROCEDURE TREE PRIORITY
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	IMUL T,A
	MOVE Q,UTMPTR(U)
	ADDM T,USWPRI(U)	;CHARGE AGAINST SWAPPINNG PRI
	ADDM T,SWRCE-USRRCE(Q)	;AND FOR TREE
	MOVE B,A
	LSH B,-4	;GET RUNTIME IN 64 USEC UNITS
	CAILE B,1777
	MOVEI B,1777	;TO FIT IN SCHEDULER HISTORY TBL
	MOVE C,USWST(U)
	SKIPE FLSINS(U)
	TLNN C,200000
	CAIA
	TRO B,2000	;BLOCKAGE DUE TO PAGE FAULT
	DPB B,[301300,,@SCHHP]	;COMPLETE SCHEDULER HISTORY TBL ENTRY
	SKIPL Q,RTIMER(U)	;SKIP UNLESS RUNTIME INT ACTIVE
	JRST SEARRT
SCHED3:	SKIPGE DLSRCH
	JRST SEAREP	;DELETE SEARCH, EXIT
	IFN SCHBLN,[
	SKIPE SCHMNY
	JRST SCHED4
]SEARL0:	CLEARM TRUMM	;TOTAL RUNNABLE USER MEM
	CLEARM AUSOPG	;ACTIVE USER SWAPPED OUT PAGES
	CLEARM BUMPGS	;PAGES IN REAL CORE BELONGING TO BLOCKED USERS
	CLEARM ASBUM	;PGS IN REAL MEM OCC BY SWAPPED BLOCKED LOSERS
	SKIPL A,SWOUPG
	PUSHJ P,SWPUP
	SKIPN SWPOPB
	SKIPE SWPOPR
	PUSHJ P,SWPON	;SWAP OUT STUFF
IFN NSWPV,[
	SKIPGE CIRPSW
	PUSHJ P,SWPPIN	;SERVICE SWAPPING VARIABLES
]
	SETZB U,J	;JOB BEING SCHEDULED
	SETOM I		;BEST USER SO FAR
	SETZM RNABLU	;NUM RUNABLE USERS
	JRST SEARL1

SEARRT:	SUB Q,A
	MOVEM Q,RTIMER(U)
	JUMPGE Q,SCHED3
	MOVSI T,(%PIRUN)	;GIVE RUNTIME INTERRUPT
	IORM T,PIRQC(U)
	JRST SCHED3

;MAIN SEARCH LOOP, RETURN HERE TO EXAMINE NEXT PROCEDURE
SEARL:	MOVEI U,LUBLK	;LENGTH OF USER VAR BLOCK
	ADDB U,J	;STEP TO NEXT USER
	CAML U,USRHI	;SKIP IF EXISTS
	 JRST SEAREN	;ALL PROCEDURES HAVE BEEN EXAMINED
SEARL1:	SKIPE T,USTP(U)
	 JRST SEARS1	;EMPTY OR STOPPED JOB SLOT
	SKIPE A,PIRQC(U)
	 JRST SEAR2A	;FIRST WORD INTERRUPT PENDING
SEARL2:	SKIPE B,IFPIR(U)
	 JRST INTWD2	;SECOND WORD INTERRUPT PENDING
SEARL3:	SKIPN FLSINS(U)
	 JRST SEARC	;NOT BLOCKED
SEARL4:	MOVE T,EPDL2(U)
	XCT FLSINS(U)	;TEST BLOCKING CONDITION (MAY SKIP ONCE OR TWICE)
	 JRST SEARLB	;UNRUNABLE
	 JRST SEARC	;LOW PRIORITY UNBLOCK
	 SKIPA Q,[-1]	;HIGH PRIORITY UNBLOCK
	  MOVEI Q,3	;EXTRA LOW PRIORITY
	JRST SEARC2

IFN SCHBLN,[
SCHED4:	SETZM SCHMNY
	HLRZ U,UREALT
	SKIPN U
	 JRST SEARL0
	PUSHJ P,SCHGB
	SKIPGE U
	 JRST SEARL0
	PUSHJ P,SCHACK
	 JRST SCHED4
	MOVE I,U
	SETOM SCHMNY
	JRST SEAREN
]

SCHED9:			;ACCUMULATE NULL TIME IN 1.0 USEC UNITS
IFE KL10P,[
	LDB A,[2300,,UPQUAN]
	ADDM A,NULTM1
]
IFN KL10P,[
	CAMN U,MTRJOB
	 WRPAE PAEOFF
	CAMN U,MTRJOB
	 CONO MTR,4000
	REBOXC A	;COMPUTE NULL JOB'S EQUIVALENT RUNTIME IN 4 USEC UNITS
	DSUB A,NULEBC
	RMBOXC C
	DSUB C,NULMBC
	DMUL C,KLMBCC	;CONVERT MBOX COUNT TO EBOX COUNTER UNITS,
	DADD A,D	;ADD TO EBOX COUNT
	DMUL A,KLEBCC	;CONVERT TO 4 USEC UNITS.
	LSH C,2
	ADDM C,NULTM1	;FOR SOME REASON, NULTM1 IS IN USEC.
]
	JRST SEARL0

SEARC:	SETZM Q		;SET TO NORMAL PRIORITY
	PUSHJ P,UPRIVL
	SOJA Q,SEARC2
	JRST SEARC2
	SKIPGE APRC(U)
	ADDI Q,2	;DISOWNED
SEARC2:	AOS RNABLU	;ANOTHER RUNABLE USER
	MOVE T,TIME
	MOVEM T,LUBTM(U)	;RECORD LAST TIME UNBLOCKED
	SKIPGE USWSCD(U)
	JRST SEARC7	;HE'S SWAPPED BLOCKED SO HE DOESNT COUNT
	JUMPE U,SEARC4	;DON'T FIGURE SYSTEM JOB.
	MOVSI T,400000
	ANDCAM T,USWST(U)	;RUNNABLE SO NOT DESIRED OUT
	MOVE T,NMPGS(U)
	ADDM T,TRUMM	;TOTAL RUNNABLE USER MEM
	MOVE T,NSWPGS(U)
	ADDM T,AUSOPG	;TOTAL PAGES OF RUNNABLE USERS SWAPPED OUT
SEARC4:	CAMN U,UREALT
	JRST SEARP2	;JUMP IF SCHEDULING REAL TIME USER IN HIGH PRIORITY PHASE
	JUMPL I,SEARC5
	CAMN I,UREALT
	JRST SEARL	;JUMP IF REAL TIME USER SCHEDULED
SEARC5:	SKIPLE T,URTIME(U)	;NON SKIP IF POSSIBLE REAL TIME BLOCK
	TLNN T,1	;SKIP IF REAL TIME BLOCK UNLESS PI IN PROGRESS
	JRST SEARC6
	SKIPGE PICLR(U)	;SKIP IF PI IN PROGRESS
	JRST SEARL	;REAL TIME BLOCKED
SEARC6:	MOVE T,@UTMPTR(U)	;GET AMOUNT OF MACHINE TIME USED RECENTLY BY TREE PROCEDURE IS IN
	ASH T,(Q)	;LARGER C(T)= LOWER PRIORITY; INCREASE PRIORITY IF Q INDICATES
	JUMPL I,SEARP1	;FIRST NON-NULL JOB
	CAMG T,U0P
	JRST SEARP3	;JUMP IF USER BEING CONSIDERED HAS LOWER USRRCE (HIGHER PRIORITY)
	MOVE A,JTMU(U)	;USER HAS LESS PRIORITY, BUT MAY RUN ANYWAY IF JTMU'S DIFFER BY ENUF
	ASH A,3(Q)	;MULTIPLY BY 8+Q
	CAML A,U0PP	;DOES JOB HAVE LESS THAN 1/8 OF BEST SO FAR MACHINE TIME?
	JRST SEARL	;DOESNT MAKE IT
SEARP5:	MOVE A,JTMU(U)
	ASH A,(Q)
	MOVEM T,U0P	;STORE TIME USED RECENTLY BY TREE
	MOVEM A,U0PP	; " BY PROCEDURE
SEARP2:	MOVEM U,I	;NEW BEST USER SO FAR
IFN SCHBLN,	PUSHJ P,SCHSB
	JRST SEARL	;TRY NEXT

SEARC7:	MOVE T,NMPGS(U)	;RUNNABLE AND SWAPPED BLOCKED
	SUB T,NSWPGS(U)
	SOSGE T
	MOVEI T,0
	ADDM T,ASBUM
	JRST SEARC4

SEARLB:	JUMPE U,SEARL	;DON'T FIGURE SYSTEM JOB
	MOVE T,USWST(U)
	SKIPL USWSCD(U)	;IF LOCKED OUT, DONT COUNT
	TLNN T,200000
	JRST SEARB1	;NOT WAITING FOR PAGE
	MOVE T,NMPGS(U)	;USER IS WAITING FOR PAGE SO COUNT FOR ACTIVE
	ADDM T,TRUMM
	MOVE T,NSWPGS(U)
	ADDM T,AUSOPG
	JRST SEARL

SEARB1:	TLNE T,100000
	JRST SEARL	;HAVE MADE BEST SWAPOUT EFFORT
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	SOSGE T
	MOVEI T,0
	ADDM T,BUMPGS	;REAL MEM PGS BELONGING TO BLOCKED USERS
	JRST SEARL

SEARS1:	SKIPN UNAME(U)
	JRST SEARL
	MOVE T,USWST(U)	;GUY STOPPED, DOES HE HAVE PAGES IN REAL MEM?
	TLNE T,100000
	JRST SEARL	;HAVE TRIED BEST EFFORT TO SWAP OUT
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	ADDM T,BUMPGS
	JRST SEARL

IFN SCHBLN,[
SCHACK:	SKIPN USTP(U)	;ALL THINGS THAT MAKE A PERSON UNRUNABLE
	SKIPE PIRQC(U)
	POPJ P,
	CAML U,USRHI
	POPJ P,
	SKIPN IFPIR(U)
	SKIPE FLSINS(U)
	POPJ P,
	SKIPLE T,URTIME(U)
	TLNN T,1
	SKIPA
	SKIPLE PICLR(U)
	AOS (P)
	POPJ P,

SCHSB:	MOVE T,SCHBPT	; STORE NEXT BEST PERSON
	MOVEM I,(T)
	AOBJN T,.+2
	MOVE T,[-SCHBLN,,SCHBTB]	;RING AROUND
	MOVEM T,SCHBPT
	POPJ P,

SCHGB:	MOVE T,SCHBPT	;POP BEST USER OFF OF LIST
	SUB T,[1,,1]
	CAMN T,[-SCHBLN-1,,SCHBTB-1]	;RAP AROUND
	MOVE T,[-1,,SCHBTB+SCHBLN-1]
	MOVEM T,SCHBPT
	MOVE U,(T)
	SETOM (T)	;CLEAR LAST ENTRY
	POPJ P,
]

;SWAP OUT N PAGES (IN SWPOPR)
SWPON:	MOVE C,SOLNG
	SKIPGE CIRPSW		;CAN'T DO ANYTHING WITHOUT CIRPSW
	 CAIL C,3
	  POPJ P,		;ALREADY STUFF ON WAY OUT
	MOVE C,PSWCLS
	SKIPL U,PSWOUS
	 CAML U,USRHI
	  JRST SWPON1
	SKIPE LSWPR(U)		;WE DON'T HAVE TO WAIT IF HE ISN'T PCLSR'ABLE.
	 JRST SWPON1
	SKIPE UNAME(U)		;SKIP ON USER KILLED
	 SKIPL USWST(U)
SWPON1:	  PUSHJ P,SWPON2	;FIND NEW USER TO FLUSH
	JUMPL U,SWUP8
SWPON6:	MOVSI A,(SETZ)
	IORM A,USWST(U)
	MOVEM C,PSWCLS
	MOVEM U,PSWOUS
	MOVE T,UPC(U)
	TLNE T,%PCUSR
	 JRST SWPU1		;OK TO SWAP USER
	SKIPE FLSINS(U)
	 JRST SWPU1A
	PUSHJ P,PCLSR
	 POPJ P,
;		DROPS THROUGH

SWPU1:	AOS NSOUSR
	TLO A,40000
	CAILE C,1		;CLASS
	 IORM A,USWST(U)	;INDICATE USER WAS RUNNABLE AT TIME OF SWAP OUT
IFE SWBLK,[
	MOVE T,UPC(U)
	SETZM SWUPC		;CALCULATE WHAT PAGE HIS PC IS ON
	LDB C,[121000,,UPC(U)]
	ROT C,-1
	ADDI C,UPGMP(U)
	MOVE A,[222200,,(C)]
	SKIPGE C
	 IBP A
	LDB C,A
	TRNN A,600000
	 SETZM A
	ANDI A,PMRCM		;MASK TO REAL CORE ADR BITS
	SKIPN USTP(U)		;ONLY IF RUNNING
	 TLNN T,%PCUSR		;AND IN USR MODE
	  CAIA
	   MOVEM A,SWUPC	;THEN DON'T ALLOW UPC PAGE TO BE SWAPPED OUT
]
	MOVE B,PSWLC
	AOSE PSWSFL
	 JRST SWPU3A		;PICK UP FROM WHERE LEFT OFF
	MOVE C,UDBR1(U)		;ADDRESS OF PAGE MAP (START FROM PG 0)
	LDB B,[2300,,HUSRAD(U)]	;CAN BE GREATER THAN RANGE OF DBR1 BUT WILL BE LIMITED BY DBL
	MOVE J,UCPB1(U)
IFN SWBLK,	SETOM SWPP0F
SWPU7C:	ASH B,-10.		;SAVE SIGN BIT
IFE KL10P, LDB T,[230700,,C]	;GET DBL
IFN KL10P, MOVEI T,100
	LSH T,1	;2 PGS / WD
	CAIGE T,(B)
	 HRR B,T		;MIN HUSRAD/2000, 2*DBL
	TRNN B,-1
	 JRST SWPU7B		;NO PGS THIS DBR
	HRLI J,442200
	HRLI C,442200		;CNVRT TO BYTE PNTR TO MAP
	MOVEM C,SWPMBP
	MOVEM J,SWPCBP
SWPU2:	ILDB D,SWPCBP		;CIRC PNTR ENTRY
	ILDB A,SWPMBP		;PAGE MAP ENTRY
	AOS NSOPGS
	MOVEM B,PSWLC
	JUMPE D,SWPU3A		;DOESN'T HAVE PAGE
IFN SWBLK,[
	AOSN SWPP0F
	 SKIPE USTP(U)		;DON'T SWAP OUT PAGE 0 IF NOT STOPPED
]
	CAIN D,-1
	 JRST SWPU3A		;PAGE IS ABSOLUTE
	TRNN A,600000
	 JRST SWPU3A		;NO ACCESS
IFE SWBLK,[
	TRON A,PMAGEM		;HAS PAGE BEEN REFERENCED? (AGE MASK)
	 JRST	[DPB A,SWPMBP
		 JRST SWPU3A]
	ANDI A,PMRCM		;MASK TO REAL CORE PAGE #
	CAMN A,SWUPC		;DON'T SWAP OUT PAGE WHERE PC IS IF RUNNING
	 JRST SWPU3A
]
IFN SWBLK,	ANDI A,PMRCM	;MASK TO REAL CORE PAGE NUMBER
	HRRZ D,MMSWP(A)		;NUMBER OF USERS WHO HAVE THIS PAGE
	SOJN D,SWPU4		;PAGE IS SHARED
SWPU6:	MOVE C,PSWOUS
	PUSHJ P,SWPOPG
	 JRST SWPU3
	SETOM SBEFLG		;FOUND A PAGE TO SWAP OUT, NOT DESPERATE
	MOVE C,SOLNG
	CAIGE C,20.		;ENOUGH FOR NOW
	 SOSG SWPOPR
	  POPJ P,
SWPU3:	MOVE B,PSWLC
	MOVE U,PSWOUS
SWPU3A:	TRNE B,-2		;IN PAIRS SO DON'T TEST LOW BIT
	 SOJA B,SWPU2
SWPU7B:	TLON B,400000
	 JRST SWPU7		;DO UDBR2
SWPU7A:	SETOM PSWOUS
	MOVSI B,100000
	IORM B,USWST(U)		;SET BEST EFFORT BIT
	JRST SWPON

SWPU7:	LDB C,[2300,,HUSRAD(U)]
	SUBI C,400000
	JUMPLE C,SWPU7A
	HRR B,C
	MOVE C,UDBR2(U)
	MOVE J,UCPB2(U)
	JRST SWPU7C

SWPU1A:	MOVSI T,20000		;SWAPPING OUT PAGES OF PROCEDURE BLOCKED IN EXEC MODE
	IORM T,USWST(U)
	JRST SWPU1

SWPU4:	AOSE CIRPSW	;PAGE IS SHARED
	JRST 4,.	;CIRPSW LOCKED IN SWAP OUT CODE
	MOVE C,[2200,,MEMPNT(A)]
	MOVEM A,SWOBK
	PUSHJ P,UCPRL
	400000,,SWPU5
	SETOM CIRPSW
	MOVE A,SWOBK
	JRST SWPU6

SWPU5:IFN SWBLK,	SKIPGE USWST(U)
IFE SWBLK,[
	MOVE TT,I
	LSH TT,-1
	ADDI TT,UPGMP(U)
	HRLI TT,2200
	TRNN I,1
	HRLI TT,222200
	LDB TT,TT
	TRNE TT,600000	;SKIP IF NO ACCESS, IGNORE AGE
	TRNE TT,PMAGEM	;HAS ANYONE USED THIS PAGE?
]
	POPJ P,	;THIS USER WANTED OUT
	SUB P,[4,,4]
	SETOM CIRPSW	;SHARED W/USER WHO IS WANTED IN CORE
	JRST SWPU3

SWUP8:	AOSE SBEFLG	;HAVE WE COME HERE TWICE?
	 JRST SWUP6	;TO, LOOK THRU USERS ONCE MORE.
	MOVSI B,100000	;TURN OFF EVERYONES BEST EFFORT BIT
	MOVEI J,2*LUBLK
SWUP9:	CAML J,USRHI
	JRST SWUP7
	ANDCAM B,USWST(J)
	ADDI J,LUBLK
	JRST SWUP9
SWUP7:	PUSHJ P,SWPON2
	JUMPG U,SWPON6
SWUP6:	SETZM SWPOPR
	SETOM PSWOUS
	POPJ P,

SWPUP:	SKIPL CIRPSW
	POPJ P,
	HLRZ U,A	;U HAS INDEX
	HRRZS A	;A HAS VIRTUAL PAGE #
	PUSHJ P,UPLC	;RETURN POINTERS IN T AND Q
	LDB A,T	;GET MAP ENTRY
	TRNE A,600000
	JRST SWPUP2	;SWAP IT OUT
SWPUP1:	SETOM SWOUPG
	POPJ P,

SWPUP2:	ANDI A,PMRCM	;MASK TO REAL CORE PAGE #
	MOVNI C,1
	PUSHJ P,SWPOPG
	POPJ P,
	JRST SWPUP1

IFE SWBLK,[
CKPRUS:	MOVSI B,4000
	CAMGE U,USRHI
	ANDCAM B,USWST(U)	;TURN OFF PRIV USER BIT
	MOVNI TT,30.*2
	ADD TT,TIME	;TWO SECONDS AGO
	SKIPE UNAME(U)
	CAML TT,LUBTM(U)
	PUSHJ P,NPRVUSR
	SKIPG U,PRVUSR
	POPJ P,
	MOVSI B,4000
	IORM B,USWST(U)
	POPJ P,
SWPON2:	SETOM PSWSFL	;START FROM BEG OF USER
	SKIPL U,PRVUSR
	PUSHJ P,CKPRUS	; MAKE SURE PRIV USER EXISTS AND HAS NOT BEEN BLOCKED FOR A LONG TIME
	MOVNI T,30.*60.
	ADD T,TIME	;A MINUTE AGO
	MOVNI U,1
]
IFN SWBLK,[
SWPON2:	SETOM PSWSFL	;START FROM BEG OF USER
	MOVNI U,1	;BEST LOSER SO FAR
	MOVNI T,30.*60.
	ADD T,TIME	;A MINUTE AGO
]
	MOVEI J,2*LUBLK
	MOVEI C,NSSCDC	;# SWAP OUT CLASSES
SWPON4:	CAML J,USRHI	;C HAS INDEX OF MAX CLASS INTERESTED IN
	JRST SWPONX
	SKIPN UNAME(J)
	JRST SWPON3	;NOT FOR REAL
	MOVE B,USWST(J)
	SKIPE NMPGS(J)
	TLNE B,100000
	JRST SWPON3	;NO MEM OR HAVE TRIED TO FLUSH
	SKIPE LSWPR(J)
	JRST SWPON7	;PREFER NO TO SWAP OUT LOSER WITH SWITCHES LOCKED
	MOVEI I,1
	TLNE B,200000
	JRST SWPON5	;FLSINS IS WAITING FOR A PAGE (NOT REALLY BLOCKED)
	CAML T,LUBTM(J)
	SOJA I,SWPTK	;BLOCKED FOR A LONG TIME (CLASS 0)
	SKIPN FLSINS(J)
SWPON5:	SKIPE USTP(J)
	JRST SWPTK	;CLASS 1 (BLOCKED)
	TLNE B,4000
	JRST 	[MOVEI I,7
		JRST SWPTK]
	JUMPL B,[AOJA I,SWPTK]	;DESIRED OUT (CLASS 2)
	MOVEI I,4
	SKIPGE APRC(J)
	SOJA I,SWPTK	;DISOWNED (CLASS 3)
	SKIPGE USWSCD(J)
	JRST SWPTK	;SWAP BLOCKED (CLASS 4)
	SKIPGE TTYTBL(J)
	AOJA I,SWPTK	;DOESNT HAVE TTY (CLASS 5)
SWPON7:	MOVEI I,6	;OTHERWISE....

SWPTK:	CAMGE C,I
	JRST SWPON3	;THIS GUY IN MORE WINNING CLASS
	MOVE A,NMPGS(J)
	SUB A,NSWPGS(J)
	CAME C,I
	JRST SWPTK2
	XCT SWPTT(C)
	JRST SWPON3
SWPTK2:	MOVE E,@SWPTT(I)	;MAKE THIS GUY BEST VICTIM
	MOVE C,I
	MOVE U,J
SWPON3:	ADDI J,LUBLK
	JRST SWPON4

SWPONX:	JUMPL U,CPOPJ	;NO SWAP OUTTABLE LOSER
	SKIPGE USWSCD(U)
	POPJ P,	;HE'C ALREADY SWAPPED BLOCKED
	MOVE B,USWST(U)	;IS HE RUNNABLE?
	TLNN B,200000
	SKIPN FLSINS(U)
	SKIPE USTP(U)
	POPJ P,
	MOVE B,NMPGS(U)	;HE'S RUNNABLE
	CAIGE B,SYSUSM-SYSB-30
	JRST SWPNX1	;SMALL, NO THRASH
	SUB B,NSWPGS(U)
	ADD B,MEMFR
	SUB B,NCBCOM
	ADD B,SOLNG
	SUB B,SILNG
	SUB B,AUSOPG
	JUMPG B,CPOPJ	;LET THIS GUY THRASH
SWPNX1:IFE SWBLK,	POPJ P,
	MOVSI B,(SETZ)	;SWAP BLOCK THIS LOSER
	IORM B,USWSCD(U)
	AOS NUSWB
	MOVE B,NMPGS(U)	;SMALLEST SWAP BLOCKED LOSER?
	CAML B,BUSIZ
	POPJ P,
	MOVEM U,BUSR	;YES
	MOVEM B,BUSIZ
	POPJ P,

;SKIP IF THIS GUY (J) IS BETTER LOSER TO FLUSH THAT PREV BEST (IN E)
SWPTT:	CAMG E,LUBTM(J)	;BLOCKED FOR A LONG TIME (0)
	CAMG E,LUBTM(J)	;BLOCKED (1)
	CAML E,A	;DESIRED OUT (2)
	CAML E,A	;DISOWNED (3)
	CAML E,A	;RUNNABLE, SWAP BLOCK SET (4)
	CAML E,USWPRI(J)	;RUNNABLE, W/O TTY (5)
	CAML E,USWPRI(J)	;OTHERWISE (6)
	JRST 4,.
NSSCDC==.-SWPTT
SWPNX2:	MOVE TT,NMPGS(J)
	SUB TT,NSWPGS(J)
	CAMGE E,TT
	AOS (P)
	POPJ P,

;AC: A.9 =>1  SWAP OUT USER
;4.8 => 1 ALL PAGES
;4.7=1 => LOOP FOR A WHILE
;3.6-3.1 USER # SELF IF 0
;RH => USER VIRTUAL PG # 
;OR 4.9=0, 4.8=0, 4.7=0 SWAP OUT RH # OF PAGES
;IF 4.9=0, 4.8=1 AND 4.7=0, HACK PCLSR TEST FEATURE ON CURRENT USER
;RH =0 LEAVE PCLSR TEST MODE =1 ENTER IN ADVANCE MODE =-1 ENTER IN HOLD MODE
;   =2 ENTER IN ADVANCE BUT DON'T ^Z

ASWAP:	SKIPN SYSDBG
	JRST ILUUO
	XCTR XR,[MOVE A,(J)]
	TLNE A,100000
	JRST ASWAP3
	JUMPL A,ASWAP1
	TLNE A,200000
	JRST ASWPCL	;PC LSR TEST MODE.
	HRRZM A,SWPOPR	;CLOBBER CLOBBER
	POPJ P,

ASWAP1:	HLRZ B,A
	ANDI B,77
	IMULI B,LUBLK
	SKIPE B
	MOVE U,B
	TLNN A,200000
	JRST ASWAP2
	MOVE D,NMPGS(U)
	SUB D,NSWPGS(U)
	JUMPL D,[JRST 4,.]
	JUMPE D,CPOPJ
	CONO PI,CLKOFF
	MOVEM U,PSWOUS
	SETOM PSWSFL
	ADDM D,SWPOPR
	MOVSI D,(SETZ)
	IORM D,USWST(U)
	CONO PI,CLKON
	POPJ P,

ASWAP2:	HRL A,U
	PUSHJ P,CWAIT
	SKIPL SWOUPG
	MOVEM A,SWOUPG
	JRST CLKONJ

ASWAP3:	MOVE B,[1250000.]
	SOJG B,.
	XCTR XR,[MOVE A,2000]
	JRST .-3

ASWPCL:	MOVEM U,PCLUSR
	CLEARM PCLL
	CLEARM PCLHSH
	SETOM PCLNXT
	HRRES A
	MOVEM A,PCLDBM
	POPJ P,

;.CALL PGDUMP
; ARG 1 - A <JOB>
; ARG 2 - PAGE NUMBER IN <JOB>'S ADDRESS SPACE
; IF ONLY ONE ARGUMENT IS GIVEN, IT IS ARG 2, AND ARG 1 DEFAULTS TO CURRENT USER

; THE PAGE IS SWAPPED OUT.  THE CALL DOESN'T RETURN UNTIL THE SWAP IS COMPLETED.
; THIS ALLOWS USER TO BE SURE THAT THE COPY ON DISK IS UP TO DATE.

APGDUM:	CAIGE W,2
	 JRST [	MOVE J,U ? JRST APGDM1 ]
	MOVE J,A
	JSP T,NCORUI	;DECODE THE JOB SPEC
	 JRST APGDM0
	JSP T,NCORWR	;WHICH MUST BE WRITABLE
	 JRST OPNL31
APGDM0:	CAIN J,-1	
	 JRST OPNL34	;CAN'T HACK PDP6
	MOVE A,B	;NOTE: SWPOPG TAKES CARE OF THE PCLSR'ING

;USER INDEX IN J, PAGE NUMBER IN A
APGDM1:	TDNE A,[-1,,-400]
	 JRST OPNL32	;PAGE NUMBER NOT VALID
	EXCH U,J
	PUSHJ P,CWAIT	;DON'T ALLOW PAGE MAPS TO CHANGE
	  SKIPL CIRPSW	;DON'T NEED UTCOFF BECAUSE UTC LEVEL CAN ONLY PUT PAGES INTO MAPS
	PUSHJ P,UPLC
	EXCH U,J
	LDB C,T		;C GETS PMAP ENTRY
	LDB D,Q		;D GETS CIRC PNTR
	JUMPE C,OPNL32	;NO PAGE THERE
	CAIGE C,600000	;IF ALREADY SWAPPED OUT, OR
	 JRST APGDM2	;IF HE DOES NOT HAVE WRITE ACCESS, NO NEED TO SWAP IT OUT
	CAIN D,-1
	 JRST OPNL12	;ABSOLUTE PAGE
	MOVE A,C
	ANDI A,PMRCM
	HLRZ D,MMSWP(A)
	JUMPN D,OPNL12	;POINTED TO BY AN EXEC PAGE
	PUSH P,Q	;STORE CIRC BYTE PNTR
	MOVE C,USER	;DON'T PCLSR THIS JOB
	PUSHJ P,SWPOPG
	 JRST [CONO PI,CLKON ? POP P,Q ? JRST OPNL12] ;NO DISK SPACE, PROBABLY
	POP P,C		;GETS BACK CIRC BYTE PNTR
	PUSHJ P,UCPRL	;FIND MMP
	  200000,,.+2
	JRST 4,.	;IF NONE FOUND
	SUB P,[4,,4]
	MOVE U,USER	;U CLOBBERED BY UCPRL
	CONO PI,CLKON
	MOVSI T,100000	;PAGE IN TRANSIT BIT
	TDNE T,(C)	;WAIT FOR BIT TO TURN OFF
	 PUSHJ P,UFLS
APGDM2:	CAIL W,2
	 PUSHJ P,LSWPOP	;UNLOCK DIELOK
	JRST CLKOJ1

EBLK

;SWAP IN RQ BLOCKS
SWIRQB:
IFN 340P\E.SP,	DISSWI:	-1	;USER
IFN VIDP,	VIDSWI:	-1
IFN IMXP,	POTSWI:	-1
IFN NSWPV-.+SWIRQB,.ERR NSWPV ERR

SWIVPN:
IFN 340P\E.SP,	DISSPG:	0	;VIRTUAL PAGE NUMBER
IFN VIDP,	VIDSPG:	0
IFN IMXP,	POTSPG:	0

SWPNTB:		;SIGNAL BITS IN LH OF W TO CFHSW1
IFN 340P\E.SP,	400000	;DISPLAY
IFN VIDP,	400000	;VID
IFN IMXP,	400000	;POTS

SWILMT:		;PIRQC BIT TO SET ON ILM
IFN 340P\E.SP,	%PIDIS
IFN VIDP,	%PIMPV
IFN IMXP,	%PIMPV

NPGSWO:	0	;NUMBER OF CURRENTLY SWAPPED OUT PAGES
PSWOUS:	-1	;INDEX OF PARTIALLY SWAPPED OUT USER
PSWCLS:	0	;CLASS OF PARTIALLY SWAPPED OUT USER
PSWSFL:	0	;-1 START FROM BEG OF USER, ELSE PICK UP WHERE LEFT OFF
SWPMBP:	0	;PNTR TO MAP
SWPCBP:	0	;PNTR TO CIRC DESC SPACE
PSWLC:	0	;LOOP COUNT
SWUPC:	0	;ABSOLUTE PAGE NUMBER OF USER MODE PC DURNING SWAP OUT
SBEFLG:	-1	;0 => ALREADY ONCE WANTED TO CLEAR ALL "BEST EFFORT" BITS.
PRVUSR:	-1	;PRIV USR
PRVCUT:	2000	;CUT OFF FOR PRIV USR
		;***** THIS MAY NEED TO BE RETUNED.
		;UPGSEC VALUES WILL GENERALLY BE SMALLER
		; DUE TO A BUG FIX.
IFN SWBLK,SWPP0F:	-1	;-1 IF CONSIDERING PAGE 0
SWPOPR:	0	;NUMBER OF PAGES DESIRED TO BE SWAPPED OUT
SWPOPB:	0	;SWAP OUT REQUEST BUT ONLY SWAP OUT NON-RUNNING USERS TO MEET
SILNG:	0	;TOTAL LENGTH OF SWAP IN LISTS
SOLNG:	0	;TOTAL LENGTH OF SWAP OUT LISTS
		;SINLST AND SOUTLS ARE IN DISK CODE.  VARIATION ON QBFP.
SWODSK:	NQS-1	;UNIT TO SWAP OUT ON NEXT
SWOBK:	0	;MEMBLT BEING SWAPPED OUT
SWOMMP:	0	;MMP ADDRESS (NOT INDEX)
SPGNMF:	0	;-1 => PAGE NOT MODIFIED
SWOUPG:	-1	;REQUEST TO SWAP OUT PAGE RH OR USER LH
CFHAS:	0	;TEMP FOR A AT CFH
SWPIQS:	0	;SAVE Q AT SWPPIN,ETC
CFHUVP:	0	;USER'S VIRTUAL PAGE NUMBER TOOK FAULT ON
LUMPS:	0	;UMAPS USED FOR CURRENT USER, MAY DIFFER FROM
		;UMAPS(U) IF TOOK FAULT TRYING TO CAUSE INTERRUPT
TRUMM:	0	;TOTAL USER MEM ACTIVE USERS
AUSOPG:	0	;ACTIVE USER SWAPPED OUT PAGES
BUMPGS:	0	;REAL CORE PAGES OCC BY BLOCKED + STOPPED LOSERS
NUSWB:	0	;# LOSERS SWAP BLOCKED
BUSR:	0	;INDEX OF SMALLEST SWAP BLOCKED LOSER
BUSIZ:	0	;SIZE OF ABOVE LOSER
ASBUM:	0	;REAL MEM OCC BY ACTIVE "SWAPPED BLOCKED" LOSERS
SWSCT1:	0	;TEM AT SWSCD
SWPOPU:	0	;USER PG "BELONGS" TO (IE NOT NECC TO PCLSR THIS GUY,
			;BUT PCLSR ANYONE ELSE LINKED TO PG.

BBLK


SWPOPG:	MOVEM C,SWPOPU
	MOVEM A,SWOBK	;SWAP OUT PAGE WHOSE MEMBLT INDEX IS IN A
	CAIGE A,TSYSM
	CAIGE A,SYSB
	 JRST 4,.	;DON'T SWAP OUT PART OF SYSTEM
	AOSE CIRPSW	;SKIP IF SUCCESSFUL
	 POPJ P,
	LDB C,[MMMPX,,MEMBLT(A)]
	ADDI C,MMP
	HRRZM C,SWOMMP	;STORE ADDRESS OF FIRST WORD OF MMP ENTRY
	MOVSI B,MMPBAD
	ANDCAM B,(C)
	SOS CIRPSW	;RELEASE SWITCH
	HLRZ B,1(C)
	JUMPN B,SWOP1	;JUMP IF DISK SPACE ALREADY ASSIGNED
SWODF3:	MOVSI B,-NQS
SWODF6:	AOS I,SWODSK
	CAIL I,NQS
	 SUBI I,NQS	;WRAP AROUND
	MOVEM I,SWODSK	;CURRENT SWAPPING DSK
	CONO PI,UTCOFF-1	;DON'T CHANGE STATE OF CLOCK CHNL.
	SKIPGE QTUTO(I)	;TUT LOCKED
	 JRST SWODF7
	SKIPL QACT(I)
	SKIPG QSFTS(I)	;DSK FULL IN SWAPPING AREA
	 JRST SWODF7
	MOVSI A,(SETZ)
	IORM A,QTUTO(I)
	CONO PI,UTCON-1	;DON'T TURN ON CLOCK CHNL.
	MOVEI A,NQCHN+1(I)	;QMFTP(A) CONTAINS TRACK TO START FROM
	PUSHJ P,QGTK4	; RETURNS TRACK IN D
	SOS QSFTS(I)
SWODF5:	MOVSI A,(SETZ)
	ANDCAM A,QTUTO(I)
	MOVE A,SWOMMP
	DPB I,[DADDNR+D]	;GET DISK NUMBER AND TRACK NUMBER TOGETHER
	HRLM D,1(A)	;STORE IN MMP ENTRY
	JRST SWOP1

SWODF7:	AOBJN B,SWODF6	;TRY NEXT DSK FOR SWAPPING AREA
	CONO PI,UTCON-1	;NON FOUND FIND FILE SPACE
	MOVNI D,1
	MOVNI I,1
	MOVSI E,-NQS
SWODF2:	SKIPL QTUTO(E)	;FIND WHICH DISK HAS MOST FREE SPACE
	SKIPGE QACT(E)
	 JRST SWODF4
	CAMGE D,QSFT(E)
	 HRRZ I,E
	CAMGE D,QSFT(E)
	 MOVE D,QSFT(E)
SWODF4:	AOBJN E,SWODF2
	JUMPL I,CPOPJ	;NO DSK SPACE AVAIL
	HRRZM I,SWODSK	;LAST DSK HACKED
	JUMPLE D,CPOPJ	; NO ROOM ANYWHERE
	CONO PI,UTCOFF-1
	SKIPGE QTUTO(I)
	 JRST UTCNJ	;TUT LOCKED
	MOVSI A,(SETZ)
	IORM A,QTUTO(I)
	CONO PI,UTCON-1
	MOVEI D,NBLKS/2	;STARTING POINT
	MOVEI A,NQCHN+1(I) ;DISK CHANNEL
	MOVEM D,QMFTP(A)
	PUSHJ P,QGTK4	;RETURNS TRACK IN D
	MOVEI E,NUDSL
	MOVEM E,QMFTP(A);DON'T LEAVE SWAPPING CHNL POINTING INTO FILE SPACE
	SOS QSFT(I)
	JRST SWODF5

SWOP1:	AOSE CIRPSW
	 POPJ P,
	AOS NPGSO

;DROPS THROUGH;DROPS IN

;MMPRTN CALLS HERE. MMPGON WILL BE SET IN @SWOMMP IFF CALL WAS FROM
;MMPRTN. IN THAT CASE, WE SHOULD CALL CMEMR INSTEAD OF IMEMR.

SWOP1A:	CONO PI,UTCOFF-1	;DON'T CHANGE STATE OF CLOCK CHNL.
	MOVE A,SWOBK
	HLRZ C,MMSWP(A)	;NUMBER OF EXEC PAGES POINTING TO THIS PAGE
	JUMPN C,SWOP5	;POINTED TO BY EXEC PAGE
IFN 340P,[
	MOVSI C,-N340PB-2
SWOPT2:	LDB I,DPEP(C)
	TRZN I,600000
	 JRST SWOPT1
	ANDI I,PMRCM	;MASK TO REAL CORE PAGE #
	CAIN I,(A)
	 JRST 4,.	;DISPLAY STILL SET UP TO PAGE BEING SWAPPED OUT
SWOPT1:	AOBJN C,SWOPT2
]
	MOVSI C,(SETZ)
	IORM C,MEMBLT(A)	;PREVENT NEW EXEC PAGES FROM BEING SET UP POINTING HERE
	CONO PI,UTCON-1
	MOVE C,[2200,,MEMPNT]
	ADD C,SWOBK
	LDB I,C
	PUSH P,I	;NOTE: CAN BACK OUT OF THIS PUSH AT SWOP2B
	SETOM SPGNMF	;INITIALIZE PAGE NOT MODIFIED
	PUSHJ P,UCPRL
	  400000,,SWOP2	;RETURN ON USERS (CAN BACK OUT AT SWOP2B)
	POP P,I
	DPB I,C		;DELINK MEMPNT
	MOVEI I,3
	DPB I,[410200,,@SWOMMP]	;INDICATE ON THE WAY OUT
	CONO PI,UTCOFF-1
	MOVE A,SWOBK
	MOVSI B,(SETZ)
	ANDCAM B,MEMBLT(A)
	MOVE C,@SWOMMP
	TLNE C,MMPWRT	;WAS WRITTEN BY USER WHO LATER DELETED IT
	 JRST SWOP3
	SKIPGE SPGNMF	;SKIP IF PAGE MODIFIED
	TLNN C,MMPWOD
	 JRST SWOP3	;HASN'T BEEN WRITTEN
	MOVEI I,2	;NO NEED TO WRITE OUT.  INDICATE OUT.
	DPB I,[410200,,@SWOMMP]
	AOS NPGSWO	;PAGE NOW CONSIDERED SWAPPED OUT
	PUSHJ P,[TLNE C,MMPGON	;IF CALLED FROM MMPRTN WHICH LOCKED MEMFRZ,
		  JRST CMEMR	;ACT AS IF MEM NOT FROZEN.
		 JRST IMEMR]	;OTHERWISE SEE IF IT'S UNLOCKED.

	JRST SWOP4

SWOP5:	SOS CIRPSW
UTCNJ:	CONO PI,UTCON-1	;DON'T TURN ON CLOCK CHNL
	POPJ P,

SWOP3:	CAIGE A,TSYSM		;HAVE TO WRITE THIS PAGE OUT
	CAIGE A,SYSB
	 JRST 4,.
	HRRZ B,SWOMMP
	LDB I,[DADDNL 1(B)]
	CAIL I,NQS
	 JRST 4,.		;DISK NUMBER NOT LEGITIMATE
	MOVEI C,.BM MLO
	ANDCAM C,MEMBLT(A)	;SET END OF LIST IN THIS BLOCK
	HLRZ C,SOUTLS(I)	;GET PREV BLOCK
	SKIPE C
	 DPB A,[MLO,,MEMBLT(C)]	;CHAIN TO PREV BLOCK
	SKIPN C
	 MOVEM A,SOUTLS(I)	;OR TO HEADER IF FIRST
	HRLM A,SOUTLS(I)	;AND SET NEW LAST BLOCK
	AOS SOLNG
	AOS NPGSWO
	LDB C,[DADTNL 1(B)]
	HRLM C,MEMPNT(A)	;STORE DISK ADDRESS
	MOVEI B,MUSWPG
	DPB B,[MUR,,MEMBLT(A)]
	PUSHJ P,QSTRT1
SWOP4:	SOS CIRPSW
UTCNJ1:	CONO PI,UTCON-1
	JRST POPJ1

SWOP2:	CAIG U,LUBLK
	JRST 4,.	;SYS JOB OR CORE JOB?
	PUSH P,I
	CAMN U,SWPOPU
	JRST SWOP2A
	MOVE T,UPC(U)
	TLNE T,%PCUSR
	JRST SWOP2A
	SKIPN LSWPR(U)	;PCLSR IF HAS SWITCHES LOCKED
	SKIPN FLSINS(U)
	JRST SWOP2D
	MOVSI T,20000	;DONT PCLSR NOW, BUT WHEN UNBLOCKS
	IORM T,USWST(U)
	JRST SWOP2A

SWOP2D:	PUSHJ P,PCLSR
	JRST SWOP2B
SWOP2A:	MOVE C,UDBR1(U)
	TRZE I,200
	MOVE C,UDBR2(U)
	ROT I,-1
	ADDI C,(I)
	HRLI C,222200
	SKIPGE I
	HRLI C,2200
	LDB I,C
	JUMPE I,[JRST 4,.]	;NO ACCESS?
	TRNN I,600000
	JRST SWOP2C	;NOT SET UP SINCE PREV SWAPPED OUT
	LSH I,-16.	;SAVE ACCESS MODE IN LOW ADR BITS
	CAILE I,2	;SKIP ON READ ONLY OR READ/WRITE/FIRST
	CLEARM SPGNMF	;PAGE HAS BEEN MODIFIED
	CAIN I,2	;FLUSH R.W.F.
	MOVEI I,3
	DPB I,C		;STORE PROTECTION BITS BACK IN LOWER TWO BITS OF ENTRY
	AOS NSWPGS(U)	;INCR COUNT OF SWAPPED OUT PGS OF USER
	AOS SNSWPG	;INCR CNT OF SWAPPED OUT FOR SYS
IFN E.SP,[
	CAMN U,DISUSR	;IF USER OF E&S
	PUSHJ P,E.SLPM	;LOAD ITS MAP
]
SWOP2C:	POP P,I
	POPJ P,

SWOP2B:	SUB P,[6,,6]	;2 PUSHES OF I AND 4 FOR UCPRL
	MOVE A,SWOBK
	MOVSI I,(SETZ)
	ANDCAM I,MEMBLT(A)
	SETOM CIRPSW
	POPJ P,


IFN NSWPV,[
SWPPIN:	MOVSI Q,-NSWPV		;# OF DEVICES THAT CAN SWAP IN PAGES
SWPPI4:	SKIPGE W,SWIRQB(Q)	;USER INDEX
	 JRST SWPPI6
	MOVE E,SWIVPN(Q)	;VIRTUAL PAGE NUMBER
	HRL W,SWPNTB(Q)
	CLEARB TT,D
	MOVEM Q,SWPIQS
	PUSHJ P,CFHSW1
	MOVE Q,SWPIQS
	SETOM SWIRQB(Q)
SWPPI6:	AOBJN Q,SWPPI4
	POPJ P,
]

SWIILM:	MOVE Q,SWPIQS
	JUMPE Q,[JRST 4,.]	;ON SWAP IN USER OPERATION
IFN E.SP,[
	TRNN	Q,-1	; IS DEVICE DIS? (E&S IS INDEX 0 IN SWIRQB)
	SETZM	E.SPGW	; IF SO, CLEAR PAGE WAIT.
]
	MOVE E,SWILMT(Q)
	JUMPL E,[JRST 4,.]
	IORM E,PIRQC(W)
	MOVEI A,0
	POPJ P,

SWIUSR:	MOVE W,U	;SWAP IN ALL PGS USER IN U SKIP IF ENUF ROOM ,ETC
	SETZM SWPIQS	;FLAG FOR SWILM, ETC
	MOVE B,HUSRAD(W)
	MOVE C,UDBR1(W)
	MOVE D,UCPB1(W)
	MOVEI E,0	;PAGE #
SWIUS1:	LSH B,-10.
IFE KL10P,[
	LDB T,[230700,,C]	;GET DBL
	LSH T,1
]
IFN KL10P,MOVEI T,200
	CAIGE T,(B)
	HRRZ B,T
	TRNN B,-1
	JRST SWIUS2
	HRLI C,442200
	HRLI D,442200
SWIUS3:	ILDB A,C
	ILDB J,D
	TRNE A,600000
	JRST SWIUS4	;SOME ACCESS, THEREFORE NOT SWAPPED OUT
	JUMPE J,SWIUS4
	CAIN J,-1
	JRST SWIUS4
	PUSH P,E
	PUSH P,C
	PUSH P,D
	PUSH P,B
	HRLI W,(SETZ)
	CLEARB TT,D
	PUSHJ P,CFHSW1
	POP P,B
	POP P,D
	POP P,C
	POP P,E
	JUMPE A,CPOPJ	;FAILED
SWIUS4:	AOS E
	SOJG B,SWIUS3
SWIUS2:	CAILE E,200
	JRST POPJ1	;ALREADY IN HI HALF, THRU
	MOVE B,HUSRAD(W)
	SUBI B,400000
	JUMPLE B,POPJ1
	MOVEI E,200
	MOVE C,UDBR2(W)
	MOVE D,UCPB2(W)
	JRST SWIUS1

.ALSKF==0
DEFINE ALTSKP A
IFE .ALSKF,[
	DEFINE .ALSKS
A TERMIN
]
IFN .ALSKF,[
	CAME U,.ALSKS
	CAMN U,A
	POPJ P,
]
.ALSKF==.ALSKF#1
TERMIN

;DETERMINES USER PRIVILEGE LEVEL FOR SCHEDULING AND SWAPPING
UPRIVL:	SKIPN RPCL(U)	;BEING RPCLAR'ED?
	CAMN U,UMASTER	;MASTER?
	POPJ P,		;HIGHLY PRIVILEGED
	AOS (P)		;SKIP AT LEAST ONCE
IFN 340P\E.SP,	ALTSKP DISUSR
IFN VIDP,	ALTSKP NVDUSR
IFN TABP,	ALTSKP TABUSR
IFN ARMP,	ALTSKP ARMUSR
IFN LPTP,	ALTSKP LPTUSR
IFG LPTP-1,	ALTSKP OLPUSR
IFN PLTP,	ALTSKP PLTUSR
IFN .ALSKF,[
	CAMN U,.ALSKS
	POPJ P,
]
	MOVE T,UPC(U)
	TLNE T,%PCUSR
	AOS (P)		;SKIP TWICE
	POPJ P,

;SEARCH END (EXIT)
SEAREN:	SKIPE NUSWB
	JRST SSWC1	;SEE IF ENUF CORE TO UNBLOCK A SWAPPED BLOCKED LOSER
SSWC2:	SKIPGE U,I	;SKIP IF NON-NULL JOB BEST
	JRST SCHED1
SCHED6:	SKIPE FLSINS(U)
	JRST SCHED5
SCHED1:	EXCH U,USER
	JUMPL U,SCHDN	;JUMP IF SWITCHING FROM NULL JOB
	CAMN U,USER	;SKIP UNLESS RUNNING SAME JOB AGAIN
	JRST SEAREP	;JUMP ON SAME JOB
IFE KL10P,[
	MOVE T,40
	MOVEM T,SV40(U)	;SAVE LAST UUO EXECUTED FOR THIS USER
	MOVE T,UPC(U)	;IF USER HAS JUST TRAPPED TO 60,
	TLNE T,%PCUSR
	 JRST SCHDN
	ANDI T,-1
	CAIL T,60H0
	 CAILE T,60HE
	  JRST SCHDN
	MOVNI T,60H0-UUOH0
	ADDM T,UPC(U)	;THEN MOVE HIM INTO UUOH INSTEAD
	MOVE T,60	;AND MOVE 60H'S VARIABLES INTO UUOH'S VARS
	MOVEM T,FORTY	;(THAT'S ALL 60H DOES ANYWAY).
	MOVE T,60H
	MOVEM T,UUOH
]		;END OF IFE KL10P
SCHDN:	SKIPGE U,USER
	JRST SCHDN2	;JUMP IF SWITCHING TO NULL JOB
IFE KL10P,[
	MOVE T,SV40(U)	;LOAD NEW KRUFT
	MOVEM T,40
]		;END OF IFE KL10P
SEAREP:
IFN KL10P,[
	CAMN U,MTRJOB	;IF THIS JOB'S BEING METERED, TURN ON METER AND TIME BASE.
	 WRPAE PAEON
	CAMN U,MTRJOB
	 CONO MTR,2000
]
IFN N11TYS,[
	SKIPGE TT11P	;DONT HACK 11 IF ITS DOWN (MOSTLY IN CASE ITS BEING HACKED
			;HARDWARILY
	SKIPE TEN11F
	JRST SLTVR1	;DONT HACK 11
	SKIPGE T,TVVBN(U)	;BLINK RUNNING FROB?
	JRST SLTVR2
	MOVEM T,400000+TTR10*2000
	MOVE A,TVBLAD
	MOVNI T,20
	MOVEM T,400000+TTR0*2000(A)
	SKIPA T,TVVBN(U)
SLTVR2:	MOVSI T,12_<8+4+16.-18.>	;ALU NOP
	SKIPL TVCREG(U)
	MOVE T,TVCREG(U)
	MOVEM T,400000+TTR10*2000
SLTVR1:]	
IFE KL10P,	HRLOI T,1
    .ALSO	ANDCAM T,UPQUAN(U)	;RESET QUANTUM TIMER
	PUSHJ P,PGLDU
	MOVE T,UPC(U)	;USER'S PC WORD
	MOVEM T,CLKBRK
	AOS A,SCHHP	;SET UP SCHEDULER HISTORY TBL
	CAIL A,SCHHB+SSCHDB
	MOVEI A,SCHHB
	MOVEM A,SCHHP
	HRRM T,(A)	;STORE PC
	MOVE B,NUINX	;"NUMERIC" USER INDEX (FROM PGLD)
	TLNN T,%PCUSR
	TRO B,400000
	HRLM B,(A)	;STORE USER INDEX AND USER BIT
	MOVSI T,UUO(U)
	HRRI T,UEXIT
	BLT T,UEXND-1	;BLT IN UEXIT BLOCK
IFN SCHBLN,[
	SKIPG T,SCHFLG
	SKIPN SCHMNY
]
	MOVNI T,7
	MOVEM T,SCHFLG	;DONT SCHED FOR 1/7.5 SEC
	SETZM SCHMNY
CLKB5:
IFN KL10P, DATAO PAG,@CLCXSV	;RESTORE CONTEXT
	MOVE U,USER
	MOVSI U,AC0S(U)
	BLT U,U
IFN KL10P,AOSE PFAILF	;PROBLEM: PAGE FAULT HAS CLOCK OFF INSTEAD OF IN PROG.
	JRST 12,@CLKBRK
IFN KL10P,[
	CONO PI,2401	;PI OFF, CLOCK ON.
	JRST 17,@CLKBRK
]

SCHED5:	MOVSI T,20000
	TDNE T,USWST(U)
	JRST SCHED7	;PAGES HAVE BEEN SWAPPED OUT WHILE BLOCKED
	MOVSI T,250000	;NOT WAITING FOR PAGE,NOT UNBLOCKED SWAPOUT,
	ANDCAM T,USWST(U)	;NOT WAITING FOR INTERRUPT PAGE
	SETZM FLSINS(U)
	JRST SCHED1

SCHED7:	SKIPE HUSRAD(U)	;SWAPPED OUT PAGES HAVE GONE AWAY
	PUSHJ P,PCLSR	;PAGES WERE SWAPPED OUT WHILE BLOCKED IN EXEC MODE
	JFCL	;COULD NOT SKIP IF GUY HAS UFINAL SET
	JRST SCHED1

; SWITCHING TO NULL JOB
SCHDN2:	MOVSI T,(JFCL)
	MOVEM T,CLUSAV	;AVOID LOSSAGE AT CLKBRK+1 NEXT CLOCK INT
IFN KL10P, MOVEM T,CLCXSV
IFE KL10P,[
	DATAO PI,[0]	;LOAD MI WITH JOB RUNNING
	HRLOI T,1
	ANDCAM T,UPQUAN
]
IFN KL10P,[
	CAMN U,MTRJOB
	 WRPAE PAEON
	CAMN U,MTRJOB
	 CONO MTR,2000
	REBOXC NULEBC
	RMBOXC NULMBC
]
	CLEARM SCHFLG	;RESCHEDULE ON NEXT INT
	LPMR UPGML
IFN KL10P,AOSE PFAILF	;PROBLEM: PAGE FAULT HAS CLOCK OFF INSTEAD OF IN PROG.
	 JRST 12,@[%PSPCU,,NULJOB]	;DISMISS INT AND GO TO NULL JOB
IFN KL10P,[
	CONO PI,2401	;PI OFF, CLOCK ON.
	JRST 17,@[%PSPCU,,NULJOB]	;TURN PI ON AND GO TO NULL JOB.
]

NULJOB:	AOS NULTM2	;INCREMENT COUNT OF NULL QUANTA
	MOVSI (JRST 4,)
	MOVEI 17,1
	BLT 17,16	;SET ACS 0 TO 16 TO JRST 4, TO CATCH SPURIOUS TRANSERS TO ACS
	MOVE 17,[AOJA 17]	;RUNS IN ACS TO FREE MEMORY FOR OTHER PROCESSORS
	JRST 2,@[%PCUSR,,17]	;RUNS IN USER MODE FOR SAKE OF RANDOMNESS

SSWC1:	SKIPGE U,BUSR
	JRST SSWC2
	MOVN T,NSWPGS(U)
	ADD T,MEMFR
	SUB T,NCBCOM
	ADD T,SOLNG
	SUB T,SILNG
	SUB T,AUSOPG
	ADD T,ASBUM
	ADD T,BUMPGS
	CAIGE T,20
	JRST SSWC2	;NOT ROOM
	MOVSI T,400000
	ANDCAM T,USWSCD(U)	;CLEAR SWAP BLOCKED
	SETOM BUSR
	MOVE T,[-1_-1]
	MOVEM D,BUSIZ	;SIZE OF SMALLEST SWAP-BLOCKED USER.
	AOS NTSBUU
	SOSN NUSWB
	JRST SSWSC3
	MOVEI U,0
	MOVNI R,1
	MOVSI T,200000
SSWSC4:	CAML U,USRHI
	JRST SSWSC6
	SKIPGE USWSCD(U)
	SKIPN UNAME(U)
	JRST SSWSC5
	CAMGE T,NMPGS(U)
	JRST SSWSC5
	MOVE R,U
	MOVE T,NMPGS(U)
SSWSC5:	ADDI U,LUBLK
	JRST SSWSC4

SSWSC6:	MOVEM R,BUSR	;STORE NEW SMALLEST SWAPPED BLOCKED LOSER
	SKIPGE R
	MOVEI T,0
	MOVEM T,BUSIZ
SSWSC3:	JUMPL I,SEARL0	;MAYBE CAN RUN THIS GUY NOW
	JRST SSWC2


SUBTTL LOAD USER PAGE MAP

PGLDU:	MOVE R,UMAPS(U)
PGLD:	MOVEM R,LUMPS	;LAST UMAPS ACTUALLY USED
	PUSH P,A	;R HAS UMAPS CODE
	PUSH P,B
	PUSH P,C
;	JUMPE U,PGLDR1	;SYS JOB
;		***** THIS LOSES ON KL, AND APPEARS TO BE UNNECESSARY *****
	HRRZ C,U
	TLNN R,200000
	JRST PGLD3A	;USE NORMAL LOW SEG
IFN PDP6P,[
	TRNE R,400000
	JRST PGLD3B	;USE PNTR TO PDP6
]
	HRRZ C,R
	TLNE R,20000	;SKIP ON USE HIS LOWER
	JRST PGLD3D	;USE HIS UPPER
PGLD3A:	MOVE B,UDBR1(C)
	TLNE R,4000
	JRST PGLD3G	;MAKE AC'S POINT AT SWAP OUT AC'S
	MOVEI A,UUOACS(C)
PGLD3F:	MOVEM B,UPDBR1(U)
IFE KL10P, DPB A,[2300,,UPACP(U)]	;STORE AC PNTR
IFN KL10P,[
	CAMN A,AC1PTR	;IF CHANGING AC BLOCK 1
	 JRST PGLD3H
	EXCH A,AC1PTR	;STORE OLD BLOCK 1
	MOVE B,A
	XCTR XBR,[BLT B,17(A)]
	MOVS A,AC1PTR	;AND LOAD NEW BLOCK 1
	XCTR XBW,[BLT A,17]
PGLD3H:	]
	MOVE B,UDBR2(U)
	TLNN R,100000
	JRST PGLD5	;USE NORMAL UPPER SEG
IFN PDP6P,[
	MOVE B,PDP6MP
	TRNE R,400000
	JRST PGLD6	;USE PNTR TO PDP6
]
	MOVE B,UDBR2(R)
	TLNN R,20000
	MOVE B,UDBR1(R)	;PNTR TO HIS LOWER
PGLD5:	TLNE R,10000
	MOVE B,UDBR2(R)	;MAP HIGH TO HIGH IN ADDITION TO HACKING LOW
PGLD6:	MOVEM B,UPDBR2(U)
PGLDR1:	LPMR UPGML(U)
	LDB A,[300,,APRC(U)]
	CAIE A,APRCHN
	JRST 4,.
	CONO @APRC(U)
	MOVN A,U
	IDIVI A,LUBLK
	MOVNM A,NUINX
IFE KL10P,[				;KL10 DOESN'T HAVE ANY LIGHTS
	MOVSI B,(SETZ)
	LSH B,(A)
	DATAO PI,B
]					;MAYBE KL10 SHOULD STORE IN EPT FOR CONSOLE PROGRAM?
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

IFN PDP6P,	PGLD3B:	SKIPA B,PDP6MP
PGLD3D:	MOVE B,UDBR2(R)
	MOVEI A,GACS
	JRST PGLD3F

PGLD3G:	MOVEI A,AC0S(C)
	JRST PGLD3F

GACS:	BLOCK 20	;GARBAGE AC'S POINTED TO BY ACPNTR WHEN ITS REALLY POINTING
		;AT UPPER PAGES OR PDP6  SHOULD HOPEFULLY NEVER GET REFERENCED

MPLDZ:	TDZA J,J
MP6LD:	MOVE J,[100000,,-1]	;LOAD UPPER DBR TO PNT TO 6
MPLD1:	MOVEM J,UMAPS(U)	;SET UMAPS
MPLD:	CONO PI,CLKOFF
	PUSHJ P,PLD
	JRST CLKONJ

PLDZ:	TDZA J,J
PLD6:	MOVE J,[100000,,-1]
PLD1:	MOVEM J,UMAPS(U)
PLD:	SPM UPGML(U)	;IF ANY INHIBITED FAULT PRESENT, CAUSE IT TO GET STORED AWAY
	PUSH P,R
	PUSHJ P,PGLDU	;CAUSE ACTUAL PG LOAD TO HAPPEN
	POP P,R
	POPJ P,

SUBTTL GIVING THE USER INTERRUPTS

;ROUTINE TO HANDLE FIRST WORD (PIRQC) INTS
SEAR2A:	SKIPN PICLR(U)
	 JRST SEAR2C	;PI IN PROG, ONLY LOOK FOR FATAL INTS.
	SETCM Q,IDF1(U)
	AND Q,MSKST(U)	;ENABLED UNDEFERRED INTS.
	TDNN A,Q	;ANY OF THOSE PENDING,
	TDNE A,[BADBTS]	;OR ANY CLASS 1 OR 2 => INTERRUPT.
	 CAIA
	 JRST SEARL2
	ANDCA Q,A	;GET DISABLED OR DEFERRED PENDING INTS.
	TDNN Q,[BADBTS]	;ANY CLASS 1 OR 2 DISABLED OR DEFERRED
	 JRST INTWD1	 ;NO, INT. THIS JOB.
	JRST SEAR2D	;YES, INT. SUPERIOR.

SEAR2C:	TDNN A,[BADBTS]	;PI IN PROG: ANY CLASS 1 OR 2 ?
	 JRST SEARL2	 ;NO, NOTHING TO DO.
SEAR2D:	PUSHJ P,PCLSR	;INT. THE SUPERIOR: PCLSR FIRST.
	 JRST SEARC	;CAN'T STOP THIS JOB IN EXEC MODE.

;INTERRUPT SUPERIOR
INTSUP:	MOVSI T,BUSRC
	IORM T,USTP(U)	;STOP INFERIOR
	MOVSI T,BULGOS	;IF LOST TRYING TO LOG OUT, ABORT LOGOUT
	ANDCAM T,APRC(U)
	MOVE Q,U	;SAVE USER INTERRUPTING
	SKIPGE U,SUPPRO(U)	;SKIP UNLESS TOP LEVEL
	JRST INTTOP	;REALLY TOP LEVEL
	HLLZ T,U	;GET INT BIT
	IORM T,IFPIR(U)	;TURN ON INTERRUPT BIT IN SUPERIOR
	HRRZS U		;CLEAR LEFT HALF OF U
	CAIL J,(U)	;SKIP IF SUPERIOR HAS NOT YET BEEN SCHEDULED
	JRST SEARL1	;RESCHEDULE SUPERIOR
	JRST SEARL	;HAVEN'T GOT TO HIM YET SO CONTINUE

INTTOP:	MOVE T,Q
INTTO2:	MOVE U,TTYTBL(T)
	TLNE U,%TBDTY	;TREE HAS NO TTY =>
	 JRST INTTO1	;DETACH IT.
	JUMPL U,[HRRZ T,U ? JRST INTTO2]
	MOVE T,OPTION(Q)
	TLNE T,OPTDET	;MAYBE IT WANTS TO BE DETACHED
	 JRST INTTO1
	MOVE U,Q	;RELOAD
	PUSH P,I
	PUSHJ P,LOGUPD	;LOG TIME USED SO FAR SINCE USRST2 WILL RESET
	PUSHJ P,DMNPLI	;LOG LOSER BACK IN AGAIN
	POP P,I
	PUSHJ P,USRST2	;RESET USER VARS
	MOVEI T,USTCDR
IFN KL10P, HRLI T,%PSPCU
	MOVEM T,UPC(U)
	MOVSI T,BUSRC
	ANDCAM T,USTP(U)	;START UP
	SETZM @UTMPTR(U)	;GIVE TEMPORARY HIGH PRIORITY
	JRST SEARC	;RESCHEDULE THIS JOB

INTTO1:	MOVEI T,SCRDET
	SKIPL APRC(Q)	;IF JOB ISN'T ALREADY DISOWNED
	IORM T,SUPCOR	;SAY SOMEONE WNATS TO BE DETACHED.
	JRST SEARL	;LEAVE STOPPED, SYS JOB WILL DETACH SOMEDAY.

;IFPIR IS NONZERO BUT PIRQC IS ZERO.
INTWD2:	SKIPN PICLR(U)
	 JRST SEARL3	;IGNORE 2ND WD INTS IF PI IN PROG.
	AND B,MSKST2(U)
	ANDCM B,IDF2(U)	;GET ENABLED UNDEFERRED INTS.
	JUMPE B,SEARL3	;ALL DISABLED OR DEFERRED.
	JSP T,INTPAG	;MAKE SURE NOT WAITING FOR PAGE NEEDED FOR INT.
	PUSHJ P,PCLSR	;DON'T INT. EXCEPT IN USER MODE.
	 JRST SEARC
	SETZ A,		;1ST WD INTS TO GIVE = 0.
	JRST INTSRC	;2ND WD INTS TO GIVE ALREADY IN B.

;PIRQC WAS NONZERO BUT NO FATAL INTS.
INTWD1:	JSP T,INTPAG	;IF TRIED BEFORE & WENT TO INTPFL, WAIT FOR PAGE.
	PUSHJ P,PCLSR	;CAN INT. ONLY IN USER MODE.
	 JRST SEARC
	MOVE B,IFPIR(U)
	AND B,MSKST2(U)	;GET PENDING ENABLED UNDEFERRED 2ND WD INTS IN B.
	ANDCM B,IDF2(U)
	AND A,MSKST(U)
	ANDCM A,IDF1(U)	;PENDING ENABLED UNDEFERRED 1ST WD INTS IN A.
INTSRC:	SKIPGE UTRAPM(U)	;MAYBE ALL INTS SHOULD GO TO SUPERIOR?
	 JRST INTBAD
	AOS NAUINT	;ELSE 1 MORE ATTEMPT TO INTERRUPT.
	MOVSI R,4000	;LOAD ORDINARY MAP FOR THIS USER.
	PUSHJ P,PGLD	;BUT ACS -> SWAP OUT ACS.
	HRRZ T,40ADDR(U) ;GET ADDR OF USER'S LOCATION "40"
	XCTRI XR,[MOVE T,2(T)] ;TRY TO GET CONTENTS OF "42" (..I SO STOP ON EXEC PG FAULT DOESNT)
	 SKIPA R,T
	  JRST INTPFL	;PAGE FAULT IN XCTR, GIVE UP & WAIT FOR PAGE.
	ANDI R,-1
	JUMPE R,INTBAD	;42 POINTS TO 0 => BADPI ERROR.
	MOVE TT,OPTION(U)
	TLNN TT,OPTINT	;NEW STYLE INTERRUPTS?
	 JRST INTOLD	 ;NO, OLD STYLE.
	XCTRI XR,[MOVE R,(R)] ;GET ADDR OF HIS INT PDL PTR.
	 CAIA
	  JRST INTPFL
	JUMPGE T,INTBAD
	CAMGE T,[-72.*5-1,,]
	 JRST INTBAD
	XCTRI XR,[MOVE H,(R)] ;GET CONTENTS OF INT PDL PTR.
	JRST INTSR2	;ADVANCE T PAST INT PDL PTR ADDR.
	 JRST INTPFL

INTSR0:	XCTRI XR,[MOVE C,(T)] ;GET THE INTS NEXT INT TABLE ENTRY
	 SKIPA D,B
	  JRST INTPFL	;APPLIES TO.
	XCTRI XR,[AND D,1(T)]
	 CAIA
	  JRST INTPFL
	AND C,A		;WHICH OF THEM ARE WE TRYING TO GIVE?
	JUMPN C,.+2
	 JUMPE D,INTSR1	;NOT GIVING ANY OF THEM, TRY NEXT ENTRY.
	MOVE Q,IDF1(U)	;GET CURRENT SETTINGS OF DEFER WORDS.
	XCTRI XW,[MOVEM Q,3(H)]
	 SKIPA Q,IDF2(U)	;AND PUT INTO NEXT INT PDL FRAME.
	  JRST INTPFL
	XCTRI XW,[MOVEM Q,4(H)]
	 SKIPA Q,UPC(U)	;ALSO PUT CURRENT PC IN FRAME.
	  JRST INTPFL
	XCTRI XW,[MOVEM Q,5(H)]
	 CAIA
	  JRST INTPFL
	XCTRI XR,[MOVE E,2(T)] ;NOW SEE WHICH DEFER BITS TO TURN ON NOW.
	 CAIA
	  JRST INTPFL
	XCTRI XR,[MOVE TT,3(T)]
	 CAIA
	  JRST INTPFL
	XCTRI XR,[MOVE Q,4(T)] ;AND THE NEW PC.
	 TLOA Q,%PCUSR
	  JRST INTPFL
	TLZ Q,BADPC
	SKIPGE IOTLSR(U)
	 TLO Q,%PCUIO	;DON'T CHANGE HIS IOTLSR STATUS.
	XCTRI XW,[MOVEM C,1(H)]
	 CAIA		;PUT INTS BEING GIVEN IN
	  JRST INTPFL	;INT. PDL FRAME.
	XCTRI XW,[MOVEM D,2(H)]
	 TDZA B,D
	  JRST INTPFL
	MOVE W,H	;REMEMBER PDL PTR BEFORE INCREMENT, FOR PDL OV TESTING
	ADD H,[5,,5]
	TLNN R,400000	;SAVE DEBUGGING INFO ON INT PDL IF USER WISHES
	 JRST INTSR4
	HRRZ J,UPJPC(U)
	XCTRI XW,[MOVEM J,1(H)]
	 SKIPA J,UUOH
	  JRST INTPFL
	XCTRI XW,[MOVEM J,2(H)]
	 SKIPA J,LSUUO(U)
	  JRST INTPFL
	XCTRI XW,[MOVEM J,3(H)]
	 CAIA
	  JRST INTPFL
	ADD H,[3,,3]
INTSR4:	LDB J,[220500,,R]	;HOW MANY ACS SHOULD WE SAVE?
	JUMPE J,INTSR5		;NONE?
	HRLS J
	ADD H,J			;ADVANCE THE PDL PTR OVER WHERE THEY'LL GO.
	SUBM H,J		;GET BACK THE OLD UN-ADVANCED PDL PTR IN J.
	ROT R,14
	HRLI J,(R)		;PUT 3.7-4.1 OF R INTO LH(J) CIRCUITOUSLY
	TLZ J,777760
	ROT R,-14
	AOS J			;MAKE J POINT AT 1ST UNUSED PDL WORD.
	XCTRI XBRW,[BLT J,-1(H)]
	 CAIA
	  JRST INTPFL
INTSR5:	XCTRI XW,[MOVEM H,(R)]	;STORE BACK THE PDL POINTER, THUS FINALIZING ALL
	 TDZA A,C	;INTS HAVE BEEN GIVEN; NOW WE CAN CHANGE THE USER VARS.
	  JRST INTPFL
	ANDCAM C,PIRQC(U)
	ANDCAM D,IFPIR(U)
	IORM E,IDF1(U)	;SET THE DEFER BITS SPEC'D IN TABLE ENTRY.
	IORM TT,IDF2(U)
	MOVEM Q,UPC(U)	;START USER AT INT HANDLER.
	JUMPL H,INTSR3	;NOW CHECK FOR INT PDL OVFLO.
	JUMPGE W,INTSR3
	MOVEI TT,%PIPDL	;THERE WAS OVFLO, SET PDL OV INT
	TDNN TT,MSKST(U) ;IF ENABLED.
	 JRST INTSR3
	IORM TT,PIRQC(U)
	JRST SEAR2A	;RE-TRY THE INTERRUPT.

INTSR3:	JUMPN A,SEAR2A	;MORE INTS TO GIVE => RETRY.
	JUMPN B,SEAR2A
INTSRX:	AOS NUINT	;1 MORE INT GIVEN SUCESSFULLY.
	SPM UPGML(U)
	JRST SEARC	;SCHEDULE.

INTSR1:	ADD T,[4,,4]	;NO INTS GIVEN, TRY NEXT ENTRY.
INTSR2:	AOBJN T,INTSR0
	JRST INTSUP	;ENABLED INTS BUT NO ENTRIES FOR THEM.

;GIVE INTS THE OLD WAY.
INTOLD:	SKIPN C,A	;GIVE INTS OF 1 WD AT A TIME.
	 SKIPA C,B	 ;(NO 1ST WD, GIVE ALL 2ND WD)
	TDZA B,B	;(SOME 1ST WD INTS, GIVE NO 2ND WD INTS)
	 TLO C,4^5	 ;(GIVING 2ND WD, SET SIGN TO SAY SO)
	XCTRI XW,[MOVEM C,(T)]
	 SKIPA Q,UPC(U)	;STORE INTS BEING GIVEN,
	  JRST INTPFL
	MOVEI T,2(T)	;ADVANCE -> PLACE TO START USER.
	XCTRI XW,[MOVEM Q,-1(T)]
	 TLOA T,%PCUSR	;OLD PC STORED, SET UP NEW.
	  JRST INTPFL
	ANDCAM A,PIRQC(U) ;SAY THESE INTS NOW GIVEN.
	ANDCAM B,IFPIR(U)
	SKIPGE IOTLSR(U)
	 TLO T,%PCUIO
	MOVEM T,UPC(U)	;SET HIS PC -> TSINT+2
	SETZM PICLR(U)
	JRST INTSRX
	
;IF WE ARE WAITING FOR A PAGE NEEDED FOR TAKING AN INTERRUPT,
;GIVE UP ON TRYING TO TAKE TE INT. UNLESS PAGE HAS COME IN SINCE LAST TRY.
INTPAG:	MOVSI E,200000
	SKIPE FLSINS(U)
	 TDNN E,USWST(U)
	  JRST (T)	;JOB NOT WAITING FOR PAGE
	MOVSI E,10000
	TDNN E,USWST(U)
	 JRST (T)	;NOT WAITING FOR INTERRUPT PAGE
	MOVE E,T
	MOVE T,EPDL2(U)
	XCT FLSINS(U)
	 JRST SEARL	;PAGE NOT IN
	JRST (E)	;PAGE IN
	JRST 4,.	;SHOULDN'T SKIP TWICE...
	JRST 4,.

;COME HERE WHEN AN XCTRI TAKES FAULT WHILE TRYING TO STORE AN INTERRUPT.
INTPFL:	SPM UPGML(U)	;STORE MAP IN INTERRUPTING STATE
IFE KL10P,LDB T,[221000,,UPJPC(U)]	;FAULT ADDRESS
IFN KL10P,LDB T,[$PFPNO,,UPFW(U)]
	ROT T,-1
	TRZE T,100
	 SKIPA A,UCPB2(U)
	  MOVE A,UCPB1(U)
	HRLI A,222200+T
	SKIPGE T
	 HRLI A,2200+T
	LDB E,A
	JUMPE E,INTBAA	;DON'T HAVE PAGE
IFE KL10P,[
	HLLZ T,UPQUAN(U)
	TLNE T,100
	 JRST INTBAB	;WRITE IN RD ONLY
INTBAC:	HLLZ T,UPC(U)	;SIMULATE SETUP OF OPC
	LSH T,-5
	HRR T,UPC(U)
	MOVEM T,UPOPC(U)	;FAULT STATUS
	MOVSI T,1000
	IORM T,UPQUAN(U)	;BIT NOT SET BY XCTRI
	MOVSI T,10000
	IORM T,USWST(U)	;PAGE FAULT RESULT OF INTERRUPT ATT
	LPMRI UPGML(U)	;SHOULD BE REDUNDANT BUT FOR EXTRA RELIABILITY
	JRST SCHED6	;"RUN" USER, TAKING PAGE FAULT IMMEDIATELY

INTBAB:	TLNE T,50	;NO ACCESS OR W IN RWF
	 JRST INTBAC	;PAGING BOX BUG? IGNORE RD ONLY
	JRST INTBAA	;REALLY IS READ-ONLY.
]		;END IFE KL10P
IFN KL10P,[
	SUBI A,UPGCP-UPGMP
	LDB E,A
	TRNE E,600000
	 LSH E,-20
	CAIN E,2
	 JRST INTBAB
	MOVS T,UPFW(U)
	ANDI T,%PFCOD
	CAIE T,%PFPNA
	 JRST INTBAA	;REAL VIOLATION
INTBAB:	MOVSI T,10000
	IORM T,USWST(U)	;PAGE FAULT RESULT OF INTERRUPT ATTEMPT
	SETOM DLSRCH	;DON'T INTERRUPT AT INTBA1, SCHEDULE, TRY TO PCLSR WITH WRONG PC
	MOVEI T,INTBA1	;JUST PAGE FAULT OR RWF SO TAKE THE FAULT
	EXCH T,UPC(U)	;HACK USER'S PC
	MOVEM T,EPDL3(U)
	JRST SCHED6	;RUN USER

INTBA1:	CONO PI,400	;(PIOFF);COMING BACK HERE IMMEDIATELY
	SETZM DLSRCH
	MOVEM U,PFAILU	;AND SIMULATING A PAGE FAIL ON THE INTERRUPT WORD
	MOVE U,USER
	MOVE U,EPDL3(U)
	MOVEM U,PFOPC
	JRST PFA2
]		;END IFN KL10P

INTBAD:
INTBAA:	MOVEI A,%PIB42	;TURN ON BAD PI LOC INT BIT
	IORB A,PIRQC(U)	;GIVE USER INTERRUPT(MUST IORM TO AVOID TIMING ERR)
	JRST SEAR2A	;RE-PERFORM ACTIONS FOR NON-ZERO PIRQC
		;WILL CAUSE AN INTERRUPT TO SUPERIOR

SEARP1:	MOVEM T,U0P	;SET UP TREE MACHINE TIME USED RECENTLY
	MOVE T,JTMU(U)	;GET PROCEDURE TIME USED RECENTLY FOR BEST SO FAR
	ASH T,(Q)	;INCREASE PRIORITY IF INDICATED
	MOVEM T,U0PP	;STORE FOR FUTURE COMPARISIONS
	MOVEM U,I	;SET BEST SO FAR TO CURRENT PROCEDURE
	JRST SEARL

SEARP3:	CAMN T,U0P
	JRST SEARP6	;JUMP IF EQUAL TO BEST SO FAR
	MOVE A,JTMU(U)	;NEW USER HAS HIGHER TREE PRIORITY
			;SO MACHINE TIME CAN BE 8X AS GREAT
	ASH A,-3(Q)	;DIVIDE JTMU BY 8+Q
SEARP4:	CAML A,U0PP	;COMPARE TO BEST SO FAR
	JRST SEARL	;CURRENT PROC. LOSES, HAS USED MUCH MORE TIME THAN BEST SO FAR
	JRST SEARP5	; " WINS, HAS NOT USED MUCH MORE

SEARP6:	MOVE A,JTMU(U)	;PICK UP TIME USED RECENTLY
	ASH A,(Q)	;INCREASE PRIORITY AS INDICATED BY Q
	JRST SEARP4

SEARD:	MOVEI T,SEARC	;"JUMPA SEARD" IS FLSINS SET UP BY UDELAY
	HRRM T,FLSINS(U)	;MODIFY FLSINS TO SIMULATE UNBLOCKING
	JRST SEARL


;INTERRUPT ALL USERS THAT WANT IT
;  C(A) IS BIT IN PIRQC TO TURN ON
DBGINT:	MOVSI A,(%PIDBG)	;"SYS BEING DEBUGGED" INT
INTALL:	MOVEI U,0	;ENTRY INITIALIZE
INTA2:	ADDI U,LUBLK	;ADVANCE TO NEXT BLOCK OF USER VARIABLES
	CAML U,USRHI	;SKIP UNLESS AT END
	POPJ P,		;THROUGH, RETURN
	SKIPN UNAME(U)	;SKIP IF BLOCK IN USE
	JRST INTA2	;IDLE, IGNORE
	LDB T,[410100,,USTP(U)]	;GET BUCSTP OF USERS STOP WORD
	JUMPN T,INTA2	;IF USER CONTROL STOPPED, JUMP TO IGNORE
	MOVE B,MSKST(U)	;PICK UP INTERRUPT MASK
	AND B,A		;MASK C(B) TO APPROPRIATE BIT
	IORM B,PIRQC(U)	;GIVE INT TO USER
	JRST INTA2	;LOOP

SUBTTL PCLSR ROUTINES

; PUT PC OF USER WHOSE INDEX IS IN U IN USER MODE
;  (CALL ONLY WITH CLOCK OFF OR CLOCK BREAK IN PROGRESS)
;SKIPS IF SUCCESSFUL, FAILS IF USER RUNNING IN EXEC CODE OR HAS TO BE FINALIZED
;
PCLSR:	AOS NPCLSR
	JUMPLE U,[JRST 4,.]	;SHOULD NOT HAPPEN TO SYS OR NULL JOB
	MOVEI T,L
	IDIVM U,T
	IMULI T,L
	CAMN T,U		;IS U REALLY A MULTIPLE OF LUBLK?
	 SKIPN UNAME(U)		;SHOULD NOT HAPPEN TO NONEXTANT JOB
	  JRST 4,.
	SKIPE USTP(U)
	 JRST POPJ1		;USER STOPPED (MUST ALREADY BE IN USER MODE)
	SKIPLE T,RPCL(U)
	 JRST PCLSR2		;LOSER IS RPCLSR'ING SOMEONE
PCLSR3:	MOVE T,SUEXIT(U)
IFN KL10P,SUB T,U
	CAME T,[JRST 2,@XUUOH]
	 JRST PCLSR5		;EXIT ALREADY CLOBBERED
	MOVE T,UPC(U)		;PICK UP PROGRAM COUNTER (FLAGS IN L.H.)
	TLNN T,%PCUSR		;SKIP IF USER MODE ON
	 JRST PCLSR8		;JOB CURRENTLY IN EXEC MODE
	CLEARM FLSINS(U)	;IN CASE HE WAS WAITING FOR A PAGE OR CIRPSW
	MOVSI T,250000
	ANDCAM T,USWST(U)
	AOS (P)
	POPJ P,

PCLSR8:	SKIPE FLSINS(U)		;SKIP IF UNBLOCKED
	 JRST PCLSR1		;HUNG, TRY TO BACK UP TO UUO
PCLSR4:	MOVE T,[JRST ONEFLS]
	MOVEM T,SUEXIT(U)	;MUNG EXIT OF UUO, COME BACK LATER
	POPJ P,

PCLSR2:	SETZM RPCL(U)		;CLEAR OUT POINTERS IN BOTH DIRECTIONS
	SETZM RPCL(T)
	JRST PCLSR3

PCLSR5:	SKIPN FLSINS(U)
	 POPJ P,		;NOT HUNG, LET RUN TO COMPLETION
IFE KL10P,[			;HUNG, UNCLOBBER EXIT AND BACK UP TO UUO
	CAME T,[JRST ONEPROC]	;SKIP IF ONE PROCEEDING A SYS CALL
	 JRST PCLSR6
	MOVSI T,%PC1PR
	IORM T,SUUOH(U)		;RESET SINGLE INSTRUCTION PROCEED
PCLSR6:]	;END IFE KL10P
	MOVE T,UPC(U)
	TLNE T,%PCUSR
	 JRST 4,.
IFE KL10P,	MOVE T,[JRST 2,@UUOH]
IFN KL10P,[
	MOVSI T,(JRST 2,@)
	HRRI T,UUOH
]
	MOVEM T,SUEXIT(U)	;UNCLOBBER EXIT
PCLSR1:	HRRZ T,UPC(U)
	EXCH T,LSPCL(U)		;SAVE FOR DEBUGGING (NO FLAGS BUT WHO NEEDS 'EM?)
	CAME T,LSPCL(U)
	 MOVEM T,LSPCL1(U)	;SAVE LAST TWO DISTINCT LOCATIONS
	SOS T,SUUOH(U)		;GET USER LOCATION OF HIS CURRENT UUO
UFL5:	MOVEM T,UPC(U)		;SET USERS PROGRAM COUNTER
IFN KL10P,[
	MOVSI T,701100		;RESTORE PAGE-CONTEXT
	HLLM T,CLCX(U)
]
	CLEARM UMAPS(U)		;RESTORE TO NORMAL MAP
	SETZM FLSINS(U)		;CLEAR OUT ANY BLOCKING CONDITION
	MOVSI T,270000		;NOT BLOCKED ON PAGE, NOT UNBLOCKED SWAPOUT, NOT INTERRUPT PAGE
	ANDCAM T,USWST(U)	;CLEAR FLAG PGS SWAPPED OUT WHILE BLOCKED
	SKIPE T,LSWPR(U)
	 JRST LSWZAP		;REQUIRED TO UNLOCK SWITCHES
PCLSR7:
IFN KL10P,[
	MOVEI T,UUOACS(U)	;IF JOB U'S ACS ARE IN HARDWARE AC BLOCK 1,
	CAMN T,AC1PTR		;COPY THEM INTO UUOACS WHERE THEY BELONG.
	 XCTR XBR,[BLT T,UUOACS+17(U)]
]
	MOVEI T,AC0S(U)
	HRLI T,UUOACS(U)
	BLT T,AC17S(U)
	JRST POPJ1		;EXIT AFTER BACKING UP TO UUO
;
; AOS USTP OF USER IN A
;
NJRPCL:	CAIE A,-1	;ENTRY TO IGNORE IF NULL JOB
RPCLSR:	CAMN A,USER	;NORMAL ENTRY
	POPJ P,		;TRYING TO RPCLSR SELF OR NULL JOB
	PCLT
	PUSH P,U	;SAVE U
	MOVE U,A	;GET INDEX OF RPCLSRED JOB IN U
	MOVE A,USER	;GET RPCLSRING USER INDEX IN A
	CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	PUSHJ P,PCLSR	;PUT USER IN USER MODE
	JRST RPCLOS	;JUMP IF CAN'T DO IT RIGHT NOW
	AOS USTP(U)	;WIN,STOP USER
	CONO PI,CLKON	;RE-ENABLE CLOCK BREAKS
RPCLS1:	MOVE A,U	;RESTORE A
	POP P,U		;RESTORE U
	POPJ P,
;
RPCLOS:	SKIPE RPCL(U)	;SKIP IF ZERO RPCL FOR USER BEING RPCLSRED
	JRST RPCLS2	;SOMEONE GOT THERE FIRST
	SKIPE RPCL(A)	;SKIP IF ZERO RPCL FOR RPCSRING USER
	JRST UDELAY	;YOU ARE BEING RPCLSR'ED, SURRENDER
	HRROM A,RPCL(U)	;SET UP RPCL IN VARS OF RPCLSRED USER
	HRRM U,RPCL(A)	;" OF RPCLSRING USER
	PCLT
	SKIPE RPCL(A)	;WILL NOT SKIP AT FIRST
	PUSHJ P,UFLS	;WAIT FOR PERSON BEING RPCLSRED TO GET TO ONEFL2
	JRST RPCLS1
;
RPCLS2:	MOVE A,U	;RESTORE A AND U
	POP P,U
	PCLT
	SKIPE RPCL(A)	;WAIT FOR OTHER GUY TO WIN
	PUSHJ P,UFLS
	JRST RPCLSR	;THEN TRY AGAIN

;
; UNDO AN RPCLSR
;
NJUPCL:	CAIE A,-1	;ENTRY TO IGNORE IF NULL JOB
UPCLSR:	CAMN A,USER	;REGULAR ENTRY
	POPJ P,		;TRYING TO UPCLSR SELF OR NULL JOB
	SOS USTP(A)
	POPJ P,

IFE KL10P,[
;
; RETURN FROM SYSTEM CALL IN ONE PROCEED MODE
;
ONEPROC:CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	MOVE U,USER	;BE SURE U HAS RUNNING USER INDEX IN IT
	MOVEI T,%PI1PR
	IORM T,PIRQC(U)	;GIVE USER INTERRUPT
	JRST ONEPR2
]

SUBTTL USER START ROUTINES
;
; CALLED EVERY SLOW CLOCK TICK WHEN TTY WANTING TOP PROCEDURE LOADED
;
USTART:	PUSH P,U
USTRT1:	SKIPGE T,@UTTYO	;GET TTY TO BE STARTED
	MOVSI T,%TBNOT+%TBDTY+%TBNVR	;NOT A REAL TTY, INITIALIZE TTYTBL
	PUSHJ P,USTRA	;CREATE NEW USER SLOT ENTRY
	JRST USTSC1	;LOSE, HAVE TO WAIT
	SKIPGE T,@UTTYO	;SKIP IF REALLY A TTY
	JRST USTRTS	;DONT LOAD A HACTRN
	MOVE T,[SIXBIT /HACTRN/]	;LOAD HACKTRN
USTRT2:	MOVEM T,JNAME(U)	;SET JOB NAME
	HRLZI T,%PCUSR
	HRRI T,1
	MOVEM T,UPC(U)
	MOVEI T,AC0S(U)
	HRLI T,NUSTCD
	BLT T,AC17S(U)
	MOVE T,JNAME(U)
	MOVEM T,AC0S+11(U)
	SETZM @UTMPTR(U)	;GIVE TEMPORARY HIGH PRIORITY
	SETZM USTP(U)	;START UP
USTSC2:	AOS T,UTTYO	;AOS RING BUFF
	CAIL T,UTTYS+MXCZS
	MOVEI T,UTTYS
	MOVEM T,UTTYO
	SOSE UTTYCT
	JRST USTRT1	;MORE JOBS TO SET UP
	POP P,U
	POPJ P,

USTRTS:	MOVEM U,1(T)	;STORE USER'S INDEX IN SECOND WORD
	MOVE T,(T)	;GET JNAME FROM FIRST WORD (POINTED TO BY RH OF @UTTYO)
IFN DEMON,[
	CAME T,[SIXBIT /LDRDEM/]
	CAMN T,[SIXBIT /UNSPOO/]
	AOS UTMPTR(U)		;LOADER, UNSPOOLER -> SYSTEM TREE
]
	JRST USTRT2

USTSC1:	MOVE U,USRHI	;IF A USER IS ^Z'ING AND THERE IS NO POSSIBILITY
	SKIPL T,@UTTYO	;OF GETTING MORE JOB SLOTS,
	 CAIGE U,LUBLK*MAXJ
	  JRST POPUJ
	MOVSI U,%TANJS	;THEN MARK THE TTY AS IN NEED OF A "SYSTEM FULL" MESSAGE
	IORM U,TTYSTA(T)
	MOVEI U,SCRCFM	;AND WAKE UP THE SYS JOB.
	IORM U,SUPCOR
	JRST USTSC2	;REMOVE THIS TTY FROM LIST OF THOSE NEEDING A ^Z.

;GOBBLE NEW USER SLOT, RESET VARIABLES (SKIPS IF IT WINS)
USTRA:	MOVEI U,0	;-1(P) MUST BE U
USTR3:	CAML U,USRHI
	JRST USTR1	;ASSIGN MORE CORE TO USER STORAGE
	SKIPN UNAME(U)
	JRST USTR2	;HAVE FOUND FREE USER SLOT (IN U)
	ADDI U,LUBLK
	JRST USTR3

USTR1:	SKIPGE SJCFF
	POPJ P,	;SYSTEM JOB FLUSHING CORE, WAIT UNTIL IT STABILIZES
	MOVEI U,LUBLK	;MOVE UP USRHI IF SYS HAS ENOUGH CORE
	ADD U,USRHI
	PUSH P,T
	MOVE T,HUSRAD	;LENGTH OF SYS
	CAIG T,USRSTG(U)
	JRST MORCOR	;SYS NEEDS MORE CORE FOR USER VARIABLES
	POP P,T
USSINI:	SETOM USTP-LUBLK(U)	;SYS INITIALIZATION ENTRY
	EXCH U,USRHI
USTR2:	PUSHJ P,USTR4	;RESET USER VARIABLES
	MOVEI T,SIOCHN-1(U)
	MOVEM T,SIOCP(U)
	CLEARM IOCHNM(U)
	HRLI T,IOCHNM(U)
	HRRI T,IOCHNM+1(U)
	BLT T,IOCHNM+17(U)	;CLEAR ALL I/O CHANNELS
USRST4:	HRLI T,AC0S(U)
	HRRI T,AC0S+1(U)
	SETZM AC0S(U)
	BLT T,AC17S(U)	;CLEAR AC'S & RETURN HAPPY
	JRST POPJ1

MORCOR:	MOVE U,-2(P)
	SUB P,[1,,1]
	MOVSI T,SCLDEC
	ANDCAM T,SUPCOR	;CLEAR ANY SYS CORE DECREASE REQ
	MOVSI T,SCLEX
	JRST SUPSET	;REQUEST MORE CORE FROM SYS JOB

;
; INITIALIZE A SET OF USER VARIABLES
;  T HAS INITIAL TTYTBL, POSITIVE IT IS TTY # ELSE NO TTY
USTR4:	MOVEM T,TTYTBL(U)
	JUMPL T,USTR4B
	PUSH P,U
	HRRM U,TTYSTS(T) ;TELL TTY IT NOW BELONGS TO NEW JOB,
	MOVSI U,%TSCNS	;AND IS NOW A CONSOLE.
	IORM U,TTYSTS(T)
	MOVSI U,%TSFRE
	ANDCAM U,TTYSTS(T)	;AND IS NO LONGER FREE
	MOVSI U,%TACFM+%TACTZ
	ANDCAM U,TTYSTA(T)	;AND WILL NEED CONSOLE FREE MESSAGE
	POP P,U
	ADDI T,USRRCE
USTR4A:	MOVEM T,UTMPTR(U)
	HRROI T,'000
	MOVEM T,UNAME(U)
	PUSH P,U
	MOVE T,U
	IDIVI T,LUBLK
	POP P,U
	DPB T,[000300,,UNAME(U)]
	LSH T,-3
	DPB T,[060300,,UNAME(U)]
	LSH T,-3
	DPB T,[140300,,UNAME(U)]
	MOVE T,UNAME(U)
	MOVEM T,XUNAME(U)
	MOVEI T,(U)
	HRLI T,%TSCNS
	MOVEM T,TTSTSV+2(U)
	SETZM USWST(U)
	SETZM LUBTM(U)
	SETZM NSWPGS(U)
	SETZM NMPGS(U)
	SETOM JBI(U)		;NOT JOB DEVICE HANDLER (NOT YET, ANYWAY)
	SETZM OPTION(U)
	SETOM TRNLST(U)		;INIT TRANSL LISTS TO NIL
	SETOM TRNLS1(U)
	SETZM HUSRAD(U)
	MOVEI T,UPGCP(U)
	MOVEM T,UCPB1(U)
	ADDI T,NUVPG/4
	MOVEM T,UCPB2(U)
	MOVEI T,UPGMP(U)
IFE KL10P,	HRLI T,<NUVPG/4>_1
	MOVEM T,UDBR1(U)
	ADDI T,NUVPG/4
	MOVEM T,UDBR2(U)
	CLEARM UPGMP(U)
	MOVSI T,UPGMP(U)
	HRRI T,UPGMP+1(U)
	BLT T,UPGCP+NUVPG/2-1(U)
	MOVSI T,(MOVEM U,)
	HRRI T,AC17S(U)
	MOVEM T,SCLUSV(U)
IFN KL10P,[
	MOVSI T,(DATAI PAG,)
	HRRI T,CLCX(U)
	MOVEM T,SCLCXS(U)
	MOVEI T,USRSTG(U)
	LSH T,-9
	HRLI T,701100
	MOVEM T,CLCX(U)
	MOVSI T,(JRST 2,@)
	HRRI T,XUUOH(U)
	MOVEM T,SUEXIT(U)
	MOVSI T,MUUOKN		;UUO NEW PC'S ARE SAME AS SYS JOB'S,
	HRRI T,MUUOKN(U)	; EXCEPT THAT UUO IN EXEC MODE IS AN ERROR
	BLT T,MUUOPT(U)
	MOVEI T,MUUOEX
	HRRM T,MUUOKN(U)
	MOVSI T,(CAI)		;INITIALLY IGNORE TRAPS 1 AND 2
	MOVEM T,TR1INS(U)
	MOVEM T,TR2INS(U)
	MOVEI T,%PI1PR
	MOVEM T,TR3INS(U)	;TRAP 3 GIVES ONE-PROCEED INTERRUPT
]
IFE KL10P,[
	MOVE T,[JRST 2,@UUOH]
	MOVEM T,SUEXIT(U)
]
	MOVSI T,BUSRC
	MOVEM T,USTP(U)
	SETOM SUPPRO(U)
	SETZM UCLBLK(U)
	SETOM UCLBLK+1(U)
	MOVE T,[JRST UREALB]
	MOVEM T,UCLBLK+2(U)
	CLEARM UPGML(U)		;CLEAR USER PG MAP VARIABS
	MOVEI T,UPGML+1(U)
	HRLI T,-1(T)
	BLT T,UPGMLE(U)
IFE KL10P,[
	MOVSI T,1+EXPGNG	;DONT ENABLE QUAN COUNTER FOR NOW (BUT SET EXEC PAGING)
	MOVEM T,UPQUAN(U)
	MOVE T,EXECMP
	MOVEM T,UPDBR3(U)	;SET UP EXEC DBR
	MOVSI T,1040
	MOVEM T,UPACP(U)	;SET UP B+C MEMORY PTRS
]
USRST2:	MOVE T,UNAME(U)	;USER RESET ETC ENTERS HERE
	MOVEM T,USYSNM(U)	;CLOCK MUST BE OFF OR PI IN PROG ON 7
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,E
	MOVEI C,UCLBLK(U)
	SKIPL 1(C)
	JSP E,CLQCLR
IFN N11TYS,[
	SETZM NVDBA(U)	;0 VIDEO BUFFERS ASSIGNED BY JOB.
	SETOM TVCREG(U)
	SKIPL T,TTYTBL(U)
	JRST [	SKIPN TEN11F
		SKIPL TT11P
		JRST .+1
		HRL T,TTYTYP(T)
		TLNN T,%TY11T
		JRST .+1	;NOT A TV
		MOVE A,TT11HD	;11 HEADER ADR
		ADDI A,-NF11TY(T)
		LDB B,[141000,,1(A)]	;VIDEO BUFFER #
		TRO B,17_8	;CSET ALU FCTN
		LSH B,4+16.	;INTO POSITION FOR MOVEMING INTO CONSOLE REG
		MOVEM B,TVVBN(U)
		JRST USTTV1]
	SETOM TVVBN(U)
USTTV1:]
	POP P,E
	POP P,C
	POP P,B
	POP P,A
	SETZM URTIME(U)
	SETZM UTIME(U)
	SETOM RTIMER(U)
	MOVSI T,%PCUSR
	MOVEM T,UPC(U)
	HRLI T,-LUPDL
	HRRI T,UPDL-1(U)
	MOVEM T,USRPDL(U)
	SETZM MSKST(U)
	SETZM MSKST2(U)
	MOVEI T,40
	MOVEM T,40ADDR(U)
	MOVEI T,APRCHN+440
	MOVEM T,APRC(U)
	HRRZS UTRAPM(U)
	SETZM PIRQC(U)
	SETZM IFPIR(U)
	SETZM IDF1(U)
	SETZM IDF2(U)
	SETOM PICLR(U)
	SETZM FLSINS(U)
	SETZM UTRNTM(U)
IFN KL10P,[
	SETZM EBOXCT(U)
	SETZM EBOXCT+1(U)
	SETZM MBOXCT(U)
	SETZM MBOXCT+1(U)
]
	SETZM USIPRQ(U)
	SETZM TRUNTM(U)
	SETZM TSIPRQ(U)
	SETZM LTRNTM(U)
	SETZM LSIPRQ(U)
	SETZM UPGSEC(U)
	SETZM IOTLSR(U)
	MOVSI T,OPTOJB		;USR RESET DOESN'T CLEAR OJB OPTION BIT
	ANDM T,OPTION(U)
	SETOM CORRQ(U)
	POPJ P,

USTR4B:	MOVEI T,USRRCE+NCT
	JRST USTR4A

;	USER START CODE

NUSTCD:	JFCL		;0
	.OPEN 1,7
	JRST 0	;2
	.CALL 12
	.LOGOUT
	.IOT 1,2
	JRST (2)
	4,,(SIXBIT/SYS/)	;7
	SIXBIT /ATSIGN/
	SIXBIT /HACTRN/
	SETZ		;12
	SIXBIT /LOAD/
	16
	SETZ 17
	-1
	1

USTCDR:	MOVE U,USER
	MOVEI A,USTCDR+1	;COME BACK HERE IN CASE OF PCLSR
	MOVEM A,UUOH
	MOVE P,USRPDL(U)
	PUSHJ P,UBLAM
	MOVE U,USER
	MOVSI T,NUSTCD
	XCTR XBW,[BLT T,17]
	MOVE T,JNAME(U)
	XCTR XW,[MOVEM T,11]
	MOVE T,[%PCUSR,,1]
	MOVEM T,UUOH
	JRST URET

SUBTTL USER KILL ROUTINES

;
; CLOSE ALL DEVICES AND INFERIOR PROCEDURES OF A JOB (INDEX IN U)
;
IODCL:	MOVNI I,1	;SET TO STOP
	PUSHJ P,IODCL3	;STOP ALL INFERIOR JOBS (RECURSIVE)
	MOVEI I,0	;THEN KILL.
IODCLA:	PUSH P,I
IFN 340P\E.SP,	PUSHJ P,ADCLOSE	;FLUSH DISPLAY
IFN IMXP,	PUSHJ P,POTCLS	;DISCONNECT HIS POTS
IFN VIDP,[
	CAMN U,SCNUSR
	 PUSHJ P,SCNSTP	;KILL SCANNER IF HIS
]
IFN ARMP,	PUSHJ P,AARMOFF	;FLUSH ARM
IFN DEMON,	PUSHJ P,DEMOUT	;FLUSH EXISTANCE (CURRENT OR FORMER) AS DAEMON.
IFN N11TYS,[
	SKIPE NVDBA(U)
	 PUSHJ P,VBDFLS	;DEASSIGN ALL VIDEO BUFFERS.
]
IFN KL10P,[
	CAME U,MTRUSR	;DEASSIGN THE PERFORMANCE COUNTER
	 JRST IODCL0
	SETOM MTRUSR
	MOVNI A,2
	MOVEM A,MTRJOB
	WRPAE PAEOFF
	CONO MTR,4000
IODCL0:
]
	PUSHJ P,CLQDEL	;RELEASE AND STOP CLOCK QUEUE BLOCK
	 UCLBLK(U)
	HRRZ A,UREALT
	CAMN A,U
	 SETOM UREALT	;UN REAL TIME
	CAMN U,UMASTER	;UNMASTER
	 SETOM UMASTER
	MOVE A,OPTION(U) ;IF USER HAS ENABLED THE SWITCH-UNLOCK FEATURE,
	TLNE A,OPTLOK
	 PUSHJ P,IODCSW	;UNLOCK HIS LOCKED SWITCHES.
	PUSHJ P,AIOPDL	;POP UP ALL OF IO PDL (CLOSING CHNLS POPPED INTO)
	MOVEI R,IOCHNM(U)
IODCL1:	PUSHJ P,CCLOSE	;CLOSE ALL CHANNELS
	CAIGE R,IOCHNM+NIOCHN-1(U)
	 AOJA R,IODCL1
	PUSH P,U
	SKIPGE T,JBI(U)	;IF THIS JOB IS A JOB-DEVICE,
	 JRST IODCL2
	CONO PI,CLKOFF
	SKIPGE JBCG(T)	;AND ITS CREATOR STILL HAS A JOB CHANNEL,
	 JRST IODCL6
	MOVE A,JBCUI(T)	;FLUSH THE CREATOR'S JOB CHANNELS,
	CONO PI,CLKON
	PUSHJ P,RPCLSR	;STOPPING THE CREATOR IN CASE HE'S USING THEM NOW.
	MOVE T,JBI(U)	;RPCLSR CLOBBERS T.
	MOVEI B,IOCHNM(A)
	HRLI B,C	;GET CHNL IN C, THEN SETZM @B TO CLOSE IT.
	LDB C,[0600,,JBCH(T)]
	CAIE C,77	;CLOSE THE JOB INPUT CHANNEL IF ANY.
	 SETZM @B
	LDB C,[060600,,JBCH(T)]
	CAIE C,77	;AND THE OUTPUT CHANNEL IF ANY.
	 SETZM @B
	SOS USTP(A)
IODCL6:	CONO PI,CLKON
	SETOM JBCUI(T)	;FLUSH THE JOB-DEVICE SLOT.
	SETOM JBI(U)	;SAY THIS JOB NO LONGER A JOB-DEVICE.
	JRST IODCL2

IODCL3:	 PUSH P,I	;I=0 KILL I=-1 STOP I=1 JUST CLOSE CHANNELS.
	PUSH P,U
IODCL2:	MOVEI A,0
IODCL4:	HRRZ E,SUPPRO(A)
	SKIPE UNAME(A)	;SKIP IF VARIABLES BLOCK IDLE
	CAIE E,(U)	;SKIP ONLY IF IT IS A DIRECT INF.
	JRST IODCL5	;TRY NEXT SET OF VARS
	PUSH P,A
	MOVE U,A
	PUSHJ P,1USTOP	;STOP (WITH BUSRC BIT)
	MOVE R,P
	MOVE P,USRPDL(U)
	PUSH P,R
	SKIPGE I,-2(R)
	JRST IODCL8	;STOP
	PUSHJ P,IODCLA	;KILL OR CLOSE CHNLS, RECURSE
IODCL9:	MOVE P,(P)
	SKIPE -2(P)	;KILLING?
	JRST IODCL7	;JUST CLOSING CHNLS.
	MOVE A,U	;KILLING; WAIT TILL NO OTHER JOB
	PUSHJ P,AUCL3	;IS LOOKING AT THE ONE THAT WE'RE KILLING.
	PUSHJ P,UBLST2	;FLUSH CORE
	PUSHJ P,ZUSLOG	;ACCOUNT FOR USAGE THEN FLUSH LAST VESTIGES
	CONO PI,CLKON
IODCL7:	POP P,A
	HRRZ U,(P)
IODCL5:	ADDI A,LUBLK
	CAMGE A,USRHI
	JRST IODCL4	;LOOP FOR ALL SETS OF USER VARIABLES
	POP P,U
	SUB P,[1,,1]
	POPJ P,

IODCL8:	PUSHJ P,IODCL3
	JRST IODCL9

;CALL HERE TO UNLOCK THE SWITCHES A JOB HAS LOCKED (USER IDX IN U).
;LOCATION 43 (ACTUALLY, 3+C(40ADDR)) HAS THE LIST POINTER. 0 IS NIL.
;ANYTHING ELSE POINTS TO 2-WORD BLOCK; THE 1ST WORD IS THE SWITCH OR THE
;ADDRESS OF THE SWITCH. THE RH OF THE SECOND IS THE CDR OF THE LIST.
;THE LH OF THE SECOND IS THE UNLOCK INTRUCTION. THE INDEX FIELD IS IGNORED,
;ONE LEVEL OF INDIRECTION IS PERMITTED, AND THE INSN MUST BE EITHER
;AOS OR SOS WITH 0 IN AC FLD, A LOGICAL INSTRUCTION (TOP 3 BITS = 4),
;A HALFWORD INSTRUCTION, OR A MOVE,MOVN,MOVS,MOVN,ADD OR SUB SERIES INSN,
;OR 0 WHICH MEANS SETOM. ONLY INSNS THAT MODIFY MEMORY ARE USEFUL.
;44 IS AN AOBJN POINTER TO THE CRITICAL RTNS TABLE, OF 2-WORDS ENTRIES.
;THE 1ST WORD EACH IS <BEGINNING OF RANGE>,,<END OF RANGE>+1.
;THE SECOND IS THE UNLOCK INSTRUCTION, WITH THE ADDRESS OF THE SWITCH
;IN THE RH (AGAIN, 1 LEVEL OF INDIRECTION IS PERMITTED).
;IF THE PC IS IN THAT RANGE, THE UNLOCK INSN IS EXECUTED.
;43 AND 44 ARE UPDATED DURING PROCESSING TO PREVENT PCLSR LOSSAGE.
;SEE .INFO.;ITS LOCKS


;MACRO TO DO XCTR, OR POPJ IF THAT WOULD CAUSE INTERRUPT.
DEFINE XCTRIJ
	JSP TT,IODCXC
	XCTR!TERMIN

IODCSW:	HRRZ J,U
	MOVE U,USER	;SET UP MAP OF ACTUALLY RUNNING USER
	HRLI J,250000	;TO POINT TO USER BEING HACKED.
	CAIE U,(J)	;IF THEY'RE NOT THE SAME, THE ACS
	 TLO J,4000	;ARE IN THE SWAP-OUT ACS.
	PUSHJ P,MPLD1
	HRRZ U,J	;U HAS WHAT IT HAD AT CALL (USR BEING HACKED).
	MOVEI C,1000	;COUNT LENGTH OF LIST SO CIRCULAR LISTS DON'T HANG US UP.
	HRRZ E,40ADDR(U)
	XCTRIJ XRW,[MOVES B,3(E)] ;GET HIS "43" (AND MAKE SURE IT'S WRITABLE)
IODCS1:	JUMPE B,IODCS2		;REACHED END OF LOCKED SWITCH LIST, MAYBE?
	XCTRIJ XR,[HLL B,1(B)]	;MERGE LOCK INSN WITH ADDR OF SWITCH.
	PUSHJ P,IODCDO		;EXECUTE THE UNLOCK INSN
	 POPJ P,		 ;IODCDO DETECTED MPV OR PUR INTERRUPT.
	XCTR XR,[HRRZ B,1(B)]	;REPLACE LIST BY ITS CDR.
	XCTR XW,[MOVEM B,3(E)]
	SOJG C,IODCS1

IODCS2:	XCTRIJ XRW,[MOVES E,4(E)]	;GET JOB'S "44", AND MAKE SURE IT'S WRITEABLE.
	HRRZ C,UPC(U)		;GET ITS PC, FOR COMPARISON.
	JUMPGE E,IODCSX		;THERE ARE NO PROTECTED RANGES => DONE.
IODCS3:	XCTRIJ XR,[MOVS B,(E)]	;GET BOUNDS OF NEXT PROTECTED RANGE.
	CAIGE C,(B)		;IS PC ABOVE LOWER BOUND?
	 JRST IODCS4
	MOVSS B
	CAIL C,(B)		;IS IT BELOW UPPER?
	 JRST IODCS4
	XCTRIJ XR,[MOVE B,1(E)]	;PC IS IN THIS RANGE; GET UNLOCK INSN
	PUSHJ P,IODCDO		;EXECUTE IT
	 POPJ P,		;NO SKIP => MPV OR PUR INTERRUPT DETECTED.
IODCS4:	ADD E,[2,,2]		;CHECK ALL ENTRIES IN CRITICAL RTN TABLE, 1 BY 1.
	HRRZ B,40ADDR(U)	;UPDATE 44 SO ENTRIES ALREADY PROCESSED ARE
	XCTR XW,[MOVEM E,4(B)]	;ACTUALLY IN THE TABLE. THIS IS IN CASE PCLSR.
	JUMPL E,IODCS3
IODCSX:	PUSH P,U
	MOVE U,USER		;RESTORE NORMAL PAGE MAP OF RUNNING USER.
	PUSHJ P,MPLDZ
	JRST POPUJ

;PRECEDE AN XCTR WITH JSP TT,IODCXC TO POPJ IF THE XCTR WOULD
;CAUSE AN INTERRUPT (MPV OR PUR). CLOBBERS A,T,Q.
IODCXC:	MOVEI A,@(TT)	;GET EFFECTIVE ADDR OF XCTR.
	MOVEI A,@(A)	;GET EFFECTIVE ADDR OF XCTR'ED INSN.
	LSH A,-10.	;GET PAGE # BEING REFERENCED.
	PUSHJ P,UPLC	;SET T = B.P. TO PAGE MAP HALFWORD. CLOBBERS Q.
	LDB T,T
	TRNE T,600000	;IF PAGE IS SWAPPED IN, PUT ACCESS BITS IN
	 LSH T,-20	;SAME PLACE THEY ARE WHEN SWAPPED OUT (LOW 2 BITS).
;FOLLOWING CODE COMMENTED OUT BECAUSE IT DOESN'T WORK ON THE KL10 XCTR
;	TRNE T,2	;CHANGE CODE 2 (READ-WRITE, NOT WRITTEN) TO 3 (READ-WRITE).
;	 IORI T,1
;	LSH T,27	;PUT ACCESS CODE IN AC FIELD, AND TEST
;	ANDCA T,(TT)	;AGAINST WHAT THE XCTR WILL TRY TO DO.
;	TLNN T,(0 3,)	;ALL DESIRED ACCESS AVAILABLE =>
;	 JRST (TT)	;WE WIN.
;	POPJ P,		;ELSE QUIT OUT OF CALLING ROUTINE.
;
;FOLLOWING CODE INSERTED INSTEAD.  THIS RELIES ON THE FACT
;THAT ONLY THE FOLLOWING INSTRUCTIONS ARE XCTRIJ'ED:
; BOOLE,HWT,MOVXX,ADDX,SUBX,AOSX,SOSX
	MOVE A,@(TT)	;GET INSTRUCTION XCTR'ED
	TLC A,300000
	TLCE A,300000	;SKIP IF AOS OR SOS
	 TLNE A,002000	;SKIP IF DOESN'T WRITE IN MEMORY
	  TRNE T,2	;INSTRUCTION WRITES, SKIP IF RW OR RWF ACCESS NOT PRESENT
	   TRNN T,3	;INSTRUCTION READS, SKIP IF ANY ACCESS PRESENT
	    POPJ P,	;INSUFFICIENT ACCESS, QUIT OUT OF CALLING ROUTINE
	JRST (TT)	;WINNING, GO DO THE XCTR

;PUSHJ P,IODCDO WITH INSN IN B TO XCTRIJ IT, CHECKING FOR LEGALITY
;AND PERFORMING ONE LEVEL OF INDIRECTION IF THE @ BIT IS SET.
;(WE CAN'T AFFORD AN INFINITE LOOP WHILE KILLING A JOB EVEN IF IT IS
;INTERRUPTABLE)
;INDEX FIELD IS IGNORED. IF THE OPCODE IS 0, SETOM IS USED INSTEAD.
;SKIPS IF INSN IS LEGAL AND DOESN'T CAUSE MPV OR PUR INTERRUPT.
;CLOBBERS A,D,J,T,TT,Q
IODCDO:	MOVE J,B	;B IS NOT CLOBBERED.
	TLZN J,(@)
	 JRST IODCD1
	XCTRIJ XR,[HRR J,(J)]	;INDIRECTION IS WANTED; DO IT.
IODCD1:	TLNN J,-1	;IF LH IS 0, REPLACE BY (SETOM)
	 HRLI J,(SETOM)
	LDB A,[271500,,J]
	CAIE A,AOS_-27	;AOS AND SOS ARE LEGAL WITH 0 IN AC FIELD.
	 CAIN A,SOS_-27
	  JRST IODCD2
	LDB A,[410300,,J]
	CAIE A,4	;ALL INSNS WITH 4 IN TOP 3 BITS (LOGICAL INSNS) ARE OK.
	 CAIN A,5	;HALFWORD INSTRUCTIONS ALSO OK.
	  JRST IODCD3
	LDB A,[360600,,J]
	CAIE A,MOVE_-36	;ALL FORMS OF MOVE, MOVS, MOVN AND MOVM OK
	 CAIN A,MOVN_-36
	  JRST IODCD3
	CAIE A,ADD_-36	;ADD & SUB OK.      (OF COURSE, ONLY TO-MEMORY INSNS MAKE SENSE)
	 POPJ P,
IODCD3:	LDB A,[270400,,J] ;AC FIELD NEED NOT BE 0, SO GET CONTENTS OF SPEC'D AC,
	XCTR XR,[MOVE D,(A)]
	MOVEI A,D
	DPB A,[270400,,J] ;AND MAKE THE INSN USE AC D, WHERE THE VALUE IS.
IODCD2:	TLZ J,17
	XCTRIJ XRW,J	;EXECUTE INSN, CHECKING FOR INTERRUPTS.
	AOS (P)
	POPJ P,

; FLUSH LAST VESTIGES OF USER
;  ELIMINATES ALL POINTERS TO USER & FREES USER VARIABLES (CLOBBERS U TO "USER")
;
ZUSER:	MOVEI A,(U)	;CLEAR BOTH TRANSLATION LISTS
	HRLI A,300000	;FOR THIS JOB.
	PUSHJ P,NTRNC
	 JFCL
	MOVEI A,0	;AND GET RID OF EXISTING FOREIGN-USER CHANNELS.
ZUSER2:	SKIPE UNAME(A)
	 PUSHJ P,ZUSES	;SEE IF THIS USER HAS ANY POINTERS TO BE FLUSHED
	ADDI A,LUBLK
	CAMGE A,USRHI
	 JRST ZUSER2	;LOOP FOR ALL SETS OF USER VARIABLES
	CONO PI,CLKOFF
	SKIPE NMPGS(U)	;USER SHOULD HAVE NO MEMORY BY NOW
	 JRST 4,.
	SETZM UNAME(U)	;ONLY PLACE THAT UNAME IS ZEROED
	SETOM USTP(U)	;SET USTP TO SPEED SEARCH
	MOVE A,U	;USER FLUSHED
	MOVE U,USER
	MOVSI T,SCLDEC
	IORM T,SUPCOR	;CAUSE USER VARIABLE BLOCKS DECREASE PROGRAM TO RUN
	POPJ P,		;RETURN WITH CLOCK OFF


ZUSES:	PUSH P,B	;CALLED BY ADISOWN
	PUSH P,R
	SETZM B		;CLEAR STOPPED PROC FLAG
	PUSHJ P,CHSCAA	;EXECUTE FOLLOWING INST FOR EACH CHANNEL AND I/O PDL SLOT
	    PUSHJ P,ZACHEK
	POP P,R
	SKIPE B		;SKIP UNLESSS YOU STOPPED THE PROC
	 PUSHJ P,UPCLSR	;RESTART USER
	JRST POPBJ

ZACHEK:	HLRZ T,(R)	;CHECK FOR CHANNEL TO ZAP
	CAME T,U
	 POPJ P,
ZACHK4:	HRRZ T,(R)
	HLRZ T,CLSTB(T)
	TRNN T,501040	;IS IT EITHER TYPE OF USER CHANNEL? OR JOB CHNL?
	 POPJ P,
	TRON B,-1	;SET FLAG
	 PUSHJ P,RPCLSR	;STOP USER
	HRRZ T,(R)	;CLEAR OUT IOCHNM OR I/O PDL SLOT
	HLRZ T,CLSTB(T)
	TRNE T,500040	;IS IT A FOREIGN USR CHNL?
	 JRST ZACHK2	;NO, SUPERIOR OR JOB CHNL.
	JUMPG R,ZACHK1	;IOPDL CHANNEL
	HRRZ T,R	;NORMAL CHANNEL
	SUBI T,IOCHNM(A)
	MOVE T,CHNBIT(T)
	AND T,MSKST2(A)
	IORM T,IFPIR(A)
ZACHK2:	SETZM (R)
	POPJ P,

ZACHK1:	MOVEI T,IIOPOP
	MOVEM T,(R)
	POPJ P,

ZUSLOG:	PUSH P,[ZUSER]		;DO LOGUSE THEN ZUSER

;LOG RUNTIME AND SWAPIN REQUESTS USED BY JOB IN U
;JOB CALLED FOR SHOULD NOT BE CURRENT OR ABLE TO RUN DURING CALL
;JOB SHOULD NOT BE TOP LEVEL EXCEPT WHEN DMNPLO CALLS
; HERE JUST BEFORE SENDING THE USAGE TO THE DEMON
;CLOBBERS T,TT,I

LOGUSE:	MOVN TT,UTRNTM(U)
	MOVN T,USIPRQ(U)
	EXCH TT,TRUNTM(U)	;AVOID CHARGING FOR THIS USAGE TWICE
	EXCH T,TSIPRQ(U)
	SUB TT,TRUNTM(U)	;COMPUTE TOTAL USAGE NOT YET CHARGED
	SUB T,TSIPRQ(U)
	SKIPGE I,SUPPRO(U)	;FIND HIGHEST JOB IN TREE
	 POPJ P,		;BUT IF TOP LEVEL RETURN WITH USAGE IN TT, T
	SKIPL SUPPRO(I)
	 JRST [ MOVE I,SUPPRO(I) ? JRST .-1 ]
	ADDM TT,TRUNTM(I)	;ADD CHARGES TO TREE'S ACCOUNT
	ADDM T,TSIPRQ(I)
	POPJ P,

;DO LOGOUT FOR TREE HEADED BY JOB IN U
;CALLER SHOULD THEN PUSHJ P,DMNPLI TO LOG JOB BACK IN
;THIS IS USED TO KEEP ACCOUNTING STRAIGHT WHEN DETACH, CHUNAME, RELOAD (SIGH)
;IF JOB IS CURRENTLY RUNNING, TIME USED IN CURRENT QUANTUM
;WON'T GET CHARGED THIS TIME AROUND.  TOO BAD.
;CLOBBERS T,TT,I,J,D. CALL WITH CLKOFF OR IN PROGRESS.

LOGUPD:	PUSH P,U
	MOVE J,UTMPTR(U)
	MOVEI U,LUBLK
LOGUP1:	ADDI U,LUBLK
	CAML U,USRHI
	 JRST LOGUP2
	CAMN J,UTMPTR(U)	;SKIP JOBS IN OTHER TREES (FOR SPEED)
	 SKIPGE SUPPRO(U)	;AND SKIP TOP LEVEL JOBS
	  JRST LOGUP1
	PUSHJ P,LOGUSE		;PROBABLY AN INFERIOR IN TREE LOGGING OUT, UPDATE ACCT
	JRST LOGUP1

LOGUP2:	POP P,U
	JRST DMNPLO		;TELL DEMON ABOUT TREE'S USAGE

SUBTTL USER UUO WAIT (HANG UP) ROUTINE
;  DOES NOT WORK FOR XCT T OR FOR X (U) IF U .NE. USER
;
UFLS:	CONSZ PI,77400
	 JRST 4,.	;PI IN PROG?
	CONO PI,CLKOFF	;DOES NOT ALLOW CLOCK INTS
	XCT CLUSAV
	SKIPGE U,USER	;GET INDEX OF USER BEING BLOCKED
	 JRST 4,.	;NULL JOB SHOULD NOT GET BLOCKED
	MOVEM T,EPDL2(U)	;SAVE C(T) FOR FLSINS AT PCLSR
	MOVEM T,AC16S(U)	;SAVE IN SWAP OUT AC ALSO
	POP P,UPC(U)		;WORK FOR INST INDEX OF P
	MOVEI T,AC0S(U)
	BLT T,AC15S(U)	;STORE REST OF ACS
	MOVE T,UPC(U)	;GET PC AT CALL (=CALL+1 ; =SKIP +2)
	MOVE U,AC17S(U)	;WIN FOR INSNS INDEX OF U.
	SKIPA T,-2(T)	;GET POINTER TO SKIP
UFL3:	 MOVE T,(T)	;GET CONTENTS OF E (WAS AN XCT)
	HRRI T,@T	;CALCULATE E
	TLZ T,37	;CLEAR OUT @ AND INDEX BITS
	MOVE U,USER
	MOVEM T,FLSINS(U)	;STORE AS BLOCKING CONDITION
	TLC T,(XCT)
	TLNN T,777740
	 JRST UFL3	;JUMP IF INSTRUCTION WAS XCT
	MOVSI T,210000
	ANDCAM T,USWST(U)	;CLEAR WAITING FOR PAGE (ZERO) TYPE FLSINS
	SKIPGE RPCL(U)	;SKIP IF NOT BEING RPCLSRED
	 JRST UFL1	;LOSER IS BEING RPCLSRED
UFL6:	MOVE U,AC17S(U)	;FOR CLUSAV TO STORE
	SETOM UFLSF
	CONO PI,CLKRQ	;CAUSE INTERRUPT TRANSFERING TO CLOCK ROUTINE PI IN PROGRESS
IFN KL10P,JRST .	;ON KL SEEMS TO TAKE A WHILE TO GO OFF
IFE KL10P,JRST 4,.	;ON KA SHOULD GO OFF RIGHT AWAY

UFL1:	MOVE P,CPDLP	;MUST NOT USE USR PDL SINCE THAT CAN
			;GET CLOBBERED BY LSWDIS VIA UFL5
			;CLOCK IS OFF, SO CPDLP IS OK
IFE KL10P,[
	MOVE T,UEXIT	;PICK UP EXIT INSTR
	CAME T,[JRST ONEPROC]	;SKIP IF WAS TRYING TO ONE PROCEED THE UUO THAT HUNG
	 JRST UFL1A	;NOT ONE PROCEEDING
	MOVSI T,%PC1PR	;GET ONE PROCEED BIT
	IORM T,UUOH	;TURN IT ON IN PC
UFL1A:]
	SOS T,UUOH	;UUOH HAS REAL PC IF UFL5 SKIPS. WILL GET SET BY UUOE1
	PUSHJ P,UFL5	;BACK UP TO UUO
	 JRST UFL6	;FINALIZATION REQUIRED
	MOVE T,RPCL(U)
	JRST ONEFL2	;WIN

SUBTTL VARIOUS WAIT & LOCK-SWITCH ROUTINES
;
;WAIT FOR INSTRUCTION AFTER CALL TO SKIP WITH UTCCHN OFF
;
LWAIT1:	CONO PI,UTCON	;TURN INTERRUPTS ON
LWAIT:	PCLT
	XCT @(P)	;ENTRY, EXECUTE INSTRUCTION
	PUSHJ P,UFLS	;HANG TILL INSTRUCTION SKIPS
	CONO PI,UTCOFF	;TURN INTERRUPTS OFF
	XCT @(P)	;TRY AGAIN
	JRST LWAIT1	;LOSE
	JRST POPJ1	;WIN, RETURN SKIPPING OVER ARG
;
;WAIT FOR LOCK VAR (@ NEXT LOC) TO BE -1 AND SEIZE IT
;
SWTL:	PCLT
	MOVEI T,(@)	;ENTRY
	HRLM T,(P)	;MAKE PC STORED ON PDL INDIRECT
	MOVEI T,@(P)	;ADDRESS OF SWITCH
	SKIPGE @(P)	;SKIP IF ALREADY LOCKED
	JRST SWTL1	;NOT LOCKED SO TRY TO GRAB IT
	HLRZ T,1(T)	;USER THAT HAS SWITCH
	ANDI T,77
	IMULI T,LUBLK
	CAMN T,USER	;SKIP IF THIS USER DOESN'T HAVE IT
	JRST 4,.	;THIS USER ALREADY HAS THAT SWITCH
SWTL1:	SKIPL @(P)	;(DO NOT CHANGE TO AOSE)
	PUSHJ P,UFLS	;HANG TILL NEGATIVE
	CONO PI,CLKOFF
	AOSE @(P)
	JRST SWTL1
SWTL2:	MOVEI T,@(P)
SWTL3:	PUSH P,U
	PUSH P,T
	MOVE T,USER
	IDIVI T,LUBLK
	ADDI T,600000
	MOVE U,USER
	HRL T,LSWPR(U)
	POP P,U
	MOVSM T,1(U)
	MOVE T,USER
	HRRZM U,LSWPR(T)
	POP P,U
	JRST CLKOJ1
;
;IF LOCK ALREADY SEIZED, JUST SET UP POINTERS
SWTLZ:	MOVEI T,(@)
	HRLM T,(P)
	JRST SWTL2
;
SWTAD:	PCLT	;TRY TO LOCK SWITCH (@NEXT LOCN). IF SUCEED, SKIP EXTRA TIME.
	MOVE T,@(P)	;IF FAIL, DO N LSWPOPS (AS SPEC IN 4.6-4.1 OF NEXT WORD)
	SKIPGE (T)	;AND WAIT FOR SWITCH TO SEEM TO BE AVAILABLE.
	JRST SWTAD1	;THEN RETURN (NOTE: NOT LOCKING IT).
SWTAD2:	TLNN T,77000
	JRST SWTAD3
	PUSH P,T
	PUSHJ P,LSWPOP
	POP P,T
	SUB T,[1000,,]
	JRST SWTAD2

SWTAD3:	SKIPL (T)
	PUSHJ P,UFLS
	JRST POPJ1

SWTAD1:	CONO PI,CLKOFF
	AOSE (T)
	JRST 	[CONO PI,CLKON
		 JRST SWTAD2]
	AOS (P)	;SKIP OVER FAILURE RETURN
	JRST SWTL3

;
;WAIT FOR INSTRUCTION AFTER CALL TO SKIP WITH CLKCHN OFF
CWAIT1:	CONO PI,CLKON	;TURN CLOCK ON
CWAIT:	PCLT
	XCT @(P)	;ENTRY, EXECUTE INSTRUCTION
	PUSHJ P,UFLS	;HANG TILL INSTRUCTION SKIPS
	CONO PI,CLKOFF	;TURN CLOCK OFF
	XCT @(P)	;TRY AGAIN
	JRST CWAIT1	;LOSE
	JRST POPJ1	;WIN, RETURN SKIPPING OVER ARG
;
;WAIT FOR LOCK VAR (@ NEXT LOC) TO BE NON-NEGATIVE AND SEIZE IT
LSWTL:	PCLT
	MOVEI T,(@)	;IF 4.9 OF NEXT LOCN =1, RETURN WITH UTCOFF
	HRLM T,(P)
	MOVSI T,400000
	PUSHJ P,LWAIT
	SKIPGE @-1(P)
	IORM T,@(P)
	MOVE T,(P)
	SKIPL (T)
	CONO PI,UTCON
	MOVEI T,@(P)
LSWTL2:	PUSH P,TT
	MOVEI TT,600100
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SWITCH LIST LOCK, DOES NOT WORK FOR SWITCHES POINTED TO INDEX OF A, B, OR D
;FOLLOW BY LIST OF SWITCHES
;4.9-4.1=0 3.9-3.6 0 AOSE SWITCH 1 SIGN SWITCH
SLUGH:	PCLT
	PUSH P,A
	PUSH P,B
	PUSH P,D
	MOVEI T,AC0S(U)
	BLT T,AC0S+17(U)	;FOR SLWAIT FIRST TIME
SLUGH1:	HRRZ T,-3(P)	;POINTER TO SWITCH LIST
	PUSHJ P,SLWAIT
	PUSHJ P,UFLS
	HRRZ T,-3(P)
SLUGH2:	MOVE A,(T)	;TRY TO LOCK LIST
	TLNE A,777000
	JRST SLUWIN	;REACHED END OF LIST
	LDB B,[220400,,A]	;INDEX
	LDB D,[300300,,A]
	SKIPE B
	ADD A,(B)
	HRRZS A
	CAIL D,2
	JRST 4,.
	XCT SLLOCK(D)
	JRST SLULOS
	AOBJP T,SLUGH2	;LH COUNTS SWITCHES SUCCESSFULLY SEIZED

SLWAIT:	MOVE A,(T)
	TLNE A,777000
	JRST POPJ1	;WIN
	LDB B,[220400,,A]	;INDEX
	LDB D,[300300,,A]	;TYPE CODE
	JUMPE B,SLWT1
	ADD B,U
	ADD A,AC0S(B)
SLWT1:	CAIL D,2
	JRST 4,.
	XCT SLWATT(D)
	POPJ P,	;LOSE
	AOJA T,SLWAIT	;THAT SWITCH OK, TRY OTHERS

SLWATT:	SKIPL (A)	;WAIT FOR NEG (AOSE SW)
	SKIPGE (A)	;WAIT FOR POS (SIGN SW)

SLUWIN:	POP P,D
	POP P,B
	POP P,A
	SUB P,[1,,1]	;"RETURN" BUT NOT INCREMENTED
	JRST (T)

SLLOCK:	PUSHJ P,SWTLX
	PUSHJ P,LSWTLX

SLULOS:	HLRZ A,T
SLULO2:	JUMPE A,SLUGH1	;NONE SEIZED TRY AGAIN
	PUSHJ P,LSWPOP	;RELEASE THOSE SEIZED
	SOJA A,SLULO2

SWTLX:	CONO PI,CLKOFF	;DON'T GO OFF HALF-LOCKED
	AOSE (A)
	 JRST CLKONJ
	EXCH A,T
	PUSHJ P,SWTL3
	 JRST 4,.
SWTLX1:	EXCH A,T
	JRST POPJ1

LSWTLX:	CONO PI,UTCOFF
	SKIPGE (A)
	 JRST UTCONJ
	MOVSI B,400000
	IORM B,(A)
	CONO PI,UTCON
	EXCH A,T
	PUSH P,TT
	MOVEI TT,600100
	PUSHJ P,LSWSET
	POP P,TT
	JRST SWTLX1

;SET UP ROUTINE TO SETOM VARIABLE UPON UNLOCKING SWITCH
STMSET:	PUSH P,TT
	MOVEI TT,600600
	JRST COMSET

IFN 0,[
;SET UP ROUTINE TO BE CALLED ON PCLSR'ING OUT
FINSET:	MOVE T,@(P)
	HRLI T,-1(P)
	PUSH P,TT
	MOVEI TT,400200
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1
]

;SET UP ROUTINE TO AOS VARIABLE UPON UNLOCKING SWITCH
AOSSET:	PUSH P,TT
	MOVEI TT,600500
	JRST COMSET

;SET UP ROUTINE TO SOS VARIABLE UPON UNLOCKING SWITCH
SOSSET:	PUSH P,TT
	MOVEI TT,600300
	JRST COMSET

;SET UP ROUTINE TO SOS LH UPON UNLOCKING SWITCH
;HALT IF SWITCH'S LH EVER BECOMES NEGATIVE
SOLSET:	PUSH P,TT
	MOVEI TT,600700
	JRST COMSET

;SET UP ROUTINE TO BE CALLED UPON UNLOCKING SWITCH
LOSSET:	MOVE T,@(P)
	HRLI T,-1(P)
	PUSH P,TT
	MOVEI TT,600200
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SET UP ROUTINE TO CLEAR SIGN BIT OF VARIABLE UPON UNLOCKING SWITCH
SGNSET:	PUSH P,TT
	MOVEI TT,600100
	JRST COMSET

;SET UP ROUTINE TO DO NOTHING UPON UNLOCKING SWITCH
NULSET:	PUSH P,TT
	MOVEI TT,0
	PUSHJ P,LSWSET
	POP P,TT
	POPJ P,

;ROUTINE TO ADD THIS PROCEDURE TO A LIST POINTED TO
;BY THE WORD AFTER THE CALL.  UNLOCKING REMOVES IT FROM THE LIST
LSTSET:	PUSH P,TT	;LEAVES CLKON
	MOVEI TT,600400
	PUSHJ P,LSTST3
	POP P,TT
	JRST POPJ1

LSTST3:	PUSH P,U
	PUSH P,Q
	MOVEI Q,LSWB0(U)
REPEAT NULBLK,[
IFN .RPCNT,ADDI Q,2
	SKIPN 1(Q)
	JRST LSTST2
]
	JRST 4,.	;NOT ENOUGH BLOCKS
LSTST2:	MOVE T,@-4(P)	;ADDRESS OF HEAD OF LIST
	CONO PI,CLKOFF
	PUSH P,(T)	;PUSH HEAD OF LIST
	POP P,(Q)	;POP INTO LSWB BLOCK
	MOVEM Q,(T)
	HRLM T,(Q)
	MOVE T,(Q)
	TRNE T,-1
	HRLM Q,(T)
	CONO PI,CLKON
	JRST LSWSE3

;SET UP ROUTINE TO SETOM VARIABLE UPON UNLOCKING OF SWITCH
;BY OTHER THAN PCLSRING OUT
STMNPS:	PUSH P,TT
	MOVEI TT,200600
	JRST COMSET

;SET UP ROUTINE TO BE CALLED UPON UNLOCKING OF SWITCH
;BY OTHER THAN PCLSRING OUT
LNPSET:	PUSH P,TT
	MOVEI TT,200200
	JRST COMSET

COMSET:	EXCH TT,(P)
	MOVE T,@-1(P)
	MOVEI T,@T
	EXCH TT,(P)
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SET USER LOCK SWITCH BLOCK,  WD1 IN T,  MODE IN TT
LSWSET:	PUSH P,U
	MOVE U,USER
	PUSH P,Q
	MOVEI Q,LSWB0(U)
REPEAT NULBLK,[IFN .RPCNT,ADDI Q,2
	SKIPN 1(Q)
	JRST LSWSE2
]
	JRST 4,.	;NOT ENOUGH BLOCKS

LSWSE2:	MOVEM T,(Q)
LSWSE3:	MOVE T,U
	IDIVI T,LUBLK
	MOVE U,USER
	HRL T,LSWPR(U)
	IOR T,TT	;GET TYPE
	MOVSM T,1(Q)
	HRRZM Q,LSWPR(U)
	JRST POPQUJ

LSWCJ1:	AOS (P)		;EXIT TO DO LSWCLR AND SKIP-RETURN.

;UNLOCK ALL SWITCHES, CALLED BY OPENL, ADISOWN, IOADCR
LSWCLR:	PUSH P,T
LSWCL1:	SKIPN T,LSWPR(U)	;MUST HAVE USER IN U
	JRST POPTJ
	PUSHJ P,LSWPOP
	JRST LSWCL1

LSWPJ1:	AOS (P)
LSWPOP:	PUSH P,U
	MOVE U,USER
	TLO U,400000	;SIGNAL NOT PCLSR
	SKIPN T,LSWPR(U)
	JRST 4,.
	PUSHJ P,LSWPPP
	JRST POPUJ

LSWPPP:	PUSH P,A
	PUSH P,T
	MOVE A,1(T)
	HRRZM A,LSWPR(U)
	CAIL T,USRSTG
	 SETZM 1(T)
	PUSHJ P,LSWDIS
	POP P,T
	POP P,A
	POPJ P,

;4.9=1 => PERFORM FUNCTION ON PCLSR
;4.8=1 => PERFORM FUNCTION ON ANY LSWPOP OTHER THAN PCLSR
;3.7-3.9 => FUNCTION

;-1(P) HAS POINTER TO SWITCH BLOCK TO UNDO.
;A HAS SECOND WORD OF THAT BLOCK.
LSWDIS:
	LDB T,[300300,,A]	;FUNCTION
	TLNE A,400000	;SKIP IF NOT FOR PCLSR
	 JUMPGE U,LSWDS1	;PCLSRED AND 4.9=1
	TLNN A,200000	;NOT FOR PCLSR OR FOR PCLSR BUT NOT PCLSRED
	 POPJ P,	;NOT FOR EITHER LSWPOP
	JUMPGE U,CPOPJ	;FOR OTHER LSWPOP BUT PCLSRED
LSWDS1:	JRST LSWTAB(T)

LSWTAB:	JRST UNSWTL	;0 (AOSE) ALSO USED FOR QUSR
	JRST UNLSWT	;1 (SIGN)
	JRST ULROUT	;2 (GO TO ROUTINE)
	JRST ULAOS	;3 (AOS, SOS)
	JRST UNLST	;4 (UNLOCK FROM LIST)
	JRST ULSOS	;5 (SOS, AOS)
	JRST ULSTM	;6  (SETOM)
	JRST ULAOSL	;7 (AOS,SOS LEFT HALF)

UNSWTL:	MOVE T,-1(P)
	SETOM (T)
	POPJ P,

ULSTM:	MOVE T,@-1(P)
	SETOM (T)
	POPJ P,

UNLSWT:	MOVE T,@-1(P)
	MOVSI A,400000
	ANDCAM A,(T)
	POPJ P,

ULAOSL:	MOVE T,@-1(P)
	MOVSI A,-1
	ADDB A,(T)
	JUMPGE A,CPOPJ
	JRST 4,.		;OVER-SOS'ED

ULAOS:	MOVE T,@-1(P)
	SOS (T)
	POPJ P,

UNLST:	SETOM DLSRCH
	MOVS T,@-1(P)
	HLRM T,(T)
	MOVSS T
	TRNE T,-1
	HLLM T,(T)
	SETZM DLSRCH
	POPJ P,

ULSOS:	MOVE T,@-1(P)
	AOS (T)
	POPJ P,

ULROUT:	MOVE T,@-1(P)
	TLNE A,200000
	 JRST ULROU1	;A LOSSET - MAY CLOBBER A OR T; USR INDEX IN U
	HRRZM T,UPC(U)	;IT'S A FINSET, EXPECTS THE OLD METHOD OF CALL.
	TLNE T,-1
	 HLRM T,AC15S(U)
IFN KL10P,[
	MOVSI T,%PSPCU	;IT MIGHT TRY AN XCTR
	HLLM T,UPC(U)
]
	TLOE U,200000	;SIGNAL PC CLOBBERED
	 JRST 4,.	;PC TRIED TO BE CLOBBERED TWICE
	POPJ P,

ULROU1:	JUMPGE U,(T)	;IF LOSSET, AND LSWPOPPING,
	MOVE A,[B,,AC0S+B]
	ADDI A,(U)	;PUT THE ACS IN THE AC0S, SINCE
	BLT A,AC0S+H(U)	;THAT'S WHERE THEY'LL BE IF CALL LOSSET ROUTINE WHILE PCLSRING.
	JRST (T)

LSWZAP:	PUSH P,U
	PUSH P,A
LSWZP1:	PUSH P,T	;FROM PCLSR
	MOVE A,1(T)
	HRRZM A,LSWPR(U)
	CAIL T,USRSTG
	 SETZM 1(T)
	PUSHJ P,LSWDIS
	POP P,T
	HRR U,-1(P)
	SKIPE T,LSWPR(U)
	JRST LSWZP1
	POP P,A
	SUB P,[1,,1]
	TLZN U,200000	;HAS PC BEEN CLOBBERED?
	JRST PCLSR7	;NO
	SKIPLE PCLDBM
	SETZM LSUUO(U)	;INDICATE OCCURRENCE OF FINSET (WILL MEAN WE HAVEN'T MISSED MARK)
	JRST PCLSR4	;REQUIRED TO START UP ROUTINE

;FIND SWITCH POINTED TO BY WORD AFTER
;PUSHJ P,LSWREM AND UNLOCK IT
LSWREM:	PUSH P,T
	PUSH P,U
	PUSH P,Q
	MOVE U,USER
	SKIPN U,LSWPR(U)
	JRST 4,.
	HRRZ Q,@-3(P)
	MOVEI T,1
LSWRM1:	CAMN U,Q
	JRST LSWRM2
	HRRZ U,1(U)
	JUMPE U,[JRST 4,.]
	AOJA T,LSWRM1
LSWRM2:	POP P,Q
	POP P,U
	PUSHJ P,LSWPON
	AOS -1(P)
	JRST POPTJ

LSWDEL:	PUSH P,U	;REMOVE SWITCH FROM HEAD OF LIST
	MOVE U,USER	;DO NOT ATTEMPT TO UNLOCK IT
	PUSH P,T
	SKIPN T,LSWPR(U)
	JRST 4,.
	PUSHJ P,LSWDDD
	JRST POPTUJ

LSWDDD:	PUSH P,Q
	HRRZ Q,1(T)
	HRRZM Q,LSWPR(U)
	CAILE T,USRSTG
	SETZM 1(T)
	POP P,Q
	POPJ P,

;POP C(T)'TH FROB BACK
LSWPON:	PUSHJ P,LSWBAK
	PUSHJ P,LSWPPP
	POPJ P,

;DELETE C(T)'TH FROB BACK
LSWDLN:	PUSHJ P,LSWBAK
	PUSHJ P,LSWDDD
	POPJ P,

LSWBAK:	PUSH P,U
	MOVE U,USER
	TLO U,400000	;SIGNAL NOT PCLSR IN CASE OF LSWPPP
	PUSH P,Q
	MOVE Q,T
	MOVEI T,LSWPR-1(U)
	SOJE Q,LSWBA3	;UNLOCKING FIRST FROB
	MOVE T,1(T)
	SOJG Q,.-1
LSWBA2:	MOVE Q,T
	HRRZ T,1(T)
	PUSH P,LSWPR(U)	;DON'T WORRY, YOU CAN'T GET PCLSR'ED JUST BELOW
	XCT @-3(P)
	HRRZ T,LSWPR(U)
	HRRM T,1(Q)
	POP P,LSWPR(U)
	JRST POPQU1

LSWBA3:	MOVE T,LSWPR(U)
	XCT @-2(P)
	JRST POPQU1

SUBTTL VARIOUS RETURNS

PPBAJ1:	POP P,B
POPAJ1:	AOSA -1(P)
POPBAJ:	POP P,B
POPAJ:	POP P,A
CPOPJ:	POPJ P,

POPQJ:	POP P,Q
	POPJ P,

POPBJ1:	AOSA -1(P)
POPCBJ:	POP P,C
POPBJ:	POP P,B
	POPJ P,

POPJ3:	AOS (P)
POPJ2:	AOSA (P)
POPCJ1:	POP P,C
POPJ1:	AOSA (P)
POPCJ:	POP P,C
	POPJ P,

POPJJ1:	AOS -1(P)
POPJJ:	POP P,J
	POPJ P,

POPUJ1:	AOSA -1(P)
POPTUJ:	POP P,T
POPUJ:	POP P,U
	POPJ P,

POPTJ:	POP P,T
	POPJ P,

POPTTJ:	POP P,TT
	POPJ P,

CKOCJ1:	CONO PI,CLKON
	JRST POPCJ1

CLKOJ1:	AOS (P)
CLKONJ:	CONO PI,CLKON
	POPJ P,

CKOPJ1:	AOS (P)
CLKOPJ:	CONO PI,CLKON
	JRST LSWPOP

IFN OMXP,[
OMXONJ:	CONO PI,OMXON
	POPJ P,
]

TTYOJ1:	AOS (P)
TTYONJ:	CONO PI,TTYON
	POPJ P,

IFN LPTP,	LPTONJ:
PTRONJ:
PTPONJ:	CONO PI,PTRON
	POPJ P,

IFN NETP,NETOJ1:
UTCOJ1:	AOS (P)
IFN NETP,NETONJ:
UTCONJ:	CONO PI,UTCON
	POPJ P,

POPQU1:	AOS -2(P)
POPQUJ:	POP P,Q
	POP P,U
	POPJ P,

POP1J1:	AOS -1(P)
POP1J:	SUB P,[1,,1]
	POPJ P,

POP2J:	SUB P,[2,,2]
	POPJ P,

POP3J1:	AOS -3(P)
POP3J:	SUB P,[3,,3]
	POPJ P,

POP4J:	SUB P,[4,,4]
	POPJ P,

POP5J:	SUB P,[5,,5]
	POPJ P,

SUBTTL UUO PROCESSOR

.IOT=UUOMIN
.OPEN=UUOMIN+1_27.
.OPER=UUOMIN+2_27.
.CALL=UUOMIN+3_27.
.USET=UUOMIN+4_27.
.BREAK=UUOMIN+5_27.
.STATUS=UUOMIN+6_27.
.ACCESS=UUOMIN+7_27.

DEFINE GLOSYM X
	IRP Y,,[X]
	SQUOZE 4,.!Y
	.!Y
	TERMIN
	TERMIN

;SYMBOLS SHOULD BE LEFT IN CURRENT ORDER OR DDT WILL LOSE
	DEFINE USTIRP A
	IRPS X,,[UPC VAL TTY FLS UNAME JNAME MASK USTP
PIRQC INTB MEMT SV40 IPIRQ APIRQ SNAM PICLR
MARA MARPC UUOH UIND RUNT MSK2 IFPIR APRC
SV60 UTRP IIFPI AIFPI IMASK AMASK IMSK2 AMSK2
JPC OPC RTMR 60H BCHN MPVA IDF1 ADF1
IDF2 ADF2 DF1 DF2 OPTION 40ADDR TVCREG
TTST TTS1 TTS2 WHO1 WHO2 WHO3 SUPPRO TR1INS
TR2INS MBOX MBO1 EBOX EBO1 XUNAME]
A
TERMIN
TERMIN

;NOTE:  OPER'S BELOW ARE 8 PER LINE
;    USE UP ILUUO'S BEFORE ADDING TO END
; THE FOLLOWING SHOULD GO AWAY EVENTUALLY
;	ITYI (=ITYIC)
;	SETMSK (=SUSET)
;	WSNAME (=SUSET)
;	UPISET (=SUSET)
;	RDSW (=DATAI)
;	EOFC (OBSOLETE)
DEFINE OPRIRP A
	IRPS X,,[ITYI LISTEN SLEEP SETMSK SETM2 DEMON CLOSE
UCLOSE ATTY DTTY IOPUSH IOPOP DCLOSE DSTOP RDTIME
RDSW GUN UDISMT GETSYS IPDP GETLOC SETLOC DISOWN
DWORD DSTEP GENSYM LOGOUT REALT WSNAME UPISET RESET
ARMOVE DCONTIN CBLK ASSIGN DESIGN RTIME RDATE HANG
EOFC IOTLSR RSYSI SUPSET PDTIME ARMRS UBLAT IOPDL
ITYIC MASTER VSTST NETAC NETS REVIVE DIETIM SHUTDN
ARMOFF NDIS FEED EVAL REDEF IFSET UTNAM UINIT
RYEAR RLPDTM RDATIM RCHST RBTC DMPCH SWAP MTAPE
ILUUO NETINT]
	A
TERMIN
TERMIN

DEFINE CALIRP A
IRPS X,,[DISMIS UNUSD TRANAD VALUE UTRAN CORE TRAND
DSTART FDELE DSTRTL SUSET LTPEN VSCAN POTSET]
A TERMIN TERMIN

;THESE ARE THE SYMBOLS USED BY MIDAS AND DDT. THEY ALSO
;EXIST IN SYS:ITS DEFS.
SYSYMB:	USTIRP [SQUOZE 44,.R!X
	.IRPCNT]
	SQUOZE 44,.RIOC
	100
	SQUOZE 44,.RIOS
	120
	SQUOZE 44,.RIOP
	140
	SQUOZE 44,.RPMAP
	200
	USTIRP [SQUOZE 44,.S!X
	400000+.IRPCNT]

	GLOSYM [IOT,OPEN,OPER]

DEFINE DEFSYM X/
IRPS Z,,[X]
SQUOZE 44,Z
Z
.ISTOP
TERMIN TERMIN

.INSRT BITS >
.INSRT TTYDEF >

EXPUNG DEFSYM

	ZZ=1
	OPRIRP [IFSN X,ILUUO,[.!X=.OPER ZZ
	SQUOZE 4,.!X
	.!X]
	ZZ==ZZ+1]

MXOPR==ZZ

	SQUOZE 4,.CALL
	.CALL

CALIRP [
IFSN X,UNUSD,[
	.!X=.CALL .IRPCNT+1,
	SQUOZE 4,.!X
	.!X
]]

	GLOSYM [USET,BREAK,STATUS,ACCESS]
SYSYME==.-1

;THESE SYMBOLS ARE USED BY DDT, SO THE USER CAN OPEN .PIRQC, ETC.
		;BEGINNING FOR .GETSYS (USYMS)
SYSUSB:	USTIRP [SQUOZE 4,.!X
	.IRPCNT]
	SQUOZE 4,.IOC
	100
	SQUOZE 4,.IOS
	120
	SQUOZE 4,.IOP
	140
	SQUOZE 4,.PMAP
	200
SYSUSE==.-1	;END FOR .GETSYS (USYMS)

;SIXBIT NAME TABLES FOR WHO LINE GENERATION.
;ALSO USED BY PEEK FOR PRINTING OUT JOBS' STATUS.

OPRSXB:	SIXBIT/OPER/
OPRIRP [
.1STWD	SIXBIT/X/
]

CALSXB:	SIXBIT/CALL/
CALIRP [
.1STWD	SIXBIT/X/
]
	SIXBIT/UNUSD/

UUOSXB:
IRPS X,,IOT OPEN OPER CALL USET BREAK STATUS ACCESS
.1STWD	SIXBIT/X/
TERMIN
NUUOSX==.-UUOSXB

;MACRO TO SAVE ACS AS APPROPRIATE FOR OUR CPU, LOAD UP U,
;CHECK VARIOUS ERROR CONDITIONS.

DEFINE UUOSAV
	CONSZ PI,77400
	 JRST 4,.	;PI IN PROGRESS??
IFE KL10P,[
	XCTR XW,[MOVEM U,17]	;SAVE 17
	SKIPGE U,USER		;LOAD CURRENT USERS INDEX,
	 JRST 4,.		;UUO WAS EXECTUED BY THE NULL JOB
	XCTR XW,[MOVEM T,16]	;SAVE LOC 16 FOR USER
	MOVEI T,0	;HA HA
	XCTR XBW,[BLT T,15]	;SAVE REST OF ACS IN USERS SHADOW 0-15
]
IFN KL10P,[
	DATAO PAG,[400100,,400000] ;AC BLK 0 CURRENT; AC BLK 1 PREVIOUS.
	SKIPGE U,USER
	 JRST 4,.
	LDB T,[330300,,MUUOCX(U)]
	CAIE T,1
	 JRST 4,.		;ISSUED UUO RUNNING WITH AC BLOCK OTHER THAN 1?
]
TERMIN

; UUO AND ILLOP TRAP HANDLER
;
;EITHER DISPATCHES TO APPROPRIATE UUO ROUTINE,
;   RETURNS CONTROL TO USERS UUO ROUTINE, GOES TO ILLOP, USRTRP, OR USRIOT.
;CODE ON THIS PAGE IS INTERRUPTABLE AT ANY POINT

USRUU2:	MOVE T,FORTY		;FOR OPTDEC AND AUIOT
USRUUO:	HRRZ A,40ADDR(U)
USRUU1:	CAIG U,LUBLK
	 JRST 4,.
	MOVE P,USRPDL(U)	;IN CASE WE TAKE A PAGE FAULT
	XCTR XW,[MOVEM T,(A)]	;PLANT UUO INTO USERS 40
	MOVE T,UUOH	;PICK UP FLAGS
	TLNN T,%PCUSR	;SKIP IF INTERRUPT FROM USER MODE
	 JRST 4,.	;GET HERE FOR NON-SYS-CALL UUO IN EXECUTIVE MODE
	XCTR XR,[HRRZ T,1(A)]	;PICK UP USERS 41, SHOULD POINT TO HIS UUO HANDLER
IFE KL10P,	XCTR XR,[MOVE A,A]	;RESTORE USER'S AC A
	JUMPE T,ILUUO	;BAD USER 41? (USER NOT EXPECTING UUO'S)
	HRLI U,1(T)	;SIMULATE A JSR AT USER'S 41 OR 61
	MOVE P,UUOH	;OK TO CLOBBER P - SEE BELOW.
	XCTR XW,[MOVEM P,(T)]
;	HRLI T,UUOH	;CODE FOR HISTORICAL INTEREST ONLY - DOESN'T WORK ON KL.
;	XCTR XBW,[BLT T,0]
	HLRM U,UUOH	;SET TO RETURN TO USER AT FIRST INSTRUCTION OF UUO HANDLER
IFE KL10P,[
	XCTR XR,[MOVE P,15]
	XCTR XR,[MOVE T,16]	;RESTORE USER 16
	XCTR XR,[MOVE U,17]	;RESTORE USER 17
]
ULEAVE:
IFN KL10P,	DATAO PAG,[401100,,400000]	;CURRENT AC BLK 1, PREV AC BLK 1.

EBLK

;THE FOLLOWING BLOCK OF THREE LOCATIONS IS SWITCHED WITH SOME USER VARS
UEXIT:	JRST 2,@XUUOH	;EXIT FROM UUO (FOR KL-10, POINTS TO APPROPRIATE UPT LOC)
CLUSAV:	MOVEM U,AC17S	;CLOCK SAVE OF U
IFN KL10P,[
CLCXSV:	DATAI PAG,CLCX	;CLOCK LEVEL CONTEXT SAVE
]
IFE KL10P,[
XUUOH:	0		;UUO AND ILLOP TRAP GETS HERE - UUOH0 MUST BE . + 1.
]
UEXND::	;END OF SWAPPED UEXIT BLOCK.
BBLK
UUOH0:	UUOSAV
MUUOT1:	SKIPGE UTRAPM(U) ;IF SUPERIOR WANTS TO CATCH UUOS, THIS IS FATAL INT.
	 JRST USRTRP
	SKIPGE T,FORTY	;PICK UP THE UUO OR ILLOP
	 JRST USRIOT
	CAML T,[UUOMIN]
	 CAML T,[UUOMAX]
	  JRST USRUUO	;NOT A SYSTEM CALL, GIVE TO USER
ILLOP1:	JUMPN U,UUOH1
	MOVEI Q,0	;SAVE SYS JOB EXEC MODE LSWPR PNTR
	EXCH Q,LSWPR
	MOVEM Q,SLSWPR
UUOH1:	SKIPE LSWPR(U)
	 JRST 4,.
	SETZM SYSCVL(U)	;DIDN'T GET INTO SYSTEM VIA .CALL
	MOVEM T,LSUUO(U)	;SAVE UUO FOR DEBUGGING PURPOSES
	LSH T,-27.	;RIGHT JUSTIFY OP CODE
UUOTR2:	SKIPL UUODSP-UUOMIN_-27.(T)
	 JRST UUOTR3
	MOVE A,OPTION(U)
	TLNE A,OPTDEC
	 JRST USRUU2
UUOTR3:	MOVE P,USRPDL(U)	;SET UP USER PDL
	HRRZ C,FORTY		;PICK UP EFFECTIVE ADDRESS OF UUO
	LDB R,[270400,,FORTY]	;PICK UP AC FIELD OF UUO
	MOVEM R,UUAC(U)		;SAVE AC FLD
	PUSHJ P,@UUODSP-UUOMIN_-27.(T)	;DISPATCH ON UUO TYPE
	 JRST URET	;NORMAL RETURN (NON SKIP)
URETJ1:
IFN KL10P,MOVE U,USER	;(SINCE UUOH IS IN THE USER VARIABLES)
	AOS UUOH	;UUO ROUTINE SKIPPED, AOS USER RETURN POINT
URET:	MOVE U,USER
	MOVE A,PIRQC(U)	;CHECK FOR RETURNING TO USE WITH PCLSR'ING FATAL INT SET.
	TDNE A,[BADBTS&#<%PIC.Z\%PIMAR\%PIDIS>]
	 JRST [	HRRZ A,UEXIT
		CAIE A,ONEFLS
		 JRST 4,.
		JRST .+1]
IFN KL10P,[
	MOVSI T,%PSINH	;AN INSTRUCTION (THE UUO) HAS BEEN COMPLETED, SO
	ANDCAM T,UUOH	; IF ONE-PROCEEDING THE TRAP SHOULD GO OFF NOW.
]
	SKIPE UMAPS(U)
	 PUSHJ P,MPLDZ
	CAMN U,PCLUSR
	 SKIPG PCLDBM
	  JRST URET2
	SKIPL PCLNXT
	 JRST URPCL1
URET2:	SKIPE LSWPR(U)
	 JRST 4,.
	JUMPN U,URETC
	MOVEI T,0	;RESTORE SYS JOB EXEC LSWPR
	EXCH T,SLSWPR
	MOVEM T,LSWPR
URET1:	CONSO PI,1
	 JRST 4,.	;RETURNING TO USER MODE WITH CLOCK OFF
IFE KL10P,[
	MOVEI U,0
	XCTR XBR,[BLT U,U]		;RESTORE USERS ACS FROM USERS SHADOW 0-17
]
	JRST ULEAVE

URETC:	REPEAT NULBLK/2,[
	SKIPN CONC LSWB,\<2*.RPCNT>,+1(U)
	SKIPE CONC LSWB,\<2*.RPCNT+1>,+1(U)
	JRST 4,.
]
	REPEAT NULBLK&1,[
	SKIPE CONC LSWB,\<NULBLK-1>,+1(U)
	JRST 4,.
]
	JRST URET1

URPCL1:	SKIPN LSUUO(U)
	JRST URET2	;DIDN'T REALLY MISS MARK (DUE TO FINSET)
	SETOM PCLNXT	;MISSED MARK, REINITIALIZE
	SETZM PCLL
	SETZM PCLHSH
	JRST URET2

UUOTRO:	LDB T,[331100,,FORTY]
	JRST UUOTR2

USRIOT:	MOVSI T,(UIOT)	;I/O INST TURNS INTO PSEUDO UUO TO DISPATCH ON
	JRST ILLOP1

IFN KL10P,[

;HANDLE UUOS EXECUTED FOR TRAPS (PDL OV, ARITH OV, ONE PROCEED).
;MOST ARE AS USUAL, BUT OPCODE 0 IORM'S ADDRESS INTO PIRQC.
;NOTE: LOSER IS NOT PERMITTED TO USE OPCODE 0 - SEE USTR1I, ETC.

MUUOTR:	UUOSAV
	MOVE T,FORTY
	TLNE T,-1
	 JRST MUUOT1	;IF OPCODE ISN'T 0, TREAT UUO NORMALLY.
	TRNN T,%PIARO
	 JRST MUUOT2
	MOVE A,UUOH	;DISTINGUISH FIXED AND FLOATING OVERFLOW.
	TLNE A,%PCFOV
	 TLO T,(%PIFOV)
MUUOT2:	MOVE P,USRPDL(U)
	TDNE T,[BADBTS]
	 JRST UUOERR	;IF ANY BIT IS FATAL, SET IT AND TAKE INTERRUPT.
	AND T,MSKST(U)	;CLASS 3 BITS SHOULD BE SET ONLY IF ENABLED.
	IORM T,PIRQC(U)
	ANDCM T,IDF1(U)	;IF THESE BITS ARE ENABLED AND UNDEFERRED,
	SKIPE PICLR(U)
	 JUMPN T,UUOE2	;THEN SHOULD TAKE INT NOW AFTER ALL.
	JRST URET

MUUOEX:	JRST 4,.	;UUO IN EXEC MODE NOT IN SYS JOB

LUUOEX:	0
	JRST 4,.	;LUUO IN EXEC MODE

ILLTRP:	0
	JRST 4,.	;TRAP IN SYS OR CORE JOB OR EXEC MODE
]

IFE KL10P,[
EBLK
60H:	0		;TRAPS FROM 60
BBLK
60H0:	UUOSAV		;IF WE LOSE PROCESSOR HERE, 60 GETS COPIED INTO 40,
			;60H IS COPIED INTO UUOH, AND UPC GETS MOVED INTO UUOH0.
60HE:	CONO PI,CLKOFF
	MOVE T,60H
	MOVEM T,UUOH
	MOVE T,60
	MOVEM T,FORTY
	CONO PI,CLKON
	JRST MUUOT1
]

;COME HERE FROM UEXIT WHEN USER IS BEING PCLSR'ED
; KA10 - ALL USER ACS ARE IN MACHINE ACS AND IN UUOACS
; KL10 - ALL USERS ACS ARE IN AC BLOCK 1

ONEFLS:	CONO PI,CLKOFF		;TURN OFF CLOCK BREAKS
IFN KL10P,	DATAO PAG,[400100,,400000]	;BACK TO AC BLOCK 0
	MOVE U,USER		;GET INDEX OF CURRENT USER
ONEPR2:	SKIPE T,RPCL(U)		;SKIP IF NO RPCLSRING OCCURING
	 JRST ONEFL2		;RPCLSRING GOING ON
ONEPR1:
UUOE1:	MOVE U,USER		;GET INDEX OF CURRENT USER
	CONO PI,CLKOFF		;TURN OFF CLOCK BREAKS
	SKIPE LSWPR(U)
	 JRST 4,.
	MOVEI T,AC0S(U)		;PUT USER ACS INTO SWAP OUT ACS
	XCTR XBR,[BLT T,AC17S(U)]
	MOVE T,UUOH
	MOVEM T,UPC(U)		;SIMULATE JRST 2,@UUOH
IFE KL10P,MOVE T,[JRST 2,@UUOH]
IFN KL10P,[
	MOVSI T,(JRST 2,@)
	HRRI T,UUOH
]		;END OF IFN KL10P
	MOVEM T,UEXIT		;RESTORE UEXIT
IFN KL10P,[
	DATAO PAG,[401100,,400000]	;AC BLK 1, PREV AC BLK 1
	MOVE U,USER			;AS IF HAD RETURNED TO USER THEN CLKBRK
]		;END OF IFN KL10P	;EXCEPT THAT AC'S ARE ALREADY STORED IN AC0S
	JRST UFL6		;RESCHEDULE, ETC

ONEFL2:	JUMPG T,[JRST 4,.]	;LOSEY LOSEY (SHOULD NOT TRY TO EXIT WHILE TRYING TO RPCLSR SOMEONE)
	MOVE A,FLSINS(T)	;GET FLSINS OF USER SUPPOSEDLY RPCLSRING YOU
	SUBI A,RPCL(T)		;HIS FLSINS SHOULD BE A SKIPE OF HIS RPCL
	CAME A,[SKIPE]		;SKIP IF HE HAS THE RIGHT FLSINS
	 JRST 4,.		;LOSEY LOSEY
	CLEARM FLSINS(T)	;ASSURE NO INTERRUPT
	SETZM RPCL(U)		;ACS IN UUO ACS CLOCK OFF
	AOS USTP(U)		;STOP SELF
	SETZM RPCL(T)		;UNHANG LOSER RPCLSR'ING YOU
	JRST ONEPR1

;ROUTINES TO GIVE THE RUNNING JOB AN INTERRUPT AND ABORT THE CURRENT INSTRUCTION

TTYLOS:	SKIPA T,[%PITTY] ;JOB WHOSE %TBINT IS SET TRIED TO USE ITS TTY WHEN DIDN'T OWN IT
IOADC:	 MOVEI T,%PIMPV	;I/O UUO MEMORY PROTECT VIOLATION
	JRST UUOERR

	RADIX 10.
IOCERF:	;ADDRESS OF FIRST IO CHANNEL ERROR
ZZ==NIOTER
IFG ZZ-9,ZZ==9
REPEAT ZZ,CONC IOCER,\.RPCNT+MIOTER,:	JSP T,IOCERX
IFG NIOTER-9,[REPEAT NIOTER-9,CONC IOCR,\.RPCNT+MIOTER+9,:	JSP T,IOCERX
]
	RADIX 8
IOCERX:	SUBI T,IOCER9-9+1
	MOVE U,USER
	MOVE TT,UUAC(U)
	DPB TT,[BCHPTR]	;STORE LAST CHNL IN ERROR
	ADD TT,U
	DPB T,[330600,,IOCHST(TT)]
IOCERR:	MOVEI T,%PIIOC
	JRST UUOERR

AILUUO::
ILUUO:	SKIPA T,[%PIILO]	;ILLEGAL SYSTEM UUO
USRTRP:	 MOVSI T,(%PITRP)	;SYSTEM UUO IN TRAP MODE

UUOERR:	IORM T,PIRQC(U)	;GIVE USER INT BIT
UUOE2::
IOADCR:	MOVE T,OPTION(U);PC CLOBBERED TO HERE IF MPV IN EXEC MODE - INTR OUT OF UUO
	TLNN T,OPTOPC	;UNLESS USER HAS SAID NOT TO,
	 AOS UUOH	;UNDO SOS THAT PCLSR'ING WILL DO; PC SHOULD END UP -> AFTER UUO.
	CONO PI,CLKON	;THERE HAD BETTER BE A CLASS 1 OR 2 INT. PENDING.
	JFCL
	PUSHJ P,UFLS	;LET THE INTERRUPT PCLSR US.
	JRST 4,.

IFE KL10P,[
ILEXPF:	CONO PI,CLKOFF	;GET HERE AFTER EXEC PAGE FAULT TAKEN ON XCTRI
	SPM UPGML(U)
	MOVSI A,1770	;CLEAR FAULT REASON BITS
	ANDCAM A,UPQUAN(U)
	LPMR UPGML(U)
	JRST ILUUO
]
IFN KL10P, ILEXPF==ILUUO	;NO CLEANUP NECESSARY

;UUO DISPATCH

;AT DISPATCH TIME, P HAS UPDL C HAS RH OF 40
	;R HAS AC FLD OF UUO U HAS USER INDEX

UUODSP:	SETZ AIOT	;SETZ FLAGS UUO'S TO REFLECT TO USER WHEN OPTDEC OPTIONS
	SETZ AOPEN	;IN EFFECT. THEY ARE THE UUOS WHICH OVERLAP DEC
	AOPER
	ACALL
	AUSET
	ABREAK
	ASTATUS	
	SETZ AACCESS
	SETZ AUIOT
IF2,IFN <UIOT-UUOMIN>_-27.+UUODSP-.+1,.ERR LOSE AT UUODSP

ABREAK:	MOVEI T,%PIBRK	;INTERRUPT TO SUPERIOR
ILLOP4:	IORM T,PIRQC(U)
	JRST UUOE1

;IOT DISPATCH
NIOT:	AOS (P)		;NEW SYSTEM CALL IOT, CHANNEL ALREADY DECODED.
	CAIL W,3	;SET IOTBTS TO USER'S 3RD ARG, OR TO 0.
	 SETZ C,
	MOVEM C,IOTBTS(U)
	HRRZ C,B
	JRST AIOT1

AIOT:	SETZM CTLBTS(U)
	SETZM IOTBTS(U)
	ADDI R,IOCHNM(U) ;GET IOCHNM WD ADDR IN R.
AIOT1:	MOVE A,U
	IDIVI A,LUBLK
	JUMPN B,[JRST 4,.]
	HLRZ A,(R)	;PICK UP LEFT HALF (DEVICE DEPENDENT)
	HRRZ B,(R)	;PICK UP RIGHT HALF (INDEX INTO IOTTB, ETC.)
	MOVE D,IOTTB(B)	;GO TO ROUTINE FOR PARTICULAR DEV AND MODE
	TLNE D,%IOTOT+%IOTBK+%IOTSP	;BUT FOR "NORMAL" UNIT MODE INPUT, SPECIAL:
	 JRST (D)
	XCTR XRW,[MOVES (C)] ;MAKE SURE XCTR XW, BELOW WON'T PCLSR.
	PUSH P,C
	PUSHJ P,(D)	;CALL IOT ROUTINE, EXPECTING VALUE IN W.
AIOT3:	 JRST AIOT2	;NOTE AIOT3 MAY BE CHECKED FOR ON PDL.
	  JRST AIOT2
AIOT2:	POP P,C
	XCTR XW,[MOVEM W,(C)]
	POPJ P,

;RANDOM ACCESS

AACCES:	MOVE A,UUAC(U)
	XCTR XR,[MOVE B,(C)]
	SOS (P)		;DON'T SKIP
NACCES:	JSP T,CHNDCD	;GET <CLSTB BITS>,,<IOCHNM WD ADDR> IN R
	JUMPE H,IOCER8	;AND CONTENTS IN H: 0 => CHNL NOT OPEN.
	HRRM B,IOCHST-IOCHNM(R)	;STORE USR .ACCESS POINTER
	TLNE R,100040	;SKIP IF NOT JOB
	JRST JBACCS
	TLNN R,200	;CHECK CLSTB BITS OF THIS DEVICE
	JRST POPJ1		;NOT 2311 DEVICE
	HLRZ I,(R)
	MOVEM B,QRADAD(I)	;STORE ACCESS POINTER FOR DSK
	MOVSI D,%QAACC
	IORM D,QSRAC(I)	;SET ADR HAS BEEN HACKED FLAG
	JRST POPJ1

;SIOT SYMBOLIC SYSTEM CALL - IOT A STRING.
; 1ST ARG CHANNEL NUMBER.
; 2ND ARG BYTE POINTER
; 3RD ARG STRING LENGTH
; 4TH (OPTIONAL) ARG DEVICE-INDEPENDENT CONTROL BITS
; CTLBTS  DEVICE DEPENDENT CONTROL BITS

NSIOT:	TLNN B,1000	;OBJECT IF B.P. OR COUNT IS IMMEDIATE.
	 TLNE C,1000
	  JRST OPNL33
	CAIGE W,4
	 SETZ D,
	MOVEM D,IOTBTS(U)
	MOVE D,IOTTB(H)
	TLNE D,%IOTBK+%IOTSP	;SIOT ALLOWED ONLY ON UNIT MODE CHANNELS.
	 JRST OPNL12		;"MODE NOT AVAILABLE".
	XCTR XRW,[MOVES (C)]	;ENSURE STRING LENGTH WRITABLE
	XCTR XRW,[MOVES A,(B)]	;ENSURE BYTE POINTER WRITABLE
	TLNE A,(0 @(17))	;CAN'T HACK BYTE POINTER WITH HAIRY ADDRESSING
	 JRST OPNL33		;MEANINGLESS ARGS
	HLRZ A,(R)
	MOVE TT,B		;IN CASE SPECIAL ROUTINE WANTS TO CALL SIOKT
	TLNE D,%IOTBP		;IF THERE'S A SPECIAL DEVICE ROUTINE FOR SIOT,
	 JRST -1(D)		;GO TO IT.
;THIS CALL IS LEGAL AND ORDINARY. LOOP, CALLING THE UNIT MODE ROUTINE.
NSIOT1:	PUSH P,A
	XCTR XRW,[MOVES (B)]	;MAKE SURE REWRITING B.P. OR COUNT IS OK.
	XCTR XRW,[MOVES A,(C)]
	JUMPLE A,POPAJ1	;0 BYTES TO BE XFERED => SUCCEED IMMEDIATELY.
	PUSH P,B
	PUSH P,C
	PUSH P,D		;PUT ALL IMPORTANT INFO ON STACK FOR MAIN LOOP
	HRRZS (P)		;TO LOOK AT.
	PUSH P,R
	TLNN D,%IOTOT
	 JRST NSIOIL		;INPUT AND OUTPUT PART HERE
NSIOOL:	XCTR XR,[MOVE A,@-3(P)]
	IBP A			;THIS HAIR IS TO AVOID INCREMENTING THE USER'S COPY
	XCTR XR,[MOVE D,(A)]	;OF THE BYTE POINTER BEFORE THE BYTE HAS BEEN
	HRRI A,D		;FINALLY TAKEN WITH NO POSSIBILITY OF PCLSR'ING OUT.
	LDB D,A			;CAN'T USE XCTR XR,[LDB D,A] BECAUSE ON THE KA10
	MOVE C,[SETZ D]		;THAT WOULD USE THE LOSER'S AC A.
	MOVE R,(P)
	MOVE A,-4(P)	;SET UP ARGS FOR IOT ROUTINE; C HAS ADDR OF VALUE.
	PUSHJ P,@-1(P)	;CALL THE IOT ROUTINE.
	XCTR XRW,[IBP @-3(P)]	;NOW STEP THE B.P. AND COUNT.
	XCTR XRW,[SOS A,@-2(P)]
	JUMPG A,NSIOOL
	JRST NSIOTX

NSIOIL:	XCTR XR,[MOVE A,@-3(P)]
	HRRZ W,A	;GET THE B.P.,
	IBP A		;STEP IT, AND IF THAT MOVES TO ANOTHER WORD,
	CAIE W,(A)	;MAKE SURE WE CAN WRITE IN THAT WORD.
	 XCTR XRW,[MOVES (A)]
	MOVE R,(P)	;NOW GET THE ARGS FOR THE IOT ROUTINE,
	MOVE A,-4(P)
	PUSHJ P,@-1(P)	;AND CALL IT, WITH VALUE COMING IN W.
	 JRST NSIOI3	;NO SKIP => WE WIN.
	  JRST NSIOTX	;1 SKIP => THERE'S NO INPUT; RETURN WITHOUT STEPPING B.P.
			;2 SKIPS => THIS BYTE IS THE LAST ONE AVAILABLE.
	XCTR XBYTE,[IDPB W,@-3(P)]
	XCTR XRW,[SOS @-2(P)]
	JRST NSIOTX

NSIOI3:	XCTR XBYTE,[IDPB W,@-3(P)]
	XCTR XRW,[SOS A,@-2(P)]
	JUMPG A,NSIOIL
NSIOTX:	SUB P,[5,,5]
	JRST POPJ1
;
; ROUTINES TO SIMULATE SOME I/O INSTRUCTIONS WHEN EXECUTED BY USER

AUIOT:	MOVE I,FORTY	;GET I/O INST
	ANDI R,7	;GET IOT TYPE FIELD
	LDB J,[320700,,FORTY]
	LDB D,[420200,,IOTTYP(R)]
	JRST @IOTTYP(R)	;DISPATCH ON TYPE

IOTTYP:	000000,,IOTTY3		;BLKI
	000000,,IOTTY2		;DATAI
	200000,,IOTTY3		;BLKO
	200000,,IOTTY2		;DATAO
	300000,,IOTTY2		;CONO
	400000,,IOTTY2		;CONI
	400000,,IOTTY1		;CONSZ
	400000,,IOTTY1		;CONSO

IOTTY1:	CAIN J,177	;IF EQ INST WAS 7777XX,,XXXXXX
	JRST ILUUO	;USER HAS EXECUTED A SMALL NEGATIVE NUMBER
	JRST IOTTY2

IOTTY3:
IFN KL10P,[
	MOVE C,DCHNTB(J)
	TRNE C,10000
	 JRST IOTTY2	;SPECIAL BLKI THAT IS TREATED LIKE DATAI
]
	TLO I,40	;BLOCK TYPE, TURN ON BIT TO CONVERT TO UNIT
	XCTR XR,[MOVE C,(I)]	;GET BLOCK POINTER
	ADD C,[1,,1]	;ADVANCE
	TLNE C,-1	;SKIP IF OVERFLOW
	AOS (P)		;CAUSE RETURN TO SKIP
	XCTR XW,[MOVEM C,(I)]	;STORE BACK
	HRR I,C		;MODIFY INST ADR TO RH OF BLOCK POINTER
IOTTY2:	SKIPL C,DCHNTB(J)
	JRST IOTTYA
	LSH C,19.(D)
	SKIPL C
	JRST ILUUO
IOTTYB:	XCTR XRW,I	;DO IOT
	POPJ P,		;NORMAL RETURN
	JRST POPJ1	;IOT SKIPPED RETURN

IOTTYA:	SKIPGE DCHNTC(J)
	JRST ILUUO	;SUSPICIOUS DEVICE
	JRST IOTTYB

SUBTTL .SUSET AND .USET

;
;	.SUSET [N,,LOC]	;SAME AS .USET (SEE BELOW) BUT REFERS TO SELF
;
ASUSET:	MOVE C,B	;TEMP
	MOVE A,U	;MAKE SELF-REFERENT
	MOVEI I,1	;INDICATE SUSET
	MOVEI B,UWIDN
	JRST ASUS2
;			;IF N&200000=1, BLOCK MODE
;	.USET CH,[N,,LOC]	;IF N&400000=0, READS USER VAR SPECIFIED BY REST OF N
				;	FOR INFERIOR OR FOREIGN USER OPEN ON CHANNEL CH
				;	INTO USER LOCATION LOC
				;IF N&400000.NE.0, SETS USER VAR SPECIFIED BY REST OF N
				;	FOR DIRECTLY INFERIOR USER OPEN ON CHANNEL CH
				;	FROM USER LOCATION LOC
AUSET:	PUSHJ P,STDUUO	;SET UP ACS.
	MOVEI I,0	;INDICATE A USET
ASUS2:	XCTR XR,[HRRZ J,(C)]	;GET LOC READING INTO OR SETTING FROM
	XCTR XR,[HLRZ Q,(C)]	;GET VARIABLE AND DIRECTION INFO
	HLRZ H,CLSTB(B)	;GET CLSTB BITS
	TRNE Q,200000
	 JRST ABUSET
IFN PDP6P,[
	TRNE H,100	;SKIP UNLESS PDP-6 DEVICE
	 JRST PDPPMT	;PDP-6 DEV.
]
	CAMN A,U	;IF DOING A .USET ON SELF,
	 IORI I,1	;CALL IT A .SUSET INSTEAD.
	TRZE Q,400000	;SKIP IF READING
	 TRO I,2		;INDICATE SETTING
	TRNE I,2	;SKIP IF READING
	 TRNE H,504040	;SKIP IF NOT INFERIOR OPEN ON CH OR JOB OR BOJ DEVICE
	  TRNN H,505040	;SKIP IF INFERIOR OR FOREIGN USER OPEN OR JOB OR BOJ
	   JRST IOCER7	;NO USER OPEN IF READING OR NOT INFERIOR IF SETTING
	TRNE H,100040
	 MOVE A,JBCJUI(A)	;CREATED PROCEDURE'S INDEX IF JOB DEVICE
	TRNE H,4000	;BOJ
	 MOVE A,JBCUI(A);CREATOR INDEX
	CAIL Q,MXVAL	;SKIP IF IN USETL TABLE
	JRST AUSET2	;ABOVE USETL TABLE, MUST BE IOC, IOS, IOP, OR ILLEGAL
	LDB D,USETBT(I)	;GET METHOD BITS
	SOJL D,ILUUO	;JUMP IF ILLEGAL
	SOJL D,AUSVAR	;JUMP IF SIMPLE VARIABLE READ/SET
	LDB C,USETRL(D)	;GER ADDRESS OF ROUTINE
	XCTR XR,[MOVE D,(J)]	;GET CONTENTS OF USERS LOC (USEFUL IF SETTING VAR)
	MOVE T,A	.SEE UPISE1 ;SAVE COPY OF IDX OF JOB BEING HACKED.
	JRST (C)	;TRANSFER TO ROUTINE

AUSVAR:	LDB C,USETRL+1	;GET ADDRESS OF VARIBLE
	ADD C,[USRSTG(A)]		;INDEX BY AC WITH USER INDEX
	XCTR XR,[MOVE B,(J)]	;GET USERS LOC
	TRNN I,2	;SKIP IF SETTING
	 SKIPA B,@C	;GET VAR
	  MOVEM B,@C	;SET VAR
	TRNN I,2	;ALLOW READING FROM PURE PAGE
	 XCTR XW,[MOVEM B,(J)]	;SET USERS LOC
	POPJ P,

IFN PDP6P,[
PDPPMT:	CAIE Q,12	;SKIP IF READING MEM BOUND
	POPJ P,	;IGNORE OTHERWISE
	MOVEI A,LPDP6M*2000	;FIXED MEM BOUND FOR PDP-6
	JRST APTUAJ
]

AUSET2:	TRNE I,2
	JRST ILUUO	;JUMP IF TRYING TO WRITE
	SUBI Q,100
	JUMPL Q,ILUUO	;ERROR IF MXVAL<Q<100
	CAIL Q,40
	JRST AUSET4	;>140=>.RIOP+M
	TRZE Q,20
	JRST AUSET3	;117<Q<140=>.RIOS+M
	ADDI Q,IOCHNM(A)	;77<Q<120=>.RIOC+M
AUSETX:	MOVE A,(Q)	;GET VAR
APTUAJ:	XCTR XW,[MOVEM A,(J)]	;GIVE TO USER
	POPJ P,

AUSET3:	MOVE R,A	;INFERIOR USER INDEX
	ADDI R,IOCHNM(Q)	;GET CHANNEL POINTER
	MOVE C,J	;CAUSE STATUS TO BE READ INTO (J)
	HRRZ B,(R)	;GET INDEX IN CH WHOSE STATUS IS BEING EXAMINED
	HLRZ A,(R)	;GET LH(IOCHNM(U,R))
	JRST ASTAT1	;DO A .STATUS

AUSET4:	CAIL Q,40+LUIOP	;COMPARE AGAINST LAST IO PDL LOC
	JRST AUSET5	;READ MAP ENTRY
	ADDI Q,SIOCHN-40(A)	;MAKE UP POINTER TO VAR
	JRST AUSETX

;CALLED BY AUSET, ASTATUS
STDUUO:	ADDI R,IOCHNM(U) ;R POINTS TO IO CHANNEL WORD REFERENCED BY UUO'S AC FIELD
	HLRZ A,(R)	;A IS THE LEFT HALF OF IOC WORD
	HRRZ B,(R)	;B IS RIGHT HALF AND INDEX INTO IOTTB, ETC.
	POPJ P,		;C IS ABSOLUTE EQUIVALENT OF UUO'S EFFECTIVE ADDRESS

ABUSET:	TRNE Q,400000
	TLOE I,1	;SET BLOCK BIT
	JRST ILUUO	;BLOCK IN BLOCK LOSES
	XCTR XR,[MOVE Q,(C)]	;GET AOBJN PTR AGAIN
ABUST2:	XCTR XW,[MOVEM Q,(C)]	;STORE AWAY UPDATED POINTER
	PUSH P,B
	PUSH P,C
	PUSH P,A
	PUSH P,I
	MOVE C,Q
	PUSHJ P,ASUS2
	POP P,I
	POP P,A
	POP P,C
	POP P,B
	XCTR XR,[MOVE Q,(C)]
	AOBJN Q,ABUST2
	POPJ P,
;USET VARIABLE 200+N  --  READ MAP VARIABLE FOR PAGE N.
; (0 <= N < 400)

;VALUE OF MAP WORD READ:

;4.9  -  PAGE WRITEABLE.
;4.8  -  PAGE EXISTS (IF THIS OFF, WHOLE WORD IS 0)
;4.7  -  PAGE IS IN CORE.
;4.6  -  PAGE IS PUBLIC (ANYONE CAN WRITE IT)

;3.1 - 3.9  -  # TIMES PAGE SHARED (LIKE CORTYP'S 4TH VALUE'S RH)
;2.1 - 2.9  -  ABS PAGE # OR PAGE # IN NEXT SHARER
;		(LIKE CORTYP'S 3RD VALUE)
;1.1 - 1.9  -  0 => ABS PAGE  (OR NO PAGE, OF COURSE)
;		-1 => UNSHARED PAGE,
;		ELSE USR NUM. OF NEXT SHARER.

AUSET5:	CAIGE Q,600-100	;GEQ 400 ILLEGAL
	CAIGE Q,200-100	;GEQ 0 IS OK
	JRST ILUUO	;PAGE NUM. OUT OF RANGE.
	PUSHJ P,SWTL
	CIRPSW		;DON'T LET PAGE TABLES CHANGE.
	PUSH P,J
	MOVEI J,(A)	;USER IDX OF JOB TO EXAMINE.
	MOVEI A,-100(Q)	;PAGE NUMBER IN JOB.
	PUSHJ P,NCORT0	;PUT CORTYP'S VALUES IN A THRU D.
	PUSHJ P,LSWPOP	;FREE CIRPSW.
	ANDI B,777	;CORTYP'S 2ND VALUE IN 1.1 - 1.9
	DPB C,[111100,,B]	;3RD VALUE IN 2.1 - 2.9
	TLO B,(D)	;VTH VALUE RH INTO 3.1-3.9
	LSH D,-20.
	TLO B,(D)	;4TH VAL BITS 4.8-4.9 INTO 4.6-4.7
	IOR A,B		;TOGETHER WITH 1ST VALUE'S 4.8, 4.9.
	POP P,J
	JRST APTUAJ
USETBT:	420200,,USETL(Q)	;BYTE POINTER TO UENTRY FIELD A
	400200,,USETL(Q)	; " B
	200200,,USETL(Q)	; " C
	160200,,USETL(Q)	; " D

USETRL:	221600,,USETL(Q)	;BYTE POINTER TO UENTRY FIELD E
	001600,,USETL(Q)	; " F

;IN EACH UENTRY ENTRY:	A IS THE METHOD FOR USET READ
;			B IS THE METHOD FOR SUSET READ
;			C IS THE METHOD FOR USET SET
;			D IS THE METHOD FOR SUSET SET
;			E & F ARE USED BY THE METHODS AS LISTED BELOW
;METHOD 0 = ILLEGAL MODE
;METHOD 1 = USE F AS RELATIVE LOC OF VAR
;METHOD 2 = USE E AS ROUTINE TO TRANSFER TO
;METHOD 3 = USE F AS ROUTINE TO TRANSFER TO

DEFINE UENTRY A,B,C,D,E,F
	A_20+B_16+E,,C_20+D_16+F
	IF2 [
	IFN 777774&<A\B\C\D>,[PRINTX /UENTRY A,B,C,D TOO BIG
/]	IFN 740000&<E\F>,[PRINTX /UENTRY E,F TOO BIG
/]	IFSE [E!F],[PRINTX /UENTRY E,F NULL
/]	]
	TERMIN

USETL:	UENTRY 1,1,2,0,UPCSET,UPC-USRSTG	;.UPC
	UENTRY 1,1,1,1,,VALUE-USRSTG		;.VAL
	UENTRY 1,1,2,2,USTTY,TTYTBL-USRSTG	;.TTY
	UENTRY 1,1,0,0,,FLSINS-USRSTG		;.FLS
	UENTRY 1,1,0,2,UUNAME,UNAME-USRSTG	;.UNAME
	UENTRY 1,1,2,2,UJNAME,JNAME-USRSTG	;.JNAME
	UENTRY 1,1,2,2,USMASK,MSKST-USRSTG	;.MASK
	UENTRY 1,1,2,0,USTOP,USTP-USRSTG	;.USTP

	UENTRY 1,1,2,2,USPIRQ,PIRQC-USRSTG	;.PIRQC
	UENTRY 2,2,0,0,UGSUPR,			;.INTB
	UENTRY 1,1,2,2,URMEMT,HUSRAD-USRSTG	;.MEMT
	UENTRY 1,1,0,0,,SV40-USRSTG		;.SV40
REPEAT 2,UENTRY 1,1,2,2,IAPIRQ,PIRQC-USRSTG	;.IPIRQ/.APIRQ
	UENTRY 1,1,2,2,USYNST,USYSNM-USRSTG	;.SNAM  (WHY NOT .SNAME?)
	UENTRY 1,1,2,2,UPISET,PICLR-USRSTG	;.PICLR

	UENTRY 2,2,3,3,URMAR,USMAR		;.MARA
	UENTRY 1,1,1,1,,UMARPC-USRSTG		;.MARPC
	UENTRY 1,1,0,0,,SUUOH-USRSTG		;.UUOH
	UENTRY 2,2,0,0,UINDEX,			;.UIND
	UENTRY 1,2,0,0,UTRNTR,UTRNTM-USRSTG	;.RUNT
	UENTRY 1,1,2,2,USMSK2,MSKST2-USRSTG	;.MSK2
	UENTRY 1,1,2,2,USIFPI,IFPIR-USRSTG	;.IFPIR
	UENTRY 1,1,0,0,,APRC-USRSTG		;.APRC

	UENTRY 1,1,0,0,,SRN3-USRSTG		;NOT REALLY USED ANYMORE. (.SV60)
	UENTRY 2,0,3,0,RUTRAP,SUTRAP		;.UTRP
REPEAT 2,UENTRY 1,1,2,2,IAIFPI,IFPIR-USRSTG	;.IIFPI/.AIFPI
REPEAT 2,UENTRY 1,1,2,2,IAMASK,MSKST-USRSTG	;.IMASK/.AMASK
REPEAT 2,UENTRY 1,1,2,2,IAMSK2,MSKST2-USRSTG	;.IMSK2/.AMSK2

	UENTRY 3,3,2,2,UJPCS,UJPCR,		;.JPC
	UENTRY 2,2,0,0,UROPC,			;.OPC
	UENTRY 1,1,1,1,,RTIMER-USRSTG		;.RTMR
	UENTRY 1,1,1,1,,SRN3-USRSTG		;NOT REALLY USED ANYMORE. (.60H)
	UENTRY 2,2,3,3,RUBCHN,SUBCHN,		;.BCHN
	UENTRY 2,2,0,0,MPVARD			;.MPVA
REPEAT 2,UENTRY 1,1,2,2,IADF1,IDF1-USRSTG	;.IDF1, .ADF1

REPEAT 2,UENTRY 1,1,2,2,IADF2,IDF2-USRSTG	;.IDF2, .ADF2
	UENTRY 1,1,2,2,USDF1,IDF1-USRSTG	;.DF1
	UENTRY 1,1,2,2,USDF2,IDF2-USRSTG	;.DF2
	UENTRY 1,1,1,1,,OPTION-USRSTG		;.OPTION
	UENTRY 1,1,1,1,,40ADDR-USRSTG		;.40ADDR
IFE N11TYS,	UENTRY 1,1,1,1,,SRN3-USRSTG	;.TVCREG - JOB'S CONSOLE REGISTER CONTENTS
IFN N11TYS,	UENTRY 1,1,1,2,STVCRG,TVCREG-USRSTG
	UENTRY 1,1,1,1,,TTSTSV+2-USRSTG		;.TTST

	UENTRY 1,1,1,1,,TTSTSV-USRSTG		;.TTS1
	UENTRY 1,1,1,1,,TTSTSV+1-USRSTG		;.TTS2
	UENTRY 1,1,1,1,,UWHO1-USRSTG		;.WHO1
	UENTRY 1,1,1,1,,UWHO2-USRSTG		;.WHO2
	UENTRY 1,1,1,1,,UWHO3-USRSTG		;.WHO3
	UENTRY 3,3,0,0,,RUSUPP			;.SUPPRO
IFE KL10P,UENTRY 2,2,0,0,URTR1I			;.TR1INS
IFN KL10P,UENTRY 1,1,2,2,USTR1I,TR1INS-USRSTG
IFE KL10P,UENTRY 2,2,0,0,URTR2I			;.TR2INS
IFN KL10P,UENTRY 1,1,2,2,USTR2I,TR2INS-USRSTG

IFE KL10P,[
REPEAT 4,UENTRY 1,1,0,0,,SRN3-USRSTG
]
IFN KL10P,[
	UENTRY 1,0,0,0,,MBOXCT-USRSTG		;.MBOX
	UENTRY 1,0,0,0,,MBOXCT+1-USRSTG		;.MBO1
	UENTRY 1,0,0,0,,EBOXCT-USRSTG		;.EBOX
	UENTRY 1,0,0,0,,EBOXCT+1-USRSTG		;.EBO1
]
	UENTRY 1,1,1,1,,XUNAME-USRSTG		;.XUNAME (USER'S REAL NAME)
MXVAL==.-USETL
EXPUNGE UENTRY	;NO MORE UENTRY'S

USTOP:	JUMPN D,1USTOP	;NONZERO VALUE => STOP THE JOB.
	MOVE E,APRC(A)	;ZERO => START.
	TLNE E,BULGOS	;BUT DON'T EVER START A JOB THAT'S BEING KILLED.
	 POPJ P,
	JRST 1USTRT

1USTOP:	MOVNI D,1	;SET TO STOP
1USTRT:	PUSHJ P,RPCLSR	;STOP USER IN A
	DPB D,[.BP BUSRC_22,USTP(A)]	;BUSRC
	JRST UPCLSR

;SET INFERIOR'S PC
UPCSET:	PUSHJ P,RPCLSR	;STOP USER IN USER MODE
	TLO D,%PCUSR	;BE SURE USER MODE IS ON IN NEW PC
	TLZ D,BADPC	;BE SURE PRIVILEGED BITS ARE OFF
	SKIPGE IOTLSR(A)	;SKIP UNLESS USER IS SUPPOSED TO BE IN IOT-USER MODE
	TLO D,%PCUIO	;TURN ON IOT-USER MODE
	MOVEM D,UPC(A)	;SET PC
	JRST UPCLSR	;RESTART

UJPCS:	HRRM D,UPJPC(A)
	POPJ P,

UJPCR:	CAIN U,(A)	;READ .JPC:
	 SPM UPGML(U)	;IF READING ONE'S OWN, MAKE SURE IT'S UP TO DATE.
	HRRZ D,UPJPC(A)
	JRST DPUTDJ

IFE KL10P,[
UROPC:	HLLZ D,UPOPC(A)
	LSH D,5
	HRR D,UPOPC(A)
	JRST DPUTDJ
]
IFN KL10P, UROPC==ILUUO	;.OPC NOT SUPPORTED ON KL

IFN N11TYS,[			;SET OWN TV CONSOLE REGISTER
STVCRG:	MOVEM D,TVCREG(U)	;ENABLE TVCREG TO BE SWAPPED IN AND OUT OF HARDWARE
	JUMPL D,CPOPJ		;IF TURNING ON; OR, IF TURNING OFF, ALL DONE
	SKIPGE TT11P		;ALLOWED TO TOUCH HARDWARE?
	 SKIPE TEN11F
	  CAIA
	   MOVEM D,400000+TTR10*2000 ;UPDATE REG IN HARDWARE
	MOVEM D,TVCREG(U)	;AND UPDATE AGAIN IN SOFTWARE IN CASE CLOBBERED AT SSTVR2
	POPJ P,
]

;READ MAR
URMAR:	MOVE D,UPMAR(A)
IFE KL10P,	TLZ D,777770
IFN KL10P,	LDB E,[270400,,D]
IFN KL10P,	HRL D,MARPTB(E)
DPUTDJ:	XCTR XW,[MOVEM D,(J)]	;GIVE TO USER
	POPJ P,

;SET MAR
USMAR:	CONO PI,CLKOFF	;TURN OFF CLOCK INTERRUPTS
	CAMN A,USER
	SPM UPGML(A)	;STORE PG VARIABLES IF HACKING CURRENT USER
IFE KL10P,[
	TLZ D,777770
	TLO D,4	;SET USER MODE
]
IFN KL10P,[
	LDB E,[220400,,D]
	HLL D,MARPTB(E)
]
	MOVEM D,UPMAR(A)
	CAMN A,USER
	 LPMR UPGML(A)		;USE LPMR BECAUSE KL10 DOESN'T HAVE VANILLA LPM
	JRST CLKONJ

IFN KL10P,[	;MAR PERMUTATION TABLE.  MAYBE CAN DO BETTER????   *****

MARPTB:	0  1,  0	;OFF		;NONE (EXEC)
	0 11,  0	;FETCH		;NONE (USER)
	0  3,  2	;WRITE		;WRITE(EXEC)
	0 17,  6	;ANY		;WRITE (USER)
	0  1, 10	;OFF		;READ (EXEC)
	0 11, 14	;FETCH		;READ (USER)
	0  3, 12	;WRITE		;NOT FETCH (EXEC)
	0 17, 16	;ANY		;NOT FETCH (USER)
	0  5,  1	;READ		;FETCH (EXEC)
	0 15,  5	;READ+FETCH	;FETCH (USER)
	0  7, 13	;NOT FETCH	;NOT READ (EXEC)
	0 13, 17	;NOT READ	;NOT READ (USER)
	0  5, 11	;READ		;READ+FETCH (EXEC)
	0 15, 15	;READ+FETCH	;READ+FETCH (USER)
	0  7,  3	;NOT FETCH	;ANY (EXEC)
	0 13,  7	;NOT READ	;ANY (USER)
]

RUSUPP:	HRRE A,SUPPRO(A) ;READ SUPERIOR'S USER INDEX
	JUMPL A,APTUAJ	;-1 => TOP LEVEL
UINDEX:	IDIVI A,LUBLK	;GET INDEX NUMBER
	JRST APTUAJ	;GIVE TO USER

;READ OWN RUN TIME
UTRNTR:	CONO PI,CLKOFF
IFE KL10P,[
	SPM UPGML(U)
	LDB D,[2300,,UPQUAN(U)]
	LSH D,-2	;SIMULATE 4.069 USEC CLOCK
	ADD D,UTRNTM(A)
]
IFN KL10P,[
	RMBOXC A	;REQUIRES AC ORDER - A,B,C,D,E
	DMUL A,KLMBCC	;BECAUSE DMUL PRODUCES FOUR WORD RESULT
	REBOXC D
	DADD B,D
	DMUL B,KLEBCC
]
	CONO PI,CLKON
	JRST DPUTDJ

;SET JOB'S TTYTBL (.TTY VARIABLE).
USTTY:	CONO PI,CLKOFF		;PREVENT TIMING ERROR.
	HLLZ E,TTYTBL(A)	;GET CURRENT VALUE
	XOR E,D			;GET WHICH BITS USER WANTS TO CHANGE
	AND E,[%TBNVR+%TBINT+%TBWAT,,]	;GET BITS USER IS ALLOWED TO CHANGE
	TRNE I,1
	TLZ E,%TBWAT		;THIS BIT CAN BE ALTERED ONLY BY THE SUPERIOR
	XORM E,TTYTBL(A)	;ALTER THE 2 USER-CONTROLLED BITS WITHOUT WRITING THE OTHERS.
	JRST CLKONJ

UJNAME:	JUMPE D,ILUUO	;SET INFERIOR'S JNAME
	CAIN I,3	;.SUSET?
	 JRST UJNAMS	;YES...
	PUSHJ P,RPCLSR
	PUSHJ P,UJNAMU	;IS NEW JNAME UNIQUE?
	JRST UJNAMG	;NO
	MOVEM D,JNAME(A)	;YES
	CONO PI,CLKON
	JRST UPCLSR

UJNAMU:	MOVE B,UNAME(A)
	MOVEI E,0
	CONO PI,CLKOFF
UJNAM1:	CAME B,UNAME(E)
	JRST UJNAMF
	CAMN D,JNAME(E)
	POPJ P,
UJNAMF:	ADDI E,LUBLK
	CAMGE E,USRHI
	JRST UJNAM1
	JRST POPJ1

UJNAMG:	PUSHJ P,UPCLSR
	CAME A,E
	JRST ILUUO
	JRST CLKONJ

UUNAME:	HLRE I,D		;SET OWN UNAME
	AOJE I,ILUUO		;CHECK FOR ILLEGAL ___nnn UNAME
	TDZA I,I
UJNAMS:	 MOVEI I,1		;SET OWN JNAME
	JUMPE D,ILUUO		;CHECK FOR EVIL NAMES
	CAME A,U		;SELF?
	 JRST 4,.		;SOMETHING SCREWED
	SKIPL SUPPRO(U)
	 JRST ILUUO		;MUST BE TOP LEVEL
	CONO PI,CLKOFF		;TURN CLOCK OFF NOW SO WE DON'T GET REOWNED OR SOMETHING
	SKIPN I
	 SKIPA C,JNAME(U)	;CHANGING UNAME, KEEPING JNAME
	  SKIPA C,UNAME(U)	;VICE VERSA
	   EXCH D,C		;NOW C=UNAME, D=JNAME
	MOVEI E,0		;CHECK FOR DUPLICATE NAMES
UUNAM0:	SKIPE UNAME(E)
	 CAMN E,U		;ALLOW SETTING TO SAME NAME AS BEFORE
	  JRST UUNAM1
	HRRZ A,SUPPRO(E)
	CAMN C,UNAME(E)
	CAME D,JNAME(E)
	 CAMN A,U		;JOB CAN'T HAVE INFERIORS
	  JRST ILUUO		;OR DUPLICATE U-JNAME
UUNAM1:	ADDI E,LUBLK
	CAMGE E,USRHI
	 JRST UUNAM0
	CAMN C,UNAME(U)
	 CAME D,JNAME(U)
	  SKIPA A,D		;D GETS CLOBBERED
	   JRST CLKONJ		;THE NAMES WEREN'T ACTUALLY CHANGED! (SYNCOM DOES IT).
	PUSHJ P,LOGUPD		;CHARGE OLD NAME FOR USAGE SO FAR
	MOVEM C,UNAME(U)	;THEN SWITCH NAMES
	MOVEM A,JNAME(U)
	PUSHJ P,DMNPLI		;LOG BACK IN UNDER NEW NAMES
	JRST CLKONJ

RUTRAP:	LDB D,[430100,,UTRAPM(A)]	;GET SPECIAL TRAP MODE INDICATOR
	JRST DPUTDJ

SUTRAP:	DPB D,[430100,,UTRAPM(A)]	;SET    "     "    "       "
	POPJ P,

IFE KL10P,[
URTR1I:	SKIPA D,[0,,%PIARO]	;READ "TRAP 1 INSTRUCTION" FOR KA-10
URTR2I:	 MOVEI D,%PIPDL		;TRAP 2
	JRST DPUTDJ
]		;END OF IFE KL10P

IFN KL10P,[
USTR1I:	MOVEM D,TR1INS(A)	;SET .TR1IN
	JRST TRINST

USTR2I:	MOVEM D,TR2INS(A)	;SET .TR2IN
	JRST TRINST
]

;SET MEMORY BOUND
URMEMT:	CAMN U,A
	 JRST URMEM2
	PUSHJ P,RPCLSR
	MOVSI B,BSSTP
	IORM B,USTP(A)
	PUSHJ P,UPCLSR
URMEM2:	ADDI D,1777
	LSH D,-10.
	MOVE B,D
	MOVEM A,SRN5(U)	;ARGUMENT TO NCORFS
	PUSHJ P,LOSSET
	    NCORFS	;CLEARS BSSTP IN USTP(A).
	EXCH U,A
	PUSHJ P,ACORE
	 JFCL
	EXCH U,A
	JRST LSWCLR

;SET SYSTEM NAME (ZERO IGNORED)
USYNST:	SKIPE D
	MOVEM D,USYSNM(A)
	POPJ P,

;SET INFERIOR'S INTERRUPT MASK
USMASK:	SKIPA Q,[2]	;MOVEM
IAMASK:	 ANDI Q,1	;ANDCAM OR IORM
	ANDCM D,[VBDBTS] ;BITS FOR CLASS 1 INTS CAN'T BE CHANGED.
	XCT (Q)[ IORB D,MSKST(A)
		 ANDCAB D,MSKST(A)
		 MOVEM D,MSKST(A)]
IFE KL10P,[
	MOVEI B,440+APRCHN ;NOW UPDATE JOB'S APRC VARIABLE.
	TRNE D,%PIARO
	TRC B,60
	TLNE D,(%PIFOV)
	TRC B,600
	HRRM B,APRC(A)
	TRNE I,1
	CONO @APRC(A)
]
IFN KL10P,PUSHJ P,TRINST
	JRST UPISE1

IFN KL10P,[
;SET THE AROV AND PDLOV TRAP INSNS ACCORDING TO WHETHER THE
;INTERRUPTS ARE ENABLED; BUT DON'T OVERRIDE AN EXPLICIT SPECIFICATION
;BY THE USER.
TRINST:	MOVE D,MSKST(A)
	MOVSI B,(CAI)		;CAI IS FASTER THAN JFCL - NO AC DECODE
	TDNE D,[%PIFOV+%PIARO]	;AND OVERFLOW GOES OFF A LOT
	 MOVEI B,%PIARO
	HLRZ C,TR1INS(A)
	JUMPE C,TRINS1
	CAIN C,(CAI)
	 MOVEM B,TR1INS(A)
TRINS1:	MOVSI B,(CAI)
	TRNE D,%PIPDL
	 MOVEI B,%PIPDL
	HLRZ C,TR2INS(A)
	JUMPE C,CPOPJ
	CAIN C,(CAI)
	 MOVEM B,TR2INS(A)
	POPJ P,
]

;SET INFERIOR'S PI IN PROGRESS FLAG
UPISET:	ASH D,-35.	;SHIFT SIGN BIT TO BOTTOM BIT
	MOVEM D,PICLR(A)	;SET VARIABLE
;COME HERE WHEN ANY INTERRUPT VARIABLE'S VALUE IS CHANGED
;BY A .USET OR .SUSET; TAKE ANY INTS THAT ARE NOW PENDING.
UPISE1:	MOVE A,T	;IAMASK, ETC. MODIFY A. RESTORE IT.
	TRNN I,1	;SKIP IF A SUSET
	 JRST APISE6
	JRST APISE1	;SEE IF SHOULD REINTERRUPT

IAMSK2:	ADDI A,MSKST2-IDF1
IADF1:	ADDI A,IDF1-IDF2
IADF2:	ADDI A,IDF2-PIRQC	;IORM OR ANDCAM INTO IDF2.
IAPIRQ:	ADDI A,PIRQC-IFPIR
IAIFPI:	ANDI Q,1	;GET USET PARITY (0=IORM, 1=ANDCAM)
	XCT IAINS(Q)	;DO APPRO OP
	JRST UPISE1

IAINS:	IORB D,IFPIR(A)	;SET BITS
	ANDCAB D,IFPIR(A)	;FLUSH BITS

USMSK2:	ADDI A,MSKST2-IDF1	;SET .MSK2, ETC.
USDF1:	ADDI A,IDF1-IDF2
USDF2:	ADDI A,IDF2-PIRQC
USPIRQ:	ADDI A,PIRQC-IFPIR
USIFPI:	MOVEM D,IFPIR(A)
	JRST UPISE1

;.RBCHN, .SBCHN  READ/SET NUMBER OF LAST CHANNEL ON WHICH ERROR OCCURRED
RUBCHN:	LDB D,[BCHPTR#(A#U)]
	JRST DPUTDJ

SUBCHN:	DPB D,[BCHPTR#(A#U)]
	POPJ P,

;GET INT BIT
UGSUPR:	HLLZ D,SUPPRO(A)
	JRST DPUTDJ

;MA (HIGH BITS) ON LAST MPV OR WIRO
;SET UP, CALLED FROM CLKBRK, DONT CLOBBER A OR D

MPVMAS:
IFE KL10P,[
	HLRZ T,UPJPC(U)
	LSH T,10.
]
IFN KL10P, HRRZ T,UPFW(U)
	HRRM T,IOTLSR(U)
	POPJ P,

;.RMPVA READ VIRTURAL PAGE # (8 BITS) OF LAST MPV OR WIRO

MPVARD:	HRRZ D,IOTLSR(A)
	JRST DPUTDJ

SUBTTL USER INSTRUCTION HANG ROUTINE (.HANG)

AHANG:	MOVE A,UUOH
	XCTR XR,[MOVE A,-2(A)]	;GET USER'S FLUSH INSTRUCTION
AHANG7:	LDB C,[360600,,A]	;PICK UP FIRST TWO DIGITS OF OP CODE
	CAIE C,CAM_-36	;CHECK FOR CAMX INSTRUCTIONS
	CAIN C,TDN_-36	;CHECK FOR TDNX AND TSNX INSTRUCTIONS
	 JRST AHANG6	;CAMX, TDNX, OR TSNX, SET UP AC
	CAIN C,TLN_-36	;TRNX, TLNX WORK.
	 JRST AHANG4	;SINCE THEY ONLY REFERENCE AC
	CAIN C,AOS_-36	;AOS AND SOS WORK - CHANGE THEM TO CAM.
	 JRST AHANG0
	CAIN C,SOS_-36
	 JRST AHANG9
	CAIE C,SKIP_-36	;NOW CHECK FOR SKIPX (BUT NOT AOS OR SOS, THOSE ILLEGAL)
	 JRST AHANG2	;NONE OF THESE, MAYBE XCT OR CONSX
	LDB C,[331100,,A]
	CAIN C,SKIP_-33
	 JRST AHANG8	;SKIP ... LONG HANG
	TLZ A,740	;FLUSH THE AC FIELD FROM WHAT WE USE AS FLSINS.
AHANG1:	MOVE R,A
	PUSHJ P,ASCIND	;PERFORM ADDRESS CALC
	MOVEM R,EPDL(U)
	TLC R,(XCT)
	TLNN R,777000
	 JRST AHANG5	;XCT
	PCLT
	TRNN R,777760
	 JRST AHANG4	;ONLY REFERENCES AC
	JRST .+2
	PUSHJ P,UHANG
	PUSHJ P,UFLS
	POPJ P,

AHANG4:	SOS UUOH	;UUOH -> THE .HANG, BUT AFTER PCLSR IT WILL -> THE FLSINS.
	JRST AHANG3	;AND HANG FOREVER SINCE AC CAN'T CHANGE WITHOUT PCLSR'ING

AHANG8:	MOVSI A,(SETZ)
	IORM A,USWST(U)	;DESIRED OUT
AHANG3:	JFCL
	PUSHJ P,UFLS	;LONG LONG HANG
	JRST 4,.

AHANG2:	LDB B,[331100,,A]	;PICK UP OP CODE
	CAIN B,XCT_-33
	JRST AHANG1	;XCT
	CAIN B,JFCL_-33
	JRST AHANG8	;JFCL ... LONG HANG
	HLRZ C,A
	TRZ C,077477
	CAIE C,(CONSZ\CONSO)
	JRST ILUUO
	JRST AHANG1

AHANG9:	SKIPA T,[1]	;COME HERE FOR SOS: COMPARE AGAINST 1.
AHANG0:	 MOVNI T,1	;FOR AOS, COMPARE WITH -1.
	TLZ A,770740
	TLO A,(CAM T,)	;CHANGE TO CAM (BUT DON'T CLOBBER CONDITION)
	JRST AHANG1

AHANG5:	PUSHJ P,OPBRK	;EFFECTIVE ADDRESS CALCULATED, BUT INSTR IS XCT
	XCTR XR,[MOVE A,(R)]
	JRST AHANG7

AHANG6:	LDB B,[270400,,A]	;LEGITIMATE MEMORY REFERENCE INSTR WANTS AC SET UP
	XCTR XR,[MOVE T,(B)]	;GET CONTENTS OF AC FROM USER
	TLZ A,(0 17,)	;CLEAR OUT AC FIELD IN INSTR
	TLO A,(0 T,)	;REPLACE AC FIELD IN INSTR WITH T
	JRST AHANG1

	;.HANG FLUSH INSTRUCTION ROUTINE, CALLED WITH PUSHJ ONLY ON CLOCK LEVEL

UHANG:	MOVEI TT,0		;SAVE MAR WORD
	EXCH TT,UPMAR(U)	;SO WILL NOT MAR
	LPMR UPGML(U)
	MOVEM TT,UPMAR(U)	;RESTORE MAR
	MOVE TT,EPDL(U)
	XCTRI XRW,[SKIP (TT)]	;REFERENCE LOCATION
	 JRST UHANG1		;NOT SWAPPED OUT OR MISSING
	MOVNI B,2		;BACK UP TO INSTRUCTION BEFORE .HANG
	ADDM B,SUUOH(U)
	SETZM FLSINS(U)
	JRST POPJ1

UHANG1:	XCTR XRW,TT
	 POPJ P,
	JRST POPJ1

;ALLOW INT IF BEING PCLSRED
OPBRK:	PUSH P,T
	MOVE T,UEXIT
	CAMN T,[JRST ONEFLS]
	PUSHJ P,UDELAY
	POP P,T
	POPJ P,

SUBTTL .OPEN AND FRIENDS

;
;.FDELE FILBLK	;DELETE OR RENAME FILE SPECIFIED AT FILBLK
;
AFDELE:	SETZM UUAC(U)
	XCTR XR,[MOVE A,(C)]	;GET DEVICE
	MOVEI W,4
	DPB W,[OPNCOM,,A]	;SET OP TO SPECIFY AN .FDELE
	JRST AFDEL1
;
;OPEN SET UP AND DISPATCH
;3.1=0 => INPUT  =1 OUTPUT
;3.2=0  => UNITS   =1  BLOCK
;3.3=0  => ASCII   =1 IMAGE
;4.9-4.7 OPERATION FIELD
;   0=> NORMAL READ OR WRITE
;   1=> WRITE OVER MODE
;   2=> MAKE LINK
;   4=> DELETE OR RENAME (INTERNAL)
;
;.OPEN CH,FILBLK	;OPEN FILE SPECIFIED AT FILBLK ON LOGICAL CHANNEL CH
;
AOPEN:		;C HAS EFF ADR OF UUO AND R ITS AC FIELD
	ADDI R,IOCHNM(U)	;MAKE R POINT TO SPECIFIED I/O CHANNEL WORD
	PUSH P,C
	PUSHJ P,ACLOSE	;CLOSE PREV
	POP P,C
	XCTR XR,[MOVE A,(C)]	;GET DEV AND MODE BITS
	LDB W,[OPNCOM,,A]
	CAIN W,4
	JRST OPNL23	;BARF IF TRY TO DELETE WITH .OPEN
AFDEL1:	MOVEI TT,SRN3(U)	;MOVE 4TH-6HT ARGS
	HRLI TT,3(C)		;TO SRN3 THRU SRN5
	MOVEI Q,3(TT)
	XCTR XBR,[BLT TT,-1(Q)]
	XCTR XR,[MOVE B,1(C)]	;GET 2ND, 3RG ARGS (FILENAMES)
	XCTR XR,[MOVE C,2(C)]
	MOVE D,USYSNM(U)	;USE DEFAULT SNAME.
	HLRZ E,A		;GET MODE BITS.
	HRLZI A,(A)	;LEFT-JUSTIFY DEVICE NAME.
NOPNE:	CAIN W,4	;SKIP ON NOT .FDELE (ENTRY FOR NCALL TYPE OPEN, ETC COMMANDS)
	SKIPN SRN3(U)	;SKIP ON RENAME
	JRST AOPEN3	;JUMP IF A .OPEN OR DELETING .FDELE
	JUMPN B,AOPEN3	;JUMP UNLESS RENAME WHILE OPEN.
	MOVE TT,C	;GET CH ON WHICH FILE IS SUPPOSIDLY OPEN
	TDNE TT,[-NIOCHN]	;SKIP IF CH LOGICALLY LESS THAN 20
	JRST OPNL14	;BAD CHANNEL NUM
	ADDI TT,IOCHNM(U)	;RELOCATE TO POINT TO CH WORD FOR USER
	MOVE Q,(TT)	;GET CH WORD
	HLRZ Q,CLSTB(Q)	;GET LEFT HALF OF CLOSE TABLE ENTRY FOR INDEX IN I/O CH WORD
	TRNE Q,100040
	JRST JFDEL4	;JOB DEVICE CHNL
	TRNN Q,202200	;SKIP IF A DIRECTORY DEVICE
	JRST POPJ1	;JUMP IF NOT DIRECTORY DEVICE
	HLRZ J,(TT)	;PICK UP DEV CHNL NO
	EXCH A,B	;PUT FN1, FN2 IN A, B.
	EXCH B,C
IFN NUNITS,[
	TRNN Q,200000	;SKIP IF DEC TAPE
	 JRST NOPNE1
	MOVEI C,(SIXBIT/UT0/)	;GET DUMMY UT DEV NAME.
	HRRZ I,UTTNO(J)	;GET POSSIBLE TAPE NUM
	DPB I,[300,,C]	;STORE IN DEV NAME
	PUSH P,[UTO]	;WILL EXIT TO UTAPE OPEN RTN.
	JRST NOPNE2
]
NOPNE1:	MOVEI C,(SIXBIT/DSK/)	;NOT UT, MUST BE DSK.
	PUSH P,[QSKO]	;NOBODY ELSE HANDLES RENAME WHILE OPEN.
NOPNE2:	HRLI C,(E)	;RE-INSERT MODE BITS.
	MOVEI E,1	;DIRECTORY DEVICE
	JRST OPEN2B

AOPEN3:	PUSHJ P,TRAN	;PERFORM I/O TRANSLATIONS
	 JRST OPNL3	;TOO MANY TRANSLATIONS.
	MOVEM D,USYSN1(U);SAVE TRAN'D SNAME FOR OPEN RTN.
	PUSH P,A	;PUT NAMES ON STACK.
	PUSH P,B
	PUSH P,C
	TRNE A,-1
	 JRST OPEN22	;SYSTEM DEVICE NAMES ARE 3 CHARACTERS
	HLRZS A
	MOVSI B,-NDEVS	;LOAD LENGTH OF FIRST DEV NAME TABLE
	HRRZ C,DEVTAB(B);GET DEVNAM POINTED AT BY COUNT
	CAIE C,(A)	;SKIP IF EQUAL
	 AOBJN B,.-2	;LOOP TILL FOUND OR COUNTED OUT
	JUMPG B,OPEN1	;JUMP IF NOT FOUND
OPEN2:	HLRZS -2(P)	;FOUND SYSTEM DEVICE, CHANGE NAME TO 3 CHARS
	HRLM E,-2(P)	;AND INSERT MODE BITS IN LH
	LDB C,[.BP %DVDEL_22,DEVTAB(B)]	;<IGNORE DELETE> BIT
	CAIN W,4
	 JUMPN C,OPEN2C	;IGNORE DELETE
	LDB C,[.BP %DVLNK_22,DEVTAB(B)]
	CAIN W,2
	 JUMPE C,[ SUB P,[3,,3]
		   JRST OPNL34	]	;DEVICE DOESN'T ALLOW LINK
	MOVSI C,%DVIN	;PICK UP INPUT BIT FOR DEVTAB
	TRNE E,1	;SKIP IF INPUT MODE SPECIFIED
	 MOVSI C,%DVOUT	;PICK UP OUTPUT BIT FOR DEVTAB
	TDNN C,DEVTAB(B);SKIP IF REQUESTED MODE IS ALLOWED
	 JRST LCDIY	;IO DEVICE DOESN'T GO THAT WAY
	LDB E,[.BP %DVDIR_22,DEVTAB(B)]	;GET DIR DEV BIT
	HRRZ C,DEVADR(B)
OPEN2A:	POP P,B		;UNSAVE SECOND FILE NAME
	POP P,A		;UNSAVE FIRST FILE NAME
	EXCH C,(P)	;EXCHANGE <MODE BITS,,DEV> AND .OPEN ROUTINE POINTER
OPEN2B:	HLRZ D,C	;GET MODE BITS IN R.H. OF D
;
;AT THIS POINT:	A & B HAVE FILE NAMES, C HAS MAPPED DEV AND MODE BITS
;W HAS OPEN COMMAND
;
	ROT D,-1	;ROTATE IN/OUT BIT TO SIGN
	CAIN W,4	;SKIP IF NOT A .FDELE
	 TDZ D,[400000,,7]	;A .FDELE, MAKE LOOK LIKE OPEN FOR READ
	PUSHJ P,FLDRCK
	 POPJ P,	;POPJ TO .OPEN ROUTINE
	JUMPN E,CPOPJ	;DIR DEVICE, POPJ TO .OPEN ROUTINE
;ASKING FOR DIR OF DEVICE SYSTEM DOESN'T HAVE DIR ROUTINE FOR.
;PASS IT OFF TO THE UNKNOWN-DEVICE HANDLER.
	MOVEM C,(P)	;POP .OPEN ROUTINE AND PUSH DEVICE NAME
	HRLZS (P)	;CHANGE TO 6-CHARACTER DEVICE NAME
	PUSH P,A	;PUSH FN1
	PUSH P,B	;PUSH FN2
	HLRZ E,C	;GET MODE BITS
	JRST OPEN22	;PASS TO UNKNOWN DEVICE JOB

OPEN2C:	SUB P,[3,,3]	;IGNORE FDELE
	JRST POPJ1

	;CHECK FOR NUMBERED DEV
OPEN1:	MOVE B,[-NDV1,,DVT1-DEVTAB]	;LOAD AOBJN POINTER WITH COUNT FOR 2ND DEV TABLE
OPEN1A:	MOVEI I,0		;INITIALIZE NUMBERED DEV NUM TO ZERO
	MOVE D,[440600,,-2(P)]	;GET BYTE POINTER INTO DEV REQUESTED
	MOVE C,[220600,,DEVTAB(B)]	;GET BYTE POINTER INTO CURRENT TABLE ENTRY
OPENA1:	ILDB A,C	;GET CHAR FROM TABLE
	ILDB J,D	;GET CHAR FROM DEV
	JUMPE A,OPEN1B	;JUMP ON SPACE IN TABLE, "MATCHES" DIGIT IN DEV
	CAIN A,(J)	;SKIP IF CHAR DIFFER
	 JRST OPEN1C	;SAME, TRY FOR NEXT CHAR
OPENZ1:	AOBJN B,OPEN1A	;LOOP TO NEXT TABLE ENTRY OR COUNT OUT
;
;"UNKNOWN DEVICE" HANDLER.  FOO DEVICE IS LOADED BY
;SYS;ATSIGN DEVICE FROM FILE DEVICE;JOBDEV FOO
;
OPEN22:	POP P,EPDLT2(U)	;WHEN WE USE SYS:ATSIGN DEVICE AS A JOB DEVICE,
	POP P,EPDLT1(U)	;SET UP THE "NAMES BEFORE LAST TRANSLATION" TO BE
	POP P,EPDLT4(U) ;THE NAMES BEING USED, INCLUDING "FOO" AS THE DEVICE.
	MOVE A,USYSN1(U)
	MOVEM A,EPDLT3(U)
	PUSH P,['JOB]
	HRLM E,(P)	;JOB DEVICE, SAME MODE
	PUSH P,['ATSIGN]
	PUSH P,['DEVICE]
	MOVSI A,'SYS
	MOVEM A,USYSN1(U)
	MOVEI E,1
	MOVEI C,JOBO	;OPEN ROUTINE
	JRST OPEN2A

OPEN1B:	SUBI J,'0	;CONVERT SIXBIT DIGIT TO NUMBER
	JUMPL J,OPENZ1	;JUMP IF TOO SMALL, NOT A DIGIT
	CAILE J,9	;SKIP IF LESS THAN 10.
	 JRST OPENZ1	;LOSE, TRY NEXT
	ASH I,3		;MULTIPLY NUM SO FAR BY 8
	ADD I,J		;ADD NEW DIGIT
OPEN1C:	TLNE C,770000	;SKIP IF ALL THREE CHAR POSITIONS COMPARED
	 JRST OPENA1	;GO TO NEXT POSITION
	JRST OPEN2

AOPEN5:	SUB P,[3,,3]	;RESTORE PDL PNTR
	POPJ P,		;RETURN
NOPEN:	HRRZ R,A	;ARGS 1 MODE (LH) CHNL (RH) 2-5 LIKE NOPEN1 1-4
	CAILE R,17
	JRST OPNL14
	ADDI R,IOCHNM(U)
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,W
	PUSHJ P,CCLOSE
	POP P,W
	SOS W	;STRIP OF FIRST ARG
	POP P,D	;B-E POPPED INTO A-D
	POP P,C
	POP P,B
	POP P,A
	POP P,R	;A POPPED INTO R
	TLC R,@CTLBTS(U)
	LDB E,[OPNCOM,,R]
	CAIE E,2
	CAIN E,4
	JRST OPNL12	;COMMAND CANT BE LINK OR FDELE FOR "NEW" CALL
	JSP T,NOPEN1
	MOVEM D,SRN3(U)	;MAKE SYMBOLIC OPEN OF NETWORK WIN USING 5TH ARG AS FOREIGN HOST.
NDEL1:	CLEARM SRN4(U)
NRN2:	CLEARM SRN5(U)
NOPENX:	TRNE R,-NIOCHN
	 JRST 4,.	;BAD CHANNEL #
	HRRZM R,UUAC(U)	;CHNL # (MAYBE ONLY FOR ERRS) IN R
	ADDI R,IOCHNM(U)
	LDB W,[OPNCOM,,R]
	JRST NOPNE

;DEFAULT THE ARGS FOR .CALL OPEN, ETC,; PUT MODE IN E.
NOPEN1:	CAIGE W,2
	MOVSI B,(SIXBIT /@/)
	CAIGE W,3
	MOVSI C,(SIXBIT /@/)
	CAIGE W,4
	MOVE D,USYSNM(U)	;SYSTEM NAME
	HLRZ E,R	;GET MODE BITS FOR TRAN.
	JRST (T)

;MAKE LINK 1-4 AS NOPEN1, 5 SNAME 2 6,7 FN1,2(2)
NMLINK:	MOVEM E,SRN3(U)
	MOVEM TT,SRN4(U)
	MOVEM I,SRN5(U)
	MOVSI R,200000
	JSP T,NOPEN1
	JRST NOPENX


NDEL:	MOVSI R,400000	;DELETE, ARGS AS NOPEN1
	JSP T,NOPEN1
	SETZM SRN3(U)
	JRST NDEL1

NRNAM:	MOVEM E,SRN3(U)
	MOVEM TT,SRN4(U)
	MOVSI R,400000	;RENAME 1-4 AS NOPEN1 5,6 NEW FN1,2
	JSP T,NOPEN1
	JRST NRN2

NRNWO:	MOVEM B,SRN3(U)	;PUT AWAY NEW NAMES.
	MOVEM C,SRN4(U)
	MOVEI C,(A)	;CHNL NUM IS "OLD FN2".
	SETZB A,B
	MOVEI D,0
	MOVSI R,400000	;OPNCOM IS .FDELE .
	MOVEI E,400000
	JRST NRN2

SUBTTL HACKS FOR OPENS THAT LOSE


IFN 0,[		;THESE "DEFNS" EXIST ONLY SO @ WILL CREF THEM
	OPNL1:	OPNL2:	OPNL3:	OPNL4:	OPNL5:	OPNL6:	OPNL7:
OPNL10:	OPNL11:	OPNL12:	OPNL13:	OPNL14:	OPNL15:	OPNL16:	OPNL17:
OPNL20:	OPNL21:	OPNL22:	OPNL23:	OPNL24:	OPNL25:	OPNL26:	OPNL27:
OPNL30:	OPNL31:	OPNL32:	OPNL33:	OPNL34:	OPNL35:	OPNL36:	OPNL37:
OPNL40:	OPNL41:	OPNL42:	OPNL43:	OPNL44:	OPNL45:	OPNL46:	OPNL47:
OPNL50:	OPNL51:	OPNL52:	OPNL53:	OPNL54:	OPNL55:	OPNL56:	OPNL57:
OPNL60:	OPNL61:	OPNL62:	OPNL63:	OPNL64:	OPNL65:	OPNL66:	OPNL67:
OPNL70:	OPNL71:	OPNL72:	OPNL73:	OPNL74:	OPNL75:	OPNL76:	OPNL77:	
]		;END OF IFN 0

;HERE ARE THE REAL DEFNS
REPEAT NOPNLS,CONC OPNL,\.RPCNT+1,:	JSP D,OPENL
;
OPENL:	MOVE U,USER	;BE SURE U=CURRENT USER'S INDEX
	MOVEI D,-OPNL1(D)	;GET LOSSAGE NUMBER
	MOVE R,SYSCVL(U);POSSIBLY RETURN IN ERROR-CODE ARG TO .CALL
	TLNE R,%SCVER
	 XCTR XW,[MOVEM D,(R)]
	HRRZ R,UUAC(U)	;GET CH NUM
	CAILE R,NIOCHN-1
	JRST 4,.	;UUAC BAD
	PUSHJ P,LSWCLR	;UNLOCK SWITCHES
	DPB R,[BCHPTR]	;SAVE AS MOST RECENT CHANNEL IN ERR
	ADD R,U		;RELOCATE TO POINT TO USER VARS
	DPB D,[220600,,IOCHST(R)]	;STORE IN STATUS WORD
	JRST CLKONJ

NSD:	PUSHJ P,OPNL1	;SET I/O CH STATUS WORD TO INDICATE NO SUCH DEVICE
	JRST AOPEN5	;RETURN

LCDIY:	LDB E,[410100,,DEVTAB(B)]	;GET DIR BIT
	MOVEI C,OPNL2	;LOAD, AS .OPEN ROUTINE POINTER, THE ADR OF WRONG DIRECTION OPEN LOSE
	JRST OPEN2A	;WILL JUMP TO OPNL2 IF NOT READING ".FILE. (DIR)"

UNCA:	JUMPGE D,NCA
UTWNA:	SUB P,[2,,2]
NCA:	JRST OPNL10

UFILDF:	SUB P,[2,,2]
FILDF:	JRST OPNL5

S1NL14:	SUB P,[1,,1]
	JRST OPNL14

SUBTTL .RCHST AND .STATUS ROUTINES

;SYMBOLIC CALL "RFNAME"
;1 ARG, A CHANNEL NUMBER
;5 OR MORE VALUES. THE FIRST 4 ARE THE DEVICE, FN1, FN2 AND SNAME
;  AS LEFT-JUSTIFIED SIXBIT WHOLEWORDS.
;THE 5TH IS THE ACCESS POINTER, OR -1 IF NOT RANDOM ACCESS.
;MORE VALUES ARE RETURNED ONLY FOR NET:, AT THE MOMENT.

;THIS SUBROUTINE LEAVES THE NUMBER OF MEANINGFUL VALUES IN W.
;R HAS ADDR OF IOCHNM WD, H HAS CONTENTS.

NRFNAME:
	HLRZ A,H	;PUT LH(IOCHNM WD) WHERE DEVICE RTN LOOKS
	HLLZ J,DCHSTB(H)
	PUSH P,J	;SAVE THE PROBABLE VALUE OF DEVICE NAME
	HRRZ J,DCHSTB(H)
	SETZB B,C	;FN1, FN2 ARE 0 FOR NON-DIR-DEV
	SETZ D,		;SNAME 0 EXCEPT FOR MULTI-DIR-DEVS
	SETZB I,TT	;VALUES AFTER THE 5TH NORMALLY DON'T EXIST
	SETO E,		;ACCESS PTR -1 EXCEPT ON RANDOM ACCESS DEVS
	MOVEI W,5	;NORMALLY THERE ARE 5 VALUES RETURNED.
	PUSHJ P,(J)	;CALL DEVICE-SPECIFIC ROUTINE
	 CAIA		;SKIPS => USE DEV NAME RETURNED IN J
	  MOVEM J,(P)	;RATHER THAN THAT FOUND IN DCHSTB
	POP P,A		;RETURN DEV NAME AS THE 1ST VALUE
	JRST POPJ1

;.RCHST AC,  W/  AC/ CH,,ADDR
;RETURNS, IN THE 5 OR MORE WORDS STARTING AT ADDR,
;THE RESULTS OF AN RFNAME ON CHANNEL CH.
;ONE EXCEPTION - THE DEVICE NAME IS RETURNED IN THE RH
;OF THE FIRST WORD , SO IT IS TRUNCATED TO 18 BITS.
;NEVER SKIPS.

ARCHST:	XCTR XR,[MOVE J,(J)]	;GET CONTENTS OF AC
	HLRZ A,J
	CAIL A,NIOCHN
	 JRST ILUUO	;BAD CHANNEL NUMBER
	MOVE T,[4,,.+2]	;DECODE THE CHANNEL NUMBER, NO ERROR IF
	JRST CHNDCD	;NOT OPEN.
	PUSH P,J
	PUSHJ P,NRFNAME	;DO THE REAL WORK.
	 JRST 4,.
	HLRZS A		;PUT DEV NAME IN RH FOR HISTORY'S SAKE
	POP P,J		;RH(J) HAS PLACE TO STORE DATA
	HRLI J,A
	ADDI W,-1(J)	;W HAD # VALS, NOW HAS PLACE TO PUT LAST ONE
	XCTR XBW,[BLT J,(W)]
	POPJ P,

;TABLE FOR RFNAME/.RCHST
;LH SIXBIT MAIN DEVICE NAME,  RH ROUTINE TO GET REST OF DATA

DCHSTB:				      CPOPJ
		REPEAT 4,SIXBIT /TTY/+RCHTTY
		REPEAT 4,SIXBIT /NUL/+CPOPJ
		REPEAT 6,SIXBIT /USR/+RCHUSR
IFN NUNITS,	REPEAT 6,SIXBIT /UT/+RCHUTP
IFG LPTP-1,	REPEAT 2,SIXBIT /OLP/+CPOPJ
IFN LPTP,	REPEAT 2,SIXBIT /LPT/+CPOPJ
		REPEAT 4,SIXBIT /DIR/+CPOPJ
IFN VIDP,	REPEAT 2,SIXBIT /NVD/+CPOPJ
IFN PLTP,	REPEAT 2,SIXBIT /PLT/+CPOPJ
IFN PTRP,	REPEAT 5,SIXBIT /PTP/+CPOPJ
IFN IMXP,	REPEAT 4,SIXBIT /IMX/+CPOPJ
IFN OMXP,	REPEAT 4,SIXBIT /OMX/+CPOPJ
		REPEAT 6,SIXBIT /CLO/+RCHCL
IFN PTRP,	REPEAT 5,SIXBIT /PTR/+CPOPJ
IFN 340P,	REPEAT 4,SIXBIT /DIS/+CPOPJ
;IFN 340P,		SIXBIT /IDS/+CPOPJ
IFN CODP,	REPEAT 2,SIXBIT /COD/+CPOPJ
		REPEAT 6,SIXBIT /DSK/+RCHQSK
IFN VIDP,	REPEAT 4,SIXBIT /TVC/+CPOPJ
IFN PDP6P,	REPEAT 4,SIXBIT /PDP/+RCHUSR
IFN TABP,	REPEAT 2,SIXBIT /TAB/+CPOPJ
IFN NMTCS,	REPEAT 8,SIXBIT /MT0/+CPOPJ
		REPEAT 6,SIXBIT /JOB/+RCHJOB
		REPEAT 6,SIXBIT /BOJ/+RCHBOJ
			SIXBIT /IIP/+[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
			SIXBIT /SPY/+CPOPJ
		REPEAT 4,SIXBIT /STY/+RCHSTY
IFN NETP,	REPEAT 4,SIXBIT /NET/+NETRCH
IFN MSPP,		SIXBIT /MSP/+CPOPJ
IFN STKP,		SIXBIT /STK/+CPOPJ

IF2,IFN .-DCHSTB-LIOTTB,.ERR BARF AT DCHSTB

DCHSTE==.-1	;END FOR GETSYS (CHDEVS)

;DEVICE-SPECIFIC RFNAME/.RCHST ROUTINES

	;.RCHST USR ROUTINE
RCHUSR:	MOVE B,UNAME(A)		;GET UNAME
	MOVE C,JNAME(A)		;GET JNAME
	HRRZ E,IOCHST-IOCHNM(R)	;GET ACCESS POINTER
	POPJ P,

IFN NUNITS,[
	;.RCHST UTAPE ROUTINE
RCHUTP:	HRRZ C,UTTNO(A)
	MOVSI J,'UT0(C)	;GET REAL DEV NAME "UTN" IN J
	AOS (P)		;SKIP TO RETURN CHANGED DEV NAME
	MOVE D,UTASS(C)	;THE "SNAME" IS THE USER TAPE IS ASSIGNED TO.
	CAIGE A,NUTIC
	 JRST RCHUTI	;INPUT
	MOVE B,UTN1(A)	;OUTPUT, GET FN1
	MOVE C,UTN2(A)	;NOW FN2
	POPJ P,

	;UTAPE INPUT .RCHST
RCHUTI:	LDB T,[220500,,UTDBC(A)]	;GET FILE NUMBER
	SUBI T,1
	LSH T,1			;TURN INTO INDEX INTO DIRECTORY
	CONO PI,CLKOFF
	ADD T,UDIRO(C)		;GET POINTER TO FILE NAMES
	MOVE B,(T)		;GET FN1
	MOVE C,(T)		;GET FN2
	JRST CLKONJ
]

;RFNAME ROUTINE FOR TTY
RCHTTY:	TRNE A,%TICNS
	 POPJ P,
	ANDI A,7
	MOVEI J,'T00(A)
	HLRZ A,(R)
RCHST1:	ANDI A,70
	LSH A,3
	ADD J,A
	HRLZS J		;J NOW HAS SIXBIT/TNM/, NM = TTY #.
	JRST POPJ1	;SKIP TO SAY DEV NAME IS IN J.

RCHSTY:	SUBI A,NFSTTY
	ANDI A,7
	MOVEI J,'S00(A)
	HLRZ A,(R)
	SUBI A,NFSTTY
	JRST STSTY1

;CORE LINK .RCHST ROUTINE

RCHCLO:	CONO PI,CLKOFF
	MOVE B,CLN1(A)	;GET FN1
	MOVE C,CLN2(A)	;GET FN2
	MOVE D,CLSYN(A)	;GET SYSTEM NAME
	JRST CLKONJ

;RFNAME ROUTINE FOR DSK

RCHQSK:	MOVE H,QUDPR(A)	;FILE STATUS FOR DISK PICKUP USER DIR POINTER
	PUSHJ P,QUDLK	;LOCK DIRECTORY
	MOVE C,QSNLCN(H)	;LOCATION OF DIRECTORY
	MOVE D,UDNAME(C)
	ADD C,QUDFPR(A)	;ADD LOCN OF FILE WITHIN DIRECTORY
	MOVE B,(C)	;GET FIRST FILE NAME
	MOVE C,1(C)	;GET SECOND FILE NAME
	MOVEI E,0	;PICK UP 0 IN CASE
	MOVSI T,%QAACC
	TDNN T,QSRAC(A)
	 JRST RCHQS1
	MOVE E,QRADAD(A)
	JRST QUDULK

RCHQS1:	SKIPGE QSMDN(A)	;SKIP ON A BUFFER ACTIVE
	 JRST RCHQS2	;NO BUFFER ACTIVE, WILL READ FIRST WORD OF NEXT BLOCK
			;WHICH IS WHAT QFBLNO POINTS TO
	MOVE E,QSMPRP(A)
	IBP E
	ANDI E,1777	;NUMBER OF WORDS PASSED OVER IN THIS BUFFER
RCHQS2:	ADD E,QFBLNO(A)	;ADD WORD ORG OF CURRENT BUFFER
	JRST QUDULK

;RFNAME ROUTINE FOR BOJ:

RCHBOJ:	CONO PI,CLKOFF	;BOJ DEVICE .RCHST ROUTINE
	MOVE T,JBCUI(A)	;RETURNS CREATOR'S NAME
	MOVE B,UNAME(T)
	MOVE C,JNAME(T)
	SKIPGE JBCG(A)
	 SETZB B,C	;CREATOR GONE, RETURN BLANK NAMES
	JRST CLKONJ

SUBTTL I/O DEVICE DISPATCH TABLES

;
;DISPATCH TABLE FOR .CLOSE UUO
;TRANSFERED THROUGH USING RIGHT HALF OF I/O CH WORD AS AN INDEX
;
;VARIOUS ROUTINES USE THE BITS IN THE L.H. TO DECIDE WHETHER
;A CHANNEL IS ACCEPTABLE FOR SOME OPERATION.
%CLSU==400000	;USR DEVICE
%CLSDO==200000	;DECTAPE OUTPUT
%CLSJI==100000	;JOB INPUT
%CLSDI==40000	;DECTAPE INPUT
%CLSTI==20000	;TTY INPUT
%CLSCL==10000	;CORE-LINE DEVICE
%CLSBJ==4000	;BOJ DEVICE
%CLSQO==2000	;DISK OUTPUT
%CLSFU==1000	;NON-INFERIOR USR
%CLSNRM==400	;STANDARD CLOSE ROUTINE USED FOR THIS DEVICE.
%CLSQ==200	;DISK
%CLS6==100	;PDP6
%CLSJO==40	;JOB OUTPUT
%CLSST==20	;STY DEVICE.

CLSTB:	CPOPJ
		REPEAT 2,20000,,TYICLS	;TYI
		REPEAT 2,TYOCLS	;TYO
		REPEAT 4,CPOPJ	;NULL
		REPEAT 4,SETZ CPOPJ	;USER
		REPEAT 2,1000,,CPOPJ	;FOREIGN USER
IFN NUNITS,[
		40000,,UTICL	;UTAPE
		MOVE UTOCLR
		40000,,UTICL
		MOVE UTOCL
		40000,,UTICL
		MOVE UTOCL
]
IFN OLPTP,	REPEAT 2,LPTCLS	;LPT
IFN NLPTP,[
		NLPDCL
		NLPTCL
]
IFN GLPTP, REPEAT 2,GLPCLS
    REPEAT 4,	UTDCLS	;DIRECTORY DEVICE
IFN VIDP,	REPEAT 2,NVDCLS	;NVIDI
IFN PLTP,	REPEAT 2,400,,PLTUSR	;PLOTTER
IFN PTRP,[
    REPEAT 5,	400,,PTPUSR	;PAPER  TAPE PUNCH
]
IFN IMXP,	REPEAT 4,IMPXCL	;IMX
IFN OMXP,	REPEAT 4,OMPXCL	;OMX
		10000,,CLCLRU	;CORE LINK
		CLCLWU
    REPEAT 2,[
		10000,,CLCLRB
		CLCLWB
    ]
IFN PTRP,[
    REPEAT 5,	PTRCLS	;PAPER TAPE READER
]
IFN 340P,[
    REPEAT 4,	ADCL1	;340
]
;		ADCL1		;IDS
IFN CODP,[
    REPEAT 2,	CODCLS		;CODE DEV
]
		200,,QICL	;2311
		2200,,QOCLR
		200,,QICL
		2200,,QOCL
		200,,QICL
		2200,,QOCL
IFN VIDP,	REPEAT 4,TVCCLS	;TVC
IFN PDP6P,	REPEAT 4,100,,PDPCLS	;USR IN PDP10 MODE
IFN TABP,	REPEAT 2,400,,TABUSR	;TABLET
IFN NMTCS,[REPEAT 4,MTICL
	REPEAT 4,MTOCL
]		;MAGTAPE
	REPEAT 3,[
	100000,,JOBCLS	;JOB DEVICE
	40,,JOBCLS
]
	REPEAT 6,4000,,BOJCLS	;BOJ
	[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
	CPOPJ	;SPY
	REPEAT 2,[	;PSEUDO TTY
	20,,STYICL
	20,,STYOCL
]
IFN NETP,	REPEAT 4,NETCLS
IFN MSPP,	MSCLOS	;MESS SWITCHER (DM)
IFN STKP,	STKCLS	;STANFORD KEYBOARD

IF2,IFN .-CLSTB-LIOTTB,.ERR BARF AT CLSTB

;DISPATCH TABLE FOR .IOT UUO
;TRANSFERED THROUGH USING RIGHT HALF OF I/O CHANNEL WORD AS AN INDEX
%IOTBK==400000	;4.9 = 1 => BLOCK  = 0 => UNIT
%IOTOT==200000	;4.8 = 1 => OUTPUT  = 0 => INPUT     "
%IOTBP==100000	;4.7 = 1 => THERE IS A SPECIAL ROUTINE FOR SIOT,
		 ;AND ITS ADDRESS IS -1 + RH(IOTTB WORD).
%IOTSP==40000	;4.6 => THIS DEVICE IS FUNNY. SIOT ISN'T ALLOWED,
		 ;AND IOT LETS THE DEVICE RTN DO ALL THE WORK.
		;PRESENT ONLY FOR UNIT INPUT MODES.

%IOTBO==600000	;BLOCK OUTPUT
%IOTUI==000000	;UNIT INPUT.

IOTTB:		%IOTSP,,IOCER8
	OFFSET -IOTTB
TYIDN::		%IOTUI,,TYI	;TTY ENTRIES MUST BE COMPACT
TYIBN::		%IOTBK,,TTYBI
TYODN::		%IOTOT,,TYO (%IOTBP)
TYOBN::		%IOTBO,,TTYBO	;LAST TTY DEVICE
NLIDN::		%IOTUI,,NULI
NLBIDN::	%IOTBK,,NULBI
NLODN::		%IOTOT,,CPOPJ
NLBDN::		%IOTBO,,NULBOD
UWIDN::		%IOTUI,,UWI
UWODN::		%IOTOT,,UWO
UBODN::		%IOTBO,,UBO
UBIDN::		%IOTBK,,UBI
FUWIDN::	%IOTUI,,UWI	;FOREIGN USER, CLSTB POSITIVE
FUBIDN::	%IOTBK,,UBI
IFN NUNITS,[
DNUACII::	%IOTUI,,UASCII
DNUACCO::	%IOTOT,,UASCCO
DNUBKI::	%IOTBK,,UBLKI
DNUBKO::	%IOTBO,,UBLKO
DNUDTI::	%IOTUI,,UDATAI
DNUDTO::	%IOTOT,,UDATAO
]
IFN OLPTP,[
LPTDN::		%IOTOT,,PILPT1
LPTBN::		%IOTBO,,BLPTO
]
IFN NLPTP,[
NLPTDN::	%IOTOT,,NLPT1
NLPTBN::	%IOTBO,,BNLPTO
]
IFN GLPTP,[
GLPTDN::	%IOTOT+%IOTBP,,GLPTDO
GLPTBN::	%IOTBO,,GLPTBO
]
DIRCHN::	%IOTUI,,DIRCH
DIRBN::		%IOTBK,,DIRB
NDATAI::	%IOTUI,,DDATAI
NBLKI::		%IOTBK,,DBLKI
IFN VIDP,[
NVIDOP::	%IOTSP,,NVIDIT
BNVIDO::	%IOTBK,,BNVIDI
]
IFN PLTP,[
PLTDN::		%IOTOT,,PLOT
PLTBN::		%IOTBO,,BPLOT
]
IFN PTRP,[
PTPI::		%IOTOT,,PIPUN
PTPA::		%IOTOT,,APIPUN
PTPB::		%IOTBO,,BPIPUN
PTPWA::		%IOTOT,,WAPIPN
PTPWB::		%IOTBO,,WBPIPN
]
IFN IMXP,[
IMPXDN::	%IOTSP+%IOTUI,,IMPXS
IMXDN::		%IOTSP+%IOTUI,,IMPXS1
BIMXDN::	%IOTSP+%IOTBK,,BIMXS1
BIMPXD::	%IOTSP+%IOTBK,,BIMPXS
]
IFN OMXP,[
OMPXDN::	%IOTSP+%IOTOT,,OMPXS
OMXDN::		%IOTSP+%IOTOT,,OMXDS
BOMXDN::	%IOTSP+%IOTBO,,BOMXDS
BOMPXD::	%IOTSP+%IOTBO,,BOMPXS
]
DCLUAI::	%IOTUI,,CLUAI
DCLUAO::	%IOTOT,,CLUAO
DCLBI::		%IOTBK,,CLBI
DCLBO::		%IOTBO,,CLBO
DCLUBI::	%IOTUI,,CLUBI
DCLUBO::	%IOTOT,,CLUBO
IFN PTRP,[
REDUAI::	%IOTUI,,PTRUAI
REDBAI::	%IOTBK,,PTRBAI
REDUII::	%IOTUI,,PTRUII
REDBII::	%IOTBK,,PTRBII
REDUTI::	%IOTUI,,PTRUTI
]
IFN 340P,[
DN340B::	%IOTBO,,340B	;340 ENTRIES MUST BE COMPACT; BLOCK FIRST, THEN UNIT
DN340W::	%IOTSP+%IOTOT,,340W
DN340C::	%IOTSP+%IOTOT,,340C
DN340H::	%IOTSP+%IOTOT,,340H
;DN340I::	%IOTSP+%IOTOT,,340I
DN340L::	;LAST 340 DEVICE ENTRY
]
IFN CODP,[
CODDN::		%IOTOT,,SEND
CODBN::		%IOTBO,,BSEND
]
DQUAI::		%IOTUI+%IOTBP,,QUAI
DQUAO::		%IOTOT+%IOTBP,,QUAO
DQBI::		%IOTBK,,QBI
DQBO::		%IOTBO,,QBO
DQUII::		%IOTUI+%IOTBP,,QUII
DQUIO::		%IOTOT+%IOTBP,,QUIO
IFN VIDP,[
DNVDIU::	%IOTSP+%IOTUI,,RNVDIU
DNVDIB::	%IOTSP+%IOTBK,,RNVDIB
DNVDOU::	%IOTSP+%IOTOT,,RNVDOU
DNVDOB::	%IOTSP+%IOTBO,,RNVDOB
]
IFN PDP6P,[
PDPUIO::	%IOTOT,,UWO	;BUT JOB WILL BE -1 TO INDICATE PDP6
PDPBIO::	%IOTBO,,UBO
PDPUII::	%IOTUI,,UWI
PDPBII::	%IOTBK,,UBI
]
IFN TABP,[
DTABUI::	%IOTUI,,UTABI
DTABBI::	%IOTBK,,BTABI
]
IFN NMTCS,[
MTUAIX::	%IOTUI,,MTUAI	;MAGTAPE
MTUIIX::	%IOTUI,,MTUII
MTBIX::		%IOTBK,,MTBI
MTCKIX::	%IOTBK,,MTCKI
MTUAOX::	%IOTOT,,MTUAO
MTUIOX::	%IOTOT,,MTUIO
MTBOX::		%IOTBO,,MTBO
MTCKOX::	%IOTBO,,MTCKO
]
JDUAI::		%IOTUI,,JBUAI
JDUAO::		%IOTOT,,JBUAO
JDBI::		%IOTBK,,JBBI
JDBO::		%IOTBO,,JBBO
JDUII::		%IOTUI,,JBUII
JDUIO::		%IOTOT,,JBUIO
BDUAI::		%IOTUI,,BJUAI
BDUAO::		%IOTOT,,BJUAO
BDBI::		%IOTBK,,BJBI
BDBO::		%IOTBO,,BJBO
BDUII::		%IOTUI,,BJUII
BDUIO::		%IOTOT,,BJUIO
IIOPOP::		[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
ISPY::		%IOTUI,,SPYI
STYDUI::	%IOTUI,,STTYI	;PSEUDO TTY
STYDUO::	%IOTOT,,STTYW
STYDBI::	%IOTBK,,STTBI
STYDBO::	%IOTBO,,STTBO
IFN NETP,[
NETDUI::	%IOTUI,,NETI
NETDUO::	%IOTOT,,NETW
NETDBI::	%IOTBK,,NETBI
NETDBO::	%IOTBO,,NETBO
]
IFN MSPP,[
MSPIO::		IOCR10
]
IFN STKP,[
STKDP::		STKI
]
	OFFSET 0
LIOTTB==.-IOTTB

;.STATUS CH,LOC	;STORE IN LOC THE STATUS OF CHANNEL CH
		;AND OF THE DEV OPEN ON IT IF ANY
;
ASTATUS:	PUSHJ P,STDUUO	;SET UP AC'S
ASTAT1:	LDB D,[300600,,STATB(B)]	;PICK UP SYS PERIPHERAL DEV NUM IF PRESENT IN STATB
	PUSHJ P,@STATB(B)	;CALL ROUTINE TO COMPUTE DEVICE STATUS
	HLL D,IOCHST-IOCHNM(R)	;PICK UP CHANNEL STATUS
	TLZ D,740000	;TURN OFF BITS USED TO STORE CH NUM INFO ON I/O PDL
	XCTR XW,[MOVEM D,(C)]	;GIVE TO USER
	POPJ P,

NSTATUS:	HLRZ A,H	;NEW SYSTEM CALL "STATUS"; H HAS IOCHNM WORD CONTENTS.
	LDB D,[300600,,STATB(H)]
	PUSHJ P,@STATB(H)
	HLL D,IOCHST-IOCHNM(R)
	TLZ D,740000
	MOVE A,D
	JRST POPJ1

STATB:			CPOPJ
		REPEAT 2,STATYI
		REPEAT 2,STATYO
		REPEAT 4,SNNUL_6,,STDSTA
		REPEAT 4,SNUSR_6,,CPOPJ
		REPEAT 2,SNFUSR_6,,CPOPJ
IFN NUNITS,	REPEAT 6,SNUTC_6,,CPOPJ
IFN OLPTP,	REPEAT 2,SNLPD_6,,STALPT
IFN NLPTP,	REPEAT 2,SNLPV_6,,STDSTA
IFN GLPTP,	REPEAT 2,SNLPV_6,,STDSTA
		REPEAT 4,SNDIR_6,,CPOPJ
IFN VIDP,	REPEAT 2,SNBAT_6,,CPOPJ
IFN PLTP,	REPEAT 2,SNPLT_6,,STDSTA
IFN PTRP,	REPEAT 5,SNPTP_6,,STDSTA
IFN IMXP,	REPEAT 4,SNIMPX_6,,STDSTA
IFN OMXP,	REPEAT 4,SNOMPX_6,,STDSTA
		REPEAT 3,[SNCLK_6,,CLISTA	;CORE LINK INPUT
			 SNCLK_6,,STDSTA	;CORE LINK OUTPUT
		]
IFN PTRP,	REPEAT 5,SNPTR_6,,STDSTA
IFN 340P,	REPEAT 4,SN340_6,,CPOPJ
;IFN 340P,	SN340I_6,,CPOPJ
IFN CODP,	REPEAT 2,SNCOD_6,,STDSTA	;CODE
		REPEAT 6,SN2311_6.,,CPOPJ
IFN VIDP,	REPEAT 4,SNBAT_6,,CPOPJ
IFN PDP6P,	REPEAT 4,SNPDP_6,,CPOPJ
IFN TABP,	REPEAT 2,SNTAB_6,,CPOPJ
IFN NMTCS,	REPEAT 8,SNMTC_6,,STAMTC	;MAGTAPE
		REPEAT 6,SNJOB_6,,JBSTAT
		REPEAT 6,SNBOJ_6,,CPOPJ
			 [JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
			 SNSPY_6,,CPOPJ
		REPEAT 2,[SNSTY_6,,STASTI	;PSEUDO-TTY.
			 SNSTY_6,,STASTO ? ]
IFN NETP,	REPEAT 4,SNNET_6,,STANET
IFN MSPP,	SNMSP_6,,CPOPJ
IFN STKP,	SNSTK_6,,CPOPJ

IF2,IFN LIOTTB-.+STATB,.ERR BARF AT STATB

;.RESET CH,	;RESET BUFFERED INFO ON CHANNEL CH
		;NOT IMPLEMENTED FOR MANY DEVICES
		;HAS SPECIAL EFFECTS ON "USR" DEVICE
;
NRESET:	HRRZ A,H
	AOSA (P)
ARESET:	 HRRZ A,(R)	;PICK UP INDEX FROM I/O CH WORD
	SKIPA T,[HRRZ T,RSTB1(A)]	;.RESET USES RH OF TABLE
AIOPP1:	 MOVE T,[HLRZ T,RSTB1(A)]	;.IOPUSH, .IOPOP USE LH OF TABLE
	IDIVI A,7	;TABLE IS IN 5-BIT BYTES TO SAVE SPACE
	ADD A,[440500,,RSTB]
	IBP A
	SOJGE B,.-1
	LDB A,A		;GET BYTE FROM TABLE
	XCT T		;GET REAL TABLE ENTRY IN T
	JRST (T)	;DISPATCH

RSTB1:	CPOPJ,,CPOPJ	;0
	TYIIOP,,TYIRS	;1
	TYOIOP,,TYORS	;2
	CPOPJ,,USRST	;3
	CPOPJ,,JBIRS	;4
	CPOPJ,,JBORS	;5
	IIOPPR,,[JRST 4,CPOPJ]	;6
	STYIIP,,STYIRS	;7
	STYOIP,,STYORS	;10
	OFFSET -RSTB1	;OPTIONAL DEVICES BEGIN HERE
IFN OLPTP, %%LPT:: CPOPJ,,LPTRS
IFN NLPTP, %%NLP:: CPOPJ,,NLPTRS
IFN PLTP,  %%PLT:: CPOPJ,,PLTRS
IFN PTRP,  %%PTR:: CPOPJ,,PTRRS
IFN PTRP,  %%PTP:: CPOPJ,,PUNCLR
IFN IMXP,  %%IMX:: CPOPJ,,IMPXRS
IFN 340P,  %%340:: CPOPJ,,DSIZAP
IFN CODP,  %%COD:: CODIOP,,CODRS
IFN PDP6P, %%PDP:: PDPIOP,,PDPRST
IFN TABP,  %%TAB:: CPOPJ,,TABCLR
IFN NETP,  %%NET:: NETIOP,,NETRS
IFN STKP,  %%STK:: CPOPJ,,STKRS
	OFFSET 0

RSTB:	.BYTE 5

			0	;CHNL NOT OPEN
		REPEAT 2,1	;TTY INPUT
		REPEAT 2,2	;TTY OUTPUT
		REPEAT 4,0	;NUL DEVICE
		REPEAT 4,3	;USR DEVICE
		REPEAT 2,0	;FOREIGN USR
IFN NUNITS,	REPEAT 6,0	;DEC TAPE
IFN OLPTP,	REPEAT 2,%%LPT
IFN NLPTP,	REPEAT 2,%%NLP
IFN GLPTP,	REPEAT 2,0
		REPEAT 4,0	;DIR "DEVICE"
IFN VIDP,	REPEAT 2,0
IFN PLTP,	REPEAT 2,%%PLT
IFN PTRP,	REPEAT 5,%%PTP
IFN IMXP,	REPEAT 4,%%IMX
IFN OMXP,	REPEAT 4,0
		REPEAT 6,0	;CORE LINK.
IFN PTRP,	REPEAT 5,%%PTR
IFN 340P,	REPEAT 4,%%340
;IFN 340P,		0
IFN CODP,	REPEAT 2,%%COD	;CODE
		REPEAT 6,0	;DISK
IFN VIDP,	REPEAT 4,0
IFN PDP6P,	REPEAT 4,%%PDP	;PDP-6 DEVICE
IFN TABP,	REPEAT 2,%%TAB
IFN NMTCS,	REPEAT 8,0	;MAGTAPE
		REPEAT 3,[4
			  5
		]		;JOB
		REPEAT 3,[0	;BOJ INPUT
			  0	;BOJ OUTPUT
		]		;BOJ
			6	;INTERRUPT ON IOPOP DEVICE
			0	;SPY
		REPEAT 2,7	;PSEUDO-TTY
		REPEAT 2,10	;"
IFN NETP,	REPEAT 4,%%NET	;NET RESET INR/INS
IFN MSPP,		0	;MS SWITCH HACK
IFN STKP,		%%STK	;STANFORD KEYBOARD

IF2,IFN LIOTTB-.BYTC,.ERR BARF AT RSTB
	.BYTE
EXPUNGE %%LPT,%%NLP,%%PLT,%%PTR,%%PTP,%%IMX,%%340,%%COD,%%PDP,%%TAB,%%NET,%%STK

DEFINE DVHR X,Y
X!Y!TERMIN

DEFINE DV A,B/
	B
DVHR [DEFINE DVHR X,Y
X!][A
Y!TERMIN]
TERMIN

;DEVICE TABLES FOR AOPEN
;
;IN EACH ENTRY:
 %DVIN==400000	;4.9 DEVICE CAN DO INPUT
 %DVOUT==200000	;4.8 DEVICE CAN DO OUTPUT
 %DVDIR==100000	;4.7 DEVICE CAN GIVE DIRECTORY
 %DVDEL==40000	;4.6 IGNORE DELETE/RENAME (SKIP)
 %DVLNK==20000	;4.5 ALLOW MLINK
		;RIGHT HALF, SIXBIT DEVICE NAME
%DV==1,,520000	;BIT TYPEOUT MASK

DEVTAB:
IFN NLPTP,	DV NLPTO,%DVOUT+%DVDEL,,'LPT
IFG OLPTP-NLPTP,DV LPTO,%DVOUT+%DVDEL,,'LPT
IFG LPTP-1,	DV LPTO,%DVOUT+%DVDEL,,'OLP
IFN GLPTP,	DV GLPTO,%DVOUT+%DVDEL,,'LPT
IFN TTLPTP,	DV LPTO,%DVOUT+%DVDEL,,'LPT

		DV QSKO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'DSK
		DV TTYO1,%DVIN+%DVOUT+%DVDIR+%DVDEL,,'TTY
		DV NULO,%DVIN+%DVOUT+%DVDEL,,'NUL
		DV USRO,%DVIN+%DVOUT+%DVDEL,,'USR
IFN VIDP,	DV NVIDI,%DVIN+%DVOUT+%DVDEL,,'NVD
		DV SYSO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'SYS
IFN NETP,	DV NETO,%DVIN+%DVOUT+%DVDEL,,'NET
IFN MSPP,	DV IPCO,%DVIN+%DVOUT+%DVDEL,,'IPC
		DV STTYO,%DVIN+%DVOUT+%DVDEL,,'STY	;PSEUDO TTY
		DV JOBO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'JOB
		DV BOJO,%DVIN+%DVOUT+%DVDEL,,'BOJ
		DV JOBO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'OJB
MCHNIRP MCHN,[
IFE MCOND MCHN, DV QSKO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,(SIXBIT/MCHN/)	;THIS MACHINE.
.ELSE		DV MLGO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,(SIXBIT/MCHN/)	;OTHER MACHINES.
]
IFN STKP,	DV STKO,%DVIN+%DVDEL,,'STK
IFN PLTP,	DV PLOTO,%DVOUT+%DVDEL,,'PLT
IFN PLTP,	DV IPLO,%DVOUT+%DVDEL,,'IPL	;INTERPRETED PLOTTER
IFN XGP,	DV XPLO,%DVOUT+%DVDEL,,'XPL
IFN IMXP,	DV IMPXO,%DVIN+%DVDEL,,'IMX
IFN OMXP,	DV OMPXO,%DVOUT+%DVDEL,,'OMX
IFN PTRP,	DV PTRO,%DVIN+%DVDEL,,'PTR
IFN PTRP,	DV PTPO,%DVOUT+%DVDEL,,'PTP
IFN 340P,	DV DISO,%DVOUT+%DVDEL,,'DIS	;340 AS OUTPUT DEVICE
;IFN 340P,	DV IDISO,%DVOUT+%DVDEL,,'IDS	;340 AS INTERPRETED DISPLAY
		DV CLUO,%DVIN+%DVOUT+%DVDIR,,'CLU
		DV CLOO,%DVIN+%DVOUT+%DVDIR,,'CLO
		DV CLIO,%DVOUT,,'CLI
		DV CLAO,%DVIN,,'CLA
		DV COMO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'COM
IFN CODP,	DV CODO,%DVIN+%DVOUT+%DVDEL,,'COD
IFN VIDP,	DV TVCO,%DVIN+%DVOUT+%DVDEL,,'TVC
		DV ERRO,%DVIN+%DVDEL,,'ERR
IFN TPLP+TTLPTP&DEMON, DV TPLO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,'TPL
IFN TABP,	DV TABO,%DVIN+%DVDEL,,'TAB
		DV SPYO,%DVIN+%DVOUT+%DVDEL,,'SPY
		DV CORO,%DVIN+%DVDIR+%DVDEL,,(SIXBIT /COR/)	;DIR=LAST LINE OF TTY^F

NDEVS==.-DEVTAB

DVT1:		DV TTYO,%DVIN+%DVOUT+%DVDIR+%DVDEL,,(SIXBIT /TY/)
		DV TTYO,%DVIN+%DVOUT+%DVDIR+%DVDEL,,(SIXBIT /T/)
IFN NUNITS,	DV UTO,%DVIN+%DVOUT+%DVDIR,,(SIXBIT /UT/)
		DV STTYOA,%DVIN+%DVOUT+%DVDEL,,(SIXBIT /ST/)
		DV STTYOA,%DVIN+%DVOUT+%DVDEL,,(SIXBIT /S/)
		DV QSKUO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,(SIXBIT /DK/)	;PARTICULAR UNIT
		DV QSKPO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,(SIXBIT /P/)	;PARTICULAR PACK
		DV QSKPO,%DVIN+%DVOUT+%DVDIR+%DVLNK,,(SIXBIT /PK/)	;PARTICULAR PACK
IFN NMTCS,	DV MAGTO,%DVIN+%DVOUT+%DVDEL,,(SIXBIT /MT/)	;MAGTAPE

NDV1==.-DVT1
EDEVS==.-1	;END FOR GETSYS (DEVS)

DEVADR:	DVHR
IFN .-DEVADR-NDEVS-NDV1,.ERR DVHR LOST

SUBTTL .OPER, .CALL DISPATCH

AOPER:	MOVE J,R	;AC FIELD OF UUO
	ADDI R,IOCHNM(U)	;SET UP IO CHANNEL REFERENCE POINTER
	CAIL C,MXOPR	;SKIP IF UUO E FIELD IS LESS THAN MAX OPR
	JRST ILUUO	;ILLEGAL OPER
	JRST @OPRDSP(C)	;LEGAL OPER-- DISPATCH ON E FIELD OF UUO

OPRDSP:	ILUUO
	OPRIRP A!X	;AITYI,ALISTEN,ASLEEP,ETC.

;
;CALL DISPATCH
;
ACALL:	MOVE B,C	;SET UP COPY OF ERR ADR NOT TO BE RELOCATED
	JRST @CALDIS(R)	;DISPATCH INDEX OF UUO'S AC FIELD

CALDIS:	ASYSC
	ADISMIS
	ILUUO
	ATRANAD
	AVALRET	;4
	AUTRAN
	UACORE
	ATRNDL
	ADSTART	;10
	AFDELE
	ADSTL
	ASUSET
	ALTPEN	;14
	AVSCAN
	APOTSET
REPEAT 20-.+CALDIS,ILUUO

SUBTTL MISCELLANEOUS UUO'S

;SHUT DOWN SYSTEM

ASHUTD:	XCTR XR,[MOVE C,(J)]	;TIME TO DOWN IN THIRTIETHS
	JUMPL C,AREVIV	;GO DOWN IN NEGATIVE TIME => REVIVE.
	ADD C,TIME	;GET TIME AT WHICH DOWN
	PUSHJ P,SWTL
	SHUTLK
	SKIPGE SHUTDN	;SKIP UNLESS ALREADY DOWN
	 JRST LSWPOP
	PUSHJ P,CLQDEL
	DEDBLK
	MOVEM C,SHUTDN	;SET TIME TILL DEATH
	SUB C,TIME
	LSH C,1
	MOVEM C,DEDTIM
	PUSHJ P,DEATHX
	JRST 4,.
	JRST LSWPJ1

;READ TIME TILL SYSTEM DOWN

ADIETI:	XCTR XW,[SETOM (J)]	;READ -1 IF NOT GOING DOWN
	SKIPG A,SHUTDN
	POPJ P,		;NOT DYING
	SUB A,TIME
	JRST APTUAJ	;GIVE TO USER

;REVIVE SYS

AREVIV:	PUSHJ P,SWTL
	    SHUTLK
	SKIPN SHUTDN
	 JRST LSWPOP	;NOT DYING
	PUSHJ P,CLQDEL
	 DEDBLK
	SETZM SHUTDN
	SETZM DEDTIM
	PUSHJ P,DEATHM
	JRST LSWPOP

;FROM CLOCK QUEUE BLOCK

DEATHZ:	PUSHJ P,DEATHX
	SKIPA
	JRST CLQRET
	MOVSI T,SCLOUT
	PUSHJ P,SUPSET	;DIE
	SETOM DEDTIM
	JRST CLQRET

;GET VARIOUS SYS STATUS

ASSTAT:	CONO PI,CLKOFF
	SKIPLE A,SHUTDN
	SUB A,TIME
	SKIPG SHUTDN
	SUBI A,1	;TIME TILL DOWN IF > 0,  -1 IF UP,  -2 IF DOWN
	CONO PI,CLKON
	MOVE B,SYSDBG
	MOVE C,SUSRS
	MOVE D,PARERR
	ADD D,NXMERR
	MOVE E,TIME
	MOVE TT,[MNAME SIXBIT/,/]	;SIXBIT NAME OF THIS MACHINE.
	MOVE I,[.FNAM2]
	JRST POPJ1

SUBTTL SYMBOLIC SYSTEM CALL HANDLER

;IN ORDER @A...Z[\]^_ !".../0...9:;,=.? (THAT IS IN NUMERICAL ORDER)

SYSCTB:	SIXBIT /ACCESS/	;IOCHNL, ADR
	SIXBIT /ATTACH/
	SIXBIT /BREAK/	;. . .
	SIXBIT /CALL/	;SIXBIT /<NEXT CALL>/
	SIXBIT /CLOSE/	;IOCHNL
	SIXBIT /CNSGET/	;GET SEMIPERMANENT TTY INFO
	SIXBIT /CNSSET/	;SET SAME. (TCMXH, TCTYP, TTYOPT, TTYCOM, ETC)
	SIXBIT /CORBLK/	;HACK PAGE MAP
	SIXBIT /CORTYP/	;READ STATUS OF PAGE.
	SIXBIT /CREAPB/	;CLEAR THE DO NOT REAP BIT
	SIXBIT /DELETE/	;FILE DELETE
IFN DEMON,SIXBIT /DEMSIG/	;SIGNAL DAEMON
	SIXBIT /DETACH/	;DISOWN ENTIRE TREE
	SIXBIT /DIRSIZ/
	SIXBIT /DISMIS/
	SIXBIT /DISOWN/	;DISOWN AN INFERIOR JOB
	SIXBIT /DSKUPD/	;SIMULATE REFERENCE OF FILE
	SIXBIT /FILBLK/ ; READ NAME AREA OF FILE
	SIXBIT /FILLEN/ ;READ FILE LENGTH
	SIXBIT /FLAP/	;TAPE #
	SIXBIT /IOPOP/
	SIXBIT /IOPUSH/
	SIXBIT /IOT/	;IOCHNL, QUAN OR BLK POINTER
	SIXBIT /ITYIC/
	SIXBIT /JOBCAL/	;GENERAL JOBGET
	SIXBIT /JOBGET/	;JOB CHNL
	SIXBIT /JOBINT/	;JOB CHNL
	SIXBIT /JOBRET/	;JOB CHNL
	SIXBIT /JOBSTS/	;SET JOB CHNL STATUS
IFN KL10P,SIXBIT /KLPERF/ ;ACTIVATE & CONTROL PERFORMANCE METER
	SIXBIT /LISTEN/	;IOCHNL, ADR
	SIXBIT /LOAD/	;USER CH, I/O CH, VARBLK
	SIXBIT /LOGIN/	;SIXBIT /<NAME>/
	SIXBIT /LOGOUT/	;. . .
	SIXBIT /MLINK/	;MAKE LINK
	SIXBIT /NETBLK/	;HANG ON NCP STATE
	SIXBIT /NETHST/	;GETS STATUS OF HOST
	SIXBIT /NETIMP/	;GETS STATUS OF IMP
	SIXBIT /OPEN/	;FILE OPEN
	SIXBIT /PAGEID/	;VIRT. PAGE NO., ID, STATUS
	SIXBIT /PDUMP/	;USER CH, I/O CH, VARBLK
	SIXBIT /PGDUMP/	;DUMP PAGE OUT OF CORE
IFE MCOND DM,	SIXBIT /RAUTH/	;READ AUTHOR OF FILE
	SIXBIT /RCPOS/	;READ CURSOR POS
IFN DEMON,SIXBIT /RDDMST/	;READ DEAMON STATUS
	SIXBIT /RDMPBT/	;READ FILE DUMPED BIT IOCHN, ADR
	SIXBIT /RELOAD/
	SIXBIT /RENAME/	;FILE RENAME
	SIXBIT /RENMWO/	;RENAME WHILE OPEN
	SIXBIT /RESET/
	SIXBIT /RESRDT/	;RESTORE REFERENCE DATE
	SIXBIT /RFDATE/	;READ TIME OF CREATION OF FILE IOCHN, ADR
	SIXBIT /RFNAME/	;READ OPENED FILENAMES & ACCESS POINTER
	SIXBIT /RQDATE/	;READ DSK DATE
	SIXBIT /RSSIZE/	;READ SCREEN SIZE
IFE MCOND DM,	SIXBIT /SAUTH/	;SET AUTHOR OF FILE
	SIXBIT /SCML/	;SET # COMMAND LINES
	SIXBIT /SCPOS/	;SET TTY CURSOR POSITION
	SIXBIT /SDMPBT/	;SET FILE DUMPED BIT IOCHN, ADR
	SIXBIT /SETIOC/	;CAUSE IO CHANNEL ERROR IN JOB/BOJ CHANNEL
	SIXBIT /SFDATE/	;SET TIME OF CREATION OF FILE IOCHN, ADR
	SIXBIT /SIOT/	;IOT A STRING GIVEN B.P. AND LENGTH
	SIXBIT /SRDATE/ ;SET REFERENCE DATE
	SIXBIT /SREAPB/	;SET THE DO NOT REAP BIT
	SIXBIT /SSTATU/	;READS VARIOUS SYSTEM STATUS
	SIXBIT /STATUS/
IFN DEMON,SIXBIT /STDMST/	;SET DEAMON STATUS
	SIXBIT /STYGET/	;GET INFO ABOUT SPECIFIED STY
	SIXBIT /T11MP/	;TEMP ? TEN11 HACKER
	SIXBIT /TRANAD/	;CREATE TRANSLATION ENTRY
	SIXBIT /TRANCL/	;CLEAR TRANSL. LIST(S) FOR A JOB.
	SIXBIT /TRANDL/	;DELETE A TRANSL. ENTRY.
	SIXBIT /TRANEX/	;READ A JOB'S TRANSL. LIST.
	SIXBIT /TRANS/	;TRANSLATE A FILENAME.
	SIXBIT /TTYGET/	;SUPPLY TTY CH, RETURNS THREE WORDS OF TTY STATUS
	SIXBIT /TTYSET/	;SUPPLY TTY CH AND THREE WORDS OF TTY STATUS
	SIXBIT /TVWHER/
	SIXBIT /VIDBUF/	;ASSIGN/DEASSIGN VIDEO BUFFER.
	SIXBIT /VIDSW/	;SET VIDEO SWITCH.
	SIXBIT /WHOLIN/	;GET OR SET WHO-LINE MODE AND JOB.
	SIXBIT /XGPIM/	;OUTPUT TO XGP IN IMAGE MODE

ZZ==.-SYSCTB-1
RADIX 2
ZZ2==CONC [.LENGTH /]\ZZ,/
RADIX 8
REPEAT 1_<ZZ2>-ZZ-1,377777,,-1
;4.X BIT IMPLIES SUPPLY ROUTINE WITH POINTER TO X'TH ARG, NOT ARG ITSELF
;3.9-3.7 = MINIMUM NUMBER OF ARGS
;3.1 => DECODE 1ST ARG AS IO CHNL, LEAVING IOCHNM WD ADDR IN RH(R),
; IOCHNM WD CONTENTS IN H, CLSTB ENTRY'S LH IN LH(R).
;3.2 => NEVER PASS TO SPECIAL CHECKER FOR JOB CHNL
;3.3 => DON'T BARF IF CHNL NOT OPEN, CALLED ROUTINE WILL HANDLE IT

;# ARGS ACTUALLY SUPPLIED IN W WHEN DISPATCHING THRU SYSCTD, ARGS IN A...J
SYSCTD:	200,,NACCES
	100,,NATTAC
	ABREAK
	100,,NCALL
	100,,NCLOSE(7)
	100,,NCNSGET
	100,,NCNSSET
	24300,,NCORBL
	100,,NCORTY
	100,,ACREAP(1)
	300,,NDEL
IFN DEMON,100,,ADEMSIG
	NDETAC
	100,,NDIRSIZ(1)
	1100,,NDISMIS
	100,,NDISOWN
	100,,ADSKUP(1)
	100,,NFILBLK(1)
	100,,NFILLEN(1)
IFN NUNITS,	100,,NFLAP
IFE NUNITS,	100,,OPNL1
	100,,NIOPOP(7)
	100,,NIOPUS(7)
	2200,,NIOT(7)	;(7) FOR CHNL NOT OPEN TO BE IOC ERROR, (3) TO BE OPEN LOSS
	100,,NITYIC
	100,,NJBCL(1)
	100,,NJBGT(1)
	100,,NJBINT(1)
	100,,NJBRT(1)
	100,,NJBSTS(1)
IFN KL10P,200,,KLPERF
	100,,NLISTE
	200,,NLOAD
	200,,NLOGIN
	ALOGOU
	700,,NMLINK
	4200,,ANETBLK(1)
	100,,ANETHST
	ANETIMP
	200,,NOPEN
	200,,APGID
	4300,,PDUMP
	100,,APGDUM
IFE MCOND DM,	100,,ARAUTH(1)
	100,,ARCPOS
IFN DEMON,100,,ARDDMST
	100,,NRDMPBT(1)
	100,,NRELOAD
	600,,NRNAM
	300,,NRNWO
	100,,NRESET(7)
	100,,NRESRDT(1)
	100,,NRFDATE(1)
	100,,NRFNAME(7)
	ARQDAT
	100,,ARSSIZ
IFE MCOND DM,	200,,ASAUTH(1)
	200,,ASCML
	100,,NSCPOS
	200,,NSDMPBT(1)
	200,,NSTIOC(1)
	200,,NSFDATE(1)
	6300,,NSIOT(7)	;(7) FOR IOC ERROR IF CHNL NOT OPEN, (3) FOR OPEN LOSS
	200,,NSRDATE(1)
	100,,ASREAP(1)
	ASSTAT
	100,,NSTATUS(7)
IFN DEMON,100,,ASTDMST
	100,,NSTYGT
	200,,NT11M
	300,,NTRNAD
	100,,NTRNCL
	200,,NTRNDL
	200,,NTRNEX
	100,,NTRNS
	100,,ATTYGT
	300,,ATTYST
	100,,NTVWHERE
	100,,NVDBF
	200,,NVIDSW
	100,,NWHOLI
	1100,,NXGPIM

IFN .-SYSCTD-1-ZZ,.ERR NEW SYS CALL DISPATCH LOSES!!!

REPEAT 1_<ZZ2>-ZZ-1,ILUUO

;.CALL ADR1  SKIPS UNLESS SOMETHING WRONG
;ADR1:	SETZ
;	SIXBIT /<CALL NAME>/
;	REPEAT #ARGS,BITS,, <ADDRESS OF ARGUMENT>
;	BITS=	4.9 => LAST ARG
;		4.3 - 4.1 0 = NORMAL ARG
;			  1 = IMMEDIATE
;			  2 = OUTPUT ARG
;			  3 = RETURN THE FAILURE CODE IF FAIL
;			  4 = WORD OF CONTROL BITS
;			  5 = IMMEDIATE CONTROL BITS

ASYSC:	PUSHJ P,ASCGRG	;B HAS E OF UUO
	 JRST OPNL43	;CALL NAME UNKNOWN.
	 JRST OPNL15	;MORE THAN 8 ARGS
	 JRST OPNL30	;TOO FEW ARGS
	PUSHJ P,ASYSC1	;DISPATCH TO ROUTINE.
	 POPJ P,	;NO SKIP - OPENL HAS ALREADY BEEN CALLED.
	AOS (P)		;SKIP - PROPAGATE THE SKIP UP THE PDL
	SKIPL SYSCVL(U) .SEE %SCVOT	;AND IF THE USER WANTS OUTPUT VALUES,
	 POPJ P,
	JRST SYSCPT	;GIVE THEM TO HIM.

ASYSC1:	MOVE T,SYSCTD(H)
	TLNN T,1	;DECODE 1ST ARG AS IO CHNL?
	 JRST (T)	;NO, DISPATCH TO CALL.
	TLNE T,2	;OK TO GIVE TO JOB CHNL CHECKER?
	JRST CHNDCD	;NO - GO DECODE CHANNEL
	HRL J,T		;SAVE DISPATCH ADDR
	HRRI T,AIOCAL	;MAKE DECODER RETURN TO CHECK FOR JOB DEVICE

;JSP T,HERE TO DECODE IO CHNL IN A, MODIFIERS IN 3.1-3.3 OF T.
;IF RH(T) = AIOCAL, LH(J) IS REAL RETURN ADDRESS.
;RETURNS IOCHNM ADDR IN RH(R), IOCHNM WD CONTENTS IN H, CLSTB BITS IN LH(R)
;CAN POPJ OUT FOR INVALID CHANNEL.
CHNDCD:	TRNE A,-NIOCHN	;IS 1ST ARG A LEGAL CHNL NUM?
	 JRST OPNL14
	HRRZM A,UUAC(U)	;REMEMBER CHNL # FOR IOC ERRORS, ETC.
	MOVEI R,(A)
	ADDI R,IOCHNM(U) ;YES, COMPUTE IOCHNM WD ADDR
	MOVE H,(R)	;RETURN CONTENTS IN H.
	HLL R,CLSTB(H)	;RETURN CLSTB BITS IN LH(R).
	TRNN H,-1	;IF CHNL NOT OPEN
	 TLNE T,4	;AND NOT SPECIALLY OK FOR THIS SYSTEM CALL
	  JRST (T)
	JRST OPNL44	;THEN BARF

;JOB DEVICE CHECKER - PUT AIOCAL IN RH(T), JRST CHNDCD
AIOCAL:	HLRZ T,J		;GET DISPATCH ADR BACK
	TLNN R,100040	;IS CHANNEL JOB DEVICE?
	JRST (T)	;NO - DISPATCH
	HLRZS H		;ISOLATE JOB DEVICE INDEX
	DPB W,[230400,,JBSTS(H)]	;SAVE ARG COUNT
	MOVNS W
	HRLZS W
	HRRI W,1		;NOW HAVE AOBJN PNTR TO DATA
	MOVE T,(W)		;COPY ARGS TO JOB AC TABLES
	MOVEM T,@JBACTB-1(W)
	AOBJN W,.-2
	MOVEI W,10		;SET NON-STANDARD OP-CODE
	HRRM W,JBSTS(H)
	MOVE E,H	;PUT JOB INDEX IN E FOR JBWT
	CONO PI,CLKOFF
	PUSHJ P,JBWT		;WAIT FOR JOB TO ANSWER
	MOVE H,E	;GET JOB INDEX BACK IN H (FOR JBACTB)
	MOVE W,[-8,,1]		;LOAD ANSWERS INTO ACS
	MOVE T,@JBACTB-1(W)
	MOVEM T,(W)
	AOBJN W,.-2
	LDB T,[350400,,JBSTS(H)]	;GET SKIP COUNT
	JUMPN T,POPJ1	;SKIP COUNT NOT ZERO - SKIP
	LDB C,[270600,,JBSTS(H)]	;GET OPEN LOSS CODE
	SKIPE C		;MAKE SURE IN BOUNDS
	CAILE C,NOPNLS
	MOVEI C,22
	JRST OPNL1-1(C)	;GO REPORT LOSSAGE AND DON'T SKIP


NCALL:	MOVE T,A
	MOVE R,[B,,A]
	BLT R,A+6
	SETZM A+7	;MAX 8 ARGS, 1 USED FOR NAME
	SOS W
	PUSHJ P,ASCRCH
	 JRST OPNL43
	MOVEI J,ASYSC+2	;LOOK LIKE PUSHJ'ED FROM ASYSC
	MOVEM J,(P)
	LDB J,[331000,,SYSCTD(H)]
	JUMPE J,NCALL2
	AOS B,FORTY
	JRST NCALL3	;HE WANTS POINTERS, WE HAVE JUST VALUES.
		;MUST GET ARGS AGAIN

ASCRCH:	MOVEI H,0
	REPEAT ZZ2,[CAML T,SYSCTB+1_<ZZ2-.RPCNT-1>(H)
	ADDI H,1_<ZZ2-.RPCNT-1>
	]
	CAMN T,SYSCTB(H)
	AOS (P)
	POPJ P,

;SYSTEM CALL GET ARGS
ASCGRG:	XCTR XR,[MOVE T,(B)]
	CAME T,[SETZ]
	 JRST ILUUO
	XCTR XR,[MOVE T,1(B)]
	MOVEM T,LSCALL(U)
	PUSHJ P,ASCRCH
	 POPJ P,	;CALL NAME UNRECOGNIZED.
	AOS (P)
	LDB J,[331000,,SYSCTD(H)]	;GET BITS CORRESP TO ARGS WHICH SAY SUPPLY PNTR TO NTH ONE
NCALL3:	MOVEI W,2(B)
	MOVE T,[-9,,A]
	SETZM CTLBTS(U)
ASYSC2:	XCTR XR,[MOVE R,(W)]
	TLNE R,37
	 PUSHJ P,ASCIND	;CALC EFFECTIVE ADDRESS
	TLNE R,2000
	 JRST ASYSC3	;OUTPUT OR ERRORCODE ARG
	TLNE R,4000
	 JRST ASYSC5	;CONTROL BITS
	AOBJP T,CPOPJ
	ROT J,-1
	JUMPL J,ASYSC7	;J IF WANT ADDRESS, NOT VALUE
	TLNE R,1000
	 TLZA R,-1	;IMMEDIATE, GET 0,,ADR
	  XCTR XR,[MOVE R,(R)]	;ELSE GET WORD POINTED TO
ASYSC7:	MOVEM R,-1(T)	;PUT INTO AC
	JRST ASYSC4

ASYSC5:	TLNE R,1000	;CTL BITS
	 TLZA R,-1	;IMMEDIATE, GET 0,,ADR
	  XCTR XR,[HRRZ R,(R)]	;ELSE WORD ADDRESS
	XORM R,CTLBTS(U)	;XOR ALL THESE ARGS TOGETHER
ASYSC4:	XCTR XR,[SKIPL (W)]	;SKIP IF TERMINATE BIT ON
	 AOJA W,ASYSC2
	HLRE W,T
	ADDI W,9	;COMPUTE NUMBER OF ARGUMENTS SUPPLIED
NCALL2:	LDB T,[300300,,SYSCTD(H)]
	SUB T,W
	JUMPG T,POPJ1	;NOT ENOUGH ARGS
	JRST POPJ2	;OK

ASYSC3:	TLNE R,1000
	 JRST ASYSC8	;ERROR CODE ARG
	XCTR XRW,[MOVES (R)] ;OUTPUT ARG, JUST MAKE SURE IT'S THERE
	MOVSI R,%SCVOT	;AND FLAG PRESENCE
ASYSC9:	IORM R,SYSCVL(U)
	JRST ASYSC4

ASYSC8:	HRLI R,%SCVER	;ERROR-CODE ARG
	TDNE R,SYSCVL(U);CAN'T HAVE MORE THAN ONE ERRORCODE ARG
	 JRST CPOPJ	;SAY "TOO MANY ARGS"
	XCTR XW,[SETZM (R)] ;MAKE SURE IT'S THERE AND ZERO IT IN CASE NO ERROR
	JRST ASYSC9

;SYSTEM CALL PUT (INTO USER MEMORY FROM AC'S)
SYSCPT:	HRRZ W,FORTY
	ADDI W,2
	MOVSI T,-8
SYSCP2:	XCTR XR,[MOVE R,(W)]
	TLNN R,1000
	TLNN R,2000
	JRST SYSCP3
	PUSHJ P,ASCIND
	MOVE J,1(T)
	XCTR XW,[MOVEM J,(R)]
	AOBJP T,CPOPJ
SYSCP3:	JUMPL R,CPOPJ
	AOJA W,SYSCP2

;PERFORM INDEXING AND INDIRECTION ON ADDRESS WORD IN R.
;DON'T CLOBBER BITS 3.6 - 4.9.  SET BITS 3.1 - 3.5 TO ZERO
;PUT ADDR IN RH.
ASCIND:	TLNN R,37
	POPJ P,
ASCIN1:	PUSH P,R
	LDB R,[220400,,R]
	CAIE R,0
	XCTR XR,[HRRZ R,(R)]
	ADD R,(P)
	HLL R,(P)	;GET ORIG @, MAY HAVE BEEN CARRIED INTO BY -1(17)
	TLZ R,17
	TLZE R,(@)
	XCTR XR,[MOVE R,(R)]
	DPB R,[2700,,(P)]
	POP P,R
	TLNN R,37
	POPJ P,
	PUSHJ P,OPBRK	;ALLOW PCLSR
	JRST ASCIN1

TPFLT:	CONO PI,CLKOFF	;PREVENT INTERRUPT AFTER IORM SPM ING BACK ON TOP OF 1000 BIT
IFE KL10P,[
	SPM UPGML(U)
	PUSH P,B
	MOVSI B,1000
	IORM B,UPQUAN(U)
	POP P,B
	LPMRI UPGML(U)	;TAKE TRAP, MAYBE DONT COME BACK
	JRST CLKONJ
]
IFN KL10P,[
	POP P,PFOPC	;IF RESTART FAULT, RETURN FROM TPFLT
	JRST PFA6	;JOIN REGULAR PAGE FAIL CODE
]

SUBTTL PURE DUMP

;`PDUMP' SYMBOLIC SYSTEM CALL
; ARG 1 - JOB SPEC FOR JOB TO BE DUMPED
; ARG 2 - DISK CHANNEL TO DUMP ONTO
; ARG 3 - STATE WORD (MODIFIED) INITIALLY 0, THEN 4.9 + PAGE # ABOUT TO DUMP

PDUMP:	MOVE J,A
	JSP T,NCRUI2	;DECODE JOB SPEC (1ST ARG)
	 JFCL
	MOVE A,J
	JUMPL J,OPNL31	;CAN'T PDUMP THE PDP6.
	MOVE D,B
	JSP T,PDUMDC	;DECODE 2ND ARG, B-> IOCHNM WORD.
	TRNN J,2000
	 JRST OPNL34	;NOT DISK WRITE CHANNEL.
	HRRZM D,UUAC(U)	;SO SET IN CASE OF ERROR
	PCLT
	XCTR XRW,[MOVES D,(C)]
	MOVEM A,EPDL(U)	;USER INDEX
PDUMA:	CAIN A,(U)	;IF PDUMP'ING SELF, MUSTN'T PCLSR,
	 PUSHJ P,NULSET	;SO DO A NULSET INSTEAD OF THE SOSSET
	CAIN A,(U)
	 JRST PDUMP9	;SO THAT A LSWPOP CAN BE DEON AT THE END IN EITHER CASE.
	PUSHJ P,RPCLSR	;HACKING ANOTHER JOB: STOP IT.
	PUSHJ P,SOSSET
	  USTP(A)
PDUMP9:	HLRZ A,(B)	;GET DISK CHANNEL
	MOVEM A,SRN3(U)	;CHANNEL
	MOVEM C,SRN4(U)	;POINTER TO STATE WORD
	MOVE T,QSRAC(A)
	TLNE T,%QAPDM
	 JRST PDUMP1	;ALREADY IN PDUMP MODE
	MOVE TT,QBFP(A)
	JUMPN TT,OPNL7	;WRITE LIST NOT EMPTY
	SKIPL QSMDN(A)
	JRST PDUMP2
	PUSH P,D
	MOVEI E,1
	MOVEI B,QBOV
	PUSHJ P,QSBWG
	JRST [	PUSHJ P,LSWPOP
		POP P,D
		PUSHJ P,UDELAY
		MOVE A,EPDL(U)
		JRST PDUMA ]
	POP P,D
	SOS QSBFS(A)		;COUNTED AT QSBWG AND AGAIN AT QSBWW DUE TO PDUMP MODE
	SOS QWBUFS
PDUMP2:	MOVSI TT,%QAPDM
	IORM TT,QSRAC(A)
	MOVEI TT,%QMPDM
	HRRM TT,QSRAC(A)
PDUMP1:	PUSHJ P,SWTAD	;TRY TO GET CIRPSW.
	  1_9,,CIRPSW	;IF FAIL, DO 1 LSWPOP, HANG UNTIL CIRPSW SEEMS TO BE AVAILABLE
	 JRST	[MOVE A,EPDL(U)	;THEN RETURN AND TRY WHOLE THING AGAIN.
		 JRST PDUMA]
	MOVE E,QSMDN(A)	;IF SUCCEED, SKIP EXTRA TIME
	LSH E,10.
	JUMPN D,PDUMP5
	SETZM (E)	;CLEAR FIRST WORD OF BLOCK
PDUMP4:	PUSHJ P,PUPLC	;GET BYTE POINTERS
	LDB W,Q		;CIRC POINTER ENTRY
	LDB R,T		;PAGE MAP ENTRY
	ANDCMI R,PMAGEM	;CLEAR AGE BITS
	CAIN W,-1
	 TLO R,(SETZ)	;ABS PAGE
	SKIPN W
	 MOVEI R,0	;PAGE NON-EXISTANT
	TRNN R,600000
	 LSH R,16.	;SWAPPED OUT
	MOVE W,D	;VIRTUAL PAGE NUMBER
	ADDI W,1(E)	;ADDRESS OF ENTRY IN BLOCK
	MOVEM R,(W)	;STORE ENTRY
	CAIGE D,377
	 AOJA D,PDUMP4
;DROPS THROUGH
;DROPS IN

	HRLI W,1(W)
	SETZM 1(W)
	HRRI W,2(W)
	BLT W,1777(E)
	PUSHJ P,PDUMPW
	SETZM QSMPRC(A)
	MOVSI D,(SETZ)
PDUMP5:	MOVE C,SRN4(U)
	XCTR XW,[MOVEM D,(C)]
PDUMP8:	PUSHJ P,PUPLC
	LDB W,Q
	CAIE W,-1
	SKIPN W
	 AOJA D,PDUMP6	;PAGE ABSOLUTE OR NONEXISTANT
	CONO PI,CLKOFF
	LDB TT,T	;PICK UP PAGE MAP ENTRY
	TRNN TT,600000
	 JRST PDUMP7	;SWAPPED OUT
	ANDI TT,PMRCM
	MOVSI Q,1
	ADDM Q,MMSWP(TT)	;AOS COUNT OF EXEC PGS POINTING TO THIS ONE
	CONO PI,CLKON
	PUSHJ P,SOLSET
	  MMSWP(TT)
	SKIPL QSMDN(A)
	 JRST PDUMP3		;ALREADY BEEN THROUGH HERE ONCE?
	PUSHJ P,QSTWG		;PREPARE FOR WRITING
PDUMP3:	MOVEM TT,QSMDN(A)	;STORE ABS PAGE NUMBER
	PUSHJ P,LSWDEL		;PAGE NOW GUARANTEED TO BE WRITTEN (MAYBE AT QOCLP1)
	PUSH P,D
	PUSHJ P,PDUMPW
	POP P,D
	AOS D
PDUMP6:	TRNN D,400
	 JRST PDUMP5
	MOVSI W,%QAPDX
	IORM W,QSRAC(A)
	PUSHJ P,LSWPOP
	PUSHJ P,LSWPOP
	JRST POPJ1

PDUMP7:	PUSHJ P,LSWPOP	;RELEASE CIRPSW
	MOVE J,EPDL(U)
	HRLI J,240000
	TRNE D,200
	 HRLI J,220000	;UPPER HALF
	PUSHJ P,MPLD1	;TURNS ON CLOCK
	MOVE J,D
	TRZ J,200
	LSH J,10.	;VIRTUAL ADDRESS OF PAGE
	PCLT
	XCTR XR,[MOVE J,20(J)]	;SWAP IN THE PAGE
	PUSHJ P,MPLDZ
	PUSHJ P,SWTL
	  CIRPSW
	JRST PDUMP8

PDUMPW:	MOVEI E,1
	MOVEI B,QBOV
	JRST QSBWW

PUPLC:	PUSH P,A
	PUSH P,U
	MOVE U,EPDL(U)
	MOVE A,D
	ANDI A,377
	PUSHJ P,UPLC
	POP P,U
	JRST POPAJ

;DECODE 2ND ARG TO PDUMP & LOAD.
;B GETS IOCHNM WORD ADDR, RH OF J GETS LH OF CLSTB ENTRY.

PDUMDC:	TRNE B,-NIOCHN
	 JRST OPNL14
	ADDI B,IOCHNM(U)
	HRRZ J,(B)
	HLRZ J,CLSTB(J)
	JRST (T)

PUSH4.:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	JRST (H)

POPP4.:	POP P,D
	POP P,C
	POP P,B
	POP P,A
	JRST (H)

SUBTTL PURE AND SBLK LOAD

;`LOAD' SYMBOLIC SYSTEM CALL
; ARG 1 - JPB SPEC FOR JOB TO BE LOADED
; ARG 2 - DISK CHANNEL TO LOAD FROM

;PAGE WORD
;4.9=1 ABSOLUTE
;4.8=1 SHARED WITH OTHER PAGES AT LEAST ONE OF WHICH IS WRITE
;4.7=1 LINK WITH VIRT PG IN RH 1.8-1.1
;2.7=1 WORD ALREADY PROCESSED

NLOAD:	MOVE J,A
	JSP T,NCORUI	;DECODE THE JOB SPEC.
	 JRST JLOAD0	 ;JOB GUARANTEED WRITEABLE.
	JSP T,NCORWR	;ELSE CHECK IF WRITEABLE.
	CAIN J,-1	;BUT CAN WRITE PDP6.
	CAIA
	JRST OPNL31	;NOT WRITEABLE.
JLOAD0:	HRREI A,(J)	;MAKE SURE EXTEND SIGN IF PDP6.
	JSP T,PDUMDC	;DECODE 2ND ARG.
	TRNN J,2000
	TRNN J,200
	JRST OPNL34	;NOT DISK READ CHANNEL.
	MOVE R,B	;IOCHNM ADDRESS IN CASE WE GET TO QICL
	JUMPL A,NLOADE	;DONT STOP THE 6
	CAMN A,U
	 JRST NLOADA	;DONT STOP IF LOADING INTO SELF
	PUSHJ P,RPCLSR
	PUSHJ P,LSWPOP	;SOS JOB'S DIELOK - IT CAN'T DIE WHILE STOPPED.
	PUSHJ P,SOSSET
	USTP(A)
	 CAIA
NLOADA:	 PUSHJ P,LSWPOP
NLOADE:	MOVEM A,SRN3(U)	;SAVE USER INDEX (-1 => PDP6)
	HLRZ A,(B)
	MOVEM A,SRN4(U)	;SAVE # OF DISK CHANNEL
	SETZM SRN5(U)
	HLRZ C,QPCLSR(A)
	JUMPE C,NLOADD
	HRRZ Q,SRN3(U)
	CAIN C,(Q)
	JRST NLDSBB	;(COMING BACK AFTER PCLSR)
	SETZM QPCLSR(A)
NLOADD:	CAMN U,PCLUSR
	SETZM PCLIDX
	SKIPL TT,QSMDN(A)
	 JRST NLOADB
	PCLT
	SKIPG QSBFS(A)
	 PUSHJ P,UFLS	;HANG UNTIL A BLOCK IS READ IN
	MOVE Q,QSRAC(A)
	TLNE Q,%QAACC+%QAMPU+%QAPAR
	 JRST OPNL7	;LOST ONE WAY OR ANOTHER
	MOVEI E,1
	MOVEI B,QBIV
	PUSHJ P,QSBGB	;SET UP CHNL AREA. TT ADDR OF FIRST WORD OF BLOCK
	 JRST 4,.
	 JRST NLOADC	;QSBGB SKIPS FOR NORMAL RETURN
	 JRST OPNL33	;SKIPPED TWICE => EOF

NLOADB:	MOVE J,QAWMPB(A)
	LSH TT,10.

NLOADC:	SKIPE (TT)	;SKIP IF PURE DUMPED FILE
	 JRST NLDSB	;SBLK
	SKIPGE SRN3(U)
	 JRST OPNL34	;TRYING TO PURE LOAD PDP6
	MOVSI Q,%QAACC	;WILL GO RANDOM ACCESSING THROUGH FILE
	IORM Q,QSRAC(A)	;THIS ALSO INHIBITS ACTIVATION AT PI LEVEL
	MOVEI R,1(TT)	;ADDRESS OF FIRST WORD OF DUMPED MAP
	MOVEM R,EPDL3(U)	;SAVE
	MOVEI Q,2000
	PUSHJ P,QFNTR	;FIND DISK ADDRESS OF SECOND BLOCK
	 JRST OPNL33	;OFF END OF FILE
	SOS QSBI(A)	;UNDO QFNTR HACK
	AOS QSLGL(A)
	PUSHJ P,QUDULK	;UNLOCK USER DIRECTORY
	PUSHJ P,SWTL	;LOCK CIRPSW
	  CIRPSW
;DROPS IN

NLOAD0:	MOVE A,@EPDL3(U)
	TRNE A,600000	;SKIP IF NO ACCESS (IGNORE)
	TRNE A,100000
	JRST NLD14	;THIS PAGE ALREADY DONE OR NO ACCESS
	MOVE A,SRN5(U)	;VIRTUAL PAGE NUMBER
	MOVE U,SRN3(U)	;USER INDEX
	PUSHJ P,UPLC
	LDB R,Q		;LOOK IN CIRCULAR POINTER ENTRY FOR THIS PAGE
	JUMPE R,NLOAD1	;DOESN'T ALREADY HAVE THIS VIRTUAL PAGE
	PUSH P,T	;SAVE BYTE POINTER TO PAGE MAP FOR THIS VIRTUAL PAGE
	PUSH P,Q	;SAVE BYTE POINTER TO CIRCULAR POINTER ENTRY FOR THIS PAGE
	PUSHJ P,PAGERT	;FLUSH THE ALREADY EXISTING VIRTUAL PAGE
	POP P,Q
	POP P,T
NLOAD1:	MOVE U,USER
	MOVE R,@EPDL3(U)	;PICK UP DUMPED PAGE MAP WORD
	ANDCMI R,PMAGEM	;CLEAR AGE BITS (WOULD LOSE AT NLOAD4+4)
	JUMPGE R,NLOAD3	;NOT ABSOLUTE PAGE
	ANDI R,PMRCM	;ABS PG #
	CAIL R,TSYSM
IFE PDP6P,	JRST OPNL32
.ELSE [
	JRST [	CAIGE R,<PDP6BM_-10.+LPDP6M>
		 CAIGE R,<PDP6BM_-10.>
		  JRST OPNL32
		HRRZ R,@EPDL3(U)	;ALLOW USER TO LOAD WRITABLE PDP6 PAGES.
		ANDCMI R,PMAGEM\PMUNSD	;GIVE HIM WHATEVER ACCESS HE RQ'S.
		JRST NLOAD5]]
;IFN TEN11P,[		;NOT NECESSARY SINCE 10-11 PAGES ABOVE TSYSM NOW
;	TRNN R,400
;	JRST .+3
;	MOVE E,T11MP-400(R)
;	AOJN E,NLOAD2	;DONT ALLOW PAGE TO POINT TO TEN11
;]

	LDB E,[MUR,,MEMBLT(R)]
	CAIN E,MUHOLE
	 TDZA R,R	;IF PAGE NXM TODAY, DON'T ACTUALLY GIVE ACCESS

NLOAD5:	  TRO R,200000	;RD ONLY
	DPB R,T		;STORE ENTRY IN PAGE MAP
	MOVEI R,-1
	DPB R,Q		;STORE -1 IN CIRCULAR POINTER
NLOAD2:	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	PUSHJ P,GHUSRA	;RECOMPUTE HUSRAD
NLD14:	MOVE U,USER
	MOVEI R,100000
	IORB R,@EPDL3(U)	;MARK DUMPED PAGE WORD AS ALREADY DONE
	MOVE A,SRN4(U)	;DISK CHANNEL
	TLNN R,500000	;SKIP IF NO CORRESPONDING BLOCK IN FILE
	TRNN R,600000	;SKIP IF MUST ADVANCE ONE BLOCK
	 JRST .+3	;DON'T ADVANCE FILE POINTER
	  PUSHJ P,QFNTN	;ADVANCE TO NEXT DISK ADDRESS
	   JRST OPNL33	;PREMATURE EOF
	AOS R,SRN5(U)	;NEXT VIRTUAL PAGE
	CAMN U,PCLUSR
	 MOVEM R,PCLIDX
	AOS EPDL3(U)	;NEXT MAP WORD
	CAIGE R,400
	 JRST NLOAD0	;LOOP
	PUSHJ P,LSWPOP	;RELEASE CIRPSW
	MOVE B,SRN3(U)	;USER INDEX LOADING INTO
	CAME B,U	;SKIP IF LOADING INTO SELF
	 PUSHJ P,LSWPOP	;UNSTOP USER
	MOVE B,QFBLNO(A)
	SETZM QFBLNO(A)
	MOVEM B,QRADAD(A)
	JRST POPJ1

NLOAD3:	TLNN R,100000	;SKIP IF LINK WITH PAGE IN RH OF R
	JRST NLOAD4
	PUSH P,T	;SAVE BYTE POINTER TO MAP ENTRY FOR THIS VIRTUAL PAGE
	PUSH P,Q	;SAVE POINTER TO CIRCULAR POINTER ENTRY FOR THIS PAGE
	LDB A,[1700,,R]	;VIRTUAL PAGE NUMBER BEING LINKED TO
	CAIL A,400
	JRST NLOAD8	;BAD VIRT PAGE #
	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER OF PAGE BEING LINKED
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	PUSHJ P,UPLC
	LDB W,Q		;CIRCULAR POINTER OF OTHER ENTRY
	JUMPE W,NLOAD8	;DIDN'T EXIST
	CAIN W,-1
	JRST NLOAD8	;POINTS TO AN ABSOLUTE PAGE
	MOVE C,U
	IDIVI C,LUBLK
	JUMPN D,[JRST 4,.]	;L DOESN'T DIVIDE U
	LSH C,10	;USER NUMBER _ 8
	TRZE C,400000
	JRST 4,.	;USER INDEX WAS TOO LARGE
	IOR C,E		;NEW CIRCULAR POINTER
	POP P,D		;NEW CIRCULAR POINTER BYTE POINTER
	DPB W,D		;STORE OTHER ENTRY AS NEW CIRCULAR POINTER ENTRY
	DPB C,Q		;MAKE OTHER CIRCULAR POINTER ENTRY POINT TO NEW ONE
	LDB E,T		;OTHER MAP ENTRY
	POP P,T		;POINTER TO NEW MAP ENTRY
	ANDI R,600000	;PROTECTION BITS
	TRZN E,600000
	JRST NLD11
	IOR E,R
	JRST NLD10
NLD11:	LSH R,-20
	DPB R,T
NLOAD9:	AOS SNSWPG	;INCR CNT OF SWAPPED OUT FOR SYS
	AOSA NSWPGS(U)	;USER LOADING INTO HAS ONE MORE SWAPPED OUT PAGE
NLD10:	DPB E,T
NLD13:	AOS NMPGS(U)	;USER HAS ONE MORE PAGE
	AOS SNMPGS	;SYSTEM HAS 1 MORE PAGE
NLD15:	MOVE U,USER
	JRST NLOAD2	;RECOMPUTE HUSRAD AND LOOP

NLOAD4:	MOVE A,SRN4(U)	;DISK CHANNEL
	MOVEI TT,(R)	;PUT DESIRED ACCESS IN RH(TT),
	TDNE R,[200000,,400000]
	 IORI TT,4000	;ALLONG WITH INITIAL-SWAPIN BIT IF NEC.
	PUSHJ P,NCORQ7	;FIND OR CREATE MMP ENTRY.
	MOVE E,SRN5(U)	;GET PAGE # IN JOB BEING LOADED
	MOVE U,SRN3(U)	;TARGET USER.
	PUSHJ P,NCORR1	;INSERT THE PAGE.
	JRST NLD15

NLOAD8:	SUB P,[2,,2]	;"DEVICE NOT READY"
	JRST OPNL7	;LOSING ERROR - MAYBE CREATE NEW ONE?

NLOADZ:	PUSHJ P,LSWPOP	;FREE CIRPSW
	MOVEI T,3
	CAMLE T,LMEMFR
	PUSHJ P,UFLS
	PUSHJ P,SWTL
	CIRPSW
POPSM2:	SOS (P)	;RETURN TO LOCN BEFORE PUSHJ
	SOS (P)
	POPJ P,

;QTAOS:	PUSHJ P,QTLOCK	;LOCK TUT
QTAOS1:	MOVE D,QSLGL(A)	;DISK TRACK
	PUSHJ P,TUTPNT
	JUMPLE B,[JRST 4,.]	;NOT PART OF ANY FILE
	CAIGE B,TUTMNY
	 AOS B
	DPB B,D		;ADD ONE TO TUT ENTRY FOR THIS TRACK
	JRST QTULK

NLUPCL:	MOVSI T,BSSTP	;THIS IS THE LOSSET ROUTINE TO CLEAR BSSTP.
	SKIPGE A,SRN3(U)
	 JRST 4,.
	ANDCAM T,USTP(A)
	POPJ P,

NLDSBB:	MOVSI J,254000	;LO-LO, HI-HI, ACS-SWAP OUT ACS (COMING BACK AFTER PCLSRING OUT)
	HRR J,SRN3(U)	;A HAS DSK CHNL #)
	CAIE U,(J)	;LOADING SELF?
	PUSHJ P,MPLD1	;LOAD MAP (ALSO CLOBBER UMAPS)
	SKIPL C,SRN3(U)
	CAIN U,(C)
	JRST NLDSBH
	PUSHJ P,LSWPOP
	PUSHJ P,LOSSET
	NLUPCL
	MOVSI B,BSSTP
	IORM B,USTP(C)
NLDSBH:	HRRZ B,QPCLSR(A)
	JRST (B)

NLDSB:	PUSH P,A	;A HAD DSK CHNL #
	SKIPL A,SRN3(U)	;USER INDEX OF GUY WE'RE LOADING
	 CAIN U,(A)
	  JRST NLDSBG	;LOADING OURSELVES (OR PDP6)
	MOVSI B,BSSTP
	IORM B,USTP(A)	;STOP GUY
	PUSHJ P,LSWPOP	;UNDO SOSSET
	PUSHJ P,LOSSET
	  NLUPCL	;GO HERE ON PCLSRING OR LSWPOPING THIS.

NLDSBG:	POP P,A
	HRLZ B,SRN3(U)
	HRRI B,NLDSBD
	MOVEM B,QPCLSR(A)	;RESTART POINT IN CASE OF PCLSR
	MOVEM J,QSMPRC(A)
	MOVEM TT,QSMPRP(A)
	MOVSI J,254000	;LO-LO, HI-HI, ACS-SWAP OUT ACS
	HRR J,SRN3(U)
	CAIE U,(J)
	PUSHJ P,MPLD1	;LOAD MAP (ALSO CLOBBER UMAPS)

;DROPS THROUGH

;DROPS IN

NLDSB1:	HRROI I,EPDL3(U)
	MOVEM I,SRN4(U)	;SET UP AOBJN PTR TO READ INTO EPDL3
NLDSBD:	MOVEI C,SRN4(U)	;SET C UP TO POINT TO AOBJN PTR
	HRLI C,(TRN)	;INDICATE EXEC MODE ADR
	PUSHJ P,QBI
	SKIPGE SRN4(U)
	 JRST NLDSB9	;PREMATURE EOF
	MOVE I,EPDL3(U)
	CAME I,[JRST 1]
	 JRST NLDSB1	;IGNORE INITIAL STUFF UNTIL JRST 1
NLDSBK:	MOVEI B,NLDSBE
	HRRM B,QPCLSR(A)
NLDSB2:	HRROI I,EPDL3(U)
	MOVEM I,SRN4(U)
NLDSBE:	MOVEI C,SRN4(U)
	HRLI C,(TRN)
	PUSHJ P,QBI	;GET AN AOBJN POINTER
	SKIPGE SRN4(U)
	 JRST NLDSB9	;PREMATURE EOF
	SKIPL B,EPDL3(U)
	 JRST NLDSB6	;NOT AN AOBJN POINTER
	HRRZS B
	CAIL B,20
	 JRST NLDSB3	;OK IF NOT LOADING INTO ACS
	SKIPL SRN3(U)
	 CAMN U,SRN3(U)
	  JRST NLDSBP
	JRST NLDSB3

NLDSBP:	HLRE C,EPDL3(U)	;ATTEMPTING TO LOAD INTO OWN ACS OR 6 ACS
	SUBI B,20
	CAMLE C,B
	 MOVE B,C
	MOVNS B
	LDB D,[1200,,QSMPRP(A)]
	SKIPGE QSMDN(A)
	 MOVEI D,0
	ADD D,QFBLNO(A)
	ADD D,B
	MOVEM D,QRADAD(A)
	MOVSI D,%QAACC
	IORM D,QSRAC(A)
	ADD C,B
	JUMPE C,NLDSBI	;GET NEW AOBJN POINTER (FLUSH CHECKSUM)
	HRLS B
	ADDM B,EPDL3(U)	;UPDATE AOBJN POINTER

NLDSB3:	MOVEI B,NLDSBF	;LOADING OTHER GUY,MAYBE FLUSH EXISTING MEMORY AND GET NEW
	HRRM B,QPCLSR(A)
NLDSBF:	HRRZ E,EPDL3(U)	;START ADR OF BLOCK
	HLRE C,EPDL3(U)	;-LENGTH OF BLOCK
	SUB E,C
	SUBI E,1	;GET END ADR OF BLOCK
	LSH E,-10.
	SKIPGE SRN3(U)
	 JRST [	CAIL E,16.	;LOADING PDP6
		JRST NLDSB9
		JRST NLDSBQ]
	CAIL E,400
	 JRST NLDSB9	;TRYING TO LOAD ABOVE TOP OF MEM
	PUSH P,A
	PUSH P,R	;R HAS IOCHNM WD, NEEDED IF REACH QICL VIA QBI.
	PUSH P,E	;PAGE NO. OF LAST PAGE NEEDED
NLDSB4:	MOVE E,(P)
	CAMGE E,SRN5(U)
	 JRST NLDSB5	;ALREADY HAVE NEEDED PAGES
	MOVE A,SRN5(U)
	PUSH P,U
	MOVE U,SRN3(U)	;LOOK UP THIS PAGE IN MAP OF USER WE'RE HACKING.
	PUSHJ P,UPLC	;IF THERES A WRITABLE PAGE
	POP P,U
	LDB A,T		;IN THE SLOT ALREADY, KEEP IT.
	TRNN A,600000
	 TRNN A,2
	  TRNE A,400000
	   JRST NLDSBM
	CAME U,SRN3(U)	;IF NOT HACKING SELF, NCORLL WILL LSWPOP
	 PUSHJ P,NULSET	;WHAT IT THINKS IS A LOSSET LIKE NLUPCL
	PUSHJ P,SWTL
	  CIRPSW
	MOVEI R,LUBLK	;GET PAGE FROM CORE JOB (FRESH PG, GET IT?)
	MOVE TT,SRN3(U)	;INTO THE JOB WE'RE HACKING.
	MOVE C,SRN5(U)	;PAGE # TO GIVE IT.
	MOVSI A,NCORDW+NCORDR	;WANT WRITE ACCESS.
	PUSHJ P,NCORL	;UNDOES NULSET AND SWTL.
	 JRST NLSBPL	;COULDNT GET PAGE (CALLED LSWCLR)
NLDSBM:	AOS SRN5(U)
	JRST NLDSB4	;CHECK WHETHER WE NEED MORE PAGES.

NLDSB5:	SUB P,[1,,1]	;NOW WE HAVE ALL PAGES NEEDED TO LOAD THIS BLOCK.
	POP P,R
	POP P,A
NLDSBQ:	MOVEI B,NLDSBC
	HRRM B,QPCLSR(A)
	MOVE I,EPDL3(U)	;GET THE BLOCK'S HEADER (AOBJN TO PLACE TO LOAD INTO)
	MOVEM I,QLDPTR(A)	;AND PUT IT WHERE IT WILL BE SAFE OVER OTHER UUOS.
NLDSBC:	HRRZI C,QLDPTR(A)
	HRLI C,(SETZ)
	PUSHJ P,QBI	;DO A BLOCK IOT, USING THAT AOBJN POINTER.
NLDSBI:	MOVEI B,NLDSBJ
	HRRM B,QPCLSR(A)
	HRROI I,EPDL3(U)
	MOVEM I,QLDPTR(A) ;NOW READ THE CHECKSUM INTO EPDL3 TO IGNORE IT.
NLDSBJ:	HRRZI C,QLDPTR(A)
	HRLI C,(TRN)
	PUSHJ P,QBI	;IGNORE CKSUM
	JRST NLDSBK

NLDSB6:	LDB D,[1200,,QSMPRP(A)]
	SKIPGE QSMDN(A)
	 MOVEI D,0
	ADD D,QFBLNO(A)
	SUBI D,1
	MOVEM D,QRADAD(A)
	MOVSI D,%QAACC
	IORM D,QSRAC(A)
	MOVEI B,NLDSBA
	HRRM B,QPCLSR(A)
NLDSBA:
NLDSB8:	CAME U,SRN3(U)	;UNLESS HACKING SELF OR PDP6, WE HAVE A SOSSET OF USTP TO POP.
	 SKIPGE SRN3(U)
	  CAIA
	   PUSHJ P,LSWPOP
	AOSA (P)
NLDSB9:	 PUSHJ P,OPNL22	;LOAD FILE NOT IN VALID SBLK FORMAT
NLSBP1:	PUSHJ P,MPLDZ
	SETZM QPCLSR(A)
	POPJ P,

NLSBPL:	SUB P,[2,,2]	;FLUSH PUSHES OF E AND R.
	POP P,A
	JRST NLSBP1

SUBTTL .CALL PAGEID

;	.CALL ADR
;ADR:	SETZ
;	SIXBIT /PAGEID/
;	ARG1
;	ARG2
;	402000,,ARG3

;ARG1:	N	;VIRTUAL PAGE NUMBER (MUST NOT BE ZERO)
;ARG2:	ID	;SIX BITS OF IDENTIFIER (1.1-1.6)
;ARG3:		;SET TO -1 IF NEW PAGE CREATED,
		;0 IF LINKED TO EXISTING PAGE

;INSERTS A PUBLIC PAGE WITH IDENTIFIER -ID- IN USERS MAP
;AS PAGE SPECIFIED BY FIRST ARGUMENT.  IF A PUBLIC PAGE
;WITH IDENTIFIER -ID- ALREADY EXISTS, THAT PAGE WIL BE
;INSERTED IN THE USERS MAP.  IN THE FIRST CASE ARG3 WILL
;BE SET TO -1, IN THE SECOND CASE IT WILL BE SET TO 0.
;SKIPS UNLESS BAD ARGUMENTS OR RANDOMNESS.

APGID:	JUMPL A,OPNL33
	CAIL A,400
	JRST OPNL33
	PUSHJ P,SWTL
	PGIDSW
	ANDI B,MEMIDM
	PUSH P,A
	PUSH P,B
	MOVNI A,1
	SKIPE C,MEMID(B)	;SKIP IF NO ENTRY FOR THIS ID
	MOVEI A,0	;ENTRY ALREADY EXISTS
	PUSHJ P,SYSCPT	;STORE INDICATION
	JUMPN C,APGID1	;LINK WITH EXISTING ENTRY
	MOVE TT,-1(P)	;VIRTUAL PAGE NUMBER
	LSH TT,11
	IOR TT,[5400,,400000]
	MOVE Q,U	;USER REQUEST IS FOR
	PUSHJ P,NCBLK
	JRST POP2J	;CORBLK FAILED, CALLED LSWCLR.
	PUSHJ P,SWTL
	CIRPSW
	MOVE A,-1(P)
	PUSHJ P,UPLC
	MOVE C,Q	;BYTE POINTER TO CIRCULAR POINTER ENTRY
	PUSHJ P,UCPRL
	200000,,.+2	;RETURN ON MMP
	JRST 4,.	;NO MMP ENTRY
	SUB P,[4,,4]
	MOVE U,USER
	MOVE B,(P)
	MOVEM C,MEMID(B)
	AOS MEMIDU
	PUSHJ P,LSWPOP
	SUB P,[2,,2]
	JRST LSWPJ1

APGID1:	PUSHJ P,SWTL
	CIRPSW
	PUSHJ P,UCPRL
	400000,,.+2
	JRST 4,.	;NO USERS IN LIST
	SUB P,[4,,4]
	MOVE A,U
	IDIVI A,LUBLK
	MOVE U,USER
	LSH A,22
	IOR A,[3400,,400000]
	IOR A,I
	MOVE TT,-1(P)
	LSH TT,11
	IOR TT,A
	PUSHJ P,LSWPOP
	MOVE Q,U	;USER REQUEST IS FOR
	PUSHJ P,NCBLK
	JRST POP2J
	SUB P,[2,,2]
	JRST LSWPJ1

	EBLK
PGIDSW:	-1
	0
	BBLK

SUBTTL .GUN, .LOGOUT

;DESTROY PROCEDURE TREE WHOSE TOP INDEX SUPPLIED BY USER
AGUN:	XCTR XR,[SKIPG A,(J)]
	 POPJ P,	;LOSE, NEG OR SYSTEM JOB
	IMULI A,LUBLK
	CONO PI,CLKOFF
	CAMGE A,USRHI	;USER INDEX UNREASONABLE => LOSE.
	CAIG A,LUBLK
	 JRST CLKONJ
	JRST ALOGO6

ALOGOU:	MOVE A,U	;.LOGOUT, AND STY CLOSE.
	CONO PI,CLKOFF
;A HAS JOB BEING LOGGED OUT; U HAS JOB THAT'S DOING IT.
;.GUN AND .LOGOUT ACT BY PUTTING THE JOB IN SUCH A STATE THAT
;IT CAN DO NOTHING BUT TRY TO DISAPPEAR. IF THE JOB IS ALREADY
;IN THAT STATE, THIS ROUTINE DOES NOTHING. THAT PREVENTS
;RECURSION LOOPS WHEN KILLING CYCLIC STRUCTURES INVOLVING STY'S.
;EXCEPTION: IF THE JOB TO BE LOGGED OUT IS THE RUNNING JOB,
;WE DO THE REAL WORK BY GOING TO ALOGO1.
ALOGO6:	SKIPE UNAME(A)	;JOB TO BE LOGGED OUT IS GONE.
	SKIPL SUPPRO(A)	;CAN'T LOG OUT UNLESS TOP LEVEL.
	 JRST CLKONJ
	CAME A,U
	 AOS (P)	;IF .GUN GETS THIS FAR, IT HAS "SUCCEEDED".
	MOVSI T,BULGOS+BULGO
	TDNE T,APRC(A)	;IF JOB IS ALREADY LOGGING OUT,
	 JRST ALOGO7	; SEE IF IT IS THE RUNNING JOB
	MOVSI B,%PCUSR
	CAMN A,USER
	 AOJA B,ALOGO5
	PUSH P,U
	MOVE U,USER
	MOVEM A,SRN3(U)	;AUCL4 FINDS USR IDX TO HACK HERE.
	PUSHJ P,LOSSET
	    AUCL4	;CLEAR BULGOS IF AUCL1 PCLSR'S
	PUSHJ P,AUCL1	;SET BULGOS AND WAIT FOR DIELOK TO CLEAR.
	POP P,U
	CONO PI,CLKOFF
	PUSHJ P,LSWDEL
	MOVEM B,UPC(A)	;SET HIM UP TO LOG OUT.
	SOS USTP(A)
ALOGO4:	MOVE B,[.LOGOUT]	;PUT THE FOLLOWING ROUTINE IN JOB'S AC'S:
	MOVEM B,AC0S(A)		;	0/	.LOGOUT
	CAMN A,USER		;	1/	.VALUE
	 XCTR XW,[MOVEM B,0]	;	2/	JRST 0
	MOVSI B,(.VALUE)
	MOVEM B,AC0S+1(A)
	CAMN A,USER
	 XCTR XW,[MOVEM B,1]
	MOVSI B,(JRST)
	MOVEM B,AC0S+2(A)
	CAMN A,USER
	 XCTR XW,[MOVEM B,2]
	MOVSI B,BULGOS
	IORM B,APRC(A)	;SAY HE'S DIEING SO NO-ONE WILL HACK HIM.
	MOVEM U,SRN3(A)	;RECORD WHO IS KILLING HIM.
	SETZM PICLR(A)	;PREVENT INTERRUPTS.
	SETZM MSKST(A)
	SETZM PIRQC(A)
	MOVSI B,BUSRC
	ANDCAM B,USTP(A) ;MAKE SURE HE CAN RUN - ELSE HE WOULDN'T LOG OUT.
ALOGO7:	CONO PI,CLKON
	CAME A,USER
	 POPJ P,
	JRST ALOGO1	;IF JOB IS RUNNING JOB, MUST HACK AROUND

ALOGO5:	MOVEM B,UUOH	;LOGGING OUT SELF - MAKE OUR PC LOOK
	JRST ALOGO4	; AS IF WE HAD EXECUTED THE .LOGOUT IN AC 0

ALOGO1:	MOVE A,U
	PUSHJ P,AUCL3	;WAIT TILL NO-ONE IS LOOKING AT ME,
	PUSHJ P,UBLAM	;CLOSE MY CHANNELS AND KILL MY INFERIORS AND CORE.
	MOVE A,USER
	MOVE U,SRN3(A)	;GET IDX OF JOB THAT KILLED ME.
	CONO PI,CLKOFF	;DYING JOB'S USER VARS ARE SAFE PLACE
	MOVEI T,SRN3(A)	;TO REMEMBER INFO FOR LOGOUT MESSAGE.
	PUSH T,UNAME(U)	;SINCE IT CAN'T EVER RUN AGAIN.
	PUSH T,JNAME(U)	;UNAME AND JNAME OF KILLER.
	MOVSI T,BULGO
	IORM T,APRC(A)	;SYS JOB KILLS ANY TREES WITH BULGO SET.
	MOVSI T,SCLGUN
	IORM T,SUPCOR	;TELL SYS JOB TO LOOK AROUND FOR TREES TO KILL.
	MOVSI T,BUSRC	;SUICIDE: MAKE SURE WE DON'T RUN ANY MORE.
	IORM T,USTP(A)
	CONO PI,CLKON
	JRST UDELAY

;COME WITH JOB INDEX IN A. INDICATE THAT JOB IS ABOUT TO DIE,
;THEN WAIT TILL IT'S SAFE TO KILL IT.
;TURNS CLOCK ON.
AUCL3:	MOVSI T,BULGOS
	IORM T,APRC(A)	;SAY THIS JOB STARTING TO GO AWAY.
	CONO PI,CLKON	;NOONE CAN START HACKING US NOW; SAFE.
	CAME A,USER	;IF NOT LOGGING OUT RUNNING USER,
	 PUSHJ P,1USTOP	;STOP THE JOB BEING KILLED.
	SKIPE DIELOK(A)	;WAIT TILL NO-ONE IS LOOKING AT THAT JOB.
	 PUSHJ P,UFLS
	HRLOI T,#BUSRC	;AND NO-ONE ELSE HAS HIM PCLSR'ED.
	TDNE T,USTP(A)
	 PUSHJ P,UFLS
	POPJ P,		;WE SUCCEEDED, BUT CALLER HAS WORK TO DO.

SUBTTL REAL TIME USER FEATURE
;
;.REALT AC,	SKIPS ONLY IF REAL TIME FACILITY REQUESTED AND SEIZED
;AC=	4.9=>TURN OFF OLD CLOCK RATE, FLUSHING REAL TIME FACILITY AND
;		 REMAINDER OF CURRENT TICK AND ZEROING TICK COUNT
;	4.8=>TURN ON NEW CLOCK RATE
;	4.7=>TRY TO SEIZE REAL TIME USER FACILITY
;	4.6=>DON'T SETTLE FOR PSEUDO-REAL TIME STATUS
;	4.5 =>ONLY WANT PSEUDO
;	4.4=>PROGRAM TO BE BLOCKED EXCEPT FOR HIGH PRIORITY PHASE OR INT. LEVEL
;	4.3=>READ INTO WD3+4 AS DESCRIBED BELOW (BEFORE ANY OTHER BITS INTERPRETED)
;	3.1-4.2=RESERVED FOR EXPANSION, SHOULD BE ZERO
;	1.1-2.9=RH=POINTER TO 4 WORD BLOCK
;	WD1=FRAME TIME IN 60'THS (MUST BE <2**18.)
;	WD2=PRIORITY TIME IN 60'THS (MUST BE <7 AND <WD1/2)
;	WD3= IF 4.3 ON, SET RH TO FRAME TIME, LH TO TICKS SINCE EXAMINED
;	WD4= IF 4.3 ON, SET RH TO HIGH PRIORITY TIME, LH TO 0 IF CURRENTLY LOW
		;PRIORITY OR -1 IF CURRENTLY HIGH PRIORITY
;
AREALT:	XCTR XR,[MOVE A,(J)]
	TLNN A,4000
	JRST AREAL1
	CONO PI,CLKOFF
	MOVE T,UTIME(U)
	MOVE Q,URTIME(U)
	CONO PI,CLKON
	XCTR XW,[MOVEM T,2(A)]
	XCTR XW,[MOVEM Q,3(A)]
AREAL1:	TLNN A,700000
	POPJ P,
	HRRZ T,UREALT
	CAMN T,U
	SETOM UREALT
	SETZM URTIME(U)
	TLNN A,400000
	JRST AREAL2
	PUSHJ P,CLQDEL	;TURN OFF OLD INTS
	UCLBLK(U)
	SETZM UTIME(U)	;ZERO TICK COUNT
AREAL2:	TLNN A,200000
	JRST AREAL4
	XCTR XR,[SKIPG T,(A)]
	JRST ILUUO
	HRRM T,UTIME(U)
AREAL4:	TLNN A,100000
	JRST AREAL6
	XCTR XR,[SKIPLE T,1(A)]
	CAIL T,13.
	JRST ILUUO
	HRRZ B,UTIME(U)
	LSH B,-1
	CAMLE T,B
	JRST ILUUO
	HRROS T
	TLNE A,10000
	TLZ T,1
	MOVEM T,URTIME(U)
	TLNE A,20000
	JRST AREAL6
	CONO PI,CLKOFF
	SKIPGE UREALT
	JRST AREAL7
	TLNE A,40000
	SETZM URTIME(U)
	JRST AREAL5
AREAL7:	MOVEM U,UREALT
	AOS (P)
AREAL5:	CONO PI,CLKON
AREAL6:	SKIPN T,UTIME(U)
	POPJ P,
	SKIPE B,URTIME(U)
	MOVE T,B
	HRRZS T
	PUSHJ P,CLQADD
	UCLBLK(U)
	POPJ P,


;CLOCK LEVEL ROUTINE
UREALB:	SUBI U,UCLBLK	;SET INDEX TO QUEUE BLOCK
	SKIPE B,URTIME(U)
	JRST URLTB2
URLTB1:	MOVSI T,(%PIRLT)
	IORM T,PIRQC(U)
	MOVSI T,1
	ADDM T,UTIME(U)
	HRRZ T,UTIME(U)
	SKIPGE B
	HRRZ T,B
URLTBX:	SETZM SCHFLG	;CAUSE SCHEDULE THIS CLOCK BREAK
	MOVEI C,UCLBLK(U)
	JRST CLQREE

URLTB2:	TLC B,-1
	MOVEM B,URTIME(U)
	MOVSI T,1
	HRRZ C,UREALT
	JUMPGE B,URLTB4
	CAMN C,U
	HRRZS UREALT
	JRST URLTB1

URLTB4:	CAMN C,U
	IORM T,UREALT
	HRRZ T,UTIME(U)
	HRRZS B
	SUB T,B
	JUMPG T,URLTBX
	JRST 4,.

SUBTTL MISCELLANEOUS SYSTEM CALLS

$INSRT TIME		;ROUTINES HAVING TO DO WITH CLOCKS AND THINGS

;
;.CLOSE CH,	;CLOSE ANY I/O TRANSACTION OPEN ON CHANNEL CH
;
CCLOSE:	HRREI C,-IOCHNM(R)	;CLOSE CALLED INTERNALLY
	SUB C,U
	TRNE C,-NIOCHN
	 JRST 4,.	;R WAS NOT AN IOCHNM WORD ADDRESS.
	HRRZM C,UUAC(U)	;SOME CLOSE ROUTINES LOOK AT UUAC
	JRST ACLOSE

NCLOSE:	AOS (P)
ACLOSE:	HLRZ A,(R)	;SET UP A WITH L.H. OF I/O CH WORD
	HRRZ B,(R)	;SET UP B WITH R.H. "
	MOVE C,CLSTB(B)	;GET CLOSE TABLE ENTRY
	TLNE C,400	;SKIP IF NOT STANDARD CLOSE
	JRST STDCLS	;JUMP TO STANDARD CLOSE
	PUSH P,R	;SAVE R
	PUSHJ P,(C)	;CALL CLOSE ROUTINE
	POP P,R		;RESTORE R
STDCLX:	SETZM (R)	;CLEAR I/O CHANNEL WORD
	SETZM IOCHST-IOCHNM(R)	;CLEAR I/O CHNL STATUS WORD
	POPJ P,

STDCLS:	CONO PI,CLKOFF	;INHIBIT CLOCK BREAKS
	SOSGE 1(C)	;DECREMENT USE COUNTER, SKIP IF STILL IN USE AT LEAST ONCE
	SETOM (C)	;NO LONGER IN USER, FREE BY SETOM'ING "XXXUSR" VARIABLE
	CONO PI,CLKON	;ENABLE CLOCK BREAKS
	JRST STDCLX

AVALRET:XCTR XR,[MOVE A,(B)]	;CALL 4,
	MOVEM A,VALUE(U)
	MOVEI T,%PIVAL
	JRST ILLOP4

AUTRAN:	MOVEI A,0	;CALL 5,
	XCTR XR,[MOVE C,(B)]
	HRR C,U
UTRNL:	SKIPN UNAME(A)
	JRST UTRNA
	CAMN C,SUPPRO(A)
	JRST UTFND
UTRNA:	CAML A,USRHI
	POPJ P,
	ADDI A,LUBLK
	JRST UTRNL

UTFND:	MOVE C,UNAME(A)
	XCTR XW,[MOVEM C,1(B)]
	MOVE C,JNAME(A)
	XCTR XW,[MOVEM C,2(B)]
	JRST POPJ1


;RETURN WITH LOSER IN A IN LOSER MODE AND CLOCK OFF
;
RPCCK:	PUSHJ P,RPCLSR	;STOP USER (ALSO PUTS HIM IN USER MODE)
	CONO PI,CLKOFF	;TURN OFF CLOCK
	JRST UPCLSR	;"RESTART USER" (HE CAN'T RUN TILL CLOCK BACK ON)

AUCLOSE:
IFN PDP6P,[
	MOVE A,(R)	;OPER 10
	MOVE A,CLSTB(A)
	TLNE A,100
	JRST PDPUCL
]
	PUSHJ P,AUCL2
	PUSHJ P,1USTOP
	MOVEM A,SRN3(U)
	PUSHJ P,LOSSET
	   AUCL4
	PUSHJ P,AUCL3	;STOP JOB, AND WAIT TILL SAFE TO KILL IT
			;(TURNS CLOCK ON)
	EXCH U,A
	PUSH P,A
	HLLZ T,SUPPRO(U)
	PUSH P,T
	PUSH P,R
	PUSHJ P,UBLAST
	POP P,R
	PUSHJ P,ZUSLOG	;ACCOUNT FOR USAGE THEN FLUSH LAST VESTIGES
	CONO PI,CLKON
	POP P,T
	POP P,U
	ANDCAM T,IFPIR(U)
	JRST LSWDEL

AUCL4:	HRRZ A,SRN3(U)
	MOVSI T,BULGOS
	ANDCAM T,APRC(A)
	POPJ P,

;REMAINING PROBLEM:
;ZUSER CAN CLEAR THE CHANNEL BEGIN .UCLOSE'D, THEN BE PCLSR'ED
;WHILE TRYING TO PCLSR SOMEONE ELSE.  THEN WHEN .UCLOSE IS RESTARTED
;IT WILL FAIL.  LOSEY LOSEY.

AUCL2:	HLRZ A,(R)	;GUY BEING CLOSED
	HRRZ B,(R)
	LDB TT,[330100,,CLSTB(B)]
	JUMPN TT,URET	;NOT INFERIOR
	SKIPL CLSTB(B)
	 JRST IOCER7
	CONO PI,CLKOFF
	MOVE TT,TTYTBL(U)
	JUMPGE TT,AUCL1	;HAVE TTY NOW
	TLNN TT,%TBDTY	;NOT GIVING IT AWAY.
	 CAIE A,(TT)	;SKIP IF GAVE IT TO GUY WE'RE KILLING
	  JRST AUCL1
	PUSHJ P,SDTTY	;TAKE IT BACK FROM HIM.
	 JFCL
AUCL1:	HLRZ A,(R)
	POPJ P,

;DISMIS SYSTEM CALL. 1ST ARG INT PDL PTR (WILL BE DECREMENTED
;IF NOT AN IMMEDIATE ARG)
;2ND ARG OPTIONAL PC TO DISMIS TO (OVERRIDES THAT IN INT PDL)
;3RD ARG OPTIONAL NEW .DF1 VALUE       "       "    "     "
;4TH ARG OPTIONAL NEW .DF2 VALUE ...
;IF 4 ARGS GIVEN, 1ST IGNORED EXCEPT FOR POSSIBLY DECREMENTING.
NDISMIS:	MOVE E,A	;GET IN E THE INT PDL PTR.
	TLNN E,1000	;IF 1ST ARG IMMEDIATE, IT IS PTR,
	 XCTR XR,[MOVE E,(A)] ;ELSE IT PTS TO PTR.
	CAIGE W,2	;IF NO 2ND ARG, GET PC FROM INT PDL
	 XCTR XR,[MOVE B,(E)]
	CAIGE W,3	;IF NO 3RD ARG, GET .DF1 FROM INT PDL
	 XCTR XR,[MOVE C,-2(E)]
	CAIGE W,4	;IF NO 4TH ARG GET .DF2 FROM INT PDL
	 XCTR XR,[MOVE D,-1(E)]
	TLNE A,1000	;IF 1ST ARG NOT IMMED, DECREMENT IT
	 JRST NDISM3
	SUB E,[5,,5]
	XCTR XW,[MOVEM E,(A)]
	JUMPGE E,NDISM3	;AND CHECK FOR PDL OVFLO.
	CAML E,[-5,,]
	 PUSHJ P,NDISMP	;PDL OVFLO, SET INT BIT IF INT ENABLED.
NDISM3:	MOVEM C,IDF1(U)	;RESTORE THE PC, .DF1, .DF2
	MOVEM D,IDF2(U)
	JRST NDISM1

NDISMP:	MOVEI TT,%PIPDL	;PDL OV INT BIT.
	TDNE TT,MSKST(U)
	 IORM TT,PIRQC(U)
	POPJ P,

ADISMIS:	XCTR XR,[MOVE B,(B)]	;CALL 1,
NDISM1:	TLO B,%PCUSR
	TLZ B,BADPC
	SKIPGE IOTLSR(U)
	TLO B,%PCUIO
	MOVEM B,UUOH
	SETOM PICLR(U)

;CHECK  FOR PENDING INTERRUPTS AND TAKE THEM RIGHT AWAY
APISE1:
IFN PDP6P,[
	CAMN U,PDPISR
	CONO DSDEV,DSDCHN	;ENABLE INTERRUPT FROM 6
]
	MOVE A,U
	PUSHJ P,APISE6	;SEE IF ANY DEVICES WANT TO RE-INTERRUPT.
	MOVEI C,%PIARO
	ANDCAB C,PIRQC(U)
	SETCM D,MSKST(U)
	IOR D,IDF1(U)	;FIND ALL DISABLED OR DEFERRED
	SKIPN PICLR(U)	;(ALL ARE DEFERRED WHEN PI IS OFF).
	 SETO D,
	AND D,[BADBTS]	;BAD
	TDNE C,D	;PENDING INTERRUPTS
	 JRST ADISM7	;IF THERE ARE ANY, LET THEM HAPPEN.
	AND C,MSKST(U)
	ANDCM C,IDF1(U)
	JUMPN C,ADISM7	;1ST WD INT. PENDING.
	MOVE C,IFPIR(U)
	AND C,MSKST2(U)
	ANDCM C,IDF2(U)
	JUMPE C,CPOPJ	;JUMP IF NO 2ND WORD INT PENDING.
ADISM7:	MOVE C,[JRST ONEFLS]
	MOVEM C,UEXIT
	POPJ P,

APISE6:	MOVE D,MSKST(A)	;IF INTERRUPT FROM CONSOLE ENDBLED,
	TRNN D,%PITYI
	 JRST APISE7
	SKIPL T,TTYTBL(A) ;IF THIS JOB HAS ITS CONSOLE
	SKIPN TINTC(T)	;AND THE CONSOLE HAS INT. CHARS,
	 JRST APISE7
	MOVEI D,%PITYI	;GENERATE AN INTERRUPT.
	IORM D,PIRQC(A)
APISE7:	MOVE D,MSKST2(A) ;LOOK AT HIS ENABLED IO CHANNELS.
	ANDI D,177777
APISE0:	JFFO D,APISE9	;CHECK EACH ONE.
	JRST APISE8	;ALL CHECKED.

APISE9:	MOVNS E		;CHECK ONE IO CHNL THAT'S ENABLED TO INT.
	ANDCM D,CHNBIT+35.(E) ;MARK THIS CHNL AS HANDLED.
	ADDI E,35.+IOCHNM(A)  ;GET ADDR OF IOCHNM WD FOR CHANNEL.
	HRRZ T,(E)	;IS IT A TTY INPUT CHANNEL?
	CAIL T,TYIDN
	CAILE T,TYIBN
	 JRST APISE2
	LDB T,[$TIIDX,,(E)] ;YES, GET THE TTY NUMBER.
	HRRZ C,TTYSTS(T)
	CAIE T,%TINON	;IF IT ISN'T A DISOWNED TY CHANNEL,
	CAIE C,(A)	;AND THE TTY BELONGS TO THIS JOB,
	 JRST APISE0
	SKIPN TINTC(T)	;AND IT HAS AN INT. CHAR WAITING,
	 JRST APISE0
	MOVE C,TYIMSK(T)
APISE4:	AND C,MSKST2(A)	;GIVE AN INT. ON ONE OF THE CHANNELS IT'S OPEN ON.
	MOVN T,C
	AND C,T
	IORM C,IFPIR(A)
	JRST APISE0

APISE2:	CAIN T,STYDUI	;NOT A TTY CHNL. IS IT A STY CHNL?
	 JRST APISE3
	CAIE T,STYDBI
	 JRST APISE0
APISE3:	LDB T,[$TIIDX,,(E)]	;YES, GET TTY #.
	SKIPL C,STYSTS-NFSTTY(T) ;STY IN USE BY THIS JOB?
	CAIE C,(A)
	 JRST APISE0
	SKIPGE TTYOAC(T)	;TTY OUTPUT PENDING?
	 JRST APISE0
	MOVE C,STYMSK-NFSTTY(T)	;YES, INT. ON ONE CHANNEL.
	JRST APISE4

APISE8:
IFN STKP,[
	SKIPL C,STKUSR
	CAIE C,(A)
	 POPJ P,
	HRRZ C,STKMSK
	AND C,MSKST2(A)
	SKIPLE STKBC
	IORM C,IFPIR(A)
]
	POPJ P,

;.SLEEP AC,	;IF C(AC) + OR ZERO:	;BECOME DORMANT FOR C(AC) 1/30'THS OF A SEC
		;IF C(AC) -:	;BECOME DORMANT TILL MAGNITUDE OF C(AC) > C(TIME)
ASLEEP:	XCTR XR,[MOVN T,(J)]	;PICK UP NEGATIVE OF C(AC)
	JUMPGE T,ASLP1	;JUMP IF C(AC) WAS NEG
	SUB T,TIME	;COMPUTE NEG OF TIME SLEEP SHOULD RUN OUT
	XCTR XW,[MOVEM T,(J)]	;STORE BACK SO YOU WILL WIN IF PCLSR'ED OUT
ASLP1:	MOVMS A,T		;MAKE POSITIVE
	SUBI A,60.*30.		;IF SLEEPING FOR MORE THAN A MINUTE
	MOVSI B,400000
	CAMLE A,TIME
	IORM B,USWST(U)		;PUT RIP VAN WINKLE ON ICE
	PCLT
	JRST ASLP2		;ALWAYS GO TO UFLS AT LEAST ONCE

	CAMLE T,TIME	;HANG TILL C(T) LESS THAN C(TIME)
ASLP2:	PUSHJ P,UFLS
	XCTR XW,[SETZM (J)]	;CLEAR OUT ARG (FOR COMPATIBILITY WITH WHEN AC WAS COUNTED OUT)
	JRST CLKONJ	;MAKE SURE CLKCHN ON IN CASE SLEEP WAS 0 & SKIPPED UFLS ENTIRELY

;RELOAD CALL - IGNORE ARGS
;MUST BE FROM TOP LEVEL NON-DISOWNED JOB
;RELOADS AND STARTS SYS: ATSIGN WHATEVER

NRELOAD:SKIPGE SUPPRO(U)
	SKIPGE APRC(U)
	 JRST OPNL40		;NOT TOP LEVEL
	CONO PI,CLKOFF
	PUSHJ P,LOGUPD		;LOG OUT
	PUSHJ P,DMNPLI		;AND IN AGAIN
	PUSHJ P,USRST2		;RESET USER VARS
	CONO PI,CLKON
	SETZM @UTMPTR(U)	;TEMPORARY HIGH PRIORITY
	JRST USTCDR		;LOAD FILE AND START IT

AMASTER:XCTR XR,[MOVE J,(J)]
	CONO PI,CLKOFF	;OPER 61
	SKIPL A,UMASTER
	 JRST AMAST2
	SKIPGE J
AMAST1:	 HRRZM U,UMASTER
	JRST CLKOJ1

AMAST2:	CAME U,A
	 JRST AMAST3
	SKIPL J
	 SETOM UMASTER
	JRST CLKOJ1

AMAST3:	JUMPGE J,CLKOJ1
	SKIPGE TTYTBL(U)
	 JRST CLKONJ	;LOSEY
	PUSHJ P,RPCCK
	CAME A,UMASTER
	 JRST AMASTER
	JRST AMAST1

NLOGIN:	HLRE T,UNAME(U)	
	AOJN T,OPNL31	;JUMP ON ALREADY LOGGED IN
	SKIPL SUPPRO(U)
	 JRST OPNL40	;CAN'T LOG IN IF NOT TOP LEVEL
	JUMPE A,OPNL11
	HLRE T,A
	AOJE T,OPNL11		;BAD NAME
	MOVEI C,0
	CONO PI,CLKOFF
ALOG2:	SKIPN UNAME(C)
	 JRST ALOG4
	MOVE T,JNAME(C)
	CAMN T,JNAME(U)
	CAME A,UNAME(C)
	JRST ALOG3
	SKIPL APRC(C)
	JRST OPNL13	;CONSOLE CONTROLLED TREE ALREADY LOGGED IN THAT NAME
ALOG3:	HRRZ T,SUPPRO(C)
	CAMN T,U	;CAN'T LOGIN IF HAVE INFERIOR
	 JRST OPNL12	; ONLY BECAUSE NO CODE TO SET INFERIOR'S UNAME.	
ALOG4:	ADDI C,LUBLK
	CAMGE C,USRHI
	JRST ALOG2	;LOOP FOR ALL SETS OF PROCEDURE VARIABLES
	MOVSI T,SCLLGI
	HRRZ D,TTYTBL(U)
	PUSHJ P,CWAIT	;WAIT TILL YOU CAN CAUSE MESSAGE TO BE TYPED OUT
	TDNE T,SUPCOR
	MOVEM A,SLGIV
	MOVEM D,SLGIV+1
	MOVEM B,SLGIV+2
	IORM T,SUPCOR
	SKIPL TTYTBL(U)		;SKIP IF NOT CONSOLE CONTROLLED
	 AOS SUSRS		;INCREMENT COUNT OF LOGGED IN CONSOLE CONTROLLED TREES
	MOVEM A,UNAME(U)	;SET UNAME TO WHAT LOGGED IN AS
	MOVEM A,USYSNM(U)	;SET SNAME "
	MOVEM B,TRMNAM(U)
	PUSHJ P,DMNPLI		;GIVE INFO TO DEMON
	JRST CLKOJ1		;TURN CLK ON AND SKIP RETURN

ARSYSI:	MOVE A,[.FNAM2]	;OPER 17
	JRST APTUAJ

ASETM2:	XCTR XR,[MOVE A,1(J)]	;.OPER 5
	MOVEM A,MSKST2(U)
ASETMSK:	XCTR XR,[MOVE D,(J)]	;OPER 4
	MOVE A,U
	MOVEI I,1
	JRST USMASK	;ACT LIKE .SUSET.

ARDTIME:	SKIPA A,TIME	;OPER 17
ARDSW:	DATAI A	;OPER 20
	JRST APTUAJ

ASUPSET:	MOVEI C,177777	;OPER 53
	XCTR XR,[AND C,(J)]
	MOVE D,SUPCOR	;SAVE OLD CONTENTS
	XORB C,SUPCOR
	XCTR XW,[MOVEM C,(J)]
	HRROI A,SUPCOR
	JRST ASPST2

;	.CALL DET
;	ERROR RETURN
;	NORMAL RETURN

;DET:	SETZ
;	SIXBIT /DETACH/
;	SETZ [<JOB SPEC>]	;SEE NCORUI

;DISOWN JOB'S ENTIRE TREE AND FREE CONSOLE.  IF TREE HAS NO
;CONSOLE, JUST MAKES IT DISOWNED.  NO ARG => THIS JOB'S TREE
;ALWAYS SKIPS IF THE JOB SPEC IS REASONABLE.

;CTL BIT 1.1 => DON'T SET SIGN OF APRC (DON'T MAKE TREE "DISOWNED").
;CTL BIT 1.2 => USE SYSTEM TREE'S RESOURCE WORD
;CTL BIT 1.4 => KILL TREE AN HOUR FROM NOW IF IT ISN'T REOWNED

NDETAC:	HLRZ B,A	;XOR LH OF 1ST ARG INTO CTL BITS
	XORM B,CTLBTS(U)
	PUSHJ P,SWTL	;MAKE SURE NOBODY ELSE IS REARRANGING TREES.
	    TREESW
	MOVEI J,(U)	;DEFAULT TO OUR TREE
	JUMPE W,NDETA0	;JUMP IF NO ARGS SUPPLIED
	MOVE J,A	;JOB SPEC
	JSP T,NCORUI	;DECODE ARG, GET USER INDEX IN J
	 JFCL		;IGNORE INFO ON WRITEABILITY
	CAIGE J,LUBLK	;DONT DETACH SYSJOB OR CORE JOB
	 JRST OPNL31
NDETA0:	SKIPL T,SUPPRO(J)	;FIND TOP LEVEL JOB OF TREE (IN J)
	 JRST [	MOVE J,T 
		JRST NDETA0 ]
	HRRZ A,J	;TOP OF TREE
	SKIPGE APRC(A)
	 JRST LSWCJ1	;TREE IS ALREADY DISOWNED.
	MOVEI Q,NDETA8
	PUSHJ P,IFPLUP	;STOP ALL BUT THIS JOB
	PUSHJ P,NDETA7	;DO THE WORK
	JRST LSWCJ1	;UNSTOP THE TREE

NDETA7:	PUSH P,U	;US
	PUSH P,A	;TOP LEVEL
	MOVEI U,(A)
	CONO PI,CLKOFF
	PUSHJ P,LOGUPD	;FOR ACCOUNTING PURPOSES, THIS IS LIKE A LOGOUT
	CONO PI,CLKON
NDETA1:	MOVEI U,(A)	;GET IN U USER INDEX OF OWNER OF TTY
	MOVE A,TTYTBL(U)	;GET IN A TTY NUMBER
	TLNE A,%TBDTY	;TREE HAS NO TTY =>
	 JRST [	POP P,A	;JUST MAKE IT DISOWNED.
		POP P,U
		JRST NDETA5 ]
	JUMPL A,NDETA1	;GAVE TTY AWAY
	HRRZS A
	PUSH P,TTYSTS(A)	;SAVE THIS TTY INFO
	PUSH P,TTYST1(A)	;WILL PUT INTO TTY OWNER'S USER VARS
	PUSH P,TTYST2(A)	;AFTER SUCCEED IN FREEING THE TTY
	MOVE B,A
	IMULI B,TPLEN*2
	MOVN B,TPVB+TPLEN(B)
	ADD B,TCMXV(A)
	PUSH P,B
	MOVSI B,%TCDET	;IF TREE DETACHED DUE TO TOP LVL INT,
	SKIPN USER	;THE CONSOLE FREE MESSAGE SHOULD SAY SO.
	 IORM B,TTYCOM(A)	.SEE SYSCFM
IFN N11TYS,	PUSHJ P,TVBNCL	;CLEAR VIDEO BUFFER #
	PUSHJ P,TTYLO1	;NOW MAKE CONSOLE FREE.
	POP P,B		;CAN'T PCLSR AFTER THIS POINT
	DPB B,[$TBECL,,TTYTBL(U)]
	POP P,TTSTSV+1(U)	;STORE INTO TTY'S OLD OWNER
	POP P,TTSTSV(U)	;OLD TTY VARS FROM BEFORE FREEING IT
	POP P,B
	MOVEM B,TTSTSV+2(U)
	SKIPA A,(P)	;TOP LEVEL JOB
NDETAA:	 HRRZ A,T
	SKIPGE T,TTYTBL(A)	;SKIP IF HE HAS IT
	 JRST NDETAA	;NOW DO GUY HE GAVE IT TO
	CAIE A,(U)
	 JRST 4,.	;BUT.  BUT.  BUT.
	MOVSI B,%TBNOT+%TBDTY	;TAKEN FROM --ME-- AND DOESN'T HAVE IT
	IORM B,TTYTBL(A)
	HLLZS TTYTBL(A)
	POP P,A		;TOP LEVEL
	POP P,U		;US
	HLRO B,UNAME(A)
	AOSE B		;IF DETACHED TREE WAS LOGGED IN
	 SOS SUSRS	;ONE LESS CONSOLE CONTROLLED TREE
NDETA5:	MOVSI B,BUMRTL	;IF REQUESTED, MARK TREE AS DUE TO DIE
	MOVE D,CTLBTS(U) ;IN AN HOUR.
	ANDCAM B,APRC(A)
	TLNE D,10
	 IORM B,APRC(A)
	MOVE D,JNAME(A)	;IF TOP LEVEL JOB ...
	CAME D,[SIXBIT /HACTRN/]	;IS A HACTRN,
	 JRST NDETA3
NDETA2:	AOS D		;AOS ITS NAME LEVEL UNTIL ...
	PUSHJ P,UJNAMU	;IT IS UNIQUE
	 JRST NDETA2	;(UJNAMU TURNS OFF CLOCK)
	MOVEM D,JNAME(A)
NDETA3:	CONO PI,CLKOFF
	EXCH U,A
	PUSHJ P,DMNPLI	;LOG BACK IN, NAME MAY HAVE CHANGED FROM HACTRN TO HACTRO
	EXCH U,A
	CONO PI,CLKON
	MOVEI Q,NDETA9	;NOW SAY ALL JOBS IN TREE
	JRST IFPLUP	;ARE DISOWNED

NDETA8:	CAIE A,(U)	;IF JOB ISN'T SELF, STOP IT
	 JRST IFSTOP
	POPJ P,

;"ATTACH" SYSTEM CALL:
;1ST ARG - JOB SPEC -> OUR INFERIOR, OR TOP OF A DISOWNED TREE.
;2ND ARG - TTY SPEC (OF A TTY WHICH MUST BE FREE)
 ;2ND ARG ABSENT => USE OUR CONSOLE, AND GUN OUR TREE
;CONTROL BIT 400000 => CHANGE JOB'S NAME TO HACTRN (IF 2 ARGS)

;CONNECTS THE SPECIFIED JOB TO THE SPECIFIED TTY, AS A CONSOLE CONTROLLED TREE.
;IF THE TTY IS OUR CONSOLE, WE ARE LOGGED OUT.
;IF THE JOB IS OUR INFERIOR, IT IS FIRST DISOWNED.

NATTAC:	PUSHJ P,SWTL
	    TREESW
	SOJE W,NATTAN
	EXCH A,B	;2ND ARG => IT IS TTY SPEC, SO DECODE IT.
	JSP J,ATTYCK
	MOVE A,B
	MOVE B,I	;AND PUT IT IN B.
	JRST NATTA6

NATTAN:	SKIPL B,SUPPRO(U) ;NO 2ND ARG => WE MUST BE TOP LEVEL, SINCE WE'LL HAVE
	 JRST OPNL40	  ;TO LOG OUT. B GETS NEGATIVE.
NATTA6:	MOVE J,A
	JSP T,NCRUI2	;DECODE 1ST ARG, GET USR IDX IN J.
	 JFCL
	SKIPGE A,SUPPRO(J)
	 JRST NATTA5	;JOB SPEC'D MUST BE EITHER
	CAIE U,(A)	;OUR INFERIOR, OR
	 JRST OPNL31
	JRST NATTA7

NATTA5:	SKIPL APRC(J)	;THE TOP OF A DISOWNED TREE.
	 JRST OPNL31
;NOW IF TTY IS OUR CONSOLE, B IS NEGATIVE; OTHERWISE, B HAS TTY #.
NATTA7:	PUSH P,CTLBTS(U)
	SETZM CTLBTS(U)	;DON'T GET FAKED OUT AT NATTA1, NATTA2, DSWNTY.
	PUSH P,J
	MOVE A,J
	MOVEI Q,NDETA8	;STOP SPEC'D JOB AND ITS INFERIORS.
	PUSHJ P,IFPLUP
	JUMPL B,NATTAG
NATTAM:	CONO PI,TTYOFF
	SKIPL T,TTYSTA(B)	;SEE IF TTY IS FREE
	 JRST NATTAL
	MOVSI T,(SETZ)	;IT IS, GRAB IT
	ANDCAM T,TTYSTA(B)	.SEE %TACFM
	ANDCAM T,TTYSTS(B)	.SEE %TSFRE
	CONO PI,TTYON
	JRST NATTA8	;SINCE NO PCLSR POSSIBLE, DON'T BOTHER WITH A LOSSET OF THESE

NATTAL:	HRRE Q,TTYSTS(B)
	CONO PI,TTYON
	SKIPG Q		;IF TTY IS IN USE
	TLNE T,%TACTZ	;OR BEING ^Z'ED, DEVICE NOT AVAIL
	 JRST [ SUB P,[2,,2] ? JRST OPNL10 ]
	MOVSI T,%TACFM+%TACTZ	;OTHERWISE JUST WAIT FOR CONSOLE FREE
	TDNN T,TTYSTA(B)	;MESSAGE TO FINISH COMING OUT
	 PUSHJ P,UFLS
	JRST NATTAM

NATTAG:	MOVE A,U	;IF HACKING OUR CONSOLE, MUST STOP OUR WHOLE TREE
	MOVEI Q,NDETA8	;(EXCEPT US, OF COURSE - NDETA8 CHECKS THAT).
	PUSHJ P,IFPLUP
	MOVEI B,(U)
NATTA4:	MOVE B,TTYTBL(B) ;FIND THE TTY'S NUMBER.
	TLNE B,%TBDTY
	 JRST NATTAL	;THIS TREE HAS NO TTY?
	JUMPL B,NATTA4	.SEE %TBNOT
	PUSHJ P,SDTTY	;GET TTY BACK TO TOP OF TREE FOR AGBLT3 LATER.
	 JRST 4,.
	HRRO B,TTYTBL(U)
;I BELIEVE THAT NOTHING CAN PCLSR BEYOND THIS POINT.
;RH OF B HAS TTY #; SIGN IS SET IF TTY IS OUR CONSOLE.
NATTA8:	AOS TTNTO(B)	;KEEP DSWNTZ FROM HALTING (WILL UNDO THIS LATER)
	PUSH P,B	;PUSH <CONSOLE-FLAG>,,<TTY #>
	HRRZ A,-1(P)	;LEGALITY OF CALL FULLY CHECKED; CAN START ALTERING.
	SKIPGE APRC(A)	;IF SPEC'D JOB IS OUR INFERIOR, DISOWN IT.
	 JRST NATTA9
	MOVE B,TTYTBL(A)
	TLNE B,%TBDTY	;IF THE INFERIOR HAS THE TTY, TAKE IT AWAY.
	 JRST NATTAF
	PUSHJ P,SDTTY
	 JRST 4,.
NATTAF:	HRRZ A,-1(P)
	MOVEI Q,DSWNTY	;JUST LIKE .DISOWN, BUT KNOW JOBS ARE ALREADY STOPPED.
	PUSHJ P,IFPLUP
	PUSHJ P,NATTA1
NATTA9:	MOVEI Q,NATTA2
	MOVE A,U
	SKIPGE (P)	;IF HACKING OUR CONSOLE, DISOWN OUR TREE SO IT IS FREE.
	 PUSHJ P,IFPLUP
			;OUR TTY NOW IN INCONSISTENT STATE SINCE WE ARE DISOWNED
			;BUT TTY STILL BELONGS TO US. AGBLT3 FIXES THAT.
	MOVE B,(P)
	SOSGE TTNTO(B)
	 JRST 4,.
	MOVE TT,-1(P)	;NOW "RE-OWN" THE SPEC'D JOB
	MOVE A,UNAME(TT);NOT CHANGING ITS UNAME
	HRRZ J,B	;TO THE DESIRED TTY, WITH APPRO. RESOURCE WORD.
	MOVEI D,USRRCE(B)
	SETZ B,		;NO INTERRUPT BIT NEEDED.
	SETOM DLSRCH	;INHIBIT SCHEDULING (UFN2A UNDOES THIS)
	PUSH P,U
	PUSHJ P,UFN2A
	POP P,U
	HRRZ A,-1(P)
	SKIPA C,A
NATTAH:	 MOVE C,D	;FIND THE JOB IN THE TREE BEING ATTACHED
	MOVE D,TTYTBL(C)
	TLNN D,%TBDTY	;THAT IS SUPPOSED TO GET CONTROL OF THE TTY.
	 JRST NATTAH
	SETOM SUPPRO(A)	;BUT DON'T LEAVE IT THINKING IT IS OUR INFERIOR.
	SKIPGE I,(P)
	 JRST NATTAD
	HLRE B,UNAME(A)	;ATTACHING JOB TO FREE TTY:
	AOSE B	
	 AOS SUSRS	;THIS MAY MEAN 1 MORE LOGGED IN CONSOLE-CTL'ED TREE.
	CONO PI,TTYOFF
	PUSHJ P,TTYINI	;INIT TTYOPT, ECHO AREA, TTYCOM, TTYSTA.
	MOVSI B,%TSFRE	;NOW MAKE TTY'S TTYSTS HAPPY
	ANDCAM B,TTYSTS(I)
	MOVSI B,%TSCNS
	IORM B,TTYSTS(I)
	HRRM A,TTYSTS(I)
	CONO PI,TTYON#1	;TTYCHN ON, BUT NOT CLKCHN.
	MOVE D,['HACTRN]
	PUSHJ P,UJNAMU
	 JRST NATTAI
	MOVE B,-2(P)	;SAVED CTLBTS(U) AT ENTRY
	TRNN B,400000
	 MOVEM D,JNAME(A)
NATTAI:	MOVE A,U
	HRRZ U,C
	PUSHJ P,AGBLT4	;MOVE HIS PER-JOB VARIABLES INTO THE TTY'S VARIABLES, ETC.
	JRST NATTAE	;CLOCK IS NOW BACK ON.

NATTAD:	CONO PI,CLKOFF
	MOVE J,JNAME(U)	;ATTACHING OUR TTY TO JOB:
	MOVEM J,JNAME(A) ;GIVE JOB OUR JNAME ALONG WITH OUR TTY.
	MOVE A,U
	HRRZ U,C
	PUSHJ P,AGBLT6	;TRANSFER TTY TO HIM, SAVING OUR TTY STATE AND LOADING HIS.
NATTAE:	MOVE U,A
	POP P,B
	EXCH U,(P)	;U := USER INDEX OF TOP OF TREE BEING ATTACHED
	MOVSI T,BUMRTL	;SINCE TREE HAS BEEN ATTACHED, IT SHOULDN'T
	ANDCAM T,APRC(U) ;DIE AN HOUR AFTER IT WAS DETACHED.
	HLRE T,UNAME(U)
	CONO PI,CLKOFF
	AOSE T
	 PUSHJ P,DMNPLI	;LOG HIM IN
	CONO PI,CLKON
	POP P,U
	SUB P,[1,,1]	;FLUSH SAVED CTLBTS
	PUSHJ P,LSWCLR	;UNSTOP THE JOBS AND FREE TREESW
	JUMPGE B,POPJ1	;RETURN IF WE DIDN'T GIVE AWAY OUR CONSOLE.
	SETOM TTYTBL(U)	;DON'T WANT ALOGOU TO TYPE LOGOUT MESSAGE.
	JRST ALOGOUT	;LOG THIS JOB OUT.

;.CALL DISOWN
; RH OF ARG IS JOB SPEC, OF OUR INFERIOR.
; LH OF ARG XOR CONTROL BITS:
;  1.1 => RETAIN PRIORITY (DON'T SET APRC)
;  1.2 => USE SYSTEM RESOURCE
;  1.3 => CLEAR .USTP AFTER DISOWNING (THUS AVOIDING TIMING ERROR)
;  1.4 => SET BUMRTL SO THAT JOB WILL BE GUNNED IF IT IS STOPPED FOR A WHOLE HOUR
;	   AND NOT REOWNED OR ATTACHED.

NDISOWN:HLRZ J,A
	XORM A,CTLBTS(U) ;XOR LH OF 1ST ARG INTO CTL BITS.
	HRRZ J,A
	JSP T,NCRUI2	;DECODE JOB SPEC; DON'T SET DIELOK.
	 JFCL
	CAIN J,-1
	 JRST OPNL31	;PDP6 NO GOOD.
	HRRZ A,J
	HRRZ J,SUPPRO(A)
	CAME J,U
	 JRST OPNL31	;NO GOOD IF NOT OUR INFERIOR.
	JRST NDISO1	;JOIN OLD-STYLE DISOWN

;.DISOWN CH,	;MAKES DIRECTLY INFERIOR PROCEDURE OPEN ON CHANNEL CH
		;THE TOP LEVEL JOB OF A DISOWNED JOB

ADISOWN:HRRZ B,(R)	;PICK UP CH TYPE INDEX
	SKIPL CLSTB(B)	;SKIP IF AN INF. USER CHANNEL
	 JRST IOCER7	;OTHER TYPE, GIVE IOC ERROR
	HLRZ A,(R)	;PICK UP INF.'S INDEX
	SETZM CTLBTS(U)
NDISO1:	PUSHJ P,SWTL
	    TREESW
	MOVE B,TTYTBL(A)
	TLNE B,%TBDTY	;SKIP IF TTY TAKEN AWAY
	 JRST ADISO1
	PUSH P,A	;JOB TO BE DISOWNED HAS THE TTY: TAKE IT AWAY.
	PUSHJ P,SDTTY
	 JRST 4,.
	POP P,A
ADISO1:	MOVEI Q,DSWNTY
	PUSHJ P,IFPHAK	;HACK INFERIORS
	PUSHJ P,NATTA1	;FLUSH POINTERS TO INFERIOR, AND SET FLAGS
	JRST LSWCJ1	;UNSTOP HIS TREE AND FREE TREESW

NATTA1:	EXCH U,A
	PUSHJ P,ZUSES	;FLUSH POINTERS TO INFERIOR
	EXCH U,A
	SETOM SUPPRO(A)	;MARK AS TOP LEVEL
	MOVE W,CTLBTS(U)
	MOVSI TT,BUSRC	;CLEAR .USTP IF REQUESTED
	TRNE W,4
	 ANDCAM TT,USTP(A)
	MOVSI TT,BUMRTL
	TRNE W,10
	 IORM TT,APRC(A)
	POPJ P,

DSWNTY:	SKIPL TTYTBL(A)
	 JRST 4,.	;CHECKED AT HIGHER LEVEL, DATA INCONSISTENT
NATTA2:	TDZA T,T	;DO SOS TTNTO OF CONSOLE TTY.
NDETA9:	 SETO T,	;DON'T.
	PUSHJ P,CHSCAA	;LOOK AT ALL CNHLS
	PUSHJ P,DSWNTZ	;BLESSING CONSOLE TTY CHNLS
	MOVEI TT,SYSRCE	;SET RESOURCE POINTER TO SYSTEM OR DISOWNED
	MOVE W,CTLBTS(U);DEPENDING ON CTLBTS
	TRNN W,2
	 MOVEI TT,USRRCE+NCT
	MOVEM TT,UTMPTR(A)
	MOVSI T,400000
	TRNN W,1
	 IORM T,APRC(A)	;MARK AS DISOWNED
	POPJ P,

;BLESS CONSOLE TTY CHANNELS. IF T NONZERO, DON'T SOS TTNTO.
DSWNTZ:	MOVS B,(R)	;GET IOCHNM WORD
	HLRZ J,B	;GET DEV TYPE INDEX
	CAIL J,TYIDN	;SKIP IF LESS THAN LEAST TTY INDEX
	CAILE J,TYOBN	;SKIP UNLESS .LTEQ. HIGHEST
	 POPJ P,		;NOT A TTY CHANNEL
	TRZ B,377700
	TRZE B,400000	;SKIP IF NOT A CONSOLE TTY
	CAIN B,%TINON	;DO NOTHING TO "DISOWNED" TTY CHNLS
	 POPJ P,
	MOVEI J,%TINON	;CHANGE OTHER TTY CHNLS TO DISOWNED
	DPB J,[220700,,(R)]	;CHNLS.
	JUMPN T,CPOPJ	;IN NDETAC, TTNTO ALREADY SETZM'D.
	SOSLE TTNTO(B)	;DECREMENT OPEN COUNT
	 POPJ P,
	JRST 4,.	;SHOULD BE OPEN AT HIGHER LEVELS

;ROUTINE TO SCAN ALL I/O CHANNEL AND I/O PDL SLOTS OF A PROCEDURE
;R 4.9=1 => REGULAR CHANNEL  4.9=0 => IOPUSHED CHANNEL
CHSCAA:	MOVEI R,IOCHNM(A)
CHSCAN:	HRLI R,-20
CHSCA2:	XCT @(P)
	AOBJN R,CHSCA2
	HRLI R,-<LUIOP/2>+400000
CHSCA4:	XCT @(P)
	ADD R,[1,,2]
	JUMPG R,CHSCA4
	JRST POPJ1
;
;IFPHAK AND IFPLUP TAKE A USER INDEX IN A AND THE ADDRESS OF A ROUTINE
;	IN Q.  THEY CALL THE ROUTINE FOR THE PROCEDURE AND ALL OF ITS
;	INFERIORS BUT IFPHAK ALSO STOPS THE SPECIFIED PROCEDURE AND
;	ALL ITS INFERIORS STRINGING THEIR USTP'S INTO THE CURRENT USER'S
;	LSWPR.
;
IFPHAK:	PUSH P,U
	PUSH P,Q
	MOVE U,USER	;MADE SURE YOU USE THE RIGHT LSWPR
	MOVEI Q,IFSTOP	;SET UP TO STOP
	PUSHJ P,IFPLUP
	POP P,Q
	POP P,U
IFPLUP:	PUSH P,E	;SAVE E
	PUSH P,H	; " H
	SKIPA H,A
IFPLU5:	MOVE A,E	;RECURSE
	PUSH P,H
	PUSH P,Q
	PUSHJ P,(Q)	;CALL ROUTINE
	POP P,Q
	POP P,H
	MOVEI E,LUBLK*2	;INITIALIZE TO INDEX OF JOB AFTER CORE JOB
IFPLU2:	SKIPN UNAME(E)
	JRST IFPLU3
	HRRZ T,SUPPRO(E)
	CAIN T,(A)
	JRST IFPLU5
IFPLU3:	ADDI E,LUBLK	;STEP TO NEXT VAR BLOCK
	CAMGE E,USRHI	;SKIP IF ALL EXAMINED
	JRST IFPLU2	;NOT ALL, CONTINUE
	CAME H,A	;ALL, SKIP IF BACK TO TOP LEVEL
	JRST IFPLU4	;NOT AT TOP LEVEL, POP UP
	POP P,H		;RESTORE H
	POP P,E		; " E
	POPJ P,		;RETURN FROM CALL TO IFPLUP

IFPLU4:	MOVE E,A	;POP
	HRRZ A,SUPPRO(A)	;UP
	JRST IFPLU3	;AND CONTINE

IFSTOP:	PUSHJ P,RPCLSR	;STOP ROUTINE WHOSE INDEX IS IN A
	HRRZ T,USTP(A)
	SOJE T,IFSTP1
	SKIPE LSWB0+1(A)
	JRST UPCLSR	;HAVE ALREADY HACKED THIS GUY
IFSTP1:	MOVEI T,USTP(A)	;GET LOC OF USTP (WAS AOSED BY RPCLSR)
	MOVEI H,LSWB0(A)	;GET LOC OF A LOCKED SWITCH BLOCK OF PROC STOPPED
	MOVEM T,(H)	;SET WD1
	PUSH P,U
	HRRZ T,U
	IDIVI T,LUBLK
	POP P,U
	HRL T,LSWPR(U)
	IORI T,600300	;SOS WHEN UNLOCKED
	MOVSM T,1(H)
	MOVEM H,LSWPR(U)	;ADD TO LOCKED SWITCH LIST OF USER
	POPJ P,

UBLAM:	SKIPL APRC(U)	;SKIP IF DISOWNED
	 PUSHJ P,SDTTY	;GET TTY UP TO THIS LEVEL
	  JFCL
UBLAST:	PUSHJ P,IODCL	;CLOSE IO DEVICES ETC
UBLST2:	SETZ B,
UBLST3:	PUSH P,U	;DO NOT USE THIS ROUTINE FOR CORING UP.
	MOVE Q,U
	MOVE U,USER
	PUSHJ P,ACRF1	;CORE DOWN TO NUM OF BLOCKS IN B
	JRST 4,.
	POP P,U
	POPJ P,


AEOFC:	XCTR XR,[MOVE B,(J)]
	LDB B,[400,,B]	;OPER 50
	ADDI B,IOCHNM(U)
	MOVE A,(B)
	MOVE A,CLSTB(A)
	HLR A,(B)
IFN NUNITS,	TLNE A,40000
.ALSO		SKIPA A,UTEOF(A)
	MOVEI A,EOFCH
	JRST APTUAJ

;OPER TO REQUEST OR FLUSH RUNNING IN IOT USER MODE
AIOTLS:	MOVSI A,400000
	MOVSI B,%PCUIO
	XCTR XR,[SKIPGE (J)]
	 JRST AIOTL1	;JUMP IF WANT TO ENTER IOTLSR MODE
	ANDCAM A,IOTLSR(U)
	ANDCAM B,UUOH
	POPJ P,

AIOTL1:	SKIPGE IOTLSR(U)
	 POPJ P,	;ALREADY IN IOTLSR
	PUSHJ P,SYSMSG
	  660,,[ASCIZ/~ ~ IOTLSR/]
	  UNAME(U)
	  JNAME(U)
	MOVEI T,SCRMSG	;WAIT FOR IT TO BE PRINTED (HA HA WHAT ABOUT BUFFERING?)
	TDNE T,SUPCOR
	 PUSHJ P,UFLS
	IORM A,IOTLSR(U)
	IORM B,UUOH
	JRST CLKONJ

SUBTTL FILENAME TRANSLATION

;ROUTINE TO TRANSLATE A FILENAME.
;WANTS DEV, FN1, FN2, SNAME IN A, B, C, D RESP. LEFT-JUST.
;WANTS MODE IN RH OF E.
;RETURNS TRANSLATED NAMES IN SAME PLACE.
TRAN:	SKIPN D	;MAYBE DEFAULT THE SNAME.
TRAN6:	MOVE D,USYSNM(U)
	MOVEM B,EPDLT1(U)
	MOVEM C,EPDLT2(U)
	MOVEM D,EPDLT3(U)
	MOVEM A,EPDLT4(U)
	SKIPN TRNCNT	;IF NO TRANSL. ENTRIES IN USE,
	JRST POPJ1	;SHORT CUT.
	PUSHJ P,TRANRF	;GET READ ACCESS TO TRANSL LISTS.
	LDB I,[100,,E]	;GET INPUT/OUTPUT BIT.
	MOVEI H,10	;MAX. NUM. TRANSLS ALLOWED.
TRAN0:	HRROI Q,(U)	;1ST TRY THIS JOB'S TRNLST.
	MOVE J,TRNLST(U)
	JRST TRAN5
TRAN1:	SKIPGE Q,SUPPRO(Q)	;MOVE UP TREE TO TRNLS1.
	SETZ Q,		;AFTER TOP OF TREE, USE SYS.
TRAN2:	MOVE J,TRNLS1(Q)	;USE THIS GUY'S TRNLS1.
	MOVEI Q,(Q)	;INDICATE THAT FACT IN SIGN.
	JRST TRAN5
TRAN3:	CAME B,TRANI1(J)	;ENTRY'S FN1 MATCHES
	SKIPN TRANI1(J)	;OR IS NULL?
	SKIPA TT,TRANI2(J)	;YES, GET FN2.
	JRST TRAN4	;NO, TRY NEXT ENTRY.
	CAME TT,C	;FN2 MTCHES OR NULL.
	JUMPN TT,TRAN4
	CAME D,TRANIS(J)	;SNAME ?
	SKIPN TRANIS(J)
	SKIPA TT,TRANID(J)	;YES, GET DEV.
	JRST TRAN4
	CAME A,TT
	JUMPN TT,TRAN4	;TEST DEV.
	HLRZ TT,TRANLK(J)	;GET ENTRY'S MODE BITS.
	TRNN TT,1(I)	;TRANSLATE OUR MODE?
	JRST TRAN4	;NO.
	MOVEM B,EPDLT1(U)
	MOVEM C,EPDLT2(U)
	MOVEM D,EPDLT3(U)
	MOVEM A,EPDLT4(U)
IRPS X,,OD O1 O2 OS
	SKIPE TRAN!X(J)
	MOVE A+.IRPCN,TRAN!X(J)
TERMIN			;REPLACE NAMES FROM ENTRY.
	TRNE TT,400000	;ATOMIC?
	JRST TRANX3	;YES, EXIT.
	SOJG H,TRAN0	;ELSE RETRANSL.
	JRST TRANX2	;IF TOO MANY TRANSL., DON'T SKIP.

TRAN4:	HRRE J,TRANLK(J)	;CDR DOWN LIST.
TRAN5:	JUMPGE J,TRAN3	;TRY NEXT UNLESS AT END.
	JUMPL Q,TRAN2	;IF DID TRNLST, DO SAME JOB'S TRNLS1.
	JUMPN Q,TRAN1	;ELSE DO SUPPRO'S TRNLS1.
TRANX3:	AOS (P)		;EXIT IF DID SYS.
TRANX2:	SOS TRNREF	;NO LONGER USING TRANSL. LISTS.
	POPJ P,

TRANRF:	AOS TRNREF	;SAY USING TRANSL. LISTS.
	SKIPGE TRANSW
	POPJ P,		;OK IF NOT BEING CHANGED.
	SOS TRNREF	;NOT REFERENCING AFTER ALL.
	SKIPL TRANSW	;WAIT TILL FREE.
	PUSHJ P,UFLS
	JRST TRANRF	;TRY AGAIN.
;TRANS SYSTEM CALL.
NTRNS:	JSP T,DEFARG	;DEFAULT 5 ARGS TO 0.
	5
	XOR E,CTLBTS(U)	;XOR CTL BITS WITH ARG S
	PUSHJ P,TRAN	;TRANSLATE NAME.
	 JRST OPNL3		;FAIL IF TOO MANY TRANSL.
	JRST POPJ1	;ELSE GIVE BACK TRANSL'D NAMES.


DEFARG:	CAML W,(T)	;IF NOT ALL SPEC'D,
	JRST 1(T)
	SETZM A(W)	;DEFAULT ONE AND RETRY.
	AOJA W,DEFARG

;LOCK TRANSW, AND SET UP 1ST ARG FOR NTRNAD, NTRNDL, NTRNCL.
;RH OF A HAS JOB SPEC; CONTROL BIT ARGS XOR'D INTO LH.
;THE 4.8 BIT, IF SET, INDICATES TRNLS1 RATHER THAN TRNLST.
;OTHER LH BITS IGNORED,, NOT CHANGED BY NTRNUI.
;ON RETURN, A'S LH IS UNCHANGED, RH IS SUCH THAT
;   TRANLK(A) IS THE ADDR OF THE SPECIFIED TRNLS VAR.
NTRNUI:	PUSHJ P,SWTL
	 TRANSW
	TSC A,CTLBTS(U)
	MOVEI J,(A)
	JSP T,NCRUI2	;DECODE THE JOB-SPEC.
	 JRST NTRNU1	;JOB GUARANTEED WRITEABLE.
	JSP T,NCORWR	;ELSE CHECK.
	 JRST OPNL31	;NOT WRITEABLE.
NTRNU1:	CAIN J,-1
	 JRST OPNL34	;PDP6??
	HRRI A,TRNLST-TRANLK(J)
	TLNE A,200000	;4.8 BIT SAYS WHICH TRNLS TO USE.
	ADDI A,TRNLS1-TRNLST
	JRST (Q)

;GET UP TO 4 ARGS INTO D ... D+3, FROM AOBJN PTR IN B.
NTRNGA:	MOVSI H,-4	;UP TO 4 ARGS.
	JUMPGE B,NTRNG3
NTRNG0:	XCTR XR,[MOVE J,(B)]
	JUMPGE W,NTRNG2	;W IS -1 FOR .TRANA, .TRAND;
	TRNN H,-1	;IN THAT CASE LEFT-JUST. DEV. (1ST ARG)
	HRLZI J,(J)
NTRNG2:	CAMN J,[SIXBIT/*/]
	MOVEI J,0	;REPLACE * BY BLANK.
	MOVEM J,D(H)	;STORE AWAY.
	AOBJP H,CPOPJ	;DONE AFTER 4TH ARG.
	AOBJN B,NTRNG0	;ELSE GET NEXT.
NTRNG3:	SETZM D(H)	;ZERO REMAINING ARGS.
	AOBJN H,NTRNG3
	POPJ P,
;TRANEX CALL  --  READ IN A JOB'S TRANSL LIST.
;1ST ARG RH - JOB SPEC. BIT 4.8 - IF SET, TRNLS1 NOT TRNLST.
;2ND ARG AOBJN -> PLACE TO STORE LIST INTO.
;UPDATED AOBJN PTR IS OUTPUT ARG.
;SKIPS IF ENTIRE LIST FIT IN BUFFER.
;EACH ENTRY TAKES 9 WDS OF SPACE: MODE,, IN 1ST,
;INPUT DEV, FN1, FN2, SNAME; THEN OUTPUT DEV, FN1, FN2, SNAME.
NTRNEX:	PUSHJ P,TRANRF	;GET READ ACCESS TO TRANSL LISTS.
	PUSHJ P,SOSSET	;RELINQUISH IF BLOCKED.
	TRNREF
	TSC A,CTLBTS(U)
	MOVEI J,(A)
	JSP T,NCRUI2	;DECODE THE JOB SPEC.
	 JFCL		;NOT TRYING TO WRITE.
	HRRI A,TRNLST-TRANLK(J)
	TLNE A,200000	;MAKE TRANLK(A) BE TRNLS VAR.
	ADDI A,TRNLS1-TRNLST
	SUB B,[1,,1]	;SINCE WE AOBJ BEFORE ACTING.
NTRNE1:	HRRE T,TRANLK(A)	;AT END -> RETURN SKIPPING.
	JUMPL T,NTRNE8
	HLLZ D,TRANLK(T)	;RETURN LH ONLY OF 1ST WD.
	TLOA T,-9
NTRNE2:	MOVE D,TRANLK(T)	;ALL OF OTHER 8 WDS.
	AOBJP B,[	PUSHJ P,OPNL37
			JRST NTRNE9]
	;FAIL IF NO ROOM.
	XCTR XW,[MOVEM D,(B)]
	ADDI T,SIOMT-1
	AOBJN T,NTRNE2	;STORE ALL 9.
	MOVEI A,-9*SIOMT(T)	;GO TO NEXT.
	JRST NTRNE1

NTRNE8:	AOS (P)
	AOBJP B,.+1	;COMPENSATE FOR SUB .
	PUSHJ P,LSWPOP	;RELEASE READ ACCESS.
NTRNE9:	MOVE A,B
	JRST SYSCPT	;RETURN AOBJN PTR.
;TRANDL CALL -- DELETE ENTRY FROM TRANSL LIST.
;1ST ARG RH JOB SPEC. OF JOB WHICH IS OK TO MODIFY.
;1ST ARG LH MODE BITS AS FOR .TRANAD, ALSO 4.8 BIT SAYS TRNLS1
;	(SPEC'D JOB AND INFS, RATHER THAN JUST SPEC'D JOB)
;2ND ARG AOBJN -> INPUT DEV, FN1, FN2, SNAME. (ONLY DEV NEC.).
;SKIPS IF SOMETHING WAS DELETED.
NTRNDL:	JSP Q,NTRNUI	;PROCESS 1ST ARG., LOCK TRANSW.
NTRND:	PUSHJ P,NTRNDA	;ACTUALLY DELETE.
	JRST OPNL4	;NOTHING TO DELETE => FILE NOT FOUND
	JRST LSWPJ1	;SKIP IF NTRNDA DID.

NTRNDA:	TLZ A,-1#400003
	PUSHJ P,NTRNGA	;ELSE GET INPUT NAMES.
	SKIPGE TRANLK(A)
	POPJ P,
	HRRZS (P)	;CLEAR SKIP FLAG.
	SKIPA T,A
NTRND2:	MOVEI T,(H)	;CDR DOWN BOTH PTRS.
NTRND0:	HRRE H,TRANLK(T)	;LOOK AT NEXT ENTRY.
	JUMPL H,NTRNDX	;EXIT IF END.
	CAMN D,TRANID(H)	;ALL 4 INPUT NAMES MUST MATCH.
	CAME E,TRANI1(H)
	JRST NTRND2	;ELSE NOT TO BE DELETED.
	CAMN TT,TRANI2(H)
	CAME I,TRANIS(H)
	JRST NTRND2
	HLLZ R,A	;GET MODE FROM ARG.
	TLZ R,400000	;DONT CLOBBER ATOM BIT
	ANDCA R,TRANLK(H)	;TURN OFF IN MODE FROM ENTRY.
	CAME R,TRANLK(H)	;IF DELETED ONE, CALL WILL SKIP.
	HRROS (P)
	MOVEM R,TRANLK(H)
	TLNE R,3		;IF NEITHER DIRECTION LEFT, SPLICE OUT.
	JRST NTRND2
	SKIPE TRNREF	;WAIT TILL NOONE READING TRANSL LISTS.
	PUSHJ P,UFLS
	SOS TRNCNT	;ONE LESS ENTRY IN USE.
	HRRZ R,TRANFL	;MAKE LINK -> CURRENT FREE LIST.
	EXCH R,TRANLK(H)
	HRRM R,TRANLK(T)	;REST OF TRNLS INTO PREDECESSOR'S LINK.
	HRRZM H,TRANFL	;ADD THIS ONE TO FREE LIST.
	JRST NTRND0

NTRNDX:	HRRES TRANLK(A)	;IN CASE DELETED 1ST ENTRY.
	SKIPGE (P)
	AOS (P)		;SKIP IF SET FLAG.
	POPJ P,
;TRANAD CALL. -- ADD AN ENTRY TO A TRANSL LIST.
;1ST 2 ARGS AS FOR TRANDL.
;3RD ARG LIKE 2ND BUT GIVES OUTPUT NAMES.
;SKIPS UNLESS ALL ENTRIES WERE IN USE.
NTRNAD:	JSP Q,NTRNUI
NTRNA:	TLNN A,3	;IF RELLY NOTHING WOULD BE TRANSL'D,
	 JRST LSWPJ1	;DON'T BOTHER ADDING..
	PUSHJ P,NTRNDA	;DELETE ANY EXISTING TRANSL. FOR THESE INPUT NAMES.
	JFCL		;IF WERE NONE.
	SKIPGE T,TRANFL
	JRST OPNL5	;NO FREE ENTRIES - DIRECTORY FULL.
	AOS TRNCNT	;1 MORE ENTRY IN USE.
IRPS X,,ID I1 I2 IS
	MOVEM D+.IRPCN,TRAN!X(T)
TERMIN			;PUT INPUT NAMES INTO ENTRY.
	MOVE B,C
	PUSHJ P,NTRNGA	;GET OUTPUT NAMES.
IRPS X,,OD O1 O2 OS
	MOVEM D+.IRPCN,TRAN!X(T)
TERMIN			;STORE OUTPUT NAMES.
	MOVE H,TRANLK(A)	;PUT CURRENT TRNLS INTO LINK.
	EXCH H,TRANLK(T)
	HRREM H,TRANFL	;STORE BACK REST OF FREE LIST.
	MOVEM T,TRANLK(A)	;TRNLS NOW STARTS WITH THSI ONE.
	HLLM A,TRANLK(T)	;STORE MODE BITS.
	JRST LSWPJ1
;TRANCL CALL -- RESET A ONE OR BOTH TRANSL LISTS FOR A JOB.
;1ST ARG RH HAS JOB SPEC OF MODIFYABLE JOB.
; BIT 4.8 CLEAR TRNLS1 VAR. (TRANSL FOR THIS JOB & INFS).
; BIT 4.7 CLEAR TRNLST VAR. (TRANSL FOR THIS JOB ONLY).
; ALWAYS SKIPS IF VALID.
NTRNCL:	JSP Q,NTRNUI	;RH(A) -> TRNLST OR TRNLS1 VAR.
	TLNE A,200000
	SUBI A,TRNLS1-TRNLST	;MAKE -> TRNLST VAR.
	SUBI A,TRNLST-TRANLK
	JRST NTRNC4

NTRNCA:	SUBI A,TRNLST-TRANLK	;MAKE HOLD USR IDX.
NTRNC:	PUSHJ P,SWTL	;GET WRITE ACCESS.
	TRANSW
NTRNC4:	AOS (P)
	SKIPE TRNREF	;WAIT FOR READ REFS TO FINISH.
	PUSHJ P,UFLS
	TLNN A,100000	;IF 4.7, HANDLE TRNLST.
	JRST NTRNC0
	HRRE T,TRNLST(A)
	SETOM TRNLST(A)	;SET LIST TO NIL.
	JUMPGE T,NTRNC1	;IF WASN'T NIL, FREE ENTRIES ON IT.
NTRNC0:	TLZN A,200000	;MAYBE HANDLE TRNLS1.
	JRST LSWPOP
	HRRE T,TRNLS1(A)
	SETOM TRNLS1(A)
	JUMPL T,LSWPOP	;NOTHING TO DO IF ALREADY NIL.
NTRNC1:	MOVEI C,(T)	;SAVE START OF LIST.
NTRNC2:	SOS TRNCNT	;UPDATE NUM ENTRIES IN USE.
	HRRES H,TRANLK(T)
	JUMPL H,NTRNC3	;AT END, SPLICE INTO FREELIST.
	MOVEI T,(H)	;ELSE CDR DOWN.
	JRST NTRNC2
NTRNC3:	EXCH C,TRANFL
	HRRZM C,TRANLK(T)
	JRST NTRNC0	;MAYBE CONSIDER THE OTHER LIST.
;.TRANA, .TRAND CALLS.
ATRANA:	XCTR XR,[MOVE E,(B)]
	JSP T,ATRNDT	;SET UP ARGS FOR NTRNA .
	PUSHJ P,SWTL	;GET WRITE ACCESS.
	TRANSW
	JRST NTRNA

ATRNDL:
ATRAND:	XCTR XR,[SKIPN E,(B)]
	JRST ATRND0	;ZERO UNAME -> TRANCL .
	JSP T,ATRNDT	;SET UP ARGS.
	PUSHJ P,SWTL	;GET WRITE ACCESS.
	TRANSW
	JRST NTRND

ATRND0:	JSP T,ATRNDT
	TLO A,300000	;SAY CLEAR BOTH LISTS.
	CAMN D,[SIXBIT/*/]
	SUBI A,TRNLS1-TRNLST	;NAKE SURE -> TRNLST VAR.
	JRST NTRNCA

ATRNDT:	MOVE C,JNAME(U)
	MOVEM C,ATRNJN	;WHO THE HELL'S USING THESE?
	CAME E,UNAME(U)	;UNAME MUST BE 0 OR THSI JOB'S.
	JUMPN E,CPOPJ	;ELSE MAKE UUO FAIL.
	MOVNI W,1	;SIGNAL TO NTRNGA.
	MOVEI C,5(B)	;SET UP 2 AOBJN PTRS
	MOVEI B,2(B)
	HRLI C,-3	;-> INPUT NAMES (B), OUTPUT NAMES (C).
	HRLI B,-3
	XCTR XR,[HLL A,(B)]	;GET MODE BITS.
	XCTR XR,[MOVE D,-1(B)]
	JUMPE D,CPOPJ	;JNAME MUSTN'T BE 0.
	CAME D,[SIXBIT/*/]	;IF *, USE THIS JOB'S TRNLS1.
	JRST ATRND2
	HRRI A,TRNLS1-TRANLK(U)
	JRST (T)

ATRND2:	MOVEI H,0	;ELSE FIND JOB WITH THAT JNAME.
	MOVE E,UNAME(U)	;THIS JOB'S UNAME.
ATRND1:	CAMN E,UNAME(H)
	CAME D,JNAME(H)
	JRST ATRND3	;NOT THE ONE WE'RE LOOKING FOR.
	HRRE E,SUPPRO(H)
	CAIE U,(E)	;IS THIS OUR INF.
	CAIN U,(H)	;IS IT THE CURRENT JOB?
	CAIA
	POPJ P,		;NO, CAN'T SET ITS TRANSL LIST.
	HRRI A,TRNLST-TRANLK(H)
	JRST (T)	;OK, SET ITS TRNLST VAR.
ATRND3:	ADDI H,LUBLK
	CAMGE H,USRHI	;LOOK AT ALL JOBS.
	JRST ATRND1
	POPJ P,		;CAN'D TRANAD NON EX JOB.

SUBTTL JOB, BOJ DEVICE ROUTINES

;ML AND AI AND DM AND ... DEVICES
MLGO:	HRLZM C,EPDLT4(U)
	MOVEM A,EPDLT1(U)
	MOVEM B,EPDLT2(U)
	MOVE E,USYSN1(U)
	MOVEM E,EPDLT3(U)
	MOVSI E,(SIXBIT /SYS/)
	MOVEM E,USYSN1(U)
	MOVE A,[SIXBIT /ATSIGN/]
	MOVE B,[SIXBIT /OTHER/]
	CAIN W,2
	 JRST JOBOLK	;MLINK IS SPECIAL
	CAIN W,4
	 JRST JOBOFD	;FDELE IS SPECIAL
	MOVEI W,0	;FLUSH MODE
	JRST JOBO

JOBOF3:	MOVEI TT,6	;FOR FDELE USE CODE 6.
	CAME J,[-1]
	 MOVEI TT,2	;FOR MLINK USE CODE 2.
	MOVEI A,JBWT1		;CLOSE IF PCLSRED
JFDEL5:	MOVEM TT,JBSTS(E)
	MOVE TT,SRN3(U)	;REMEMBER NAMES TO RENAME AS
	MOVEM TT,JBST2(E) ;FOR JOBGET TO RETURN.
	MOVE TT,SRN4(U)
	MOVEM TT,JBNFN2(E)
	MOVE TT,SRN5(U)	  ;IN CASE THIS IS MLINK, MAKE SURE THE "TO" SNAME
	MOVEM TT,JBAC7(E) ;IS GIVEN TO JOBGET.
	CONO PI,CLKOFF
	PUSHJ P,(A)
	LDB TT,[350400,,JBSTS(E)]
	JUMPE TT,JOBOPL
	AOS (P)
	MOVE A,E
	JRST JOBCL2

;RENAME WHILE OPEN ON JOB WRITE CHNL
JFDEL4:	HLRZ E,(TT)	;JOB CHNL INDEX
	MOVEI TT,7
	MOVEI A,JBWT	;DON'T CLOSE IF PCLSRED
	JRST JFDEL5

EBLK
JBMN==10	;MAXIMUM NUMBER OF JOBS ON JOB DEVICE

JBNTO:	REPEAT JBMN,0	;NUMBER TIMES JOB OPEN
BJNTO:	REPEAT JBMN,0	;NUMBER TIMES BOJ OPEN
JBCUI:	REPEAT JBMN,-1	;CREATOR'S USER INDEX
JBCG:	BLOCK JBMN	;-1 IF CREATOR GONE AWAY
JBWST:	REPEAT JBMN,SNJOB	;CREATED JOB'S WAIT STATUS
	;4.9 = 1  => CREATED JOB HAS DONE A SUCCESSFUL JOBRET
	;4.8 => DIRECTION OF CHANNEL IF ONLY OPEN ONE WAY.
	;   = 0 => READ   = 1 => WRITE.
	;4.7 = 1  => HAVE DONE INPUT JOB CLS BUT NO JOBGET YET
	;4.6 = 1  => HAVE DONE OUTPUT JOB CLS BUT NO JOBGET YET.
	;4.5 => VALID BIT
	;4.4 => STORED BIT
	;4.3 => BOJ BLK UNHANG BIT
	;4.2 => USE NEW BOJ JOB FOR OTHER DIRECTION OPEN
	;4.1 => CREATED FOR A .FDELE
	;3.9 => CREATED JOB DID AN UNSUCCESSFUL JOBGET FOR AN INITIAL OPEN
	;1.1-2.9 => LAST STATUS SET BY BOJ

JBINCL==100000
JBOUCL==40000
JBVAL==20000
JBSTR==10000

JBDEV:	BLOCK JBMN	;DEVICE NAME, USER-SETTABLE (MOSTLY FOR PEEK AND WHO LINES)
JBFN1:	BLOCK JBMN	;FN1
JBFN2:	BLOCK JBMN	;FN2
JBSYS:	BLOCK JBMN	;SYSNAME
JBOPNM:	BLOCK JBMN	;OPEN MODE
JBCJUI:	BLOCK JBMN	;CREATED JOB'S USER INDEX. CREATED JOB MUST EXIST BECAUSE
		;WHEN IT IS IODCL'D BEFORE DYING IT FLUSHES THE JOB-DEVICE SLOT
		;AND ITS CREATOR'S JOB CHANNELS.
JBSTS:	BLOCK JBMN	;STATUS OF JOB-BOJ INTERACTIONS
;4.9=1 => IMAGE =0 => ASCII
;4.8=1 => BLOCK =0 => UNIT
;4.7=1 => WRITE =0 => READ
;4.6-4.3 => NUMBER OF TIMES TO SKIP
;4.2-3.6 => OPEN LOSS
;3.5-3.2 => # OF ARGS ON LAST .CALL
;1.4 => SYSTEM CALL OTHER THAN THOSE BELOW.
;1.3-1.1 => SYSTEM CALL
	;0	OPEN
	;1	IOT
	;2	MLINK
	;3	RESET
	;4	RCHST
	;5	ACCESS
	;6	FDELE (DELETE OR RENAME)
	;7	FDELE (RENAME WHILE OPEN)

JBST2:	BLOCK JBMN	;SECOND WORD OF JOBGET INFO
JBOFN1:	BLOCK JBMN	;FN1 BEFORE LAST TRANS
JBOFN2:	BLOCK JBMN	;FN2 "" ""
JBOSYN:	BLOCK JBMN	;SYSNAM ""
JBODEV:	BLOCK JBMN	;DEV  " "
JBNFN2:	BLOCK JBMN	;NEW FN2 FOR FDELE.
JBAC7:	BLOCK JBMN	;TABLE FOR .CALL ARG 7
JBAC10:	BLOCK JBMN	;TABLE FOR .CALL ARG 10
JBAC11:	BLOCK JBMN	;TABLE FOR .CALL ARG 11

JBACTB:	JBST2(H)	;TABLE OF POINTERS TO .CALL ARG TABLES
	JBOFN1(H)
	JBOFN2(H)
	JBOSYN(H)
	JBODEV(H)
	JBNFN2(H)
	JBAC7(H)
	JBAC10(H)
	JBAC11(H)

JBSW:	-1
	0

JBCH:	BLOCK JBMN	;1.1-1.4 => JOB USER INPUT CH
			;1.7-2.1 => JOB USER OUTPUT CH
			;3.1-3.4 => BOJ USER OUTPUT CH
			;3.7-4.1 => BOJ USER INPUT CH

JBIOCJ:	BLOCK JBMN	;IO CHNL ERROR WORD.  4.9 => NEXT JOB IOT
			;RH = IOCER TYPE
JBIOCB:	BLOCK JBMN	;IO CHNL ERROR WORD.  4.9 => NEXT BOJ IOT
			;RH = IOCER TYPE

BBLK

;3.4 = 1 => CAUSE CREATIONOF NEW BOJ JOB FOR OPPOSITE DIR OPEN
;3.5 = 1 => UNHANG ON BLK IOT AFTER EACH XFER OF MAXIMAL SIZE
BOJO:	JUMPN W,OPNL12	;NO SUCH MODE
	SKIPGE E,JBI(U)	;JOB CHANNEL INDEX
	 JRST [	MOVE E,OPTION(U) ;IF THIS JOB ISN'T A JOB DEVICE,
		TLNN E,OPTOJB	;IF IT'S EXPECTING TO BE AN OJB DEVICE, OK.
		 JRST OPNL10	;OTHERWISE IT CAN'T WIN.
		SKIPGE JBI(U)	;IF IT CAN WIN, WAIT TILL IT HAS.
		 PUSHJ P,UFLS
		JRST BOJO]	;THEN TRY AGAIN.
	CAIL E,JBMN
	JRST 4,.	;JOB CHANNEL INDEX TOO BIG
	HRLZ A,E
	MOVE B,UUAC(U)
	MOVE TT,[220600,,JBCH(E)]
	SKIPL D
	MOVE TT,[300600,,JBCH(E)]
	DPB B,TT	;STORE BOJ USER CH #
	ROT D,-2
	DPB D,[340200,,JBWST(E)]
	HLRZS C
	AOS BJNTO(E)
	JSP Q,OPSLC7
	BDUAI,,BDUAO
	BDBI,,BDBO
	BDUII,,BDUIO
	BDBI,,BDBO

;.OPEN CH,ADR
;ERROR RETURN
;NORMAL RETURN

;ADR:	MODE BITS,,SIXBIT /JOB/
;	FN1
;	FN2

;MODE BITS:
;3.1-3.3 => IMAGE/ASCII, BLOCK/UNIT, OUTPUT/INPUT
;A,B HAVE FILENAMES, RH(C) HAS DEVICE (JOB OR OJB)
;RH(D) AND LH(C) BOTH HAVE OPEN-MODE.

JOBO:	PUSHJ P,FLDRCK
	 JRST JOBO3
	  JRST OPNL11	;ILLEGAL FILE NAME
JOBO3:	CAMN A,[SIXBIT /M.F.D./]
	 CAME B,[SIXBIT /(FILE)/]
	  JRST JOBO2
	JRST OPNL11	;ILLEGAL FILE NAME
JOBO2:	CAIN W,2	;WE HANDLE LINKS NOW - MOSTLY JUST LIKE FDELE 
	 JRST JOBOLK	;BUT SEE JOBOF3.
	CAIE W,4
	 TDZA J,J
JOBOFD:	  MOVNI J,1	;ENTRY FOR FDELE
	CAIA
JOBOLK:	 MOVNI J,3	;SIGN IS SET, AND LOW BIT IS SET - LIKE -1.
	MOVNI E,1
	MOVSI Q,-JBMN
	PUSHJ P,SWTL	;LOCK JOB CHNL ASSIGN SWITCH
	JBSW
JOBO5:	SKIPGE TT,JBCUI(Q)	;SKIP IF NOT FREE
	JRST JOBO4
	SKIPL JBCG(Q)	;CREATOR CLOSED THIS CHNL => CAN'T REUSE
	CAIE TT,(U)	;CREATED BY OTHER JOB =>       "     "
	JRST JOBO6
	CAMN A,JBFN1(Q)
	CAME B,JBFN2(Q)
	JRST JOBO6
	MOVE T,USYSN1(U)
	CAME T,JBSYS(Q)
	JRST JOBO6
	SKIPGE TT,JBWST(Q)	;SKIP IF HASN'T DONE JOBRET
	JRST JOBO6A
	JUMPL J,JOBOF1
	TLNE TT,400
	JRST JOBO6	;JOB WILL GO AWAY
	LSH TT,1	;READ/WRITE BIT
	EQV TT,D
	JUMPGE TT,JOBO6		;WRONG DIR
JOBOF2:	HRRZ E,Q	;FILE ALREADY ACTIVE DONT RECREATE.
	SETZM JBCG(E)
	PUSHJ P,LSWPOP	;FREE JBSW
	JRST JOBO7

JOBOF1:	TLNE TT,1000
	JRST JOBOF2	;THIS JOB IS AN FDELE
	JRST JOBO6

JOBO6A:	JUMPL J,JOBO6
	MOVE H,JBNTO(Q)
	SOJN H,JOBO6	;ALREADY OPEN IN BOTH DIRECTIONS OR OPENED AND CLOSED.
	TLNE TT,2000
	 JRST JOBO6	;CAN'T USE IT IF IT SAID NOT TO.
	MOVSI T,JBINCL
	SKIPGE D
	MOVSI T,JBOUCL
	TDNE T,JBWST(Q)	;PENDING CLOSE THIS DIRECTION =>
	 JRST JOBO6	 ;CAN'T USE THIS ONE.
	LSH TT,1
	EQV TT,D
	JUMPL TT,JOBO6	;SAME DIR.  CAN'T USE THIS JOB
	HRRZ E,Q
	MOVEM C,JBOPNM(E)
	SETZM JBCG(E)
	PUSHJ P,LSWPOP	;FREE JOBSW
	JRST JOBO7

JOBO4:	HRRZ E,Q
JOBO6:	AOBJN Q,JOBO5
	JUMPL E,OPNL6	;DEVICE FULL
	MOVEM U,JBCUI(E)	;STORE CREATOR'S USER INDEX
	PUSHJ P,LSWPOP	;FREE JOBSW
	MOVEM A,JBFN1(E)
	MOVEM B,JBFN2(E)
	MOVEM C,JBOPNM(E)
	SETZM JBCG(E)
	SETZM JBNTO(E)
	SETZM BJNTO(E)
	MOVEI A,SNJOB	;INITIALIZE STATUS
	MOVEM A,JBWST(E)
	SETOM JBCH(E)
	ROT D,1
	DPB D,[420100,,JBWST(E)]
	ROT D,-1
	DPB J,[340100,,JBWST(E)]	;FDELE BIT
	PUSHJ P,STMSET	;SETOM JBCUI(E) ON LOSSAGE
	JBCUI(E)
	PUSH P,R
	PUSH P,E
	PUSH P,U
	PUSH P,J
	PUSH P,D
	ANDI C,-1	;FOR OJB DEVICE, LOOK FOR EXISTING JOB.
	CAIN C,'OJB
	 JRST JOBO6B
	MOVE A,UNAME(U)	;FOR JOB DEVICE, CREATE NEW JOB.
	IDIVI E,10.
	MOVEI B,'0(E)
	LSH B,6
	ADDI B,'0(TT)
	HRLI B,(SIXBIT /JOB/)		;CREATE JNAME = 'JOB MN'
	MOVE C,[7,,(SIXBIT /USR/)]
	MOVE D,[SETZ 3]
	PUSHJ P,USROJ	;GENERATE USER(CAN ONLY PCLSR BEFORE CREATING INFERIOR)
	 JRST POP5J	;USER OPEN FAILED, MUST HAVE GONE TO OPNL ALREADY
	JRST JOBO6C

JOBO6B:	MOVE A,JBFN1(E)	;OJB DEVICE: LOOK FOR JOB WHOSE NAMES ARE
	MOVE B,JBFN2(E)	;THE FILENAMES SPECIFIED IN THE OJB OPEN.
	MOVE C,[7+UBPFJ,,'USR]	;DON'T EVER CREATE JOB FOR OJB.
	MOVE D,[SETZ 3+UBPFJ_<-1>]
	PUSHJ P,USROOJ
	 JRST POP5J
;TT HAS USER IDX OF JOB TO BE USED; CAN'T PCLSR AFTER THIS POINT.
JOBO6C:	PUSHJ P,LSWDEL	;SETOM JBCUI(E)
	POP P,D
	POP P,J
	POP P,U
	POP P,E
	POP P,R
	HRRZM TT,JBCJUI(E)
	MOVEM E,JBI(TT)
	HRRZ C,JBOPNM(E)
	CAIN C,'OJB	;OJB DEVICE => DON'T LOAD THE ALREADY EXISTING JOB;
	 JRST JOBO7	;ASSUME ITS SUPERIOR DOES THAT.
	SETOM SUPPRO(TT)
	MOVE T,[JBSTCD,,AC0S]
	ADDI T,(TT)
	BLT T,AC17S(TT)
	HRLZI T,%PCUSR
	MOVEM T,UPC(TT)
	MOVE A,JBFN1(E)
	MOVEM A,AC0S+10(TT)
	MOVE B,JBFN2(E)
	MOVEM B,AC0S+11(TT)
	MOVE T,USYSN1(U)
	MOVEM T,USYSNM(TT)	;SET CREATED JOB'S SYS NAME TO OURS
	MOVEM T,JBSYS(E)
	CONO PI,CLKOFF
	SETZM USTP(TT)	;START HIM UP
JOBO7:	CONO PI,CLKOFF
	MOVE TT,EPDLT1(U)
	MOVEM TT,JBOFN1(E)
	MOVE TT,EPDLT2(U)
	MOVEM TT,JBOFN2(E)
	MOVE TT,EPDLT3(U)
	MOVEM TT,JBOSYN(E)
	MOVE TT,EPDLT4(U)
	MOVEM TT,JBODEV(E)
	MOVEM TT,JBDEV(E)
	JUMPL J,JOBOF3	;DELETE
	MOVE TT,UUAC(U)
	MOVE C,[000600,,JBCH(E)]
	SKIPGE D
	MOVE C,[060600,,JBCH(E)]
	DPB TT,C	;STORE USER CH #
	LDB TT,[220300,,JBOPNM(E)]
	ROT TT,-3
	MOVEM TT,JBSTS(E)
	HLRZ C,JBOPNM(E)	;GET ALL OF OPEN MODE
	MOVEM C,JBNFN2(E)	;GIVE IT
	PUSHJ P,JBWT1	;STORE STUFF AND HANG
	LDB TT,[350400,,JBSTS(E)]
	JUMPE TT,JOBOPL	;OPEN LOST
	MOVE C,JBOPNM(E)
JOBO14:	AOS JBNTO(E)	;NUMBER OF TIMES OPEN
	SETZM IOCHST-IOCHNM(R)
	HRLZ A,E
	HLRZS C
	JSP Q,OPSLC7
	JDUAI,,JDUAO
	JDBI,,JDBO
	JDUII,,JDUIO
	JDBI,,JDBO

JOBOPL:	LDB C,[270600,,JBSTS(E)]
	SKIPE C
	CAILE C,NOPNLS
	MOVEI C,22
	MOVE A,E
	CONO PI,CLKOFF
	PUSHJ P,JOBCL2	;CAUSE CHNL TO GO AWAY WHEN BOJ GUY LOGS OUT
	JRST OPNL1-1(C)

;JOB CHNL INDEX IN E,  CLOBBERS TT,J,Q,H
;CALL WITH CLKOFF

JBINT:	MOVE TT,JBCJUI(E)
	MOVEI J,IOCHNM(TT)
	HRLI J,-20
	MOVSI H,4000
JBINT1:	MOVE Q,(J)
	TDNN H,CLSTB(Q)	;SKIP IF BOJ
JBINT2:	AOBJN J,JBINT1
	JUMPGE J,CPOPJ
	SUBI J,IOCHNM(TT)
	MOVE Q,CHNBIT(J)
	IORM Q,IFPIR(TT)
	ADDI J,IOCHNM(TT)
	JRST JBINT2


JBSTCD:	.OPEN 1,7	;0
	.LOGOUT
	.CALL 12
	.LOGOUT
	.IOT 1,2
	.CLOSE 1,
	JRST (2)
	4,,(SIXBIT /DSK/)	;7
	0	;10 FN1
	0	;11 FN2
	SETZ	;12
	SIXBIT /LOAD/
	16
	SETZ 17
	-1	;16 (LOAD INTO SELF)
	1	;17


;CALL WITH CLOCK OFF ,JOB CHNL IN E
JBWT1:	TLOA E,400000
JBWT:	TLZ E,400000
	MOVSI TT,JBVAL+JBSTR
	IORM TT,JBWST(E)	;TURN ON VALID AND STORED
	PUSHJ P,LOSSET
	    JBPCL	;CLEAR VALID AND STORED IF PCLSR
	PUSHJ P,JBINT	;GIVE INT
	MOVE T,E	;CAUSES EPDL2 TO HAVE JOB INDEX
	PCLT
JBFLS:	SKIP JBFLS
	PUSHJ P,UFLS	;ONLY PLACE TO PCLSR AFTER SUCCESSFUL USRO
	JRST LSWDEL

JBPCL:	MOVE A,AC0S+E(U)
	MOVSI T,JBVAL+JBSTR
	ANDCAM T,JBWST(E)
	JUMPGE A,CPOPJ
	SKIPE JBNTO(A)	;IF THE JOB DEVICE IS NO LONGER OPEN,
	 POPJ P,
	SETOM JBCG(A)	;SAY THE CREATOR HAS CLOSED IT
IRPS X,,E TT J Q H
	PUSH P,X
TERMIN
	MOVE E,A	;AND GIVE THE HANDLER AN INTERRUPT
	PUSHJ P,JBINT
IRPS X,,H Q J TT E
	POP P,X
TERMIN
	POPJ P,

JBBI:	SKIPA TT,[600000,,1]	;BLOCK IMAGE (ASCII) INPUT IOT
JBBO:	MOVE TT,[700000,,1]	;BLOCK IMAGE (ASCII) OUTPUT IOT
JBIB:	XCTR XRW,[MOVES D,(C)]	;REFERENCE POINTER
	JUMPGE D,CPOPJ
	MOVEM D,JBST2(A)
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZS B,D
	SUB D,E		;LA + 1
	CAMLE D,[1,,]
	JRST IOADC
	ANDI B,776000	;FIRST WORD OF FIRST PAGE
JBBO1:	TLNE TT,100000
	XCTR XR,[SKIPA (B)]
	XCTR XRW,[MOVES (B)]	;REFERENCE ONE WORD IN EACH PAGE
	ADDI B,2000
	CAMGE B,D
	JRST JBBO1
	JRST JBIX

JBUII:	SKIPA TT,[SETZ 1]	;UNIT IMAGE INPUT IOT
JBUAI:	MOVEI TT,1	;UNIT ASCII INPUT IOT
JBIU:
JBIX:	HRRZ E,A	;JOB CHNL INDEX
	MOVEM TT,JBSTS(E)
	MOVEM C,SRN3(U)
	SKIPGE TT,JBIOCJ(E)
	JRST JBIXER	;GET IO CHNL ERROR
	CONO PI,CLKOFF
	JRST JBWT

JBUIO:	SKIPA TT,[500000,,1]	;UNIT IMAGE OUTPUT IOT
JBUAO:	MOVE TT,[100000,,1]	;UNIT ASCII OUTPUT IOT
	SKIPGE C
	 SKIPA W,(C)
	  XCTR XR,[MOVE W,(C)]
	JRST JBIU

JBIXER:	SETZM JBIOCJ(E)
	JRST IOCERF-MIOTER(TT)

;WAIT FOR CREATOR TO BE HUNG AT JBFLS
;4.9 OF SRN3 = 1 => WAIT FOR WRITE   0 => READ
;1.1-1.4 => CODE OF UUO TO WAIT FOR

BJWAIT:	SKIPE B,FLSINS(T)
	CAME B,JBFLS
	POPJ P,		;NOT HUNG AT JBFLS
	MOVE B,EPDL2(T)	;JOB INDEX THAT CREATOR IS HACKING
	HLRZ E,T	;JOB INDEX OF BOJ USER
	CAME B,E
	POPJ P,		;CHNLS DON'T AGREE
	PUSH P,J
	MOVE TT,JBSTS(B)
	LSH TT,2	;4.9 => READ/WRITE BIT NOW
	EQV TT,SRN3(U)	;4.9 OF SRN3 => WHAT TO LOOK FOR
	JUMPGE TT,POPJJ	;DOESN'T MATCH
	LDB TT,[000400,,JBSTS(B)]
	LDB J,[000400,,SRN3(U)]	;INSTRUCTION TO LOOK FOR
	CAMN TT,J	;SKIP IF WRONG INSTRUCTION
	AOS -1(P)		;FINALLY
	JRST POPJJ

BJIOCC:	SKIPL TT,JBIOCB(A)
	POPJ P,
	SETZM JBIOCB(A)
	SUB P,[1,,1]
	JRST IOCERF-MIOTER(TT)

BJUIO:	TDZA W,W
BJUAO:	MOVNI W,1
	PUSHJ P,BJIOCC
	SKIPGE C
	 SKIPA H,(C)
	  XCTR XR,[MOVE H,(C)]
	MOVEI B,1	;WAIT FOR INPUT IOT
	MOVEM B,SRN3(U)
BJUO1:	HRLZ T,A	;JOB INDEX
	HRR T,JBCUI(A)	;CREATOR'S USER INDEX
	PUSHJ P,CWAIT
	 PUSHJ P,BJWAIT
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	 JRST BJUOB	;BLOCK MODE CREATOR IOT
	MOVE D,TT
	XOR D,W
	JUMPGE D,BJUO4
	MOVEM H,AC0S+W(T)
	JRST BJUO6

BJUO3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJUO1

BJUO2:	TDZA I,I
BJUO2B:	MOVNI I,1
	PUSHJ P,PLDZ	;IN CASE ANY XCTRS GET ADDED TO THIS CODE
BJUO6:	MOVSI D,(SETZ)
	IORM D,JBWST(A)	;SET SUCCESSFUL JOBRET BIT
	MOVSI D,JBVAL+JBSTR
	ANDCAM D,JBWST(A)
	MOVEI D,0
	DPB D,[350400,,JBSTS(A)]	;DON'T SKIP
	MOVE D,FLSINS(T)
	SETZM FLSINS(T)	;RESTART CREATOR
	CONSO PI,1
	CAME D,JBFLS
	JRST 4,.	;HE WASNT WHERE HE BELONGED
	JUMPE I,CLKONJ	;UNHANG IF NOT BLK
	XCTRI XR,[MOVE D,(C)]
	 JRST .+2
	  JRST 4,.
	JUMPGE D,CLKONJ
	MOVE D,JBWST(A)
	TLNN D,4000	;BLK UNHANG BIT
	JRST BJBO
	JRST CLKONJ

BJUO4:	PUSHJ P,MPLDZ	;TURNS CLK ON
	JRST IOCR10

BJUOB:	HRLI T,250000	;MAKE MY MAP POINT AT CREATOR
	MOVE J,T
	PUSHJ P,PLD1	;LOAD UP NEW MAP
	MOVE D,SRN3(T)	;ADDRESS OF CREATOR'S POINTER
	XCTRI XRW,[MOVES B,(D)]
	JRST .+2	;NO FAULT (INSURANCE OF WRITEABILITY)
	JRST BJUO3
	JUMPL W,BJUOBA	;BOJ ASCII IOT
	XCTRI XW,[MOVEM H,(B)]
	 CAIA
	  JRST BJUO3
	ADD B,[1,,1]
	XCTRI XW,[MOVEM B,(D)]
	 CAIA
	  JRST 4,.
	JUMPGE B,BJUO2
PLDZONJ:	PUSHJ P,PLDZ
	JRST CLKONJ

BJUOBA:	LDB E,[410300,,B]	;CHAR COUNT
	CAIGE E,3
	 JRST BJUO2
	MOVE E,BTOCHT-3(E)
	XCTRI XR,[MOVE W,(B)]
	 CAIA
	  JRST BJUO3
	IDPB H,E
	XCTRI XW,[MOVEM W,(B)]
	 CAIA
	  JRST BJUO3
	ADD B,[700000,,]
	TLNN B,500000
	 ADD B,[500001,,1]
	XCTRI XW,[MOVEM B,(D)]
	 CAIA
	  JRST 4,.
	TLNN B,700000
	 JRST BJUO2
	JRST PLDZONJ

BJBO:	PUSHJ P,BJIOCC
	MOVEI I,1
	JSP TT,BJCLST
	XCTR XRW,[MOVES D,(C)]	;D GETS IOT POINTER
	JUMPGE D,CPOPJ	;XFER 0 WORDS?
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZ T,D
	SUB T,E
	CAILE T,-1
	JRST IOADC
	XCTR XR,[MOVE H,(D)]	;H GETS FIRST WORD
	MOVEI B,1
	MOVEM B,SRN3(U)
	HRLZ T,A
	HRR T,JBCUI(A)
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT	;WAIT FOR JOB INPUT IOT COME BACK W/ CLOCK OFF
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	 JRST BJBB	;CREATOR IOT IS IN BLOCK MODE
	TLNN TT,400000
	 JRST BJBOA	;CREATOR IOT IS ASCII
	MOVEM H,AC0S+W(T)
	ADD D,[1,,1]
BJBO1:	XCTRI XW,[MOVEM D,(C)]
	 SKIPA I,[-1]
	  JRST 4,.
	JRST BJUO6

BJBOA:	SETZ I,
	LDB E,[410300,,D]	;CHAR CNT
	CAIGE E,3
	JRST BJUO6
	MOVE E,BTOCHT-3(E)
	MOVE W,H
	ILDB E,E
	MOVEM E,AC0S+W(T)
	ADD D,[700000,,]
	TLNN D,500000
	ADD D,[500001,,1]
	JRST BJBO1

BJBO3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJBO

BJUII:	TDZA H,H
BJUAI:	MOVNI H,1
	PUSHJ P,BJIOCC
	XCTR XRW,[MOVES (C)]
	MOVE B,[SETZ 1]	;WAIT FOR OUTPUT IOT
	MOVEM B,SRN3(U)
BJUI1:	HRLZ T,A	;JOB INDEX
	HRR T,JBCUI(A)	;CREATOR'S USER INDEX
	PUSHJ P,CWAIT
	 PUSHJ P,BJWAIT
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	 JRST BJUIB	;BLOCK MODE CREATOR IOT
	MOVE D,TT
	XOR D,H
	JUMPGE D,BJUO4
	MOVE W,AC0S+W(T)
	JRST BJUI6	;SUCCESSFUL

BJUI3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJUI1

BJUI2:	PUSHJ P,PLDZ
BJUI6:	SKIPGE H
	 ANDI W,177
BJUI4:	TDZA I,I
BJUI4B:	MOVNI I,1
	MOVSI D,(SETZ)
	IORM D,JBWST(A)	;SET SUCCESSFUL JOBRET BIT
	MOVSI D,JBVAL+JBSTR
	ANDCAM D,JBWST(A)
	MOVEI D,0
	DPB D,[350400,,JBSTS(A)]	;DON'T SKIP
	MOVE D,FLSINS(T)
	SETZM FLSINS(T)	;RESTART CREATOR
	CONSO PI,1
	CAME D,JBFLS
	JRST 4,.	;HE WASN'T WHERE HE BELONGED
	JUMPE I,CLKONJ	;UNHANG IF NOT BLK
	XCTRI XR,[MOVE D,(C)]
	 JRST .+2
	  JRST 4,.
	JUMPGE D,CLKONJ
	MOVE D,JBWST(A)
	TLNN D,4000	;BOJ BLK UNHANG BIT
	JRST BJBI
	JRST CLKONJ

BJUIB:	HRLI T,250000	;MAKE MY MAP POINT AT CREATOR
	MOVE J,T
	PUSHJ P,PLD1	;LOAD UP NEW MAP
	MOVE D,SRN3(T)	;ADDRESS OF CREATOR'S POINTER
	XCTRI XRW,[MOVES B,(D)]
	 JRST .+2	;NO FAULT
	  JRST BJUI3
	JUMPL H,BJUIBA	;BOJ ASCII IOT
	XCTRI XR,[MOVE W,(B)]
	 JRST .+2
	  JRST BJUI3
	ADD B,[1,,1]
	XCTRI XW,[MOVEM B,(D)]
	 CAIA
	  JRST 4,.
	JUMPGE B,BJUI2
	JRST PLDZONJ

BJUIBA:	LDB E,[410300,,B]	;CHAR COUNT
	MOVEI W,0
	CAIGE B,3
	JRST BJUI2
	MOVE E,BTOCHT-3(E)
	XCTRI XR,[MOVE W,(B)]
	 JRST .+2
	  JRST BJUI3
	ILDB W,E
	ADD B,[700000,,]
	TLNN B,500000
	ADD B,[500001,,1]
	XCTRI XW,[MOVEM B,(D)]
	 CAIA
	  JRST 4,.
	TLNN B,700000
	 JRST BJUI2
	JRST PLDZONJ

BJBI:	PUSHJ P,BJIOCC
	MOVEI I,0
	JSP TT,BJCLST
	XCTR XRW,[MOVES D,(C)]	;D GETS IOT POINTER
	JUMPGE D,CPOPJ	;XFER 0 WORDS?
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZ T,D
	SUB T,E
	CAILE T,-1
	JRST IOADC
	MOVE B,[SETZ 1]
	MOVEM B,SRN3(U)
	HRLZ T,A
	HRR T,JBCUI(A)
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT	;WAIT FOR JOB OUTPUT IOT
	JUMPGE D,BJUI4	;THROUGH
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	 JRST BJBB	;CREATOR IOT IS IN BLOCK MODE
	MOVE H,AC0S+W(T)
	TLNN TT,400000
	 JRST BJBIA
	XCTRI XW,[MOVEM H,(D)]
	 JRST .+2
	  JRST 4,.
	ADD D,[1,,1]
	XCTRI XW,[MOVEM D,(C)]
	 JRST BJUI4B
	JRST 4,.

BJBIA:	LDB E,[410300,,D]
	CAIGE E,3
	JRST BJUI4
	MOVE E,BTOCHT-3(E)
	XCTRI XR,[MOVE W,(D)]
	 JRST .+2
	  JRST BJBI3
	IDPB H,E
	XCTRI XW,[MOVEM W,(D)]
	 JRST .+2
	  JRST 4,.
	ADD D,[700000,,]
	TLNN D,500000
	ADD D,[500001,,1]
	XCTRI XW,[MOVEM D,(C)]
	 JRST BJUI4B
	  JRST 4,.

BJBI3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJBI

BJCLST:	MOVSI T,100000	;INPUT JOBCLS
	SKIPN I
	MOVSI T,40000	;OUTPUT JOBCLS
	TDNE T,JBWST(A)
	POPJ P,
	JRST (TT)

BJ3T:	BJBI3
	BJBO3

BJOV:	BJBI
	BJBO

BJB2:	BJUI4B
	BJUO2B

BJBB:	HRLI T,250000
	MOVE J,T
	PUSHJ P,PLD1
	MOVEM J,SRN4(U)	;UMAPS FOR PURELY CREATOR MAP
	MOVE E,SRN3(T)
	XCTRI XRW,[MOVES H,(E)]
	 JRST BJBBL1
	JRST @BJ3T(I)

BJBBL:	MOVE J,SRN4(U)
	PUSHJ P,PLD1
	MOVE E,SRN3(T)
	XCTRI XRW,[MOVES H,(E)]
	 JRST BJBBL1
	JRST 4,.
BJBBL1:	PUSHJ P,PLDZ
	XCTRI XRW,[MOVES D,(C)]
	 JRST .+2
	  JRST 4,.
	JUMPGE H,@BJB2(I)	;H HAS JOB BLOCK IOT POINTER
	JUMPGE D,CLKONJ	;D HAS BOJ BLOCK IOT POINTER
	HLRE B,H
	CAML D,H
	HLRE B,D	;CHOOSE SMALLER OF TWO BLOCK SIZES
	MOVNS B		;COUNT TO BE XFERRED
	HRLZ E,H	;JOB ADDRESS
	HRR E,D		;JOB,,BOJ  (FROM,,TO FOR BOJ INPUT)
	HLRZ Q,E	;JOB ADDRESS
	CAIGE Q,20
	JRST BJBB1	;JOB ADDR IS AN AC
	HRRZ J,T	;SET UP UMAPS (JOB USER INDEX IN RH)
	TRZE E,400000
	TLOA J,200000	;TO HI PG, HACK OUR LO PAGE
	TLO J,100000	;TO LO PG, HACK OUR HI PAGE
	TLZE E,400000
	TLOA J,20000	;TO POINT TO HIS UPPER
	TLO J,40000	;TO POINT TO HIS LOWER
	TLNN J,140000	;UPPER TO UPPER XFER
	JRST BJBB3	;YES.  MAKE SURE NOT SCREWED BY AC PNTR
BJBB3A:	PUSHJ P,PLD1
	TRZ Q,400000
	MOVNS Q		;LIMIT SIZE OF XFER TO MIN OF
	ADDI Q,400000	;DIST OF TO ADR FROM SEG BOUNDARY
	CAMLE B,Q	;AND DIST OF FROM ADR TFROM SEG BOUNDARY
	HRRZ B,Q
	MOVNI Q,(E)	; - BOJ ADDR
	ADDI Q,400000
	CAMLE B,Q
	HRRZ B,Q
	TLNN J,200000	;BUGGER ADDRESSES SO RIGHT DBRS WILL BE USED
	TLOA E,400000	;SET JOB ADDR TO HI PAGE
	TRO E,400000	;SET BOJ ADDR TO HI PAGE
	SKIPE I
	MOVSS E		;XFER OTHER DIRECTION
	MOVE Q,E	;SAVE COPY OF BLT POINTER
	ADDI B,(E)	;GET LA + 1
	XCTRI XBRW,[BLT E,-1(B)]	;XFER DATA
	 MOVEI E,(B)	;NO FAULT.  SIMULATE STORE BACK OF POINTER
	PUSH P,J
	PUSHJ P,PLDZ
	SUBM E,Q
	HRLS Q		;NUMBER OF WORDS ACTUALLY XFERRED
BJBB2:	XCTRI XRW,[ADDM Q,(C)]
	 JRST .+2
	  JRST 4,.
	MOVE J,SRN4(U)
	PUSHJ P,PLD1
	POP P,J
	MOVE W,SRN3(T)
	XCTRI XRW,[ADDM Q,(W)]
	 JRST .+2
	  JRST 4,.
	CAIN B,(E)
	 JRST BJBBL	;NO FAULT
	PUSHJ P,PLD1	;RESTORE TO FROB AT TIME OF FAULT
BJBBF:	PUSHJ P,TPFLT	;TAKE FAULT (TURNS CLK ON)
	PUSHJ P,MPLDZ
	JRST @BJOV(I)

BJBB1:	ADDI Q,UUOACS(T)
	JUMPN I,BJBB1A
	MOVE B,(Q)	;READ JOB WORD
BJBB3C:	XCTRI XW,[MOVEM B,(E)]
	 JRST .+2
	  JRST BJBBF
BJBB2A:	MOVE Q,[1,,1]	;1 WORD XFERRED
	HRRZ B,E	;FAKE OUT FAULT TEST
	PUSH P,J
	JRST BJBB2

BJBB1A:	XCTRI XR,[MOVE B,(E)]
	 JRST .+2
	  JRST BJBBF
	MOVEM B,(Q)
	JRST BJBB2A

BJBB3:	TLNE E,777760	;SKIP OIN XFERRING FROM AC AREA, HI TO HI
	JRST BJBB3A	;NO.  OK TO DO BLT
	JUMPN I,BJBB3B
	HRLI J,120000	;HACK OUR HI TO POINT TO HIS HI
	PUSHJ P,PLD1
	XCTRI XR,[MOVE B,(Q)]
	 JRST .+2
	  JRST BJBBF
	PUSHJ P,PLDZ
	HRRZ E,D	;TO ADDRESS
	JRST BJBB3C

BJBB3B:	XCTRI XR,[MOVE B,(D)]
	 JRST .+2
	  JRST BJBBF
	HRLI J,120000
	PUSHJ P,PLD1	;HACK OUR HI TO POINT TO HIS HI
	XCTRI XW,[MOVEM B,(Q)]
	 JRST .+2
	  JRST BJBBF
	PUSHJ P,PLDZ
	JRST BJBB2A

;	.CALL ADR
;	ERROR RETURN
;	NORMAL RETURN

;ADR:	SETZ
;	SIXBIT /JOBGET/
;	[BOJCHNL]
;	2000,,WD1
;	2000,,WD2
;UP TO SIX WDS RETURNED

;WD1 BITS:
;4.9-4.7 => IMAGE/ASCII, BLOCK/UNIT, OUTPUT/INPUT
;4.6 => INPUT CLOSE
;4.5 => OUTPUT CLOSE
;1.4-1.1 => TYPE OF SYSTEM CALL
	;0	OPEN
	;1	IOT
	;2	MLINK
	;3	RESET
	;4	RCHST
	;5	ACCESS
	;6	FDELE (DELETE OR RENAME)
	;7	FDELE (RENAME WHILE OPEN)

;WD2 SET ONLY FOR BLOCK IOT POINTER, ACCESS POINTER, NEW FN1 FOR FDELE
;WD3	FN1
;WD4	FN2
;WD5	SYS NAME
;WD6	LEFT ADJUSTED DEVICE NAME
;WD7	NEW FN2 FOR FDELE.
;IGNORE ALL RETURNED INFO ON AN ERROR RETURN
;IF 4.5 OR 4.6 IS SET THEN ALL ELSE IS MEANINGLESS

NJBGT:	SETZM T		;INDICATE JOBGET, NOT JOBCAL
	HLRZ E,H	;GET JOB CHNL IDX FROM LH OF IOCHNM WD
	TLNN R,4000	;NOT A BOJ CHANNEL => WRONG TYPE DEVICE
	 JRST OPNL34
	CONO PI,CLKOFF
	MOVE A,JBWST(E)
	AND A,[<JBINCL+JBOUCL>,,]
	JUMPN A,NJBGT1
	MOVE A,JBWST(E)
	TLNN A,JBVAL
	JRST NJBGTE	;FAIL IF VALID NOT SET
	TLZ A,JBSTR
	MOVEM A,JBWST(E)	;CLEAR STORED BIT
	CONO PI,CLKON
	MOVE A,JBSTS(E)
	TLZ A,60000
	JUMPN T,NJBCL1	;BRANCH IF JOBCAL
NJBGT0:	MOVE B,JBST2(E)
	MOVE C,JBOFN1(E)
	MOVE D,JBOFN2(E)
	MOVE TT,JBODEV(E)
	MOVE I,JBNFN2(E)
	MOVE E,JBOSYN(E)
	CONO PI,CLKON
	JRST POPJ1

NJBGT1:	ANDCAM A,JBWST(E)
	LSH A,-1
	CONO PI,CLKON
	JRST POPJ1

NJBGTE:	SKIPGE JBCG(E)	;HAS CREATOR GONE AWAY?
	JRST NJBGCL	;YES - GO GIVE CLOSE
	JUMPL A,OPNL36	;NOT INITIAL OPEN
	MOVSI A,400
	IORM A,JBWST(E)	;INDICATE FAILING JOBGET ON INITIAL OPEN
	JRST OPNL36

NJBGCL:	CONO PI,CLKON
	HRLZI A,JBINCL+JBOUCL	;GIVE CLOSE - SET BITS
	JUMPE T,NJBGT0	;GIVE VIA JOBGET
	MOVEM A,JBSTS(E)	;GIVE VIA JOBCAL
	JRST NJBCL1

;	.CALL ADR
;	ERROR RETURN
;	NORMAL RETURN

;ADR:	SETZ
;	SIXBIT /JOBCAL/
;	[BOJCHNL]
;	[-N,,ADR OF DATA BUFFER]	;OPTIONAL
;	[DEVNAM]			;OPTIONAL
;	SETZM OPCODE
; OPCODE WILL BE THE SAME AS RETURNED IN WD1 BY JOBGET
; IF OPCODE<10 THEN WD2-WD7 OF JOBGET WILL BE WRITTEN INTO DATA BUFFER
;IF OPCODE=10 THEN JOB'S LAST .CALL WILL BE DESCRIBED:
;	WORD 1 OF DATA BUFFER => SIXBIT OF OPERATION (I.E. THE NAME
;		OF THE .CALL)
;	WORD 2 OF DATA BUFFER => FLAG BITS OF .CALL
;	WORD 3 OF DATA BUFFER => # OF ARGS TO .CALL
;	WORDS 4-12 => INPUT ARGS TO .CALL
; THIRD ARG, IF PRESENT, SETS DEVICE NAME USED BY PEEK AND TV WHO LINES.

NJBCL:	CAIL W,2		;DID CALLER SUPPLY AOBJN POINTER?
	SKIPN T,B		;IF SO AND NON-ZERO USE IT
	MOVEI T,1		;OTHERWISE SET T NONZERO
	JRST NJBGT+1		;GO JOIN JOBGET CODE FOR ERROR CHECKING

NJBCL1:	CAIL W,3
	 MOVEM C,JBDEV(E)	;SET DEVICE NAME FOR PEEK AND WHO LINE
	JUMPGE T,POPJ1		;BACK FROM JOBGET - ANY AOBJN PNTR?
	MOVEI C,7		;YES - OPCODE 10?
	TRNN A,10
	JRST NJBCL2		;NO - JUST COPY 7 STANDARD ARGS
	HLRE D,T		;GET LENGTH OF USERS DATA BUFFER
	MOVE B,JBCUI(E)		;GET JOB'S USER INDEX
	MOVE C,LSCALL(B)	;GET NAME OF JOB'S LAST CALL
	XCTR XW,[MOVEM C,(T)]	;PUT INTO CALLERS BUFFER
	AOJE D,POPJ1		;IF NO MORE ROOM - DONE
	MOVE C,CTLBTS(B)	;GET USER'S .CALL FLAG BITS
	XCTR XW,[MOVEM C,1(T)]
	AOJE D,POPJ1
	LDB C,[230400,,JBSTS(E)]	;GET # OF ARGS
	XCTR XW,[MOVEM C,2(T)]
	JUMPE C,POPJ1		;ANY ARGS TO PASS?
	ADD T,[3,,3]		;YES - COPY INTO BUFFER
NJBCL2:	JUMPGE T,POPJ1	;ANY ROOM LEFT?
	MOVNS C			;GET SMALLEST WORD COUNT
	HLRE B,T
	CAMLE C,B
	HRL T,C			;MAKE AOBJN PNTR AS SMALL AS POSSIBLE
	MOVE H,E		;JOB INDEX IN H FOR USING JBACTB
	MOVEI B,JBACTB		;GET PNTR TO ARG TABLES
NJBCL3:	MOVE C,@(B)		;GET NEXT ARG
	XCTR XW,[MOVEM C,(T)]	;GIVE TO CALLER
	AOS B
	AOBJN T,NJBCL3
	JRST POPJ1		;DONE - GO SKIP

;	.CALL ADR
;	ERROR RETURN
;	NORMAL RETURN

;ADR:	SETZ
;	SIXBIT /JOBRET/
;	[BOJCHNL]
;	[OPEN LOSS #(IF RH = 0),,# TIMES FOR CREATING JOB TO SKIP]
;	SETZ [-N,,ADR OF DATA BUFFER]

;RETURN DATA (E.G. RETURN TO RCHST,STATUS OR THE RETURN ARGS TO A .CALL
;WILL BE COPIED FROM THE CALLERS DATA BUFFER

NJBRT:	HLRZ E,H	;GET JOB CHNL IDX FROM LH OF IOCHNM WD
	TLNN R,4000	;NOT BOJ CHNL => WRONG TYPE DEVICE.
	 JRST OPNL34
	CAIGE W,3	;RETURN ARGS PROVIDED?
	SETZM C		;NO - ZERO IT
	JUMPGE C,NJBRT1	;DO NOTHING IF NO RETURNS OR NO AOBJN
	HLRE D,C	;GET LENGTH OF BUFFER
	CAMGE D,[-8.]	;MAKE SURE AREA AT MOST 8 LONG
	MOVNI D,8	;OVER 8 - USE 8
	HRL C,D		;FIX AOBJN PNTR
	MOVMS D
	ADDI D,-1(C)	;GET ADDRESS OF LAST WORD NEEDED
	XCTR XR,[SKIP (C)]	;MAKE SURE PAGES ARE IN
	XCTR XR,[SKIP (D)]
NJBRT1:	CONO PI,CLKOFF	;NOW OK TO TURN CLOCK OFF
	MOVE A,JBWST(E)
	TLNE A,JBVAL
	 TLNE A,JBSTR
	  JRST OPNL36	;FAIL IF STORED IS SET OR IF VALID IS CLEARED
	HRRZ TT,JBCUI(E)
	HRRZ I,UPC(TT)
	MOVE D,FLSINS(TT)
	CAME D,JBFLS
	CAIN I,JBPCL
	JRST .+2
	JRST 4,.
	TLO A,(SETZ)
	TLZ A,JBVAL+JBSTR
	MOVEM A,JBWST(E)	;SET SUCCESSFUL JOBRET BIT
	DPB B,[350400,,JBSTS(E)]	;NUMBER OF TIMES TO SKIP
	MOVSS B
	DPB B,[270600,,JBSTS(E)]	;OPEN LOSS
	MOVSI B,-6		;DEFAULT # WDS TO RETURN FOR .RCHST IS 6.
	MOVEM B,JBAC11(E)
	JUMPGE C,NJBRT3		;ANY RETURN ARGS?
	MOVEM C,JBAC11(E)	;REMEMBER HOW MANY, FOR .RCHST TO RETURN THAT MANY.
	MOVE H,E		;YES - COPY THEM
	MOVEI D,JBACTB
NJBRT2:	XCTRI XR,[MOVE B,(C)]	;GET IT
	 SKIPA
	  JRST 4,.		;PAGE IS TIED - NO?
	MOVEM B,@(D)		;PUT INTO ARG TABLE
	AOS D
	AOBJN C,NJBRT2
NJBRT3:	SETZM FLSINS(TT)
	JRST CLKOJ1

JOBCLS:	MOVSI T,JBINCL	;C HAS CLSTB ENTRY
	TLNN C,100000	;SKIP IF JOB INPUT
	MOVSI T,JBOUCL
	IORM T,JBWST(A)	;TURN ON INCLS OR OUTCLS
	MOVE E,A
	CONO PI,CLKOFF
	PUSHJ P,JBINT	;GIVE INT
	SOSGE B,JBNTO(A)
	JRST 4,.
	MOVEI D,-1
	MOVE TT,[000600,,JBCH(A)]
	TLNN C,100000
	MOVE TT,[060600,,JBCH(A)]	;JOB OUTPUT
	DPB D,TT
	JUMPE B,JOBCL1
	MOVEI D,1	;BOJ JOB STILL OPEN ONCE,
	TLNN T,JBINCL
	MOVEI D,0
	DPB D,[420100,,JBWST(A)]
	JRST CLKONJ		;SET BIT FOR DIRECTION STILL OPEN.

JOBCL2:	SKIPE JBNTO(A)
	JRST CLKONJ	;NOT LAST TIME OPEN
JOBCL1:	SETOM JBCG(A)	;INDICATE CREATOR GONE AWAY
JOBCL3:	MOVE E,A	;INTERUPT POOR BOJ GUY
	PUSHJ P,JBINT	;SINCE HE HAS NO CREATOR
	JRST CLKONJ

BOJCLS:	SOSGE BJNTO(A)
	JRST 4,.
	MOVEI D,-1
	LDB TT,[220600,,JBCH(A)]
	CAMN TT,UUAC(U)
	DPB D,[220600,,JBCH(A)]
	LDB TT,[300600,,JBCH(A)]
	CAMN TT,UUAC(U)
	DPB D,[300600,,JBCH(A)]
	POPJ P,

; ROUTINES FOR JOB ACCESS, RCHST,RESET AND STATUS

RCHJOB:	MOVEI J,4	;RCHST IS OPCODE 4
	HRRM J,JBSTS(A)
	PUSH P,A	;SAVE JOB INDEX
	MOVE E,A
	CONO PI,CLKOFF
	PUSHJ P,JBWT	;WAIT FOR AN ANSWER
	POP P,H		;GET JOB CHANNEL INDEX
	HLRE W,JBAC11(H) ;HOW MANY VALUES DID HANDLER GIVE?
	SETO E,		;RE-DEFAULT E TO -1 SINCE WE CLOBBERED.
	MOVE T,[MOVE A,@JBACTB]
RCHJO1:	XCT T
	ADD T,[0 1,1]
	AOJL W,RCHJO1
	HLRE W,JBAC11(H)
	MOVNS W		;RETURN # VALUES WE HAVE
	CAIG W,5	;BUT THERE ARE ALWAYS AT LEAST 5
	 MOVEI W,5
	MOVE J,A	;PUT DEV NAME IN J WHERE NRFNAME LOOKS
	JRST POPJ1	;SKIP TO TELL IT TO LOOK THERE

JBSTAT:	HLRZ A,(R)	;GET JOB INDEX
	HRRZ D,JBWST(A)	;GET MOST RECENT STATUS
	POPJ P,

JBORS:
JBIRS:	MOVEI D,3	;RESET IS OPCODE 3
	HLRZ A,(R)
	HRRM D,JBSTS(A)
	CONO PI,CLKOFF
	MOVE E,A
	PUSHJ P,JBWT	;WAIT FOR IT TO GET PROCESSED
	POPJ P,

JBACCS:	MOVEI D,5	;ACCESS IS OPCODE 5
	HLRZ A,(R)
	HRRM D,JBSTS(A)
	MOVEM B,JBST2(A)
	CONO PI,CLKOFF
	MOVE E,A
	PUSHJ P,JBWT
	JRST POPJ1

;	.CALL ADR	;SKIPS IF SUCCESSFUL.

;ADR:	SETZ
;	SIXBIT /SETIOC/
;	ARG1
;	SETZ ARG2

;ARG1:	CHANNEL BOJ DEVICE IS OPEN ON
;ARG2:	TYPE OF IOCER TO CAUSE

;THIS CALL CAUSES THE NEXT IOT EXECUTED BY THE
;PROCEDURE ON THE OTHER END OF THE CHANNEL TO GET
;THE SPECIFIED IO CHANNEL ERROR

NSTIOC:	HLRZ E,H	;GET JOB CHNL IDX FROM LH OF IOCHNM WD.
	CAIL B,MIOTER
	CAILE B,NIOTER
	JRST OPNL33	;BAD ARG. (NOT LEGAL IOCER)
	TLO B,(SETZ)	;IN CASE IOCER 0 EVER EXISTS
	TLNN R,4000
	 JRST OPNL34	;NOT BOJ CHANNEL
	CONO PI,CLKOFF
	MOVE A,JBCUI(E)	;PREPARE TO STOP CREATOR.
	SKIPGE JBCG(E)
	 JRST OPNL41	;CREATOR WENT AWAY
	MOVE H,APRC(A)
	TLNE H,BULGOS
	 JRST OPNL41	;HE'S BEING KILLED NOW.
	PUSHJ P,RPCLSR	;STOP
	MOVEM B,JBIOCJ(E)
	AOS (P)
	JRST UPCLSR


; .CALL ADR	;SKIPS IF SUCCESSFUL

;ADR:  SETZ
;	SIXBIT/JOBSTS/
;	ARG1
;	SETZ AR2

;ARG1 - CHANNEL BOJ IS OPEN ON
;ARG2 - NEW STATUS (RIGHT HALF OF STATUS WORD ONLY - I.E. DEVICE DEPENDENT STUFF)


NJBSTS:	HLRZ A,(R)	;GET JOB INDEX
	CAIGE W,2	;DID HE SUPPLY STATUS?
	MOVEI B,SNJOB	;NO - RESET TO INITIAL
	HRRM B,JBWST(A)	;REMEMBER WHAT HE SAYS
	JRST POPJ1	;SKIP RETURN

;	.CALL ADR	;SKIPS UNLESS JOB END OF CHNL NOT THERE

;ADR:	SETZ
;	SIXBIT /JOBINT/
;	401000,,BOJCH

;GIVE CREATOR A SECOND WORD INT ON CHANNEL CORRESP TO BOJCH

NJBINT:	TLNN R,4000	;ERROR IF NOT BOJ CHNL.
	JRST OPNL34
	CONO PI,CLKOFF
	HLRZ E,H
	MOVE D,JBCUI(E)
	MOVE B,[300400,,JBCH(E)]
	LDB C,B
	CAMN A,C
	JRST NJBIN1
	SUB B,[060000,,]
	LDB C,B
	CAME A,C
	JRST 4,.
NJBIN1:	SUB B,[<220000,,>-<0200,,>]	;MAKE INTO 6 BIT POINTER
	LDB C,B
	TRNE C,20
	JRST OPNL41	;THAT END DOESN'T EXIST
	ANDI C,17
	MOVE C,CHNBIT(C)
	AND C,MSKST2(D)
	IORM C,IFPIR(D)
	JRST CLKOJ1

SUBTTL PERIPHERAL DEVICE ROUTINES IN SEPARATE FILES

CONSTANTS		;TAKE THIS OUT AGAIN WHEN MIDAS IS FIXED

IFN NMTCS,[
$INSRT MTAPE
]

IFN NUNITS,[
$INSRT UTAPE
]

$INSRT DISK

IFN NETP,[
$INSRT IMP
]

IFN E.SP,[
$INSRT ITSDIS
]

IFN MSPP,[
$INSRT ITSMSP
]

$INSRT TTYDEF

$INSRT TS3TTY

$INSRT ITSDEV

SUBTTL DM DAEMON UUO'S

IFE DEMON,ADEMON==ILUUO

IFN DEMON,[
ADEMON:	JUMPE J,[AOJA J,.+2]	;IF J = 0 THEN SUBTRACT ONE
	XCTR XR,[MOVE J,(J)]	;GET VALUE HERE
	PUSHJ P,LSWTL
	400000,,DEMSW
	PUSHJ P,DEMUSR	;FIND CURRENT USER IN DEMON TABLE
	JRST UTOLKJ	;FAIL, JUST RETURN, NOT DEMON
	HRRE TT,DMTTBL+2(B)
	SUB TT,J
	HRRM TT,DMTTBL+2(B)	;PUT NEW COUNT IN DEMON TABLE
	SKIPLE TT
UTOLJ1:	AOS (P)
UTOLKJ:	CONO PI,UTCON
	JRST LSWPOP

ADEMSIG:MOVE D,B
	CONO PI,CLKOFF	;DON'T LET SYS JOB LOOK TILL WE'RE READY.
	MOVSI T,SCLDMN	;TELL IT TO LOOK FOR US, AFTER UFLS TURNS CLOCK ON.
	IORM T,SUPCOR
	SETZB T,SRN3(U)	;SYS JOB WILL SETOM SRN3 TO RESTART US
	SKIPN SRN3(U)	;WITH 0 IN T => FILE EXISTS, OR OPNL CODE.
	 PUSHJ P,UFLS	;SYS JOB DETECTS US BY PC=ADEMS1.
			;DEMON NAME IS EXPECTED TO BE IN A.
ADEMS1:	JUMPN T,OPNL1-1(T)
	CAIGE W,2	;NO SECOND ARG, JST SIGNAL
	 JRST ADEMS3
	JUMPL D,NUDMTB	;IF 2ND ARG < MERELY CALL NUJBST, NO DEMON ENTRY
	TDZA TT,TT	;ZERO OUT TT
ADEMS3:	 SETOM TT	;SET FLAG
	PUSHJ P,LSWTL	;SIEZE SWITCH
	    DEMSW
	PUSHJ P,DEMSIG
	 JRST LSWPOP	;SIGNAL FAILED
	SKIPN TT	;FLAG NOT SET
	 HRLM D,DMTTBL +2(B)	;SET TIME RQ
	JRST CKOPJ1	;RELEASE SWITCH

NUDMTB:	PCLT
	PUSHJ P,DMBLK1	;WAIT TILL DEMON BLOCK IS CLEARED
	 PUSHJ P,UFLS
	HRROI T,DMBLK
	MOVEM A,DMBLK	;SAVE IN BLOCK NOW
	PUSHJ P,NUJBST
	 JRST NUDMTB	;IF FAILURE AFTER WAIT LOOP BACK
	JRST POPJ1	;SUCCESS

DMBLK1:	SKIPGE DMBLK+1	;FOR DEMON BLOCK TEST
	 POPJ P,	;RETURN, NOT FINISHED LOADING
	MOVE T,UTTYCT
	CAIGE T,MXCZS	;ROOM IN RING BUFFER
	 AOS (P)
	POPJ P,	;SKIP IF ROOM
;UTILITY ROUTINES FOR DEAMONS

;THIS ROUTINE SIGNALS DEAMONS, IT IS RUNNABLE PI OR MAIN LEVEL WITHOUT LOCKING ANY OTHER
;SWITCHES EXCEPT THE ONES IT LOCKS ITSELF
.ERR RIDICULOUS COMMENT

DEMSIG:	PUSHJ P,DEMNAM	;LOOK FOR NAME
	JRST DEMSG2	;HAVE TO MAKE NEW ENTRY
DEMSG1:	AOS (P)
	HLLZ E,DMTTBL+2(B)	;18 BITS 2'S COMPLEMENT
	AOS DMTTBL+2(B)
	HLLM E,DMTTBL+2(B)	;MUST DO THIS WAY TO FIT ABOVE
	SKIPE DMTTBL+1(B)	;DOWN, WANT SYS JOB TO LOOK AT
	POPJ P,
	MOVSI E,SCLDMN
	IORM E,SUPCOR
	AOS REQCNT	;ONLY SIGNAL IF NECESSARY
	POPJ P,

DEMSG2:	SOSGE DEMCNT	;IF NO ROOM FLUSH
	POPJ P,
	PUSH P,A
	MOVEI A,DMTLL	;BUMP POINTER
	ADDB A,DMTPTR
	IDIVI A,DMLNG	;TRUNCATE TO LENGNTH OF TABLE
	SKIPE DMTTBL(B)
	JRST .-4	;SEARCH FOR NEW ENTRY
	POP P,DMTTBL(B)	;SET NAME IN TABLE
	JRST DEMSG1

;ROUTINES TO FIND ENTRY IN TABLE.
;DEMNAM TAKES NAME IN A, DEMUSR TAKES USER INDEX IN U
;THEY SKIP RETURN IF SUCCESSFUL, RETURN OTHERWISE
;IF SUCCESSFUL DEMON TABLE INDEX IS IN B

DEMUSR:	JUMPL U,CPOPJ
	MOVSI B,-DMLNG
	CAMN U,DMTTBL+1(B)
	JRST POPJ1
	ADD B,[DMTLL,,DMTLL]
	JUMPL B,.-3
	POPJ P,

DEMNAM:	MOVSI B,-DMLNG	;SEARCH BY NAME
	CAMN A,DMTTBL(B)
	JRST POPJ1
	ADD B,[DMTLL,,DMTLL]
	JUMPL B,.-3
	POPJ P,

DEMOUT:	PUSHJ P,LSWTL	;CALLED BY KILLING JOB (IN CASE OWNED)
	400000,,DEMSW
	PUSHJ P,DEMUSR
	JRST UTOLKJ
	SETZM DMTTBL+1(B)	;MARK AS DOWN,SYSTEM JOB DECIDES WHAT TO DO
	AOS REQCNT
	MOVSI B,SCLDMN
	IORM B,SUPCOR
	JRST UTOLKJ

DEMMRV:	SETZM DMTTBL+2(B)	;CALL WITH UTCOFF (SYS JOB) REMOVES ENTRY FROM TBL
	SETZM DMTTBL+3(B)	;WITH INDEX OF DEMON IN B
	SETZM DMTTBL(B)
	MOVEI B,1
	AOSGE DEMCNT
	MOVEM B,DEMCNT
	JRST UTCONJ


;DEAMON READ AND SET STATUS ROUTINES

ARDDMST:	PUSHJ P,LSWTL	;READ DEAMON STATUS
	DEMSW
	PUSHJ P,DEMNAM
	JRST RDDMS1	;LOST TRY USER INDEX
	MOVE A,DMTTBL+1(B)
	MOVEI C,L
	IDIVM C,A	;DIVIDE BY L, DON'T CLOBBER B
RDDMS2:	MOVE C,DMTTBL+3(B)
	MOVE B,DMTTBL+2(B)
	PUSHJ P,LSWPOP
	JRST POPJ1

RDDMS1:	PUSH P,U
	MOVE U,A
	PUSHJ P,DEMUSR	;BAD USER
	JRST LKUPOP
	POP P,U
	MOVE A,DMTTBL(B)
	JRST RDDMS2
LKUPOP:	POP P,U
	JRST LSWPOP

ASTDMST:	PUSHJ P,LSWTL	;SET DEAMON STATUS
	400000,,DEMSW
	MOVE D,B
	PUSHJ P,DEMNAM
	JRST STDMS1
STDMS2:	JUMPL D,STDMS4
STDMS3:	SOSLE W
	MOVEM D,DMTTBL+2(B)
	SOSLE W
	MOVEM C,DMTTBL+3(B)
	JRST UTOLJ1
STDMS1:	PUSH P,U
	MOVE U,A
	PUSHJ P,DEMUSR
	JRST UTULKP
	POP P,U
	JUMPGE D,STDMS2
STDMS4:	SKIPGE DMTTBL+1(B)	;REMOVE FROM TABLE IF POSSIBLE
	JRST UTOLKJ	;CAN'T DELETE, LOADING
	SETZM DMTTBL+1(B)	;DOWN
	SETZM DMTTBL+2(B)	;REMOVE REQUESTS
	AOS REQCNT	;SIGNAL SYS JOB
	MOVSI B,SCLDMN
	IORM B,SUPCOR
	JRST UTOLJ1
UTULKP:	POP P,U
	JRST UTOLKJ
]


SUBTTL IO CHANNEL PUSH DOWN LIST ROUTINES

;LOOK AT LH OF RESET TABLE TO SEE IF DEVICES HAVE ROUTINES (FOR INTERRUPTS ETC)
;C(I) =0 AT DSP => IOPUSH =1 => IOPOP

NIOPUS:	AOS (P)
AIOPUSH:MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	CAML T,[LUIOP-2,,]
	 JRST IOCER6	;OVER PUSH ERROR
	PUSH T,(R)	;PUSH CURRENT IOCHNM
	PUSH T,IOCHST-IOCHNM(R)	;&IOCHST
	HRRZ A,(R)
	MOVE J,UUAC(U)
	DPB J,[400400,,(T)]	;STORE CHANNEL NUM FOR POSSIBLE USE BY AIOPDL
	MOVEM T,SIOCP(U)	;STORE BACK PDL POINTER
	MOVEI I,0	;INDICATE IOPUSH
	PUSH P,R
	PUSHJ P,AIOPP1	;CALL DEVICE'S IOPDL HANDLER.  SHOULD NOT HANG
	POP P,R
	SETZM (R)	;CLEAR OUT IOCHNM
	SETZM IOCHST-IOCHNM(R)	;&IOCHST
	POPJ P,

NIOPOP:	AOS (P)
AIOPOP:	PUSHJ P,ACLOSE	;CLOSE WHATEVER MAY BE OPEN ON CHANNEL POPPING INTO
	MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	TLNN T,-1
	 JRST IOCER5	;OVER POP ERROR
	POP T,IOCHST-IOCHNM(R)	;POP BACK IOCHST
	POP T,(R)		;&IOCHNM
	HRRZ A,(R)
	SETZM 1(T)	;CLEAR OUT PDL WORD TO AVOID CONFUSION IN
			;ROUTINES THAT GROVEL OVER I/O PDL
	MOVEM T,SIOCP(U)	;STORE BACK PDL POINTER
	MOVEI I,1	;INDICATE IOPOP
	JRST AIOPP1	;CALL DEVICE'S IOPDL HANDLER

AIOPDL:	MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	TLNN T,-1	;SKIP UNLESS IO PDL EMPTY
	POPJ P,
	LDB R,[400400,,(T)]	;FIND OUT WHAT CHNL TOP ENTRY WAS PUSHED FROM
	ADDI R,IOCHNM(U)
	PUSHJ P,AIOPOP	;POP BACK INTO CHNL PUSHED FROM
	JRST AIOPDL

IIOPPR:	JUMPE I,[JRST 4,CPOPJ]	;IOPUSH
	SETZM (R)	;CLOSE CHANNEL
	SUBI R,IOCHNM(U)	;GET CHANNEL NUMBER
	MOVE R,CHNBIT(R)	;SECOND WORD INTERRUPT BIT
	IORM R,IFPIR(U)	;GIVE TO USER
	POPJ P,

SUBTTL .GETSYS UUO

;.GETSYS AC,	;TRANSFERS SYSTEM AREA SPECIFIED BY C(AC+1)
		;TO USER AREA STARTING AT R.H. C(AC) OF LENGTH MINUS L.H. C(AC)

AGETSYS:PUSHJ P,UDELAY		;CAUSE A SCHEDULE TO STOP GETSYSER FROM MONOPOLIZING SYSTEM
	MOVSI A,-<GSYS1-GSNAME>	;NEGATIVE OF TABLE LENGTH
	XCTR XR,[MOVE B,1(J)]	;LOOK AT USERS AC+1, THE 6BIT NAME
	CAME B,GSNAME(A)	;CYCLE THROUGH TABLE
	 AOBJN A,.-1		;OF NAMES, POINTER IN RIGHT HALF OF A
	JUMPGE A,AGETSL		;JUMP IF NOT IN TABLE
	XCTR XR,[MOVE B,(J)]	;GET POINTER TO USERS RECEPTACLE BLOCK
AGETS1:	HLRZ C,GSYS1(A)		;GET LOW END OF BLOCK
	HRRZS A			;CLEAR COUNT IN L.H. OF A
	CAIGE A,NUTCFN		;SKIP IF UTC OFF NOT REQUIRD
	 CONO PI,UTCOFF		;TURN OFF ALL CHANNELS BUT CH 1
	TRNE C,700000		;SKIP IF TABLE ENTRY NOT AN INSTRUCTION
	 XCT GSYS1(A)		;EXECUTE THE INSTRUCTION
	HRRZ D,GSYS1(A)		;GET HIGH END OF BLOCK
;AT THIS POINT:		;B USER'S POINTER (UNRELOCATED)
			;C BEGINNING OF AREA IN SYS
			;D END OF AREA
	SUBI D,-1(C)		;BLOCK LENGTH TO BE SENT
	HLRZ E,B		;GET NEG BLK LENGTH FROM USERS PNTR
	ADDI E,-1(D)		;-1 CAUSES CARRY BIT IF .GT.
	TLNE E,-1		;CARRY INDICATES LOSS
	 JRST AGETS5		;MORE THAN USER WANTS
	HRLS D			;BLOCK LENGTH IN BOTH HALVES
	HRRZ E,B		;FIRST WORD (UNRELOCATED)
	HRL E,C			;SOURCE ADDRESS FOR BLT
	HRRZ C,E		;DESTINATION INTO C
	ADD C,D			;FINAL ADDRESS +1
AGETS7:	XCTRI XBW,[BLT E,-1(C)]	;BLT IT TO HIM
	 AOSA (P)		;INCREMENT RETURN, INDICATE SUCCESS
	  JRST AGETS6
	CONO PI,UTCON
	ADD B,D
	XCTR XW,[MOVEM B,(J)]	;TELL USER HOW MUCH HE GOT
AGETS4:	POPJ P,

AGETSL:	XCTR XW,[SETZM 1(J)]	;INDICATE BAD SIXBIT
	POPJ P,

AGETS5:	MOVNS D			;TELL USER HOW MUCH HE NEEDS
	CONO PI,UTCON		;NEGATIVE OF RIGHT BLOCK LENGTH
	XCTR XRW,[HRLM D,(J)]	;SET UP PROPER BLOCK LENGTH IN HIS AC
	JRST AGETS4

AGETS6:	CONO PI,UTCON		;ONE PAGE WASN'T THERE
	XCTR XRW,[MOVES (E)]	;SO TOUCH IT (TAKE MPV INTERRUPT IF REAL MPV)
	JRST AGETS1		;AND TRY AGAIN (BLT WILL GET FARTHER THIS TIME)
				;HAD TO RETRY FROM BEGINNING SINCE THIS MAY BE
				;ONE THAT HAS TO BE TRANSFERRED INTACT WITH UTCOFF

GSNAME:	SIXBIT /MEMORY/
IFN NUNITS,SIXBIT /UTAPE/
IFN NETP,[SIXBIT /NCPSM/
	SIXBIT /NCPPQ/
	SIXBIT /NCPHT/
]
NUTCFN==.-GSNAME	;NUMBER TO GET WITH UTCOFF
	SIXBIT /USERS/
	SIXBIT /USER/
	SIXBIT /GETS/
	SIXBIT /DEVS/
	SIXBIT /CALLS/
IFN IMXP,	SIXBIT /IMPX/
	SIXBIT /CLINK/
	SIXBIT /DSYMS/
	SIXBIT /USYMS/	;.UPC, .VAL, .TTY, ETC.
	SIXBIT /CHDEVS/
	SIXBIT /NCALLS/


;ENTRIES ARE:   BOTTOM,,TOP  OF AREA TO BE TRANSMITTED OR INST TO EXECUTE
GSYS1:	IOBFTL,,EMEMTL	;4.9 - 4.7 NOT ZERO => XCT THIS ENTRY
IFN NUNITS, UTCHNT,,UTCHE	;UTAPE
IFN NETP,[IMSOKB,,IMSOKE	;NCP SOCKET MAP
	IMPBPQ-1,,IMPEPQ	;NCP PENDING RFC QUEUE
	IMPHTB,,IMPHTB+255.	;NCP HOST TABLE
]
	PUSHJ P,USRSV	;USERS
	PUSHJ P,USR1V	;USER
	GSNAME,,GSYS1-1	;GETS
	DEVTAB,,EDEVS	;DEVS
	SYSYMB,,SYSYME	;CALLS
IFN IMXP,	IMXTBB,,IMXTBE	;IMPX
	CLVBEG,,CLVEND	;CLINK
	PUSHJ P,DSYMS	;DSYMS
	SYSUSB,,SYSUSE	;USYMS
	DCHSTB,,DCHSTE	;CHDEVS
	SYSCTB,,SYSCTD-1	;NCALLS

USRSV:	MOVEI C,USRSTG
	MOVE D,USRHI
	ADDI D,USRSTG-1
	JRST POPJ1

USR1V:	XCTR XR,[MOVE C,2(J)]
	IMULI C,LUBLK
	CAML C,USRHI
	JRST USR1VL
	ADDI C,USRSTG
	MOVE D,C
	ADDI D,LUBLK-1
	JRST POPJ1

USR1VL:	SUB P,[1,,1]
	XCTR XW,[SETOM 2(J)]
	JRST AGETS4

DSYMS:	HRRZ C,DDT-2
	HLRE D,DDT-2
	SETCMM D	;OFFSET BY ONE
	ADD D,C
	JRST POPJ1

SUBTTL .GETLOC, .EVAL, ETC.

;GET AN ABSOLUTE LOCATION	;.GETLOC AC,	;C(A)=FROM(ABS),,TO(RELATIVE)
;
AGETLOC:XCTR XR,[MOVE A,(J)]	;GET TO ADDRESS
	HLRZ B,A		;GET FROM ADDRESS
	XCTRI [MOVE C,(B)]
	 JRST .+2
	  JRST ILEXPF		;ILLEGAL EXEC PAGE FAULT
	XCTR XW,[MOVEM C,(A)]	;GIVE TO USER
	POPJ P,

;SET AN ABSOLUTE LOCATION	;.SETLOC AC,	;C(AC)=FROM(RELATIVE),,TO(ABS)
;
ASETLOC:TDZA D,D	;CLEAR COND FLAG, SKIP

;SET AN ABSOLUTE LOCATION ONLY IF C(ABS)=C(TEST) & SKIP IF SUCCESSFUL
;.IFSET AC,	;C(AC)=<POINTER TO 2 WORD BLOCK>,,TO ADR(ABS)
;WORD 1=TEST	;WORD 2=NEW C(ABS)

AIFSET:	MOVNI D,1	;SET COND FLAG
	XCTR XR,[HRRZ A,(J)]	;GET TO ADDRESS (ABSOLUTE)
	XCTR XR,[HLRZ B,(J)]
	XCTR XR,[MOVE C,(B)]	;GET WORD
	XCTRI [MOVES (A)]
	 JRST .+2
	  JRST ILEXPF
	JUMPE D,ASPST1	;NORMAL SETLOC
	XCTR XR,[MOVE D,1(B)]	;GET NEW VALUE
	CONO PI,CLKOFF	;PREVENT INTERRUPTS
	CAME C,(A)	;CHECK WORD AGAINST TEST WORD
	 JRST CLKONJ	;NOT EQUAL => IGNORE
	MOVE C,D
	AOS (P)		;CAUSE RETURN TO SKIP
	CAIG A,SYSB_10.	;CHECK IF IN SYS
	 JRST ASPST1	;YES SO DO REG SETLOC
	EXCH D,(A)	;NO SO DO NOW BEFORE SHUFFLE & GET OLD
ASPST2:	MOVE C,D
	HRROS A		;LET SYS JOB KNOW ALREADY DONE
ASPST1:	CAMN C,(A)	;SKIP IF DIFFERENT FROM C(TO ADR)
	 JRST CLKONJ	;SAME
	MOVE D,LUBTIM	;IF SYSTEM JOB HAS BEEN HUNG FOR 30 SEC,
	ADDI D,30.*30.
	CAMGE D,TIME
	 JUMPGE A,ASPST3	;GO DO THE WORK OURSELVES (BUT DON'T DO IT TWICE).
ASPST4:	MOVE D,UNAME(U)	;GET UNAME OF SETLOCER
	MOVSI T,SCLSET
	PUSHJ P,CWAIT	;WAIT TILL VARIABLES TO COMMUNICATE WITH SYS JOB ARE FREE
	    TDNE T,SUPCOR	;ARG TO CALL IN .-1
	MOVEM A,SETSLC	;REMEMBER ABS LOCATION
	MOVEM C,SETSLQ	; " NEW CONTENTS (OR OLD IF LH(SETSLC)=-1)
	MOVEM D,SETSU	; " USER
CSPST:	IORM T,SUPCOR	;TELL SYS JOB TO DO IT
	JRST CLKONJ

ASPST3:	HRRZ D,UPC	;SYS JOB HAS BEEN HANGING FOR 30 SEC.
	CAIN D,SCOR1	;WHY? JUST SLEEPING?
	 JRST ASPST4	;YES => SIGNAL IT TO DO THE WORK
	MOVEM C,(A)	;ELSE GIVE UP ON IT AND DO IT NOW
	JRST CLKONJ

;LOOK UP ITS SYMBOL	;.EVAL AC,	;C(AC)=SQUOZE SYMBOL
;REPLACES SYMBOL BY VALUE & SKIPS IF SUCCESSFUL
;IF YOU WANT TO .EVAL A SYMBOL IN A PROGRAM HABITUALLY AND IMPLICITLY,
;AND WANT IT TO CONTINUE TO WORK, YOU HAD BETTER ADD AN ENTRY TO THE FILE
;AI:SYSTEM;EVSYMS > SAYING WHAT PROGRAM AND WHAT SYMBOL. THEN, ITS HACKERS
;CAN AVOID SCREWING YOU WITHOUT WARNING.

AEVAL:	PUSHJ P,SWTL
	ARDFSW
	XCTR XR,[MOVE B,(J)]	;GET SYM
	PUSHJ P,SYMLK	;LOOK UP
	JRST LSWPOP		;NOT FOUND
	MOVE A,(C)	;GET VALUE
	PUSHJ P,LSWPOP
	AOS (P)		;CAUSE UUO TO SKIP
	JRST APTUAJ	;RETURN VALUE

;REDEFINE ITS SYMBOL	;.REDEF AC,	;C(AC)=POINTER TO 2 WORD BLOCK
;WORD 1 = SYMBOL	;WORD 2 = VALUE
;DELETE SYM IF ALL 4 FLAG BITS SET
;  OTHERWISE SET SYMBOL FLAGS TO THOSE SPECIFIED, EXCEPT REJECT ANY ATTEMPT TO
;  ADD A PROGRAM NAME
;ADD SYM IF NOT FOUND	;FAIL ONLY IF NOT ENOUGH ROOM
;SKIPS IF SUCCESSFUL

AREDEF:	PUSHJ P,SWTL
	    ARDFSW
	XCTR XR,[HRRZ D,(J)]	;GET POINTER FROM AC
	XCTR XR,[MOVE B,(D)]	;GET SYMBOL
	PUSHJ P,SYMLK	;LOOK UP
	JRST ARDF2	;NOT FOUND, CREATE
	XCTR XR,[SETCM A,(D)]	;GET SYM (COMPLEMENTED)
	TLNN A,740000	;SKIP IF ANY FLAGS NOT SET
	JRST ARDF3	;ALL SET => DELETE
	SETCA A,
	TLNN A,740000
	JRST LSWPOP
	MOVEM A,-1(C)
	XCTR XR,[MOVE A,1(D)]	;GET VALUE
	MOVEM A,(C)	;STORE IN SYMTAB
	JRST ARDF4	;SORT AND SKIP-RETURN.

ARDF2:	MOVE C,DDT-2	;GET POINTER
	SUB C,[2,,2]	;DECREMENT FOR NEW ENTRY
	MOVEI A,-1(C)	;FUDGE FOR BLOCK CALC
	LSH A,-10.	;CONVERT TO # OF BLOCKS UP TO SYMTAB -1
	XCTR XR,[MOVE B,(D)]	;GET SYM
	TLNE B,740000	;LOSE IF PROG NAME
	CAILE A,LDDTADR	;CHECK FOR LOSSAGE
	 JRST LSWPOP	;DON'T OVERWRITE TS
	EXCH B,2(C)	;STORE OVER GLOBAL BLOCK HEADER,
	MOVEM B,(C)	;MOVE THAT HEADER DOWN 2 WDS.
	XCTR XR,[MOVE A,1(D)]	;GET VALUE
	EXCH A,3(C)
	ADD A,[-2,,]	;1 MORE SYM IN GLOBAL BLOCK.
	MOVEM A,1(C)	;STORE
	MOVEM C,DDT-2	;UPDATE POINTER
	JRST ARDF4	;GO SORT AND SKIP-RETURN.

ARDF3:	MOVE B,DDT-2	;GET POINTER
	MOVE A,(B)	;MOVE THE GLOBAL HEADER
	EXCH A,2(B)	;UP OVER 1ST SYM
	MOVEM A,-1(C)	;WHICH GOES INTO FREE SLOT.
	MOVE A,1(B)
	ADD A,[2,,]	;GLOBAL BLOCK 1 SYM SHORTER.
	EXCH A,3(B)
	MOVEM A,(C)
	MOVE A,[2,,2]
	ADDM A,DDT-2	;UPDATE POINTER
ARDF4:	MOVSI E,(SETZ)	;TELL DDT ITS SYMTAB WAS ALTERED.
	IORM E,DDT-1
	PUSHJ P,SBUBL	;DO 1 BUBBLE-SORT UP AND 1 DOWN.
	JRST LSWPJ1	;FREE ARDFSW AND EXIT.

EBLK
ARDFSW:	-1 ? 0
BBLK

;DO ONE BUBBLE SORT PASS UP, ONE DOWN; LEAVE J <0 IFF DID AN EXCHANGE.
;CLOBBER A-E.
SBUBL:	MOVE E,DDT-2
	HLL E,1(E)
	ADD E,[2,,2]	;AOBJN -> SYMS IN GLOBAL BLOCK.
SBUBL0:	SETZ J,
	MOVE B,[2,,2]	;INCREMENT FOR UPWARD PASS.
	MOVE C,[JUMPL A,SBUBL1]
	SUBI E,2	;(WILL INCREMENT BEFORE ACTING)
	MOVE A,E
	PUSHJ P,SBUBL2
	MOVNS B		;DECREMENT FOR DOWNWARD PASS.
	MOVE C,[CAMN A,E]
	JRST SBUBL2

SBUBL1:	MOVE D,1(A)	;CHECK NEXT PAIR OF ENTRIES.
	CAMG D,3(A)
	 JRST SBUBL2	;IN CORRECT ORDER.
	EXCH D,3(A)
	MOVEM D,1(A)	;WRONG ORDER, EXCHANGE.
	MOVE D,(A)
	EXCH D,2(A)
	MOVEM D,(A)
	SETO J,		;SAY DID AN EXCHANGE.
SBUBL2:	ADD A,B		;MOVE TO NEXT ENTRY.
	XCT C		;TEST IF FINISHED.
	 POPJ P,
	JRST SBUBL1	;(NOT FINISHED)

;LOOK UP SYMBOL IN B IN ITS SYMBOL TABLE (CLOBBERS A,B,C)
;RETURN WITH POINTER TO VALUE WORD IN C
;SKIPS IF SUCCESSFUL

SYMLK:	TLZ B,740000	;FLUSH FLAGS
	MOVE C,774000-2	;PICK UP AOBJN POINTER TO SYMTAB FROM EXEC DDT
SYMLK2:	MOVE A,(C)	;GET SYM
	AOBJP C,[JRST 4,.+1]	;INCREMENT POINTER
	TLNE C,376	;GO THROUGH HAIR EVERY 200 SYMS
	JRST SYMLK3	;NOT THIS TIME
	PUSHJ P,OPBRK
SYMLK3:	TLNN A,200000	;SKIP IF DELETE INPUT (FLAG PREVENTS MATCH)
	TLZE A,740000	;FLUSH FLAGS & CAUSE LOSS IF ALL 0 (PROG NAME)
	CAME A,B	;COMPARE
	AOBJN C,SYMLK2	;LOSS, TRY ANOTHER
	JUMPL C,POPJ1	;SKIP RETURN IF FOUND
	POPJ P,		;NOT SO IF LOSS

AWSNAME:XCTR XR,[SKIPE B,(J)]	;OPER 35
	 MOVEM B,USYSNM(U)
	POPJ P,

AUPISET:XCTR XR,[MOVE B,(J)]	;OPER 36
	ASH B,-35.
	EXCH B,PICLR(U)
	XCTR XW,[MOVEM B,(J)]
	SKIPN PICLR(U)
	 POPJ P,
	JRST APISE1

;GENERATE A UNIQUE SYM 	;.GENSYM AC,	;LOADS AC WITH SYM
;
AGENSYM:PUSHJ P,SWTL	;WAIT TILL INTERLOCK FREE THEN SEIZE IT
	  GENSSW
	MOVEI TT,IGNSYM
	PUSHJ P,SIXAOS	;INCREMENT SYM
	MOVE A,IGNSYM	;GET SYM
	PUSHJ P,LSWPOP	;UNLOCK FOR NEXT USER
	JRST APTUAJ	;GIVE USER GENERATED SYMBOL

EBLK

GENSSW:	-1
	0
IGNSYM:	SIXBIT /SYS/

BBLK

SIXAOS:	PUSH P,I
	PUSH P,J
	AOS (TT)	;INCREMENT SYM
	MOVE I,[440600,,(TT)]	;GET POINTER TO FIRST CHAR
SIXAS2:	ILDB J,I	;GET FIRST (NEXT) CHAR
	SKIPN J		;SKIP IF NOT ZERO
	MOVEI J,1	;REPLACE EMBEDDED SPACE WITH "!"
	DPB J,I		;PUT BACK
	CAME I,[60600,,(TT)]	;SKIP IF FIRST FIVE CHARS HAVE BEEN EXAMINED
	 JRST SIXAS2	;GO TO NEXT CHAR
	POP P,J
	POP P,I
	POPJ P,

IFN KL10P,[

SUBTTL KL10 PERFORMANCE COUNTER

;KLPERF SYMBOLIC SYSTEM CALL
;ARG 1: <JOB> TO MEASURE PERFORMANCE DURING;
	;-3 => NULL JOB, -4 => ALL JOBS
;ARG 2: P.A. ENABLES WORD (SEE NON-EXISTENT KL10 SYS REF MAN)
	;0 => FREE THE FACILITY, ELSE TRIES TO GRAB IT
;NO ARGS => JUST READS THE VALUES WITHOUT CHANGING THE ENABLING CONDITIONS.
	;IN THAT CASE, IT IS OK IF FACILITY IS OWNED BY SOMEONE ELSE
;VAL 1:	PREVIOUS <JOB> SETTING
;VAL 2: PREVIOUS P.A. ENABLE WORD
;VAL 3: TIME BASE HIGH WORD
;VAL 4: TIME BASE LOW WORD
;VAL 5: PERF CTR HIGH WORD
;VAL 6: PERF CTR LOW WORD

KLPERF:	CONO PI,CLKOFF
	JUMPN W,KLPER1
KLPER0:	MOVE J,MTRJOB	;NO ARGS => DONT CHANGE SETTINGS,
	MOVE B,PAEON	;JUST RETURN CURRENT COUNT.
	JRST KLPER3

KLPER1:	JUMPN B,KLPER2	;TRYING TO TURN IT ON?
	CAME U,MTRUSR
	 JRST KLPER0	;FREEING THE FACILITY WHEN DON'T OWN IT?
	SETOM MTRUSR	;NO, TRYING TO FREE IT - DO SO.
	MOVEI J,-2
	CONO MTR,4000
	JRST KLPER3

KLPER2:	SKIPGE MTRUSR	;IF FACILITY IS FREE, SIEZE IT.
	 MOVEM U,MTRUSR
	CAME U,MTRUSR
	 JRST OPNL10	;ALREADY BELONGS TO SOME OTHER JOB.
	MOVEI J,2(A)
	CAIN J,-2	;ALL JOBS?
	 JRST KLPER4
	CAIN J,-1	;NULL JOB?
	 JRST KLPER3
	MOVE J,A
	JSP T,NCRUI2	;ELSE DECODE JOB SPEC; OBJECT TO PDP6
	 JFCL
	CAME J,U
	 JRST KLPER3
;TRYING TO TURN ON FOR SELF OR ALL JOBS - IT OUGHT TO BE ON RIGHT NOW!
KLPER4:	CONO MTR,2000	;TURN ON TIME BASE
	WRPAE B		;SET ENABLES
KLPER3:	EXCH B,PAEON
	SKIPGE A,MTRJOB
	 TRZA A,2	;UN CONVERT -1 => -3, -2 => -4
	  LSH A,-9	;IDIVI A,LUBLK
IFN LUBLK-1000,.ERR NO DIVIDE
	HRREM J,MTRJOB
	RCCL C		;C,D GET TIME BASE
	RPERFC E	;E,TT GET PERFC
	JRST CLKOJ1

$INSRT CORE		;CORE JOB AND MEMORY MANAGEMENT ROUTINES


IFE KL10P,[

SUBTTL EXEC PAGING MAP

IFN PDP6P,[
;DBR FOR REFERENCING PDP6 MEM
PDP6MP:	<LPDP6M/2>_1,,PDPUMP
]

EXECMP:	100_1,,EXEUMP	;EXEC DBR POINTER

;TABLE OF BYTE POINTERS THAT POINT TO VIDEO BUFFER AREA OF EXEUMP
IFN N11TYS,[
TTCRT:	REPEAT NTVBP,[
		CONC [.TTR]\.RPCNT,+EXEUMP
]
]
EBLK
;AGES CAN GET STORED

IFN PDP6P,[	;PAGE MAP FOR REFERENCING PDP6 MEM
PDPUMP:	REPEAT LPDP6M/2,600000+<PDP6BM_-10.>+2*.RPCNT,,600000+<PDP6BM_-10.>+2*.RPCNT+1
]

EXEUMP:	REPEAT 100-<DDTPGS+1>/2,0	;SET UP FURTHER AT SYSTEM STARTUP
	IFN DDTPGS&1,600000+200+<.-EXEUMP>*2+1
	REPEAT DDTPGS/2,600000+200+<.-EXEUMP>*2,,600000+200+<.-EXEUMP>*2+1

DDEXCF:	BLOCK NEXPGS	;-1 IF SET UP TO EXEC PAGE

BBLK
]

IFN KL10P,[
EBLK			;AGES CAN GET STORED
ZZ==.
	LOC EXELMP	;EXEC LOWER MAP, DIRECT AND CACHED
EXELMP:	.BYTE 18.
	600000		;EXCEPT PAGE 0 IS NOT CACHED
	REPEAT 177,600000+PMCSHM+.RPCNT+1

	.BYTE		;EXEC UPPER MAP
EXEUMP:	.BYTE 18.
	REPEAT 200-DDTPGS,0	;SET UP FURTHER AT SYSTEM STARTUP
	REPEAT DDTPGS,600000+PMCSHM+400-DDTPGS+.RPCNT

	.BYTE
LOC ZZ
BBLK
]

CONSTANTS		;MIDAS CONSTANTS BUFFER IS ONLY SO BIG

SUBTTL NULL DEVICE
;  READS ZEROS ON INPUT, HAS NO EFFECT ON OUTPUT
;
NULO:	HLRS A,C		;REMEMBER MODE FOR .STATUS
	JSP Q,OPSLC3	;SET UP IOCHNM WORD AND EXIT
	NLIDN,,NLODN	;ARG
	NLBIDN,,NLBDN	;ARG

;UNIT NULL DEVICE INPUT
NULI:	SETZ W,		;RETURN A ZERO.
	POPJ P,

;BLOCK NULL DEVICE INPUT (READS ZEROS)
NULBI:	XCTR XR,[HRRZ D,(C)]	;PICK UP STARTING LOC (R.H. .IOT PNTR)
	XCTR XR,[HLRE TT,(C)]	;PICK UP NEG LENGTH
	JUMPGE TT,CPOPJ	;IGNORE IF LENGTH ZERO OR RIDICULOUS (>2**17)
	MOVNS TT	;GET POSITIVE LENGTH
	HRLS D		;PUT IN BOTH HALVES
	XCTR XW,[SETZM (D)]	;ZERO FIRST LOC
	AOS D		;MAKE C(D) A BLT PNTR TO COPY EACH WORD INTO NEXT
	ADD TT,D	;GET LAST LOC + 2
	XCTR XBRW,[BLT D,-2(TT)]	;ZERO THE BLOCK
;BLOCK NULL DEVICE OUTPUT ENTRY
;ADVANCE BLOCK MODE .IOT POINTER
NULBOD:	XCTR XR,[HLRE A,(C)]	;GET NEG LENGTH FROM LEFT HALF
	MOVNS A		;GET POSITIVE LENGTH
	XCTR XR,[ADD A,(C)]	;ADD STARTING LOC (R.H.)
	XCTR XW,[HRRZM A,(C)]	;STORE BACK "COUNTED OUT" POINTER
	POPJ P,

STDSTA:	DPB A,[60300,,D]	;A HAS CH OF IOC WORD
	TRO D,1_9		;SYS BUF CAP FULL
	TRNE D,1_6		;SKIP IF INPUT
	TRC D,3_9		;TURN OFF SYS BUF CAP FULL, SET EMPTY
	POPJ P,

SUBTTL USER DEVICE

UBPFJ==10	;DEMAND FOREIGN JOB (BIT IN LH (DEV) FOR .OPEN (USR))

USROJ:	TDZA J,J	;ENTRY FROM JOB DEVICE DONT GET CORE.
USRO:	MOVNI J,1	;INDICATE NOT FROM JOB OPEN
	CAIA
USROOJ:	 MOVEI J,1	;OJB DEVICE; EXISTING JOB OK ONLY IF OPTOJB BIT SET.
	PCLT
	SKIPL CORRQ(U)
	PUSHJ P,UFLS	;PREVENT ATTEMPT TO CORE, PCLSR OUT, AND THINK YOU'VE WON AT SETBF1, ETC
	PUSHJ P,SWTL
	    TREESW
	JUMPE B,USRO4	;JNAME = 0 => UNAME IS JOB SPEC.
	SKIPN A		;IF UNAME=0
	 MOVE A,UNAME(U)	;MAKE IT THIS JOB'S UNAME
IFN PDP6P,[
	CAME A,UNAME(U)	;SKIP IF FIRST FILE NAME IS UNAME OF OPENER
	 JRST USROA
	CAME B,[SIXBIT /PDP10/]	;SKIP IF SECOND FILE NAME IS "PDP10"
	 CAMN B,[SIXBIT /PDP6/]	;OR PDP6
	  JRST PDPO
]

USROA:	MOVEI TT,0
	CONO PI,CLKOFF
	PUSHJ P,LSWPOP	;TREESW
USRO3:	CAME A,UNAME(TT)
	 JRST AGIN
	CAMN B,JNAME(TT)
	 JRST UFN1	;FOUND UNAME JNAME PAIR
AGIN:	ADDI TT,LUBLK
	CAMGE TT,USRHI
	 JRST USRO3
	PUSH P,U
TCORS:	TLNE C,UBPFJ	;JOB MUST EXIST TO WIN IF UBPFJ SET
	 JRST NOGO5
	CAME A,UNAME(U)	;INFERIOR PROCEDURE MUST HAVE
	 JRST NOGO2
	MOVSI T,%TBNOT+%TBDTY	;DOESN'T HAVE TTY, ISN'T GIVING IT AWAY
	PUSHJ P,USTRA	;MUST HAVE U IN -1(P)
	 JRST TCORS1	;USTRA FAILED - SEE WHY, MAYBE RETRY
	MOVEM A,UNAME(U)
	MOVEM B,JNAME(U)
	MOVEM A,USYSNM(U)
	MOVE TT,U
	POP P,U
	MOVE A,UTMPTR(U)
	MOVEM A,UTMPTR(TT)
	MOVE A,XUNAME(U)
	MOVEM A,XUNAME(TT)
	PUSHJ P,USRST5	;SET UP TTY STUFF
	MOVSI A,400000
	SKIPGE APRC(U)
	 IORM A,APRC(TT)	;NEW INFERIOR IS DISOWNED IF CREATOR IS.
	CONO PI,CLKON
	JUMPE J,POPJ1	;RETURN HERE FOR JOB DEVICE (INDEX IN TT)
	PUSHJ P,ULUP1
	 JRST NOGO1
	JRST SETBIT

ULUP1:	CLEARB A,T
ULUP:	HRRZ E,SUPPRO(T)
	SKIPN UNAME(T)	;SKIP IF VARIABLE BLOCK IN USE
	JRST ULUP2
	CAIN E,(U)	;SKIP IF NOT AN INFERIOR
	IOR A,SUPPRO(T)	;IOR IN INTERRUPT BIT OF INFERIOR
ULUP2:	ADDI T,LUBLK	;ADVANCE TO NEXT BLOCK
	CAMGE T,USRHI	;SKIP IF ALL EXAMINED
	JRST ULUP	;LOOP
UFIN:	MOVEI B,1	;SELECT INT BIT
UFIN2:	TLON A,(B)
	JRST POPJ1
	LSH B,1
	CAIGE B,1_<NINFP>
	JRST UFIN2
	POPJ P,

NOGO1:	MOVE U,TT
	PUSHJ P,ZUSER
	JRST OPNL5	;DIREC FULL (TOO MANY LOSERS)

NOGO2:	SUB P,[1,,1]
	JRST OPNL20

NOGO3:	SUB P,[1,,1]
	JRST OPNL10

NOGO4:	SUB P,[1,,1]
	JRST OPNL6

NOGO5:	SUB P,[1,,1]
	JRST OPNL4	;FILE NOT FOUND

USRO4:	EXCH J,A	;USR: OPEN WITH JNAME=0: USE UNAME AS JOB SPEC.
	JSP T,NCORUI
	 JFCL
IFN PDP6P,[
	CAIN J,-1	;SPEC'D JOB IS PDP6 => OK,
	 JRST PDPO
]
	CONO PI,CLKOFF
	PUSHJ P,LSWPOP	;SOS DIELOK(J)
	PUSHJ P,LSWPOP	;TREESW
	MOVE TT,J
	MOVE J,A
;COME HERE WHEN JOB ALREADY EXISTS, WITH CLOCK OFF AND USR IDX IN TT.
;A, B, C STILL HAVE UNAME, JNAME AND OPEN MODE.
UFN1:	JUMPE J,[ADDI B,10000	;OPENING JOB-DEVICE AND JOB EXISTS??
		 JRST USROA]	;KEEP CHANGING JNAME UNTIL WE CREATE A JOB.
	CAIG TT,LUBLK
	 JUMPL J,UFNDF	;SKIP SOME CHECKS ON SYS & CORE
	SKIPE NMPGS(TT)
	 JRST UFN1A
	MOVSI T,BUSRCR	;CONT LET FOREIGN USERS OPEN JOB
	PCLT
	TDNE T,APRC(TT)	;UNTIL JOB HAS CORE (I.E. ORIG OPEN THAT CREATED JOB
	 PUSHJ P,UFLS	;HAS COMPLETED). OTHERWISE
			;ZUSER CALLED WHEN THAT OPEN PC LSRED OUT OF COULD
			;ITSELF HANG UP TRYING TO FLUSH FOREIGN USER CHNLS
UFN1A:	JUMPG J,[MOVSI E,OPTOJB	;OJB DEVICE OPEN; IF JOB DOESN'T HAVE OPTOJB SET,
		TDNE E,OPTION(TT)	;THEN IT HASN'T GIVEN PERMISSION TO BE HACKED.
		 SKIPL JBI(TT)	;IF IT'S ALREADY A JOB DEVICE DON'T HACK IT.
		  JRST [CONO PI,CLKON	;IN EITHER CASE, WAIT TILL ALL'S OK,
			SKIPL JBI(TT)
			 PUSHJ P,UFLS
			TDNN E,OPTION(TT)
			 PUSHJ P,UFLS
			JRST USROOJ]	;THEN RE-TRY THE OPEN.
		LDB E,[.BP BULGOS_22,APRC(TT)]
		JUMPN E,OPNL42
		JRST CLKOJ1]	;RETURN SUCCESS TO JOBO6C.
	TLNE C,UBPFJ
	JRST UFNDF	;USER WANTS IT AS FOREIGN JOB
	HRRZ E,SUPPRO(TT)
	CAIN E,(U)
	JRST UFN1C	;OPENING UP INFERIOR
	SKIPGE APRC(TT)
	SKIPGE APRC(U)
	JRST UFNDF	;OPENING PROCEDURE DISOWNED OR OPENED PROCEDURE NOT DISOWNED => FOREIGN USER
		;PROCEDURE BEING OPEN DISOWNED, OPENING PROCEDURE NOT DISOWNED
	SKIPL SUPPRO(TT)	;IF DISOWNED PROCEDURE NOT AT TOP LEVEL,
	JRST UFNDF	;THEN FOREIGN JOB
	JRST UFN2	;ATTACH DISOWNED TREE

UFN1C:	MOVE U,TT	;OPENING PROCEDURE IMMEDIATE SUPERIOR OF PROCEDURE BEING OPENED
	JRST UFOUND

TCORS1:	PCLT		;COME HERE FROM TCORS IF ATTEMPT TO FIND FREE JOB SLOT FAILED.
	SKIPGE SJCFF	;IF THIS IS NEGATIVE, USTRA DIDN'T EVEN REQUEST MORE
	 JRST [ SKIPGE SJCFF
		PUSHJ P,UFLS
		JRST TCORS2]
	SKIPGE SUPCOR	.SEE SCLEX	;PRESUMABLY USTRA ASKED SYS JOB FOR MORE JOB SLOTS
	PUSHJ P,UFLS			;SO WAIT TILL SYS JOB ANSWERS THE REQUEST
	MOVE TT,USRHI
	CAIL TT,MAXJ*LUBLK
	JRST NOGO4			;USER MEM EXPANDED TO MAX
TCORS2:	CONO PI,CLKOFF			;AND SEE IF THERE ARE NOW ENOUGH SLOTS.
	JRST TCORS

;
; ATTACH A DISOWNED PROCEDURE TREE
;

UFN2:	LDB T,[.BP BULGOS_22,APRC(TT)]
	JUMPN T,OPNL42	;IF JOB IS LOGGING OUT, DON'T TOUCH IT.
	PUSHJ P,ULUP1	;FIND AN INTERRUPT BIT
	 JRST OPNL5	;ALL USED (TOO MANY INFERIORS)
	SETOM DLSRCH	;INHIBIT SCHEDULING
	CONO PI,CLKON	;TURN CLOCK BACK ON, THIS MAY TAKE A WHILE
	MOVSI A,BUMRTL	;DOOMED DETACHED JOBS ARE RESCUED BY REOWNING.
	ANDCAM A,APRC(TT)
	MOVE A,UNAME(U)	;PICK UP NEW UNAME
	MOVE D,UTMPTR(U)	;PICK UP NEW USER RESOURCE POINTER
	MOVE J,D
	SUBI J,USRRCE	;GET NEW CONSOLE #
	CAIL J,NCT	;IF NEW TREE STILL HAS NO TTY,
	 MOVEI J,%TINON	;"DISOWNED" TTY CHNLS SHOULD REMAIN SUCH
	PUSH P,[UFOUND]
UFN2A:	PUSH P,B	;SAVE INTERRUPT BIT
UFN3:	MOVEM A,UNAME(TT)	;SET TO NEW UNAME
	MOVEM D,UTMPTR(TT)	;SET TO NEW USER RESOURCE POINTER
	MOVEI R,IOCHNM(TT)
	PUSHJ P,CHSCAN
	PUSHJ P,UFN3ZZ
	MOVSI T,400000
	ANDCAM T,APRC(TT)	;MARK AS NOT DISOWNED
UFNL3:	MOVE B,JNAME(TT)	;PICK UP CURRENT JNAME
	MOVEI E,0	;LOOP ON ALL USERS
UFNL1:	SKIPN UNAME(E)	;SKIP IF VAR BLOCK IN USE
	JRST UFNL2
	CAMN A,UNAME(E)	;SKIP ON NOT SAME UNAME
	CAME B,JNAME(E)	;SKIP ON SAME UNAME-JNAME
	JRST UFNL2
	SKIPL APRC(E)	;SAME NAMES, IGNORE IF DISOWNED
	JRST UFN7	;TRUE NAME CONFLICT, RESOLVE
UFNL2:	ADDI E,LUBLK
	CAMGE E,USRHI
	JRST UFNL1
	MOVEI E,0	;INITIALIZE FOR LOOP TO LOOK FOR INFERIORS AND DUPLICATE NAMES
UFN4:	SKIPN UNAME(E)	;SKIP IF VAR BLOCK IN USE
	JRST UFN5	;TRY NEXT
	HRRZ I,SUPPRO(E)	;PICK UP SUPERIOR POINTER OF BLOCK BEING EXAMINED
	CAIN I,(TT)	;SKIP IF NOT INFERIOR
	JRST UFN6	;INFERIOR, PSEUDO-RECURSE
UFN5:	ADDI E,LUBLK	;ADVANCE TO NEXT BLOCK
	CAMGE E,USRHI	;SKIP IF ALL EXAMINED
	JRST UFN4	;LOOP
	SKIPGE SUPPRO(TT)	;SKIP IF NOT BACK TO TOP
	JRST UFNX	;BACK TO TOP LEVEL
	MOVE E,TT	;POP BACK UP
	HRRZ TT,SUPPRO(E)	;TO PREVIOUS LEVEL
	MOVE B,JNAME(TT)	;RESTORE B
	JRST UFN5	;PROCEED AT PREVIOUS LEVEL

UFNX:	POP P,B
	HRLM B,SUPPRO(TT)
	HRRM U,SUPPRO(TT)	;SET UP SUPERIOR POINTER IN TO LEVEL DISOWNED
	SETZM DLSRCH	;RE-ENABLE SCHEDULING
	MOVE U,TT
	POPJ P,

UFN6:	MOVE TT,E	;PSEUDO-RECURSE
	JRST UFN3	;START UP ON LOWER LEVEL

UFN7:	CAMN E,TT	;SKIP UNLESS FOUND SELF
	JRST UFNL2
	ADDI TT,JNAME	;SET UP ARG TO SIXAOS
	PUSHJ P,SIXAOS	;INCREMENT JNAME
	SUBI TT,JNAME	;RESTORE TT
	JRST UFNL3	;RESTART LOOP

	;RESUSCITATE TTY CHNLS
UFN3ZZ:	HRRZ Q,(R)
	CAIL Q,TYIDN
	CAILE Q,TYOBN
	POPJ P,		;NOT A TTY CH
	HLRZ Q,(R)
	TRNN Q,400000
	POPJ P,		;NOT CONSOLE
	AOS TTNTO(J)
	DPB J,[220700,,(R)]
	POPJ P,

SETBIT:	HRLZ B,B
	HRR B,U
	MOVEM B,SUPPRO(TT)
	MOVE U,TT
	PUSHJ P,UFOUND
	JFCL
	MOVE U,TT
	MOVEI B,1
	PUSHJ P,ACORE	;MAY PCLSR OUT
	JRST OPNL6
	JRST POPJ1

UFOUND:	HLRZS C	;U HAS INF PROC
	HRL A,U
	MOVE U,USER
	MOVE R,UUAC(U)
	ADDI R,IOCHNM(U)	;CLOBBERED BY CORE
	JSP Q,OPSLC3
	UWIDN,,UWODN
	UBIDN,,UBODN

UFNDF:	TLNE C,1
	JRST OPNL12	;ATTEMPTED OUTPUT
	LDB A,[.BP BULGOS_22,APRC(TT)]
	JUMPN A,OPNL42	;USER GOING AWAY
	HRL A,TT
	JSP Q,OPSLD1
	FUWIDN,,FUBIDN

ULOSE:	MOVE U,USER
	MOVEI T,%PIOOB
	JRST UUOERR

USRST:	PUSHJ P,AUCL2	;.RESET SIMULATES CLOSING AND REOPENING
	CONO PI,CLKON
	PUSHJ P,1USTOP
	EXCH U,A	;BUT WITH LESS OVERHEAD
	PUSH P,A
	PUSHJ P,IODCL
	MOVEI B,BULGOS	;WE'RE NOT REALLY TRYING TO KILL THE INFERIOR,
	ANDCAM B,APRC(U) ;SO DON'T LET OTHERS THINK HE'S BEING KILLED.
	MOVE Q,U
	SETZ B,
	EXCH U,(P)
	PUSHJ P,ACRF1	;FLUSH ALL OF CORE
	JRST 4,.
USRST1:	MOVEI B,1
	MOVE Q,(P)
	PUSHJ P,ACRF1	;THEN GET 1 PAGE
	 JRST [ PUSHJ P,UDELAY
		JRST USRST1]
	EXCH U,(P)
	MOVSI T,%TBNOT+%TBDTY
	MOVEM T,TTYTBL(U)
	MOVE J,U
	EXCH U,(P)
	HRLI J,240000
	PUSHJ P,MPLD1
	XCTR XW,[CLEARM 0]
	MOVEI T,1
	XCTR XBRW,[BLT T,1777]
	PUSHJ P,MPLDZ
	EXCH U,(P)
	PUSHJ P,LOGUSE
	CONO PI,CLKOFF
	PUSHJ P,USRST2
	CONO PI,CLKON
	PUSHJ P,USRST4	;SHOULD SKIP
	JRST 4,.
	MOVE T,UNAME(U)
	MOVEM T,USYSNM(U)
	POP P,A
	EXCH U,A
	MOVE TT,A
USRST5:	MOVE A,TTSTSV(U)	;INITIALIZE SAVED TTYSET OF NEW JOB EQUAL TO CREATOR'S.
	SKIPL B,TTYTBL(U)	;NOTE THAT THE WHEREABOUTS OF THE CREATOR'S TTYSET
	 MOVE A,TTYST1(B)	;DEPENDS ON WHETHER HE HAS THE TTY NOW.
	MOVEM A,TTSTSV(TT)
	MOVE A,TTSTSV+1(U)
	SKIPL B
	 MOVE A,TTYST2(B)
	MOVEM A,TTSTSV+1(TT)
	MOVEI A,(TT)		;RH OF NEW JOB'S SAVED TTYSTS IS HIS INDEX.
	HRLI A,%TSCNS		;NOW CONSTRUCT THE LH.
	MOVE B,UTMPTR(TT)	;TO DO THAT, FIND THE TREE'S TTY NUMBER
	MOVE B,TTYOPT-USRRCE(B)	;TO FIND THE TTY'S TTYOPT WORD,
	TLNE B,%TOROL		;WHICH TELLS HOW TO INIT THE BITS IN THE TTYSTS.
	 TLO A,%TSROL
	TLNN B,%TOMOR
	 TLO A,%TSMOR
	TLNE B,%TOSA1
	 TLO A,%TSSAI
	MOVEM A,TTSTSV+2(TT)
	POPJ P,

UBO1:	TLZ A,400000	;NEED MORE CORE
UMEMEX:	MOVSI TT,BSSTP
	CAME A,USER
	IORM TT,USTP(A)
	PUSHJ P,UPCLSR
	MOVE B,D
	ADDI B,2000-1
	LSH B,-10.
	MOVEM A,SRN5(U)	;ARG FOR NCORFS
	PUSHJ P,LOSSET
	    NCORFS
	EXCH U,A
	PUSHJ P,ACORE
	JRST ULOSE
	PUSHJ P,LSWPOP
	EXCH U,A
	JRST UUOTRO

UBO:	MOVNI I,1
	JRST UBIL
;COMMENTS BELOW APPLY TO UBI IN MANY CASES.  FOR UBO, TRANSFER GOES THE
;OTHER DIRECTION

UBI:	MOVEI I,0	;SIGNAL UBI

UBIL:	JUMPL C,UBIA
	XCTR XRW,[MOVES TT,(C)]	;MAKE SURE WRITE CYCLES WILL WIN
UBIB:	TRNE A,200000	;SKIP UNLESS 6
	MOVNI A,1	;SO CAILE BELOW WILL SKIP OVER SUSTPR AMONG OTHER REASONS
	CAILE A,LUBLK	;SKIP ON SYS JOB, CORE JOB, PDP6 OR JOB ALREADY STOPPED
	PUSHJ P,SUSTPR	;RANDOM JOB STOP
	JUMPGE TT,UBI4	;THRU
	TLO A,400000	;INDICATE ALREADY STOPPED SO WONT TRY IT AGAIN
	HLRO B,TT
	MOVNS D,B	;COUNT TO BE XFERRED
	HRLZ E,IOCHST-IOCHNM(R)	;EXAMINED USER ADDRESS
	HRR E,TT	;FROM,,TO (INFERIOR ADR,,SUPERIOR ADR)
	HLRZ Q,E
	ADD D,Q	;HIGHEST ADR +1
	CAMLE D,[1,,]
	JRST UBMCK1	;TRYING TO WRAP AROUND
	TLNE A,200000
	JRST UBI5A	;PDP6
	CAMLE D,HUSRAD(A)
	JUMPN I,UBO1	;DONT HAVE ENUF MEM ON WRITE
UBI5:	CAIGE Q,20	;INF ADR IN Q
	JRST UBI3	;READ AC
	HRRZ J,A	;SET UP UMAPS WORD
	TRZE E,400000
	TLOA J,200000	;TO HI PG, HACK OUR LOW PG
	TLO J,100000	;TO LOW PG, HACK OUR HI PG
	TLZE E,400000
	TLOA J,20000	;TO POINT TO HIS UPPER
	TLO J,40000	;TO POINT TO HIS LOWER
	TLNN J,140000	;UPPER TO UPPER XFER ?
	JRST UBI3A	;YES MAKE SURE NOT SCREWED BY AC PNTR
UBI3B:	PUSHJ P,MPLD1
	TRZ Q,400000
	MOVNS Q	;LIMIT SIZE OF XFER TO MIN OF DESIRED
	ADDI Q,400000	;DIST OF TO ADR FROM SEG BOUNDARY
	CAMLE B,Q
	HRRZ B,Q
	MOVNI Q,(E)	;AND DIST OF FROM ADR FROM SEQ BOUNDARY
	ADDI Q,400000
	CAMLE B,Q
	HRRZ B,Q
	TLNN J,200000	;BUGGER ADDRESSES SO RIGHT DBRS WILL BE USED
	TLOA E,400000	;SET FROM ADR TO HI PG
	TRO E,400000	;SET TO ADR TO HI PG
	SKIPE I		;SKIP ON UBI
	MOVSS E		;UBO, XFERR OTHER DIRECTION
	MOVE Q,E	;SAVE COPY OF BLT PNTR
	ADDI B,(E)	;GET LA +1
;	TLNE B,-1	;THIS LOSSAGE HAS BEEN FIXED (HOPEFULLY)
;	SOJA B,UBI3F	;AVOID -1 LOSSAGE
UBI3H:	XCTRI XBRW,[BLT E,-1(B)]	;XFERR DATA
UBI3K:	 MOVEI E,(B)	;NO FAULT, SIMULATE STORE BACK OF BLT PNTR AFTER COMP OF BLT (RH ANYWAY)
UBI3L:	PUSH P,J
	PUSHJ P,MPLDZ	;RETURN TO NORMAL MAP TO STORE BACK USER PNTR
	POP P,J	;SAVE PREV MAP FOR EVENTUAL USE
	SUBM E,Q	;FIGURE OUT HOW MANY WDS ACTUALLY XFERRED
	HRRZS Q
UBI3E:	ADDM Q,IOCHST-IOCHNM(R)	;UPDATE INFERIOR PNTR
	HRLS Q
	JUMPL C,UBIC	;UPDATE USER PNTR
	XCTRI XRW,[ADDM Q,(C)]
	 JRST .+2
	  JRST 4,.	;SHOULD HAVE ALREADY CHECKED THIS
UBID:	TLZ B,-1
	CAIN B,(E)	;WAS THERE A FAULT?
	JRST UBIL	;NO LOOP
	PUSHJ P,UBI4	;TAKE FAULT
	PUSHJ P,MPLD1	;RESTORE TO FROB AT TIME OF FAULT
UBI3C:	PUSHJ P,TPFLT
	PUSHJ P,MPLDZ
	JRST UBIL

;UBI3F:	CAIE B,(E)
;	JRST UBI3H	;XFERR ALL BUT LAST WORD
;	HLRZ TT,E
;	XCTRI XR,[MOVE T,(TT)]
;	JRST .+2
;	AOJA B,UBI3L
;	XCTRI XW,[MOVEM T,(E)]
;	AOJA B,UBI3K
;	AOJA B,UBI3L

UBI4:	TLNN A,200000	;SKIP ON REALLY PDP6
	TLZ A,400000	;FLUSH RANDOM BIT SO COMPARE WILL WORK
	CAILE A,LUBLK
	JRST UPCLSR
	POPJ P,

UBMCK1:	PUSHJ P,UBI4
	JRST IOADC

UBIA:	TRNE C,777760
	JRST 4,.
	MOVE TT,(C)
	JRST UBIB

UBIC:	TRNE C,777760
	JRST 4,.
	ADDM Q,(C)
	JRST UBID
UBI5A:	CAIL D,400000
	JRST UBMCK1
	JRST UBI5

UWO:	SKIPGE C
	 SKIPA D,(C)
	  XCTR XR,[MOVE D,(C)]
	TDZA I,I
UWI:	 SETO I,	;0 FOR OUTPUT, -1 FOR INPUT.
	TRNE A,200000
	 MOVNI A,1	;-1 MEANS PDP6.
	CAIG A,LUBLK
	 JRST UWI1	;SYS, CORE, OR PDP6
	PUSHJ P,SUSTPR
	PUSHJ P,SOSSET	;MIGHT TAKE PAGE FAULT AND GET PCLSRED
	  USTP(A)
UWI1:	HRRZ E,IOCHST-IOCHNM(R)
	HRRZ J,A
	HRLI J,254000	;SET UP MAP TO JOB NOT RUNNING.
	SKIPGE A
	 TLO J,400000	;PDP6
	PUSHJ P,MPLD1
	XCTR XRW,[	MOVE W,(E)
			MOVEM D,(E)]+1(I)
	AOS IOCHST-IOCHNM(R)	;ADVANCE ACCESS POINTER
	CAILE A,LUBLK
	 PUSHJ P,LSWPOP
	JRST MPLDZ
UBI3A:	TLNE E,777760	;SKIP ON XFERRING FROM AC AREA, HI TO HI
	JRST UBI3B	;NO OK
	JUMPN I,UBO3A	;UBO
	HRLI J,120000	;HACK OUR HI TO PNT TO HIS
	PUSHJ P,MPLD1
	XCTRI XR,[MOVE B,(Q)]	;PICK UP WD
	JRST .+2	;OK
	JRST UBI3C	;TAKE FAULT
	PUSHJ P,MPLDZ	;BACK TO NORMAL MAP
	HRRZ E,TT	;TO ADR
	JRST UBI3D

;USR DEV IOT STOP ROUTINE
USUSTP:	SOS USTP(A)
SUSTPR:	MOVSI T,BCSTOP+BUCSTP
	TDNE T,USTP(A)	;WAIT TILL NOT BEING SHUFFLED
	PUSHJ P,UFLS
	PUSHJ P,RPCLSR	;AOS'ES USTP
	MOVSI T,BCSTOP+BUCSTP
	TDNE T,USTP(A)
	JRST USUSTP
	POPJ P,

UBI3:	ADDI Q,AC0S(A)
	JUMPN I,UBO3	;UBO
	TLNE A,200000
	TDZA B,B	;READ PDP6 AC
	MOVE B,(Q)	;READ NORMAL AC
UBI3D:	XCTRI XW,[MOVEM B,(E)]
	 JRST .+2
	  JRST UBI3C	;TAKE FAULT
UBI3G:	MOVEI Q,1	;1 WD XFERRED
	HRRZ B,E	;FAKE OUT FAULT TEST
	JRST UBI3E

UBO3:	TLNE A,200000
	JRST UBI3G	;TRYING TO WRITE PDP6 AC IGNORE
	XCTRI XR,[MOVE B,(E)]
	 JRST .+2
	  JRST UBI3C
	MOVEM B,(Q)
	JRST UBI3G


UBO3A:	XCTRI XR,[MOVE B,(TT)]
	 JRST .+2
	  JRST UBI3C	;TAKE FAULT
	HRLI J,120000
	PUSHJ P,MPLD1	;SWITCH OUR HI PAGE TO PNT TO HIS HI PG
	XCTRI XW,[MOVEM B,(Q)]
	 JRST .+2
	  JRST UBI3C
	PUSHJ P,MPLDZ	;BACK TO NORMAL
	JRST UBI3G

SUBTTL CORE LINK DEVICE

EBLK
CLVBEG:	NCLCH
CLSYN:	BLOCK NCLCH	;SYSTEM NAME ;0=>VARIABLES FREE
CLN1:	BLOCK NCLCH	;FN1
CLN2:	BLOCK NCLCH	;FN2
CLUSR:	REPEAT NCLCH,-1	;LH=WRITING USER ;RH=READING USER ;-1=>NOT OPEN THAT HALF
CLRAC:	BLOCK NCLCH	;4.9=LOCKED BY CORE ALLOCATOR
		;4.8=VERY SLOW CLOCK ROUTINE CONSIDERING FLUSHING THIS BUFFER
		;RH=UT BUFFER NUMBER (IOBFT ADR)

CLOSW:	-1	;USER LOCK TO STOP MORE THAN ONE PERSON FROM SIMULTANEOUSLY MODIFYING
	0			;THE CORE LINK VARIABLES
CLVEND==.-1
BBLK

;FORMAT OF CORE LINK 200 WORD BUFFER
;
CLBVSP==8
CLBCHS==100.
CLBEOF==<CLBCHS+4>/5
IFG CLBVSP+CLBCHS+CLBEOF-128.,[PRINTX /CLBXXX LOSSAGE
/]
;
;0:   CHARACTER COUNT
;1&2: READ AND WRITE CHARACTER OR WORD POINTERS
;3&4: READ AND WRITE EOF POINTERS
;CLBVSP TO CLBVSP+CLBCHS-1: CHARACTERS OR WORDS
;CLBVSP+CLBCHS UP: EOF BITS STORED AS SEVEN FIVE BIT BYTES PER WORD,
;		EACH BIT CORRESPONDING TO A CHARACTER POSITION.

CLAO:	SKIPA J,[2]	;CLA .OPEN (TO ANSWER A CLI INTERRUPT)
CLIO:	MOVNI J,1	;CLI .OPEN (INTERRUPTS USER SPECIFIED BY FILE NAME)
	JRST CLI2

CLUO:	TDZA J,J	;CLU .OPEN
CLOO:	MOVEI J,1	;CLO .OPEN
CLI2:	JUMPL C,CLFDEL	;JUMP IF AN .FDELE
	PUSHJ P,FLDRCK
	JRST CLO1	;NOT FILE DIRECTORY
	MOVEI J,2
	JRST LISTF7


CLFDEL:	SKIPN SRN3(U)	;SKIP IF THIS IS A DELETE.
	 JRST POPJ1	;IGNORE RENAMES
	MOVEI J,3
;DROPS IN
CLO1:	PUSHJ P,SWTL	;SEIZE SWITCH TO STOP VARIABLES FROM CHANGING UNDER YOU
	 CLOSW
	LDB H,[220100,,C]	;DIRECTION BIT
	MOVE Q,USYSN1(U)	;PICK UP SNAME
	MOVSI I,-NCLCH
	CAIN J,2	;SKIP UNLESS CLA
	 JRST CLO1A	;JUMP IF CLA .OPEN
CLOL:	CAMN Q,CLSYN(I)	;LOOK FOR SNAME, FN1, & FN2
	 CAME A,CLN1(I)
	  JRST CLOO1
	CAME B,CLN2(I)
	 JRST CLOO1
	JUMPL J,OPNL13	;CLI LOSES IF FILE EXISTS
	CAIN J,3	;SKIP UNLESS DELETE
	 JRST CLO1D	;FOUND FILE TO DELETE
CLO1A6:	LDB TT,CLOOT1(H)
	CAIE TT,-1
	 JRST OPNL10	;ALREADY OPEN THIS DIRECTION
	HRRZ TT,CLRAC(I)
	LDB Q,[IOSA,,IOBFT(TT)]
	LSH Q,6
CLOX:	DPB U,CLOOT1(H)	;STORE USER INDEX
	MOVSI TT,200000
	ANDCAM TT,CLRAC(I)	;CLEAR VERY SLOW CLOCK BIT
	PUSHJ P,LSWPOP	;RELEASE SWITCH
	HRL A,I
	LDB C,[220300,,C]
	MOVEI TT,44	;WORD
	TRNN C,6
	 MOVEI TT,7	;UNIT ASCII
	ADD Q,H		;OFFSET FOR DIRECTION
	DPB TT,[300600,,1(Q)]	;SET UP ITEM POINTER
	MOVEI TT,5	;WORD
	TRNN C,6
	 MOVEI TT,1	;UNIT ASCII
	DPB TT,[300600,,3(Q)]	;SETUP EOF POINTER
	JSP Q,OPSLC7	;SET UP IOCHNM OF USER
	 DCLUAI,,DCLUAO	;UNIT ASCII INPUT ;UNIT ASCII OUTPUT
	 DCLBI,,DCLBO	;BLOCK INPUT ;BLOCK OUTPUT
	 DCLUBI,,DCLUBO	;UNIT BINARY INPUT ;UNIT BINARY OUTPUT
	 DCLBI,,DCLBO

CLOO1:	AOBJN I,CLOL	;LOOP FOR ALL SETS OF CORE LINK VARIABLES
	JUMPE J,OPNL4	;FILE NOT FOUND & CLU .OPEN
	CAIN J,3
	 JRST OPNL4	;FNF FOR DELETE
	MOVSI I,-NCLCH
CLOO3:	SKIPN CLSYN(I)	;LOOK FOR FREE VARIABLES TO CREATE FILE
	 JRST CLOO2
	AOBJN I,CLOO3
	JRST OPNL5	;GIVE DIREC FULL ERROR

CLOOT1:	2200,,CLUSR(I)	;READING
	222200,,CLUSR(I)	;WRITING

CLOO2:	JUMPL J,CLOO5	;JUMP IF CLI
CLOO2A:	MOVEM A,CLN1(I)	;SET UP VARIABLES
	MOVEM B,CLN2(I)
	MOVEI D,SCNCLO(I)	;SYS CHNL NO
	PUSHJ P,TCALL	;GET 200 WORD BUFFER
	JRST IUTCONS
	JRST CLOO4	;NO MEM AVAIL
	MOVEM Q,CLSYN(I)	;DONT SET UP SYS UNTIL MEM AVAIL
	HRRM A,CLRAC(I)
	LDB Q,[IOSA,,IOBFT(A)]	;SET UP BUFFER
	LSH Q,6
	SETZM (Q)	;CHAR COUNT
	MOVE TT,Q
	ADDI TT,CLBVSP	;SET UP BUF POINTERS
	MOVEM TT,1(Q)
	MOVEM TT,2(Q)
	HRLI TT,440000
	ADDI TT,CLBCHS	;SET UP EOF POINTERS
	MOVEM TT,3(Q)
	MOVEM TT,4(Q)
	JUMPGE J,CLOX
	MOVE U,USER	;GET HERE ON CLI
	MOVE T,2(Q)
	PUSH T,UNAME(U)	;STORE U&J NAMES OF INTERRUPTING PROCEDURE AS FIRST TWO WORD OF FILE
	PUSH T,JNAME(U)
	HRRM T,2(Q)
	MOVEI T,10.
	DPB T,[300600,,4(Q)]	;INTO SIZE FIELD OF EOF PNTR
	MOVEI T,0
	IDPB T,4(Q)	;CLEAR OUT APPROPRIATE EOF BITS
	MOVEI T,10.
	MOVEM T,(Q)	;SET "CHAR COUNT" TO REFLECT DATA ENTERED
	JRST CLOX

CLOO4:	SETZM CLSYN(I)	;RELEASE VARS
	JRST OPNL10	;DEVICE NOT AVAILABLE ERROR

CLOO5:	CONO PI,CLKOFF	;TURN OFF CLOCK TO STOP U&J NAMES FROM CHANGING
	MOVEI U,2*LUBLK
CLOO5A:	CAMN A,UNAME(U)	;LOOK FOR USER WHOSE NAMES MATCH THE SPECIFIED FILE NAMES
	CAME B,JNAME(U)
	JRST CLOO6
	MOVEI T,%PICLI	;IF GET TO HERE, HAVE FOUND USER WITH RIGHT NAMES
	TDNE T,MSKST(U)	;SKIP IF HE HAS CLI INT DISABLED
	TDNE T,PIRQC(U)	;SKIP IF HE IS NOT CURRENTLY PROCESSING A CLI INT
	JRST OPNL11
	IORM T,PIRQC(U)	;GIVE USER INT
	CONO PI,CLKON
	JRST CLOO2A

CLOO6:	ADDI U,LUBLK	;GO TO NEXT USER SLOT
	CAMGE U,USRHI	;SKIP IF ALL EXAMINED
	JRST CLOO5A
	JRST OPNL11

CLO1D:	MOVE T,CLUSR(I)
	AOS (P)	;DELETES FOR EXISTANT FILE ALWAYS SKIP
	AOJN T,LSWPOP
	MOVE A,I
	PUSHJ P,CLIOTB	;NO TIMING ERROR SINCE CORE JOB WILL PCLSR USR ON
		;CORE LINK BEFORE MOVING BUFFER
	JRST CLO1D2

CLO1A:	MOVE A,UNAME(U)
	MOVE B,JNAME(U)
CLO1A2:	SKIPN CLSYN(I)
	JRST CLO1A4
	CAMN A,CLN1(I)
	CAME B,CLN2(I)
CLO1A4:	AOBJN I,CLO1A2
	JUMPGE I,OPNL4
	JRST CLO1A6

;CORE LINK .IOT SET UP ROUTINE

CLIOTB:	SKIPGE CLRAC(A)	;WAIT IF BUFFER LOCKED BY CORE ALLOCATOR
	PUSHJ P,UFLS	;(DO NOT CHANGE ABOVE TO "SKIPGE TT,CLRAC(A)")
	HRRZ TT,CLRAC(A)
	LDB Q,[IOSA,,IOBFT(TT)]	;GET POINTER TO BUFFER
	LSH Q,6
	POPJ P,


;CORE LINK .IOT ROUTINE FOR UNIT ASCII INPUT

CLUAI:	PUSHJ P,CLIOTB	;SETUP
CLUAI1:	SKIPN (Q)	;WAIT TILL CHAR COUNT NON-ZERO
	PUSHJ P,UFLS
	MOVE J,3(Q)
	ILDB I,J	;GET EOF BIT
	ILDB W,1(Q)	;GET CHARACTER
	SOS (Q)	;DECREMENT BUF COUNT
CLFAXP:	LDB TT,[700,,1(Q)]	;FIX UP POINTERS ALSO ENTRY ON UNIT ASCII OUTPUT
	CAIN TT,CLBVSP+CLBCHS-1
	PUSHJ P,CLFAX2	;MAYBE TIME TO RING BUFFER
	LDB TT,[360600,,J]
	CAIN TT,1	;SIMULATE 5 BIT BYTES (USE 35. BIT / WORD)
	IBP J
	MOVEM J,3(Q)
	JUMPE I,CPOPJ
	LDB TT,[360600,,3(Q)]	;EOF
	SOJE TT,CLUAI2	;IGNORE EOFS EXCEPT ON WORD BOUNDARY
	CAIE TT,44-1
	JRST CLUAI1
CLUAI2:
UNIEOF:	HRROI W,EOFCH
	JRST POPJ1

CLFAX2:	LDB TT,[370500,,1(Q)]	;PICK UP TOP 5 BITS OF BYTE POSITION
	JUMPN TT,CPOPJ	;NOT QUITE YET
CLFBX2:	MOVEI TT,CLBVSP	;J HAS NEW EOF PNTR
	DPB TT,[700,,1(Q)]	;RING CHAR POINTER
	MOVEM J,3(Q)
	MOVEI J,44
	DPB J,[360600,,1(Q)]
	MOVEI TT,CLBVSP+CLBCHS
	DPB TT,[700,,3(Q)]	;RING EOF POINTER
	DPB J,[360600,,3(Q)]
	MOVE J,3(Q)
	POPJ P,

;CORE LINK .IOT ROUTINE FOR UNIT ASCII OUTPUT

CLUAO:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-11.
	CAMGE T,(Q)	;WAIT TILL THERE IS SPACE IN BUF
	PUSHJ P,UFLS
	MOVE J,4(Q)
	SKIPGE C
	 SKIPA B,(C)	;GET CHAR FROM EXEC
	  XCTR XR,[MOVE B,(C)]	;GET CHAR FROM USER
	MOVEI TT,0
	IDPB TT,J	;INDICATE NOT AN EOF
	IDPB B,2(Q)	;STORE IN BUF
	MOVEI TT,1	;GET MASK FOR LOW ORDER BIT
	ANDCAM TT,@2(Q)	;FLUSH IN CURRENT WORD
CLCWU2:	AOS (Q)	;INCREMENT BUF COUNT
	MOVEI I,0	;FAKE OUT EOF TEST
	AOJA Q,CLFAXP	;FAKE OUT CLFAXP AND FIX UP POINTERS


CLBI:	JSP W,WRDBTI	;BLOCK INPUT.

;CORE LINK .IOT ROUTINE FOR UNIT BINARY INPUT

CLUBI:	MOVEI E,0
CLBIN:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,5
	CAMLE T,(Q)	;WAIT TILL A WORD IS AVAILABLE
	PUSHJ P,UFLS
	MOVE J,3(Q)
	ILDB TT,J	;GET EOF BITS
	JUMPN TT,CLUBIE	;JUMP ON EOF
	ILDB W,1(Q)	;GET WORD
CLCRB2:	MOVNI T,5
	ADDM T,(Q)	;DECREMENT COUNT
CLFBXP:	LDB TT,[700,,1(Q)]	;FIX UP POINTERS
	CAIN TT,CLBVSP+CLBCHS-1
	JRST CLFBX2	;TIME TO RING BUFFER
	MOVEM J,3(Q)
	POPJ P,

CLUBIE:	TROE TT,20	;SKIP IF EOF NOT ON FIRST CHAR OF WORD
	JRST CLUBIF
	DPB TT,J	;SET EOF ON FIRST CHAR
	MOVE J,1(Q)
	ILDB W,J	;PICK UP WORD WITH EOF IN MIDDLE
	POPJ P,

CLUBIF:	IBP 1(Q)	;REACHED EOF IN IMAGE INPUT.
	PUSHJ P,CLCRB2	;SPACE PAST EOF WD
	PUSH P,C
	PUSH P,H
	PUSHJ P,CCLOSE
	POP P,H
	JRST POPCJ1

;CORE LINK .IOT ROUTINE FOR UNIT BINARY OUTPUT

CLUBO:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-11.
	CAMGE T,(Q)	;WAIT TILL THERE IS SPACE FOR A WORD
	PUSHJ P,UFLS
	MOVE J,4(Q)
	SKIPGE C
	 SKIPA B,(C)	;GET WORD FROM EXEC
	  XCTR XR,[MOVE B,(C)]	;GET WORD FROM USER
	MOVEI TT,0
	IDPB TT,J	;INDICATE NOT AN EOF
	IDPB B,2(Q)	;STORE IN BUF
CLCWB2:	MOVEI TT,5
	ADDM TT,(Q)	;INCREMENT COUNT
	AOJA Q,CLFBXP	;FAKE OUT CLFBXP AND FIX UP POINTERS


;CORE LINK .IOT ROUTINE FOR BLOCK OUTPUT

CLBO:	MOVE I,C	;SAVE A POINTER TO USERS BLKO POINTER
	XCTR XR,[SKIPL H,(I)]	;PICKUP BLKO POINTER
	 POPJ P,
	SKIPA E,H	;SECOND COPY, ALSO FLAG TO CLBIN
CLBI2:	 XCTR XW,[MOVEM E,(I)]	;TO INFORM USER & IN CASE YOU ARE PCLSR'ED
	HRRZ C,E
	PUSHJ P,CLUBO	;TRANSFER ONE WORD
	AOBJN E,CLBI2	;TRY FOR NEXT
CLBI3:	XCTR XW,[MOVEM E,(I)]	;COUNT EXHAUSTED OR EOF
	POPJ P,

;CORE LINK .CLOSE ROUTINE FOR BINARY OR BLOCK OUTPUT

CLCLWB:	PUSHJ P,CLCWC	;STORE EOF BITS FOR WORD
	JRST CLCW1	;NO ROOM SO LAST MUST HAVE BEEN EOF HACK SO FLUSH
	PUSHJ P,SWTL	;WAIT FOR SWITCH TO MODIFY VARIABLES
	CLOSW
	IBP 2(Q)	;KEEP WORD POINTER IN STEP
	PUSHJ P,CLCWB2	;FIX UP COUNT AND POINTERS
CLCWU6:	MOVNI B,1
	DPB B,[222200,,CLUSR(A)]	;OBLITERATE USER INDEX
	JRST LSWPOP	;RELEASE SWITCH


CLCW1:	PUSHJ P,SWTL
	CLOSW
	JRST CLCWU6

;CORE LINK .CLOSE ROUTINE FOR UNIT ASCII OUTPUT

CLCLWU:	PUSHJ P,CLCWC	;STORE EOF BIT FOR CHAR
	JRST CLCW1
	LDB TT,[360600,,2(Q)]
	CAIN TT,8
	JRST CLCWU4	;JUMP ON END OF WORD NEXT
	MOVEI TT,EOFCH
	IDPB TT,2(Q)	;STORE AN EOF CHAR
	PUSHJ P,CLCWU2	;FIX UP COUNT AND POINTERS
	JRST CLCLWU

CLCWU4:	PUSHJ P,SWTL	;SEIZE SWITCH TO MODIFY VARIABLES
	CLOSW
	MOVEI TT,EOFCH	;(CODE MUST BE DUPLICATED DUE TO TIMING ERR IF PCLSR'ED OUT OF SWAIT)
	IDPB TT,2(Q)	;STORE AN EOF CHAR
	PUSHJ P,CLCWU2	;FIX UP COUNT AND POINTERS
	JRST CLCWU6


;COMMON SUBROUTINE FOR CORE LINK OUTPUT .CLOSE ROUTINES

CLCWC:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-5.
	CAMGE T,(Q)	;WAIT FOR THERE TO BE ROOM
	POPJ P,
	MOVE J,4(Q)
	MOVNI TT,1
	IDPB TT,J	;SET EOF BIT(S)
	JRST POPJ1

;CORE LINK .CLOSE ROUTINE FOR INPUT

CLCLRB:
CLCLRU:	PUSHJ P,CLIOTB
	PUSHJ P,SWTL	;SEIZE SWITCH TO MODIFY VARIABLES
	CLOSW
			;(CODE MUST BE DUPLICATED DUE TO TIMING ERROR IF PCLSR'ED OUT OF SWAIT)
	HLLOS B,CLUSR(A)	;OBLITERATE USER INDEX, GET ENTIRE WORD IN B
	AOJN B,LSWPOP	;JUMP IF CORE LINK OPEN FOR WRITING
CLCLR2:	SKIPE (Q)
	JRST CLCLR1	;JUMP IF CORE LINK NOT EMPTY
CLO1D2:	SETZM CLSYN(A)	;FREE VARIABLES
	HRRZ A,CLRAC(A)	;CORE LINK NO LONGER IN USE
	PUSHJ P,BRTN	;RETURN BUFFER TO FREE STATE
	JRST LSWPOP

CLCLR1:	MOVE J,3(Q)	;CLOSING NONEMPTY CORE LINK, CHECK FOR SCREW CASE THAT
	ILDB TT,J	;IT CONTAINS ONLY A WORD OF EOF
	TRNN TT,20	;EOF ON 1ST CHAR NEXT WORD?
	JRST LSWPOP
	IBP 1(Q)
	PUSHJ P,CLCRB2	;FLUSH THE EOF WORD
	JRST CLCLR2

CLISTA:	PUSHJ P,CLIOTB	;CORE LINK INPUT STATUS
	SKIPN J,(Q)	;COUNT
	TRO D,1_10.	;SYS BUF CAP EMPTY
	CAIL J,CLBCHS*5-5
	TRO D,1_9	;SYS BUF CAP EMPTY
	POPJ P,

SUBTTL COMMON I/O ROUTINES

;STANDARD DEVICE OPEN

STDOP1:	MOVEI R,R	;ENTRY TO NOT CLOBBER IOCHNM
STDOPN:	HLRZ A,(Q)	;LH MASK ON 4.9-3.2 OF LH OPEN WRD
	AND D,A	;RH POINTER TO ..USR,..USE PAIR
	ROT D,-1	;FOLLOWING WORDS CONTAIN LIST FOR ALL MASKED STATES
	ADDI D,(Q)	;LH MSKED STATE =0, RH =1, IOTTB ENTRY NUMBERS
	HRRZ A,1(D)
	SKIPL D
	HLRZ A,1(D)
	JUMPE A,OPNL12	;MODE NOT AVAIL
	HRRZ E,(Q)
	CONO PI,CLKOFF
	CAME U,(E)
	SKIPGE 1(E)
	AOSA 1(E)
	JRST OPNL10	;DEVICE NOT AVAIL
	MOVEM U,(E)
	HLL A,C
	JRST OPNSLT

OPSLD1:	ANDI D,1	;ENTRY TO USE BOTTOM BIT OF AC D
OPSLD3:	ANDI D,3	;ENTRY TO USE BOTTOM TWO BIT OF AC D
	MOVE C,D
OPSLC3:	ANDI C,3	;ENTRY TO USE BOTTOM TWO BITS OF AC C
OPSLC7:	ANDI C,7	;ENTRY TO USE BOTTOM THREE BITS OF AC C
	ROT C,-1
	ADDI C,(Q)
	HRR A,(C)
	SKIPL C
	HLR A,(C)
OPNSLT:	MOVEM A,(R)	;SET USERS IOCHNM
	JRST CLKOJ1

;BLOCK OUTPUT TO CHARACTER DEVICE 
;ADR OF CHR ROUTINE IN E
; THAT ROUTINE MUST NOT CLOBBER C, D, E, OR TT
;C POINTS TO AOBJN POINTER IN USER SPACE
;MUSTN'T CLOBBER J (TTY OUTPUT ASSUMES).

NBTOCH:	XCTR XRW,[MOVES D,(C)]	;CHECK WRITEABILITY OF AOBJN PTR
	LDB TT,[410300,,D]	;USE HIGH 3 BITS OF USER PNTR AS CHR CNT
	CAIGE TT,3
	 POPJ P,		;USER TRYING TO XFER >32K FLUSH
	SKIPA TT,BTOCHT-3(TT)	;PICK UP APPROPRIATE BYTE PTR (WORD IN W)
NBTO1:	 XCTR XW,[MOVEM D,(C)]	;UPDATE USER'S AOBJN PTR
	XCTR XR,[MOVE W,(D)]	;FETCH CURRENT WORD FROM USER
	ILDB A,TT		;FETCH CURRENT CHARACTER
	PUSHJ P,(E)		;SEND TO DEVICE
	ADD D,[700000,,]	;UPDATE PTR
	TLNE D,500000
	 JRST NBTO1		;GO TO NEXT CHR
	MOVE TT,BTOCHT+4
	ADD D,[500001,,1]	;INCR TO NEXT WORD
	JUMPL D,NBTO1
	XCTR XW,[MOVEM D,(C)]	;COUNTED OUT, UPDATE FINAL TIME & RETURN
	POPJ P,

BTOCHT:	REPEAT 5,<44-<4-.RPCNT>*7>_14+700,,W

;BLOCK INPUT FROM CHARACTER DEVICE
;E AND C SET UP LIKE NBTOCH
;INTERNALLY LH OF E USED FOR FLAGS:
; 4.9 EOF FLAG (SIGN)
; 4.8 => JUST RETURN WITHOUT ERROR IF AT BEGINNING OF WORD,
;	 OTHERWISE IGNORE BIT.
; 4.7 => RETURN WITHOUT ERROR EVEN IF NOT AT BEGINNING OF WORD.

INBTCH:	HRRZS E		;CLEAR GARBAGE IN LH
	XCTR XRW,[MOVES D,(C)] ;SET UP LIKE NBTOCH
	LDB TT,[410300,,D]
	CAIGE TT,3
	 POPJ P,
	SKIPA TT,BTOCHT-3(TT)
INBTO1:	 XCTR XW,[MOVEM D,(C)]
	XCTR XRW,[MOVES (D)] ;CHECK WRITABILITY OF CURRENT WORD
	JUMPL E,INBTO2	;JUMP IF EOF
	PUSH P,C
	PUSH P,D
	PUSH P,TT
	PUSH P,R
	HLRZ A,(R)
	PUSHJ P,(E)	;RETN CHR IN W
	 JRST .+3
	  TLO E,200000
	TLO E,400000
	MOVE I,W
	POP P,R
	POP P,TT
	POP P,D
	POP P,C
	LDB W,[410300,,D]
	TLNN E,100000
	 CAIN W,7	;SKIP IF NOT AT 1ST CHAR.
	  TLNN E,300000
	   JRST INBTO3
	POPJ P,

INBTO3:	XCTR XR,[MOVE W,(D)]	;PICK UP CURRENT WORD
	IDPB I,TT		;INSERT CHARACTER
	XCTR XW,[MOVEM W,(D)]	;PUT WORD BACK
	ADD D,[700000,,]
	TLNE D,500000
	 JRST INBTO1		;DO ANOTHER CHR THIS WORD
	MOVE TT,BTOCHT+4
	ADD D,[500001,,1]	;INCR TO NEXT WD
	SKIPL E			;SKIP IF EOF
	 JUMPL D,INBTO1
	XCTR XW,[MOVEM D,(C)]	;DONE, UPDATE POINTER AND RETURN
	POPJ P,

INBTO2:	MOVEI I,EOFCH		;EOF, STORE EOF CHARACTER
	JRST INBTO3

;BLOCK IO TO WORD DEVICE
;C POINTS TO AOBJN POINTER IN USER SPACE
;Q POINTS TO WORD HANDLING ROUTINE (POINTER WILL BE IN C)
;MUST NOT CLOBBER Q OR H (PTR ROUTINES DO POPJ2 SOMETIMES)
;WRDBRT CHECKED FOR ON PDL BY TVC ROUTINES

WRDBT:	MOVE H,C
	XCTR XR,[MOVE C,(H)]	;FETCH USER'S AOBJN POINTER
	JUMPGE C,CPOPJ
	JRST WRDBT3

WRDBT2:	PUSHJ P,OPBRK
WRDBT3:	ANDI C,-1
	PUSHJ P,(Q)
WRDBRT:	 JRST WRDBT5		;NO SKIP - WORD XFERRED
	 SKIPA C,[1,,1]		;1 SKIP - LAST WORD XFERRED
	  POPJ P,		;2 SKIPS - EOF, NO WORD XFERRED
	XCTR XRW,[ADDM C,(H)]
	POPJ P,

WRDBT5:	MOVE C,[1,,1]
	XCTR XRW,[ADDB C,(H)]
	JUMPL C,WRDBT2
	POPJ P,

;JSP W,WRDBTI TO DO WRDBT FOR A UNIT MODE INPUT ROUTINE SATISFYING NEW
;CALLING CONVENTION FOR THOSE.
;SEE COMMENTS AT WRDBRT ABOVE FOR SKIP CONVENTIONS OF ROUTINE AT (W).
WRDBTI:	JSP Q,WRDBT
	XCTR XRW,[MOVES (C)]
	PUSH P,W
	PUSHJ P,(W)
	 JRST WRDBT4
	 AOS -1(P)
	AOS -1(P)
WRDBT4:	XCTR XW,[MOVEM W,(C)]
	MOVEI Q,WRDBTI+1
	POP P,W
	POPJ P,

;CHANGED CONVENTIONS: 
 ;1) EOF IS NO LONGER CHECKED FOR CHARACTER BY CHARACTER.
 ;   INSTEAD, THE GET-BUFFER ROUTINE SHOULD SET UP THE BYTE COUNT
 ;   TO A SMALLER VALUE THAN USUAL.
 ;   AN ATTEMPT TO GET ANOTHER BUFFER AFTER REACHING EOF
 ;   SHOULD CAUSE THE GET-BUFFER ROUTINE TO SKIP TWICE.
 ;2) THE THE BUFFER POINTER IS NOW A B.P. EVEN IN IMAGE MODE.
 ;   ALSO, THE L.H. OF THE B.P. IS NOT INITTED HERE.
 ;   IT MUST BE SET UP BY THE OPEN ROUTINE. ALSO, ACCESS ROUTINES
 ;   FOR DSK MUST KNOW HOW TO SET IT UP.
 ;   ALSO, THE BUFFER GET ROUTINE SHOULD SET IT UP,
 ;   INSTEAD OF RETURNING THE BUFFER ADDRESS IN TT.
 ;3) THE BYTE SIZE THE FILE IS OPEN ON IS PASSED AS AN ARGUMENT.
 ;   THIS ROUTINE WORKS FOR ANY CHANNEL BYTE SIZE WITH ANY
 ;   SIOT BYTE SIZE.

;GENERAL BLOCK I/O
;E HAS # BYTES/WORD OF FILE BYTE SIZE
;RH(C) = ADDR OF COUNT, IN USER MEMORY
;RH(TT) = ADDR OF USER'S B.P.
; ARGUMENTS B ->
;0(B)	ADDR OF ACTIVE BUFFER BYTE PTR, 4.9=0 => INPUT, =1 => OUTPUT
;1(B)	ADDR OF COUNT OF BYTES REMAINING IN CURRENT BUFFER
;2(B)	ROUTINE TO GET NEXT BUFFER.  NO SKIP IF NO MEMORY
;	 OTHERWISE SKIP; BUFFER BYTE COUNT IN @1(B)
;	 AND BUFFER BYTE POINTER ALREADY SET UP.
;	  2 SKIPS => THERE IS NO BUFFER, DUE TO EOF.
;	WHEN THIS ROUTINE IS CALLED, E CONTAINS THE
;	NUMBER OF BYTES/WORD (GOOD FOR DETERMINING CHANNEL MODE).
;3(B)	ROUTINE TO PUT BUFFER (OUTPUT) OR DISCARD (INPUT)
;	MAY REACTIVATE CURRENT BUFFER BY SETTING @1(B) TO NONZERO,
;	IN WHICH CASE IT SHOULD CONTAIN THE NUMBER OF WORDS, NOT BYTES.
;	SIOKT WILL CONVERT IT TO THE NUMBER OF BYTES.
;4(B)	NOT USED
;5(B)	IF POSITIVE, INSTRUCTION TO WAIT FOR I/O
;	IF NEGATIVE, ROUTINE ASSUMES 2(B) AND 3(B) WILL WAIT

;RELOADING ROUTINES MUST NOT CLOBBER B,E,A,C,I
;SIOKT CLOBBERS C,D,J,TT, AND WHATEVER THE RELOADING ROUTINES CLOBBER.

SIOKT:	PUSH P,E
	PUSH P,TT
	PUSH P,C
	JRST SIOKT1

;NEXT BUFFER

SIOKNB:	PUSHJ P,@3(B)	;"DISCARD" BUFFER
	SKIPE J,@1(B)	;CHECK AMOUNT REMAINING ONE MORE TIME
	 JRST SIOKN2	;IT SPRUNG BACK TO LIFE (WRITE OVER MODE LAST BLOCK OF FILE)
	SKIPG 5(B)	;NEED TO WAIT FOR DEVICE?
	 JRST SIOKF1	;NO.
SIOKN1:	SKIPG 5(B)	;COME HERE IF MUST WAIT FOR SOME REASON OR OTHER
	 JRST SIOKW1	;DEVICE CAN'T WAIT SO UDELAY
	XCT 5(B)	;DEVICE WAIT
SIOKF:	PUSHJ P,UFLS

SIOKF1:	PUSHJ P,@2(B)	;NOW GET NEXT BUFFER
	 JRST SIOKN1	;HMM, HAVE TO WAIT
	  JRST SIOKT1	;BUFFER HAS BEEN GOT.
	JRST POP3J1	;EOF, TRANSFER IS COMPLETE

SIOKT1:	XCTR XR,[MOVE TT,@(P)]	;GET COUNT OF BYTES TO TRANSFER
	JUMPLE TT,POP3J1	;COUNT DECREMENTED TO 0; TRANSFER DONE.
	SKIPG D,@1(B)	;CHECK AMOUNT LEFT IN BUFFER
	 JRST SIOKNB	;NEW BUFFER NEEDED
	CAMLE TT,D	;AMT OF ROOM LEFT IN CURRENT BUFFER
	 MOVE TT,D	;TRANSFER ONLY AMT LEFT IN BUFFER
	XCTR XR,[MOVE J,@-1(P)]
	IBP J
	LDB D,[301400,,J]
	MOVE C,@(B)
	IBP C		;TO TRANSFER WORD-WISE, BOTH B.P.'S MUST
	HRL J,C
	LDB C,[301400,,C]
	CAIE C,(D)	;HAVE SAME BYTE SIZE,
	 JRST SIOKS1
	LDB D,[060600,,C]
	ANDI C,77
	ADDI C,(D)
	CAMGE TT,-2(P)	;THERE MUST BE AT LEAST 1 WORD TO TRANSFER,
	 JRST SIOKS1
	CAIE C,44	;AND MUST BE ABOUT TO START THE NEXT WORD.
	 JRST SIOKSL
	PUSH P,TT+1
	IDIV TT,-3(P)
	POP P,TT+1
	SKIPGE (B)
	 MOVSS J	;WRITING, SWAP BLT POINTER
	MOVE D,J
	ADDI TT,(D)	;1+LAST WORD TO BLT INTO
	SKIPGE (B)
	 JRST SIOKN6	;JUMP IF WRITING
	XCTRI XBW,[BLT D,-1(TT)] ;READING
SIOKN7:	 MOVEI D,(TT)	;NO FAULT, UPDATE PTR TO LAST WORD + 1 (LIKE KL10)
SIOKN8:	SUBM D,J
	HRRZS J		;# WDS ACTUALLY XFERRED
	ADDM J,@(B)	;INCR BUFFER PNTR
	XCTR XRW,[ADDM J,@-1(P)]
	IMUL J,-2(P)
	MOVNI J,(J)
	XCTR XRW,[ADDM J,@(P)]
	ADDM J,@1(B)	;DECREMENT COUNT LEFT IN BUFFER
	CAIE D,(TT)	;SKIP IF TRANSFERRED ALL WE COULD
	 PUSHJ P,TPFLT	;TAKE FAULT IF ANY
SIOKN3:	SKIPE @1(B)
	 JRST SIOKT1
	PUSHJ P,@3(B)	;BUFFER EXHAUSTED, "DISCARD"
	SKIPN J,@1(B)	;CAME BACK TO LIFE?
	 JRST SIOKT1	;NO, SIOKT1 WILL DECIDE TO GET ANOTHER BUFFER.
SIOKN2:	IMULI J,-2(P)	;YES, CONVERT WORD COUNT TO BYTE COUNT.
	MOVEM J,@1(B)
	JRST SIOKT1


SIOKW1:	PUSHJ P,UDELAY
	JRST SIOKF1

SIOKN6:	XCTRI XBR,[BLT D,-1(TT)] ;WRITING TRANSFER
	 JRST SIOKN7
	JRST SIOKN8

;COME HERE FOR SLOW (BYTE AT A TIME) SIOT TO BLOCK MODE DEVICE.
;TT HAS NUMBER OF BYTES TO TRANSFER - IT IS KNOWN THAT THE DEVICE
;CAN SUPPLY THAT MANY FROM ITS CURRENT BUFFER.
SIOKSL:	SUBM C,D	;D GETS SIZE; C HAS # BITS REMAINING TO BE HANDLED
	IDIV C,D	;C GETS # BYTES TO XFER TILL REACH WORD BOUNDARY.
	MOVE TT,C	;XFER THAT MANY, THEN TRY AGAIN, SO WILL USE FAST MODE.
SIOKS1:	SKIPL (B)
	 JRST SIOKSI	;INPUT AND OUTPUT PART HERE
SIOKSO:	XCTR XR,[MOVE C,@-1(P)]	;GET COPY OF USER'S B.P. FOR SWAPPING IN PAGES.
SIOKS3:	IBP C		;IF NOT FOR THESE 2 INSNS, ILDB MIGHT GET PAGE FAULT
	XCTR XR,[MOVE (C)]	;WHICH WOULD CAUSE EXTRA INCREMENTING OF B.P.
	XCTR XBYTE,[ILDB D,@-1(P)] ;FETCH NEXT BYTE,
	IDPB D,@(B)
	SOS @1(B)
	XCTR XRW,[SOS @(P)]
	SOJG TT,SIOKSO
	JRST SIOKN3

SIOKSI:	XCTR XR,[MOVE C,@-1(P)]	;GET COPY OF USER'S B.P., FOR WRITEABILITY TESTING.
SIOKS2:	IBP C
	XCTR XRW,[MOVES (C)]	;MAKE SURE WE CAN WRITE IN NEXT BYTE.
	ILDB D,@(B)		;GET NEXT BYTE FROM DEVICE BUFFER
	XCTR XBYTE,[IDPB D,@-1(P)];GIVE IT TO USER.
	XCTR XRW,[SOS @(P)]	;UPDATE USER'S COUNT
	SOS @1(B)		;AND THE SYSTEM'S COUNT.
	SOJG TT,SIOKS2
	JRST SIOKN3

;CONVENIENT EXIT ROUTINE FOR BUFFER-GET ROUTINES.
;ASSUMES ADDR OF START OF BUFFER IN TT,
;SIZE (IN WORDS) OF DATA AREA IN J.
;BYTES/WD SHOULD BE IN E, WHERE IT WAS WHEN
;THE BUFFER-GET ROUTINE WAS CALLED.
SIOBGX:	HRLI TT,440700
	CAIN E,1
	 HRLI TT,444400
	MOVEM TT,@(B)
	IMUL J,E
	MOVEM J,@1(B)
	JRST POPJ1

;BYTE AT A TIME I/O TO BLOCK MODE DEVICE
;SEE PRECEDING PAGE (SIOKT) FOR COMMENTS ON CALLING SEQUENCE
;EXCEPT: ON INPUT, VALUE RETURNED IN W, AND C,D HAVE NO SIGNIFICANCE;
;ON OUTPUT, RH(C) HAS ADDRESS OF ARG, SIGN(C) SET IFF ADDRESS IS EXEC-MODE,
; AND D HAS NO SIGNIFICANCE.

CHRKT:	SKIPGE (B)
	 JRST CHRKTO	;WRITING
	JRST CHRKTI	;READING

CHRKTI:	SOSGE @1(B)	;DECREMENT ACTIVE CHAR COUNT
	 JRST CHRKT1	;GET NEW BUFFER
	ILDB W,@(B)	;READ - GET NEXT CHAR
	POPJ P,

CHRKTO:	SKIPGE C	;USED WHEN FILLING OUT BLOCK AT CLOSE, AND ELSEWHERE.
	 SKIPA I,(C)
	  XCTR XR,[MOVE I,(C)]	;GET CHAR. FROM USER
	SOSGE @1(B)	;DECREMENT ACTIVE CHAR COUNT
	 JRST CHRKT1	;GET NEW BUFFER
	IDPB I,@(B)	;DEPOSIT IN BUFFER
	POPJ P,

CHRKT1:	PUSHJ P,@3(B)	;GET RID OF THIS BUFFER
	SKIPLE J,@1(B)	;CHECK AMOUNT REMAINING ONE MORE TIME
	 JRST CHRKT6	;SPRUNG BACK TO LIFE (LAST BLOCK OF FILE WRITE OVER)
	SKIPG 5(B)	;NEED TO WAIT FOR DEVICE?
	 JRST CHRKF1	;NO.
CHRKN1:	SKIPG 5(B)	;HAVE TO WAIT
	 JRST [	PUSHJ P,UDELAY
		JRST CHRKF1 ]
	XCT 5(B)	;DEVICE WAIT
	 PUSHJ P,UFLS

CHRKF1:	PUSHJ P,@2(B)	;GOBBLE NEW BLOCK
	 JRST CHRKN1	;NOT READY, WAIT
	  JRST CHRKT
	SOJN E,UNIEOF	;READING PAST EOF IN ASCII MODE.
	JRST IOCER8	;READING PAST EOF IN IMAGE MODE.

CHRKT6:	IMUL J,E	;CONVERT TO CHARACTERS
	MOVEM J,@1(B)	;SET ACTIVE CHAR COUNT
	JRST CHRKT

;GENERAL BLOCK I/O
;E HAS # BYTES/WORD OF FILE BYTE SIZE - MUST BE 1.
;RH(C) = ADDR OF AOBJN POINTER
; AND 4.9 => AOBJN PTR IS IN EXEC ADDRESS SPACE,
;     4.8 => BLOCK IT POINTS TO IS IN EXEC ADDRESS SPACE.
; ARGUMENTS B ->
;0(B)	ADDR OF ACTIVE BUFFER BYTE PTR, 4.9=0 => INPUT, =1 => OUTPUT
;1(B)	ADDR OF COUNT OF BYTES REMAINING IN CURRENT BUFFER
;2(B)	ROUTINE TO GET NEXT BUFFER.  NO SKIP IF NO MEMORY
;	 OTHERWISE SKIP; BUFFER BYTE COUNT IN @1(B)
;	 AND BUFFER B.P. IN @(B) ALREADY SET UP.
;	  2 SKIPS => THERE IS NO BUFFER, DUE TO EOF.
;3(B)	ROUTINE TO PUT BUFFER (OUTPUT) OR DISCARD (INPUT)
;	MAY REACTIVATE CURRENT BUFFER BY SETTING @1(B) TO NONZERO,
;	IN WHICH CASE IT SHOULD CONTAIN THE NUMBER OF WORDS, NOT BYTES.
;	SIOKT WILL CONVERT IT TO THE NUMBER OF BYTES.
;4(B)	NOT USED
;5(B)	IF POSITIVE, INSTRUCTION TO WAIT FOR I/O
;	IF NEGATIVE, ROUTINE ASSUMES 2(B) AND 3(B) WILL WAIT

;RELOADING ROUTINES MUST NOT CLOBBER B,E,A,C,I
;BLKT CLOBBERS C,D,J,TT, AND WHATEVER THE RELOADING ROUTINES CLOBBER.

BLKT:	CAIE E,1
	 JRST 4,.	;BLKT CALLED ON UNIT ASCII MODE CHANNEL??
	SKIPL C		;SKIP IF POINTER IN USER SPACE
	 XCTR XRW,[MOVES (C)] ;USER SPACE, MAKE SURE WRITE CYCLE WILL WIN
	JRST BLKT1

;NEXT BUFFER

BLKTNB:	PUSHJ P,@3(B)	;"DISCARD" BUFFER
	SKIPE @1(B)	;CHECK AMOUNT REMAINING ONE MORE TIME
	 JRST BLKT1	;IT SPRUNG BACK TO LIFE (WRITE OVER MODE LAST BLOCK OF FILE)
	SKIPG 5(B)	;NEED TO WAIT FOR DEVICE?
	 JRST BLKTF1	;NO.
BLKTN1:	SKIPG 5(B)	;COME HERE IF MUST WAIT FOR SOME REASON OR OTHER
	 JRST BLKTW1	;DEVICE CAN'T WAIT SO UDELAY
	XCT 5(B)	;DEVICE WAIT
BLKTF:	PUSHJ P,UFLS

BLKTF1:	PUSHJ P,@2(B)	;NOW GET NEXT BUFFER
	 JRST BLKTN1	;HMM, HAVE TO WAIT
	  JRST BLKT1
	POPJ P,		;EOF, TRANSFER FINISHED

BLKT1:	SKIPGE C	;SET UP FOR TRANSFER
	 SKIPA J,(C)	;GET EXEC MODE BLOCK .IOT (AOBJN) POINTER
	  XCTR XR,[MOVE J,(C)]	;GET USER MODE AOBJN POINTER
	JUMPGE J,CPOPJ	;POINTER COUNTED OUT, TRANSFER DONE
	SKIPG D,@1(B)	;CHECK AMOUNT LEFT IN BUFFER
	 JRST BLKTNB	;NEW BUFFER NEEDED
	HLRE TT,J
	MOVNS TT	;DESIRED SIZE OF BLOCK
	CAMLE TT,D	;AMT OF ROOM LEFT IN CURRENT BUFFER
	 MOVE TT,D	;TRANSFER ONLY AMT LEFT IN BUFFER
	MOVE D,@(B)	;CANONICALIZE THE BUFFER B.P. SO RH => NEXT WORD TO XFER
	IBP D
	HRL J,D		;MERGE WITH USER'S BLOCK ADDR TO GET BLT AC.
	SKIPGE (B)
	 MOVSS J	;WRITING, SWAP BLT POINTER
	MOVE D,J
	ADDI TT,(D)	;1+LAST WORD TO BLT INTO
	TLNE C,200000
	 JRST BLKTN9	;JUMP IF EXEC AOBJN POINTER
	SKIPGE (B)
	 JRST BLKTN6	;JUMP IF WRITING
	XCTRI XBW,[BLT D,-1(TT)] ;READING
BLKTN7:	 MOVEI D,(TT)	;NO FAULT, UPDATE PTR TO LAST WORD + 1 (LIKE KL10)
BLKTN8:	SUBM D,J
	HRRZS J		;# WDS ACTUALLY XFERRED
	ADDM J,@(B)	;INCR BUFFER PNTR
	HRLS J		;PUT # WDS IN BOTH HALVES
	JUMPL C,BLKTN3	;UPDATE AOBJN PTR IN EXEC SPACE
	XCTRI XRW,[ADDM J,(C)] ;UPDATE AOBJN PTR IN USER SPACE
	 JRST .+2
	  JRST 4,.	;MUMBLE.  THIS WAS SUPPOSED TO BE THERE.

BLKTN4:	MOVNI J,(J)
	ADDM J,@1(B)	;DECREMENT COUNT LEFT IN BUFFER
	CAIE D,(TT)	;SKIP IF TRANSFERRED ALL WE COULD
	 PUSHJ P,TPFLT	;TAKE FAULT IF ANY
	SKIPN @1(B)
	 PUSHJ P,@3(B)	;BUFFER EXHAUSTED, "DISCARD"
	JRST BLKT1	;GO TRANSFER ANOTHER CHUNK

BLKTN3:	ADDM J,(C)	;UPDATE EXEC AOBJN POINTER
	JRST BLKTN4

BLKTW1:	PUSHJ P,UDELAY
	JRST BLKTF1

BLKTN6:	XCTRI XBR,[BLT D,-1(TT)] ;WRITING TRANSFER
	 JRST BLKTN7
	JRST BLKTN8

BLKTN9:	BLT D,-1(TT)	;READING INTO EXEC SPACE
	JRST BLKTN7

SUBTTL DIRECTORY AND ERR DEVICES

QMLSTF:	MOVEI J,4	;ENTRY TO GET MASTER 2314 DIRECTORY
	JRST LISTF7

QLISTF:	MOVEI J,3	;ENTRY FOR 2314 USER DIRECTORY
LISTF7:	MOVEI I,0
LISTFE:	PUSHJ P,SWTL	;ENTER HERE FOR ALL KINDS OF DIRECTORIES.
	UDCSW
	MOVSI TT,-NUDCH
UD1:	SKIPGE UDUSR(TT)
	JRST UD2
	AOBJN TT,UD1
	JRST OPNL17	;DIRECTORY NOT AVAILABLE NOW

UD2:	MOVEM J,DSKLST(TT)
	MOVEM I,UDUSR(TT)
	PUSHJ P,LSWPOP
	MOVE Q,USYSN1(U)
	MOVEM Q,UDSYSN(TT)
	JUMPG J,UDIF	;JUMP IF NOT UTAPE DIR.
IFE NUNITS, JRST 4,.	;HOW DID UTAPE GET HERE?
IFN NUNITS,[
	CONO PI,CLKOFF
	MOVE Q,UDIRO(I)
	MOVEM Q,DIRPT(TT)
	CONO PI,CLKON
	MOVEI J,200
	TRNE D,2
	JRST UDBIN	;IMAGE MODE UTAPE DIR
	MOVEI Q,LISTF	;ASCII MODE UTAPE DIR
]
UDIF1:	MOVEM Q,DIRPC(TT)
	HRL A,TT
	JSP Q,OPSLD1
	DIRCHN,,DIRBN

UDIF:	HLRZ Q,UDT-1(J)	;INITIAL COROUTINE PC
	HRRZ T,UDT-1(J)	;PLACE TO FINISH OPENING - USUALLY UDIF1.
	JRST (T)

UQL1:	HRRZM H,UUDPP(TT)	;2314 MFD (FROM UDIF)
	MOVEI J,2000
	TRNE D,2
	JRST QUDBIN
	JRST UDIF1

UQL1A:	PUSHJ P,STMSET	;DISK UFD (FROM UDIF). WE CAN STILL PCLSR,
	UDUSR(TT)	;ARRANGE TO GIVE BACK THE DIRECTORY CHANNEL.
UQL1B:	PUSH P,TT
	PUSHJ P,QUDLK
	PUSHJ P,TCALL	;GET A LOW-HALF PAGE TO COPY UFD INTO.
	  JRST NMMRQ	;GET LOW HALF PAGE
	 JRST UQL1W	;NOT AVAIL NOW
	MOVEI T,MU23LS
	DPB T,[MUR,,MEMBLT(A)]	;MARK THE PAGE AS A UFD COPY.
	LSH A,10.
	MOVEM A,DIRPT(TT)
	MOVEM A,UUDPP(TT)
	HRL A,QSNLCN(H)
	HRRI T,2000(A)
	BLT A,-1(T)	;COPY UFD
	PUSHJ P,QUDULK
	PUSHJ P,LSWDEL	;STMSET OF UDUSR.
	PUSHJ P,LSWPOP	;SOS QSNNR
	POP P,TT
	MOVEI J,2000
	TRNE D,2
	JRST UDBIN
	JRST UDIF1

UQL1W:	PUSHJ P,QUDULK
	POP P,TT
	PUSHJ P,TCALL	;TRY FLUSHING DIRECTORIES
	JRST QDIRFL
	JRST .+2	;LOST
	JRST UQL1B	;SEE IF THAT MADE ROOM
	MOVE T,TIME
	ADDI T,30.
	CAMLE T,TIME
	PUSHJ P,UFLS
	JRST UQL1B

;LH INITIAL PC RH DISP ADR AT OPEN TIME
UDT:	NDLF,,UDIF1	;NON DIR DEVICE
	UCL1,,UDIF1	;CORE LINK
	UQL2,,UQL1A	;2314 UFD
	QMLS1,,UQL1	;2314 MFD
	ERR1,,ERR2	;ERR DEVICE
	TTYFLD,,UDIF1	;TTY DIR
	TTYF99,,UDIF1	;COR DIR (LAST LINE OF TTY DIR)

QUDBIN:	CONO PI,CLKOFF
	HRRZ T,QMDRO
	MOVEM T,DIRPT(TT)
	CONO PI,CLKON
UDBIN:	MOVEM J,NUM(TT)	;DOESN'T USE DIRPC THIS PC
	MOVEM J,ENDT(TT)
	MOVEI J,444400
	HRLM J,DIRPT(TT)
	HRL A,TT
	JSP Q,OPSLD1
	NDATAI,,NBLKI

UTDCLS:	MOVE B,DSKLST(A)
	CAIN B,3
	JRST UTDCL1
UTDCLX:	SETOM UDUSR(A)
	POPJ P,

UTDCL1:	PUSH P,A
	MOVE A,UUDPP(A)
	LSH A,-10.
	PUSHJ P,MEMR
	POP P,A
	JRST UTDCLX

;UNIT MODE IOT ON DIR DEVICE COMES HERE (RETURN CHAR IN W)
DIRCH:	SETOM SRN3(U)	;SAY WE WANT ONLY 1 CHARACTER.
	PUSHJ P,DIRCHR
	HRRZ W,I
	CAIN W,^C
	 JRST UNIEOF
	POPJ P,

;BLOCK MODE IOT ON DIR DEVICE.
DIRB:	JSP Q,WRDBT	;PUSHJ'S TO .+1 FOR EACH WORD.
DIRB1:	XCTR XRW,[MOVES (C)]	;MAKE SURE WE CAN WRITE.
	PUSH P,C
	PUSH P,H
	SETZM SRN3(U)	;SAY WE WANT A WHOLE WORD OF CHARS.
	PUSHJ P,DIRCHR
	POP P,H
	POP P,C
	LDB Q,[350700,,SRN3(U)]
	CAIN Q,^C	;IF THE WORD STARTS WITH ^C,
	 JRST POPJ2	;IT IS EOF; DON'T RETURN IT, UNHANG IOT.
	MOVE Q,SRN3(U)
	XCTR XW,[MOVEM Q,(C)]
	MOVEI Q,DIRB1	;FASTER THAN PUSHING AND POPPING Q.
	POPJ P,		;RETURN INTO WRDBT

DDATAI:	MOVEI E,1
	MOVEI B,DBLKI+1	;UNIT IMAGE INPUT FROM DIRECTORY.
	JRST CHRKTI

DBLKI:	MOVEI E,1
	JSP B,BLKT
	  DIRPT(A)
	  NUM(A)
	  POPJ2		;EOF IF TRY TO GET ANOTHER BUFFER
	  CPOPJ		;BUFFER DISCARD ROUTINE
	  JRST 4,.
	  SKIPA

;ERR DEVICE AND ERROR MESSAGE TABLES
; ERR DEVICE WORKS MUCH LIKE DIR DEVICE

ERRO:	MOVEI J,5
	JRST LISTF7

ERR2:	SOJE A,ERR21	;LAST ERRONEOUS CHANNEL
	SOJE A,ERR22	;CHANNEL SPECIFIED IN B
	SOJE A,ERR23	;STATUS WORD IN B
	SOJE A,ERR24	;.CALL ERROR ARG IN B
	SETOM UDUSR(TT)
	JRST OPNL11

ERR21:	LDB B,[BCHPTR]
ERR22:	ANDI B,17
	ADDI B,IOCHST(U)
	SKIPA B,(B)
ERR24:	 MOVSS B
ERR23:	MOVEM B,UUDPP(TT)
	JRST UDIF1

CORO:	PUSHJ P,FLDRCK
	JRST OPNL11
	MOVEI J,7
	JRST LISTF7

ERR1:	SKIPN I,UUDPP(A)
	JRST ERR3
	LDB B,[220600,,UUDPP(A)]	;OPEN LOSS FIELD
	JUMPE B,ERR1B
	CAIL B,NERMES+1
	 MOVEI B,NERMES+1
	MOVE TT,ERMST1-1(B)
	JSP B,MESPNT
ERR1B:	LDB B,[300300,,UUDPP(A)]	;IDS ERROR FIELD
	JUMPE B,ERR1C
	MOVE TT,ERMST2-1(B)
	JSP B,MESPNT
ERR1C:	LDB B,[330400,,UUDPP(A)]	;IOCERR FIELD
	JUMPE B,UCL7
	CAIL B,MIOTER
	CAIL B,NERM1+MIOTER
	MOVEI B,NERM1+MIOTER
	MOVE TT,ERMST3-MIOTER(B)
	JSP B,MESPNT
	JRST UCL7

ERR3:	MOVEI TT,[ASCIZ /ISE0
/]
	JSP B,MESPNT
	JRST UCL7

;LISP ASSUMES THAT NO "ERR" DEVICE MESSAGE WILL EVER CONTAIN
; !, #, ^, OR LOWER CASE LETTERS.  PLEASE MAINTAIN THIS STATE
;   GLS (GUY STEELE)

ERMST1:	[ASCIZ /NO SUCH DEVICE
/]
	[ASCIZ /WRONG DIRECTION
/]
	[ASCIZ /TOO MANY TRANSLATIONS
/]
	[ASCIZ /FILE NOT FOUND
/]
	[ASCIZ /DIRECTORY FULL
/]
	[ASCIZ /DEVICE FULL
/]
	[ASCIZ /DEVICE NOT READY
/]
	[ASCIZ /DEVICE NOT AVAILABLE
/]
	[ASCIZ /ILLEGAL FILE NAME
/]
	[ASCIZ /MODE NOT AVAILABLE
/]
	[ASCIZ /FILE ALREADY EXISTS
/]
	[ASCIZ /BAD CHANNEL NUMBER
/]
	[ASCIZ /TOO MANY ARGUMENTS (CALL)
/]
	[ASCIZ /PACK NOT MOUNTED
/]
	[ASCIZ /DIRECTORY NOT AVAIL
/]
	[ASCIZ /NON-EXISTENT DIRECTORY
/]
	[ASCIZ /LOCAL DEVICE ONLY
/]
	[ASCIZ /SELF-CONTRADICTORY OPEN
/]
	[ASCIZ /FILE LOCKED
/]
	[ASCIZ /M.F.D. FULL
/]
	[ASCIZ /DEVICE NOT ASSIGNABLE TO THIS PROCESSOR
/]
	[ASCIZ /DEVICE WRITE-LOCKED
/]
	[ASCIZ /LINK DEPTH EXCEEDED
/]
	[ASCIZ /TOO FEW ARGUMENTS (CALL)
/]
	[ASCIZ /CAN'T MODIFY JOB
/]
	[ASCIZ /CAN'T GET THAT ACCESS TO PAGE
/]
	[ASCIZ /MEANINGLESS ARGS
/]
	[ASCIZ /WRONG TYPE DEVICE
/]
	[ASCIZ /NO SUCH JOB
/]
	[ASCIZ /VALID CLEAR OR STORED SET
/]
	[ASCIZ /NO CORE AVAILABLE
/]
	[ASCIZ /NOT TOP LEVEL
/]
	[ASCIZ /OTHER END OF PIPELINE GONE OR NOT OPEN
/]
	[ASCIZ /JOB GONE OR GOING AWAY
/]
	[ASCIZ /ILLEGAL SYSTEM CALL NAME
/]
	[ASCIZ /CHANNEL NOT OPEN
/]
	[ASCIZ /INPUT BUFFER EMPTY OR OUTPUT BUFFER FULL
/]
IFN .-ERMST1-NOPNLS,.ERR WRONG TABLE LENGTH
;ADD NEW MESSAGES HERE

IFN 0,[		A CLASSIFICATION OF OPEN-LOSS MESSAGES

FULL -	NO CORE (MMP FULL)
	DIR NOT AVAIL (DIR CHNL TABLE FULL)
	DEVICE FULL
	DIR FULL
	MFD FULL
	INPUT BUFFER EMPTY OR OUTPUT BUFFER FULL

NO SUCH - DEVICE, FILE, JOB, DIRECTORY, PAGE (CAN'T GET ACCESS)
	  ILLEGAL SYSTEM CALL NAME

ALREADY ONE SUCH - FILE (FILE ALREADY EXISTS - RENAME)

WRITING - CAN'T MODIFY JOB
	 DEVICE WRITE-LOCKED
	 WRONG DIRECTION
	 MODE NOT AVAILABLE
	 CAN'T GET ACCESS TO PAGE

ARGS (THE PARAMETERS ARE RIDICULOUS) -
	SELF-CONTRADICTORY OPEN COMMAND
	ILLEGAL FILE NAME
	BAD CHANNEL NUMBER
	TOO FEW ARGS
	TOO MANY ARGS
	MEANINGLESS ARGS
	CHANNEL NOT OPEN

NOT AVAILABLE (IT EXISTS BUT YOU CAN'T USE IT) -
	DEVICE NOT READY
	DEVICE NOT AVAILABLE
	       NOT ASSIGNABLE TO THIS PROCESSOR
	LOCAL DEVICE
	PACK NOT MOUNTED
	FILE LOCKED
	OTHER END OF PIPELINE GONE
	JOB GONE OR GOING AWAY

DEPTH -	LINK DEPTH EXCEEDED
	TOO MANY TRANSLATIONS

OTHER -	NOT TOP LEVEL
	VALID CLEAR OR STORED SET
]

NERMES==.-ERMST1
	[ASCIZ /OPEN TYPE NOT DETERMINED
/]

ERMST2:	[ASCIZ /IDS ILLEGAL SCOPE MODE
/]
	[ASCIZ /IDS SCOPE HUNG
/]
	[ASCIZ /MORE THAN 1K SCOPE BUFFER
/]
	[ASCIZ /IDS MEM PROTECT
/]
	[ASCIZ /IDS ILLEGAL SCOPE OP
/]
	[ASCIZ /IDS MEM PROTECT ON PDL PNTR
/]
	[ASCIZ /IDS ILLEGAL PARAMETER SET
/]

ERMST3:	[ASCIZ /ILLEGAL HARDWARE OPERATION ATTEMPTED
/]
	[ASCIZ /ATTEMPTED RANDOM ACCESS TO ADDRESS BEYOND END OF FILE
/]
	[ASCIZ /NON-RECOVERABLE DATA ERROR
/]
	[ASCIZ /NON-EXISTENT SUB DEVICE
/]
	[ASCIZ /OVER IOPOP
/]
	[ASCIZ /OVER IOPUSH
/]
	[ASCIZ /USR OP CHNL DOES NOT HAVE USR OPEN
/]
	[ASCIZ /CHNL NOT OPEN
/]
	[ASCIZ /DEVICE FULL
/]
	[ASCIZ /CHNL IN ILLEGAL MODE ON IOT
/]
	[ASCIZ /ILLEGAL CHR AFTER CNTRL P ON TTY DISPLAY
/]
;INSERT NEW MESSAGES HERE
NERM1==.-ERMST3
	[ASCIZ /IOT OR OPR TYPE NOT DETERMINED
/]

;DIRECTORY LISTING ROUTINES

UNAMQ:	MOVEI T,0
UNAMQ1:	SKIPN UNAME(T)
	JRST UNAMQ2
	CAME B,USYSNM(T)
	CAMN B,UNAME(T)
	POPJ P,
UNAMQ2:	CAML T,USRHI
	JRST POPJ1
	ADDI T,LUBLK
	JRST UNAMQ1

UQL3C:	SKIPA I,["*]
UQL3:	MOVEI I,"-
	PUSHJ P,OUTC
	JRST UQL3A

UQL2:	MOVEI TT,[MNAME ASCIZ /,  /]	;GENERATE USER DIRECTORY
	JSP B,MESPNT
	MOVE I,UUDPP(A)
	MOVEI J,UDNAME(I)
	JSP B,SIXTYC	;SEND DIRECTORY NAME
	MOVEI TT,[ASCIZ /
FREE BLOCKS /]
	JSP B,MESPNT
	MOVSI E,-NQS
UQL2A:	SKIPGE QACT(E)
	JRST UQL3	;UNIT NOT ENGAGED
	MOVE J,QTUTO(E)
	TLNE J,40000
	JRST UQL3C	;TUT FOR UNIT NOT IN
	MOVEI I,"#
	PUSHJ P,OUTC
	MOVE TT,QPKID(E)
	JSP B,GDPT	;AND #
	MOVEI I,"=
	PUSHJ P,OUTC
	MOVE TT,QSFT(E)
	JSP B,GDPT	;AND # FREE TRACKS
UQL3A:	PUSHJ P,OUTCS
	AOBJN E,UQL2A
	JSP B,MESPCR
	MOVE I,UUDPP(A)
	MOVEM I,DIRPT(A)
	MOVE Q,UDNAMP(I)
UQL4:	CAIL Q,2000
	JRST UCL7
	HRLI I,440600+Q
	HLLM I,DIRPT(A)

UQLP:	ADDI Q,2	;MOVE PNTR TO 3RD WRD OF FILE DESC
	MOVE I,@DIRPT(A)
	MOVEI TT,[ASCIZ /* /]	;DELETED OR BEING WITTEN
	TLNN I,UNIGFL
	MOVEI TT,[ASCIZ /  /]
	JSP B,MESPNT
	MOVE I,@DIRPT(A)
	TLNE I,UNLINK
	JRST UQLL1	;LINK
	LDB TT,[UNPKN+@DIRPT(A)]
	JSP B,GDPT	;PRINT PACK #
	LDB TT,[UNPKN+@DIRPT(A)]
	CAIG TT,9
UQLL2:	PUSHJ P,OUTCS
	PUSHJ P,OUTCS
	SUBI Q,2	;BACK TO FIRST WD
	JSP B,SIXTYA	;SEND FIRST FILE NAME
	JSP B,SIXTYB	;AND SECOND (AOSES Q)
	PUSHJ P,OUTCS
	AOS Q	;SET Q TO POINT TO FILE DESC PNTR
	LDB E,[UNDSCP+@DIRPT(A)]	;PICK UP FILE DESC PNTR
	IDIVI E,UFDBPW
	ADDI E,UDDESC	;COMPUTE WORD ADDRESS
	MOVE I,@DIRPT(A)	;SAVE STATUS WORD
	EXCH E,Q	;MOVE INTO PNTR
	MOVE TT,QBTBLI(TT)
	TLO TT,Q
	HLLM TT,DIRPT(A)	;SET UP DIRPT TO POINT TO FILE DESC
	TLNE I,UNLINK
	JRST QLL1	;LINK
	MOVEI TT,0
UQL5:	JSP B,UQL5R	;CHECK IF ABOUT TO INCREMENT OFF WORD
	ILDB I,DIRPT(A)
	JUMPE I,UQL5A	;STOP
	CAILE I,UDTKMX
	JRST UQL5B
	ADD TT,I
	JRST UQL5

UQLL1:	MOVEI I,"L
	PUSHJ P,OUTC
	JRST UQLL2

QLL1:	CLEARM ENDT(A)	;CNTS TO 3 FOR USER NAME AND 2 FILE NAMES
QLL3:	CLEARM NUM(A)	;CHR CNTR
QLLIST:	JSP B,UQL5R
	ILDB I,DIRPT(A)
	JUMPE I,QLL4
	CAIN I,';
	JRST QLL2
	CAIN I,':
	JRST QLL5
QLL5A:	ADDI I,40
	PUSHJ P,OUTC
	AOS I,NUM(A)
	CAIGE I,6
	JRST QLLIST
QLL2:	PUSHJ P,OUTCS
	AOS I,ENDT(A)
	CAIGE I,3
	JRST QLL3
QLL4:	JSP B,MESPCR
	MOVEI Q,3(E)	;ADVANCE Q
	JRST UQL4

QLL5:	JSP B,UQL5R
	ILDB I,DIRPT(A)
	JRST QLL5A

UQL5R:	MOVE I,DIRPT(A)	;CHECK IF ABOUT TO ILDB OFF WORD
	TLNE I,770000
	JRST (B)	;NO
	MOVEI I,440600+Q	;YES INCREMENT Q INSTEAD
	HRLM I,DIRPT(A)
	AOJA Q,(B)

UQL5B:	CAIGE I,UDWPH	;PLACE HOLDER
	AOJA TT,UQL5	;SKIP AND TAKE
	CAIN I,UDWPH
	JRST UQL5	;NULL
	REPEAT NXLBYT,[JSP B,UQL5R
	IBP DIRPT(A)
]
	AOJA TT,UQL5	;SPACE OVER 2ND HALF OF LOAD ADDRESS

UQL5A:	JSP B,GDPT	;TYPE OUT # BLOCKS
	PUSHJ P,OUTCS
	MOVE Q,E	;FILE POINTER
	MOVEI I,"!
	SKIPGE @DIRPT(A)	;SKIP ON NOT DUMPED
	MOVEI I,40
	PUSHJ P,OUTC	;HAS NOT BEEN BACKED UP
	MOVEI Q,1(E)
	LDB E,[1200,,DIRPT(A)]
	JUMPN E,[JRST 4,.]
	MOVE TT,@DIRPT(A)
	AOJE TT,UQL5C	;DATE NOT KNOWN
IFN OQDTSW,[	;EVENTUALLY FLUSH CODING
	LDB TT,[UNMON+@DIRPT(A)]
	JSP B,GDPT	;TYPE MONTH
	MOVEI I,"/
	PUSHJ P,OUTC
	LDB TT,[UNDAY+@DIRPT(A)]
	JSP B,GDPT	;TYPE DAY
	MOVEI I,"/
	PUSHJ P,OUTC
	LDB TT,[UNYRB+@DIRPT(A)]
	JSP B,GDPT	;TYPE YEAR
	PUSHJ P,OUTCS
	HRRZ TT,@DIRPT(A)
	IDIVI TT,60.*60.*2
	MOVE E,I
	JSP B,G2DPT
	MOVEI I,":
	PUSHJ P,OUTC
	MOVE TT,E
	IDIVI TT,60.*2
	MOVE E,I
	JSP B,G2DPT
	MOVEI I,":
	PUSHJ P,OUTC
	MOVE TT,E
	LSH TT,-1
	JSP B,G2DPT
]	;END OLD DATE CODING
UQL5D:	JSP B,MESPCR
	ADDI Q,2	;ADVANCE Q
	JRST UQL4

UQL5C:	MOVEI I,"-
	PUSHJ P,OUTC
	JRST UQL5D

;GENERATE MFD LISTING
QMLS1:	CONO PI,CLKOFF
	MOVE Q,QMDRO
	HRLI Q,440600+Q
	MOVEM Q,DIRPT(A)
	MOVE Q,MDNAMP(Q)
	CONO PI,CLKON
QMLS2:	CAIL Q,1777
	JRST UCL7
	SKIPN @DIRPT(A)
	JRST QMLS3
	JSP B,SIXTYA
	JSP B,MESPCR
QMLS3:	ADDI Q,LMNBLK
	JRST QMLS2

IFN OQDTSW,[	;EVENTUALLY FLUSH CODE
ZZ==0
DAYTB:	;DAYS PRECEEDING MONTH (NO LEAP YEAR)
IRPS A,,[31,28,31,30,31,30,31,31,30,31,30,31]
	ZZ
	ZZ==ZZ+A!.
TERMIN
]

;DIRECTORY LISTING ROUTINES FOR UTAPE

IFN NUNITS,[
LISTF:	MOVEI Q,220600+Q
	HRLM Q,DIRPT(A)
	MOVEI Q,177
	MOVE TT,@DIRPT(A)
	AOJE TT,LISTF1
	JSP B,SIXTYP
LISTF1:	MOVEI TT,[ASCIZ /
FREE FILES /]
	JSP B,MESPNT
	MOVSI Q,-23.
	MOVEI TT,0
LISTF4:	SKIPE @DIRPT(A)
	AOJA Q,LISTF8
	AOS Q
	SKIPN @DIRPT(A)
	AOS TT
LISTF8:	AOBJN Q,LISTF4
	JSP B,GDPT
	MOVEI TT,[ASCIZ /	FREE BLOCKS /]
	JSP B,MESPNT
	SETZB J,TT
	JSP B,BLKPNT
LISTD2:	JSP B,MESPCR
	MOVSI Q,-23.
LISTF2:	MOVEI I,440600+Q
	HRLM I,DIRPT(A)
	MOVE I,@DIRPT(A)
	JUMPE I,LISTF5
LISTF6:	PUSHJ P,OUTCS
	JSP B,SIXTYA
	JSP B,SIXTYB
	PUSHJ P,OUTCS
	MOVEI J,1(Q)
	JSP B,BLKPNN
LISTD4:	JSP B,MESPCR
LISTF3:	AOBJN Q,LISTF2
];END IFN NUNITS

UCL7:	MOVEI I,14	;END DIR WITH FORMFEED AND EOF CHARS
	PUSHJ P,OUTC
	HRROI I,EOFCH
	JRST .-2

IFN NUNITS, LISTF5:	AOJA Q,LISTF3

; DIRECTORY LISTING ROUTINES FOR MISC. DEVICES + CORE LINK

NDLF:	MOVEI TT,[ASCIZ /
NON-DIRECTORY DEVICE/]
	JSP B,MESPNT
	JRST UCL7

;DIRECTORY OF CORE LINK DEVICE
UCL1:	MOVSI Q,-NCLCH
UCL6:	SKIPN CLSYN(Q)
	JRST UCL5A
	MOVEI J,CLSYN(Q)
	JSP B,SIXTYC
	MOVEI J,CLN1(Q)
	JSP B,SIXTYC
	MOVEI J,CLN2(Q)
	JSP B,SIXTYC
	HLRE B,CLUSR(Q)
	AOJE B,UCL2
	MOVEI J,UNAME-1(B)
	MOVEM B,NUM(A)
	JSP B,SIXTYC
	MOVE B,NUM(A)
	MOVEI J,JNAME-1(B)
	JSP B,SIXTYC
UCL3:	MOVEI TT,[ASCIZ /->/]
	JSP B,MESPNT
	HRRE B,CLUSR(Q)
	AOJE B,UCL4
	MOVEI J,UNAME-1(B)
	MOVEM B,NUM(A)
	JSP B,SIXTYC
	MOVE B,NUM(A)
	MOVEI J,JNAME-1(B)
	JSP B,SIXTYC
UCL5:	JSP B,MESPCR
UCL5A:	AOBJN Q,UCL6
	JRST UCL7

UCL4:	MOVEI B,UCL5
	JRST .+2
UCL2:	MOVEI B,UCL3
	MOVEI J,[SIXBIT /CLOSED/]
SIXTYC:	HRLI J,440600
	MOVEM J,DIRPT(A)
	PUSHJ P,OUTCS
	JRST SIXTYP

; DIRECTORY LISTING ROUTINES FOR TTY

TTYFLD:	MOVEI TT,[ASCIZ /
TTY UNAME  JNAME  CORE  TOTAL IDX
/]
	JSP B,MESPNT
	MOVSI Q,-NCT
TTYF1:	HRRE E,TTYSTS(Q)
	AOJE E,TTYF5	;JUMP IF NOT IN USE
	MOVE E,TTYSTS(Q)
	MOVEI I,"T	;TTY
	TLNN E,%TSCNS
	MOVEI I,"D	;"DEVICE"
	PUSHJ P,OUTC
	HRRZ TT,Q
	JSP B,G2OPT
	HRRZS E
TTYF11:	MOVEI J,UNAME(E)
	JSP B,SIXTYC
	MOVEI J,JNAME(E)
	JSP B,SIXTYC
	PUSHJ P,OUTCS
	MOVE TT,NMPGS(E)
	JSP B,G3DPT
	JSP B,MESP3S
	MOVEM E,DIRPT(A)
	MOVE E,UTMPTR(E)
	SETZB B,TT
TTYF3:	CAME E,UTMPTR(B)
	JRST TTYF4
	ADD TT,NMPGS(B)
	JUMPE Q,TTYF4
	SKIPGE SUPPRO(B)
	MOVE J,B
TTYF4:	ADDI B,LUBLK
	CAMGE B,USRHI
	JRST TTYF3
	SKIPE Q
	MOVEM J,DIRPT(A)
	JSP B,G3DPT
	JSP B,MESP3S
	MOVE TT,DIRPT(A)
	IDIVI TT,LUBLK
	JSP B,G2OPT
	JSP B,MESPCR
TTYF5:	JUMPE Q,TTYF99
	AOBJN Q,TTYF1
	SETZB E,TT
	SETZM I
TTYF7:	SKIPGE APRC(I)
	JRST TTYF9
TTYF13:	ADDI I,LUBLK
	CAMGE I,USRHI
	JRST TTYF7
	JUMPE E,TTYF99
	MOVEI TT,[ASCIZ /DSN/]
	JSP B,MESPNT
	SETZM Q
	JRST TTYF11

TTYF9:	CAML TT,NMPGS(I)
	JRST TTYF13
	MOVE E,I
	MOVE TT,NMPGS(E)
	JRST TTYF13

TTYF99:	MOVEI TT,[ASCIZ /FREE CORE  /]
	JSP B,MESPNT
	MOVE TT,MEMFR
	SUB TT,NCBCOM
	JSP B,G3DPT
	MOVEI TT,[ASCIZ / OUT /]
	JSP B,MESPNT
	MOVE TT,NPGSWO
	JSP B,G3DPT
	JRST UCL7

SIXTYB:	AOS Q
SIXTYA:	PUSHJ P,OUTCS
	MOVEI I,440600+Q
	HRLM I,DIRPT(A)

SIXTYP:	ILDB I,DIRPT(A)
	ADDI I,40
	PUSHJ P,OUTC
	MOVE I,DIRPT(A)
	TLNE I,770000
	JRST SIXTYP
	JRST (B)

MESP3S:	SKIPA TT,[[ASCIZ /   /]]
MESPCR:	MOVEI TT,[ASCIZ /
/]
MESPNT:	HRLI TT,440700
	MOVEM TT,NUM(A)
	ILDB I,NUM(A)
	JUMPE I,(B)
	PUSHJ P,OUTC
	JRST .-3

OUTCS:	MOVEI I,40
OUTC:	SKIPL TT,SRN3(U) ;IF WANT 1 CHAR, RETURN WITH IT, SAVING ACS.
	 JRST OUTC1	;IF WANT WHOLE WORD, SEE IF WORD IS FULL.
OUTC2:	MOVEM E,SAVE(A)
	MOVEM Q,SAVQ(A)
	MOVEM B,SAVB(A)
	POP P,DIRPC(A)
	POPJ P,

OUTC1:	LSH TT,6
	ADDI TT,(I)	;MERGE THIS CHAR (IN I) INTO WORD BEING ACCUMULATED.
	LSH TT,1
	MOVEM TT,SRN3(U)
	TLNE TT,774000	;IF THE WORD IS FULL, RETURN TO DIRB.
	 JRST OUTC2
	POPJ P,		;ELSE POPJ FROM OUTC, TO GET MORE CHARS.

G2OPT:	IDIVI TT,8
	JRST G2DPT2

G3DPT:	IDIVI TT,100.
	MOVEM I,NUM(A)
	MOVEI I,"0(TT)
	PUSHJ P,OUTC
	MOVE TT,NUM(A)
G2DPT:	IDIVI TT,10.
G2DPT2:	MOVEM I,NUM(A)
	MOVEI I,"0(TT)
	PUSHJ P,OUTC
	MOVE I,NUM(A)
	ADDI I,"0
	PUSHJ P,OUTC
	JRST (B)

GDPT:	SETZM ENDT(A)
	MOVEM TT,NUM(A)
GDPT1:	PUSH P,Q
	MOVE Q,TT
	IDIVI TT,10.
	CAME TT,ENDT(A)
	JRST .-3
	MOVEM Q,ENDT(A)
	POP P,Q
	ADDI I,"0
	PUSHJ P,OUTC
	MOVE TT,NUM(A)
	CAME TT,ENDT(A)
	JRST GDPT1
	JRST (B)

DIRCHR:	MOVE E,SAVE(A)
	MOVE B,SAVB(A)
	MOVE Q,SAVQ(A)
	JRST @DIRPC(A)

BLKPNA:	MOVEI J,1(I)
	LSH J,-1
	JRST BLKPNT+1

BLKPNN:	LSH J,-1
BLKPNT:	MOVEI TT,0
	MOVEI I,56
BLKPN2:	MOVEI E,440500+I
	HRLM E,DIRPT(A)
BLKPN1:	ILDB E,DIRPT(A)
	CAIN E,37
	JRST BLKPN3
	CAMN E,J
	AOS TT
	HLRZ E,DIRPT(A)
	TRNE E,760000
	JRST BLKPN1
	AOJA I,BLKPN2
BLKPN3:	JUMPE J,GDPT
	MOVSI I,-23.
BLKPN4:	MOVE E,@DIRPT(A)
	AOS I
	CAMN J,@DIRPT(A)
	JUMPE E,BLKPNA
	AOBJN I,BLKPN4
	JRST GDPT

EBLK

UDUSR:	REPEAT NUDCH,-1	;-1 => FREE, ELSE UTAPE # IF UTAPE DIR, ELSE 0.

IRPS X,,DIRPC:DIRPT:NUM:ENDT:SAVB:SAVQ:UDSYSN:UUDPP:SAVE:
X:	REPEAT NUDCH,-1
	TERMIN
UDCSW:	-1
	0

DSKLST:	BLOCK NUDCH	;0 LISTING UTAPE 1 NON-DIR DEVICE
				;2 CORE LINK 3 2311
;NO BBLK SINCE VARIABLES ON NEXT PAGE

SUBTTL UTC LEVEL INTERRUPT

;NO EBLK SINCE VARIABLES ON PREVIOUS PAGE

UTCPDP:	-LUTCP,,UTCP-1	;UTC-LEVEL PDL
UTCP:	BLOCK LUTCP
UTACS:	BLOCK 20	;UTC-LEVEL AC SAVE

UTCBRK:	0
BBLK
IFN KL10P,[
	CONSO PI,1_<7-UTCCHN>
	 JRST 12,@UTCBRK	;HARDWARE BUG
]
	MOVEM U,UTACS+U
	MOVEI U,UTACS
	BLT U,UTACS+U-1
	MOVE P,UTCPDP
IFN NUNITS,[
IFE NEWDTP,[
	CONSZ DC,6
	JRST PIPOS	;HAS CHNL >1
PIPX:
]
IFN NEWDTP,[
	SKIPGE CUINT
	JRST UTCB0
]
];IFN NUNITS
IFN NETP,[
IFE DMI,[
	CONI IMP,TT
	LDB A,[000300,,TT]
	CAIE A,NETCHN
	JRST UTCB2
	TRNE TT,IMPLW+IMPHER+IMPERR+IMPOD+IMPID
]
IFN DMI,[
	CONI FI,TT
	TRNN TT,70	;CHECK PIA
	JRST UTCB2	;DO NOT PROCESS IF NO PIA
	TRNE TT,FILW+FIDOWN+FIWASD+FIOD+FIID
]
	JRST IMPINT
UTCB2:]
IFN DC10P,[
	CONI DC0,TT
	TRNE TT,DPIRQC
	JRST QINT
]
IFN KL10P, CONO PI,020000+200_<-UTCCHN>	;BAG-BITING DEC LOSERS
IFN RP10P,[
	CONI DPC,TT
	TRNE TT,7
	TRNN TT,10	;IF BIT IS ON IT IS INTERRUPTING - LET QINT HAVE IT
	SKIPGE QGTBZY
	JRST QINT
]
IFN RH10P,[
	CONI DSK,TT
	TRNN TT,%HIDON+%HIATN	;INTERRUPTING HARDWARILY
	SKIPGE QGTBZY		;INTERRUPTING SOFTWARILY
	 JRST QINT
]
IFN NMTCS,[
	CONI MTC,A
	CONI MTS,C
	LDB TT,[030300,,A]
	CAIE TT,MTCCHN
	JRST UTCBK2
	TRNN C,100	;IF NOT JOB DONE
	TRZ C,30000	; THEN DON'T BELIEVE PAR ERR OF EOF
	TRNN A,400	;IF NEXT UNIT NOT ENABLED
	TRZ C,2	;THEN TURN OFF NEXT UNIT FLAG
	TRNE C,440302	; UNIT HUNG, ILLEGAL, BAD TAPE (UGH), LOAD NEXT UNIT, JOB DONE
	JRST MGHBRK
UTCBK2:	SKIPN MGTBZY	; SOFT WARE CALL
	JRST MGSBRK
]
IFN NUNITS,	JRST UTCB0


POPRET:
IFN NUNITS,[
	MOVE A,TIME
	MOVEM A,LUTOTM
]
DSKEX:
IMPEX:
MGEX:	MOVSI U,UTACS
	BLT U,U
	JRST 12,@UTCBRK


$INSRT SYSJOB		;SYSTEM JOB AND RELATED STUFF


SUBTTL DCHNTB AND DCHNTC

;***** DCHNTB *****
;4.9 = KNOWN DEVICE
;4.8 = HAS PIA 2
;4.7-4.4 PIA 2 SHIFT
;4.3-4.1 PIA 2 ACTIVE VALUE
;3.9 = PIA 2 MAY BE ZERO
;3.8 = HAS PIA 1
;3.7-3.4 PIA 1 SHIFT
;3.3-3.1 PIA 1 ACTIVE VALUE
;2.9 = PIA 1 MAY BE ZERO
;2.8 = ALLOW USER DATAI
;2.7 DATAO
;2.6 CONI
;2.5 CONO
;2.4 SPECIAL KL10 DEVICE, BLKI/BLKO ARE DATAI/DATAO TO A SECOND DEVICE REGISTER
;1.6-1.1=N, IF NON ZERO: IGNORE DEV UNLESS CONI BIT N-1 IS ON
		;(IF DSDEV PRESENT)

;***** DCHNTC *****
;4.9 = SUSPICIOUS DEVICE
;4.8 = FOUND CLOBBERED
;4.7 = SUSPECTED OF CAUSING SPURIOUS INTS
;4.6-4.4 = CHANNEL CAUSING INTS ON
;3.9-3.1 = SUSPICION COUNT
;2.9-1.1 = CONI

DCHNTB:
IFE KL10P,[
	400200+APRCHN,,240000	;0 APR
	SETZ			;4 PI
]
IFN KL10P,[
	400200+APRCHN,,250000	;0 APR
	SETZ 210000		;4 PI
]

DEFINE DCHENT D,W
LOC DCHNTB+D_-2
	W
	TERMIN

IFN KL10P,[
	DCHENT PAG,SETZ 240000
	DCHENT CCA,SETZ
	DCHENT TIM,SETZ 250000
	DCHENT MTR,SETZ 250000	;INTERVAL TIMER INTERRUPTS NOT CURRENTLY USED
	DCHENT 30,SETZ		;30 RESERVED
]
IFN DSDP,	DCHENT DSDEV,[REPEAT 2,400200+DSDCHN,,440000]	;20,24
IFN STKP,	DCHENT STK,[400200+LPTCHN,,440000]	;70 STK
IFN PTRP,	DCHENT PTP,[400200+PCHCHN,,440000]	;100 PTP
IFN PTRP,	DCHENT PTR,[400200+PTRCHN,,440000]	;104 PTR
IFN NOTYS,	DCHENT TTY,[400200+TTYCHN,,40000]	;120 TTY
IFN OLPTP,	DCHENT OLPT,[400200+LPTCHN,,440000]	;124 OLPT
IFN 340P,	DCHENT DIS,[630600+DISCHN+SDCHN_9,,440001]	;130 DIS
IFN E.SP,	DCHENT DIS,[400200+DISCHN,,440000]		;130 E&S
IFN KL10P,	DCHENT DTE,[400200+APRCHN,,240000]
IFN RP10P,	DCHENT DPC,[400200+DSKCHN,,440000]	;250 DPC
IFN RH10P,	DCHENT DSK,[400200+DSKCHN,,040000]
IFN NDLTYS,[	DCHENT DLB,SETZ 240000
		DCHENT DLC,[400200+TTYCHN,,240000]
]
IFN NUNITS,[
IFE NEWDTP,[
		DCHENT DC,[400000,,440000]	;200 DC
		DCHENT UTC,[400200+UTCCHN,,440000]	;210 UTC
		DCHENT UTS,[SETZ 40000]		;214 UTS
]
IFN NEWDTP,[
		DCHENT DTC,[630600+UTCCHN+DCCHN_9.,,440000]	;320
		DCHENT DTS,[SETZ 40000]	;324
]
]		;END OF IFN NUNITS
IFN NMTCS,[
		DCHENT MTC,[400230+MTCCHN,,440001]	;340 MTC
		DCHENT MTS,[SETZ 40001]			;344 MTS
]
IFN MTYP,	DCHENT MTY,[400200+TTYCHN,,40000]	;400 MORTON BOX
IFN NETP,IFN DMI,DCHENT FI,[400230+NETCHN,,400000]	;424 DM IMP HARDWARE
IFN NDAP,	DCHENT 454,[400200,,760000]		;454 D/A
IFN NETP,IFE DMI,DCHENT IMP,[400200,,400001]		;460 IMP
IFN NLPTP,	DCHENT NLPT,[400200+LPTCHN,,440000]	;464 NEW LPT
		DCHENT 500,[400000,,240000]		;500 ML, DM CALENDAR
IFN ARMP,	DCHENT TIPDEV,[400200+TIPBCH,,440000]	;504 ARM TIP BREAK
IFE MCOND AI,	DCHENT 510,[400000,,360000]		;510 ANOTHER D/A??
			;DOES ANYONE KNOW WHAT DEVICE 510 IS??
IFN RBTCP,	DCHENT RBTCON,[400200+TABCHN,,440001]	;514 ROBOT CONSOLE
IFN ARMP,	DCHENT 564,[400200,,440000]		;564 ARM TACTILE SENSE
IFN OMXP,	DCHENT OMPX,[400200+OMPCHN,,440001]	;570 OMX
IFN IMXP,	DCHENT MPX,[SETZ 40001]			;574 IMX
IFN TK10P,	DCHENT NTY,[400200+TTYCHN,,40000]	;600 NTY
IFN DPKPP,	DCHENT DPK,[400200+TTYCHN,,40000]	;604 DATAPOINT KLUDGE
IFN DC10P,[
		DCHENT DC0,[400200+DSKCHN,,4000]	;610 DC0
		DCHENT DC1,[400000,,]	;614 DC1
]
IFN VIDP,	DCHENT NVDX,[REPEAT 4,400200+NVDCHN,,440001]	;620-634 BAT
IFN PLTP,	DCHENT PLT,[400200+PLTCHN,,440000]	;654 PLT
		DCHENT 704,[400000,,440000]
IFN HCLKP,[
		DCHENT CLK1,[400200,,240000]		;710 CLK1
		DCHENT CLK2,[SETZ 40000]		;714 CLK2
]
LOC DCHNTB+127.
EBLK
DCHNTC:	BLOCK 128.
CHSPUR:	BLOCK 8	;NUM OF SUPRIOUS INTS PER CH (ZERO = DCHK)
DCACS:	BLOCK 20	;SAVE ACS
CCSDEV:	0	;+ => SOME SUSPICIOUS DEVICES
BBLK

DCHK:	0	;TO CALL FROM DDT
	MOVEM 17,DCACS+17
	MOVEI 17,DCACS
	BLT 17,DCACS+16
	MOVEI J,0
	JSP E,SPUR
	SKIPN W
	AOS DCHK
	MOVEI 17,DCACS
	BLT 17,17
	JRST @DCHK

;CHECK FOR CLOBBERED DEVS, CALL WITH JSP E,
CHECK:	JSP H,DCSTUP
CHECK1:	SKIPL TT,DCHNTB(I)
	JRST CHECK4	;UNKNOWN DEVICE
IFN DSDP,[
	TRNN TT,77
	JRST CHECK2
	ANDI TT,77
	JSP H,DCCONI
	LSH B,-1(TT)
	JUMPGE B,CHECK4
	MOVE TT,DCHNTB(I)
]
CHECK2:	JSP H,DCCONI
	TLNN TT,200	;SKIP IF PI TO TEST
	JRST CHECK4
	LDB T,[250400,,TT]	;GET SKIP
	MOVEI Q,7
	LSH Q,(T)
	AND B,Q
	LDB Q,[220300,,TT]	;GET CHANNEL
	LSH Q,(T)
	CAME B,Q
	JRST CHECK5
CHECK3:	LSH TT,-9	;SHIFT TO PIA2
	JRST CHECK2

CHECK5:	JUMPN B,CHECKL	;JUMP IF NONZERO AND WRONG
	TRNE TT,400000	;SKIP IF CAN NOT BE ZERO
	JRST CHECK3	;ZERO OK
	JRST CHECKL

CHECK4:	ADD A,[400,,]	;INCREMENT DEVICE CODE
	AOBJN I,CHECK1
SPURCX:	SKIPE C
	JRST 4,.+1	;BIT STUCK ON IN I/O BUS?
	MOVSI T,SCLCK5
	SKIPE W		;SKIP IF NO TROUBLE DETECTED
	IORM T,SUPCOR
	JRST (E)

DCSTUP:	MOVE A,[CONI B]	;SET UP
	MOVEI W,0
	MOVNI C,1
	MOVSI I,-128.
	JRST (H)

DCCONI:	XCT A
	AND C,B
	SKIPL DCHNTC(I)	;SKIP IF DEVICE ALREADY SUSPICIOUS,SAVES FIRST SUSPICIOUS
	HRRM B,DCHNTC(I)	;STORE AWAY CONI
	JRST (H)

CHECKL:	JSP H,DCSAOS
	MOVSI T,600000	;CLOB
	IORM T,DCHNTC(I)
	JRST CHECK3

DCSAOS:	MOVE D,A	;MAKE A CONO
	TDZ D,[40,,-1]
	SKIPL T,DCHNTB(I)	;SKIP IF KNOWN DEV
	JRST DCSAS2	;JUST RESET UNKNOWN TO ZERO
	TLNE T,200000	;SKIP IF NO PIA2
	TLNE T,400	;SKIP IF PIA2 CAN NOT BE ZERO
	JRST DCSAS1
	LDB TT,[330300,,T]	;GET PIA2
	LDB T,[360400,,T]	;GET PIA2 SHIFT
	LSH TT,(T)
	IOR D,TT		;ADD CORRECT CANNEL TO CONO
	MOVE T,DCHNTB(I)	;SKIP IF NO PIA1
DCSAS1:	TLNE T,200	;SKIP IF PIA1 CANNOT BE ZERO
	TRNE T,400000
	JRST DCSAS2
	LDB TT,[220300,,T]	;GET P1A 1
	LDB T,[250400,,T]	;GET PIA 1 SHIFT
	LSH TT,(T)		;OR IN PIA 1
	IOR D,TT		;ZAP
DCSAS2:	XCT D
	HLRZ T,DCHNTC(I)
	TLNN T,300000
	AOS W	;THIS MAY BE THE CAUSE OF OUR TROUBLES
	ANDI T,777
	AOS T
	AOS CCSDEV
	CAILE T,777
	SOJA T,[JRST 4,.+1]	;LOSEY LOSEY
	DPB T,[221100,,DCHNTC(I)]
	JRST (H)

;CHANNEL IN J SPURIOUS INTERRUPT ON, CALL WITH JSP E,
SPUR:	SKIPL J
	CAIL J,10
	JRST 4,SPUR1
	AOS U,CHSPUR(J)
SPUR1:	MOVE U,E
	JSP E,CHECK
	MOVE E,U
	JSP H,DCSTUP
SPUR2:	SKIPGE TT,DCHNTB(I)
	JRST SPUR4
	JSP H,DCCONI
	JUMPGE B,SPUR4
	JSP H,DCSAOS
	MOVSI T,500000
	IORM T,DCHNTC(I)
	DPB J,[360300,,DCHNTC(I)]
SPUR4:	ADD A,[400,,]
	AOBJN I,SPUR2
	JRST SPURCX

SUBTTL PC LSR TEST FEATURE

;CALLED BY PCLT MACRO
;WHICH ASSEMBLES
;SKIPE PCLDBM
;PUSHJ P,PCLTST

PCLTST:	PUSH P,U
	MOVE U,PCLIDX
	MOVEM U,PCLHT
	MOVE U,USER
	CAME U,PCLUSR
	JRST POPUJ
PCLX:	CAIA	;PATCH IN OTHER CHECKS (SHOULD JRST POPUJ TO IGNORE)
	MOVE U,USER	;PATCH ROUTINE MAY CLOBBER U
	AOSN PCLNXT
	JRST PCLT1	;FOUND PLACE, CAUSE PCLSR
	HRRZ U,-1(P)
	CAME U,PCLL
	JRST POPUJ	;NOT MARK (NOT AT RIGHT LOCN)
	HRRO U,USER	;4.9 U FLAG 
PCLT1:	PUSH P,A	;COMPUTE HASH ADR OF RETURNS ON PDL
	PUSH P,B
	PUSH P,C
	HRREI A,-USRSTG(P)
	JUMPL A,PCLT1A	;SYS JOB'S PDL?
	IDIVI A,LUBLK
	IMULI A,LUBLK
	MOVEI A,USRPDL(A)	;GET START OF USERS PDL IN A
PCLT3:	HRRZ B,(A)
	JUMPE B,PCLT2
	CAIL B,HSYSCD
	JRST PCLT2
	HLRZ C,-1(B)
	TRZ C,37
	CAIE C,(PUSHJ P,)
	JRST PCLT2
	XOR B,PCLHT
	ROT B,1
	MOVEM B,PCLHT
PCLT2:	CAIGE A,-2-3(P)
	AOJA A,PCLT3
	MOVE A,PCLHT	;COMPUTED HASH
	JUMPGE U,PCLT4	;GOING TO PCLSR HERE, STORE HASH AS MARK FOR NEXT TIME
	CAME A,PCLHSH
	JRST PCLT5
	SKIPGE PCLDBM
	JRST PCLT6	;IN HOLD MODE, PCLSR HERE
	SETOM PCLNXT	;FOUND MARK, PCLSR NEXT TIME
PCLT5:	POP P,C
	POP P,B
	POP P,A
	JRST POPUJ

PCLT4:	MOVEM A,PCLHSH	;STORE HASH FOR NEXT TIME
	HRRZ A,-3-1(P)
	MOVEM A,PCLL
PCLT6:	CONO PI,CLKOFF
	MOVE B,PCLDBM
	MOVEI A,%PIC.Z
	CAIN B,1	;DON'T ^Z.
	IORM A,PIRQC(U)
	POP P,C
	POP P,B
	POP P,A
	POP P,U
	JRST PCLME

	PUSHJ P,PCLME1
PCLME:	PUSHJ P,UFLS
	JRST 4,.

PCLME1:	PUSHJ P,PCLSR
	JFCL
	JRST POPJ1

PCLT1A:	TRNE U,-1
	JRST 4,.
	JRST 4,.	;TEMP MODIFY END CHECK IF WANT TO WIN FOR SYS JOB

SUBTTL ILLUO NON-RELEVANT SYSTEM CALLS
IFE E.SP,[
	ADSTEP==URET
	ADCONT==URET
	ADWORD==URET
]
IFE 340P\E.SP,[
	ADSTAR==URET
	ADCLOS==URET
	ADSTOP==URET
	ADSTL==URET
]
IFE 340P,[
	ALTPEN==URET
	ANDIS==URET
]
IFE VIDP,[
	AVSCAN==ILUUO
	AVSTST==ILUUO
]
IFE IMXP,[
	APOTSET==ILUUO
]
IFE PDP6P,[
	AIPDP==ILUUO
]
IFE NMTCS,[
	AMSPAC==ILUUO
]

IFE ARMP,[
	AARMOV==ILUUO
	AARMRS==ILUUO
	AARMOF==ILUUO
]
IFE PTRP,[
	AFEED==CPOPJ
]
IFE RBTCP,[
	ARBTC==ILUUO
]
IFE NETP,[
	ANETAC==CPOPJ
	ANETS==CPOPJ
	ANETIM==OPNL1	;NO SUCH DEVICE ERROR FOR SYMBOLIC SYSTEM CALLS.
	ANETBL==OPNL1
	ANETHS==OPNL1
	ANETIN==CPOPJ
]

IFE NUNITS,[
	AUBLAT==URET
	AUTNAM==URET
	AUINIT==URET
	AUDISM==URET
	AASSIGN==URET
	ADESIGN==URET
]

HSYSCD:		;HIGHEST SYSTEM CODE

SUBTTL RANDOM STORAGE
EBLK

NUINX:	0	;"NUMERIC INDEX" OF LAST USER PGLD'ED
SCHHP:	SCHHB	;PNTR TO SCHED HIST BUFFER
SCHHB:	BLOCK SSCHDB	;SCHED HIST BUFFER
			;4.9 =1 EXEC
			;4.8 =1 QUANT TERMINATED BY PG FAULT
			;4.7--3.7  LENGTH OF RUN TIME IN 64 USEC UNITS
			;3.6-3.1 USER ("NUMERIC INDEX)
			;RH PC QUANT STARTED AT
SCHMNY:	0	;FLAG AS TO IF A SECOND BEST PERSON SHOULD BE SCHEDUALED
IFN SCHBLN,[
SCHBPT:	-SCHBLN,,SCHBTB
SCHBTB:	REPEAT SCHBLN,-1
]
;TRANSLATION ENTRY _ T
;TRANLK(T) IS  MODE,,NEXT ENTRY
;MODE IS 0 IF ENTRY ON FREE LIST, ELSE NOT 0, AND
 ;BITS 3.1 => INPUT, 3.2 => OUTPUT, 4.9 => ATOMIC TRANSLATION (DON'T RETRANSLATE)
;NEXT-ENTRY IS -1 FOR NIL, ELSE IDX REL TRAN!X
;TRANID(T) THRU TRANIS(T) - FROM-NAMES
;TRANOD(T) THRU TRANOS(T) - TO-NAMES

TRANLK:	REPEAT SIOMT,,,.RPCNT-1	;GENERATE 1ST WDS, LINKED TOGETHER.
TRANID:	BLOCK SIOMT
TRANI1:	BLOCK SIOMT
TRANI2:	BLOCK SIOMT
TRANIS:	BLOCK SIOMT
TRANOD:	BLOCK SIOMT
TRANO1:	BLOCK SIOMT
TRANO2:	BLOCK SIOMT
TRANOS:	BLOCK SIOMT

TRANFL:	SIOMT-1		;TRANSL ENTRY FREE LIST.
TRNCNT:	0		;NUM ENTRIES IN USE.
TRNREF:	0		;NUM. READ-ONLY ACCESSES TO TRANSL LISTS.
TRANSW:	-1		;SWITCH FOR WRITE REF.
	0

U0P:	0	;PRIORITY OF BEST USER SO FAR
U0PP:	0	;JTMU OF ABOVE

USER:	-1	;USER # OF CURRENT LOSER
SYSL:	SYSB*2000
LITM:	0	;LAST TIME SYS INCREASED CORE
STTY:	21,,(SIXBIT /T00/)	;OPEN IN "DISPLAY MODE"

SLGIV:	BLOCK 3	;LOGIN

SETSLC:	0	;SETLOC VARIABLES
SETSLQ:	0
SETSU:	-1

SWUNAM:	0	;SYS WRITE VARIABLES
SWJNAM:	0
SWFN1:	0
SWFN2:	0
SWFN3:	0
SWMOD:	0

DMON:	SIXBIT /DRAGON/
DMONX:	-1	;USER INDEX OF DEMON JOB

NQMFWR:	0	;COUNT OF FILES WRITTEN ON .MAIL. - FOR MAILER DEMON TO HANG ON.

;DEAMON VARIABLES
;VARIABLES FOR DEAMON CODE HACK
IFN DEMON,[

IFN TTLPTP,TPLFLG: 1	;FLAG FOR TPL

DMTLL==4	;LEGNTH OF DEAMON TABLE SLOT
NODEAM==20.	;NUMBER OF SLOTS
DMLNG==NODEAM*DMTLL

DEMSW:	0
	0	;MAIN PROG SWITCH FOR DEMON
REQCNT:	1	;COUNT OF REQUEST'S FOR SYS JOB
DMTPTR:	0	;POINTER FOR DEMSIG TO DEM TBL, AN INDEX INTO IT, TAKEN MODULO DMLNG
DMLSEX:	-DMLNG,,0	;POINTER TO DEAMON TABLE AOBJN
DEMCNT:	<NODEAM.-1>	;AMOUNT OF SLOTS REMAINING IN THE TABLE

DMBLK:	0
	0	;SLOT FOR NON DEAMON LOAD VIA NUJBST

DMOBLK:	SIXBIT /   SYS/
	SIXBIT /ATSIGN/
	0	;BLOCK USED BY SYSTEM JOB TO CHECK OPEN

;DEAMON TABLE--CONSISTS OF SLOTS OF FOUR WORDS FOR EACH DEMON
;WORD 1 CONTAINS ITS SIXIT NAME
;WORD 2 CONTAINS THE USER INDEX,-1 IF LOADING, 0 IF DOWN
;WORD 3 2 QUANTITIES IN 18 BIT 2'S COMPLEMENT--
;LH ALWAYS > = 0, IF 0 ONLY TAKES EXPLICIT REQUESTS IN > 0 A REQUEST
;RH CONTAINS THE NUMBER OF REQUESTS PENDING FOR THE DEAMON
;FOR THE DEAMON WILL BE GENERATED EVERY 2 MINUTES
;WORD 4 CONTAINS THE TIME TILL THE NEXT IMPLICIT REQUEST WILL BE GENERATED.


DMTTBL:	 SIXBIT /DEMSTR/
	0
	1	;STARTUP DEAMON
	0
	
BLOCK <NODEAM-1>*DMTLL	
]
TIMOFF:	-1	;TIME SINCE MIDNIGHT IN HALF SECONDS ("TIME IN DSK FORMAT").
QDATE:	-1	;DISK FORMAT DATE: -1 => SYSTEM DOESN'T KNOW DATE, ELSE
		;BITS 3.1-3.5 HAVE DAY OF MONTH, 3.6-3.9 HAVE MONTH OF YEAR,
		;4.1-4.7 HAVE YEAR MOD 100. .
QDATEI:	-1	;-1 => SYSTEM DOESN'T KNOW DATE, ELSE
		;DATE AND TIME THE DATE AND TIME WERE FIRST DETERMINED, IN DSK FORMAT.
JDATE:	-1	;NUMBER OF DAYS ELAPSED SINCE MARCH 1,0000
		;NOTE: "JULIAN DAY NUMBER" = C(JDATE)+1721120.
PDYTIM:	-1	;TIME SINCE BEGINNING OF YEAR IN HALF-SECONDS (BACKUP TO PDCLK)
FYEAR:	0	;YEAR (E.G. 1969.)
PDTIME:	0	;NON-ZERO => OFFSET FOR PDCLK
		;WHEN SUBTRACTED FROM PDCLK DATAI GIVES # PD-UNITS SINCE BEGINNING OF YEAR
		;ONE SECOND = 60. PD-UNITS

SUPCOR:	SCLDAT+IFN DEMON,[SCLDMN],,SCRCKS	;CONTROLS SYS JOB, SEE SYSDTB, SCOR, ETC
		;EACH BIT REQUESTS ONE FUNCTION IF SET.
SCKPHS:	0	;USED FOR COUNTING EVERY OTHER 1/2 SECOND CLOCK
		;TO SET SCRCKS EVERY SECOND

LNETIM:	0	;TIME AT WHICH NETWORK WAS LAST BROUGHT UP

MXPARS==40
PARPG:	BLOCK 8	;STORAGE OF PAGE MAP WHILE HACKING PARITY ERROR CHECK
PARCNT:	0	;# OF PAR ERROR ENTRIES IN TABLE
PARCON:	BLOCK MXPARS	;CONTENTS OF BAD PARITY LOCATIONS
PARADR:	BLOCK MXPARS	;ADDRESSES OF BAD PARITY LOCATIONS
PARAND:	-1		;QND OF ALL BAD WORDS
PARIOR:	0		;IOR OF ALL BAD WORDS
PARAAN:	-1		;AND F ALL BAD ADDRS
PARAOR:	0		;IOR OF ALL BAD ADDRS
IFN KL10P,[
PARPFW:	0		;PAGE FAIL WORD
PARERA:	0		;ADDRESS OF PAR ERR
PARWRD:	0		;BAD DATA
PARRSN:	0		;0 => PAR ERR PAGE FAULT IN PROG
			;-1 => PAR ERR INTERRUPT; NEEDN'T STOP
			;THE RUNNING JOB.
]
PARDIE:	0	;-1 => FATAL PARITY ERROR
TPLSWP:	0	;-1 => USE OLP FOR TPL
IFN PDP6P,[
PDP6UP:	-1	;0 => PDP6 IS DOWN.
]
IFN TEN11P,[
TEN11F:	0	;0 -> NORMAL
		;-1 -> COMPLETELY IGNORE 10-11 INTERFACE
		; 1 -> RESET 10-11 INTERFACE, OTHERWISE IGNORE
T11ERC:	0	;COUNT OF CONTROL PAGE RAM ERRORS
T11CCN:	0	;CORRECT CONTENTS
T11WCN:	0	;WRONG CONTENTS
T11PG:	0	;PAGE # INVOLVED
]
IFN N11TYS,[
TVBLAD:	17743	;VIDEO BUFFER TO FLASH WHEN JOB RUNNING (PDP10 VIDEO BUFFER ADDR)
]
IFN DL10P,[
DL10F:	-1	;-1 NORMAL, 0 => 11 DOWN
DL10HC:	0	.SEE TTDLBRK ;NUMBER OF LOOPS WHEN HUNG UP WAITING FOR 11 TO GOBBLE BUFFER
]

DLSRCH:	0	;-1 => DON'T RUN ANY USER BUT THE ONE ALREADY RUNNING
		;(UNLESS WE TAKE A PAGE FAULT).
CPDLP:	-CPDLL,,LCPDL-1	;CLOCK PDL POINTER
LCPDL:	BLOCK CPDLL	;CLOCK INT LEVEL PDL
CLROOT:	SSLCKB	;CLOCK QUEUE ROOT
SSLCKB:	SCLKI	;SLOW CLOCK RQ BLOCK
	15SCLB
	JRST SSLCK
15SCLB:	15.*60.-SCLKI
IFN SWBLK,	VSLCKB
IFE SWBLK,	PRVCLB
	JRST 15SCLK
IFE SWBLK,[
PRVCLB:	NPVSEC*60.-15.*60.-SCLKI	;PRIVILEDGED USER VARIABLE CHECK
	VSLCKB
	JRST PRVCLK
VSLCKB:	0	;VERY SLOW CLOCK BLOCK
]
IFN SWBLK,VSLCKB:	0	;VERY SLOW CLOCK BLOCK
	CLINFB			;CAUSE SLOW CLOCK TICK SOON AFTER SYS COMES UP
	JRST VSSLCK
CLINFB:	377777,,-1	;ABOUT 15 YEARS
	0
	JRST 4,.	;?
IFN CCLKP,[
CCLKB:	0	;FOR CHESS CLOCK HACK
	-1
	JRST RCCLK
CCLK1:	0
CCLK2:	0
]

IINTIC==60.	;# TWO-MINUTE TICKS PER VERY VERY SLOW CLOCK TICK (2 HOURS)
IINCNT:	0	;# TWO-MINUTE TICKS REMAINING UNTIL NEXT VERY VERY SLOW CLOCK TICK
.SEE VSCLK

IFN N11TYS,[
WHOCLB:	0	;WHO LINE TIMER
	-1
	JRST WHOSET
]

UTTYS:	BLOCK MXCZS	;RING BUFFER FOR JOBS TO BE STARTED
UTTYI:	UTTYS
UTTYO:	UTTYS
UTTYCT:	0

PCLDBM:	0	;.NE. 0 ACTIVATE PC LSR DEBUG MODE
			;1 => ADVANCE PLACE WHERE PCLSR
			;2 => ADVANCE BUT DON'T ^Z.
			;- HOLD
PCLUSR:	-1	;USER PCLSR MODE ACTIVE FOR
PCLL:	0	;PLACE WHERE LAST PCLSR TESTED
PCLHSH:	0	;HASH OF RETURNS ON PDL AT LAST PLACE TRAPPED OUT OF
PCLNXT:	-1	;-1 => FROB NEXT TIME IN ADVANCE MODE
PCLHT:	0	;TEMP
PCLIDX:	0	;INITIALIZE PCLT TO THIS (SET TO LOOP COUNT IF NECESSARY)

CORRNR:	0	;LAST USER TO RUN CORE
SJSPG:	0	;-1 => LAST FREE PG RESERVED FOR SYS JOB; DON'T GIVE IT TO ANYONE ELSE.
UTRMF:	0	;-1 MOVING IO BUF BLOCK 0 FLUSHING CORE
UTBFLF:	0	;-1 SIGNAL TO TRY TO FLUSH I/O BLOCKS
UFDFLF:	0	;-1 SIGNAL TO TRY TO FLUSH 2311 UFDS
CORCNT:	0
UFLSF:	0	;FLAG FROM UFLS TO CLKBRK
CLKFL1:	0	;FLAG COUNTER TO CONTROL CLOCK LEVEL 
SCHFLG:	0	;SCHEDULE TIMER (DIVIDES 60 CPS)
27FCLK:	0	;-1 IF FAST CLOCK SHOULD CALL TYP27S
SCITM:	0	;SEE SYSEX, SYSDEC
LQTIM:	0
LCLK1:	0
SYSCKP:	-LTSTB,,TSTB	;SYSTEM CHECKSUMS CHECKER POINTER
SYSPDP:	-LSYSP,,SYSPDL-1	;PDL POINTER FOR SYSTEM JOB
SYSPDL:	BLOCK LSYSP	;PDL FOR SYS JOB
IFN TPLP,TPLBUF:	BLOCK TPLBSZ	;PSEUDO LPT BUFFER - MUST BE ABOVE SUACS
IFN TPLP\DEMON,TPLFNO:	SIXBIT /!/	;UNIQUE TPL FIRST FILE NAME
SJCFF:	0	;-1 WHEN SYS JOB IN PROCESS OF FLUSHING CORE
			;AVOIDS TIMING ERROR DUE TO HUSRAD NOT REALLY REFLECTING WHAT ITS GOING TO BE

SWUDI:	0	;-1 IF SWAP USER DIR IN AND ITS QSNNR AOSED EXTRA TIME
LUFNAL:	0	;LAST NON ZERO UFINAL HACKED
LUFNLU:	0	;USER LAST UFINALED
SLSWPR:	0	;STORE SYS JOB'S LSWPR WHILE HACKING UUOS

BBLK
CONSTANTS
IFN TPLP,	TPLFN:	2,,(SIXBIT /TPL/)
IFN KL10P,[
KLEBCC:	0 ? <1_23.>/<4*25./2>	;EBOX COUNTER CONVERSION TO 4 USEC CONSTANT (FOR 25 MHZ)
		;RESULT IS IN AC+2 AFTER DMUL AC,KLEBCC
KLMBCC:	1 ? 110000,,		;FOR CONVERTING AN MBOX COUNT TO THE TIME (IN EBOX UNITS)
				;IT SUPPOSEDLY AMOUNTS TO.
				;WE ASSUME 102.5 NANOSEC OD WAITING TIME PER MBOX CYCLE
				;THIS NUMBER IS 102.5/80.
				;DMUL AC,KLMBCC PUTS ANSWER IN AC+1, AC+2
				;WITH BINARY POINT BETWEEN THE WORDS.

MTRUSR:	-1		;USER TO WHOM PERF CTR IS ASSIGNED
MTRJOB:	-2		;USER BEING MEASURED BY PERF CTR,
			;OR -1 => NULL JOB, OR -2 => ALL JOBS.

PAEON:	0		;SELECTED PERF CTR ENABLE WORD
PAEOFF:	0		;DISABLE THE PERF CTR (WHEN WRONG JOB IS RUNNING)
]
EBLK
IFN TPLP,[
TPLFN1:	0
TPLFN2:	0
TPLFN3:	0
]
VARIABLES


TSTB:	REPEAT CKNUM,CONC CK,\.RPCNT,
LTSTB==.-TSTB

CKSUMS:	BLOCK CKNUM
CKXORS:	BLOCK 36.	;XOR OF ALL ADRS IN PURE AREAS IN SYS WITH CORRESP
		;BIT SET (RH)
TCKXOR:	BLOCK 36.	;TEST XORS

SSYSCL==SSYS
SYSCLB==SSYSCL_-10.+IFN 1777&SSYSCL,1

IFN KL10P, AC1PTR: UUOACS	;-> WHERE AC BLOCK 1 IS CURRENTLY LOADED FROM

USRHI:	0	;HIGHEST LOC USED FOR USER STORAGE

SUBTTL LOCATIONS TO PATCH WHEN DEBUGGING

SYSDBG:	0	;0 NORMAL TIMESHARING
		;+ GIVE "ITS BEING DEBUGGED" MESSAGE
		;-N ALSO ALLOW ONLY CONSOLE #N AND T00 TO CTRL/Z.
		;-512.*N => ALLOW ONLY HOST N TO TELNET IN.
		;-512.*N+M => ALLOW HOST N AND TTY M.
DMLLDF:	-1	;-1 => START DAEMONS AUTOMATICALLY, 0 DON'T.
IFN DEMON,DMNFLG: 1  ;1 => START DM-STYLE DAEMONS, 0 DON'T.

SYSCN:	SYSCON	;NUMBER OF TTY TO RECEIVE SYSTEM CONSOLE OUTPUT.
		;-1 TO THROW IT AWAY.  YOU CAN CHANGE THIS ANY TIME.

IFN NETP,NETUSW: 0 ;-1 => DON'T START UP A JOB IN ANSWER TO ICP
		;FROM A HOST OTHER THAN OURSELVES

.SEE USEHM	;NONZERO => USE HIGH MOBY, ELSE ONLY 256K

.SEE USEMDM	;NONZERO => USE MEDIUM MEMORY AS ADDITIONAL "LOW HALF" PAGES

IFN N11TYS,[
TT11P:	1	;0 => PDP11-TTYS ARE NOT IN USE
		;1 => SYSTEM SHOULD INITIALIZE THEM
		;-1 => INITIALIZED AND IN USE
		;TO BRING THE TV'S DOWN, ZEROING TT11P ISN'T ENOUGH
		;EITHER DO WHAT TT11LS DOES, OR JUST SET SCR11D IN SUPCOR
		;(THE LATTER MAY NOT TAKE EFFECT INSTANTLY, HOWEVER)
		;TO BRING THE TV'S UP, JUST SET TT11P TO 1 AND WAIT 2 SECONDS
]

SUBTTL SYSTEM LOCKS

CIRPSW:	-1	;CIRCULAR POINTER SWITCH
	0

MEMFRZ:	-1	;MEMORY FROZE
	0

CASW:	-1	;CORE ALLOCATE INTERLOCK SWITCH (REQUESTS TO CORE JOB)
	0

SJDH:	-1	;INTERLOCK BETWEEN CORE JOB AND SYS JOB RE DISK HACKING
	0

SHUTLK:	-1	;LOCK VAR FOR SHUTDN
	0	;USED TO TELL WHO CAUSED SYS DOWN

TREESW:	-1	;LOCK MANIPULATION OF JOB TREE STRUCTURE
	0	;ATTACH, DETACH, DISOWN, REOWN ALL LOCK.

CUSER:	-1	;CORE ALLOCATOR USER
	0	;DUMMY CORE ALOC USE VAR

IFN 340P\E.SP,[
DISUSR:	-1	;340 USER
	0	;DUMMY 340 USE VAR
]

IFN CODP,[
CODUSR:	-1	;CODE SENDER
CODUSE:	-1
]

IFN PLTP,[
PLTUSR:	-1	;PLOTTER USER
PLTUSE:	-1
]

IFN LPTP\TTLPTP,[
LPTUSR:	-1	;LINE PRINTER USER
LPTUSE:	-1
]
IFG LPTP-1,[
OLPUSR:	-1
OLPUSE:	-1
]
IFN LPTP,[
  IFE LPTP-1,[
    IFN NLPTP,[
	NLUSR==LPTUSR
	NLUSE==LPTUSE
    ]
    IFN OLPTP,[
	OLUSR==LPTUSR
	OLUSE==LPTUSE
    ]
  ]
  IFG LPTP-1,[
    OLUSR==OLPUSR
    OLUSE==OLPUSE
    NLUSR==LPTUSR
    NLUSE==LPTUSE
  ]
]

IFN PTRP,[
PTPUSR:	-1
PTPUSE:	-1

PTRUSR:	-1
PTRUSE:	-1
]

IFN VIDP,[
NVDUSR:	-1
NVDUSE:	-1
]

IFN PDP6P,[
PDPUSR:	-1	;PDP-6 USER
PDPUSE:	-1
PDPISR:	-1	;PDP6 AS INFERIOR (INTS ON IO CHANNEL)
PDPISE:	-1	;PDP6 USE VAR
]

IFN TABP,[
TABUSR:	-1	;TABLET USER
TABUSE:	-1
]

IFN STKP,[
	STKUSR:	-1
	STKUSE:	-1
]

MEMFR:	SYSUSM-1	;MEMORY FREE
TIME:	0	;TIME SINCE SYSTEM START IN 1/30'THS
SUSRS:	0	;NUMBER USERS ON SYS
USRRCE:	BLOCK NCT+1	;USER RESOURCE +1 FOR DISOWNED JOBS
SYSRCE:	0	;SYS JOB RESOURCE
RNABLU:	0	;RUNNABLE USERS
LOUTIM:	0	;TOTAL TIME USED BY LOGGED OUT USERS
UMASTER:	-1	;INDEX OF MASTER USER

SWRCE:	BLOCK NCT+2	;SWAP SCHED RESOURCE
SWIPRQ:	0	;TOTAL # SWAP IN REQUESTS
SHUTDN:	0	;"TIME" SYS WILL DIE, 0 IF NOT DYING, -1 IF DEAD
DEDTIM:	0	;TIME TILL DEATH AFTER NEXT CLK QUEUE INT
		; < 0 => SYSTEM ACTUALLY DOWN
		;(CHECKED BY ^Z AND DRAGON AND NUJBST)
DEDBLK:	0
	-1
	JRST DEATHZ

ATRNJN:	0	;JNAME OF LAST JOB TO DO A .TRANAD OR .TRANDL
		;(SO I CAN SEE IF THEY'RE USED AT ALL).

NCORRQ:	0	;NUMBER CORE RQS HERE SO TRANSFERRED TO PEEK
NCBCOM:	0	;NUMBER CORE BLOCKS COMMITTED

NQDE:	BLOCK NQS	;NUMBER OF 2314 DATA ERRORS
NQHE:	BLOCK NQS	;NUMBER OF 2314 HARDWARE ERRORS
NQSE:	BLOCK NQS	;NUMBER OF SPURIOUS 2314 ERROR INTERRUPTS
NQCMPE:	BLOCK NQS	;NUMBER OF 2314 READ/COMPARE ERRORS
NQWDE:	BLOCK NQS	;# DATA ERRS ON WRITE
NQRDE:	BLOCK NQS	;# DATA ERRS  ON READS
NIRSWE:	0	;# IRRCV ERRS ON  SWAPPING XFERS
QIRCBK:	0	;BLOCK # W/ IRRCV ERROR
QIRUNT:	0	;UNIT OF ABOVE
NQWRE:	0	;# WRITE ERRS RCC OK
NQWIRE:	0	;# WRITE ERRS RCC LOST
NWXFR:	0	;NUMBER WRITE TRANSFERS (FILE, DIR, ETC.)
NRXFR:	0	;NUMBER READ
NSWXFR:	0	;NUMBER WRITE SWAPS
NSRXFR:	0	;NUMBER READ SWAPS

PARERR:	0	;COUNT OF CORE PARITY ERRORS
NXMERR:	0	;NXM
PARPC:	0	;PC ON CORE PARITY INTERRUPT
NXMPC:	0	;NXM
PARUSR:	-1	;USER ON PAR ERR
NXMUSR:	-1	;USR ON NXM

SNMPGS:	0	;SYSTEM, NUMBER OF VIRTUAL USER PAGES
SNSWPG:	0	;SYS, NUM OF SWAPPED OUT VIR. PGS

USRTM1:	0	;4USEC TICKS USED BY USERS SINCE LAST (1/2 SEC) UPDATE TO USRTIM
USRTIM:	0	;TIME USED BY ALL USERS 1 SEC UNITS

NULTM1:	0	;# USECS USED BY NULJOB SINCE LAST (1/2 SEC) UPDATE TO NULTIM
NULTM2:	0	;# OF TIMES NULJOB STARTED (OLD NULTIM)
NULTM3:	0	;NUMBER OF SECONDS USED BY NULJOB FOR DRAGON
NULTIM:	0	;TIME USED BY NULL JOB (60'THS)
IFN KL10P,[
NULEBC:	0 ? 0	;EBOX COUNT WHEN NULL JOB ENTERED
NULMBC:	0 ? 0	;MBOX COUNT WHEN NULL JOB ENTERED
PFAILF:	0	;-1 => ENTRY TO CLOCK LEVEL WAS VIA PFAIL, SO CLKCHN IS OFF, NOT IN PROG.
]

UREALT:	-1	;RH=INDEX OF THE REAL TIME USER
		;LH=0=> THIS USER HAS HIGHEST PRIORITY
		;LH>0=> USER NOT IN HIGH PRIORITY PHASE
		;LH<0=> FACILITY IDLE
QIRRCV:	0	;IRRECOVERABLE DISK ERRORS
SJBRES:	0	;-1 => BLOCK IN LOWER HALF RESERVED FOR SYS JOB
IFN DPKPP,	NDPKPE:	0	;# PARITY ERRS FROM DATAPOINT KLUDGE

INFORM [HIGHEST USED]\<.-1>

SUBTTL USER VARIABLES

;ONE COPY FOR EACH PROCEDURE
;FOR KL-10, THIS IS THE UPT

IFN KL10P,[
DEFINE KLUPT N,NAME/		;CHECKS "HARD-WIRED" UPT LOCATIONS
IFN .-USRSTG-<N>, .ERR "NAME" LOST IN UPT
.ALSO LOC USRSTG+<N>
TERMIN

LOC <.+777>&-1000
]		;END OF IFN KL10P
IFE KL10P,[
DEFINE KLUPT N,NAME/
TERMIN
]

USRSTG==.				;BEGINNING OF USER STORAGE

KLUPT 0,;USER PAGE MAP

UPGMP:	REPEAT 200,600000+PMCSHM+.RPCNT*2,,600000+PMCSHM+<.RPCNT*2+1>	;ONE HALFWORD PER PAGE
;	BLOCK NUVPG/2	;PAGE MAP STORAGE (PROGRAMS UP TO NUVPG LONG)
;		2.9-2.8	ACCESS RIGHTS
;			00	NO ACCESS (BY SOFTWARE CONVENTION, 1.2-1.1
;				HAVE THE "REAL" ACCESS BITS, WHICH MAY BE 00,
;				BUT MAY NOT, E.G. FOR A SWAPPED OUT PAGE).
;			01	READ ONLY
;			10	READ/WRITE/FIRST
;			11	READ/WRITE
.SEE PMCSHM	;CACHE BIT (KL-10 ONLY)
.SEE PMAGEM	;AGE BITS
.SEE PMRCM	;LOW N BITS ARE PHYSICAL CORE PAGE NUMBER (IN 1K PAGES)
UPGCP:	BLOCK NUVPG/2	;CIRCULAR POINTERS (CORRESPONDS 1-1 WITH UPGMP)
;		IF -1, ABSOLUTE PAGE, NOT LINKED.  OTHERWISE:
;		2.9	IF 0:
;			2.8-1.9	USER INDEX
;			1.8-1.1	PAGE NUMBER IN THAT USER'S UPGCP
;			IF 1:
;			2.8	IF 0:
;				2.7-1.1	LINK TO MMP TABLE
;				IF 1:
;				2.7-1.1	LINK TO MEM PNT TABLE
UMAPS:	0	;USER MAP STATUS (M.P.)
		;0 NORMAL MAP AS IN UPR
		;4.8=1 HACK MY LOWER DBR
		;4.7=1 HACK MY UPPER DBR
		;4.6=1 TO POINT TO HIS LOWER SEG
		;4.5=1 TO POINT TO HIS UPPER SEG
		;4.4=1 MAKE MY HIGH DBR POINT TO HIS HIGH DBR AS WELL
		;4.3=1 MAKE AC'S POINT TO SWAP OUT AC'S INSTEAD OF UUO AC'S
		;RH USER OR -1 = PDP6
UDBR1:	0	;NORMAL CONTENTS OF DBR1
UDBR2:	0	;NORMAL CONTENTS OF DBR2
UCPB1:	0	;CIRC PNTR BASE DBR1
UCPB2:	0	;CIRC PNTR BASE DBR2
NMPGS:	0	;NUMBER OF NON-ABSOLUTE PAGES (INCLUDES PURE)
NSWPGS:	0	;NUMBER SWAPPED OUT PAGES (AOSED FOR EACH USER OF SHARED PAGE SWAPPED OUT)
HUSRAD:	0	;MEM ADR OF PAGE ABOVE HIGHEST THAT EXISTS (MAX 1,,0)
USWST:	0	;4.9=0 => DESIRED TO BE IN
		;   =1 => DESIRED TO BE OUT
		;4.8=1 => FLSINS IS WAITING FOR A PAGE
		;4.7=1 => USER COMPLETELY OUT OR HAVE TRIED TO FLUSH REMAINING PAGES RECENTLY
		;(I.E. DON'T TRY LOOKING AT THIS USER FOR FURTHER PAGES TO SWAP OUT)
		;4.6=1 => UNBLOCKED SWAPOUT SO CONSIDER MEM STATUS BEFORE REACTIVATION
		;4.5=1 => PAGE SWAPPED OUT WHILE BLOCKED IN EXEC MODE
		;SO WHEN FLSINS SKIPS DON'T CLEAR IT BUT PCLSR INSTEAD
		;4.4=1 => IF WAITING FOR PAGE,NEED IT TO INTERRUPT
LUBTM:	0	;TIME LAST UNBLOCKED (FOR IDENTIFYING INACTIVE JOBS)
VALUE:	0	;PROCEDURE "VALUE" RETURN

UPGML:		;USER PAGE MAP LOAD (EIGHT WORDS FOR LPM AND SPM INSTRUCTIONS)
		UPJPC:	0	;JPC.  KA HAS FAULT ADDRESS IN LH.
IFE KL10P,	UPOPC:	0	;OLD PC FLAGS,,OPC (UNUSED ON KL-10)
		UPMAR:	0,,0	;MAR ADDRESS AND CONDITION
				;FOR KA-10:
				;	3.3	0=EXEC, 1=USER
				;	3.2-3.1	MAR CONDITION:
				;		0	NEVER
				;		1	INSTR FETCH
				;		2	WRITE
				;		3	ALWAYS
				;	2.9-1.1	VIRTUAL ADDRESS
				;FOR KL-10:
				;	3.9-3.7	ADDRESS BREAK CONDITIONS:
				;		3.9	FETCH
				;		3.8	READ
				;		3.7	WRITE
				;	3.6	0=EXEC, 1=USER
				;	3.5-1.1	VIRTUAL ADDRESS
IFE KL10P,	UPQUAN:	EXPGNG+1,,0		;F.S. QUAN AND FAULT BITS
IFN KL10P,	UPFW:	0			;PAGE FAIL WORD
IFE KL10P,DBL==100_1
IFN KL10P,DBL==0
		UPDBR1:	DBL,,UPGMP		;DBR1
		UPDBR2:	DBL,,UPGMP+100		;DBR2
IFE KL10P,	UPDBR3:	DBL,,EXEUMP		;DBR3
IFE KL10P,	UPACP:	1040,,UUOACS		;B KEY,C KEY,,AC POINTER

UPGMLE::				;END OF PAGE MAP (+1)

IFN KL10P,[
	KLUPT 420,	;RESERVED UPT 420
UPT420:	0
	KLUPT 421,	;TRAP 1 INSN	;ARITHMETIC OVERFLOW
TR1INS:	JSR ILLTRP	 ;FOR ITS-STYLE INTERRUPT, CONTAINS 0,,%PIARO
	KLUPT 422,	;TRAP 2 INSN	;PDL OVERFLOW
TR2INS:	JSR ILLTRP 	 ;SYS JOB SHOULDN'T OVERFLOW	;FOR ITS-STYLE, 0,,%PIPDL
	KLUPT 423,	;TRAP 3 INSN	;USED FOR ONE-PROCEED
TR3INS:	JSR ILLTRP	 ;SYS JOB SHOULDN'T ONE-PROCEED	;FOR ITS-STYLE, 0,,%PI1PR
	KLUPT 424,	;MUUO DEPOSIT LOCATION
SV40::
MUUODP:	0	.SEE FORTY
	KLUPT 425,	;MUUO OLD PC STORAGE
SUUOH::
XUUOH:	0
	KLUPT 426,	;MUUO PAGING AND CONTEXT WORD
MUUOCX:	0
	KLUPT 427,	;RESERVED UPT 427
UPT427:	0
	KLUPT 430,	;MUUO NEW PC WORDS
MUUOKN:	%PSPCU,,UUOH0		;FOR OTHER JOBS, MUUOEX (A JRST 4,).
MUUOKT:	%PSPCU,,MUUOEX		;NO JOB SHOULD EVER TRAP IN EXEC MODE.
MUUOSN:	%PSPCU,,MUUOEX		;NO JOB SHOULD EVER RUN IN SUPERV. STATE.
MUUOST:	%PSPCU,,MUUOEX		;..
MUUOCN:	%PSPCU,,UUOH0		;NORMAL UUOS
MUUOCT:	%PSPCU,,MUUOTR		;UUOS AS TRAP INSN
MUUOPN:	%PSPCU,,UUOH0		;PUBLIC MODE IDENTICAL TO CONCEALED MODE,
MUUOPT:	%PSPCU,,MUUOTR		; ALTHOUGH IT'S A SCREW FOR A LOSER TO BECOME PUBLIC
]		;END OF IFN KL10P

UUOACS:	BLOCK 20
AC0S:	BLOCK 15	;SWAP OUT AC S
AC15S:	0
AC16S:	0
AC17S:	0

IFN KL10P,[
;KLUPT 500,	;PAGE FAIL WORD STORAGE		;MICROCODE MOD PUTS
;KLUPT 501,	;PAGE FAIL OLD PC STORAGE	; THESE LOCATIONS IN
;KLUPT 502,	;PAGE FAIL NEW PC		; THE EPT FOR ITS
]		;END OF IFN KL10P

UUO::	;THE FOLLOWING LOCATIONS (UP TO SUEXND) ARE SWAPPED IN & OUT OF UEXIT ETC. WITH THE USER
SUEXIT:	JRST 2,@XUUOH	;USER UUO EXIT INS
SCLUSV:	MOVEM U,AC17S	;CLOCK U SAVE
IFE KL10P,[
SUUOH:	0	;C(@41) (ABSOLUTE)
SUEXND::

SV40:	0	;C(40) WHEN USER OUT (SEE SWITCH)
]		;END OF IFE KL10P
IFN KL10P,[
SCLCXS:	DATAI PAG,CLCX	;CLOCK SAVE OF CONTEXT
SUEXND::
]		;END OF IFN KL10P

IFN <SUEXND-UUO>-<UEXND-UEXIT>, .ERR SUEXIT BLOCK LOST

IFN KL10P,[
CLCX:	0	;SAVED CONTEXT (DATAI PAG,) AT CLKBRK AND PFAIL

KLUPT 504,	;EBOX COUNT
EBOXCT:	0 ? 0	;NUMBER OF EBOX TICKS (25 MHZ) OVER 2 LEFT 12. THAT EBOX RAN FOR THIS USER
KLUPT 506,	;CACHE COUNT
MBOXCT:	0 ? 0	;NUMBER OF MBOX CYCLES REQUESTED BY EBOX FOR THIS USER LEFT 12.

EXPUNGE KLUPT
]		;END OF IFN KL10P

UTIME:	0	;RH=CLOCK INTERVAL IN 60'THS, LH=COUNT OF TICKS SINCE READ
UTRNTM: 0	;TOTAL RUN TIME IN 4 MICROSEC UNITS
USIPRQ:	0	;# SWAPIN REQUESTS
LTRNTM:	0	;SAVED RUN TIME FOR PRIV USR
LSIPRQ:	0	;SAVED SWAP IN REQ FOR PRIV USER
UPGSEC:	0	;NUMBER OF PAGE FAULTS PER <NPVSEC> RUN TIME SECONDS
LPRVTM:	0	;LAST TIME PRIV USER
TRUNTM:	0	;IF NOT TOP LEVEL, MINUS RUNTIME (4.069 US) ALREADY SENT TO SUPERIOR
		;IF TOP LEVEL, RUNTIME USED BY SUBTREE MINUS TIME SENT TO DEMON ALREADY
TSIPRQ:	0	;DITTO FOR SWAPIN REQUESTS
UTMPTR:	0	;POINTER TO RESOURCE WORD FOR THIS LOSER (JTMU FOR TREE)
JTMU:	0	;REDUCED BY 1/16 EVERY 1/2 SEC
			;INCREMENTED BY TIME RUN IN 4 USEC
			;MAX EQV VAL 1000000/8-1/16X=0
			;EQV VAL=2X10^6
			;AMONG JOBS WITH EQUAL RESOURSE
			;LOWEST JTMU HAS HIGHEST PRIORITY

IOCHNM:	REPEAT NIOCHN,0	;IO CHANNEL ASSIGNMENT
			;RH INDEX INTO IOTTB AND CLSTB
			;LH DEV CHNL AND/OR OTHER
SIOCHN:	BLOCK LUIOP	;MUST FOLLOW IOCHNM
			;I/O CHANNEL PDL
SIOCP:	SIOCHN-1	;POINTER INTO I/O CHANNEL PDL
IOCHST:	BLOCK NIOCHN	;I/O CHANNEL STATUS FOR CH'S AT IOCHNM
			;3.1-4.9 IO STATUS
			;1.1-2.9 .ACCESS POINTER

UPC:	0	;USER PC STORAGE
CORRQ:	-1	;RQ TO CORE JOB
		;4.9=1=>NO REQUEST
		;4.8=0 OLD TYPE RQ,1.1-1.9 # BLKS,3.1-3.8=USR NUMBER RQ'ED FOR
		;4.8=1 NEW TYPE
		;4.3 ADD FRESH BLOCK (IGNORE 4.2,4.1)
		;4.1=1=> ADDING ABSOLUTE BLOCK
		;3.9=1=>REQUEST WRITE ABILITY
		;2.9=1 INSERT, =0 DELETE ONLY IGNORE 4.1-4.3
		;2.1-2.8 VIRTUAL PAGE AFFECTED
		;1.1-1.9 USER RQ IS FOR

JBI:	-1	;JOB DEVICE INDEX. IF NOT -1, THIS JOB IS A JOB-DEVICE,
		;AND JBI HAS INDEX INTO JOB DEVICE TABLES.
APRC:	APRCHN	;R.H. CONO TO APR WHEN USER STARTS (HAS AR OV ENABLE, ETC.)
		;4.9=1=> PROCEDURE IS IN A DISOWNED TREE
BUMRTL==100000	;4.7 => GUN TREE IF HASN'T RUN FOR AN HOUR
		;(MEANINGFUL ONLY IN TOP LEVEL JOB).
		;CLEARED BY REOWNING OR ATTACHING.
BUSRCR==40000	;4.6 CORE RQ PENDING ON THIS JOB
BULGO==20000	.SEE SYSGUN ;USER IS DISABLED, WAITING TO BE FLUSHED BY SYS JOB.
BCHPTR==330400,,APRC(U)	;4.1-4.4 LAST CH ON WHICH AN ERR OCCURED (SEE ERR DEV)
BULGOS==400	;AN ATTEMPT IS BEING MADE TO DELETE OR LOG OUT THIS JOB
		;SO NO-ONE ELSE SHOULD START TO. THIS BIT ALSO LOCKS OUT
		;MOST WAYS OF HACKING THE JOB (INCL. THOSE THAT SET DIELOK).
		;3.1-3.5 MUST BE ZERO

DIELOK:	0	;NUMBER OF JOBS LOOKING AT OR HACKING THIS JOB.
		;BEFORE KILLING A JOB, WAIT FOR ITS DIELOK TO BECOME 0.

USTP:	0	;0 RUNNABLE, (IS SET NON ZERO FOR IDLE SETS OF VARS TO SPEED SEARCH)
BCSTOP==400000	;BIT IN USTP FOR CORE MOVAGE
BUCSTP==200000	;CORE STOPPING LOSER TO GIVE MORE CORE RQSTED BY ANOTHER LOSER
BUSRC==100000	;USER CONTROL BIT, SET & CLEARED BY SUPERIOR PROCEDURE
BSSTP==40000	;SET BY SUPERIOR WHEN HACKING MEM BOUND AT URMEMT OR UMEMEX
;1.1-2.9	;USED BY UBO AND FRIENDS INHIBITS RELOCATION BY CORE ALLOCATOR
		;MUST BE MODIFIED WITH CLKOFF  MUST NOT BE SET IF CSTOP IS SET
		;IS A COUNTER OF TRANSIENT REASONS FOR PROCEDURE BEING STOPPED

PIRQC:	0	;INT REQ AWAITING SERVICE (SOFTWARE INTS EFFECTED BY SEARCH)
MSKST:	0	;INT MASK REGISTER FOR BITS IN PIRQC
IFPIR:	0	;SECOND WORD OF INTERRUPT REQUESTS
		;3.8-3.1 INF PROC INT
		;2.7-1.1 IO CHANNEL INT
		;1.1= CHANNEL 0
MSKST2:	0	;INT MASK FOR IFPIR
PICLR:	0	;INT IN PROGRESS FLAG, -1=>ENABLED, 0=>IN PROGRESS

SUPPRO:	0	;-1 => TOP LEVEL PROCEDURE
		;OTHERWISE: INT BIT,,PNTR TO SUPERIOR PROCEDURE

FLSINS:	0	;USER BLOCKING INSTRUCTION;  STATE:
		; 0 => RUNABLE (UNLESS USTP .NE. 0) 
		; OTHERWISE HUNG,  IF NO SKIP SAFE TO RESTART AT UUO (UNLESS UFINAL .NE. 0)
RPCL:	0	;0,,N  RPCLSR'ING N
		;-1,,N  BEING RPCLSR'ED BY N

UNAME:	0	;USER NAME
		;THIS WORD FOR EACH PROCEDURE IS COPIED FROM THE UNAME OF THE PROCEDURE
		;THAT CREATES IT (SEE USR DEV).  FOR AN INITIAL TOP LEVEL PROCEDURE IT
		;IS INITIALLY -1 BUT IS MODIFIED BY ALOGIN.  IT IS THE SAME FOR ALL
		;PROCEDURES IN A TREE.
JNAME:	0	;JOB NAME
		;EACH LOGGED IN PROCEDURE HAS A UNIQUE UNAME, JNAME PAIR.  THE JNAME
		;OF AN INITIAL TOP LEVEL JOB IS "HACTRN".  FOR OTHER JOBS IT IS THE SECOND
		;FILE NAME SPECIFIED IN THE .OPEN ON THE USR DEVICE THAT CREATES THEM.
USYSNM:	0	;USER SYSTEM NAME
		;THIS VARIABLE IS INITIALLY SET TO THE SAME VALUE AS UNAME FOR
		;A PROCEDURE.  IT CAN BE READ OR WRITTEN BY THE PROCEDURE (ASUSET)
		;OR BY ITS SUPERIOR (AUSET).  ITS ONLY USE IS AS THE DEFAULT THIRD FILE NAME ON
		;USER SHARED DEVICES (2311'S (SEE QSKO),  AND CORE
		;LINK (SEE CLOO)).
USYSN1:	0	;3RD NAME FOR QSKO, CLOO (AFTER DEFAULTING AND TRANSLATION)

TTYTBL:	0	;TTY ASSIGNED THIS USER OR INDICATION THAT THERE IS NONE
%TBNOT==400000	;4.9 DOES NOT HAVE TTY NOW
%TBNVR==200000	;4.8 IF JOB DOESN'T HAVE TTY, OPENS SHOULD FAIL.
%TBINT==100000	;4.7 IF JOB DOESN'T HAVE TTY, ATTEMPT TO USE TTY SHOULD INTERRUPT.
		;JOB CAN SET BITS 4.8 AND 4.7.
%TBWAT==40000	;4.6 IF 1, %TBINT AND %TBNVR ARE OVERRIDDEN AND TTY USE ATTEMPTS
		;    ALWAYS HANG. SET BY DDT FOR $P, CLEARED BY ^P. ONLY SUPERIOR CAN SET.
%TBDTY==010000	;4.4 TTY TAKEN FROM --ME--.  WHEN GIVEN BACK,
		 ;DON'T PASS IT ON TO MY INFERIOR.
$TBECL==220600	;3-6-3.1 # ECHO LINES IF I DONT HAVE DISPLAY
		;RH USER NUM GAVE TTY AWAY TO OR TTY NUM IF HAS IT

TTSTSV:	BLOCK 3	;JOB'S SAVED TTYST1,TTYST2,TTYSTS, WHEN JOB DOESN'T HAVE THE TTY.

IOTLSR:	0	;4.9 IOT USER MOD (=1 ENABLES USER TO DO DIRECT I/O INSTRUCTIONS)
		;RH VIRTUAL PAGE # OF LAST MPV OR WIRO (SHIFTED TO ADDRESS SIZE)
UMARPC:	0	;PC AT MAR INTERRUPT
LSWPR:	0	;LOCKED SWITCH POINTER
UCLBLK:	0	;CLOCK QUEUE BLOCK
	-1
	JRST UREALB
URTIME:	0	;LH=0=>LOW PRIORITY PHASE 1=> LOW PRIORITY WITH BLOCKING
		;LH=-1=>HIGH PRIORITY PHASE 2=> HIGH PRIORITY WITH BLOCKING
		;RH=LENGTH OF HIGH PRIOITY IN 60'THS
RTIMER:	-1	;POSITIVE => MICROSEC RUNTIME TILL RUNTIME INT

LSPCL:	0	;UPC AT LAST PCLSR
LSPCL1:	0	;UPC AT LAST PCLSR AT A DIFFERENT PLACE FROM ABOVE
LPFBTS:	0	;FAULT BITS AT LAST PG FAULT DEBUGGING USE ONLY
LEXFDR:	0	;EXEC ADR THAT CAUSED PG FAULT THIS PC
		;FLUSHED AT CLK LVL AND CNTRL SENT TO IOADCR
		;USED FOR DEBUGGING ONLY
UTRAPM:	0	;4.9=> 1 UUO TRAP MODE
LSUUO:	0	;LAST SYS UUO (FOR DEBUGGING PURPOSE)
LSCALL:	0	;SIXBIT NAME OF LAST .CALL 0, (FOR PEEK)
CTLBTS:	0	;CTL BITS TO .CALL 0, XORED TOGETHER IN HERE (RIGHT HALF)
SYSCVL:	0	;CONTROLS OUTPUT ARGS FROM SYSTEM .CALL
 %SCVOT==400000	;4.9 CALL HAS OUTPUT ARGS FLAG (TO SAVE TIME)
 %SCVER==200000	;4.8 CALL HAS ERROR CODE ARG FLAG
		;3.6-4.7 UNUSED 3.1-3.5 MUST BE ZERO
		;1.1-2.9 ADDRESS OF ERROR CODE ARG
IOTBTS:	0	;DEVICE-INDEPENDENT IOT CONTROL BITS GO HERE, IN IOT AND SIOT
USTYN:	0	;TTY NO OF PSEUDO TTY FOR THIS USER
UUAC:	0	;AC FLD OF LAST UUO OR DESIRED CHANNEL IN CASE OF NOPEN ETC
		;SELECTS CHNL FOR ALL IOTS, OPENS ETC
TRMNAM:	0	;TERMINAL IDENTIFICATION
USWSCD:	0	;SWAP SCHEDULING WORD 4.9=1 SWAPIN INHIBITED THIS JOB
USWPRI:	0	;JOB SWAP PRIORITY
TRNLST:	0	;TRANSL LIST FOR THIS JOB. -1 => NIL, OR IDX INTO TRAN!X
TRNLS1:	0	;TRANSL LIST FOR THIS JOB & INFERS.
IDF1:	0	;DEFER BITS FOR 1ST WD INTERRUPTS.
IDF2:	0	;FOR 2ND WORD INTERRUPTS.
		;IF AN INTERRUPT IS DEFERRED, IT IS TREATED AS
		;IF THE JOB'S PICLR VAR HELD 0.
OPTION:	0	;OPTIONS WORD, SETTABLE BY USER
		;EACH BIT CONTROLS SOME SYSTEM ACTION FOR THIS JOB
	.SEE OPT
XUNAME:	0	;"WHO I REALLY AM" AS OPPOSED TO "WHO I AM LOGGED IN AS"

40ADDR:	40	;ADDRESS OF USER'S 6-WORD BLOCK FOR UUO'S, INTS, SWITCHES, LOCKING.
IFN N11TYS,[
TVCREG:	-1	;TV CONSOLE REG FOR THIS USER OF -1 NONE
TVVBN:	-1	;-1 OR CONSOLE REG FOR RUN BLINKING
NVDBA:	0	;# VIDEO BUFFERS ASSIGNED (WITH NVDBA SYSTEM CALL).
UWHO1:	0	;WHOLINE FLAGS
UWHO2:	0	;5 CHARS OF LEFT-JUSTIFIED SIXBIT TO APPEAR IN WHOLINE.
UWHO3:	0	;RIGHT-JUST 32 BIT NUMBER FOR WHOLINE.
]
;INSERT NEW USER VARIABLES HERE^

USRPDL:	-LUPDL,,UPDL-1	;USER PDL
UPDL:	BLOCK LUPDL-1
EPDL2:	0	;SAVES C(T) FOR FLSINS
QLD:	0	;LINK DEPTH
IFE N11TYS,[
UWHO1:: UWHO2:: UWHO3::	;USER VARS REFERENCED BY USET VARS - SHOULD
]			;BE LEGAL TO REFERENCE EVEN IF DOES NOTHING.
SRN3:	0	;SAVED N3, N4 FOR RENAMES AT AOPEN ALSO USER INDEX AT NLOAD
		;SRN3, SRN4 USED BY CORBLK .CALL
SRN4:	0	;ALSO DEVICE CHNL IOCHNM POINTER AT NLOAD
SRN5:	0	;SAVED N5 FOR LINK ALSO VIRTUAL PAGE NUMBER AT NLOAD
EPDL3:	0	;USED BY 2311 ROUTINES (QFNG) ALSO QSMDN ADDR AT NLOAD ALSO BY TYOW2
EPDL:	0	;USED BY 2311 ROUTINES
EPDLT1:	0	;FN1 BEFORE LAST TRANSLATION
EPDLT2:	0	;FN2
EPDLT3:	0	;SYS NAME
EPDLT4:	0	;LEFT ADJ DEVICE NAME

REPEAT NULBLK,[
CONC LSWB,\.RPCNT,:	BLOCK 2
]		;SWITCH BLOCK FORMAT
		;WD1 ASSOCIATED ADDRESS OR QUANTITY
		;3.6-3.1 USER NUMBER OF SWITCH HOLDER
		;2.9-1.1 PNTR TO NEXT SWITCH ON LIST OR 0 IF NONE
		;FOR REMAINDER OF FORMAT SEE LSWDIS

IFN KL10P,[
IFGE USRSTG+1000-., INFORM SPACE LEFT IN UPT,\1000-<.-USRSTG>
IFL USRSTG+1000-., .ERR USER VARS TOO BIG FOR UPT!
.ELSE LOC USRSTG+1000
]		;END OF IFN KL10P

LUBLK==.-USRSTG
L==LUBLK
INFORM [STORAGE PER LOSER]\LUBLK
	BLOCK LUBLK	;USER VARIABLES FOR CORE JOB
SYSB==<1777+.>_-10.
MXC==SYSUSB-SYSB	;AVAIL BLOCKS AFTER SYS+DDT


LMB=100000,,	;LOAD META BITS
SMB=101000,,	;STORE META BITS

SUBTTL TSS INITIALIZATION
;(THE FOLLOWING CODE IS WIPED OUT AT ICLR)

BEG:	SKIPE SALV		;SKIP IF NO SALVAGER IN CORE
	 JSR SALV+1
GO:	JFCL 17,.+1
	JRST .+1
	JFCL 1,[JRST 4,.]	;SYSTEM WONT RUN ON 6
IFN KL10P,[
	CONSO PAG,600000
	 SWPIA			;IF CACHE OFF, FLUSH CRUFT THAT MAY BE IN IT
	CONSZ PAG,600000
	 SWPUA			;IF CACHE ON, UPDATE CORE SO DDT IS GOOD
	CONSZ 200000
	 JRST .-1
	DATAO PAG,[700100,,400000]	;CLEAR CRUFT OUT OF AC BLK 1
	MOVEI T,0
	XCTR XBW,[BLT T,17]		;TO AVOID RANDOM PARITY ERRORS
]
IFN TEN11P,[
	MOVEI TT,600000+<T11CPA_-10.>
	SKIPGE TEN11F
	 MOVEI TT,0
	DPB TT,[.T11CP+EXEUMP]
	SETOM T11MP+<T11CPA&777777>_-10.	;DONT USE MAP PAGE AS 10-11 PAGE
;IFN PDP6P,[		;THESE ARE IN SEPARATE MOBIES NOW
;	MOVE TT,[-LPDP6M,,<PDP6BM&777777>_-10.]
;	SETOM T11MP(TT)	;CONFLICTS WITH PDP-6 MEM
;	AOBJN TT,.-1
;]
;IFG TSYSM-256.,[
;	MOVSI TT,-TSYSM+256.
;	SETOM T11MP(TT)	;CONFLICT PAGES
;	AOBJN TT,.-1
;]
]
	LPMR UPGML
IFE KL10P,	CONO 633550
IFN KL10P,[
	CONO 327740	;ENABLE AND CLEAR ALL FLAGS EXCEPT SWEEP DONE
	APRID A
	TLNN A,020000
	 JRST 4,.	;SYS WON'T RUN WITH DEC MICROCODE
	DATAO PAG,[706600,,400000]	;LOAD PAGER ACS IN BLK 6
	MOVEI 3,EXEUMP	;DBR3
	MOVEI 4,EXELMP	;DBR4
	MOVSI 5,PMAGEM	;LH.AGE
	MOVEI 6,PMAGEM	;RH.AGE
	MOVEI 7,1000	;CN1000
	MOVEI 10,100	;CN100
	CONO PAG,660000+<EPT/1000>	;CACHE ON, ITS PAGER, TRAP ENB, EPT ADDR
	DATAO PAG,[701100,,400000+<USRSTG/1000>] ;AC BLOCK 1, UPT ADDR
]		;END IFN KL10P
	MOVE P,SYSPDP

IFN DIRMAP,[	;INITIALIZE EXEC PAGE MAP
	MOVE Q,[222200,,EXEUMP]
	SETZB A,B
	SKIPE USEMDM		;MAKE MEDIUM MEM NXM IF DIRMAP NOT TURNED ON
	 MOVEI B,600200+PMCSHM	;THIS MAY BE USEFUL FOR DEBUGGING
BEG2:	CAIL A,NEXPGS
	 DPB B,Q
	IBP Q
	ADDI B,1
	CAIGE A,200-DDTPGS
	 AOJA A,BEG2
IFL TSYSM-128.-NEXPGS-DDTPGS, .ERR NO MEDIUM MEMORY, TURN OFF DIRMAP
IFL TSYSM-256., MOVEI A,TSYSM-128.-DDTPGS-NEXPGS
.ELSE	MOVEI A,256.-128.-DDTPGS-NEXPGS	;NUMBER OF PGS MEDIUM MEMORY
	SKIPE USEMDM
	 ADDM A,LMEMFR	;COUNT MEDIUM PAGES AS LOW FREE
];END IFN DIRMAP
 
;INITIALIZE FREE LISTS IN MEMBLT
;IF DIRECT MAPPING IS ON, LOW + MEDIUM PAGES GO IN MEMFP, HIGH PAGES IN MEMHPT
;IF DIRECT MAPPING IS OFF, LOW PAGES GO IN MEMFP, HIGH + MEDIUM IN MEMHPT

	SETZB B,C	;B LAST LOW PG, C LAST HIGH PG
	MOVEI A,1	;A PG NO
BEGF0:	CAIGE A,128.
	 JRST BEGFL	;LOW HALF
	CAIL A,128.+NEXPGS ;MEDIUM MEM CAN'T MAP
	 CAIL A,256.	;HIGH MOBY
	   JRST BEGFH
	CAIL A,256.-DDTPGS
	 JRST BEGF1	;DDT PAGES AREN'T FREE
	SKIPN USEMDM
	 JRST BEGFH	;MEDIUM MEM TO GO IN HIGH
BEGFL:	MOVEI TT,MUFR
	DPB TT,[MUR,,MEMBLT(A)]
	SKIPN MEMFP	;THIS PAGE GOES IN LOW
	 MOVEM A,MEMFP
	DPB B,[MLU,,MEMBLT(A)]
	SKIPE B
	 DPB A,[MLO,,MEMBLT(B)]
	MOVE B,A
	JRST BEGF1

BEGFH:	MOVEI TT,MUFR
	DPB TT,[MUR,,MEMBLT(A)]
	SKIPN MEMHPT	;THIS PAGE GOES IN HIGH
	 MOVEM A,MEMHPT
	DPB C,[MLU,,MEMBLT(A)]
	SKIPE C
	 DPB A,[MLO,,MEMBLT(C)]
	MOVE C,A
BEGF1:	CAIGE A,TSYSM-1
	 AOJA A,BEGF0
IFN TEN11P,[
	SKIPGE TEN11F
	 JRST BEG4
	MOVSI A,-256.	;CLEAR THE INTERFACE'S "VALID" BITS.
	SETZM 400000+T11CP*2000(A)
	AOBJN A,.-1
BEG4:]
IFN XGP,[
	SKIPE TEN11F
	 JRST BEGX1
	MOVE A,[600000+<XGP11_8>,,1777]
	PUSHJ P,T11AD
	JRST 4,.	;NO 10-11 PAGES AVAILABLE?
	MOVEI TT,600000+<<T11CPA_-18.>_8>(B)	;GET CORRESP EXEC MAP PG SETUP
	DPB TT,[.XGPC+EXEUMP]
	MOVEI TT,600000+<<T11CPA_-18.>_8>+XGPTP
	DPB TT,[.XGPB+EXEUMP]	;SETUP PAGE FOR PDP-11 BUFFER
BEGX1:]
	MOVEI A,TSYSM-1	;CHECK AVAIL MEM FOR EXISTANCE
CKML:	MOVEI TT,600000(A)
	DPB TT,[.PAREP+EXEUMP]
	LPMR UPGML
IFN AI,[
	CAIN A,<1,,521400>_-10.	;THIS PAGE OF OLD MOBY IS TREATED AS DOWN
	 JRST CKML1A		;BECAUSE PARR ERRS HAPPEN VERY OFTEN IN IT
]
IFE MCOND ML,[
	MOVE TT,A
	LSH TT,10.-9
	ANDI TT,1740
	CAIN TT,0540
	 JRST CKML1A		;STACK B MEM A3 DOWN DUE TO BROKEN Y LINE
]
	SKIPL USEHM
	CAIGE A,256.
	JRST .+2
	JRST CKML1A
	MOVE 0,400000+PAREP*2000+20	;IF THIS NXMS, MEM THE SYS THINKS IT HAS IS NON EXISTANT
				;CHECK STATE OF USEHM
	CONSZ 10000
	 JRST CKML1	;THAT MEM LOSES
	SKIPL CKMBLK	;WINS
	 JRST CKML6	;THUS ENDING BLOCK OF LOSERS
CKML2:	SOJGE A,CKML
	MOVEI TT,[ASCIZ/
/]
	AOSN CKMFLG	;ANY MEM OFF UNEXPECTEDLY?
	 JRST CKML5	;NO
	PUSHJ P,T00ASZ	;YES, NEED CRLF
	JRST 4,CKML5	;HALT SO LOSERS WHO IGNORE ERROR MESSAGES	
CKML5:			;WILL REALIZE THAT SOMETHING MAY BE SERIOUSLY WRONG
IFN KL10P,[
	CONI MTS,TT
	TLNN TT,400
	 JRST 4,.	;TAPE CHANNEL IN KA MODE
	CONI DSK,TT
	TLNN TT,4000
	 JRST 4,.	;DISK CHANNEL IN KA MODE
]
;DROPS THROUGH

;DROPS IN

IFE <MCOND ML,>&<MCOND DM,>,[	;CHECK FOR LOSING SWITCHES ON MEMORY ON ML AND DM

	MOVSI D,(DWRITC)	;MAKE COMMAND FOR VERY LAST BLOCK ON DISK
	MOVEI A,NCYLS+XCYLS-1
	DATAO DPC,[DNOOPC]	;DETERMINE TYPE OF DRIVE 0
	DATAI DPC,B
	TRNE B,RP03BT
	 MOVEI A,MCYLS+XCYLS-1	;RP03
	DPB A,[DCYL D]
	LSH A,-8
	DPB A,[DCYLXB D]
	MOVEI A,NHEDS-1
	DPB A,[DSURF D]
	ADDI D,QICWA
	MOVEM D,CKMSWC
	SUB D,[DWRITC-DREADC]
	MOVEM D,CKMSRC
	SUB D,[DREADC-DSEEKC]
	MOVEM D,CKMSSC
	MOVEI A,0
CKMS1:	LDB TT,[MUR,,MEMBLT(A)]	;MEM EXIST?
	CAIE TT,MUFR		;AND NOT DDT?
	 JRST CKMS2
	MOVEI B,600000(A)
	DPB B,[.PAREP+EXEUMP]
	LPMR UPGML
	CAIGE A,CKMSZZ		;MEM LOADED?
	 JRST CKMS3		;YES
	MOVSI B,'FOO		;NO, LOAD IT
	MOVEM B,CKMSBF
	MOVE B,[CKMSBF,,CKMSBF+1]
	BLT B,CKMSBF+177
	MOVEI B,'BAR
	HRRM B,CKMSBF+69.
	HRRM A,CKMSBF+6		;MAKE DIFF FROM OTHER SUCH PAGES
	MOVEI C,1
	MOVE B,A
	LSH B,-4		;16K BLOCK # IN B
	LSH C,(B)		;GET UNIQUE BIT SO PARITY ERR IF TWO AT SAME ADDR
	MOVEM C,CKMSBF+35
	MOVE B,[CKMSBF,,400000+PAREP*2000]
	BLT B,400000+PAREP*2000+177
CKMS3:	MOVE B,A		;MAKE IOWD
	LSH B,10.
	SOS B
	HRLI B,-200
	LDB C,[100300,,A]	;MA 15-17
	TRC C,7
	DPB C,[410300,,B]
	MOVEM B,QICWA
	SETZM QICWA+1
	CONO DPC,175700
	DATAO DPC,CKMSSC	;POSITION HEADS
	CONSO DPC,10
	 JRST .-1
	DATAO DPC,CKMSWC	;WRITE OUT SECTOR
	CONSZ DPC,20
	 JRST .-1
	CONI DPC,B
	TLNE B,17
	 JRST CKMS4		;CHANNEL ERROR MEM LOSING
	TRNE B,177700
	 JRST CKMS2		;FOO, DISK LOSING
	MOVE B,[-200,,CKMSBF-1]	;READ IT BACK	
	MOVEM B,QICWA
	SETZM QICWA+1
	SETZM CKMSBF+69.
	CONO DPC,175700
	DATAO DPC,CKMSRC
	CONSZ DPC,20
	 JRST .-1
	CONI DPC,B
	TLNE B,17
	 JRST CKMS2		;MEM LOSS IN CKMSBF?
	TRNE B,177700
	 JRST CKMS2		;FOO, DISK LOSING
	MOVSI B,-200		;COMPARE
	MOVE C,CKMSBF(B)
	CAME C,400000+PAREP*2000(B)
	 JRST CKMS4		;NOT SAME SWITCHES LOSING
	AOBJN B,.-3
CKMS2:
IFE MCOND DM,	ADDI A,16.	;MA10'S !!
IFE MCOND ML,	ADDI A,32.	;ML MEM IS IN 32K MODULES
	CAIGE A,TSYSM
	 JRST CKMS1
	CONO DPC,175700		;RESET THE DISK CONTROL
	DATAO DPC,[DEASEC+776]	;AT EASE!
	CONO PI,20000		;TURN OFF IOB PI REQ LIGHT
	JRST CKMSX		;DONE WITH THIS, CONTINUE INITIALIZATION

CKMSBF:	BLOCK 200

CKMS4:	MOVEI TT,[ASCIZ/MEM ADDR SWITCHES DISAGREE CPU VS DSK AT LOC /]
	PUSHJ P,T00ASZ
	PUSHJ P,T00BKO
	MOVEI TT,[ASCIZ/0000/]
	PUSHJ P,T00ASZ
	JRST DDT

CKMSZZ==./2000+2		;ABOVE HIGHEST CODE

CKMSX:
]		;END IFE MCOND ML & DM

;DROPS IN
	MOVEI TT,0
	DPB TT,[.PAREP+EXEUMP]
	LPMR UPGML
IFE KL10P,	CONO PI,240000+11577+IFN C1MXP,20000
IFN KL10P,	CONO PI,11577
IFN NOTYS,	CONO TTY,TTYCHN
IFN NETYS,[
	CONO DTE,1170+APRCHN	;CLEAR ALL FLAGS AND ASSIGN PI CHANNEL
	MOVEI TT,%DTMMN		;ENTER MONITOR MODE
	MOVEM TT,DTECMD
	SETZM DTEFLG
	CONO DTE,%DBL11
	SKIPN DTEFLG
	 JRST .-1
]		;END OF IFN NETYS
IFN E.SP,[
	CONO DIS,515330	;RESET E&S
	MOVEI TT,E.SPM
	MOVEM TT,34	;SET PAGER LOC (USED BY DSKDUMP)
]
IFN TM10B,[
	MOVEI TT,MIOWD
	MOVEM TT,MICWA	;SETUP LOC FOR MEM CHAN TAPE
]
IFN RP10P+RH10P,[
	MOVEI TT,QIOWD
	MOVEM TT,QICWA	;SETUP FOR DEC DISK CHANNEL
]
IFN ARMP,	DATAO 760,[0]	;RESET LITE ON ARM
IFN DSDP,	CONO DSDEV,10	;RESET INT RQ FROM PDP10
IFN RBTCP,	CONO RBTCON,0	;RESET TABLET

	MOVE A,DDT-2	;PUT GLOBAL BLOCK HEADER AT BEGINNING
	MOVE B,[SQUOZE 0,GLOBAL]
	CAME B,(A)	;SEARCH FOR GLOBAL BLOCKS
	AOBJN A,[	AOBJN A,.-1
			JRST BEGS1]
	MOVE C,DDT-2
	MOVEI D,(C)
	SUBI D,(A)	;GET ,,-#WDS  BEFORE GLOBAL BLOCK
	MOVSI D,(D)
	ADDM D,1(A)	;GLOBAL BLOCK NOW LARGER
	EXCH B,(C)	;EXCHANGE IT WITH FIRST SYM
	MOVEM B,(A)
	MOVE B,1(A)
	EXCH B,1(C)
	MOVEM B,1(A)
	PUSHJ P,SBUBL
	JUMPL J,.-1	;KEEP SORTING UNTIL SYMS IN ORDER
	MOVSI A,400000
	IORM A,DDT-1

; SORT THE UUO/SUSET/BIT SYMBOL TABLE BY VALUE

	MOVE E,[SYSYMB-SYSYME-1,,SYSYMB]
	PUSHJ P,SBUBL0
	JUMPL J,.-2

BEGS1:	MOVE A,[-LTSTB,,TSTB]
BEG1:	MOVE B,(A)
	MOVEI C,(B)
	EQV C,(B)
	AOBJN B,.-1
	MOVEM C,CKSUMS-TSTB(A)
	MOVE B,(A)
CKXC2:	MOVE C,(B)
REPEAT 36.,[
	IFL .RPCNT-18.,TLNE C,400000_<-.RPCNT>
IFGE .RPCNT-18.,TRNE C,400000_<18.-.RPCNT>
	XORM B,CKXORS+.RPCNT
]
	AOBJN B,CKXC2
	AOBJN A,BEG1
	HRRZS 37		;MAKE SURE SYS DOESNT IMMEDIATELY COME DOWN
;DROPS THROUGH

;DROPS IN

	MOVEI A,0
	CLEARM QACTB
QSETUP:	MOVE B,DCHBT(A)
	SKIPN QACT(A)
	IORM B,QACTB
	CAIGE A,NQS-1
	AOJA A,QSETUP
IFN DC10P,	CONO DC0,DCCSET+DCDENB+DSKCHN	;RESET 2314 AND SET DATA ERROR ENABL
IFN 340P,	CONO DIS,100
IFN TK10P,	CONO NTY,TTYCHN
IFN MTYP,	CONO MTY,TTYCHN
	CLEARM USRHI
	CLEARB U,USER
	MOVE P,SYSPDP
IFN DPKPP,[
	CONO DPK,400070+TTYCHN	;INITIALIZE DP KLUDGE
	DATAO DPK,[4,,DPKBAS]
	MOVE T,[-NDPTYS,,NFDPTY]
	MOVEI B,0	;LINE #
DPIL:	LDB A,[220300,,TTYTYP(T)]	;OUTPUT SPEED
	LSH A,9
	DPB B,[140400,,A]	;LINE #
	CONO DPK,500+TTYCHN(A)	;LOAD OUT SPEED
	LDB A,[250300,,TTYTYP(T)]	;INPUT SPEED
	LSH A,9
	DPB B,[140400,,A]
	CONO DPK,700+TTYCHN(A)	;LOAD IN SPEED
	AOS B
	AOBJN T,DPIL
]
IFN N11TYS,[
	SKIPE TEN11F
	 JRST BEG5
	MOVSI R,-NTTPG-NTVBP+1
	MOVE T,[.TTPG0+EXEUMP]
VSCL7A:	MOVEI A,(R)	;SET UP 1 MORE TEN-11 MAP ENTRY
	LSH A,20.
	IORI A,1777	;A FULL PAGE
	TLO A,600000+TT11NM*400
	PUSHJ P,T11AD
	 JRST 4,.
	ADDI B,600000+<<T11CPA_-18.>_8>		;READ-WRITE, IN HIGH MOBY.
	DPB B,T
	IBP T
	AOBJN R,VSCL7A
	MOVE A,[(600000+TT11NM*400)TT11CR_8]	;POINTER TO CONSOLE REG
	PUSHJ P,T11AD
	 JRST 4,.
	ADDI B,600000+<<T11CPA_-18.>_8>
	DPB B,T
	LPMR UPGML
	SKIPE TT11P	;IF WE'RE SUPPOSED TO USE THE TV 11,
	 SETZM TT11UP	;REQUEST IT TO RE-INIT.
		;IF TT11UP BECOMES NONZERO, THE 11 IS UP.
BEG5:	];END IFN N11TYS
IFN DL10P,[		;INITIALIZE DL10
	CONO DLC,400000	;MR CLR
	CONO DLB,1
	CONO DLB,2
	CONO DLB,3
	CONO DLB,DL10AR	;64 WORDS FOR PDP11 #0 AT DL10AR
	DATAO DLB,[1,,]	;KI INTERRUPT MODE
	CONO DLC,100020+TTYCHN	;ENB PDP11 PORT #0 AND ENB INTR
	MOVSI T,1
	SKIPN DL10UP
	 SOJG T,.-1
	SETZM DL10UP
	SKIPGE T	;IF THE 11 DIDN'T SAY IT WAS UP,
	 SETZM DL10F	;MARK IT NON-FUNCTIONAL.
]
IFN KL10P,[
	CONO MTR,433000		;TIME BASE ON, ACCOUNT FOR USER + EXEC NO PI
]
;DROPS THROUGH

;DROPS IN
	MOVSI T,%TBNOT+%TBDTY+%TBNVR	;SYS JOB HAS NO CONSOLE ALL TO ITSELF
	MOVEI U,LUBLK
	PUSHJ P,USSINI	;INITIALIZE SYS JOB VARIABLES BLOCK
	 JRST .-1
	AOS NMPGS
IFN KL10P,[
	MOVEI T,UUOH0	;CLOBBERED BY USSINI
	HRRM T,MUUOKN
]
	MOVSI T,600000
	HLLM T,UPGMP	;GIVE PG 0 TO SYS JOB
	MOVEI T,2000
	MOVEM T,HUSRAD
	MOVEI T,SYSRCE	;SET SYS JOB RESOURCE POINTER
	MOVEM T,UTMPTR
	MOVSI A,(SIXBIT /SYS/)	;""" NAMES
	MOVEM A,USYSNM(U)
	MOVEM A,UNAME(U)
	MOVEM A,XUNAME(U)
	MOVEM A,JNAME(U)
	SETZM USTP(U)
	MOVSI T,%TBNOT+%TBDTY+%TBNVR	;CORE JOB HAS NO CONSOLE
	MOVEI U,2*LUBLK
	PUSHJ P,USSINI	;SET UP CORE JOB VARIABLES BLOCK
	 JRST .-1
	MOVE A,[SIXBIT /CORE/]
	MOVEM A,USYSNM(U)
	MOVEM A,UNAME(U)
	MOVEM A,XUNAME(U)
	MOVSI A,(SIXBIT /JOB/)
	MOVEM A,JNAME(U)
	MOVEI T,SYSRCE
	MOVEM T,UTMPTR+LUBLK
	SETZM USTP(U)
	MOVEI A,CORJI
IFN KL10P, HRLI A,%PSPCU	;DOES CORE JOB XCTR?
	MOVEM A,UPC(U)
IFN KL10P,[
	MOVE T,[JSR ILLTRP]	;SYS AND CORE JOBS SHOULDN'T TRAP
	MOVEM T,TR1INS		;THESE WON'T BE USED ANYWAY UNLESS
	MOVEM T,TR2INS		;SOMEDAY THEY SHOULD RUN IN USED MODE
	MOVEM T,TR3INS
	MOVEM T,TR1INS+L
	MOVEM T,TR2INS+L
	MOVEM T,TR3INS+L
]
	MOVEI A,SYSB
	MOVEM A,CORRQ
	AOS NCORRQ
	SOS A
	ADDM A,NCBCOM
;	DATAI CLK1,LCLK1
	CONO PI,100+UTCON-1	;ALL EXCEPT 7
IFE KL10P,	CONO 3000+APRCHN
IFN KL10P,[
	MOVEI A,%DTCLN	;TURN ON 60-CYCLE CLOCK
	MOVEM A,DTECMD
	SETZM DTEFLG
	CONO DTE,%DBL11
	SKIPN DTEFLG
	 JRST .-1
	CONO APRCHN	;ENABLE APR FAULT INTERRUPTS
]
IFN KL10P,[
	SWPUA		;UPDATE MEMORY AGAIN TO MAKE SURE DDT + SYMBOL TABLE OUT OF CACHE
	CONSZ 200000
	 JRST .-1
]
	JRST ICLR

CKML1:			;MEM NON-EXISTANT PATCH OUT
IFE KL10P,	CONO 10000	;TURN OFF NXM FLAG
IFN KL10P,	CONO 22000	; ..
	SKIPGE CKMBLK
	 MOVEM A,CKMBLK	;HIGHEST IN BLOCK OF LOSERS
CKML1A:	LDB TT,[MUR,,MEMBLT(A)]
	CAIE TT,MUFR
	 JRST 4,.	;?
	CAIG A,SYSB+1
	 JRST 4,.	;SYS MEM NON EX?
	PUSHJ P,MPOUT2	;FLUSH THAT BLOCK
	MOVEI TT,MUHOLE
	DPB TT,[MUR,,MEMBLT(A)]
	JRST CKML2

; REPORT A BLOCK OF LOSING MEMORY

CKML6:	PUSH P,A
	MOVEI TT,[ASCIZ/MEM OFF /]
	AOSN CKMFLG
	 PUSHJ P,T00ASZ
	ADDI A,1	;LOWEST LOSER = HIGHEST WINNER + 1 PAGE
	PUSHJ P,T00BKO
	MOVEI A,"-
	PUSHJ P,T00TYO
	MOVE A,CKMBLK
	PUSHJ P,T00BKO
	MOVEI A,40
	PUSHJ P,T00TYO
	SETOM CKMBLK
	POP P,A
	JRST CKML2

; TYPE CHAR IN A ON CONSOLE TTY

T00TYO:
IFE KL10P,[
	CONSZ TTY,20
	 JRST .-1
	DATAO TTY,A
]
IFN KL10P,[
	SETZM DTEFLG
	MOVEM A,DTECMD
	CONO DTE,%DBL11
	SKIPN DTEFLG
	 JRST .-1
]
	POPJ P,

; TYPE BLOCK NO IN A AS HIGH 3 OCTAL DIGITS OF ADDR
; (ALL MEMORIES MULTIPLE OF 4K.  MAX MEMORY 2M WORDS.)

T00BKO:	PUSH P,A
	PUSH P,B
	LSHC A,-8
REPEAT 3,[
	ADDI A,"0
	PUSHJ P,T00TYO
	MOVEI A,0
	LSHC A,3
]
	JRST POPBAJ

; TYPE ASCIZ IN TT ON T00

T00ASZ:	PUSH P,A
	HRLI TT,440700
T00AZ1:	ILDB A,TT
	JUMPE A,POPAJ
	PUSHJ P,T00TYO
	JRST T00AZ1

USEHM:	-1	;-1 => USE MEM IN HIGH MOBY (IF PRESET)

CKMBLK:	-1	;IF + HIGHEST LOSING BLOCK IN CONTIG RANGE
CKMFLG:	-1	;IF + PRINTED MESSAGE ALREADY
CKMSWC:	0	;WRITE CMD
CKMSRC:	0	;READ CMD.
CKMSSC:	0	;SEEK CMD.

CONSTANTS
VARIABLES

IEND:

SALV==200000
DDT==774000
DSKDMP==777700

END BEG		;START AT BEG TO SALVAGE AND RUN ITS, START AT GO TO JUST ITS
PS IN    KML1A