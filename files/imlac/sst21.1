.SYMTAB 10000.,4000.

TITLE SST 21

; Written for PDS-1D compatible IMLACs, uses DMS display addressing
; modification.  Includes ARDS graphics simulator.

; 21 (04/16/77) Software TTY codes

%VERSIO==21.

; assembly switches (non-zero implies feature exists)
CTRLS=1				; display controls
GRAPH=1				; graphix
MUDDLE=1			; muddle movement
NOXMIT=1			; no page transmit

IF1 [PRINTX \TRACE = \
.TTYMAC A
DEFINE XSVFLG
A
TERMIN
TERMIN ]

TRACE=XSVFLG

%TYPE==<MUDDLE_6>+<NOXMIT_4>	; muddle stuff and no-pxmit bit

.CRFOFF
	.INSRT IMSRC;IMDEFS >
	IF1, EXPUNG PUSH POP MOVE
.CRFON

	.ADDR.=1

; character and screen parameters
	CSIZE=11.
	LSIZE=21.		; characters are 8*12
	LEFT=<3*CSIZE>		; leftmost character position
	TOP==2000-50-LSIZE	; topmost character position
	SCREEN==44.		; screen length
	LINE==90.		; screen width
	SCROLL==10.		; number of lines to scroll

; hard-wired buffer parameters
	BUFBEG==17777-<SCREEN*<LINE+3>>
				; beginning of buffer
	CRIKY==BUFBEG-1		; end of overprint/grafix buffer

; keyboard logic levels
	REPT=2000
	CTRL=1000
	SHIFT=400

; macro for dispatch tables
	DEFINE DSP DISCOD,DISGO
		DISCOD
		DISGO
	TERMIN

; macro to facilitate horizontal positioning
	DEFINE DXPOS N
		DLXA LEFT+<N*CSIZE>
	TERMIN

; interrupt handler
	LOC 1

	DAC ASAVE		; save ac
	RAR 1			; save link
	DAC LSAVE
	CLA
	RDI
	DAC INTBIT
	JMP AFT100		; go restart display

; locations 24 through 37 are defined to contain
; constants and variables of interest to programs that
; might be overlaid on top of SSV
	LOC 24

JMSTAB:	LIST40			; 24/ table of character DJMSs
BUFEND:	CRIKY			; 25/ end of SSVs display buffer
INTARM:	REF\KBD			; 26/ interrupt arming word
DLPTR:	0			; 27/ pointer to dlist overlay
OVRLAY:	0			; 30/ pointer to overlay routine
COUNTR:	0			; 31/ number of 40th's remaining this second

; program start up locations
	LOC 100

	JMP GO100		; continuation startup
	JMP GO101		; erasing, reinitializing startup

; interrupt armer
ARMER:	0
	DAC INTARM
	ARM			; arm it
	JMP @ARMER

; display restart routine.  takes address in ac
DSTART:	0
	DCF			; clear display flag
	SCF			; clear 40 cyc sync flag
	DLA
	DON
	JMP @DSTART

; interrupt handler continued
; is it keyboard?
AFT100:	KSN
	JMP KBDINT
; not keyboard, maybe refresh?
	SSN
	DSN
	JMP INTXIT

; here for refresh interrupt
	LAC [DORIG]
	JMS DSTART		; restart display
	ISZ COUNTR

TAUTO:	ISZ TICKER		; tick bomb
	JMP GLV
	CLA			; it exploded here
	KRB			; get current keyboard
	SAM KCHAR		; see if key held down long enough
	JMP GLV			; no
	LWC 1
	DAC TICKER
	LAC [JMP CONTIN]
	DAC LOOPY		; impure dispatch, the only way !!
GLV:	JMP RESTRZ
DUD:	ISZ TWITCH		; tick the twitchy
	JMP RESTRZ		; normal restore
	LWC 12
	DAC TWITCH		; reset the twitch ticker
	LAC @[DCURT]		; twitch the twtichy
	XOR [DJMP DFORM#DNOP,]
	DAC @[DCURT]

; here for various clock-related hackery
RESTRZ:	ISZ BELCNT
	 JMP INTXIT
	LAC [DNOP]
	DAC @[DBELL]

; restore ac, link, and return
INTXIT:	LAC LSAVE		; restore program control
	RAL 1
	LAC ASAVE
	ION
	JMP @0

KBDINT:	CAL
	KRC
	DAC @KIPTR
	LAC KIPTR
	SAM [KBDEND]
	JMP .+2
	LAC [KBDBUF-1]
	IAC
	DAC KIPTR
	SAM KOPTR
	JMP INTXIT
	JMS DONG
	LAW REF
	JMS ARMER
	JMP INTXIT

INTBIT:	0
ASAVE:	0
LSAVE:	0
TICKER:	0
BELCNT:	0
TWITCH:	-12

; initialization routine, go here on 101 start
INITA:	0			; subroutine init call point
	JMS TECCLR		; kill macroage

GO101:	JMS UCASE		; get in upper case mode
	JMS ATON		; get in auto repeat mode
	JMS CLRS		; clears the screen
	JMP GOBOTH

; continuation routine
GO100:	LAW [0]			; fweep interrupt (IMLAC says it helps)
	JMS DSTART		; start display
	DOF			; and then turn off for power up

; reset int handler and enable interrupts
GOBOTH:
IFN GRAPH, JMS XCLEAR		; flush pending graphics input
	LAC [DAC ASAVE]
	DAC 1
	LAC [RAR 1]
	DAC 2
	LAC [DAC LSAVE]
	DAC 3
	LAC [CLA]
	DAC 4
	LAC [KBDBUF]
	DAC KIPTR
	DAC KOPTR
	IOF
	LAW REF\KBD		; screen refresh interrupt/keyboard int.
	JMS ARMER
	ION

; main loop
LOOPY:	JMS KEYIN		; read keystroke
	RSN			; skip no tty
TTYRED:	JMS TTYIN		; read tty character
	JMP LOOPY		; loop

IFN GRAPH, JGRFIN:	JMS GRFIN		; used by graphics readin hacker

; clear the screen
CLRS:	0
	CLA
	DAC LINPOS		; pointing at the first line
	DAC LINCNT
	DAC CHRPOS		;  and first character
	XAM @[DBLOCK]		; clear screen for real!
	DAC BLKINS
; reinitialize screen buffer
	LAC [DOVERP-1]		; start of overprint buffer
	DAC 17
	LWC 1
	ADD TOPLIN		; start of line buffer
	DAC 10
	JMS CLRLNS
	JMS NEWPNT		; fix up pointers to line and char position
	JMS PUTCUR		; put cursor into dlist
; now unblock dlist
	LAC BLKINS		; unblocking instruction
	DAC @[DBLOCK]
	JMP @CLRS

; clear several lines
CLRLNS:	0
CLRSL:	LAC @10			; get part of line buffer
	ASN			; done?
	 JMP @CLRLNS		;  yes, return
	SAM [DJMS DCRLF,]	; don't touch crlfs
	 JMP .+2		;  not a crlf
	  JMP CLRNXT		;  crlf, loop
; set up to reinitialize a line
	JMS JMSADR		; turn into an address
	SUB [1]			; point at character count
	DAC TMP			; line's character count
	DAC 11			; place for cursor
	IAC
	DAC 12			; place for DRJM
	CLA			; zero character count
	DAC @TMP		;  no characters on this line
	ISZ TMP
	LAC [DRJM]
	DAC @TMP		; block the list
; reinitialize line
	LAC [DRJM]		; and a return
	DAC @12
	LAC DEOL		; put out a crlf
	DAC @11			; which unblocks the list
; check for wrap-around
CLRNXT:	LAC 10
	SAM [DEND-1]
	 JMP CLRSL
	LAC [DLINES-1]
	DAC 10
	JMP CLRSL

; insert the cursor into the display
PUTCUR:	0
	LAC @CHRPNT
	DAC @[DCURCH]
	LAC [DJMS CURSOR,]
	DAC @CHRPNT
	JMP @PUTCUR

; remove the cursor from the display
GETCUR:	0
	LAC @[DCURCH]
	DAC @CHRPNT
	JMP @GETCUR

CLZERO:	0
	CLA
	DAC CHRPOS
	JMP @CLZERO

; move cursor to end of dlist
HOME:	0
	JMS DNAR
	 JMP .-1
	JMS EOL
	JMP @HOME

; move cursor to start of dlist
HOMEUP:	0
	JMS UPAR
	 JMP .-1		; left arrow forever
	JMP @HOMEUP

; set up pointers and such
NEWPNT:	0
	LAC LINPOS
	JMS MAKPNT
; fix up stupid margin arrow
	LAC LINPOS
	SAL 2			; multiply by LSIZE (==21.)
	ADD LINPOS
	SAL 2
	ADD LINPOS
	CIA
	ADD [DLYA TOP,]
	DAC @[DARROW]
; make new chrpnt
	LAC @LINPNT
	JMS JMSADR
	ADD CHRPOS
	DAC CHRPNT
	JMP @NEWPNT

MAKPNT:	0
	SAL 1
	ADD TOPLIN
	SUB [DEND]
	ASP
	 JMP .+3
	  ADD [DLINES]
	  JMP .+2
	   ADD [DEND]
	DAC LINPNT
	JMP @MAKPNT

; move cursor to start of previous line
UPAR:	0
	LAC LINPOS
	ASN
	 JMP UPAR1		; on first line, see if at beg of it
	JMS GETCUR
	JMS CLZERO		; zero column position
	LWC 1
	ADD LINPOS
	DAC LINPOS		; decrement line position
	JMS NEWPNT		; set up new curpnt0 and linpnt
	JMS PUTCUR
	JMP @UPAR

; here if already on line 1
UPAR1:	JMS LBEG		; move to beg if haven't yet
UPSKIP:	ISZ UPAR		; skip in any case
	JMP @UPAR

; move cursor to start of current line
LBEG:	0
	LAC CHRPOS
	ASN
	 JMP @LBEG
	JMS GETCUR
	JMS CLZERO
	LAC @LINPNT
	JMS JMSADR
	DAC CHRPNT
	JMS PUTCUR
	JMP @LBEG

; move cursor to end of current line (more or less)
EOL:	0
	JMS HOWIDE
	SAM CHRPOS
	 JMP .+2
	JMP @EOL
	DAC CHRPOS
	JMS GETCUR
	JMS NEWPNT
	JMS PUTCUR
	JMP @EOL

; down a line
DNAR:	0			; line feed routine
	LAC LINPOS
	SAM LINCNT
	 JMP .+3
	  ISZ DNAR
	  JMP @DNAR
	JMS LNFD
	JMP @DNAR

SUBTTL Line-feed and Scrolling

; move to a new line and clear it
NEWLIN:	0
	JMS LNFD
	JMS DELRT
	JMP @NEWLIN

; insert a linefeed
LNFD:	0
	JMS GETCUR		; flush the cursor
	JMS CLZERO		; column zero
	LAC LINCNT		; increment line count if on last line
	SAM LINPOS
	 JMP LNFD1
; increment line count
	ISZ LINCNT
	LAC LINCNT
	SAM [SCREEN]		; overflow screen?
	 JMP LNFD1

; here to scroll ten lines
	LWC SCROLL		; amount to scroll
	DAC LOOPR
; here to scroll one line off of top of screen
LNSCR:	LAC @[DBLOCK]		; pick up djmp to line buffer
	JMS JMSADR		; convert to address of first line
	DAC 10			; index ptr to crlf of top line
	ADD [2]			; two for crlf's, natch
	SAM [DEND]		; wrap?
	 JMP .+2
	  LAC [DLINES]		; when wraps, move back to top
	DAC TOPLIN
	JMS ADRJMP		; convert back to djmp
	DAC @[DBLOCK]		; and stuff it out -- old top is now gone
; now fix up two locs that are out of dlist
	CLA			; pick up dhlt
	DAC @10			; clobber crlf of old line one
	LWC 2
	ADD 10
	DAC 10			; index ptr to previous line
	SAM [DLINES-1]		; want ptr to where dhlt used to be
	 JMP .+2
	  LAC [DEND-1]
	DAC LTMP		; ptr to old dhlt
	JMS CLRLNS		; clear top line
	LAC [DJMS DCRLF,]	; clobber old dhlt with crlf
	DAC @LTMP
; update pointers
	LWC 1
	ADD LINCNT
	DAC LINCNT		; one less line on screen
	LWC 1
	ADD LINPOS
	DAC LINPOS		; logical line pos is one less
	ISZ LOOPR		; loop?
	 JMP LNSCR		;  scroll some more

; clean up pointers and return
LNFD1:	ISZ LINPOS		; increment line number
	JMS NEWPNT		; update pointers
	JMS PUTCUR		; put cursor back
	JMP @LNFD

; rub out the column to the left of the cursor
RUBLFT:	0
	LAC CHRPOS
	ASN
	 JMP @RUBLFT
	JMS LFAR		; move back over it
	JMS RUBOUT		; rub it out
	JMP @RUBLFT

; rub out the column to the right of the cursor
RUBOUT:	0
	LAC @[DCURCH]
	SAM DEOL
	 JMP .+2
	  JMP @RUBOUT
	LAC [DJMS D040,]
	DAC @[DCURCH]		; part of cursor
	JMP @RUBOUT

; insert a character at the current column position
INSERT:	0
	DAC INTMP		; save new character
	LAC @[DCURCH]		; pick up character from current cursor pos
	SAM DEOL		; if its crlf we are at end of line
	 JMP INSER1		;  not at end just clobber over current char
; insert at eol
	LAC [DRJM]	; it looks like cursor and crlf
	DAC @CHRPNT		; replace cursor with dummy
	LAC CHRPNT		; get pointer to cursor location
	DAC 10
	LAC [DJMS CURSOR,]
	DAC @10			; now output new cursor
	LAC [DRJM]		; and new return
	DAC @10
	LAC INTMP		; pick up new character
	DAC @CHRPNT		; stuff out old character
; increment cursor position variables
	ISZ CHRPNT		; character position
	ISZ CHRPOS
	JMS HOWIDE		; get pointer to number of chrs on line
	ISZ @LINWID		; increment count of characters on line
	SAM [LINE]		; is it up to the max yet?
	 JMP @INSERT		;  no, return
	JMS LBEG		; otherwise, go back to beg. of line
	JMP @INSERT

; here to write over an existing position
INSER1:	JMS ROOM
	 JMP INSER9
	LAC INTMP		; pick up character we are inserting
	SAM [DJMS D040,]	; space? blech, waste of time
	 JMP .+2		;  not space
	  JMP INSER2
	LAC @[DCURCH]		; pick up character we are overprinting
	SAM [DJMS D040,]	; space? blech, waste of time
	 JMP .+3
; here to just clobber the character -- either no room or char is space
INSER9:	  LAC INTMP		; just clobber the space, no one will notice
	  JMP INSER3
; same character?
	SAM INTMP		; no double-printing allowed!
	 JMP .+2
	  JMP INSER2		; just move over frob
; 17 now points to before new hack; either we are making a new overprint
; hack or extending an old one.  time to find out...
	JMS JMSADR		; convert to address
	DAC INTMP1
	SUB [DOVERP]		; start of overprint buffer
	ASP			; check if already overprint char
	 JMP INSER4		;  nope, tasteful single character

; here if adding more overprinting to one already there
INSER7:	LAC @INTMP1
	SAM INTMP		; eschew superfluity!
	 JMP .+2
	  JMP INSER2
	SAM [DRJM]		; return?
	 JMP INSER6
	LAC 17			; make a djmp to new area
	IAC
	JMS ADRJMP		; and save it til end
	DAC TMP
	JMS INOVER		; do boring inserts
	LAC TMP			; now link them up
	DAC @INTMP1
	JMP INSER2		; and then move right and exit
; move to next character in trail
INSER6:	ISZ INTMP1
	JMP INSER7

; here for new overprinting
INSER4:	LAC @[DCURCH]		; put out new character
	DAC @17			; here put out beginning of overprint hack
	LAC 17
	JMS ADRJMS		; make DJMS for insertion
	DAC TMP
	JMS INOVER
	LAC TMP
INSER3:	DAC @[DCURCH]
INSER2:	JMS RTAR
	JMP @INSERT

; drudgery of overprinting
INOVER:	0
	LAC [DJMS D010,]
	DAC @17
	LAC INTMP
	DAC @17
	LAC [DRJM]
	DAC @17
	JMP @INOVER

ROOM:	0
	LWC 4
	ADD BUFEND
	SUB 17
	ASP			; must be at least four characters room
	 JMP .+3
	  ISZ ROOM
	  JMP @ROOM
; feep if first time
	LAC 17
	SAM BUFEND
	 JMS DONG
	LAC BUFEND
	DAC 17
	JMP @ROOM

SUBTTL Absolute Positioning Routine

; old reversed argument absolute position (for "Imlacs")
OABPOS:	0
	JMS TGET
	SUB [1]
	DAC CHRNEW
	JMS TGET
	SUB [1]
	DAC LINNEW
	JMS IABPOS
	JMP @OABPOS

; four argument absolute position, ignore first two args ("Software")
NABPOS:	0
	JMS TGET
	JMS TGET
	JMS ABPOS
	JMP @NABPOS

; absolute position to a given column and row coordinate ("Software")
ABPOS:	0			; absolute positioning routine
	JMS TGET
	SUB [1]
	DAC LINNEW		; new line position
	JMS TGET
	SUB [1]
	DAC CHRNEW		; new column position
	JMS IABPOS
	JMP @ABPOS

IABPOS:	0
; after reading args, must see what sort of move needed
	LAC LINNEW
	SAM LINPOS		; already on correct line?
	 JMP ABNEW		;  nope, must move cursor
	LAC CHRNEW
	SAM CHRPOS		; already at correct column position
	 JMP ABNEW
	JMP @IABPOS		; what a win, we're already there
; here have to move the cursor
ABNEW:	JMS GETCUR		; flush cursor from display
	LAC LINNEW
	DAC LINPOS		; move to new line
	JMS MAKPNT
	LAC LINCNT
	SUB LINNEW		; update line count if necessary
	ASM
	 JMP ABNEW1
	LAC LINNEW
	DAC LINCNT
; here for destination line
ABNEW1:	JMS HOWIDE		; first must find out if enough chars on line
	DAC LOOPR		; save size of line for now
	SUB CHRNEW		; subtract where on line we want to go
	ASM			; must line be expanded?
	 JMP ABPOS1		;  needn't grow line
	XAM LOOPR		; pick up width of line
	DAC CHRPOS		;  and use it to go to end of line
	JMS NEWPNT		; fix up pointers
	JMS PUTCUR		; and put cursor out
ABEXP:	LAC [DJMS D040,]	; add spaces to grow line
	JMS INSERT
	ISZ LOOPR
	 JMP ABEXP
	JMP @IABPOS

; here when position already exists
ABPOS1:	LAC CHRNEW
	DAC CHRPOS
	JMS NEWPNT		; fix up pointers
	JMS PUTCUR		; reinsert cursor
	JMP @IABPOS

; get number of chrs on line
;  returns width of line, and sets up LINWID as pointer to cell containing width
HOWIDE:	0
	LAC @LINPNT
	JMS JMSADR
	SUB [1]
	DAC LINWID
	LAC @LINWID
	JMP @HOWIDE

; clear to eof
DELDN:	0
	JMS DELRT	; clear rest of this line
	LAC LINPOS	; pick up which one we are on
	DAC LINCNT	; that's how many there will be
	LAC LINPNT	; where to start flushing
	DAC 10
	JMS CLRLNS	; flush a bunch of lines
	JMP @DELDN

; clears the current line
LDELT:	0
	JMS LBEG	
	JMS DELRT
	JMP @LDELT

; clear to eol
DELRT:	0
	LAC [DRJM]		; pick up line ender
	DAC @CHRPNT		; stuff it where cursor is
	LAC CHRPNT		; now put a return
	DAC 10			;  out in the next location
	LAC [DRJM]		;  of the 
	DAC @10			;  dlist
	LAC DEOL		; and then drop a crlf back
	DAC @CHRPNT		; back in on top of the CURCRL
	JMS HOWIDE		; set up pointer to line size
	LAC CHRPOS		; it is now same as position
	DAC @LINWID
	JMS PUTCUR		; put back cursor
	JMP @DELRT

; transmit a character
XMIT:	0
	TSF
	 JMP .-1
	TPC
XMITC:	JMP @XMIT		; changes for graphics xmit
	JMP @XMIT

JCLEAR:	JMS XCLEAR

; tell me about yourself....
INQUIR:	0
	LAW %VERSIO+40
	JMS XMIT
	LAW %TYPE
	JMS XMIT
	JMP @INQUIR

; what line is cursor on?
LINNUM:	0
	LAW 40
	ADD LINPOS
	JMS XMIT
	JMP @LINNUM

CHRNUM:	0
	LAW 40
	ADD CHRPOS
	JMS XMIT
	JMP @CHRNUM

; make a djmp (or djms) into an address
JMSADR:	0
	AND [107777]		; get rid of no.6 bit
	ASP
	 XOR [110000]		; transfer the 10000 bit
	JMP @JMSADR

; make an address into a djms
ADRJMS:	0
	SUB [010000]
	ASM
	 ADD [070000]
	ADD [060000]
	JMP @ADRJMS

; make an address into a djmp
ADRJMP:	0
	SUB [010000]
	ASM			; skips if < 10000
	 ADD [070000]
	ADD [070000]
	JMP @ADRJMP

; routine to insert "right" tab
TABR:	0
	LAW 10
	ADD CHRPOS
	AND [77]
	SUB CHRPOS
	CIA
	DAC LOOPR
TABRL:	LAC [DJMS D040,]
	JMS INSERT
	ISZ LOOPR
	 JMP TABRL
	JMP @TABR

; tty character readin routine
TGET:	0
	RSF
	 JMP .-1
	CLA
	RRC
	AND [177]
IFN TRACE, XGET: JMP @TGET	; or JMS @XSVDSP
	JMP @TGET

IFN TRACE, XSVDSP: XSVLIN		; add to "wholine"

; insert TECO cursor in buffer
TECURS:	0
	LAC [DJMS XFORM,]
	JMS INSERT
	JMP @TECURS

SPACE:	0
	LAC @[DCURCH]
	SAM DEOL
	 JMP SPACE1
	LAC [DJMS D040,]	; yes, must insert space
	JMS INSERT
	JMP @SPACE
SPACE1:	JMS RTAR
	JMP @SPACE

; move cursor one column right
RTAR:	0
	LAC @[DCURCH]		; look at character cursor is at
	SAM DEOL		; crlf?
	 JMP RTAR1		;  no, just move
	JMP @RTAR		; and return
; here for rtar within line
RTAR1:	JMS GETCUR		; pick up cursor
	ISZ CHRPOS		; aos character position
	ISZ CHRPNT
	JMS PUTCUR
	JMP @RTAR

; move cursor one column left
LFAR:	0
	LAC CHRPOS
	ASN
	 JMP @LFAR
	JMS GETCUR
	LWC 1
	ADD CHRPOS
	DAC CHRPOS
	LWC 1
	ADD CHRPNT
	DAC CHRPNT
	JMS PUTCUR
	JMP @LFAR


; feeeeepppppp!!!!!
DONG:	0
	BEL
	LAC [DJMS BIGBEN,]
	DAC @[DBELL]
	LWC 20
	DAC BELCNT
	JMP @DONG

; leave graphix mode -- ascii 34
; ignore cretinous 34's -- outside graph conditional

JMSNOP:	0
	JMP @JMSNOP

SUBTTL Movable Right Margin


; toggle line at 70 character paper margin
EDITLN:	0
	LAC @[DEDLIN]
	XOR [DNOP#<DJMS LINE70,>]
	DAC @[DEDLIN]
	LAW 70.
	DAC EDTPOS
	LAC [DXPOS 70.,]
	DAC @[LINELX]
	JMP @EDITLN

EDTPOS:	0

EDTLFT:	0
	LWC 1
	ADD EDTPOS
	ASP
	 JMP @EDTLFT
	DAC EDTPOS
	LWC CSIZE
	ADD @[LINELX]
	DAC @[LINELX]
	JMP @EDTLFT

EDTRGT:	0
	LAC EDTPOS
	SAM [LINE-2]
	 JMP .+2
	  JMP @EDTRGT
	ISZ EDTPOS
	LAW CSIZE
	ADD @[LINELX]
	DAC @[LINELX]
	JMP @EDTRGT

SUBTTL MUDDLE movement commands

IFN MUDDLE,[ ; begin MUDDLE conditional

; MUDDLE movement commands

; push ac onto stack -- skip if no overflow
PUSH:	0
	ISZ PDL			; inc. pdl ptr
	ISZ PDLSIZ		; inc. pdl counter
	DAC @PDL		; stuff out ac
	LAC PDLSIZ
	SAM [40]		; fail to skip if overflow
	 ISZ PUSH
	JMP @PUSH

; pop off stack into ac
POP:	0
	LWC 1			; subtract one from pdl pointer
	ADD PDL
	DAC PDL
	LWC 1			; subtract one from pdl count
	ADD PDLSIZ
	DAC PDLSIZ
	ASM			; fail to skip on underflow
	 ISZ POP
	LAC @PDL		; get word to return
	JMP @POP

PREV:	0
	LAC CHRPOS
	ASN
	 JMP PREV1
	LWC 1
	ADD CHRPNT
	DAC TMP
	LAC @TMP
	JMP @PREV
PREV1:	LAC DEOL
	JMP @PREV

; look for bracket character, skip if not found
BSERCH:	0
	LWC 4
	DAC LOOP
	LAC SCHAR
BSLUP:	SAM @SRCPTR		; same?
	 JMP BSLUP1
	LAC MOVER
	SAM [MLFAR]
	 JMP BSXIT1		; return
	JMS PREV
	SAM [DJMS D041,]
	 JMP BSXIT1
	ISZ LOOP
	LAC @TMP
	SAM [DJMS D042,]
	 JMP BSXIT1
	JMP BSXIT

BSXIT1:	LAC @SRCPTR		; must return crock found
	JMP @BSERCH

BSLUP1:	ISZ SRCPTR		; move to next
	ISZ CMPPTR
	ISZ LOOP		; done?
	 JMP BSLUP		; no, loop
; done, skip return, none found
BSXIT:	ISZ BSERCH
	JMP @BSERCH

; look at next character (or one we moved over)
;  skip: 0 -- nothing
;	 1 -- "open"
;	 2 -- "close"
;	 3 -- "
;	 4 -- !"?
XSERCH:	0
	LAC [DJMS D134,]
	JMS BSQ			; character preceded by backslash?
	 JMP XSERC0		;  yes, ignore it
	LAC SCHAR
	SAM DEOL
	 JMP .+2
	  JMP @XSERCH
	SAM [DJMS D040,]
	 JMP .+2
	  JMP @XSERCH
XSERCB:	LAC TPUSH		; pointer to pushing brackets
	DAC SRCPTR
	LAC TPOP		; pointer to popping brackets
	DAC CMPPTR
	JMS BSERCH		; search for "opens"
	 JMP XSERC1		; found one
	JMS BSERCH
	 JMP XSERC2		; found one
; no brackets, maybe \" or !" ??
	LAC SCHAR		; look at argument char
	SAM [DJMS D042,]	; is it double-quote?
	 JMP XSERC0		;  no, go check for invisible char
; found double-quote, look for ! preceding it
	LAC [DJMS D041,]
	JMS BSQ			; " preceded by exclamation point?
XSERC4:	 ISZ XSERCH		;  yes, four skips

XSERC3:	ISZ XSERCH		; ordinary ", three skips
XSERC2:	ISZ XSERCH		; right bracket, two skips
	LAC @CMPPTR
XSERC1:	ISZ XSERCH		; left bracket, one skip
XSERC0:	ISZ XSERCH		; normal character
	JMP @XSERCH		; spacer

; search for a ", skip if found
QSERCH:	0
	JMS @MOVER
	 JMP @QSERCH		; eof, quit
	SAM [DJMS D042,]	; found it?
	 JMP QSERCH+1		; loop until found
	LAC [DJMS D134,]	; backslash?
	JMS BSQ
	 JMP QSERCH+1		; yes
	ISZ QSERCH		; no
	JMP @QSERCH

; look for <argument> one back (for \" and !")
; skip if not found
BSQ:	0
	DAC TMP			; save arg
	LAC MOVER
	SAM [MLFAR]		; moving left?
	 JMP BSQRT
	LAC @[DCURCH]
BSQ1:	SAM TMP			; same?
BSQ2:	 ISZ BSQ		; no, skip
	JMP @BSQ		; yes, no skip
BSQRT:	LWC 2
	ADD CHRPOS
	ASP
	 JMP BSQ2
	LWC 2			; moving right, back two
	ADD CHRPNT
	DAC LOOP
	LAC @LOOP
	JMP BSQ1

SUBTTL MUDDLE Movement Setup Routines

; routine to move to first visible character in current direction
; if it is not a bracket, moves over contiguous visible characters to just
; before next invisible character.
;  no skip return if first character found was a bracket
;  skip return if first was not a bracket
VSFLAG:	0

VSTART:	0
; initialize sign
	LAC [DNOP]		; clear sign
	DAC @[DMAT]
VSLOOP:	JMS @MOVER		; get next character
	 JMP VSEXI1
	JMS XSERCH		; no, but is it a bracket?
	 JMP VSLOOP		;  spacer
	 JMP VSIBEG		;  visible char
	 JMP VSINIT		;  left bracket
	 JMP VSINIT		;  right bracket
	 JMP VSINIT		;  double quote
VSINIT:	ISZ VSFLAG		;  excl "
	 JMP VSEXIT
VSEXI2:	JMS @BACKER		; here for general non-skip return
	JMP @VSTART		;  yes, bracket, so don't skip
; here if first visible character wasn't any sort of bracket
VSIBEG:	LAC VSFLAG		; first see if want to move over it
	ASM			; if negative, moving over it
	 JMP VSEXIT		;  exit, just moving up to it
; if moving right, move over random syntactic sugar
	LAC MOVER		; if we are moving to the right
	SAM [MRTAR]		;  then we want to move over all syn. sugar
	 JMP VSIBE1		;   not moving right
	JMS MSUGAR		; move over syntactic sugar
	 JMP VSLOOP		;  and try again if find some
VSIBE1:	ISZ VSFLAG		; skip if really want to move over it
	 JMP VSEXIT		;  no, just moving to it
; move over body of non-structure
VSILUP:	JMS @MOVER		; move over visible character
	 JMP VSEXI1		;  end of file
	JMS XSERCH		; bracket?
	 JMP VSEXIT		;  spacer
	 JMP VSILUP		;  nope, randomness
	 JMP VSEXIT		;  left bracket
	 JMP VSEXIT		;  right bracket
	 JMP VSEXIT		;  quote
	JMS @MOVER
	 JMP .+2
	JMP VSILUP

VSEXIT:	JMS @BACKER
VSEXI1:	ISZ VSTART		;  not a bracket, skip return
	JMP @VSTART

; setup for movement to left
;  moves to first non-invisible character, and over atom if that's
;  what it begins.  skip returns if first is bracket.
SLEFT:	0
	DAC VSFLAG
	LAC [MLFAR]		; mover is LFAR
	DAC MOVER
	LAC [BRTAR]
	DAC BACKER
	LAC [SRCCMP]		; "closes" push
	DAC TPUSH
	LAC [SRCTAB]		; "opens" pop
	DAC TPOP
	JMS VSTART		; move to first visible character
	 ISZ SLEFT		; vstart skips if its not a bracket
	JMP @SLEFT

; setup for movement to right
;  moves to first non-invisible character, and over atom if that's
;  what it begins.  skip returns if first is bracket.
SRIGHT:	0
	DAC VSFLAG
	LAC [MRTAR]		; mover is RTAR
	DAC MOVER
	LAC [BLFAR]
	DAC BACKER
	LAC [SRCTAB]		; "opens" push
	DAC TPUSH
	LAC [SRCCMP]		; "closes" pop
	DAC TPOP
	JMS VSTART		; move to first visible character
	 ISZ SRIGHT		;  no skip if its a bracket
	JMP @SRIGHT		;  skips if its anything else

SUBTTL MUDDLE Front, Back, and Up

; move to front
MF:	0
	LWC 1
	JMS SLEFT		; set up to move left
	 NOP
	JMS MFUB		; find "unbalanced close"
	JMS RTAR		; and move right over it
	JMP @MF

; move to back
MB:	0
	LWC 1
	JMS SRIGHT		; set up to move right
	 NOP
	JMS MFUB		; find "unbalanced close"
	JMS LFAR		; and move left over it
	JMP @MB

; move up
MU:	0
	LWC 1
	JMS SLEFT		; set up to move left
	 NOP
	JMS MFUB		; find "unbalanced close"
	 NOP
	JMS MSUGAR
	JMP @MU
	JMP @MU

; does move (right or left) until "unbalanced close" is found
MFUB:	0
MFUB1:	JMS MRL			; move!
	 JMP .+3
	  ISZ MFUB		; no error, return w. skip
	  JMP @MFUB
	ASN			; balanced?
	 JMP MFUB1		; yes, loop
	SAM [4]			; underflow?
	 JMP .+2		; no, lose
	CLA			; yes, win
	JMS MOVMES
	JMP @MFUB

; move down
MD:	0
	LWC 1
	JMS SRIGHT		; setup to move right
	 NOP
MD1:	JMS @MOVER		; move over next character
	 JMP MBOT		; eof is bottom
	JMS XSERCH		; find bracket
	 JMP MD1
	 JMP MD1		; random, loop
	 JMP @MD		; left bracket == win!
	 JMP MBOT		; right bracket == bottom level
	 JMP MDQ		; "
	JMS @MOVER		; !"
	 JMP MBOT
	JMP MD1

MDQ:	JMS QSERCH		; quote == find other side
	 JMP MDUN		; no other side, underflow
	JMP MD1			; try again

; error -- underflow
MDUN:	LAW 1
	JMP MDMES
; error -- bottom level
MBOT:	JMS LFAR
	LAW 5
MDMES:	JMS MOVMES
	JMP @MD


; move right
CMR:	0
	CLA
	JMS SRIGHT
	 JMP @CMR
	JMP @CMR

MR:	0
	LWC 1
	JMS SRIGHT		; set up to move right
	 JMP @MR		;  no skip if first object was atomic
	JMS MRL
	 NOP
	ASZ
	 JMS MOVMES
	JMP @MR

; move left
CLNML:	0
	CLA
	JMS SLEFT
	 JMP @CLNML
	JMP @CLNML

ML:	0
	LWC 1
	JMS SLEFT		; set up to move left
	 JMP @ML		;  no skip if first object was atomic
	JMS MRL			; do it
	 NOP
	ASZ
	 JMP MLLOSE
	JMS MSUGAR
	JMP @ML
	JMP @ML
MLLOSE:	JMS MOVMES		; display message if any
	JMP @ML

; here for movement over syntactic sugar
;  skip if none found
SFLAG:	0	; count of sugar characters found

MSUGAR:	0
	CLA
	DAC SFLAG
MSUINI:	LAC [SUGAR-1]
	DAC 10
	LWC SUGSIZ
	DAC LOOPX
	JMS @MOVER
	 JMP MSEXIT
MSULUP:	LAC SCHAR
	SAM @10
	 JMP MSUNXT
	ISZ SFLAG
	JMP MSUINI
MSUNXT:	ISZ LOOPX
	 JMP MSULUP
	JMS @BACKER
MSEXIT:	LAC SFLAG
	ASN
	 ISZ MSUGAR
	JMP @MSUGAR

; magic move right or left hacker
; skip if EOF, returns code otherwise
MRL:	0
; initialize pdl
	CLA
	DAC PDLSIZ		; size is 0
	LAC [PDLBUF-1]
	DAC PDL			; pointer is to pdl

; search for bracket
MSERCH:	JMS @MOVER		; either left or right arrow
	 JMP MEOF		; EOF, just return
	JMS XSERCH
	 JMP MSERCH
	 JMP MSERCH		; nothing exciting
	 JMP MLEFT		; "open"
	 JMP MRIGHT		; "close"
	 JMP MQUOTE
	LAC MOVER		; if moving right skip char after !"
	SAM [MLFAR]
	 JMP .+2
	  JMP MSERCH
	JMS @MOVER
	 JMP MEOF
	JMP MSERCH

; quote
MQUOTE:	JMS PUSH
	 JMP MOVERF
	JMS QSERCH
	 JMP MEOF
	JMP MRLOOP

; found left bracket
MLEFT:	JMS PUSH		; push it
	 JMP MOVERF		; pdl overflow
	JMP MSERCH		; and loop

; found right bracket
MRIGHT:	SAM @PDL		; same as top of stack?
	 JMP MISMAT		; no, mismatch

MRLOOP:	JMS POP			; same, pop stack
	 JMP MUNDER		; pdl underflow, ssv bug!
	LAC PDLSIZ		; size of pdl
	ASZ			; if, zero, empty, done
	 JMP MSERCH		; loop
	JMP MWIN

; end of dlist
MEOF:	LAC PDLSIZ
	ASZ
	 JMP MUNMAT		; if cruft on pdl, unmatched
	ISZ MRL			; else just skip return

; here to terminate and return various numerical results
MWIN:	CLA			; 0 == no problems
	JMP @MRL
MUNMAT:	LAW 1			; 1 == unmatched
	JMP @MRL
MISMAT:	LAC PDLSIZ		; 2 == mismatched
	ASN
	 JMP MUNDER
	LAW 2
	JMP @MRL
MOVERF:	LAW 3			; 3 == pdl overflow
	JMP @MRL
MUNDER:	LAW 4			; 4 == pdl underflow
	JMP @MRL

; display a sign -- take offset in sign table from tty
NEON:	0
	JMS TGET		; get a character
	AND [7]
	JMS MOVMES		; display message
	JMP @NEON

; display a sign
MOVMES:	0
	ADD [MMTAB]
	DAC TMP
	LAC @TMP
	DAC @[DMAT]
	JMP @MOVMES

; muddle-only variables

MOVER:	MRTAR		; either LFAR or RTAR
BACKER:	BLFAR
CMPPTR:	0
PDL:	PDLBUF		; pdl for m.m. to use
PDLSIZ:	0		; how much of pdl is left
SCHAR:	0
SRCPTR:	0
TPOP:	0
TPUSH:	0

MRTAR:	0
	LAC @[DCURCH]
	DAC SCHAR
	SAM DEOL
	 JMP MRTAR1
	JMS DNAR
	 JMP MRTAR2
	JMP @MRTAR
MRTAR1:	JMS RTAR
MRTAR2:	LAC SCHAR
	ISZ MRTAR
	JMP @MRTAR

MLFAR:	0
	LAC CHRPOS
	ASZ
	 JMP MLFAR1
	LAC LINPOS
	ASN
	 JMP @MLFAR
	JMS UPAR
	JMS EOL
	 JMP MLFAR2
MLFAR1:	JMS LFAR
MLFAR2:	LAC @[DCURCH]
	DAC SCHAR
	ISZ MLFAR
	JMP @MLFAR

BRTAR:	0
	JMS MRTAR
	JMP @BRTAR
	JMP @BRTAR

BLFAR:	0
	JMS MLFAR
	JMP @BLFAR
	JMP @BLFAR

; table of interesting characters for m.m. commands
; the character plus 4 is always the matching character
SUGAR:	DTXT [.,;'!]
SUGSIZ==.-SUGAR

SRCTAB:	DJMS D074
	DJMS D050
	DJMS D133
	DJMS D173

SRCCMP:	DJMS D076
	DJMS D051
	DJMS D135
	DJMS D175

	DJMS D074
	DJMS D050
	DJMS D133
	DJMS D173
]

SUBTTL Keyboard Macros

; get keystroke being defined
TECKEY:	0
	JMS TGET	; bits 5-8
	SAL 3
	SAL 3
	SAL 1
	DAC TECTMP
	JMS TGET	; bits 9-15
	IOR TECTMP
	AND [17777]	; remove extraneous bits
	SAM KINIT	; naughty, naughty, can't redefine INIT!
	 ISZ TECKEY
	JMP @TECKEY

; here to define a keystroke as one or two characters to be sent:
; ^A ^E <cnt><k1><k2><ch1><ch2>...
TECMAC:	0
	LAC TECPTR
	SAM [CRIKY]	; check for macro table full
	 ASN		;  or no table allocated
	  JMP TECBKT	; table full, ignore rest of characters
	JMS TECKEY	; read a keystroke
	 JMP TECBKT	; go ignore rest of characters
	JMS TECLUK	; see if already has a definition
	 JMP TECRED	; already defined, kill old definition
	 JMP TECRED	; ditto if defined and off
; here to make a new definition
TECNRM:	DAC @TECPTR	; keystroke
	ISZ TECPTR
	LAC [DJMS D053,]
	DAC @[DMACRO]
	LAC TECPTR
	SAM [CRIKY]
	 JMP TECCNT	; room for definition
	  CLA		; no room, clear keystroke
	  DAC @TECPTR	; and go throw rest in bit bucket
	  JMP TECBKT
; set up count of definition characters
TECCNT:	JMS TGET	; read count of characters to come
	CIA
	DAC LOOP	; character count
; here to get definition
TECLIN:	JMS TGET	; first character of a definition word
	IOR [100000]	; always turn on sign bit
	SAL 3
	SAL 3
	SAL 2
	DAC TECTMP	; save it away
	CLL		; link on indicates last char
	ISZ LOOP
	 JMP TECTWO	; not last character
; here if definition odd number of chars long -- fake it
	LAW "~		; useless character?
	JMP TECOUT

TECTWO:	JMS TGET	; get second character of defn word
	IOR [200]
	ISZ LOOP	; counted out?
	 JMP .+2	; nope
TECOUT:	  STL		; here set link, counted out
	IOR TECTMP
	DAC @TECPTR	; output two chars of defn
; increment table pointer and see if table full
	LAW 1
	ADD TECPTR
	SAM [CRIKY]
	 JMP .+3
	  JMS DONG	; table full, complain
	  JMP TECSKP	; but finish reading
	DAC TECPTR
	CLA		; zero entry after last used -- signals end
	DAC @TECPTR
TECSKP:	LSN		; counted out?
	 JMP TECLIN	; no, loop
	JMP @TECMAC

; here to kill a current definition of a character
TECRED:	LAC 10
	DAC TECTMP
	LAW 1		; can't be gotten, since all have 200 bit on
	DAC @TECTMP
	LAC TEM1
	JMP TECNRM	; now go define new version

; here after error or table full
TECBKT:	JMS TGET	; throw characters into bit bucket
	CIA
	DAC LOOP	; read a bunch of characters
	JMS TGET
	ISZ LOOP
	 JMP .-2
	JMS DONG	; feep at loser
	JMP @TECMAC

; look up a keystroke in the teco list
; skip return twice if NOT in the list
; skip return once if in but turned off
TECLUK:	0
	DAC TEM1	; save keystroke we are looking for
	LAC TECPTR
	ASN
	 JMP TECDL2	; no table defined, pretend not found
	LAC TECTOP	; top of teco land less one
	DAC 10
TECDLP:	LAC @10
	SAM TEM1
	 JMP .+2
	  JMP @TECLUK	; already defined, 10 is set up as pointer
	AND [37777]
	SAM TEM1
	 JMP .+2
	  JMP TECDL1	; found it, but its turned off
	ASZ		; skip if end of universe
	 JMP TECDLP	;  nope, loop
	LAC TEM1
TECDL2:	ISZ TECLUK	; twice, not found
TECDL1:	ISZ TECLUK	; once, there but off
	JMP @TECLUK


; keyboard macroage starts here (others in low space at TECMAC, TECKEY, TECLUK)

TECMSK:	0
	LAC TECPTR
	ASN
	 JMP @TECMSK	; none defined
	JMS TGET
	AND [7]
	DAC TECTTT
	CLL
	RAR 3		; remember the stupid link bit
	RAR 3
	DAC TMASK
	LAC TECTTT
	ASN
	 JMP TECMS1
	ADD [LZERO]
	DAC TECTTT
	LAC @TECTTT
	JMP .+2
TECMS1:	LAC [DNOP]
	DAC @[DMACRO+1]
	JMP @TECMSK

TECOFF:	0
	JMS TECKEY
	 JMP @TECOFF
	JMS TECLUK
	 JMP .+3	; there, so turn it off
	  JMP @TECOFF	; already off
	  JMP @TECOFF	; not there
	DAC TECTTT
	LAC 10
	XAM TECTTT
	IOR [040000]
	DAC @TECTTT
	JMP @TECOFF

TECON:	0
	JMS TECKEY
	 JMP @TECON
	JMS TECLUK
	 JMP @TECON	; already on
	 JMP .+2	; off, at last something to do...
	 JMP @TECON	; not there
; turn on offed key macro
	DAC TECTTT
	LAC 10
	XAM TECTTT
	AND [37777]
	DAC @TECTTT
	JMP @TECON

TECTTT:	0		; temporary

; clear macro table
; ^A ^D
TECCLR:	0
	LAC [DNOP]
	DAC @[DMACRO]
	DAC @[DMACRO+1]
	LAC TECPTR
	ASN
	 JMP @TECCLR	; no table to clear
	LAC TECTOP
	IAC
	DAC TECPTR
	DAC TECTTT
	CLA
	DAC @TECTTT
	JMP @TECCLR

; allocate space for macro table -- character argument times 64.
; ^A ^U
TECALC:	0
	JMS TGET
	AND [17]	; don't let him overdo it...
	SAL 3
	SAL 3
	CIA
	ADD [CRIKY]
	DAC BUFEND	; new buffer top
	DAC TECTOP
	IAC
	DAC TECPTR
	SAM [CRIKY]	; flushed?
	 JMP .+3
	  CLA
	  DAC TECPTR	; say so
	JMS TECCLR	; clear macro area
	JMS CLRS	; be compatible with ssv, (ie: consistently do wrong thing)
	JMP @TECALC

; magic flag flappers

; toggle cursor twitchery
TTGLE:	0
	LAC GLV
	XOR [DUD#RESTRZ]
	DAC GLV
	LAC CASEF		; make sure case ends up right
	ASN
	 JMP .+3
	LAC [DJMP DFORM,]
	JMP .+2
	 LAC [DNOP]
	DAC @[DCURT]
	JMP @TTGLE

; toggle TAUTO (auto repeat)
ZAUTO:	0
	JMS ATON		; set it on
	ASP			; skips if it was on
	 JMP @ZAUTO
	JMS ATOFF		; turn it off
	JMP @ZAUTO

; set TAUTO to ON
ATON:	0
	LAC [DNOP]
	DAC @[DAUTF]
	LAC [ISZ TICKER]
	XAM TAUTO		; return old value of flag in ac
	JMP @ATON

; set TAUTO to OFF
ATOFF:	0
	LAC [DJMP DBELLI,]
	DAC @[DAUTF]
	LAC [NOP]
	XAM TAUTO		; return old value of flag in ac
	JMP @ATOFF

; toggle CASEF
ZCASE:	0
	JMS UCASE
	ASN			; skips on upper case
	 JMP @ZCASE
	JMS LCASE		; set lower case
	JMP @ZCASE

; set CASEF to UC
UCASE:	0
	LAC [DNOP]
	DAC @[DUCF]
	LAC [DJMP DFORM,]
	DAC @[DCURT]
	LAW 40			; sets upper case here
	XAM CASEF		; and return old setting of casef
	JMP @UCASE

; set CASEF to LC
LCASE:	0
	LAC [DJMP DAUTF,]
	DAC @[DUCF]
	LAC [DNOP]
	DAC @[DCURT]
	CLA
	XAM CASEF		;  return old setting of casef in ac
	JMP @LCASE

MODTMP:	0
MODSET:	0
	JMS TGET
	DAC MODTMP
	JMS LCASE
	LAC MODTMP
	AND [1]		; upper/lower case
	ASZ
	 JMS UCASE
	JMS ATOFF
	LAC MODTMP
	AND [2]		; auto repeat
	ASZ
	 JMS ATON
	LAC MODTMP
	AND [4]		; teco cursor
	ASZ
	 JMP .+3
	LAC [DJMS DCURT,]
	JMP .+2
	 LAC [DJMS XFORM,]
	DAC @[CURSOR]
	LAC MODTMP
	AND [10]	; twitch cursor
	ASZ
	 JMP .+3
	LAC [JMP DUD]
	JMP .+2
	 LAC [JMP RESTRZ]
	DAC GLV
	JMS TTGLE
	LAC MODTMP
	AND [20]	; save teco macro buffer
	ASN
	 JMS TECCLR
	JMP @MODSET

; toggle I-beam cursor as winner
TECTOG:	0
	LAC @[CURSOR]
	XOR [DCURT#XFORM]
	DAC @[CURSOR]
	JMP @TECTOG

IFN TRACE,[

ZXSV:	0
	LAC XGET
	XOR [<JMP @TGET>#<JMS @XSVDSP>]
	DAC XGET
	LAC [DJMP XSVLND,]
	DAC @[XSVLBG]
	LAC [XSVLBG]
	DAC XSVPTR
	JMP @ZXSV

XSVLIN:	0
	DAC XSVTMP
	LAC XSVPTR
	DAC 10
	LAC [DJMP XSVLND,]
	DAC @10
	LAC XSVTMP
	SUB [16]
	ASM
	 JMP XSVNRM
	ADD [6]
	ASP
	 JMP XSVNR1
	ADD [FNYTAB]
	DAC XSVTM1
	LAC @XSVTM1
	JMP XSVIN
XSVNR1:	SUB [6]
XSVNRM:	ADD [16]
	JMS @[CHRJMS]
XSVIN:	DAC @XSVPTR
	ISZ XSVPTR
	LAC XSVPTR
	SAM [XSVLND-1]
	 JMP .+3
	  LAC [XSVLBG]
	  DAC XSVPTR
	LAC XSVTMP
	JMP @XSVLIN

XSVPTR:	XSVLBG
XSVTMP:	0
XSVTM1:	0
]


; jump to ROM loader
RLOADM:	0
	IOF			; save weird bugs
	JMP @.+1
	40

; jump to overlaid program (SW, MAZE, etc.)
TENM:	0
	IOF
	JMP @.+1
	10000

; * keyboard input *

KEYIN:	0			; keyboard input subroutine
	LAC INTARM
	SAM [KBD\REF]		; kbd int. off?
	 JMP KEYI1
	LAC KIPTR
	SAM KOPTR
	 JMP .+2
	  JMP @KEYIN
KEYI1:	LAC @KOPTR
	DAC KCHAR
	LAC KOPTR
	SAM [KBDEND]
	 JMP .+2
	LAC [KBDBUF-1]
	IAC
	DAC KOPTR
	IOF
	LAW KBD\REF
	JMS ARMER
	ION

	LAC KCHAR
	AND [REPT]		; handle rept key
	SAR 1			; make it look like ctrl key
	IOR KCHAR
	DAC KCHAC		; save transformed character

	LAC [DNOP]		; turn off any transient signs
	DAC @[DMAT]

	LWC 20			; set auto repeat clock
	DAC TICKER
CONTIN:	LAC [JMS KEYIN]		; restore listen loop
	DAC LOOPY

; lookup key stroke for macro expansion
; try with current macro mask
	LAC KCHAR		; for macroage, use raw keystroke
	IOR TMASK		; current macro mask
	JMS TECLUK
	 JMP TECDIS		; found it!
	 NOP			; its there, but turned off
; now try with global (always on) macros
	LAC KCHAR
	JMS TECLUK
	 JMP TECDIS
	 NOP			; normal dispatch

; here for non-macro processing of keystroke
	LAC [KEYDIS-1]		; set up for tty mode lookup
	DAC 10
	LWC KEYSIZ
	DAC LOOP
	LAC KCHAC
	AND [1777]		; can't dispatch on value of REPT!
	JMS DISPCH		; dispatch
	 JMP DSPR		; go execute call to routine
	  JMP XTR		; character conversion

; no match found, do standard conversion
; characters range from 200 to 377 for ascii, all others are ignored
	LAC KCHAC
	AND [CTRL+300]		; check for control of alphanumeric
	SAM [CTRL+300]
	 JMP .+4			; not unconverted control
	  LAC KCHAC		; convert to control and dispose of it
	  AND [37]
	  JMP XTR
	LAC KCHAC		; else check normal ranges
	AND [377]
	SUB [240]
	ASP
	 JMP @KEYIN
	SUB [40]
	ASM			; 240 - 277?
	 JMP .+3		; nope, higher
	  AND [77]		; and it down
	  JMP XTR		; dispose of it
	SUB [1]			; in range 301 to 372?
	ASP			; 300? (atsign)
	 JMP @KEYIN		; atsign handled elsewhere
	SUB [72]
	ASM			; alphabetic?
	 JMP @KEYIN		; no, others elsewhere, leave
	ADD [373]		; restore real value
	XOR CASEF		; set the case properly

; here we have an ascii value.  there are several things we can do with
; it:  in tty mode, we automatically sent it
;      in local mode, we automatically put it into buffer
;      in edit mode, we send control characters, everything else into buffer

XTR:	AND [177]		; and down to 7 bits
	DAC TEM1		; and save it
TXMIT1:	LAC TEM1
TXMIT2:	JMS XMIT		; send it to the pdp-10
	JMP @KEYIN

TECDIS:	LAC @10
	ASM
	 JMP @KEYIN	; oops, hit next keystroke def.
	DAC TEM1
	SAR 3
	SAR 3
	SAR 2
	AND [177]
	JMS XMIT
	LAC TEM1
	AND [177]
	SAM ["~]	; noop character
	 JMP .+2
	  JMP @KEYIN
	JMS XMIT
	JMP TECDIS	; loop

; dispatch
DSPR:	JMS IMPER	
	JMP @KEYIN

; * keyboard and tty character dispatch routine *

IMPER:	0			; subroutine dispatch subroutine
	JMS @IMP
	JMP @IMPER
	JMP @IMPER		; some can skip return
IMP:	0			; impure location

; read a character from the tty and dispatch on result
TTYIN:	0			; teletype subroutine
	JMS TGET		; read it
TTYIN1:	JMS CVDISP		; dispatch or insert
	JMP @TTYIN

; insert ascii into display list (converting first)
CVDISP:	0			; converts ascii to display list
	AND [177]		; protection
	DAC TCHAR		; save character read

	ISZ QUTFLG		; worry about whether char quoted
	JMP .+2
	JMP CTABLE

; set up for table look-up
	LAC [TTYDIS-1]
	DAC 10			; set index
	LWC TTYSIZ
	DAC LOOP

; start loop
	LAC TCHAR
; table look-up loop
	JMS DISPCH
	 JMP TDSPR
	 JMP GOOLIN

; no match
CTABLE:	SAM [177]
	 JMP .+2
	JMP @TTYIN		; >176, ignore it
	JMS CHRJMS

; normal insert
GOOLIN:	JMS INSERT
	JMP @CVDISP

; dispatch to a routine
TDSPR:	JMS IMPER		; dispatch
	JMP @CVDISP

; get subroutine corresponding to ascii value
CHRJMS:	0
	ADD [LISTR-1]
	DAC TEMPNT
	LAC @TEMPNT
	JMP @CHRJMS

; dispatcher
;   r0 - match, subroutine
;   r1 - match, non-subroutine
;   r2 - no match found

DISPCH:	0
; comparison loop
DISCMP:	SAM @10			; match?
	JMP .+2			; no match
	JMP DISMAT		; match!
	ISZ 10			; skip second word of entry
	ISZ LOOP		; all of it?
	JMP DISCMP		; no, loop

; failed -- no matches
	ISZ DISPCH
	JMP DISXIT

; won -- return second word of table entry
DISMAT:	LAC @10
	DAC IMP			; make it IMP value
	ASM
DISXIT:	ISZ DISPCH
	JMP @DISPCH

IFN GRAPH,[ ; begin GRAPH INPUT conditional

; convert two chars into number, sign-bit, and dot-bit
GRFIN:	0
	JMS @[TGET]		; read character
	DAC @[TEMPNT]
	AND [177740]
	ASN			; control character?
	JMP GRFIN1		; yes, end of graphics
; not control character, buffer it
	LAC @[TEMPNT]		; get character
	DAC @15
	ISZ GRF			; advance count
	JMP @GRFIN		; return if not ran out
; count ran out
	LAC [GRF]
	DAC 15			; reset input pointer
	DAC 16			; set output pointer
	LAC GRFSAV		; reset input counter
	DAC GRF
XDISP:	0			; dispatch
	JMP @GRFIN		; return
; control character, game is up
GRFIN1:	JMS XCLEAR		; clear out graphics
	LAC @[TEMPNT]
	JMP @[TTYIN1]		; regular tty input

GRFSAV:	0
; graphics input buffer
GRF:	0			; count
	0			; and up to four characters
	0
	0
	0

; set up for graphics readin
XSET:	0
	DAC GRF			; count
	DAC GRFSAV
	LAC [GRF]		; pointer into input buffer
	DAC 15
	LAC @[JGRFIN]		; read graphics
	DAC @[TTYRED]		; in main loop
	LAC @[JCLEAR]		; clear graphics if char sent
	DAC @[XMITC]
	JMP @XSET

; clear out graphics from main loop, transmitter
XCLEAR:	0
	LAC [JMS TTYIN]
	DAC TTYRED		; fix up main loop
	LAC [JMP @XMIT]
	DAC XMITC		; fix up auto clear out hacker
	LAC 17
	DAC TMP
	LAC @TMP
	SAM [@DRJM]
	 JMP @XCLEAR
	LAC [DRJM]
	DAC @TMP
	JMP @XCLEAR

; process two ards graphics codes
GETARD:	0
; get and process n1
	LAC @16			; get a character between 100 and 177
	AND [77]		; ignore all but 6 bits
	RAR 1			; shift sign bit into link
	DAC POS			; save 5 most sig bits
; sign bit?
	CLA			; zero if link not set
	LSZ			; link zero?
	LWC 1			; minus one if is
	DAC SIGN		; save in sign
; get and process n2
	LAC @16
	DAC POS1		; save it
; dots bit?
	AND [40]
	ASZ			; if dots bit not on, skip
	LWC 1			; -1 if one, so isz will skip
	DAC DOTS		; save it
; do pos=<pos|<pos1_5>>
	LAC POS1
	AND [37]
	SAL 3
	SAL 2
	IOR POS
	AND [1777]
	DAC POS			; save in pos and return in ac
	JMP @GETARD

; get number into co-ordinate format
SETDL:	0
	LAC POS
	ISZ SIGN
	JMP SETDL1
; if pos negative
	CIA
; if pos positive
SETDL1:	ADD [1000]
	DAC POS
	JMP @SETDL


; set point -- from ascii 35
; create:	dgd
;		DLXA x
;		DLYA y

SETPNT:	0
	LAC [JMS SETEND]	; set up for when count runs out
	DAC XDISP
	LWC 4
	JMS XSET		; read four characters
	JMP @SETPNT

; here whenever set point count runs out
SETEND:	0
; x coordinate
	JMS GETARD		; two chars
	JMS SETDL		; frob into coordinates
	XOR [DLXA 0,]		; make it a dlxa
	DAC XPOS		; save it
; y co-ordinate
	JMS GETARD
	JMS SETDL
	XOR [DLYA 0,]
	DAC YPOS
; insert them
	LAC XPOS
	DAC @17
	LAC 17
	JMS ADRJMS
	DAC TMP
	LAC YPOS
	DAC @17
	LAC [@DRJM]
	DAC @17
	LAC TMP
	JMS INSERT
	JMP @SETEND

; long vector -- from ascii 36
; create:	dlv x,y

LNGVCT:	0
	LAC [JMS LNGEND]	; set up end jump
	DAC XDISP
	LWC 4
	JMS XSET		; read four characters
	JMP @LNGVCT

; here whenever long vector count runs out
LNGEND:	0
; x
	JMS GETARD		; two chars
	DAC XPOS		; x relative
; check dots bit
	CLA			; invisible?
	ISZ DOTS		; if dots=-1, invisible
	LAC [20000]		; not invisible
	DAC LONG1
; check sign bit
	LAC [40000]
	ISZ SIGN		; if sign=-1, then negative
	CLA
	DAC LONG2

; y
	JMS GETARD
	DAC YPOS
	ADD XPOS
	ASN
	JMP @LNGEND
; check dots bit
	LAC [60000]		; dotted?
	ISZ DOTS		; if dots=-1, dotted
	CLA			; not dotted
	IOR LONG1
	DAC LONG1
; sign bit
	LAC [20000]
	ISZ SIGN
	CLA
	IOR LONG2		; don't forget x may have sign, too!
	DAC LONG2
	JMS VCTDO
	JMP @LNGEND

; short vectors -- no one uses them ever
;SHTVCT:	0
;	LAC [JMS SHTEND]
;	DAC XDISP
;	LWC 2
;	JMS XSET
;	JMP @SHTVCT
;
;SHTEND:	0
;	LAC [40000]
;	DAC LONG1
;	LAC @16
;	RAR 1
;	DAC XPOS
;	CLA
;	LSN
;	JMP SHTY
;	LAC [40000]
;SHTY:	DAC LONG2
;	LAC @16
;	RAR 1
;	DAC YPOS
;	LSN
;	JMP SHTDO
;	LAC [20000]
;	IOR LONG2
;	DAC LONG2
;SHTDO:	JMS VCTDO
;	JMP @SHTEND

; hack difference and bit for which is greater
VCTDO:	0
	LAC YPOS		; y
	SUB XPOS		; minus x
	DAC LONG0		; (y-x)
; check whether y or x greater
	ASZ			; nothing if x=y
	ASP			; skip if y>x, must hack
	JMP LNGPUT		; x>y is the normal case, super win

; here y was greater than x, must switch them
	CIA
	DAC LONG0		; -(y-x)
; exchange x and y -- greater in first word always
	LAC XPOS
	XAM YPOS
	DAC XPOS
	LAC [10000]		; indicate y was greater
	IOR LONG2
	DAC LONG2
; now set up in source buffer for GRFINS
LNGPUT:	LAC XPOS
	IOR LONG1
	IOR [100000]		; so can't look like DHLT
	DAC LONG1
	LAC YPOS
	IOR LONG2
	IOR [100000]		; ditto
	DAC LONG2
	LAC LONG0
	AND [7777]
	IOR [40000]		; opcode for DLV
	DAC LONG0
	JMS GRFINS		; insert them
	JMP @VCTDO

; here to insert three word grafix object w.o. display glitchery
GRFINS:	0
	JMS ROOM		; is there room?
	 JMP @GRFINS		; nope, flush
; extending a graphix object?
	LAC 17			; pointer to last grafix output
	DAC TMP
	LAC @TMP		; if its @DRJM, we can extend previous object
	DAC POS
	SAM [@DRJM]		; signal that previous was grafix
	 ISZ 17			;  if not extending, bump pointer
	LAC 17
	DAC SIGN		; points to first word of three
; insert second word
	LAC LONG1
	DAC @17
; insert third word
	LAC LONG2
	DAC @17
; insert return
	LAC [@DRJM]
	DAC @17
; insert first word
	LAC LONG0		; unblocks dlist
	DAC @SIGN
; here to jms to it if not extending
	LAC POS
	SAM [DRJM]
	 JMP @GRFINS
	LAC SIGN
	JMS ADRJMS
	JMS INSERT
	JMP @GRFINS

; long vector insertion buffer
LONG0:	0
LONG1:	0
LONG2:	0
POS:	0
POS1:	0
XPOS:	0
YPOS:	0
SIGN:	0
DOTS:	0

] ; end GRAPH INPUT conditional


; dispatcher for contiguous tables
FULDIS:	0
	JMS @[TGET]		; get argument
	ASN
	 JMP @FULDIS
	ADD FULTAB
	DAC FULTAB
	SUB FULEND		; check table limit
	ASM			; skips if o.k.
	 JMP @FULDIS
	LAC @FULTAB		; load address of selected routine
	ASN			; is a routine assigned ?
	 JMP @FULDIS		; forget it if a zero entry
	DAC FULTAB		; store it
	JMS @FULTAB		; i jms to it
	JMP @FULDIS

FULTAB:	0
FULEND:	0

; dispatch for software TTY codes (^? codes)
SMART:	0
	LAC [SMTAB-1]
	DAC FULTAB
	LAC [SMEND]
	DAC FULEND
	JMS FULDIS
	JMP @SMART

; dispatcher for special IMLAC codes (^A codes)
ASETR:	0
	LAC [AXTAB-1]
	DAC FULTAB
	LAC [AXEND]
	DAC FULEND
	JMS FULDIS
	JMP @ASETR

; variables and constants

BLKINS:	0
TOPLIN:	DLINES	; location of first line
CHRPNT:	0	; pointer to current character location
LINPNT:	0	; pointer to current line
LINWID:	0	; sometimes pointer to size cell of current line

CHRPOS:	0	; column position
LINPOS:	0	; line position
LINCNT:	0

CHRNEW:	0	; new column position from ABPOS
LINNEW:	0	; new line position from ABPOS

CASEF:	0	; shift lock

DEOL:	DNOP

LTMP:	0	; temporary for LNFD

INTMP:	0	; temporary for INSERT
INTMP1:	0	; temporary for INSERT

KCHAR:	0	; keystroke as read
KCHAC:	0	; keystroke with REPT=>CTRL
KIPTR:	0	; keyboard input buffer input pointer
KOPTR:	0	; keyboard input buffer output pointer

LOOP:	0
LOOPR:	0
LOOPX:	0

QUTFLG:	0

TCHAR:	0
TECPTR:	0		; pointer to teco macro characters
TECTMP:	0		; temporary for teco hackery
TECTOP:	0		; top of teco land
TEM1:	0
TEMPNT:	0
TMASK:	0		; current mask for macros
TMP:	0

INFORM START OF FIRST CONSTANTS
	VARIAB
	CONSTA
INFORM END OF FIRST CONSTANTS

; *** NO CONSTANTS CREATED FROM HERE ON ***

SUBTTL Keyboard Dispatch Table

KEYDIS:
; muddle commands
IFN MUDDLE,[
	DSP CTRL+204,@MD		; c   = muddle move down
	DSP CTRL+205,@MR		; c   = muddle move right
	DSP SHIFT+205,@CMR
	DSP CTRL+206,@MU		; c   = muddle move up
	DSP CTRL+210,@ML		; c   = muddle move left
	DSP SHIFT+210,@CLNML
	DSP CTRL+235,@MF		; c   = muddle move front
	DSP CTRL+236,@MB		; c   = muddle move back
]
; edit line commands
	DSP SHIFT+204,@EDTLFT
	DSP SHIFT+206,@EDTRGT
	DSP SHIFT+235,@EDITLN		; s   = toggle editing margin
; down arrow
	DSP 204,@DNAR			;     = move down a line
	DSP CTRL+SHIFT+204,@DELDN
; right arrow
	DSP 205,@MRTAR			;     = move right a character
	DSP CTRL+SHIFT+205,@DELRT
; up arrow
	DSP 206,@UPAR			;     = move up a line
; left arrow
	DSP 210,@MLFAR			;     = left one character
; form
	DSP 214,014			;     = ^L
; del
	DSP 377,177			;     = send delete (rubout)
	DSP SHIFT+377,@RUBOUT		; s   = delete
	DSP CTRL+377,@JMSNOP		; c   = NOP
	DSP CTRL+SHIFT+377,@CLRS	; c-s = clear screen
; home
	DSP 217,@HOME			;     = move to end of screen
	DSP SHIFT+217,@HOMEUP		; s   = move to top of screen
; page xmit
; xmit
; "0"
	DSP SHIFT+230,@LDELT		; s   = line clear
	DSP 230,@TTGLE			;     = toggle twitchy cursor
	DSP CTRL+230,@CLRS		; c   = clear screen
; "2"
	DSP 232,@RUBLFT			;     = delete
; "4"
	DSP CTRL+SHIFT+234,@LDELT
; "5"
	DSP CTRL+SHIFT+235,@LBEG
; "6"
	DSP CTRL+SHIFT+236,@EOL		; c-s = move to end of line
	DSP 236,037			;     = ^_ (ascii 37)
; "7"
	DSP 211,@TECTOG			;     = toggle teco cursor
	DSP CTRL+SHIFT+211,@RLOADM	; c-s = jump to 40
KINIT:	DSP CTRL+211,@INITA		; c   = re-initialize SSV

; --- left keyboard ---

; esc
	DSP 233,033			;     = ESC (ascii 33)
	DSP CTRL+SHIFT+233,@TENM	; c-s = jump to 10000
; cr
	DSP 215,015			;     = carriage return (ascii 15)
; lf
	DSP 212,012			;     = line-feed (ascii 12)
; tab
	DSP CTRL+237,177		; c   = back delete
	DSP 237,011			;     = tab (ascii 11)
; break
IFN TRACE, DSP CTRL+SHIFT+231,@ZXSV	; c s = toggles input snoop
	DSP SHIFT+231,@ZAUTO		; s   = toggles auto repeat
	DSP 231,@ZCASE			;     = toggles case
; space
	DSP SHIFT+240,040		; s   = space
	DSP CTRL+240,040		; c   = space

; --- key translations ---

	DSP CTRL+254,133		; c , = [
	DSP CTRL+255,137		; c - = _
	DSP CTRL+256,135		; c . = ]
	DSP CTRL+257,134		; c / = \
	DSP SHIFT+260,010		; s 0 = ^H (backspace)
	DSP CTRL+260,174		; c 0 = | (vertical bar)
	DSP CTRL+266,176		; c 6 = ~ (tilde)
	DSP CTRL+267,140		; c 7 = ` (accent grave)
	DSP CTRL+270,173		; c 8 = { (left curly bracket)
	DSP CTRL+271,175		; c 9 = } (right curly bracket)
	DSP CTRL+272,136		; c : = ^
	DSP CTRL+273,100		; c ; = @
	DSP CTRL+SHIFT+313,033		; c-s K = ESC
	DSP CTRL+SHIFT+314,034		; c-s L = ^\
	DSP CTRL+SHIFT+315,035		; c-s M = ^]
	DSP CTRL+SHIFT+316,036		; c-s N = ^^
	DSP CTRL+SHIFT+317,037		; c-s O = ^_
	DSP CTRL+SHIFT+320,000		; c-s P = ^@
KEYSIZ=<.-KEYDIS>/2

SUBTTL TTY Dispatch Table

			; tty mode tty table
TTYDIS:	DSP 001,@ASETR		; ^A -- dispatch on next character
	DSP 007,@DONG		; ^G -- ring bell
	DSP 010,@LFAR		; ^H -- back space
	DSP 011,@TABR		; ^I -- tab
	DSP 012,@LNFD		; ^J -- line feed
	DSP 013,@LNFD		; ^K -- down a line (make it if need be)
	DSP 014,@CLRS		; ^L -- also clear screen
	DSP 015,@LBEG		; ^M -- carriage return
	DSP 016,@OABPOS		; ^N -- absolute position to chr,line
	DSP 017,@LFAR		; ^O -- move left
	DSP 020,@DELDN		; ^P -- delete to EOF
	DSP 021,@DELRT		; ^Q -- delete to EOL
	DSP 022,@CLRS		; ^R -- clear screen
	DSP 023,@LDELT		; ^S -- clear whole line (less crlf)
	DSP 024,@HOMEUP		; ^T -- home up
	DSP 025,@HOME		; ^U -- home down
	DSP 030,@RUBOUT		; ^X -- delete left
	DSP 031,@SPACE		; ^Y -- move right
	DSP 032,@UPAR		; ^Z -- up a line
	DSP 033,DJMS D033	; normal alt-mode
IFN GRAPH,[		; graphics codes
	DSP 034,@XCLEAR
	DSP 035,@SETPNT
	DSP 036,@LNGVCT
;	DSP 037,@SHTVCT		; nobody uses short vectors
]
	DSP 040,@SPACE		; SP -- move right
	DSP 177,@SMART		; DEL -- intelligent terminal
TTYSIZ=<.-TTYDIS>/2

SUBTTL ITS buffer code dispatching

SMTAB:	0			; rubout=177
      	@NABPOS			; %TDMOV=200
	@ABPOS			; %TDMV1=201
	@DELDN			; %TDEOF=202
	@DELRT			; %TDEOL=203
	@RUBOUT			; %TDDLF=204
	0			; %TDMTF=205
	0			; %TDMTN=206
	@NEWLIN			; %TDCRL=207
	0			; %TDNOP=210
	@LFAR			; %TDBS=211
	@LNFD			; %TDLF=212
	@LBEG			; %TDRCR=213
	0			; %TDORS=214
	0			; %TDQOT=215
	@SPACE			; %TDFS=216
	@ABPOS			; %TDMV0=217
	@CLRS			; %TDCLR=220
	@DONG			; %TDBEL=221
	@INITA			; %TDINI=222
; new, unimplemented (as yet) codes
	0			; %TDILP=223 ?
	0			; %TDDLP=224 ?
	0			; %TDICP=225 ?
	0			; %TDDCP=226 ?
SMEND:


SUBTTL Control-A Dispatch Table

AXTAB:	@RLOADM			; ^A^A -- jump to 40
	@TECURS			; ^A^B -- insert teco cursor
	@HOMEUP			; ^A^C -- home up
	@TECCLR			; ^A^D -- clear TECO macro buffer
	@TECMAC			; ^A^E -- define TECO macro character
	@TENM			; ^A^F -- jump to 10000
	0			; ^A^G
	0			; ^A^H
	0			; ^A^I
	0			; ^A^J
	0			; ^A^K -- mouse off
	@NEON			; ^A^L -- display sign
	@INQUIR			; ^A^M -- get version # and type
	@LINNUM			; ^A^N -- ask for line number
	@MODSET			; ^A^O -- set SSV modes
	0			; ^A^P -- set size 0
	0			; ^A^Q -- set size 1
	0			; ^A^R -- set size 2
	0			; ^A^S -- set size 3
	0			; ^A^T -- start page xmit
	@TECALC			; ^A^U -- allocate teco macro buffer
	@TECOFF			; ^A^V -- turn off a character
	@TECON			; ^A^W -- turn on an offed character
	@TECMSK			; ^A^X -- set the macro mask
AXEND:

; --------- (cursors) -----------

DCURT:	DNOP			; regular cursor
	INC E,D0M1
	INC D0M3,B30
	INC B30,B30
	INC D03,D20
	INC D01,T
	DJMP CURRET

DFORM:	INC E,D0M1		; cursor with prongs
	INC B0M3,B30
	INC B30,B30
	INC B03,D20
	INC D01,T
CURRET:	INC E,DM30
	INC DM30,DM30
	DM20,X

XFORM:	DJMS XXFORM		; teco cursor
	DJMS XXFORM
	DRJM

XXFORM:	INC E,DM3M3		; i-beam cursor
	INC DM3M3,DM20
	INC B30,B30
	INC B30,B30
	INC DM30,DM30
	INC B03,B03
	INC B03,B03
	INC B03,B03
	INC B03,B03
	INC DM30,DM30
	INC B30,B30
	INC B30,B30
	INC DM3M3,DM1M3
	INC D0M3,D0M3
	INC D0M3,D0M3
	INC X,X

LINE70:	DGD
LINELX:	DXPOS 70.
	DLYA TOP
	DGB
	DLYA 0
	DRJM

IFN MUDDLE,[

; table of signs
MMTAB:	DNOP
	DJMS DUNMAT
	DJMS DMISMA
	DJMS DOVER
	DJMS DUNDER
	DJMS DBOT

; messages
DBOT:	DTXT [BOTTOM]
	DRJM
DOVER:	DTXT [OVER]
	DJMP DFLOW
DUNDER:	DTXT [UNDER]
DFLOW:	DTXT [FLOW]
	DRJM
DMISMA:	DTXT [MIS]
	DJMP DMATCH
DUNMAT:	DTXT [UN]
DMATCH:	DTXT [MATCH]
	DRJM

PDLBUF:	BLOCK 40
]

KBDBUF:	BLOCK 17
KBDEND:	0

BIGBEN:	DTXT [*FEEP*]
	DRJM

IFN TRACE,[

H010:	DJMS DCTRL
	DJMP D150

H011:	DJMS DCTRL
	DJMP D151

H012:	DJMS DCTRL
	DJMP D152

H015:	DJMS DCTRL
	DJMP D155

FNYTAB:	DJMS H010
	DJMS H011
	DJMS H012
	DJMS D013
	DJMS D014
	DJMS H015
]

.CRFOF
	.TABS==0
	.INSRT IMSRC;SSVCHR >
.CRFON

INFORM LAST CHAR

DCRLF:	DJMS D015
	DJMS D012
	DRJM

CURSOR:	DJMS DCURT
DCURCH:	DJMS DEOL
	DRJM

LISTR:
		     DJMS D001, ? DJMS D002, ? DJMS D003
	DJMS D004, ? DJMS D005, ? DJMS D006, ? DJMS D007
	DJMS D010, ? DJMS 0,	? DJMS D012, ? DJMS D013
	DJMS D014, ? DJMS D015, ? DJMS D016, ? DJMS D017
	DJMS D020, ? DJMS D021, ? DJMS D022, ? DJMS D023
	DJMS D024, ? DJMS D025, ? DJMS D026, ? DJMS D027
	DJMS D030, ? DJMS D031, ? DJMS D032, ? DJMS D033
	DJMS D034, ? DJMS D035, ? DJMS D036, ? DJMS D037

LIST40:	DJMS D040, ? DJMS D041, ? DJMS D042, ? DJMS D043
	DJMS D044, ? DJMS D045, ? DJMS D046, ? DJMS D047
	DJMS D050, ? DJMS D051, ? DJMS D052, ? DJMS D053
	DJMS D054, ? DJMS D055, ? DJMS D056, ? DJMS D057
LZERO:	DJMS D060, ? DJMS D061, ? DJMS D062, ? DJMS D063
	DJMS D064, ? DJMS D065, ? DJMS D066, ? DJMS D067
	DJMS D070, ? DJMS D071, ? DJMS D072, ? DJMS D073
	DJMS D074, ? DJMS D075, ? DJMS D076, ? DJMS D077
	DJMS D100, ? DJMS D101, ? DJMS D102, ? DJMS D103
	DJMS D104, ? DJMS D105, ? DJMS D106, ? DJMS D107
	DJMS D110, ? DJMS D111, ? DJMS D112, ? DJMS D113
	DJMS D114, ? DJMS D115, ? DJMS D116, ? DJMS D117
	DJMS D120, ? DJMS D121, ? DJMS D122, ? DJMS D123
	DJMS D124, ? DJMS D125, ? DJMS D126, ? DJMS D127
	DJMS D130, ? DJMS D131, ? DJMS D132, ? DJMS D133
	DJMS D134, ? DJMS D135, ? DJMS D136, ? DJMS D137
	DJMS D140, ? DJMS D141, ? DJMS D142, ? DJMS D143
	DJMS D144, ? DJMS D145, ? DJMS D146, ? DJMS D147
	DJMS D150, ? DJMS D151, ? DJMS D152, ? DJMS D153
	DJMS D154, ? DJMS D155, ? DJMS D156, ? DJMS D157
	DJMS D160, ? DJMS D161, ? DJMS D162, ? DJMS D163
	DJMS D164, ? DJMS D165, ? DJMS D166, ? DJMS D167
	DJMS D170, ? DJMS D171, ? DJMS D172, ? DJMS D173
	DJMS D174, ? DJMS D175, ? DJMS D176, ? DJMS DFORM


INFORM START OF DLIST

DORIG:	DADR
	DHVS 1
DEDLIN:	DNOP
	DGD

	DLXA 0
DARROW:	DLYA TOP
	DTXT [=>]

IFN TRACE,[
; who line hackery
	DXPOS 0.
	DLYA 10

XSVLBG:	REPEAT 90., DJMP XSVLND
XSVLND:
]

; status line
	DLYA 1740
	DXPOS 0.
	DNAME
	DXPOS 67.
DMACRO:	DNOP
	DNOP

; upper-lower case
DUCF:	DJMP DAUTF
	DXPOS 70.
	DTXT [-UC-]

; auto-repeat
DAUTF:	DNOP
	DXPOS 75.
	DTXT [-AUTO-]

; bell and other messages here
DBELLI:	DXPOS 30.
DMAT:	DNOP

	DXPOS 50.
DBELL:	DNOP

; after signs
	DLXA LEFT
	DLYA TOP

DBLOCK:	DJMP DLINES
	%BUFR==BUFBEG
DLINES:	REPEAT SCREEN-1,[
	 DJMS %BUFR+1
	 DJMS DCRLF
	 %BUFR==%BUFR+LINE+3
]
	DJMS %BUFR+1
	DHLT			; this is sometimes a crlf too
DEND:	DJMP DLINES

DOVERP:	

INFORM HIGHEST USED

	END GO101
