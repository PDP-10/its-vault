;-*- mode: lisp; base: 8; package: user -*-

;THE "GENERATION" FEATURE OF CHASM.
;	FOR VARIOUS REASONS, PARTS OF A CHEOPS PROGRAM ARE OFTEN
;ASSEMBLED IN SIMILAR FORM TWO OR MORE TIMES.  FOR EXAMPLE,
;SINCE IT WOULD BE VERY TIME CONSUMING TO DIDDLE THE APPROPRIATE
;INDEXES,  CHEOPS PROGRAMS ALMOST ALWAYS USE
;ONE GENERATION TO "PLAY-CHESS-FOR-WHITE" AND ANOTHER TO
;"PLAY-CHESS-FOR-BLACK".  BY CONVENTION, THE LOW ORDER BIT OF THE GENERATION
;NUMBER GIVES THE SIDE TO MOVE,  EVEN GENERATONS FOR WHITE-TO-MOVE.
;IN ADDITION, SINCE IT MAY BE DESIRABLE TO
;USE SOMEWHAT DIFFERENT CODE DEPENDING ON THE DEPTH IN THE TREE,
;FURTHER PAIRS OF GENERATIONS MAY BE EMPLOYED.  FOR EXAMPLE,
;ONE PAIR MAY BE USED FOR THE TOP 4 PLIES IN THE TREE
;AND ANOTHER PAIR FOR DEEPER PLIES.  THE TOP ONE MIGHT DO SUCH THINGS
;AS RETURN A PRINCIPLE VARIATION,  ORDER THE MOVES MORE CLEVERLY, REFERENCE
;A HASH TABLE, ETC.  THE GENERATION FEATURE HELPS MAKE THIS MORE CONVENIENT.
;	THE GENERATION FEATURE IS SIMILAR IN SOME WAYS TO MACROS IN A MACRO
;ASSEMBLER, BUT THE IMPLEMENTATION IS QUITE DIFFERENT, IN THAT IT IS "BINARY"
;ORIENTED RATHER THAN CHARACTER STRING ORIENTED.  PASS 2 DOES MAKE
;A COMPLETE PASS OVER THE PASS 1 OUTPUT FOR EACH GENERATION.  HOWEVER,
;NO "GAMES" ARE PLAYED (BY THE ASSEMBLER).  IE NORMAL TAGS HAVE THEIR
;SAME NAMES ON ALL GENERATIONS, ETC, ALTHO IT IS EASY TO WRITE ARBITRARY
;GENERATION DEPENDANT CONDITIONALS.  INSTEAD, EACH TAG HAS PROVISION FOR
;HAVING A SEPARATE VALUE AND SET OF PROPERTIES, ETC, FOR EACH GENERATION.
;DURING PASS 3, THERE IS A "CURRENT" GENERATION, WHICH IS USED AS THE DEFAULT
;SET WHEN AN ATOMIC TAG IS SEEN.  HOWEVER, BY SUBSTITUTING A LIST OF
;(<GENERATION NUMBER> TAG) IT IS POSSIBLE AT ALL TIMES TO REFERENCE THE
;PROPERTY-SET OF ANY TAG ASSOCIATED WITH ANY GENERATION.

;GENERAL OPERATION OF PASS 3 OF THE CHEOPS ASSEMBLER:
;PASS 3 TAKES AS INPUT THE FULLY "LISPIFIED"
;AND EXPANDED OUTPUT PRODUCED BY PASS 2.
;PASS 3 CREATES FOR EACH STORAGE WORD AN ATOM.
;(IF THE STORAGE WORD IS PRECEEDED BY A TAG,
;THE ATOM IS THE SAME AS THE TAG. IF NOT, A
;GENSYM IS CREATED.)  VARIOUS
;PROPERTIES AND LINKS HAVING TO DO WITH THE STORAGE
;WORD ARE REPRESENTED AS PROPERTIES OF THIS ATOM.
;THIS SITUATION IS SOMEWHAT COMPLICATED
;BY THE GENERATION FEATURE, DISCUSSED ABOVE.
;  TO DEAL WITH THIS PROBLEM, AN ARRAY IS DEFINED TO HOLD
;ALL THE PROPERTIES OF EACH TYPE IN THE ENTIRE SYSTEM.
;EACH TAG IS ASSIGNED A BASE INDEX IN THIS ARRAY.  TO OBTAIN
;THE VALUE OF THE GIVEN PROPERTY ONE THE N TH GENERATION FOR A TAG,
;ONE ADDS THE BASE ASSOCIATED WITH THE TAG TO THE GENERATION NUMBER
;AND REFERENCES THE ARRAY HOLDING THAT SORT OF PROPERTY.
;	NORMALLY, WHEN AN ATOMIC TAG IS SEEN, THE GENERATION
;NUMBER IS DEFAULTED TO THE "CURRENT GENERATION".  HOWEVER A LIST IS SEEN
;WHERE A TAG IS EXPECTED, CAR OF THE LIST MAY BE WHITE-TAG, BLACK-TAG
;SAME-SIDE-TAG, OTHER-SIDE-TAG OR TAG-IN-GENERATION.  THE FIRST FOUR
;OF THESE ARE FOLLOWED BY THE TAG AND WILL REFERENCE THE VALUE IN THE CURRENT
;GENERATION PAIR.  TAG-IN-GENERATION IS FOLLOWED BY THE GENERATION NUMBER,
;THEN BY THE TAG, AND CAN OF COURSE REFERENCE ANY GENERATION.
;IN CASES WHERE THE ATOMIC PROPERTY IS USED TO DISTINGUISH
;TAGS FROM OTHER DATA, THE TAG PSEUDO-OP MUST BE
;USED TO REFERENCE A NON-CURRENT TAG.
;CODE WHICH IS TO BE ASSEMBLED ONCE
;IS NORMALLY ASSEMBLED ONLY IN GENERATION 0.
;	THE ONLY WORK REMAINING AFTER THE COMPLETION OF
;PASS 3 IS THE FINAL ASSIGNMENT OF STORAGE LOCATIONS.
;	THE MAIN PART OF THE STORAGE WORD IS ADDED UP
;AND STORED IN THE CHASM-STORAGE-WORD ARRAY. 
;	IN THE CHASM-NEXT-TEXTUAL-LINK ARRAY IS STORED
;A POINTER TO THE ATOM FOR THE TEXTUALLY NEXT STORAGE WORD.
;	THE OTHER PRIMARY INFORMATION STORED ABOUT THE STORAGE
;WORD CONCERNS RESTRICTIONS THAT MAY ARISE REGARDING
;WHAT LOCATION (MODULO 16) MAY BE USED TO STORE THE STORAGE
;WORD.  NOTE THAT THESE RESTRICTIONS MAY ARISE IN AN
;AREA OF THE ASSEMBLED PROGRAM TEXTUALLY DISTANT FROM THE
;WORD ITSELF.
;	TO REVIEW BRIEFLY:  IN CHEOPS, EVERY INSTRUCTION IS
;A TRANSFER.  THUS THE CHEOPS ASSEMBLER HAS NO NEED FOR A
;CONVENTIONAL SECOND PASS:  AT THE APPEARANCE OF A SYMBOL
;IS IT CAN JUST AS WELL BE ARBITRARILY DEFINED TO BE THE NEXT
;AVAILABLE LOCATION. HOWEVER, THIS SITUATION IS COMPLICATED
;BY THE SCHEME USED TO IMPLEMENT CONDITIONALS.
;	ALL CONDITIONS TESTABLE BY CHEOPS MUST MANIFEST
;THEMSELVES BY SHOWING UP IN ONE OF THE FOUR SIXTEEN BIT
;FLAGWORDS.  EACH INSTRUCTION HAS A FOUR BIT COND FIELD.
;THE COND FIELD SPECIFIES WHICH FOUR BIT QUARTER OF WHICH
;FLAGWORD IS TO BE IOR ED WITH THE NEXT-ADDRESS FIELD OF
;THIS MICROINSTRUCTION TO LOCATE THE NEXT MICROINSTRUCTION.
;	NOTES:   THESE WORDS ARE LATCHED AT THE BEGINNING OF
;		EACH INSTRUCTION. THIS THEN IMPLIES THAT IT IS
;		IMPOSSIBLE FOR A MICROINSTRUCTION TO TRANSFER
;		CONDITIONALLY ON ANYTHING SPECIFIED IN THAT
;		MICROINSTRUCTION.  IT CAN ONLY TEST THOSE
;		CONDITIONS ALREADY PRESENT IN THE FLAGWORDS.
;		 QUARTER 0 OF FLAGWORD 0 IS ALWAYS 0.
;		IT IS SPECIFIED WHEN AN UNCONDITIONAL TRANSFER
;		IS DESIRED.  CHASM3 > CONTAINS THE CURRENT
;		DEFINITIONS OF THE FLAGWORD BITS.
;	AS A RESULT OF THIS SCHEME, THE ASSEMBLER MUST BE
;CONCERNED WITH INSURING THAT ANY MICROINSTRUCTION WHICH IS
;TO BE REACHED AS A RESULT OF A CONDITIONAL TEST IS STORED IN THE
;CORRECT LOCATION MODULO 16.  IT MAY NOT BE POSSIBLE IN GENERAL
;TO SATISFY THIS WITH A SINGLE COPY OF THE MICROINSTRUCTION,
;SO IT MAY BE NECESSARY TO STORE TWO (OR MORE) COPIES OF
;THE SAME MICROINSTRUCTION AT DIFFERENT ADDRESSES.  THE
;ASSEMBLER IS CHARGED WITH DOING THIS AUTOMATICALLY, IF 
;REQUIRED.
;	THE BASIC SCHEME AS PRESENTED SO FAR WOULD REQUIRE
;"USING UP" AN ADDRESS 17 EVERY TIME ANY CONDITION WAS TESTED.
;FOR EXAMPLE, SUPPOSE IT WAS DESIRED TO TEST A BIT WHICH
;HAPPENED TO BE IN THE 4 BIT OF A FLAGWORD QUARTER.
;THEN THE LOW ORDER NEXT ADDRESS FIELD OF THE INSTRUCTION WOULD
;BE ASSEMBLED AS 13, AND CONTROL WOULD GO TO EITHER LOCATION XXX13 
;OR XXX17 DEPENDING ON THE STATE OF THE DESIRED BIT. (NOTE, OF
;COURSE, THAT THERE IS NO POSSIBLITY OF REACHING ANY OTHER
;LOCATION IN THE 16.-GROUP SINCE AN IOR ING OPERATION IS DONE.)
;THE ONLY TROUBLE WITH THIS SCHEME IS THAT IF MORE THAN
;APPROXIMATELY ONE SIXTEENTH OF INSTRUCTIONS ARE CONDITIONAL
;WE MAY RUN OUT OF LOCATIONS XXX17 BEFORE WE RUN OUT OF
;CONTROL MEMORY.  TO SOMEWHAT AMELIORATE THIS PROBLEM,
;SOME FLAGWORD BITS HAVE BEEN WIRED TO ALWAYS BE ZERO.
;THUS, IN THE PREVIOUS EXAMPLE, IF IT WERE KNOWN THAT
;THE ONE BIT OF THE FLAGWORD QUARTER IN QUESTION WERE
;ALWAYS GUARENTEED TO BE ZERO, ONE COULD SAFELY ASSEMBLE
;12 INTO THE INSTRUCTION, AND IT WOULD REACH 12 OR 16
;DEPENDING ON THE BIT TO BE TESTED.
;	THUS, WE SEE THAT EACH TIME AN INSTRUCTION IS
;REFERENCED IN THE TARGET ADDRESS OF A CONDITIONAL, ITS
;STORAGE LOCATION BECOMES CONSTRAINED IN TWO WAYS:
;	1) ITS OWN LOCATION MODULO 16 BECOMES DEFINED
;	   (OR PARTIALLY DEFINED IF THE FLAGWORD QUARTER
;	   HAS ALWAYS-ZERO BITS).
;	2) THE NECESSARY OTHER LOCATIONS IN THAT BLOCK
;	   OF SIXTEEN MUST BE AVAILABLE TO ACCOMODATE
;	   THE OTHER POSSIBILITIES OF THE MULTI-WAY
;	   BRANCH.
;	ANOTHER RESTRICTION ON LOCATION ASSIGNMENT
;HAS TO DO WITH SUBROUTINE CALLS, NOTABLY PUSHJ.
;THE PROBLEM BASICALLY IS THAT THE INSTRUCTION TO BE RETURNED TO
;(RETURN-TARGET) MUST BE LOCATED IN THE PROPER MANNER RELATIVE TO THE
;CALLING INSTRUCTION.
;	TO REVIEW THE OPERATION OF THE HARDWARE:
;WHEN A PUSHJ IS DONE ON CHEOPS, THE PC (POINTING
;TO THE LOCATION THAT CONTAINED THE PUSHJ) IS PUSHED ON
;THE MICRO-STACK OR U-STACK.  WHEN A POPJ IS DONE,
;THIS VALUE IS RETRIEVED AND ADDED TO THE QUANTITY
;RESULTING FROM IOR ING THE SPECIFIED FLAGWORD QUARTER
;AND THE NEXT-ADDRESS FIELD OF THE POPJ INSTRUCTION.
;TO SIMPLIFY THE STORAGE ALOCATION PROBLEM SOMEWHAT,
;WE ADOPT THE FOLLOWING CONVENTION (SUGGESTED BY GLS):
;ALL "NORMAL" RETURNS WILL DO A POPJ 20, ALL "SKIP"
;RETURNS A POPJ 40, ETC.  INITIALLY THE FEATURE OF BEING
;ABLE TO DO A MULTIWAY BRANCH ON THE RETURN BY SPECIFING
;A NON-ZERO COND FIELD IN THE POPJ INSTRUCTION WILL NOT
;BE SUPPORTED BY ASSEMBLER.  HOWEVER, IT CAN BE IN THE
;FUTURE IF THE NEED IS DEMONSTRATED.   THUS, ANY MICRO-INSTRUCTION
;WHICH IS A PUSHJ MUST ALSO INSURE THAT THE RETURN-TARGET
;(NORMALLY THE INSTRUCTION TEXTUALLY FOLLOWING THE PUSHJ,
;BUT POSSIBLY DIFFERENT IF THE RETURN-TO OPERATION IS INVOKED)
;IS STORED IN THE LOCATION OF THE PUSHJ + 20.
;IF A SKIP IS INVOLVED, THAT LOCATION MUST BE IN PUSHJ + 40, ETC.
;(THE RETURN-SKIPS <N> PSEUDO MUST BE EMPLOYED TO INFORM THE
;ASSEMBLER THAT A SKIP IS INVOLVED.)
;	IT IS THE JOB OF PASS 3 TO ACCUMULATE SUFFICIENT
;DATA ON THESE RESTRICTIONS TO ENABLE PASS 4 TO DO AN
;ACCEPTABLE JOB OF ASSIGNING FINAL STORAGE LOCATIONS.
;	PASS 3 ALSO PRODUCES A LIST CALLED THE CONDS-LIST.
;THERE IS ONE ENTRY ON THIS LIST FOR EACH MULTIWAY BRANCH
;IN THE INPUT PROGRAM.  THE ENTRY CONSISTS OF A NUMBER GIVING
;THE "ACTIVE BITS", FOLLOWED BY THE FLAGWORD QUARTER NUMBER
;FOLLOWED BY A LIST
;OF POINTERS TO THE STATEMENT HEADERS OF THE STATEMENTS
;WHICH CAN POSSIBLY BE REACHED.  (NOTE THAT SINCE ANY
;STATEMENT WHICH CAN BE REACHED BY A MULTIWAY CONDITIONAL
;MUST HAVE A STATEMENT LABEL, THERE IS NO POSSIBILITY
;OF HAVING A GENSYM IN SUCH A LIST.  HOWEVER, TO DEAL WITH
;THE CASE OF TWO LABELS BEING GIVEN TO THE SAME STATEMENT,
;IT IS NECESSARY FOR ALL LEVELS OF THE SYSTEM TO REFERENCE THE CHASM-REAL-TAG-NAME
;ARRAY FOR ALL TAGS TAKEN FROM "SOURCE CODE".  THE CHASM-REAL-TAG-NAME ARRAY
;MAY CONTAIN NIL, OR MAY GIVE THE NAME OF A TAG FOR WHICH THIS IS A SYNONYM,
;IN WHICH CASE ALL FURTHER ATTENTION MUST BE DIRECTED TO THE GIVEN TAG.)
;THE LENGTH OF ALTERNATIVE STATEMENTS
;MUST BE EXACTLY 2**N LONG, WHERE N IS THE NUMBER OF ONE BITS IN
;"ACTIVE BITS".   THE FLAGWORD QUARTER NUMBER IS INCLUDED SO
;THE ASSEMBLER CAN EASILY DETERMINE THE "ZERO BITS" (IE THOSE
;THAT HAVE BEEN HARDWIRED TO ALWAYS BE ZERO).
;	PASS 4 THEN OPERATES BY INITIALIZING A 16 BIT VECTOR
;OF ONES FOR EACH 16-GROUP OF AVAILABLE CONTROL MEMORY LOCATIONS.
;THESE ARE STORED IN THE C-MEM-AVAILABLE-WORDS ARRAY.
;(THERE IS ONE ENTRY FOR EACH 16-GROUP.  THUS A STORAGE
;LOCATION IS FREQUENTLY SPECIFIED AS A 2 LIST, THE
;16.-GROUP INDEX, AND THE LOCATION WITHIN THE GROUP SPECIFIED
;AS A POWER OF 2).
;PASS 4 THEN PROCEEDS DOWN THE CONDS-LIST.  THE INITIAL GOAL
;IS TO SEE IF ANY OF THE STORAGE WORDS IN THE CONS-LIST
;ENTRY HAVE ALREADY BEEN ASSIGNED STORAGE WHICH CAN BE
;USED TO HELP IMPLEMENT THIS CONDS-LIST-ENTRY. 
;	FIRST DETERMINE THE POSSIBLE STORAGE PATTERN
;       WITHIN THE 16-GROUP.  IF THERE ARE NO ALWAYS
;	ZEROS IN THE FLAGWORD QUARTER, THIS WILL USUALLY
;	BE A SINGLE POSSIBILITY. (IT CAN BE MORE BECAUSE
;	SOME LOGICAL CONDITIONS ARE STORED IN MORE THAN
;	ONE FLAGWORD QUARTER).  THE RESULTS OF THIS ARE
;	A SERIES OF NUMBERS. IF THE C-MEM-AVAILABLE WORDS
;	ENTRY OF A 16-GROUP CONTAINS ONES IN ALL OF THE
;	BIT POSITIONS HAVING A ONE IN ONE OF THESE
;	NUMBERS,  THAT 16-GROUP CAN DEFINITELY BE USED.
;	IF NOT, IT CAN BE USED ONLY IF THOSE MASKED LOCATIONS
;	CONTAINING ZEROES HAPPEN TO ALREADY CONTAIN EXACTLY THE
;	REQUIRED CONTENTS.
;  L1:  SCAN DOWN CONDS-LIST ENTRY UNTIL FIND STORAGE WORD
;	   WHICH ALREADY HAS STORAGE ASSIGNED.  IF NONE,
;	   GO TO DEFAULT-ASSIGN.
;  L2:  SCAN DOWN LIST OF LOCATIONS WHICH HAVE BEEN ASSIGNED
;	   TO THAT STORAGE WD. 
;	 FOR EACH OF THEM:
;	  IS THIS WORD IN AN ACCEPTABLE POSITION MODULO 16.? 
;	    IF NOT, FLUSH.
;	  ARE THE OTHER NECESSARY LOCATIONS AVAILABLE, OR
;	    IF NOT, DO THEY ALREADY CONTAIN EXACTLY THE
;	    NECESSARY STORAGE WORD?  IF SO, RECORD THE
;	    NUMBER OF NEW STORAGE WORDS IT WILL REQUIRE TO
;	    ASSEMBLE THINGS HERE, AND KEEP LOOKING FOR A
;	    BETTER SPOT, UNLESS THIS IS 0.
;  SINCE WE ARE DOING A "TRIANGULAR" SORT OF SEARCH,
;ONCE WE ADVANCE DOWN THE CONDS-LIST ENTRY N STEPS, ANYTHING
;WE DO WILL INVOLVE AT LEAST N NEW STORAGE WORDS.  IF
;AT ANY TIME THIS GETS TO BE AS MANY AS WE HAVE A WAY OF
;DOING THINGS IN, STOP LOOKING.

;SUMMARY OF ARRAYS INDEXED BY <TAG-BASE+GENERATION-NUMBER>

;CHASM-STORAGE-WORD  STORES MAIN PART OF CORRESPONDING STORAGE WORD

;CHASM-NEXT-TEXTUAL-LINK  STORES A POINTER TO THE ATOM FOR THE 
;	TEXTUALLY NEXT STORAGE WORD.
;CHASM-REAL-TAG-NAME HAS NIL OR TAG THIS IS A SYNONYM FOR.
;CHASM-NEXT-ADDRESS-LINK  NIL OR NEXT-ADDRESS-FIELD
;CHASM-STORAGE-LOCATIONS  CONTAINS LIST OF LOCATIONS AT WHICH THIS STORAGE
;	WORD HAS BEEN STORED.

;THE NEXT-ADDRESS-LINK ARRAY ENTRY AS PRODUCED BY CHASM-3:
;  MAY BE NIL, IN WHICH CASE IS ASSUMED TO REPRESENT AN UNCONDITIONAL TRANSFER
;	  TO THE CHASM-NEXT-TEXTUAL-LINK STORAGE WD.
;  IF PRESENT, IT IS A 3-LIST:
;	CAR IS THE BIT-LIST.  BIT-LIST CAN BE NIL OR ANY COMBINATION OF:
;	  PUSHJ POPJ INHIBIT-WRITE-IF-BRANCH STATISTICS-BIT E-LONG.
;	  ALSO, IF PUSHJ IS PRESENT, A ELEMENT OF THE FORM (RETURN-TARGET <TAG>)
;	  MAY ALSO BE PRESENT.  IF THIS ELEMENT IS NOT PRESENT, THE
;	  RETURN TARGET OF A PUSHJ IS THE SAME AS THE NEXT-TEXTUAL-LINK.
;	CADR IS THE DISPATCH-FIELD-LIST.  THIS IS A LIST OF THE
;	  SYMBOLIC FLAGWORD-QUARTER BITS OR BIT FIELDS SPECIFIED.
;	  ERROR IF THEY ARE NOT ALL IN SAME QUARTER, ETC.
;	  IF UNCONDITIONAL TRANSFER, LIST WILL BE OF ONE ELEMENT "TRANSFER".
;	CADDR IS THE TAG LIST.  ERROR UNLESS OF LENGTH 2**<NUMBER ACTIVE BITS IN
;	  TRANSLATED DISPATCH-FIELD.  EACH ELEMENT MAY BE A ATOMIC TAG
;	  (FOR CURRENT SIDE) OR A 2-LIST SPECIFYING SIDE AND TAG.


;CHASM-4 FILLS CHASM-NAF WITH THE NUMERIC NEXT-ADDRESS FIELD FOR THOSE STORAGE-HEADS
;  WHICH CONTAIN CONDITIONALS.  THE NUMERIC VALUE INCLUDES THE APPROPRIATE COND FIELD.
;  IT CONTAINS NIL FOR STORAGE-HEADS THAT
;  HAVE SIMPLE TRANSFERS (EITHER TO NEXT-TEXTUAL-LINK OR ELSEWHERE.)  THE COND FIELD
;  IS ALWAYS 0 IN THIS CASE.

(SETQ CHEOPS-CONTROL-MEMORY-LENGTH 1024.)

(DECLARE (SPECIAL CHEOPS-CONTROL-MEMORY-LENGTH CHEOPS-NUMBER-GROUPS 
		 CHASM-GENERATION-NUMBER CHASM-NUMBER-GENERATIONS 
		 CHASM-DATA-VECTOR-LENGTH CHEOPS-LAST-TAG 
		 CHEOPS-WDS-SINCE-LAST-TAG CHEOPS-PASS CHEOPS-INDEX-ASSIGNMENT-POINTER 
		 CHEOPS-STORAGE-WORD-OPERATIONS))

(COMMENT
(DECLARE (ARRAY* (NOTYPE (CHASM-STORAGE-LOCATIONS NIL) (CHEOPS-GROUP-ARRAY NIL) 
		(CHASM-STORAGE-WORD NIL) (CHASM-NEXT-TEXTUAL-LINK NIL) 
		(CHASM-REAL-TAG-NAME NIL) (CHASM-NEXT-ADDRESS-LINK NIL) 
		(CHASM-NAF NIL) (ACTIVE-BITS-COUNT-ARRAY NIL)))) )

(SETQ CHEOPS-STORAGE-WORD-OPERATIONS '(ALU ARRAY ARRAY-HOLD DUPLICATE-OP))

(DEFUN CHASM-4-INIT NIL 
  (PROG (TEM)
	(*ARRAY 'CHASM-STORAGE-LOCATIONS T CHASM-DATA-VECTOR-LENGTH)
	(*ARRAY 'CHASM-NAF T CHASM-DATA-VECTOR-LENGTH)
	(*ARRAY 'CHEOPS-GROUP-ARRAY T 
		(SETQ CHEOPS-NUMBER-GROUPS (// CHEOPS-CONTROL-MEMORY-LENGTH 20)))
	(SETQ TEM (1- CHEOPS-NUMBER-GROUPS))
   L	(STORE (CHEOPS-GROUP-ARRAY TEM) 177777)
	(COND ((MINUSP (SETQ TEM (1- TEM)))
		(RETURN T)))
	(GO L)))

(DEFUN CHASM-4-GET-INDEX (WORD-DESC)
  (PROG (TEM ATOM-HEAD INDEX)
	(COND ((NUMBERP WORD-DESC)
		(RETURN WORD-DESC))
	      ((ATOM WORD-DESC)
		(SETQ ATOM-HEAD WORD-DESC)
		(SETQ INDEX CHASM-GENERATION-NUMBER)
		(GO T1))
	      ((EQ (CAR WORD-DESC) 'TAG-IN-GENERATION)
		(SETQ INDEX (CADR WORD-DESC))
		(SETQ ATOM-HEAD (CADDR WORD-DESC))
		(GO T1))
	      ((EQ (CAR WORD-DESC) 'BLACK-TAG)
		(SETQ INDEX (1+ (LOGAND CHASM-GENERATION-NUMBER 177776))))
	      ((EQ (CAR WORD-DESC) 'WHITE-TAG)
		(SETQ INDEX (LOGAND CHASM-GENERATION-NUMBER 177776)))
	      ((EQ (CAR WORD-DESC) 'OTHER-SIDE-TAG)
		(SETQ INDEX (LOGXOR CHASM-GENERATION-NUMBER 1)))
	      ((EQ (CAR WORD-DESC) 'SAME-SIDE-TAG)
		(SETQ INDEX CHASM-GENERATION-NUMBER))
	      (T (CHEOPS-BARF WORD-DESC 'BAD-WORD-DESC 'BARF)))
	(SETQ ATOM-HEAD (CADR WORD-DESC))
   T1   (COND ((NULL (SETQ TEM (GET ATOM-HEAD 'CHASM-TAG-BASE)))
		(CHEOPS-BARF WORD-DESC 'NO-TAG-BASE-PROP 'BARF)))
	(SETQ TEM (+ TEM INDEX))
	(COND ((CHASM-REAL-TAG-NAME TEM)
		(SETQ ATOM-HEAD (CHASM-REAL-TAG-NAME TEM))
		(GO T1)))
	(RETURN TEM)
))
  
(DEFUN CHASM-4-GET-NEXT-ADDRESS-LINK (WORD-DESC)
  (PROG (IDX TEM)
	(SETQ IDX (CHASM-4-GET-INDEX WORD-DESC))
	(COND ((SETQ TEM (CHASM-NEXT-ADDRESS-LINK IDX))
		(RETURN TEM)))
	(RETURN (LIST NIL '(TRANSFER) (CHASM-NEXT-TEXTUAL-LINK IDX)))))

(DEFUN CHASM-4-GET-NEXT-TEXTUAL-LINK (WORD-DESC)
	(CHASM-NEXT-TEXTUAL-LINK (CHASM-4-GET-INDEX WORD-DESC)))

(DEFUN CHASM-4-GET-STORAGE-LOCATIONS (WORD-DESC)
	(CHASM-STORAGE-LOCATIONS (CHASM-4-GET-INDEX WORD-DESC)))

(DEFUN CHASM-4-ADVANCE-TO-NEXT-STATEMENT (ATOM-HEAD)
	(CHASM-NEXT-TEXTUAL-LINK (CHASM-4-GET-INDEX ATOM-HEAD)))

;ACTIVE-BITS IS A NUMBER 0-17 CONTAINING ONES IN THOSE FLAGWORD-QUARTER
;BITS WE WANT TO TEST. (IF N ONE BITS ARE PRESENT, IT MEANS WE ARE DOING
;A 2**N WAY DISPATCH).  ZERO-BITS IS A NUMBER 0-17 CONTAINING ONES IN THOSE
;FLAGWORD-QUARTER BITS WHICH ARE HARDWIRED 0.  CHASM-4-GET-STORAGE-PATTERN
;RETURNS A LIST OF NUMBERS EACH OF WHICH REPRESENTS A POSSIBLE 
;STORAGE PATTER WITHING A 16.-GROUP.  THIS LIST WILL BE 2**<NUMBER OF ONE
;BITS IN ZERO-BITS> LONG.  UNARY REPRESENTATION FOR POSITION WITHING
;THE 16. GROUP IS EMPLOYED, WITH LOCATION 0 CORRESPONDING TO THE LOW ORDER
;BIT.  EACH OUTPUT NUMBER WILL HAVE THE SAME NUMBER OF BITS SET AS
;THERE ARE WAYS IN THE BRANCH.

(DEFUN CHASM-4-GET-STORAGE-PATTERN (ACTIVE-BITS ZERO-BITS)
  (PROG (PATS LOC MASKED-OUT-BITS TEM ACTIVE-BITS-COUNT)
	(SETQ LOC 0)
	(SETQ MASKED-OUT-BITS (BOOLE 1 17 (BOOLE 10 ACTIVE-BITS ZERO-BITS)))	;ANDCB
    L	(COND ((NOT (< LOC 17)) (RETURN (NREVERSE PATS)))
	      ((AND (= 0 (BOOLE 1 LOC ACTIVE-BITS))	;BASE LOCN MUST 
							;HAVE 0 IN ACTIVE BITS
		    (= 0 (BOOLE 2 LOC MASKED-OUT-BITS)))   ;AND ONE IN MASKED BITS
		(GO B)))	;THIS LOCN CAN SERVE AS A BASE LOCN
    L1	(SETQ LOC (1+ LOC))
	(GO L)
    B	(SETQ TEM (LSH 1 LOC))		;BASE LOCN OF GROUP
	(SETQ ACTIVE-BITS-COUNT (ACTIVE-BITS-COUNT-ARRAY ACTIVE-BITS))
    B1	(COND ((NULL ACTIVE-BITS-COUNT)
		(SETQ PATS (CONS TEM PATS))
		(GO L1)))
	(SETQ TEM (BOOLE 7 TEM (LSH 1 (+ LOC (CAR ACTIVE-BITS-COUNT)))))
	(SETQ ACTIVE-BITS-COUNT (CDR ACTIVE-BITS-COUNT))
	(GO B1)))

(ARRAY ACTIVE-BITS-COUNT-ARRAY T 20)
(STORE (ACTIVE-BITS-COUNT-ARRAY 0) NIL)
(STORE (ACTIVE-BITS-COUNT-ARRAY 1) '(1))
(STORE (ACTIVE-BITS-COUNT-ARRAY 2) '(2))
(STORE (ACTIVE-BITS-COUNT-ARRAY 3) '(1 2 3))
(STORE (ACTIVE-BITS-COUNT-ARRAY 4) '(4))
(STORE (ACTIVE-BITS-COUNT-ARRAY 5) '(1 4 5))
(STORE (ACTIVE-BITS-COUNT-ARRAY 6) '(2 4 6))
(STORE (ACTIVE-BITS-COUNT-ARRAY 7) '(1 2 3 4 5 6 7))
(STORE (ACTIVE-BITS-COUNT-ARRAY 10) '(10))
(STORE (ACTIVE-BITS-COUNT-ARRAY 11) '(1 10 11))
(STORE (ACTIVE-BITS-COUNT-ARRAY 12) '(2 10 12))
(STORE (ACTIVE-BITS-COUNT-ARRAY 13) '(1 2 3 10 11 12 13))
(STORE (ACTIVE-BITS-COUNT-ARRAY 14) '(4 10 14))
(STORE (ACTIVE-BITS-COUNT-ARRAY 15) '(1 4 5 10 11 14 15))
(STORE (ACTIVE-BITS-COUNT-ARRAY 16) '(2 4 6 10 12 14 16))
(STORE (ACTIVE-BITS-COUNT-ARRAY 17) '(1 2 3 4 5 6 7 10 11 12 13 14 15 16 17))

;ASSIGNING THE DISPATCH LIST:
;  TWO LOOPS ARE USED.  THE OUTTER ONE ASSIGNS A FLAGWORD QUARTER TO
;	THE FIRST ELEMENT, AND THE INNER ON TRIES TO ASSIGN THE REMAINING
;	ELEMENTS TO THAT FLAGWORD QUARTER.  
;  RETURNS A 3-LIST OF FLAGWORD-QUARTER NUMBER, ACTIVE-BITS AND ZERO-BITS.

(DEFUN CHASM-4-ASSIGN-DISPATCH-LIST (D-L)
  (PROG (I1 Q1 L1 I-REST Q2 L2 ACTIVE-BITS ZERO-BITS)
	(SETQ I1 (CAR D-L))
	(COND ((NULL (SETQ L1 (GET I1 'CHEOPS-FLAGBIT-FIELD)))
		(GO E1)))		;UNKNOWN FLAGBIT SPECIFIER
   L1	(COND ((NULL L1) (GO E2)))	;CANT SEEM TO WIN ON THIS ONE
	(SETQ Q1 (CAAR L1))
	(SETQ ACTIVE-BITS (CADAR L1))
	(SETQ ZERO-BITS (CADDAR L1))
   	(SETQ I-REST (CDR D-L))
   L2	(COND ((NULL I-REST) (GO X))	;HAVE WON
	      ((NULL (SETQ L2 (GET (CAR I-REST) 'CHEOPS-FLAGBIT-FIELD)))
		(SETQ I1 (CAR I-REST))
		(GO E1)))		;UNKNOWN FLAGBIT SPECIFIER
   L3	(COND ((NULL L2) (GO L1A))	;CANT ASSIGN THIS ONE WITH FIRST 
					; ASSIGNED TO THAT ONE
	      ((NOT (= Q1 (CAAR L2)))
		(SETQ L2 (CDR L2))
		(GO L3)))		;NOT IN RIGHT QUARTER
	(SETQ ACTIVE-BITS (LOGIOR ACTIVE-BITS (CADAR L2)))
	(COND ((NOT (= ZERO-BITS (CADDAR L2)))
		(CHEOPS-BARF (LIST I1 (CAR I-REST))
			     'FLAGBIT-PROPERTIES-SCREWWED
			     'BARF)))
	(SETQ I-REST (CDR I-REST))
	(GO L2)
   L1A	(SETQ L1 (CDR L1))		;TRY NEXT ASSIGN FOR FIRST
	(GO L1)
   E1	(CHEOPS-BARF I1 'UNKNOWN-FLAGBIT-SPECIFIER 'DATA)
   E-X	(RETURN '(0 0 17))
   E2   (CHEOPS-BARF D-L 'UNABLE-TO-ASSIGN-DISPATCH-LIST 'DATA)
	(GO E-X)
   X	(RETURN (LIST Q1 ACTIVE-BITS ZERO-BITS)) ))

(DEFUN CHASM-4 NIL 
  (PROG (CHASM-4-CURRENT-ATOM-HEAD CHASM-GENERATION-NUMBER CHEOPS-LAST-TAG 
	CHEOPS-WDS-SINCE-LAST-TAG CHEOPS-PASS)
	(SETQ CHEOPS-PASS 4)			;FOR CHEOPS-BARF
	(SETQ CHEOPS-WDS-SINCE-LAST-TAG 0)	;SINCE EVERY STG WD HAS TAG NOW
	(SETQ CHASM-GENERATION-NUMBER 0)
	(CHASM-4-INIT)
    L3	(SETQ CHASM-4-CURRENT-ATOM-HEAD 'CHEOPS-PRGM-BEG)
    L1	(COND ((NULL CHASM-4-CURRENT-ATOM-HEAD) (GO L2)))
	(SETQ CHEOPS-LAST-TAG CHASM-4-CURRENT-ATOM-HEAD)
	(CHASM-4-WD CHASM-4-CURRENT-ATOM-HEAD)
	(SETQ CHASM-4-CURRENT-ATOM-HEAD 
		(CHASM-4-ADVANCE-TO-NEXT-STATEMENT CHASM-4-CURRENT-ATOM-HEAD))
	(GO L1)
    L2	(COND ((< (SETQ CHASM-GENERATION-NUMBER (1+ CHASM-GENERATION-NUMBER))
		  CHASM-NUMBER-GENERATIONS)
		(GO L3)))
	(CHASM-4-ASSIGN-REST 'T)	;ASSIGN ALL UNCONDITIONAL PUSHJES NOW
	(CHASM-4-ASSIGN-REST 'NIL)	;FILL IN WITH THE COMPLETELY UNCONSTRAINED ONES
	(RETURN T)))

(DEFUN CHASM-4-ASSIGN-REST (PUSHJ-FLAG)
  (PROG (IDX SX-GRP SX-LCN SX-BITS STG-WD)
	(SETQ IDX 0)
	(SETQ SX-BITS 0)
	(SETQ SX-GRP -1)
   L	(COND ((NOT (< IDX CHEOPS-INDEX-ASSIGNMENT-POINTER))
		(RETURN T))
	      ((OR (NULL (SETQ STG-WD (CHASM-STORAGE-WORD IDX)))
		   (CHASM-STORAGE-LOCATIONS IDX)
		   (NOT (MEMQ (CAAR STG-WD) CHEOPS-STORAGE-WORD-OPERATIONS))
		   (AND PUSHJ-FLAG (NULL (CHASM-4-GET-PUSHJ-RETURN-TARGET IDX))))
		(GO L1X)))		;NO STG WD OR ALREADY STORED OR NOT PUSHJ
   L1	(COND ((NOT (= 0 SX-BITS))(GO L2))
	      ((NOT (< (SETQ SX-GRP (1+ SX-GRP)) CHEOPS-NUMBER-GROUPS))
		(CHEOPS-BARF PUSHJ-FLAG 'CHASM-4-OUT-OF-SPACE 'BARF)))
	(SETQ SX-BITS (CHEOPS-GROUP-ARRAY SX-GRP))
	(SETQ SX-LCN 0)
	(GO L1)
   L2	(COND ((= 0 (LOGAND 1 SX-BITS))
		(SETQ SX-LCN (1+ SX-LCN))
		(SETQ SX-BITS (LSH SX-BITS -1))
		(GO L2)))
	(SETQ CHASM-GENERATION-NUMBER (\ IDX CHASM-NUMBER-GENERATIONS))
			;MUST BE SET UP SO RETURN TARGET TAGS WILL GET DEFAULTED
	(COND ((NULL (CHASM-4-ASSIGN-WORD IDX (+ (LSH SX-GRP 4) SX-LCN) T))
		(SETQ SX-LCN (1+ SX-LCN))
		(SETQ SX-BITS (LSH SX-BITS -1))
		(GO L1)))
	(SETQ SX-LCN (1+ SX-LCN))
	(SETQ SX-BITS (LSH SX-BITS -1))
  L1X	(SETQ IDX (1+ IDX))
	(GO L)))

(DEFUN CHASM-4-WD (ATOM-HEAD)
  (PROG (ADDRESS-LINK DISPATCH-LIST ASSIGNED-D-L POSS-STG-PATS 
	 TARGET-TAG-LIST DISPATCH-POWER VECTOR-INDEX)
	(SETQ VECTOR-INDEX (CHASM-4-GET-INDEX ATOM-HEAD))
 	(SETQ ADDRESS-LINK (CHASM-4-GET-NEXT-ADDRESS-LINK VECTOR-INDEX))
	(COND (ADDRESS-LINK (SETQ DISPATCH-LIST (CADR ADDRESS-LINK))))
	(COND ((OR (NULL ADDRESS-LINK)
		   (NULL DISPATCH-LIST)
		   (EQUAL DISPATCH-LIST '(TRANSFER)))
		(GO X)))	;NO NEED TO ASSIGN TARGET OF THIS GUY NOW.
	(SETQ ASSIGNED-D-L (CHASM-4-ASSIGN-DISPATCH-LIST DISPATCH-LIST))
	(SETQ POSS-STG-PATS (CHASM-4-GET-STORAGE-PATTERN (CADR ASSIGNED-D-L)
							 (CADDR ASSIGNED-D-L)))
	(SETQ TARGET-TAG-LIST (CADDR ADDRESS-LINK))
	(SETQ DISPATCH-POWER (CHASM-COUNT-BITS (CADR ASSIGNED-D-L)))
	(COND ((NOT (= (LENGTH TARGET-TAG-LIST)
		       (LSH 1 DISPATCH-POWER)))
		(CHEOPS-BARF (LIST DISPATCH-LIST TARGET-TAG-LIST)
			     'TARGET-TAG-LIST-WRONG-LENGTH 
			     'DATA)
		(GO X)))
	(CHASM-4-LOCATE-DISPATCH-TARGETS VECTOR-INDEX 
					(CAR ASSIGNED-D-L) 
					 TARGET-TAG-LIST 
					 POSS-STG-PATS)
    X	(RETURN T)))
		    
;POSS-STG-PATS IS A LIST OF 16 BIT NUMBERS.  EACH OF THEM MUST CONTAIN THE SAME
;NUMBER OF BINARY 1S AS TARGET-TAG-LIST IS LONG.
;VECTOR-INDEX IS INDEX OF ATOM HEAD WHERE THIS CRUFT CAME FROM.
; CHASM-NAF OF THAT INDEX IS FILLED WITH STUFF TO IMPLEMENT DISPATCH.

(DEFUN CHASM-4-LOCATE-DISPATCH-TARGETS 
		(VECTOR-INDEX FLAGWORD-QUARTER TARGET-TAG-LIST POSS-STG-PATS)
 (PROG (P1 P-L LEAST-NEW-STG-WDS-REQD LEAST-STG-WDS-GROUP LEAST-STG-WDS-PAT 
	COUNT-DOWN P-T TEM SX-GRP SX-BIT SX-LCN SX-PATTERN STG-L)
	(SETQ LEAST-NEW-STG-WDS-REQD 10000)
	(SETQ COUNT-DOWN 0)
	(SETQ P-T TARGET-TAG-LIST)
   L1	(COND ((NULL (SETQ STG-L (CHASM-4-GET-STORAGE-LOCATIONS (CAR P-T))))
		(GO L1A)))		;FIRST FIND WD THAT HAS STORAGE ASSIGNED
   L4	(SETQ P-L POSS-STG-PATS)
	(SETQ SX-PATTERN (CAR P-L))
	(SETQ SX-GRP (LSH (CAR STG-L) -4))	;16 GRP NUMBER
	(SETQ SX-LCN (LOGAND (CAR STG-L) 17))	;POSITION OF THAT COPY OF WD WITHIN
	(SETQ SX-BIT (LSH 1 SX-LCN))		;16-GRP
   L3	(COND ((OR (= 0 (LOGAND SX-BIT SX-PATTERN))	;THAT WD NOT USED THIS PAT
		   (NULL (REPRESENTS-NTH-BIT (1+ COUNT-DOWN)
					     SX-LCN 
					     SX-PATTERN)))	;OR IN WRONG POSITION
		(GO L5)))	;THAT ONE LOSES
;TRY ASSIGNING EVERTHING THERE AND SEE IF
;ITS POSSIBLE AND IF SO, HOW MANY WDS IT TAKES
	(SETQ TEM (CHASM-4-COUNT-NEW-STORAGE-WORDS TARGET-TAG-LIST SX-GRP SX-PATTERN))
	(COND ((OR (NULL TEM)
		   (NOT (< TEM LEAST-NEW-STG-WDS-REQD)))
		(GO L5))		;THAT WAY NOT BEST SO FAR
	      ((= 0 TEM)
		(GO X)))		;THAT COMBO DOES IT EXACTLY
	(SETQ LEAST-NEW-STG-WDS-REQD TEM)		;WDS THIS WOULD TAKE
	(SETQ LEAST-STG-WDS-PAT SX-PATTERN)		;STORAGE PATTERN USED
	(SETQ LEAST-STG-WDS-GROUP SX-GRP)		;GROUP TO PUT IT IN
   L5	(COND ((SETQ P-L (CDR P-L))
		(GO L3))		;TRY USING THAT WD IN ANOTHER STG PATTERN
	      ((SETQ STG-L (CDR STG-L))
		(GO L4))		;OR ANOTHER COPY OF THAT WD
	      (T (GO L1A)))		;FOO! THAT WD IS A LOSER
   L1A	(SETQ COUNT-DOWN (1+ COUNT-DOWN))
	(COND ((SETQ P-T (CDR P-T))
		(GO L1)))
;DROP THRU ON NO STORAGE ASSIGNED TO ANY OF TARGET INSTS YET
	(SETQ P-L POSS-STG-PATS)
   L2C	(SETQ SX-GRP -1)
   L2	(SETQ SX-PATTERN (CAR P-L))
	(COND ((SETQ SX-GRP (CHASM-4-FIND-SX-GROUP SX-PATTERN (1+ SX-GRP)))
		(GO L2A))		;FOUND 16-GRP WITH THAT PATTERN FREE
	      ((SETQ P-L (CDR P-L))
		(GO L2C))		;TRY ANOTHER PATTERN
	      (T (CHEOPS-BARF (LIST TARGET-TAG-LIST POSS-STG-PATS)
		       'CANT-FIND-STORAGE 
		       'BARF)))
   L2A	(COND ((NULL (CHASM-4-ASSIGN-GROUP TARGET-TAG-LIST SX-GRP SX-PATTERN))
		(GO L2)))	;MUST HAVE LOST DUE TO PUSHJ LOSSAGE, TRY AGAIN
    X	(SETQ TEM 0)
    XL	(COND ((= 0 (LOGAND 1 SX-PATTERN))		;ASSEMBLE ADR OF LOWEST
		(SETQ TEM (1+ TEM))			;USED LOCN OF 16-GRP IN NAF
		(SETQ SX-PATTERN (LSH SX-PATTERN -1))
		(GO XL)))
	(STORE (CHASM-NAF VECTOR-INDEX) (+ (LSH FLAGWORD-QUARTER 11.)
					   (LSH SX-GRP 4)
					   TEM))
	(RETURN T)
 ))

;RETURNS NIL IF NOT PUSHJ.
(DEFUN CHASM-4-GET-PUSHJ-RETURN-TARGET (STG-HEAD)
  (PROG (ADDRESS-LINK TEM I-GEN O-IDX)
	(COND ((OR (NULL (SETQ ADDRESS-LINK (CHASM-4-GET-NEXT-ADDRESS-LINK STG-HEAD)))
		   (NOT (MEMQ 'PUSHJ (CAR ADDRESS-LINK))))
		(RETURN NIL))	;NOT PUSHJ
	      ((SETQ TEM (CHASM-4-FIND-RETURN-TARGET-IN-LIST (CAR ADDRESS-LINK)))
		(GO X)))	;EXPLICIT RETURN-TARGET
	(SETQ TEM (CHASM-4-GET-NEXT-TEXTUAL-LINK STG-HEAD))	;RTN TARGET SAME AS 
								;NEXT-TEXTUAL LINK
;CODE BELOW ASSURES RETURN TARGET GETS CORRECT GENERATION INDEX.
;IF RETURN TARGET IS NUMERIC (THIS SHOULD NEVER HAPPEN) OR NON-ATOMIC, IT IS
;ASSUMED TO SPECIFY ITS OWN GENERATION SPEC AND RETURNED.  HOWEVER, IF IT IS
;ATOMIC, IT IS CONVERTED INTO INDEX FORM, AND THE GENERATION SUPPLIED FROM THE
;GENERATION SPEC OF THE STG-HEAD ARG.
   X	(COND ((OR (NUMBERP TEM) (NOT (ATOM TEM)))
		(RETURN TEM)))
	(SETQ I-GEN (\ (CHASM-4-GET-INDEX STG-HEAD) CHASM-NUMBER-GENERATIONS))
	(SETQ O-IDX (CHASM-4-GET-INDEX TEM))
	(RETURN (+ I-GEN (* CHASM-NUMBER-GENERATIONS 
				(// O-IDX CHASM-NUMBER-GENERATIONS))))
))

(DEFUN CHASM-4-FIND-RETURN-TARGET-IN-LIST (BIT-LIST)
  (PROG (TEM)
	(SETQ TEM BIT-LIST)
   L	(COND ((NULL TEM) (RETURN NIL))
	      ((ATOM (CAR TEM)) (GO L1))
	      ((EQ (CAAR TEM) 'RETURN-TARGET) (RETURN (CADAR TEM))))
   L1	(SETQ TEM (CDR TEM))
	(GO L)))

(DEFUN CHASM-4-COUNT-NEW-STORAGE-WORDS (TAG-LIST SX-GRP STG-PAT)
  (PROG (C LOCN T-L S-P SX-LCN STG-L R-T SX-GRP-TEM STG-L-TEM)
	(SETQ C 0)
	(SETQ T-L TAG-LIST)
	(SETQ S-P STG-PAT)
	(SETQ SX-LCN 0)
   L	(COND ((NULL T-L) (RETURN C))
	      ((= 0 (LOGAND 1 S-P))
		(GO L1A))	;THAT LOCN NOT USED THIS STG PATTERN
	      ((NULL (SETQ STG-L (CHASM-4-GET-STORAGE-LOCATIONS (CAR T-L))))
		(GO L1)))
	(SETQ LOCN (+ (LSH SX-GRP 4) SX-LCN))
	(COND ((MEMBER LOCN STG-L) (GO L1B)))	;XFER ON THAT ONE ALREADY THERE
   L1	(COND ((NULL (SETQ R-T (CHASM-4-GET-PUSHJ-RETURN-TARGET (CAR T-L))))
		(GO L1C)))	;NO PUSHJ COMPLICATIONS
	(SETQ SX-GRP-TEM SX-GRP)
   L2	(COND ((NOT (< (SETQ SX-GRP-TEM (1+ SX-GRP-TEM))
		        CHEOPS-NUMBER-GROUPS))
		(RETURN NIL)))	;LOSE IF IN LAST SIXTEEN GROUP BECAUSE ...
	(COND ((NOT (= 0 (LOGAND 
		     	   (LSH 1 SX-LCN) 
		     	   (CHEOPS-GROUP-ARRAY SX-GRP-TEM))))
		(SETQ C (1+ C))	;LOCN FREE SO CAN WIN BUT WILL TAKE AN EXTRA WD
		(GO L2A)))
	(COND ((OR (NULL (SETQ STG-L-TEM (CHASM-4-GET-STORAGE-LOCATIONS R-T)))
		   (NOT (MEMBER (+ (LSH SX-GRP-TEM 4) SX-LCN) STG-L-TEM)))
		(RETURN NIL)))	;LOSE BECAUSE LOCN IS TAKEN AND RIGHT WD NOT THERE
   L2A	(COND ((SETQ R-T (CHASM-4-GET-PUSHJ-RETURN-TARGET R-T))
		(GO L2)))	;THAT ONE A PUSHJ TOO, SO GO AROUND LOOP
   L1C	(SETQ C (1+ C))		;THIS ONE NOT ALREADY THERE
   L1B	(SETQ T-L (CDR T-L))	;ADVANCE TO NEXT TAG
   L1A	(SETQ SX-LCN (1+ SX-LCN))
	(SETQ S-P (LSH S-P -1))
	(GO L) ))

(DEFUN CHASM-4-ASSIGN-GROUP (TARGET-TAG-LIST SX-GRP STORAGE-PATTERN)
  (PROG (LOCN S-P T-T-L)
	(SETQ S-P STORAGE-PATTERN)
	(SETQ T-T-L TARGET-TAG-LIST)
	(SETQ LOCN (LSH SX-GRP 4))
    L	(COND ((NULL T-T-L)
		(COND ((NOT (= 0 S-P))
			(CHEOPS-BARF (LIST TARGET-TAG-LIST SX-GRP STORAGE-PATTERN)
			      'LOSSAGE-AT-CHASM-4-ASSIGN-GROUP 
			      'WARN)))
		(RETURN T)))
   L1	(COND ((= 0 (LOGAND 1 S-P)) (GO L2)))
	(COND ((NULL (CHASM-4-ASSIGN-WORD (CAR T-T-L) LOCN T))
		(RETURN NIL)))	;MUST HAVE LOST DUE TO PUSHJ LOSSAGE
	(SETQ S-P (LSH S-P -1))
	(SETQ LOCN (1+ LOCN))
	(SETQ T-T-L (CDR T-T-L))
	(GO L)
   L2	(SETQ S-P (LSH S-P -1))
	(SETQ LOCN (1+ LOCN))
	(GO L1)
))

;IF ERR-FLAG T, LOCN HAD BETTER HAVE RIGHT STUFF OR BE FREE OR ERROR.
;OTHERWISE, WILL SIMPLY RETURN NIL (FAILING) IF WRONG THING ALREADY THERE.
;ERROR IF TARGET WORD DOES NOT CONTAIN A "STORAGE-WORD-OPERATION"
(DEFUN CHASM-4-ASSIGN-WORD (WD LOCN ERR-FLAG)
  (PROG (TEM G-N B-N W-IDX R-T) 
	(SETQ TEM (CHASM-STORAGE-LOCATIONS 
		    (SETQ W-IDX (CHASM-4-GET-INDEX WD))))
	(COND ((NOT (MEMQ (CAAR (CHASM-STORAGE-WORD W-IDX)) 
		           CHEOPS-STORAGE-WORD-OPERATIONS))
		(CHEOPS-BARF (LIST WD LOCN W-IDX) 'ASSIGNED-BAD-OP 'BARF)))
   L	(COND ((NULL TEM) (GO A1))
	      ((= (CAR TEM) LOCN) (RETURN T)))	;ALREADY THERE
	(SETQ TEM (CDR TEM))
	(GO L)
  A1	(SETQ B-N (LOGAND LOCN 17))
	(SETQ G-N (LSH LOCN -4))
	(COND ((= 0 (LOGAND (CHEOPS-GROUP-ARRAY G-N) (LSH 1 B-N)))
		(GO E1)))
	(COND ((NULL (SETQ R-T (CHASM-4-GET-PUSHJ-RETURN-TARGET WD)))
		(GO A2)))	;NO PUSHJ LOSSAGE
	(COND ((NULL (CHASM-4-ASSIGN-WORD R-T (+ 20 LOCN) NIL))
		(RETURN NIL)))	;CAN'T PUT IN RETURN TARGET, SO FAIL
  A2	(STORE (CHEOPS-GROUP-ARRAY G-N) (BOOLE 2 (LSH 1 B-N) (CHEOPS-GROUP-ARRAY G-N)))
	(STORE (CHASM-STORAGE-LOCATIONS W-IDX)
	       (CONS LOCN (CHASM-STORAGE-LOCATIONS W-IDX)))
	(RETURN T)
  E1	(COND (ERR-FLAG	(CHEOPS-BARF (LIST WD LOCN)
		      		'LOCN-ALREADY-TAKEN 
		      		'BARF)))
	(RETURN NIL)
))

(DEFUN CHASM-4-FIND-SX-GROUP (FREE-PAT STARTING-GROUP)
  (PROG (G)
	(SETQ G STARTING-GROUP)
   L	(COND ((= 0 (BOOLE 4 FREE-PAT (CHEOPS-GROUP-ARRAY G)))
		(RETURN G))
	      ((NOT (< (SETQ G (1+ G)) CHEOPS-NUMBER-GROUPS))
		(RETURN NIL)))	;NO GROUP WITH THAT PATTERN FREE
	(GO L)))

;RETURNS T IF <N TH> BIT WORKING FROM LOW END OF <SX-GRP> IS IN BIT POSITION <BIT-NUM>
(DEFUN REPRESENTS-NTH-BIT (N BIT-NUM SX-GRP)
  (PROG (BT-N)
	(SETQ BT-N 0)
   L	(COND ((= 0 (LOGAND 1 SX-GRP)))
	      ((NOT (= 0 (SETQ N (1- N)))))
	      (T (RETURN (= BT-N BIT-NUM))))
	(SETQ BT-N (1+ BT-N))
	(SETQ SX-GRP (LSH SX-GRP -1))
	(GO L)
))

(DEFUN CHASM-COUNT-BITS (N)
  (PROG (A)
	(SETQ A 0)
  L	(COND ((= 0 N) (RETURN A))
	      ((NOT (= 0 (LOGAND 1 N)))
		(SETQ A (1+ A))))
	(SETQ N (LSH N -1))
	(GO L)))

(DEFUN T-MULT-STORED NIL 
  (PROG (IDX TEM GEN TOTAL-WDS MULT-COST)
	(SETQ GEN 0)
	(SETQ TOTAL-WDS 0)
	(SETQ MULT-COST 0)
  L1	(SETQ IDX GEN)
  L	(COND ((NOT (< IDX CHEOPS-INDEX-ASSIGNMENT-POINTER))
		(GO L1A))
	      ((> (SETQ TEM (LENGTH (CHASM-STORAGE-LOCATIONS IDX)))
		  1)
		(PRINT (LIST IDX (CHASM-NEXT-TEXTUAL-LINK IDX) TEM))))
	(SETQ TOTAL-WDS (+ TOTAL-WDS TEM))
	(COND ((> TEM 1)
		(SETQ MULT-COST (+ MULT-COST (1- TEM)))))
	(SETQ IDX (+ IDX CHASM-NUMBER-GENERATIONS))
	(GO L)
  L1A	(COND ((< (SETQ GEN (1+ GEN))
		   CHASM-NUMBER-GENERATIONS)
		(GO L1)))
	(PRINT (LIST 'TOTAL-WDS TOTAL-WDS 'MULT-COST MULT-COST))
	(RETURN T)))