;;; -*-Mode:LISP; Package:USER; Base: 10. -*-
;READ IN LCHESS;CHDEFS > BEFORE RUNNING THIS INTERPRETED..

(DECLARE (SPECIAL CHEOPS-BUFFER-MEMORY CHEOPS-BUFFER-MEMORY-UNIBUS-WD-ADR 
		  CHEOPS-BUFFER-MEMORY-PRIORITY-BLOCK-POINTER 
		  CHEOPS-BUFFER-MEMORY-PRIORITY-BLOCK 
		  CHEOPS-BUFFER-MEMORY-BACKGROUND-BLOCK-POINTER 
		  CHEOPS-BUFFER-MEMORY-BACKGROUND-BLOCK 
		  CHEOPS-DOORBELL-UNIBUS-ADDRESS CHEOPS-ARG-BLOCK-LENGTH 
		  CHEOPS-BUFFER-MEMORY-LENGTH))

(DECLARE (SPECIAL CHEOPS-ARG-QS 
		  CHEOPS-ARG-FLAG CHEOPS-ARG-UNUSED CHEOPS-ARG-MODES 
		  CHEOPS-ARG-SETD CHEOPS-ARG-ALPHA CHEOPS-ARG-BETA 
		  CHEOPS-ARG-FLAGWORD CHEOPS-ARG-CHAIN-POINTER))

(DEFPROP U (OPTIONAL NUMBER) C-ARGS-PROP)

(defun C-COM-u (&OPTIONAL NUM)
   (PROG NIL 
	(COND ((NOT (NUMBERP NUM)) (SETQ NUM 1)))
    L	(COND ((OR (ZEROP NUM)
		   (ZEROP (GAME-FILL-POINTER GAME-ARRAY)))
	       (RETURN T)))
    	(C-REVERT-MOVE)
	(SETQ NUM (1- NUM))
	(GO L)))

(DEFPROP SET-GAME-NAME C-COM-SET-GAME-NAME C-COMMAND)
(DEFPROP SET-GAME-NAME (SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-SET-GAME-NAME (SYL)
   (SETQ C-CURRENT-GAME-NAME SYL))

(DEFPROP STORE-GAME C-COM-STORE-GAME C-COMMAND)
(DEFPROP STORE-GAME (OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-STORE-GAME (&OPTIONAL SYM)
  (PROG (OLDG OLDS IDX LIM NEWBP NEWB MVP CODE)
	(COND (SYM (C-COM-SET-GAME-NAME SYM)))
	(COND ((NULL C-CURRENT-GAME-NAME)
	       (ERROR "NO GAME-NAME SELECTED")))
	(SETQ OLDS (SETQ OLDG (GET C-CURRENT-GAME-NAME 'GAME-MOVES)))
	(SETQ IDX 0 LIM (GAME-FILL-POINTER GAME-ARRAY))
;SPACE OVER PREVIOUSLY STORED GAME SEGMENT, IF ANY, MAKING SURE ITS THE
;SAME AS WHAT EXISTS NOW.
   L	(COND ((NULL OLDS) (GO X1))
	      ((NOT (< IDX LIM))
	       (GO X))			;GAME PREVIOUSLY STORED DEEPER
	      ((NOT (EQ (CAAR OLDS) 'MOVE))
	       (SETQ OLDS (CDR OLDS))	;NOT A MOVE
	       (GO L))
	      ((OR (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-MOVING-PC))
			   (CADAR OLDS)))
		   (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-TO-SQ))
			   (CADDAR OLDS)))
		   (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-CODE))
			   (CAR (CDDDAR OLDS)))))
	       (ERROR "MOVE DFS AT PLY" (// IDX C-GAME-NQS))))
   	(SETQ IDX (+ IDX C-GAME-NQS))
	(SETQ OLDS (CDR OLDS))
	(GO L)
   X1	(SETQ NEWBP
	      (SETQ NEWB 
		    (MAKE-LIST WORKING-STORAGE-AREA (// (- LIM IDX) C-GAME-NQS))))
   L1	(COND ((NOT (< IDX LIM))
	       (GO X2)))

	(RPLACA NEWBP (SETQ MVP (MAKE-LIST WORKING-STORAGE-AREA 
			      (COND ((NULL (SETQ CODE 
						 (AR-1 GAME-ARRAY 
						       (+ IDX C-GAME-CODE)))) 
				     3)
				    (T 4)))))
	(RPLACA MVP 'MOVE)
	(SETQ MVP (CDR MVP))
	(RPLACA MVP (AR-1 GAME-ARRAY (+ IDX C-GAME-MOVING-PC)))
	(SETQ MVP (CDR MVP))
	(RPLACA MVP (AR-1 GAME-ARRAY (+ IDX C-GAME-TO-SQ)))
	(SETQ MVP (CDR MVP))
	(COND (CODE (RPLACA MVP CODE)))
	(SETQ IDX (+ IDX C-GAME-NQS))
	(SETQ NEWBP (CDR NEWBP))
	(GO L1)
   X2	(PUTPROP C-CURRENT-GAME-NAME (NCONC OLDG NEWB) 'GAME-MOVES)
   X   	(RETURN T)
))

(DEFPROP R-GAME C-COM-R-GAME C-COMMAND)
(DEFPROP R-GAME (OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-R-GAME (&OPTIONAL GN)
  (PROG (IDX LIM GAMP) 
	(COND ((NULL GN) (SETQ GN C-CURRENT-GAME-NAME)))
	(SETQ IDX 0 LIM (GAME-FILL-POINTER GAME-ARRAY))
	(SETQ GAMP (GET GN 'GAME-MOVES))
;REVERT AS MANY MOVES AS NECC TO BRING CURRENT POSITION BACK TO GAME LINE
   L	(COND ((NULL GAMP) (GO REV))	;REACHED END OF GAME-LIST, REVERT ANY EXCESS
	      ((NOT (< IDX LIM))
	       (RETURN T))		;NOW ON GAME LINE
	      ((NOT (EQ (CAAR GAMP) 'MOVE))
	       (SETQ GAMP (CDR GAMP))
	       (GO L))
	      ((OR (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-MOVING-PC))
			   (CADAR GAMP)))
		   (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-TO-SQ))
			   (CADDAR GAMP)))
		   (NOT (= (AR-1 GAME-ARRAY (+ IDX C-GAME-CODE))
			   (CAR (CDDDAR GAMP)))))
	       (GO REV)))   ;THIS MOVE NOT IN GAME, REVERT TO HERE
   	(SETQ IDX (+ IDX C-GAME-NQS))
	(SETQ GAMP (CDR GAMP))
	(GO L)
   REV	(COND ((>= IDX LIM) (RETURN T)))
	(C-REVERT-MOVE)
	(SETQ LIM (GAME-FILL-POINTER GAME-ARRAY))
	(GO REV)
))

(DEFPROP TO-GAME-POS C-COM-TO-GAME-POS C-COMMAND)
(DEFPROP TO-GAME-POS (NUMBER OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-TO-GAME-POS (MOVE-NUMBER &OPTIONAL GAME)
  (PROG (GMLIST PN)
	(COND ((NULL GAME) (SETQ GAME C-CURRENT-GAME-NAME)))
	(COND ((NULL GAME) (ERROR "NO GAME NAME")))
	(COND ((NULL (SETQ GMLIST (GET GAME 'GAME-MOVES)))
	       (ERROR "NO GAME MOVES")))
   L1 	(COND ((ZEROP (GAME-FILL-POINTER GAME-ARRAY))
	       (GO L2)))
   	(C-REVERT-MOVE)
	(GO L1)
   L2	(SETQ PN 0)
   L3	(COND ((OR (NULL GMLIST)
		   (>= (// PN 2) (1+ MOVE-NUMBER)))
	       (RETURN T))
	      ((NOT (EQ (CAAR GMLIST) 'MOVE))
	       (SETQ GMLIST (CDR GMLIST))
	       (GO L3)))
   	(C-READ-GAME-PLAY-MOVE (CAR GMLIST))
	(SETQ GMLIST (CDR GMLIST))
	(SETQ PN (1+ PN))
	(GO L3)
))

(DEFPROP A-POS C-COM-A-POS C-COMMAND)
(DEFPROP A-POS (LIST OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-A-POS (LST &OPTIONAL SYM &AUX TEM TEM1)
  (COND ((NULL SYM) (SETQ SYM C-ANNOTATER)))
  (COND ((NULL SYM) (ERROR SYM "NO ANNOTATOR")))
  (COND ((NULL (SETQ TEM (GET C-CURRENT-POSITION 'STATIC-ANNOTATIONS)))
	 (PUTPROP C-CURRENT-POSITION (LIST (LIST SYM LST)) 'STATIC-ANNOTATIONS))
	((NULL (SETQ TEM1 (ASSQ SYM TEM)))
	 (PUTPROP C-CURRENT-POSITION (CONS (LIST SYM LST) TEM) 'STATIC-ANNOTATIONS))
	(T (RPLACA (CDR TEM1) LST))))

(DEFPROP A-GPOS C-COM-A-GPOS C-COMMAND)
(DEFPROP A-GPOS (LIST) C-ARGS-PROP)

(DEFUN C-COM-A-GPOS (LST)
       (C-COM-A-POS LST C-CURRENT-GAME-NAME))

(DEFPROP SET-ANNOTATER C-COM-SET-ANNOTATER C-COMMAND)
(DEFPROP SET-ANNOTATER (SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-SET-ANNOTATER (SYM)
       (SETQ C-ANNOTATER SYM))

(DEFPROP A-MV C-COM-A-MV C-COMMAND)
(DEFPROP A-MV C-INPUT-A-MV C-COMMAND-READER)
;(DEFPROP A-MV (CHESS-MOVE LIST OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-INPUT-A-MV (STRING IDX)
  (PROG (MV LST)
	(MULTIPLE-VALUE (MV IDX) (C-INPUT-MOVE 'DESCRIPTIVE STRING IDX))
	(MULTIPLE-VALUE (LST IDX) (READ-FROM-STRING STRING IDX))
	(RETURN (LIST MV LST) IDX) ))

(DEFUN C-COM-A-MV (MV LST &OPTIONAL SYM &AUX TEM TEM1 TEM2)
  (COND ((NULL SYM) (SETQ SYM C-ANNOTATER)))
  (COND ((NULL SYM) (ERROR SYM "NO ANNOTATER")))
  (COND ((NULL (SETQ TEM (GET C-CURRENT-POSITION 'DYNAMIC-ANNOTATIONS)))
	 (PUTPROP C-CURRENT-POSITION (LIST (LIST SYM (LIST MV LST))) 'DYNAMIC-ANNOTATIONS))
	((NULL (SETQ TEM1 (ASSQ SYM TEM)))
	 (PUTPROP C-CURRENT-POSITION (CONS (LIST SYM (LIST MV LST)) TEM) 'DYNAMIC-ANNOTATIONS))
	((NULL (SETQ TEM2 (ASSOC MV (CDR TEM1))))
	 (RPLACD TEM1 (CONS (LIST MV LST) (CDR TEM1))))
	(T (RPLACA (CDR TEM2) LST)))
)
	
(DEFPROP PRINT-NAMED-GAME C-COM-PRINT-NAMED-GAME C-COMMAND)
(DEFPROP PRINT-NAMED-GAME (OPTIONAL SYMBOL NUMBER) C-ARGS-PROP)

(DEFUN C-COM-PRINT-NAMED-GAME (&OPTIONAL SYM MVN)
       (C-PRINT-GAME STANDARD-OUTPUT SYM (COND (MVN (// MVN 2)))))

(DEFPROP PRINT-GAME C-COM-PRINT-GAME C-COMMAND)
(DEFPROP PRINT-GAME (OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-PRINT-GAME (&OPTIONAL FILE)
   (PROG (C-COM-CURRENT-GAME-NAME STREAM)
	 (REMPROP 'TEMP-GAME-HEADER 'GAME-MOVES)
	 (C-COM-STORE-GAME 'TEMP-GAME-HEADER)
	 (COND (FILE (SETQ STREAM (OPEN FILE '(WRITE))))
	       (T (SETQ STREAM STANDARD-OUTPUT)))
	 (C-PRINT-GAME STREAM 'TEMP-GAME-HEADER 0)
	 (COND (FILE (CLOSE STREAM)))))

(DEFPROP STEP-GAME C-COM-STEP-GAME C-COMMAND)
(DEFPROP STEP-GAME (OPTIONAL NUMBER) C-ARGS-PROP)

(DEFUN C-COM-STEP-GAME (&OPTIONAL (PLYN 0))
   (PROG (C-COM-CURRENT-GAME-NAME)
	 (REMPROP 'TEMP-GAME-HEADER 'GAME-MOVES)
	 (C-COM-STORE-GAME 'TEMP-GAME-HEADER)
	 (C-STEP-GAME 'TEMP-GAME-HEADER PLYN)))

(DEFPROP WRITE-GAME C-COM-WRITE-GAME C-COMMAND)
(DEFPROP WRITE-GAME (STRING OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-WRITE-GAME (FILE &OPTIONAL GAME)
   (COND ((NULL GAME) (SETQ GAME C-CURRENT-GAME-NAME)))
   (COND ((NULL GAME) (ERROR "NO GAME NAME"))
	 (T (C-WRITE-GAME GAME FILE))))

(DEFPROP READ-GAME C-COM-READ-GAME C-COMMAND)
(DEFPROP READ-GAME (STRING) C-ARGS-PROP)

(DEFUN C-COM-READ-GAME (FILE)
   (C-EVAL-SEXP-FROM-FILE FILE))

(DEFPROP READ-OCM-GAME C-COM-READ-OCM-GAME C-COMMAND)
(DEFPROP READ-OCM-GAME (STRING) C-ARGS-PROP)

(DEFUN C-COM-READ-OCM-GAME (FILE)
       (C-COM-U #o1005)
       (C-INPUT-OCM-GAME-FROM-FILE FILE))

(DEFPROP READ-AGB-GAME C-COM-READ-AGB-GAME C-COMMAND)
(DEFPROP READ-AGB-GAME (STRING) C-ARGS-PROP)

(DEFUN C-COM-READ-AGB-GAME (FILE)
       (C-COM-U #o1005)
       (C-INPUT-AGB-GAME-FROM-FILE FILE))

(DEFPROP GM-COMMENT C-COM-GM-COMMENT C-COMMAND)
(DEFPROP GM-COMMENT (LIST OPTIONAL SYMBOL) C-ARGS-PROP)

(DEFUN C-COM-GM-COMMENT (COM &OPTIONAL GM)
   (COND ((NULL GM) (SETQ GM C-CURRENT-GAME-NAME)))
   (PUTPROP GM COM 'COMMENT))

(DEFPROP CT-BOTH C-COM-CT-BOTH C-COMMAND)
(DEFPROP CT-BOTH (NUMBER OPTIONAL NUMBER NUMBER) C-ARGS-PROP)

(DEFUN C-COM-CT-BOTH (SETD &OPTIONAL (ALPHA #o-20000) (BETA #o20000))
       (C-COM-CT SETD ALPHA BETA T))



(DEFPROP CT C-COM-CT C-COMMAND)
(DEFPROP CT (NUMBER OPTIONAL NUMBER NUMBER) C-ARGS-PROP)
(DEFPROP CTS C-COM-CTS C-COMMAND)
(DEFPROP CTS (NUMBER NUMBER OPTIONAL NUMBER NUMBER STRING) C-ARGS-PROP)

(DEFUN C-COM-CTS1 (starting-setd ending-setd alpha beta real-value filename
                                 &optional (stream (open filename 'print))
                                 &aux mes found) 
       (DO ((SETD STARTING-SETD (1+ SETD)) (value))
           ((>= SETD ENDING-SETD)
            (close stream)
            (setq mes "didn't find a checkmate")
            (setq found nil))
           (format stream "~%setd=~d~%" setd)
           (setq value (C-COM-CT SETD ALPHA BETA NIL STREAM)) 
           (cond ((> (abs value) real-value)          ;found mate 
                  (format stream "~%backing up one ply~%")
                  (c-com-u 1)
                  (c-display-board white-at-top-p)
                  (cond ((or (white-king-in-check-p)
                             (black-king-in-check-p))
                         (close stream)
			 (c-com-cts-cont-search setd alpha beta real-value filename))
                        ((c-com-cts-cont-search (1+ setd) alpha
						beta real-value filename)))
                  (setq mes "found a checkmate")
                  (setq found t)
                  (return nil))))
       (format t "~s~%" mes)
       found)


(defun c-com-cts-cont-search (s alpha beta real-value filename)
       (do ((setd s (1+ setd))
	    (stream (open filename 'print)))
	   (nil)
	   (cond ((c-com-cts1 setd (1+ setd) alpha beta real-value filename)
		  (return nil)))
	   (format stream "didn't find the expected mate")))

(defun c-com-cts  (STARTING-SETD ENDING-SETD
                  &OPTIONAL (ALPHA #o-20000) (BETA #o20000)
                  (real-value #o4000)(FILENAME "CHESS;CTS >"))
       (c-com-cts1 starting-setd ending-setd alpha beta real-value filename))

(DEFUN C-COM-CT (SETD &OPTIONAL (ALPHA #o-20000) (BETA #o20000)
                      BOTH-SIDES-MODE (STREAM STANDARD-OUTPUT))
 (PROG (V M STATB STATA VAR-LIST)
      (CHEOPS-START-PRIORITY (COND ((NULL BOTH-SIDES-MODE) 0)
				   (T #o400))
			     SETD
			     ALPHA
			     BETA)
      (MULTIPLE-VALUE (V M STATB STATA VAR-LIST) 
		      (CHEOPS-FETCH-RESULTS CHEOPS-BUFFER-MEMORY-PRIORITY-BLOCK))
      (FORMAT STREAM 
"Value ~D, Initial Wood ~D, Delta ~D
STATB ~O, STATA ~O
"
	V M (- V M) STATB STATA)
      (COND ((= V ALPHA)
	     (FORMAT STREAM "Negative A//B Cut, PV invalid"))
	    ((= V BETA)
	     (FORMAT STREAM "Positive A//B Cut, PV invalid"))
	    (T (C-PRINT-VARIATION VAR-LIST STREAM)))
      (TERPRI STREAM)
      (COND (BOTH-SIDES-MODE 
	     (MULTIPLE-VALUE (V VAR-LIST)
		(CHEOPS-FETCH-OTHER-SIDE-RESULTS CHEOPS-BUFFER-MEMORY-PRIORITY-BLOCK))
	     (FORMAT STREAM 
"With OTHER side to move, Value ~D
" 
	 V)
	     (COND ((= V ALPHA)
		    (FORMAT STREAM "Negative A//B Cut, PV invalid"))
		   ((= V BETA)
		    (FORMAT STREAM "Positive A//B Cut, PV invalid"))
		   (T (C-PRINT-OTHER-SIDE-VARIATION VAR-LIST STANDARD-OUTPUT)))
	     (TERPRI STREAM)))
      (RETURN V)))

(DEFPROP CTB C-COM-CTB C-COMMAND)	;TEMPORARY GROSSNESS
(DEFPROP CTB (NUMBER OPTIONAL NUMBER NUMBER) C-ARGS-PROP)

(DEFUN C-COM-CTB (SETD &OPTIONAL (ALPHA #o-20000) (BETA #o20000))
 (PROG (V M STATB STATA VAR-LIST)
      (CHEOPS-START-BACKGROUND 0 SETD ALPHA BETA)
      (MULTIPLE-VALUE (V M STATB STATA VAR-LIST) 
		      (CHEOPS-FETCH-RESULTS CHEOPS-BUFFER-MEMORY-BACKGROUND-BLOCK))
      (FORMAT STANDARD-OUTPUT 
"Value ~D, Initial Wood ~D, Delta ~D
STATB ~O, STATA ~O
"
	V M (- V M) STATB STATA)
      (C-PRINT-VARIATION VAR-LIST STANDARD-OUTPUT)
      (TERPRI STANDARD-OUTPUT)
))

(DEFPROP CT-RING C-COM-CT-RING C-COMMAND)
(DEFPROP SBACK C-COM-CT-RING C-COMMAND)

(DEFPROP CT-RING (NUMBER OPTIONAL NUMBER NUMBER) C-ARGS-PROP)
(DEFPROP SBACK (NUMBER OPTIONAL NUMBER NUMBER) C-ARGS-PROP)

(DEFUN C-COM-CT-RING (SETD &OPTIONAL (ALPHA #o-20000) (BETA #o20000))
   (CHEOPS-START-BACKGROUND-RING-FROM-MOVE-LIST
		 (C-GET-MY-MOVE-LIST) #o3000 (1- SETD) ALPHA BETA))

(DEFPROP CT-RING-STAT C-COM-CT-RING-STAT C-COMMAND)
(DEFPROP PBACK C-COM-CT-RING-STAT C-COMMAND)

(DEFUN C-COM-CT-RING-STAT NIL 
   (PROG (MOVE-LIST IDX LIM SETD1 BADR V M STATB STATA VAR-LIST)
	 (SETQ MOVE-LIST (GET CHEOPS-BACKGROUND-RING-POSITION 'MOVE-LIST))
	 (SETQ IDX 0 LIM (ARRAY-ACTIVE-LENGTH MOVE-LIST))
	 (SETQ BADR (- (AR-1 CHEOPS-BUFFER-MEMORY 
			     CHEOPS-BUFFER-MEMORY-BACKGROUND-BLOCK-POINTER)
		       CHEOPS-BUFFER-MEMORY-UNIBUS-WD-ADR))
     L   (COND ((NOT (< IDX LIM)) (RETURN T))
               ((EQ (AR-1 MOVE-LIST (+ IDX C-MVL-STATE))
		    'ILLEGAL)
		(GO E0)))
         (PRINC "After ")
	 (C-PRINT-MOVE-FROM-MOVE-LIST MOVE-LIST IDX)
    L0	 (SETQ SETD1 (AR-1 CHEOPS-BUFFER-MEMORY (+ BADR CHEOPS-ARG-SETD)))
	 (MULTIPLE-VALUE (V M STATB STATA VAR-LIST)
			 (CHEOPS-FETCH-RESULTS BADR))
	 (COND ((NOT (= (AR-1 CHEOPS-BUFFER-MEMORY (+ BADR CHEOPS-ARG-SETD))
			SETD1))
		(GO L0)))	;CHEOPS COMPLETED NEW PLY, RESULTS MAY BE INVALID
	 (FORMAT STANDARD-OUTPUT 
"Value ~D, Delta ~D, SETD ~D,
"	V M SETD1)
	 (C-OUTPUT-LIST-OF-MOVES VAR-LIST STANDARD-OUTPUT)
	 (TERPRI)
	 (SETQ BADR (+ BADR CHEOPS-ARG-BLOCK-LENGTH))
  E0	 (SETQ IDX (+ IDX C-MVL-NQS))
	 (GO L)
))

(DEFPROP CT-RING-ABORT C-COM-CT-ABORT-RING C-COMMAND)
(DEFPROP ABACK C-COM-CT-ABORT-RING C-COMMAND)

(DEFUN C-COM-CT-ABORT-RING NIL (CHEOPS-ABORT-BACKGROUND))

(DEFPROP SPS C-COM-SPS C-COMMAND)
(DEFPROP SPS (NUMBER) C-ARGS-PROP)

;SIMPLE PS
(DEFUN C-COM-SPS (D)
  (PROG (RA IDX LIM MOVE-LIST)
   L	(COND ((KBD-TYI-NO-HANG) (RETURN T)))
   	(SETQ RA (CHEOPS-COMPUTE-RESULTS D))
	(SETQ MOVE-LIST (CHEOPS-RESULTS-MOVE-LIST-POINTER RA))
	(SETQ IDX 0 LIM (ARRAY-ACTIVE-LENGTH RA))
   L1	(COND ((NOT (< IDX LIM))
	       (RETURN NIL)))		;NO MOVES
	(C-REACH-FOLLOWING-POSITION MOVE-LIST 
				    (AR-1 RA (+ IDX C-CH-MOVE-IDX)))
;SEE IF THAT ONE LEGAL.
	(COND ((COND ((WHITE-TO-MOVE-P)
		      (BLACK-KING-IN-CHECK-P))
		     (T (WHITE-KING-IN-CHECK-P)))
	       (C-REVERT-MOVE)
	       (SETQ IDX (+ IDX C-CH-NQS))
	       (GO L1)))
        (C-DISPLAY-BOARD WHITE-AT-TOP-P)
	(GO L)))

(DEFPROP MO C-COM-MO C-COMMAND)
(DEFPROP MO (CHESS-MOVE) C-ARGS-PROP)

(DEFUN C-COM-MO (MOVE-INDEX)
       (COND ((NUMBERP MOVE-INDEX)
	      (TERPRI)
	      (C-OUTPUT-MO-LIST (MO-COMPUTE-MOVE-OPINION (C-GET-MY-MOVE-LIST) MOVE-INDEX)))))

(DEFPROP DIRECT-GAIN C-COM-DIRECT-GAIN C-COMMAND)
(DEFPROP DIRECT-GAIN (CHESS-MOVE) C-ARGS-PROP)

(DEFUN C-COM-DIRECT-GAIN (MOVE-INDEX)
       (COND ((NUMBERP MOVE-INDEX)
	      (PRINT (MULTIPLE-VALUE-LIST 
		       (C-GET-DIRECT-RESULTS-OF-MOVE (C-GET-MY-MOVE-LIST) MOVE-INDEX))))))

(DEFPROP PRINT-ATTACKS C-COM-PRINT-ATTACKS C-COMMAND)
(DEFPROP PRINT-ATTACKS (CHESS-MOVE) C-ARGS-PROP)

(DEFUN C-COM-PRINT-ATTACKS (MOVE-INDEX &AUX MOVE-LIST)
       (SETQ MOVE-LIST (C-GET-MY-MOVE-LIST))
       (COND ((NOT (MEMQ 'ATTACK-RELATIONS (MOVE-LIST-COMPUTED-KEYS MOVE-LIST)))
	      (C-CREATE-ATTACK-RELATIONS (C-GET-CURRENT-SIDE))))
       (COND ((NUMBERP MOVE-INDEX)
	      (PRINT (AR-1 MOVE-LIST (+ MOVE-INDEX C-MVL-ATTACK-INSTANCES))))))

(DEFPROP TRACE C-COM-TRACE C-COMMAND)
(DEFPROP TRACE (CHESS-MOVE) C-ARGS-PROP)

(DEFUN C-COM-TRACE (MOVE-INDEX)
    (FORMAT T "MOVE-OPINION:~%")
    (C-COM-MO MOVE-INDEX)
    (FORMAT T "DIRECT-GAIN:~%")
    (C-COM-DIRECT-GAIN MOVE-INDEX)
    (FORMAT T "ATTACKS:~%")
    (C-COM-PRINT-ATTACKS MOVE-INDEX))

(DEFPROP STATEV C-COM-STATEV C-COMMAND)

(DEFUN C-COM-STATEV NIL 
  (PROG (PC PW DVL)
	(MULTIPLE-VALUE (PC PW DVL) (C-BASIC-STATIC-EVALUATOR))
	(FORMAT T "PIECE ~S, PAWN ~S, DEVEL ~S ~%"
		         PC PW DVL)))

(DEFPROP SWAP-SIDES C-COM-SWAP-SIDES C-COMMAND)

(DEFUN C-COM-SWAP-SIDES NIL
       (SETQ WHITE-AT-TOP-P (NOT WHITE-AT-TOP-P)))

(DEFPROP RESET-POSITION-INFO C-COM-RESET-POSITION-INFO C-COMMAND)

(DEFUN C-COM-RESET-POSITION-INFO (&AUX TEM)
       (COND ((SETQ TEM (GET C-CURRENT-POSITION 'MOVE-LIST))
	      (SETF (MOVE-LIST-COMPUTED-KEYS TEM) NIL)))
       (COND ((SETQ TEM (GET C-CURRENT-POSITION 'HIS-MOVE-LIST))
	      (SETF (MOVE-LIST-COMPUTED-KEYS TEM) NIL)))
       (DO PROP CHESS-PROPERTY-INDICATORS (CDR PROP) (NULL PROP)
	   (COND ((NOT (MEMQ PROP '(MOVE-LIST HIS-MOVE-LIST STATIC-ANNOTATIONS
				    DYNAMIC-ANNOTATIONS)))
		  (REMPROP C-CURRENT-POSITION (CAR PROP))))))

;  :sback N   start backround search from current position.
;  :pback     print background status.
;  :u         undoes last move.
;  :ct n      runs cheops n plys.