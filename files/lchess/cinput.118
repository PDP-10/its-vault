;;; -*-Mode:LISP; Package:USER; Base: 10. -*-
;READ IN LCHESS;CHDEFS > BEFORE RUNNING THIS INTERPRETED..

;(DECLARE (SPECIAL C-INPUT-MOVE-LIST))


;THE C-COMMAND PROP.  EXISTS ON PROPERTY LIST OF SYMBOLS WHICH ARE CHESS PRGM COMMANDS.
;  PROPERTY IS FUNCTION TO APPLY WHEN COMMAND INVOKED.  ALSO ON PROPERTY LIST OF
;  THE SAME SYMBOL MAY EXIST THE C-ARGS-PROP PROPERTY, WHICH IS
;A SORT OF PATTERN FOR ARGS TO COMMAND.  LAST TWO ARGS ARE ALWAYS
;COMMAND STRING AND IDX SO COMMAND CAN SCAN ITS OWN IF IT WANTS.
;ITEMS ALLOWABLE IN PATTERN ARE NUMBER, MOVE, PIECE, SQUARE

(DEFUN C-INPUT (&OPTIONAL RE-INITIALIZE-FLAG)
  (PROG (STRING MV-OUTPUT IDX)
	(COND ((NULL (BOUNDP 'WHITE-AT-TOP-P))
	       (SETQ WHITE-AT-TOP-P NIL)))
	(COND ((NULL (BOUNDP 'CHESS-TEMPORARY-AREA))      ;USED MOSTLY FOR MAKING ADDITION
	       (MAKE-AREA ':NAME 'CHESS-TEMPORARY-AREA))) ;OR DELETIONS TO PIECE-LISTS ETC.
	(COND ((OR (NULL (BOUNDP 'BOARD-ARRAY))
		   RE-INITIALIZE-FLAG)
	       (C-INITIALIZE RE-INITIALIZE-FLAG)
	       (SETQ C-MAIN-PIECE-ARRAY PIECE-ARRAY 
		     C-MAIN-BOARD-ARRAY BOARD-ARRAY 
		     C-MAIN-GAME-ARRAY GAME-ARRAY 
;		     C-MAIN-BOARD-PAWN-DATA-ARRAY BOARD-PAWN-DATA-ARRAY
		     ))
	      (T (SETQ PIECE-ARRAY C-MAIN-PIECE-ARRAY    ;TRY TO AVOID LOSSAGE IF QUITTED OUT
		       BOARD-ARRAY C-MAIN-BOARD-ARRAY 
		       GAME-ARRAY C-MAIN-GAME-ARRAY 
		       ;BOARD-PAWN-DATA-ARRAY C-MAIN-BOARD-PAWN-DATA-ARRAY
		       )))
	(GO REDIS)
    L	(SETQ STRING (READLINE))
	(SETQ IDX 0)
    	(MULTIPLE-VALUE (MV-OUTPUT IDX)
			(C-INPUT-MOVE 'DESCRIPTIVE 
				      STRING 
				      IDX))
	(COND ((NUMBERP MV-OUTPUT) (GO PLAY-MOVE))
	      ((EQ MV-OUTPUT 'COMMAND) 
	       (C-INPUT-COMMAND STRING IDX)	;JUST : PROCESSED SO FAR.
	       (GO REDIS))
	      (MV-OUTPUT (PRIN1 MV-OUTPUT) (TERPRI)))
	(GO L)
  PLAY-MOVE	(C-REACH-FOLLOWING-POSITION 
		     (GET C-CURRENT-POSITION 'MOVE-LIST)
		     MV-OUTPUT)
	(COND ((COND ((WHITE-TO-MOVE-P)
		      (BLACK-KING-IN-CHECK-P))
		     (T (WHITE-KING-IN-CHECK-P)))
	       (C-REVERT-MOVE)
	       (PRINC "Illegal")
	       (TERPRI)))
  REDIS	(C-DISPLAY-BOARD WHITE-AT-TOP-P)
	(C-DISPLAY-ANNOTATIONS)
	(GO L)
  ))


(DEFUN C-INPUT-COMMAND (STRING IDX)
  (PROG (COM ARGD ARGL FUNCT SYL OPTIONAL-F)
	(MULTIPLE-VALUE (COM IDX) (C-INPUT-FROM-STRING 'SYMBOL STRING IDX))
	(COND ((NOT (SYMBOLP COM)) (GO UDEF))
	      ((SETQ FUNCT (GET COM 'C-COMMAND-READER))
	       (MULTIPLE-VALUE (ARGL IDX) (FUNCALL FUNCT STRING IDX)) ;SPECIAL READER FOR THIS
	       (GO X)))				;COMMAND
	(SETQ ARGD (GET COM 'C-ARGS-PROP))
     L	(COND ((NULL ARGD) (GO X))
	      ((EQ (CAR ARGD) 'OPTIONAL)
	       (SETQ OPTIONAL-F T))
	      ((EQ (CAR ARGD) 'NUMBER)
	       (MULTIPLE-VALUE (SYL IDX) (C-INPUT-FROM-STRING 'SYMBOL STRING IDX))
	       (COND ((NULL SYL) (GO END))
		     ((NOT (NUMBERP SYL)) (GO WTA))
		     (T (GO L1))))
	      ((MEMQ (CAR ARGD) '(SYMBOL STRING))
	       (MULTIPLE-VALUE (SYL IDX) (C-INPUT-FROM-STRING (CAR ARGD) STRING IDX))
	       (COND ((NULL IDX) (GO END))
		     (T (GO L1))))				   
	      ((EQ (CAR ARGD) 'LIST)
	       (MULTIPLE-VALUE (SYL IDX) (READ-FROM-STRING STRING IDX))
	       (GO L1))
	      ((EQ (CAR ARGD) 'CHESS-MOVE)
	       (MULTIPLE-VALUE (SYL IDX)
			       (C-INPUT-MOVE 'DESCRIPTIVE 
					     STRING 
					     IDX))
	       (GO L1))
	      ((EQ (CAR ARGD) 'DYNAMIC-ANNOTATION)
	       (MULTIPLE-VALUE (SYL IDX)
			       (C-INPUT-DYNAMIC-ANNOTATION STRING IDX))
	       (GO L1))
	      ((EQ (CAR ARGD) 'PIECE))
	      ((EQ (CAR ARGD) 'SQUARE))
	      ((EQ (CAR ARGD) 'FILE))
	      (T (ERROR ARGD "BAD C-ARGS-PROP")))
     L2 (SETQ ARGD (CDR ARGD))
	(GO L)
     L1	(SETQ ARGL (NCONC ARGL (LIST SYL)))	;STORE NEXT ARG
     	(GO L2)
    END	(COND ((NULL OPTIONAL-F)
	       (ERROR "NOT ENUF ARGS")
	       (RETURN NIL))
	      (T (GO X)))
    WTA	(ERROR (CAR ARGD) "WRONG TYPE ARG")
	(RETURN NIL)
     X	(COND ((NULL (SETQ FUNCT (GET COM 'C-COMMAND)))
	       (GO UDEF)))
        (RETURN (APPLY FUNCT ARGL))	       
    UDEF(ERROR COM "UNDEFINED COMMAND")
    	(RETURN NIL)))

;C-INPUT-DYNAMIC-ANNOTATION IS SORT OF SIMILAR TO LISP READ.
; THE MAIN DIFFERENCE IS THAT THE C-INPUT-DYNAMIC-ANNOTATION PROPERTY
; IS FETCHED FROM SYMBOLS READ IN THE 1ST POSITION OF A LIST.
; IF FOUND, THIS PROPERTY IS CALLED AS A FUNCTION TO READ THE
; REST OF THE ELEMENTS OF THE LIST. THE MOST IMPORTANT REASON FOR DOING
; THIS IS TO ALLOW CHESS VARIATIONS TO GET READ IN AND CONVERTED TO
; INTERNAL MOVE NOTATION, UPDATING THE BOARD, ETC FOR THE USER IN THE PROCESS.
(DEFUN C-INPUT-DYNAMIC-ANNOTATION (STRING IDX)
)

;C-INPUT-MOVE WORKS ON A ELIMINATION PRINCIPLE.  
; ARGS ARE:
; INPUT MOVE STRING 
; MODE (ALGBRADIC MODIFIED-ALGBRADIC, OR DESCRIPTIVE)

; SIDE (0 1 EITHER)

;RETURNS THE ATOM AMBIGUOUS, ILLEGAL, ETC IF MOVE WAS.
;	 'COMMAND IF A COLON WAS ENCOUNTERED IN THE STRING.
;	 T IF MOVE READ WAS ...
;	 INDEX TO MOVE-LIST OF C-CURRENT-POSITION  IF WON.
; MODE MAY BE DESCRIPTIVE OR ALGEBRADIC.
(DEFUN C-INPUT-MOVE (MODE STRING IDX &OPTIONAL SIDE)
  (PROG (P1 P2 S1 S2 CAPT-FLAG CHECK-FLAG EP-FLAG O-COUNT PROMOTION-TO SYL 
					;CAPT-FLAG CAN BE NIL FOR DONT-KNOW, 
					;       'CAPT OR 'MOVE.
	  MOVE-LIST TEM LIM)
	(COND ((NULL SIDE) (SETQ SIDE (LOGAND 1 (GAME-PLY-NUMBER GAME-ARRAY)))))
        (SETQ LIM (ARRAY-ACTIVE-LENGTH STRING))
	(SETQ O-COUNT 0)
    L	(MULTIPLE-VALUE (SYL IDX) (C-INPUT-FROM-STRING 'CHESS-MOVE STRING IDX))
	(COND ((NULL SYL) (GO A1))
	      ((STRING-EQUAL SYL ":") (RETURN 'COMMAND IDX))
	      ((MEMBER SYL '("*" "X"))
		(SETQ CAPT-FLAG 'CAPT))
	      ((STRING-EQUAL SYL "-")
		(SETQ CAPT-FLAG 'MOVE))
	      ((STRING-EQUAL SYL "//"))		;FOR NOW
	      ((STRING-EQUAL SYL "O")
		(SETQ O-COUNT (1+ O-COUNT)))
	      ((STRING-EQUAL SYL "...")
		(RETURN 'SOME-MOVE IDX))
	      ((= (AR-1 SYL 0) #/=)
		(SETQ PROMOTION-TO (INTERN SYL)))
	      ((STRING-EQUAL SYL "+")
		(SETQ CHECK-FLAG T))
	      ((STRING-EQUAL SYL "PEP")
	       (SETQ EP-FLAG T)
	       (STORE-ARRAY-LEADER 1 SYL 0)     ;HACK HACK, FLUSH IT DOWN TO P
	       (GO L))
	      ((STRING-EQUAL SYL "EP")
		(SETQ EP-FLAG T))
	      ((EQ MODE 'ALGEBRADIC)
	       (SETQ TEM (C-ALGEBRADIC-CONVERT-SQUARE SYL 0))
	       (COND ((NULL S1) (SETQ S1 TEM))
		     ((NULL S2) (SETQ S2 TEM)))
	       (COND ((= (ARRAY-ACTIVE-LENGTH SYL) 4)
		      (SETQ TEM (C-ALGEBRADIC-CONVERT-SQUARE SYL 2))
		      (COND ((NULL S2) (SETQ S2 TEM))))))
	      ((NUMBERP SYL))		;THIS PROBABLY OUGHT TO DO SOMETHING, BUT
					; AT LEAST DONT DROP DEAD	       
	      ((C-INPUT-PIECEP SYL)
		(COND (S2 (GO E))
		      ((AND (NULL P1) (NULL S1) (NULL CAPT-FLAG))
			(SETQ P1 SYL))
		      ((NULL P2)
			(SETQ P2 SYL))
		      (T (GO E))))
	      ((C-INPUT-SQUAREP SYL)
		(COND ((AND (NULL S1) (NULL P2) (NULL CAPT-FLAG))
			(SETQ S1 SYL))
		      ((NULL S2)
			(SETQ S2 SYL))
		      (T (GO E))))
	      (T (GO E)))
	(COND ((NOT (< IDX LIM))
	       (GO A1))
	      ((= (AR-1 STRING IDX) #o40)      ;SPACE TERMINATES MOVE ...
               (COND ((AND (< (+ IDX 2) LIM) ; UNLESS EP FOLLOWS KLUDGE KLUDGE
			   (STRING-EQUAL "EP" STRING 0 (1+ IDX) 2 (+ 3 IDX)))
		      (GO L))
		     (T (GO A1))))
	      (T (GO L)))
   A1	
;   	(C-CALCULATE-ATTACKS)
	(COND ((AND (NULL P1) (NULL P2) (NULL S1) (NULL S2) (NULL CAPT-FLAG)
		    (NULL CHECK-FLAG) (ZEROP O-COUNT))
	       (RETURN NIL IDX)))	;EVIDENTLY, JUST CR TYPED.
	(COND ((NULL (SETQ MOVE-LIST (GET C-CURRENT-POSITION 'MOVE-LIST)))
	       (SETQ MOVE-LIST (C-CREATE-MOVE-LIST (DPB SIDE #o0401 0))))
	      (T (C-CLEAR-FLAGS-OF-MOVE-LIST MOVE-LIST)))
	(C-INPUT-SCAN 
		MOVE-LIST SIDE P1 S1 P2 S2 CAPT-FLAG CHECK-FLAG EP-FLAG O-COUNT PROMOTION-TO)
	(COND ((NULL (C-INPUT-SCAN-RESULTS MOVE-LIST))
		(RETURN 'IMPOSSIBLE IDX)))
	(C-INPUT-VERIFY-LEGAL MOVE-LIST SIDE)
	(COND ((NULL (SETQ TEM (C-INPUT-SCAN-RESULTS MOVE-LIST)))
		(SETQ TEM 'ILLEGAL)))
	(RETURN TEM IDX)
    E	(ERROR (LIST MODE SIDE STRING) "C-INPUT-MOVE")
	(RETURN NIL IDX)
))

(DEFUN C-INPUT-VERIFY-LEGAL (MOVE-LIST SIDE) NIL)


(DEFUN C-CLEAR-FLAGS-OF-MOVE-LIST (MOVE-LIST)
  (PROG (IDX LIM)
	(SETQ IDX C-MVL-MARKER LIM (ARRAY-LEADER MOVE-LIST 0))
    L	(COND ((NOT (< IDX LIM)) (RETURN T)))
	(AS-1 NIL MOVE-LIST IDX)
	(SETQ IDX (+ IDX C-MVL-NQS))
	(GO L)))


(DEFUN C-INPUT-SCAN-RESULTS (MOVE-LIST)
  (PROG (BSF IDX LIM)
	(SETQ IDX 0 LIM (ARRAY-LEADER MOVE-LIST 0))
    L	(COND ((NOT (< IDX LIM)) (RETURN BSF))
	      ((NOT (AR-1 MOVE-LIST (+ IDX C-MVL-MARKER)))
		(COND (BSF (RETURN 'AMBIGUOUS))
		      (T (SETQ BSF IDX)))))
	(SETQ IDX (+ IDX C-MVL-NQS))
	(GO L)))


(DEFUN C-INPUT-SCAN (MOVE-LIST SIDE FROM-PC FROM-SQ CAPT-PC TO-SQ CAPT-FLG CHECK-FLAG 
			EP-FLAG O-COUNT PROMOTION-TO)
  (PROG (IDX LIM TEM M-CODE)
	(SETQ IDX 0 LIM (ARRAY-LEADER MOVE-LIST 0))
   L	(COND ((NOT (< IDX LIM)) (RETURN NIL)))
	(COND ((AR-1 MOVE-LIST (+ IDX C-MVL-MARKER))	;MOVE ALREADY RULED OUT
	       (GO NXT)))
	(COND ((SETQ M-CODE (AR-1 MOVE-LIST (+ IDX C-MVL-CODE)))
	       (SELECTQ M-CODE 
		 (CASTLES-KING 
		  (COND ((EQ O-COUNT 2) (GO NXT))
			((NOT (ZEROP O-COUNT))
                         (GO FLUSH))    ;IF O-COUNT EXISTS, IT HAS TO MATCH
			((AND (OR (NULL FROM-PC)
				  (NULL (C-INPUT-PIECE-CONTRADICTS 
					   FROM-PC 
					   (SETQ TEM (+ (* SIDE #o20) WK)))))
			      (OR (NULL FROM-SQ)
				  (NULL (C-INPUT-SQUARE-CONTRADICTS 
					   FROM-SQ 
					   (COND ((ZEROP SIDE) WK1)
						 (T BK1))
					   SIDE)))
			      (OR (NULL TO-SQ)
				  (NULL (C-INPUT-SQUARE-CONTRADICTS 
					   TO-SQ 
					   (COND ((ZEROP SIDE) WKN1)
						 (T BKN1))
					   SIDE))))
			 (GO NXT))  ;ACCEPT E1-G1 TYPE NOTATION FOR O-O
			(T (GO FLUSH))))
		 (CASTLES-QUEEN 
		  (COND ((EQ O-COUNT 3) (GO NXT))
			((NOT (ZEROP O-COUNT))
                         (GO FLUSH))    ;IF O-COUNT EXISTS, IT HAS TO MATCH
			((AND (OR (NULL FROM-PC)
				  (NULL (C-INPUT-PIECE-CONTRADICTS 
					 FROM-PC 
					 (SETQ TEM (+ (* SIDE #o20) WK)))))
			      (OR (NULL FROM-SQ)
				  (NULL (C-INPUT-SQUARE-CONTRADICTS 
					   FROM-SQ 
					   (COND ((ZEROP SIDE) WK1)
						 (T BK1))
					   SIDE)))
			      (OR (NULL TO-SQ)
				  (NULL (C-INPUT-SQUARE-CONTRADICTS 
					   TO-SQ 
					   (COND ((ZEROP SIDE) WQB1)
						 (T BQB1))
					   SIDE))))
			 (GO NXT))  ;ACCEPT E1-C1 TYPE NOTATION FOR O-O
			(T (GO FLUSH))))
		 (=Q 
		  (COND ((AND PROMOTION-TO 
			      (NOT (EQ PROMOTION-TO '=Q)))
			 (GO FLUSH))))
		 ((=R =N =B)
		  (COND ((NOT (EQ PROMOTION-TO M-CODE))
			 (GO FLUSH))))))
	      (PROMOTION-TO (GO FLUSH)))
	(COND ((OR (NOT (ZEROP O-COUNT))
		   (AND FROM-PC 
			(C-INPUT-PIECE-CONTRADICTS FROM-PC 
			    (AR-1 MOVE-LIST (+ IDX C-MVL-MOVING-PC))))
		   (AND FROM-SQ 
			(C-INPUT-SQUARE-CONTRADICTS FROM-SQ 
				     (AR-1 PIECE-ARRAY (AR-1 MOVE-LIST 
							     (+ IDX C-MVL-MOVING-PC)))
				     SIDE))
		   (AND CAPT-PC 
			(NOT EP-FLAG)
			(OR (NOT (< (SETQ TEM (AR-1 BOARD-ARRAY 
						    (AR-1 MOVE-LIST (+ IDX C-MVL-TO-SQ))))
				    SQUARE-VACANT))
			    (C-INPUT-PIECE-CONTRADICTS CAPT-PC TEM)))
		   (AND EP-FLAG 
			(OR (NOT (= (AR-1 MOVE-LIST (+ IDX C-MVL-TO-SQ))
				    (BOARD-GHOST-LOCATION BOARD-ARRAY)))
			    (NOT (PAWN-P (AR-1 MOVE-LIST (+ IDX C-MVL-MOVING-PC))))))
		   (AND TO-SQ 
			(C-INPUT-SQUARE-CONTRADICTS 
			   TO-SQ
			   (AR-1 MOVE-LIST (+ IDX C-MVL-TO-SQ))
			   SIDE))
		   )
	       (GO FLUSH)))	;NOT THIS ONE
   NXT	(SETQ IDX (+ IDX C-MVL-NQS))
  	(GO L)
  FLUSH	(AS-1 T MOVE-LIST (+ IDX C-MVL-MARKER))
	(GO NXT)
))


(DEFUN C-INPUT-PIECE-CONTRADICTS (STRING-PC PC-NUM)
  (PROG (CH CH1 IDX FN)
	(SETQ IDX (1- (ARRAY-ACTIVE-LENGTH STRING-PC)))
	(SETQ CH (AR-1 STRING-PC IDX))		;LOOK AT CHARS IN REVERSE ORDER
	(COND ((NOT (MEMQ (AR-1 (PIECE-TYPE-WOOD-ARRAY PIECE-ARRAY) PC-NUM)
			  (CDR (ASSQ CH '( (#/K . (KING)) (#/Q . (QUEEN)) 
				  (#/B . (BISHOP)) (#/N . (KNIGHT)) (#/R . (ROOK))
				  (#/P . (WHITE-PAWN BLACK-PAWN)) )))))
	       (RETURN T))
	      ((ZEROP IDX) (RETURN NIL)))
	(SETQ IDX (1- IDX))
	(SETQ CH1 (AR-1 STRING-PC IDX))
	(COND ((= CH #/P)
	       (GO P))
	      ((AND (ZEROP IDX) (MEMQ CH '(#/B #/N #/R)))
	       (GO BNR))
	      (T (RETURN T)))
  BNR	(COND ((OR (AND (EQ CH1 #/K) (>= (LOGAND PC-NUM 7) 4))
		   (AND (EQ CH1 #/Q) (< (LOGAND PC-NUM 7) 4)))
	       (RETURN NIL))
	      (T (RETURN T)))
  P	(COND ((NULL (MEMQ (SETQ FN (AR-1 C-BOARD-FILE-NUMBER (AR-1 PIECE-ARRAY PC-NUM)))
			   (CDR (ASSQ CH1 '( (#/R . (1 #o10)) (#/N . (2 7))
					    (#/B . (3 6)) (#/K . (4)) (#/Q . (5)))))))
	       (RETURN T))
	      ((ZEROP IDX) (RETURN NIL)))
	(SETQ IDX (1- IDX))
	(SETQ CH1 (AR-1 STRING-PC IDX))
	(COND ((AND (ZEROP IDX)
		    (OR (AND (EQ CH1 #/K) (<= FN 4))
			(AND (EQ CH1 #/Q) (> FN 4))))
	       (RETURN NIL))
	      (T (RETURN T)))
))


(DEFUN C-INPUT-SQUARE-CONTRADICTS (STRING-SQ SQ-NUM SIDE)
  (PROG (IDX CH TEM FN)
	(COND ((NUMBERP STRING-SQ)			;IN ALG MODE, IT CAN BE A NUMBER
	       (RETURN (NOT (= STRING-SQ SQ-NUM)))))
	(SETQ IDX (1- (ARRAY-ACTIVE-LENGTH STRING-SQ)))
	(SETQ CH (AR-1 STRING-SQ IDX))
	(COND ((NOT (AND (< CH #/9)
			 (> CH #/0)))
	       (SETQ CH #/1)
	       (SETQ IDX (1+ IDX))))	;KB IS SAME AS KB1, ETC
	(SETQ TEM (AR-1 C-BOARD-WHITE-RANK-NUMBER SQ-NUM))
	(COND ((NOT (ZEROP SIDE)) (SETQ TEM (- 9 TEM))))
	(COND ((NOT (= TEM (- CH #/0)))
	       (RETURN T))
	      ((ZEROP IDX)
	       (RETURN NIL)))
	(SETQ IDX (1- IDX))
	(SETQ CH (AR-1 STRING-SQ IDX))
	(COND ((NULL (MEMQ (SETQ FN (AR-1 C-BOARD-FILE-NUMBER SQ-NUM))
			   (CDR (ASSQ CH '( (#/R . (1 #o10)) (#/N . (2 7))
					    (#/B . (3 6)) (#/K . (4)) (#/Q . (5)))))))
	       (RETURN T))
	      ((ZEROP IDX) (RETURN NIL)))
	(SETQ IDX (1- IDX))
	(SETQ CH (AR-1 STRING-SQ IDX))
	(COND ((AND (ZEROP IDX)
		    (OR (AND (EQ CH #/K) (<= FN 4))
			(AND (EQ CH #/Q) (> FN 4))))
	       (RETURN NIL))
	      (T (RETURN T)))
))


;MODE CAN BE CHESS-MOVE STRING, OR SYMBOL. 
;  (IF SYLABLE IS ALL DIGITS, IT WILL BE INTERPRETED AS A DECIMAL NUMBER)

(DEFUN C-INPUT-FROM-STRING (MODE I-STRING IDX)
  (PROG (O-STRING CH LIM NON-NULL OLDP NUM LETF)
	(SETQ LIM (ARRAY-ACTIVE-LENGTH I-STRING))
	(SETQ NUM 0)
	(SETQ O-STRING (MAKE-ARRAY NIL 'ART-STRING 100 NIL '(0)))
    L	(COND ((NOT (< IDX LIM))
		(GO X)))
	(SETQ CH (AR-1 I-STRING IDX))
	(COND ((AND (>= CH #/a)
		    (<= CH #/z))
	       (SETQ CH (- CH #o40))))
	(COND ((EQ MODE 'CHESS-MOVE)
		(COND ((AND NON-NULL 
			   (MEMQ CH '(#o40 #// #/X #/* #/- 
				      #/+ #/: #/=)))  ;THESE CAUSE PRE-BREAKS
		       (GO X)))))
	(SETQ IDX (1+ IDX))
	(COND ((AND (NOT NON-NULL)
		    (= CH #o40))
	       (GO L))
	      ((EQ MODE 'CHESS-MOVE))
	      ((= CH #/")
	       (GO RSTRING))
	      ((NOT (OR (AND (>= CH #/A)
			     (<= CH #/Z))
			(AND (>= CH #/0)
			     (<= CH #/9))
			(MEMQ CH '(#/- ))))
	       (GO X)))
	(COND ((AND (>= CH #/0)
		    (<= CH #/9))
	       (SETQ NUM (+ (* NUM #o10.) (- CH #/0))))
	      (T (SETQ LETF T)))
	(ARRAY-PUSH O-STRING CH)
	(SETQ NON-NULL T)
	(COND ((AND (EQ MODE 'CHESS-MOVE)
		    (MEMQ CH '(#/X #/* #/- #// #/:)))  ;THESE CAUSE POST-BREAKS
		(GO X)))
	(GO L)
  RSTRING (SETQ NON-NULL T LETF T)
  RS1	(COND ((NOT (< IDX LIM))
		 (ERROR I-STRING "UNTERMINATED STRING")))
  	(SETQ CH (AR-1 I-STRING IDX))
	(SETQ IDX (1+ IDX))
	(COND ((= CH #/")
	       (GO X)))
	(ARRAY-PUSH O-STRING CH)
	(GO RS1)
  X	(COND ((NULL NON-NULL) 
	       (RETURN-ARRAY O-STRING)
	       (RETURN NIL NIL))
	      ((NULL LETF)
	       (RETURN-ARRAY O-STRING)
	       (RETURN NUM IDX))
	      (T 
	       (ADJUST-ARRAY-SIZE O-STRING (ARRAY-LEADER O-STRING 0))
	       (COND ((EQ MODE 'SYMBOL)
		      (MULTIPLE-VALUE (CH OLDP) (INTERN O-STRING))
		      (COND (OLDP (RETURN-ARRAY O-STRING)
				  (SETQ O-STRING CH)))))
	       (RETURN O-STRING IDX))) ))


(DEFUN C-INPUT-PIECEP (STRING)	;T IF STRING COULD REASONABLY BE A PC
  (PROG (LEN CH IDX)
	(SETQ LEN (ARRAY-ACTIVE-LENGTH STRING))
	(COND ((ZEROP LEN) (RETURN NIL)))
	(SETQ CH (AR-1 STRING 0))
	(SETQ IDX 1)
	(COND ((MEMQ CH '(#/K #/Q))
		(COND ((= LEN IDX) (RETURN T))
		      (T (SETQ CH (AR-1 STRING IDX))
			 (SETQ IDX (1+ IDX))))))
	(COND ((MEMQ CH '(#/B #/N #/R))
		(COND ((= LEN IDX) (RETURN T))
		      (T (SETQ CH (AR-1 STRING IDX))
			 (SETQ IDX (1+ IDX))))))
	(COND ((EQ CH #/P)
		(COND ((= LEN IDX) (RETURN T)))))
	(RETURN NIL)))


(DEFUN C-INPUT-SQUAREP (STRING)
  (PROG (LEN CH IDX)
	(SETQ LEN (ARRAY-ACTIVE-LENGTH STRING))
	(COND ((ZEROP LEN) (RETURN NIL)))
	(SETQ CH (AR-1 STRING 0))
	(SETQ IDX 1)
	(COND ((MEMQ CH '(#/K #/Q))
	       (COND ((= LEN IDX) (RETURN T))
		     (T (SETQ CH (AR-1 STRING IDX))
			(SETQ IDX (1+ IDX))))))
	(COND ((MEMQ CH '(#/B #/N #/R))
	       (COND ((= LEN IDX) (RETURN T))
		     (T (SETQ CH (AR-1 STRING IDX))
			(SETQ IDX (1+ IDX))))))
	(COND ((AND (> CH #/0) (< CH #/9))
	       (COND ((= LEN IDX) (RETURN T)))))
	(RETURN NIL)))


  

