BEGOF("FILLR")

COMMENT
This module fills a text line with as many words as can fit. The file
HORIZ handles positioning within a line, such as scripts, tabs, and
centering.

The routines build a first pass output line in string OWL and then
call the line paster (PLACELINE()) to place it in an area.  OWL is
kept lengthy enough to hold any first pass output line.  That way, a
line can be constructed by IDPB'ing (with APPEND()) inside OWL
instead of by numerous concatenations.

Characters in OWL[1 TO OAKS] belong to the current line being built.
However, some of these characters describe FONT changes or forward
label references and others mark word breaks or CR to the left margin
for superimposing. Thus, the line reaches only to column POSN
(relative to the left edge of the area), and FAKE of these columns
are not occupied but are only allocated for forward references.

In FILL mode, the last permissible point after which the line can be
broken by a CrLf is marked by four variables:  BRKPT, BRKPOSN,
BRKSPCS, and BRKFAKE, which contain the values of OAKS, POSN, and
FAKE at that point, and the number of delible spaces right after that
point.  Though there is normally a WDBRK character at the breakpoint,
there may be none if it is the first breakpoint on the line or if it
was caused by a hyphen.

TEXTLINE sets up the input stream for processing by TEXTSEGMENT.
TEXTSEGMENT scans it up to a {, cr, or altmode, obeying all control
characters (see SCANTEXT in file CTRLC) and EMITting all regular
characters.  EMIT calls APPEND after checking for line overflow, etc.
Spaces are handled differently -- instead of calling EMIT to APPEND
them immediately, EMSPACES is called, which just counts up spaces in
SPCS and handles COMPACTion and punctuation problems.  Thus, when
EMIT is called, it must append SPCS spaces before appending its
argument.

;

PROCEDURES
PUBLIC SIMPLE PROCEDURE FILLR! ;$"#
BEGIN "FILLR!"
INTEGER I ;
SPSSTR _ SP ;
FOR I _ 1 THRU 200 DO SPSSTR _ SPSSTR&SP ;
END "FILLR!" ;
PUBLIC SIMPLE PROCEDURE APPEND(STRING CHARS) ;$"#
IF ON THEN
BEGIN "APPEND"
STRING D ; INTEGER CCT, BALANCE ;
DEFINE SRC=['15], COUNT=['14], DEST=['13], CHAR=['11] ;
CCT _ LENGTH(CHARS) ;
IF (BALANCE _ LENGTH(OWL) - (OAKS+CCT)) < 0 THEN
	OWL _ OWL & SP & SPS((1-BALANCE)*2) ;
IF CCT > 0 THEN
	BEGIN
	LABEL IUD ; COMMENT DEPOSIT LOOP ;
	D _ OWL[OAKS+1 FOR 1] ;
	START!CODE "APPD"
	MOVE SRC, CHARS ;
	HRRZ COUNT, CCT ;
	ADDM COUNT, OAKS ;
	MOVE DEST, D ;
IUD:	ILDB CHAR, SRC ;
	IDPB CHAR, DEST ;
	SOJG COUNT, IUD ;
	END "APPD"
	END ;
END "APPEND" ;
PUBLIC SIMPLE PROCEDURE COMPMAXIMS ;$"#
	BEGIN "COPYMAXIMS"
	FMAXIM _ (RMARG-RIGHTIM)-LMARG ;
	NMAXIM _ COLWID(IF AREAIXM THEN AREAIXM ELSE IXTEXT)-LMARG ;
	MAXIM _ IF FILL THEN FMAXIM ELSE NMAXIM ;
	END "COPYMAXIMS" ;
PUBLIC RECURSIVE PROCEDURE EMIT(STRING CHARS) ;$"#
	IF ON THEN EMITPIECE(CHARS, LENGTH(CHARS), XLENGTH(CHARS)) ;
PUBLIC RECURSIVE PROCEDURE EMITPIECE(STRING CHARS; INTEGER NCHARS, XCHARL) ;$"#
BEGIN TES PROCEDURIZED 11/29/73 ;
INTEGER EXCHARS, WASBRC ;  STRING EXCESS ;  LABEL ADDIT ; comment Sorry about that ;
INTEGER XSPCL,XEXCHARS; RKJ;
XSPCL _ XSPLEN(SPCS) ; RKJ;
RKJ: OLD LINE IF POSN + SPCS + NCHARS LEQ MAXIM THEN comment, no overfow ;
IF (IF XCRIBL THEN (XPOSN+XSPCL+XCHARL LEQ XMAXIM) ELSE (POSN+SPCS+NCHARS LEQ MAXIM)) THEN comment no overflow;
ADDIT:
	BEGIN
	IF SPCS AND XCRIBL AND (FILL AND ADJUST) AND POSN>INDENT THEN
		BEGIN FSHORT_FSHORT+XSPLEN(1); SPCS_SPCS-1 END;
	IF SPCS THEN BEGIN APPEND(SPS(SPCS)) ; BRKSPCS _ SPCS END ;
	APPEND(CHARS) ;  POSN _ POSN + SPCS + NCHARS ;  SPCS _ 0 ;
	XPOSN _ XPOSN + XSPCL + XCHARL; RKJ;
	END
ELSE IF FILL AND (BRKPT>INDENT OR BRKPOSN>INDENT) THEN comment, go back to a break point ;
	BEGIN
	IF BRKPT=OAKS THEN BEGIN XSPCL _ SPCS _ EXCHARS _ 0 ;  EXCESS _ NULL END
	ELSE BEGIN EXCESS_OWL[BRKPT+1+BRKSPCS TO OAKS]; COPY(EXCESS);
	     XEXCHARS _ XPOSN-FSHORT-BRKXPOSN-BRKSPCS*XSPLEN(1);
	     EXCHARS_POSN-BRKPOSN-BRKSPCS END;
	FAKE _ FAKE - BRKFAKE ;  NOPGPH _ -1 ;  WASBRC _ BRC ;
	OAKS _ BRKPT ; BOUND(3) ; COMMENT ADDED 4/14/72 ;
	PLACELINE(IF OWL[OAKS FOR 1]=WDBRK AND LASTWDBRK=OAKS   COMMENT JAN 9 73 ;
		THEN OAKS-1 ELSE OAKS,  BRKPOSN MIN MAXIM, BRKXPOSN,
		BRKFAKE, BRKABX, -BRKBLX, IF FIRST THEN LEADFM ELSE SPREADM-1,
		IF FIRST THEN MLEADFM ELSE MSPREADM,
		BRKPLBL, ADJUST, SPREADM) ;
	FSHORT _ NOPGPH _ OAKS _ TABI _ BRKABX _ BRKBLX _ STARPOSN _ AMPPOSN _ LASTWDBRK _ 0 ; BRC_WASBRC;
	COMMENT VARIABLES NEEDED BEYOND THE ABOVE "PLACELINE"
		HAD BETTER BE "MIDWDS" IN PUBDFS.SAI ;
	IF FIRST THEN	BEGIN
			INDENT _ RESTIM MAX -LMARG ; FIRST _ FALSE ;
			END ;
	IF XCRIBL
	    THEN
		BEGIN
		APPEND(PICKFONT(BRKFONT)) ; BRKFONT _ THISFONT ; TES 11/16/73 ;
		IF (LMARG+INDENT) NEQ 0 THEN APPEND(FONTCHAR&"="&CVSR(CHARW*(LMARG+INDENT)));
		XPOSN_CHARW*INDENT;
		END
	    ELSE
		BEGIN
		APPEND(SPS(LMARG+INDENT));
		END;
	POSN_INDENT;
	IF BRKUNDER THEN BEGIN APPEND(FONTCHAR&""); BRKUNDER _ 0 END ; TES 12/28/73;
	OKCR(TRUE); TES MOVED AFTER BRKUNDER TEST, 12/28/73 ;
	APPEND(EXCESS);
	POSN_POSN+EXCHARS;  XPOSN_XPOSN+XEXCHARS;
	IF SPCS THEN BEGIN OKSP(FALSE) ;  OKCR(FALSE) END ;
	GO  TO  ADDIT   ;
	END
ELSE IF (IF XCRIBL THEN XPOSN LEQ XMAXIM ELSE POSN LEQ MAXIM)
	THEN comment, About to overflow right edge of area! ;
	BEGIN "LINE TOO LONG"
	STRING S;   RKJ: 1-5-74;
	S_SPS(SPCS)&CHARS;   RKJ: 1-5-74;
	APPEND((IF XCRIBL THEN (EXCESS_TRUNCATE(S,XMAXIM-XPOSN)) ELSE S[1 TO MAXIM - POSN])) ;
	IF XCRIBL AND FNTFIL[DEFAULTFONT]=0 THEN TES 11/15/73;
		WARN("=", "FONT declaration needed. Start over!")
	ELSE
	WARN("Line too long",<(IF NOFILL THEN "Nofill" ELSE "Fill") & " line too long -- characters lost:" &
		S[(IF XCRIBL THEN LENGTH(EXCESS)+1 ELSE MAXIM-POSN+1) TO ] & "...">) ;
	POSN _ MAXIM+1 ; SPCS _ 0 ;
	XPOSN _ XMAXIM + 1; RKJ;
	END ;
MIDWORD _ MIDWORD OR FULSTR(CHARS) ;  PUNC _ FALSE ;
END "EMITPIECE" ;
PUBLIC SIMPLE PROCEDURE EMSPACES(INTEGER N) ;$"#
IF ON THEN BEGIN
	   IF SPCS=0 THEN BEGIN OKSP(FALSE) ; OKCR(FALSE) END ; MIDWORD _ FALSE ;
	   SPCS _ IF COMPACT THEN (SPCS+N) MIN (IF PUNC THEN 2 ELSE 1) ELSE SPCS+N ;
	   END "EMSPACES" ;
PUBLIC SIMPLE PROCEDURE OKCR(BOOLEAN EVEN!IN!SUPERSUBSCRIPT) ;$"#
IF BRKPT NEQ OAKS AND ON AND (SUPERSUB=0 OR EVEN!IN!SUPERSUBSCRIPT) THEN
	BEGIN
	BRKPT _ OAKS ;  BRKPOSN _ POSN ;  BRKFAKE _ FAKE ;  BRKPLBL _ PLBL ;  BRKSPCS _ 0 ;
	BRKUNDER _ UNDERLINING ; TES 12/28/73 ;
	BRKFONT _ THISFONT ; TES 11/16/73 ;
	BRKXPOSN _ XPOSN - FSHORT ;
	IF SUPERSUB THEN RETURN ;
	BRKABX _ BRKABX MAX ABOVEX ; BRKBLX _ BRKBLX MIN BELOWX ; ABOVEX_BELOWX_0 ;
	END "OKCR" ;
PRIVATE SIMPLE PROCEDURE OKSP(BOOLEAN EVEN!BEFORE!LMARG) ;$"#
IF LASTWDBRK NEQ OAKS AND ON AND
	JUSTIFY AND (POSN<MAXIM OR XCRIBL) AND (EVEN!BEFORE!LMARG OR POSN > 0 MAX INDENT) THEN
		BEGIN  APPEND(WDBRK) ;  LASTWDBRK _ OAKS ; END ;
PUBLIC RECURSIVE PROCEDURE PGPHSTART ;$"#
IF ON THEN
BEGIN "PGPHSTART"
OAKS_SPCS_TABI_PUNC_MIDWORD_SUPERSUB_ 0 ;
ABOVEX_BELOWX_HEIGHT_FAKE_BRKABX_BRKBLX_UNDERLINING_ 0  ;
FIRST _ NOFILL OR NOPGPH<0 ;
STARPOSN_AMPPOSN_LASTWDBRK_0 ;
BRKFONT _ THISFONT ; TES 11/16/73 ;
BRKUNDER _ 0 ; TES 12/28/73 ;
INDENT _ IF FLUSHL OR VERBATIM OR CENTER OR FLUSHR THEN 0
	ELSE (IF NOFILL OR FIRST THEN FIRSTIM ELSE RESTIM) MAX -LMARG ;
NOPGPH _ 0 ;
LBK _ 3 ; LBF _ NULL ;
IF XCRIBL THEN
	BEGIN
	APPEND(PICKFONT(THISFONT)) ; TES 11/15/73 ;
	IF (LMARG+INDENT) NEQ 0 THEN APPEND(FONTCHAR&"="&CVSR(CHARW*(LMARG+INDENT)));
	XPOSN_CHARW*INDENT;
	END
ELSE	BEGIN
	APPEND(SPS(LMARG+INDENT));
	END;
POSN_INDENT; FSHORT_0; OKCR(TRUE);
IF FLUSHR THEN BOUND(2) ELSE IF CENTER THEN BOUND(1) ;
FMAXIM _ (RMARG-RIGHTIM)-LMARG ;
NMAXIM _ COLWID(IF AREAIXM THEN AREAIXM ELSE IXTEXT) - LMARG ;
MAXIM _ IF FILL THEN FMAXIM ELSE NMAXIM ;
END "PGPHSTART" ;
PUBLIC STRING SIMPLE PROCEDURE SPS(INTEGER N) ;$"#
	IF N LEQ 10 THEN RETURN(SPSARR[N MAX 0])
	ELSE RETURN(SPSSTR[1 TO N]) ;
PUBLIC INTERNAL RECURSIVE BOOLEAN PROCEDURE TEXTLINE ;$"#
BEGIN
PRELOAD!WITH 6, [8]0, 1, [2]0, 5, 0, 3, [4]4, [6]0, 4, 2, 4, 2, [2]0 ;
OWN INTEGER ARRAY TEXTTYPE[-15:15] ;
BOOLEAN IMITEXT ;  INTEGER USYMB, LEN ;  STRING STR ;
IMITEXT _ TRUE ; comment assume computed text line ;
CASE TEXTTYPE[THISTYPE] OF
BEGIN COMMENT BY TYPE ;
COMMENT 0 ... Invalid ; RETURN(FALSE) ;
COMMENT 1 ... [ ;	BEGIN comment	[Est] Label or [@] rubout gen-label	; PASS ;
		IF ITSCH(@) THEN BEGIN PASS ; IMITEXT _ FALSE END
		ELSE	BEGIN LEN _ CVD(E("5", 0)) ; COMMENT THANKS RKJ ;
			IF ITSCH(<]>) THEN PASS ELSE
			WARN("=",<"Missed ] after label length; You probably thought you had" & CRLF &
			"a subscripted variable like X[I] computing text;" & CRLF &
			"but the syntax of that would be (X[I]).  See" & CRLF &
			"p.21 in the manual for parenthesis rules.">) ;
			THISWD _ LABELREF(0, LEN) ; END ;
		END ;
COMMENT 2 ... Unit ; IF THATISID THEN
		BEGIN comment	Unit Label	;
		USYMB _ SYMB ;
		LEN _ IF THISTYPE=PCOUNTERTYPE THEN PATT!CHRS(IX) ELSE CTR!CHRS(IX) ;
		PASS ; THISWD _ LABELREF(USYMB, LEN) ;
		END
	ELSE IF IX=IXPAGE THEN
		BEGIN comment, Generate a label ;
		THISWD _ NULL ;
		THISWD _ LABELREF(0, IF ITS(PAGE) THEN CTR!CHRS(IXPAGE) ELSE PATT!CHRS(IXPAGE)) ;
		END
	ELSE THISWD _ VEVAL ;
COMMENT 3 ... Constant ;
	BEGIN
	LOPP(THISWD) ; STR _ THISWD ; TES 8/19/74 FIX BUG ;
	IF THATISID AND SIMLOOK(CAPITALIZE(STR_SCAN(STR,ALPHA,DUMMY)))
		 AND (SYMTYPE = COUNTERTYPE OR SYMTYPE = PCOUNTERTYPE) THEN
		BEGIN comment	"Unit.." Label	;
		IF SYMTYPE=PCOUNTERTYPE THEN STR_STR[1 TO -1]; USYMB _ SYMBOL;
		LEN _ IF SYMTYPE=PCOUNTERTYPE THEN PATT!CHRS(SYMIX) ELSE CTR!CHRS(SYMIX) ;
		PASS ; THISWD _ STR & SP & LABELREF(USYMB, LEN) ;
	 	END ;
	END ;
COMMENT 4 ... Variable ;	THISWD _ VEVAL ;
COMMENT 5 ... ~ etc. ; IF IX comment not ~ ; THEN RETURN(FALSE) ELSE IMITEXT_FALSE ;
COMMENT 6 ... misc ; IF ITSCH(<(>) THEN BEGIN PASS; STR_E(NULL,NULL);
		IF  NOT ITSCH(<)>) THEN WARN("=","Parens don't match") ; THISWD_STR END ELSE RETURN(FALSE) ;
END ; COMMENT BY TYPE ;
IF IMITEXT THEN IF NULSTR(THISWD) OR  NOT ON THEN ELSE
	BEGIN
	BEGINBLOCK(FALSE, 0, "COMPUTED!TEXT") ;
	SWICH(THISWD&ALTMODE&" END ""COMPUTED!TEXT""", -1, 0) ;
	TEXTSEGMENT ;
	END
ELSE TEXTSEGMENT ;
PASS ;
RETURN(TRUE) ;
END "TEXTLINE" ;
PRIVATE RECURSIVE PROCEDURE TEXTSEGMENT ;$"#
BEGIN
INTEGER INSET, N ;
EMPTYTHIS ; INSET _ 0 ;
IF INPUTSTR = VT THEN  IF  NOT ON THEN LOPP(INPUTSTR) ELSE
	BEGIN "NEW INPUT LINE"
	LOPP(INPUTSTR) ;
	IF VERBATIM THEN BEGIN END
	ELSE IF INPUTSTR=CR AND (N_SIGNALD[CR]) THEN BEGIN LOPP(INPUTSTR) ; RESPOND(N) ; RETURN END
	ELSE IF ATLEAD(INSET _ LENGTH(RD(TO!NON!SP))) THEN INSET_0 ; comment AT NULL , AT <integer> ;
	END "NEW INPUT LINE" ;
IF NOPGPH THEN
	BEGIN
	PGPHSTART ; TES 11/2/74 PROCEDURIZED ;
	IF ON AND VERBATIM THEN
		BEGIN
		JUSTIFY_FALSE;
		EMIT(RD(TO!CR!SKIP));
		DBREAK ;
		RETURN ;
		END ;
	END ;
JUSTIFY _ FILL AND ADJUST OR JUSTJUST ;
IF INSET AND RETAIN AND  NOT FLUSHL THEN EMSPACES(INSET) ;
SCANTEXT ;
END "TEXTSEGMENT " ;
FINISHED

ENDOF("FILLR")
