BEGOF("QUADS")


COMMENT

Tabs, somescripts, infinity, superimpose, flush left, flush right,
and center.  Also the INDENT declaration.

;


PROCEDURES
PUBLIC SIMPLE PROCEDURE QUADS! ;$"#
BEGIN "QUADS!"
TABSORT[1]_TWO(33);
END "QUADS!" ;
PUBLIC RECURSIVE PROCEDURE BOUND(INTEGER KIND) ;$"#
PLK: THIS ENTIRE PROCEDURE REWORKED 6-FEB-75
	THE INFORMATION PASSED TO PASS2 FOR  STRINGS AND  AND _ IS
	(1)	WHERE WE WANT TO BE
	(2)	WHERE WE ARE
	(3)	1 OR 2 ( WE LIED IN THE FIRST CASE IF IT WAS CENTERING)
	(4)	XLENGTH OF THE  STRING (ONLY IN XCRIBL MODE)
	(5)	THE  STRING
	;
IF ON THEN
BEGIN "BOUND"
STRING FILLER,SEGMENT,BOUNDS;

	SIMPLE PROCEDURE TABCASE(INTEGER RB);
	BEGIN "TABCASE"
	INTEGER LB;
	RB_RB*CHARW;
	LB_(IF XCRIBL THEN XLBP ELSE LBP) + LMARG*CHARW - (LBFAKE-OLBFAKE);
	BOUNDS _ CVSR(RB) & CVSR(LB) & CVSR(1);
	SEGMENT_NULL;
	FILLER _ LBF;
	APPEND(FONTCHAR & "") ; APPEND (BOUNDS);
	IF XCRIBL THEN APPEND(CVSR(XLENGTH(FILLER)));
	APPEND(FILLER & ALTMODE);
	APPEND(FONTCHAR & "_");
	END "TABCASE";

COMMENT
	KIND	  0 ... X	(THE ASCII OF X NEGATED)
		= 1 ... _
		= 2 ... 
		= 3 ... CR OR BREAK
		= 4 ... TAB (\ OR ) ;
IF KIND=3 OR (KIND=4 AND NULSTR(LBF)) THEN
	SPCS_0
    ELSE EMIT(NULL);
OKCR(TRUE) ; COMMENT ADDED 4/17/72 ;

COMMENT AN EARLIER BOUND ON THIS LINE MAY HAVE SET LBK_KIND ;
IF LBK < 3 THEN
  CASE (LBK MAX 0) OF
    BEGIN "BY KIND"
[0]   COMMENT  ONLY VALID IF IMMEDIATELY PRECEDING THIS BOUND ;
	IF (LBO < OAKS) OR (SPCS>0) THEN
		BEGIN "SHOULD NOT HAVE MOVED"
		WARN("="," NEEDS A RIGHT BOUND") ;
		LBF _ NULL ;
		END ;
[1]   COMMENT CENTER BETWEEN LEFT BOUND AT POSN=LBP AND THIS TAB TO RBOUND, OR BETWEEN MARGINS ;
	BEGIN "CENTER"
	INTEGER LB,RB,FAKEL,MINL,LASTPOSN;
	FAKEL_FAKE-LBFAKE;
	LASTPOSN_(IF XCRIBL THEN XLBP ELSE LBP) + LMARG*CHARW;
	MINL_(IF XCRIBL THEN (XPOSN-XLBP) ELSE (POSN-LBP))-FAKEL;
	RB _ (IF KIND=4 THEN ((RBOUND+LMARG)*CHARW+LASTPOSN) ELSE ((RMARG+LMARG)*CHARW)) - MINL;
	LB _ LASTPOSN - (LBFAKE-OLBFAKE);
	BOUNDS_CVSR(RB) & CVSR(LB) & CVSR(2);	PLK: MUST DIVIDE BY 2 IN PASS2
						TO PREVENT TRUCATION FROM HAPPENING TWICE;
	SEGMENT _ OWL[LBO+1 TO OAKS] ; COPY(SEGMENT) ; OAKS _ LBO ; FILLER _ OLBF ;
	APPEND(FONTCHAR & "") ; APPEND(BOUNDS) ;
	IF XCRIBL THEN APPEND(CVSR(XLENGTH(FILLER)));
	APPEND(FILLER & ALTMODE);
	APPEND(SEGMENT) ; APPEND(FONTCHAR & "_") ;
	POSN _ ((RB DIV CHARW) + FAKEL) DIV 2 + MINL;
	XPOSN _ (RB + FAKEL) DIV 2 + MINL;
	LBFAKE_LBFAKE + ((FAKEL-1) DIV 2);	plk: so that OLBFAKE will be right the next time
						     in the event of an  string;
	END "CENTER" ;
[2]   COMMENT  RIGHT FLUSH AGAINST TAB TO RBOUND OR AGAINST RIGHT MARGIN ;
	BEGIN "RIGHT FLUSH"
	INTEGER RB,LB;
	RB _ (IF KIND=4 THEN (RBOUND+LMARG)*CHARW ELSE RMARG*CHARW) -
		(IF XCRIBL THEN (XPOSN-XLBP) ELSE (POSN-LBP)) +
		(FAKE-LBFAKE);
	LB_(IF XCRIBL THEN XLBP ELSE LBP) + LMARG*CHARW - (LBFAKE-OLBFAKE);
	BOUNDS_CVSR(RB) & CVSR(LB) & CVSR(1);
	SEGMENT _ OWL[LBO+1 TO OAKS] ; COPY(SEGMENT) ; OAKS _ LBO ; FILLER _ OLBF ;
	APPEND(FONTCHAR & "") ; APPEND(BOUNDS) ;
	IF XCRIBL THEN APPEND(CVSR(XLENGTH(FILLER)));
	APPEND(FILLER & ALTMODE);
	APPEND(SEGMENT) ; APPEND(FONTCHAR & "_") ;
	POSN _ RB DIV CHARW;
	XPOSN _ RB;
	END "RIGHT FLUSH" 
    END "BY KIND";
IF KIND=3 AND FULSTR(LBF) THEN TABCASE(RMARG);
IF  KIND=4 THEN
	BEGIN "TAB"
	IF FULSTR(LBF) THEN TABCASE(RBOUND+LMARG)
	    ELSE APPEND(FONTCHAR&"="&CVSR(CHARW*(RBOUND+LMARG)));
	BRKXPOSN_BRKXPOSN+FSHORT;  FSHORT_0;
	POSN _ RBOUND ;	XPOSN _ RBOUND * CHARW ;
	END "TAB" ;
IF KIND = 4 AND POSN > MAXIM THEN MAXIM _ NMAXIM+LMARG
	ELSE IF FILL THEN MAXIM _ IF KIND LEQ 2 THEN NMAXIM ELSE FMAXIM ;
IF KIND = 3 THEN XLBP _ LBP _ LBO _ LBFAKE _ OLBFAKE _ 0	RKJ: 1-22-74;
    ELSE
	BEGIN "SETUP FOR NEXT TIME"
				COMMENT FINALLY, SET LEFT BOUND FOR A SUBSEQUENT BOUND ;
	LBO _ OAKS ;  LBP _ POSN ; XLBP _ XPOSN ;
	LBK _ KIND ; MIDWORD _ FALSE ;
	IF KIND LEQ 0 THEN
		BEGIN LBF_LBF&(-KIND); RETURN END;	plk: cannot reset the LBxx if we
							are only making the  string longer;
	OLBFAKE _ LBFAKE ; LBFAKE _ FAKE ;
					plk: (leq 0) and 3 have been eliminated by now;
	IF KIND=4 THEN OLBF_LBF_NULL
	    ELSE BEGIN OLBF_LBF; LBF_NULL; END;
	END "SETUP FOR NEXT TIME";
END "BOUND" ;
PUBLIC SIMPLE PROCEDURE DINDENT ;$"#
BEGIN
STRING X ;
DBREAK ; PASS ; X _ E(NULL,NULL) ; IF ON AND FULSTR(X) THEN FIRSTIM _ CVD(X) ;
IF ITSCH(<,>) THEN BEGIN PASS ; X_E(NULL, NULL) END ELSE X_NULL ;
IF ON AND FULSTR(X) THEN RESTIM_CVD(X) ;
IF ITSCH(<,>) THEN BEGIN PASS ; X_E(NULL, NULL) END ELSE X_NULL ;
IF ON AND FULSTR(X) THEN RIGHTIM_CVD(X) ;
END "DINDENT" ;
PUBLIC SIMPLE PROCEDURE DSUPERIMPOSE ;$"#
BEGIN
INTEGER N ;
DBREAK ; PASS ; N _ CVD(E("0",NULL)) MIN 50 ;IF N<1 THEN N_50 ; IF  NOT ON THEN RETURN ;
TWEENLFM _ N-1; SINCELFM _ 0; BREAKM _ 5;
END "DSUPERIMPOSE" ;
PUBLIC SIMPLE PROCEDURE DTABS ;$"#
BEGIN TES 8/26/74 REWROTE FOR ASCEND-CHECK AND "ONLY" OPTION ;
INTEGER NUMB, I, BIG ;
BIG _ 0 ;
FOR I _ 1 THRU TABLIMIT DO
	BEGIN
	PASS ; NUMB _ CVD(E("-9999", NULL)) MIN 9999 ;
	IF ON THEN
	IF NUMB LEQ BIG THEN
		BEGIN
		WARN(NULL, <"TAB STOPS " & CVS(BIG) & "," & CVS(NUMB) & " ARE OUT OF ORDER">) ;
		I _ I - 1 ;
		END
	ELSE TABSORT[I] _ BIG _ NUMB ;
	IF NOT ITSCH(<,>) THEN BEGIN I _ I + 1 ; DONE END ;
	END ;
IF ON AND I > TABLIMIT THEN WARN(NULL,"Too many Tab Stops") ;
NUMB _ IF ITS(ONLY) THEN IPASS(TWO(34))	TES 8/26/73 FOR BRIAN HARVEY ;
ELSE TWO(33) ;
IF ON THEN TABSORT[I] _ NUMB ;
END "DTABS" ;
PUBLIC SIMPLE PROCEDURE SCRIPT(INTEGER ARROW) ;$"#
BEGIN
INTEGER CHR ;
CHR _ LOP(INPUTSTR) ;
HEIGHT _ HEIGHT + (IF ARROW="^" THEN 1 ELSE -1) ;
ABOVEX _ ABOVEX MAX HEIGHT ;  BELOWX _ BELOWX MIN HEIGHT ;
IF POSN LEQ MAXIM OR XCRIBL THEN BEGIN EMIT(NULL) ; APPEND(FONTCHAR&ARROW) ; END ;
RIPTPOSNS _ RIPTPOSNS LSH 9 LOR (POSN+LMARG) ;
IF LDB(SPCODE(CHR))=LBRACK THEN BEGIN SUPERSUB _ SUPERSUB LSH 9 LOR ARROW ;
	AMPPOSN _ AMPPOSN LSH 9  ; COMMENT 3/28/72 ; END
ELSE BEGIN EMIT(CHR) ; UNSCRIPT(ARROW) END ;
END "SCRIPT" ;
PUBLIC RECURSIVE PROCEDURE TABTO(INTEGER POSNO) ;$"#
IF ON THEN
BEGIN TES 8/14/74 SIMPLIFIED AND FIXED A BUG ;
POSNO _ POSNO MAX 1-LMARG ; TES 8/11/74 ;
IF (IF XCRIBL THEN (POSNO*CHARW LEQ XPOSN) ELSE (POSNO LEQ POSN)) THEN
	IF FULSTR(LBF) THEN
		BEGIN
		WARN("=","Already passed tab column " & CVS(POSNO)) ;
		RETURN ;
		END
	ELSE TABI _ 0
ELSE IF POSNO>NMAXIM+LMARG THEN
	BEGIN
	WARN("BAD TAB",<"Can't TAB past right margin to char "&CVS(POSNO)&
		(IF FILL THEN CRLF&"Did you really mean to be in FILL mode?" ELSE NULL)>) ;
	RETURN
	END ;
RBOUND _ POSNO-1 ;
BOUND(4) ;
END "TABTO" ;
PUBLIC SIMPLE PROCEDURE UNSCRIPT(INTEGER ARROW) ;$"#
BEGIN
INTEGER CHR, PN ; BOOLEAN MORE, WILLRIPT ;
IF ARROW = 0 THEN
	BEGIN COMMENT "]" -- find matching "[" ;
	ARROW _ SUPERSUB LAND '177 ;
	AMPPOSN _ AMPPOSN LSH -9 ; COMMENT 3/28/72 ;
	SUPERSUB _ SUPERSUB LSH -9 ;
	END ;
IF POSN LEQ MAXIM OR XCRIBL THEN
	BEGIN
	EMIT(NULL) ;
	IF ARROW NEQ "." THEN
		BEGIN
		APPEND(FONTCHAR & ("^"+"" - ARROW)) ;
		HEIGHT _ HEIGHT - (IF ARROW="^" THEN 1 ELSE -1) ;
		END ;
	END ;
WILLRIPT _ TRUE ; comment assume that RIPTPOSNS will be updated by SCRIPT if necessary ;
IF LDB(SPCODE(INPUTSTR)) = AMSAND THEN
	BEGIN
	LOPP(INPUTSTR) ;
	MORE _ TRUE ; PN _ RIPTPOSNS LAND '177 - LMARG ; COMMENT 3/28/72: ;
	AMPPOSN _ ((AMPPOSN LSH -9) LSH 9) LOR ((AMPPOSN LAND '177) MAX POSN) ;
	IF PN<POSN THEN BEGIN APPEND(FONTCHAR&"-"&CVSR(POSN-PN)) ; POSN_PN END ;
	IF (CHR _ LDB(SPCODE(INPUTSTR))) = LBRACK THEN
		BEGIN
		SUPERSUB _ SUPERSUB LSH 9 LOR "." ;
		LOPP(INPUTSTR) ; WILLRIPT _ FALSE ; comment not a ript: won't call SCRIPT! ;
		END
	ELSE IF CHR NEQ UARROW AND CHR NEQ DARROW THEN BEGIN EMIT(LOP(INPUTSTR)) ; MORE _ FALSE END ;
	END
ELSE MORE _ FALSE ;
IF  NOT MORE THEN BEGIN COMMENT 3/28/72: ;
	PN _ (AMPPOSN LAND '177) MAX POSN ; AMPPOSN _ (AMPPOSN LSH -9) LSH 9 ;
	IF PN>POSN THEN BEGIN APPEND(FONTCHAR&"+"&CVSR(PN-POSN)) ; POSN_PN END END ;
IF WILLRIPT THEN RIPTPOSNS _ RIPTPOSNS LSH -9 ;
END "UNSCRIPT" ;
FINISHED

ENDOF("QUADS")
