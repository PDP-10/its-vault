BEGOF("CNTRS")
COMMENT

A counter is represented by a COUNTERTYPE declaration record on ISTK
and SSTK.  Its implementation is obvious except for the trickiness
necessary to get responses triggered at the "right" time, and the
peculiarities of the PAGE counter.

;
PROCEDURES
PUBLIC SIMPLE PROCEDURE CNTRS! ;$"#
BEGIN "CNTRS!"
SYMPAGE_SYMNUM("PAGE") ;
CRECOUNTER(0,1,18,1,0,"1",SYMPAGE) ;
IXPAGE_LDB(IXN(SYMPAGE)) ;
PATPAGE_PATT!STRS(IXPAGE) ;
PAGEVAL _ NULL ;
! _ NULL ;
END "CNTRS!" ;
PUBLIC RECURSIVE PROCEDURE CLOSECOUNTER(INTEGER ITSIX; BOOLEAN DISDECLAREIT) ;$"#
BEGIN "CLOSECOUNTER"
INTEGER STRS, PP ;
CLOSET(ITSIX, TRUE, DISDECLAREIT) ;
IF DISDECLAREIT THEN
	BEGIN
	IF (PP _ PARENT(ITSIX)) THEN
		BEGIN
		LLSCAN(<SON(PP)>, <BROTHER>, LLTHIS=ITSIX) ;
		LLSKIP(<SON(PP)>, <BROTHER>) ;
		END ;
	STRS _ PATT!STRS(ITSIX) ;
	PATT!VAL(STRS)_PREFIX(STRS)_INFIX(STRS)_SUFFIX(STRS)_CTR!VAL(STRS)_NULL ;
	IF STRS=SHED THEN SHED_SHED-5 ;
	END ;
END "CLOSECOUNTER" ;
PRIVATE INTEGER SIMPLE PROCEDURE CHRSALF(INTEGER INT, ALFABET) ;$"#
BEGIN "CHRSALF"
INTEGER LABS, LSIGN ; STRING STR ; PRELOAD!WITH [2]3,2,[5]1,[2]0 ; OWN INTEGER ARRAY L[0:9] ;
LSIGN _ IF INT < 0 THEN 1 ELSE 0 ; INT _ ABS(INT) ; STR _ CVS(INT) ;
CASE ALFABET DIV 2 OF
BEGIN
COMMENT 1 ... "1" ; LABS _ LENGTH(STR) ;
COMMENT 2 ... i,I ; LABS _ 4*LENGTH(STR) - L[STR-"0"] ; comment, Believe-it-or-Not ;
COMMENT 3 ... a,A ; LABS _ LENGTH(CVALF(ALFABET, INT)) ;
END ;
RETURN(LABS + LSIGN) ;
END "CHRSALF" ;
PUBLIC PROCEDURE CRECOUNTER(INTEGER INLINE, PFROM, PTO, PBY, PIN;
	STRING PPRINTING; INTEGER USYMB) ;$"#
BEGIN "CRECOUNTER"
INTEGER TEMP, LENPAT, PARENTCHARS, POSNALF, POSN!, PS, ALF, UIX, PINIX, PINPS, PCHARS ;
STRING S!, SPAR, SPAR! ;
USYMB _ DECLARE(USYMB, COUNTERTYPE) ; TEMP _ DECLARE(SYMNUM(SYM[USYMB]&"!"), PCOUNTERTYPE) ;
UIX _ PUSHI(COUNTERWDS, COUNTERTYPE) ; PS _ PUSHS(5, NULL) ; PATT!STRS(UIX) _ PS ;
BIND(USYMB, UIX) ; DPB(UIX, IXN(TEMP)) ;
CTR!INIT(UIX) _ PFROM + TWO(14) ; CTR!STEP(UIX) _ PBY + TWO(6) ;
TES 10/25/73 ;  IN!LINE(UIX) _ IF UIX=IXPAGE THEN 0 ELSE INLINE ;
PINIX _ IF PIN THEN LDB(IXN(PIN)) ELSE 0 ; PARENT(UIX) _ PINIX ;
IF PIN = 0 THEN PARENTCHARS _ PINPS _ 0
ELSE IF LDB(TYPEN(PIN)) = COUNTERTYPE THEN
	BEGIN
	PARENTCHARS _ PATT!CHRS(PINIX) ;  PINPS _ PATT!STRS(PINIX) ;
	BROTHER(UIX) _ SON(PINIX) ; SON(PINIX) _ UIX ;
	END
ELSE BEGIN WARN("=","Undeclared Parent Unit "&SYMB) ; PINPS _ 0 ; PARENTCHARS _ 2 END ;
PCHARS _ LENGTH(CVS(PFROM)) MAX LENGTH(CVS(PTO)) ;
IF FULSTR(PPRINTING) AND PPRINTING=0 THEN
	BEGIN "TEMPLATE"
	PREFIX(PS) _ "!_" & PPRINTING[2 TO ] & ";!!!;;" ;
	PATT!ALF(UIX) _ 0 ;
	IF PIN NEQ 0 AND PINPS=0 THEN TEMP _ PCHARS + PARENTCHARS comment lousy guess ;
	ELSE	BEGIN
		S! _ ! ; CTR!VAL(PS) _ CVS(PTO - PBY) ; CTR!CHRS(UIX)_PATT!CHRS(UIX)_1000 ;
		IF PINPS THEN BEGIN SPAR _ CTR!VAL(PINPS) ; SPAR! _ PATT!VAL(PINPS) ;
		CTR!VAL(PINPS) _ "999999"[1 TO CTR!CHRS(PINIX)] ;
		PATT!VAL(PINPS) _ ! _ "9999999999999999"[1 TO PARENTCHARS] ; END ;
		NEXTCOUNTER(USYMB, -UIX) ; TEMP _ LENGTH(!) ;
		! _ S! ; IF PINPS THEN BEGIN CTR!VAL(PINPS) _ SPAR ; PATT!VAL(PINPS) _ SPAR! END ;
		END ;
	END "TEMPLATE"
ELSE	BEGIN "PATTERN"
	STRING PATCOPY ; LABEL FALF ; INTEGER ARRAY PCH[1:LENGTH(PPRINTING)] ;
	PRELOAD!WITH "1", "i", "I", "a", "A" ; OWN INTEGER ARRAY ALFS[1:5] ;
	PATCOPY _ PPRINTING ; LENPAT _ 0 ; WHILE FULSTR(PATCOPY) DO PCH[LENPAT_LENPAT+1]_LOP(PATCOPY) ;
	FOR POSNALF _ LENPAT DOWN 1 DO FOR ALF _ 1 THRU 5 DO IF ALFS[ALF]=PCH[POSNALF] THEN GO TO FALF;
	WARN("=",<"No 1, i, I, a, or A in pattern for "&SYM[SYMB]>) ;
	POSNALF _ LENPAT + 1 ; PPRINTING _ PPRINTING & "1" ;
	FALF: POSN! _ POSNALF - 1 ; WHILE POSN! AND PCH[POSN!] NEQ "!" DO POSN! _ POSN! - 1 ;
	PATT!ALF(UIX) _ ALF ; PATT!PARENT(UIX) _ IF POSN! THEN 1 ELSE 0 ;
	PREFIX(PS) _ PPRINTING[1 TO POSN!-1] ; INFIX(PS) _ PPRINTING[POSN!+1 TO POSNALF-1] ;
	SUFFIX(PS) _ PPRINTING[POSNALF+1 TO ] ; PATT!VAL(PS) _ NULL ;
	TEMP _ LENGTH(PREFIX(PS)) + PARENTCHARS + LENGTH(INFIX(PS)) + 
		(CHRSALF(PFROM,ALF) MAX CHRSALF(PTO,ALF)) + LENGTH(SUFFIX(PS));
	END "PATTERN" ;
PATT!CHRS(UIX) _ TEMP ; CTR!CHRS(UIX) _ PCHARS ; PATT!VAL(PS)_CTR!VAL(PS)_NULL ;
END "CRECOUNTER" ;
PRIVATE STRING SIMPLE PROCEDURE CVALF(INTEGER ALFABET, VAL) ;$"#
BEGIN "CVALF" COMMENT handles 1aAiI conversions ;
STRING S, A ; INTEGER I ;
PRELOAD!WITH	NULL, "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix",
		NULL, "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc",
		NULL, "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm" ;
OWN STRING ARRAY LOWROMAN[0:2, 0:9] ;
PRELOAD!WITH	NULL, "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX",
		NULL, "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
		NULL, "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM" ;
OWN STRING ARRAY UPROMAN[0:2, 0:9] ;
DEFINE BEG = [WHILE VAL DO BEGIN], OOPS = [WARN(<"=">,<"I only know roman numerals up to 1000, sorry">)] ;
IF VAL = 0 THEN RETURN("0") ;
IF VAL<0 THEN BEGIN S _ "-" ; VAL _ ABS(VAL) END ELSE S _ NULL ;
A _ NULL ; I _ -1 ;
CASE ALFABET - 1 OF
BEGIN
COMMENT 1 ... "1" ; A _ CVS(VAL) ;
COMMENT 2 ... "i" ; IF VAL < 1000 THEN BEG A _ LOWROMAN[I_I+1, VAL MOD 10]&A ;
		VAL_ VAL DIV 10 END ELSE OOPS ;
COMMENT 3 ... "I" ; IF VAL < 1000 THEN BEG A _ UPROMAN[I_I+1, VAL MOD 10]&A ;
		VAL_ VAL DIV 10 END ELSE OOPS ;
COMMENT 4 ... "a" ; BEG A _ ("a" + (VAL-1) MOD 26)&A ; VAL _ VAL DIV 26 END ;
COMMENT 5 ... "A" ; BEG A _ ("A" + (VAL-1) MOD 26)&A ; VAL _ VAL DIV 26 END ;
END ;
RETURN(S & A) ;
END "CVALF" ;
PUBLIC SIMPLE PROCEDURE DCOUNT ;$"#
BEGIN
INTEGER USYMB, INLINE ;
PRELOAD!WITH "FROM", "TO", "BY", "IN", "PRINTING" ;
OWN STRING ARRAY PRE[1:5] ; OWN STRING ARRAY PAR[1:5] ;
DPASS ; IF  NOT THISISID THEN BEGIN WARN("=","Unit must have a name") ; THISWD _ "!DUMMY" END ;
USYMB _ SYMNUM(THISWD) ; PASS ; IF ITS(INLINE) THEN BEGIN INLINE_TRUE; PASS END ELSE INLINE_FALSE ;
PAR[1]_PAR[2]_PAR[3]_PAR[5]_NULL;
PAR[4] _ 0 ; PARAMS(5, PRE, PAR, NULLS) ;
IF ON THEN CRECOUNTER( INLINE,
	IF NULSTR(PAR[1]) THEN 1 ELSE CVD(PAR[1]), comment, FROM -- ;
	IF NULSTR(PAR[2]) THEN 18 ELSE CVD(PAR[2]), comment, TO -- ;
	IF NULSTR(PAR[3]) THEN 1 ELSE CVD(PAR[3]), comment, BY -- ;
	IF PAR[4] = 0 THEN 0 ELSE SYMNUM(PAR[4]), comment IN -- ;
	IF NULSTR(PAR[5]) THEN "1" ELSE PAR[5], comment, PRINTING -- ;
	USYMB ) ;
END "DCOUNT" ;
PUBLIC RECURSIVE PROCEDURE DNEXT ;$"#
BEGIN
COMMENT Already PASSed "NEXT" ;
IF  NOT THISISID OR (THISTYPE NEQ COUNTERTYPE AND THISTYPE NEQ PCOUNTERTYPE) THEN WARN("=","NEXT what?")
ELSE IF ON THEN IF IX=IXPAGE THEN NEXTPAGE ELSE NEXTCOUNTER(SYMB, IX) ;
PASS ;
END "DNEXT" ;
PUBLIC RECURSIVE PROCEDURE NEXTCOUNTER(INTEGER USYMB, UIX) ;$"#
BEGIN "NEXTCOUNTER"
INTEGER PS, PARIX, PARTYPE, SONIX, SONPS, IVAL, SVTY, SVIX, SVSY, SVTHAT ;
INTEGER I;
STRING PARVAL, CVAL, PVAL, SVWD ;
IF UIX>0 AND  NOT IN!LINE(UIX) THEN DBREAK ;
IF UIX>0 AND FULSTR(CTR!VAL(PATT!STRS(UIX))) AND FINDTRAN(USYMB, 3) THEN RESPOND(LLTHIS) ;
IF UIX = IXPAGE AND OLDPGIDA THEN FINPAGE ELSE UIX _ ABS(UIX) ;
PS _ PATT!STRS(UIX) ; CVAL _ CTR!VAL(PS) ;
CTR!VAL(PS) _ CVAL _
	CVS(IVAL_IF NULSTR(CVAL) THEN CTR!INIT(UIX)-TWO(14) ELSE CVD(CVAL)+CTR!STEP(UIX)-TWO(6)) ;
PARVAL _ IF PATT!PARENT(UIX) AND (PARIX _ PARENT(UIX)) THEN
	EVALV("(a parent counter)", PARIX, PCOUNTERTYPE) ELSE NULL ;
IF PATT!ALF(UIX) THEN
	PVAL _ ! _ PREFIX(PS)&PARVAL&INFIX(PS)&CVALF(PATT!ALF(UIX),IVAL)&SUFFIX(PS)
ELSE	BEGIN
	SVTY_THISTYPE ; SVIX_IX ; SVSY_SYMB ; SVWD_THISWD ; SVTHAT_THATISFULL ;
	SWICH(PREFIX(PS), -1, 0) ; PASS ; PVAL _ E(NULL, NULL) ;
	PASS ; IF ITS(;) THEN PASS ;
	IF  NOT ITS(!!!) THEN WARN("=","Unbalanced COUNT Template") ;
	SWICHBACK ;
	THISTYPE_SVTY ; IX_SVIX ; SYMB_SVSY ; THISWD_SVWD ;
	IF SVTHAT THEN RDENTITY ELSE EMPTYTHAT;
	END ;
IF LENGTH(CVAL) > CTR!CHRS(UIX) THEN
	BEGIN
	WARN("Counter underestimated","Underestimated counter "&SYM[USYMB]&" -- reached "&CVAL) ;
	CTR!CHRS(UIX) _ LENGTH(CVAL) ;
	END ;
IF LENGTH(PVAL) > PATT!CHRS(UIX) THEN
	BEGIN
	IF PATT!STRS(UIX) THEN WARN("Pattern underestimate",
		"Underestimated counter "&SYM[USYMB]&": --  reached "&PVAL) ;
	PATT!CHRS(UIX) _ LENGTH(PVAL) ;
	END ;
PATT!VAL(PS) _ PVAL ; SONIX _ SON(UIX) ;
WHILE SONIX > 0 DO
	BEGIN
	SONPS _ PATT!STRS(SONIX) ;
	IF SONIX NEQ IXPAGE AND FULSTR(CTR!VAL(SONPS)) AND FINDTRAN(LDB(BIXNUM(SONIX)),3) THEN RESPOND(LLTHIS) ;
	CTR!VAL(SONPS) _ PATT!VAL(SONPS) _ NULL ;
	IF SONIX = IXPAGE THEN NEXTCOUNTER(SYMPAGE, SONIX _ -SONIX) ;
	DO  SONIX _ IF SONIX>0 AND (K_SON(SONIX)) THEN K ELSE IF (K_BROTHER(ABS SONIX)) THEN K
		ELSE -PARENT(ABS SONIX)  UNTIL SONIX>0 OR SONIX=-UIX ;
	END ;
IF UIX NEQ IXPAGE AND FINDTRAN(USYMB, 4) THEN RESPOND(LLTHIS) ;
IF UIX = IXPAGE THEN PAGEVAL _ PATT!VAL(PATPAGE) ;
! _ PVAL ; C! _ CVAL ; comment RESPOND or NEXTCOUNTER(..PAGE..) might have changed it ;
END "NEXTCOUNTER" ;
PUBLIC INTEGER SIMPLE PROCEDURE NEXTSTATEMENT ;$"#
IF ITS(NEXT) THEN
	BEGIN
	INTEGER USYMB ; COMMENT, counter name symbol number ;
	PASS ; USYMB_IF THISTYPE=COUNTERTYPE THEN SYMB ELSE IF THISTYPE=PCOUNTERTYPE THEN -SYMB ELSE TWO(20) ;
	DNEXT ; RETURN(USYMB) ;
	END
ELSE RETURN(0) ;
FINISHED

ENDOF("CNTRS")
