.chap (MACSYMA Functions and Variables,Mfunctions)

Following is a list of all MACSYMA functions divided into functional classes.
MACSYMA variables which affect the operation of some functions are described under the
appropriate function with their default value in brackets.  These are sometimes
referred to as MACSYMA options.

.sec (General Purpose Functions,general!functions)

.subsec (Evaluation and Simplification Functions,evsimpfun)

.function(EV,|exp, arg1, ..., argn|)
is one of MACSYMA's most powerful and versatile commands. It evaluates the expression 2exp1 in the environment
specified by the 2argi1.  This is done in steps, as follows:

.skip 1
(1) First the environment is set up by scanning the 2argi1 which may be as follows:

$flag<SIMP> causes 2exp1 to be simplified regardless of the setting of the switch SIMP
which inhibits simplification if FALSE.

$flag<NOEVAL> suppresses the evaluation phase of EV (see step (4) below).  This is
useful in conjunction with the other switches and in causing 2exp1 to be
resimplified without being reevaluated.

$flag<EVAL> causes an extra post-evaluation of 2exp1 to occur. (See step (5) below.)

$flag<INFEVAL> leads to an "infinite evaluation" mode.  EV repeatedly evaluates an expression until it stops changing.    To prevent a variable, say X, from being evaluated away in this mode, simply include X='X as an argument to EV.   Of course expressions such as EV(X,X=X+1,INFEVAL); will generate an infinite loop.  2CAVEAT EVALUATOR*.

$flag<EXPAND> causes expansion.

EXPAND(2m,n1) causes expansion, setting the values of MAXPOSEX and MAXNEGEX to
2m1 and 2n1 respectively. (see the EXPAND function below)

$flag<DETOUT> causes any matrix inverses computed in 2exp1 to have their
determinant kept outside of the inverse rather than dividing through each
element.

$flag<DIFF> causes all differentiations indicated in 2exp1 to be performed.
(see the DIFF function below.)

$flag<DERIVLIST>(2var11,...,2vark1) causes only differentiations with respect to
the indicated variables.

$flag<FLOAT> causes non-integral rational numbers and bigfloats to be converted to floating point.

$flag<NUMER> causes some mathematical functions (including exponentiation) with numerical
arguments to be evaluated in floating point $see<Simple!Functions>. It causes variables in 2exp1 which have been given numervals $see<uspropfun> to be replaced by their values.  It also sets the FLOAT switch on.

$flag<PRED> causes predicates (expressions which evaluate to TRUE or FALSE)
to be evaluated.

$flag<NOUNS> converts all nouns occurring in 2exp1 to verbs.


E where E is an atom declared to be an $var<EVFLAG/> $see<MACSYMA!properties> causes E to be
bound to TRUE during the evaluation of 2exp1.

2V:expression* (or alternatively 2V=expression*) causes 2V* to be bound to
the value of 2expression* during the evaluation of 2exp*.  Note that if 2V*
is a MACSYMA option, then 2expression* is used for its value during the evaluation
of 2exp*.  If more than one argument to EV is of this type then the binding is done
in parallel.  If 2V* is a non-atomic expression then a substitution rather than a
binding is performed.

E where E is a function name declared to be an EVFUN $see<property!specification>  causes E to be applied to 2exp*.

Any other function names (e.g. SUM) cause evaluation of occurrences of those
names in 2exp* as though they were verbs $see<evaluation>.

In addition a function occurring in 2exp1 (say F(args)) may be defined locally for
the purpose of this evaluation of 2exp1 by giving F(args):=body as an argument to EV.

If an atom not mentioned above or a subscripted variable or subscripted expression
was given as an argument, it is evaluated and if the result is an equation or
assignment then the indicated binding or substitution is performed.  If the result is
a list then the members of the list are treated as if they were additional arguments
given to EV. This permits a list of equations to be given (e.g. [X=1, Y=A**2] ) or a
list of names of equations (e.g. [E1,E2] where E1 and E2 are equations) such as that
returned by $fun<SOLVE>. $see<SOLVE>

The 2argi1 of EV usually may be given in any order but since they
are picked up left to right the order may influence the result.  This
is strictly true of substitution equations which are handled in
sequence, left to right, and EVFUNS which are composed, e.g.
EV(2exp1,RATSIMP,RECTFORM) is handled as RECTFORM(RATSIMP(2exp1)).
The SIMP, NUMER, FLOAT, PRED, and INFEVAL switches may also be set
locally in a block, or globally at the "top level" in MACSYMA so that
they will remain in effect until being reset.  Setting INFEVAL:TRUE
locally will cause all evaluations occurring via explicit calls to EV
to be done "infinitely".

If 2exp1 is in CRE form $see<rep> then EV will return a result in CRE form provided
the NUMER and FLOAT switches are both FALSE.

(2) During step (1), a list is made of the non-subscripted variables appearing on the
left side of equations in the 2argi1 or in the value of some 2argi1 if the value
is an equation.
The variables (including subscripted variables) in the expression 2exp1 are
replaced by their
global values, except for those appearing in this list.  Usually, 2exp1 is just a
label or % (as in (C2) below), so this step simply retrieves the expression named by the
label, so that EV may work on it.

(3) If any substitutions are indicated by the 2argi1, they are carried out now.
.begin turn on ""
(4) The resulting expression is then re-evaluated (unless one of the 2argi1 was NOEVAL) and simplified according the the
2argi1.  Note that any function calls in 2exp1 will be
carried out after the variables in it are evaluated and that
EV(F(X)) thus may behave like F(EV(X)).
.end
(5) If one of the 2argi1 was EVAL, steps (3) and (4) are repeated.

.example
.begin group
.once center
2Examples1

(C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
.end
.begin group
                        d                 2
(D1)  COS(Y) + SIN(X) + --SIN(W) + (W + 1)
                        dW
.end
(C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
.begin group
                    2
(D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742
.end
.end

An alternate "top level" syntax has been provided for EV, whereby one may just
type in its arguments, without the EV().  That is, one may write simply
2exp,arg11,...,2argn1. (This is not permitted as part of another expression, i.e. in functions, blocks, etc.).  2exp,RESCAN1 is equivalent to EV(2exp1). 


.example
(C4) X+Y,X:A+Y,Y:2;
(D4)                Y + A + 2

1(Notice the parallel binding process)*

(C5) 2*X-3*Y=3$

(C6) -3*X+2*Y=-4$

(C7) SOLVE([D5,D6]);
solution
.begin group
                             1
(E7)                  Y =  - -
                             5
.end
.begin group
                          6
(E8)                  X = -
                          5
.end

(D8)               [E7, E8]

(C9) D6,D8;
(D9)               - 4 =  - 4

(C10) X+1/X > GAMMA(1/2);

.begin group
                    1
(D10)           X + - > SQRT(%PI)
                    X
.end

(C11) %,NUMER,X=1/2;

(D11)            2.5 > 1.7724539

(C12) %,PRED;
(D12)                  TRUE

.end
.endfunction


.function(UNKNOWN,exp)
returns  TRUE   iff  2exp*  contains an operator or function not known to the built-in simplifier.
.endfunction

.function(EXPAND,exp)
causes products of sums and exponentiated sums to be multiplied out,
numerators of rational expressions which are sums to be split into their respective
terms, and multiplication (commutative and non-commutative) to be distributed over
addition at all levels of 2exp1.
For polynomials one may wish use RATEXPAND which uses a more efficient algorithm (see below).


Terms in 2exp1 whose exponent is less than $var<MAXNEGEX/1000> or greater than $var<MAXPOSEX/1000> will not be EXPANDed.  However,

EXPAND(2exp,p,n1) expands 2exp1, using 2p1 for MAXPOSEX and 2n1 for MAXNEGEX.  This helps the user control how much and what kinds of expansion are to take place.

$var<EXPON/0> - the exponent of the largest negative power which is automatically
expanded (independent of calls to EXPAND).  For example if EXPON is 4 then (X+1)**(-5)
will not be automatically expanded.

$var<EXPOP/0> - the highest positive exponent which is automatically expanded.  Thus
(X+1)**3, when typed, will be automatically expanded only if EXPOP is greater than or
equal to 3.  If it is desired to have (X+1)**n expanded where n is greater than EXPOP
then executing EXPAND((X+1)**n) will work only if MAXPOSEX is not less than n.



.example
(C1) (1/(X+Y)**4-3/(Y+Z)**3)**2;

.begin group
                              1          3     2
(D1)                      (-------- - --------)
                                  4          3
                           (Y + X)    (Z + Y)
.end

(C2) EXPAND(%,2,0);

.begin group
                           6              9          1
(D2)             - ----------------- + -------- + --------
                          4        3          6          8
                   (Y + X)  (Z + Y)    (Z + Y)    (Y + X)
.end

(C3) EXPAND(A.(B+C.(D+E)+F));

(D3)            A . F + A . C . E + A . C . D + A . B

.end
.endfunction

.function(RATEXPAND,exp)
expands 2exp1 by multiplying out products of sums and exponentiated sums,
combining fractions over a common denominator, cancelling the greatest common divisor
of the numerator and denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by converting 2exp1
to CRE form $see<rep> and then back to general form.


$var<RATEXPAND/FALSE> - if TRUE will cause CRE expressions to be fully expanded when
they are converted back to general form or displayed, while if it is FALSE then they
will be put into a recursive form. (see RATSIMP below)

$var<RATDENOMDIVIDE/TRUE> - if FALSE will stop the splitting up of the terms of the
numerator of RATEXPANDed expressions from occurring.

$var<KEEPFLOAT/FALSE> if set to TRUE will prevent floating point numbers from being
rationalized when expressions which contain them are converted to CRE form.

$var<GCD/SPMOD> if FALSE will prevent the greatest common divisor from being taken
when expressions are converted to CRE form.  This will sometimes speed the calculation if gcds are not required. (cf. the function GCD in $ref<rational!functions>)

.example
(C1) RATEXPAND((2*X-3*Y)**3);

.begin group
                3         2       2        3
(D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X

(C2) (X-1)/(X+1)**2+1/(X-1);
.end

.begin group
                              X - 1       1
(D2)                         -------- + -----
                                    2   X - 1
                             (X + 1)
.end

(C3) EXPAND(D2);

.begin group
                         X              1           1
(D3)                ------------ - ------------ + -----
                     2              2             X - 1
                    X  + 2 X + 1   X  + 2 X + 1
.end

(C4) RATEXPAND(D2);

.begin group
                             2
                          2 X                 2
(D4)                 --------------- + ---------------
                      3    2            3    2
                     X  + X  - X - 1   X  + X  - X - 1

.end

.end
.endfunction

.function(RATSIMP,exp)
"rationally" simplifies (similar to RATEXPAND) the expression 2exp1
and all of its subexpressions including the arguments to non-rational
functions.  The result is returned as the quotient of two polynomials
in a recursive form, i.e. the coefficients of the main variable are
polynomials in the other variables.  Variables may, as in RATEXPAND,
include non-rational functions (e.g. SIN(X**2+1) ) but with RATSIMP,
the arguments to non-rational functions are rationally simplified.
Note that RATSIMP is affected by some of the variables which affect
RATEXPAND.


$var<RATSIMPEXPONS/FALSE> - if TRUE will cause exponents of expressions to be
RATSIMPed automatically during simplification.
.endfunction

.function(RATSIMP,|exp,v1,...,vn|)
enables rational simplification with the specification of variable ordering as in RATVARS.

.example
.begin group
(C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);


                                    2                  2
                    X          - LOG (X) + (LOG(X) + 1)
(D1)          SIN(------) = %E
                   2
                  X  + X
.end

(C2) RATSIMP(%);
.begin group
                                  1          2
(D2)                        SIN(-----) = %E X
                                X + 1
.end

(C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));

.begin group
                       3/2
                (X - 1)    - SQRT(X - 1) (X + 1)
(D3)            --------------------------------
                    SQRT(X - 1) SQRT(X + 1)
.end

(C4) RATSIMP(%);
.begin group
                                 2
(D4)                      - -----------
                            SQRT(X + 1)
.end

(C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;

.begin group
                    2
                   A  + 1
                   ------
                     A
(D5)              X
.end

.end
.endfunction

.function(FULLRATSIMP,exp)
When non-rational expressions are involved, one call
to RATSIMP followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.  The command
FULLRATSIMP makes this process convenient.  FULLRATSIMP repeatedly
applies RATSIMP followed by non-rational simplification to an
expression until no further change occurs.  For example, consider
For the expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .
FULLRATSIMP(EXP); gives   X^A-1 .  The problem may be seen by looking at 
RAT(EXP); which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
.endfunction

.function(FULLRATSIMP,|exp,var1,...,varn|)
takes one or more arguments similar 
to RATSIMP above.
.endfunction

.function(RADCAN,exp)
simplifies 2exp1, which can contain logs, exponentials, and radicals,
by converting it into a form which is canonical over a large class of expressions and a
given ordering of variables; that is, all functionally equivalent forms are mapped
into a unique form.  For a somewhat larger class of expressions, RADCAN produces a
regular form [Fa2].  Two equivalent expressions in this class will not necessarily
have the same appearance, but their difference will be simplified by RADCAN to zero.
For some expressions RADCAN can be quite time consuming.  This is the cost of
exploring certain relationships among the components of the expression for
simplifications based on factoring and partial-fraction expansions of exponents.  (Because exploring all types of simplifications in which nested radicals can
participate is very expensive, RADCAN will sometimes fail to discover simplied
forms.  E.g. RADCAN is not able to reduce the expression SQRT(EXPAND((1+SQRT(X))^2))-(1+SQRT(X)) to 0 where X 7>1 0.)  The variable $var<%E_TO_NUMLOG/FALSE> may be useful also, $see<miscellaneous!functions>.


$var<RADEXPAND/TRUE> when set to FALSE will inhibit certain
transformations: RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not
become %I SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X
+ 1) and will not be transformed to X-1.
 
.example
(C1) (LOG(X**2+X)-LOG(X))**A/LOG(X+1)**(A/2);

.begin group
                          2               A
                    (LOG(X  + X) - LOG(X))
(D1)                -----------------------
                                   A/2
                         LOG(X + 1)
.end

(C2) RADCAN(%);
.begin group
                               A/2
(D2)                 LOG(X + 1)
.end

(C3) LOG(A**(2*X)+2*A**X+1)/LOG(A**X+1);

.begin group
                   2 X      X
              LOG(A    + 2 A  + 1)
(D3)          --------------------
                       X
                  LOG(A  + 1)
.end

(C4) RADCAN(%);
(D4)                  2

(C5) (%E**X-1)/(%E**(X/2)+1);

.begin group
                       X
                     %E  - 1
(D5)                ---------
                      X/2
                    %E    + 1
.end

(C6) RADCAN(%);

.begin group
                      X/2
(D6)                %E    - 1
.end

.end
.endfunction

.function(COMBINE,exp)
simplifies the sum exp by combining terms with the same denominator into a single term.
.endfunction


.function(MULTTHRU,exp)
multiplies a factor (which should be a sum) of 2exp1  by the other factors of
2exp1. That is 2exp1 is f1*f2*...*fn where at least one factor, say fi, is a
sum of terms.  Each term in that sum is multiplied by the other factors in the
product.  (Namely all the factors except fi).  MULTTHRU does not expand
exponentiated sums.  This function is the fastest way to distribute products
(commutative or noncommutative) over sums.  Since quotients are represented as
products $see<simp> MULTTHRU can be used to divide sums by products as well.

.endfunction

.function(MULTTHRU,|exp1, exp2|)
multiplies each term in 2exp21 (which should be a sum
or an equation) by 2exp11.  If 2exp11 is not itself a sum then this form is
equivalent to MULTTHRU(2exp11*2exp21).

.example
(C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;

.begin group
               1        X         F(X)
(D1)       - ----- + -------- - --------
             X - Y          2          3
                     (X - Y)    (X - Y)
.end

(C2) MULTTHRU((X-Y)**3,%);

.begin group
                    2
(D2)       - (X - Y)  + X (X - Y) - F(X)
.end

(C3) RATEXPAND(D2);
.begin group
                           2
(D3)                    - Y  + X Y - F(X)
.end

(C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);

.begin group
                         10  2              2  2
                (B  + A )   S  + 2 A B S + A  B
(D4)            --------------------------------
                                   2
                              A B S
.end

(C5) MULTTHRU(%);

.begin group
                                          10
                        2   A B   (B  + A)
(D5)                    - + --- + -------
                        S    2      A B
                            S
.end

1(notice that (B+A)**10 is not expanded)*

(C6) MULTTHRU(A.(B+C.(D+E)+F));

(D6)                A . F + A . (C . (E + D)) + A . B

1(compare with similar example under EXPAND)*

.end
.endfunction

.function(DISTRIB,exp)
distributes sums over products.  It differs from EXPAND
in that it works at only the top level of an expression, i.e. it doesn't
recurse and it is faster than EXPAND.  It differs from MULTTHRU in
that it expands all sums at that level. For example, 
.begin nofill narrow 5;
DISTRIB((A+B)*(C+D)) -> A C + A D + B C + B D 
MULTTHRU ((A+B)*(C+D)) -> (A + B) C + (A + B) D

DISTRIB (1/((A+B)*(C+D))) ->  1/ ((A+B) *(C+D))
EXPAND(1/((A+B)*(C+D)),1,0) -> 1/(A C + A D + B C + B D)
.end
.endfunction

The switch $var<NEGDISTRIB/TRUE> may be set globally to control the
distribution of -1 over an expression.  When it is TRUE it allows -1
to be distributed over an expression.  E.g. -(X+Y) becomes -Y-X.
Setting it to FALSE will allow -(X+Y) to be displayed like that.  This
is sometimes useful but be very careful: like the SIMP flag, this is
one flag you do not want to set to FALSE as a matter of course or
necessarily for other than local use in your MACSYMA.

.function(XTHRU,exp)
combines all terms of 2exp1 (which should be a sum) over a common denominator
without expanding products and exponentiated sums as $fun<RATSIMP> does.  XTHRU
cancels common factors in the numerator and denominator of rational expressions but
only if the factors are explicit.  Sometimes it is better to use XTHRU before
RATSIMPing an expression in order to cause explicit factors of the gcd of the
numerator and denominator to be canceled thus simplifying the expression to be
RATSIMPed.

.example
(C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;

.begin group
                                                20
                     1           X       (X + 2)   - 2 Y
(D1)             --------- - --------- + ---------------
                        19          20             20
                 (Y + X)     (Y + X)        (Y + X)
.end

(C2) XTHRU(%);
.begin group
                                     20
                              (X + 2)   - Y
(D2)                          -------------
                                       20
                                (Y + X)
.end

.end
.endfunction

.function(PARTFRAC,|exp, var|)
expands the expression 2exp1 in partial fractions with respect to the main variable,
2var1.
Each power of a different denominator will be represented by only a single term (i.e. the decomposition is not "complete").
The algorithm employed is based on the fact that the denominators of the partial
fraction expansion (the factors of the original denominator) are relatively prime.
The numerators can be written as linear combinations of denominators, and the
expansion falls out.

.example
(C1) 2/(X+2)-1/(X+1)-X/(X+1)**2$

(C2) RATSIMP(%);
.begin group
                                     X
(D2)                      - -------------------
                             3      2
                            X  + 4 X  + 5 X + 2
.end

(C3) PARTFRAC(%,X);
.begin group
                            - 2 X - 1     2
(D3)                       ---------- + -----
                                   2    X + 2
                            (X + 1)
.end

.end
.endfunction

.function(FACTOR,exp)
factors the expression 2exp1, containing any number of variables or functions,
into factors irreducible over the integers.

.ENDFUNCTION

.FUNCTION(FACTOR,|exp, p|)
factors 2exp1 over the field of integers with an element adjoined whose minimum polynomial is 2p1.


$var<FACTORFLAG/FALSE> if FALSE suppresses the factoring of integer
factors of rational expressions.

$var<DONTFACTOR/> may be set to a list of variables with respect to which factoring is
not to occur.  (It is initially empty).  Factoring also will not take place with
respect to any variables which are less important (using the variable ordering assumed
for CRE form) than those on the DONTFACTOR list. $see<rational!functions>

$var<FACEXPAND/TRUE> controls whether the irreducible factors
returned by FACTOR are in expanded (the default) or recursive (normal
CRE) form.

$var<SAVEFACTORS/FALSE> if TRUE causes the factors of an expression which is a
product of factors to be saved by certain functions in order to speed up later
factorizations of expressions containing some of the same factors.

$var<BERLEFACT/TRUE> if FALSE then the Kronecker factoring algorithm will be used otherwise the Berlekamp
algorithm, which is the default, will be used. (see [Be1, Wa4])

$var<NEWFAC/FALSE> may be set to true to use the new factoring routines.

$var<INTFACLIM/1000> is the largest divisor which will be tried when factoring a bignum integer.  If set to FALSE (this is the case when the user calls FACTOR explicitly), or if the integer is a fixnum (i.e. fits in one machine word), complete factorization of the integer will be attempted.   The user's setting of INTFACLIM is used for internal calls to FACTOR. 
 Thus, INTFACLIM may be reset to prevent MACSYMA from taking an inordinately long time factoring large integers. 
.endfunction
.function(GCFACTOR,n)
factors the gaussian integer n over the gaussians, i.e. numbers of the
form  a + b i where a and b are rational integers. Factors are normalized by making a and b non-negative.

.example
(C1) FACTOR(2**63-1);

.begin group
                                                2
(D1)                   73 127 337 92737 649657 7
.end

(C2) FACTOR(Z**2*(X+2*Y)-4*X-8*Y);

(D2)                   (2 Y + X) (Z - 2) (Z + 2)

(C3)  X**2*Y**2+2*X*Y**2+Y**2-X**2-2*X-1;

.begin group
                     2  2        2    2    2
(D3)                X  Y  + 2 X Y  + Y  - X  - 2 X - 1
.end

(C4) DONTFACTOR:[X]$

(C5) FACTOR(D3/36/(Y**2+2*Y+1));

.begin group
                            2
                          (X  + 2 X + 1) (Y - 1)
(D5)                      ----------------------
                                36 (Y + 1)
.end

(C6) FACTOR(%E**(3*X)+1);
.begin group
                          X         2 X     X
(D6)                   (%E  + 1) (%E    - %E  + 1)
.end

(C7) FACTOR(X**4+1,A**2-2);

.begin group
                    2              2
(D7)              (X  + A X + 1) (X  - A X + 1)
.end

.end

When FACTOR is applied to integers, note that the value returned by FACTOR when used in other computations may not lead to a simplified result.  Using D1 above, the user can check that D1 + 1; will not return  2^63.


.endfunction

.function(FACTORSUM,exp)
tries to group terms in factors of 2exp1 which are sums into groups
of terms such that their sum is factorable.  It can recover the
result of EXPAND((X+Y)^2+(Z+W)^2) but it can't
recover EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.

.EXAMPLE

.BEGIN GROUP

(C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;

	  2      2                            2      2
(D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X 

			 2        2    2            2
	    + 2 U V X + U  X + A W  + V  + 2 U V + U

.END
.BEGIN GROUP
(C2) FACTORSUM(%);
				       2          2
(D2)                 (X + 1) (A (Z + W)  + (V + U) )

.END
.END
.endfunction

.function(FACTOROUT,|exp,var1,var2,...|)
rearranges the sum 2exp* into a sum of terms of the form f(var1,var2,...)*g
where g is a product of expressions not containing the vari's and f is factored.
.endfunction


Another technique of factoring complex expressions uses the function SCANMAP (see Chapter $ref<lisp!functions>). 
             



.function(SQFR,exp)
is similar to FACTOR except that the polynomial factors are "square-free."  That
is, they have factors only of degree one.  This algorithm, which is also used by the
first stage of FACTOR, utilizes the fact that a polynomial has in common with its
n2th1 derivative all its factors of degree > n.  Thus by taking gcds with the
polynomial of the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.

.example group
(C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);

                             2               2
(D1)                       (X  - 1) (2 X + 1)

.end
.endfunction

.function(GFACTOR,exp)
factors the polynomial 2exp1 over the Gaussian integers (i. e. with SQRT(-1) =
%I adjoined).  This is like FACTOR(2exp1,A**2+1) where A is %I.

.example group
(C1)  GFACTOR(X**4-1);
(D1)        (X - 1) (X + 1) (X + %I) (X - %I)

.end
.endfunction

.function(GFACTORSUM,exp)
is similar to FACTORSUM but applies GFACTOR instead of FACTOR.
.endfunction

.function(PARTITION,|exp, var|)
returns a list of two expressions.  They are (1) the factors of 2exp1 (if it is a
product) or the terms of 2exp1 (if it is a sum) which don't contain 2var1 and, (2)
the factors or terms which do.

.example
(C1) PARTITION(2*A*X*F(X),X);

(D1)                 [ 2 A , X F(X) ]

(C2) PARTITION(A+B,X);

(D2)                 [ A + B , 0 ]
.end
.endfunction

.function(LOGCONTRACT,exp)
recursively scans an exp, transforming subexpressions of the form
a1*LOG(b1) + a2*LOG(b2) + c into LOG(RATSIMP(b1^a1 * b2^a2)) + c

.example

(C1) 2*(A*LOG(X) + 2*A*LOG(Y))$

(C2) LOGCONTRACT(%);
					2  4
(D2) 				 A LOG(X  Y )

(C3) LOGCONTRACT(LOG(SQRT(X+1)+SQRT(X)) + LOG(SQRT(X+1)-SQRT(X)));
(D3) 				      0

.end
if you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
A*LOG(X^(2*N)).  The coefficients that "contract" in this manner are
those such as the 2 and the N here which satisfy
FEATUREP(coeff,INTEGER).  The user can control which coefficients are
contracted by setting the option $var<LOGCONCOEFFP/FALSE> to the name of a
predicate function of one argument.  E.g. if you like to generate
SQRTs, you can do
.example
(C1) LOGCONCOEFFP:'LOGCONFUN$
(C2) LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$
(C3) LOGCONTRACT(1/2*LOG(X)); 
(D3)                             LOG(SQRT(X)).
.end
.endfunction

.function(ROOTSCONTRACT,exp) 
converts products of roots into roots of products. For example,
ROOTSCONTRACT(SQRT(X)*Y^(3/2)); gives SQRT(X*Y^3).
There is an option $var<ROOTSCONMODE/TRUE>, 
which affects ROOTSCONTRACT as follows:
.SKIP BEGIN NOFILL turn on "\" tabs 25,50;turn off "^"
Problem        Value of ROOTSCONMODE     Result of applying ROOTSCONTRACT
X^(1/2)*Y^(3/2)\FALSE\(X*Y^3)^(1/2)
X^(1/2)*Y^(1/4)\FALSE\X^(1/2)*Y^(1/4)
X^(1/2)*Y^(1/4)\TRUE\(X*Y^(1/2))^(1/2)
X^(1/2)*Y^(1/3)\TRUE\X^(1/2)*Y^(1/3)
X^(1/2)*Y^(1/4)\ALL\(X^2*Y)^(1/4)
X^(1/2)*Y^(1/3)\ALL\(X^3*Y^2)^(1/6)
.end
(The above examples and more may be tried out by typing 
EXAMPLE(ROOTSCONTRACT); .)
When ROOTSCONMODE is FALSE, ROOTSCONTRACT contracts only wrt rational 
number exponents whose denominators are the same.  The key to the 
ROOTSCONMODE:TRUE$ examples is simply that 2 divides into 4 but not 
into 3.  ROOTSCONMODE:ALL$ involves taking the lcm (least common multiple)
of the denominators of the exponents.
ROOTSCONTRACT uses RATSIMP in a manner similar to LOGCONTRACT.  
.example
(C1) ROOTSCONMODE:TRUE$
(C2) ROOTSCONTRACT(SQRT(SQRT(5)+5)-5^(1/4)*SQRT(SQRT(5)+1));
(D2) 				      0

.end
.endfunction


.subsec (Sums and Products,sumsandprods)

.function(SUM,|exp, ind, lo, hi|)
performs a summation of the values of 2exp1 as the index 2ind1 varies from
2lo1 to 2hi1.   If the upper and lower limits differ by an integer then each term
in the sum is evaluated and added together.  Otherwise, if SIMPSUM [FALSE] is TRUE the result is
simplified.  This simplification may sometimes be able to produce a closed form.  If
SIMPSUM is FALSE or if 'SUM is used, the value is a sum noun form which is a
representation of the sigma notation used in mathematics.


If 2hi1 is one less than 2lo1, we have an "empty sum" and SUM returns 0 rather than erring out.


Sums may be differentiated, added, subtracted, or multiplied with some automatic
simplification being performed.

$var<SUMEXPAND/FALSE> if TRUE, products of sums and
exponentiated sums are converted into nested sums.
E.g.
.example
(C1) SUMEXPAND:TRUE$

(C2) SUM(F(I),I,0,M)*SUM(G(J),J,0,N);

			   M	  N
			  ====	 ====
			  \	 \
(D2) 			   >	  >     F(I1) G(I2)
			  /	 /
			  ====	 ====
			  I1 = 0 I2 = 0

(C3) SUM(F(I),I,0,M)^2;

			   M	  M
			  ====	 ====
			  \	 \
(D3) 			   >	  >     F(I3) F(I4)
			  /	 /
			  ====	 ====
			  I3 = 0 I4 = 0

.end
If FALSE, they are left alone.


$var<CAUCHYSUM/FALSE> When multiplying together sums with INF as their upper limit, 
if set to TRUE then the Cauchy product will be used rather than the usual product.
In the Cauchy product the index of the inner summation is a function of 
the index of the outer one rather than varying independently.

$fun<GENINDEX[I]> is the alphabetic prefix used to generate the next variable of summation when necessary.

$fun<GENSUMNUM[0]> is the numeric suffix used to generate the next variable of
summation.  If it is set to FALSE then the index will consist only of GENINDEX with no
numeric suffix.

.example
(C1) SIMPSUM:TRUE$

(C2) SUM(I**2+2**I,I,0,N);

.begin group
                         3      2
              N + 1   2 N  + 3 N  + N
(D2)         2      + --------------- - 1
                             6
.end

(C3) SUM(3**(-I),I,1,INF);

.begin group
                          1
(D3)                      -
                          2
.end

(C4) SUM(I^2,I,1,4)*SUM(1/I^2,I,1,INF);

.begin group
                                       2
(D5)                              5 %PI
.end

.end
.endfunction

.function(SUMCONTRACT,expr)
- will combine all sums of an addition that have
upper and lower bounds that differ by constants. The result will be an
expression containing one summation for each set of such summations
added to all appropriate extra terms that had to be extracted to form
this sum.  SUMCONTRACT will combine all compatible sums and use one of
the indices from one of the sums if it can, and then try to form a
reasonable index if it cannot use any supplied.
.endfunction

.function(INTOSUM,expr)
- will take all things that a summation is multiplied
by, and put them inside the summation. If the index is used in the
outside expression, then the function tries to find a reasonable
index, the same as it does for SUMCONTRACT. This is essentially the
reverse idea of the OUTATIVE property of summations, but note that it
does not remove this property, it only bypasses it.
.endfunction

.function(BASHINDICES,expr)
- will take the expression and give each index of a
summation and product a unique index. This allows CHANGEVAR to be
selective about which summations it is playing with.  The form of the
unique index is J<number>. If <number> gets to big for your liking, it
can be changed by changing GENSUMNUM (eg GENSUMNUM:0$ will reset it).
.endfunction

.function(NICEINDICES,expr)
- will take the expression and change all the
indices of sums and products to something easily understandable. It
makes each index it can "I" , unless "I" is in the internal
expression, in which case it sequentially tries
J,K,L,M,N,I0,I1,I2,I3,I4,...  until it finds a legal index.
.endfunction

.function(NUSUM,|exp,var,low,high|)
performs indefinite summation of 2exp1 with respect to 2var1 using a decision procedure due to R.W. Gosper.  2exp1  and the potential answer must be expressible as products of n^[th] powers, factorials, binomials, and rational functions.
.endfunction

.function(UNSUM,|fun,n|)
is the first backward difference  2fun(n) - fun(n-1)1.
.endfunction

.function(FUNCSOLVE,|eqn,g(t)|)
gives [g(t) = ...]  or [], depending on whether
or not there exists a rational fcn g(t) satisfying 2eqn1, which must be
a first order, linear polynomial in (for this case) g(t) and g(t+1).

Warning: this is a very rudimentary implementation--many safety checks
and obvious generalizations are missing.
.endfunction
.example

(C1) G(P):=P*4^N/BINOMIAL(2*N,N);
					    N
					 P 4
(D1) 			   G(P) := ----------------
				   BINOMIAL(2 N, N)
.begin group

(C2) G(N^4);
				     4  N
				    N  4
(D2) 			       ----------------
			       BINOMIAL(2 N, N)
.end
(C3) NUSUM(D2,N,0,N);
			 4	  3	  2		 N
	  2 (N + 1) (63 N  + 112 N  + 18 N  - 22 N + 3) 4      2
(D3) 	  ------------------------------------------------ - ------
			693 BINOMIAL(2 N, N)		     3 11 7

(C4) UNSUM(%,N);
				     4  N
				    N  4
(D4) 			       ----------------
			       BINOMIAL(2 N, N)

(C5) FUNCSOLVE((N+1)*FOO(N)-(N+3)*FOO(N+1)/(N+1) =
(N-1)/(N+2),FOO(N));
				   N
(D5) 		   FOO(N) = ---------------
			    (N + 1) (N + 2)

.end
$var<SUMHACK/FALSE> if set to true allows SUM(I,I,3,1); to give -2,
based on the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1), when
A>B.

.function(PRODUCT,|exp, ind, lo, hi|)
gives the product of the values of 2exp1 as the index 2ind1 varies from
2lo1 to 2hi1.  The evaluation is similar to that of SUM.   No simplification of
products is available at this time.  If 2hi1 is one less than 2lo1, we have an "empty product" and PRODUCT returns 1 rather than erring out.

.example group
(C1)  PRODUCT(X+I*(I+1)/2,I,1,4);

(D1)             (X + 1) (X + 3) (X + 6) (X + 10)
.end
.endfunction

$var<PRODHACK/FALSE> - if set to TRUE then PRODUCT(F(I),I,3,1); 
will yield 1/F(2), by the identity 
PRODUCT(F(I),I,A,B) = 1/PRODUCT(F(I),I,B+1,A-1) when A>B.

.subsec (Differentiation and Integration Functions,difintfun)

.function(DIFF,|exp, v1, n1, v2, n2, ...|)
differentiates 2exp1 with respect to each 2vi1, 2ni1 times.  If just the first
derivative with respect to one variable is desired then the form DIFF(2exp,v1)
may be used.  If the noun form of the function is required (as, for example, when writing a
differential equation), 'DIFF should be used and this will display in a two dimensional
format.  (See Section ???***??? on how to convert 'DIFF ("derivative") into
DIFF ("differentiate") via the EV command.)


$var<DERIVABBREV/FALSE> if TRUE will cause derivatives to display as subscripts.

DIFF(2exp1) gives the "total differential", that is, the sum of the
derivatives of 2exp1 with respect to each of its variables times the function
DEL of the variable.  No further simplification of DEL is offered. 
.example

(C1) DIFF(EXP(F(X)),X,2);
			     2
		      F(X)  d		  F(X)  d       2
(D1) 		    %E	   (--- F(X)) + %E     (-- F(X))
			      2		        dX
			    dX



(C2) DERIVABBREV:TRUE$


(C3) 'INTEGRATE(F(X,Y),Y,G(X),H(X));
				H(X)
			       /
			       [
(D3) 			       I     F(X, Y) dY
			       ]
			       /
				G(X)

.begin group
(C4) DIFF(%,X);
	    H(X)
	   /
	   [
(D4) 	   I	 F(X, Y)  dY + F(X, H(X)) H(X)  - F(X, G(X)) G(X)
	   ]	        X		      X			 X
	   /
	    G(X)

.end
.end
.endfunction
.begin turn on ""
.function(DEPENDS,|funlist1,varlist1,funlist2,varlist2,...|)
declares functional dependencies for variables to be used by DIFF.  DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T) informs DIFF that F and G depend on X and Y, that R and S depend on U,V, and W, and that U depends on T.  The arguments to DEPENDS are evaluated.  The variables in each 2funlist1 are declared to depend on all the variables in the next 2varlist1.$$In this command, lists of length one can be typed in directly as atoms.*  A 2funlist1 can contain the name of an atomic variable or array.   In the latter case, it is assumed that all the elements of the array depend on all the variables in the succeeding 2varlist1.    Initially, DIFF(F,X) is 0;  executing DEPENDS(F,X) causes future differentiations of F with respect to X to give  DF/DX  or  YX   (if DERIVABBREV:TRUE).

.example

(C1) DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T);
(D1) 	       [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]

(C2) DEPENDENCIES;
(D2) 	       [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
.begin group
(C3) DIFF(R.S,U);
			       dR	    dS
(D3) 			       -- . S + R . --
			       dU	    dU
.end
.end

Since MACSYMA knows the chain rule for symbolic derivatives, it takes advantage of the given dependencies as follows:
.example
.begin group
(C4) DIFF(R.S,T);
			   dR dU	     dS dU
(D4) 			  (-- --) . S + R . (-- --)
			   dU dT	     dU dT
.end
.end
.bcon
If we set 
.example
(C5) DERIVABBREV:TRUE;
(D5) 				     TRUE
.end
.scon
then re-executing the command C4, we obtain
.example

(C6) ''C4;
(D6) 			  (R  U ) . S + R . (S  U )
			    U  T	      U	 T
.end


To eliminate a previously declared dependency, the REMOVE command can be used.  For  example, to say that R no longer depends on U as declared in C1, the user can type  REMOVE(R,DEPENDENCY).  This will eliminate all dependencies that may have been declared for R.  
.example

(C7) REMOVE(R,DEPENDENCY);
(D7) 				     DONE

(C8) ''C4;
(D8) 				 R . (S  U )
				       U  T

.end scon
2CAVEAT:1 DIFF* is the only1 MACSYMA* command which uses 1DEPENDENCIES* information.   The arguments to 1INTEGRATE,LAPLACE,*etc. must be given their dependencies explicitly in the command, e.g., 1INTEGRATE(F(X),X)*.

.endfunction
1
.end
.function(GRADEF,|f(x1, ..., xn), g1, ..., gn|)
defines the derivatives of the function 2f1 with respect to its n arguments.  That is,
d2f1/d2xi1 = 2gi1, etc.  If fewer than n gradients, say i, are given, then they
refer to the first i arguments of 2f1.  The 2xi1 are merely dummy variables as in
function definition headers and are used to indicate the i2th1 argument of 2f1.  All
arguments to GRADEF except the first are evaluated so that if 2g1 is a defined
function then it is invoked and the result is used.

Gradients are needed when, for example, a function is not known explicitly but
its first derivatives are and it is desired to obtain higher order derivatives.
GRADEF may also be used to redefine the derivatives of MACSYMA's predefined functions
(e.g. GRADEF(SIN(X),SQRT(1-SIN(X)**2)) ).  It is not permissible to use GRADEF on
subscripted functions.

GRADEFS is a list of the functions which have been given gradients by use of the
GRADEF command.

PRINTPROPS([2f1,f2,1...],GRADEF) $see<MACSYMA!properties> may be used to display the gradefs of the functions 2f1,f2,..1

REMOVE([2f1,f2,1...],GRADEF) may be used to eliminate the GRADEF property from the functions 2f1,f2,...1.

.example
(C1) DEPENDS(Y,X)$

(C2) GRADEF(F(X,Y),X**2,G(X,Y))$

(C3) DIFF(F(X,Y),X);
.begin group
                                     dY    2
(D3)                         G(X, Y) -- + X
                                     dX
.end

(C4) GRADEF(J(N,Z), 'DIFF(J(N,Z),N),
RATSIMP(J(N-1,Z)-N/Z*J(N,Z)))$

(C5) DIFF(J(2,X),X,2);

.begin group
                       2
              J(0, X) X  - 3 J(1, X) X + 6 J(2, X)
(D5)          ------------------------------------
                                2
                               X
.end

.end

    (The example above computes the second derivative of a Bessel function of order two.
A subscripted function e.g. J[N], could not have been used because a gradient for it
cannot be defined using GRADEF.)

.endfunction

.function(GRADEF,|a,v,exp|)
may be used to state
that the derivative of the atomic variable 2a1 with respect to 2v1 is
2exp1.  This automatically does a DEPENDS(2a1,2v1).  For examples, see example 2 of Appendix III.


PRINTPROPS([2a1,a21,...],$fun<ATOMGRAD>) $see<MACSYMA!properties> may be used to display the atomic
gradient properties of 2a1,a2,...1

REMOVE([2a1,a2,1...],ATOMGRAD) may be used to eliminate the ATOMGRAD property from  2a1,a2,...1.


.endfunction

.function(INTEGRATE,|exp, var|)
 integrates 2exp1 with respect to 2var1 or returns an integral
expression (the noun form) if it cannot perform the integration.
Generally speaking, MACSYMA only handles integrals which are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as g(x) and h(x).
Roughly speaking three stages are used:

(1) INTEGRATE sees if the integrand is of the form
F(G(X))*DIFF(G(X),X) by testing whether the derivative of some
subexpression (i.e. G(X) in the above case) divides the integrand.  If
so it looks up F in a table of integrals and substitutes G(X) for X in
the integral of F.  This may make use of gradients in taking the
derivative.  (If an unknown function appears in the integrand it must
be eliminated in this stage or else INTEGRATE will return the noun
form of the integrand.)

(2) INTEGRATE tries to match the integrand to a form for which a
specific method can be used, e.g. trigonometric substitutions.

(3) If the first two stages fail it uses the Risch algorithm. (see [Mo2, Mo4])
.endfunction

2CAVEAT: 1INTEGRATE* knows only about explicit dependencies.1

.function(INTEGRATE,|exp, var, low, high|)
 finds the definite integral of 2exp1 with respect to 2var1 from
2low1 to 2high1.  Several methods are used,including direct
substitution in the indefinite integral and contour integration (see
[Wa3]).  Improper integrals may use the names $var<INF/> for positive
infinity and $var<MINF/> for negative infinity.  If an integral "form"
is desired for manipulation (for example, an integral which cannot be
computed until some numbers are substituted for some parameters), the
noun form 'INTEGRATE may be used and this will display with an
integral sign.

$var<ABCONVTEST/FALSE> when TRUE causes INTEGRATE to test for absolute convergence.

$var<LOGABS/FALSE> causes integration of an expression where logs are
generated, e.g. INTEGRATE(1/X,X), to return the answer in terms of
LOG(...).  If LOGABS is set to TRUE, the answer will be given in terms
of LOG(ABS(...)).  For definite integration, the LOGABS:TRUE setting
is used, because here "evaluation" of the indefinite integral at the
endpoints is often needed.

The function $fun<LDEFINT> uses $fun<LIMIT> $see<difintfun> to evaluate the indefinite integral at the lower and upper limits.


Sometimes during integration the user may be asked what the sign of an expression
is.  Suitable responses are POS; , ZERO; , or NEG; . $see<decass>

.example
(C1) INTEGRATE(SIN(X)**3,X);

.begin group
                    3
                 COS (X)
(D1)             ------- - COS(X)
                    3
.end

(C2) INTEGRATE(X**A/(X+1)**(5/2),X,0,INF);
IS  A + 1  POSITIVE, NEGATIVE, OR ZERO?

POS;
IS  2 A - 3  POSITIVE, NEGATIVE, OR ZERO?

NEG;
.begin group
                            3
(D2)            BETA(A + 1, - - A)
                            2
.end

(C3) GRADEF(Q(X),SIN(X**2));
(D3)                              Q(X)

(C4) DIFF(LOG(Q(R(X))),X);

.begin group
                           d             2
                          (-- R(X)) SIN(R (X))
                           dX
(D4)                      --------------------
                                Q(R(X))
.end

(C5) INTEGRATE(%,X);
(D5)                          LOG(Q(R(X)))

.end
.endfunction

.function(DEFINT,|exp, var, low, high|)
DEFinite INTegration, the same as INTEGRATE(2exp,var,low,high1).
.endfunction

.function(RISCH,|exp, var|)
integrates 2exp1 with respect to 2var1 using the Risch algorithm.  This
currently handles the cases of nested exponentials and logarithms which the main
part of $fun<INTEGRATE> can't do.  INTEGRATE will automatically apply RISCH if
given these cases.


$var<ERFFLAG/TRUE> - if FALSE prevents RISCH from introducing the ERF function in
the answer if there were none in the integrand to begin with.

.example group
(C1) RISCH(X^2*ERF(X),X);

	    2     2
	 - X     X             3           2
       %E     (%E   SQRT(%PI) X  ERF(X) + X  + 1)
(D1)   ------------------------------------------
		      3 SQRT(%PI)

(C2) DIFF(%,X),RATSIMP;
				 2
(D2)                            X  ERF(X)

.end
.endfunction

.function(CHANGEVAR,|exp,f(x,y),y,x|)
makes the change of variable given by f(x,y) = 0 in all integrals occurring in 
2exp1 with integration with respect to x;  y is the new variable.

.example
(C1) 'INTEGRATE(%E**SQRT(A*Y),Y,0,4);

.begin group
                    4
                   /
                   [    SQRT(A) SQRT(Y)
(D1)               I (%E               ) DY
                   ]
                   /
                   0
.end

(C2) CHANGEVAR(D1,Y-Z^2/A,Z,Y);
.begin group

			       2 SQRT(A)
			      /
			      [		     ABS(Z)
			    2 I		 Z %E      dZ
			      ]
			      /
			       0
(D2) 			    ---------------------
				      A

.end
.end
CHANGEVAR may also be used to changes in the indices of a sum or product.
However, it must be realized that when a change is made in a sum or product,
this change must be a shift, i.e. I=J+ ..., not a higher degree function.
For example:
.example
.begin group
(C3) SUM(A[I]*X^(I-2),I,0,INF);

			       INF
			       ====
			       \         I - 2
(D3)                            >    A  X
			       /      I
			       ====
			       I = 0

.end
.begin group
(C4) CHANGEVAR(%,I-2-N,N,I);

			      INF
			      ====
			      \               N
(D4)                           >      A      X
			      /        N + 2
			      ====
			      N = - 2

.end
.end
.endfunction

.function (LIMIT,|exp, var, val, dir|)
finds the limit of 2exp1 as the real variable 2var1 approaches the value
2val1 from the direction 2dir1.  2Dir1 may have the value PLUS for a limit
from above, MINUS for a limit from below, or may be omitted (implying a
two-sided limit is to be computed).  For the method see [Wa3].  LIMIT uses the
following special symbols:  INF (positive infinity) and MINF (negative
infinity).  On output it may also use UND (undefined), IND (indefinite but
bounded) and INFINITY (complex infinity).  If LIMIT is called on FIB(2n1),
it will convert this to the closed form definition, involving the constant
$var<%PHI/|(SQRT(5)+1)/2 = 1.618033989>.

$var<LHOSPITALLIM/4> is the maximum number of times  L'Hospital's rule is used in
LIMIT.  This prevents infinite looping in cases like LIMIT(COT(X)/CSC(X),X,0).

$var<TLIMSWITCH/FALSE> if true will cause the limit package to use Taylor series when possible.

.example
(C1) LIMIT(X*LOG(X),X,0,PLUS);

(D1)                 0

(C2) LIMIT((1+X)**(1/X),X,0);

(D2)                 %E

(C3) LIMIT(%E**X/X,X,INF);

(D3)                 INF

(C4) LIMIT(SIN(1/X),X,0);

(D4)                 IND

.end
LIMIT is often called upon to simplify constant expressions like INF-1,
so for such expressions LIMIT will accept only one argument:
.example
(C5) LIMIT(INF-1);

(D5)                 INF
.end
.endfunction

.function(TLIMIT,|exp,var,val,dir|) 
 is just the function LIMIT with TLIMSWITCH set to TRUE.

.endfunction

.function(LDEFINT,|exp,var,low,high|)
yields the definite integral of 2exp* by using LIMIT to evaluate the indefinite integral of 2exp* with respect to 2var* at the upper limit 2high* and at the lower limit 2low*.

.endfunction

.function(TLDEFINT,|exp,var,low,high|)
is just LDEFINT with  TLIMSWITCH  set to TRUE.

.endfunction

.function (RESIDUE,|exp, var, val|)
computes the residue in the complex plane of the expression 2exp1
when the variable 2var1 assumes the value 2val1.  The residue is the coefficient of
(2var1-2val1)**(-1) in the Laurent series for 2exp1.

.example
(C1) RESIDUE(S/(S**2+A**2),S,A*%I);

.begin group
                        1
(D1)                    -
                        2
.end

(C2) RESIDUE(SIN(A*X)/X**4,X,0);

.begin group
                        3
                       A
(D2)                 - --
                       6
.end

.end
.endfunction


.function(ODE2,|diffeq,depvar,indvar|)
solves ordinary differential equations,2diffeq1, of first or second
order. The dependent and independent variables are specified as the
second and third arguments.  When successful ODE2 returns either an
explicit or implicit solution for the dependent variable.  The symbol
2%C1 is used to represent the constant in the case of first order
equations and 2%K1,%K21 represent the constants for second order
equations.  If for some reason ODE2 cannot obtain a solution, it
returns FALSE, sometimes printing an error message to the user.
.example
.begin group
(C1) X^2*'DIFF(Y,X) + 3*X*Y = SIN(X)/X;
			 2 dY	        SIN(X)
(D1) 		        X  -- + 3 X Y = ------
			   dX		  X

.end
(C2) ODE2(%,Y,X);


				%C - COS(X)
(D2) 			    Y = -----------
				     3
				    X


.end
.endfunction

.function(DESOLVE,|[eq1,...,eqn],[var1,...,varn]|)
where the 2eq*'s are differential equations in the dependent variables
var1,...,varn.  The functional relationships must be explicitly
indicated in both the equations and the variables. For example

.example
(C1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);
(C2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);
.end
.scon
is not the proper format.  The correct way is:

.example
(C3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);
(C4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);
.end
The quotes are not necessary since DIFF will return the noun forms anyway.

The call is then DESOLVE([D3,D4],[F(X),G(X)]);

If initial conditions at 0 are known, they should be supplied before
calling DESOLVE by using ATVALUE.
.example

(C11) 'DIFF(F(X),X)='DIFF(G(X),X)+SIN(X);
.begin group
			D         D
(D11)                   -- F(X) = -- G(X) + SIN(X)
			DX        DX
.end
(C12) 'DIFF(G(X),X,2)='DIFF(F(X),X)-COS(X);
.begin group
			 2
			D          D
(D12)                   --- G(X) = -- F(X) - COS(X)
			  2        DX
			DX
.end
(C13) ATVALUE('DIFF(G(X),X),X=0,A);
(D13)                                A

(C14) ATVALUE(F(X),X=0,1);
(D14)                                1

(C15) DESOLVE([D11,D12],[F(X),G(X)]);

		X                            X
(D16) [F(X)=A %E  - A+1, G(X) = COS(X) + A %E  - A + G(0) - 1]

/* VERIFICATION */
(C17) [D11,D12],D16,DIFF;
		  X       X      X                X
(D17)        [A %E  = A %E , A %E  - COS(X) = A %E  - COS(X)]
.end
.endfunction
.subsec(Numerical Integration,numint,1)

A program for Romberg numerical integration can be obtained by doing:
LOADFILE(ROMBRG,FASL,DSK,SHARE)
.skip

The original version of this program was  written by Richard Fateman.  The
 current improved version of the program was written by Charles Karney.   In
 the latest version there are  two ways of calling the function ROMBERG:$$Note
the change from the original version of the program*


1) An inefficient way that resembles a call to INTEGRATE (the definite 
integral version):
.inline function(ROMBERG,|integrand,variable,lower limit,upper limit|)

For example,
.example
(C1) ROMBERG(SIN(Y),Y,1,%PI);
time= 54 msec.
(D1) 			      1.5403023

(C2) F(X):=1/(X^5+X+1)$
time= 1 msec.

(C3) ROMBERG(F(X),X,1.5,0);
time= 216 msec.
.end 
.skip
2) An efficient way that is more like the old ROMBERG function:
.inline function(ROMBERG,|function name,lower limit,upper limit|)

The first argument must be a TRANSLATEd or compiled function.  (If it is
compiled it must be declared to return a FLONUM.)  If the first argument
is not already TRANSLATEd, ROMBERG will not attempt to TRANSLATE it but
will give an error.  As an example consider the function f defined above,
.example
(C4) F(X):=(MODEDECLARE([FUNCTION(F),X],FLOAT),1/(X^5+X+1));
time= 1 msec.
							1
(D4) F(X) := (MODEDECLARE([FUNCTION(F), X], FLOAT), ----------)
						     5
						    X  + X + 1

(C5) TRANSLATE(F)$
time= 10 msec.

(C6) ROMBERG(F,1.5,0);
time= 13 msec.
(D6) 			    - 0.75293843

.end
.skip
The accuracy of the integration is governed by the global variables
$var<ROMBERGTOL/1.E-4> and $var<ROMBERGIT/11>.
ROMBERG will return a result if the relative difference in successive
approximations is less than ROMBERGTOL.  It will try halving the
stepsize ROMBERGIT times before it gives up.

ROMBERG may be called recursively and thus can do double and triple
integrals.  In this case , it is even  more important to TRANSLATE the 
functions and to use the second way of calling ROMBERG. 
.example
(C7) INTEGRATE(INTEGRATE(X*Y/(X+Y),Y,0,X/2),X,1,3);
time= 305 msec.
				    2
			  13 (2 LOG(-) + 1)
				    3
(D7) 			  -----------------
				  3

(C8) %,NUMER;
time= 6 msec.
(D8) 			     0.819302335

(C9) F(Y):=(MODEDECLARE([FUNCTION(F),X,Y],FLOAT),X*Y/(X+Y))$
time= 2 msec.

(C10) G(X):=(MODEDECLARE([FUNCTION(F,G),X],FLOAT),ROMBERG(F,0,X/2))$
time= 1 msec.

(C11) TRANSLATE(F,G)$
time= 6 msec.

(C12) ROMBERG(G,1,3);
time= 32 msec.
(D12) 			      0.8193023


.end

.sec (Part Selection and Substitution, pss)

The functions in this section are used to extract or replace parts of expressions.

.subsec (The Part Functions,partfun)

The Part functions make it possible to reference or replace any part
of any MACSYMA expression.  A part of a displayed expression is
referred to by a set of indices which are non-negative integers.  For
example, in exponentiation the base is considered part 1 and the
exponent part 2.  In a quotient the numerator is part 1 and the
denominator part 2.  In a sum or product the i2th1 term or factor is
part i. In any expression the main operator is part 0.  For -X the 0th
part is -, for A^B it is ^, for DIFF(F(X),X) it is DIFF, etc.  Note
that unary minus is considered an operator.

In MACSYMA the user has some control of the way in which expressions
are displayed.  The ordering of factors in a product or terms in a sum
may be changed by the user (see $ref<ordering!functions>,
$ref<rational!functions>).  The ordering of parts in the displayed
form of an expression may differ from the ordering in the internal
representation of the expression.

.function(PART,|exp, n1, ..., nk|)
deals with the displayed form of 2exp*. It obtains the part of
2exp1 as specified by the indices 2n11,...,2nk1.  First part
2n11 of 2exp1 is obtained, then part 2n21 of that, etc.  The
result is part 2nk1 of ... part 2n21 of part 2n11 of 2exp1.
Thus PART(Z+2*Y,2,1) yields 2.  PART can be used to obtain an element
of a list, a row of a matrix, etc.

.example
(C1)  X+Y/Z**2;
.begin group
                        Y
(D1)                   -- + X
                        2
                       Z
.end
(C2) PART(D1,1,2,2);

(D2)                    2

(C3) 'INTEGRATE(F(X),X,A,B)+X;

.begin group
                      B
                     /
                     [
(D3)                 I F(X)dX + X
                     ]
                     /
                     A
.end

(C4) PART(%,1,1);
(D4)                  F(X)

.end
.endfunction

.function(INPART,|exp,n1,...,nk|)
is similar to PART but works on the internal representation of the
expression $see<simp> rather than the displayed form and thus may be
faster since no formatting is done.  Care should be taken with respect
to the order of subexpressions in sums and products (since the order
of variables in the internal form is often different from that in the
displayed form) and in dealing with unary minus, subtraction, and
division (since these operators are removed from the expression).
PART(X+Y,0) or INPART(X+Y,0) yield +, though in order to refer to the
operator it must be enclosed in "s.  For example ...IF
INPART(D9,0)="+" THEN ...

.example
(C1)  X+Y+W*Z;

(D1)                  W Z + Y + X

(C2)  INPART(D1,3,2);

(D2)                  Z
(C3)  PART(D1,1,2);

(D3)                  Z

(C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
.begin group
                                      G(X + 1)
(D4)                      LIMIT   F(X)
                          X ->0-
.end

(C5) INPART(%,1,2);
(D5)                            G(X + 1)

.end
.endfunction

.function(ARGS,exp)
returns a list of the args of exp.  I.e. it is
essentially equivalent to SUBSTPART("[",exp,0) .
.endfunction

$var<INFLAG/FALSE> if set to TRUE, the functions for part
extraction will look at the internal form of 2exp*.
Also, setting INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.

.function(ALLBUT,|arg1,arg2,...|)
works with the PART commands (i.e. PART, INPART, SUBSTPART,
SUBSTINPART, DPART, and LPART).  For example, if EXPR is E+D+C+B+A,
then PART(EXPR,[2,5]); gives D+A, while PART(EXPR,ALLBUT(2,5)); gives
E+C+B.  (ALLBUT also works with the KILL command, which see.)
.endfunction

.function(DISPFORM,exp) 
returns the external representation of 2exp* (wrt its main
operator).  This should be useful in conjunction with PART which also
deals with the external representation.  Suppose EXP is -A .  Then the
internal representation of EXP is "*"(-1,A), while the external
representation is "-"(A). LENGTH(EXP) gives 2, while
LENGTH(DISPFORM(EXP)) gives 1.  MAP(F,EXP) gives F(-1)*F(A), while
MAP(F,DISPFORM(EXP)) gives -F(A).

  DISPFORM(2exp*,ALL) converts the entire expression (not just the top-level) to external format.  For example, if  EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.

.endfunction  

.function(NOUNIFY,f)
returns the noun form of the function name 2f1.  This is needed
if one wishes to refer to the name of a verb function as if it were a noun.  Note that
some verb functions will return their noun forms if they can't be evaluated for
certain arguments.  This is also the form returned if a function call is preceded by a
quote.

.example group
(C6) IS(INPART(D4,0)=NOUNIFY(LIMIT));

(D6)                              TRUE

.end
.endfunction

.function(APPLY_NOUNS,exp)
causes the application of noun forms in an
expression.  E.g. EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This
gives the same result as EV(EXP,NOUNS); except that it can be faster
and use less storage.  It also can be used in translated code, where
EV may cause problems.  Note that it is called APPLY_NOUNS, not
"EV_NOUNS", because what it does is to apply the rules corresponding to
the noun-form operators, which is not evaluation.
.endfunction

.function(VERBIFY,f)
returns the function name 2f1 in its verb form.

.endfunction

.function(BOX,exp)
returns 2exp1 enclosed in a box. The box is actually part of the expression. BOX(2exp,label1) encloses 2exp1 in a labeled box.  2label1 is a name which will be truncated in display  if it is too long.  Simplification will occur within and outside of a BOXed expression but simplifications which require interactions across the box boundary will not take place.


$var<BOXCHAR/""> - is the character used to draw the box in this and in the DPART and
LPART functions.
.endfunction

.function(DPART,|exp, n1, ..., nk|)
selects the same subexpression as PART, but instead of just returning that
subexpression as its value, it returns the whole expression with the selected
subexpression displayed inside a box.  The box is actually part of the expression.

.example group
(C1) DPART(X+Y/Z**2,1,2,1);

                       Y
(D1)                  ---- + X
                         2
                     """""
                     " Z "
                     """""

.end
.endfunction

.function(LPART,|label, exp, n1, ..., nk|)
is similar to DPART but uses a labeled box. A labeled box is similar to the one
produced by DPART but it has a name in the top line.

.endfunction

.function(REMBOX,|exp, arg|)
removes boxes from 2exp1 according to 2arg1.  If 2arg1 is $var<UNLABELED/> then all
unlabeled boxes are removed.  If 2arg1 is the name of some label then only boxes with
that label are removed.  If 2arg1 is omitted then all boxes labeled and unlabeled
are removed.

.endfunction
.subsec (The Substitution Functions,substfuns)

.function(SUBST,|a, b, c|)
substitutes 2a1 for all occurrences of 2b1 in 2c1.  2b1 must be an atom or a complete
subexpression of 2c1.  For example, X+Y+Z is a complete subexpression of
2*(X+Y+Z)/W while X+Y is not. When 2b1 does not have these characteristics,
one may sometimes use SUBSTPART or RATSUBST (see below).  Alternatively, if
2b1 is of the form e/f then one could use SUBST(a*f,e,c) while if 2b1 is of
the form e**(1/f) then one could use SUBST(a**f,e,c).   The SUBST command also discerns the X^Y  in X^(-Y) so that SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.
.skip
2a1 and 2b1 may also be operators of an expression (enclosed in "s) or they may be function names.  If one wishes to substitute for the independent variable in derivative forms then the AT function (see below) should be used.

SUBST(2eq1,exp1) or SUBST([2eq11,...,2eqk1],2exp1) are other permissible
forms. The 2eqi1 are equations indicating substitutions to be made.  For each
equation, the right side will be substituted for the left in the expression
2exp1.

For expressions in CRE representation $see<rep>, SUBST, like many of MACSYMA's general simplification commands, works on the RATDISREPed form of the expression.

$var<DERIVSUBST/FALSE> if TRUE permits substitutions such as
SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2)); to return 'DIFF(X,T).

$var<EXPTSUBST/FALSE> if TRUE permits substitutions such as Y for %E**X in %E**(A*X) to
take place.

$var<OPSUBST/TRUE> if FALSE, SUBST will not attempt to
substitute into the operator of an expression.  E.g. (OPSUBST:FALSE,
SUBST(X^2,R,R+R[0])); will work.

.example
(C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
.begin group
                                 2
(D1)                    Y + X + A
.end

(C2) SUBST(-%I,%I,A+B*%I);
(D2)                             A - %I B

.begin group fill indent 0,0
1(Note that C2 is one way of obtaining
the complex conjugate of an analytic expression.)  The following
examples illustrate the difference between substitution (as performed
by SUBST) and binding (as performed by $fun<EV>).
.end

(C3) %PI*R,%PI:-%I;
%PI improper value assignment

(C4) SUBST(X=0,DIFF(SIN(X),X));

(D4)                           1

(C5) DIFF(SIN(X),X),X=0;
0
attempt to differentiate wrt a number

.BEGIN GROUP

(C6) MATRIX([A,B],[C,D]);
				[ A  B ]
(D6)                            [      ]
				[ C  D ]

(C8) SUBST("[",MATRIX,%);
(D8)                        [[A, B], [C, D]]
.END

.end
.endfunction

.function(RATSUBST,|a, b, c|)
substitutes 2a1 for 2b1 in 2c1.  2b1 may be a sum, product, power, etc. 
RATSUBST knows something of the meaning of expressions whereas SUBST does a
purely syntactic substitution.  Thus SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas
RATSUBST would return Z+A.


$var<RADSUBSTFLAG/FALSE> if TRUE permits substitutions such as U for SQRT(X) in X.

.example 
.begin group
(C1) RATSUBST(A,X*Y^2,X^4*Y^8+X^4*Y^3);

                  3      4
(D1)           A X  Y + A
.end

(C2) 1 + COS(X) + COS(X)^2 + COS(X)^3 + COS(X)^4;
.begin group
	    4	      3	        2
(D2)	 COS (X) + COS (X) + COS (X) + COS(X) + 1
.end

(C3) RATSUBST(1-SIN(X)^2,COS(X)^2,%);
.begin group
	    4		          2 	       2
(D3)     SIN (X) + COS(X) (2 - SIN (X)) - 3 SIN (X) + 3
.end

.end
.endfunction

.function(LRATSUBST,|list,exp|)
is analogous to SUBST(2list_of_equations,exp1)
except that it uses RATSUBST instead of SUBST.  The first argument of
LRATSUBST must be an equation or a list of equations identical in
format to that accepted by SUBST (see above).  The
substitutions are made in the order given by the list of equations,
that is, from left to right.
.example
(C1) LRATSUBST([A^2=B,C^2=D],(A+E)*C*(A+C));
(D1) 			   (D + A C) E + A D + B C

(C2) LRATSUBST(A^2=B,A^3);
(D2) 				     A B
.end
.endfunction

.function(FULLRATSUBST,|a,b,c|)
is the same as RATSUBST except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.
FULLRATSUBST will also accept its arguments in the format of
LRATSUBST.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.
.example
(C1) RATSUBST(B*A,A^2,A^3);
				      2
(D1) 				     A  B

(C2) FULLRATSUBST(B*A,A^2,A^3);
					2
(D2) 				     A B

(C3) FULLRATSUBST([A^2=B,B^2=C,C^2=A],A^3*B*C);
(D3) 				      B

(C4) FULLRATSUBST(A^2=B*A,A^3);
					2
(D4) 				     A B
.end
Since FULLRATSUBST goes over the expression recursively, care should
be taken lest infinite recursion cause the calculation to err out with
"REGPDL overflow".
.endfunction

.function(SUBSTPART,|x, exp, n1, ..., nk|)
substitutes 2x1 for the subexpression picked out by the rest of the arguments as in
PART.  It returns the new value of 2exp1. 
.bcon
2x1 may be some operator to be
substituted for an operator of 2exp1.  In this case it is enclosed in "s.

.example
(C1) 1/(X^2+2);
.begin group
                                    1
(D1)                              ------
                                   2
                                  X  + 2
.end

(C2) SUBSTPART(3/2,%,2,1,2);
.begin group
                                    1
(D2)                             --------
                                  3/2
                                 X    + 2
.end

(C3) A*X+F(B,Y);
(D3)                          A X + F(B, Y)

(C4) SUBSTPART("+",%,1,0);
(D4)                         X + F(B, Y) + A

(C5) X^2 + X + 1$

(C6) SUBSTPART("[",%,0);
				    2
(D6) 				  [X , X, 1]


.end
.endfunction

.function(SUBSTINPART,|x, exp, n1, ...|)
is like SUBSTPART but works on the internal representation of 2exp1.

.example
(C1) X.'DIFF(F(X),X,2);
.begin group
                                   2
                                  d
(D1)                         X . (--- F(X))
                                    2
                                  dX
.end

(C2) SUBSTINPART(D^2,%,2);
.begin group
                                      2
(D2)                             X . D
.end

(C3) SUBSTINPART(F1,F[1](X+1),0);

(D3)                            F1(X + 1)

.end
.endfunction

.function(SUBLIS,|list,expr|)
allows multiple substitutions into an expression in parallel.
SUBLIS([2sym1 = exp1 , sym2 = exp2 , ...1], 2form1); Substitutes
for each occurrence of 2symi1 in form the appropriate 2expi1.  A
2sym1 MUST be a symbol.  An 2exp1 may be any expression.  2Form1
may be any expression. The new expression, with appropriate
substitutions made, is the value returned.

$var<SUBLIS_APPLY_LAMBDA/TRUE> controls whether LAMBDA's 
substituted are applied in simplification after the SUBLIS or whether you 
have to do an EV to get things to apply. TRUE means do the application.

SUBLIS will preserve sharing where possible. eg, SUBLIS([A=B],C+D);
returns a pointer to the original C+D since no substitution is needed.
SUBLIS does substitutions in parallel. eg, SUBLIS([A=B,B=A],SIN(A)+COS(B)); 
returns SIN(B)+COS(A).
SUBLIS will preserve CRE form, too. eg, 
.example

(C1) RAT(X^3+A*X+B)$
(C2) SUBLIS([A=B,B=A],%);
			          3
(D2)	                 => /R/  X  + B X + A
.end continue
If a form is in CRE form, RATDISREP is called on it,
the substitution is done and if there is no change, the
original CRE form is returned; if there was a change, RAT is called
on the result of the substitution to return the CRE form.
.endfunction
.skip 3;
.begin group
.once center
2Additional1 2Information1

.skip 1
If the last argument to a Part function is a list of indices then several
subexpressions are picked out, each one corresponding to an index of the list.  Thus
PART(X+Y+Z,[1,3]) is Z+X.

$var<PIECE/> holds the last expression selected when using the Part functions.
It is set during the execution of the function and thus may be referred to in the
function itself as shown below.

If $var<PARTSWITCH/FALSE> is set to TRUE then END is returned when a selected
part of an expression doesn't exist, otherwise an error message is given.
.end

.example
(C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;

.begin group
            3         2       2            3
(D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1
.end

(C2)  PART(D1,2,[1,3]);

.begin group
                  2
(D2)          54 Y
.end

(C3)  SQRT(PIECE/54);

(D3)            Y

(C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);

.begin group
                          3
(D4)           (3 Y + 2 X) + Y + X + 1
.end

(C5) 1/X+Y/X-1/Z;
.begin group
                                 1   Y   1
(D5)                           - - + - + -
                                 Z   X   X
.end

(C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);

.begin group
                                Y + 1   1
(D6)                            ----- - -
                                  X     Z
.end

.end

.function(ATVALUE,|form, list, value|)
enables the user to assign the boundary value 2value1 to 2form1 at the points specified by 2list1.

.example
(C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$
.end

The 2form1 must be a function, f(v1,v2,...) , or a derivative, DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional arguments explicitly appear  (ni is the order of differentiation with respect vi).

The 2list1 of equations determine the "boundary" at which the 2value1 is given; 2list1 may be a list of equations, as above, or a single equation,  vi = exp.

The symbols @1, @2,... will be used to represent the functional variables v1,v2,... when atvalues are displayed.

PRINTPROPS([2f1, f2,*...], ATVALUE)
will display the atvalues of the functions 2f1,f21,... as specified in previously
given uses of the ATVALUE function. $see<MACSYMA!properties>  If the list contains just one
element then the element can be given without being in a list.  If a first argument
of ALL is given then atvalues for all functions which have them will be displayed.

.endfunction

.function(AT,|exp, list|)
will evaluate 2exp1 (which may be any expression) with the variables assuming
the values as specified for them in the 2list1 of equations or the single
equation similar to that given to the ATVALUE function.  If a subexpression
depends on any of the variables in 2list1 but it hasn't had an atvalue
specified and it can't be evaluated then a noun form of the AT will be returned
which will display in a two-dimensional form.

.example
(C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2);

.begin group
                                     2
(D1)                                A
.end

(C2) ATVALUE('DIFF(F(X,Y),X),X=0,Y+1);

(D2)                              @2 + 1

(C3) PRINTPROPS(ALL,ATVALUE);
.begin group
                                  !
                      D           !
                     --- F(@1, @2)!       = @2 + 1
                     D@1          !
                                  !@1 = 0

                                        2
                             F(0, 1) = A
.end

(D3)                               DONE

(C4) DIFF(4*F(X,Y)**2-U(X,Y)**2,X);

.begin group
                   d                        d
(D4)    8 F(X, Y) (-- F(X, Y)) - 2 U(X, Y) (-- U(X, Y))
                   dX                       dX
.end

(C5) AT(%,[X=0,Y=1]);
.begin group
                                         !
               2               d         !
(D5)       16 A  - 2 U(0, 1) ( -- U(X, Y)!            )
                               dX        !
                                         !X = 0, Y = 1
.end
.end
.endfunction

.subsec (More Functions for Part Extraction,extracting!expressions)

.function(LISTOFVARS,exp)
yields a list of the variables in 2exp1.


$var<LISTCONSTVARS/FALSE> if TRUE will cause LISTOFVARS to include %E, %PI, %I,
and any variables declared constant $see<property!specification> in the list it returns if they
appear in 2exp1.  The default is to omit these.

.example group
(C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));

(D1)                            [X[1], Y, A, G]

.end
.endfunction

.function(COEFF,|exp, v, n|)
obtains the coefficient of 2v1**2n1 in 2exp1.  2n1 may be
omitted if it is 1.  2v1 may be an atom, or complete subexpression
of 2exp1 e.g., X, SIN(X), A[I+1], X+Y, etc. (In the last case the
expression (X+Y) should occur in 2exp1).  For example, X+Y is a
complete subexpression of (X+Y)*(C+D+E) but C+D is not.  Similarly,
X*Y is a complete subexpression of X*Y + C*D*E, but C*D is not.
Sometimes it may be necessary to expand or factor 2exp1 in order to
make 2v^n1 explicit.  This is not done automatically by COEFF.
(Also see the RATCOEF command.)

.example group
(C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));

(D1)                         2 A + 1 = 5

(C2) COEFF(Y+X*%E**X+1,X,0);
(D2)                            Y + 1

.end
.endfunction

.function(RATCOEF,|exp, v, n|)
returns the coefficient, C, of the expression 2v1^2n1 in the
expression 2exp1.  2n1 may be omitted if it is 1.  C will be free
(except possibly in a non-rational sense) of the variables in 2v1.
If no coefficient of this type exists, zero will be returned.  RATCOEF
expands and rationally simplifies its first argument and thus it may
produce answers different from those of COEFF which is purely
syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas COEFF
returns 1.  RATCOEF(2exp,v1,0), viewing 2exp1 as a sum, gives a
sum of those terms which do not contain 2v1.  If 2v1 occurs to any
negative powers, RATCOEF should not be used.  Since 2exp1 is
rationally simplified before it is examined, coefficients may not
appear quite the way they were envisioned.

.example group
(C1) S:A*X+B*X+5$

(C2) RATCOEF(S,A+B);

(D2)                               X

.end
.endfunction

.function(BOTHCOEF,|exp, var|)
returns a list whose first member is the coefficient of 2var1 in 2exp1 (as found by
RATCOEF if 2exp1 is in CRE form otherwise by COEFF) and whose second member is
the remaining part of 2exp1.  That is, [A,B] where 2exp1=A*2var1+B.

.example group
(C1) ISLINEAR(EXP,VAR):=BLOCK([C],
	C:BOTHCOEF(RAT(EXP,VAR),VAR),
        IS(FREEOF(VAR,C) AND C[1]#0))$

(C2) ISLINEAR((R**2-(X-R)**2)/X,X);

(D2)                              TRUE

.end
.endfunction

.function(ISOLATE,|exp, var|)
returns 2exp1 with subexpressions which are sums and which do not contain
2var1 replaced by intermediate expression labels (these being atomic symbols
like E1, E2, ...). This is often useful to avoid unnecessary expansion of
subexpressions which don't contain the variable of interest.  Since the
intermediate labels are bound to the subexpressions they can all be substituted
back by evaluating the expression in which they occur.
(See also the $fun<DISOLATE> function in the SHARE directory.)

$var<EXPTISOLATE/FALSE> if TRUE will cause ISOLATE to examine exponents of
atoms (like %E) which contain 2var1.

.example
(C1) (A+B)^4*(1+X*(2*X+(C+D)^2));

.begin group
			   4                  2
(D1)                (B + A)  (X (2 X + (D + C) ) + 1)
.end

(C2) ISOLATE(%,X);

.begin group
					2
(E2)                             (D + C)
.end

.begin group
					4
(E3)                             (B + A)
.end

(D3)                      E3 (X (2 X + E2) + 1)

(C4) RATEXPAND(D3)$

(C5) EV(%);

.begin group
	       4  2          4        2            4
(D5)  2 (B + A)  X  + (B + A)  (D + C)  X + (B + A)
.end

(C6) (A+B)*(X+A+B)^2*EXP(X^2+A*X+B);
.begin group
					   2
				      2   X  + A X + B
(D6)               (B + A) (X + B + A)  %E
.end

(C7) ISOLATE(%,X),EXPTISOLATE:TRUE;

(E7)                              B + A

.begin group
				     B
(E8)                               %E
.end

.begin group
					   2
				      2   X  + A X
(D8)                    E7 E8 (X + E7)  %E

.end

.end
.endfunction

$var<ISOLATE_WRT_TIMES/FALSE> if set to TRUE, then ISOLATE
will also isolate wrt products.  E.g. compare both settings of the
switch on ISOLATE(EXPAND((A+B+C)^2),C); .

.function(PICKAPART,|exp,depth|)
will assign E labels to all subexpressions of 2exp1 down to the specified integer 2depth1. 
This is useful for dealing with large expressions and for automatically
assigning parts of an expression to a variable without having to use the Part
functions.

.EXAMPLE
(C1) INTEGRATE(1/(X^3+2),X)$

.BEGIN GROUP
(C2) PICKAPART(D1,1);

				       1/3
			      LOG(X + 2   )
(E2)                          -------------
				    2/3
				 3 2
.END
.BEGIN GROUP

					 1/3
				  2 X - 2
			    ATAN(------------)
				  1/3
				 2    SQRT(3)
(E3)                        ------------------
				2/3
			       2    SQRT(3)
.END
.BEGIN GROUP


			       2    1/3      2/3
			  LOG(X  - 2    X + 2   )
(E4)                    - -----------------------
				     2/3
				  6 2

(D4)                         E4 + E3 + E2
.END
.END
.endfunction

.function (REVEAL,|exp,depth|)
will display 2exp1 to the specified integer 2depth1 with
the length of each part indicated.  Sums will be displayed as
SUM(n) and products as PRODUCT(n) where n is the
number of subparts of the sum or product.  Exponentials will
be displayed as EXPT.

.EXAMPLE

(C1) INTEGRATE(1/(X^3+2),X)$

(C2) REVEAL(%,2);
(D2)              PRODUCT(3) + PRODUCT(3) + PRODUCT(3)

.BEGIN GROUP
(C3) REVEAL(D1,3);
		    EXPT LOG                    EXPT LOG
(D3)              - -------- + EXPT EXPT ATAN + --------
		       6                           3

.END
.END
.endfunction

.function(NUMFACTOR,exp)
gives the numerical factor multiplying the expression 2exp1 which should be a
single term.  If the gcd of all the  term coefficients  in a sum is desired the CONTENT function $see<rational!functions> may be used.

.example
(C1) GAMMA(7/2);

.begin group
(D1)               15 SQRT(%PI)
                   ------------
                        8
.end

(C2) NUMFACTOR(%)
.begin group
                    15
(D2)                --
                     8
.end

.end
.endfunction

.function(HIPOW,|exp, v|)
gives the highest explicit exponent of 2v1 in 2exp1.  Sometimes it may be necessary
to expand 2exp1 since this is not done automatically by HIPOW.  Thus
HIPOW(Y**3*X**2+X*Y**4,X) is 2.

.endfunction

.function(LOPOW,|exp, v|)
gives the lowest exponent of 2v1 which explicitly appears in 2exp1.  Thus
LOPOW((X+Y)**2+(X+Y)**A,X+Y) is MIN(A,2).

.endfunction

.function(DERIVDEGREE,|exp, dv, iv|)
finds the highest degree of the derivative of the dependent
variable 2dv1 with respect to the independent variable 2iv1 occurring in 2exp1.

.example group
(C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
(C2) DERIVDEGREE(%,Y,X);
(D2)                           2

.end
.endfunction

.function(LHS,eqn)
returns the left side of the equation 2eqn1.  If 2eqn1 is not an equation, then LHS(2eqn1) = 2eqn1.

.endfunction

.function(RHS,eqn)
returns the right side of the equation 2eqn1.  If 2eqn1 is not an equation, then RHS(2eqn1) = 0.

.endfunction

.function(NUM,exp)
obtains the numerator, exp1, of the rational expression 2exp1 = exp1/exp2.

.endfunction

.function(DENOM,exp)
returns the denominator, exp2, of the rational expression 2exp1 = exp1/exp2.

.endfunction

The above two commands do not alter the internal representations of expressions and have the desirable property that for all expressions  NUM(exp)/DENOM(exp) is the same as exp.

.function(FIRST,exp)
yields the first part of 2exp1 which may result in the first element
of a list, the first row of a matrix, the first term of a sum, etc.  Note that FIRST and
the following two functions work on the form of 2exp1 which is displayed not the form
which is typed on input.  If the variable $var<INFLAG/FALSE> is set to TRUE however, these
functions will look at the internal form of 2exp1.  Note
that the simplifier re-orders expressions $see<simp>.  Thus FIRST(X+Y) will be X if
INFLAG is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same results).

.endfunction

.function(REST,|exp, n|)
yields 2exp1 with its first 2n1 elements removed if 2n1 is
positive and its last 2-n1 elements removed if 2n1 is negative.  If 2n1 is 1 it
may be omitted.  2Exp1 may be a list, matrix, or other expression.
If INFLAG:TRUE the internal form of 2exp1 will be used.
.endfunction

.function(LAST,exp)
yields the last part (term, row, element, etc.) of the 2exp1.
If INFLAG:TRUE the internal form of 2exp1 will be used.

.endfunction

.function(DELETE,|exp1, exp2|)
removes all occurrences of 2exp11 from 2exp21.  2Exp11 may
be a term of 2exp21 (if it is a sum) or a factor of 2exp21 (if it is a product).

.example group
(C1)  DELETE(SIN(X),X+SIN(X)+Y);

(D1)               Y + X

.end
.endfunction
.function(DELETE,|exp1, exp2, integer|)
removes the first 2integer1 occurrences of 2exp11 from 2exp21.
Of course, if there are fewer than 2integer1 occurrences of 2exp11
in 2exp21 then all occurrences will be deleted.
.endfunction
.function(LENGTH,exp)
gives the number of parts in the internal form of 2exp1.  For lists
this is the number of elements, for matrices it is the number of rows, and for sums it
is the number of terms.  However for products it may not always yield the number of
factors that would be displayed because of the fact that -E is represented internally
as -1*E and A/B is represented internally by A*B^(-1).  (cf.  DISPFORM)

.endfunction

.function(NTERMS,exp)
gives the number of terms that 2exp1 would have if it were fully
expanded out and no cancellations or combinations of terms occurred. Note that expressions
like SIN(E), SQRT(E), EXP(E), etc. count as just one term regardless of how many terms E has
(if it is a sum).

.endfunction

.subsec(Dealing with Complex Variables,complex!variables) 

The next several functions deal with complex variables.  The user should note the following conventions used in MACSYMA.

.begin indent 8,5; single space
1) all variables are assumed to take on real values exclusively unless
they are DECLAREd to be COMPLEX;

2) all functions are assumed to be real-valued unless they are
DECLAREd to be COMPLEX;

3) the complex argument is maintained in the half-open interval
(-6p1,6p1] whenever possible;

4) the argument of 0 is (arbitrarily) assumed to be 0, although
normally the user need not worry about this, since 0*%E^(%I*0) is
simplified to 0;

5) trigonometric functions are normally assumed to take on their
principal values.

.end

.function(REALPART,exp)
gives the real part of 2exp1. REALPART and IMAGPART will work on
expressions involving trigonometric and hyperbolic functions, as well as SQRT, LOG, and
exponentiation.

.endfunction

.function(IMAGPART,exp)
returns the imaginary part of the expression 2exp1.

.endfunction


The real or imaginary part of an expression of the form Z^N, where Z is not purely real, will be algebraic if  n <= MAXPOSEX; otherwise, for compactness,it will be expressed as ABS(Z)^N * COS(N*ARG Z)  or  ABS(Z)^N * SIN(N*ARG Z).

.function(RECTFORM,exp)
returns an expression of the form  A + B*%I, where A and B are purely real.

.endfunction

.function(POLARFORM,exp)
returns  R*%E^(%I*THETA) where R and THETA are purely real.

.endfunction

CAVEAT: Simplification of algebraic and transcendental functions of a complex variable may give rise to apparent factors, %I.  For example, SQRT(-C+D) may be transformed to %I*SQRT(C-D).

.function(CABS,exp) 
returns the complex absolute value (the complex modulus) of 2exp1.
.endfunction

.function(CARG,exp)
returns the argument (phase angle) of  2exp1.   Due to the conventions and restrictions (described above),  principal value cannot be guaranteed.
.endfunction

.example

(C1) RECTFORM(SIN(2*%I+X));

(D1) 		    COSH(2) SIN(X) + %I SINH(2) COS(X)

(C2) POLARFORM(%);
.begin group
	      2	      2		 2	 2
(D2) SQRT(COSH (2) SIN (X) + SINH (2) COS (X))

		      %I ATAN2(SINH(2) COS(X), COSH(2) SIN(X))
		    %E
.end
(C3) RECTFORM(LOG(3+4*%I));
.begin group

(D3) 			   LOG(5) + %I ATAN2(4,3)
.end
(C4) POLARFORM(%);
.begin group

					 
				 
	      2		  2          %I ATAN2(ATAN2(4, 3), LOG(5))
(D4)  SQRT(LOG (5) + ATAN2 (4, 3)) %E
			   
.end
(C5) RECTFORM((2+3.5*%I)^.25),NUMER;

(D5) 		        0.36825881 %I + 1.36826627

(C6) POLARFORM(D5);
.begin group
				    0.26291253 %I
(D6) 			 1.416957 %E

.end
.end


.next page
