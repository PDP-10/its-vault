.<<(c) Copyright 1983 Massachusetts Institute of Technology>>
.chap (MACSYMA Functions and Variables,Mfunctions)

Following is a list of all MACSYMA functions divided into functional classes.
MACSYMA variables which affect the operation of some functions are described under the
appropriate function with their default value in brackets.  These are sometimes
referred to as MACSYMA options.

.sec (General Purpose Functions,general!functions)

.subsec (Evaluation and Simplification Functions,evsimpfun)

.function(EV,|exp, arg1, ..., argn|)
is one of MACSYMA's most powerful and versatile commands. It evaluates the expression 2exp1 in the environment
specified by the 2argi1.  This is done in steps, as follows:

.skip 1
(1) First the environment is set up by scanning the 2argi1 which may be as follows:

$flag<SIMP> causes 2exp1 to be simplified regardless of the setting of the switch SIMP
which inhibits simplification if FALSE.

$flag<NOEVAL> suppresses the evaluation phase of EV (see step (4) below).  This is
useful in conjunction with the other switches and in causing 2exp1 to be
resimplified without being reevaluated.

$flag<EVAL> causes an extra post-evaluation of 2exp1 to occur. (See step (5) below.)

$flag<INFEVAL> leads to an "infinite evaluation" mode.  EV repeatedly evaluates an expression until it stops changing.    To prevent a variable, say X, from being evaluated away in this mode, simply include X='X as an argument to EV.   Of course expressions such as EV(X,X=X+1,INFEVAL); will generate an infinite loop.  2CAVEAT EVALUATOR*.

$flag<EXPAND> causes expansion.

EXPAND(2m,n1) causes expansion, setting the values of MAXPOSEX and MAXNEGEX to
2m1 and 2n1 respectively. (see the EXPAND function below)

$flag<DETOUT> causes any matrix inverses computed in 2exp1 to have their
determinant kept outside of the inverse rather than dividing through each
element.

$flag<DIFF> causes all differentiations indicated in 2exp1 to be performed.
(see the DIFF function below.)

$flag<DERIVLIST>(2var11,...,2vark1) causes only differentiations with respect to
the indicated variables.

$flag<FLOAT> causes non-integral rational numbers and bigfloats to be converted to floating point.

$flag<NUMER> causes some mathematical functions (including
exponentiation) with numerical arguments to be evaluated in floating
point $see<Simple!Functions>. It causes variables in 2exp1 which
have been given numervals $see<uspropfun> to be replaced by their
values.  It also sets the FLOAT switch on.

$flag<PRED> causes predicates, which are expressions that evaluate to
TRUE or FALSE, to be evaluated.

$flag<NOUNS> converts all nouns occurring in 2exp1 to verbs.

E where E is an atom declared to be an $var<EVFLAG/>
$see<MACSYMA!properties> causes E to be bound to TRUE during the
evaluation of 2exp1.

2V:expression* (or alternatively 2V=expression*) causes 2V* to
be bound to the value of 2expression* during the evaluation of
2exp*.  Note that if 2V* is a MACSYMA option, then 2expression*
is used for its value during the evaluation of 2exp*.  If more than
one argument to EV is of this type then the binding is done in
parallel.  If 2V* is a non-atomic expression then a substitution
rather than a binding is performed.

E where E is a function name declared to be an EVFUN $see<property!specification>  causes E to be applied to 2exp*.

Any other function names (e.g. SUM) cause evaluation of occurrences of those
names in 2exp* as though they were verbs $see<evaluation>.

In addition a function occurring in 2exp1 (say F(args)) may be
defined locally for the purpose of this evaluation of 2exp1 by
giving F(args):=body as an argument to EV.

If an atom not mentioned above or a subscripted variable or
subscripted expression is given as an argument, it is evaluated, and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to EV. This permits a list of equations to be given (e.g. [X=1,
Y=A**2] ) or a list of names of equations (e.g. [E1,E2] where E1 and
E2 are equations) such as that returned by $fun<SOLVE>. $see<SOLVE>

The 2argi1 of EV usually may be given in any order, but since they
are picked up left to right the order may influence the result.  This
is strictly true of substitution equations which are handled in
sequence, left to right, and EVFUNS which are composed, e.g.
EV(2exp1,RATSIMP,RECTFORM) is handled as RECTFORM(RATSIMP(2exp1)).
The SIMP, NUMER, FLOAT, PRED, and INFEVAL switches may also be set
locally in a block, or globally at the "top level" in MACSYMA so that
they will remain in effect until being reset.  Setting INFEVAL:TRUE
locally will cause all evaluations occurring via explicit calls to EV
to be done "infinitely".

If 2exp1 is in CRE form $see<rep> then EV will return a result in CRE form provided
the NUMER and FLOAT switches are both FALSE.

(2) During step (1), a list is made of the non-subscripted variables
appearing on the left side of equations in the 2argi1 or in the
value of some 2argi1 if the value is an equation.  The variables,
including subscripted variables, in the expression 2exp1 are
replaced by their global values, except for those appearing in this
list.  Usually, 2exp1 is just a label or %, as in (C2) below, so
this step simply retrieves the expression named by the label, so that
EV may work on it.

(3) If any substitutions are indicated by the 2argi1, they are carried out now.
.begin turn on ""
(4) The resulting expression is then re-evaluated (unless one of the 2argi1 is NOEVAL) and simplified according the the
2argi1.  Note that any function calls in 2exp1 will be
carried out after the variables in it are evaluated and that
EV(F(X)) thus may behave like F(EV(X)).
.end
(5) If one of the 2argi1 is EVAL, steps (3) and (4) are repeated.

.example
.begin group
.once center
2Examples1

(C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
.end
.begin group
                            d                 2
(D1)      COS(Y) + SIN(X) + --SIN(W) + (W + 1)
                            dW
.end
(C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
.begin group
                    2
(D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742
.end
.end

An alternate "top level" syntax has been provided for EV, whereby one
may just type in its arguments, without the EV().  That is, one may
write simply 2exp,arg11,...,2argn1.  This is not permitted as part
of another expression, i.e. in functions, blocks, etc.
2exp,RESCAN1 is equivalent to EV(2exp1).


.example
(C4) X+Y,X:A+Y,Y:2;
(D4)                Y + A + 2

1Notice the parallel binding process.*

(C5) 2*X-3*Y=3$

(C6) -3*X+2*Y=-4$

(C7) SOLVE([D5,D6]);
solution
.begin group
                              1       6
(D7)                 [ Y =  - - , X = - ]
                              5       5
.end

(C8) D6,D7;
(D8)               - 4 =  - 4

(C9) X+1/X > GAMMA(1/2);

.begin group
                    1
(D9)           X + - > SQRT(%PI)
                    X
.end

(C10) %,NUMER,X=1/2;

(D10)            2.5 > 1.7724539

(C11) %,PRED;
(D11)                  TRUE

.end
.endfunction


.function(UNKNOWN,exp)
returns  TRUE   iff  2exp*  contains an operator or function not known to the built-in simplifier.
.endfunction

.function(EXPAND,exp)
causes products of sums and exponentiated sums to be multiplied out,
numerators of rational expressions that are sums to be split into
their respective terms, and multiplication, both commutative and
non-commutative, to be distributed over addition at all levels of
2exp1.  For polynomials one may wish use RATEXPAND, which uses a more
efficient algorithm (see below).


Terms in 2exp1 whose exponents are less than $var<MAXNEGEX/1000> or
greater than $var<MAXPOSEX/1000> will not be EXPANDed.  However,

EXPAND(2exp,p,n1) expands 2exp1, using 2p1 for MAXPOSEX and
2n1 for MAXNEGEX.  This helps the user control how much and what
kinds of expansion are to take place.

$var<EXPON/0> - the exponent of the largest negative power that is
automatically expanded, independent of calls to EXPAND.  For example
if EXPON is 4 then (X+1)**(-5) will not be automatically expanded.

$var<EXPOP/0> - the highest positive exponent that is automatically
expanded.  Thus (X+1)**3, when typed, will be automatically expanded
only if EXPOP is greater than or equal to 3.  If it is desired to have
(X+1)**n expanded where n is greater than EXPOP then executing
EXPAND((X+1)**n) will work only if MAXPOSEX is not less than n.



.example
(C1) (1/(X+Y)**4-3/(Y+Z)**3)**2;

.begin group
                              1          3     2
(D1)                      (-------- - --------)
                                  4          3
                           (Y + X)    (Z + Y)
.end

(C2) EXPAND(%,2,0);

.begin group
                           6              9          1
(D2)             - ----------------- + -------- + --------
                          4        3          6          8
                   (Y + X)  (Z + Y)    (Z + Y)    (Y + X)
.end

(C3) EXPAND(A.(B+C.(D+E)+F));

(D3)            A . F + A . C . E + A . C . D + A . B

.end
.endfunction

.function(RATEXPAND,exp)
expands 2exp1 by multiplying out products of sums and exponentiated
sums, combining fractions over a common denominator, cancelling the
greatest common divisor of the numerator and denominator, then
splitting the numerator, if it is a sum, into its respective terms
divided by the denominator.  This is accomplished by converting
2exp1 to CRE form $see<rep> and then back to general form.


$var<RATEXPAND/FALSE> - if TRUE will cause CRE expressions to be fully
expanded when they are converted back to general form or displayed,
while if it is FALSE then they will be put into a recursive form. (see
RATSIMP below)

$var<RATDENOMDIVIDE/TRUE> - if FALSE will prevent the splitting of the
terms of the numerator of RATEXPANDed expressions from occurring.

$var<KEEPFLOAT/FALSE> if set to TRUE will prevent floating point numbers from being
rationalized when expressions that contain them are converted to CRE form.

$var<GCD/SPMOD> if FALSE will prevent the greatest common divisor from
being taken when expressions are converted to CRE form.  This will
sometimes speed the calculation if gcds are not required. (cf. the
function GCD in $ref<rational!functions>)

.example
(C1) RATEXPAND((2*X-3*Y)**3);

.begin group
                3         2       2        3
(D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X

(C2) (X-1)/(X+1)**2+1/(X-1);
.end

.begin group
                              X - 1       1
(D2)                         -------- + -----
                                    2   X - 1
                             (X + 1)
.end

(C3) EXPAND(D2);

.begin group
                         X              1           1
(D3)                ------------ - ------------ + -----
                     2              2             X - 1
                    X  + 2 X + 1   X  + 2 X + 1
.end

(C4) RATEXPAND(D2);

.begin group
                             2
                          2 X                 2
(D4)                 --------------- + ---------------
                      3    2            3    2
                     X  + X  - X - 1   X  + X  - X - 1

.end

.end
.endfunction

.function(RATSIMP,exp)
"rationally" simplifies (similar to RATEXPAND) the expression 2exp1
and all of its subexpressions including the arguments to non-rational
functions.  The result is returned as the quotient of two polynomials
in a recursive form, i.e. the coefficients of the main variable are
polynomials in the other variables.  Variables may, as in RATEXPAND,
include non-rational functions (e.g. SIN(X**2+1) ) but with RATSIMP,
the arguments to non-rational functions are rationally simplified.
Note that RATSIMP is affected by some of the variables that affect
RATEXPAND.


$var<RATSIMPEXPONS/FALSE> - if TRUE will cause exponents of expressions to be
RATSIMPed automatically during simplification.
.endfunction

.function(RATSIMP,|exp,v1,...,vn|)
enables rational simplification with the specification of variable
ordering as in RATVARS.

.example
.begin group
(C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);


                                           2          2
                    X          (LOG(X) + 1)  - LOG (X)
(D1)          SIN(------) = %E
                   2
                  X  + X
.end

(C2) RATSIMP(%);
.begin group
                                  1          2
(D2)                        SIN(-----) = %E X
                                X + 1
.end

(C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));

.begin group
                       3/2
                (X - 1)    - SQRT(X - 1) (X + 1)
(D3)            --------------------------------
                    SQRT((X - 1)(X + 1))
.end

(C4) RATSIMP(%);
.begin group
                            2 SQRT(X-1)
(D4)                      - -----------
                                  2
                            SQRT(X - 1)
.end

(C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;

.begin group
                    2
                   A  + 1
                   ------
                     A
(D5)              X
.end

.end
.endfunction

.function(FULLRATSIMP,exp)
When non-rational expressions are involved, one call
to RATSIMP followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.  The command
FULLRATSIMP makes this process convenient.  FULLRATSIMP repeatedly
applies RATSIMP followed by non-rational simplification to an
expression until no further change occurs.  For example, consider
the expression
.example
.begin group
(C1) EXP:(X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1);
                             A/2     2   A/2     2
                           (X    - 1)  (X    + 1)
(D1)                       -----------------------
                                    A
                                   X  - 1
.end

.begin group
(C2) RATSIMP(EXP);
                                2 A      A
                               X    - 2 X  + 1
(D2)                           ---------------
                                    A
                                   X  - 1
.end

.begin group
(C3) FULLRATSIMP(EXP);
                                     A
(D3)                                X  - 1
.end
.end
The problem may be seen by looking at 
RAT(EXP);
.example
.begin group
(C4) RAT(EXP);
                             A/2 4       A/2 2
                           (X   )  - 2 (X   )  + 1
(D4)/R/                    -----------------------
                                    A
                                   X  - 1

.end
.end
.endfunction

.function(FULLRATSIMP,|exp,var1,...,varn|)
takes one or more arguments similar 
to RATSIMP above.
.endfunction

.function(RADCAN,exp)
simplifies 2exp1, which can contain logs, exponentials, and
radicals, by converting it into a form that is canonical over a large
class of expressions and a given ordering of variables; that is, all
functionally equivalent forms are mapped into a unique form.  For a
somewhat larger class of expressions, RADCAN produces a regular form
[Fa2].  Two equivalent expressions in this class will not necessarily
have the same appearance, but their difference will be simplified by
RADCAN to zero.  For some expressions RADCAN can be quite time
consuming.  This is the cost of exploring certain relationships among
the components of the expression for simplifications based on
factoring and partial-fraction expansions of exponents.  (Because
exploring all types of simplifications in which nested radicals can
participate is very expensive, RADCAN will sometimes fail to discover
simplied forms.  E.g. RADCAN is not able to reduce the expression
SQRT(EXPAND((1+SQRT(X))^2))-(1+SQRT(X)) to 0 where X 7>1 0.)  The
variable $var<%E_TO_NUMLOG/FALSE> may be useful also,
$see<miscellaneous!functions>.


$var<RADEXPAND/TRUE> when set to FALSE will inhibit certain
transformations: RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not
become %I SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X
+ 1) and will not be transformed to X-1.  Another way to get this
result is to set $var<DOMAIN/REAL> to COMPLEX.  The notion of a
"domain" of simplification is still in its infancy, and controls
little more than this at the moment.  This can be overridden by
setting RADEXPAND to ALL irrespective of the setting of DOMAIN.

 
.example
(C1) (LOG(X**2+X)-LOG(X))**A/LOG(X+1)**(A/2);

.begin group
                          2               A
                    (LOG(X  + X) - LOG(X))
(D1)                -----------------------
                                   A/2
                         LOG(X + 1)
.end

(C2) RADCAN(%);
.begin group
                               A/2
(D2)                 LOG(X + 1)
.end

(C3) LOG(A**(2*X)+2*A**X+1)/LOG(A**X+1);

.begin group
                   2 X      X
              LOG(A    + 2 A  + 1)
(D3)          --------------------
                       X
                  LOG(A  + 1)
.end

(C4) RADCAN(%);
(D4)                  2

(C5) (%E**X-1)/(%E**(X/2)+1);

.begin group
                       X
                     %E  - 1
(D5)                ---------
                      X/2
                    %E    + 1
.end

(C6) RADCAN(%);

.begin group
                      X/2
(D6)                %E    - 1
.end

.end

.endfunction

.function(SCSIMP,|exp,rule1, rule2,...,rulen|)
(Sequential Comparative Simplification) takes an expression (its first
argument) and a set of identities, or rules (its other arguments) and
tries simplifying.  If a smaller expression is obtained, the process
repeats.  Otherwise after all simplifications are tried, it returns
2exp*.
.example
(C1) EXP:K^2*N^2+K^2*M^2*N^2-K^2*L^2*N^2-K^2*L^2*M^2*N^2;
.begin group
                    2  2  2  2    2  2  2    2  2  2    2  2
(D1)             - K  L  M  N  + K  M  N  - K  L  N  + K  N
.end

(C2) EQ1:K^2+L^2=1;
.begin group
                                  2    2
(D2)                             L  + K  = 1
.end

(C3) EQ2:N^2-M^2=1;
.begin group
                                  2    2
(D3)                             N  - M  = 1
.end

(C4) SCSIMP(EXP,EQ1,EQ2);

                                     4  4
(D4)                                K  N

(C5) EXQ:(K1*K4-K1*K2-K2*K3)/K3^2;
.begin group
                            K1 K4 - K2 K3 - K1 K2
(D5)                        ---------------------
                                       2
                                     K3
.end

(C6) EQ3:K1*K4-K2*K3=0;
(D6)                          K1 K4 - K2 K3 = 0

(C7) EQ4:K1*K2+K3*K4=0;
(D7)                          K3 K4 + K1 K2 = 0

(C8) SCSIMP(EXQ,EQ3,EQ4);
.begin group
                                      K4
(D8)                                  --
                                      K3
.end end
.endfunction
.function(COMBINE,exp)
simplifies the sum 2exp1 by combining terms with the same denominator into a single term.
.endfunction
.function(RNCOMBINE,exp)
transforms 2exp1 by combining all terms of 2exp1 that have
identical denominators or denominators that differ from each other by
numerical factors only.  This is slightly different from the behavior
of COMBINE, which collects terms that have identical denominators.
Setting PFEFORMAT:TRUE and using COMBINE will achieve results similar
to those that can be obtained with RNCOMBINE, but RNCOMBINE takes the
additional step of cross-multiplying numerical denominator factors.
This results in neater forms, and the possiblity of recognizing some
cancellations.
.endfunction

.function(MULTTHRU,exp)
multiplies a factor (which should be a sum) of 2exp1  by the other factors of
2exp1. That is 2exp1 is f1*f2*...*fn where at least one factor, say fi, is a
sum of terms.  Each term in that sum is multiplied by the other factors in the
product.  (Namely all the factors except fi).  MULTTHRU does not expand
exponentiated sums.  This function is the fastest way to distribute products
(commutative or noncommutative) over sums.  Since quotients are represented as
products $see<simp> MULTTHRU can be used to divide sums by products as well.

.endfunction

.function(MULTTHRU,|exp1, exp2|)
multiplies each term in 2exp21 (which should be a sum or an
equation) by 2exp11.

.example
(C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;

.begin group
               1        X         F(X)
(D1)       - ----- + -------- - --------
             X - Y          2          3
                     (X - Y)    (X - Y)
.end

(C2) MULTTHRU((X-Y)**3,%);

.begin group
                                2
(D2)         X (X - Y) - (X - Y) - F(X)
.end

(C3) RATEXPAND(D2);
.begin group
                           2
(D3)                    - Y  + X Y - F(X)
.end

(C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);

.begin group
                         10  2              2  2
                (B  + A )   S  + 2 A B S + A  B
(D4)            --------------------------------
                                   2
                              A B S
.end

(C5) MULTTHRU(%);

.begin group
                                          10
                        2   A B   (B  + A)
(D5)                    - + --- + -------
                        S    2      A B
                            S
.end

1Notice that (B+A)**10 is not expanded.*

(C6) MULTTHRU(A.(B+C.(D+E)+F));

(D6)                A . F + A . C . (E + D) + A . B

1Compare with similar example under EXPAND.*

.end
.endfunction

.function(DISTRIB,exp)
distributes sums over products.  It differs from EXPAND
in that it works at only the top level of an expression, i.e. it does not
recurse and it is faster than EXPAND.  It differs from MULTTHRU in
that it expands all sums at that level. For example, 
.begin nofill narrow 5;
DISTRIB((A+B)*(C+D)) -> A C + A D + B C + B D 
MULTTHRU ((A+B)*(C+D)) -> (A + B) C + (A + B) D

DISTRIB (1/((A+B)*(C+D))) ->  1/ ((A+B) *(C+D))
EXPAND(1/((A+B)*(C+D)),1,0) -> 1/(A C + A D + B C + B D)
.end
.endfunction

The switch $var<NEGDISTRIB/TRUE> may be set globally to control the
distribution of -1 over an expression.  When it is TRUE it allows -1
to be distributed over an expression.  E.g. -(X+Y) becomes -Y-X.
Setting it to FALSE will allow -(X+Y) to be displayed like that.  This
is sometimes useful but be very careful: like the SIMP flag, this is
one flag you do not want to set to FALSE as a matter of course or
necessarily for other than local use in your MACSYMA.

.function(XTHRU,exp)
combines all terms of 2exp1, which should be a sum, over a common
denominator, without expanding products and exponentiated sums as
$fun<RATSIMP> does.  XTHRU cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.  Sometimes it is better to use XTHRU before RATSIMPing an
expression in order to cause explicit factors of the gcd of the
numerator and denominator to be cancelled, thus simplifying the
expression to be RATSIMPed.

.example
(C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;

.begin group
                                    20
                     1       (X + 2)   - 2 Y       X
(D1)             --------- + --------------- - ---------
                        19             20             20
                 (Y + X)        (Y + X)        (Y + X)
.end

(C2) XTHRU(%);
.begin group
                                     20
                              (X + 2)   - Y
(D2)                          -------------
                                       20
                                (Y + X)
.end

.end
.endfunction

.function(PARTFRAC,|exp, var|)
expands the expression 2exp1 in partial fractions with respect to
the main variable, 2var1.  PARTFRAC does a complete partial fraction
decomposition.  The algorithm employed is based on the fact that the
denominators of the partial fraction expansion (the factors of the
original denominator) are relatively prime.  The numerators can be
written as linear combinations of denominators, and the expansion
falls out.

.example

(C1) 2/(X+2)-1/(X+1)-X/(X+1)**2$

(C2) RATSIMP(%);
.begin group
                                       X
(D2)                        - -------------------
                               3      2
                              X  + 4 X  + 5 X + 2

.end
(C3) PARTFRAC(%,X);

.begin group
                             2       2        1
(D3)                       ----- - ----- + --------
                           X + 2   X + 1          2
                                           (X + 1)

.end


.end
.endfunction

.function(FACTOR,exp)
factors the expression 2exp1, containing any number of variables or functions,
into factors irreducible over the integers.

.ENDFUNCTION

.FUNCTION(FACTOR,|exp, p|)
factors 2exp1 over the field of integers with an element adjoined whose minimum polynomial is 2p1.


$var<FACTORFLAG/FALSE> if FALSE suppresses the factoring of integer
factors of rational expressions.

$var<DONTFACTOR/[]> may be set to a list of variables with respect to
which factoring is not to occur.  Factoring also will not take place
with respect to any variables that are less important (using the
variable ordering assumed for CRE form) than those on the DONTFACTOR
list. $see<rational!functions>

$var<FACEXPAND/TRUE> controls whether the irreducible factors
returned by FACTOR are in expanded (the default) or recursive (normal
CRE) form.

$var<SAVEFACTORS/FALSE> if TRUE causes the factors of an expression that is a
product of factors to be saved by certain functions in order to speed up later
factorizations of expressions containing some of the same factors.

$var<BERLEFACT/TRUE> if FALSE then the Kronecker factoring algorithm will be used otherwise the Berlekamp
algorithm, which is the default, will be used. (see [Be1, Wa4])

$var<NEWFAC/FALSE> may be set to true to use the new factoring routines.

$var<INTFACLIM/1000> is the largest divisor that will be tried when
factoring a bignum integer.  If set to FALSE (this is the case when
the user calls FACTOR explicitly), or if the integer is a fixnum (i.e.
fits in one machine word), complete factorization of the integer will
be attempted.  The setting of INTFACLIM is used for internal
calls to FACTOR.  Thus, INTFACLIM may be reset to prevent MACSYMA from
taking an inordinately long time factoring large integers.
.endfunction
.function(GCFACTOR,n)
factors the Gaussian integer n over the Gaussians, which are numbers of the
form a + b i where a and b are rational integers (i.e. ordinary
integers). Factors are normalized by making a and b non-negative.

.example
(C1) FACTOR(2**63-1);

.begin group
                        2
(D1)                   7  73 127 337 92737 649657
.end

(C2) FACTOR(Z**2*(X+2*Y)-4*X-8*Y);

(D2)                   (2 Y + X) (Z - 2) (Z + 2)

(C3)  X**2*Y**2+2*X*Y**2+Y**2-X**2-2*X-1;

.begin group
                     2  2        2    2    2
(D3)                X  Y  + 2 X Y  + Y  - X  - 2 X - 1
.end

(C4) DONTFACTOR:[X]$

(C5) FACTOR(D3/36/(Y**2+2*Y+1));

.begin group
                            2
                          (X  + 2 X + 1) (Y - 1)
(D5)                      ----------------------
                                36 (Y + 1)
.end

(C6) FACTOR(%E**(3*X)+1);
.begin group
                          X         2 X     X
(D6)                   (%E  + 1) (%E    - %E  + 1)
.end

(C7) FACTOR(X**4+1,A**2-2);

.begin group
                    2              2
(D7)              (X  - A X + 1) (X  + A X + 1)
.end

.end

When FACTOR is applied to integers, note that the value returned by
FACTOR when used in other computations may not lead to a simplified
result.  Using D1 above, the user can check that D1 + 1; will not
return 2^(63).


.endfunction

.function(FACTORSUM,exp)
tries to group terms in factors of 2exp1 that are sums into groups
of terms such that their sum is factorable.  It can recover the
result of EXPAND((X+Y)^2+(Z+W)^2) but it can not
recover EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.

.EXAMPLE

.BEGIN GROUP

(C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;

          2      2                            2      2
(D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X 

                         2        2    2            2
            + 2 U V X + U  X + A W  + V  + 2 U V + U

.END
.BEGIN GROUP
(C2) FACTORSUM(%);
                                       2          2
(D2)                 (X + 1) (A (Z + W)  + (V + U) )

.END
.END
.endfunction

.function(FACTOROUT,|exp,var1,var2,...|)
rearranges the sum 2exp* into a sum of terms of the form f(var1,var2,...)*g
where g is a product of expressions not containing the vari's and f is factored.
.endfunction


Another technique of factoring complex expressions uses the function SCANMAP (see Chapter $ref<lisp!functions>). 
             



.function(SQFR,exp)
is similar to FACTOR except that the polynomial factors are
"square-free."  That is, they have factors of degree one only.  This
algorithm, which is also used by the first stage of FACTOR, utilizes
the fact that a polynomial has in common with its n2th1 derivative
all its factors of degree > n.  Thus by taking gcds with the
polynomial of the derivatives with respect to each variable in the
polynomial, all factors of degree > 1 can be found.

.example group
(C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);

                             2               2
(D1)                       (X  - 1) (2 X + 1)

.end
.endfunction

.function(GFACTOR,exp)
factors the polynomial 2exp1 over the Gaussian integers,
which are the ordinary integers with SQRT(-1) =
%I adjoined.  This is like FACTOR(2exp1,A**2+1).

.example group
(C1)  GFACTOR(X**4-1);
(D1)        (X - 1) (X + 1) (X + %I) (X - %I)

.end
.endfunction

.function(GFACTORSUM,exp)
is similar to FACTORSUM but applies GFACTOR instead of FACTOR.
.endfunction

.function(PARTITION,|exp, var|)
returns a list of two expressions.  They are (1) the factors of
2exp1 (if it is a product), the terms of 2exp1 (if it is a sum),
or the sublist of 2exp1 (if it is a list) that do not contain
2var1 and, (2) the factors, terms, or sublist that do.

.example
(C1) PARTITION(2*A*X*F(X),X);

(D1)                 [2 A, X F(X)]

(C2) PARTITION(A+B,X);

(D2)                  [A + B, 0]

(C3) PARTITION([A,B,F(A),C],A);

(D3)              [[B, C], [A, F(A)]]
.end
.endfunction

.function(NTHROOT,|p,n|)
where 2p1 is a polynomial with integer coefficients and 2n1 is a
positive integer returns 2q1, a polynomial over the integers, such
that 2q1^2n1=2p1 or prints an error message indicating that
2p1 is not a perfect nth power. This routine is much faster than
either FACTOR or SQFR.
.endfunction

.function(LOGCONTRACT,exp)
recursively scans an exp, transforming subexpressions of the form
a1*LOG(b1) + a2*LOG(b2) + c into LOG(RATSIMP(b1^a1 * b2^a2)) + c

.example

(C1) 2*(A*LOG(X) + 2*A*LOG(Y))$

(C2) LOGCONTRACT(%);
                                        2  4
(D2)                             A LOG(X  Y )

(C3) LOGCONTRACT(LOG(SQRT(X+1)+SQRT(X)) + LOG(SQRT(X+1)-SQRT(X)));
(D3)                                  0

.end
If you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
A*LOG(X^(2*N)).  The coefficients that "contract" in this manner are
those such as the 2 and the N here which satisfy
FEATUREP(coeff,INTEGER).  The user can control which coefficients are
contracted by setting the option $var<LOGCONCOEFFP/FALSE> to the name of a
predicate function of one argument.  For example, if you like to generate
SQRTs, you can do
.example
(C1) LOGCONCOEFFP:'LOGCONFUN$
(C2) LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$
(C3) LOGCONTRACT(1/2*LOG(X)); 
(D3)                             LOG(SQRT(X)).
.end
.endfunction

.function(ROOTSCONTRACT,exp) 
converts products of roots into roots of products. For example,
ROOTSCONTRACT(SQRT(X)*Y^(3/2)); gives SQRT(X*Y^3).
There is an option $var<ROOTSCONMODE/TRUE>, 
which affects ROOTSCONTRACT as follows:
.SKIP BEGIN NOFILL turn on "\" tabs 25,50;turn off "^"
Problem\Value of ROOTSCONMODE\Result of applying
\\ROOTSCONTRACT
X^(1/2)*Y^(3/2)\FALSE\(X*Y^3)^(1/2)
X^(1/2)*Y^(1/4)\FALSE\X^(1/2)*Y^(1/4)
X^(1/2)*Y^(1/4)\TRUE\(X*Y^(1/2))^(1/2)
X^(1/2)*Y^(1/3)\TRUE\X^(1/2)*Y^(1/3)
X^(1/2)*Y^(1/4)\ALL\(X^2*Y)^(1/4)
X^(1/2)*Y^(1/3)\ALL\(X^3*Y^2)^(1/6)
.end
The above examples and more may be tried out by typing
EXAMPLE(ROOTSCONTRACT); .  When ROOTSCONMODE is FALSE, ROOTSCONTRACT
contracts only wrt rational number exponents whose denominators are
the same.  The key to the ROOTSCONMODE:TRUE$ examples is simply that 2
divides into 4 but not into 3.  ROOTSCONMODE:ALL$ involves taking the
lcm (least common multiple) of the denominators of the exponents.

When RADEXPAND is TRUE and DOMAIN is REAL (their defaults), 
ROOTSCONTRACT converts ABS into SQRT.
For example, ROOTSCONTRACT(ABS(X)*SQRT(Y)); gives SQRT(X^2*Y) .

ROOTSCONTRACT uses RATSIMP in a manner similar to LOGCONTRACT.  
.example
(C1) ROOTSCONMODE:TRUE$
(C2) ROOTSCONTRACT(SQRT(SQRT(5)+5)-5^(1/4)*SQRT(SQRT(5)+1));
(D2)                                  0

.end
.endfunction


.subsec (Sums and Products,sumsandprods)

.function(SUM,|exp, ind, lo, hi|)
performs a summation of the values of 2exp1 as the index 2ind1
varies from 2lo1 to 2hi1.  If the upper and lower limits differ by
an integer then each term in the sum is evaluated and added together.
Otherwise, if $var<SIMPSUM/FALSE> is TRUE the result is simplified.  This
simplification may sometimes be able to produce a closed form.  If
SIMPSUM is FALSE or if 'SUM is used, the value is a sum noun form
which is a representation of the sigma notation used in mathematics.

If 2hi1 is one less than 2lo1, we have an "empty sum" and SUM
returns 0 rather than erring out.

Sums can be differentiated, added, subtracted, or multiplied with some
automatic simplification being performed.

$var<SUMEXPAND/FALSE> if TRUE, causes products of sums and
exponentiated sums to be converted into nested sums.
If FALSE, they are left alone.  See also CAUCHYSUM, below.

.example
(C1) SUMEXPAND:TRUE$

(C2) SUM(F(I),I,0,M)*SUM(G(J),J,0,N);

.begin group
                           M      N
                          ====   ====
                          \      \
(D2)                       >      >     F(I1) G(I2)
                          /      /
                          ====   ====
                          I1 = 0 I2 = 0
.end

(C3) SUM(F(I),I,0,M)^2;

.begin group
                           M      M
                          ====   ====
                          \      \
(D3)                       >      >     F(I3) F(I4)
                          /      /
                          ====   ====
                          I3 = 0 I4 = 0

.end end


$var<CAUCHYSUM/FALSE> - When multiplying together sums with INF
as their upper limit, if SUMEXPAND is TRUE and CAUCHYSUM is set to
TRUE then the Cauchy product will be used rather than the usual
product.  In the Cauchy product the index of the inner summation is a
function of the index of the outer one rather than varying
independently.  That is: SUM(F(I),I,0,INF)*SUM(G(J),J,0,INF) becomes
SUM(SUM(F(I)*G(J-I),I,0,J),J,0,INF)

$var<GENINDEX/I> is the alphabetic prefix used to generate the next
variable of summation when necessary.

$var<GENSUMNUM/0> is the numeric suffix used to generate the next
variable of summation.  If it is set to FALSE then the index will
consist only of GENINDEX with no numeric suffix.

$var<SUMHACK/FALSE> if set to true allows SUM(I,I,3,1); to give -2,
based on the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1), when
A>B.


.example
(C1) SIMPSUM:TRUE$

(C2) SUM(I**2+2**I,I,0,N);

.begin group
                         3      2
              N + 1   2 N  + 3 N  + N
(D2)         2      + --------------- - 1
                             6
.end

(C3) SUM(3**(-I),I,1,INF);

.begin group
                          1
(D3)                      -
                          2
.end

(C4) SUM(I^2,I,1,4)*SUM(1/I^2,I,1,INF);

.begin group
                                       2
(D5)                              5 %PI
.end

.end
.endfunction

.function(SUMCONTRACT,expr)
combines all sums of an addition that have
upper and lower bounds that differ by constants. The result is an
expression that contains one summation for each set of such summations
added to all appropriate extra terms that had to be extracted to form
this sum.  SUMCONTRACT  combines all compatible sums and use one of
the indices from one of the sums if it can, and then tries to form a
reasonable index if it cannot use any of those supplied.
.endfunction

.function(INTOSUM,expr)
takes all factors that a summation is multiplied by, and puts them
inside the summation.  If the index is used in the outside expression,
then INTOSUM tries to find a reasonable index, as it
does for SUMCONTRACT. This is the reverse of the
OUTATIVE property of summations, but note that it does not remove this
property, it only bypasses it.
.endfunction

.function(BASHINDICES,expr)
- transforms the expression 2expr1 by giving each
summation and product a unique index. This gives CHANGEVAR greater
precision when it is working with summations or products.  The form of
the unique index is J2number1. The quantity 2number1 is determined by
referring to GENSUMNUM, which can be changed by the user.  For
example, GENSUMNUM:0$ resets it.
.endfunction

.function(NICEINDICES,expr)
- will take the expression and change all the
indices of sums and products to something easily understandable. It
makes each index it can "I" , unless "I" is in the internal
expression, in which case it sequentially tries
J,K,L,M,N,I0,I1,I2,I3,I4,...  until it finds a legal index.

The user may set the variable $var<NICEINDICESPREF/I,J,K,L,M,N>, the
list that NICEINDICES uses to find its "nice indices".  This allows
the user to set an order of preference for the "nice indices".  E.g.
NICEINDICESPREF:[Q,R,S,T,INDEX]$.  Then if NICEINDICES finds that it
cannot use any of these as indices in a particular summation, it uses
the first as a base to try and tack on numbers.  Here, if the list is
exhausted, Q0, then Q1, etc, will be tried.

.endfunction

.function(NUSUM,|exp,var,low,high|)
performs indefinite summation of 2exp1 with respect to 2var1 using
a decision procedure due to R.W. Gosper.  2exp1 and the potential
answer must be expressible as products of nth powers, factorials,
binomials, and rational functions.  The terms "definite" and
"indefinite summation" are used analogously to "definite" and
"indefinite integration".  To sum indefinitely means to give a closed
form for the sum over intervals of variable length, not just e.g. 0 to
inf.  Thus, since there is no formula for the general partial sum of
the binomial series, NUSUM can not do it.

.endfunction

.function(UNSUM,|fun,n|)
is the first backward difference  2fun(n) - fun(n-1)1.
.endfunction

.function(FUNCSOLVE,|eqn,g(t)|)
gives [g(t) = ...]  or [], depending on whether
or not there exists a rational fcn g(t) satisfying 2eqn1, which must be
a first order, linear polynomial in (for this case) g(t) and g(t+1).

Warning: this is a very rudimentary implementation--many safety checks
and obvious generalizations are missing.
.endfunction
.example
(C1) NUSUM(N*N!,N,0,N);

(D1)                             (N + 1)! - 1

.begin group
(C2) NUSUM(N^4*4^N/BINOMIAL(2*N,N),N,0,N);

                           4        3       2              N
            2 (N + 1) (63 N  + 112 N  + 18 N  - 22 N + 3) 4     2
(D2)        ------------------------------------------------ - ---
                          693 BINOMIAL(2 N, N)                 231

.end begin group
(C3) UNSUM(%,N);
                                     4  N
                                    N  4
(D3)                           ----------------
                               BINOMIAL(2 N, N)

.end end scon
NUSUM and UNSUM now also know a little about sums and differences 
of finite products:
.example
.begin group
(C4) UNSUM(PROD(I^2,I,1,N),N);

                           N - 1
                           /===\
                            ! !   2
(D4)                      ( ! !  I ) (N - 1) (N + 1)
                            ! !
                           I = 1

.end begin group
(C5) NUSUM(%,N,1,N);
                                   N
                                 /===\
                                  ! !   2
(D5)                              ! !  I  - 1
                                  ! !
                                 I = 1

.end
(C6) FUNCSOLVE((N+1)*F(N)-(N+3)*F(N+1)/(N+1) = (N-1)/(N+2),F(N));
.begin group
                                 N
(D6)               F(N) = ---------------
                          (N + 1) (N + 2)

.end end
.function(PRODUCT,|exp, ind, lo, hi|)
gives the product of the values of 2exp1 as the index 2ind1 varies from
2lo1 to 2hi1.  The evaluation is similar to that of SUM.   No simplification of
products is available at this time.  If 2hi1 is one less than 2lo1, we have an "empty product" and PRODUCT returns 1 rather than erring out.

.example group
(C1)  PRODUCT(X+I*(I+1)/2,I,1,4);

(D1)             (X + 1) (X + 3) (X + 6) (X + 10)
.end
.endfunction

$var<PRODHACK/FALSE> - if set to TRUE then PRODUCT(F(I),I,3,1); 
will yield 1/F(2), by the identity 
PRODUCT(F(I),I,A,B) = 1/PRODUCT(F(I),I,B+1,A-1) when A>B.

.subsec (Differentiation and Integration Functions,difintfun)

.function(DIFF,|exp, v1, n1, v2, n2, ...|)
differentiates 2exp1 with respect to each 2vi1, 2ni1 times.  If just the first
derivative with respect to one variable is desired then the form DIFF(2exp,v1)
may be used.  If the noun form of the function is required (as, for example, when writing a
differential equation), 'DIFF should be used and this will display in a two dimensional
format.  (See Section $ref<evsimpfun> on how to convert 'DIFF ("derivative") into
DIFF ("differentiate") via the EV command.)


$var<DERIVABBREV/FALSE> if TRUE will cause derivatives to display as subscripts.

DIFF(2exp1) gives the "total differential", that is, the sum of the
derivatives of 2exp1 with respect to each of its variables times the function
DEL of the variable.  No further simplification of DEL is offered. 
.example

(C1) DIFF(EXP(F(X)),X,2);
.begin group
                             2
                      F(X)  d             F(X)  d         2
(D1)                %E     (--- F(X)) + %E     (-- (F(X)))
                              2                 dX
                            dX
.end



(C2) DERIVABBREV:TRUE$


(C3) 'INTEGRATE(F(X,Y),Y,G(X),H(X));
.begin group
                                H(X)
                               /
                               [
(D3)                           I     F(X, Y) dY
                               ]
                               /
                                G(X)
.end
.begin group
(C4) DIFF(%,X);
            H(X)
           /
           [
(D4)       I     F(X, Y)  dY + F(X, H(X)) H(X)  - F(X, G(X)) G(X)
           ]            X                     X                  X
           /
            G(X)

.end
.end
.endfunction
.function(DEPENDS,|funlist1,varlist1,funlist2,varlist2,...|)
declares functional dependencies for variables to be used by DIFF.
DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T) informs DIFF that F and G
depend on X and Y, that R and S depend on U,V, and W, and that U
depends on T.  The arguments to DEPENDS are evaluated.  The
variables in each 2funlist1 are declared to depend on all the
variables in the next 2varlist1.$$In this command, lists of length
one can be typed in directly as atoms.* A 2funlist1 can contain the
name of an atomic variable or array.  In the latter case, it is
assumed that all the elements of the array depend on all the variables
in the succeeding 2varlist1.  Initially, DIFF(F,X) is 0; executing
DEPENDS(F,X) causes future differentiations of F with respect to X to
give DF/DX or F[X] (if DERIVABBREV:TRUE).

.example

(C1) DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T);
(D1)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]

(C2) DEPENDENCIES;
(D2)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
.begin group
(C3) DIFF(R.S,U);
                               dR           dS
(D3)                           -- . S + R . --
                               dU           dU
.end
.end

Since MACSYMA knows the chain rule for symbolic derivatives, it takes advantage of the given dependencies as follows:
.example
.begin group
(C4) DIFF(R.S,T);
                           dR dU             dS dU
(D4)                      (-- --) . S + R . (-- --)
                           dU dT             dU dT
.end
.end
.bcon
If we set 
.example
(C5) DERIVABBREV:TRUE;
(D5)                                 TRUE
.end
.scon
then re-executing the command C4, we obtain
.example

(C6) ''C4;
(D6)                      (R  U ) . S + R . (S  U )
                            U  T              U  T
.end


To eliminate a previously declared dependency, the REMOVE command can be used.  For  example, to say that R no longer depends on U as declared in C1, the user can type  REMOVE(R,DEPENDENCY).  This will eliminate all dependencies that may have been declared for R.  
.example

(C7) REMOVE(R,DEPENDENCY);
(D7)                                 DONE

(C8) ''C4;
(D8)                             R . (S  U )
                                       U  T

.end scon
2CAVEAT:1 DIFF* is the only1 MACSYMA* command that uses 1DEPENDENCIES* information.   The arguments to 1INTEGRATE,LAPLACE,*etc. must be given their dependencies explicitly in the command, e.g., 1INTEGRATE(F(X),X)*.

.endfunction
1
.function(GRADEF,|f(x1, ..., xn), g1, ..., gn|)
defines the derivatives of the function 2f1 with respect to its n arguments.  That is,
d2f1/d2xi1 = 2gi1, etc.  If fewer than n gradients, say i, are given, then they
refer to the first i arguments of 2f1.  The 2xi1 are merely dummy variables as in
function definition headers and are used to indicate the i2th1 argument of 2f1.  All
arguments to GRADEF except the first are evaluated so that if 2g1 is a defined
function then it is invoked and the result is used.

Gradients are needed when, for example, a function is not known explicitly but
its first derivatives are and it is desired to obtain higher order derivatives.
GRADEF may also be used to redefine the derivatives of MACSYMA's predefined functions
(e.g. GRADEF(SIN(X),SQRT(1-SIN(X)**2)) ).  It is not permissible to use GRADEF on
subscripted functions.

GRADEFS is a list of the functions that have been given gradients by use of the
GRADEF command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn).)

PRINTPROPS([2f1,f2,1...],GRADEF) $see<MACSYMA!properties> may be used to display the gradefs of the functions 2f1,f2,..1

REMOVE([2f1,f2,1...],GRADEF) may be used to eliminate the GRADEF property from the functions 2f1,f2,...1.

.example
(C1) DEPENDS(Y,X)$

(C2) GRADEF(F(X,Y),X**2,G(X,Y))$

(C3) DIFF(F(X,Y),X);
.begin group
                                     dY    2
(D3)                         G(X, Y) -- + X
                                     dX
.end

(C4) GRADEF(J(N,Z), 'DIFF(J(N,Z),N),J(N-1,Z)-N/Z*J(N,Z))$

(C5) RATSIMP(DIFF(J(2,X),X,2));

.begin group
                       2
              J(0, X) X  - 3 J(1, X) X + 6 J(2, X)
(D5)          ------------------------------------
                                2
                               X
.end

.end

    (The example above computes the second derivative of a Bessel function of order two.
A subscripted function e.g. J[N], could not have been used because a gradient for it
cannot be defined using GRADEF.)

.endfunction

.function(GRADEF,|a,v,exp|)
may be used to state
that the derivative of the atomic variable 2a1 with respect to 2v1 is
2exp1.  This automatically does a DEPENDS(2a1,2v1).  For examples, see example 2 of Appendix IV.


PRINTPROPS([2a1,a21,...],$fun<ATOMGRAD>) $see<MACSYMA!properties> may be used to display the atomic
gradient properties of 2a1,a2,...1

REMOVE([2a1,a2,1...],ATOMGRAD) may be used to eliminate the ATOMGRAD property from  2a1,a2,...1.


.endfunction

.function(INTEGRATE,|exp, var|)
 integrates 2exp1 with respect to 2var1 or returns an integral
expression (the noun form) if it cannot perform the integration.
Generally speaking, MACSYMA only handles integrals that are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as g(x) and h(x) (see note
below).
Roughly speaking three stages are used:

(1) INTEGRATE sees if the integrand is of the form
F(G(X))*DIFF(G(X),X) by testing whether the derivative of some
subexpression (i.e. G(X) in the above case) divides the integrand.  If
so it looks up F in a table of integrals and substitutes G(X) for X in
the integral of F.  This may make use of gradients in taking the
derivative.  (If an unknown function appears in the integrand it must
be eliminated in this stage or else INTEGRATE will return the noun
form of the integrand.)

(2) INTEGRATE tries to match the integrand to a form for which a
specific method can be used, e.g. trigonometric substitutions.

(3) If the first two stages fail it uses the Risch algorithm. (see [Mo2, Mo4])
.endfunction

2CAVEAT: 1INTEGRATE* knows only about explicit dependencies.1 It
is not affected by DEPENDENCIES set up with the DEPENDS command.

.function(INTEGRATE,|exp, var, low, high|)
 finds the definite integral of 2exp1 with respect to 2var1 from
2low1 to 2high1 or returns the noun form if it cannot 
perform the integration.  Several methods are used,including direct
substitution in the indefinite integral and contour integration (see
[Wa3]).  Improper integrals may use the names $var<INF/> for positive
infinity and $var<MINF/> for negative infinity.  If an integral "form"
is desired for manipulation (for example, an integral that cannot be
computed until some numbers are substituted for some parameters), the
noun form 'INTEGRATE may be used and this will display with an
integral sign.  See Note below.

$var<ABCONVTEST/FALSE> when TRUE causes INTEGRATE to test for absolute convergence.

$var<LOGABS/FALSE> causes integration of an expression where logs are
generated, e.g. INTEGRATE(1/X,X), to return the answer in terms of
LOG(...).  If LOGABS is set to TRUE, the answer will be given in terms
of LOG(ABS(...)).  For definite integration, the LOGABS:TRUE setting
is used, because here "evaluation" of the indefinite integral at the
endpoints is often needed.

The function $fun<LDEFINT> uses $fun<LIMIT> $see<difintfun> to evaluate the indefinite integral at the lower and upper limits.


Sometimes during integration the user may be asked what the sign of an
expression is.  Suitable responses are POS; , ZERO; , or NEG; .
There is a switch $var<ASSUME_POS/FALSE> such that if 
set to TRUE, MACSYMA will assume one's parameters are positive.  $see<decass>.

.example
(C1) INTEGRATE(SIN(X)**3,X);

.begin group
                    3
                 COS (X)
(D1)             ------- - COS(X)
                    3
.end

(C2) INTEGRATE(X**A/(X+1)**(5/2),X,0,INF);
IS  A + 1  POSITIVE, NEGATIVE, OR ZERO?

POS;
.begin group

   2 A + 2
IS ------- AN INTEGER?
      5
YES;

.end
IS  2 A - 3  POSITIVE, NEGATIVE, OR ZERO?

NEG;
.begin group
                            3
(D2)            BETA(A + 1, - - A)
                            2
.end

(C3) GRADEF(Q(X),SIN(X**2));
(D3)                              Q(X)

(C4) DIFF(LOG(Q(R(X))),X);

.begin group
                           d             2
                          (-- R(X)) SIN(R (X))
                           dX
(D4)                      --------------------
                                Q(R(X))
.end

(C5) INTEGRATE(%,X);
(D5)                          LOG(Q(R(X)))

.end
Note: The fact that MACSYMA does not perform certain integrals does
not always imply that the integral does not exist in closed form. In
the example below the integration call returns the noun form but the
integral can be found fairly easily. For example, one can compute the
roots of X^3+X+1 = 0 to rewrite the integrand in the form
1/((X-A)*(X-B)*(X-C)) where A, B and C are the roots. MACSYMA will
integrate this equivalent form although the integral is quite
complicated.
.example
(C6) INTEGRATE(1/(X^3+X+1),X);

                          /
                          [     1
(D6)                      I ---------- dX
                          ]  3
                          / X  + X + 1
.end
.endfunction

.function(DEFINT,|exp, var, low, high|)
DEFinite INTegration, the same as INTEGRATE(2exp,var,low,high1).
.endfunction

.function(RISCH,|exp, var|)
integrates 2exp1 with respect to 2var1 using the transcendental
case of the Risch algorithm.  (The algebraic case of the Risch
algorithm has not been implemented.)  This currently handles the cases
of nested exponentials and logarithms that the main part of
$fun<INTEGRATE> can not do.  INTEGRATE will automatically apply RISCH if
given these cases.


$var<ERFFLAG/TRUE> - if FALSE prevents RISCH from introducing the ERF function in
the answer if there were none in the integrand to begin with.

.example group
(C1) RISCH(X^2*ERF(X),X);
                                                              2
                   3                      2                - X
              %PI X  ERF(X) + (SQRT(%PI) X  + SQRT(%PI)) %E
(D1)          -------------------------------------------------
                                    3 %PI

(C2) DIFF(%,X),RATSIMP;
                                   2
(D2)                              X  ERF(X)

.end
.endfunction


.function(CHANGEVAR,|exp,f(x,y),y,x|)
makes the change of variable given by f(x,y) = 0 in all integrals occurring in 
2exp1 with integration with respect to x;  y is the new variable.

.example
(C1) ASSUME(A>0)$

(C2) 'INTEGRATE(%E^(SQRT(A)*SQRT(Y)),Y,0,4);

.begin group
                      4
                     /
                     [    SQRT(A) SQRT(Y)
(D2)                 I  %E                dY
                     ]
                     /
                      0

.end
(C3) CHANGEVAR(%,Y-Z^2/A,Z,Y);
.begin group
                      0
                     /
                     [                ABS(Z)
                   2 I            Z %E       dZ
                     ]
                     /
                      - 2 SQRT(A)
(D3)             - ----------------------------
                                A

.end
(C4) FORGET(A>0)$

.end

CHANGEVAR may also be used to changes in the indices of a sum or product.
However, it must be realized that when a change is made in a sum or product,
this change must be a shift, i.e. I=J+ ..., not a higher degree function.
For example:
.example
(C5) SUM(A[I]*X^(I-2),I,0,INF);
.begin group
                         INF
                         ====
                         \         I - 2
(D5)                      >    A  X
                         /      I
                         ====
                         I = 0

.end
(C6) CHANGEVAR(%,I-2-N,N,I);
.begin group
                        INF
                        ====
                        \               N
(D6)                     >      A      X
                        /        N + 2
                        ====
                        N = - 2
.end
.end
.endfunction

.function (LIMIT,|exp, var, val, dir|)
finds the limit of 2exp1 as the real variable 2var1 approaches the value
2val1 from the direction 2dir1.  2Dir1 may have the value PLUS for a limit
from above, MINUS for a limit from below, or may be omitted (implying a
two-sided limit is to be computed).  For the method see [Wa3].  LIMIT uses the
following special symbols:  INF (positive infinity) and MINF (negative
infinity).  On output it may also use UND (undefined), IND (indefinite but
bounded) and INFINITY (complex infinity).  If LIMIT is called on FIB(2n1),
it will convert this to the closed form definition, involving the constant
$var<%PHI/|(SQRT(5)+1)/2 = 1.618033989>.

$var<LHOSPITALLIM/4> is the maximum number of times
l'Hospital's rule is used in
LIMIT.  This prevents infinite looping in cases like LIMIT(COT(X)/CSC(X),X,0).

$var<TLIMSWITCH/FALSE> if true will cause the limit package to use Taylor series when possible.

$var<LIMSUBST/FALSE> prevents LIMIT from attempting substitutions on
unknown forms.  This is used to avoid bugs like LIMIT(F(N)/F(N+1),N,INF);
giving 1.  Setting LIMSUBST to TRUE will allow such substitutions.

.example
(C1) LIMIT(X*LOG(X),X,0,PLUS);

(D1)                 0

(C2) LIMIT((1+X)**(1/X),X,0);

(D2)                 %E

(C3) LIMIT(%E**X/X,X,INF);

(D3)                 INF

(C4) LIMIT(SIN(1/X),X,0);

(D4)                 IND

.end
LIMIT is often called upon to simplify constant expressions like INF-1,
so for such expressions LIMIT will accept only one argument:
.example
(C5) LIMIT(INF-1);

(D5)                 INF
.end
.endfunction

.function(TLIMIT,|exp,var,val,dir|) 
 is just the function LIMIT with TLIMSWITCH set to TRUE.

.endfunction

.function(LDEFINT,|exp,var,low,high|)
yields the definite integral of 2exp* by using LIMIT to evaluate the indefinite integral of 2exp* with respect to 2var* at the upper limit 2high* and at the lower limit 2low*.

.endfunction

.function(TLDEFINT,|exp,var,low,high|)
is just LDEFINT with  TLIMSWITCH  set to TRUE.

.endfunction

.function (RESIDUE,|exp, var, val|)
computes the residue in the complex plane of the expression 2exp1
when the variable 2var1 assumes the value 2val1.  The residue is the coefficient of
(2var1-2val1)**(-1) in the Laurent series for 2exp1.

.example
(C1) RESIDUE(S/(S**2+A**2),S,A*%I);

.begin group
                        1
(D1)                    -
                        2
.end

(C2) RESIDUE(SIN(A*X)/X**4,X,0);

.begin group
                        3
                       A
(D2)                 - --
                       6
.end

.end
.endfunction


.function(ODE2,|diffeq,depvar,indvar|)
solves ordinary differential equations, 2diffeq1, of first or second
order. The dependent and independent variables are specified as the
second and third arguments.  When it is successful, ODE2 returns either an
explicit or implicit solution for the dependent variable.  The symbol
2%C1 is used to represent the constant in the case of first order
equations and 2%K1,%K21 represent the constants for second order
equations.  If for some reason ODE2 cannot obtain a solution, it
returns FALSE, sometimes printing an error message.

ODE2 includes a recognizer for the Bessel equation 
.example
(X-PT)^2*'DIFF(Y,X,2)+(X-PT)*'DIFF(Y,X)+((X-PT)^2-NU^2)*Y=0 
.end
for which it returns solutions in terms of { %J[NU], %Y[NU] } 
If NU is an integer, and otherwise in terms of { %J[NU], %J[-NU] }, 
except that it treats NU=1/2 as a special case.
.example
.begin group
(C1) X^2*'DIFF(Y,X) + 3*X*Y = SIN(X)/X;
                         2 dY           SIN(X)
(D1)                    X  -- + 3 X Y = ------
                           dX             X

.end
(C2) ODE2(%,Y,X);


                                %C - COS(X)
(D2)                        Y = -----------
                                     3
                                    X


.end
.endfunction

.function(DESOLVE,|[eq1,...,eqn],[var1,...,varn]|)
where the 2eq*'s are differential equations in the dependent variables
var1,...,varn.  The functional relationships must be explicitly
indicated in both the equations and the variables. For example

.example
(C1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);
(C2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);
.end
.scon
is not the proper format.  The correct way is:

.example
(C3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);
(C4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);
.end
The quotes are not necessary since DIFF will return the noun forms anyway.

The call is then DESOLVE([D3,D4],[F(X),G(X)]);

If initial conditions at 0 are known, they should be supplied before
calling DESOLVE by using ATVALUE.
.example

(C11) 'DIFF(F(X),X)='DIFF(G(X),X)+SIN(X);
.begin group
                        d           d
(D11)                   -- (F(X)) = -- (G(X)) + SIN(X)
                        dX          dX
.end
(C12) 'DIFF(G(X),X,2)='DIFF(F(X),X)-COS(X);
.begin group
                         2
                        d            d
(D12)                   --- (G(X)) = -- (F(X)) - COS(X)
                          2          dX
                        dX
.end
(C13) ATVALUE('DIFF(G(X),X),X=0,A);
(D13)                                A

(C14) ATVALUE(F(X),X=0,1);
(D14)                                1

(C15) DESOLVE([D11,D12],[F(X),G(X)]);

                X                            X
(D16) [F(X)=A %E  - A+1, G(X) = COS(X) + A %E  - A + G(0) - 1]

/* VERIFICATION */
(C17) [D11,D12],D16,DIFF;
                  X       X      X                X
(D17)        [A %E  = A %E , A %E  - COS(X) = A %E  - COS(X)]

.end
If DESOLVE cannot obtain a solution, it returns FALSE.
.endfunction
.subsec(Numerical Integration,numint,1)


The original version of this program was written by Richard Fateman.
In the latest version there are two ways of calling the function
ROMBERG:$$Note the change from the original version of the program*

1) An inefficient way that resembles a call to INTEGRATE (the definite 
integral version):
.inline function(ROMBERG,|integrand,variable,lower limit,upper limit|)

For example,
.example
(C1) SHOWTIME:TRUE$

(C2) ROMBERG(SIN(Y),Y,1,%PI);
time= 54 msec.
(D2)                          1.5403023

(C3) F(X):=1/(X^5+X+1)$
time= 1 msec.

(C4) ROMBERG(F(X),X,1.5,0);
time= 216 msec.
(D4)                          -.075293843
.end 
.skip
2) An efficient way that is more like the old ROMBERG function:
.inline function(ROMBERG,|function name,lower limit,upper limit|)

The first argument must be a TRANSLATEd or compiled function.  (If it is
compiled it must be declared to return a FLONUM.)  If the first argument
is not already TRANSLATEd, ROMBERG will not attempt to TRANSLATE it but
will give an error.  As an example consider the function f defined above,
.example
(C5) F(X):=(MODE_DECLARE([FUNCTION(F),X],FLOAT),1/(X^5+X+1));
time= 1 msec.
                                                        1
(D5) F(X) := (MODE_DECLARE([FUNCTION(F), X], FLOAT), ----------)
                                                     5
                                                    X  + X + 1

(C6) TRANSLATE(F)$
time= 10 msec.

(C7) ROMBERG(F,1.5,0);
time= 13 msec.
(D7)                        - 0.75293843

.end
.skip
The accuracy of the integration is governed by the global variables
$var<ROMBERGTOL/1.E-4> and $var<ROMBERGIT/11>.
ROMBERG will return a result if the relative difference in successive
approximations is less than ROMBERGTOL.  It will try halving the
stepsize ROMBERGIT times before it gives up.

ROMBERG may be called recursively and thus can do double and triple
integrals.  In this case , it is even  more important to TRANSLATE the 
functions and to use the second way of calling ROMBERG. 
.example
(C8) INTEGRATE(INTEGRATE(X*Y/(X+Y),Y,0,X/2),X,1,3);
time= 305 msec.
.begin group
Is  X  positive, negative, or zero?

pos;

                         3               9
                   2 LOG(-) - 1   18 LOG(-) - 18 LOG(3) - 9
                         2               2
(D8)               ------------ - -------------------------
                        6                     2

.end

(C9) %,NUMER;
time= 6 msec.
(D9)                         0.819302335

(C10) F(Y):=(MODE_DECLARE([FUNCTION(F),X,Y],FLOAT),X*Y/(X+Y))$
time= 2 msec.

(C11) G(X):=(MODE_DECLARE([FUNCTION(F,G),X],FLOAT),ROMBERG(F,0,X/2))$
time= 1 msec.

(C12) TRANSLATE(F,G)$
time= 6 msec.

(C13) ROMBERG(G,1,3);
time= 32 msec.
(D13)                         0.8193023


.end

.sec (Part Selection and Substitution, pss)

The functions in this section are used to extract or replace parts of expressions.

.subsec (The Part Functions,partfun)

The Part functions make it possible to reference or replace any part
of any MACSYMA expression.  A part of a displayed expression is
referred to by a set of indices that are non-negative integers.  For
example, in exponentiation the base is considered part 1 and the
exponent part 2.  In a quotient the numerator is part 1 and the
denominator part 2.  In a sum or product the i2th1 term or factor is
part i. In any expression the main operator is part 0.  For -X the 0th
part is -, for A^B it is ^, for DIFF(F(X),X) it is DIFF, etc.  Note
that unary minus is considered an operator.

In MACSYMA the user has some control of the way in which expressions
are displayed.  The ordering of factors in a product or terms in a sum
may be changed by the user (see $ref<ordering!functions>,
$ref<rational!functions>).  The ordering of parts in the displayed
form of an expression may differ from the ordering in the internal
representation of the expression.

.function(PART,|exp, n1, ..., nk|)
deals with the displayed form of 2exp*. It obtains the part of
2exp1 as specified by the indices 2n11,...,2nk1.  First part
2n11 of 2exp1 is obtained, then part 2n21 of that, etc.  The
result is part 2nk1 of ... part 2n21 of part 2n11 of 2exp1.
Thus PART(Z+2*Y,2,1) yields 2.  PART can be used to obtain an element
of a list, a row of a matrix, etc.

.example
(C1)  X+Y/Z**2;
.begin group
                        Y
(D1)                   -- + X
                        2
                       Z
.end
(C2) PART(D1,1,2,2);

(D2)                    2

(C3) 'INTEGRATE(F(X),X,A,B)+X;

.begin group
                      B
                     /
                     [
(D3)                 I F(X)dX + X
                     ]
                     /
                     A
.end

(C4) PART(%,1,1);
(D4)                  F(X)

.end
.endfunction

.function(INPART,|exp,n1,...,nk|)
is similar to PART but works on the internal representation of the
expression $see<simp> rather than the displayed form and thus may be
faster since no formatting is done.  Care should be taken with respect
to the order of subexpressions in sums and products (since the order
of variables in the internal form is often different from that in the
displayed form) and in dealing with unary minus, subtraction, and
division (since these operators are removed from the expression).
PART(X+Y,0) or INPART(X+Y,0) yield +, though in order to refer to the
operator it must be enclosed in "s.  For example ...IF
INPART(D9,0)="+" THEN ...

.example
(C1)  X+Y+W*Z;

(D1)                  W Z + Y + X

(C2)  INPART(D1,3,2);

(D2)                  Z
(C3)  PART(D1,1,2);

(D3)                  Z

(C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
.begin group
                                      G(X + 1)
(D4)                      LIMIT   F(X)
                          X ->0-
.end

(C5) INPART(%,1,2);
(D5)                            G(X + 1)

.end
.endfunction

.function(ARGS,exp)
returns a list of the args of exp.  I.e. it is
essentially equivalent to SUBSTPART("[",exp,0) .
.endfunction

$var<INFLAG/FALSE> if set to TRUE, the functions for part extraction
will look at the internal form of 2exp*.  Also, setting INFLAG to
TRUE and calling PART/SUBSTPART is the same as calling
INPART/SUBSTINPART.  The functions affected by the setting of INFLAG are:
$fun<PART>, $fun<SUBSTPART>, $fun<FIRST>, $fun<REST>, $fun<LAST>,
$fun<LENGTH>, the FOR ... IN construct, $fun<MAP>, $fun<FULLMAP>,
$fun<MAPLIST>, $fun<REVEAL> $fun<ARGS> and $fun<PICKAPART>.

.function(ALLBUT,|arg1,arg2,...|)
works with the PART commands (i.e. PART, INPART, SUBSTPART,
SUBSTINPART, DPART, and LPART).  For example, if EXPR is E+D+C+B+A,
then PART(EXPR,[2,5]); gives D+A, while PART(EXPR,ALLBUT(2,5)); gives
E+C+B.  (ALLBUT also works with the KILL command, which see.)
.endfunction

.function(DISPFORM,exp) 
returns the external representation of 2exp* (wrt its main
operator).  This should be useful in conjunction with PART which also
deals with the external representation.  Suppose EXP is -A .  Then the
internal representation of EXP is "*"(-1,A), while the external
representation is "-"(A). 

  DISPFORM(2exp*,ALL) converts the entire expression (not just the top-level) to external format.  For example, if  EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.

.endfunction  

.function(NOUNIFY,f)
returns the noun form of the function name 2f1.  This is needed
if one wishes to refer to the name of a verb function as if it were a noun.  Note that
some verb functions will return their noun forms if they can not be evaluated for
certain arguments.  This is also the form returned if a function call is preceded by a
quote.

.example group
(C6) IS(INPART(D4,0)=NOUNIFY(LIMIT));

(D6)                              TRUE

.end
.endfunction

.function(APPLY_NOUNS,exp)
causes the application of noun forms in an
expression.  E.g. EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This
gives the same result as EV(EXP,NOUNS); except that it can be faster
and use less storage.  It also can be used in translated code, where
EV may cause problems.  Note that it is called APPLY_NOUNS, not
"EV_NOUNS", because what it does is to apply the rules corresponding to
the noun-form operators, which is not evaluation.
.endfunction

.function(VERBIFY,f)
returns the function name 2f1 in its verb form.

.endfunction

.function(BOX,exp)
returns 2exp1 enclosed in a box. The box is actually part of the expression. BOX(2exp,label1) encloses 2exp1 in a labeled box.  2label1 is a name which will be truncated in display  if it is too long.  Simplification will occur within and outside of a BOXed expression but simplifications that require interactions across the box boundary will not take place.


$var<BOXCHAR/""> - is the character used to draw the box in this and in the DPART and
LPART functions.
.endfunction

.function(DPART,|exp, n1, ..., nk|)
selects the same subexpression as PART, but instead of just returning that
subexpression as its value, it returns the whole expression with the selected
subexpression displayed inside a box.  The box is actually part of the expression.

.example group
(C1) DPART(X+Y/Z**2,1,2,1);

                       Y
(D1)                  ---- + X
                         2
                     """""
                     " Z "
                     """""

.end
.endfunction

.function(LPART,|label, exp, n1, ..., nk|)
is similar to DPART but uses a labeled box. A labeled box is similar to the one
produced by DPART but it has a name in the top line.

.endfunction

.function(REMBOX,|exp, arg|)
removes boxes from 2exp1 according to 2arg1.  If 2arg1 is
UNLABELED then all unlabeled boxes are removed.  If 2arg1 is
the name of some label then only boxes with that label are removed.
If 2arg1 is omitted then all boxes labeled and unlabeled are
removed.

.endfunction
.subsec (The Substitution Functions,substfuns)

.function(SUBST,|a, b, c|)
substitutes 2a1 for all occurrences of 2b1 in 2c1.  2b1 must be an atom or a complete
subexpression of 2c1.  For example, X+Y+Z is a complete subexpression of
2*(X+Y+Z)/W while X+Y is not. When 2b1 does not have these characteristics,
one may sometimes use SUBSTPART or RATSUBST (see below).  Alternatively, if
2b1 is of the form e/f then one could use SUBST(a*f,e,c) while if 2b1 is of
the form e**(1/f) then one could use SUBST(a**f,e,c).   The SUBST command also discerns the X^Y  in X^(-Y) so that SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.
.skip
2a1 and 2b1 may also be operators of an expression (enclosed in "s) or they may be function names.  If one wishes to substitute for the independent variable in derivative forms then the AT function (see below) should be used.

SUBST(2eq1,exp1) or SUBST([2eq11,...,2eqk1],2exp1) are other permissible
forms. The 2eqi1 are equations indicating substitutions to be made.  For each
equation, the right side will be substituted for the left in the expression
2exp1.

For expressions in CRE representation $see<rep>, SUBST, like many of MACSYMA's general simplification commands, works on the RATDISREPed form of the expression.

$var<DERIVSUBST/FALSE> if TRUE permits substitutions such as
SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2)); to return 'DIFF(X,T).

$var<EXPTSUBST/FALSE> if TRUE permits substitutions such as Y for %E**X in %E**(A*X) to
take place.

$var<OPSUBST/TRUE> if FALSE, SUBST will not attempt to
substitute into the operator of an expression.  E.g. (OPSUBST:FALSE,
SUBST(X^2,R,R+R[0])); will work.

.example
(C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
.begin group
                                 2
(D1)                    Y + X + A
.end

(C2) SUBST(-%I,%I,A+B*%I);
(D2)                             A - %I B

.begin group fill indent 0,0
1(Note that C2 is one way of obtaining
the complex conjugate of an analytic expression.)  The following
examples illustrate the difference between substitution (as performed
by SUBST) and binding (as performed by $fun<EV>).
.end

(C3) SUBST(X=0,DIFF(SIN(X),X));

(D3)                           1

(C4) DIFF(SIN(X),X),X=0;
Non-variable 2nd arg to DIFF : 0

.BEGIN GROUP

(C5) MATRIX([A,B],[C,D]);
                                [ A  B ]
(D5)                            [      ]
                                [ C  D ]

(C6) SUBST("[",MATRIX,%);
(D6)                        [[A, B], [C, D]]
.END

.end
.endfunction

.function(RATSUBST,|a, b, c|)
substitutes 2a1 for 2b1 in 2c1.  2b1 may be a sum, product, power, etc. 
RATSUBST knows something of the meaning of expressions whereas SUBST does a
purely syntactic substitution.  Thus SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas
RATSUBST would return Z+A.


$var<RADSUBSTFLAG/FALSE> if TRUE permits RATSUBST to make
substitutions such as U for SQRT(X) in X.

.example 
.begin group
(C1) RATSUBST(A,X*Y^2,X^4*Y^8+X^4*Y^3);

                  3      4
(D1)           A X  Y + A
.end

(C2) 1 + COS(X) + COS(X)^2 + COS(X)^3 + COS(X)^4;
.begin group
            4         3         2
(D2)     COS (X) + COS (X) + COS (X) + COS(X) + 1
.end

(C3) RATSUBST(1-SIN(X)^2,COS(X)^2,%);
.begin group
            4           2                     2
(D3)     SIN (X) - 3 SIN (X) + COS(X) (2 - SIN (X)) + 3
.end

.end
.endfunction

.function(LRATSUBST,|list,exp|)
is analogous to SUBST(2list_of_equations,exp1)
except that it uses RATSUBST instead of SUBST.  The first argument of
LRATSUBST must be an equation or a list of equations identical in
format to that accepted by SUBST (see above).  The
substitutions are made in the order given by the list of equations,
that is, from left to right.
.example
(C1) LRATSUBST([A^2=B,C^2=D],(A+E)*C*(A+C));
(D1)                       (D + A C) E + A D + B C

(C2) LRATSUBST(A^2=B,A^3);
(D2)                                 A B
.end
.endfunction

.function(FULLRATSUBST,|a,b,c|)
is the same as RATSUBST except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.
FULLRATSUBST will also accept its arguments in the format of
LRATSUBST.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.
.example
(C1) RATSUBST(B*A,A^2,A^3);
                                      2
(D1)                                 A  B

(C2) FULLRATSUBST(B*A,A^2,A^3);
                                        2
(D2)                                 A B

(C3) FULLRATSUBST([A^2=B,B^2=C,C^2=A],A^3*B*C);
(D3)                                  B

(C4) FULLRATSUBST(A^2=B*A,A^3);
                                        2
(D4)                                 A B
.end
Since FULLRATSUBST goes over the expression recursively, care should
be taken lest infinite recursion cause the calculation to err out with
"REGPDL overflow".
.endfunction

.function(SUBSTPART,|x, exp, n1, ..., nk|)
substitutes 2x1 for the subexpression picked out by the rest of the arguments as in
PART.  It returns the new value of 2exp1. 
.bcon
2x1 may be some operator to be
substituted for an operator of 2exp1.  In this case it is enclosed in "s
(E.g. C4 below, or SUBSTPART("+",A*B,0); -> B + A).

.example
(C1) 1/(X^2+2);
.begin group
                                    1
(D1)                              ------
                                   2
                                  X  + 2
.end

(C2) SUBSTPART(3/2,%,2,1,2);
.begin group
                                    1
(D2)                             --------
                                  3/2
                                 X    + 2
.end

(C3) A*X+F(B,Y);
(D3)                          A X + F(B, Y)

(C4) SUBSTPART("+",%,1,0);
(D4)                         X + F(B, Y) + A

(C5) X^2 + X + 1$

(C6) SUBSTPART("[",%,0);
                                    2
(D6)                              [X , X, 1]


.end
.endfunction

.function(SUBSTINPART,|x, exp, n1, ...|)
is like SUBSTPART but works on the internal representation of 2exp1.

.example
(C1) X.'DIFF(F(X),X,2);
.begin group
                                   2
                                  d
(D1)                         X . (--- F(X))
                                    2
                                  dX
.end

(C2) SUBSTINPART(D^2,%,2);
.begin group
                                      2
(D2)                             X . D
.end

(C3) SUBSTINPART(F1,F[1](X+1),0);

(D3)                            F1(X + 1)

.end
.endfunction

.function(SUBLIS,|list,expr|)
allows multiple substitutions into an expression in parallel.
SUBLIS([2sym1 = exp1 , sym2 = exp2 , ...1], 2form1); Substitutes
for each occurrence of 2symi1 in form the appropriate 2expi1.  A
2sym1 MUST be a symbol.  An 2exp1 may be any expression.  2Form1
may be any expression. The new expression, with appropriate
substitutions made, is the value returned.

$var<SUBLIS_APPLY_LAMBDA/TRUE> controls whether LAMBDA's 
substituted are applied in simplification after the SUBLIS or whether you 
have to do an EV to get things to apply. TRUE means do the application.

SUBLIS will preserve sharing where possible. eg, SUBLIS([A=B],C+D);
returns a pointer to the original C+D since no substitution is needed.
SUBLIS does substitutions in parallel. eg, SUBLIS([A=B,B=A],SIN(A)+COS(B)); 
returns SIN(B)+COS(A).
SUBLIS will preserve CRE form, too. eg, 
.example

(C1) RAT(X^3+A*X+B)$
(C2) SUBLIS([A=B,B=A],%);
                               3
(D2)/R/                       X  + B X + A
.end continue
If a form is in CRE form, RATDISREP is called on it,
the substitution is done and if there is no change, the
original CRE form is returned; if there was a change, RAT is called
on the result of the substitution to return the CRE form.
.endfunction
.skip 3;
.begin group
.once center
2Additional1 2Information1

.skip 1
If the last argument to a Part function is a list of indices then several
subexpressions are picked out, each one corresponding to an index of the list.  Thus
PART(X+Y+Z,[1,3]) is Z+X.

$var<PIECE/> holds the last expression selected when using the Part functions.
It is set during the execution of the function and thus may be referred to in the
function itself as shown below.

If $var<PARTSWITCH/FALSE> is set to TRUE then END is returned when a selected
part of an expression does not exist, otherwise an error message is given.
.end

.example
(C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;

.begin group
            3         2       2            3
(D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1
.end

(C2)  PART(D1,2,[1,3]);

.begin group
                  2
(D2)          54 Y
.end

(C3)  SQRT(PIECE/54);

(D3)            ABS(Y)

(C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);

.begin group
                          3
(D4)           (3 Y + 2 X) + Y + X + 1
.end

(C5) 1/X+Y/X-1/Z;
.begin group
                                 1   Y   1
(D5)                           - - + - + -
                                 Z   X   X
.end

(C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);

.begin group
                                Y + 1   1
(D6)                            ----- - -
                                  X     Z
.end

.end

.function(ATVALUE,|form, list, value|)
enables the user to assign the boundary value 2value1 to 2form1 at the points specified by 2list1.

.example
(C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$
.end

The 2form1 must be a function, f(v1,v2,...) , or a derivative, DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional arguments explicitly appear  (ni is the order of differentiation with respect vi).

The 2list1 of equations determine the "boundary" at which the 2value1 is given; 2list1 may be a list of equations, as above, or a single equation,  vi = exp.

The symbols @1, @2,... will be used to represent the functional variables v1,v2,... when atvalues are displayed.

PRINTPROPS([2f1, f2,*...], ATVALUE)
will display the atvalues of the functions 2f1,f21,... as specified in previously
given uses of the ATVALUE function. $see<MACSYMA!properties>  If the list contains just one
element then the element can be given without being in a list.  If a first argument
of ALL is given then atvalues for all functions that have them will be displayed.

.endfunction

.function(AT,|exp, list|)
will evaluate 2exp1 (which may be any expression) with the variables assuming
the values as specified for them in the 2list1 of equations or the single
equation similar to that given to the ATVALUE function.  If a subexpression
depends on any of the variables in 2list1 but it hasn't had an atvalue
specified and it can not be evaluated then a noun form of the AT will be returned
which will display in a two-dimensional form.

.example
(C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2);

.begin group
                                     2
(D1)                                A
.end

(C2) ATVALUE('DIFF(F(X,Y),X),X=0,Y+1);

(D2)                              @2 + 1

(C3) PRINTPROPS(ALL,ATVALUE);
.begin group
                                  !
                      D           !
                     --- F(@1, @2)!       = @2 + 1
                     D@1          !
                                  !@1 = 0

                                        2
                             F(0, 1) = A
.end

(D3)                               DONE

(C4) DIFF(4*F(X,Y)**2-U(X,Y)**2,X);

.begin group
                   d                        d
(D4)    8 F(X, Y) (-- F(X, Y)) - 2 U(X, Y) (-- U(X, Y))
                   dX                       dX
.end

(C5) AT(%,[X=0,Y=1]);
.begin group
                                         !
               2               d         !
(D5)       16 A  - 2 U(0, 1) ( -- U(X, Y)!            )
                               dX        !
                                         !X = 0, Y = 1
.end
.end
.endfunction

.subsec (More Functions for Part Extraction,extracting!expressions)

.function(LISTOFVARS,exp)
yields a list of the variables in 2exp1.


$var<LISTCONSTVARS/FALSE> - if TRUE will cause LISTOFVARS to include %E,
%PI, %I, and any variables declared constant
$see<property!specification> in the list it returns if they appear in
2exp1.  The default is to omit these.

$var<LISTDUMMYVARS/TRUE> - if FALSE, "dummy variables" in the
expression will not be included in the list returned by LISTOFVARS.
"Dummy variables" are mathematical things like the index of a sum or product, the
limit variable, and the definite integration variable.

.example group
(C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));

(D1)                            [ G, A, X, Y]

(C2) LISTOFVARS('SUM(F(I),I,0,N));
(D2)                                [I, N]

(C3) LISTDUMMYVARS:FALSE$

(C4) LISTOFVARS('SUM(F(I),I,0,N));
(D4)                                 [N]
.end
.endfunction

.function(COEFF,|exp, v, n|)
obtains the coefficient of 2v1**2n1 in 2exp1.  2n1 may be
omitted if it is 1.  2v1 may be an atom, or complete subexpression
of 2exp1 e.g., X, SIN(X), A[I+1], X+Y, etc. (In the last case the
expression (X+Y) should occur in 2exp1).  For example, X+Y is a
complete subexpression of (X+Y)*(C+D+E) but C+D is not.  Similarly,
X*Y is a complete subexpression of X*Y + C*D*E, but C*D is not.
Sometimes it may be necessary to expand or factor 2exp1 in order to
make 2v^n1 explicit.  This is not done automatically by COEFF.
(Also see the RATCOEF command.)

.example group
(C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));

(D1)                         2 A + 1 = 5

(C2) COEFF(Y+X*%E**X+1,X,0);
(D2)                            Y + 1

.end
.endfunction

.function(RATCOEF,|exp, v, n|)
returns the coefficient, C, of the expression 2v1^2n1 in the
expression 2exp1.  2n1 may be omitted if it is 1.  C will be free
(except possibly in a non-rational sense) of the variables in 2v1.
If no coefficient of this type exists, zero will be returned.  RATCOEF
expands and rationally simplifies its first argument and thus it may
produce answers different from those of COEFF which is purely
syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas COEFF
returns 1.  RATCOEF(2exp,v1,0), viewing 2exp1 as a sum, gives a
sum of those terms that do not contain 2v1.  If 2v1 occurs to any
negative powers, RATCOEF should not be used.  Since 2exp1 is
rationally simplified before it is examined, coefficients may not
appear quite the way they were envisioned.

.example group
(C1) S:A*X+B*X+5$

(C2) RATCOEF(S,A+B);

(D2)                               X

.end
.endfunction

.function(BOTHCOEF,|exp, var|)
returns a list whose first member is the coefficient of 2var1 in
2exp1 (as found by RATCOEF if 2exp1 is in CRE form otherwise by
COEFF) and whose second member is the remaining part of 2exp1.  That
is, [A,B] where 2exp1=A*2var1+B.

.example group
(C1) ISLINEAR(EXP,VAR):=BLOCK([C],
        C:BOTHCOEF(RAT(EXP,VAR),VAR),
        IS(FREEOF(VAR,C) AND C[1]#0))$

(C2) ISLINEAR((R**2-(X-R)**2)/X,X);

(D2)                              TRUE

.end
.endfunction

.function(ISOLATE,|exp, var|)
returns 2exp1 with those subexpressions that are sums and which do
not contain 2var1 replaced by intermediate expression labels (these
being atomic symbols like E1, E2, ...). This is often useful to avoid
unnecessary expansion of subexpressions that do not contain the
variable of interest.  Since the intermediate labels are bound to the
subexpressions they can all be substituted back by evaluating the
expression in which they occur.  (See also the $fun<DISOLATE> function
in the SHARE directory.)

$var<EXPTISOLATE/FALSE> if TRUE will cause ISOLATE to examine exponents of
atoms (like %E) that contain 2var1.

.example
(C1) (A+B)^4*(1+X*(2*X+(C+D)^2));

.begin group
                           4                  2
(D1)                (B + A)  (X (2 X + (D + C) ) + 1)
.end

(C2) ISOLATE(%,X);

.begin group
                                        2
(E2)                             (D + C)
.end

.begin group
                                        4
(E3)                             (B + A)
.end

(D3)                      E3 (X (2 X + E2) + 1)

(C4) RATEXPAND(D3)$

(C5) EV(%);

.begin group
               4  2          4        2            4
(D5)  2 (B + A)  X  + (B + A)  (D + C)  X + (B + A)
.end

(C6) (A+B)*(X+A+B)^2*EXP(X^2+A*X+B);
.begin group
                                           2
                                      2   X  + A X + B
(D6)               (B + A) (X + B + A)  %E
.end

(C7) ISOLATE(%,X),EXPTISOLATE:TRUE;

(E7)                              B + A

.begin group
                                     B
(E8)                               %E
.end

.begin group
                                           2
                                      2   X  + A X
(D8)                    E7 E8 (X + E7)  %E

.end

.end
.endfunction

$var<ISOLATE_WRT_TIMES/FALSE> if set to TRUE, then ISOLATE
will also isolate wrt products.  E.g. compare both settings of the
switch on ISOLATE(EXPAND((A+B+C)^2),C); .

.function(PICKAPART,|exp,depth|)
will assign E labels to all subexpressions of 2exp1 down to the specified integer 2depth1. 
This is useful for dealing with large expressions and for automatically
assigning parts of an expression to a variable without having to use the Part
functions.

.EXAMPLE
(C1) EXP:(A+B)/2+SIN(X^2)/3-LOG(1+SQRT(X+1));
.begin group
                                              2
                                         SIN(X )   B + A
(D1)           - LOG(SQRT(X + 1) + 1) + ------- + -----
                                           3        2

.end
(C2) PICKAPART(%,1);

(E2)                    - LOG(SQRT(X + 1) + 1)
.begin group

                                    2
                               SIN(X )
(E3)                           -------
                                  3

.end
.begin group
                                B + A
(E4)                            -----
                                  2

.end
(D4)                         E4 + E3 + E2
.END
.endfunction

.function (REVEAL,|exp,depth|)
will display 2exp1 to the specified integer 2depth1 with
the length of each part indicated.  Sums will be displayed as
Sum(n) and products as Product(n) where n is the
number of subparts of the sum or product.  Exponentials will
be displayed as Expt.

.EXAMPLE
(C1) INTEGRATE(1/(X^3+2),X)$

(C2) REVEAL(%,2);

(D2)                   Negterm + Quotient + Quotient

(C3) REVEAL(D1,3);
                                     ATAN         LOG
(D3)                 - Quotient + ---------- + ----------
                                  Product(2)   Product(2)
.END
.endfunction

.function(NUMFACTOR,exp)
gives the numerical factor multiplying the expression 2exp1 which should be a
single term.  If the gcd of all the  term coefficients  in a sum is desired the CONTENT function $see<rational!functions> may be used.

.example
(C1) GAMMA(7/2);

.begin group
(D1)               15 SQRT(%PI)
                   ------------
                        8
.end

(C2) NUMFACTOR(%)
.begin group
                    15
(D2)                --
                     8
.end

.end
.endfunction

.function(HIPOW,|exp, v|)
gives the highest explicit exponent of 2v1 in 2exp1.  Sometimes it may be necessary
to expand 2exp1 since this is not done automatically by HIPOW.  Thus
HIPOW(Y**3*X**2+X*Y**4,X) is 2.

.endfunction

.function(LOPOW,|exp, v|)
gives the lowest exponent of 2v1 that explicitly appears in 2exp1.  Thus
LOPOW((X+Y)**2+(X+Y)**A,X+Y) is MIN(A,2).

.endfunction

.function(DERIVDEGREE,|exp, dv, iv|)
finds the highest degree of the derivative of the dependent
variable 2dv1 with respect to the independent variable 2iv1 occurring in 2exp1.

.example group
(C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
(C2) DERIVDEGREE(%,Y,X);
(D2)                           2

.end
.endfunction

.function(LHS,eqn)
returns the left side of the equation 2eqn1.  If 2eqn1 is not an equation, then LHS(2eqn1) = 2eqn1.

.endfunction

.function(RHS,eqn)
returns the right side of the equation 2eqn1.  If 2eqn1 is not an equation, then RHS(2eqn1) = 0.

.endfunction

.function(NUM,exp)
obtains the numerator, exp1, of the rational expression 2exp1 = exp1/exp2.

.endfunction

.function(DENOM,exp)
returns the denominator, exp2, of the rational expression 2exp1 = exp1/exp2.

.endfunction

The above two commands do not alter the internal representations of expressions and have the desirable property that for all expressions  NUM(exp)/DENOM(exp) is the same as exp.

.function(FIRST,exp)
yields the first part of 2exp1 which may result in the first element
of a list, the first row of a matrix, the first term of a sum, etc.  Note that FIRST and
the following two functions work on the form of 2exp1 that is displayed not the form
that is typed on input.  If the variable $var<INFLAG/FALSE> is set to TRUE however, these
functions will look at the internal form of 2exp1.  Note
that the simplifier re-orders expressions $see<simp>.  Thus FIRST(X+Y) will be X if
INFLAG is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same results).

.endfunction

.function(REST,|exp, n|)
yields 2exp1 with its first 2n1 elements removed if 2n1 is
positive and its last 2-n1 elements removed if 2n1 is negative.  If 2n1 is 1 it
may be omitted.  2Exp1 may be a list, matrix, or other expression.
If INFLAG:TRUE the internal form of 2exp1 will be used.
.endfunction

.function(LAST,exp)
yields the last part (term, row, element, etc.) of the 2exp1.
If INFLAG:TRUE the internal form of 2exp1 will be used.

.endfunction

.function(DELETE,|exp1, exp2|)
removes all occurrences of 2exp11 from 2exp21.  2Exp11 may
be a term of 2exp21 (if it is a sum) or a factor of 2exp21 (if it is a product).

.example group
(C1)  DELETE(SIN(X),X+SIN(X)+Y);

(D1)               Y + X

.end
.endfunction
.function(DELETE,|exp1, exp2, integer|)
removes the first 2integer1 occurrences of 2exp11 from 2exp21.
Of course, if there are fewer than 2integer1 occurrences of 2exp11
in 2exp21 then all occurrences will be deleted.
.endfunction
.function(LENGTH,exp)
gives the number of parts in the external (displayed) form of 2exp1.
For lists this is the number of elements, for matrices it is the
number of rows, and for sums it is the number of terms. (See DISPFORM)
The LENGTH command is affected by the $var<INFLAG/FALSE>.  So, e.g.
LENGTH(A/(B*C)); gives 2 if INFLAG is FALSE (Assuming EXPTDISPFLAG is
TRUE), but 3 if INFLAG is TRUE (the internal representation is
essentially A*B^-1*C^-1).

.endfunction

.function(NTERMS,exp)
gives the number of terms that 2exp1 would have if it were fully
expanded out and no cancellations or combination of terms occurred. Note that expressions
like SIN(E), SQRT(E), EXP(E), etc. count as just one term regardless of how many terms E has
(if it is a sum).

.endfunction

.subsec(Dealing with Complex Variables,complex!variables) 

The next several functions deal with complex variables.  The user should note the following conventions used in MACSYMA.

.begin indent 8,5; single space
1) all variables are assumed to take on real values exclusively unless
they are DECLAREd to be COMPLEX;

2) all functions are assumed to be real-valued unless they are
DECLAREd to be COMPLEX;

3) the complex argument is maintained in the half-open interval
(-6p1,6p1] whenever possible;

4) the argument of 0 is (arbitrarily) assumed to be 0, although
normally the user need not worry about this, since 0*%E^(%I*0) is
simplified to 0;

5) trigonometric functions are normally assumed to take on their
principal values.

.end

.function(REALPART,exp)
gives the real part of 2exp1. REALPART and IMAGPART will work on
expressions involving trigonometric and hyperbolic functions, as well as SQRT, LOG, and
exponentiation.

.endfunction

.function(IMAGPART,exp)
returns the imaginary part of the expression 2exp1.

.endfunction


The real or imaginary part of an expression of the form Z^N, where Z is not purely real, will be algebraic if  n <= MAXPOSEX; otherwise, for compactness,it will be expressed as ABS(Z)^N * COS(N*ARG Z)  or  ABS(Z)^N * SIN(N*ARG Z).

.function(RECTFORM,exp)
returns an expression of the form  A + B*%I, where A and B are purely real.

.endfunction

.function(POLARFORM,exp)
returns  R*%E^(%I*THETA) where R and THETA are purely real.

.endfunction

CAVEAT: Simplification of algebraic and transcendental functions of a complex variable may give rise to apparent factors, %I.  For example, SQRT(-C+D) may be transformed to %I*SQRT(C-D).

.function(CABS,exp) 
returns the complex absolute value (the complex modulus) of 2exp1.
.endfunction

.function(CARG,exp)
returns the argument (phase angle) of 2exp1.  Due to the conventions
and restrictions (described above), principal value cannot be
guaranteed unless 2exp1 is numeric.
.endfunction

.example

(C1) RECTFORM(SIN(2*%I+X));

(D1)                COSH(2) SIN(X) + %I SINH(2) COS(X)

(C2) POLARFORM(%);
.begin group
              2       2          2       2
(D2) SQRT(COSH (2) SIN (X) + SINH (2) COS (X))

                      %I ATAN2(SINH(2) COS(X), COSH(2) SIN(X))
                    %E
.end
(C3) RECTFORM(LOG(3+4*%I));
.begin group
                                             4
(D3)                       LOG(5) + %I ATAN(---)
                                             3
.end
(C4) POLARFORM(%);
.begin group

                                         
                                 
              2          2  4      %I ATAN2(ATAN2(4, 3), LOG(5))
(D4)  SQRT(LOG (5) + ATAN (---)) %E
                            3

.end
(C5) RECTFORM((2+3.5*%I)^.25),NUMER;

(D5)                    0.368258808 %I + 1.36826627

(C6) POLARFORM(D5);
.begin group
                                    0.262912527 %I
(D6)                     1.416957 %E

.end
.end


.next page
