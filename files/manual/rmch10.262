@Comment<(c) Copyright 1983 Massachusetts Institute of Technology>
@comment<Enhancements (c) Copyright 1983 Symbolics, Inc.>
@chapter(Utility, Input-Output, and Display Functions)
@label(utility!functions)

@Section[Debugging Functions]
@Label[debugging]

The functions in this section permit the user to examine his MACSYMA
environment and to obtain debugging information.  Further detail is
given in section @Ref[debugmac].

@begin(function)
@fcn[Name="TRACE", Args="name1, name2, ..."]
gives a trace printout whenever the functions mentioned are
called. TRACE() prints a list of the functions currently under TRACE.

@fcn[Name="UNTRACE", Args="name1, ..."]
removes tracing invoked by the TRACE function.  UNTRACE() removes
tracing from all functions.

@fcn[Name="DECLARE", Args="[var1, var2, ...], BINDTEST"]
causes MACSYMA to give an error message whenever any of the @i[vari]
occur unbound in a computation.

@fcn[Name="BREAK", Args="arg1, ..."]
evaluates and prints its arguments then enters a MACSYMA break loop.
@end(function)

The following functions make available to the user debugging
features used by systems programmers.  These tools are powerful, and
although some conventions are different from the usual macsyma level
it is felt their use is very intuitive.  [Some printout may be verbose
for slow terminals, there are switches for controlling this.]  These
commands were most useful for the user who must debug translated
macsyma code.  For a more complete discussion (see Section @Ref[debugmac]).

@begin(function)
@fcn[Name="DEBUG", Args=""]
Starts up a Lisp debugging break.

@fcn[Name="DEBUGPRINTMODE", Args=""]
returns current printing mode used by the DEBUG() function.

@fcn[Name="DEBUGPRINTMODE", Args="LISP"]
sets the current printing mode to lisp printing (the default),
DEBUGPRINTMODE(@i[x],@i[y]) where @i[x] is FALSE or a positive fixnum,
sets the maximum length to which LISP expressions are printed to
@i[x], and the maximum depth to @i[y].  This is used to abreviate
printout. FALSE means INFINITY.  DEBUGPRINTMODE(MACSYMA) sets it to
try printing expressions as they would be displayed at macsyma level,
except with more information and a slightly different notation.

@fcn[Name="LISPDEBUGMODE", Args="TRUE"]
will cause lisp errors to enter
normal lisp break points, from which it is normal to
call the lisp function (DEBUG) which prompts for single
character commands to move up and down the evaluation
stack at the point of the error.  See @Ref[debugmac] for details.
@end(function)

@i[Options and Variables]

%% @Index[%%] The value of the last computation performed while in a
(MACSYMA-BREAK).  Also may be used in compound statements in the nth
statement to refer to the value of the (n-1)th statement.  E.g.
F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%)); is in essence
equivalent to F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),
SUBST(3,X,%%)-SUBST(2,X,%%));
This will also work for communicating between the (n-1)th and nth
(non-atomic) BLOCK statements.

@var<DEBUGMODE (default: FALSE)> if TRUE causes MACSYMA to enter a
MACSYMA break loop whenever a MACSYMA error occurs. If DEBUGMODE:ALL
then the user may examine BACKTRACE for the list of functions
currently entered.

@var<REFCHECK (default: FALSE)> if TRUE causes a message to be printed
each time a bound variable is used for the first time in a
computation.

@var<PREDERROR (default: TRUE)> - If TRUE, an error message is
signalled whenever the predicate of an IF statement or an IS function
fails to evaluate to either TRUE or FALSE.  If FALSE, UNKNOWN is
returned instead in this case.  The PREDERROR:FALSE mode is not
supported in translated code.

@var<SETCHECK (default: FALSE)> - if set to a list of variables (which
can be subscripted) will cause a printout whenever the variables, or
subscripted occurrences of them, are bound (with : or :: or function
argument binding).  The printout consists of the variable and the
value it is bound to.  SETCHECK may be set to ALL or TRUE thereby
including all variables.  Note: No printout is generated when a
SETCHECKed variable is set to itself, e.g. X:'X.

@var<SETCHECKBREAK (default: FALSE)> - if set to TRUE will cause a
(MACSYMA-BREAK) to occur just prior to the binding of variables on the
SETCHECK list.  At this point, SETVAL @Index[SETVAL] holds the value
to which the variable is about to be set.  Hence, one may change this
value by resetting SETVAL.

BACKTRACE @Index[BACKTRACE] (when DEBUGMODE:ALL has been done) has as
value a list of all functions currently entered.  (see Chapter
@Ref[debugmac].)

@begin(function)
@fcn[Name="ERRORMSG", Args=""]
reprints the last error message.  This is very helpful if
you are using a display console and the message has gone off the
screen.  The variable ERROR is set to a list describing the error,
the first of it being a string of text, and the rest the objects in
question.

TTYINTFUN:LAMBDA([],ERRORMSG(),PRINT("")) will set up the user-interrupt
character (^U) to reprint the message.@index(TTYINTFUN)
@end(function)

@Section[Functions for Displaying]
@Label[display!functions]

@Begin(function)
@fcn[Name="DISPFUN", Args="f1, f2, ..."]
displays the definition of the user defined functions @i[f1, f2, ...]
which may also be the names of array associated functions, subscripted
functions, or functions with constant subscripts which are the same as
those used when the functions were defined. DISPFUN(ALL) will display
all user defined functions as given on the FUNCTIONS @Index[FUNCTIONS] and
ARRAYS @Index[ARRAYS] lists except subscripted functions with constant
subscripts.  E.g. if the user has defined a function F(X), then
DISPFUN(F); will display the definition.

@fcn[Name="FUNDEF", Args="functionname"]
returns the function definition associated with @i[functionname].
FUNDEF(@[fnname]); is similar to DISPFUN(@i[fnname]); except that
FUNDEF does not invoke display.

@fcn[Name="DISPRULE", Args="rulename1,rulename2,..."]
will display the rules with the names @i[rulename1, rulename2, ...]
as were given by DEFRULE @Index[DEFRULE], TELLSIMP @Index[TELLSIMP],
or TELLSIMPAFTER @Index[TELLSIMPAFTER] or a pattern defined by
DEFMATCH @Index[DEFMATCH].  For example, the first rule modifying SIN
will be called SINRULE1. (see @PageRef[patmatfun])) DISPRULE(ALL)
displays all rules.

@fcn[Name="DISPLAY", Args="exp1, exp2, ..."]
displays equations whose left side is @i[expi] unevaluated, and whose
right side is the value of the expression centered on the line.  This
function is useful in blocks and FOR statements in order to have
intermediate results displayed.  The arguments to DISPLAY are usually
atoms, subscripted variables, or function calls.  (see the DISP
function below.)
@Begin[Example]
(C1) B[1,2]:=X-X^2$
@hinge
(C2) DISPLAY(B[1,2]);
                                      2
                         B     = X - X
                          1, 2


(D2)                            DONE
@End[Example]

@fcn[Name="LDISPLAY", Args="exp1,exp2,..."]
is like DISPLAY but also generates intermediate labels.

@fcn[Name="DISP", Args="exp1,exp2, ..."]
is like DISPLAY but only the value of the arguments are displayed
rather than equations.  This is useful for complicated arguments which
don't have names or where only the value of the argument is of
interest and not the name.

@fcn[Name="LDISP", Args="exp1,exp2,..."]
is like DISP but also generates intermediate labels.

@fcn[Name="PRINT", Args="exp1, exp2, ..."]
evaluates and displays its arguments one after the other "on a line"
starting at the leftmost position.  If @i[expi] is unbound or is
preceded by a single quote or is enclosed in "s then it is printed
literally.  For example, PRINT("THE VALUE OF X IS ",X).  The value
returned by PRINT is the value of its last argument.  No intermediate
lines are generated.

@fcn[Name="DISPTERMS", Args="exp"]
displays its argument in parts one below the other.  That is, first
the operator of @i[expr] is displayed, then each term in a sum, or
factor in a product, or part of a more general expression is displayed
separately.  This is useful if @i[exp] is too large to be otherwise
displayed.  For example if P1, P2, ... are very large expressions then
the display program may run out of storage space in trying to display
P1+P2+... all at once.  However, DISPTERMS(P1+P2+...) will display P1,
then below it P2, etc.  When not using DISPTERMS, if an exponential
expression is too wide to be displayed as A^B it will appear as
EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).

@fcn[Name="REVEAL", Args="exp,depth"]
will display @i[exp] to the specified integer @i[depth] with the
length of each part indicated.  Sums will be displayed as Sum(n) and
products as Product(n) where n is the number of subparts of the sum or
product.  Exponentials will be displayed as Expt.
@Begin[Example]
(C1) INTEGRATE(1/(X^3+2),X)$
@hinge
(C2) REVEAL(%,2);
(D2)                    Negterm + Quotient + Quotient
@hinge
(C3) REVEAL(D1,3);
				     ATAN         LOG
(D3)                 - Quotient + ---------- + ----------
				  Product(2)   Product(2)
@end(Example)

@fcn[Name="TRUNC", Args="exp"]
causes exp which is in general representation to be
displayed as if its sums were truncated Taylor series.  E.g. 
@Begin[Example]
(C1) EXP1:X^2+X+1;
				   2
(D1)                              X  + X + 1
@hinge
(C2) EXP2:TRUNC(X^2+X+1);
				       2
(D2)                          1 + X + X  + . . .
@End[Example]
Note that IS(EXP1=EXP2); gives TRUE.

@fcn[Name="PLAYBACK", Args="arg"]
"plays back" input and output lines.  If @i[arg]=n (a number) the
last n expressions (Ci, Di, and Ei count as 1 each) are "played-back",
while if @i[arg] is omitted, all lines are.  If @i[arg]=INPUT then
only input lines are played back.  If @i[arg]=[m,n] then all lines
with numbers from m to n inclusive are played-back.  If m=n then [m]
is sufficient for arg.  @i[Arg]=SLOW places PLAYBACK in a slow-mode
similar to DEMO @Index[DEMO]'s (as opposed to the "fast" BATCH
@Index[BATCH]). This is useful in conjunction with SAVE @Index[SAVE]
or STRINGOUT @Index[STRINGOUT] (see below) when creating a
secondary-storage file in order to pick out useful expressions.  If
@i[arg]=TIME then the computation times are displayed as well as the
expressions.  If @i[arg]=GCTIME @Index[GCTIME] or TOTALTIME
@Index[TOTALTIME], then a complete breakdown of computation times are
displayed, as with SHOWTIME:ALL; @Index[SHOWTIME].  @i[arg]=NOSTRING
@Index[NOSTRING] displays all input lines when playing back rather
than STRINGing them.  If @i[arg]=GRIND (or if GRIND is set to TRUE)
then the display will be in a more readable format.  One may include
any number of options as in PLAYBACK([5,10],20,TIME,SLOW).

@fcn[Name="STRING", Args="exp"]
converts @i[exp] to MACSYMA's linear notation (similar to FORTRAN's)
just as if it had been typed in and puts @i[exp] into the buffer for
possible editing (in which case @i[exp] is usually Ci) (see sec.
@Ref[entered]).  The STRING'ed expression should not be used in a
computation.  Setting the @var<GRIND (default: FALSE)> switch to TRUE
will make STRING's output a little more readable.

@fcn[Name="STRINGOUT", Args="args"]
will output an expression to a file in a linear format.
(see @Ref[disk!storage])

@fcn[Name="GRIND", Args="arg"] 
prints out @i[arg] in a more readable format than the STRING command.
It returns a D-line as value.

@fcn[Name="FORTRAN", Args="exp"]
converts @i[exp] into a FORTRAN
linear expression in legal FORTRAN with 6 spaces inserted at the
beginning of each line,continuation lines,and ** rather than ^ for
exponentiation.  When the option @var<FORTSPACES (default: FALSE)> is
TRUE, the FORTRAN command fills out to 80 columns using spaces.  If
FORTRAN is called on a bound symbolic atom, e.g. FORTRAN(X); where
X:A*B has been done, then X={value of X}, e.g.  X=A*B will be
generated.  In particular, if e.g. M:MATRIX(...); has been done, then
FORTRAN(M); will cause the appropriate assignment statements to be
generated.

@fcn[Name="FORTRAN", Args="name=matrix"]
converts a MACSYMA @i[matrix] into a sequence of FORTRAN assignment
statements of the form
@Begin[Example]
   @i[name](i,j)=  <the i,j @i[matrix] element> 
@End[Example]
(If "name" is bound, FORTRAN('name=matrix);  may be necessary.)

The variable @var<FORTINDENT (default: 0)> controls the left margin
indentation of expressions printed out by the FORTRAN command.  0
gives normal indentation, which is 6 spaces, and positive values will
causes the expressions to be printed farther to the right.  This is
useful for structured FORTRAN code where the MACSYMA output is to be
inserted into nested DO loops.

@fcn[Name="DESCRIBE", Args="entity"]
prints out a description of @i[entity], which may be a command, switch,
flag, or concept.

@fcn[Name="EXAMPLE", Args="function"]
does a DEMO of relevant examples involving @i[function].
@end(function)

The following two functions are useful in programs which want to
generate neat output:

@begin(function)
@fcn[Name="CLEARSCREEN", Args=""]
Clears the screen.  The same as typing control-L.

@fcn[Name="PAUSE", Args=""]
Causes the display to "pause", printing "--Pause--" and
waiting for the usual "space" for "yes" to resume printing.  
Then it clears the screen and continues.
PAUSE("--Something else--"); will use "--Something else--" as the string
printed instead of "--Pause--".
PAUSE("--Something else--","--And some more--"); will use "--Something else--"
instead of "--Pause--" and "--And some more--" instead of "--Continued--".
@end(function)

@Section[Functions for Freeing Storage]
@Label[freeing!storage]

@begin(function)
@fcn[Name="REMOVE", Args="args"]
will remove some or all of the properties associated with variables or
functions. (see @Ref[property!specification])

@fcn[Name="REMFUNCTION", Args="f1, f2, ..."]
removes the user defined functions @i[f1, f2,...] from MACSYMA.  If
there is only one argument of ALL then all functions are removed.

@fcn[Name="REMVALUE", Args="name1, name2, ..."]
removes the values of user variables (which can be subscripted) from
the system.  If name is ALL then the values of all user variables are
removed.  Values are those items given names by the user as opposed to
those which are automatically labeled by MACSYMA as Ci, Di, or Ei.

@fcn[Name="REMARRAY", Args="name1, name2, ..."]
removes arrays and array associated functions and frees the storage
occupied.  If name is ALL then all arrays are removed.  It may be
necessary to use this function if it is desired to redefine the values
in a hashed array.

@fcn[Name="REMRULE", Args="function, rulename"]
will remove a rule with the name @i[rulename] from the @i[function]
which was placed there by DEFRULE @Index[DEFRULE], DEFMATCH
@Index[DEFMATCH], TELLSIMP @Index[TELLSIMP], or TELLSIMPAFTER
@Index[TELLSIMPAFTER].  If @i[rule-name] is ALL, then all rules will
be removed. (see example in Section @Ref[patmatfun].)

@fcn[Name="KILL", Args="arg1, arg2, ..."]
eliminates its arguments from the MACSYMA system.  If @i[argi] is a
variable (including a single array element), function, or array, the
designated item with all of its properties is removed from core. If
@i[argi]=LABELS then all input, intermediate, and output lines to date
(but not other named items) are eliminated. If @i[argi]=CLABELS then
only input lines will be eliminated; if @i[argi]=ELABELS then only
intermediate E-lines will be eliminated; if @i[argi]=DLABELS only the
output lines will be eliminated.
If @i[argi] is the name of any of the other information lists (the
elements of the MACSYMA variable INFOLISTS @Index[INFOLISTS]), then
every item in that class (and its properties) is KILLed and if
@i[argi]=ALL then every item on every information list previously
defined as well as LABELS is KILLed.  If @i[argi]=a number (say n),
then the last n lines (i.e. the lines with the last n line numbers)
are deleted.  If @i[argi] is of the form [m,n] then all lines with
numbers between m and n inclusive are killed. Note that KILL(VALUES)
or KILL(variable) will not free the storage occupied unless the labels
which are pointing to the same expressions are also KILLed.  Thus if a
large expression was assigned to X on line C7 one should do KILL(D7)
as well as KILL(X) to release the storage occupied.

KILL(ALLBUT @Index[ALLBUT](@i[name1,...,namek])) will do a KILL(ALL) except it
will not KILL the names specified.  (Note: name@i[i] means a name such
as U, V, F, G, not an infolist such as FUNCTIONS.)

KILL removes all properties from the given argument; thus KILL(VALUES)
will kill @u[all] properties associated with @u[every] item on the VALUES
list.  KILL always returns the value "DONE" even if the named item
doesn't exist (see @Ref[property!specification]).

The "REMOVE" functions (REMVALUE @Index[REMVALUE],REMFUNCTION
@Index[REMFUNCTION], REMARRAY @Index[REMARRAY],REMRULE
@Index[REMRULE]) remove a @u[specific] property.  These functions return
a list of names or FALSE (if the specific argument doesn't exist).

MACSYMA options may not be KILLed.  The user may do RESET() (see
@Ref[miscfun]) to reset MACSYMA options to their default values.

The error message "NO CORE - FASLOAD" results when either too many
FASL files have been loaded in or when allocation level has gotten too
high.  Note that once this occurs, KILLing expressions will not help.
In either of these cases, no amount of killing will cause the size of
these spaces to decrease.  Killing expressions only causes some spaces
to get emptied out but not made smaller.
@end(function)

@Section[Functions Which Reference Disk Files]
@Label[disk!storage]

@begin(function)
@fcn[Name="FILEDEFAULTS", Args=""]
returns the current default file specification for the commands
LOADFILE, BATCH, DELFILE, and DEMO.  This is the file specification
which will be tried for LOADFILE or BATCH if they are called with no
arguments.

FILEDEFAULTS('[@i<file>]) - sets the current file defaults to
@i[file].  The argument to FILEDEFAULTS is evaluated as it is
anticipated that the command will be used mainly in programs.  The
@i[file] need not be a real file, so one can use this function e.g.  if
one's real purpose is to set the "device" field back to "DSK", where
one does not care about the settings for the other fields.  E.g.
FILEDEFAULTS('[FN1,FN2,DSK,USER]); .

@var<CHANGE_FILEDEFAULTS (default: TRUE on PDP10 systems, and FALSE elsewhere)>.  Controls whether the user doing a LOADFILE or BATCH has
his file defaults changed to the file LOADFILEd or BATCHed.  The TRUE
setting is for people who like DDT-style file defaulting.  The FALSE
setting is for people who like the conventions of other operating
systems, who like LISP-style file defaulting, or who write packages
which do LOADFILEs or BATCHes which should not interfere with their
user's file defaults.

@var<FILE_STRING_PRINT (default: FALSE on MC, TRUE elsewhere)>.  If
TRUE, filenames are output as strings; if FALSE, as lists.  For
example, the message when an out of core file is loaded into
MACSYMA (e.g. the LIMIT package), appears on MC in list format as
@Begin[Example]
  LIMIT FASL DSK MACSYM being loaded
@End[Example]
and in string format as:
@Begin[Example]
  DSK:MACSYM;LIMIT FASL being loaded
@End[Example]
The string format is like the top level (DDT) file specifications.

@fcn[Name="FILE_TYPE", Args="filename"]
returns FASL, LISP, or MACSYMA, depending on
what kind of file @i[filename] is.  This is helpful when you are not
sure whether to use LOADFILE or BATCH.  (See the LOAD function below.)

@fcn[Name="LOAD", Args="file-specification"]
 takes one argument, a filename represented as a "string" (i.e. inside
quotation marks), as a list (i.e. inside square brackets), or (on ITS)
a first filename.  It then locates and loads the indicated file.  If
no directory is designated, it searches the SHARE@i[i] directories and
any other directories listed in the 
@var<FILE_SEARCH (default: SHARE@i[i])>
variable and loads the indicated file.  LOAD(EIGEN)
will load the eigen package without the need for the user to be aware
of the details of whether the package was compiled, translated, saved,
or fassaved, i.e. LOAD will work on both LOADILEable and BATCHable
files.  Note: LOAD will use BATCHLOAD @Index[BATCHLOAD] if it finds
the file is BATCHable (which means that it will BATCH the file in
"silently" without terminal output or labels).

@fcn[Name="LOADFILE", Args="fn1, fn2, DSK, directory"]
loads a file as designated by its arguments.  This function may be
used to bring back quantities that were stored from a prior MACSYMA
session by use of the SAVE or STORE functions.  If DSK and
@i[directory] are omitted then the last directory seen (initially the
same as the user's login name or USERS if the user has no file
directory) will be used.  If DSK and @i[directory] are omitted,
@i[fn2] may also be omitted if @i[fn1] > is to be loaded in (where >
follows the conventions of ITS's file system).  @i[Fn1] @i[fn2] must
be a file of LISP functions and expressions, not of MACSYMA command
lines, in which case BATCH or DEMO is to be used.  (See Chapter
@Ref[batchap].)

@fcn[Name="FILE_SEARCH", Args="filename"]
searches on those directories and devices
specified by the FILE_SEARCH variable, and returns the name of the
first file it finds.  This function is invoked by the LOAD function,
which is why LOAD("FFT") finds and loads DSK:SHARE;FFT FASL.  You may
do FILE_SEARCH:CONS("dsk:dir\;",FILE_SEARCH); to add other directories
to the search rules.

@fcn[Name="DELFILE", Args="file-specification"]
will delete the file given by the @i[file-specification].

@fcn[Name="BATCH", Args="file-specification"]
reads in and evaluates MACSYMA command lines from a file. (See Chapter
@Ref[batchap].)

@fcn[Name="DEMO", Args="file-specification"]
same as BATCH but pauses after each command line and continues when a
the appropriate character is typed.  On MC and TOPS-20 this is a
space and anything else will terminate the demo.  On Multics and UNIX
systems where a carriage return is required after each command, a
carriage return is used to tell the demo to proceed, and anything
else followed by a carriage return terminates the demo.
(See Chapter @Ref[batchap].)

@fcn[Name="BATCON", Args="argument"]
continues BATCHing in a file which was interrupted (see @Ref[batconfun]).

@fcn[Name="BATCHLOAD", Args="file-specification"]
Batches in the file silently without
terminal output or labels.  (See Chapter @Ref[batchap].)

@fcn[Name="WRITEFILE", Args="@r(DSK), directory"]
opens a file for writing.  On a Lisp Machine one uses
WRITEFILE("filename").  All interaction between the user and MACSYMA
is then recorded in this file, just as it is on the console.  Such a
file is a transcript of the session, and is not reloadable or
batchable into MACSYMA again.  See the CLOSEFILE command below for
more information.

@fcn[Name="APPENDFILE", Args="filename1, filename2, @r(DSK), directory"]
is like WRITEFILE(DSK,@i[directory]) but appends
to the file whose name is specified by the first two arguments.
A subsequent CLOSEFILE will delete the original file and
rename the appended file.

@fcn[Name="CLOSEFILE", Args="filename1, filename2"]
closes a file opened by WRITEFILE and gives it the name @i[filename1]
@i[filename2].  (On a Lisp Machine one need only say CLOSEFILE();.)
Thus to save a file consisting of the display of all input and output
during some part of a session with MACSYMA the user issues a
WRITEFILE, transacts with MACSYMA, then issues a CLOSEFILE.  The user
can also issue the PLAYBACK function after a WRITEFILE to save the
display of previous transactions.  (Note that what is saved this way
is a copy of the @i[display] of expressions not the expressions
themselves).  To save the actual expression in internal form the SAVE
function may be used.  The expression can then be brought back into
MACSYMA via the LOADFILE function.  To save the expression in a linear
form which may then be BATCHed in later, the STRINGOUT function is
used. (see below)

@fcn[Name="STRINGOUT", Args="file-specification, A1, A2, ..."]
outputs to a file given by @i[file-specification]
([filename1,filename2,DSK, directory]) the values given by
@i[A1,A2],.. in a MACSYMA readable format.  The @i[file-specification]
may be omitted, in which case the default values will be used. (see
@PageRef[autostor] - C) The @i[Ai] are usually C labels or may be INPUT
meaning the value of all C labels.  Other options are FUNCTIONS which
will cause all of the user's function definitions to be strungout
(i.e. all those retrieved by DISPFUN(ALL)), and VALUES, which will
STRINGOUT all variables to which the user has assigned values. @i[Ai]
may also be a list [m,n] which means to stringout all labels in the
range m through n inclusive.  This function may be used to create a
file of FORTRAN statements by doing some simple editing on the
strungout expressions.  Alternatively, the function FORTRAN @Index[FORTRAN] can
be used (see @Ref[display!functions]).  If the @var<GRIND (default: FALSE)>
switch is set to true, then "grind" format will be used
instead of "string" format in the file, which may give a more easily
readable result for long function definitions.  Note: STRINGOUT may be
done while a WRITEFILE is in process.

@fcn[Name="SAVE", Args="args"]
saves quantities described by its arguments on disk and keeps them in
core also. (see @Ref[explicitstor]).  The arg's are the expressions to
be SAVEd.  ALL is the simplest, but note that saving ALL will save the
entire contents of your MACSYMA, which in the case of a large
computation may result in a file which is too large to be reloaded.
VALUES, FUNCTIONS, or any other items on the INFOLISTS may be SAVEd,
as may functions and variables by name.  C and D lines may also be
saved, but it is better to give them explicit names, which may be done
in the command line, e.g.  SAVE(RES1=D15); Files saved with SAVE
should be reloaded with LOADFILE.  MACSYMA will select a file name
for you, using your home directory.  SAVE returns a list of the form
[@i<name of file>,@i<size of file in blocks>,...] where ... are the things
saved.  Warnings are printed out in the case of large files, or if an
empty file is accidently generated. Note: SAVE may be used while a
WRITEFILE is in progress.

SAVE([@i<optional file spec>],@i[args])
allows you to name the SAVE file.  The optional file spec is in the
form NAME1,NAME2,DSK,DIRECTORY on MC, or a pathname surrounded by
double quotes (e.g. "/usr/jamu/funcs.l") on other systems, and is
always enclosed in square brackets, e.g.  [JAMU,FUNCS,DSK,USERS2] or
["/usr/jamu/funcs.l"].

@fcn[Name="STORE", Args="args"]
same as SAVE but doesn't retain quantities in core. (see @Ref[explicitstor]).
Note:  STORE may be used while a WRITEFILE is in progress.

@fcn[Name="FASSAVE", Args="args"]
is similar to SAVE but produces a FASL file in which the sharing of
subexpressions which are shared in core is preserved in the file
created.  Hence, expressions which have common subexpressions will
consume less space when loaded back from a file created by FASSAVE
rather than by SAVE.  See also the COLLAPSE @Index[COLLAPSE] command below.
Note:  FASSAVE may be used while a WRITEFILE is in progress.

@fcn[Name="UNSTORE", Args="name1, ..."]
brings the named expressions into core that were stored away by use of
the STORE function in the current MACSYMA. (see @Ref[explicitstor]).

@fcn[Name="RESTORE", Args="file-specification"]
reinitializes all quantities filed away by a use of the SAVE
or STORE functions, in a prior MACSYMA session, from the file given by
@i[file-specification] without bringing them into core. (see @Ref[savmacsym]).
Note: RESTORE will not work on files written with FASSAVE.

@fcn[Name="REMFILE", Args=""]
removes files created by the secondary storage scheme in the MACSYMA
under use (see @Ref[autostor]).  REMFILE(ALL) and REMFILE(TRUE) do what
REMFILE() does and in addition delete any files which have been
created by the SAVE or STORE functions but which have not been
assigned names by the user.
@end(function)

@subsection(Functions for Referencing Files on the MC Machine)
@label(MCfuncs)

All of the functions in this section work only on the MIT-MC machine.

The following functions provide
some primitive file operations for MACSYMA Users from inside MACSYMA,
making it unnecessary to interact with the operating system:

@begin(function)
@fcn[Name="PRINTFILE", Args="file,name,dsk,directory"]
will print the specified file on your terminal.

@fcn[Name="LISTFILES", Args="dsk,username"]
will list your files for you.  If you use a shared directory such as
USERS or PLASMA, only your files--the ones with your login name as
first file name--will be shown.  The length and date of creation of
each file is also shown.  LISTFILES indicates
whether each file is stored on secondary disk and whether it
has been backed up to tape (an exclamation point appears if
it has not).  In order to list just the names of your files without the
length and date information, use QLISTFILES @Index[QLISTFILES] (Quick LIST Files)
with the same arguments as LISTFILES.

@fcn[Name="FILELENGTH", Args="name1,name2,directory"]
returns the length of the file argument
in blocks and fractional blocks.
There are five characters in a word and 1024 words in a disk block.
(So if it returns 5.6, the file is 6 blocks long, but the last block
is only 60% full.  This file would be 5.6*1024*5 (= 28672) characters
long.)  If the file named does not exist, an error message is printed,
and False is returned to permit easier recovery in a program.

@fcn[Name="RENAMEFILE", Args="oldname,newname"]
renames a file from @i[oldname]
to @i[newname]. 
Files may not be renamed across directories or devices. Both @i[oldname]
and @i[newname] must be on the same directory. Renaming a file to a filename
that already exists gives an error. You must explicitly DELFILE the
existing file first if that's what you want.  Both @i[oldname] and @i[newname]
must be list-type filespecs. E.g.
@Begin[Example]
(C1) RENAMEFILE([myold,file,dsk,foo],[mynew,file]);
(D1)                     [MYNEW,FILE,DSK,FOO]
@End[Example]
@end(function)

The following function may be useful when writing a "package" in
MACSYMA where you want to manipulate filenames and may need to merge
a partially specified user filename with default information from the
user's MACSYMA to produce an actual filename.

@begin(function)
@fcn[Name="FILENAME_MERGE", Args=""filename1","filename2",..."]
merges together filenames, using a "*" convention for unspecified
components of filenames, with the leftmost filenames getting
precedence.
@end(function)

The following functions offer information about the amount of disk
space available and the amount in use by any given user.

@begin(function)
@fcn[Name="DISKFREE", Args=""]
With no args or an arg of TRUE, will return the total
number of free blocks of disk space in the system.  With an arg of 0,
1, or 13, it will return the number of free blocks of diskspace on the
respective disk pack.  With an arg of SECONDARY or PRIMARY, it will
return the total number of free blocks of disk space on the secondary
or primary disk pack respectively.

@fcn[Name="DISKUSE", Args="username"]
returns the total number of disk blocks in use by a
user.  The result is of the form @i<n>*BLOCKS

@fcn[Name="PRINTDISKUSE", Args="username"]
displays in English information about a user's
disk usage.

@fcn[Name="FULLDISKUSE", Args="username"]
Returns a long list of info about the user's disk usage of
the form:
@Begin[Example]
  [["TOTAL FREE BLOCKS", [@i<pack-type>, @i<pack-number>, @i<n> BLOCKS],
			 [@i<pack-type>, @i<pack-number>, @i<n> BLOCKS], ...]
   ["DIRECTORY BLOCK USAGE", @i<directory-name>
			     ["PRIMARY", @i<n> BLOCKS],
			     ["SECONDARY", @i<n> BLOCKS]]
   ["USER BLOCK USAGE", @i<user-name>,
			[PRIMARY, @i<n> BLOCKS],
			[SECONDARY, @i<n> BLOCKS]]]
@End[Example]
If the user has his own directory, the last element of the list ("USER
BLOCK USAGE") is omitted since it would be the same as "DIRECTORY
BLOCK USAGE".
@Begin[Example]
	@i<pack-type> ::= "PRIMARY PACK" or "SECONDARY PACK"
	@i<pack-number> ::= a fixed point number
	@i<n> ::= a fixed point number
@End[Example]
Occurrences of "@i<n> BLOCKS" are in the form of a Macsyma multiplication
between a fixnum @i<n> and the Macsyma symbol BLOCKS.

If no name is supplied, it defaults to the current user's.
@end(function)

@Section[Ordering Functions]
@Label[ordering!functions]

Aside from declaring a variable to be constant or using options like
POWERDISP (see below), the only other way in which a user can alter
the ordering of parts of an expression is to set up special aliases
for variables which cause them to be alphabetically less than or
greater than any other variables.  Functions which do this are
described below.  This technique requires care because although the
names have been aliased, they display with their original name.  Aside
from the input/output phase the two names represent two different
symbols and thus expressions which contain both the original name and
the alias will not be simplified as the user desires.  This is shown
in the examples below.

@begin(function)
@fcn[Name="ORDERGREAT", Args="V1, ..., Vn"]
sets up aliases for the variables @i[V1, ..., Vn] such that

@i[V1] > @i[V2] > ... > @i[Vn] > any other variable not mentioned as an argument.

@fcn[Name="ORDERLESS", Args="V1, ..., Vn"]
sets up aliases for the variables @i[V1, ..., Vn] such that

@i[V1] < @i[V2] < ... < @i[Vn] < any other variable not mentioned as an argument. 

Thus the complete ordering scale is:

@begin(format)
numbers < numerical constants < declared constants < scalars

< first argument to ORDERLESS < ...
       < last argument to ORDERLESS < 

< variables which begin with A < ...
      < variables which begin with Z < 

< last argument to ORDERGREAT < ...
      < first argument to ORDERGREAT

< declared MAINVARS
@End[Format]

@fcn[Name="ORDERGREATP", Args="exp1,exp2"]
returns TRUE if @i[exp2] precedes @i[exp1] in the ordering induced by
the variable ordering described above.

@fcn[Name="ORDERLESSP", Args="exp1,exp2"]
returns TRUE if @i[exp1] precedes @i[exp2] in the ordering induced by
the variable ordering described above.

@fcn[Name="UNORDER", Args=""]
stops the aliasing created by the last use of the above ordering
commands.  ORDERGREAT and ORDERLESS may not be used more than one time
each without calling UNORDER.
@Begin[Example]
(C1) A^2+B*X;
                                        2
(D1)                             B X + A
@hinge
(C2) ORDERGREAT(A);
(D2)                               DONE
@hinge
(C3) A^2+B*X;
                                  2
(D3)                             A  + B X
@hinge
(C4) %-D1;
                                  2    2
(D4)                             A  - A
@hinge
(C5) UNORDER();
(D5)                               [A]
@End[Example]

@fcn[Name="SORT", Args="list,optional-predicate"]
sorts the @i[list] using a suitable @i[optional-predicate] of two
arguments (such as "<" or ORDERLESSP).  If the @i[optional-predicate]
is not given, then MACSYMA's built-in ordering predicate is used.

You may DECLARE @Index[DECLARE] variables to be MAINVAR
@Index[MAINVAR] The ordering scale for atoms then is essentially:
numbers < constants (e.g. %E,%PI) < scalars < other variables <
mainvars.  E.g. compare EXPAND((X+Y)@+[4]); with (DECLARE(X,MAINVAR),
EXPAND((X+Y)@+[4])); .  (Note: Care should be taken if you elect to
use the above feature.  E.g. if you subtract an expression in which X
is a MAINVAR from one in which X isn't a MAINVAR, resimplification
e.g. with EV(expression,SIMP) may be necessary if cancellation is to
occur.  Also, if you SAVE an expression in which X is a MAINVAR, you
probably should also SAVE X.)
@end(function)

@section(Miscellaneous Functions)
@label(miscfun)

@begin(function)
@fcn[Name="TIME", Args="Di1, Di2, ..."]
gives a list of the times in milliseconds taken to compute the @i[Di].

@fcn[Name="TIMEDATE", Args=""]
prints out the current date and time.

@fcn[Name="WHO", Args=""]
On those systems where such interaction with the operating system is possible,
prints out the currently logged in users.  Currently this is only the MIT-MC
system and Multics versions.

@fcn[Name="LOGOUT", Args=""]
On MIT-MC and Multics, causes the user to be logged out and all jobs
deleted.  This is useful when it is desired to BATCH in a file and
have the terminal logged out automatically when the computations are
finished.  (Equivalent to ^Z and :LOGOUT).  On other systems, LOGOUT();
works like QUIT(); below.

@fcn[Name="QUIT", Args=""]
kills the current MACSYMA but doesn't affect the user's other jobs.
(Equivalent to ^Z and :KILL on MIT-MC).  Note: on the TOPS-20 version of
MACSYMA QUIT(); halts the job, but does not kill it (that is, it's like
typing two control-C's).

@fcn[Name="TO_LISP", Args=""]
enters the LISP system under MACSYMA.  This is useful on
those systems where control-uparrow is not available for this
function (TOPS-20, Multics, and UNIX, for instance).

@fcn[Name="DDT", Args=""]
exits from MACSYMA to the operating system level.  (The same
as control-Z on ITS, or control-C on Tops-20.)

@fcn[Name="READ", Args="string1, ..."]
prints its arguments, then reads in and evaluates one expression.  For
example:  
@begin(example)
A:READ("ENTER THE NUMBER OF VALUES");
@end(example)
will print out
@begin(example)
ENTER THE NUMBER OF VALUES:
@end(example)
and wait expectantly for the user to type a number or something at it,
followed by a semi-colon.

@fcn[name="READONLY", Args="string1,..."]
prints its arguments, then reads in an expression (which in contrast
to READ is not evaluated).

@fcn[Name="DEFINE", Args="f(x1, ...), body"]
is equivalent to f(x1,...):=''body but when used inside functions it
happens at execution time rather than at the time of definition of the
function which contains it.  (see @ref[evaluation])

@fcn[Name="LOCAL", Args="v1, v2, ..."]
causes the variables @i[v1, v2,...] to be local with respect to all
the properties in the statement in which this function is used (see
@Ref[program!blocks]).  LOCAL may only be used in BLOCKs, in the body
of function definitions or LAMBDA expressions, or in the EV function
and only one occurrence is permitted in each.

@fcn[Name="ERROR", Args="arg1, arg2, ..."]
will evaluate and print its arguments and then will cause an error
return to top level MACSYMA or to the nearest enclosing ERRCATCH.
This is useful for breaking out of nested functions if an error
condition is detected, or wherever one can't type control-G.  The
variable ERROR is set to a list describing the error, the first of it
being a string of text, and the rest the objects in question.
ERRORMSG(); is the preferred way to get the last
error message printed out. @Index[ERRORMSG]

@var<ERRORFUN (default: FALSE)> - if set to the name of a function of
no arguments will cause that function to be executed whenever an error
occurs.  This is useful in BATCH files where the user may want his
MACSYMA killed or his terminal logged out if an error occurs.  In
these cases ERRORFUN would be set to QUIT or LOGOUT.

@fcn[Name="ERRCATCH", Args="exp1, exp2, ..."]
evaluates its arguments one by one and returns a list of the value of the last
one if no error occurs.  If an error occurs in the evaluation of any arguments,
ERRCATCH "catches" the error and immediately returns [] (the empty list).  This
function is useful in BATCH files where one suspects an error might occur which
would otherwise have terminated the BATCH if the error weren't caught.

@fcn[Name="CATCH", Args="exp1,...,expn"]
evaluates its arguments one by one; if the structure of the @i[expi]
leads to the evaluation of an expression of the form THROW(@i[arg]), then
the value of the CATCH is the value of THROW(@i[arg]).  This "non-local
return" thus goes through any depth of nesting to the nearest
enclosing CATCH.  There must be a CATCH corresponding to a THROW, else
an error is generated.  If the evaluation of the @i[expi] does not
lead to the evaluation of any THROW then the value of the CATCH is the
value of @i[expn].
@Begin[Example]
(C1) G(L):=CATCH(MAP(LAMBDA([X],
       IF X<0 THEN THROW(X) ELSE F(X)),L))$
@hinge
(C2) G([1,2,3,7]);
(D2) 			 [F(1), F(2), F(3), F(7)]
@hinge
(C3) G([1,2,-3,7]);
(D3) 				    - 3
@End[Example]
The function G returns a list of F of each element of L if L consists
only of non-negative numbers; otherwise, G "catches" the first
negative element of L and "throws" it up.

@fcn[Name="THROW", Args="exp"]
evaluates @i[exp] and throws the value back to the most recent CATCH.
THROW is used with CATCH as a structured nonlocal exit mechanism.

@fcn[Name="BREAK", Args="arg1, ..."]
will evaluate and print its arguments and will then cause a
(MACSYMA-BREAK) at which point the user can examine and change his
environment.  Upon typing EXIT; the computation resumes. (see Chapter
@Ref[debugmac])

@fcn[Name="RESET", Args=""]
causes all MACSYMA options to be set to their default values.  (Please
note that this does not include features of terminals such as LINEL
which can only be changed by assignment as they are not considered to
be computational features of MACSYMA.  See the TTY_INIT @Index[TTY_INIT]();
function for that purpose.)

@fcn[Name="%TH", Args="i"]
is the @i[i]th previous computation.  That is, if the next expression
to be computed is D(j) this is D(j-@i[i]).  This is useful in BATCH
files or for referring to a group of D expressions.  For example, if
SUM is initialized to 0 then FOR I:1 THRU 10 DO SUM:SUM+%TH(I) will
set SUM to the sum of the last ten D expressions.

@fcn[Name="CONCAT", Args="arg1, arg2, ..."]
evaluates its arguments and returns the concatenation of their values
resulting in a name or a quoted string (see @PageRef[names] and
@PageRef[quoted!strings]) the type being given by that of the first
argument.  Thus if X is bound to 1 and D is unbound then
CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.

@fcn[Name="GETCHAR", Args="a, i"]
returns the @i[i]th character of the
quoted string or atomic name @i[a].  This function is useful
in manipulating the LABELS list.

@fcn[Name="STATUS", Args="arg"]
will return miscellaneous status information about the user's MACSYMA
depending upon the @i[arg] given.  Permissible arguments and results
are as follows:
@begin(itemize)
TIME - the time used so far in the computation.

DAY - the day of the week.

DATE - a list of the year, month, and day.

DAYTIME - a list of the hour, minute, and second.

RUNTIME - accumulated cpu time times the atom "MSEC".

REALTIME - the real time (in sec) elapsed since the user started up
his MACSYMA.

GCTIME - the garbage collection time used so far in the current computation.

TOTALGCTIME - gives the total garbage collection time used in MACSYMA
so far.

FREECORE - the number of blocks of core your MACSYMA can expand before
it runs out of address space.  (A block is 1024 words.)  Subtracting
that value from 250*BLOCKS (the maximum you can get on MC) tells you
how many blocks of core your MACSYMA is using up.
(A MACSYMA with no "fix" file starts at approx. 191 blocks.)

FEATURE - gives you a list of system features. At present the list for
MC is: MACSYMA, NOLDMSG, MACLISP, PDP10, BIGNUM, FASLOAD, HUNK,
FUNARG, ROMAN, NEWIO, SFA, PAGING, MC, and ITS.  Any of these
"features" may be given as a second argument to STATUS(FEATURE,...);
If the specified feature exists, TRUE will be returned, else FALSE.
Note: these are system features, and not really "user related".
@end(itemize)
For information about your files, see the FILEDEFAULTS
@Index[FILEDEFAULTS](); command.

@fcn[Name="SSTATUS", Args="feature,package"]
- meaning SET STATUS.  It can be used to
SSTATUS(FEATURE,HACK_PACKAGE) so that STATUS(FEATURE,HACK_PACKAGE)
will then return TRUE.  This can be useful for package writers, to
keep track of what FEATURES they have loaded in.

@fcn[Name="ALARMCLOCK", Args="arg1, arg2, arg3"]
will execute the function of no arguments whose name is @i[arg3] when
the time specified by @i[arg1] and @i[arg2] elapses.  If @i[arg1] is
the atom "TIME" then @i[arg3] will be executed after @i[arg2] seconds
of real-time has elapsed while if @i[arg1] is the atom "RUNTIME" then
@i[arg3] will be executed after @i[arg2] milliseconds of cpu time. If
@i[arg2] is negative then the @i[arg1] timer is shut off.

@fcn[Name="LABELS", Args="char"]
takes a char C,D,or E as arg and generates a list of all
C-labels,D-labels, or E-labels, respectively.  (If you've generated
many E-labels via SOLVE, then FIRST(REST(LABELS(C))); reminds you what
the last C-label was.)  LABELS will take as argument any symbolic
name, so if you have reset INCHAR, OUTCHAR, or LINECHAR, it will
return the list of labels whose first character matches the first
character of the argument you give to LABELS.

@fcn[Name="ALIAS", Args="newname1, oldname1, newname2, oldname2, ..."] 
provides an alternate name for a (user or system) function, variable, array,
etc.  Any even number of arguments may be used.  Nouns are handled via aliases.

@fcn[Name="TTY_INIT", Args=""]
- ("initialize TTY") is an MC-only command of no
arguments which can be used if you change your TCTYP after starting up
a MACSYMA or when you reown a MACSYMA on a terminal with different
characteristics from the terminal from which the MACSYMA was disowned.
TTY_INIT(); informs MACSYMA of your terminal's new characteristics,
e.g.  linelength, pagesize, etc.
@end(function)

@section(Options and Variables for I/O, Status, and Display)
@label(ioptions)

@var<GRIND (default: FALSE)> if TRUE will cause the STRING
@Index[STRING], STRINGOUT @Index[STRINGOUT], and PLAYBACK
@Index[PLAYBACK] commands to use "grind" mode instead of "string"
mode.  For PLAYBACK, "grind" mode can also be turned on (for
processing input lines) by specifying GRIND as an option.

@var<DISPLAY2D (default: TRUE)> - if set to FALSE will cause the standard
display to be a string (1-dimensional) form rather than a display
(2-dimensional) form.  This may be of benefit for users on printing
consoles who would like to conserve paper.

@var<LINEDISP (default: TRUE)> - Allows the use of line graphics in the
drawing of equations on those systems which support them (e.g. the
Lisp Machine).  This can be disabled by setting LINEDISP to FALSE.  It
is automatically disabled during WRITEFILE.

@var<DISPLAY_FORMAT_INTERNAL (default: FALSE)> - if set to TRUE will cause
expressions to be displayed without being transformed in ways that
hide the internal mathematical representation.  The display then
corresponds to what the INPART command returns rather than the PART
command.  Examples:
@Begin[Example]
User       PART       INPART

a-b;      A - B     A + (- 1) B

            A            - 1
a/b;        -         A B
            B
                       1/2
sqrt(x);   SQRT(X)    X

           4 X          4
X*4/3;     ---          - X
            3           3
@End[Example]

@var<SHOWTIME (default: FALSE)> - if TRUE causes MACSYMA to print the cpu time
taken by each computation. This figure does not include I/O time
except in the case of the time given at the end of running a batch
file.  By setting SHOWTIME:ALL, in addition to the cpu time MACSYMA
now also prints out (when not zero) the amount of time spent in
garbage collection (gc) in the course of a computation.  This time is
of course included in the time printed out as "Total time=" .

(It should be noted that since the "time=" time only includes
computation time and not any intermediate display time, and since it
is difficult to ascribe "responsibility" for gc's, the gctime printed
will include all gctime incurred in the course of the computation and
hence may in rare cases even be larger than "time=").

@var<LASTTIME (default: @Index)> - the time to compute the last
expression in milliseconds presented as a list of "time" and "gctime".

@var<TIMER_DEVALUE (default; FALSE)> - when set to TRUE then the time
charged against a function is the time spent dynamically inside the
function devalued by the time spent inside other timed functions.

@var<OPTIONSET (default: FALSE)> - if TRUE, MACSYMA will print out a
message whenever a MACSYMA option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

@var<NOLABELS (default: FALSE)> - if TRUE then no labels will be bound
except for E lines generated by the solve functions (@ref[SOLVE]).  This
is most useful in the "BATCH" mode where it eliminates the need to do
KILL(LABELS) in order to free up storage.

@var<CURSORDISP (default: TRUE)> - if TRUE, causes expressions to be drawn by
the displayer in logical sequence.  This only works with a console
which can do cursor movement.  If FALSE, expressions are simply
printed line by line.  CURSORDISP is FALSE when a WRITEFILE is in
effect.

@var<BFTRUNC (default: TRUE)> causes trailing zeroes in non-zero
bigfloat numbers not to be displayed.  Thus, if BFTRUNC:FALSE,
BFLOAT(1); displays as 1.000000000000000B0. Otherwise, this is
displayed as 1.0B0.

@var<EXPTDISPFLAG (default: TRUE)> - if TRUE, MACSYMA displays
expressions with negative exponents using quotients e.g., X**(-1) as
1/X.

@var<NEGSUMDISPFLAG (default: TRUE)> - when TRUE, X-Y displays as X-Y
instead of as -Y+X.  Setting it to FALSE causes the special check in
display for the difference of two expressions to not be done.  One
application is that thus A+%I*B and A-%I*B may both be displayed the
same way.

@var<%EDISPFLAG (default: FALSE)> - if TRUE, MACSYMA displays %E to a
negative exponent as a quotient, i.e. %E@+[-X] as 1/%E@+[X].

@var<SQRTDISPFLAG (default: TRUE)> - if FALSE causes SQRT to
display with exponent 1/2.

@var<PFEFORMAT (default: FALSE)> - if TRUE will cause rational
numbers to display in a linear form and denominators which are
integers to display as rational number multipliers.

@var<DISPFLAG (default: TRUE)> - if set to FALSE within a BLOCK (see
@Ref[program!blocks]) will inhibit the display of output generated by
the solve functions (see @Ref[SOLVE]) called from within the BLOCK.
Termination of the BLOCK with a dollar sign, , sets DISPFLAG to FALSE.

@var<LOADPRINT (default: TRUE)> - governs the printing of messages
accompanying loading of files.  The following options are available:
TRUE means always print the message; 'LOADFILE means print only when
the LOADFILE command is used; 'AUTOLOAD means print only when a file
is automatically loaded in (e.g. the integration file SIN FASL); FALSE
means never print the loading message.

@var<NOUNDISP (default: FALSE)> - if TRUE will cause NOUNs to display
with a single quote.  This switch is always TRUE when displaying
function definitions.

@var<POWERDISP (default: FALSE)> - if TRUE will cause sums to be
displayed with their terms in the reverse order.  Thus polynomials
would display as truncated power series, i.e., with the lowest power
first.

@var<BOTHCASES (default: FALSE)> - if TRUE will cause MACSYMA to
retain lower case text as well as upper case. Note, however, that the
names of any MACSYMA special variables or functions must be typed in
upper case.

@var<STARDISP (default: FALSE)> - if TRUE will cause multiplication to
be displayed explicitly with an * between operands.

@var<DSKGC (default: FALSE)> - if TRUE will cause user defined values,
functions, arrays, and line labelled expressions to be automatically
stored on disk whenever the system determines that the available
in-core space is getting low (see also @PageRef[autostor]).

@var<LABELS (default: [])> - a list of C, D, and E lines which are bound.

@var<INCHAR (default: C)> - the alphabetic prefix of the names of
expressions typed by the user.

@var<LINECHAR (default: E)> - the alphabetic prefix of the names of
intermediate displayed expressions.

@var<OUTCHAR (default: D)> - the alphabetic prefix of the names of
outputted expressions.

Note:  The first alphabetic character of INCHAR,
OUTCHAR, and LINECHAR are assumed to be different.

@var<LINENUM (default: [])> - the line number of the last expression.

@var<PROMPT (default: _)> is the prompt symbol of the DEMO function,
PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).  (see chapter
@Ref[debugmac]).

@var<CURSOR (default: $)> is the prompt symbol of the MACSYMA editor.
(see chapter @Ref[macedit].)

@var<PAGEPAUSE (default: not_set_yet)> - is set by MACSYMA according to
what the system knows about your terminal type.  If it is set to TRUE,
then "more" processing, which involves the printing of --More
Display?-- or --Pause-- at the bottom of your screen or after so many
lines on a printing terminal, and pausing, will be enabled.  It may be
set to FALSE to turn off the "more" processing on a display terminal.
PAGEPAUSE is sometimes useful in batch files on slow lines where you
just wish to watch the output run past, and can keep up with the line
speed well enough.  On MC, you can also do this by typing ^_M
(control-underscore M) which toggles "more" processing.

@var<MOREWAIT (default: FALSE)> - Controls the action of more
processing.  In its default FALSE setting, a space typed at --More
Display?-- will continue the display, a rubout (or delete) will flush
the display of the expression (to both the terminal and any WRITEFILE
which is open) and anything else will flush only output to the
terminal.  Type-ahead is allowed (i.e. you can begin typing the next
command-line and the display to the console will be flushed and your
typing will be saved and put on the C-line).  "carriage return" is
frequently used for this last function of just flushing the output to
the terminal.  If MOREWAIT is set to TRUE, then space and rubout work
as above, but only carriage return is enabled to flush display to the
terminal, and type-ahead is ignored.  If MOREWAIT is set to ALL, then
only space (to continue output) and carriage return (to flush it) are
enabled, and any other characters (including rubout) are ignored.
This may be useful for users on noisy connections where rubouts
transmitted by the phone line sometimes flush output accidently.

@var<GENINDEX (default: I)> - the alphabetic prefix of the index of
summation for generated sums. (The values of GENINDEX and of the above
four variables may be any number of characters though the default is a
single character.)

@var<IBASE (default: 10)> - the base for inputting numbers.

@var<OBASE (default: 10)> - the base for display (output) of numbers.

@var<LINEL (default: 80)> - the length of the printed line on the terminal.
Also used for plotting (see Chapters @Ref[simplot] and @Ref[plot2]).

PLOTHEIGHT @Index[PLOTHEIGHT] - the height of the area used for
plotting (see Chapters @Ref[simplot] and @Ref[plot2]).

@var<VERSION (default: 304)> - is the version number of MACSYMA.  This
could be useful if the user wants to label his output.

INFOLISTS @Index[INFOLISTS] is the list of all the information lists
which are in MACSYMA:
@begin(example)
[LABELS, VALUES, FUNCTIONS, MACROS, ARRAYS, MYOPTIONS, 

         PROPS, ALIASES, RULES, GRADEFS, DEPENDENCIES,

         LET_RULE_PACKAGES]
@end(example)

Initially, all these information lists are empty, except
LET_RULE_RACKAGES.  As the user proceeds with his computation, he may
examine these lists when necessary.

@Section[Functions for Translation and Compilation]
@Label[compilation]

Translating functions and packages written in MACSYMA into Lisp, and
then compiling the Lisp code will result in faster running code.  This
is recommended for well worked out routines which are going to be used
a lot.  When MACSYMA code is going to be translated or compiled,
declarations as to data types must be made.  The first two functions
below do this.

@begin(function)
@fcn[Name="MODE_DECLARE", Args="y1, mode1, y2, mode2, ..."]
is used to declare the modes of variables and functions for subsequent
translation or compilation of functions. Its arguments are pairs
consisting of a variable yi, and a mode which is one of BOOLEAN,
FIXNUM, NUMBER, RATIONAL, or FLOAT.  Each @i[yi] may also be a list of
variables all of which are declared to have @i[modei].

If @i[yi] is an array, and if every element of the array which is
referenced in the function has a value then ARRAY(@i[yi], COMPLETE,
dim1, dim2, ...) rather than ARRAY(@i[yi], dim1, dim2, ...) should be used
when first declaring the bounds of the array. If all the elements of
the array are of mode FIXNUM (FLOAT), use FIXNUM (FLOAT) instead of
COMPLETE.  Also if every element of the array is of the same mode, say
@i[m], then MODE_DECLARE(COMPLETEARRAY(@i[yi]),@i[m])) should be used
for efficient translation.  Also numeric code using arrays can be made
to run faster by declaring the expected size of the array, as in:
@begin(example)
MODE_DECLARE(COMPLETEARRAY(A[10,10]),FLOAT)
@end(example)
for a floating point number array which is 10 x 10.
Array functions translate and compile correctly.  This includes the
simple array function  FA[J]:=J@+[2];  and the complex one  FC[J](X):=X@+[J]; 
which is actually a definition of a class of functions.  (It is 
implemented in translated code as an upward funarg.)

Additionally one may declare the mode of the result of a function by
using FUNCTION(F1,F2,...) as an argument; here @i[F1,F2,...] are the
names of functions.  For example the expression, 
@begin(example)
MODE_DECLARE([FUNCTION(F1,F2,...),X],FIXNUM,Q,COMPLETEARRAY(Q),FLOAT) 
@end(example)
declares that X and the values returned by F1,F2,... are single-word
integers and that Q is an array of floating point numbers.
MODE_DECLARE is used either immediately inside of a function definition
(see below) or at top-level for global variables.

Sometimes one wants to declare a value to be a list of flonums, a list
of lists of flonums, or other compound data object.  Since macros have
been introduced into macsyma (see @Ref[macr]) it is now possible to
implement these compound data types in a simple way.  The required
primitive is MODE_IDENTITY @Index[MODE_IDENTITY], a special form of
two arguments.  Its first argument is a primitive value mode name as
given to MODE_DECLARE (i.e. [FLOAT,FIXNUM,NUMBER, LIST,ANY]), and the
second argument is an expression which is evaluated and returned as
the value of MODE_IDENTITY.  However, if the return value is not
allowed by the mode declared in the first argument, an error or
warning is signalled.  The important thing is that the MODE of the
expression as determined by the Macsyma-to-Lisp translator, will be
that given as the first argument, independent of anything that goes on
in the second argument.

E.g. X:3.3; MODE_IDENTITY(FIXNUM,X); is an error.  MODE_IDENTITY(FLONUM,X) 
returns 3.3 . 

This has a number of uses, e.g., if you knew that FIRST(L) returned a
number then you might write MODE_IDENTITY(NUMBER,FIRST(L)).  However,
a more efficient way to do it would be to define a new primitive,
@Begin[Example]
FIRSTNUMB(X)::=BUILDQ([X],MODE_IDENTITY(NUMBER,X))
@end(example)
and use FIRSTNUMB every time you take the first of a list of numbers.

This is the simplest example, and it doesn't show the full power of the 
method. 

There is a switch, @var<UNDECLAREDWARN (default: COMPFILE)> to warn about
undeclared variables. It is recommended to do
MODE_DECLARE(@i<variable>,ANY) to declare a variable to be a general
macsyma variable (i.e. not limited to being FLOAT or FIXNUM).  The
extra work in declaring all your variables in code to be compiled
should pay off.  However, there are four relevant settings for UNDECLAREDWARN
@Begin[format]
@tabclear()
@tabset(.5inches,1.5inches)
@\SETTING@\ACTION

@\FALSE@\never print warning messages.
@\COMPFILE@\warn when in COMPFILE
@\TRANSLATE@\warn when in TRANSLATE and when TRANSLATE:TRUE
@\ALL@\warn in COMPFILE and TRANSLATE
@end(format)
@end(function)

To assist in making sure the MACSYMA code to be translated is reasonably
efficient, the following two functions are useful:

@begin(function)
@fcn(Name="OPTIMIZE",Args="exp")
returns an expression that produces the same value and side effects
as @i[exp] but does so more efficiently by avoiding the recomputation
of common subexpressions.  OPTIMIZE also has the side effect of
"collapsing" its @u[argument] so that all common subexpressions are
shared.

@var<OPTIMPREFIX (default: %)> - The prefix used for generated symbols by
the OPTIMIZE command.

@Begin[Example]
(C1) DIFF(%,X,2);
			2	     2		    2		 2
	       2   Y + X        Y + X	       Y + X	    Y + X
	    4 X  %E	    2 %E	 4 X %E	        2 %E
(D1) 	    ------------- + ---------- - ------------ + ----------
		Y + X	      Y + X		  2	        3
					   (Y + X)	 (Y + X)
@hinge
(C2) OPTIMIZE(%);
					       2	 Y + T2	 
(D2) BLOCK([%1, %2, %3, %4], %1 : Y + X, %2 : X , %3 : %E      ,  
								 

                     1				4 X %3	 2 %3
   		%4: --,	 4 %2 %4 %3 + 2 %4 %3 - ------ + ----)
                    %1				   2	   3
						 %1	 %1
@End[Example]

@fcn[Name="COLLAPSE", Args="exp"]
"collapses" its argument by causing all of its
common (i.e. equal) subexpressions to share (i.e. use the same cells),
thereby saving space.  (COLLAPSE is a subroutine used by the OPTIMIZE
command.)  Thus, calling COLLAPSE may be useful before using FASSAVE
or after loading in a SAVE file.  You can collapse several expressions
together by using COLLAPSE([@i<expr1,...,exprN>]).  Similarly, you can
collapse the elements of the array A by doing
COLLAPSE(LISTARRAY('A)).
@end(function)

The function FLOATDEFUNK (see below) offers some automation of
OPTIMIZE and COLLAPSE, and helps with some MODE_DECLAREs.

@begin(function)
@fcn[Name="COMPILE", Args="function1,function2,..."]
compiles the functions, it uses the name
of @i[function1] as the first name of the file to put the lisp output.

The COMPILE command is a convenience feature in macsyma. It handles
the calling of the function COMPFILE, which translates macsyma
functions into lisp, the calling of the lisp compiler on the file
produced by COMPFILE, and the loading of the output of the compiler,
known as a FASL file, into the macsyma. It also checks the compiler
comment listing output file for certain common errors. All these
things can be done manually of course, but using COMPILE, with its
convenient default actions, makes some work go much faster, mainly use
of PLOT2 and numerical integration.

COMPILE(ALL); or COMPILE(FUNCTIONS) will compile all functions.
Also, see FLOATDEFUNK, below.

COMPILE(); causes macsyma to prompt for arguments.

COMPILE([@i<file-name>],@i<function1,function2,...>); N.B. all arguments are 
evaluated, just like a normal function (it is a normal function!).
Therefore, if you have variables with the same name as part of the file
you can not ignore that fact.

@var<DEFAULT_DIRECTORY_COMPILE (default: STATUS(UDIR))>
STATUS(UDIR) is your "home" directory. And it is set at DDT level.
COMPILE is not affected by previous LOADFILEs, although it does use
LOADFILE to load the FASL file.

@var<FIRST_FILENAME_COMPILE (default: FALSE)>
If you are doing a lot of compilations and always want the same file
to be used as scratch, you might set this.

@var<FUNCTIONS_TO_COMPILE (default: FALSE)>
It is not usually useful to set this, athough it can save some typing
if you are changing and recompiling the same functions a lot.

@var<COMPILER_CALL (default: INFERIOR)> can also be set to DDT. This controls
whether the lisp compiler is called as an inferior job to macsyma
or by valreting to toplevel DDT.

@fcn[Name="COMPILE_LISP_FILE", Args=""input filename""]
can be used in conjunction with
TRANSLATE_FILE("@i<filename>").  It takes an optional second
argument of "output filename".   For convenience you might define
@Begin[Example]
	Compile_and_load(FILENAME):=
	 LOAD(COMPILE_LISP_FILE(TRANSLATE_FILE(FILENAME)[2]))[2]);
@End[Example]
These file-oriented commands are to be preferred over the use of
COMPILE, COMPFILE, and the TRANSLATE SAVE combination.
@end(function)

@center(EXAMPLES)

In order to get the most out of compilation, declarations must be made
to describe your function types and variables. The basic idea of
compilation is for the computer to make certain calculations only
once, that is, at compile time.

F(X,Y):=X*Y; If what you want to do is call F(3.2,2.2) then there is
some inefficiency, because you could have also done F('X,'X) and
expected to receive back X@+[2], and it takes many times longer for
macsyma to figure out that it needs to call the PDP-10 floating point
multiply instruction, than it does for the PDP-10 to execute this
instruction.

F(X,Y):=(MODE_DECLARE(X,FLOAT,Y,FLOAT),X*Y); tells macsyma that X and Y
are the equivalent of the Fortran REAL, and when you compile or
TRANSLATE the function, it can use that information to decide to use
the PDP-10 multiply instruction.

In general, the MODE_DECLARE should appear as the first "function call"
where ever new variables are introduced. Variables should be
MODE_DECLAREd as soon as they are introduced, not before, or after. By
"introduced" we mean the lexical contour in which they appear. The
following things, and only these things, mark the beginning of a
contour:

":="     starts a contour for all the formal parameters, and for
all free variables used in the function.

"BLOCK", starts a contour for all of the "block" variables.

"DO" starts a contour for its "FOR" variable, presently the "FOR"
variable should be declared in the next outer contour though, this
bug will be soon fixed. Then a proper example would be
FOR X:X1 THRU XN STEP DX DO(MODE_DECLARE(X,FLOAT),SUM:SUM+F(X)*DX)

"LAMBDA" starts a contour for its lambda variables.

Certain constructs, such as SUM, have an implied contour of limited scope.
e.g. SUM(J@+[2],J,1,N). In this case, it is not the responsibility of the
user to declare the mode of the variable "J", which is
bound by the construct. The code which handles the SUM can look at
those modes of the lower and upper limits and infer the mode of "J".
@Begin[Example]
F(X,Y):=(MODE_DECLARE([X,Y],FLOAT),SIN(4*X)+SQRT(1+X^2)*COS(X));
F(X,Y):=(MODE_DECLARE([X,Y,A,B],FLOAT,N,INTEGER), SQRT(A*B*X+Y^N));
F(X):=(MODE_DECLARE(X,FLOAT),
       BLOCK([P,Q],
             MODE_DECLARE([P,Q],FLOAT),
             P:SIN(X)*X^2,
	     Q:4*X^2-X+14,
	     IF X>0 THEN SQRT(P^2+ABS(P*Q)+SIN(Q)+1)
                     ELSE P+Q/10));

/* dY/dX=F(X,Y), [X0,Y0] and X_FIN and DX */
@End[Example]
Declaring that a function will return a floating point number.
@Begin[Example]
EULER(F,X0,Y0,X_FIN,DX):=
     (MODE_DECLARE([X0,Y0,X_FIN,DX],FLOAT,FUNCTION(F),FLOAT),
      BLOCK([Y:Y0,X:X0],
	    MODE_DECLARE([Y,X],FLOAT),
	    LOOP, IF X>=X_FIN THEN RETURN(Y),
	    Y:Y+DX*APPLY(F,[X]),   X:X+DX,
	    GO(LOOP)));
@End[Example]
Or, without the GO TO,
@Begin[Example]
EULER(F,X0,Y0,X_FIN,DX):=
     (MODE_DECLARE([X0,Y0,X_FIN,DX],FLOAT,FUNCTION(F),FLOAT),
      BLOCK([Y:Y0],
	    MODE_DECLARE([Y,X],FLOAT),
	    FOR X:X0 THRU X_FIN STEP DX 
               DO Y:Y+DX*APPLY(F,[X]),
	    Y);
@End[Example]
Declaring arrays, for example, A is an array that returns some number,
@Begin[Example]
SUM_ARRAY(A):=(MODE_DECLARE(ARRAY(A),NUMBER),
               IF LENGTH(ARRAYDIMS(A))#1 
               THEN ERROR("Takes only 1 dim array"),
	       BLOCK([N:ARRAYDIMS(A)[1],SUM:0],
	             MODE_DECLARE([N,J],FIXNUM,SUM,NUMBER),
		     FOR J:1 THRU N DO SUM:SUM+A[J],
		     SUM));
@End[Example]
FLOATDEFUNK @Index[FLOATDEFUNK] is a utility for making floating
point functions from mathematical expression. It will take the input
expression and FLOAT it, then OPTIMIZE it, and then insert
MODE_DECLARATIONS for all the variables.  This is THE way to use
ROMBERG, PLOT2, INTERPOLATE, etc. e.g.
EXP:some-hairy-macsyma-expression; FLOATDEFUNK('F,['X],EXP); will
define the function F(X) for you.

@Begin[Example]
F():=BLOCK([MY_FLAG:TRUE],MODE_DECLARE(MY_FLAG,SPECIAL),FOOBAR());

F(U,EXP):=(MODE_DECLARE(FUNCTION(MY_MAP(CLOSURE,ANY)),ANY),
	   MY_MAP(LAMBDA([X],U:Q(U,X)),EXP));
@End[Example]

@begin(function)
@fcn[Name="TRANSLATE_FILE", Args="file"]
- translates a file of MACSYMA code (a BATCH file) into a file of
LISP code.  It takes one or two arguments.  The first argument is the
name of the MACSYMA file, and the optional second argument is the name
of the LISP file to produce.  The second argument defaults to the
first argument with second file name the value of
TR_OUTPUT_FILE_DEFAULT which defaults to TRLISP.  E.g.
TRANSLATE_FILE(TEST); will translate a file called TEST > into TEST
TRLISP.  It also produces is a file of translator warning messages of
various degrees of severity.  The second file name is always UNLISP.
This file contains valuable information for tracking down bugs in
translated code.  See also the MAKE_INDEX_FILE @Index[MAKE_INDEX_FILE]
in (see @PageRef[batchap]) for hints on checking BATCH files before
translating them.

@fcn[Name="TRANSLATE", Args="f1, f2, ..."]
translates the user defined functions @i[f1,f2],... from the MACSYMA
language to LISP (i.e. it makes them EXPRs).  This results in a gain
in speed when they are called.  The functions should include a call to
MODE_DECLARE at the beginning when possible in order to produce more
efficient code.  For example:
@Begin[Example]
F(X1,X2,...):=BLOCK([v1,v2,...],
              MODE_DECLARE(v1,mode1,v2,mode2,...),...);
@End[Example]

where the X1,X2,... are the parameters to the function and the
v1,v2,... are the local variables.  The names of translated functions
are added to the PROPS lists (see @Ref[property!specification]).
Functions should not be translated unless they are fully debugged.

TRANSLATE(FUNCTIONS) or TRANSLATE(ALL)  means translate all functions.

@var<TRANSLATE (default: FALSE)> - If TRUE, causes automatic translation of a
user's function to LISP.  Note that translated functions may not run
identically to the way they did before translation as certain
incompatabilities may exist between the LISP and MACSYMA versions.
Principally, the RAT function with more than one argument and the
RATVARS function (see @Ref[rational!functions]) should not be used if any
variables are MODE_DECLAREd CRE.

@var<TRANSCOMPILE (default: FALSE)> - if true, TRANSLATE will generate the
declarations necessary for possible compilation.  The COMPFILE command
uses TRANSCOMPILE:TRUE;.

@var<SAVEDEF (default: TRUE)> - if TRUE will cause the MACSYMA version of a
user function to remain when the function is TRANSLATEd.  This permits
the definition to be displayed by DISPFUN and allows the function to
be edited.  If SAVEDEF is FALSE, the names of translated functions are
removed from the FUNCTIONS list.  If SAVEDEF is set to ALL, then if a
TRANSLATEd function is redefined, it's TRANSLATEd definition will still
remain, although the MACSYMA version of its definition will be changed.
If the function had been TRACEd, then the tracing is deleted.

@var<TRANSRUN (default: TRUE)> - if FALSE will cause the interpreted
version of all functions to be run (provided they are still around)
rather than the translated version.

@var<TRANSBIND (default: FALSE)> - if TRUE removes global declarations in the
local context.  This applies to variables which are formal parameters
to functions.

@var<PREDERROR (default: TRUE)> - the setting of this variable to FALSE is not
currently supported in the translator.

One can translate functions stored in a file by giving TRANSLATE an
argument which is a file specification.  This is a list of the form
[@i<fn1,fn2,>DSK,@i<dir>] where @i<fn1 fn2> is the name of the file of MACSYMA
functions, and @i<dir> is the name of a file directory.

Such a file may contain declarations involving DECLARE,MODE_DECLARE, or
MATCHDECLARE in addition to the function definitions.  The file should
not use %, since % is not maintained when the translated file is
loaded.

TRANSLATE will return DONE when translation is accomplished.  In the
case of a file translation, the file containing the translated code is
named fn1 LISP on the disk directory dir.  This file of LISP code may
be read into MACSYMA by using the LOADFILE @Index[LOADFILE] or LOAD
@Index[LOAD] function, (see @Ref[disk!storage]).

@fcn[Name="COMPFILE", Args="[filespec],f1,f2,..."]
will translate MACSYMA function definitions (if necessary) and write
out MACSYMA function definitions and other expressions into a disk
file which can be read into the compiler. The ]filespec@?[ (optional)
specifies the file to be written.  The default for users with a
directory is CMPFIL > and the standard MACSYMA default file for other
users.  The file written contains declarations used by the compiler.
When @var<COMPGRIND (default: FALSE)> is TRUE the function
definitions are pretty-printed.  The remaining arguments are atomic
function names.  COMPFILE([@i<filespec>],FUNCTIONS); will translate
all FUNCTIONS.

On MC,
there is a version of macsyma with the macsyma to lisp translator 
pre-loaded into it.  It is available from DDT level by typing :TM (for 
TranslateMacsyma).  When given JCL it takes it as a file name to give 
to TRANSLATE_FILE, and proceeds without further user interaction.
With no JCL it gives a regular macsyma "(C1)" line.
A user init file with second name "TM" will be loaded if it exists.
(You might want to link such a "TM" init file to your regular MACSYM
init file so that a TM job will use your standard init.)

There is a top-level special form
which is a general convenience
feature that is very useful to package writers.
Basicaly
@fcm(Name="EVAL_WHEN",Args="key-words,form1,form2,...")
has
the following semantics: @i[key_words] is a single key-word
or a list of keywords from the set BATCH,LOADFILE,TRANSLATE.
The @i[forms] are evaluated when BATCHing if the BATCH keyword is present,
they are evaluated when the file is being translated with
TRANSLATE_FILE when the TRANSLATE keyword is present, and
the forms are evaluated when the translated file is LOADFILEd
if the LOADFILE keyword is present. This feature can only be
used at TOPLEVEL. Here is an example usage:
@Begin[Example]
EVAL_WHEN(BATCH,TTYOFF:TRUE)$

EVAL_WHEN([BATCH,LOADFILE],
          IF NOT STATUS(FEATURE,"MY PACKAGE") 
             THEN LOADFILE(FOO,FASL,DSK,BAR),
          SSTATUS(FEATURE,"MY PACKAGE"),
          INITIALIZE_MY_PACKAGE())$
/* special things might need to be in the environment to translate
   my package. */

EVAL_WHEN(TRANSLATE,
          IF NOT STATUS(FEATURE,"MY PACKAGE MODEDECLARATIONS"),
             THEN LOADFILE(FOO,MODES,DSK,BAR),
          MODE_DECLARE(EXTRA STUFF...))$


 ....MY PACKAGE .....

EVAL_WHEN(BATCH,TTYOFF:FALSE)
@end(example)
@end(function)

@SubSection[Switches which affect the Translator and Compiler]
@Label[trswitch]

@var<TR_ARRAY_AS_REF (default: TRUE)> - If TRUE runtime code uses the value
of the variable as the array.

@var<TR_BOUND_FUNCTION_APPLYP (default: TRUE)> - Gives a warning if a bound
variable is found being used as a function.

@var<TR_FILE_TTY_MESSAGESP (default: FALSE)> - Determines whether messages
generated by TRANSLATE_FILE during translation of a file will be sent
to the TTY.  If FALSE (the default), messages about translation of the
file are only inserted into the UNLISP file.  If TRUE, the messages
are sent to the TTY and are also inserted into the UNLISP file.

@var<TR_FLOAT_CAN_BRANCH_COMPLEX (default: TRUE)> - States whether the arc
functions might return complex results.  The arc functions are SQRT,
LOG, ACOS, etc.  e.g. When it is TRUE then ACOS(X) will be of mode ANY
even if X is of mode FLOAT. When FALSE then ACOS(X) will be of mode
FLOAT if and only if X is of mode FLOAT.

@var<TR_FUNCTION_CALL_DEFAULT (default: GENERAL)> - FALSE means give
up and call MEVAL, EXPR means assume Lisp fixed arg function.
GENERAL, the default gives code good for MEXPRS and MLEXPRS but not
MACROS.  GENERAL assures variable bindings are correct in compiled
code.  In GENERAL mode, when translating F(X), if F is a bound
variable, then it assumes that APPLY(F,[X]) is meant, and translates a
such, with apropriate warning. There is no need to turn this off.
With the default settings, no warning messages implies full
compatibility of translated and compiled code with the macsyma
interpreter.

@var<TR_GEN_TAGS (default: FALSE)> - If TRUE, TRANSLATE_FILE generates a
TAGS file for use by the text editor.

@var<TR_NUMER (default: FALSE)> - If TRUE numer properties are used for
atoms which have them, e.g. %PI.

@var<TR_OPTIMIZE_MAX_LOOP (default: 100)> - The maximum number of times the
macro-expansion and optimization pass of the translator will loop in
considering a form.  This is to catch MACRO expansion errors, and
non-terminating optimization properties.

@var<TR_OUTPUT_FILE_DEFAULT (default: TRLISP)> - This is the second file
name to be used for translated lisp output.

@var<TR_PREDICATE_BRAIN_DAMAGE (default: FALSE)> - If TRUE, output possible
multiple evaluations in an attempt to interface to the COMPARE
package.

@var<TR_SEMICOMPILE (default: FALSE)> - If TRUE TRANSLATE_FILE and COMPFILE
output forms which will be macroexpanded but not compiled into machine
code by the lisp compiler.  With this you can produce a FASL file with
all macros expanded, and still run translated code interpreted.  The
procedure would be
@Begin[Example]
TR_SEMICOMPILE:TRUE;
TRANSLATE_FILE("USER\;MYFILE");
@End[Example]
then at DDT level,
@Begin[Example]
:CL USER;MY TRLISP (T)
@End[Example]
producing USER;MY FASL.

@var<TR_STATE_VARS (default: TRANSCOMPILE, TR_SEMICOMPILE,
TR_WARN_UNDECLARED, TR_WARN_MEVAL, TR_WARN_FEXPR, TR_WARN_MODE,
TR_WARN_UNDEFINED_VARIABLE, TR_FUNCTION_CALL_DEFAULT, TR_ARRAY_AS_REF,
TR_NUMER)> - The list of the switches that affect the form of the
translated output.  This information is useful to system people when
trying to debug the translator.  By comparing the translated product
to what should have been produced for a given state, it is possible to
track down bugs.

@var<TR_TRUE_NAME_OF_FILE_BEING_TRANSLATED (default: FALSE)> is bound to
the quoted string form of the true name of the file most recently
translated by TRANSLATE_FILE.

@var<TR_VERSION @Index (default: TR)> - The version number of the translator.

@var<TR_WARN_BAD_FUNCTION_CALLS (default: TRUE)> - Gives a warning when
when function calls are being made which may not be correct 
due to improper declarations that were made at translate time.

@var<TR_WARN_FEXPR (default: COMPFILE)> - Gives a warning if any FEXPRs are
encountered.  FEXPRs should not normally be output in translated code,
all legitimate special program forms are translated.

@var<TR_WARN_MEVAL (default: COMPFILE)> - Gives a warning if the function
MEVAL gets called.  If MEVAL is called that indicates problems in the
translation.

@var<TR_WARN_MODE (default: ALL)> - Gives a warning when variables are
assigned values inappropriate for their mode.

@var<TR_WARN_UNDECLARED (default: COMPILE)> - Determines when to send
warnings about undeclared variables to the TTY.

@var<TR_WARN_UNDEFINED_VARIABLE (default: ALL)> - Gives a warning when
undefined global variables are seen.  Possible settings of this switch
are: ALL,COMPILE,COMPFILE,TRANSLATE,FALSE, controlling when warnings
will be seen.  FALSE disables the feature.  This picks up many
spelling errors in variable names which could cause obscure errors
once code is translated/compiled.  Cases where one accidently uses a
symbol as a variable will also be picked up, e.g.  APPLY(APPEND,L)
when APPLY('APPEND,L) is intended.

TR_WARNINGS_GET(); @Index[TR_WARNINGS_GET] - Prints a list of warnings
which have been given by the translator during the current
translation.

@var<TR_WINDY (default: TRUE)> - Generate "helpful" comments and
programming hints (verbose).

@var<MODE_CHECKP (default: TRUE)> - If TRUE, MODE_DECLARE checks the modes
of bound variables.

@var<MODE_CHECK_WARNP (default: TRUE)> - If TRUE, mode errors are
described.

@var<MODE_CHECK_ERRORP (default: FALSE)> - If TRUE, MODE_DECLARE calls
error.

For information on debugging and timing your functions once they are
translated, see @Ref[debugmac].

@Section[Hints for Writers of Packages in MACSYMA]
@Label[phints]

@begin(function)
@fcn[Name="DEFINE_VARIABLE", Args="name,default-binding,mode,optional-documentation"]
introduces a global variable into the MACSYMA environment.  This is
for user-written packages, which are often translated or compiled.

E.g.: DEFINE_VARIABLE(FOO,TRUE,BOOLEAN);  does the following:
@begin(enumerate)
MODE_DECLARE(FOO,BOOLEAN); sets it up for the translator, so
that the resultant code will be more efficient.

If the variable is unbound, it sets it: FOO:TRUE.  The user of a
package can set the values of various switches before the file which
contains the package is loaded in, and these values take effect,
rather than being bashed by ":" which would otherwise happen.  This is
especially convenient for autoloading packages (packages which get
loaded automatically when a function is invoked, rather than having to
be explicitly LOADFILEd.)

DECLARE(FOO,SPECIAL); declares it special.
This is vital to have if code refering to the variable is to be compiled.

Sets up an assign property for it to make sure that it never
gets set to a value of the wrong mode.  E.g.  FOO:44 would be an error
once FOO is defined BOOLEAN.  This is important for proper error
checking.  For example in the code "IF FOO THEN 7 ELSE 8", FOO should
be TRUE or FALSE, i.e. of BOOLEAN mode.  Suppose the user sets it to
4.44.  If you used DEFINE_VARIABLE then it would catch the error as
"ERROR: Trying to assign variable FOO of mode BOOLEAN to 4.44 "
instead of the more enigmatic: "Macsyma was unable to evaluate the
predicate: 4.44", which might be misunderstood as a bug in the package
instead of a misuse of the variable.
@End[Enumerate]
The possible @i[mode]s are as for MODE_DECLARE.

The optional 4th argument is a documentation string.  When
TRANSLATE_FILE is used on a package which includes documentation
strings, a second file is output in addition to the LISP file (it will have
TRDOC as its second file name) which
will contain the documentation strings, formatted suitably for use in
manuals, usage files, or (for instance) DESCRIBE.

With any variable which has been DEFINE_VARIABLE'd with mode other than 
ANY, you can give a VALUE_CHECK property, which is a function of one 
argument called on the value the user is trying to set the variable to.

PUT('G5,LAMBDA([U],IF U#'G5 THEN ERROR("Don't set G5")),'VALUE_CHECK);
Use DEFINE_VARIABLE(G5,'G5,ANY_CHECK, "this ain't supposed to be set 
by anyone but me.")

ANY_CHECK is a mode which means the same as ANY, but which 
keeps DEFINE_VARIABLE from optimizing away the assign property.

@fcn[Name="SETUP_AUTOLOAD", Args="file,func1,...,funcN"]
makes the @i[funci] "AUTOLOADing".  SETUP_AUTOLOAD takes two or more
arguments: a file specification, and one or more function names,
@i[funci], and which indicates that if a call to @i[funci] is made and
@i[funci] is not defined, that the file specified by @i[file] is to be
automatically loaded in via LOAD, which file should contain a
definition for @i[func].  (This is the process by which calling e.g.
INTEGRATE in a fresh MACSYMA causes various files to be loaded in.)
If the second file name of @i[file] is not specified (preferred usage
is to specify) then the standard search for second file names of
"FASL", "TRLISP", and ">" is done.  As with the other file-handling
commands in MACSYMA, the arguments to SETUP_AUTOLOAD are not
evaluated.

For example:
@begin(example)
SETUP_AUTOLOAD([BESSEL,FASL,SHARE],J1) J1(0.0); 
@end(example)

Note that the variable @var<CHANGE_FILEDEFAULTS (default: TRUE)> can
be set to FALSE and thus files loaded in by a package will not disturb
the user' FILEDEFAULTS.

Package designers who use SAVE, FASSAVE, or TRANSLATE to create
packages (files) for others to use may want to set 
@var<PACKAGEFILE (default: FALSE)>
to TRUE to prevent information from being added to
MACSYMA's information-lists (e.g. VALUES, FUNCTIONS) except where
necessary when the file is loaded in.  In this way, the contents of
the package will not get in the user's way when he adds his own data.
Note that this will not solve the problem of possible name conflicts.
Also note that the flag simply affects what is output to the package
file.  Setting the flag to TRUE is also useful for creating MACSYMA
init files.
@end(function)

@SubSection[Functions Which Do Not Evaluate Some Arguments]
@Label[fxpr]

It is now possible to define a user-function in MACSYMA which does 
not evaluate or simplify some of its arguments at function-call time. 
This is done by using "single-quotes" in the parameter-list of the 
function definition, as in the following definitions:
Suppose A is assigned the value 2, A:2
@begin(example)
[1] F('X):=PRINT(X,"has value",EV(X))  F(A); 
@End[Example]
prints "A HAS VALUE 2" and returns 2 .
@Begin[Example]
[2] F('X,Y):=X+Y  F(A,A);
@End[Example]
gives A+2 .
@Begin[Example]
[3] F('X):=BLOCK([SIMP:FALSE],PRINT(EV(X)))  F(A+A); 
@End[Example]
prints "2+2" and returns 4.

Please note the following: 

The syntax F(X,['L]):=... also works.
One cannot now TRANSLATE and TRACE such function definitions.
The above scheme does not work for array function definitions.
Working with expressions which have not been evaluated or simplified
can lead to difficulties, and care should be taken.  In particular,
the use of EV inside such function definitions can have unpredictable
results.

@SubSection[|Advanced Programming Hints - Macros|]
@Label[macr]

@heading(Introduction)

The Macsyma macro facility allows the user to define forms which are
similar in appearance to Macsyma functions but whose evaluation and
simplification can be more carefully controlled. This high degree of
control provides users with many powerful capabilities (the ability
to write definitions of operators which act as extended control
structures, which implicitly quote certain of their arguments, or
which establish special environments for the evaluation of their
arguments, to name just a few). Additionally, macros are highly
efficient from a compilation standpoint - references to macros can
be made to yield extremely good code when compiled.

@heading(The Concept)

A macro is a definition of a transformation between some syntactic
construct typed in by the user and a form which can be interpreted
by the Macsyma evaluator. Suppose a user had several lists (X, Y,
and Z) which he often wanted to print out the values of in the
following way:
@Begin[Example]
FOR I THRU LENGTH(X) DO PRINT('X[I]=X[I]);
FOR I THRU LENGTH(Y) DO PRINT('Y[I]=Y[I]);
 ... etc
@End[Example]
This could get tedious to type. He might, for instance, want to
define a Macsyma operator which did most the work for him, so that
he could type
@Begin[Example]
SHOWME(X);
@End[Example]
and have the same thing happen as if he had typed out the FOR loop.
Without using macros, trying to write a definition for SHOWME which
allows this syntax is tedious at best, and in any case would require
the user to type
@Begin[Example]
SHOWME('X);
@End[Example]
in order to get ahold of the name of the form being displayed.

Here is an example of how it could be done as a macro: SHOWME will be
an operator with just one thing in its argument position, so we'll
want to write
@Begin[Example]
SHOWME(LISTNAME) ::= ...something...
@end(example)
(The "::=" is used instead of ":=" to indicate that what follows is
a macro definition, rather than an ordinary functional definition.)
Proceeding, we must next write a definition. The definition should
do something to create the form which we really want to evaluate,
returning that form as a value.  In this case, we shall want
@Begin[Example]
FOR I THRU LENGTH(LISTNAME) DO PRINT('LISTNAME[I]=LISTNAME[I])
@End[Example]
to get returned by SHOWME. Note that we don't want to do this action,
we only want to return the new ("expanded") form.  The Macsyma
interpreter will take care of any evaluation later. One way to do this
might be to use FUNMAKE and SUBSTPART but that can be pretty hard to
do, especially with a form like FOR. An easier way is to use the
Macsyma BUILDQ function.
Using BUILDQ, the definition would look like:
@Begin[Example]
    SHOWME(LISTNAME)::=
          BUILDQ([LISTNAME],
                 FOR I THRU LENGTH(LISTNAME)
                     DO PRINT('LISTNAME[I]=LISTNAME[I]))$
@end(example)
BUILDQ is a generalized substitution function used to create macsyma
forms.

@fcn(Name="BUILDQ",Args="variable list,expression")

where the @i[variable list] is similar to the variable list for a BLOCK
(i.e. it can contain both atomic variables and assignment-forms).  The
right hand sides of any assignment-forms in the @i[variable list] are
evaluated left to right and the resulting variable bindings are 
substituted in parallel into the @i[expression] (actually, the process
is more complicated than what SUBST would provide, as we shall see farther 
down). The @i[expression] can be any macsyma expression (including a nested
BUILDQ).  The new expression is returned as is, not evaluated.  For example,
@Begin[Example]
        S:A+B

        BUILDQ([S,A:B*C,FUN:BAR],
               S^2+G(A,'A)+FUN(S) );

                       2
        =>      (A + B) + G(B C, '(B C)) + BAR(A + B)
@End[Example]
The parallel nature of the substitution can probably be most easily seen
in the following example:
@Begin[Example]
        BUILDQ([A:'B,B:'A], SIN(A)+COS(B));

        => SIN(B) + COS(A)
@End[Example]
BUILDQ also recognizes specially the keyword SPLICE when it is used in
a functional position within the expression.  If SPLICE is used with
only one argument and that argument is the name of one of the
variables being substituted for, then the value of the variable is
"spliced" into the expression instead of being substituted.  The
spliced variable must evaluate to a list.
@Begin[Example]
        L:[A,B,C]

        BUILDQ([L],F(L,SPLICE(L)));

        F([A, B, C], A, B, C)
@End[Example]

Returning to our definition:
@Begin[Example]
    SHOWME(LISTNAME)::=
          BUILDQ([LISTNAME],
                 FOR I THRU LENGTH(LISTNAME)
                     DO PRINT('LISTNAME[I]=LISTNAME[I]))$
@End[Example]
what happens when the Macsyma evaluator encounters a Macro? First it
calls the macro definition on the appropriate parts of the form;
for example, in the case of SHOWME(X), the SHOWME macro would be
called with LISTNAME bound to X. Note that @u[no] evaluation of
arguments is done prior to application of the macro -- that will
come later. The SHOWME definition will then create a new form which
looks like
@Begin[Example]
FOR I THROUGH LENGTH(X) DO PRINT('X[I]=X[I])
@End[Example]
and return that to the evaluator. The evaluator will then take the
new form, and evaluate that in place of the original SHOWME form,
finally returning the value of this second evaluation as the value
of the SHOWME. So we might actually type:
@Begin[Example]
        X:['A,'B]

        SHOWME(X)

        X  = A
         1

        X  = B
         2
@End[Example]
A symbol can have either a macro property or a function property but
not both at the same time.  Defining an atom with ::= will remove
the atom's function properties and vice versa.

@heading(Useful Functions and Variables)

A. Information about Definitions

MACROS @Index[MACROS] is a variable (similar to FUNCTIONS) which lists at
any time all macros defined in the current environment. It is
one of the variables which can be found in INFOLISTS.

DISPFUN(@i[name]) @Index[DISPFUN] and GRIND(@i[name]) @Index[GRIND]
will use either the function property or the macro property if either
exist.

STRINGOUT(FUNCTIONS); may be used to stringout all functions and 
macros in the current environment.

B. Removing definitions

REMFUNCTION(@i[func]) @Index[REMFUNCTION] removes all functional
properties and macro properties from @i[func].  REMFUNCTION(ALL)
removes all functions and macros from the current environment.

REMOVE(@i[name],FUNCTION) @Index[REMOVE] removes the function property
of @i[name] if one exists, but will not remove macro properties.  See
MACROS and REMFUNCTION.

REMOVE(@i[name],MACRO) removes the macro property of @i[name] if one
exists, but will not remove function properties.  See MACROS and
REMFUNCTION.

KILL(FUNCTIONS) @Index[KILL] only affects the functions in the current
environment and has no effects on any macros. Similarly,
KILL(MACROS) only affects macros and hase no effects on any
defined functions.

C. Controlling Expansions

The switch @var<MACROEXPANSION (default: FALSE)> controls advanced features
which affect the efficiency of macros. Possible settings:
@begin(itemize)
FALSE -- Macros expand normally each time they are called.

EXPAND -- The first time a particular call is evaluated,
the expansion is "remembered" internally, so that
it doesn't have to be recomputed on subsequent calls 
making subsequent calls faster.  The macro call still
GRINDs and DISPLAYs normally, however extra memory is 
required to remember all of the expansions.

DISPLACE -- The first time a particular call is evaluated,
the expansion is substituted for the call.  This requires
slightly less storage when MACROEXPANSION is set to EXPAND
and is just as fast, but has the disadvantage that the 
original macro call is no longer remembered and hence the 
expansion will be seen if DISPLAY or GRIND is called.
@end(itemize)
Macros always expand and displace at the time of translation 
when calls to them are translated.  (See @Ref[compilation].)

For examples of usage, do DEMO(MACEX,DEMO,DSK,DEMO);

D. Forcing Macro Expansion

The following commands are useful in debugging MACROS:

@begin(function)
@fcn[Name="MACROEXPAND1", Args="form"]
- expands @i[form] exactly once if @i[form] is a
macro call without doing the automatic evaluation.  If @i[form] is
not a macro call, @i[form] is returned, again unevaluated.

@fcn[Name="MACROEXPAND", Args="form"]
- expands @i[form] repeatedly until it is no
longer a macro call.  The final expansion is returned without
doing the automatic evaluation.

For examples of usage, do DEMO(MACEX,DEMO,DSK,DEMO);

@u[More Examples]

    A. PUSH, POP -- Stack Control Operators
@Begin[Example]
        PUSH(VALUE,STACKNAME)::=BUILDQ([VALUE,STACKNAME],
                                  STACKNAME:CONS(VALUE,STACKNAME))

        POP(STACKNAME)::=BUILDQ([STACKNAME],
                           BLOCK([TEMP:FIRST(STACKNAME)],
                                 STACKNAME:REST(STACKNAME),TEMP))$

        A:[];           => []
        PUSH('FOO,A);   => [FOO]
        PUSH('BAR,A);   => [BAR, FOO]
        A;              => [BAR, FOO]
        POP(A);         => BAR
        A;              => [FOO]
        POP(A);         => FOO
        A;              => []
@End[Example]
On MC, the SHAREM; directory contains some useful demo files which
serious package writers might like to look at.  Notably:

KEYARG DEMO - a description of argument passing using key words.

DEFM DEMO - substitution macros.

PACKG > - some macros for organizing packages.

TRANSL HINTS - hints for translating MACSYMA code.
