.chap (Debugging in MACSYMA,debugmac)

When MACSYMA detects a syntax error in an input line, the error
message sometimes displays the offending expression to help the user
pinpoint the source of error.  This is inconvenient if the expression
is large, especially when the user has a slow terminal.  Gradually,
this scheme is being replaced by a scheme that does not display the
offending expression, but rather sets $var<ERREXP/> to it, and prints
out the error message followed by the message "ERREXP contains the
offending expression".  The user can then type ERREXP; to see the
expression and locate the error.

The variable $var<PARSEWINDOW/10> controls the maximum number of "lexical tokens"
that are printed out on each side of the error-point when a syntax
(parsing) error occurs.  This option is especially useful on slow
terminals.  Setting it to -1 causes the entire input string to be
printed out when an error occurs.

The variable $var<ERROR_SIZE/>
controls the size of error messages.  For example,
.example
U:(C^D^E+B+A)/(COS(X-1)+1)$
.end
U has an error size of 24.  So if ERROR_SIZE has value < 24 then 
.example
(C1) ERROR("The function", FOO,"doesn't like", U,"as input.");

prints as:

The function FOO doesn't like ERREXP1 as input.
.end
If ERROR_SIZE > 24 then as:
.example
				 E
				D
			       C   + B + A
The function FOO doesn't like -------------- as input.
			      COS(X - 1) + 1
.end
Expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
user-settable list ERROR_SYMS:[ERREXP1,ERREXP2,ERREXP3].  The default
value for ERROR_SIZE varies with terminal type, being 20 for display
terminals and 10 for others.  This may change depending on user experience.

When the user's command lines, especially functions and $fun<BLOCK>
programs, do not do what is expected or generate errors, MACSYMA
offers several debugging alternatives:

(1) The user may trace function calls by typing TRACE(2fun1,fun2,...1),
where the 2funi1 are either MACSYMA or user-defined functions.  This will cause a
printout of the function name and its arguments each time it is entered, and of
the function name and the value it returns each time it is exited.  A count
which is the level of recursion is also printed.  Usually, this is all the
tracing power the user will need, although MACSYMA offers the full
capabilities of the LISP tracing package including conditional and breakpoint
tracing.  This will not be described here - for information see [Mn1].  MACSYMA
uses trace-syntax very similar to that of LISP.

To check which functions are currently under trace, the user may type TRACE().
To remove tracing of functions use UNTRACE(2fun1,fun2,...1).  To untrace all
previously traced functions type UNTRACE().  Since the TRACE package takes up
some of the user's workspace in core, when finished with it the user should type
$fun<REMTRACE>().  It can always be reloaded again if necessary.

(2) The assignment of variables can be traced by setting the variable
$var<SETCHECK/> to a list of variables (which can be subscripted).  When a
variable on the list is bound (either with : or :: or function
argument binding) then a message -- variable "SET TO" value -- will be
printed. If the variable $var<SETCHECKBREAK/FALSE> is set to TRUE then a
(MACSYMA-BREAK) will be caused each time a variable on the SETCHECK
list is bound.  The break takes place before the actual binding is done,
however, and the variable $var<SETVAL/> contains the actual binding, so
the binding may be changed at this point by re-setting SERVAL.

(3) By setting the variable $var<REFCHECK/FALSE> to TRUE, the user will be informed when each
of his variables which has a value comes up for evaluation for the first time
during the course of a computation.  This has a dual purpose.  The user will be
informed of evaluations he may not have been aware of which are the result of
assignments he made long ago. It also gives him a sort of chronological trace of
his computations which may be helpful in finding out where an error has
occurred.

(4) By setting the variable $var<PREDERROR/> to TRUE, the user will be informed of
predicates of IF-THEN-ELSE statements which failed to evaluate to either TRUE or
FALSE.

(5) The user may have variables which he intends not to use purely symbolically,
i.e. they are to have values all the time.  By typing
DECLARE([2var1,var2,1...],BINDTEST) MACSYMA will give the user an error
whenever any of the vari appear in a computation unbound.  To remove a BINDTEST
declaration, the user may use the function $fun<REMOVE>.  $see<property!specification>

(6) When an error occurs in the course of a computation, MACSYMA prints out an
error message and terminates the computation.  At times the user may find it
helpful to investigate the environment at the place of the error.  To do so, type DEBUGMODE:TRUE or DEBUGMODE:ALL and repeat the computation.  This enters a special
debugging mode which will "break" or pause when an error occurs.  This mode may
be terminated by typing DEBUGMODE:FALSE.  When an error occurs in debugging
mode, (ERROR-BREAK) is printed. MACSYMA is then waiting for the user to type
something.  He may type any command line just as if he were at "top level".  The
command lines will be evaluated in the environment of the error.  If the user had done DEBUGMODE:ALL, he may now
type BACKTRACE;, and MACSYMA will print out a backtrace, which is a list of the
function calls the user is currently in together with the arguments they were
called with, ordered from most recent to earliest i.e., when reversed, this list
shows a trace beginning from the initial function and ending at the last call
entered including only those function calls from which the user still has not
exited.  To exit from the MACSYMA error-break and return to "top-level", type
EXIT;.

The user may also enter the error-break at any point, by typing control-A or by
executing the function $fun<BREAK> $see<miscfun>.  This will simply cause his
computation to pause, while he investigates at will.  $var<%%/> refers to the last
computed result while in the MACSYMA break.  $var<%/> still refers to the last
result computed at top-level.  Upon typing EXIT;, the computation will resume.  If
he wants to quit a computation begun in a control-A break without quitting the
top-level suspended computation, the user can type control-X.

During a break one may type $var<TOPLEVEL/>;.  This will cause top-level MACSYMA to
be entered recursively.  Labels will now be bound as usual.  Everything will be
identical to the previous top-level state except that the computation which was
interrupted is saved. The function TOBREAK() will cause the break which was left by
typing TOPLEVEL; to be re-entered.  If TOBREAK is given any argument whatsoever,
then the break will be exited, which is equivalent to typing TOBREAK() immediately
followed by EXIT;.


In the following example, an attempt is made to define a function ROOT which finds an approximate root to an expression
using Newton-Raphson iteration.
.example
.begin group
(C1) ROOT(F,V):=BLOCK([VAL,FUN,DER],DER:DIFF(F,V),VAL:0.0,
        TEST,FUN:SUBST(VAL,V,F),IF ABS(FUN)<5.0E-7 THEN
        RETURN(VAL),DER:SUBST(VAL,V,DER),VAL:VAL-FUN/DER,
        GO(TEST))$
.end

(C2) NUMER:TRUE$

(C3) F:SIN(%PI*X)-%PI*(X-1)$

(C4) ROOT(F,X);

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

(C5) REFCHECK:TRUE$

(C6) DEBUGMODE:TRUE$

.begin group
(C7) ''C4;
F has value
V has value
VAL has value
FUN has value
DER has value
.end

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

(ERROR-BREAK)

_VAL;
1.0541436E+8

_DER;
- 2.98023224E-8

_TRACE(SUBST)$

_''C4;

.begin fill
1(The numerical value of %PI is present below due to NUMER being set to TRUE
above.)
.end

.begin group
1 ENTER SUBST [0.0, X, SIN(3.1415927 X) - 3.1415927 (X - 1)]
1 EXIT SUBST: 3.1415927
1 ENTER SUBST [0.0, X, 3.1415927 COS(3.1415927 X) - 3.1415927]
1 EXIT SUBST: - 2.98023224E-8
1 ENTER SUBST [1.0541436E+8, X, SIN(3.1415927 X) - 3.1415927 (X - 1)]
.end

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

.begin group
try again

.begin fill
1(This message is due to an error-break occurring within another error break.)
.end

_EXIT;
Exited from the break
.end

(C8) <$>
_''C4
MYFROOT<$><$>

.begin fill
1(The user uses the MYF command of the MACSYMA editor to insert the definition of ROOT into the
edit buffer. The editor is then used to insert an IF statement to test for
DER being close to 0. The actual editing work is not shown.)
.end

.begin group
(C8) ROOT(F,V):=BLOCK([VAL,FUN,DER],DER:DIFF(F,V,1),VAL:0.0,
        TEST,FUN:SUBST(VAL,V,F),IF ABS(FUN)<5.0E-7 THEN
         RETURN(VAL),DER:SUBST(VAL,V,DER),IF ABS(DER)<5.E-8
         THEN ERROR("DERIVATIVE IS ZERO"),VAL:VAL-FUN/DER,
        GO(TEST))$
.end

(C9) UNTRACE();
(D9)                             [SUBST]

(C10) REFCHECK:FALSE$

(C11) ''C4;
DERIVATIVE IS ZERO
QUIT     (This is due to the ERROR function being executed.)
.end

