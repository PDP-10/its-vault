18718 minfactorial does not simplify binomial coeffs. see  MAKEFACT AND 
MAKEGAMMA.
61451 include some of this section in the ARRAYS section as well

.if partial then start
.count chapter from 6 printing "1"
.count section from 6 in chapter printing "!.1"
.count subsection in section printing "!.1"
.next chapter
.end

.next page

.sec (Other General Purpose Functions,othergpf)

This section contains functions which are less frequently used than those in 6.1
through 6.5, e.g. those dealing with series, continued fractions, direct and inverse Laplace
transforms, etc.  As it is difficult to put them into distinct classes this section is
necessarily a conglomeration.

.function(SUM,|exp, ind, lo, hi|)
performs a summation of the values of 2exp1 as the index 2ind1 varies from
2lo1 to 2hi1.   If the upper and lower limits differ by an integer then each term
in the sum is evaluated and added together.  Otherwise the summand is evaluated with the
index of summation unbound and (if the SIMPSUM [FALSE] is TRUE) the result is
simplified.  This simplification may sometimes be able to produce a closed form.  If
SIMPSUM is FALSE or if 'SUM is used, the value is a sum noun form which is a
representation of the sigma notation used in mathematics.


Sums may be differentiated, added, subtracted, or multiplied with some automatic
simplification being performed.

$var<OUTSUM[TRUE]> if TRUE  causes factors of the summand which don't depend upon
the index of summation to be moved outside of the sum.

$var<CAUCHYSUM[FALSE]> when TRUE causes the Cauchy product to be used when multiplying
sums together rather than the usual product.  In the Cauchy product the index of the
inner summation is a function of the index of the outer one rather than varying
independently.

$var<GENINDEX[I]> is the alphabetic prefix used to generate the next variable of
summation.

$var<GENSUMNUM[0]> is the numeric suffix used to generate the next variable of
summation.  If it is set to FALSE then the index will consist only of GENINDEX with no
numeric suffix.

.example
(C1) SIMPSUM:TRUE$

(C2) SUM(I**2+2**I,I,0,N);

.begin group
                         3      2
              N + 1   2 N  + 3 N  + N
(D2)         2      + --------------- - 1
                             6
.end

(C3) SUM(3**(-I),I,1,INF);

.begin group
                          1
(D3)                      -
                          2
.end

(C4) SUM(I^2,I,1,4)*SUM(1/I^2,I,1,INF);

.begin group
                                       2
(D5)                              5 %PI
.end

.end
.endfunction

.function(PRODUCT,|exp, ind, lo, hi|)
gives the product of the values of 2exp1 as the index 2ind1 varies from
2lo1 to 2hi1.  The evaluation is similar to that of SUM.   No simplification of
products is available at this time.

.example group
(C1)  PRODUCT(X+I*(I+1)/2,I,1,4);

(D1)             (X + 1) (X + 3) (X + 6) (X + 10)
.end
.endfunction

.function (LIMIT,|exp, var, val, dir|)
finds the limit of 2exp1 as the real variable 2var1 approaches the value
2val1 from the direction 2dir1.  2Dir1 may have the value PLUS for a limit
from above, MINUS for a limit from below, or may be omitted (implying a
two-sided limit is to be computed).  For the method see [Wa3].  LIMIT uses the
following special symbols:  INF (positive infinity) and MINF (negative
infinity).  On output it may also use UND (undefined), IND (indefinite but
bounded) and INFINITY (complex infinity).


$var<LHOSPITALLIM[4]> is the maximum number of times  L'Hospital's rule is used in
LIMIT.  This prevents infinite looping in cases like LIMIT(COT(X)/CSC(X),X,0).

$var<TLIMSWITCH[FALSE]> when true will cause the limit package to use Taylor series when possible.

.example
(C1) LIMIT(X*LOG(X),X,0,PLUS);

(D1)                 0

(C2) LIMIT((1+X)**(1/X),X,0);

(D2)                 %E

(C3) LIMIT(%E**X/X,X,INF);

(D3)                 INF

(C4) LIMIT(SIN(1/X),X,0);

(D4)                   IND

.end
.endfunction

.function(TLIMIT,|exp,var,val,dir|) 
 is just the function LIMIT with TLIMSWITCH set to TRUE.

.endfunction

.function(LDEFINT,|exp,var,ll,ul|)
yields the definite integral of 2exp* by using LIMIT to evaluate the indefinite integral of 2exp* with respect to 2var* at the upper limit 2ul* and at the lower limit 2ll*.

.endfunction

.function(TLDEFINT,|exp,var,ll,ul|)
is just LDEFINT with  TLIMSWITCH  set to TRUE.

.endfunction

.function (RESIDUE,|exp, var, val|)
computes the residue in the complex plane of the expression 2exp1
when the variable 2var1 assumes the value 2val1.  The residue is the coefficient of
(2var1-2val1)**(-1) in the Laurent series for 2exp1.

.example
(C1) RESIDUE(S/(S**2+A**2),S,A*%I);

.begin group
                        1
(D1)                    -
                        2
.end

(C2) RESIDUE(SIN(A*X)/X**4,X,0);

.begin group
                        3
                       A
(D2)                 - --
                       6
.end

.end
.endfunction


.function (TAYLOR,|exp, var, pt, pow|)
expands the expression 2exp1 in a truncated Taylor series (or Laurent series,
if required) in the variable 2var1 around the point 2pt1.  The terms through
(2var1-2pt1)**2pow1 are generated. If 2exp1 is of the form
f(2var1)/g(2var1) and g(2var1) has no terms up to degree 2pow1 then
TAYLOR will try to expand g(2var1) up to degree 2*2pow1.  If there are still
no non-zero terms TAYLOR will keep doubling the degree of the expansion of
g(2var1) until reaching 2pow1*2**n where n is the value of the variable
$var<TAYLORDEPTH[3]>.

If $var<MAXTAYORDER[FALSE]> is set to TRUE, then during algebraic manipulation of (truncated) Taylor series,  TAYLOR will try to retain as many terms as are certain to be correct.  

.example
(C1) TAYLOR(SQRT(1+A*X+SIN(X)),X,0,3);

.begin group
                           2             2
             (A + 1) X   (A  + 2 A + 1) X
(D1)/R/  1 + --------- - -----------------
                 2               8

                      3      2             3
                  (3 A  + 9 A  + 9 A - 1) X
                + -------------------------- +  . . .
                              48
.end

(C2) %**2;
.begin group
                              3
                             X
(D2)/R/      1 + (A + 1) X - -- +  . . .
                             6
.end

(C3) PRODUCT((X**I+1)**2.5,I,1,INF)/(X**2+1);

.begin group
                          INF
                         /===\
                          ! !    I     2.5
                          ! !  (X  + 1)
                          ! !
                          ! !
                         I = 1
(D3)                     -----------------
                               2
                              X  + 1
.end

(C4) TAYLOR(%,X,0,3),KEEPFLOAT:TRUE;

.begin group
                                  2           3
(D4)/R/      1.0 + 2.5 X + 3.375 X  + 6.5625 X  +  . . .
.end

(C5) TAYLOR(1/LOG(1+X),X,0,3);

.begin group
                                  2       3
                    1   1   X    X    19 X
(D5)/R/             - + - - -- + -- - ----- +  . . .
                    X   2   12   24    720
.end

.end
.endfunction
.skip 2

2Multivariate Taylor Series Expansions1
.skip 1
For multivariate functions, there are several ways of obtaining Taylor series expansions.  If the variables are truly independent and all singularities involve only one variable
at a time then the expansion may be done as follows:

.function(TAYLOR,|exp, var1, pt1, ord1, var2, pt2, ord2, . . .| )

.endfunction
.scon
or
.function(TAYLOR,|exp,[var1,pt1,ord1],[var2,pt2,ord2],...|)
.endfunction
.scon
Naturally the two techniques may be intermixed.

However, if  the variables are interdependent or singularities involving
 some of the variables together can occur then the following
scheme is to be used:

.function(TAYLOR, |exp, [var1, var2, . . .], pt, ord|)
where each of 2pt1 and 2ord1 may be replaced by a list which will correspond to the list of variables.  that is, the nth items on each of the lists will be associated together.  

.endfunction

2The user should be warned that this scheme uses the RATWTLEVEL scheme implicitly whenever the variables are expanded to different orders.  In this case the user must not be trying to use RATWTLEVEL simultaneously.1

.begin turn on "[^]"
Internally this is done in the following manner; for each Xi substitute
.skip 1
.once center
Xi -----> T^[Ni] Wi.

Then a term like  X^2 Y^3 Z would become
.skip 1
.once center
T^[2 N1 + 3 N2 + N3] W1^2 W2^3 W3
.end
.skip 1
.continue
and truncation is done on T.  The W variables as well as T are not seen by the user.  The following are examples of the various modes of Taylor expansions.

.example
(C5) TAYLOR(SIN(X+Y),X,0,3,Y,0,3);
.begin group

		 3	  2	   2    3  2    3
		Y	 Y  X   Y X    Y  X    X 
(D5)/R/     Y - -- + X - ---- - ---- + ----- - --
		6	  2	 2      12     6 

		    2  3
		   Y  X
		 + ----- + . . .
		    12
.end

(C6) TAYLOR(SIN(X+Y),[X,Y],0,3);
.begin group
			   3	    2	   2	  3
			  X  + 3 Y X  + 3 Y  X + Y
(D6)/R/ 	  Y + X - ------------------------- + . . .
				      6
.end

(C7) TAYLOR(1/SIN(X+Y),X,0,3,Y,0,3);
.begin group
					2    3
		      1	  Y   X	   X   X    X
(D7)/R/ 	      - + - - -- + - + -- - -- + . . .
		      Y	  6    2   6    3    4
			      Y	       Y    Y
.end
(C8) TAYLOR(1/SIN(X+Y),[X,Y],0,3);
.begin group
			 
	      1	    X + Y
(D8)/R/     ----- + -----
	    X + Y     6	

         3         2       2         3
      7 X  + 21 Y X  + 21 Y X  +  7 Y
    + -------------------------------- + . . .
		    360
.end
.end

If one wants to handle asymptotic expansions a facility exists
to some extent. It may be invoked as follows.

.function(TAYLOR,|exp, [x,pt,ord,asymp]|)
will give an expansion of 2exp1 in negative powers of (2x-pt1).  The highest order term will be 
.endfunction
.begin turn on "[^]"
.skip 1
2
.once center
(x - pt)^[-ord]
.end
1

If the user is expanding polynomials he may specify a truncation level of INF in which case the expansion will never truncate.

.function (DEFTAYLOR,|function, exp|)
allows the user to define the Taylor series (about 0) of an arbitrary
2function1 of one variable as 2exp1 which may be a polynomial in that variable or
which may be given implicitly as a power series using the SUM function.

.skip 1
In order to display the information given to DEFTAYLOR one can use
POWERSERIES(F(X),X,0). (see below).

.example
(C1) DEFTAYLOR(F(X),X**2+SUM(X**I/(2**I*I!**2),
	I,4,INF));
(D1)                          [F]

(C2) TAYLOR(%E**SQRT(F(X)),X,0,4);

.begin group
                     2         3          4
                    X    3073 X    12817 X
(D2)/R/     1 + X + -- + ------- + -------- +  . . .
                    2     18432     307200
.end

.end
.endfunction

.function (POWERSERIES,|exp, var, pt|)
generates the general form of the power series expansion for 2exp1 in the
variable 2var1 about the point 2pt1 (which may be INF for infinity).  In
cases in which POWERSERIES is unable to expand 2exp1 the TAYLOR function may
give the first several terms of the series.


$var<VERBOSE[FALSE]> - if TRUE will cause comments about the progress of POWERSERIES
to be printed as the execution of it proceeds.

.example
(C1) VERBOSE:TRUE$

(C2) POWERSERIES(LOG(SIN(X)/X),X,0);
.begin group
CAN'T EXPAND

                    LOG(SIN(X))

SO WE WILL TRY AGAIN AFTER APPLYING THE RULE:

                                D
                             /  -- SIN(X)
                             [  DX
               LOG(SIN(X)) = I (---------) DX
                             ]   SIN(X)
                             /
.end

.begin group
IN FIRST SIMPLIFICATION WE HAVE RETURNED

                              /
                              [
                   - LOG(X) + I COT(X) DX
                              ]
                              /
.end

.begin group
         INF
        \====         I9 - 1  2 I9             2 I9 + 2
         \      ( - 1)       2     BERN(2 I9) X
(D2)      >    (---------------------------------------)
         /                (2 I9 + 2) (2 I9)!
        /====
        I9 = 0
.end

.end
.endfunction

.function (TRIGEXPAND,exp)
expands trigonometric and hyperbolic functions of sums
of angles and of multiple angles occuring in 2exp1.  For best results, 2exp1 should be expanded.   To enhance user control of simplification, this function first expands only  sums; a repeated application will then expand multiple angles.    To obtain full expansion into sines and cosines immediately, set the switch  TRIGEXPAND:TRUE.


$var<TRIGEXPAND[FALSE]> if TRUE causes expansion of all expressions containing
SINs and COSs occurring subsequently.

$var<HALFANGLES[FALSE]> - if TRUE causes half-angles to be simplified away.

.example
(C1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;

.begin group
                              2           2
(D1)                     - SIN (X) + 3 COS (X) + X
.end

(C2) TRIGEXPAND(SIN(10*X+Y));

(D2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)

.end
.endfunction

.function (TRIGREDUCE,|exp, var|)
combines products and powers of trigonometric and hyperbolic SINs and COSs of
2var1 into those of multiples of 2var1.  It also tries to eliminate these
functions when they occur in denominators.  If 2var1 is omitted then all
variables in 2exp1 are used.  Also see the POISSIMP function sect. 6.14.

.example group
(C4) TRIGREDUCE(D1);
(D4)                        2 COS(2 X) + X + 1

.end

The trigonometric simplification routines will use declared information in some simple cases.  Declarations about variables are used as follows, e.g.

.example

(C5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$

(C6) SIN(X + (E + 1/2)*%PI)$

(D6) 			  COS(X)

(C7) SIN(X + (O + 1/2) %PI);


(D7) 			 - COS(X)

.end

.endfunction

.function (COMEXP,exp)
returns a list of the common subexpressions of 2exp1.

.endfunction

.function (OPTIMIZE,exp)
returns a BLOCK which evaluates to 2exp1 making use of common
subexpressions.  This may be used to evaluate 2exp1 efficiently or to store it on
disk without having many copies of the same subexpression. (see 9.4)

.example
(C1) DIFF(EXP(X^2+Y)/(X+Y),X,2);

.begin group
                    2            2 
           2   Y + X        Y + X  
        4 X  %E         2 %E       
(D1)    ------------- + ---------- 
            Y + X         Y + X    
                                   

	             2            2
	        Y + X        Y + X
	  4 X %E         2 %E
	- ------------ + ----------
	           2             3
	    (Y + X)       (Y + X)
.end

(C2) OPTIMIZE(%);
.begin group
                                       2
(D2) BLOCK([T4, T3, T2, T1, T0], T0 : X , T1 : Y + T0,
	T2 : Y + X,

       1          T1            4 T4 X              
  T3 : --, T4 : %E  , RETURN( - ------ + 4 T0 T3 T4 
       T2                          2                
                                 T2                 

	            2 T4
	+ 2 T3 T4 + ----))
	              3
	            T2
.end

.end
.endfunction

.function (LAPLACE,|exp, ovar, lvar|)
takes the Laplace transform of 2exp1 with respect to the variable 2ovar1
and transform parameter 2lvar1.  2Exp1 may only involve the functions EXP,
LOG, SIN, COS, SINH, COSH, and ERF.  It may also be a linear, constant coefficient 
differential equation in which case $fun<ATVALUE> (see sect. 6.2.2) of the dependent
variable will be used.  These may be supplied either before or after the
transform is taken. Since the initial conditions must be specified at zero, if
one has boundary conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution for them
and substituting their values back. 2Exp1 may also involve convolution
integrals.  Functional relationships must be explicitly represented in order for
LAPLACE to work properly. That is, if F depends on X and Y it must be written as
F(X,Y) wherever F occurs as in LAPLACE('DIFF(F(X,Y),X),X,S).

.example group
(C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);

                     A
                 2 %E  (S - 2)
(D1)            ---------------
                        2     2
                ((S - 2)  + 1)


(C2) LAPLACE(DELTA(T-A)*SIN(B*T),T,S);

IS A POSITIVE,NEGATIVE OR ZERO?

POS;
					  - A S
(D2) 			       SIN(A B) %E


.end
.endfunction

.function (ILT,|exp, lvar, ovar|)
takes the inverse Laplace transform of 2exp1 with respect to 2lvar1 and
parameter 2ovar1.  2exp1 must be a ratio of polynomials whose denominator
has only linear and quadratic factors.  By using the functions LAPLACE and ILT
together with the SOLVE or LINSOLVE functions the user can solve a single
differential or convolution integral equation or a set of them.

.example
(C1) 'INTEGRATE(SINH(A*X)*F(T-X),X,0,T)+B*F(T)=T**2;

.begin group
              T
             /
             [                                     2
(D1)         I (SINH(A X) F(T - X)) DX + B F(T) = T
             ]
             /
             0
.end

(C2) LAPLACE(%,T,S);

.begin group
            A LAPLACE(F(T), T, S) 
(D2)        --------------------- 
                    2    2        
                   S  - A         

		                          2
		+ B LAPLACE(F(T), T, S) = --
		                           3
		                          S
.end

(C3) LINSOLVE([%],['LAPLACE(F(T),T,S)]);
SOLUTION

.begin group
                                        2      2
                                     2 S  - 2 A
(E3)       LAPLACE(F(T), T, S) = --------------------
                                    5         2     3
                                 B S  + (A - A  B) S
.end

(D3)                         [E3]

(C4) ILT(E3,S,T);

IS  A B (A B - 1)  POSITIVE, NEGATIVE, OR ZERO?

POS;

.begin group
                                       2
                       SQRT(A) SQRT(A B  - B) T
                2 COSH(------------------------) 
                                  B              
(D4)  F(T) =  - -------------------------------- 
                               A                 

	      2
	   A T             2
	+ ------- + ------------------
	  A B - 1    3  2      2
	            A  B  - 2 A  B + A
.end

.end
.endfunction

.function (MINFACTORIAL,exp)
examines 2exp1 for occurrences of two factorials which differ by an
integer.  It then turns one into a polynomial times the other.  If 2exp1 involves
binomial coefficients then they will be converted into ratios of factorials.

.example
(C1) N!/(N+1)!;
.begin group
                                    N!
(D1)                             --------
                                 (N + 1)!
.end

(C2) MINFACTORIAL(%);
.begin group
                                     1
(D2)                               -----
                                   N + 1
.end

.end
.endfunction

.function (FACTCOMB,exp)
tries to combine the coefficients of factorials in 2exp1 with the factorials
themselves by converting, for example, (N+1)*N! into (N+1)!.



$var<SUMSPLITFACT[TRUE]> if set to FALSE will cause MINFACTORIAL to be applied after a FACTCOMB.   

.example group
(C1) (N+1)^B*N!^B;
                                      B   B
(D1)                           (N + 1)  N!

(C2) FACTCOMB(%);
                                         B
(D1)                             (N + 1)!

.end
.endfunction

.function (BERNPOLY,|v, n|)
generates the 2n1th Bernoulli polynomial in the variable 2v1.

.endfunction

.function (QUNIT,n)
gives the principal unit of the real quadratic number field $fun<SQRT>(2n*)
where 2n1 is an integer, i.e. the element whose norm is unity.  This amounts to
solving Pell's equation A**2-2n1*B**2=1.

.example group
(C1) QUNIT(17);
(D1)              SQRT(17)+4

(C2)  EXPAND(%*(SQRT(17)-4));

(D2)               1

.end
.endfunction

.function (CF,exp)
converts 2exp1 into a continued fraction.  2exp1 is an expression composed of
arithmetic operators and lists which represent continued fractions.  A continued
fraction  a+1/(b+1/(c+...)) is represented by the list [a,b,c,...]. a,b,c,.. must
be integers.  2Exp1 may also involve SQRT(2n1) where 2n1 is an integer.  In
this case CF will give as many terms of the continued fraction as the value of the
variable $var<CFLENGTH[1]> times the period.  Thus the default is to give one
period.

.endfunction

.function (CFDISREP,list)
converts the continued fraction represented by 2list1 into general representation.

.example
(C1) CF([1,2,-3]+[1,-2,1]);

(D1)                 [1, 1, 1, 2]

(C2) CFDISREP(%);
.begin group
                            1
(D2)                1 + ---------
                              1
                        1 + -----
                                1
                            1 + -
                                2
.end

.end
.endfunction

.function (CFEXPAND,x)
gives a matrix of the numerators and denominators of the next-to-last and last
convergents of the continued fraction 2x1.

.example group
(C1) CF(SQRT(3));
(D1)                 [1, 1, 2, 1, 2, 1, 2, 1]

(C2) CFEXPAND(%);
                             [71  97]
(D2)                         [      ]
                             [41  56]

(C3) D2[1,2]/D2[2,2],NUMER;
(D3)                        1.7321429
.end
.endfunction

.next page
.sec (List Handling and LISP-like functions,lisp!functions)

.function (APPLY,|function, list|)
gives the result of applying the 2function1 to the 2list1 of its
arguments.  This is useful when it is desired to compute the arguments to a function
before applying that function.  For example, if L is the list [1, 5, -10.2, 4, 3],
then APPLY(MIN,L) gives -10.2.  APPLY is also useful when calling functions which do
not have their arguments evaluated if it is desired to cause evaluation of them.  For
example, if FILESPEC is a variable bound to the list [TEST, CASE] then
APPLY(CLOSEFILE,FILESPEC) is equivalent to CLOSEFILE(TEST,CASE).  In general the first
argument to APPLY should be preceded by a ' to to make it evaluate to itself.  Since
some atomic variables have the same name as certain functions the values of the
variable would be used rather than the function because APPLY has its first argument
evaluated as well as its second.

.endfunction

.function(FUNMAKE,|name,[arg1,...,argn]|)
returns 2name*(arg1,...,argn) without calling the function 2name*.
.endfunction

.function(ARRAYMAKE,|name,[i1,i2,...]|)
returns  2name1[2i1,i2,...1].
.endfunction

.function (MAP,|fn, exp1, exp2, ...|)
 returns an expression whose leading operator is the same as that of the
2expi1 but whose subparts are the results of applying 2fn1 to the
corresponding subparts of the 2expi1.  2Fn1 is either the name of a function
of n arguments (where n is the number of 2expi1) or is a LAMBDA form of n
arguments.


$var<MAPERROR[TRUE]> - if FALSE will cause all of the mapping functions to (1)
stop when they finish going down the shortest 2expi1 if not all of the
2expi1 are of the same length and (2) apply 2fn1 to [2exp1, exp2,...1] if
the 2expi1 are not all the same type of object. If MAPERROR is TRUE then an
error message will be given in the above two instances.

One of the uses of this function is to MAP a function (e.g. PARTFRAC) onto each
term of a very large expression where it ordinarily wouldn't be possible to use the
function on the entire expression due to an exhaustion of list storage space in the
course of the computation.

.example
(C1) MAP(F,X+A*Y+B*Z);
(D1) 			  F(B Z) + F(A Y) + F(X)

(C2) MAP(LAMBDA([U],PARTFRAC(U,X)),X/(X^3+4*X^2+5*X+2));
.begin group
				1	 X
(D2) 			   X (----- - --------)
			      X + 2	     2
				      (X + 1)
.end

(C3) MAP(RATSIMP, X/(X**2+X)+(Y**2+Y)/Y);

.begin group
                      1
(D3)            Y + ----- + 2
                    X + 1
.end

(C4) MAP("=",[A,B],[-.5, 3,2.5]);
MAP IS TRUNCATING
(D4)                [A = -.5, B = 3]

.end
.endfunction

.function (MAPLIST,|fn, exp1, exp2, ...|)
yields a list of the applications of 2fn1 to the parts of the 2expi1.  This
differs from MAP(2fn,exp1,exp2,...1) which returns an expression with the same
main operator as expi has (except for simplifications and the case where MAP
does an APPLY).  2Fn1 is of the same form as in MAP.

.endfunction

.function (FULLMAP,|fn, exp1, ...|)
is similar to MAP but it will keep mapping down all subexpressions
until the main operators are no longer the same.

The user should be aware that FULLMAP is used by the MACSYMA  simplifier for certain matrix manipulations; thus,   the user might see an error message concerning FULLMAP even though FULLMAP was not explicitly called by the user.

.example
(C1) A+B*C$

(C2) FULLMAP(G,%);

(D2)              G(B) G(C) + G(A)

(C3)  MAP(G,D1);

(D3)                G(B C) + G(A)

.end
.endfunction

.function (FULLMAPL,|fn, list1, ...|)
is similar to FULLMAP but it only maps onto lists and matrices

.example group
(C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);

(D1)                      [[A + 3, 4], [4, 3.5]]

.end
.endfunction

.function(SCANMAP,|function,exp|)
recursively applies 2function1 to 2exp*.  This is most useful when "complete" factorization is desired, for example:

.example

(C1) EXP:(A^2+2*A+1)*Y + X^2$

(C2) SCANMAP(FACTOR,EXP);
				    2	   2
(D2) 			     (A + 1)  Y + X

.end

Note the way in which SCANMAP applies the given function FACTOR to the constituent subexpressions of 2exp1;  if another form of 2exp1 is presented to SCANMAP then the result may be different.  Thus, D2 is not recovered when SCANMAP is applied to the expanded form of 2exp1:

.example

(C3) SCANMAP(FACTOR,EXPAND(EXP));
.begin group
			   2		      2
(D3) 			  A  Y + 2 A Y + Y + X
.end
.end

Here is another example of the way in which SCANMAP recursively applies a given function to all subexpressions, including exponents:

.example
.begin group
				 
(C4) EXPR : U*V^(A*X+B) + C$
.end

(C5) SCANMAP('F, EXPR);
.skip 1
.begin group
		    F(F(F(A) F(X)) + F(B))
(D5) F(F(F(U) F(F(V)			  )) + F(C))
.end
.end
.endfunction

.function (APPEND,|list1, list2, ...|)
returns a single list of the elements of 2list11 followed by the
elements of 2list21,...

.example group
(C1) APPEND([Y+X,0,-3.2],[2.5E20,X]);

(D1)             [Y+X, 0, -3.2, 2.5E20, X]

.end
.endfunction

.function (CONS,|exp, list|)
returns a new list constructed of the element 2exp1 as its first element, followed by
the elements of 2list1.

.endfunction

.function (ENDCONS,|exp, list|)
returns a new list consisting of the elements of 2list1 followed by 2exp1.

.endfunction

.function (MEMBER,|exp, list|)
returns TRUE if 2exp1 occurs as a member of 2list1 (not within a member).  Otherwise
FALSE is returned.

.endfunction

.function (REVERSE,list)
reverses the order of the members of 2list1 (not the members themselves).


See also the functions $fun<FIRST>, $fun<REST>, $fun<LAST>, $fun<DELETE>, $fun<LENGTH>  ($ref<extracting!expressions>).

.skip 2
.example group once center
2Examples*

(C1) UNION(X,Y):=IF X = [] THEN Y ELSE
           IF MEMBER(T:FIRST(X),Y) THEN UNION(REST(X),Y)
           ELSE CONS(T,UNION(REST(X),Y)$

(C2) UNION([A,B,1,1/2,X**2],[-X**2,A,Y,1/2]);

                         2            2        1
(D2)                   [X , 1, B,  - X , A, Y, -]
                                               2
.end continue

In this example T is assigned the value of FIRST(X) in the call to MEMBER and is
referenced later in CONS(T,UNION(...)).

.example
(C3) BERNPOLY(X,5);
.begin group
                               4      3
                        5   5 X    5 X    X
(D3)                   X  - ---- + ---- - -
                             2      3     6
.end

(C4) MAPLIST(NUMFACTOR,%);
.begin group
                             5  5    1
(D4)                   [1, - -, -, - -]
                             2  3    6
.end

(C5) APPLY(MIN,%);
.begin group
                                  5
(D5)                            - -
                                  2
.end

.end
.endfunction

.next page
.sec (Graphing Functions,graphing!functions,1)

The functions described below produce point-plots of functions given either
explicitly or as tabulated values.  Further detail is given in section 11.0.

.function (PLOT,|exp, var, low, high|)
produces a character-plot of the expression 2exp1 as 2var1 (the independent
variable) ranges from 2low1 to 2high1.  An optional fifth argument of
INTEGER causes PLOT to choose only integer values for 2var1 in the given
domain.

.endfunction

.function(PARAMPLOT,|[f1(t), g1(t), ...h1(t)], [f2(t), g2(t), ..., h2(t)], t, low, high, [list of plotting characters]| )
plots the plane curves f(t) = (f1,f2), g(t) = (g1,g2),...,h(t) = (h1,h2)  using the specified plotting characters or the default "*". 

.endfunction

.function (GRAPH,|xlist, ylist, xlabel, ylabel|)
graphs the two lists of data points, and labels the axes
as indicated or omits labels if just the first two arguments are given.

.endfunction

.function(MULTIGRAPH,|[[xset1, yset1], ..., [xsetn, ysetn]], optional-args|)
- allows the user to produce a scatter-graph involving several x-domains each with a single y-range; e.g. MULTIGRAPH([[[0,1],[0,1]],[[3,4],[1,2]]],["&"]).

.endfunction

.next page
.sec ("Debugging Functions ",debugging,1)
The functions in this section permit the user to examine his MACSYMA environment and to obtain debugging information.  Further detail is given in section 12.0.

.function (TRACE,|name1, name2, ...|)
gives a trace printout whenever the functions mentioned are
called. TRACE() prints a list of the functions currently under TRACE.

.endfunction

.function (UNTRACE,|name1, ...|)
removes tracing incurred by the TRACE function.  UNTRACE() removes tracing from all
functions.

.endfunction

.function (REMTRACE)
removes the tracing facilities from MACSYMA thus freeing up some storage.  They
will be reloaded when TRACE is used again.

.endfunction

.function (DECLARE,|[var1, var2, ...], BINDTEST|)
causes MACSYMA to give an error message whenever any of
the 2vari1 occur unbound in a computation.

.endfunction

.function (DEBUGMODE,switch)
causes MACSYMA to enter a MACSYMA break loop whenever a MACSYMA error
occurs if 2switch1 is TRUE and to terminate that mode if 2switch1 is FALSE.  If 2switch* is ALL then the user may examine BACKTRACE for the list of functions currently entered.

.endfunction

.function (BREAK,|arg1, ...|)
evaluates and prints its arguments then enters a MACSYMA break loop.

.endfunction


.skip 2 once center
2Options and Variables
.skip 1

$var<%%> the value of the last computation performed while in a (MACSYMA-BREAK).

$var<DEBUG[FALSE]> if TRUE causes a message to be printed each time a bound variable is
used for the first time in a computation.

$var<PREDERROR[TRUE]> - if TRUE causes a message to be printed whenever the
predicate of an IF statement or an IS function fails to evaluate to either TRUE
or FALSE.

$var<SETCHECK[FALSE]> - if set to a list of variables (which can be subscripted)
will cause a printout whenever the variables, or subscripted occurrences of
them, are bound (with : or :: or function argument binding).  The printout
consists of the variable and the value it is bound to.   SETCHECK may be set to  ALL or TRUE thereby including all variables.


$var<SETCHECKBREAK[FALSE]> - if set to TRUE will cause a (MACSYMA-BREAK) to
occur whenever the variables on the SETCHECK list are bound.

$var<BACKTRACE> (when DEBUGMODE(ALL) has been done) has as value a list of all functions currently entered.
(see Chapter 12).


.next page
.sec ("Utility, Input-Output, and Display Functions",utility!functions)

.subsec (Functions for Displaying,display!functions)

.function (DISPFUN,|f1, f2, ...|)
displays the definition of the user defined functions 2f1, f2, ...* which may
also be the names of array associated functions, subscripted functions, or
functions with constant subscripts which are the same as those used when the
functions were defined. DISPFUN(ALL) will display all user defined functions as
given on the $var<FUNCTIONS> and $var<ARRAYS> lists except subscripted functions
with constant subscripts.

.endfunction

.function (DISPRULE,rulename)
will display a rule with the name 2rulename* as was given by $fun<DEFRULE>,
$fun<TELLSIMP>, or $fun<TELLSIMPAFTER> or a pattern defined by $fun<DEFMATCH>.  For
example, the first rule modifying SIN will be called SINRULE1. (see sect 6.13.2)

.endfunction

.function (DISPLAY,|expr1, expr2, ...|)
displays equations whose left side is 2expri1 unevaluated, and
whose right side is the value of the expression centered on the line.  This function
is useful in blocks and FOR statements in order to have intermediate results
displayed.  The arguments to DISPLAY are usually atoms, subscripted variables, or
function calls.  (see the DISP function below.)

.example
(C1) DISPLAY(B[1,2]);

.begin group
                                      2
                         B     = X - X
                          1, 2
.end

(D1)                            DONE

.end
.endfunction

.function(LDISPLAY,|expr1,expr2,...|)
is like DISPLAY but also generates intermediate labels.

.endfunction

.function (DISP,|expr1,expr2, ...|)
is like DISPLAY but only the value of the arguments are displayed rather
than equations.  This is useful for complicated arguments which don't have names or
where only the value of the argument is of interest and not the name.

.endfunction

.function(LDISP,|expr1,expr2,...|)
is like DISP but also generates intermediate labels.

.endfunction

.function (PRINT,|exp1, exp2, ...|)
evaluates and displays its arguments one after the other "on a line"
starting at the leftmost position.  If 2expi1 is unbound or is preceded by a single
quote or is enclosed in "s then it is printed literally.  For example, PRINT("THE
VALUE OF X IS ",X).  The value returned by PRINT is the value of its last argument.
No intermediate lines are generated.

.endfunction

.function (DISPTERMS,expr)
displays its argument in parts one below the other.  That is, each term in
a sum or factor in a product is displayed separately.  This is useful if 2expr1 is too
large to be otherwise displayed.  For example if P1, P2, ... are very large
expressions then the display program may run out of storage space in trying to display
P1+P2+... all at once. However, DISPTERMS(P1+P2+...) will display P1, then below it P2,
etc.
When not using DISPTERMS, if an exponential expression is too wide to be displayed as A**B it will appear
as EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).

.endfunction

.function (REVEAL,|exp,depth|)
will display 2exp1 to the specified integer 2depth1 with
the length of each part indicated.  Sums will be displayed as
SUM(n) and products as PRODUCT(n) where n is the
number of subparts of the sum or product.  Exponentials will
be displayed as EXP.

.EXAMPLE

(C1) INTEGRATE(1/(X^3+2),X)$

(C2) REVEAL(%,2);
(D2)              PRODUCT(3) + PRODUCT(3) + PRODUCT(3)

.BEGIN GROUP
(C3) REVEAL(D1,3);
		    EXPT LOG                    EXPT LOG
(D3)              - -------- + EXPT EXPT ATAN + --------
		       6                           3

.END
.END
.endfunction
 
.function (PLAYBACK,arg)
"plays back" input and output lines.  If 2arg1=n (a number) the last n
expressions (Ci, Di, and Ei count as 1 each) are "played-back", while if 2arg1 is
omitted, all lines are.  If 2arg1=INPUT then only input lines are played back. 
If 2arg1=[m,n] then all lines with numbers from m to n inclusive are played-back.
If m=n then [m] is sufficient for arg.  2Arg1=SLOW places PLAYBACK in a slow-mode
similar to $fun<DEMO>'s (as opposed to the "fast" $fun<BATCH>). This is useful in
conjunction with $fun<SAVE> or $fun<STRINGOUT> (see below) when creating a
secondary-storage file in order to pick out useful expressions.  If 2arg1=TIME
then the computation times are displayed as well as the expressions. 
2Arg1=STRING strings-out (see $fun<STRING> function below) all input lines when
playing back rather than displaying them.  One may include any number of options as in PLAYBACK([5,10],20,TIME,SLOW).

.endfunction

.function (STRING,expr)
converts 2expr1 to MACSYMA's linear notation (similar to FORTRAN's) just as if
it had been typed in and puts 2expr1 into the buffer for possible editing (in which
case 2expr1 is usually Ci)  (see section 8.2).  The STRING'ed expression should not be
used in a computation.

.endfunction

.function(FORTRAN,exp) 
converts 2exp* into a FORTRAN linear expression in legal FORTRAN with 6 spaces inserted at the beginning of each line,continuation lines,and ** rather than ^ for exponentiation.
.endfunction

.function(FORTMX,|name,matrix|)
converts a MACSYMA 2matrix* into a sequence of FORTRAN assignment statements of the form

   2name*(i,j)=  <the ij 2matrix* element> 

.endfunction

.function (STRINGOUT,args)
will output an expression to a file in a linear format. STRINGOUT([filespec],...,FUNCTIONS,...) puts all the user's function definitions in the specified file. (see 6.10.3)

.endfunction

.function(DESCRIBE,|function|)
prints out the portion of the MACSYMA manual describing the 2function*.
.endfunction

.function (EXAMPLE,|function|)
does a DEMO of  relevant examples involving 2function*.
.endfunction

.subsec (Functions for Freeing Storage,freeing!storage)

.function (REMOVE,args)
will remove some or all of the properties associated with variables or
functions. (see 6.12)

.endfunction

.function (REMFUNCTION,|f1, f2, ...|)
removes the user defined functions 2f1,f21,... from
MACSYMA.  If there is only one argument of ALL then all functions are removed.

.endfunction

.function (REMVALUE,|name1, name2, ...|)
removes the values of user variables (which can be subscripted) from the system.
If name is ALL then  the values of all user variables are removed.  Values are
those items given names by the user as opposed to those which are automatically
labeled by MACSYMA as Ci, Di, or Ei.

.endfunction

.function (REMARRAY,|name1, name2, ...|)
removes arrays and array associated functions and frees the
storage occupied.  If name is ALL then all arrays are removed.  It may be necessary to
use this function if it is desired to redefine the values in a hashed array.

.endfunction

.function (REMRULE,|function, rulename|)
will remove a rule with the name 2rulename1 from the 2function1 which was
placed there by $fun<DEFRULE>, $fun<DEFMATCH>,  $fun<TELLSIMP>, or
$fun<TELLSIMPAFTER>.  If 2rule-name1 is ALL, then all rules will be removed. (see
example in 6.13.2)

.endfunction

.function (KILL,|arg1, arg2, ...|)
eliminates its arguments from the MACSYMA system.  If 2argi1 is a variable
(including a single array element), function, or array, the designated item with
all of its properties is removed from core. If 2argi1=LABELS then all input,
intermediate, and output lines to date (but not other named items) are
eliminated. If 2argi1=CLABELS then only input lines will be eliminated;  if 2argi1=ELABELS then only intermediate E-lines will be eliminated; if 2argi1=DLABELS only the output lines will be eliminated.
 If 2argi1 is the name of any of the other information lists (the elements of the MACSYMA variable $var<INFOLISTS>), then every item in that class (and its properties) is
KILLed and if 2argi1=ALL then every item on every information  list
previously defined as well as LABELS is KILLed.  If 2argi1=a number (say n),
then the last n lines (i.e. the lines with the last n line numbers) are deleted.
If 2argi1 is of the form [m,n] then all lines with numbers between m and n
inclusive are killed. Note that KILL(VALUES) or KILL(variable) will not freeup
the storage occupied unless the labels which are pointing to the same
expressions are also KILLed.  Thus if a large expression was assigned to X on
line C7 one should do KILL(D7) as well as KILL(X) to release the storage
occupied.


KILL removes all properties from the given argument thus KILL(VALUES) will kill
all properties associated with every item on the VALUES list whereas the REMOVE set of
functions ($fun<REMVALUE>,$fun<REMFUNCTION>,$fun<REMARRAY>,$fun<REMRULE>) remove a specific property.  Also the latter print out a list of names or
FALSE if the specific argument doesn't exist whereas KILL always has value "DONE" even
if the named item doesn't exist (see 6.12).

MACSYMA options may not be killed.  The user may do RESET() ($see<>) to reset all options to their default values.

Note that killing expressions will not help the problem indicated by  "NO CORE - FASLOAD" which results when either too many FASL files have been loaded in or when allocation level has gotten too high.  In either of these cases, no amount of killing will cause the size of these spaces to decrease.  Killing expressions only causes some spaces to get emptied out but not made smaller.


.endfunction

.subsec (Functions Which Reference Disk Files,disk!storage)


.function (LOADFILE,|fn1, fn2, DSK, directory|)
loads a file as designated by its arguments.  This function may be used to bring
back quantities that were stored from a prior MACSYMA session by use of the SAVE or
STORE functions.  If 2DSK1 and 2directory1 are omitted then the last directory
seen (initially the same as the user's login name or USERS if the user has no file directory) will be used.  If 2DSK1 and 2directory1 are omitted, 2fn21 may also
be omitted if 2fn11 > is to be loaded in (where > follows the conventions of
ITS's file system).  2Fn11 2fn21 must be a file of LISP functions and
expressions, not of MACSYMA command lines, in which case BATCH or DEMO is to be
used.  (See Chapter 8).

.endfunction

.function (DELFILE,|file-specification|)
will delete the file given by the 2file-specification1
(i.e. firstname secondname device user) from the given device.

.endfunction

.function (BATCH,|file-specification|)
reads in and evaluates MACSYMA command lines from a file. (see
Chapter 8).

.endfunction

.function (DEMO,|file-specification|)
same as BATCH but pauses after each command line and continues when a space is typed.
(see Chapter 8).

.endfunction

.function (BATCON,argument)
continues BATCHing in a file which was interrupted.  ($see<batconfun>).

.endfunction

.function (WRITEFILE,|DSK, directory|)
opens up a file for writing.

.endfunction

.function (APPENDFILE,|filename1, filename2, DSK, directory|)
is like WRITEFILE(DSK,2directory1) but appends
to the file whose name is specified by the first two arguments.
A subsequent CLOSEFILE will delete the original file and
rename the appended file.

.endfunction

.function (CLOSEFILE,|filename1, filename2|)
closes a file opened by WRITEFILE and gives it the name
2filename11 2filename21.  Thus to save a file consisting of the display of all
input and output during some part of a session with MACSYMA the user issues a WRITEFILE,
transacts with MACSYMA, then issues a CLOSEFILE.
The user can also issue the PLAYBACK function after a WRITEFILE to save the
display of previous transactions.  (Note that what is saved this way is a copy
of the 2display1 of expressions not the expressions themselves).  To save the
actual expression in internal form the SAVE function may be used.  The
expression can then be brought back into MACSYMA via the LOADFILE function.  To
save the expression in a linear form which may then be BATCHed in later, the
STRINGOUT function is used. (see below)

.endfunction

.function (STRINGOUT,|file-specification, A1, A2, ...|)
outputs to a file given by 2file-specification1
([filename1,filename2,DSK, directory]) the values given by 2A1,A21,.. in a
MACSYMA readable format.  The 2file-specification1 may be omitted, in which
case the default values will be used. (see sect. 9.2 - C)  The 2Ai1 are
usually C labels or may be INPUT meaning the value of all C labels.   Another option is to make 2ai1 FUNCTIONS which will cause all of the user's function definitions to be strungout (i.e. all those retrieved by DISPFUN(ALL)). 2ai1 may
also be a list [m,n] which means to stringout all labels in the range m through
n inclusive.  This function may be used to create a file of FORTRAN statements
by doing some simple editing on the strungout expressions.  The function
FORTRAN(TRUE) should be executed first, however, to cause exponentiation to be
strung as ** rather than as ^, as well as to effect other FORTRAN-like changes.

.endfunction

.function (SAVE,arg1)
saves quantities described by its arguments on disk and keeps them in core
also. (see section 9.3).

.endfunction

.function (STORE,args)
same as SAVE but doesn't retain quantities in core. (see section 9.3).

.endfunction

.function(FASSAVE,args)
is similar to SAVE but produces a FASL file in which the sharing of subexpressions which are shared in core is preserved in the file created.  Hence, expressions which have common subexpressions will consume less space when loaded back from a file created by FASSAVE rather than by SAVE.

.endfunction

.function (DSKGC,TRUE)
will cause user defined values, functions, arrays, and line labelled
expressions to be automatically stored on disk whenever the system determines that the
available in-core space is getting low.  DSKGC(2FALSE1) will turn off the automatic
storing mechanism activated by DSKGC(2TRUE1).  (see also sect. 9.2).

.endfunction

.function (UNSTORE,|name1, ...|)
brings the named expressions into core that were stored away by use of
the STORE function in the current MACSYMA. (see section 9.3).

.endfunction

.function (RESTORE,|file-specification|)
reinitializes all quantities filed away by a use of the SAVE
or STORE functions, in a prior MACSYMA session, from the file given by
2file-specification1 without bringing them into core. (see section 9.4).

.endfunction

.function(REMFILE)
removes files created by the secondary storage scheme in the MACSYMA under use
(see section 9.2).  REMFILE(TRUE) does what REMFILE() does and in addition deletes
any files which have been created by the SAVE or STORE functions but which have not
been assigned names by the user.

.endfunction

.subsec (Miscellaneous Functions,miscfun)

.function (TIME,|Di1, Di2, ...|)
gives a list of the times in milliseconds taken to compute the 2Di1.

.endfunction

.function (LOGOUT)
causes the user to be logged out and all jobs deleted.  This is useful when it is
desired to BATCH in a file and have the terminal logged out automatically when the
computations are finished.  (Equivalent to ^Z and :LOGOUT)

.endfunction

.function (QUIT)
kills the current MACSYMA but doesn't affect the user's other jobs.  (Equivalent to
^Z and :KILL).

.endfunction

.function (READ,|string1, ...|)
prints its arguments, then reads in and evaluates one expression.  For
example:  A:READ("ENTER THE NUMBER OF VALUES").

.endfunction

.function (DEFINE,|f(x1, ...), body|)
is equivalent to f(x1,...):=' 'body but when used inside functions it happens at
execution time rather than at the time of definition of the function which contains
it.  (see sect. 4.2)

.endfunction

.function (LOCAL,|v1, v2, ...|)
causes the variables 2v1,v2,...1 to be local with respect to all the properties
in the statement in which this function is used (see 3.12).  LOCAL may only be used
in BLOCKs, in the body of function definitions or LAMBDA expressions, or in the EV
function and only one occurrence is permitted in each.

.endfunction

.function (ERROR,|arg1, arg2, ...|)
will evaluate and print its arguments and then will cause an error return to top
level MACSYMA or to the nearest enclosing ERRCATCH.  This is useful for breaking out of nested functions if an error
condition is detected, or wherever one can't type control-^.

$var<ERRORFUN[FALSE]> - if set to the name of a function of no arguments will cause
that function to be executed whenever an error occurs.  This is useful in BATCH files
where the user may want his MACSYMA killed or his terminal logged out if an error
occurs.  In these cases ERRORFUN would be set to QUIT or LOGOUT.

.endfunction

.function (ERRCATCH,|exp1, exp2, ...|)
evaluates its arguments one by one and returns a list of the value of the last
one if no error occurs.  If an error occurs in the evaluation of any arguments,
ERRCATCH "catches" the error and immediately returns [] (the empty list).  This
function is useful in BATCH files where one suspects an error might occur which
would otherwise have terminated the BATCH if the error weren't caught.

.endfunction

.function(CATCH,|exp1,...,expn|)
evaluates its arguments one by one; if the structure of the 2expi1 leads to the evaluation of an expression of the form THROW(arg),  then the value of the CATCH is the value of THROW(arg).  This  "non-local return"  thus goes through any depth of nesting to the nearest enclosing CATCH.  There must be a CATCH corresponding to a THROW, else an error is generated.     
If the evaluation of the 2expi1 does not lead to the evaluation of any THROW then the value of the CATCH is the value of  2expn1.  

.example

(C1) G(L):=CATCH(MAP(LAMBDA([X],
       IF X<0 THEN THROW(X) ELSE F(X)),L))$

(C2) G([1,2,3,7]);
(D2) 			 [F(1), F(2), F(3), F(7)]

(C3) G([1,2,-3,7]);
(D3) 				    - 3

.end

The function G returns a list of  F of each element of L  if  L consists only of non-negative numbers; otherwise, G "catches"  the first negative element of L and "throws" it up.

.endfunction

.function(THROW,exp)
evaluates  2exp1 and throws the value back to the most recent CATCH.  THROW is used with CATCH as a structured nonlocal exit mechanism.

.endfunction

.function (BREAK,|arg1, ...|)
will evaluate and print its arguments and will then cause a
(MACSYMA-BREAK) at which point the user can examine and change his environment.  Upon
typing EXIT; the computation resumes. (see 12.0)

.endfunction

.function(RESET)
causes all MACSYMA options to be set to their default values.

.endfunction

.function (%TH,i)
is the 2i1th previous computation.  That is, if the next expression to be computed is
D(j) this is D(j-2i1).  This is useful in BATCH files or for referring to a group of D
expressions.  For example, if SUM is initialized to 0 then FOR I:1 THRU 10 DO
SUM:SUM+%TH(I) will set SUM to the sum of the last ten D expressions.

.endfunction

.function (CONCAT,|arg1, arg2, ...|)
evaluates its arguments and returns the concatenation of their
values resulting in a name or a quoted string (see 3.2 and 3.3) the type being given
by that of the first argument.  Thus if X is bound to 1 and D is unbound then
CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.

.endfunction

.function (GETCHAR,|a, i|)
returns the 2i1th character of the
quoted string or atomic name 2a1.  This function is useful
in manipulating the LABELS list.

.endfunction

.function (STATUS,arg)
will return miscellaneous status information about the user's MACSYMA
depending upon the 2arg1 given.  Permissible arguments and results are as follows:

.skip 1
.begin preface 0
TIME - the time used so far in the computation.

DAY - the day of the week.

DATE - a list of the year, month, and day.

DAYTIME - a list of the hour, minute, and second.

RUNTIME - accumulated cpu time times the atom "MSEC".

WRITEFILE - a list of the device and username for the current writefile or an empty
list if no WRITEFILE has been done.

LOADFILE - a list of the first file name, second file name, device, and username for
the current BATCH, DEMO, or LOADFILE function.

FILE - a list of the current first file name and second file name.

UNIT - a list of the current device and username.

.end
.endfunction

.function (ALARMCLOCK,|arg1, arg2, arg3|)
will execute the function of no arguments whose name is 2arg31 when the time
specified by 2arg11 and 2arg21 elapses.  If 2arg11 is the atom "TIME" then
2arg31 will be executed after 2arg21 seconds of real-time has elapsed while
if 2arg11 is the atom "RUNTIME" then 2arg31 will be executed after 2arg21
milliseconds of cpu time. If 2arg21 is negative then the 2arg11 timer is shut
off.

.endfunction

.function(BOTHCASES,TRUE)
will cause MACSYMA to retain lower case text as well as upper case.
Note, however, that the names of any MACSYMA special variables or functions must be typed
in upper case.

BOTHCASES(FALSE) causes MACSYMA to revert to the normal mode of lower to upper case
conversion.

.endfunction

.function(STARDISP,FALSE)
if TRUE will cause multiplication to be displayed explicitly with an  * between operands.

.endfunction

.function(LABELS,char)
takes a char C,D,or E as arg and generates a list of all C-labels,D-labels, or E-labels, respectively.  (If you've generated many E-labels via SOLVE, then FIRST(REST(LABELS(C))); reminds you what the last C-label was.)

.endfunction

.function(ALIAS,|newname1, oldname1, newname2, oldname2, ...|) 
provides an alternate name for a (user or system) function,variable,array,etc.  Any even number of arguments may be used.

.endfunction


.subsec (Ordering Functions,ordering!functions,1)

Aside from declaring a variable to be constant or using options like POWERDISP (see below), the
only other way in which a user can alter the ordering of parts of an expression is to
set up special aliases for variables which cause them to be alphabetically less than
or greater than any other variables.  Functions which do this are described below.
This technique requires care because although the names have been aliased, they
display with their original name.  Aside from the input/output phase the two names
represent two different symbols and thus expressions which contain both the original
name and the alias will not be simplified as the user desires.  This is shown in the
examples below.

.function (ORDERGREAT,|V1, ..., Vn|)
sets up aliases for the variables 2V1, ..., Vn* such that
2V1* > 2V2* > ... > 2Vn* > any other variable not mentioned as an argument.

.endfunction

.function (ORDERLESS,|V1, ..., Vn|)
sets up aliases for the variables 2V1, ..., Vn* such that
2V1* < 2V2* < ... < 2Vn* < any other variable not mentioned as an argument.  Thus
the complete ordering scale is:
numerical constants < declared constants < first argument
to ORDERLESS < ... < last argument to ORDERLESS < variables which
begin with A < ... < variables which begin with Z < last
argument to ORDERGREAT < ... < first argument to ORDERGREAT.

.endfunction

.function (UNORDER)
removes the aliases created by the last use of the above ordering commands.
ORDERGREAT and ORDERLESS may not be used more than one time each without calling
UNORDER.

.example
(C1) A**2+B*X;
.begin group
                                        2
(D1)                             B X + A
.end

(C2) ORDERGREAT(A);
(D2)                               DONE

(C3) A**2+B*X;
.begin group
                                  2
(D3)                             A  + B X
.end

(C4) %-D1;
.begin group
                                  2    2
(D4)                             A  - A
.end

(C5) UNORDER();
(D5)                               [A]

.end
.endfunction

.begin group
.skip 2
.once center
2MACSYMA Options and Variables for I/O, Status, and Display*

.skip 1
$var<TIME[FALSE]> - if TRUE causes MACSYMA to print the cpu time taken by each
computation. This figure does not include I/O time except in the case of the
time given at the end of running a batch file.  By setting TIME:ALL, in addition to the cpu time MACSYMA now also prints out (when not zero) the amount of time spent in garbage collection (gc) in the course of a computation.  This time is of course included in the time printed out as "TIME=" .
.end
(It should be noted that since the "TIME=" time only includes computation time and not any intermediate display time, and since it is difficult to ascribe "responsibility" for  gc's,  the gctime printed will include all gctime incurred in the course of the computation and hence may in rare cases even be larger than "TIME=").

$var<LASTTIME>  - the time to compute the last expression in milliseconds presented as a list of "TIME" and "gctime" .

$var<OPTIONSET[FALSE]> - if TRUE, MACSYMA will print out a message whenever a
MACSYMA option is reset.  This is useful if the user is doubtful of the spelling
of some option and wants to make sure that the variable he assigned a value to
was truly an option variable.

$var<NOLABELS[FALSE]> - if TRUE then no labels will be bound except for E lines
generated by the solve functions (sect. 6.3).  This is most useful in the "BATCH"
mode where it eliminates the need to do KILL(LABELS) in order to free up
storage.

$var<BFTRUNC[TRUE]> causes trailing zeroes in non-zero bigfloat numbers not to be displayed.  Thus, if BFTRUNC:FALSE, BFLOAT(1); displays as 1.000000000000000B0. Otherwise, this is displayed as 1.0B0.

$var<EXPTDISPFLAG[TRUE]> - if TRUE, MACSYMA displays expressions with negative
exponents using quotients e.g., X**(-1) as 1/X.

$var<%EDISPFLAG[FALSE]> - if TRUE, MACSYMA displays %E to a negative exponent as
a quotient, i.e. %E^-X as 1/%E^X.

$var<SQRTDISPFLAG[TRUE]> - if FALSE causes SQRT to display with exponent 1/2.

$var<PFEFORMAT[FALSE]> - if TRUE will cause rational numbers to display in a
linear form and denominators which are integers to display as rational number
multipliers.


$var<DISPFLAG[TRUE]> - if set to FALSE within a BLOCK (see sect. 2.11) will
inhibit the display of output generated by the solve functions (see 6.3) called
from within the BLOCK.  Termination of  the BLOCK with a dollar sign, $, sets DISPFLAG to FALSE.

$var<NOUNDISP[FALSE]> - if TRUE will cause NOUNs to display with a single quote.
This switch is always TRUE when displaying function definitions.

$var<POWERDISP[FALSE]> - if TRUE will cause sums to be displayed with their
terms in the reverse order.  Thus polynomials would display as truncated
power series, i.e., with the lowest power first.

$var<LABELS> - a list of C, D, and E lines which are bound.

$var<INCHAR[C]> - the alphabetic prefix of the names of expressions typed by the
user.

$var<LINECHAR[E]> - the alphabetic prefix of the names of intermediate displayed
expressions.

$var<OUTCHAR[D]> - the alphabetic prefix of the names of outputted expressions.

$var<LINENUM> - the line number of the last expression.

$var<CURSOR[_]> is the prompt symbol of the MACSYMA editor, DEMO function,
PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).  (see chapters 7 and 12).

$var<GENINDEX[I]> -the alphabetic prefix of the index of summation for generated
sums. (The values of GENINDEX and of the above four variables may be any number
of characters though the default is a single character.)

$var<IBASE[10]> - the base for inputting numbers.

$var<BASE[10]> - the base for display of numbers.

$var<LINEL> - the length of the printed line on the terminal.  Also used for
plotting (see section 11.0).

$var<PLOTHEIGHT> - the height of the area used for plotting. (see section 11.0)

$var<VERSION[256]> - is the version number of MACSYMA.  This could be useful if
the user wants to label his output.

$var<INFOLISTS> is the list of all the information lists which are in MACSYMA:
.skip begin nofill
[LABELS,VALUES,FUNCTIONS,ARRAYS,PROPS,ALIASES,RULES,
			GRADEFS,DEPENDENCIES]
.end
.skip
Initially, all these information lists are empty.  As the user proceeds with his computation, he may examine these lists when necessary.


.next page
.sec ( Functions for Translation and Compilation,compilation,1)

.function (MODEDECLARE,|y1, mode1, y2, mode2, ...|)
is used to declare the modes of variables and
functions for subsequent translation or compilation of functions.  It can also influence trigonometric simplification  ($see<othergpf> for an example).
Its arguments are
pairs consisting of a variable yi, and a mode which is one of BOOLEAN, INTEGER, FLOAT,
POLY (for polynomial), or CRE (for expression in CRE form).

.skip 1
If 2yi* is an array, and if every element of the array which is referenced in the
function has a value then ARRAY(2yi*, COMPLETE, d1, d2, ...) rather than
ARRAY(2yi*, d1, d2, ...) should be used when first declaring the bounds of the array. If all the elements of the array are of mode INTEGER (FLOAT), use INTEGER (FLOAT) instead of COMPLETE. 
Also if every element of the array is of the same mode, say 2m*, then
MODEDECLARE(COMPLETEARRAY(2yi*),2m*)) should be used for efficient translation.  Also numeric code using arrays can be made to run faster by declaring the expected size of the array, as in:
.once center
MODEDECLARE(COMPLETEARRAY(A[10,10]),FLOAT)

.scon
for a floating point number array which is 10 x 10.

Each 2yi* may also be a list of variables all of which are declared to have 2modei*.

Additionally one may declare the mode of the result of a function by using
FUNCTION(name) as an argument where name is the name of the function.  For example the
expression MODEDECLARE([FUNCTION(FUN1),X],POLY,Q,COMPLETEARRAY(Q),FLOAT) declares that X
and the value returned by FUN1 are polynomials and that Q is an array of floating point
numbers.  MODEDECLARE is used either immediately inside of a function definition (see
below) or at top-level for global variables.

.endfunction

.function (TRANSLATE,|f1, f2, ...|)
 translates the user defined functions 2f1,f21,... from the MACSYMA
language to LISP (i.e. it makes them EXPRs).  This results in a gain in speed when
they are called.  The functions should include a call to MODEDECLARE at the beginning
when possible in order to produce more efficient code.  For example:

.example
1F(X1,X2,...):=BLOCK([v1,v2,...],
	MODEDECLARE(v1,mode1,v2,mode2,...),...)

.end
.continue
where the X1,X2,... are the parameters to the function and the v1,v2,... are the local
variables.  The names of translated functions are added to the PROPS lists (see 6.12).  Functions
should not be translated unless they are fully debugged.

$var<TRANSLATE[FALSE]> - If TRUE, causes automatic translation of a user's function to LISP.  Note that translated functions may not run identically to the way they did
before translation as certain incompatabilities may exist between the LISP and MACSYMA
versions.  Principally, the RAT function with more than one argument and the RATVARS
function (see 6.5) should not be used if any variables are MODEDECLAREd CRE.

$var<SAVEDEF[TRUE]> - if TRUE will cause the MACSYMA version of a user function to
remain when the function is TRANSLATEd.  This permits the definition to be displayed
by DISPFUN and allows the function to be edited.  If SAVEDEF is FALSE, the names of translated functions are removed from the FUNCTIONS list.

$var<TRANSRUN[TRUE]> - if FALSE will cause the interpreted version of all
functions to be run (provided they are still around) rather than the translated
version.

One can translate functions stored in a file by giving TRANSLATE an argument
which is a file specification.  This is a list of the form [fn1,fn2,DSK,dir]
where fn1 fn2 is the name of the file of MACSYMA functions, and dir is the name
of a file directory.

Such a file may contain declarations involving DECLARE,MODEDECLARE, or MATCHDECLARE in addition to the function definitions.  However, the fule should not use %, since  %  is not maintained when the translated file is loaded.

The result returned by TRANSLATE is a list of the names of the functions
TRANSLATEd.  In the case of a file translation the corresponding element of the
list is a list of the first and second new file names containing the LISP code
resulting from the translation.  This will be fn1 LISP on the disk directory dir. 
The file of LISP code may be read into MACSYMA by using the $fun<LOADFILE> function
(see 6.10.3).
.endfunction

.function(COMPILE,|f1, f2, ...|)
will compile the user defined functions 2f1,f21,... from MACSYMA to
machine language (i.e. it makes them SUBRs).  This results in a further gain in speed
over the TRANSLATEd version.  The functions are in the form described under the
TRANSLATE function.  



The COMPILE command can also generate FASL files.  Setting $var<COMPFILE[FALSE]> to a list of file specs causes that FASL file to be renamed to the specified file.  Temporary files  .CMPL. EXPR, .CMPL. ERROR, .CMPL. FASL are generated and deleted on the USERS directory.  To keep these files from being deleted, set $var<COMPSAVE[FALSE]> to TRUE.  

.endfunction

.next page
.sec (Property Specification Functions,property!specification,1)

The functions in this section are used to specify properties for atomic
variables.  A property is a piece of information which may be utilized during the
user's session with MACSYMA.  MODEDECLARE (sect. 6.11) is one example of a property
specification function.  Also the subsequent section deals with functions for pattern
matching and includes the function MATCHDECLARE.  As these are somewhat complicated
they are described in other sections.  However along with DECLARE (see below) and
other functions, they all perform the task of setting up information which is used
later.

For most types of properties there exists a name which is an indicator of that
property.  For example the command GRADEF(F(X),SIN(X**2)); causes F to receive a
"gradef" property of LAMBDA([X],SIN(X**2)).  (The indicator is GRADEF and the property
is the lambda expression).

The presence of some properties is signified merely by the presence of the
indicator and requires no additional information.  These indicators are known as flags.
For example %I has associated with it the flag CONSTANT.  We can also speak of
"constant" as being a property of %I.

There are three principal operations which are needed by the user in dealing with
properties.  He must be able to set up the property, to display it, and to remove it.
Also he may sometimes want to know what properties he set up in his MACSYMA.  There
are several lists (known as information lists) which contain all of the atoms
that possess a particular property. Moreover, the value of the variable $var<INFOLISTS> is a list of the names of all of the information lists in MACSYMA. These are:

$var<LABELS> - all bound C,D, and E labels.

$var<VALUES> - all bound atoms (set up by : , :: , or functional binding).

$var<FUNCTIONS> -  all user defined functions (set up by f(x):=...).

$var<ARRAYS> - declared and undeclared arrays (set up by : , :: , or a[x]:=...)

$var<RULES> - user defined pattern matching and simplification rules (set up by
$fun<TELLSIMP>, $fun<TELLSIMPAFTER>, $fun<DEFMATCH>, or, $fun<DEFRULE>.)

$var<ALIASES> - atoms which have a user defined alias (set up by the $fun<ALIAS>,
$fun<ORDERGREAT>, $fun<ORDERLESS> functions or by DECLAREing the atom a NOUN).

$var<DEPENDENCIES> - atoms which have functional dependencies (set up by the
$fun<DEPENDENCIES> or $fun<GRADEF> functions).

$var<GRADEFS> - functions which have user defined derivatives (set up by the
$fun<GRADEF> function).

$var<PROPS> - atoms which have any property other than those mentioned above,
such as atvalues, matchdeclares, etc. as well as properties specified in the
DECLARE function.

In addition to these information lists similar lists may be generated by
the function
.inline function(PROPVARS,prop)
which yields a list of those atoms on the PROPS
list which have the property indicated by 2prop1.  Thus PROPVARS(ATVALUE) will
yield a list of atoms which have atvalues.

.subsec (Functions for Handling MACSYMA Properties,MACSYMA!properties)


.function (DECLARE,|a1, f1, a2, f2, ...|)
gives the atom 2ai1 the flag 2fi1.  The 2ai1's and 2fi1's may also be
lists of atoms and flags respectively in which case each of the atoms gets all of the
properties.  The possible flags and their meanings are:

$var<CONSTANT> - makes 2ai1 a constant as is %PI.

$var<NONSCALAR> - makes 2ai1 behave as does a list or matrix with respect to the dot
operator. (see 6.4.1)

$var<NOUN> - makes the function 2ai1 a noun so that it won't be evaluated
automatically. (see 3.2)

$var<EVFUN> - makes 2ai* known to the EV function so that it will get applied if
its name is mentioned.  Initial evfuns are $fun<FACTOR>, $fun<TRIGEXPAND>,
$fun<TRIGREDUCE>, $fun<BFLOAT>, $fun<RATSIMP>, $fun<RATEXPAND>, and $fun<RADCAN>.

$var<EVFLAG> - makes 2ai1 known to the $fun<EV> function so that it will be bound
to TRUE during the execution of EV if it is mentioned.  Initial evflags are 
$var<FLOAT>, $var<PRED>, $var<SIMP>, $var<NUMER>, $var<DETOUT>,
$var<EXPONENTIALIZE>, $var<DEMOIVRE>, $var<KEEPFLOAT>, $var<LISTARITH>, and
$var<TRIGEXPAND>.

$var<BINDTEST> -  causes 2ai* to signal an error if it ever is used in a computation
unbound. (see 12.0)

.endfunction

.function (ARRAYINFO,a)
returns a list of information about the array 2a1.  For hashed arrays
it returns a list of "HASHED", the number of subscripts, and the subscripts of every
element which has a value.  For declared arrays it returns a list of "DECLARED", the
number of subscripts, and the bounds that were given the the ARRAY function when it
was called on 2a1.

.example
(C1) B[1,X]:1$
(C2) ARRAY(F,2,3)$
(C3) ARRAYINFO(B);

(D3)            [HASHED, 2, [1, X]]
(C4) ARRAYINFO(F);

(D4)            [DECLARED, 2, [2, 3]]
.end

.endfunction

.function (PROPERTIES,a)
will yield a list showing the names of all the properties associated with
the atom 2a1.

.endfunction

.function (PRINTPROPS,|a, i|)
will display the property with the indicator 2i1 associated with the atom
2a1. 2a1 may also be a list of atoms or the atom ALL in which case all of
the atoms with the given property will be used.  For example,
PRINTPROPS([F,G],ATVALUE).     PRINTPROPS is for properties that cannot otherwise be displayed, i.e. for ATVALUE,ATOMGRAD,GRADEF, and MATCHDECLARE.

.endfunction

.function (REMOVE,|a1, p1, a2, p2, ...|)
removes the property 2pi1 from the atom 2ai1.  2Ai1 and 2pi1 may also be
lists as with DECLARE.  2Pi1 may be any property e.g. FUNCTION, MODEDECLARE, etc.  It
may also be TRANSFUN implying that the translated LISP version of the function is to
be removed.  This is useful if one wishes to have the MACSYMA version of the function
executed rather than the translated version. 2Pi* may also be OP or OPERATOR to remove a syntax extension given to 2ai* (see Appendix II).
 If 2ai1 is "ALL" then the property
indicated by 2pi1 is removed from all atoms which have it.  Unlike the more specific
remove functions (REMVALUE, REMARRAY, REMFUNCTION, and REMRULE) REMOVE does not
indicate when a given property is non-existent; it always returns "DONE".

.endfunction

.subsec (Functions for Handling Users' Properties,uspropfun)

.function (PUT,|a, p, i|)
associates with the atom 2a1 the property 2p1 with the indicator 2i1.  This
enables the user to give an atom any arbitrary property.

.endfunction

.function (QPUT,|a, p, i|)
is similar to PUT but it doesn't have its arguments evaluated.

.endfunction

.function (GET,|a, i|)
retrieves the user property indicated by 2i1 associated with atom 2a1 or
returns FALSE if 2a1 doesn't have property 2i1.

.example
(C1) PUT(%E,TRANSCENDENTAL,TYPE);
(D1)                          TRANSCENDENTAL

(C2) PUT(%PI,TRANSCENDENTAL,TYPE)$

(C3) PUT(%I,ALGEBRAIC,TYPE)$

.begin group
(C4) TYPEOF(X) := BLOCK([Q], IF NUMBERP(X)
	   THEN RETURN(ALGEBRAIC),
           IF NOT ATOM(X)
	   THEN RETURN(MAPLIST(TYPEOF, X)),
           Q : GET(X, TYPE), IF Q=FALSE THEN
           ERROR("NOT NUMERIC") ELSE Q)$
.end

(C5) TYPEOF(2*%E+X*%PI);

.begin group
NOT NUMERIC
QUIT
(C6) TYPEOF(2*%E+%PI);
(D6)          [[ALGEBRAIC, TRANSCENDENTAL],
			TRANSCENDENTAL]
.end

.end
.endfunction

.function (REM,|a, i|)
removes the property indicated by 2i1 from the atom 2a1.

.endfunction

.function (NUMERVAL,|var1, exp1, var2, exp2, ...|)
declares 2vari1 to have a numerval of 2exp11 which is evaluated and
substituted for the variable in any expressions in which the variable occurs if
the $var<NUMER> flag is TRUE. (see the EV function sec. 6.1.1).

.endfunction

.subsec (Functions for Relational Information,relinfun)

.function (ASSUME,|pred1, pred2, ...|)
stores information in MACSYMA about the relation among various variables and their relation to
zero (>, =, etc.) on the basis of the given predicates.  This information can be
utilized later in conditional statements such as IF or in the functions IS, SIGN or
INTEGRATE (certain cases of integration requiring sign information).
The information is added to the data base and is tested for consistency against
previously given relations.


.endfunction


.function(ZEROEQUIV,|exp,var|)
is a zero-equivalence testing algorithm.  It returns  either TRUE,FALSE, or DONTKNOW. (see section 6.1.1).

.endfunction


.function (IS,exp)
tries to determine if 2exp1 (which must evaluate to a predicate) is TRUE or FALSE.
If it can't determine this, then a simplified but equivalent form of 2exp1 is returned.  TRUE (or
FALSE) is returned only if the relation 2exp1 (which is composed of variables,
comparison operators, and predicate functions) is TRUE (or FALSE) for all possible
values of its variables.

.skip 1
The operator = compares two expressions to determine if they are identical after
all evaluations have been done.  Thus IS(X+1=2) returns TRUE if and only if X
has the value 1. 
.inline function(EQUAL,|expr1,expr2|)
 on the other hand returns TRUE (or
FALSE) if and only if 2expr11 and 2expr21 are equal (or not equal) for all
possible values of their variables (as determined by RATSIMP).  Thus
IS(EQUAL((X+1)**2,X**2+2*X+1)) returns TRUE whereas if X is unbound
IS((X+1)**2=X**2+2*X+1) returns FALSE.  Note also that IS(RAT(0)=0) gives FALSE
but IS(EQUAL(RAT(0),0)) gives TRUE.  If a determination can't be made with EQUAL
then a simplified but equivalent form is returned whereas = always causes either
TRUE or FALSE to be returned.  All variables occurring in 2exp1 are presumed
to be real valued.  EV(2exp1,PRED) is equivalent to IS(2exp1).

.example
(C1)  IS(X**2 >= 2*X-1);
(D1)          TRUE
(C2)  IS(EQUAL(Y**3,1) OR LOG(X) > 0);
(D2)          EQUAL(Y,1) OR X-1>0

(C3) ASSUME(A>1);
(D3)                               DONE

(C4) IS(LOG(LOG(A+1)+1)>0 AND A^2+1>2*A);

(D4)                               TRUE

.end

.endfunction

.function (SIGN,exp)
uses ASSUMEd information (if any) or asks the user in determining the
sign (POS, NEG, or ZERO) of 2exp1.

.endfunction

.function (FORGET,|pred1, pred2, ...|)
removes relations established by ASSUME.  The predicates may
be expressions equivalent to (but not necessarily identical to) those previously ASSUMED. 

.endfunction

.next page
.sec (Pattern Matching and Related Functions,patternfun,1)

.subsec (Type Testing Functions,typtestfun,1)

.function (ATOM,exp)
is TRUE if 2exp1 is atomic (i.e. a number or name) else FALSE.  Thus ATOM(5) is
TRUE while ATOM(A[1]) and ATOM(SIN(X)) are FALSE.  (Assuming A[1] and X are unbound.)

.endfunction

.function (CONSTANTP,exp)
is TRUE if 2exp1 is a constant (i.e. composed of numbers and %PI, %E,
%I or any variables bound to a constant or DECLAREd constant [see section 6.12.1]) else
FALSE.  Any function whose arguments are constant is also considered to be a
constant.

.endfunction

.function (NONSCALARP,exp)
is TRUE if 2exp1 is a non-scalar, i.e. it contains atoms declared as
non-scalars (see 6.12), lists, or matrices.

.endfunction

.function (INTEGERP,exp)
is TRUE if 2exp1 is an integer else FALSE.

.endfunction

.function (FLOATNUMP,exp)
is TRUE if 2exp1 is a floating point number else FALSE.

.endfunction

.function(BFLOATP,exp)
is TRUE is 2exp1 is a bigfloat number else FALSE.

.endfunction

.function (NUMBERP,exp)
is TRUE if 2exp1 is an integer, a rational number, a floating point number or a bigfloat
else FALSE.

.endfunction

.function (RATNUMP,exp)
is TRUE if 2exp1 is a rational number (includes integers) else FALSE.

.endfunction

.function (LISTP,exp)
is TRUE if 2exp1 is a list else FALSE.

.endfunction

.function (MATRIXP,exp)
is TRUE if 2exp1 is a matrix else FALSE.

.endfunction

.function (RATP,exp)
is TRUE if 2exp1 is in CRE or extended CRE form else FALSE.

.endfunction

.function (FREEOF,|x1, x2, ..., exp|)
yields TRUE if the  2xi1 do not occur in 2exp1 and FALSE otherwise.
The x2i1 are atoms or they may be subscripted names, functions (e.g. SIN(X) ), or
operators enclosed in "s.  They may also be lists of these objects.

.example
(C1) FREEOF(Y,SIN(X+2*Y));

(D1)                    FALSE

(C2) FREEOF(COS(Y),"*",SIN(Y)+COS(X));

(D2)                          TRUE
.end
.endfunction

.subsec (General Pattern Matching Functions,patmatfun,1)

The pattern matching functions permit the user to test expressions for
combinations of syntactic and semantic patterns and to automatically have variables
set to parts of expressions which fit the patterns.  This enables one to transform an
expression as well as to see if it fits a pattern.

It is also possible to add simplification rules which apply to user or system
defined functions or operators.  In order to choose the particular rule which applies,
a pattern match must usually be performed on the operands of the expression which is
to be simplified.

.function (MATCHDECLARE,|patternvar, predicate, ...|)
associates a 2predicate1 with a 2pattern1 2variable1 so that the
2variable1 will only match expressions for which the 2predicate1 is not
FALSE.  (The matching is accomplished by one of the functions described below). 
For example after MATCHDECLARE(Q,FREEOF(X,%E)) is executed, Q will match any
expression not containing X or %E.  If the match succeeds then the variable is
set to the matched expression.  The predicate (in this case FREEOF) is written
without the last argument which should be the one against which the pattern
variable is to be tested.  Note that the 2patternvar1 and the arguments to the
2predicate1 are evaluated at the time the match is performed.


The odd numbered argument may also be a list of pattern variables all of which are
to have the associated predicate.  Any even number of arguments may be given.

For pattern matching, predicates refer to functions which are either FALSE or not
FALSE (any non FALSE value acts like TRUE).

MATCHDECLARE(var,TRUE) will permit var to match any expression.

.endfunction

PRINTPROPS([2v1,v2,*...],MATCHDECLARE)
(see 6.12.1) will display the matchdeclare properties of the variables 2v1,v2,*...


.function (TELLSIMPAFTER,|pattern, replacement|)
defines a 2replacement1 for 2pattern1 which the MACSYMA
simplifier uses after it applies the built-in simplification rules.  The 2pattern1 may
be anything but a single variable or a number.

.endfunction

.function (TELLSIMP,|pattern, replacement|)
is similar to TELLSIMPAFTER but places new information
before old so that it is applied before the built-in simplification rules.  The
2pattern1 may not be a sum, product, single variable, or number.

$var<RULES> is a list of names having simplification rules added to them by DEFRULE,
DEFMATCH, TELLSIMP, or TELLSIMPAFTER.

.example
.begin group
(C1) MATCHDECLARE(X,FREEOF(%I))$
(C2) TELLSIMP(SIN(%I*X),%I*SINH(X));
RULE PLACED ON SIN

(D2)            [SINRULE1, SIMP-SIN]

.end
.begin fill indent 0,0
1(SINRULE1 is the name assigned to the TELLSIMP rule from (C2) and SIMP-SIN is the
internal name of the built-in simplifier rule.)
.end

(C3) TRIGEXPAND(SIN(X+%I*Y));

(D3)            SIN(X) COS(%I Y) + %I COS(X) SINH(Y)
(C4) 0^0;
0^0 HAS BEEN GENERATED
(C5) BLOCK([SIMP],SIMP:FALSE,TELLSIMP(0^0,1));

RULE PLACED ON **
(D5)                       [**RULE1, SIMPEXPT]

(C6) 0^0;
(D6)                                1

(C7) REMRULE("**","**RULE1");
(D7)				[ SIMPEXPT ]

.end

.endfunction

.function (DEFMATCH,|progname, pattern, parm1, ..., parmn|)
creates a function of n+1 arguments
with the name 2progname1 which tests an expression to see if it can match a particular
2pattern1.  The 2pattern1 is some expression containing pattern variables and
2parameters1.  The 2parms1
are given explicitly as arguments to DEFMATCH while the pattern variables (if
supplied) were given implicitly in a previous MATCHDECLARE function.  The first
argument to the created function 2progname1, is an expression to be matched against
the "2pattern1" and the other n arguments are the actual variables occurring in the
expression which are to take the place of dummy variables occurring in the
"2pattern1".  Thus the parms in the DEFMATCH are like the dummy arguments to the
SUBROUTINE statement in FORTRAN.  When the function is "called" the actual arguments are
substituted.  For example:

.example group
(C1)  NONZEROANDFREEOF(X,E):=  IF E#0 AND FREEOF(X,E)
            THEN TRUE ELSE FALSE$

.begin fill indent 0,0
(IS(E#0 AND FREEOF(X,E)) is an equivalent function definition - see sect. 6.12 )
.end

(C2)  MATCHDECLARE(A,NONZEROANDFREEOF(X),B,FREEOF(X))$
(C3)  DEFMATCH(LINEAR,A*X+B,X)$

.end

This has caused the function LINEAR(2exp,var11) to be defined.  It tests 2exp1 to
see if it is of the form A*2var11+B where A and B do not contain 2var11 and A is
not zero.  DEFMATCHed functions return (if the match is successful) a list of equations
whose left sides are the pattern variables and parms and whose right sides are the
expressions which the pattern variables and parameters matched.  The pattern variables,
but not the parameters, are set to the matched expressions.  If the match fails, the
function returns FALSE.  Thus LINEAR(3*Z+(Y+1)*Z+Y**2,Z) would return [B=Y**2, A=Y+4,
X=Z].  Any variables not declared as pattern variables in MATCHDECLARE or as
parameters in DEFMATCH which occur in 2pattern1 will match only themselves so that if
the third argument to the DEFMATCH in (C4) had been omitted, then LINEAR would only
match expressions linear in X, not in any other variable.

A pattern which contains no parameters or pattern variables returns
TRUE if the match succeeds.

.example
(C1) MATCHDECLARE([A,F],TRUE)$

(C2) CONSTINTERVAL(L,H):=CONSTANTP(H-L)$

(C3) MATCHDECLARE(B,CONSTINTERVAL(A))$

(C4) MATCHDECLARE(X,ATOM)$

(C5) DEFMATCH(CHECKLIMITS,'INTEGRATE(F,X,A,B))$

(C6) 'INTEGRATE(SIN(T),T,X+%PI,X+2*%PI)$

(C7) CHECKLIMITS(%);

(D7)  [B = X + 2 %PI, A = X + %PI, X = T,

                               F = SIN(T)]

(C8) 'INTEGRATE(SIN(T),T,0,X)$

(C9) CHECKLIMITS(%);

(D9)                    FALSE

.end

.endfunction

.function (DEFRULE,|rulename, pattern, replacement|)
defines and names a 2replacement1 rule for the given p2attern1.  If the rule
named 2rulename1 is applied to an expression (by one of the APPLY functions
below), every subexpression matching the 2pattern1 will be replaced by the
2replacement1.  All variables in the 2replacement1 which have been assigned
values by the pattern match are assigned those values in the 2replacement1
which is then simplified. The rules themselves can be treated as functions which
will transform an expression by one operation of the pattern match and
replacement.  If the pattern fails, the original expression is returned.

.endfunction

.function (APPLY1,|exp, rule1, ..., rulen|)
repeatedly applies the first rule to 2exp1 until it fails, then repeatedly
applies the same rule to all subexpressions of 2exp1, left-to-right, until the
first rule has failed on all subexpressions.  Call the result of transforming
2exp1 in this manner 2exp1'.  Then the second rule is applied in the same
fashion starting at the top of 2exp1'.  When the final rule fails on the final
subexpression, the application is finished.

.endfunction

.function (APPLY2,|exp, rule1, ..., rulen|)
differs from APPLY1 in that if the first rule fails on a given
subexpression, then the second rule is repeatedly applied, etc.  Only if they all fail
on a given subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same subexpression is
reprocessed, starting with the first rule.

$var<MAXAPPLYDEPTH[10000]> is the maximum depth to which APPLY1 and APPLY2 will delve.

.endfunction

.function (APPLYB1,|exp, rule1, ..., rulen|)
is similar to APPLY1 but works from the "bottom up" instead of from the "top
down".  That is, it processes the smallest subexpression of 2exp1, then the
next smallest, etc.

$var<MAXAPPLYHEIGHT[10000]> - is the maximum height to which APPLYB1 will reach before
giving up.

.endfunction

.subsec (Pattern Matching for Rational Expressions,patmatrat,1)

.function (LETSIMP,exp)
will continually apply the substitution rules previously defined by the
function LET (see below) until no further change is made to 2exp1.

.endfunction

.function (LET,|prod, repl, predname, arg1, arg2, ..., argn|)
defines a substitution rule for LETSIMP such that 2prod1 gets replaced by
2repl1.  2prod1 is a product of positive or negative powers of the following types of terms:


(1) 2Atoms1 which LETSIMP will search for literally unless previous to calling
LETSIMP the MATCHDECLARE function is used to associate a predicate with the atom.  In
this case LETSIMP will match the atom to any term of a product satisfying the
predicate.

(2) 2Kernels1 such as SIN(X), N!, F(X,Y),  etc.  As with atoms above LETSIMP will
look for a literal match unless MATCHDECLARE is used to associate a predicate with the
argument of the kernel.

A term to a positive power will only match a term having at least that power in
the expression being LETSIMPed.  A term to a negative power on the other hand will
only match a term with a power at least as negative.  In the case of negative powers
in "product" the switch LETRAT must be set to TRUE (see below).

If a predicate is included in the LET function followed by a list of arguments,
a tentative match (i.e. one that would be accepted if the predicate were
omitted) will be accepted only if 2predname1(2arg11',...,2argn1')
evaluates to TRUE where 2argi1' is the value matched to 2argi1.  The
2argi1 may be the name of any atom or the argument of any kernel appearing in
2prod1.  2repl1 may be any rational expression.  If any of the atoms or
arguments from 2prod1 appear in 2repl1 the appropriate substitutions will be
made.

$var<LETRAT[FALSE]> when FALSE, LETSIMP will simplify the numerator and
denominator of 2expr1 independently and return the result.  Substitutions such
as N!/N goes to (N-1)! will fail.  To handle such situations LETRAT should be
set to TRUE, then the numerator, denominator, and their quotient will be
simplified in that order.

These substitution functions allow you to work with several rulepackages at
once. Each rulepackage can contain any number of LETed rules and is refered to
by a user supplied name.  To insert a rule into the rulepackage 2name1,  do
LET([2prod,repl,pred,arg11,...],2name1).  To apply the rules in rulepackage
2name1, do LETSIMP(2expr1, 2name1).  The function
LETSIMP(2expr,name1,name21,...) is equivalent to doing LETSIMP(2expr,name11)
followed by LETSIMP(%,2name21) etc.

There is a default rulepackage name which is
assumed when no other name is supplied to any of the functions.  Whenever a LET
includes a rulepackage name the default rulepackage is made to look like that
rulepackage.
.endfunction
.function (REMLET,|prod, name|)
deletes the substitution rule, 2prod1 --> 2repl1, most recently defined by
the LET function.  If 2name1 is supplied the rule is deleted from the rule
package 2name1. REMLET() and REMLET(ALL,2name1) delete all substitution
rules from the default rulepackage. If 2name1 is supplied the rulepackage,
2name1, is also deleted.

If a substitution is to be changed using the same product, REMLET need not be
called, just redefine the substitution using the same product (literally) with the LET
function and the new replacement and/or predicate name.  Should REMLET(product) now be
called the original substitution rule will be revived.

.endfunction

.function(LETRULES,name)
and LETRULES() display the rules in the default rulepackage and the
rulepackage, 2name*, respectively.  Note that the function LETRULES(2name*)
will set the default rulepackage to the rulepackage, 2name*.

.example
(C1) MATCHDECLARE([A1,A2],TRUE)$

(C2) ONELESS(X,Y):=IS(EQUAL(X,Y-1))$

(C3) LET(A1*A2!,A1!,ONELESS,A2,A1);

(D3)         A1 A2! --> A1! WHERE ONELESS(A2, A1)

(C4) LETRAT:TRUE$

(C5) LET(A1!/A1,(A1-1)!);

.begin group
                        A1!
(D5)                    --- --> (A1 - 1)!
                        A1
.end

(C6) LETSIMP(N*M!*(N-1)!/M);

(D6)                      (M - 1)! N!

.end
.endfunction

.next page
.sec (Poisson Series Functions,poissfun,1)

A Poisson series is a finite sum where each term has the form p*trig(q) where
"trig" is either SIN or COS .  P is usually a polynomial with
rational number or floating point coefficients, or a general MACSYMA expression.  The
argument q is a linear combination of no more than 6 variables, whose names are
literally U, V, W, X, Y, and Z.  (These restrictions are not vital, but apparently
present no difficulty in usual applications.  They could be altered easily).

Conversion to a Poisson series expands all products or powers of sines and/or
cosines into sums. In order to display the result, it is usually necessary to convert
an expression in Poisson encoding into general MACSYMA representation using the
OUTOFPOIS function, or to print it using the PRINTPOIS function.

.function(POISSIMP,A)
converts A into a Poisson series for A in general representation.
.endfunction

.function(INTOPOIS,A)
converts A into a Poisson encoding.

.endfunction

.function(OUTOFPOIS,A)
converts A from Poisson encoding to general representation.  If A is not in
Poisson form, it will make the conversion, i.e. it will look like the result of
OUTOFPOIS(INTOPOIS(A)).  This function is thus a canonical simplifier for sums of
powers of SIN's and COS's of a particular type.

.endfunction

.function(PRINTPOIS,A)
prints a Poisson series in a readable format.  In common with OUTOFPOIS, it
will convert A into a Poisson encoding first, if necessary.

.endfunction

.function(POISTIMES,|A, B|)
is functionally identical to INTOPOIS(A*B).

.endfunction

.function(POISTRIM)
is a reserved function name which (if the user has defined it) gets
applied during Poisson multiplication.  It is a predicate function of 6 arguments
which are the coefficients of the U, V,..., Z in a term.  Terms for which POISTRIM is
TRUE (for the coefficients of that term) are eliminated during multiplication.

.endfunction

.function(POISPLUS,|A, B|)
is functionally identical to INTOPOIS(A+B).

.endfunction

.function(POISEXPT,|A, B|)
(B a positive integer) is functionally identical to INTOPOIS(A**B).

.endfunction

.function(POISDIFF,|A, B|)
differentiates A with respect to B.  B must occur only in the trig arguments
or only in the coefficients.

.endfunction

.function(POISINT,|A, B|)
integrates in a similarly restricted sense (to POISDIFF).  Non-periodic terms
in B are dropped if B is in the trig arguments.

.endfunction

.function(POISSUBST,|A, B, C|)
substitutes A for B in C.  C is a Poisson series.

(1) Where B is a variable U, V, W, X, Y, or Z then A must be an expression linear in
those variables (e.g. 6*U+4*V).

(2) Where B is other than those variables, then A must also be free of those
variables, and furthermore, free of sines or cosines.

.endfunction

.function(POISSUBST,|A, B, C, D, N|)
is a special type of substitution which operates on A and B as in
type (1) above, but where D is a Poisson series, expands COS(D) and SIN(D) to order N
so as to provide the result of substituting A+D for B in C.  The idea is that D is an
expansion in terms of a small parameter.  For example, POISSUBST(U,V,COS(V),E,3)
results in COS(U)*(1-E^2/2) - SIN(U)*(E-E^3/6).

.endfunction

.function(POISMAP,|series, sinfn, cosfn|)
will map the functions 2sinfn* on the sine terms and 2cosfn* on
the cosine terms of the poisson series given.  2sinfn* and 2cosfn* are functions of two
arguments which are a coefficient and a trigonometric part of a term in series
respectively.

.example
(C1) PFEFORMAT:TRUE$

(C2) (2*A^2-B)*COS(X+2*Y)-(A*B+5)*SIN(U-4*X);

.begin group
					
(D2)        - (A B + 5) SIN(U - 4 X) 

		      2
		+ (2 A  - B) COS(2 Y + X)
.end

(C3) POISEXPT(%,2)$

.begin group
(C4) PRINTPOIS(D3);

    2
(2 A  - B) ( - A B - 5) SIN( - 2 Y - 5 X + U)

    2
(2 A  - B) ( - A B - 5) SIN(2 Y - 3 X + U)

		  2
- 1/2 ( - A B - 5)  COS(2 U - 8 X)

	2     2                   2
1/2 (2 A  - B)  + 1/2 ( - A B - 5)

	2     2
1/2 (2 A  - B)  COS(4 Y + 2 X)
.end

(D4)                               DONE

(C5) POISINT(D3,Y)$

(C6) OUTOFPOIS(%);

.begin group
	     2     2 
(D6) 1/8 (2 A  - B)  

	                         2
	SIN(4 Y + 2 X) - 1/2 (2 A  - B) ( - A B - 5)

				     2
        COS(2 Y - 3 X + U) + 1/2 (2 A  - B) ( - A B - 5)

        COS( - 2 Y - 5 X + U)
.end

(C7) OUTOFPOIS(SIN(X)^5+COS(X)^5);

.begin group
(D7) 1/16 SIN(5 X) + 1/16 COS(5 X) - 5/16 SIN(3 X) 

	+ 5/16 COS(3 X) + 5/8 SIN(X) + 5/8 COS(X)
.end

.end

One or two final points:  the coefficients in the arguments of the trig
functions must fit in a pre-arranged domain.  Initially this is set to [-15,16] but
can be set to [-2^(n-1)+1, 2^(n-1)] by the command POISLIM(n).  This should not be
done in the middle of a calculation.  Also, it is possible to define the coefficient
arithmetic to be almost anything.  The user (probably in conjunction with a LISP-MACSYMA
programmer) must define the programs needed to add, multiply, substitute,
encode and decode the coefficients.  The encoding for +1 and -1 and a program to test
for 0 (zero), completes each package.  These packages are available for coefficients
being CRE form, polynomials with floating point coefficients, and polynomials with
rational number coefficients, in addition to the default general MACSYMA form.

If all coefficients of trig terms are desired in CRE form, the user should
LOADFILE(POIS3,FASL,DSK,MACSYM) and LOADFILE(RATPOI,FASL,DSK,MACSYM).  Only those
variables on the RATVARS list can be used in the coefficients.  In many instances this
is a much more efficient technique in terms of speed.

.endfunction

.next page
.sec(Tensor Manipulation,tensors)

MACSYMA implements symbolic tensor manipulation of two distinct types: 5explicit* tensor manipulation and 5indicial* tensor manipulation.  


5Explicit tensor manipulation* means that tensors are represented as arrays or matrices; tensor operations such as contraction or covariant differentiation are carried out by actually summing over repeated (dummy) indices---by explicitly performing operations on the appropriate tensor components stored in an array or matrix.

5Indicial tensor manipulation* is implemented by representing tensors simply as functions of their covariant and contravariant indices; tensor operations such as contraction or covariant differentiation are represented by manipulating the indices themselves rather than the components which they refer to.   

These two approaches to the question of treating differential, algebraic and analytic processes in the context of Riemannian geometry  have various advantages and disadvantages which reveal themselves only through the particular nature and difficulty of the user's problem.  However, one should keep in mind the following characteristics of the two implementations:

2Explicit Tensor Manipulation* (ETENSR FASL)

.begin narrow 4,5

i) The standard representation of tensors and tensor operations explicitly in terms of their components makes  ETENSR FASL easy to use:  specification of the metric and the computation of the induced tensors and invariants is straightforward.

ii) Although all of MACSYMA's powerful simplification capacity is at hand,  a complex metric with intricate functional and coordinate dependencies can easily lead to expressions whose size is excessive and whose structure is hidden.  

.end

2Indicial Tensor Manipulation* (ITENSR FASL)

.begin narrow 4,5

i) Because of the special way in which tensors and tensor operations are represented in terms of symbolic operations on their indices,  expressions which in the 2explicit* representation would be unmanageable  can be greatly simplified by contraction and reduction to a "canonical" form (for symmetric tensors).  In this way the structure of a large expression may be more transparent.

ii) On the other hand, because of the the special indicial representation in ITENSR FASL,  the user must be careful about the specification of the metric, function definition, and the evaluation of differentiated "indexed" objects. 

.end


These two tensor manipulation packages, ETENSR FASL and ITENSR FASL, are available to the MACSYMA user on the SHARE directory $see<share>.  To use the functions in these files, the user must load them in by doing

LOADFILE(ETENSR,FASL,DSK,SHARE); --- for explicit tensor manipulation.

LOADFILE(ITENSR,FASL,DSK,SHARE); --- for indicial tensor manipulation


Both of these packages enable the user to specify a metric and compute the basic quantities of interest
.skip 1
.begin nofill center
Christoffel symbols, Riemann curvature tensor,
curvature invariants
.end
.skip 1
.continue
in the study of Riemannian manifolds.   These routines were written primarily for research in gravitation theory; however, they may also be of some use in other areas of physics where Riemannian geometry is applied.


.subsec(Explicit Tensor Manipulation,explicit) 

After the user has done 
.skip 1
(C1) LOADFILE(ETENSR,FASL,DSK,SHARE)$
.skip 1
.continue
the function 

.function(SETUP,)
of no arguments presents several options which are self-explanatory.  First the user chooses the kind of metric to be used---whether it will be one of the standard metrics already stored in some file, or a power-series approximation, or some new metric to be specified (perhaps only a slight modification of a metric already defined). After the metric has been specified,  a number of simplification options are provided which govern the rational simplification and factoring of the tensor components to be computed.   The particular quantity to be computed can then be indicated; the user can say whether the results (some of which may be quite lengthy) are to be immediately displayed or not.

Here is a sample protocol:
.skip 1
.example
.begin verbatim

(C2) SETUP();
DO YOU WANT
1 - TO CONSIDER A METRIC IN THE SPECIAL METRIC FILE?
2 - TO APPROXIMATE A METRIC WITH A POWER SERIES?
3 - TO ENTER A NEW METRIC?
TYPE 1 OR 2 OR 3  
3;

SPECIFY THE COORDINATES AS A LIST OF FOUR ELEMENTS  
[R,THETA,PHI,T];
DO YOU WANT
1 - TO SPECIFY  A DIAGONAL METRIC?
2 - TO CHANGE A COMPONENT IN A PREVIOUSLY DEFINED
	METRIC?
3 - TO SPECIFY A GENERAL (SYMMETRIC) METRIC?
TYPE 1 2  OR  3  
1;

ENTER DIAGONAL MATRIX
[1, 1]  
-EXP(M);
[2, 2]  
-R^2;
[3, 3]  
-R^2*SIN(THETA)^2;
[4, 4]  
EXP(N);

INDICATE THE KIND OF SIMPLIFICATION YOU WANT

1 - RATIONAL SIMPLIFICATION ONLY
2 - FACTORING AND RATIONAL SIMPLIFICATION
3 - EXPANSION 
TYPE 1 2 OR 3  
2;

.end
.end
.endfunction
.skip 1
At this point the user has the option of computing various quantities which are described below.

.function(CHRISTOF,dis)
computes the Christoffel symbols of both kinds;  the argument,2dis*, determines which results are to be immediately displayed.  The Christoffel symbols of the first kind are stored in the array LCS[I,J,K].   If the argument to CHRISTOF were LCS,  all the non-zero values of LCS[I,J,K] would be displayed.


The Christoffel symbols of the second kind (Mixed Christoffel Symbols) are given by the array MCS[I,J,K]; in the example below, the argument MCS was given resulting in the immediate display of all the non-zero mixed Christoffel symbols.

.example
(C3) CHRISTOF(MCS);
.begin group
					  M
					   R
(E3) 			     MCS        = --
				1, 1, 1	  2
.end
.begin group
					   1
(E4) 			      MCS        = -
				 1, 2, 2   R
.end
.begin group
					   1
(E5) 			      MCS        = -
				 1, 3, 3   R
.end
.begin group
					  N
					   R
(E6) 			     MCS        = --
				1, 4, 4	  2
.end
.begin group
					   - M
(E7) 			  MCS	     = - %E    R
			     2, 2, 1
.end
.begin group
				      COS(THETA)
(E8) 			 MCS	    = ----------
			    2, 3, 3   SIN(THETA)
.end
.begin group
				     - M      2
(E9) 		    MCS	       = - %E    R SIN (THETA)
		       3, 3, 1
.end
.begin group
(E10) 		   MCS	      = - COS(THETA) SIN(THETA)
		      3, 3, 2
.end
.begin group
					 N - M
				       %E      N
						R
(E11) 			  MCS	     = ----------
			     4, 4, 1	   2

(D11) 				   DONE
.end
.end
.endfunction


.function(MOTION,dis)
gives the geodesic equations of motion corresponding to a given metric.  They are stored in the array EM[I].  If the argument 2dis* is TRUE then these equations are displayed.

.endfunction

.function(RICCICOM,dis)
This function first computes the contravariant components LR[I,J] of the Ricci tensor (LR is a mnemonic for "lower Ricci").  Then the mixed Ricci tensor is computed using the covariant metric tensor.  If the value of the argument to RICCICOM is TRUE, then these mixed components, RICCI[I,J]  (the index I is covariant (down) and the index J is contravariant (up) ),  will be displayed directly.  Otherwise,  RICCICOM(FALSE)  will simply compute the entries of the  array RICCI[I,J]  without presenting the results.

.example


(C13) RICCICOM(TRUE);
.begin group
		
	        
		
(E13) RICCI
	   1, 1	

	   - M		     2
	 %E    ((2 N    + (N )  - M  N ) R - 4 M )
		  R R	  R	 R  R	      R
       = -----------------------------------------
			  4 R
.end
.begin group
		       - M		      M
		     %E	   ((M  - N ) R + 2 %E  - 2)
			      R	   R
(E14)  RICCI     = - -------------------------------
	    2, 2		     2
				  2 R
.end
.begin group

		       - M		      M
		     %E	   ((M  - N ) R + 2 %E  - 2)
			      R	   R
(E15)  RICCI     = - -------------------------------
	    3, 3		     2
				  2 R
.end
.begin group
		
		
		
(E16)  RICCI    
	    4, 4

		 - M		    2
	       %E    ((2 N    + (N )  - M  N ) R + 4 N )
			  R R	  R	 R  R	      R
	     = -----------------------------------------
				  4 R

(D16) 				   DONE
.end
.end
.endfunction

.function(NTERMSRCI,) 
 returns a list of pairs, whose second elements give the number of terms in the RICCI component specified by the first elements.  In this way, it is possible to quickly find the non-zero expressions and attempt simplification.

.endfunction

.function(LRICCICOM,dis)
computes the covariant components LR[I,J] of the Ricci tensor.  If the argument 2dis* is TRUE, then the non-zero components are displayed.

.endfunction

.function(EINSTEIN,dis)
computes the Einstein tensor once the Christoffel symbols and Ricci tensor have been obtained.  Again, if the argument evaluates to TRUE, then the non-zero values of the Einstein tensor G[I,J] will be displayed. $var<RATEINSTEIN>:TRUE will perform rational simplification on these components; if $var<FACRAT>:TRUE then the components will also be factored.

.endfunction

.function(NTERMSG,)
gives the user a quick picture of the "size" of the Einstein tensor.  It returns  a list of pairs  whose second elements give the number of terms in the components specified by the first elements.  

.endfunction

Of course a detailed examination of the structure of the Einstein components can be made using the powerful simplification, factoring and extraction functions available in MACSYMA (see $ref<evsimpfun>,$ref<extracting!expressions>).


.function(SCURVATURE,)
returns the scalar curvature (obtained by contracting the Ricci tensor) of the Riemannian manifold with the given metric.

.endfunction

.function(RIEMANN,dis)
computes the Riemann curvature tensor from the given metric (the Christoffel symbols should be obtained first using CHRISTOF).  If 2dis* is TRUE, the non-zero components R[I,J,K,L] will be displayed. 2All the indicated indices are covariant.*  As with the Einstein tensor, various switches set by the user control the simplification of the Riemann components.  If $var<RATRIEMAN>:TRUE, then rational simplification will be done; if $var<FACRAT>:TRUE then each of the components will also be factored.

.example

.begin group
(C27) RIEMANN(TRUE);
					   M  R
					    R
(E27) 			   R	       = - ----
			    1, 2, 1, 2	    2
.end
.begin group
					     2
				     M  R SIN (THETA)
				      R
(E28) 		     R	         = - ----------------
		      1, 3, 1, 3	    2
.end
.begin group
			 N	    N	  2	   N
		   - 2 %E  N    - %E  (N )  + M  %E  N
			    R R	        R      R      R
(E29) R	         = ------------------------------------
       1, 4, 1, 4			   4
.end
.begin group
			 M	  - M  2    2
(E30) R 	  = - (%E  - 1) %E    R  SIN (THETA)
       2, 3, 2, 3
.end
.begin group
					 N - M
				       %E      N  R
						R
(E31) 		       R	   = - ------------
			2, 4, 2, 4	    2
.end
.begin group
			   N - M	 2
			 %E      N  R SIN (THETA)
				  R
(E32)	 R	     = - ------------------------
	  3, 4, 3, 4		    2

(D32) 				   DONE
.end
.end
.endfunction

.function(RAISERIEMANN,dis) 
returns the 2contravariant* components of the Riemann curvature tensor as  array elements  UR[I,J,K,L].  These are displayed if 2dis* is TRUE.

.endfunction

.function(RINVARIANT,)
forms the scalar invariant obtained by contracting  R[I,J,K,L]*UR[I,J,K,L].

.example


(C34) RINVARIANT();
.begin group
	-2M           2          2	               4
(D34) %E    ((4 (N   )  + (4 (N )  - 4 M  N ) N   + (N )
                  R R	       R        R  R   R R    R

	    3	    2	  2   4		 2	   2   2 
 - 2 M  (N )  + (M )  (N ) ) R  + (8 (N )  + 8 (M ) ) R  
      R	  R	  R     R	       R	 R

        2 M        M           4
 + 16 %E    - 32 %E  + 16)/(4 R )

.end
.end
.endfunction

.function(WEYL,dis)
computes the Weyl conformal tensor. If the argument 2dis*
is TRUE, the non-zero components W[I,J,K,L]  will be displayed to the user.  Otherwise, these components will simply be computed and stored.  If the switch $var<RATWEYL> is set to TRUE, then the components will be rationally simplified; if $var<FACRAT> is TRUE then the results will be factored as well. 

.endfunction

.function(DSCALAR,function)
applies the scalar d'Alembertian to the scalar 2function*.

.example

(C41) DEPENDENCIES(FIELD(R));
(D41) 			        [FIELD(R)]

(C42) DSCALAR(FIELD);
.begin group

(D43)
    -M
  %E  ((FIELD  N - FIELD  M + 2 FIELD   ) R + 4 FIELD )
	     R  R       R  R         R R             R
- -----------------------------------------------------
			     2 R
.end
.end
.endfunction


.next page
.subsec(Indicial Tensor Manipulation ,indicial,1)


In ITENSR FASL a tensor is represented as an "indexed object" .  This is a function of 3 groups of indices which represent the covariant, contravariant and derivative indices.   The covariant indices are specified by a list as the first argument to the indexed object;  the contravariant indices are specified by a list as the second argument.  If the indexed object lacks either of these groups of indices, then the empty list, [], is given as the corresponding argument.  For example,  
.once center
G([mu,nu],[])
.continue
represents an indexed object called  G  which has covariant indices  mu,nu  and no contravariant or derivative indices. 

The derivative indices, if they are present, follow as additional arguments to the (symbolic) function representing the tensor. They are usually not explicitly specified by the user but are created in the process of differentiation with respect to some coordinate variable.  A derivative index is not the coordinate variable itself, but rather the coordinate 2index*.   These indices are appended as additional arguments to the function representing the tensor.   Since it is assumed that ordinary differentiation is independent of the order in which it is carried out, the derivative indices are sorted alphabetically.  This canonical order makes it possible for MACSYMA to recognize that, for example, T([mu],[nu],i,j) is the same as T([mu],[nu],j,i).  Differentiation of an indexed object with respect to some coordinate whose index does not appear as an argument to the indexed object would normally yield zero since MACSYMA would not know that the tensor represented by the indexed object might depend implicitly on the corresponding coordinate.  This has been remedied by modifying the existing MACSYMA function DIFF so that in the tensor package it assumes that all indexed objects depend on any variable of differentiation unless otherwise stated.  This makes it possible for the summation convention to be extended to derivative indices.


To specify that an indexed object is independent of all coordinate variables, it is specified a constant by using the DECLARE function $see<property!specification>. Thus DIFF(W([],[I,J])x,K)  would ordinarily result in  W([],[I,J],K);  if the command DECLARE(W,CONSTANT) had previously been given, the result of the differentiation would be 0.


The following functions are available in the tensor package for manipulating indexed objects.  At present it is assumed that all tensor indices are completely symmetric.

In what follows, general indexed objects will be denoted 2tensor, tensor1,tensor2,...* . The letters  2L1,L2*,... denote lists which are arguments to indexed objects.  Optional arguments are enclosed in angle brackets.

.function(SHOW,|exp|)
 will display 2exp* with the indexed objects in it shown having covariant indices as subscripts,contravariant indices as superscripts. The derivative indices will be displayed as subscripts, separated from the covariant indices by a comma.

.endfunction

.function(LC,|L|)
 is the permutation (or Levi-Civita) tensor which yields 1 if the list 2L* consists of an even permutation of integers, -1 if it consists of an odd permutation, and 0 if some indices in 2L* are repeated.

.endfunction

.function(DELTA,|L1,L2|)
 is the generalized Kronecker delta function.
2L1* and 2L2* are lists of indices of the same length.
.skip 1
a) If 2L1* and 2L2* have a single member, say L1=[a] and L2=[b].  Then
.skip 1
.begin narrow 4,5  preface 0
1) if the index  a  is identical to the index b and they are non-numeric,  the value of the function DELTA is the value of the variable DIMENSION [default value: 4];

2) if a and b are numeric then the value of the function is 1 if they are equal, else 0;

3) otherwise the noun form of DELTA.

.end
.continue
b) If L1=[a1,a2] and L2=[b1,b2]. Then the value of the function is
.example
DELTA([a1],[b1])*DELTA([a2],[b2])
	- DELTA([a1],[b2])*DELTA([a2],[b1]) 

.end
.continue
c) If L1 and L2 have more than two indices the result generalizes.

.endfunction

.function(CHR1,|1[*i,j,k1]*|)
 yields the Christoffel symbol of the first kind
.skip 1

.begin turn on "{"
.once center
1/2({sb(g,|[ik,j]|)} + {sb(g,|[jk,i]|)} - {sb(g,|[ij,k]|)})
.end
.skip 1
.continue
The variable METRIC must be assigned the name of a function (which can be either defined or undefined); in the above example, METRIC:g.  

.endfunction

.function(CHR2,|1[*i,j1]*,1[*k1]*|)
 yields the Christoffel symbol of the second kind.
.skip 1
.begin turn on "{"
.once center
CHR2([i,j],[k]) = {sp(g,|[ks]|)} CHR1([i,j,s])
.end
.endfunction

.function(RIEMANN,|1[*i,j,k1]*,1[*l1]*|) 
 yields the Riemann curvature tensor in terms of the Christoffel symbols of the second kind (CHR2).  Suppose the function name specified by the value of METRIC corresponds to a function which has been given some structure via a function definition; in order to evaluate the Riemann tensor incorporating this given structure of the metric,  first apply UNDIFF to obtain an equivalent expression, say 2exp*;  then use EV(exp,chr2,diff).
.skip 1
Consider the following example involving a metric, G, expressed in terms of the rank two tensors, P and E;  the covariant and contravariant forms of the metric are specified within the same function G  representing the metric.

.example
.begin group
(C8) G(L1,L2):=
BLOCK([A,B],IF L2=[] 
THEN [A:L1[1],B:L1[2],RETURN(E(L1,[])*(1+2*L*P([],[]))-
4*L*P(L1,[])
)],
A:L2[1],B:L2[2],E([],L2)*(1-2*L*P([],[]))+4*L*P([],L2)
)$
.end
.end

Note that a BLOCK is necessary in this definition since the arguments on the left are lists yet the metric structure is given in terms of the members of those lists.  
.continue
Now the contraction properties of the metric G are declared (see DEFCON):

.example
(C10) METRIC:G$

(C11) DEFCON(G)$
.end
.continue
The tensor E is declared constant and its contraction properties are described:
.example
(C14) DECLARE(E,CONSTANT)$

(C15) DEFCON(E)$

(C16) DEFCON(E,E,DELTA)$
.end
.scon
The Ricci tensor is easily expressed in terms of the Riemann tensor, using the Einstein summation convention:
.example

(C17) RICCI:RIEMANN([I,J,K],[J])$

(C18) SHOW(%);
.begin group
      J		  J	   !1	     J	
- CHR2	    - CHR2     CHR2    + CHR2	   
      I K,J	  !1 J	   I K	     I J,K

	      J        !1
	+ CHR2     CHR2
	      !1 K     I J
.end
(D18) 				   DONE

.end
To prepare for the evaluation of the Christoffel symbols  in terms of the metric structure, the function UNDIFF is applied:
.example
(C19) RICCI:UNDIFF(RICCI)$
.end
.skip 1
.continue
Now evaluation and differentiation proceeds, using the structure given to the metric above.
.example
(C20) RICCI:EV(RICCI,CHR2,DIFF)$
.end
.skip 1
Finally, the result is expanded, truncated (with respect to the parameter L), and contracted:
.example

(C23) RATWEIGHT(L,1)$

(C24) RATWTLVL:1$

(C25) TAKEGCD:FALSE$

(C27) RICCI:RATEXPAND(D20)$

(C28) CONTRACT(%)$

(C29) SHOW(%);
.begin group
   !1		 !1 !2			      
2 P	  L - 2 E      P	  L + P	      
   K,!1 I	        I K,!1 !2      ,!1 !2

 !1 !2	          !1
E     E    L + 2 P	 L
       I K        I,!1 K
.end
.end

.endfunction

.function(CONTRACT,|exp|)
 carries out all possible contractions in 2exp*, which may be any well-formed combination of sums and products.  This function uses the information given to the DEFCON function.  Since all tensors are considered to be symmetric in all indices, the indices are sorted into alphabetical order.  Also all dummy indices are renamed using the symbols !1,!2,...  to permit the expression to be simplified as much as possible by reducing equivalent terms to a canonical form.   For best results 2exp* should be fully expanded.  

RATEXPAND ($see<evsimpfun>) is the fastest way to expand products and powers of sums if there are no variables in the denominators of the terms.  The TAKEGCD switch should be FALSE if gcd cancellations are unnecessary.  

.endfunction

.function(DEFCON,|tensor1,<tensor2,tensor3>|) 
 gives 2tensor1* the property that the contraction of a product of 2tensor1* and 2tensor2*  results in 2tensor3*
with the appropriate indices.  If only one argument, 2tensor1*, is given, then the contraction of the product of 2tensor11 with any indexed object having the appropriate indices (say 2tensor*) will yield an indexed object with that name,i.e.2tensor*, and with a new set of indices reflecting the contractions performed.
.skip 1
.begin preface 0
For example, if METRIC: G, then DEFCON(G) 
will implement the raising and lowering of indices  through contraction with the metric tensor.

More than one DEFCON can be given for the same indexed object;  the latest one given which applies in a particular contraction will be used.

CONTRACTIONS is a list of those indexed objects which have been given contraction properties with DEFCON.
.end
.endfunction

.function(DISPCON,|tensor1,tensor2,...|)
 displays the contraction properties of the 2tensori* as were given to DEFCON.  DISPCON(ALL) displays all the contraction properties which were defined.

.endfunction

.function(REMCON,|tensor1,tensor2,...|)
 removes all the contraction properties from the 2tensori*. 
REMCON(ALL) removes all contraction properties from all indexed objects.

.endfunction

.function(DUMMY,|i1,i2,...|)
 will set each index i1,i2,... to  name of the form !n  where n is a positive integer.  This guarantees that dummy indices which are needed in forming expressions will not conflict with indices already in use.

$var<COUNTER[default 1]> determines the numerical suffix to be used in generating the next dummy index.  The prefix is determined by the option $var<DUMMYX[!]>.

.endfunction

.function(DIFF,|exp,v1,n1,v2,n2,...|) 
 is the usual MACSYMA differentiation function; it takes the derivative of 2exp* wrt 2v1 n1* times, wrt 2v2 n2* times, etc.  For the tensor package, the following modifications have been incorporated:

1) the derivatives of any indexed objects in 2exp* will have the variables 2vi* appended as additional arguments.  Then all the derivative indices will be sorted.

2) the 2vi* may be integers from 1 up to the value of the variable DIMENSION[default value: 4].  This will cause the differentiation to be carried out wrt the  2vi*th member of the list COORDINATES which should be set to a list of the names of the coordinates, e.g., [x,y,z,t]  .  If  COORDINATES is bound to an atomic variable, then that variable subscripted by 2vi* will be used for the variable of differentiation.  This permits an array of coordinate names or subscripted names like  X[1], X[2],...  to be used.  If COORDINATES has not been assigned a value, then the variables will be treated as in 1) above.

.endfunction

.function(COVDIFF,|exp,v1,v2,...|)
 yields the covariant derivative of 2exp* with respect to the variables 2vi* in terms of the Christoffel symbols of the second kind (CHR2).  In order to evaluate these, one should use EV(exp,CHR2).

.endfunction

.function(UNDIFF,|exp|)
 returns an expression equivalent to 2exp* but with all derivatives of indexed objects replaced by the noun form of the DIFF function with arguments which would yield that indexed object if the differentiation were carried out.  This is useful when it is desired to replace a differentiated indexed object with some function definition and then carry out the differentiation by saying  EV(...,DIFF).

.endfunction

.function(LORENTZ,|exp|)
 yields 2exp* with indexed objects have a derivative index identical to a contravariant index replaced by zero, implementing the Lorentz condition.

.endfunction

.function(INDICES,|exp|)
 returns a list of two elements.  The first is a list of the free indices in 2exp* (those that occur only once); the second is the list of dummy indices in 2exp* (those that occur exactly twice).

.endfunction

.function(RENAME,|exp|)
 returns an expression equivalent to 2exp* but with the dummy indices in each term chosen from the set [!1,!2,...].  Each dummy index in a product will be different; for a sum RENAME will try to make each dummy index in a sum the same.  In addition, the indices will be sorted alphanumerically.

.endfunction

.function(MAKEBOX,|exp|)
 will display 2exp* in the same manner as SHOW; however, any tensor d'Alembertian occurring in 2exp* will be indicated using the symbol [].  For example, []P([M],[N]) represents G([],[I,J])*P([M],[N],I,J).

.endfunction

.function(CAN,|exp|)
 reduces 2exp* to canonical form and simplifies the expression as much as possible by renaming and permuting dummy indices. 
The expression 2exp* must be fully expanded.

As an example of the kind of simplification this function achieves, consider the following sum of tensor "monomials":

.example

(C4) P([I,J,S,V],[M,N,Q],V)*P1([Q,T],[R,S])

	*P2([R,L,M,N,U],[I,J,K])  + 

	P2([L,N,U],[R,M,I,J,K])

	*P([M,I,J,V],[N,Q,S],V)*P1([R,S,Q,T],[])$

(C6) SHOW(D4);
.skip 1
.begin group
  R M I J K  N Q S		    M N Q
P2	    P	       P1        + P 
  L N U	     M I J V,V	 R S Q T    I J S V,V

	  R S   I J K
	P1    P2
	  Q T   R L M N U
.skip 1
.end
(D6) 				   DONE
.end
.scon
(Recall that the tensors are assumed completely symmetric)
.scon
The function RENAME renames the dummy indices:
.example
(C7) SHOW(RENAME(D4));
.begin group

 !6 !7 !8	  !2 !3 K	 !4 !5
P	        P2	       P1
 !1 !2 !3 !5,!1	  !4 !6 !7 L U	 !8 T

	  !3 !4 !8		        !2 !5 !6 !7 K
       + P	         P1	      P2
	  !1 !5 !6 !7,!1   !2 !3 !4 T   !8 L U

(D7) 				   DONE
.end
.end
.skip 2
.continue
but is not able to notice that by a sequence of raising and lowering operations, the original expression can be transformed into

.example
(C8) SHOW(CAN(D4));
.begin group
		     I J K M N	 Q R S
2 P		   P2	       P1
   I J M N Q S V,V   L R U	 T

.end
.skip 1
(D8) 				   DONE
.end

.endfunction
.skip 1
.once center
2EXAMPLE*

.example


(C2) BATCH(ITENSR,DEMO,DSK,SHARE);

(C3) /* DEMONSTRATION OF MACSYMAS INDICIAL MANIPULATION
 OF  SYMMETRIC TENSORS.  WE WILL SHOW THAT THE COVARIANT
 DERIVATIVE OF THE COVARIANT FORM OF THE METRIC TENSOR
 IS ZERO */

/* LOAD IN INDICIAL TENSOR MANIPULATION PACKAGE */

LOADFILE(ITENSR,FASL,DSK,SHARE)$

ITENSOR FASL DSK SHARE BEING LOADED 
SYMMETRIC TENSOR PACKAGE - VERSION 130
LOADING DONE

(C4) /* STATE THAT G IS THE METRIC AND THAT IT CONTRACTS
WITH ITSELF TO FORM THE KRONECKER DELTA */

DEFCON(G)$

(C5) DEFCON(G,G,DELTA)$

(C6) METRIC:G$

(C7) /* SHOW THE TIMES OF THE COMPUTATIONS */

TIME:TRUE$
TIME= 4 MSEC.

(C8) /* OBTAIN COVARIANT DERIVATIVE OF METRIC
	AND DISPLAY IT */

E:COVDIFF(G([I,J]),K)$

CONCAT FASL DSK MAXOUT BEING LOADED 
LOADING DONE
TIME= 9 MSEC.

(C9) SHOW(%)$
.begin group

		      !3	      !3
G      + (- G	  CHR2	  - G	  CHR2	 )
 I J,K	     I !3     J K    !3 J     I K

.end

TIME= 242 MSEC.

(C10) /* REPLACE CHRISTOFFEL SYMBOLS OF SECOND
	        KIND BY THEIR VALUE */

E:EV(E,CHR2)$
TIME= 328 MSEC.

(C11) SHOW(%)$
.begin group
   !3 !2
  G      G     (G       - G	  + G	   )
	  I !3	 K !2,J	   J K,!2    J !2,K
- ------------------------------------------
		      2

   !3 !1
  G      G     (G       - G	  + G	   )
	  !3 J	 K !1,I	   I K,!1    I !1,K
- ------------------------------------------ + G
		      2			        I J,K
TIME= 618 MSEC.
.end
(C12) /* EXPAND OUT COMPLETELY */

E:EXPAND(E)$
TIME= 375 MSEC.

(C13) SHOW(%)$
.begin group

   !3 !2		  !3 !1			
  G      G     G	 G      G     G
	  I !3  K !2,J		 !3 J  K !1,I
- -------------------- - -------------------- 
	   2			  2

    !3 !2		    !3 !2	
   G     G      G	   G	  G      G	 
    I !3  J K,!2	    I !3   J !2,K
+ -----------------	 - ----------------
	 2			  2

      !3 !1
     G     G      G
      !3 J  I K,!1
 + -------------------- + G
	   2		   I J,K

    !3 !1
   G	  G     G
	   !3 J	 I !1,K
 - --------------------
	    2
TIME= 946 MSEC.
.end
(C14) /* CONTRACT INDICES MAKING USE OF ALL RULES
	     AND THE RESULT IS 0  */

CONTRACT(E);
TIME= 338 MSEC.
(D14) 				     0

TIME= 7044 MSEC.

.end
.sec(The SHARE Directory,share,1)

.skip 1

     The SHARE directory contains programs, information files, etc. 
which are considered to be of interest to the MACSYMA community.  
Files on SHARE; are not part of the MACSYMA system per se and must be 
loaded individually by the user, e.g. LOADFILE(ODER,LISP,DSK,SHARE);. 
Many files on SHARE; were contributed by MACSYMA users, and all 
MACSYMA users are encouraged to do so.

     Names for files on SHARE; should be chosen as appropriate.  
However, the contributor will probably want to follow the conventions 
discussed here.  A contributor will probably create some but not all 
of the following files.  Examples may be seen on the SHARE directory.

  
   1)  NAME > is the file name of the MACSYMA BATCHable programs.  
The > sign indicates a numeric second filename which is increased 
whenever a new version is created.  

   2)  NAME LISP is the file name of the LISP code for the programs 
contained in the file NAME >.  This file is loaded into MACSYMA using 
LOADFILE.  It was obtained by using the TRANSLATE command or was 
written directly in LISP by the contributor. 

   3)  NAME FASL is the file name of the FASL (fast-loadable) version 
of NAME LISP, and was produced from NAME LISP by using the LISP 
compiler.  It is loaded into MACSYMA using the LOADFILE command.

   4)  NAME USAGE is the name of the documentation file for the 
programs in NAME >.  It describes how the programs are used, inputs, 
outputs, options, warnings, error messages, etc.  It may mention the 
algorithms behind the programs, references, and whatever else the 
user should know.  It should certainly indicate who programmed the 
routines, especially his login name.  If the NAME USAGE file does 
not exist, this information should be given in NAME > or elsewhere.

   5)  NAME DEMO is the name of the demonstration file which may be 
used in DEMOing NAME > or NAME LISP.

   6)  NAME OUTPUT may be used to store sample output obtained from 
running NAME > on some examples or from DEMOing the NAME DEMO file.

   7)  Other file names may be used for information files providing 
some information on some aspect of the MACSYMA system or for 
describing some MACSYMA utility or for notes on some MACSYMA issues, 
etc.

     The SHARE > file is an index to the SHARE directory and is 
intended to contain a short note on each of the programs on the SHARE 
directory.  It should be updated by the SHARE; contributor as 
appropriate.

     Any comments or questions about the use of the SHARE directory 
should be sent to JPG.
