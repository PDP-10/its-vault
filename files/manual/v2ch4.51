.chap(The SHARE Directory,share)

     The SHARE, SHARE1, and SHARE2 directories contain programs, 
information files, etc. which are considered to be of interest to the 
MACSYMA community.  (The SHARE1; and SHARE2; directories are overflow 
directories for the SHARE; directory which in general hold less frequently 
used files.  From now on, references to the SHARE; directory should be 
taken to mean all of the SHARE;, SHARE1;, and SHARE2; directories.)
Some files on SHARE; are not part of the MACSYMA system per se and must 
be loaded individually by the user, e.g. LOADFILE(CGAMMA,FASL,SHARE);.
However, using the $fun<LOAD> command it is not necessary to worry about
either which of the SHARE directories a file is on, or which kind of
file it is, e.g. LOAD(CGAMMA); will find and load up the file CGAMMA FASL.

     Many files on SHARE; were contributed by MACSYMA users, and all MACSYMA 
users are encouraged to contribute.

     Names for files on SHARE; should be chosen as appropriate.  
However, the contributor will probably want to follow the conventions 
discussed here.  A contributor will probably create some but not all 
of the following files.  Examples may be seen on the SHARE directory.
  
   1)  NAME > is the file name of the MACSYMA BATCHable programs.  
The > sign indicates a numeric second filename which is increased 
whenever a new version is created.  

   2) NAME LISP is the file name of the LISP code for the programs
contained in the file NAME >.  This file is loaded into MACSYMA using
LOADFILE.  It was obtained by using the TRANSLATE command, the SAVE
command, or was written directly in LISP by the contributor.

   3) NAME FASL is the file name of the FASL (fast-loadable) version
of NAME LISP, and was produced from NAME LISP by using the LISP
compiler, or produced using the FASSAVE command.  It is loaded into
MACSYMA using the LOADFILE command.

   4)  NAME USAGE is the name of the documentation file for the 
programs in NAME >.  It describes how the programs are used, inputs, 
outputs, options, warnings, error messages, etc.  It may mention the 
algorithms behind the programs, references, and whatever else the 
user should know.  It should certainly indicate who programmed the 
routines, especially his login name.  If the NAME USAGE file does 
not exist, this information should be given in NAME > or elsewhere.

   5)  NAME DEMO is the name of the demonstration file which may be 
used in DEMOing NAME > or NAME LISP.

   6)  NAME OUTPUT may be used to store sample output obtained from 
running NAME > on some examples or from DEMOing the NAME DEMO file.

   7)  Other file names may be used for information files providing 
some information on some aspect of the MACSYMA system or for 
describing some MACSYMA utility or for notes on some MACSYMA issues, 
etc.

     The SHARE > file is an index to the SHARE directory and is 
intended to contain a short note on each of the programs on the SHARE 
directory.  It should be updated by the SHARE; contributor as 
appropriate.

     Any comments or questions about the use of the SHARE directory 
should be sent to JPG.

.sec(|Contents of the Directory|,cotd)

This is the contents of the file SHARE;SHARE 51, which represents the
SHARE directories as of mid-July 1981.  This is a complete listing, and
thus contains some packages which are actually part of MACSYMA.  Those
will have a reference to the appropriate section of the manual.  The
packages which are on the SHARE directories will be treated, each in a separate
section, in the rest of this chapter.

.begin indent 0,10;turn on ""
ABSIMP(11)(SHARE1;) supplements the built-in simplification rules for
ABS and SIGNUM.

ANTID(11)(SHARE2;) Integrates (antidifferentiates) expressions involving 
an unspecified function and its derivatives.

APLOT2(11)belongs to PLOT2

AIRY(11)(SHARE1;) Contains the AIRY functions and their derivatives, both
numerically and a bit symbolically; has the GRADEFS that TAYLOR uses.

ARRAY(11)various functions for handling arrays (e.g. changing array	
dimensions, filling arrays from a list).

ASYMP(11)(SHARE1;) does asymptotic analysis, including big-Oh and little-oh
simplification.

BESSEL(11)obtains Bessel functions J and I for real arg and integer 
order.  Bessel function J for complex arg and nonneg real order.
Airy function Ai of real arg.  Plasma Dispersion function (Complex
Error function), and a generator of random numbers with a normal 
distribution.

BINIO(11) (SHARE2;) belongs to PLOT2

BRMBRG(11)(SHARE2;) BIGFLOAT version of ROMBRG numerical integration

CGAMMA(11)Gamma function for complex arguments.

CTENSR(11)for a user-specified metric, enables explicit computation
of Christoffel symbols, Ricci tensor, Riemann tensor, and other tensor
quantities of interest in differential geometry and gravitation
theory.  $see<tensors>.

DECLIN(11)(SHARE1;) Functions for declaring linear operators with several 
arguments.

DELTA(11)(SHARE2;) integrals with Dirac deltas

DESOLN(11)solves differential equations or systems of them using 
Laplace transforms.  Part of MACSYMA, see $see<difintfun>.

DETERM(11)(SHARE1;) the Bareiss two-step determinant algorithm.

DIFSOL(11)(SHARE2;) solves differential equations or systems of them using
Laplace transforms.

DIMEN(11)(SHARE1;) dimensional analysis.

DISOL(11)(SHARE2;) does ISOLATE's job for multiple variables.

DSKUSE(11)(SHARE2;) Functions for finding out about disk usage on this machine.

DUMP(11)saves and loads number arrays efficiently

DUMPAR(11)NEWIO version of DUMP/LOADARRAYS compatible with OLDIO format
Soon to be installed as standard version, in which case replace
DUMPAR FASL by a link to COMMON; (CFFK(11)16 July 1977)

EIGEN(11)computes right eigenvectors, right unit eigenvectors, 
eigenvalues, and similarity transforms.

ELIM(11)(SHARE1;) eliminates variables from equations by taking resultants.

ELLIPT(11)Some complete elliptic integrals and Jacobian elliptic functions.

FACEXP(11)(SHARE1;) Several functions for controlled expansion of rational
expressions.

FACT(11)Taylor series of the gamma function.

FFT(11)routines form Fast Fourier Transform and inverse FFTs

FIDO(11)(SHARE2;) a program named FIDO that acts like DDT's fido program 
without wasting a whole job slot in a crowded system.

FOPTIM(11)(SHARE2;) a program which accepts function-names as arguments, 
and calls OPTIMIZE on their definitions. Subject to same restrictions 
as OPTIMIZE but saves some of the clumsiness of accessing and 
restoring definition.


FORMAT(11)for pretty printing floating point numbers according to a specified
precision, total width, or fractional width.

FORMA1(11)same as above, but still nicer to the eye.

FORTRA(11)produces FORTRAN-compatible code from MACSYMA using TECO.

FOURIE(11)(SHARE1;) calculate Fourier series and Fourier integral
coefficients.  Also, there are various utility functions to do such
things as replace all occurrences of F(arg) by arg in an expression.

FUNCTS(11)assorted useful functions.  Their names are CONJUGATE,
REMPART, WRONSKIAN, ADJOINT, TRACEMATRIX, RATIONAL, ODD, UPROBE, 
KRONECKER, NONZEROANDFREEOF, LINEAR, and QUADRATIC.

GAMALG(11)Part of a package for Feynman diagram calculations in high-energy
physics. Takes traces (in n dimensions), squares amplitudes,
manipulates untraced strings of gamma matrices, and much more.
(Manual is in GAM USAGE)

GAMMA(11)(SHARE2;) computes a truncated asymptotic expansion for the gamma 
function.

GRIND(11)a TECO program which "grinds" (formats) BATCH files.

IFFUN(11)belongs to PLOT2

INTPOL(11)roots of transcendental equations by interpolation.

INTSCE(11)(SHARE1;) smartly integrates expressions of the form 
EXP(a*X+b)*COS(c*X)^n*SIN(c*X)^m .

INVERT(11)(SHARE1;) finds the inverse of a matrix using the adjoint method.
In MACSYMA, see $see<matrix!functions>.

ITENSR(11)MACSYMA's indicial tensor manipulation package. Unlike
ETENSR, which carries out tensor operations explicitly,
this package works on the tensor indices and is truly
symbolic.  $see<tensors>.

Linde1(11)(SHARE2;) solves first order linear ordinary differential equations 

LEXPR(11)implementation of functions of unknown knumbers of actual
parameters, by the use of a new ":==" function defining operation.
subject to an initial condition.

LRATS (11)two functions related to RATSUBST: one is a recursive form of
RATSUBST, and the other is an enhancement of RATSUBST which
allows multiple serial substitution in the manner of SUBST.

MMACRO(11)an implementation of user definable macsyma macros. which is
something equivalent to making the evaluator user extendable.

NUMRCL(11)(NUMER;) Various numerical hacks including Gaussian quadratures,
simpson's rule, bessel functions, mappings over declared arrays,
smoothings and quadratures of functions defined by arrays.
coded by GJC. See the NUMER directory for other stuff.

ODE(11)solves ordinary differential equations of 1st, 2nd and a few higher
orders by a very large number of methods (including ODE2).

ODE2(11)solves ordinary differential equations of 1st and 2nd order.

OPTIMU(11)(NUMER;) Functions for generating programming constructs from
macsyma mathematical expressions. Automatic optimizing, MODE
declaration, and function defining. -GJC.

OPTMIZ(11)(SHARE2;) does analytic optimization.  Finds the stationary
points of a multivariate objective function.

OPTVAR(11)(SHARE2;) does variational optimization: the calculus of
variations, the maximum principle, and optimal control.

PFAFF(11)(SHARE2;) contains a function which evaluates Pfaffians.

PINVRS(11)(SHARE2;) computes matrix inverse by partitioning.

PLOT2(11)plotting for Tektronix 4013, Imlacs the XGP and the Gould 
lineprinter capabilities include all those provided by the
MACSYMA plotting package and much more.

PLOT3D(11)belongs to PLOT2

PRINT(11)belongs to PLOT2				

QUAL(11)does qualitative analysis, determining bounds, monotonicity,
convexity, structure, periods, symmetries, poles, zeros, stationary
points, and asymptotics of general expressions.

RECUR(11)recurrence relation program.  Written by John Ivie of UCB

REVERT(expr,var)(11)(SHARE2;) for reversion of series.  Programmed by Wilson.

RGKUTT(11)(SHARE2;) 4th order runge-kutta for solving 1st order
    differential eqns.  Written by Y L Chu.

RUNGE(11)(NUMER;) runge-kutta, uses fast macsyma declared arrays 
   and translated functions, self documenting, coded in lisp by GJC.

OROMBR(11)(SHARE2;) does Romberg numerical integration.

ROMBRG(11)an alternate version of ROMBER.

SERIES(11)solution of second (and some first) order differential equations
by substitution of infinite series(method of Frobenius). Attempts
to find a complete solution in closed form.

SETS(11)provides a fast SETS package.

SPECFN(11)definite integration of special functions (Bessel, Whittaker,
Legendre,Orthogonal Polys, Incomplete Gamma, etc.) by conversion to
hypergeometric functions. Currently handles only Laplace type
integrals; i.e., INTEGRAL(F(Z)*EXP(-P*Z),Z,0,inf).

TEKPLT(11)belongs to PLOT2

TRGSMP(11)an alternative trigonometric-hyperbolic simplifier.

UNITS(11)does automatic conversion of units to metric, and provides
a check on the dimensional homogeniety of expressions.

VECT(11)vector algebra and calculus, including simplification,
expansion into curvilinear coordinates, scalar potentials, and
vector potentials.

VECTOR(11)various vector operations are included, e.g. DIV, GRAD,
DOTDEL, CROSS, LAPLACIAN, and CURL.

WORLD(11)belongs to PLOT2
.end
.sec(|Simplification for ABS and SIGNUM|,absign)

The file SHARE1;ABSIMP > contains MACSYMA pattern-matching rules that
extend the built-in simplification rules for the $fun<ABS> and $fun<SIGNUM>
functions.  Among other things, use is made of global relations
established with the built-in $fun<ASSUME> function or by declarations such
as $fun<DECLARE>(M,EVEN, N,ODD)  for even or odd integers.  $fun<UNITRAMP>
and $fun<UNITSTEP> functions are also defined in terms of ABS and SIGNUM.
These routines were written by David Stoutemyer (STOUTE@MIT-MC).

.sec(Antidifferention,santid)

	The file antid > contains a routine for evaluating integrals of
expressions involving an arbitrary unspecified function and its derivatives.
after load'ing the file, the function antidiff is defined:

.function(ANTIDIFF,|g,x,u(x)|)
.endfunction
Where g is the expression involving u(x) (u(x) arbitrary) and its
derivatives, whose integral with respect to x is desired.

	The file also defines the functions $fun<NONZEROANDFREEOF> and
$fun<LINEAR> as well as $fun<ANTID>.  ANTID is the same as ANTIDIFF
except that it returns a list of two parts, the first part is the
integrated part of the expression and the second part of the list is
the non-integrable remainder.

.sec(Airy Functions,airyf)

The $fun<AIRY> equation diff(y(x),x,2)-x*y(x)=0 has two linearly independent
solutions, taken to be ai(x) and bi(x). This equation is very popular
as an approximation to more complicated problems in many mathematical
physics settings.

Do LOAD("AIRY");  to get the functions $fun<AI>(x), $fun<BI>(x), $fun<DAI>(x), $fun<DBI>(x) .

The file SHARE1;AIRY FASL (by LPH@MIT-MC) contains routines to compute the 
Ai(x), Bi(x), d(Ai(x))/dx, and d(Bi(x))/dx functions. The result will be
a floating point number if the argument is a number, and will return a
simplified form otherwise. An error will occur if the argument is large
enough to cause an overflow in the exponentials, or a loss of 
accuracy in sin or cos. This makes the range of validity
about -2800 to 1.e38 for AI and DAI, and -2800 to 25 for BI and DBI.
The GRADEF rules are now known to MACSYMA: diff(AI(x),x)=DAI(x),
diff(DAI(x),x)=x*AI(x), diff(BI(x),x)=DBI(x), diff(DBI(x),x)=x*BI(x).

The method is to use the convergent Taylor series for abs(x)<3., and
to use the asymptotic expansions for x<-3. or x>3. as needed.  This
results in only very minor numerical discrepancies at x=3. or x=-3.
More accuracy can be had if you request help from LPH. For details,
please see Abramowitz and Stegun's Handbook of Mathematical Functions,
section 10.4 (hardcover ed.) and Table 10.11 .

To get the floating point Taylor expansions of the functions here, do 
ev($fun<TAYLOR>(AI(x),x,0,9),infeval); for example.

Please also check $see<spec!fun> for the AIRY function there.

Leo P. Harten (LPH)

.sec(Asymptotic Analysis,asympanal)

MACSYMA batch file SHARE1;ASYMP > contains simplification functions
for asymptotic analysis, including the big-O and little-o functions that
are widely used in complexity analysis and numerical analysis.  First,
to establish the asymptotic values of any independent variables that are
not to be regarded as constants, issue the appropriate set of commands of
the form

.function(PUT,|indeterminant, limitvalue, 'LIMIT|)
For complexity analysis, 2limitvalue1 is usually 'INF, and for
numerical analysis, 2limitvalue1 is usually 0.  However, any
symbolic or numeric value can be used.
.endfunction

Thereafter:

.function(ASYMP,expression1)
returns ASYMP(2expression21), where 2expression21 is the simplest
expression that ASYMP could determine that is asymptotically equal to
2expression11:
.example
        limit (expression2/expression1)  =  1.
          indeterminates->limitvalues
.end
.endfunction

.function(THETA,expression1)
returns THETA(2expression21), where 2expression21 is the simplest
expression that THETA could determine that is of the exact same order
as expression1.
.endfunction

.function(O,expression1)
returns O(2expression21), where 2expression21 is the simplest
expression that O could determine that is big-O of every expression
that expression1 is big-O of.
.endfunction

.function(LO,expression1)
returns LO(expression2), where expression2 is the simplest expression
that LO could determine that is little-o of every expression
that expression1 is little-o of.
.endfunction

.function(OMEGA,expression1)
returns OMEGA(expression2), where expression2 is the simplest expression
that OMEGA could determine that is of least the same order as expression1.
OMEGA specifies a lower bound on the order, analagous to  how O
specifies an upper bound.
.endfunction

.function(LOMEGA,expression1)
returns LOMEGA(expression2), where expression2 is the simplest expression
that LOMEGA could determine that is of lesser order than every expression
that expression1 is of lesser order than.  LOMEGA specifies a strict
lower bound on the order, analagous to how LO specifies
an upper bound on the order.
.endfunction

When expression3 contains one or more subexpressions containing the
results of the above functions, 

.function(ASYMPSIMP,expression3)
may return a simplified form of expression3.  For example, after
typing PUT(N, 'INF, 'LIMIT),  ASYMPSIMP(N**3 + 5*THETA(N)*ASYMP(
%E*N*LOG(N)) + THETA(LOG(LOG(N))))   yields  N**3 + THETA(N**2*LOG(N)).
.endfunction

Input expressions can contain the functional form named LOG2, the
logarithm to the base 2, which will be converted to LOG appropriately.

When set to TRUE (default is FALSE), BASECONVERT causes exponentials
to be converted to the base %e, which may permit greater simplification.x

When set to TRUE, (default is FALSE), ASYMPTAYLOR causes use of
taylor series before trying other techniques, which may lead to a
simpler answer or may lead to an error interrupt which
produces baffling messages and may be beyond the control of ERRCATCH.
The effectiveness and interrupt-proneness of the taylor technique is also
dependent upon upon the setting of TAYLORMAX, the maximum number of iterations,
which has a default setting of 1.  

Rather than discard information and accuracy unnecessarily, it is 
recommended that the user first try ASYMP.  If the constants in the
result are incomprehensibly complicated, then try THETA.  If the result
still contains too may terms, then try O and OMEGA to
geta bound pair.

.sec(Gamma Functions for Complex Arguements,gffca)

The Gamma function in the complex plane.

Functions CGAMMA, CGAMMA2, and LOGCGAMMA2.

These functions evaluate the Gamma function over the complex plane
using the algorithm of Kuki, CACM algorithm 421.  Calculations are
performed in single precision and the relative error is typically
around 1.0E-7; evaluation at one point costs less than 1 msec.
The algorithm provides for an error estimate, but the Macsyma
implementation currently does not use it.

Load the functions with:
.example
LOAD(CGAMMA); .
.end
.function(CGAMMA,arg)
is the general function and may be called with a symbolic
or numeric argument.  With symbolic arguments, it returns as is;
with real floating or rational arguments, it uses the Macsyma Gamma
function; and for complex numeric arguments, it uses the Kuki
algorithm.
.endfunction

.function(CGAMMA2,|real,imag|)
of two arguments, 2real1 and 2imaginary1, is for numeric arguments
only.
.endfunction

$fun<LOGCGAMMA2> is the same as CGAMMA, but the log-gamma function is
calculated.  These two functions are somewhat more efficient.

Examples:

CGAMMA(1) -> 1

CGAMMA(4) -> 6

CGAMMA(3/2) -> SQRT(%PI)/2

CGAMMA(X) -> CGAMMA(x)

CGAMMA(1+%i) -> 0.49801569-%i*.154949838  (error 2.5E-8)

.sec(Gamma Matrix Algebra Program,GAMALG)

The GAMALG package is a package for Feynman diagram calculations
in high energy physics.  See also $see<physics>.

Capabilities:
.begin indent 0,5;turn on ""
1.(6)Takes traces of products of Dirac gamma matrices in n dimensions.
In 4 dimensions, it also takes traces of products involving 
gamma[5] (G5).  The results may have free indices.

2.(6)Squares sums of amplitudes, involving polarized or unpolarized spinors.

3.(6)Contracts free indices.

4.(6)Simplifies products of gamma matrices in n dimensions.
.end continue
For all manipulations, GAMALG uses the conventions of Bjorken and Drell
and takes Tr(1)=4 (generalization of the spinor dimensionality is 
unnecessary).

Further information, especially on the algorithms used by GAMALG, may
be found in 'MACSYMA Tools for Feynman Diagram Calculations', by Stephen 
Wolfram, in Proceeding of the 1979 Users' Conf. and Caltech preprint 
CALT-68-720 (June 1979). These references give some discussion of other
programs available for high energy physics calculations (including
Feynman parametrization etc.).

Numbers in brackets refer to sections of the file SHARE;GAM USAGE, which
is the complete manual for this package.

Summary of Functions:

.function(BTR,list)
takes the trace of the gamma matrices represented by its argument
in a way that is more efficient than TR for long traces invloving many sums 
of momenta [1].
.endfunction

.function(CIND,|mu1,...,muk|)
adds mu1 through muk to the list of contracted indices [1].
.endfunction

.function(CGT,exp)
converts G's to TR's and does them [3].
.endfunction

.function(COMPDEF,|vec1=list1,vec2=list2,ind1=val1,ind2=val2,vec3=...|)
defines lists as the components of vectors and values for indices, for
use by NONCOV
.endfunction

.function(CON,exp)
contracts all free indices in exp (including epsilon symbols) [3].
.endfunction

.function(CONJ,amp)
returns the conjugate of the amplitude amp [2].
.endfunction

.function(COTR,exp)
reduces (in n=4) products of traces with contracted indices to 
single traces [3].
.endfunction

.function(CRUNCH,exp)
simplifies untraced products of gamma matrices in exp [3].
.endfunction

.function(DFIX,exp)
expands all dot products in exp [3].
.endfunction

.function(EPSFIX,exp)
expands all epsilon symbols in exp [3].
.endfunction

.function(FLAGS,)
displays the values of flags and information lists.
.endfunction

.function(GFIX,exp)
expands sums of vectors appearing in untraced products of
gamma matrices in exp [3].
.endfunction

.function(GLUE3,|l1,l2,l3|)
gives the tensor corresponding to the three-gluon vertex represented
by its arguments [3].
.endfunction

.function(KINDEF,|dotp1=rep1, dotp2=rep2, ...|)
defines kinematics substitutions dotp1=rep1,... [3].
.endfunction

.function(NONCOV,exp)
substitues the non-covariant components specified by COMPDEF
for vectors and indices in dot products in exp [3]
.endfunction

.function(NSET,dim)
sets the dimensionality of spacetime to dim [1].
.endfunction

.function(SCALS,|x1,..,xk|)
adds x1 through xk to the list of scalars [1].
.endfunction

.function(SQ,|spn1,amp,spn2|)
squares the amplitude amp sandwiched between the spinors
spn1 and spn2 [2].
.endfunction

.function(SQAM,|spn1,amp1,spn2,amp2|)
sums over spins the amplitude squared 
amp1*conj(amp2) sandwiched between the spinors spn1 and spn2 [2].
.endfunction

.function(TR,|a1,a2,...|)
takes the trace of gamma matrices represented by its 
argument [1].
.endfunction

.function(UNCIND,|mu1,...,muk|)
removes mu1 through muk from the list of
contracted indices [1].
.endfunction

.function(UNCOMPDEF,|vec1,ind1,vec2,vec3,...|)
removes the components defined for
its arguments [3].
.endfunction

.function(UNKINDEF,|dotp1,...,dotpk|)
removes simplifications defined for dot
products dotp1 through dotpk [3].
.endfunction

.function(UNSCALS,|x1,...,xk|)
removes x1 through xk from the list of scalars [2].
.endfunction

Pseudofunctions:

$fun<D>(p,q)   dot product of p and q

D(p,mu)   mu component of the vector p

D(mu,nu)   mu, nu component of metric tensor

$fun<EPS>(p,q,r,s)   totally antisymmetric product of p,q,r and s

$fun<G>(a1,...,ak)   product of gamma matrices represented by a1,...,ak
(list brackets around sets of arguments optional)

$fun<UV>(p,m)   a fermion spinor with momentum p and mass m

$fun<UVS>(p,m,s)   a polarized fermion spinor with spin s

$fun<ZN>(p,m)   the numerator of a massive fermion propagator (p(slash)+m)

$fun<ZD>(p,m) or ZA(p,m)   the full propagator for a massive fermion 
((p(slash)+m)/(d(p,p)-m*m)). [If ZERM:TRUE then m=0 will be assumed, and 
ZD(p) or ZA(p) may be used.]

$fun<ZDEN>(p,m)  the denominator of a massive propagator (d(p,p)-m^2) suitable
for VIPER generated when VIRED:TRUE.

Flags (Switches)

$var<BORED/FALSE> if TRUE generates interest (TR0 entries and exits).

$var<COF/FALSE> if TRUE alphabetizes CRUNCH outputs by anticommutation.   

$var<DEF/TRUE> if FALSE will prevent the expansion of dot products as they are 
generated

$var<DOF/TRUE> if FALSE will prevent alphabetization of dot products as they
are generated

$var<DSIM/TRUE> if FALSE prevents dot product simplifications defined by KINDEF
from being applied.

$var<EPSOF/TRUE> if FALSE will prevent alphabetization of epsilon symbols
(antisymmetric products) as they are generated.

$var<EPSEF/TRUE> if FALSE will prevent expansion of epsilon symbols as 
they are generated.

$var<KAHAF/FALSE> if TRUE will cause the Kahane algorithm to be used on
traces with many contracted indices in n=4.
 
$var<MTRICK/TRUE> if TRUE invokes a more efficient algorithm for treating 
traces with large numbers of massive spinor propagators in 4 dimensions.

$var<NOP/FALSE> if TRUE causes SQ to generate no primed indices 
(does Feynman gauge polarization sums).


$var<NTR/FALSE> if TRUE causes SQ to generate G's rather than TR's

$var<PLATU/FALSE> if TRUE uses the inefficient methods of templates for large 
traces

$var<VIRED/FALSE> if TRUE generates VIPER-compatible output.

$var<ZERM/FALSE> if TRUE assumes all particle masses to be zero.

$var<BORELEN/>   determines the amount of interest generated when BORED:TRUE

$var<METSIG/> is the signature of the metric used by NONCOV  (default [+,-,-,-])


Information lists (initially empty)

.begin indent 0,10;turn on ""
COMPS(11)is the list of components defined by COMPDEF

IND(11)is the list of contracted indices (which will be uncontracted if 
unpaired)

KINS(11)is the list of kinematic substitutions defined by KINDEF

NPIND(11)is the list of indices automatically summed over by SQ (or SQAM)

SCALARS(11)is the list of scalars
.end

Loading GAMALG

      To load GAMALG into a MACSYMA, do 
.example
LOAD(GAMALG);
.end
      Some examples of the use of GAMALG may be executed by doing
.example
BATCH (GAM,DEMO,SHARE);
.end

The complete documentation should be perused in the file SHARE;GAM USAGE.

.sec(Functions for Declaring Linear Operators with Several Arguments,declino)

	The functions LINSIMP and DECLARE_LINEAR_OPERATOR provide the
user with the capability of simplifying expressions that contain
operators that are linear in one or more arguments.  It is possible to
accomplish something quite similar using the standard MACSYMA function
DECLARE ($see<declar>), but there is no simple way to extend this to
operators that have more than one argument.  The example below
illustrates the capabilities that are built into MACSYMA:
.example
(C1) DECLARE(F,LINEAR);
(D1) 				     DONE

(C2) F(2*A);
(D2) 				    2 F(A)

(C3) F(2);
(D3) 				    2 F(1)

(C4) F(A*B);
(D4) 				    F(A B)

(C5) DECLARE(B,CONSTANT);
(D5) 				     DONE

(C6) F(A*B);
(D6) 				    B F(A)
.end

Notice that constant factors are extracted from the argument of F.  This
will often be what is needed, but not always.  Operators that have more
than one argument are treated differently.  A complete description is given
in MACDOC;UPDATE >, in a note describing new features of MACSYMA #261.

	LINSIMP and DECLARE_LINEAR_OPERATOR fill these minor gaps in
MACSYMA's understanding of linear operators.  DECLARE_LINEAR_OPERATOR is
used to set up the information necessary for appropriate simplifications
to be carried out, and LINSIMP is used to execute those simplifications.
The desired simplification rules are not applied automatically, which is
a disadvantage of this method relative to MACSYMA's built in capability.

.function(LINSIMP,|exp, operator1, operator2, ...|)
simplifies exp with respect to
the linearity properties of operator1, then operator2, and so on.
Any terms belonging to the same sum that can be combined together
under the same operator are combined, and any factors that can be
extracted from any of these operators are extracted.  If any of the
operators in the argument list of LINSIMP have not been declared
linear using the function DECLARE_LINEAR_OPERATOR, an error will result.
.endfunction

.function(DECLARE_LINEAR_OPERATOR,|operator, linear-arguments, separation-predicate|)
sets up the linearity property of "operator", which must be an atomic
symbol.  The second argument of DECLARE_LINEAR_OPERATOR,
linear-arguments, is a list of one or more elements the entries of
which denote the specific arguments of "operator" that participate in
the linearity property.  "operator" is considered to be a linear
function of these specific arguments, taken together.  For example,
let F be linear in its first three arguments.  Then:
.example
F(2*A, 2*B, 2*C, D, E)  =  2*F(A, B, C, D, E)
.end
The third argument of DECLARE_LINEAR_OPERATOR is the separation predicate.
It must be a function of one argument which returns TRUE if its argument
is not meant to be extracted from "operator", and FALSE if its argument
is meant to be extracted.  Thus, for example, the built in separation
predicate used by MACSYMA for this purpose could be defined as
.example
NOT_CONSTANTP(EXP):=NOT CONSTANTP(EXP)$
.end
With such a definition, the declaration necessary to mimic MACSYMA's
built-in capability would be, for the function H of one argument,
.example
DECLARE_LINEAR_OPERATOR(H, [1], NOT_CONSTANTP)$
.end
Subsequent use of LINSIMP would then produce forms similar to those
produced by MACSYMA if H had been DECLAREd LINEAR.
.endfunction
.sec(Functions for Integrals with Direc Deltas,FFIWDD)

The function DELINT does integrals
which contain Dirac delta functions.

$fun<DELINT>(2expr,var1) and
$fun<DELINT>(2expr,var,lower_limit,upper_limit1).  These give the
indefinite and definite integrals respectively.  The delta function is
represented by $fun<DELTA>(2argument1); the step function (which is
returned by the indefinite integral) by $fun<THETA>(2argument1).  These
functions are not defined in the file.

	Currently lower_limit must be lower than upper_limit. This will be
corrected in a later version.  Currently derivatives of delta's
are not handled.  This may be put in later.  Error checking is currently
mimnimal.

	If there is no DELTA function in 2expr1 whose argument depends on
2var1, DELINT calls INTEGRATE.
.example
LOAD(DELTA);
.end

.sec(Characteristic Polynomial Computation,nchrpl,1)

NCHRPL FASL contains a function, NCHARPOLY, which is an alternative to
the built in MACSYMA CHARPOLY command $see<matrix!functions>.

NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric functions of
the roots can be calculated, which are nothing more than the coefficients of
the characteristic polynomial.  CHARPOLY works by forming the determinant of
VAR * IDENT [N] - A.  Thus NCHARPOLY wins, for example, in the case of large
dense matrices filled with integers, since it avoids polynomial arithmetic
altogether.  This command was written by DRB.

.function(NCHARPOLY,|M,var|)
computes the characteristic polynomial of the
matrix 2M1 with respect to 2var1.
.endfunction

.function(MATTRACE,M)
computes the trace [sum of the elements on the main diagonal] of
the square matrix 2M1.
.endfunction

.sec(Isolating Variables,disolv)
.function(DISOLATE,|exp, var1, var2, ..., varN|)
is similar to ISOLATE(exp, var) $see<extracting!expressions>
except that it enables the user to 
isolate more than one variable simultaneously.  This might be useful,
for example, if one were attempting to change variables in a multiple 
integration, and that variable change involved two or more of the 
integration variables.  To access this function, do 
LOADFILE(DISOL,FASL,SHARE2)$ .  A demo is available in SHARE2;DISOL DEMO.
.endfunction

.sec(Exterior Calculus of Differential Forms,cartan)

     The exterior calculus of differential forms is a basic tool of differential geometry developed by Elie Cartan and has important applications in the theory of partial differential equations.   The present implementation is due to 
F.B. Estabrook and H.D. Wahlquist.  The program is self-explanatory and can be accessed by doing

                   BATCH([CARTAN,START,DSK,SHARE],ON)
.scon
which will give a description with examples.  

.next page
The next six sections describe programs written by David Stoutemyer.

.sec(Vector Analysis,vecan)

The file VECT > contains a vector analysis package,  VECT DEMO contains a corresponding demonstration, and  VECT ORTH contains definitions of various orthogonal curvilinear coordinate systems.

The vector analysis package can combine and simplify symbolic 
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under
user control, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.
There is also a capability for deriving the scalar or vector potential
of a field.

To establish 2indeterminate1, indeterminate2, ...1 as vector entities,
type
.example
        DECLARE([2indeterminate1, indeterminate2, ...1], NONSCALAR) $
.end
.scon
Vectors can also be represented as lists of components.

"." is the dot-product operator, "~" is the cross-product operator,
$fun<GRAD> is the gradient operator, $fun<DIV> is the divergence operator, $fun<CURL> is the curl or rotation operator, and $fun<LAPLACIAN> is DIV GRAD.

Most non-controversial simplifications are automatic.  For additional
simplification, there is a function which can be used in the form

.inline function(VECTORSIMP,vectorexpression)
.scon
This function employs additional non-controversial simplifications,
together with various optional expansions according to the settings
of the following global flags:
.scon
EXPANDALL, EXPANDDOT, EXPANDDOTPLUS
.scon
EXPANDCROSS, EXPANDCROSSPLUS, EXPANDCROSSCROSS
.scon
EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD
.scon
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD
.scon
EXPANDCURL, EXPANDCURLPLUS, EXPANDCURLCURL
.scon
EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS, EXPANDLAPLACIANPROD
.scon
All these flags have default value FALSE. The PLUS suffix refers to employing additivity or distributivity.
The PROD suffix refers to the expansion for an operand that is any
kind of product.  EXPANDCROSSCROSS refers to replacing p~(q~r)
with (p.r)*q-(p.q)*r,  and EXPANDCURLCURL refers to replacing
CURL CURL p with  GRAD DIV p + DIV GRAD p.  EXPANDCROSS:TRUE has the 
same effect as EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other
flags, EXPANDPLUS and EXPANDPROD, have the same effect as setting all
similarly suffixed flags true.  When TRUE, another flag named
EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
composition DIV GRAD.  All of these flags are initially FALSE.
For convenience, all of these flags have been declared EVFLAG.

For orthogonal curvilinear coordinates, the global variables
COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set by the function invocation

.inline function(SCALEFACTORS,coordinatetransform) 
.scon
Here 2coordinatetransform1 evaluates to the form
[[expression1, expression2, ...], indeterminate1, indeterminat2, ...],
where indeterminate1, indeterminate2, etc. are the curvilinear
coordinate variables and where a set of rectangular Cartesian
components is given in terms of
the curvilinear coordinates by [expression1, expression2, ...].  COORDINATES
is set to the vector [indeterminate1, indeterminate2, ...], and
DIMENSION is set to the length of this vector.  SF[1], SF[2], ...,
SF[DIMENSION] are set to the coordinate scale factors, and SFPROD is
set to the product of these scale factors.  Initially, COORDINATES is
[X, Y, Z], DIMENSION is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1,
corresponding to 3-dimensional rectangular Cartesian coordinates.

To expand an expression into physical components in the current
coordinate system, there is a function with usage of the form

.inline function(EXPRESS,expression)
.scon
The result uses the noun form of any derivatives arising from
expansion of the vector differential operators.
To force evaluation of these derivatives,
the built-in EV function can be used together with the DIFF evflag,
after using the built-in DEPENDS function to establish any new
implicit dependencies.

The scalar potential of a given gradient vector, in the current
coordinate system, is returned as the result of

.inline function(POTENTIAL,givengradient)
.scon
The calculation makes use of the global variable POTENTIALZEROLOC[0],
which must be NONLIST or of the form [indeterminatej=expressionj,
indeterminatek=expressionk, ...], the former being equivalent to
the nonlist expression
for all right-hand sides in the latter.  The indicated right-hand
sides are used as the lower limit of integration.  The success of
the integrations may depend upon their values and order.
POTENTIALZEROLOC is initially set to 0.

The vector potential of a given curl vector, in the current
coordinate system, is returned as the result of

.inline function(VECTORPOTENTIAL,givencurl)
.scon
POTENTIALZEROLOC has a similar role as for POTENTIAL, but the order
of the left-hand sides of the equations must be a cyclic permutation
of the coordinate variables.

EXPRESS, POTENTIAL, and VECTORPOTENTIAL can have a second argument
like the argument of SCALEFACTORS, causing a corresponding
invocation of SCALEFACTORS before the other computations.


.sec(Dimensional Analysis,dimanal)

The file DIMEN > contains functions for automatic dimensional analysis,
and file DIMEN DEMO contains a demonstration.  Usage is of the form

.inline function(NONDIMENSIONALIZE,|list of physical quantities|)

The returned value is a sufficient list of nondimensional products of
powers of the physical quantities.  A physical relation between only
the given physical quantities must be expressible as a relation between
the nondimensional quantities.  There are usually fewer nondimensional
than physical quantities, which reduces the number of experiments or
numerical computations necessary to establish the physical relation to
a specified resolution, in comparison with the number if all but one
dependent physical variable were independently varied.  Also, the 
absence of any given physical quantity in the output reveals that
either the quantity is irrelevant or others are necessary to describe
the relation.


The program already knows an extensive number of relations between
physical quantities, such as  VELOCITY=LENGTH/TIME.  The user may over-ride or supplement the prespecified relations by typing

.inline function(DIMENSION,|equation or list of equations|)
.scon
where each equation is of the form  indeterminate=expression, where
expression is a product or quotient of powers of none or more of the
indeterminates   CHARGE, TEMPERATURE, LENGTH, TIME, or MASS.  To see
if a relation is already established type

.once center
GET(indeterminate, 'DIMENSION);

The result of NONDIMENSIONALIZE usually depends upon the value of the
global variable %PURE, which is set to a list of none or more of the
indeterminates  ELECTRICPERMITTIVITYOFAVACUUM, BOLTZMANNSCONSTANT,
SPEEDOFLIGHT, PLANCKSCONSTANT, GRAVITYCONSTANT, corresponding to the
relation between charge and force, temperature and energy, length and
time, length and momentum, and the inverse-square law of gravitation
respectively.  Each included relation is used to eliminate one of
CHARGE, TEMPERATURE, LENGTH, TIME, or MASS from the dimensional basis.
To avoid omission of a possibly relevant nondimensional grouping,
either include the relevant constant in %PURE or in the argument
of NONDIMENSIONALIZE if the corresponding physical effect is thought to
be relevant to the problem.  However, the inclusion of unnecessary
constants, especially the latter three, tends to produce irrelevant or
misleading dimensionless groupings, defeating the purpose of
dimensional analysis.  As an extreme example, if all five constants are
included in %PURE, all physical quantities are already dimensionless.
%PURE is initially set to '[ELECTRICPERMITTIVITYOFVACUUM,
BOLTZMANNSCONSTANT], which is best for most engineering work.
%PURE must not include any of the other 3 constants without also
including these 2.

.sec(Analytic Optimization,Anopt,1)


We now describe  a  package for finding the stationary points of a multivariate objective function, either unconstrained or subject
to equality and/or inequality constraints.
.scon
RELEVANT FILES: OPTMIZ >  is a MACSYMA batch file containing the functions and option settings for optimization.  OPTMIZ DEMO  is a MACSYMA batch file demonstrating various ways of using the optimization functions. OPTMIZ OUTPUT  is a text file listing  OPTMIZ DEMO together with the output that it produces when executed.

To use this package from a MACSYMA, first type  BATCH(OPTMIZ, ">", DSK, SHARE)
Then the following command is available:

.inline function(STAP,|OBJECTIVE, LEZEROS, EQZEROS, DECISIONVARS|);

OBJECTIVE is an expression denoting the objective function or the
   label of such an expression.
LEZEROS is a list of expressions which are constrained to be less
   than or equal to zero.  Use [] if no such constraints.
EQZEROS is a list of expressions which are constrained to equal zero, or
   the label of such a list.  Use [] if there are no such constraints.
DECISIONVARS is a list of the decision variables or the label of
   such a list.  One may use [] if all variables in objective and
   constraintsare decision variables. For convenience, brackets may be omitted from one-expression lists, and  trailing [] arguments may be omitted.

ROOTSEPSILON may affect the accuracy of results computed by  SOLVE
   and REALROOTS  within STAP.  The default value of 1.0E-7 for this
   MACSYMA global variable is as small as practical for pdp single-
   precision floating-point arithmetic.  Larger values save cpu time.

The class of functions that may be used and the practical limitations
on the number of decision variables and constraints is primarily 
dependent upon the capabilities of the built-in SOLVE function, 
which is still under development.

.sec(Variational Optimization,optvar,1)

This section describes how to use a MACSYMA variational optimization
package to analytically solve problems from the calculus of variations
and the maximum principle, including optimal control.

To use this package in a MACSYMA, first type  BATCH(OPTVAR,">", DSK, SHARE)
 or LOADFILE(OPTVAR, LISP, DSK, SHARE). 

To derive the Euler-Lagrange equations for a calculus-of-variations
problem, type

.inline function(EL,|F, YLIST, TLIST|);
.scon
F  is an expression or the label of an expression for the integrand
   of the stationary functional, augmented by Lagrange multipliers
   times the integrands of any isoperimetric constraints and/or
   differential expressions constrained to equal zero.  The multipliers
   should be written as functions of the independent variables in the
   latter case.
.scon
YLIST  is a list of the dependent variables, or the label thereof.
.bcon
TLIST  is a list of the independent variables, or the label thereof.
.scon
For convenience, square brackets may be omitted from 1-element lists.
EL displays one or more E-labeled equations, then returns a list
of the E-labels.  These equations are the Euler-Lagrange equations,
perhaps together with first integrals corresponding to conservation
of energy and/or conservation of momentum.  The former will contain a
constant of integration K[0], whereas the latter will contain constants
of integration K[I], with positive I.  The latter will immediately
follow the corresponding Euler-Lagrange equation.

OPTVAR DEMO or OPTVAR OUTPUT illustrates some ways that the
resulting differential equations may be solved analytically.

To derive the Hamiltonian and auxiliary differential equations for
an optimal control problem, type

.inline function(HAM,ODES)
.scon
ODES  is a list of the first-order differential equations that govern the state variables.  Each differential equation must be of the form
.example
                'D(Y,T) = EXPRESSION
.end
.scon
where  Y  is one of the dependent variables,  T is the independent
variable, and EXPRESSION  depends upon the independent, dependent, and
control variables.

HAM displays two or more E-labeled expressions, then returns a list
of the E-labels.  The first expression is the Hamiltonian, and the
other expressiona are the auxiliary diferential equations,
together with their general solutions,  AUX[I] = K[I], whenever the
Ith differential equation is of the trivial form  'D(AUX[I],T) = 0.
The K[I] are undetermined constants of integration.

HAM is directly suitable for the autonomous time-optimal problem.
Other problems may be converted to this form by introducing extra state
variables, as described in most optimal-control texts or in the report
referenced in  OPTVAR OUTPUT  and OPTVAR DEMO.

.sec(Qualitative Analysis,qual,1)

QUAL > contains MACSYMA functions for qualitative analysis
of an expression, QUAL DEMO contains a demonstration, and 
QUAL OUT contains the output from executing the demo.

To use the functions do  ALLOC(2); LOADFILE(STOUTE,">",DSK,MRG); BATCH(QUAL, ">", DSK, SHARE);

Top-level usage is of the form
.inline function(QUAL,|<expression>, <variables>|)
.scon
where <expression> is any given expression, <variables> is a given indeterminate or list of indeterminates.  If omitted, this argument defaults to all of the indeterminates in the first argument.

QUAL returns a list of E-labels of displayed equations, each of the
form 
.example
        <property name> = <property value>
.end
.scon
where  <property name> is one of the second-level function names below, and <property value> is the value returned by that function.  These second-level functions may also be used directly.  Usage is of the form
.example
            REVELATION(<expression>, <minimum>, <maximum>);
            BOUNDS(<expression>);
            SLOPES(<expression>, <variables>);
            CURVATURE(<expression>, <variables>);
            SYMMETRY(<expression>, <variables>);
            PERIODS(<expression>, <variables>);
            ZEROSANDPOLES(<expression>, <variables>);
            STATIONARYPOINTS(<expression>, <variables>);
            LIMITS(<expression>, <variables>);
.end
.scon
where <expression>, <variables>, and their defaults are as for QUAL.


.sec(Units Conversion,units,1)
The file UNITS > contains assignments for automatic conversion to MKS
metric units.  Usage example:  5*FT + METER + CM; simplifies to
2.534*METER .

Erroneously dimensionally inhomogeneous expressions are revealed by
uncollected terms.  For example, 5*FT + SECOND;  does not simplify to one term.

The supplied conversions comprise a rather complete set, but it should
be clear how to supplement them or produce an analagous set for
conversion to other units.

.sec(The Eigen Package,eigen,1)

The file SHARE;EIGEN FASL contains functions
 to compute right eigenvectors, right unit  eigenvectors, eigenvalues, and similarity transforms.
It also is 
able to handle multiple eigenvalues and the eigenvectors corresponding
to those eigenvalues.  It will work with any square matrix (not necessarily
symmetric or hermitian) and will tell whether the matrix is diagonalizable.
The calculated eigenvectors and the unit eigenvectors of the matrix are the
RIGHT eigenvectors and the RIGHT unit eigenvectors respectively.
It was written by Yekta Gursel, and bugs found should be sent to YEKTA@MC.
(You should be aware of the fact that this program uses the MACSYMA functions
SOLVE and ALGSYS and if SOLVE can not find the roots of the characteristic
polynomial of the matrix or if it generates a rather messy solution the
EIGEN package may not produce any useful results.  More info on this will be 
given in the description of the commands.)  LOAD(EIGEN); will allow you to
use this package.

Description of the functions:

.function(CONJUGATE,X)
returns the complex conjugate of its argument.
(Note that %I's in the expressions should be explicit, since there is
no complex variable declaration in MACSYMA at the present time.  This
is true for all the functions in this package.)
.endfunction

.function(INNERPRODUCT,|X,Y|)
takes two LISTS of equal length as its arguments and
returns their inner (scalar) product defined by
(Complex Conjugate of X).Y (The "dot" operation is the same
as the usual one defined for vectors).
.endfunction

.function(UNITVECTOR,X)
takes a LIST as its argument and returns a  unit list.
(i.e. a list with unit magnitude).
.endfunction

.function(COLUMNVECTOR,X)
takes a LIST as its argument and returns a column vector the
components of which are the elements of the list.  The first element is
the first component,...etc...(This is useful if you want to use parts 
of the outputs of the functions in this package in matrix calculations.)
.endfunction

.function(GRAMSCHMIDT,X)
takes a LIST of lists the sublists of which are of
equal length and not necessarily orthogonal (with respect to the
innerproduct defined above) as its argument and returns a similar
list each sublist of which is orthogonal to  all others.
(Returned results may contain integers that are factored.
This is due to the fact that the MACSYMA function FACTOR is 
used to simplify each substage of the Gram-Schmidt algorithm.
This prevents the expressions from getting very messy and
helps to reduce the sizes of the numbers that are produced
along the way.)
.endfunction

.function(EIGENVALUES,MAT)
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the list of eigenvalues of
the matrix and the other sublist of which is the list of the
multiplicities of the eigenvalues in the corresponding order.
The MACSYMA function SOLVE is used here to find the roots of
the characteristic polynomial of the matrix.  Sometimes SOLVE
may not be able to find the roots of the polynomial;in that
case nothing in this package except CONJUGATE, INNERPRODUCT,
UNITVECTOR, COLUMNVECTOR and GRAMSCHMIDT will work unless
you know the eigenvalues.
In some cases SOLVE may generate very messy eigenvalues.  You may
want to simplify the answers yourself before you go on.  There
are provisions for this and they will be explained below.
(This usually happens when SOLVE returns a not-so-obviously
real expression for an eigenvalue which is supposed to be real.)
.endfunction

.function(EIGENVECTORS,MAT)
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the output of the EIGENVALUES 
command and the other sublists of which are the eigenvectors
of the matrix corresponding to those eigenvalues respectively.
The flags that affect this function are :

$var<NONDIAGONALIZABLE/FALSE> will be set to TRUE or FALSE depending 
on whether the matrix is nondiagonalizable or diagonalizable after
an EIGENVECTORS command is executed.

$var<HERMITIANMATRIX/FALSE> If set to TRUE will cause the degenerate
eigenvectors of the hermitian matrix to be orthogonalized using
the Gram-Schmidt algorithm.

$var<KNOWNEIGVALS/FALSE> If set to TRUE the EIGEN package will assume
the eigenvalues of the matrix are known to the user and stored
under the global name LISTEIGVALS.  LISTEIGVALS should be set to
a list similar to the output of the EIGENVALUES command.
(The MACSYMA function ALGSYS is used here to solve for the 
eigenvectors. Sometimes if the eigenvalues are messy, ALGSYS may
not be able to produce a solution.  In that case you are advised
to try to simplify the eigenvalues by first finding them using
EIGENVALUES command and then using whatever marvelous tricks you
might have to reduce them to something simpler.  You can then use 
the KNOWNEIGVALS flag to proceed further.)
.endfunction


.function(UNITEIGENVECTORS,MAT)
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the output of the EIGENVALUES
command and the other sublists of which are the unit eigenvectors
of the matrix corresponding to those eigenvalues respectively.
The flags mentioned in the description of the EIGENVECTORS command
have the same effects in this one as well.  In addition there is one
more flag which may be useful :

$var<KNOWNEIGVECTS/FALSE> If set to TRUE the EIGEN package will assume that
the eigenvectors of the matrix are known to the user and are stored
under the global name $flag<LISTEIGVECTS>.  LISTEIGVECTS should be set to
a list similar to the output of the EIGENVECTORS command.
(If KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is
given the setting of the flag NONDIAGONALIZABLE may not be correct.
If that is the case please set it to the correct value.  The author
assumes that the user knows what he is doing and will not try to 
diagonalize a matrix the eigenvectors of which do not span the
vector space of the appropriate dimension...)
.endfunction

.function(SIMILARITYTRANSFORM,MAT)
takes a MATRIX as its argument and returns a list
which is the output of the UNITEIGENVECTORS command.  In addition if
the flag NONDIAGONALIZABLE is FALSE two global matrices LEFTMATRIX
and RIGHTMATRIX will be generated.  These matrices have the  property
that LEFTMATRIX.MAT.RIGHTMATRIX is a  diagonal matrix with the
eigenvalues of MAT on the diagonal.  If NONDIAGONALIZABLE
is TRUE these two matrices will not be generated.
If the flag HERMITIANMATRIX is TRUE then LEFTMATRIX is the
complex conjugate of the transpose of  RIGHTMATRIX.  Otherwise
LEFTMATRIX is the inverse of RIGHTMATRIX.  RIGHTMATRIX
is the matrix the columns of which are the unit eigenvectors of MAT.
The other flags have the same effects since SIMILARITYTRANSFORM
calls the other functions in the package in order to be able to
form RIGHTMATRIX...
.endfunction

Finally, for some of you who may think that the names of the 
functions are too long, there are some aliases (In the following
list " := "  means  "is equivalent to".). Note that using these may 
make your code pretty unreadable, you'll save 50% in typing though.

CONJ(X):= CONJUGATE(X)

INPROD(X,Y):= INNERPRODUCT(X,Y)

UVECT(X):= UNITVECTOR(X)

COVECT(X):= COLUMNVECTOR(X)

GSCHMIT(X):= GRAMSCHMIDT(X)

EIVALS(MAT):= EIGENVALUES(MAT)

EIVECTS(MAT):= EIGENVECTORS(MAT)

UEIVECTS(MAT):= UNITEIGENVECTORS(MAT)

SIMTRAN(MAT):= SIMILARITYTRANSFORM(MAT)


.sec(Integration of Special Forms,intspec,1)


INTSCE LISP contains a routine, written by Richard Bogen, for integrating products of sines,cosines and exponentials of the form
.example
                EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M
.end
The call is
.inline function(INTSCE,|expr,var|)
2expr1 may be any expression, but if it is not in the above
form then the regular integration program will be invoked
if the switch $var<ERRINTSCE/TRUE> is TRUE.  If it is FALSE
then INTSCE will err out.



.sec(Integral Equations,inteqs)

The following package was written by Richard Bogen based on some routines of David Stoutemyer.   It is still an experimental version, untranslated and uncompiled at present.  

To load the package, do BATCH(INTEQN,>,DSK,SHARE).

CAVEAT:  To free some storage,  a  KILL(LABELS) is included in this file.  Therefore, before loading the integral equation package, the user should give names to any expressions he wants to keep.

The usage is very simple. The main function is called IEQN.  It takes five arguments though only the first one is required. If trailing arguments are omitted they will default to preset values which will be announced.

Two types of equations are considered. An integral equation of the 2second kind1 is of the form:
.example
.begin group
			      B(X)
			     /
			     [
(D3) 	   P(X) = Q(X, P(X), I	   W(X, U, P(X), P(U)) dU)   .
			     ]
			     /
			      A(X)

.end
.end
.scon
An integral equation of the 2first kind1 is of the form:
.example
.begin group
		     B(X)
		    /
		    [
(D4) 		    I	  W(X, U, P(U)) dU = F(X)
		    ]
		    /
		     A(X)

.end
.end
.scon
The unknown function in these equations is P(X) while Q,W,A, and B are given
functions of the independent variable.
Although these are the general forms, most of the solution
techniques require particular forms of Q and W.

The techniques used are:

2For SECONDKIND equations1:
.begin narrow 8,5
.SCON
FINITERANK: for degenerate (or separable) integrands.
.bcon
DIFFEQN: reduction to differential equation.
.bcon
TRANSFORM: Laplace Transform for convolution types.
.bcon
FREDSERIES: Fredholm-Carleman series for linear equations.
.bcon
TAILOR: Taylor series for quasi-linear variable-limit equations.
.bcon
NEUMANN: Neumann series for quasi-second kind equations.
.bcon
COLLOCATE: collocation using a power series form for P(X) evaluated at equally spaced points.
.end
.scon
2For FIRSTKIND equations:1
.begin narrow 8,5
.SCON
FINITERANK: for degenerate integrands.
.bcon
DIFFEQN: reduction to differential equation.
.bcon
ABEL: for singular integrands.
.bcon
TRANSFORM: see above
.bcon
COLLOCATE: see above
.bcon
FIRSTKINDSERIES: iteration technique similar to Neumann series.
.end
.scon
Also, differentiation is used in certain cases to transform a FIRSTKIND into a SECONDKIND.
.scon
The calling sequence is
.function(IEQN,|ie,unk,tech,n,guess|)
where 2ie1 is  the integral equation; 2unk1 is the unknown function; 2tech1 is the technique to be tried from those given above (2tech1 = FIRST means: try the first technique which finds a solution; 2tech1 = ALL means: try all applicable techniques); 2n1 is the maximum number of terms to take for TAYLOR, NEUMANN, FIRSTKINDSERIES, or FREDSERIES (it is also the maximum depth of recursion for the differentiation method); 2guess1 is the initial guess for NEUMANN or FIRSTKINDSERIES.

Default values for the 2nd thru 5th parameters are:
.begin narrow 8,5
.scon
2unk1: P(X), where P is the first function encountered in an integrand which is unknown to MACSYMA and X is the variable which occurs as an argument to the first occurrence of P found outside of an integral in the case of SECONDKIND equations, or is the only other variable besides the variable of integration in FIRSTKIND equations.  If the attempt to search for X fails, the user will be asked to supply the independent variable;
.bcon
2tech1: FIRST;
.bcon
2n1: 1;
.bcon
2guess1: NONE,  which  will cause NEUMANN and FIRSTKINDSERIES too use F(X)  as an initial guess.
.end
.scon
The value returned by IEQN is a list of labels of solution lists. The solution lists are printed as they are found unless the variable $var<IEQNPRINT/TRUE> is set to FALSE. These lists are of the form
.once center
[SOLUTION, TECHNIQUE USED, NTERMS, FLAG]
.scon
where FLAG is absent if the solution is exact.  Otherwise, it is the word APPROXIMATE or INCOMPLETE corresponding to an inexact or non-closed form solution,
respectively. If a series method was used, NTERMS gives the
number of terms taken (which could be less than the 2n1 given to IEQN if an error prevented generation of further terms).
.endfunction

For examples, do BATCH(INTEXS,">",DSK,RAB) which will load an array
called EQ with about 43 sample integral equations. Then try IEQN(EQ[1]), IEQN(EQ[30],P(X),ALL), for instance.


.sec(Numerical Techniques,numtech)
.subsec(Numerical Integration,brmbg)

A Bigfloated version of the ROMBERG function ($see<numint>)
is gotten by saying:
.example
LOAD(BRMBRG);
.end
The name of the function in it is BROMBERG.  It's use is identical to
the ROMBERG function except that ROMBERGTOL is called BROMBERGTOL
(default value 1.B-4) ROMBERGABS is called BROMBERGABS (default value
0.0B0) ROMBERGIT is called BROMBERGIT (default value 11), and
ROMBERGMIN is call BROMBERGMIN (default value 0).

.subsec(Fast Fourier Transforms,fft,1)

The following describes some FFT routines written by Tom Knight.
To load the routines do LOADFILE(FFT,FASL,DSK,SHARE);  The basic functions
 are: 
FFT(Fast Fourier Transform), IFT (Inverse Fast Fourier Transform).

These functions perform a (complex) fast fourier transform on either 1 or 2
dimensional FLOATING-POINT arrays, obtained by:  ARRAY(array,FLOAT,dim1); or
ARRAY(array,FLOAT,dim1,dim2);  for 1d arrays dim1 must equal 2^n-1, and
for 2d arrays dim1=dim2=2^n-1 (i.e. the array is square).  (Recall that
MACSYMA arrays are indexed from a 0 origin so that there will be 2^n and
(2^n)^2 arrays elements in the above two cases.)

The calling sequence is:
.function(FFT,|real-array,imag-array|) 
 
.endfunction
.function(IFT,|real-array,imag-array|)
 
.endfunction
.scon
The real and imaginary arrays must of course be the same size.  The transforms
 are done in place so that 2real-array1 and 2imag-array1 will contain 
the real and imaginary parts of the transform.

The definitions of the Fast Fourier Transform and its inverse
are given here.  Here A is the array to be transformed and AT is
its transform.  Both A and AT are complex arrays, although as noted
above FFT and IFT can only deal with separate real arrays for
the real and imaginary parts of A and AT.  N (or N^2) is the number
of elements in A in the 1D (or 2D) case.  (In fact these definitions
are not of the FFTs but of the discrete Fourier transforms.  The
FFT and IFT functions merely provided efficient algorithms for the
implementation of these definitions.)
.example
1D case:

      N - 1
      ====		       - 1
      \		 2 %I %PI I K N
AT  =  >    A  %E		   
  K   /	     I
      ====
      I = 0

	  N - 1
	  ====			      - 1
      - 1 \	      - 2 %I %PI I K N
A  = N	   >    AT  %E			  
 I	  /	  K
	  ====
	  K = 0

2D case:

	 N - 1 N - 1
	 ====  ====				   - 1
	 \     \	     2 %I %PI (I K + J L) N
AT     =  >     >    A	   %E			       
  K, L	 /     /      I, J
	 ====  ====
	 I = 0 J = 0

	     N - 1 N - 1
	     ====  ====					  - 1
	 - 2 \	   \		  - 2 %I %PI (I K + J L) N
A     = N     >	    >	 AT     %E			      
 I, J	     /	   /	   K, L
	     ====  ====
	     K = 0 L = 0
.end
Other functions included in this file are:

.function(POLARTORECT,|magnitude-array,phase-array|) 
converts from magnitude/phase form into real/imaginary form
putting the real part in the magnitude array and the imaginary part
into the phase array.
.endfunction
.function(RECTTOPOLAR,|real-array,imag-array|)
undoes POLARTORECT.
.endfunction

(The above four functions return a list of their arguments.)

.subsec(Roots of Equations by Interpolation,interproots,1)

The file INTPOL FASL, created by Charles Karney, contains the function

.function(INTERPOLATE,|func,x,a,b|)
which finds the zero of 2func* as 2x* varies.  The last two args give 
the range to look in.  The function must have a different sign at each 
endpoint.  If this condition is not met, the action of the of the function is 
governed by $var<INTPOLERROR/TRUE>).  If INTPOLERROR is TRUE then an error 
occurs,
otherwise the value of INTPOLERROR is returned  (thus for plotting INTPOLERROR
might be set to 0.0).  Otherwise (given that MACSYMA can evaluate the first
argument in the specified range, and that it is continuous) INTERPOLATE is
guaranteed to come up with the zero (or one of them if there is more than one
zero).

The accuracy of INTERPOLATE is governed by $var<INTPOLABS/0.0> and 
$var<INTPOLREL/0.0> which must be non-negative floating point numbers.  
INTERPOLATE will stop when the first arg evaluates to something less than or 
equal to INTPOLABS or if successive approximants to the root differ by no more
 than INTPOLREL * <one of the approximants>.  The defaults values of INTPOLABS
 and INTPOLREL are 0.0 so INTERPOLATE gets as good an answer as is possible 
with the single precision arithmetic we have.  The first arg may be an 
equation.  The order of the last
two args is irrelevant.  Thus
.example
INTERPOLATE(SIN(X)=X/2,X,%PI,.1);
.end
.scon
is equivalent to
.example
INTERPOLATE(SIN(X)=X/2,X,.1,%PI);
.end
.scon
The method used is a binary search in the range specified by the last two args.
When it thinks the function is close enough to being linear,  it starts using
linear interpolation.

An alternative syntax has been added to interpolate, this replaces the first
 two arguments by a function name.  The function MUST be TRANSLATEd or compiled
function of one argument.  No checking of the result is done, so make sure  the
function returns a floating point number.

.example

F(X):=(MODEDECLARE(X,FLOAT),SIN(X)-X/2.0);
INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)	time= 60 msec
INTERPOLATE(F(X),X,0.1,%PI);		time= 68 msec
TRANSLATE(F);
INTERPOLATE(F(X),X,0.1,%PI);		time= 26 msec
INTERPOLATE(F,0.1,%PI);			time=  5 msec
.end
.endfunction

.subsec(Special Functions,spec!fun,1)

The file BESSEL FASL contains routines for computing numerical values for  
various special functions.  If they are given non-numeric arguments they 
return themselves.

2Bessel Functions*

The following functions compute Bessel functions of integer order for real 
arguments.

.function(J0,X) 
returns the value of the zeroth order Bessel function at 2X*.
.endfunction
.function(J1,X)
returns the value of the Bessel function of first order at 2X*
.endfunction
.function(JN,|X,N|)
returns the 2N*'th order Bessel function.  In addition it sets up an array
 JARRAY of  N+1 elements, (numbered from 0 to ABS(N))  such that JARRAY[I] 
gives the value of the I'th order Bessel function  with argument X.  (If N < 0
 then JARRAY[I] gives the (-I)'th Bessel function).
.endfunction

2Modified Bessel Functions*

The following functions compute the Modified Bessel Functions I of integer 
orders for real arguments.

.function(I0,X)
returns the value of the modified Bessel function of zeroth order.
.endfunction
.function(I1,X)
returns the value of the modified Bessel function of first order.
.endfunction
.function(IN,|X,N|)
works the same way as JN(X,N), except that the array is called IARRAY.
.endfunction

Since the modified Bessel function blows up like EXP(ABS(X)) at infinity, 
they cannot be evaluated directly for ABS(X) > 83 (due to overflow).  The 
following functions avoid this problem:

.function(G0,X)
returns I0(X)*EXP(-ABS(X)).
.endfunction
.function(G1,X)
returns I1(X)*EXP(-ABS(X)).
.endfunction
.function(GN,|X,N|)
returns IN(X,N)*EXP(-ABS(X)). The array generated by GN is called GARRAY.
.endfunction


2Complex Bessel Function of positive fractional order*

.function(BESSEL,|Z,A|)
returns the Bessel function J for complex Z and real A 7>* 0.0 .  Also an 
array BESSELARRAY is set up such that BESSELARRAY[I] = J[I+A-ENTIER(A)](Z)
.endfunction
.function(AIRY,X)
returns the Airy function Ai of real argument 2X*.
.endfunction

2Plasma Dispersion Function,* NZETA(Z).

This function is related to the complex error function by 

.example
NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z))
.end


.function(NZETA,Z)
returns the complex value of the Plasma Dispersion Function for complex Z.
.endfunction
.function(NZETAR,Z)
returns  REALPART(NZETA(Z)).
.endfunction
.function(NZETAI,Z)
returns IMAGPART(NZETA(Z)).
.endfunction


2Normal distribution function*

.function(GAUSS,|MEAN,SD|)
returns a random floating point number from a normal distribution with mean
 2MEAN* and standard deviation 2SD*
.endfunction


.subsec(Polynomial Zeros,poly!zero,1)


      The file SHARE;PRRID FASL  contains the code, written by Richard Fateman,
which implements the Collins-Loos "Polynomial Real Root Isoloation by 
Differentiation"
algorithm, as described in the Collins-Loos paper, Proc. of the 1976 ACM Symp.
on Symbolic and Algebraic Computation.  The subsequent improvements,
due to Fateman, and described in his paper in the Proc. of the 1977 MACSYMA
Users' Conference, are also included.
Three versions, PRRID1, PRRID2, and PRRID3 are included.  The first of these is
the original algorithm, transcribed from "ALDES", and the second two use
combinations of exact and floating point arithmetic to achieve the same 
results.
PRRID3 appears to be the fastest for most cases.

Input: a univariate polynomial  (preferably in rational canonical form).

Output: a list of the form [ I1, M1, I2, m2, ... In, Mn] in
which each Ij is itself a list of two items, each a rational number, [Aj, Bj].
There are exactly Mj real zeros of the input polynomial in the half-open
interval (Aj, Bj].
      These programs are potentially much faster than
the Sturm sequence calculation used by realroots (the system command),
for polynomials with fewer real zeros than the maximum possible.  They are 
slower
for some polynomials e.g.  (x-1)*(x-2)* ...*(x-20).
    Realroots goes a bit further in that it will refine the isolating intervals
to some desired narrowness.  This is not done by the PRRID programs,
but could be easily done.  A Newton iteration guaranteed to converge, can
be used to refine the zeros, starting from points based on the zeros of the
 second
derivative of the input.


    A faster program has been implemented by Bruce Char, which, however, does
 not
have the same precise characteristics.  Using the "allroots" command,
approximate zeros are located, and then disks in the complex plane are computed
which include the actual positions of the zeros.  This is much faster in
finding isolating disks, and works in the complex plane.  Unfortunately, the
 disks
may intersect (in which case the program says so). 

