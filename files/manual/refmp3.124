.if partial then start
.count chapter from 6 printing "1"
.count section from 6 in chapter printing "!.1"
.count subsection in section printing "!.1"
.next chapter
.end

.sec(Taylor Series,taylor)
.<<see file MANUAL;TAYLOR >>
.sec(Trigonometric Simplification,trigsimpl)

.function (TRIGEXPAND,exp)
expands trigonometric and hyperbolic functions of sums
of angles and of multiple angles occurring in 2exp1.  For best results, 2exp1 should be expanded.   To enhance user control of simplification, this function expands only one level at a time, expanding sums of angles or multiple angles.    To obtain full expansion into sines and cosines immediately, set the switch  TRIGEXPAND:TRUE.


$var<TRIGEXPAND/FALSE> if TRUE causes expansion of all expressions containing
SINs and COSs occurring subsequently.

$var<HALFANGLES/FALSE> - if TRUE causes half-angles to be simplified away.

$var<TRIGEXPANDPLUS/TRUE> - controls the "sum" rule for
TRIGEXPAND.  Thus, when the TRIGEXPAND command is used or the
TRIGEXPAND switch set to TRUE, expansion of sums (e.g. SIN(X+Y)) will
take place only if TRIGEXPANDPLUS is TRUE.

$var<TRIGEXPANDTIMES/TRUE> - controls the "product" rule for
TRIGEXPAND.  Thus, when the TRIGEXPAND command is used or the
TRIGEXPAND switch set to TRUE, expansion of products (e.g. SIN(2*X))
will take place only if TRIGEXPANDTIMES is TRUE.

.example
(C1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;

.begin group
                              2           2
(D1)                     - SIN (X) + 3 COS (X) + X
.end
.begin group
(C2) TRIGEXPAND(SIN(10*X+Y));

(D2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)
.end
.end
.endfunction

.function (TRIGREDUCE,|exp, var|)
combines products and powers of trigonometric and hyperbolic SINs and COSs of
2var1 into those of multiples of 2var1.  It also tries to eliminate these
functions when they occur in denominators.  If 2var1 is omitted then all
variables in 2exp1 are used.  Also see the POISSIMP function  ($ref<poissfun>).

.example group
(C4) EXPAND(TRIGREDUCE(D1));
(D4)                        2 COS(2 X) + X + 1

.end

The trigonometric simplification routines will use declared information in some simple cases.  Declarations about variables $see<compilation> are used as follows, e.g.

.example

(C5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$

(C6) SIN(X + (E + 1/2)*%PI);

(D6) 			  COS(X)

(C7) SIN(X + (O + 1/2)*%PI);


(D7) 			 - COS(X)

.end

.endfunction

$var<TRIGINVERSES/ALL> - controls the simplification of the
composition of trig and hyperbolic functions with their inverse
functions: If ALL, both e.g. ATAN(TAN(X)) and TAN(ATAN(X)) simplify to
X.  If TRUE, the arcfunction(function(x)) simplification is turned
off.  If FALSE, both the arcfun(fun(x)) and fun(arcfun(x))
simplifications are turned off.


.function(TRIGSIMP,|exp|)
employs the identities SIN(X)^2 + COS(X)^2 = 1 and
COSH(X)^2 - SINH(X)^2 = 1 to simplify expressions containing TAN, SEC,
etc. to SIN, COS, SINH, and COSH so that further simplification may be
obtained by using TRIGREDUCE on the result.
.example group
(C8) (1-SIN(X)^2)*COS(X)/COS(X)^2+TAN(X)*SEC(X)^2;
						 2
			    2		  1 - SIN (X)
(D8) 			 SEC (X) TAN(X) + -----------
					    COS(X)

(C9) TRIGSIMP(%);
					   4
			       SIN(X) + COS (X)
(D9) 			       ----------------
				      3
				   COS (X)

(C10) TAN(X)^2+SEC(X)^2/(1-TAN(X)*SEC(X));
				 2
			      SEC (X)	        2
(D10) 			 ----------------- + TAN (X)
			 1 - SEC(X) TAN(X)

(C11) TRIGSIMP(%);
			       4	 3
			    SIN (X) + SIN (X) - 1
(D11) 			   ------------------------
			      2		       4
			   COS (X) SIN(X) - COS (X)

(C12) (SIN(X)^4-6*COS(X)^2*SIN(X)^2+4*(COS(X)^2-SIN(X)^2)+8*SIN(X)+COS(X)^4+3)/(8*COS(X)^3);
(D12)

     4		 2	 2	      2	        2		      4
  SIN (X) - 6 COS (X) SIN (X) + 4 (COS (X) - SIN (X)) + 8 SIN(X) + COS (X) + 3
  ----------------------------------------------------------------------------
					3
				   8 COS (X)

(C13) TRIGSIMP(%);
					   4
			       SIN(X) + COS (X)
(D13) 			       ----------------
				      3
				   COS (X)

.end
.endfunction

There are a number of ways the user may also explicitly invoke identities such as sin^2(x) + cos^2(x) = 1.    The simplest method is substitution.

.example

(C14) D1;
			       2	   2
(D14) 			  - SIN (X) + 3 COS (X) + X

(C15) %,SIN(X)^2=1-COS(X)^2;
				   2
(D15) 			      4 COS (X) + X - 1


.end

Often one wishes to recognize that sin^4(x) can be transformed using the same rule.  For this one needs the added power of RATSUBST.

.example

(C16) RATSUBST(1-COS(X)^2,SIN(X)^2,SIN(X)^4);

			      4		  2
(D16) 			   COS (X) - 2 COS (X) + 1

.end
In general RATSUBST will perform a RATSIMP (and thus an expansion) as well as apply the substitution.   One can similarly use the LETSIMP and DEFRULE commands together with additional declarations to define more intricate rules.  

Although not as powerful as RATSUBST, the TELLSIMP command enables the automatic application of a rule.

.example

(C17) TELLSIMP(SIN(X)^2,1-COS(X)^2)$

(C18) (SIN(X)+1)^2;
					    2
(D18) 			        (SIN(X) + 1)

(C19) EXPAND(%);
					  2
(D19) 			    2 SIN(X) - COS (X) + 2

(C20) SIN(X)^2;
					2
(D20) 				 1 - COS (X)

.end

.sec(Laplace Transforms,laplace)

.function (LAPLACE,|exp, ovar, lvar|)
takes the Laplace transform of 2exp1 with respect to the variable 2ovar1
and transform parameter 2lvar1.  2Exp1 may only involve the functions EXP,
LOG, SIN, COS, SINH, COSH, and ERF.  It may also be a linear, constant coefficient 
differential equation in which case $fun<ATVALUE> (see $ref<substfuns>) of the dependent
variable will be used.  These may be supplied either before or after the
transform is taken. Since the initial conditions must be specified at zero, if
one has boundary conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution for them
and substituting their values back. 2exp1 may also involve convolution
integrals.  Functional relationships must be explicitly represented in order for
LAPLACE to work properly. That is, if F depends on X and Y it must be written as
F(X,Y) wherever F occurs as in LAPLACE('DIFF(F(X,Y),X),X,S).

.example group
(C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);

                     A
                 2 %E  (S - 2)
(D1)            ---------------
                        2     2
                ((S - 2)  + 1)
.end

Currently only LAPLACE knows about the DELTA function:

.example
(C2) LAPLACE(DELTA(T-A)*SIN(B*T),T,S);

Is A positive, negative or zero?

POS;
					  - A S
(D2) 			       SIN(A B) %E


.end
.endfunction

.function (ILT,|exp, lvar, ovar|)
takes the inverse Laplace transform of 2exp1 with respect to 2lvar1 and
parameter 2ovar1.  2exp1 must be a ratio of polynomials whose denominator
has only linear and quadratic factors.  By using the functions LAPLACE and ILT
together with the SOLVE or LINSOLVE functions the user can solve a single
differential or convolution integral equation or a set of them.

.example
(C1) 'INTEGRATE(SINH(A*X)*F(T-X),X,0,T)+B*F(T)=T**2;

.begin group
              T
             /
             [                                     2
(D1)         I (SINH(A X) F(T - X)) DX + B F(T) = T
             ]
             /
             0
.end

(C2) LAPLACE(%,T,S);

.begin group
            A LAPLACE(F(T), T, S)                             2
(D2)        ---------------------  +  B LAPLACE(F(T), T, S) = --
                    2    2                                     3
                   S  - A                                     S

.end

(C3) LINSOLVE([%],['LAPLACE(F(T),T,S)]);
SOLUTION

.begin group
                                        2      2
                                     2 S  - 2 A
(E3)       LAPLACE(F(T), T, S) = --------------------
                                    5         2     3
                                 B S  + (A - A  B) S
.end

(D3)                         [E3]

(C4) ILT(E3,S,T);

Is  A B (A B - 1)  positive, negative, or zero?

POS;

.begin group
                                       2
                       SQRT(A) SQRT(A B  - B) T
                2 COSH(------------------------) 
                                  B              
(D4)  F(T) =  - -------------------------------- 
                               A                 

	      2
	   A T             2
	+ ------- + ------------------
	  A B - 1    3  2      2
	            A  B  - 2 A  B + A
.end

.end
.endfunction

2Laplace Transforms of Special Functions1

The following function for taking Laplace transforms of Special Functions 
is available in MACSYMA.  The user must type LOADFILE(SPECFN,LISP,DSK,SHARE);
to load in the special routines.  Since the latter take up a great deal of space, it is recommended that these computations be carried out in a fresh MACSYMA.

.function(LAPINT,|exp,ovar|)
takes the Laplace transform of 2exp1 with respect to the variable 2ovar1.   2exp1 may involve 
.scon
1) Special Functions of linear or quadratic argument multiplied by 
.begin narrow 8,0
.bcon
a) arbitrary powers of the argument, or
.bcon
b) trigonometric and exponential functions of linear argument
.end
.scon
2) Products of two Special Functions of linear or quadratic argument taken from only one of the following groups:
.begin narrow 8,0
.bcon
a) Any kind of Bessel, Modified Bessel, or Hankel functions,
.bcon
b) Orthogonal polynomials,
.bcon
c) Confluent Hypergeometric Functions

In this second category, factors of type 1a or 1b are also permitted.
.end

The basic method is to rewrite the expression in terms of Generalized Hypergeometric Functions (GHF), apply a general formula  for taking the Laplace transform of GHF's, and then, if possible, present the result in terms of  elementary functions or "common" Special Functions.   For further details, see  2Symbolic Laplace Transforms of Special Functions1 [Av].

.example
(C1) T^(1/2)*GAMMAINCOMPLETE(1/2,A*T)*%E^(-P*T);

				   1		     - P T
(D1) 		   GAMMAINCOMPLETE(-, A T) SQRT(T) %E
				   2
.begin group
(C2) LAPINT(%,T);

		       %PI			     2
(D2) 	   --------------------------- - -------------------------
		    3/2	       A   3/2	        3/2	   A   3/2
	   2 (P + A)    (1 - -----)	 (P + A)    (1 - -----)
			     P + A			 P + A

.end
.begin group
(C3) T^(1/2)*J[1](2*A^(1/2)*T^(1/2))*%E^(-P*T);

						    - P T
(D3) 		    J (2 SQRT(A) SQRT(T)) SQRT(T) %E
		     1

.end
(C4) LAPINT(%,T);

					 - A/P
			       SQRT(A) %E
(D4) 			       ---------------
				      2
				     P

(C5) T^2*J[1](A*T)*%E^(-P*T);

				       2   - P T
(D5) 			      J (A T) T  %E
			       1

.begin group
(C6) LAPINT(%,T);

				     3 A
(D6) 			        --------------
				  2
				 A      5/2  4
				(-- + 1)    P
				  2
				 P
.end
(C7) T^(3/2)*Y[1](A*T)*%E^(-T);

				       3/2   - T
(D7) 			      Y (A T) T	   %E
			       1
.begin group
(C8) LAPINT(%,T);

					  %I	 1	  3/4
		15 %I SQRT(2) P	       (- --) (------ - 1)
			       - 2, 1/2	  A     2
					       A  + 1
(D8) 	        ---------------------------------------------
				2     2	   2	 2     1/4
		  8 SQRT(%PI) (A  + 1)  ((A  + 1)  - 1)

.end
.end
.endfunction


.sec(Combinatorial Functions,combfun)

.function (MINFACTORIAL,exp)
examines 2exp1 for occurrences of two factorials which differ by an
integer.  It then turns one into a polynomial times the other.  

.example
(C1) N!/(N+1)!;
.begin group
                                    N!
(D1)                             --------
                                 (N + 1)!
.end

(C2) MINFACTORIAL(%);
.begin group
                                     1
(D2)                               -----
                                   N + 1
.end

.end
.endfunction

.function (FACTCOMB,exp)
tries to combine the coefficients of factorials in 2exp1 with the factorials
themselves by converting, for example, (N+1)*N! into (N+1)!.



$var<SUMSPLITFACT/TRUE> if set to FALSE will cause MINFACTORIAL to be applied after a FACTCOMB.   

.example group
(C1) (N+1)^B*N!^B;
                                      B   B
(D1)                           (N + 1)  N!

(C2) FACTCOMB(%);
                                         B
(D1)                             (N + 1)!

.end
.endfunction

.function(MAKEFACT,exp)
transforms occurrences of binomial,gamma, and beta functions in 2exp*
to factorials.
.endfunction

.function(MAKEGAMMA,exp)
transforms occurrences of binomial,factorial, and beta functions in 2exp*
to gamma functions.
.endfunction

.function (BERNPOLY,|v, n|)
generates the 2n1th Bernoulli polynomial in the variable 2v1.

.endfunction

.sec(Continued Fractions,confrac)

.function (CF,exp)
converts 2exp1 into a continued fraction.  2exp1 is an expression composed of
arithmetic operators and lists which represent continued fractions.  A continued
fraction  a+1/(b+1/(c+...)) is represented by the list [a,b,c,...]. a,b,c,.. must
be integers.  2Exp1 may also involve SQRT(2n1) where 2n1 is an integer.  In
this case CF will give as many terms of the continued fraction as the value of the
variable $var<CFLENGTH/1> times the period.  Thus the default is to give one
period.

.endfunction

.function (CFDISREP,list)
converts the continued fraction represented by 2list1 into general representation.

.example
(C1) CF([1,2,-3]+[1,-2,1]);

(D1)                 [1, 1, 1, 2]

(C2) CFDISREP(%);
.begin group
                            1
(D2)                1 + ---------
                              1
                        1 + -----
                                1
                            1 + -
                                2
.end

.end
.endfunction

.function (CFEXPAND,x)
gives a matrix of the numerators and denominators of the next-to-last and last
convergents of the continued fraction 2x1.

.example group
(C1) (CFLENGTH:4, CF(SQRT(3));
(D1)                 [1, 1, 2, 1, 2, 1, 2, 1, 2]

(C2) CFEXPAND(%);
                             [265  97]
(D2)                         [       ]
                             [153  56]

(C3) D2[1,2]/D2[2,2],NUMER;
(D3)                        1.73214285
.end
.endfunction


.sec(Number-Theoretic Functions,numtheory)


.function(PRIME,n)
gives the 2n1th prime. $var<MAXPRIME/489318> is the largest number accepted as argument.  
.endfunction

.function(DIVSUM,|n,k|)
adds up all the factors of 2n1 raised to the 2k1th power.  If only one argument is given then 2k1  is assumed to be 1.
.endfunction

.function(TOTIENT,n)
is the number of integers less than or equal to 2n1 which are relatively prime to 2n1.
.endfunction

.function(JACOBI,|p,q|)
is the Jacobi symbol of p and q.
.endfunction

.function (QUNIT,n)
gives the principal unit of the real quadratic number field $fun<SQRT>(2n*)
where 2n1 is an integer, i.e. the element whose norm is unity.  This amounts to
solving Pell's equation A**2-2n1*B**2=1.

.example group
(C1) QUNIT(17);
(D1)              SQRT(17)+4

(C2)  EXPAND(%*(SQRT(17)-4));

(D2)               1

.end
.endfunction

.chap(|Declaring and Using Mathematical Information|,declar)
.<<check that "fdusm" isn't referred to anywhere... change to "declar">>

The commands in this chapter deal with the communication, use, and
manipulation of mathematical information about objects and functions
in MACSYMA.  Taken as a whole, this information comprises MACSYMA's
relational data base.  Facts take the form of either "predicates" or
"features".  A predicate is a well-formed formula consisting of a
relation and its arguments, e.g. A>B, or is a composition of
predicates using the logical operators NOT, AND, and OR.
Alternatively, certain facts about mathematical objects and functions
can be expressed more naturally as "features", i.e.  unary predicates.
For example, one can say that a certain constant is an INTEGER or that
a function is INCREASING.  Any feature, e.g. the linearity of F, can
also be expressed as a predicate via the relation KIND, as in
KIND(F,LINEAR).

.sec(Declaring and Assuming,decass)

The predicates and features communicated to MACSYMA with the ASSUME
and DECLARE commands may be tested with IS and FEATUREP and removed
with FORGET and REMOVE.  The facts in the relational data base are
used by the simplifier and several commands, like SIGN, the IF
statement, and INTEGRATE (certain integrations require sign
information).  MACSYMA has a rudimentary inference capability enabling
limited deductions from the data base.  It excels at taxonomic
deductions, e.g. KIND(N,EVEN) implies KIND(N,INTEGER), and simple
expression comparisons, e.g. X<0 and KIND(N,EVEN) imply Y^2+X^N>0.
The only sort of inequality information used by the inference
mechanism at the moment are relations between variables and other
variables and numbers.

The operator "=" is a total relation that holds between two
expressions if and only if the expressions are syntactically
identical.  It is not a mathematical comparison.  Thus,
IS((X+1)^2=X^2+2*X+1) would return FALSE.  The relation EQUAL, on
the other hand, is a mathematical comparison of its two arguments.  A
predicate involving EQUAL is true if and only if its arguments are
mathematically equivalent in light of the current data base.  Thus,
IS(EQUAL((X+1)^2,X^2+2*X+1)) would return TRUE.  The operators ">",
">=", "<", and "<=" are also mathematical comparisons.

MACSYMA currently recognizes and uses the following features of
objects and functions: INTEGER, NONINTEGER, EVEN, ODD, RATIONAL,
IRRATIONAL, REAL, IMAGINARY, COMPLEX, ANALYTIC, INCREASING,
DECREASING, ODDFUN (odd function), EVENFUN (even function), POSFUN
(positive function), COMMUTATIVE, ASSOCIATIVE, SYMMETRIC,
ANTISYMMETRIC.  The variable $var<FEATURES/> contains a list of these
and any others the user may add with the DECLARE command.

.function(ASSUME,|pred1, pred2, ...|)
first checks the specified predicates for redundancy
and consistency with the current data base.  If the predicates are
consistent and non-redundant, they are added to the data base; if
inconsistent or redundant, no action is taken.  ASSUME returns a list
whose entries are the predicates added to the data base and the atoms
REDUNDANT or INCONSISTENT where applicable.  ASSUME also accepts lists
of predicates as arguments.
.endfunction

.function(FORGET,|pred1, pred2, ...|)
removes the specified predicates from the data base.  Note that it
does not guarantee that equivalent facts are removed.  FORGET also
accepts lists of predicates as arguments.
.endfunction

.function(DECLARE,|a1, f1, a2, f2,...|)
declares each 2ai1 to have the corresponding feature 2f1i.  DECLARE(F,
INCREASING) is in all respects equivalent to
ASSUME(KIND(F,INCREASING)).  The 2ai1 and 2fi1 may also be lists of
objects or features.
.endfunction

.function(REMOVE,|a1, f1, a2, f2, ...|)
removes each feature 2fi1 from the corresponding object 2a1i.  The 2ai1 and
2fi1 may also be lists of objects or features.
.endfunction

.function(IS,pred)
attempts to determine whether the specified predicate is provable from
the facts in the current data base.  IS returns TRUE if the predicate
is true for all values of its variables consistent with the data base
and returns FALSE if it is false for all such values.  Otherwise, its
action depends on the setting of the switch $var<PREDERROR/TRUE>. IS errs
out if the value of PREDERROR is TRUE and returns UNKNOWN if PREDERROR
is FALSE.
.endfunction

.function(FEATUREP,|a,f|)
attempts to determine whether the object 2a1 has the feature 2f1 on the
basis of the facts in the current data base.  If so, it returns TRUE,
else FALSE.
.begin nofill group
(C1) DECLARE(J,EVEN)$

(C2) FEATUREP(J,INTEGER);
(D2)                                TRUE
.end
.endfunction

.function(SIGN,exp)
attempts to determine the sign of its specified expression on the
basis of the facts in the current data base.  It returns one of the
following answers: POS (positive), NEG (negative), ZERO, PZ (positive
or zero), NZ (negative or zero), PN (positive or negative), or PNZ
(positive, negative, or zero, i.e. nothing known).
.example
(C3) ASSUME(A>=B,B>=C,C>=D,D>=A);
(D3)                   [A >= B, B >= C, C >= D, D >= A]

(C4) SIGN(B-C);
(D4)                                 ZERO

(C5) DECLARE(K,INTEGER,L,ODD,F,INCREASING)$

(C6) ASSUME(X>0);
(D6)                               [X > 0]

(C7) F(X+3*Y^(L+24*K+1))-F(0);
                             L + 24 K + 1
(D7)                    F(3 Y             + X) - F(0)

(C8) SIGN(%);
(D8)                                 POS
.end
.endfunction

.function(ASKSIGN,exp)
first attempts to  determine whether the specified  expression is
positive, negative, or zero.  If it cannot, it asks the user the
necessary questions to complete its deduction.$$If the user wishes to
look at the expression more closely before replying, the variable
$var<ASKEXP/> is set to it.  Typing control-A results in a MACSYMA break 
$see<hints>; the user may now analyze the expression in order to give an
appropriate answer.*
The user's answer is recorded in the
data base for the duration of the current computation (one  "C-line"). The
value of ASKSIGN is one of POS, NEG, or ZERO.
.endfunction

    The following function, when applicable, gives the user relational
information.  However, it does NOT use the data base.

.function(ZEROEQUIV,|exp,var|)
tests whether the expression 2exp1 in the single variable 2var1 is
equivalent to zero.  It returns either TRUE, FALSE, or DONTKNOW.  For
example ZEROEQUIV(SIN(2*X) - 2*SIN(X)*COS(X),X) returns TRUE and
ZEROEQUIV(%E^X+X,X) returns FALSE.  On the other hand
ZEROEQUIV(LOG(A*B) - LOG(A) - LOG(B),A) will return DONTKNOW because
of the presence of an extra variable.  The restrictions are:
.begin indent 5,10;turn on ""
(1)(11)Do not use functions that MACSYMA does not know how to
differentiate and evaluate.

(2)(11)If the expression has poles on the real line, there may be
errors in the result (but this is unlikely to occur).

(3)(11)If the expression contains functions which are not solutions
to first order differential equations there may be incorrect results.

(4)(11)The algorithm uses floating-point evaluation at randomly
chosen points using a corresponding "epsilon" for carefully selected
subexpressions.  This is always somewhat hazardous, although the
algorithm tries to minimize the potential for error.
.end
.endfunction

.sec(Contexts,contexts)


    The context mechanism makes it possible for a user to bind
together and name a selected portion of his data base, called a
2context1.  Once this is done, the user can have MACSYMA assume or
forget large numbers of facts merely by activating or deactivating
their context.  Any atom can be a context, and the facts contained in
that context will be retained in storage until the user destroys them
individually by using FORGET or destroys them as a whole by using KILL
to destroy the context to which they belong.

    Contexts exist in a formal hierarchy, with the root always being
the context GLOBAL, which contains information about MACSYMA that some
functions need.  When in a given context, all the facts in that
context are "active" (meaning that they are used in deductions and
retrievals) as are all the facts in any context which is an inferior
of that context.  When a fresh MACSYMA is started up, the user is in a
context called INITIAL, which has GLOBAL as a subcontext.

.function(FACTS,context)
returns a list of the facts in the specified 2context.1  If no argument
is given, the default is to list the current context.  Facts which are
active, but in a different context are not listed.
.endfunction

.function(NEWCONTEXT,name)
creates a new (empty) context, called 2name1, which has
GLOBAL as its only subcontext.  The new context created will become the
currently active context. 
.endfunction

.function(SUPCONTEXT,|name,context|)
will create a new context (called 2name1) whose subcontext is 2context1.
If context is not specified, the current context will be assumed.  If
it is specified, context must exist.
.endfunction

$var<CONTEXT/INITIAL>. Whenever a user assumes a new fact, it is placed in the
context named as the current value of the variable CONTEXT.
Similarly, FORGET references the current value of CONTEXT.  To change
contexts, simply bind CONTEXT to the desired context.  If the
specified context does not exist it will be created by an invisible
call to NEWCONTEXT.  The context specified by the value of CONTEXT is
automatically activated.

$var<CONTEXTS/[INITIAL,GLOBAL]> is a list of the contexts which
currently exist, including the currently active context.

.function(KILLCONTEXT,|context1,context2,...,contextn|)
kills the specified contexts.  If one of them is the current context,
the new current context will become the first available subcontext of
the current context which has not been killed.  If the first available
unkilled context is GLOBAL then INITIAL is used instead.  If the
INITIAL context is killed, a new INITIAL is created, which is empty of
facts.  KILLCONTEXT doesn't allow the user to kill a context which is
currently active, either because it is a subcontext of the current
context, or by use of the function ACTIVATE.
.endfunction

.function(ACTIVATE,|cont1, cont2, ...|)
causes the specified contexts 2conti1 to be activated.  The facts in
these contexts are used in making deductions and retrieving
information.  The facts in these contexts are not listed when FACTS();
is done.
.endfunction

.function(DEACTIVATE,|cont1, cont2, ...|)
causes the specified contexts 2conti1 to be deactivated.
.endfunction

$var<ACTIVECONTEXTS/[]> is a list of the contexts which are active by
way of the ACTIVATE function, as opposed to being active because they
are subcontexts of the current context.

.example
(C9) CONTEXT:CON1$

(C10) DECLARE(M,INTEGER)$

(C11) FEATUREP(M,INTEGER);
(D11)                                TRUE

(C12) CONTEXT:CON2$

(C13) FEATUREP(M,INTEGER);
(D13)                               FALSE

(C14) DECLARE(N,INTEGER);
(D14)                                DONE

(C15) CONTEXT:CON1$

(C16) FEATUREP(M,INTEGER);
(D16)                                TRUE

(C17) FEATUREP(N,INTEGER);
(D17)                               FALSE

(C18) ACTIVATE(CON2)$

(C19) FEATUREP(N,INTEGER);
(D19)                                TRUE

(C13) CONTEXTS;
(D13)                               [CON2]
.end

.function(LOCAL,|a1, a2, ...|)
causes the external facts about the objects 2a11, 2a12, ...  to be
forgotten for the duration of the enclosing BLOCK, independent of
context.  Any facts assumed about 2a11, 2a21, ... within the BLOCK
containing the LOCAL will be forgotten upon exit, again independent of
context.
.endfunction

.example

(C14) DECLARE(P,INTEGER)$

(C15) BLOCK(LOCAL(P),PRINT(FEATUREP(P,INTEGER)),DECLARE(P,IRRATIONAL))$
FALSE

(C16) FEATUREP(P,INTEGER);
(D16)                                TRUE

(C17) FEATUREP(P,IRRATIONAL);
(D17)                               FALSE
.end


.chap(List Handling and LISP-like functions,lisp!functions)

.function (APPLY,|function, list|)
gives the result of applying the 2function1 to the 2list1 of its
arguments.  This is useful when it is desired to compute the arguments to a function
before applying that function.  For example, if L is the list [1, 5, -10.2, 4, 3],
then APPLY(MIN,L) gives -10.2.  APPLY is also useful when calling functions which do
not have their arguments evaluated if it is desired to cause evaluation of them.  For
example, if FILESPEC is a variable bound to the list [TEST, CASE] then
APPLY(CLOSEFILE,FILESPEC) is equivalent to CLOSEFILE(TEST,CASE).  In general the first
argument to APPLY should be preceded by a ' to to make it evaluate to itself.  Since
some atomic variables have the same name as certain functions the values of the
variable would be used rather than the function because APPLY has its first argument
evaluated as well as its second.

.endfunction

.function(FUNMAKE,|name,[arg1,...,argn]|)
returns 2name*(arg1,...,argn) without calling the function 2name*.
.endfunction

.function(ARRAYMAKE,|name,[i1,i2,...]|)
returns  2name1[2i1,i2,...1].
.endfunction

.function (MAP,|fn, exp1, exp2, ...|)
 returns an expression whose leading operator is the same as that of the
2expi1 but whose subparts are the results of applying 2fn1 to the
corresponding subparts of the 2expi1.  2Fn1 is either the name of a function
of n arguments (where n is the number of 2expi1) or is a LAMBDA form of n
arguments.


$var<MAPERROR/TRUE> - if FALSE will cause all of the mapping functions to (1)
stop when they finish going down the shortest 2expi1 if not all of the
2expi1 are of the same length and (2) apply 2fn1 to [2exp1, exp2,...1] if
the 2expi1 are not all the same type of object. If MAPERROR is TRUE then an
error message will be given in the above two instances.


One of the uses of this function is to MAP a function (e.g. PARTFRAC) onto each
term of a very large expression where it ordinarily wouldn't be possible to use the
function on the entire expression due to an exhaustion of list storage space in the
course of the computation.

.example
.begin group
(C1) MAP(F,X+A*Y+B*Z);
(D1) 			  F(B Z) + F(A Y) + F(X)
.end
(C2) MAP(LAMBDA([U],PARTFRAC(U,X)),X/(X^3+4*X^2+5*X+2));
.begin group
				1	 X
(D2) 			   X (----- - --------)
			      X + 2	     2
				      (X + 1)
.end

(C3) MAP(RATSIMP, X/(X**2+X)+(Y**2+Y)/Y);

.begin group
                      1
(D3)            Y + ----- + 1
                    X + 1
.end

(C4) MAP("=",[A,B],[-.5, 3,2.5]);
MAP IS TRUNCATING
(D4)                [A = -.5, B = 3]

.end
.endfunction

.function(MAPATOM,expr)
is TRUE if and only if 2expr1 is treated  by the MAPping routines a
as an "atom", a unit.   "Mapatoms" are atoms, numbers (including rational numbers), and subscripted variables.
.endfunction

.function (MAPLIST,|fn, exp1, exp2, ...|)
yields a list of the applications of 2fn1 to the parts of the 2expi1.  This
differs from MAP(2fn,exp1,exp2,...1) which returns an expression with the same
main operator as expi has (except for simplifications and the case where MAP
does an APPLY).  2Fn1 is of the same form as in MAP.

.endfunction

.function (FULLMAP,|fn, exp1, ...|)
is similar to MAP but it will keep mapping down all subexpressions
until the main operators of the exp2i1 (if there are more than one)
are no longer the same or until "mapatoms" (see above) are met.

The user should be aware that FULLMAP is used by the MACSYMA  simplifier for certain matrix manipulations; thus,   the user might see an error message concerning FULLMAP even though FULLMAP was not explicitly called by the user.

.example
(C1) A+B*C$

(C2) FULLMAP(G,%);

(D2)              G(B) G(C) + G(A)

(C3)  MAP(G,D1);

(D3)                G(B C) + G(A)

.end
.endfunction

.function (FULLMAPL,|fn, list1, ...|)
is similar to FULLMAP but it only maps onto lists and matrices

.example group
(C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);

(D1)                      [[A + 3, 4], [4, 3.5]]

.end
.endfunction

.function(SCANMAP,|function,exp|)
recursively applies 2function1 to 2exp*.  This is most useful when "complete" factorization is desired, for example:

.example

(C1) EXP:(A^2+2*A+1)*Y + X^2$

(C2) SCANMAP(FACTOR,EXP);
				    2	   2
(D2) 			     (A + 1)  Y + X

.end

Note the way in which SCANMAP applies the given function FACTOR to the constituent subexpressions of 2exp1;  if another form of 2exp1 is presented to SCANMAP then the result may be different.  Thus, D2 is not recovered when SCANMAP is applied to the expanded form of 2exp1:

.example

(C3) SCANMAP(FACTOR,EXPAND(EXP));
.begin group
			   2		      2
(D3) 			  A  Y + 2 A Y + Y + X
.end
.end

Here is another example of the way in which SCANMAP recursively applies a given function to all subexpressions, including exponents:

.example
.begin group
				 
(C4) EXPR : U*V^(A*X+B) + C$
.end

(C5) SCANMAP('F, EXPR);
.skip 1
.begin group
		    F(F(F(A) F(X)) + F(B))
(D5) F(F(F(U) F(F(V)			  )) + F(C))
.end
.end
.endfunction

.function (APPEND,|list1, list2, ...|)
returns a single list of the elements of 2list11 followed by the
elements of 2list21,...

.example group
(C1) APPEND([Y+X,0,-3.2],[2.5E20,X]);

(D1)             [Y+X, 0, -3.2, 2.5E20, X]

.end
.endfunction

.function (CONS,|exp, list|)
returns a new list constructed of the element 2exp1 as its first element, followed by
the elements of 2list1.

.endfunction

.function (ENDCONS,|exp, list|)
returns a new list consisting of the elements of 2list1 followed by 2exp1.

.endfunction

.function (MEMBER,|exp, list|)
returns TRUE if 2exp1 occurs as a member of 2list1 (not within a member).  Otherwise
FALSE is returned.

.endfunction

.function (REVERSE,list)
reverses the order of the members of 2list1 (not the members themselves).

.scon
The functions $fun<FIRST>, $fun<REST>, $fun<LAST>, $fun<DELETE>, $fun<LENGTH>  ($ref<extracting!expressions>) also work on lists.

.skip 2
.example group once center
2Examples*

(C1) UNION(X,Y):=IF X = [] THEN Y ELSE
           IF MEMBER(T:FIRST(X),Y) THEN UNION(REST(X),Y)
           ELSE CONS(T,UNION(REST(X),Y)$

(C2) UNION([A,B,1,1/2,X**2],[-X**2,A,Y,1/2]);

                         2            2        1
(D2)                   [X , 1, B,  - X , A, Y, -]
                                               2
.end continue

In this example T is assigned the value of FIRST(X) in the call to MEMBER and is
referenced later in CONS(T,UNION(...)).

.example
(C3) BERNPOLY(X,5);
.begin group
                               4      3
                        5   5 X    5 X    X
(D3)                   X  - ---- + ---- - -
                             2      3     6
.end

(C4) MAPLIST(NUMFACTOR,%);
.begin group
                             5  5    1
(D4)                   [1, - -, -, - -]
                             2  3    6
.end

(C5) APPLY(MIN,%);
.begin group
                                  5
(D5)                            - -
                                  2
.end

.end
.endfunction

.function(MAKELIST,|exp,var,lo,hi|)
returns 
a list as value.  3lo1 and 3hi1 must be integers.
In this case MAKELIST is analogous to SUM.
.endfunction
.function(MAKELIST,|exp,var,list|)
returns 
a list as value.  In this
second case MAKELIST is similar to MAP.
.example
(C1)MAKELIST(CONCAT(X,I),I,1,6);
(D1)                      [X1,X2,X3,X4,X5,X6]

(C2)MAKELIST(X=Y,Y,[A,B,C])
(D2)                         [X=A,X=B,X=C]
.end
Note that in the example in C2, the equasion is mapped over the list
[A,B,C].
.endfunction
.sec (Property Specification Functions,property!specification,1)

The functions in this section are used to specify properties for atomic
variables.  A property is a piece of information which may be utilized during the
user's session with MACSYMA.  MODEDECLARE (sec. $ref<compilation>) is one example of a property
specification function.  Also, the subsequent section deals with functions for pattern
matching and includes the function MATCHDECLARE.  As these are somewhat complicated
they are described in other sections.  However, along with DECLARE (see below) and
other functions, they all perform the task of setting up information which is used
later.

For most types of properties there exists a name which is an indicator of that
property.  For example the command GRADEF(F(X),SIN(X**2)); causes F to receive a
"gradef" property of LAMBDA([X],SIN(X**2)).  (The indicator is GRADEF and the property
is the lambda expression).

The presence of some properties is signified merely by the presence of the
indicator and requires no additional information.  These indicators are known as flags.
For example %I has associated with it the flag CONSTANT.  We can also speak of
"constant" as being a property of %I.

There are three principal operations which are needed by the user in dealing with
properties.  He must be able to set up the property, to display it, and to remove it.
Also he may sometimes want to know what properties he set up in his MACSYMA.  There
are several lists (known as information lists) which contain all of the atoms
that possess a particular property. Moreover, the value of the variable $var<INFOLISTS/> is a list of the names of all of the information lists in MACSYMA. These are:

$var<LABELS/> - all bound C,D, and E labels.

$var<VALUES/> - all bound atoms (set up by : , :: , or functional binding).

$var<FUNCTIONS/> -  all user defined functions (set up by f(x):=...).

$var<ARRAYS/> - declared and undeclared arrays (set up by : , :: , or a[x]:=...)

$var<MYOPTIONS/> - all options ever reset by the user (whether or not they get reset to their default value). 

$var<RULES/> - user defined pattern matching and simplification rules (set up by
$fun<TELLSIMP>, $fun<TELLSIMPAFTER>, $fun<DEFMATCH>, or, $fun<DEFRULE>.)

$var<ALIASES/> - atoms which have a user defined alias (set up by the $fun<ALIAS>,
$fun<ORDERGREAT>, $fun<ORDERLESS> functions or by DECLAREing the atom a NOUN).

$var<DEPENDENCIES/> - atoms which have functional dependencies (set up by the
$fun<DEPENDS> or $fun<GRADEF> functions).

$var<GRADEFS/> - functions which have user defined derivatives (set up by the
$fun<GRADEF> function).

$var<PROPS/> - atoms which have any property other than those mentioned above,
such as atvalues, matchdeclares, etc. as well as properties specified in the
DECLARE function.

In addition to these information lists similar lists may be generated by
the function
.inline function(PROPVARS,prop)
which yields a list of those atoms on the PROPS
list which have the property indicated by 2prop1.  Thus PROPVARS(ATVALUE) will
yield a list of atoms which have atvalues.

.subsec (Functions for Handling MACSYMA Properties,MACSYMA!properties)


.function (DECLARE,|a1, f1, a2, f2, ...|)
gives the atom 2ai1 the flag 2fi1.  The 2ai1's and 2fi1's may also be
lists of atoms and flags respectively in which case each of the atoms gets all of the properties.  The possible flags and their meanings are:


$flag<CONSTANT> - makes 2ai1 a constant as is %PI.

$flag<NONSCALAR> - makes 2ai1 behave as does a list or matrix with respect to the dot operator. $see<dotop>

$flag<NOUN> - makes the function 2ai1 a noun so that it won't be evaluated
automatically. $see<evaluation>

$flag<ALPHABETIC> - adds 2ai1 to MACSYMA's alphabet (initially A-Z,%).
Thus, DECLARE("_",ALPHABETIC) enables  NEW_VALUE to be used as a name.

$flag<EVFUN> - makes 2ai* known to the EV function so that it will get applied if
its name is mentioned.  Initial evfuns are $fun<FACTOR>, $fun<TRIGEXPAND>,
$fun<TRIGREDUCE>, $fun<BFLOAT>, $fun<RATSIMP>, $fun<RATEXPAND>, $fun<RADCAN>,
$fun<LOGCONTRACT>, $fun<RECTFORM>, and $fun<POLARFORM>.

$flag<EVFLAG> - makes 2ai1 known to the $fun<EV> function so that it will be bound
to TRUE during the execution of EV if it is mentioned.  Initial evflags are 
$var<FLOAT/>, $var<PRED/>, $var<SIMP/>, $var<NUMER/>, $var<DETOUT/>,
$var<EXPONENTIALIZE/>, $var<DEMOIVRE/>, $var<KEEPFLOAT/>, $var<LISTARITH/>, $var<TRIGEXPAND/>, $var<SIMPSUM/>, $var<ALGEBRAIC/>, $var<RATALGDENOM/>, $var<FACTORFLAG/>, and $var<LOGEXPAND/>. 

$flag<BINDTEST> -  causes 2ai* to signal an error if it ever is used in a computation
unbound (see Chapter $ref<debugmac>).

.endfunction

.function (ARRAYINFO,a)
returns a list of information about the array 2a1.  For hashed arrays
it returns a list of "HASHED", the number of subscripts, and the subscripts of every
element which has a value.  For declared arrays it returns a list of "DECLARED", the
number of subscripts, and the bounds that were given the the ARRAY function when it
was called on 2a1.

.example
(C1) B[1,X]:1$
(C2) ARRAY(F,2,3)$
(C3) ARRAYINFO(B);

(D3)            [HASHED, 2, [1, X]]
(C4) ARRAYINFO(F);

(D4)            [DECLARED, 2, [2, 3]]
.end

.endfunction

.function (PROPERTIES,a)
will yield a list showing the names of all the properties associated with
the atom 2a1.

.endfunction

.function (PRINTPROPS,|a, i|)
will display the property with the indicator 2i1 associated with the atom
2a1. 2a1 may also be a list of atoms or the atom ALL in which case all of the atoms with the given property will be used.  For example,
PRINTPROPS([F,G],ATVALUE).     PRINTPROPS is for properties that cannot otherwise be displayed, i.e. for ATVALUE,ATOMGRAD,GRADEF, and MATCHDECLARE.

.endfunction

.function (REMOVE,|a1, p1, a2, p2, ...|)
removes the property 2pi1 from the atom 2ai1.  2Ai1 and 2pi1 may also be
lists as with DECLARE.  2Pi1 may be any property e.g. FUNCTION, MODEDECLARE, etc.  It
may also be TRANSFUN implying that the translated LISP version of the function is to
be removed.  This is useful if one wishes to have the MACSYMA version of the function
executed rather than the translated version. 2Pi* may also be OP or OPERATOR to remove a syntax extension given to 2ai* (see Appendix II).
 If 2ai1 is "ALL" then the property
indicated by 2pi1 is removed from all atoms which have it.  Unlike the more specific
remove functions (REMVALUE, REMARRAY, REMFUNCTION, and REMRULE) REMOVE does not
indicate when a given property is non-existent; it always returns "DONE".

.endfunction

.subsec (Functions for Handling Users' Properties,uspropfun)

.function (PUT,|a, p, i|)
associates with the atom 2a1 the property 2p1 with the indicator 2i1.  This
enables the user to give an atom any arbitrary property.

.endfunction

.function (QPUT,|a, p, i|)
is similar to PUT but it doesn't have its arguments evaluated.

.endfunction

.function (GET,|a, i|)
retrieves the user property indicated by 2i1 associated with atom 2a1 or
returns FALSE if 2a1 doesn't have property 2i1.

.example
.begin group
(C1) PUT(%E,TRANSCENDENTAL,TYPE);
(D1)                          TRANSCENDENTAL
.end
(C2) PUT(%PI,TRANSCENDENTAL,TYPE)$

(C3) PUT(%I,ALGEBRAIC,TYPE)$

.begin group
(C4) TYPEOF(X) := BLOCK([Q], IF NUMBERP(X) THEN RETURN(ALGEBRAIC),
                   IF NOT ATOM(X) THEN RETURN(MAPLIST(TYPEOF, X)),
                   Q : GET(X, TYPE),
                   IF Q=FALSE THEN ERROR("NOT NUMERIC") ELSE Q)$
.end

(C5) TYPEOF(2*%E+X*%PI);

.begin group
NOT NUMERIC
QUIT
(C6) TYPEOF(2*%E+%PI);
(D6)          [[ALGEBRAIC, TRANSCENDENTAL], TRANSCENDENTAL]
.end

.end
.endfunction

.function (REM,|a, i|)
removes the property indicated by 2i1 from the atom 2a1.

.endfunction

.function (NUMERVAL,|var1, exp1, var2, exp2, ...|)
declares 2vari1 to have a numerical value of 2exp11 which is evaluated and
substituted for the variable in any expressions in which the variable occurs if
the $var<NUMER/> flag is TRUE. (see the EV function, sec. $ref<evsimpfun>).

.endfunction

.chap (Pattern Matching and Related Functions,patternfun)

.sec (Type Testing Functions,typtestfun,1)

.function (ATOM,exp)
is TRUE if 2exp1 is atomic (i.e. a number or name) else FALSE.  Thus ATOM(5) is
TRUE while ATOM(A[1]) and ATOM(SIN(X)) are FALSE.  (Assuming A[1] and X are unbound.)

.endfunction

.function(SUBVARP,exp) 
is TRUE if 2exp1 is a subscripted variable, for example A[I].
.endfunction


.function (CONSTANTP,exp)
is TRUE if 2exp1 is a constant (i.e. composed of numbers and %PI, %E,
%I or any variables DECLAREd constant $see<MACSYMA!properties>  else
FALSE.  Arithmetic functions whose arguments are constant as well as functions
and arrays which are DECLAREd constant are also considered to be
constants.

.endfunction

.function (NONSCALARP,exp)
is TRUE if 2exp1 is a non-scalar, i.e. it contains atoms declared as
non-scalars $see<property!specification>, lists, or matrices.

.endfunction

.function (INTEGERP,exp)
is TRUE if 2exp1 is an integer else FALSE.
.endfunction

.function(EVENP,exp)
is TRUE if 2exp1 is an even integer.  FALSE is returned in all other cases.
.endfunction

.function(ODDP,exp)
is TRUE if 2exp1 is an odd integer.  FALSE is returned in all other cases.
.endfunction

.function (FLOATNUMP,exp)
is TRUE if 2exp1 is a floating point number else FALSE.

.endfunction

.function(BFLOATP,exp)
is TRUE is 2exp1 is a bigfloat number else FALSE.

.endfunction

.function (NUMBERP,exp)
is TRUE if 2exp1 is an integer, a rational number, a floating point number or a bigfloat
else FALSE.

.endfunction

.function (RATNUMP,exp)
is TRUE if 2exp1 is a rational number (includes integers) else FALSE.

.endfunction

.function (SYMBOLP,exp)
returns TRUE if "exp" is a "symbol" or "name", else
FALSE.  I.e., in effect, SYMBOLP(X):=ATOM(X) AND NOT NUMBERP(X)$ .

.endfunction

.function (LISTP,exp)
is TRUE if 2exp1 is a list else FALSE.

.endfunction

.function (MATRIXP,exp)
is TRUE if 2exp1 is a matrix else FALSE.

.endfunction

.function (RATP,exp)
is TRUE if 2exp1 is in CRE or extended CRE form else FALSE.

.endfunction

.function (FREEOF,|x1, x2, ..., exp|)
yields TRUE if the  2xi1 do not occur in 2exp1 and FALSE otherwise.
The x2i1 are atoms or they may be subscripted names, functions (e.g. SIN(X) ), or
operators enclosed in "s.  They may also be lists of these objects.

.example
(C1) FREEOF(Y,SIN(X+2*Y));

(D1)                    FALSE

(C2) FREEOF(COS(Y),"*",SIN(Y)+COS(X));

(D2)                          TRUE
.end
.endfunction

.sec (General Pattern Matching Functions,patmatfun,1)

The pattern matching functions permit the user to test expressions for
combinations of syntactic and semantic patterns and to automatically have variables
set to parts of expressions which fit the patterns.  This enables one to transform an
expression as well as to see if it fits a pattern.

It is also possible to add simplification rules which apply to user or system
defined functions or operators.  In order to choose the particular rule which applies,
a pattern match must usually be performed on the operands of the expression which is
to be simplified.

.function (MATCHDECLARE,|patternvar, predicate, ...|)
associates a 2predicate1 with a 2pattern1 2variable1 so that the
2variable1 will only match expressions for which the 2predicate1 is not
FALSE.  (The matching is accomplished by one of the functions described below). 
For example after MATCHDECLARE(Q,FREEOF(X,%E)) is executed, Q will match any
expression not containing X or %E.  If the match succeeds then the variable is
set to the matched expression.  The predicate (in this case FREEOF) is written
without the last argument which should be the one against which the pattern
variable is to be tested.  Note that the 2patternvar1 and the arguments to the
2predicate1 are evaluated at the time the match is performed.


The odd numbered argument may also be a list of pattern variables all of which are
to have the associated predicate.  Any even number of arguments may be given.

For pattern matching, predicates refer to functions which are either FALSE or not
FALSE (any non FALSE value acts like TRUE).

MATCHDECLARE(var,TRUE) will permit var to match any expression.

.endfunction

PRINTPROPS([2v1,v2,*...],MATCHDECLARE)
$see<MACSYMA!properties> will display the matchdeclare properties of the variables 2v1,v2,*...


.function (TELLSIMPAFTER,|pattern, replacement|)
defines a 2replacement1 for 2pattern1 which the MACSYMA
simplifier uses after it applies the built-in simplification rules.  The 2pattern1 may
be anything but a single variable or a number.

.endfunction

.function (TELLSIMP,|pattern, replacement|)
is similar to TELLSIMPAFTER but places new information
before old so that it is applied before the built-in simplification rules.  The
2pattern1 may not be a sum, product, single variable, or number.

$var<RULES/> is a list of names having simplification rules added to them by DEFRULE,
DEFMATCH, TELLSIMP, or TELLSIMPAFTER.

.example
.begin group
(C1) MATCHDECLARE([XX,A,B],TRUE);
(D1) 				     DONE

(C2) 
TELLSIMP(D[XX](A,B),B(XX)*DIFF(A(XX),X)-A(XX)*DIFF(B(XX),XX));
RULE PLACED ON SUBVAR
(D2) 			     [SUBVARRULE1, FALSE]


.end
.begin fill indent 0,0
1SUBVARRULE1 is the name assigned to the TELLSIMP rule from (C34).
.end
.begin group
(C3) D[Z](X,Y);
(D3) 			   Y(Z) X(Z)  - X(Z) Y(Z)
				    X		 Z

.end
.end scon
Another example of the use of TELLSIMP is shown in the following:
.example
(C4) 0^0;
0^0 HAS BEEN GENERATED
.end
.scon
To override such default simplification, the user can use the following paradigm:
.example
(C5) BLOCK([SIMP],SIMP:FALSE,TELLSIMP(0^0,1));

RULE PLACED ON **
(D5)                       [**RULE1, SIMPEXPT]

(C6) 0^0;
(D6)                                1

(C7) REMRULE("**","**RULE1");
(D7)				[ SIMPEXPT ]

.end

.endfunction

.function (DEFMATCH,|progname, pattern, parm1, ..., parmn|)
creates a function of n+1 arguments
with the name 2progname1 which tests an expression to see if it can match a particular
2pattern1.  The 2pattern1 is some expression containing pattern variables and
2parameters1.  The 2parms1
are given explicitly as arguments to DEFMATCH while the pattern variables (if
supplied) were given implicitly in a previous MATCHDECLARE function.  The first
argument to the created function 2progname1, is an expression to be matched against
the "2pattern1" and the other n arguments are the actual variables occurring in the
expression which are to take the place of dummy variables occurring in the
"2pattern1".  Thus the parms in the DEFMATCH are like the dummy arguments to the
SUBROUTINE statement in FORTRAN.  When the function is "called" the actual arguments are
substituted.  For example:

.example group
(C1)  NONZEROANDFREEOF(X,E):=  IF E#0 AND FREEOF(X,E)
            THEN TRUE ELSE FALSE$

.begin fill indent 0,0
(IS(E#0 AND FREEOF(X,E))1 is an equivalent function definition - see sec. $ref<MACSYMA!properties>.
.end
3
(C2)  MATCHDECLARE(A,NONZEROANDFREEOF(X),B,FREEOF(X))$
(C3)  DEFMATCH(LINEAR,A*X+B,X)$

.end

This has caused the function LINEAR(2exp,var11) to be defined.  It tests 2exp1 to
see if it is of the form A*2var11+B where A and B do not contain 2var11 and A is
not zero.  DEFMATCHed functions return (if the match is successful) a list of equations
whose left sides are the pattern variables and parms and whose right sides are the
expressions which the pattern variables and parameters matched.  The pattern variables,
but not the parameters, are set to the matched expressions.  If the match fails, the
function returns FALSE.  Thus LINEAR(3*Z+(Y+1)*Z+Y**2,Z) would return [B=Y**2, A=Y+4,
X=Z].  Any variables not declared as pattern variables in MATCHDECLARE or as
parameters in DEFMATCH which occur in 2pattern1 will match only themselves so that if
the third argument to the DEFMATCH in (C4) had been omitted, then LINEAR would only
match expressions linear in X, not in any other variable.

A pattern which contains no parameters or pattern variables returns
TRUE if the match succeeds.

.example
(C1) MATCHDECLARE([A,F],TRUE)$

(C2) CONSTINTERVAL(L,H):=CONSTANTP(H-L)$

(C3) MATCHDECLARE(B,CONSTINTERVAL(A))$

(C4) MATCHDECLARE(X,ATOM)$

(C5) BLOCK(REMOVE(INTEGRATE,OUTATIVE),
           DEFMATCH(CHECKLIMITS,'INTEGRATE(F,X,A,B),
           DECLARE(INTEGRATE,OUTATIVE))$

(C6) 'INTEGRATE(SIN(T),T,X+%PI,X+2*%PI)$

(C7) CHECKLIMITS(%);

(D7)  [B = X + 2 %PI, A = X + %PI, X = T,

                               F = SIN(T)]

(C8) 'INTEGRATE(SIN(T),T,0,X)$

(C9) CHECKLIMITS(%);

(D9)                    FALSE

.end

.endfunction

.function (DEFRULE,|rulename, pattern, replacement|)
defines and names a 2replacement1 rule for the given p2attern1.  If the rule
named 2rulename1 is applied to an expression (by one of the APPLY functions
below), every subexpression matching the 2pattern1 will be replaced by the
2replacement1.  All variables in the 2replacement1 which have been assigned
values by the pattern match are assigned those values in the 2replacement1
which is then simplified. The rules themselves can be treated as functions which
will transform an expression by one operation of the pattern match and
replacement.  If the pattern fails, the original expression is returned.

.endfunction

.function (APPLY1,|exp, rule1, ..., rulen|)
repeatedly applies the first rule to 2exp1 until it fails, then repeatedly
applies the same rule to all subexpressions of 2exp1, left-to-right, until the
first rule has failed on all subexpressions.  Call the result of transforming
2exp1 in this manner 2exp1'.  Then the second rule is applied in the same
fashion starting at the top of 2exp1'.  When the final rule fails on the final
subexpression, the application is finished.

.endfunction

.function (APPLY2,|exp, rule1, ..., rulen|)
differs from APPLY1 in that if the first rule fails on a given
subexpression, then the second rule is repeatedly applied, etc.  Only if they all fail
on a given subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same subexpression is
reprocessed, starting with the first rule.

$var<MAXAPPLYDEPTH/10000> is the maximum depth to which APPLY1 and APPLY2 will delve.

.endfunction

.function (APPLYB1,|exp, rule1, ..., rulen|)
is similar to APPLY1 but works from the "bottom up" instead of from the "top
down".  That is, it processes the smallest subexpression of 2exp1, then the
next smallest, etc.

$var<MAXAPPLYHEIGHT/10000> - is the maximum height to which APPLYB1 will reach before
giving up.

.endfunction

.sec (Pattern Matching for Rational Expressions,patmatrat,1)

.function (LETSIMP,exp)
will continually apply the substitution rules previously defined by the
function LET (see below) until no further change is made to 2exp1.

.endfunction

.function (LET,|prod, repl, predname, arg1, arg2, ..., argn|)
defines a substitution rule for LETSIMP such that 2prod1 gets replaced by
2repl1.  2prod1 is a product of positive or negative powers of the following types of terms:


(1) 2Atoms1 which LETSIMP will search for literally unless previous to calling
LETSIMP the MATCHDECLARE function is used to associate a predicate with the atom.  In
this case LETSIMP will match the atom to any term of a product satisfying the
predicate.

(2) 2Kernels1 such as SIN(X), N!, F(X,Y),  etc.  As with atoms above LETSIMP will
look for a literal match unless MATCHDECLARE is used to associate a predicate with the
argument of the kernel.

A term to a positive power will only match a term having at least that power in
the expression being LETSIMPed.  A term to a negative power on the other hand will
only match a term with a power at least as negative.  In the case of negative powers
in "product" the switch LETRAT must be set to TRUE (see below).

If a predicate is included in the LET function followed by a list of arguments,
a tentative match (i.e. one that would be accepted if the predicate were
omitted) will be accepted only if 2predname1(2arg11',...,2argn1')
evaluates to TRUE where 2argi1' is the value matched to 2argi1.  The
2argi1 may be the name of any atom or the argument of any kernel appearing in
2prod1.  2repl1 may be any rational expression.  If any of the atoms or
arguments from 2prod1 appear in 2repl1 the appropriate substitutions will be
made.

$var<LETRAT/FALSE> when FALSE, LETSIMP will simplify the numerator and
denominator of 2expr1 independently and return the result.  Substitutions such
as N!/N goes to (N-1)! will fail.  To handle such situations LETRAT should be
set to TRUE, then the numerator, denominator, and their quotient will be
simplified in that order.

These substitution functions allow you to work with several rule packages at
once. Each rule package can contain any number of LETed rules and is refered to
by a user supplied name.  To insert a rule into the rule package 2name1,  do
LET([2prod,repl,pred,arg11,...],2name1).  To apply the rules in rule package
2name1, do LETSIMP(2expr1, 2name1).  The function
LETSIMP(2expr,name1,name21,...) is equivalent to doing LETSIMP(2expr,name11)
followed by LETSIMP(%,2name21) etc.

There is a default rule package name which is
assumed when no other name is supplied to any of the functions.  Whenever a LET
includes a rule package name the default rule package is made to look like that
rule package.

SAVE and KILL of LET rules have not been implemented.

.endfunction
.function (REMLET,|prod, name|)
deletes the substitution rule, 2prod1 --> 2repl1, most recently defined by
the LET function.  If 2name1 is supplied the rule is deleted from the rule
package 2name1. REMLET() and REMLET(ALL,2name1) delete all substitution
rules from the default rule package. If 2name1 is supplied the rule package,
2name1, is also deleted.

If a substitution is to be changed using the same product, REMLET need not be
called, just redefine the substitution using the same product (literally) with the LET
function and the new replacement and/or predicate name.  Should REMLET(product) now be
called the original substitution rule will be revived.

.endfunction

.function(LETRULES,name)
and LETRULES() display the rule package 2name*, and the rules in the
default rule package, respectively.  Note that the function
LETRULES(2name*) will set the default rule package to the rule package,
2name*.

.example
(C1) MATCHDECLARE([A1,A2],TRUE)$

(C2) ONELESS(X,Y):=IS(EQUAL(X,Y-1))$

(C3) LET(A1*A2!,A1!,ONELESS,A2,A1);

(D3)         A1 A2! --> A1! WHERE ONELESS(A2, A1)

(C4) LETRAT:TRUE$

(C5) LET(A1!/A1,(A1-1)!);

.begin group
                        A1!
(D5)                    --- --> (A1 - 1)!
                        A1
.end

(C6) LETSIMP(N*M!*(N-1)!/M);

(D6)                      (M - 1)! N!

.end

.scon
The user should be aware that simplification rules for differential operators can be specified using MACSYMA's pattern-matching commands.

.endfunction


.chap ("Utility, Input-Output, and Display Functions",utility!functions)

.sec ("Debugging Functions ",debugging,1)
The functions in this section permit the user to examine his MACSYMA environment and to obtain debugging information.  Further detail is given in section 12.0.

.function (TRACE,|name1, name2, ...|)
gives a trace printout whenever the functions mentioned are
called. TRACE() prints a list of the functions currently under TRACE.

.endfunction

.function (UNTRACE,|name1, ...|)
removes tracing incurred by the TRACE function.  UNTRACE() removes tracing from all
functions.

.endfunction

.function (REMTRACE)
removes the tracing facilities from MACSYMA thus freeing up some storage.  They
will be reloaded when TRACE is used again.

.endfunction

.function (DECLARE,|[var1, var2, ...], BINDTEST|)
causes MACSYMA to give an error message whenever any of
the 2vari1 occur unbound in a computation.

.endfunction

.function (BREAK,|arg1, ...|)
evaluates and prints its arguments then enters a MACSYMA break loop.

.endfunction


.skip 2 once center
2Options and Variables
.skip 1

$var<%%/> The value of the last computation performed while in a
(MACSYMA-BREAK).  Also may be used in compound statements in the nth
statement to refer to the value of the (n-1)th statement.  E.g.
F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%)); is in essence
equivalent to F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),
SUBST(3,X,%%)-SUBST(2,X,%%));
This will also work for communicating between the (n-1)th and nth
(non-atomic) BLOCK statements.

$var<DEBUGMODE/FALSE> if TRUE causes MACSYMA to enter a MACSYMA break loop whenever a MACSYMA error occurs. If DEBUGMODE:ALL then the user may examine BACKTRACE for the list of functions currently entered.


$var<REFCHECK/FALSE> if TRUE causes a message to be printed each time a bound variable is used for the first time in a computation.

$var<PREDERROR/TRUE> - if TRUE causes a message to be printed whenever the
predicate of an IF statement or an IS function fails to evaluate to either TRUE
or FALSE.

$var<SETCHECK/FALSE> - if set to a list of variables (which can be subscripted)
will cause a printout whenever the variables, or subscripted occurrences of
them, are bound (with : or :: or function argument binding).  The printout
consists of the variable and the value it is bound to.   SETCHECK may be set to  ALL or TRUE thereby including all variables.


$var<SETCHECKBREAK/FALSE> - if set to TRUE will cause a (MACSYMA-BREAK) to
occur just prior to the binding of variables on the SETCHECK list.  At this 
point, $var<SETVAL/> holds the value to which the variable is about to be set.
Hence, one may change this value by resetting SETVAL.

$var<BACKTRACE/> (when DEBUGMODE:ALL has been done) has as value a list of all functions currently entered.
(see Chapter $ref<debugmac>).

.sec (Functions for Displaying,display!functions)

.function (DISPFUN,|f1, f2, ...|)
displays the definition of the user defined functions 2f1, f2, ...* which may
also be the names of array associated functions, subscripted functions, or
functions with constant subscripts which are the same as those used when the
functions were defined. DISPFUN(ALL) will display all user defined functions as
given on the $var<FUNCTIONS/> and $var<ARRAYS/> lists except subscripted functions
with constant subscripts.

.endfunction

.function (FUNDEF,functionname)
returns the function definition associated
with 2functionname1.  FUNDEF(2fnname1); is similar to DISPFUN(2fnname1);
except that FUNDEF does not invoke display.
.endfunction

.function (DISPRULE,rulename)
will display a rule with the name 2rulename* as was given by $fun<DEFRULE>,
$fun<TELLSIMP>, or $fun<TELLSIMPAFTER> or a pattern defined by $fun<DEFMATCH>.  For
example, the first rule modifying SIN will be called SINRULE1. (see $ref<patmatfun>)

.endfunction

.function (DISPLAY,|exp1, exp2, ...|)
displays equations whose left side is 2expi1 unevaluated, and
whose right side is the value of the expression centered on the line.  This function
is useful in blocks and FOR statements in order to have intermediate results
displayed.  The arguments to DISPLAY are usually atoms, subscripted variables, or
function calls.  (see the DISP function below.)

.example
(C1) DISPLAY(B[1,2]);

.begin group
                                      2
                         B     = X - X
                          1, 2
.end

(D1)                            DONE

.end
.endfunction

.function(LDISPLAY,|exp1,exp2,...|)
is like DISPLAY but also generates intermediate labels.

.endfunction

.function (DISP,|exp1,exp2, ...|)
is like DISPLAY but only the value of the arguments are displayed rather
than equations.  This is useful for complicated arguments which don't have names or
where only the value of the argument is of interest and not the name.

.endfunction

.function(LDISP,|exp1,exp2,...|)
is like DISP but also generates intermediate labels.

.endfunction

.function (PRINT,|exp1, exp2, ...|)
evaluates and displays its arguments one after the other "on a line"
starting at the leftmost position.  If 2expi1 is unbound or is preceded by a single
quote or is enclosed in "s then it is printed literally.  For example, PRINT("THE
VALUE OF X IS ",X).  The value returned by PRINT is the value of its last argument.
No intermediate lines are generated.

.endfunction

.function (DISPTERMS,exp)
displays its argument in parts one below the other.  That is, each term in
a sum or factor in a product is displayed separately.  This is useful if 2exp1 is too
large to be otherwise displayed.  For example if P1, P2, ... are very large
expressions then the display program may run out of storage space in trying to display
P1+P2+... all at once. However, DISPTERMS(P1+P2+...) will display P1, then below it P2,
etc.
When not using DISPTERMS, if an exponential expression is too wide to be displayed as A**B it will appear
as EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).

.endfunction

.function (REVEAL,|exp,depth|)
will display 2exp1 to the specified integer 2depth1 with
the length of each part indicated.  Sums will be displayed as
SUM(n) and products as PRODUCT(n) where n is the
number of subparts of the sum or product.  Exponentials will
be displayed as EXP.

.EXAMPLE

(C1) INTEGRATE(1/(X^3+2),X)$

(C2) REVEAL(%,2);
(D2)              PRODUCT(3) + PRODUCT(3) + PRODUCT(3)

.BEGIN GROUP
(C3) REVEAL(D1,3);
		    EXPT LOG                    EXPT LOG
(D3)              - -------- + EXPT EXPT ATAN + --------
		       6                           3

.END
.END
.endfunction
 
.function (PLAYBACK,arg)
"plays back" input and output lines.  If 2arg1=n (a number) the last n
expressions (Ci, Di, and Ei count as 1 each) are "played-back", while if 2arg1 is
omitted, all lines are.  If 2arg1=INPUT then only input lines are played back. 
If 2arg1=[m,n] then all lines with numbers from m to n inclusive are played-back.
If m=n then [m] is sufficient for arg.  2Arg1=SLOW places PLAYBACK in a slow-mode
similar to $fun<DEMO>'s (as opposed to the "fast" $fun<BATCH>). This is useful in
conjunction with $fun<SAVE> or $fun<STRINGOUT> (see below) when creating a
secondary-storage file in order to pick out useful expressions.  If 2arg1=TIME
then the computation times are displayed as well as the expressions. 
2arg1=$flag<NOSTRING>  displays  all input lines when
playing back rather than STRINGing them. If 2arg1=GRIND then the display will be in a more readable format.   One may include any number of options as in PLAYBACK([5,10],20,TIME,SLOW).

.endfunction

.function (STRING,exp)
converts 2exp1 to MACSYMA's linear notation (similar to FORTRAN's) just as if
it had been typed in and puts 2exp1 into the buffer for possible editing (in which
case 2exp1 is usually Ci)  (see sec. $ref<simpform>).  The STRING'ed expression should not be
used in a computation.

.endfunction

.function (STRINGOUT,args)
will output an expression to a file in a linear format. STRINGOUT([filespec],...,FUNCTIONS,...) puts all the user's function definitions in the specified file. $see<disk!storage>

$var<GRIND/FALSE> if TRUE will cause the $fun<STRING>, $fun<STRINGOUT>, and $fun<PLAYBACK> commands to use "grind" mode instead of "string" mode.  For PLAYBACK, "grind" mode can also be turned on (for processing input lines) by specifying GRIND as an option.


.endfunction

.function(GRIND,arg) 
prints out 2arg* in a more readable format than the STRING command. It returns a D-line as value.
.endfunction

.function(FORTRAN,exp) 
converts 2exp* into a FORTRAN linear expression in legal FORTRAN
with 6 spaces inserted at the beginning of each line,continuation
lines,and ** rather than ^ for exponentiation.  When the option
$var<FORTSPACES/FALSE> is TRUE, the FORTRAN command fills out to 80
columns using spaces.  If FORTRAN is called on a bound symbolic atom,
e.g. FORTRAN(X); where X:A*B$ has been done, then X={value of X}, e.g.
X=A*B will be generated.  In particular, if e.g. M:MATRIX(...); has
been done, then FORTRAN(M); will cause the appropriate assignment
statements to be generated

.endfunction

.function(FORTRAN,|name=matrix|)
converts a MACSYMA 2matrix* into a sequence of FORTRAN assignment
statements of the form

   2name*(i,j)=  <the ij 2matrix* element> 

(If "name" is bound, FORTRAN('name=matrix);  may be necessary.)

.endfunction

.function(DESCRIBE,|entity|)
prints outa description of 2entity*, which may be a command, switch,
flag, or concept.
.endfunction

.function (EXAMPLE,|function|)
does a DEMO of relevant examples involving 2function*.
.endfunction

.sec (Functions for Freeing Storage,freeing!storage)

.function (REMOVE,args)
will remove some or all of the properties associated with variables or
functions. $see<property!specification>

.endfunction

.function (REMFUNCTION,|f1, f2, ...|)
removes the user defined functions 2f1,f21,... from
MACSYMA.  If there is only one argument of ALL then all functions are removed.

.endfunction

.function (REMVALUE,|name1, name2, ...|)
removes the values of user variables (which can be subscripted) from the system.
If name is ALL then  the values of all user variables are removed.  Values are
those items given names by the user as opposed to those which are automatically
labeled by MACSYMA as Ci, Di, or Ei.

.endfunction

.function (REMARRAY,|name1, name2, ...|)
removes arrays and array associated functions and frees the
storage occupied.  If name is ALL then all arrays are removed.  It may be necessary to
use this function if it is desired to redefine the values in a hashed array.

.endfunction

.function (REMRULE,|function, rulename|)
will remove a rule with the name 2rulename1 from the 2function1 which was
placed there by $fun<DEFRULE>, $fun<DEFMATCH>,  $fun<TELLSIMP>, or
$fun<TELLSIMPAFTER>.  If 2rule-name1 is ALL, then all rules will be removed. (see
example in $ref<patmatfun>)

.endfunction

.function (KILL,|arg1, arg2, ...|)
eliminates its arguments from the MACSYMA system.  If 2argi1 is a variable
(including a single array element), function, or array, the designated item with
all of its properties is removed from core. If 2argi1=LABELS then all input,
intermediate, and output lines to date (but not other named items) are
eliminated. If 2argi1=CLABELS then only input lines will be eliminated;  if 2argi1=ELABELS then only intermediate E-lines will be eliminated; if 2argi1=DLABELS only the output lines will be eliminated.
 If 2argi1 is the name of any of the other information lists (the elements of the MACSYMA variable $var<INFOLISTS/>), then every item in that class (and its properties) is
KILLed and if 2argi1=ALL then every item on every information  list
previously defined as well as LABELS is KILLed.  If 2argi1=a number (say n),
then the last n lines (i.e. the lines with the last n line numbers) are deleted.
If 2argi1 is of the form [m,n] then all lines with numbers between m and n
inclusive are killed. Note that KILL(VALUES) or KILL(variable) will not freeup
the storage occupied unless the labels which are pointing to the same
expressions are also KILLed.  Thus if a large expression was assigned to X on
line C7 one should do KILL(D7) as well as KILL(X) to release the storage
occupied.


KILL(ALLBUT(2name1,...,namek*)) will do a KILL(ALL) except it will not KILL the names specified.  (Note:  name2i1 means a name such as U, V, F, G,
not an infolist such as FUNCTIONS.)

.begin turn on ""
KILL removes all properties from the given argument; thus KILL(VALUES) will kill all properties associated with every item on the VALUES list.   KILL always returns the value "DONE" even if the named item doesn't exist $see<property!specification>.

The "REMOVE" functions ($fun<REMVALUE>,$fun<REMFUNCTION>, $fun<REMARRAY>,$fun<REMRULE>) remove a specific property.  These functions return a list of names or FALSE (if the specific argument doesn't exist).
.end
MACSYMA options may not be KILLed.  The user may do RESET() $see<miscfun> to reset MACSYMA options to their default values.


The error message "NO CORE - FASLOAD" results when either too many FASL files have been loaded in or when allocation level has gotten too high.   Note that 
once this occurs,  KILLing expressions will not help.  In either of these cases, no amount of killing will cause the size of these spaces to decrease.  Killing expressions only causes some spaces to get emptied out but not made smaller.

.endfunction

.sec (Functions Which Reference Disk Files,disk!storage)

.function (FILEDEFAULTS,)
returns the current default file specification for the commands LOADFILE,
BATCH, DELFILE, and DEMO.
.endfunction

.function (LOADFILE,|fn1, fn2, DSK, directory|)
loads a file as designated by its arguments.  This function may be
used to bring back quantities that were stored from a prior MACSYMA
session by use of the SAVE or STORE functions.  If 2DSK1 and
2directory1 are omitted then the last directory seen (initially the
same as the user's login name or USERS if the user has no file
directory) will be used.  If 2DSK1 and 2directory1 are omitted,
2fn21 may also be omitted if 2fn11 > is to be loaded in (where >
follows the conventions of ITS's file system).  2Fn11 2fn21 must
be a file of LISP functions and expressions, not of MACSYMA command
lines, in which case BATCH or DEMO is to be used.  (See Chapter
$ref<batchap>).

.endfunction

.function (DELFILE,|file-specification|)
will delete the file given by the 2file-specification1.
.endfunction

.function (BATCH,|file-specification|)
reads in and evaluates MACSYMA command lines from a file. (see Chapter $ref<batchap>).

.endfunction

.function (DEMO,|file-specification|)
same as BATCH but pauses after each command line and continues when a space is typed.
(see Chapter $ref<batchap>).

.endfunction

.function (BATCON,argument)
continues BATCHing in a file which was interrupted $see<batconfun>.

.endfunction

.function (BATCHLOAD,|file-specification|)
Batches in the file silently without
terminal output or labels.  (See Chapter $ref<batchap>).

.endfunction

.function (WRITEFILE,|DSK, directory|)
opens a file for writing.  All interaction
between the user and MACSYMA is then recorded in this file, just as it
is on the console.  Such a file is a transcript of the session, and is
not reloadable or batchable into MACSYMA again.  See the CLOSEFILE command below for more information. 

.endfunction

.function (APPENDFILE,|filename1, filename2, DSK, directory|)
is like WRITEFILE(DSK,2directory1) but appends
to the file whose name is specified by the first two arguments.
A subsequent CLOSEFILE will delete the original file and
rename the appended file.

.endfunction

.function (CLOSEFILE,|filename1, filename2|)
closes a file opened by WRITEFILE and gives it the name
2filename11 2filename21.  Thus to save a file consisting of the display of all
input and output during some part of a session with MACSYMA the user issues a WRITEFILE,
transacts with MACSYMA, then issues a CLOSEFILE.
The user can also issue the PLAYBACK function after a WRITEFILE to save the
display of previous transactions.  (Note that what is saved this way is a copy
of the 2display1 of expressions not the expressions themselves).  To save the
actual expression in internal form the SAVE function may be used.  The
expression can then be brought back into MACSYMA via the LOADFILE function.  To
save the expression in a linear form which may then be BATCHed in later, the
STRINGOUT function is used. (see below)

.endfunction

.function (STRINGOUT,|file-specification, A1, A2, ...|)
outputs to a file given by 2file-specification1
([filename1,filename2,DSK, directory]) the values given by 2A1,A21,.. in a
MACSYMA readable format.  The 2file-specification1 may be omitted, in which
case the default values will be used. (see $ref<autostor> - C)  The 2Ai1 are
usually C labels or may be INPUT meaning the value of all C labels.   Another option is to make 2Ai1 FUNCTIONS which will cause all of the user's function definitions to be strungout (i.e. all those retrieved by DISPFUN(ALL)). 2Ai1 may
also be a list [m,n] which means to stringout all labels in the range m through
n inclusive.  This function may be used to create a file of FORTRAN statements
by doing some simple editing on the strungout expressions.  Alternatively, the
function $fun<FORTRAN> can be used  $see<display!functions>

.endfunction

.function (SAVE,args)
saves quantities described by its arguments on disk and keeps them in core
also. $see<explicitstor>.

.endfunction

.function (STORE,args)
same as SAVE but doesn't retain quantities in core. $see<explicitstor>.

.endfunction

.function(FASSAVE,args)
is similar to SAVE but produces a FASL file in which the sharing of subexpressions which are shared in core is preserved in the file created.  Hence, expressions which have common subexpressions will consume less space when loaded back from a file created by FASSAVE rather than by SAVE.

.endfunction


.function (UNSTORE,|name1, ...|)
brings the named expressions into core that were stored away by use of
the STORE function in the current MACSYMA. $see<explicitstor>.

.endfunction

.function (RESTORE,|file-specification|)
reinitializes all quantities filed away by a use of the SAVE
or STORE functions, in a prior MACSYMA session, from the file given by
2file-specification1 without bringing them into core. $see<savmacsym>.

.endfunction

.function(REMFILE)
removes files created by the secondary storage scheme in the MACSYMA under use
$see<autostor>.  REMFILE(ALL) does what REMFILE() does and in addition deletes
any files which have been created by the SAVE or STORE functions but which have not
been assigned names by the user.

.endfunction

.sec (Ordering Functions,ordering!functions,1)

Aside from declaring a variable to be constant or using options like POWERDISP (see below), the
only other way in which a user can alter the ordering of parts of an expression is to
set up special aliases for variables which cause them to be alphabetically less than
or greater than any other variables.  Functions which do this are described below.
This technique requires care because although the names have been aliased, they
display with their original name.  Aside from the input/output phase the two names
represent two different symbols and thus expressions which contain both the original
name and the alias will not be simplified as the user desires.  This is shown in the
examples below.

.function (ORDERGREAT,|V1, ..., Vn|)
sets up aliases for the variables 2V1, ..., Vn* such that
.bcon
2V1* > 2V2* > ... > 2Vn* > any other variable not mentioned as an argument.

.endfunction


.function (ORDERLESS,|V1, ..., Vn|)
sets up aliases for the variables 2V1, ..., Vn* such that
.bcon
2V1* < 2V2* < ... < 2Vn* < any other variable not mentioned as an argument. 

.endfunction
.begin group
.skip
 Thus the complete ordering scale is:
.skip
.once center
numerical constants < declared constants < 
.skip
.once center
< first argument to ORDERLESS < ... < last argument to ORDERLESS < 
.skip
.once center
< variables which begin with A < ... < variables which begin with Z < 
.skip
.once center
< last argument to ORDERGREAT < ... < first argument to ORDERGREAT.
.end
.function(ORDERGREATP,|exp1,exp2|)
returns TRUE  if  2exp21  precedes  2exp11 in the ordering induced by the variable ordering described above.
.endfunction

.function(ORDERLESSP,|exp1,exp2|)
returns TRUE if 2exp11 precedes 2exp21 in the ordering induced by the variable ordering described above.
.endfunction

.function (UNORDER)
removes the aliases created by the last use of the above ordering commands.
ORDERGREAT and ORDERLESS may not be used more than one time each without calling
UNORDER.

.example
(C1) A**2+B*X;
.begin group
                                        2
(D1)                             B X + A
.end

(C2) ORDERGREAT(A);
(D2)                               DONE

(C3) A**2+B*X;
.begin group
                                  2
(D3)                             A  + B X
.end

(C4) %-D1;
.begin group
                                  2    2
(D4)                             A  - A
.end

(C5) UNORDER();
(D5)                               [A]

.end
.endfunction

.function(SORT,|list,optional-predicate|)
sorts the 2list1 using a suitable 2optional-predicate1 of two arguments
 (such as "<" or ORDERLESSP).  If the 2optional-predicate1 is not given, then MACSYMA's built-in ordering predicate is used.  
.endfunction

.begin group
.sec (Miscellaneous Functions,miscfun)

.function (TIME,|Di1, Di2, ...|)
gives a list of the times in milliseconds taken to compute the 2Di1.

.endfunction
.end
.function (LOGOUT)
causes the user to be logged out and all jobs deleted.  This is useful when it is
desired to BATCH in a file and have the terminal logged out automatically when the
computations are finished.  (Equivalent to ^Z and :LOGOUT)

.endfunction

.function (QUIT)
kills the current MACSYMA but doesn't affect the user's other jobs.  (Equivalent to ^Z and :KILL).

.endfunction

.function (READ,|string1, ...|)
prints its arguments, then reads in and evaluates one expression.  For
example:  A:READ("ENTER THE NUMBER OF VALUES").

.endfunction

.function(READONLY,|string1,...|)
prints its arguments, then reads in an expression (which in contrast to READ is not evaluated).
.endfunction

.function (DEFINE,|f(x1, ...), body|)
is equivalent to f(x1,...):=''body but when used inside functions it happens at
execution time rather than at the time of definition of the function which contains it.  $see<evaluation>

.endfunction

.function (LOCAL,|v1, v2, ...|)
causes the variables 2v1,v2,...1 to be local with respect to all the properties
in the statement in which this function is used $see<program!blocks>.  LOCAL may only be used
in BLOCKs, in the body of function definitions or LAMBDA expressions, or in the EV
function and only one occurrence is permitted in each.

.endfunction

.function (ERROR,|arg1, arg2, ...|)
will evaluate and print its arguments and then will cause an error return to top
level MACSYMA or to the nearest enclosing ERRCATCH.  This is useful for breaking out of nested functions if an error
condition is detected, or wherever one can't type control-G.

$var<ERRORFUN/FALSE> - if set to the name of a function of no arguments will cause
that function to be executed whenever an error occurs.  This is useful in BATCH files
where the user may want his MACSYMA killed or his terminal logged out if an error
occurs.  In these cases ERRORFUN would be set to QUIT or LOGOUT.

.endfunction

.function (ERRCATCH,|exp1, exp2, ...|)
evaluates its arguments one by one and returns a list of the value of the last
one if no error occurs.  If an error occurs in the evaluation of any arguments,
ERRCATCH "catches" the error and immediately returns [] (the empty list).  This
function is useful in BATCH files where one suspects an error might occur which
would otherwise have terminated the BATCH if the error weren't caught.

.endfunction

.function(CATCH,|exp1,...,expn|)
evaluates its arguments one by one; if the structure of the 2expi1 leads to the evaluation of an expression of the form THROW(arg),  then the value of the CATCH is the value of THROW(arg).  This  "non-local return"  thus goes through any depth of nesting to the nearest enclosing CATCH.  There must be a CATCH corresponding to a THROW, else an error is generated.     
If the evaluation of the 2expi1 does not lead to the evaluation of any THROW then the value of the CATCH is the value of  2expn1.  

.example

(C1) G(L):=CATCH(MAP(LAMBDA([X],
       IF X<0 THEN THROW(X) ELSE F(X)),L))$

(C2) G([1,2,3,7]);
(D2) 			 [F(1), F(2), F(3), F(7)]

(C3) G([1,2,-3,7]);
(D3) 				    - 3

.end

The function G returns a list of  F of each element of L  if  L consists only of non-negative numbers; otherwise, G "catches"  the first negative element of L and "throws" it up.

.endfunction

.function(THROW,exp)
evaluates  2exp1 and throws the value back to the most recent CATCH.  THROW is used with CATCH as a structured nonlocal exit mechanism.

.endfunction

.function (BREAK,|arg1, ...|)
will evaluate and print its arguments and will then cause a
(MACSYMA-BREAK) at which point the user can examine and change his environment.  Upon
typing EXIT; the computation resumes. (see Chapter $ref<debugmac>)

.endfunction

.function(RESET)
causes all MACSYMA options to be set to their default values.  (Please note that this does not include features of terminals such as LINEL which can only be changed by assignment as they are not considered to be computational features of MACSYMA.)

.endfunction

.function (%TH,i)
is the 2i1th previous computation.  That is, if the next expression to be computed is
D(j) this is D(j-2i1).  This is useful in BATCH files or for referring to a group of D
expressions.  For example, if SUM is initialized to 0 then FOR I:1 THRU 10 DO
SUM:SUM+%TH(I) will set SUM to the sum of the last ten D expressions.

.endfunction

.function (CONCAT,|arg1, arg2, ...|)
evaluates its arguments and returns the concatenation of their
values resulting in a name or a quoted string (see $ref<names> and $ref<quoted!strings>) the type being given
by that of the first argument.  Thus if X is bound to 1 and D is unbound then
CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.

.endfunction

.function (GETCHAR,|a, i|)
returns the 2i1th character of the
quoted string or atomic name 2a1.  This function is useful
in manipulating the LABELS list.

.endfunction

.function (STATUS,arg)
will return miscellaneous status information about the user's MACSYMA
depending upon the 2arg1 given.  Permissible arguments and results are as follows:

.skip 1
.begin preface 0
TIME - the time used so far in the computation.

DAY - the day of the week.

DATE - a list of the year, month, and day.

DAYTIME - a list of the hour, minute, and second.

RUNTIME - accumulated cpu time times the atom "MSEC".

REALTIME -the real time (in sec) elapsed since the user started up his MACSYMA.

WRITEFILE - a list of the device and username for the current writefile or an empty
list if no WRITEFILE has been done.

LOADFILE - a list of the first file name, second file name, device, and username for
the current BATCH, DEMO, or LOADFILE function.

FILE - a list of the current first file name and second file name.

UNIT - a list of the current device and username.

.end
.endfunction

.function (ALARMCLOCK,|arg1, arg2, arg3|)
will execute the function of no arguments whose name is 2arg31 when the time
specified by 2arg11 and 2arg21 elapses.  If 2arg11 is the atom "TIME" then
2arg31 will be executed after 2arg21 seconds of real-time has elapsed while
if 2arg11 is the atom "RUNTIME" then 2arg31 will be executed after 2arg21
milliseconds of cpu time. If 2arg21 is negative then the 2arg11 timer is shut
off.

.endfunction


.function(LABELS,char)
takes a char C,D,or E as arg and generates a list of all C-labels,D-labels, or E-labels, respectively.  (If you've generated many E-labels via SOLVE, then FIRST(REST(LABELS(C))); reminds you what the last C-label was.)

.endfunction

.function(ALIAS,|newname1, oldname1, newname2, oldname2, ...|) 
provides an alternate name for a (user or system) function, variable, array,
etc.  Any even number of arguments may be used.  Nouns are handles via aliases.

.endfunction



.sec(|Options and Variables for I/O, Status, and Display|,ioptions,1)

.skip 1
$var<GRIND/FALSE> if TRUE will cause the $fun<STRING>, $fun<STRINGOUT>, and $fun<PLAYBACK> commands to use "grind" mode instead of "string" mode.  For PLAYBACK, "grind" mode can also be turned on (for processing input lines) by specifying GRIND as an option.

$var<SHOWTIME/FALSE> - if TRUE causes MACSYMA to print the cpu time taken by each
computation. This figure does not include I/O time except in the case of the
time given at the end of running a batch file.  By setting SHOWTIME:ALL, in addition to the cpu time MACSYMA now also prints out (when not zero) the amount of time spent in garbage collection (gc) in the course of a computation.  This time is of course included in the time printed out as "Total time=" .

(It should be noted that since the "time=" time only includes computation time and not any intermediate display time, and since it is difficult to ascribe "responsibility" for  gc's,  the gctime printed will include all gctime incurred in the course of the computation and hence may in rare cases even be larger than "time=").

$var<LASTTIME/>  - the time to compute the last expression in milliseconds presented as a list of "time" and "gctime" .

$var<OPTIONSET/FALSE> - if TRUE, MACSYMA will print out a message whenever a
MACSYMA option is reset.  This is useful if the user is doubtful of the spelling
of some option and wants to make sure that the variable he assigned a value to
was truly an option variable.

$var<NOLABELS/FALSE> - if TRUE then no labels will be bound except for E lines
generated by the solve functions (sect. 6.3).  This is most useful in the "BATCH"
mode where it eliminates the need to do KILL(LABELS) in order to free up
storage.

$var<CURSORDISP/TRUE> - if TRUE, causes expressions to be drawn by
the displayer in logical sequence.  This only works with a console
which can do cursor movement.  If FALSE, expressions are simply
printed line by line.  CURSORDISP is FALSE when a WRITEFILE is in
effect.

$var<BFTRUNC/TRUE> causes trailing zeroes in non-zero bigfloat numbers not to be displayed.  Thus, if BFTRUNC:FALSE, BFLOAT(1); displays as 1.000000000000000B0. Otherwise, this is displayed as 1.0B0.

$var<EXPTDISPFLAG/TRUE> - if TRUE, MACSYMA displays expressions with negative
exponents using quotients e.g., X**(-1) as 1/X.

$var<%EDISPFLAG/FALSE> - if TRUE, MACSYMA displays %E to a negative exponent as
a quotient, i.e. %E^-X as 1/%E^X.

$var<SQRTDISPFLAG/TRUE> - if FALSE causes SQRT to display with exponent 1/2.

$var<PFEFORMAT/FALSE> - if TRUE will cause rational numbers to display in a
linear form and denominators which are integers to display as rational number
multipliers.


$var<DISPFLAG/TRUE> - if set to FALSE within a BLOCK $see<program!blocks> will
inhibit the display of output generated by the solve functions $see<SOLVE> called
from within the BLOCK.  Termination of  the BLOCK with a dollar sign, $, sets DISPFLAG to FALSE.

$var<LOADPRINT/TRUE> -  governs the printing of messages accompanying loading of files.  The following options are available: TRUE means always print the message; 'LOADFILE means print only when the LOADFILE command is used; 'AUTOLOAD means print only when a file is automatically loaded in (e.g. the integration file SIN FASL); FALSE means never print the loading message.


$var<NOUNDISP/FALSE> - if TRUE will cause NOUNs to display with a single quote.
This switch is always TRUE when displaying function definitions.

$var<POWERDISP/FALSE> - if TRUE will cause sums to be displayed with their
terms in the reverse order.  Thus polynomials would display as truncated
power series, i.e., with the lowest power first.

$var<BOTHCASES/FALSE> - if TRUE will cause MACSYMA to retain lower case text as well as upper case. Note, however, that the names of any MACSYMA special variables or functions must be typed in upper case.

$var<STARDISP/FALSE> - if TRUE will cause multiplication to be displayed explicitly with an  * between operands.

$var<DSKGC/FALSE> - if TRUE will cause user defined values, functions, arrays, and line labelled expressions to be automatically stored on disk whenever the system determines that the available in-core space is getting low (see also $ref<autostor>).

$var<LABELS/> - a list of C, D, and E lines which are bound.

$var<INCHAR/C> - the alphabetic prefix of the names of expressions typed by the
user.

$var<LINECHAR/E> - the alphabetic prefix of the names of intermediate displayed
expressions.

$var<OUTCHAR/D> - the alphabetic prefix of the names of outputted expressions.

$var<LINENUM/> - the line number of the last expression.

$var<PROMPT/_> is the prompt symbol of the DEMO function,
PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).  (see chapter $ref<debugmac>).

$var<CURSOR/$> is the prompt symbol of the MACSYMA editor.  (see chapter
$ref<macedit>).

$var<PAGEPAUSE/TRUE> - if set to FALSE will turn off the --More-- processing
for a display terminal.

$var<GENINDEX/I> -the alphabetic prefix of the index of summation for generated
sums. (The values of GENINDEX and of the above four variables may be any number
of characters though the default is a single character.)

$var<IBASE/10> - the base for inputting numbers.

$var<BASE/10> - the base for display of numbers.

$var<LINEL/> - the length of the printed line on the terminal.  Also used for
plotting (see Chapters $ref<simplot> and $ref<plot2>).

$var<PLOTHEIGHT/> - the height of the area used for plotting (see Chapters $ref<simplot> and $ref<plot2>).

$var<VERSION/267> - is the version number of MACSYMA.  This could be useful if
the user wants to label his output.

$var<INFOLISTS/> is the list of all the information lists which are in MACSYMA:
.skip 
.begin nofill
[LABELS,VALUES,FUNCTIONS,ARRAYS,MYOPTIONS,PROPS,ALIASES,RULES,
			GRADEFS,DEPENDENCIES]
.end
.skip
Initially, all these information lists are empty.  As the user proceeds with his computation, he may examine these lists when necessary.


.next page
.sec ( Functions for Translation and Compilation,compilation,1)

.function (MODEDECLARE,|y1, mode1, y2, mode2, ...|)
is used to declare the modes of variables and functions for subsequent
translation or compilation of functions. Its arguments are pairs
consisting of a variable yi, and a mode which is one of BOOLEAN,
FIXNUM, NUMBER, RATIONAL, or FLOAT.  Each 2yi* may also be a list of variables
all of which are declared to have 2modei*.

.scon
If 2yi* is an array, and if every element of the array which is
referenced in the function has a value then ARRAY(2yi*, COMPLETE,
d1, d2, ...) rather than ARRAY(2yi*, d1, d2, ...) should be used
when first declaring the bounds of the array. If all the elements of
the array are of mode FIXNUM (FLOAT), use FIXNUM (FLOAT) instead of
COMPLETE.  Also if every element of the array is of the same mode, say
2m*, then MODEDECLARE(COMPLETEARRAY(2yi*),2m*)) should be used
for efficient translation.  Also numeric code using arrays can be made
to run faster by declaring the expected size of the array, as in:
.scon
.once center
MODEDECLARE(COMPLETEARRAY(A[10,10]),FLOAT)
.scon
for a floating point number array which is 10 x 10.

Additionally one may declare the mode of the result of a function by using
FUNCTION(F1,F2,...) as an argument;  here 2F1,F2,...1 are the names of functions.  For example the expression,
.scon
MODEDECLARE([FUNCTION(F1,F2,...),X],FIXNUM,Q,COMPLETEARRAY(Q),FLOAT) 
.scon
declares that X and the values returned by F1,F2,... are single-word
integers and that Q is an array of floating point numbers.
MODEDECLARE is used either immediately inside of a function definition
(see below) or at top-level for global variables.

.endfunction

.begin turn on ""
.function(OPTIMIZE,exp)
returns an expression that produces the same value and
side effects as 2exp1 but does so more efficiently by avoiding the recomputation of common subexpressions.  OPTIMIZE also has the side effect of "collapsing" its argument so that all common subexpressions are shared.
.example
.begin group
(C1) DIFF(%,X,2);

			2	     2		    2		 2
	       2   Y + X        Y + X	       Y + X	    Y + X
	    4 X  %E	    2 %E	 4 X %E	        2 %E
(D1) 	    ------------- + ---------- - ------------ + ----------
		Y + X	      Y + X		  2	        3
					   (Y + X)	 (Y + X)
.end
(C2) OPTIMIZE(%);
.begin group
					       2	 Y + T2	 
(D2) BLOCK([T1, T2, T3, T4], T1 : Y + X, T2 : X , T3 : %E      ,  
								 

                     1				4 X T3	 2 T3
   		T4: --,	 4 T2 T4 T3 + 2 T4 T3 - ------ + ----)
                    T1				   2	   3
						 T1	 T1

.end
.end
.endfunction
.end


.function (TRANSLATE,|f1, f2, ...|)
 translates the user defined functions 2f1,f21,... from the MACSYMA
language to LISP (i.e. it makes them EXPRs).  This results in a gain in speed when
they are called.  The functions should include a call to MODEDECLARE at the beginning
when possible in order to produce more efficient code.  For example:
.example
    F(X1,X2,...):=BLOCK([v1,v2,...],MODEDECLARE(v1,mode1,v2,mode2,...),...)
.end
.scon
where the X1,X2,... are the parameters to the function and the v1,v2,... are the local
variables.  The names of translated functions are added to the PROPS lists $see<property!specification>.  Functions
should not be translated unless they are fully debugged.

TRANSLATE(FUNCTIONS) or TRANSLATE(ALL)  means translate all functions.

$var<TRANSLATE/FALSE> - If TRUE, causes automatic translation of a user's function to LISP.  Note that translated functions may not run identically to the way they did
before translation as certain incompatabilities may exist between the LISP and MACSYMA
versions.  Principally, the RAT function with more than one argument and the RATVARS
function $see<rational!functions> should not be used if any variables are MODEDECLAREd CRE.

$var<SAVEDEF/TRUE> - if TRUE will cause the MACSYMA version of a user function to
remain when the function is TRANSLATEd.  This permits the definition to be displayed
by DISPFUN and allows the function to be edited.  If SAVEDEF is FALSE, the names of translated functions are removed from the FUNCTIONS list.

$var<TRANSRUN/TRUE> - if FALSE will cause the interpreted version of all
functions to be run (provided they are still around) rather than the translated
version.

$var<TRANSBIND/TRUE> - if TRUE removes global declarations in the local context.  This applies to variables which are formal parameters to functions.


One can translate functions stored in a file by giving TRANSLATE an argument
which is a file specification.  This is a list of the form [fn1,fn2,DSK,dir]
where fn1 fn2 is the name of the file of MACSYMA functions, and dir is the name
of a file directory.

Such a file may contain declarations involving DECLARE,MODEDECLARE, or MATCHDECLARE in addition to the function definitions.  The file should not use %, since  %  is not maintained when the translated file is loaded.

TRANSLATE will return DONE  when translation is accomplished.  In the case of a file translation, the file containing the translated  code is named fn1 LISP on the disk directory  dir.
This file of LISP code may be read into MACSYMA by using the $fun<LOADFILE> function $see<disk!storage>.
.endfunction

.function(COMPFILE,|[filespec],f1,f2,...|)
will translate MACSYMA function definitions (if necessary) and write out
MACSYMA function definitions and other expressions into a disk file which
can be read into the compiler. The 2filespec* (optional) specifies the
file to be written.  The default for users with a directory is CMPFIL > and
the standard MACSYMA default file for other users.  The file written contains
declarations used by the compiler.  When $var<COMPGRIND/FALSE> is TRUE the
function definitions are pretty-printed.
The remaining arguments are atomic function names.
.endfunction


.chap(Tensor Manipulation,tensors)

.sec(|Tensor Manipulation Programs- Introduction|,compontenfuyn)

MACSYMA implements symbolic tensor manipulation of two distinct types: 5component* tensor manipulation and 5indicial* tensor manipulation.  

5Component* tensor manipulation means that geometrical tensor objects are represented as arrays or matrices. Tensor operations such as contraction or covariant differentiation are carried out by actually summing over repeated (dummy) indices with DO statements. That is, one explicitly performs operations on the appropriate tensor components stored in an array or matrix.

5Indicial* tensor manipulation is implemented by representing tensors as functions of their covariant, contravariant and derivative indices. Tensor operations such as contraction or covariant differentiation are performed by manipulating the indices themselves rather than the components to which they correspond.

These two approaches to the treatment of differential, algebraic and analytic processes in the context of Riemannian geometry have various advantages and disadvantages which reveal themselves only through the particular nature and difficulty of the user's problem.  However, one should keep in mind the following characteristics of the two implementations:

2Component Tensor Manipulation* (CTENSR)

.begin narrow 4,5

i) The representation of tensors and tensor operations explicitly in terms of their components makes CTENSR easy to use. Specification of the metric and the computation of the induced tensors and invariants is straightforward.

ii) Although all of MACSYMA's powerful simplification capacity is at hand, a complex metric with intricate functional and coordinate dependencies can easily lead to expressions whose size is excessive and whose structure is hidden. In addition, many calculations involve intermediate expressions which swell causing programs to terminate before completion. Through experience, a user can avoid avoid many of these difficulties.

.end

2Indicial Tensor Manipulation* (ITENSR)

.begin narrow 4,5

i) Because of the special way in which tensors and tensor operations are represented in terms of symbolic operations on their indices, expressions which in the 2component* representation would be unmanageable can sometimes be greatly simplified by using the special routines for symmetrical objects in ITENSR. In this way the structure of a large expression may be more transparent.

ii) On the other hand, because of the the special indicial representation in ITENSR, in some cases the user may find difficulty with the specification of the metric, function definition, and the evaluation of differentiated "indexed" objects. 
.end


These two tensor manipulation packages, CTENSR and ITENSR, are available to the MACSYMA user on the TENSOR directory.  To use the functions in these files, the user can load them in by doing

LOADFILE(CTENSR,FASL,TENSOR); --- for component tensor manipulation.

LOADFILE(ITENSR,FASL,TENSOR); --- for indicial tensor manipulation


Both of these packages enable the user to specify a metric and compute the basic geometrical objects of interest.  These routines were written primarily for research in gravitation theory.  However, they can also be of use in other areas of physics where Riemannian geometry is applied owing to their generality.

.next page
.sec(|Component Tensor Manipulation- Basic Functions|,compontenfuun)

To use CTENSR the user does LOADFILE(CTENSR,FASL,TENSOR). The basic function is called
.function(TSETUP,)
which automatically loads the CTENSR package from within MACSYMA (if it is not already loaded) and then prompts the user to make use of it. The user is first asked to specify the dimension of the manifold. If the dimension is 2, 3 or 4 then the list of coordinates defaults to [X,Y], [X,Y,Z] or [X,Y,Z,T] respectively. These names may be changed by assigning a new list of coordinates to the variable OMEGA (described below) and the user is queried about this. Care must be taken to avoid the coordinate names conflicting with other object definitions. Next, the user enters the metric either directly or from a file by specifying its ordinal position. As an example of a file of common metrics, see TENSOR;METRIC FILE. The metric is stored in the matrix LG. Finally, the metric inverse is computed and stored in the matrix UG. One has the option of carrying out all calculations in a power series.
.skip
A sample protocol is begun below for the static, spherically symmetric metric (standard coordinates) which will be applied to the problem of deriving Einstein's vacuum equations (which lead to the Schwarzschild solution) as an example. Many of the functions in CTENSR will be displayed for the standard metric as examples.
.example
.begin group
(C2) TSETUP();
Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
N;
Do you want to
1. Enter a new metric?
2. Enter a metric from a file?
3. Approximate a metric with a Taylor series?
Enter 1, 2 or 3 
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
.end
.skip
.begin group
Row 1 Column 1:  A;

Row 2 Column 2:  X^2;

Row 3 Column 3:  X^2*SIN(Y)^2;

Row 4 Column 4:  -D;
.end
.skip
.begin group
Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
DEPENDS([A,D],X);
Do you wish to see the metric? 
Y;
			  [ A  0       0        0  ]
			  [			   ]
			  [     2		   ]
			  [ 0  X       0        0  ]
			  [ 			   ]
			  [	    2	 2	   ]
			  [ 0  0   X  SIN (Y)   0  ]
			  [			   ]
			  [ 0  0       0       - D ]

Do you wish to see the metric inverse? 
N;
.end
.end
.endfunction

.skip
The other functions and features in CTENSR are now listed below.

.function(CHRISTOF,arg)
computes the Christoffel symbols of both kinds.  The 2arg* determines which results are to be immediately displayed.   The Christoffel symbols of the first and second kinds are stored in the arrays LCS[i,j,k] and MCS[i,j,k] respectively and defined to be symmetric in the first two indices. If the argument to CHRISTOF is LCS or MCS then the unique non-zero values of LCS[i,j,k] or MCS[i,j,k], respectively, will be displayed. If the argument is ALL then the unique non-zero values of LCS[i,j,k] and MCS[i,j,k] will be displayed.  If the argument is FALSE then the display of the elements will not occur. The array elements MCS[i,j,k] are defined in such a manner that the final index is contravariant. For the standard metric one has:
.example
.begin group
.end
.skip
.begin group
(C3) CHRISTOF(MCS);
					    A
					     X
(E3) 			       MCS	  = ---
				  1, 1, 1   2 A
.end
.skip
.begin group
					     1
(E4) 			        MCS	   = -
				   1, 2, 2   X
.end
.skip
.begin group
					     1
(E5) 			        MCS	   = -
				   1, 3, 3   X
.end
.skip
.begin group
					    D
					     X
(E6) 			       MCS	  = ---
				  1, 4, 4   2 D
.end
.skip
.begin group
					      X
(E7) 			       MCS	  = - -
				  2, 2, 1     A
.end
.skip
.begin group
					  COS(Y)
(E8) 			     MCS        = ------
				2, 3, 3	  SIN(Y)
.end
.skip
.begin group
					       2
					  X SIN (Y)
(E9) 			   MCS	      = - ---------
			      3, 3, 1	      A
.end
.skip
.begin group
(E10) 			 MCS	    = - COS(Y) SIN(Y)
			    3, 3, 2
.end
.skip
.begin group
					    D
					     X
(E11) 			       MCS	  = ---
				  4, 4, 1   2 A
.end
.end
.endfunction

.function2 DIAGMETRIC
if TRUE causes special routines to compute all geometrical objects (which contain the metric tensor explicitly) by taking into consideration the diagonality of the metric. Reduced run times will, of course, result. Note: this option is set automatically by TSETUP if a diagonal metric is specified.
.endfunction

.function2 DIM
is the dimension of the manifold with the default 4. The command DIM : N will reset the dimension to any other integral value.
.endfunction

.function(EINSTEIN,dis)
computes the mixed Einstein tensor after the Christoffel symbols and Ricci tensor have been obtained.  If the argument 2dis* is TRUE, then the non-zero values of the mixed Einstein tensor G[i,j] will be displayed where j is the contravariant index. $var<RATEINSTEIN/TRUE> if TRUE will cause the rational simplification on these components. If RATFAC is TRUE then the components will also be factored as the following example, for the standard metric, demonstrates:
.example
.begin group
(C40) EINSTEIN(TRUE);
				    D  X - A D + D
				     X
(E40) 			    G	  = --------------
			     1, 1	     2
					A D X
.end
.skip
.begin group

				  2				     2
	       2 A D D	  X - A D   X - A  D D  X + 2 A D D  - 2 A  D
		      X X	 X	 X    X		   X	  X
(E41)  G     = -------------------------------------------------------
	2, 2				 2  2
				      4 A  D  X
.end
.skip
.begin group

				  2				     2
	       2 A D D	  X - A D   X - A  D D  X + 2 A D D  - 2 A  D
		      X X	 X	 X    X		   X	  X
(E42)  G     = -------------------------------------------------------
	3, 3				 2  2
				      4 A  D  X
.end
.skip
.begin group

					     2
				     A  X + A  - A
				      X
(E43) 			   G     = - -------------
			    4, 4	  2  2
					 A  X
.end
.end
.endfunction

.function(LRICCICOM,dis)
computes the covariant (symmetric) components LR[i,j] of the Ricci tensor.  If the argument 2dis* is TRUE, then the non-zero components are displayed. For the standard metric one finds (with RATFAC:TRUE):
.example
.begin group
(C24) RATFAC:TRUE$
.end
.skip
.begin group

(C25) LRICCICOM(TRUE);
					 2			 2
		      2 A D D    X - A D   X - A  D D  X - 4 A  D
			     X X        X       X    X	      X
(E25) 	   LR	  = - --------------------------------------------
	     1, 1			     2
					4 A D  X
.end
.skip
.begin group

						 2
			    A D  X - A  D X - 2 A  D + 2 A D
			       X      X
(E26) 		 LR     = - --------------------------------
		   2, 2			    2
					 2 A  D
.end
.skip
.begin group

					     2		     2
		       (A D  X - A  D X - 2 A  D + 2 A D) SIN (Y)
			   X	  X
(E27) 	    LR	   = - ------------------------------------------
	      3, 3			    2
					 2 A  D
.end
.skip
.begin group

					2
		     2 A D D    X - A D	  X - A  D D  X + 4 A D D
			    X X	       X       X    X		 X
(E28) 	    LR	   = ---------------------------------------------
	      4, 4			  2
				       4 A  D X
.end
.end
.endfunction

.function(MOTION,dis)
computes the geodesic equations of motion for a given metric.  They are stored in the array EM[i].  If the argument 2dis* is TRUE then these equations are displayed.
.endfunction

.function2 OMEGA
is an option which assigns a list of coordinates to the variable. While normally defined when the function TSETUP is called, one may redefine the coordinates with the assignment OMEGA:[2j1,j2,...jn*] where the 2j*'s are the new coordinate names. A call to OMEGA will return the coordinate name list. Also see the function TSETUP above.
.endfunction

.function(RATFAC,false)
is a switch which, if TRUE, causes the Ricci, Einstein, Riemann, and Weyl tensors and the Scalar Curvature to be factored automatically. Clearly, this should only be set for cases where the tensorial components are known to consist of few terms.
.endfunction

.function(RIEMANN,dis)
computes the Riemann curvature tensor from the given metric and the corresponding Christoffel symbols.  If 2dis* is TRUE, the non-zero components R[i,j,k,l] will be displayed. All the indicated indices are covariant.  As with the Einstein tensor, various switches set by the user control the simplification of the components of the Riemann tensor.  If $var<RATRIEMAN/TRUE> is TRUE then rational simplification will be done. If RATFAC is TRUE then each of the components will also be factored.
.endfunction

.function(RICCICOM,dis)
This function first computes the covariant components LR[i,j] of the Ricci tensor.  Then the mixed Ricci tensor is computed using the contravariant metric tensor.  If the value of the argument to RICCICOM is TRUE, then these mixed components, RICCI[i,j]  (the index i is covariant and the index j is contravariant),  will be displayed directly.  Otherwise, RICCICOM(FALSE) will simply compute the entries of the array RICCI[i,j] without displaying the results.
.endfunction

.function(SCURVATURE,)
returns the Scalar Curvature as the trace of the mixed Ricci tensor. With RATFAC:TRUE this invariant will be factored.
.endfunction

.function(WEYL,dis)
computes the covariant Weyl conformal tensor. If the argument 2dis* is TRUE, the non-zero components W[i,j,k,l] will be displayed. Otherwise, these components will be computed and stored.  If the switch $var<RATWEYL/TRUE> is set to TRUE, then the components will be rationally simplified. If RATFAC is TRUE then the results will be factored as well. The following example illustrates the use of the function for an elementary metric which is chosen to be conformally flat.
.example
.begin group

(C7) LG;
			  [ A  0  0  0  0 ]
			  [		  ]
			  [ 0  A  0  0  0 ]
			  [		  ]
(D7) 			  [ 0  0  A  0  0 ]
			  [		  ]
			  [ 0  0  0  A  0 ]
			  [		  ]
			  [ 0  0  0  0  A ]
.end
.skip
.begin group
(C8) DEPENDENCIES;
(D8) 			        [A(T)]
.end
.skip
.begin group
(C9) RATWEYL:TRUE;
(D9) 				 TRUE
.end
.skip
.begin group
(C10) WEYL(TRUE);
THIS SPACETIME IS CONFORMALLY FLAT 
Time= 94320 msec.
(D10) 				 DONE
.end
.end
.endfunction

.next page
.sec(|Component Tensor Manipulation- Auxiliary Functions|,compontenman)

.function(CHECKDIV,|tensor|)
computes the covariant divergence of the mixed second rank 2tensor* (whose first index must be covariant) by printing the corresponding n components of the vector field (the divergence) where n = DIM. If the argument to the function is G then the divergence of the Einstein tensor will be formed and must be zero. In addition, the divergence (vector) is given the array name DIV. 
.endfunction

.function(COGRAD,|function,name|)
computes the COvariant GRADient of a scalar 2function* allowing the user to choose the corresponding vector2name* as the example under CONTRAGRAD illustrates.
.endfunction

.function(CONTRAGRAD,|function,name|)
computes the CONTRAvariant GRADient of a scalar 2function* allowing the user to choose the corresponding vector2name* as the example below for the standard metric illustrates.
.example
.begin group
.end
(C12) DEPENDS(F,X);
(D12) 			        [F(X)]
.begin group
.end
(C13) COGRAD(F,G1)$
.begin group
.end
(C14) LISTARRAY(G1);

(D14) 			    [F , 0, 0, 0]
			      X
.begin group
.end
(C15) CONTRAGRAD(F,G2)$
.begin group
.end
(C16) LISTARRAY(G2);
			     F
			      X
(D16) 			    [--, 0, 0, 0]
			     A
.begin group
.end
.end
.endfunction

.function(DELETEN,|list,n|)
returns a new list consisting of 2list* with the 2n*th element deleted.
.endfunction

.function(DSCALAR,function)
computes the tensor d'Alembertian of the scalar 2function* once dependencies have been declared upon the 2function*. For the standard metric one has:
.example
.begin group
.end
.skip
.begin group
(C16) DEPENDS(P,X);
(D16) 				    [P(X)]

(C17) FACTOR(DSCALAR(P));
	       2 A D P	  X + A D  P  X - A  D P  X + 4 A D P
		      X X	 X  X	   X    X	     X
(D17) 	       -----------------------------------------------
				     2
				  2 A  D X
.end
.end
.endfunction

.function(FINDDE,|array,n|)
returns a list of the unique differential equations (expressions) corresponding to the elements of the 2n* dimensional square 2array*. Presently, 2n* may be 2 or 3. DEINDEX is a global list containing the indices of 2array* corresponding to these unique differential equations. For the Einstein tensor (G) given above, which is a two dimensional array, FINDDE gives the following independent differential equations:
.example
.begin group
(C19) FINDDE(G,2);
					  2
(D19) [D  X - A D + D, 2 A D D	  X - A D   X - A  D D  X + 2 A D D
	X		      X X	 X	 X    X		   X

						     2	        2
					     - 2 A  D , A  X + A  - A]
						  X	 X

(C20) DEINDEX;
(D20) 			   [[1, 1], [2, 2], [4, 4]]
.end
.end
.endfunction

.function(NTERMST,f) 
gives the user a quick picture of the "size" of the doubly subscripted tensor (array) 2f*.  It prints two element lists where the second element corresponds to NTERMS of the components specified by the first elements.  In this way, it is possible to quickly find the non-zero expressions and attempt simplification.
.endfunction

.function(RAISERIEMANN,dis) 
returns the 2contravariant* components of the Riemann curvature tensor as  array elements UR[i,j,k,l].  These are displayed if 2dis* is TRUE.
.endfunction

.function(RINVARIANT,)
forms the Kretschmann invariant obtained by contracting the tensors R[i,j,k,l]*UR[i,j,k,l]. This object not automatically simplified since it can be very large. For the standard metric, however, the invariant is small and easily factored. One finds:
.example
.begin group
(C20) FACTOR(RINVARIANT());
.end
.skip
.begin group
	  2  2	   2  4	     2	   2	   4	       2	  4
(D20) (4 A  D  D     X  - 4 A  D D   D	  X  - 4 A A  D  D  D    X
		X X		  X   X X	    X	  X  X X
.end
.skip
.begin group

    2   4  4		  3  4	   2  2	  2  4	    2  2   2  2
 + A  D	  X  + 2 A A  D D   X  + A   D  D   X  + 8 A  D  D   X
       X	    X	 X	  X	 X		  X
.end
.skip
.begin group

       2  4  2	     4  4       3  4	   2  4	     4  4  4
 + 8 A   D  X  + 16 A  D  - 32 A  D  + 16 A  D )/(4 A  D  X )
      X
.end
.end
.endfunction

.function(TRANSFORM,matrix)
will perform a coordinate transformation upon an arbitrary square symmetric 2matrix*. The user must input the functions which define the transformation as in C8 below. The following example considers the transformation from Cartesian to spherical coordinates:
.example
.begin group
(C5) DIM:3$

(C6) OMEGA:[X,Y,Z]$
.end
.skip
.begin group
(C7) LG:MATRIX([1,0,0],[0,1,0],[0,0,1]);

				 [ 1  0	 0 ]
				 [	   ]
(D7) 				 [ 0  1	 0 ]
				 [	   ]
				 [ 0  0	 1 ]

.end
.skip
.begin group
(C8) TRANSFORM(LG)$

TRANSFORM # 1 
X*SIN(Y)*SIN(Z);
TRANSFORM # 2 
X*SIN(Y)*COS(Z);
TRANSFORM # 3 
X*COS(Y);
.end
.skip
.begin group
(C9) /* a substitution which reduces the transformed matrix */

EV(%,COS(Y) = SQRT(1-SIN(Y)^2),SIN(Z) = SQRT(1-COS(Z)^2),RATSIMP);

			    [ 1	 0	 0      ]
			    [		        ]
			    [	  2	        ]
(D9) 			    [ 0	 X	 0      ]
			    [		        ]
			    [	      2	   2    ]
			    [ 0	 0   X  SIN (Y) ]

.end
.end
.endfunction

.next page
.sec(|Component Tensor Manipulation- Alternate Gravity Theories|,compontenyuk)

.function(BDVAC,)
generates the covariant components of the vacuum field equations of the Brans- Dicke gravitational theory. There are two field equations. The components of the second rank covariant field tensor are represented by the array BD2. The scalar field equation requires the user to input the name of a scalar and declare its functional dependencies. This field equation is represented by the scalar BD0. 
.endfunction

.function(INVARIANT1,)
generates the mixed Euler- Lagrange tensor (field equations) for the invariant density of R^2. The field equations are the components of an array named INV1.
.endfunction

.function(INVARIANT2,)
generates the mixed Euler- Lagrange tensor (field equations) for the invariant density of LR[i,j]*UR[i,j]. The field equations are the components of an array named INV2.
.endfunction

.function(BIMETRIC,)
generates the field equations of Rosen's bimetric theory. The field equations are the components of an array named ROSEN.
.endfunction

.next page
.sec(Indicial Tensor Manipulation ,indicial,1)

In ITENSR a tensor is represented as an "indexed object" .  This is a function of 3 groups of indices which represent the covariant, contravariant and derivative indices.   The covariant indices are specified by a list as the first argument to the indexed object, and the contravariant indices by a list as the second argument. If the indexed object lacks either of these groups of indices then the empty list [] is given as the corresponding argument.  Thus, G([a,b],[c]) represents an indexed object called  G  which has two covariant indices (a,b), one contravariant index (c) and no derivative indices. 

The derivative indices, if they are present, are appended as additional arguments to the symbolic function representing the tensor. They can be explicitly specified by the user or be created in the process of differentiation with respect to some coordinate variable. Since ordinary differentiation is commutative, the derivative indices are sorted alphanumerically.  This canonical ordering makes it possible for MACSYMA to recognize that, for example, T([a],[b],i,j) is the same as T([a],[b],j,i).  Differentiation of an indexed object with respect to some coordinate whose index does not appear as an argument to the indexed object would normally yield zero. This is because MACSYMA would not know that the tensor represented by the indexed object might depend implicitly on the corresponding coordinate.  By modifying the existing MACSYMA function DIFF in ITENSR, MACSYMA now assumes that all indexed objects depend on any variable of differentiation unless otherwise stated.  This makes it possible for the summation convention to be extended to derivative indices. It should be noted that ITENSR does not possess the capabilities of raising derivative indices, and so they are always treated as covariant. 

The following functions are available in the tensor package for manipulating indexed objects.  At present, with respect to the simplification routines, it is assumed that all indexed objects are completely symmetric in their lists of covariant indices and symmetric in their lists of contravariant indices. This can be overridden by setting the variable ALLSYM[TRUE] to FALSE which will result in no symmetry assumptions in these two sets of indices.  However, the simplification routines may no longer operate completely.

In what follows, general indexed objects will be denoted by 2tensor1, tensor2, ...* . The symbols  2L1, L2*,... denote lists which are arguments to indexed objects. Optional arguments are enclosed in angle brackets.

.next page
.sec(|Indicial Tensor Manipulation- Basic Functions|,compontenfun)

.function(CHR1,|1[*i,j,k1]*|)
yields the Christoffel symbol of the first kind via the definition
.skip 1

.begin turn on "{"
.once center
({sb(g,|[ik,j]|)} + {sb(g,|[jk,i]|)} - {sb(g,|[ij,k]|)})/2 .
.end
.skip 1
.continue
To evaluate the Christoffel symbols for a particular metric, the variable METRIC must be assigned a name as in the example under CHR2.
.endfunction

.function(CHR2,|1[*i,j1]*,1[*k1]*|)
yields the Christoffel symbol of the second kind defined by the relation
.skip 1
.begin turn on "{"
.once center
CHR2([i,j],[k]) = {sp(g,|[ks]|)} ({sb(g,|[is,j]|)} + {sb(g,|[js,i]|)} - {sb(g,|[ij,s]|)})/2
.end
As an example we consider a conformally flat metric and find the Christoffel symbols of both kinds:
.example
.begin group
(C7) DECLARE(E,CONSTANT)$
.end
.skip
.begin group
(C8) METRIC(G)$
.end
.skip
.begin group
(C9) COMPONENTS(G([I,J],[]),E([I,J],[])*P([],[]))$
.end
.skip
.begin group
(C10) COMPONENTS(G([],[I,J]),E([],[I,J])/P([],[]))$
.end
.skip
.begin group
(C11) SHOW(G([I,J],[]));
(D11) 			        P E
				   I J
.end
.skip
.begin group
(C12) SHOW(G([],[I,J]));
				  I J
				 E
(D12) 				 ----
				  P

.end
.skip
.begin group
(C13) SHOW(FACTOR(CHR1([I,J,K])));
		    P   E    + P   E    - P   E
		     ,I	 J K    ,J  I K	   ,K  I J
(D13) 		    ------------------------------
				  2
.end
.skip
.begin group
(C30) SHOW(FACTOR(CHR2([I,J],[K])));
		%1 K
	       E     (P	   E    - P   E	    - P	  E    )
		       ,%1  I J	   ,I  %1 J    ,J  %1 I
(D31) 	     - -----------------------------------------
				  2 P
.end
.end
.endfunction

.function(COMPONENTS,|tensor,exp|)
permits one to assign an indicial value to an expression 2exp1 giving the values of the components of 2tensor1. These are automatically substituted for the 2tensor1 whenever it occurs with all of its indices.  The 2tensor1 must be of the form  T([...],[...]) where either list may be empty. 2Exp1 can be any indexed expression involving other objects with the same free indices as 2tensor1. When used to assign values to the metric tensor wherein the components contain dummy indices one must be careful to define these indices to avoid the generation of multiple dummy indices. Removal of this assignment is given to the function REMCOMPS described below.
.skip
The example under DEFCON (C9 - D12) demonstrates the use of the 2COMPONENTS* function to define an 2algebraically special metric* and also shows how the null property of the vector field can be given with the property assignment functions. The example above under CHR2 gives the basic syntax used in the COMPONENTS statement.
.endfunction

.function(CONTRACT,|exp|)
carries out the tensorial contractions in 2exp* which may be any combination of sums and products.  This function uses the information given to the DEFCON function.  When using CONTRACT, 2exp* must be fully expanded. Also see the function METRIC and the example under 2DIM*.
.endfunction

.function(COVDIFF,|exp,v1,v2,...|)
 yields the covariant derivative of 2exp* with respect to the variables 2vi* in terms of the Christoffel symbols of the second kind (CHR2).  In order to evaluate these, one can use EV(2exp1,CHR2). 
.example
.begin group
(C3) ENTERTENSOR();
Enter tensor name: A;
Enter a list of the covariant indices: [I,J];
Enter a list of the contravariant indices: [K];
Enter a list of the derivative indices: [];
				      K
(D3) 				     A
				      I J
.end
.skip
.begin group
(C4) SHOW(COVDIFF(%,S));
	      K	       %1     K	       %1     K		  K     %1
(D4) 	   - A	   CHR2	   - A	   CHR2	   + A	    + CHR2     A
	      I %1     J S    %1 J     I S    I J,S	  %1 S  I J
.end
.end
.endfunction

.function(DIFF,|exp,v1,n1,v2,n2,...|) 
 is the usual MACSYMA differentiation function which has been expanded in its abilities for ITENSR. It takes the derivative of 2exp* with respect to 2v1 n1* times, with respect to 2v2 n2* times, etc.  For the tensor package, the following modifications have been incorporated (also see the function UNDIFF):
.break continue
.skip
1) the derivatives of any indexed objects in 2exp* will have the variables 2vi* appended as additional arguments.  Subsequently, all derivative indices will be sorted.
.break continue
.skip
2) the 2vi* may be integers from 1 up to the value of the variable DIM[4].  This will cause the differentiation to be carried out with respect to the  2vi*th member of the list COORDINATES which should be set to a list of the names of the coordinates, e.g., [x,y,z,t]  .  If  COORDINATES is bound to an atomic variable, then that variable subscripted by 2vi* will be used for the variable of differentiation.  This permits an array of coordinate names or subscripted names like  X[1], X[2],...  to be used.  If COORDINATES has not been assigned a value, then the variables will be treated as in 1) above.
.break continue
.skip
3) one may now differentiate the determinant of the metric tensor. Thus, if METRIC has been bound to G then DIFF(DETERMINANT(G),K) will return 2*DETERMINANT(G)*CHR2([%i,K],[%i]) where the dummy index has been appropriately chosen.
.endfunction

.function2 DIM
is the dimension of the manifold with the default 4. The command DIM : N will reset the dimension to any other integral value.  The following example demonstrates the contraction property of the Kronecker delta.
.example
.begin group
(C4) CONTRACT(KDELTA([A],[B])*KDELTA([B],[A]));
(D4) 			        KDELTA([], [])
.end
.skip
.begin group
(C5) EV(%,KDELTA);
(D5) 				      4
.end
.end
.endfunction

.function(ENTERTENSOR,|<name>|)
is a function which, by prompting, allows one to create an indexed object called 2name* with any number of tensorial and derivative indices. Either a single index or a list of indices (which may be null) is acceptable input (see the example under COVDIFF).
.endfunction

.function(GEODESIC,|exp,name|)
enables the user to cause undifferentiated Christoffel symbols and first derivatives of the metric tensor vanish in 2exp*. The 2name* in the GEODESIC function refers to the metric 2name* (if it appears in 2exp*) while the connection coefficients must be called with the names CHR1 and/or CHR2. The following example demonstrates the verification of the cyclic identity upon the Riemann tensor using RENAME while also showing the use of the GEODESIC function.
.example
.begin group
(C2) EXP:RIEMANN([R,S,T],[U])+RIEMANN([S,T,R],[U])+RIEMANN([T,R,S],[U])$
.end
.skip
.begin group
(C3) SHOW(EXP);
	   U          U       %6       U          U       %6       U
(D3) - CHR2     - CHR2    CHR2   + CHR2     + CHR2    CHR2   + CHR2
	   T S,R      %6 R    T S      T R,S      %6 S    T R      S T,R
.end
.skip
.begin group
       U        %5	  U	      U	       %5	 U
 + CHR2	    CHR2    - CHR2      - CHR2	   CHR2	   - CHR2
       %5 R     S T	  S R,T	      %5 T     S R	 R T,S
.end
.skip
.begin group
       U        %4	  U	      U	       %4
 - CHR2	    CHR2    + CHR2      + CHR2	   CHR2
       %4 S     R T	  R S,T	      %4 T     R S
.end
.skip
.begin group
(C4) SHOW(GEODESIC(EXP,CHR2));
	   U          U          U          U          U          U
(D4) - CHR2     + CHR2     + CHR2     - CHR2     - CHR2     + CHR2
	   T S,R      T R,S      S T,R      S R,T      R T,S      R S,T
.end
.skip
.begin group
(C5) SHOW(RENAME(EXP));
(D5) 				      0
.end
.end
.endfunction

.function(INDEXED,tensor)
must be executed before assigning components to a 2tensor1 for which a built in value already exists as with CHR1, CHR2, RIEMANN. See the example under RIEMANN.
.endfunction

.function(KDELTA,|L1,L2|)
 is the generalized Kronecker delta function with 2L1* the list of covariant indices and 2L2* the list of contravariant indices. KDELTA([i],[j]) returns the ordinary Kronecker delta. The command EV(EXP,KDELTA) causes the evaluation of an expression containing KDELTA([],[]) to the dimension of the manifold (see the example under DIM).
.example
.begin group
(C3) KDELTA([A,B,C],[R,S,T])$
.end
.skip
.begin group
(C4) SHOW(EV(%));
	     R	      S	      T	        T       S
(D4) - KDELTA  (KDELTA  KDELTA  - KDELTA  KDELTA )
	     A	      B	      C	        B       C
.end
.skip
.begin group
	 R	  T	  S	    S	    T
 - KDELTA  (KDELTA  KDELTA  - KDELTA  KDELTA )
	 B	  A	  C	    A	    C
.end
.skip
.begin group
	  S	  T	    T	    S	     R
 - (KDELTA  KDELTA  - KDELTA  KDELTA ) KDELTA
	  A	  B	    A	    B	     C

.end
.end
.endfunction

.function(LC,|L|)
 is the permutation (or Levi-Civita) tensor density which yields 1 if the list 2L* consists of an even permutation of integers, -1 if it consists of an odd permutation, and 0 if some indices in 2L* are repeated.
.endfunction

.function(METRIC,|name|)
specifies 2name* as the metric name by assigning the variable METRIC:2name1. In addition, the contraction properties of the metric 2name1 are set up by executing the commands DEFCON(2name1), DEFCON(2name, name1, KDELTA). See, for example, the example under RIEMANN. 
.endfunction

.function(RATEXPAND,|exp|)
 is the fastest way to expand products and powers of sums of indexed objects generated by ITENSR within MACSYMA.
.endfunction

.function(RENAME,|exp, <count>|)
returns an expression equivalent to 2exp* but with the dummy indices in each term chosen from the set [%1, %2,...], if the optional second argument is omitted. Otherwise, the dummy indices are indexed beginning at the value of  2count1.  Each dummy index in a product will be different. For a sum, RENAME will operate upon each term in the sum resetting the counter with each term. In this way RENAME can serve as a tensorial simplifier. In addition, the indices will be sorted alphanumerically (if ALLSYM is TRUE) with respect to covariant or contravariant indices depending upon the value of FLIPFLAG.  If FLIPFLAG is FALSE then the indices will be renamed according to the order of the covariant indices otherwise according to the order of the contravariant indices. It often happens that the combined effect of the two renamings will reduce an expression more than either one by itself.
.example
.begin group
(C41) SHOW(EXP);
       %4 %5  %6 %7     %3	  U	    %1	      %2
(D41) G	     G	    CHR2      CHR2      CHR2	  CHR2
			%1 %4	  %2 %3	    %5 %6     %7 R

		   %4 %5  %6 %7	    U	      %1        %3	  %2
	        - G      G      CHR2	  CHR2	    CHR2      CHR2
				    %1 %2     %3 %5     %4 %6	  %7 R
.end
.skip
.begin group
(C42) FLIPFLAG;
(D42) 				    FALSE
.end
.skip
.begin group
(C43) SHOW(RENAME(EXP));
       %2 %5  %6 %7     %4	  U	    %1	      %3
(D43) G	     G	    CHR2      CHR2      CHR2	  CHR2
			%1 %2	  %3 %4	    %5 %6     %7 R

		   %4 %5  %6 %7	    U	      %1        %3	  %2
	        - G      G      CHR2	  CHR2	    CHR2      CHR2
				    %1 %2     %3 %4     %5 %6	  %7 R
.end
.skip
.begin group
(C44) FLIPFLAG:TRUE$
.end
.skip
.begin group
(C45) RENAME(D42);
(D45) 				  0
.end
.skip
.begin group
(C46) [FIRST(D42),LAST(D42)]$
.end
.skip
.begin group
(C46) SHOW(RENAME(%));
	%1 %2  %3 %4	 %5	   %6	     %7	      U
(D46) [G      G	     CHR2      CHR2      CHR2	  CHR2	   , 
			 %1 %6	   %2 %3     %4 R     %5 %7

		  %1 %2	 %3 %4	   %5	     %6	       %7       U
	       - G      G      CHR2      CHR2	   CHR2	    CHR2     ]
				   %1 %6     %2 %3     %4 R     %5 %7
.end
.end
.endfunction

.function(RIEMANN,|1[*i,j,k1]*,1[*h1]*|) 
 yields the Riemann curvature tensor in terms of the Christoffel symbols of the second kind (CHR2).  The following notation is used:
.example
.begin group
	     h		   h	       h        %1	  h
      RIEMANN	   = - CHR2      - CHR2	    CHR2    + CHR2
	     i j k	   i k,j       %1 j     i k	  i j,k

			      h         %1
			+ CHR2	    CHR2
			      %1 k      i j

.end
.end
.end
Suppose the name specified by the value of METRIC corresponds to a tensor which has been given some structure via the COMPONENTS command. In order to evaluate an 2expression1 involving the Riemann tensor and incorporate this given definition of the metric explicitly into the result, the user can do  2expression1, EVAL as the following example for the weak field metric demonstrates: 
.example
.begin group
(C5) INDEXED(CHR2)$
.end
.skip
.begin group
(C6) DECLARE(E,CONSTANT)$
.end
.skip
.begin group
(C7) METRIC:G$
.end
.skip
.begin group
(C8) COMPONENTS(G([M,N],[]),E([M,N],[])+2*L*P([M,N],[]))$
.end
.skip
.begin group
(C9) COMPONENTS(G([],[M,N]),E([],[M,N])-2*L*P([],[M,N]))$
.end
.skip
.begin group
(C10) SHOW(G([I,J],[]));
(D10) 			   2 L P    + E
				I J    I J
.end
.skip
.begin group
(C11) SHOW(G([],[I,J]));
			    I J	     I J
(D11) 			   E    - 2 P    L
.end
.skip
.begin group
(C12) (RATVARS(L),RATWEIGHT(L,1),RATWTLVL:1)$
.end
.skip
.begin group
(C13) RIEMANN([S,U,N],[Y])$
.end
.skip
.begin group
(C14) %,EVAL$
.end
.skip
.begin group
(C15) SHOW(CANFORM(CONTRACT(RENAME(RATEXPAND(%)))))$

	 %1 Y		     %1 Y		 %1 Y
(D15) - E     L P	  + E	  L P	      + E     P	        L
		 S U,%1 N	     N S,%1 U	       %1 U,N S

						      %1 Y
						   - E	   P	     L
							    %1 N,S U
.end
.endfunction

.function(SHOW,|exp|)
displays 2exp* with the indexed objects in it shown having their covariant indices as subscripts and contravariant indices as superscripts. The derivative indices are displayed as subscripts, separated from the covariant indices by a comma (see the example above).
.endfunction

.function(UNDIFF,|exp|)
 returns an expression equivalent to 2exp* but with all derivatives of indexed objects replaced by the noun form of the DIFF function. Its arguments would yield that indexed object if the differentiation were carried out.  This is useful when it is desired to replace a differentiated indexed object with some function definition resulting in 2exp* and then carry out the differentiation by saying  EV(2exp*, DIFF).
.endfunction

.next page
.sec(|Indicial Tensor Manipulation- Simplification Functions|,compontensimp)

.function(ALLSYM,|true|)
if TRUE then all indexed objects are assumed symmetric in all of their covariant and contravariant indices. If FALSE then no symmetries of any kind are assumed in these indices. Derivative indices are always taken to be symmetric.
.endfunction

.function(CANFORM,|exp|)
simplifies 2exp* by renaming dummy indices and reordering all indices as dictated by symmetry conditions imposed on them. If ALLSYM is TRUE then all indices are assumed symmetric, otherwise symmetry information provided by DECSYM declarations will be used. The dummy indices are renamed in the same manner as in the RENAME function. When CANFORM is applied to a large expression the calculation may take a considerable amount of time. This time can be shortened by calling RENAME on the expression first. Also see the example under DECSYM. Note: CANFORM may not be able to reduce an expression completely to its simplest form although it will always return a mathematically correct result.
.endfunction

.function(CANTEN,|exp|)
simplifies 2exp*  by renaming (see RENAME) and permuting dummy indices. CANTEN is restricted to sums of tensor products in which no derivatives are present. As such it is limited and should only be used if CANFORM is not capable of carrying out the required simplification.
.endfunction

.function(CHANGENAME,|old,new,exp|)
will change the name of all indexed objects called 2old* to 2new* in 2exp*. 2Old* may be either a symbol or a list of the form 2[name, m, n]* in which case only those indexed objects called 2name* with 2m* covariant and 2n* contravariant indices will be renamed to 2new*.
.endfunction

.function(CONMETDERIV,|exp,tensor|)
is used to simplify expressions containing ordinary derivatives of both covariant and contravariant forms of the metric tensor (the current restriction).  For example, CONMETDERIV can relate the derivative of the contravariant metric tensor with the Christoffel symbols as seen from the following:
.example
.begin
.end
.skip
.begin group
(C8) SHOW(G([],[A,B],C))$

				      A B
(D8) 				     G
				      ,C
.end
.skip
.begin group
(C9) SHOW(CONMETDERIV(%,G));
			 %1 B	  A	  %1 A	   B
(D9) 		      - G     CHR2     - G     CHR2
				  %1 C		   %1 C
.end
.end
.endfunction

.function(FLIPFLAG,false)
if FALSE then the indices will be renamed according to the order of the covariant indices otherwise according to the order of the contravariant indices. The function influences RENAME in the following way: If FLIPFLAG is FALSE then RENAME forms a list of the covariant indices as they are encountered from left to right (if TRUE then of the contravariant indices). The first dummy index in the list is renamed to %1, the next to %2, etc. Then sorting occurs after the RENAMEing (see the example under RENAME).
.endfunction

.function(FLUSH,|exp,tensor1,tensor2,...|)
will set to zero, in 2exp*, all occurrences of the 2tensori* that have no derivative indices.
.endfunction

.function(FLUSHD,|exp,tensor1,tensor2,...|)
will set to zero, in 2exp*, all occurrences of the 2tensori* that have derivative indices.
.endfunction

.function(FLUSHND,|exp,tensor,n|)
will set to zero, in 2exp*, all occurrences of the differentiated object 2tensor* that have 2n* or more derivative indices as the following example demonstrates.
.example
.begin group
(C3) SHOW(A([I],[J,R],K,R)+A([I],[J,R,S],K,R,S));
			       J R S	  J R
(D3) 			      A	       + A
			       I,K R S	  I,K R
.end
.skip
.begin group
(C4) SHOW(FLUSHND(D3,A,3));
				     J R
(D4) 				    A
				     I,K R
.end
.end
.endfunction

.function(FLUSH1DERIV,|exp,tensor|)
will set to zero, in 2exp*, all occurrences of 2tensor* that have exactly one derivative index.
.endfunction

.function(LORENTZ,|exp, <tensor1, tensor2, ...>|)
imposes a generalized Lorentz condition on 2exp* replacing by zero those 2tensori* which have a derivative index identical to a contravariant index. If no 2tensori* are specified, this process will be performed on all indexed objects in 2exp* (see the example under MAKEBOX).
.endfunction

.function(MAKEBOX,|exp,tensor|)
 will display, with the symbol [], all occurrences of the flat-space d'Alembertian operator acting upon 2tensor* in 2exp*. The name of the flat-space metric appears in the argument to the function. In the following example EIN is the weak field approximation of the Einstein tensor for the metric which is given and L is small.
.example
.begin group
(C56) SHOW(G([I,J]));

(D56) 			    P    L + E
			     I J      I J
.end
.skip
.begin group
(C57) SHOW(EIN);
	 %1 %2  I J	    %1 %2   I J		     %1 %2  I J
(D57) - E      P       L - P	   E    L + P	    E	   E    L
		,%1 %2	    ,%1 %2	     ,%1 %2

	      %1 I  %2 J        %1 I    %2 J		  %1 I  %2 J
	   + E	   P	   L + P       E     L - P       E     E     L
		    ,%1 %2      ,%1 %2		  ,%1 %2
.end
.skip
.begin group
(C58) SHOW(LORENTZ(%,P));
	 %1 %2  I J		    %1 %2  I J
(D58) - E      P       L + P	   E	  E    L
		,%1 %2	    ,%1 %2

							  %1 I  %2 J
					       - P       E     E     L
						  ,%1 %2
.end
.skip
.begin group
(C59) SHOW(MAKEBOX(%,E));
		I J	     I J	      %1 I  %2 J
(D59) 	   - []P    L + []P E    L - P	     E	   E     L
				      ,%1 %2
.end
.end
.endfunction

.next page
.sec(|Indicial Tensor Manipulation- Property Assignment Functions|,compontenprop)

.function(COORD,|tensor1,tensor2,...|)
gives 2tensori* the coordinate differentiation property that the derivative of contravariant vector whose name is one of the 2tensori* yields a Kronecker delta. For example, if COORD(X) has been done then DIFF(X([],[I]),J) gives KDELTA([I],[J]). COORD is a list of all indexed objects having this property.
.endfunction

.function(DECLARE,|object,property|)
allows the specification of certain 2properties* upon the 2object*. For example, we can  specify that an indexed object is independent of all coordinate variables. Whereas DIFF(W([],[I,J]),K) normally results in  W([],[I,J],K), with the command DECLARE(W,CONSTANT) given, the result of the differentiation will be 0. Similarly, one can declare a vector to be null (see the example under the DEFCON function).
.endfunction

.function(DECSYM,|tensor, m, n, [cov1,cov2,...], [contr1,contr2,...]|) 
declares symmetry properties for 2tensor* of 2m* covariant and 2n* contravariant indices. The 2covi* and 2contri* are pseudofunctions expressing symmetry relations among the covariant and contravariant indices respectively.  These are of the form 2symoper*(2index1*, 2index2*,...) where 2symoper* is one of SYM, ANTI or CYC and the 2indexi* are integers indicating the position of the index in the 2tensor*.  This will declare 2tensor* to be symmetric, antisymmetric or cyclic respectively in the 2indexi*. 2symoper*(ALL) is also an allowable form which indicates all indices obey the symmetry condition. For example, given an object B with 5 covariant indices, DECSYM (B,5,3,[SYM(1,2),ANTI(3,4)],[CYC(ALL)]) declares B symmetric in its first and second and antisymmetric in its third and fourth covariant indices, and cyclic in all of its contravariant indices.  Either list of symmetry declarations may be null.  The function which performs the simplifications is CANFORM as the example below illustrates.
.example
.begin group
(C4) EXP:A([K,J,I],[])+A([K,I,J],[])+A([J,K,I],[])+
	 A([J,I,K],[])+A([I,K,J],[])+A([I,J,K],[])$
.end
.skip
.begin group
(C5) SHOW(EXP);
(D5) 	     A	    + A	     + A      + A      + A      + A
	      K J I    K I J    J K I	 J I K	  I K J	   I J K
.end
.skip
.begin group
(C6) ALLSYM;
(D6) 				     TRUE
.end
.skip
.begin group
(C7) SHOW(CANFORM(EXP));

(D7) 				   6 A
				      I J K
.end
.skip
.begin group
(C8) ALLSYM:FALSE$
.end
.skip
.begin group
(C9) DECSYM(A,3,0,[ANTI(ALL)],[])$
.end
.skip
.begin group
(C10) DISPSYM(A,3,0);
(D10) 			  [[ANTI, [[1, 2, 3]], []]]
.end
.skip
.begin group
(C11) SHOW(CANFORM(EXP));
(D11) 				      0
.end
.skip
.begin group
(C12) REMSYM(A,3,0)$
.end
.skip
.begin group
(C13) DECSYM(A,3,0,[CYC(ALL)],[])$
.end
.skip
.begin group
(C14) SHOW(CANFORM(EXP));
(D14) 			     3 A      + 3 A
				I K J	   I J K

.end
.end
.endfunction

.function(DEFCON,|tensor1,<tensor2,tensor3>|) 
gives 2tensor1* the property that the contraction of a product of 2tensor1* and 2tensor2*  results in 2tensor3* with the appropriate indices.  If only one argument, 2tensor1*, is given, then the contraction of the product of 2tensor11 with any indexed object having the appropriate indices (say 2tensor*) will yield an indexed object with that name, i.e. 2tensor*, and with a new set of indices reflecting the contractions performed. For example, if METRIC:G, then DEFCON(G) will implement the raising and lowering of indices  through contraction with the metric tensor. CONTRACTIONS is a list of those indexed objects which have been given contraction properties with DEFCON.
.skip
The following example for an 2algebraically special metric* shows how the null property of a vector field may be assigned as well as demonstrating that more than one DEFCON assignment can be given for the same indexed object.
.example
.begin group
(C4) DECLARE(E,CONSTANT)$
.end
.skip
.begin group
(C5) DEFCON(E)$
.end
.skip
.begin group
(C6) DEFCON(E,E,KDELTA)$
.end
.skip
.begin group
(C7) DEFCON(L,L,W)$
.end
.skip
.begin group
(C8) W(L1,L2):=0$
.end
.skip
.begin group
(C9) COMPONENTS(G([P,Q],[]),E([P,Q],[])+2*M*L([P],[])*L([Q],[]))$
.end
.skip
.begin group
(C10) COMPONENTS(G([],[A,B]),E([],[A,B])-2*M*L([],[A])*L([],[B]))$
.end
.skip
.begin group
(C11) SHOW(G([I,J],[]));
(D11) 			       2 L  L  M + E
				  I  J	    I J
.end
.skip
.begin group
(C12) SHOW(G([],[I,J]));
				I J	 I  J
(D12) 			       E    - 2 L  L  M
.end
.skip
.begin group
(C13) METRIC(G)$
.end
.skip
.begin group
(C14) CONTRACT(RENAME(EXPAND(G([I,J],[])*G([],[J,K]))))$
.end
.skip
.begin group
(C15) SHOW(%);
					 K
(D15) 				   KDELTA
					 I
.end
.skip
.begin group
(C16) DISPCON(ALL);
(D16) 	 [[[E, E, KDELTA], [E]], [[L, L, W]], [[G, G, KDELTA], [G]]]
.end
.end
.endfunction

.next page
.sec(|Indicial Tensor Manipulation- Property Display Functions|,compontenproq)

.function(DISPCON,|tensor1,tensor2,...|)
 displays the contraction properties of the 2tensori* which were given to DEFCON.  DISPCON(ALL) displays all defined contraction properties as the example under DEFCON illustrates.
.endfunction

.function(DISPSYM,|tensor, m, n|) 
displays symmetries declared by DECSYM as a list of lists or returns [] if there are none (see the example under DECSYM). The first element of the inner list is one of the atoms SYM, ANTI or CYC. The second element is a list of lists of the index positions that have this property in the covariant indices of 2tensor*. The third element is the same except that it is for the contravariant indices.

.endfunction

.next page
.sec(|Indicial Tensor Manipulation- Property Removal Functions|,compontenprox)

.function(REMCOMPS,tensor)
unbinds all values from 2tensor1 which were assigned with the COMPONENTS function.
.endfunction

.function(REMCOORD,|tensor1,tensor2,...|)
removes the coordinate differentiation property from the 2tensori* that was established by the function COORD.  REMCOORD(ALL) removes this property from all indexed objects.
.endfunction

.function(REMCON,|tensor1,tensor2,...|)
 removes all the contraction properties from the 2tensori*. 
REMCON(ALL) removes all contraction properties from all indexed objects.
.endfunction

.function(REMSYM,|tensor,m,n|)
removes all symmetry properties from 2tensor* which has 2m* covariant indices and 2n* contravariant indices.
.endfunction

.next page
.sec(|Indicial Tensor Manipulation- Indexing Functions|,compontenindx)

.function2 COUNTER
determines the numerical suffix to be used in generating the next dummy index. It may also be used to set the counter to any value (see the example under INDICES).
.endfunction

.function(DUMMY,)
increments COUNTER and returns as its value an index of the form %n where n is a positive integer.  This guarantees that dummy indices which are needed in forming expressions will not conflict with indices already in use (see the example under INDICES).
.endfunction

.function2 DUMMYX
is the prefix for dummy indices (see the example under INDICES).
.endfunction

.function(INDICES,|exp|)
 returns a list of two elements.  The first is a list of the free indices in 2exp* (those that occur only once). The second is the list of the dummy indices in 2exp* (those that occur exactly twice) as the following example demonstrates.
.example
.begin group
(C3) SHOW(RIEMANN([I,J,K],[L])*RIEMANN([A,B,C],[D]));
	    D	        D	 %2	   D	       D        %2
(D3) (- CHR2	  - CHR2     CHR2    + CHR2      + CHR2	    CHR2   )
	    A C,B       %2 B	 A C	   A B,C       %2 C     A B
.end
.skip
.begin group
	      L		  L	   %1	     L		 L	  %1
       (- CHR2	    - CHR2     CHR2    + CHR2	   + CHR2     CHR2   )
	      I K,J	  %1 J	   I K	     I J,K	 %1 K	  I J
.end
.skip
.begin group
(C4) INDICES(%);
(D4) 		     [[D, C, A, B, L, K, I, J], [%2, %1]]
.end
.skip
.begin group
(C5) COUNTER;
(D5) 				      2
.end
.skip
.begin group
(C6) COUNTER:11$
.end
.skip
.begin group
(C7) ''C3;
	    D	        D	  %13	    D	        D	  %13
(D7) (- CHR2	  - CHR2      CHR2    + CHR2	  + CHR2      CHR2   )
	    A C,B       %13 B	  A C	    A B,C       %13 C	  A B
.end
.skip
.begin group
	    L	        L	  %12	    L	        L	  %12
     (- CHR2	  - CHR2      CHR2    + CHR2	  + CHR2      CHR2   )
	    I K,J       %12 J	  I K	    I J,K       %12 K	  I J
.end
.skip
.begin group
(C8) DUMMYX;
(D8) 				      %
.end
.skip
.begin group
(C9) DUMMYX:&$
.end
.skip
.begin group
(C10) ''C3;
	     D		 D	   &15	     D		 D	   &15
(D10) (- CHR2	   - CHR2      CHR2    + CHR2	   + CHR2      CHR2   )
	     A C,B	 &15 B	   A C	     A B,C	 &15 C	   A B
.end
.skip
.begin group
	    L	        L	  &14	    L	        L	  &14
     (- CHR2	  - CHR2      CHR2    + CHR2	  + CHR2      CHR2   )
	    I K,J       &14 J	  I K	    I J,K       &14 K	  I J
.end
.end
.endfunction

.next page
.sec(|Indicial Tensor Manipulation- ITENSR --> CTENSR|,compontenie)

.function(GENERATE,eqn)
converts an ITENSR equation 2eqn* to a CTENSR assignment statement. Implied sums over dummy indices are made explicit while indexed objects are transformed into arrays (the array subscripts are in the order of covariant followed by contravariant indices of the indexed objects). The derivative of an indexed object will be replaced by the noun form of DIFF taken with respect to OMEGA subscripted by the derivative index. The Christoffel symbols CHR1 and CHR2 will be translated to LCS and MCS respectively and if $var<METRICCONVERT/TRUE> is TRUE then all occurrences of the metric with two covariant (contravariant) indices will be renamed to LG (UG). In addition, DO loops will be introduced summing over all free indices so that the transformed assignment statement can be evaluated by just doing EV(...). The following examples demonstrate the features of this function.
.example
.begin group
(C11) SHOW(X);
			      L	       K  I    I   J
(D11) 			 G = F  A    (C  B  + D ) E
				 I J	  K	   L
.end
.skip
.begin group
(C12) GENERATE(X);
(D12) G : SUM(SUM(SUM(F  A     (SUM(C  B    , K, 1, DIM) + D ) E    ,
		       L  I, J	     K  K, I		    I   L, J

			 I, 1, DIM), J, 1, DIM), L, 1, DIM)
.end
.skip
.begin group
(C4) SHOW(T([I],[J]));
				   J
(D4) 				  T
				   I
.end
.skip
.begin group
(C5) SHOW(COVDIFF(%,K));
		    J	   %1	  J	    J	  %1
(D5) 		 - T   CHR2    + T    + CHR2     T
		    %1	   I K	  I,K	    %1 K  I
.end
.skip
.begin group
(C6) METRICCONVERT;
(D6) 				 TRUE
.end
.skip
.begin group
(C7) GENERATE(H([I,K],[J])=D5);

(D7) 

FOR I THRU DIM DO (FOR J THRU DIM DO (FOR K THRU DIM DO H        : 
							 I, K, J

- SUM(T	     MCS        , %1, 1, DIM) + DIFF(T	  , OMEGA )
       %1, J    I, K, %1		      I, J	 K

 + SUM(MCS	   T	 , %1, 1, DIM)))
	  %1, K, J  I, %1
.end
.skip
.begin group
(C8) METRIC(G)$
.end
.skip
.begin group
(C9) D5,CHR2$
.end
.skip
.begin group
(C10) SHOW(%);
	 %1 %3  J
	G      T   (G	    - G	      + G      )
		%1   K %3,I    I K,%3	 I %3,K
(D10) - ----------------------------------------
			   2

		      J %2  %1
		     G	   T   (G        - G	    + G	      )
			    I	 K %2,%1    %1 K,%2    %1 %2,K	   J
		   + ------------------------------------------ + T
					 2			   I,K
.end
.skip
.begin group
(C11) GENERATE(H([I,K],[J])=D10);
(D11) 

FOR I THRU DIM DO (FOR J THRU DIM DO (FOR K THRU DIM DO H        : 
							 I, K, J

- SUM(SUM(UG	   T	  (DIFF(LG     , OMEGA )
	    %1, %3  %1, J	  K, %3	      I

 - DIFF(LG    , OMEGA  ) + DIFF(LG     , OMEGA )), %1, 1, DIM), %3, 
	  I, K	     %3		  I, %3	      K

1, DIM)/2 + SUM(SUM(UG	    T	   (DIFF(LG     , OMEGA	 )
		      J, %2  I, %1	   K, %2       %1

 - DIFF(LG     , OMEGA  ) + DIFF(LG	 , OMEGA )), %1, 1, DIM), %2, 
	  %1, K	      %2	   %1, %2       K

1, DIM)/2 + DIFF(T    , OMEGA )))
		  I, J	     K
.end
.end
.endfunction

.next page
.sec(Acknowledgments ,iindicial,1)
These program systems, first begun in 1973, have undergone several stages of development during the last 7 years. One of us (RP) wishes to thank Alexander Doohovskoy, David Grabel, Richard Zippel and especially Richard Bogen for their efforts in coding the routines described above. In addition, thanks are extended to the many staff members of the Laboratory of Computer Science (past and present) who contributed such a great deal to the current state of this project.
