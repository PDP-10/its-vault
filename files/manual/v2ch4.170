@Comment<(c) Copyright 1983 Massachusetts Institute of Technology>
@comment<Enhancements (c) Copyright 1983 Symbolics, Inc.>

@Chapter[The SHARE Directory]
@Label[share]

     The SHARE, SHARE1, and SHARE2 directories contain programs, 
information files, etc. which are considered to be of interest to the 
MACSYMA community.  (The SHARE1; and SHARE2; directories are overflow 
directories for the SHARE; directory which in general hold less frequently 
used files.  From now on, references to the SHARE; directory should be 
taken to mean all of the SHARE;, SHARE1;, and SHARE2; directories.)
Some files on SHARE; are not part of the MACSYMA system per se and must 
be loaded individually by the user, e.g. LOADFILE(CGAMMA,FASL,SHARE);.
However, using the LOAD @Index[LOAD] command makes it unnecessary to worry about
either which of the SHARE directories a file is on, or which kind of
file it is, e.g. LOAD(CGAMMA); will find and load up the file CGAMMA FASL.

     Many files on SHARE; were contributed by MACSYMA users, and all MACSYMA 
users are encouraged to contribute.

     Names for files on SHARE; should be chosen as appropriate.  
However, the contributor will probably want to follow the conventions 
discussed here.  A contributor will probably create some but not all 
of the following files.  Examples may be seen on the SHARE directory.
  
   1)  NAME > is the file name of the MACSYMA BATCHable programs.  
The > sign indicates a numeric second filename which is increased 
whenever a new version is created.  

   2) NAME LISP is the file name of the LISP code for the programs
contained in the file NAME >.  This file is loaded into MACSYMA using
LOADFILE.  It was obtained by using the TRANSLATE command, the SAVE
command, or was written directly in LISP by the contributor.

   3) NAME FASL is the file name of the FASL (fast-loadable) version
of NAME LISP, and was produced from NAME LISP by using the LISP
compiler, or produced using the FASSAVE command.  It is loaded into
MACSYMA using the LOADFILE command.

   4)  NAME USAGE is the name of the documentation file for the 
programs in NAME >.  It describes how the programs are used, inputs, 
outputs, options, warnings, error messages, etc.  It may mention the 
algorithms behind the programs, references, and whatever else the 
user should know.  It should certainly indicate who programmed the 
routines, especially his login name.  If the NAME USAGE file does 
not exist, this information should be given in NAME > or elsewhere.

   5)  NAME DEMO is the name of the demonstration file which may be 
used in DEMOing NAME > or NAME LISP.

   6)  NAME OUTPUT may be used to store sample output obtained from 
running NAME > on some examples or from DEMOing the NAME DEMO file.

   7)  Other file names may be used for information files providing 
some information on some aspect of the MACSYMA system or for 
describing some MACSYMA utility or for notes on some MACSYMA issues, 
etc.

     The SHARE > file is an index to the SHARE directory and is 
intended to contain a short note on each of the programs on the SHARE 
directory.  It should be updated by the SHARE; contributor as 
appropriate.

     Any comments or questions about the use of the SHARE directory 
should be sent to JPG.

@Section[|Contents of the Directory|]
@Label[cotd]

This is the contents of the file SHARE;SHARE 58, which represents the
SHARE directories as of June 1982.  This is a complete listing, and
thus contains some packages which are actually part of MACSYMA.  Those
will have a reference to the appropriate section of the manual.  The
packages which are on the SHARE directories will be treated, each in a separate
section, in the rest of this chapter.

*** begin indent  0,10;turn on "" hereABSIMP(11)(SHARE1;) supplements the built-in simplification rules for
ABS and SIGNUM.

ANTID(11)(SHARE2;) Integrates (antidifferentiates) expressions involving 
an unspecified function and its derivatives.

APLOT2(12)belongs to PLOT2

AIRY(11)(SHARE1;) Contains the AIRY functions and their derivatives, both
numerically and a bit symbolically; has the GRADEFS that TAYLOR uses.

ARRAY(11)various functions for handling arrays (e.g. changing array   
dimensions, filling arrays from a list).

ASYMP(11)(SHARE1;) a package for determining the asymptotic behavior of
Feynman integrals.

ASYMPA(15)(SHARE1;) does asymptotic analysis, including big-Oh and little-oh
simplification.

BESSEL(11)obtains Bessel functions J and I for real arg and integer 
order.  Bessel function J for complex arg and nonneg real order.
Airy function Ai of real arg.  Plasma Dispersion function (Complex
Error function), and a generator of random numbers with a normal 
distribution.

BFFAC(11)(SHARE2;) cheap and dirty BFLOAT versions of the
Factorial (shifted Gamma) and Riemann Zeta functions.

BINIO(11)(SHARE2;) belongs to PLOT2

BRMBRG(15)(SHARE2;) BIGFLOAT version of ROMBRG numerical integration

CGAMMA(15)Gamma function for complex arguments.

CTENSR(12)for a user-specified metric, enables explicit computation
of Christoffel symbols, Ricci tensor, Riemann tensor, and other tensor
quantities of interest in differential geometry and gravitation
theory.  (see @Ref[tensors]).

DBLINT(11)(SHARE1) Function for double intergrals, using Simpson's Rule.

DECLIN(11)(SHARE1;) Functions for declaring linear operators with several 
arguments.

DELTA(11)(SHARE2;) integrals with Dirac deltas

DESOLN(12)solves differential equations or systems of them using 
Laplace transforms.  Part of MACSYMA, see (see @Ref[difintfun]).

DETERM(15)(SHARE1;) the Bareiss two-step determinant algorithm.

DIFSOL(11)(SHARE2;) solves differential equations or systems of them using
Laplace transforms.

DIMEN(11)(SHARE1;) dimensional analysis.

DISOL(11)(SHARE2;) does ISOLATE's job for multiple variables.

DSKUSE(11)(SHARE2;) Functions for finding out about disk usage on the MC machine.

DUMP(11)saves and loads number arrays efficiently

EIGEN(11)computes right eigenvectors, right unit eigenvectors, 
eigenvalues, and similarity transforms.

ELIM(11)(SHARE1;) eliminates variables from equations by taking resultants.

ELLIPT(11)Some complete elliptic integrals and Jacobian elliptic functions.

FACEXP(15)(SHARE1;) Several functions for controlled expansion of rational
expressions.

FACT(11)Taylor series of the gamma function.

FFT(11)routines form Fast Fourier Transform and inverse FFTs

FIDO(11)(SHARE2;) a program named FIDO that acts like DDT's fido program 
without wasting a whole job slot in a crowded system.

FOPTIM(12)(SHARE2;) a program which accepts function-names as arguments, 
and calls OPTIMIZE on their definitions. Subject to same restrictions 
as OPTIMIZE but saves some of the clumsiness of accessing and 
restoring definition.

FORMAT(15)for pretty printing floating point numbers according to a specified
precision, total width, or fractional width.

FORMA1(15)same as above, but still nicer to the eye.

FORTRA(15)produces FORTRAN-compatible code from MACSYMA using TECO.

FOURIE(12)(SHARE1;) calculate Fourier series and Fourier integral
coefficients.  Also, there are various utility functions to do such
things as replace all occurrences of F(arg) by arg in an expression.

FUNCTS(15)assorted useful functions.  Their names are CONJUGATE,
REMPART, WRONSKIAN, ADJOINT, TRACEMATRIX, RATIONAL, ODD, UPROBE, 
KRONECKER, NONZEROANDFREEOF, LINEAR, and QUADRATIC.

GAMALG(15)Part of a package for Feynman diagram calculations in high-energy
physics. Takes traces (in n dimensions), squares amplitudes,
manipulates untraced strings of gamma matrices, and much more.
(Manual is in GAM USAGE)

GAMMA(15)(SHARE2;) computes a truncated asymptotic expansion for the gamma 
function.

GRIND(11)a TECO program which "grinds" (formats) BATCH files.

IFFUN(11)belongs to PLOT2

INTPOL(11)roots of transcendental equations by interpolation.

INTSCE(11)(SHARE1;) smartly integrates expressions of the form 
EXP(a*X+b)*COS(c*X)@-[110]*SIN(c*X)@-[109] .

INVERT(11)(SHARE1;) finds the inverse of a matrix using the adjoint method.
In MACSYMA, see (see @Ref[matrix!functions]).

ITENSR(11)MACSYMA's indicial tensor manipulation package. Unlike
ETENSR, which carries out tensor operations explicitly,
this package works on the tensor indices and is truly
symbolic.  (see @Ref[tensors]).

KACH(11)(SHARE1;) implementation of Hacijan's linear programming
algorithm.

LINDE1(11)(SHARE2;) solves first order linear ordinary differential
equations.

LRATS (11)two functions related to RATSUBST: one is a recursive form of
RATSUBST, and the other is an enhancement of RATSUBST which
allows multiple serial substitution in the manner of SUBST.

NDIFFQ(12)(SHARE2;) Numerical solutions to differential equations.

NTRIG(11)(SHARE1;) Computes trig functions with arguments of the form
N*%PI/10 for integer N.

NUMRCL(15)(NUMER;) Various numerical hacks including Gaussian quadratures,
simpson's rule, bessel functions, mappings over declared arrays,
smoothings and quadratures of functions defined by arrays.
coded by GJC. See the NUMER directory for other stuff.

ODE(11)solves ordinary differential equations of 1st, 2nd and a few higher
orders by a very large number of methods (including ODE2).

ODE2(11)solves ordinary differential equations of 1st and 2nd order.
(see @Ref[difintfun]).

OPTIMU(12)(NUMER;) Functions for generating programming constructs from
MACSYMA mathematical expressions. Automatic optimizing, MODE
declaration, and function defining. -GJC.

OPTMIZ(12)(SHARE2;) does analytic optimization.  Finds the stationary
points of a multivariate objective function.

OPTVAR(12)(SHARE2;) does variational optimization: the calculus of
variations, the maximum principle, and optimal control.

PFAFF(11)(SHARE2;) contains a function which evaluates Pfaffians.

PINVRS(11)(SHARE2;) computes matrix inverse by partitioning.

PLOT2(11)plotting for Tektronix 4013, Imlacs the XGP and the Gould 
lineprinter capabilities include all those provided by the
MACSYMA plotting package and much more.

PLOT3D(12)belongs to PLOT2

POLSOL(11)(SHARE2) A package for finding the roots of polynomials.

POWERS(15)(SHARE2) returns the powers of variables in polynomials.

PRINT(11)belongs to PLOT2                             

QUAL(11)does qualitative analysis, determining bounds, monotonicity,
convexity, structure, periods, symmetries, poles, zeros, stationary
points, and asymptotics of general expressions.

QQ(11)(SHARE1;) Adaptive quadrature for fast numerical integrations. Has
3 and 4 arg versions of QUANC8. Written by LPH.

RECUR(11)recurrence relation program.  Written by John Ivie of UCB

REVERT(15)(SHARE2;) for reversion of series.  Programmed by Wilson.

OROMBR(15)(SHARE2;) does Romberg numerical integration.

ROMBRG(15)an alternate version of ROMBER.

SERIES(11)solution of second (and some first) order differential equations
by substitution of infinite series(method of Frobenius). Attempts
to find a complete solution in closed form.

SET(11)(SHARE2;) a Set Theory package using MACSYMA notation.

SETS(11)provides a fast SETS package.

SPECFN(12)definite integration of special functions (Bessel, Whittaker,
Legendre,Orthogonal Polys, Incomplete Gamma, etc.) by conversion to
hypergeometric functions. Currently handles only Laplace type
integrals; i.e., INTEGRAL(F(Z)*EXP(-P*Z),Z,0,inf).

STOPEX(12)(SHARE1;) Expansion with respect to specified variables.

TEKPLT(12)belongs to PLOT2

TRGSMP(15)an alternative trigonometric-hyperbolic simplifier, see
(see @PageRef[trigsimpl]).

UNITS(11)does automatic conversion of units to metric, and provides
a check on the dimensional homogeniety of expressions.

VECT(11)vector algebra and calculus, including simplification,
expansion into curvilinear coordinates, scalar potentials, and
vector potentials.

VECTOR(15)various vector operations are included, e.g. DIV, GRAD,
DOTDEL, CROSS, LAPLACIAN, and CURL.

WORLD(12)belongs to PLOT2
*** begin indent ends here
@Section[|Simplification for ABS and SIGNUM|]
@Label[absign]

The file SHARE1;ABSIMP > contains MACSYMA pattern-matching rules that
extend the built-in simplification rules for the ABS @Index[ABS] and SIGNUM @Index[SIGNUM]
functions.  Among other things, use is made of global relations
established with the built-in ASSUME @Index[ASSUME] function or by declarations such
as DECLARE @Index[DECLARE](M,EVEN, N,ODD)  for even or odd integers.  UNITRAMP @Index[UNITRAMP]
and UNITSTEP @Index[UNITSTEP] functions are also defined in terms of ABS and SIGNUM.
These routines were written by David Stoutemyer (STOUTE@MIT-MC).

@Section[Airy Functions]
@Label[airyf]

The AIRY @Index[AIRY] equation diff(y(x),x,2)-x*y(x)=0 has two linearly independent
solutions, taken to be ai(x) and bi(x). This equation is very popular
as an approximation to more complicated problems in many mathematical
physics settings.

Do LOAD("AIRY");  to get the functions AI @Index[AI](x), BI @Index[BI](x), DAI @Index[DAI](x), DBI @Index[DBI](x) .

The file SHARE1;AIRY FASL (by LPH@MIT-MC) contains routines to compute the 
Ai(x), Bi(x), d(Ai(x))/dx, and d(Bi(x))/dx functions. The result will be
a floating point number if the argument is a number, and will return a
simplified form otherwise. An error will occur if the argument is large
enough to cause an overflow in the exponentials, or a loss of 
accuracy in sin or cos. This makes the range of validity
about -2800 to 1.e38 for AI and DAI, and -2800 to 25 for BI and DBI.
The GRADEF rules are now known to MACSYMA: diff(AI(x),x)=DAI(x),
diff(DAI(x),x)=x*AI(x), diff(BI(x),x)=DBI(x), diff(DBI(x),x)=x*BI(x).

The method is to use the convergent Taylor series for abs(x)<3., and
to use the asymptotic expansions for x<-3. or x>3. as needed.  This
results in only very minor numerical discrepancies at x=3. or x=-3.
More accuracy can be had if you request help from LPH. For details,
please see Abramowitz and Stegun's Handbook of Mathematical Functions,
section 10.4 (hardcover ed.) and Table 10.11 .

To get the floating point Taylor expansions of the functions here, do 
ev(TAYLOR @Index[TAYLOR](AI(x),x,0,9),infeval); for example.

Please also check (see @Ref[spec!fun]) for the AIRY function there.

Leo P. Harten (LPH)

@Section[Asymptotic Analysis]
@Label[asympanal]

MACSYMA batch file SHARE1;ASYMPA > contains simplification functions
for asymptotic analysis, including the big-O and little-o functions that
are widely used in complexity analysis and numerical analysis.  First,
to establish the asymptotic values of any independent variables that are
not to be regarded as constants, issue the appropriate set of commands of
the form

@fcn[Name="PUT", Args="indeterminant, limitvalue, 'LIMIT"])
For complexity analysis, @i[limitvalue] is usually 'INF, and for
numerical analysis, @i[limitvalue] is usually 0.  However, any
symbolic or numeric value can be used.


Thereafter:

@fcn[Name="ASYMP", Args="expression1"]
returns ASYMP(@i[expression2]), where @i[expression2] is the simplest
expression that ASYMP could determine that is asymptotically equal to
@i[expression1]:
@Begin[Example]
        limit (expression2/expression1)  =  1.
          indeterminates->limitvalues
@End[Example]


@fcn[Name="THETA", Args="expression1"]
returns THETA(@i[expression2]), where @i[expression2] is the simplest
expression that THETA could determine that is of the exact same order
as expression1.


@fcn[Name="O", Args="expression1"]
returns O(@i[expression2]), where @i[expression2] is the simplest
expression that O could determine that is big-O of every expression
that expression1 is big-O of.


@fcn[Name="LO", Args="expression1"]
returns LO(expression2), where expression2 is the simplest expression
that LO could determine that is little-o of every expression
that expression1 is little-o of.


@fcn[Name="OMEGA", Args="expression1"]
returns OMEGA(expression2), where expression2 is the simplest expression
that OMEGA could determine that is of least the same order as expression1.
OMEGA specifies a lower bound on the order, analagous to  how O
specifies an upper bound.


@fcn[Name="LOMEGA", Args="expression1"]
returns LOMEGA(expression2), where expression2 is the simplest expression
that LOMEGA could determine that is of lesser order than every expression
that expression1 is of lesser order than.  LOMEGA specifies a strict
lower bound on the order, analagous to how LO specifies
an upper bound on the order.


When expression3 contains one or more subexpressions containing the
results of the above functions, 

@fcn[Name="ASYMPSIMP", Args="expression3"]
may return a simplified form of expression3.  For example, after
typing PUT(N, 'INF, 'LIMIT),  ASYMPSIMP(N**3 + 5*THETA(N)*ASYMP(
%E*N*LOG(N)) + THETA(LOG(LOG(N))))   yields  N**3 + THETA(N**2*LOG(N)).


Input expressions can contain the functional form named LOG2, the
logarithm to the base 2, which will be converted to LOG appropriately.

BASECONVERT[FALSE] @Index[BASECONVERT] if TRUE  causes exponentials
to be converted to the base %e, which may permit greater simplification.

ASYMPTAYLOR[FALSE] @Index[ASYMPTAYLOR] if TRUE causes use of
Taylor series before trying other techniques, which may lead to a
simpler answer or may lead to an error interrupt which
produces baffling messages and may be beyond the control of ERRCATCH.

TAYLORMAX[1] @Index[TAYLORMAX] The effectiveness and interrupt-proneness of the
Taylor technique is also dependent upon upon the setting of TAYLORMAX, the
maximum number of iterations.

Rather than discard information and accuracy unnecessarily, it is 
recommended that the user first try ASYMP.  If the constants in the
result are incomprehensibly complicated, then try THETA.  If the result
still contains too may terms, then try O and OMEGA to
get a bound pair.

@Section[Factorial and Riemann Zeta Functions]
@Label[rwg!bfac]

SHARE2;BFFAC BFZETA contains cheap and dirty BFLOAT versions of the
Factorial (shifted Gamma) and Riemann Zeta functions.  Do LOAD(BFFAC);
to access these functions.

@fcn[Name="BFFAC", Args="exp,n"])
- BFLOAT version of the Factorial (shifted Gamma)
function.  The second argument is how many digits to retain and return.
It's a good idea to request a couple of extra.

@fcn[Name="BFZETA", Args="exp,n"])
- BFLOAT version of the Riemann Zeta function.  The 2nd
argument is how many digits to retain and return, and as above, it is
a good idea to request a couple of extra.

@fcn[Name="BFPSI", Args="n,z,fpprec"])
- gives polygammas of real arg and integer order.
For digamma, BFPSI0(z,fpprec) is more direct.  Note -BFPSI0(1,fpprec)
provides BFLOATed %GAMMA.


There is also CBFAC @Index[CBFAC](z,fpprec) for factorial of complex z, which is
even slower!

@fcn[Name="BURN", Args="n"]
is a way to get isolated Bernoulli numbers faster than BERN(n)
when n > 105 or so.


There is also the Hurwitz zeta function BHZETA @Index[BHZETA](s,h,fpprec), which gives
fpprec digits of sum((k+h)@-[45]s,k,0,inf). 

These are all due to RWG@MC.

@Section[Gamma Functions for Complex Arguements]
@Label[gffca]

The Gamma function in the complex plane.

Functions CGAMMA, CGAMMA2, and LOGCGAMMA2.

These functions evaluate the Gamma function over the complex plane
using the algorithm of Kuki, CACM algorithm 421.  Calculations are
performed in single precision and the relative error is typically
around 1.0E-7; evaluation at one point costs less than 1 msec.
The algorithm provides for an error estimate, but the MACSYMA
implementation currently does not use it.

Load the functions with:
@Begin[Example]
LOAD(CGAMMA); .
@End[Example]
@fcn[Name="CGAMMA", Args="arg"]
is the general function and may be called with a symbolic
or numeric argument.  With symbolic arguments, it returns as is;
with real floating or rational arguments, it uses the MACSYMA Gamma
function; and for complex numeric arguments, it uses the Kuki
algorithm.


@fcn[Name="CGAMMA2", Args="real,imag"])
of two arguments, @i[real] and @i[imaginary], is for @u[]umeric arguments
only@-[46]


LOGCGAMMA2 @Index[LOGCGAMMA2] is the same as CGAMMA, but the log-gamma function is
calculated.  These two functions are somewhat more efficient.

Examples:

CGAMMA(1) -> 1

CGAMMA(4) -> 6

CGAMMA(3/2) -> SQRT(%PI)/2

CGAMMA(X) -> CGAMMA(x)

CGAMMA(1+%i) -> 0.49801569-%i*.154949838  (error 2.5E-8)

@Section[Gamma Matrix Algebra Program]
@Label[GAMALG]

The GAMALG package is a package for Feynman diagram calculations
in high energy physics.  See also (see @PageRef[fey]).

@u[]apabilities@-[58]
*** begin indent  0,5;turn on "" here1.(6)Takes traces of products of Dirac gamma matrices in n dimensions.
In 4 dimensions, it also takes traces of products involving 
gamma[5] (G5).  The results may have free indices.

2.(6)Squares sums of amplitudes, involving polarized or unpolarized spinors.

3.(6)Contracts free indices.

4.(6)Simplifies products of gamma matrices in n dimensions.
*** begin indent ends hereFor all manipulations, GAMALG uses the conventions of Bjorken and Drell
and takes Tr(1)=4 (generalization of the spinor dimensionality is 
unnecessary).

Further information, especially on the algorithms used by GAMALG, may
be found in 'MACSYMA Tools for Feynman Diagram Calculations', by Stephen 
Wolfram, in Proceeding of the 1979 Users' Conf. and Caltech preprint 
CALT-68-720 (June 1979). These references give some discussion of other
programs available for high energy physics calculations (including
Feynman parametrization etc.).

Numbers in brackets refer to sections of the file SHARE;GAM USAGE, which
is the complete manual for this package.

@u[]ummary of Functions@-[58]

@fcn[Name="BTR", Args="list"]
takes the trace of the gamma matrices represented by its argument
in a way that is more efficient than TR for long traces invloving many sums 
of momenta [1].


@fcn[Name="CIND", Args="mu1,...,muk"])
adds mu1 through muk to the list of contracted indices [1].


@fcn[Name="CGT", Args="exp"]
converts G's to TR's and does them [3].


@fcn[Name="COMPDEF", Args="vec1=list1,vec2=list2,ind1=val1,ind2=val2,vec3=..."])
defines lists as the components of vectors and values for indices, for
use by NONCOV


@fcn[Name="CON", Args="exp"]
contracts all free indices in exp (including epsilon symbols) [3].


@fcn[Name="CONJ", Args="amp"]
returns the conjugate of the amplitude amp [2].


@fcn[Name="COTR", Args="exp"]
reduces (in n=4) products of traces with contracted indices to 
single traces [3].


@fcn[Name="CRUNCH", Args="exp"]
simplifies untraced products of gamma matrices in exp [3].


@fcn[Name="DFIX", Args="exp"]
expands all dot products in exp [3].


@fcn[Name="EPSFIX", Args="exp"]
expands all epsilon symbols in exp [3].


@fcn[Name="FLAGS", Args=""]
displays the values of flags and information lists.


@fcn[Name="GFIX", Args="exp"]
expands sums of vectors appearing in untraced products of
gamma matrices in exp [3].


@fcn[Name="GLUE3", Args="l1,l2,l3"])
gives the tensor corresponding to the three-gluon vertex represented
by its arguments [3].


@fcn[Name="KINDEF", Args="dotp1=rep1, dotp2=rep2, ..."])
defines kinematics substitutions dotp1=rep1,... [3].


@fcn[Name="NONCOV", Args="exp"]
substitues the non-covariant components specified by COMPDEF
for vectors and indices in dot products in exp [3]


@fcn[Name="NSET", Args="dim"]
sets the dimensionality of spacetime to dim [1].


@fcn[Name="SCALS", Args="x1,..,xk"])
adds x1 through xk to the list of scalars [1].


@fcn[Name="SQ", Args="spn1,amp,spn2"])
squares the amplitude amp sandwiched between the spinors
spn1 and spn2 [2].


@fcn[Name="SQAM", Args="spn1,amp1,spn2,amp2"])
sums over spins the amplitude squared 
amp1*conj(amp2) sandwiched between the spinors spn1 and spn2 [2].


@fcn[Name="TR", Args="a1,a2,..."])
takes the trace of gamma matrices represented by its 
argument [1].


@fcn[Name="UNCIND", Args="mu1,...,muk"])
removes mu1 through muk from the list of
contracted indices [1].


@fcn[Name="UNCOMPDEF", Args="vec1,ind1,vec2,vec3,..."])
removes the components defined for
its arguments [3].


@fcn[Name="UNKINDEF", Args="dotp1,...,dotpk"])
removes simplifications defined for dot
products dotp1 through dotpk [3].


@fcn[Name="UNSCALS", Args="x1,...,xk"])
removes x1 through xk from the list of scalars [2].


@u[]seudofunctions@-[58]

D @Index[D](p,q)   dot product of p and q

D(p,mu)   mu component of the vector p

D(mu,nu)   mu, nu component of metric tensor

EPS @Index[EPS](p,q,r,s)   totally antisymmetric product of p,q,r and s

G @Index[G](a1,...,ak)   product of gamma matrices represented by a1,...,ak
(list brackets around sets of arguments optional)

UV @Index[UV](p,m)   a fermion spinor with momentum p and mass m

UVS @Index[UVS](p,m,s)   a polarized fermion spinor with spin s

ZN @Index[ZN](p,m)   the numerator of a massive fermion propagator (p(slash)+m)

ZD @Index[ZD](p,m) or ZA(p,m)   the full propagator for a massive fermion 
((p(slash)+m)/(d(p,p)-m*m)). [If ZERM:TRUE then m=0 will be assumed, and 
ZD(p) or ZA(p) may be used.]

ZDEN @Index[ZDEN](p,m)  the denominator of a massive propagator (d(p,p)-m@-[50]) suitable
for VIPER generated when VIRED:TRUE.

@u[]lags@-[32](Switches)

BORED[FALSE] @Index[BORED] if TRUE generates interest (TR0 entries and exits).

COF[FALSE] @Index[COF] if TRUE alphabetizes CRUNCH outputs by anticommutation.   

DEF[TRUE] @Index[DEF] if FALSE will prevent the expansion of dot products as they are 
generated

DOF[TRUE] @Index[DOF] if FALSE will prevent alphabetization of dot products as they
are generated

DSIM[TRUE] @Index[DSIM] if FALSE prevents dot product simplifications defined by KINDEF
from being applied.

EPSOF[TRUE] @Index[EPSOF] if FALSE will prevent alphabetization of epsilon symbols
(antisymmetric products) as they are generated.

EPSEF[TRUE] @Index[EPSEF] if FALSE will prevent expansion of epsilon symbols as 
they are generated.

KAHAF[FALSE] @Index[KAHAF] if TRUE will cause the Kahane algorithm to be used on
traces with many contracted indices in n=4.
 
MTRICK[TRUE] @Index[MTRICK] if TRUE invokes a more efficient algorithm for treating 
traces with large numbers of massive spinor propagators in 4 dimensions.

NOP[FALSE] @Index[NOP] if TRUE causes SQ to generate no primed indices 
(does Feynman gauge polarization sums).


NTR[FALSE] @Index[NTR] if TRUE causes SQ to generate G's rather than TR's

PLATU[FALSE] @Index[PLATU] if TRUE uses the inefficient methods of templates for large 
traces

VIRED[FALSE] @Index[VIRED] if TRUE generates VIPER-compatible output.

ZERM[FALSE] @Index[ZERM] if TRUE assumes all particle masses to be zero.

BORELEN @Index[BORELEN]   determines the amount of interest generated when BORED:TRUE

METSIG @Index[METSIG] is the signature of the metric used by NONCOV  (default [+,-,-,-])

 < 5 then next page;
@u[]nformation lists@-[32](initially empty)

*** begin indent  0,10;turn on "" hereCOMPS(11)is the list of components defined by COMPDEF

IND(11)is the list of contracted indices (which will be uncontracted if 
unpaired)

KINS(11)is the list of kinematic substitutions defined by KINDEF

NPIND(11)is the list of indices automatically summed over by SQ (or SQAM)

SCALARS(11)is the list of scalars
*** begin indent ends here

 < 5 then next page
@u[]oading GAMALG@-[10]
      To load GAMALG into a MACSYMA, do 
@Begin[Example]
LOAD(GAMALG);
@End[Example]
      Some examples of the use of GAMALG may be executed by doing
@Begin[Example]
BATCH(GAM,DEMO,SHARE);
@End[Example]

The complete documentation should be perused in the file SHARE;GAM USAGE.

@Section[Evaluation of bounds on Feynman Diagrams]
@Label[fey]

        ASYMP is a package for determining the asymptotic behavior of
Feynman integrals, written by William E. Caswell (WEC@MIT-MC) and
Anthony D. Kennedy (ADK@MIT-MC).

Given a topological description of a Feynman diagram as a set of lines
and vertices, together with information about the mass of the virtual
particle corresponding to each line and the momentum entering at each
external leg, it will tell one the leading asymptotic behavior of that
graph as some sets of masses get much larger than others.

        As this package is very unlikely to be of use to people who
are not familiar with Feynman diagrams and other basic aspects of
perturbative quantum field theory, we will refrain from describing the
basics here and refer the interested reader to any of the standard
textbooks on the subject instead.

        Perhaps this is also the appropriate place to mention the
limitations of the package.  These are of two kinds, those which are
fundamental limitations of the formalism and methods used in the
package itself, and those which are just features which could be added
easily if they are ever needed.  In the first category we stress that
the bounds are obtained for individual Feynman graphs, and not for
sums of them; in other words the asymptotic behavior of a green's
function might be quite different from that of the graphs which
contribute to it, because there may be "miraculous" cancellations.
Such cancellations occur in many interesting theories, in particular
gauge theories, but they are best dealt with by means of Ward
identities rather than explicit calculation.  Another mathematical
limitation is that the actual behavior of a graph is only bounded by
the result given -- in reality the graph might have a smaller
asymptotic growth: the bounds obtained are usually fairly good,
however.  In the second class of limitations we should mention that
(1) the package currently deals only with boson fields, (2) allows
only a trivial dependence of the vertices upon momenta and masses, (3)
tries to compute 1/0 for IR divergent graphs [which is honest, in a
way], and (4) returns INF for a UV divergent graph [which is correct].
All of these are simple to generalize in the program, and if one need
to get around these limitations, please contact the authors.  A
slightly harder problem to circumvent is related to point (4) above,
namely (5) one cannot currently specify that a UV divergent graph is
to be subtracted in a certain way: part of the problem is that there
are many different subtraction schemes (minimal, zero momentum Taylor
series, etc.) and how to specify which method one wants is not clear,
but it would also require a fair amount of thought to make the program
renormalize automatically.  Any suggestions or comments on this, or
any other aspect of ASYMP, would be appreciated.

Simple Example.

        The easiest way to see how ASYMP works is to look at the simplest example,
the one-loop three-point function in (phi)@-[51] theory.  First of all we must load the
ASYMP package into a MACSYMA:
@Begin[Example]

(C1) loadfile(asymp,fasl,dsk,share1)
ASYMP: version of 11:54pm  Saturday, 4 July 1981 

(C2) graph1:diagram(line(a,b,1,m),line(b,c,2,m),line(c,a,3,mm),
        extline(a,4,p),extline(b,5,q),extline(c,6,-p-q))
1 Loop Diagram 


(C3) bound(graph1,[[m,p,q],mm,inf]);
@Hinge

                                       MM
                                   LOG(--)
                                       M
(D3)                               -------
                                       2
                                     MM


        First of all, in line (C1) we have loaded up the FASL (compiled)
version of the ASYMP package.  It identifies itself by telling us the date
on which it was born.  We then define the desired Feynman diagram as GRAPH1
using the DIAGRAM function.  DIAGRAM takes an arbitrary number of arguments,
each of which is a pseudo-function describing a part of the graph.  Currently,
there are two such pseudo-functions, LINE and EXTLINE.  Logically enough LINE
describes an internal line; if we type LINE(LONDON,PARIS,RHUBARB,5*M[PLANCK])
we are defining a line from a vertex called LONDON to a vertex called PARIS
corresponding to a particle of mass 5*M[PLANCK].  A couple of points are to
be noted, (1) the vertices can be names, numbers, or anything one want as long
as it is a valid argument to a hashed array, (2) the factor of 5 in the mass
is pointless, as numerical factors are ignored in asymptotic bounds.  The
third argument, RHUBARB, is a name for the line, which is solely there for 
debugging purposes: internally ASYMP will invent its own name for the line.
This argument is, like rhubarb, best left by the side of the plate and ignored.
EXTLINE describes an external leg to our Feynman diagram.  EXTLINE(ROME,
CELERY,-P+2*Q) says that there is an external leg attached to our graph at
vertex ROME carrying momentum 2*Q-P into the graph.  It is one's own responsibility
to ensure over all momentum conservation.  The second argument, CELERY, has
great similarities to RHUBARB and is also best forgotten (well, it has to be there,
but it seems to serve no other useful role in life).

        OK, so we have now defined our graph.  DIAGRAM sets up tables of lines
containing their masses etc., assigns internal loop-momenta, routes all momenta
through the graph, and tells one the number of loops in the diagram.  If we had
been nosey and typed a ; rather than a  at DIAGRAM, it would have returned a list
of the form [G000002653,G000005532,G000007771].  The Goo's are internal line-names
of no interest to one, other than that they are used by later programs to index
the tables set up by DIAGRAM and its cohorts.  The only point of interest is that
GRAPH1 is now a list of variable names, in other words it behaves just like any other
MACSYMA variable, which is not too surprising because it IS just like any other
MACSYMA variable.

        In line (C2) we get down to the real business of the day.  We use the
function BOUND to find the asymptotic behavior of GRAPH1 when the Euclidean
momenta p and q and the mass m are much smaller than the mass mm, and both are
much smaller than INF (of course: the need to put in INF by hand is just a foible
of the program, so don't forget it!).  To put it another way, we set up three
mass scales, which we shall call m, mm, and INF, such that any mass of order
m is asymptotically bounded by (or, in everyday terms, much less than) any mass
of order mm, and in turn mm << INF.  The second argument to BOUND, therefore,
is a list of mass-scales, each of which is either a mass/momentum or a list of
masses and/or momenta of the same scale.  The result of BOUND is that GRAPH1 is
bounded by (an implicit constant) times log(mm/m)/mm^2, at least for mm/m large
enough.

        For further examples look at the files SHARE1;ASYMP DEMOUT, SHARE1;ASYMP DEMOU1,
etc., which are the output from the demo files SHARE1;ASYMP DEMO, SHARE1;ASYMP DEMO1, etc.

Method:

        For a long write up, see the paper "The Asymptotic Behavior of Feynman
Integrals," Maryland Physics publication #PP-81-188.

Syntax:

        As the syntax has been described above, we just summarize it below:

@fcn[Name="DIAGRAM", Args="pseudo-function,pseudo-function,..."])

@fcn[Name="LINE", Args="from-vertex,to-vertex,name,mass"])

@fcn[Name="EXTLINE", Args="to-vertex,name,momentum"])

@fcn[Name="BOUND", Args="diagram,[mass-scale,mass-scale,...,INF]"]);

<mass-scale> :: mass | momentum | [<mass-scale>,<mass-scale>,...]


        For further information please send mail to ADK@MIT-MC or
WEC@MIT-MC.


@Section[Declaring Linear Operators with Several Arguments]
@Label[declino]

        The functions LINSIMP and DECLARE_LINEAR_OPERATOR provide the
user with the capability of simplifying expressions that contain
operators that are linear in one or more arguments.  It is possible to
accomplish something quite similar using the standard MACSYMA function
DECLARE (see @Ref[declar]), but there is no simple way to extend this to
operators that have more than one argument.  The example below
illustrates the capabilities that are built into MACSYMA:
@Begin[Example]
(C1) DECLARE(F,LINEAR);
(D1)                                 DONE

(C2) F(2*A);
(D2)                                2 F(A)

(C3) F(2);
(D3)                                2 F(1)

(C4) F(A*B);
(D4)                                F(A B)

(C5) DECLARE(B,CONSTANT);
(D5)                                 DONE

(C6) F(A*B);
(D6)                                B F(A)
@End[Example]

Notice that constant factors are extracted from the argument of F.  This
will often be what is needed, but not always.  Operators that have more
than one argument are treated differently.

        LINSIMP and DECLARE_LINEAR_OPERATOR fill these minor gaps in
MACSYMA's understanding of linear operators.  DECLARE_LINEAR_OPERATOR is
used to set up the information necessary for appropriate simplifications
to be carried out, and LINSIMP is used to execute those simplifications.
The desired simplification rules are not applied automatically, which is
a disadvantage of this method relative to MACSYMA's built in capability.

@fcn[Name="LINSIMP", Args="exp, operator1, operator2, ..."])
simplifies exp with respect to
the linearity properties of operator1, then operator2, and so on.
Any terms belonging to the same sum that can be combined together
under the same operator are combined, and any factors that can be
extracted from any of these operators are extracted.  If any of the
operators in the argument list of LINSIMP have not been declared
linear using the function DECLARE_LINEAR_OPERATOR, an error will result.


@fcn[Name="DECLARE_LINEAR_OPERATOR", Args="operator, linear-arguments, separation-predicate"])
sets up the linearity property of @i[operator], which must be an atomic
symbol.  The second argument of DECLARE_LINEAR_OPERATOR,
@i[linear-arguments], is a list of one or more elements the entries of
which denote the specific arguments of @i[operator] that participate in
the linearity property.  @i[operator] is considered to be a linear
function of these specific arguments, taken together.  For example,
let F be linear in its first three arguments.  Then:
@Begin[Example]
F(2*A, 2*B, 2*C, D, E)  =  2*F(A, B, C, D, E)
@End[Example]
The third argument of DECLARE_LINEAR_OPERATOR is the separation predicate.
It must be a function of one argument which returns TRUE if its argument
is not meant to be extracted from "operator", and FALSE if its argument
is meant to be extracted.  Thus, for example, the built in separation
predicate used by MACSYMA for this purpose could be defined as
@Begin[Example]
NOT_CONSTANTP(EXP):=NOT CONSTANTP(EXP)
.end
With such a definition, the declaration necessary to mimic MACSYMA's
built-in capability would be, for the function H of one argument,
@Begin[Example]
DECLARE_LINEAR_OPERATOR(H, [1], NOT_CONSTANTP)
.end
Subsequent use of LINSIMP would then produce forms similar to those
produced by MACSYMA if H had been DECLAREd LINEAR.

@Section[Functions for Integrals with Dirac Deltas]
@Label[FFIWDD]

The function DELINT does integrals
which contain Dirac delta functions.

DELINT @Index[DELINT](@i[expr,var]) and
DELINT @Index[DELINT](@i[expr,var,lower_limit,upper_limit]).  These give the
indefinite and definite integrals respectively.  The delta function is
represented by DELTA @Index[DELTA](@i[argument]); the step function (which is
returned by the indefinite integral) by THETA @Index[THETA](@i[argument]).  These
functions are not defined in the file.

        Currently lower_limit must be lower than upper_limit. This will be
corrected in a later version.  Currently derivatives of delta's
are not handled.  This may be put in later.  Error checking is currently
mimnimal.

        If there is no DELTA function in @i[expr] whose argument depends on
@i[var], DELINT calls INTEGRATE.  To access these functions do:
@Begin[Example]
LOAD(DELTA);
@End[Example]

@Section[Characteristic Polynomial Computation]
@Label[nchrpl]

NCHRPL FASL contains a function, NCHARPOLY, which is an alternative to
the built in MACSYMA CHARPOLY command (see @Ref[matrix!functions]).

NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric functions of
the roots can be calculated, which are nothing more than the coefficients of
the characteristic polynomial.  CHARPOLY works by forming the determinant of
VAR * IDENT [N] - A.  Thus NCHARPOLY wins, for example, in the case of large
dense matrices filled with integers, since it avoids polynomial arithmetic
altogether.  This command was written by DRB.

@fcn[Name="NCHARPOLY", Args="M,var"])
computes the characteristic polynomial of the
matrix @i[M] with respect to @i[var].


@fcn[Name="MATTRACE", Args="M"]
computes the trace [sum of the elements on the main diagonal] of
the square matrix @i[M].


@Section[Isolating Variables]
@Label[disolv]
@fcn[Name="DISOLATE", Args="exp, var1, var2, ..., varN"])
is similar to ISOLATE(exp, var) (see @Ref[extracting!expressions])
except that it enables the user to 
isolate more than one variable simultaneously.  This might be useful,
for example, if one were attempting to change variables in a multiple 
integration, and that variable change involved two or more of the 
integration variables.  To access this function, do 
LOAD(DISOL) .  A demo is available in SHARE2;DISOL DEMO.

 < 15 then next page;
@Section[Differential Equations]
@Label[difeq]
@SubSection[ODE]
@Label[ellode]

ODE is a pot-pourri of Ordinary Differential solvers
combined in such a way as to attempt more and more difficult
methods as each fails. For example, the first attempt is with
ODE2, so therefore, a user using ODE can assume he has all
the capabilities of ODE2 at the very beginning and if he has
been using ODE2 in programs they will still run if he substitutes
ODE (the returned values, and calling sequence are identical).

In addition, ODE has a number of user features which can
assist an experienced ODE solver if the basic system cannot handle
the equation. These will be covered completely toward the end of 
this description, but, essentially, he can make transforms of the
dependent and independent variables, find the invariant in the normal form,
compute the normal form, the Schwartzian derivative, the  adjoint 
or try various particular solutions of the equation. These features
are used to some extent in ODE's attempts to find a general solution.
The user can also control a primitive learning capability of the 
program, i.e., it will remember his attempts at trial particular
solutions as long as he does not read in a fresh version.

The program is called with ODE(equation,y,x); where 
equation is of the same form as required for ODE2 (see @Ref[difintfun]); i.e.:
@Begin[Example]
        'diff(y,x,2)*F(x) + 'diff(y,x)*G(x) +y*H(x) = K(x,y)
@End[Example]Note: The term K(x,y) is only permissible (for now) in first order equations;
e.g. 'diff(y,x)=K(x,y). Its presence in a second order equation;i.e.,trying
to solve a nonlinear higher order will  return  FALSE.
Translation Lossage ******
.scon 
 ******
.if lines < 5 then next page
@b[First Order Equations]

Nearly all of the known methods for handling first order
equations are present in ODE. The more basic methods; e.g. Bernoulli,
Generalized Homogeneous, Linear, Separable, are contained in
ODE2 (see @Ref[difintfun]).
This program is also used by many of the
other methods after they have done the necessary transformations
required by their algorithm. The following additional methods are
applied if ODE2 fails to solve the equation:

 < 5 then next page
DIFFSOL

This is the method of Laplace Transforms.  It is described in
(see @PageRef[difintfun]).
Basically, it converts the DE
to the form DIFF(Y(X),X)+F(Y(X),X)=0 , sets the ATVALUES Y(X) at
0 to %K1 and DIFF(Y(X),X) at 0 to %K2 and then calls DESOLN.

 < 5 then next page
NONLIN

This will solve an equation nonlinear in Y' according to 
the method of Ince. The variable P is substituted for DIFF(Y,X) and
the resulting equation is solved for P. The two solutions thus 
obtained are then reconverted to ODE's in Y,X and solved by a recursive
call to ODE. The two solutions are returned.

 < 5 then next page
NONLIN1

This method is used for the special case in which the coefficients
of Y' and Y are polynomials in X and Y and are homogeneous (have the
same powers of the variables). The transformation %v=y/x is made and
the resulting equation solved by ODE2.

 < 5 then next page
RICCATI

Here we describe the general methods, and the Schmidt algorithms
for finding particular solutions.

 < 5 then next page
EULER MULTIPLIER

(not implemented yet)

Some limited search for an integrating factor is performed by 
ODE2. This method goes to additional lenghths (as described by Schmidt)
to find other possible factors.

 < 5 then next page
@b[Second Order Equations]

After a failing attempt to solve by ODE2, we then try
DIFFSOL, which is merely a new name for Bogen's Laplace Transform
method, in which the appropriate notation has been substituted and
the ATVALUES for the dependent variable and its  derivatives
have been set to %k1, %k2, etc.

Failing that, the following methods are used in the solution
and the variable, METHOD, will be set accordingly:
Translation Lossage ******
.skip 
 ******
.begin indent 5,10;preface 0;
1. Invariant constant. 
Translation Lossage ******
.break  continue
 ******
If the invariant of the DE in the normal form
is a constant the substitution:
Translation Lossage ******
.skip  continue
 ******
y=v*exp(-1/2*integral(G(x)dx))
Translation Lossage ******
.skip  continue                  
 ******
is made and the equation is solved by ODE2 using
the Constant Coefficients rule. The answer is re-
transformed.
Translation Lossage ******
.skip    
 ******
2. Solution of adjoint.
Translation Lossage ******
.break  continue
 ******
If the adjoint of the equation is solvable the answer
is returned after retransformation.
Translation Lossage ******
.skip  
 ******
3. Change of independent variable.
Translation Lossage ******
.break  continue
 ******
If the value of G'(x)+2*H(x)*G(x)/G(x)@-[40]3/2)  is 
a constant, the equation is transformed into
a new equation via:
Translation Lossage ******
.skip  continue
 ******
z= integral(G(x)@-[40]1/2) dx)*c
Translation Lossage ******
.skip  continue
 ******
where c is a constant chosen to simplify the
result. The resulting equation, which now has
constant coefficients, is solved by ODE2 and
the result retransformed.
Translation Lossage ******
.skip 
 ******
.if lines < 5 then next page
4. Try a solution.
Translation Lossage ******
.break  continue
 ******
Next, the fact that y=R(x) may be a solution
is used by scanning thru the list,
Translation Lossage ******
.break  continue
 ******
TRYLIST:[            ],
Translation Lossage ******
.break  continue
 ******
and changing the dependent variable via:
Translation Lossage ******
.skip  continue                
 ******
y= R * v
Translation Lossage ******
.skip  continue
 ******
and solving the resulting equation for v and
retransforming.
Note that, in a pinch, the user may CONS a
solution of his own into TRYLIST (if he thinks he knows
one).
@End[Example]


The program will try some more sophisticated methods
at this point.  The first, solution by
factorization of the differential operator, uses the
Riccati equation solver.  (see Ref. Lafferty, MUCII)

Failing the above, we are left with the
unfortunate alternative of SERIES solutions. But first,
we can see if we have a Hypergeometric or a Whittaker.
This is done by looking at the singularities of the
equation. If it possesses three singularities, all
regular, then we have a Hypergeometric and solve by
means of a Riemann P-Symbol. If two singularities, one
irregular and at infinity (or at zero with the regular
one at infinity), we transform such that the
singularities are at [zero, infinity] and generate a
Whittaker solution. Both the Whittaker and
Hypergeometric solutions are then fed to the
Hypergeometric series reduction routine to generate a
closed form, if possible. Otherwise, the program
returns the series in the form:
Translation Lossage ******
.once  nofill center
 ******
%F[m,n]([a],[b],arg)
Translation Lossage ******
.skip  continue
 ******
where a and b are the lists of factorial function
arguments and arg is an expression. The user has
some control of this process in that he can suppress
the generation of the hypergeometric by setting the
flag CLOSEDFORM[TRUE] @Index[CLOSEDFORM] to FALSE, and further, he
can cause the result to display as a sum by setting the
flag SUMFORM[FALSE] @Index[SUMFORM] to TRUE.

Failing to find either of the preceding cases, the
program will default to the SERIES solver. (ref. Lafferty, MUCI).
This will default to the truncated Taylor form (see
Fateman,MUCI) if no complete solution is obtainable from the
recurrence relation. The complete solution can be
obtained in any of the above forms; i.e., closed,
hypergeometric or sum by setting the various flags.

Optional arguments can be given to ODE following the third
mandatory argument which can have the following values:
*** begin indent  5,15;turn on "" hereANY  =(16)equivalent to no value, i.e., run the methods
as in the current version until a solution is found.

ALL  =(16)run all appropriate (a test is made for degree)
methods even if one or more return a solution.
Return a list of solutions including FALSE.
*** begin indent ends here
or one or more of the following :
SERIES: run SERIES in closedform mode
SOLVEHYPER: solve as a hypergeometric using P-symbols
WHITTAKER: solve as a confluent hyper using tables of Kummer solutions.
ODE2: run ODE2 on it
DIFFSOL: solve by Laplace Xforms
DESOL: solve using more advanced methods(see ODE usage)
SOLFAC: solve by factoring the operator
RICCATI: run the Riccati solver
NONLIN: solve for nonlinear first order in Y'
NONLIN1: solve for nonlinear first order in Y
Example:
@Begin[Example]
ODE('DIFF(Y,X,2)=0,Y,X,SERIES,ODE2);
@End[Example]will apply SERIES and ODE2 in that order and return
a list of the two solutions obtained.
[Note: A user may have his own favorite method which he may want
to include in the list.  This can be done easily for the
ALL case or for a specific call, but not for the ANY or
default case. Check with ELL for instructions and form.]

Two demos are available on SHARE. They should be run in the following
order:
@Begin[Example]
DEMO(ODE,DEMO1,SHARE);
DEMO(ODE,DEMO2,SHARE);
@End[Example]
The first is a small sample of the first order capability, especially
Riccati equations. The second shows some of the second order capability,
Legendre and Bessel equations. The demos also show how some of the
variables and switches can be used to help see what is happening.

@SubSection[Frobenius Series Method]
@Label[frsm]

This program computes the solution of second order linear
ordinary differential equations by the method of Frobenius (substitution
of infinite series.) The program is called by:
@Begin[Example]
LOAD(SERIES);
@End[Example].function(SERIES,|eqn,y,x|)
where @i[eqn] is a differential equation of the form:
Translation Lossage ******
.once  nofill indent 10;
 ******
f(x)*diff(y,x,2)+f'(x)*diff(y,x)+f''(x)*y=0
Translation Lossage ******
.skip  continue
 ******
and @i[y] and @i[x] are the dependent and independent variables.

The dependencies must be established ahead of time by:
@Begin[Example]
DEPENDS(Y,X);
@End[Example]
The program will determine the recurrence relation and if that
is a  function of only one subscripted variable, will go on to determine
a complete solution in terms of an infinite series or a sum of them. If
the recurrence relation is more complex;e.g.,
Translation Lossage ******
.once  nofill center
 ******
A[N]=A[N-1]+A[N-2]
Translation Lossage ******
.skip  continue
 ******
then the relation will be printed and the program will produce a
truncated series solution using the global variable NUMTERMS[5] @Index[NUMTERMS].
These truncated solutions courtesy of JF...OLVER >.


The program produces answers containing some compact functions, 
namely, FFF @Index[FFF] and HARM @Index[HARM].
These are defined in Rainville: @u[]ntermediate
Differential Equations@-[32](pp. 109-112) as follows:
Translation Lossage ******
.once  nofill center
 ******
FFF(exp,n)=exp(exp+1)(exp+2)...(exp+n-1)    n >= 1
Translation Lossage ******
.scon 
 ******
and
Translation Lossage ******
.once  nofill center
 ******
FFF(exp,0)=1, exp#0                                
Translation Lossage ******
.scon 
 ******
and HARM(exp,n) is the partial sum of the harmonic series:
@Begin[Example]
                                  n
                                 ====
                                 \        1
                HARM(exp,n) =     >    -------                             
                                 /     exp + k
                                 ====
                                 k = 1


@End[Example]

and the special case:
Translation Lossage ******
.once  nofill center
 ******
HARM(1,n) =  SUM(1/k,k,1,n)                        
Translation Lossage ******
.skip  once nofill center
 ******
        Several variables and flags are available to the user:
Translation Lossage ******
.skip 
 ******
.begin indent 0,15;
VERBOSE1[TRUE] @Index[VERBOSE1] if FALSE will print diagnostic information about
the equation, i.e. the point at which the solution is being found (0),
is an ordinary point, singular point or the roots of the indicial
equation are equal or differ by an integer and therefore there will be
a logarithmic term in the solution.

POINTEXPAND[0] @Index[POINTEXPAND] if set to any value other than zero will cause the
diagnostics to try that point but will not solve the equation there
(yet)!!

NUMTERMS[5] @Index[NUMTERMS] if set to another value will cause the diagnostic
routine to compute a different number of terms for the Taylor
coefficients when determining the nature of the singularities and will
truncate an approximate solution(if necessary) at that value.
@End[Example]
The program will not work for expressions containing transcendentals
or other functions in the coefficients of the Y'',Y', and Y terms at this
time nor will it work for non-homogeneous equations. In the latter case,
the user can, of course, get a partial solution by making the equation
homogeneous and solving with this program.

The program is still in some state of modification and any comments,
bugs, complaints etc. should be sent to ELL@MC. In addition, the author 
would appreciate any info on successful or unsuccessful application of this
program.


@SubSection[Exterior Calculus of Differential Forms]
@Label[cartan]

     The exterior calculus of differential forms is a basic tool of
differential geometry developed by Elie Cartan and has important
applications in the theory of partial differential equations.  The
present implementation is due to F.B. Estabrook and H.D. Wahlquist.
The program is self-explanatory and can be accessed by doing

                   BATCH(CARTAN,START,DSK,SHARE2)
Translation Lossage ******
.scon 
 ******
which will give a description with examples.  

@NewPage
The next six sections describe programs written by David Stoutemyer.

@Section[Vector Analysis]
@Label[vecan]

The file VECT > contains a vector analysis package,  VECT DEMO contains a corresponding demonstration, and  VECT ORTH contains definitions of various orthogonal curvilinear coordinate systems.

The vector analysis package can combine and simplify symbolic 
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under
user control, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.
There is also a capability for deriving the scalar or vector potential
of a field.

To establish @i[indeterminate1, indeterminate2, ...] as vector entities,
type
@Begin[Example]
        DECLARE([@i[indeterminate1, indeterminate2, ...]], NONSCALAR) 
.end
Translation Lossage ******
.scon 
 ******
Vectors can also be represented as lists of components.

"." is the dot-product operator, "~" is the cross-product operator,
GRAD @Index[GRAD] is the gradient operator, DIV @Index[DIV] is the divergence operator, CURL @Index[CURL] is the curl or rotation operator, and LAPLACIAN @Index[LAPLACIAN] is DIV GRAD.
NOTE: "." is declared to be a commutative operator in the
VECT package!

Most non-controversial simplifications are automatic.  For additional
simplification, there is a function which can be used in the form

Translation Lossage ******
.inline  function(VECTORSIMP,vectorexpression)
 ******
.scon
This function employs additional non-controversial simplifications,
together with various optional expansions according to the settings
of the following global flags:
Translation Lossage ******
.scon 
 ******
EXPANDALL, EXPANDDOT, EXPANDDOTPLUS
Translation Lossage ******
.scon 
 ******
EXPANDCROSS, EXPANDCROSSPLUS, EXPANDCROSSCROSS
Translation Lossage ******
.scon 
 ******
EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD
Translation Lossage ******
.scon 
 ******
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD
Translation Lossage ******
.scon 
 ******
EXPANDCURL, EXPANDCURLPLUS, EXPANDCURLCURL
Translation Lossage ******
.scon 
 ******
EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS, EXPANDLAPLACIANPROD
Translation Lossage ******
.scon 
 ******
All these flags have default value FALSE. The PLUS suffix refers to employing additivity or distributivity.
The PROD suffix refers to the expansion for an operand that is any
kind of product.  EXPANDCROSSCROSS refers to replacing p~(q~r)
with (p.r)*q-(p.q)*r,  and EXPANDCURLCURL refers to replacing
CURL CURL p with  GRAD DIV p + DIV GRAD p.  EXPANDCROSS:TRUE has the 
same effect as EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other
flags, EXPANDPLUS and EXPANDPROD, have the same effect as setting all
similarly suffixed flags true.  When TRUE, another flag named
EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
composition DIV GRAD.  All of these flags are initially FALSE.
For convenience, all of these flags have been declared EVFLAG.

For orthogonal curvilinear coordinates, the global variables
COORDINATES[[X,Y,Z]] @Index[COORDINATES], DIMENSION[3] @Index[DIMENSION],
SF[[1,1,1]] @Index[SF], and SFPROD[1] @Index[SFPROD] are set
by the function invocation

Translation Lossage ******
.inline  function(SCALEFACTORS,coordinatetransform) 
 ******
.scon
Here @i[coordinatetransform] evaluates to the form
[[expression1, expression2, ...], indeterminate1, indeterminat2, ...],
where indeterminate1, indeterminate2, etc. are the curvilinear
coordinate variables and where a set of rectangular Cartesian
components is given in terms of
the curvilinear coordinates by [expression1, expression2, ...].  COORDINATES
is set to the vector [indeterminate1, indeterminate2, ...], and
DIMENSION is set to the length of this vector.  SF[1], SF[2], ...,
SF[DIMENSION] are set to the coordinate scale factors, and SFPROD is
set to the product of these scale factors.  Initially, COORDINATES is
[X, Y, Z], DIMENSION is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1,
corresponding to 3-dimensional rectangular Cartesian coordinates.

To expand an expression into physical components in the current
coordinate system, there is a function with usage of the form

Translation Lossage ******
.inline  function(EXPRESS,expression)
 ******
.scon
The result uses the noun form of any derivatives arising from
expansion of the vector differential operators.
To force evaluation of these derivatives,
the built-in EV function can be used together with the DIFF evflag,
after using the built-in DEPENDS function to establish any new
implicit dependencies.

The scalar potential of a given gradient vector, in the current
coordinate system, is returned as the result of

Translation Lossage ******
.inline  function(POTENTIAL,givengradient)
 ******
.scon
The calculation makes use of the global variable POTENTIALZEROLOC[0] @Index[POTENTIALZEROLOC],
which must be NONLIST or of the form [indeterminatej=expressionj,
indeterminatek=expressionk, ...], the former being equivalent to
the nonlist expression
for all right-hand sides in the latter.  The indicated right-hand
sides are used as the lower limit of integration.  The success of
the integrations may depend upon their values and order.
POTENTIALZEROLOC is initially set to 0.

The vector potential of a given curl vector, in the current
coordinate system, is returned as the result of

Translation Lossage ******
.inline  function(VECTORPOTENTIAL,givencurl)
 ******
.scon
POTENTIALZEROLOC has a similar role as for POTENTIAL, but the order
of the left-hand sides of the equations must be a cyclic permutation
of the coordinate variables.

EXPRESS, POTENTIAL, and VECTORPOTENTIAL can have a second argument
like the argument of SCALEFACTORS, causing a corresponding
invocation of SCALEFACTORS before the other computations.

@Section[Expansion of Rational Expressions]
@Label[eratex]

    The file SHARE1;FACEXP FASL contains several related functions
that provide the user with the ability to structure expressions by
controlled expansion.  Do LOAD(FACEXP);.  This capability is
especially useful when the expression contains variables that have
physical meaning, because it is often true that the most economical
form of such an expression can be obtained by fully expanding the
expression with respect to those variables, and then factoring their
coefficients.  While it is true that this procedure is not difficult
to carry out using standard MACSYMA functions, additional fine-tuning
may also be desirable, and these finishing touches can be more
difficult to apply.  The function FACSUM and its related forms provide
a convenient means for controlling the structure of expressions in
this way.  Another function, COLLECTTERMS, can be used to add two or
more expressions that have already been simplified to this form,
without resimplifying the whole expression again.  This function is
particularly useful when the expressions are large and address space
or cpu time is in short supply.

    For a complete demonstration of the use of these functions,
BATCH(FACEXP,DEMO,DSK,SHARE1) Brief descriptions of these functions
and their switches follow.

@fcn[Name="FACSUM", Args="exp,arg1,arg2,..."])
returns a form of exp which depends on the @i[argi].  The @i[argi] can be any
form suitable for RATVARS, or they can be lists of such forms.  If the
@i[argi] are not lists, then the form returned will be fully expanded with
respect to the @i[argi], and the coefficients of the @i[argi] will be
factored.  These coefficients will be free of the @i[argi], except perhaps
in a non-rational sense.  If any of the @i[argi] are lists, then all such
lists will be combined into a single list, and instead of calling
FACTOR on the coefficients of the @i[argi], FACSUM will call itself on
these coefficients, using this newly constructed single list as the
new @i[argi] for this recursive call.  This process can be repeated to
arbitrary depth by nesting the desired elements in lists.

It is possible that one may wish to FACSUM with respect to more
complicated subexpressions, such as LOG(X+Y).  Such arguments are also
permissible.  With no variable specification, for example FACSUM(exp),
the result returned is the same as that returned by RATSIMP(exp).

Occasionally the user may wish to obtain any of the above forms for
expressions which are specified only by their leading operators.  For
example, one may wish to FACSUM with respect to all LOG's.  In this
situation, one may include among the @i[argi] either the specific LOG's
which are to be treated in this way, or alternatively, either the
expression OPERATOR(LOG) or 'OPERATOR(LOG).  If one wished to FACSUM
the expression EXP with respect to the operators OP1, OP2, ..., OPn,
one would evaluate FACSUM(EXP, OPERATOR(OP1, OP2,...OPn)).  The
OPERATOR form may also appear inside list arguments.

In addition, the setting of the switches FACSUM_COMBINE and
NEXTLAYERFACTOR may affect the result of FACSUM as follows:

NEXTLAYERFACTOR[FALSE] @Index[NEXTLAYERFACTOR] if TRUE will force the recursive calls of
FACSUM to be applied to the factors of the factored form of the
coefficients of the @i[argi].  If FALSE then FACSUM will be applied to
each coefficient as a whole whenever recursive calls to FACSUM occur as
described above.  In addition, inclusion of the atom NEXTLAYERFACTOR
in the argument list of FACSUM has the effect of NEXTLAYERFACTOR:TRUE,
but for the next level of the expression ONLY.  Since NEXTLAYERFACTOR
is always bound to either TRUE or FALSE, it must be presented
single-quoted whenever it is used in this way.

FACSUM_COMBINE[TRUE] @Index[FACSUM_COMBINE] controls the form of the final result
returned by FACSUM when its argument is a quotient of polynomials.  If
FACSUM_COMBINE is FALSE then the form will be returned as a fully
expanded sum as described above, but if TRUE, then the form returned
is a ratio of polynomials, with each polynomial in the form described
above.  The TRUE setting of this switch is useful when one wants to
FACSUM both the numerator and denominator of a rational expression,
but does not want the denominator to be multiplied through the terms
of the numerator.


@fcn[Name="FACTORFACSUM", Args="exp, arg1, arg2,  ...argN"])
returns a form of exp which is obtained by calling FACSUM on the
factors of exp with the @i[argi] as arguments.  If any of the factors of
exp is raised to a power, both the factor and the exponent will be
processed in this way.


@fcn[Name="COLLECTTERMS", Args="arg1,  arg2, ...  argn"])
If several expressions have been simplified with FACSUM, FACTORFACSUM,
and they are to be added
together, it may be desirable to combine them using the function
COLLECTERMS.  COLLECTERMS can take as arguments all of the arguments
that can be given to these other associated functions with the
exception of NEXTLAYERFACTOR, which has no effect on COLLECTTERMS.
The advantage of COLLECTTERMS is that it returns a form similar to
FACSUM, but since it is adding forms that have already been processed
by FACSUM, it does not need to repeat that effort.  This capability is
especially useful when the expressions to be summed are very large.


@Section[Dimensional Analysis]
@Label[dimanal]

The file DIMEN > contains functions for automatic dimensional analysis,
and file DIMEN DEMO contains a demonstration.  Usage is of the form

Translation Lossage ******
.inline  function(NONDIMENSIONALIZE,|list of physical quantities|)
 ******

The returned value is a sufficient list of nondimensional products of
powers of the physical quantities.  A physical relation between only
the given physical quantities must be expressible as a relation between
the nondimensional quantities.  There are usually fewer nondimensional
than physical quantities, which reduces the number of experiments or
numerical computations necessary to establish the physical relation to
a specified resolution, in comparison with the number if all but one
dependent physical variable were independently varied.  Also, the 
absence of any given physical quantity in the output reveals that
either the quantity is irrelevant or others are necessary to describe
the relation.


The program already knows an extensive number of relations between
physical quantities, such as  VELOCITY=LENGTH/TIME.  The user may over-ride or supplement the prespecified relations by typing

Translation Lossage ******
.inline  function(DIMENSION,|equation or list of equations|)
 ******
.scon
where each equation is of the form  indeterminate=expression, where
expression is a product or quotient of powers of none or more of the
indeterminates   CHARGE, TEMPERATURE, LENGTH, TIME, or MASS.  To see
if a relation is already established type

Translation Lossage ******
.once  center
 ******
GET(indeterminate, 'DIMENSION);

The result of NONDIMENSIONALIZE usually depends upon the value of the
global variable %PURE, which is set to a list of none or more of the
indeterminates  ELECTRICPERMITTIVITYOFAVACUUM, BOLTZMANNSCONSTANT,
SPEEDOFLIGHT, PLANCKSCONSTANT, GRAVITYCONSTANT, corresponding to the
relation between charge and force, temperature and energy, length and
time, length and momentum, and the inverse-square law of gravitation
respectively.  Each included relation is used to eliminate one of
CHARGE, TEMPERATURE, LENGTH, TIME, or MASS from the dimensional basis.
To avoid omission of a possibly relevant nondimensional grouping,
either include the relevant constant in %PURE or in the argument
of NONDIMENSIONALIZE if the corresponding physical effect is thought to
be relevant to the problem.  However, the inclusion of unnecessary
constants, especially the latter three, tends to produce irrelevant or
misleading dimensionless groupings, defeating the purpose of
dimensional analysis.  As an extreme example, if all five constants are
included in %PURE, all physical quantities are already dimensionless.
%PURE is initially set to '[ELECTRICPERMITTIVITYOFVACUUM,
BOLTZMANNSCONSTANT], which is best for most engineering work.
%PURE must not include any of the other 3 constants without also
including these 2.

@Section[Analytic Optimization]
@Label[Anopt]


We now describe  a  package for finding the stationary points of a multivariate objective function, either unconstrained or subject
to equality and/or inequality constraints.
Translation Lossage ******
.scon 
 ******
RELEVANT FILES: OPTMIZ >  is a MACSYMA batch file containing the functions and option settings for optimization.  OPTMIZ DEMO  is a MACSYMA batch file demonstrating various ways of using the optimization functions. OPTMIZ OUTPUT  is a text file listing  OPTMIZ DEMO together with the output that it produces when executed.

To use this package from a MACSYMA, first type  BATCH(OPTMIZ, ">", DSK, SHARE)
Then the following command is available:

Translation Lossage ******
.inline  function(STAP,|OBJECTIVE, LEZEROS, EQZEROS, DECISIONVARS|);
 ******

*** begin indent  0,5;preface 0; hereOBJECTIVE is an expression denoting the objective function or the
label of such an expression.

LEZEROS is a list of expressions which are constrained to be less
than or equal to zero.  Use [] if no such constraints.

EQZEROS is a list of expressions which are constrained to equal zero, or
the label of such a list.  Use [] if there are no such constraints.

DECISIONVARS is a list of the decision variables or the label of such
a list.  One may use [] if all variables in objective and constraints
are decision variables. For convenience, brackets may be omitted from
one-expression lists, and trailing [] arguments may be omitted.

ROOTSEPSILON may affect the accuracy of results computed by  SOLVE
and REALROOTS  within STAP.  The default value of 1.0E-7 for this
MACSYMA global variable is as small as practical for pdp single-
precision floating-point arithmetic.  Larger values save cpu time.
*** begin indent ends here
The class of functions that may be used and the practical limitations
on the number of decision variables and constraints is primarily 
dependent upon the capabilities of the built-in SOLVE function, 
which is still under development.

@Section[Variational Optimization]
@Label[optvar]

This section describes how to use a MACSYMA variational optimization
package to analytically solve problems from the calculus of variations
and the maximum principle, including optimal control.

To use this package in a MACSYMA, first type  BATCH(OPTVAR,">", DSK, SHARE)
 or LOADFILE(OPTVAR, LISP, DSK, SHARE). 

To derive the Euler-Lagrange equations for a calculus-of-variations
problem, type

Translation Lossage ******
.inline  function(EL,|F, YLIST, TLIST|);
 ******
.scon
F  is an expression or the label of an expression for the integrand
   of the stationary functional, augmented by Lagrange multipliers
   times the integrands of any isoperimetric constraints and/or
   differential expressions constrained to equal zero.  The multipliers
   should be written as functions of the independent variables in the
   latter case.
Translation Lossage ******
.scon 
 ******
YLIST  is a list of the dependent variables, or the label thereof.
Translation Lossage ******
.bcon 
 ******
TLIST  is a list of the independent variables, or the label thereof.
Translation Lossage ******
.scon 
 ******
For convenience, square brackets may be omitted from 1-element lists.
EL displays one or more E-labeled equations, then returns a list
of the E-labels.  These equations are the Euler-Lagrange equations,
perhaps together with first integrals corresponding to conservation
of energy and/or conservation of momentum.  The former will contain a
constant of integration K[0], whereas the latter will contain constants
of integration K[I], with positive I.  The latter will immediately
follow the corresponding Euler-Lagrange equation.

OPTVAR DEMO or OPTVAR OUTPUT illustrates some ways that the
resulting differential equations may be solved analytically.

To derive the Hamiltonian and auxiliary differential equations for
an optimal control problem, type

Translation Lossage ******
.inline  function(HAM,ODES)
 ******
.scon
ODES  is a list of the first-order differential equations that govern the state variables.  Each differential equation must be of the form
@Begin[Example]
                'D(Y,T) = EXPRESSION
@End[Example]
Translation Lossage ******
.scon 
 ******
where  Y  is one of the dependent variables,  T is the independent
variable, and EXPRESSION  depends upon the independent, dependent, and
control variables.

HAM displays two or more E-labeled expressions, then returns a list
of the E-labels.  The first expression is the Hamiltonian, and the
other expressiona are the auxiliary diferential equations,
together with their general solutions,  AUX[I] = K[I], whenever the
Ith differential equation is of the trivial form  'D(AUX[I],T) = 0.
The K[I] are undetermined constants of integration.

HAM is directly suitable for the autonomous time-optimal problem.
Other problems may be converted to this form by introducing extra state
variables, as described in most optimal-control texts or in the report
referenced in  OPTVAR OUTPUT  and OPTVAR DEMO.

@Section[Qualitative Analysis]
@Label[qual]

QUAL > contains MACSYMA functions for qualitative analysis
of an expression, QUAL DEMO contains a demonstration, and 
QUAL OUT contains the output from executing the demo.

To use the functions do  ALLOC(2); LOADFILE(STOUTE,">",DSK,MRG); BATCH(QUAL, ">", DSK, SHARE);

Top-level usage is of the form
Translation Lossage ******
.inline  function(QUAL,|<expression>, <variables>|)
 ******
.scon
where <expression> is any given expression, <variables> is a given indeterminate or list of indeterminates.  If omitted, this argument defaults to all of the indeterminates in the first argument.

QUAL returns a list of E-labels of displayed equations, each of the
form 
@Begin[Example]
        <property name> = <property value>
@End[Example]
Translation Lossage ******
.scon 
 ******
where  <property name> is one of the second-level function names below, and <property value> is the value returned by that function.  These second-level functions may also be used directly.  Usage is of the form
@Begin[Example]
            REVELATION(<expression>, <minimum>, <maximum>);
            BOUNDS(<expression>);
            SLOPES(<expression>, <variables>);
            CURVATURE(<expression>, <variables>);
            SYMMETRY(<expression>, <variables>);
            PERIODS(<expression>, <variables>);
            ZEROSANDPOLES(<expression>, <variables>);
            STATIONARYPOINTS(<expression>, <variables>);
            LIMITS(<expression>, <variables>);
@End[Example]
Translation Lossage ******
.scon 
 ******
where <expression>, <variables>, and their defaults are as for QUAL.


@Section[Floating Point Pretty Printing]
@Label[fppp]

SHARE;FORMAT FASL is a package for pretty printing of floating point numbers.
Do LOAD(FORMAT); to access it.

Nothing is changed unless you set FLOATFORMAT[FALSE] @Index[FLOATFORMAT] to TRUE.
Then all floating point numbers are printed in a field of
FLOATWIDTH[10] @Index[FLOATWIDTH] character positions with FLOATPREC[3] @Index[FLOATPREC]
significant figures and FLOATINT[1] @Index[FLOATINT] figures before the decimal
point.  (FLOATINT may also be a list of 3 integers, in which the first
gives the no. of digits before the decimal point and the other two
specify the range of powers of 10 for which the "E" format is not
used.)

Alternately you can do FLOATFORMAT:'F; in which case the "E" notation
is not used and FLOATFRAC figures appear after the decimal point.
The total width is again FLOATWIDTH.

In either case if FLOATWIDTH is 0, then only the digits themselves will
be part of the number.  (I.e there will be no leading spaces.)

The printing is also governed by FLOATOPTIONS[FALSE] @Index[FLOATOPTIONS].  This
may be set to a list of items, which should be any of:
"+"(15)print + for positive integers
LEFT(15)place sign in leftmost column instead of by leftmost digit
0(15)print trailing zeros
E(15)force E format for fixed precision output
E.g. FLOATOPTIONS:["+",'E];

If you specify too large a precision, or small a width, then the number
will appear in the default manner.

Currently the MACSYMA display package (which prints D and E lines),
PRINT and CONCAT will use this method of printing floating point numbers.
SAVE, STRING and STRINGOUT do not, so there should be no loss of precision
in doing a SAVE followed by a LOADFILE or a STRINGOUT followed by a
BATCH.

For fuller documentation do :PRINT LIBDOC;FFORMA >
which documents the Fortran-style-FORMAt package (written by JONL), and 
is the support for the formatter herein discussed.
There might be a better user interface provided if there is a consensus
on how it should be done.

Example:
@Begin[Example]
(C1) LOAD(FORMAT)

(C2) FLOATFORMAT:TRUE

(C3) PI:EV(%PI,NUMER);

(D3)                                    3.14

(C4) FOR I FROM -10 THRU 10 DO PRINT(10^I*PI);
  3.14E-10 
   3.14E-9 
   3.14E-8 
   3.14E-7 
   3.14E-6 
   3.14E-5 
   3.14E-4 
   0.00314 
    0.0314 
     0.314 
      3.14 
      31.4 
   3.14E+2 
   3.14E+3 
   3.14E+4 
   3.14E+5 
   3.14E+6 
   3.14E+7 
   3.14E+8 
   3.14E+9 
  3.14E+10 
(D4)                                 DONE

(C5) FLOATOPTIONS:['E]

(C6) FOR I FROM -10 THRU 10 DO PRINT(10^I*PI);
  3.14E-10 
   3.14E-9 
   3.14E-8 
   3.14E-7 
   3.14E-6 
   3.14E-5 
   3.14E-4 
   3.14E-3 
   3.14E-2 
   3.14E-1 
   3.14E+0 
   3.14E+1 
   3.14E+2 
   3.14E+3 
   3.14E+4 
   3.14E+5 
   3.14E+6 
   3.14E+7 
   3.14E+8 
   3.14E+9 
  3.14E+10 
(D6)                                 DONE

(C7) FLOATFORMAT:'F

(C8) FLOATOPTIONS:FALSE

(C9) FOR I FROM -10 THRU 10 DO PRINT(10^I*PI);
      0.00 
      0.00 
      0.00 
      0.00 
      0.00 
      0.00 
      0.00 
      0.00 
      0.03 
      0.31 
      3.14 
     31.42 
    314.16 
   3141.59 
  31415.93 
 314159.26 
3141592.66 
31415926.5 
3.14159265E+8 
3.14159265E+9 
3.14159265E+10 
(D9)                                 DONE
@End[Example]

Comments etc. to CFFK@MC

@Section[Units Conversion]
@Label[units]
Do LOAD(UNITS) to obtain assignments for automatic conversion to MKS
metric units.  Usage example:  5*FT + METER + CM; simplifies to
2.534*METER .

Erroneously dimensionally inhomogeneous expressions are revealed by
uncollected terms.  For example, 5*FT + SECOND;  does not simplify to one term.

The supplied conversions comprise a rather complete set, but it should
be clear how to supplement them or produce an analagous set for
conversion to other units.

@Section[The Eigen Package]
@Label[eigen]

Doing LOAD(EIGEN) loads the functions to compute right eigenvectors,
right unit eigenvectors, eigenvalues, and similarity transforms.  It
also is able to handle multiple eigenvalues and the eigenvectors
corresponding to those eigenvalues.  It will work with any square
matrix (not necessarily symmetric or hermitian) and will tell whether
the matrix is diagonalizable.  The calculated eigenvectors and the
unit eigenvectors of the matrix are the RIGHT eigenvectors and the
RIGHT unit eigenvectors respectively.  It was written by Yekta Gursel,
and bugs found should be sent to YEKTA@MC.  (You should be aware of
the fact that this program uses the MACSYMA functions SOLVE and ALGSYS
and if SOLVE can not find the roots of the characteristic polynomial
of the matrix or if it generates a rather messy solution the EIGEN
package may not produce any useful results.  More info on this will be
given in the description of the commands.)

Description of the functions:

@fcn[Name="CONJUGATE", Args="X"]
returns the complex conjugate of its argument.
(Note that %I's in the expressions should be explicit, since there is
no complex variable declaration in MACSYMA at the present time.  This
is true for all the functions in this package.)


@fcn[Name="INNERPRODUCT", Args="X,Y"])
takes two LISTS of equal length as its arguments and
returns their inner (scalar) product defined by
(Complex Conjugate of X).Y (The "dot" operation is the same
as the usual one defined for vectors).


@fcn[Name="UNITVECTOR", Args="X"]
takes a LIST as its argument and returns a  unit list.
(i.e. a list with unit magnitude).


@fcn[Name="COLUMNVECTOR", Args="X"]
takes a LIST as its argument and returns a column vector the
components of which are the elements of the list.  The first element is
the first component,...etc...(This is useful if you want to use parts 
of the outputs of the functions in this package in matrix calculations.)


@fcn[Name="GRAMSCHMIDT", Args="X"]
takes a LIST of lists the sublists of which are of
equal length and not necessarily orthogonal (with respect to the
innerproduct defined above) as its argument and returns a similar
list each sublist of which is orthogonal to  all others.
(Returned results may contain integers that are factored.
This is due to the fact that the MACSYMA function FACTOR is 
used to simplify each substage of the Gram-Schmidt algorithm.
This prevents the expressions from getting very messy and
helps to reduce the sizes of the numbers that are produced
along the way.)


@fcn[Name="EIGENVALUES", Args="MAT"]
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the list of eigenvalues of
the matrix and the other sublist of which is the list of the
multiplicities of the eigenvalues in the corresponding order.
The MACSYMA function SOLVE is used here to find the roots of
the characteristic polynomial of the matrix.  Sometimes SOLVE
may not be able to find the roots of the polynomial;in that
case nothing in this package except CONJUGATE, INNERPRODUCT,
UNITVECTOR, COLUMNVECTOR and GRAMSCHMIDT will work unless
you know the eigenvalues.
In some cases SOLVE may generate very messy eigenvalues.  You may
want to simplify the answers yourself before you go on.  There
are provisions for this and they will be explained below.
(This usually happens when SOLVE returns a not-so-obviously
real expression for an eigenvalue which is supposed to be real.)


@fcn[Name="EIGENVECTORS", Args="MAT"]
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the output of the EIGENVALUES 
command and the other sublists of which are the eigenvectors
of the matrix corresponding to those eigenvalues respectively.
The flags that affect this function are :

NONDIAGONALIZABLE[FALSE] @Index[NONDIAGONALIZABLE] will be set to TRUE or FALSE depending 
on whether the matrix is nondiagonalizable or diagonalizable after
an EIGENVECTORS command is executed.

HERMITIANMATRIX[FALSE] @Index[HERMITIANMATRIX] If set to TRUE will cause the degenerate
eigenvectors of the hermitian matrix to be orthogonalized using
the Gram-Schmidt algorithm.

KNOWNEIGVALS[FALSE] @Index[KNOWNEIGVALS] If set to TRUE the EIGEN package will assume
the eigenvalues of the matrix are known to the user and stored
under the global name LISTEIGVALS.  LISTEIGVALS should be set to
a list similar to the output of the EIGENVALUES command.
(The MACSYMA function ALGSYS is used here to solve for the 
eigenvectors. Sometimes if the eigenvalues are messy, ALGSYS may
not be able to produce a solution.  In that case you are advised
to try to simplify the eigenvalues by first finding them using
EIGENVALUES command and then using whatever marvelous tricks you
might have to reduce them to something simpler.  You can then use 
the KNOWNEIGVALS flag to proceed further.)


@fcn[Name="UNITEIGENVECTORS", Args="MAT"]
takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the output of the EIGENVALUES
command and the other sublists of which are the unit eigenvectors
of the matrix corresponding to those eigenvalues respectively.
The flags mentioned in the description of the EIGENVECTORS command
have the same effects in this one as well.  In addition there is one
more flag which may be useful :

KNOWNEIGVECTS[FALSE] @Index[KNOWNEIGVECTS] If set to TRUE the EIGEN package will assume that
the eigenvectors of the matrix are known to the user and are stored
under the global name LISTEIGVECTS @Index[LISTEIGVECTS].  LISTEIGVECTS should be set to
a list similar to the output of the EIGENVECTORS command.
(If KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is
given the setting of the flag NONDIAGONALIZABLE may not be correct.
If that is the case please set it to the correct value.  The author
assumes that the user knows what he is doing and will not try to 
diagonalize a matrix the eigenvectors of which do not span the
vector space of the appropriate dimension...)


@fcn[Name="SIMILARITYTRANSFORM", Args="MAT"]
takes a MATRIX as its argument and returns a list
which is the output of the UNITEIGENVECTORS command.  In addition if
the flag NONDIAGONALIZABLE is FALSE two global matrices LEFTMATRIX
and RIGHTMATRIX will be generated.  These matrices have the  property
that LEFTMATRIX.MAT.RIGHTMATRIX is a  diagonal matrix with the
eigenvalues of MAT on the diagonal.  If NONDIAGONALIZABLE
is TRUE these two matrices will not be generated.
If the flag HERMITIANMATRIX is TRUE then LEFTMATRIX is the
complex conjugate of the transpose of  RIGHTMATRIX.  Otherwise
LEFTMATRIX is the inverse of RIGHTMATRIX.  RIGHTMATRIX
is the matrix the columns of which are the unit eigenvectors of MAT.
The other flags have the same effects since SIMILARITYTRANSFORM
calls the other functions in the package in order to be able to
form RIGHTMATRIX...


Finally, for some of you who may think that the names of the 
functions are too long, there are some aliases (In the following
list " := "  means  "is equivalent to".). Note that using these may 
make your code pretty unreadable, you'll save 50% in typing though.

CONJ(X):= CONJUGATE(X)

INPROD(X,Y):= INNERPRODUCT(X,Y)

UVECT(X):= UNITVECTOR(X)4

COVECT(X):= COLUMNVECTOR(X)

GSCHMIT(X):= GRAMSCHMIDT(X)

EIVALS(MAT):= EIGENVALUES(MAT)

EIVECTS(MAT):= EIGENVECTORS(MAT)

UEIVECTS(MAT):= UNITEIGENVECTORS(MAT)

SIMTRAN(MAT):= SIMILARITYTRANSFORM(MAT)


@Section[Functions for Integration]
@Label[funint]
@SubSection[Integration of Special Forms]
@Label[intspec]


INTSCE LISP contains a routine, written by Richard Bogen, for integrating products of sines, cosines and exponentials of the form
@Begin[Example]
                EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M
@End[Example]
The call is
Translation Lossage ******
.inline  function(INTSCE,|expr,var|).
 ******
@i[expr] may be any expression, but if it is not in the above
form then the regular integration program will be invoked
if the switch ERRINTSCE[FALSE] @Index[ERRINTSCE] is FALSE.  If it is TRUE
then INTSCE will err out.

The LISP file contains the main program INTSCE which does
the pattern matching and error checking and a subroutine
SCEINT @Index[SCEINT] which does the actual integration.  
Do LOAD(INTSCE); to use this program.


@SubSection[Integral Equations]
@Label[inteqs]

The following package was written by Richard Bogen based on some routines of David Stoutemyer.   It is still an experimental version, untranslated and uncompiled at present.  

To load the package, do LOAD(INTEQN).

The usage is very simple. The main function is called IEQN.  It takes
five arguments though only the first two are required.  If trailing
arguments are omitted they will default to preset values which will be
announced.

Two types of equations are considered. An integral equation of the @i[second kind] is of the form:
@Begin[Example]
@Hinge
                              B(X)
                             /
                             [
(D3)       P(X) = Q(X, P(X), I     W(X, U, P(X), P(U)) dU)   .
                             ]
                             /
                              A(X)


@End[Example]
Translation Lossage ******
.scon 
 ******
An integral equation of the @i[first kind] is of the form:
@Begin[Example]
@Hinge
                     B(X)
                    /
                    [
(D4)                I     W(X, U, P(U)) dU = F(X)
                    ]
                    /
                     A(X)


@End[Example]
Translation Lossage ******
.scon 
 ******
The unknown function in these equations is P(X) while Q,W,A, and B are given
functions of the independent variable.
Although these are the general forms, most of the solution
techniques require particular forms of Q and W.

The techniques used are:

@i[For SECONDKIND equations]:
*** begin narrow  8,5 here.SCON
FINITERANK: for degenerate (or separable) integrands.
Translation Lossage ******
.bcon 
 ******
DIFFEQN: reduction to differential equation.
Translation Lossage ******
.bcon 
 ******
TRANSFORM: Laplace Transform for convolution types.
Translation Lossage ******
.bcon 
 ******
FREDSERIES: Fredholm-Carleman series for linear equations.
Translation Lossage ******
.bcon 
 ******
TAILOR: Taylor series for quasi-linear variable-limit equations.
Translation Lossage ******
.bcon 
 ******
NEUMANN: Neumann series for quasi-second kind equations.
Translation Lossage ******
.bcon 
 ******
COLLOCATE: collocation using a power series form for P(X) evaluated at equally spaced points.
*** begin narrow ends here
Translation Lossage ******
.scon 
 ******
@i[For FIRSTKIND equations:]
*** begin narrow  8,5 here.SCON
FINITERANK: for degenerate integrands.
Translation Lossage ******
.bcon 
 ******
DIFFEQN: reduction to differential equation.
Translation Lossage ******
.bcon 
 ******
ABEL: for singular integrands.
Translation Lossage ******
.bcon 
 ******
TRANSFORM: see above
Translation Lossage ******
.bcon 
 ******
COLLOCATE: see above
Translation Lossage ******
.bcon 
 ******
FIRSTKINDSERIES: iteration technique similar to Neumann series.
*** begin narrow ends here
Translation Lossage ******
.scon 
 ******
Also, differentiation is used in certain cases to transform a FIRSTKIND into a SECONDKIND.
Translation Lossage ******
.scon 
 ******
The calling sequence is
@fcn[Name="IEQN", Args="ie,unk,tech,n,guess"])
where @i[ie] is the integral equation; @i[unk] is the unknown
function; @i[tech] is the technique to be tried from those given above
(@i[tech] = FIRST means: try the first technique which finds a
solution; @i[tech] = ALL means: try all applicable techniques); @i[n]
is the maximum number of terms to take for TAYLOR, NEUMANN,
FIRSTKINDSERIES, or FREDSERIES (it is also the maximum depth of
recursion for the differentiation method); @i[guess] is the initial
guess for NEUMANN or FIRSTKINDSERIES.

Default values for the third through fifth parameters are:
*** begin indent  8,12; here@i[tech]: FIRST;

@i[n]: 1;

@i[guess]: NONE,  which  will cause NEUMANN and FIRSTKINDSERIES to use F(X)  as an initial guess.
*** begin indent ends here
Translation Lossage ******
.scon 
 ******
The value returned by IEQN is a list of labels of solution lists. The solution lists are printed as they are found unless the variable IEQNPRINT[TRUE] @Index[IEQNPRINT] is set to FALSE. These lists are of the form
Translation Lossage ******
.once  center
 ******
[SOLUTION, TECHNIQUE USED, NTERMS, FLAG]
Translation Lossage ******
.scon 
 ******
where FLAG is absent if the solution is exact.  Otherwise, it is the word APPROXIMATE or INCOMPLETE corresponding to an inexact or non-closed form solution,
respectively. If a series method was used, NTERMS gives the
number of terms taken (which could be less than the @i[n] given to IEQN if an error prevented generation of further terms).


For examples, do LOAD(INTEXS) which will load an array
called EQ with about 43 sample integral equations. Then try
IEQN(EQ[1],P(X)), IEQN(EQ[30],P(X),ALL), for instance.


@SubSection[Newton-Cotes Quadrature]
@Label[ncq]

The file SHARE1;QQ FASL contains a function QUANC8 which can take either 
3 or 4 arguments.

@fcn[Name="QUANC8", Args="'function name,lo,hi"])
The 3 arg version computes the integral of the function 
specified as the first argument over the interval from @i[lo] to @i[hi.]  The function name should be quoted.

@fcn[Name="QUANC8", Args="f(var) or expression in var,var,lo,hi"])
The 4 arg version will compute the integral of the function or expression
(first arg) with respect to the variable (second arg) over the interval 
from @i[lo] to @i[hi].


The method used is the Newton-Cotes 8th order polynomial quadrature, and 
the routine is adaptive. It will thus spend time dividing the interval only 
when necessary to achieve the error conditions specified by the global
variables QUANC8_RELERR[1.0e-4] @Index[QUANC8_RELERR] and QUANC8_ABSERR[1.0e-8] @Index[QUANC8_ABSERR] which give
the relative error test 

|integral(function)-computed value|< QUANC8_RELERR*|integral(function)|

and the absolute error test 

|integral(function)-computed value|<QUANC8_ABSERR. 

The error from each subinterval is estimated and the contribution from a 
subinterval is accepted only when the integral over the subinterval satisfies
the error test over the subinterval. The total estimated error of the integral
is contained in the global variable QUANC8_ERREST[0.0] @Index[QUANC8_ERREST]. 

The global variable QUANC8_FLAG[0.0] @Index[QUANC8_FLAG] will contain valuable 
information if the computation fails to satisfy the error conditions. The 
integer part will tell you how many subintervals failed to converge and the 
fractional part will tell you where the singular behavior is, as follows: 
singular point=lo+(1.-frac part)*(hi-lo).
Thus QUANC8(tan(x),x,1.57,1.6); gives frac=.97 so trouble is at 1.57+.03*.03=
1.5709 (=half pi). If QUANC8_FLAG is not 0.0, you should be cautious in using 
the return value, and should try ROMBERG or a Simpson method and see if the
result checks. Analysis of possible singular behavior might be advisable. You
may get QUANC8_FLAG=@i[integer].0 and an error message (such as division by 0)
when a singular point is hit in the interval. You will have to find the
singularity and eliminate it before QUANC8 will get an answer. Functions 
which have very large derivatives may throw the error estimate way off and
cause the wrong points to be used, and a wrong answer returned. Try
ROMBERG(exp(-.002*x@-[50])*cos(x)@-[50],x,0.,100.); with the default tolerance, and
QUANC8(exp(-.002*x@-[50])*cos(x)@-[50],x,0.,100.); with QUANC8_RELERR=1.e-7 and 1.e-8.
The last result is consistent with romberg while the previous one is off by
a factor of 2! This is due to the bad behavior of the derivatives near
x=10.0 which cause the adaptive routine to have trouble. If you use 
QUANC8('f,a,c)+QUANC8('f,c,b) where a<c<b, you will do better in such cases.

Typing a control-right-bracket () will give a printout of where the 
computation is at the moment, and how much time has been used.

You can do BATCH("QQ DEMO"); for some comparisons with the ROMBERG numerical
integrator (which is not adaptive). Note that ROMBERG usually gives more 
accurate answers for comparable tolerances, while QUANC8 will get the same 
answer faster even with a smaller tolerance, because ROMBERG subdivides the
whole interval if the total result is not within error tolerance, while QUANC8
improves only where needed, thus saving many function calls. ROMBERG will also
fail to converge when oscillatory behavior is overwhelming, while QUANC8 will 
adapt in the regions as it sees fit. (The global variable ROMBERGMIN is 
designed to allow you a minimum number of function calls in such cases, so 
that exp(-x)*sin(12*x) can be integrated from 0 to 4*%pi without erroneously 
giving 0. from the first few function calls.)

To make your MACSYMA user function callable in the fastest way, you must use
MODE_DECLARE and then translate and compile the function. Read TRANSL;TRANSL
NEWS for info on this, or ask me for more info. The speed of the computation
may be increased by well over an order of magnitude when compilation is used.
If you do multiple integrals, it is really necessary to compile the function
in order to avoid the time spent on function calls. A sample use of QUANC8
for a double integral is in the BATCH("QQ DEMO"); and compilation is nearly 
a hundred times faster in doing the work!
Comments, bugs, etc. should be sent to LPH@MIT-MC.

@SubSection[Antidifferention]
@Label[santid]

        Do LOAD(ANTID); to access a routine for evaluating integrals of
expressions involving an arbitrary unspecified function and its derivatives.
after loading the file, the function ANTIDIFF is defined:

@fcn[Name="ANTIDIFF", Args="g,x,u(x)"])
returns the integral of g with respect to x, where g is an
expression involving u(x) and its derivatives.  u(x) may be arbitrary.


        The file also defines the functions NONZEROANDFREEOF @Index[NONZEROANDFREEOF] and
LINEAR @Index[LINEAR] as well as ANTID @Index[ANTID].  ANTID is the same as ANTIDIFF
except that it returns a list of two parts, the first part is the
integrated part of the expression and the second part of the list is
the non-integrable remainder.

@SubSection[Elliptical Integrals]
@Label[ellipt]

Numerical routines for Elliptic Functions and Complete Elliptic
Integrals

The notation of Abramowitz and Stegun, Chapters 16 & 17 is used.

To use this package, do LOAD(ELLIPT);

@i[Caveat:  At present all arguments MUST be floating point.
You'll get nonsense otherwise.]

Translation Lossage ******
.once  center
 ******
Jacobian elliptic functions
Translation Lossage ******
.skip 
 ******
.function(AM,|U,M|)
amplitude with modulus M

@fcn[Name="AM1", Args="U,M1"])
ampiltude with complementary modulus M1

Translation Lossage ******
.skip  continue
 ******
Note: AM(U,M):=AM1(U,1-M); so use AM1 if M ~ 1
Translation Lossage ******
.skip 
 ******
The following functions are pre-defined in the file.  Other functions
(e.g. CD, NS) may be defined in a similar fashion by the user:
@Begin[Example]
SN(U,M):=SIN(AM(U,M));
CN(U,M):=COS(AM(U,M));
DN(U,M):=SQRT(1-M*SN(U,M)^2);
@End[Example]
Translation Lossage ******
.skip  once center
 ******
Complete Elliptic Integrals
Translation Lossage ******
.skip 
 ******
.function(ELLIPTK,M)
Complete elliptic integral of first kind

@fcn[Name="ELLIPTK1", Args="M1"]
Same but with complementary modulus. 

Translation Lossage ******
.skip  continue
 ******
Note: ELLIPTK(M):=ELLIPTK1(1-M); so use if M ~ 1
Translation Lossage ******
.skip 
 ******
.function(ELLIPTE,M)
Complete elliptic integral of second kind

@fcn[Name="ELLIPTE1", Args="M1"]
Same but with complementary modulus. 

Translation Lossage ******
.skip  continue
 ******
Note: ELLIPTE(M):=ELLIPTE1(1-M); so use if M ~ 1

@Section[Numerical Techniques]
@Label[numtech]
@SubSection[Numerical Integration]
@Label[brmbg]

A Bigfloated version of the ROMBERG function (see @Ref[numint])
is gotten by saying:
@Begin[Example]
LOAD(BRMBRG);
@End[Example]
The name of the function in it is BROMBERG.  It's use is identical to
the ROMBERG function except that ROMBERGTOL is called BROMBERGTOL
(default value 1.B-4) ROMBERGABS is called BROMBERGABS (default value
0.0B0) ROMBERGIT is called BROMBERGIT (default value 11), and
ROMBERGMIN is call BROMBERGMIN (default value 0).

@SubSection[Double Integrals using Simpson's Rule]
@Label[diusr]

The file SHARE1;DBLINT FASL contains a double-integral routine which
was written in top-level MACSYMA and then translated and compiled to
machine code.  Use LOAD(DBLINT); to access this package.  It uses the
Simpson's Rule method (see note below) in both the x and y directions
to calculate
@Begin[Example]
/B /S(X)
|  |
|  |    F(X,Y) DY DX .
|  |
/A /R(X)
@End[Example]
A call to DBLINT would be:
DBLINT @Index[DBLINT]('F,'R,'S,@i[a],@i[b],);.

The function F(X,Y) must be a translated or compiled function of two
variables, and R(X) and S(X) must each be a translated or compiled
function of one variable, while @i[a] and @i[b] must be floating point
numbers. The routine has two global variables which determine the
number of divisions of the x and y intervals: DBLINT_X[10] @Index[DBLINT_X] and DBLINT_Y[10] @Index[DBLINT_Y],
both of which are initially 10, and can be changed independently to
other integer values (there are 2*DBLINT_X+1 points computed in the x
direction, and 2*DBLINT_Y+1 in the y direction).

The routine subdivides the X axis and then for each value of X it
first computes R(X) and S(X); then the Y axis between R(X) and S(X) is
subdivided and the integral along the Y axis is performed using
Simpson's Rule; then the integral along the X axis is done using
Simpson's Rule with the function values being the Y-integrals. This
procedure may be numerically unstable for a great variety of reasons,
but is reasonably fast: avoid using it on highly oscillatory functions
and functions with singularities (poles or branch points in the
region).  The Y integrals depend on how far apart R(X) and S(X) are,
so if the distance S(X)-R(X) varies rapidly with X, there may be
substantial errors arising from truncation with different step-sizes
in the various Y integrals. One can increase DBLINT_X and DBLINT_Y in
an effort to improve the coverage of the region, at the expense of
computation time. The function values are not saved, so if the
function is very time-consuming, you will have to wait for
re-computation if you change anything (sorry).

It is required that the functions F, R, and S be either translated or
compiled prior to calling DBLINT. This will result in orders of
magnitude speed improvement over interpreted code in many cases! Ask
LPH (or GJC) about using these numerical aids.  The file SHARE1;DBLINT
DEMO can be run in batch or demo mode to illustrate the usage on a
sample problem; the file SHARE1;DBLNT DEMO1 is an extension of the DEMO
which also makes use of other numerical aids, FLOATDEFUNK and QUANC8.
Please send all bug notes and questions to LPH@MIT-MC.

Note: Simpson's Rule specifies that
@Begin[Example]
/X[2*N]
|
|       F(X) DX = H/3* (F(X[0]) + 
|                                                                     
/X[0]                   4*(F(X[1])+F(X[3])+...+F(X[2*N-1])) + 
                  
                        2*(F(X[2])+F(X[4])+...+F(X[2*N-2])) +

                        F(X[2*N]))
@End[Example]
in one dimension, where H is the distance between the equally spaced
X[N]'s, and DBLINT_X=N. The error in this formulation is of order
H@-[53]*N*DIFF(F(X),X,4) for some X in (X[0],X[2*N]).

@SubSection[Numerical Solutions of Differential Equations]
@Label[nsde]

The file SHARE2;NDIFFQ FASL contains some routines for solution of
differential equations by the Runge Kutta technique.  An example of
its use might be:

@Begin[Example]
Define_Variable(N,0.3,FLOAT);
Define_Variable(H,0.175,FLOAT);
F(X,E):=(Mode_Declare([X,E],FLOAT),N*EXP(X)/(E+X^(2*H)*EXP(H*X)));
Compile(F);
Array([X,E],FLOAT,35);
Init_Float_Array(X,1.0E-3,6.85); /* Fills X with the interval */
E[0]:5.0;                        /* Initial condition */
Runge_Kutta @Index[Runge_Kutta](F,X,E);              /* Solve it */
Graph2(X,E);                     /* Graph the solution */
@End[Example]
Runge_Kutta(F,X,E,E_Prime) would be the call for a second-order 
equation.

@SubSection[Fast Fourier Transforms]
@Label[fft]

The following describes some FFT routines written by Tom Knight.
To load the routines do LOADFILE(FFT,FASL,DSK,SHARE);  The basic functions
 are: 
FFT(Fast Fourier Transform), IFT (Inverse Fast Fourier Transform).

These functions perform a (complex) fast fourier transform on either 1 or 2
dimensional FLOATING-POINT arrays, obtained by:  ARRAY(array,FLOAT,dim1); or
ARRAY(array,FLOAT,dim1,dim2);  for 1d arrays dim1 must equal 2@-[110]-1, and
for 2d arrays dim1=dim2=2@-[110]-1 (i.e. the array is square).  (Recall that
MACSYMA arrays are indexed from a 0 origin so that there will be 2@-[110] and
(2@-[110])@-[50] arrays elements in the above two cases.)

The calling sequence is:
@fcn[Name="FFT", Args="real-array,imag-array"]) 
 

@fcn[Name="IFT", Args="real-array,imag-array"])
 

Translation Lossage ******
.scon 
 ******
The real and imaginary arrays must of course be the same size.  The transforms
 are done in place so that @i[real-array] and @i[imag-array] will contain 
the real and imaginary parts of the transform.

The definitions of the Fast Fourier Transform and its inverse
are given here.  Here A is the array to be transformed and AT is
its transform.  Both A and AT are complex arrays, although as noted
above FFT and IFT can only deal with separate real arrays for
the real and imaginary parts of A and AT.  N (or N^2) is the number
of elements in A in the 1D (or 2D) case.  (In fact these definitions
are not of the FFTs but of the discrete Fourier transforms.  The
FFT and IFT functions merely provided efficient algorithms for the
implementation of these definitions.)
@Begin[Example]
@Hinge
1D case:

      N - 1
      ====                     - 1
      \          2 %I %PI I K N
AT  =  >    A  %E                  
  K   /      I
      ====
      I = 0

          N - 1
          ====                        - 1
      - 1 \           - 2 %I %PI I K N
A  = N     >    AT  %E                    
 I        /       K
          ====
          K = 0


@Hinge
2D case:

         N - 1 N - 1
         ====  ====                                - 1
         \     \             2 %I %PI (I K + J L) N
AT     =  >     >    A     %E                          
  K, L   /     /      I, J
         ====  ====
         I = 0 J = 0

             N - 1 N - 1
             ====  ====                                   - 1
         - 2 \     \              - 2 %I %PI (I K + J L) N
A     = N     >     >    AT     %E                            
 I, J        /     /       K, L
             ====  ====
             K = 0 L = 0
Other functions included in this file are:

@fcn[Name="POLARTORECT", Args="magnitude-array,phase-array"]) 
converts from magnitude/phase form into real/imaginary form
putting the real part in the magnitude array and the imaginary part
into the phase array.

@fcn[Name="RECTTOPOLAR", Args="real-array,imag-array"])
undoes POLARTORECT.


(The above four functions return a list of their arguments.)

@SubSection[Roots of Equations by Interpolation]
@Label[interproots]

The file INTPOL FASL, created by Charles Karney, contains the function

@fcn[Name="INTERPOLATE", Args="func,x,a,b"])
which finds the zero of @i[func] as @i[x] varies.  The last two args give 
the range to look in.  The function must have a different sign at each 
endpoint.  If this condition is not met, the action of the of the function is 
governed by INTPOLERROR[TRUE] @Index[INTPOLERROR]).  If INTPOLERROR is TRUE then an error 
occurs,
otherwise the value of INTPOLERROR is returned  (thus for plotting INTPOLERROR
might be set to 0.0).  Otherwise (given that MACSYMA can evaluate the first
argument in the specified range, and that it is continuous) INTERPOLATE is
guaranteed to come up with the zero (or one of them if there is more than one
zero).

The accuracy of INTERPOLATE is governed by INTPOLABS[0.0] @Index[INTPOLABS] and
INTPOLREL[0.0] @Index[INTPOLREL] which must be non-negative floating point numbers.
INTERPOLATE will stop when the first arg evaluates to something less
than or equal to INTPOLABS or if successive approximants to the root
differ by no more than INTPOLREL * <one of the approximants>.  The
default values of INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets
as good an answer as is possible with the single precision arithmetic
we have.  The first arg may be an equation.  The order of the last two
args is irrelevant.  Thus
@Begin[Example]
INTERPOLATE(SIN(X)=X/2,X,%PI,.1);
@End[Example]
Translation Lossage ******
.scon 
 ******
is equivalent to
@Begin[Example]
INTERPOLATE(SIN(X)=X/2,X,.1,%PI);
@End[Example]
Translation Lossage ******
.scon 
 ******
The method used is a binary search in the range specified by the last two args.
When it thinks the function is close enough to being linear,  it starts using
linear interpolation.

An alternative syntax has been added to interpolate, this replaces the first
 two arguments by a function name.  The function MUST be TRANSLATEd or compiled
function of one argument.  No checking of the result is done, so make sure  the
function returns a floating point number.

@Begin[Example]

F(X):=(MODE_DECLARE(X,FLOAT),SIN(X)-X/2.0);
INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)       time= 60 msec
INTERPOLATE(F(X),X,0.1,%PI);            time= 68 msec
TRANSLATE(F);
INTERPOLATE(F(X),X,0.1,%PI);            time= 26 msec
INTERPOLATE(F,0.1,%PI);                 time=  5 msec
@End[Example]


@SubSection[Special Functions]
@Label[spec!fun]

The file BESSEL FASL contains routines for computing numerical values for  
various special functions.  If they are given non-numeric arguments they 
return themselves.

@i[Bessel Functions]

The following functions compute Bessel functions of integer order for real 
arguments.

@fcn[Name="J0", Args="X"] 
returns the value of the zeroth order Bessel function at @i[X].

@fcn[Name="J1", Args="X"]
returns the value of the Bessel function of first order at @i[X]

@fcn[Name="JN", Args="X,N"])
returns the @i[N]'th order Bessel function.  In addition it sets up an array
 JARRAY of  N+1 elements, (numbered from 0 to ABS(N))  such that JARRAY[I] 
gives the value of the I'th order Bessel function  with argument X.  (If N < 0
 then JARRAY[I] gives the (-I)'th Bessel function).


@i[Modified Bessel Functions]

The following functions compute the Modified Bessel Functions I of integer 
orders for real arguments.

@fcn[Name="I0", Args="X"]
returns the value of the modified Bessel function of zeroth order.

@fcn[Name="I1", Args="X"]
returns the value of the modified Bessel function of first order.

@fcn[Name="IN", Args="X,N"])
works the same way as JN(X,N), except that the array is called IARRAY.


Since the modified Bessel function blows up like EXP(ABS(X)) at infinity, 
they cannot be evaluated directly for ABS(X) > 83 (due to overflow).  The 
following functions avoid this problem:

@fcn[Name="G0", Args="X"]
returns I0(X)*EXP(-ABS(X)).

@fcn[Name="G1", Args="X"]
returns I1(X)*EXP(-ABS(X)).

@fcn[Name="GN", Args="X,N"])
returns IN(X,N)*EXP(-ABS(X)). The array generated by GN is called GARRAY.



@i[Complex Bessel Function of positive fractional order]

@fcn[Name="BESSEL", Args="Z,A"])
returns the Bessel function J for complex Z and real A @?[>] 0.0 .  Also an 
array BESSELARRAY is set up such that BESSELARRAY[I] = J[I+A-ENTIER(A)](Z)

@fcn[Name="AIRY", Args="X"]
returns the Airy function Ai of real argument @i[X].


@i[Plasma Dispersion Function,] NZETA(Z).

This function is related to the complex error function by 

@Begin[Example]
NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z))
@End[Example]


@fcn[Name="NZETA", Args="Z"]
returns the complex value of the Plasma Dispersion Function for complex Z.

@fcn[Name="NZETAR", Args="Z"]
returns  REALPART(NZETA(Z)).

@fcn[Name="NZETAI", Args="Z"]
returns IMAGPART(NZETA(Z)).



@i[Normal distribution function]

@fcn[Name="GAUSS", Args="MEAN,SD"])
returns a random floating point number from a normal distribution with mean
 @i[MEAN] and standard deviation @i[SD]



@SubSection[Polynomial Zeros]
@Label[poly!zero]


      The file SHARE;PRRID FASL  contains the code, written by Richard Fateman,
which implements the Collins-Loos "Polynomial Real Root Isolation by 
Differentiation"
algorithm, as described in the Collins-Loos paper, Proc. of the 1976 ACM Symp.
on Symbolic and Algebraic Computation.  The subsequent improvements,
due to Fateman, and described in his paper in the Proc. of the 1977 MACSYMA
Users' Conference, are also included.
Three versions, PRRID1, PRRID2, and PRRID3 are included.  The first of these is
the original algorithm, transcribed from "ALDES", and the second two use
combinations of exact and floating point arithmetic to achieve the same 
results.
PRRID3 appears to be the fastest for most cases.

Input: a univariate polynomial  (preferably in rational canonical form).

Output: a list of the form [ I1, M1, I2, m2, ... In, Mn] in
which each Ij is itself a list of two items, each a rational number, [Aj, Bj].
There are exactly Mj real zeros of the input polynomial in the half-open
interval (Aj, Bj].
      These programs are potentially much faster than
the Sturm sequence calculation used by realroots (the system command),
for polynomials with fewer real zeros than the maximum possible.  They are 
slower
for some polynomials e.g.  (x-1)*(x-2)* ...*(x-20).
    Realroots goes a bit further in that it will refine the isolating intervals
to some desired narrowness.  This is not done by the PRRID programs,
but could be easily done.  A Newton iteration guaranteed to converge, can
be used to refine the zeros, starting from points based on the zeros of the
 second
derivative of the input.


    A faster program has been implemented by Bruce Char, which, however, does
 not
have the same precise characteristics.  Using the "allroots" command,
approximate zeros are located, and then disks in the complex plane are computed
which include the actual positions of the zeros.  This is much faster in
finding isolating disks, and works in the complex plane.  Unfortunately, the
 disks
may intersect (in which case the program says so). 

@Section[General Utilities]
@Label[genutil]

@SubSection[Expansion with respect to specified variables]
@Label[ewrtsv]

The file DSK:SHARE1;STOPEX FASL contains two functions that are useful
for performing expansions with respect to specified variables or 
operators.
A demo is available in DSK:SHARE1;STOPEX DEMO.

@fcn[Name="EXPANDWRT", Args="exp,var1,var2,..."])
expands exp with respect to the @i[vari.] All products involving the
@i[vari] appear explicitly.  The form returned will be free of
products of sums of expressions that are not free of the @i[vari].
The @i[vari] may be variables, operators, or expressions.  By default,
denominators are not expanded, but this can be controlled by means of
the switch EXPANDWRT_DENOM.

EXPANDWRT_DENOM[FALSE] @Index[EXPANDWRT_DENOM] controls the treatment of rational
expressions by EXPANDWRT.  If TRUE, then both the numerator and
denominator of the expression will be expanded according to the
arguments of EXPANDWRT, but if EXPANDWRT_DENOM is FALSE, then only the
numerator will be expanded in that way.


@fcn[Name="EXPANDWRT_FACTORED", Args="exp, var1, var2, ..., varn"])
is similar to EXPANDWRT, but treats expressions that are products
somewhat differently.  EXPANDWRT_FACTORED will perform the required
expansion only on those factors of exp that contain the variables in
the argument list of EXPANDWRT_FACTORED.


@SubSection[Powers of Polynomials]
@Label[pops]

LOAD(POWERS); loads in a package which provides a function
Translation Lossage ******
.inline  function(POWERS,|expr, var|)
 ******
which gives the powers of @i[var] occuring in @i[expr].

This function is a generalisation of HIPOW and LOPOW
in that it returns a list of all the powers of @i[var] occuring
in @i[expr.]  It is still necessary to expand @i[expr] before applying
POWERS (on pain of getting the wrong answer).

This function has many uses, e.g. if you want to find all
the coefficients of X in a polynomial POLY you can use
@Begin[Example]
MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@End[Example]
and many other similar useful hacks.

@SubSection[Roots of Polynomials]
@Label[polsol]

     LOAD(POLSOL) loads the POLYSOLVE package, which has
facilities for finding the roots of polynomials.
This package was written by Anthony Kennedy and
any comments, suggestions etc. should be sent to him.  ADK@MC.

It is easiest to describe with an example:

We start off, by defining a quadratic form
in the variable X
@Begin[Example]
(C1) QUADRATIC:A*X^2+B*X+C
.end continue
which we solve by calling
Translation Lossage ******
.inline  function(POLYSOLVE,|expr,var|)
 ******
in the obvious way
@Begin[Example]
(C2) POLYSOLVE(QUADRATIC,X);
@Hinge
                         %DEX2       2
                    (- 1)      SQRT(B  - 4 A C) - B
(D2)              [[-------------------------------, 1, 2]]
                                  2 A
The output is in a form convenient for use by other
programs. The notation is that POLYSOLVE returns a list of
"rootlists", each "rootlist" being of the form
@Begin[Example]
       [root(%dex2,%dex3,...,%dexn),bound1,bound2,...,boundn]
@End[Example]where root is an expression for the root in terms of the parameters
%dexi, with i running from 2 to some value n. The solutions are the
values of root for every value of %dexi from 1 through boundi, that
is there are bound1*bound2*...*boundn roots of the expression. Notice
the special role played by %dex1; it does not appear in the root
expression. This is because POLYSOLVE attempts to make bound1
into the multiplicity of the root (that is it tries to ensure that root
is not a trivial function of any other of the %dexi). It is not
currently guaranteed that different "rootlists" will not contain
the same root, though it is to be hoped that this will eventually
be checked by POLYSOLVE (to the extent that is possible heuristically,
as it is really an undecidable problem).
       
In order to make the output more readable to humans a function
Translation Lossage ******
.inline  function(FACTORFORM,|list-of-rootlists,var|)
 ******
is provided to reconstruct
the original expression in factored form over the complex plane
(there is no need for var to be the same as in the expression being
POLYSOLVEd).
@Begin[Example]
(C3) FACTORFORM(%,X);

@Hinge
                        2                          2
                - SQRT(B  - 4 A C) - B       SQRT(B  - 4 A C) - B
(D3)       (X - ----------------------) (X - --------------------)
                         2 A                         2 A
which clearly is
@Begin[Example]
(C4) RATSIMP(%);
@Hinge
                                   2
                                A X  + B X + C
(D4)                            --------------
                                      A
what we started with. The overall factor
in the original expression is returned by POLYSOLVE in
the variable LEADINGCOEFF @Index[LEADINGCOEFF].
@Begin[Example]
(C5) LEADINGCOEFF;
(D5)                                  A
@End[Example]Similarly POLYSOLVE attacks cubics. 
@Begin[Example]
(C6) CUBIC:A*T^3+B*T^2+C*T+D;
@Hinge
                               3      2
(D6)                        A T  + B T  + C T + D

(C7) SHOWTIME:TRUE
Time= 3 msec.

(C8) POLYSOLVE(CUBIC,T);
@Hinge
                           3                                    3
                  B C   2 B   2                        B C   2 B
             (D - --- + -----)                     D - --- + -----
                  3 A       2               2 3        3 A       2
                        27 A      (3 A C - B )               27 A  1/3
(E8)  (SQRT(------------------ + -------------) - ---------------)
                       2                  6              2 A
                    4 A              729 A

Time= 4396 msec.
                                   2 %I %PI %DEX2
          2 %I %PI %DEX2         - --------------
          --------------                 3                  2
                3              %E                 (3 A C - B )    B
(D8) [[%E               E11 - ------------------------------- - ---, 1, 3]]
                                             2                   3 A
                                          9 A  E11
@End[Example]There is a small degree of control over how POLYSOLVE generates
intermediate expressions on E-lines; it uses an E-line if the
expression is longer than ELENGTH[10] @Index[ELENGTH].
@Begin[Example]
(C9) ELENGTH;
Time= 1 msec.
(D9)                                 10

(C10) EV(POLYSOLVE(CUBIC,T),ELENGTH = 5);
@Hinge
                                           2
                                  3 A C - B
(E10)                             ----------
                                        2
                                     9 A

                                            3
                                   B C   2 B
                               D - --- + -----
                                   3 A       2
                                         27 A
(E11)                          ---------------
                                     2 A
@End[Example]
                                  2      3        1/3
(E12)                    (SQRT(E14  + E13 ) - E14)

Time= 3666 msec.
@End[Example]                                     2 %I %PI %DEX2
            2 %I %PI %DEX2         - --------------
            --------------                 3
                  3              %E                 E13    B
(D12)   [[%E               E15 - ---------------------- - ---, 1, 3]]
                                          E15             3 A
@End[Example]Similarly ELENGTH:0 will display a maximal number of
intermediate results and ELENGTH:INF will display none.

We can regain the cubic again using FACTORFORM
@Begin[Example]
(C13) LEADINGCOEFF*FACTORFORM(%,T);
Time= 1154 msec.
@Hinge
                   E13    B           SQRT(3) %I   1
(D13) A (T - E15 + --- + ---) (T - (- ---------- - -) E15
                   E15   3 A              2        2

    SQRT(3) %I   1
   (---------- - -) E13
        2        2         B         SQRT(3) %I   1
 + -------------------- + ---) (T - (---------- - -) E15
           E15            3 A            2        2

      SQRT(3) %I   1
   (- ---------- - -) E13
          2        2         B
 + ---------------------- + ---)
            E15             3 A

(C14) %,EVAL,RATSIMP;
Time= 6472 msec.
                               3      2
(D14)                       A T  + B T  + C T + D

@End[Example]If we feel enthusiastic we can solve quartics too.
@Begin[Example]
(C15) QUARTIC:A*S^4+B*S^3+C*S^2+D*S+E;
@Hinge
Time= 19 msec.
                            4      3      2
(D15)             A S  + B S  + C S  + D S + E


(C16) EV(POLYSOLVE(QUARTIC,S),ELENGTH = 5);
@Hinge
                                            2
                                 8 A C - 3 B
(E16)                            ------------
                                        2
                                    16 A

                                            3
                                    B C    B
                                D - --- + ----
                                    2 A      2
                                          8 A
(E17)                           --------------
                                     4 A

@End[Example]                                      2          4
                               B D   B  C     3 B
                           E - --- + ----- - ------
                               4 A       2        3
                                     16 A    256 A
(E18)                      ------------------------
                                      A

@End[Example]                                             2
                                - 3 E21 - E19
(E19)                           --------------
                                      9

@End[Example]                                                   3
                         2 E19 E21        2   2 E19
                         --------- - 2 E20  - ------
                             3                  27
(E20)                    ---------------------------
                                      2

@End[Example]                                  2      3        1/3
(E21)                    (SQRT(E23  + E22 ) - E23)
@End[Example]
                                     E22   E19
(E22)                          E24 - --- + ---
                                     E24    3
@End[Example]
                                     E20
(E23)                             ---------
                                  E25 - E19
                               SQRT(E25 - E19)
(E24)                          ---------------
                                   SQRT(2)

Time= 8462 msec.

             %DEX2         2          %DEX3                       %DEX3
(D24) [[(- 1)      SQRT(E27  - 2 (- 1)      E26 E27 - E25) + (- 1)      E27

                                                                 B
                                                              - ---, 1, 2, 2]]
                                                                4 A

(C25) LEADINGCOEFF*FACTORFORM(%,X);
Time= 1037 msec.
                     2                             B
(D25) A (X - SQRT(E27  - 2 E26 E27 - E25) - E27 + ---)
                                                  4 A

              2                             B
 (X + SQRT(E27  - 2 E26 E27 - E25) - E27 + ---)
                                           4 A

              2                             B
 (X - SQRT(E27  + 2 E26 E27 - E25) + E27 + ---)
                                           4 A

              2                             B
 (X + SQRT(E27  + 2 E26 E27 - E25) + E27 + ---)
                                           4 A

But it becomes difficult to simplify the FACTORFORMed
result back to the original expression again in a reasonable time.
(The solution has been checked numerically, but even that
was tedious!).

If we try a quintic
@Begin[Example]
(C26) QUINTIC:F*S^5+QUARTIC;

Time= 11 msec.
@Hinge
                        5      4      3      2
(D26)                F S  + A S  + B S  + C S  + D S + E


(C27) ERRCATCH(POLYSOLVE(QUINTIC,S))
CANNOT SOLVE EQUATION OF ORDER 5
Time= 1769 msec.
@End[Example]it fails, because Galois was a clever man. However POLYSOLVE will
happily attack symbolic problems like
@Begin[Example]
(C28) SYMBOLIC:(X^N-A)^M;
Time= 9 msec.
@Hinge
                                    N     M
(D28)                             (X  - A)


(C29) POLYSOLVE(SYMBOLIC,X);
Time= 555 msec.
@Hinge
                                2 %I %PI %DEX2
                                --------------
                          1/N         N
(D29)                  [[A    %E              , M, N]]


(C30) FACTORFORM(%,X);
Time= 1077 msec.
@Hinge
                      N                   2 %I %PI %DEX2
                    /===\                 --------------
                     ! !            1/N         N        M
(D30)                ! !      (X - A    %E              )
                     ! !
                    %DEX2 = 1


(C31) HARDERSYMBOLIC:X^N+A*X^M;
Time= 9 msec.
@Hinge
                                   N      M
(D31)                             X  + A X


(C32) ERRCATCH(POLYSOLVE(HARDERSYMBOLIC,X))
CANNOT SOLVE EQUATION OF ORDER M
Time= 399 msec.
@End[Example]But some are just too hard for it! The symbolic answer would become
rather complicated, with lots of noun forms, if it was attempted.

POLYSOLVE gains a lot by using FACTOR (in fact GFACTOR) in its insides, 
so perhaps you shouldn't be too impressed by 
@Begin[Example]
(C33) FACTORISABLE:EXPAND((X-A)^3*QUADRATIC);
Time= 120 msec.
@Hinge
         5      4      2  4      3          3      3  3          2      2    2
(D33) A X  + B X  - 3 A  X  + C X  - 3 A B X  + 3 A  X  - 3 A C X  + 3 A  B X

                                               4  2      2        3        3
                                            - A  X  + 3 A  C X - A  B X - A  C


(C34) POLYSOLVE(FACTORISABLE,X);
Time= 3120 msec.
@Hinge
                             %DEX2       2
                        (- 1)      SQRT(B  - 4 A C) - B
(D34)         [[A, 3], [-------------------------------, 1, 2]]
                                      2 A


(C35) LEADINGCOEFF*FACTORFORM(%,X);
Time= 894 msec.
@Hinge
                              2                          2
               3      - SQRT(B  - 4 A C) - B       SQRT(B  - 4 A C) - B
(D36) A (X - A)  (X - ----------------------) (X - --------------------)
                               2 A                         2 A
POLYSOLVE does have some clever tricks though:
@Begin[Example]

(C37) OCTIC:Z^8+5*Z^4-B;
Time= 13 msec.
@Hinge
                                 8      4
(D37)                           Z  + 5 Z  - B


(C38) POLYSOLVE(OCTIC,Z);
Time= 1805 msec.
@Hinge
            %I %PI %DEX3
            ------------
                 2             %DEX2                    1/4
          %E             ((- 1)      SQRT(4 B + 25) - 5)
(D38)   [[-------------------------------------------------, 1, 2, 4]]
                                 1/4
                                2
Just in case you make a mistake and forget the variable
to solve for, POLYSOLVE behaves quite logically and tells
you that constants have no roots!
@Begin[Example]

(C39) POLYSOLVE(QUADRATIC,T);
Time= 141 msec.
(D39)                                 []
@End[Example]
So as to make it easier to use POLYSOLVE directly from 
top-level MACSYMA a function
Translation Lossage ******
.inline  function(CFACTOR,|exp,var|)
 ******
has been
provided which combines the actions of POLYSOLVE and
FACTORFORM. CFACTOR behaves like FACTOR in many ways
except that it factors into linear factors
over the complex plane whenever POLYSOLVE is able to find the
roots, and fails otherwise.
@Begin[Example]

(C40) CFACTOR(-(X-A)^N*(X^N-A)^M,X);
Time= 2306 msec.
@Hinge
                           N                   2 %I %PI %DEX2
                         /===\                 --------------
                       N  ! !            1/N         N        M
(D40)         - (X - A)   ! !      (X - A    %E              )
                          ! !
                         %DEX2 = 1

Time= 50572 msec.

@Section[Dumping and Loading Arrays]
@Label[dumpa]
To efficiently save and load up number arrays do:

LOAD(DUMP);
@fcn[Name="DUMPARRAYS", Args="[filespec],arrays"])
saves arrays.


@fcn[Name="LOADARRAYS", Args="filespec"]
loads the dumped arrays back in.


The arrays must be number arrays. i.e. as produced by 
ARRAY @Index[ARRAY](@i[arrayname],INTEGER, .. ); or ARRAY(@i[arrayname],FLOAT, .. );.

The defaulting of @i[filepsec] is identical to the SAVE and LOADFILE
commands.  e.g. DUMPARRAYS(@i[arrays]); dumps them in the default file.
@Begin[Example]
example:
LOADFILE(DUMP,FASL,DSK,SHARE);
ARRAY(ARRAY1,FLOAT,2,3,4);
ARRAY1[1,2,3]:EV(%PI,NUMER);
ARRAY(ARRAY2,INTEGER,20);
FOR I FROM 1 THRU 20 DO ARRAY2[I]:I;
DUMPARRAYS([ARRAYS,">",DSK,USERS],ARRAY1,ARRAY2); saves ARRAY1 and ARRAY2
^Z A^K
LOADFILE(DUMP,FASL,DSK,SHARE);
LOADARRAYS(ARRAYS,">",DSK,SHARE);
ARRAY2[5]; ==> 5
ARRAY1[1,2,3]; ==> 3.14159..
@End[Example]
The amount of room occupied by these files is roughly 1/2 of what
is needed when saving the arrays using the SAVE command.  more
importantly it doesn't require bags of FLONUM or FIXNUM space as
the SAVE command sometimes does.

@Section[Functions relating to series]
@Label[frs]

@SubSection[Reversion of Taylor Series]
@Label[rots]

Do LOAD(REVERT); .
@fcn[Name="REVERT", Args="expression,variable"])

@fcn[Name="REVERT2", Args="expression,variable,hipower"])

@i[variable] is the variable the original Taylor 
expansion is in.  Note:  REVERT only works on expansions around 0.

@SubSection[Fourier Series]
@Label[forser]

Do LOAD(FOURIER) to access the Fourier Series package.
It also will calculate Fourier integral
coefficients and has various other functions to do such things as
replace all occurrences of F(ARG) by ARG in expression (like changing
ABS(a*x+b) to a*x+b).  A demo is available as DEMO(FOURIE,DEMO,DSK,SHARE1);.

The file contains the following functions:

@fcn[Name="EQUALP", Args="X, Y"])
returns TRUE if X EQUALs Y otherwise FALSE (doesn't give an
error message like EQUAL(X, Y) would do in this case).


@fcn[Name="REMFUN", Args="fun, exp"])
replaces all occurrences of @i[fun](@i[arg]) by @i[arg] in @i[exp].

REMFUN(@i[fun, exp, var]) replaces all occurrences of @i[fun](@i[arg])
by @i[arg] in @i[exp] only if @i[arg] contains the variable @i[var].


@fcn[Name="FUNP", Args="fun, exp"])
returns TRUE if @i[exp] contains the function @i[fun].

FUNP(@i[fun, exp, var]) returns TRUE if @i[exp] contains the function
@i[fun] and the variable @i[var] is somewhere in the argument of one
of the occurences of @i[fun].


@fcn[Name="ABSINT", Args="fun, var, halfplane"])
indefinite integral of @i[fun] with respect to
@i[var] in the given halfplane (POS, NEG, or BOTH).
If halfplane is omitted, POS is assumed as a
default. @i[fun] may contain expressions of the form
ABS(X), ABS(SIN(X)), ABS(A)*EXP(-ABS(B)*ABS(X)).

ABSINT(@i[fun, var, A, B]) definite integral of @i[fun] with respect
to @i[var] from A to B. @i[fun] may include absolute values.


@fcn[Name="FOURIER", Args="F, X, P"])
produces a list of the Fourier coefficients of F(X) defined
on the interval [-P, P].


@fcn[Name="FOURSIMP", Args="L"]
returns the form o L thatresults after it
simplifies SIN(N %PI X) to 0 if SINNPIFLAG[TRUE] @Index[SINNPIFLAG] is TRUE and
COS(N %PI X) to (-1)@-[78] if COSNPIFLAG[TRUE] @Index[COSNPIFLAG] is TRUE.
If L is a list FOURSIMP will map itself over the items of the
list, and call LDISP @Index[LDISP] on the result for each item.  If L is an
equation, FOURSIMP will operate only on the right hand side of the equation.


@fcn[Name="FOUREXPAND", Args="L, X, P, limit"])
generates the Fourier series from the list of
Fourier coefficients L up thru @i[limit] terms (@i[limit]
may be INF). X and P have same meaning as in
FOURIER.


@fcn[Name="FOURCOS", Args="F, X, P"])
Fourier cosine coefficients for F(X) defined on [0, P].


@fcn[Name="FOURSIN", Args="F, X, P"])
Fourier sine coefficients for F(X) defined on [0, P].


@fcn[Name="TOTALFOURIER", Args="F, X, P"])
does FOUREXPAND(FOURSIMP(FOURIER(F, X, P)), X, P, 'INF).


@fcn[Name="FOURINT", Args="F, X"])
creates a list of the Fourier integral coefficients of F(X)
defined on [MINF, INF].


@fcn[Name="FOURINTCOS", Args="F, X"])
Fourier cosine integral coefficients for F(X) on [0, INF].


@fcn[Name="FOURINTSIN", Args="F, X"])
Fourier sine integral coefficients for F(X) on [0, INF].


@Section[Set Theory]
@Label[set!theory]

There are two packages for Set Theory.  One uses MACSYMA's
list representation, meaning you can convert easily between lists and
sets.  To use it, type LOAD(SET); .  The other Sets package
uses a different representation and is computationally faster.
It may be accessed by LOAD(SETS); .

@SubSection[Set Package using MACSYMA Lisp Representation]
@Label[spumlr]

Typing LOAD(SET); provides MACSYMA with the basic primitives of set
theory.  This package is due to David Spear

For our purposes, we define a set to be a sorted irredundant list.

Thus [2,3,x,1] is not a set since it isn't sorted and [2,3,x,x,y] is
not a set since it has a redundancy, however [1,2,3,x] and [2,3,x,y]
are sets.

Functions provided are mostly self-explanatory, so the following brief
descriptions should be sufficient:

@fcn[Name="INTERSECT", Args="A,B"])
returns the intersection of A and B.

@fcn[Name="UNION", Args="A,B"])
returns the union of A and B.

@fcn[Name="COMPLEMENT", Args="A,B"])
returns the relative complement of A in B,
that is, the set of elements of B which are not in A.

@fcn[Name="SETDIFFERENCE", Args="A,B"])
returns the set of elements of A which are not in B.
Note that SETDIFFERENCE(A,B) is just COMPLEMENT(B,A).

@fcn[Name="SYMMDIFFERENCE", Args="A,B"])
returns the symmetric differrence of A and B, 
which is equal to UNION(SETDIFFERENCE(A,B),SETDIFFERENCE(B,A)).

@fcn[Name="POWERSET", Args="S"]
returns the set of all subsets of S.

@fcn[Name="SETIFY", Args="L"]
converts the list L to a set.
For example  SETIFY([2,x,2,3,8,x]) yields [2,3,8,x].

@fcn[Name="SUBSET", Args="A,F"])
returns the set of elements of A which satisfy the condition F.
For example  SUBSET([1,2,x,x+y,z,x+y+z],atom) yields [1,2,z].
The argument F should be a function of one argument
which returns TRUE or FALSE. Another  example:
SUBSET([1,2,7,8,9,14],evenp) yields [2,8,14].

@fcn[Name="SETP", Args="L"]
returns TRUE if L is a set, FALSE otherwise.

@fcn[Name="SUBSETP", Args="A,B"])
decides whether or not A is a subset of B
and returns TRUE or FALSE accordingly.


@fcn[Name="DISJOINTP", Args="A,B"])
decides whether A and B are disjoint (have no common elements)
and returns TRUE or FALSE accordingly.


Remarks:
Translation Lossage ******
.skip  begin indent 0,5;turn on "";
 ******
1.(6)We reemphasize that a set is a list.
Thus the notation for both input and output 
is  [ ... ]  rather than  { ... } .
We feel that this ambiguity is desirable.  It allows
list processing on sets and set processing on lists
without conversion. 

2.(6)However, not every list is a set.
A set must satisfy two additional conditions.  It must be
(1) sorted
(2) irredundant.
Implied is a notion of order and a notion of equivalence.
We choose order as the fundamental notion.
The user can specify an order by resetting the value
of CANONLT[ORDERLESSP] @Index[CANONLT].
Initially, CANONLT has the value ORDERLESSP which is MACSYMA's
canonical order. The value of CANONLT must be a strict total 
preorder (a function of two arguments which returns TRUE or FALSE
and such that the associated relation is transitive and irreflexive).
It need not be universally well-defined so long as it is
well-defined for the arguments it receives. The notion of 
equivalence is derived from the order notion by the 
familiar law of trichotomy:
Given objects a,b we require that exactly one of the following holds:
Translation Lossage ******
.skip  begin nofill narrow 10
 ******
(1) a is less than b
(2) b is less than a
(3) a and b are equivalent
@End[Example]Note that equivalence is, in general, weaker than equality.

3.(6)Consider the following example:
In a MACSYMA suppose we define a function h by:
Translation Lossage ******
.skip  once nofill narrow 8;
 ******
h(n):=for i do if n=(2@-[105])*ENTIER(n/(2@-[105])) then return(i-1);
Translation Lossage ******
.skip  continue
 ******
Thus h returns the largest positive integer e such that
n is divisible by 2@-[101] (n is assumed to be a positive integer).
Translation Lossage ******
.skip  continue
 ******
Next define an order function f by:
Translation Lossage ******
.skip  once nofill narrow 8;
 ******
f(a,b):=is( h(a) < h(b) );
Translation Lossage ******
.skip  continue
 ******
For example, with this order, 9 is less than 2
and 6 is equivalent to 10.
Translation Lossage ******
.skip  continue     
 ******
Next we set CANONLT by:  CANONLT:f;
Translation Lossage ******
.skip  continue
 ******
Then all functions in the SET package will
return sort and eliminate redundancies (equivalences)
using the function f.
Translation Lossage ******
.skip  continue     
 ******
For example, SETIFY([6,20,2,9,8,12]) returns [9,2,12,8].

4.(6)As mentioned above the default value of CANONLT
is ORDERLESSP. It follows that the default notion of
equivalence is equality.

5.(6)The functions UNION and INTERSECT can take any
number of arguments.

6.(6)The arguments to functions in the SET package
need not be sets - arbitrary lists are OK
(i.e. possibly unsorted and/or redundant).
Translation Lossage ******
.skip  continue   
 ******
Thus, functions such as INTERSECT 
accept arbitrary lists  but always return a set.
For example,
Translation Lossage ******
.skip  once nofill narrow 8;
 ******
INTERSECT([2,3,2,y,x],[2,z,y,y]) yields [2,y].
@End[Example]

@SubSection[Fast Set Package]
@Label[fsp]

There is a fast sets package (due to GJC) available by doing 
LOAD(SETS); .

The set constructor is the "{".  So
@Begin[Example]
X:{A,B,C,D,E}; creates a set.
@End[Example]
The usual primitives UNION @Index[UNION], INTERSECTION @Index[INTERSECTION], SETDIFF @Index[SETDIFF], SYMDIFF @Index[SYMDIFF] 
are defined.  (SYMDIFF(A,B)=UNION(SETDIFF(A,B),SETDIFF(B,A))
 = SETDIFF(UNION(A,B),INTERSECTION(A,B)) ).

Predicates are:
ELEMENTP @Index[ELEMENTP](@i[X,set]), EMPTYP @Index[EMPTYP](@i[set]), and 
SUBSETP @Index[SUBSETP](@i[set1,set2])

Translation Lossage ******
.inline  function(CARDINAL,set)
 ******
returns the cardinality.

There are two mapping-like functions which are provided
for sets.

@fcn[Name="PREDSET", Args="predicate,set"])
returns the set of all elements of @i[set]
such that the PREDICATE returns TRUE. e.g.
@Begin[Example]
X:{1,2,3,4,5,6,7,8,9,10,11}
@End[Example]
PREDSET(LAMBDA([U],IS(ABS(U-6)<3)),X) returns {5,6,7}


@fcn[Name="MAPSET", Args="function,set"])
creates a set from the results of applying
the @i[function] to the elements of the @i[set].

@fcn[Name="ELEMENTS", Args="set"]
returns a list of the elements of @i[set].

The sets are not represented as lists.  The set-algebraic
functions (UNION, INTERSECTION, SETDIFF, SYMDIFF, PREDSET,
CARDINAL), all operate on the internal representation of sets
and as such are fast.  Things which have to be converted from
the set representation to non-set are a bit slower,
the things which make sets from raw elements are slower
still, however, they are somewhat faster than CONS on
the average.

If there is interest, "INFINITE" sets could be implemented.
There, of course, one has to be careful in converting between
representations, obviously one can't print a list of the elements 
of an infinite set.

@Section[Hacijan Linear Programming Algorithm]
@Label[hlpa]

An implementation of Hacijan's Linear Programming Algorithm by Jim
Purtilo (JIMP@MIT-MC), Kent State University, resides in the file
SHARE1;KACH >.  Do LOAD(KACH); to access it.

This version has more hooks for adding users definable
criterion for stopping and restarting in mid alg;
trying to solve the difficulty in loosing positive
definitness in time.

Primitives defined are:

@fcn[Name="HACH", Args="a,b,n,m,l"])
where @i[a] is the matrix and @i[b] is the column vector such that
@i[a].x<@i[b] is the problem to be solved; @i[n] is number variables;
@i[l] is as described in the theory, roughly a length, and also what,
for instance, might be output from GETL.  This is the main algorithm,
and return either a vector x such that the above inequality is
satisfied, or, hopefully, returns why not. m is the number of
inequalities.

@fcn[Name="CHECK", Args="a,b,x,m"])
is a primitive which CHECKs the inequality @i[a.x<b], returning either
0 (when no rows in @i[a.x] violate the equality) or @i[j] (where @i[j]
is in fact a row which does violate the inequality).  This is the new
check, which will always check first that the last row iterated on is
satisfied in the new inequality, before giving the rest of the rows a
chance to be iterated on.  New strategies for row choice will be
implemented as the theory developes at Kent CSR Group.  @i[m] is the
number rows (inequalities).

@fcn[Name="GETL", Args="a,b,n,m"])
returns a value @i[l] (for length) as required
by and defined in the theory.  @i[a] and @i[b] are as
above, also @i[n] is number variables, and @i[m] is
the number inequalities in @i[a].

Several utilities are here-in defined:
@Begin[Example]
                FX              FQ              FH
                ITERATE         Z               LOG2
                ACCELERATE      CRITERION
@End[Example]

Note that the desired precision in bigfloat desired
for the calculations of the elipsoids should be set
prior to any calculations by fpprec:@i[num digits]

Note that there is a global variable SHOW%ALL[FALSE] @Index[SHOW%ALL]
which when true will print the vector x at each
iteration.
@Begin[Example]
(C1) hach(a,b,n,m,l):=
        block([x,i,k,h,q,last%row],
                local(x,i,k,h,q,last%row),

                last%row:0,
                h:bfloat(2^(2*l)*ident(n)),
                x:genmatrix(z,n,1),
@End[Example]Note this is a "do forever...", not
automatically checking the counter k against
in the stopping criterion of the theory.
The reason for this is that oft' times we
like to play with whacky L's, and don't want
to mess with the resulting random stoppage.
Next update will have a settable switch...
and possibly also an improved polynomial
stopping time... continuing our definition:
@Begin[Example]
                for k:0 next k+1
                do  if (i:check(a,b,x,m))=0
                    then return(["win",k,"iterations",x])
                    else (
                        if show%all then ( print(k,x),print(" ")),
                        if not criterion(a,b,x,n,m,l,k)
                                 then  iterate(i)
                                else      
@End[Example]In here would be code for
resetting, say, h, x , lastrow, etc.
Then we start the iteration process
again, hopefully accelerated.
Note that for debugging purposes, code here 
could be a break...
@Begin[Example]
                        (       accelerate(a,b,x,n,m,l,k),
                                iterate(i) ) )


        )

(C2) accelerate(a,b,x,n,m,l,k):=false

(C3) criterion(a,b,x,n,m,l,k):=true
.end continue
for now the above will keep things runningtill the users defined
what he wants... 
@Begin[Example]
(C4) check(a,b,x,m):=
        block([y,j,j1],
                local(y,j,j1),
                j1:0,
                y:a.x,
                if numberp( last%row ) then
                        if last%row#0 then
                                if y[last%row,1]>=b[last%row,1]
                                        then j1:last%row,
                if j1#0 then return( j1 ),
                for j:1 thru m
                        do if y[j,1]>=b[j,1] then j1:j,
                j1
        )
.end continue
Note that this strategy is that if last%row is ok, or
is undefined due to a user CHECKing a system, the
the first row violating a.x<b is used
@Begin[Example]
@Hinge
(C5) getl(a,b,n,m):=
        block([i,j,l],
                l:product(
                        (abs(b[i,1])+1)*product((abs(a[j,i])+1),j,1,m),
                          i,1,n ),
                l:1+log2(n*m*l)
        )
.end

(C6) log2(x):=bfloat(log(x)/log(2))

(C7) z[i,j]:=0

(C8) show%all:false

.begin group
(C9) iterate(i):=(     q:fq(a,h,i,n),
                x:fx(x,a,h,q,i,n),
                h:fh(a,h,q,i,n)

           )
.end

(C10) fx(x,a,h,q,i,n):=x-(n+1)^(-1)*q^(-1/2)*h.transpose(row(a,i))

.begin group
(C11) fh(a,h,q,i,n):=n^2/(n^2-1)*(h-2/(n+1)*q^-1*
                h.transpose(row(a,i)).row(a,i).transpose(h))
.end

(C12) fq(a,h,i,n):=row(a,i).h.transpose(row(a,i))

(C13) Translate(hach,check,iterate,fx,fq,fh,getl,criterion,accelerate)

(C14) dynamalloc:true

(C15) a:bfloat(matrix([1,0],[0,1],[-1,-1]))
.end continue
now get a matrix a and a matrix b for the problem
of solving  a.x < b   ...    
@Begin[Example]
(C16) b:bfloat(matrix([-1],[-1],[4.00000001]))
Warning:  Float to bigfloat conversion of 4.0

(C17) n:2

(C18) m:3

(C19) getl(a,b,n,m);
@End[Example]the user can find the L as in Hacijan's abstract by
doing ... 
@Begin[Example]
(D19)                        9.584962500721156B0
@End[Example]and can find a solution vector x for
@Begin[Example]
                x[1]            <       -1
                        x[2]    <       -1
                x[1] +  x[2]    >=      -4
@End[Example]
by doing
@Begin[Example]
(C20) show%all:true

(C21) hach(a,b,n,m,1);
@Hinge

  [ 0 ]
0 [   ] 
  [ 0 ]
  
  [         0.0B0          ]
1 [                        ] 
  [ - 6.666666666666667B-1 ]
  
  [         0.0B0         ]
2 [                       ] 
  [ - 1.111111111111111B0 ]
  
  [ - 8.888888888888889B-1 ]
3 [                        ] 
  [ - 1.111111111111111B0  ]
  
                                    [ - 1.481481481481482B0 ]
(D21)          [win, 4, iterations, [                       ]]
                                    [ - 1.111111111111111B0 ]

@End[Example]Note that this last example does not pay attention
to the L of the theory.   Doing so, taking a bit longer,
is
@Begin[Example]
(C22) show%all:false
.begin group

(C23) hach(a,b,n,m,9.58);
Warning:  Float to bigfloat conversion of 585780.305
Warning:  Float to bigfloat conversion of 585780.305
                                     [ - 2.415021897406222B0 ]
(D23)          [win, 37, iterations, [                       ]]
                                     [ - 1.018231278758703B0 ]
@End[Example]
@Section[|More Numerical Techniques:  The IMSL Library|]
@Label[imsl!library]

The IMSL Library is a set of numerical analysis routines written
originally in Fortran and translated to Lisp by an automatic Fortran
to Lisp translator (written by KMP@MC).

To use the library, do the following in a MACSYMA:

        LOAD(IMSL)

This will set up an environment for the running of IMSL routines
and will make them load automatically when you call them.

During the main part of a computation, all translated IMSL routines 
call a common subroutine to signal fatal errors. The default is to
display these error messages on the console AND return the error code.
To suppress typeout of IMSL-related error messages, set the variable 
IMSLVERBOSE[TRUE] @Index[IMSLVERBOSE] to FALSE.

Because they use translated Fortran routines, which were not intended for 
recursive invocation, users should be aware that typing ^A in the middle 
of an IMSL routine and attempting to invoke that same routine before 
allowing the first invocation to run to completion will not work.
If a translated IMSL routine complains that it has been recursively invoked
from a breakpoint, that's the problem it's referring to. Frequently the
correct recovery action is to proceed the breakpoint briefly and then type
^A again.

@SubSection[|Useful Functions|]
@Label[imsl!useful]

The following functions are based on the IMSL routines but have normal
MACSYMA calling conventions. They take numeric arguments and 
return floating point results.

@fcn[Name="|BESSELJ0|", Args="x"]
computes the Bessel J0 function (first kind, 0th order) by calling
IMSL's MMBSJ0 @Index[MMBSJ0] routine.


@fcn[Name="|BESSELJ1|", Args="x"]
computes the Bessel J1 function (first kind, 1st order) by calling
IMSL's MMBSJ1 @Index[MMBSJ1] routine.


@fcn[Name="|BESSELK0|", Args="x"]
computes the Bessel Y0 function (modified second kind, 0th order) by
calling IMSL's MMBSK0 @Index[MMBSK0] routine.


@fcn[Name="|BESSELK1|", Args="x"]
computes the Bessel Y1 function (modified second kind, 1st order) by
calling IMSL's MMBSK1 @Index[MMBSK1] routine.


@fcn[Name="GAM", Args="x"]
computes the Gamma function by calling IMSL's MGAMMA @Index[MGAMMA] routine.


@fcn[Name="%ERF", Args="x"])
computes the Error Function by calling IMSL's MERF @Index[MERF] routine.


@fcn[Name="%ERFC", Args="x"])
computes the Error Function Complement,@i[ 1-erf(x)], by calling IMSL's
MERFC @Index[MERFC] routine.


@fcn[Name="%NORMAL", Args="x"])
computes the Gaussian Normal Distribution Function
by calling IMSL's MDNOR @Index[MDNOR] routine.


@SubSection[Romberg Extrapolation - DCADRE]
@Label[dcadre]

These three routines are based on the IMSL subroutine DCADRE, providing
a package for doing Numerical Integration via a Cautious, Adaptive
Romberg Extrapolation. 

@fcn[Name="IMSL_ROMBERG", Args="fn,low,hi"])
performs a romberg extrapolation,
where @i[fn] is a function of 1 argument; @i[low] and @i[hi] should be
the lower and upper bounds of integration.  @i[fn] must return floating
point values.

@fcn[Name="IMSL_ROMBERG", Args="exp,var,low,hi"])
performs a romberg extrapolation,
where @i[exp] should be integrated over the range @i[var=low] to
@i[hi]. The result of evaluating @i[exp] must always be a floating point
number.

@fcn[Name="FAST_IMSL_ROMBERG", Args="fn,low,hi"])
This function does no error checking but may achieve a speed gain over
the IMSL_ROMBERG function. It expects that @i[fn] is a Lisp function (or
translated MACSYMA function) which accepts a floating point argument 
and that it always returns a floating point value.


These functions return one of:

*** begin indent  0,5; here[SUCCESS, answer, error] where answer is the result of the integration and
error is the estimated bound on the absolute error of the output.
(The error estimate is referred to in the IMSL documentation by 
the name DCADRE).

[WARNING, n, answer, error] where n is a warning code, answer is the answer,
and error is the estimated bound on the absolute error of the output, DCADRE.
This is just like [SUCCESS, answer, error], but
the following non-fatal warning codes may accompany the result:
*** begin indent  5,10;turn on ""; here65 =(11)One or more singularities were successfully handled.

66 =(11)In some subinterval(s), the estimate of the integral was accepted
merely because the estimated error was small, even though no regular
behavior was recognized.
*** begin indent ends here

[ERROR, errorcode] where error code is the IMSL-generated 
error code. The following error codes may occur:
*** begin indent  5,11;turn on ""; here131 =(12)Failure due to insufficient internal working storage.

132 =(12)Failure. This may be due to too much noise in function 
(relative to the given error requirements) or due to an
ill-behaved integrand.

133 =(12)RERR is greater than 0.1 or less than 0.0 or is too small
for the precision of the machine.
*** begin indent ends hereThe following flags have an influence upon the operation of IMSL_ROMBERG:

ROMBERG_AERR[1.0E-5] @Index[ROMBERG_AERR] -- Desired absolute error in answer.

ROMBERG_RERR[0.0] @Index[ROMBERG_RERR] -- Desired relative error in the answer.


@SubSection[FMIN - Finding the Minimum of a Function]
@Label[ftmo]

FMIN is a package for finding the minimum of a function of @i[n] arguments 
using a quasi-Newton algorithm starting with a set of estimates of the 
result.

@fcn[Name="FMIN", Args="f,x"])
where @i[f] is a function of @i[n] variables and @i[x] is a list of
length @i[n] containing the initial parameter estimates for @i[f].


This function returns one of:

*** begin indent  0,5; here[SUCCESS, @i[f(x[1],x[2],...) = minval], GRADIENT = @i[gradlist],
SIGNIFICANT_DIGITS = @i[sig] ] where the first value is an equation with
the @i[x] values and the function's minimum value, @i[minval], plugged
in; the @i[gradlist] represents the gradient at that point, and @i[sig]
is the estimated number of significant digits in the result.

[ERROR, errorcode] where error code is the IMSL-generated 
error code. The following error codes may occur:
*** begin indent  5,11;turn on ""; here130 =(12)Iteration terminated due to rounding errors becoming dominant.
No useful result was obtainable.

131 =(12)Iteration was terminated because the maximum number of calls
to the given function was exceeded. (cf FMIN_MAXFN)
*** begin indent ends here
The following flags have an influence upon the operation of FMIN:

FMIN_NSIG[3] @Index[FMIN_NSIG] Convergence criterion. The number of digits of 
accuracy required in the parameter estimates. This convergence
criterion is satisfied if on two successive iterations, the
parameter estimates agree to FMIN_NSIG digits.

FMIN_MAXFN[500] @Index[FMIN_MAXFN] Maximum number of calls to the given function
which are allowed.

       See demo BATCH(FMIN,DEMO,IMSL1)

.subsec(Jenkins-Traub Method for Finding Zeros - ZRPOLY,jtmffz)

ZRPOLY is a package that uses Jenkins-Traub method for finding zeros
of polynomials with real coefficients. It provides a function, POLYROOTS,
which is based on the IMSL ZRPOLY @Index[ZRPOLY] routine.

@fcn[Name="POLYROOTS", Args="polynomial"])

The @i[polynomial] must be a simple polynomial -- single variable,
real coefficients,  non-negative exponents.

This function returns one of:

*** begin indent  0,5; here[SUCCESS, [eqn1, eqn2, ..., eqnN]] where eqnI's are the computed roots
of the equation expressed in terms of an equality between the variable
of the input polynomial and each of the the zeros found. Solutions may 
be real or complex and may be duplicated if there are multiplicities.

[ERROR, errorcode {, data} ] where error code is the IMSL-generated 
error code. The following error codes may occur:
*** begin indent  5,11;turn on ""; here129 =(12)The degree of the polynomial is greater than 100 or less 
than 1.

130 =(12)The leading coefficient is 0.

131 =(12)ZRPOLY found fewer than NDEG zeros. If only M Zeros are found,
Z[j] (for j=1,...,M) are returned as the optional data part 
(third element) of the return value.
*** begin indent ends here.endfunction

All computations are performed in single-precision.

For a demo of this package, do BATCH(ZRPOLY,DEMO,IMSL1).

@SubSection[Solving Systems of Non-Linear Equations - ZSOLVE]
@Label[ssonle]

ZSOLVE is a package for solving N simultaneous non-linear equations in 
N unknowns to obtain an approximate numerical solution. It uses the
IMSL routine ZSYSTM @Index[ZSYSTM].

@fcn[Name="ZSOLVE", Args="F,X"])
solves a vector of non-linear equations, @i[F], given as a list of functions
of @i[n] variables. The second argument, @i[X], should be an @i[n]-length
list of  initial approximations for the solution.

Returns one of:

*** begin indent  0,5; here[SUCCESS, [@i[x[1], x[2], ..., x[n]]]] where @i[x[i]]'s are the
computed values for the various variables

[ERROR, errorcode] where error code is the IMSL-generated 
error code. The following error codes may occur:
*** begin indent  5,11;turn on ""; here129 =(12)Failure to converge within ZSOLVEITMAX iterations.

130 =(12)Apparent singularity (to single precision arithmetic
standards) has been encountered twice.
*** begin indent ends here
The following flags have an influence upon the operation of ZSOLVE:

*** begin indent  0,5; hereZSOLVEEPS[1.0E-6] @Index[ZSOLVEEPS] - First stopping criterion. A root xI is 
accepted if the maximum absolute value of f (X) is less 
than or equal to ZSOLVEEPS.

ZSOLVENSIG[5] @Index[ZSOLVENSIG] - Second stopping criterion. A root is accepted if two
successive approximations to a given root agree 
in the first ZSOLVENSIG digits.

ZSOLVEITMAX[100] @Index[ZSOLVEITMAX] - The maximum allowable number of iterations.

*** begin indent ends here

@u[]emarks@-[10]
ZSYSTM (the translated Fortran routine) will terminate processing if a
root is not found within ZSOLVEITMAX iterations and/or if the Jacobian
matrix of the system of equations becomes computationally singular (to
within numerical tolerances of single-precision arithmetic). In this
case, a different initial approximation should be tried and/or the 
equations should be studied to see if some of the equations or variables
can be elimiated or solved for in terms of others.


@subsection(Eigenvalues and Eigenvectors - EIGRS, EIGRF)
@label(imsl!eigen)

EIGRF @Index[EIGRF] computes complex eigenvalues and eigenvectors of matrix with
real entries. EIGRS @Index[EIGRS] computes eigenvalues and (optionally) eigenvectors 
of a real symmetric matrix. These work according to the IMSL documentation.

There is a somewhat prettier interface to EIGRS, called
SEIGEN @Index[SEIGEN], which accepts a matrix and optional IJOB value
(default 0) variable for EIGRS. For example,
Translation Lossage ******
.inline  function(SEIGEN,|M|)
 ******
gets the eigenvalues of a matrix M or
Translation Lossage ******
.inline  function(SEIGEN,|M,2|)
 ******
gets the eigenvalues and eigenvectors. The matrix, M, must be input in
a special format, however. The matrix must be symmetric, and a matrix of the
form:

@Begin[Example]
[ x1.1  ---          ]
[ x2.1 x2.2 ---      ]
[ x3.1 x3.2 x3.3 --- ]
[ ...                ]
@End[Example]

must be input as a list of the form:

@Begin[Example]
[ x1.1, x2.1, x3.1, ...,
  x2.2, x2.3, ...,
  x3.3, ..., ... ]
@End[Example]

Important: Note that the input format is column major order and the
`matrix' is actually just a list!

@SubSection[Miscellaneous Functions]
@Label[imsl!misc]

Some IMSL routines do not have hand-tailored MACSYMA interfaces but are
available with names and calling sequences that are nearly identical 
to that given in the IMSL documentation. They include:

@fcn[Name="DVERK", Args="n,fcn,x,y,xend,tol,ind,c,nw,w,ier"])
finds solutions to differential equations via RUNGE-KUTTA method.
This works almost the same as described in the IMSL documentation except
that the second argument, @i[fcn], takes a modified calling sequence 
because MACSYMA is not call-by-reference as Fortran is.

The @i[fcn] argument is expected to be a function of 3 
parameters: @r[I], @i[X], and @i[Y]. @i[I] is the index of the
YPRIME[@i[I]] being calculated, @i[X]1 is the point the function is
being evaluated at, and @i[Y] is a list of Y's values.


LEQT1B @Index[LEQT1B] and LEQT1F @Index[LEQT1F] are linear equation solvers. They work exactly
as described in the IMSL documentation. A MACSYMA demo is available by
doing BATCH(LEQT1B,DEMO,IMSL1) and BATCH(LEQT1F,DEMO,IMSL1).

@Section[Additional Trigonometric functions]
@Label[ntrig]

There are two files which extend MACSYMA's trigonometric functions:

SHARE1;NTRIG FASL allows MACSYMA to 
compute trig functions with arguments of the form N*%PI/10 for integer N. 
Do LOAD(NTRIG) to access this.

The main functions are USIN @Index[USIN](N) and UCOS @Index[UCOS](N).

SHARE1;ATRIG1 FASL contains several additional simplification rules for
inverse trig functions.  Together with rules already known to MACSYMA, the
following angles are fully implemented: 0, %PI/6, %PI/4, %PI/3, and %PI/2.
Corresponding angles in the other three quadrants are also available.
Do LOAD(ATRIG1); to use them.

@Begin[Example]
Examples:

(C2) ASIN(SQRT(3)/2);
@Hinge
                                     %PI
(D2)                                 ---
                                      3


(C3) ACSC(2);
@Hinge
                                     %PI
(D3)                                 ---
                                      6

@End[Example]
