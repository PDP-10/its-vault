.<<(c) Copyright 1983 Massachusetts Institute of Technology>>
.chap (Secondary Storage Functions,secstor)

.sec (Introduction,secstorint)

There are two different reasons for wanting to use secondary storage
while running a MACSYMA.  Sometimes the user's intermediate
expressions are large, and it is impossible to complete the job if all
the intermediate expressions are kept in main memory.  In this case
the user would like to have his intermediate expressions written
automatically onto the disk, in order to free main memory.  On the
other hand, some users would like to save some expressions onto the
disk so that they can be read back into a future MACSYMA at a later
time.  In this case the user would like to specify certain expressions
to be stored and to name the disk file where they are to be stored.
MACSYMA offers the user two secondary storage schemes.  The user may
ask to have his expressions automatically filed away onto the disk, or
he may, by means of the $fun<SAVE> and $fun<STORE> functions, exercise
explicit control over the storage of expressions.  These latter
functions give the user more power and flexibility at the expense of a
greater effort.  It is expected that the user whose only concern is to
run a big job which would not run without using secondary storage will
use the automatic storage scheme, while the user who wishes to save
expressions for use in later MACSYMAs will use the SAVE and STORE
functions.

.sec (Automatic Storage of Expressions,autostor)
2
.isolate(A - How to use it)
*To activate the automatic storage scheme the user merely sets the
MACSYMA option $var<DSKUSE/FALSE> to TRUE.  From this point on
labelled expressions will be written out periodically onto the disk.
(A labelled expression is one which is referred to by a line label,
e.g. D4, C7, E12.)  Once an expression is written onto the disk it
will no longer reside in main memory and most of the main memory
storage taken up by it will be released. When the user attempts to
reference an expression which has been stored onto the disk, MACSYMA
will retrieve the correct value from the disk file.  In this scheme
expressions are copied periodically onto the disk whenever there are
enough to write out (see FILESIZE).  An alternative heuristic to use
in order to free some storage is to write out all labelled
expressions, values, functions, and arrays whenever the garbage
collector finds that space is getting low. This is the purpose of the
$var<DSKGC/> function $see<utility!functions>.

If the user is dealing with large expressions then his storage limit
may be exceeded before FILESIZE expressions have been generated.  In
this case the DSKGC method should be used.  If this situation does not
occur and if the user prefers to have some control over how many
expressions are saved in each file then the other scheme should be
used.  2
.if lines < 8 then next page;
.isolate(B - Cleaning up the disk)
* The automatic storage scheme will in general cause several disk
files to be created, which are of no further value after the user has
finished running his current MACSYMA. There is a function called
$fun<REMFILE>, which will delete all the files created by the
automatic storage scheme.  Thus if the user does not want these files
to stay around, he should execute REMFILE() before leaving MACSYMA.
REMFILE will only delete files created in the same MACSYMA to which
the REMFILE function is given.  In order to delete files created in
previous uses of MACSYMA it is necessary to use the $fun<DELFILE>
function $see<utility!functions>.  2
.isolate(C - Options)
* The user may specify how often files are written, how large they
are, what they will be named, and what gets stored in them, or he may
accept the default values for all these.  The following MACSYMA
options are relevant.

$var<FILENAME/> - The value of this variable is the first name of the files which are
generated by the automatic disk storage scheme.  The default value is
the first three characters of the user's login name concatenated with
an integer, the lowest integer which insures a unique name (e.g. ECR1).

$var<STORENUM/> - The value of this variable, an integer, is the
second name of the last file written.  Each time a file is written,
this value is first increased by 1, so it must always be an integer.
It is initially set to 1000.

$var<FILESIZE/> - The value of this variable is the number of
expressions written into each file.  The default value is 16.


$var<DEVICE/> - The value of this variable is the default device.  It
is initialized to DSK.

$var<DIREC/> - The value of this variable is the default file directory for
SAVE, STORE, FASSAVE, and STRINGOUT.  It is initialized to the user's
login name, if he has a disk directory, and to one of the USERS2i1
directories otherwise.  DIREC determines to what directory disk files
will be written.

$var<DSKALL/> - If TRUE will cause values, functions, arrays, and
rules to be written periodically onto the disk in addition to labelled
expressions.  TRUE is the default value whereas if DSKALL is FALSE
then 2only1 labelled expressions will be written.

For information about how large your files are and how much space they
are using, see $fun<FULLDISKUSE>, $fun<DISKUSE>, and $fun<PRINTDISKUSE>
in $ref<disk!storage>.

.sec (|Explicit Storage of Expressions|,explicitstor)

.subsec(|Use of the storage functions|,storage!functions)

The functions $fun<SAVE>, $fun<STORE>, and $fun<FASSAVE> allow the
user to explicitly state that certain expressions should be written
onto the disk.  These functions also allow him to specify the file
into which these expressions should be written.  They allow the user
to store away arrays, function definitions, rules, and any other type
of information.  The main purpose of these functions is to allow the
user to save expressions onto the disk so that they can be read into
future MACSYMAs.

SAVE and STORE are identical in all respects but one.  When an
expression is STOREd it is both written onto the disk and removed from
main memory. (When the expression is referenced, of course, the
correct value is retrieved from the disk.)  When an expression is
SAVEd, it is written onto the disk but not removed from main memory.
The only difference between these two functions is their effect on
main memory storage.

FASSAVE is similar to SAVE but produces a FASL file in which the
sharing of subexpressions which are shared in core is preserved in the
file created.  Hence, expressions which have common subexpressions
will consume less space when loaded back from a file created by
FASSAVE rather than by SAVE.  The user should note that FASSAVE files
are not as flexible as SAVE files since the RESTORE function (see
below) cannot be applied to them.  Also if the user's MACSYMA is
already near maximal allocation, FASSAVE , which uses a considerable
amount of space and time in doing its job, may not work, whereas SAVE
still might.

SAVE, STORE, FASSAVE take any number of arguments.  If the first
argument is a list it is assumed to be the file specification (e.g.
[fn1, fn2, DSK, directory]).  In accordance with the standard options
for file specifications, the latter arguments may be omitted from the
list and the defaults will be assumed.  If the first argument is not a
list, the expressions will be written into a file with the default
filename.  The value of the MACSYMA variable $var<FILENAME/> is the
default first filename, and the value of the MACSYMA variable
$var<FILENUM/0> is the default second filename.  The value of FILENUM
is increased by 1 each time a file is written, so its value must
always be an integer. FILENUM is initially 0.  The value of DEVICE is the
default device, and the value of DIREC is the default directory.

All arguments to SAVE or STORE, except possibly the first, must be one
of the following:

(1) The name of an "information list" $see<property!specification>.
SAVE(VALUES) will not cause MACSYMA options (e.g. SHOWTIME, RATPRINT,
etc.) to be saved.  Also ALIASES will be automatically saved with
every use of the SAVE function if they exist.

(2) ALL - When this atom is an argument every quantity associated with
any information list is written.

(3) [m,n] - when this list is given as an argument, every label whose
line number lies between m and n inclusive gets written.

(4) When any other atom is an argument, it must be either an array, a
function, or have a value.  It gets written onto the disk.

(5) A=B - The effect is similar to the case where the argument is just
B, i.e. B gets written onto the disk.  The only difference shows up if
the file is read into some future MACSYMA.  In that case, the
expression which is referred to as "B" in the present MACSYMA will be
referred to as "A" in the future MACSYMA.  For example, suppose the
user wishes to save some expression, say D7, for use in a future
MACSYMA.  He can execute STORE([FOO, BAR], YESTERDAYSD7 = D7).  D7 is
now stored onto the disk.  When he comes back the following day and
load in a fresh MACSYMA he merely executes $fun<LOADFILE>(FOO, BAR,
DSK, ECR) and the variable YESTERDAYSD7 will take on the value which
D7 had yesterday.  This renaming however has no effect on the present
MACSYMA, where D7 must still be referred to as "D7".  Note that if a
SAVEd or STOREd file contains labelled expressions they may conflict
with expressions having the same label in the MACSYMA into which the
file is loaded.  For example if D9 is in a file which is loaded into a
MACSYMA then it would replace the D9 which was already in the MACSYMA
(if there was a D9 generated), or it would itself be replaced by D9
when the new D9 was generated.  To avoid this difficulty the user
should give labelled expressions a name as described in (4) above.  He
could also set $var<LINENUM/> in the new MACSYMA or save it from the
old one so that line numbers wouldn't conflict.

The user should note that each use of the SAVE or STORE function will
cause exactly one file to be written, regardless of the number of
arguments the function is given.

SAVE, STORE, and FASSAVE return a list of the form [2file specification,
size of file in blocks1,...] where ... are the things saved.
Warnings are printed out in the case of large files, or if an empty file
is accidently generated.

SAVE, STORE, and FASSAVE may be used while a WRITEFILE is in progress.

REMFILE(TRUE) and REMFILE(ALL) will perform REMFILE()
(see $ref<autostor> - B) and in addition will delete files created by SAVE
or STORE which haven't been assigned names explicitly by the user.

Certain MACSYMA variables (i.e. $var<LINENUM/>, $var<FILESIZE/>, etc.)
are used to communicate to the MACSYMA system that certain options are
in effect, or to tell the system to use certain values.  These
variables should not be STOREd (though they may be SAVEd), since the
system programs will not be able to correctly retrieve their values
from the disk.  In general, one should not attempt to STORE variables
whose purpose is to provide information to the system (i.e.  MACSYMA
options).

.subsec(|Retrieval of expressions stored on disk|,retexp)
2
.isolate(1 - In the MACSYMA you are using)
*
Expressions which are written onto the disk using the SAVE function also reside
in main memory, so the notion of retrieving them from the disk in the present
MACSYMA is not applicable. Expressions written onto the disk using STORE,
however, no longer reside in main memory.  When such expressions are referenced
the system will always retrieve the correct value from the disk.  When a STOREd
array is referenced, the array will be brought back to main memory.  Functions
and values will be read from the disk correctly, but will not be returned to
main memory.  If the user wants to bring an expression back to main memory he
may use the function UNSTORE.  This function takes any number of arguments.
Each argument must be an atomic variable, and if this atomic variable refers to
an expression which is stored onto the disk, the expression is returned to main
memory.  Of course, when an expression is UNSTOREd, either by the user or by
the system (as happens when STOREd arrays are accessed), a copy of the
expression still remains on the disk in the assigned file.
2
.isolate(2 - In future MACSYMAs)
*
Files created by SAVE and STORE can be loaded into future MACSYMAs
using the LOAD or LOADFILE functions.  This will set up in main memory
all those expressions which were written into the file.  Some of the
expressions will have different names than they had in the MACSYMA
where they were created, if the renaming option (i.e. arguments of the
form A=B) of the STORE or SAVE function was used.  Also, unless the
FASSAVE scheme was used, expressions will generally take up more space
than they did in the MACSYMA where they were created, as sharing among
common subexpressions will be lost.

.sec (Saving a MACSYMA Overnight,savmacsym)

Often a user in the middle of his work would like to save everything onto the disk so he
can go home and resume work tomorrow.  When the user decides to save the state of his
MACSYMA, he should execute for example:
$fun<SAVE>([fn1,fn2,DSK,directory],ALL)

This will write all his lines, arrays, functions, values, rules, and
aliases (if he has created any), and the current value of LINENUM into
a single disk file named fn1 fn2 (where these may be any names given
by the user).  Of course, the user should choose names for his files
which are unique.  If he does not have his own directory then he
should use one of the USERS2i1 directory and his login name for the first
file name.  If the automatic storage scheme was in effect he should
now execute $fun<REMFILE>(); to delete useless files from the disk.
When the user comes back the next day he should load a fresh MACSYMA
and execute one of the following two functions:

.example
   LOADFILE(2fn1, fn2, DSK, directory*);

or RESTORE(2fn1, fn2, DSK, directory*);
.end

The first command will cause all expressions to be loaded into the present
MACSYMA.  Whereas all the expressions may have fit into the MACSYMA in which
they were generated, they may not fit into a new MACSYMA, because common
subexpressions originally shared will not be shared in a new MACSYMA. However if
the $fun<OPTIMIZE> function is used  $see<extracting!expressions>, then some sharing of common subexpressions
may be obtained.  The $fun<RESTORE> function does not cause the expressions to be
loaded into main memory but does permit them to be accessed when needed.  (This
is as though STORE had been used on the information.)  Thus it should be used if
it is not desired to bring all the expressions into main memory at the same
time.

