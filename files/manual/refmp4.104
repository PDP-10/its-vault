.if partial then start
.count chapter from 7 printing "1"
.count section in chapter printing "!.1"
.count subsection in section printing "!.1"
.end

.chap (The MACSYMA Editor, macedit)

.sec (Introduction,edint)

The major features of the editor are its concise
commands (few alphabetic characters), its varied assortment of commands, concatenation of commands as in
TECO (the PDP-10 file editor), mnemonics for command names (once you know them,
R means "move in the Reverse direction" ; B means "move to the Bottom" ), and
compatibility with TECO as to command names (in the case of C, D, F, G, I, J, K,
L, R, and S).

.sec (Entering the Editor,entered)

At any time while the user is inputting a command line to MACSYMA, he may enter
the input-stream editor by typing "altmode" or "escape", henceforth denoted by
<$>.  The editor is given the string of characters typed so far in the current
input line.  In the case of a detected syntax error, upon typing <$> the entire
previous command string will be given to the editor.  Before typing in the next
command string, one may always elect instead to edit the previous command string
in this manner.  This is useful in making it unnecessary to retype a command
line similar to the previous one when that command line did not have the desired
effect.  Note however, that <$> must be the first character typed on the next
command line.  Any other character (except "space") causes the edit buffer to be emptied.

One may also request the editor to edit or modify a previously accepted input
line by using the $fun<STRING> function in MACSYMA.  Typing STRING(Ci) will restore
the expression labeled as Ci as the current input string.  This enables the user
to modify it by then immediately typing <$>.  For a simpler method, see the MYV command below.

All the commands to the editor reference a cursor (displayed as an underscore or
back-arrow, depending on the console) which is displayed within or at either end
of the string of characters currently being edited (called the "input string"
from now on).  The value of the variable $var<CURSOR/> determines what character is
used $see<ioptions>.

The editor accepts a command string which must be terminated by <$><$>.  A
command string is any concatenation of one or more legal commands which will be
processed in left-to-right order.  Display of the input string occurs at the end
of the processing of each command string.  <$> is used to enter the editor, to
exit from the editor (as <$><$>), and to terminate insert or search substrings.
Otherwise, spurious <$>'s are ignored.  Rubouts (the rubout or delete key on the
console) may be used at any point prior to command termination to delete the
last character typed in.  ?? deletes the entire command. At any point prior to
command termination, the user may type a <control>K, and the editor will reprint
the characters of the command typed so far.

Occasionally, one gets a syntax error because of omitting characters from the
end of a command (especially right parentheses).  By typing <$><$><$>
immediately, as the first 3 characters of the next input line, the last command
will be automatically reproduced on the current input line at which point one
can supply the missing characters or rubout erroneous characters.  For example:

.example group turn on ""
(C1) (((X+1)*X+2)*X+3$
( ( ( X + 1 ) * X + 2 ) * X + 3 ***$***
SYNTAX ERROR
PLEASE REPHRASE OR EDIT

(C1) <$>
_(((X+1)*X+2)*X+3
<$><$>
(C1) (((X+1)*X+2)*X+3 )*X+4$
1(In the above line the user typed the
			characters after the 3)*
.end

.sec ("A Description of the Commands",commandescr)

Some commands may be prefixed by an integer (represented below by "n") which
usually may be positive or negative; although it may be zero as well in the case
of K, L, and W; and it must be non-negative in case of W.  The default value of
n is +1.  Except in the case of R, if n is positive the commands operate toward
the right of the cursor, if n is negative they operate toward the left.  I and S
are two of the few commands which may be followed by other characters, namely the
characters which constitute the insert or search strings.  An error message will
be printed if an illegal command substring is encountered or if any command
substring fails.  In case of such error, the processing of the current command
string will be terminated at that point, with the offending command substring
indicated.
.skip 1

.begin fill compact
.tabs 12, 24, 36, 48
.indent 0,23
.turn on "\"
2Command    \Mnemonic   \Action*

.skip 1
2Commands which move the cursor*

nC      \Character    \moves the cursor past n characters.

nR      \Reverse      \moves the cursor past n characters in the reverse direction
                      (nR =  -nC).

J or T  \Jump to Top  \moves the cursor to the beginning of the input string.

B or ZJ  \Bottom       \moves the cursor to the end of the input string.

nL      \Line         \moves the cursor to the right of the nth carriage return (0L
                      moves left); e.g., L moves to the next line.

nSstring<$>           \\moves the cursor to the right (left if n is negative) of the nth
                      occurrence of "string" in the input string.

nS      \Search       \repeats the last S command given.

) or ]  \Move         \moves the cursor right from the current position over the next
                      balanced pair of parentheses (or brackets).

( or [  \Move         \similar to ) or ] but moves left.

.skip 1
2Commands which delete characters*

nD      \Delete       \deletes n characters, and saves them in the "save-register"
                      (see the G command below).

nK      \Kill         \deletes all the characters through the nth carriage return
                      (0K kills left), and saves them in the "save-register";
                      e.g., K deletes the remainder of this line.

M) or M]\Delete       \similar to ) or ] but deletes the characters moved over and
                      saves them in the "save-register".

M( or M[\Delete       \similar to M) or M] but moves left.

nFRstring<$>          \\deletes the next n occurrences of string. (This command is a special case of the FR command below and can be used in this way only when it is the last argument in the command string).

.skip 1
2Commands which insert characters*

Istring<$>\Insert     \inserts the characters "string" at the current cursor position.
                      The cursor is positioned at the right of the inserted text.  If
                      no argument is given then the string of the last I command which
                      had one is used.

G       \Get          \inserts at the current cursor position the characters deleted
                      by the last use of D, K, or M.  Thus G may be used in combination
                      with D or K to move characters from one place to another in the
                      input string; or to recover from an accidental use of D or K.
                      There is only one "save-register".

nFRstring1<$>string2<$>
                      \replaces the next n occurrences of string1 by string2.  If n is
                      1 it may be omitted.  nFR given with no string arguments uses
                      those from the last FR given which had them.

MFRstring1<$>string2<$>
                      \replaces all occurrences of string1 by string2.


YVname<$>\Yank value    \puts into the editing buffer, the value of the argument whose
                      name is given, if a label or the name of a user variable, at the
                      current cursor position leaving the cursor at the end of the
                      inserted string.

YFname<$>\Yank function  \puts into the editing buffer the
                      definition of the user function whose name is given (as with YV).
                      If the name is followed by
                      a list of subscripts in brackets, then the named subscripted
                      function is brought into the buffer.  This command provides
                      an alternative to DISPFUN and STRING $see<display!functions>.

.begin indent 0, 0 skip 1
Note: If the YV or YF commands are prefixed by the letter M then the editor will
clear the buffer before yanking, and also will leave the cursor at the head of
the edit string when done.
.end

.skip 1
2Commands which control display of results*

P       \Print        \simply reprints the input string.  This is useful in case of
                      console problems.

nW      \Window       \controls the window size of the display, which is the maximum
                      number of characters displayed on each side of the cursor.
                      This is useful in case of slow consoles and large input strings.
                      0W will cause only the cursor to be displayed.  Once set 
                      the window size remains at that setting until it is reset.
V       \View         \restores the display to full view, which is the normal mode
                      (affected only by W).

Q       \Quit         \exits the editor without reprinting the just edited string.

.end

.skip 1
<$><$> will exit from the editor and is also the command string terminator.  Two
examples of legal command strings are 4C3DIFOO<$><$> and -2SBAR<$>3R<$><$>.  The
first moves right over four characters, deletes the next three characters, and
inserts FOO.  The second searches from the current pointer position to the
beginning of the text for the second occurrence of BAR then moves left over
three characters.

.example
.begin group once center
2Example3

(C1) X:1$

(C2) NATRIX([A,4],[-1,A/2]);
.end

(D2)                   NATRIX([A, 4], [- 1, 1/2 A])
(C3)<$>
_NATRIX([A,4],[-1,A/2])
DIM<$><$>
M_ATRIX([A,4],[-1,A/2])
]2CD<$><$>
MATRIX([A,4],[_1,A/2])
<$><$>   1(In the line below the user typed the ;)*
(C3) MATRIX([A,4],[1,A/2]);

.begin group
			       [ A    4   ]
(D3)                           [          ]
			       [ 1  1/2 A ]
.end
(C4) CHARPOLY(%,X);
(D4)                     (A - 1) (1/2 A - 1) - 4
(C5)<$>
_CHARPOLY(%,X)
S%<$>-DID3<$>CI'<$><$>
CHARPOLY(D3,'_X)
<$><$>   1(In the line below the user typed the ;)*
(C5) CHARPOLY(D3,'X);
(D5)                     (A - X) (1/2 A - X) - 4
.end

.chap (Batch Functions,batchap)

.sec (Introduction,batint)

The Batch set of functions in MACSYMA, namely $fun<BATCH>, $fun<DEMO>, and
$fun<BATCON> (mnemonic for BATch CONtinue), provide a facility for executing
command lines stored on a disk file rather than in the usual on-line mode.  This
facility has several uses, namely to provide a reservoir for working command lines,
for giving error-free demonstrations, or helping in organizing one's thinking in
complex problem-solving situations where modifications may be done via the PDP-10
TECO file editor.

A batch file consists of a set of MACSYMA command lines, each with its
terminating ; or $, which may be further separated by spaces, carriage-returns,
form-feeds, and the like.  The BATCH and DEMO functions have both a simple and
more complicated format, which are described below.

.sec  (The Simple Format,simpform)

.inline function(BATCH,|filename1, filename2, DSK, directory|)

(The same function format holds for $fun<DEMO> as well.)  The arguments to BATCH (or
DEMO) in this format specify the file which is to be batched. Here, each file is
specified by two filenames of at most six characters each, the device the file
is on ( which is normally DSK), and the user file directory.  E.g.
DEMO(TAYLOR,DEMO,DSK,DEMO) calls for "demonstrating" (see below) the file TAYLOR
DEMO on the DEMO disk directory. Latter arguments to the BATCH or DEMO functions
may always be omitted if they are known from previous file-manipulating
functions.

The BATCH function calls for reading in the command lines from the file one at a
time, echoing them on the user console, and executing them in turn.  Control is
returned to the user console only when serious errors occur or when the end of
the file is met.  Of course, the user may quit out of the file-processing by
typing <control> ^ at any point $see<hints> .

DEMO differs from BATCH only in that it pauses after the execution of each
command line, waiting for the user to type a space which tells it to go on.  If
the user types any other character, file-processing will then terminate, giving
control over to the user console.  (The user may actually continue processing
from the file at any time - see the BATCON function below.)

.sec (The More Complicated Format,compform)

.inline function(BATCH,|[fn1, fn2, DSK, directory], <delay-switch>, <index-specification>|)

The arguments to 5BATCH* or $fun<DEMO> in this mode are as follows:

The first argument is the file specification (as above), enclosed in brackets.

The second argument, the delay-switch, may be answered by $var<ON/> or $var<OFF/>
(the default if it is omitted).  This switch has to do with the temporary inability
of LISP, the system underlying MACSYMA, to have more than one input file open at a
time. If in the course of batching in a file of command lines, execution of a
function forces a second file to be input, this would ordinarily cause an error.
However, setting the delay-switch to ON causes the entire batch file to be read in
before execution of it begins, thus preventing the error.  The default for the
delay-switch is OFF, as the circumstance described above is not frequent, it takes
some time to read in a batch file, and one may always continue batching via the
$fun<BATCON> function.  As soon as the inability of LISP is removed, this switch will no
longer be needed.

The index-specification is given by one or two arguments, the possibilities being:
(In the following, m and n are positive integers.)

(i) 2m1.  This indicates that processing is to begin with the mth command line in the
file.  Thus, the default for the index-specification is 1.

(ii) 2m1, 2n1.  This indicates that only the 2m1th command line through
the 2n1th command line are to be processed.

(iii) a variable (say FOO).  FOO must be non-numeric and neither TRUE nor FALSE.
This causes file-processing to begin at FOO&& $see<batmisc> and continue until
the end of the file.  This makes it unnecessary to count command lines as
required by (i) above.

(iv) variable (say FOO), continue-flag.  The continue-flag is either ON (the
default, and unnecessary) or OFF.  If OFF, this enables one to separate a batch
file into subfiles by prefixing a command line in the file with FOO&&.  By using
FOO as the index-specification, one may execute only that subfile which begins
with FOO and ends with some other variable&&, or the end of file.  If the
continue-flag is ON, this causes mode (iv) to operate as (iii) above.

One can see that BATCH(TAYLOR,DEMO,DSK,DEMO) and BATCH([TAYLOR,DEMO,DSK,DEMO], OFF,
1) are equivalent.

.sec (The BATCON Function,batconfun)

The $fun<BATCON> function is used to continue or change the last $fun<BATCH> or
$fun<DEMO> function, without it being necessary to mention again BATCH or DEMO, the
file specification, or the setting of the delay-switch.  Of course, if one wishes
to change any of these, a new call to BATCH or DEMO is required.

The possible arguments to BATCON are as follows:

(i) a number

(ii) number1, number2

(iii) a variable

(iv) variable, continue-flag

They are all as in 8.3.  The numeric arguments may involve the variable $var<BATCOUNT/0>
which is set to the number of the last expression BATCH'ed in from the file.
Thus BATCON(BATCOUNT-1) will resume BATCH'ing from the expression before the
last BATCH'ed in from before.  One other mode is possible:

(v) skip-flag.  The skip-flag is useful if an error has occurred while batching,
or if the user wishes to interject command lines from the console while in
DEMO-mode and then to continue processing from the file.  The skip-flag may be
either TRUE or FALSE.  If FALSE, this indicates that processing is to continue
with the last command line attempted (supposedly edited, in case of error); if
TRUE, this indicates that processing is to continue with the next (untried)
command line in the file.

.sec (Miscellany,batmisc)

(1) Comments may be added to batch files at any point, and will, of course, be
treated as such when batching in the file.  A comment is any string beginning
with /* and ending with */ as in PL/I.

(2) Any command line in a batch file may begin with variable&&.  This labels
that command line so that the file can be partitioned into subfiles.  If not in
a subfile mode, this prefix will be treated as a comment.

(3) When using the batch functions, it is inconvenient to keep track of which Di
label MACSYMA will assign to a computation; yet later command lines often need
to refer to an earlier computation.  One way to get around this, of course, is
for the user to explicitly label some of his command lines.  A function %TH is
also provided, such that %TH(i), where i is positive, refers to the result of
the i2th1 previous command line.  E.g., %TH(1) and the variable % both refer
to the same computation.

(4) When $fun<BATCH>ing in several files it is possible for one file to
unintentionally cause an error to occur in a subsequent one by duplication of
names or settings of options.  If the variable $var<BATCHKILL/FALSE> is TRUE however, then
the effect of all previous BATCH files is nullified because a KILL(ALL) and a
RESET() will be done automatically when the next one is read in.  If BATCHKILL is bound to any
other atom then a KILL(BATCHKILL) will be done.  (The default value of BATCHKILL
is FALSE meaning to do nothing.)

(5) While BATCHing in a file which takes a lot of time to process the user may
leave his terminal unattended.  If an error occurs he may want some special
action to be taken automatically.  By setting the option $var<ERRORFUN/> to the
name of a function of no arguments one can have that function executed when any
error occurs.  Useful functions are $fun<QUIT> and $fun<LOGOUT>. However in the
case of LOGOUT the user should also set the switch TTYOFF to TRUE to prevent his
job from hanging up in the case it tries to output to the terminal $see<hints>. In addition if a file has been opened for writing, then a command
to close it should be executed before the LOGOUT.  Also,
the user may wish to set $var<DYNAMALLOC/FALSE> to TRUE
$see<storman> so that his job will not hang if additional
storage space is needed

If the user is executing a function of his own and would like to signal an error
he can use the functions ERROR and ERRCATCH $see<miscfun>.  

(6) If the user does not have a directory of his own then he can
use the one called USERS to store his files.  He should identify them as his in some fashion such as using his login name
for the first file names.

(7) The DEMO file directory contains many demonstration files which may be helpful to the user in learning to use MACSYMA.


.chap (Secondary Storage Functions,secstor)

.sec (Introduction,secstorint)

There are two different reasons for wanting to use secondary storage while
running a MACSYMA.  Sometimes the user's intermediate expressions are large, and
it is impossible to complete the job if all the intermediate expressions are
kept in main memory.  In this case the user would like to have his intermediate
expressions written automatically onto the disk, in order to free main memory.
On the other hand, some users would like to save some expressions onto the disk
so that they can be read back into a future MACSYMA at a later time.  In this
case the user would like to specify certain expressions to be stored and to name
the disk file where they are to be stored.  MACSYMA offers the user two
secondary storage schemes.  The user may ask to have his expressions
automatically filed away onto the disk, or he may, by means of the $fun<SAVE> and
$fun<STORE> functions, exercise explicit control over the storage of expressions.
These latter functions give the user more power and flexibility at the expense
of a greater effort.  It is expected that the user whose only concern is to run
a big job which would not run without using secondary storage will use the
automatic storage scheme, while the user who wishes to save expressions for use
in later MACSYMAs will use the SAVE and STORE functions.

.sec (Automatic Storage of Expressions,autostor)
2
.isolate(A - How to use it)
*To activate the automatic storage scheme the user merely sets the MACSYMA option
$var<DSKUSE/FALSE> to TRUE.  From this point on labelled expressions
will be written out periodically onto the disk.  (A labelled expression is one
which is referred to by a line label, e.g. D4, C7, E12.)  Once an expression is
written onto the disk it will no longer reside in main memory and most of the
main memory storage taken up by it will be released. When the user attempts to
reference an expression which has been stored onto the disk, MACSYMA will
retrieve the correct value from the disk file.  In this scheme expressions are
copied periodically onto the disk whenever there are enough to write out
(see FILESIZE).
An alternative heuristic to use in order to free some storage is to write out
all labelled expressions, values, functions, and arrays whenever the garbage
collector finds that space is getting low. This is the purpose of the $var<DSKGC/>
function $see<utility!functions>.

If the user is dealing with large expressions then his storage limit may be
exceeded before FILESIZE expressions have been generated.  In this
case the DSKGC method should be used.  If this situation does not occur and if
the user prefers to have some control over how many expressions are saved in
each file then the other scheme should be used.
2
.isolate(B - Cleaning up the disk)
*
The automatic storage scheme will in general cause several disk files to be
created, which are of no further value after the user has finished running his
current MACSYMA. There is a function called $fun<REMFILE>, which will delete all the
files created by the automatic storage scheme.  Thus if the user does not want
these files to stay around, he should execute REMFILE() before leaving MACSYMA.
REMFILE will only delete files created in the same MACSYMA to which the REMFILE
function is given.  In order to delete files created in previous uses of MACSYMA
it is necessary to use the $fun<DELFILE> function $see<utility!functions>.
2
.isolate(C - Options)
*
The user may specify how often files are written, how large they are, what they will
be named, and what gets stored in them, or he may accept the default values for all
these.  The following MACSYMA options are relevant.

$var<FILENAME/> - The value of this variable is the first name of the files which are
generated by the automatic disk storage scheme.  The default value is
the first three characters of the user's login name concatenated with
a three-digit random number (e.g. ECR864)

$var<STORENUM/> - The value of this variable, an integer, is the second name of the last
file written.  Each time a file is written, this value is first
increased by 1, so it must always be an integer.  It is initially set to 0.

$var<FILESIZE/> - The value of this variable is the number of expressions written into
each file.  The default value is 16.


$var<DEVICE/> - The value of this variable is the default device.  It is initialized
to DSK.

$var<UNAME/> - The value of this variable is the default sname.  It is initialized to
the user's login name, if he has a disk directory, and to USERS
otherwise.  UNAME determines to what directory disk files will be
written.

$var<DIREC/> - may be used as an alias for UNAME.

$var<DSKALL/> - If TRUE will cause values, functions, arrays, and rules to be written
periodically onto the disk in addition to labelled expressions.  TRUE is the
default value whereas if DSKALL is FALSE then 2only1 labelled
expresions will be written.

.sec (|Explicit Storage of Expressions|,explicitstor)

.subsec(|Use of the storage functions|,storage!functions)

The functions $fun<SAVE>, $fun<STORE>, and $fun<FASSAVE> allow the user to explicitly state that
certain expressions should be written onto the disk.  These functions also allow
him to specify the file into which these expressions should be written.  They allow
the user to store away arrays, function definitions, rules, and any other type of
information.  The main purpose of these functions is to allow the user to save
expressions onto the disk so that they can be read into future MACSYMAs.

SAVE and STORE  are identical in all respects but one.  When an expression is
STORE'd it is both written onto the disk and removed from main memory. (When the
expression is referenced, of course, the correct value is retrieved from the
disk.)  When an expression is SAVE'd, it is written onto the disk but not
removed from main memory.  The only difference between these two functions is
their effect on main memory storage.

FASSAVE  is similar to SAVE but produces a FASL file in which the sharing of subexpressions which are shared in core is preserved in the file created.  hence, expressions which have common subexpressions will consume less space when loaded back from a file created by FASSAVE rather than by SAVE.   The user should note that FASSAVE files are not as flexible as SAVE files since the RESTORE function (see below) cannot be applied to them.   Also if the user's MACSYMA is already near maximal allocation, FASSAVE , which uses a considerable amount of space and time in doing its job, may not work, whereas SAVE still might.

SAVE, STORE, FASSAVE take any number of arguments.  If the first argument is a list it
is assumed to be the file specification (e.g. [fn1, fn2, DSK, directory]).  In
accordance with the standard options for file specifications, the latter
arguments may be omitted from the list and the defaults will
be assumed.  If the first argument is not a list, the expressions will be
written into a file with the default filename.  The value of the MACSYMA
variable FILENAME is the default first filename, and the value of the MACSYMA
variable FILENUM is the default second filename.  The value of FILENUM is
increased by 1 each time a file is written, so its value must always be an
integer. FILENUM is initially 0.  The value of DEV is the default device, and
the value of UNAME is the default username.

All arguments to SAVE or STORE, except possibly the first, must be one of the
following:

(1) The name of an "information list" $see<property!specification>. SAVE(VALUES) will not
cause MACSYMA options (e.g. SHOWTIME, RATPRINT, etc.) to be saved.  Also ALIASES
will be automatically saved with every use of the SAVE function if they exist.

(2) ALL    When this atom is an argument every quantity associated with any
information list is written.

(3) [m,n]  when this list is given as an argument, every label whose line number lies between m and n inclusive gets written.

(4) When any other atom is an argument, it must be either an array, a function, or
have a value.  It gets written onto the disk.

(5) A=B  The effect is similar to the case where the argument is just B, i.e. B
gets written onto the disk.  The only difference shows up if the file is read
into some future MACSYMA.  In that case, the expression which is referred to as
"B" in the present MACSYMA will be referred to as "A" in the future MACSYMA.
For example, suppose the user wishes to save some expression, say D7, for use in
a future MACSYMA.  He can execute STORE([FOO, BAR], YESTERDAYSD7 = D7).  D7 is
now stored onto the disk.  When he comes back the following day and load in a
fresh MACSYMA he merely executes $fun<LOADFILE>(FOO, BAR, DSK, ECR) and the variable
YESTERDAYSD7  will take on the value which D7 had yesterday.  This renaming
however has no effect on the present MACSYMA, where D7 must still be referred to
as "D7".  Note that if a SAVEd or STOREd file contains labelled expressions
they may conflict with expressions having the same label in the MACSYMA into
which the file is loaded.  For example if D9 is in a file which is loaded into a
MACSYMA then it would replace the D9 which was already in the MACSYMA (if there
was a D9 generated), or it would itself be replaced by D9 when the new D9 was
generated.  To avoid this difficulty the user should give labelled expressions a
name as described in (4) above.  He could also set $var<LINENUM/> in the new MACSYMA or
save it from the old one so that line numbers wouldn't conflict.

The user should note that each use of the SAVE or STORE function will cause exactly
one file to be written, regardless of the number of arguments the function is given.

REMFILE(TRUE) will perform REMFILE() (see $ref<autostor> - B) and in addition will delete
files created by SAVE or STORE which haven't been assigned names explicitly by
the user.

Certain MACSYMA variables (i.e. $var<LINENUM/>, $var<FILESIZE/>, etc.) are used to
communicate to the MACSYMA system that certain options are in effect, or to tell
the system to use certain values.  These variables should not be STORE'd (though
they may be SAVE'd), since the system programs will not be able to correctly
retrieve their values from the disk.  In general, one should not attempt to
STORE variables whose purpose is to provide information to the system (i.e.
MACSYMA options).

.subsec(|Retrieval of expressions stored on disk|,retexp)
2
.isolate(1 - In the MACSYMA you are using)
*
Expressions which are written onto the disk using the SAVE function also reside
in main memory, so the notion of retrieving them from the disk in the present
MACSYMA is not applicable. Expressions written onto the disk using STORE,
however, no longer reside in main memory.  When such expressions are referenced
the system will always retrieve the correct value from the disk.  When a STORE'd
array is referenced, the array will be brought back to main memory.  Functions
and values will be read from the disk correctly, but will not be returned to
main memory.  If the user wants to bring an expression back to main memory he
may use the function UNSTORE.  This function takes any number of arguments.
Each argument must be an atomic variable, and if this atomic variable refers to
an expression which is stored onto the disk, the expression is returned to main
memory.  Of course, when an expression is UNSTORE'd, either by the user or by
the system (as happens when STORE'd arrays are accessed), a copy of the
expression still remains on the disk in the assigned file.
2
.isolate(2 - In future MACSYMAs)
*
Files created by SAVE and STORE can be loaded into future MACSYMAs using the
LOADFILE function.  This will set up in main memory all those expressions which
were written into the file.  Some of the expressions will have different names
than they had in the MACSYMA where they were created, if the renaming option
(i.e. arguments of the form A=B) of the STORE or SAVE function was used.  Also, unless the FASSAVE scheme was
used, expressions will generally take up more space than they did in the MACSYMA where they were created, as sharing among common subexpressions will be lost.

.sec (Saving a MACSYMA Overnight,savmacsym)

Often a user in the middle of his work would like to save everything onto the disk so he
can go home and resume work tomorrow.  When the user decides to save the state of his
MACSYMA, he should execute for example:
$fun<SAVE>([fn1,fn2,DSK,directory],ALL)

This will write all his lines, arrays, functions, values, rules, and aliases (if he
has created any), and the current value of LINENUM  into a single disk file named fn1 fn2 (where these may be any
names given by the user).  Of course, the user should choose names for his files
which are unique.  If he does not have his own directory then he should use the
USERS directory and his login name for the first file name.  If the automatic
storage scheme was in effect he should now execute $fun<REMFILE>(); to delete
useless files from the disk.  When the user comes back the next day he should load
a fresh MACSYMA and execute one of the following two functions:

.example
   LOADFILE(2fn1, fn2, DSK, directory*);

or RESTORE(2fn1, fn2, DSK, directory*);
.end

The first command will cause all expressions to be loaded into the present
MACSYMA.  Whereas all the expressions may have fit into the MACSYMA in which
they were generated, they may not fit into a new MACSYMA, because common
subexpressions originally shared will not be shared in a new MACSYMA. However if
the $fun<OPTIMIZE> function is used  $see<extracting!expressions>, then some sharing of common subexpressions
may be obtained.  The $fun<RESTORE> function does not cause the expressions to be
loaded into main memory but does permit them to be accessed when needed.  (This
is as though STORE had been used on the information.)  Thus it should be used if
it is not desired to bring all the expressions into main memory at the same
time.

.CHAP (Storage Management,storman)

In the LISP system in which MACSYMA resides, the space requirements of the
user's programs and data may be increased during the execution of the programs.
This is in contrast to static storage allocation systems in which the storage is
completely allocated before the programs are executed and consequently the
storage requirements must be completely known before execution time and cannot
be changed during program execution.  If they exceed the capacity of the memory
space that has been allocated for them, the programs will not be allowed to run.

With our LISP system, a certain amount of space is initially allocated, the
programs are started running, and the amount of space utilized changes during
execution.  If at some point the limit of available space is exceeded, program
execution will be terminated.

This LISP divides up the available memory spaces into several portions on the
basis of what kind of data they will contain.

.begin preface 1 indent 0,10
BPS - (binary program space) for compiled functions and arrays.

FIXNUM - for integers which fit into one machine word.

FLONUM - for floating point numbers.

BIGNUM - the first word of numbers bigger than one machine word.

SYMBOL - for atomic symbols.

ARRAY - for array indicators.

LIST - for anything else not in the other spaces, e.g. uncompiled
functions, symbolic expressions, etc.

PDL - for several kinds of pushdown lists.
.end
.skip 1

When a MACSYMA is started up, each space is initially allocated some fixed
amount.  These spaces will grow as the user interacts with MACSYMA, each
particular space growing as the user causes more objects to be created which
reside in that space. For example, executing a command line which causes an
out-of-core file to be loaded mainly increases BPS and LIST space.  Also new
labelled expressions are created every time a command line is executed and these
occupy LIST space.  Push down lists are used to store variables, return
addresses, and other information related to the function calling mechanism.

When a space (except for BPS and the PDLs) is used up, a process is initiated
called "garbage collection" which attempts to free up storage so it can be
reused rather than trying to increase the size of the spaces. In very simple
terms, it marks every word in a particular storage space which is still being utilized
and then links up the unmarked words (termed "garbage") on a chain to be used to
store subsequently created data.  If this chain is not of a certain assigned
minimal size, a special allocation routine is invoked. At this point several
possibilities can occur, among which is the possiblity of increasing the size of
the spaces. Before these are described however, there is something to be
mentioned which the user should take note of. The initial allocations (later to
be referred to as "level 0 allocations") are quite reasonable.  Many problems run
quite well using these allocations.  If the user's problem does not run due to
running out of storage, most often this is due to one of the following
circumstances and not to the insufficiency of the allocations:

.begin narrow 4 preface 1
(1) The user has organized his problem poorly, thereby either not solving the
problem he intended to solve, biting off too much in too short a time, or
creating intermediate expression swell of perhaps incredible proportions.  He
should get a feel for the size of all of his expressions and the behavior of
MACSYMA's functions on them.

(2) The user is retaining expressions in core that are useless to him.  Since
MACSYMA maintains a complete history of the user's session, it does not release
the storage occupied by the user's data unless explicitly instructed to do so.
This can be accomplished in several ways. One way is by using the functions
KILL, REMVALUE, REMFUNCTION, and REMARRAY $see<freeing!storage> which unbind an item from
the expression it represents thus freeing up the storage occupied by the
expression to be reclaimed on the next garbage collection. It is recommended
that the user give a name to all labelled expressions which he wishes to keep
around for a time, and then periodically do a KILL(LABELS).  He should also KILL
functions and arrays which he no longer needs.  Killing a name will not
accomplish much unless the labelled expression (D line) at which the assignment
was done is also KILLed because the two symbols are holding onto the same
expresson.

If the above approach is unacceptable because the (intermediate or final)
expressions which the user needs occupy a lot of storage,  he can store them on
the disk (kill the corresponding label if any) and have them retrieved when
needed.  This can be accomplished in the following two ways (see Chapter $ref<secstor>).

The STORE function can be used to explicitly transfer expressions from main
memory to disk.  These will be brought back into main memory each time they are
referenced. Since the process of retrieving an expression from a large file may
be rather time consuming, the user can use the UNSTORE function to bring an
expression back to main memory and keep it there. However, in general an
UNSTOREd expression will occupy more space then it originally did because
several copies of common subexpressions will be created.  These were originally
represented by pointers to a single copy.

Another way to transfer expressions to the disk is by using the automatic
storage mechanism.  This will cause expressions to be STOREd automatically in an
effort to conserve space.  As with the explicit use of the STORE function, the
expressions will be retrieved by MACSYMA when they are referenced. There are two
heuristics which MACSYMA uses to decide when to store expressions.  One is to
STORE all values, functions, arrays, and labelled expressions whenever available
space becomes low.  This is the purpose of the DSKGC function. The other
heuristic is to periodically STORE a fixed number of labelled expressions
whenever that many get created above a minimum number which are to be kept
around.  The user can utilize this option by setting the switch DSKUSE to TRUE.
In addition if DSKALL is TRUE, then all values, functions, and arrays will be
written at this time as well.

(3) A recursive infinite loop has occurred because of a bug in either the user's
code or in MACSYMA's code.  Such a loop would cause storage spaces to grow
indefinitely if possible. It may be difficult for the user to recognize that
this situation has occurred, as opposed to a real need for more space, yet such
a situation can cause havoc to any dynamic allocation scheme. By typing a
control-D the user will be informed whenever a garbage collection occurs and a
printout such as the following will occur:

.example
;GC DUE TO ... SPACE

;2729[33%] LIST, 1935[94%] FIXNUM, 511[99%] FLONUM,

; 509[99%] BIGNUM, 629[15%] SYMBOL,

; 480[93%] ARRAY WORDS FREE

.end

The numbers before the name of each space give the number of words of that space
which are available. The percentages refer to the ratio of the available amount
of space compared to the total amount (used plus unused). This may be of some
help in determining whether the user's computation is doing what he expected.
Typing a control-C will turn off this g.c. printout.
.end

If the user feels that he is not in one of the above situations and that there is a
real need for more space, he can avail himself of the following scheme:

When a space, e.g. LIST is exhausted, MACSYMA
will print:

.example
YOU HAVE RUN OUT OF LIST SPACE
DO YOU WANT MORE?
TYPE ALL; NONE; A LEVEL-NO.; OR THE NAME OF A SPACE;

.end

At this point the user can type a control-A and enter a (MACSYMA-BREAK).  He can
then follow any of the procedures mentioned in (2) above.  After getting out of
the break by typing EXIT; he can then type OK; which indicates that the user
believes he has freed up enough space thus making reallocation unnecessary. If he
is wrong, he will get the above message again.  He can also reply with the name
of a space, i.e. one of FIXNUM, FLONUM, BIGNUM, SYMBOL, or ARRAY which will
cause the size of that space to be expanded.  If he replies with LIST or ALL
then not only will list space be increased, but so will every other space.  This
is because if he needs more list space, then he probably needs more of the other
spaces as well.  Replying LIST also increments the "allocation level" by one.
There are 5 equi-spaced levels of allocation, ranging from the initial level 0
to level 4. The user can also boost his MACSYMA up to that particular level of
allocation immediately by replying with that level number.

At level 4 the maximal allocation possible on the computer is just about
exhausted so that there is no higher level.  Also, the amount of
core space devoted to the allocatible storage spaces is 
obviously inversely proportional to the number and size of out-of-core files which are loaded in.  If many out-of-core files
are loaded in, allocation level 4 will not even be attainable.
The user may wish for this reason alone to continue now and
then with a fresh MACSYMA.  If the user's computation exceeds
this level of storage it will error out with the message "...STORAGE CAPACITY
EXCEEDED". Since the size of the spaces can't be decreased, it is important not
to increase them unless it is necessary.

If the user knows initially that his problem will require much space, the
function $fun<ALLOC> is provided.  5ALLOC* takes any number of arguments which are the
same as the replies to the "run out of space" question above.  It increases
allocations accordingly.

Lastly, if he is running a MACSYMA disowned, or for other reasons wishes storage
space to be increased automatically as needed without having any questions
asked, the user may set the switch DYNAMALLOC [FALSE] to TRUE which will
 allocate additional space whenever necessary.

Like the other spaces BPS and the PDLs cannot be decreased.  BPS will continue
to grow until the MACSYMA runs out of address space so caution should be
exercised in causing out-of-core files to be loaded.  For example, once the
integration file is loaded into the user's MACSYMA it is there to stay even if
he no longer uses it.  The allocation of the PDLs is sufficiently large, so that
if they are ever caused to overflow it is probably due to a recursive infinite
loop in the user's programs.

.chap(Simple Plotting Functions,simplot)

The MACSYMA functions PLOT,PARAMPLOT,GRAPH, and MULTIGRAPH produce character plots of specified
functions and sets of data points.  (They can also be used to produce output
files for plotting on the Calcomp plotter or XGP attached to the PDP-10 used by the
Artificial Intelligence Group). The format of these functions and the variables
used by the corresponding routines are described below:

2Variables*

$var<LINEL/> - width of graphing area in terms of number of characters.

$var<PLOTHEIGHT/> - height of graph in terms of number of characters.

$var<XAXIS/FALSE> - if set to TRUE will cause the Y=0 axis to be displayed.

$var<YAXIS/FALSE> - if set to TRUE will cause the X=0 axis to be displayed.

.skip 1
2Formats for PLOT and PARAMPLOT*

.function(PLOT,|F(x), x, low, high|)
- plots the expression F(x) over the domain low < x < high.

.endfunction

.function(PLOT,|F(x), x, low, high, INTEGER|)
- as above, but plots F(x) only for integer values of x.

.endfunction

.function(PLOT,|F(x), x, [x1, x2, x3, ..., xn]|)
- plots the function F(x) for the values x1,x2,x3,...,xn.

.endfunction

The first argument to PLOT may also be a list of functions rather than just a
single function.  This permits several functions to be plotted on the same set
of axes. Three optional final arguments may also be given.  They are: (1) an X
axis label (quoted string or name), (2) a Y axis label, and (3) a list of
plotting characters used for the given function(s) enclosed in "s.  (Note also
that if a special symbol such as ; , $ , etc. is used it must be preceded by a
\.)  An * will be used to plot any functions which are not given a particular
plotting character.

.function(PARAMPLOT,|f1(t),f2(t),t,low,high|)
plots the plane curve f(t) = ( f1(t) , f2(t) )  with parameter t.  The syntax is basically like that of plot.  For example,

.example
PARAMPLOT(COS(T),SIN(T),T,0,2*%PI)
.end
.endfunction
.scon
plots a circle.  Also several curves may be presented at the same time by using the following syntax

.function(PARAMPLOT,|[f1(t), g1(t), ... h1(t)], [f2(t), g2(t), ..., h2(t)], t, low, high, [list of plotting characters]| )
- plots the plane curves f(t) = (f1,f2), g(t) = (g1,g2),...,h(t) = (h1,h2)  using the specified plotting characters or the default "*".  For example,

.example
PARAMPLOT([COS(T),COS(T)+7],[SIN(T),SIN(T)],
		T,0,2*%PI,["@"])
.end
.scon
plots two circles. 
.endfunction

The user may wish to $fun<TRANSLATE> or $fun<COMPILE> $see<compilation> the functions to be
plotted as they might be evaluated many times.

2Formats for GRAPH and MULTIGRAPH:*

.function(GRAPH,|[x1, x2, x3, ..., xn], [y1, y2, y3, ..., yn]|)
- Graphs the two sets of data points.

.endfunction

.function(GRAPH,|[[x1, y1], [x2, y2], ..., [xn, yn]]|)
- Graphs the points specified by the list of coordinate pairs.

.endfunction

.function(GRAPH,|xset, [yset1, yset2,..., ysetn],optional-args|)
- allows graphing of one x-domain with several y-ranges; e.g. GRAPH([0,1],[[0,1],[1,2]],["&"]).

.endfunction

.function(MULTIGRAPH,|[ [xset1, yset1], ..., [xsetn, ysetn] ], optional-args|)
- allows the user to produce a scatter-graph involving several x-domains each with a single y-range; e.g. MULTIGRAPH([ [[0,1],[0,1]], [[3,4],[1,2]] ],["&"]).

.endfunction

The three optional final arguments mentioned above under PLOT may also be used
with GRAPH and MULTIGRAPH.

The plot produced by the above functions is a character plot on a coordinate system
defined by axes along the minimum x and y values of the plot. The x and y
coordinates are independently scaled to optimally use the specified graphing area. 
Note that this may distort the shape of the graph e.g., a circle could become an
ellipse.  The origin of the graph (left-hand corner) is given on the graph by the
values of XORG and YORG; the computed increments (= one character) are given by the
values of XDELTA and YDELTA and the maximum X and Y values are given by XMAX and
YMAX. The axes are labeled with the number sequence 0,2,4,6,8,0,2,4,...  as an aid
in counting the number of increments from the origin.

When a graph is completed, the user must type a single character (on
non-printing consoles), such as space or carriage return, to return control to
MACSYMA.
.example
.once center
2Examples3

(C1) XAXIS:YAXIS:TRUE$

(C2) PLOT([1/(X^2+1),X^2-1],X,-2,2,[@]);
.begin group
  4[    *                           .
   [                                .                           *
  2[                                .
   [     *                          .
  0[                                .                          *
   [      *                         .
  8[                                .                         *
   [       *                        .
  6[                                .                        *
   [        *                       .
  4[                                .                       *
   [         *                      .
  2[                             @@@@@@@                   *
   [          *               @@@   .   @@@
  0[                        @@      .      @@             *
   [           *          @@        .        @@@
  8[                   @@@          .           @@       *
   [            *    @@             .             @@@
  6[             @@@@               .                @@@*
   [         @@@@                   .                  *@@@@
  4[   @@@@@@     *                 .                       @@@@@@
   [@@@            *                .                 *           @@@
  2[                                .                *
   [................*.................................................
  0[                 *              .               *
   [                  *             .              *
  8[                                .             *
   [                   *            .            *
  6[                    *           .           *
   [                     *          .          *
  4[                      **        .         *
   [                        *       .       **
  2[                         **     .      *
   [                           **   .   ***
  0[                             *******
   -------------------------------------------------------------------
    0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4
XORG=-2.0 YORG=-0.999744 XDELTA=0.062 YDELTA=0.091
XMAX=1.96800017 YMAX=3.0
.end

.begin group
(C2) POLARPLOT(RHO,NUMBREV):=BLOCK([THETA, LIMIT, X, Y, P, NUMER,
        RATPRINT], NUMER:TRUE, RATPRINT:FALSE, THETA:0.0, X:Y:[],
          LIMIT:72*NUMBREV, FOR I:1 THRU LIMIT DO
                ( P:RHO(THETA), X:CONS(P*COS(THETA),X),
                  Y:CONS(P*SIN(THETA),Y), THETA:THETA+%PI/36.0),
        GRAPH(X,Y,X,Y))$

(C3) XAXIS:YAXIS:FALSE$

(C4) F(T):=4-COS(8.0/3.0*T)$
.end
.next page
.begin group

(C5) POLARPLOT(F,3)$
a





  6[                      *  *  *  *     *  *  *  *
   [              * *  *         * *  *  * *         *  * *
  4[             *           * *             * *            *
   [      * *  *  *  *  *  ** * * * * * * * * * *** *  *  *  ** * *
Y 2[    *     *         **                         **         *      *
   [ **       *   * * **                             * ** *   *       * *
  0[*       * ***                                           *** *       *
   [**  * *     *                                           *      * * **
  8[  *          *                                          *         *
   [**  * *     *                                           *      * * **
  6[*       * ***                                           *** *       *
   [ *        **  * * *                                ** *  **         *
  4[  * *     *        ***                         ***        *      **
   [      * *  *           ** * * * * * * * * * ***          ** * *
  2[             **  *  *    * *             * *    *  *  * *
   [              * *            * *     * *            * *
  0[                   *  *  *  *  *  *  *  *  *  *  *
   ---------------------------------------------------------------------------
    0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2
XORG=-4.77137667 YORG=-4.77137756 XDELTA=0.14 YDELTA=0.6
XMAX=4.7713773 YMAX=4.77137697
                                  X                 


.end
.end
1

.chap(Complex Plotting and Graphics---PLOT2,plot2)

.sec(Introduction,plot2intro)

This is a description of the functions contained in the following 6
files:
.once center
APLOT2 > ARC CFFK,   TEKPLT > ARC CFFK,  PLOT3D > ARC CFFK
.once center
WORLD  > ARC CFFK,   PRINT  > ARC CFFK,  IFFUN  > ARC CFFK.
.bcon
They will be loaded up as needed when most of the functions below are
used.  However to get the "complete" PLOT2 environment, LOADFILE(PLOT2,LISP,DSK,SHARE) is recommended.  This loads in complete AUTOLOAD properties for the functions described below.  The effect of loading this file will be to cause the PLOT2 package to be automatically loaded when you need it.  If you use PLOT2 regularly,  you should consider including PLOT2 LISP DSK SHARE in your MACSYM (INIT) file; it will take up neglegible room in your MACSYM.  

The capabilities of the routines described here include plotting of
several curves on a single graph, plotting several graphs in different
positions on the screen, saving plots, replotting plots with different
scales without having to recompute any points, plotting of 3 dimensional
surfaces, plotting of user defined dashed lines and symbols.

The devices supported are: the Tektronix 4010 and 4013, the Imlac PDS 1 and PDS 4 (using ARDS graphics conventions), the XGP and the Gould line-printer (at MIT) and printing and display consoles in a "preview" mode.

.sec(Two-Dimensional Plotting,d2plot)

.function(PLOT2,|y-exprs,variable,var-range,optionals-args|)
plots 2y-exprs* on the y axis as 2variable* (the x axis) takes on  values specified by 2var-range*.
.bcon
2y-exprs* can take one of two forms:
.begin narrow 8,5
.scon
i) 2expr* plots a curve of 2expr* against 2variable*
.scon
ii) [2expr1*,2expr2*, .. ,2expri*, .. ,2exprn*] plots n curves of 2expri* against 2variable*.  2expri* gets evaluated in the context FLOAT(EV(2expri*,2variable*=2value gotten from var-range*, NUMER)). It is an error if this doesn't result in a floating point number.
.end
.scon
2var-range* can have the following forms:
.begin narrow 8,5
.scon
i) 2low*,2high*, where 2low* and 2high* evaluate to numbers.  2low* may be either greater or less than 2high*.  2variable* will take on CALCOMPNUM values equally spaced between 2low* and 2high*. 
.begin narrow 2,2
Note that the first argument will be evaluated at 2low* first e.g. PLOT2(1/X,X,-1,-3); calculates 1/(-1.0) before 1/(-3.0). This will only make a difference if the computation of the first arg changes a variable which changes the value returned by subsequent computation.  Whether or not 2low* < 2high*, min(2low*,2high*) will be on the left of the plot.  (This can be overridden using the SPECIAL $see<transformpts> option with REFLECT as XFUN.)
.end
.scon
ii) 2low1,2high*,INTEGER.  As in i), except 2variable* will take on all integer values between 2low* and 2high* inclusive.
.scon
iii) [2val1*,2val2*, ... , 2valn*] . 2variable* takes the values specified by the list
.scon
iv) 2arrayname* where 2arrayname* is the name of a declared floating-point  one-dimensional array (i.e. declared by ARRAY(2arrayname*,FLOAT, 2max-index*);).  2variable* takes the values from 2arrayname*[0] thru 2arrayname*[2max-index*] (2max-index* is the maximum index of 2arrayname*
.end
.scon
2optional-args* can be any of the following:
.begin narrow 8,5
.scon
i) X-Label, Y-Label or Title descriptor $see<labels>
.scon
ii) Line type descriptor $see<linetypes>
.scon
iii) FIRST, SAME and LAST $see<allinone>
.scon
iv) POLAR, LOG, LINLOG, LOGLIN $see<transformpts>
.end
.scon
The optional arguments may appear in any order.  The rule for 	evaluation of the optional args is as follows.  If the argument is atomic it gets evaluated.  The resulting arguments are the	ones that get used.

If you want to plot more than 3-4 curves on the same plot investigate using the NOT3D option to PLOT3D $see<d3plot>

.example
.once center
2Examples1

  PLOT2(SIN(X),X,-%PI,%PI);	plots sin(X) against X as X takes on
				CALCOMPNUM values between -%PI to %PI
  PLOT2(X!,X,0,6,INTEGER);	plots X! as X takes integral values
				between 0 and 6
  F(X):=SQRT(X);
  PLOT2(F(X),X,[-2,3,100.12]);	plots F(X) as X takes the values in the
				values in the list
  PLOT2([X+1,X^2+1],X,-1,1);	plots 2 curves on top of each other
.end
.endfunction

.function(PLOT2,|y-funs,var-range,optionals-args|)
is the alternative form for PLOT2.  2y-funs* must be a function of one argument or a list of functions of one argument.  The functions must be either translated or compiled functions which return a floating point number when it is given floating point arg (or integer arg if the INTEGER arg to PLOT2 is given).  This form of PLOT2 acts as though you had given a argument to the 2y-funs*, and also specified that argument as the 2variable* in the form above. E.g. PLOT2(F,-2,2); acts like PLOT2(F(X),X,-2,2);  This is supposed to provide a quicker evaluation of the first arg and for that reason NO checking is done on the result.  If the wrong kind of number is returned, the resulting plot will not be meaningful.

.example

      TRANSLATE:TRUE;
      F(X):=(MODEDECLARE(X,FLOAT),EXP(-X*X));
      PLOT2(F,-2,2);
      PLOT2(F,[-2,-1,0,1,2]); 
      ARRAY(V,FLOAT,10);
      FOR I FROM 0 THRU 10 DO V[I]:FLOAT(I*I);
      PLOT2(F,V);
.end
.endfunction

.function(GRAPH2,|x-lists,y-lists,optional-args|)
plots points specified by the first 2x-lists* and 2y-lists*.  The format for 2x-lists* can be one of
.begin narrow 8,5
.scon
i) [2x-pt1*,2x-pt2*, .. ,2x-pti*, .. ,2x-ptn*] 	where 2x-pti* evaluates to a number
.scon
ii) 2arrayname* where 2arrayname* is the name of a declared one-dimensional array of floating point numbers
.scon
iii) 22d-arrayname* where 22d-arrayname* is the name of a declared two-dimensional array of floating point numbers (i.e. by ARRAY(22d-arrayname*, FLOAT, 2max-row-index*,2max-col-index*);)
.scon
iv) [2x-list1*,2x-list2*, .. ,2x-listi*, .. ,2x-listk*]	where 2x-listi* can have the form of either i) or ii).
.end
The format of 2y-lists* is similar.
.scon
GRAPH2 performs as follows: arguments of form i) or ii) are converted to form iv) (e.g. 2arrayname* ==> [2arrayname*]).  Arguments of from iii) are converted to form iv) by 22d-arrayname* ==> [2row0*,2row1*, .. , 2rowi*, .. ,2rowk*] where 2rowi* is a list of the numbers in the i'th row of 22d-arrayname* (remember that array indexing begins from 0 in MACSYMA).  If the length of the resulting 2x-lists* is shorter than that of the resulting 2y-lists* then 2x-lists* is filled with 2x-listk* to make the lengths the same (similarly if 2y-lists* is shorter than 2x-lists*).  If the length of 2y-lists* is, say, n, then n curves of 2x-list1* vs. 2y-list1*, .. ,2x-listn* vs. 2y-listn* are plotted. In the event of 2x-listi* containing less numbers (or being a shorter array) than 2y-listi* then the last numbers of 2y-listi* are left unused.

    The format of 2optional-args* is the same as for PLOT2.

    Note that GRAPH2 performs the same job as the MACSYMA function MULTIGRAPH and that GRAPH2 is thus slightly incompatible with GRAPH FASL.
.endfunction


.function(PARAMPLOT2,|x-exprs,y-exprs,variable,var-range,optional-args|)
plots 2x-exprs* as the x coordinate against 2y-exprs* as the y coordinate.
.scon
      The format for the first two arguments is the same as that for the first argument to PLOT2.  Thus if 2x-exprs* is [2x-expr1*, 2x-expr2*, .. ,2x-expri*, .. ,2x-exprn*] and 2y-exprs* is [2y-expr1*,2y-expr2*, .. ,2y-expri*, .. ,2y-exprk*], then max(n,k) curves will be plotted. They will be (assuming n > k): 
.scon
.once center
2x-expr1* vs. 2y-expr1*, .. ,2x-exprk* vs. 2y-exprk*,
.once center
2x-expr(k+1)* vs. 2y-exprk*, .. ,2x-exprn* vs. 2y-exprk*
.scon
The format for the remaining arguments is the same as for PLOT2.
.endfunction

.function(PARAMPLOT2,|x-funs.y-funs,var-range,optional-args|)
efficiently evaluates its first 2 arguments in the same way that the alternative form of PLOT2 works.
.endfunction
.skip 1
.once center
2Examples1
.example
  TRANSLATE:TRUE;	causes automatic translation
  F(X):=(MODEDECLARE(X,FLOAT),COS(X)); 
  G(X):=(MODEDECLARE(X,FLOAT),SIN(X));
  PARAMPLOT2(F,G,0,2*%PI); plots F(x) vs G(x) as x goes from 0 to 2*%PI

  PARAMPLOT2(SIN(T),COS(T),T,0,2*%PI);
.end bcon
plots sin(T) for the x-axis and cos(T) for the y-axis as T takes on CALCOMPNUM $see<d2plot> values between 0 and 2*%PI.  (If EQUALSCALE is TRUE $see<scales> this draws a circle.)

.function(WORLDPLOT,|min-long,max-long,min-lat,max-lat|)
plots your favorite portion of the world. The arguments are in degrees with latitude ranging from -90 to 90 and longitude from -180 to 180. the projection is unorthodox.  (For this function,  don't expect any of the features available with the other plotting functions to be available)
.endfunction
.scon
$var<CALCOMPNUM/20> is the number of points PLOT2 and PARAMPLOT2 plot when given the 2low*,2high* type of variable range.  The default if you    load up PLOT2,LISP,DSK,SHARE is 20, which is sufficient for   trying things out.  100 is a suitable value for a final hard copy.

.sec(What to Type When PLOT2 has Finished Plotting,whatnow)

When a plot is finished the bell on your terminal will be dinged.  (In fact, this happens only if WAIT is TRUE $see<allinone>
and if you're plotting on the terminal $see<otherpf> and $see<devices>.)  The plotting
function is now waiting for you to type something before it exits and prints
the next C-Label on your nice plot.  It does nothing with most characters; 
they are left to be part of the next C-Line.  However, the following characters
are read and interpreted specially.
.scon
2space1 exits the plotting function. 
.scon
2return1 clears the screen and then exits.  
.scon
2tab1 causes the previous plot to be replotted.
.begin narrow 8,5
.bcon
This is useful if the line is noisy, or, in conjunction with 2control-A1  if various plotting parameters need to be changed.
.end
.scon
2linefeed1 sends out a hardcopy signal.  

.begin narrow 8,5 
.bcon
At present this can only  be used to generate a hardcopy on the Tektronix hardcopy unit or on the Gould $see<devices>
.end
.scon
2rubout1 names the plot.  
.begin narrow 8,5 
.bcon
PLOT2 types out "Enter name of plot" you reply 2plotname*;  this is identical to typing a space instead of a rubout, followed by NAMEPLOT(2plotname*);$see<namsav>.  
.end 
.scon
2control-A1
.begin narrow 8,5 
.bcon
This is not really read by the plotting function, but enables you to enter a 2control-A1 break and change various options, before typing tab to have the plot replotted.  Make sure the plot has finished before you type this $see<whatnow>.  The most common things that need changing are the scaling options $see<scales>;  but just about anything can be changed as long as they don't require that more points be calculated (e.g. don't try resetting CALCOMPNUM in a 2control-A1 break).  There are a number of options that exist as explicit options only within a 2control-A1 break of this type.  (Normally they are set in the 2optional-args* of the plotting function.)  They are $var<TYPEL/> $see<linetypes>, $var<XLABEL/>, var<YLABEL/>, $var<TITLE/> $see<labels>, $var<TXTYPE/> $see<transformpts> and $var<\3D/> $see<d3plot>. 

Unlike the other options these are local variables and will become unbound (or bound to their old values) when PLOT2 is exited and in order for the changes made to them to be remembered by REPLOT $see<otherpf> later on you must replot the plot after exiting the break.  In order to get your plot replotted in the new environment you have set up, just type EXIT; followed by a tab.  
.end
.scon 
$var<PLOTBELL/TRUE> when FALSE inhibits the dinging of the bell.  
.scon
While your plot is coming out your terminal is in a rather strange state (e.g. not echoing characters).  Thus it is OK to type ahead to MACSYMA, but the ONLY way you should interrupt the plot is with 2control-^1.  E.g. do not use 2control-A1 until the plot has finished.  
.begin indent 0,6
Note:	The characters to create a plot get put in a buffer, and normally only get sent when the buffer is full or when the plot is complete.  The user can force the buffer contents to be sent by typing control-\ (control-shift-L on the Tektronix, control-\ on the Imlac).  This is probably only of use to users of WORLDPLOT, which will sometimes wait until it has gone thru the whole world before sending anything out.  Note however that this feature is not reliable.  
.end 
.sec("Three-Dimensional Plotting",D3plot)

.function(PLOT3D,|z-exprs,x-var,var-range,y-var,var1-range,optional-args|)
makes a 3-dimensional plot of 2z-exprs* against 2x-var* and 2y-var*.  The plot consists of curves of 2y-exprs* against 2x-var* (the x coordinate) with 2y-var* (the y coordinate) held fixed.  Perspective is used and curves further away from the viewer have those parts of them which are hidden by the closer curves removed. 

The format of 2y-exprs* is the same as for PLOT2.  The context of evaluation is FLOAT(EV(2expri*,2x-var*=2value gotten from var-range1,2y-var*=2value gotten from var1-range1,NUMER)).

The format for 2var-range* and 2var1-range* is the same as for PLOT2 except that if 2var1-range* is of the form 2low*,2high* then 2y-var* will take on CALCOMPNUM1 values. 

      The format of 2optional-args* is the same as for PLOT2 except that additional options $var<NOT3D/>, $var<\3D/>, $var<CONTOUR/> are available. 
.endfunction
.function(PLOT3D,|z-funs,var-range,var1-range,optional-args|)
is analogous to the alternative form for PLOT2.  2z-funs* must be a function or list of functions of 2 arguments, which must return a floating point argument when given floating point (integer, if the INTEGER argument is used for either 2var-range* or 2var1-range*) arguments.  The functions must be translated or compiled.  If you expect to make several 3D plots this form is recommended. 

 A simple example is 
.example
  TRANSLATE:TRUE;	causes automatic translation
  G(X,Y):=(MODECLARE(X,FLOAT),EXP(-X*X-Y*Y));	defines a funtion G
  PLOT3D(G,-2,2,-2,2);	plots it 
.end
.endfunction
.function(GRAPH3D,|x-lists,y-lists,z-listsoptional-args|) 
takes 3 arguments (GRAPH2 takes 2) and  interprets them as lists of x, y, and z points which it uses to draw lines using the 3d transformations.  It can be used to add lines (e.g.  axes) to your 3D plot (see SAME option $ref<allinone>)).  The hidden line routines are not used.  
.endfunction 

2NOT3D1

In this section we describe the option $var<NOT3D/>.   As an example, consider 
.example 
.once center 
PLOT3D(SIN(X)+A,X,-%PI,%PI,A,[-2,3,4,6],NOT3D) 
.end scon
which plots sin(X)+A for X from -%PI to %PI ($var<CALCOMPNUM/20> points) and A
taking the values in the list.  This is equivalent to:  
.example 
.once center
PLOT2([SIN(X)-2,SIN(X)+3,SIN(X)+4,SIN(X)+6],X,-%PI,%PI) 
.end 
.scon 
but requires less typing. 

The additional NOT3D argument to PLOT3D, causes exactly the same points as in the bare PLOT3D to be calculated.  Instead of plotting a 3-dimensional representation of the data, the data is plotted in a 2D one.  Specifically 1 2D curve of z vs. x for each y value, and so is a convenient way to plot several curves on the same plot. 

2PERSPECTIVE, REVERSE, VIEWPT, and CENTERPLOT1

The following options govern the type of perspective view given. 

$var<PERSPECTIVE/TRUE>, if FALSE causes a non-perspective view to be taken.  This is equivalent to extending the viewing position out to infinity along a line connecting the origin and VIEWPT. 

$var<REVERSE/FALSE>, if TRUE cause a left-handed coordinate system to be assumed. 

$var<VIEWPT/> and $var<CENTERPLOT/> determine the perspective view taken.       They are defaulted to be unbound - like XMAX etc.)  VIEWPT may be set to a list of 3 numbers and gives the point from which the projection should be made.  CENTERPLOT may likewise be set to a list of 3 numbers and gives a point on the line of sight.  The projection will be made onto a plane perpendicular to a line joining VIEWPT and CENTERPLOT. 

If VIEWPT and CENTERPLOT are unbound (the default) then they will be chosen as  follows: the extreme values of the coordinates are determined.  This gives the two points min:  [xmin,ymin,zmin], max:[xmax,ymax,zmax]. CENTERPLOT is chosen as (min+max)/2, and VIEWPT is chosen as max+3*(max-min).  The view is then one in which the z axis is vertical, the x axis is increasing towards you to the left and the y axis is increasing towards you to the right. 

If CENTERPLOT is FALSE then the old type of  perspective view will be given (like setting the x and z components of CENTERPLOT to the corresponding components of VIEWPT). 

Before you set either VIEWPT or CENTERPLOT you might want to look at the values of $var<VIEWPT1/> or $var<CENTERPLOT1/>, the values that PLOT3D assumed in doing the previous plot $see<scales>.  Likewise $var<XMAX3D/>, $var<YMIN3D/> etc. will be the values of xmax, min for the data points, that PLOT3D used to determine the default VIEWPT or CENTERPLOT. 

If rather than changing the view you want to change the scale of the plot (to cause clipping, for example), then you must change $var<XMAX/>, $var<XMIN/>, $var<YMAX/> or $var<YMIN/> $see<scales>.  However, note that these numbers refer to the size of the plot AFTER the perspective routines have been used.  So again you will probably want to look at XMAX1 etc. to find what had been assumed. 

2CROSSHATCH and UNDERSIDE1

The option $var<CROSSHATCH/TRUE> will force PLOT3D to crosshatch, i.e. plot lines of constant x as  well as constant y.  You can turn this off by doing CROSSHATCH:  	FALSE; (it will then plot only lines of constant y)

If $var<UNDERSIDE/TRUE> is TRUE, PLOT3D will show the underside of a figure (when it is visible). 

2HIDE, \3D, CONTOUR, and NOT3D1

Internally the plots generated by PLOT3D (with or without the NOT3D option), GRAPH3D and CONTOURPLOT2 $see<contourplot> are the same, and it is possible to switch between any of the 4 representations.  The 4 representations are accessible directly in the following ways:   
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon 
Hidden-Line\\PLOT3D, GRAPH3D(....,HIDE)$$HIDE is the optional argument* 
.bcon 
3D, hidden lines not removed\\PLOT3D(...., \3D), GRAPH3D 
.bcon 
Contourplot\\PLOT3D(...., CONTOUR),CONTOURPLOT2 
.bcon 
Not3d\\\PLOT3D(...., NOT3D) 
.end 
There are two ways of changing representations once the plot has been made.  In a ^A break, or using the REPLOT $see<otherpf> function.         

In a ^A break there are 2 variables which govern the representation: $var<\3D/> and $var<TXTYPE/> $see<transformpts>.  These variables are local to the ^A break.  They should be reset according to the following table 
.begin group turn on "_\"; tabs 8, 20, 34 ;  
\\value of \3D \value of TXTYPE 
.scon 
\Hidden-Line\HIDE\FALSE 
.bcon
\3D\TRUE\FALSE
.bcon
\Contourplot\CONTOUR\FALSE 
.bcon
\Not3d\FALSE\NOT3D 
.end 
.scon 
(Note that TXTYPE only need be touched switching to and from the Not3d representation.  It is a misfeature that it should have to be touched at all, and this may be corrected someday.)

Having exited the plot, you can have it REPLOT'ed in another represention by using the following table.  
.begin group turn on "_\";tabs 8, 20, 34 ;  
.scon
\Hidden-Line\REPLOT(TRUE,HIDE);  
.bcon
\3D\REPLOT(TRUE,3D); 
.bcon
\Contourplot\REPLOT(TRUE,CONTOUR);  
.bcon
\Not3d\REPLOT(TRUE,NOT3D);  
.end 
.scon
Again, as a misfeature when swapping from a Not3d representation to a Contourplot it necessary to supply an additional optional argument LIN (thus REPLOT(TRUE,CONTOUR,LIN);)  The TRUEs in the calls to REPLOT indicate the last plot.  The name of a named plot $see<namsav> may be used instead (see $ref<otherpf> for details)

2CALCOMPNUM11

If the 2low*,2high* form is used with 2var1-range* in PLOT3D, the 2y-var* takes on $var<CALCOMPNUM1/20> points.  CALCOMPNUM1 defaults to 20.  Since CALCOMPNUM*CALCOMPNUM1 points are normally calculated when PLOT3D is called, the alternative form for calling PLOT3D is highly recommended. 


.sec(Contour Plotting,contourplot)

2CONTOURPLOT21

First consider some simple examples 
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
CONTOURS:10;\\Do 10 contours 
.bcon
LABELCONTOURS:FALSE;\\Don't label the contours 
.bcon
CONTOURPLOT2(Y^2/2+COS(X)+X/2,X,-6,6,Y,-3,3);  
.scon
makes  a contour plot of Y^2/2+cos(X) as X takes CALCOMPNUM values between -6 and 6 and as Y takes CALCOMPNUM1 values between -3 and 3. $$This gives the phase space orbits of a particle in a periodic potential superimposed on a constant field* 
.end
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
PLOT3D(Y^2/2+COS(X)+X/2,X,-6,6,Y,-3,3,CONTOUR);\\Exactly the same 
.bcon
CONTOURS:[0];\\\Plot only the zero contour.  
.bcon
CONTOURPLOT2([REALPART((X+%I*Y)^3-1),IMAGPART((X+%I*Y)^3-1)], 
.once center
 X,-1.5,1.5,Y,-1.5,1.5,[0,1]);  
.bcon 
finds the zeroes of Z^3=-1 in the complex plane.  
.scon 
CONTOURS:CALCOMPNUM:CALCOMPNUM1:10; Work with a 10x10 grid 
.bcon
CONTOURPLOT2(RANDOM(100),X,0,1,Y,0,1);\\Plot something random 
.end

The function  
.inline function(CONTOURPLOT2,|...|) 
is exactly the same as PLOT3D(...., CONTOUR).  That is it calculates the same points as PLOT3D(...) would, but displays the points as a contour plot.  What contours are drawn is governed by the variable $var<CONTOURS/20> .  Changing CONTOURS does not require any more points to be calculated, so it makes sense to change CONTOURS in the ^A break after a plot $see<whatnow> or before using REPLOT $see<otherpf>.  The contours are drawn using linear interpolation, so they tend to look rough (especially near saddle points) unless CALCOMPNUM and CALCOMPNUM1 are large.  The contour tracking algorithm is quite smart so all contours should either terminate at the boundaries of the region or be closed loops. 

CONTOURS, ZMAX and ZMIN

If $var<CONTOURS/20> is an integer, you will get CONTOURS equally spaced contours lying between the maximum and minimum z values to be plotted (the first argument to CONTOURPLOT2 and PLOT3D is considered to be a z variable).  If either $var<ZMAX/> or $var<ZMIN/> as a value then that value will be used instead of the actual maximum or minimum.  The default is for ZMAX and ZMIN to be unbound. 

If CONTOURS is the atom INTEGER then only integer heights for the contours will be used.  Again the range for these contours can be restricted by setting ZMAX and ZMIN appropriately.

If CONTOURS is a list of numbers (e.g. CONTOURS:[1,.5,%PI];) then those numbers will be used to determine the heights of the contours.  The number in the list can be in any order.

CONTOURPLOT2 will label the contours with their height unless $var<LABELCONTOURS/TRUE> is FALSE.  $var<PLOTNUMPREC/7> digits of precision are given $see<labels>.

.sec(Other Plotting Functions,otherpf)

2REPLOT1

First, consider the following examples.
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
PLOT2(1,X,0,2*%PI);\\Plots a straight line
.bcon
REPLOT(TRUE,POLAR);
.bcon
Plots it in polar coordinates $see<transformpts>. This will appear as an ellipse unless EQUALSCALE:TRUE $see<scales>
.bcon
EQUALSCALE:TRUE;
.bcon
REPLOT();
.bcon
Replots the ellipse with EQUALSCALE equal to TRUE; this will then appear as a circle.
.end

.function(REPLOT,|plotname,optional-args|)
replots 2plotname* $see<namsav>, which will be loaded from a file if REPLOT can determine which file to load. REPLOT(TRUE); and REPLOT(); both replot the last plot.  If any of the options for determining the scale, etc. have been changed since the plot was saved the new values of those options will be used.
.scon
2optional-args* may be any of the optional arguments to the main plotting functions.  These optional args will be merged in with those supplied to the original plot.  (The exceptions are FIRST, LAST and SAME $see<allinone> and DONT $see<namsav>.  These optional argument don't stick around with the plot.)  If you want the last plot replotted with some optional args supplied you must use the form REPLOT(TRUE,2optional-args*); (REPLOT(2optional-args*); won't work because it will try and use the first optional arg. as a 2plotname*).

There are two additional optional arguments that it makes sense to give to REPLOT, but not to the original plotting function.  They are NONE, to suppress a label $see<labels> and LIN, to suppress a transformation $see<transformpts>.
.endfunction

.function(REPLOT,|list-of-plots,optional-args|)
where 2list-of-plots* = [2plot1*,2plot2*, ... ]
.bcon
is identical to (REPLOT(2plot1*,2optional-args*), REPLOT(2plott2*,2optional-args*),...);  If the first arg to REPLOT is atomic then it is evaluated and the evaluated form is used if is a list.
.endfunction
.example
REPLOT(PLOTS);  	Replots all named plots $see<namsav>.
.end

.function(PLOTMODE,|dev1,dev2, ...| )
sets PLOT2 up to plot on the devices specified by 2devi*. at present 2devi* can be one of T (or TEKTRONIX), I (or IMLAC), GR (or GRINNELL), D (or DISPLAY), P (or PRINTING), X (or XGP)   or G (or GOULD), for Tekronix, Imlac, a display console,  printing terminal, the XGP or the Gould printers at MIT.  Any number of arguments may be given with the restriction that no 2 of [I, T, GR, D, P] appear together.  The arguments may appear in any order, with the first argument being used to determine what  character size will be assumed.  The defaults performed when PLOT2 is loaded is PLOTMODE(T), PLOTMODE(I), PLOTMODE(D) or PLOTMODE(P), depending on the terminal type [see $ref<defaults> for details]

Details of the peculiarities of the various devices are given in $see<devices>.

.example
PLOTMODE(DISPLAY,XGP);  
.end scon
sets things up for plotting on the XGP and a Datapoint.
.endfunction
.scon
PLOTMODE:2dev* and PLOTMODE:[2dev1*, 2dev2*, .. ]    are equivalent to PLOTMODE(2dev*) and PLOTMODE(2dev1*, 2dev2*,...), respectively.
.scon
$var<PLOTMODE/>  returns a list of the devices PLOT2 currently is plotting for; PLOTMODE(); also does this.

.function(CLEAR,)
clears the screen
.endfunction

.function(HARDCOPY,)
queues up the plot for the Gould if PLOTMODE contains GOULD, else it sends out a hardcopy signal to the Tektronix if PLOTMODE contains TEKTRONIX, else it prints "HARDCOPY failed".
.endfunction

.function(PLOTRESET,)
resets most of the options affecting plotting back to their default values.  The exceptions are the terminal related options.  See $ref<defaults> for details.
.endfunction

.sec(Labels,labels)

2XLABEL, YLABEL, TITLE and NONE1

The following simple examples will help in understanding the label options.
.example
.once center
PLOT2(EXP(X),X,0,3,X,EXP(X),"THIS IS A PLOT OF EXP(X) VS. X");
.end
.scon
plots a curve of exp(X) with an x-label, X, a y-label, EXP(X), and a title, THIS IS A PLOT OF EXP(X) VS. X.
.bcon
.example
                         A:3;
                         TITLE:CONCAT("A=",A); 
.end bcon
computes the title "A=3".
.bcon
.example
.once center
PLOT2(SIN(X)+A,X,-%PI,%PI,FALSE,FALSE,TITLE);
.end bcon
plots sin(X)+A, and sticks an the title "A=3".
.example
.once center
PLOT2(SIN(X),X,-%PI,%PI,FALSE,SIN());
.end bcon
labels the y-axis with 	"SIN(X)".

We now explain in greater detail the effect of a sequence of optional arguments
.once center
2xlabel*,2ylabel*,2title*
.scon
If the optional arguments to the plotting functions aren't any of the recognized keywords (FIRST, LAST etc.) they are taken to be specifications for the x-label, y-label and the title of the plot,  If any of these is atomic it gets evaluated once, else it gets used literally.  (See the "A=3" example above.  If PLOT2(SIN(X)+A,X,-%PI,%PI,FALSE,FALSE,CONCAT("A=",A)); had been used the title would have appeared as "CONCAT("A=",A)".) If one of them is FALSE then nothing gets printed for that item.  Only as many of the three to be non-ambigous need be specified:  thus if only a y-label is required then FALSE,2ylabel* would be sufficient. None of these options may be a list (to avoid confusion with  line-type list $see<linetypes>.

Within a ^A break at the end of a plot $see<whatnow>, the x-label, y-label and title of the current plot are the values of the local variables $var<XLABEL/>, $var<YLABEL/>, and $var<TITLE/>.  These variables will be FALSE if there is no corresponding label.  You can change the values of these variables in the ^A break and they will be incorpoated into your plot when you exit the break and type a tab $see<whatnow>.

In the optional arguments to REPLOT $see<otherpf> FALSE has the meaning "Don't change the corresponding label".  If it is desired to remove a label when REPLOTting then NONE should be given instead.
.example
.once center
2Examples*
.scon
  PLOT2(SIN(X),X,-%PI,%PI,FALSE,FALSE,"THE CAT SAT ON THE MAT");
.break
    1(title is set to "THE CAT SAT ON THE MAT ")3
.break
  REPLOT(TRUE,"X-AXIS");
.break
    1(replots with title and x label)3
.break
  REPLOT(TRUE,FALSE,"SIN(X)",NONE);
.break
    1(replots with same xlabel a new ylabel and no title)3
.break
  REPLOT(TRUE,FALSE,"Y-AXIS");
.break
    1(replots with new ylabel)3
.end

As a default the 2D plotting functions include a line at the bottom with the Max and Min of X and Y printed.  $var<NOPRINT/FALSE>:TRUE causes this line to be suppressed.

The numbers that PLOT2 prints out in the Min and Max line at the bottom of the plot, in the Min and Max labels on the axes $see<axes> and on the contours $see<contourplot> are given to a precision of $var<PLOTNUMPREC/7> significant figures.  The default is to give the numbers to full precision.  If you want to have less precision given (particularly useful with the labelling of contour levels) set PLOTNUMPREC to a smaller number (say 2 or 3).


The date is normally given at the top right corner of the plot, in a long form if no title is specified, or in a shorter form if a title is specified.  Sometimes the date overlaps with the title.  You can shut off the printing of the date by doing $var<DATEPLOT/TRUE>:FALSE;

.sec(Axes,axes)

2XAXIS and YAXIS1

The default action of PLOT2 for 2D plots is to provide the plots with x and y axes (which go through the origin if the origin is within the plot), to give the axes approximately 10 tickmarks in reasonable places, and  to give the max and min values of x and y by the axes and on a line beneath the plot.

$var<XAXIS/ALL>:FALSE;  $var<YAXIS/ALL>:FALSE; 	cause the x axis and y axis not to be drawn.  Their tickmarks will not be drawn either.  When TRUE these options draw the axis and the tick marks only.  When these options are set to ALL, the result is to draw the axis, the tick marks and give the max and min values of the coordinate.

2TICKSIZE and TICKNUM1
.begin turn on "^"
$var<TICKNUM/10>:2no-of-ticks*;  $var<TICKSIZE/6>:2size-of-ticks*; causes TICKNUM ticks to be given on each axis.  The size of the ticks will be TICKSIZE raster units either side of the axes.  The ticks will always come at "nice" values of the x or y variable.  "Nice" values is defined to be 2m**2k**10^n 1where 2m* and 2n* are integers and 2k* is 1, 2 or 5.
.end
TICKSIZE:0;  results in there being no ticks and TICKSIZE:2000; results in the ticks going all the way across the WINDOW $see<scales>, causing the ticks to turn into grids.

Setting TICKNUM to a negative number causes about |TICKNUM| ticks to be drawn, but PLOT2 won't round the max and min values on your axes to the nearest tickmark. Both TICKSIZE and TICKNUM may be lists of two numbers---the first referring to the ticks on the xaxis and the second to the ticks on the y axis.

As yet no axes are provided for 3D plots.  Suggestions for their implementation are welcome,

.sec(Scales,scales)

If the user takes no action the scale of his plots will be chosen for
him.  In general the scale will be as large as possible, while
still allowing everything to fit on the screen.  The user is provided
with various ways of overriding the default settings for the scales.

$var<WINDOW/>:[2min-x*,2max-x*,2min-y*,2max-y*]  sets the area of the screen that PLOT2 tries to plot in. The elements of the list are in raster units.  The maximum permissible size of the WINDOW is [0,1023,0,1023];  garbage will be produced if the WINDOW is larger than this.  If PLOT2 tries to plot outside the window, the plot will be clipped correctly.  If WINDOW is unbound then the default settings will be used (corresponding to the full Tektronix screen),  thus you can get back the default value be doing KILL(WINDOW);

In choosing the scale for a plot PLOT2 looks at the maximum and minimum values of x and y of the points it has calculated. However if one of $var<XMIN/>, $var<XMAX/>, $var<YMIN/>, $var<YMAX/> has a numeric value then that value will be used instead of the one found from the points themselves.  As with WINDOW do KILL(XMIN, etc) to get back to the default values.  The maximum and minimum values of x and y that PLOT2 obtains are rounded up and down to the nearest tick mark, unless TICKNUM is negative $see<axes>.

$var<EQUALSCALE/FALSE>:TRUE; tells PLOT2 to ensure that the scales are the same in both directions.  Thus if the WINDOW is rectangular, a circle will normally appear as an ellipse, whereas with EQUALSCALE:TRUE it will appear as a circle. All the plotting options whose default state is unbound (e.g. XMAX, WINDOW) have corresponding options obtained by sticking a "1" on the end, e.g. $var<XMAX1/>, $var<WINDOW1/>.  These options should only be read (not set), and their values may be loosely defined to be the value that PLOT2 assumed for the option.  The value will only be right if PLOT2 needed to calculate it.

Variables in this class are: $var<XMAX1/>, $var<XMIN1/>, $var<YMAX1/>, $var<YMIN1/>.  These refer to the quantities after the transformation functions $see<transformpts> have been applied, and after rounding to the nearest tickmark. 

$var<ZMAX1/>, $var<ZMIN1/> are of use only for contour plots $see<contourplot>.  ZMAX1 and ZMIN1 are equal to ZMAX and ZMIN if the latter have values.  They are equal to the max and min values of the first argument to CONTOURPLOT2, if ZMAX and ZMIN are unbound.  Their values are meaningless if CONTOURS is a list, since then CONTOURPLOT2 doesn't need to compute zmax and zmin.

$var<WINDOW1/> is the window in which plotting is done.  It does not include the room used by titles etc.

$var<XMAX3D/>, $var<XMIN3D/>, $var<YMAX3D/>, $var<YMIN3D/>, $var<ZMAX3D/>, $var<ZMIN3D/> are only of use for 3D plots $see<d3plot>.  These are the values of the 3D data before transforming it to 2d.  This will only be up to date information if PLOT3D needed to calculate it to determine either the default VIEWPT or the default CENTERPLOT.

$var<VIEWPT1/>, $var<CENTERPLOT1/> are only of use with 3D plots.  Useful to look at before you change VIEWPT or CENTERPLOT.

These variables are especially important when changing the scale of 3D plots $see<d3plot>, because YMAX etc. refer to the values after the perspective transformations, and so may be quite unrelated to the data points.
.example
.once center
2Example*

			CALCOMPNUM:CALCOMPNUM1:20;
			PLOT3D(1/(X^2+Y^2),X,-3,3,Y,-3,3);
.end bcon
has a big peak in the middle which we wish to clip.   YMAX1; returns -.896... and   YMIN1; yields -0.957...  .  YMAX:-0.92; tries a value of YMAX about 1/2 way between the old YMAX and YMIN
.scon
REPLOT(); replots on new scale.

.sec(Line Types,linetypes)

2TYPEL1

As usual, we begin with easy examples. 
.once center
PLOT2([SIN(X),COS(X)],X,-%PI,%PI,[0,1]);
.bcon
plots sin(X) with line type 0 (a solid line) and cos(X) with line type 1 (a dashed line)
.once center
PARAMPLOT2(RANDOM(),RANDOM(),X,0,1,[99]);
plots CALCOMPNUM "random" points (no connecting lines drawn)
.scon
		TT:[0,1,2,3,4,5,6,7,8];   CALCOMPNUM1:9;
.bcon
		PLOT3D(SIN(X)+A,X,-%PI,%PI,A,0,2,TT,NOT3D);
.bcon
gives the full repertory of line types
.scon
		TT:9+10*(TT+1);	TT is now [19,29,39 .. ]
.bcon
		REPLOT(TRUE,TT);
.bcon
gives the full repertory of symbol types.

If a list (or an atom that evaluates to a list) appears as an optional argument to a plotting function, then that list is taken as a specification of the line type to be used for the plot.  The elements of the list are evaluated once, and the elements of the resultant list must be all integers.  If this list has the form
.skip
.once center
[2type1*,2type2*, .. ,2typei*, .. ,2typek*]
.scon
then the i'th curve is to be plotted with line of type 2typei*. The (k+1)st curve is plotted with line of type 2type1* etc.      Omitting this optional argument is the same as specifying [0], i.e. all the curves are plotted with line of type 0 (i.e. solid line with no symbols).

The curves drawn by the PLOT2 functions may be drawn as 1 of 9 types of dashed line, with 1 of 9 types of symbol drawn at the data points.  In general the line type 2typei* is of the form of a decimal number abbcd where a, b, c, and d are digits between 0 and 9 (leading 0's may be omitted of course) and have the following meanings:
.begin narrow 8,5
.begin group
.scon
d = line-type is specified by the DEFINEDASH command; line-type 0 (the default) is defined as being a solid line; line-type of 9 defaults to meaning no line;
.end
.scon
c = symbol-type is defined by the DEFINESYMBOL command (see below); symbol 0 is defined to mean no symbol;

.scon
bb = number of data points with no symbol between the data points with a symbol.  If bb = 99 then bb is set to CALCOMPNUM-1,  if bb = 98 then bb is set to CALCOMPNUM-2.
.scon
a , the first symbol, is put at data point number 1 if a = 0, and at
    bb+2-a otherwise.

.end
.scon

2Examples1
.scon
.begin verbatim
abbcd =  0 ==> plain line
        10 ==> symbol 1 at every pt + plain line
        19 ==> symbol 1 at every pt
       124 ==> symbol 2 at every other pt + line 4
      9874 ==> line 4 with symbol 7 at endpoints
      9974 ==>   "     "    "     " at first point
     19974 ==>   "     "    "     " at last point
.end


.function(DEFINEDASH,|line-no,line-spec|)
redefines line number 2line-no* according to 2line-spec*. 2line-no* must lie between 0 and 9.  2line-spec* may be one of the following:
.scon
2FALSE1, the line is defined to be a solid line;
.scon
2TRUE1, no line is drawn (useful in conjunction with a symbol);
.scon
a 2list1 which defines a sequence of line segments separated by gaps; for example, DEFINEDASH(3,[1,5,5,5]) defines line 3 to start with 1 raster position on, 5 off, 5 on, 5 off, 1 on, 5 off etc;
.scon
a 2character1 (e.g. A, "1", \$) or its ASCII value.  This defines the character to be used for line 2line-no* when plotting on printing or display consoles, see $see<devices>.  In order to specify no line give 0 as the second argument (not space or 32, as this will cause existing lines, axes etc, to get over-written and, maybe erased, by spaces).

Note that dashed lines are implemented by drawing a sequence of small undashed lines.  Since these lines are about 4 - 10 raster units long, there are only a small number of directions in which they can point, and the chances are that none of these directions coincide with the direction of the dashed line as a whole. Hence dashed lines often appear to weave about.
.endfunction

.function(DEFINESYMBOL,|symbol-no,symbol-spec|);
redefines symbol number 2symbol-no* according to 2symbol-spec*. 2symbol-spec* may one of the following:

.scon
      2FALSE1, meaning no symbol
.scon
      2TRUE1, meaning a point
.scon
      A 2list of lists1 giving a sequence of setpoint and vector commands (relative to starting position) to be used in drawing the symbol. For example, DEFINESYMBOL(3,[[5,5],[5,-5,-5,-5,-5,5,5,5],[0,0],[0,0]]);  defines symbol 3 to be drawn by a setpoint to 5,5 (relative to the starting position) following by vectors to 5,-5; -5,-5; - 5,5; 5,5, followed by setpoint to origin and a vector to origin. this will draw a box with a dot in it. The numbers are in raster positions. DEFINESYMBOL should always end with a setpoint or vector to [0,0].
.scon
      A 2character1 or its ASCII value.  This is interpreted the same way as for DEFINEDASH.  For example, the command  DEFINESYMBOL(1, [[0, 9], [4, -6, -7, 2, 7, 2, -4, -6, 0, 9], [0, 0]]) defines symbol 1 to be a 5-pointed star.
.endfunction

.sec(Plotting Several Curves on One Screen,allinone)


2CLEAR and WAIT1

By governing when PLOT2 clears the screen it is possible to either superimpose plots or have plots come out in different parts of the screen.

$var<CLEAR/TRUE>:FALSE; causes the screen not to get cleared before starting a new plot.

$var<WAIT/TRUE>:FALSE; causes PLOT2 not to wait for a character to be typed after finishing a plot.

As an example, notice the effects of the individual parts of the following compound statement.
.example
.begin group turn on "_\"; tabs 8, 25, 34 ;  
(CLEAR:TRUE,WAIT:FALSE,\\turn on clearing, turn off waiting
 PLOT2(..),\\the screen will be cleared
 CLEAR:FALSE,\\turn off screen clearing
 PLOT2(..),\\plot more stuff
 GRAPH2(..),etc.,
 WAIT:TRUE,\\turn waiting back on
 PLOT2(..),\\last plot
 CLEAR:TRUE);\\reset CLEAR
.end
.end
Much more convenient ways are provided for doing this as described in the following sections.

2FIRST, LAST, and SAME1

$var<FIRST/>, $var<LAST/>, $var<SAME/> are optional args to the plotting functions and to REPLOT.  These optional arguments are non-sticky:  the fact that they were supplied is not remembered by REPLOT, although you can supply them to REPLOT.
.scon
FIRST or LAST indicate that the current plot is to be the first (or last) of a series of plots that are to be superimposed or plotted in different parts of the screen.  They work by setting the WAIT and CLEAR flags to achieve the right effect. (FIRST sets CLEAR to TRUE and WAIT to FALSE before plotting and CLEAR to FALSE after plotting.  LAST sets WAIT to TRUE before plotting and CLEAR to TRUE after plotting.

For example, in order to get 4 plots out in different corners of the screen a typical sequence might be:
.example

  (WINDOW:2window1*, PLOT2(......,FIRST),
   WINDOW:2window2*, PARAMPLOT2(......),
   WINDOW:2window3*, REPLOT(.....),
   WINDOW:2window4*, GRAPH2(.......,LAST),
   KILL(WINDOW));
.end
.scon
Obviously it is necessary to use a compound statement to prevent the printing of unwanted cruft on the screen.  Since plotting 4 graphs together is quite common, the REPLOT4 (10.3) command is provided to do that automatically.
.scon 
NAME tells PLOT2 to make the current plot on the same scale as the previous plot, and in the same WINDOW $see<scales>.  Plotting of axes, and printing of the date and the line giving XMAX, etc is suppressed.  The intention is to allow the convenient superposition of plots.  Specification of a title and labels is allowed, but if the previous plot which defines the scale of the current plot didn't have them they may appear in the wrong place (having wrapped around the screen).  If you want to specify a title, then you should probably specify a null title "" in the original plot.

For example, in order to superimpose plots the normal sequence is:
.example

  (PLOT2(.....,FIRST),
   PLOT2(.....,SAME),
   PLOT2(.....,SAME),
   ...
   PLOT2(.....,SAME,LAST));
.end

2REPLOT41

.function(REPLOT4,|plot1, ... ,plotk|)
conveniently replots up to 4 plots in different parts of the screen. 2plot1*,2plot2*,...  must be named plots $see<namsav>.  It plots the first plot in the upper left hand corner of the default window (or of your own window, if WINDOW $see<scales> has a value), the second arg in the upper right-hand corner, etc.  It stops when it runs out of things to plot.  This function takes care of the business of specifying the FIRST and LAST options to REPLOT, so don't give them to REPLOT4.
.example
.once center
2Example1
.begin group turn on "_\"; tabs 4, 28, 34 ;  
.scon
\PLOT2(X,X,0,1);\\plots X vs X
\NAMEPLOT(A1);\\names it A1
\PLOT2(SIN(X),X,0,2*%PI);
\NAMEPLOT(B[1]);
\PLOT2(X^2,X,0,1);
\NAMEPLOT(FOO);
\REPLOT4(A1,B[1],FOO);\\replots A1, B[1], and FOO
.end
.end
.endfunction

.sec(Device Characteristics,devices)

A number of different devices are supported by PLOT2.  You set things up for a particular device using the PLOTMODE command $see<otherpf>. Each has its peculiarities, which will be described here.    Note that if you plotting on a terminal you should only interrupt a plot by doing ^^ (control-uparrow), because your terminal will be left in a strange state otherwise $see<whatnow>.

2Tektronix1

The Tektronix has problems keeping up with PLOT2 at 9600 baud if short vectors are used.  For that reason PLOT2 will not normally use short vectors.  On slow terminals PLOT2 can be directed to use short vectors by setting the variable $var<PADDED/TRUE> to FALSE, this will result is some increase in speed.

For a Tektronix with graphic cross-hairs the EDIT function $see<plotedit> can be used to edit plots  (to put the labels in the right place, for example).

2Imlac1

ARDS graphics conventions are used.  Only Imlacs supporting these conventions are recognized by PLOT2. 

Imlacs do not have infinite room for storing vectors,  thus some plots (especially 3D and Contour plots) won't fit.  It may be necessary to locally clear the screen (with the CLEAR button) during a plot.  If you are also plotting for the Gould or the XGP output to those devices will not be effected.

2Grinnell TV's1

ARDS graphics conventions are used, however the coordinates are divided by 2 before being plotted, so WINDOW etc. should be chosen as though the screen coordinates ran from 0 to 1023 each way.

2Printing and Display1

These are really only intended to give a preview of the plot before it comes out on a higher resolution device like the XGP or the Gould.  Internally PLOT2 keeps a resolution appropriate for the standard graphics devices (about 1000 x 1000), so that good hardcopies can be obtained.  Instead of attempting to draw dotted lines or symbols for the various linetypes $see<linetypes> different characters are used, although dotted lines and symbols will be drawn on the hardcopy device. Line type 0 is drawn with .'s.  The other line types (1 - 9) are drawn with other symbols (*, #, $ etc.).  The symbols (specified by the tens digit of the line type) are defined by the letters (A, B, C etc.).  Unfortunately if you choose a line type that specifies both a line and a symbol, the line will in most cases overprint and so erase the symbol.

When plotting on another device, say the XGP, you might find that PLOTMODE:[X,D]; $see<otherpf>, results in your seeing only a corner of the plot.  This is because it is assuming the XGP's character size.  You can correct this by doing PLOTMODE:[D,X]; since this will use the terminal's character size.  The copies you get out of the XGP will have the characters slightly widely placed, but will otherwise be acceptable.

The difference between how PLOT2 handles printing and display terminals, is that with display terminals PLOT2 knows that it can move the cursor around, and so it will plot your graph in the same order that it would on say a Tektronix.  With a printing terminal, it stores up the entire plot, and spits it out at the end in a line by line fashion.  Multiple plots $see<allinone> are handled correctly, the entire plot coming out only after the LAST call to a plotting function.

The plotting is done on a character grid that is $var<PLOTHEIGHT/> high and $var<LINEL/> wide.  You may change these if you want, but the changes must be followed by a call to the PLOTMODE function (PLOTMODE(); will do) to re-initialize things.  With PLOTMODE(D) you will probably lose badly if PLOTHEIGHT or LINEL is set larger than your terminal can handle.  Note that you can restrict the area of the screen used, with more flexibility, by changing WINDOW $see<scales>.  Don't forget that you can look at WINDOW1 to see what the default was.

You might want to change the value of $var<CHARRATIO/2.5>.   This should equal the ratio of line-pitch to the character-pitch for your terminal.  This enables the EQUALSCALE:TRUE $see<scales> mode to work, and ensures that what you see on your screen/paper is the same shape as what will come out on the XGP.

2XGP1

Plotting on the XGP works by writing a file of ARDS graphics commands in a file on your default directory.  The filenames are .PLOT. 2uname*.  Since the XGP won't accept ARDS graphics commands, this file must be changed into something the XGP recognizes using the XP program.  There are two commands which do this for you: 
.function(XGPSAVE,filespec) 
produces an XGP'able file specified by 2filespec* of the last screenful (this might have consisted of several calls to PLOT2). 2filespec* defaults in the same way as the arguments to LOADFILE.  The resultant file is in the SCAN format for the XGP. You can get it XGP'ed by typing :XGP ;SCAN 2filespec* 2return* in DDT (using the DDT style filespec).  Don't forget to delete the files after they're printed, since they are usually large. If you are doing a lot of plots you might want to do
.example
	XGPSAVE(">",SCN,SECOND,2uname*);
.end scon
The advantage of this if 2-fold.  It will put the file on the secondary disk pack (PACK 13) which has more storage space.  The command :XGP ;SCAN 2uname*;* 2return* XGP's all the files of the form > SCN and DELETES them afterwards. (Note that currently the :XGP program can't be used on MC.  You have to log into AI to do it.  Also the SECOND device is not known to OLDIO MACSYM,  so if you are using OLDIO either use DSK,2uname* or preferably DSK,USERS1 - USERS1 is a secondary directory, all of whose files go on PACK 13).
.endfunction

Consider the example:
.begin narrow 8,0
.example
(PLOTMODE(X,GR),WINDOW:[100,900,0,950])$

(CALCOMPNUM:CALCOMPNUM1:40,VIEWPT:[-30,-20,5])$

PLOT3D((X^3+Y^4-0.2*X)*EXP(-X^2-Y^2)+0.3*EXP(-(X-1.225)^2-Y^2),
             X,-3,3,Y,-3,3);

XGPSAVE(">",SCN,DSK,CFFK);
.end
.end

The resulting plot is shown on the next page.

.next page
.example 
    
.end
.next page
The problem with the XGPSAVE command is that the files it produces are quite large.  Thus if you do not expect to get your plots off the XGP for a while the following two commands should be used.

.function(NAMEFILE,filespec)
takes the scratch file that PLOT2 uses in PLOTMODE(GOULD); or PLOTMODE(XGP); and copies it to 2filespec*.
.endfunction
.function(XGPSAVE1,filespec)
takes the file 2filespec* and converts it into XGP scan form.
.endfunction

Thus, XGPSAVE can be roughly defined as 
.scon
XGPSAVE(2filespec*):= (NAMEFILE(2filespec*), XGPSAVE1(2filespec*));
.scon
The advantage of this is that the scratch file (which contains ARDS graphics commands) is usually much shorter than the corresponding XGP file, thus if you want to generate several plots for the XGP, but aren't able to actually get them out on the XGP for a while then use NAMEPLOT now,  and convert them to XGP format with XGPSAVE1 at the last minute.

The XGPSAVE, NAMEFILE, and XGPSAVE1 commands all use DDT for various tasks (such as running the XP program or copying files).   You should not interrupt these functions with a ^Z, since you might be in DDT at the time.  If you  accidently do type ^Z at the wrong time you will see :INPUSH or something (meaning you have interrupted a valret).  What you should then do is: alt-alt-V; if the current job (the one with the * by it) is not your MACSYMA, type $P and let it finish (it will type :KILL or something when it's done); then do :INPOP<return>. This tells DDT to finish the valret you so rudely interrupted, and you should end up back in your MACSYMA.

Note that since these commands hack files in DDT, DDT's file defaults are changed by them.

Incidentally, since the file produced by NAMEFILE is ARDS graphics commands the plot it contains can be viewed by :IMPRNT'ing the file on an Imlac. 

2Gould1

Hardcopy can be produced off the Gould either by typing 2linefeed* after the plot has finished $see<whatnow> or by executing HARDCOPY(); $see<otherpf>.

HARDCOPY() (or a linefeed at the end of a plot) has to use DDT, so the  caveats about interrupting it with a ^Z apply.  It also changes your DDT's file defaults.

The parameters $var<GOULDSCALE/1.75> and $var<GOULDTHICK/2> govern the scale of the Gould output (the larger GOULDSCALE the larger the copy) and the thickness of the lines.  GOULDTHICK must be an integer.  The default GOULDSCALE and WINDOW $see<scales> produce a plot which nicely fits into an 8.5 x 11 piece of paper.

NOTE: Often people forget to say e.g. PLOTMODE(G,T); before doing a plot.  The thing to do in that case is: PLOTMODE(G,T); REPLOT(); followed by 2linefeed* $see<whatnow>.  The same applies for plotting on the XGP, except of course you have to do XGPSAVE.  This will only work if your plot consisted of a single call to a plotting function (the normal case).

.sec(Naming and Saving of Plots,namsav)

Plots can be given names, saved in files, killed just like other MACSYMA data types.  However since plots aren't really something MACSYMA knows about there are a number of commands specifically for manipulating plots.

.function(NAMEPLOT,plotname)
names the last call to one of the plotting functions 2plotname*. 2plotname* must be either an atom (e.g. FOOP) or an array element (e.g. SNOO[4]).  2plotname* is put onto the list  PLOTS  so it becomes for instance [2plotname*]. 2plotname* is put on the VALUES or ARRAYS list as appropriate.  Typing rubout at the end of a plot causes a 2plotname* to get read in and NAMEPLOT applied to it $see<whatnow>.

What actually gets saved by NAMEPLOT are the unscaled data points plus most of the optional arguments to the plotting function (the exceptions are FIRST, LAST, SAME $see<allinone> and DONT ).  This is why one can change the scale before replotting the plot using REPLOT $see<otherpf>.
.endfunction

.function(SAVEPLOTS,|[filespec],plotname1,plotname2, ... |)
saves the plots 2plotname1*, 2plotname2*,... etc in the file 2filespec*. defaulting of 2filespec* is traditional (e.g. FOO is the same as FOO,">").  [2filespec*] may be omitted altogether in which  case the defaults (as used by e.g. LOADFILE) are used.      SAVEPLOTS([2filespec*],ALL); saves all the plots in PLOTS.  (or else you can say SAVEPLOT([2filespec*],PLOTS); ) (N.B. SAVEPLOTS may be done within a WRITEFILE, unlike for instance SAVE.)  Another action of SAVEPLOTS is the put the 2filespec* into the value of the saved plots.  Thus a subsequent SAVE([2filespec1*],FUNCTIONS,2plotname*); although it won't correctly save the data in  2plotname* will remember what file it was saved in using the SAVEPLOTS command. SAVEPLOTS returns a list of plots it succeeded in saving

.endfunction

.function(LOADPLOTS,filespec)
loads a file of plots created by SAVEPLOTS. 2filespec* defaults exactly as with LOADFILE.  It also sets the file defaults. LOADPLOTS may be done within a batch (unlike LOADFILE).
.endfunction


.function(KILLPLOTS,|plotname1,plotname2, ... |) 
frees up the array storage used by 2plotname1*,... etc. KILLPLOTS(PLOTS), KILLPLOTS(ALL) and KILLPLOTS() will apply KILLPLOTS to all the members of PLOTS.  Note the KILLPLOTS does not KILL 2plotname1* etc.  and in  particular it leaves the 2filespec* information put in by SAVEPLOTS.  (If you never want to reference a plot again it is probably better to do a KILLPLOTS followed by a KILL, since KILLPLOTS takes care to totally exorcise the arrays of the plot from the system, something that KILL might not manage to do).  If you doing a lot of plotting then you may get a message like NO CORE ARRAY when trying to name a plot (either by invoking NAMEPLOT explicitly or by typing rubout after a plot.)  If that happens all you have to do is check that all the plots that are  important are saved using the SAVEPLOTS command, then do KILLPLOTS(); NAMEPLOT(2plotname*); 
.endfunction

.function(REPLOT,plotname)
replots 2plotname*.  If the arrays of 2plotname* were destroyed either by a KILLPLOTS(2plotname*); or by SAVE'ing 2plotname* and LOADFILE'ing it into another MACSYMA, REPLOT checks to see if 2plotname* was ever saved using the SAVEPLOTS command, if it was it finds the 2filespec* under which it was saved, and then attempts a LOADPLOTS(2filespec*); (but taking care not to change the current file defaults) and replots 2plotname* if it was found in the file.  REPLOT understands the old format of saved plots.
.endfunction

If $var<DONT/> appears as an optional argument to the plotting functions then the points will be calculated, but not plotted.  This is primarly of use for creating plots that are to be named and used later.  DONT is a non-sticky option (like FIRST and LAST), and so doesn't get saved when the plot is named (so PLOT2(EXP(X),X,-1,1,DONT); REPLOT(); will plot something).


In order to assist the manipulation of plots, a list of plots is kept.  The list is called $var<PLOTS/> and it contains all the plots present in your MACSYMA.  After KILLPLOTS is executed on a plot it is removed from PLOTS.  However, if it had been previously saved with the SAVEPLOTS command an attempt to REPLOT that plot will cause it to be reloaded from the file it was saved in and it will be put back on the PLOTS list.


.function(OLDNAMEPLOT,plotname)
names the last plot 2plotname* using the old format for naming plots (which could be safely SAVE'd and LOADFILE'd but which took up much space)
.endfunction
.example
.once center
2Examples* 

  PLOT2(SIN(X),X,-%PI,%PI);
  2rubout*
  SNOO;
  REPLOT(SNOO); replots SNOO
  PLOTS; ==> [SNOO]
  KILLPLOTS(); kills the plots in PLOTS i.e. SNOO
  REPLOT(SNOO); ==> SNOO NOT A PLOT (and it wasn't saved)
  REPLOT(); replots the last plot (which happens to be the same as
	SNOO)
  2rubout*
  ARF;
  SAVEPLOTS([CFK,PLOT,DSK,USERS],ALL); saves the plots in PLOTS
  KILLPLOTS();
  PLOTS; ==> [] there are now no active plots around
  VALUES; ==> [SNOO,ARF]  both SNOO and ARF got put on the values list
	but only ARF is any good because:
  SAVE([CFFK],VALUES); ==> [[CFFK, >, DSK, USERS], SNOO, ARF]
  ^Z
  MACSYM^K
  LOADFILE(CFK,">",DSK,USERS);
  VALUES; ==> [SNOO,ARF]  as before
  PLOTS; ==> []
  REPLOT(SNOO); ==> SNOO NOT A PLOT (It was never SAVEPLOTS'ed)
  REPLOT(ARF); ==> CFK PLOT DSK USERS being loaded
                  (ARF is automatically loaded in and replotted)
  PLOTS; ==> [ARF]  ARF is put back into PLOTS
  KILLPLOTS(); kills the arrays in ARF but saves the fact that it came 
	from CFK PLOT
  REPLOT(ARF); ARF is replotted.
.end

.sec(Transformations on Points,transformpts)


2POLAR, LOG, LINLOG, LOGLIN, LIN, and TXTYPE1

We first present some examples
.begin group turn on "_\"; tabs 8, 30, 34 ;  
.scon
PLOT2(1,T,0,2*%PI,POLAR);\\Plots a circle
.bcon
REPLOT(TRUE,LIN);\\Replots the previous plot on a linear
.bcon
\\scale (i.e. gives a horizontal line)
.bcon
PLOT2(EXP(X),X,0,10,LINLOG);\\Plots exp(X) on a Lin-Log scale

.end bcon
GRAPH2([1,2,5,10,50,100],[1,1.5,2.5,3,7,10],LOG);
.scon
Plots some random points on Log-Log scale.  Slope shows that y=sqrt(x).

If one of $var<POLAR/>, $var<LOG/>, $var<LINLOG/>, $var<LOGLIN/> appear as an optional argument to one of the 2D plotting functions, then the plots appear on the appropriate scale.

With POLAR the first arg to PLOT2 or the second arg to GRAPH2,  what is normally considered to be the y coordinate becomes r, the radius;  and what is normally considered to be the x coordinate becomes theta, the angle.

LOG causes both axes to appear on a log (base 10) scale.

LINLOG causes the y axis to appear on a log scale.

LOGLIN causes the x axis to appear on a log scale.

The optional arguments LOG and LOGLIN alse cause PLOT2 to choose  logarithmic intervals for the x variable, if the 2low*,2high* form of range specification is used $see<d2plot>.  (Something less than optimal probably happens for PARAMPLOT2 in this case).

CONTOURPLOT2 $see<contourplot> is regarded as being a 2D plotting function (since it does not transform its x and y coordinates).  Thus the above optional args work on it and CONTOURPLOT2(Y,X,0,2*%PI,Y,0,1,POLAR) does the right thing. Note that when a plot is saved, the points--- before their transformation---are saved, together with the type of transformation.  Thus is possible to change the transformation either using REPLOT $see<otherpf> or a ^A break $see<whatnow>.

With REPLOT all that is necessary is to supply an optional arg overriding the one originally given.   LIN is an optional argument that specifies no transformation (i.e. a LINear scale in both directions).  This can be given to REPLOT to turn off any transformations.

In a ^A break, the variable $var<TXTYPE/> is (locally bound) to the type of transformation.  Thus within a polar plot TXTYPE is POLAR. A value of FALSE implies no transformation (like LIN in REPLOT). The possible values of TXTYPE are FALSE, POLAR, LOG, LINLOG, LOGLIN, SPECIAL (for user defined transformations), and NOT3D (for Not3d plots $see<d3plot>).  Remember that after exiting the break the plot must be replotted (with a tab $see<whatnow>) for the change in TXTYPE to be saved.

2SPECIAL, XFUN, and YFUN1

If the optional argument $var<SPECIAL/> appears in the call to PLOT2 then immediately before sticking your data up on the screen PLOT2 looks at the values of $var<XFUN/FALSE> and $var<YFUN/FALSE>.  If they are FALSE the data gets scaled in the normal way and is plotted without further ado.  If either is non-FALSE then it should be the name of a function of 1 to 3 arguments which defines a transformation between the data and the x and y screen coordinates.  (The standard linear scaling is still applied the result of this transformation, to make your plot fit on the screen.)  The functions must be translated or compiled and must return a floating point result.  The way they work is best illustrated by an example.

Suppose   XFUN:POLARX;  YFUN:POLARY; where POLARX and POLARY are defined by: 
.example
    TRANSLATE:TRUE;
    POLARX(X,Y):=(MODEDECLARE([X,Y],FLOAT),Y*COS(X));
    POLARY(X,Y):=(MODEDECLARE([X,Y],FLOAT),Y*SIN(X));
.end scon
(note that X and Y are the THETA and R coordinates of a polar system)
.scon
then     PLOT2(1,X,0,2*%PI,SPECIAL);
.scon
produces CALCONMPNUM x data points (ranging from 0 to 2*%PI) and CALCOMPNUM corresponding y data points (all 1 in this case).  These x and y are given to the POLARX and POLARY functions as the first and second arguments and the value of these two functions is what is supplied to the normal scaling routines.  Thus this PLOT2 command will produce a circle (if EQUALSCALE:TRUE $see<scales>, an ellipse otherwise).  What we have  just described could of course all be done with the POLAR optional arg .  But then we have just described more or less what happens when you give the POLAR optional arg.

The arguments that XFUN and YFUN take are:
.begin group turn on "_\"; tabs 8, 16, 24, 32 ;  
.scon
\\1 arg\2 args\3 args
.scon
\XFUN\x\x,y\x,y,z
.bcon
\YFUN\y\x,y\x,y,z
.end
The first argument to PLOT2 is considered a y variable, and it's second argument an x variable.  For PARAMPLOT2 and GRAPH2 the first arguments are x variables and the second arguments are y variables.  For all the 2D plotting functions the z variable is 0.0.  (See below for the coordinate conventions for the 3d plotting functions).

In fact POLARX and POLARY come predefined in the PLOT2 files. Other XFUN's and YFUN's that may be of use are (omitting the  MODECLARE's):
.example
	    CLOG(X):=(IF X=0.0 THEN -90.0 ELSE LOG(ABS(X)))/LOG(10.0);
	    REFLECT(X):=-X$
	    YTOX(X,Y):=Y$
	    XTOY(X,Y):=X$
	    ZTOY(X,Y,Z):=Z$
	    ZTOX(X,Y,Z):=Z$  (just the same function really)
	    ROTATEX(X,Y):=X*COSANG-Y*SINANG$
	    ROTATEY(X,Y):=X*SINANG+Y*COSANG$
	    (SINANG and COSANG are set up by
	     INITROTATE(ANG):=(COSANG:COS(ANG),SINANG:SIN(ANG));)
.end
The following example plots ASIN(X) vs. X:
.example
  XFUN:YTOX;
  YFUN:XTOY;	These cause X and Y to be swapped
  PLOT2(SIN(X),X,-%PI/2,%PI/2,SPECIAL);	
.end
The XFUN's and YFUN's implied by the optional args POLAR,LOG,LINLOG,LOGLIN,LIN  are:
.begin group turn on "_\"; tabs 8, 25, 35 ;  
.scon
\optional arg.\XFUN\YFUN
.scon
\POLAR\POLARX\POLARY
.bcon
\LOG\CLOG\CLOG
.bcon
\LINLOG\FALSE\CLOG
.bcon
\LOGLIN\CLOG\FALSE
.bcon
\LIN\FALSE\FALSE
.end

23D Transformations and HOWCLOSE1

The perspective transformations $see<d3plot> work by the same XFUN and YFUN mechanism documented above.  In case to want to try changing the transformation here are the names of the functions used (although it is probably quite easy to confuse the function that figures out the hidden lines).

The hidden line routine also makes use of the variable HOWCLOSE. HOWCLOSE should evaluate a the name of a function of 3 arguments (x, y, and z) and should give a measure of how close the point [x,y,z] is to the viewer.  It is not necessary that this function return the exact distance [x,y,z] is away, just that the further away [x,y,z] is, the larger the number the function should return.
.skip
.begin group verbatim
CENTERPLOT  PERSPECTIVE  REVERSE  XFUN	     YFUN	HOWCLOSE
------------------------------------------------------------------------
non-FALSE   TRUE	 FALSE	  P3DX	     P3DY	HOWCLOSE3D
non-FALSE   TRUE	 TRUE	  P3DXR	     P3DYR	HOWCLOSE3D
non-FALSE   FALSE	 FALSE	  NP3DX	     NP3DY	HOWCLOSENP3D
non-FALSE   FALSE	 TRUE	  NP3DXR     NP3DYR	HOWCLOSENP3D
FALSE	    TRUE	 FALSE	  OLD3DX     OLD3DY	HOWCLOSEOLD3D
FALSE	    TRUE	 TRUE	  OLD3DXR    OLD3DYR	HOWCLOSEOLD3D
FALSE	    FALSE	 FALSE	  OLDNP3DX   OLDNP3DY	HOWCLOSEOLDNP3D
FALSE	    FALSE	 TRUE	  OLDNP3DXR  OLDNP3DYR	HOWCLOSEOLDNP3D
.end
.scon
The type of view is setup by doing
.inline function(INITPERSPEC,|CX,CY,CZ,VX,VY,VZ|)
.bcon
where [VX,VY,VZ] is the VIEWPT and [CX,CY,CZ] is the CENTERPLOT.

The optional argument NOT3D now causes YFUN to be bound to ZTOY.

.sec(Editing Plots,plotedit)

There exists a recently developed facility for editting pictures using the crosshairs on a Tektronix terminal.  This enables you to position labels accurately, and add in additional lines, arrows etc.

To load the editing package do 	LOADFILE(EDIT,FASL,DSK,CFK);

The main function in the package is called EDIT, and its intention is to allow you to enter labels and various odd lines onto an existing plot.  To use it you must have a function of no arguments, whose body is a BLOCK and the last statement in the BLOCK must be EXITGRAPH().  If the function is P(), say then P(); should plot as much of your picture as can be conveniently specified by PLOT2, GRAPH2 etc.

.function(EDIT,P)
will execute P(), but will stop before the final EXITGRAPH(), and display the cross-hairs.  By typing various letters EDIT will enter commands into the function P directly before the EXITGRAPH(),

Allowed characters are:
.begin narrow 8,5 indent 0,4
.scon
      2Rubout1, exit from EDIT
.scon
      2Space1, save the location of the crosshairs (for use with L and A)
.scon
      2S1, enters a SETPOINT command into your function
.scon
      2V1, enters a VECTOR command (should be preceded by a
	SETPOINT or another VECTOR command)
.scon
      2L1, draws a line between the saved location and the
	crosshairs and enters it in the function.
.scon
      2A1, draws an arrow head pointing in the direction from the saved location to the crosshairs.  The tip of the arrow is at the crosshairs.  The size of the arrow is ARROWSIZE (a floating point number in raster units, default value 20.0) and its half angle is ARROWANG (a floating point number in radians, default value 0.2).  (The arrow is drawn using the ?ARROW function, defined in EDIT FASL.  It takes 4 integer arguments, similarly to ?LINE $see<primitives>.  Thus ?LINE(20,20,100,100),?ARROW(20,20,100,100) draws a line with an arrow head on it.)
.scon
      2P1, reads text from the keyboard and prints it left justified at the cursor.  Echoing is suppressed while it is reading the text.  Reading continues until a Carriage-Return is encountered.  The case of the text is remembered, but if you want it preserved after, say STRINGOUT'ing and BATCH'ing you should set BOTHCASES:TRUE; scon      2C1, same as P, except the text is centered.
.scon
      2R1, same as P, except the text is right justified
.end
.scon			
    Remember that after exiting EDIT your function will have been changed, so that P(); should give you the updated PLOT.  Items maybe be removed using the MACSYMA editor, or TECO.  To draw a picture from scratch you could do:
.endfunction
.example
      HOUSE():=BLOCK([],ENTERGRAPH(),EXITGRAPH());
      EDIT(HOUSE);  now with a sequence of S's and V's you can draw a
	house terminating it with a Rubout.
      HOUSE();  re-draws your house.
.end
.sec(Defaults,defaults)

.subsec(Options,options)
The defaults for the options are:
.example
	CALCOMPNUM:20;
	CALCOMPNUM1:20;
	EQUALSCALE:FALSE;
	NOPRINT:FALSE;
	DATEPLOT:TRUE;
	XAXIS:ALL;
	YAXIS:ALL;
	TICKNUM:10;
	TICKSIZE:6;
	UNDERSIDE:TRUE;
	REVERSE:FALSE;
	PERSPECTIVE:TRUE
	PLOTNUMPREC:7;
	CONTOURS:20;
	LABELCONTOURS:TRUE;
	VIEWPT unbound
	CENTERPLOT unbound
	WINDOW unbound
	XMAX,XMIN,YMAX,YMIN,ZMAX,ZMIN unbound
	CLEAR:TRUE;
	WAIT:TRUE;
	PLOTBELL:TRUE;
**	GOULDSCALE:1.75;
**	GOULDTHICK:2;
**	CHARRATIO:2.5;
**	PADDED:TRUE;
**	LINEL		(terminal dependent)
**	PLOTHEIGHT	(terminal dependent)
**	PLOTMODE	(terminal dependent) 
.end
The double asterisk **  marks those options not reset by PLOTRESET();

The switches whose default state is unbound are put on the VALUES list when they are given a value.  The other switches get put on the MYOPTIONS list when they get changed.  So all options can be saved by doing SAVE([2fn1*,2fn2*,DSK,2dir*],MYOPTIONS,VALUES);)

The following are "read-only" options $see<scales>:
.example
	XMAX1,XMIN1,YMAX1,YMIN1,ZMAX1,ZMIN1
	VIEWPT1,CENTERPLOT1
	WINDOW1
	XMAX3D,XMIN3D,YMAX3D,YMIN3D,ZMAX3D,ZMIN3D
.end
.subsec(Lines and Symbols,linesymb)
  See $ref<linetypes>.  The defaults for the dashed lines are (not reset by PLOTRESET();):
.example
	DEFINEDASH(0,FALSE);		(solid line)
	DEFINEDASH(1,[40,8]);
	DEFINEDASH(2,[15,8]);
	DEFINEDASH(3,[1,7]);
	DEFINEDASH(4,[30,8,1,8]);
	DEFINEDASH(5,[30,8,1,8,1,8]);
	DEFINEDASH(6,[40,8,1,8,5,8,1,8]);
	DEFINEDASH(7,[8,30]);
	DEFINEDASH(8,[1,20]);
	DEFINEDASH(9,TRUE]);		(no line)
.end
The defaults for the symbols are (not reset by PLOTRESET();):
.example
 	DEFINESYMBOL(0,FALSE);		(no symbol)
	DEFINESYMBOL(1,[[0,6],[0,-6],[-6,0],[6,0],[0,0]]);
	DEFINESYMBOL(2,[[4,4],[-4,-4],[4,-4],[-4,4],[0,0]]);
	DEFINESYMBOL(3,[[6,6],[6,-6,-6,-6,-6,6,6,6],[0,0],[0,0]]);
	DEFINESYMBOL(4,[[8,0],[0,-8,-8,0,0,8,8,0],[0,0],[0,0]]);
	DEFINESYMBOL(5,[[0,8],[6,-4,-6,-4,0,8],[0,0],[0,0]]);
	DEFINESYMBOL(6,[[0,-8],[6,4,-6,4,0,-8],[0,0],[0,0]]);
	DEFINESYMBOL(7,[[8,0],[-4,6,-4,-6,8,0],[0,0],[0,0]]);
	DEFINESYMBOL(8,[[-8,0],[4,6,4,-6,-8,0],[0,0],[0,0]]);
	DEFINESYMBOL(9,TRUE);		(point)
.end

For PLOTMODE(PRINTING); or PLOTMODE(DISPLAY) the default line and symbol characters (defined by e.g. DEFINESYMBOL(1,"A");) are
.example
			   0  1  2  3  4  5  6  7  8  9
		lines      .  *  #  $  %  &  +  @  - none
		symbols  none A  B  C  D  E  F  G  H  I
.end
.subsec(PLOTMODE,plotmode)
  See $ref<otherpf>. Unless you set the PLOTMODE before PLOT2 is loaded, PLOTMODE gets initiallized according to LISP's TTY variable as follows:
.example
	TTY	PLOTMODE
.skip

	0	PRINTING
	1	DISPLAY			(datapoint)
	2	DISPLAY			(datapoint)
	3	IMLAC
	4	TEKTRONIX
	5	DISPLAY 		(TV these may soon be supported)
	6	PRINTING		(decwriter)
	7	(software tty) depends on the terminals characteristics
		as follows (this is the order the questioning are asked)
		Can't do cursor positioning	PRINTING
		Can't selectively erase		TEKTRONIX
		Can't overprint			DISPLAY
		An IMLAC (%TOIML)		IMLAC
		Not an AI-TV			GRINNELL
		Else				DISPLAY
	8	PRINTING		(terminet)
	9	DISPLAY			(other display)
.end
If WINDOW is unbound then it is chosen according to PLOTMODE as
	follows
.example
	if GOULD then [0, 1023, 5, 790]
	else if TEKTRONIX then [0, 1023, 5, 790]
	else if IMLAC then [0, 1023, 200, 1006.))
	else if PRINTING or DISPLAY then [0, 2char-width**LINEL-1,
					  0, 2char-height**PLOTHEIGHT-1]
	else [0, 1023, 0, 1023]
.end
For example, if PLOTMODE:[I,G], WINDOW is chosen to be [0, 1023, 5, 790] (because the GOULD condition is satisfied first).

For PRINTING or DISPLAY terminals 2char-width* and 2char-height* are chosen to make WINDOW be close to that for the other devices. The formulas used are
.example
	2char-width*  = 1 + ENTIER(1023/LINEL)
	2char-height* = ENTIER(0.5 + CHARRATIO*2char-width*)
.end
.sec(Primitives Called by PLOT2,primitives)

With the following functions practically no argument checking is done. So make sure a function gets floating-point numbers or integers as it needs them.  In particular 2xf*, 2xf1*, 2yf*, 2yf1* should all be floating point (unscaled) screen coordinates, and 2x*, 2x1*, 2y*, 2y1* should be integer screen coordinates after all scaling.  Some of the basic functions below come in 3 versions.

The one with the ? in front is the most basic.  Its arguments are in screen raster coordinates.

The middle one accepts floating point arguments as screen coordinates before the last stage of (linear) scaling is done.

The last one with a 3 at the end takes x, y, and z arguments and applies the transformation functions (set up with ?CALL\-INIT to them).
.example
?SETPOINT(2x*,2y*);	absolute setpoint
SETPOINT(2xf*,2yf*);
SETPOINT3(2xf*,2yf*,2zf*);

?POINT(2x*,2y*);	absolute point
POINT(2xf*,2yf*);
POINT3(2xf*,2yf*,2zf*);

?VECTOR(2x*,2y*);	absolute vector
VECTOR(2xf*,2yf*);
VECTOR3(2xf*,2yf*,2zf*);

?LINE(2x1*,2y1*,2x*,2y*);	line
LINE(2xf1*,2yf1*,2xf*,2yf*);
LINE3(2xf1*,2yf1*,2zf1*,2xf*,2yf*,2zf*);

CHANGEDASH(2n*);	change to dashed line 2n*
PUSHDASH();		change to dashed line 0 temporally
POPDASH();		undo PUSHDASH()

?DRAWSYMBOL(2x*,2y*,2n*);	draw symbol n
DRAWSYMBOL(2xf*,2yf*,2n*);
DRAWSYMBOL3(2xf*,2yf*,2zf*,2n*);

?TEK\-X(2xf*);	converts unscaled screen coordinates to raster coords
?TEK\-Y(2yf*);

?TEK\-XF(2x*);  converts raster coordinates to unscaled screen coords
?TEK\-YF(2y*);

SCREENSIZE(2min-x*,2min-y*,2max-x*,2max-y*);	sets the window in which
	plotting is done.  if a vector goes outside this window it will
	be clipped
SCREENSIZE1(2min-x*,2min-y*,2max-x*,2max-y*); 	same as SCREENSIZE
	except that the scale is left unchanged.  SCREENSIZE leaves
	2min-xf* etc. unchanged
SIZE(2min-xf*,2min-yf*,2max-xf*,2max-yf*);	sets the scale so that
	2min-xf*,2min-xf* gets plotted at 2min-x*,2min-y* etc.

?CALL\-X(2xf*,2yf*,2zf*);	applies transformation routines to give
?CALL\-Y(2xf*,2yf*,2zf*);		unscaled screen coords.

?CALL\-INIT(2xfun*,2yfun*);	initialized transformation routines to
	use 2xfun* and 2yfun*

CLEAR();		clears the screen
ENTERGRAPH();		should be done before a sequence of plotting.
	It will clear the screen if CLEAR is TRUE.
EXITGRAPH();		should be done after a sequence of plotting.
	If WAIT is TRUE it will wait for you to type in a char, and
	will return its ASCII value
HARDCOPY();		sends out a hardcopy signal

GHPRINT(2l*,2x*,2y*,2a*);	prints 2l* at (raster) coordinates
	2x*,2y*.  2a*=0 ==>left justify, 2a*=1 ==> center, 2a*=2 ==>
	right justify.  Add 10 to 2a* to get 2l* underlined.  2l* may
	be a list, in which case its element are concatenated together
GVPRINT(2l*,2x*,2y*,2a*);	prints 2l*.  2a*=1, 2, or 3 meaning
	top justify, center, or bottom justify.

.end






.chap (Debugging in MACSYMA,debugmac)

When the user's command lines, especially functions and $fun<BLOCK> programs, do not do
what is expected or generate errors, MACSYMA offers  several debugging alternatives:

(1) The user may trace function calls by typing TRACE(2fun1,fun2,...1),
where the 2funi1 are either MACSYMA or user-defined functions.  This will cause a
printout of the function name and its arguments each time it is entered, and of
the function name and the value it returns each time it is exited.  A count
which is the level of recursion is also printed.  Usually, this is all the
tracing power the user will need, although MACSYMA offers the full
capabilities of the LISP tracing package including conditional and breakpoint
tracing.  This will not be described here - for information see [Mn1].  MACSYMA
uses trace-syntax very similar to that of LISP.

To check which functions are currently under trace, the user may type TRACE().
To remove tracing of functions use UNTRACE(2fun1,fun2,...1).  To untrace all
previously traced functions type UNTRACE().  Since the TRACE package takes up
some of the user's workspace in core, when finished with it the user should type
$fun<REMTRACE>().  It can always be reloaded again if necessary.

(2) The assignment of variables can be traced by setting the variable SETCHECK to a list of variables (which can be subscripted).  When a variable on the list is bound (either with : or :: or function argument binding) then a message -- variable "SET TO" value -- will be printed. If the variable SETCHECKBREAK is set to TRUE then a (MACSYMA-BREAK) will be caused each time a variable on the SETCHECK list is bound.

(3) By setting the variable $var<REFCHECK/FALSE> to TRUE, the user will be informed when each
of his variables which has a value comes up for evaluation for the first time
during the course of a computation.  This has a dual purpose.  The user will be
informed of evaluations he may not have been aware of which are the result of
assignments he made long ago. It also gives him a sort of chronological trace of
his computations which may be helpful in finding out where an error has
occurred.

(4) By setting the variable $var<PREDERROR/> to TRUE, the user will be informed of
predicates of IF-THEN-ELSE statements which failed to evaluate to either TRUE or
FALSE.

(5) The user may have variables which he intends not to use purely symbolically,
i.e. they are to have values all the time.  By typing
DECLARE([2var1,var2,1...],BINDTEST) MACSYMA will give the user an error
whenever any of the vari appear in a computation unbound.  To remove a BINDTEST
declaration, the user may use the function $fun<REMOVE>.  $see<property!specification>

(6) When an error occurs in the course of a computation, MACSYMA prints out an
error message and terminates the computation.  At times the user may find it
helpful to investigate the environment at the place of the error.  To do so, type DEBUGMODE:TRUE or DEBUGMODE:ALL and repeat the computation.  This enters a special
debugging mode which will "break" or pause when an error occurs.  This mode may
be terminated by typing DEBUGMODE:FALSE.  When an error occurs in debugging
mode, (ERROR-BREAK) is printed. MACSYMA is then waiting for the user to type
something.  He may type any command line just as if he were at "top level".  The
command lines will be evaluated in the environment of the error.  If the user had done DEBUGMODE:ALL, he may now
type BACKTRACE;, and MACSYMA will print out a backtrace, which is a list of the
function calls the user is currently in together with the arguments they were
called with, ordered from most recent to earliest i.e., when reversed, this list
shows a trace beginning from the initial function and ending at the last call
entered including only those function calls from which the user still has not
exited.  To exit from the MACSYMA error-break and return to "top-level", type
EXIT;.

The user may also enter the error-break at any point, by typing control-A or by
executing the function $fun<BREAK> $see<miscfun>.  This will simply cause his
computation to pause, while he investigates at will.  $var<%%/> refers to the last
computed result while in the MACSYMA break.  $var<%/> still refers to the last
result computed at top-level.  Upon typing EXIT;, the computation will resume.  If
he wants to quit a computation begun in a control-A break without quitting the
top-level suspended computation, the user can type control-X.

During a break one may type $var<TOPLEVEL/>;.  This will cause top-level MACSYMA to
be entered recursively.  Labels will now be bound as usual.  Everything will be
identical to the previous top-level state except that the computation which was
interrupted is saved. The function TOBREAK() will cause the break which was left by
typing TOPLEVEL; to be re-entered.  If TOBREAK is given any argument whatsoever,
then the break will be exited, which is equivalent to typing TOBREAK() immediately
followed by EXIT;.


In the following example, an attempt is made to define a function ROOT which finds an approximate root to an expression
using Newton-Raphson iteration.
.example
.begin group
(C1) ROOT(F,V):=BLOCK([VAL,FUN,DER],DER:DIFF(F,V),VAL:0.0,
        TEST,FUN:SUBST(VAL,V,F),IF ABS(FUN)<5.0E-7 THEN
        RETURN(VAL),DER:SUBST(VAL,V,DER),VAL:VAL-FUN/DER,
        GO(TEST))$
.end

(C2) NUMER:TRUE$

(C3) F:SIN(%PI*X)-%PI*(X-1)$

(C4) ROOT(F,X);

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

(C5) DEBUG:TRUE$

(C6) DEBUGMODE:TRUE$

.begin group
(C7) ''C4;
F HAS VALUE
V HAS VALUE
VAL HAS VALUE
FUN HAS VALUE
DER HAS VALUE
.end

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

_(ERROR-BREAK)

_VAL;
1.0541436E+8

_DER;
- 2.98023224E-8

_TRACE(SUBST)$

_''C4;

.begin fill
1(The numerical value of %PI is present below due to NUMER being set to TRUE
above.)
.end

.begin group
1 ENTER SUBST [0.0, X, SIN(3.1415927 X) - 3.1415927 (X - 1)]
1 EXIT SUBST: 3.1415927
1 ENTER SUBST [0.0, X, 3.1415927 COS(3.1415927 X) - 3.1415927]
1 EXIT SUBST: - 2.98023224E-8
1 ENTER SUBST [1.0541436E+8, X, SIN(3.1415927 X) - 3.1415927 (X - 1)]
.end

3.3116898E+8 ARG TOO BIG FOR ACCURACY - SIN

.begin group
TRY AGAIN

.begin fill
1(This message is due to an error-break occurring within another error break.)
.end

_EXIT;
EXITED FROM THE BREAK
.end

(C8) <$>
_''C4
MYFROOT<$><$>

.begin fill
1(The user uses the MYF command of the MACSYMA editor to insert the definition of ROOT into the
edit buffer. The editor is then used to insert an IF statement to test for
DER being close to 0. The actual editing work is not shown.)
.end

.begin group
(C8) ROOT(F,V):=BLOCK([VAL,FUN,DER],DER:DIFF(F,V,1),VAL:0.0,
        TEST,FUN:SUBST(VAL,V,F),IF ABS(FUN)<5.0E-7 THEN
         RETURN(VAL),DER:SUBST(VAL,V,DER),IF ABS(DER)<5.E-8
         THEN ERROR("DERIVATIVE IS ZERO"),VAL:VAL-FUN/DER,
        GO(TEST))$
.end

(C9) UNTRACE();
(D9)                             [SUBST]

(C10) DEBUG:FALSE$

(C11) ''C4;
DERIVATIVE IS ZERO
QUIT     (This is due to the ERROR function being executed.)
.end
