


SEND(message)  which will  send  your message  to  some MACSYMA
    system programmer  who is  logged in at  that time.   If the
    message consists  of more than  one word, then  message must
    begin and end with double quotes.


&ARRAY(name, dim1, dim2, ..., dimk)

    This  sets  up a  k-dimensional  array.  A  maximum  of five
    dimensions  may  be  used.   The  subscripts  for   the  ith
    dimension are the integers  running from 0 to dimi.   If the
    user assigns to a subscripted variable before  declaring the
    corresponding array, an undeclared array is set up.

        Undeclared  arrays,  otherwise  known  as  hashed arrays
    (because hash  coding is done  on the subscripts),  are more
    general  than declared  arrays.  The  user does  not declare
    their maximum size, and they grow dynamically by  hashing as
    more  elements  are  assigned  values.  The   subscripts  of
    undeclared arrays need not even be numbers.  However, unless
    an array is rather sparse, it is probably more  efficient to
    declare it when possible  than to leave it  undeclared.  The
    ARRAY function can be used to transform an  undeclared array
    into a declared array.


    &BLOCK([v1,...,vk],  statement1,...,statementj)  Blocks
        in MACSYMA are somewhat analogous to subroutines in
        FORTRAN or procedures in ALGOL or PL/I.  Blocks are
        like compound statements  but also enable  the user
        to label statements within the block and  to assign
        "dummy" variables to values which are local  to the
        block.  The vi are variables which are local to the
        BLOCK and  the stmti  are any  MACSYMA expressions.
        If no variables are to be made local then  the list
        may be omitted.
        A  block  uses  these  local  variables   to  avoid
        conflict with variables having the same  names used
        outside of  the block (i.e.  global to  the block).
        In this case, upon  entry to the block,  the global
        values are saved onto a stack and  are inaccessible
        while  the  block  is  being  executed.   The local
        variables then are unbound so that they evaluate to
        themselves.  They may be bound to  arbitrary values
        within the block but  when the block is  exited the
        saved values are restored to these  variables.  The
        values  created  in  the  block  for   these  local
        variables  are  lost.   Where  a  variable  is used
        within  a block  and is  not in  the list  of local
        variables for that block it will be the same as the
        variable used outside of the block.

            If  it is  desired  to save  and  restore other



        local  properties   besides  VALUE,   namely  ARRAY
        (except   for   complete   arrays   -    (see   )),
        FUNCTION,   DEPENDENCIES,   ATVALUE,  MATCHDECLARE,
        ATOMGRAD,   CONSTANT,   AND   NONSCALAR    (see   )
        then the  function LOCAL should  be used  inside of
        the  block with  arguments being  the names  of the
        variables (see ).

            The value of the block is the value of the last
        statement  or  the  value of  the  argument  to the
        function  RETURN   which  may   be  used   to  exit
        explicitly from the  block. The function GO  may be
        used to  transfer control to  the statement  of the
        block that is labeled with the argument to  GO.  To
        label a statement, precede it by an atomic argument
        as another  statement in  the BLOCK.   For example:
        BLOCK([X],X:1,LOOP,X:X+1,...,GO(LOOP),...).     The
        argument  to  GO   may  be  any   expression  which
        evaluates to a  label.  For example GO(IF  X>Y THEN
        PLACE1 ELSE COMPUTEPLACE(X)).  One cannot use GO to
        transfer to a label  in a BLOCK other than  the one
        containing the GO.

            Blocks typically appear on the right side  of a
        function definition but can be used in other places
        as well.


    &EV(exp,  arg1, ...,  argn)  is one  of  MACSYMA's most
        powerful and  versatile commands. It  evaluates the
        expression exp in the environment specified  by the
        argi.  This is done in steps, as follows:


            (1) First the environment is set up by scanning
        the argi which may be as follows:

            SIMP causes exp to be simplified  regardless of
        the  setting  of  the  switch  SIMP  which inhibits
        simplification if FALSE.

            NOEVAL  supresses  the evaluation  phase  of EV
        (see   step  (4)   below).   This   is   useful  in
        conjunction with the other switches and  in causing
        exp to be resimplified without being reevaluated.

            EXPAND causes expansion.

            EXPAND(m,n)   causes  expansion,   setting  the
        values  of  MAXPOSEX  and  MAXNEGEX  to  m   and  n
        respectively. (see the EXPAND function below)

            DETOUT causes  any matrix inverses  computed in



        exp to have  their determinant kept outside  of the
        inverse rather than dividing through each element.

            DIFF causes  all differentiations  indicated in
        exp  to  be  performed.   (see  the  DIFF  function
        below.)

            DERIVLIST(var1,...,vark)       causes      only
        differentiations  with  respect  to  the  indicated
        variables.

            FLOAT causes  non-integral rational  numbers to
        be converted to floating point.

            NUMER   causes   some   mathematical  functions
        (including exponentiation) with numerical arguments
        to  be   evaluated  in   floating  point   (see  ).
        It causes  variables in exp  which have  been given
        numervals  (see  6.12.2) to  be  replaced  by their
        values.  It also sets the FLOAT switch on.

            PRED   causes  predicates   (expressions  which
        evaluate to TRUE or FALSE) to be evaluated.

            EVAL causes an extra post-evaluation of  exp to
        occur. (See step (5) below.)

            E where E is  an atom declared to be  an EVFLAG
        (see 6.12.1)  causes E to  be bound to  TRUE during
        the evaluation of exp.

            V:expression   (or   alternately  V=expression)
        causes V  to be  bound to  the value  of expression
        during the evaluation of exp.  Note that if V  is a
        MACSYMA  option, then  expression is  used  for its
        value during the  evaluation of exp.  If  more than
        one argument to EV is of this type then the binding
        is  done  in  parallel.   If  V  is   a  non-atomic
        expression  then  a  substitution  rather   than  a
        binding is performed.

            E where E,  a function name, has  been declared
        to be an EVFUN (see 6.12) causes E to be applied to
        exp.

            Any  other  function  names  (e.g.  SUM)  cause
        evaluation of occurrences of those names in  exp as
        though they were verbs (see sect. 3.2).

            In addition  a function  occurring in  exp (say
        F(args)) may be defined locally for the  purpose of
        this evaluation of  exp by giving  F(args):=body as
        an argument to EV.



            If an atom not mentioned above or a subscripted
        variable or subscripted expression was given  as an
        argument, it is evaluated  and if the result  is an
        equation or  assignment then the  indicated binding
        or substitution is  performed.  If the result  is a
        list then the members of the list are treated as if
        they were  additional arguments  given to  EV. This
        permits a list of equations to be given (e.g. [X=1,
        Y=A**2] )  or a  list of  names of  equations (e.g.
        [E1,E2] where E1 and E2 are equations) such as that
        returned by SOLVE. (see )

            The argi of EV  may be given in any  order with
        the exception  of substitution equations  which are
        handled  in  sequence, left  to  right,  and EVFUNS
        which  are composed,  e.g. EV(exp,RATSIMP,REALPART)
        is handled as REALPART(RATSIMP(exp)).

            The SIMP, NUMER,  FLOAT, and PRED  switches may
        also be set locally in a block, or globally  at the
        "top level" in MACSYMA so that they will  remain in
        effect until being reset.

            If exp is  in CRE form  (see 4.1) then  EV will
        return a result in CRE form provided the  NUMER and
        FLOAT switches are not both TRUE.

            (2) During step (1), a list is made of the non-
        subscripted variables appearing on the left side of
        equations in the argi or in the value of  some argi
        if the value  is an equation.  The  variables (both
        subscripted variables which do not  have associated
        array functions, and non-subscripted  variables) in
        the  expression exp  are replaced  by  their global
        values, except  for those  appearing in  this list.
        Usually,  exp is  just  a label  or %  (as  in (C2)
        below),   so   this  step   simply   retrieves  the
        expression named by the label, so that EV  may work
        on it.

            (3) If any  substitutions are indicated  by the
        argi, they are carried out now.

            (4)  The  resulting  expression  is   then  re-
        evaluated (unless one  of the argi was  NOEVAL) and
        simplified according the  the argi.  Note  that any
        function calls in exp will be carried out after theî                                                  _____
        variables  in it  are evaluated  and  that EV(F(X))
        thus may behave like F(EV(X)).

            (5) If one of the argi was EVAL, steps  (3) and
        (4) are repeated.

                             Examples



        (C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
                                D                 2
        (D1)  COS(Y) + SIN(X) + --SIN(W) + (W + 1)
                                DW
        (C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
                            2
        (D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742

            An  alternate  "top  level"  syntax   has  been
        provided for EV, whereby  one may just type  in its
        arguments,  without  the EV().   That  is,  one may
        write  simply   exp,arg1,...,argn.  (This   is  not
        permitted as  part of  another expression,  i.e. in
        functions, blocks, etc.)

        (C4) X+Y,X:A+Y,Y:2;
        (D4)                Y + A + 2

        (Notice the parallel binding process)

        (C5) 2*X-3*Y=3$

        (C6) -3*X+2*Y=-4$

        (C7) SOLVE([D5,D6]);
        SOLUTION
                                        1
        (E7)                     Y =  - -
                                        5
                                  6
        (E8)                  X = -
                                  5

        (D8)               [E7, E8]

        (C9) D6,D8;
        (D9)               - 4 =  - 4

        (C10) X+1/X > GAMMA(1/2);

                            1
        (D10)           X + - > SQRT(%PI)
                            X

        (C11) %,NUMER,X=1/2;

        (D11)            2.5 > 1.7724539

        (C12) %,PRED;
        (D12)                  TRUE



    &ZEROEQUIV(exp,var) tests whether the expression exp in
        the variable var is equivalent to zero.  It returns
        either  TRUE,  FALSE,  or  DONTKNOW.   For  example
        ZEROEQUIV(SIN(2*X)  -   2*SIN(X)*COS(X),X)  returns
        TRUE and ZEROEQUIV(%E^X+X,X) returns FALSE.  On the
        other hand ZEROEQUIV(LOG(A*B) - LOG(A)  - LOG(B),A)
        will return DONTKNOW because of the presence  of an
        extra parameter.  The restrictions are:

            (1) Do not use functions that MACSYMA  does not
        know how to differentiate and evaluate.

            (2)  If the  expression has  poles on  the real
        line, there may be  errors in the result  (but this
        is unlikely to occur).

            (3) If the expression contains  functions which
        are  not  solutions  to  first  order  differential
        equations  (e.g.  Bessel  functions)  there  may be
        incorrect results.

            (4) The  algorithm uses evaluation  at randomly
        chosen     points     for     carefully    selected
        subexpressions.    This   is   always   a  somewhat
        hazardous business, although the algorithm tries to
        minimize the potential for error.


    &EXPAND(exp)   will   cause   products   of   sums  and
        exponentiated sums to be multiplied out, numerators
        of rational expressions which are sums to  be split
        into  their  respective  terms,  and multiplication
        (commutative and non-commutative) to be distributed
        over   addition  at   all  levels   of   exp.   For
        polynomials one should usually use  RATEXPAND which
        uses a more efficient algorithm (see below).

            MAXNEGEX[6] and MAXPOSEX[6] control the maximum
        negative  and  positive   exponents,  respectively,
        which will expand.

            EXPAND(exp,p,n)  expands   exp,  using   p  for
        MAXPOSEX  and n  for MAXNEGEX.   This is  useful in
        order to expand part but not all of an expression.

            EXPON[0] - the exponent of the largest negative
        power which is automatically  expanded (independent
        of calls  to EXPAND).   For example  if EXPON  is 4
        then   (X+1)**(-5)   will   not   be  automatically
        expanded.

            EXPOP[0] - the highest positive  exponent which
        is  automatically  expanded.   Thus  (X+1)**3, when



        typed, will be automatically expanded only if EXPOP
        is greater than or equal to 3.  If it is desired to
        have  (X+1)**N  expanded where  N  is  greater than
        EXPOP  then  executing  EXPAND((X+1)**N)  will work
        only if MAXPOSEX is not less than N.


    &RATEXPAND(exp) expands exp by multiplying out products
        of sums and exponentiated sums, combining fractions
        over a common denominator, cancelling  the greatest
        common  divisor of  the numerator  and denominator,
        then splitting  the numerator (if  a sum)  into its
        respective terms divided by the  denominator.  This
        is accomplished by converting exp to CRE  form (see
        4.1) and then back to general form.

            RATEXPAND[FALSE]  -  if  TRUE  will  cause  CRE
        expressions  to  be fully  expanded  when  they are
        converted back to general form or  displayed, while
        if  it  is  FALSE  then they  will  be  put  into a
        recursive form. (see RATSIMP below)

            RATDENOMDIVIDE[TRUE] -  if FALSE will  stop the
        splitting  up  of  the terms  of  the  numerator of
        RATEXPANDed expressions from occurring.

            KEEPFLOAT[FALSE]  if set  to TRUE  will prevent
        floating point numbers from being rationalized when
        expressions which contain them are converted to CRE
        form.

            TAKEGCD[TRUE]   if  FALSE   will   prevent  the
        greatest  common  divisor  from  being  taken  when
        expressions are converted  to CRE form.   This will
        sometimes  speed the  calculation if  gcds  are not
        required.

        (C1) RATEXPAND((2*X-3*Y)**3);

                        3         2       2        3
        (D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X

        (C2) (X-1)/(X+1)**2+1/(X-1);

                                      X - 1       1
        (D2)                         -------- + -----
                                            2   X - 1
                                     (X + 1)

        (C3) EXPAND(D2);



                                 X              1           1
        (D3)                ------------ - ------------ + -----
                             2              2             X - 1
                            X  + 2 X + 1   X  + 2 X + 1

        (C4) RATEXPAND(D2);

                                     2
                                  2 X                 2
        (D4)                 --------------- + ---------------
                              3    2            3    2
                             X  + X  - X - 1   X  + X  - X - 1




    &RATSIMP(exp)   "rationally"  simplifies   (similar  to
        RATEXPAND)  the  expression  exp  and  all  of  its
        subexpressions  including  the  arguments  to  non-
        rational functions.  The result is returned  as the
        quotient of  two polynomials  in a  recursive form,
        i.e.  the  coefficients of  the  main  variable are
        polynomials in the other variables.  Variables may,
        as  in  RATEXPAND,  include  non-rational functions
        (e.g. SIN(X**2+1) ) but with RATSIMP, the arguments
        to    non-rational    functions    are   rationally
        simplified.  Note that RATSIMP is affected  by some
        of the variables which affect RATEXPAND.

            RATSIMPEXPONS[FALSE]  -  if  TRUE   will  cause
        exponents   of   expressions   to    be   RATSIMPed
        automatically during simplification.

        (C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);

                                            2                  2
                            X          - LOG (X) + (LOG(X) + 1)
        (D1)          SIN(------) = %E
                           2
                          X  + X

        (C2) RATSIMP(%);
                                          1          2
        (D2)                        SIN(-----) = %E X
                                        X + 1

        (C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));

                               3/2
                        (X - 1)    - SQRT(X - 1) (X + 1)
        (D3)            --------------------------------
                            SQRT(X - 1) SQRT(X + 1)

        (C4) RATSIMP(%);



                                         2
        (D4)                      - -----------
                                    SQRT(X + 1)

        (C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;

                            2
                           A  + 1
                           ------
                             A
        (D5)              X



    &RADCAN(exp)  simplifies exp,  which can  contain logs,
        exponentials, and radicals, by converting it into a
        form  which  is  canonical over  a  large  class of
        expressions and a given ordering of variables; that
        is,  all functionally  equivalent forms  are mapped
        into a unique form.  For a somewhat larger class of
        expressions, RADCAN produces a regular  form [Fa2].
        Two equivalent expressions  in this class  will not
        necessarily  have  the same  appearance,  but their
        difference will  be simplified  by RADCAN  to zero.
        For  some  expressions  RADCAN  can  be  quite time
        consuming.  This is  the cost of  exploring certain
        relationships   among   the   components   of   the
        expression for  simplifications based  on factoring
        and partial-fraction expansions of exponents.

            RADPRODEXPAND[TRUE]  when  set  to  FALSE  will
        inhibit certain  transformations: RADCAN(SQRT(1-X))
        will  remain  SQRT(1-X)  and  will  not  become  %I
        SQRT(X-1).   RADCAN(SQRT(X^2-2*X+1))   will  remain
        SQRT(X^2-2*X + 1) and will not be transformed to X-
        1.

        (C1) (LOG(X**2+X)-LOG(X))**A/LOG(X+1)**(A/2);

                                  2               A
                            (LOG(X  + X) - LOG(X))
        (D1)                -----------------------
                                           A/2
                                 LOG(X + 1)

        (C2) RADCAN(%);
                                       A/2
        (D2)                 LOG(X + 1)

        (C3) LOG(A**(2*X)+2*A**X+1)/LOG(A**X+1);



                           2 X      X
                      LOG(A    + 2 A  + 1)
        (D3)          --------------------
                               X
                          LOG(A  + 1)

        (C4) RADCAN(%);
        (D4)                  2

        (C5) (%E**X-1)/(%E**(X/2)+1);

                               X
                             %E  - 1
        (D5)                ---------
                              X/2
                            %E    + 1

        (C6) RADCAN(%);

                              X/2
        (D6)                %E    - 1



    &MULTTHRU(exp) multiplies a  factor (which should  be a
        sum) of exp  by the other  factors of exp.  That is
        exp is f1*f2*...*fn where at least one  factor, say
        fi, is a  sum of terms.  Each  term in that  sum is
        multiplied  by the  other factors  in  the product.
        (Namely all the factors except fi).   MULTTHRU does
        not  expand exponentiated  sums.  This  function is
        the fastest way to distribute products (commutative
        or noncommutative) over sums.  Since  quotients are
        represented as products  (see 4.3) MULTTHRU  can be
        used to divide sums by products as well.


    &MULTTHRU(exp1,  exp2)  multiplies  each  term  in exp2
        (which should be a sum or an equation) by exp1.  If
        exp1  is  not  itself  a  sum  then  this  form  is
        equivalent to MULTTHRU(exp1*exp2).

        (C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;

                       1        X         F(X)
        (D1)       - ----- + -------- - --------
                     X - Y          2          3
                             (X - Y)    (X - Y)

        (C2) MULTTHRU((X-Y)**3,%);

                            2
        (D2)       - (X - Y)  + X (X - Y) - F(X)



        (C3) RATEXPAND(D2);
                                   2
        (D3)                    - Y  + X Y - F(X)

        (C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);

                                 10  2              2  2
                        (B  + A )   S  + 2 A B S + A  B
        (D4)            --------------------------------
                                           2
                                      A B S

        (C5) MULTTHRU(%);

                                                  10
                                2   A B   (B  + A)
        (D5)                    - + --- + -------
                                S    2      A B
                                    S

        (notice that (B+A)**10 is not expanded)

        (C6) MULTTHRU(A.(B+C.(D+E)+F));

        (D6)                A . F + A . (C . (E + D)) + A . B

        (compare with similar example under EXPAND)



    &XTHRU(exp) combines all terms of exp (which  should be
        a sum) over a common denominator  without expanding
        products  and exponentiated  sums as  RATSIMP does.
        XTHRU cancels common  factors in the  numerator and
        denominator of rational expressions but only if the
        factors are  explicit.  Sometimes  it is  better to
        use XTHRU before RATSIMPing an expression  in order
        to  cause  explicit  factors  of  the  gcd  of  the
        numerator  and  denominator  to  be  canceled  thus
        simplifying the expression to be RATSIMPed.

        (C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;

                                                        20
                             1           X       (X + 2)   - 2 Y
        (D1)             --------- - --------- + ---------------
                                19          20             20
                         (Y + X)     (Y + X)        (Y + X)

        (C2) XTHRU(%);



                                             20
                                      (X + 2)   - Y
        (D2)                          -------------
                                               20
                                        (Y + X)



    &PARTFRAC(exp,  var)  expands  the  expression  exp  in
        partial   fractions  with   respect  to   the  main
        variable,   var.    Each  power   of   a  different
        denominator will  be represented  by only  a single
        term  (i.e. the  decomposition is  not "complete").
        The algorithm  employed is based  on the  fact that
        the denominators of the partial  fraction expansion
        (the  factors  of  the  original  denominator)  are
        relatively prime.  The numerators can be written as
        linear  combinations   of  denominators,   and  the
        expansion falls out.

        (C1) 2/(X+2)-1/(X+1)-X/(X+1)**2$

        (C2) RATSIMP(%);
                                             X
        (D2)                      - -------------------
                                     3      2
                                    X  + 4 X  + 5 X + 2

        (C3) PARTFRAC(%,X);
                                    - 2 X - 1     2
        (D3)                       ---------- + -----
                                           2    X + 2
                                    (X + 1)



    &FACTOR(exp) factors the expression exp, containing any
        number  of  variables  or  functions,  into factors
        irreducible over the integers.


    &FACTOR(exp, p) factors exp over the field  of integers
        with an  element adjoined whose  minimum polynomial
        is p.

            FACTORFLAG[FALSE]   if  FALSE   suppresses  the
        factoring   of   integer   factors    of   rational
        expressions.

            DONTFACTOR may  be set to  a list  of variables
        with respect  to which factoring  is not  to occur.
        (It is initially  empty).  Factoring also  will not
        take place with respect to any variables  which are



        less important (using the variable ordering assumed
        for CRE  form) than those  on the  DONTFACTOR list.
        (see sect. 6.5)

            SAVEFACTORS[FALSE] if  TRUE causes  the factors
        of an expression which  is a product of  factors to
        be saved by certain functions in order to  speed up
        later factorizations of expressions containing some
        of the same factors.

            BERLEFACT[TRUE]  if  FALSE  then  the Kronecker
        factoring  algorithm  will  be  used  otherwise the
        Berlekamp algorithm, which is the default,  will be
        used. (see [Be1, Wa4])

            INTFACLIM[FALSE] is  the largest  divisor which
        will be tried when factoring a bignum  integer.  If
        set to its default (FALSE), or if the integer  is a
        fixnum (i.e.  fits in  one machine  word), complete
        factorization  of  the integer  will  be attempted.
        Thus,  INTFACLIM may  be reset  to  prevent MACSYMA
        from  taking  an inordinately  long  time factoring
        large integers.   The user should  note that  if he
        types,   say,  SQRT(integer);   MACSYMA  ordinarily
        attempts  to  factor  the  integer.   For  example,
        FACTOR(1129886087521);     gives     1031^4    when
        INTFACLIM:FALSE$   ,   but   doesn't   factor  when
        INTFACLIM:2^10.

        (C1) FACTOR(2**63-1);

                                                        2
        (D1)                   73 127 337 92737 649657 7

        (C2) FACTOR(Z**2*(X+2*Y)-4*X-8*Y);

        (D2)                   (2 Y + X) (Z - 2) (Z + 2)

        (C3)  X**2*Y**2+2*X*Y**2+Y**2-X**2-2*X-1;

                             2  2        2    2    2
        (D3)                X  Y  + 2 X Y  + Y  - X  - 2 X - 1

        (C4) DONTFACTOR:[X]$

        (C5) FACTOR(D3/36/(Y**2+2*Y+1));

                                    2
                                  (X  + 2 X + 1) (Y - 1)
        (D5)                      ----------------------
                                        36 (Y + 1)

        (C6) FACTOR(%E**(3*X)+1);



                                    X         2 X     X
        (D6)                   (%E  + 1) (%E    - %E  + 1)

        (C7) FACTOR(X**4+1,A**2-2);

                            2              2
        (D7)              (X  + A X + 1) (X  - A X + 1)


            When FACTOR is  applied to integers,  note that
        the  value returned  by FACTOR  when used  in other
        computations may not  lead to a  simplified result.
        Using D1  above, the  user can check  that D1  + 1;
        will not return 2^63.


    &FACTORSUM(exp) tries to group terms in factors  of exp
        which are sums into groups of terms such that their
        sum is  factorable.  It can  recover the  result of
        EXPAND((X+Y)^2+(Z+W)^2)   but   it   can't  recover
        EXPAND((X+1)^2+(X+Y)^2)  because  the   terms  have
        variables in common.


    (C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;

              2      2                            2      2
    (D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X

                             2        2    2            2
                + 2 U V X + U  X + A W  + V  + 2 U V + U

    (C2) FACTORSUM(%);
                                           2          2
    (D2)                 (X + 1) (A (Z + W)  + (V + U) )



    &SQFR(exp)  is  similar  to  FACTOR  except   that  the
        polynomial factors are "square-free." That is, they
        have factors only  of degree one.   This algorithm,
        which is  also used by  the first stage  of FACTOR,
        utilizes the fact  that a polynomial has  in common
        with its nth derivative all its factors of degree >
        n.  Thus by taking gcds with the polynomial  of the
        derivatives with  respect to  each variable  in the
        polynomial, all factors of degree > 1 can be found.

        (C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);

                                     2               2
        (D1)                       (X  - 1) (2 X + 1)



    &GFACTOR(exp)  factors  the  polynomial  exp  over  the
        Gaussian  integers  (i.  e.  with  SQRT(-1)   =  %I
        adjoined).  This is like FACTOR(exp,A**2+1) where A
        is %I.

        (C1)  GFACTOR(X**4-1);
        (D1)        (X - 1) (X + 1) (X + %I) (X - %I)



    &GFACTORSUM(exp)  is similar  to FACTORSUM  but applies
        GFACTOR instead of FACTOR.


    &IRREDUCIBLE(exp)   returns   exp   flagged   as  being
        irreducible, i.e. it doesn't factor.  Exp must be a
        sum.   If FACTOR  is ever  called on  an expression
        marked as irreducible it returns  immediately.  For
        example, if  the value of  H is a  large expression
        which  the user  knows  to be  irreducible  and the
        expression G*H is  to be factored (where  the value
        of G is arbitrary) then FACTOR(G*IRREDUCIBLE(H)) is
        faster than FACTOR(G*H).


    &PARTITION(exp, var) returns a list of two expressions.
        They  are  (1) the  factors  of expr  (if  it  is a
        product)  or the  terms of  expr (if  it is  a sum)
        which  don't contain  var and,  (2) the  factors or
        terms which do.

        (C1) PARTITION(2*A*X*F(X),X);

        (D1)                 [ 2 A , X F(X) ]

        (C2) PARTITION(A+B,X);

        (D2)                 [ A + B , 0 ]


    &DIFF(exp, v1, n1, v2, n2, ...) differentiates exp with
        respect to  each vi, ni  times.  If just  the first
        derivative with respect to one variable  is desired
        then the form DIFF(exp,v) may be used.  If the noun
        form is required  (as, for example, when  writing a
        differential  equation), 'DIFF  should be  used and
        this will display in a two dimensional format.

            DERIVABBREV[FALSE]    if   TRUE    will   cause
        derivatives to display as subscripts.

            DIFF(exp) gives the "total  differential", that
        is, the sum of the derivatives of exp  with respect



        to each of its variables times the function  DEL of
        the variable.  No further simplification of  DEL is
        offered.

            The  user should  be aware  that simplification
        rules for  differential operators can  be specified
        using the LET command ((see )).

            Consider  a  function F(X).  To  inform MACSYMA
        that   F  depends   on  X,   the  user   must  type
        DEPENDENCIES(F(X));   (otherwise,   DIFF(F,X)  will
        return 0).  We will assume that this has  been done
        and that  DERIVABBREV has been  set to TRUE  in the
        following example.

            Now  suppose that  the function  F(X) satisfies
        some    constraint,   say    that    the   (scalar)
        d'Alembertian of f(x) is zero:

                            1 f(x) = 0.

            In a curved space, this may take the form:


        (C4) -2*(DIFF(F,X)*X +2)*(L*(DIFF(F,X)^3)*X^2
        + (4*DIFF(F,X,2) + 4*(DIFF(F,X)^2) )*X + 8*DIFF(F,X) );
                                  3    2                   2
        (D4)  - 2 (F  X + 2) ((F )  L X  + (4 F    + 4 (F ) ) X
                    X           X              X X       X

                        + 8 F )
                             X

            One can solve for the second-order term:

        (C5) SOLVE(%,DIFF(F,X,2));
        SOLUTION
                                       3    2         2
                                   (F )  L X  + 4 (F )  X + 8 F
                                     X              X          X
        (E5)              F    = - -----------------------------
                           X X                  4 X
        (D5)                               [E5]

        which  can  be restated  as  a  simplification rule
        using the LET command (see ).


        (C6) LET(DIFF(F,X,2),RHS(E5));
        (D6)                       (F     -->  RHS(E5))
                                     X X

            Then a  relatively complicated  expression such
        as



                   4  2  3                        3     2
        (D10) ((F )  L  X  + (8 F  F    L + 8 (F )  L) X
                 X               X  X X         X

                2
         + ((F )  (12 L + 16) + 16 F   ) X + 32 F )
              X                     X X          X

                                    2    2
                           /(X ((F )  L X  + 4 F  X + 4))
                                  X                     X
        can be simplified using the LETSIMP  command, which
        applies the rules specified by the user:

        (C11) FACTOR(LETSIMP(%));

                                               2
        (D11)                            - (F )  L
                                             X



    &DEPENDENCIES(f1,   ...,   fn)    declares   functional
        dependencies for variables to be used by DIFF. Each
        fi (i=1,n) has  the format f(v1,...,vm)  where each
        vj  (j=1,m)  is  an  atomic  variable  on  which  f
        depends.  f  is the name  of an atomic  variable or
        array.  In the latter case, it is assumed  that all
        of  the  elements  of  f  depend  on  the variables
        v1,v2,... in  the same way.   Thus DIFF(Y,X)  is 0,
        initially.   Executing   DEPENDENCIES(Y(X))  causes
        future differentiations of  Y with respect to  X to
        be displayed as DY/DX.

            It  is  possible  to  give  several  levels  of
        dependency  relations  because  MACSYMA  knows  the
        chain rule for symbolic derivatives.

            The  variable  DEPENDENCIES is  a  list  of the
        functional dependencies attributed to  variables by
        uses of the DEPENDENCIES function.  Each  member of
        the list is of the form f(v1,..).

        (C1) DEPENDENCIES(A(X));
        (D1)                               [A]

        (C2) DIFF(A.A,X);
                                     DA           DA
        (D2)                         -- . A + A . --
                                     DX           DX
        (C4) DEPENDENCIES(F(X,Y),X(T),Y(T));

        (D4)                 [F(X, Y), X(T), Y(T)]



        (C5) DIFF(F,T);
                                 DF DY   DF DX
        (D5)                     -- -- + -- --
                                 DY DT   DX DT

            To eliminate a previously  declared dependency,
        the REMOVE  command can be  used.  For  example, to
        say that Y  no longer depends  on T as  declared in
        C4, the  user can type  REMOVE(Y,DEPENDENCY).  This
        will eliminate all dependencies that may  have been
        declared for Y.


    &GRADEF(f(x1,  ...,  xn),  g1,  ...,  gn)  defines  the
        derivatives of the function f with respect to its n
        arguments.  That  is, df/dxi =  gi, etc.   If fewer
        than n gradients, say i, are given, then they refer
        to the first i  arguments of f.  The xi  are merely
        dummy variables  as in function  definition headers
        and are  used to  indicate the  ith argument  of f.
        All  arguments  to  GRADEF  except  the  first  are
        evaluated so that if  g is a defined  function then
        it is invoked and the result is used.
        Gradients are needed when, for example,  a function
        is not known  explicitly but its  first derivatives
        are  and  it  is  desired  to  obtain  higher order
        derivatives.  GRADEF may  also be used  to redefine
        the derivatives  of MACSYMA's  predefined functions
        (e.g.  GRADEF(SIN(X),SQRT(1-SIN(X)**2))  ).   It is
        not  permissible  to  use  GRADEF   on  subscripted
        functions.

            GRADEFS is a  list of the functions  which have
        been given gradients by use of the GRADEF command.

            PRINTPROPS([f1,f2,...],GRADEF) (see 6.12.1) may
        be  used to  display the  gradefs of  the functions
        f1,f2,..


    &GRADEF(a,v,exp)  may  be   used  to  state   that  the
        derivative of the atomic variable a with respect to
        v    is   exp.     This   automatically    does   a
        DEPENDENCIES(a(v)).  For  examples, see  example II
        of Appendix III.

        PRINTPROPS([a1,a2,...],ATOMGRAD)  (see  6.12.1) may
        be used to  display the atomic  gradient properties
        of a1,a2,...

        (C1) DEPENDENCIES(Y(X))$

        (C2) GRADEF(F(X,Y),X**2,G(X,Y))$



        (C3) DIFF(F(X,Y),X);
                                             DY    2
        (D3)                         G(X, Y) -- + X
                                             DX

        (C4) GRADEF(J(N,Z), 'DIFF(J(N,Z),N),
        RATSIMP(J(N-1,Z)-N/Z*J(N,Z)))$

        (C5) DIFF(J(2,X),X,2);

                               2
                      J(0, X) X  - 3 J(1, X) X + 6 J(2, X)
        (D5)          ------------------------------------
                                        2
                                       X


            (The   example   above   computes   the  second
        derivative of  a Bessel function  of order  two.  A
        subscripted function e.g. J[N], could not have been
        used because  a gradient for  it cannot  be defined
        using GRADEF.)


    &INTEGRATE(exp, var) integrates exp with respect to var
        or returns an  integral expression (the  noun form)
        if  it  cannot  perform  the  integration.  Roughly
        speaking three stages are used:

            (1) INTEGRATE sees  if the integrand is  of the
        form  F(G(X))*DIFF(G(X),X) by  testing  whether the
        derivative of some subexpression (i.e. G(X)  in the
        above case) divides the integrand.  If so  it looks
        up F in a  table of integrals and  substitutes G(X)
        for X in the integral  of F.  This may make  use of
        gradients in taking the derivative.  (If an unknown
        function  appears  in  the  integrand  it  must  be
        eliminated  in this  stage or  else  INTEGRATE will
        return the noun form of the integrand.)

            (2) INTEGRATE tries to match the integrand to a
        form for which a specific method can be  used, e.g.
        trigonometric substitutions.

            (3) If  the first two  stages fail it  uses the
        Risch algorithm. (see [Mo2, Mo4])


    &INTEGRATE(exp,  var,  low,  high)  finds  the definite
        integral of  exp with  respect to  var from  low to
        high.  The limits should not contain  var.  Several
        methods are used, including direct  substitution in
        the  indefinite  integral  and  contour integration



        (see [Wa3]).  Improper integrals may use  the names
        INF  for positive  infinity and  MINF  for negative
        infinity.   If an  integral "form"  is  desired for
        manipulation (for example, an integral which cannot
        be computed until some numbers are  substituted for
        some parameters), the  noun form 'INTEGRATE  may be
        used and this will display with an integral sign.

            The   function  LDEFINT   (see  )   uses  LIMIT
        to  evaluate the  integral at  the lower  and upper
        limits.

            Sometimes  during integration  the user  may be
        asked what the sign of an expression  is.  Suitable
        responses are POS;  , ZERO; ,  or NEG; .  (see also
        sect. 6.12.3)

        (C1) INTEGRATE(SIN(X)**3,X);

                            3
                         COS (X)
        (D1)             ------- - COS(X)
                            3

        (C2) INTEGRATE(X**A/(X+1)**(5/2),X,0,INF);
        IS  A + 1  POSITIVE, NEGATIVE, OR ZERO?

        POS;
        IS  2 A - 3  POSITIVE, NEGATIVE, OR ZERO?

        NEG;
                                    3
        (D2)            BETA(A + 1, - - A)
                                    2

        (C3) GRADEF(Q(X),SIN(X**2));
        (D3)                              Q(X)

        (C4) DIFF(LOG(Q(R(X))),X);

                                   D             2
                                  (-- R(X)) SIN(R (X))
                                   DX
        (D4)                      --------------------
                                        Q(R(X))

        (C5) INTEGRATE(%,X);
        (D5)                          LOG(Q(R(X)))



    &RISCH(exp,  var) integrates  exp with  respect  to var
        using the Risch algorithm.  This  currently handles



        the  cases  of nested  exponentials  and logarithms
        which  the  main   part  of  INTEGRATE   can't  do.
        INTEGRATE will  automatically apply RISCH  if given
        these cases.

            ERFFLAG[TRUE]  - if  FALSE prevents  RISCH from
        introducing the ERF function in the answer if there
        were none in the integrand to begin with.

        (C1) RISCH(X^2*ERF(X),X);

                    2     2
                 - X     X             3           2
               %E     (%E   SQRT(%PI) X  ERF(X) + X  + 1)
        (D1)   ------------------------------------------
                              3 SQRT(%PI)

        (C2) DIFF(%,X),RATSIMP;
                                         2
        (D2)                            X  ERF(X)



    &CHANGEVAR(exp,ovar=G(nvar),nvar)  will  substitute the
        function  G(nvar) for  the variable  of integration
        ovar in any integrals in exp which are with respect
        to ovar.
        If  the  inverse  function of  G  (the  solution to
        ovar=G(nvar)  )  is  not  unique  then   the  first
        solution  returned by  SOLVE  will be  used  as the
        inverse.

        (C1)'INTEGRATE(%E**SQRT(A*Y),Y,0,4);

                            4
                           /
                           [    SQRT(A) SQRT(Y)
        (D1)               I (%E               ) DY
                           ]
                           /
                           0

        (C2) CHANGEVAR(D1,Y=Z**2/A,Z);

                           - 2 SQRT(A)
                          /                   Z
                          [             2 Z %E
        (D3)              I            (-------) DZ
                          ]                A
                          /
                          0



    &PART(exp, n1, ...,  nk) deals with the  displayed form
        of exp. It obtains the part of exp as  specified by
        the  indices n1,...,nk.   First part  n1 of  exp is
        obtained, then part n2 of that, etc.  The result is
        part nk  of ... part  n2 of part  n1 of  exp.  Thus
        PART(Z+2*Y,2,1)  yields  2.  PART  can  be  used to
        obtain an  element of  a list, a  row of  a matrix,
        etc.

        (C1)  X+Y/Z**2;
                                Y
        (D1)                   -- + X
                                2
                               Z
        (C2) PART(D1,1,2,2);

        (D2)                    2

        (C3) 'INTEGRATE(F(X),X,A,B)+X;

                              B
                             /
                             [
        (D3)                 I F(X)DX + X
                             ]
                             /
                             A

        (C4) PART(%,1,1);
        (D4)                  F(X)



    &INPART(exp, n1, ..., nk) is similar to PART  but works
        on  the internal  representation of  the expression
        (see 4.3) rather  than the displayed form  and thus
        may be  faster since no  formatting is  done.  Care
        should  be  taken  with  respect  to  the  order of
        subexpressions  in  sums  and  products  (since the
        order of  variables in the  internal form  is often
        different from that  in the displayed form)  and in
        dealing with unary minus, subtraction, and division
        (since  these   operators  are  removed   from  the
        expression). PART(X+Y,0) or INPART(X+Y,0)  yield +,
        though in order to refer to the operator it must be
        enclosed in "s.  For example ...IF INPART(D9,0)="+"
        THEN ...

        (C1)  X+Y+W*Z;

        (D1)                  W Z + Y + X

        (C2)  INPART(D1,3,2);



        (D2)                  Z
        (C3)  PART(D1,1,2);

        (D3)                  Z

        (C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
                                              G(X + 1)
        (D4)                      LIMIT   F(X)
                                  X ->0-

        (C5) INPART(%,1,2);
        (D5)                            G(X + 1)



    &NOUNIFY(f) returns the noun form of the  function name
        f.  This is  needed if one  wishes to refer  to the
        name of a verb function as if it were a noun.  Note
        that  some verb  functions will  return  their noun
        forms  if  they  can't  be  evaluated  for  certain
        arguments.   This is  also the  form returned  if a
        function call is preceded by a quote.

        (C6) IS(INPART(D4,0)=NOUNIFY(LIMIT));

        (D6)                              TRUE



    &VERBIFY(f)  returns the  function name  f in  its verb
        form.


    &BOX(expr) returns expr enclosed in a box.  The  box is
        actually part  of the  expression.  BOX(expr,label)
        encloses expr in a  labelled box.  label is  a name
        which will  be truncated  in display  if it  is too
        long.

            BOXCHAR[*] - is the character used to  draw the
        box in this and in the DPART and LPART functions.


    &DPART(exp, n1, ..., nk) selects the same subexpression
        as  PART,  but  instead  of  just   returning  that
        subexpression as  its value,  it returns  the whole
        expression   with   the    selected   subexpression
        displayed inside a  box.  The box is  actually part
        of the expression.



        (C1) DPART(X+Y/Z**2,1,2,1);

                               Y
        (D1)                  ---- + X
                                 2
                             *****
                             * Z *
                             *****



    &LPART(label, expr,  n1, ..., nk)  is similar  to DPART
        but uses a labelled box. A labelled box  is similar
        to the one produced by  DPART but it has a  name in
        the top line.


    &REMBOX(expr, arg) removes boxes from expr according to
        arg.   If  arg is  UNLABELLED  then  all unlabelled
        boxes  are removed.   If arg  is the  name  of some
        label then only boxes with that label  are removed.
        If  arg  is  omitted then  all  boxes  labelled and
        unlabelled are removed.


    &SUBST(a, b, c) substitutes a for b in c.  b must be an
        atom,  or  a  complete  subexpression  of  c.   For
        example,  X+Y+Z  is  a  complete  subexpression  of
        2*(X+Y+Z)/W while X+Y is not. When b does  not have
        these  characteristics,   one  may   sometimes  use
        SUBSTPART or RATSUBST (see  below).  Alternatively,
        if  b  is  of  the  form  e/f  then  one  could use
        SUBST(a*f,e,c) while if  b is of the  form e**(1/f)
        then  one  could  use  SUBST(a**f,e,c).   The SUBST
        command  also  discerns  the X^Y  in  X^-Y  so that
        SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.
        a  and b  may also  be operators  of  an expression
        enclosed in "s or  they may be function  names.  If
        one  wishes  to  substitute  for   the  independent
        variable in derivative  forms then the  AT function
        (see below) should be used.

            SUBST(eq1,exp) or  SUBST([eq1,...,eqk],exp) are
        other  permissible  forms.  The  eqi  are equations
        indicating  substitutions  to  be  made.   For each
        equation, the  right side  will be  substituted for
        the left in the expression exp.

            EXPTSUBST[FALSE] if TRUE  permits substitutions
        like Y for %E**X in %E**(A*X) to take place.

        (C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
                                         2
        (D1)                    Y + X + A



        (C2) SUBST(-%I,%I,A+B*%I);
        (D2)                             A - %I B


        (Note that C2 is  one way of obtaining  the complex
        conjugate of an expression.) The following examples
        illustrate the difference between  substitution (as
        performed by  SUBST) and  binding (as  performed by
        EV).

        (C3) A+B*%I,%I:-%I;
        %I IMPROPER VALUE ASSIGNMENT

        (C4) SUBST(X=0,DIFF(SIN(X),X));

        (D4)                           1

        (C5) DIFF(SIN(X),X),X=0;
        0
        ATTEMPT TO DIFFERENTIATE WRT A NUMBER

        (C6) INTEGRATE(X^I,X),I=-1;

        (D6)                              LOG(X)

        (C7) SUBST(-1,I,INTEGRATE(X^I,X));
        DIVISION BY 0

        (C8) MATRIX([A,B],[C,D]);
                                        [ A  B ]
        (D8)                            [      ]
                                        [ C  D ]

        (C9) SUBST("[",MATRIX,%);
        (D9)                        [[A, B], [C, D]]



    &RATSUBST(a, b, c) substitutes a for b in c.  b  may be
        a   sum,  product,   power,  etc.   RATSUBST  knows
        something  of  the meaning  of  expressions whereas
        SUBST does  a purely syntactic  substitution.  Thus
        SUBST(A,X+Y,X+Y+Z)  returns X+Y+Z  whereas RATSUBST
        would return Z+A.

            RADSUBSTFLAG[FALSE]     if     TRUE     permits
        substitutions like U for SQRT(X) in X.

        (C1)   RATSUBST(A,X*Y^2,X^4*Y^8+X^4*Y^3)

                          3      4
        (D1)           A X  Y + A

        (C2) 1 + COS(X) + COS(X)^2 + COS(X)^3 + COS(X)^4;



                    4         3         2
        (D2)     COS (X) + COS (X) + COS (X) + COS(X) + 1

        (C3) RATSUBST(1-SIN(X)^2,COS(X)^2,%);
                    4                  2            2
        (D3)     SIN (X) + COS(X) (2 - SIN (X)) - 3 SIN (X) + 3



    &SUBSTPART(x, exp, n1,  ..., nk) substitutes x  for the
        subexpression  picked  out  by  the  rest   of  the
        arguments as in PART.  It returns the new  value of
        exp.  x may be some operator to be  substituted for
        an operator of exp.  In this case it is enclosed in
        "s.

        (C1) 1/(X**2+2);
                                            1
        (D1)                              ------
                                           2
                                          X  + 2

        (C2) SUBSTPART(3/2,%,2,1,2);
                                            1
        (D2)                             --------
                                          3/2
                                         X    + 2

        (C3) A*X+F(B,Y);
        (D3)                          A X + F(B, Y)

        (C4) SUBSTPART("+",%,1,0);
        (D4)                         X + F(B, Y) + A



    &SUBSTINPART(x,  exp, n1,  ...) is  like  SUBSTPART but
        works on the internal representation of exp.

        (C1) X.'DIFF(F(X),X,2);
                                           2
                                          D
        (D1)                         X . (--- F(X))
                                            2
                                          DX

        (C2) SUBSTINPART(D**2,%,2);
                                              2
        (D2)                             X . D

        (C3) SUBSTINPART(F1,F[1](X+1),0);

        (D3)                            F1(X + 1)



                      Additional Information


            If the  last argument to  a part function  is a
        list  of  indices then  several  subexpressions are
        picked out, each  one corresponding to an  index of
        the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.

            PIECE holds  the value  of the  last expression
        selected when using the part functions.  It  is set
        during the execution  of the function and  thus may
        be  referred to  in  the function  itself  as shown
        below.

            If PARTSWITCH[FALSE] is set to TRUE then END is
        returned  when  a selected  part  of  an expression
        doesn't exist, otherwise an error message is given.

        (C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;

                    3         2       2            3
        (D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1

        (C2)  PART(D1,2,[1,3]);

                          2
        (D2)          54 Y

        (C3)  SQRT(PIECE/54);

        (D3)            Y

        (C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);

                                  3
        (D4)           (3 Y + 2 X) + Y + X + 1

        (C5) 1/X+Y/X-1/Z;
                                         1   Y   1
        (D5)                           - - + - + -
                                         Z   X   X

        (C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);

                                        Y + 1   1
        (D6)                            ----- - -
                                          X     Z



    &ATVALUE(form, list, value) enables the user  to assign
        the  boundary value  value  to form  at  the points
        specified by list.



        (C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$

            The form must be a function, f(v1,v2,...)  , or
        a derivative, DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in
        which  the functional  arguments  explicitly appear
        (ni is  the order  of differentiation  with respect
        vi).

            The list of equations determine  the "boundary"
        at which the value is given; list may be a  list of
        equations,  as above,  or a  single equation,  vi =
        expr .

            The  symbols  @1,   @2,...  will  be   used  to
        represent the  functional variables  v1,v2,... when
        atvalues are displayed.

            PRINTPROPS([f1, f2,...], ATVALUE|) will display
        the   atvalues  of   the  functions   f1,f2,...  as
        specified in previously  given uses of  the ATVALUE
        function. (see  6.12.1) If  the list  contains just
        one element then  the element can be  given without
        being in  a list.   If a first  argument of  ALL is
        given then  atvalues for  all functions  which have
        them will be displayed.


    &AT(exp,  list) will  evaluate  exp (which  may  be any
        expression) with the variables assuming  the values
        as specified for them  in the list of  equations or
        the single  equation similar to  that given  to the
        ATVALUE  function.  If  a subexpression  depends on
        any of the variables  in list but it hasn't  had an
        atvalue specified and it can't be evaluated  then a
        noun form  of the  AT will  be returned  which will
        display in a two-dimensional form.

        (C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2);

                                             2
        (D1)                                A

        (C2) ATVALUE('DIFF(F(X,Y),X),X=0,Y+1);

        (D2)                              @2 + 1

        (C3) PRINTPROPS(ALL,ATVALUE);



                                          !
                              D           !
                             --- F(@1, @2)!       = @2 + 1
                             D@1          !
                                          !@1 = 0

                                                2
                                     F(0, 1) = A

        (D3)                               DONE

        (C4) DIFF(4*F(X,Y)**2-U(X,Y)**2,X);

                           D                        D
        (D4)    8 F(X, Y) (-- F(X, Y)) - 2 U(X, Y) (-- U(X, Y))
                           DX                       DX

        (C5) AT(%,[X=0,Y=1]);
                                                 !
                       2               D         !
        (D5)       16 A  - 2 U(0, 1) ( -- U(X, Y)!            )
                                       DX        !
                                                 !X = 0, Y = 1


    &LISTOFVARS(exp) yields a list of the variables in exp.

            LISTCONSTVARS[FALSE]   if   TRUE   will   cause
        LISTOFVARS  to  include   %E,  %PI,  %I,   and  any
        variables declared constant (see 6.12) in  the list
        it returns if they  appear in exp.  The  default is
        to omit these.

        (C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));

        (D1)                            [X[1], Y, A, G]



    &COEFF(exp, v,  n) obtains the  coefficient of  v**n in
        exp.  n  may be omitted  if it is  1.  v may  be an
        atom,  or complete  subexpression of  exp  e.g., X,
        SIN(X),  A[I+1], X+Y,  etc. (In  the last  case the
        expression (X+Y)  should occur in  exp).  Sometimes
        it  may be  necessary to  expand or  factor  exp in
        order  to  make  v^n explicit.   This  is  not done
        automatically by COEFF.



        (C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));

        (D1)                         2 A + 1 = 5

        (C2) COEFF(Y+X*%E**X+1,X,0);
        (D2)                            Y + 1



    &RATCOEF(exp, v, n) returns the coefficient, C,  of the
        expression v**n  in the expression  exp.  n  may be
        omitted  if  it  is  1.   C  will  be  free (except
        possibly in a non-rational sense) of  the variables
        in v.  If no coefficient of this type  exists, zero
        will be  returned.  RATCOEF expands  and rationally
        simplifies  its  first  argument  and  thus  it may
        produce answers different from those of COEFF which
        is  purely  syntactic.   Thus  RATCOEF((X+1)/Y+X,X)
        returns   (Y+1)/Y   whereas   COEFF    returns   1.
        RATCOEF(exp,v,0)   is   currently   the   same   as
        RATSUBST(0,v,exp).   Therefore if  v occurs  to any
        negative powers, RATCOEF should not be used.  Since
        exp is rationally simplified before it is examined,
        coefficients may not appear quite the way they were
        envisioned.

        (C1) S:A*X+B*X+5$

        (C2) RATCOEF(S,A+B);

        (D2)               X



    &BOTHCOEF(exp, var) returns  a list whose  first member
        is  the  coefficient of  var  in exp  (as  found by
        RATCOEF if exp is  in CRE form otherwise  by COEFF)
        and whose  second member is  the remaining  part of
        exp.  That is, [A,B] where exp=A*var+B.

        (C1) ISLINEAR(EXP,VAR):=BLOCK([C],
                C:BOTHCOEF(RAT(EXP,VAR),VAR),
                IS(FREEOF(VAR,C) AND C[1]#0))$

        (C2) ISLINEAR((R**2-(X-R)**2)/X,X);

        (D2)                              TRUE



    &ISOLATE(exp,  var)  returns  exp  with  subexpressions
        which  are  sums  and  which  do  not  contain  var
        replaced by  intermediate expression  labels (these



        being  atomic symbols  like E1,  E2, ...).  This is
        often  useful  to  avoid  unnecessary  expansion of
        subexpressions which don't contain the  variable of
        interest.  Since the intermediate labels  are bound
        to the subexpressions  they can all  be substituted
        back  by evaluating  the expression  in  which they
        occur.

            EXPTISOLATE[FALSE] if  TRUE will  cause ISOLATE
        to  examine  exponents  of  atoms  (like  %E) which
        contain var.

        (C1) (A+B)^4*(1+X*(2*X+(C+D)^2));

                                   4                  2
        (D1)                (B + A)  (X (2 X + (D + C) ) + 1)

        (C2) ISOLATE(%,X);

                                                2
        (E2)                             (D + C)

                                                4
        (E3)                             (B + A)

        (D3)                      E3 (X (2 X + E2) + 1)

        (C4) RATEXPAND(D3)$

        (C5) EV(%);

                       4  2          4        2            4
        (D5)  2 (B + A)  X  + (B + A)  (D + C)  X + (B + A)

        (C6) (A+B)*(X+A+B)^2*EXP(X^2+A*X+B);
                                                   2
                                              2   X  + A X + B
        (D6)               (B + A) (X + B + A)  %E

        (C7) ISOLATE(%,X),EXPTISOLATE:TRUE;

        (E7)                              B + A

                                             B
        (E8)                               %E

                                                   2
                                              2   X  + A X
        (D8)                    E7 E8 (X + E7)  %E



    &PICKAPART(exp,depth)  will  assign  E  labels  to  all
        subexpressions of exp down to the specified integer
        depth.  This  is  useful  for  dealing  with  large
        expressions and  for automatically  assigning parts
        of an  expression to a  variable without  having to
        use the part functions.

        (C1) INTEGRATE(1/(X^3+2),X)$

        (C2) PICKAPART(D1,1);

                                               1/3
                                      LOG(X + 2   )
        (E2)                          -------------
                                            2/3
                                         3 2

                                                 1/3
                                          2 X - 2
                                    ATAN(------------)
                                          1/3
                                         2    SQRT(3)
        (E3)                        ------------------
                                        2/3
                                       2    SQRT(3)


                                       2    1/3      2/3
                                  LOG(X  - 2    X + 2   )
        (E4)                    - -----------------------
                                             2/3
                                          6 2

        (D4)                         E4 + E3 + E2


    &NUMFACTOR(exp) gives the numerical  factor multiplying
        the expression exp  which should be a  single term.
        If the gcd of all the terms in a sum is desired the
        CONTENT function (sect. 6.5) may be used.

        (C1) GAMMA(7/2);

        (D1)               15 SQRT(%PI)
                           ------------
                                8

        (C2) NUMFACTOR(%)
                            15
        (D2)                --
                             8



    &HIPOW(exp, v)  the highest explicit  exponent of  v in
        exp.  Sometimes it  may be necessary to  expand exp
        since  this  is not  done  automatically  by HIPOW.
        Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.


    &LOPOW(exp,  v)   the  lowest   exponent  of   v  which
        explicitly      appears      in      exp.      Thus
        LOPOW((X+Y)**2+(X+Y)**A,X+Y) is MIN(A,2).


    &DERIVDEGREE(exp, dv, iv)  finds the highest  degree of
        the derivative  of the  dependent variable  dv with
        respect to the independent variable iv  occuring in
        exp.

        (C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
        (C2) DERIVDEGREE(%,Y,X);
        (D2)                           2



    &REALPART(exp) gives the real part of exp. REALPART and
        IMAGPART   will  work   on   expressions  involving
        trigonometic and  hyperbolic functions, as  well as
        SQRT, LOG, and exponentiation.


    &IMAGPART(exp)  returns  the  imaginary  part   of  the
        expression exp.


    &RECTFORM(exp) returns  an expression of  the form  A +
        B*%I, where A and B are purely real.


    &POLARFORM(exp)  returns  R*%E^(%I*THETA)  where  R and
        THETA are purely real.


    &CABS(exp)  returns  the  complex  absolute  value (the
        complex modulus) of exp.


    &LHS(eqn) the left side of the equation eqn.


    &RHS(eqn) the right side of the equation eqn.


    &NUM(exp) obtains the numerator, exp1, of  the rational
        expression exp = exp1/exp2.



    &DENOM(exp)  returns  the  denominator,  exp2,  of  the
        rational expression exp = exp1/exp2.


    &FIRST(exp)  yields the  first  part of  exp  which may
        result in  the first element  of a list,  the first
        row  of a  matrix, the  first term  of a  sum, etc.
        Note  that FIRST  and the  following  two functions
        work on the form of exp which is displayed  not the
        form  which is  typed  on input.   If  the variable
        INFLAG  [FALSE]  is  set  to  TRUE  however,  these
        functions will  look at the  internal form  of exp.
        Note that the simplifier re-orders expressions (see
        4.3).  Thus FIRST(X+Y) will be X if INFLAG  is TRUE
        and Y  if INFLAG is  FALSE.  (FIRST(Y+X)  gives the
        same results).


    &REST(exp,  n) yields  exp  with its  first  n elements
        removed if n is  positive and its last  -n elements
        removed if  n is  negative.  If  n is  1 it  may be
        omitted.   Exp  may  be a  list,  matrix,  or other
        expression.


    &LAST(exp) yields  the last  part (term,  row, element,
        etc.) of the exp.


    &DELETE(exp1,  exp2)  removes all  occurrences  of exp1
        from exp2.  Exp1 may be a term of exp2 (if it  is a
        sum) or a factor of exp2 (if it is a product).

        (C1)  DELETE(SIN(X),X+SIN(X)+Y);

        (D1)               Y + X



    &LENGTH(exp) gives the number of parts in  the internal
        form  of  exp.  For  lists  this is  the  number of
        elements, for  matrices it is  the number  of rows,
        and for  sums it is  the number of  terms.  However
        for products it may not always yield the  number of
        factors that would be displayed because of the fact
        that -E is  represented internally as -1*E  and A/B
        is represented internally by A*B^(-1).


    &NTERMS(exp) gives the numbers of terms that  exp would
        have  if  it   were  fully  expanded  out   and  no
        cancellations or combinatons of terms occured. Note
        that expressions like SIN(E), SQRT(E), EXP(E), etc.



        count as just one term regardless of how many terms
        E has (if it is a sum).


    &NROOTS(poly, low, high) finds the number of real roots
        of the real univariate polynomial poly in the half-
        open  interval  (low,high].  The  endpoints  of the
        interval  may  also  be  MINF,INF  respectively for
        minus infinity  and plus  infinity.  The  method of
        Sturm sequences is used.  (see Heindel in [A1].)

        (C1) POLY1:X**10-2*X**4+1/2$
        (C2) NROOTS(POLY1,-6,9.1);
        RAT REPLACED 0.5 BY 1/2 = 0.5
        (D2)                               4



    &REALROOTS(poly, bound) finds all of the real  roots of
        the  real  univariate  polynomial  poly   within  a
        tolerance of  bound which, if  less than  1, causes
        all  integral  roots  to  be  found  exactly.   The
        parameter bound may  be arbitrarily small  in order
        to  achieve   any  desired  accuracy.    The  first
        argument may also be an equation.

        (C1) REALROOTS(X**5+X+1,5.0E-6);

                                            395773
        (E1)                          X = - ------
                                            524288

        (D1)                              [E1]

        (C2) E1,FLOAT;
        (D2)                        X = - 0.75487709

        (C3) PART(C1,1);
                                        5
        (D3)                           X  + X + 1

        (C4) %,D2;
        (D4)                          1.50687992E-6



    &ALLROOTS(poly) finds all the real and complex roots of
        the real polynomial  poly which must  be univariate
        and may be an equation.  The Newton-Bairstow method
        is  used.  After  a root  is  located approximately
        from the reduced polynomial it is refined using the
        original  polynomial.   If  convergence   can't  be
        obtained  the reduced  polynomial is  returned.  In



        this case one may want to  alter ROOTSEPSILON[1.0E-
        7] which is the upper bound of the  relative change
        in  the  coefficients of  the  quadratic polynomial
        divisor in order  for the convergence  criterion to
        be satisfied.  The roots of this quadratic give two
        roots of poly.  Note however that ROOTSEPSILON does
        not give the accuracy  of the roots, but  is merely
        related to it.

            ROOTSQUAD[FALSE] if TRUE will cause ALLROOTS to
        return  the quadratic  polynomials (and  the linear
        one if the degree of poly is odd) which it found to
        have the  same roots as  poly instead  of returning
        the roots themselves.  This is useful for obtaining
        a "complete  factorization over the  floating point
        numbers."

        (C1) (2*X+1)**3=13.5*(X**5+1);

                                    3          5
        (D1)               (2 X + 1)  = 13.5 (X  + 1)

        (C2) ALLROOTS(%);

        (E2)                    X =  - 1.0157555

        (E3)                      X = 0.829675

        (E4)           X =  - 0.96596254 %I - 0.40695972

        (E5)             X = 0.96596254 %I - 0.40695972

        (E6)                        X = 1.0

        (D6)                  [E2, E3, E4, E5, E6]



    &LINSOLVE([exp1, exp2, ...], [var1, var2,  ...]) solves
        the list of  simultaneous linear equations  for the
        list  of   variables.   The   expi  must   each  be
        polynomials in the variables and may be equations.

            If  GLOBALSOLVE[FALSE]  is  set  to  TRUE  then
        variables which are SOLVEd  for will be set  to the
        solution of the set of simultaneous equations.

            BACKSUBST[TRUE]  if set  to FALSE  will prevent
        back  substitution  after the  equations  have been
        triangularized.  This may be necessary in  very big
        problems  where back  substitution would  cause the
        storage capacity to be exceeded.

        (C1) X+Z=Y$



        (C2) 2*A*X-Y=2*A**2$

        (C3) Y-2*Z=2$

        C4) LINSOLVE([D1,D2,D3],[X,Y,Z]),GLOBALSOLVE:TRUE;
        SOLUTION

        (E4)                            X : A + 1

        (E5)                             Y : 2 A

        (E6)                            Z : A - 1

        (D6)                          [E4, E5, E6]


    &ALGSYS([exp1,  exp2, ...],  [var1, var2,  ...]) solves
        the list of simultaneous polynomials  or polynomial
        equations (which can be non-linear) for the list of
        variables.  The symbols %R1, %R2, etc. will be used
        to represent  arbitrary parameters when  needed for
        the solution.

            The method is as follows:

            If  the number  of  variables is  less  than or
        equal to the number of equations:

            (1)   First  the   equations  are   checked  to
        determine  if  one  of  them  is  linear   in  some
        variable.   If so  the equation  is solved  for the
        variable  and the  result is  substituted  into the
        other equations.

            (2)  When this  process can  no longer  be done
        then gcds of successive pairs of the  equations are
        taken in order to try to obtain  additional simpler
        systems.

            (3) When this  stage is finished an  attempt is
        made  to factor  the  equations in  order  again to
        obtain additional simpler systems.

            (4) Finally resultants of  successive equations
        are taken eliminating some variable.  When a single
        irreducible  equation  is  left  then  REALROOTS is
        called on it  if it is univariate,  otherwise SOLVE
        is called.  The user should realize that  SOLVE may
        not be able to produce a solution or if it does the
        solution  may  be  a  very  large  expression  (see
        below).

            In  the  process  described  above   ALGSYS  is
        entered recursively if necessary.



            If there are more variables than equations then
        the  setting  of  the  variable  GRINDSWITCH[FALSE]
        determines what procedure is used:

            If  it  is TRUE  then  the  procedure described
        above will be used but SOLVE rather  than REALROOTS
        will be invoked  since some of the  extra variables
        will  be regarded  as parameters.   If it  is FALSE
        then  the user  will  be given  the  opportunity to
        substitute  numerical   values  for  some   of  the
        variables, to solve  the equations in terms  of the
        extra variables, or  to obtain a reduced  system of
        equations.  The reduced systems can be solved later
        using the function BAKSOLVE (see below).  If ALGSYS
        produces  a  solution which  has  fewer significant
        digits than required, the user can change the value
        of ALGEPSILON[10**8] to a higher value.

        (C1) X+Z-Y$

        (C2) X*Y+B-A^2$

        (C3) X^2+Z-1$

        (C4) ALGSYS([D1,D2,D3],[X,Y,Z]);
        UNDETERMINED PARAMETER(S) IN THE SYSTEM :  [A, B]

        REDUCED SYSTEM(S):

        SUBSYSTEM 1:

        (E4)                            Z - Y + X
                                                  2
        (E5)                           X Y + B - A

                                             2
        (E6)                            Z + X  - 1
                                            2        2
        (E7)                       - Y Z + Y  + B - A
                                2                    2
        (E8)                   Z  + (- 2 Y + 1) Z + Y  - 1

              3               2           2
        (E9) Z  + (- 2 B + 2 A  - 2) Z + B

                                2           4      2
                        + (- 2 A  + 2) B + A  - 2 A  + 1

        (E10)                 [[E4, E5, E6], [E7, E8], [E9]]

        THE FOLLOWING OPTIONS ARE AVAILABLE:
          (1) TYPE "SUBST;" TO SUBSTITUTE NUMERICAL VALUE(S) FOR
              THE PARAMETER(S) AND SOLVE THE SYSTEM(S) AGAIN.
          (2) TYPE THE NUMBER N ("N;"), CORRESPONDING TO THE



              N(TH) SUBSYSTEM, OR "ALL;" SO THAT THE N(TH) OR
              ALL OF THE SUBSYSTEM(S) WILL BE GROUND OUT.
          (3) OTHERWISE TYPE "QUIT;".

        SUBST;

        WHAT IS THE VALUE OF THE UNDETERMINED PARAMETER A ?
        1;


        WHAT IS THE VALUE OF THE UNDETERMINED PARAMETER B ?
        7;


        SOLUTION TO SUBSYSTEM 1:

        (E11)                          X = 2.4288299

        (E12)                        Y = - 2.47032574

        (E13)                         Z = - 4.8991552

        (E14)                        [[E11, E12, E13]]




    &BAKSOLVE(eqlist, varlist)  solves a reduced  system of
        equations  such  as that  generated  by  ALGSYS (if
        GRINDSWITCH is FALSE).   Eqlist is a list  of lists
        of equations.  Varlist is a list of variables to be
        solved  for  in  the same  order  as  was  given to
        ALGSYS.  The  last list of  equations in  eqlist is
        solved  simultaneously for  some variable,  this is
        substituted  into   the  equations  and   the  next
        variable is solved for, etc.


    &SOLVE(exp, var) solves the algebraic equation  exp for
        the  variable var  and returns  a list  of solution
        equations in var.  If exp is not an equation, it is
        assumed  to be  an expression  to be  set  equal to
        zero.  Var may be a function (e.g. F(X)),  or other
        non-atomic expression except  a sum or  product. It
        may be omitted  if exp contains only  one variable.
        Exp may be  a rational expression, and  may contain
        trigonometric functions, exponentials, etc.
        The following method is used:

            Let E be the expression and X be  the variable.
        If E is linear in X then it is trivially solved for
        X.  Otherwise if E is of the form A*X**N+B then the
        result  is  (-B/A)**(1/N) times  the  Nth  roots of
        unity.



            If E  is not linear  in X then  the gcd  of the
        exponents of  X in  E (say N)  is divided  into the
        exponents  and  the multiplicity  of  the  roots is
        multiplied by N.  Then SOLVE is called again on the
        result.

            If E  factors then SOLVE  is called on  each of
        the factors.  Finally SOLVE will use the quadratic,
        cubic, or quartic formulas where necessary.

            In the  case where  E is  a polynomial  in some
        function  of the  variable  to be  solved  for, say
        F(X), then  it is first  solved for F(X)  (call the
        result C), then  the equation F(X)=C can  be solved
        for X  provided the  inverse of  the function  F is
        known.

            BREAKUP[TRUE]  if  FALSE  will  cause  SOLVE to
        express the solutions of cubic or quartic equations
        as  single expressions  rather than  as made  up of
        several common subexpressions which is the default.

            MULTIPLICITIES[FALSE] - will  be set to  a list
        of the  multiplicities of the  individual solutions
        returned by SOLVE, REALROOTS, or ALLROOTS.

            SOLVEFACTORS[TRUE] -  if FALSE then  SOLVE will
        not  try  to  factor  the  expression.   The  FALSE
        setting  may  be   desired  in  some   cases  where
        factoring is not necessary.

            SOLVERADCAN[FALSE]  - if  TRUE then  SOLVE will
        use RADCAN  which will make  SOLVE slower  but will
        allow certain problems containing  exponentials and
        logs to be solved.


    &SOLVE([eq1, ..., eqn], [v1, ..., vn]) solves  a system
        of simultaneous  (linear or  non-linear) polynomial
        equations by calling LINSOLVE or ALGSYS and returns
        a list of the solution lists in the  variables.  In
        the  case of  LINSOLVE  this list  would  contain a
        single list  of solutions.  It  takes two  lists as
        arguments.   The   first   list   (eqi,  i=1,...,n)
        represents the equations  to be solved;  the second
        list is  a list of  the unknowns to  be determined.
        If the total  number of variables in  the equations
        is  equal to  the number  of equations,  the second
        argument-list may  be omitted.  For  linear systems
        if  the  given equations  are  not  compatible, the
        message  INCONSISTENT  will  be  displayed;  if  no
        unique  solution  exists,  then  SINGULAR  will  be
        displayed unless  the variable  SINGSOLVE[FALSE] is



        TRUE  in which  case  the solution  is  returned in
        terms of parameters (see ALGSYS).

        (C1) SOLVE(ASIN(COS(3*X))*(F(X)-1),X);
        SOLUTION

                                            %PI
        (E1)                            X = ---
                                             6
        THE ROOTS OF

        (E2)                            F(X) = 1
        (D2)                            [E1, E2]

        (C3) SOLVERADCAN:TRUE$
        (C4) SOLVE(5**F(X)=125,F(X));
        (D4)                           F(X) = 3

        (C5) [4*X**2-Y**2=12,X*Y-X=2]

                                  2    2
        (D5)                  [4 X  - Y  = 12, X Y - X = 2]

        (C6) SOLVE(D5,[X,Y]);

        (D6)  [[Y =  - 0.15356758,

                X =  - 1.733752], [Y = 2.0, X = 2.0]]

        (C7) SOLVE(X^3+A*X+1,X);

                                                   3
                                          4 A  + 27
                                     SQRT(---------)
                                              3
        (E7)                         ---------------
                                            6

                                             1 1/3
        (E8)                           (E7 - -)
                                             2
        SOLUTION

                                           %I SQRT(3)   1
                                          (---------- - -) A
                     %I SQRT(3)   1            2        2
        (E9) X = ( - ---------- - -) E8 - ------------------
                         2        2              3 E8

                                           %I SQRT(3)   1
                                       ( - ---------- - -) A
                   %I SQRT(3)   1               2       2
        (E10) X = (---------- - -) E8 - ---------------------
                       2        2               3 E8



                                                A
        (E11)                         X = E8 - ----
                                               3 E8

        (D11)                         [E9, E10, E11]


    &ENTERMATRIX(m, n) allows one to enter a matrix element
        by element with MACSYMA requesting values  for each
        of the m*n entries.

        (C1) ENTERMATRIX(2,1);

        ROW 1 COLUMN 1  X+Y/2;

        ROW 2 COLUMN 1  34;

        MATRIX-ENTERED
                                        [ Y     ]
                                        [ - + X ]
        (D1)                            [ 2     ]
                                        [       ]
                                        [   34  ]



    &MATRIX(row1, ...,  rown) defines a  rectangular matrix
        with the indicated rows.  Each row has the  form of
        a list of  expressions, e.g. [A,  X**2, Y, 0]  is a
        list of 4 elements.


    &GENMATRIX(array, i2,  j2, i1,  j1) generates  a matrix
        from  the array  using array(i1,j1)  for  the first
        (upper-left) element and array(i2,j2) for  the last
        (lower-right) element of the matrix.  If j1=i1 then
        j1 may be  omitted. If j1=i1=1  then i1 and  j1 may
        both be omitted. If a selected element of the array
        doesn't exist a symbolic one will be used.

        (C1) H[I,J]:=1/(I+J-1)$

        (C2) GENMATRIX(H,3,3);
                                   [   1  1]
                                   [1  -  -]
                                   [   2  3]
                                   [       ]
                                   [1  1  1]
        (D2)                       [-  -  -]
                                   [2  3  4]
                                   [       ]
                                   [1  1  1]
                                   [-  -  -]
                                   [3  4  5]



    &COPYMATRIX(M) creates a copy of the matrix M.  This is
        the only way to make a copy aside from recreating M
        elementwise.  Copying a  matrix may be  useful when
        SETELMX is used (see below).


    &COPYLIST(L) creates a copy of the list L.


    &ADDROW(M,l) appends the row  given by the list  l onto
        the matrix M.


    &IDENT(n) produces an n by n identity matrix.


    &DIAGMATRIX(n, x) returns  a diagonal matrix of  size n
        by n with the diagonal elements all x.  An identity
        matrix is  created by  DIAGMATRIX(n,1), or  one may
        use IDENT(n).


    &EMATRIX(m, n, x,  i, j) will create  an m by  n matrix
        all of whose elements  are zero except for  the i,j
        element which is x.


    &MATRIXMAP(fn, M)  will map the  function fn  onto each
        element of the matrix M.


    &SETELMX(x, i, j, M) changes the i,j element of M to x.
        The altered matrix  is returned as the  value.  The
        notation M[i,j]:x may also be used, altering M in a
        similar manner, but returning x as the value.


    &COEFMATRIX([eq1,  ...], [var1,  ...])  the coefficient
        matrix for the variables var1,... of the  system of
        linear equations eq1,...


    &AUGCOEFMATRIX([eq1, ...],  [var1, ...])  the augmented
        coefficient  matrix for  the variables  var1,... of
        the system  of linear  equations eq1,....   This is
        the coefficient matrix  with a column  adjoined for
        the constant terms in each equation (i.e. those not
        dependent upon var1,...).

        (C1) [2*X-(A-1)*Y=5*B,A*X+B*Y+C=0]$

        (C2) AUGCOEFMATRIX(%,[X,Y]);



                                [2  1 - A  5 B ]
        (D2)                    [              ]
                                [A    B     - C]



    &COL(M,i)  gives  a matrix  of  the ith  column  of the
        matrix M.


    &ROW(M, i) gives a matrix of the ith row of matrix M.


    &SUBMATRIX(m1, ...,  M, n1, ...)  creates a  new matrix
        composed of the matrix M with rows mi  deleted, and
        columns ni deleted.


    &MINOR(M, i, j) computes the i,j minor of the matrix M.
        That is, M with row i and column j removed.


    &TRANSPOSE(M) produces the transpose of M.


    &ECHELON(M) produces the echelon form of M.  That is, M
        with elementary row operations performed on it such
        that the first non-zero element in each row  in the
        resulting matrix is  a one and the  column elements
        under the first one in each row are all zero.

        (C3) ECHELON(D2);     (D2 is as above)

                         [      A - 1        5 B      ]
                         [1   - -----        ---      ]
                         [        2           2       ]
        (D3)             [                            ]
                         [                2 C + 5 A B ]
                         [0     1       - ------------]
                         [                       2    ]
                         [                2 B + A  - A]



    &TRIANGULARIZE(M) produces the upper triangular form of
        the matrix M which needn't be square.

        (C4) TRIANGULARIZE(D2);

                       [2     - A + 1         5 B      ]
        (D4)           [                               ]
                       [          2                    ]
                       [0  2 B + A  - A   - 2 C - 5 A B]



    &RANK(M) computes the rank  of the matrix M.   That is,
        the    order    of    the    largest   non-singular
        subdeterminant of M.

        (C5) RANK(D2);
        (D5)                            2


    &DETERMINANT(M)  computes  the determinant  of  M  by a
        method similar  to Gaussian elimination.   The form
        of  the  result  depends upon  the  setting  of the
        switch  RATMX  (see  below).   There  is  a special
        routine  for  dealing  with  sparse  determininants
        which  can   be  used   by  setting   the  switches
        RATMX:TRUE and SPARSE:TRUE.


    &NEWDET(M,n)  also computes  the determinant  of  M but
        uses  the  Johnson-Gentleman  tree  minor algorithm
        [Ge1].  M  may be  the name of  a matrix  or array.
        The argument n is the order; it is optional if M is
        a matrix.


    &CHARPOLY(M,    var)   computes    the   characteristic
        polynomial  for M  with respect  to var.   That is,
        DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).

        (C2) A:MATRIX([3,1],[2,4]);
                                         [3  1]
        (D2)                             [    ]
                                         [2  4]

        (C3) CHARPOLY(A,LAMBDA);
                                       2
        (D3)                     LAMBDA  - 7 LAMBDA + 10

        (C4) SOLVE(%);
        SOLUTION

        (E4)                           LAMBDA = 2

        (E5)                           LAMBDA = 5

        (D5)                            [E4, E5]

        (C6) X:MATRIX([X1],[X2]);
                                          [X1]
        (D6)                              [  ]
                                          [X2]

        (C7) A.X-LAMBDA*X,E5;



                                     [ X2 - 2 X1  ]
        (D7)                         [            ]
                                     [ - X2 + 2 X1]

        (C8)  D7[1,1]=0;
        (D8)                          X2 - 2 X1 = 0

        (C9) X1**2+X2**2=1;
                                        2     2
        (D9)                          X2  + X1  = 1

        (C10) SOLVE([D8,D9],[X1,X2]);

        (D10) [[X2 =  - 0.89442714, X1 =  - 0.44721357],

               [X2 = 0.89442714, X1 = 0.44721357]]



                   Options Relating to Matrices

        Note: MX stands for Matrix and SC stands for Scalar


            By  resetting the  options LMXCHAR  and RMXCHAR
        (with the defaults [ and ] respectively),  the user
        can specify the  delimiters used in the  display of
        matrices.

            RATMX[FALSE] - if FALSE will  cause determinant
        and     matrix    addition,     subtraction,    and
        multiplication    to    be    performed    in   the
        representation  of  the  matrix  elements  and will
        cause the  result of matrix  inverse to be  left in
        the representation of  the matrix elements.   If it
        is TRUE, the  4 operations mentioned above  will be
        performed  in CRE  form  and the  result  of matrix
        inverse will  be in CRE  form.  Note that  this may
        cause the elements to be expanded (depending on the
        setting  of  RATFAC)  which  might  not  always  be
        desired.

            LISTARITH[TRUE]   -   if   FALSE   causes   any
        arithmetic operations with lists to  be suppressed;
        when  TRUE, list-matrix  operations  are contagious
        causing lists to be converted to  matrices yielding
        a result which is always a matrix.   However, list-
        list operations should return lists.

            DETOUT[FALSE]   -  if   TRUE  will   cause  the
        determinant of a  matrix whose inverse  is computed
        to be kept outside of the inverse.  For this switch
        to have an  effect DOALLMXOPS and  DOSCMXOPS should



        be  FALSE (see  below).  Alternatively  this switch
        can be given to EV which causes the other two to be
        set correctly.

            DOALLMXOPS[TRUE]  -  if  TRUE   all  operations
        relating  to matrices  are carried  out.  If  it is
        FALSE then  the setting  of the  following switches
        govern which operations are performed.

            DOMXMXOPS[FALSE]  -  if TRUE  then  all matrix-
        matrix  or matrix-list  operations are  carried out
        (but not scalar-matrix operations); if  this switch
        is FALSE they are not.

            DOSCMXOPS[FALSE] -  if TRUE  then scalar-matrix
        operations are performed.

            DOSCMXPLUS[FALSE] - if TRUE will cause SCALAR +
        MATRIX to give a matrix answer.

            SCALARMATRIX[TRUE]  - if  TRUE causes  a square
        matrix of dimension one (when produced as  a result
        of a computation) to be converted to a scalar (i.e.
        its only element).

            SPARSE[FALSE] - if TRUE and if  RATMX:TRUE then
        DETERMINANT will use special routines for computing
        sparse determinants.


    &MAKENONSCALAR(a1,a2,...,an)  is  used  to  declare any
        number  of  atoms  ai  to  be  nonscalar.   Soon  a
        capability  will  exist  for  declaring  functions,
        arrays to  be scalar or  nonscalar so that,  say, a
        scalar  function  of   a  nonscalar  arg   will  be
        considered scalar.


    &RATVARS(var1, var2, ...,  varn) forms its  n arguments
        into a  list in which  the rightmost  variable varn
        will  be  the  main  variable  of  future  rational
        expressions  in  which  it  occurs,  and  the other
        variables will follow  in sequence.  If  a variable
        is missing from the RATVARS list, it will  be given
        lower priority than the leftmost variable var1. The
        arguments  to RATVARS  can be  either  variables or
        non-rational functions (e.g. SIN(X)).
        The  variable RATVARS  is a  list of  the arguments
        which have been given to this function.


    &RAT(exp,  v1, ...,  vn) converts  exp to  CRE  form by
        expanding  and combining  all terms  over  a common



        denominator and cancelling out the  greatest common
        divisor of the numerator and denominator as well as
        converting  floating  point  numbers   to  rational
        numbers within  a tolerance  of RATEPSILON[2.0E-8].
        The   variables  are   ordered  according   to  the
        v1,...,vn as  in RATVARS,  if these  are specified.
        RAT  does  not generally  simplify  functions other
        than  + ,  - ,  * ,  / ,  and exponentiation  to an
        integer power and  it does not deal  with equations
        whereas RATSIMP does handle these cases.  Note that
        atoms (numbers and names)  in CRE form are  not the
        same as they are in the general form.  Thus RAT(X)-
        X results in RAT(0) which has a  different internal
        representation than 0.

            RATFAC[FALSE]  when  TRUE  invokes  a partially
        factored form for CRE rational expressions.  During
        rational operations the expression is maintained as
        fully factored as  possible without an  actual call
        to  the factor  package.  This  should  always save
        space and may save some time in  some computations.
        The  numerator  and  denominator  are   still  made
        relatively  prime  (e.g.  RAT((X^2  -1)^4/(X+1)^2);
        yields  (X-1)^4*(X+1)^2),  but  the  factors within
        each part may not be relatively prime.

            RATPRINT[TRUE] if FALSE suppresses the printout
        of the message informing the user of the conversion
        of floating point numbers to rational numbers.

            KEEPFLOAT[FALSE]  if  TRUE   prevents  floating
        point  numbers  from  being  converted  to rational
        numbers.

            (Also see the RATEXPAND and  RATSIMP functions.
        sec. 6.1.1)

        (C1) ((X-2*Y)**4/(X**2-4*Y**2)**2+1)*(Y+A)*(2*Y+X)
                /(4*Y**2+X**2);
                                                   4
                                          (X - 2 Y)
                      (Y + A) (2 Y + X) (------------ + 1)
                                           2      2 2
                                         (X  - 4 Y )
        (D1)          ------------------------------------
                                      2    2
                                   4 Y  + X

        (C2) RAT(%,Y,A,X);
                                    2 A + 2 Y
        (D2)/R/                     ---------
                                     X + 2 Y



    &RATDISREP(exp) changes its  argument from CRE  form to
        general form.  This is sometimes convenient  if one
        wishes  to stop  the "contagion",  or  use rational
        functions in non-rational contexts (see the example
        at  the  beginning  of  this  section).   Most  CRE
        functions  will  work  on  either  CRE  or  non-CRE
        expressions,  but  the answers  may  take different
        forms.   If RATDISREP  is  given a  non-CRE  for an
        argument, it returns its argument unchanged.


    &TOTALDISREP(exp) converts  every subexpression  of exp
        from CRE to general form.  If exp is itself  in CRE
        form then this is identical to RATDISREP but if not
        then  RATDISREP  would return  exp  unchanged while
        TOTALDISREP  would  "totally  disrep"  it.  This is
        useful   for   ratdisrepping    expressions   e.g.,
        equations,  lists, matrices,  etc. which  have some
        subexpressions in CRE form.


    &NUM(exp)  obtains   the  numerator  of   the  rational
        expression exp.


    &DENOM(exp)  returns  the denominator  of  the rational
        expression exp.


    &RATNUMER(exp)  obtains the  numerator of  the rational
        expression exp.  If exp is in general form then the
        NUM  function should  be used  instead,  unless one
        wishes to get a CRE result.


    &RATDENOM(exp) obtains the denominator of  the rational
        expression exp.  If exp is in general form then the
        DENOM function should  be used instead,  unless one
        wishes to get a CRE result.


    &RATWEIGHT(v1, w1, ..., vn, wn) assigns a weight  of wi
        to  the  variable vi.   This  causes a  term  to be
        replaced by  0 if its  weight exceeds the  value of
        the variable RATWTLVL [default is FALSE which means
        no truncation].  The weight of a term is the sum of
        the products  of the  weight of  a variable  in the
        term  times   its  power.    Thus  the   weight  of
        3*v1**2*v2 is 2*w1+w2.  This truncation occurs only
        when  multiplying  or exponentiating  CRE  forms of
        expressions.


        (C5) RATWEIGHT(A,1,B,1);



        (D5)                         [[B, 1], [A, 1]]

        (C6) EXP1:RAT(A+B+1)$

        (C7) %**2;
                              2                  2
        (D7)/R/              B  + (2 A + 2) B + A  + 2 A + 1

        (C8) RATWTLVL:1$

        (C9) EXP1**2;
        (D9)/R/                       2 B + 2 A + 1


    &HORNER(exp, var)  will convert  exp into  a rearranged
        representation as  in Horner's  rule, using  var as
        the main variable if it is specified.  Var may also
        be omitted in which  case the main variable  of the
        CRE form of exp is used.  HORNER sometimes improves
        stability if expr  is to be  numerically evaluated.
        It is  also useful if  MACSYMA is used  to generate
        programs  to be  run  in FORTRAN  (see  STRINGOUT -
        sect. 6.10.3)

        (C1) 1.0E-20*X^2-5.5*X+5.2E20;
                                        2
        (D1)                   1.0E-20 X  - 5.5 X + 5.2E+20

        (C2) HORNER(%,X),KEEPFLOAT:TRUE;
        (D2)                  X (1.0E-20 X - 5.5) + 5.2E+20

        (C3) D1,X=1.0E20;
        ARITHMETIC OVERFLOW

        (C4) D2,X=1.0E20;
        (D4)                          6.9999999E+19



    &FASTTIMES(p1, p2) multiplies the polynomials p1 and p2
        by using a special algorithm for  multiplication of
        polynomials.  They should  be  multivariate, dense,
        and nearly the same size.  Classical multiplication
        is  of order  N*M where  N and  M are  the degrees.
        FASTTIMES is of order MAX(N,M)**1.585.

            The  rest  of  the  functions  in  this section
        return their results in general representation only
        if  all of  their principal  arguments are  in that
        form.  If any  of their principal arguments  are in
        CRE form then the result is returned in CRE form.



    &DIVIDE(p1, p2, var1, ..., varn) computes  the quotient
        and remainder of  the polynomial p1 divided  by the
        polynomial p2, in a main polynomial variable, varn.
        The other variables are as in the RATVARS function.
        The result  is a  list whose  first element  is the
        quotient and whose second element is the remainder.

        (C1) DIVIDE(X+Y,X-Y,X);
        (D1)                        [1, 2 Y]

        (C2) DIVIDE(X+Y,X-Y);
        (D2)                      [ - 1, 2 X]

        (Note that Y is the main variable in C2)



    &QUOTIENT(p1, p2, var1,  ...) computes the  quotient of
        the polynomial p1 divided by the polynomial p2.


    &REMAINDER(p1, p2, var1, ...) computes the remainder of
        the polynomial p1 divided by the polynomial p2.


    &CONTENT(p1,  var1,  ..., varn)  returns  a  list whose
        first element is the greatest common divisor of the
        coefficients of the  terms of the polynomial  p1 in
        the variable varn  (this is the content)  and whose
        second element is the polynomial p1 divided  by the
        content.

        (C1) CONTENT(2*X*Y+4*X**2*Y**2,Y);

        (D1)            [2*X, 2*X*Y**2+Y].



    &GCD(p1, p2,  var1, ...)  computes the  greatest common
        divisor of  p1 and p2.   The EZGCD  algorithm [Mo6]
        will    be    employed    unless    the    variable
        EZGCDSWITCH[TRUE]  is  FALSE,  in  which  case  the
        setting of the variable GCDSWITCH will govern which
        algorithm  is  to be  used.   Many  functions (e.g.
        RATSIMP,  FACTOR,  etc.) cause  gcd's  to  be taken
        implicitly.

            If  GCDSWITCH[FALSE] is  TRUE then  the modular
        algorithm is employed [Br1] rather than the Collins
        reduced prs algorithm.

            If  TAKEGCD[TRUE]  is FALSE,  MACSYMA  will not
        cancel the gcd of the numerator and  denominator of



        a rational expression in CRE form.  This  is useful
        when gcds  are unnecessary  and attempting  to take
        them would be time consuming.


    &EZGCD(p1, p2, ...) gives a list whose first element is
        the g.c.d  of the  polynomials p1,p2,...  and whose
        remaining elements  are the polynomials  divided by
        the g.c.d.  This always uses the EZGCD algorithm.


    &MOD(p)  converts  the   polynomial  p  to   a  modular
        representation with respect to the  current modulus
        which is the value of the variable MODULUS.

            If MODULUS[FALSE] is set to a positive prime p,
        then  all  arithmetic  in  the   rational  function
        routines  will  be  done  modulo  p.   That  is all
        integers  will  be  reduced  to  less  than  p/2 in
        absolute  value  (if  p=2  then  all  integers  are
        reduced  to  1  or  0).   This  is  the  so  called
        "balanced" modulus system, e.g.  N MOD 5 =  -2, -1,
        0, 1, or 2.


    &RESULTANT(p1, p2, var)  computes the resultant  of the
        two polynomials p1 and p2, eliminating the variable
        var.   The  resultant  is  a  determinant   of  the
        coefficients of var in p1 and p2 which  equals zero
        if and only if p1 and p2 have a non-constant factor
        in common.

            MODRESULT[FALSE]  if  TRUE  causes  the modular
        resultant  algorithm  to  be  used,  otherwise  the
        reduced (which  is the default)  will be  used (see
        [Co1]).

        (C1)    RESULTANT(A*Y+X**2+1,Y**2+X*Y+B,X);

                     4      3              2    2
        (D1)        Y  + A Y  + (2 B + 1) Y  + B



    &RATDIFF(exp,   var)   differentiates    the   rational
        expression   exp  (which   must  be   a   ratio  of
        polynomials or  a polynomial  in the  variable var)
        with respect to var.  For rational expressions this
        is much  faster than DIFF.   The result is  left in
        CRE form.  However, RATDIFF should  not be  used on
        factored  CRE  forms;  use  DIFF  instead  for such
        expressions.

        (C1) (4*X**3+10*X-11)/(X**5+5);



                                                 3
                                              4 X  + 10 X - 11
        (D1)                                  ----------------
                                                    5
                                                   X  + 5

        (C2) MODULUS:3$

        (C3) MOD(D1);
                                        2
                                       X  + X - 1
        (D3)                      --------------------
                                   4    3    2
                                  X  + X  + X  + X + 1

        (C4) RATDIFF(D1,X);
                                  5    4    3
                                 X  - X  - X  + X - 1
        (D4)                ------------------------------
                             8    7    5    4    3
                            X  - X  + X  - X  + X  - X + 1


    &TELLRAT(poly) adds to  the ring of  algebraic integers
        known to MACSYMA, the element which is the solution
        of  the univariate,  monic polynomial  with integer
        coefficients.  MACSYMA initially knows about %I and
        all roots of integers.

            ALGEBRAIC[FALSE] must be  set to TRUE  in order
        for the simplfication of algebraic integers to take
        effect.

            TELLRATLIST -  is a  list of  polynomials which
        were given to the TELLRAT function.

        (C1) ALGEBRAIC:TRUE$

        (C2) RATDIS(E):=RATDISREP(RAT(E))$

        (C3) 10*(1+%I)/(3^(1/3)+%I);
                                       10 (%I + 1)
        (D3)                           -----------
                                         1/3
                                        3    + %I

        (C4) RATDIS(%);
                           2/3               1/3
        (D4)   (4 %I + 2) 3    + (4 - 2 %I) 3    - 4 %I - 2




        (C5) TELLRAT(A^2+A+1)$

        (C6) A/(SQRT(2)+SQRT(3))+1/(A*SQRT(2)-1);
                                  1                 A
        (D6)                ------------- + -----------------
                            SQRT(2) A - 1   SQRT(3) + SQRT(2)

        (C7) RATDIS(%);
              (7 SQRT(3) - 10 SQRT(2) + 2) A - 2 SQRT(2) - 1
        (D7)  ----------------------------------------------
                                    7



    &TAYLOR(exp,[var1,pt1,ord1],[var2,pt2,ord2],...)
        returns a truncated  power series in  the variables
        vari about the  points pti, truncated at  ordi. For
        further details see .

            PSEXPAND[FALSE]  if  TRUE  will  cause extended
        rational  function  expressions  to  display  fully
        expanded.  (RATEXPAND  will  also  cause  this.) If
        FALSE, multivariate  expressions will  be displayed
        just  as  in  the  rational  function  package.  If
        PSEXPAND:MULTI,  then  terms  with  the  same total
        degree in the variables are grouped together.


    &SRRAT(exp) converts exp from extended rational form to
        CRE  form,  i.e.  it  is  like  RAT(RATDISREP(exp))
        although much faster.



        (C1)                     TAYLOR(1 + X, [X, 0, 3]);

        (D1)/R/                         1 + X + . . .

        (C2) 1/%;
                                            2    3
        (D2)/R/                    1 - X + X  - X  + . . .

        (C3) TAYLOR(1 + X + Y + Z, [X, 0, 3], [Y, 1, 2],
                [Z, 2, 1]);

        (D3)/R/               4 + (Z - 2) + (Y - 1) + X + . . .


        (C4) 1/%;




                1   Z - 2      1    Z - 2
        (D4)/R/ - - ----- + (- -- + ----- + . . .) (Y - 1)
                4    16        16    32

            1    3 (Z - 2)                 2
         + (-- - --------- + . . .) (Y - 1)
            64      256

              1    Z - 2    1    3 (Z - 2)
         + (- -- + ----- + (-- - --------- + . . .) (Y - 1)
              16    32      32      128

               3    3 (Z - 2)                 2
         + (- --- + --------- + . . .) (Y - 1)  + . . .) X
              256      256

            1    3 (Z - 2)       3    3 (Z - 2)
         + (-- - --------- + (- --- + --------- + . . .) (Y - 1)
            64      256         256      256

             3    15 (Z - 2)                 2           2
         + (--- - ---------- + . . .) (Y - 1)  + . . .) X
            512      2048

               1    Z - 2     1    5 (Z - 2)
         + (- --- + ----- + (--- - --------- + . . .) (Y - 1)
              256    256     256     1024

               5     15 (Z - 2)                 2           3
         + (- ---- + ---------- + . . .) (Y - 1)  + . . .) X
              2048      4096

         + . . .

        (C5) TAYLOR(1 + X + Y + Z, [X, 0, 3], [Y, 0, 3],
                [Z, 0, 3]);

        (D5)/R/             1 + Z + Y + X + . . .


        (C6) 1/%;



                         2    3
        (D6)/R/ 1 - Z + Z  - Z

                           2      3
         + (- 1 + 2 Z - 3 Z  + 4 Z  + . . .) Y

                         2       3           2
         + (1 - 3 Z + 6 Z  - 10 Z  + . . .) Y

                            2       3           3
         + (- 1 + 4 Z - 10 Z  + 20 Z  + . . .) Y

                           2      3
         + (- 1 + 2 Z - 3 Z  + 4 Z

                          2       3
         + (2 - 6 Z + 12 Z  - 20 Z  + . . .) Y

                             2       3           2
         + (- 3 + 12 Z - 30 Z  + 60 Z  + . . .) Y

                           2        3           3
         + (4 - 20 Z + 60 Z  - 140 Z  + . . .) Y  + . . .) X

                         2       3
         + (1 - 3 Z + 6 Z  - 10 Z

                             2       3
         + (- 3 + 12 Z - 30 Z  + 60 Z  + . . .) Y

                           2        3           2
         + (6 - 30 Z + 90 Z  - 210 Z  + . . .) Y

                               2        3           3
         + (- 10 + 60 Z - 210 Z  + 560 Z  + . . .) Y

                   2
         + . . .) X

                            2       3
         + (- 1 + 4 Z - 10 Z  + 20 Z

                           2        3
         + (4 - 20 Z + 60 Z  - 140 Z  + . . .) Y

                               2        3           2
         + (- 10 + 60 Z - 210 Z  + 560 Z  + . . .) Y

                              2         3           3
         + (20 - 140 Z + 560 Z  - 1680 Z  + . . .) Y

                   3
         + . . .) X  + . . .



    &SUM(exp,  ind, lo,  hi)  performs a  summation  of the
        values of exp  as the index  ind varies from  lo to
        hi.  If  the upper  and lower  limits differ  by an
        integer then each term in the sum is  evaluated and
        added together.  Otherwise the summand is evaluated
        with  the index  of summation  unbound and  (if the
        SIMPSUM [FALSE] is TRUE) the result  is simplified.
        This  simplification  may  sometimes  be   able  to
        produce a closed form.   If SIMPSUM is FALSE  or if
        'SUM is used, the value is a sum noun form which is
        a  representation  of the  sigma  notation  used in
        mathematics.

            Sums may be differentiated,  added, subtracted,
        or  multiplied with  some  automatic simplification
        being performed.

            OUTSUM[TRUE]  if  TRUE  causes  factors  of the
        summand  which  don't  depend  upon  the  index  of
        summation to be moved outside of the sum.

            CAUCHYSUM[FALSE]  when TRUE  causes  the Cauchy
        product to be  used when multiplying  sums together
        rather  than  the  usual  product.   In  the Cauchy
        product  the  index  of the  inner  summation  is a
        function of the index of the outer one  rather than
        varying independently.

            GENINDEX[I]  is the  alphabetic prefix  used to
        generate the next variable of summation.

            GENSUMNUM[0]  is  the  numeric  suffix  used to
        generate the next variable of summation.  If  it is
        set to  FALSE then the  index will consist  only of
        GENINDEX with no numeric suffix.

        (C1) SIMPSUM:TRUE$

        (C2) SUM(I**2+2**I,I,0,N);

                                 3      2
                      N + 1   2 N  + 3 N  + N
        (D2)         2      + --------------- - 1
                                     6

        (C3) SUM(3**(-I),I,1,INF);

                                  1
        (D3)                      -
                                  2

        (C4) SUM(I^2,I,1,4)*SUM(1/I^2,I,1,INF);



                                               2
        (D5)                              5 %PI



    &PRODUCT(exp,  ind, lo,  hi) gives  the product  of the
        values of exp  as the index  ind varies from  lo to
        hi.  The evaluation is similar to that of  SUM.  No
        simplification  of  products is  available  at this
        time.

        (C1)  PRODUCT(X+I*(I+1)/2,I,1,4);

        (D1)             (X + 1) (X + 3) (X + 6) (X + 10)


    &LIMIT(exp, var,  val, dir) finds  the limit of  exp as
        the real variable var approaches the value val from
        the direction dir.  Dir may have the value PLUS for
        a limit from above,  MINUS for a limit  from below,
        or may be omitted (implying a two-sided limit is to
        be  computed).  For  the method  see  [Wa3].  LIMIT
        uses the  following special symbols:  INF (positive
        infinity) and MINF (negative infinity).   On output
        it may  also use  UND (undefined),  IND (indefinite
        but bounded) and INFINITY (complex infinity).

            LHOSPITALLIM[4] is the maximum number  of times
        L'Hospital's rule is used in LIMIT.   This prevents
        infinite      looping      in       cases      like
        LIMIT(COT(X)/CSC(X),X,0).

            TLIMSWITCH[FALSE]  when  true  will  cause  the
        limit package to use Taylor series when possible.

        (C1) LIMIT(X*LOG(X),X,0,PLUS);

        (D1)                 0

        (C2) LIMIT((1+X)**(1/X),X,0);

        (D2)                 %E

        (C3) LIMIT(%E**X/X,X,INF);

        (D3)                 INF

        (C4) LIMIT(SIN(1/X),X,0);

        (D4)                   IND



    &TLIMIT(exp,var,val,dir)  is  just  the  function LIMIT
        with TLIMSWITCH set to TRUE.


    &LDEFINT(exp,var,ll,ul) yields the definite integral of
        exp  by  using  LIMIT  to  evaluate  the indefinite
        integral of  exp with respect  to var at  the upper
        limit ul and at the lower limit ll.


    &TLDEFINT(exp,var,ll,ul)    is   just    LDEFINT   with
        TLIMSWITCH set to TRUE.


    &RESIDUE(exp,  var, val)  computes the  residue  in the
        complex  plane  of  the  expression  exp  when  the
        variable var assumes the value val.  The residue is
        the coefficient  of (var-val)**(-1) in  the Laurent
        series for exp.

        (C1) RESIDUE(S/(S**2+A**2),S,A*%I);

                                1
        (D1)                    -
                                2

        (C2) RESIDUE(SIN(A*X)/X**4,X,0);

                                3
                               A
        (D2)                 - --
                               6



    &TAYLOR(exp, var, pt,  pow) expands the  expression exp
        in a truncated Taylor series (or Laurent series, if
        required) in the variable var around the  point pt.
        The terms  through (var-pt)**pow are  generated. If
        exp is of the form f(var)/g(var) and g(var)  has no
        terms  up to  degree pow  then TAYLOR  will  try to
        expand  g(var) up  to degree  2*pow.  If  there are
        still no non-zero  terms TAYLOR will  keep doubling
        the  degree  of  the  expansion  of   g(var)  until
        reaching  pow*2**n  where  n is  the  value  of the
        variable TAYLORDEPTH[3].
        If MAXTAYORDER[FALSE] is  set to TRUE,  then during
        algebraic   manipulation   of   (truncated)  Taylor
        series, TAYLOR will try to retain as many  terms as
        are certain to be correct.

        (C1) TAYLOR(SQRT(1+A*X+SIN(X)),X,0,3);



                                   2             2
                     (A + 1) X   (A  + 2 A + 1) X
        (D1)/R/  1 + --------- - -----------------
                         2               8

                              3      2             3
                          (3 A  + 9 A  + 9 A - 1) X
                        + -------------------------- +  . . .
                                      48

        (C2) %**2;
                                      3
                                     X
        (D2)/R/      1 + (A + 1) X - -- +  . . .
                                     6

        (C3) PRODUCT((X**I+1)**2.5,I,1,INF)/(X**2+1);

                                  INF
                                 /===\
                                  ! !    I     2.5
                                  ! !  (X  + 1)
                                  ! !
                                  ! !
                                 I = 1
        (D3)                     -----------------
                                       2
                                      X  + 1

        (C4) TAYLOR(%,X,0,3),KEEPFLOAT:TRUE;

                                          2           3
        (D4)/R/      1.0 + 2.5 X + 3.375 X  + 6.5625 X  +  . . .

        (C5) TAYLOR(1/LOG(1+X),X,0,3);

                                          2       3
                            1   1   X    X    19 X
        (D5)/R/             - + - - -- + -- - ----- +  . . .
                            X   2   12   24    720



    &EXTEND(exp,var1,new-ord1,var2,new-ord2,...)    extends
        the  Taylor  expansion exp  beyond  some previously
        specified truncation levels for the  variables vari
        to  new truncation  levels new-ordi.  This function
        has the effect of changing the old value of  exp to
        to a new value including the newly added terms.
        If MAXTAYORDER[FALSE] is  set to TRUE,  then during
        algebraic   manipulation   of   (truncated)  Taylor
        series, TAYLOR will try to retain as many  terms as
        are certain to be correct.



    &TAYLOR(exp, var1, pt1, ord1, var2, pt2, ord2, . . .)


    &TAYLOR(exp,[var1,pt1,ord1],[var2,pt2,ord2],...)


    &TAYLOR(exp, [var1, var2, .  . .], pt, ord)  where each
        of pt and ord may be replaced by a list  which will
        correspond to the list of variables.  that  is, the
        nth items on each  of the lists will  be associated
        together.


    &TAYLOR(exp, [x,pt,ord,asymp])  will give  an expansion
        of exp in  negative powers of (x-pt).   The highest
        order term will be


    &DEFTAYLOR(function, exp) allows the user to define the
        Taylor series (about 0) of an arbitrary function of
        one variable  as exp which  may be a  polynomial in
        that variable or which may be given implicitly as a
        power series using the SUM function.


            In order  to display  the information  given to
        DEFTAYLOR one  can use  POWERSERIES(F(X),X,0). (see
        below).

        (C1) DEFTAYLOR(F(X),X**2+SUM(X**I/(2**I*I!**2),
                I,4,INF));
        (D1)                          [F]

        (C2) TAYLOR(%E**SQRT(F(X)),X,0,4);

                             2         3          4
                            X    3073 X    12817 X
        (D2)/R/     1 + X + -- + ------- + -------- +  . . .
                            2     18432     307200



    &POWERSERIES(exp, var,  pt) generates the  general form
        of  the  power  series  expansion  for  exp  in the
        variable var about the  point pt (which may  be INF
        for infinity).   In cases  in which  POWERSERIES is
        unable to expand  exp the TAYLOR function  may give
        the first several terms of the series.

            VERBOSE[FALSE]  - if  TRUE will  cause comments
        about the progress of POWERSERIES to be  printed as
        the execution of it proceeds.

        (C1) VERBOSE:TRUE$



        (C2) POWERSERIES(LOG(SIN(X)/X),X,0);
        CAN'T EXPAND

                            LOG(SIN(X))

        SO WE WILL TRY AGAIN AFTER APPLYING THE RULE:

                                        D
                                     /  -- SIN(X)
                                     [  DX
                       LOG(SIN(X)) = I (---------) DX
                                     ]   SIN(X)
                                     /

        IN FIRST SIMPLIFICATION WE HAVE RETURNED

                                      /
                                      [
                           - LOG(X) + I COT(X) DX
                                      ]
                                      /

                 INF
                \====         I9 - 1  2 I9             2 I9 + 2
                 \      ( - 1)       2     BERN(2 I9) X
        (D2)      >    (---------------------------------------)
                 /                (2 I9 + 2) (2 I9)!
                /====
                I9 = 0



    &TRIGEXPAND(exp, var1, var2, ...) expands trigonometric
        and hyperbolic functions  of sums of angles  and of
        multiple angles occuring in exp with respect to the
        vars or with respect  to all variables if  only the
        first  argument  (i.e.  exp)  is  given.   For best
        results, exp should  be expanded.  To  enhance user
        control  of  simplification,  this  function  first
        expands only sums; a repeated application will then
        expand multiple  angles.  To obtain  full expansion
        into sines and cosines immediately, set  the switch
        TRIGEXPAND:TRUE.

            TRIGEXPAND[FALSE] if  TRUE causes  expansion of
        all expressions containing SINs and  COSs occurring
        subsequently.

            HALFANGLES[FALSE] - if TRUE  causes half-angles
        to be simplified away.

        (C1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;



                                      2           2
        (D1)                     - SIN (X) + 3 COS (X) + X

        (C2) TRIGEXPAND(SIN(10*X+Y),Y);

        (D2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)



    &TRIGREDUCE(exp, var)  combines products and  powers of
        trigonometric and hyperbolic  SINs and COSs  of var
        into those of multiples  of var.  It also  tries to
        eliminate  these  functions  when  they   occur  in
        denominators.  If var is omitted then all variables
        in exp  are used.  Also  see the  POISSIMP function
        sect. 6.14.

        (C4) TRIGREDUCE(D1);
        (D4)                        2 COS(2 X) + X + 1


            The trigonometric simplification  routines will
        use  declared  information  in  some  simple cases.
        Declarations about  variables are used  as follows,
        e.g.


        (C5)     MODEDECLARE(J, INTEGER, E, EVEN, O, ODD)$

        (C6)               SIN(X + (E + 1/2)*%PI)$

        (D6)                      COS(X)

        (C7)               SIN(X + (O + 1/2) %PI)


        (D7)                     - COS(X)



    &COMEXP(exp)   returns    a   list   of    the   common
        subexpressions of exp.


    &OPTIMIZE(exp) returns a  BLOCK which evaluates  to exp
        making use of  common subexpressions.  This  may be
        used to evaluate exp efficiently or to store  it on
        disk  without  having  many  copies  of   the  same
        subexpression. (see 9.4)

        (C1) DIFF(EXP(X^2+Y)/(X+Y),X,2);



                            2            2
                   2   Y + X        Y + X
                4 X  %E         2 %E
        (D1)    ------------- + ----------
                    Y + X         Y + X

                             2            2
                        Y + X        Y + X
                  4 X %E         2 %E
                - ------------ + ----------
                           2             3
                    (Y + X)       (Y + X)

        (C2) OPTIMIZE(%);
                                               2
        (D2) BLOCK([T4, T3, T2, T1, T0], T0 : X , T1 : Y + T0,
                T2 : Y + X,

               1          T1            4 T4 X
          T3 : --, T4 : %E  , RETURN( - ------ + 4 T0 T3 T4
               T2                          2
                                         T2

                            2 T4
                + 2 T3 T4 + ----))
                              3
                            T2



    &LAPLACE(exp, ovar,  lvar) takes the  Laplace transform
        of  exp  with  respect  to  the  variable  ovar and
        transform parameter lvar.  Exp may only involve the
        functions EXP, LOG, SIN, COS, SINH, COSH,  and ERF.
        It  may  also  be  a  linear,  constant coefficient
        differential  equation in  which case  ATVALUE (see
        sect.  6.2.2)  of the  dependent  variable  will be
        used.  These may be supplied either before or after
        the   transform   is  taken.   Since   the  initial
        conditions must  be specified at  zero, if  one has
        boundary conditions imposed elsewhere he can impose
        these  on the  general solution  and  eliminate the
        constants by solving the general solution  for them
        and substituting  their values  back. Exp  may also
        involve    convolution    integrals.     Functional
        relationships  must  be  explicitly  represented in
        order for LAPLACE to  work properly. That is,  if F
        depends on  X and  Y it must  be written  as F(X,Y)
        wherever        F        occurs        as        in
        LAPLACE('DIFF(F(X,Y),X),X,S).



        (C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);

                             A
                         2 %E  (S - 2)
        (D1)            ---------------
                                2     2
                        ((S - 2)  + 1)


    &ILT(exp,  lvar,   ovar)  takes  the   inverse  Laplace
        transform of exp with respect to lvar and parameter
        ovar.   exp must  be a  ratio of  polynomials whose
        denominator has only linear and  quadratic factors.
        By  using the  functions LAPLACE  and  ILT together
        with the SOLVE  or LINSOLVE functions the  user can
        solve a single differential or convolution integral
        equation or a set of them.

        (C1) 'INTEGRATE(SINH(A*X)*F(T-X),X,0,T)+B*F(T)=T**2;

                      T
                     /
                     [                                     2
        (D1)         I (SINH(A X) F(T - X)) DX + B F(T) = T
                     ]
                     /
                     0

        (C2) LAPLACE(%,T,S);

                    A LAPLACE(F(T), T, S)
        (D2)        ---------------------
                            2    2
                           S  - A

                                                  2
                        + B LAPLACE(F(T), T, S) = --
                                                   3
                                                  S

        (C3) LINSOLVE([%],['LAPLACE(F(T),T,S)]);
        SOLUTION

                                                2      2
                                             2 S  - 2 A
        (E3)       LAPLACE(F(T), T, S) = --------------------
                                            5         2     3
                                         B S  + (A - A  B) S

        (D3)                         [E3]

        (C4) ILT(E3,S,T);

        IS  A B (A B - 1)  POSITIVE, NEGATIVE, OR ZERO?



        POS;

                                               2
                               SQRT(A) SQRT(A B  - B) T
                        2 COSH(------------------------)
                                          B
        (D4)  F(T) =  - --------------------------------
                                       A

                      2
                   A T             2
                + ------- + ------------------
                  A B - 1    3  2      2
                            A  B  - 2 A  B + A



    &MINFACTORIAL(exp) examines exp for occurrences  of two
        factorials  which differ  by an  integer.   It then
        turns one  into a polynomial  times the  other.  If
        exp involves  binomial coefficients then  they will
        be converted into ratios of factorials.

        (C1) N!/(N+1)!;
                                            N!
        (D1)                             --------
                                         (N + 1)!

        (C2) MINFACTORIAL(%);
                                             1
        (D2)                               -----
                                           N + 1



    &FACTCOMB(exp)  tries  to combine  the  coefficients of
        factorials in exp with the factorials themselves by
        converting, for example, (N+1)*N! into (N+1)!.

            SUMSPLITFACT[TRUE] if  set to FALSE  will cause
        MINFACTORIAL to be applied after a FACTCOMB.

        (C1) (N+1)^B*N!^B;
                                              B   B
        (D1)                           (N + 1)  N!

        (C2) FACTCOMB(%);
                                                 B
        (D1)                             (N + 1)!



    &BERNPOLY(v, n) generates the nth  Bernoulli polynomial
        in the variable v.



    &QUNIT(n)  gives  the   principal  unit  of   the  real
        quadratic  number  field  SQRT(n)  where  n  is  an
        integer,  i.e.  the element  whose  norm  is unity.
        This  amounts  to  solving  Pell's  equation  A**2-
        n*B**2=1.

        (C1) QUNIT(17);
        (D1)              SQRT(17)+4

        (C2)  EXPAND(%*(SQRT(17)-4));

        (D2)               1



    &CF(exp) converts exp  into a continued  fraction.  exp
        is an  expression composed of  arithmetic operators
        and lists  which represent continued  fractions.  A
        continued fraction a+1/(b+1/(c+...)) is represented
        by the list [a,b,c,...]. a,b,c,.. must be integers.
        Exp may also involve SQRT(n) where n is an integer.
        In  this case  CF will  give as  many terms  of the
        continued  fraction as  the value  of  the variable
        CFLENGTH[1] times the period.  Thus the  default is
        to give one period.


    &CFDISREP(list)   converts   the   continued   fraction
        represented by list into general representation.

        (C1) CF([1,2,-3]+[1,-2,1]);

        (D1)                 [1, 1, 1, 2]

        (C2) CFDISREP(%);
                                    1
        (D2)                1 + ---------
                                      1
                                1 + -----
                                        1
                                    1 + -
                                        2



    &CFEXPAND(x)  gives  a  matrix  of  the  numerators and
        denominators   of   the   next-to-last   and   last
        convergents of the continued fraction x.



        (C1) CF(SQRT(3));
        (D1)                 [1, 1, 2, 1, 2, 1, 2, 1]

        (C2) CFEXPAND(%);
                                     [71  97]
        (D2)                         [      ]
                                     [41  56]

        (C3) D2[1,2]/D2[2,2],NUMER;
        (D3)                        1.7321429


    &APPLY(function, list) gives the result of applying the
        function  to the  list of  its arguments.   This is
        useful when it is desired to compute  the arguments
        to a function  before applying that  function.  For
        example, if L is the list [1, 5, -10.2, 4, 3], then
        APPLY(MIN,L)  gives  -10.2.  APPLY  is  also useful
        when  calling  functions which  do  not  have their
        arguments  evaluated  if  it  is  desired  to cause
        evaluation of them.  For example, if FILESPEC  is a
        variable  bound  to  the  list  [TEST,  CASE]  then
        APPLY(CLOSEFILE,FILESPEC)    is    equivalent    to
        CLOSEFILE(TEST,CASE).    In   general   the   first
        argument to APPLY should  be preceded by a '  to to
        make  it  evaluate to  itself.   Since  some atomic
        variables have the  same name as  certain functions
        the  values of  the variable  would be  used rather
        than  the  function  because  APPLY  has  its first
        argument evaluated as well as its second.


    &ARRAYMAKE(name,[i1,i2,...]) returns name[i1,i2,...].


    &MAP(fn, exp1, exp2,  ...) returns an  expression whose
        leading operator  is the same  as that of  the expi
        but whose subparts  are the results of  applying fn
        to the corresponding  subparts of the expi.   Fn is
        either the name of a function of n arguments (where
        n is the number of  expi) or is a LAMBDA form  of n
        arguments.

            MAPERROR[TRUE] - if FALSE will cause all of the
        mapping  functions  to (1)  stop  when  they finish
        going down the shortest expi if not all of the expi
        are of the same  length and (2) apply fn  to [exp1,
        exp2,...] if the expi are not all the same  type of
        object. If MAPERROR  is TRUE then an  error message
        will be given in the above two instances.

            One of the  uses of this  function is to  MAP a
        function (e.g. PARTFRAC)  onto each term of  a very



        large  expression where  it ordinarily  wouldn't be
        possible  to  use   the  function  on   the  entire
        expression  due to  an exhaustion  of  list storage
        space in the course of the computation.

        (C1) MAP(F,X+A*Y+B*Z);
        (D1)                      F(B Z) + F(A Y) + F(X)

        (C2) MAP(LAMBDA([U],PARTFRAC(U,X)),X/(X^3+4*X^2+5*X+2));
                                        1        X
        (D2)                       X (----- - --------)
                                      X + 2          2
                                              (X + 1)

        (C3) MAP(RATSIMP, X/(X**2+X)+(Y**2+Y)/Y);

                              1
        (D3)            Y + ----- + 2
                            X + 1

        (C4) MAP("=",[A,B],[-.5, 3,2.5]);
        MAP IS TRUNCATING
        (D4)                [A = -.5, B = 3]



    &MAPLIST(fn,  exp1, exp2,  ...)  yields a  list  of the
        applications of fn to the parts of the  expi.  This
        differs from MAP(fn,exp1,exp2,...) which returns an
        expression with the same main operator as  expi has
        (except for simplifications and the case  where MAP
        does an APPLY).  Fn is of the same form as in MAP.


    &FULLMAP(fn, exp1, ...) is  similar to MAP but  it will
        keep mapping down all subexpressions until the main
        operators are no longer the same.
        The user  should be aware  that FULLMAP is  used by
        the   MACSYMA   simplifier   for   certain   matrix
        manipulations; thus,  the user  might see  an error
        message concerning FULLMAP even though  FULLMAP was
        not explicitly called by the user.

        (C1) A+B*C$

        (C2) FULLMAP(G,%);

        (D2)              G(B) G(C) + G(A)

        (C3)  MAP(G,D1);

        (D3)                G(B C) + G(A)



    &FULLMAPL(fn, list1, ...) is similar to FULLMAP  but it
        only maps onto lists and matrices

        (C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);

        (D1)                      [[A + 3, 4], [4, 3.5]]



    &SCANMAP(function,exp) recursively applies  function to
        exp.    This   is  most   useful   when  "complete"
        factorization is desired, for example:


        (C1) EXP:(A^2+2*A+1)*Y + X^2$

        (C2) SCANMAP(FACTOR,EXP);
                                            2      2
        (D2)                         (A + 1)  Y + X


            Note the way in which SCANMAP applies the given
        function FACTOR  to the  constituent subexpressions
        of  exp; if  another form  of exp  is  presented to
        SCANMAP then the result may be different.  Thus, D2
        is  not recovered  when SCANMAP  is applied  to the
        expanded form of exp:


        (C3) SCANMAP(FACTOR,EXPAND(EXP));
                                   2                  2
        (D3)                      A  Y + 2 A Y + Y + X

            Here  is another  example of  the way  in which
        SCANMAP recursively applies a given function to all
        subexpressions, including exponents:

        (C4) EXPR : U*V^(A*X+B) + C$

        (C5) SCANMAP('F, EXPR);

                            F(F(F(A) F(X)) + F(B))
        (D5) F(F(F(U) F(F(V)                      )) + F(C))


    &APPEND(list1, list2, ...) returns a single list of the
        elements  of  list1  followed  by  the  elements of
        list2,...

        (C1) APPEND([Y+X,0,-3.2],[2.5E20,X]);

        (D1)             [Y+X, 0, -3.2, 2.5E20, X]



    &CONS(exp, list) returns a new list constructed  of the
        element exp as  its first element, followed  by the
        elements of list.


    &ENDCONS(exp, list)  returns a  new list  consisting of
        the elements of list followed by exp.


    &MEMBER(exp,  list) returns  TRUE  if exp  occurs  as a
        member of  list (not  within a  member).  Otherwise
        FALSE is returned.


    &REVERSE(list)  reverses the  order of  the  members of
        list (not the members themselves).

            See         also          the         functions
        FIRST,REST,LAST,DELETE,LENGTH ().



                             Examples

        (C1) UNION(X,Y):=IF X = [] THEN Y ELSE
                   IF MEMBER(T:FIRST(X),Y) THEN UNION(REST(X),Y)
                   ELSE CONS(T,UNION(REST(X),Y)$

        (C2) UNION([A,B,1,1/2,X**2],[-X**2,A,Y,1/2]);

                                 2            2        1
        (D2)                   [X , 1, B,  - X , A, Y, -]
                                                       2

            In  this example  T  is assigned  the  value of
        FIRST(X) in  the call to  MEMBER and  is referenced
        later in CONS(T,UNION(...)).

        (C3) BERNPOLY(X,5);
                                       4      3
                                5   5 X    5 X    X
        (D3)                   X  - ---- + ---- - -
                                     2      3     6

        (C4) MAPLIST(NUMFACTOR,%);
                                     5  5    1
        (D4)                   [1, - -, -, - -]
                                     2  3    6

        (C5) APPLY(MIN,%);
                                          5
        (D5)                            - -
                                          2



    &PLOT(exp, var, low, high) produces a character-plot of
        the   expression  exp   as  var   (the  independent
        variable)  ranges from  low to  high.   An optional
        fifth  argument of  INTEGER causes  PLOT  to choose
        only integer values for var in the given domain.


    &PARAMPLOT([f1(t),  g1(t),  ...h1(t)],  [f2(t),  g2(t),
        ...,  h2(t)],  t,  low,  high,  [list  of  plotting
        characters]) plots the plane curves f(t) = (f1,f2),
        g(t)  =   (g1,g2),...,h(t)  =  (h1,h2)   using  the
        specified plotting characters or the default "*".


    &GRAPH(xlist,  ylist,  xlabel, ylabel)  graphs  the two
        lists  of  data  points,  and  labels  the  axes as
        indicated  or omits  labels if  just the  first two
        arguments are given.


    &MULTIGRAPH([[xset1,  yset1],  ...,   [xsetn,  ysetn]],
        optional-args)  -  allows  the  user  to  produce a
        scatter-graph involving several x-domains each with
        a           single           y-range;          e.g.
        MULTIGRAPH([[[0,1],[0,1]],[[3,4],[1,2]]],["&"]).


    &TRACE(name1,  name2,  ...)  gives  a   trace  printout
        whenever  the   functions  mentioned   are  called.
        TRACE() prints  a list  of the  functions currently
        under TRACE.


    &UNTRACE(name1,  ...) removes  tracing incurred  by the
        TRACE function.  UNTRACE() removes tracing from all
        functions.


    &REMTRACE() removes the tracing facilities from MACSYMA
        thus  freeing  up  some  storage.   They   will  be
        reloaded when TRACE is used again.


    &DECLARE([var1, var2, ...], BINDTEST) causes MACSYMA to
        give  an error  message  whenever any  of  the vari
        occur unbound in a computation.


    &DEBUGMODE(switch)  causes MACSYMA  to enter  a MACSYMA
        break  loop  whenever  a  MACSYMA  error  occurs if
        switch is TRUE and to terminate that mode if switch
        is  FALSE.   If switch  is  ALL then  the  user may
        examine  BACKTRACE   for  the  list   of  functions
        currently entered.



    &BREAK(arg1,  ...) evaluates  and prints  its arguments
        then enters a MACSYMA break loop.


    &DISPFUN(f1, f2,  ...) displays  the definition  of the
        user defined functions  f1, f2, ... which  may also
        be  the   names  of  array   associated  functions,
        subscripted functions,  or functions  with constant
        subscripts which  are the same  as those  used when
        the  functions  were  defined.   DISPFUN(ALL)  will
        display all user defined functions as given  on the
        FUNCTIONS  and  ARRAYS  lists   except  subscripted
        functions with constant subscripts.


    &DISPRULE(rulename) will display  a rule with  the name
        rulename  as  was given  by  DEFRULE,  TELLSIMP, or
        TELLSIMPAFTER  or  a pattern  defined  by DEFMATCH.
        For example, the  first rule modifying SIN  will be
        called SINRULE1. (see sect 6.13.2)


    &DISPLAY(expr1,  expr2, ...)  displays  equations whose
        left  side is  expri unevaluated,  and  whose right
        side is the value of the expression centered on the
        line.  This  function is useful  in blocks  and FOR
        statements  in order  to have  intermediate results
        displayed.   The arguments  to DISPLAY  are usually
        atoms,  subscripted variables,  or  function calls.
        (see the DISP function below.)

        (C1) DISPLAY(B[1,2]);

                                              2
                                 B     = X - X
                                  1, 2

        (D1)                            DONE



    &LDISPLAY(expr1,expr2,...)  is  like  DISPLAY  but also
        generates intermediate labels.


    &DISP(expr1,expr2, ...)  is like  DISPLAY but  only the
        value of  the arguments  are displayed  rather than
        equations.    This   is   useful   for  complicated
        arguments which don't have names or where  only the
        value of  the argument is  of interest and  not the
        name.



    &LDISP(expr1,expr2,...) is like DISP but also generates
        intermediate labels.


    &PRINT(exp1,  exp2,  ...)  evaluates  and  displays its
        arguments one after the other "on a  line" starting
        at the leftmost position.  If expi is unbound or is
        preceded by  a single  quote or  is enclosed  in "s
        then  it   is  printed  literally.    For  example,
        PRINT("THE VALUE OF X IS ",X).  The  value returned
        by PRINT  is the  value of  its last  argument.  No
        intermediate lines are generated.


    &DISPTERMS(expr)  displays  its argument  in  parts one
        below the other.   That is, each  term in a  sum or
        factor in a product is displayed  separately.  This
        is  useful if  expr is  too large  to  be otherwise
        displayed.   For example  if P1,  P2, ...  are very
        large expressions then the display program  may run
        out of storage space in trying to display P1+P2+...
        all  at  once.  However,  DISPTERMS(P1+P2+...) will
        display P1, then below it P2, etc.  When  not using
        DISPTERMS, if an exponential expression is too wide
        to be displayed as A**B it will appear as EXPT(A,B)
        (or as NCEXPT(A,B) in the case of A^^B).


    &REVEAL(exp,depth)  will display  exp to  the specified
        integer  depth  with   the  length  of   each  part
        indicated.  Sums  will be  displayed as  SUM(n) and
        products  as PRODUCT(n)  where n  is the  number of
        subparts of the sum or product.   Exponentials will
        be displayed as EXP.


        (C1) INTEGRATE(1/(X^3+2),X)$

        (C2) REVEAL(%,2);
        (D2)              PRODUCT(3) + PRODUCT(3) + PRODUCT(3)

        (C3) REVEAL(D1,3);
                            EXPT LOG                    EXPT LOG
        (D3)              - -------- + EXPT EXPT ATAN + --------
                               6                           3



    &PLAYBACK(arg) "plays back" input and output lines.  If
        arg=n (a  number) the last  n expressions  (Ci, Di,
        and Ei count as 1 each) are "played-back", while if
        arg is omitted,  all lines are.  If  arg=INPUT then
        only input lines are played back. If arg=[m,n] then



        all lines  with numbers from  m to n  inclusive are
        played-back.   If m=n  then [m]  is  sufficient for
        arg.   Arg=SLOW  places  PLAYBACK  in  a  slow-mode
        similar to DEMO's (as opposed to the "fast" BATCH).
        This  is  useful   in  conjunction  with   SAVE  or
        STRINGOUT  (see below)  when creating  a secondary-
        storage   file  in   order  to   pick   out  useful
        expressions.   If  arg=TIME  then  the  computation
        times  are displayed  as well  as  the expressions.
        Arg=STRING strings-out (see STRING  function below)
        all  input  lines  when  playing  back  rather than
        displaying  them.  One  may include  any  number of
        options as in PLAYBACK([5,10],20,TIME,SLOW).


    &STRING(expr)   converts  expr   to   MACSYMA's  linear
        notation (similar to  FORTRAN's) just as if  it had
        been typed  in and  puts expr  into the  buffer for
        possible editing (in which case expr is usually Ci)
        (see section 8.2).  The STRING'ed expression should
        not be used in a computation.


    &FORTRAN(switch)   If   switch   is    TRUE,   STRINGed
        expressions  will  have  fortran  syntax,  i.e.  **
        rather  than ^  for exponentiation.   If  switch is
        FALSE, then this mode is terminated.


    &STRINGOUT(args) will output an expression to a file in
        a                   linear                  format.
        STRINGOUT([filespec],...,FUNCTIONS,...)   puts  all
        the  user's function  definitions in  the specified
        file. (see 6.10.3)


    &REMOVE(args) will remove some or all of the properties
        associated with variables or functions. (see 6.12)


    &REMFUNCTION(f1,  f2,  ...)  removes  the  user defined
        functions f1,f2,... from MACSYMA.  If there is only
        one argument of ALL then all functions are removed.


    &REMVALUE(name1, name2, ...) removes the values of user
        variables  (which  can  be  subscripted)  from  the
        system.  If name is ALL then the values of all user
        variables  are  removed.   Values  are  those items
        given names by the  user as opposed to  those which
        are automatically labeled by MACSYMA as Ci,  Di, or
        Ei.



    &REMARRAY(name1, name2,  ...) removes arrays  and array
        associated   functions   and   frees   the  storage
        occupied.   If  name  is ALL  then  all  arrays are
        removed.  It may be necessary to use  this function
        if it is desired to redefine the values in a hashed
        array.


    &REMRULE(function,  rulename) will  remove a  rule with
        the  name  rulename  from  the  function  which was
        placed  there  by DEFRULE,  DEFMATCH,  TELLSIMP, or
        TELLSIMPAFTER.  If rule-name is ALL, then all rules
        will be removed. (see example in 6.13.2)


    &KILL(arg1,  arg2, ...)  eliminates its  arguments from
        the  MACSYMA  system.    If  argi  is   a  variable
        (including  a single  array element),  function, or
        array,  the  designated   item  with  all   of  its
        properties  is  removed from  core.  If argi=LABELS
        then all input,  intermediate, and output  lines to
        date (but not other named items) are eliminated. If
        argi=CLABELS   then  only   input  lines   will  be
        eliminated; if argi=ELABELS then  only intermediate
        E-lines  will be  eliminated; if  argi=DLABELS only
        the output  lines will be  eliminated.  If  argi is
        the name of any of the other information lists (the
        elements of  the MACSYMA variable  INFOLISTS), then
        every item  in that class  (and its  properties) is
        KILLed  and if  argi=ALL then  every item  on every
        information  list  previously  defined  as  well as
        LABELS is KILLed.   If argi=a number (say  n), then
        the last n  lines (i.e. the  lines with the  last n
        line numbers) are deleted.  If argi is of  the form
        [m,n] then all lines  with numbers between m  and n
        inclusive  are  killed. Note  that  KILL(VALUES) or
        KILL(variable) will not freeup the storage occupied
        unless the  labels which are  pointing to  the same
        expressions  are  also  KILLed.   Thus  if  a large
        expression was assigned to X on line C7  one should
        do  KILL(D7)  as  well as  KILL(X)  to  release the
        storage occupied.

            KILL  removes  all  properties  from  the given
        argument thus KILL(VALUES) will kill all properties
        associated  with  every  item  on  the  VALUES list
        whereas    the    REMOVE    set     of    functions
        (REMVALUE,REMFUNCTION,REMARRAY,REMRULE)   remove  a
        specific  property.  Also  the latter  print  out a
        list  of names  or FALSE  if the  specific argument
        doesn't exist whereas KILL always has  value "DONE"
        even if the named item doesn't exist (see 6.12).



            Note that killing expressions will not help the
        problem  indicated  by "NO  CORE  -  FASLOAD" which
        results when either  too many FASL files  have been
        loaded in or  when allocation level has  gotten too
        high.   In  either  of these  cases,  no  amount of
        killing  will cause  the  size of  these  spaces to
        decrease.   Killing  expressions  only  causes some
        spaces to get emptied out but not made smaller.


    &LOADFILE(fn1,  fn2, DSK,  directory) loads  a  file as
        designated by its arguments.  This function  may be
        used to bring back quantities that were stored from
        a prior MACSYMA session by use of the SAVE or STORE
        functions.  If DSK  and directory are  omitted then
        the last directory seen (initially the same  as the
        user's login name or USERS if the user has  no file
        directory) will be used.  Also, fn2 may  be omitted
        if fn1 >  is to be loaded  in (where >  follows the
        conventions of ITS's file system).  Fn1 fn2 must be
        a file  of LISP functions  and expressions,  not of
        MACSYMA command lines, in which case BATCH  or DEMO
        is to be used.  (See Chapter 8).


    &DELFILE(file-specification) will delete the file given
        by    the   file-specification    (i.e.   firstname
        secondname device user) from the given device.


    &BATCH(file-specification)   reads  in   and  evaluates
        MACSYMA command lines from a file. (see Chapter 8).


    &DEMO(file-specification)  same  as  BATCH  but  pauses
        after each command line and continues when  a space
        is typed.  (see Chapter 8).


    &BATCON(argument)  continues BATCHing  in a  file which
        was interrupted.  ((see )).


    &WRITEFILE(DSK, directory) opens up a file for writing.


    &APPENDFILE(filename1,  filename2,  DSK,  directory) is
        like  WRITEFILE(DSK,directory) but  appends  to the
        file  whose  name  is specified  by  the  first two
        arguments.  A subsequent CLOSEFILE will  delete the
        original file and rename the appended file.



    &CLOSEFILE(filename1, filename2)  closes a  file opened
        by  WRITEFILE  and  gives  it  the  name  filename1
        filename2.  Thus to  save a file consisting  of the
        display of all input and output during some part of
        a session with MACSYMA the user issues a WRITEFILE,
        transacts  with MACSYMA,  then issues  a CLOSEFILE.
        The user can also issue the PLAYBACK function after
        a  WRITEFILE  to  save  the  display   of  previous
        transactions.  (Note that what is saved this way is
        a  copy  of  the  display  of  expressions  not the
        expressions  themselves).    To  save   the  actual
        expression in internal  form the SAVE  function may
        be used.  The  expression can then be  brought back
        into MACSYMA  via the  LOADFILE function.   To save
        the expression in a  linear form which may  then be
        BATCHed in later,  the STRINGOUT function  is used.
        (see below)


    &STRINGOUT(file-specification, A1, A2, ...)  outputs to
        a     file     given      by     file-specification
        ([filename1,filename2,DSK,  directory])  the values
        given  by A1,A2,..  in a  MACSYMA  readable format.
        The  file-specification  may be  omitted,  in which
        case the  default values will  be used.  (see sect.
        9.2 -  C) The  Ai are  usually C  labels or  may be
        INPUT meaning the  value of all C  labels.  Another
        option is to make ai FUNCTIONS which will cause all
        of the user's function definitions to  be strungout
        (i.e. all those retrieved by DISPFUN(ALL)).  ai may
        also be a list  [m,n] which means to  stringout all
        labels in  the range m  through n  inclusive.  This
        function may  be used to  create a file  of FORTRAN
        statements  by  doing some  simple  editing  on the
        strungout expressions.  The  function FORTRAN(TRUE)
        should  be   executed  first,  however,   to  cause
        exponentiation to be strung as ** rather than as ^,
        as well as to effect other FORTRAN-like changes.


    &SAVE(arg1) saves quantities described by its arguments
        on disk and keeps  them in core also.  (see section
        9.3).


    &STORE(args) same as SAVE but doesn't retain quantities
        in core. (see section 9.3).


    &FASSAVE(args) is similar  to SAVE but produces  a FASL
        file in which  the sharing of  subexpressions which
        are  shared  in  core  is  preserved  in  the  file
        created.   Hence,  expressions  which  have  common



        subexpressions will consume less space  when loaded
        back from a file created by FASSAVE rather  than by
        SAVE.


    &DSKGC(TRUE) will cause user defined values, functions,
        arrays,  and   line  labelled  expressions   to  be
        automatically  stored on  disk whenever  the system
        determines  that  the  available  in-core  space is
        getting  low.   DSKGC(FALSE)  will  turn   off  the
        automatic    storing    mechanism    activated   by
        DSKGC(TRUE).  (see also sect. 9.2).


    &UNSTORE(name1, ...) brings the named  expressions into
        core  that were  stored away  by use  of  the STORE
        function in the current MACSYMA. (see section 9.3).


    &RESTORE(file-specification)      reinitializes     all
        quantities filed away by a use of the SAVE or STORE
        functions,  in a  prior MACSYMA  session,  from the
        file given  by file-specification  without bringing
        them into core. (see section 9.4).


    &REMFILE()  removes  files  created  by  the  secondary
        storage  scheme  in  the  MACSYMA  under  use  (see
        section  9.2).  REMFILE(TRUE)  does  what REMFILE()
        does and in  addition deletes any files  which have
        been  created by  the SAVE  or STORE  functions but
        which have not been assigned names by the user.


    &TIME(Di1,  Di2,  ...) gives  a  list of  the  times in
        milliseconds taken to compute the Di.


    &LOGOUT() causes the user to be logged out and all jobs
        deleted.   This is  useful  when it  is  desired to
        BATCH in  a file and  have the terminal  logged out
        automatically when  the computations  are finished.
        (Equivalent to ^Z and :LOGOUT)


    &QUIT() kills  the current  MACSYMA but  doesn't affect
        the  user's  other  jobs.   (Equivalent  to  ^Z and
        :KILL).


    &READ(string1, ...) prints its arguments, then reads in
        and   evaluates  one   expression.    For  example:
        A:READ("ENTER THE NUMBER OF VALUES").



    &DEFINE(f(x1, ...), body) is equivalent to f(x1,...):='
        'body but when used inside functions it  happens at
        execution  time   rather  than   at  the   time  of
        definition of the function which contains it.  (see
        sect. 4.2)


    &LOCAL(v1, v2, ...)  causes the variables  v1,v2,... to
        be local with respect to all the properties  in the
        statement  in  which  this  function  is  used (see
        3.12).  LOCAL  may only be  used in BLOCKs,  in the
        body of function definitions or LAMBDA expressions,
        or in  the EV function  and only one  occurrence is
        permitted in each.


    &ERROR(arg1,  arg2, ...)  will evaluate  and  print its
        arguments and  then will cause  an error  return to
        top  level  MACSYMA  or  to  the  nearest enclosing
        ERRCATCH.   This  is  useful  for  breaking  out of
        nested functions if an error condition is detected,
        or wherever one can't type control-^.
        ERRORFUN[FALSE] - if set to the name of  a function
        of  no arguments  will  cause that  function  to be
        executed whenever an error occurs.  This  is useful
        in BATCH files where the user may want  his MACSYMA
        killed  or  his  terminal logged  out  if  an error
        occurs.  In  these cases ERRORFUN  would be  set to
        QUIT or LOGOUT.


    &ERRCATCH(exp1, exp2, ...) evaluates its  arguments one
        by one and returns a list of the value of  the last
        one if no error occurs.  If an error occurs  in the
        evaluation of any arguments, ERRCATCH "catches" the
        error and immediately returns [] (the  empty list).
        This function  is useful in  BATCH files  where one
        suspects an error might occur which would otherwise
        have  terminated  the BATCH  if  the  error weren't
        caught.


    &CATCH(exp1,...,expn)  evaluates its  arguments  one by
        one;  if the  structure of  the expi  leads  to the
        evaluation of an expression of the form THROW(arg),
        then  the  value  of  the  CATCH  is  the  value of
        THROW(arg).   This  "non-local  return"  thus  goes
        through  any  depth  of  nesting  to   the  nearest
        enclosing   CATCH.    There   must   be   a   CATCH
        corresponding  to  a   THROW,  else  an   error  is
        generated.  If the evaluation of the expi  does not
        lead to the evaluation of any THROW then  the value
        of the CATCH is the value of expn.



        (C1) G(L):=CATCH(MAP(LAMBDA([X],
               IF X<0 THEN THROW(X) ELSE F(X)),L))$

        (C2) G([1,2,3,7]);
        (D2)                     [F(1), F(2), F(3), F(7)]

        (C3) G([1,2,-3,7]);
        (D3)                                - 3


            The  function G  returns a  list of  F  of each
        element  of L  if L  consists only  of non-negative
        numbers; otherwise, G "catches" the  first negative
        element of L and "throws" it up.


    &THROW(exp) evaluates exp and throws the value  back to
        the most recent CATCH.  THROW is used with CATCH as
        a structured nonlocal exit mechanism.


    &BREAK(arg1, ...) will evaluate and print its arguments
        and  will  then cause  a  (MACSYMA-BREAK)  at which
        point  the   user  can   examine  and   change  his
        environment.   Upon  typing  EXIT;  the computation
        resumes. (see 12.0)


    &RESET() causes all MACSYMA options to be set  to their
        default values.


    &%TH(i) is the  ith previous computation.  That  is, if
        the next expression to be computed is D(j)  this is
        D(j-i).   This  is  useful in  BATCH  files  or for
        referring  to  a  group  of  D   expressions.   For
        example, if  SUM is initialized  to 0 then  FOR I:1
        THRU 10 DO SUM:SUM+%TH(I)  will set SUM to  the sum
        of the last ten D expressions.


    &CONCAT(arg1,  arg2, ...)  evaluates its  arguments and
        returns the concatenation of their values resulting
        in a name or a quoted string (see 3.2 and  3.3) the
        type  being given  by that  of the  first argument.
        Thus  if X  is bound  to 1  and D  is  unbound then
        CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.


    &GETCHAR(a, i) returns the ith character of  the quoted
        string or atomic  name a.  This function  is useful
        in manipulating the LABELS list.



    &STATUS(arg)    will   return    miscellaneous   status
        information about the user's MACSYMA depending upon
        the arg  given.  Permissible arguments  and results
        are as follows:

            TIME - the time used so far in the computation.
            DAY - the day of the week.
            DATE - a list of the year, month, and day.
            DAYTIME  -  a  list of  the  hour,  minute, and
        second.
            RUNTIME - accumulated  cpu time times  the atom
        "MILLISECONDS".
            WRITEFILE - a  list of the device  and username
        for the  current writefile or  an empty list  if no
        WRITEFILE has been done.
            LOADFILE  -  a  list of  the  first  file name,
        second  file  name, device,  and  username  for the
        current BATCH, DEMO, or LOADFILE function.
            FILE -  a list of  the current first  file name
        and second file name.
            UNIT  -  a  list  of  the  current  device  and
        username.


    &ALARMCLOCK(arg1, arg2, arg3) will execute the function
        of no  arguments whose name  is arg3 when  the time
        specified by arg1 and arg2 elapses.  If arg1 is the
        atom "TIME" then  arg3 will be executed  after arg2
        seconds of real-time  has elapsed while if  arg1 is
        the atom "RUNTIME" then arg3 will be executed after
        arg2 milliseconds of cpu time. If arg2  is negative
        then the arg1 timer is shut off.


    &BOTHCASES(TRUE)  will  cause MACSYMA  to  retain lower
        case text  as well as  upper case.   Note, however,
        that the names of any MACSYMA special  variables or
        functions must be typed in upper case.
        BOTHCASES(FALSE)  causes MACSYMA  to revert  to the
        normal mode of lower to upper case conversion.


    &STARDISP(TRUE)   will  cause   multiplication   to  be
        displayed explicitly with an * between operands.


    &LABELS(char)  takes  a  char  C,D,or  E  as   arg  and
        generates a  list of  all C-labels,D-labels,  or E-
        labels, respectively.  (If you've generated many E-
        labels  via  SOLVE,   then  FIRST(REST(LABELS(C)));
        reminds you what the last C-label was.)



    &ALIAS(newname1,  oldname1,  newname2,  oldname2,  ...)
        provides an alternate  name for a (user  or system)
        function,variable,array,etc.   Any  even  number of
        arguments may be used.


    &ORDERGREAT(V1,  ...,  Vn)  sets  up  aliases  for  the
        variables V1, ..., Vn such that V1 > V2 > ...  > Vn
        > any other variable not mentioned as an argument.


    &ORDERLESS(V1,  ...,  Vn)  sets  up  aliases   for  the
        variables V1, ..., Vn such that V1 < V2 < ...  < Vn
        < any other variable not mentioned as  an argument.
        Thus  the  complete  ordering  scale  is: numerical
        constants < declared constants < first  argument to
        ORDERLESS  < ...  <  last argument  to  ORDERLESS <
        variables  which begin  with  A <  ...  < variables
        which begin with Z < last argument to  ORDERGREAT <
        ... < first argument to ORDERGREAT.


    &UNORDER() removes the aliases created by the  last use
        of  the  above ordering  commands.   ORDERGREAT and
        ORDERLESS may not be  used more than one  time each
        without calling UNORDER.

        (C1) A**2+B*X;
                                                2
        (D1)                             B X + A

        (C2) ORDERGREAT(A);
        (D2)                               DONE

        (C3) A**2+B*X;
                                          2
        (D3)                             A  + B X

        (C4) %-D1;
                                          2    2
        (D4)                             A  - A

        (C5) UNORDER();
        (D5)                               [A]



    &MODEDECLARE(y1,  mode1,  y2, mode2,  ...)  is  used to
        declare the  modes of  variables and  functions for
        subsequent translation or compilation of functions.
        It can also influence  trigonometric simplification
        ((see  )  for  an  example).   Its   arguments  are
        pairs consisting of a variable yi, and a mode which



        is  one  of  BOOLEAN,  INTEGER,  FLOAT,  POLY  (for
        polynomial), or CRE (for expression in CRE form).


            If yi is an array, and if every element  of the
        array  which is  referenced in  the function  has a
        value then ARRAY(yi, COMPLETE, d1, d2,  ...) rather
        than  ARRAY(yi, d1,  d2, ...)  should be  used when
        first declaring the bounds of the array. If all the
        elements of the array are of mode  INTEGER (FLOAT),
        use INTEGER  (FLOAT) instead  of COMPLETE.  Also if
        every element of the array is of the same mode, say
        m, then MODEDECLARE(COMPLETEARRAY(yi),m)) should be
        used for efficient translation.  Also  numeric code
        using arrays can be made to run faster by declaring
        the expected size of the array, as in:
            MODEDECLARE(COMPLETEARRAY(A[10,10]),FLOAT)
        for a floating point number array which is 10 x 10.

            Each yi may also be a list of variables  all of
        which are declared to have modei.

            Additionally one  may declare  the mode  of the
        result of a function by using FUNCTION(name)  as an
        argument where  name is the  name of  the function.
        For         example          the         expression
        MODEDECLARE([FUNCTION(FUN1),X],POLY,Q,COMPLETEARRAY(Q),FLOAT)
        declares that X and the value returned by  FUN1 are
        polynomials  and that  Q  is an  array  of floating
        point   numbers.    MODEDECLARE   is   used  either
        immediately  inside of  a function  definition (see
        below) or at top-level for global variables.


    &TRANSLATE(f1,  f2,  ...) translates  the  user defined
        functions  f1,f2,... from  the MACSYMA  language to
        LISP (i.e. it makes them EXPRs).  This results in a
        gain in speed when they are called.   The functions
        should  include  a  call  to  MODEDECLARE   at  the
        beginning when  possible in  order to  produce more
        efficient code.  For example:

        F(X1,X2,...):=BLOCK([v1,v2,...],
                MODEDECLARE(v1,mode1,v2,mode2,...),...)

        where  the  X1,X2,...  are  the  parameters  to the
        function and the v1,v2,... are the local variables.
        The names of translated functions are  removed from
        the FUNCTIONS list if SAVEDEF is FALSE  (see below)
        and  are  added  to  the  PROPS  lists  (see 6.12).
        Functions should not be translated unless  they are
        fully  debugged.   Also,  expressions  are  assumed
        simplified;  if  they  are  not,  correct  but non-



        optimal code gets generated.  Thus, the user should
        not  set the  SIMP switch  to FALSE  which inhibits
        simplification of the expressions to be translated.

            TRANSLATE[FALSE]  - If  TRUE,  causes automatic
        translation  of a  user's function  to  LISP.  Note
        that translated  functions may not  run identically
        to the way  they did before translation  as certain
        incompatabilities  may exist  between the  LISP and
        MACSYMA  versions.  Principally,  the  RAT function
        with  more  than  one  argument  and   the  RATVARS
        function  (see  6.5)  should  not  be  used  if any
        variables are MODEDECLAREd CRE.

            SAVEDEF[TRUE] - if TRUE will cause  the MACSYMA
        version  of  a  user function  to  remain  when the
        function   is   TRANSLATEd.    This   permits   the
        definition to  be displayed  by DISPFUN  and allows
        the function to be edited.

            TRANSRUN[TRUE]  -  if  FALSE  will   cause  the
        interpreted  version  of all  functions  to  be run
        (provided they  are still  around) rather  than the
        translated version.

            One can translate functions stored in a file by
        giving  TRANSLATE  an  argument  which  is  a  file
        specification.   This  is   a  list  of   the  form
        [fn1,fn2,DSK,dir] where fn1 fn2 is the name  of the
        file of MACSYMA functions, and dir is the name of a
        file directory.

            The result returned  by TRANSLATE is a  list of
        the names of the functions TRANSLATEd.  In the case
        of a file translation the corresponding  element of
        the list is a list of the first and second new file
        names containing the  LISP code resulting  from the
        translation.   This will  be fn1  LISP on  the disk
        directory dir.  The file of  LISP code may  be read
        into MACSYMA  by using  the LOADFILE  function (see
        6.10.3).


    &COMPILE(f1,  f2, ...)  will compile  the  user defined
        functions   f1,f2,...  from   MACSYMA   to  machine
        language (i.e. it makes them SUBRs).   This results
        in  a further  gain  in speed  over  the TRANSLATEd
        version.  The functions  are in the  form described
        under the TRANSLATE function.

            The  COMPILE  command  can  also  generate FASL
        files.  Setting COMPFILE[FALSE]  to a list  of file
        specs causes  that FASL file  to be renamed  to the



        specified  file.   Temporary  files   .CMPL.  EXPR,
        .CMPL. ERROR, .CMPL. FASL are generated and deleted
        on the USERS  directory.  To keep these  files from
        being deleted, set COMPSAVE[FALSE] to TRUE.


    &DECLARE(a1, f1,  a2, f2,  ...) gives  the atom  ai the
        flag fi.  The  ai's and fi's  may also be  lists of
        atoms and flags respectively in which case  each of
        the atoms gets all of the properties.  The possible
        flags and their meanings are:
        CONSTANT - makes ai a constant as is %PI.

            NONSCALAR - makes ai  behave as does a  list or
        matrix  with  respect  to  the  dot  operator. (see
        6.4.1)

            NOUN - makes the function ai a noun so  that it
        won't be evaluated automatically. (see 3.2)

            EVFUN -  makes ai known  to the EV  function so
        that it will get applied if its name  is mentioned.
        Initial evfuns are FACTOR,  TRIGEXPAND, TRIGREDUCE,
        BFLOAT, RATSIMP, RATEXPAND, and RADCAN.

            EVFLAG - makes ai  known to the EV  function so
        that it will be bound to TRUE during  the execution
        of  EV if  it  is mentioned.   Initial  evflags are
        FLOAT, PRED,  SIMP, NUMER,  DETOUT, EXPONENTIALIZE,
        DEMOIVRE, KEEPFLOAT, LISTARITH, and TRIGEXPAND.

            BINDTEST - causes ai  to signal an error  if it
        ever is used in a computation unbound. (see 12.0)


    &ARRAYINFO(a) returns a  list of information  about the
        array a.   For hashed arrays  it returns a  list of
        "HASHED",  the   number  of  subscripts,   and  the
        subscripts of every element which has a value.  For
        declared arrays  it returns  a list  of "DECLARED",
        the number of subscripts, and the bounds  that were
        given the the ARRAY function when it was  called on
        a.

        (C1) B[1,X]:1$
        (C2) ARRAY(F,2,3)$
        (C3) ARRAYINFO(B);

        (D3)            [HASHED, 2, [1, X]]
        (C4) ARRAYINFO(F);

        (D4)            [DECLARED, 2, [2, 3]]



    &PROPERTIES(a) will yield  a list showing the  names of
        all the properties associated with the atom a.


    &PRINTPROPS(a, i)  will display  the property  with the
        indicator i associated with the atom a. a  may also
        be a list  of atoms or the  atom ALL in  which case
        all of  the atoms with  the given property  will be
        used.  For example, PRINTPROPS([F,G],ATVALUE).


    &REMOVE(a1, p1,  a2, p2, ...)  removes the  property pi
        from the atom ai.  Ai  and pi may also be  lists as
        with  DECLARE.   Pi   may  be  any   property  e.g.
        FUNCTION,  MODEDECLARE,   etc.   It  may   also  be
        TRANSFUN implying that the translated  LISP version
        of the function is  to be removed.  This  is useful
        if one  wishes to have  the MACSYMA version  of the
        function  executed   rather  than   the  translated
        version. Pi may also be OP or OPERATOR to  remove a
        syntax extension given to ai (see Appendix II).  If
        ai is  "ALL" then the  property indicated by  pi is
        removed from all  atoms which have it.   Unlike the
        more specific remove functions (REMVALUE, REMARRAY,
        REMFUNCTION, and REMRULE) REMOVE does  not indicate
        when a  given property  is non-existent;  it always
        returns "DONE".


    &PUT(a, p, i) associates with the atom a the property p
        with  the indicator  i.  This  enables the  user to
        give an atom any arbitrary property.


    &QPUT(a, p, i)  is similar to  PUT but it  doesn't have
        its arguments evaluated.


    &GET(a, i) retrieves  the user property indicated  by i
        associated  with  atom  a  or  returns  FALSE  if a
        doesn't have property i.

        (C1) PUT(%E,TRANSCENDENTAL,TYPE);
        (D1)                          TRANSCENDENTAL

        (C2) PUT(%PI,TRANSCENDENTAL,TYPE)$

        (C3) PUT(%I,ALGEBRAIC,TYPE)$



        (C4) TYPEOF(X) := BLOCK([Q], IF NUMBERP(X)
                   THEN RETURN(ALGEBRAIC),
                   IF NOT ATOM(X)
                   THEN RETURN(MAPLIST(TYPEOF, X)),
                   Q : GET(X, TYPE), IF Q=FALSE THEN
                   ERROR("NOT NUMERIC") ELSE Q)$

        (C5) TYPEOF(2*%E+X*%PI);

        NOT NUMERIC
        QUIT
        (C6) TYPEOF(2*%E+%PI);
        (D6)          [[ALGEBRAIC, TRANSCENDENTAL],
                                TRANSCENDENTAL]



    &REM(a, i) removes the property indicated by i from the
        atom a.


    &NUMERVAL(var1, exp1, var2, exp2, ...) declares vari to
        have  a numerval  of  exp1 which  is  evaluated and
        substituted for the variable in any  expressions in
        which  the variable  occurs  if the  NUMER  flag is
        TRUE. (see the EV function sec. 6.1.1).


    &ASSUME(pred1,  pred2,   ...)  stores   information  in
        MACSYMA about the relation among  various variables
        and  their relation  to zero  (>, =,  etc.)  on the
        basis  of the  given predicates.   This information
        can  be  utilized later  in  conditional statements
        such  as  IF  or  in  the  functions  IS,  SIGN  or
        INTEGRATE (certain  cases of  integration requiring
        sign information).  The information is added to the
        data  base and  is tested  for  consistency against
        previously given relations.  The  form ASSUME(list)
        where  list is  a list  of predicates  may  also be
        used.


    &ZEROEQUIV(exp,var)   is  a   zero-equivalence  testing
        algorithm.   It   returns  either   TRUE,FALSE,  or
        DONTKNOW. (see section 6.1.1).


    &IS(exp) tries to determine if exp (which must evaluate
        to  a predicate)  is TRUE  or FALSE.   If  it can't
        determine  this, then  a simplified  but equivalent
        form  of  exp  is  returned.   TRUE  (or  FALSE) is
        returned  only  if  the  relation  exp   (which  is
        composed  of variables,  comparison  operators, and



        predicate  functions) is  TRUE (or  FALSE)  for all
        possible values of its variables.


            The  operator  =  compares  two  expressions to
        determine   if   they  are   identical   after  all
        evaluations have been done.  Thus IS(X+1=2) returns
        TRUE  if   and  only   if  X   has  the   value  1.
        &EQUAL(expr1,expr2) on the other hand  returns TRUE
        (or FALSE) if and only if expr1 and expr2 are equal
        (or  not equal)  for all  possible values  of their
        variables   (as  determined   by   RATSIMP).   Thus
        IS(EQUAL((X+1)**2,X**2+2*X+1)) returns TRUE whereas
        if  X  is  unbound  IS((X+1)**2=X**2+2*X+1) returns
        FALSE.  Note also that IS(RAT(0)=0) gives FALSE but
        IS(EQUAL(RAT(0),0)) gives TRUE.  If a determination
        can't  be made  with  EQUAL then  a  simplified but
        equivalent form is returned whereas = always causes
        either TRUE or FALSE to be returned.  All variables
        occurring in  exp are presumed  to be  real valued.
        EV(exp,PRED) is equivalent to IS(exp).

        (C1)  IS(X**2 >= 2*X-1);
        (D1)          TRUE
        (C2)  IS(EQUAL(Y**3,1) OR LOG(X) > 0);
        (D2)          EQUAL(Y,1) OR X-1>0

        (C3) ASSUME(A>1);
        (D3)                               DONE

        (C4) IS(LOG(LOG(A+1)+1)>0 AND A^2+1>2*A);

        (D4)                               TRUE



    &SIGN(exp) uses  ASSUMEd information  (if any)  or asks
        the  user in  determining  the sign  (POS,  NEG, or
        ZERO) of exp.


    &FORGET(pred1,    pred2,    ...)    removes   relations
        established  by  ASSUME.   The  predicates  may  be
        expressions  equivalent  to  (but  not  necessarily
        identical    to)    those    previously    ASSUMED.
        FORGET(list) is also a legal form.


    &ATOM(exp) is TRUE if  exp is atomic (i.e. a  number or
        name)  else  FALSE.   Thus  ATOM(5)  is  TRUE while
        ATOM(A[1]) and  ATOM(SIN(X)) are  FALSE.  (Assuming
        A[1] and X are unbound.)



    &CONSTANTP(exp)  is TRUE  if  exp is  a  constant (i.e.
        composed  of  numbers  and  %PI,  %E,  %I   or  any
        variables bound to a constant or  DECLAREd constant
        [see  section  6.12.1]) else  FALSE.   Any function
        whose arguments are constant is also  considered to
        be a constant.


    &NONSCALARP(exp) is TRUE  if exp is a  non-scalar, i.e.
        it  contains  atoms  declared  as  non-scalars (see
        6.12), lists, or matrices.


    &INTEGERP(exp) is TRUE if exp is an integer else FALSE.


    &FLOATNUMP(exp)  is TRUE  if  exp is  a  floating point
        number else FALSE.


    &BFLOATP(exp) is TRUE is exp is a bigfloat  number else
        FALSE.


    &NUMBERP(exp) is TRUE if exp is an integer,  a rational
        number, a floating point number or a  bigfloat else
        FALSE.


    &RATNUMP(exp)  is  TRUE  if exp  is  a  rational number
        (includes integers) else FALSE.


    &LISTP(exp) is TRUE if exp is a list else FALSE.


    &MATRIXP(exp) is TRUE if exp is a matrix else FALSE.


    &RATP(exp) is  TRUE if  exp is in  CRE or  extended CRE
        form else FALSE.


    &FREEOF(x1, x2, ..., exp) yields TRUE if the xi  do not
        occur in exp and FALSE otherwise.  The xi are atoms
        or they may  be subscripted names,  functions (e.g.
        SIN(X) ),  or operators enclosed  in "s.   They may
        also be lists of these objects.

        (C1) FREEOF(Y,SIN(X+2*Y));

        (D1)                    FALSE

        (C2) FREEOF(COS(Y),"*",SIN(Y)+COS(X));



        (D2)                          TRUE


    &MATCHDECLARE(patternvar, predicate, ...)  associates a
        predicate  with  a  pattern  variable  so  that the
        variable will only match expressions for  which the
        predicate   is   not  FALSE.    (The   matching  is
        accomplished  by  one  of  the  functions described
        below).          For          example         after
        MATCHDECLARE(Q,FREEOF(X,%E))  is  executed,  Q will
        match any  expression not containing  X or  %E.  If
        the match succeeds then the variable is set  to the
        matched  expression.  The  predicate (in  this case
        FREEOF) is written without the last  argument which
        should  be  the  one  against  which   the  pattern
        variable is to be tested.  Note that the patternvar
        and the arguments to the predicate are evaluated at
        the time the match is performed.

            The odd numbered argument may also be a list of
        pattern  variables all  of  which are  to  have the
        associated predicate.  Any even number of arguments
        may be given.

            For  pattern  matching,  predicates   refer  to
        functions which are either FALSE or not  FALSE (any
        non FALSE value acts like TRUE).

            MATCHDECLARE(var,TRUE) will permit var to match
        any expression.


    &TELLSIMPAFTER(pattern,    replacement)    defines    a
        replacement   for   pattern   which   the   MACSYMA
        simplifier  uses  after  it  applies  the  built-in
        simplification rules.  The pattern may  be anything
        but a single variable or a number.


    &TELLSIMP(pattern,    replacement)   is    similar   to
        TELLSIMPAFTER but places new information before old
        so  that   it  is   applied  before   the  built-in
        simplification  rules.  The  pattern may  not  be a
        sum, product, single variable, or number.
        RULES  is  a list  of  names  having simplification
        rules added to them by DEFRULE, DEFMATCH, TELLSIMP,
        or TELLSIMPAFTER.

        (C1) MATCHDECLARE(X,FREEOF(%I))$
        (C2) TELLSIMP(SIN(%I*X),%I*SINH(X));
        RULE PLACED ON SIN

        (D2)            [SINRULE1, SIMP-SIN]



        (SINRULE1 is the name assigned to the TELLSIMP rule
        from (C2) and SIMP-SIN is the internal name  of the
        built-in simplifier rule.)

        (C3) TRIGEXPAND(SIN(X+%I*Y));

        (D3)            SIN(X) COS(%I Y) + %I COS(X) SINH(Y)
        (C4) 0^0;
        0^0 HAS BEEN GENERATED
        (C5) BLOCK([SIMP],SIMP:FALSE,TELLSIMP(0^0,1));

        RULE PLACED ON **
        (D5)                       [**RULE1, SIMPEXPT]

        (C6) 0^0;
        (D6)                                1

        (C7) REMRULE("**","**RULE1");
        (D7)                            [ SIMPEXPT ]



    &DEFMATCH(progname, pattern, parm1, ..., parmn) creates
        a function of n+1 arguments with the  name progname
        which tests an expression to see if it can  match a
        particular pattern.  The pattern is some expression
        containing pattern  variables and  parameters.  The
        parms are given explicitly as arguments to DEFMATCH
        while  the  pattern  variables  (if  supplied) were
        given   implicitly  in   a   previous  MATCHDECLARE
        function.   The  first  argument  to   the  created
        function progname, is  an expression to  be matched
        against the "pattern" and the other n arguments are
        the  actual variables  occurring in  the expression
        which  are to  take  the place  of  dummy variables
        occurring in the "pattern".  Thus the parms  in the
        DEFMATCH  are  like  the  dummy  arguments  to  the
        SUBROUTINE statement in FORTRAN.  When the function
        is "called"  the actual arguments  are substituted.
        For example:

        (C1)  NONZEROANDFREEOF(X,E):=  IF E#0 AND FREEOF(X,E)
                    THEN TRUE ELSE FALSE$


        (IS(E#0 AND FREEOF(X,E)) is an  equivalent function
        definition - see sect. 6.12 )

        (C2)  MATCHDECLARE(A,NONZEROANDFREEOF(X),B,FREEOF(X))$
        (C3)  DEFMATCH(LINEAR,A*X+B,X)$


            This has  caused the  function LINEAR(exp,var1)



        to be defined.  It tests exp to see if it is of the
        form A*var1+B where A and B do not contain var1 and
        A is not zero.  DEFMATCHed functions return (if the
        match is successful) a list of equations whose left
        sides are the pattern variables and parms and whose
        right sides are  the expressions which  the pattern
        variables  and  parameters  matched.   The  pattern
        variables, but not  the parameters, are set  to the
        matched  expressions.   If  the  match  fails,  the
        function        returns         FALSE.         Thus
        LINEAR(3*Z+(Y+1)*Z+Y**2,Z)  would  return  [B=Y**2,
        A=Y+4, X=Z].  Any variables not declared as pattern
        variables  in  MATCHDECLARE  or  as  parameters  in
        DEFMATCH  which occur  in pattern  will  match only
        themselves  so that  if the  third argument  to the
        DEFMATCH  in  (C4) had  been  omitted,  then LINEAR
        would only  match expressions linear  in X,  not in
        any other variable.

            A  pattern  which  contains  no  parameters  or
        pattern  variables   returns  TRUE  if   the  match
        succeeds.

        (C1) MATCHDECLARE([A,F],TRUE)$

        (C2) CONSTINTERVAL(L,H):=CONSTANTP(H-L)$

        (C3) MATCHDECLARE(B,CONSTINTERVAL(A))$

        (C4) MATCHDECLARE(X,ATOM)$

        (C5) DEFMATCH(CHECKLIMITS,'INTEGRATE(F,X,A,B))$

        (C6) 'INTEGRATE(SIN(T),T,X+%PI,X+2*%PI)$

        (C7) CHECKLIMITS(%);

        (D7)  [B = X + 2 %PI, A = X + %PI, X = T,

                                       F = SIN(T)]

        (C8) 'INTEGRATE(SIN(T),T,0,X)$

        (C9) CHECKLIMITS(%);

        (D9)                    FALSE



    &DEFRULE(rulename,  pattern,  replacement)  defines and
        names a replacement rule for the given pattern.  If
        the rule named rulename is applied to an expression
        (by  one  of  the  APPLY  functions  below),  every



        subexpression matching the pattern will be replaced
        by   the   replacement.   All   variables   in  the
        replacement which have been assigned values  by the
        pattern  match  are assigned  those  values  in the
        replacement  which  is then  simplified.  The rules
        themselves can be  treated as functions  which will
        transform  an expression  by one  operation  of the
        pattern  match  and  replacement.   If  the pattern
        fails, the original expression is returned.


    &APPLY1(exp, rule1, ..., rulen) repeatedly  applies the
        first rule to  exp until it fails,  then repeatedly
        applies the same rule to all subexpressions of exp,
        left-to-right, until the  first rule has  failed on
        all   subexpressions.     Call   the    result   of
        transforming  exp in  this manner  exp'.   Then the
        second rule is applied in the same fashion starting
        at the top of  exp'.  When the final rule  fails on
        the   final  subexpression,   the   application  is
        finished.


    &APPLY2(exp, rule1, ..., rulen) differs from  APPLY1 in
        that   if  the   first  rule   fails  on   a  given
        subexpression, then  the second rule  is repeatedly
        applied, etc.   Only if  they all  fail on  a given
        subexpression is the whole set of  rules repeatedly
        applied to the  next subexpression.  If one  of the
        rules  succeeds,  then  the  same  subexpression is
        reprocessed, starting with the first rule.
        MAXAPPLYDEPTH[10000] is the maximum depth  to which
        APPLY1 and APPLY2 will delve.


    &APPLYB1(exp, rule1, ...,  rulen) is similar  to APPLY1
        but works from the "bottom up" instead of  from the
        "top  down".  That  is, it  processes  the smallest
        subexpression of exp, then the next smallest, etc.
        MAXAPPLYHEIGHT[10000]  - is  the maximum  height to
        which APPLYB1 will reach before giving up.


    &LETSIMP(exp) will  continually apply  the substitution
        rules previously defined  by the function  LET (see
        below) until no further change is made to exp.


    &LET(prod,  repl,  predname,  arg1,  arg2,  ...,  argn)
        defines a substitution  rule for LETSIMP  such that
        prod gets replaced by  repl.  prod is a  product of
        positive or negative powers of the  following types
        of terms:



            (1)  Atoms   which  LETSIMP  will   search  for
        literally  unless previous  to calling  LETSIMP the
        MATCHDECLARE  function  is  used  to   associate  a
        predicate with the atom.  In this case LETSIMP will
        match the atom to any term of a  product satisfying
        the predicate.

            (2) Kernels  such as  SIN(X), N!,  F(X,Y), etc.
        As with atoms above LETSIMP will look for a literal
        match unless  MATCHDECLARE is  used to  associate a
        predicate with the argument of the kernel.

            A term  to a positive  power will only  match a
        term having at  least that power in  the expression
        being LETSIMPed.  A term to a negative power on the
        other hand will only  match a term with a  power at
        least as negative.  In the case of  negative powers
        in "product" the switch LETRAT must be set  to TRUE
        (see below).

            If a predicate is included in the  LET function
        followed by a list of arguments, a  tentative match
        (i.e. one that  would be accepted if  the predicate
        were   omitted)   will   be   accepted    only   if
        predname(arg1',...,argn')  evaluates to  TRUE where
        argi' is the value  matched to argi.  The  argi may
        be  the name  of any  atom or  the argument  of any
        kernel appearing in prod.  repl may be any rational
        expression.  If any of the atoms or  arguments from
        prod appear  in repl the  appropriate substitutions
        will be made.

            LETRAT[FALSE] when FALSE, LETSIMP will simplify
        the numerator and denominator of expr independently
        and return the result.  Substitutions such  as N!/N
        goes  to   (N-1)!  will   fail.   To   handle  such
        situations LETRAT should  be set to TRUE,  then the
        numerator, denominator, and their quotient  will be
        simplified in that order.

            These substitution functions allow you  to work
        with several rulepackages at once. Each rulepackage
        can  contain  any  number  of  LETed  rules  and is
        refered to  by a user  supplied name.  To  insert a
        rule    into     the    rulepackage     name,    do
        LET([prod,repl,pred,arg1,...],name).  To  apply the
        rules in rulepackage name, do  LETSIMP(expr, name).
        The   function   LETSIMP(expr,name1,name2,...)   is
        equivalent to doing LETSIMP(expr,name1) followed by
        LETSIMP(%,name2) etc.

            There is  a default  rulepackage name  which is
        assumed when  no other name  is supplied to  any of



        the   functions.    Whenever  a   LET   includes  a
        rulepackage name the default rulepackage is made to
        look like that rulepackage.


    &REMLET(prod, name) deletes the substitution rule, prod
        -->  repl,  most   recently  defined  by   the  LET
        function.  If name is supplied the rule  is deleted
        from   the   rule   package   name.   REMLET()  and
        REMLET(ALL,name) delete all substitution rules from
        the default  rulepackage. If  name is  supplied the
        rulepackage, name, is also deleted.
        If a substitution is  to be changed using  the same
        product, REMLET need  not be called,  just redefine
        the substitution using the same product (literally)
        with  the  LET  function  and  the  new replacement
        and/or predicate name.  Should  REMLET(product) now
        be called  the original  substitution rule  will be
        revived.


    &LETRULES(name) and LETRULES() display the rules in the
        default  rulepackage  and  the  rulepackage,  name,
        respectively.      Note    that     the    function
        LETRULES(name) will set the default  rulepackage to
        the rulepackage, name.

        (C1) MATCHDECLARE([A1,A2],TRUE)$

        (C2) ONELESS(X,Y):=IS(EQUAL(X,Y-1))$

        (C3) LET(A1*A2!,A1!,ONELESS,A2,A1);

        (D3)         A1 A2! --> A1! WHERE ONELESS(A2, A1)

        (C4) LETRAT:TRUE$

        (C5) LET(A1!/A1,(A1-1)!);

                                A1!
        (D5)                    --- --> (A1 - 1)!
                                A1

        (C6) LETSIMP(N*M!*(N-1)!/M);

        (D6)                      (M - 1)! N!



    &POISSIMP(A) converts A into a Poisson series for  A in
        general representation.


    &INTOPOIS(A) converts A into a Poisson encoding.



    &OUTOFPOIS(A)  converts  A  from  Poisson  encoding  to
        general  representation.  If  A is  not  in Poisson
        form,  it will  make the  conversion, i.e.  it will
        look  like  the  result  of OUTOFPOIS(INTOPOIS(A)).
        This function  is thus  a canonical  simplifier for
        sums of powers of  SIN's and COS's of  a particular
        type.


    &PRINTPOIS(A)  prints a  Poisson series  in  a readable
        format.  In common with OUTOFPOIS, it  will convert
        A into a Poisson encoding first, if necessary.


    &POISTIMES(A,   B)   is   functionally   identical   to
        INTOPOIS(A*B).


    &POISTRIM() is a  reserved function name which  (if the
        user has  defined it)  gets applied  during Poisson
        multiplication.  It  is a  predicate function  of 6
        arguments  which  are the  coefficients  of  the U,
        V,..., Z  in a term.   Terms for which  POISTRIM is
        TRUE  (for  the  coefficients  of  that  term)  are
        eliminated during multiplication.


    &POISPLUS(A,   B)   is   functionally    identical   to
        INTOPOIS(A+B).


    &POISEXPT(A, B) (B a positive integer)  is functionally
        identical to INTOPOIS(A**B).


    &POISDIFF(A, B) differentiates A with respect to  B.  B
        must occur  only in the  trig arguments or  only in
        the coefficients.


    &POISINT(A,  B)  integrates in  a  similarly restricted
        sense (to POISDIFF).   Non-periodic terms in  B are
        dropped if B is in the trig arguments.


    &POISSUBST(A, B, C) substitutes A  for B in C.  C  is a
        Poisson series.
        (1) Where B is a variable U, V, W, X, Y, or  Z then
        A must be  an expression linear in  those variables
        (e.g. 6*U+4*V).

            (2) Where B is other than those variables, then
        A  must  also  be  free  of  those  variables,  and
        furthermore, free of sines or cosines.



    &POISSUBST(A,  B,  C,  D,  N)  is  a  special  type  of
        substitution which operates on  A and B as  in type
        (1) above, but where D is a Poisson series, expands
        COS(D) and SIN(D) to  order N so as to  provide the
        result of substituting A+D for B in C.  The idea is
        that  D  is  an  expansion  in  terms  of  a  small
        parameter.  For  example, POISSUBST(U,V,COS(V),E,3)
        results in COS(U)*(1-E^2/2) - SIN(U)*(E-E^3/6).


    &POISMAP(series, sinfn,  cosfn) will map  the functions
        sinfn on  the sine  terms and  cosfn on  the cosine
        terms of the poisson series given.  sinfn and cosfn
        are  functions  of   two  arguments  which   are  a
        coefficient and a  trigonometric part of a  term in
        series respectively.

        (C1) PFEFORMAT:TRUE$

        (C2) (2*A^2-B)*COS(X+2*Y)-(A*B+5)*SIN(U-4*X);

        (D2)        - (A B + 5) SIN(U - 4 X)

                              2
                        + (2 A  - B) COS(2 Y + X)

        (C3) POISEXPT(%,2)$

        (C4) PRINTPOIS(D3);

            2
        (2 A  - B) ( - A B - 5) SIN( - 2 Y - 5 X + U)

            2
        (2 A  - B) ( - A B - 5) SIN(2 Y - 3 X + U)

                          2
        - 1/2 ( - A B - 5)  COS(2 U - 8 X)

                2     2                   2
        1/2 (2 A  - B)  + 1/2 ( - A B - 5)

                2     2
        1/2 (2 A  - B)  COS(4 Y + 2 X)

        (D4)                               DONE

        (C5) POISINT(D3,Y)$

        (C6) OUTOFPOIS(%);



                     2     2
        (D6) 1/8 (2 A  - B)

                                         2
                SIN(4 Y + 2 X) - 1/2 (2 A  - B) ( - A B - 5)

                                             2
                COS(2 Y - 3 X + U) + 1/2 (2 A  - B) ( - A B - 5)

                COS( - 2 Y - 5 X + U)

        (C7) OUTOFPOIS(SIN(X)^5+COS(X)^5);

        (D7) 1/16 SIN(5 X) + 1/16 COS(5 X) - 5/16 SIN(3 X)

                + 5/16 COS(3 X) + 5/8 SIN(X) + 5/8 COS(X)


            One or  two final  points: the  coefficients in
        the arguments of the  trig functions must fit  in a
        pre-arranged domain.  Initially  this is set  to [-
        15,16] but can  be set to [-2^(n-1)+1,  2^(n-1)] by
        the command POISLIM(n).  This should not be done in
        the middle of a calculation.  Also, it  is possible
        to define the  coefficient arithmetic to  be almost
        anything.  The user (probably in conjunction with a
        LISP-MACSYMA programmer)  must define  the programs
        needed  to  add, multiply,  substitute,  encode and
        decode the coefficients.   The encoding for  +1 and
        -1 and  a program to  test for 0  (zero), completes
        each  package.   These packages  are  available for
        coefficients  being  CRE  form,   polynomials  with
        floating point  coefficients, and  polynomials with
        rational  number coefficients,  in addition  to the
        default general MACSYMA form.

            If all coefficients  of trig terms  are desired
        in      CRE     form,      the      user     should
        LOADFILE(POIS3,FASL,DSK,MACSYM)                 and
        LOADFILE(RATPOI,FASL,DSK,MACSYM).     Only    those
        variables on  the RATVARS list  can be used  in the
        coefficients.   In many  instances this  is  a much
        more efficient technique in terms of speed.


    &SETUP() of no arguments presents several options which
        are self-explanatory.   First the user  chooses the
        kind of metric to be used---whether it will  be one
        of  the  standard metrics  already  stored  in some
        file, or a power-series approximation, or  some new
        metric  to  be  specified  (perhaps  only  a slight
        modification  of a  metric already  defined). After
        the  metric  has   been  specified,  a   number  of



        simplification  options are  provided  which govern
        the  rational simplification  and factoring  of the
        tensor components  to be computed.   The particular
        quantity to be computed can then be  indicated; the
        user can say whether the results (some of which may
        be quite lengthy)  are to be  immediately displayed
        or not.
        Here is a sample protocol:


        
        (C2) SETUP();
        DO YOU WANT
        1 - TO CONSIDER A METRIC IN THE SPECIAL METRIC FILE?
        2 - TO APPROXIMATE A METRIC WITH A POWER SERIES?
        3 - TO ENTER A NEW METRIC?
        TYPE 1 OR 2 OR 3  
        3;
        
        SPECIFY THE COORDINATES AS A LIST OF FOUR ELEMENTS  
        [R,THETA,PHI,T];
        DO YOU WANT
        1 - TO SPECIFY  A DIAGONAL METRIC?
        2 - TO CHANGE A COMPONENT IN A PREVIOUSLY DEFINED
                METRIC?
        3 - TO SPECIFY A GENERAL (SYMMETRIC) METRIC?
        TYPE 1 2  OR  3  
        1;
        
        ENTER DIAGONAL MATRIX
        [1, 1]  
        -EXP(M);
        [2, 2]  
        -R^2;
        [3, 3]  
        -R^2*SIN(THETA)^2;
        [4, 4]  
        EXP(N);
        
        INDICATE THE KIND OF SIMPLIFICATION YOU WANT
        
        1 - RATIONAL SIMPLIFICATION ONLY
        2 - FACTORING AND RATIONAL SIMPLIFICATION
        3 - EXPANSION 
        TYPE 1 2 OR 3  
        2;
        


    &CHRISTOF(dis) computes the Christoffel symbols of both
        kinds; the  argument,dis, determines  which results
        are to  be immediately displayed.   The Christoffel
        symbols of the first  kind are stored in  the array



        LCS[I,J,K].  If the argument to CHRISTOF  were LCS,
        all  the  non-zero values  of  LCS[I,J,K]  would be
        displayed.

            The  Christoffel  symbols  of  the  second kind
        (Mixed Christoffel Symbols) are given by  the array
        MCS[I,J,K]; in the example below, the  argument MCS
        was given resulting in the immediate display of all
        the non-zero mixed Christoffel symbols.

        (C3) CHRISTOF(MCS);
                                                  M
                                                   R
        (E3)                         MCS        = --
                                        1, 1, 1   2
                                                   1
        (E4)                          MCS        = -
                                         1, 2, 2   R
                                                   1
        (E5)                          MCS        = -
                                         1, 3, 3   R
                                                  N
                                                   R
        (E6)                         MCS        = --
                                        1, 4, 4   2
                                                   - M
        (E7)                      MCS        = - %E    R
                                     2, 2, 1
                                              COS(THETA)
        (E8)                     MCS        = ----------
                                    2, 3, 3   SIN(THETA)
                                             - M      2
        (E9)                MCS        = - %E    R SIN (THETA)
                               3, 3, 1
        (E10)              MCS        = - COS(THETA) SIN(THETA)
                              3, 3, 2
                                                 N - M
                                               %E      N
                                                        R
        (E11)                     MCS        = ----------
                                     4, 4, 1       2

        (D11)                              DONE


    &MOTION(dis)  gives  the geodesic  equations  of motion
        corresponding to a  given metric.  They  are stored
        in the  array EM[I].  If  the argument dis  is TRUE
        then these equations are displayed.


    &RICCICOM(dis)   This  function   first   computes  the
        contravariant  components  LR[I,J]  of   the  Ricci



        tensor (LR is a mnemonic for "lower  Ricci").  Then
        the  mixed  Ricci  tensor  is  computed  using  the
        covariant  metric  tensor.   If  the  value  of the
        argument  to  RICCICOM is  TRUE,  then  these mixed
        components,  RICCI[I,J] (the  index I  is covariant
        (down)  and the  index J  is contravariant  (up) ),
        will    be    displayed    directly.     Otherwise,
        RICCICOM(FALSE) will simply compute the  entries of
        the   array  RICCI[I,J]   without   presenting  the
        results.



        (C13) RICCICOM(TRUE);
        (E13) RICCI
                   1, 1

                   - M               2
                 %E    ((2 N    + (N )  - M  N ) R - 4 M )
                          R R     R      R  R         R
               = -----------------------------------------
                                  4 R
                               - M                    M
                             %E    ((M  - N ) R + 2 %E  - 2)
                                      R    R
        (E14)  RICCI     = - -------------------------------
                    2, 2                     2
                                          2 R

                               - M                    M
                             %E    ((M  - N ) R + 2 %E  - 2)
                                      R    R
        (E15)  RICCI     = - -------------------------------
                    3, 3                     2
                                          2 R
        (E16)  RICCI
                    4, 4

                         - M                2
                       %E    ((2 N    + (N )  - M  N ) R + 4 N )
                                  R R     R      R  R         R
                     = -----------------------------------------
                                          4 R

        (D16)                              DONE


    &NTERMSRCI()  returns  a list  of  pairs,  whose second
        elements  give the  number  of terms  in  the RICCI
        component specified by the first elements.  In this
        way, it  is possible to  quickly find  the non-zero
        expressions and attempt simplification.



    &LRICCICOM(dis)   computes  the   covariant  components
        LR[I,J] of the  Ricci tensor.  If the  argument dis
        is   TRUE,   then  the   non-zero   components  are
        displayed.


    &EINSTEIN(dis)  computes the  Einstein tensor  once the
        Christoffel  symbols  and  Ricci  tensor  have been
        obtained.   Again,  if  the  argument  evaluates to
        TRUE,  then  the non-zero  values  of  the Einstein
        tensor G[I,J]  will be  displayed. RATEINSTEIN:TRUE
        will  perform  rational  simplification   on  these
        components; if FACRAT:TRUE then the components will
        also be factored.


    &NTERMSG() gives the user a quick picture of the "size"
        of the Einstein tensor.  It returns a list of pairs
        whose second elements  give the number of  terms in
        the components specified by the first elements.


    &SCURVATURE() returns the scalar curvature (obtained by
        contracting  the  Ricci tensor)  of  the Riemannian
        manifold with the given metric.


    &RIEMANN(dis)  computes  the  Riemann  curvature tensor
        from  the  given  metric  (the  Christoffel symbols
        should be obtained  first using CHRISTOF).   If dis
        is TRUE, the non-zero components R[I,J,K,L] will be
        displayed. All the indicated indices are covariant.
        As with the  Einstein tensor, various  switches set
        by  the  user  control  the  simplification  of the
        Riemann   components.    If   RATRIEMAN:TRUE,  then
        rational   simplification   will   be    done;   if
        FACRAT:TRUE then each  of the components  will also
        be factored.


        (C27) RIEMANN(TRUE);
                                                   M  R
                                                    R
        (E27)                      R           = - ----
                                    1, 2, 1, 2      2
                                                     2
                                             M  R SIN (THETA)
                                              R
        (E28)                R           = - ----------------
                              1, 3, 1, 3            2



                                 N          N     2        N
                           - 2 %E  N    - %E  (N )  + M  %E  N
                                    R R         R      R      R
        (E29) R          = ------------------------------------
               1, 4, 1, 4                          4
                                 M        - M  2    2
        (E30) R           = - (%E  - 1) %E    R  SIN (THETA)
               2, 3, 2, 3
                                                 N - M
                                               %E      N  R
                                                        R
        (E31)                  R           = - ------------
                                2, 4, 2, 4          2
                                   N - M         2
                                 %E      N  R SIN (THETA)
                                          R
        (E32)    R           = - ------------------------
                  3, 4, 3, 4                2

        (D32)                              DONE


    &RAISERIEMANN(dis) returns the contravariant components
        of the Riemann  curvature tensor as  array elements
        UR[I,J,K,L].  These are displayed if dis is TRUE.


    &RINVARIANT()  forms the  scalar invariant  obtained by
        contracting R[I,J,K,L]*UR[I,J,K,L].



        (C34) RINVARIANT();
                -2M           2          2                     4
        (D34) %E    ((4 (N   )  + (4 (N )  - 4 M  N ) N   + (N )
                          R R          R        R  R   R R    R

                    3       2     2   4          2         2   2
         - 2 M  (N )  + (M )  (N ) ) R  + (8 (N )  + 8 (M ) ) R
              R   R       R     R              R         R

                2 M        M           4
         + 16 %E    - 32 %E  + 16)/(4 R )



    &WEYL(dis) computes the  Weyl conformal tensor.  If the
        argument  dis  is  TRUE,  the  non-zero  components
        W[I,J,K,L]   will   be  displayed   to   the  user.
        Otherwise, these components will simply be computed
        and stored.  If the switch RATWEYL is set  to TRUE,
        then the components will be  rationally simplified;
        if FACRAT is TRUE then the results will be factored
        as well.



    &DSCALAR(function) applies the scalar  d'Alembertian to
        the scalar function.


        (C41) DEPENDENCIES(FIELD(R));
        (D41)                           [FIELD(R)]

        (C42) DSCALAR(FIELD);

        (D43)
            -M
          %E  ((FIELD  N - FIELD  M + 2 FIELD   ) R + 4 FIELD )
                     R  R       R  R         R R             R
        - -----------------------------------------------------
                                     2 R


    &SHOW(exp) will display exp with the indexed objects in
        it    shown    having    covariant    indices    as
        subscripts,contravariant  indices  as superscripts.
        The  derivative   indices  will  be   displayed  as
        subscripts, separated from the covariant indices by
        a comma.


    &LC(L) is the permutation (or Levi-Civita) tensor which
        yields  1  if  the  list  L  consists  of  an  even
        permutation of  integers, -1 if  it consists  of an
        odd permutation,  and 0  if some  indices in  L are
        repeated.


    &DELTA(L1,L2)  is   the  generalized   Kronecker  delta
        function.  L1  and L2 are  lists of indices  of the
        same length.

        a) If L1  and L2 have  a single member,  say L1=[a]
        and L2=[b].  Then

                1) if the index a is identical  to the
            index  b  and  they  are  non-numeric, the
            value of the  function DELTA is  the value
            of the variable DIMENSION  [default value:
            4];
                2)  if a  and b  are numeric  then the
            value  of the  function is  1 if  they are
            equal, else 0;
                3) otherwise the noun form of DELTA.
        b) If L1=[a1,a2] and L2=[b1,b2]. Then the  value of
        the function is

        DELTA([a1],[b1])*DELTA([a2],[b2])
                - DELTA([a1],[b2])*DELTA([a2],[b1])



        c)  If L1  and L2  have more  than two  indices the
        result generalizes.


    &CHR1([i,j,k])  yields  the Christoffel  symbol  of the
        first kind

                   1/2(g      + g      - g     )
                        ik,j     jk,i     ij,k

        The variable METRIC must be assigned the name  of a
        function   (which   can   be   either   defined  or
        undefined); in the above example, METRIC:g.


    &CHR2([i,j],[k]) yields  the Christoffel symbol  of the
        second kind.

                                  ks
               CHR2([i,j],[k]) = g    CHR1([i,j,s])


    &RIEMANN([i,j,k],[l])  yields  the   Riemann  curvature
        tensor in terms  of the Christoffel symbols  of the
        second  kind  (CHR2).   Suppose  the  function name
        specified by the  value of METRIC corresponds  to a
        function which has been given some structure  via a
        function  definition;  in  order  to  evaluate  the
        Riemann tensor  incorporating this  given structure
        of  the metric,  first  apply UNDIFF  to  obtain an
        equivalent   expression,   say   exp;    then   use
        EV(exp,chr2,diff).

        Consider the following example involving  a metric,
        G, expressed  in terms of  the rank two  tensors, P
        and E; the covariant and contravariant forms of the
        metric  are specified  within the  same  function G
        representing the metric.

        (C8) G(L1,L2):=
        BLOCK([A,B],IF L2=[]
        THEN [A:L1[1],B:L1[2],RETURN(E(L1,[])*(1+2*L*P([],[]))-
        4*L*P(L1,[])
        )],
        A:L2[1],B:L2[2],E([],L2)*(1-2*L*P([],[]))+4*L*P([],L2)
        )$

            Note  that  a   BLOCK  is  necessary   in  this
        definition  since  the arguments  on  the  left are
        lists yet the metric structure is given in terms of
        the members of those lists.
        Now the contraction properties of the metric  G are
        declared (see DEFCON):



        (C10) METRIC:G$

        (C11) DEFCON(G)$
        The  tensor   E  is   declared  constant   and  its
        contraction properties are described:

        (C14) DECLARE(E,CONSTANT)$

        (C15) DEFCON(E)$

        (C16) DEFCON(E,E,DELTA)$

        The Ricci  tensor is easily  expressed in  terms of
        the  Riemann tensor,  using the  Einstein summation
        convention:


        (C17) RICCI:RIEMANN([I,J,K],[J])$

        (C18) SHOW(%);
              J           J        !1        J
        - CHR2      - CHR2     CHR2    + CHR2
              I K,J       !1 J     I K       I J,K

                      J        !1
                + CHR2     CHR2
                      !1 K     I J
        (D18)                              DONE


            To   prepare   for   the   evaluation   of  the
        Christoffel   symbols  in   terms  of   the  metric
        structure, the function UNDIFF is applied:

        (C19) RICCI:UNDIFF(RICCI)$

        Now evaluation and differentiation  proceeds, using
        the structure given to the metric above.

        (C20) RICCI:EV(RICCI,CHR2,DIFF)$


            Finally,  the  result  is  expanded,  truncated
        (with respect to the parameter L), and contracted:


        (C23) RATWEIGHT(L,1)$

        (C24) RATWTLVL:1$

        (C25) TAKEGCD:FALSE$

        (C27) RICCI:RATEXPAND(D20)$



        (C28) CONTRACT(%)$

        (C29) SHOW(%);
           !1            !1 !2
        2 P       L - 2 E      P          L + P
           K,!1 I               I K,!1 !2      ,!1 !2

         !1 !2            !1
        E     E    L + 2 P       L
               I K        I,!1 K


    &CONTRACT(exp) carries out all possible contractions in
        exp, which  may be  any well-formed  combination of
        sums   and  products.    This  function   uses  the
        information  given to  the DEFCON  function.  Since
        all tensors are  considered to be symmetric  in all
        indices, the  indices are sorted  into alphabetical
        order.  Also  all dummy  indices are  renamed using
        the symbols !1,!2,...  to permit the  expression to
        be  simplified  as  much  as  possible  by reducing
        equivalent  terms to  a canonical  form.   For best
        results exp should be fully expanded.
        RATEXPAND   ((see  ))   is  the   fastest   way  to
        expand products and powers of sums if there  are no
        variables in  the denominators  of the  terms.  The
        TAKEGCD switch should be FALSE if gcd cancellations
        are unnecessary.


    &DEFCON(tensor1,<tensor2,tensor3>)  gives  tensor1  the
        property  that  the  contraction  of  a  product of
        tensor1  and tensor2  results in  tensor3  with the
        appropriate   indices.   If   only   one  argument,
        tensor1,  is  given, then  the  contraction  of the
        product of tensor1  with any indexed  object having
        the appropriate indices (say tensor) will  yield an
        indexed object with that name,i.e.tensor,  and with
        a new  set of  indices reflecting  the contractions
        performed.

            For example, if METRIC: G, then  DEFCON(G) will
        implement  the  raising  and  lowering  of  indices
        through contraction with the metric tensor.
            More than one DEFCON can be given for  the same
        indexed object; the latest one given  which applies
        in a particular contraction will be used.
            CONTRACTIONS is a list of those indexed objects
        which have  been given contraction  properties with
        DEFCON.


    &DISPCON(tensor1,tensor2,...) displays  the contraction



        properties of the tensori as were given  to DEFCON.
        DISPCON(ALL)    displays   all    the   contraction
        properties which were defined.


    &REMCON(tensor1,tensor2,...)     removes     all    the
        contraction    properties    from    the   tensori.
        REMCON(ALL) removes all contraction properties from
        all indexed objects.


    &DUMMY(i1,i2,...) will set each index i1,i2,... to name
        of the form !n where n is a positive integer.  This
        guarantees that dummy  indices which are  needed in
        forming expressions will not conflict  with indices
        already in use.
        COUNTER[default 1] determines the  numerical suffix
        to be used in generating the next dummy index.  The
        prefix is determined by the option DUMMYX[!].


    &DIFF(exp,v1,n1,v2,n2,...)   is   the   usual   MACSYMA
        differentiation function;  it takes  the derivative
        of exp wrt v1 n1 times, wrt v2 n2 times,  etc.  For
        the  tensor  package,  the  following modifications
        have been incorporated:
        1) the  derivatives of any  indexed objects  in exp
        will have the  variables vi appended  as additional
        arguments.  Then all the derivative indices will be
        sorted.

            2)  the vi  may be  integers from  1 up  to the
        value of the variable DIMENSION[default  value: 4].
        This will cause  the differentiation to  be carried
        out  wrt the  vith member  of the  list COORDINATES
        which should be set to  a list of the names  of the
        coordinates,  e.g., [x,y,z,t]  . If  COORDINATES is
        bound  to an  atomic variable,  then  that variable
        subscripted by vi will be used for the  variable of
        differentiation.    This   permits   an   array  of
        coordinate  names or  subscripted names  like X[1],
        X[2],...  to be used.  If COORDINATES has  not been
        assigned  a  value,  then  the  variables  will  be
        treated as in 1) above.


    &COVDIFF(exp,v1,v2,...) yields the covariant derivative
        of exp with respect to the variables vi in terms of
        the Christoffel symbols of the second  kind (CHR2).
        In  order  to   evaluate  these,  one   should  use
        EV(exp,CHR2).



    &UNDIFF(exp)  returns an  expression equivalent  to exp
        but  with   all  derivatives  of   indexed  objects
        replaced by the noun form of the DIFF function with
        arguments which would yield that indexed  object if
        the  differentiation  were  carried  out.   This is
        useful   when   it   is   desired   to   replace  a
        differentiated  indexed object  with  some function
        definition and  then carry out  the differentiation
        by saying EV(...,DIFF).


    &LORENTZ(exp) yields  exp with  indexed objects  have a
        derivative index identical to a contravariant index
        replaced   by   zero,   implementing   the  Lorentz
        condition.


    &INDICES(exp)  returns  a list  of  two  elements.  The
        first is a list  of the free indices in  exp (those
        that occur  only once); the  second is the  list of
        dummy  indices  in exp  (those  that  occur exactly
        twice).


    &RENAME(exp)  returns an  expression equivalent  to exp
        but with the dummy indices in each term chosen from
        the set [!1,!2,...].  Each dummy index in a product
        will be  different; for  a sum  RENAME will  try to
        make  each  dummy  index in  a  sum  the  same.  In
        addition,    the    indices    will    be    sorted
        alphanumerically.


    &MAKEBOX(exp) will  display exp in  the same  manner as
        SHOW; however,  any tensor  d'Alembertian occurring
        in exp will be indicated using the symbol  [].  For
        example,           []P([M],[N])          represents
        G([],[I,J])*P([M],[N],I,J).


    &CAN(exp) reduces exp to canonical form  and simplifies
        the expression as much as possible by  renaming and
        permuting dummy indices. The expression exp must be
        fully expanded.
        As an  example of the  kind of  simplification this
        function  achieves, consider  the following  sum of
        tensor "monomials":


        (C4) P([I,J,S,V],[M,N,Q],V)*P1([Q,T],[R,S])

                *P2([R,L,M,N,U],[I,J,K])  +

                P2([L,N,U],[R,M,I,J,K])



                *P([M,I,J,V],[N,Q,S],V)*P1([R,S,Q,T],[])$

        (C6) SHOW(D4);

          R M I J K  N Q S                  M N Q
        P2          P          P1        + P
          L N U      M I J V,V   R S Q T    I J S V,V

                  R S   I J K
                P1    P2
                  Q T   R L M N U

        (D6)                               DONE

        (Recall  that  the tensors  are  assumed completely
        symmetric)

        The function RENAME renames the dummy indices:

        (C7) SHOW(RENAME(D4));

         !6 !7 !8         !2 !3 K        !4 !5
        P               P2             P1
         !1 !2 !3 !5,!1   !4 !6 !7 L U   !8 T

                  !3 !4 !8                      !2 !5 !6 !7 K
               + P               P1           P2
                  !1 !5 !6 !7,!1   !2 !3 !4 T   !8 L U

        (D7)                               DONE


        but is  not able  to notice that  by a  sequence of
        raising  and  lowering  operations,   the  original
        expression can be transformed into

        (C8) SHOW(CAN(D4));
                             I J K M N   Q R S
        2 P                P2          P1
           I J M N Q S V,V   L R U       T


        (D8)                               DONE


    &PLOT(F(x), x, low,  high) - Plots the  expression F(x)
        over the domain low < x < high.


    &PLOT(F(x),  x, low,  high,  INTEGER) -  As  above, but
        plots F(x) only for integer values of x.



    &PLOT(F(x),  x,  [x1, x2,  x3,  ..., xn])  -  Plots the
        function F(x) for the values x1,x2,x3,...,xn.


    &PARAMPLOT(f1(t),f2(t),t,low,high)   plots   the  plane
        curve f(t) =  (f1(t),f2(t)) with parameter  t.  The
        syntax  is  basically  like  that  of   plot.   For
        example,

        PARAMPLOT(COS(T),SIN(T),T,0,2*%PI)


    &PARAMPLOT([f1(t),  g1(t), ...  h1(t)],  [f2(t), g2(t),
        ...,  h2(t)],  t,  low,  high,  [list  of  plotting
        characters])  -  Plots  the  plane  curves  f(t)  =
        (f1,f2),  g(t) =  (g1,g2),...,h(t) =  (h1,h2) using
        the  specified plotting  characters or  the default
        "*".  For example,

        PARAMPLOT([COS(T),COS(T)+7],[SIN(T),SIN(T)],
                        T,0,2*%PI,["@"])

        plots two circles.


    &GRAPH([x1, x2, x3, ..., xn], [y1, y2, y3, ...,  yn]) -
        Graphs the two sets of data points.


    &GRAPH([[x1, y1],  [x2, y2], ...,  [xn, yn]])  - Graphs
        the  points  specified by  the  list  of coordinate
        pairs.


    &GRAPH(xset, [yset1, yset2,..., ysetn],optional-args) -
        allows  graphing of  one x-domain  with  several y-
        ranges; e.g. GRAPH([0,1],[[0,1],[1,2]],["&"]).


    &MULTIGRAPH([[xset1,  yset1],  ...,   [xsetn,  ysetn]],
        optional-args)  -  allows  the  user  to  produce a
        scatter-graph involving several x-domains each with
        a           single           y-range;          e.g.
        MULTIGRAPH([[[0,1],[0,1]],[[3,4],[1,2]]],["&"]).
&