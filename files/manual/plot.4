.chap(Complex Plotting and Graphics---PLOT2,plot2)

.sec(Introduction,plot2intro)

This is a description of the functions contained in the following 6
files:
.once center
APLOT2 > ARC CFFK,   TEKPLT > ARC CFFK,  PLOT3D > ARC CFFK
.once center
WORLD  > ARC CFFK,   PRINT  > ARC CFFK,  IFFUN  > ARC CFFK.
.bcon
They will be loaded up as needed when most of the functions below are
used.  However to get the "complete" PLOT2 environment, LOADFILE(PLOT2,LISP,DSK,SHARE) is recommended.  This loads incomplete AUTOLOAD properties for the functions described below.  The effect of loading this file will be to cause the PLOT2 package to be automatically loaded when you need it.  If you use PLOT2 regularly,  you should consider including PLOT2 LISP DSK SHARE in your MACSYM (INIT) file, it will take up neglegible room in your MACSYM.  

The capabilities of the routines described here include plotting of
several curves on a single graph, plotting several graphs in different
positions on the screen, saving plots, replotting plots with different
scales without having to recompute any points, plotting of 3 dimensional
surfaces, plotting of user defined dashed lines and symbols.

The devices supported are: the Tektronix 4010 and 4013, the Imlac PDS 1 and PDS 4 (using ARDS graphics conventions), the XGP and the Gould line-printer (at MIT) and printing and display consoles in a "preview" mode.

Mail concerning bugs/features in PLOT2 should be addressed to Charles Karney (CFFK), who is responsible for these routines.

.sec(Two-Dimensional Plotting,d2plot)

.function(PLOT2,|y-exprs,variable,var-range,optionals-args|)
plots 2y-exprs* on the y axis as 2variable* (the x axis) takes on  values specified by 2var-range*.
.bcon
2y-exprs* can take one of two forms:
.begin narrow 8,5
.scon
i) 2expr* plots a curve of 2expr* against 2variable*
.scon
ii) [2expr1*,2expr2*, .. ,2expri*, .. ,2exprn*] plots n curves of 2expri* against 2variable*.  2expri* gets evaluated in the context FLOAT(EV(2expri*,2variable*=2value gotten from var-range*, NUMER)). It is an error if this doesn't result in a floating point number.
.end
.scon
2var-range* can have the following forms:
.begin narrow 8,5
.scon
i) 2low*,2high*, where 2low* and 2high* evaluate to numbers.  2low* may be either greater or less than 2high*.  2variable* will take on CALCOMPNUM values equally spaced between 2low* and 2high*. 
.begin narrow 2,2
Note that the first argument will be evaluated at 2low* first e.g. PLOT2(1/X,X,-1,-3); calculates 1/(-1.0) before 1/(-3.0). This will only make a difference if the computation of the first arg changes a variable which changes the value returned by subsequent computation.  Whether or not 2low* < 2high*, min(2low*,2high*) will be on the left of the plot.  (This can be overridden using the SPECIAL $see<transformpts> option with REFLECT as XFUN.)
.end
.scon
ii) 2low1,2high*,INTEGER.  As in i), except 2variable* will take on all integer values between 2low* and 2high* inclusive.
.scon
iii) [2val1*,2val2*, ... , 2valn*] . 2variable* takes the values specified by the list
.scon
iv) 2arrayname* where 2arrayname* is the name of a declared floating-point  one-dimensional array (i.e. declared by ARRAY(2arrayname*,FLOAT, 2max-index*);).  2variable* takes the values from 2arrayname*[0] thru 2arrayname*[2max-index*] (2max-index* is the maximum index of 2arrayname*
.end
.scon
2optional-args* can be any of the following:
.begin narrow 8,5
.scon
i) X-Label, Y-Label or Title descriptor $see<labels>
.scon
ii) Line type descriptor $see<linetypes>
.scon
iii) FIRST, SAME and LAST $see<allinone>
.scon
iv) POLAR, LOG, LINLOG, LOGLIN $see<transformpts>
.end
.scon
The optional arguments may appear in any order.  The rule for 	evaluation of the optional args is as follows.  If the argument is atomic it gets evaluated.  The resulting arguments are the	ones that get used.

If you want to plot more than 3-4 curves on the same plot investigate using the NOT3D option to PLOT3D $see<d3plot>

.example
.once center
2Examples1

  PLOT2(SIN(X),X,-%PI,%PI);	plots sin(X) against X as X takes on
				CALCOMPNUM values between -%PI to %PI
  PLOT2(X!,X,0,6,INTEGER);	plots X! as X takes integral values
				between 0 and 6
  F(X):=SQRT(X);
  PLOT2(F(X),X,[-2,3,100.12]);	plots F(X) as X takes the values in the
				values in the list
  PLOT2([X+1,X^2+1],X,-1,1);	plots 2 curves on top of each other
.end
.endfunction

.function(PLOT2,|y-funs,var-range,optionals-args|)
is the alternative form for PLOT2.  2y-funs* must be a function of argument or a list of functions of 1 argument.  The functions must be either translated or compiled functions which return a floating point number when it is given floating point arg (or integer arg if the INTEGER arg to PLOT2 is given).  This form of PLOT2 acts as though you had given a argument to the 2y-funs*, and also specified that argument as the 2variable* in the form above. E.g. PLOT2(F,-2,2); acts like PLOT2(F(X),X,-2,2);  This is supposed to provide a quicker evaluation of the first arg and for that reason NO checking is done on the result.  If the wrong sort of number is returned, you will get garbage plotted.

.example

      TRANSLATE:TRUE;
      F(X):=(MODEDECLARE(X,FLOAT),EXP(-X*X));
      PLOT2(F,-2,2);
      PLOT2(F,[-2,-1,0,1,2]); 
      ARRAY(V,FLOAT,10);
      FOR I FROM 0 THRU 10 DO V[I]:FLOAT(I*I);
      PLOT2(F,V);
.end
.endfunction

.function(GRAPH2,|x-lists,y-lists,optional-args|)
plots points specified by the first 2x-lists* and 2y-lists*.  The format for 2x-lists* can be one of
.begin narrow 8,5
.scon
i) [2x-pt1*,2x-pt2*, .. ,2x-pti*, .. ,2x-ptn*] 	where 2x-pti* evaluates to a number
.scon
ii) 2arrayname* where 2arrayname* is the name of a declared one-dimensional array of floating point numbers
.scon
iii) 22d-arrayname* where 22d-arrayname* is the name of a declared two-dimensional array of floating point numbers (i.e. by ARRAY(22d-arrayname*, FLOAT, 2max-row-index*,2max-col-index*);)
.scon
iv) [2x-list1*,2x-list2*, .. ,2x-listi*, .. ,2x-listk*]	where 2x-listi* can have the form of either i) or ii).
.end
The format of 2y-lists* is similar.
.scon
GRAPH2 performs as follows: arguments of form i) or ii) are converted to form iv) (e.g. 2arrayname* ==> [2arrayname*]).  Arguments of from iii) are converted to form iv) by 22d-arrayname* ==> [2row0*,2row1*, .. , 2rowi*, .. ,2rowk*] where 2rowi* is a list of the numbers in the i'th row of 22d-arrayname* (remember that array indexing begins from 0 in MACSYMA).  If the length of the resulting 2x-lists* is shorter than that of the resulting 2y-lists* then 2x-lists* is filled with 2x-listk* to make the lengths the same (similarly if 2y-lists* is shorter than 2x-lists*).  If the length of 2y-lists* is, say, n, then n curves of 2x-list1* vs. 2y-list1*, .. ,2x-listn* vs. 2y-listn* are plotted. In the event of 2x-listi* containing less numbers (or being a shorter array) than 2y-listi* then the last numbers of 2y-listi* are left unused.

    The format of 2optional-args* is the same as for PLOT2.

    Note that GRAPH2 performs the same job as the MACSYMA function MULTIGRAPH and that GRAPH2 is thus slightly incompatible with GRAPH FASL.
.endfunction


.function(PARAMPLOT2,|x-exprs,y-exprs,variable,var-range,optional-args|)
plots 2x-exprs* as the x coordinate against 2y-exprs* as the y coordinate.
.scon
      The format for the first two arguments is the same as that for the first argument to PLOT2.  thus if 2x-exprs* is [2x-expr1*, 2x-expr2*, .. ,2x-expri*, .. ,2x-exprn*] and 2y-exprs* is [2y-expr1*,2y-expr2*, .. ,2y-expri*, .. ,2y-exprk*], then max(n,k) curves will be plotted. They will be (assuming n > k): 
.scon
.once center
2x-expr1* vs. 2y-expr1*, .. ,2x-exprk* vs. 2y-exprk*,
.once center
2x-expr(k+1)* vs. 2y-exprk*, .. ,2x-exprn* vs. 2y-exprk*
.scon
The format for the remaining arguments is the same as for PLOT2.
.endfunction

.function(PARAMPLOT2,|x-funs.y-funs,var-range,optional-args|)
efficiently evaluates its first 2 arguments in the same way that the alternative form of PLOT2 works.
.endfunction
.once center
2Examples1
.example
  TRANSLATE:TRUE;	causes automatic translation
  F(X):=(MODEDECLARE(X,FLOAT),COS(X)); 
  G(X):=(MODEDECLARE(X,FLOAT),SIN(X));
  PARAMPLOT2(F,G,0,2*%PI); plots F(x) vs G(x) as x goes from 0 to 2*%PI

  PARAMPLOT2(SIN(T),COS(T),T,0,2*%PI);
.end bcon
plots sin(T) for the x-axis and cos(T) for the y-axis as T takes on CALCOMPNUM $see<d2plot> values between 0 and 2*%PI.  (If EQUALSCALE is TRUE $see<scales> this draws a circle.)

.function(WORLDPLOT,|min-long,max-long,min-lat,max-lat|)
plots your favorite portion of the world. The arguments are in degrees with latitude ranging from -90 to 90 and longitude from -180 to 180. the projection is unorthodox.  (For this function,  don't expect any of the features available with the other plotting functions to be available)
.endfunction
.scon
$var<CALCOMPNUM/20> is the number of points PLOT2 and PARAMPLOT2 plot when given the 2low*,2high* type of variable range.  The default if you    load up PLOT2,LISP,DSK,SHARE is 20, which is sufficient for   trying things out.  100 is a suitable value for a final hard copy.

.sec(What to Type When PLOT2 has Finished Plotting,whatnow)

When a plot is finished the bell on your terminal will be dinged and the bell
on your terminal dinged.  (This only in fact happens if WAIT is TRUE $see<allinone>
and if you're plotting on the terminal $see<otherpf> and $see<devices>.)  The plotting
function is now waiting for you to type something before it exits and prints
the next C-Label on your nice plot.  It does nothing with most characters; 
they are left to be part of the next C-Line.  However, the following characters
are read and interpreted specially.
.scon
2space1 exits the plotting function. 
.scon
2return1 clears the screen and then exits.  
.scon
2tab1 causes the previous plot to be replotted.
.begin narrow 8,5
.bcon
This is useful if the line is noisy, or, in conjunction with 2control-A1  if various plotting parameters need to be changed.
.end
.scon
2linefeed1 sends out a hardcopy signal.  

.begin narrow 8,5 
.bcon
At present this can only  be used to generate a hardcopy on the Tektronix hardcopy unit or on the Gould $see<devices>
.end
.scon
2rubout1 names the plot.  
.begin narrow 8,5 
.bcon
PLOT2 types out "Enter name of plot" you reply 2plotname*;  this is identical to typing a space instead of a rubout, followed by NAMEPLOT(2plotname*);$see<namsav>.  
.end 
.scon
2control-A1
.begin narrow 8,5 
.bcon
This is not really read by the plotting function, but enables you to enter a 2control-A1 break and change various options, before typing tab to have the plot replotted.  Make sure the plot has finished before you type this $see<whatnow>.  The most common things that need changing are the scaling options $see<scales>;  but just about anything can be changed as long as they don't require that more points be calculated (e.g. don't try resetting CALCOMPNUM in a 2control-A1 break).  There are a number of options that exist as explicit options only within a 2control-A1 break of this type.  (Normally they are set in the 2optional-args* of the plotting function.)  They are $var<TYPEL/> $see<linetypes>, $var<XLABEL/>, var<YLABEL/>, $var<TITLE/> $see<labels>, $var<TXTYPE/> $see<transformpts> and $var<\3D/> $see<d3plot>. 

Unlike the other options these are local variables and will become unbound (or bound to their old values) when PLOT2 is exited and in order for the changes made to them to be remembered by REPLOT $see<otherpf> later on you must replot the plot after exiting the break.  In order to get your plot replotted in the new environment you have set up, just type EXIT; followed by a tab.  
.end
.scon 
$var<PLOTBELL/TRUE> when FALSE inhibits the dinging of the bell.  
.scon
While your plot is coming out your terminal is in a rather strange state (e.g. not echoing characters).  Thus it is OK to type ahead to MACSYMA, but the ONLY way you should interrupt the plot is with 2control-^1.  E.g. do not use 2control-A1 until the plot has finished.  
.begin indent 0,8
Note:	the characters to create a plot get put in a buffer, and normally only get sent when the buffer is full or when the plot is complete.  the user can force the buffer contents to be sent by typing ^\ (control-shift-L on the tektronix, control-\ on the imlac).  (this is probably only of use to to users of WORLDPLOT, which because of its ridiculously inefficient implementation will sometimes wait until it has gone thru the whole world before sending anything out.)  note however that this feature is not reliable.  
.end 
.sec("Three-Dimensional Plotting",D3plot)

.function(PLOT3D,|z-exprs,x-var,var-range,y-var,var1-range,optional-args|)
makes a 3-dimensional plot of 2z-exprs* against 2x-var* and 2y-var*.  the plot consists of curves of 2y-exprs* against 2x-var* (the x coordinate) with 2y-var* (the y coordinate) held fixed.  Perspective is used and curves further away from the viewer have those parts of them which are hidden by the closer curves removed. 

The format of 2y-exprs* is the same as for PLOT2.  The context of evaluation is FLOAT(EV(2expri*,2x-var*=2value gotten from var-range1,2y-var*=2value gotten from var1-range1,NUMER)).

The format for 2var-range* and 2var1-range* is the same as for PLOT2 except that if 2var1-range* is of the form 2low*,2high* then 2y-var* will take on CALCOMPNUM1 values. 

      The format of 2optional-args* is the same as for PLOT2 except that additional options $var<NOT3D/>, $var<\3D/>, var<CONTOUR/> are available. 
.endfunction
.function(PLOT3D,|z-funs,var-range,var1-range,optional-args|)
is analogous to the alternative form for PLOT2.  2z-funs* must be a function or list of functions of 2 arguments, which must return a floating point argument when given floating point (integer, if the INTEGER argument is used for either 2var-range* or 2var1-range*) arguments.  The functions must be translated or compiled.  If you expect to make several 3D plots this form is recommended. 

 A simple example is 
.example
  TRANSLATE:TRUE;	causes automatic translation
  G(X,Y):=(MODECLARE(X,FLOAT),EXP(-X*X-Y*Y));	defines a funtion G
  PLOT3D(G,-2,2,-2,2);	plots it 
.end
.endfunction
.function(GRAPH3D,|x-lists,y-lists,z-listsoptional-args|) 
takes 3 arguments (GRAPH2 takes 2) and  interprets them as lists of x, y, and z points which it uses to draw lines using the 3d transformations.  It can be used to add lines (e.g.  axes) to your 3D plot (see SAME option $ref<allinone>)).  The hidden line routines are not used.  
.endfunction 

2NOT3D1

In this section we describe the option $var<NOT3D/>.   As an example, consider 
.example 
.once center 
PLOT3D(SIN(X)+A,X,-%PI,%PI,A,[-2,3,4,6],NOT3D) 
.end scon
which plots sin(X)+A for X from -%PI to %PI ($var<CALCOMPNUM/20> points) and A
taking the values in the list.  This is equivalent to:  
.example 
.once center
PLOT2([SIN(X)-2,SIN(X)+3,SIN(X)+4,SIN(X)+6],X,-%PI,%PI) 
.end 
.scon 
but requires less typing. 

The additional NOT3D argument to PLOT3D, causes exactly the same points as in the bare PLOT3D to be calculated.  Instead of plotting a 3-dimensional representation of the data, the data is plotted in a 2D one.  Specifically 1 2D curve of z vs. x for each y value, and so is a convenient way to plot several curves on the same plot. 

2PERSPECTIVE, REVERSE, VIEWPT, and CENTERPLOT1

The following options govern the type of perspective view given. 

$var<PERSPECTIVE/>, if FALSE causes a non-perspective view to be taken.  This is equivalent to extending the viewing position out to infinity along a line connecting the origin and VIEWPT. 

$var<REVERSE/>, if TRUE cause a left-handed coordinate system to be assumed. 

$var<VIEWPT/> and $var<CENTERPLOT/> determine the perspective view taken.       They are defaulted to be unbound - like XMAX etc.)  VIEWPT may be set to a list of 3 numbers and gives the point from which the projection should be made.  CENTERPLOT may likewise to set to a list of 3 numbers and gives a point on the line of sight.  The projection will be made onto a plane perpendicular to a line joining VIEWPT and CENTERPLOT. 

If VIEWPT and CENTERPLOT are unbound (the default) then they will be chosen as  follows: the extreme values of the coordinates are determined.  This gives the two points min:  [xmin,ymin,zmin], max:[xmax,ymax,zmax]. CENTERPLOT is chosen as (min+max)/2, and VIEWPT is chosen as max+3*(max-min).  The view is then one in which the z axis is vertical, the x axis is increasing towards you to the left and the y axis is increasing towards you to the right. 

If CENTERPLOT is FALSE then the old type of  perspective view will be given (like setting the x and z components of CENTERPLOT to the corresponding components of VIEWPT). 

Before you set either VIEWPT or CENTERPLOT you might want to look at the values of $var<VIEWPT1/> or $var<CENTERPLOT1/>, the values that PLOT3D assumed in doing the previous plot $see<scales>.  Likewise $var<XMAX3D/>, $var<YMIN3D/> etc. will be the values of xmax, min for the data points, that PLOT3D used to determine the default VIEWPT or CENTERPLOT. 

If rather than changing the view you want to change the scale of the plot (to cause clipping or whatever), then you must change $var<XMAX/>, $var<XMIN/>, $var<YMAX/> or $var<YMIN/> $see<scales>.  However, ote that these numbers refer to the size of the plot AFTER the perspective routines have been used.  So again you will probably want to look at XMAX1 etc. to find what had been assumed. 

2CROSSHATCH and UNDERSIDE1

The option $var<CROSSHATCH/TRUE> will force PLOT3D to crosshatch, i.e. plot lines of constant x as  well as constant y.  You can turn this off by doing CROSSHATCH:  	FALSE; (it will then plot only lines of constant y)

If $var<UNDERSIDE/TRUE> is TRUE, PLOT3D will show the underside of a figure (when it is visible). 

2HIDE, \3D, CONTOUR, and NOT3D1

Internally the plots generated by PLOT3D (with or without the NOT3D option), GRAPH3D and CONTOURPLOT2 $see<contourplot> are the same, and it is possible to switch between any of the 4 representations.  The 4 representations are accessible directly in the following ways:   
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon 
Hidden-Line\\PLOT3D, GRAPH3D(....,HIDE)$$HIDE is the optional argument* 
.bcon 
3D, hidden lines not removed\\PLOT3D(...., \3D), GRAPH3D 
.bcon 
Contourplot\\PLOT3D(...., CONTOUR),CONTOURPLOT2 
.bcon 
Not3d\\\PLOT3D(...., NOT3D) 
.end 
There are two ways of hanging representations once the plot has been made.  In a ^A break, or using the REPLOT $see<otherpf> function.         

In a ^A break there are 2 variables which govern the representation $var<\3D/> and $var<TXTYPE/> $see<transformpts>  (These variables are local to the ^A break.)  They should be reset according to the following table 
.begin group turn on "_\"; tabs 8, 20, 34 ;  
\\value of \3D \value of TXTYPE 
.scon 
\Hidden-Line\HIDE\FALSE 
.bcon
\3D\TRUE\FALSE
.bcon
\Contourplot\CONTOUR\FALSE 
.bcon
\Not3d\FALSE\NOT3D 
.end 
.scon 
(Note that TXTYPE only need be touched switching to and from the Not3d representation.  It is a misfeature that it should have to be touched at all, and this may be corrected someday.)

Having exited the plot, you can have it REPLOT'ed in another represention by using the following table.  
.begin group turn on "_\";tabs 8, 20, 34 ;  
.scon
\Hidden-Line\REPLOT(TRUE,HIDE);  
.bcon
\3D\REPLOT(TRUE,3D); 
.bcon
\Contourplot\REPLOT(TRUE,CONTOUR);  
.bcon
\Not3d\REPLOT(TRUE,NOT3D);  
.end 
.scon
Again, as a misfeature when swapping from a Not3d representation to a Contourplot it necessary to supply an additional optional argument LIN (thus REPLOT(TRUE,CONTOUR,LIN);)  The TRUEs in the calls to replot indicate the last plot.  The name of a named plot $see<namsav> may be used instead (see $ref<otherpf> for details)

2CALCOMPNUM11

If the 2low*,2high* form is used with 2var1-range* in PLOT3D, the 2y-var* takes on $var<CALCOMPNUM1/20> points.  CALCOMPNUM1 defaults to 20.  Since CALCOMPNUM*CALCOMPNUM1 points are normally calculated when PLOT3D is called, the alternative form for calling PLOT3D is highly recommended. 


.sec(Contour Plotting,contourplot)

2CONTOURPLOT21

First consider some simple examples 
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
CONTOURS:10;\\Do 10 contours 
.bcon
LABELCONTOURS:FALSE;\\Don't label the contours 
.bcon
CONTOURPLOT2(Y^2/2+COS(X)+X/2,X,-6,6,Y,-3,3);  
.scon
makes  a contour plot of Y^2/2+cos(X) as X takes CALCOMPNUM values between -6 and 6 and as Y takes CALCOMPNUM1 values between -3 and 3. $$This gives ou the phase space orbits of a particle in a periodic potential superimposed on a constant field* 
.end
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
PLOT3D(Y^2/2+COS(X)+X/2,X,-6,6,Y,-3,3,CONTOUR);\\Exactly the same 
.bcon
CONTOURS:[0];\\Plot only the zero contour.  
.bcon
CONTOURPLOT2([REALPART((X+%I*Y)^3-1),IMAGPART((X+%I*Y)^3-1)], 
.once center
 X,-1.5,1.5,Y,-1.5,1.5,[0,1]);  
.bcon 
finds the zeroes of Z^3=-1 in the complex plane.  
.scon 
CONTOURS:CALCOMPNUM:CALCOMPNUM1:10;
.bcon
Work with a 10x10 grid 
.bcon
CONTOURPLOT2(RANDOM(100),X,0,1,Y,0,1);\\Plot something random 
.end

The function  
.inline function(CONTOURPLOT2,|...|) 
is exactly the same as PLOT3D(...., CONTOUR).  That is it calculates the same points as PLOT3D(...) would, but displays the points as a contour plot.  What contours are drawn is governed by the variable $var<CONTOURS/20> .  Changing CONTOURS does not require any more points to be calculated, so it makes sense to change CONTOURS in the ^A break after a plot $see<whatnow> or before using REPLOT $see<otherpf>.  The contours are drawn using linear interpolation, so they tend to look rough (especially near saddle points) unless CALCOMPNUM and CALCOMPNUM1 are large.  The contour tracking algorithm is quite smart so all contours should either terminate at the boundaries of the region or be closed loops. 

CONTOURS, ZMAX and ZMIN

If $var<CONTOURS/20> is an integer, you will get CONTOURS equally spaced contours lying between the maximum and minimum z values to be plotted (the first argument to CONTOURPLOT2 and PLOT3D is considered to be a z variable).  If either $var<ZMAX/> or $var<ZMIN/> as a value then that value will be used instead of the actual maximum or minimum.  The default is for ZMAX and ZMIN to be unbound. 

If CONTOURS is the atom INTEGER then only integer heights for the contours will be used.  Again the range for these contours can be restricted by setting ZMAX and ZMIN appropriately.

If CONTOURS is a list of numbers (e.g. CONTOURS:[1,.5,%PI];) then those numbers will be used to determine the heights of the contours.  The number in the list can be in any order.

CONTOURPLOT2 will label the contours with their height unless $var<LABELCONTOURS/TRUE> is FALSE.  $var<PLOTNUMPREC/7> digits of precision are given $see<labels>.

.sec(Other Plotting Functions,otherpf)

2REPLOT1

First, consider the following examples.
.begin group turn on "_\"; tabs 8, 20, 34 ;  
.scon
PLOT2(1,X,0,2*%PI);\\Plots a straight line
.bcon
REPLOT(TRUE,POLAR);
.bcon
Plots it in polar coordinates $see<transformpts>. This will appear as an ellipse unless EQUALSCALE:TRUE $see<scales>
.bcon
EQUALSCALE:TRUE;
.bcon
REPLOT();
.bcon
Replots the ellipse with EQUALSCALE equal to TRUE; this will then appear as a circle.
.end

.function(REPLOT,|plotname,optional-args|)
replots the plot named 2plotname* $see<namsav>.  2plotname* will be loaded from a file if REPLOT can determine which file to load. REPLOT(TRUE); and REPLOT(); both replot the last plot.  If any of the options for determining the scale, etc. have been changed since the plot was saved the new values of those options will be used.

2optional-args* may be any of the optional arguments to the main plotting functions.  These optional args will be merged in with those supplied to the original plot.  (The exceptions are FIRST, LAST and SAME $see<allinone> and DONT $see<namsav>.  These optional argument don't stick around with the plot.)  If you want the last plot replotted with some optional args supplied you must use the form REPLOT(TRUE,2optional-args*); (REPLOT(2optional-args*); won't work because it will try and use the first optional arg. as a 2plotname*).

There are two additional optional arguments that it makes sense to give to REPLOT, but not to the original plotting function.  They are NONE, to suppress a label $see<labels> and LIN, to suppress a transformation $see<transformpts>.
.endfunction

.function(REPLOT,|list-of-plots,optional-args|)
where 2list-of-plots* is [2plotname1*,2plotname2*, .. ] is identical to (REPLOT(2plotname1*,2optional-args*), REPLOT(2plotname2*,2optional-args*));  If the first arg to REPLOT is atomic then it is evaluated and the evaluated form is used if is a list.
.endfunction
.example
REPLOT(PLOTS);  	Replots all named plots $see<namsav>.
.end

.function(PLOTMODE,|dev1,dev2, ...| )
sets PLOT2 up to plot on the devices specified by 2devi*. at present 2devi* can be one of T (or TEKTRONIX), I (or IMLAC), GR (or GRINNELL), D (or DISPLAY), P (or PRINTING), X (or XGP)   or G (or GOULD), for Tekronix, Imlac, a display console,  printing terminal, the XGP or the Gould printers at MIT.  Any number of arguments may be given with the restriction that no 2 of [I, T, GR, D, P] appear together.  The arguments may appear in any order, with the first argument being used to determine what  character size will be assumed.  The defaults performed when PLOT2 is loaded is PLOTMODE(T), PLOTMODE(I), PLOTMODE(D) or PLOTMODE(P), depending on the terminal type [see $ref<defaults> for details]

Details of the peculiarities of the various devices in given in $see<devices>.

.example
PLOTMODE(DISPLAY,XGP);  
.end scon
sets things up for plotting on the XGP and a datapoint.
.endfunction
.scon
PLOTMODE:2dev* and PLOTMODE:[2dev1*, 2dev2*, .. ]    are equivalent to PLOTMODE(2dev*) and PLOTMODE(2dev1*, 2dev2*,...), respectively.
.scon
$var<PLOTMODE/>  returns a list of the devices PLOT2 currently is plotting for; PLOTMODE(); also does this.

.function(CLEAR,)
clears the screen
.endfunction

.function(HARDCOPY,)
queues up the plot for the Gould if PLOTMODE contains GOULD, else it sends out a hardcopy signal to the Tektronix if PLOTMODE contains TEKTRONIX, else it prints "HARDCOPY failed".
.endfunction

.function(PLOTRESET,)
resets most of the options affecting plotting back to their default values.  The exceptions are the terminal related options.  See $ref<defaults> for details.
.endfunction

.sec(Labels,labels)

2XLABEL, YLABEL, TITLE and NONE1

The following simple examples will help in understanding the label options.
.example
      PLOT2(EXP(X),X,0,3,X,EXP(X),"THIS IS A PLOT OF EXP(X) VS. X");
.end
.bcon
plots a curve of exp(X) with an x-label of "X", a y-label of "EXP(X)" and a title of "THIS IS A PLOT OF EXP(X) VS. X" (the labels don't appear with the "'s)
.bcon
.example
  A:3;
  TITLE:CONCAT("A=",A);
.end bcon
computes the title "A=3".
.bcon
.example
  PLOT2(SIN(X)+A,X,-%PI,%PI,FALSE,FALSE,TITLE);
.end bcon
plots sin(X)+A, and sticks an the title "A=3".
.example
  PLOT2(SIN(X),X,-%PI,%PI,FALSE,SIN());
.end bcon
labels the y-axis with 	"SIN(X)".

We now explain in greater detail the effect of a sequence of optional arguments
.once center
2xlabel*,2ylabel*,2title*
.scon
If the optional arguments to the plotting functions aren't any of the recognized keywords (FIRST, LAST etc.) they are taken to be specifications for the x-label, y-label and the title of the plot,  If any of these is atomic it gets evaluated once, else it gets used literally.  (See the "A=3" example above.  If PLOT2(SIN(X)+A,X,-%PI,%PI,FALSE,FALSE,CONCAT("A=",A)); had been used the title would have appeared as "CONCAT("A=",A)".) If one of them is FALSE then nothing gets printed for that item.  Only as many of the three to be non-ambigous need be specified:  thus if only a y-label is required then FALSE,2ylabel* would be sufficient. None of these options may be a list (to avoid confusion with  line-type list $see<linetypes>.

Within a ^A break at the end of a plot $see<whatnow>, the x-label, y-label and title of the current plot are the values of the local variables $var<XLABEL/>, $var<YLABEL/>, and $var<TITLE/>.  These variables will be FALSE if there is no corresponding label.  You can change the values of these variables in the ^A break and they will be incorpoated into your plot when you exit the break and type a tab $see<whatnow>.

In the optional arguments to REPLOT $see<otherpf> FALSE has the meaning "Don't change the corresponding label".  If it is desired to remove a label when REPLOTting then NONE should be given instead.
.example
.once center
2Examples*
.scon
  PLOT2(SIN(X),X,-%PI,%PI,FALSE,FALSE,"THE CAT SAT ON THE MAT");
.bcon
title is set to "THE CAT SAT ON THE MAT "
.bcon
  REPLOT(TRUE,"X-AXIS");
.bcon
replots with title and x label.
.bcon
  REPLOT(TRUE,FALSE,"SIN(X)",NONE);
.bcon
replots with same xlabel a new ylabel and no title.
.bcon
  REPLOT(TRUE,FALSE,"Y-AXIS");
.bcon
replots with new ylabel.
.end

As a default the 2D plotting functions include a line at the bottom with the Max and Min of X and Y printed.  $var<NOPRINT/FALSE>:TRUE causes this line to be suppressed.

The numbers that PLOT2 prints out in the Min and Max line at the bottom of the plot, in the Min and Max labels on the axes $see<axes> and on the contours $see<contourplot> are given to a precision of $var<PLOTNUMPREC/7> significant figures.  The default is to give the numbers to full precision.  If you want to have less precision given (particularly useful with the labelling of contour levels) set PLOTNUMPREC to a smaller number (say 2 or 3).


The date is normally given at the top right corner of the plot, in a long form if no title is specified, or in a shorter form if a title is specified.  Sometimes the date overlaps with the title.  You can shut off the printing of the date by doing $var<DATEPLOT/TRUE>:FALSE;

.sec(Axes,axes)

2XAXIS and YAXIS1

The default action of PLOT2 for 2D plots is to provide the plots with x and y axes (which go through the origin if the origin is within the plot), to give the axes approximately 10 tickmarks in reasonable places, and  to give the max and min values of x and y by the axes and on a line beneath the plot.

$var<XAXIS/ALL>:FALSE;  $var<YAXIS/ALL>:FALSE; 	cause the x axis and y axis not to be drawn.  Their tickmarks will not be drawn either.  When TRUE these options draw the axis and the tick marks only.  When these options are set to ALL, the result is to draw the axis, the tick marks and give the max and min values of the coordinate.

2TICKSIZE and TICKNUM1

$var<TICKNUM/10>:2no-of-ticks*;  $var<TICKSIZE/6>:2size-of-ticks*; causes TICKNUM ticks to be given on each axis.  The size of the ticks will be TICKSIZE raster units either side of the axes.  The ticks will always come at "nice" values of the x or y variable.  "Nice" values is defined to be 2m**2k**10^2n* where 2m* and 2n* are integers and 2k* is 1, 2 or 5.

TICKSIZE:0;  results in there being no ticks and TICKSIZE:2000; results in the ticks going all the way across the WINDOW $see<scales>, causing the ticks to turn into grids.

Setting TICKNUM to a negative number causes about |TICKNUM| ticks to be drawn, but PLOT2 won't round the max and min values on your axes to the nearest tickmark. Both TICKSIZE and TICKNUM may be lists of two numbers---the first referring to the ticks on the xaxis and the second to the ticks on the y axis.

As yet no axes are provided for 3D plots.  Suggestions for their implementation are welcome,

.sec(Scales,scales)

If the user takes no action the scale of his plots will be chosen for
him.  In general the scale will be as large as possible, while
still allowing everything to fit on the screen.  The user is provided
with various ways of overriding the default settings for the scales.

$var<WINDOW/>:[2min-x*,2max-x*,2min-y*,2max-y*]  sets the area of the screen that PLOT2 tries to plot in. The elements of the list are in raster units.  The maximum permissible size of the WINDOW is [0,1023,0,1023];  garbage will be produced if the WINDOW is larger than this.  If PLOT2 tries to plot outside the window, the plot will be clipped correctly.  If WINDOW is unbound then the default settings will be used (corresponding to the full Tektronix screen),  thus you can get back the default value be doing KILL(WINDOW);

In choosing the scale for a plot PLOT2 looks at the maximum and minimum values of x and y of the points it has calculated. However if one of $var<XMIN/>, $var<XMAX/>, $var<YMIN/>, $var<YMAX/> has a numeric value then that value will be used instead of the one found from the points themselves.  As with WINDOW do KILL(XMIN, etc) to get back to the default values.  The maximum and minimum values of x and y that PLOT2 obtains are rounded up and down to the nearest tick mark, unless TICKNUM is negative $see<axes>.

$var<EQUALSCALE/FALSE>:TRUE; tells PLOT2 to ensure that the scales are the same in both directions.  Thus if the WINDOW is rectangular, a circle will normally appear as an ellipse, whereas with EQUALSCALE:TRUE it will appear as a circle. All the plotting options whose default state is unbound (e.g. XMAX, WINDOW) have corresponding options obtained by sticking a "1" on the end, e.g. $var<XMAX1/>, $var<WINDOW1/>.  These options should only be read (not set), and their values may be loosely defined to be the value that PLOT2 assumed for the option.  The value will only be right if PLOT2 needed to calculate it.

Variables in this class are: $var<XMAX1/>, $var<XMIN1/>, $var<YMAX1/>, $var<YMIN1/>.  These refer to the quantities after the transformation functions $see<transformpts> have been applied, and after rounding to the nearest tickmark. 

$var<ZMAX1/>, $var<ZMIN1/> are of use only for contour plots $see<contourplot>.  ZMAX1 and ZMIN1 are equal to ZMAX and ZMIN if the latter have values.  They are equal to the max and min values of the first argument to CONTOURPLOT2, if ZMAX and ZMIN are unbound.  Their values are meaningless if CONTOURS is a list, since then CONTOURPLOT2 doesn't need to compute zmax and zmin.

$var<WINDOW1/> is the window in which plotting is done.  It does not include the room used by titles etc.

$var<XMAX3D/>, $var<XMIN3D/>, $var<YMAX3D/>, $var<YMIN3D/>, $var<ZMAX3D/>, $var<ZMIN3D/> are only of use for 3D plots $see<d3plot>.  These are the values of the 3D data before transforming it to 2d.  This will only be up to date information if PLOT3D needed to calculate it to determine either the default VIEWPT or the default CENTERPLOT.

$var<VIEWPT1/>, $var<CENTERPLOT1/> are only of use with 3D plots.  Useful to look at before you change VIEWPT or CENTERPLOT.

These variables are especially important when changing the scale of 3D plots $see<d3plot>, because YMAX etc. refer to the values after the perspective transformations, and so may be quite unrelated to the data points.
.example
.once center
2Example*

  CALCOMPNUM:CALCOMPNUM1:20;
  PLOT3D(1/(X^2+Y^2),X,-3,3,Y,-3,3);

.end scon
has a big peak in the middle which we wish to clip.   YMAX1; returns -.896... and   YMIN1; yields -0.957...  
.scon
YMAX:-0.92; tries a value of YMAX about 1/2 way between the old YMAX and YMIN
.scon
REPLOT(); replots on new scale.

.sec(Line Types,linetypes)

2TYPEL1

As usual, we begin with easy examples. 
.scon
       PLOT2([SIN(X),COS(X)],X,-%PI,%PI,[0,1]);
.bcon
plots sin(X) with line type 0 (a solid line) and cos(X) with line type 1 (a dashed line)
.bcon
       PARAMPLOT2(RANDOM(),RANDOM(),X,0,1,[99]);
.bcon 
plots CALCOMPNUM "random" points (no connecting lines drawn)
.scon
       TT:[0,1,2,3,4,5,6,7,8];   CALCOMPNUM1:9;
.bcon
       PLOT3D(SIN(X)+A,X,-%PI,%PI,A,0,2,TT,NOT3D);
.scon
gives the full repertory of line types
.scon
       TT:9+10*(TT+1);	TT is now [19,29,39 .. ]
.bcon
       REPLOT(TRUE,TT);	gives the full repertory of symbol types.

If a list (or an atom that evaluates to a list) appears as an optional argument to a plotting function, then that list is taken as a specification of the line type to be used for the plot.  The elements of the list are evaluated once, and the elements of the resultant list must be all integers.  If this list has the form
.skip
.once center
[2type1*,2type2*, .. ,2typei*, .. ,2typek*]
.scon
then the i'th curve is to be plotted with line of type 2typei*. The (k+1)th curve is plotted with line of type 2type1* etc.      Omitting this optional argument is the same as specifying [0], i.e. all the cuves are plotted with line of type 0 (i.e. solid line with no symbols).

The curves drawn by the PLOT2 functions may be drawn as 1 of 9 types of dashed line, with 1 of 9 types of symbol drawn at the data points.  In general the line type 2typei* is of the form of a decimal number abbcd where a b c and d are digits between 0 and 9 (leading 0's may be omitted of course) and have the following meanings:
.begin narrow 8,5
.scon
.begin group
d = line-type is specified by the DEFINEDASH command; line-type 0 (the default) is defined as being a solid line; line-type of 9 defaults to meaning no line;
.end
.scon
c = symbol-type is defined by the DEFINESYMBOL command (see below); symbol 0 is defined to mean no symbol;

.scon
bb = number of data points with no symbol between the data points with a symbol.  If bb = 99 then bb is set to CALCOMPNUM-1,  if bb = 98 then bb is set to CALCOMPNUM-2.
.scon
a , the first symbol, is put at data point number 1 if a = 0, and at
    bb+2-a otherwise.

.end
.scon

2Examples1
.scon
.begin verbatim
abbcd =  0 ==> plain line
        10 ==> symbol 1 at every pt + plain line
        19 ==> symbol 1 at every pt
       124 ==> symbol 2 at every other pt + line 4
      9874 ==> line 4 with symbol 7 at endpoints
      9974 ==>   "     "    "     " at first point
     19974 ==>   "     "    "     " at last point
.end


.function(DEFINEDASH,|line-no,line-spec|)
redefines line number 2line-no* according to 2line-spec*. 2line-no* must lie between 0 and 9.  2line-spec* may be one of the following:
.scon
FALSE, the line is defined to be a solid line;
.scon
TRUE, no line is drawn (useful in conjunction with a symbol).
.scon
A list which defines a sequence of line segments separated by gaps.  

For example, DEFINEDASH(3,[1,5,5,5]) defines line 3 to start with 1 raster position on, 5 off, 5 on, 5 off, 1 on, 5 off etc.
.scon
A character (e.g. A, "1", \$) or its ASCII value.  This defines the character to be used for line 2line-no* when plotting on printing or display consoles, see $see<devices>.  In order to specify no line give 0 as the second argument (not space or 32, as this will cause existing lines, axes etc, to get over-written and, maybe erased, by spaces).

Note that dashed lines are implemented by drawing a sequence of small undashed lines.  Since these lines are about 4 - 10 raster units long, there are only a small number of directions in which they can point, and the chances are that none of these directions coincide with the direction of the dashed line as a whole. Hence dashed lines often appear to weave about.
.endfunction

.function(DEFINESYMBOL,|symbol-no,symbol-spec|);
redefines symbol number 2symbol-no* according to 2symbol-spec*. 2symbol-spec* may one of the following:

.scon
      FALSE meaning no symbol
.scon
      TRUE meaning a point
.scon
      A list of lists given a sequence of setpoint and vector commands (relative to starting position) to be used in drawing the symbol. For example, DEFINESYMBOL(3,[[5,5],[5,-5,-5,-5,-5,5,5,5],[0,0],[0,0]]);  defines symbol 3 to be drawn by a setpoint to 5,5 (relative to the starting position) following by vectors to 5,-5; -5,-5; - 5,5; 5,5, followed by setpoint to origin and a vector to origin. this will draw a box with a dot in it. The numbers are in raster positions. DEFINESYMBOL should always end with a setpoint or vector to [0,0].
.scon
      A character or its ASCII value.  This is interpreted the same way as for DEFINEDASH.

For example, the command 
.scon
  DEFINESYMBOL(1, [[0, 9], [4, -6, -7, 2, 7, 2, -4, -6, 0, 9], [0, 0]]);
.scon
defines symbol 1 to be a 5-pointed star.
.endfunction

.sec(Plotting Several Curves on One Screen,allinone)


2CLEAR and WAIT1

By governing when PLOT2 clears the screen it is possible to either superimpose plots or have plots come out in different parts of the screen.

$var<CLEAR/TRUE>:FALSE; causes the screen not to get cleared before starting a new plot.

$var<WAIT/TRUE>:FALSE; causes PLOT2 not to wait for a character to be typed after finishing a plot.

As an example, notice the effects of the individual parts of the following compound statement.
.example
.begin group turn on "_\"; tabs 8, 25, 34 ;  
(CLEAR:TRUE,WAIT:FALSE,\\turn on clearing, turn off waiting
 PLOT2(..),\\the screen will be cleared
 CLEAR:FALSE,\\turn off screen clearing
 PLOT2(..),\\plot more stuff
 GRAPH2(..),etc.,
 WAIT:TRUE,\\turn waiting back on
 PLOT2(..),\\last plot
 CLEAR:TRUE);\\reset CLEAR
.end
.end
Much more convenient ways are provided for doing this as described in the following sections.

2FIRST, LAST, and SAME1

$var<FIRST/>, $var<LAST/>, $var<SAME/> are optional args to the plotting functions and to REPLOT.  These optional arguments are non-sticky:  the fact that they were supplied is not remembered by REPLOT, although you can supply them to REPLOT.
.scon
FIRST or LAST indicate that this plot is to be the first (or last) of a series of plots that are to be superimposed or plotted in different parts of the screen.  They work by setting the WAIT and CLEAR flags to achieve the right effect. (FIRST sets CLEAR to TRUE and WAIT to FALSE before plotting and CLEAR to FALSE after plotting.  LAST sets WAIT to TRUE before plotting and CLEAR to TRUE after plotting.

For example, in order to get 4 plots out in different corners of the screen a typical sequence might be:
.example

  (WINDOW:2window1*, PLOT2(......,FIRST),
   WINDOW:2window2*, PARAMPLOT2(......),
   WINDOW:2window3*, REPLOT(.....),
   WINDOW:2window4*, GRAPH2(.......,LAST),
   KILL(WINDOW));
.end
.scon
Obviously it is necessary to use a compound statement to prevent the printing of unwanted cruft on the screen.  Since plotting 4 graphs together is quite common, the REPLOT4 (10.3) command is provided to do that automatically.
.scon 
NAME tells PLOT2 to make this plot on the same scale as the previous plot, and in the same WINDOW $see<scales>.  Plotting of axes, and printing of the date and the line giving XMAX, etc is suppressed.  The intention is to allow the convenient superposition of plots.  Specification of a title and labels is allowed, but if the previous plot which defines the scale of this plot didn't have them they may appear in the wrong place (having wrapped around the screen).  If you want to specify a title, then you should probably specify a null title "" in the original plot.

For example, in order to superimpose plots the normal sequence is:
.example

  (PLOT2(.....,FIRST),
   PLOT2(.....,SAME),
   PLOT2(.....,SAME),
   ...
   PLOT2(.....,SAME,LAST));
.end

2REPLOT41

.function(REPLOT4,|plot1, ... ,plotk|)
conveniently replots up to 4 plots in different parts of the screen. 2plot1*,2plot2*,...  must be named plots $see<namsav>.  It plots the first plot in the upper left hand corner of the default window (or of your own window, if WINDOW $see<scales> has a value), the second arg in the upper right-hand corner, etc.  It stops when it runs out of things to plot.  This function takes care of the business of specifying the FIRST and LAST options to REPLOT, so don't give them to REPLOT4.
.example
.once center
2Example1
.begin group turn on "_\"; tabs 4, 28, 34 ;  
.scon
\PLOT2(X,X,0,1);\\plots X vs X
\NAMEPLOT(A1);\\names it A1
\PLOT2(SIN(X),X,0,2*%PI);\\etc.
\NAMEPLOT(B[1]);
\PLOT2(X^2,X,0,1);
\NAMEPLOT(FOO);
\REPLOT4(A1,B[1],FOO);	replots A1, B[1], and FOO
.end
.end
.endfunction

.sec(Device Characteristics,devices)

A number of different devices are supported by PLOT2.  You set things up for a particular device using the PLOTMODE command $see<otherpf>. Each has its peculiarities, which will be described here.    Note that if you plotting on a terminal you should only interrupt a plot by doing ^^ (control-uparrow), because your terminal will be left in a strange state otherwise $see<whatnow>.

2Tektronix1

The Tektronix has problems keeping up with PLOT2 at 9600 baud if short vectors are used.  For that reason PLOT2 will not normally use short vectors.  On slow terminals PLOT2 can be directed to use short vectors by setting the variable $var<PADDED/TRUE> to FALSE, this will result is some increase in speed.

For a Tektronix with graphic cross-hairs the EDIT function $see<plotedit> can be used to edit plots.  (Put the labels in the right place etc.)

2Imlac1

ARDS graphics conventions are used.  Only Imlacs supporting these conventions are recognized by PLOT2. 

Imlacs do not have infinite room for storing vectors,  thus some plots (especially 3D and Contour plots) won't fit.  It may be necessary to locally clear the screen (with the CLEAR button) during a plot.  If you are also plotting for the Gould or the XGP output to those devices will not be effected.

2Grinnell TV's1

ARDS graphics conventions are used, however the coordinates are divided by 2 before being plotted, so WINDOW etc. should be chosen as though the screen coordinates ran from 0 to 1023 each way.

2Printing and Display1

These are really only intended to give a preview of the plot before it comes out on a higher resolution device like the XGP or the Gould.  Internally PLOT2 keeps a resolution appropiate for the standard graphics devices (about 1000 x 1000), so that good Hardcopies can be obtained.  Instead of attempting to draw dotted lines or symbols for the various linetypes $see<linetypes> different characters are used, although dotted lines and symbols will be drawn on the Hardcopy device. Line type 0 is drawn with .'s.  The other line types (1 - 9) are drawn with other symbols (*, #, $ etc.).  The symbols (specified by the tens digit of the line type) are defined by the letters (A, B, C etc.).  Unfortunately if you choose a line type that specifies both a line and a symbol, the line will in most cases overprint and so erase the symbol.

When plotting on another device, say the XGP, you might find that PLOTMODE:[X,D]; $see<otherpf>, results in your seeing only a corner of the plot.  This is because it is assuming the XGP's character size.  You can correct this by doing PLOTMODE:[D,X]; since this will use the terminal's character size.  The copies you get out of the XGP will have the characters slightly widely placed, but will otherwise be OK.

The difference between how PLOT2 handles Printing and Display terminals, is that with Display terminals PLOT2 knows that it can move the cursor around, and so it will plot your graph in the same order that it would on say a Tektronix.  With a Printing terminal, it stores up the entire plot, and spits it out at the end in a line by line fashion.  Multiple plots $see<allinone> are handled correctly, the entire plot coming out only after the LAST call to a plotting function.

The plotting is done on a character grid that is $var<PLOTHEIGHT/> high and $var<LINEL/> wide.  You may change these if you want, but the changes must be followed by a call to the PLOTMODE function (PLOTMODE(); will do) to re-initialize things.  With PLOTMODE(D) you will probably lose badly if PLOTHEIGHT or LINEL is set larger than your terminal can handle.  Note that you can restrict the area of the screen used, with more flexibility, by changing WINDOW $see<scales>.  Don't forget that you can look at WINDOW1 to see what the default was.

You might want to change the value of $var<CHARRATIO/2.5>.   This should equal the ratio of line-pitch to the character-pitch for your terminal.  This enables the EQUALSCALE:TRUE $see<scales> mode to work, and ensures that what you see on your screen/paper is the same shape as what will come out on the XGP.

2XGP1

Plotting on the XGP works by writing a file of ARDS graphics commands in a file on your default directory.  The filenames are .PLOT. 2uname*.  Since the XGP won't accept ARDS graphics commands, this file must be changed into something the XGP recognizes using the XP program.  There are two commands which do this for you: 
.function(XGPSAVE,filespec) 
produces an XGP'able file specified by 2filespec* of the last screenful (this might have consisted of several calls to PLOT2). 2filespec* defaults in the same way as the arguments to LOADFILE.  The resultant file is in the SCAN format for the XGP. You can get it XGP'ed by typing :XGP ;SCAN 2filespec* 2return* in DDT (using the DDT style filespec).  Don't forget to delete the files after they're printed, since they are usually large. If you are doing a lot of plots you might want to do
.example
	XGPSAVE(">",SCN,SECOND,2uname*);
.end scon
The advantage of this if 2-fold.  It will put the file on the secondary disk pack (PACK 13) which has more storage space.  The command :XGP ;SCAN 2uname*;* 2return* XGP's all the files of the form > SCN and DELETES them afterwards. (Note that currently the :XGP program can't be used on MC.  You have to log into AI to do it.  Also the SECOND device is not known to OLDIO MACSYM,  so if you are using OLDIO either use DSK,2uname* or preferably DSK,USERS1 - USERS1 is a secondary directory, all of whose files go on PACK 13).
.endfunction

Consider the example:
.begin narrow 8,0
.example
(PLOTMODE(X,GR),WINDOW:[100,900,0,950])$

(CALCOMPNUM:CALCOMPNUM1:40,VIEWPT:[-30,-20,5])$

PLOT3D((X^3+Y^4-0.2*X)*EXP(-X^2-Y^2)+0.3*EXP(-(X-1.225)^2-Y^2),
             X,-3,3,Y,-3,3);

XGPSAVE(">",SCN,DSK,CFFK);
.end
.end

The resulting plot is shown on the next page.

.next page
.example 
    
.end
.next page
The problem with the XGPSAVE command is that the files it produces are quite large.  Thus if you do not expect to get your plots off the XGP for a while the following two commands should be used.

.function(NAMEFILE,filespec)
takes the scratch file that PLOT2 uses in PLOTMODE(GOULD); or PLOTMODE(XGP); and copies it to 2filespec*.
.endfunction
.function(XGPSAVE1,filespec)
takes the file 2filespec* and converts it into XGP scan form.
.endfunction

Thus, XGPSAVE can be roughly defined as 
.scon
XGPSAVE(2filespec*):= (NAMEFILE(2filespec*), XGPSAVE1(2filespec*));
.scon
The advantage of this is that the scratch file (which contains ARDS graphics commands) is usually much shorter than the corresponding XGP file, thus if you want to generate several plots for the XGP, but aren't able to actually get them out on the XGP for a while then use NAMEPLOT now,  and convert them to XGP format with XGPSAVE1 at the last minute.

The XGPSAVE, NAMEFILE, and XGPSAVE1 commands all have to hop into DDT to do stuff (run the XP program, or copy files etc.).  You should not interrupt these functions with a ^Z, since you might be in DDT at the time.  If you do accidently do type ^Z at the wrong time you will see :INPUSH or somthing (meaning you have interrupted a Valret).  What you should then do is: alt-alt-V; if the current job (the one with the * by it) is not your MACSYMA, type $P and let it finish (it'll type :KILL or somthing when it's done); then do :INPOP<return>, this tells DDT to finish the valret you so rudely interrupted, and you should end up back in your MACSYMA.

Note that since these commands hack files in DDT, DDT's file defaults are changed by them.

Incidentally, since the file produced by NAMEFILE is ARDS graphics commands the plot it contains can be viewed by :IMPRNT'ing the file on an Imlac. 

2Gould1

Hardcopy can be produced off the Gould either by typing 2linefeed* after the plot has finished $see<whatnow> or by executing HARDCOPY(); $see<otherpf>.

HARDCOPY() (or a linefeed at the end of a plot) has to do stuff in DDT, so the  caveats about interrupting it with a ^Z apply.  It also changes your DDT's file defaults.

The parameters $var<GOULDSCALE/1.75> and $var<GOULDTHICK/2> govern the scale of the Gould output (the larger GOULDSCALE the larger the copy) and the thickness of the lines.  GOULDTHICK must be an integer.  The default GOULDSCALE and WINDOW $see<scales> produce a plot which nicely fits into an 8.5 x 11 piece of paper.

NOTE: Often people forget to say e.g. PLOTMODE(G,T); before doing a plot.  The thing to do in that case is: PLOTMODE(G,T); REPLOT(); followed by 2linefeed* $see<whatnow>.  The same applies for plotting on the XGP, except of course you have to do XGPSAVE.  This will only work if your plot consisted of a single call to a plotting function (the normal case).

.sec(Naming and Saving of Plots,namsav)

Plots can be given names, saved in files, killed just like other MACSYMA data types.  However since plots aren't really something MACSYMA knows about there are a number of commands specifically for manipulating plots.

.function(NAMEPLOT,plotname)
names the last call to one of the plotting functions 2plotname*. 2plotname* must be either an atom (e.g. FOOP) or an array element (e.g. SNOO[4]).  2plotname* is stuck onto the list  PLOTS  so it becomes for instance [2plotname*]. 2plotname* gets stuck on the VALUES or ARRAYS list as appropriate.  Typing rubout at the end of a plot causes a 2plotname* to get read in and NAMEPLOT applied to it $see<whatnow>.

What actually gets saved by NAMEPLOT are the unscaled data points plus most of the optional arguments to thee plotting function (the exceptions are FIRST, LAST, SAME $see<allinone> and DONT ).  This is why it works to change the scale before replotting the plot using REPLOT $see<otherpf>.
.endfunction

.function(SAVEPLOTS,|[filespec],plotname1,plotname2, ... |)
saves the plots 2plotname1*, 2plotname2*,... etc in the file 2filespec*. defaulting of 2filespec* is traditional (e.g. FOO is the same as FOO,">").  [2filespec*] may be omitted altogether in which  case the defaults (as used by e.g. LOADFILE) are used.      SAVEPLOTS([2filespec*],ALL); saves all the plots in PLOTS.  (or else you can say SAVEPLOT([2filespec*],PLOTS); ) (N.B. SAVEPLOTS may be done within a WRITEFILE, unlike for instance SAVE.)  Another action of SAVEPLOTS is the put the 2filespec* into the value of the saved plots.  Thus a subsequent SAVE([2filespec1*],FUNCTIONS,2plotname*); although it won't correctly save the data in  2plotname* will remember what file it was saved in using the SAVEPLOTS command. SAVEPLOTS returns a list of plots it succeeded in saving

.endfunction

.function(LOADPLOTS,filespec)
loads a file of plots created by SAVEPLOTS. 2filespec* defaults exactly as with LOADFILE.  It also sets the file defaults. LOADPLOTS may be done within a batch (unlike LOADFILE).
.endfunction


.function(KILLPLOTS,|plotname1,plotname2, ... |) 
frees up the array storage used by 2plotname1*,... etc. KILLPLOTS(PLOTS), KILLPLOTS(ALL) and KILLPLOTS() will apply KILLPLOTS to all the members of PLOTS.  Note the KILLPLOTS does not KILL 2plotname1* etc.  and in  particular it leaves the 2filespec* information stuck in by SAVEPLOTS.  (If you never want to reference a plot again it is probably better to do a KILLPLOTS followed by a KILL, since KILLPLOTS takes care to totally exorcise the arrays of the plot from the system, something that KILL might not manage to do).  If you doing a lot of plotting then you may get a message like NO CORE ARRAY when trying to name a plot (either by invoking NAMEPLOT explicitly or by typing rubout after a plot.)  If that happens all you have to do is check that all the plots that are  important are saved using the SAVEPLOTS command, then do KILLPLOTS(); NAMEPLOT(2plotname*); 
.endfunction

.function(REPLOT,plotname)
replots 2plotname*.  If the arrays of 2plotname* were destroyed either by a KILLPLOTS(2plotname*); or by SAVE'ing 2plotname* and LOADFILE'ing it into another MACSYMA, REPLOT checks to see if 2plotname* was ever saved using the SAVEPLOTS command, if it was it finds the 2filespec* under which it was saved, and then attempts a LOADPLOTS(2filespec*); (but taking care not to change the current file defaults) and replots 2plotname* if it was found in the file.  REPLOT understands the old format of saved plots.
.endfunction

If $var<DONT/> appears as an optional argument to the plotting functions then the points will be calculated, but not plotted.  This is primarly of use for creating plots that are to be named and used later.  DONT is a non-sticky option (like FIRST and LAST), and so doesn't get saved when the plot is named (so PLOT2(EXP(X),X,-1,1,DONT); REPLOT(); will plot something).


In order to assist the manipulation of plots, a list of plots is kept.  The list is called $var<PLOTS/> and it contains all the plots present in your MACSYMA.  After KILLPLOTS is executed on a plot it is removed from PLOTS.  However, if it had been previously saved with the SAVEPLOTS command an attempt to REPLOT that plot will cause it to be reloaded from the file it was saved in and it will be put back on the PLOTS list.


.function(OLDNAMEPLOT,plotname)
names the last plot 2plotname* using the old format for naming plots (which could be safely SAVE'd and LOADFILE'd but which took up much space)
.endfunction
.example
.once center
2Examples* 

  PLOT2(SIN(X),X,-%PI,%PI);
  2rubout*
  SNOO;
  REPLOT(SNOO); replots SNOO
  PLOTS; ==> [SNOO]
  KILLPLOTS(); kills the plots in PLOTS i.e. SNOO
  REPLOT(SNOO); ==> SNOO NOT A PLOT (and it wasn't saved)
  REPLOT(); replots the last plot (which happens to be the same as
	SNOO)
  2rubout*
  ARF;
  SAVEPLOTS([CFK,PLOT,DSK,USERS],ALL); saves the plots in PLOTS
  KILLPLOTS();
  PLOTS; ==> [] there are now no active plots around
  VALUES; ==> [SNOO,ARF]  both SNOO and ARF got put on the values list
	but only ARF is any good because:
  SAVE([CFFK],VALUES); ==> [[CFFK, >, DSK, USERS], SNOO, ARF]
  ^Z
  MACSYM^K
  LOADFILE(CFK,">",DSK,USERS);
  VALUES; ==> [SNOO,ARF]  as before
  PLOTS; ==> []
  REPLOT(SNOO); ==> SNOO NOT A PLOT (It was never SAVEPLOTS'ed)
  REPLOT(ARF); ==> CFK PLOT DSK USERS being loaded
                  (ARF is automatically loaded in and replotted)
  PLOTS; ==> [ARF]  ARF is stuck back into PLOTS
  KILLPLOTS(); kills the arrays in ARF but saves the fact that it came 
	from CFK PLOT
  REPLOT(ARF); ARF is replotted.
.end

The following precaution only applies to OLDIO MACSYMAS.  Note that things would be more difficult in the above example if one had called both files CFK,">", for then SAVEPLOTS would put the plots in e.g CFK,1 and SAVE would put the VALUES in CFK,2; however ARF would only know that it was saved in CFK,">",DSK, USERS so that the automatic LOADPLOTS that REPLOT tries to do would attempt to load from CFK,">" i.e. CFK,2 caused an error. I would then have to explicitly load up ARF by doing LOADPLOTS(CFK,1,DSK,USERS);

NEWIO MACSYMAs are smarter about this, since they can figure out
 what  ">" was changed into.

.sec(Transformations on Points,transformpts)


2POLAR, LOG, LINLOG, LOGLIN, LIN, and TXTYPE1

We first present some examples
.begin group turn on "_\"; tabs 8, 30, 34 ;  
.scon
PLOT2(1,T,0,2*%PI,POLAR);\\Plots a circle
.bcon
REPLOT(TRUE,LIN);\\Replots the previous plot on a linear
.bcon
\\scale (i.e. gives a horizontal line)
.bcon
PLOT2(EXP(X),X,0,10,LINLOG);\\Plots exp(X) on a Lin-Log scale

.end bcon
GRAPH2([1,2,5,10,50,100],[1,1.5,2.5,3,7,10],LOG);
.scon
Plots some random points on Log-Log scale.  Slope shows that y=sqrt(x).

If one of $var<POLAR/>, $var<LOG/>, $var<LINLOG/>, $var<LOGLIN/> appear as an optional argument to one of the 2D plotting functions, then the plots appear on the appropriate scale.

With POLAR the first arg to PLOT2 or the second arg to GRAPH2,  what is normally considered to be the y coordinate becomes r, the radius;  and what is normally considered to be the x coordinate becomes theta, the angle.

LOG causes both axes to appear on a log (base 10) scale.

LINLOG causes the y axis to appear on a log scale.

LOGLIN causes the x axis to appear on a log scale.

The optional arguments LOG and LOGLIN alse cause PLOT2 to choose  logarithmic intervals for the x variable, if the 2low*,2high* form of range specification is used $see<d2plot>.  (Something less than optimal probably happens for PARAMPLOT2 in this case).

CONTOURPLOT2 $see<contourplot> is regarded as being a 2D plotting function (since it does not transform its x and y coordinates).  Thus the above optional args work on it and CONTOURPLOT2(Y,X,0,2*%PI,Y,0,1,POLAR) does the right thing. Note that when a plot is saved, the points--- before their transformation---are saved, together with the type of transformation.  Thus is possible to change the transformation either using REPLOT $see<otherpf> or a ^A break $see<whatnow>.

With REPLOT all that is necessary is to supply an optional arg overriding the one originally given.   LIN is an optional argument that specifies no transformation (i.e. a LINear scale in both directions).  This can be given to REPLOT to turn off any transformations.

In a ^A break, the variable $var<TXTYPE/> is (locally bound) to the type of transformation.  Thus within a polar plot TXTYPE is POLAR. A value of FALSE implies no transformation (like LIN in REPLOT). The possible values of TXTYPE are FALSE, POLAR, LOG, LINLOG, LOGLIN, SPECIAL (for user defined transformations), and NOT3D (for Not3d plots $see<d3plot>).  Remember that after exiting the break the plot must be replotted (with a tab $see<whatnow>) for the change in TXTYPE to be saved.

2SPECIAL, XFUN, and YFUN1

If the optional argument $var<SPECIAL/> appears in the call to PLOT2 then immediately before sticking your data up on the screen PLOT2 looks at the values of $var<XFUN/FALSE> and $var<YFUN/FALSE>.  If they are FALSE the data gets scaled in the normal way and is plotted without further ado.  If either is non-FALSE then it should be the name of a function of 1 to 3 arguments which defines a transformation between the data and the x and y screen coordinates.  (The standard linear scaling is still applied the result of this transformation, to make your plot fit on the screen.)  The functions must be translated or compiled and must return a floating point result.  The way they work is best illustrated by an example.

Suppose   XFUN:POLARX;  YFUN:POLARY; where POLARX and POLARY are defined by: 
.example
    TRANSLATE:TRUE;
    POLARX(X,Y):=(MODEDECLARE([X,Y],FLOAT),Y*COS(X));
    POLARY(X,Y):=(MODEDECLARE([X,Y],FLOAT),Y*SIN(X));
.end scon
(note that X and Y are the THETA and R coordinates of a polar system)
.scon
then     PLOT2(1,X,0,2*%PI,SPECIAL);
.scon
produces CALCONMPNUM x data points (ranging from 0 to 2*%PI) and CALCOMPNUM corresponding y data points (all 1 in this case).  These x and y are given to the POLARX and POLARY functions as the first and second arguments and the value of these two functions is what is supplied to the normal scaling routines.  Thus this PLOT2 command will produce a circle (if EQUALSCALE:TRUE $see<scales>, an ellipse otherwise).  What we have  just described could of course all be done with the POLAR optional arg .  But then we have just described more or less what happens when you give the POLAR optional arg.

The arguments that XFUN and YFUN take are:
.begin group turn on "_\"; tabs 8, 16, 24, 32 ;  
.scon
\\1 arg\2 args\3 args
.scon
\XFUN\x\x,y\x,y,z
.bcon
\YFUN\y\x,y\x,y,z
.end
The first argument to PLOT2 is considered a y variable, and it's second argument an x variable.  For PARAMPLOT2 and GRAPH2 the first arguments are x variables and the second arguments are y variables.  For all the 2D plotting functions the z variable is 0.0.  (See below for the coordinate conventions for the 3d plotting functions).

In fact POLARX and POLARY come predefined in the PLOT2 files. Other XFUN's and YFUN's that may be of use are (omitting the  MODECLARE's):
.example
	    CLOG(X):=(IF X=0.0 THEN -90.0 ELSE LOG(ABS(X)))/LOG(10.0);
	    REFLECT(X):=-X$
	    YTOX(X,Y):=Y$
	    XTOY(X,Y):=X$
	    ZTOY(X,Y,Z):=Z$
	    ZTOX(X,Y,Z):=Z$  (just the same function really)
	    ROTATEX(X,Y):=X*COSANG-Y*SINANG$
	    ROTATEY(X,Y):=X*SINANG+Y*COSANG$
	    (SINANG and COSANG are set up by
	     INITROTATE(ANG):=(COSANG:COS(ANG),SINANG:SIN(ANG));)
.end
The following example plots ASIN(X) vs. X:
.example
  XFUN:YTOX;
  YFUN:XTOY;	These cause X and Y to be swapped
  PLOT2(SIN(X),X,-%PI/2,%PI/2,SPECIAL);	
.end
The XFUN's and YFUN's implied by the optional args POLAR,LOG,LINLOG,LOGLIN,LIN  are:
.begin group turn on "_\"; tabs 8, 25, 35 ;  
.scon
\optional arg.\XFUN\YFUN
.scon
\POLAR\POLARX\POLARY
.bcon
\LOG\CLOG\CLOG
.bcon
\LINLOG\FALSE\CLOG
.bcon
\LOGLIN\CLOG\FALSE
.bcon
\LIN\FALSE\FALSE
.end

23D Transformations and HOWCLOSE1

The perspective transformations $see<d3plot> work by the same XFUN and YFUN mechanism documented above.  In case to want to try changing the transformation here are the names of the functions used (although it is probably quite easy to confuse the function that figures out the hidden lines).

The hidden line routine also makes use of the variable HOWCLOSE. HOWCLOSE should evaluate a the name of a function of 3 arguments (x, y, and z) and should give a measure of how close the point [x,y,z] is to the viewer.  It is not necessary that this function return the exact distance [x,y,z] is away, just that the further away [x,y,z] is, the larger the number the function should return.
.skip
.begin group verbatim
CENTERPLOT  PERSPECTIVE  REVERSE  XFUN	     YFUN	HOWCLOSE
------------------------------------------------------------------------
non-FALSE   TRUE	 FALSE	  P3DX	     P3DY	HOWCLOSE3D
non-FALSE   TRUE	 TRUE	  P3DXR	     P3DYR	HOWCLOSE3D
non-FALSE   FALSE	 FALSE	  NP3DX	     NP3DY	HOWCLOSENP3D
non-FALSE   FALSE	 TRUE	  NP3DXR     NP3DYR	HOWCLOSENP3D
FALSE	    TRUE	 FALSE	  OLD3DX     OLD3DY	HOWCLOSEOLD3D
FALSE	    TRUE	 TRUE	  OLD3DXR    OLD3DYR	HOWCLOSEOLD3D
FALSE	    FALSE	 FALSE	  OLDNP3DX   OLDNP3DY	HOWCLOSEOLDNP3D
FALSE	    FALSE	 TRUE	  OLDNP3DXR  OLDNP3DYR	HOWCLOSEOLDNP3D
.end
.scon
The type of view is setup by doing
.inline function(INITPERSPEC,|CX,CY,CZ,VX,VY,VZ|)
.bcon
where [VX,VY,VZ] is the VIEWPT and [CX,CY,CZ] is the CENTERPLOT.

The optional argument NOT3D now causes YFUN to be bound to ZTOY.

.sec(Editing Plots,plotedit)

There exists a recently deeloped facility for editting pictures using the crosshairs on a Tektronix terminal.  This enables you to position labels accurately, and add in additional lines, arrows etc.

To load the editing package do 	LOADFILE(EDIT,FASL,DSK,CFK);

The main function in the package is called EDIT, and its intention is to allow you to enter labels and various odd lines onto an existing plot.  To use it you must have a function of no arguments, whose body is a BLOCK and the last statement in the BLOCK must be EXITGRAPH().  If the function is P(), say then P(); should plot as much of your picture as can be conveniently specified by PLOT2, GRAPH2 etc.

.function(EDIT,P)
will execute P(), but will stop before the final EXITGRAPH(), and display the cross-hairs.  By typing various letters EDIT will enter commands into the function P directly before the EXITGRAPH(),

Allowed characters are:
.begin narrow 8,5 indent 0,4
.scon
      2Rubout1, exit from EDIT
.scon
      2Space1, save the location of the crosshairs (for use with L and A)
.scon
      2S1, enters a SETPOINT command into your function
.scon
      2V1, enters a VECTOR command (should be preceded by a
	SETPOINT or another VECTOR command)
.scon
      2L1, draws a line between the saved location and the
	crosshairs and enters it in the function.
.scon
      2A1, draws an arrow head pointing in the direction from the saved location to the crosshairs.  The tip of the arrow is at the crosshairs.  The size of the arrow is ARROWSIZE (a floating point number in raster units, default value 20.0) and its half angle is ARROWANG (a floating point number in radians, default value 0.2).  (The arrow is drawn using the ?ARROW function, defined in EDIT FASL.  It takes 4 integer arguments, similarly to ?LINE $see<primitives>.  Thus ?LINE(20,20,100,100),?ARROW(20,20,100,100) draws a line with an arrow head on it.)
.scon
      2P1, reads text from the keyboard and prints it left justified at the cursor.  Echoing is suppressed while it is reading the text.  Reading continues until a Carriage-Return is encountered.  The case of the text is remembered, but if you want it preserved after, say STRINGOUT'ing and BATCH'ing you should set BOTHCASES:TRUE; scon      2C1, same as P, except the text is centered.
.scon
      2R1, same as P, except the text is right justified
.end
.scon			
    Remember that after exiting EDIT your function will have been changed, so that P(); should give you the updated PLOT.  Items maybe be removed using the MACSYMA editor, or TECO.  To draw a picture from scratch you could do:
.endfunction
.example
      HOUSE():=BLOCK([],ENTERGRAPH(),EXITGRAPH());
      EDIT(HOUSE);  now with a sequence of S's and V's you can draw a
	house terminating it with a Rubout.
      HOUSE();  re-draws your house.
.end
.sec(Defaults,defaults)

.subsec(Options,options)
The defaults for the options are:
.example
	CALCOMPNUM:20;
	CALCOMPNUM1:20;
	EQUALSCALE:FALSE;
	NOPRINT:FALSE;
	DATEPLOT:TRUE;
	XAXIS:ALL;
	YAXIS:ALL;
	TICKNUM:10;
	TICKSIZE:6;
	UNDERSIDE:TRUE;
	REVERSE:FALSE;
	PERSPECTIVE:TRUE
	PLOTNUMPREC:7;
	CONTOURS:20;
	LABELCONTOURS:TRUE;
	VIEWPT unbound
	CENTERPLOT unbound
	WINDOW unbound
	XMAX,XMIN,YMAX,YMIN,ZMAX,ZMIN unbound
	CLEAR:TRUE;
	WAIT:TRUE;
	PLOTBELL:TRUE;
**	GOULDSCALE:1.75;
**	GOULDTHICK:2;
**	CHARRATIO:2.5;
**	PADDED:TRUE;
**	LINEL		(terminal dependent)
**	PLOTHEIGHT	(terminal dependent)
**	PLOTMODE	(terminal dependent) 
.end
The double asterisk **  marks those options not reset by PLOTRESET();

The switches whose default state is unbound are put on the VALUES list when they are given a value.  The other switches get put on the MYOPTIONS list when they get changed.  So all options can be saved by doing SAVE([2fn1*,2fn2*,DSK,2dir*],MYOPTIONS,VALUES);)

The following are "read-only" options $see<scales>:
.example
	XMAX1,XMIN1,YMAX1,YMIN1,ZMAX1,ZMIN1
	VIEWPT1,CENTERPLOT1
	WINDOW1
	XMAX3D,XMIN3D,YMAX3D,YMIN3D,ZMAX3D,ZMIN3D
.end
.subsec(Lines and Symbols,linesymb)
  See $ref<linetypes>.  The defaults for the dashed lines are (not reset by PLOTRESET();):
.example
	DEFINEDASH(0,FALSE);		(solid line)
	DEFINEDASH(1,[40,8]);
	DEFINEDASH(2,[15,8]);
	DEFINEDASH(3,[1,7]);
	DEFINEDASH(4,[30,8,1,8]);
	DEFINEDASH(5,[30,8,1,8,1,8]);
	DEFINEDASH(6,[40,8,1,8,5,8,1,8]);
	DEFINEDASH(7,[8,30]);
	DEFINEDASH(8,[1,20]);
	DEFINEDASH(9,TRUE]);		(no line)
.end
The defaults for the symbols are (not reset by PLOTRESET();):
.example
 	DEFINESYMBOL(0,FALSE);		(no symbol)
	DEFINESYMBOL(1,[[0,6],[0,-6],[-6,0],[6,0],[0,0]]);
	DEFINESYMBOL(2,[[4,4],[-4,-4],[4,-4],[-4,4],[0,0]]);
	DEFINESYMBOL(3,[[6,6],[6,-6,-6,-6,-6,6,6,6],[0,0],[0,0]]);
	DEFINESYMBOL(4,[[8,0],[0,-8,-8,0,0,8,8,0],[0,0],[0,0]]);
	DEFINESYMBOL(5,[[0,8],[6,-4,-6,-4,0,8],[0,0],[0,0]]);
	DEFINESYMBOL(6,[[0,-8],[6,4,-6,4,0,-8],[0,0],[0,0]]);
	DEFINESYMBOL(7,[[8,0],[-4,6,-4,-6,8,0],[0,0],[0,0]]);
	DEFINESYMBOL(8,[[-8,0],[4,6,4,-6,-8,0],[0,0],[0,0]]);
	DEFINESYMBOL(9,TRUE);		(point)
.end

For PLOTMODE(PRINTING); or PLOTMODE(DISPLAY) the default line and symbol characters (defined by e.g. DEFINESYMBOL(1,"A");) are
.example
			   0  1  2  3  4  5  6  7  8  9
		lines      .  *  #  $  %  &  +  @  - none
		symbols  none A  B  C  D  E  F  G  H  I
.end
.subsec(PLOTMODE,plotmode)
  See $ref<otherpf>. Unless you set the PLOTMODE before PLOT2 is loaded, PLOTMODE gets initiallized according to LISP's TTY variable as follows:
.example
	TTY	PLOTMODE
.skip

	0	PRINTING
	1	DISPLAY			(datapoint)
	2	DISPLAY			(datapoint)
	3	IMLAC
	4	TEKTRONIX
	5	DISPLAY 		(TV these may soon be supported)
	6	PRINTING		(decwriter)
	7	(software tty) depends on the terminals characteristics
		as follows (this is the order the questioning are asked)
		Can't do cursor positioning	PRINTING
		Can't selectively erase		TEKTRONIX
		Can't overprint			DISPLAY
		An IMLAC (%TOIML)		IMLAC
		Not an AI-TV			GRINNELL
		Else				DISPLAY
	8	PRINTING		(terminet)
	9	DISPLAY			(other display)
.end
If WINDOW is unbound then it is chosen according to PLOTMODE as
	follows
.example
	if GOULD then [0, 1023, 5, 790]
	else if TEKTRONIX then [0, 1023, 5, 790]
	else if IMLAC then [0, 1023, 200, 1006.))
	else if PRINTING or DISPLAY then [0, 2char-width**LINEL-1,
					  0, 2char-height**PLOTHEIGHT-1]
	else [0, 1023, 0, 1023]
.end
For example, if PLOTMODE:[I,G], WINDOW is chosen to be [0, 1023, 5, 790] (because the GOULD condition is satisfied first).

For PRINTING or DISPLAY terminals 2char-width* and 2char-height* are chosen to make WINDOW be close to that for the other devices. The formulas used are
.example
	2char-width*  = 1 + ENTIER(1023/LINEL)
	2char-height* = ENTIER(0.5 + CHARRATIO*2char-width*)
.end
.sec(Primitives Called by PLOT2,primitives)

With the following functions practically no argument checking is done. So make sure a function gets floating-point numbers or integers as it needs them.  In particular 2xf*, 2xf1*, 2yf*, 2yf1* should all be floating point (unscaled) screen coordinates, and 2x*, 2x1*, 2y*, 2y1* should be integer screen coordinates after all scaling.  Some of the basic functions below come in 3 versions.

The one with the ? in front is the most basic.  Its arguments are in screen raster coordinates.

The middle one accepts floating point arguments as screen coordinates before the last stage of (linear) scaling is done.

The last one with a 3 at the end takes x, y, and z arguments and applies the transformation functions (set up with ?CALL\-INIT to them).
.example
?SETPOINT(2x*,2y*);	absolute setpoint
SETPOINT(2xf*,2yf*);
SETPOINT3(2xf*,2yf*,2zf*);

?POINT(2x*,2y*);	absolute point
POINT(2xf*,2yf*);
POINT3(2xf*,2yf*,2zf*);

?VECTOR(2x*,2y*);	absolute vector
VECTOR(2xf*,2yf*);
VECTOR3(2xf*,2yf*,2zf*);

?LINE(2x1*,2y1*,2x*,2y*);	line
LINE(2xf1*,2yf1*,2xf*,2yf*);
LINE3(2xf1*,2yf1*,2zf1*,2xf*,2yf*,2zf*);

CHANGEDASH(2n*);	change to dashed line 2n*
PUSHDASH();		change to dashed line 0 temporally
POPDASH();		undo PUSHDASH()

?DRAWSYMBOL(2x*,2y*,2n*);	draw symbol n
DRAWSYMBOL(2xf*,2yf*,2n*);
DRAWSYMBOL3(2xf*,2yf*,2zf*,2n*);

?TEK\-X(2xf*);	converts unscaled screen coordinates to raster coords
?TEK\-Y(2yf*);

?TEK\-XF(2x*);  converts raster coordinates to unscaled screen coords
?TEK\-YF(2y*);

SCREENSIZE(2min-x*,2min-y*,2max-x*,2max-y*);	sets the window in which
	plotting is done.  if a vector goes outside this window it will
	be clipped
SCREENSIZE1(2min-x*,2min-y*,2max-x*,2max-y*); 	same as SCREENSIZE
	except that the scale is left unchanged.  SCREENSIZE leaves
	2min-xf* etc. unchanged
SIZE(2min-xf*,2min-yf*,2max-xf*,2max-yf*);	sets the scale so that
	2min-xf*,2min-xf* gets plotted at 2min-x*,2min-y* etc.

?CALL\-X(2xf*,2yf*,2zf*);	applies transformation routines to give
?CALL\-Y(2xf*,2yf*,2zf*);		unscaled screen coords.

?CALL\-INIT(2xfun*,2yfun*);	initialized transformation routines to
	use 2xfun* and 2yfun*

CLEAR();		clears the screen
ENTERGRAPH();		should be done before a sequence of plotting.
	It will clear the screen if CLEAR is TRUE.
EXITGRAPH();		should be done after a sequence of plotting.
	If WAIT is TRUE it will wait for you to type in a char, and
	will return its ASCII value
HARDCOPY();		sends out a hardcopy signal

GHPRINT(2l*,2x*,2y*,2a*);	prints 2l* at (raster) coordinates
	2x*,2y*.  2a*=0 ==>left justify, 2a*=1 ==> center, 2a*=2 ==>
	right justify.  Add 10 to 2a* to get 2l* underlined.  2l* may
	be a list, in which case its element are concatenated together
GVPRINT(2l*,2x*,2y*,2a*);	prints 2l*.  2a*=1, 2, or 3 meaning
	top justify, center, or bottom justify.

.end




