
TITLE TENLOD
IF1,[
DEFINE INSERT A
A[6STAP]TERMIN
.INSRT DSK:JSF;STNDRD MACROS
]

IFNDEF MOBY,	MOBY==0		;FOR 16K
IFNDEF OLDSW,	OLDSW==0	;0 OR 1, 1 => LOADING INTO PDP10 FROM PDP6
IFNDEF SUDTSW,	SUDTSW==-1	;+1 => SUDTAP, 0 => NO SUDTAP, -1 => TTY & JSR ONLY
IFNDEF CBLKSW,	CBLKSW==1	;PAGE NTS CORE INTO HIGH TS CORE


;AC DEFINITIONS

FF=0
A=1
AA=2
B=3
C=4
D=5
E=6
F=7	;TEMPORARY FLAGS
G=10
S=13	;.SLEEP AC, CLOBBERED TO -1 BY INTERRUPT ROUTINE ON INTERRUPT FROM NTS PROCESSOR
T=14
TT=15
Q=16
P=17

;IO CHANNELS

TYIC==1		;TYPEIN
TYOC==2		;TYPEOUT
UTYIC==5	;LOADER IN
UTYOC==6	;DUMPER OUT
USRIC==4	;PDP10 IN
USROC==3	;PDP10 OUT

;FLAG DEFINITIONS

GETTY==RHF FF,1		;ONE => GE TTY
PDPO==RHF FF,2		;ONE => PDP10 IS OPEN
ARGF==RHF FF,4		;ARGUMENT TYPED
ARGCF==RHF FF,10	;ARGUMENT COMPLETED
UTYIO==RHF FF,20	;CLOSE UTYIC ON ERROR
FFFLG==RHF FF,40	;USED BY GETFIL
LAFLG==RHF FF,100	;NOT USED BUT LOOKED AT BY GETFIL
MINUSF==RHF FF,200	;MINUS SIGN TYPED
RTYIF==RHF FF,400	;RUBOUT TYPED AT RTYI, OTHERWISE AVAIL. FOR MISC.
NTYO==RHF FF,1000	;CERTAIN ROUTINES SHOULD TYPE TO ALTERNATE LOCATION INSTEAD OF TYO
SDTSW==RHF FF,2000	;IN AND NOT ABOUT TO LEAVE SUDTAP MODE
SILNT==RHF FF,4000	;SILENCE TYPEOUT
WAKUPF==RHF FF,10000	;USED BY 10SLP AND TSINT TO CONTROL WAKING UP FROM SLEEP
SDTSW2==RHF FF,20000	;ENTER SUDTAP MODE ON NEXT SLEEP THIS COMMAND
UNECHF==RHF FF,40000	;TYI NOT TO ECHO
JSROTF==RHF FF,1_15.	;SET DURING BREAK => JSR'D INTO NTS CORE
	;LH(FF) USED BY SUDTAP MONITOR

;RANDOM

DDT=MOBY+34000	;STARTING ADDRESS OF DDT
10HIGH=MOBY+40000	;1 MORE THAN TOP OF PDP10 MEMORY
IFNDEF MACAC,	MACAC==4	;AC DDT PICKS UP STARTING ADDRESS FROM
IFNDEF MACQ,	MACQ==6		;HEH, HEH
IFNDEF 10T,	10T==5		;AC T IN DDT
IFNDEF 10P,	10P==1		;AC P IN DDT
MACCR=37777+MOBY	;MACDMP COMMAND POINTER
LPDL==40	;LENGTH OF PDL
UTIBFL==200	;LENGTH OF LOADER BUFFER
TOBS==10	;QUANTUM (NUMBER OF WORDS) FOR TYPOC (PSEUDO-TYO)
IFNDEF PDPTTY,PDPTTY==4	;PDP10 CONSOLE (TTY) NUMBER
IODEV ICL,20	;INTERCOM DEVICE BETWEEN PROCESSORS
IPDP10==.IPDP USROC,	;INTERRUPT NTS PROCESSOR
		; ^ (DOESN'T SKIP OR INTERRUPT TO SELF EVEN IF NOT OPEN)
IFNDEF R,R=SIGN		;ADD TO NTS ADR TO GET TS (PAGED) ADR

	;TEMPORARY FLAGS

	;LOADER

CLRCF==RHF F,1		;CLEAR CORE
CLRDF==RHF F,2		;CLEAR CORE BELOW DDT
KSYMF==RHF F,4		;KILL SYMS DDT ALREADY HAS
LSYMF==RHF F,10		;LOAD SYMBOLS
LOADF==RHF F,20		;LOAD PROGRAM
LDDTF==RHF F,40		;CLEAR CORE AND LOAD DDT FIRST
STRTF==RHF F,100	;SET STARTING ADDRESS
GOF==RHF F,200		;START UP PROGRAM
DDTGF==RHF F,400	;START UP DDT
DDTPGF==RHF F,1000	;START UP PROGRAM VIA DDT
NRLODF==RHF F,200000	;DON'T READ FILE FOR PROGRAM LOAD
DCCDF==RHF F,400000	;DON'T CLOSE UTYIC WHEN DONE LOADING

P2MSK==CLRDF\KSYMF\LSYMF\GOF\DDTGF

	;MACROS

	;COMMAND DEFINITION MACRO

DEFINE CMD CHAR,ROUT,BLURB
DEF CHR,\<CHAR>-40,[
ROUT
]
IFSE [BLURB],CONCAT CHB,\<CHAR>-40,==0
IFSN [BLURB],CONCAT CHB,\<CHAR>-40,==[ASCIZ \BLURB\]
TERMIN

	;INITIALIZE COMMAND DISPATCH AND BLURB TABLES

IF1,[REPEAT 100,[CONCAT CHR,\.RPCNT,==0
CONCAT CHB,\.RPCNT,==0
]
]

	;MACRO TO GIVE SYMBOLIC NAMES TO PDP10 LOCATIONS ENDING (RATHER
	;THAN BEGINNING) AT A CERTAIN LOCATION

DEFINE TAG ADR
ADR=TGOFST+.
TERMIN

DEFINE TGPREP LOCTN
TGOFST==LOCTN-.
TERMIN

		;TTY ROUTINES

DEFINE RTYIQM	;MACRO EXECUTED IF RUBBED BACK TO BEGINNING
IFE SUDTSW,ERR HUH
IFN SUDTSW,JRST RTYIR2
TERMIN

IFN SUDTSW,[DEFINE UNSLNC
	TESTF E,SDTSW
	POPJ P,
TERMIN
]
.INSRT JSF;DSK:STNDRD TTY

CRFF:	TESTF N,GETTY
	JRST CRLF
	JRST FORMF

SPACE4:	PUSHJ P,.+1	;TYPE FOUR SPACES
SPACE2:	PUSHJ P,.+1	;TYPE TWO SPACES
SPACE:	MOVEI A,40	;SPACE
	JRST TYO

		;ROUTINE TO TYPE OUT THE SIXBIT WORD IN AA

SIXTYO:	JUMPE AA,CPOPJ	;IF AA CLEAR THEN RETURN
	MOVEI A,0	;CLEAR A
	LSHC A,6	;SHIFT CHARACTER INTO A
	ADDI A,40	;CONVERT TO ASCII
	PUSHJ P,TYO	;TYPE IT OUT
	JRST SIXTYO	;GO GET REST

TTYGET:	.CALL TYGTBK	;GET TTY STATUS INTO COMMAND LEVEL VARIABLES
	.VALUE
	POPJ P,

TYGTBK:	SETZ
	SIXBIT /TTYGET/
	[TYIC]
	2000,,TTYST1'
	2000,,TTYST2'
	40200,,TTYSTS'

TTYSET:	.CALL TYSTBK	;SET TTY STATUS TO COMMAND LEVEL
	.VALUE
	POPJ P,

TYSTBK:	SETZ
	SIXBIT /TTYSET/
	[TYIC]
	TTYST1
	TTYST2
	SETZ TTYSTS

IFN SUDTSW,[

TTZGET:	.CALL TZGTBK	;GET TTY STATUS INTO SUDTAPE MONITOR LEVEL VARIABLES
	.VALUE
	POPJ P,

TZGTBK:	SETZ
	SIXBIT /TTYGET/
	[TYIC]
	2000,,TTZST1
	2000,,TTZST2
	402000,,TTZSTS

TTZSET:	.CALL TZSTBK	;SET TTY STATUS TO THAT FOR SUDTAPE MONITORING
	.VALUE
	POPJ P,

TZSTBK:	SETZ
	SIXBIT /TTYSET/
	[TYIC]
	TTZST1
	TTZST2
	SETZ TTZSTS

TTMSET:	.CALL TMSTBK	;SET TTY STATUS TO IMAGE MODE OUTPUT
	.VALUE
	POPJ P,

IFE CBLKSW,[	;FOLLOWING HERE ONLY IF NO JSR ROUTINES, ELSE AT JSRRS

TTZST1:	0
TTZST2:	0
TTZSTS:	0

JSRRS:	MOVEI D,TTZST1-1
	PUSH D,TTMST1
	PUSH D,TTMST2
	PUSH D,TTYSTS
	POPJ P,
]]

TMSTBK:	SETZ
	SIXBIT /TTYSET/
	[TYIC]
	TTMST1
	TTMST2
	SETZ TTYSTS

TTMST1:	131602,,121212	;INTERRUPT ON WAKEUP CHAR, CONVERT LOWER CASE
TTMST2:	131212,,121212	;INTERRUPT ON ^G, ^S


FOO==.
LOC	41
	JSR UUOH
LOC	FOO

IFE CBLKSW,[DEFINE UUOIRP A
IRPS UUO,,[GET BGET PUT BPUT
ACCESS CTYPE TYPE ERR]
A
TERMIN
TERMIN]

IFN CBLKSW,[DEFINE UUOIRP A
IRPS UUO,,[BGET
BPUT CTYPE TYPE ERR]
A
TERMIN
TERMIN
GET=MOVE R
PUT=MOVEM R
]

UUOIRP MINUUO==37-.IRPCNT,	;GET OP CODE OF MINIMUM UUO
UUOIRP UUO=<MINUUO+.IRPCNT>_33,	;DEFINE UUO'S

UUOH:	0		;UUO PROCESSOR
	PUSH P,A	;SAVE A
	PUSH P,AA	;SAVE AA
	PUSH P,B	;SAVE B
	PUSH P,C
	MOVEI C,-C(P)	;FOR ACRLOC
	HRRZ B,40	;GET EFFECTIVE ADDRESS FOR UUO ROUTINE
	LDB AA,[270400,,40]	;GET AC FIELD FOR UUO PROCESSOR
	LDB A,[331100,,40]	;GET OP CODE
	CAIGE A,MINUUO	;IF TOO SMALL,
ILUUO:	.VALUE		;THEN COMPLAIN
	PUSHJ P,@UUODTB-MINUUO(A)	;CALL ROUTINE FOR INDIVIDUAL UUO
	JRST .+2	;NON-SKIP RETURN POINT
	AOS UUOH	;ROUTINE SKIPPED, INCREMENT RETURN POINT
	POP P,C		;RESTORE C
	POP P,B		;RESTORE B
	POP P,AA	;RESTORE AA
	POP P,A		;RESTORE A
	JRST 2,@UUOH	;RETURN

UUODTB:	UUOIRP A!UUO	;DISPATCH TABLE

		;MAYBE RELOCATE AA (DOESN'T WORK FOR 0)

ACRLOC:	CAIG AA,C	;IF .LE. MAXIMUM PUSHED AC,
	ADDI AA,(C)	;THEN RELOCATE TO POINT TO AC ON PDL
	POPJ P,

		;GET THE CONTENTS OF THE AC POINTED TO BY AA INTO A

GETAC:	PUSHJ P,ACRLOC	;RELOCATE AA
	MOVE A,(AA)	;GET THE AC
	POPJ P,

		;RELOCATE AA, HRRO IT INTO A, AND SKIP-RETURN

GETACP:	PUSHJ P,ACRLOC	;RELOCATE AA
	HRROI A,(AA)	;GET THE AOBJN POINTER TO IT
	JRST POPJ1	;SKIP-RETURN

IFE CBLKSW,[	;FOLLOWING UUO'S ONLY IF NOT USING .CBLK
	;GET AC,ADR	;GETS THE CONTENTS OF ADR (IN THE PDP10) INTO AC
	;BGET AC,ADR	;GETS PDP10 CORE BLOCK STARTING AT ADR INTO BLOCK IN PDP6 SPECIFIED BY AOBJN POINTER IN AC

AGET:	PUSHJ P,GETACP	;GET AOBJN POINTER TO AC, SKIP OVER .+1
ABGET:	PUSHJ P,GETAC	;GET AOBJN POINTER FROM AC
	.ACCESS USRIC,B	;SET UP POINTER TO PDP10 CORE
	.IOT USRIC,A	;DO THE TRANSFER
	POPJ P,

	;PUT AC,ADR	;PUT CONTENTS OF AC INTO PDP10 LOCATION ADR
	;BPUT AC,ADR	;PUT PDP6 BLOCK SPECIFIED BY AOBJN POINTER IN AC INTO PDP10 BLOCK STARTING AT ADR

APUT:	PUSHJ P,GETACP	;GET AOBJN POINTER TO AC, SKIP-RETURN
ABPUT:	PUSHJ P,GETAC	;GET AOBJN POINTER FROM AC
	.ACCESS USROC,B	;SET UP POINTER TO PDP10 CORE
	.IOT USROC,A	;DO THE TRANSFER
	POPJ P,

		;ACCESS IOCH,ADR	;SAME AS OLD VERSION OF .ACCESS

AACCES:	DPB AA,[270400,,.+1]	;DEPOSIT IO CHANNEL
	.ACCESS B	;DO THE ACCESS
	POPJ P,
]

IFN CBLKSW,[	;USER UUO'S USING PAGING (.CBLK)
	;BGET AC,ADR	;GETS NTS CORE BLOCK STARTING AT ADR
		; ^ INTO TS BLOCK SPECIFIED BY AOBJN POINTER IN AC

ABGET:	PUSHJ P,GETAC	;GET AOBJN POINTER FROM AC
	ADDI B,R	;RELOCATE
	HLL B,A
	EXCH A,B
	JRST ABPUT1

	;BPUT AC,ADR	;PUT TS BLOCK SPECIFIED BY AOBJN POINTER IN AC
		; ^ INTO NTS BLOCK STARTING AT ADR

ABPUT:	PUSHJ P,GETAC	;GET AOBJN POINTER IN A
	ADDI B,R	;RELOCATE
ABPUT1:	HRL B,A
	JUMPGE A,CPOPJ	;JUMP IF NOTHING TO TRANSFER
	HLROS A
	SUBM B,A
	BLT B,-1(A)
	POPJ P,
]
		;CTYPE "CH	;TYPE OUT THE ASCII CHARACTER CH (PUSHJ TO TYO)

ACTYPE:	MOVE A,B	;GET CHARACTER IN A
	JRST TYO	;TYPE IT OUT AND RETURN

AERR:	TESTF E,UTYIO	;IF UTYIC SHOULD BE CLOSED,
	.IOPDL		;THEN RESET IO PDL,
	TMODF ZE,UTYIO	;...
	.CLOSE UTYIC,	;AND CLOSE IT
	PUSHJ P,ATYPE	;TYPE OUT THE TEXT STRING,
	LDB A,[270400,,40]	;GET AC FIELD,
	CAIL A,NERRS	;IF ILLEGAL AC FIELD,
ILLERR:	.VALUE		;THEN COMPLAIN
	MOVE P,[-LPDL,,PDL]	;RESTORE PDL,
	JRST @ERRDTB(A)	;GO TO RETURN POINT

ERRDTB:	ERRET		;0, NORMAL ERROR RETURN POINT
NERRS==.-ERRDTB
IFGE NERRS-20,[PRINTC /TOO MANY ERR DISPATCHES.
/]

GETFIL:	PUSHJ P,SPACE	;TYPE OUT A SPACE
	SETF FFFLG	;USED TO KEEP TRACK OF FILENAME COUNT
GFIL1:	MOVEI C,0	;INITIALIZE WORD
	MOVE B,[440600,,C]	;SET UP BP FOR INPUT
GFIL2:	PUSHJ P,RTYI	;GET CHARACTER IN A
	CAIN A,":	;IF COLON...
	JRST GCOL	;THEN PROCESS AS SUCH
	CAIN A,";	;SIMILARLY FOR SEMICOLON
	JRST GSEMC
	CAIN A,15	;IF CARRIAGE RETURN...
	MOVEI A,0	;THEN CLEAR A
	CAIN A,"	;IF CONTROL Q...
	JRST GFILCQ	;THEN GET NEXT CHARACTER AND TREAT AS NON-SYNTACTICAL
	CAILE A,40	;LOGICAL SPACE? (INCLUDING CR)
	JRST GFILC
	JUMPE C,GFIL5	;IGNORE NULL FILENAMES
	EXCH C,FN2
	TMODF ZE,FFFLG
	MOVSI C,(SIXBIT /@/)
	MOVEM C,FN1	;MOVE SECOND TO FIRST
GFIL5:	JUMPN A,GFIL1	;A=0 IF CHARACTER=CR OR ENABLED LA
	POPJ P,		;DONE
GCOL:	JUMPE C,GFIL1	;IF HE WANTS THE NULL DEVICE HE GETS TO TYPE IT IN
	HLRM C,DNAM	;MOVE TO RH OF DEVICE LOCATION
	JRST GFIL1	;LOOP
GSEMC:	JUMPE C,GFIL1	;NO NULL SYSTEM NAMES PLEASE
	MOVEM C,SNAM	;MOVE TO SYSTEM NAME LOCATION
	JRST GFIL1	;LOOP
GFILCQ:	PUSHJ P,RTYI	;CONTROL Q EATS UP THE NEXT CHARACTER
GFILC:	SUBI A,40	;CONVERT CHARACTER TO SIXBIT
	TLNE B,770000	;TOO MANY CHARACTERS?
	IDPB A,B	;NO
	JRST GFIL2	;LOOP

	;FFFLG USED TO SORT OUT FILENAMES

DNAM:	(SIXBIT /DSK/)	;ROUTINE OUTPUTS HERE
FN1:	SIXBIT /@/
FN2:	SIXBIT /@/
SNAM:	0		;SYSTEM NAME

BEG:	MOVEI FF,0	;INITIALIZE FLAGS
	MOVE P,[-LPDL,,PDL]
	MOVE A,[-SUSBKL,,SUSBK]
	.SUSET A	;DO A BUNCH OF .SUSETS
	PUSHJ P,TYINIT	;INITIALIZE TTY
	PUSHJ P,TTYGET	;GET TTY STATUS
IFN SUDTSW,[MOVEI D,TTZST1-1
	INSIRP PUSH D,[TTMST1 TTMST2 TTYSTS]
]	PUSHJ P,KSYMS	;KILL SYMBOLS IF ANY
	SETZM SVSYMP	;INDICATE NO POINTER TO DDT INITIAL SYMS BEING SAVED
	IFN SUDTSW,PUSHJ P,SUDINI	;INITIALIZE SUDTAP MONITOR
	PUSHJ P,CRFF	;TYPE CRLF OR CRFF
	TYPE [ASCIZ /TENLOD./]
	MOVE AA,[.FNAM2]
	PUSHJ P,SIXTYO
	PUSHJ P,10INIT	;MUST BE LAST IN INITIALIZATION DUE TO POSSIBILITY OF FAILURE

GCMD1:	PUSHJ P,CRRR
ERRET:	CLEARF ARGF\ARGCF\MINUSF\RTYIF\NTYO\SDTSW\WAKUPF\SDTSW2\UNECHF\JSROTF
	SETZM OVAL
	SETZM DVAL
	SETZM VALUE
	SETZM RTYIP	;COMMAND POINTER FOR TYPEIN WITH RUBOUT
	MOVEI A,15
	HRRM A,RTYIDL	;INITIALIZE DELIMITER FOR RTYI
GCMD:	PUSHJ P,TYI
	CAIL A,40
	CAILE A,140
	JRST N6B	;NOT SIXBIT
	MOVEI T,-40(A)
	IDIVI T,3
	LDB T,DTBP(TT)
	JUMPE T,ERRET	;IF NOT COMMAND THEN CLEAR STATUS OF ARG, BUT OTHERWISE IGNORE
	PUSHJ P,(T)
	JRST GCMD1	;ROUTINE DIDN'T SKIP, REINITIALIZE ARGUMENTS
	JRST GCMD	;ROUTINE SKIPPED, DON'T REINITIALIZE
	JRST ERRET	;ROUTINE SKIPPED TWICE, REINITIALIZE BUT DON'T TYPE CRRR

N6B:	CAIN A,177	;IF RUBOUT,
	ERR HUH		;THEN RESET COMMAND STATUS
IFN SUDTSW,[CAIN A,^X	;IF THE NON-SIXBIT WAKE-UP CHARACTER,
	JRST GCMD1	;THEN GO KERCHINK
]
		;INSERT OTHER NON-SIXBIT COMMANDS HERE
	JRST ERRET	;REINITIALIZE ARGUMENT STATUS, OTHERWISE IGNORE

SUSBK:	.RSNAM,,SNAM	;.SUSET BLOCK: GET INITIAL SYSTEM NAME
IFN SUDTSW,IFN CBLKSW,.RSNAM,,ISNAM	;INITIAL SYSTEM NAME
	.SMASK,,IMSK	;SET INTERRUPT MASK
	.SMSK2,,IMSK2	;ALSO FOR SECOND WORD
INTON:	.SPICL,,[-1]	;ENABLE INTERRUPTS
SUSBKL==.-SUSBK	;LENGTH OF BLOCK

INTOFF:	.SPICL,,[0]	;INHIBIT INTERRUPTS

	CMD "?,QUEST,LIST COMMANDS

QUEST:	MOVE B,[441400,,BTB]
	MOVEI T,40
	PUSHJ P,CRFF
	TYPE [ASCIZ /   SILENCE TYPEOUT
   WAKE UP FROM SLEEP
/]
QUESTL:	ILDB AA,B
	CAIN AA,7777	;DONE?
	POPJ P,		;YES
	JUMPE AA,QUSTL2	;NO, BUT JUMP IF INACTIVE CHARACTER
	MOVE A,T	;GET COMMAND CHARACTER IN A
	PUSHJ P,TYO	;TYPE OUT THE CHARACTER
	PUSHJ P,SPACE4	;TYPE 4 SPACES
	TYPE (AA)	;TYPE THE BLURB
	PUSHJ P,CRLF	;NEW LINE
QUSTL2:	AOJA T,QUESTL

		;GET THE CURRENT VALUE INTO A AND SKIP, OR DON'T SKIP IF NO VALUE

ARGET:	TESTF N,MINUSF	;IF MINUS NOT TYPED,
	SKIPA A,VALUE	;THEN RETURN VALUE
	MOVN A,VALUE	;RETURN NEGATIVE OF VALUE
	TESTF E,ARGF
POPJ1:	AOS (P)		;ARGUMENT EXISTS
	POPJ P,

		;NUMBERS

	REPEAT 10.,CMD "0+.RPCNT,NUM

NUM:	TESTF E,ARGCF
	ERR HUH		;ERROR IF CURRENT VALUE COMPLETED
	SUBI A,"0	;CONVERT CHARACTER TO DIGIT
	MOVEI AA,10	;UPDATE OCTAL VALUE
	IMULM AA,OVAL
	ADDM A,OVAL
	MOVEI AA,10.	;UPDATE DECIMAL VALUE
	IMULM AA,DVAL
	ADDM A,DVAL
	MOVE AA,CRADIX	;UPDATE VALUE IN CURRENT RADIX
	IMULM AA,VALUE
	ADDM A,VALUE
	SETF ARGF
	JRST POPJ1	;SKIP-RETURN SO NOT TO KILL CURRENT VALUE

	CMD ".,PT,FORCE CURRENT VALUE TO DECIMAL
	CMD "',SQUOT,FORCE CURRENT VALUE TO OCTAL
PT:	SKIPA A,DVAL
SQUOT:	MOVE A,OVAL
	TMODF ZE,ARGF	;BARF IF NO ARGUMENT
VALRET:	TMODF OE,ARGF	;ENTRY TO RETURN VALUE IN A, BARF IF ARGUMENT
	ERR HUH
	TMODF OE,ARGCF	;BARF IF CURRENT VALUE COMPLETE
	ERR HUH		;ERROR IF NO CURRENT VALUE OR CURRENT VALUE COMPLETED
	MOVEM A,VALUE
	JRST POPJ1

OVAL:	0	;CURRENT VALUE, UPDATED IN OCTAL
DVAL:	0	;CURRENT VALUE, UPDATED IN DECIMAL
VALUE:	0	;CURRENT VALUE, UPDATED IN CURRENT RADIX, OR FINAL
CRADIX:	8	;CURRENT RADIX
RCHAR:	"'	;CHARACTER TO DOCUMENT RADIX ON TYPEOUT


	CMD "R,RDXSEL,SELECT DEFAULT RADIX

RDXSEL:	PUSHJ P,ARGET	;GET ARGUMENT IN A
	ERR HUH		;NO ARGUMENT SPECIFIED
	MOVEM A,CRADIX	;SET RADIX
	MOVEI B,177	;DEFAULT "RADIX IDENTIFICATION CHARACTER" NON-PRINTING
	CAIN A,8	;IF OCTAL,
	MOVEI B,"'	;THEN USE SINGLE QUOTE
	CAIN A,10.	;IF DECIMAL,
	MOVEI B,".	;THEN USE PERIOD
	MOVEM B,RCHAR
	POPJ P,

	CMD "=,EQLS,PRINT OUT VALUE IN CURRENT RADIX

EQLS:	PUSHJ P,ARGET	;GET ARGUMENT
	ERR HUH		;TYPE OUT VALUE OF NOTHING?
	PUSHJ P,RTYO	;TYPE IT OUT
	MOVE A,RCHAR	;GET RADIX IDENTIFICATION CHARACTER,
	JRST TYO	;TYPE IT OUT AND RETURN

RTYO:	LSHC A,-35.	;SET UP A AND AA,
	LSH AA,-1	;TO BOTH ARE POSITIVE AND BIT 1.1(A) HAS "SIGN" BIT
	DIV A,CRADIX	;DO INITIAL DIVISION
	JRST RTYO2	;TRANSFER TO REST OF ROUTINE

RDXTYO:	IDIV A,CRADIX
RTYO2:	JUMPE A,RDXTY2
	HRLM AA,(P)
	PUSHJ P,RDXTYO
	HLRZ AA,(P)
RDXTY2:	MOVEI A,60(AA)
	TESTF N,NTYO	;IF TYPEOUT HACK FLAG NOT SET,
	JRST TYO	;THEN USE NORMAL TYPEOUT
ALTYO:	JRST		;ALTERNATE TYPEOUT

	CMD "-,MINUS

MINUS:	TESTF E,ARGF	;IF ARGUMENT,
	ERR HUH		;THEN COMPLAIN
	SETF MINUSF	;SET FLAG,
	JRST POPJ1	;RETURN

	CMD "Q,WIPOUT,VALRET AN ALTX. REQUIRES .

WIPOUT:	PUSHJ P,LOSSNP	;LOSE IF USER TYPES OTHER THAN A .
	.VALUE [ASCIZ /./]
	POPJ P,

	CMD "X,RETTY,RETURN TTY TO DDT

RETTY:	PUSHJ P,PDPCLS	;GIVE UP PDP10 WHENEVER GIVING UP TTY
	.VALUE [0]
	JRST 10INIT	;TRY TO OPEN THE PDP10 UP AGAIN

	CMD "O,CMDO,OPEN THE PDP10 FOR MUNGING

CMDO:	PUSHJ P,ARGET	;O TAKES OPTIONAL ARGUMENT
	JRST 10INIT	;WITHOUT ARGUMENT IT DOES WHAT THE DOCUMENTATION SAYS
	ANDI A,1	;WITH ARGUMENT, IT SELECTS NORMAL (0) OR CROCK (1) DDT
	MOVE A,[SIXBIT /DDT   RDDT/](A)	;EVER SEE AN INDEXED CONSTANT BEFORE?
	MOVEM A,DDTFN2
	POPJ P,

10INIT:	.SUSET [.RUNAM,,UNAME]
	MOVEI A,6	;BLOCK IMAGE INPUT
	HRLM A,PDPNAM
	.OPEN USRIC,PDPNAM	;OPEN IT FOR INPUT
	ERR [ASCIZ /  PDP10 NOT AVAILABLE.
/]
IFE SUDTSW,	MOVEI A,7	;BLOCK IMAGE OUTPUT
IFN SUDTSW,[	MOVEI A,27	;" " ", INFERIOR
	HRLM A,PDPNAM		;STORE AS MODE FOR .OPEN
	.OPEN USROC,PDPNAM	;TRY TO OPEN IT
	TRZA A,20		;LOSE, NOW TRY NOT AS INFERIOR
	JRST 10INI2		;WIN
]
	HRLM A,PDPNAM		;STORE NEW MODE FOR OPEN
	.OPEN USROC,PDPNAM	;OPEN IT FOR OUTPUT
	ERR [ASCIZ /  PDP10 NOT AVAILABLE FOR OUTPUT.
/]
10INI2:	IFN CBLKSW,[MOVEI E,[ASCIZ / CAN'T .CBLK PDP6.
/]
	JSP Q,CBLK
	2_9+400+USROC,,SIGN+<R/2000>_9	;PAGE IN PDP6
	10HIGH/2000	;RIGHT NUMBER OF BLOCKS
]	SETF PDPO		;DOCUMENT FACT THAT PDP10 OPEN
	POPJ P,

	CMD "C,PDPCLS,CLOSE THE PDP10

PDPCLS:	CLEARF PDPO	;INDICATE NO LONGER OPEN
IFN CBLKSW,[MOVEI E,[ASCIZ / LOST ON FLUSHING CORE.
/]
	JSP Q,CBLK	;FLUSH PAGED IN PDP6 PAGES
	<R/2000>_9
	10HIGH/2000
]	.CLOSE USRIC,	;CLOSE INPUT
	.CLOSE USROC,	;CLOSE OUTPUT
	POPJ P,

LOSSNP:	PUSHJ P,TYI	;LOSE IF NEXT CHARACTER IS NOT A PERIOD
	CAIE A,".
	ERR HUH
	POPJ P,

	CMD "E,SSA,STARTING ADR (SET IT OR HAS VALUE OF)

SSA:	PUSHJ P,ARGET	;GET ARGUMENT,
	JRST STADR	;NO ARG => RETURN VALUE
	TLNN A,777000	;IF INSTRUCTION PART ZERO,
	TLO A,(JRST)	;THEN TURN INTO JRST
	MOVEM A,GOINST	;DEPOSIT AS STARTING INSTRUCTION
	POPJ P,

STADR:	SKIPN GOINST	;IF NO STARTING ADDRESS,
	ERR [ASCIZ /  NO CURRENT STARTING ADDRESS.
/]
	HRRZ A,GOINST	;GET IT
	JRST VALRET

	CMD "Z,ZEROC,[CLEAR CORE, REQUIRES PERIOD]

ZEROC:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,LOSSNP	;LOSE IF NEXT CHARACTER NOT PERIOD.
	JRST RESET	;WIPE IT OUT

	;ROUTINE TO GENERATE ERROR IF PDP10 NOT OPEN

LOSSNO:	TESTF N,PDPO
	ERR [ASCIZ /  PDP10 NOT OPEN.
/]
CPOPJ:	POPJ P,

	CMD "L,LOAD,LOAD PROGRAM WITH DDT

LOAD:	PUSHJ P,ARGET	;GET ARGUMENT (INTERPRETED AS MASK),
	MOVEI A,LSYMF\LDDTF\STRTF\LOADF\CLRCF
	MOVE F,A	;SAVE AS MASK FOR LOAD
ALOAD:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,GETFIL	;READ FILE DESCRIPTION
	MOVEI A,6	;MODE FOR OPEN
	HRLM A,DNAM
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	.OPEN UTYIC,DNAM	;OPEN THE FILE
	ERR [ASCIZ /FNF?   /]	;NOT FOUND?
	SETF UTYIO	;TELL ERR TO CLOSE FILE IF OPEN
	TESTF E,LDDTF	;IF DDT SHOULD BE LOADED,
	PUSHJ P,LODDT	;THEN LOAD DDT
BLOAD:	TESTF E,CLRDF\KSYMF	;IF PDP10 CORE SHOULD BE MUNGED (OTHER THAN COMPLETELY)
	PUSHJ P,MNGCOR	;THEN DO SO
	TESTF E,CLRCF	;IF CORE SHOULD BE COMPLETELY CLEARED,
	PUSHJ P,RESET	;ZAP!
	TESTF N,LOADF\LSYMF\STRTF	;IF NOTHING REQUIRES READING FROM FILE,
	JRST CLOAD	;THEN BYPASS FOLLOWING
	TESTF N,NRLODF	;IF FILE SHOULD BE READ FOR READING,
	PUSHJ P,LODPGM	;THEN READ IT, AND LOAD IT IF DESIRED
	TESTF E,LSYMF	;IF SYMS SHOULD BE LOADED,
	PUSHJ P,LOADS	;THEN LOAD SYMS
CLOAD:	TESTF N,DCCDF	;IF INPUT FILE SHOULD BE CLOSED,
	.CLOSE UTYIC,	;CLOSE INPUT FILE
	TESTF N,DCCDF	;AND IF IT WAS CLOSED,
	CLEARF UTYIO	;DOCUMENT SAME
	TESTF E,GOF	;IF PROGRAM SHOULD BE STARTED UP,
	JRST STST	;THEN START UP PROGRAM
	TESTF E,DDTGF	;IF DDT SHOULD BE STARTED UP,
	JRST STDDT	;THEN START UP DDT
	TESTF E,DDTPGF	;IF PROGRAM SHOULD BE STARTED UP VIA DDT,
	JRST STPDT2	;THEN DO IT
	POPJ P,


	CMD "M,LDCC,LOAD BUT DON'T CLEAR CORE (NO SYMS)
	CMD "T,LCCDS,[KILL SYMS,CLEAR CORE < DDT,LOAD W/SYMS]	;BH'S IDEA (THE <)

LDCC:	SKIPA F,[STRTF\LOADF]	;LOAD AND SET STARTING ADDRESS
LCCDS:	MOVEI F,KSYMS\CLRDF\LOADF\LSYMF\STRTF	;KILL SYMS, CLEAR CORE BELOW DDT, LOAD, LOAD SYMS, SET STARTING ADDRESS
	JRST ALOAD	;GO DO IT

	CMD "N,LWS,LOAD WITH SYMS
	CMD "K,KKL,KLEAR KORE AND LOAD (NO SYMS)

LWS:	SKIPA F,[LSYMF\STRTF\LOADF]	;LOAD SYMS, SET STARTING ADDRESS, LOAD
KKL:	MOVEI F,CLRCF,\STRTF\LOADF	;CLEAR CORE, SET STARTING ADDRESS, LOAD
	JRST ALOAD	;GO DO IT

		;CLEAR CORE BELOW DDT AND/OR KILL SYMBOLS

MNGCOR:	TESTF N,KSYMF	;IF NOT KILLING SYMS,
	JRST LOAD3	;THEN GET DDT-2 IN A AND GO TO LOAD4
	MOVE T,[-2,,SVSYMP]	;SET UP AOBJN POINTER TO PDP6 VERSION OF DDT-2,DDT-1
	BPUT T,DDT-2	;CLOBBER DDT LOCATIONS (NEW SYMBOL POINTER AND CLOBBERAGE DOCUMENTATION)
	MOVE A,SVSYMP	;GET NEW SYMBOL POINTER IN A
LOAD4:	TESTF N,CLRDF	;IF NOT CLEARING CORE BELOW DDT,
	JRST LOAD5	;THEN GET LH(SVSYMP) INTO LH(B) AND GO TO LOAD6
	SETZM 10SV41	;CLEARING CORE BELOW DDT, MAKE IT INCLUDE 41
	IFN SUDTSW,SETZM 10TYOL	;CLEAR TYO STATUS
	IFN SUDTSW,SETZM 10TYIL	;ALSO CLEAR TYI STATUS
	HRLZ B,A	;B:=LAST LOCATION TO CLEAR+1,,0
	MOVE A,[30,,30]	;30 IS FIRST LOCATION CLEARED
LOAD6:	SUB A,B		;CALCULATE AOBJN POINTER TO CORE TO CLEAR
	JRST CLRCOR	;CLEAR IT AND RETURN

		;RANDOM FROBS FOR ABOVE
LOAD3:	GET A,DDT-2	;GET DDT SYMBOL POINTER IN A
	JRST LOAD4	;GO BACK TO ROUTINE

LOAD5:	HLLZ B,SVSYMP	;GET LH(SVSYMP) IN B
	JRST LOAD6	;GO BACK AND PROCESS

		;ROUTINE TO CLEAR SELECTED CORE
		;ARGUMENT IN A, AOBJN POINTER TO CORE TO CLEAR

IFE CBLKSW,[	;VERSION WITHOUT PAGING

CLRCOR:	PUSH P,SYMP	;SAVE CURRENT SYMBOL POINTER
	ACCESS USROC,(A)	;BEGINNING OF CORE TO CLEAR
	HLRES A		;-# WORDS TO CLEAR
	IDIVI A,2000	;GET -# BLOCKS IN A,- # EXTRA WORDS IN AA
	MOVN B,A	;SAVE # BLOCKS
	MOVEI E,[ASCIZ /NOT ENOUGH CORE TO CLEAR CORE.
/]			;ERROR MESSAGE IF LOSSAGE
	MOVSI A,-2000	;# WORDS IN ONE BLOCK
	JUMPE B,.+2	;IF LESS THAN ONE BLOCK,
	HRLZ A,AA	;THEN USE -# WORDS TOTAL
	PUSHJ P,ACORE	;GET THE CORE?
	HLRE T,A	;- # WORDS LOCAL TO CLEAR
	MOVE C,A	;AOBJN POINTER TO LOCAL CORE
	SUBM A,T	;RH(T):=LAST LOCATION LOCALLY TO CLEAR -1
	HRLI A,1(A)	;SET UP BLT POINTER,
	SETZM (A)	;CLEAR FIRST LOCATION
	BLT A,-1(T)	;CLEAR LOCAL CORE
	JRST CLRC3	;PUT LOCAL CORE INTO PDP10 CORE

CLRC2:	MOVE A,C	;AOBJN POINTER TO LOCAL CLEAR CORE
	.IOT USROC,A	;CLEAR PDP10 CORE
CLRC3:	SOJGE B,CLRC2	;DO IT # TIMES EQUAL TO NUMBER OF BLOCKS
	MOVE A,C	;RH HAS POINTER TO LOCAL CLEAR CORE
	HLL A,AA	;-# WORDS LEFT OVER
	.IOT USROC,A	;CLEAR REMAINDER OF CORE
	POP P,SYMP	;RESTORE OLD SYMBOL POINTER
	MOVEI E,[ASCIZ /LOST ON FLUSHING CORE.
/]
	JRST ACOR2	;GIVE IT UP AND RETURN
]

IFN CBLKSW,[	;VERSION USING PAGING

CLRCOR:	HLRO B,A
	MOVNS B
	ADDI B,(A)
	HRLS A
	AOJ A,
	SETZM -1(A)
	BLT A,-1(B)
	POPJ P,

	;JSP Q,CBLK	;DO .CBLKS AS DIRECTED
	;INITIAL .CBLK AC
	;# TIMES TO DO IT
	;RETURNS HERE
	;ERROR MSG SHOULD BE POINTED TO BY E

CBLK:	MOVE T,(Q)
	MOVE TT,1(Q)
CBLK1:	JUMPLE TT,2(Q)	;RETURN WHEN NO MORE PAGES TO CBLK
	.CBLK T,
	ERR (E)		;.CBLK LOST
	ADDI T,1001
	SOJA TT,CBLK1

]	;END IFN CBLKSW, CONDITIONAL

		;LOAD PROGRAM WITH DDT

LODDT:	PUSH P,F	;SAVE F
	CLEARF P2MSK	;CLEAR BITS NOT TO BE SET DURING LOAD OF PROGRAM
	SETF DCCDF	;TELL LOADER NOT TO CLOSE UTYIC WHEN DONE
	PUSHJ P,BLOAD	;LOAD PROGRAM
	PUSH P,A	;SAVE SADR
	PUSH P,E	;SAVE LOADER COUNT
	.IOPUSH UTYIC,	;SAVE UTYIC
	SKIPE DDTFIL+3	;SAVE A LITTLE TIME IF SYSTEM NAME IRRELEVANT
	.SUSET [.SSNAM,,DDTFIL+3]	;PREPARE TO OPEN DDT FILE
	.OPEN UTYIC,DDTFIL	;TRY TO DO SO
	ERR [ASCIZ /DDT FILE NOT FOUND.
/]
	MOVEI F,LOADF	;MASK FOR ACTUALLY LOADING DDT
	PUSHJ P,BLOAD	;LOAD DDT
	GET T,DDT-2	;GET INITIAL SYMS POINTER
	MOVEM T,SVSYMP	;SAVE IT WHERE IT BELONGS
	.IOPOP UTYIC,	;RESTORE UTYIC
	INSIRP POP P,[E A F]	;RESTORE WORLD
	ANDI F,P2MSK	;MASK TO BITS TO BE EXAMINED DURING SYMLOD ETC.
	SETF NRLODF	;PROG. ALREADY READ, DON'T READ IT AGAIN
	POPJ P,

GWD:	HRROI T,A	;GET A WORD IN A
GBLK:	.IOT UTYIC,T	;ENTRY TO INPUT A BLOCK
	JUMPGE T,CPOPJ	;IF ENTIRE BLOCK WAS TRANSFERED THEN RETURN
	ERR [ASCIZ /EOF?   /]	;END OF FILE ENCOUNTERED

LODRED:	MOVE T,A	;READ IN A BLOCK IN SBLK FORMAT
	PUSHJ P,GBLK	;GET THE BLOCK
	MOVE B,A	;SO NOT TO MUNG A
LODRD1:	ROT C,1		;CHECKSUM IN C, UPDATE IT
	ADD C,(B)	;" " "
	AOBJN B,LODRD1	;DO IT FOR THE ENTIRE BLOCK
	POPJ P,		;RETURN WITH CALCULATED CHECKSUM IN C

		;CLEAR CORE

RESET:	SETZM 10SV41
	IFN SUDTSW,SETZM 10TYOL	;CLEAR TYO STATUS
	IFN SUDTSW,SETZM 10TYIL	;ALSO CLEAR TYI STATUS
	.RESET USROC,
IFE OLDSW,[MOVE A,[-RIMLL,,RIMLDR]
	BPUT A,RIMLG	;SET UP RIM LOADER
]	IFN SUDTSW,PUSHJ P,JSRRS	;RESET JSR OUT VARIABLES
	POPJ P,

RIMLDR:	OFFSET -.	;SHADOW AND RIM LOADERS
RIMLG::	JFCL		;SHADOW LOADER, STARTING AT 0 IN SHADOW
	MOVSI (JFCL)
	CONO 635550	;INITIALIZE PROCESSOR STATUS
	CONO PI,11577	;CLEAR PI
	CONO UTC,223110
	CONO DC,4010
SHADL::	CONSO DC,1000	;LOOP POINT
	JRST .-1
	DATAI DC,SHADA
	AOJE SHADA,SHADL
	TRNE SHADA,-1
SHADA::	0
	JRST SHADL

.=20		;NOW FOR THE RIM LOADER

	CONO PTR,60	;START UP READER
RIMLP:	CONSO PTR,10	;WAIT FOR DATA READY
	JRST .-1
	DATAI PTR,RIMLX	;GET INSTRUCTION WORD (USUALLY A DATAI)
	CONSO PTR,10	;WAIT FOR READY AGAIN
	JRST .-1
RIMLX:	JFCL		;(USUALLY DATAI PTR,ADR) DO WHATEVER FILE WANTS
	JRST RIMLP

OFFSET 0
RIMLL==.-RIMLDR	;LENGTH OF THIS STUFF

		;READ FILE AND MAYBE LOAD PROGRAM FROM IT

LODPGM:	MOVEI AA,41	;FOR CAIX'S
	TESTF E,LOADF	;IF LOADING,
	SETOM 41SW	;THEN INDICATE TENLOD HAS THE REAL 41
	MOVEI E,0	;INITIALIZE LOADER COUNT
	PUSHJ P,GWD	;GET A WORD
	CAME A,[JRST 1]	;IF NOT END OF LOADER,
	AOJA E,.-2	;E NOT CLOBBERED BY REST OF LOAD, SYMS NOT LOADED
			;IF NO SBLK LOADER AND JUMP BLOCK NOT JUMPA
LOAD1:	PUSHJ P,GWD	;GET A WORD
	JUMPGE A,LDJBLK	;IF POSITIVE THEN JUMP BLOCK
	MOVE C,A	;INITIALIZE CHECKSUM
	MOVE D,A
LOAD2:	CAMGE A,[-UTIBFL,,0]	;IF BIGGER THAN BUFFER,
	HRLI A,-UTIBFL	;THEN USE BUFFER LENGTH
	HRRI A,UTIBUF	;MAKE IT POINT TO THE BUFFER
	PUSHJ P,LODRED	;READ IN A BLOCK
	TESTF N,LOADF	;IF PROG NOT TO BE LOADED,
	JRST NOLOD	;THEN DON'T MUNG INTO PDP10 CORE
	ADDI B,(D)	;C(B)+UTIBUF=1+LAST LOCATION IN BLOCK
	CAIL AA,(D)	;IF 41 LOWER THAN FIRST WORD IN BLOCK,
	CAIG B,UTIBUF+41	;OR 1+LAST LOCATION IN BLOCK .LE. 41,
	JRST NOLD41	;THEN DON'T LOAD 41
	MOVEI TT,41	;LOAD INTO 41
	SUBI TT,(D)	;MAKE TT POINT TO RELEVANT WORD IN BLOCK
	MOVEI T,0	;WORD TO BE SUBSTITUTED
	EXCH T,UTIBUF(TT)	;SUBSTITUTE AND SAVE ORIGINAL
	MOVEM T,10SV41	;SAVE FOR STARTING IT UP
NOLD41:	BPUT A,(D)	;LOAD INTO PDP10 CORE
NOLOD:	HLRS A		; -NUMBER OF WORDS PROCESSED
	HRLI A,-1(A)	;C(A):=<-# PROCESSED-1,,-# PROCESSED> = -<# PROCESSED,,# PROCESSED>
	SUBB D,A	;D HAD ORIGINAL AOBJN POINTER, ANSWER=NEW AOBJN POINTER
	JUMPL A,LOAD2	;JUMP IF MORE BUFFERINGS IN THIS BLOCK
	PUSHJ P,GWD	;GET FILE'S VERSION OF CHECKSUM
	CAME A,C	;IF NOT EQUAL TO CALCULATED ONE,
	ERR [ASCIZ /CHECKSUM ERROR.   /]	;THEN COMPLAIN
	JRST LOAD1	;GO GET ANOTHER BLOCK

		;JUMP BLOCK ENCOUNTERED DURING LOAD

LDJBLK:	TESTF E,STRTF	;IF STARTING INSTRUCTION SHOULD BE SET,
	MOVEM A,GOINST	;THEN DO SO
	POPJ P,		;FILE READ AND MAYBE PROGRAM LOADED, RETURN

		;LOAD SYMBOLS

LOADS:	TLC A,(JUMPA)	;IF JUMP BLOCK JUMPA THEN LH(LH):=0
	TLNE A,777000	;IF JUMP BLOCK NOT JUMPA,
	JUMPE E,CPOPJ	;AND NO SBLK LOADER, THEN REFUSE TO LOAD SYMBOLS
	HRRZS SYMP	;KILL ANY PREVIOUS
	MOVEI E,[ASCIZ /CORE FOR SYMS?/]	;ERROR MESSAGE IF CORE UNOBTAINABLE
	SKIPE SVSYMP	;IF NO DDT INITIAL SYMS POINTER,
	JRST LODS1	;...
	GET A,DDT-2	;THEN GET ONE
	MOVEM A,SVSYMP	;STORE IT WHERE IT BELONGS
LODS1:	PUSHJ P,GWD	;GET HEADER
	JUMPGE A,LODS2	;END OF SYMS IF POSITIVE
	MOVE C,A	;INITIALIZE CHECKSUM
	PUSHJ P,ACORE	;GET CORE FOR THIS BLOCK
	PUSHJ P,LODRED	;READ IN BLOCK AND CALCULATE CHECKSUM
	PUSHJ P,GWD	;GET CHECKSUM FROM FILE
	CAME A,C	;COMPARE WITH CALCULATED
	ERR [ASCIZ /CKS ON SYMS.
/]
	JRST LODS1	;DO IT AGAIN

LODS2:	GET B,DDT-2	;GET DDT POINTER INTO B
	HLRZ A,SYMP	;0,,-# SYMS TO BE LOADED
	HRLI A,-1(A)	;-# SYMS-1,,-# SYMS
	ADD A,B		;BIT CARRIES OVER INTO LH, RESULT=-TOTAL # SYMS,,LOWEST LOCATION SYMS
	MOVEI C,10HIGH	;GET MEMTOP IN C
	CAILE C,(A)	;IF .LE. LAST LOC TO BE LOADED,
	CAIG C,(B)	;OR IF .LE. LAST LOC TO BE LOADED,
	JRST LODS3	;THEN KILL SYMS AND COMPLAIN
	PUT A,DDT-2	;PUT IT BACK IN DDT
	MOVE T,DDT1C	;GET WORD TELLING DDT ITS SYMBOL TABLE WAS MUNGED
	PUT T,DDT-1	;PUT IT IN PDP10 CORE
	SKIPGE B,SYMP	;POINTER TO SYMS TO BE LOADED
	BPUT B,(A)	;LOAD INTO PDP10
	JRST KSYMS	;KILL SYMBOLS AND RETURN

LODS3:	PUSHJ P,KSYMS	;SYMS WERE ABOUT TO BE LOADED INTO NON-EXISTANT CORE
	ERR [ASCIZ /DDT IN CORE?	/]	;ERROR CONDITION

		;MAKE ROOM FOR SYMS

ACORE:	HLRE TT,SYMP	;TAKES -ARGUMENT IN LH(A)
	HLLZS A		;MASK TO ARGUMENT
	ADDM A,SYMP	;UPDATE POINTER
	HRRI A,SYMS	;A:=-# NEW SYMS,,SYMS
	SUB A,TT		;A:= -# NEW SYMS,,SYMS+# OLD SYMS
IFE CBLKSW,ACOR2:	;ENTRY TO CORE TO WHAT INDICATED BY SYMP
	HLRE TT,SYMP	;-TOTAL # SYMS
	SUBI TT,SYMS+1777	;-LAST LOC. SYMS -2000
	IDIV TT,[-2000]	;TT:=# BLOCKS CORE NEEDED
IFE CBLKSW,[.CORE 1(TT)	;TRY TO GET CORE
	ERR (E)		;COMPLAIN WITH RELEVANT MESSAGE
	POPJ P,
]IFN CBLKSW,[MOVE T,NBLKS
	SUB TT,T
	IMULI T,1001
	ADD T,.+2
	JSP Q,CBLK1
	4_9+400,,SIGN
	1000,,NBLKS
	DPB T,.-1
	POPJ P,
]
IFE CBLKSW,[
KSYMS:	HRRZS SYMP	;KILL SYMBOLS
	.CORE SYMS_<-10.>+1
	.VALUE		;LOST ON FLUSHING CORE?
	POPJ P,
]IFN CBLKSW,[
KSYMS:	HRRZS SYMP
	MOVEI T,ICOR*1001
	MOVE TT,NBLKS
	SUBI TT,ICOR
	JSP Q,CBLK1
	0
	0
	MOVEI T,ICOR
	MOVEM T,NBLKS
	POPJ P,
]

	CMD "F,STDDT,START UP DDT
	CMD "S,SSLP,PUT TTY TO SLEEP (AUTOMATIC ON GO)
	CMD "W,CPOPJ,(OR ) WAKE UP FROM SLEEP

STST:	SKIPN GOINST	;START UP PROGRAM AT STARTING ADDRESS,
	ERR [ASCIZ /  NO CURRENT STARTING ADDRESS.
/]			;BUT COMPLAIN IF NONE
START1:	SKIPA B,[10PGO]	;B:=INSTRUCTION TO PUT INTO 41
STDDT:	MOVEI B,DDTGO	;ENTRY TO START UP DDT
STRND:	HRRM B,10DSP	;SET ROUTINE FOR APR INITIALIZER TO TRANSFER TO
	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	AOSN 41SW	;IF LOCAL 41 ACCURATE VIA LOAD,
	JRST START2	;THEN USE IT,
	GET T,41	;OTHERWISE USE THE ONE IN IN THE PDP10
	MOVEM T,10SV41	;PUT IT WHERE IT BELONGS
START2:	MOVE C,[GOBEG-GOEND,,GOBEG]	;LOCAL LOCATION OF STARTING ROUTINE
	BPUT C,10ST	;PUT IT WHERE IT BELONGS
	MOVE T,[JRST 10ST]	;WORD TO PUT IN 41 TO START UP START ROUTINE
	PUT T,41	;START IT UP
	MOVEI S,15.	;1/2 SECOND (IN THIRTIETHS)
	.SLEEP S,	;WAIT,
	GET B,DUNSW	;AND SEE IF IT STARTED PROPERLY
	AOJE B,START3	;JUMP IF STARTED PROPERLY
	MOVE T,10SV41	;DIDN'T START PROPERLY, GET PROPER CONTENTS OF 41
	PUT T,41	;PUT THEN BACK IN 41
	TYPE [ASCIZ /  RUNNING?/]	;LET USER KNOW THERE'S DOUBT
START3:	IFN SUDTSW,[TESTF E,SDTSW2
	JRST TSLEEP	;SLEEP REGARDLESS OF CONSOLE IF ENTERING SUDTAP MONITOR MODE
]
	.SUSET [.RIOC+TYIC,,A]	;GET TTY IOCHNM
	LDB A,[221000,,A]	;CONVERT TO TTY NUMBER
	CAIE A,PDPTTY	;IF NOT PDP10 TTY,
	POPJ P,		;THEN JUST RETURN
SSLP1:	PUSHJ P,CRRR	;TYPE CR TO TELL USER DONE STARTING
	PUSHJ P,TTMSET	;OPEN TELETYPE FOR IMAGE MODE INPUT (NO ECHO)
STARTW:	PUSHJ P,TYI	;GET CHARACTER
	CAIE A,^X	;ALSO ALLOW CONTROL X
	CAIN A,"W	;W ORIGINAL CHARACTER BEFORE TYI CROCK
	JRST .+2	;W OR CONTROL X, TIME TO WAKE UP
	JRST STARTW	;NEITHER, GO BACK FOR MORE,
	PUSHJ P,TYO	;W, WAKE UP, ECHO THE W,
	JRST TTYSET	;AND OPEN THE TELETYPE RIGHT

IFE SUDTSW,SSLP=SSLP1
IFN SUDTSW,[

SSLP:	TESTF N,SDTSW2	;S COMMAND
	JRST SSLP1	;NOT ENTERING SUDTAP MODE

TSLEEP:	PUSHJ P,CRRR	;TYPE CR TO ACKNOWLEDGE COMMAND
	PUSHJ P,TTZSET	;INITIALIZE TYI MODE PROPERLY FOR OCCASION
	.SUSET INTOFF	;TRY TO AVOID TIMING ERROR ON FOLLOWING
	.RESET TYIC,	;CAUSE TYPEIN TO BEHAVE
	SETOB S,SNCHAR	;CAUSE CHARACTER COUNT TO AGREE (ALSO SHORT-CIRCUIT FIRST .SLEEP)
	CLEARF SDTSW2
	SETF SDTSW
	.DISMIS [SUDTAP]
]

	CMD "G,START,START UP PROGRAM

START:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,ARGET	;SEE IF ARGUMENT,
	JRST STST	;IF NOT THE USE STARTING ADDRESS,
	TLNN A,777000	;IF SO THEN USE SUPPLIED: IF INSTRUCTION PART ZERO,
	TLO A,(JRST)	;THEN USE JRST AS INSTRUCTION
	PUSH P,GOINST	;SAVE STARTING INSTRUCTION
	MOVEM A,GOINST	;TEMPORARILY USE SUPPLIED TO START IT UP
	PUSHJ P,START1	;START IT UP
	POP P,GOINST	;RESTORE STARTING INSTRUCTION
	POPJ P,

	CMD "H,STPDDT,START PROG VIA DDT

STPDDT:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,ARGET	;GET ARGUMENT IF ANY
STPDT2:	SKIPA A,GOINST	;NO ARGUMENT, USE STARTING ADDRESS (ENTRY FROM LOADER)
	TLNE A,777000	;ARGUMENT SPECIFIED, LOOK AT LEFT HALF
	JRST .+2	;IF LH NON-ZERO OR USING STARTING INSTRUCTION, THEN DON'T MODIFY
	TLO A,(JRST)	;INSTRUCTION PART ZERO, TURN INTO JRST
	MOVEI B,DEPDDT	;ADDRESS OF ROUTINE...
	HRRM B,ALTYO	;FOR ALTYO TO TRANSFER TO INSTEAD OF TYO
	SETF NTYO	;TELL ALTYO TO USE ALTERNATE ROUTINE
	MOVE B,[440700,,DDSTRI]	;BYTE POINTER TO DDT COMMAND STRING (LOCAL VERSION)
	PUSH P,CRADIX	;SAVE CURRENT RADIX,
	MOVEI AA,8	;AND REPLACE,
	MOVEM AA,CRADIX	;WITH OCTAL
	PUSHJ P,RTYO	;TYPE OUT STARTING INSTRUCTION IN OCTAL
	MOVE C,[440700,,[ASCIZ /X/]]
STPDT3:	ILDB A,C
	PUSHJ P,ALTYO
	JUMPN A,STPDT3
	POP P,CRADIX	;RESTORE CURRENT RADIX
	CLEARF NTYO	;MAY AS WELL
	MOVEI B,FGO	;TELL STARTER WHERE TO GO
	JRST STRND	;START IT UP

DEPDDT:	IDPB A,B	;DEPOSIT CHARACTER INTO DDT COMMAND STRING
	POPJ P,

		;INTERRUPT HACKERY

IMSK:	201000		;INTERRUPT MASK

	FOO==1_TYIC
	IFN SUDTSW,FOO==FOO\1_<USROC>	;FOR PDP10 INTERRUPTS
IMSK2:	FOO		;SECOND WORD INTERRUPT MASK

TMPLOC 42,JSR TSINT

TSINT:	0
	0
	AOSN INTLEV	;INCREMENT INTERRUPT LEVEL (SOMETIMES .DISMISSES TO SUBROUTINE THEN RETURNS)
JSRSW:	JRST TSINT1	;MODIFIED FROM JSRC
TSINT1:	PUSH P,G	;SAVE G,
	SKIPGE G,TSINT	;GET INTERRUPT REQUEST WORD IN G (WHERE IT STAYS UNTIL DISMISSAL)
	JRST WRD2I	;SECOND WORD, PROCESS SEPARATELY (RETURN TO WRD2IR)
	TRNE G,200000	;PDL OVERFLOW
	MOVE P,[-LPDL+1,,PDL+1]	;RE-INITIALIZE PDL (COMPLAIN LATER)
	PUSH P,A	;SAVE A
	TRZE G,201000	;ERROR CONDITIONS?
	JRST ERRBRK	;YES (RETURNS TO ERBKRT)
ERBKRT:	SKIPE G
RNDB1:	.VALUE		;RANDOM BIT(S) IN (FIRST WORD) INTERRUPT WORD
WRD2IR:	POP P,A		;RESTORE A
	SOSL INTLEV	;DECREMENT INTERRUPT LEVEL
	JRST TSINT2	;NOT ABOUT TO DISMISS TO MAIN PROGRAM LEVEL
	SKIPE G,INTRET	;DISMISSING TO MAIN PROGRAM LEVEL, GET RETURN POINT CLOBBERAGE, SKIP IF NONE
	HRRM G,TSINT+1	;CLOBBER IT
	SETZM INTRET	;DESTRUCTIVE READOUT
	POP P,G
JSRSW2:	JRST TSINTX	;MODIFIED

TSINT2:	POP P,G		;RESTORE G
TSINTX:	.DISMIS TSINT+1	;RETURN TO LOWER LEVEL

		;SECOND WORD INTERRUPT

WRD2I:	PUSH P,A
	TRZE G,1_<USROC>	;PDP10 INTERRUPT?
	JRST NTSBRK	;YES => TERMINATE .SLEEP EARLY IF ANY
NTSBRT:	TRZE G,1_TYIC	;CHARACTER TYPED IN?
	JRST TYIBRK	;YES
TYBKRT:	TDNE G,[SETZ-1]	;RANDOM BITS?
RNDB2:	.VALUE		;YES
	JRST WRD2IR

NTSBRK:	TESTF N,JSROTF
	MOVNI S,1
	JRST NTSBRT

		;ERROR INTERRUPT BITS (RETURN TO ERBKRT)

ERRBRK:	IFN CBLKSW,[IFN SUDTSW,[
	TESTF E,JSROTF
	JRST ERRBJ	;IN JSR MODE
]]	MOVEI A,0
	EXCH A,INTLEV	;RETURN TO MAIN PROGRAM LEVEL, GET FORMER INTLEV
	MOVEM A,ERRLEV	;SAVE LEVEL FOR ERROR PRINTOUT
	MOVEI A,ERRDSM	;DISMISS TO ERRDSM
	MOVEM A,INTRET	;" " "
	MOVE A,[TSINT,,ERRPIR]
	BLT A,ERRPCW	;SAVE PIRQC WORD AND GUILTY PC
	JRST ERBKRT	;THAT'S ALL FOR NOW, SEE YOU LATER AT...

		;MAIN PROGRAM LEVEL ROUTINE DISMISSED TO ON ERROR CONDITIONS

ERRBJ:		;TEMPORARILY
	MOVE A,[TSINT1,,TSINTX]
	HLRM A,JSRSW
	HRRM A,JSRSW2
ERRDSM:	PUSHJ P,TYINIT	;RE-INITIALIZE TTY
	PUSHJ P,TTYGET	;GET STATUS AGAIN
	CLEARF SILNT	;MAKE BEGINNING OF MESSAGE TYPE OUT
	PUSHJ P,CRLF	;START AT BEGINNING OF LINE
	MOVE A,ERRPIR	;GET THE PIRQC WORD
	TRNE A,200000	;CHECK PDL OVERFLOW
	TYPE [ASCIZ /PDLOV, /]
	TRNE A,1000	;CHECK ILLEGAL USER ADDRESS (.ACCESS POINTER ABOVE PDP10 MEMORY)
	TYPE [ASCIZ /ILUADR, /]
		;INSERT OTHER CONDITIONS HERE
	TYPE [ASCIZ /PC=/]
	PUSH P,CRADIX	;TYPE OUT THE PC IN OCTAL
	MOVEI A,8
	MOVEM A,CRADIX
	HRRZ A,ERRPCW
	PUSHJ P,RTYO	;TYPE OUT THE PC
	SKIPN A,ERRLEV
	JRST .+3	;INTERRUPTED FROM MAIN PROGRAM LEVEL => DON'T MENTION IT
	TYPE [ASCIZ /', INTLEV=/]
	PUSHJ P,RTYO
	POP P,CRADIX	;RESTORE FORMER TYPEOUT RADIX
	ERR [ASCIZ /' .
/]

ERRLEV:	0		;INTLEV WHEN ERROR CONDITION NOTICED (0 => INTERRUPTED FROM TOP LEVEL)

		;FOLLOWING TWO WORDS BLT'ED FROM TSINT AND TSINT+1
ERRPIR:	0		;PIRQC AT RELEVANT INTERRUPT
ERRPCW:	0		;PC WORD STORED

		;TYI BREAK (RETURN TO TYBKRT)
		;DON'T CLOBBER A ON THIS PAGE AFTER .ITYIC

TYIBRK:	MOVEI A,TYIC
	.ITYIC A,	;GET CHARACTER TYPED
	JRST TYBKRT	;NOT REALLY THERE
	CAIN A,^S	;IF CONTROL S,
	PUSHJ P,CTLSBK	;THEN MAYBE SILENCE TYPEOUT
IFE SUDTSW,JRST TYBKRT	;IF SUDTAP MODE DOESN'T EXIST, THEN THAT'S ALL
IFN SUDTSW,[TESTF N,SDTSW	;IF NOT IN SUDTAP MODE,
	JRST TYBKRT	;THEN THAT'S ALL
	CAIN A,^X	;IF CHARACTER IS CONTROL X,
	JRST WAKUPB	;THEN WAKE UP
	AOSLE SNCHAR	;ANOTHER CHARACTER: THE FIRST?
	JRST TYBKRT	;NO
	PUSH P,TSINT	;YES
	PUSH P,TSINT+1
	PUSH P,G
	SKIPN 10TYIL	;IF NOT IN CROCK TYI MODE,
	TDZA G,G	;THEN SET INDEX TO ZERO
	MOVEI G,1	;IN TYI MODE, SET INDEX TO 1
	.SUSET INTON	;PROCESS CHARACTERS WHILE REMAINING INTERRUPTABLE
TYIBK4:	PUSHJ P,@TYWTDS(G)	;PROCESS A CHARACTER
	.SUSET INTOFF	;TURN OFF INTERRUPTS (PREVENT PDL BUILDUP)
	SOSL SNCHAR		;ANOTHER CHARACTER PROCESSED: THE LAST ONE?
	.DISMIS [TYIBK4]	;NO, DO IT AGAIN
	POP P,G		;YES, RETURN TO INTERRUPT ROUTINE
	POP P,TSINT+1
	POP P,TSINT
	JRST TYBKRT

TYWTDS:	TYIBK2	;INACTIVE
	TYIBK3	;ACTIVE (IN CROCK TYI MODE)

		;WAKEUP CHARACTER TYPED

WAKUPB:	CLEARF SDTSW	;LEAVING SUDTAP MODE SOON
	SKIPN INTRET	;IF GOING TO DISMISS TO ERROR ROUTINE,
	TMODF CN,WAKUPF	;OR IF NOT SLEEPING,
	JRST TYBKRT	;THEN THAT'S ALL (IF NOT SLEEPING, 10SLP WILL SEE WAKUPF SET)
	MOVEI A,10SLP2	;NOT DISMISSING TO ERROR ROUTINE, AND MAIN PROGRAM SLEEPING
	MOVEM A,INTRET	;CLOBBER RETURN TO DISMISS TO 10SLP2, CAUSING WAKE-UP
	JRST TYBKRT

SNCHAR:	-1		;1 LESS THAN NUMBER OF CHARACTERS TYIBK4 TO EAT UP BEFORE RETURNING TO INTERRUPT ROUTINE
]			;END SUDTAP MODE CONDITIONAL

INTLEV:	-1		;1 LESS THAN NUMBER OF INTERRUPT LEVEL PUSH-DOWNS
INTRET:	0		;0 => DISMISS NORMALLY, NON-ZERO => PLACE IN MAIN PROGRAM TO DISMISS TO
MPVDSM:	0		;NON-ZERO => PLACE TO DISMISS TO ON MPV INSTEAD OF DYING

CTLSBK:	.RESET TYOC,	;CONTROL S BREAK, RESET TYPEOUT
	SETF SILNT	;SILENCE TYPEOUT
	HRRZ A,TSINT+1	;GET PLACE THIS INTERRUPT CAME FROM (DON'T WORRY ABOUT INTLEV)
	CAIN A,TYOIOT	;IF IT WAS HUNG ON TYPEOUT,
	AOS TSINT+1	;THEN SKIP THIS CHARACTER
	MOVEI A,^S	;RESTORE A
	POPJ P,

IFN SUDTSW,[
	;ROUTINES TO GOBBLE DOWN .ITYI'ED CHARACTERS WITH .IOTS THEN RETURN TO INTERRUPT ROUTINE

		;ROUTINE NUMBER 1: REALLY ASLEEP, EAT UP CHARACTER BUT IGNORE IT (EMPTY SYSTEM BUFFER)

TYIBK2:	PUSHJ P,TYI	;GET CHAR
	CAIN A,^Y	;IF CONTROL Y,
	.IPDP USROC,	;THEN INTERRUPT OTHER PROCESSOR
	POPJ P,		;(ONLY WHEN NOT IN CROCK TYI MODE)

IFN CBLKSW,[	;VERSION OF TYIBK3 TO TAKE ADVANTAGE OF PAGING
TYIBK3:	PUSHJ P,TYI	;GET CHAR FOR REAL
	CAIE A,^S
	CAIN A,^L
	POPJ P,		;^S OR ^L, DON'T GIVE IT TO NTS PROCESSOR
	INSIRP PUSH P,[T TT C]	;SAVE SOME AC'S
	MOVE C,10TYIL
	MOVE T,R+1(C)	;GET CHARACTER COUNT
10TIBS:	CAIL T,		;RH IS BUFFER SIZE (# CHARS)
	JRST 10BFL	;BUFFER FULL
	AOS T,R(C)	;GET CHAR ADR TO DEPOSIT INTO
	CAIL T,@10TIBS
	SETZB T,R(C)	;RING THE BUFFER
	IDIVI T,5
	ADD T,10TYIL
	DPB A,TYB3TB(TT)	;GIVE HIM THE CHARACTER
	AOS R+1(C)	;INCREMENT CHARACTER COUNT
10UTYI:	INSIRP POP P,[C TT T]	;RESTORE AC'S
	POPJ P,

TYB3TB:	POINTS 7,R(T)
]]

IFN SUDTSW,[IFE CBLKSW,[
		;ROUTINE NUMBER 2: IN CROCK TYI MODE, GIVE CHARACTER TO PDP10
		;SEE 10TYIL FOR DESCRIPTION OF WHAT'S GOING ON

TYIBK3:	PUSHJ P,TYI	;GET THE CHARACTER (AND ECHO IT IF NECESSARY)
	CAIE A,^S	;IF CHARACTER IS CONTROL S,
	CAIN A,14	;OR IF CHARACTER IS FORM FEED,
	POPJ P,		;THEN DON'T PASS IT ON TO THE OTHER PROCESSOR
	INSIRP PUSH P,[T B C TT 40 UUOH]	;SAVE WORLD
	MOVE B,10TYIL	;GET LOCATION OF BUFFER DESCRIPTOR AREA
	GET C,2(B)	;GET THE SWITCH
	MOVEM C,10TYSW	;STORE IT AWAY
	TLZ C,777000	;TURN OFF INSTRUCTION PART
	TLO C,(TRN)	;TURN INTO NO-OP
	PUT C,2(B)	;PUT BACK (DON'T LET HIM MUNG  AREA)
	MOVE T,[-2,,10TIIC]	;SET UP AOBJN POINTER
	BGET T,(B)	;GET FIRST TWO WORDS OF DESCRIPTOR AREA
	AOS T,10TICC	;INCREMENT CHARACTER COUNT
	CAILE T,@10TIBS	;IF GREATER THAN BUFFER SIZE,
	JRST 10BFL	;THEN BUFFER FULL
		;NOW TO DEPOSIT THE CHARACTER
	AOS T,10TIIC	;INCREMENT CHARACTER ADDRESS AND GET IT IN T
10TIBS:	CAIL T,		;RH BUFFER SIZE (CHARACTERS)
	SETZB T,10TIIC	;OUT OF RANGE, SET TO BEGINNING OF BUFFER
	IDIVI T,5	;GET WORD NUMBER IN T, POSITION IN WORD IN TT
10TBLC:	GET B,(T)	;RH LOCATION OF TYI BUFFER IN PDP10
	DPB A,10TTBL(TT)	;DEPOSIT THE BYTE
	PUT B,@10TBLC-IFN CBLKSW,R	;PUT BACK THE WORD
10UTYI:	MOVE T,10TYIL	;GET TYI BUFFER DESCRIPTOR LOCATION
	MOVE A,[-3,,10TIIC]
	BPUT A,(T)	;UNLOCK BUFFER DESCRIPTOR AREA
	INSIRP POP P,[UUOH 40 TT C B T]	;RESTORE MOST OF WORLD
	POPJ P,

10TTBL:	POINTS 7,B	;TABLE OF BYTE POINTERS FOR DPB'ING INTO PDP10
]
10BFL:	TYPE [ASCIZ / BUFFER FULL.
/]
	SOS 10TICC	;DECREMENT CHARACTER COUNT BEFORE RESTORING BUFFER STATUS TO 10
	JRST 10UTYI	;UNLOCK VARIABLES AND RETURN

	CMD "P,SDTPRP,PREPARE TO PSEUDO-TAPE ON SLEEP

SDTPRP:	PUSHJ P,LOSSNO		;LOSS IF PDP10 NOT OPEN
	.SUSET [.RIOC+USROC,,A]	;GET IOC WORD FOR USROC
	JUMPGE A,[ERR [ASCIZ /  DON'T HAVE PDP10 AS INFERIOR.
/]]
	SETF SDTSW2
	JRST POPJ1

IFG SUDTSW,[	;OLD STYLE SUDTAP

6STAP

		;DO A .SLEEP T, , BUT WAKE UP IF A WAKE-UP CHARACTER TYPED, SKIP UNLESS AWAKEN

10SLP:	TMODF CE,WAKUPF	;COMPLEMENT STATUS OF FLAG, IF ALREADY SET THEN TIME TO WAKE UP
	JRST 10SLP2	;ALREADY SET, NOW CLEAR
	EXCH S,T
	SKIPL T
	.SLEEP S,	;FLAG NOW SET, IF WAKEUP CHARACTER TYPED THEN TSINT WILL DISMISS TO 10SLP2 WITH WAKUPF OFF
	CLEARF WAKUPF	;SURVIVED THIS SLEEP, CLEAR FLAG,
	JRST POPJ1	;RETURN STILL ASLEEP
]
		;WAKE UP (WAKUPF NOW OFF) (USUALLY DISMISSED TO FROM TSINT)

10SLP2:	PUSHJ P,TYI	;GET CHARACTER FOR REAL
	PUSHJ P,TTZGET	;GET TTY STATUS
	PUSHJ P,TTYSET	;SET TO COMMAND LEVEL STATUS
	MOVEI A,^X
	MOVSI T,600000
	TDNN T,TTZST1
	PUSHJ P,TYO	;"ECHO" CHAR
IFL SUDTSW,.SUSET [.SIMSK2,,[1_USROC]]
	POPJ P,
]

IFE SDTSW,[
	CMD "P,SDTPRP
	CMD "U,SDTPRP

SDTPRP:	ERR [ASCIZ /  NOT IMPLEMENTED THIS VERSION.
/]
]

IFL SUDTSW,[	;NEW (ABBREVIATED) STYLE SUDTAP MONITOR

10SSW=10HIGH-10
10CMD=10SSW+1
10FN1=10SSW+2
10FN2=10SSW+3

SSW=R+10SSW
SCMD=R+10CMD
SFN1=R+10FN1
SFN2=R+10FN2

SUDTAP:	PUSHJ P,LOSSNO	;LOSS IF NOT OPEN
	MOVEM P,10SVP'	;SAVE P IN CASE OF ERROR
	.SUSET [.SAMSK2,,[1_USROC]]	;DISABLE INTERRUPTS FROM OTHER PROCESSOR
STAPL:	MOVE P,10SVP	;LOOP POINT, RE-INITIALIZE P
	TMODF CE,WAKUPF
	JRST 10SLP2	;WAKE UP
	MOVNI A,1
	CAME A,SSW	;WAIT FOR THE SWITCH TO BECOME -1
	.HANG
	CLEARF WAKUPF
	MOVNM A,SSW
	HLRZ A,SCMD
	CAIL A,CMDMIN
	CAILE A,CMDMIN+NCMDS
	JRST ERCMD	;UNKNOWN COMMAND
	PUSHJ P,@SUDTBL-CMDMIN(A)	;PROCESS REQUEST
	JRST STAPL	;BACK FOR NEXT

CMDMIN==32	;LOWEST COMMAND NUMBER (LOWER ONES ONLY IN OLD VERSION)

SUDTBL:	STTYC	;SENSITIZE TTY TO LOCATION IN RH, OR DESENSITIZE TTY OF RH 0 (32)
	RTTYC	;READ LOCATION TTY SENSITIZED TO (0 => NONE) (33)
	TYPOC	;TYPE OUT CHARACTER STRING (ENDS WITH ^@ OR ^C) (34)
	RTYPIC	;GET TYPED IN CHARACTER STRING ALLOWING INCREMENTAL RUBOUT (35)
	JSRACC	;SET AC STORAGE AREA FOR JSRC, PUT OLD ONE AND R IN FN1
	JSRC	;JSR TO ADR ADDRESSED BY RH
NCMDS==.-SUDTBL	;NUMBER OF COMMANDS

SETSWJ:	SETZM SSW	;JRST SETSWJ FOR NORMAL RETURN
	.IPDP USROC,
	POPJ P,

		;ERROR HANDLING ROUTINES

ERCMD::	REPEAT 5,CONCAT 10ER,\.RPCNT+1,: JSP A,10ER

10ER:	MOVNI A,-<ERCMD+1>+2(A)
10ERP:	MOVEM A,SSW
	.IPDP USROC,
	JRST STAPL

10OER1:	TLO A,SIGN	;.STATUS WORD IN A FROM OPEN THAT LOST
	JRST 10ERP
]

IFN SUDTSW,[IFN CBLKSW,[	;ROUTINE TO JSR INTO NTS CORE

JSRACC:	MOVE A,SCMD
	MOVEI A,R(A)
	MOVEI T,10ER2
	MOVEM T,MPVDSM
	MOVES (A)
	MOVES 17(A)
	SETZM MPVDSM
	MOVE B,[(R)-R]
	ADDI B,@NTSA17
	MOVEM B,SFN1	;GIVE HIM R,,OLD NTSAC0
	HRRM A,NTSAC0	;SET NEW NTSAC0
	ADDI A,17
	HRRM A,NTSA17	;SET NEW NTS AC 17
	JRST SETSWJ

JSRC:	HRRZ A,NTSAC0
	JUMPE A,10ER2	;JUMP IF HE HASN'T SPECIFIED AN AC STORAGE AREA
	MOVE A,R+10CMD
	ADDI A,R
	HRRM A,JSRX	;STORE RH OF JSR
	JSR JSROUT	;SWAP VARIABLES FOR JSR OUT
	MOVE [TSJNT,,TSKNT]
	HLRM JSRSW
	HRRM JSRSW2
	MOVE @NTSAC0
	.SUSET [.SPICL,,SVNPIC]
JSRX:	JSR		;JSR INTO NTS CORE (MODIFIED)
	MOVEM TEMP'	;DON'T CHANGE TO @NTSAC0
	MOVE [-2,,JSRCOS]
	.SUSET
	MOVE [TSINT1,,TSINTX]
	HLRM JSRSW
	HRRM JSRSW2
	MOVE TEMP
	JSR JSRIN	;SWAP VARIABLES BACK TO TENLOD'S
	JRST SETSWJ

JSRCOS:	.RPICL,,SVNPIC
	.SPICL,,[0]

TSJNT:	JSR JSRIN
	JRST TSINT1

TSKNT:	JSR JSROUT
	JRST TSINTX

JSROUT:	0		;RETURNS WITH INTERRUPTS OFF
	INSIRP PUSH P,[41 42]
	MOVE A,[-SVTSTL,,SVTSTB]
	.SUSET A	;SAVE STUFF AND DISABLE INTERRUPTS
	SETF JSROTF	;SET JSR MODE FLAG
	MOVEM 17,TSAC17	;NOW TO SAVE THE TS AC'S
	MOVEI 17,TSAC0
	BLT 17,TSAC16
	JRST NTSIN	;NOW SWAP IN THE NTS CORE VARIABLES AND RETURN

SVTSTB:	.RSNAM,,SVTSNM'
	.RMASK,,SVTMSK'
	.RMSK2,,SVTMK2'
	.SPICL,,[0]
SVTSTL==.-SVTSTB

TSAC0:	BLOCK 16	;BULK OF TS AC STORAGE WHEN JSR'ING INTO NTS CORE
TSAC16:	0
TSAC17:	0
IFN .-TSAC0-20,PRINTB TSAC0 LENGTH WRONG

RSTSTB:	.SSNAM,,SVTSNM
	.SMASK,,SVTMSK
	.SMSK2,,SVTMK2
	.SPICL,,INTLEV
RSTSTL==.-RSTSTB

TSIN:	MOVSI 17,TSAC0	;HERE FROM JSRIN TO RESTORE TS VARIABLES
	BLT 17,17	;IN COME THE AC'S
	INSIRP POP P,[42 41]
	SKIPGE INTLEV
	CLEARF JSROTF
	MOVE A,[-RSTSTL,,RSTSTB]
	.SUSET A
	JRST @JSRIN

JSRIN:	0		;MUST BE CALLED WITH INTERRUPTS INHIBITED
NTSAC0:	MOVEM 0,	;MODIFIED, HAS RELOCATED ADR OF NTS SWAPOUT AC'S
	HRRZ 0,NTSAC0
NTSA17:	BLT 0,R+17	;MODIFIED, SWAP OUT THE AC'S
	MOVE A,[-SVNTTL,,SVNTTB]
	.SUSET A	;SAVE STUFF
	MOVEI D,SVNT40-1
	INSIRP PUSH D,[40 41 42]
	JRST TSIN	;NTS STUFF SWAPPED OUT, SWAP IN TS STUFF

SVNTTB:	.RSNAM,,SVNSNM
	.RMASK,,SVNMSK
	.RMSK2,,SVNMK2
SVNTTL==.-SVNTTB

SVNSNM:	0		;SYSTEM NAME WHEN OUT
SVNMSK:	0		;INTERRUPT MASK WHEN OUT
SVNMK2:	0		;SECOND WORD MASK
SVNT40:	0		;C(40) WHEN OUT
SVNT41:	JSR UUOH	;C(41) WHEN OUT
SVNT42:	JSR TSINT	;C(42) WHEN OUT
TTZST1:	0
TTZST2:	0
TTZSTS:	0
SVNPIC:	-1		;PICLR WHEN OUT

RSNTTB:	.SSNAM,,SVNSNM
	.SMASK,,SVNMSK
	.SMSK2,,SVNMK2
RSNTTL==.-RSNTTB

JSRRS:	MOVEI D,SVNSNM-1
	PUSH D,ISNAM'
	PUSH D,IMSK
	PUSH D,IMSK2
	PUSH D,[0]	;40
	PUSH D,[JSR UUOH]
	PUSH D,[JSR TSINT]
	INSIRP PUSH D,[TTMST1 TTMST2 TTYSTS]
	TLZ D,-1
	CAIE D,SVNPIC-1
	.VALUE		;INTERNAL ERROR: PUSHES WERE SUPPOSED TO LINE UP WITH SVNSNM TABLE
	SETOM SVNPIC
	HLLZS NTSAC0
	POPJ P,

NTSIN:	MOVEI D,40-1
	INSIRP PUSH D,[SVNT40 SVNT41 SVNT42]
	MOVE A,[-RSNTTL,,RSNTTB]
	.SUSET A
	HRLZ 17,NTSAC0
	BLT 17,17	;SWAP IN THE AC'S
	JRST @JSROUT
]]

IFN SUDTSW,[

JSRVRS==.IFNM2
	;CROCK TYI COMMANDS INITIATED BY PDP10

		;OPEN OR CLOSE TYI MODE, BUFFER DESCRIPTION LOCATION IN RH (FN1)
			;MODE AS MODIFIED IN LH(FN1)

STTYC:	MOVE A,SFN1
	PUSHJ P,STTYC1	;DO THE WORK
	JRST 10OER1	;DIDN'T SKIP, SOMETHING LOST, A SET PROPERLY FOR DOCUMENTATION
	JRST SETSWJ	;RETURN INDICATING SUCCESS


IPITTY:	MOVE A,10TYIL	;ROUTINE TO RE-ENTER MODE
	ADD A,10TYOL	;INITIALIZE AC
	PUSHJ P,STTYC1	;DO THE WORK
	.VALUE		;DIDN'T SKIP => SOMETHING WRONG (PROBABLY LOST TTY)
	POPJ P,		;SKIPPED => WIN (OF COURSE), RETURN

		;ACTUAL ROUTINE TO OPEN TTY

STTYC1:	JUMPL A,STYOCX	;JUMP IF NOT SETTING TYO MODE
	LDB T,[331100,,A]	;GET TYO MODE
	TRO T,1		;SET OUTPUT
	TRZ T,2		;FLUSH BLOCK MODE
	HRLM T,TYOPBK	;STORE FOR .OPEN ATTEMPT
	.OPEN TYOC,TYOPBK	;TRY TO OPEN IT
	JRST STYOC2	;LOST
STYOC3:	LSH T,9		;SHIFT OVER
	HRLZM T,10TYOL'	;STORE IN WORD DESCRIBING OUTPUT MODE (LOOKS TO SUDTAP LIKE LEFT 9 BITS OF 10TYIL)
STYOCX:	TLZ A,777000
	TLNE A,400	;SKIP IF SETTING TYI MODE
	JRST POPJ1	;NOT SETTING TYI MODE
	PUSH P,TT	;SAVE TT (AREN'T MODIFICATIONS FUN?)
	MOVE TT,A	;GET COPY OF WORD FOR MAYBE PUTTING INTO 10TYIL
	HLLM A,TYOPBK	;NOW SAVE CALCULATED MODE FOR OPEN
	.OPEN TYIC,TYOPBK	;TRY IT
	JRST STTYC3	;LOST
STTYC4:	GET A,3(A)	;WON, GET BUFFER DESCRIPTOR
	HLRM A,10TIBS	;SAVE NUMBER OF CHARACTERS BUFFER SIZE
	MOVEM TT,10TYIL	;SAVE AS TYI OPEN MODE
IFE CBLKSW,[ADDI TT,R
	HRRM TT,10TBLC
]	POP P,TT	;RESTORE TT
	PUSHJ P,TTZGET
	JRST POPJ1	;RETURN SKIPPING (SUCCESS)

		;.OPEN FOR OUTPUT LOST

STYOC2:	SETZM 10TYOL	;CLEAR WORD FOR DOCUMENTATION
	.STATUS TYOC,A
	PUSH P,A
	PUSHJ P,TYINIT
	PUSHJ P,STYOCX	;PROCESS TYI OPEN
	JFCL
	POP P,A
	POPJ P,

		;TYI .OPEN LOST, OR CLOSING TYI MODE

STTYC2:	AOS -1(P)	;CLOSING TYI MODE
STTYC3:	SETZM 10TYIL	;OPEN LOST, CLEAR 10TYIL
	.STATUS TYIC,A
	PUSH P,A
	PUSHJ P,TYINIT
	PUSHJ P,TTMSET
	POP P,A
	POP P,TT	;RESTORE TT (DIDN'T REALLY NEED IT, BUT...)
	POPJ P,		;RETURN, IF ERROR THEN NOT SKIPPING

		;RETURN (IN FN1) THE BUFFER LOCATION FOR TYI (ALSO MODE BITS IN LEFT HALF)

RTTYC:	MOVE T,10TYIL	;GET THE WORD
	ADD T,10TYOL	;ADD IN OUTPUT WORD (LEFT 9 BITS BELONG TO OUTPUT WORD, WORDS SEPARATED ONLY FOR TENLOD'S CONVENIENCE)
	PUT T,10FN1	;GIVE IT TO PDP10 PROGRAM
	JRST SETSWJ

TYOPBK:	(SIXBIT /TTY/)
	SIXBIT /TENLOD/
	SIXBIT /TTY/

;IF THIS THING EVER GETS DEBUGGED, A PROGRAM ON THE PDP10 WILL BE ABLE TO TAKE
;TYPEIN FROM THE PDP6. RESPONSE SHOULD BE REASONABLY FAST. THIS COMMUNICATION
;IS NOT HANDLED LIKE NORMAL SUDTAP COMMANDS, HOWEVER: IN OPERATION
;THE NORMAL COMMUNICATIONS AREA IS NOT USED. THE "SPECIAL COMMUNICATIONS AREA"
;IS NOT FIXED (DUE TO POSSIBILITY OF PROGRAM AND DDT BOTH WANTING TO DO TYI).
;IT IS SELECTED BY THE STTYC (SENSITIZE OR OPEN TTY), AND IT IS A FOUR WORD BLOCK IN THE 10.
;THE STTYC SPECIFIES THE LOCATION OF THE FIRST WORD IN THE BLOCK.

;THE FOURTH WORD IN THE BLOCK SHOULD CONTAIN A CONSTANT: THE LEFT HALF
	;SHOULD BE THE NUMBER OF CHARACTERS THE BUFFER ACCOMODATES; THE RIGHT
	;HALF SHOULD BE THE LOCATION OF THE BUFFER ITSELF.

	;THE BUFFER ITSELF IS A RING BUFFER. NOTE THAT IT IS ENTIRELY FILLED WITH NO WASTE.

;THE FIRST WORD IN THE BLOCK HAS THE CHARACTER ADDRESS OF THE LAST CHARACTER
	;DEPOSITED BY THE 6 INTO THE 10.

;THE SECOND WORD IN THE BLOCK HAS THE NUMBER OF CHARACTERS CURRENTLY IN THE BUFFER.

;THE THIRD WORD IN THE BLOCK IS AN INSTRUCTION. THE PROGRAM ON THE 10 SHOULD HAVE
	;THIS WORD INITIALIZED AS A SOSA OF THE CHARACTER COUNT, AND IT SHOULD
	;EXECUTE IT WHENEVER IT WANTS TO DECREMENT THE CHARACTER COUNT.
	;WHEN THE PDP6 PROGRAM IS HACKING THE AREA, IT MUNGS THIS LOCATION TO A 
	;(NEGATIVE) NO-OP WHICH, UNLIKE THE SOSA, WILL NOT SKIP.

10TYIL:	0		;0 => NOT IN TYI MODE, NON-ZERO => LOCATION OF BUFFER DESCRIPTOR AREA
			;BITS 3.1, 3.2 ALWAYS ZERO
			;BITS 3.3-3.8 OPEN MODE
			;BITS 3.9-4.9 ZERO

10TIIC:	0		;CHARACTER ADDRESS OF LAST TYI CHARACTER DEPOSITED BY PDP6
10TICC:	0		;CHARACTER COUNT FOR TYI HACK
10TYSW:	0		;SWITCH FOR TYI HACK (SEE COMMENTS ABOVE)

		;TYPE OUT THE CHARACTER STRING IN THE PDP10 STARTING AT THE SPECIFIED LOCATION
		;CHARACTER STRING ENDS WITH CONTROL C OR CONTROL @

IFE CBLKSW,[

TYPOC:	HRRZ D,SCMD	;GET LOCATION OF STRING
	CAIL D,10SSW	;IF ABOVE SUDTAP COMMUNICATIONS AREA (NEAR TOP OF CORE),
	JRST 10ER3	;THEN COMPLAIN (CALL IT A MEMORY PROTECTION VIOLATION)
	ACCESS USRIC,(D)	;SET UP THE .ACCESS POINTER
TYPOC1:	MOVE T,[-TOBS,,UTIBUF]	;SEP UP POINTER FOR QUANTUM TRANSFER
	ADDI D,TOBS	;LOOK AT WHERE IT IS
	CAIL D,10SSW
	JRST TYPOC2	;ABOUT TO RUN INTO COMMUNICATIONS AREA, FORCE STOPPAGE (RETURNS TO TYPOC3)
TYPOC3:	.IOT USRIC,T	;GET QUANTUM FROM PDP10 CORE
	SETZM (T)	;MAKE SURE IT STOPS WHEN DONE WITH QUANTUM
	SKIPA B,[440700,,UTIBUF]	;SET UP TYPEOUT BYTE POINTER
TYPOC4:	PUSHJ P,TYO	;TYPE OUT CHARACTER (LOOP POINT FOR TYPEOUT)
	TESTF E,SILNT	;IF TYPEOUT SILENCED,
	JRST 10ER2	;THEN QUIT NOW; ALSO LET PDP10 PROGRAM KNOW TYPEOUT SILENCED
	ILDB A,B	;GET NEXT CHARACTER
	CAIE A,3	;IF CONTROL C,
	JUMPN A,TYPOC4	;OR IF CONTROL @ THEN DROP THROUGH, OTHERWISE LOOP FOR NEXT CHARACTER
	CAMN B,[350700,,UTIBUF+TOBS]	;IF AT END OF QUANTUM,
	JRST TYPOC1	;THEN MORE TO COME
	JRST SETSWJ	;NOT AT END OF QUANTUM, THEREFORE DONE

TYPOC2:	MOVSI D,-<10SSW-1>(D)	;MEMORY PROTECTION VIOLATION HANDLING ROUTINE
	ADD T,D
	JRST TYPOC3
]
IFN CBLKSW,[

TYPOC:	HRRZ B,SCMD
	ADDI B,R
	PUSHJ P,ATYPE
	LDB A,B		;GET LAST CHAR TYPED
	CAIE A,3
	JUMPN A,10ER2	;TELL PROGRAM IT GOT SILENCED
	JRST SETSWJ
]

		;GET A TYPED IN CHARACTER STRING ALLOWING RUBOUT

RTYPIC:	SKIPE A,SFN1
	HRRM A,RTYIDL	;DELIMITER
	CLEARF SDTSW
	PUSHJ P,TTZGET
	PUSHJ P,TTYSET
	PUSHJ P,RTYI0	;READ IN THE STRING
RTYPC1:	MOVEI D,SETSWJ
		;FOLLOWING 2 INSTRUCTIONS DO 2'S COMPLEMENT BY SUBTRACTING 1
		;AND TAKING 1'S COMPLEMENT
	HRLOI T,-RTYIBF(B)	;NUMBER OF WORDS TO TRANSFER+1
	EQVI T,RTYIBF	;FINISH BLOCK .IOT POINTER
	HRRZ A,SCMD
	BPUT T,(A)
RTYPC2:	MOVEI A,15	;RESTORE OLD DELIMITER
	HRRM A,RTYIDL
	PUSHJ P,TTZSET	;RE-INITIALIZE TTY
	SETF SDTSW
	JRST (D)

		;RUBBED OUT TO BEFORE BEGINNING OF STRING

RTYIR2:	POP P,B		;RESTORE B
	HRRZ A,(P)	;GET RETURN LOCATION
	CAIE A,RTYPC1
	ERR HUH		;BACK TO COMMAND LEVEL
	POP P,A
	MOVEI D,10ER2
	JRST RTYPC2
]		;END IFN SUDTSW,[] CONDITIONAL

	;PDP10 INTERNAL ROUTINES

TGPREP 37200+MOBY

TAG 10ST,
GOBEG:	SETZM MACCR
	CONO 635550+40000*OLDSW	;IO RESET, NXMEM OFF, AND FRIENDS
	CONO PI,11577+700000*OLDSW	;PI OFF, ETC.
	MOVE MACAC,10R41
	MOVEM MACAC,41	;GIVE PROGRAM ITS DESIRED C(41)
	SETOM DUNSW	;DOCUMENT RUNNAGE OF THIS ROUTINE
IFN SUDTSW,CONO ICL,20	;TELL TENLOD THAT NTS PROC GOT STARTED OK
10DSP:	JSP MACQ,	;ACTUAL DISPATCH TO RELEVANT ROUTINE

TAG FGO,		;START HERE TO START UP PROGRAM VIA DDT
	MOVEI MACAC,10IRT	;ADDRESS OF ROUTINE...
	MOVEM MACAC,@DDT	;FOR DDT TO CALL FOR INPUT
TAG DDTGO,			;START HERE TO START UP DDT
	MOVE MACAC,10PGO	;GIVE STARTING INSTRUCTION TO DDT
	JRST DDT+1	;START UP DDT

TAG 10IRT,		;ROUTINE CALLED BY DDT FOR INPUT
	ILDB 10T,10BP	;GET CHARACTER IN "T"
	CAIN 10T,"X	;IF CHARACTER LAST IN STRING,
	SETZM @DDT	;THEN PREVENT THIS ROUTINE FROM BEING CALLED AGAIN
	POPJ 10P,

TAG 10STRI,		;TEXT OF COMMAND TO DDT FOR STARTING PROGRAM VIA DDT
DDSTRI:	ASCIZ /254000000100X/	;PROGRAM STARTED BY SAYING <INST> ALT X

TAG 10R41,
10SV41:	0		;SAVES LOCATION 41 FOR PROGRAM

TAG DUNSW,
	0		;-1 => THIS ROUTINE SUCCESSFULLY TRANSFERED TO

TAG 10PGO,
GOINST:	0		;ACTUAL INSTRUCTION USED TO START UP PROGRAM

TAG 10BP,
	440700,,10STRI	;DDT COMMAND POINTER

GOEND:

PRINTA START ROUTINE ENDS AT ,\GOEND, .

PDPNAM:	(SIXBIT /USR/)
UNAME:	0
JNAME:	SIXBIT /PDP6/

DDTFIL:	6,,(SIXBIT /SYS/)
	SIXBIT /PDP10/
DDTFN2:	SIXBIT /DDT/	;CLOBBERED BY 1O AND 0O
	0		;SYSTEM NAME UNIMPORTANT

41SW:	0		;-1=> 10SV41 HAS C(41) VIA LOAD

		;FOLLOWING TWO LOCATIONS MUST REMAIN CONSECUTIVE

DDT1C:	-40,,DDT-2	;PUT INTO DDT-1 DURING SYMLOD
SVSYMP:	0		;SAVES DDT-2 FOR KILLING SYMS

NBLKS:	ICOR		;# BLOCKS CORE (NOT INCLUDING NTS MACHINE PAGED IN)

SYMP:	SYMS		;AOBJN POINTER TO SYMBOL AREA

HUH:	ASCIZ /?   /	;FREQUENT ERROR "MESSAGE"

PDL:	BLOCK LPDL+16	;EXTRA FOR "WORST CASE" PDL OVERFLOW DETECTION AND PROCESSING

UTIBUF:	BLOCK UTIBFL	;LOADER BUFFER

PAT:
PATCH:	BLOCK 100	;PATCH AREA
PATCHE=.-1

		;COMMAND DISPATCH TABLE

DTBP:	POINTS 12.,DTB(T)

DTB:	.BYTE 12.
	REPEAT 100,[CONCAT CHR,\.RPCNT
]
	.WALGN
	.BYTE

		;BLURB TABLE

BTB:	.BYTE 12.
	REPEAT 100,[CONCAT CHB,\.RPCNT
]
	-1		;FOR END OF TABLE DETECTION
	.WALGN
	.BYTE

CONST1:	CONSTANTS	;CONSTANTS AREA
	VARIABLES

ICOR==<.+1777>/2000	;INITIAL CORE ALLOCATION

PRINTA HIGHEST USED = ,\.-1

SYMS:	END BEG		;BEGINNING OF SYMBOL AREA
