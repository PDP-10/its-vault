
TITLE SNOOP
;SEARCHES EVERYBODY'S DISK DIRECTORY FOR SPECIFIED FILE
;REPLACING GROSSLY SLOW TECO MACRO
IF1,[SWRQ==1	;GET TYPEIN
.INSRT JSF;DSK:STNDRD MACROS
]

	;AC DEFINITIONS

FF=0	;FLAGS
A=1	;A,B,C,D MAY BE ASSUMED CONSECUTIVE
B=2	;A,B TEMP, MAY BE CLOBBERED WITHOUT COMMENT BY MOST ROUTINES
C=3
D=4
E=5
F=6
G=7
T=10	;T,TT TEMP,CONSECUTIVE, MAY BE CLOBBERED WITHOUT COMMENT BY MOST ROUTINES
TT=11
R=15
Q=16
P=17	;PDL POINTER

	;IO CHANNELS

TYIC==1		;TYPEIN
TYOC==2		;TYPEOUT
UTYIC==3	;BINARY FILE IN
UTYOC==4	;BINARY FILE OUT
FDRC==5		;FILE DIRECTORY AND ERR DEVICE IN
PRTOC==6	;ASCII (PRINTING) FILE OUT
UTYJC==7	;OTHER BINARY FILE IN
REDIC==10	;ASCII FILE IN

	;FF FLAGS

CRF==RHF FF,1_17.	;CHAR READ BY RCHA WAS CR, TERMINATES COMMAND LINE
ALTF==RHF FF,1_16.	;CHAR READ BY RCHA WAS ALTMODE, TERMINATES ARG STRING OR COMMAND
UNRCHA==RHF FF,1_15.	;RCHA TO RE-INPUT LAST CHAR

TMPF1==RHF FF,40000	;TEMPORARY
TMPF2==RHF FF,20000	; "
TMPF3==RHF FF,10000	; "

OPNFIF==RHF FF,4000	;A FILE IS OPEN ON UTYIC
OPNFPF==RHF FF,2000	;OUTPUT FILE OPEN ON PRTOC
OPNFOF==RHF FF,1000	;FILE IS OPEN ON UTYOC

GETTY==RHF FF,400	;TTY IS DISPLAY CONSOLE
OPNFJF==RHF FF,200	;FILE IS OPEN ON UTYJC
OPNFRF==RHF FF,100	;FILE IS OPEN ON REDIC

;IFNDEF PRTSW,	PRTSW==1	;NON-ZERO TO INCLUDE PRINT ROUTINES
;IFNDEF JCPSW,	JCPSW==0	;NON-ZERO TO INCLUDE JCPJ
;IFNDEF MTSTSW,	MTSTSW==0	;NON-ZERO TO INCLUDE MAGTAPE ROUTINES TESTING ROUTINES
;IFNDEF JBVSW,	JBVSW==0	;NON-ZERO TO INCLUDE JBV (JOB VERIFIER)
;IFNDEF PGCTSW,	PGCTSW==0	;NON-ZERO TO INCLUDE PAGE COUNT COMMAND
;IFNDEF REDSW,	REDSW==JCPSW	;NON-ZERO TO INCLUDE ASCII INPUT ROUTINES
;IFNDEF ICOR,	ICOR==5		;EXPECTED INITIAL CORE ALLOCATION
;IFN JCPSW,IFNDEF REDBFL,REDBFL==200	;LENGTH OF REDIC BUFFER

DEFINE INITM A	;INITIALIZATION MACRO, ACCUMULATES INITIALIZATION CODING
	A
TERMIN

	;INIT [CODING]	;ADD CODING TO STUFF EXECUTED WHEN PROGRAM STARTED UP

DEFINE INIT CODING
INITM [DEFINE INITM %%A
%%A]CODING
TERMIN
TERMIN

HALT==.VALUE

	;UUO NAME OR UUO NAME1 NAME2 ...  OR UUO [NAME1 NAME2 ...]
	;DEFINE NAMES AS UUO'S
	;DISPATCH WILL BE TO ROUTINE NAMED A!NAME

TMPLOC 41,JSR UUOH	;UUO HANDLER

DEFINE UUOLST A,B	;ACCUMULATES NAMES
A[B]
TERMIN

DEFINE UUO NAMES	;THE ONE TO USE
UUOLST [DEFINE UUOLST %%A,%%B
%%A][NAMES
%%B]TERMIN
TERMIN

	;MAXDEF FOO==EXPR	;IF FOO NOT DEFINED, SET FOO==EXPR
	;IF FOO ALREADY DEFINED, SET IT TO THE MAXIMUM OF ITS CURRENT VALUE
	;AND EXPR

DEFINE MAXDEF ASSGT/GENSYM
  IRPS %NAME,,[ASSGT]
    IFDEF %NAME,[GENSYM==%NAME
    ASSGT
    IFG GENSYM-%NAME,%NAME==GENSYM
    EXPUNG GENSYM
    ]
    IFNDEF %NAME,ASSGT
  .ISTOP
  TERMIN
TERMIN

DEFINE SWDFCK ASSGT
  IRPS %NAME,,[ASSGT]
    IFNDEF %NAME,ASSGT
    FOO==%NAME
  .ISTOP
  TERMIN
  IFN FOO,TERMIN

	;CMD NAME,DISPATCHADR,VERBOSEADR,BLURBN
	;DEFINE COMMAND WITH NAME "NAME", ADR OF ROUTINE = "DISPATCHADR",
	  ;ONE LINE BLURB "BLURB", AND "VERBOSEADR" OPTIONAL ADDRESS
	  ;OF VERBOSE BLURB

DEFINE CMDNMM A	;ACCUMULATES NAMES OF COMMANDS, IN SIXBIT
A
TERMIN

DEFINE CMDSPM A	;ACCUMULATES DISPATCH ADRS
A
TERMIN

DEFINE CMBLBM A	;ACCUMULATES ADRS OF COMMAND BLURBS
A
TERMIN

DEFINE CMD NAME,DSP,VERBOS,BLURB,THROW/FOO	;THE REAL MCCOY
FOO==SIXBIT NAME

CMDNMM [DEFINE CMDNMM %%A
%%A]FOO
EXPUNGE FOO
TERMIN

CMDSPM [DEFINE CMDSPM %%A
%%A]<DSP>
TERMIN

CMBLBM [DEFINE CMBLBM %%A
%%A]<VERBOS>,,[ASCIZ BLURB]
TERMIN

TERMIN

	;VBLK AND PBLK FOR POSSIBLE FUTURE PURIFICATION

CKPUR==0	;MODE SWITCH FOR SPOTTING VBLKS AND PBLKS OUT OF SYNC

DEFINE VBLK	;BEGIN VARIABLE (IMPURE) AREA
IFN CKPUR,PRINTA LOSSAGE AT VBLK = ,\.,
CKPUR==1
TERMIN

DEFINE PBLK	;BEGIN PROGRAM (PURE) AREA (ACTUALLY END VARIABLE AREA)
IFE CKPUR,PRINTA LOSSAGE AT PBLK = ,\.,
CKPUR==0
TERMIN

		;SORT THE SYMBOL TABLE
		;A POINTS TO FIRST ENTRY
		;B POINTS TO LAST ENTRY + 1
		;C HAS ONE BIT SET, THAT BIT MOST SIGNIFICANT BIT TO SORT ON
		;"SORT" IS FIRST UP TO 5 CHARS OF EACH TAG
		;WPS IS # WORDS PER ENTRY
		;SORTOF IS INDEX INTO EACH ENTRY OF KEYWORD
		;POPJS WHEN DONE

DEFINE SORTM SORT,WPS,SORTOF
SORT!1:	HRLM B,(P)	;SAVE UPPER BOUND
	CAIL A,-<WPS>(B)
	JRST SORT!7	;ONE OR ZERO ENTRIES
	PUSH P,A	;SAVE LOWER BOUND
SORT!3:	TDNN C,<SORTOF>(A)	;BIT SET IN LOWER ENTRY?
	JRST SORT!4	;NO, INCREMENT TO NEXT AND MAYBE TRY AGAIN
	SUBI B,<WPS>	;YES, NOW BACK UP UPPER POINT	
	TDNE C,<SORTOF>(B)	;BIT CLEAR IN UPPER ENTRY?
	JRST SORT!5	;NO, CHECK FOR END, DECREMENT B, AND TRY AGAIN
REPEAT <WPS>,[		;BIT SET IN LOWER ENTRY AND CLEAR IN UPPER => EXCHANGE ENTRIES
	MOVE D,.RPCNT(A)
	EXCH D,.RPCNT(B)
	MOVEM D,.RPCNT(A)
]
SORT!4:	ADDI A,<WPS>	;INCREMENT LOWER BOUND POINTER TO NEXT ENTRY
SORT!5:	CAME A,B	;ANY MORE ENTRIES LEFT?
	JRST SORT!3	;YES, GO PROCESS THEM
		;A AND B NOW BOTH POINT TO FIRST ENTRY WITH BIT SET
	ROT C,-1	;ROTATE BIT INDICATOR TO NEXT (LESS SIGNIFICANT) BIT
	POP P,A		;RESTORE LOWER BOUND OF ENTIRE SORT
	JUMPL C,SORT!6	;JUMP IF NO MORE KEY TO SORT ON
	PUSHJ P,SORT!1	;SORT BOTTOM PART OF TABLE
	HLRZ B,(P)	;RESTORE UPPER BOUND (SORT CLOBBERED A TO MIDDLE)
	PUSHJ P,SORT!1	;SORT TOP PART OF TABLE
SORT!6:	ROT C,1		;BACK UP KEY AGAIN SO AS TOO "NOT CLOBBER C"
SORT!7:	HLRZ A,(P)	;MAKE A POINT ABOVE TABLE ENTRIES SORTED
	POPJ P,
TERMIN

;;SNOOP , SEARCH FOR SPECIFIED FILE(S) IN EVERYBODIES DIRECTORY

CMD SNOOP,SNOOP,,MULTIFILE  LIST ALL USERS WITH MULTIFILE IN DIRECTORIES.

SNOOP:	PUSHJ P,MFCOMP	;COMPILE MULTIFILE
	PUSHJ P,QRMFD	;READ MFD
	HALT		;?????
	SETZM SNULPS	;SET TO BEGINNING OF LINE (WILL PRECEDE FIRST USER WITH CR)
SNUP2:	PUSHJ P,QRUFD	;READ NEXT USER FILE DIRECTORY
	JRST SNUP4	;NO MORE USERS
SNUP3:	PUSHJ P,QRFILE	;FIND NEXT FILE IN THIS DIRECTORY
	JRST SNUP2	;NO MORE, TRY NEXT USER
	MOVE A,QFILE+UNRNDM	;GET FLAGS WORD
	TLNE A,UNIGFL	;IGNORE?
	JRST SNUP3	;IGNORE THIS FILE
	LDB A,[UNPKN QFILE+UNRNDM]	;GET PACK NUMBER
	MOVE B,QFILE+UNFN1	;GET FN1
	MOVE C,QFILE+UNFN2	;FN2
	MOVE D,USER	;SYSTEM NAME
	PUSHJ P,MFCHK	;COMPARE WITH MULTIFILE
	JRST SNUP3	;DOESN'T MATCH
	SOSG SNULPS'	;DECREMENT COUNT OF NAMES TYPED THIS LINE
	JRST SNUP3B	;WANT NEW LINE
	PUSHJ P,TAB	;OLD LINE, PRINT NEW USER ON SAME LINE
SNUP3C:	MOVE B,USER	;GET SYSTEM NAME THIS USER
	PUSHJ P,SIXTYO	;TYPE OUT
	JRST SNUP2	;BACK FOR NEXT USER

SNUP3B:	PUSHJ P,CRLF
	MOVEI D,5	;SIX USERS PER LINE
	MOVEM D,SNULPS	;INITIALIZE ENTRY COUNT THIS LINE
	JRST SNUP3C	;TYPE OUT NEW USER

SNUP4:	SOSL SNULPS
	JRST CRLF	;BEGIN NEW LINE
	POPJ P,		;UNLESS DIDN'T PRINT ANY USERS ON CURRENT ONE

INSERT DSKRED > JSF;DSK:
DKRDVR==.IFNM2	;FNAM2 OF DSKRED ROUTINES FILE

;;MTFIND , FIND ALL MAGTAPE FILES MATCHING TYPED IN SPEC

CMD MTFIND,MTFIND,,MULTIFILE$OUTFIL  PRINT ALL MAGTAPE FILES MATCHING MULTIFILE.

PRTSW==1	;INCLUDE PRINT ROUTINES

MTFIND:	PUSHJ P,MFCOMP	;COMPILE MULTIFILE
	PUSHJ P,GTPTB	;GET TAPE TABLE
	PUSHJ P,PRTOPN	;READ FILE DESCRIPTION AND OPEN OUTPUT FILE
	TYPCR TWTAW	;"THIS IS GOING TO TAKE A WHILE."
	MOVEI A,MTFIH
	MOVEM A,PGHDRP'	;STORE PAGE HEADER ADR
	PRT MTFIH	;PRINT HEADER ON FIRST PAGE
MTFI2:	SKIPE LINEPS
	PUSHJ P,TPDSPT	;DOCUMENT TAPE JUST COMPLETED
	PUSHJ P,GNXTP	;NEXT TAPE
	JRST PRTCLS	;THAT'S ALL
	MOVE A,TPHD+2	;GET DATE TAPE CREATED (SIXBIT /YYMMDD/)
	PUSHJ P,QDTST	;SET UP DISK DATE VARIABLES
MTFI2B:	PUSHJ P,GNXTF	;NEXT FILE
	JRST MTFI2	;EOT
	MOVE A,FLHD+4	;PACK NUMBER
	MOVE B,FLHD+2	;FNAM1
	MOVE C,FLHD+3	;FNAM2
	MOVE D,FLHD+1	;SYSTEM NAME
	PUSHJ P,MFCHK	;EXECUTE COMPILED STUFF
	JRST MTFI2B	;NO GO
	PUSHJ P,FLDSPT	;PRINT FILE INFO
	JRST MTFI2B	;BACK FOR NEXT FILE

GWRDNJ:	HRROI T,A
UTYJNE:	.IOT UTYJC,T
	POPJ P,

TWTAW:	ASCIZ /THIS IS GOING TO TAKE A WHILE./

MTFIH:	ASCIZ \
USER	 FILENAMES	DISK-DATE/TIME	TAPE	FILE

\							;PAGE HEADER FOR MTFIND

INSERT MF > JSF;DSK:
MFVRS==.IFNM2

		;ROUTINES TO WORK WITH STUFF STORED ON DISK ABOUT TAPES

		;SET UP SORTED TABLE OF TAPE NUMBERS

GTPTB:	MOVEI D,MFD-1	;USE MFD FOR TABLE, THERE SHOULD BE ENOUGH ROOM
	SETZM MTFFLP	;TEMPORARILY CONTAINS MAXIMUM TAPE NUMBER FOUND SO FAR
	SETZB A,MTFFLE	;TEMPORARILY DIRECTORY NUMBER
GTPTB1:	MOVE A,TPDRNM(A)	;GET SYSTEM NAME
	MOVEM A,USER
	PUSHJ P,QRUDNA	;READ DIRECTORY
	HALT
GTPTB2:	PUSHJ P,QRFILE	;NEXT FILE
	JRST GTPTB3	;DIDN'T SKIP, NO MORE THIS DIRECTORY
	MOVE A,QFILE+UNRNDM
	MOVE B,QFILE+UNFN1
	TLNN A,UNIGFL	;SKIP IF THIS FILE NOT REALLY THERE
	CAME B,[SIXBIT /TAPE/]
	JRST GTPTB2	;DON'T USE IT
	MOVE B,QFILE+UNFN2
	PUSHJ P,6BNMCV	;CONVERT FNAM2 TO NUMBER IN A
	JRST GTPTB2	;DIDN'T SKIP, SECOND FILE NAME NOT A NUMBER
	MOVE T,A
	IDIVI T,NTPDIR
	CAME TT,MTFFLE
	JRST GTPTB2	;DOESN'T BELONG IN THIS DIRECTORY
	PUSH D,A	;BY GOLLY, IT'S OK!
	CAMLE A,MTFFLP
	MOVEM A,MTFFLP	;NEW BIGGEST NUMBER
	JRST GTPTB2

GTPTB3:	AOS A,MTFFLE	;INCREMENT TO NEXT DIRECTORY
	CAIL A,NTPDIR
	JRST GTPTB1	;BACK FOR NEXT DIRECTORY
	MOVE C,MTFFLP	;BIGGEST TAPE NUMBER
	MOVEI B,1(D)
	MOVEM B,MTFFLE'	;STORE POINTER TO FIRST WORD AFTER TABLE
	MOVEI A,MFD
	MOVEM A,MTFFLP'	;INITIALIZE POINTER INTO TABLE
	JFFO C,.+2
	POPJ P,		;TABLE OF ZERO LENGTH, OR ALL NUMBERS THE SAME
	MOVSI C,SIGN
	MOVNS D
	LSH C,(D)
	SORTM GTPST,1,0	;SORT TABLE AND RETURN

		;GET INFO ON NEXT TAPE OR DON'T SKIP

GNXTP:	MOVE A,@MTFFLP	;GET NEXT TAPE NUMBER
	AOS B,MTFFLP	;INCREMENT TO THE ONE AFTER THIS
	CAMLE B,MTFFLE
	POPJ P,		;THAT'S ALL, NO MORE
	PUSHJ P,GQXTP	;GET INFO ON TAPE
	JRST GNXTP	;DIDN'T SKIP, TRY AGAIN
	JRST POPJ1	;SKIP-RETURN (SUCCESS)

		;GET INFO ON NEXT FILE ON TAPE OR DON'T SKIP

GNXTF:	MOVE T,FLHD	;RETRIEVE OLD FILE HEADER HEADER
	HRRI T,FLHD+1
	PUSHJ P,UTYINE	;READ REST OF HEADER
	JUMPL T,RDCLS	;EOF, THAT'S ALL THIS TAPE
	AOS MTFLCT'	;INCREMENT FILE COUNT IN TAPE
	JRST POPJ1

GQXTP:	MOVE T,A	;GET TAPE NUMBER
	IDIVI T,NTPDIR
	MOVE C,TPDRNM(TT)	;GET DIRECTORY NAME FOR THIS TAPE
	MOVEM C,TDSNM	;SET SYSTEM NAME
	PUSHJ P,DPSIX	;CONVERT NUMBER TO SIXBIT
	MOVEM C,TDFN2	;STORE TAPE NAME FOR .OPEN
GQXTP1:	PUSHJ P,RDCLS	;ENTRY FOR STUFF ALREADY SET UP
	.SUSET [.SSNAM,,TDSNM]	;SET SYSTEM NAME
	.OPEN UTYIC,TDNAM	;TRY OPENING TAPE FILE
	POPJ P,		;LOSE, DON'T SKIP-RETURN
	SETF OPNFIF
	PUSHJ P,LSWSET
	 PUSHJ P,RDCLS
	SETZM MTFLCT	;CLEAR OUT FILE COUNT
	PUSHJ P,GWRDNE	;GET HEADER FROM TAPE FILE
	JUMPL T,CPOPJ
	TRNE A,-1
	ERR [ASCIZ /BAD TAPE HEADER RH/]	;NON-ZERO RH
	CAMG A,[-4,,]
	CAMGE A,[-LFLHDB,,]
	ERR [ASCIZ /TAPE HEADER COUNT OUT OF RANGE/]
	MOVEM A,TPHD	;STORE VALIDATED TAPE HEADER
	MOVE T,A
	ADD T,[1,,TPHD+1]
	PUSHJ P,UTYI	;GET REST OF HEADER BLOCK
	PUSHJ P,GWRDNE	;GET HEADER WORD OF FILE HEADER
	JUMPL T,CPOPJ	;JUMP IF NOT THERE, END OF TAPE FILE
	TRNE A,-1
	ERR [ASCIZ /BAD FILE HEADER RH/]	;NON-ZERO
	CAMG A,[-4,,]
	CAMGE A,[-LFLHDB,,]
	ERR [ASCIZ /FILE HEADER COUNT OUT OF RANGE/]
	MOVEM A,FLHD	;STORE HEADER HEADER
	JRST POPJ1	;ALL OK, SKIP-RETURN

	;DATA AREA FOR MTFIND
VBLK
	;TAPE HEADER (ALSO FIRST BLOCK OF TAPE <N> ON .TAPE. DIRECTORY)

TPHD:	0	;0 - # WORDS TOTAL IN HEADER,, (RH MUST BE ZERO)
	0	;1 TAPE #,,REEL #
	0	;2 CREATION DATE (SIXBIT /YYMMDD/)
	0	;3 TYPE OF DATA LAST WRITTEN
		;  0 RANDOM, >0 FULL DUMP, <0 INCREMENTAL DUMP
LOC TPHD+100
LTPHDB==.-TPHD	;MAXIMUM LENGTH OF TAPE HEADER BLOCK

	;FILE HEADER (ALSO EACH BLOCK OF .TAPE.;TAPE <N> FILE)
	;END OF .TAPE.; FILE MARKED BY NO MORE WORDS .IOT'D (BLETCH!)
	;NOTE: TAPE HEADER (IF ANY), FILE HEADER, AND FILE ALL
	  ;WITHOUT INTERVENING EOF MARKS ON TAPE

FLHD:	0	;0 -# WORDS TOTAL IN HEADER,, (RH MUST BE ZERO)
	;^ ON DISK, EXISTS ONLY IN FIRST FILE BLOCK!
	0	;1 SYSTEM NAME
	0	;2 FNAM1
	0	;3 FNAM2
	0	;4 PACK #
	0	;5 DISK DATE, AND TIME IN DISK DATE FORMAT
LOC FLHD+100
LFLHDB==.-FLHD	;MAXIMUM LENGTH OF FILE HEADER BLOCK

TDNAM:	6,,(SIXBIT /DSK/)	;.OPEN BLOCK FOR SINGLE TAPE INFO FILE
	SIXBIT /TAPE/
TDFN2:	0		;TAPE NUMBER (IN SIXBIT)
TDSNM:	SIXBIT /.TAPE./	;SYSTEM NAME
PBLK

SWDEF NTPDIR==2	;NUMBER OF .TAPE DIRECTORIES
TPDRNM:	REPEAT NTPDIR,SIXBIT /.TAPE0/+.RPCNT	;TABLE OF SYSTEM NAMES

GWRDNE:	HRROI T,A
UTYINE:	.IOT UTYIC,T
	POPJ P,

DPSIX:	MOVEI C,0	;CONVERT DECIMAL NUMBER IN A INTO SIXBIT IN C
	MOVE T,[440600,,C]
DPSIX1:	IDIVI A,10.
	JUMPE A,DPSIX2
	HRLM B,(P)
	PUSHJ P,DPSIX1
	HLRZ B,(P)
DPSIX2:	MOVEI A,'0(B)
	TLNE T,770000
	IDPB A,T
	POPJ P,

6BNMCV:	MOVEI A,0	;CONVERT SIXBIT DECIMAL NUMBER IN B INTO VALUE IN A
6BNMC1:	MOVEI C,0	;OR DON'T SKIP IF NOT NUMBER
	ROTC B,6
	CAIL C,'0
	CAILE C,'9
	POPJ P,		;NOT A NUMBER
	IMULI A,10.	;UPDATE IN DECIMAL
	ADDI A,-'0(C)
	JUMPN B,6BNMC1
	JRST POPJ1

		;DUMPED FILE DOCUMENTATION (PRINTING) ROUTINES

		;PRINT FILE INFO

FLDSPT:	SKIPE LINEPS
	PUSHJ P,PCRLF	;NEW LINE, LAST FILE WAS ON SAME TAPE
	MOVE B,FLHD+1	;SYSTEM NAME
	PUSHJ P,SIXPTT
	MOVE B,FLHD+2	;FNAM1
	PUSHJ P,SIXPTT
	MOVE B,FLHD+3	;FNAM2
	PUSHJ P,SIXPTT
	MOVE A,FLHD+5	;DISK DATE/TIME
	PUSHJ P,GQDATE	;TRANSLATE INTO SIXBIT IN B (DATE) AND C (TIME)
	PUSHJ P,SIXPTT	;DATE (YYMMDD)
	MOVE B,C
	PUSHJ P,SIXPTT	;TIME (HHMMSS)
	MOVE B,TDFN2	;TAPE NUMBER IN SIXBIT
	PUSHJ P,SIXPTT	;TAPE NUMBER
	MOVE A,MTFLCT	;FILE NUMBER
	JRST PDPT	;PRINT FILE NUMBER AND RETURN WITHOUT PRINTING CRLF

		;PRINT INFO ABOUT TAPE (ON LINE OF LAST FILE ON TAPE)

TPDSPT:	MOVEI B,[ASCIZ /	OF /]	;TAB OF SP
	PUSHJ P,APRT
	MOVE A,MTFLCT	;NUMBER OF FILES ON TAPE
	PUSHJ P,PDPT
	PUSHJ P,PTAB
	MOVEI A,40	;SPACE => NEITHER INCREMENTAL DUMP NOR FULL DUMP
	SKIPGE TPHD+3
	MOVEI A,"I	;INCREMENTAL DUMP
	SKIPLE TPHD+3
	MOVEI A,"F	;FULL DUMP
	PUSHJ P,PCH	;INDICATE WHICH
IFN 0,[	MOVEI A,"*	;ASSUME NOT COMPLETED
	SKIPGE UTYJBF+6
	MOVEI A,40	;REGULAR
	SKIPLE UTYJBF+6
	MOVEI A,"A	;ARCHIVE
	PUSHJ P,PCH	;INDICATE WHICH
]IFN 1,	PUSHJ P,PSPACE
	PUSHJ P,SPACE2
	SKIPG B,TPHD+2	;DATE WRITTEN
	MOVE B,[SIXBIT /??????/]	;UNKNOWN
	PUSHJ P,SIXPT
	JRST PCRLF

		;DISK DATE HACKERY
		;A DATE (SIXBIT /YYMMDD/) IN A, DECIPHER MEANING OF YEAR BITS

QDTST:	JUMPL A,QYRNA	;JUMP IF NOT AVAILABLE
	AND A,[777700,,]	;MASK TO YEAR
	LDB T,[POINTL 11.,1,A]	;GET YEAR BIT
	MOVEM A,QDYR(T)		;STORE YEAR TAPE WRITTEN AS CURRENT YEAR
	SUB A,[000100,,]	;NOW CLUMSILY SUBTRACT ONE FROM YEAR
	TLNN A,(SIXBIT / 0/)
	ADD A,[-010000+001200,,]
	TLNN A,(SIXBIT /0/)
	ADD A,[120000,,]
	TRC T,1		;DECREMENTED YEAR IS "OTHER YEAR"
	MOVEM A,QDYR(T)	;STORE OTHER YEAR
	POPJ P,

QYRNA:	MOVE A,[SIXBIT /EV OD /]	;YEAR NOT AVAILABLE
	HLLZM A,QDYR
	HRLZM A,QDYR+1
	POPJ P,

VBLK
QDYR:	BLOCK 2		;SIXBIT OF YEARS, INDEXED BY YEAR BIT IN DISK DATE
PBLK

		;DISK DATE IN A, GET SIXBIT YYMMDD IN B, HHMMSS IN C
		;CLOBBERS A

GQDATE:	SETZM B,C	;IN CASE NOT KNOWN
	CAMN A,[-1]
	POPJ P,		;NOT KNOWN
	LDB T,[UNYRB A]	;YEAR BIT
	MOVE B,QDYR(T)	;YEAR
	LDB T,[UNMON A]	;MONTH
	MOVE D,[POINTL 6,6,B]	;SET UP BYTE POINTER TO B AND, LATER, C
	PUSHJ P,GQDPT2	;PUT TWO DIGITS IN B, MONTH
	LDB T,[UNDAY A]	;DAY IN MONTH
	PUSHJ P,GQDPT2	;PUT TWO DIGITS INTO B
	IOR B,[SIXBIT /  0000/]
	LDB T,[UNTIM A]	;GET TIME, # HALF-SECONDS SINCE BEGINNING OF DAY
	LSH T,-1	;CONVERT TO # SECONDS
	ADDI T,36000.	;TEN HOURS (FITS IN A HALFWORD)
	PUSHJ P,GQDAT2	;CONVERT TO SIXBIT TIME PLUS TEN HOURS
	ADD C,[SIXBIT $/00000$]	;'/ = '0-1
	POPJ P,

GQDAT2:	IDIVI T,60.
	HRLM TT,(P)
	SKIPE T
	PUSHJ P,GQDAT2
	HLRZ T,(P)
GQDPT2:	IDIVI T,10.	;PUT TWO DECIMAL DIGITS SIX BITS APART
	IDPB T,D
	IDPB TT,D
	POPJ P,

SWDFCK MTSTSW==0,[	;;MAGTAPE TESTING ROUTINES

UUO MTAPE

AMTAPE:	.CALL MTPBLK
	.VALUE
	POPJ P,

MTPBLK:	SETZ
	SIXBIT /MTAPE/
	[UTYJC]
	C	;AC FIELD
	SETZ B	;EFFECTIVE ADR

GETSYL:	CLEARF TMPF1	;LETTER FLAG
	MOVEI D,0	;CLEAR OUT NUMERIC VALUE
	JSP R,GTSYL
	CAIG A,"9
	JRST GETSL2
	CAIL A,"A
	JRST GETSL3
GETSLD:	JUMPE C,GTSYL2
	POPJ P,

GETSL2:	CAIL A,"0
	JRST GETSLN	;DIGIT
	TESTF E,ALTF\CRF
	POPJ P,
	JRST GETSLD

GETSLN:	IMULI D,10.	;DIGIT
	ADDI D,-"0(A)
	JRST GTSYL2

GETSL3:	CAILE A,"Z
	JRST GETSLD
	SETF TMPF1	;LETTER
	JRST GTSYL2

		;GET NUMBER; SKIP UNLESS BLANK

GETNUM:	PUSHJ P,GETSYL
	JUMPE C,CPOPJ	;BLANK
	MOVE A,D	;PUT NUMBER IN A
	TESTF N,TMPF1
	JRST POPJ1	;OK
	PUSHJ P,ERR1	;LETTERS IN SYL
	MOVE B,C
	PUSHJ P,SIXTYO
	ERR [ASCIZ / NOT A NUMBER./]

	CMD TAPOPN,TAPOPN,,FILE  OPEN FILE AS MAGTAPE UNIT.
	CMD TAPCLS,TAPCLS,,UNDO A TAPOPN.

TAPOPN:	MOVE A,[TPDNAM,,DNAM]
	BLT A,SNAM
	PUSHJ P,RFD
	MOVS A,[TPDNAM,,DNAM]
	BLT A,TPSNAM
	CLEARF OPNFJF
	.SUSET [.SSNAM,,SNAM]
	.OPEN UTYJC,DNAM
	OPNER UTYJC,DNAM
	SETF OPNFJF
	POPJ P,

TAPCLS:	CLEARF OPNFJF
	.CLOSE UTYJC,
	POPJ P,

CMD TAPLOD,TAPLOD,,FILE  LIKE TAPOPN BUT ALSO READ TAPE # FROM TAPE.

TAPLOD:	PUSHJ P,TAPOPN
	MTAPE		;REWIND
	SETZM MTFLCT	;CLEAR OUT FILE COUNT
	PUSHJ P,GWRDNJ	;GET TAPE HEADER
	JUMPL T,BDTPH
	TRNE A,-1
BDTPH:	.VALUE		;BAD TAPE HEADER
	CAMG A,[-4,,]
	CAMGE A,[-LTPHDB,,]
	XCT BDTPH	;BAD TAPE HEADER
	MOVEM A,TTPHD	;STORE TAPE-TYPE TAPE HEADER
	MOVE T,A
	ADD T,[1,,TTPHD+1]
	PUSHJ P,UTYJNE
	JUMPL T,BDTPH
	HLRZ A,TTPHD+1
	PUSHJ P,TAPLD1	;OPEN DISK FILE TOO
	MOVE B,TPHD
TAPLD3:	MOVE A,TPHD(B)
	CAME A,TTPHD(B)
	.VALUE		;ERR [ASCIZ /TAPE AND DISK TAPE HEADERS DISAGREE/]
	AOBJN B,TAPLD3
	POPJ P,

VBLK
TTPHD:	BLOCK LTPHDB
TFLHD:	BLOCK LFLHDB

TPDNAM:	6,,(SIXBIT /MT0/)
	SIXBIT /MAG/
	SIXBIT /INPUT/
TPSNAM:	0
PBLK

CMD TAPENR,TAPENR,,NR  SPECIFY TAPE NUMBER.

TAPENR:	PUSHJ P,GETNUM
	ERR [ASCIZ /NO TAPE NUMBER?/]
TAPLD1:	PUSHJ P,GQXTP	;ENTRY (SUBR) FROM TAPLOD
	ERR [ASCIZ /.TAPE.; TAPE FILE BAD/]
QNXTF1:	PUSHJ P,LSWDEL
	 PUSHJ P,RDCLS
	HLRE A,TPHD
	SOJ A,
	MOVNM A,TPHDRL'	;# WORDS IN TAPE HEADER
	HLRE A,FLHD
	MOVNM A,TPWPF'	;# WORDS PER FILE ENTRY
	POPJ P,

	CMD FILENR,FILENR,,NR  SET FILE NUMBER.
	CMD PFILNR,PFILNR,,PRINT FILE NUMBER.

FILENR:	PUSHJ P,GETNUM
	ERR [ASCIZ /NO NUMBER FOR FILENR?/]
	MOVEM A,MTFLCT
	POPJ P,

PFILNR:	MOVE A,MTFLCT
	PUSHJ P,DPT
	JRST CRLF

	CMD MT,MTP1,,[NR1,NR2  DO MTAPE NR1,NR2.]

MTP1:	PUSHJ P,GETNUM
	JFCL
	PUSH P,D
	TESTF N,ALTF\CRF
	PUSHJ P,GETNUM
	TDZA B,B	;NO SECOND ARG
	MOVE B,D
	POP P,C		;FIRST ARG
	JRST AMTAPE

	CMD FWD,MTFWD,,N  SPACE FWD N FILES.

MTFWD:	PUSHJ P,GETNUM
MTFWD1:	MOVEI A,1	;ENTRY FROM ELSEWHERE TO SPACE FORWARD ONE FILE
	MOVE B,A
	MTAPE 6		;SPACE TO BEG OF NEXT
	AOS MTFLCT
	SOJG B,.-2
	POPJ P,

	CMD REV,MTREV,,N  SPACE REVERSE N FILES.

MTREV:	PUSHJ P,GETNUM
	MOVEI A,1	;DEFAULT IS ONE
	MOVE B,A
MTREV2:	MTAPE 2		;SPACE TO BEG OF PREV
	SOSGE MTFLCT
	SETZM MTFLCT
	SOJG B,MTREV2
	POPJ P,

	CMD VFY,MTVFY,,VERIFY TAPE FILE HEADER AGAINST DISK.

MTVFY:	PUSHJ P,GFILQ	;GET INFO FROM DISK
	MOVE T,[-1,,TFLHD]
	ADD T,FLHD
	HLLZ B,T
	PUSHJ P,UTYJNE
	SKIPGE T
	ERR [ASCIZ /TAPE FILE HEADER TOO SHORT/]
	MOVSI A,1
	ADDM A,TFLHD
MTVFY2:	MOVE A,TFLHD(B)
	CAME A,FLHD(B)
	JRST MTVFY3	;ERROR
	AOBJN B,MTVFY2
	CTYPE "(
	MOVE A,MTFLCT
	PUSHJ P,DPT
	TYPCR [ASCIZ / OK)/]
	MOVEI B,1
	JRST MTFWD1	;SKIP TO EOF

MTVFY3:	MOVE A,MTFLCT	;ERROR
	PUSHJ P,DPT
	TYPE [ASCIZ /Q /]
	6TYPE 5,FLHD+1	;SNAM
	6TYPE 1,FLHD+2	;FNAM1
	6TYPE   FLHD+3	;FNAM2
	TYPE [ASCIZ / -> X /]
	PUSHJ P,MTVFY4	;SEE IF CAN FIND FILE ON DISK
	6TYPE 5,TFLHD+1	;TAPE SNAM
	6TYPE 1,TFLHD+2	;FNAM1
	6TYPE 3,TFLHD+3	;FNAM2
	POPJ P,

MTVFY4:	PUSH P,MTFLCT	;SAVE IN CASE CAN'T FIND FILE ON DISK
	SETZM MTFLCT
MTVF4B:	PUSHJ P,QNXTFL
	JRST MTVF4E	;THIS ONE NOT ON DISK
	MOVSI B,-1
	ADD B,FLHD
MTVF4C:	MOVE A,TFLHD(B)
	CAME A,FLHD(B)
	JRST MTVF4B
	AOBJN B,MTVF4C
	POP P,A		;FOUND FILE, THROW AWAY OLD MTFLCT
	MOVE A,MTFLCT	;GET NEW ONE
	PUSHJ P,DPT
	JRST SPACE

MTVF4E:	POP P,MTFLCT
	TYPE [ASCIZ /?? /]
	POPJ P,

QNXTFL:	SKIPN MTFLCT
	.ACCESS UTYIC,TPHDRL	;BACK TO BEGINNING OF .TAPE. FILE
	MOVEI T,FLHD+1
	ADD T,FLHD
	PUSHJ P,UTYINE	;GET FILE DESC. BLOCK FROM DISK
	AOS MTFLCT
	JUMPGE T,POPJ1	;SKIP-RETURN UNLESS EOF
	PUSHJ P,GQXTP1	;EOF, RE-OPEN .TAPE. FILE
	.VALUE
	JRST QNXTF1	;RE-READ BEGINNING

		;GET INFO FROM DISK ABOUT CURRENT FILE

GFILQ:	MOVE A,MTFLCT
	IMUL A,TPWPF
	ADD A,TPHDRL
	TLNE A,-1
	.VALUE		;BAD .ACCESS POINTER
	.ACCESS UTYIC,A
	MOVEI T,FLHD+1
	ADD T,FLHD
	JRST UTYI

	;MAGTAPE BUFFER COUNTING ROUTINES

MAXDEF RNDBFL==400	;SYSTEM'S MEMBLT TABLE COPIED INTO RNDBUF

CMD CMTB,CMTB,,COUNT SYSTEM MAGTAPE BUFFERS.

INIT [	JSP B,SYEVAL
MTBGRP:	SQUOZE 0,MEMBLT
	MEMBLP'
	SQUOZE 0,MUMGB
	MUMGB'
	SQUOZE 0,MUR
	MURVL']	;EVALUATE RELEVANT SYSTEM SYMS

CMTB:	MOVEI B,MTBGRP
	PUSHJ P,SYEVCK	;MAKE SURE SYSTEM SYMS DEFINED
	.OPEN UTYIC,[6,,SIXBIT /   USRSYS   SYS      /]	;EXTRA WORD NULL SYSTEM NAME
	OPNER UTYIC,@.-1
	PUSHJ P,LSWSET
	 .CLOSE UTYIC,	;CLOSE UTYIC WHEN DONE
	.ACCESS UTYIC,MEMBLP
	MOVE T,[-400,,RNDBUF]
	PUSHJ P,UTYI	;READ IN SYSTEM'S MEMBLT TABLE
	PUSHJ P,LSWONE
	 .CLOSE UTYIC,	;DONE WITH UTYIC
	MOVEI C,0	;INITIALIZE COUNT
	MOVSI B,-400	;AOBJN POINTER
	HLRZ D,MURVL
	ADD D,[RNDBUF(B)]
CMTB1:	LDB A,D
	CAMN A,MUMGB
	ADDI C,1	;MAGTAPE BUFFER
	AOBJN B,CMTB1	;LOOP FOR ENTIRE TABLE
	MOVE A,C	;GET TOTAL COUNT
	PUSHJ P,DPT	;TYPE OUT IN DECIMAL
	CTYPE ".	;SO HE'S SURE IT'S DECIMAL
	JRST CRLF

CMD PMTB,PMTB,,TYPE OUT NUMBER AND LOCATIONS OF MAGTAPE BUFFERS.

PMTB:	PUSHJ P,CMTB	;GET MEMBLT TABLE AND TYPE OUT NUMBER
	MOVSI D,-401	;AOBJP POINTER (EXTRA 1 SINCE AOBJP PRECEDES ACTION)
	HLRZ E,MURVL
	ADD E,[RNDBUF-1(D)]
	SETOM PMTLBK	;INITIALIZE LOW BLOCK NUMBER
	SETOM PMTHBK	;INITIALIZE HIGH BLOCK NUMBER
	MOVEI C,LSTCPL	;# ENTRIES PER LINE
PMTB2:	AOBJP D,PMTB3	;EXIT IF DONE; INCREMENT POINTER
	LDB A,E		;GET CORE BLOCK TYPE
	CAME A,MUMGB
	JRST PMTB2	;NOT MAGTAPE BUFFER
	MOVE A,PMTHBK	;HIGHEST BLOCK FOUND SO FAR
	CAIE A,-1(D)	;DOESN'T SKIP IF C(T) = -1
	JRST PMTB3
	AOS PMTHBK'	;ANOTHER CONSECUTIVE BLOCK
	JRST PMTB2

PMTB3:	JUMPL A,PMTB5	;JUMP IF THIS IS FIRST TIME HERE
	CAMN A,PMTLBK'
	JRST PMTB4	;HIGH = LOW, DON'T TYPE OUT REDUNDENTLY
	CTYPE "-	;SEPARATE NUMBERS WITH HYPHEN
	PUSHJ P,OCTYO	;TYPE OUT LAST CONSECUTIVE CORE BLOCK NUMBER IN OCTAL
PMTB4:	SOJLE C,PMTB4B	;JUMP FOR NEW LINE
	PUSHJ P,TAB
PMTB5:	JUMPG D,CPOPJ
	MOVEI A,(D)
	HRRZM D,PMTLBK
	HRRZM D,PMTHBK
	PUSHJ P,OCTYO	;LOWEST OF GROUP OF CONSECUTIVE BLOCKS
	JRST PMTB2

PMTB4B:	PUSHJ P,CRLF
	MOVEI C,LSTCPL
	JRST PMTB5

OCTYO:	IDIVI A,8
	JUMPE A,DPT2
	HLRM B,(P)
	PUSHJ P,OCTYO
	JRST OCTYO2

]		;END MTSTSW CONDITIONAL

SWDFCK JBVSW==0,[	;;JBV JOB VERIFIER

CMD JBV,JBV,,INFILES$OUTFIL  JOB VERIFY INFILES.

SWDEF J2LNPS==32.	;COLUMN NUMBER TO ALIGN TO FOR JOB 2 PRINTOUT
SWDEF JBVJ1==600000	;ADR OF BLOCK .CBLK'D FROM JOB 1
SWDEF JBVJ2==602000	; " " " JOB 2
SWDEF SNUSR==61		;INFERIOR PROCEDURE .STATUS DEVICE CODE
SWDEF SNFUSR==60	;FOREIGN " "

PRTSW==1		;INCLUDE PRINT ROUTINES
DATMSW==1		;INCLUDE DATE/TIME PRINTING ROUTINES

JBV:	PUSHJ P,RIFDS	;READ AT LEAST TWO INPUT FILE DESCRIPTIONS
	PUSHJ P,JBVLOD	;LOAD (TWO) JOBS
	PUSHJ P,PRTOPN	;OPEN PRINT FILE
	CLEARF TMPF1	;CLEAR OUT "KEEP PRINTING INDEFINITELY" FLAG
	PUSHJ P,LSWSET
	 PUSHJ P,JBVCLS	;CAUSE PAGED IN CORE BLOCKS TO BE FLUSHED WHEN DONE
	SETZB A,JBVBKN	;INITIALIZE CORE BLOCK NUMBER
JBV1:	PUSHJ P,JBVCOR	;GET BLOCKS INTO JBVJ1 AND JBVJ2 (BLOCK # IN A)
	CAME T,TT	;COMPARE EXISTENCE FLAGS RETURNED BY JBVCOR
	JRST JBVD	;ONE JOB HAS THIS BLOCK, THE OTHER DOESN'T (RETURNS TO JBVL)
	JUMPGE T,JBVL	;JUMP IF BOTH JOBS DON'T HAVE BLOCK
	MOVSI E,-2000	;SET UP AOBJN POINTER FOR BLOCK COMPARISON
JBV2:	MOVE T,JBVJ1(E)	;INNER LOOP: GET WORD FROM JOB 1
	CAME T,JBVJ2(E)	;COMPARE WITH CORRESPONDING WORD IN JOB 2
	PUSHJ P,JBVPD	;LOCATIONS DIFFERENT, PRINT DIFFERENCE
	AOBJN E,JBV2	;LOOP FOR THE ENTIRE BLOCK
JBVL:	AOS A,JBVBKN'	;DONE WITH BLOCK, INCREMENT TO NEXT CORE BLOCK
	CAIGE A,400	;TOO HIGH?
	JRST JBV1	;NO, BACK FOR NEXT CORE BLOCK
	SKIPN PAGENR	;DONE PRINTING, NOW SEE IF PRINTED ANYTHING
	SKIPE LINENR
	JRST .+2	;YES
	TYPCR [ASCIZ /(JBV FILES IDENTICAL.)/]
	JRST PRTCLS	;LET LSWCLR WIPE OUT JOBS

		;PRINT ROUTINES FOR JBV

		;ONE JOB HAS CORE BLOCK, THE OTHER DOESN'T
		;PRINT THIS INFO AND RETURN TO JBVL

JBVD:	PUSH P,TT	;SAVE JOB 2 STATUS FLAG
	PUSH P,T	;SAVE JOB 1 STATUS FLAG
	PUSHJ P,JBVHD	;MAYBE QUIT OR PRINT PAGE HEADER
	MOVE A,JBVBKN	;GET BLOCK NUMBER
	LSH A,1		;YEAH, WELL
	PUSHJ P,OCTPT	;PRINT FIRST FEW DIGITS OF FIRST ADR IN BLOCK IN OCTAL
	PRT [ASCIZ /XXX	/]
	POP P,T		;GET BACK JOB 1 STATUS FLAG
	MOVEI A,JBVJ1	;WHERE TO START CHECKING (FOR NON-ZERO-NESS)
	PUSHJ P,JBVD1	;PRINT INFO ON BLOCK IN JOB 1
	MOVEI B,J2LNPS
	PUSHJ P,ALIGN
	POP P,T		;NOW FOR JOB 2
	MOVEI A,JBVJ2
	PUSHJ P,JBVD1
	PUSHJ P,PCRLF	;END LINE
	JRST JBVL	;RETURN FOR NEXT CORE BLOCK

JBVD1:	MOVEI B,[ASCIZ /ABSENT/]
	JUMPGE T,APRT
	MOVEI B,[ASCIZ /ZERO/]
	HRLI A,-2000	;SET UP AOBJN POINTER FOR CHECKING BLOCK
	SKIPE (A)
	SKIPA B,[[ASCIZ /NON-ZERO/]]
	AOBJN A,.-2
	JRST APRT

		;PRINT DIFFERENCE BETWEEN LOCATIONS
		;E NON-TEMP, HAS INDEX INTO CORE BLOCK

JBVPD:	PUSHJ P,JBVHD	;MAYBE QUIT OR PRINT PAGE HEADER
	MOVE A,JBVBKN	;BLOCK NUMBER
	LSH A,10.	;CONVERT TO INITIAL ADDRESS IN BLOCK
	ADDI A,(E)	;CALCULATE OFFENDING ADR
	PUSHJ P,OCTPT	;PRINT IN OCTAL
	PUSHJ P,PTAB	;TAB
	MOVE A,JBVJ1(E)	;CONTENTS IN JOB 1
	PUSHJ P,JBVPT
	MOVEI B,J2LNPS
	PUSHJ P,ALIGN
	MOVE A,JBVJ2(E)	;GET CONTENTS IN JOB 2
	PUSHJ P,JBVPT
	JRST PCRLF	;END WITH CR

		;PRINT C(A) "SYMBOLICALLY" FOR JBVPD
		;DON'T CLOBBER E

JBVPT:	TLNN A,-1
	JRST OCTPT	;LH ZERO
	HRLM A,(P)
	HLRZS A
	PUSHJ P,OCTPT	;PRINT LH
	PUSHJ P,PCOMMA
	PUSHJ P,PCH	;ANOTHER COMMA
	HLRZ A,(P)	;GET RIGHT HALF
	JUMPE A,CPOPJ	;NOTHING IF ZERO
OCTPT:	IDIVI A,8	;PRINT OCTAL NUMBER IN A
	JUMPE A,PDGPTB
	HRLM B,(P)
	PUSHJ P,OCTPT
	JRST OCTPT2

		;MAYBE PRINT PAGE HEADER FOR JBV
		;IF PAGE NUMBER IS MULTIPLE OF 8, ASK USER WHETHER SHOULD CONTINUE
		;DON'T CLOBBER E
		;TMPF1 USED AS FLAG, SHOULD BE CLEARED DURING INITIALIZATION

JBVHD:	SKIPE LINENR
	POPJ P,		;NOT AT BEGINNING OF PAGE
	TESTF E,TMPF1
	JRST JBVHD2	;CONTINUING INDEFINITELY
	MOVE A,PAGENR	;GET NUMBER OF PAGES COMPLETED
	TRNN A,7
	JUMPN A,JBVHQ	;ASK USER WHETHER SHOULD CONTINUE
JBVHD2:	PUSH P,E
	MOVEI B,[ASCIZ /
LOC	/]		;BEGINNING OF PAGE HEADER
	PUSHJ P,APRT
	MOVEI B,RCHSTC
	PUSHJ P,PRTFIL	;PRINT FILE DESCRIPTION FOR JOB 1
	MOVEI B,J2LNPS
	PUSHJ P,ALIGN
	MOVEI B,RCHSTB
	PUSHJ P,PRTFIL	;NOW FILE DESC FOR JOB 2
	PUSHJ P,PTAB
	PUSHJ P,NOWPRT	;PRINT DATE AND TIME
	MOVEI B,[ASCIZ /	PAGE /]	;TAB PAGE SPACE
	PUSHJ P,APRT
	MOVE A,PAGENR
	PUSHJ P,[AOJA A,PDPT]	;PRINT PAGE NUMBER
	POP P,E
	JRST P2CRLF	;END WITH 2 CRS; FOLLOW HEADER WITH BLANK LINE

JBVHQ:	CAIE A,8
	JRST JBVHQ2	;NOT FIRST TIME HERE
	TYPE [ASCIZ /JBV OUTPUT 8 PAGES SO FAR; CONTINUE?  /]
JBVHQ1:	PUSHJ P,TYI	;GET ANSWER
	CAIN A,"I
	TMODF OA,TMPF1	;INDEFINITELY
	CAIN A,"Y
	JRST JBVHQ4	;YES, BUT NOT NECESSARILY INDEFINITELY
	ERR [ASCIZ / FLUSHED./]	;NO

JBVHQ4:	PUSHJ P,CRLF	;USER WANTS TO CONTINUE
	JRST JBVHD2

JBVHQ2:	PUSHJ P,DPT
	TYPE [ASCIZ / PAGES; CONTINUE?  /]
	JRST JBVHQ1

		;LOAD INFILES INTO JOBS; CHECK TO SEE IF INFILES ALREADY JOBS

VBLK		;ADDRESS MODIFIED (.CLOSE/.UCLOSE)

JBVLOD:	PUSHJ P,JBVLD1	;JOB 1
	HRRM A,.+2	;.CLOSE OR .UCLOSE
	PUSHJ P,LSWSET
	 .UCLOSE\.CLOSE UTYIC,
	PUSHJ P,LSWSET
	 .IOPOP UTYIC,
	MOVE A,[RCHSTB,,RCHSTC]
	BLT A,RCHSTC+3	;SAVE REAL FILE DESCRIPTION FOR HEADER
	PUSHJ P,JBVLD1	;LOAD JOB 2
	.IOPOP UTYJC,	;POP JOB 2 INTO UTYJC
	PUSHJ P,LSWONE
	 .IOPOP UTYIC,	;POP JOB 1 INTO UTYIC
	HRRM A,.+2	;.CLOSE OR .UCLOSE
	PUSHJ P,LSWSET
	 .UCLOSE\.CLOSE UTYJC,
	POPJ P,

RCHSTC:	BLOCK 4		;.RCHST RESULT FROM JOB 1'S INFILE
PBLK

		;JBV CORE (.CBLK) PROCESSING ROUTINES

JBVCLS:	MOVEI A,SIGN	;ENTRY TO FLUSH PAGES
JBVCOR:	MOVEI T,SIGN+JBVJ1_-1(A)	;ENTRY TO INSERT, A HAS BLOCK NUMBER
	HRLI T,2400+UTYIC
	.CBLK T,		;TRY GETTING FROM JOB 1
	TDZA T,T	;LOSE, CLEAR TT AS FLAG ON RETURN
	MOVNI T,1	;WIN, SET T TO -1 AS FLAG ON RETURN
	MOVEI TT,SIGN+JBVJ2_-1(A)	;NOW FOR JOB 2
	HRLI TT,2400+UTYJC
	.CBLK TT,
	TDZA TT,TT	;TT IS SUCCESS/FAILURE FLAG FOR JOB 2'S PAGE
	MOVNI TT,1
	POPJ P,

		;OPEN AND LOAD AN INFILE, CLOSE THE FILE, AND .IOPUSH THE JOB
		;LEAVES RH(.CLOSE OR .UCLOSE) IN A AS "DESTROY" INSTRUCTION

JBVLD1:	PUSHJ P,OPNRD	;OPEN INFILE
	ERR [ASCIZ /NOT ENOUGH INFILES FOR JBV./]
	.STATUS UTYIC,B
	ANDI B,77	;MASK TO DEVICE CODE
	CAIE B,SNUSR
	CAIN B,SNFUSR
	JRST JBVLD5	;ALREADY JOB OF SOME KIND
JBVLD2:	MOVEI A,DNAM-1
	PUSH A,[6,,(SIXBIT /USR/)]	;DNAME
	.SUSET [.RUNAM,,T]
	PUSH A,T	;UNAME
	.GENSYM T,
	PUSH A,T	;JOB NAME
	PUSH A,[0]	;SYSTEM NAME IRRELEVANT; FOR TYPFIL ON OPNER
	.OPEN UTYJC,DNAM	;TRY OPENING JOB
	OPNER UTYJC,DNAM
	.STATUS UTYJC,A	;NOW SEE WHAT HAPPENED
	ANDI A,77	;MASK TO DEVICE CODE
	CAIN A,SNFUSR	;GOT FOREIGN USER?
	JRST JBVLD2	;YES, TRY AGAIN
	PUSHJ P,LSWSET
	 .UCLOSE UTYJC,
JBVLDX:	.CALL JBVLDC	;LOAD FILE INTO JOB
	OPNER		;LOST
	PUSHJ P,LSWDEL
	 .UCLOSE UTYJC,
	PUSHJ P,RDCLS	;FLUSH INFILE
	.IOPUSH UTYJC,	;SAVE JOB ON I/O PDL
	MOVEI A,.UCLOSE	;TELL CALLING ROUTINE WHAT HAPPENED
	POPJ P,

JBVLD5:	.IOPUSH UTYIC,	;INFILE IS ALREADY A JOB, SAVE IT
	PUSH P,B
	PUSHJ P,RDCLS	;CLEAR OUT FLAGS, ETC.
	POP P,B
	MOVEI A,.CLOSE
	CAIN B,SNUSR
	MOVEI A,.UCLOSE	;IMMEDIATE INFERIOR!
	POPJ P,

JBVLDC:	SETZ		;.CALL BLOCK FROM JBVLD1
	SIXBIT /LOAD/
	[UTYJC]		;JOB CHANNEL
	SETZ [UTYIC]	;DISK CHANNEL

]		;END JBVSW CONDITIONAL

SWDFCK JCPSW==0,[	;;JCPJ , FIND INSTANCES OF JRST CPOPJ ON DISK

CMD JCPJ,JCPJ,,MULTIFILE$OUTFIL  FIND OCCURRENCES OF JRST CPOPJ IN MULTIFILE.

REDSW==1	;INCLUDE READ ROUTINES
PRTSW==1	;INCLUDE PRINT ROUTINES
MAXDEF REDBFL==200	;LENGTH OF READ BUFFER

JCPJ:	PUSHJ P,MFCOMP	;COMPILE MULTIFILE
	PUSHJ P,PRTOPN	;GET OUTPUT FILE SPECIFICATION
	TYPCR TWTAW	;"THIS IS GOING TO TAKE A WHILE"
	PUSHJ P,QRMFD	;READ MFD
	HALT		;???
JCPJ1:	PUSHJ P,QRUFD	;GET NEXT UFD
	JRST PRTCLS	;ALL DONE
JCPJ2:	PUSHJ P,QRFILE	;NEXT FILE
	JRST JCPJ1	;NO MORE THIS USER
	MOVE A,QFILE+UNRNDM
	TLNE A,UNIGFL\UNLINK
	JRST JCPJ2	;LINK OR NOT REALLY THERE, IGNORE IT
	LDB A,[UNPKN QFILE+UNRNDM]	;GET PACK NUMBER
	MOVE B,QFILE+UNFN1	;FNAM1
	MOVE C,QFILE+UNFN2	;FNAM2
	MOVE D,USER	;SNAM
	PUSHJ P,MFCHK	;CHECK THIS FILE?
	JRST JCPJ2	;NO
	MOVE A,[2,,(SIXBIT /DSK/)]	;WANT TO CHECK IT
	.OPEN REDIC,A	;TRY OPENING FILE
	JRST JCPJ7	;LOSS
	SETF OPNFRF	;FILE IS OPEN
	PUSHJ P,REDCL2	;INITIALIZE INPUT FILE VARIABLES
	SETZM JCPJCT	;CLEAR OUT LOSS COUNT
	PUSHJ P,SOBTH	;COUNT CRUD IN THIS FILE
	SKIPN JCPJCT
	JRST JCPJ2	;NO LOSSAGE, BACK FOR NEXT FILE
	PUSHJ P,JCPJ8	;LOSSAGE, PRINT FILE DESCRIPTION
	MOVE A,JCPJCT	;GET LOSS COUNT
	PUSHJ P,PDPT	;PRINT IT
JCPJ7X:	PUSHJ P,PCRLF	;END LINE
	JRST JCPJ2

JCPJ7:	PUSHJ P,JCPJ8	;.OPEN ON REDIC LOST, PRINT IT
	.OPEN FDRC,JCPJOE	;OPEN ERR DEV, LAST CHANNEL WITH ERROR
	HALT
JCPJ7B:	.IOT FDRC,A	;GET CHAR
	JUMPL A,JCPJ7X
	CAIE A,^L
	CAIN A,^C
	JRST JCPJ7X
	PUSHJ P,PCH	;PRINT CHAR
	JRST JCPJ7B	;LOOP

JCPJOE:	(SIXBIT /ERR/)	;UNIT ASCII INPUT
	1		;CHANNEL WITH LAST ERROR

JCPJ8:	MOVE B,USER	;PRINT SNAM, FNAM1, FNAM2
	PUSHJ P,SIXPTT
	MOVE B,FNAM1
	PUSHJ P,SIXPTT
	MOVE B,FNAM2
	JRST SIXPTT

		;ROUTINE TO PROCESS A FILE

JCPBK:	CAIN C,10.	;BREAK CHAR OTHER THAN LOGICAL SPACE
	JRST JCPF	;FOUND A LOSER
JCPBK2:	TDZA C,C	;CLEAR OUT COUNT AND FALL IN
SOBTH:	MOVNI C,1	;SQUOZE CHARS OTHER THAN MATCHING
JCPRR:	ILDB A,RCHBP	;ENTRY, GET CHAR
	XCT RRTAB(A)	;DO THE RIGHT THING
	AOJA C,JCPRR	;DIDN'T SKIP, INCREMENT COUNT AND LOOP FOR NEXT CHAR
	JRST SOBTH	;SKIPPED, INITIALIZE COUNT

	AOJA C,JCPRR	;-1 (FOR NEXT TABLE)
JCPSPT:	JRST JCPRR	;0 SPACES ETC. THIS TABLE XCT'D INDEXED BY C AT JCPRR+1
	REPEAT 3,MOVNI C,1	;1,2,3
	AOJA C,JCPRR	;4
	JRST JCPRR	;5
	REPEAT 4,MOVNI C,1	;6,7,8,9
	JRST JCPF	;10. => FOUND

JCP095:	CAIN C,9	;J
	AOJA C,JCPRR
	CAIE C,5
	JRST SOBTH
	MOVEI C,1
	JRST JCPRR

JCP68:	CAIE C,6	;P
	CAIN C,8
	AOJA C,JCPRR
	JRST SOBTH

JCPF:	AOS JCPJCT'	;FOUND A LOSER, INCREMENT COUNT THIS FILE
	JRST JCPBK2

JCPRLF:	PUSHJ P,REDRLD	;EOF CHAR
	POPJ P,		;DONE WITH THIS FILE
	JRST JCPRR

		;TABLE OF INSTRUCTIONS XCT'D INDEXED BY CHAR AT JCPRR+1
DEFINE JCPBRK A		;NORMAL (NON-SPACE) BREAK CHAR MACRO
REPEAT <A>,JUMPGE C,JCPBK
TERMIN

DEFINE JCPSQ A	;UNINTERESTING SQUOZE CHAR MACRO
REPEAT <A>,JRST SOBTH
TERMIN

RRTAB:	JCPBRK 3,	;^@ - ^B
	JRST JCPRLF	;^C
	JCPBRK 37-^D+1,	;^D - ^_
	XCT JCPSPT(C)	;SPACE
	JCPBRK 2,	; ! "
	XCT JCPSPT(C)	; #
	JRST SOBTH	; $
	JRST SOBTH	; %
	JCPBRK "*-"&+1,	; & - *
	XCT JCPSPT(C)	; +
	XCT JCPSPT(C)	; ,
	JCPBRK 1,	; -
	JRST SOBTH	; .
	JCPBRK 1,	; /
	JCPSQ 10.,	;DIGITS
	JCPBRK 6,	; : - ?
	JRST SOBTH	; @
IRP DUMMY,,[[JCPBRK 6,	;BRACKETS, ETC. -> GRAVE ACCENT]
[JCPBRK 4,	;LEFT BRACE - VERTICAL BAR?
	XCT JCPSPT(C)	;RUBOUT, LIKE SPACE]]
	JCPSQ 2,	; A - B
	CAIN C,5	; C
	JCPSQ 6,	; D - I
	JUMPN C,JCP095	; J
	JCPSQ "N-"K+1,	; K - N
	CAIN C,7	; O
	JRST JCP68	; P
	JCPSQ 1,	; Q
	CAIN C,1	; R
	CAIN C,2	; S
	JCPSQ "Z-"T+1,	; T - Z
	DUMMY		;OTHERS
TERMIN
IFN .-RRTAB-200,PRINTB [RRTAB LOSES; LENGTH = ]\.-RRTAB,

]		;END JCPSW CONDITIONAL

SWDFCK PGCTSW==0,[	;;PGCT PAGE COUNTER

CMD PGCT,PGCT,,INFILES  TYPE OUT # FORM FEEDS AND # PAGES IN INFILES

REDSW==1		;INCLUDE BLOCK INPUT ROUTINES

PGCT:	PUSHJ P,RIFDS	;READ INPUT FILE DESCRIPTIONS
PGCT1:	SETZM PGCTPN	;CLEAR OUT FORM FEED PAGE NUMBER
	SETZM PGCTRN	;CLEAR OUT REAL PAGE NUMBER COUNT
	PUSHJ P,REDOPN	;OPEN NEXT FILE
	 POPJ P,	;NO MORE
	MOVEI B,RCHSTB
	PUSHJ P,TYPFIL	;TYPE OUT FILE NAME
	PUSHJ P,SPACE	;SEPARATE WITH SPACE
	MOVE A,[PGCACL,,PGCACT]
	BLT A,PGCACL+PGCALL-1	;BLT IN ROUTINE, TO ACS TO RUN FAST
PGCT5:	MOVE B,RCHBP	;GET INPUT BYTE POINTER IN B
	JRST PGCT4	;INTO ACS, COUNT PAGES

PGCACL:	OFFSET D-.	;THIS ROUTINE GOES IN THE ACS IN ORDER TO RUN FAST
PGCACT::
PGCT2::	TDZA C,C	;CLEAR OUT CHAR COUNT WITHIN LINE
PGCT4::	SETZB C,PGCTLN	;CLEAR OUT LINE NUMBER
PGCT3::	ILDB A,B	;GET CHAR
	CAIL A,^M	;SPECIAL?
	AOJA C,PGCT3	;NOT SPECIAL, INCREMENT CHAR COUNT AND BACK FOR NEXT
	XCT PGCTTB(A)	;SPECIAL, DO THE APPROPRIATE THING
	JRST PGCT2	;RETURNED => BACK FOR MORE, CLEARING LINE POSITION
PGCALL==.-PGCACT	;LENGTH OF THIS ROUTINE
	OFFSET 0

PGCT6:	MOVEM B,RCHBP	;HERE ON ^C, STORE BACK BYTE POINTER
	PUSHJ P,REDRLD	;TRY RELOADING
	JRST .+2	;REAL EOF
	JRST PGCT5	;JUST BUFFER RELOAD, BACK FOR MORE
	SKIPN PGCTLN	;EOF, SEE IF CRUD BETWEEN LAST FORM FEED AND EOF
	SKIPE C
	PUSHJ P,PGCTRA	;STUFF AFTER LAST FORM FEED
	MOVE A,PGCTPN	;GET FORM FEED COUNT
	PUSHJ P,DPT	;TYPE OUT IN DECIMAL
	PUSHJ P,SPACE
	MOVE A,PGCTRN	;GET "REAL" PAGE NUMBER (NUMBER OF LINE PRINTER PAGES NECESSARY)
	PUSHJ P,DPT	;TYPE IT OUT IN DECIMAL TOO
	PUSHJ P,CRLF	;END WITH CR
	JRST PGCT1	;BACK MAYBE FOR NEXT FILE

PGCTFF:	PUSHJ P,PGCTRA	;FORM FEED
	JRST PGCT4

PGCTRA:	AOS PGCTPN'	;INCREMENT FORM FEED COUNT
	SKIPN C		;CHECK FOR EXTRA LINE NOT FOLLOWED BY LF
	SKIPA A,PGCTLN	;OK, GET LINE NUMBER
	AOS A,PGCTLN	;NOT OK, INCREMENT AND GET IT
	IDIVI A,60.	;GET NUMBER OF PHYSICAL PAGES THIS PAGE
	SKIPE B		;CHECK FOR EXTRA
	AOS A		;EXTRA, ADD ANOTHER
	ADDM A,PGCTRN'	;UPDATE "REAL" PAGE COUNT (# PAGES OF PAPER NECESSARY)
	POPJ P,

DEFINE PGCTM A	;MACRO FOR NOT REALLY SPECIAL CHARS
REPEAT <A>,AOJA C,PGCT3
TERMIN

PGCTTB:	PGCTM 3		;^@, ^A, ^B
	JRST PGCT6	;^C
	PGCTM 6		;^D ^E ^F ^G ^H ^I
	AOS PGCTLN'	;^J LINE FEED, INCREMENT LINE COUNT WITHIN PAGE
	PGCTM 1		;^K
	JRST PGCTFF	;^L FORM FEED
IFN .-PGCTTB-^M,PRINTB PGCTTB LENGTH = ,\.-PGCTTB,[, SHOULD BE ]\^M,
]

		;TTY ROUTINES

		;GET CHARACTER FROM COMMAND STRING, SET UP ALTF, CRF; USE UNRCHA

RCHA:	TMODF ZE,UNRCHA	;CLEAR AND CHECK RE-INPUT FLAG
	SKIPA A,LIMBOA	;RETRIEVE LAST
	PUSHJ P,RTYI	;GET NEXT
	MOVEM A,LIMBOA'	;STORE AS LAST INPUT
	CLEARF ALTF\CRF	;CLEAR TERMINATOR FLAGS
	CAIN A,^M
	SETF CRF\UNRCHA	;CARRIAGE RETURN, CAUSE INDEFINITE RE-INPUT UNLESS SPECIFICALLY FLUSHED
	CAIN A,33
	SETF ALTF	;ALTMODE
	POPJ P,

		;.INSRT SO CAN MORE EASILY KEEP UP WITH SYS TTY ROUTINES

.INSRT JSF;DSK:STNDRD TTY

SIXTYO:	JUMPE B,CPOPJ	;TYPE OUT SIXBIT WORD IN B
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,TYO
	JRST SIXTYO

		;ASSORTED TYPEOUT ROUTINES

TYOSP2:	PUSH P,CTYO	;TWO SPACES
SPACE:	MOVEI A,40	;SPACE
CTYO:	JRST TYO

TAB:	MOVEI A,^I
	JRST TYO

		;MORE TYPEOUT ROUTINES, PRIMARILY FOR UUO'S

		;ERR [ASCIZ /STRING/]	;LIKE TYPECR [ASCIZ /STRING/] BUT CALLS ERR1, RETURNS TO ERRET
		;TYPECR [ASCIZ /STRING/]	;TYPE OUT STRING, FOLLOWED BY CRLF

AERR:	MOVEI A,ERRET
	HRRM A,UUOH	;CAUSE RETURN TO ERRET
	PUSHJ P,ERR1
ATYPCR:	PUSHJ P,ATYPE	;TYPCR, TYPE STRING THEN CR
	JRST CRLF

UUO [ERR 6TYPE 6QRT TYPCR TYPE CTYPE]	;UUOS

		;PUSHJ P,ERR1	;UN-SILENCE TYPEOUT IN PREPARATION FOR TYPEOUT OF ERROR MESSAGE

ERR1:	POPJ P,		;WOW, SOME UNSILENCING ROUTINE

ACTYPE:	MOVE A,B	;CTYPE, TYPE OUT ASCII CHAR IN RH(UUO)
	JRST TYO

		;TYPE OUT DECIMAL NUMBER IN A

DPT:	IDIVI A,10.
	JUMPE A,DPT2
	HRLM B,(P)
	PUSHJ P,DPT
OCTYO2:	HLRZ B,(P)
DPT2:	MOVEI A,"0(B)
	JRST TYO

		;6TYPE ACI,[SIXBIT /WORD/]	;TYPE OUT WORD, WITH ACI INTERPRETED AS SHOWN:
		;6QRT LIKE 6TYPE BUT CHAR OUTPUT ROUTINE ADR IN QCH

6QRTB:	POPJ P,		;ACI 0 => THAT'S ALL
	MOVEI A,40	;1 END WITH SPACE
	MOVEI A,^I	;2 END WITH TAB
	JRST QCRLF	;3 END WITH CRLF
	MOVEI A,":	;4 COLON
	MOVEI A,";	;5 SEMICOLON
	MOVEI A,"'	;6 SINGLE QUOTE
L6QRTB==.-6QRTB

A6QRT:	MOVE B,(B)	;GET ARG, ONE WORD
	PUSHJ P,SIXQT	;TYPE OUT
	LDB A,[270400,,40]	;GET AC FIELD
	CAIL A,L6QRTB	;TOO BIG?
	.VALUE		;ACI FIELD OF 6TYPE UUO TOO BIG
	XCT 6QRTB(A)	;NOW FIGURE OUT WHAT TO DO NEXT (MAYBE POPJ'S OUT)
	JRST @QCH'	;WANTS A CHARACTER TYPED OUT, DO IT

INIT [SETZM QCH]

SIXQT:	JUMPE B,CPOPJ
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,@QCH
	JRST SIXQT

QCRLF:	MOVEI A,^M
	PUSHJ P,@QCH
	MOVEI A,^J
	JRST @QCH

A6TYPE:	MOVEI A,TYO
A6PRT2:	EXCH A,QCH
	PUSH P,A
	PUSHJ P,A6QRT
	POP P,QCH
	POPJ P,

UUO [DIRTYP OPNER]

		;DIRTYP OPNBLK	;OPEN OPNBLK (LH SHOULD HAVE DIRMOD) AND TYPE OUT
		;SKIPS IF .OPEN DOES

DIRMOD==0	;MODE THAT OPNBLK FOR DIRTYP SHOULD HAVE

ADIRTY:	.OPEN FDRC,(B)	;TRY OPENING FILE
	POPJ P,		;CAN'T
	MOVNI C,1	;DON'T MATCH ANYTHING (C GETS LAST CHAR TYPED OUT + 1)
ADIRT1:	.IOT FDRC,A	;GET CHAR FROM DIRECTORY OR WHATEVER
	JUMPL A,ADIRTX	;RETURN ON STANDARD EOF (AS OPPOSED TO DIRECTORY EOF)
	CAIE A,^L	;FORM FEED?
	CAIN A,^C	;CONTROL C?
	JRST ADIRTX	;YES, THAT'S ALL
	PUSHJ P,TYO	;MEETS TESTS, TYPE OUT
	MOVEI C,1(A)	;COPY CHAR + 1 INTO C
	CAIE A,^J	;EXTRA HAIR FOR LINE FEED, MAYBE STOP TYPING
	JRST ADIRT1	;BACK INTO LOOP
	.STATUS TYIC,A	;LINE FEED, CHECK TYPEIN
	TRNE A,2000	;WAITING FOR PUSHJ TO TYI?
	JRST ADIRT1	;NO (BUFFER EMPTY), COPY MORE
	.RESET TYOC,	;YES, STOP TYPEOUT
ADIRTX:	CAIE A,^J+1
	PUSHJ P,CRLF	;LAST NOT LINE FEED (OR DID .RESET), TYPE CRLF
	.CLOSE FDRC,	;EXIT, CLOSE CHANNEL
	JRST POPJ1

		;OPNER IOCH,OPNBLK	;.OPEN DIDN'T SKIP, TYPE OUT WHY AND GO TO ERRET

AOPNER:	LDB T,[270400,,40]	;PICK UP AC FIELD
	DPB T,[270400,,ERRST]	;DEPOSIT FOR .STATUS, MAY BE FDRC WHICH WOULD GET CLOBBERED BY .OPEN
	XCT ERRST	;GET CHANNEL STATUS
	PUSHJ P,ERR1	;MAKE SURE IT GETS TYPED OUT
	PUSH P,UUOH	;SAVE PC FOR POSSIBLE DEBUGGING
	SKIPE B
	PUSHJ P,TYPFIL	;TYPE OUT FILE DESCRIPTION (USES UUO'S)
	PUSHJ P,TYOSP2	;SEPARATE WITH TWO SPACES
	DIRTYP ERRO	;TYPE OUT PROBLEM
	 .VALUE		;SHOULD HAVE SKIPPED
	JRST ERRET	;THAT'S ALL

VBLK
ERRO:	DIRMOD,,(SIXBIT /ERR/)	;OPEN BLOCK FOR OPNER
	3		;=> USE ERRFN2 AS .STATUS WORD
ERRFN2:	0		;.STATUS WORD

ERRST:	.STATUS ERRFN2	;AC FIELD MODIFIED
PBLK

SWDFCK DATMSW==0,[	;;DATIME DATE/TIME PRINTING ROUTINES

SPD==24.*3600.	;# SECONDS PER DAY (FITS IN 17. BITS)
DOWBP==320300	;BP TO DAY OF WEEK FIELD IN SECOND WORD .RLPDT

		;PRINT TIME AND DATE

NOWPRT:	.RLPDT A,	;GET TIME AND DATE
	JUMPL A,CPOPJ	;RETURN IF NOT KNOWN
	MOVE E,B	;GET YEAR AND FLAGS IN E
	IDIVI A,SPD	;SAPARATE DATE FROM TIME
	PUSH P,A	;SAVE LOCALIZED DAY OF YEAR
	IDIVI B,SPD/2
	PUSH P,[SIXBIT / AM,   PM,/](B)
	MOVE A,C	;# SECS SINCE TWELVE
	CAIGE A,3600.
	ADDI A,SPD/2	;BEFORE ONE, MAKE PRINT TWELVE INSTEAD
	PUSHJ P,HMSPRT	;H:MM:SS
	POP P,B		;AM OR PM (IN SIXBIT, WITH LEADING SPACE)
	PUSHJ P,SIXPT
	PUSHJ P,SPACE2	;TWO SPACES TO SEPARATE FROM DATE
	LDB A,[DOWBP,,E]	;GET DAY OF WEEK
	MOVE B,DOWTB(A)	;GET SIXBIT
	PUSHJ P,SIXPT	;PRINT DAY OF WEEK, LESS "DAY"
	MOVEI B,[ASCIZ /DAY, /]
	PUSHJ P,APRT
	POP P,C		;LOCALIZED DAY OF YEAR
	MOVEI B,0
	CAML C,MVALTB+1(B)
	AOJA B,.-1	;SEARCH FOR MONTH
	SUB C,MVALTB(B)	;GET # DAYS SINCE BEGINNING OF MONTH
	MOVE B,MNAMTB(B)	;NAME OF MONTH, IN SIXBIT
	PUSHJ P,SIXPT	;PRINT MONTH
	PUSHJ P,PSPACE
	MOVEI A,1(C)	;DAY OF MONTH
	PUSHJ P,PDPT	;(IN DECIMAL, OF COURSE)
	PUSHJ P,PCOMMA
	MOVEI A,(E)
	JRST PDPT	;PRINT YEAR AND RETURN

HMSPRT:	IDIVI A,3600.	;PRINT H:MM:SS
	HRLM B,(P)
	PUSHJ P,PDPT	;HOURS
	HLRZ B,(P)
	IDIVI B,60.	;SEPARATE MINUTES FROM SECONDS
	PUSHJ P,HMSPR2	;PRINT MINUTES
	MOVE B,C
HMSPR2:	PUSHJ P,PCOLON	;PRINT SECONDS
	MOVE A,B
	IDIVI A,10.
	PUSHJ P,PDGPTA
	JRST PDGPTB

		;SIXBIT TABLE OF NAMES OF DAYS OF WEEK, LESS "DAY"

DOWTB:	IRPS D,,[SUN MON TUES
WEDNES THURS FRI SATUR]
	SIXBIT /D/
	TERMIN
IFN .-DOWTB-7,PRINTB DOWTB LOSES.

		;SIXBIT TABLE OF NAMES OF MONTHS

MNAMTB:	IRPS M,,[JAN FEB MAR APR
MAY JUN JUL AUG
SEP OCT NOV DEC]
	SIXBIT /M/
	TERMIN
IFN .-MNAMTB-12.,PRINTB MNAMTB LOSES.

		;TABLE OF NUMBER OF DAYS IN LEAP YEAR BEFORE BEG OF MONTH

FOO==0

MVALTB:	IRPS L,,[31. 29. 31. 30.
31. 30. 31. 31.
30. 31. 30. 31.]
	FOO
	FOO==FOO+L
	TERMIN
	SETZ-1		;EXTRA WORD AT END OF TABLE TO MAKE MONTH LOOKUP WORK
IFN .-MVALTB-13.,PRINTB MVALTB LOSES.

]

SWDFCK PRTSW==0,[	;PRINTING ROUTINES

		;OPEN ROUTINE ELSEWHERE (AT PRTOPN)

PRTCLS:	IFDEF PGHDRP,SETZM PGHDRP
	SKIPE LINEPS	;CLOSE THE PRINTING FILE: IF NOT AT BEGINNING OF LINE,
	PUSHJ P,PCRLF	;THEN OUTPUT CRLF
	SKIPE LINENR	;IF NOT AT BEGINNING OF PAGE,
	PUSHJ P,PRTFF	;THEN OUTPUT A FORM FEED
	MOVEI A,^C	;NOW GET EOFCH IN A
	MOVSI B,760000	;SET UP WORD FOR TDNE TO SEE IF WORD FULL
	PUSHJ P,PCH	;DEPOSIT AT LEAST ONE EOF CHARACTER
	TDNE B,PCHBP	;WORD FULL?
	JRST .-2	;NOT YET
	PUSHJ P,PPBUF	;OUTPUT THE BUFFER
	CLEARF OPNFPF	;CLEAR FLAG, INDICATE CHANNEL CLOSED
	.CLOSE PRTOC,
	PUSHJ P,LSWDEL	;DELETE ENTRY
	 PUSHJ P,PRTCLS
	MOVE A,PAGENR	;GET PAGE NUMBER
	CAIGE A,5
	JRST PRTCL2	;NOT ENOUGH TO WORRY ABOUT
	TYPE [ASCIZ /OUTPUT IS /]
	PUSHJ P,DPT
	TYPCR [ASCIZ / PAGES LONG./]
PRTCL2:	SETZM LINEPS	;CLEAR OUT LINE POSITION
	SETZM LINENR	;ALSO LINE NUMBER
	SETZM PAGENR	;ALSO PAGE NUMBER (# PAGES COMPLETELY OUTPUT SO FAR)
	POPJ P,

VBLK
IFNDEF LPP,LPP==59.		;NUMBER OF LINES PRINTED PER PAGE
IFNDEF CPL,CPL==119.		;# CHARS PER LINE (LEAVE ONE BLANK FOR BADCOL)
IFNDEF PRTBFL,PRTBFL==40	;LENGTH OF PRINTER BUFFER
PRTBUF:	BLOCK PRTBFL		;BUFFER FOR PRINTING DEVICE
PBLK

		;PRINT CHARACTER IN A

PCH:	CAIGE A,40
	JRST PCHNP	;NOT PRINTING CHARACTER
PCH2:	AOS LINEPS'	;INCREMENT LINE POSITION
PCH1:	IDPB A,PCHBP'	;STORE CHARACTER IN PRINT BUFFER
	SOSLE PRTCC'	;DECREMENT CHARACTER COUNT, SKIP IF EXHAUSTED
	POPJ P,
		;DROPS THROUGH
		;OUTPUT THE BUFFER

PPBUF:	PUSH P,A	;SAVE A
	MOVE A,PCHBP	;GET FINAL POINTER
	HRLOI A,-PRTBUF(A)
	EQVI A,PRTBUF	;CONVERT TO AOBJN POINTER TO BUFFER
	.IOT PRTOC,A	;OUTPUT THE BUFFER
PPBUF2:	MOVE A,[010700,,PRTBUF-1]
	MOVEM A,PCHBP	;INITIALIZE PCHBP
	MOVEI A,5*PRTBFL
	MOVEM A,PRTCC	;INITIALIZE CHARACTER COUNT
	POP P,A
	POPJ P,

		;ROUTINES FOR PROCESSING SPECIAL CHARACTERS AT PCH

PCHNP:	CAIL A,^H	;HERE FROM PCH IF CHAR IS NON-PRINTING (CONTROL CHAR)
	CAILE A,^M
	AOSA LINEPS	;NOT FORMAT EFFECTOR, INCREMENT OVER PRESUMED UPARROW TO BE PRINTED
	JRST @PCHTB-^H(A)	;FORMAT EFFECTOR, DISPATCH ON IT
	CAIE A,33	;NOT FORMAT EFFECTOR; ALTMODE?
	AOS LINEPS	;NOT ALTMODE, INCREMENT AGAIN, CHAR PRINTS AS TWO
	JRST PCH1	;BACK TO PRINT CHAR

PCHTB:	PCHBS	;^H BACKSPACE (JRST@'D FROM PCH)
	PCHTAB	;^I TAB
	PCHLF	;^J LINE FEED
	PCH2	;^K
	PCHFF	;^L FORM FEED
	PCHCR	;^M CARRIAGE RETURN

PCHBS:	SOSGE LINEPS	;BACKSPACE
	SETZM LINEPS	;BEGINNING OF LINE
	JRST PCH1

PCHTAB:	MOVEI A,7	;TAB
	IORM A,LINEPS	;SET TO END OF THIS TAB GROUP
	MOVEI A,^I
	JRST PCH2	;INCREMENT TO TAB STOP AND FALL IN

PCHLF:	PUSHJ P,PCH1	;LINE FEED, PRINT IT
	AOS A,LINENR'	;INCREMENT LINE NUMBER
	CAIL A,LPP
	PUSHJ P,PCHLF2	;NEW PAGE, FORM FEED TO IT
	MOVEI A,^J	;CLOBBER A TO LINE FEED AGAIN SO AS TO APPEAR NONDESTRUCTIVE
	POPJ P,

IFNDEF PGHDRP,PCHLF2==PRTFF
IFDEF PGHDRP,[

PCHLF2:	PUSHJ P,PRTFF	;HERE FROM PCHLF, SKIP TO NEXT PAGE
	SKIPN PGHDRP	;CHECK PAGE HEADER POINTER
	POPJ P,		;ZERO => THAT'S ALL
	PUSH P,B	;NON-ZERO
	MOVE B,PGHDRP	;GET PAGE HEADER POINTER
	PUSHJ P,APRT	;PRINT PAGE HEADER
	POP P,B
	POPJ P,
]

PCHFF:	SETZM LINENR	;FORM FEED
	AOS PAGENR'	;INCREMENT COUNT OF # PAGES PRINTED
	JRST PCH1

PCHCR:	SETZM LINEPS	;CARRIAGE RETURN, CLEAR OUT LINE POSITION
	JRST PCH1

PRTFF:	MOVEI A,^L	;PRINT A FORM FEED
	JRST PCH

	;RANDOM PRINTING ROUTINES

PCOLON:	SKIPA A,[":]	;PRINT A COLON
PCOMMA:	MOVEI A,",	;PRINT A COMMA
	JRST PCH

SPACE6:	PUSH P,CPCH	;6 SPACES
SPACE5:	PUSH P,[SPACE2]	;5 SPACES, NORMAL SPACING TO NON-NULL PART OF LINE
SPACE3:	PUSH P,CPCH	;3 SPACES
SPACE2:	PUSH P,CPCH	;2 SPACES
PSPACE:	MOVEI A,40	;PRINT ONE SPACE
CPCH:	JRST PCH	;CPCH CONTAINA PCH IN RIGHT HALF

PTAB:	MOVEI A,^I	;TAB
	JRST PCH

P4CRLF:	PUSHJ P,.+1	;PRINT FOUR CARRIAGE RETURNS
P2CRLF:	PUSHJ P,.+1	;PRINT TWO CARRIAGE RETURNS
PCRLF:	MOVEI A,^M	;CRLF (BUT SEE ENDLIN, BEGLIN FOR NORMAL ROUTINES CALLED)
	PUSHJ P,PCH
	MOVEI A,^J
	JRST PCH

PDGPTA:	ADDI A,"0	;DIGIT IN A
	JRST PCH

PDGPTC:	MOVEI A,"0(C)	;DIGIT IN C
	JRST PCH

		;PRINT SPACES AND TABS (AT LEAST ONE CHAR)
		;UNTIL LINE POSITION IS AT LEAST C(B)

ALIGN0:	CAMG B,LINEPS	;ENTRY FOR NO MINIMUM NUMBER OF SPACES
	POPJ P,
ALIGN:	MOVE A,LINEPS	;MAIN ENTRY
	TRZ A,7
	SUBM B,A
	IDIVI A,8	;# TABS IN A, # SPACES IN B
	JUMPLE A,ALIGN2	;JUMP IF ZERO OR FEWER TABS
	PUSH P,B	;SAVE NUMBER OF SPACES
	MOVE B,A	;NUMBER OF TABS, PUT WHERE WON'T GET CLOBBERED
	MOVEI A,^I	;TAB
	PUSHJ P,ALIGNX	;PRINT RIGHT NUMBER OF TABS
	POP P,B		;GET BACK NUMBER OF SPACES
	JUMPLE B,CPOPJ	;RETURN IF NO SPACES NECESSARY
ALIGN2:	MOVEI A,40	;NOW FOR SPACES
ALIGNX:	PUSHJ P,PCH	;LITTLE ROUTINE TO PRINT C(A) NUMBER OF TIMES SPECIFIED BY B
	SOJG B,.-1	;PRINTS AT LEAST ONE
	POPJ P,

		;PRINT SIXBIT WORD IN B

SIXPT:	JUMPE B,CPOPJ	;RETURN WHEN DONE (IF WORD IS NULL, DON'T TYPE ANYTHING)
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,PCH
	JRST SIXPT

UUO PRT

		;PRINT ASCIZ STRING POINTED TO BY B

APRT:	HRLI B,440700
APRTL:	ILDB A,B
	JUMPE A,CPOPJ
	PUSHJ P,PCH
	JRST APRTL

		;FILE DESCRIPTION READING/OPENING ROUTINES

		;READ DESCRIPTION FOR, AND OPEN, PRINTING FILE

PRTOPN:	PUSHJ P,PRDFIN	;BLT IN DEFAULT
	PUSHJ P,RFD	;GET FILE DESCRIPTION
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	.OPEN PRTOC,DNAM	;TRY OPENING FILE
	OPNER PRTOC,DNAM
	PUSHJ P,PRDFOT	;BLT DNAM BLOCK OUT AS NEW DEFAULT
	SETF OPNFPF	;INDICATE PRINTING CHANNEL OPEN
	PUSHJ P,LSWSET
	 PUSHJ P,PRTCLS
	PUSHJ P,PRTCL2	;CLOBBER PAGE/LINE POSITION VARIABLES
	PUSHJ P,PPBUF2	;INCREMENT P AND FALL INTO ROUTINE TO RE-INITIALIZE BUFFER VARIABLES

VBLK
DFPFD:	3,,(SIXBIT /TPL/)	;DEFAULT NAMES (AND MODE) FOR PRTOPN
	SIXBIT /WALL/
	SIXBIT /PAPER/
DFPSNM:	0		;SET AT BEG TO INITIAL SYSTEM NAME
INIT [.SUSET [.RSNAM,,DFPSNM]]	;INITIALIZATION
PBLK

PRDFIN:	MOVE T,[DFPFD,,DNAM]	;BLT DFPFD INTO DNAM, ETC
	BLT T,SNAM
	POPJ P,

PRDFOT:	MOVS T,[DFPFD,,DNAM]	;BLT DNAM OUT INTO DFPFD
	BLT T,DFPSNM
	POPJ P,

SIXPTT:	PUSHJ P,SIXPT
	JRST PTAB

PDPT:	IDIVI A,10.	;PRINT DECIMAL NUMBER IN A
	JUMPE A,PDGPTB
	HRLM B,(P)
	PUSHJ P,PDPT
OCTPT2:	HLRZ B,(P)
PDGPTB:	MOVEI A,"0(B)
	JRST PCH

	CMD TPLOFF,TPLOFF,,[TELL SYSTEM JOB TO QUIT TPLING.]

TPLOFF:	SKIPG TPLFN1	;CHECK TO SEE IF KNOW WHERE TPL FNAM1 IS IN SYSTEM
	JRST TPLOF3	;AW, SHUCKS
	.SUSET [.RUNAM,,C]	;GET UNAME, CLOBBER OWN PRINTING WITHOUT COMMENT
TPLOF1:	HRLZ A,TPLFN1'	;GET LOC IN SYSTEM OF TPL NAME 1 (UNAME)
	HRRI A,B
	.GETLOC A,	;WHO'S BEING TPL'D NOW?
	CAME B,C
	JRST TPLOF2	;SOMEBODY ELSE
TPLOF3:	MOVEI A,2	;REALLY WANTS THIS GUY CLOBBERED
	.SUPSET A,	;ZAP!
	POPJ P,

TPLOF4:	PUSHJ P,CRLF
	JRST TPLOF1

TPLOF5:	TYPCR [ASCIZ /TPL ALREADY OFF./]
	POPJ P,

TPLOF2:	JUMPE B,TPLOF5	;JUMP ON SYSTEM JOB IDLE
	TYPE [ASCIZ /DO YOU REALLY WANT TO FLUSH /]	;UNAMES DIFFER, ASK USER
	MOVE C,B	;IF YES THEN TREAT TPLFN1 LIKE NEW UNAME
	PUSHJ P,SIXTYO	;TYPE OUT UNAME
	TYPE [ASCIZ /'S LISTING?   /]
	PUSHJ P,TYI	;GET ANSWER
	CAIN A,"Y
	JRST TPLOF4	;HE SAYS YES, LOOP WITH THIS UNAME
	TESTF N,ALTF\CRF	;NO, DON'T BOTHER COMMENTING IF AT END OF COMMAND
	TYPE [ASCIZ / TPLON./]
	JRST CRLF	;END WITH CR EITHER WAY

INIT [	MOVE A,[SQUOZE 0,TPLFN2]
	.EVAL A,
	MOVSI A,SIGN
	MOVEM A,TPLFN1]	;TPLOFF INITIALIZATION

]		;END PRTSW CONDITIONAL

SWDFCK REDSW==0,[	;ASCII FILE INPUT ROUTINES

		;PUSHJ P,RCH	;GET CHAR FROM FILE IN A

RCH:	ILDB A,RCHBP'	;GET CHAR
	CAIE A,^C	;EOF?
	POPJ P,		;NO
	PUSHJ P,REDRLD	;EOF, TRY RELOADING
	HALT		;DIDN'T SKIP => REAL EOF (WANT TO INSERT SOMETHING BETTER HERE)
	JRST RCH	;TRY NEW CHAR

		;PUSHJ P,REDRLD
		;TRY RELOADING THE BUFFER
		;SKIPS UNLESS RCHBP INDICATES REAL EOF
		  ;IN WHICH CASE CHANNEL HAS BEEN CLOSED

REDRLD:	HRRZ A,RCHBP	;GET POINTER
	CAIE A,REDBUF+REDBFL	;POINTS TO END OF BUFFER?
	JRST REDCLS		;NO => REAL EOF
	MOVE A,[440700,,REDBUF]	;INITIAL RCHBP
	MOVEM A,RCHBP	;INITIALIZE RCHBP
	HRLI A,-REDBFL	;NOW CONVERT TO BLOCK .IOT POINTER
	.IOT REDIC,A	;READ BLOCK
	HRLI A,^C_<18.-7>
	HLLM A,(A)	;SET UP EOF INDICATION AT END OF STUFF LOADED (MUST NOT BE HLLZM)
	JRST POPJ1	;EXIT SKIPPING, SUCCESS

		;PUSHJ P,REDCLS	;CLOSE REDIC

REDCLS:	.CLOSE REDIC,	;DO IT
	CLEARF OPNFRF	;SIGNAL IT
	PUSHJ P,LSWDEL
	 PUSHJ P,REDCLS
REDCL2:	MOVE A,[70700,,REDBUF+REDBFL]
	MOVEM A,RCHBP	;STORE POINTER TO EOF
	POPJ P,

REDOPN:	PUSHJ P,REDCLS
	PUSHJ P,RDINCR
	 POPJ P,
	.OPEN REDIC,DFZFD
	OPNER REDIC,DFZFD
	PUSHJ P,LSWSET
	 PUSHJ P,REDCLS
	SETF OPNFRF
	MOVE A,[REDIC,,RCHSTB]
	JRST REDOP2

VBLK
MAXDEF REDBFL==40	;LENGTH OF BUFFER
REDBUF:	BLOCK REDBFL
	^C_<36.-7>+^C	;EOF INDICATION AT END OF BUFFER
PBLK
]		;END REDSW CONSITIONAL

;;FILE IO ROUTINES, RFD, ETC.

		;READ INPUT FILE DESCRIPTION STRING

RIFDS:	MOVEI A,IFILES	;SET UP POINTERS INTO DESCRIPTION AREA
	MOVEM A,IFILET
	MOVEM A,IFILEB
	PUSHJ P,ZFDFIN	;BLT IN DEFAULT
	MOVEI T,6
	HRLM T,DNAM	;SET MODE FOR .OPEN
RFDIP2:	PUSHJ P,RFDCCM	;GET NEXT DESCRIPTION
	PUSHJ P,DNININ
	ADDI B,4	;INCREMENT TO NEXT ENTRY
	MOVEM B,IFILET	;UPDATE POINTER
	TESTF N,CRF\ALTF	;END OF STRING?
	JRST RFDIP2	;BACK FOR MORE DESCRIPTIONS
	POPJ P,

		;OPEN NEXT INPUT FILE OR DON'T SKIP

OPNRD:	PUSHJ P,RDINCR	;INCREMENT POINTERS TO NEXT
	JRST RDCLS	;NO SKIP => NO MORE
OPNRD1:	.OPEN UTYIC,DFZFD
	OPNER UTYIC,DFZFD
	SETF OPNFIF
	PUSHJ P,LSWSET
	 PUSHJ P,RDCLS
	MOVE A,[UTYIC,,RCHSTB]
REDOP2:	.RCHST A,	;GET WHAT THE SYSTEM THINKS IS IMPORTANT ABOUT THIS FILE
	MOVSI A,770000
	TDNE A,RCHSTB
	MOVSS RCHSTB	;LH SIGNIFICANT, USE IT AS DEV NAME TO PRINT
	JRST POPJ1

RDINCR:	MOVE B,IFILEB'	;GET POINTER TO LOWEST DESCRIPTION NOT PROCESSED
	CAML B,IFILET
	POPJ P,		;NO MORE DESCRIPTIONS
	PUSHJ P,DNINOT
	ADDI B,4
	MOVEM B,IFILEB
	.SUSET [.SSNAM,,DFZSNM]
	JRST POPJ1

		;INPUT .IOT ROUTINES

GWRDA:	HRROI T,A	;ENTRY TO READ WORD INTO A
UTYI:	.IOT UTYIC,T	;ENTRY TO DO BLOCK .IOT
	JUMPGE T,CPOPJ	;RETURN IF OK
	ERR [ASCIZ /UNEXPECTED END-OF-FILE/]

		;CLOSE THE READ CHANNEL

RDCLS:	.CLOSE UTYIC,
	CLEARF OPNFIF
	PUSHJ P,LSWDEL
	 PUSHJ P,RDCLS
	POPJ P,

VBLK
IFNDEF NIFILS,NIFILS==20.	;MAX NUMBER OF FILES SEPARABLE BY COMMAS
IFILES:	BLOCK 4*NIFILS

DFZFD:	6,,(SIXBIT /DSK/)	;DEFAULT INPUT FILE DESCRIPTION, WITH MODE
	SIXBIT /@/
	SIXBIT /@/
DFZSNM:	0		;SYSTEM NAME

INIT [.SUSET [.RSNAM,,DFZSNM]]	;GET INITIAL SYSTEM NAME WHEN PROG STARTED UP

RCHSTB:	BLOCK 10.	;READ INTO BY .RCHST BY OPNRD
PBLK

ZFDFIN:	MOVE T,[DFZFD,,DNAM]	;BLT DFZFD INTO DNAM, ETC.
	BLT T,SNAM
	POPJ P,

DNINOT:	MOVS A,IFILEB
	HRRI A,DFZFD
	BLT A,DFZSNM
	POPJ P,

DNININ:	MOVE B,IFILET'	;LEAVES IFILET IN B
	MOVSI A,DNAM
	HRR A,B
	BLT A,3(B)
	POPJ P,

		;OPEN FOR WRITING

OPNWR:	MOVEI T,7
	HRLM T,DNAM
	.OPEN UTYOC,DNAM
	OPNER UTYOC,DNAM
	PUSHJ P,LSWSET
	 PUSHJ P,WRCLS
	TMODF OA,OPNFOF
POPJ1:	AOS (P)
CPOPJ:	POPJ P,

		;OUTPUT .IOT ROUTINES

WRMIN1:	HRROI T,[-1]	;ENTRY TO OUTPUT MINUS 1
UTYO:	.IOT UTYOC,T	;ENTRY TO DO BLOCK .IOT
	POPJ P,

WRCLS:	.CLOSE UTYOC,	;CLOSE THE OUTPUT FILE
	CLEARF OPNFOF
	PUSHJ P,LSWDEL
	 PUSHJ P,WRCLS
	POPJ P,

		;FILE DESCRIPTION READING ROUTINES, CLOBBER AC'S

RFD:	MOVEI R,RFDC1	;PUSHJ P,RFD	;READ SINGLE DESCRIPTION INTO DNAM, ETC.
RFDC:	CLEARF TMPF1	;CLEAR OUT "FILE NAME HAS BEEN SPECIFIED" FLAG
	JRST GTSYL	;FALL IN

RFDC1:	CAIN A,":
	JRST RFDCOL	;DEVICE
	CAIN A,";
	JRST RFDSEM	;SYSTEM NAME
	CAILE A,40
	JRST GTSYL2	;USE IT AS PART OF NAME
	CAIN A,^Q
	JRST RFDCQ	;PROBABLY QUOTE NEXT CHARACTER
	TESTF N,ALTF\CRF
	PUSH P,CGTSYL	;NOT TERMINATOR, CAUSE LOOP TO GETSYL
RFDTRM:	JUMPE C,CGTSYL	;JUMP IF NAME IS NULL
	EXCH C,FNAM2	;LOGICAL SPACE
	TMODF OE,TMPF1	;IS THIS FIRST NAME SPECIFIED?
	MOVEM C,FNAM1	;NO, CLOBBER FNAM1 TOO
CGTSYL:	POPJ P,GTSYL

RFDCOL:	TLNE C,-1
	HLRM C,DNAM
	JRST GTSYL

RFDSEM:	JUMPE C,GTSYL
	MOVEM C,SNAM
	JRST GTSYL

RFDCQ:	PUSHJ P,RCHA
	TESTF E,ALTF\CRF
	JRST RFDTRM	;DON'T LET TERMINATOR BE QUOTED
	JRST GTSYL2

RFDCCM:	JSP R,RFDC	;VERSION OF RFD TO STOP ON COMMA TOO
	CAIN A,",
	JRST RFDTRM
	JRST RFDC1

VBLK
DNAM:	0	;DEVICE NAME
FNAM1:	0	;FILE NAME 1
FNAM2:	0	;FILE NAME 2
SNAM:	0	;SYSTEM NAME
PBLK

		;TYPE OUT FILE DESCRIPTION POINTED TO BY B

IFN PRTSW,PRTFIL:	SKIPA A,[PCH]	;ENTRY TO PRINT INSTEAD OF TYPING
TYPFIL:	MOVEI A,TYO	;ENTRY TO TYPE
	MOVEM A,QCH
	HRLZ T,(B)	;GET DEVICE NAME
	CAMN T,[SIXBIT /DSK/]
	JRST QRTFL2	;DON'T TYPE OUT DSK
	PUSH P,T	;PUT DEVICE NAME ON PDL WHERE UUO'S CAN GET TO IT
	6QRT 4,(P)	;TYPE OUT DEVICE NAME
	POP P,T
	CAME T,[SIXBIT /LPT/]
	CAMN T,[SIXBIT /TPL/]
	JRST QRTFL3	;DON'T TYPE OUT SYSTEM NAME OF PRINTER
QRTFL2:	SKIPE 3(B)	;DON'T TYPE OUT NULL SYSTEM NAME
	6QRT 5,3(B)	;(THIS MAY GET SKIPPED OVER) TYPE OUT SYSTEM NAME
QRTFL3:	6QRT 1,1(B)	;FNAM1
	6QRT 2(B)	;FNAM2
	POPJ P,

		;LISTF COMMAND

LISTF:	MOVE A,DFZFD	;GET DEFAULT ZUSERS DEVICE NAME
	HRLI A,DIRMOD	;SET TO DIRMOD
	MOVEM A,DNAM	;STORE AS DEFAULT DNAM
	MOVE A,DFZSNM	;GET ZUSERS SYSTEM NAME
	MOVEM A,SNAM	;STORE AS DEFAULT SYSTEM NAME
	PUSHJ P,RFD	;GET FILE DESCRIPTION
	MOVEI D,DNAM
	PUSH D,[SIXBIT /.FILE./]
	PUSH D,[SIXBIT /(DIR)/]
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	PUSHJ P,FORMF	;CLEAR SCREEN ON DISPLAY CONSOLE
	DIRTYP DNAM	;TYPE IT OUT
	OPNER FDRC,DNAM
	MOVE A,DNAM	;NOW STORE BACK NEW DEFAULT ZUSERS NAMES
	HRRM A,DFZFD
	MOVE A,SNAM
	MOVEM A,DFZSNM
	POPJ P,

		;FDELE COMMAND, DELETE FILES (SEPARATED BY COMMAS)

FDELE:	PUSHJ P,RIFDS	;GET LIST
FDELE1:	PUSHJ P,RDINCR
	POPJ P,		;THAT'S ALL
	MOVS C,[A,,DFZFD]
	BLT C,C
	MOVEI D,0	;FOR DELETE
	.FDELE A
	OPNER DFZFD
	JRST FDELE1

		;UUO HANDLER

UUOLST [DEFINE UUOIRP A
IRPS UUO,,],A
TERMIN
TERMIN

UUOIRP NUUOS==.IRPCNT+1	;COUNT UUOS

UUOHI==40		;ONE MORE THAN HIGHEST UUO OP CODE USED
UUOMIN==UUOHI-NUUOS	;LOWEST UUO OP CODE USED
UUOIRP UUO=<UUOMIN+.IRPCNT>_33	;DEFINE UUOS

VBLK
UUOH:	0
	INSIRP PUSH P,[A B C]	;UUOS DON'T CLOBBER ANY AC'S, HELP THE UUO DEPENDENT ROUTINES BY SAVING SOME
	LDB A,[331100,,40]	;PICK UP OP CODE
	CAIL A,UUOMIN
	CAILE A,UUOHI
ILUUO:	HALT		;ILLEGAL UUO EXECUTED
	HRRZ B,40	;GET EFFECTIVE ADDRESS FOR ROUTINE
	LDB C,[270400,,40]	;GET AC FIELD
	PUSHJ P,@UUODTB-UUOMIN(A)	;DISPATCH ON OP CODE
	JRST .+2
	AOS UUOH	;ROUTINE SKIPPED, INCREMENT RETURN POINT TO MAKE UUO SKIP
	INSIRP POP P,[C B A]	;RESTORE ACS SAVED
	JRST 2,@UUOH
PBLK

UUODTB:	UUOIRP A!UUO	;UUO DISPATCH TABLE

SWDEF LLSPDL==10	;LENGTH OF LSW PDL
ILSWP:	-LLSPDL,,LSWPDL-1	;WHAT LSWP INITIALIZED TO
VBLK
LSWP:	-LLSPDL,,LSWPDL-1

LSWPDL:	BLOCK LLSPDL

LSWTMP:	0		;TEMP; CONTAINS INSTRUCTION FROM PDL TO BE EXECUTED
PBLK

INIT [MOVE A,ILSWP
	MOVEM A,LSWP]

LSWSET:	EXCH D,LSWP
	PUSH D,@(P)
	EXCH D,LSWP
	JRST POPJ1

LSWONE:	PUSHJ P,LSWDLF
	JRST POPJ1
	XCT LSWTMP
	JRST POPJ1
	JRST POPJ1

LSWDEL:	PUSHJ P,LSWDLF
	JRST POPJ1
	JRST POPJ1

LSWDLF:	MOVEM A,LSWTMP
	MOVE A,@-1(P)
	PUSH P,D
	MOVE D,LSWP
	CAME A,(D)
	JRST LSWDF2
	POP D,(D)
	MOVEM D,LSWP	;STORE BACK MODIFIED POINTER
LSWDF9:	AOS -1(P)	;CAUSE RETURN TO SKIP
LSWDF8:	EXCH A,LSWTMP	;RESTORE A
	POP P,D
	POPJ P,

LSWDF3:	POP D,(D)
LSWDF2:	CAMN D,ILSWP
	JRST LSWDF8	;PDL EMPTY
	CAME A,-1(D)
	JRST LSWDF3
	MOVSI A,(JFCL)	;FOUND IT
	EXCH A,-1(D)
	JRST LSWDF9

LSWCLR:	MOVE A,LSWP
	CAMN A,ILSWP
	POPJ P,		;ALL EMPTY
	POP A,LSWTMP
	MOVEM A,LSWP	;STORE BACK UPDATED POINTER
	XCT LSWTMP
	JFCL		;ALLOW SKIP
	JRST LSWCLR

;;MAIN ROUTINES

VERSION:	.FNAM2

BEG:	MOVEI FF,0	;INITIALIZE FLAGS
	MOVE P,[-LPDL,,PDL]
	PUSHJ P,TYINIT
	PUSHJ P,FORMF
	MOVE B,[SIXBIT /SNOOP./]
	PUSHJ P,SIXTYO
	MOVE B,VERSION
	PUSHJ P,SIXTYO
	INITM		;DUMP OUT INITIALIZATION CODING ACCUMULATED BY INIT MACRO
EXPUNG INITM
	PUSHJ P,CRLF	;END TYPEOUT WITH CRLF NOW, MAYBE ASTERISK LATER
ERRET:	MOVE P,[-LPDL,,PDL]	;RETURN POINT FROM ERRORS, RE-INITIALIZE STUFF
	SETF ALTF\CRF
	SETZM RTYIP
	CLEARF UNRCHA
MNLUP:	PUSHJ P,LSWCLR	;FLUSH ANY REMAINING ERROR CONTINGENCIES
	PUSHJ P,GCMD	;GET AND LOOK UP COMMAND
	PUSHJ P,@DTB(B)	;PROCESS COMMAND
	JRST MNLUP	;BACK FOR NEXT

		;KILL COMMAND, WIPE OUT SELF

ALTX:	.LOGOUT		;JUST IN CASE
	.VALUE [ASCIZ /./]
	POPJ P,

		;NONEXISTENT COMMAND, GIVE ERROR MESSAGE

CMDERR:	PUSHJ P,ERR1
	MOVE B,C	;GET SIXBIT
	PUSHJ P,SIXTYO	;TYPE OUT GUILTY NAME
	PUSHJ P,SPACE
	ERR @BTB+NCMDS

	CMD FD,LISTF,,PRINT FILE DIRECTORY OF DEVICE.
	CMD FDELE,FDELE,,FILES  DELETE FILES.
	CMD HELP,DOCUMT,,DOCUMENT SPECIFIED COMMANDS.
	CMD KILL,ALTX,,VALRET AN $^X.
	CMD LISTC,LISTC,,LIST COMMANDS.
	CMD LISTF,LISTF,,PRINT FILE DIRECTORY OF DEVICE.

BTB:	CMBLBM		;BLURB TABLE
NCMDS==.-BTB	;# COMMANDS
	[ASCIZ /IS NOT A COMMAND./]	;FOR DOCUMT ON BAD ARGUMENT

NMTB:	CMDNMM		;TABLE OF COMMAND NAMES (IN SIXBIT)
IFN .-NMTB-NCMDS,PRINTB NMTB LOSES.;	;PROBABLY A COMMAND MORE THAN SIX CHARACTERS LONG

DTB:	CMDSPM		;DISPATCH TABLE
IFN .-DTB-NCMDS,PRINTB DTB LOSES.;	;????
	CMDERR		;NO SUCH COMMAND

EXPUNGE CMDNMM,CMDSPM,CMBLBM

PURIFY::		;START UP HERE FROM DDT BEFORE ACTUALLY RUNNING PROG
CSRT:	MOVEI E,NCMDS-1
CSRT1:	MOVSI D,-LSTCPL
	SETZB B,C
	JRST CSRT5
CSRT2:	MOVEI C,(D)
CSRT3:	MOVE A,NMTB(B)
	CAMG A,NMTB(C)
	JRST CSRT4
	EXCH A,NMTB(C)
	MOVEM A,NMTB(B)
	MOVE A,DTB(B)
	EXCH A,DTB(C)
	MOVEM A,DTB(B)
	MOVE A,BTB(B)
	EXCH A,BTB(C)
	MOVEM A,BTB(B)
CSRT4:	MOVE B,C
CSRT5:	ADDI C,LSTCPL
	CAIGE C,NCMDS
	JRST CSRT3
	AOBJN D,CSRT2
	SOJG E,CSRT1

	MOVE 0,[1,,2]
	MOVEI 1,0
	BLT 0,40
	MOVEI 0,0
	.VALUE [ASCIZ /:SORTED/]
	.VALUE

		;JSP R,GTSYL OR SOMETHING SIMILAR
		;ROUTINE IS FOR INSTRUCTIONS RATHER THAN FUNCTION, ALL TAGS ACCESSIBLE TO CALLING ROUTINE
		;BASIC FUNCTION IS TO LOAD C WITH SIXBIT, STOPPING WHENEVER CALLING ROUTINE WANTS TO

GTSYL:	MOVEI C,0	;CLEAR OUT SIXBIT
	MOVE B,[440600,,C]	;SET UP BYTE POINTER TO SIXBIT
	JRST GTSYL1	;FALL IN, GET FIRST CHAR

GTSYL2:	SUBI A,40	;FREQUENTLY HERE FROM CALLING ROUTINE TO USE CHAR AS SIXBIT
	TLNE B,770000	;ROOM?
	IDPB A,B	;YES, DEPOSIT CHAR
GTSYL1:	PUSHJ P,RCHA	;GET CHAR
	CAIL A,140
	SUBI A,40	;CONVERT LOWER CASE TO UPPER
	JRST (R)	;BACK TO CALLING ROUTINE

		;GET SIXBIT NAME OF "COMMAND" USING TERMINATOR CONVENTIONS OF GCMD
		;CALL WITH PUSHJ P,

GETNAM:	JSP R,GTSYL
	CAIL A,"A
	CAILE A,"Z
	JRST .+2
	JRST GTSYL2	;LETTER
	CAIL A,"0
	CAILE A,"9
	POPJ P,		;NOT ALPHAMERIC
	JRST GTSYL2	;DIGIT

		;GET AND DECIPHER COMMAND (CALLED WITH PUSHJ P, FROM MAIN LOOP)

GCMD:	TESTF E,CRF
	PUSHJ P,NUCMDL	;NEW COMMAND LINE
GCMD1:	CLEARF UNRCHA	;DON'T ALLOW RE-INPUT OF CR (SET AT RCHA)
	PUSHJ P,GETNAM	;GET NAME OF COMMAND
	JUMPE C,GCMD1	;KEEP TRYING UNTIL THERE'S SOMETHING THERE
	TESTF E,ALTF	;ALTMODE LAST CHAR?
	SETF UNRCHA	;YES, CAUSE ALTMODE TO BE RE-INPUT TO TERMINATE ARG OR SOMETHING
CMDLK:	MOVSI B,-NCMDS	;SET UP AOBJN POINTER TO COMMAND TABLES
	CAME C,NMTB(B)
	AOBJN B,.-1	;KEEP TRYING UNTIL FOUND OR COUNTED OUT
	POPJ P,

NUCMDL:	JRST KERCHK	;NEW COMMAND LINE, GO KERCHINK

		;LISTC, LIST COMMANDS

SWDEF LSTCPL==6		;# COMMANDS PRINTED PER LINE

LISTC:	MOVSI C,-NCMDS	;C AOBJN POINTER TO TABLES
LISTC1:	MOVEI D,LSTCPL	;COUNT DOWN TO CRLF
LISTC2:	MOVE B,NMTB(C)	;GET NAME
	PUSHJ P,SIXTYO	;TYPE OUT
	SOJLE D,LISTC3	;JUMP IF THIS LAST IN LINE
	AOBJP C,CRLF	;END WITH CRLF IF DONE
	PUSHJ P,TAB	;NOT DONE YET, TYPE TAB
	JRST LISTC2	;BACK FOR NEXT COMMAND

LISTC3:	PUSHJ P,CRLF	;THIS LAST ONE IN LINE, END WITH CRLF
	AOBJN C,LISTC1	;LOOP FOR ALL LINES
	POPJ P,

		;HELP, DOCUMENT SPECIFIED COMMANDS

DOCUMT:	CLEARF TMPF1	;GETS SET ON DESCRIPTION NOT NULL
DOCU1:	PUSHJ P,GETNAM	;GET NAME
	JUMPE C,DOCU2	;JUMP ON NO SYL
	SETF TMPF1	;SET SYL FLAG
	MOVE B,C	;GET NAME IN B
	PUSHJ P,SIXTYO
	PUSHJ P,TAB
	PUSHJ P,CMDLK	;LOOK UP
	TYPCR @BTB(B)	;TYPE OUT BLURB
DOCU2:	TESTF N,ALTF\CRF
	JRST DOCU1	;LOOP UNTIL END OF COMMAND
	TESTF N,TMPF1
	TYPCR DOCLOS	;LOSER DIDN'T TYPE IN ANY NAMES
	POPJ P,

DOCLOS:	ASCIZ /HELP DOCUMENTS SPECIFIED COMMANDS, LISTC LISTS ALL COMMANDS./]

IFE 3-.TYPE SYEVAL,SYEVAL:	;ROUTINE TO EVALUATE SYSTEM SYMBOLS
IFDEF SYEVAL,[IFE SYEVAL-.,[

	;THESE ROUTINES MUST BE AFTER EXPANSION OF INITM AT BEG,
	;SO CALLS CAN OCCUR WITHIN INIT

		;JSP B,SYEVAL
		;SQUOZE 0,<SYM>
		;<PLACE VALUE OF SYM (OR ZERO) IS TO BE STORED>
		;SQUOZE 0,<SYM2>
		;<PLACE SYM2'S VALUE IS TO BE STORED>	;AS MANY SYMS AS DESIRED

SYEVAL:	SKIPL A,(B)	;GET WHAT MAY BE NEXT SQUOZE
	TLNE A,740000	;CHECK FLAGS
	JRST (B)	;FLAGS SET => NOT REALLY SQUOZE
	.EVAL A,
	MOVEI A,0	;DIDN'T SKIP, USE ZERO
	MOVEM A,@1(B)	;STORE VALUE
	ADDI B,2	;INCREMENT TO NEXT SYM
	JRST SYEVAL

	;MOVEI B,<ADR OF LIST OF SYMS FOR SYEVAL>
	;PUSHJ P,SYEVCK	;MAKE SURE SYMS IN LIST ARE ALL DEFINED

SYEVCK:	SKIPL A,(B)
	TLNE A,740000
	POPJ P,
	SKIPN @1(B)
	ERR [ASCIZ /NEED SYSTEM SYMS./]	;MAYBE REPLACE WITH SOMETHING MORE INFORMATIVE
	ADDI B,2
	JRST SYEVCK
]

CONSTA
VBLK
VARIAB
SWDEF PATCHL==40	;LENGTH OF PATCH AREA
PATCH:
PAT:	BLOCK PATCHL
PATCHE=.-1
SWDEF LPDL==40
PDL:	BLOCK LPDL+1
SWDFCK RNDBFL==0,RNDBUF:	BLOCK RNDBFL	;RANDOM BUFFER
PBLK

DSTG:		;BEGINNING OF STORAGE DYNAMICALLY ALLOCATED

END BEG		;SHOULD BE STARTED AT PURIFY BEFORE BEING USED
