
TITLE IOTEST
RELOCA
IF1,[SWRQ==1
.INSRT JSF;DSK:STNDRD MACROS
]

FF=0
A"=1
B"=2
C=3
D=4
P"=17

IFNDEF R,R=400000	;RELOCATION IN TS MODE

TTYCHN"==4
.LIBRQ HALT,SILNT
DISAC"==A
DISCHN"==3
FLGCHN"==5

	;FLAGS

TMPF1==RHF FF,1		;TEMPORARY FLAG

BEG:	CONO 635550
	CONO PI,11577
	CONO PI,PICON+200_-TTYCHN+200_-DISCHN+200_-FLGCHN
	MOVEI FF,0	;INITIALIZE FLAGS REGISTER
	MOVE P,[-LPDL,,PDL]
	PUSHJ P,TYINIT"
	PUSHJ P,DDTINI"
	PUSHJ P,TSINIT"
	HALT
	JSP B,TSJSR"
	.SUSET R+[.RSNAM,,R+SNAM]
	JSP B,TSDONE"
	SETZM RTYIP
LUP:	PUSHJ P,CRLF	;KERCHINK
	PUSHJ P,RFD
	PUSHJ P,OPNRD	;OPEN FILE FOR READING
	PUSHJ P,COPY	;COPY FILE ONTO DISPLAY
	JRST LUP

		;READ IN CHARACTER STRING ALLOWING RUBOUTS

RTYI:	ILDB A,RTYIP'	;GET CHAR
	JUMPN A,CPOPJ	;RETURN ON NOT ZERO
	PUSH P,B	;SAVE B, WILL USE AS BYTE POINTER
	MOVE B,[010700,,RTYIBF-1]
	MOVEM B,RTYIP
RTYI1:	PUSHJ P,TYI"	;GET CHAR
	CAIN A,^C
	JRST RTYIQT	;FLUSH LINE, START AGAIN
	CAIN A,177
	JRST RTYIRB	;RUBOUT
	JUMPE A,RTYI1	;IGNORE ZERO
	IDPB A,B	;LOOKS GOOD, USE IT
	CAIE A,^M	;CARRIAGE RETURN?
	JRST RTYI1	;NO, GO BACK FOR NEXT
	MOVEI A,0	;CARRIAGE RETURN, INDICATE END OF LINE
	IDPB A,B	;MARK END OF LINE SO WILL RECYCLE IF NECESSARY
	POP P,B		;NOW RESTORE B
	JRST RTYI	;TRY AGAIN WITH NEW LINE

RTYIRB:	CAMN B,[010700,,RTYIBF-1]
	JRST RTYIRQ	;BACK TO BEGINNING OF LINE
	LDB A,B		;GET LAST CHAR
	PUSHJ P,TYO"	;TYPE IT OUT AS REMINDER
	DBP7J B,RTYI1

RTYIQT:	MOVE B,[010700,,RTYIBF-1]
RTYIRQ:	PUSHJ P,CRLF
	JRST RTYI1

IFNDEF RTYIBL,RTYIBL==20.	;LENGTH OF TYPEIN BUFFER
RTYIBF:	BLOCK RTYIBL		;TYPEIN BUFFER FOR RTYI

CRLF:	MOVEI A,^M
	PUSHJ P,TYO
	MOVEI A,^J
	JRST TYO

CPOPJ:	POPJ P,

IFNDEF LPDL,LPDL==40
PDL:	BLOCK LPDL+1

		;READ SINGLE FILE DESCRIPTION

RFD:	HRRZS DNAM
RFD0:	SETF TMPF1	;SET FLAG KEEPING TRACK OF FILENAME COUNT
RFD1:	MOVEI C,0	;INITIALIZE WORD
	MOVE B,[440600,,C]	;SET UP BP FOR INPUT
RFD2:	PUSHJ P,RTYI	;GET CHARACTER IN A
	CAIN A,":	;IF COLON...
	JRST RFDCOL	;THEN PROCESS AS SUCH
	CAIN A,";	;SIMILARLY FOR SEMICOLON
	JRST RFDSEM
	CAIN A,"	;IF CONTROL Q...
	JRST RFDCQ	;THEN GET NEXT CHARACTER AND TREAT AS NON-SYNTACTICAL
	CAILE A,40	;LOGICAL SPACE? (INCLUDING CR)
	JRST RFDC	;NO
RFD6:	JUMPE C,RFD5	;IGNORE NULL FILENAMES
	EXCH C,FNAM2
	TMODF ZN,TMPF1
	MOVEM C,FNAM1	;MOVE SECOND TO FIRST
RFD5:	CAIE A,15	;WAS LAST CHAR CR?
	JRST RFD1	;NO, GO BACK FOR NEXT NAME
	POPJ P,		;DONE

RFDCOL:	JUMPE C,RFD1	;IF HE WANTS THE NULL DEVICE HE GETS TO TYPE IT IN
	HLRM C,DNAM	;MOVE TO RH OF DEVICE LOCATION
	JRST RFD1	;LOOP

RFDSEM:	JUMPE C,RFD1	;NO NULL SYSTEM NAMES PLEASE
	MOVEM C,SNAM	;MOVE TO SYSTEM NAME LOCATION
	JRST RFD1	;LOOP

RFDCQ:	PUSHJ P,RTYI	;CONTROL Q EATS UP THE NEXT CHARACTER
	CAIN A,15
	JRST RFD6	;BUT NOT IF CR
RFDC:	SUBI A,40	;CONVERT CHARACTER TO SIXBIT
	TLNE B,770000	;TOO MANY CHARACTERS?
	IDPB A,B	;NO
	JRST RFD2	;LOOP

DNAM:	2,,(SIXBIT /DSK/)
FNAM1:	SIXBIT /@/
FNAM2:	SIXBIT />/
SNAM:	0

		;FILE INPUT ROUTINES
		;GET CHAR IN A, CLOSE FILE IF EOFCH

IFNDEF EOFCH,EOFCH==^C	;EOF CHARACTER
IFNDEF UTIBFL,UTIBFL==40	;LENGTH OF INPUT BUFFER

RCH:	ILDB A,UREDP'	;ENTRY, GET CHAR
	CAIE A,EOFCH	;COMPARE WITH EOF CHAR
	POPJ P,		;NOT EOF CHAR, RETURN WITH IT
	PUSHJ P,UTRLD	;EOF CHAR, READ NEW BUFFER-FULL (OR POPJ OUT OF RCH)
	JRST RCH	;TRY AGAIN WITH NEW BUFFER

		;OPEN FILE (DNAM, ETC.) FOR READING

OPNRD:	MOVE A,[2,,DNAM]	;BLOCK ASCII INPUT
	HLLM A,DNAM	;STORE MODE
	PUSHJ P,OPEN"	;TRY THE OPEN
	HALT"		;LOST
UTRLD2:	MOVE A,[440700,,UTIBUF]
	MOVEM A,UREDP
	HRLI A,-UTIBFL
	PUSHJ P,BIOT"	;DO BLOCK .IOT
	HALT		;(SHOULD ALWAYS SKIP)
	HRLI A,EOFCH_<18.-7>
	HLLZM A,(A)
	POPJ P,

UTRLD:	HRRZ A,UREDP	;READ NEW BUFFER: FIND OUT WHERE LOST
	CAIN A,UTIBUF+UTIBFL
	JRST UTRLD2	;JUST END OF BUFFER, RELOAD IT
UTRLDC:	PUSHJ P,CLOSE"	;REAL EOF, CLOSE CHANNEL
	HALT		;???
	POP P,A		;POP OFF PC STORED ON PUSHJ TO UTRLD,
		; ^ WANT TO RETURN FROM CALLING ROUTINE
	MOVE A,[070700,,.+2]
	MOVEM A,UREDP	;CAUSE INDEFINITE EOF INPUTTING
	MOVEI A,EOFCH
	POPJ P,

UTIBUF:	BLOCK UTIBFL+1	;INPUT BUFFER

		;DISPLAY ROUTINES

IFNDEF NLINES,NLINES==44.	;NUMBER OF LINES ROOM FOR ON DISPLAY

DISJNI:	MOVEI A,NLINES-1	;DISPLAY INITIALIZATION ROUTINE
	MOVEM A,LINENR
	JRST DISINI"

		;PUSHJ P,ADSPL	;DISPLAY ASCIZ STRING POINTED TO BY RH(B)

ADSPL:	HRLI B,440700
ADSPLL:	ILDB A,B
	JUMPE A,CPOPJ
	PUSHJ P,DISAD
	JRST ADSPLL

		;COPY THE FILE ONTO THE DISPLAY

COPY:	PUSHJ P,DISJNI	;INITIALIZE DISPLAY
COPY1:	PUSHJ P,RCH	;GET CHAR
COPY3:	CAIGE A,40
	JRST COPYCC	;CONTROL CHAR
COPY2:	PUSHJ P,DISAD"	;DISPLAY CHAR
	JRST COPY1

COPYCC:	CAIN A,^J	;CONTROL CHAR: LINE FEED?
	JRST CPYLF	;LINE FEED
	CAIN A,^L
	JRST CPYFF	;FORM FEED
	CAIN A,EOFCH
	JRST DISCLG"	;EOFCH, DISPLAY CURRENT STUFF AND RETURN
	CAIN A,33
	MOVEI A,"$	;DISPLAY ROUTINE USES CRUMMY ALTMODE
	JRST COPY2

CPYLF:	SOSLE LINENR'	;LINE FEED
	JRST COPY2	;DISPLAY NOT FULL
	PUSHJ P,DISAD	;DISPLAY THE LINE FEED
CPYFF:	PUSHJ P,RCH	;GET NEXT CHAR
	CAIN A,EOFCH	;EOF?
	JRST DISCLG	;EOF, LET THAT BE ALL
	PUSH P,A	;SAVE CHAR
	PUSHJ P,DSLNPS"	;GET CURRENT LINE POSITION
	JFCL
	JUMPE A,.+3	;JUMP IF AT BEGINNING OF LINE
	MOVEI A,^J	;NOT AT BEGINNING, INCREMENT TO NEXT LINE
	PUSHJ P,DISAD
	MOVEI B,[ASCIZ /î--MORE--/]
	PUSHJ P,ADSPL
	PUSHJ P,DISCLG	;SHOW HIM WHAT'S THERE
	PUSHJ P,TYI	;WAIT FOR HIM TO TYPE IN A CHAR
	CAIE A,40
	JRST UTRLDC	;NOT SPACE, LET THAT BE ALL (POPS EXTRA ENTRY OFF PDL)
	PUSHJ P,DISJNI	;RE-INITIALIZE DISPLAY
	POP P,A		;GET BACK NEXT CHAR FROM FILE
	JRST COPY3	;LOOP BACK AND PROCESS NEXT PAGE

END BEG
