
Formats used in the LISP Machine editor:

The editor operates on units
called "buffers". a buffer is a single dimensional q array, each of whose
members points to a "line" (or nil in the case of a null line). additional
information  pertaining to the buffer is stored in the leader of the array.

A line is an ART-STRING array, which has additional information
pertaining to the line in its array leader.  There are no "newline"
characters stored; the end of a line is a logical newline.  A line
may be arbitrarily long. (??? ED-INFINITY)

	A "display window" is a single dimensional ART-Q array.  It specifies
one area of the screen.  The <n>'th element of the array contains an
array pointer to the LINE being displayed on the <n>'th physical line
in the area of the screen.  Presumably on the real machine each window will be
associated with one piece-of-paper (PC-PPR) on the screen.  If an entry in
the window array is -1, this is a special flag meaning that the corresponding
physical line is really a continuation of the previous logical line. (There
may be as many -1's in a row as are needed, but anyone who keeps lines that
long lying around is aking for trouble, since the top line of an area must
be the beginning of a logical line, and not a continuation of one).

	Since it is necessary to RELOCATE pointers into the buffer, (???
explain what that means) a buffer pointer which is going to be around for a long
time must be kept where the relocation routines can get at it.  Thus:
A buffer pointer is an object which points to a specific place in the buffer.
It is a CONS of (<a line pointer> . <a fixnum index into the line>).
In order to get properly relocated, each line has a list (the pointer to the list is
kept on the line's array leader) of buffer pointers which must be updated.
There may of course be temporary buffer pointers during whose ephemeral
life-span there will never be a relocation; these need not be placed on the
list.
	The point and the mark exist as special variables whose value is
a buffer pointer.  These buffer pointers are therefore being pointed to by both
the point and mark special variables, and the line's buffer pointer list.
A buffer pointer is actually considered to point between two characters
in the line, that is, 0 is just before the first char, and upward from there.
When it is needed to refer to a character, it is usually the character "just
to the right" of the pointer, as is done in TECO.  Thus 0 refers to the zeroth
character, 1 refers to the next one and so on.  The character pointed to by a
pointer pointing to the end of a line is the mythical "newline" character,
so that deleting that "character" actually causes two lines to be merged into
one, etc, producing the same effect as the TECO editors now in use do.

	General:  only one entry in a BUFFER may point to a line
(othwerwise editing one line would affect the other). Thus to copy a line
you must really make a copy, and to copy a buffer you must copy the BUFFER
array and all its lines.
All buffers must have at least on line in them (so that the mark and point can 
always be meaningful).
	All editor arrays  have FILL-POINTERs which show their current size, so
FILL-ARRAY can be used.
Some editor functions will accept in lieu of a string a single FIXNUM and
interpret it as a one-character string.
	Each line has a variable in its leader which holds the number of physical
lines it takes to display the line.  If the number is -1 it means that we don't know,
so the editor need only compute it when it it is interested, and anything which
might change it should set it to -1 so that it will be recomputed when the time comes.
Note that this is dependent on the window size, and if it is changed ALL
of the lines must have -1 stored there.  Each line also knows how many net opens-
minus-closes there are on the line (this must look ath the readtable; is
is also not clear how to handle brackets) (not implemented initially).

; IN ORDER TO FACILITATE
;UPDATING THE DISPLAY, A NUMBER OF FEATURES EXIST TO ENABLE THE SYSTEM TO
;KEEP TRACK OF HOW MUCH DISPLAY ROOM A LINE TAKES AND WHETHER IT HAS BEEN
;CHANGED SINCE THE DISPLAY WAS LAST UPDATED. EACH LINE IN A BUFFER, AT THE
;TIME OF ITS CREATION, IS ASSIGNNED A UNIQUE NUMBER.  THIS NUMBER IS
;OBTAINED BY INCREMENTING AN ASCENDING COUNT ASSOCIATED WITH THE BUFFER.
;EACH LINE ALSO HAS AN "INCARNATION" NUMBER, WHICH IS INCREMENTED EACH TIME
;THE LINE IS CHANGED.  








Basic operation of the editor:
	When some insertion or deletion wants to be done on a line, the line must be
"opened". There may only be one (or none at all) open line at a time, similar to
the DDT "open location," on which insertion or deletion will be done.
Some of the array-leader elements are copied out into special varibles for the open
line for more eficient accessing.

;OPENING A LINE CONSISTS OF COPYING IT (WITH A NEW INCARNATION NUMBER). (IF
;THE LINE WAS PREVIOUSLY NULL, A NEW LINE BLOCK IS CREATED.) A POINTER TO
;THE NEW INCARNATION OF THE LINE IS STORED BACK INTO THE BUFFER, BUT A
;POINTER TO THE OLD COPY IS KEPT IN ED-BUFFER-OLD-COPY-OPEN-LINE. THIS IS
;DONE FOR THE CONVENIENCE OF THE DISPLAY ROUTINES. ANY DESIRED CHANGES MAY
;THEN BE MADE.  IN THIS PROCESS, HOWEVER, A RECORD IS KEPT OF THE LOCATIONS
;OF THESE CHANGES IN THE FORM OF A LIST OF (<OPERATION>, <LOCATION>,
;<NUMBER>).  <OPERATION> CAN BE INSERT OR DELETE, <LOCATION> IS THE LOCATION
;WITHIN THE LINE AT WHICH THE OPERATION OCCURRED, AND <NUMBER> IS THE NUMBER
;OF CHARACTERS INSERTED OR DELETED.

 CLOSING A LINE IS DONE WHEN IT IS DESIRED TO OPEN SOME OTHER LINE, TO DO
AN INTER-LINE EDITING OPERATION OR TO FILE OUTPUT.  IT IS NOT NECESSARY TO
CLOSE THE LINE TO UPDATE THE DISPLAY. IN ADDITION TO CLOBBERING BACK THE
POINTER TO THE LINE IN THE BUFFER, CLOSING THE LINE MUST RELOCATE ANY
BUFFER POINTERS THAT MAY HAVE BEEN AFFECTED AND MUST MAKE APPROPRIATE
ENTRIES ON THE HISTORY LIST (CONSISTING OF BOTH THE OLD LINE AND OLD BUFFER
POINTER VALUES). INTER-LINE EDITING OPERATIONS CONSIST SOLELY OF SHUFFLING
THE POINTERS TO LINES IN THE LINE-POINTING PART OF THE BUFFER.  TO DELETE A
LINE, FOR EXAMPLE, ALL POINTERS TO LINES ABOVE THAT LINE MUST BE "BLT ED"
DOWN ONE. AGAIN, APPROPRIATE BUFFER-POINTER RELOCATIONS AND HISTORY LIST
UPDATING MUST BE DONE.  INTER-LINE EDITING CAN ONLY BE DONE WHEN THERE IS
NO LINE OPEN FOR INTRA-LINE EDITING.

	In a similar manner to the open line, an open buffer is defined.
all editing operations are performed on the open buffer.  Opening a buffer
consists of transferring information out of its array leader to a set of
special variables which are referenced by the editing functions, and
closing it consists merely of transferring them back.

OVERALL EDITING OPERATION.   EDITING LISP: A BUFFER IS LOGICALLY ASSOCIATED
WITH EACH FUNCTION. THIS BUFFER MAY BE STORED ON THE PROPERTY LIST OF THE
FUNCTION OR CREATED WHEN NEEDED BY GRINDEF OR READING IT IN FROM A FILE.
WHEN IT IS DESIRED TO "QUIT" EDITING THE FUNCTION, THE CONTENTS OF THE
BUFFER ARE FED TO READ.  THE RESULTING S-EXPRESSION MAY IF DESIRED SIMPLY
BE STORED BACK IN THE FUNCTION CELL, ETC.  ALTERNATIVELY, AN "INTEGRATE"
MAY BE ATTEMPTED.  AN INTEGRATE IS A SEMI-HEURISTIC OPERATION WHICH IS OF
INTEREST ONLY IF ONE IS IN THE MIDDLE OF AN ON-GOING COMPUTATION WHICH ONE
WISHES TO CONTINUE USING THE NEWLY EDITED DATA TO REPLACE THE OLD.  SINCE
ARBITRARY DECISIONS CAN BE INVOLVED THIS GENERAL PROCESS, THE MAIN EMPHASIS
IS TO GIVE THE USER WARNING IF THERE EXIST WITHIN THE SYSTEM (MORE
ACCURATELY, ON THE PUSH DOWN LIST) POINTERS TO SECTIONS OF CODE WHICH HAVE
BEEN DELETED, OR DO NOT CORRESPOND IN AN OBVIOUS MANNER TO SECTIONS IN THE
NEW COPY.  IF ANY POINTERS ARE FOUND TO SECTIONS OF THE OLD THING WHICH DO
CORRESPOND, THEY ARE RELOCATED. IF A WARNING MESSAGE IS TYPED, IT IS
EXPECTED THAT THE USER WILL NORMALLY QUIT AND START THE WHOLE THING OVER,
SINCE IT IS TOO MUCH PAIN TO FIGURE OUT EXACTLY WHAT IS GOING ON (HE CAN
TRY IF HE WANTS, THOUGH).
	IT IS BELIEVED THAT THIS APPROACH IS SUPERIOR, IN USER CONFIDENCE
AT LEAST, TO THE APPROACH WHERE THE EDITOR DIRECTLY EDITS THE ACTUAL
S-EXPRESSION, THEN SIMPLY PROCEEDS, SINCE WITH THAT APPROACH THE USER
RECEIVES NO WARNING IF HE IS BEING SCREWED.  FURTHERMORE, AN EDITOR EDITING
THE ACTUAL S-EXPRESSION DOES NOT LEND ITSELF CONVIENENTLY TO EFFICIENT USE
OF THE DISPLAY.
 EDITING GENERAL TEXT: THE BUFFER CAN BE HUNG OFF ANYWHERE CONVIENENT, ETC.
EXTREMELY LARGE BUFFERS CAN CAUSE SEMI-SERIOUS OVERHEADS ON INTER-LINE
EDITING OPERATIONS NEAR THE BEGINNING OF THE BUFFER, BUT THIS SHOULD NOT BE
A SERIOUS PROBLEM (I DONT THINK). 
 "STRUCTURE" WITHIN A BUFFER. CERTAIN STRUCTURE IS INHERITLY PROVIDED BY
THE EDITING SYSTEM ITSELF AT LEVELS BOTH ABOVE AN BELOW THE UNIT OF THE
BUFFER.  AN EXAMPLE IS THE SYSTEM OF MULTIPLE BUFFERS WITH A BUFFER
CORRESPONDING TO A FUNCTION OR CHAPTER.  ANOTHER IS THE DIVISION INTO
LINES, ETC. IN MANY CASES, HOWEVER, IT IS HIGHLY DESIRABLE TO PROVIDE
ADDITIONAL STRUCTURE WHICH MAY BE DATA-TYPE SPECIFIC IN SOME CASES.  FOR
EXAMPLE, ONE MAY HAVE A COMMAND TO JUMP DIRECTLY TO A GIVEN TAG IN A PROG,
OR TO A GIVEN CHAPTER, ETC.  ASSUMING ONE WISHES TO PROVIDE SUCH COMMANDS,
IN SOME CASES IT IS LARGELY AN IMPLEMENTATION DECISION WHETHER A DATA BASE
SHOULD BE MAINTAINED AND UPDATED OR WHETHER THE SYSTEM SHOULD LOCATE THE
DESIRED POINT BY A SPECIALIZED SEARCH ON THE TEXT STRING EACH TIME
REQUESTED. THE DATA-BASE IS CLEARLY REQUIRED IF ONE WISHES TO BE ABLE TO
PROCEED TO ARBITRARY POINTS IN THE TEXT WHICH ARE NOT NECESSARILY LOCALLY
DISTINGUISHED IN A MANNER THEY CAN BE SEARCHED FOR.  FOR EXAMPLE, IF ALL
TAGS END WITH A COLON, THEY ARE LOCALLY DISTINGUISHED.  BUT ALL REFERENCES
TO "INVISIBLE DATA TYPES" MAY NOT BE UNIQUELY LOCALLY DISTINGUISHED.  TO
PROVIDE AN EFFICIENT MEANS OF UPDATING THESE DATA BASES  A LIST OF
"STRUCTURE TABLES" MAY BE ASSOCIATED WITH A BUFFER. THESE CONTAIN
INFORMATION SIMILIAR TO THE BUFFER POINTER ARRAY, BUT WITH THE FOLLOWING
DIFFERENCES:
   1) THE BUFFER POINTERS ARE REFERENCED BY A "KEY", WHICH IS AN ARBITRARY
	  LISP-MACHINE Q.  THUS, THEY ARE CONSIDERED IN TRIPLES INSTEAD OF
	  PAIRS.  THE THIRD MEMBER OF THE TRIPLE HOLDS THE KEY.
   2) THE ENTRIES ARE LOG SORTED BY LINE NUMBER FOR FAST LOOK-UP AND
UPDATING. A STRUCTURE TABLE MAY SPECIFY THAT IT IS REALLY A FUNCTION
(PRESUMABLY SEARCHING FUNCTION), IN WHICH CASE, THAT ENTRY IS IGNORED WHEN
UPDATING BUFFER POINTERS, BUT PRESUMABLY MAY BE ACESSED WHEN ATTEMPTING TO
RETRIEVE A VALUE ASSOCIATED WITH A KEY BY THE STRUCTURE.  DISPLAY
UPDATING:
 THERE ARE FIVE BASIC "SORTS" OF DISPLAY UPDATE THAT CAN OCCUR.
  THESE ARE 1) CLEAN-WIPE 2) LINE-REDISPLAY 3) PARTIAL-LINE-REDISPLAY.
  4) CHARACTER-ADD AND 5) CURSOR-POSITION.
  UNDER APPROPRIATE CONDITIONS, AN ATTEMPT TO DO A (4) CAN RESULT IN A
  (3) CAN RESULT IN A (2),
  WHICH CAN RESULT IN A (1), BUT THIS IS NOT THE COMMON CASE.
 DISPLAY UPDATE TYPES 1 THRU 4 TAKE AS ARG A LINE NUMBER <LINE>, ON WHICH
THE
  "CURSOR" IS ASSUMED TO RESIDE FOR PURPOSES OF DISPLAY POSITIONING.
  TWO VARIABLES ASSOCIATED WITH THE DISPLAY WINDOW 
  CONTROL HOW CLOSE THIS LINE WILL BE ALLOWED TO "WANDER"
  TO THE EDGES OF THE SCREEN BEFORE A CLEAN-WIPE IS INITIATED.
  THESE ARE ED-WINDOW-MIN-CURSORPOS AND ED-WINDOW-MAX-CURSORPOS.
  IF <LINE> WOULD BE STARTED ON A PHYSICAL LINE NUMBER OUT OF THE RANGE
  THESE VARIABLES DEFINE, A CLEAN-WIPE HAPPENS.  IF A CLEAN-WIPE DOES
HAPPEN
  <LINE> GETS POSITIONED ON THE SCREEN UNDER THE CONTROL OF TWO MORE
  VARIABLES, ED-WINDOW-MIN-RESET-CURSORPOS AND
ED-WINDOW-MAX-RESET-CURSORPOS.
  IF LINE ATTEMPTED TO BE DISPLAYED ON A LINE LESS THAN MIN-CURSORPOS,
  IT WILL BE REPOSITIONED TO PHYSICAL LINE MIN-RESET-CURSORPOS AFTER THE
  CLEAN-WIPE, AND SIMILARILY FOR MAX-CURSORPOS AND MAX-RESET-CURSORPOS.
 (ED-DISPLAY-CLEAN-WIPE <LINE> <SCREEN LOCATION>) INVOKES A CLEAN WIPE.
  AN ATTEMPT IS MADE TO WORK THINGS OUT SUCH THAT LINE <LINE> STARTS ON THE
  <SCREEN-LOCATION TH) PHYSICAL LINE ON THE SCREEN.  HOWEVER, IT SHOULD
  NOT BE AUTOMATICALLY ASSUMED THAT ED-DISPLAY-CLEAN-WIPE WILL SUCCEED IN
  LOCATING IT EXACTLY THERE.
 (ED-LINE-REDISPLAY <LINE>)
  WILL ATTEMPT TO LEAVE AS MUCH OF THE CURRENT SCREEN CONTENTS AS POSSIBLE.
  IE, IT STARTS AT THE TOP OF THE DISPLAY WINDOW AND SKIPS OVER ANY
  SCREEN LINES THAT HAVENT BEEN CHANGED AND MATCHING TEXT LINES.
  HOWEVER, IF THIS PROCEDURE WOULD CAUSE LINE <LINE> TO BE DISPLAYED AT
  A PHYSICAL LINE NUMBER OUT OF RANGE (SEE ABOVE) A CLEAN-WIPE OCCURS.
 (ED-PARTIAL-LINE-REDISPLAY <LINE> <CHARPOS> <SCREEN-VERTICAL LOCATION>)
  SAYS UPDATE SCREEN ASSUMING THAT ONLY <LINE> IN CHARACTER POSITIONS
  GREATER THAN OR EQUAL TO <CHARPOS> HAS CHANGED.  THIS LINE MUST BE
  BEING CURRENTLY DISPLAYED STARTING AT <SCREEN-VERTICAL LOCATION>.
  ED-PARTIAL-LINE-REDISPLAY COMPUTES THE HORIZONAL SCREEN COORDINATE
  CORRESPONDING TO <CHARPOS>, AND DOES A (IO-SET-CURSORPOS ..) TO THERE.
  IT THEN REDISPLAYS THE REST OF THE LINE AND DOES A CLEAR END OF LINE.
  IT THEN DOES AN RCPOS TO SEE IF THE LINE CAUSED MORE CONTINUATIONS THIS
TIME
  THAN LAST.  IF NOT, IT RETURNS.  IF SO, IT DOES A (ED-LINE-REDISPLAY
<LINE>).
 (ED-REDISPLAY-CHARACTER-ADD <LINE> <CHARPOS> <NUMBER>
		<SCREEN-VERTICAL-LOCATION><SCREEN-HORIZONAL-LOCATION>)
    ASSUMES THAT THE CURSOR (OF THE ACTIVE BUFFER) IS AT THE
	SPECIFIED SCREEN LOCATION AND THAT THIS CORRESPONDS TO 
	<LINE> <CHARPOS> IN THE BUFFER.  PRESUMABLY, <NUMBER> OF CHARACTERS
	HAVE BEEN INSERTED.  THUS <NUMBER> OF CHARACTERS ARE OUTPUTTED,
	A SAVE CURSOR POSITION DONE, THE REST OF THE LINE OUTPUTED, AND
	A RESTORE CURSOR POSITION DONE.  AS ABOVE, AN ED-LINE-REDISPLAY
	MAY THEN BE DONE IF NECESSARY.
 (ED-DISPLAY-CURSOR-POS <LINE> <CHARPOS>) MOVES CURSOR TO DISPLAY
	POSITION CORRESPONDING THE THE ARGS.
 KEEPING TRACK OF THE CURSORPOS:
  TWO VARIABLES IO-CURSORPOS-V AND IO-CURSORPOS-H ATTEMPT TO KEEP TRACK
  OF THE CURSORPOS, BUT EITHER MAY BE NIL INDICATING THAT ITS NOT
  REALLY SURE RIGHT NOW.  EACH DISPLAY WINDOW HAS TWO VARIABLES
  ED-WINDOW-CURSORPOS-V AND ED-WINDOW-CURSORPOS-H WHICH ATTEMPT
  TO REMEMBER WHERE THE "LOGICAL" CURSOR ASSOCIATED WITH THIS WINDOW IS
  (WAS), BUT THESE MAY AT TIMES BE NIL ALSO.
