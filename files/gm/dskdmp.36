
TITLE DSKDMP

A=1
B=2
C=3
D=4
BLKIN=5	;PSEUDO-CORE BLOCK IN CBUF
WRITE=6	;NEG MEANS DUMP, RH 0 OR WRBIT
DIFF=7	;DIFF CONO ALSO TEMP
HEAD=10	;HEAD CONO ALSO TEMP
P=11	;JSP AC
TRACK=12
UNIT=13	;UNIT AND M.A. DATAO
CMD=14	;COMMAND CHAR
T=15	;VERY TEMP
TT=16	;ANOTHER JSP AC, ALSO VERY TEMP
BUFP=17	;DBUF PNTR--LAST WORD USED

LPM=102000,,
LPMR=LPM 2,
SPM=LPM 1,

DSK==704
CONTROL==400000
SETCYL==200000
SETHD==100000
SETDIFF==40000
FORW==20000
SEEK==4000
RESETHD==2000
CKSERR==200
RET0==200
PARERR==100
WKBTS==74	;FILE BEING WRITTEN, KILLED, ETC.
WRBIT==40
BUSY==20
DONE==10
U0==1
U1==2
U2==4
U3==10
NDSK==4	;SOMEDAY 4?
UX==1_<NDSK>
MDIRTK==999.
CORE==766000	;HIGHEST ADR ALWAYS IN CORE+1
CORES==CORE_<-12>
HIGH==777700	;HIGHEST ADR LOADED/DUMPED+1
DDT==774000
CTRK==2020.	;766000 SAVED TRACK
;GM WILL BUY A COKE FOR THE FIRST PERSON WHO
;DISCOVERS WHY THE FILE DIRECTORY LISTER IS
;CALLED LISTFC

...:	MOVE T,....	;THIS CODE BLTS THE FOLLOWING OFFSET CODE
	BLT T,THEEND-1-1	;INTO HIGH MEMORY AND WRITES DSKDMP ON ITS
	MOVE T,PROG+THEEND-2-ERROR+1
	MOVEM T,ERROR+THEEND-2-ERROR+1	;AVOID LOSING DUE TO -1 BLT LOSSAGE

	MOVEI UNIT,ERROR+U0	;MAGIC TRACK THEN STARTS IT
	MOVEI TRACK,2025.
	MOVEI WRITE,WRBIT
	JSP TT,WRD3
	JRST .....
....:	PROG,,ERROR

PROG:	OFFSET CORE+10000-.

O=.-PROG
ERROR:	0
	CLEARM -1	;DON'T READ ANY MORE COMMANDS FROM MEMORY
	SOS T,ERROR	;PICK UP ERROR CODE FROM THE AC FIELD OF
	LDB T,[270400+T,,]	;THE JSR ERROR
	MOVE D,ERMESS(T)
	JSP TT,PD	;PRINT OUT APPROPRIATE COMMENT
	CAIL T,EBUG
	JRST READ	;BAD ERROR - NO MORE DISKING
LOADG1:	DATAI TTY,C	;FLUSH RANDOM CHARACTER
	TRO CMD,10	;MAKE SURE PSEUDO-CORE IN CORE
	JRST LOADG	;BY SIMULATING END OF LOADING, NON-GOING COMMAND
ERMESS:	IRP XX,,[ECMP,EDIR,EEOF,ESNF,EFNF,EPNM,ECKS
EDSK,EDDT,EBUG,EC63,ECRD,ECWR,ECDR]YY,,[CMPERR,DIRFUL
EOF,SYSNNF,FNF,PKNMTD,CKSERR,DSKFUL,NODDT,?BUG?,CLOB63
CLOBRD,CLOBWR,DIRCLB]
XX==.-ERMESS
	SIXBIT \YY\
TERMIN

PD:	JSP P,CRLF	;TYPE A CR
PD2:	MOVEI C,40
	JSP P,TYO	;AND A SPACE
	MOVE B,[440600,,D]
PD1:	ILDB C,B	;AND THE SIXBIT CONTENTS OF D
	ADDI C,40
	JSP P,TYO
	TLNE B,770000
	JRST PD1
	JRST (TT)

PNO:	IDIVI C,10.	;PRINT CONTENTS OF C AS A TWO-DIGIT
	DPB C,[60600,,D]	;DECIMAL NUMBER PRECEDED
	ADDI D,(SIXBIT \#00\)	;BY <SPACE>#
	MOVE B,[300600,,D]
	JRST PD1

WRCB:	MOVEI UNIT,CBUF	;WRITE OUT CONTENTS OF CBUF
	LSH BLKIN,-12	;ON APPROPRIATE TRACK
	MOVEI TRACK,CTRK-CORES(BLKIN)
	JRST WRM

LODUMP:	MOVEI UNIT,CORE	;DEPENDING ON SIGN BIT OF WRITE, LOAD OR DUMP
	MOVEI TRACK,CTRK	;PSEUDO-CORE (766000-775777)
LODMP1:	JSP TT,WRDM
	ADDI UNIT,2000
	CAIGE UNIT,ERROR
	AOJA TRACK,LODMP1
	MOVEI BLKIN,CORE
	JRST (P)

FD:	HRRZ C,B	;SET UP POINTER IN C TO FETCH OR DEPOSIT
	CAIL C,20	;CONTENTS OF ADDRESS IN RIGHT HALF OF B
	CAIL C,HIGH
	JRST (P)	;CAN'T LOAD OR DUMP THIS ADDR--DON'T SKIP
	CAIE C,63	;63 AND 64 ARE ALWAYS 0--RETURN A POINTER
	CAIN C,64	;TO A ZERO
	TROA C,C0	;C0=C0\67
	CAIGE C,CORE	;IF ADDR IS IN REAL CORE, RETURN IMMEDIATELY
	JRST 1(P)
FDX:	CAIL C,(BLKIN)	;ADDR IS IN PSEUDO-CORE--CHECK IF RIGHT
	CAILE C,1777(BLKIN)	;BLOCK IS IN CBUF
	JRST FD3	;IT'S NOT THERE--READ IT IN
FD4:	SUBI C,-CORE(BLKIN)	;IT'S THERE--SET UP RIGHT POINTER IN C
	JRST 1(P)	;AND RETURN
FD3:	JUMPLE WRITE,FD3A	;IF DUMP OR VERIFY DON'T BOTHER
		;TO WRITE OUT CURRENT BLOCK
FD3B:	JSP TT,WRCB	;IF LOAD, WRITE CURRENT BLOCK FIRST
FD3A:	MOVEI UNIT,CBUF
	MOVE BLKIN,C
	ANDI BLKIN,776000
	LDB TRACK,[121000,,BLKIN]
	ADDI TRACK,CTRK-CORES
	JSP TT,RDM	;READ IN CORRECT BLOCK
	JRST FD4	;SET UP POINTER AND RETURN

GBP:	IDIVI C,6	;TURN USER DIRECTORY CHARACTER ADDR IN C
	IMULI D,-60000	;INTO A BYTE POINTER
	HRLI C,440600(D)
	ADDI C,UDESC
	JRST (TT)

WD:	AOBJN BUFP,WD1	;READ, WRITE, OR VERIFY WORD IN D FROM, INTO,
	JSP TT,NXTBLK	;OR AGAINST WORD IN DBUF
	JSP TT,WRDB	;TIME TO REFILL OR EMPTY DBUF
	MOVSI BUFP,-2000	;RESET BUFFER POINTER
WD1:	JUMPG WRITE,WD2	;JUMP ON LOAD
	JUMPL WRITE,WD3	;JUMP ON WRITE
	CAME D,DBUF(BUFP)	;HERE IF VERIFY
	JSR ECMP,ERROR	;VERIFY COMPARE LOST
	JRST (P)
WD2:	SKIPA D,DBUF(BUFP)	;LOAD
WD3:	MOVEM D,DBUF(BUFP)	;DUMP
	JRST (P)

NXTMDR:	HRRZ B,CU	;SELECT NEXT UNIT AND READ ITS MASTER DIRECTORY
	LSH B,1
	TRNE B,UX
	MOVEI B,U0
	HRRM B,CU
	TRNE B,@MU
	JRST 1(TT)	;SKIP IF NO MORE
	TDNE B,UNITS
	JRST NXTMDR	;UNIT NOT ON LINE
RDMDR:	MOVEI TRACK,MDIRTK	;READ MASTER DIRECTORY OF CURRENT UNIT
	MOVEI UNIT,MDIR
	JRST RD

NXTBW3:	0
	IBP DIRPT	;DO AN IDPB T,DIRPT CHECKING TO SEE IF
	LDB DIFF,[1200,,DIRPT]	;RUNNING INTO NAME AREA
	CAML DIFF,UNAMPT
	JSR EDIR,ERROR
	DPB T,DIRPT
	JRST @NXTBW3

NXTBW:	MOVE TRACK,LTRACK	;FIND NEXT FREE BLOCK TO WRITE
	MOVEI HEAD,1(TRACK)
	ILDB T,TUTPT
	JUMPN T,NXTBW1	;JUMP IF VERY NEXT BLOCK NOT FREE
	AOS T,BLKCNT
	CAIG T,13
	JRST NXTBW2	;NO NEED TO MODIFY DIRECTORY YET
	CLEARM BLKCNT	;14 IN A ROW--RESET COUNTER AND
NXTBW6:	JSR NXTBW3	;DPB BYTE INTO DIRECTORY
NXTBW2:	MOVE TRACK,HEAD
	CAIL TRACK,2000.
	JSR EDSK,ERROR	;NO MORE DISK LEFT
	MOVEI T,1
	DPB T,TUTPT	;MARK BLOCK USED IN TRACK USAGE TABLE
	JRST WRDB1
NXTBW1:	ADDI HEAD,1	;SEARCH FOR NEXT FREE BLOCK
	ILDB T,TUTPT
	JUMPN T,NXTBW1
	SUBM HEAD,TRACK
	SKIPE T,BLKCNT	;COME UP WITH DESC BYTE FOR LAST FEW TRACKS
	JSR NXTBW3
	CLEARM BLKCNT
	MOVEI T,13(TRACK)
	CAIGE T,37	;CAN WE SAY SKIP N--TAKE 1?
	JRST NXTBW6	;YES
	LDB T,[60500,,HEAD]	;NO, HAVE TO USE LOAD ADDRESS
	IORI T,40
	JSR NXTBW3
	MOVE T,HEAD
	JRST NXTBW6

NXTBLK:	JUMPL WRITE,NXTBW	;GET NEXT BLOCK OF FILE--IF DUMP, FIND FREE
	MOVE TRACK,LTRACK	;BLOCK
NXTB6:	SOSLE BLKCNT	;HAVE WE RUN OUT OF "TAKE N"?
	AOJA TRACK,WRDB1	;NO--TAKE NEXT TRACK
	ILDB T,DIRPT	;YES--GET NEXT DESC BYTE
	TRZE T,40
	JRST NXTB1	;IT'S A LOAD ADDR
	CAIE T,37
	JUMPN T,NXTB2	;IT'S BETWEEN 1 AND 36 INCLUSIVE
	CAIE CMD,'D	;IT'S 0 OR 37--IF THIS IS A LOAD, IT'S AN
	CAIN CMD,'K	;UNEXPECTED END OF FILE
	JRST KILL1	;IF LOAD OR KILL, O.K.
	JSR EEOF,ERROR
NXTB1:	MOVE TRACK,T	;LOAD ADDR
	MOVEI T,0
	CAIE CMD,'D
	CAIN CMD,'K
	DPB T,DIRPT	;IF KILLING FILE, ZERO THIS BYTE (OTHERS ZEROED AT KILL)
	LSH TRACK,6
	ILDB T,DIRPT
	ADD TRACK,T	;GET COMPLETE TRACK NUMBER
	JRST NXTB3
NXTB2:	MOVEM T,BLKCNT
	CAIG T,14
	AOJA TRACK,WRDB1	;TAKE N STARTING WITH NEXT ONE
	ADDI TRACK,-13(T)	;SKIP N-14 AND TAKE 1
NXTB3:	CLEARM BLKCNT
WRDB1:	MOVEM TRACK,LTRACK
	JRST (TT)

WRDM:	SKIPL WRITE	;SEE WHETHER LOAD OR DUMP/VERIFY
RDM:	TRZA WRITE,WRBIT	;READ FROM MASTER UNIT
WRM:	IORI WRITE,WRBIT	;WRITE ON MASTER UNIT
	ANDCMI UNIT,17	;FLUSH EXTRANEOUS UNIT SELECT BITS
MU:	IORI UNIT,U0	;MASTER UNIT SELECT BIT STORED HERE
	JRST WRD3

WRDB:	MOVEI UNIT,DBUF	;READ OR WRITE DBUF FROM/ON CURRENT UNIT
WRD:	SKIPL WRITE	;READ OR WRITE FROM/ON CURRENT UNIT
RD:	TRZA WRITE,WRBIT	;READ FROM CURRENT UNIT
WR:	IORI WRITE,WRBIT	;WRITE ON CURRENT UNIT
	ANDCMI UNIT,17	;FLUSH EXTRANEOUS UNIT SELECT BITS
CU:	IORI UNIT,U0	;CURRENT UNIT SELECT BIT STORE HERE
WRD3:	ANDCMI WRITE,-1-WRBIT	;CLEAN UP RIGHT HALF OF WRITE
	MOVNI DIFF,11	;INITIALIZE ERROR COUNTER
	MOVEM DIFF,ERRCT	;10. LOSSES PERMITTED
WRD1:	LDB T,[10200,,UNIT]	;TURN UNIT SELECT BIT INTO UNIT NUMBER
IFE NDSK-4,[TRNE UNIT,U3
	MOVEI T,3
]	SKIPL POS(T)
	JRST WRD4	;CURRENT POSITION KNOWN
WRD5:	CLEARM POS(T)	;CURRENT POSITION UNKNOWN--RESET UNIT
	DATAO DSK,UNIT
	CONO DSK,CONTROL\RET0\BUSY\DONE
	MOVEI DIFF,6000.
	SOJG DIFF,.
	CONO DSK,0
	MOVEI DIFF,200000.
	SOJG DIFF,.
WRD4:	HRRZM TRACK,63	;SET UP 63 IN CASE WRITING
	HRRZ DIFF,TRACK
C12:	IDIVI DIFF,12	;SEE CRLF
	SUBM DIFF,POS(T)	;SET UP DIFFERENCE CONO
	EXCH DIFF,POS(T)	;AND STORE NEW POSITION
	SKIPL DIFF
	TROA HEAD,FORW_<-6>	;TURN ON FORWARD BIT IF GOING FORWARD
	MOVNS DIFF
	XORI DIFF,377
	LSHC DIFF,6
	DATAO DSK,UNIT	;GET THINGS GOING
	CONO DSK,CONTROL\RESETHD
	CONO DSK,SETCYL
	CONO DSK,SETHD(HEAD)
	CONO DSK,SETDIFF(DIFF)
	CONO DSK,CONTROL\SEEK
	CONO DSK,CONTROL\BUSY(WRITE)
	CONSO DSK,DONE
	JRST .-1
	CONSZ DSK,PARERR\CKSERR
	JRST WRD2	;HARDWARE PARITY/CKS ERROR
	LDB DIFF,[1300,,63]
	CAIE DIFF,(TRACK)
	CAIN TRACK,CTRK+4	;BLOCK WRITTEN BY BOOTSTRAP HAS WRONG 63
	JRST (TT)	;NO ERRORS--RETURN
	HRRZM TRACK,BADTRK
	AOSLE ERRCT	;POSITIONER ERROR--CHECK ERROR COUNT
	JSR EC63,ERROR	;TOO MANY--GIVE UP
	JRST WRD5	;TRY AGAIN AFTER RESETTING UNIT
WRD2:	HRRZM TRACK,BADTRK
	AOSG ERRCT	;HARDWARE ERROR--CHECK COUNTER
	JRST WRD1	;TRY AGAIN
	TRNE WRITE,WRBIT	;GIVE UP--DISTINGUISH BETWEEN
	JSR ECWR,ERROR	;WRITE ERRORS AND
	JSR ECRD,ERROR	;READ ERRORS

LINK:	JRST 4,.

TYI:	ILDB C,-1	;CHECK FOR COMMANDS FROM MEMORY
	JUMPN C,(P)	;FOUND ONE--RETURN
	CLEARM -1
	CONSO TTY,40
	JRST .-1
	DATAI TTY,C
	ANDI C,177
	CAIGE C,175
	CAIN C,33
	JRST (P)	;DON'T ECHO GRITCHES
TYO:	SKIPE -1
	JRST (P)	;DON'T ECHO COMMANDS FROM MEMORY
	HRRZ A,C	;COMPUTE PARITY
	IMULI A,40201
	AND A,[1111111]
	IMUL A,[1111111]
	TLNE A,1
	IORI C,200
	CONSZ TTY,20
	JRST .-1
	DATAO TTY,C
	ANDCMI C,200
	JUMPGE C,(P)	;CHECK FOR CRLF (AS OPPOSED TO ECHOING A CR)
	SKIPA C,C12	;TYPE AN LF
CRLF:	HRROI C,15
	JRST TYO

BEG:	CONO 635550	;THIS CODE EXECUTED ONCE EACH TIME DSKDMP IS
	JRST .+1	;SET PC CHNG ON 6
	JFCL 1,.+2	;DONT LMPR ON 6
	LPMR PGBLK	;TURN OFF PAGING ON 10
	MOVEM 16,SYSN	;LOADED BY BOOTSTRAP
	LDB 16,BOOT5	;UNPACK INFO PUT IN ACS BY BOOTSTRAP
	HRRM 16,MU
	LDB 16,[360600,,17]
	DPB 16,BOOT4
	SKIPN 16
	CLEARM -1
	LDB 16,[220500,,17]
	DPB 16,[500,,-1]
	HRRM 17,SADR
	MOVEI 17,777760
	BLT 17,-1-2
	MOVEI T,LOADG1	;MUNG DSKDMP STARTING ADDRESS
	HRRM T,BOOT
READ:	MOVEI BLKIN,CORE
	JSP P,CRLF
	MOVEI CMD,0	;INITIALIZE COMMAND
READ1A:	MOVEI WRITE,0	;INITIALIZE NUMBER
	MOVSI B,(SIXBIT \@\)	;INITIALIZE 1ST FILE NAME
READ1:	MOVEM B,FN1
READ3A:	MOVSI B,(SIXBIT \@\)	;INITIALIZE CURRENT FILE NAME
	MOVE D,[440600,,B]
READ2:	JSP P,TYI
	CAIN C,177
	JRST READ	;IF RUBOUT START OVER
	CAIGE C,175
	CAIN C,33
	JRST ALTMOD	;JUMP IF 33, 175, 176
	ASH WRITE,3	;DOES NOT CHANGE SIGN OF WRITE
	CAIL C,"0
	CAILE C,"7
	TLOA WRITE,400000	;NON-NUMERIC CHAR--MAKE WRITE NEGATIVE
	ADDI WRITE,-"0(C)	;NUMERIC CHAR--ACCUMULATE NUMBER
	CAIN C,";
	JRST READ3	;SET SYSTEM NAME
	CAIN C,40
	JRST READ1	;SET FIRST FILE NAME
	CAIN C,^Q
	JSP P,TYI	;QUOTED CHARACTER
	CAIGE C,140	;CHECK FOR LOWER CASE
	SUBI C,40
	JUMPL C,DOIT	;IF LESS THAN 40 (EXC. ^Q) END OF COMMAND
	TLNE D,770000	;SKIP IF ALREADY SIX CHARS
	IDPB C,D
	JRST READ2
READ3:	MOVEM B,SYSN
	CAIE CMD,'U
	JRST READ3A
	JRST DOIT	;IF COMMAND IS U GO LIST DIRECTORY

PGBLK:	BLOCK 8

ONOFF:	DPB WRITE,ONOFF1	;PUT UNIT ON OR OFF LINE DEPENDING ON LOW
	DPB CMD,ONOFF2	;BIT OF COMMAND
	JRST READ
ONOFF1:	360200,,ONOFF2
ONOFF2:	100,,UNITS

ALT1:	LDB CMD,D	;PICK UP COMMAND CHAR
	CAIE CMD,'K
	TRNN CMD,2
	JRST READ1A	;GET FILE NAME
	JRST DOIT	;DON'T WANT FILE NAME--GO TO WORK

ALTMOD:	MOVEI C,"$
	JSP P,TYO	;ECHO DOLLAR SIGN
	JUMPLE WRITE,ALT2	;JUMP IF NOT <NUMBER><ALTMODE> LAST TYPED
	JUMPN CMD,ONOFF	;JUMP IF <CMD><ALTMODE><NUMBER><ALTMODE>
	HRRM WRITE,SADR	;SET STARTING ADDR
	JRST READ
ALT2:	TLC D,360000
	TLCN D,360000	;SKIP IF SINGLE CHARACTER BEFORE <ALTMODE>
	JUMPE CMD,ALT1	;JUMP IF NO COMMAND ALREADY TYPED
DOIT:	MOVEM B,FN2	;STORE SECOND FILE NAME
	MOVSI T,-NDSK
	SETOM POS(T)	;UNKNOWNIFY POSITIONS OF ALL DISKS
	AOBJN T,.-1
	HRRZ T,MU
	HRRM T,CU	;MAKE MASTER UNIT CURRENT UNIT
	MOVNI WRITE,1
	JSP P,LODUMP	;DUMP OUT PSEUDO-CORE
	CAIN CMD,'G
	JRST LOADG0	;GO
	MOVSI WRITE,1	;MAKE WRITE INDICATE LOAD
	JSP TT,RDMDR	;READ MASTER DIRECTORY TO FIND WHERE USER DIRECTORY IS
	CAIN CMD,'S
	JRST LISTS	;LIST DISK ID'S AND SYSTEM NAMES
	MOVE C,SYSN
	MOVE T,MNAMPT
MLOOK:	CAMN C,MDIR(T)	;LOOK UP SYSTEM NAME
	JRST MLOOK1
	ADDI T,2
	CAIGE T,2000
	JRST MLOOK
	JSR ESNF,ERROR	;NOT FOUND

MLOOK1:	MOVEI TRACK,-1467(T)	;CONVERT USER SLOT TO TRACK NUMBER
	LSH TRACK,-1
	HRRM TRACK,UDTRK	;REMEMBER FOR KILL OR DUMP
	MOVEI UNIT,UDIR
	JSP TT,RDM	;READ USER DIRECTORY
ULOOK:	CAME C,UNAM
	JSR ECDR,ERROR	;WRONG ONE??
	CAIE CMD,'F
	CAIN CMD,'U
	JRST LISTFC	;LIST USER DIRECTORY
	MOVSI TT,WKBTS
	MOVE T,UNAMPT
	MOVE A,FN1
	MOVE B,FN2
ULOOK1:	CAMN A,UFN1(T)	;LOOK UP FILE NAME
	CAME B,UFN2(T)
	JRST ULOOK2
	TDNN TT,UFBTS(T)	;IS THIS FILE FOR REAL?
	JRST ULOOK3
ULOOK2:	ADDI T,5
	CAIGE T,2000
	JRST ULOOK1
	CAIE CMD,'D	;IF NOT FOUND BETTER BE DUMP
	JSR EFNF,ERROR
	MOVE T,UNAMPT
ULOOK4:	SKIPN UFN1(T)	;FIND FREE SLOT FOR NEW FILE
	JRST DUMP
	ADDI T,5
	CAIGE T,2000
	JRST ULOOK4
	MOVNI T,5	;NO FREE SLOTS--TRY TO EXTEND NAME AREA DOWN
	ADDM T,UNAMPT
	MOVE T,UDIR
	IDIVI T,6
	ADDI T,UDESC-UDIR
	CAMGE T,UNAMPT	;DID WE RUN INTO DESCRIPTOR AREA?
	JRST DUMP0
	JSR EDIR,ERROR	;YES
ULOOK3:	HRRM T,DMP4	;IF FILE FOUND, SAVE SLOT NUMBER FOR DUMP
	LDB C,[1500+T,,UFBTS]
	JSP TT,GBP
	MOVEM C,DIRPT	;SET UP DESCRIPTOR AREA BYTE POINTER
	MOVSI TT,1
	TDNE TT,UFBTS(T)
	JRST LINK	;FILE IS A LINK
	LDB A,[150500+T,,UFBTS]	;GET PACK NUMBER
ULOOK5:	CAMN A,PKNO	;SEE IF IT'S MOUNTED
	JRST LOAD
	JSP TT,NXTMDR
	JRST ULOOK5
	JSR EPNM,ERROR

LOAD:	CAIE CMD,'D	;GET HERE IF FILE FOUND
	CAIN CMD,'K	;IF DUMP OR KILL, DELETE IT
	JRST KILL
ZERO:	MOVEI TT,CORE-1
	TRNN CMD,20
	JRST ZERO1
	MOVE B,SADR
	SUBI B,1
	JSP P,FD	;GET DDT'S SYMBOL TABLE POINTER
	JSR EDDT,ERROR	;CAN'T GET IT??
	HRROS B,(C)	;TELL DDT ITS SYMBOL TABLE WAS BUGGERED
	HRRM B,LOADS4
	JSP P,FD
	JSR EDDT,ERROR
	MOVE D,(C)
	MOVEM D,DDTM2
	MOVEI TT,CORE-1
	CAILE TT,(D)
	HRRZ TT,D
ZERO1:	TRNE CMD,1
	JRST LOAD1	;NON-ZEROING COMMAND
	CLEARM 40
	MOVE T,[40,,41]
	BLT T,(TT)	;CLEAR REAL CORE
	TRNE CMD,20
	JRST LOAD1	;IF SYMBOL-LOADING COMMAND, STOP THERE
	CLEARM CBUF
	MOVE T,[CBUF,,CBUF+1]
	BLT T,CBUF+1777
	MOVEI UNIT,CBUF
	MOVE TRACK,[-5,,CTRK]
	JSP TT,WRM	;CLEAR PSEUDO-CORE
	AOBJN TRACK,.-1
LOAD1:	MOVEI BUFP,0	;SET UP BUFP SO FIRST CALL TO WD WILL READ
LOAD2:	JSP P,WD	;FIRST BLOCK OF FILE
	CAME D,[JRST 1]	;LOOK FOR END OF SBLK LOADER
	JRST LOAD2
	CAIN CMD,'I	;IF VERIFY, START SIMULATING DUMP
	JRST DUMP.5
LOAD3:	JSP P,WD	;READ BLOCK HEADER
	JUMPGE D,LOADS	;IT'S A JUMP BLOCK
	MOVE A,D
	MOVE B,D
	JSR LOADB	;LOAD LOGICAL BLOCK INTO CORE
	JRST LOAD3

LOADS:	TRNN CMD,20
	JRST LOADJ	;DON'T LOAD SYMBOLS
LOADS1:	MOVE B,DDTM2
	JSP P,WD	;GET SYMBOL BLOCK HEADER
	JUMPGE D,LOADS2	;JUMP IF END OF SYMBOLS
	MOVSS D
	HRLI D,-1(D)
	ADD B,D	;EFFECTIVELY SUBTRACTS LENGTH OF BLOCK FROM BOTH HALVES
	MOVEM B,DDTM2	;OF SYMBOL TABLE POINTER
	HRL B,D	;SET UP AOBJN POINTER IN B
	HRLZ A,D	;AND RECREATE HEADER IN A
	JSR LOADB	;LOAD THE SYMBOLS
	JRST LOADS1

LOADS2:	MOVE D,DDTM2
LOADS4:	MOVEI B,.	;PNTR TO SYMTAB PNTR
	JSP P,FD	;PUT BACK SYMBOL TABLE POINTER
	JSR EBUG,ERROR	;CAN'T PUT IT BACK??
	MOVEM D,(C)
	JRST LOADG0

LOADJ:	HRRM D,SADR	;SET STARTING ADDRESS FROM JUMP BLOCK
LOADG0:	MOVEI B,ERROR
	JSP P,FD	;GET 776000 BLOCK INTO CBUF
	JSR EBUG,ERROR
	MOVE T,[CBOOT,,CBUF+1700]
	BLT T,CBUF+1776	;RESTORE BOOTSTRAP LOADER
	MOVEI T,BOOT2
	HRRM T,CBUF+1701	;WITH A CHANGE
LOADG:	JSP TT,WRCB	;MAKE SURE ALL LOADED CRUFT IN PSEUDO-CORE IS OUT
	MOVEI WRITE,0
	JSP P,LODUMP	;AND LOAD IT ALL IN
	TRNE CMD,10
	JRST READ	;NON-GOING COMMAND
GO:	LDB T,[10200,,MU]
	MOVEI DIFF,202.	;FIGURE OUT DIFFERENCE CONO
	SUB DIFF,POS(T)
	XORI DIFF,377
	LSH DIFF,6
	MOVEI T,ERROR
	IORI T,@MU
	DATAO DSK,T	;GET THINGS GOING
	CONO DSK,CONTROL\RESETHD
	CONO DSK,SETCYL
	CONO DSK,SETHD\FORW+<4_6>
	CONO DSK,SETDIFF(DIFF)
	HRRZ 17,SADR	;PACK INFO INTO ACS
	HRL 17,-1
	ASH 17,6
	LDB 16,BOOT4
	ADD 17,16
	ASH 17,4
	LDB 16,BOOT3
	ADD 17,16
	MOVSI 16,777760
	BLT 16,16
	CONO DSK,CONTROL\SEEK
	CONO DSK,CONTROL\BUSY	;START TRANSFER
	JRST WAIT

LOADB:	0
LOAD4:	JSP P,WD	;LOAD A LOGICAL BLOCK--AOBJN POINTER IN B,
	ROT A,1	;BLOCK HEADER IN A (FOR CHECKSUM)
	ADD A,D	;ADD NEW WORD INTO CHECKSUM
	JSP P,FD	;AND PREPARE TO SMASH IT AWAY
	JRST .+2	;LOCATION CAN'T BE LOADED
	MOVEM D,(C)	;SMASH WORD AWAY
	AOBJN B,LOAD4
	JSP P,WD
	CAMN A,D	;CHECK THE CHECKSUM
	JRST @LOADB
	JSR ECKS,ERROR	;BAD CHECKSUM

LISTS:	JSP P,CRLF
LISTS2:	CONSZ TTY,40
	JRST LOADG1	;SHUT UP IF KEY HIT
	MOVE C,PKNO	;TYPE PACK NUMBER
	JSP TT,PNO
	MOVE D,PKID	;AND I.D.
	JSP TT,PD2
	JSP TT,NXTMDR	;SAME FOR ALL DIRECTORIES
	JRST LISTS2
	JSP TT,RDMDR	;READ MASTER UNIT MASTER DIRECTORY AGAIN
	MOVE T,MNAMPT
LISTS1:	SKIPE D,MDIR(T)
	JSP TT,PD	;TYPE OUT USER NAME
	ADDI T,2
	CONSO TTY,40	;STOP TYPING IF TTI FLAG ON
	CAIL T,1777
	JRST LOADG1
	JRST LISTS1

LISTFC:	MOVE T,UNAMPT
LISTF1:	SKIPN UFN1(T)	;SKIP IF FILE IN THIS SLOT
	JRST LISTF2
	JSP P,CRLF
	LDB C,[150500+T,,UFBTS]
	JSP TT,PNO	;TYPE PACK NUMBER
	MOVE D,UFN1(T)
	JSP TT,PD2	;TYPE FIRST FILE NAME
	MOVE D,UFN2(T)
	JSP TT,PD2	;AND SECOND FILE NAME
LISTF2:	ADDI T,5
	CONSO TTY,40	;STOP TYPING IF TTI FLAG ON
	CAIL T,2000
	JRST LOADG1
	JRST LISTF1

KILL:	JSP TT,NXTB6	;GET HERE ON KILL OR DUMP OF EXISTING FILE
	MOVEI T,0	;ZERO BYTES IN USER DIRECTORY DESCIPTOR AREA
	DPB T,DIRPT	;NXTB6 JUMPS TO KILL1 AT END OF FILE
	MOVE C,TRACK
	JSP TT,GBP
	SUBI C,UDESC-MTUT	;GET POINTER TO TRACK USAGE TABLE
	ILDB T,C
	CAIGE T,76	;SOS USAGE OF THIS TRACK
	JUMPN T,[SOJA T,.+1]
	DPB T,C
	JRST KILL
KILL1:	HRRZ T,DMP4	;CLEAR OUT USER DIRECTORY SLOT
	CLEARM UFN1(T)
	CLEARM UFN2(T)
	CLEARM UFBTS(T)
	CLEARM UDATM(T)
	MOVSI WRITE,-1
	CAIN CMD,'K
	JRST KILDMP	;IF KILL DON'T DUMP
	JRST DMP4	;MUST DUMP ON SAME UNIT

DUMP0:	MOVE T,UNAMPT	;GET HERE IF SLOT CREATED AT BOTTOM OF NAME AREA
DUMP:	HRRM T,DMP4	;GET HERE IF EMPTY SLOT FOUND IN NAME AREA
DMP0:	MOVEI D,0	;GET HERE IF USING SLOT OF OLD FILE
	HRRZ B,CU	;FIND PACK WITH MOST FREE TRACKS
DMP1:	MOVE A,[440600,,MTUT]	;COUNT FREE TRACKS ON THIS DISK
	MOVSI C,-2000.
DMP2:	ILDB T,A
	SKIPE T
	SUBI C,1
	AOBJN C,DMP2
	CAIG C,(D)	;RH OF D IS HIGHEST SO FAR, LH SAYS WHICH UNIT
	JRST DMP5	;NOT BETTER THAN RECORD
	MOVE D,C	;NEW RECORD--RECORD IT
	HRL D,B
DMP5:	JSP TT,NXTMDR	;TRY NEXT
	JRST DMP1

DMP3:	HLRM D,CU	;SET CURRENT UNIT TO ONE WITH MOST FREE TRACKS
	JSP TT,RDMDR	;GET ITS MASTER DIRECTORY
DMP4:	MOVEI T,.
	MOVE A,FN1
	MOVE B,FN2
	MOVEM A,UFN1(T)	;PUT CRUFT INTO SLOT
	MOVEM B,UFN2(T)
	SETOM UDATM(T)
	MOVE C,UDIR	;PUT DESCRIPTOR CHARACTER ADDRESS
	MOVE B,PKNO	;AND PACK NUMBER
	DPB B,[150500,,C]
	MOVEM C,UFBTS(T)	;INTO USER DIRECTORY SLOT
	MOVE T,[440600,,MTUT]
	MOVEM T,TUTPT	;INITIALIZE TRACK USAGE TABLE POINTER
	MOVE C,UDIR
	JSP TT,GBP
	MOVEM C,DIRPT	;INITIALIZE DESCRIPTOR AREA POINTER
	SETOB WRITE,LTRACK	;LAST TRACK WRITTEN WAS -1 (HA HA)
	CLEARM BLKCNT	;AND WE'VE SO FAR WRITTEN 0 TRACKS IN A ROW
	HRLOI BUFP,-2002	;SET UP BUFP SO FIRST WORD GOES IN DBUF+0
	MOVE D,[JRST 1]
	JSP P,WD	;END OF SBLK LOADER
DUMP.5:	MOVSI WRITE,-'I(CMD)	;GET HERE IF VERIFY--SET WRITE NEGATIVE IF
	MOVEI B,20	;DUMP AND ZERO IF VERIFY--FIRST ADDR DUMPED IS 20
	CLEARM C0	;MAKE 63 AND 64 APPEAR TO BE 0 (SEE FD)
DUMP1:	JSP P,FD
	JRST DUMPJ	;TIME TO WRITE JUMP BLOCK
	SKIPN (C)	;LOOK FOR NON-ZEROES
	AOJA B,DUMP1
	MOVE A,B	;FOUND SOME
	HRLI B,-200	;DON'T DUMP MORE THAN 200 OF THEM
DUMP2:	JSP P,FD
	JRST DUMP3	;END OF CORE--WRITE OUT THIS BLOCK
	SKIPE (C)	;LOOK FOR ZEROES
	JRST DUMP2A
	AOBJP B,DUMP3	;JUMPS IF WE HAVE 200 WORDS' WORTH OF CRUD ANYWAY
	JSP P,FD
	JRST DUMP3
	SUBI B,1
	SKIPE (C)	;IF NOT TWO ZEROES DON'T END BLOCK
DUMP2A:	AOBJN B,DUMP2	;UNLESS THERE ARE ALREADY 200 WORDS
DUMP3:	HRRM B,DUMP4	;SAVE ADDRESS TO CONTINUE SEARCH
	SUBM A,B	;GET MINUS THE LENGTH OF THE BLOCK
	HRL A,B	;SET UP HEADER IN A
	MOVE B,A	;AND B
	MOVE D,A	;AND D
	JSP P,WD	;WRITE HEADER
DUMP3A:	JSP P,FD
	JSR EBUG,ERROR	;CAN'T FETCH WORD WE FETCHED BEFORE??
	MOVE D,(C)
	ROT A,1
	ADD A,D	;COMPUTE CHECKSUM
	JSP P,WD
	AOBJN B,DUMP3A
	MOVE D,A
	JSP P,WD	;WRITE OUT CHECKSUM
DUMP4:	MOVEI B,.	;AND CONTINUE SEARCHING
	JRST DUMP1

DUMPJ:	MOVE D,SADR
	JSP P,WD	;WRITE OUT JUMP BLOCK
	JUMPE WRITE,LOADG1	;IF VERIFY, THAT'S ALL
	JSP P,WD	;INDICATE NO SYMBOLS IN FILE
	JSP TT,NXTBLK
	JSP TT,WRDB	;WRITE OUT LAST TRACK
	SKIPE T,BLKCNT
	JSR NXTBW3	;STORE LAST DESCRIPTOR BYTE
	MOVEI T,0
	JSR NXTBW3	;AND INDICATE END OF FILE
	LDB T,[360600,,DIRPT]
	IDIVI T,6
	HRRZ TT,DIRPT
	IMULI TT,6
	SUBI TT,6*UDESC-5-1(T)
	HRRZM TT,UDIR	;INDICATE NEW END OF DESCRIPTOR AREA
KILDMP:	MOVEI UNIT,MDIR
	MOVEI TRACK,MDIRTK
	JSP TT,WRD	;WRITE OUT MASTER DIRECTORY ON THIS UNIT
	HRRZ B,CU
	HRRM B,KD2	;WRITE OUT USER DIRECTORY ON ALL UNITS
KD1:	LSH B,1
	TRNE B,UX
	MOVEI B,U0
	HRRM B,CU
	TDNE B,UNITS
	JRST KD2
	MOVE UNIT,B
	MOVEI UNIT,UDIR
UDTRK:	MOVEI TRACK,.
	JSP TT,WR
KD2:	TRNE B,.
	JRST LOADG1
	JRST KD1

ERRCT:	0	;ERROR COUNTER
DDTM2:	0	;DDT SYMBOL TABLE POINTER
POS:	REPEAT NDSK,-1	;DISK POSITIONS- -1 MEANS UNKNOWN
LTRACK:	0	;LAST TRACK WRITTEN OR READ
BLKCNT:	0	;NUMBER OF TRACKS READ OR WRITTEN CONSECUTIVELY
DIRPT:	0	;DESCRIPTOR AREA BYTE POINTER
TUTPT:	0	;TRACK USAGE TABLE BYTE POINTER
UNITS:	0	;SELECT BIT ON FOR UNITS NOT ON LINE
FN1:	0	;FILE NAME 1
FN2:	0	;FILE NAME 2
CONSTA
BLOCK <.\67>-.
C0:	0	;CONSTANT ZERO (PSEUDO-63 AND 64)
BADTRK:	0	;TRACK WITH HDWE ERROR
IRP XX,,\<.-1>
IF1,PRINTX  BADTRK=XX
 TERMIN
BLOCK ERROR+1700-.

CBOOT:	CLEARM -1	;BOOTSTRAP
BOOT:	JRST BEG	;OR BOOT2 OR LOADG1
BOOT1:	ERROR+U0
BOOT3:	400,,BOOT1
BOOT4:	360600,,-1
BOOT5:	300400,,17
BOOT2:	CONO 635550
	DATAO DSK,BOOT1
	MOVEI 0,6000.
	CONO DSK,CONTROL\RET0\BUSY\DONE
	SOJG 0,.
	CONO DSK,0
	AOBJP 0,.
	CONO DSK,CONTROL\RESETHD	;DUMP OUT TOP BLOCK OF MEMORY
	CONO DSK,SETCYL
	CONO DSK,SETHD\FORW+<4_6>
	CONO DSK,SETDIFF+<<202.#377>_6>
	CONO DSK,CONTROL\SEEK
	CONO DSK,CONTROL\WRBIT\BUSY
	CONSO DSK,DONE
	JRST .-1
.....:	LDB 16,BOOT3	;PACK INFO INTO ACS
	HRLZ 17,-1
	ADD 17,-1
	DPB 16,BOOT5
	HRR 17,SADR
	MOVSI 16,777760
	BLT 16,16
	DATAO DSK,BOOT1	;READ DSKDMP INTO TOP BLOCK OF MEMORY
	CONO DSK,CONTROL\RESETHD
	CONO DSK,SETCYL
	CONO DSK,SETHD+<5_6>
	CONO DSK,CONTROL\BUSY
	CONSO DSK,DONE
	JRST .-1
	JRST BEG
WAIT:	CONSO DSK,DONE	;WAIT FOR LAST BLOCK OF MEMORY TO BE LOADED
	JRST .-1
	DPB 17,BOOT3	;UNPACK INFO FROM ACS
	ASH 17,-4
	DPB 17,BOOT4
	ASH 17,-6
	HRRM 17,SADR
	HLRM 17,-1
	MOVEI 17,777760
	BLT 17,-1-1
SADR:	JRST BOOT	;AND GO TO PROGRAM TO BE STARTED
IFG .-777760,PRINTX ;NUTS
;
BLOCK ,-2-.
SYSN:	SIXBIT \.\
	700,,777740
THEEND:

OFFSET 0
OFFSET CORE-.
CBUF:	BLOCK 2000	;PSEUDO-CORE BUFFER
DBUF:	BLOCK 2000	;DISK BUFFER
MDIR:	0	;MASTER DIRECTORY BUFFER
	0
PKID:	0
PKNO:	0
MNAMPT:	0
MTUT=MDIR+13
BLOCK 2000+MDIR-.
UDIR:	0	;USER DIRECTORY BUFFER
UNAMPT:	0
UNAM:	0
UFN1=UDIR
UFN2=UDIR+1
UFBTS=UDIR+2
UDATM=UDIR+3
UDESC=UDIR+13
BLOCK 2000+UDIR-.
IFN .-ERROR,PRINTX ;UGH
;
OFFSET 0
END ...
RST ULOOK4
	MOVNI T,5	;NO FREE SLOTS--TRY TO EXTEND NAME AREA DOWN
	ADDM T,UNAMPT
	MOVE T,UDIR
	IDIVI T,6
	ADDI T,UDESC-UDIR
	CAMGE T,UNAMPT	;DID WE RUN INTO DESCRIPTOR AREA?
	JRST DUMP0
	JSR EDIR,ERROR	;YES
ULOOK3:	HRRM T,DMP4	;IF FILE FOUND, SAVE SLOT NUMBER FOR DUMP
	LDB C,[1500+T,,UFBTS]
	JSP TT,GBP
	MOVEM C,DIRPT	;SET UP DESCRIPTOR AREA BYTE POINTER
	MOVSI TT,1
	TDNE TT,UFBTS(T)
	JRST LINK	;FILE IS A LINK
	LDB A,[150500+T,,UFBTS]	;GET PACK NUMBER
ULOOK5:	CAMN A,PKNO	;SEE IF IT'S MOUNTED
	JRST LOAD
	JSP TT,NXTMDR
	JRST ULOOK5
	JSR EPNM,ERROR

LOAD:	CAIE CMD,'D	;GET HERE IF FILE FOUND
	CAIN CMD,'K	;IF DUMP OR KILL, DELETE IT
	JRST KILL
ZERO:	MOVEI TT,CORE-1
	TRNN CMD,20
	JRST ZERO1
	MOVE B,SADR
	SUBI B,1
	JSP P,FD	;GET DDT'S SYMBOL TABLE POINTER
	JSR EDDT,ERROR	;CAN'T GET IT??
	HRROS B,(C)	;TELL DDT ITS SYMBOL TABLE WAS BUGGERED
	HRRM B,LOADS4
	JSP P,FD
	JSR EDDT,ERROR
	MOVE D,(C)
	MOVEM D,DDTM2
	MOVEI TT,CORE-1
	CAILE TT,(D)
	HRRZ TT,D
ZERO1:	TRNE CMD,1
	JRST LOAD1	;NON-ZEROING COMMAND
	CLEARM 40
	MOVE T,[40,,41]
	BLT T,(TT)	;CLEAR REAL CORE
	TRNE CMD,20
	JRST LOAD1	;IF SYMBOL-LOADING COMMAND, STOP THERE
	CLEARM CBUF
	MOVE T,[CBUF,,CBUF+1]
	BLT T,CBUF+1777
	MOVEI UNIT,CBUF
	MOVE TRACK,[-5,,CTRK]
	JSP TT,WRM	;CLEAR PSEUDO-CORE
	AOBJN TRACK,.-1
LOAD1:	MOVEI BUFP,0	;SET UP BUFP SO FIRST CALL TO WD WILL READ
LOAD2:	JSP P,WD	;FIRST BLOCK OF FILE
	CAME D,[JRST 1]	;LOOK FOR END OF SBLK LOADER
	JRST LOAD2
	CAIN CMD,'I	;IF VERIFY, START SIMULATING DUMP
	JRST DUMP.5
LOAD3:	JSP P,WD	;READ BLOCK HEADER
	JUMPGE D,LOADS	;IT'S A JUMP BLOCK
	MOVE A,D
	MOVE B,D
	JSR LOADB	;LOAD LOGICAL BLOCK INTO CORE
	JRST LOAD3

LOADS:	TRNN CMD,20
	JRST LOADJ	;DON'T LOAD SYMBOLS
LOADS1:	MOVE B,DDTM2
	JSP P,WD	;GET SYMBOL BLOCK HEADER
	JUMPGE D,LOADS2	;JUMP IF END OF SYMBOLS
	MOVSS D
	HRLI D,-1(D)
	ADD B,D	;EFFECTIVELY SUBTRACTS LENGTH OF BLOCK FROM BOTH HALVES
	MOVEM B,DDTM2	;OF SYMBOL TABLE POINTER
	HRL B,D	;SET UP AOBJN POINTER IN B
	HRLZ A,D	;AND RECREATE HEADER IN A
	JSR LOADB	;LOAD THE SYMBOLS
	JRST LOADS1

LOADS2:	MOVE D,DDTM2
LOADS4:	MOVEI B,.	;PNTR TO SYMTAB PNTR
	JSP P,FD	;PUT BACK SYMBOL TABLE POINTER
	JSR EBUG,ERROR	;CAN'T PUT IT BACK??
	MOVEM D,(C)
	JRST LOADG0

LOADJ:	HRRM D,SADR	;SET STARTING ADDRESS FROM JUMP BLOCK
LOADG0:	MOVEI B,ERROR
	JSP P,FD	;GET 776000 BLOCK INTO CBUF
	JSR EBUG,ERROR
	MOVE T,[CBOOT,,CBUF+1700]
	BLT T,CBUF+1776	;RESTORE BOOTSTRAP LOADER
	MOVEI T,BOOT2
	HRRM T,CBUF+1701	;WITH A CHANGE
LOADG:	JSP TT,WRCB	;MAKE SURE ALL LOADED CRUFT IN PSEUDO-CORE IS OUT
	MOVEI WRITE,0
	JSP P,LODUMP	;AND LOAD IT ALL IN
	TRNE CMD,10
	JRST READ	;NON-GOING COMMAND
GO:	LDB T,[10200,,MU]
	MOVEI DIFF,202.	;FIGURE OUT DIFFERENCE CONO
	SUB DIFF,POS(T)
	XORI DIFF,377
	LSH DIFF,6
	MOVEI T,ERROR
	IORI T,@MU