(declare (special formmap))

(defun show-list n
       (cond ((zerop n)
	      (cond ((or (not (boundp 'formmap))
			 (not formmap))
		     (terpri)
		     (princ '|Type in a list: |)
		     (show-list (read)))
		    (t (show))))
	     (t (cond ((atom (arg 1)) (arg 1))
		      ((showp (arg 1) t) (show))
		      (t (arg 1))))))

(defun showp (form flag)
       (cond ((catch (cond ((atom form) t)
			   (t (setq formmap
				    (array nil
					   t
					   (min (// (car (status ttysize)) 5.)
						100.)
					   (// (cdr (status ttysize)) 12.)))
			      (plot form 0 0 flag)
			      t)))
	      t)
	     (t (setq formmap nil))))

(defun plot (form x y flag)
  (and (= y (caddr (arraydims formmap)))
       (throw
	(prog2 (cond (flag
		      (terpri)
		      (princ '|I'm afraid that won't fit on your terminal.|)
		      (terpri)
		      (princ '|Try something that isn't so long.|)))
	       nil)))
  (store (arraycall t formmap x y) form)
  (cond ((atom (cdr form)) nil)
	(t (plot (cdr form) x (1+ y) flag)))
  (cond ((atom (car form)) nil)
	(t (plot (car form)
		 (downp (car form) (1+ x) y flag)
		 y
		 flag)))))

(defun downp (form x y flag)
  (and (= x (cadr (arraydims formmap)))
       (throw
	(prog2
	 (cond (flag
		(terpri)
		(princ '|I'm afraid that won't fit on your terminal.|)
		(terpri)
		(princ '|Try something without so many nested parentheses.|)))
	 nil)))
  (do ((f form (cdr f))
       (j y (1+ j)))
      ((atom f) x)
      (and (= j (caddr (arraydims formmap)))
	   (throw
	    (prog2
	     (cond (flag
		    (terpri)
		    (princ '|I'm afraid that won't fit on your terminal.|)
		    (terpri)
		    (princ '|Try something with shorter lists in it.|)))
	     nil)))
      (and (arraycall t formmap x j)
	   (store (arraycall t formmap x y) 0.)
	   (return (downp form (1+ x) y flag)))))

(defun show ()
       (let ((sfa))
	    (cursorpos 'c tyo)
	    (setq sfa (sfa-create 'sfa-handler 3 'foo))
	    (sfa-call sfa 'init ())
	    (arrayprint sfa)
	    (close sfa)
	    (arraycall t formmap 0 0)))

(defun arrayprint (sfa)
       (prog (flag w l)
	     (setq flag nil)
	     (setq w (caddr (arraydims formmap)))
	     (setq l (cadr  (arraydims formmap)))
	     (do i 0 (1+ i) (or flag (= i l))
		 (setq flag t)
		 (do j 0 (1+ j) (= j w)
		     (cond ((null (arraycall t formmap i j)) nil)
			   (t (setq flag nil)
			      (cursorpos (* 5 i) (* 12. j) sfa) 
			      (consprint (arraycall t formmap i j)
					 (* 5 i) (* 12. j) sfa)))))))

(defun consprint (form i j sfa)
       (cond ((numberp form) (barprint sfa))
	     ((atom (car form))
	      (cellprint (car form) i j sfa)
	      (cdrcases (cdr form) sfa))
	     (t (treeprint i j sfa)
		(cdrcases (cdr form) sfa))))

(defun barprint (sfa)
       (princ '|  /|| sfa)
       (do i 0 (+ i 1) (= i 3)
	   (cursorpos 'd sfa)
	   (cursorpos 'b sfa)
	   (princ '/| sfa))
       (cursorpos 'd sfa)
       (cursorpos 'b sfa)
       (princ 'V sfa))

(defun cellprint (a x y sfa)
       (princ '|/|---/|---/|| sfa)
       (cursorpos (+ x 2) y sfa)
       (princ '|/|---/|---/|| sfa)
       (cursorpos (+ x 1) y sfa)
       (princ '|/|| sfa)
       (princ (mush a) sfa)
       (princ '|/|| sfa))

(defun treeprint (x y sfa)
       (princ '|/|---/|---/|| sfa)
       (cursorpos (+ x 2) y sfa)
       (princ '|/|-+-/|---/|| sfa)
       (cursorpos (+ x 3) (+ y 2) sfa)
       (princ '/| sfa)
       (cursorpos (+ x 4) (+ y 2) sfa)
       (princ 'V sfa)
       (cursorpos (+ x 1) y sfa)
       (princ '|/| /| /|| sfa))

(defun nilprint (sfa) (princ '| // /|| sfa))

(defun arrowprint (sfa) (princ '| --+-->| sfa))

(defun mush (x)
  (implode
   (do ((l (explodec x) (cdr l))
	(nl () (cons (car l) nl))
	(i 0. (1+ i)))
       ((> i 2.) (nreverse nl))
       (and (null l)
	    (return (cond ((= i 2.)
			   (cons '| | (nreverse nl)))
			  (t (cons '| |
				      (nreverse (cons '| | nl))))))))))
								    
(defun cdrcases (a sfa)
       (cond ((null a)
	      (nilprint sfa))
	     ((atom a)
	      (cdrprint a sfa))
	     (t (arrowprint sfa))))


(defun cdrprint (a sfa)
       (princ (mush a) sfa)
       (princ '|/|| sfa))

(defun sfa-handler (self op data)
  (caseq op (which-operations '(init cursorpos close tyo))
	 (init (sfa-store self 0.
			  (array nil fixnum
				 (min (car (status ttysize)) 500.)
				 (1- (cdr (status ttysize)))))
	       (sfa-store self 1. 0.)
	       (sfa-store self 2. 0.))
	 (cursorpos (cond ((equal data '(b))
			   (sfa-store self 2. (1- (sfa-get self 2.))))
			  ((equal data '(d))
			   (sfa-store self 1. (1+ (sfa-get self 1.))))
			  (t (sfa-store self 1. (car data))
			     (sfa-store self 2. (cadr data)))))
	 (tyo (store (arraycall fixnum (sfa-get self 0.)
				(sfa-get self 1.) (sfa-get self 2.))
		     data)
	      (sfa-store self 2. (1+ (sfa-get self 2))))
	 (close (prog (w l c flag)
		      (setq l (cadr (arraydims (sfa-get self 0.))))
		      (setq w (caddr (arraydims (sfa-get self 0.))))
		      (do i 0 (1+ i) (or (= i l) flag)
			  (setq flag t)
			  (do j 0 (1+ j) (= j w)
			      (setq c (arraycall fixnum
						 (sfa-get self 0.)
						 i j))
			      (cond ((zerop c) (tyo 32. tyo))
				    (t (setq flag nil)
				       (tyo c tyo))))
			  (terpri))))))