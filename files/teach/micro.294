;;; -*- LISP -*-

(EVAL-WHEN (EVAL COMPILE) (SETQ VERSION (CADDR (TRUENAME INFILE))))

(EVAL-WHEN (EVAL COMPILE)
	   (COND ((NOT (STATUS FEATURE IOTA))
		  (LOAD '((DSK LIBLSP) IOTA FASL)))))

(DEFUN *VERSION MACRO (()) `',VERSION)

(DEFUN UNIX-LISP-VERSION () (*VERSION))

(DEFUN |quote| FEXPR (X) (CAR X)) ; Avoid hassles

(SETQ BASE 10. IBASE 10. *NOPOINT T
      MAKHUNK NIL) ; Don't allow (a . b . c .) input syntax for hunks

(SETQ GC-OVERFLOW '(LAMBDA (X) T))

(DECLARE (SPECIAL MICRO:ALIST UNIX:PROG-FLAG |()| |)(|
		  MICRO:BACKLIST MICRO:BACKTRACE MICRO:IBASE MICRO:OBASE
		  MICRO:GENSYM-PREFIX MICRO:GENSYM-COUNTER
		  MICRO:PROMPT MICRO:PROMPTME MICRO:UNBOUND-ERRORS
		  UNIX:DEBUG 
		  STANDARD-OUTPUT STANDARD-OUTPUT-FILES
		  UNIX:SCRIPT-FILE UNIX:SCRIPT-FILENAME)
	 (*LEXPR UNIX:EVAL))

(SETQ UNIX:SCRIPT-FILENAME '(UNXLPT >))

(SETQ UNIX:DEBUG T)

(SETQ UNIX:SCRIPT-FILE ())

(SETQ MICRO:PROMPT '|Lisp->|)
(SETQ MICRO:PROMPTME T)
(SETQ MICRO:IBASE 10.)
(SETQ MICRO:OBASE 10.)
(SETQ MICRO:GENSYM-PREFIX '/g)
(SETQ MICRO:GENSYM-COUNTER 0)
(SETQ |()| NIL)
(SETQ |)(| (MAKNAM '(N I L)))
(SETQ MICRO:BACKLIST NIL MICRO:BAKTRACE '|t|)

(EVAL-WHEN (EVAL COMPILE)
	   (SSTATUS MACRO /# '+INTERNAL-/#-MACRO SPLICING))

(EVAL-WHEN (EVAL LOAD)
	   (SETQ MICRO:ALIST '|nil|))

(DEFUN STANDARD-OUTPUT-HANDLER (SELF OP DATA)
       (CASEQ OP
        ((WHICH-OPERATIONS) '(TYO CHARPOS))
	((TYO)
	 (COND ((NOT (MINUSP DATA))
		(MAPC #'(LAMBDA (X) (TYO DATA X)) STANDARD-OUTPUT-FILES))))
	((CHARPOS LINEL)
	 (FUNCALL OP (CAR STANDARD-OUTPUT-FILES)))
	(T
	 (ERROR '|UnSupported SFA Operation on STANDARD-OUTPUT-HANDLER|
		`(SFA-CALL ,SELF ,OP ,DATA)))))

(DEFUN UNIX:BEGIN-SCRIPT ()
    (COND (UNIX:SCRIPT-FILE NIL)
	  (T (SETQ ^R T)
	     (SETQ UNIX:SCRIPT-FILE (OPEN UNIX:SCRIPT-FILENAME 'OUT))
	     (PUSH UNIX:SCRIPT-FILE STANDARD-OUTPUT-FILES)
	     (PUSH UNIX:SCRIPT-FILE ECHOFILES)
	     (PUSH UNIX:SCRIPT-FILE MSGFILES)
	     T)))

(DEFUN UNIX:END-SCRIPT ()
    (COND ((NOT UNIX:SCRIPT-FILE) NIL)
	  (T (SETQ ^R ())
	     (SETQ MSGFILES  (DELETE UNIX:SCRIPT-FILE MSGFILES))
	     (SETQ ECHOFILES (DELETE UNIX:SCRIPT-FILE ECHOFILES))
	     (SETQ STANDARD-OUTPUT-FILES
		   (DELETE UNIX:SCRIPT-FILE STANDARD-OUTPUT-FILES))
	     (CLOSE UNIX:SCRIPT-FILE)
	     (SETQ UNIX:SCRIPT-FILE ())
	     T)))

(SETQ STANDARD-OUTPUT-FILES (NCONS TYO))

(SETQ STANDARD-OUTPUT
      (SFA-CREATE 'STANDARD-OUTPUT-HANDLER 0. '|Standard Output|))

(DEFUN ARRAY-TYPE MACRO (X) `(CXR 1. ,(CADR X)))
(DEFUN ARRAY-STORAGE MACRO (X) `(CXR 2. ,(CADR X)))
(DEFUN ARRAY-DIMS MACRO (X) `(CXR 3. ,(CADR X)))

(DEFUN NEWLINE MACRO (X) `(TERPRI ,(CADR X))) ; I give up...

(DEFUN LAMBDA MACRO (FORM) `(FUNCTION ,FORM))

(DEFUN MICRO:SUBR? (OBJECT)
       (AND (SYMBOLP OBJECT) (GET OBJECT 'MICRO:SUBR)))

(DEFUN MICRO:FSUBR? (OBJECT)
       (AND (SYMBOLP OBJECT) (GET OBJECT 'MICRO:FSUBR)))

(DEFUN MICRO:NLAMBDA? (OBJECT)
       (AND (NOT (ATOM OBJECT))
	    (EQ (CAR OBJECT) '|nlambda|)))

(DEFUN MICRO:LAMBDA? (OBJECT)
       (AND (NOT (ATOM OBJECT))
	    (EQ (CAR OBJECT) '|lambda|)))

(DEFUN MICRO:MACRO? (OBJECT)
       (AND (NOT (ATOM OBJECT))
	    (EQ (CAR OBJECT) '|macro|)))

(DEFUN MICRO:CLOSURE? (OBJECT)
       (AND (NOT (ATOM OBJECT))
	    (EQ (CAR OBJECT) '|closure|)
	    (OR (MICRO:LAMBDA?  (CADR OBJECT))
		(MICRO:NLAMBDA? (CADR OBJECT)))
	    (NOT (ATOM (CADDR OBJECT)))))

(DEFUN MICRO:EVAL (OBJECT)
   (LET ((MICRO:BACKLIST (COND (MICRO:BACKTRACE (CONS OBJECT MICRO:BACKLIST))
			       (T NIL))))
       (COND ((NUMBERP OBJECT) OBJECT)
	     ((AND (SYMBOLP OBJECT) (= (GETCHARN OBJECT 1.) #/#))
	      OBJECT)
	     ((ATOM OBJECT) (MICRO:SYMEVAL OBJECT))
	     (T
	      (LET ((FN (MICRO:EVAL (CAR OBJECT))))
		   (COND ((MICRO:SUBR? FN)
			  (MICRO:APPLY-MICRO-SUBR FN
						  (MICRO:MAP-EVAL
						   (CDR OBJECT))))
			 ((MICRO:FSUBR? FN)
			  (MICRO:APPLY-MICRO-FSUBR FN (CDR OBJECT)))
			 ((MICRO:MACRO? FN)
			  (MICRO:EVAL (MICRO:MACRO-EXPAND FN OBJECT)))
			 ((MICRO:NLAMBDA? FN)
			  (MICRO:APPLY FN (CDR OBJECT)))
			 ((MICRO:LAMBDA? FN)
			  (MICRO:APPLY FN (MICRO:MAP-EVAL (CDR OBJECT))))
			 ((MICRO:CLOSURE? FN) ;what a crock...
			  (LET ((ARG-LIST (COND ((MICRO:LAMBDA? (CADR FN))
						 (MICRO:MAP-EVAL (CDR OBJECT)))
						(T
						 (CDR OBJECT))))
				(MICRO:ALIST (CADDR FN)))
			       (MICRO:APPLY (CADR FN) ARG-LIST)))
			 (T
			  (MICRO:ERROR '|UNRECOGNIZED FUNCTIONAL FORM|
				       (LIST* (CAR OBJECT)
					      '-EVALS-TO->
					      FN
					      '|nil|)))))))))

(DEFUN MICRO:UNBOUND (VARNAME)
  (COND ((NOT MICRO:UNBOUND-ERRORS) '|nil|)
	(T (MICRO:ERROR '|UNBOUND VARIABLE| VARNAME))))

(DEFUN MICRO:VALUE-CELL (OBJECT)
       (DO ((L MICRO:ALIST (CDDR L)))
	   ((ATOM L) NIL)
	   (COND ((EQ (CAR L) OBJECT) (RETURN (CDR L))))))

(DEFUN MICRO:SYMEVAL (OBJECT)
       (LET ((LOOKUP (MICRO:VALUE-CELL OBJECT)))
	    (COND ((NULL LOOKUP) (MICRO:UNBOUND OBJECT))
		  (T (CAR LOOKUP)))))

(DEFUN MICRO:MACRO-EXPAND (MACRO-DEFINITION OBJECT)
       (MICRO:APPLY (CONS 'LAMBDA (CDR MACRO-DEFINITION)) (NCONS OBJECT)))

(DEFUN MICRO:APPLY (FN ACTUALS)
       (LET* (((FORMALS . BODY) (CDR FN))
	      (MICRO:ALIST (MICRO:BIND-ARGS FORMALS ACTUALS)))
	     (MICRO:MAP-EVAL-RETURNING-LAST-FORM BODY)))

(DEFUN MICRO:MAP-EVAL-RETURNING-LAST-FORM (BODY)
       (DO ((VAL (MICRO:EVAL (CAR BODY)) (MICRO:EVAL (CAR BODY))))
	   ((ATOM (CDR BODY)) VAL)
	   (POP BODY)))

(DEFUN MICRO:DEF-SUBR  MACRO (FORM) (MICRO:DEF FORM))
(DEFUN MICRO:DEF-FSUBR MACRO (FORM) (MICRO:DEF FORM))

(EVAL-WHEN (EVAL COMPILE)
  ; Simulate the effect of random pointers so that people don't come
  ; to rely on the pointers....
(SSTATUS RANDOM (- (APPLY '* (STATUS DATE)) (APPLY '* (STATUS DAYTIME))))
(SETQ MICRO:GEN-POINTER (+ 100. (RANDOM 200.)))
(DEFUN MICRO:GEN-POINTER ()
	 (LET ((*NOPOINT T) (BASE 8.) (L))
	      (SETQ L (EXPLODEN MICRO:GEN-POINTER))
	      (DO ((NL L (CONS #/0 NL))
		   (I (LENGTH L) (1+ I)))
		  ((= I 5.)
		   (SETQ MICRO:GEN-POINTER
			 (+ 1. MICRO:GEN-POINTER (RANDOM 50.)))
		   (IMPLODE (CONS '/# NL))))))

  (DEFUN MICRO:DEF (FORM)
	 (LET* (((TYPE (NAME ALIAS) BVL . BODY) FORM)
		(LOCATION (MICRO:GEN-POINTER))
		(LISP-TYPE (MICRO:DEF-LISP-TYPE TYPE))
		(MICRO-TYPE (MICRO:DEF-MICRO-TYPE TYPE)))
	      `(PROGN 'COMPILE
		      (DEFUN ,ALIAS ,@LISP-TYPE ,BVL ,@BODY)
		      (DEFPROP ,LOCATION ,ALIAS ,MICRO-TYPE)
		      ,(COND ((ATOM NAME)
			      `(SETQ MICRO:ALIST
				     (LIST* ',NAME ',LOCATION MICRO:ALIST)))
			     (T
			      `(MAPC (FUNCTION
				      (LAMBDA (X)
					      (SETQ MICRO:ALIST
						    (LIST* X
							   ',LOCATION
							   MICRO:ALIST))))
				     ',NAME))))))
  (DEFUN MICRO:DEF-MICRO-TYPE (X)
	 (COND ((EQ X 'MICRO:DEF-FSUBR) 'MICRO:FSUBR)
	       (T 'MICRO:SUBR)))
  (DEFUN MICRO:DEF-LISP-TYPE (X)
	 (COND ((EQ X 'MICRO:DEF-FSUBR) '(FEXPR)) (T NIL))))

(DEFUN MICRO:APPLY-MICRO-SUBR (FN ARG-LIST)
       (APPLY (GET FN 'MICRO:SUBR) (MICRO:FIX-LIST ARG-LIST)))

(DEFUN MICRO:APPLY-MICRO-FSUBR (FN ARG-LIST)
       (FUNCALL (GET FN 'MICRO:FSUBR) ARG-LIST))

(DEFUN MICRO:UNFIX-LIST (X)
       (DO ((L X (CDR L)))
	   ((ATOM L) '|nil|)
	   (COND ((ATOM (CDR L))
		  (RPLACD L '|nil|)
		  (RETURN X)))))

(DEFUN MICRO:FIX-FORM (X)
       (COND ((ATOM X) X)
	     ((ATOM (CDR X))
	      (CONS (MICRO:FIX-FORM (CAR X))
		    (COND ((EQ (CDR X) '|nil|) |()|)
			  (T (CDR X)))))
	     (T
	      (CONS (MICRO:FIX-FORM (CAR X))
		    (MICRO:FIX-FORM (CDR X))))))

(DEFUN MICRO:FIX-LIST (X)
       (DO ((X X (CDR X))
	    (L () (CONS (CAR X) L)))
	   ((ATOM X) (NREVERSE L))))

(DEFUN MICRO:MAP-EVAL (OBJECT)
       (DO ((X OBJECT (CDR X))
	    (L () (CONS (MICRO:EVAL (CAR X)) L)))
	   ((ATOM X) (NREVERSE L))))

(DEFUN MICRO:ERROR (MESSAGE DATA)
       (NEWLINE STANDARD-OUTPUT)
       (PRINC MESSAGE STANDARD-OUTPUT)
       (TERPRI STANDARD-OUTPUT)
       (MICRO:PRIN1 DATA STANDARD-OUTPUT)
       (TERPRI STANDARD-OUTPUT)
       (COND (MICRO:BACKTRACE (MICRO:SHOW-BACKTRACE)))
       (*THROW 'MICRO:ERROR-RETURN NIL))

(DEFUN MICRO:SHOW-BACKTRACE ()
       (DO ((L MICRO:BACKLIST (CDR L))
	    (I 1. (1+ I))
	    (END (COND ((FIXP MICRO:BACKTRACE) MICRO:BACKTRACE)
		       (T 999999.)))) ; Sufficiently large...
	   ((NULL L))
	   (TERPRI)
	   (COND ((> I END)
		  (PRINC '|... ETC.| STANDARD-OUTPUT)
		  (RETURN T)))
	   (MICRO:PRIN1 (CAR L) STANDARD-OUTPUT)))

(DEFUN MICRO:BIND-ARGS (FORMALS ACTUALS)
       (COND ((ATOM FORMALS)
	      (LIST* FORMALS (MICRO:UNFIX-LIST ACTUALS) MICRO:ALIST))
	     (T
	      (DO ((F FORMALS (CDR F))
		   (A ACTUALS (CDR A))
		   (L MICRO:ALIST   (LIST* (CAR F) (CAR A) L)))
		  ((COND ((AND (ATOM F) (ATOM A)) T)
			 ((ATOM A)
			  (MICRO:ERROR '|TOO FEW ARGUMENTS TO FUNCTION|
				       (LIST* ACTUALS
					      '-BEING-BOUND-TO->
					      FORMALS
					      '|nil|)))
			 ((ATOM F)
			  (MICRO:ERROR '|TOO MANY ARGUMENTS TO FUNCTION|
				       (LIST* (OR ACTUALS '|nil|)
					      '-BEING-BOUND-TO->
					      FORMALS
					      '|nil|))))
		   L)))))

(DEFUN MICRO:PRIN1 (OBJECT FILE-OBJECT)
       (FUNCALL (OR (GET 'PRIN1 'MICRO:PRIN1) 'PRIN1)
		OBJECT
		FILE-OBJECT))

(DEFUN MICRO:SPECIAL-CHAR? (X) (AND (CDR (EXPLODE X)) T))


(DEFUN PP$FLATSIZE-SFA-HANDLER (SELF OP DATA)
       (CASEQ OP
	      (WHICH-OPERATIONS '(INIT TYO SIZE))
	      (INIT (SFA-STORE SELF 0. 0.))
	      (TYO (COND ((NOT (MINUSP DATA))
			  (SFA-STORE SELF 0. (1+ (SFA-GET SELF 0.))))))
	      (SIZE (SFA-GET SELF 0.))
	      (T (ERROR '|ILLEGAL SFA OPERATION -- PP$FLATSIZE-SFA|))))

(DECLARE (SPECIAL PP$FLATSIZE-SFA))

(SETQ PP$FLATSIZE-SFA
      (SFA-CREATE 'PP$FLATSIZE-SFA-HANDLER 1. '|Circular File|))

(DEFUN PP$FLATSIZE (X)
       (PROG2 (PROGN (NOINTERRUPT T)
		     (SFA-CALL PP$FLATSIZE-SFA 'INIT NIL)
		     (FUNCALL (OR PRIN1 'PRIN1) X PP$FLATSIZE-SFA))
	      (SFA-CALL PP$FLATSIZE-SFA 'SIZE NIL)
	      (NOINTERRUPT NIL)))

(DEFUN $PP (X PRINTER STREAM) (LET ((PRIN1 PRINTER)) (PP X STREAM)))

(DEFUN PP (X STREAM) (TERPRI STREAM) (PP1 X STREAM))

(DEFUN PP1 (X STREAM)
       (COND ((ATOM X) (PP$ATOM X STREAM))
	     ((> (PP$FLATSIZE X) (PP$SIZE STREAM))
	      (PRINC '|(| STREAM)
	      (LET ((P (PP$POS STREAM)))
		   (PP1 (CAR X) STREAM)
		   (COND ((NOT (ATOM (CAR X)))
			  (PP$INDENT-TO (1- P) STREAM))))
	      (DO ((L (CDR X) (CDR L))
		   (FLAG NIL T)
		   (P (PP$POS STREAM)))
		  ((ATOM L)
		   (COND ((NOT (EQ L '|nil|))
			  (PRINC '| . | STREAM)
			  (PP$ATOM L STREAM)))
		   (PRINC '|)| STREAM))
		  (PRINC '| | STREAM)
		  (AND FLAG (PP$INDENT-TO (1+ P) STREAM))
		  (PP1 (CAR L) STREAM)))
	     (T
	      (PP$FORM X STREAM))))

(DEFUN PP$POS (STREAM) (CHARPOS STREAM))

(DEFUN PP$INDENT-TO (X STREAM)
       (TERPRI STREAM)
       (DO I 0. (1+ I) (= I X) (TYO #\SPACE STREAM)))

(DEFUN PP$FORM (X STREAM)
       (COND ((ATOM X) (PP$ATOM X STREAM))
	     (T
	      (PRINC '|(| STREAM)
	      (PP$FORM (CAR X) STREAM)
	      (DO ((L (CDR X) (CDR L)))
		  ((ATOM L)
		   (COND ((NOT (EQ L '|nil|))
			  (PRINC '| . | STREAM)
			  (PP$ATOM L STREAM)))
		   (PRINC '|)| STREAM))
		  (PRINC '| | STREAM)
		  (PP$FORM (CAR L) STREAM)))))

(DEFUN PP$ATOM (X STREAM) (COND ((EQ X '|nil|) (PRINC '|()| STREAM))
				(T (PRIN1 X STREAM))))

(DEFUN PP$SIZE (STREAM) (- (LINEL STREAM) (CHARPOS STREAM)))


(DEFUN CHECK-ARGS-DATATYPE N
       (LET ((PRED (ARG 1.)))
	    (DO ((I 2. (1+ I)))
		((> I N) T)
		(COND ((NOT (FUNCALL PRED (ARG I)))
		       (MICRO:ERROR '|WRONG TYPE ARG| (ARG I)))))))

(PUTPROP 'PRIN1 'UNIX:SYSPRIN1 'MICRO:PRIN1)

(DEFUN UNIX:CAREFULLY-EXPLODE (OBJECT)
       (EXPLODE	(UNIX:INSPECT-FOR-EXPLOSIVES OBJECT)))

(DEFUN UNIX:INSPECT-FOR-EXPLOSIVES (OBJECT)
       (COND ((ATOM OBJECT) OBJECT)
	     ((EQ (CDR OBJECT) '|nil|)
	      (NCONS (UNIX:INSPECT-FOR-EXPLOSIVES (CAR OBJECT))))
	     (T
	      (CONS (UNIX:INSPECT-FOR-EXPLOSIVES (CAR OBJECT))
		    (UNIX:INSPECT-FOR-EXPLOSIVES (CDR OBJECT))))))

(DEFUN UNIX:SYSPRIN1 (OBJECT STREAM)
       (COND ((ATOM OBJECT)
	      (UNIX:SYSPRIN1\ATOMIC OBJECT STREAM))
	     ((EQ (CAR OBJECT) '|closure|)
	      (PRINC '|(closure | STREAM)
	      (UNIX:SYSPRIN1 (CADR OBJECT) STREAM)
	      (PRINC '| closure_environment)| STREAM)
	      OBJECT)
	     ((AND (HUNKP OBJECT) (EQ (CXR 0. OBJECT) 'MICRO:ARRAY))
	      (TYO #/# STREAM)
              (PRINC 
	       (CASEQ (ARRAY-TYPE OBJECT)
		      (|flonum| 'F)
		      (|fixnum| 'I)
		      (|t|      'T)
		      (T        '?))
	       STREAM)
	      (TYO #/- STREAM)
	      (DO ((BASE 10.)
		   (*NOPOINT T)
		   (DIMS (ARRAY-DIMS OBJECT) (CDR DIMS)))
		  ((NOT DIMS))
		  (COND ((ATOM DIMS) (RETURN T))
			(T (PRINC (CAR DIMS) STREAM)
			   (COND ((NOT (ATOM (CDR DIMS)))
				  (PRINC '/: STREAM))))))
	      (TYO #/- STREAM)
	      (LET ((BASE 8.))
		   (PRINC (MAKNUM OBJECT) STREAM)))
	     (T
	      (TYO #/( STREAM)
	      (DO ((L OBJECT (CDR L))
		   (FLAG () T))
		  ((ATOM L)
		   (COND ((NOT (EQ L '|nil|))
			  (PRINC '| . | STREAM)
			  (UNIX:SYSPRIN1\ATOMIC L STREAM)))
		   (TYO #/) STREAM)
		   OBJECT)
		  (COND (FLAG (TYO #\SPACE STREAM)))
		  (UNIX:SYSPRIN1 (CAR L) STREAM)))))

  ;; Note -- this printer is designed to be fast, though not always correct.
  ;; in particular -- atoms which are valid numbers may not get slashified
  ;; right -- eg, -1, the symbol, will not display differently than -1 the 
  ;; number.

(DEFUN UNIX:SYSPRIN1\ATOMIC (OBJECT STREAM)
       (COND ((NUMBERP OBJECT)
	      (LET ((BASE MICRO:OBASE) (*NOPOINT T))
		   (PRIN1 OBJECT STREAM)))
	     ((EQ OBJECT '|nil|)
	      (PRINC '|()| STREAM))
	     ((SYMBOLP OBJECT)
	      (COND ((EQ (GETCHAR OBJECT 1.) '/#)
		     (PRINC OBJECT STREAM))
		    (T
		     (DO ((SIZE (FLATC OBJECT))
			  (I 1. (1+ I))
			  (SLASH-BIT #O400 #O100)
			  (C))
			 ((> I SIZE))
			 (COND ((OR (NOT
				     (ZEROP
				      (BOOLE 1.
					     (STATUS SYNTAX
						     (SETQ C
							   (GETCHARN OBJECT I)))
					     SLASH-BIT)))
				    (AND (= I 1.) ; leading digit
					 (NOT (ZEROP (BOOLE 1.
							    (STATUS SYNTAX
								    (PROGN C))
							    4)))))
				(TYO #/\ STREAM)))
			 (TYO C STREAM)))))
	     (T
	      (TERPRI STANDARD-OUTPUT)
	      (PRINC '|??? -> | STANDARD-OUTPUT)
	      (PRIN1 OBJECT STANDARD-OUTPUT)
	      (MICRO:ERROR '|PRINTER FAILURE - REPORT THIS AS A BUG|
			   (TYPEP OBJECT))))
       OBJECT)

(DEFUN UNIX:INITIALIZE-READTABLES ()
       (PUTPROP 'READTABLE (ARRAY NIL READTABLE T)   'MACLISP-READTABLE)
       (PUTPROP 'READTABLE READTABLE		    'UNIX-LISP-READTABLE)
       (PUTPROP 'READTABLE (CAR (STATUS MACRO #/;)) 'SEMI-MACRO)
       (PUTPROP 'READTABLE (STATUS SYNTAX #//)      'SLASH-SYNTAX-BITS)
       (DO ((CHAR #/a (1+ CHAR)))
	   ((> CHAR #/z))
	   (SETSYNTAX CHAR 'A CHAR))
       (SETSYNTAX '/| 'SPLICING (GET 'READTABLE 'SEMI-MACRO))
       (SETSYNTAX '/\ (GET 'READTABLE 'SLASH-SYNTAX-BITS) '/\)
       (SETSYNTAX '/, 'A '/,)
       (SETSYNTAX '// 'A '//)
       (SETSYNTAX '/; 'A '/;)
       (SSTATUS MACRO #/' 'UNIX:QUOTE-MACRO)
       (UNIX:SETUP-MACLISP-READTABLE))

(DEFUN UNIX:SETUP-UNIX-LISP-READTABLE ()
       (SETQ READTABLE (GET 'READTABLE 'UNIX-LISP-READTABLE)))

(DEFUN UNIX:SETUP-MACLISP-READTABLE ()
       (SETQ READTABLE (GET 'READTABLE 'MACLISP-READTABLE)))

(DEFUN UNIX:QUOTE-MACRO () (LIST '|quote| (READ)))

(MICRO:DEF-FSUBR (|oldlisp| UNIX:OLDLISP) (X)
      (COND ((OR (ATOM X) (NOT (EQ (CAR X) '|nil|)))
	     (SETQ MICRO:UNBOUND-ERRORS NIL) '|t|)
	    (T
	     (SETQ MICRO:UNBOUND-ERRORS T) '|nil|)))

(DECLARE (MUZZLED T))

(MICRO:DEF-SUBR ((|pp| |pretty-print| |prettyprint|) UNIX:PP) (X)
       ($PP X #'(LAMBDA N
			(COND ((= N 1.)
			       (UNIX:SYSPRIN1 (ARG 1.) STANDARD-OUTPUT))
			      (T
			       (UNIX:SYSPRIN1 (ARG 1.) (ARG 2.)))))
	    STANDARD-OUTPUT)
       (TERPRI)
       '|t|)

(MICRO:DEF-SUBR (|hash| UNIX:HASH) (OBJECT INTEGER)
       (CHECK-ARGS-DATATYPE 'FIXP INTEGER)
       (LET ((NUM (ABS (SXHASH OBJECT))))
	    (REMAINDER NUM INTEGER)))

(DECLARE (MUZZLED NIL))

(MICRO:DEF-SUBR (|apply| UNIX:APPLY) (FN ARG-LIST)
       (CHECK-ARGS-DATATYPE 'LIST ARG-LIST)
       (COND ((MICRO:SUBR? FN)
	      (MICRO:APPLY-MICRO-SUBR FN ARG-LIST))
	     ((MICRO:FSUBR? FN)
	      (MICRO:APPLY-MICRO-FSUBR FN ARG-LIST))
	     ((MICRO:NLAMBDA? FN)
	      (MICRO:APPLY FN ARG-LIST))
	     ((MICRO:LAMBDA? FN)
	      (MICRO:APPLY FN ARG-LIST))
	     ((MICRO:CLOSURE? FN) ;what a crock...
	      (LET ((MICRO:ALIST (CADDR FN)))
		   (MICRO:APPLY (CADR FN) ARG-LIST)))
	     (T
	      (MICRO:ERROR '|THIS FORM CANNOT BE APPLIED| FN))))
				       
(MICRO:DEF-SUBR (|boundp| UNIX:BOUNDP) (X)
      (CHECK-ARGS-DATATYPE 'SYMBOLP X)
      (OR (AND (MICRO:VALUE-CELL X) '|t|) '|nil|))

(MICRO:DEF-SUBR (|gensym| UNIX:GENSYM) ()
      (LET ((BASE 10.) (*NOPOINT T))
	   (PROG1 
	    (MAKNAM (CONS MICRO:GENSYM-PREFIX
			  (DO ((L (EXPLODEN MICRO:GENSYM-COUNTER)
				  (CONS '/0 L)))
			      ((> (LENGTH L) 3.) L))))
	    (SETQ MICRO:GENSYM-COUNTER (1+ MICRO:GENSYM-COUNTER)))))

(MICRO:DEF-SUBR (|fixp| UNIX:FIXP) (X)
      (COND ((EQ (UNIX:TYPEP X) '|fixnum|) '|t|)
	    (t '|nil|)))

(MICRO:DEF-SUBR (|floatp| UNIX:FLOATP) (X)
      (COND ((EQ (UNIX:TYPEP X) '|flonum|) '|t|)
	    (t '|nil|)))

(MICRO:DEF-SUBR (|numberp| UNIX:NUMBERP) (X)
      (COND ((NUMBERP X) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (|setrandom| UNIX:SETRANDOM) N
      (LET ((EVALHOOK NIL))
	   (COND ((ZEROP N)
		  (SSTATUS RANDOM
		    (APPLY '* (APPEND (STATUS DATE) (STATUS DAYTIME)))))
		 ((FIXP (ARG 1.))
		  (SSTATUS RANDOM (ARG 1.)))
		 (T
		  (MICRO:ERROR '|ILLEGAL ARG TO SETRANDOM| (ARG 1.))))))

(MICRO:DEF-SUBR (|inradix| UNIX:INRADIX) N
      (COND ((ZEROP N) MICRO:IBASE)
	    ((OR (NOT (FIXP (ARG 1.)))
		 (< (ARG 1.) 2.))
	     (MICRO:ERROR '|ILLEGAL INRADIX| (ARG 1.)))
	    (T (SETQ MICRO:IBASE (ARG 1.)))))

(MICRO:DEF-SUBR (|outradix| UNIX:OUTRADIX) N
      (COND ((ZEROP N) MICRO:OBASE)
	    ((OR (NOT (FIXP (ARG 1.)))
		 (< (ARG 1.) 2.))
	     (MICRO:ERROR '|ILLEGAL OUTRADIX| (ARG 1.)))
	    (T (SETQ MICRO:OBASE (ARG 1.)))))

(MICRO:DEF-FSUBR ((|fr| |fileread|) UNIX:FILEREAD) (FORM)
      (LET ((ERRSET NIL)
	    (EOF (GENSYM))
	    (IBASE MICRO:IBASE)
	    (TTYSCAN-STRINGERS/| '((124. . 13.)))
	    (NAME (PROBEF (SETQ FORM
				(MERGEF (MICRO:FIX-LIST FORM) DEFAULTF)))))
	   (COND ((NOT NAME) (MICRO:ERROR '|FILE NOT FOUND|
					  (MICRO:UNFIX-LIST FORM))))
	   (IOTA ((INSTREAM FORM 'IN))
		 (DO ((INFILE INSTREAM)
		      (ECHOFILES ())
		      (^Q T)
		      (FORM (SUBST '|nil| |()| (READ INSTREAM EOF))
			    (SUBST '|nil| |()| (READ INSTREAM EOF))))
		     ((EQ FORM EOF) '|t|)
		     (UNIX:PRINT (UNIX:EVAL FORM))))))

(MICRO:DEF-SUBR (|load| UNIX:LOAD) (FORM)
      (LET ((ERRSET NIL)
	    (EOF (GENSYM))
	    (IBASE MICRO:IBASE)
	    (NAME (PROBEF (SETQ FORM
				(MERGEF (MICRO:FIX-LIST FORM) DEFAULTF)))))
	   (COND ((NOT NAME) (MICRO:ERROR '|FILE NOT FOUND|
					  (MICRO:UNFIX-LIST FORM))))
	   (IOTA ((INSTREAM FORM 'IN))
		 (DO ((INFILE INSTREAM)
		      (ECHOFILES ())
		      (^Q T)
		      (FORM (SUBST '|nil| |()| (READ INSTREAM EOF))
			    (SUBST '|nil| |()| (READ INSTREAM EOF))))
		     ((EQ FORM EOF) '|t|)
		     (UNIX:EVAL FORM)))))

(MICRO:DEF-FSUBR (|backtrace| UNIX:BACKTRACE) (X)
      (COND ((OR (EQ X '|nil|) (EQ (CAR X) '|nil|))
	     (SETQ MICRO:BACKTRACE '|nil|))
	    ((OR (FIXP (CAR X)) (EQ (CAR X) '|t|))
	     (SETQ MICRO:BACKTRACE (CAR X)))
	    (T
	     (MICRO:ERROR
	      '|ARG TO BACKTRACE MUST BE T, NIL, OR A FIXED POINT NUMBER|
	      (CAR X)))))

(MICRO:DEF-SUBR (|subrp| UNIX:SUBRP) (OBJECT)
      (OR (MICRO:SUBR? OBJECT) (MICRO:FSUBR? OBJECT)))

(MICRO:DEF-SUBR (|nthcdr| UNIX:NTHCDR) (N FORM)
      (COND ((MINUSP N) (MICRO:ERROR '|ILLEGAL 1ST ARG TO NTHCDR| N))
	    ((ZEROP N) FORM)
	    ((NOT (EQ (TYPEP FORM) 'LIST))
	     (MICRO:ERROR '|NTHCDR FOUND AN ATOM| FORM))
	    (T (UNIX:NTHCDR (1- N) (CDR FORM)))))

(MICRO:DEF-SUBR (|car| UNIX:CAR) (FORM)
      (COND ((NOT (EQ (TYPEP FORM) 'LIST))
	     (MICRO:ERROR '|BAD ARG TO CAR| FORM))
	    (T (CAR FORM))))

(MICRO:DEF-SUBR (|cdr| UNIX:CDR) (FORM)
      (COND ((NOT (EQ (TYPEP FORM) 'LIST))
	     (MICRO:ERROR '|BAD ARG TO CDR| FORM))
	    (T (CDR FORM))))

(DEFUN UNIX:*APPEND (X Y)
        (DECLARE (SPECIAL FORM))
	(COND ((EQ X '|nil|) Y)
	      ((ATOM X) (MICRO:ERROR '|NOT A PROPER LIST| FORM))
	      ((EQ (CDR X) '|nil|)
	       (CONS (CAR X) Y))
	      (T
	       (CONS (CAR X) (UNIX:*APPEND (CDR X) Y)))))

(DEFUN UNIX:+APPEND (FORMS)
       (CASEQ (LENGTH FORMS)
	      (0. '|nil|)
	      (1. (CAR FORMS))
	      (T  (LET ((FORM (CAR FORMS)))
		       (DECLARE (SPECIAL FORM))
		       (UNIX:*APPEND FORM
				     (UNIX:+APPEND (CDR FORMS)))))))

(MICRO:DEF-SUBR (|append| UNIX:APPEND) NARGS
       (UNIX:+APPEND (LISTIFY NARGS)))

(MICRO:DEF-SUBR (|cons| UNIX:CONS) (FORM1 FORM2) (CONS FORM1 FORM2))

(MICRO:DEF-FSUBR (|quote| UNIX:QUOTE) (FORM)
      (COND ((OR (ATOM FORM) (NOT (EQ (CDR FORM) '|nil|)))
	     (MICRO:ERROR '|WRONG # OF ARGS TO QUOTE| FORM))
	    (T
	     (CAR FORM))))

(MICRO:DEF-SUBR (|not| UNIX:NOT) (VAL)
      (COND ((EQ VAL '|nil|) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (|null| UNIX:NULL) (VAL)
      (COND ((EQ VAL '|nil|) '|t|)
	    (T '|nil|)))

(MICRO:DEF-FSUBR (|cond| UNIX:COND) (FORM)
      (DO ((CLAUSES FORM (CDR CLAUSES)))
	  ((ATOM CLAUSES) '|nil|)
	  (COND ((ATOM (CAR CLAUSES))
		 (MICRO:ERROR '|ATOMIC COND CLAUSE| (CAR CLAUSES)))
		((NOT (EQ (MICRO:EVAL (CAAR CLAUSES)) '|nil|))
		 (RETURN
		  (MICRO:MAP-EVAL-RETURNING-LAST-FORM (CDAR CLAUSES)))))))

(MICRO:DEF-SUBR (|eval| UNIX:EVAL) NARGS
      (CASEQ NARGS
	     (0. (MICRO:ERROR '|TOO FEW ARGS TO EVAL| '(eval)))
	     (1. (MICRO:EVAL (ARG 1.)))
	     (2. (LET ((MICRO:ALIST (ARG 2.)))
		      (MICRO:EVAL (ARG 1.))))
	     (T  (MICRO:ERROR '|TOO MANY ARGS TO EVAL|
			      (CONS '|eval|
				    (MICRO:UNFIX-LIST (LISTIFY NARGS)))))))

(MICRO:DEF-SUBR (|set| UNIX:SET) (VAR VAL)
      (LET ((VAL-CELL (MICRO:VALUE-CELL VAR)))
	   (COND (VAL-CELL (RPLACA VAL-CELL VAL))
		 (T        (COND ((ATOM MICRO:ALIST)
				  (MICRO:ERROR '|EMPTY ALIST! YOU LOSE BADLY|
					       '|nil|))
				 (T
				  (RPLACD (LAST MICRO:ALIST)
					  (LIST* VAR VAL '|nil|))))))
	   VAL))

(MICRO:DEF-FSUBR (|setq| UNIX:SETQ) (FORM)
      (COND ((OR (ATOM FORM)
		 (ATOM (CDR FORM))
	         (NOT (ATOM (CDDR FORM))))
	     (MICRO:ERROR '|WRONG # OF ARGS| '|setq|))
	    (T
	     (UNIX:SET (CAR FORM) (MICRO:EVAL (CADR FORM))))))

(MICRO:DEF-SUBR (|exit| UNIX:EXIT) ()
      (QUIT))

(MICRO:DEF-SUBR (|rawo| UNIX:TYO) (X) (TYO X STANDARD-OUTPUT))

(MICRO:DEF-SUBR (|rawi| UNIX:TYI) () (TYI))

(MICRO:DEF-SUBR (|rawpeek| UNIX:TYIPEEK) () (TYIPEEK))

(MICRO:DEF-SUBR (|print| UNIX:PRINT) (FORM)
      (PROG2 ()
	     (UNIX:SYSPRIN1 FORM STANDARD-OUTPUT)
	     (TERPRI STANDARD-OUTPUT)))

(MICRO:DEF-SUBR (|prin1| UNIX:PRIN1) (FORM)
       (PROG2 ()
	      (UNIX:SYSPRIN1 FORM STANDARD-OUTPUT)
	      (TYO 32. STANDARD-OUTPUT)))

(MICRO:DEF-SUBR (|princ| UNIX:PRINC) (FORM)
       (PRINC (MICRO:FIX-FORM FORM) STANDARD-OUTPUT)
       FORM)

(MICRO:DEF-SUBR (|read| UNIX:READ) ()
      (LET ((IBASE MICRO:IBASE)
	    (TTYSCAN-STRINGERS/| '((124. . 13.))))
	   (SUBST '|nil| |()| (READ))))

(MICRO:DEF-FSUBR (|defun| UNIX:DEFUN) (FORM)
      (UNIX:SET (CAR FORM) (CONS '|lambda| (CDR FORM)))
      (CAR FORM))

(MICRO:DEF-FSUBR (|ndefun| UNIX:NDEFUN) (FORM)
      (UNIX:SET (CAR FORM) (CONS '|nlambda| (CDR FORM)))
      (CAR FORM))

(MICRO:DEF-FSUBR (|defmacro| UNIX:DEFMACRO) (FORM)
      (UNIX:SET (CAR FORM) (CONS '|macro| (CDR FORM)))
      (CAR FORM))

(MICRO:DEF-SUBR (|rplaca| UNIX:RPLACA) (FORM NEW-CAR)
      (RPLACA FORM NEW-CAR))

(MICRO:DEF-SUBR (|rplacd| UNIX:RPLACD) (FORM NEW-CDR)
      (RPLACD FORM NEW-CDR))

(MICRO:DEF-SUBR (|list| UNIX:LIST) NARGS
      (MICRO:UNFIX-LIST (LISTIFY NARGS)))

(DECLARE (MUZZLED T))

(MICRO:DEF-SUBR ((* |times|) UNIX:*) NARGS
     (COND ((< NARGS 2.) (MICRO:ERROR '|WRONG # OF ARGS| '*)))
     (LET ((ARG-LIST (LISTIFY NARGS)))
	  (APPLY 'CHECK-ARGS-DATATYPE (CONS 'NUMBERP ARG-LIST))
	  (APPLY 'TIMES ARG-LIST)))

(MICRO:DEF-SUBR ((+ |plus|) UNIX:+) NARGS
      (COND ((< NARGS 2.) (MICRO:ERROR '|WRONG # OF ARGS| '+)))
      (LET ((ARG-LIST (LISTIFY NARGS)))
	   (APPLY 'CHECK-ARGS-DATATYPE (CONS 'NUMBERP ARG-LIST))
	   (APPLY 'PLUS ARG-LIST)))

(MICRO:DEF-SUBR (- UNIX:-) NARGS
     (CASEQ NARGS
	    (0. (MICRO:ERROR '|WRONG # OF ARGS| '-))
	    (1. (CHECK-ARGS-DATATYPE 'NUMBERP (ARG 1.))
		(MINUS (ARG 1.)))
	    (T  (LET ((ARG-LIST (LISTIFY NARGS)))
		     (APPLY 'CHECK-ARGS-DATATYPE (CONS 'NUMBERP ARG-LIST))
		     (APPLY 'DIFFERENCE ARG-LIST)))))

(MICRO:DEF-SUBR (|difference| UNIX:DIFFERENCE) NARGS
      (COND ((< NARGS 2.) (MICRO:ERROR '|WRONG # OF ARGS| '|difference|)))
      (LET ((ARG-LIST (LISTIFY NARGS)))
	   (APPLY 'CHECK-ARGS-DATATYPE (CONS 'NUMBERP ARG-LIST))
	   (APPLY 'DIFFERENCE ARG-LIST)))

(MICRO:DEF-SUBR (|minus| UNIX:MINUS) (N)
     (CHECK-ARGS-DATATYPE 'NUMBERP N)
     (MINUS N))

(MICRO:DEF-SUBR (|quotient| UNIX:FIXDIV) (X Y)
     (CHECK-ARGS-DATATYPE 'FIXP X Y)
     (// X Y))

(MICRO:DEF-SUBR ((// |flodiv|) UNIX:QUOTIENT) (X Y)
     (CHECK-ARGS-DATATYPE 'NUMBERP X Y)
     (//$ (FLOAT X) (FLOAT Y)))

(MICRO:DEF-SUBR (|remainder| UNIX:REMAINDER) (X Y)
     (CHECK-ARGS-DATATYPE 'NUMBERP X Y)
     (REMAINDER X Y))

(DECLARE (MUZZLED T))

(MICRO:DEF-SUBR (|random| UNIX:RANDOM) (X)
     (CHECK-ARGS-DATATYPE 'FIXP X)
     (RANDOM X))

(MICRO:DEF-SUBR (|atom| UNIX:ATOM) (X)
      (COND ((NOT (EQ (TYPEP X) 'LIST)) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (|eq| UNIX:EQ) (X Y)
      (COND ((EQ X Y) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (|equal| UNIX:EQUAL) (X Y)
      (COND ((EQUAL X Y) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (= UNIX:=) (X Y)
      (CHECK-ARGS-DATATYPE 'NUMBERP X Y)
      (COND ((NOT (EQ (TYPEP X) (TYPEP Y)))
	     (SETQ X (FLOAT X) Y (FLOAT Y))))
      (COND ((= X Y) '|t|)
	    (t '|nil|)))

(SETQ UNIX:PROG-FLAG ())

(MICRO:DEF-FSUBR (|prog| UNIX:PROG) (FORM)
      (LET* ((BVL  (MICRO:FIX-LIST (CAR FORM)))
	     (BODY (MICRO:FIX-LIST (CDR FORM)))
	     (MICRO:ALIST (MICRO:BIND-ARGS BVL
					   (MAPCAR (LAMBDA (()) '|nil|) BVL))))
	    (*CATCH 'UNIX:PROG-FELL-OFF-END 
		    (DO ((RETURN-VALUE)
			 (START BODY))
			(NIL)
			(SETQ RETURN-VALUE
			      (*CATCH 'UNIX:PROG-CONTROL
				      (DO ((L START (CDR L))
					   (UNIX:PROG-FLAG T))
					  ((NULL L)
					   (*THROW 'UNIX:PROG-FELL-OFF-END
						   '|nil|))
					  (COND ((NOT (ATOM (CAR L)))
						 (MICRO:EVAL (CAR L)))))))
			(COND ((EQ (CAR RETURN-VALUE) 'GOTO)
			       (SETQ START (MEMQ (CDR RETURN-VALUE) BODY)))
			      (T ; Return
			       (RETURN (CDR RETURN-VALUE))))
			(COND ((NULL START)
			       (UNIX:*GOTO RETURN-VALUE)))))))

(DEFUN UNIX:*GOTO (PAIR)
       (COND (UNIX:PROG-FLAG (*THROW 'UNIX:PROG-CONTROL PAIR))
	     (T (MICRO:ERROR '|NO SUCH GO TAG| (CDR PAIR)))))

(MICRO:DEF-SUBR (|return| UNIX:RETURN) N
      (LET ((FORM (COND ((ZEROP N) '|nil|)
			((= N 1.) (ARG 1.))
			(T (MICRO:ERROR '|WRONG NUMBER OF ARGS TO RETURN|
					(MICRO:UNFIX-LIST (LISTIFY N)))))))
	   (COND (UNIX:PROG-FLAG
		  (*THROW 'UNIX:PROG-CONTROL (CONS 'RETURN FORM)))
		 (T
		  (MICRO:ERROR '|NO PLACE TO RETURN| FORM)))))

(MICRO:DEF-FSUBR (|go| UNIX:GOTO) (FORM)
      (COND ((NOT (EQ (CDR FORM) '|nil|))
	     (MICRO:ERROR '|TOO MANY ARGS TO GOTO| FORM))
	    (T
	     (UNIX:*GOTO (CONS 'GOTO (CAR FORM))))))

(MICRO:DEF-SUBR ((> |greaterp|) UNIX:>) (X Y)
      (CHECK-ARGS-DATATYPE 'NUMBERP X Y)
      (COND ((GREATERP X Y) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR ((< |lessp|) UNIX:<) (X Y)
      (CHECK-ARGS-DATATYPE 'NUMBERP X Y)
      (COND ((LESSP X Y) '|t|)
	    (T '|nil|)))

(MICRO:DEF-FSUBR (|while| UNIX:WHILE) (FORM)
      (LET (((CONDITION () . BODY) FORM))
	   (DO ()
	       ((EQ (MICRO:EVAL CONDITION) '|nil|) '|nil|)
	       (MAPC 'MICRO:EVAL (MICRO:FIX-LIST BODY)))))

(MICRO:DEF-FSUBR (|and| UNIX:AND) (FORM)
      (DO ((L FORM (CDR L))
	   (VAL '|t|))
	  ((ATOM L) VAL)
	  (COND ((EQ (SETQ VAL (MICRO:EVAL (CAR L))) '|nil|)
		 (RETURN '|nil|)))))

(MICRO:DEF-FSUBR (|or| UNIX:OR) (FORM)
      (DO ((L FORM (CDR L))
	   (VAL))
	  ((ATOM L) '|nil|)
	  (COND ((NOT (EQ (SETQ VAL (MICRO:EVAL (CAR L))) '|nil|))
		 (RETURN VAL)))))

(MICRO:DEF-SUBR (|error| UNIX:ERROR) (VAL)
      (MICRO:ERROR '|ERROR SIGNALLED| VAL))

(MICRO:DEF-SUBR ((|garbagecollect| |gc|) UNIX:GC) ()
      (GCTWA) (GC) '|t|)

(MICRO:DEF-SUBR ((|make-array| |make_array|) UNIX:MAKE-ARRAY) (TYPE SUBLIST)
      (HUNK TYPE
	    (LET ((A (*ARRAY ()
			     (CASEQ TYPE
				    (|fixnum| 'FIXNUM)
				    (|flonum| 'FLONUM)
				    (|t|      'T)
				    (T (MICRO:ERROR '|BAD ARRAY TYPE| TYPE)))
			     (APPLY '* (MICRO:FIX-LIST SUBLIST)))))
		 (COND ((EQ TYPE '|t|)
			(FILLARRAY A '(|nil|))))
		 A)
	    SUBLIST
	    'MICRO:ARRAY))

(DEFUN CHECK-ARRAY-BOUNDS (X Y)
       (COND ((AND (ATOM X) (ATOM Y)) T)
	     ((OR (ATOM X) (ATOM Y)) NIL)
	     ((OR (MINUSP X) (MINUSP Y)) NIL)
	     ((NOT (< (CAR X) (CAR Y))) NIL)
	     (T
	      (CHECK-ARRAY-BOUNDS (CDR X) (CDR Y)))))

(MICRO:DEF-SUBR (|refarray| UNIX:REFARRAY) (ARRAY-OBJ STOREP STOREV SUBSCRIPTS)
      (LET* (((DATA-TYPE . DIMS) (UNIX:ARRAYDIMS ARRAY-OBJ))
	     (STORAGE (ARRAY-STORAGE ARRAY-OBJ))
	     (LINEAR-SUBSCRIPT (MASH SUBSCRIPTS DIMS)))
	    (COND ((NOT (CHECK-ARRAY-BOUNDS SUBSCRIPTS DIMS))
		   (MICRO:ERROR '|SUBSCRIPT OUT OF BOUNDS|
				(UNIX:LIST '|array=|
					   ARRAY-OBJ
					   '|subscripts=|
					   SUBSCRIPTS
					   '|bounds=|
					   DIMS))))
	    (COND ((NOT (EQ STOREP '|nil|))
		   (CASEQ DATA-TYPE
			  (|fixnum|
			   (CHECK-ARGS-DATATYPE #'(LAMBDA (X)
							  (AND (FIXP X)
							       (NOT (BIGP X))))
						STOREV)
			   (STORE (ARRAYCALL FIXNUM STORAGE LINEAR-SUBSCRIPT)
				  STOREV))
			 (|flonum|
			  (CHECK-ARGS-DATATYPE 'FLOATP STOREV)
			  (STORE (ARRAYCALL FLONUM STORAGE LINEAR-SUBSCRIPT)
				 STOREV))
			 (|t|
			  (STORE (ARRAYCALL T STORAGE LINEAR-SUBSCRIPT)
				 STOREV))
			 (T
			  (MICRO:ERROR '|BAD ARRAY TYPE| DATA-TYPE)))
		   STOREV)
		  ((EQ DATA-TYPE '|fixnum|)
		   (ARRAYCALL FIXNUM STORAGE LINEAR-SUBSCRIPT))
		  ((EQ DATA-TYPE '|flonum|)
		   (ARRAYCALL FLONUM STORAGE LINEAR-SUBSCRIPT))
		  (T ;|t|
		   (ARRAYCALL T      STORAGE LINEAR-SUBSCRIPT)))))

(MICRO:DEF-SUBR (|typep| UNIX:TYPEP) (X)
      (CASEQ (TYPEP X)
	     ((SYMBOL)
	      (COND ((AND (EQ (GETCHAR X 1.) '/#)
			  (GETL X '(MICRO:SUBR MICRO:FSUBR)))
		     '|subr|)
		    (T '|symbol|)))
	     ((FIXNUM) '|fixnum|)
	     ((FLONUM) '|flonum|)
	     ((BIGNUM) '|bignum|)
	     ((ATOM)   '|random|)
	     ((LIST)   '|list|)
	     (T ; Hunk
	      (COND ((EQ (CXR 0. X) 'MICRO:ARRAY) '|array|)
		    (T '|random|)))))

(MICRO:DEF-SUBR (|arraydims| UNIX:ARRAYDIMS) (ARRAY-OBJ)
      (COND ((AND (HUNKP ARRAY-OBJ) (EQ (CXR 0. ARRAY-OBJ) 'MICRO:ARRAY))
	     (CONS (ARRAY-TYPE ARRAY-OBJ) (ARRAY-DIMS ARRAY-OBJ)))
	    (T
	     (MICRO:ERROR '|NOT A VALID ARRAY OBJECT| ARRAY-OBJ))))

(DEFUN MASH  (V-SUBSCRIPTS V-DIMENSIONS)
       (COND ((ATOM V-SUBSCRIPTS) 0.)
	     (T
	      (MASH1 (UNIX:REVERSE V-SUBSCRIPTS) V-DIMENSIONS 1.))))

(DEFUN MASH1 (SUBSCRIPTS DIMENSIONS PRODUCT)
       (COND ((= (UNIX:LENGTH SUBSCRIPTS) 1.)
	      (* (CAR SUBSCRIPTS) PRODUCT))
	     (T
	      (+
	       (* (CAR SUBSCRIPTS) PRODUCT)
	       (MASH1 (CDR SUBSCRIPTS)
		      (CDR DIMENSIONS)
		      (* (CAR DIMENSIONS) PRODUCT))))))

(MICRO:DEF-SUBR (|member| UNIX:MEMBER) (OBJECT LIST-TO-SEARCH)
      (DO ((L LIST-TO-SEARCH (CDR L)))
	  ((ATOM L) '|nil|)
	  (COND ((EQUAL (CAR L) OBJECT)
		 (RETURN L)))))

(MICRO:DEF-SUBR (|memq| UNIX:MEMQ) (OBJECT LIST-TO-SEARCH)
      (DO ((L LIST-TO-SEARCH (CDR L)))
	  ((ATOM L) '|nil|)
	  (COND ((EQ (CAR L) OBJECT)
		 (RETURN L)))))

(MICRO:DEF-SUBR (|sub1| UNIX:SUB1) (FORM) (1- FORM))

(MICRO:DEF-SUBR (|add1| UNIX:ADD1) (FORM) (1+ FORM))

(MICRO:DEF-SUBR (|implode| UNIX:IMPLODE) (FORM)
      (LET ((IBASE MICRO:IBASE)
	    (TTYSCAN-STRINGERS/| '((124. . 13.))))
	   (READLIST (MICRO:FIX-LIST FORM))))

(MICRO:DEF-SUBR (|implodec| UNIX:IMPLODEC) (FORM)
		(IMPLODE (MICRO:FIX-LIST FORM)))

(MICRO:DEF-SUBR (|explodec| UNIX:EXPLODEC) (FORM)
       (LET ((BASE MICRO:OBASE))
	    (MICRO:UNFIX-LIST (EXPLODEC FORM))))

(MICRO:DEF-SUBR (|explode| UNIX:EXPLODE) (FORM)
       (LET ((BASE MICRO:OBASE))
	    (MICRO:UNFIX-LIST (EXPLODEC FORM))))

(MICRO:DEF-SUBR (|zerop| UNIX:ZEROP) (FORM)
      (COND ((ZEROP FORM) '|t|)
	    (T '|nil|)))

(MICRO:DEF-SUBR (|readch| UNIX:READCH) ()
      (READCH))

(MICRO:DEF-SUBR (|reverse| UNIX:REVERSE) (FORM)
      (DO ((L '|nil| (CONS (CAR FORM) L))
	   (FORM FORM (CDR FORM)))
	  ((ATOM FORM)
	   (COND ((EQ FORM '|nil|) L)
		 (T (MICRO:ERROR '|NOT A PROPER LIST| FORM))))))

(MICRO:DEF-SUBR (|progn| UNIX:PROGN) NARGS (ARG NARGS))

(MICRO:DEF-SUBR (|length| UNIX:LENGTH) (FORM)
      (DO ((I 0. (1+ I))
	   (L FORM (CDR L)))
	  ((ATOM L)
	   (COND ((EQ L '|nil|) I)
		 (T
		  (MICRO:ERROR '|NOT A PROPER LIST| FORM))))))

(MICRO:DEF-SUBR (|peekch| UNIX:PEEKCH) ()
      (ASCII (TYIPEEK)))

(MICRO:DEF-SUBR (|cvta| UNIX:CVTA) (X)
      (ASCII X))

(MICRO:DEF-SUBR (|cvtn| UNIX:CVTN) (X)
      (GETCHARN X 1.))

(MICRO:DEF-SUBR (|caar| UNIX:CAAR) (X) (UNIX:CAR (UNIX:CAR X)))

(MICRO:DEF-SUBR (|cadr| UNIX:CADR) (X) (UNIX:CAR (UNIX:CDR X)))

(MICRO:DEF-SUBR (|cdar| UNIX:CDAR) (X) (UNIX:CDR (UNIX:CAR X)))

(MICRO:DEF-SUBR (|cddr| UNIX:CDDR) (X) (UNIX:CDR (UNIX:CDR X)))

(MICRO:DEF-SUBR (|caaar| UNIX:CAAAR) (X) (UNIX:CAR (UNIX:CAR (UNIX:CAR X))))

(MICRO:DEF-SUBR (|caadr| UNIX:CAADR) (X) (UNIX:CAR (UNIX:CAR (UNIX:CDR X))))

(MICRO:DEF-SUBR (|cadar| UNIX:CADAR) (X) (UNIX:CAR (UNIX:CDR (UNIX:CAR X))))

(MICRO:DEF-SUBR (|caddr| UNIX:CADDR) (X) (UNIX:CAR (UNIX:CDR (UNIX:CDR X))))

(MICRO:DEF-SUBR (|cdaar| UNIX:CDAAR) (X) (UNIX:CDR (UNIX:CAR (UNIX:CAR X))))

(MICRO:DEF-SUBR (|cdadr| UNIX:CDADR) (X) (UNIX:CDR (UNIX:CAR (UNIX:CDR X))))

(MICRO:DEF-SUBR (|cddar| UNIX:CDDAR) (X) (UNIX:CDR (UNIX:CDR (UNIX:CAR X))))

(MICRO:DEF-SUBR (|cdddr| UNIX:CDDDR) (X) (UNIX:CDR (UNIX:CDR (UNIX:CDR X))))

(MICRO:DEF-SUBR (|lpr-on| UNIX:LPR-ON) ()
      (COND ((UNIX:BEGIN-SCRIPT) '|t|)
	    (T '|already_on|)))

(MICRO:DEF-SUBR (|lpr-off| UNIX:LPR-OFF) () 
      (COND ((UNIX:END-SCRIPT) '|t|)
	    (T '|already_off|)))

(MICRO:DEF-SUBR (|getal| UNIX:GETAL) () MICRO:ALIST)

(MICRO:DEF-SUBR ((|close-it| |close_it|) UNIX:CLOSURE) (X)
	(LIST* '|closure| X MICRO:ALIST '|nil|))

(MICRO:DEF-FSUBR (|lambda|  UNIX:LAMBDA) (FORM)
		 (CONS '|lambda|  FORM))

(MICRO:DEF-FSUBR (|nlambda| UNIX:NLAMBDA) (FORM)
		 (CONS '|nlambda| FORM))

(MICRO:DEF-SUBR (|prompt| UNIX:PROMPT) (FORM)
      (COND ((EQ FORM '|nil|) (SETQ MICRO:PROMPTME NIL) '|nil|)
	    (T (SETQ MICRO:PROMPTME T) '|t|)))

(DEFUN UNIX:QUIT-INTERRUPT (() ())
       (SETQ MICRO:BACKLIST NIL)
       (CLEAR-INPUT TYI)
       (NEWLINE STANDARD-OUTPUT)
       (PRINC '|EVALUATION HALTED| STANDARD-OUTPUT)
       (NEWLINE STANDARD-OUTPUT)
       (*THROW 'MICRO:ERROR-RETURN NIL))

(DEFUN UNIX:+INTERNAL-/^B-BREAK (() ())
       (NOINTERRUPT NIL)
       (*BREAK T '|Debug|))

(DEFUN UNIX:MACLISP-SETUP ()
       (SETQ EVALHOOK NIL)
       (SSTATUS TTYINT 2. '+INTERNAL-/^B-BREAK)
       (SSTATUS TTYINT 7. 7.)
       (SSTATUS TTYINT 30. NIL)
       (CLEAR-INPUT TYI)
       (REMOB  |)(|)
       (INTERN |()|)
       (UNIX:SETUP-MACLISP-READTABLE)
       (NEWLINE STANDARD-OUTPUT)
       (PRINC '|MacLISP (Version | STANDARD-OUTPUT)
       (PRINC (STATUS LISPV) STANDARD-OUTPUT)
       (PRINC '|) -- Type (UNIX) to get to ULISP.| STANDARD-OUTPUT)
       (TERPRI STANDARD-OUTPUT))

(DEFUN MACLISP N
       (DECLARE (SPECIAL N))
       (UNIX:MACLISP-SETUP)
       (*THROW 'UNIX:EXIT '*))

(DEFUN UNIX:UNIX-SETUP ()
       (COND (UNIX:DEBUG
	      (SSTATUS TTYINT 30. 'UNIX:+INTERNAL-/^B-BREAK)
	      (SSTATUS TTYINT 7. 'MACLISP))
	     (T
	      (DO I 0. (1+ I) (= I #\SPACE) (SSTATUS TTYINT I NIL))))
       (SSTATUS TTYINT 2. 'UNIX:QUIT-INTERRUPT)
       (CLEAR-INPUT TYI)
       (REMOB  |()|)
       (INTERN |)(|)
       (UNIX:SETUP-UNIX-LISP-READTABLE)
       (SETQ EVALHOOK 'MICRO:EVAL)
       (NEWLINE STANDARD-OUTPUT)
       (PRINC '|Unix Lisp Simulator (Version | STANDARD-OUTPUT)
       (PRINC (UNIX-LISP-VERSION) STANDARD-OUTPUT)
       (PRINC '|)| STANDARD-OUTPUT)
       (TERPRI STANDARD-OUTPUT))

(DEFUN UNIX:WTA-HANDLER (X)
       (MICRO:ERROR '|WRONG TYPE ARG| X))

(DEFUN UNIX:WNA-HANDLER (X)
       (MICRO:ERROR '|WRONG # OF ARGS| X))

(DEFUN UNIX ()
       (*CATCH 'UNIX:EXIT
	       (UNIX:UNIX-SETUP)
	       (DO ((FORM)
		    (WRNG-TYPE-ARG 'UNIX:WTA-HANDLER)
		    (WRNG-NO-ARGS  'UNIX:WNA-HANDLER)
		    (ERRSET NIL))
		   (NIL)
		   (ERRSET 
		    (*CATCH 'MICRO:ERROR-RETURN
			    (PROGN
			     (NEWLINE STANDARD-OUTPUT)
			     (COND (MICRO:PROMPTME
				    (PRINC MICRO:PROMPT STANDARD-OUTPUT)))
			     (SETQ FORM (UNIX:READ))
			     (NEWLINE STANDARD-OUTPUT)
			     (UNIX:PRINT (UNIX:EVAL FORM))))
		    T))))

(SETQ MICRO:ALIST (LIST* '|t| '|t|
			 '|nil| '|nil|
			 MICRO:ALIST))

(UNIX:INITIALIZE-READTABLES)

(DEFUN DUMP (FILE)
       (PROGN (TERPRI TYO)
	      (PRINC '|Filename to Script to: | TYO)
	      (SETQ UNIX:SCRIPT-FILENAME (READ TYI)))
       (SETQ UNIX:DEBUG NIL)
       (GC)
       (SSTATUS FLUSH NIL)
       (SUSPEND '|| FILE)
       (DEFAULTF `((* ,(STATUS UDIR)) * ULISP))
       (SSTATUS TOPLEVEL '(UNIX))
       '*)

