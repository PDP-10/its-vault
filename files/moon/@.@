
;;; "LINEAR" ENTER
;   M-A HAS PNTR TO FEF TO CALL
;   M-S HAS EVENTUAL NEW ARG POINTER (M-AP)
;   M-R HAS NUMBER OF ARGUMENTS
;WE DON'T SUPPORT USER COPYING AND FORWARDING OF FEFS,
;SO IT'S NOT NECESSARY TO CALL THE TRANSPORTER EVERYWHERE.
;CAN SEQUENCE BREAK ONCE WE GET PAST THE ARGUMENTS AND START DOING VARIABLE
;INITIALIZATIONS, WHICH CAN CAUSE ERRORS.

QLENTR	((VMA-START-READ) M-A)			;Get FEF header word into M-D
	(CHECK-PAGE-READ)
	((PDL-BUFFER-INDEX) SUB M-S A-AP)	;Assure room in pdl-buffer
	((M-PDL-BUFFER-ACTIVE-QS) ADD PDL-BUFFER-INDEX A-PDL-BUFFER-ACTIVE-QS)
	((M-D) Q-POINTER READ-MEMORY-DATA)
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS 
			A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
	;; Activate new frame now to minimize problems if we error out, and for P-B-DUMP
       ((M-AP) M-S)				;Note A-IPMARK points here too
	;; If fast-option not active, jump off to QRENT for slow case
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%FEFH-FAST-ARG) M-D QRENT)
       ((M-J) (LISP-BYTE %%FEFH-PC) M-D)	;Relative start address (may get changed)
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-FAST-ARG-OPT)))
	(CHECK-PAGE-READ)			;Get fast-option word
	((M-TEM) (LISP-BYTE %%HEADER-TYPE-FIELD) M-D)	;Overlap error check with mem read
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL %HEADER-TYPE-FEF)) ILLOP)	;Not FEF
	;; Check number of args, and dispatch off to slow case if there is a rest arg
	((M-TEM) (LISP-BYTE %%FEFHI-FSO-MIN-ARGS) READ-MEMORY-DATA)
	(CALL-GREATER-THAN M-TEM A-R SET-TOO-FEW-ARGS)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ARG-DESC-ANY-REST) READ-MEMORY-DATA D-QLENTR-REST)
       ((M-E) (LISP-BYTE %%FEFHI-FSO-MAX-ARGS) READ-MEMORY-DATA)   ;Escape if rest arg
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-E A-R QFL1)
       (CALL-LESS-THAN M-E A-R SET-TOO-MANY-ARGS)
QFL2	((M-E) SUB M-E (A-CONSTANT 1))		;Default unsupplied args to NIL
	(JUMP-GREATER-THAN-XCT-NEXT M-E A-R QFL2)
       ((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)
	;; Put the locals after the arguments, start entry-state Q in M-E
QFL1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER A-AP) ;Local-block offset minus one
	((A-LOCALP) M+A+1 PDL-BUFFER-INDEX A-AP)
	((M-E) ADD PDL-BUFFER-INDEX		;%%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN is low bits
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX) 1)))
	;; Push NILs to allocate and initialize the locals
	((M-TEM) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-ZERO QFL3)
QFL4	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)
	(JUMP-GREATER-THAN-XCT-NEXT M-TEM (A-CONSTANT 1) QFL4)
       ((M-TEM) SUB M-TEM (A-CONSTANT 1))
	;; If any of the args or locals is special, bind them to their values now on the pdl
	;; Note that if a local was special and we are going to take a too-many-args
	;; error, the special will get bound to the wrong value.  Big deal.
QFL3	(CALL-IF-BIT-SET (LISP-BYTE %%FEFH-SV-BIND) M-D FRMBN1)
	;; All done, start executing at desired PC (or take error exit stuffed on micro stack)
	;; Also finally store the entry-state Q
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((M-TEM) DPB M-A (BYTE-FIELD 24. 1) (A-CONSTANT 0))	;Now unrelocate PC
	(POPJ-AFTER-NEXT (LOCATION-COUNTER) ADD M-TEM A-J OUTPUT-SELECTOR-LEFTSHIFT-1)
       ((C-PDL-BUFFER-INDEX) DPB M-R (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-E)

;For no missing optionals and no locals and no unusual cases, 
; takes 32 cycles (1 noop and no memory waits)
; Old code took 45 cycles (including 4 memory waits)

(LOCALITY D-MEM)
(START-DISPATCH 2 0)
D-QLENTR-REST			;Dispatch on the two rest-arg bits
	(P-BIT R-BIT)		;0 no rest arg
	(QFLREST)		;1 rest arg
	(QFLREST)		;2 rest arg
	(QFLREST)		;3 rest arg
(END-DISPATCH)

;Dispatch on additional-info type at QLEAI3
(START-DISPATCH 3 0)
D-QLEAI3
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;0 ERR
	(INHIBIT-XCT-NEXT-BIT QLEAI2)	;1 MULT RET
	(INHIBIT-XCT-NEXT-BIT QLEAI2)	;2 RESTART PC
	(P-BIT R-BIT)			;3 FEXPR CALL
	(P-BIT R-BIT)			;4 LEXPR CALL
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;5 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;6 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;7 ERR
(END-DISPATCH)
(LOCALITY I-MEM)

;;; Error rememberers.  These work by pushing a special address on the pdl
;;; and saving the error status word in M-S where it will be preserved through
;;; intervening sequence breaks.
SET-TOO-FEW-ARGS
	(JUMP-XCT-NEXT SET-FUNCTION-ENTRY-ERROR)
       ((A-TEM1) DPB (M-CONSTANT -1) (LISP-BYTE %%M-ESUBS-TOO-FEW-ARGS) A-ZERO)

SET-TOO-MANY-ARGS
	((A-TEM1) DPB (M-CONSTANT -1) (LISP-BYTE %%M-ESUBS-TOO-MANY-ARGS) A-ZERO)
SET-FUNCTION-ENTRY-ERROR
	((M-TEM) MICRO-STACK-DATA-POP)		;Return address
	((A-TEM2) MICRO-STACK-POINTER)
	(JUMP-NOT-EQUAL A-TEM2 M-ZERO SET-FUNCTION-ENTRY-ERROR-1)
	((M-S) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;Set up to take trap on return
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FUNCTION-ENTRY-ERROR)))
SET-FUNCTION-ENTRY-ERROR-1
	((OA-REG-LOW) DPB M-TEM OAL-JUMP A-ZERO)
	(JUMP-XCT-NEXT 0)			;Return
       ((M-S) IOR M-S A-TEM1)			;With error bit set for later

;;; Comes here when it's time to trap
FUNCTION-ENTRY-ERROR
	((C-PDL-BUFFER-POINTER-PUSH) M-S)	;Put error code where the error handler
	(CALL TRAP)				;will look for it
   (ERROR-TABLE FUNCTION-ENTRY) ;This table entry is specially known about.

;;; Here if the function takes a rest arg.  M-E has # reg+opt args.
;;; This is for the fast-option case
QFLREST	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX QLEAI3)
QFLR1	;; Not a LEXPR/FEXPR call, must make a list pointer to the rest of the args
	;; where they sit on the pdl and store it into the first local.
	(JUMP-GREATER-OR-EQUAL M-E A-R QFLR3)	;Jump if rest arg will be NIL
	;; Called with enough spread args to get into the rest arg
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M+A+1 M-AP A-E)		;First of rest, %LP-INITIAL-LOCAL-BLOCK-OFFSET = 1
	(JUMP-XCT-NEXT QFLR2)
       ((C-PDL-BUFFER-POINTER-PUSH)		;Push the rest-arg
		Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))

	;; If the rest arg will be NIL, push NILs for it and any missing optionals.
QFLR3	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)
	(JUMP-GREATER-THAN-XCT-NEXT M-E A-R QFLR3)
       ((M-E) SUB M-E (A-CONSTANT 1))
	;; At this point, top of pdl is the first local, which is the rest arg list
	;; This code parodies that following QFL1
QFLR2	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER A-AP)	;Local-block offset
	((A-LOCALP) ADD PDL-BUFFER-INDEX A-AP)
	((M-E) DPB PDL-BUFFER-INDEX (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	;; Push NILs to allocate and initialize the locals
	((M-TEM) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT 1) QFLR5)
QFLR4	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)
	(JUMP-GREATER-THAN-XCT-NEXT M-TEM (A-CONSTANT 2) QFLR4)
       ((M-TEM) SUB M-TEM (A-CONSTANT 1))
	;; If any of the args or locals is special, bind them to their values now on the pdl
QFLR5	(CALL-IF-BIT-SET (LISP-BYTE %%FEFH-SV-BIND) M-D FRMBN1)
	;; All done, start executing at desired PC (or take error exit stuffed on micro stack)
	;; Also finally store the entry-state Q
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((M-TEM) DPB M-A (BYTE-FIELD 24. 1) (A-CONSTANT 0))	;Now unrelocate PC
	(POPJ-AFTER-NEXT (LOCATION-COUNTER) ADD M-TEM A-J OUTPUT-SELECTOR-LEFTSHIFT-1)
       ((C-PDL-BUFFER-INDEX) DPB M-R (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-E)

	;; ADI is present, check for LEXPR or FEXPR call, which means that the
	;; last argument supplied is in fact the rest-argument
QLEAI2	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-INDEX (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX QFLR1)	;No more ADI
QLEAI3	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-INDEX (A-CONSTANT 1))
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)
	    (ERROR-TABLE DATA-TYPE-SCREWUP FEF)
	(DISPATCH (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX D-QLEAI3)
		;Drops through on ADILEX/ADIFEX; for other legal ADI loops back to QLEAI2
	((M-TEM) SUB M-R (A-CONSTANT 1))	;Number of spread args
	(JUMP-EQUAL M-E A-TEM QFLR2)		;Matches number desired, enter
	(CALL ILLOP)				;Could use QRENT, but would ILLOP at QBNDL2

;LINEAR ENTER WITHOUT FAST OPTION
; M-A FEF			M-R number of args called with
; M-B flags/temp		M-Q bind desc Q
; M-C flags/temp		M-I address of bind desc
; M-D FEF header		M-J start PC of FEF
; M-E count of bind descs	M-S used for error bits
; M-T address of sv slot	M-K temp

QRENT	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((M-TEM) (LISP-BYTE %%HEADER-TYPE-FIELD) M-D) ;Overlap error check with mem read
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL %HEADER-TYPE-FEF)) ILLOP)	;Not FEF
	((PDL-BUFFER-INDEX) ADD M-AP		;Address first argument
		(A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)));-> S-V SLOTS
	((A-ARGS-LEFT) M-R)			;Number of args yet to do
	((A-TEM1) (LISP-BYTE %%FEFHI-MS-ARG-DESC-ORG) READ-MEMORY-DATA)
	((M-I) ADD A-TEM1 M-A)			;-> first bind desc
	((M-E) (LISP-BYTE %%FEFHI-MS-BIND-DESC-LENGTH) READ-MEMORY-DATA)  ;# bind descs
	((M-E) ADD M-I A-E)			;Address of end of bind descs
	(JUMP-GREATER-OR-EQUAL M-ZERO A-ARGS-LEFT QBD1)	;No args, do missing optionals
;Bind loop used while args remain to be processed
QBINDL	((VMA-START-READ) M-I)			;Access word of binding options
	(CHECK-PAGE-READ)
	(JUMP-GREATER-OR-EQUAL M-I A-E QBMTA1)	;Out of bind desc, too many args
	((M-TEM) (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA)
	((M-I) M+A+1 M-I A-TEM)			;Space over this Q and name Q if present
	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QREDT1)
       ((M-Q) READ-MEMORY-DATA)			;Save bind desc in M-Q
		;Dispatch to QBRQA, QBROP1, QBRA, or QBTMA2

;Optional arg is present, space past initialization info if any
QBROP1	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPNP)	;to QBRQA,QBOSP,QBOASA

QBOSP	(JUMP-XCT-NEXT QBRQA)
       ((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)

QBOASA	((VMA-START-READ M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	((M-J) Q-POINTER READ-MEMORY-DATA)	;Change start addr to skip his initialization
;Required argument is present
QBRQA	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBSPCL)
;Enter here when arg has been bound.  These checks only cause exceptions.
QBDL1	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-DES-DT) M-Q QBDDT)
       ((M-C) Q-DATA-TYPE C-PDL-BUFFER-INDEX)
QBDDT1	;(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-QUOTE-STATUS) M-Q QBEQC)
       ;((M-C) Q-FLAG-BIT C-PDL-BUFFER-INDEX)
QBEQC1	((A-ARGS-LEFT Q-R) ADD (M-CONSTANT -1) A-ARGS-LEFT)
	(JUMP-GREATER-THAN-XCT-NEXT Q-R A-ZERO QBINDL)	;Proceed to next arg
       ((PDL-BUFFER-INDEX) ADD PDL-BUFFER-INDEX (A-CONSTANT 1))	;Next arg slot
	;drops in
;Bind loop used for missing optionals; push their default values onto the pdl
QBD1	((VMA-START-READ) M-I)			;Access word of binding options
	(CHECK-PAGE-READ)
	(JUMP-GREATER-OR-EQUAL M-I A-E QBDEND)	;Jump if did all bind desc Qs
	((M-TEM) (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA)
	((M-I) M+A+1 M-I A-TEM)			;Space over this Q and name Q if present
	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QBDT2)
       ((M-Q) READ-MEMORY-DATA)			;Save bind desc in M-Q
		;Dispatch to QBOPT1, QBRA1, QBLCL1, QBTFA1

;QBDEND - when all done (but locals not set up)
;QBLCL1 - when got a b.d. to start locals

;QBRA - rest arg and args present (could be spread or not)
;QBRA1 - rest arg missing

QREW1	(CALL-LESS-THAN M-E (A-CONSTANT 1) ILLOP)
	((VMA-START-READ) M-I)		;ACCESS WORD OF BINDING OPTIONS
	(CHECK-PAGE-READ)
	((M-E) SUB M-E (A-CONSTANT 1))
	((M-Q) READ-MEMORY-DATA)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) M-Q QBNDL2)
	((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)	;SKIP NAME Q IF PRESENT
QBNDL2	((M-TEM) (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT 2) ILLOP)	;WASN'T REST ARG??
	(CALL-GREATER-THAN M-ZERO A-LOCALP QLLOCB)	;SET UP LOCAL BLOCK OVER ARG
	((PDL-BUFFER-POINTER) M-D)		;SO DONT STORE LOCALS OVER ARG
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;REST ARG - FOR NOW I ASSUME MICRO-COMPILED FUNCTIONS DO STORE CDR CODES
QBRA	(CALL-NOT-EQUAL A-LCTYP M-ZERO ILLOP)	;IF A NON-SPREAD ARG, SHOULD NOT
						;GET TO REST ARG HERE.
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;MAKE PNTR TO LIST OF ARGS
       ((M-K) M-D)
	(CALL-GREATER-THAN-XCT-NEXT M-ZERO A-LOCALP QLLOCB)
       ((M-D) ADD M-D A-ARGS-LEFT)	 	;LOCATE LOCAL BLOCK AFTER LAST ARG
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-K	;STORE REST ARG AS FIRST LOCAL
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;ADVANCE TO NEXT BIND DESC

QBD0	(JUMP-NOT-EQUAL A-LCTYP M-ZERO QREW1)	;ALSO IS A NO-SPREAD ARG
;BINDING LOOP FOR WHEN ALL ARGS HAVE BEEN USED UP
QBD1	(JUMP-LESS-THAN
		M-E (A-CONSTANT 1) QBD2)	;JUMP IF FINISHED ALL BINDING
	((VMA-START-READ) M-I)			;GET NEXT BINDING DESC Q
	(CHECK-PAGE-READ)
	((M-E) SUB M-E (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA QBD2A)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;SKIP NAME IF PRESENT
QBD2A	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QBDT2)
       ((M-Q) READ-MEMORY-DATA)			;SAVE BINDING DESC IN M-Q

;LOCATE LOCAL BLOCK TO WHERE M-D POINTS
;AFTER THIS HAS BEEN CALLED, USE C-PDL-BUFFER-POINTER-PUSH TO STORE LOCALS
QLLOCB	(POPJ-AFTER-NEXT		;PDL-BUFFER-PTR SHOULD BE SET ALREADY?
					;  --NOT IF TOO FEW ARGS FOR ONE--.
	 (PDL-BUFFER-POINTER) SUB M-D (A-CONSTANT 1))	;FIRST PUSH WILL STORE @ M-D
       ((A-LOCALP) M-D)			;PDL INDEX OF LOCALS

;GOT ARG DESCRIPTOR WHEN OUT OF ARGS
QBTFA1	(JUMP-XCT-NEXT QBOPT2)			;SUPPLY ARG OF NIL
       ((M-QBTFA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)	;GIVE TOO FEW ARGS ERR LATER

QBRA1	(CALL-GREATER-THAN M-ZERO A-LOCALP QLLOCB)	;REST ARG MISSING, MAKE 1ST LOCAL NIL
QBOPT2	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;STORE MISSING ARG AS NIL (CDR CODE?)
QBD1A	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
       ((M-D) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
QBDIN1	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;INTERNAL
QBDINT	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN2)
	(JUMP-XCT-NEXT QBDIN1)	;IF SPECIAL, NO LOCAL SLOT, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

QBDIN2	(JUMP-XCT-NEXT QBOPT2)	;IF LOCAL, IGNORE AT BIND TIME BUT RESERVE LOCAL SLOT
       (CALL-GREATER-THAN M-ZERO A-LOCALP QLLOCB)	;ALSO MUST LOCATE LOCAL BLOCK


;FREE
QBDFRE	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN1) ;TAKES NO LCL SLOT
	(JUMP-XCT-NEXT QBDIN1)				    ;IF SPECIAL, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

;AUX
QBDAUX	(CALL-GREATER-THAN M-ZERO A-LOCALP QLLOCB)	;LOCATE LOCAL BLOCK, 
						; THEN DROP THROUGH TO INITIALIZE
QBOPT4	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPTT)

;OPTIONAL NOT PRESENT
QBOPT1	(JUMP-GREATER-THAN M-ZERO A-LOCALP QBOPT4)
	(CALL ILLOP)		;SHOULDN'T HAVE ARGS AFTER LOCAL BLOCK IS LOCATED

;OPTIONAL ARGUMENT INIT VIA ALTERNATE STARTING ADDRESS AND NOT PRESENT
;LEAVE STARTING ADDRESS ALONE AND INIT TO SELF, COMPILED CODE WILL
;RE-INIT.  BUT DON'T FORGET TO SKIP OVER THE START ADDRESS.
QBOPT5	((M-I) ADD M-I (A-CONSTANT 1))
;OPTIONAL OR AUX, INIT TO SELF OR NONE, LATER MAY BE REINITED BY COMPILED CODE
QBOPT3	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT)
			M-Q QBOPT2)		;LOCAL, INIT TO NIL
	((VMA-START-READ) M-T)			;SPECIAL, GET POINTER TO VALUE CELL
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-TRAP READ-MEMORY-DATA)	;FETCH EXTERNAL VALUE CELL.
							;MUST GET CURRENT VALUE, BUT NOT BARF
							;IF DTP-NULL.  MUST NOT LEAVE AN EVCP
							;SINCE THAT WOULD SCREW PREVIOUS
							;BINDING IF IT WAS SETQ'ED.
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)
;THIS IS LIKE QBD1A, EXCEPT THAT THE THING WE ARE BINDING IT TO
;MAY BE DTP-NULL, WHICH IS ILLEGAL TO LEAVE ON THE PDL BUFFER.
;ALSO, THE VARIABLE IS KNOWN NOT TO BE AN ARGUMENT THAT WAS SUPPLIED,
;SO THERE'S NO DANGER OF CLOBBERING USEFUL DEBUGGING INFORMATION
	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
       ((M-D) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
	((C-PDL-BUFFER-POINTER) A-V-NIL)	;STORE NIL OVER POSSIBLE GARBAGE
	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;INIT TO POINTER
QBOPNR	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ) M-I)			;FETCH THING TO INIT TOO, TRANSPORT IT
QBDR1	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)

;INIT TO C(POINTER)
QBOCPT	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ) M-I)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) READ-MEMORY-DATA)

;INIT TO CONTENTS OF "EFFECTIVE ADDRESS"
QBOEFF	((M-I VMA-START-READ) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 6) READ-MEMORY-DATA QBOFDT) ;DISPATCH ON REG
       ((M-1) (BYTE-FIELD 6 0) READ-MEMORY-DATA)	;PICK UP DELTA FIELD

QBFE	((M-1) (BYTE-FIELD 8 0) READ-MEMORY-DATA)	;FULL DELTA
	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) ADD M-A A-1)		;FETCH FROM FEF OF FCN ENTERING

QBQT	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) ADD M-1 A-V-CONSTANTS-AREA)	;FETCH FROM CONSTANTS PAGE

QBDLOC	(CALL-GREATER-THAN M-ZERO A-LOCALP ILLOP) ;TRYING TO ADDRESS LOCALS BEFORE LOCATED
	((PDL-BUFFER-INDEX) ADD M-1 A-LOCALP)	;FETCH LOCAL
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

QBDARG	((PDL-BUFFER-INDEX) ADD M-1 A-S ALU-CARRY-IN-ONE)	;FETCH ARG
	(JUMP-XCT-NEXT QBD1A)		;(%LP-INITIAL-LOCAL-BLOCK-OFFSET = 1)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

;TOO MANY ARGS
QBTMA2	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	(DISPATCH-XCT-NEXT  (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q QBDT2) ;FINISH BIND DESCS
       ((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCING LCL PNTR PAST THE EXTRA ARGS

;TOO MANY ARGS AND BIND DESC LIST ALL USED UP
QBTMA1	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCE LCL PNTR PAST THE EXTRA ARGS

;HERE WHEN BIND DESC LIST HAS BEEN USED UP
QBD2	(CALL-GREATER-THAN M-ZERO A-LOCALP QLLOCB)  ;SET UP LOCAL BLOCK
	((M-TEM) A-LOCALP)
	((M-TEM) SUB M-TEM A-S)
	((A-TEM1) DPB M-TEM (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;ASSEMBLE ENTRY STATE Q
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	(JUMP-XCT-NEXT QLENX)
       ((C-PDL-BUFFER-INDEX) DPB M-R
		(LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-TEM1)

;COME HERE WHEN BINDING A SPECIAL TO A LOCAL
QBLSPCL	((PDL-BUFFER-INDEX) PDL-BUFFER-POINTER)

;COME HERE WHEN BINDING A SPECIAL
; NOTE CODE BELOW CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C.  THIS IS FOR THE BENEFIT OF
;FRMBN1.  ITS A CROCK, BUT NON-MODULARITY WAS DEEMED WORTH IT BECAUSE OTHERWISE
;CLEAR WOULD HAVE TO BE DONE IN A LOOP.
;NOTE THAT IF WE CAME HERE FROM QBOPT3 THERE MAY BE ILLEGAL DATA TEMPORARILY ON THE PDL BUFFER!
;LETTERED REGS CLOBBERED: M-B, M-K.  M-T HAS S-V PNTR TABLE ADDR, M-C HAS FLAGS.
QBSPCL	((VMA-START-READ) M-T)			;GET SPECIAL VALUE CELL POINTER
	(CHECK-PAGE-READ)
	((M-1) ADD (M-CONSTANT 23.) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 TRAP)
	    (ERROR-TABLE PDL-OVERFLOW SPECIAL)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA) ;TRANSPORT THE SPECIAL VALUE CELL PTR
	((VMA-START-READ M-B) DPB READ-MEMORY-DATA Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CHECK-PAGE-READ)			;GET CONTENTS OF INTERNAL VALUE CELL
;CODE BELOW IS LOGICALLY SOMEWHAT SIMILAR TO QBND2.
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;CHASE FORWARDING PTR IF ANY
	((M-B) VMA)				;CELL ACTUALLY BOUND
	((M-K) Q-TYPED-POINTER READ-MEMORY-DATA) ;BINDING TO SAVE
	((M-TEM) C-PDL-BUFFER-INDEX)		;GET VAL TO BIND TO (ARG OR LOCAL)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT 
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER 
		A-TEM)		;NEW VALUE CELL CONTENTS
	(CHECK-PAGE-WRITE)
	((M-C) DPB M-ZERO (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) A-C) ;FOR FRMBN1'S BENEFIT
						;IF WE ARE COMING FROM THERE.
	(GC-WRITE-TEST)
	((WRITE-MEMORY-DATA) M-K)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL QBSPCL1)	;JUMP IF NOT FIRST IN BLOCK
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)	 ;ADVANCE TO NEXT S-V SLOT
	((M-K WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K)
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
QBSPCL1 ((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) M-B)
	(POPJ-AFTER-NEXT 
	 (VMA-START-WRITE M-K) A-QLBNDP)	;CLEARS POSSIBLE INVISIBLE POINTER FROM M-K
       (CHECK-PAGE-WRITE)

;DATA TYPE CHECKS
QDTATM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
QDTN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-EXTENDED-NUMBER)) QBDDT1)
QBDDT3	(JUMP-XCT-NEXT QBDDT1)		;BAD DATA TYPE
       ((M-QBBDT) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)

QDTFXN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP QBDDT3)

QDTSYM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
	(JUMP QBDDT3)

QDTLST	((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-C A-V-NIL QBDDT1)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-INDEX SKIP-IF-LIST)
	 (JUMP QBDDT3)
	(JUMP QBDDT1)

QDTFRM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FEF-POINTER)) QBDDT1)
	(JUMP QBDDT3)

;EVAL/QUOTE CHECKS
;QBEQE	(JUMP-EQUAL M-C A-ZERO QBEQC1)
;QBEQQ1	(JUMP-XCT-NEXT QBEQC1)
;      ((M-QBBQTS) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
;
;QBEQQ	(JUMP-NOT-EQUAL M-C A-ZERO QBEQC1)
;	(JUMP QBEQQ1)

;; Frame Bind.  Use the special-variable map and value-cell pointers to do the bindings
;; taking the values from the args and locals. 
FRMBN1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-SV-BITMAP)))
	(CHECK-PAGE-READ)
	((PDL-BUFFER-INDEX) M-AP)
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)))
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%FEFHI-SVM-ACTIVE) 
		READ-MEMORY-DATA ILLOP)  ;FOO FAST OPT 
			;SHOULD NOT BE ON UNLESS SVM IS. (IT ISNT WORTH IT TO HAVE
			;ALL THE HAIRY MICROCODE TO SPEED THIS CASE UP A TAD.)
	((M-C) (LISP-BYTE %%FEFHI-SVM-BITS) READ-MEMORY-DATA)
FRMBN2	(POPJ-EQUAL M-C A-ZERO)			;POPJ IF NO MORE BITS
	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) 
			M-C QBSPCL)	;QBSPCL CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C
       ((PDL-BUFFER-INDEX) ADD PDL-BUFFER-INDEX A-ZERO ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT FRMBN2)
       ((M-C) M+M M-C A-ZERO)			;Shift left

;POP A BLOCK OF BINDINGS
BBLKP	(JUMP-XCT-NEXT BBLKP1)
       ((M-ZR) SETCA A-ZERO)

;POP A BINDING (MUSTN'T BASH M-T, M-J, M-R, M-D, M-C)
QUNBND	((M-ZR) A-ZERO)
BBLKP1	((VMA-START-READ) A-QLBNDP)		;Get pntr to bound cell
	(CHECK-PAGE-READ)
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-Q) READ-MEMORY-DATA)
	((VMA-START-READ) M+A+1 M-ZERO A-QLBNDP)	;Previous contents
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE M-Q)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-LOCATIVE)) ILLOP)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-B) READ-MEMORY-DATA)
	((VMA-START-READ) M-Q)			;Access bound cell
	(CHECK-PAGE-READ)			;This is only to preserve cdr/flag bits
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-B)
	(CHECK-PAGE-WRITE)
	(JUMP-IF-BIT-SET Q-FLAG-BIT M-B BBLKP2)	;Jump if last binding in block
	(JUMP-NOT-EQUAL M-ZR A-ZERO BBLKP1)	;Loop if BBLKP
	(POPJ-IF-BIT-CLEAR-XCT-NEXT M-DEFERRED-SEQUENCE-BREAK-FLAG)	;Exit if QUNBND
       ((M-B) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  ;Dont leave a DTP-E-V-C-P in M-B
	(JUMP SB-REINSTATE)			; (If SB, this might make SG switch bomb).

BBLKP2	((M-B) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;Dont leave a DTP-E-V-P in M-B
	(POPJ-IF-BIT-CLEAR-XCT-NEXT M-DEFERRED-SEQUENCE-BREAK-FLAG)
       ((M-QBBFL) DPB M-ZERO A-FLAGS)		;NO MORE B.B.
SB-REINSTATE		;SB deferred.  Take it now?
	((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-INHIBIT-SCHEDULING-FLAG)
	(POPJ-NOT-EQUAL M-TEM A-V-NIL)
	((LOCATION-COUNTER) LOCATION-COUNTER)   ;write LC (assuring fetch of PC)
	(POPJ-AFTER-NEXT   			; and set SB req.
	  (INTERRUPT-CONTROL) IOR LOCATION-COUNTER (A-CONSTANT 1_26.))
       ((M-DEFERRED-SEQUENCE-BREAK-FLAG) DPB M-ZERO A-FLAGS)
