;;;CADR MACHINE MICROCODE		-*-FUNDAMENTAL-*- TO THE OPERATION OF THE SYSTEM

;	HERE COMES A MAN
;	TO LEAD YOU TO
;	YOUR VERY OWN MACHINE! 
;		TOMMY, THE WHO

; "Microprogramming is a wasteland of time and too dependant on
;	the technology of implementation."  --Gordon Bell


(SETQ UCADR  '(

;Notes re the ERROR-TABLE pseudo-op:
;  If the error list contains the symbol CALLS-SUB, the entry serves only
;to mark an interesting item for the user on the micro-stack.  Accordingly,
;the entry should be positioned to match with whats on the stack at the time of
;the error. In particular, it should be after the following instruction in case of
;CALL-XCT-NEXT, etc.  No EHS- properties or routines are associated in this case.
;  Otherwise, the entry is intended to match with trap location saved at location
;TRAP.  In this case it should also come after an XCT-NEXT'ed instruction if there is any.
;  These entries (may well) 
;coordinate with error recovery/printout routines in LISPM2;EHR >.  So check
;LISPM2;EHR > when making changes in the vicinity of an ERROR-TABLE which does not
;have a CALLS-SUB.  In particular, if the ERROR-TABLE entry is proceedable or to be made
;proceedable, make sure relevant quantities are all held in ACs that get saved
;(M-A, etc) as opposed to ones that dont (M-3, A-TEM1 etc).

;  To mark a point in the code to which proceed-routines may want to go,
;put an (ERROR-TABLE RESTART <name>) BEFORE the instruction.  <name> is any
;arbitrary symbol that does not conflict with any other used.

(ASSIGN-EVAL NQZUSD (EVAL (- 32. (LENGTH Q-DATA-TYPES))))	;# UNUSED DATA-TYPES
(ASSIGN-EVAL NATUSD (EVAL (- 32. (LENGTH ARRAY-TYPES))))	;# UNUSED ARRAY-TYPES
(ASSIGN-EVAL NHDUSD (EVAL (- 32. (LENGTH Q-HEADER-TYPES))))	;# UNUSED HEADER-TYPES
(ASSIGN-EVAL VERSION-NUMBER (EVAL VERSION-NUMBER)) ;MAKE SOURCE VERSION A CONSLP SYMBOL

;THESE SYMBOLS GET DEFINED SUITABLY FOR USE IN BYTE INSTRUCTIONS
;DATA LOADED WITH THESE MUST COME FROM M BUS

(DEF-DATA-FIELD Q-CDR-CODE 2 36)
(DEF-DATA-FIELD Q-FLAG-BIT 1 35)
(DEF-DATA-FIELD Q-DATA-TYPE 5 30)
(DEF-DATA-FIELD Q-DATA-TYPE-PLUS-ONE-BIT 6 27)
(DEF-DATA-FIELD Q-POINTER 30 0)
(DEF-DATA-FIELD Q-POINTER-WITHIN-PAGE 8 0)

(DEF-DATA-FIELD Q-TYPED-POINTER 35 0)	;POINTER+DATA-TYPE
(DEF-DATA-FIELD Q-ALL-BUT-TYPED-POINTER 3 35)
(DEF-DATA-FIELD Q-ALL-BUT-POINTER 10 30)
(DEF-DATA-FIELD Q-ALL-BUT-CDR-CODE 36 0)
(DEF-DATA-FIELD Q-ALL-BUT-POINTER-WITHIN-PAGE 30 8)

(DEF-DATA-FIELD SIGN-BIT 1 31.)
(DEF-DATA-FIELD BOXED-SIGN-BIT 1 23.)  ;SIGN OF A BOXED FIXNUM
(DEF-DATA-FIELD BOXED-NUM-EXCEPT-SIGN-BIT 23. 0)
(ASSIGN MINIMUM-FIXNUM 1_23.)	;SMALLEST FIXNUM
(DEF-DATA-FIELD BITS-ABOVE-FIXNUM 10 30)  ;BITS NOT USED IN REPRESENTING FIXNUM.

;"INVOKE" OPS	;GIVEN TO INVOKED ROUTINE TO TELL IT WHAT IS TRYING TO BE DONE TO IT
(ASSIGN CAR-INVOKE-OP 1)
(ASSIGN CDR-INVOKE-OP 2)
(ASSIGN RPLACA-INVOKE-OP 3)
(ASSIGN RPLACD-INVOKE-OP 4)
(ASSIGN ARRAY-HEAD-INVOKE-OP 5)
(ASSIGN DATA-TYPE-INVOKE-OP 6)
(ASSIGN NILP-INVOKE-OP 7)

;EXTRA BITS ON MICRO STACK
(DEF-DATA-FIELD %%-PPBMIR 1 14.)  ;FLAGS MACRO INSTRUCTION RETURN.  WHEN SEEN SET ON
				  ;MICRO-POPJ, CAUSES INSTRUCTION STREAM HARDWARE TO
				  ;FETCH NEXT MACROINSTRUCTION (IF NECESSARY).
(DEF-DATA-FIELD %%-PPBINF 2 15.)  ;IF THESE NON-ZERO, THEY SIGNAL PRESENCE OF ADDTL INFO
 (DEF-DATA-FIELD %%-PPBMIA 1 15.)	;MICRO-TO-MICRO CALL
 (DEF-DATA-FIELD %%-PPBMAA 1 16.)	;MICRO-TO-MACRO CALL
(DEF-DATA-FIELD %%-PPBSPC 1 17.)  ;DO BBLKP (POPPING A BLOCK OFF LINEAR BINDING PDL)
		; ON EXIT FROM THIS FCTN. FCTN MUST EXIT TO CBBLKP OR MRNMV TO CAUSE
		; THIS TO GET LOOKED AT.  ALSO, VARIOUS PDL GRUBLING ROUTINES 
		; LOOK AT THIS. 

(ASSIGN *CATCH-U-CODE-ENTRY-/# 0)	;MUST KNOW ABOUT THESE WHEN GRUBBLING STACK.. 
					; NOTE U-CODE ENTRY #'S ARE NORMALLY 
					; UNCONSTRAINED AND DETERMINE ONLY POSITION
					; IN MICRO-CODE-ENTRY-AREA, ETC. 

;INSTRUCTIONS FOR CHECKING FOR PAGE FAULTS, INTERRUPTS, SEQUENCE BREAKS
;ONE OF THESE MUST APPEAR AFTER EVERY INSTRUCTION THAT STARTS A MEMORY CYCLE.

;THIS ONE IS USED WHEN REFERENCING FIXED AREAS THAT SHOULD BE ALWAYS WIRED AND MAPPED
;E.G. INSIDE THE PAGE FAULT ROUTINES WHERE A RECURSIVE PAGE FAULT COULD NOT BE ALLOWED
(ASSIGN ILLOP-IF-PAGE-FAULT (PLUS CALL-CONDITIONAL PG-FAULT ILLOP))

;THESE TWO ARE WHAT ARE NORMALLY USED.  THEY CHECK FOR PAGE FAULTS AND
;INTERRUPTS (HANDLED ENTIRELY IN MICROCODE), BUT NOT SEQUENCE BREAKS.
(ASSIGN CHECK-PAGE-READ (PLUS CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT PGF-R-I))
(ASSIGN CHECK-PAGE-WRITE (PLUS CALL-CONDITIONAL PG-FAULT-OR-INTERRUPT PGF-W-I))

;THIS ONE IS USED WHEN YOU WANT TO BE ABLE TO WRITE A NOMINALLY READ-ONLY AREA,
;FOR INSTANCE IN THE TRANSPORTER WHEN IT IS FIXING A POINTER TO OLDSPACE.
;NOT CHECKING FOR INTERRUPTS IS JUST TO SAVE CODE.
(ASSIGN CHECK-PAGE-WRITE-FORCE (PLUS CALL-CONDITIONAL PG-FAULT PGF-W-FORCE))

;THESE TWO ARE USED WHEN AN INTERRUPT IS NOT ALLOWED, EITHER BECAUSE WE
;ARE INSIDE THE INTERRUPT HANDLER, BECAUSE WE ARE RETRYING A CYCLE IN
;PGF-R/PGF-W, OR BECAUSE WE DON'T WANT TO LET THE INTERRUPT HANDLER CHANGE THE MAP.
(ASSIGN CHECK-PAGE-READ-NO-INTERRUPT (PLUS CALL-CONDITIONAL PG-FAULT PGF-R))
(ASSIGN CHECK-PAGE-WRITE-NO-INTERRUPT (PLUS CALL-CONDITIONAL PG-FAULT PGF-W))

;THESE TWO ARE USED WHEN WE WANT TO ALLOW BOTH INTERRUPTS AND SEQUENCE BREAKS.
;NOTE THAT THE VMA HAD BETTER NOT POINT TO UNBOXED STORAGE WHEN THESE ARE USED.
(ASSIGN CHECK-PAGE-READ-SEQUENCE-BREAK
	(PLUS CALL-CONDITIONAL PG-FAULT-INTERRUPT-OR-SEQUENCE-BREAK PGF-R-SB))
(ASSIGN CHECK-PAGE-WRITE-SEQUENCE-BREAK
	(PLUS CALL-CONDITIONAL PG-FAULT-INTERRUPT-OR-SEQUENCE-BREAK PGF-W-SB))

;THESE NAMES ARE FOR USE WITH THE CALL-CONDITIONAL AND JUMP-CONDITIONAL
;INSTRUCTIONS WHEN SPECIAL CIRCUMSTANCES DICTATE SPECIAL HANDLING
(ASSIGN PG-FAULT JUMP-ON-PAGE-FAULT-CONDITION)
(ASSIGN NO-PG-FAULT (PLUS JUMP-ON-PAGE-FAULT-CONDITION INVERT-JUMP-SENSE))
(ASSIGN PG-FAULT-OR-INTERRUPT JUMP-ON-PAGE-FAULT-OR-INTERRUPT-PENDING-CONDITION)
(ASSIGN NO-PG-FAULT-OR-INTERRUPT
	(PLUS JUMP-ON-PAGE-FAULT-OR-INTERRUPT-PENDING-CONDITION INVERT-JUMP-SENSE))
(ASSIGN PG-FAULT-INTERRUPT-OR-SEQUENCE-BREAK
	JUMP-ON-PAGE-FAULT-OR-INTERRUPT-PENDING-OR-SEQUENCE-BREAK-CONDITION)

(ASSIGN LOWEST-A-MEM-VIRTUAL-ADDRESS 76776000)	;MUST BE 0 MODULO SIZE OF A-MEM
(ASSIGN LOWEST-IO-SPACE-VIRTUAL-ADDRESS 77000000)  ;BEGINING OF X-BUS IO SPACE
(ASSIGN LOWEST-UNIBUS-VIRTUAL-ADDRESS 77400000)    ;END OF X-BUS, BEGINNING OF UNIBUS

(DEF-DATA-FIELD OAL-BYTL-1 5 5)		;MICRO INSTRUCTION FIELDS
(DEF-DATA-FIELD OAL-MROT 5 0)
(DEF-DATA-FIELD OAH-A-SRC 10. 6)
(DEF-DATA-FIELD OAH-M-SRC 6 0)
(DEF-DATA-FIELD OAL-DEST 12. 14.)    ;THIS DEFINITION DOES NOT WIN FOR FUNCTIONAL DESTINATIONS
(DEF-DATA-FIELD OAL-A-DEST 10. 14.)  ;USE THIS WHEN SUPPLYING AN A-MEMORY DESTINATION
(DEF-DATA-FIELD OAL-M-DEST  5. 14.)  ;USE THIS WHEN SUPPLYING AN M-MEMORY DESTINATION
(DEF-DATA-FIELD OAL-JUMP 14. 12.)
(DEF-DATA-FIELD OAL-DISP 11. 12.)

(ASSIGN PDL-BUFFER-LOW-WARNING 20.)  ;MAX LENGTH BASIC FRAME + ADI
(ASSIGN PDL-BUFFER-SLOP 40.)	;NUMBER OF EXTRA WORDS TO LEAVE "UNUSED" AT END OF PDL BUFFER
				;4 FOR RANDOM UNCHECKED PUSHES, 10. FOR DISK HANDLER,
				; PLUS 26. FOR GOOD MEASURE. 
				;NOTE THAT CRUFT PUSHED BY SGLV SHOULD BE COUNTED IN THIS
(ASSIGN PDL-BUFFER-HIGH-LIMIT ;MAX VALUE FOR M-PDL-BUFFER-ACTIVE-QS.  THIS ALLOWS MAX SIZE 
	(DIFFERENCE 2000 (PLUS 400 PDL-BUFFER-SLOP))) ;ACTIVE FRAME. 

;MODIFIERS FOR THE DISPATCH INSTRUCTION, USED TO INVOKE THE TRANSPORTER
; ((VMA-START-READ) ---)
; (CHECK-PAGE-READ)
; ...
; (DISPATCH TRANSPORT-xxx) ;IF THIS DROPS THROUGH, OLD->NEW SPACE TRANSPORTATION
;			   ; HAS BEEN DONE AND INVISIBLE POINTERS HAVE BEEN FOLLOWED.
;			   ; VMA HAS THE ADDRESS, MD HAS THE CONTENTS.
; IT IS OK TO USE POPJ-AFTER-NEXT ON THE DISPATCH INSTRUCTION.
; DON'T USE POPJ-AFTER-NEXT OR JUMP-XCT-NEXT IN THE INSTRUCTION BEFORE
; A TRANSPORT.

;THE NAMES OF SOME OF THESE SHOULD BE CHANGED....
(ASSIGN TRANSPORT (PLUS (I-ARG 1) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-NO-TRAP (PLUS (I-ARG 21) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
				DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-CDR (PLUS (I-ARG 12) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			    DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-WRITE (PLUS (I-ARG 23) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
;	NEXT ONE KLUDGED UP TO NOT BARF AT TRAP TYPES SO BIND WILL WORK.
;	THIS HAS TO BE FIXED UP BETTER LATER.  WELL, MAYBE THIS IS REALLY RIGHT?
(ASSIGN TRANSPORT-NO-EVCP (PLUS (I-ARG 20) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-NO-EVCP-WRITE (PLUS (I-ARG 22) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-HEADER (PLUS (I-ARG 4) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-AC (PLUS (I-ARG 24) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
(ASSIGN TRANSPORT-SCAV (PLUS (I-ARG 30) Q-DATA-TYPE-PLUS-ONE-BIT DISPATCH-ON-MAP-19
			DISPATCH-PUSH-OWN-ADDRESS D-TRANSPORT))
	;I-ARG BIT 0 => MAKE DTP-EXTERNAL-VALUE-CELL-POINTER INVISIBLE
	;I-ARG BIT 1 => DON'T TRANSPORT (WRITING OVER THIS Q ANYWAY, OR ONLY CHECKING CDR CODE)
	;I-ARG BIT 2 => BARF ON DTP-ONE-Q-FORWARD, DTP-EXTERNAL-VALUE-CELL-POINTER
	;I-ARG BIT 3 => ONE-Q-FORWARD NOT INVISIBLE (JUST LOOKING FOR CDR CODE)
	;I-ARG BIT 4 => CAUSES IT NOT TO BARF IF TRAP DATATYPE IS SEEN

	;LATER THESE MAY USE MULTIPLE DISPATCH TABLES RATHER THAN I-ARG'S

;(DISPATCH ADVANCE-INSTRUCTION-STREAM) TO GET NEXT HALFWORD
(ASSIGN ADVANCE-INSTRUCTION-STREAM
	(PLUS (PLUS (PLUS DISPATCH-ADVANCE-INSTRUCTION-STREAM 
			  (BYTE-FIELD 1 31.)) ;NEEDFETCH BIT
		    LOCATION-COUNTER)
	      D-ADVANCE-INSTRUCTION-STREAM))

;(GC-WRITE-TEST)
;DO THIS AFTER STARTING A WRITE.  THIS CHECKS FOR WRITING A POINTER
;TO A PLACE YOU AREN'T ALLOWED TO POINT TO.  IF IT SEEMS TO BE SO,
;IT TRAPS TO A ROUTINE TO FIX THINGS UP, DO THE WRITE OVER AGAIN,
;AND COME BACK DO THE DISPATCH OVER AGAIN.  THIS IS USED IN THE
;IMPLEMENTATION OF "TEMPORARY STORAGE".
;IT IS OK TO COMBINE THIS WITH POPJ-AFTER-NEXT.
(ASSIGN GC-WRITE-TEST (PLUS DISPATCH Q-DATA-TYPE-PLUS-ONE-BIT
			    DISPATCH-ON-MAP-18 DISPATCH-PUSH-OWN-ADDRESS
			    WRITE-MEMORY-DATA D-GC-WRITE-TEST))

(LOCALITY M-MEM)	;ANYTHING WHICH IT IS DESIRED TO LDB OUT OF MUST BE IN M-MEM

M-GARBAGE	(0)	;THIS REG RANDOMLY STORED IN WHEN STORING IN FUNCTION 
			;DESTINATIONS AND NOT SIMULTANEOUSLY IN M-MEM

M-PGF-TEM (0)		;TEMPORARY LOCATION USED BY PAGE FAULT HANDLER

M-ZERO	(0)		;CONSTANT 0, USED FOR LDB OPERATIONS  (MUST BE IN LOCATION 2)
M-MINUS-ONE (-1)	;CONSTANT -1, USED FOR SIGN EXTENSION (MUST BE IN LOCATION 3)

;LETTERED REGISTERS, OR "PDP-10 ACS"
;THESE ARE PRESERVED BY SEQUENCE BREAKS, INTERRUPTS, AND PAGE FAULTS, AND MARKED-THROUGH
;BY THE GARBAGE COLLECTOR.  THEY MUST ALWAYS CONTAIN TYPED DATA.  SMALL
;NUMBERS (WITH TYPE-FIELD OF 0 OR 37) ARE ACCEPTABLE BY SPECIAL DISPENSATION.

M-ZR	(0)		;..
M-A	(0)		;.. 
M-B	(0)		;.. 
M-C	(0)		;.. 
M-D	(0)		;.. 
M-E	(0)		;.. 
M-T	(0)		;..	RESULT REGISTER, PSEUDO INDICATORS
M-R	(0)		;.. 
M-Q	(0)		;.. 
M-I	(0)		;.. 
M-J	(0)		;.. 
M-S	(0)		;.. 
M-K	(0)		;..
			;SEQUENCE BREAKS ALSO SAVE VMA, AND SAVE MD
			;BY RE-READING FROM VMA ON RESUME.  THE RE-READING OF
			;MEMORY DATA MEANS THE INTERRUPT IS EFFECTIVELY
			;INSERTED -BEFORE- THE READ CYCLE.  NOTE THAT THIS
			;ORDERING ALLOWS AN EFFECTIVE READ-PAUSE-WRITE CYCLE
			;TO BE DONE JUST BY DOING A READ THEN A WRITE, EVEN
			;THOUGH AFTER EACH CYCLE IS STARTED SEQ BRKS ARE CHECKED. 

M-AP	(0)		;POINTS AT EXECUTING FRAME
			;CAUTION: M-AP HOLDS A PDL BUFFER ADDRESS
			;TO GET CORRESPONDING MEMORY ADDRESS, 
			;USE CONVERT-PDL-BUFFER-ADDRESS
			;CAUTION: M-AP MUST NOT CONTAIN ANY GARBAGE IN THE HIGH BITS. 

;"NUMBERED REGISTERS".  THESE ARE TEMPORARIES WHICH ARE NOT MARKED THROUGH
;BY THE GARBAGE COLLECTOR.  THE FULL 32-BIT VALUES OF M-1 AND M-2 ARE SAVED
;IN STACK GROUPS, HENCE PRESERVED THROUGH SEQUENCE BREAKS, BUT M-3 AND M-4
;ARE NOT.
;M-1, M-2, M-3, AND M-4 ARE USED TO HOLD UNBOXED FIXNUMS OR FLONUM MANTISSAS;
;M-1, M-2 ARE THE FIRST AND SECOND ARGUMENTS RESPECTIVELY.
;M-1, M-2, M-3, AND M-4 ARE PRESERVED BY PAGE-FAULTS,
;BUT CAUTION SHOULD BE EXERCISED, GENERALLY THESE SHOULD ONLY BE VALID OVER
;A LOCALITY OF A FEW INSTRUCTIONS.
M-1	(0)
M-2	(0)
M-3	(0)
M-4	(0)

(LOC 26)  ;%MODE-FLAGS LISP VARIABLE IS MAPPED TO THIS LOCATION, SEE QCOM
M-FLAGS			;"MACHINE STATE FLAGS"
;FIRST COME "PROCESSOR FLAGS" IE THOSE SAVED AND RESTORED OVER MACRO CALL-RETURN
  (DEF-NEXT-BIT M-QBBFL M-FLAGS)	;BIND BLOCK PUT ON SPECIAL PDL (IN MACRO-CODE)
					;BIND BLOCK "OPEN" SIGNAL TO LOW LEVEL ROUTINES
					; IN MICRO-COMPILED FCTNS
					;ALSO SET IF FRAME HAS CLOSURE BINDING-BLOCK
 (DEF-DATA-FIELD M-FLAGS-PROCESSOR-FLAGS 1 0)	;BYTE POINTER TO PROCESSOR FLAGS
 (DEF-DATA-FIELD M-FLAGS-EXCEPT-PROCESSOR-FLAGS 37 1)
;END "PROCESSOR FLAGS", BEGIN PROCESSOR "MODES"
  (DEF-NEXT-FIELD M-CAR-SYM-MODE 2 M-FLAGS)	;CAR OF SYM GIVES: 
						;  ERROR
						;  ERROR EXCEPT (CAR NIL) = NIL
						;  NIL
						;  P-STRING ARRAY POINTER
  (DEF-NEXT-FIELD M-CAR-NUM-MODE 2 M-FLAGS)	;CAR OF NUMBER GIVES: 
						;  ERROR
						;  NIL
						;  "WHATEVER IT IS"
  (DEF-NEXT-FIELD M-CDR-SYM-MODE 2 M-FLAGS)	;CDR OF SYM GIVES: 
						;  ERROR
						;  ERROR EXCEPT (CDR NIL) = NIL
						;  NIL
						;  PROPERTY LIST
  (DEF-NEXT-FIELD M-CDR-NUM-MODE 2 M-FLAGS)	;CDR OF NUM GIVES: 
						;  ERROR
						;  NIL
						;  "WHATEVER IT IS"

  (DEF-NEXT-BIT M-DONT-SWAP-IN M-FLAGS)		;MAGIC FLAG FOR CREATING FRESH PAGES

  (DEF-NEXT-BIT M-TRAP-ENABLE M-FLAGS)		;1 ENABLE ERROR TRAPPING

  (DEF-NEXT-FIELD M-MAR-MODE 2 M-FLAGS)		;1 IS READ-TRAP, 2 IS WRITE-TRAP

  (DEF-NEXT-BIT M-PGF-WRITE M-FLAGS)		;1 IF CURRENT PG FAULT IS WRITING

    (DEF-BIT-FIELD-IN-REG M-FLAGS-MAR-DISP 3 11. M-FLAGS)
		;INCLUDES M-MAR-MODE AND M-PGF-WRITE

  ;FLAGS FOR CURRENT MAJOR SECTION OF CODE EXECUTING, LOOKED AT
  ;BY PAGE-FAULT AND SEQUENCE-BREAK HANDLERS
  (DEF-NEXT-BIT M-INTERRUPT-FLAG M-FLAGS)	;1 IF IN INTERRUPT HANDLER, NO PAGING PLEASE
  (DEF-NEXT-BIT M-SCAVENGE-FLAG M-FLAGS)	;1 IF IN SCAVENGER, NO SEQUENCE BREAKS
  (DEF-NEXT-BIT M-TRANSPORT-FLAG M-FLAGS)	;1 IF IN TRANSPORTER, NO SEQUENCE BREAKS
  (DEF-NEXT-BIT M-STACK-GROUP-SWITCH-FLAG M-FLAGS) ;1 IF SWITCHING SGS, NO SEQUENCE BREAKS
    (DEF-BIT-FIELD-IN-REG M-FLAGS-NO-SEQUENCE-BREAK 4 14. M-FLAGS)
	;M-INTERRUPT-FLAG, M-SCAVENGE-FLAG, M-TRANSPORT-FLAG, M-STACK-GROUP-SWITCH-FLAG
  (DEF-NEXT-BIT M-DEFERRED-SEQUENCE-BREAK-FLAG M-FLAGS) ;1 IF WANTING TO SEQUENCE-BREAK

  ( (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;SAME STUFF ALSO IN A-FLAGS
	  (BYTE-VALUE M-CAR-SYM-MODE 1)		;INITIAL MODE STATE
	  (BYTE-VALUE M-CAR-NUM-MODE 0)
	  (BYTE-VALUE M-CDR-SYM-MODE 1)
	  (BYTE-VALUE M-CDR-NUM-MODE 0)
	  (BYTE-VALUE M-DONT-SWAP-IN 0)
	  (BYTE-VALUE M-TRAP-ENABLE 0)
	  (BYTE-VALUE M-MAR-MODE 0)
	  (BYTE-VALUE M-PGF-WRITE 0)
	  (BYTE-VALUE M-INTERRUPT-FLAG 0)
	  (BYTE-VALUE M-SCAVENGE-FLAG 0)
	  (BYTE-VALUE M-TRANSPORT-FLAG 0)
	  (BYTE-VALUE M-STACK-GROUP-SWITCH-FLAG 0)
	  (BYTE-VALUE M-DEFERRED-SEQUENCE-BREAK-FLAG 0)))

M-PDL-BUFFER-ACTIVE-QS (0)	;HOLDS QS BETWEEN A-PDL-BUFFER-HEAD AND M-AP INCLUSIVE
				; SEE DISCUSSION ON PDL-BUFFER DUMP/REFILL

M-ERROR-SUBSTATUS  (0)	;IDENTIFING INFO WHEN TAKING ERROR.  IF NON-ZERO, THERE IS AN
			;ERROR PENDING
			;FOR NOW, AT LEAST, THIS IS ONLY USED BY FUNCTION-ENTRY ERRORS.
			;SYMBOL ASSIGNMENTS ARE UNIQUE TO EACH ERROR
  (DEF-NEXT-BIT M-QBTFA M-ERROR-SUBSTATUS)	;TOO FEW ARGS
  (DEF-NEXT-BIT M-QBTMA M-ERROR-SUBSTATUS)	;TOO MANY ARGS
  (DEF-NEXT-BIT M-QBEQTA M-ERROR-SUBSTATUS)	;ERRONEOUS QUOTED ARG
  (DEF-NEXT-BIT M-QBEEVA M-ERROR-SUBSTATUS)	;ERRONEOUS EVALUATED ARG
  (DEF-NEXT-BIT M-QBBDT M-ERROR-SUBSTATUS)	;BAD DATA TYPE
  (DEF-NEXT-BIT M-QBBQTS M-ERROR-SUBSTATUS)	;BAD QUOTE STATUS
 (RESET-BIT-POINTER M-ERROR-SUBSTATUS)

M-INST-BUFFER  (0)	;LAST MACRO INSTRUCTION Q FETCHED (2 INSTRUCTIONS)
  (DEF-BIT-FIELD-IN-REG M-INST-DEST 3 15 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))
  (DEF-BIT-FIELD-IN-REG M-INST-OP 4 11 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))
  (DEF-BIT-FIELD-IN-REG M-INST-ADR 11 0 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))
  (DEF-BIT-FIELD-IN-REG M-INST-ADR-*2+X 12 37 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))
  (DEF-BIT-FIELD-IN-REG M-INST-REGISTER 3 6 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))
  (DEF-BIT-FIELD-IN-REG M-INST-DELTA 6 0 (PLUS M-INST-BUFFER 
				      INSTRUCTION-STREAM))

M-LAST-MICRO-ENTRY	(0)	;HOLDS LAST MICRO ENTRY ADDRESS TRANSFERRED TO
				;IN THE JUMP FIELD.  SOMETIMES CLOBBERED W/O JUMP? 
M-TEM	(0)		;GENERAL-PURPOSE TEMPORARY, CLOBBERED BY PAGE FAULTS
			;THIS SHOULD ONLY BE USED OVER RANGES OF A FEW INSTRUCTIONS.

(LOCALITY A-MEM)

;;; THE FIRST 32. LOCATIONS SHADOW M-MEMORY. 
;;; THE M-LOCATIONS ARE CONSIDERED PRIMARY.  THE M-LOCATION SHOULD
;;; ALWAYS BE USED IN THE DESTINATION, SINCE WRITING IN M-MEMORY CLOBBERS
;;; A-MEMORY BUT WRITING IN A-MEMORY DOESN'T CLOBBER M-MEMORY.  THE A-LOCATION
;;; CAN BE USED AS A SOURCE WHEN NECESSARY TO GET IT INTO THE CORRECT
;;; SIDE OF THE ADDER OR TO OPERATE ON TWO M-LOCATIONS IN THE SAME INSTRUCTION. 

A-GARBAGE (0)
A-PGF-TEM (0)
A-ZERO	(0)		;CONSTANT 0 USED FOR LDB OPERATIONS-- MUST BE 2
A-MINUS-ONE (-1)	;CONSTANT -1 -- MUST BE 3
A-ZR	(0)		;SEE COMMENTS ON CORRESPONDING M-LOCATIONS
A-A	(0)
A-B	(0)
A-C	(0)
A-D	(0)
A-E	(0)
A-T	(0)
A-R	(0)
A-Q	(0)
A-I	(0)
A-J	(0)
A-S	(0)
A-K	(0)
A-AP	(0)
A-1	(0)
A-2	(0)
A-3	(0)
A-4	(0)
(LOC 26)  ;MUST, OF COURSE, BE AT SAME LOCATION AS M-FLAGS
A-FLAGS
  ( (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;SAME STUFF ALSO IN M-FLAGS
	  (BYTE-VALUE M-CAR-SYM-MODE 1)		;INITIAL MODE STATE
	  (BYTE-VALUE M-CAR-NUM-MODE 0)
	  (BYTE-VALUE M-CDR-SYM-MODE 1)
	  (BYTE-VALUE M-CDR-NUM-MODE 0)
	  (BYTE-VALUE M-DONT-SWAP-IN 0)
	  (BYTE-VALUE M-TRAP-ENABLE 0)
	  (BYTE-VALUE M-MAR-MODE 0)
	  (BYTE-VALUE M-PGF-WRITE 0)
	  (BYTE-VALUE M-INTERRUPT-FLAG 0)
	  (BYTE-VALUE M-SCAVENGE-FLAG 0)
	  (BYTE-VALUE M-TRANSPORT-FLAG 0)
	  (BYTE-VALUE M-STACK-GROUP-SWITCH-FLAG 0)
	  (BYTE-VALUE M-DEFERRED-SEQUENCE-BREAK-FLAG 0)))

A-PDL-BUFFER-ACTIVE-QS (0)
A-ERROR-SUBSTATUS (0)
A-INST-BUFFER (0)
A-LAST-MICRO-ENTRY (0)
A-TEM (0)

(LOC 40);SKIP OVER M-CONSTANTS

;"Q" STORAGE STARTS HERE.. IE THIS CAN "POTENTIALLY" BE RELOCATED DURING A GC

;FOLLOWING VECTOR OF A-MEM LOCATIONS ARE REFERENCED EXTERNALLY.  ORDER HERE MUST
; AGREE WITH A-MEMORY-LOCATION-NAMES IN QCOM

;A-VERSION MUST BE FIRST
A-VERSION	((PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		       VERSION-NUMBER)) ;VERSION NUMBER FROM SECOND FILE NAME OF SOURCE
A-AMCENT	(0)	;NUMBER OF ACTIVE MICRO-CODE ENTRIES, MUST BE TYPELESS
A-CNSADF	(0)	;DEFAULT-CONS-AREA.  DEFAULT AREA ARGUMENT TO CONS & RELATED FCNS.
			; THIS CAN BE AN AREA NUMBER, NIL MEANING USE A-WORKING-AREA,
			; OR T MEANING USE TEMPORARY STORAGE WHICH IF IT PROVES TO BE
			; PERMANENT WILL BE COPIED INTO A-WORKING-AREA.
A-WORKING-AREA	(0)	;AREA NUMBER IN WHICH WORKING CONSAGE HAPPENS.  DON'T CHANGE
			; THIS WITHOUT CALLING %CLEAN-TEMPORARY-SPACE.
A-MAXIMUM-TEMPORARY-OBJECT-SIZE	;MAX NUMBER OF Q'S IN AN OBJECT IN TEMPORARY STORAGE
		((PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX) 400))

;"SCRATCHPAD" CONSTANTS AND MODES
;INITIALIZED FROM SCRATCHPAD-INIT-AREA ON STARTUP.

A-SCRATCH-PAD-BEG  
A-INITIAL-FEF	(0)	;POINTER TO FEF OF FUNCTION TO START UP IN
A-QTRSTKG	(0)	;POINTER TO TRAP HANDLER STACK-GROUP
A-QCSTKG	(0)	;POINTER TO CURRENT STACK-GROUP
A-QISTKG	(0)	;POINTER TO INITIAL STACK-GROUP
A-SCRATCH-PAD-END 

;STACK-GROUP RELATED
A-SG-STATE	(0)	;SG-STATE Q OF CURRENT STACK GROUP
A-SG-PREVIOUS-STACK-GROUP (0)
A-SG-CALLING-ARGS-POINTER (0)
A-SG-CALLING-ARGS-NUMBER (0)
;A-SG-FOLLOWING-STACK-GROUP (0)

A-TRAP-MICRO-PC (0)	;PC OF (CALL TRAP) MICROINSTRUCTION

A-COUNTER-BLOCK-POINTER
		 ((BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		  (A-MEM-LOC A-COUNTER-BLOCK-BASE))
;PAGING CONTROLS
A-AGING-RATE ((BYTE-VALUE Q-DATA-TYPE DTP-FIX) 24.)	;NUMBER OF AGE STEPS PER DISK READ
A-MAR-LOW ((BYTE-VALUE Q-DATA-TYPE DTP-FIX)	;CDR CODE MUST BE ZERO!
	   77777777)		;LOWEST ADDRESS MAR IS SET ON, WITH FIXNUM TYPE
A-MAR-HIGH ((BYTE-VALUE Q-DATA-TYPE DTP-FIX)
	    77777776)		;HIGHEST ADDRESS MAR IS SET ON, FIXNUM TYPE (NOT +1)
				;IT'S UNCLEAR HOW THESE GET RELOCATED BY GC,
				;WILL HAVE TO FIX UP LATER.
A-SELF	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL)) ;LAST DTP-INSTANCE, ETC INVOKED
A-METHOD-SEARCH-POINTER			      ;POSITION IN METHOD-LIST WHERE LAST
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL)) ; METHOD FOUND.
A-INHIBIT-SCHEDULING-FLAG 	;IF NON-NIL, NO SEQUENCE BREAKS
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 5)
A-INHIBIT-SCAVENGING-FLAG	;IF NON-NIL, SCAVENGER DOESN'T RUN
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 5)
A-DISK-RUN-LIGHT ((BYTE-VALUE Q-DATA-TYPE DTP-FIX) 77051763)
				;LOCATION IN TV BUFFER ILLUMINATED WHEN DISK TRANSFERRING
				;THAT + 2 IS THE COMPLEMENT (FOR EASY COMPARISON)
				;THAT - 2 IS THE SCAVENGER RUN-LIGHT
A-LOADED-BAND ((BYTE-VALUE Q-DATA-TYPE DTP-FIX))
				;HIGH 24 BITS OF NAME OF BAND LOADED (FOR GREETING MSG)
;THESE TWO GET SET FROM THE LABEL
A-DISK-BLOCKS-PER-TRACK ((PLUS 17. (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
A-DISK-BLOCKS-PER-CYLINDER ((PLUS 85. (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;GC FLIP CONTROL
A-REGION-CONS-ALARM			;Counts new regions made
	((PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX) 0))
A-PAGE-CONS-ALARM			;Counts pages allocated to new regions
	((PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX) 0))
A-GC-FLIP-READY				;If non-NIL, there are no pointers to oldspace
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0)  ;NIL
A-INHIBIT-READ-ONLY			;If non-NIL, you can write in read-only
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0)  ;NIL
A-SCAVENGER-WS-ENABLE			;If non-NIL, scavenger gets limited working set
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 5)  ;T
A-METHOD-SUBROUTINE-POINTER		;CONTINUATION POINT FOR SELECT METHOD SUBROUTINE
	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0)  ;RETURN OR NIL
A-QLARYH ((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0) ;POINTER TO HEADER OF LAST ARRAY REFERENCED
A-QLARYL ((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0) ;ELEMENT # OF LAST ARRAY REFERENCED 
						 ; (W/ DTP-FIX DATA-TYPE)

;END OF VECTOR AREA

;FOLLOWING LOCATIONS ARE GC'ABLE BUT NOT USER'REFERENCEABLE

A-V-NIL		((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 0)	;POINTER TO NIL
A-V-TRUE	((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL) 5)	;POINTER TO T

A-END-Q-POINTERS ((BYTE-VALUE Q-DATA-TYPE DTP-SYMBOL)) ;WASTE A LOCATION TO FIX FENCEPOST ERROR
;END "Q" STORAGE

;FOLLOWING ARE 32 BIT UNTYPED COUNTERS AND METERS.  ORDER MUST AGREE WITH
; QCOM.  THIS BLOCK IS POINTED TO BY A-COUNTER-BLOCK-POINTER.
A-COUNTER-BLOCK-BASE  
A-FIRST-LEVEL-MAP-RELOADS  (0)	;# FIRST LEVEL MAP RELOADS
A-SECOND-LEVEL-MAP-RELOADS (0)	;# SECOND LEVEL MAP RELOADS
A-PDL-BUFFER-READ-FAULTS   (0)	;# TOOK PGF AND DID READ FROM PDL-BUFFER
A-PDL-BUFFER-WRITE-FAULTS  (0)	;# TOOK PGF AND DID WRITE TO PDL-BUFFER
A-PDL-BUFFER-MEMORY-FAULTS (0)	;# TOOK PGF FOR PDL-BUF, BUT DATA IN MAIN MEM.
A-DISK-PAGE-READ-COUNT     (0)	;COUNT OF PAGES READ FROM DISK
A-DISK-PAGE-WRITE-COUNT    (0)	;COUNT OF PAGES WRITTEN TO DISK
A-DISK-ERROR-COUNT         (0)	;COUNT OF RECOVERABLE ERRS
A-FRESH-PAGE-COUNT 	   (0)  ;COUNT OF FRESH PAGES 
				;  GENERATED IN CORE INSTEAD OF READ FROM DISK
A-PAGE-AGE-COUNT           (0)	;NUMBER OF TIMES AGER SET AGE TRAP
A-PAGE-FLUSH-COUNT         (0)	;NUMBER OF TIMES AGE TRAP -> FLUSHABLE
A-DISK-READ-COMPARE-REWRITES (0);NUMBER WRITES REDONE BECAUSE FAILED TO READ-COMPARE.
A-DISK-RECALIBRATE-COUNT   (0)  ;DUE TO SEEK ERRORS
A-META-BITS-MAP-RELOADS    (0)  ;RELOADS TO META-BITS-ONLY STATUS
A-COUNT-CHAOS-TRANSMIT-ABORTS (0)
A-DISK-READ-COMPARE-DIFFERENCES (0) ;NUMBER OF READ-COMPARE DIFFERENCES WITHOUT
				; ACCOMPANYING READ ERROR
;END OF COUNTER AREA.

;A-MEM EXTREMELY TEMPORARY WORKING REGISTERS. 
;CLOBBERED BY BOTH PAGE FAULTS AND INTERRUPTS.
;THESE SHOULD ONLY BE USED OVER RANGES OF A FEW INSTRUCTIONS.
A-TEM1	(0)	;VERY TEMPORARY
A-TEM2	(0)	;VERY TEMPORARY
A-TEM3	(0)	;VERY TEMPORARY

;A-MEM WORKING REGISTERS FOR VARIOUS SPECIFIC SECTIONS OF THE MICROCODE.
;THESE ARE NOT PRESERVED THROUGH SEQUENCE BREAKS.
A-TRANS-TEM	(0)	;TEMPORARY USED BY TRANSPORTER
A-TRANS-MD	(0)	;..
A-TRANS-VMA	(0)	;..
A-GC-TEM	(0)	;TEMPORARY FOR GC, E.G. FREE-REGION
A-INTR-TEM1	(0)	;TEMPORARY USED BY INTERRUPT HANDLERS
A-INTR-TEM2	(0)	;..
A-INTR-VMA	(0)	;VMA SAVED HERE THROUGH INTERRUPTS
A-INTR-MD	(0)	;MD SAVED HERE THROUGH INTERRUPTS
A-INTR-A	(0)	;SAVE M-A
A-INTR-B	(0)	;SAVE M-B
A-PGF-VMA (0)	;PAGE FAULT HANDLER SAVES VMA HERE
A-PGF-WMD (0)	;PAGE FAULT HANDLER SAVES WRITE-MEMORY-DATA HERE
A-PGF-T   (0)	;PAGE FAULT HANDLER SAVES M-T HERE
A-PGF-A   (0)	;PAGE FAULT HANDLER SAVES M-A HERE
A-PGF-B   (0)	;PAGE FAULT HANDLER SAVES M-B HERE
A-PDLB-TEM	(0)	;TEMPORARY USED BY PDL-BUFFER LOADING/DUMPING ROUTINES
A-FARY-TEM	(0)	;TEMPORARY USED BY XFARY
A-CONS-TEM	(0)	;TEMPORARY FOR THE USE OF CONS
A-CONS-NEW-FREE-POINTER (0) ;USED BY SCAV0
A-CONS-NEW-FP-REGION (0) ;..
A-TRANS-SAVE-A (0)	;REGISTER SAVING AT TRANS-COPY
A-TRANS-SAVE-B (0)
A-TRANS-SAVE-E (0)
A-TRANS-SAVE-K (0)
A-TRANS-SAVE-S (0)
A-TRANS-SAVE-T (0)

;Chaos net
A-CHAOS-CSR-ADDRESS (77772060)		;UNIBUS 764140
A-CHAOS-TRANSMIT-RETRY-COUNT (0)	;0 TRANSMIT NOT ACTIVE, ELSE NUMBER RETRIES TO GO

A-LCTYP	(0)	;LINEAR-CALL-TYPE DURING QLENTR (NORMAL, LEXPR, FEXPR, ETC)
A-NWADI (0)	;NUMBER WORDS "ADDITIONAL INFORMATION" PUSHED SO FAR

;Scavenger

A-CONS-WORK-DONE (0)	;K times number of Q's consed up (not a fixnum)
A-SCAV-WORK-DONE (0)	;number of Q's cleaned by scavenger (not a fixnum)
(ASSIGN SCAV-WS-SIZE 12.)	;number of pages in scavenger working-set
A-SCAV-PAGE-TABLE (REPEAT SCAV-WS-SIZE (-1)) ;-1 or virtual address of page brought in by scav
A-SCAV-PAGE-TABLE-PTR ((A-MEM-LOC A-SCAV-PAGE-TABLE)) ;Re-use pointer for above
A-SCAV-PTR (0)		;Address of next Q to scavenge (with type bits from gc-pointer)
A-SCAV-COUNT (0)	;Number of Q's remaining to be scavenged in that block
A-SCAV-SKIP (0)		;Number of Q's then to be skipped to get to next object.
A-SCAV-REGION (0)	;Region number of region containing above Q's
A-SCAV-REGION-ORIGIN (0);As pure number, for updating gc-pointer
A-SCAV-PDL-BASE (0)	;0 or base address of pdl currently being scavenged
A-SCAV-SAVE-A (0)
A-SCAV-SAVE-B (0)
A-SCAV-SAVE-T (0)

;PAGING VARIABLES AND CONSTANTS
A-DISK-PARITY-CHECK (1)		;NON-ZERO MEANS SCAN FOR PARITY ERROR AFTER DISK READ
A-PHT-INDEX-MASK ((EVAL (- SIZE-OF-PAGE-TABLE 2))) ;MASK FOR PAGE HASH TBL INDICES
A-FINDCORE-SCAN-POINTER (0)	;PHT INDEX OF LAST PLACE LOOKED AT BY FINDCORE
A-AGING-SCAN-POINTER (0)	;PHT INDEX OF NEXT PLACE AGER WILL LOOK AT
A-DISK-REGS-BASE (77377774)	;XBUS ADDRESS 17377774
;THESE TWO GET SET FROM THE PAGE PARTITION'S DESCRIPTOR IN THE LABEL.
A-DISK-OFFSET (0)		;DISK ADDRESS (IN QS, I.E. BLOCKS LSH 8) OF VIRTUAL LOC 0
A-DISK-MAXIMUM ((EVAL (LSH 20464 8)))	;1+ MAX ALLOWED VIRTUAL ADDR TO DISK (100. CYLINDERS)
(ASSIGN DISK-READ-COMMAND 0)	;WHAT TO STORE IN CSR TO START A READ
(ASSIGN DISK-WRITE-COMMAND 11)	;TO START A WRITE
(ASSIGN DISK-READ-COMPARE-COMMAND 10)  ;TO START A READ COMPARE
A-DISK-LAST-STATUS (0)		;STATUS READ ON LAST CALL TO DISK WAIT

A-TV-PLANE-SELECT  (77777330)	;UNIBUS ADDRESS OF TV-CONSOLE-SELECT-REGISTER
				; (ACTIVE PLANE IS SELECTED BY HIGH BYTE IN 16 BIT WD)
				;THIS IS FOR THE OLD 16-BIT TV SYSTEM
;PARAMETERS OF THE CURRENTLY SELECTED SCREEN (SEE TV-SELECT-SCREEN)
;NOT PRESERVED THROUGH SEQUENCE BREAKS
A-TV-CURRENT-SCREEN (0)		;CURRENTLY-SELECTED SCREEN, JUST FOR AN EFFICIENCY HACK
A-TV-SCREEN-BUFFER-ADDRESS (0)	;START ADDRESS OF BUFFER (IN VIRTUAL ADDRESS SPACE)
A-TV-SCREEN-BUFFER-END-ADDRESS (0)	;LAST BUFFER VIRTUAL ADDRESS +1
A-TV-SCREEN-LOCATIONS-PER-LINE (0)	;AMOUNT TO ADD TO ADDRESS TO GET TO NEXT RASTER LINE

;AREA ORIGIN POINTERS  (THESE ARE VIRTUAL ADDRESSES)
; THESE EXIST IN A-MEMORY ONLY TO SAVE TO ENABLE THEM TO BE REFERENCED
; WITHOUT A MEMORY CYCLE.  THEY ARE IN ORDER OF AREA NUMBER, AND ARE INITIALIZED
; AT UCADR STARTUP (BEG) AND NEVER CHANGED. 
;NOTE THAT THESE POINT TO FIXED AREAS, WHICH HAVE ONE REGION, SO THAT
;CONFUSION BETWEEN AREAS AND REGIONS AT THIS LEVEL IS ALLOWED AND ENCOURAGED
A-V-RESIDENT-SYMBOL-AREA	(0)	;RESIDENT SYM AREA
A-V-SYSTEM-COMMUNICATION-AREA	(0)	;MUST BE AT LOC 400
A-V-SCRATCH-PAD-INIT-AREA	(0)	;MUST BE AT LOC 1000
A-V-MICRO-CODE-SYMBOL-AREA	(0)	;FIRST 600 LOCS ARE UCODE STARTING ADRS
					; FOR (MACRO-CODE) MISC-INST S 200-777
					;FOLLOWING ARE OTHER RANDOM UCODE ENTRIES. 
A-V-PAGE-TABLE-AREA	(0)
A-V-PHYSICAL-PAGE-REGION-NUMBER (0)	;FOR EACH PAGE FRAME, REGION# OF PAGE SWAPPED IN THERE
A-V-REGION-ORIGIN	(0)		;VIRTUAL ADDRESS START OF REGION
A-V-REGION-LENGTH	(0)		;NUMBER OF QS IN REGION
A-V-REGION-BITS		(0)		;VARIOUS FIELDS, SEE QCOM
A-V-REGION-SORTED-BY-ORIGIN (0)		;REGION NUMBERS SORTED BY VIRTUAL ADDRESS
					; LAST ENTRY REPLICATED THROUGH TO END OF AREA
					; MUST HAVE DATA-TYPE DTP-FIX AND NO CDR-CODE
					; DOES NOT INCLUDE FREE REGIONS AND FREE REGION#S
A-V-REGION-FREE-POINTER	(0)		;RELATIVE ALLOCATION POINT.  ALLOCATION IS UPWARDS IN
					; STRUCTURE REGIONS, DOWNWARDS IN THOSE LIST REGIONS
					; THAT HAVE %%REGION-COMPACT-CONS-FLAG SET.
A-V-REGION-GC-POINTER	(0)		;VARIOUS USES, MAINLY RELATIVE DIRTY/CLEAN BOUNDARY
A-V-REGION-LIST-THREAD	(0)		;NEXT REGION# IN AREA, OR 1_23. + AREA# AT END OF LIST
					; THREADS FREE REGIONS (IN FREE-AREA) AND FREE REGION#S
A-V-AREA-NAME		(0)		;SYMBOL WHICH NAMES AREA (NIL FOR FREE AREA#S)
A-V-AREA-REGION-LIST	(0)		;FIRST REGION# IN AREA (FREE LIST FOR FREE AREA#S)
A-V-AREA-REGION-SIZE	(0)		;RECOMMENDED SIZE FOR NEW REGIONS
A-V-AREA-MAXIMUM-SIZE	(0)		;APPROXIMATE MAXIMUM #WDS IN THIS AREA
A-V-FREE-AREA		(0)		;OWNS REGIONS OF VIRTUAL ADDRESS SPACE WHICH ARE FREE
A-V-SUPPORT-ENTRY-VECTOR	(0)
A-V-CONSTANTS-AREA	(0)		;CONSTANTS PAGE (REF'ED IN ADR OF MACRO-CODE)
A-V-TEMPORARY-LIST-AREA (0)		;TEMPORARY STORAGE OF LIST TYPE
A-V-TEMPORARY-STRUCTURE-AREA (0)	;TEMPORARY STORAGE OF STRUCTURE TYPE
A-V-MICRO-CODE-ENTRY-AREA	(0)	;MICRO-CODE-ENTRY-AREA
A-V-MICRO-CODE-ENTRY-NAME-AREA	(0)	;PARALLEL TO PRECEDING, HAS SYMBOL WHICH IS NAME
A-V-MICRO-CODE-ENTRY-ARGS-INFO-AREA (0)	;MICRO-CODE-ENTRY-ARGS-INFO-AREA
A-V-MICRO-CODE-ENTRY-MAX-PDL-USAGE (0)	;MAXIMUM DEPTH ON PDL BEFORE MICRO TO MACRO CALL
A-V-MICRO-CODE-EXIT-AREA	(0)	;MICRO-CODE-EXIT-AREA

A-V-MISC-BASE	(0)	;BASE OF DISPATCH TABLE FOR MISC-INST . 
			; = A-V-MICRO-CODE-SYMBOL-AREA - 200

A-IPMARK	(0)	;POINTER TO LAST OPEN CALL BLOCK ON IP STACK, (= AP IF NONE)
			; CAUTION! THIS IS A PDL-BUFFER ADDRESS NOT A VIRTUAL ONE. 
A-PDL-BUFFER-VIRTUAL-ADDRESS	(0)	;VIRTUAL ADDRESS OF "HEAD" OF PDL BUFFER
		;IE THAT LOCATION OF PDL BUFFER THAT CORRESPONDS TO LOWEST VIRTUAL MEMORY
		;LOCATION AT THE CURRENT TIME. PURE NUMBER WITH NO GARBAGE IN HIGH BITS
A-PDL-BUFFER-HEAD	(0)	;PDL BUFFER INDEX CONSIDERED TO BE THE "HEAD"
		;IE THAT LOCATION OF PDL BUFFER THAT CORRESPONDS TO LOWEST VIRTUAL 
		;MEMORY LOCATION AT THE CURRENT TIME.  PURE NUMBER, WITH NO GARBAGE IN
		;HIGH BITS. 

;UNTYPED LOCATIONS

A-NARGS	(0)		;NUMBER ARGS FOR FUNCTION CURRENTLY ENTERING (TYPELESS)
A-LNUSV	(0)		;NUMBER UNSUPPLIED VALUES ON LAST MULTIPLE-VALUE CALL
A-QLOCO	(0)		;OFFSET BETWEEN LOCAL BLOCK AND ARG PNTR FOR CURRENT FCTN
A-SINF-PAD (0)		;RETURN VALUE FROM STRUCTURE-INFO
A-SINF-PDL-BASE (0)	;..

;TEMPORARIES IN FUNCTION ENTRY CODE
 ;TO SAVE SPACE, SHARED WITH *THROW TEMPORARIES

;TEMPORARIES IN *CATCH, *THROW, ETC
A-TEMPC			;TEMPORARY PC
A-CATCH-MARK	(0)	;MARK, IE, WHAT MUST BE IN FEF POINTER OF DESIRED FRAME

A-SG-TEM2            ;ANOTHER SG TEMP.
A-ARGS-LEFT		;NUMBER OF ARGS LEFT TO DO
A-CATCH-TAG	(0)	;WHAT MUST BE IN FIRST ARG POSITION OF THAT FRAME

A-SG-TEM 		;TEMPS USED BY SG-CODE.  HOLD INFO OVER SGENT MOSTLY
A-CATCH-COUNT	(0)  ;CAUSES THROWAGE TO STOP, WITH THE CURRENT ACTIVE FRAME
		     ; RETURNING TO THE PREVIOUS FRAME, IF ZERO.  IF NIL, DOESN'T APPLY.
A-SG-TEM1		; CAN'T USE PDL BUFFER FOR THESE SINCE BEING SWAPPED.
A-CATCH-ACTION  (0)  ;IF NON-NIL, CAUSES RETURN TO ERROR SG INSTEAD OF RESUMING
		     ; CURRENT SG AT CONCLUSION OF THROW.

;PAGE TRACE
A-PAGE-TRACE-PTR (0)	;0 DISABLED, ELSE ADDRESS OF NEXT 4-WORD ENTRY
A-PAGE-TRACE-START (0)	;FIRST ENTRY
A-PAGE-TRACE-END (0)	;LAST ENTRY+1 (WRAP-AROUND POINT)
A-PAGE-TRACE-VMA (0)	;TEMP: ADDRESS REFERENCED
A-PAGE-TRACE-UPC (0)	;TEMP: MICRO-PC AND SWAP-OUT FLAG

;CONNECTED WITH PDL-BUFFER MANAGEMENT
A-PDL-BUFFER-HIGH-WARNING  (PDL-BUFFER-HIGH-LIMIT)	;GO TO PDL-BUFFER-DUMP IF PUSH
			;FRAME AND M-PDL-BUFFER-ACTIVE-QS GREATER OR EQUAL TO THIS. 
			;NORMALLY STAYS AT PDL-BUFFER-HIGH-LIMIT, BUT WILL BE LESS
			;IF A-PDL-BUFFER-VIRTUAL-ADDRESS WITHIN 2000 OF A-QLPDLH. 
			;(THUS CAUSING XFER TO PDL-BUFFER-DUMP ON PUSH-DOWN-LIST 
			;OVERFLOW). 

;PDL POINTERS AND LIMITS.  INITIALIZED BY STACK-GROUP STUFF.
;THESE ARE PURE NUMBERS WITH NO DATA TYPE.
A-QLBNDP	(0)	;BIND STACK (SPECIAL PDL) POINTER; ADDRESS OF HIGHEST VALID WORD
A-QLBNDO	(0)	;LOW LIMIT OF BINDING STACK
A-QLBNDH	(0)	;HIGH LIMIT OF BINDING STACK
A-QLPDLO	(0)	;LOW LIMIT OF REGULAR PDL
A-QLPDLH	(0)	;HIGH LIMIT OF REGULAR PDL
			;REGULAR PDL POINTER IS IN HARDWARE PDL-BUFFER-POINTER REGISTER

;;; A-memory variables for BITBLT
A-ALUF	(0)			;OA-REG-LOW for ALU function
A-BITBLT-HOR-COUNT	(0)	;Counter for horizontal loop
A-BITBLT-COUNT		(0)	;Counter for vertical loop
A-BITBLT-TEM		(0)	;Temporary in inner loop
A-BITBLT-DST-WIDTH	(0)	;Width of destination region in bits
A-BITBLT-SRC-WIDTH	(0)	;Width of source array in bits
A-BITBLT-SRC-WIDTH-WORDS (0)	;Width of source array in words
A-BITBLT-SRC-Y		(0)	;Number of rows down to start at in source
A-BITBLT-SRC-Y-OFFSET	(0)	;Same translated to word offset

;;; A-memory locations for BBOOLE
A-BOOLE-CARRY-1 (0)
A-BOOLE-CARRY-2 (0)

;;; A-memory locations used by bignum-bignum division. 31. bit numbers both.
A-BDIV-V1	(0)
A-BDIV-V2	(0)

;;; Argument to TRANS-COPY
A-TRANS-COPY-FWD-DTP (0)

;;; LOCATIONS OF THE MAIN LOOP INDEXED BY %%SG-ST-INST-DISP OF SG-CURRENT-STATE
A-MAIN-DISPATCH		((PLUS (BYTE-MASK %%-PPBMIR) (I-MEM-LOC QMLP)))
A-DEBUG-DISPATCH	((PLUS (BYTE-MASK %%-PPBMIR) (I-MEM-LOC DMLP)))
A-SINGLE-STEP-DISPATCH	((PLUS (BYTE-MASK %%-PPBMIR) (I-MEM-LOC SINGLE-STEP)))
A-SINGLE-STEP-TRAP	((PLUS (BYTE-MASK %%-PPBMIR) (I-MEM-LOC STEP-BREAK)))

A-TRAP-AP-LEVEL		((BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE))

;FIRST LEVEL MAP STUFF

A-SECOND-LEVEL-MAP-REUSE-POINTER	
	(35)		;-> BLOCK OF SECOND LEVEL MAP NEXT TO BE REUSED
A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT
	(0)		;-> LOWEST NUMBERED BLOCK SAFE TO REUSE
;(MODULO 40)
;A-REVERSE-FIRST-LEVEL-MAP	
;	(0)		;FOR EACH BLOCK OF SECOND LEVEL MAP, SAYS WHICH FIRST
;(REPEAT 36 (-1))	;LEVEL MAP WORD POINTS TO THIS BLOCK CURRENTLY. 
;			;IS IN FORM OF A VMA TO ADDRESS THAT 1ST LVL MAP ENTRY. 
;A-REVERSE-FIRST-LEVEL-MAP-INIT-VALUE
;	(-1)	;THIS ONE IS NEVER CHANGED (ENTRY #37)

;*** gc-write-trap, x-clean-temporary-space, un-cons

;Structure of temporary space.
;This is a space in which objects which are consed then quickly become
;garbage can be quickly reclaimed without garbage collection.  In general
;it works by keeping track of where any pointers to such an object
;have been stored, other than in the pdl buffer and registers of the
;machine.  Pointers from other objects in temporary space do have to
;be kept track of.  The scheme is real-time in that non-garbage objects
;are continually flowing from temporary space to A-WORKING-AREA, with no
;long pauses while the area is cleaned out, except at a GC flip.  Issues
;of interaction with the regular GC are circumvented by flushing temporary
;storage just before a flip; hence there can never be pointers between
;old space and temporary space.

;Temporary space is divided into chunks for efficiency reasons.  Objects
;are grouped into chunks to cut down the overhead of moving objects out
;into permanent storage.  The temporary space is not all a single chunk
;in order to provide the "real-time" property, avoiding a long delay
;while a large chunk was "garbage-collected".  A chunk
;consists of a chunk-header, one or more objects, each with its object-header,
;and an array of back-pointers.  The back-pointers are addresses of cells
;which point to some location in the chunk, or did at one time.
;A temporary space is a circular array of chunks; when allocation wraps
;around an encounters an old chunk, it is flushed and any objects it
;contains which are still pointed-to are moved into more permanent storage.

;Pointers from one object in temporary space to another are a problem.
;Pointers from structure temporary space to temporary space (of either type)
;are not allowed, because of the problem that a back-pointer might end up
;pointing to an unboxed Q.  It doesn't seem worth taking care of this problem;
;instead, if a temporary structure tries to point to temporary space it is
;moved into permanent space.  Don't expect to make temporary list-structure
;out of arrays rather than cons cells.
;Since there are no unboxed Q's in list space, pointers from temporary list
;space to either type of temporary space are allowed.  Normally these are
;protected with back-pointers, but pointers within a single chunk are not.
;This allows most of the conses of an un-pointed-to list to be collected
;as garbage, rather than just the first one, assuming such lists usually
;fit all in one chunk.

;A chunk actually looks like, starting at low addresses:
;	2-word header
;	A sequence of objects, each preceded by its length
;	Free space in which additional objects could be allocated
;	A sequence of back-pointers, each one word long
;	Free space in which additional back-pointers could be allocated
;	The next chunk starts here

;These definitions are here rather than in QCOM since they should not be used by macrocode.

;The first word of a chunk header:
(DEF-DATA-FIELD TEMP-CHUNK-HDR1-OBJECT-FREE-PTR 20 20)
	;Offset to where the next object should be created.  0 is a special
	;case, indicating that is either free space or the end of the space.
(DEF-DATA-FIELD TEMP-CHUNK-HDR1-CHUNK-SIZE 20 0)
	;The number of words in this chunk, i.e. offset to next chunk.
	;If the OBJECT-FREE-PTR is 0, a non-zero CHUNK-SIZE indicates
	;simple unallocated space.  A zero CHUNK-SIZE marks the end of
	;the temporary space.  Thus an all-zero HDR1 word is the end-mark.
;The second word of a chunk header (not present if OBJECT-FREE-PTR = 0):
(DEF-DATA-FIELD TEMP-CHUNK-HDR2-FIRST-BACK-PTR 20 20)
	;Offset to the first back-pointer.  This also marks the limit on
	;object allocation within this chunk.
(DEF-DATA-FIELD TEMP-CHUNK-HDR2-BACK-PTR-FREE-PTR 20 0)
	;Offset to where the next back-pointer should be created.
	;CHUNK-SIZE is the maximum value of this; if we run out of back-pointers
	;we are forced to recycle the chunk prematurely.
(ASSIGN TEMP-CHUNK-OBJ-SIZE 100.)	;Normal size is 100. object words
(ASSIGN TEMP-CHUNK-N-BACK-PTRS 30.)	;and 30. back-pointers
(ASSIGN TEMP-CHUNK-HDR-SIZE 2)		;and 2 header words.

;The object header for each object in a chunk simply contains the unboxed size
;of that object, not including the header itself.  The Q-FLAG-BIT of this word
;is used as a garbage-collector mark bit sometimes.

;A-memory locations used by the temporary space feature

;These locations are permanent
;Each location is a pair, where the even-numbered location is
;for lists (%REGION-REPRESENTATION-TYPE-LIST = 0) and the odd-numbered
;location is for structures (%REGION-REPRESENTATION-TYPE-STRUCTURE = 1).

A-TEMP-SPACE-CURRENT-CHUNK (0) (0)	;Base address of current chunk
A-TEMP-SPACE-OBJ-FREE-PTR (0) (0)	;Address of next object to allocate
A-TEMP-SPACE-OBJ-SPACE-LEFT (0) (0)	;Number of words left to allocate

;These locations are temporary.



;;; DISPATCH TABLES

(LOCALITY D-MEM)

(LOC 3777) ;LAST LOCATION IN D-MEMORY MUST BE DROP THROUGH FOR TRANSPORTER TO WORK RIGHT.
	(P-BIT R-BIT)
(END-DISPATCH)

(START-DISPATCH 1 0)
;USE THIS DISPATCH WITH MULTI-UNIT INSTRUCTIONS.  FETCHES FROM MAIN MEM IF NECESSARY.
D-ADVANCE-INSTRUCTION-STREAM 
	(P-BIT R-BIT)	;DROP THRU
	(P-BIT INHIBIT-XCT-NEXT-BIT INSTRUCTION-STREAM-FETCHER)
(END-DISPATCH)

;DISPATCH ON MACRO OP CODE
;INSTRUCTION IN M-INST-BUFFER, LOCATION-COUNTER HAS ADDRESS OF NEXT INSTRUCTION.
;EFFECTIVE ADDRESS NOT PROCESSED YET, DISPATCH ON QADCM1-QADCM5 TO GET IT.
(START-DISPATCH 4 0)	;DO JUMP XCT NEXT, PUSH RETURN MANUALLY
OPDTB	(QICALL)	;0 CALL
	(QICAL0)	;1 CALL0
	(QIMOVE)	;2 MOVE
	(QICAR)		;3 CAR
	(QICDR)		;4 CDR
	(QICADR)	;5 CADR
	(QICDDR)	;6 CDDR
	(QICDAR)	;7 CDAR
	(QICAAR)	;10 CAAR
	(QIND1)		;11 ND1
	(QIND2)		;12 ND2
	(QIND3)		;13 ND3
	(QIBRN)		;14 BRANCH
	(MISC)		;15 MISC
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;16 UNUSED
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;17 UNUSED
(END-DISPATCH)

(START-DISPATCH 3 0)
;DESTINATION CODE DISPATCH, VALUE IN M-T
;EACH USE OF THIS DISPATCH TABLE MUST BE FOLLOWED BY A PUSH OF M-T WITH CDR-NEXT SET
QMDTBD	(R-BIT INHIBIT-XCT-NEXT-BIT)		;IGNORE (POPJ IMMEDIATELY)
	(R-BIT)					;TO STACK
	(R-BIT)					;TO NEXT
	(QMDDL INHIBIT-XCT-NEXT-BIT)		;TO LAST
	(QMDDR INHIBIT-XCT-NEXT-BIT)		;TO RETURN
	(R-BIT)					;TO NEXT "QUOTE =1" QUOTE BIT FEATURE LOSES
	(QMDDLQ INHIBIT-XCT-NEXT-BIT)		;TO LAST "QUOTE =1"        ..
	(QMDDNL INHIBIT-XCT-NEXT-BIT)		;TO NEXT LIST
(END-DISPATCH)

;DISPATCH ON REG FIELD FOR COMPUTE EFF ADR, USUAL CASE.
;WILL FETCH OPERAND INTO M-T
(START-DISPATCH 3 P-BIT)  ;DOES CALL-XCT-NEXT
QADCM1	(QAFE)		;FEF
	(QAFE)		;FEF+100
	(QAFE)		;FEF+200
	(QAFE)		;FEF+300
	(QAQT)		;CONSTANTS PAGE
	(QADLOC)	;LOCAL BLOCK
	(QADARG)	;ARG POINTER
	(QADPDL)	;PDL
(END-DISPATCH)

;THIS ONE IS THE SAME EXCEPT THAT IT DOESN'T XCT-NEXT.  USEFUL MAINLY TO SPEED UP NON-DEST.
(START-DISPATCH 3 (PLUS P-BIT INHIBIT-XCT-NEXT-BIT))
QADCM5	(QAFE)		;FEF
	(QAFE)		;FEF+100
	(QAFE)		;FEF+200
	(QAFE)		;FEF+300
	(QAQT)		;CONSTANTS PAGE
	(QADLOC)	;LOCAL BLOCK
	(QADARG)	;ARG POINTER
	(QADPDL)	;PDL
(END-DISPATCH)

(START-DISPATCH 3 0)	;DOES XCT NEXT
;DISPATCH ON REGISTER FIELD FOR STORE CYCLE, VALUE IN M-T.
;USE THIS ONE IF A READ CYCLE HASN'T BEEN DONE YET
QADCM2	(QSTFE)		;FEF
	(QSTFE)		;FEF+100
	(QSTFE)		;FEF+200
	(QSTFE)		;FEF+300
	(P-BIT ILLOP)	;CONSTANTS PAGE (ILLEGAL)
	(QSTLOC)	;LOCAL BLOCK
	(QSTARG)	;ARGUMENT BLOCK
	(P-BIT ILLOP)	;PDL (ILLEGAL)
(END-DISPATCH)

(START-DISPATCH 3 0) ;JUMP-XCT-NEXT
;DISPATCH ON REGISTER FIELD FOR OPERATIONS WHICH REQUIRE A TRULY EFFECTIVE ADDRESS
;IN THE VMA.  IF FEF, DO THAT.  OTHERWISE, CONVERT PDL BUFFER ADDRESS.
;POPJS WITH A LOCATIVE EFF ADDR ON THE PDL.
;THIS IS ONLY USED BY THE PUSH-E INSTRUCTION.
QADCM3	(QEAFE)	;FEF
	(QEAFE)		;FEF+100
	(QEAFE)		;FEF+200
	(QEAFE)		;FEF+300
	(P-BIT ILLOP)	;CONSTANTS PAGE (ILLEGAL)
	(QVMALCL)	;LOCAL BLOCK
	(QVMAARG)	;ARGUMENT BLOCK
	(P-BIT ILLOP)	;PDL (ILLEGAL)
(END-DISPATCH)

;DISPATCH FOR GETTING EFFECTIVE ADDRESS FOR BIND.
;THIS HAS TO HAVE A SPECIAL KLUDGE FOR DOING EXACTLY ONE LEVEL
;OF INDIRECTION ON DATA IN THE FEF.
(START-DISPATCH 3 P-BIT) ;CALL-XCT-NEXT
QADCM6	(QBAFE)		;FEF
	(QBAFE)		;FEF+100
	(QBAFE)		;FEF+200
	(QBAFE)		;FEF+300
	(ILLOP)		;CONSTANTS PAGE (ILLEGAL)
	(QVMALCL)	;LOCAL BLOCK
	(QVMAARG)	;ARGUMENT BLOCK
	(ILLOP)		;PDL (ILLEGAL)
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE.  DROPS THROUGH IN EITHER CASE BUT SKIPS IF ATOM. 
;AN ATOM IS ANYTHING OTHER THAN A LIST.
SKIP-IF-ATOM	
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(P-BIT R-BIT 0)				;LIST -- don't skip
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;U CODE ENTRY
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;FEF
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE.  DROPS THROUGH IN EITHER CASE BUT SKIPS IF LIST.
SKIP-IF-LIST	
	(P-BIT R-BIT 0)			;TRAP
	(P-BIT R-BIT 0)			;NULL
	(P-BIT R-BIT 0)			;FREE
	(P-BIT R-BIT 0)			;SYMBOL
	(P-BIT R-BIT 0)			;SYMBOL-HEADER
	(P-BIT R-BIT 0)			;FIX
	(P-BIT R-BIT 0)			;EXTENDED NUMBER
	(P-BIT R-BIT 0)			;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT R-BIT 0)			;LOCATIVE
	(P-BIT R-BIT INHIBIT-XCT-NEXT-BIT)	;LIST
	(P-BIT R-BIT 0)			;U CODE ENTRY
	(P-BIT R-BIT 0)			;FEF
	(P-BIT R-BIT 0)			;ARRAY-POINTER
	(P-BIT R-BIT 0)			;ARRAY-HEADER
	(P-BIT R-BIT 0)			;STACK-GROUP
	(P-BIT R-BIT 0)			;CLOSURE [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;SMALL-FLONUM 
	(P-BIT R-BIT 0)			;SELECT-METHOD [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;INSTANCE [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;INSTANCE-HEADER [NOT A LIST FOR PURPOSES OF THIS]
	(P-BIT R-BIT 0)			;ENTITY [NOT A LIST FOR PURPOSES OF THIS]
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA-TYPE OF FUNCTION GETTING CALLED (AT QMRCL OR MMCALL). 
;THE FUNCTION MUST BE IN BOTH M-A AND C-PDL-BUFFER-INDEX
;JUMPS TO APPROPRIATE CODE TO CALL THAT KIND OF FUNCTION, OR INTERPRETER TRAP. 
; INHIBIT-XCT-NEXT-BIT IS OFF IF A "LEAVE" IS INDICATED. 
;  A "LEAVE" IS INDICATED UNLESS
;	(1) A LOOP AROUND TYPE OPERATION IS PLANNED, IE SYM, INVZ
;	(2) DTP-ARRAY-POINTER.  HERE A LEAVE IS UNNECESSARY BECAUSE THE LINEAR PDL STATE
;		ISNT REALLY GOING TO GET CLOBBERED. 
;THIS DISPATCH IS DESIGNED TO BE USED FROM BOTH QMRCL AND MMCAL5. 

D-QMRCL	(P-BIT ILLOP)			;TRAP
	(P-BIT ILLOP)			;NULL
	(P-BIT ILLOP)			;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT QMRCL1)	;SYMBOL
	(P-BIT ILLOP)				;SYMBOL-HEADER
	(NUMBER-CALLED-AS-FUNCTION)	;FIX
	(NUMBER-CALLED-AS-FUNCTION)	;EXTENDED NUMBER
	(P-BIT ILLOP)			;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(INTP1)				;LOCATIVE
	(INTP1)				;LIST
	(QME1)				;U CODE ENTRY
	(QLENTR)			;FEF
	(INHIBIT-XCT-NEXT-BIT QARYR)	;ARRAY-POINTER
	(P-BIT ILLOP)			;ARRAY-HEADER
	(SG-CALL)			;STACK-GROUP
	(QCLS)				;CLOSURE
	(NUMBER-CALLED-AS-FUNCTION)	;SMALL-FLONUM 
	(CALL-SELECT-METHOD)		;SELECT-METHOD
	(P-BIT ILLOP)			;INSTANCE (TEMP)***
	(P-BIT ILLOP)			;INSTANCE-HEADER
	(CALL-ENTITY)			;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE BEFORE TAKING CAR
;IF DROPS THROUGH, NORMAL LIST-TYPE CAR
CAR-PRE-DISPATCH 
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT QCARSY)		;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT QCARNM)		;FIX
	(INHIBIT-XCT-NEXT-BIT QCARNM)		;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;BODY-FORWARD
	(P-BIT R-BIT)				;LOCATIVE
	(P-BIT R-BIT)				;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT R-BIT)				;CLOSURE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(P-BIT R-BIT)				;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT R-BIT)				;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON INPUT DATA TYPE WHEN TAKING CDR
;DROP THROUGH IF NORMAL LIST-TYPE CDR
CDR-PRE-DISPATCH
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT QCDRSY)		;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT QCDRNM)		;FIX
	(INHIBIT-XCT-NEXT-BIT QCDRNM)		;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT QCAR3)		;LOCATIVE.  NOTE CAR!!
	(P-BIT R-BIT)				;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT R-BIT)				;FRAME (LEGAL ???)
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT R-BIT)				;CLOSURE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(P-BIT R-BIT)				;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT R-BIT)				;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 2 0)	;MAYBE DOES XCT-NEXT
;DISPATCH ON CDR-CODE WHEN TAKING CDR
;POPJ-XCT-NEXT IF CDR-NEXT (PROBABLY MOST FREQUENT CASE)
CDR-CDR-DISPATCH 
	(INHIBIT-XCT-NEXT-BIT CDR-FULL-NODE)	;FULL-NODE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CDR NOT
	(INHIBIT-XCT-NEXT-BIT CDR-IS-NIL)	;CDR NIL
	(R-BIT)					;CDR NEXT
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CAR-SYM-MODE WHEN TAKING CAR OF SYM
CAR-SYM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(QCASE1)	;ERROR EXCEPT (CAR NIL) = NIL
	(XFALSE)	;NIL
	(P-BIT TRAP)	;"WHATEVER IT IS"
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CAR-NUM-MODE WHEN TAKING CAR OF NUM
CAR-NUM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(XFALSE)	;NIL
	(P-BIT TRAP)	;"WHATEVER IT IS"
	(P-BIT TRAP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CDR-SYM-MODE WHEN TAKING CDR OF SYM
CDR-SYM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(QCASE1)	;ERROR EXCEPT (CDR NIL) = NIL
	(XFALSE)	;NIL
	(QCDPRP)	;PROPERTY LIST
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON M-CDR-NUM-MODE WHEN TAKING CDR OF NUM
CDR-NUM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(XFALSE)	;NIL
	(P-BIT TRAP)	;"WHATEVER IT IS"
	(P-BIT TRAP)
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACA OF SYMBOL
RPLACA-SYM-DISPATCH 
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ALSO ERROR IF (CAR NIL) = NIL
	(P-BIT TRAP)	;OR IF (CAR SYM) = NIL
	(P-BIT TRAP)	;"SMASH P-STRING POINTER" - NOT ALLOWED
(END-DISPATCH)

(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DOING RPLACD OF SYM
RPLACD-SYM-DISPATCH
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(P-BIT TRAP)	;ERROR
	(QRDPRP)	;SMASH PROP LIST
(END-DISPATCH)

(START-DISPATCH 2 0)	;DOES XCT-NEXT
;DISPATCH ON CDR-CODE WHEN DOING RPLACD
RPLACD-CDR-DISPATCH
	(RPLACD-FULL-NODE)	;FULL NODE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CDR NOT
	(RPLACD-NEXT-NIL)	;CDR NIL
	(RPLACD-CDR-NEXT)	;CDR NEXT
(END-DISPATCH)

(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)
;DISP ON DATA TYPE OF POINTER-TO-SMASH-CONTENTS-OF WHEN DOING RPLACA
QRACDT	(P-BIT TRAP)	;TRAP
	(P-BIT TRAP)	;NULL
	(P-BIT TRAP)	;FREE
	(QRASYM)	;SYMBOL
	(P-BIT TRAP)	;SYMBOL-HEADER
	(P-BIT TRAP)	;FIX
	(P-BIT TRAP)	;EXTENDED NUMBER
	(P-BIT TRAP)	;HEADER
	(P-BIT TRAP)	;GC-FORWARD
	(P-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT TRAP)	;HEADER-FORWARD
	(P-BIT TRAP)	;BODY-FORWARD
	(QRAR3)		;LOCATIVE
	(QRAR3)		;LIST
	(P-BIT TRAP)	;U CODE ENTRY
	(QRAR3)		;FRAME
	(P-BIT TRAP)	;ARRAY-POINTER
	(P-BIT TRAP)	;ARRAY-HEADER
	(P-BIT TRAP)	;STACK-GROUP
	(QRAR3)		;CLOSURE
	(P-BIT TRAP)	;SMALL-FLONUM 
	(QRAR3)		;SELECT-METHOD
	(P-BIT TRAP)	;INSTANCE
	(P-BIT TRAP)	;INSTANCE-HEADER
	(QRAR3)		;ENTITY
 (REPEAT NQZUSD (P-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DATA TYPE OF POINTER-TO-SMASH-CONTENTS-OF WHEN DOING RPLACD
QRDCDT	(P-BIT TRAP)	;TRAP
	(P-BIT TRAP)	;NULL
	(P-BIT TRAP)	;FREE
	(QRDRSY)	;SYMBOL
	(P-BIT TRAP)	;SYMBOL-HEADER
	(P-BIT TRAP)	;FIX
	(P-BIT TRAP)	;EXTENDED NUMBER
	(P-BIT TRAP)	;HEADER
	(P-BIT TRAP)	;GC-FORWARD
	(P-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT TRAP)	;ONE-Q-FORWARD
	(P-BIT TRAP)	;HEADER-FORWARD
	(P-BIT TRAP)	;BODY-FORWARD
	(QRAR3)		;LOCATIVE. NOTE CAR!!
	(QRDR3)		;LIST
	(P-BIT TRAP)	;U CODE ENTRY
	(QRDR3)		;FRAME
	(P-BIT TRAP)	;ARRAY-POINTER
	(P-BIT TRAP)	;ARRAY-HEADER
	(P-BIT TRAP)	;STACK-GROUP
	(P-BIT TRAP)	;CLOSURE
	(P-BIT TRAP)	;SMALL-FLONUM 
	(QRDR3)		;SELECT-METHOD
	(P-BIT TRAP)	;INSTANCE
	(P-BIT TRAP)	;INSTANCE-HEADER
	(QRDR3)		;ENTITY
 (REPEAT NQZUSD (P-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;TRAP UNLESS DATA TYPE IS FIXNUM.
TRAP-UNLESS-FIXNUM
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(R-BIT)				;FIX  P-BIT AND R-BIT CAUSE DISPATCH TO BE A NO-OP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTENDED NUMBER - IS THIS RIGHT?
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 P-BIT);DOES CALL-XCT-NEXT
;DISPATCH ON ARRAY TYPE WHEN REF ING ARRAY
ARRAY-TYPE-REF-DISPATCH
	(INHIBIT-XCT-NEXT-BIT TRAP)
	(QB1RY)		;BIT ARRAY
	(QB2RY)		;2 BIT ARRAY
	(QB4RY)		;4 BIT ARRAY
	(QBARY)		;8 BIT ARRAY
	(QB16RY)	;16 BIT ARRAY
	(QB32RY)	;32 BIT ARRAY
	(QQARY)		;Q ARRAY
	(QQARY)		;LIST Q ARRAY
	(QBARY)		;STRING ARRAY
	(QQARY)		;STACK-GROUP HEAD
	(QQARY)		;SPEC-PDL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TV BUFFER (ONSOLETE)
	(QQARY)		;REG-PDL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TV-BUFFER-PIXEL (OBSOLETE)
 (REPEAT NATUSD (INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0)	;DOES XCT-NEXT
;DISPATCH ON ARRAY TYPE WHEN STORING INTO ARRAY
ARRAY-TYPE-STORE-DISPATCH
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)
	(QS1RY)		;BIT ARRAY
	(QS2RY)		;2 BIT ARRAY
	(QS4RY)		;4 BIT ARRAY
	(QSBARY)	;8 BIT ARRAY
	(QS16RY)	;16 BIT ARRAY
	(QS32RY)	;32 BIT ARRAY
	(QSQARY)	;Q ARRAY
	(QSLQRY)	;LIST Q ARRAY
	(QSBARY)	;BYTE ARRAY
	(QSQARY)	;STACK-GROUP HEAD
	(QSQARY)	;SPEC-PDL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TV BUFFER (OBSOLETE)
	(QSQARY)	;REG-PDL
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;TV-BUFFER-PIXEL (OBSOLETE)
 (REPEAT NATUSD (P-BIT INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 (PLUS P-BIT INHIBIT-XCT-NEXT-BIT))
;DISPATCH ON ARRAY TYPE AT XFARY
ARRAY-TYPE-FILL-DISPATCH 
	(TRAP)
	(QS1RY)		;BIT ARRAY
	(QS2RY)		;2
	(QS4RY)		;4
	(QSBARY)	;8
	(QS16RY)	;16
	(QS32RY)	;32
	(QSQARY)	;Q ARRAY
	(XFALAR)	;LIST -- SPECIAL HACKERY WITH CDR CODES TO EXTEND "LIST"
	(QSBARY)	;BYTE
	(QSQARY)	;STACK-GROUP HEAD
	(QSQARY)	;SPEC-PDL
	(TRAP)		;TV-BUFFER (OBSOLETE)
	(QSQARY)	;REG-PDL
	(TRAP)		;TV-BUFFER-PIXEL (OBSOLETE)
 (REPEAT NATUSD (TRAP))
(END-DISPATCH)

;DISPATCH ON "DESTINATION" FIELD OF BRANCH
(START-DISPATCH 3 0)	;DOES XCT-NEXT
BRDTAB	(QBRALW)
	(QBRNL)
	(QBRNNL)
	(QBRNLP)
	(QBRNNP)
	(QBRAT)
	(QBRNAT)
	(ILLOP)
(END-DISPATCH)

;DISPATCH ON ADDITIONAL INFO TYPE AT QLEAI3
(START-DISPATCH 3 0)	;USUALLY R-P NOOP
D-QLEAI3
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;0 ERR
	(INHIBIT-XCT-NEXT-BIT QLEAI4)	;1 MULT RET
	(INHIBIT-XCT-NEXT-BIT QLEAI4)	;2 RESTART PC
	(R-BIT P-BIT)			;3 FEXPR CALL
	(R-BIT P-BIT)			;4 LEXPR CALL
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;5 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;6 ERR
	(INHIBIT-XCT-NEXT-BIT ILLOP)	;7 ERR
(END-DISPATCH)

;DISPATCH ON TYPE OF ARG, ARG IS SUPPLIED
(START-DISPATCH 3 0)
QREDT1	(QBRQA)		;REQUIRED ARG
	(QBROP1)	;OPTIONAL ARG
	(QBRA)		;REST ARG
	(QBTMA2)	;AUX VAR, (HAVE REACHED END OF ARG SECT, WITH MORE ARGS)
	(QBTMA2)	;FREE,      ..
	(QBTMA2)	;INTERNAL,  ..
	(QBTMA2)	;INTERNAL-AUX,  ..
	(P-BIT ILLOP)	;UNUSED
(END-DISPATCH)

;DISPATCH ON INITIALIZING OPTION, OPT ARG HAS BEEN SUPPLIED
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
QBOPNP	(QBRQA)		;NONE
	(QBRQA)		;NIL
	(QBOSP)		;INIT TO POINTER (SPACE PAST)
	(QBOSP)		;INIT TO C(POINTER) (LIKEWISE)
	(QBOASA)	;ALT STARTING ADR, START THERE TO AVOID CLOBBERING IT
	(QBRQA)		;INIT BY COMPILED CODE
	(QBOSP)		;INIT TO C(EFF ADR)
	(QBRQA)		;INIT TO SELF
(END-DISPATCH)

;DISPATCH ON TYPE OF NEXT B-D-L ENTRY AFTER ALL PRESENT ARGS HAVE BEEN PROCESSED
(START-DISPATCH 3 0)	;DOES XCT-NEXT
QBDT2	(QBTFA1)	;THIS WAS A REQUIRED ARG, BARF
	(QBOPT1)	;THIS WAS AN OPT ARG, NOT PRESENT
	(QBRA1)		;THIS WAS A REST ARG, SET IT TO NIL
	(QBDAUX)	;AUX VAR, REALLY END OF ARG PART OF B-D-L
	(QBDFRE)	;FREE,     ..
	(QBDINT)	;INTERNAL, ..
	(QBDINT)	;INTERNAL-AUX, ..
	(P-BIT ILLOP)
(END-DISPATCH)

;DISPATCH ON INTIALIZING OPTION, GOING TO INITIALIZE VARIABLE
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
QBOPTT	(QBOPT3)	;NONE
	(QBOPT2)	;NIL
	(QBOPNR)	;INIT TO POINTER
	(QBOCPT)	;INIT TO C(POINTER)
	(QBOPT5)	;OPT ARG, ALT SA
			;ARG NOT PRESENT, SO LEAVE STARTING ADR ALONE 
			;AND LET CODE INIT IT
	(QBOPT3)	;INIT BY COMPILED CODE
	(QBOEFF)	;INIT TO CONTENTS OF "EFFECTIVE ADDRESS"
	(QBOPT3)	;INIT TO SELF (SAME AS NONE)
(END-DISPATCH)

;DISPATCH ON DESIRED DATA TYPE FOR ARG
(START-DISPATCH 4 0)	;DOES NXT INSTR
QBDDT	(R-BIT P-BIT)	;0 NO DATA TYPE CHECKING
	(QDTN)		;1 NUMBER
	(QDTFXN)	;2 FIXNUM
	(QDTSYM)	;3 SYMBOL
	(QDTATM)	;4 ATOM
	(QDTLST)	;5 LIST
	(QDTFRM)	;6 FRAME
(REPEAT 11 (P-BIT ILLOP))	;UNDEF CODE
(END-DISPATCH)

;DISPATCH ON DESIRED EVAL/QUOTE STATUS FOR ARG
;(START-DISPATCH 2 0)	;DOES NXT INSTR
;QBEQC	(R-BIT P-BIT)	;0 NO CHECKING
;	(QBEQE)		;1 DESIRED EVALUATED
;	(QBEQQ)		;2 DESIRED QUOTED
;	(QBEQQ)		;3 DESIRED BROKEN-OFF
;(END-DISPATCH)

;DISPATCH ON REGISTER FIELD OF EFF ADDR FOR INITIALIZING AUX VAR/OPT ARG
(START-DISPATCH 3 0)	;DOES NXT INSTR
QBOFDT	(QBFE)
	(QBFE)
	(QBFE)
	(QBFE)
	(QBQT)
	(QBDLOC)
	(QBDARG)
	(P-BIT ILLOP)	;PDL ILLEGAL
(END-DISPATCH)

(START-DISPATCH 3 0)  ;WANT XCT-NEXT
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-1 INSTRUCTIONS
;OPERAND FETCHED INTO M-T, VMA -> OPERAND
D-ND1	(ILLOP P-BIT)
	(QIADD)
	(QISUB)
	(QIMUL)
	(QIDIV)
	(QIAND)
	(QIXOR)
	(QIIOR)
(END-DISPATCH)

(START-DISPATCH 3 0)	;WANT XCT-NEXT
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-2 INSTRUCTIONS
;OPERAND FETCHED INTO M-T, VMA -> OPERAND
D-ND2	(QIEQL)
	(QIGRP)
	(QILSP)
	(QIEQ)
	(QISCDR)
	(QISCDDR)
	(QISP1)
	(QISM1)
(END-DISPATCH)

(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
;DISPATCH ON DEST FIELD OF NON-DEST-GROUP-3 INSTRUCTIONS
;OPERAND NOT FETCHED YET
D-ND3	(QIBND)
	(QIBNDN)
	(QIBNDP)
	(QISETN)
	(QISETZ)
	(QIPSHE)
	(QIMVM)
	(QIPOP)
(END-DISPATCH)

;DISPATCH ON RETURN STORING OPTION IN MVR (ADI IN PDL BUFFER)
(START-DISPATCH 3 0)	;DOES NXT INSTR
D-MVR	(P-BIT ILLOP)	;ERROR
	(MVRB)		;BLOCK
	(P-BIT ILLOP)	;STORE INTO LIST
	(MVRC)		;CONS UP LIST
	(MVRI)		;INDIRECT POINTER
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
(END-DISPATCH)

;DISPATCH ON RETURN STORING OPTION IN MVR (ADI NOT KNOWN TO BE IN PDL BUFFER)
(START-DISPATCH 3 0)	;DOES NXT INSTR
D-MVRV	(P-BIT ILLOP)	;ERROR
	(MVRBV)		;BLOCK
	(P-BIT ILLOP)	;STORE INTO LIST
	(MVRCV)		;CONS UP LIST
	(MVRIV)		;INDIRECT POINTER
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
	(P-BIT ILLOP)	;ERROR
(END-DISPATCH)

(START-DISPATCH 5 P-BIT)
;TRAP UNLESS DATA TYPE IS SYM
TRAP-UNLESS-SYM
	(INHIBIT-XCT-NEXT-BIT TRAP)	;TRAP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;NULL
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FREE
	(R-BIT)				;SYM  P-BIT & R-BIT CAUSE DISPATCH TO BE A NO-OP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FIX
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTENDED NUMBER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRAP))
(END-DISPATCH)

(START-DISPATCH 5 0) ;DOES XCT-NEXT UNLESS ILLOPS
;POPJ IF DATA TYPE IS NOT NUMERIC.  ONLY USED BY NUMBERP.
POPJ-IF-NOT-NUMBER 
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(R-BIT)					;NULL, POPJ
	(R-BIT)					;FREE, POPJ
	(R-BIT)					;SYM, POPJ
	(R-BIT)					;SYMBOL-HEADER, POPJ
	(P-BIT R-BIT)				;FIX, FALL-THROUGH
	(P-BIT R-BIT)				;EXTENDED NUMBER, FALL-THROUGH
	(R-BIT)					;HEADER, POPJ
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(R-BIT)					;LOCATIVE, POPJ
	(R-BIT)					;LIST, POPJ
	(R-BIT)					;U CODE ENTRY, POPJ
	(R-BIT)					;FEF, POPJ 
	(R-BIT)					;ARRAY-POINTER, POPJ
	(R-BIT)					;ARRAY-HEADER, POPJ
	(R-BIT)					;STACK-GROUP, POPJ
	(R-BIT)					;CLOSURE, POPJ
	(P-BIT R-BIT)				;SMALL-FLONUM, FALL-THROUGH
	(R-BIT)					;SELECT-METHOD, POPJ
	(R-BIT)					;INSTANCE, POPJ
	(R-BIT)					;INSTANCE-HEADER, POPJ
	(R-BIT)					;ENTITY, POPJ
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 5 0)  ;INHIBIT-XCT-NEXT-BIT UNLESS CANT FIGURE IT OUT 
		      ; (IE INTERPRETER TRAP)
XARGI-DISPATCH
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(R-BIT)					;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(XARGI3 INHIBIT-XCT-NEXT-BIT)		;SYM, REPLACE WITH FCTN CELL 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER	
	(R-BIT)					;FIX
	(R-BIT)					;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;BODY-FORWARD
	(R-BIT)					;LOCATIVE
	(R-BIT)					;LIST, (GO TO INTERPRETER)
	(XAGUE1 INHIBIT-XCT-NEXT-BIT)		;U CODE ENTRY
	(XAGM1 INHIBIT-XCT-NEXT-BIT)		;FEF, RETURN FAST OPT Q
	(XAGAR1 INHIBIT-XCT-NEXT-BIT)		;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(XAGISG INHIBIT-XCT-NEXT-BIT)		;STACK-GROUP
	(XAGICL INHIBIT-XCT-NEXT-BIT)		;CLOSURE
	(R-BIT)					;SMALL-FLONUM
	(R-BIT)					;SELECT-METHOD. CAN'T SAY WITHOUT KEY
						; SO BE CONSERVATIVE
	(R-BIT)					;INSTANCE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(XAGICL INHIBIT-XCT-NEXT-BIT)		;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

;DISPATCH ON FUNCTION TYPE WHEN RETURNING FROM QMEX1
(START-DISPATCH 5 0)	;XCT-NEXT UNLESS ILLOP
QMXRT	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;BODY-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(QMMRL)					;LIST
	(QMMR2)					;UCODE-ENTRY
	(QMEXF)					;FEF
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

;DISPATCH ON FUNCTION TYPE WHEN RETURNING FROM QBARY2
(START-DISPATCH 5 0)		;XCT-NEXT UNLESS ILLOP
QMXRT1	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;TRAP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;NULL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FREE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SYMBOL-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;FIX
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTENDED NUMBER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;GC-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ONE-Q-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;HEADER-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;BODY-FORWARD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LOCATIVE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;LIST
	(QBARY2)				;UCODE ENTRY
	(QBARY1)				;FEF
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-POINTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ARRAY-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;STACK-GROUP
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;CLOSURE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SMALL-FLONUM 
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SELECT-METHOD
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;INSTANCE-HEADER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;ENTITY
 (REPEAT NQZUSD (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)

;SKIP IF DATA-TYPE IS A POINTER, DON'T SKIP IF IT'S AN INUM
(START-DISPATCH 5 (PLUS P-BIT R-BIT))
SKIP-IF-POINTER
	(0)				;TRAP
	(INHIBIT-XCT-NEXT-BIT)		;NULL
	(0)				;FREE
	(INHIBIT-XCT-NEXT-BIT)		;SYMBOL
	(INHIBIT-XCT-NEXT-BIT)		;SYMBOL-HEADER
	(0)				;FIX
	(INHIBIT-XCT-NEXT-BIT)		;EXTENDED NUMBER
	(0)				;HEADER
	(INHIBIT-XCT-NEXT-BIT)		;GC-FORWARD
	(INHIBIT-XCT-NEXT-BIT)		;EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT)		;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT)		;HEADER-FORWARD
	(0)				;BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT)		;LOCATIVE
	(INHIBIT-XCT-NEXT-BIT)		;LIST
	(0)				;UCODE ENTRY
	(INHIBIT-XCT-NEXT-BIT)		;FEF
	(INHIBIT-XCT-NEXT-BIT)		;ARRAY-POINTER
	(0)				;ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT)		;STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT)		;CLOSURE
	(0)				;SMALL-FLONUM 
	(INHIBIT-XCT-NEXT-BIT)		;SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT)		;INSTANCE
	(INHIBIT-XCT-NEXT-BIT)		;INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT)		;ENTITY
 (REPEAT NQZUSD (0))
(END-DISPATCH)

(START-DISPATCH 6 P-BIT)	;TRANSPORTER DISPATCH ON DATA TYPE AND MAP BIT
;EITHER DROPS THROUGH (P-R) OR CALLS (P-N) MAGIC ROUTINE.
;FOR TYPES WHICH AREN'T INUMS, THE 0 CASE GOES TO TRANS-OLD TO CHECK FOR OLD-SPACE
D-TRANSPORT
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;0 TRAP
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 TRAP
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 NULL (TRANSPORT FOR SCAVENGER, XPCAL)
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 NULL
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;0 FREE
	(INHIBIT-XCT-NEXT-BIT TRANS-TRAP)	;1 FREE
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 SYMBOL
	(R-BIT)					;1 SYMBOL
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 SYMBOL-HEADER
	(R-BIT)					;1 SYMBOL-HEADER
	(R-BIT)					;0 FIX
	(R-BIT)					;1 FIX
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 EXTENDED-NUMBER
	(R-BIT)					;1 EXTENDED-NUMBER
	(R-BIT)					;0 HEADER
	(R-BIT)					;1 HEADER
	(INHIBIT-XCT-NEXT-BIT ILLOP)		;0 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT ILLOP)		;1 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT TRANS-OLDP-EVCP)	;0 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRANS-EVCP)	;1 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD0)	;0 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-OQF)	;1 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD0)	;0 HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-HFWD)	;1 HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-BFWD)	;0 BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-BFWD)	;1 BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 LOCATIVE
	(R-BIT)					;1 LOCATIVE
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 LIST
	(R-BIT)					;1 LIST
	(R-BIT)					;0 U CODE ENTRY
	(R-BIT)					;1 U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 FEF-POINTER
	(R-BIT)					;1 FEF-POINTER
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 ARRAY-POINTER
	(R-BIT)					;1 ARRAY-POINTER
	(R-BIT)					;0 ARRAY-HEADER
	(R-BIT)					;1 ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 STACK-GROUP
	(R-BIT)					;1 STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 CLOSURE
	(R-BIT)					;1 CLOSURE
	(R-BIT)					;0 SMALL-FLONUM
	(R-BIT)					;1 SMALL-FLONUM
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 SELECT-METHOD
	(R-BIT)					;1 SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 INSTANCE
	(R-BIT)					;1 INSTANCE
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 INSTANCE-HEADER
	(R-BIT)					;1 INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT TRANS-OLD)	;0 ENTITY
	(R-BIT)					;1 ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRANS-TRAP))
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT TRANS-TRAP))
(END-DISPATCH)

;THIS FLAVOR OF TRANSPORTER DISPATCH IS FOR THE PDL-BUFFER REFILL ROUTINE,
;WHICH MUST DO SOME FIXUP BEFORE CALLING THE TRANSPORTER
;ON THE 0 CASE OF NON-INUMS, IT MAY BE OLD-SPACE
(START-DISPATCH 6 0)	;TRANSPORTER DISPATCH ON DATA TYPE AND MAP BIT
;EITHER DROPS THROUGH (P-R) OR JUMPS TO PB-TRANS
D-PB-TRANS	
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 TRAP
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 TRAP
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 NULL
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 NULL
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 FREE
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 FREE
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 SYMBOL
	(P-BIT R-BIT)				;1 SYMBOL
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 SYMBOL-HEADER
	(P-BIT R-BIT)				;1 SYMBOL-HEADER
	(P-BIT R-BIT)				;0 FIX
	(P-BIT R-BIT)				;1 FIX
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 EXTENDED-NUMBER
	(P-BIT R-BIT)				;1 EXTENDED-NUMBER
	(P-BIT R-BIT)				;0 HEADER
	(P-BIT R-BIT)				;1 HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;0 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;1 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;1 BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 LOCATIVE
	(P-BIT R-BIT)				;1 LOCATIVE
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 LIST
	(P-BIT R-BIT)				;1 LIST
	(P-BIT R-BIT)				;0 U CODE ENTRY
	(P-BIT R-BIT)				;1 U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 FEF-POINTER
	(P-BIT R-BIT)				;1 FEF-POINTER
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 ARRAY-POINTER
	(P-BIT R-BIT)				;1 ARRAY-POINTER
	(P-BIT R-BIT)				;0 ARRAY-HEADER
	(P-BIT R-BIT)				;1 ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 STACK-GROUP
	(P-BIT R-BIT)				;1 STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 CLOSURE
	(P-BIT R-BIT)				;1 CLOSURE
	(P-BIT R-BIT)				;0 SMALL-FLONUM
	(P-BIT R-BIT)				;1 SMALL-FLONUM
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 SELECT-METHOD
	(P-BIT R-BIT)				;1 SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 INSTANCE
	(P-BIT R-BIT)				;1 INSTANCE
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 INSTANCE-HEADER
	(P-BIT R-BIT)				;1 INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT PB-TRANS)		;0 ENTITY
	(P-BIT R-BIT)				;1 ENTITY
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT PB-TRANS))
 (REPEAT NQZUSD (INHIBIT-XCT-NEXT-BIT PB-TRANS))
(END-DISPATCH)
(START-DISPATCH 6 P-BIT)	;GC-WRITE-TEST (MAP18: 0=CAN'T POINT TO, 1=NORMAL)
;EITHER DROPS THROUGH (P-R) OR CALLS (P-N) MAGIC ROUTINE.
;CURRENTLY ANYWAY, DOESN'T TRAP ON ILL DATA TYPES.  THAT WOULD NEED AN I-ARG TO SUPPRESS IT.
;TRAP ON ANY POINTER TYPE WHICH POINTS TO A PLACE YOU CAN'T POINT TO (TYPICALLY TEMPORARY
;STORAGE).  THIS CAN BE SPRUIOUS IF THE MAP WASN'T SET UP.
D-GC-WRITE-TEST
	(R-BIT)					;0 TRAP
	(R-BIT)					;1 TRAP
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 NULL
	(R-BIT)					;1 NULL
	(R-BIT)					;0 FREE
	(R-BIT)					;1 FREE
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 SYMBOL
	(R-BIT)					;1 SYMBOL
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 SYMBOL-HEADER
	(R-BIT)					;1 SYMBOL-HEADER
	(R-BIT)					;0 FIX
	(R-BIT)					;1 FIX
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 EXTENDED-NUMBER
	(R-BIT)					;1 EXTENDED-NUMBER
	(R-BIT)					;0 HEADER
	(R-BIT)					;1 HEADER
	(R-BIT)					;0 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(R-BIT)					;1 GC-FORWARD (SHOULDN'T SEE IN THIS CONTEXT)
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 EXTERNAL-VALUE-CELL-POINTER
	(R-BIT)					;1 EXTERNAL-VALUE-CELL-POINTER
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 ONE-Q-FORWARD
	(R-BIT)					;1 ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 HEADER-FORWARD
	(R-BIT)					;1 HEADER-FORWARD
	(R-BIT)					;0 BODY-FORWARD
	(R-BIT)					;1 BODY-FORWARD
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 LOCATIVE
	(R-BIT)					;1 LOCATIVE
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 LIST
	(R-BIT)					;1 LIST
	(R-BIT)					;0 U CODE ENTRY
	(R-BIT)					;1 U CODE ENTRY
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 FEF-POINTER
	(R-BIT)					;1 FEF-POINTER
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 ARRAY-POINTER
	(R-BIT)					;1 ARRAY-POINTER
	(R-BIT)					;0 ARRAY-HEADER
	(R-BIT)					;1 ARRAY-HEADER
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 STACK-GROUP
	(R-BIT)					;1 STACK-GROUP
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 CLOSURE
	(R-BIT)					;1 CLOSURE
	(R-BIT)					;0 SMALL-FLONUM
	(R-BIT)					;1 SMALL-FLONUM
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 SELECT-METHOD
	(R-BIT)					;1 SELECT-METHOD
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 INSTANCE
	(R-BIT)					;1 INSTANCE
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 INSTANCE-HEADER
	(R-BIT)					;1 INSTANCE-HEADER
	(INHIBIT-XCT-NEXT-BIT GC-WRITE-TRAP)	;0 ENTITY
	(R-BIT)					;1 ENTITY
 (REPEAT NQZUSD (R-BIT))
 (REPEAT NQZUSD (R-BIT))
(END-DISPATCH)

(START-DISPATCH 5 0)
;DISPATCH ON DATA TYPE OF WORD JUST STORED FROM PDL BUFFER INTO MAIN MEMORY,
;OR RETURNED FROM A FUNCTION.
;ILLOP ON DATA TYPE WHICH SHOULDN'T HAVE BEEN THERE IN THE FIRST PLACE
D-ILLOP-IF-BAD-DATA-TYPE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT R-BIT 0)				;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL-HEADER
	(P-BIT R-BIT 0)				;FIX
	(P-BIT R-BIT 0)				;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT R-BIT 0)				;LOCATIVE
	(P-BIT R-BIT 0)				;LIST
	(P-BIT R-BIT 0)				;U CODE ENTRY
	(P-BIT R-BIT 0)				;FEF
	(P-BIT R-BIT 0)				;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT R-BIT 0)				;STACK-GROUP
	(P-BIT R-BIT 0)				;CLOSURE
	(P-BIT R-BIT 0)				;SMALL-FLONUM 
	(P-BIT R-BIT 0)				;SELECT-METHOD
	(P-BIT R-BIT 0)				;INSTANCE
	(P-BIT R-BIT 0)				;INSTANCE-HEADER
	(P-BIT R-BIT 0)				;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

;;; INITIALIZATION

(LOCALITY I-MEM)

ZERO	(JUMP ZERO HALT-CONS)		;WILD TRANSFER TO ZERO

;This is location 1.  Enter here if virtual memory is valid.
BEG	(JUMP BEG000)

;Enter here from the PROM.  Virtual memory is not valid yet.
(LOC 6)
PROM	(JUMP-NOT-EQUAL-XCT-NEXT Q-R A-ZERO PROM)    ;These 2 instructions duplicate the prom
       ((Q-R) ADD Q-R A-MINUS-ONE)
;;; Decide whether to restore virtual memory from saved band on disk, i.e.
;;; whether this is a cold boot or a warm boot.  If the keyboard has input
;;; available, and the character was RETURN (rather than RUBOUT), it's a warm boot.
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) (A-CONSTANT 17772045))		;Unibus address 764112 (KBD CSR)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 5) MD	;If keyboard is not ready,
		COLD-BOOT)			; assume we are supposed to cold-boot
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) (A-CONSTANT 17772040))		;Unibus address 764100 (KBD LOW)
	((MD) (BYTE-FIELD 6 0) MD)		;Get keycode
	(JUMP-EQUAL MD (A-CONSTANT 46) COLD-BOOT)	;This is cold-boot if key is RUBOUT
	((MD) (A-CONSTANT 46))			;Standardize mode.  Mostly, set to NORMAL speed
	(CALL-XCT-NEXT PHYS-MEM-WRITE)		;40 is PROM-DISABLE, 2 is NORMAL speed.
       ((VMA) (A-CONSTANT 17773005))		;Unibus 766012
		;drops into BEG000
BEG000	((M-ZERO) SETZ)				;DON'T GET SCREWED BY CLOBBERED LOC 2@A
	(CALL WARM-READ-LABEL)			;Find out where to page off of
BEG0000	((M-FLAGS) (A-CONSTANT (PLUS		;RE-INITIALIZE ALL FLAGS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE M-CAR-SYM-MODE 1)
		(BYTE-VALUE M-CAR-NUM-MODE 0)
		(BYTE-VALUE M-CDR-SYM-MODE 1)
		(BYTE-VALUE M-CDR-NUM-MODE 0)
		(BYTE-VALUE M-DONT-SWAP-IN 0)
		(BYTE-VALUE M-TRAP-ENABLE 0)	;MACROCODE WILL TURN ON TRAPS WHEN READY
		(BYTE-VALUE M-MAR-MODE 0)
		(BYTE-VALUE M-PGF-WRITE 0)
		(BYTE-VALUE M-INTERRUPT-FLAG 0)
		(BYTE-VALUE M-SCAVENGE-FLAG 0)
		(BYTE-VALUE M-TRANSPORT-FLAG 0)
		(BYTE-VALUE M-STACK-GROUP-SWITCH-FLAG 0)
		(BYTE-VALUE M-DEFERRED-SEQUENCE-BREAK-FLAG 0))))
	((A-TV-CURRENT-SCREEN) SETZ)		;..
	((A-SCAV-COUNT) SETZ)			;Forget scavenger state
	((INTERRUPT-CONTROL) DPB (M-CONSTANT -1)  ;RESET THE BUS INTERFACE AND I/O DEVS
		(BYTE-FIELD 1 28.) A-ZERO)
	((M-1) (A-CONSTANT 40))			;GENERATE RESET FOR 10 MICROSECONDS
RST	(JUMP-NOT-EQUAL-XCT-NEXT M-1 A-ZERO RST)
       ((M-1) SUB M-1 (A-CONSTANT 1))
	((INTERRUPT-CONTROL) DPB (M-CONSTANT -1)  ;CLEAR RESET, SET HALFWORD-MODE,
		(BYTE-FIELD 1 27.) A-ZERO)	  ;AND ENABLE INTERRUPTS
	((MD) SETZ)
	(CALL-XCT-NEXT PHYS-MEM-WRITE)		;RESET BUS INTERFACE STATUS.
       ((VMA) (A-CONSTANT 17773022))		;UNIBUS LOC 766044
	(CALL INITIAL-MAP)			;SET UP MAP
	((A-INHIBIT-SCHEDULING-FLAG) A-V-TRUE)	;DISABLE SEQUENCE BREAKS
	((A-INHIBIT-SCAVENGING-FLAG) A-V-TRUE)	;GARBAGE COLLECTOR NOT TURNED ON UNTIL LATER
	((A-PAGE-TRACE-PTR) SETZ)		;SHUT OFF PAGE-TRACE
	((VMA-START-READ) (A-CONSTANT 1031))	;FETCH MISCELLANEOUS SCRATCHPAD LOCS
	(ILLOP-IF-PAGE-FAULT)
	((A-AMCENT) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT 1021))
	(ILLOP-IF-PAGE-FAULT)
	((A-CNSADF) A-V-NIL)			;CONS IN DEFAULT AREA, NO TEMPORARY STORAGE YET
	((A-WORKING-AREA) Q-TYPED-POINTER READ-MEMORY-DATA)	;AREA NUMBER TO WORK IN
	((VMA-START-READ) (A-CONSTANT (EVAL (PLUS 400 %SYS-COM-AREA-ORIGIN-PNTR))))
	(ILLOP-IF-PAGE-FAULT)
	((VMA) SUB READ-MEMORY-DATA (A-CONSTANT 1)) ;1- ADDR OF AREA-ORIGIN TABLE
	((M-K) (A-CONSTANT (A-MEM-LOC A-V-RESIDENT-SYMBOL-AREA)))
BEG02	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	((OA-REG-LOW) DPB M-K OAL-A-DEST A-ZERO)	;DESTINATION
	((A-GARBAGE) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL-XCT-NEXT M-K (A-CONSTANT (A-MEM-LOC A-V-MICRO-CODE-EXIT-AREA)) BEG02)
       ((M-K) ADD M-K (A-CONSTANT 1))
	((M-K) SUB M-ZERO (A-CONSTANT 200))	;FIRST 200 MICRO ENTRIES ARE NOT IN TABLE
	((A-V-MISC-BASE) ADD M-K A-V-MICRO-CODE-SYMBOL-AREA)
	((A-TEMPORARY-LIST-CONS-PTR) A-V-TEMPORARY-LIST-AREA)
	((A-TEMPORARY-STRUCTURE-CONS-PTR) A-V-TEMPORARY-STRUCTURE-AREA)
	;; Get A-INITIAL-FEF, A-QTRSTKG, A-QCSTKG, A-QISTKG
	((VMA) (BYTE-FIELD 9 0) (M-CONSTANT -1)) ;777 ;SCRATCH-PAD-INIT-AREA MINUS ONE
	((M-K) (A-CONSTANT (A-MEM-LOC A-SCRATCH-PAD-BEG))) ;FIRST A MEM LOC TO BLT INTO
BEG03	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((OA-REG-LOW) DPB M-K OAL-A-DEST A-ZERO)	;DESTINATION
	((A-GARBAGE) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL-XCT-NEXT M-K (A-CONSTANT (A-MEM-LOC A-SCRATCH-PAD-END)) BEG03)
       ((M-K) ADD M-K (A-CONSTANT 1))
	((VMA-START-READ) A-INITIAL-FEF)	;INDIRECT
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((A-INITIAL-FEF) READ-MEMORY-DATA)

	(CALL-XCT-NEXT SG-LOAD-STATIC-STATE)	;INITIALIZE PDL LIMITS ETC
       ((A-QCSTKG) A-QISTKG)			;FROM INITIAL STACK-GROUP
	((A-QLBNDP) ADD (M-CONSTANT -1) A-QLBNDO) ;INITIALIZE BINDING PDL POINTER
			; POINTS AT VALID LOCATION, OF WHICH THERE ARENT ANY YET.
	((A-PDL-BUFFER-HEAD) A-ZERO)
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) A-QLPDLO)
	((PDL-BUFFER-POINTER) A-PDL-BUFFER-HEAD)
	((A-PDL-BUFFER-HIGH-WARNING) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))  ;INITAL STACK
					;HAD BETTER AT LEAST BIG ENUF FOR P.B.
	((C-PDL-BUFFER-POINTER) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;THIS GOES
					;INTO 0@P
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-A C-PDL-BUFFER-POINTER-PUSH) A-INITIAL-FEF)
	((M-K) Q-DATA-TYPE M-A)
	(CALL-NOT-EQUAL M-K (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
	((M-AP) PDL-BUFFER-POINTER)
	((M-PDL-BUFFER-ACTIVE-QS) (A-CONSTANT 4))
	((VMA-START-READ) M-A)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((A-TEMPC) (LISP-BYTE %%FEFH-PC) READ-MEMORY-DATA)
BEG06	(CALL-NOT-EQUAL MICRO-STACK-PNTR-AND-DATA 	;CLEAR THE MICRO STACK PNTR (TO -1)
			(A-CONSTANT (PLUS 37_24. 1 (I-MEM-LOC BEG06))) BEG06)
	((MICRO-STACK-DATA-PUSH) A-MAIN-DISPATCH)	;PUSH MAGIC RETURN
	((MD) (A-CONSTANT 6000))		;Enable Unibus interrupts
	((VMA-START-WRITE) (A-CONSTANT 77773020))  ;Unibus address 766040
	(CHECK-PAGE-WRITE)
	(JUMP-XCT-NEXT QLENX)			;CALL INITIAL FUNCTION, NEVER RETURNS
       ((M-ERROR-SUBSTATUS) M-ZERO)

;;; MAIN INSTRUCTION EXECUTING LOOP

;NOTE: QMLP MUST BE AT LOC WITH BIT 1=0.  QMLP AND QMLP+1 ARE SKIPPED BY STREAM HARDWARE
; AUTOMATICALLY IF NO FETCH REQUIRED.
(MODULO 4) ;THIS CONSTRAINT IS A LITTLE MORE SEVERE THAN REALLY NECESSARY
QMLP	(CHECK-PAGE-READ)	;*** LATER WILL CHECK FOR SEQUENCE BREAK, JUMP OFF
	((M-INST-BUFFER) READ-MEMORY-DATA)
	(DISPATCH-XCT-NEXT M-INST-OP OPDTB)
   (ERROR-TABLE ILLEGAL-INSTRUCTION)
      ((MICRO-STACK-DATA-PUSH) A-MAIN-DISPATCH)	;PUT BACK RETURN FOR NEXT TIME

(MODULO 4)
DMLP	(CHECK-PAGE-READ)
        ((M-INST-BUFFER) READ-MEMORY-DATA)
        ((M-1) DPB M-ZERO Q-ALL-BUT-POINTER A-TRAP-AP-LEVEL)
        (JUMP-EQUAL M-1 A-ZERO DMLP-1)	;DONT CHACK M-AP LEVEL
        (CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) PDL-BUFFER-POINTER)
        (JUMP-LESS-OR-EQUAL M-K A-TRAP-AP-LEVEL STEP-BREAK-1)
DMLP-1	(DISPATCH-XCT-NEXT M-INST-OP OPDTB)
       ((MICRO-STACK-DATA-PUSH) A-DEBUG-DISPATCH)

SINGLE-STEP
	((M-1) (A-CONSTANT (EVAL SG-SINGLE-STEP-TRAP)))	;CHANGE STACK-GROUP-STATE
	((A-SG-STATE) DPB M-1 (LISP-BYTE %%SG-ST-INST-DISP) A-SG-STATE) ;TO SINGLE-STEP TRAP
        (DISPATCH-XCT-NEXT M-INST-OP OPDTB)
       ((MICRO-STACK-DATA-PUSH) A-SINGLE-STEP-TRAP)	;RETURN TO SINGLE-STEP TRAP

;;; WE HAVE TO WASTE THESE INSTRUCTIONS, BECAUSE WE WANT THE MACRO PC TO BE
;;; INCREMENTED, AND IT MIGHT SKIP THE FIRST 2 INSTRUCTIONS IF IT DOESN'T DO
;;; A MEMORY CYCLE (WHICH WE DONT ACTUALLY CARE ABOUT)
(MODULO 4)
STEP-BREAK
	(CHECK-PAGE-READ)
        ((M-INST-BUFFER) READ-MEMORY-DATA)
STEP-BREAK-1
        (CALL TRAP)
     (ERROR-TABLE STEP-BREAK)


INSTRUCTION-STREAM-FETCHER   ;DO FETCHES ASSOCIATED WITH MULTI-UNIT INSTUCTIONS.
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT NO-OP)
       ((M-INST-BUFFER) READ-MEMORY-DATA)

;;; THIS IS THE MISC ENTRY SMASHED IN FOR BREAKPOINTS IN FEF'S
BREAKPOINT (MISC-INST-ENTRY BPT)
	(CALL TRAP)
     (ERROR-TABLE BREAKPOINT)


;;; EFFECTIVE ADDRESS COMPUTATION ROUTINES.
;   THESE ARE ENTERED FROM QADCM1, THEY PUT THE OPERAND INTO M-T AND POPJ.

QAFE	((M-1) M-INST-ADR)			;FULL DELTA
	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA-START-READ) ADD C-PDL-BUFFER-INDEX A-1)
QADR4	(CHECK-PAGE-READ)			;NOTE THAT DATA-TYPE OF VMA DOESN'T MATTER
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;FOLLOW ALL INVZ
       ((M-T) READ-MEMORY-DATA)			;RETURN C(E) IN M-T

;GET EFFECTIVE ADDRESS, NOT PLANNING TO READ CONTENTS.  POPJ WITH EFF ADR ON PDL
;MUSTN'T TRANSPORT, NOR BARF AT TRAP, BUT MUST FOLLOW EXTERNAL VALUE CELL POINTER
QEAFE	((M-1) M-INST-ADR)			;FULL DELTA
	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA-START-READ) ADD C-PDL-BUFFER-INDEX A-1)
	(CHECK-PAGE-READ)  
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA) ;FOLLOW ALL INVZ
       ((C-PDL-BUFFER-POINTER-PUSH) DPB VMA	;PUSH VMA AS A LOCATIVE
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

;REF LOCAL BLOCK.  CANNOT BE INVISIBLE POINTER.
;IF THIS IS EVER CHANGED TO ALLOW INVISIBLE POINTERS, GOT TO FOOL AROUND
;WITH THE QADCM3 DISPATCH AND THE THINGS THAT USE IT, AND DECIDE WHICH
;FLAVORS OF INVISIBILITY DO WHAT WITH RESPECT TO VALUE-CELL-LOCATION.
QADLOC	((M-1) M-INST-DELTA)
	((M-1) ADD M-1 A-QLOCO)
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1)
       ((M-T) C-PDL-BUFFER-INDEX)

;REF ARGUMENT BLOCK.  CANNOT BE INVISIBLE POINTER.
QADARG	((M-1) M-INST-DELTA)
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1 ALU-CARRY-IN-ONE) ;%LP-INITIAL-LOCAL-BLOCK-OFFSET=1
       ((M-T) C-PDL-BUFFER-INDEX)

;REF CONSTANTS PAGE.
QAQT	((M-1) M-INST-DELTA)
	(JUMP-XCT-NEXT QADR4)
       ((VMA-START-READ) ADD M-1 A-V-CONSTANTS-AREA)

;REF PDL.  CANNOT BE INVISIBLE POINTER.
;WE ONLY SUPPORT (SP)+ TYPE PDL ADDRESSING (PDL 77) 
QADPDL	((M-1) M-INST-DELTA)
	(POPJ-AFTER-NEXT
	 (M-T) C-PDL-BUFFER-POINTER-POP)
       (CALL-NOT-EQUAL M-1 (A-CONSTANT 77) QADPDLT)	;UNSUPPORTED ADDRESS TYPE

QADPDLT (CALL TRAP)
   (ERROR-TABLE ILLEGAL-INSTRUCTION)		;NOTE THAT PDL HAS BEEN POPPED

;;; STORE CYCLE
;   VALUE IN M-T.  A READ-TYPE EFF ADDR COMPUTATION MAY OR MAY NOT
;   HAVE TAKEN PLACE ALREADY.
;   EXITS VIA POPJ BACK TO MAIN LOOP.

QIMVM	((M-T) C-PDL-BUFFER-POINTER)			;MOVEM INSTRUCTION
STOCYC	(DISPATCH-XCT-NEXT M-INST-REGISTER QADCM2)	;DISPATCH ON ADDRESS TYPE
       ((M-1) M-INST-DELTA)				;WITH DELTA IN M-1

;STOCYC ENDS UP HERE IF USING FEF ADDRESSING.
;STORE IN FEF, NO READ CYCLE TOOK PLACE, SO MUST COMPUTE VMA AND CHECK FOR INVZ
QSTFE	((M-1) M-INST-ADR)				;FULL DELTA
	((PDL-BUFFER-INDEX) M-AP)			;0(AP) -> FEF
	((VMA-START-READ) ADD C-PDL-BUFFER-INDEX A-1)
	(CHECK-PAGE-READ)  
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;FOLLOW ALL INVZ
		;FOLLOWING INSTRUCTION MUSTN'T POPJ-AFTER-NEXT BECAUSE
		;CANNOT START WRITE AND INSTRUCTION FETCH SIMULTANEOUSLY
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

;STORE IN LOCAL BLOCK
QSTLOC	((M-1) ADD M-1 A-QLOCO)
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1)
       ((C-PDL-BUFFER-INDEX) M-T)

;STORE IN ARGUMENT BLOCK
QSTARG	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-AP A-1 ALU-CARRY-IN-ONE)
       ((C-PDL-BUFFER-INDEX) M-T)

;PUSH LOCATIVE POINTER TO ADDRESS OF LOCAL VARIABLE ONTO THE PDL
QVMALCL	((M-1) ADD M-1 A-QLOCO)
	((M-1) SUB M-1 (A-CONSTANT 1)) ;COMPENSATE FOR +1 BELOW
;PUSH LOCATIVE POINTER TO ADDRESS OF ARGUMENT VARIABLE ONTO THE PDL
QVMAARG (CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) ADD M-AP A-1 ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (C-PDL-BUFFER-POINTER-PUSH) DPB M-K Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (NO-OP)

;;; VARIOUS TRAPS

;PUSHJ HERE FOR FATAL ERRORS, E.G. THINGS THAT CAN'T HAPPEN.
;ALSO FOR THINGS WHICH DON'T HAVE ERROR-TABLE ENTRIES YET.
  (MICRO-CODE-ILLEGAL-ENTRY-HERE)	;FILL IN UNUSED ENTRIES IN 
					; MICRO-CODE-SYMBOL-AREA
ILLOP	(POPJ HALT-CONS)		;Halt with place called from in lights

;PUSHJ HERE FOR ERRORS WHICH CAN TRAP TO MACROCODE.
;ON THE CONS MACHINE THIS USED THE OPCS, BUT WE HAVE REPUDIATED THAT PRACTICE.
;THEREFORE THIS CAN'T BE CALLED FROM THE INSTRUCTION AFTER A POPJ-AFTER-NEXT,
;AND SHOULDN'T BE CALLED FROM A CALL-XCT-NEXT UNLESS YOU MOVE THE ERROR-TABLE
;ENTRY DOWN.  IN ORDER NOT TO HAVE TO MAKE THE ERROR HANDLER MACHINE-DEPENDENT,
;THIS CODE DOES SOME ODD THINGS, AND LEAVES AN EXTRA ADDRESS ON THE PDL.
TRAP	(JUMP-IF-BIT-CLEAR M-TRAP-ENABLE ILLOP)	;TURN INTO ILLOP UNLESS TRAPS ENABLED
	((M-TEM) M-FLAGS-NO-SEQUENCE-BREAK)	;TURN INTO ILLOP IF TRAP AT BAD TIME
	(JUMP-NOT-EQUAL M-TEM A-ZERO ILLOP)	;NOTE WOULD PROBABLY DIE LATER ANYWAY
	((M-TEM) (BYTE-FIELD 14. 0) MICRO-STACK-PNTR-AND-DATA ;RETURN ADDRESS (DON'T POP!)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((A-TRAP-MICRO-PC) SUB M-TEM (A-CONSTANT 1))	;PRESUMED ADDRESS OF CALL
	((M-TEM) A-SG-STATE)			;RECURSIVE TRAP?
	(CALL-IF-BIT-SET (LISP-BYTE %%SG-ST-PROCESSING-ERROR) M-TEM ILLOP)	;IF SO, HALT
	((A-SG-STATE) DPB (M-CONSTANT -1) (LISP-BYTE %%SG-ST-PROCESSING-ERROR) A-TEM)
	((A-TEM3) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-QTRSTKG)
	((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-QCSTKG)
	(CALL-EQUAL M-TEM A-TEM3 ILLOP)		;RECURSIVE ERRORS
	(CALL-XCT-NEXT SGLV)			;STORE CURRENT STATUS
       ((M-TEM) (A-CONSTANT (EVAL SG-STATE-AWAITING-ERROR-RECOVERY))) ;AND SWAP SPECIAL-PDL
	((A-SG-TEM) A-V-NIL)	;Transmit NIL (do not change, EH knows about this.)
	(JUMP-XCT-NEXT SG-ENTER)			;"CALL" TRAP HANDLER STACK GROUP
       ((M-A) A-QTRSTKG)

;PUSHJ HERE ON ACTIVATE INVOKE.  OPERATION TYPE FROM I-ARG.
;INVOKE-ACTIVATE
;	(CALL-XCT-NEXT TRAP)	;NO HANDLER YET
;      ((C-PDL-BUFFER-POINTER-PUSH) DPB READ-I-ARG Q-POINTER	;SAVE OP-CODE
;		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
;      (ERROR-TABLE INVOKE)

;;; BASIC INSTRUCTIONS
;   OPERAND IS NOT FETCHED YET, SO FETCH IT INTO M-T, THEN
;   PRODUCE RESULT IN M-T, AND DISPATCH ON DESTINATION FIELD

QICDDR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCDR)

QICDR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

QICADR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCDR)))	;CALL QCDR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCAR)

QICAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

QICAAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCAR)

QICDAR	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)		;FETCH C(E)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QCAR)))	;CALL QCAR BEFORE RETURNING
	(JUMP-XCT-NEXT QIMOVE1)
       (CALL QCDR)

QIMOVE	(DISPATCH-CALL M-INST-REGISTER QADCM5)
QIMOVE1	(DISPATCH M-INST-DEST QMDTBD)		;MAY EXECUTE NEXT INSTUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;HERE TO TAKE DESTINATION FIELD FROM M-C INSTEAD OF INSTRUCTION
QIMOVE-EXIT
	(DISPATCH (BYTE-FIELD 3 0) M-C QMDTBD)	;MAY EXECUTE NEXT INSTRUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;ALL OF THESE WANT OPERAND FETCHED.
QIND1	(DISPATCH-XCT-NEXT M-INST-DEST D-ND1)
       (DISPATCH-CALL M-INST-REGISTER QADCM5)

;ALL OF THESE WANT OPERAND FETCHED.
QIND2	(DISPATCH-XCT-NEXT M-INST-DEST D-ND2)
       (DISPATCH-CALL M-INST-REGISTER QADCM5)

;THESE DON'T WANT THEIR OPERAND FETCHED.
QIND3	(DISPATCH M-INST-DEST D-ND3)

;CALL WITH NO ARGS
QICAL0	(DISPATCH-CALL M-INST-REGISTER QADCM5)		;FETCH C(E)
	(JUMP-XCT-NEXT QMRCL)				;ACTIVATE, BUT FIRST
       (CALL CBM)					;OPEN CALL BLOCK

;CALL WITH ARGS.  JUST OPEN A CALL BLOCK.
QICALL	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM1)	;FETCH C(E)
CBM    ((M-C) M-INST-DEST)		;EVENTUAL DESTINATION
CBM0					;%OPEN-CALL-BLOCK CALLS IN HERE
					;LEAVES M-ZR A COPY OF PDL-BUFFER-POINTER
	((M-ZR) ADD PDL-BUFFER-POINTER	;OPEN MACRO-TO-XXX CALL BLOCK
		 (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	((M-K) SUB M-ZR A-IPMARK)	;COMPUTE DELTA TO PREV OPEN BLOCK
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-K) SUB M-ZR A-AP)		;COMPUTE DELTA TO PREV ACTIVE BLOCK
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) A-TEM1)
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPCLS Q
	    DPB M-C (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) A-TEM1)
;QBNEAF QBALM WOULD GO HERE IF EVER REVIVED
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPEXS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPENS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT 
	  (C-PDL-BUFFER-POINTER-PUSH) M-T)		;PUSH LPFEF Q
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;A-IPMARK -> NEW OPEN BLOCK

;;; MISC INSTRUCTION
MISC	((M-B) M-INST-ADR)	;GET LOW 9 BITS OF INST
	(JUMP-LESS-THAN	M-B (A-CONSTANT 200) QMSCO1)	;LIST GROUPS
	((VMA-START-READ) ADD A-V-MISC-BASE M-B)
	(CHECK-PAGE-READ)
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(CALL 0)		;CALL EXECUTION ROUTINE
	(DISPATCH M-INST-DEST QMDTBD)	;M-INST-BUFFER STILL SET UP, STORE IN DEST
					;MAY EXECUTE NEXT INSTRUCTION
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;LIST GROUP, ALLOCATE NUMBER OF Q'S GIVEN BY BITS 1.5-1.1 OF INSTRUCTION.
;     LISTIFY THEM, AND PUSH ON PDL THREE QS.
;	(1) POINTER TO BLOCK 
;	(2) DESTINATION FIELD OF MISC-INSTRUCTION
;	(3) ANOTHER COPY POINTER TO BLOCK.
;    THIS INTERFACES APPROPRIATELY WITH THE STORE-NEXT-LIST DESTINATION,
;	WITH THE NET EFFECT OF CREATING A N-ELEMENT LIST AND FINALLY STORING
;	A POINTER TO IT IN THE SPECIFIED DESTINATION.
;  Q'S COME FROM AREA IN A-CNSADF OR SPECIFIED AREA DEPENDING ON WHETHER 1.6 IS
;    0 OR 1 RESPECTIVELY.

QMSCO1	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 6) M-B QMSCO2)  ;JUMP ON USE DEFAULT 
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)	;AREA (IE M-B 0 - 77 )
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;LIST IN SPECD AREA
QMSCO2	(CALL-XCT-NEXT LIST-OF-NILS)		;ALLOCATE Q'S IN B IN AREA IN S, LIST SPACE
       ((M-B) (BYTE-FIELD 6 0) M-B)		;FLUSH 100 BIT
	((C-PDL-BUFFER-POINTER-PUSH M-T)	;POINTER TO ALLOCATED BLOCK
		Q-POINTER M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	((M-C) M-INST-DEST)
	(POPJ-AFTER-NEXT 
	 (C-PDL-BUFFER-POINTER-PUSH)
	    DPB M-C Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)

;THESE VARIOUS CONSING ROUTINES HAD BETTER NOT CLOBBER M-C.  OTHER REGS PROBABLY OK.

XXCONS (MISC-INST-ENTRY XCONS)			;XCONS
	(JUMP-XCT-NEXT XXCON1)
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)	;USE DEFAULT AREA

XXCONA (MISC-INST-ENTRY XCONS-IN-AREA)		;XCONS, WITH AREA AS THIRD ARG
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XXCON1	((M-B) C-PDL-BUFFER-POINTER-POP)	;EXCH ARGS
	((M-A) C-PDL-BUFFER-POINTER-POP)
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	(JUMP-XCT-NEXT QCONS)
       ((C-PDL-BUFFER-POINTER-PUSH) M-A)

XNCONS (MISC-INST-ENTRY NCONS)			;NCONS
	(JUMP-XCT-NEXT XNCON1)
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)

XNCONA (MISC-INST-ENTRY NCONS-IN-AREA)		;NCONS, WITH AREA AS SECOND ARG
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XNCON1	(JUMP-XCT-NEXT QCONS)
       ((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)

XCONS (MISC-INST-ENTRY CONS)			;CONS
	((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)	;USE DEFAULT AREA
QCONS	(CALL-XCT-NEXT LCONS)			;ALLOCATE 2 Q'S, RETURN POINTER IN M-T,
       ((M-B) (A-CONSTANT 2))			;ALLOCATE FROM LIST SPACE
	((WRITE-MEMORY-DATA) DPB Q-TYPED-POINTER
		C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-ERROR)))
	((VMA-START-WRITE) ADD M-T (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(GC-WRITE-TEST)
	((WRITE-MEMORY-DATA) DPB Q-TYPED-POINTER 
		C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NORMAL)))
	((VMA-START-WRITE M-T) DPB M-T Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

XCONSA (MISC-INST-ENTRY CONS-IN-AREA)		;CONS, WITH AREA AS THIRD ARG
	(JUMP-XCT-NEXT QCONS)
       ((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)


;;; STORAGE ALLOCATION STUFF

; CALL WITH AREA IN M-S, NUMBER OF QS DESIRED IN M-B
; NIL AND T AS AREAS WILL MEAN A-WORKING-AREA AND TEMPORARY STORAGE, RESPECTIVELY
; OTHERWISE, M-S MUST BE AN AREA NUMBER.  (AREA SYMBOLS USED TO BE ALLOWED, CROCK.)
; CALL LCONS TO ALLOCATE IN LIST SPACE, OR SCONS TO ALLOCATE IN STRUCTURE SPACE
; RETURNS RESULT IN M-T, WITH GARBAGE IN THE DATA-TYPE, YOU BETTER FIX THIS QUICK!
; THE ALLOCATED MEMORY WILL NOT BE INITIALIZED (IT WILL NORMALLY BE FILLED WITH DTP-FREE'S)
; YOU BETTER STORE HEADERS OR WHATEVER QUICK!
; SEE LIST-OF-NILS, WHICH IS LIKE LCONS BUT INITIALIZES THE STORAGE TO NIL, WITH CDR-CODES
;
; VARIOUS CALLERS REQUIRE THAT THE FOLLOWING REGISTERS BE PRESERVED:
;	M-A, M-B, M-C, M-D, M-I, M-J, M-Q, M-R, M-1, M-2
; THIS CAN POTENTIALLY CAUSE A STACK-GROUP SWITCH, ALSO MAY CLOBBER M-K, M-E
; WILL NOT STACK-GROUP SWITCH IF CALLED FROM THE TRANSPORTER, UNLESS TRAPPING
; FOR ILLEGAL ARGUMENT IN M-S OR M-B, WHICH WON'T HAPPEN, OR
; FOR OUT-OF-VIRTUAL-MEMORY WHICH SHOULDN'T HAPPEN AND MAY NOT WORK.

;DECODE AREA SPEC IN M-S.  RETURN FIXNUM, WITH DATA-TYPE, IN M-S.
;ALSO CHECKS M-B.  (UNTYPED NUMBER OF FIXNUMS TO ALLOCATE.)
;SKIP-RETURNS UNLESS M-S IS T, SO FOLLOW CALL WITH A JUMP TO TEMPORARY-STORAGE CONS.
CONS-GET-AREA
	(CALL-LESS-OR-EQUAL M-B A-ZERO TRAP)
		(ERROR-TABLE CONS-ZERO-SIZE M-B)
	(POPJ-EQUAL M-S A-V-TRUE)	;T => cons in temporary area, return
	(JUMP-NOT-EQUAL M-S A-V-NIL CONS-GET-AREA-1)
	((M-S) A-WORKING-AREA)		;NIL => use working area
CONS-GET-AREA-1
	(DISPATCH Q-DATA-TYPE M-S TRAP-UNLESS-FIX)
		(ERROR-TABLE ARGTYP AREA M-S)
	((M-TEM) Q-POINTER M-S)		;Check range
	(CALL-GREATER-THAN M-TEM (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)) TRAP)
		(ERROR-TABLE ARGTYP AREA M-S)
SKIP-RETURN
	((M-TEM) ADD MICRO-STACK-POINTER-AND-DATA-POP (A-CONSTANT 1))
	((OA-REG-LOW) DPB M-TEM OAL-JUMP A-ZERO)
	(JUMP)

;This entry used by number functions to cons a structure in default place
SCONS-T	((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)
;This is the normal entry, area in M-S
SCONS	(CALL CONS-GET-AREA)		;SETS UP M-S
	 (JUMP TSCONS)			;JUMP IF TEMPORARY STORAGE
	((VMA-START-READ) ADD M-S A-V-AREA-REGION-LIST)	;FIND APPROPRIATE REGION OF THE AREA
SCONS0	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT READ-MEMORY-DATA SCONS5)	;NO REGION FOUND
	((M-K) Q-POINTER READ-MEMORY-DATA)	;GET REGION NUMBER
SCONS2	((VMA-START-READ) ADD M-K A-V-REGION-BITS)	;GET ATTRIBUTES OF THAT REGION
	(CHECK-PAGE-READ)
	(DISPATCH (I-ARG 0) (LISP-BYTE %%REGION-SPACE-TYPE) READ-MEMORY-DATA D-SCONS-1)
	(DISPATCH (LISP-BYTE %%REGION-REPRESENTATION-TYPE) READ-MEMORY-DATA D-SCONS-2)
	;THIS REGION IS THE RIGHT TYPE, SEE IF ADEQUATE FREE SPACE
	((VMA-START-READ) ADD M-K A-V-REGION-LENGTH)
	(CHECK-PAGE-READ)
	((M-3) Q-POINTER READ-MEMORY-DATA)	;LENGTH OF REGION
	((VMA-START-READ) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-T) Q-POINTER READ-MEMORY-DATA)	;CURRENT FREE POINTER
	((M-E) ADD M-T A-B)			;PROPOSED NEW FREE POINTER
	(JUMP-GREATER-THAN M-E A-3 SCONS1)	;JUMP IF DOESN'T FIT, TRY NEXT REGION
LCONS4	((M-3) SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-POINTER A-E) ;NEW FREE POINTER
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)	;RELOCATE M-T
	(CHECK-PAGE-READ)
	((A-CONS-TEM) M-FLAGS)
	((M-T VMA-START-READ)
		ADD READ-MEMORY-DATA A-T)	;ADDRESS OF ALLOCATED STUFF, GARBAGE DATATYPE
	((M-E) Q-POINTER-WITHIN-PAGE M-T)	;THEN TOUCH EACH PAGE OF ALLOCATED STUFF
	(JUMP-NOT-EQUAL-XCT-NEXT M-E A-ZERO CONSF2) ;JUMP IF FIRST PAGE NOT A FRESH PAGE
       ((M-E) ADD M-E A-B)			;M-E GIVES PAGE COUNT IN HAIRY WAY
CONSF1	((M-DONT-SWAP-IN) DPB (M-CONSTANT -1) A-FLAGS)	;CREATE PAGES WITHOUT DISK READ
CONSF2	(CHECK-PAGE-READ)			;NOW TAKE FAULT FOR PREVIOUS VMA-START-READ
	((M-E) SUB M-E (A-CONSTANT (EVAL PAGE-SIZE)))
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-E A-ZERO SCAV0)
       ((M-FLAGS) SETA A-CONS-TEM READ-MEMORY-DATA);RESTORE FLAGS, MAKE SURE MEM CYCLE COMPLETE
	(JUMP-XCT-NEXT CONSF1)
       ((VMA-START-READ) ADD VMA (A-CONSTANT (EVAL PAGE-SIZE)))

;A COPY OF THE ABOVE CODE EXCEPT FOR LIST REPRESENTATION-TYPE
;SLIGHTLY DIFFERENT DISPATCH, AND CONSES DOWN INSTEAD OF UP IF %%REGION-COMPACT-CONS-FLAG
LCONS	(CALL CONS-GET-AREA)		;SETS UP M-S
	 (JUMP TLCONS)			;JUMP IF TEMPORARY STORAGE
	((VMA-START-READ) ADD M-S A-V-AREA-REGION-LIST)	;FIND APPROPRIATE REGION OF THE AREA
LCONS0	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT READ-MEMORY-DATA LCONS5)	;NO REGION FOUND
	((M-K) Q-POINTER READ-MEMORY-DATA)	;GET REGION NUMBER
LCONS2	((VMA-START-READ) ADD M-K A-V-REGION-BITS)	;GET ATTRIBUTES OF THAT REGION
	(CHECK-PAGE-READ)
	(DISPATCH (I-ARG 1) (LISP-BYTE %%REGION-SPACE-TYPE) READ-MEMORY-DATA D-LCONS-1)
	(DISPATCH (LISP-BYTE %%REGION-REPRESENTATION-TYPE) READ-MEMORY-DATA D-LCONS-2)
	;THIS REGION IS THE RIGHT TYPE, SEE IF ADEQUATE FREE SPACE
	(JUMP-IF-BIT-SET (LISP-BYTE %%REGION-COMPACT-CONS-FLAG) READ-MEMORY-DATA LCONS3)
	((VMA-START-READ) ADD M-K A-V-REGION-LENGTH)	;CONS UPWARD
	(CHECK-PAGE-READ)
	((M-3) Q-POINTER READ-MEMORY-DATA)	;LENGTH OF REGION
	((VMA-START-READ) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-T) Q-POINTER READ-MEMORY-DATA)	;CURRENT FREE POINTER
	((M-E) ADD M-T A-B)			;PROPOSED NEW FREE POINTER
	(JUMP-GREATER-THAN M-E A-3 LCONS1)	;JUMP IF DOESN'T FIT, TRY NEXT REGION
	(JUMP LCONS4)				;ELSE GO JOIN SCONS'S FINALIZATION

LCONS3	((VMA-START-READ) ADD M-K A-V-REGION-FREE-POINTER)	;CONS DOWNWARD
	(CHECK-PAGE-READ)
	((M-T) SUB READ-MEMORY-DATA A-B)	;PROPOSED NEW FREE POINTER, ALSO RESULT
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT M-T LCONS1)	;JUMP IF DOESN'T FIT, TRY NEXT REGION
	((M-E) Q-POINTER-WITHIN-PAGE READ-MEMORY-DATA)	;NUMBER OF QS ON NON-FRESH PAGE
	((M-3) SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-POINTER A-T) ;NEW FREE POINTER
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)	;RELOCATE M-T
	(CHECK-PAGE-READ)
	((A-CONS-TEM) M-FLAGS)
	((M-T VMA-START-READ)
		ADD READ-MEMORY-DATA A-T)	;ADDRESS OF ALLOCATED STUFF, GARBAGE DATATYPE
	(JUMP-GREATER-THAN-XCT-NEXT M-B A-E CONSF1)
       ((M-E) SUB M-B A-E)			;NUMBER OF QS ON FRESH PAGES
	(JUMP READ-MEMORY-DATA SCAV0)		;FINISH MEMORY CYCLE, EXIT (NO FRESH PAGES)

SCONS1	(JUMP-XCT-NEXT SCONS0)			;TRY NEXT REGION
       ((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)

LCONS1	(JUMP-XCT-NEXT LCONS0)			;TRY NEXT REGION
       ((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)

;Trying to cons in newspace
CONS-CHECK-NEW
	(POPJ-IF-BIT-CLEAR M-TRANSPORT-FLAG)
	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 0) READ-I-ARG LCONS1)
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;Get rid of return address
	(JUMP SCONS1)	

;Trying to cons in copyspace
CONS-CHECK-COPY
	(POPJ-IF-BIT-SET M-TRANSPORT-FLAG)
	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 0) READ-I-ARG LCONS1)
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;Get rid of return address
	(JUMP SCONS1)	

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-SCONS-1	;DISPATCH ON SPACE TYPE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;0 FREE (ILLEGAL TO CONS IN)
	(INHIBIT-XCT-NEXT-BIT SCONS1)		;1 OLD (TRY NEXT REGION)
	(P-BIT INHIBIT-XCT-NEXT-BIT CONS-CHECK-NEW) ;2 NEW (ONLY IF NOT IN TRANSPORTER)
	(P-BIT R-BIT)				;3 STATIC
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;4 FIXED (ILLEGAL TO CONS IN)
	(P-BIT R-BIT)				;5 EXITED
	(INHIBIT-XCT-NEXT-BIT SCONS1)		;6 EXIT (TRY NEXT REGION)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 TEMPORARY SPACE (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;10 WIRED (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;11 USER-PAGED (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT CONS-CHECK-COPY) ;12 COPY (ONLY IF IN TRANSPORTER)
(REPEAT 5 (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))	;UNUSED CODE (ILLEGAL TO CONS IN)
(END-DISPATCH)

(START-DISPATCH 2 0)
D-SCONS-2	;DISPATCH ON REPRESENTATION TYPE
	(INHIBIT-XCT-NEXT-BIT SCONS1)		;0 LIST (TRY NEXT REGION)
	(P-BIT R-BIT)				;1 STRUCTURE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;2 ILLEGAL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;3 ILLEGAL
(END-DISPATCH)

(START-DISPATCH 4 0)
D-LCONS-1	;DISPATCH ON SPACE TYPE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;0 FREE (ILLEGAL TO CONS IN)
	(INHIBIT-XCT-NEXT-BIT LCONS1)		;1 OLD (TRY NEXT REGION)
	(P-BIT INHIBIT-XCT-NEXT-BIT CONS-CHECK-NEW) ;2 NEW (ONLY IF NOT IN TRANSPORTER)
	(P-BIT R-BIT)				;3 STATIC
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;4 FIXED (ILLEGAL TO CONS IN)
	(P-BIT R-BIT)				;5 EXITED
	(INHIBIT-XCT-NEXT-BIT LCONS1)		;6 EXIT (TRY NEXT REGION)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 TEMPORARY SPACE (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;10 WIRED (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;11 USER-PAGED (ILLEGAL TO CONS IN)
	(P-BIT INHIBIT-XCT-NEXT-BIT CONS-CHECK-COPY) ;12 COPY (ONLY IF IN TRANSPORTER)
(REPEAT 5 (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))	;UNUSED CODE (ILLEGAL TO CONS IN)
(END-DISPATCH)

(START-DISPATCH 2 0)
D-LCONS-2	;DISPATCH ON REPRESENTATION TYPE
	(P-BIT R-BIT)				;0 LIST
	(INHIBIT-XCT-NEXT-BIT LCONS1)		;1 STRUCTURE (TRY NEXT REGION)
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;2 ILLEGAL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;3 ILLEGAL
(END-DISPATCH)
(LOCALITY I-MEM)

;;; Scavenger

;Here after consing something, to do scavenging and so forth.  M-E, M-K smashable.
;M-B has the number of Q'S consed, M-K has the region number.
;M-3 has the new free pointer, the free-pointer has not been updated yet, to 
;avoid attempting to scavenge the newly-allocated object, which is not yet initialized.
SCAV0	(JUMP-IF-BIT-SET M-TRANSPORT-FLAG SCAVT) ;If in transporter, don't invoke scavenger
	((M-E) DPB M-B (BYTE-FIELD 24. 2) A-ZERO) ;4 times number of Q's consed (K=4)
	((A-CONS-WORK-DONE Q-R) ADD M-E A-CONS-WORK-DONE)
	(JUMP-LESS-THAN-XCT-NEXT Q-R A-SCAV-WORK-DONE SCAV0X)	;Return if not yet
       ((A-CONS-NEW-FREE-POINTER) M-3)				; time to scavenge
	((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-INHIBIT-SCAVENGING-FLAG)
	(CALL-EQUAL-XCT-NEXT M-TEM A-V-NIL SCAV2)	;Check if scavenger inhibited by user
SCAV0X ((A-CONS-NEW-FP-REGION) M-K)
	((M-K) A-CONS-NEW-FP-REGION)		;Now update free pointer
	((WRITE-MEMORY-DATA) A-CONS-NEW-FREE-POINTER)
	(POPJ-AFTER-NEXT (VMA-START-WRITE) ADD M-K A-V-REGION-FREE-POINTER)	
       (CHECK-PAGE-WRITE)

;Scavenge M-E Q's worth of stuff.  Clobber only M-E,M-K,M-3,M-4, tems
SCAV2	((MD) (A-CONSTANT -2))			;Turn on scavenger run-light
	((VMA-START-WRITE) ADD MD A-DISK-RUN-LIGHT)
	(CHECK-PAGE-WRITE)
	(JUMP-EQUAL-XCT-NEXT A-SCAV-COUNT M-ZERO SCAV3)	;Jump if no remembered scavenger state
       ((M-SCAVENGE-FLAG) DPB (M-CONSTANT -1) A-FLAGS)
;;;Continue previous scavenge.  Kludgiferous hair required for pdls since they
;;;change in size in real time, and we really have to obey the pad since various
;;;microcode routines like to push garbage off the end of the pdl.
SCAVL0	(JUMP-EQUAL M-ZERO A-SCAV-PDL-BASE SCAVL1)
	(CALL-XCT-NEXT SCAV-STRUCTURE-INFO)	;Recompute size of pdl
       ((MD) A-SCAV-PDL-BASE)
	((M-TEM) DPB M-ZERO Q-ALL-BUT-POINTER A-SCAV-PTR)
	((M-TEM) SUB M-TEM A-SCAV-PDL-BASE)	;Number of Q's already done
	((M-TEM) SUB M-ZERO A-TEM)
	((A-SCAV-COUNT) ADD M-TEM A-SCAV-COUNT)	;Subtract that from total #Q's
	(JUMP-LESS-THAN M-ZERO A-SCAV-COUNT SCAVL1)
	((M-TEM) A-SCAV-COUNT)		 ;Shrunk beyond where we were
	(JUMP-XCT-NEXT SCAVL4)		 ;Move back A-SCAV-PTR so next structure will
       ((A-SCAV-PTR) ADD M-TEM A-SCAV-PTR)  ;be found. This can result in bit of double
					    ;counting on A-SCAV-WORK-DONE, but thats too
					    ;bad.
SCAVL1	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-E A-SCAV-COUNT SCAVL2)
       ((M-K) A-SCAV-COUNT)			;Get number of Q's to do this time
	((M-K) M-E)
SCAVL2	((A-SCAV-WORK-DONE) ADD M-K A-SCAV-WORK-DONE)
	((M-E) SUB M-E A-K)
SCAVL3	((VMA-START-READ) A-SCAV-PTR)		;Scavenge some Q's
	(CHECK-PAGE-READ)
	((A-SCAV-PTR) M+A+1 M-ZERO A-SCAV-PTR)
	((A-SCAV-COUNT) ADD (M-CONSTANT -1) A-SCAV-COUNT)
	(DISPATCH TRANSPORT-SCAV READ-MEMORY-DATA)
	(JUMP-GREATER-THAN-XCT-NEXT M-K (A-CONSTANT 1) SCAVL3)
       ((M-K) SUB M-K (A-CONSTANT 1))
	(JUMP-NOT-EQUAL A-SCAV-COUNT M-ZERO SCAVX) ;M-E too small to finish this object
	;;Finished this object, update region's GC-POINTER
SCAVL4	((M-TEM) A-SCAV-SKIP)
	((A-SCAV-WORK-DONE) ADD M-TEM A-SCAV-WORK-DONE) ;Unboxed Q's come for free
	((M-3) ADD M-TEM A-SCAV-PTR)
	((M-3) SUB M-3 A-SCAV-REGION-ORIGIN) ;relative
	((WRITE-MEMORY-DATA) Q-POINTER M-3
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
				  (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))
	((M-K) A-SCAV-REGION)
	((VMA-START-WRITE) ADD M-K A-V-REGION-GC-POINTER)
	(CHECK-PAGE-WRITE)
	;;Try to find next object to scavenge in this region
	((VMA-START-READ) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-4) Q-POINTER READ-MEMORY-DATA)	;Save free pointer
	(JUMP-EQUAL M-3 A-4 SCAV3)		;This region now clean, try some others
;Here M-K has region, M-3 has gc pointer, M-4 has free pointer, as pure numbers
SCAV6	((VMA-START-READ) ADD M-K A-V-REGION-BITS)
	(CHECK-PAGE-READ)
	((A-SCAV-PTR) ADD M-3 A-SCAV-REGION-ORIGIN)
	(DISPATCH (LISP-BYTE %%REGION-REPRESENTATION-TYPE) READ-MEMORY-DATA D-SCAV6)
	(CALL-XCT-NEXT SCAV-STRUCTURE-INFO)	;Structure region
       ((MD) A-SCAV-PTR)			;Set A-SCAV-COUNT, A-SCAV-SKIP
	((A-SCAV-PDL-BASE) A-SINF-PDL-BASE)	;0 or base address of this pdl
SCAV8	(JUMP-EQUAL A-SCAV-COUNT M-ZERO SCAVL4)	;Object or region can have no boxed Q's!
	(JUMP-NOT-EQUAL-XCT-NEXT M-E A-ZERO SCAVL0)	;Go scavenge this object
       ((A-SCAV-PTR) DPB M-ZERO Q-ALL-BUT-POINTER A-SCAV-PTR) ;This must have a zero tag
	(JUMP SCAVX)				;Done for now

SCAV7	((A-SCAV-SKIP) A-ZERO)			;List region, don't worry about
	((A-SCAV-PDL-BASE) A-ZERO)		; object boundaries
	(JUMP-GREATER-THAN-XCT-NEXT M-4 A-3 SCAV9)
       ((Q-R A-SCAV-COUNT) SUB M-4 A-3)
	((A-SCAV-PTR) ADD M-4 A-SCAV-REGION-ORIGIN)
	((Q-R A-SCAV-COUNT) SUB M-3 A-4)	;Downward-consing
SCAV9	(JUMP-LESS-OR-EQUAL Q-R (A-CONSTANT 400) SCAV8)
	(JUMP-XCT-NEXT SCAV8)
       ((A-SCAV-COUNT) (A-CONSTANT 400))	;Do at most this many before updating GC-pntr

(LOCALITY D-MEM)
(START-DISPATCH 2 0) ;Dispatch on representation-type
D-SCAV6	(INHIBIT-XCT-NEXT-BIT SCAV7)		;0 list
	(P-BIT R-BIT)				;1 structure
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;2 unused
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;3 unused
(END-DISPATCH)
(LOCALITY I-MEM)

SCAV3	((M-K) A-ZERO)				;Check every region
SCAV4	((VMA-START-READ) ADD M-K A-V-REGION-BITS)
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%REGION-SCAVENGE-ENABLE) READ-MEMORY-DATA SCAV5)
	((VMA-START-READ) ADD M-K A-V-REGION-GC-POINTER)
	(CHECK-PAGE-READ)
	((M-3) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-4) Q-POINTER READ-MEMORY-DATA)	;Save free pointer
	(JUMP-EQUAL M-4 A-3 SCAV5)		;This region is clean
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	((A-SCAV-REGION) M-K)			;Do this one
	(JUMP-XCT-NEXT SCAV6)
       ((A-SCAV-REGION-ORIGIN) Q-POINTER READ-MEMORY-DATA)

SCAV5	(JUMP-LESS-THAN-XCT-NEXT M-K (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)) SCAV4)
       ((M-K) ADD M-K (A-CONSTANT 1))
	;;No scavenging needed anywhere, shut off the scavenger and enable flipping
	((A-GC-FLIP-READY) A-V-TRUE)
	((A-SCAV-WORK-DONE) (BYTE-FIELD 31. 0) (M-CONSTANT -1))  ;Maximum possible
SCAVX	((M-SCAVENGE-FLAG) DPB (M-CONSTANT 0) A-FLAGS)
	((MD) SETZ)
	((M-TEM) (A-CONSTANT -2))		;Turn off run light
	(POPJ-AFTER-NEXT (VMA-START-WRITE) ADD M-TEM A-DISK-RUN-LIGHT)
       (CHECK-PAGE-WRITE)			;This also makes sure VMA not pointing at gbg

;CONSing inside transporter.  If also inside scavenger, count as scavenger
;work done.  In either case, don't count as cons work done since this is not
;fresh consing but just copying, and don't invoke the scavenger.
SCAVT	((WRITE-MEMORY-DATA) M-3)	;Write back the free pointer
	((VMA-START-WRITE) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT POPJ-IF-BIT-CLEAR M-SCAVENGE-FLAG)
       ((A-SCAV-WORK-DONE) ADD M-B A-SCAV-WORK-DONE)

;Scavenge the specified amount or until a page fault.
XSCAV (MISC-INST-ENTRY %GC-SCAVENGE)
	((M-R) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;Amount of scav work to do
XSCAV1	((M-T) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-GC-FLIP-READY)
	(POPJ-NOT-EQUAL M-T A-V-NIL)			;Return if scavenger all done
	((M-S) A-DISK-PAGE-READ-COUNT)
	(CALL-XCT-NEXT SCAV2)				;Just do 1 single scavenge step
       ((M-E) (A-CONSTANT 1))
	(POPJ-NOT-EQUAL M-S A-DISK-PAGE-READ-COUNT)	;Return if took page fault
	(JUMP-GREATER-THAN-XCT-NEXT M-R (A-CONSTANT 1) XSCAV1)
       ((M-R) SUB M-R (A-CONSTANT 1))
	(JUMP XFALSE)					;Return if did specified # steps

;Make the scavenger forget about a particular region
SCVRST (MISC-INST-ENTRY %GC-SCAV-RESET)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;arg 1 - region number
	(JUMP-NOT-EQUAL M-K A-SCAV-REGION XFALSE)	;nothing if scavenger not looking here
	(JUMP-XCT-NEXT XTRUE)
       ((A-SCAV-COUNT) M-ZERO)			;Else make scavenger forget its state

;Adjust A-CONS-WORK-DONE
XGCCW (MISC-INST-ENTRY %GC-CONS-WORK)
	(CALL FXUNPK-P-1)				;M-1 gets adjustment
	((M-1) DPB M-1 (BYTE-FIELD 30. 2) A-ZERO)	;Multiply by 4
	(JUMP-XCT-NEXT XFALSE)
       ((A-CONS-WORK-DONE) ADD M-1 A-CONS-WORK-DONE)

;CONSING IN TEMPORARY SPACE

TSCONS	(JUMP-XCT-NEXT TCONS0)
       ((M-E) (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-STRUCTURE)))

TLCONS	((M-E) (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-LIST)))
TCONS0	((M-TEM) DPB M-ZERO Q-ALL-BUT-POINTER A-MAXIMUM-TEMPORARY-OBJECT-SIZE)
	(JUMP-GREATER-THAN M-B A-TEM TCONSX)	;Too big, cons in regular area
	((OA-REG-HIGH) DPB M-E OAH-A-SRC)	;See if there is room in current chunk
	((M-K) A-TEMP-SPACE-OBJ-SPACE-LEFT)
	(JUMP-GREATER-OR-EQUAL M-B A-K TCONS1)	;Jump if there is not room for hdr+obj
	((OA-REG-LOW) DPB M-E OAL-A-DEST)	;Yes, put it there
	((A-TEMP-SPACE-OBJ-SPACE-LEFT) M-A-1 M-K A-B)
	((OA-REG-HIGH) DPB M-E OAH-A-SRC)	;Get consing pointer
	((M-T) M+A+1 M-ZERO A-TEMP-SPACE-OBJ-FREE-PTR)
	((WRITE-MEMORY-DATA) Q-POINTER M-B)	;Store header (just the length)
	((VMA-START-WRITE) SUB M-T (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	((A-COUNT-TEMPORARY-CONS-WORDS) ADD M-B A-COUNT-TEMPORARY-CONS-WORDS)
	((OA-REG-HIGH) DPB M-E OAH-A-SRC)	;Update free pointer in chunk header
	((VMA-START-READ) A-TEMP-SPACE-CURRENT-CHUNK)
	(CHECK-PAGE-READ)
	((OA-REG-LOW) DPB M-E OAL-A-DEST)	;Advance consing pointer in A-mem
	((A-TEMP-SPACE-OBJ-FREE-PTR Q-R) ADD M-T A-B)
	((M-TEM) SUB Q-R VMA)			;Relative free pointer
	((A-TEM1) READ-MEMORY-DATA)		;Get onto A-side
	(POPJ-AFTER-NEXT (WRITE-MEMORY-DATA-START-WRITE)
		DPB M-TEM TEMP-CHUNK-HDR1-OBJECT-FREE-PTR A-TEM1)
       (CHECK-PAGE-WRITE)

;Use regular space instead of temporary space
TCONSX	(DISPATCH-XCT-NEXT (BYTE-FIELD 2 0) M-E D-TCONSX)
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-WORKING-AREA)

(LOCALITY D-MEM)
(START-DISPATCH 2 0)
D-TCONSX
	(LCONS)					;List
	(SCONS)					;Structure
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;2 Illegal
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;3 Illegal
(END-DISPATCH)
(LOCALITY I-MEM)

;No room in this chunk, start a new one
TCONS1	((C-PDL-BUFFER-POINTER-PUSH) M-A)	;Get some registers
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-S)
	;; Make M-A be where to start looking
	((OA-REG-HIGH) DPB M-E OAH-A-SRC)	;Fetch header of this chunk
	((VMA-START-READ M-A) A-TEMP-SPACE-CURRENT-CHUNK)
	(CHECK-PAGE-READ)
	((M-TEM) TEMP-CHUNK-HDR1-OBJECT-FREE-PTR READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-ZERO TCONS2)	;Jump if not a real chunk
	((M-TEM) TEMP-CHUNK-HDR1-CHUNK-SIZE READ-MEMORY-DATA)
	((M-A) ADD M-A A-TEM)			;Advance to next
TCONS2	;; Make M-B be how much storage we need for the whole chunk
	(JUMP-GREATER-THAN M-B (A-CONSTANT TEMP-CHUNK-OBJ-SIZE) TCONS3)
	((M-B) (A-CONSTANT TEMP-CHUNK-OBJ-SIZE))
TCONS3	((M-B) ADD M-B (A-CONSTANT (PLUS TEMP-CHUNK-N-BACK-PTRS TEMP-CHUNK-HDR-SIZE)))
	(CALL TREUSE)				;Make that at least that much storage available
	;; M-A has address of storage, M-B amount wanted, M-3 amount got
	(JUMP-EQUAL M-3 A-B TCONS4)		;Jump if no extra
	((WRITE-MEMORY-DATA) SUB M-3 A-B)	;Must store header for the extra
	((VMA-START-WRITE) ADD M-A A-B)
	(CHECK-PAGE-WRITE)
TCONS4	;; Build an empty chunk
	((WRITE-MEMORY-DATA) TEMP-CHUNK-HDR1-CHUNK-SIZE M-B
		(A-CONSTANT (BYTE-VALUE TEMP-CHUNK-HDR1-OBJECT-FREE-PTR TEMP-CHUNK-HDR-SIZE)))
	((VMA-START-WRITE) M-A)
	(CHECK-PAGE-WRITE)
	((M-K) SUB M-B (A-CONSTANT TEMP-CHUNK-N-BACK-PTRS))
	((WRITE-MEMORY-DATA) DPB M-K TEMP-CHUNK-HDR2-FIRST-BACK-PTR A-K)
	((VMA-START-WRITE) ADD M-A (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	((OA-REG-LOW) DPB M-E OAL-A-DEST)	;Remember this in A-memory
	((A-TEMP-SPACE-CURRENT-CHUNK) M-A)
	((OA-REG-LOW) DPB M-E OAL-A-DEST)
	((A-TEMP-SPACE-OBJ-FREE-PTR) ADD M-A (A-CONSTANT TEMP-CHUNK-HDR-SIZE))
	((OA-REG-LOW) DPB M-E OAL-A-DEST)
	((A-TEMP-SPACE-OBJ-SPACE-LEFT) SUB M-K (A-CONSTANT TEMP-CHUNK-HDR-SIZE))
	((M-S) C-PDL-BUFFER-POINTER-POP)
	((M-B) C-PDL-BUFFER-POINTER-POP)
	((M-A) C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT TCONS0)
       ((A-COUNT-TEMPORARY-CONS-CHUNKS) M+A+1 M-ZERO A-COUNT-TEMPORARY-CONS-CHUNKS)

;Recycle chunks starting at M-A until M-B words have been acquired.
;M-E has the representation-type.
;Return number of words acquired in M-3.  May smash M-S, M-T, M-K, M-4.
;Also M-A may be altered to point to the real location of the acquired storage.
;*** Clobbers M-ZR
TREUSE	((M-T) M-A)				;M-T is where we're looking now
TREUSE0	((VMA-START-READ) M-T)			;See what needs to be gotten rid of
	(CHECK-PAGE-READ)
	(JUMP-EQUAL READ-MEMORY-DATA A-ZERO TREUSE1)	;Jump if end of space
	((M-TEM) TEMP-CHUNK-HDR1-OBJECT-FREE-PTR READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-TEM A-ZERO TCLEAN0)	;Jump if an actual chunk there
	((M-T) ADD READ-MEMORY-DATA A-T)	;Reusable storage, advance past
	((M-3) SUB M-T A-A)			;Amount gotten
	(POPJ-GREATER-OR-EQUAL M-3 A-B)		;Return if it's enough
	(JUMP TREUSE0)				;Try for some more

TREUSE1	;; Reached end of space.  Wrap around and try again.  Shouldn't be
	;; able to get stuck in a loop since the length was checked at the beginning.
	((OA-REG-HIGH) DPB M-E OAH-A-SRC)
	((M-A) A-V-TEMPORARY-LIST-AREA)
	(JUMP TREUSE)

TCLEAN0	;; The hard part.  This chunk has to be displaced.
	((C-PDL-BUFFER-POINTER-PUSH) M-A)	;M-A bashed below
	((A-TCLEAN-FIRST) ADD M-T (A-CONSTANT TEMP-CHUNK-HDR-SIZE))	;First object
	((A-TCLEAN-LAST) ADD M-T A-TEM)		;First address after all objects
	((A-TCLEAN-STORAGE) SETZ)		;Will accumulate storage needed
	;; First, map through pointers in the machine and mark objects which are referenced
	;; by setting the Q-FLAG-BIT of such an object's header.
	(CALL-XCT-NEXT MAP-OVER-POINTERS-IN-MACHINE)
       ((M-ZR) (A-CONSTANT (I-MEM-LOC TCLEAN1)))
	;; Do the same with the back-pointers
	(CALL MAP-OVER-BACK-POINTERS)
	;; Now, if this is list space, the marked objects may point to some
	;; unmarked objects, so those have to be marked also.
	;; This has to be done without a stack, so we use multiple passes
	;; alternating up and down, changing the headers into trailers on
	;; the up passes and back into headers on the down passes.
	(JUMP-NOT-EQUAL M-E (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-LIST)) TCLEAN7)
TCLEAN2	((M-S) A-TCLEAN-STORAGE)		;Keep repeating until nothing new marked
	((M-4) A-TCLEAN-FIRST)
	;; Up-pass.  M-4 current pointer, M-3 previous header (not initialized!)
TCLNU3	((VMA-START-READ) M-4)			;Get object header
	(CHECK-PAGE-READ)
	((M-TEM) M-3)				;Replace it with trailer (previous header)
	((M-3) READ-MEMORY-DATA)		;Save this header for next time
	((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-TEM A-3) ;Change pointer but not flag-bit
	(CHECK-PAGE-WRITE)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT M-3 TCLNU5)	;If not marked, no mark through
	((M-3) Q-POINTER M-3)			;Number of pointers in this object
TCLNU4	((VMA-START-READ M-4) ADD M-4 (A-CONSTANT 1))	;Get pointer to mark through
	(CHECK-PAGE-READ)
	(CALL-XCT-NEXT MOPIM5)
       ((M-A) READ-MEMORY-DATA)
	(JUMP-GREATER-THAN-XCT-NEXT M-3 (A-CONSTANT 1) TCLNU4)
       ((M-3) SUB M-3 (A-CONSTANT 1))
TCLNU5	((M-4) M+A+1 M-4 A-3)			;Get to next object
	(JUMP-LESS-THAN M-4 A-TCLEAN-LAST TCLNU3)
	;; Down-pass
TCLND3	((VMA-START-READ) M-A-1 M-4 A-3)	;Fetch header location of this object
	(CHECK-PAGE-READ)
	((M-TEM) M-3)				;Put back the correct header
	((M-3) READ-MEMORY-DATA)		;Replacing the trailer that's there now
	((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-TEM A-3) ;Change pointer but not flag-bit
	(CHECK-PAGE-WRITE)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT M-3 TCLND5)	;If not marked, no mark through
	((M-3) Q-POINTER M-3)			;Number of pointers in this object
TCLND4	((VMA-START-READ M-4) SUB M-4 (A-CONSTANT 1))	;Get pointer to mark through
	(CHECK-PAGE-READ)
	(CALL-XCT-NEXT MOPIM5)
       ((M-A) READ-MEMORY-DATA)
	(JUMP-GREATER-THAN-XCT-NEXT M-3 (A-CONSTANT 1) TCLND4)
       ((M-3) SUB M-3 (A-CONSTANT 1))
TCLND5	((M-4) M-A-1 M-4 A-3)			;Get to next object
	(JUMP-GREATER-THAN-XCT-NEXT M-4 A-TCLEAN-FIRST TCLND3)
	;; If anything was marked during those 2 passes, do 2 more.  Otherwise done.
	;; If nothing was marked during the up-pass, the down-pass was redundant
	;; except to fix the headers.  Possibly the headers should remember
	;; whether they have already been marked through with another bit?
	(JUMP-NOT-EQUAL M-S A-TCLEAN-STORAGE TCLEAN2)
TCLEAN7	;; Just about ready to cons up permanent storage for marked objects
	((C-PDL-BUFFER-POINTER-PUSH) M-B)	;Preserve registers bashed by cons
	((C-PDL-BUFFER-POINTER-PUSH) M-E)
	;;*** This needs to be done with some flag set so it can't sequence-break ***
	(CALL-XCT-NEXT TCONSX)			;SCONS or LCONS in A-WORKING-AREA
       ((M-B) A-TCLEAN-STORAGE)
	;; Copy them out.  No GC-WRITE-TEST nor TRANSPORT can be required.	
	;; No transport because temporary space never contains a pointer to old-space.
	;; No GC-WRITE-TEST of the usual flavor, but if this points to temporary
	;; space then there is a back-pointer to it which needs to be relocated.
	;; We don't want to create a new back-pointer since that could recursively
	;; enter this routine if the back-pointer table of the pointed-to chunk was full.
	((M-4) A-TCLEAN-FIRST)			;Header of next object to do
	((M-E) SUB M-T (A-CONSTANT 1))		;Where to copy it to (minus one)
TCLNC3	((VMA-START-READ) M-4)			;Get object header
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA TCLNC5)	;If not marked, don't copy
	((M-3) Q-POINTER READ-MEMORY-DATA)	;Size of this object
TCLNC4	((VMA-START-READ M-4) ADD M-4 (A-CONSTANT 1))	;Get Q to copy
	(CHECK-PAGE-READ)
	;;*** We ain't done yet, buster! ***
	;;*** Pointer relocation:
	;;*** (1) Relocation of these pointers when they point to same chunk
	;;*** (1.5) Relocation of back-pointers to this place, when it points to a different
	;;	    chunk of temporary space.
	;;*** (2) Storing of forwarding pointers
	;;*** (3) Scanning of back-pointers and of the machine, following
	;;***     any pointers to this chunk through their forwarding pointers.
	;;*** No snapping-out, unlike TRANS-COPY ?
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;This just checks parity
	((VMA-START-WRITE M-E) ADD M-E (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-3 (A-CONSTANT 1) TCLNC4)
       ((M-3) SUB M-3 (A-CONSTANT 1))
TCLNC5	((M-4) M+A+1 M-4 A-3)			;Get to next object
	(JUMP-LESS-THAN M-4 A-TCLEAN-LAST TCLNC3)
	;;*** Next 2 lines are a temporary error-check ***
	((M-E) SUB M-E A-B)			;Verify correct amount copied
	(CALL-NOT-EQUAL M-E A-T ILLOP)
	;;Make this chunk into unallocated space
	((M-TEM) A-TCLEAN-FIRST)
	((VMA-START-READ) SUB M-TEM (A-CONSTANT TEMP-CHUNK-HDR-SIZE))
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA TEMP-CHUNK-HDR1-CHUNK-SIZE A-ZERO)
	(CHECK-PAGE-WRITE)
	((M-E) C-PDL-BUFFER-POINTER-POP)	;Retry the whole thing
	((M-B) C-PDL-BUFFER-POINTER-POP)
	((M-A) C-PDL-BUFFER-POINTER-POP)
	(JUMP TREUSE)

;; If pointer in M-A points into area being cleaned, mark the header
TCLEAN1	(POPJ-GREATER-OR-EQUAL M-A A-TCLEAN-LAST)
	(POPJ-LESS-THAN M-A A-TCLEAN-FIRST)
	(CALL TC-FIND-HEADER)
	(POPJ-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA)
	((A-TCLEAN-STORAGE) ADD READ-MEMORY-DATA A-TCLEAN-STORAGE)	;Count Q's needed
	(POPJ-AFTER-NEXT (WRITE-MEMORY-DATA-START-WRITE)
		IOR READ-MEMORY-DATA (A-CONSTANT (BYTE-VALUE Q-FLAG-BIT 1)))
       (CHECK-PAGE-WRITE)

;; Given a pure pointer in M-A, find the header of the object pointed to, into VMA/MD.
TC-FIND-HEADER
	((VMA-START-READ) A-TCLEAN-FIRST)	;Get first header
TC-FIND-HEADER-0
	(CHECK-PAGE-READ)
	((M-TEM) Q-POINTER READ-MEMORY-DATA)	;Size of object following header
	((M-TEM) M+A+1 VMA A-TEM)		;Address of next header
	(POPJ-LESS-THAN M-A A-TEM)		;Return if before next header
	(JUMP-XCT-NEXT TC-FIND-HEADER-0)	;Try next header
       ((VMA-START-READ) M-TEM)

;; Map a specified subroutine over all pointers in the machine.
;; The routine in M-ZR gets called with a pointer in M-A that came
;; from the machine.  Upon return the pointer goes back where it
;; came from.  Also uses M-4.  Note that only the pointer field
;; is passed in M-A, the typed pointer may be found in A-MOPIM-Q
;; Pointers "in the machine" come from M-ZR (M-B really) through M-K, A-VERSION through
;; A-END-Q-POINTERS, and the active part of the pdl buffer.
MAP-OVER-POINTERS-IN-MACHINE
	((M-4) (A-CONSTANT (M-MEM-LOC M-B)))	;Do M memory
MOPIM1	((OA-REG-HIGH) DPB M-4 OAH-M-SRC)
	((M-A) M-GARBAGE)  ;M-GARBAGE IS LOCATION 0@M
	(CALL MOPIM5)
	((OA-REG-LOW) DPB M-4 OAL-M-DEST)
	((M-GARBAGE) Q-POINTER M-A A-MOPIM-Q)
	(JUMP-NOT-EQUAL-XCT-NEXT M-4 (A-CONSTANT (M-MEM-LOC M-K)) MOPIM1)
       ((M-4) ADD M-4 (A-CONSTANT 1))
	((M-4) (A-CONSTANT (A-MEM-LOC A-VERSION)))	;Do A memory
MOPIM2	((OA-REG-HIGH) DPB M-4 OAH-A-SRC)
	((M-A) A-GARBAGE) ;A-GARBAGE IS LOCATION 0@A
	(CALL MOPIM5)
	((OA-REG-LOW) DPB M-4 OAL-A-DEST)
	((A-GARBAGE) Q-POINTER M-A A-MOPIM-Q)
	(JUMP-NOT-EQUAL-XCT-NEXT M-4 (A-CONSTANT (A-MEM-LOC A-END-Q-POINTERS)) MOPIM2)
       ((M-4) ADD M-4 (A-CONSTANT 1))
	((M-4) A-PDL-BUFFER-HEAD)
MOPIM3	((PDL-BUFFER-INDEX M-4) (BYTE-FIELD 10. 0) M-4)
	(CALL-XCT-NEXT MOPIM5)
       ((M-A) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) M-4)	;Restore possibly-clobbered PI
	((C-PDL-BUFFER-INDEX) Q-POINTER M-A A-MOPIM-Q)
	(JUMP-NOT-EQUAL-XCT-NEXT A-4 PDL-BUFFER-POINTER MOPIM3)
       ((M-4) ADD M-4 (A-CONSTANT 1))
	(POPJ)

MOPIM5	((A-MOPIM-Q) M-A)			;Save for later restoration
	(DISPATCH Q-DATA-TYPE M-A SKIP-IF-POINTER)
	 (POPJ)
	((OA-REG-LOW) DPB M-ZR OAL-JUMP)
	(JUMP-XCT-NEXT)
       ((M-A) Q-POINTER M-A)			;Pass just the pure pointer

;; Similar to MAP-OVER-POINTERS-IN-MACHINE, but maps over back-pointers of
;; chunk whose header is just before A-TCLEAN-FIRST
MAP-OVER-BACK-POINTERS
	((VMA-START-READ) ADD (M-CONSTANT -1) A-TCLEAN-FIRST)	;Second header word
	(CHECK-PAGE-READ)
	((M-TEM) TEMP-CHUNK-HDR2-BACK-PTR-FREE-PTR READ-MEMORY-DATA)
	((M-4) TEMP-CHUNK-HDR2-FIRST-BACK-PTR READ-MEMORY-DATA)
	((A-TCLEAN-COUNT) SUB M-TEM A-4)	;Number of back pointers
	((M-4) ADD VMA A-4)			;1+ address of first back pointer
MOBP1	(POPJ-EQUAL A-TCLEAN-COUNT M-ZERO)
	((VMA-START-READ) SUB M-4 (A-CONSTANT 1))	;Get a back-pointer
	(CHECK-PAGE-READ)
	((VMA-START-READ) READ-MEMORY-DATA)	;Fetch possible pointer to here
	(CHECK-PAGE-READ)
	(CALL-XCT-NEXT MOPIM5)
       ((M-A) READ-MEMORY-DATA)
	((A-TCLEAN-COUNT) ADD (M-CONSTANT -1) A-TCLEAN-COUNT)
	(JUMP-XCT-NEXT MOBP1)
       ((M-4) ADD M-4 (A-CONSTANT 1))

;HERE WHEN AREA REQUIRES NEW REGION

SCONS5	((M-E) (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-STRUCTURE)))
	(JUMP-XCT-NEXT SCONS2)
       (CALL RCONS)

LCONS5	((M-E) (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-LIST)))
	(JUMP-XCT-NEXT LCONS2)
       (CALL RCONS)

;Allocate a new region for area in M-S
;Must be at least M-B words, desired representation type in M-E, other attributes from
; the area's first region, and as follows:
;Immediately after a flip, an area may have only old-space regions.
;In that case, we have to make sure we create new-space regions,
;not additional old-space regions, as we cons in that area.
;If called from the transporter, we should make copy-space rather than new-space.
;REGION-SPACE-TYPE is determined as follows:
; If called from scavenger, %REGION-SPACE-COPY
; Otherwise copy first region except canonicalize OLD and COPY into NEW
;REGION-SCAVENGE-ENABLE is determined as follows:
; For static area, it should be on and will be copied from area's first region.
; For dynamic area, it should be on for COPY and off for NEW and OLD.
;Return region number in M-K
;May bash M-E, M-T only (among lettered registers).
;Protects M-1, M-2.

RCONS	((VMA-START-READ) ADD M-S A-V-AREA-REGION-LIST)	;COMPUTE CURRENT SIZE OF AREA
	(CHECK-PAGE-READ)				;BY ADDING UP SIZES OF ALL REGIONS
	((M-4) SETZ)					;INTO M-4
	((M-K C-PDL-BUFFER-POINTER-PUSH) Q-POINTER READ-MEMORY-DATA)
RCONS0	((VMA-START-READ) ADD M-K A-V-REGION-LENGTH)	;USE TOTAL SIZE NOT ALLOCATED SIZE
	(CHECK-PAGE-READ)
	((M-4) ADD READ-MEMORY-DATA A-4)
	((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT BOXED-SIGN-BIT READ-MEMORY-DATA RCONS0)
       ((M-K) Q-POINTER READ-MEMORY-DATA)
	((M-K) C-PDL-BUFFER-POINTER-POP)	;FIRST REGION IN AREA
	((VMA-START-READ) ADD M-S A-V-AREA-REGION-SIZE)
	(CHECK-PAGE-READ)
	((M-3) Q-POINTER READ-MEMORY-DATA)	;NORMAL AMOUNT TO ALLOCATE
	(JUMP-GREATER-THAN M-3 A-B RCONS1)
	((M-3) M-B)				;M-3 AMOUNT WE WANT TO ALLOCATE
RCONS1	((VMA-START-READ) ADD M-S A-V-AREA-MAXIMUM-SIZE)
	(CHECK-PAGE-READ)
	((M-4) SUB READ-MEMORY-DATA A-4)	;M-4 AMOUNT LEFT BEFORE OVERFLOW
	((OA-REG-HIGH) BOXED-SIGN-BIT M-4)	;SIGN EXTEND TO 32 BITS
	((M-4) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-4)
	(JUMP-GREATER-OR-EQUAL M-4 A-3 RCONS2)	;JUMP IF NO OVERFLOW PROBLEM
	(JUMP-IF-BIT-SET M-TRANSPORT-FLAG RCONS2A) ;INHIBIT EMBARRASSING TRAP OUT OF TRANSP
	(CALL-GREATER-THAN M-B A-4 TRAP)
    (ERROR-TABLE AREA-OVERFLOW M-S)
RCONS2A	((M-3) M-B)				;ALMOST OVERFLOWING, ALLOCATE LESS (WIN?)
RCONS2	((VMA-START-READ) ADD M-K A-V-REGION-BITS)	;GET BITS FOR THIS REGION
	(CHECK-PAGE-READ)			;FROM FIRST REGION IN THE AREA
	(JUMP-IF-BIT-SET-XCT-NEXT M-TRANSPORT-FLAG RCONS4)
       ((M-4) READ-MEMORY-DATA)
	((M-TEM) (LISP-BYTE %%REGION-SPACE-TYPE) M-4)
	(DISPATCH-XCT-NEXT (BYTE-FIELD 4 0) M-TEM D-RCONS)	;Check region type
RCONS3 ((M-4) IOR M-4 (A-CONSTANT (BYTE-MASK %%REGION-OLDSPACE-META-BIT))) ;Not oldspace
	((M-4) DPB M-TEM (LISP-BYTE %%REGION-SPACE-TYPE) A-4)
	(CALL-XCT-NEXT MAKE-REGION)		;ALLOCATE A REGION OF THAT SIZE (TO M-K)
       ((M-4) DPB M-E (LISP-BYTE %%REGION-REPRESENTATION-TYPE) A-4)
	;Cons into area region list - for now we just put it at the front
	;In the case where there is more than one representation type this could be unoptimal
	((VMA-START-READ) ADD M-S A-V-AREA-REGION-LIST)
	(CHECK-PAGE-READ)
	((M-3) READ-MEMORY-DATA)		;2ND REGION
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-K Q-POINTER A-3)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) M-3)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-K A-V-REGION-LIST-THREAD)
       (CHECK-PAGE-WRITE)

RCONS4	((M-TEM) (A-CONSTANT (EVAL %REGION-SPACE-COPY)))
	(JUMP-XCT-NEXT RCONS3)	;COPY space should always have scavenge enable
       ((M-4) DPB (M-CONSTANT -1) (LISP-BYTE %%REGION-SCAVENGE-ENABLE) A-4)

RCONS-DYNAM	;Newspace doesn't need to be scavenged
	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL %REGION-SPACE-NEW)))
       ((M-4) DPB M-ZERO (LISP-BYTE %%REGION-SCAVENGE-ENABLE) A-4)

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-RCONS	(P-BIT ILLOP)		;0 FREE
	(P-BIT RCONS-DYNAM)	;1 OLD (change into new)
	(P-BIT R-BIT)		;2 NEW (copy it)
	(P-BIT R-BIT)		;3 STATIC (copy it)
	(P-BIT ILLOP)		;4 FIXED (not supposed to cons new regions)
	(P-BIT R-BIT)		;5 EXITED (copy it)
	(P-BIT R-BIT)		;6 EXIT (copy it)
	(P-BIT ILLOP)		;7 TEMPORARY SPACE (not supposed to cons new regions)
	(P-BIT ILLOP)		;10 WIRED (not supposed to cons new regions)
	(P-BIT ILLOP)		;11 USER-PAGED (not supposed to cons new regions)
	(P-BIT RCONS-DYNAM)	;12 COPY (change into new)
(REPEAT 5 (P-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; MAKE A REGION.
;;; M-3 HAS SIZE IN WORDS, M-4 HAS REGION-BITS
;;; SETS UP EVERYTHING ELSE EXCEPT REGION-LIST-THREAD, RETURNS REGION IN M-K, BASHES M-E, M-T
;;; PRESERVES M-3 AND M-4, EXCEPT M-3 IS ROUNDED UP TO THE NEXT PAGE BOUNDARY
MAKE-REGION
	((M-3) ADD M-3 (A-CONSTANT (BYTE-MASK VMA-LOW-BITS)))	;Round up to page boundary
	((M-3) SELECTIVE-DEPOSIT M-3 VMA-PAGE-ADDR-PART A-ZERO)
	((A-REGION-CONS-ALARM) M+A+1 M-ZERO A-REGION-CONS-ALARM)
	((M-TEM) VMA-PAGE-ADDR-PART M-3)	;Length of region in pages
	((A-PAGE-CONS-ALARM) ADD M-TEM A-PAGE-CONS-ALARM)
	;Check out the free regions
	((M-TEM) (A-CONSTANT (EVAL (FIND-POSITION-IN-LIST 'FREE-AREA AREA-LIST))))
	((VMA-START-READ) ADD M-TEM A-V-AREA-REGION-LIST)
MAKE-REGION-1
	(CHECK-PAGE-READ)
	((M-T) VMA)				;SAVE WHO POINTED AT THIS REGION
	(CALL-IF-BIT-SET BOXED-SIGN-BIT READ-MEMORY-DATA TRAP)
    (ERROR-TABLE VIRTUAL-MEMORY-OVERFLOW)
	((M-K) Q-POINTER READ-MEMORY-DATA)	;REGION#
	((VMA-START-READ) ADD M-K A-V-REGION-LENGTH)
	(CHECK-PAGE-READ)
	((M-TEM) Q-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-3 MAKE-REGION-3)	;FITS EXACTLY
	(JUMP-GREATER-THAN M-TEM A-3 MAKE-REGION-2)	;SPLIT THIS FREE REGION
	(JUMP-XCT-NEXT MAKE-REGION-1)
       ((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)

MAKE-REGION-2
	((WRITE-MEMORY-DATA-START-WRITE) SUB READ-MEMORY-DATA A-3)	;NEW LENGTH
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)	;ORIGIN FOR NEW REGION
	((WRITE-MEMORY-DATA-START-WRITE) ADD M-T A-3)	;NEW ORIGIN FOR FREE REGION
	(CHECK-PAGE-WRITE)
MAKE-REGION-4
	;; M-T HAS ORIGIN, M-3 HAS LENGTH, M-4 HAS BITS.  PUT REGION IN TABLES.
	((VMA-START-READ) (A-CONSTANT (EVAL (PLUS 400 %SYS-COM-FREE-REGION/#-LIST))))
	(CHECK-PAGE-READ)
	((M-K) Q-POINTER READ-MEMORY-DATA)	;NUMBER OF NEW REGION
	(CALL-EQUAL M-K A-ZERO TRAP)
    (ERROR-TABLE REGION-TABLE-OVERFLOW)		;WE HAVE LOST SOME OF FREE SPACE, TOO BAD
	((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)	;CDR OFF OF LIST
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;THIS ENSURES READ CYCLE FINISHES
	((VMA-START-WRITE) (A-CONSTANT (EVAL (PLUS 400 %SYS-COM-FREE-REGION/#-LIST))))
	(CHECK-PAGE-WRITE)
MAKE-REGION-3A
	;; SET UP REGION-SORTED-BY-ORIGIN
	((M-TEM) (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)))
	((VMA-START-READ) ADD M-TEM A-V-REGION-SORTED-BY-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
	((M-TEM) SETZ)		;TABLE INDEX
	((A-TEM1) ADD READ-MEMORY-DATA A-V-REGION-ORIGIN)	;LAST ENTRY, IS REPLICATED
MAKE-REGION-5
	(JUMP-EQUAL VMA A-TEM1 MAKE-REGION-5B)			;GOES AFTER ALL EXISTING ONES
	((VMA-START-READ) ADD M-TEM A-V-REGION-SORTED-BY-ORIGIN);SEARCH UP FOR WHERE THIS
	(ILLOP-IF-PAGE-FAULT)					; REGION BELONGS
	((VMA-START-READ) ADD READ-MEMORY-DATA A-V-REGION-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
	((A-TEM2) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-T A-TEM2 MAKE-REGION-5)
       ((M-TEM) ADD M-TEM (A-CONSTANT 1))
	;; GOES RIGHT HERE, M-TEM MINUS ONE, SHIFT EVERYTHING ELSE UP
	((A-TEM1) SUB M-TEM (A-CONSTANT 1))
	((M-TEM) ADD (M-CONSTANT -1) (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)))
MAKE-REGION-5A
	((VMA-START-READ) ADD M-TEM A-V-REGION-SORTED-BY-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-NOT-EQUAL-XCT-NEXT M-TEM A-TEM1 MAKE-REGION-5A)
       ((M-TEM) SUB M-TEM (A-CONSTANT 1))
	((WRITE-MEMORY-DATA) Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) M+A+1 M-TEM A-V-REGION-SORTED-BY-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
MAKE-REGION-6
	;; PROCEED TO INITIALIZE THE VARIOUS TABLES, EXCEPT LIST-THREAD WHICH CALLER DOES.
	((WRITE-MEMORY-DATA) Q-POINTER M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-K A-V-REGION-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
	((WRITE-MEMORY-DATA) Q-POINTER M-3 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-K A-V-REGION-LENGTH)
	(ILLOP-IF-PAGE-FAULT)
	((WRITE-MEMORY-DATA) Q-POINTER M-4 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-K A-V-REGION-BITS)
	(CHECK-PAGE-WRITE)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%REGION-COMPACT-CONS-FLAG) M-4 MAKE-REGION-7)
       ((WRITE-MEMORY-DATA) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;FREE PTR = 0
	(JUMP-NOT-EQUAL M-E (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-LIST)) MAKE-REGION-7)
	((WRITE-MEMORY-DATA) M-3)		;IN LIST SPACE, FREE AND SCAV PTRS START AT TOP
MAKE-REGION-7					;IF COMPACT-CONS MODE IS TURNED ON
	((VMA-START-WRITE) ADD M-K A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-K A-V-REGION-GC-POINTER)
       (CHECK-PAGE-WRITE)

MAKE-REGION-3	;FREE REGION EXACTLY THE RIGHT SIZE, USE IT UP
	((VMA-START-READ) ADD M-K A-V-REGION-LIST-THREAD)	;REMOVE FROM FREE LIST
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;ENSURE COMPLETION OF READ CYCLE
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	(JUMP-XCT-NEXT MAKE-REGION-3A)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

MAKE-REGION-5B  ;THIS REGION HIGHER THAN ALL OTHERS, REPLICATE THROUGH END OF ARRAY
		;M-TEM HAS THE INDEX OF THE SECOND OF THE REGION THAT USED TO BE REPLICATED
	((WRITE-MEMORY-DATA) Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-TEM A-V-REGION-SORTED-BY-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-LESS-THAN-XCT-NEXT M-TEM (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS))
		MAKE-REGION-5B)
       ((M-TEM) ADD M-TEM (A-CONSTANT 1))
	(JUMP MAKE-REGION-6)

;;; SUBROUTINE TO CREATE A REGION, CALLED ONLY BY AREA-CREATOR
;;; EXISTS MAINLY BECAUSE THE MICROCODE HAS TO KNOW HOW TO DO THIS ANYWAY

XMKRG (MISC-INST-ENTRY %MAKE-REGION)
	((M-3) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;SIZE
	(CALL-XCT-NEXT MAKE-REGION)
       ((M-4) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;BITS
	(POPJ-AFTER-NEXT
	 (M-T) Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)


;;; CALL THIS ROUTINE TO FREE UP A REGION, NUMBER IN M-K (MUST BE PURE NUMBER).
;;; IF ADJACENT TO ANOTHER FREE REGION, COMPACTIFIES.
;;; BASHES M-A,M-B,M-D,M-E,M-K,M-T, M-1...M-4, A-GC-TEM, A-TEM1...A-TEM3

XFREE-REGION (MISC-INST-ENTRY %GC-FREE-REGION)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XFALSE)))
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)
FREE-REGION
	((WRITE-MEMORY-DATA) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-K A-V-REGION-BITS)	;Clear the REGION-BITS, = free status
	(CHECK-PAGE-WRITE)
	((M-D) DPB (M-CONSTANT -1) (BYTE-FIELD 1 31.)	;Change swap-status to Flushable
		(A-CONSTANT 2))				; and disconnect the virtual page
	(CALL-XCT-NEXT UPDATE-REGION-PHT);Note that this sets M-1 and M-2 to the region bounds
       ((MD) (A-CONSTANT (BYTE-VALUE MAP-STATUS-CODE 2))) ;Make read-only, no access, in PHT2
				;Referencing this region will halt in XRGNPF
	;; Remove from REGION-SORTED-BY-ORIGIN
	((M-TEM) (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)))
	((M-3 VMA-START-READ) ADD M-TEM A-V-REGION-SORTED-BY-ORIGIN)
	(CHECK-PAGE-READ)
	((M-4) Q-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-4 A-K FREE-REGION-S-2)	;Jump if this was the highest region
FREE-REGION-S-1
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;Read out location to be bashed
	(CHECK-PAGE-READ)
	((A-TEM1) M-4)
	((M-4) Q-POINTER READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE)		;Bash with contents of next higher loc
		SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-POINTER A-TEM1)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT VMA A-V-REGION-SORTED-BY-ORIGIN FREE-REGION-S-1)
       (JUMP-EQUAL M-4 A-K FREE-REGION-S-4)		;Done if just removed this region
	(CALL ILLOP)					;Foo, region was not in table
							;and we've lost the region-0 entry

FREE-REGION-S-2
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;Find new highest region
	(CHECK-PAGE-READ)
	((M-4) Q-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-4 A-K FREE-REGION-S-2)
FREE-REGION-S-3
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))	;And replicate it back up
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN VMA A-3 FREE-REGION-S-3)
FREE-REGION-S-4
	;; Search free region list, attempt to concatenate to adjacent free region
	;; M-K region#, M-1 base address, M-2 upper-bound address
	((M-TEM) (A-CONSTANT (EVAL (FIND-POSITION-IN-LIST 'FREE-AREA AREA-LIST))))
	((VMA-START-READ) ADD M-TEM A-V-AREA-REGION-LIST)
FREE-REGION-1
	(CHECK-PAGE-READ)
	((A-GC-TEM) VMA)				;REMEMBER WHO POINTS HERE
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT READ-MEMORY-DATA FREE-REGION-7)	;NON-ADJACENT
	((M-4) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-4 A-V-REGION-ORIGIN)	;CHECK ADJACENCIES
	(ILLOP-IF-PAGE-FAULT)
	((A-TEM2) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-4 A-V-REGION-LENGTH)
	(ILLOP-IF-PAGE-FAULT)
	((M-TEM) Q-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-2 A-TEM2 FREE-REGION-6)
	((A-TEM3) ADD M-TEM A-TEM2)
	(JUMP-EQUAL M-1 A-TEM3 FREE-REGION-5)
	(JUMP-XCT-NEXT FREE-REGION-1)
       ((VMA-START-READ) ADD M-4 A-V-REGION-LIST-THREAD)

;Region in M-K is right before region in M-4
FREE-REGION-6
	((M-2) ADD READ-MEMORY-DATA A-2)	;NEW UPPER-BOUND, WITH FIXNUM TYPE
	((WRITE-MEMORY-DATA-START-WRITE) SUB M-2 A-1)	;UPDATE REGION-LENGTH
	(ILLOP-IF-PAGE-FAULT)
	((M-2) Q-POINTER M-2)			;REGION UPPER-BOUND AS PURE NUMBER
	((VMA) ADD M-4 A-V-REGION-ORIGIN)
	(JUMP-XCT-NEXT FREE-REGION-4)
       ((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-1	;UPDATE REGION-ORIGIN
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;REGION IN M-K IS RIGHT AFTER REGION IN M-4
FREE-REGION-5
	((M-1) A-TEM2)				;NEW BASE ADDRESS
	((M-TEM) SUB M-2 A-TEM2)		;SUM OF REGION-LENGTHS
	((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-TEM
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
FREE-REGION-4
	(ILLOP-IF-PAGE-FAULT)
	;; Put region in M-K onto free region-table-entry list, try again with M-4
	((VMA-START-READ) (A-CONSTANT (EVAL (PLUS 400 %SYS-COM-FREE-REGION/#-LIST))))
	(ILLOP-IF-PAGE-FAULT)
	((A-TEM2) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-K
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(ILLOP-IF-PAGE-FAULT)
	((WRITE-MEMORY-DATA) A-TEM2)
	((VMA-START-WRITE) ADD M-K A-V-REGION-LIST-THREAD)
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) ADD M-4 A-V-REGION-LIST-THREAD)	;UNTHREAD M-4 REGION
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;COMPLETE READ CYCLE
	((VMA-START-WRITE) A-GC-TEM)		;GUY WHO POINTED TO M-4 IS STILL IN A-GC-TEM
	(CHECK-PAGE-WRITE)
	(JUMP-XCT-NEXT FREE-REGION-S-4)
       ((M-K) M-4)

;NO ADJACENCY, ADD THIS REGION TO FREE-AREA
FREE-REGION-7
	((M-TEM) (A-CONSTANT (EVAL (FIND-POSITION-IN-LIST 'FREE-AREA AREA-LIST))))
	((VMA-START-READ) ADD M-TEM A-V-AREA-REGION-LIST)
	(CHECK-PAGE-READ)
	((A-TEM2) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) Q-POINTER M-K
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) A-TEM2)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-K A-V-REGION-LIST-THREAD)
       (CHECK-PAGE-WRITE)

;Remove all information about the region in M-K from the page map,
;and fix the PHT entries of any swapped-in pages.
;Call with MD containing the new REGION-BITS entry for the region,
; and M-D containing A-V-NIL or the new swap-status.
;Sets M-1 and M-2 to the bounds of the region.
;Bashes M-A, M-B, M-E, M-T, tems.
UPDATE-REGION-PHT
	((M-E) (LISP-BYTE %%REGION-MAP-BITS) MD)	;Arg for XCPGS0
	((VMA-START-READ) ADD M-K A-V-REGION-ORIGIN)	;Find virtual address range of region
	(CHECK-PAGE-READ)
	((M-1) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-K A-V-REGION-LENGTH)
	(CHECK-PAGE-READ)
	((M-2) Q-POINTER READ-MEMORY-DATA)
	((MD M-2) ADD M-1 A-2)
	;; M-1 has lowest address in region, M-2 has highest address in region +1
	;; Both are necessarily a multiple of the page size.
	;; Call XCPGS0 on each page, to fix the PHT entry (if any) and the map.
UPDATE-REGION-PHT-0
	(CALL-XCT-NEXT XCPGS0)
       ((C-PDL-BUFFER-POINTER-PUSH) SUB MD (A-CONSTANT (EVAL PAGE-SIZE)))
	(JUMP-GREATER-THAN MD A-1 UPDATE-REGION-PHT-0)
	(POPJ)

;;; SAFE ALLOCATION AND INITIALIZATION OF STRUCTURES

;(%ALLOCATE-AND-INITIALIZE <data type for return> <data type for header> <header> 
;				<value for second word> <area> <nqs>)
XAAI (MISC-INST-ENTRY %ALLOCATE-AND-INITIALIZE)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER)	;CHECK FOR ALLOC AT LEAST 2 WORDS
	(CALL-LESS-THAN M-1 (A-CONSTANT 2) ILLOP)
	(CALL XALLB)			;ALLOCATE BLOCK, RETURN IN M-T, NO SEQUENCE BREAK
					; WHILE CRUFT IS PARTIALLY INITIALIZED
	((VMA) ADD M-T (A-CONSTANT 1))	;-> SECOND WORD
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-WRITE)
	((A-TEM1) C-PDL-BUFFER-POINTER-POP)	;HEADER Q (POINTER PART)
	((WRITE-MEMORY-DATA) DPB C-PDL-BUFFER-POINTER-POP	;SET DATA TYPE, ETC.
		Q-ALL-BUT-POINTER A-TEM1)
	(POPJ-AFTER-NEXT			;WRITE THE HEADER, AND
	 (VMA-START-WRITE M-T) DPB C-PDL-BUFFER-POINTER-POP	; RETURN POINTER TO BLOCK,
		Q-ALL-BUT-POINTER A-T)		; WITH CORRECT TYPE
       (CHECK-PAGE-WRITE)

;(%ALLOCATE-AND-INITIALIZE-ARRAY <header as fixnum> <index length> <leader length> 
;					<area> <nqs>)
XAAIA (MISC-INST-ENTRY %ALLOCATE-AND-INITIALIZE-ARRAY)
	(CALL XALLB)			;ALLOCATE BLOCK, RETURN IN M-T, NO SEQUENCE BREAK
					; WHILE CRUFT IS PARTIALLY INITIALIZED
	((VMA M-T) Q-POINTER M-T	;VMA -> START OF BLOCK, M-T RIGHT MAYBE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-POINTER)))
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;LEADER LENGTH
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;INDEX LENGTH
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-LEADER-BIT)
		C-PDL-BUFFER-POINTER XAAIA1)
       ((M-2) DPB C-PDL-BUFFER-POINTER-POP	;HEADER
	    Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-HEADER)))
	((WRITE-MEMORY-DATA-START-WRITE) ADD M-C	;STORE LEADER HEADER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE %%HEADER-TYPE-FIELD
						    %HEADER-TYPE-ARRAY-LEADER))
				  2)))
	(CHECK-PAGE-WRITE)
	((VMA M-T) ADD M-T A-C ALU-CARRY-IN-ONE)	;POINTS ONE BEFORE HEADER
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-C
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CHECK-PAGE-WRITE)
	((VMA M-T) ADD M-T (A-CONSTANT 1))	;POINTS TO HEADER
XAAIA1	((WRITE-MEMORY-DATA-START-WRITE) M-2)	;STORE HEADER
	(CHECK-PAGE-WRITE)
	(POPJ-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-2)
	((VMA) ADD M-T (A-CONSTANT 1))
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) DPB M-B Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (CHECK-PAGE-WRITE)

;SUBROUTINE TO THE ABOVE.  TAKES AREA AND #QS ON PDL, CALLS SCONS.
;FILLS THE THING WITH NILS
XALLB	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP 2)
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG 2 NUMBER OF QS
	(CALL-XCT-NEXT SCONS)
       ((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG 1 AREA
	(JUMP FILL-WITH-NILS)

;SUBROUTINE TO CONS UP A LIST OF NILS.  ARGS LIKE LCONS.
;NOTE THAT DATA-TYPE RETURNED IN M-T IS GARBAGE.
LIST-OF-NILS
	(CALL LCONS)
FILL-WITH-NILS
	((M-3) M-B)				;NUMBER OF CELLS TO INITIALIZE
	((WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-CDR-CODE A-V-NIL)	;CDR-NEXT
	((VMA) SUB M-T (A-CONSTANT 1))
	(JUMP-LESS-OR-EQUAL M-3 (A-CONSTANT 1) FILL-WITH-NILS-1)
FILL-WITH-NILS-0
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-3 (A-CONSTANT 2) FILL-WITH-NILS-0)
       ((M-3) SUB M-3 (A-CONSTANT 1))
FILL-WITH-NILS-1
	((WRITE-MEMORY-DATA) Q-ALL-BUT-CDR-CODE WRITE-MEMORY-DATA
			(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(POPJ-AFTER-NEXT (VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
       (CHECK-PAGE-WRITE)
;OK TO POPJ AND START MEM CYCLE.  USED AS MISC INSTRUCTION, BUT NOT AS REGULAR INSTRUCTION.

;;; Sub-Primitives for dissecting an object in storage.
;;; These are called by the garbage collector and also available as misc functions.

;;; Given a pointer, return the object (base pointer and data type) which contains
;;; the cell to which the pointer points.  This may not be the actual beginning
;;; of the object's storage, in the case of an array with a leader.
;;; Arg on pdl, answer in M-T.  Clobbers M-A, M-B, M-E, and page-fault-clobberable.
;;;This function could maybe be improved with some pipelining, but hair is required!

;;; Inside this routine, it is important to note that M-A and VMA usually
;;; but not always contain the same thing.  The difference has to do with
;;; forwarded structures.  Study the code.

;;; %FIND-STRUCTURE-LEADER is the same except if given an array with a leader,
;;; it returns a locative to the leader-header rather than the usual array-pointer.
;;; This gives you the actual lowest address in the structure, which is what
;;; the transporter needs.

XFSH (MISC-INST-ENTRY %FIND-STRUCTURE-HEADER)
	(JUMP-XCT-NEXT XFSH0)
       ((M-E) SETZ)

XFSL (MISC-INST-ENTRY %FIND-STRUCTURE-LEADER)
	((M-E) SETO)	
XFSH0	(CALL XRGN)				;M-A gets pointer, M-T gets region
	((VMA-START-READ) ADD M-T A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	((M-B) Q-POINTER READ-MEMORY-DATA)	;Origin address of region
	((VMA-START-READ) ADD M-T A-V-REGION-BITS)	;Get representation type
	(CHECK-PAGE-READ)
	(DISPATCH (LISP-BYTE %%REGION-REPRESENTATION-TYPE)
		READ-MEMORY-DATA D-FSH)

(LOCALITY D-MEM)
(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
D-FSH	(XFSHL)		;0 LIST
	(XFSHS)		;1 STRUCTURE
	(P-BIT ILLOP)	;2 NOT USED
	(P-BIT ILLOP)	;3 NOT USED
(END-DISPATCH)

(START-DISPATCH 2 0)
D-FSHL	(P-BIT R-BIT)				;0 CDR-NORMAL
	(INHIBIT-XCT-NEXT-BIT P-BIT R-BIT)	;1 CDR-ERROR
	(INHIBIT-XCT-NEXT-BIT P-BIT R-BIT)	;2 CDR-NIL
	(XFSHL)					;3 CDR-NEXT
(END-DISPATCH)

(LOCALITY I-MEM)

;%FIND-STRUCTURE-HEADER in list space
XFSHL	(JUMP-EQUAL M-A A-B XFSHL1)		;This is start of list if start of region
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;Check preceding word
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;If it is forwarded, not same list
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER-FORWARD)) XFSHL1)
	(DISPATCH Q-CDR-CODE READ-MEMORY-DATA D-FSHL)	;CDR-NEXT -> search more,
       ((M-A) SUB M-A (A-CONSTANT 1))		; CDR-NORMAL -> include this one Q.
XFSHL1	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-LIST)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

;%FIND-STRUCTURE-HEADER in structure space

;This dispatch ignores data-types 0 and -1, rather than going to ILLOP,
;because they are legal in stack-group array-leaders.
(ASSIGN-EVAL NQZUSD-1 (EVAL (- 31. (LENGTH Q-DATA-TYPES))))
(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-FSHS	(XFSHS1)				;TRAP
	(XFSHS1)				;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(XFSHS1)				;SYMBOL
	(INHIBIT-XCT-NEXT-BIT XFSHSS)		;SYMBOL-HEADER
	(XFSHS1)				;FIX
	(XFSHS1)				;EXTENDED-NUMBER
	(INHIBIT-XCT-NEXT-BIT XFSHSH)		;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(XFSHS1)				;EXTERNAL-VALUE-CELL-POINTER
	(XFSHS1)				;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT XFSHS-HFWD)	;HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT XFSHS-BFWD)	;BODY-FORWARD
	(XFSHS1)				;LOCATIVE
	(XFSHS1)				;LIST
	(XFSHS1)				;U CODE ENTRY
	(XFSHS1)				;FEF
	(XFSHS1)				;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT XFSHSA)		;ARRAY-HEADER
	(XFSHS1)				;STACK-GROUP
	(XFSHS1)				;CLOSURE
	(XFSHS1)				;SMALL-FLONUM 
	(XFSHS1)				;SELECT-METHOD
	(XFSHS1)				;INSTANCE
	(INHIBIT-XCT-NEXT-BIT XFSHSI)		;INSTANCE-HEADER
	(XFSHS1)				;ENTITY
 (REPEAT NQZUSD-1 (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
	(XFSHS1)				;DATA-TYPE 37
(END-DISPATCH)

(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)	;DISPATCH ON HEADER SUBTYPE
D-FSHSH	(P-BIT ILLOP)	;%HEADER-TYPE-ERROR
	(XFSHSHF)	;%HEADER-TYPE-FEF
	(XFSHSHAL)	;%HEADER-TYPE-ARRAY-LEADER
	(P-BIT ILLOP)	;unused
	(XFSHSHN)	;%HEADER-TYPE-FLONUM
	(XFSHSHN)	;%HEADER-TYPE-COMPLEX
	(XFSHSHN)	;%HEADER-TYPE-BIGNUM
	(XFSHSHN)	;%HEADER-TYPE-RATIONAL-BIGNUM
(REPEAT NHDUSD (P-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;%FIND-STRUCTURE-HEADER in structure space
XFSHS	((VMA-START-READ) M-A)
XFSHS1	(CHECK-PAGE-READ)
	(CALL-LESS-THAN M-A A-B ILLOP)		;Dropped off top of region
	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA D-FSHS)	;Leave loop if header,
       ((M-A VMA-START-READ) SUB M-A (A-CONSTANT 1))	; or read preceding word and loop

XFSHSS	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-SYMBOL)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

;This is an array.  We may want to return a locative pointer to the leader,
;an array-pointer to the header, or a stack-group pointer to the header.
XFSHSA	(JUMP-EQUAL M-E A-ZERO XFSHA2)			;Jump if %FIND-STRUCTURE-HEADER
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) READ-MEMORY-DATA XFSHA3)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;Pick up leader length
	(CHECK-PAGE-READ)
	((M-TEM) ADD READ-MEMORY-DATA (A-CONSTANT 2))	;and end up returning ptr to leader hdr
	((M-A) SUB M-A A-TEM)
	((M-A) Q-POINTER M-A)		;Prevent garbage data-type in M-A upon return
XFSHA1	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-LOCATIVE)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

;Return a pointer to the header, with data-type DTP-ARRAY-POINTER or DTP-STACK-GROUP
XFSHA2	((M-TEM) (LISP-BYTE %%ARRAY-TYPE-FIELD) READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL (LSH ART-STACK-GROUP-HEAD ARRAY-TYPE-SHIFT)))
			XFSHSG)
XFSHA3	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-ARRAY-POINTER)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

XFSHSG	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-STACK-GROUP)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

XFSHSI	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-INSTANCE)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

XFSHS-BFWD
	((M-A VMA-START-READ) Q-POINTER READ-MEMORY-DATA)	;BODY-FORWARD -> HEADER-FORWARD
	(CHECK-PAGE-READ)
XFSHS-HFWD
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)	;HEADER-FORWARD -> new header
	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA D-FSHS)	;DISPATCH ON TYPE OF THAT HEADER,
							; M-A STILL POINTS AT OLD ONE
       (CALL ILLOP)					;SHOULDN'T XCT-NEXT, SHOULD BE HEADER!

XFSHSH	(DISPATCH (LISP-BYTE %%HEADER-TYPE-FIELD) READ-MEMORY-DATA D-FSHSH)

XFSHSHN	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-EXTENDED-NUMBER)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

XFSHSHF	(POPJ-AFTER-NEXT (M-TEM) (A-CONSTANT (EVAL DTP-FEF-POINTER)))
       ((M-T) DPB M-TEM Q-DATA-TYPE A-A)

XFSHSHAL
	(JUMP-NOT-EQUAL M-E A-ZERO XFSHA1)	;Jump if %FIND-STRUCTURE-LEADER
	((M-TEM) (LISP-BYTE %%ARRAY-LEADER-LENGTH) READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT (M-A) ADD M-A A-TEM)	;OFFSET FROM LEADER TO HEADER
       ((M-T) Q-POINTER M-A (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-POINTER)))

;;; Given the address of the base of a structure, return information on its size.
;;; Note that if given the address of an array header, the leader (if any) is
;;; not counted, but if given the address of the leader, the leader is
;;; counted.  I.e. nothing before the given address is counted.
;;; In the case of an RPLACD-forwarded list, the 2 words pointed to by the
;;; forwarding-pointer are counted, and the forwarding-pointer itself isn't.
;;; Inputs:  address in MD
;;; Outputs: M-3 number of boxed Q's, M-4 number of unboxed Q's following those,
;;;	     A-SINF-PAD number of those Q's which need not be copied (pdl's only).
;;;	     A-SINF-PDL-BASE usually 0, else pointer to base of structure.
;;;		The scavenger, in its finite wisdom, uses this.
;;;		The value of this is garbage if not called from the scavenger.
;;;	     M-K map data, mainly for representation type
;;;	     M-K<31> = 1 if this is a list which ends in an rplacd-forwarding
;;; Clobbers: M-A, M-B, M-T, usual page-fault things.
;;; The type field of VMA is zero throughout this section.
;;; This routine MAY NOT call the transporter, since it is invoked by the
;;; transporter.  Otherwise the transporter's variables and flag could be
;;; clobbered, and the possibility of micro-stack overflow would arise.
;;; Note that an illegal pointer to oldspace can be left in the VMA.

;;; This entry saves M-A, M-B, M-T for the scavenger and sets A-SCAV-COUNT, A-SCAV-SKIP
SCAV-STRUCTURE-INFO
	((A-SCAV-SAVE-A) M-A)	;Shouldn't use pdl buffer since may be computing pdl size
	((A-SCAV-SAVE-B) M-B)
	((A-SCAV-SAVE-T) M-T)
	((A-SCAV-PDL-BASE) Q-POINTER MD)	;Could get moved into A-SINF-PDL-BASE
	(CALL-XCT-NEXT STRUCTURE-INFO)
       ((A-SINF-PDL-BASE) (A-CONSTANT 0))
	((A-SCAV-COUNT) SUB M-3 A-SINF-PAD)
	((A-SCAV-SKIP) ADD M-4 A-SINF-PAD)
	((M-T) A-SCAV-SAVE-T)
	(POPJ-AFTER-NEXT (M-B) A-SCAV-SAVE-B)
       ((M-A) A-SCAV-SAVE-A)

STRUCTURE-INFO
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-ASSURE-MAP-VALID)
	((M-K) MAP-SECOND-LEVEL-MAP MEMORY-MAP-DATA)	;FOR DISPATCH BELOW, AND
						; RETURNED TO CALLER.  NOTE 0 IN SIGN BIT.
	((VMA-START-READ) Q-POINTER MD)		;FETCH FIRST WORD
	(CHECK-PAGE-READ)
	((M-3) (A-CONSTANT 0))			;INITIALIZE RETURN VALUES
	((A-SINF-PAD) (A-CONSTANT 0))
	(DISPATCH-XCT-NEXT (LISP-BYTE %%REGION-REPRESENTATION-TYPE) M-K D-SINF)
       ((M-4) (A-CONSTANT 0))

(LOCALITY D-MEM)
(START-DISPATCH 2 0)
D-SINF	(SINFL)					;0 LIST
	(SINFS)					;1 STRUCTURE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;2 NOT USED
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;3 NOT USED
(END-DISPATCH)

(START-DISPATCH 2 0)
D-SINFL	(INHIBIT-XCT-NEXT-BIT SINFL1)		;0 CDR-NORMAL
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;1 CDR-ERROR
	(INHIBIT-XCT-NEXT-BIT R-BIT)		;2 CDR-NIL
	(SINFL0)				;3 CDR-NEXT
(END-DISPATCH)

(LOCALITY I-MEM)

;STRUCTURE-INFO in list space.  First word has been read, zero in M-3, M-4, A-SINF-PAD.
;There are no unboxed or pad Q's.  Scan forward through memory counting boxed Q's
;May clobber only M-3 and usual page-fault things, due to other callers.
SINFL0	(CHECK-PAGE-READ)
SINFL	((M-3) ADD M-3 (A-CONSTANT 1))		;Count this Q as part of structure
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;Forward ends list, but counts as 2 Q's!
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER-FORWARD)) SINFL2)
	(DISPATCH Q-CDR-CODE READ-MEMORY-DATA D-SINFL) ;Check cdr code, loop if CDR-NEXT
       ((VMA-START-READ) ADD VMA (A-CONSTANT 1))

SINFL2	((M-K) DPB (M-CONSTANT -1) (BYTE-FIELD 1 31.) A-K) ;Set sign of M-K
SINFL1	(POPJ-AFTER-NEXT (M-3) ADD M-3 (A-CONSTANT 1))
       (NO-OP)

;STRUCTURE-INFO in structure space.  First word has been read, zero in M-3, M-4, A-SINF-PAD.
SINFS	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA D-SINFS)
       ((M-3) (A-CONSTANT 5))			;Symbol is easy, make it fast case

(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-SINFS	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL
	(R-BIT)					;SYMBOL-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FIX
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTENDED-NUMBER
	(INHIBIT-XCT-NEXT-BIT SINFSH)		;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(INHIBIT-XCT-NEXT-BIT SINFS-HFWD)	;HEADER-FORWARD
	(INHIBIT-XCT-NEXT-BIT SINFS-BFWD)	;BODY-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;LOCATIVE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-POINTER
	(INHIBIT-XCT-NEXT-BIT SINFSA)		;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;STACK-GROUP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;CLOSURE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SMALL-FLONUM 
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;INSTANCE
	(INHIBIT-XCT-NEXT-BIT SINFSI)		;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;DTP-BODY-FORWARD - find DTP-HEADER-FORWARD, count boxed Q's between
SINFS-BFWD
	((M-TEM) Q-POINTER READ-MEMORY-DATA)	;Address of header
	((M-TEM) SUB VMA A-TEM)			;- # Q's between here and there
	(CALL-GREATER-OR-EQUAL M-TEM A-ZERO ILLOP)
	((M-3) SUB M-3 A-TEM)			;Account for them, drop into header case
	((VMA) Q-POINTER READ-MEMORY-DATA)
;DTP-HEADER-FORWARD - include all DTP-BODY-FORWARD's that point here as unboxed Q's
SINFS-HFWD
	(CALL-XCT-NEXT XRGN00)			;M-T gets region number
       ((M-A MD) Q-POINTER VMA)
	((VMA-START-READ) ADD M-T A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	((M-3) ADD M-3 (A-CONSTANT 1))		;1 boxed Q for the header
	((M-B) SUB READ-MEMORY-DATA (A-CONSTANT 1))
	((VMA-START-READ) ADD M-T A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-A) Q-POINTER M-A (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-BODY-FORWARD)))
	((M-B) ADD READ-MEMORY-DATA A-B)
	((M-B) Q-POINTER M-B)			;Last valid address in region
	((VMA) Q-POINTER M-A)			;Address of header
SINFS-HFWD-0
	(POPJ-GREATER-OR-EQUAL VMA A-B)		;Ran off top of region
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL-XCT-NEXT M-TEM A-A SINFS-HFWD-0) ;This word part of this forwarded struc
       ((M-4) ADD M-4 (A-CONSTANT 1))		;So count it and keep looping
	(POPJ-AFTER-NEXT (M-4) SUB M-4 (A-CONSTANT 1))	;Counted an extra time
       (NO-OP)

;Given a read cycle on a location which could be in oldspace,
;this subroutine substitutes for the transporter by checking for a GC-forward.
;Bashes M-TEM
SINF-TRANS
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)
	(POPJ-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-GC-FORWARD)))
	(JUMP-XCT-NEXT SINF-TRANS)
       ((VMA-START-READ) MD)

;DTP-INSTANCE-HEADER - get size from class (pointed to by pointer field of instance-header)
SINFSI	(CALL-XCT-NEXT SINF-TRANS)		;Access the class this is an instance of
       ((VMA-START-READ) ADD READ-MEMORY-DATA (A-CONSTANT 1)) ;Access instance variable 0
	(POPJ-XCT-NEXT)				; of the class, which is size of an instance
       ((M-3) Q-POINTER READ-MEMORY-DATA)

;DTP-HEADER - dispatch on subtype
SINFSH	(DISPATCH (LISP-BYTE %%HEADER-TYPE-FIELD) READ-MEMORY-DATA D-SINFSH)

(LOCALITY D-MEM)
(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)	;DISPATCH ON HEADER SUBTYPE
D-SINFSH(P-BIT ILLOP)	;%HEADER-TYPE-ERROR
	(SINF-FEF)	;%HEADER-TYPE-FEF
	(SINF-AL)	;%HEADER-TYPE-ARRAY-LEADER
	(P-BIT ILLOP)	;unused
	(SINF-FLO)	;%HEADER-TYPE-FLONUM
	(P-BIT ILLOP)	;%HEADER-TYPE-COMPLEX
	(SINF-BIG)	;%HEADER-TYPE-BIGNUM
	(P-BIT ILLOP)	;%HEADER-TYPE-RATIONAL-BIGNUM
(REPEAT NHDUSD (P-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

SINF-FLO
	(POPJ-AFTER-NEXT (M-4) (A-CONSTANT 2))	;2 unboxed Q's
       (NO-OP)	

SINF-BIG
	(POPJ-AFTER-NEXT
	 (M-4) BIGNUM-HEADER-LENGTH READ-MEMORY-DATA)
       ((M-4) ADD M-4 (A-CONSTANT 1))

SINF-FEF
	((M-3) (LISP-BYTE %%FEFH-PC-IN-WORDS) READ-MEMORY-DATA)	;Number of boxed words
	((VMA-START-READ) ADD VMA (A-CONSTANT (EVAL %FEFHI-STORAGE-LENGTH)))
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT (M-4) Q-POINTER READ-MEMORY-DATA)	;Total number of words
       ((M-4) SUB M-4 A-3)			;Number of unboxed words

SINF-AL	((M-3) (LISP-BYTE %%ARRAY-LEADER-LENGTH) READ-MEMORY-DATA)  ;Add in size of leader
	((VMA-START-READ) ADD VMA A-3)		;Reference header
	(CHECK-PAGE-READ)			;And drop into SINFSA

;DTP-ARRAY-HEADER - get info on array, depending on array-type
SINFSA	((M-A) Q-POINTER READ-MEMORY-DATA)	;Copy the array header
	((M-T) (LISP-BYTE %%ARRAY-NUMBER-DIMENSIONS) M-A)
	((M-B) (LISP-BYTE %%ARRAY-INDEX-LENGTH-IF-SHORT) M-A)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-A SINFSA1)
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)	
	((M-T) ADD M-T (A-CONSTANT 1))
	((M-B) Q-POINTER READ-MEMORY-DATA)	;Long index length
	((VMA) SUB VMA (A-CONSTANT 1))
SINFSA1	;; M-T # header words, M-B index length, VMA address of header, M-A header
	(JUMP-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-A SINFSA-DISPLACED)
       ((M-3) ADD M-3 A-T)			;Count array header, dimension words as boxed
	(DISPATCH (LISP-BYTE %%ARRAY-TYPE-FIELD) M-A D-SINFSA)
       ((M-3) ADD M-3 A-B)			;POPJ-XCT-NEXT if Q-type array

SINFSA-DISPLACED
	(POPJ-AFTER-NEXT (M-3) ADD M-3 A-B)	;Displaced array, pretend type is Q
       (NO-OP)

SINFSA-1B
	(POPJ-AFTER-NEXT (M-B) ADD M-B (A-CONSTANT 37))
       ((M-4) (BYTE-FIELD 19. 5) M-B)

SINFSA-2B
	(POPJ-AFTER-NEXT (M-B) ADD M-B (A-CONSTANT 17))
       ((M-4) (BYTE-FIELD 20. 4) M-B)

SINFSA-4B
	(POPJ-AFTER-NEXT (M-B) ADD M-B (A-CONSTANT 7))
       ((M-4) (BYTE-FIELD 21. 3) M-B)

SINFSA-8B
	(POPJ-AFTER-NEXT (M-B) ADD M-B (A-CONSTANT 3))
       ((M-4) (BYTE-FIELD 22. 2) M-B)

SINFSA-16B
	(POPJ-AFTER-NEXT (M-B) ADD M-B (A-CONSTANT 1))
       ((M-4) (BYTE-FIELD 23. 1) M-B)

SINFSA-32B
	(POPJ-AFTER-NEXT NO-OP)
       ((M-4) M-B)

;;; PDL's have the magic feature that stuff after the pdl pointer is not looked at
;;; Element 0 of a pdl's array leader is its stack group
;;; We have already counted whole size of pdl into M-3, still have to get A-SINF-PAD.
SINF-REGPDL
	(JUMP-XCT-NEXT SINF-PDL)
       ((M-A) (A-CONSTANT (EVAL (+ 2 SG-PDL-PDL-POINTER))))

SINF-BNDPDL
	((M-A) (A-CONSTANT (EVAL (+ 2 SG-LB-PDL-POINTER))))
SINF-PDL
	((VMA-START-READ) SUB VMA (A-CONSTANT 2))	;Get stack-group which owns pdl
	(CHECK-PAGE-READ)
	((A-SINF-PDL-BASE) A-SCAV-PDL-BASE)	;Remember that this is a pdl
	(CALL-XCT-NEXT SINF-TRANS)		;That might have been an oldspace ptr, so
       ((VMA-START-READ) MD)			; check header of stack-group for gc-fwd
;*** Next two instructions don't work due to bugs fixed in the next cold-load.
;	((M-TEM) Q-TYPED-POINTER VMA)		;Owning stack group
;	(JUMP-EQUAL M-TEM A-QCSTKG SINF-OWN-PDL) ;Currently running, ptr in different place
	((M-TEM) XOR VMA A-QCSTKG)
	((M-TEM) Q-POINTER M-TEM)
	(JUMP-EQUAL M-TEM A-ZERO SINF-OWN-PDL)
SINF-NOT-OWN-PDL
	((VMA-START-READ) SUB VMA A-A)		;Get appropriate pdl pointer out of sg
	(CHECK-PAGE-READ)
	;; This looks like it could be bummed, but note that pdl-ptrs can be -1
	((M-TEM) ADD READ-MEMORY-DATA (A-CONSTANT 1))	;Index of lowest invalid location
	(POPJ-AFTER-NEXT 
	 (M-TEM) Q-POINTER M-TEM)		;Clear carry
       ((A-SINF-PAD) SUB M-B A-TEM)		;Rest of array is to be skipped

SINF-OWN-PDL
	;; If in middle of switching stack groups, pdl pointers in machine are not valid.
	;; We must have been called from the transporter, and this must be the sg we're
	;; switching to, since the one we're switching from cannot be in oldspace.
	(JUMP-IF-BIT-SET M-STACK-GROUP-SWITCH-FLAG SINF-NOT-OWN-PDL)
	;; If not switching stack groups, and this is the current stack group,
	;; use the pdl pointers in the machine rather than those in memory.
	(JUMP-EQUAL M-A (A-CONSTANT (EVAL (+ 2 SG-LB-PDL-POINTER))) SINF-OWN-BND-PDL)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER A-PDL-BUFFER-HEAD) ;mod-2000 arithmetic
	((M-TEM) ADD PDL-BUFFER-INDEX A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(POPJ-AFTER-NEXT (M-TEM) SUB M-TEM A-QLPDLO)	;relative pdl ptr
       ((A-SINF-PAD) M-A-1 M-B A-TEM)		;Rest of array is to be skipped

SINF-OWN-BND-PDL
	((M-TEM) A-QLBNDP)
	(POPJ-AFTER-NEXT (M-TEM) SUB M-TEM A-QLBNDO)	;relative pdl ptr
       ((A-SINF-PAD) M-A-1 M-B A-TEM)		;Rest of array is to be skipped

(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-SINFSA
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY TYPE 0 NOT USED
	(INHIBIT-XCT-NEXT-BIT SINFSA-1B)	;BIT ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-2B)	;2 BIT ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-4B)	;4 BIT ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-8B)	;8 BIT ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-16B)	;16 BIT ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-32B)	;32 BIT ARRAY
	(R-BIT)					;Q ARRAY
	(R-BIT)					;LIST Q ARRAY
	(INHIBIT-XCT-NEXT-BIT SINFSA-8B)	;STRING ARRAY
	(R-BIT)					;STACK-GROUP HEAD
	(SINF-BNDPDL)				;BINDING-PDL
	(INHIBIT-XCT-NEXT-BIT SINFSA-32B)	;TV BUFFER
	(SINF-REGPDL)				;REG-PDL
	(INHIBIT-XCT-NEXT-BIT SINFSA-32B)	;TV-BUFFER-PIXEL 
 (REPEAT NATUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; These are macrocode interfaces to STRUCTURE-INFO
XSBOXSZ (MISC-INST-ENTRY %STRUCTURE-BOXED-SIZE)
	(CALL XFSL)				;Fix bug if given an array with a leader
	(CALL-XCT-NEXT STRUCTURE-INFO)
       ((MD) Q-POINTER M-T)
	((VMA) SETZ)				;Clear possible garbage in VMA
	(POPJ-AFTER-NEXT (M-3) SUB M-3 A-SINF-PAD) ;Don't count garbage off end of pdl as boxed
       ((M-T) Q-POINTER M-3 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XSTOTSZ (MISC-INST-ENTRY %STRUCTURE-TOTAL-SIZE)
	(CALL XFSL)				;Fix bug if given an array with a leader
	(CALL-XCT-NEXT STRUCTURE-INFO)
       ((MD) Q-POINTER M-T)
	((VMA) SETZ)				;Clear possible garbage in VMA
	(POPJ-AFTER-NEXT (M-3) ADD M-3 A-4)
       ((M-T) Q-POINTER M-3 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;;; FLIPPER

;%GC-FLIP region.  Flips specified region, converting newspace to oldspace.
; Then goes over everything in the machine and makes sure it
; doesn't point to old-space.  If the region is T, all newspace and copyspace regions
; are done.
; Usually reclaim oldspace at some point before calling this function.
; To do a list of areas, just apply this to their regions one at a time, paying
; the penalty of extra checking of stuff in the machine for old-space-ptr;
; this is necessary due to problems with transporting of a list argument
; to this function, and anyway makes the microcode simpler.
XFLIP (MISC-INST-ENTRY %GC-FLIP)
	((A-GC-FLIP-READY) A-V-NIL)		;Due to creation of new old-space regions
	((A-CONS-WORK-DONE) SETZ)		;Reset work counters and make them equal
	((A-SCAV-WORK-DONE) SETZ)
	((M-K) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;Region spec
	((M-TEM) Q-DATA-TYPE M-K)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-FIX)) XFLIP4) ;Single region
	;Do all areas.  We do this by looking through the region-tables
	;for new-space and copy-space, since all REGION-BITS slots are guaranteed filled-in,
	;while the area tables are less structured.
	((M-K) (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS)))
XFLIP1	((VMA-START-READ) ADD M-K A-V-REGION-BITS)
	(CHECK-PAGE-READ)
	((M-TEM) (LISP-BYTE %%REGION-SPACE-TYPE) READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL %REGION-SPACE-NEW)) XFLIP3)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL %REGION-SPACE-COPY)) XFLIP3)
XFLIP2	(JUMP-GREATER-THAN-XCT-NEXT M-K A-ZERO XFLIP1)
       ((M-K) SUB M-K (A-CONSTANT 1))
;Having done the flipping, now get rid of all pointers to old-space in the machine.
;"The machine" is M-ZR through M-K, A-VERSION through A-END-Q-POINTERS, pdl buffer,
;A-PDL-BUFFER-VIRTUAL-ADDRESS, A-QLBNDO, etc.
;In order to avoid bugs with storing GC-FORWARDING pointers into the pdl buffer
;and the like, we use the stack-group-switch mechanism to save the state of the machine
;then load it back with transporting.
XFLIPW	(CALL-XCT-NEXT SGLV)		;Save state, don't swap variables
       ((M-TEM) DPB (M-CONSTANT -1) (BYTE-FIELD 1 6) A-SG-STATE)
;Now transport the magic A-memory variables, which constitute the root of the world.
	((VMA) (A-CONSTANT (EVAL (+ 400 %SYS-COM-TEMPORARY)))) ;Pretend was read from here
	((M-E) (A-CONSTANT (A-MEM-LOC A-VERSION)))
XFLIPW2	((OA-REG-HIGH) DPB M-E OAH-A-SRC A-ZERO)
	((MD) A-GARBAGE)		;A-GARBAGE IS LOCATION 0@A
	(DISPATCH TRANSPORT-AC MD)
	((OA-REG-LOW) DPB M-E OAL-A-DEST A-ZERO)
	((A-GARBAGE) MD)
	(JUMP-NOT-EQUAL-XCT-NEXT M-E (A-CONSTANT (A-MEM-LOC A-END-Q-POINTERS)) XFLIPW2)
       ((M-E) ADD M-E (A-CONSTANT 1))
;Now restore the stack-group, which got copied back there someplace.
	(CALL SGENT)			;Restore state
	(POPJ-AFTER-NEXT (A-SG-STATE)	;Leave A-SG-STATE unchanged
		DPB M-TEM (LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
       ((M-T) A-V-NIL)

XFLIP3	(JUMP-XCT-NEXT XFLIP2)
       (CALL XFLIP5)

XFLIP4	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XFLIPW)))
	((VMA-START-READ) ADD M-K A-V-REGION-BITS)
	(CHECK-PAGE-READ)
XFLIP5	((M-TEM) (A-CONSTANT (EVAL %REGION-SPACE-OLD)))	;Change to oldspace, clear meta bit,
	((A-TEM1) ANDCA MD				; and clear scavenge-enable
		(A-CONSTANT (PLUS (BYTE-MASK %%REGION-OLDSPACE-META-BIT)
				  (BYTE-MASK %%REGION-SCAVENGE-ENABLE))))
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-TEM (LISP-BYTE %%REGION-SPACE-TYPE) A-TEM1)
	(CHECK-PAGE-WRITE)
	(JUMP-XCT-NEXT UPDATE-REGION-PHT)	;Fix map, page table
       ((M-D) A-V-NIL)				;Don't change swap-status

;;; BRANCH INSTRUCTION

QIBRN	(DISPATCH-XCT-NEXT M-INST-DEST BRDTAB)	;DISP ON BRANCH TYPE
       ((M-B) M-INST-ADR-*2+X)			;M-B = OFFSET IN BYTES, LOW BIT INDETERMINATE
						;NOTE THAT THE LC HARDWARE IGNORES THE LOW BIT
						;AND READS IT BACK AS ZERO IN HALFWORD MODE

;HERE WHEN YOU'VE DECIDED TO BRANCH
QBRALW	(CALL-IF-BIT-SET (BYTE-FIELD 1 9) M-B QBRLZ1)  ;EXTEND SIGN IF NECESSARY
QBRLZ2	(POPJ-AFTER-NEXT			;NOTE, MUST CHANGE LC IN SAME CYCLE AS POPJ
	  (LOCATION-COUNTER) ADD LOCATION-COUNTER A-B)
       (NO-OP)					;THIS CYCLE DOES VMA<-LC, START-READ

;BRANCH DELTA NEGATIVE
QBRLZ1	(POPJ-LESS-THAN-XCT-NEXT M-B (A-CONSTANT 1776))	;RETURN TO QBRLZ2 UNLESS LONG BRANCH
       ((M-B) SELECTIVE-DEPOSIT (M-CONSTANT -1)
		(BYTE-FIELD 22. 10.) A-B)	;EXTEND SIGN
;DOUBLE-LENGTH BRANCH, LONG OFFSET IS IN SECOND HALFWORD
	(DISPATCH ADVANCE-INSTRUCTION-STREAM)
	((M-B) (BYTE-FIELD 17. 37) ;SAME TRICK AS WITH M-INST-ADR-*2+X. 
			M-INST-BUFFER INSTRUCTION-STREAM)
	(POPJ-AFTER-NEXT			;RETURN TO QBRLZ2, XCT NEXT IF EXTEND SIGN
	  POPJ-IF-BIT-CLEAR (BYTE-FIELD 1 16.) M-B)
       ((M-B) SELECTIVE-DEPOSIT (M-CONSTANT -1)
		(BYTE-FIELD 15. 17.) A-B)

QBRNL	((M-K) Q-TYPED-POINTER M-T)		;BRANCH ON NIL
	(JUMP-EQUAL M-K A-V-NIL QBRALW)

;HERE WHEN YOU'VE DECIDED NOT TO BRANCH
QBRNOT	(POPJ-LESS-THAN M-B (A-CONSTANT 1776))	;CHECK FOR DOUBLE LENGTH INSTRUCTION
	(DISPATCH ADVANCE-INSTRUCTION-STREAM)
	(POPJ)

QBRNNL	((M-K) Q-TYPED-POINTER M-T)		;BRANCH ON NOT NIL
	(JUMP-NOT-EQUAL M-K A-V-NIL QBRALW)
	(POPJ-LESS-THAN M-B (A-CONSTANT 1776))	;CHECK FOR DOUBLE LENGTH INSTRUCTION
	(DISPATCH ADVANCE-INSTRUCTION-STREAM)   ;DUPLICATED AS MINOR SPEED BUM.
	(POPJ)

QBRAT	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)	;BRANCH ON ATOM
	 (JUMP QBRNOT)
	(JUMP QBRALW)

QBRNAT	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)	;BRANCH ON NOT-ATOM
	 (JUMP QBRALW)
	(JUMP QBRNOT)

QBRNLP	((M-K) Q-TYPED-POINTER M-T)		;BR NIL, POP IF NOT
	(JUMP-EQUAL M-K A-V-NIL QBRALW)
	(JUMP-XCT-NEXT QBRNOT)
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

QBRNNP	((M-K) Q-TYPED-POINTER M-T)		;BR NOT NIL, POP IF
	(JUMP-NOT-EQUAL M-K A-V-NIL QBRALW)
	(JUMP-XCT-NEXT QBRNOT)
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

;;; NON-DESTINATION GROUP 1
;   E IN VMA, C(E) IN M-T, MOSTLY EXIT BY PUTTING RESULT ON STACK

;GET TWO PDL ARGUMENTS, FIRST TO M-1, SECOND TO M-2
FXGTPP	((M-T) C-PDL-BUFFER-POINTER-POP)	;GET 2ND ARG, DROP THROUGH

;GET ADDR ARG IN M-2, PDL ARG IN M-1, ERROR UNLESS BOTH FIXNUMS
FIXGET	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		;GET PDL ARG
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE M-T TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM M-T 1)
FIXGET-1
	((OA-REG-HIGH) BOXED-SIGN-BIT M-T)		;SIGN EXTEND (MUNG M SOURCE)
	((M-2) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-T)
	(POPJ-AFTER-NEXT
	 (OA-REG-HIGH) BOXED-SIGN-BIT M-1)		;SIGN EXTEND
       ((M-1) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-1)

;;; Numeric instructions are with all of the other numeric code.

;FIXNUM EXPONENTIATION ROUTINE.
;M-3 HOLDS THE EXPONENT, AND GETS SHIFTED AND TESTED.
;M-1 HOLDS THE FIRST ARG, SQUARED N TIMES.
;M-T HOLDS THE PARTIAL PRODUCTS

XUPARROW (MISC-INST-ENTRY ^)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 1))	;POINT TO FIRST ARG
	((M-1) SELECTIVE-DEPOSIT C-PDL-BUFFER-INDEX Q-DATA-TYPE A-ZERO)
							;GET DATA TYPE OF BASE
	(JUMP-NOT-EQUAL M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) XUPOUT)
							;NOT FIXNUM TRAPS TO MACRO CODE
	((M-1) SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER Q-DATA-TYPE A-ZERO) ;DITTO FOR EXPONENT
	(JUMP-NOT-EQUAL M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) XUPOUT)
	((M-T) C-PDL-BUFFER-POINTER)			;THE EXPONENT
	(CALL-XCT-NEXT FIXGET-1)			;UNPACK THE FIXNUMS
       ((M-1) C-PDL-BUFFER-INDEX)			;AND THE BASE
	(JUMP-LESS-THAN M-2 A-ZERO XUP6)		;FIXNUM ^ -<FIXNUM> = 0 USUALLY
	((M-TEM) (A-CONSTANT 1))			;INITIALIZE RESULT
	(JUMP-EQUAL M-2 A-ZERO XUP4)			;ANYTHING ^ 0 = 1
	((M-3) M-2)					;SAVE THE EXPONENT
XUP1	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-3 XUP2)
	(CALL-XCT-NEXT MPY)				;M-1 TIMES M-TEM TO Q-R
       ((Q-R) M-TEM)
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
							;M-TEM IS 32 BITS, BUT FIXED BIN(23,0)
	(JUMP-EQUAL-XCT-NEXT M-2 A-ZERO XUP2)		;JUMP IF POSITIVE NO OVERFLOW
       ((M-TEM) Q-R)					;PRODUCT BACK TO M-TEM
	(JUMP-NOT-EQUAL M-2 (A-CONSTANT -1) XUPOUT)	;DROP THROUGH IF OK NEG, ELSE OVFL
XUP2	((M-3) M-3 OUTPUT-SELECTOR-RIGHTSHIFT-1)	;(SETQ M-3 (ASH M-3 -1))
	(JUMP-EQUAL M-3 A-ZERO XUP4)			;IF ZERO, RESULT IS IN M-TEM
	(CALL-XCT-NEXT MPY)				;OTHERWISE COMPUTE NEXT POWER
       ((Q-R) M-1)					;I.E. Q-R GETS M-1 TIMES M-1
	((M-2) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
	(JUMP-NOT-EQUAL M-2 A-ZERO XUPOUT)		;OVERFLOW (RESULT IS ALWAYS POSITIVE)
	(JUMP-XCT-NEXT XUP1)
       ((M-1) Q-R)					;(SETQ M-1 (* M-1 M-1))

;;; RESULT IS 0 UNLESS BASE (M-1) IS 0, -1, OR 1
XUP6	((M-TEM) M-ZERO)				;Return zero perhaps
	(JUMP-GREATER-THAN M-1 (A-CONSTANT 1) XUP4)
	(JUMP-LESS-THAN M-1 (A-CONSTANT -1) XUP4)
	(CALL-EQUAL M-1 (A-CONSTANT 0) TRAP)		;0 ^ negative power is an error
	    (ERROR-TABLE DIVIDE-BY-ZERO)
	((M-TEM) M-1)
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-2 XUP4)	;-1 ^ odd negative power is -1
	((M-TEM) (A-CONSTANT 1))			;-1 ^ even negative power is 1
	;drop into XUP4
;;; RETURN VALUE IN M-TEM AND POP OFF ARGUMENTS
XUP4	(POPJ-AFTER-NEXT (PDL-BUFFER-POINTER) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))
       ((M-T) DPB M-TEM Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;;; HERE CALL OUT TO MACRO CODE
XUPOUT	((M-A) C-PDL-BUFFER-POINTER-POP)		;SAVE THE EXPONENT
	((M-B) C-PDL-BUFFER-POINTER-POP)		;SAVE THE BASE
	((M-1) M-INST-DEST)				;GET THE MISC DEST
	(CALL-XCT-NEXT MMASU1)				;PUSH FAKE MACRO-TO-MACRO CALL
       ((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LP-CLS WORD
	      DPB M-1 (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION)
		      (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((ARG-CALL REF-SUPPORT-VECTOR) (I-ARG SVCEXPT))	;GET FCTN CELL OF EXPT-HELP
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;PUSH FUNCTION CELL
	((C-PDL-BUFFER-POINTER-PUSH) M-B)		;PUSH THE BASE
	((C-PDL-BUFFER-POINTER-PUSH) M-A)		;PUSH THE EXPONENT
	((M-GARBAGE) MICRO-STACK-DATA-POP)		;FLUSH RETURN TO MISC+6
	(JUMP QMRCL)

(ASSIGN SVCEXPT 6)	      ;CALL OUT FOR EXPT

;;; NON-DESTINATION-GROUP-2
;   E IN VMA, C(E) IN M-T

;THESE COMPARE C(E) TO TOP OF STACK, POP,
; AND LEAVE T OR NIL IN M-T IN LIEUE OF SETTING INDICATORS

XMEQ (MISC-INST-ENTRY M-EQ)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIEQ	((M-2) Q-TYPED-POINTER M-T)
	((M-1) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL M-1 A-2 XFALSE)
  (MISC-INST-ENTRY TRUE)
XTRUE	(POPJ-AFTER-NEXT (M-T) A-V-TRUE)
       (NO-OP)

;Numeric comparisons are off with the rest of the numeric stuff.
;THESE MODIFY THE CONTENTS OF THEIR EFFECTIVE ADDRESS

QISCDDR	(JUMP-XCT-NEXT STOCYC)
       (CALL QMDD)		;CDDR THE ARGUMENT

QISCDR	(JUMP-XCT-NEXT STOCYC)
       (CALL QMD)		;CDR THE ARGUMENT

QISM1	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;NO PASS-AROUND PATH ON PDL BUFFER
	(JUMP-XCT-NEXT STOCYC)			;STORES BACK WITH NO ASSUMPTIONS ABOUT VMA
       (CALL X1MNS)				;M-T GETS (1- PDL)
	
QISP1	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;NO PASS-AROUND PATH ON PDL BUFFER
	(JUMP-XCT-NEXT STOCYC)			;STORES BACK WITH NO ASSUMPTIONS ABOUT VMA
       (CALL X1PLS)				;M-T GETS (1+ PDL)

;;; NON-DESTINATION-GROUP-3
;   EFFECTIVE ADDRESS NOT YET COMPUTED, M-T NOT VALID.

QIPOP	(JUMP-XCT-NEXT STOCYC)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QIPSHE	(DISPATCH-XCT-NEXT M-INST-REGISTER QADCM3)	;EFF ADR TO PDL AND POPJ
       ((M-1) M-INST-DELTA)

QISETN	(JUMP-XCT-NEXT STOCYC)
       ((M-T) A-V-NIL)

QISETZ	(JUMP-XCT-NEXT STOCYC)
       ((M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

QIBNDN	(CALL QBND1)		;SAVE PRESENT BINDING
	((M-T) A-V-NIL)		;AND RE-BIND TO NIL
QIBDN1	((VMA-START-READ) DPB M-B Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)  ;CHASE FORWARDING PTR IF ANY
	((M-T WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT M-E
		Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

QIBNDP	(CALL QBND1)		;SAVE PRESENT BINDING
	(JUMP-XCT-NEXT QIBDN1)	;AND REBIND TO POP(PDL)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

XBIND (MISC-INST-ENTRY BIND)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;ARG 2, NEW VALUE TO GIVE
   (ERROR-TABLE RESTART XBIND)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER)	;ARG 1, POINTER TO CELL TO BIND
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) TRAP)
   (ERROR-TABLE ARGTYP LOCATIVE PP 0 XBIND)
XBIND1	(JUMP-XCT-NEXT QIBDN1)
       (CALL QBND2)

QIBND 				;SAVE CURRENT CONTENTS, DON'T CHANGE
				;LEAVE M-E SET TO OLD CONTENTS (MAINLY FOR CDR CODE)
QBND1	(DISPATCH-CALL-XCT-NEXT M-INST-REGISTER QADCM6)	;EFF ADR TO PDL
       ((M-1) M-INST-DELTA)
QBND2	((M-1) ADD (M-CONSTANT 23.) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 TRAP)  ;RESULT HAD BETTER BE NEGATIVE
   (ERROR-TABLE PDL-OVERFLOW SPECIAL)			 ; (AS 24 BIT QUANTITY).
	((VMA-START-READ M-B) C-PDL-BUFFER-POINTER-POP)	;FETCH CURRENT CONTENTS
	(CHECK-PAGE-READ)				;INT OK, HAVEN'T HACKED YET
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;DON'T FOLLOW EXTERNAL-VALUE-CELL-PTR
;LOGICALLY SIMILAR CODE TO BELOW EXISTS AT QBSPCL
;	((M-B) VMA)	;THIS INSTRUCTION WOULD MAKE IT FOLLOW FORWARDING POINTERS
;			;AND BIND THAT FINALLY POINTED-TO CELL RATHER THAN THE
;			;INTERNAL VALUE CELL.
	;M-E can be an invisible pointer, so don't save typed pointer part.
	((M-E) SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	((M-1 WRITE-MEMORY-DATA) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL QBND3)	 ;JUMP IF NOT FIRST IN BLOCK
       ((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE) ;ADVANCE BINDING PDL PNTR
	((WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-1)
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
QBND3	((VMA-START-WRITE) A-QLBNDP)		;STORE PREV CONTENTS
	(CHECK-PAGE-WRITE)			;HAVE INCRD A-QLBNDP, NO SEQ BRK
	((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) M-B)		;LOCATIVE PNTR TO BOUND LOCN
	((VMA-START-WRITE) A-QLBNDP)		;STORE POINTER TO BOUND CELL
	(CHECK-PAGE-WRITE)			;NO SEQ BRK, BIND NOT REALLY FINISHED
	(POPJ)		;NOTE, POPJ MUST BE DELAYED BECAUSE CANNOT START WRITE
			;AND INSTRUCTION FETCH SIMULTANEOUSLY.

;SPECIAL KLUDGEY ADDRESS ROUTINE FOR BIND.  ALWAYS INDIRECTS ONE LEVEL.
;RETURNS WITH ADDRESS ON PDL.
QBAFE	((M-1) M-INST-ADR)			;FULL DELTA
	((PDL-BUFFER-INDEX) M-AP)		;0(AP) -> FEF
	((VMA-START-READ) ADD C-PDL-BUFFER-INDEX A-1)
	(CHECK-PAGE-READ)  
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;ONLY TRANSPORT, DON'T DO INVZ
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)	;MAKE SURE IT WAS AN EVCP
	(POPJ-AFTER-NEXT			;AND RETURN LOCATIVE ON PDL
	 (C-PDL-BUFFER-POINTER-PUSH) DPB READ-MEMORY-DATA
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-EXTERNAL-VALUE-CELL-POINTER)) ILLOP)

;;; DESTINATION HANDLERS
;   DATA TO STORE IN M-T

;THESE DESTINATIONS ARE NOW HANDLED BY THE INSTRUCTION FOLLOWING THE DESTINATION DISPATCH
;QMDDNQ		;NEXT (ARG), QUOTED
;QMDDN		;NEXT (ARG)
;QMDDS		;STACK

;DESTINATION NEXT-LIST
QMDDNL	((VMA-START-READ) C-PDL-BUFFER-POINTER)	;PTR TO NEXT PLACE IN LIST
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE)	;GET RANDOM BITS FROM PLACE STORING TO
	    SELECTIVE-DEPOSIT READ-MEMORY-DATA
		Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(GC-WRITE-TEST)
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;CDR TO NEXT PLACE IN LIST
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-ATOM)
	(POPJ-AFTER-NEXT			;NOT THROUGH WITH LIST
	 (C-PDL-BUFFER-POINTER-PUSH) M-T)
	(NO-OP)
	((M-C) C-PDL-BUFFER-POINTER-POP)	;THROUGH, GET ORIGINAL DESTINATION
	(JUMP-XCT-NEXT QIMOVE-EXIT)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;POINTER TO HEAD OF LIST

;;; DESTINATION LAST

QMDDLQ		;LAST, QUOTED
QMDDL	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))

;;;ACTIVATE PENDING CALL
QMRCL	((M-K) SUB PDL-BUFFER-POINTER A-IPMARK)	;COUNT ARGUMENTS
	((A-NARGS) (BYTE-FIELD 7 0) M-K)
	((PDL-BUFFER-INDEX M-S) A-IPMARK)	;GET FEF POINTER POINTER
	((M-A) C-PDL-BUFFER-INDEX)		;M-A := FUNCTION TO CALL
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;DISPATCH ON DATA TYPE
       (CALL QLLV)				;DOES LINEAR LEAVE IF NECC.

;CONVERT PDL BUFFER ADDRESS IN M-K TO VIRTUAL ADDRESS IN M-K WITH LOCATIVE
; DATA-TYPE.  ANY REFERENCE VIRTUAL ADDRESS WHICH MAY BE IN PDL-BUFFER WILL TRAP,
; AND PAGE FAULT HANDLER WILL FIGURE OUT WHAT TO DO.

CONVERT-PDL-BUFFER-ADDRESS	
	((M-K) SUB M-K A-PDL-BUFFER-HEAD)
	(POPJ-AFTER-NEXT 
	 (M-K) DPB M-K (BYTE-FIELD 10. 0)	;ASSURE POSITIVE OFFSET IN CASE OF WRAPAROUND
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       ((M-K) ADD M-K A-PDL-BUFFER-VIRTUAL-ADDRESS)

; CONVERT VIRTUAL ADDRESS IN M-K INTO PDL-BUFFER-INDEX (ASSUMING IT REFERENCES THE CURRENT
;STACK GROUP).  NOTE THIS DOES NOT ASSURE THAT SECTION OF PDL SWAPPED IN OR ANYTHING.
;IF AND WHEN IT IS SWAPPED IN, HOWEVER, IT WILL OCUPPY THE INDICATED PDL-BUFFER ADDRESS.

GET-PDL-BUFFER-INDEX
	((M-K) SUB M-K A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(POPJ-AFTER-NEXT 
	 (M-K) ADD M-K A-PDL-BUFFER-HEAD)
       ((M-K) (BYTE-FIELD 10. 0) M-K)

;TAKE INTERPRETER TRAP

INTP1	((PDL-BUFFER-INDEX) SUB M-S A-AP)	;Increment to M-AP (truncated to 10 bits)
	((M-PDL-BUFFER-ACTIVE-QS) ADD PDL-BUFFER-INDEX A-PDL-BUFFER-ACTIVE-QS)
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
       ((M-AP) M-S)
	((M-TEM) A-NARGS)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((C-PDL-BUFFER-INDEX) DPB M-TEM (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP-EQUAL A-NARGS M-ZERO INTP1A)	;NO ARGS
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;TO VIRTUAL ADDRESS
       ((M-K) ADD A-ZERO M-AP ALU-CARRY-IN-ONE)	;RETURN RESULT IN M-K WITH NO GARBAGE 
	((M-T) DPB M-K Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))	;ARG LIST PTR
INTP1B	((PDL-BUFFER-INDEX) ADD (A-CONSTANT (EVAL %LP-CALL-STATE)) M-AP)
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX INTP5)
							;DUMMY UP ADDTL INFO
INTP5R1	(CALL P3ZERO)
INTP5R	((ARG-CALL REF-SUPPORT-VECTOR) (I-ARG SVCAPL))	;GET FTCN CELL OF APPLY-LAMBDA
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;PUSH IT
	((PDL-BUFFER-INDEX) M-AP)
	((C-PDL-BUFFER-POINTER-PUSH) DPB C-PDL-BUFFER-INDEX ;ARG 1 = FCN BEING CALLED
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T		 ;ARG 2 = ARG LIST
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	((ARG-CALL MMCALL) (I-ARG 2))
INTRET	(JUMP QMDDR0)

INTP1A	(JUMP-XCT-NEXT INTP1B)
       ((M-T) A-V-NIL)			;ARG LIST IS NIL

;SENDING ADI CALL TO INTERPRETER.. LOOK AT ADI AND MAYBE HACK...
INTP5	((PDL-BUFFER-INDEX M-R) SUB M-S (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	((M-A) SETZ A-ZERO M-ZERO)	;M-A HAS 0 OR BFLAG, AS APPRO TO IOR WITH
					;ANY ADI PUSHED. IN NON-ZERO AT END, SOME ADI
					;HAS BEEN PUSHED.
	((M-B) PDL-BUFFER-POINTER)	;SAVE STACK POSITION OF LAST ARG (SEE INTP20)
INTP6	(DISPATCH (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX
			INTP-ADI-DISPATCH)
(LOCALITY D-MEM)
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)
INTP-ADI-DISPATCH
	(P-BIT ILLOP)	;ERR
	(INTP10)	;MULTIPLE-VALUE-RETURN
	(INTP7)		;RESTART-PC
	(INTP20)	;FEXPR CALL
	(INTP20)	;LEXPR CALL
  (REPEAT 3 (P-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

INTP7	((PDL-BUFFER-INDEX M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX INTP9)
	(JUMP-XCT-NEXT INTP6)
       ((PDL-BUFFER-INDEX M-R) SUB M-R (A-CONSTANT 1))

INTP10	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;FOUND VALUE RETURNNING ADI
       ((M-K) M-R)					;PUSH INDIRECT POINTER TO IT
	((C-PDL-BUFFER-POINTER-PUSH) IOR A-A M-K)
	((M-A) DPB (M-CONSTANT -1) Q-FLAG-BIT A-ZERO)   ;ADI FROM NOW ON HAS THIS BIT ON.
	(JUMP-XCT-NEXT INTP7)
       ((C-PDL-BUFFER-POINTER-PUSH) IOR M-A (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%ADI-TYPE (EVAL ADI-RETURN-INFO)))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION (EVAL ADI-ST-INDIRECT)))))

INTP20	((M-1) A-NARGS)		;HERE IF LAST SLOT HAS REST ARG.
	((PDL-BUFFER-INDEX) M-B)	;SAVED PDL POSITION OF LAST ARG
	(JUMP-GREATER-THAN M-1 (A-CONSTANT 1) INTP21)
	(JUMP-XCT-NEXT INTP7)	;FIRST (AND LAST) SLOT IS ALREADY LIST OF ARGS
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX) ;SO REPLACE LIST-OF-ARGS POINTER WITH IT.

;GET HERE IF FCTN WAS CALLED WITH BOTH SPREAD AND REST ARGS.  MUNGE CDR CODES
; OF LAST SPREAD ARG AND THE REST ARG TO FULL-NODE, THUS NCONC ING THEM TOGETHER.
INTP21	((C-PDL-BUFFER-INDEX) DPB C-PDL-BUFFER-INDEX Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-ERROR)))		;REST ARG
	((PDL-BUFFER-INDEX) SUB M-B (A-CONSTANT 1))		;TO POINT TO LAST SPREAD ARG
	(JUMP-XCT-NEXT INTP7)
       ((C-PDL-BUFFER-INDEX) DPB C-PDL-BUFFER-INDEX Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NORMAL)))

INTP9	(JUMP-EQUAL M-A A-ZERO INTP5R1)	;NO ADI PUSHED, IGNORE THE WHOLE THING
	(CALL UAPLY4)		;LIKE P3ZERO, BUT SET LPADL BIT
	(JUMP INTP5R)

REF-SUPPORT-VECTOR	
	((VMA-START-READ) ADD READ-I-ARG A-V-SUPPORT-ENTRY-VECTOR)
	(CHECK-PAGE-READ)
	(POPJ)

(ASSIGN SVCAPL 3)	;APPLY-LAMBDA

;CALLING NUMBER AS FUNCTION
NUMBER-CALLED-AS-FUNCTION
	(CALL TRAP)
    (ERROR-TABLE NUMBER-CALLED-AS-FUNCTION M-A)

;CALLING SYMBOL AS FUNCTION
QMRCL1	((VMA-START-READ) ADD M-A		;GET FUNCTION CELL
		(A-CONSTANT 2))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-TEM) SUB MICRO-STACK-PNTR-AND-DATA-POP
		(A-CONSTANT 1))			;LOW 14 BITS GET ADDRESS OF QMRCL DISPATCHER
	((OA-REG-LOW) DPB M-TEM OAL-JUMP A-ZERO)
	(JUMP-XCT-NEXT 0)				;UNSKIP AND REDISPATCH
       ((C-PDL-BUFFER-INDEX M-A) READ-MEMORY-DATA)	;STORE NEW FROB TO CALL

;CALLING ENTITY AS FUNCTION.  BIND SELF THEN TURN INTO CLOSURE CALL.
;DON'T CALL QBND2 TO AVOID REFERENCING A-SELF VIA SLOW VIRTUAL-MEMORY PATH
CALL-ENTITY
	((M-TEM) ADD (M-CONSTANT 23.) A-QLBNDP)
	((M-TEM) SUB M-TEM A-QLBNDH)
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-TEM TRAP)
	    (ERROR-TABLE PDL-OVERFLOW SPECIAL)
	((M-TEM WRITE-MEMORY-DATA) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-SELF)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL CALL-ENTITY-1)
       ((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-TEM) ;START NEW BINDING BLOCK
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
CALL-ENTITY-1
	((VMA-START-WRITE) A-QLBNDP)	;STORE PREVIOUS CONTENTS
	(CHECK-PAGE-WRITE)		;NO SEQ BRK HERE
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA)		;LOCATIVE POINTER TO BOUND LOCATION
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)
				  LOWEST-A-MEM-VIRTUAL-ADDRESS
				  (A-MEM-LOC A-SELF))))
	((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-METHOD-SUBROUTINE-POINTER)
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((VMA-START-WRITE) A-QLBNDP)	;STORE PREVIOUS CONTENTS
	(CHECK-PAGE-WRITE)		;NO SEQ BRK HERE
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA)		;LOCATIVE POINTER TO BOUND LOCATION
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)
				  LOWEST-A-MEM-VIRTUAL-ADDRESS
				  (A-MEM-LOC A-METHOD-SUBROUTINE-POINTER))))
	((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-METHOD-SEARCH-POINTER)
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((VMA-START-WRITE) A-QLBNDP)	;STORE PREVIOUS CONTENTS
	(CHECK-PAGE-WRITE)		;NO SEQ BRK HERE
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA)		;LOCATIVE POINTER TO BOUND LOCATION
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)
				  LOWEST-A-MEM-VIRTUAL-ADDRESS
				  (A-MEM-LOC A-METHOD-SEARCH-POINTER))))
	((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)
	((A-SELF) M-A)			;DROP INTO QCLS
;CALLING CLOSURE AS FUNCTION
QCLS	(CALL-XCT-NEXT QCAR)		;SEQ BRK IS OK HERE, ISNT IT?
       ((M-T C-PDL-BUFFER-POINTER-PUSH) M-A)
	((PDL-BUFFER-INDEX) M-S)
	((C-PDL-BUFFER-INDEX M-A) M-T)	;REPLACE CLOSURE WITH CLOSED FCTN
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)	;GET BACK CLOSURE AND CDR IT.
QCLS1	(JUMP-EQUAL M-T A-V-NIL QCLS2)
	(CALL-XCT-NEXT QCAR)
       ((M-D) M-T)
	((M-B) M-T)			;LOCN TO BIND
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-D)
	(CALL-XCT-NEXT QCAR)		;GET NEW BINDING
       ((M-D) M-T)
	((M-T) DPB M-T Q-POINTER        ;SWITCH DATA TYPE.. (DOING IT THIS WAY AVOIDS PROBLEMS
				        ;WITH CAR ABOVE AS WELL AS GENERALLY REDUCING 
					;PROFUSION OF FUNNY DATA TYPES)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTERNAL-VALUE-CELL-POINTER)))
	;; M-B has cell being bound, M-T has value it should be bound to
	((VMA-START-READ) M-B)		;Check current binding
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-T QCLS3)	;If already bound to correct external value cell,
					;avoid pushing a new binding.  This saves on special
					;pdl overflows in RMS's recursive closure-entity stuff.
	(CALL-XCT-NEXT QBND2)		;SAVE PREVIOUS BINDING
       ((C-PDL-BUFFER-POINTER-PUSH M-B) DPB M-B Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	((VMA-START-READ) M-B)		;READ OUT THE CELL BEING BOUND
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA 
		Q-ALL-BUT-TYPED-POINTER A-T)		;WRITE BACK NEW VALUE (AN EVCP)
	(CHECK-PAGE-WRITE)
QCLS3	(CALL-XCT-NEXT QCDR)
       ((M-T) M-D)
	(JUMP QCLS1)

QCLS2	((PDL-BUFFER-INDEX) M-S)
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)
       (NO-OP)			;LEAVE, IF ANY, ALREADY DONE

CALL-SELECT-METHOD
	(CALL-EQUAL M-ZERO A-NARGS TRAP)	;NOT ENUF ARGS
  (ERROR-TABLE ZERO-ARGS-TO-SELECT-METHOD M-A)
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT 1))  ;FETCH MESSAGE KEY
	((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	((M-B) A-V-NIL)		;HOLDS CONSTANT ON M-SIDE, FOR EASY COMPARISON
	((M-T) DPB M-A Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(JUMP-EQUAL M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)) CSM-R)  ;RESUME
	((A-METHOD-SUBROUTINE-POINTER) A-V-NIL) ;"SUBROUTINE" CONTINUATION POINT, 
						;  OR NIL IF AT TOP LEVEL.
CSM-3	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((M-ZR) Q-DATA-TYPE M-T)		;M-T HAS ASSQ-LIST ELEMENT
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) CSM-1)   ;NOT METHOD-KEY, METHOD PAIR
	(CALL-XCT-NEXT QCAR)
       ((M-J) M-T)
	(JUMP-EQUAL M-T A-C CSM-2)		;FOUND IT
	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) CSM-7)  ;ASSQ KEY A LIST, DO MEMQ ON IT
CSM-5	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)
	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) CSM-3)
	(JUMP-NOT-EQUAL M-B A-METHOD-SUBROUTINE-POINTER CSM-8A)   ;IF IN SUBROUTINE, RETURN.
	(JUMP-NOT-EQUAL M-T A-V-NIL CSM-6)   ;NON-NIL TERMINATION IS SUPERCLASS POINTER.
  ; USE IT TO REPLACE DTP-SELECT-METHOD AND REINVOKE. THE TWO COMMON CASES ARE (1) THIS SYMBOL
  ; IS A SUPERCLASS POINTER AND IT'S FUNCTION CELL CONTAINS A DTP-SELECT-METHOD.  THE SEARCH
  ; WILL CONTINUE. (2)  THIS SYMBOL IS A LISP FUNCTION AND WILL GET CALLED IN THE USUAL WAY.
  ; THIS SERVES AS AN "OTHERWISE" CLAUSE.
	(CALL TRAP)			;SELECTED METHOD NOT FOUND
  (ERROR-TABLE SELECTED-METHOD-NOT-FOUND M-A)

CSM-R	(JUMP-XCT-NEXT CSM-5)		    ;RESUME SEARCH AT SAVED POINT
       ((C-PDL-BUFFER-POINTER-PUSH) A-METHOD-SEARCH-POINTER)  ;PUT IT WHERE CSM-5 EXPECT IT.

CSM-7	((C-PDL-BUFFER-POINTER-PUSH) M-A)   ;ASSQ KEY A LIST, DO MEMQ ON IT
	(CALL-XCT-NEXT XMEMQ1)		    ; TAKES ARGS IN M-A, M-T
       ((M-A) M-C)
	(JUMP-EQUAL-XCT-NEXT M-T A-V-NIL CSM-5)
       ((M-A) C-PDL-BUFFER-POINTER-POP)    ;RESTORE M-A
CSM-2	((A-METHOD-SEARCH-POINTER) C-PDL-BUFFER-POINTER-POP) ;SAVE IN CASE METHOD SEARCH
							     ; IS RESUMED.
	(CALL-XCT-NEXT QCDR)		   ;FOUND DESIRED METHOD KEY.  GET ASSOC FCTN
       ((M-T) M-J)                         ; FROM ASSQ ELEMENT.
CSM-6	((PDL-BUFFER-INDEX) M-S)
	((C-PDL-BUFFER-INDEX M-A) SELECTIVE-DEPOSIT C-PDL-BUFFER-INDEX 	;CLOBBER INTO
		Q-ALL-BUT-TYPED-POINTER A-T)	; LP-FEF SLOT, REPLACING DTP-SELECT-METHOD
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)
       (NO-OP)

;GET HERE IF SELECT-METHOD LIST-ELEMENT NOT A CONS.
CSM-1	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) TRAP)
 (ERROR-TABLE SELECT-METHOD-GARBAGE-IN-SELECT-METHOD-LIST M-T)
   ;DO A ONE LEVEL "SUBROUTINE" CALL.  SAVE CONTINUATION POINTER IN M-B.
	(JUMP-NOT-EQUAL M-B A-METHOD-SUBROUTINE-POINTER CSM-8) ;ALREADY IN A SUBROUTINE, RETURN
	((A-METHOD-SUBROUTINE-POINTER) C-PDL-BUFFER-POINTER-POP)    ;SAVE CONTINUATION POINT.
	((VMA-START-READ) ADD M-T (A-CONSTANT 2))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) CSM-8A)  ;NO METHODS IN THIS CLASS,
								 ; IMMEDIATELY RETURN.
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SELECT-METHOD)) TRAP)
 (ERROR-TABLE SELECT-METHOD-BAD-SUBROUTINE-CALL)
	(JUMP-XCT-NEXT CSM-3)
       ((M-T) LDB Q-POINTER READ-MEMORY-DATA
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))

;HERE IF IN A SUBROUTINE, BUT DIDNT FIND IT.  RETURN FROM SUBROUTINE AND CONTINUE.
CSM-8	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)
CSM-8A	((C-PDL-BUFFER-POINTER-PUSH) A-METHOD-SUBROUTINE-POINTER)  ;PUT CONTINUATION
	(JUMP-XCT-NEXT CSM-5)				; WHERE IT IS EXPECTED.
       ((A-METHOD-SUBROUTINE-POINTER) A-V-NIL)		;AT TOP LEVEL AGAIN.

;;; STUFF FOR CALLS WITH NUMBER OF ARGUMENTS NOT KNOW AT COMPILE TIME

XOCB  (MISC-INST-ENTRY %OPEN-CALL-BLOCK)  ;<FCTN><ADI-PAIRS><DEST>
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL M-C (A-CONSTANT 4) XOCB0)	;NOT DEST RETURN D-RETURN
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-CLEAR C-PDL-BUFFER-INDEX (LISP-BYTE %%LP-CLS-ADI-PRESENT) XOCB0)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))	;RETURNS MEM-POINTER  IN M-K
	((C-PDL-BUFFER-POINTER-PUSH) M-K)		;STORE INDIRECT ADI POINTER
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%ADI-TYPE (EVAL ADI-RETURN-INFO )))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION (EVAL ADI-ST-INDIRECT)))))
	((M-A) ADD M-A (A-CONSTANT 1))			;ONE MORE ADI PAIR.
XOCB0	(JUMP-EQUAL M-A A-ZERO CBM0)		;IF NO ADI, PUSH REGULAR CALL BLOCK
	((PDL-BUFFER-INDEX M-K) PDL-BUFFER-POINTER)
	((M-A) ADD M-A A-A)			;2 QS PER ADI PAIR
XOCB1	((A-TEM1) C-PDL-BUFFER-INDEX)		;TO SAVE AN A-CONSTANT
	((C-PDL-BUFFER-INDEX) DPB (M-CONSTANT -1) Q-FLAG-BIT A-TEM1)
	((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
	(JUMP-NOT-EQUAL-XCT-NEXT M-A (A-CONSTANT 2) XOCB1)
       ((M-A) SUB M-A (A-CONSTANT 1))
	((A-TEM1) C-PDL-BUFFER-INDEX)		;TO SAVE AN A-CONSTANT
	(CALL-XCT-NEXT CBM0)		;PUT ON CALL BLOCK BUT TAKE DEST FROM M-C
       ((C-PDL-BUFFER-INDEX)		;CLEAR FLAG BIT IN LAST WD OF ADI
		DPB M-ZERO Q-FLAG-BIT A-TEM1)
	(POPJ-AFTER-NEXT		;M-ZR LEFT COPY OF C-PDL-BUFFER-POINTER
	 (PDL-BUFFER-INDEX) ADD M-ZR (A-CONSTANT (EVAL %LP-CALL-STATE)))
       ((C-PDL-BUFFER-INDEX) IOR C-PDL-BUFFER-INDEX
		(A-CONSTANT (BYTE-MASK %%LP-CLS-ADI-PRESENT)))

	
XAOCB (MISC-INST-ENTRY %ACTIVATE-OPEN-CALL-BLOCK)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DONT RETURN TO MISC
	(JUMP-XCT-NEXT QMRCL)
       ((C-PDL-BUFFER-POINTER) DPB C-PDL-BUFFER-POINTER
		Q-ALL-BUT-CDR-CODE (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
		
XPUSH (MISC-INST-ENTRY %PUSH)
	(POPJ-AFTER-NEXT 
	  (M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
       (NO-OP)

XAPDLR (MISC-INST-ENTRY %ASSURE-PDL-ROOM)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;NUMBER OF PUSHES PLANNING TO DO
	((PDL-BUFFER-INDEX) M-A-1 PDL-BUFFER-POINTER A-AP)	;CURRENT FRAME SIZE
	(POPJ-AFTER-NEXT (M-1) ADD PDL-BUFFER-INDEX A-1)	;PROPOSED NEW FRAME SIZE
       (CALL-GREATER-THAN M-1 (A-CONSTANT 370) XAPDLR1)	;NOTE FUDGE FACTOR OF 10 SINCE WE DON'T
						;CURRENTLY KNOW HOW MANY COMPILER-GENERATED
						;PUSHES MIGHT BE GOING TO HAPPEN
XAPDLR1	(CALL TRAP)
    (ERROR-TABLE STACK-FRAME-TOO-LARGE)

;(%SPREAD LIST)D-NEXT sends the elements of the list which is
;on the top of the stack to D-NEXT.  (%SPREAD LIST)D-LAST is similar
;but sends the last one to D-LAST (i.e. activates an open-call).
;(%SPREAD LIST)D-PDL is identical to (%SPREAD LIST)D-NEXT
XSPREAD (MISC-INST-ENTRY %SPREAD)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;LIST TO BE SPREAD
	((PDL-BUFFER-INDEX) M-A-1 PDL-BUFFER-POINTER A-AP)	;CURRENT FRAME SIZE (MOD 2000)
	((M-B) SUB PDL-BUFFER-INDEX (A-CONSTANT 370))	;-# PUSHES ALLOWED (FUDGE FACTOR OF 10)
XSPREAD-1
	(JUMP-EQUAL M-T A-V-NIL XSPREAD-EMPTY)
	(CALL-XCT-NEXT QCAR)
       ((M-A) A-T)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T
		Q-TYPED-POINTER (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	(CALL-XCT-NEXT QCDR)
       ((M-T) A-A)
	(JUMP-LESS-THAN-XCT-NEXT M-B A-ZERO XSPREAD-1)
       ((M-B) ADD M-B (A-CONSTANT 1))		;DECREASE NEGATIVE COUNT OF PUSHES ALLOWED
	(CALL TRAP)
    (ERROR-TABLE STACK-FRAME-TOO-LARGE)

XSPREAD-EMPTY
	((M-1) M-INST-DEST)
	(JUMP-EQUAL M-1 (A-CONSTANT 3) XAOCB)	;D-LAST, NO SYMBOL AVAILABLE EXCEPT SHIFTED
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T STORE IN DESTINATION
	(POPJ)
	
;DO "LINEAR" LEAVE, I.E. STORE EXIT STATE WORD
;  (CALL QLLV) SHOULD BE AFTER DISPATCH ON M-QMRCL IF CURRENT EXECUTION MODE
;	IS RUNNING MACRO-CODE.
QLLV	((PDL-BUFFER-INDEX) M-AP)		;GET POINTER TO
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)	; CURRENTLY RUNNING FEF
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
	((A-TEM1) DPB C-PDL-BUFFER-INDEX (BYTE-FIELD 24. 2)
		 (A-CONSTANT 0)) ;SHIFT 2 TO ALIGN WITH LOCATION COUNTER
	((M-TEM) SUB LOCATION-COUNTER A-TEM1 OUTPUT-SELECTOR-RIGHTSHIFT-1) ;RELATIVE PC (HWDS)
	((A-TEM2) DPB M-FLAGS (LISP-BYTE %%LP-EXS-PC-STATUS)  ;SAVE STATUS BITS
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-ZERO)
	(POPJ-AFTER-NEXT 			;CLEAR M-QBBFL AFTER SAVING IT
	 (PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
       ((C-PDL-BUFFER-INDEX) 
	   DPB M-TEM (LISP-BYTE %%LP-EXS-EXIT-PC) A-TEM2)	;STORE EXIT STATE WORD

;GET HERE WHEN RESUMING A STACK GROUP WHOSE ACTIVE FRAME IS A FEF.
;DONT RESTORE M-FLAGS, ETC, BECAUSE THAT IS HANDLED BY SG RESUME MECHANISM.
QLLENT	((M-A) DPB C-PDL-BUFFER-INDEX (BYTE-FIELD 24. 2)
		   (A-CONSTANT 0))  ;SET UP FROM M-AP.  SHIFT TO BYTE ALIGN
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((A-TEM1) DPB C-PDL-BUFFER-INDEX (BYTE-FIELD 17 1) A-ZERO) ;RELATIVE PC IN BYTES
			;CODE KNOWS THAT %%LP-EXS-EXIT-PC IS 0017
	((LOCATION-COUNTER) ADD M-A A-TEM1)	;RESTORE LC
	((LOCATION-COUNTER) SUB LOCATION-COUNTER (A-CONSTANT 2))  ;IT IS NECESSARY THAT
			;M-INSTRUCTION-BUFFER ACTUALLY HAVE THE LAST INSTRUCTION
			;EXECUTED (IE NOT SUFFICIENT MERELY THAT THE CORRECT INSTRUCTION
			;WILL BE FETCHED NEXT TIME AROUND THE MAIN LOOP).  THIS IS BECAUSE
			;THE CURRENT MACRO-INSTRUCTION, WHICH MAY BE BEING REENTERED
			;IN THE MIDDLE, CAN DISPATCH AGAIN ON M-INSTRUCTION-STREAM
			;(TO GET THE DESTINATION IN MISC, FOR EXAMPLE).  THE SIMPLEST
			;WAY TO ASSURE THIS IS TO BACK UP THE LOCATION COUNTER AND
			;RE-ADVANCE IT.
	(DISPATCH ADVANCE-INSTRUCTION-STREAM)
	(POPJ-AFTER-NEXT			;START INSTRUCTION FETCH, GET LOCAL BLOCK
	 (PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
       ((A-QLOCO) (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN) C-PDL-BUFFER-INDEX)

;;PC HAS BEEN INCREMENTED, COMPENSATE WHEN LOADING M-INST-BUFFER
;	((VMA-START-READ) SUB M-PC (A-CONSTANT 1)
;		OUTPUT-SELECTOR-RIGHTSHIFT-1)  ;GET MAIN LOOP BACK
;	(CHECK-PAGE-READ)	      ;INTO PHASE
;	((M-2) MICRO-STACK-DATA-POP)		;SAVE RETURN TO QLLENT
;	((A-GARBAGE) MICRO-STACK-DATA-POP)	;FLUSH OLD MAIN LOOP RETURN
;	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 0) M-PC QLLENT-PC-ODD)
;       ((M-1) (A-CONSTANT (I-MEM-LOC QMLPOD1)))
;	((M-1) (A-CONSTANT (I-MEM-LOC QMLP)))	;M-INST-BUFFER HAS CURRENT INSTRUCTION, NOT
						; NEXT INSTRUCTION, SO GO TO QMLP, NOT QMLPEV1
;QLLENT-PC-ODD
;	((MICRO-STACK-DATA-PUSH) M-1) 	        ;PUSH A NEW ONE OF THE RIGHT FLAVOR
;	((OA-REG-LOW) DPB M-2 OAL-JUMP A-ZERO)
;	(JUMP-XCT-NEXT 0)
;       ((M-INST-BUFFER) READ-MEMORY-DATA)	;AND RESTORE INSTRUCTION BUFFER


;DO "MICRO" LEAVE, I.E. STORE EXIT STATE IF CURRENT EXECUTION MODE
;	IS RUNNING A MICRO-CODED FUNCTION (NORMALLLY MICRO-COMPILED FCTNS).
; (CALL MLLV) SHOULD APPEAR AFTER THE DISPATCH ON D-QMRCL IN THIS CASE.
;   THE MAIN WORK DONE HERE IS TRANSFERING THE U-STACK TO A USTACK BLOCK
;   IN MAIN MEMORY.  HOWEVER, THE TOP ENTRY ON THE USTACK IS THE RETURN ADDRESS
;   PUT ON BY THE (CALL MLLV).
;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
MLLV	((M-2) MICRO-STACK-DATA-POP)
	(CALL QMMPSH)
	((MICRO-STACK-DATA-PUSH) M-2)	;PUT BACK "REAL" RETURN
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((A-TEM1) C-PDL-BUFFER-INDEX)	;SAVE AND CLEAR M-QBBFL
	((C-PDL-BUFFER-INDEX) DPB M-FLAGS (LISP-BYTE %%LP-EXS-PC-STATUS)
		A-TEM1)
	((M-FLAGS) SELECTIVE-DEPOSIT M-FLAGS M-FLAGS-EXCEPT-PROCESSOR-FLAGS A-ZERO)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	(POPJ-AFTER-NEXT 
	 (A-TEM1) C-PDL-BUFFER-INDEX)
       ((C-PDL-BUFFER-INDEX) DPB M-T A-TEM1 (LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT))

;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
QMMPSH	((M-ZR) MICRO-STACK-DATA-POP)	;GET REAL RETURN OFF MICRO-STACK
	((M-1) ADD (M-CONSTANT 40) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 TRAP)  ;RESULT HAD BETTER BE NEGATIVE
  (ERROR-TABLE PDL-OVERFLOW SPECIAL)			 ; (AS A 24. QUANTITY)
	((M-T) A-ZERO)
MLLV1	((M-Q) MICRO-STACK-POINTER)	;NOTE THIS INVOLVES A LDB TYPE OPERATION
	(JUMP-EQUAL M-Q A-ZERO MLLV2)	;XFER ON THRU WITH PDL TRANSFER
					; IE ALL OFF BUT RETURN TO MAIN LOOP
	((M-Q) MICRO-STACK-DATA-POP)	;NOTE THIS INVOLVES A LDB TYPE OPERATION
	(JUMP-NOT-EQUAL-XCT-NEXT M-T A-ZERO MLLV3)
       ((A-QLBNDP) ADD A-QLBNDP M-ZERO ALU-CARRY-IN-ONE) 
	((M-Q) DPB (M-CONSTANT -1) Q-FLAG-BIT A-Q)	;FIRST IN BLOCK
MLLV3	((WRITE-MEMORY-DATA) IOR M-Q 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)		;NO SEQ BRK BECAUSE BIND STACK STATE NOT
	(JUMP-XCT-NEXT MLLV1)		; REALLY CONSISTENT NOW (IE XFER COUNT NOT
       ((M-T) ADD M-T (A-CONSTANT 1))	; STORED)

MLLV2	((OA-REG-LOW) DPB M-ZR OAL-JUMP A-ZERO)
	(JUMP 0)			;RETURN

;OPEN MICRO-TO-MACRO CALL BLOCK
P3ZERO	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
MMASU1	((M-ZR) ADD PDL-BUFFER-POINTER		;1- BECAUSE OF PUSH JUST DONE
		 (A-CONSTANT (EVAL (1- %LP-CALL-BLOCK-LENGTH))))
	((M-K) SUB M-ZR A-IPMARK)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) A-ZERO)
	((M-K) SUB M-ZR A-AP)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) A-TEM1)
	((C-PDL-BUFFER-POINTER)		;IOR WITH LPCLS Q ALREADY PUSHED
	  IOR C-PDL-BUFFER-POINTER A-TEM1)
	((C-PDL-BUFFER-POINTER-PUSH)			;PUSH LPEXS Q
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT 				;PUSH LPENS Q
	  (C-PDL-BUFFER-POINTER-PUSH)
	    (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)		;CALLER MUST PUSH LPFEF Q

;ENTER MICRO-CODE ENTRY FCTN
; M-S HAS NEW VALUE FOR M-AP, 0(M-S) IS FUNCTION BEING
; CALLED (ALSO IN M-A), 1(M-S) IS 1ST ARG, 2(M-S) IS 2ND, ETC.
; A-IPMARK AND A-NARGS ARE SET UP AND CALLING FCN HAS BEEN LEFT.

QME1	((M-D) Q-POINTER M-A)
	(CALL-GREATER-OR-EQUAL M-D A-AMCENT TRAP)	;OUT OF RANGE
  (ERROR-TABLE ILLEGAL-INSTRUCTION)
	((VMA-START-READ) ADD M-D A-V-MICRO-CODE-ENTRY-AREA)  ;IF THIS A FIXNUM, ITS
	(CHECK-PAGE-READ)           ;INDEX TO MICRO-CODE-SYMBOL-AREA.  OTHERWISE, FCTN
	((M-T) READ-MEMORY-DATA)    ;IS NOT REALLY MICROCODED NOW, AND THIS IS OTHER DEF.
	((M-TEM) Q-DATA-TYPE M-T)   ;IF SO, PUT THIS IN LP-FEF SLOT AND TRY AGAIN.
	(JUMP-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-FIX)) QME1X)  ;HMM NOT REALLY MICROCODED
QME1R	((VMA-START-READ) ADD M-D A-V-MICRO-CODE-ENTRY-ARGS-INFO-AREA)
	(CHECK-PAGE-READ)
	((PDL-BUFFER-INDEX) SUB M-S A-AP)	;Increment to M-AP (truncated to 10 bits)
	((M-PDL-BUFFER-ACTIVE-QS) ADD PDL-BUFFER-INDEX A-PDL-BUFFER-ACTIVE-QS)
	((M-TEM) (LISP-BYTE %%ARG-DESC-MIN-ARGS) READ-MEMORY-DATA)
	(CALL-GREATER-THAN M-TEM A-NARGS SET-TOO-FEW-ARGS)
	((M-TEM) (LISP-BYTE %%ARG-DESC-MAX-ARGS) READ-MEMORY-DATA)
	(CALL-LESS-THAN M-TEM A-NARGS SET-TOO-MANY-ARGS)
			;NOTE, THIS DOESN'T CHECK FOR LEXPR/FEXPR CALL.
			;WE DO PROVIDE FOR MICROCODED FUNCTIONS WITH VARIABLE NUMBER
			;OF ARGS, WHICH ARE LEGAL PROVIDED THEY ARE NOT MISC INSTRUCTIONS.
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
       ((M-AP) M-S)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((M-TEM) A-NARGS)
	((C-PDL-BUFFER-INDEX) DPB M-TEM (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-READ) ADD M-T A-V-MICRO-CODE-SYMBOL-AREA)  ;M-T HAS DATA READ FROM
	(CHECK-PAGE-READ)			;MICRO-CODE-ENTRY-AREA
QME1A	(JUMP-NOT-EQUAL M-ERROR-SUBSTATUS A-ZERO QLEERR) ;SIGNAL WRONG NUMBER OF ARGS ERROR
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT)
		C-PDL-BUFFER-INDEX QME2)	;JUMP IF THIS AN ADDTL INFO CALL
	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(CALL 0)			;CALL THE MICRO ENTRY
QMER	(JUMP QMDDR0)

QME2	((OA-REG-LOW M-LAST-MICRO-ENTRY) DPB READ-MEMORY-DATA OAL-JUMP A-ZERO)
	(JUMP-XCT-NEXT 0)
       ((MICRO-STACK-DATA-PUSH)			;PUSH FUNNY RETURN
		(A-CONSTANT (PLUS (BYTE-MASK %%-PPBMAA) (I-MEM-LOC QMER))))

QME1X	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-U-ENTRY)) QME1R)  ;FOR NOW,
             ;THIS MEANS ITS MICROCODED TOO.  JUST FOR COMPATIBILITY WITH OLD COLD LOADS.
	((C-PDL-BUFFER-INDEX M-A) SELECTIVE-DEPOSIT C-PDL-BUFFER-INDEX 	;CLOBBER INTO
		Q-ALL-BUT-TYPED-POINTER A-T)	; LP-FEF SLOT, REPLACING DTP-U-ENTRY
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)
       (NO-OP)



;;; DESTINATION RETURN
QMDDR	(JUMP-NOT-EQUAL M-AP A-IPMARK QMDDR-THROW) ;CHECK FOR UNWIND-PROTECT
QMDDR0	(CALL-IF-BIT-SET M-QBBFL BBLKP)		;POP BINDING BLOCK (IF STORED ONE)
QMEX1	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-C) C-PDL-BUFFER-INDEX)		;M-C := CALL STATE
	((PDL-BUFFER-POINTER) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH))) ;FLUSH PDL
	(CALL-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) M-C QRAD1)  ;FLUSH ADDTL INFO
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-C)
	(JUMP-EQUAL M-ZERO A-TEM1 QMXSG)	;RETURNING OUT TOP OF STACK-GROUP
	((M-ZR) SUB M-AP A-TEM1)		;COMPUTE PREV A-IPMARK
	((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;RESTORE THAT
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) M-C)
	((PDL-BUFFER-INDEX) SUB M-AP A-TEM1)		;RESTORE M-AP
	((M-AP) PDL-BUFFER-INDEX)		;THIS OPERATION MASKS M-AP TO 10 BITS.
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-PDL-BUFFER-ACTIVE-QS A-TEM1)
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS 
			(A-CONSTANT PDL-BUFFER-LOW-WARNING) PDL-BUFFER-REFILL)
	(DISPATCH-XCT-NEXT (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE 
		C-PDL-BUFFER-INDEX QMXRT)
       ((M-A) Q-POINTER C-PDL-BUFFER-INDEX)		;FUNCTION RETURNNING TO

;	(CALL-NOT-EQUAL M-J (A-CONSTANT (EVAL DTP-FEF-POINTER)) ILLOP)
QMEXF	((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) M-C)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((A-QLOCO) (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	((M-1) DPB M-A (BYTE-FIELD 24. 2) (A-CONSTANT 0))	;FEF ADR IN BYTES
	((A-TEM1) DPB C-PDL-BUFFER-INDEX (BYTE-FIELD 17 1) A-ZERO)
			;CODE KNOWS THAT %%LP-EXS-EXIT-PC IS 0017
	(JUMP-XCT-NEXT QIMOVE-EXIT)
       ((LOCATION-COUNTER) ADD M-1 A-TEM1)

;FUNCTION TYPE= LIST, RETURN TO INTERPRETER
QMMRL	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-LAST-MICRO-ENTRY) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-LAST-MICRO-ENTRY (A-CONSTANT (I-MEM-LOC INTRET)) ILLOP)
;DROPS IN-- FUNCTION TYPE= UCODE-ENTRY.
QMMR2	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	((MICRO-STACK-DATA-PUSH M-LAST-MICRO-ENTRY)
		(LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	;(JUMP QMMPOP)		;RESTORE USTACK FROM BINDING STACK
;DROPS IN
QMMPOP	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((M-J) (LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT) C-PDL-BUFFER-INDEX)
	((C-PDL-BUFFER-INDEX)			;DONT LEAVE GARBAGE AROUND IN XFER COUNT
		SELECTIVE-DEPOSIT C-PDL-BUFFER-INDEX
		(ALL-BUT-LISP-BYTE %%LP-ENS-U-MICRO-STACK-XFER-COUNT) A-ZERO)
QMMPO1	((M-S) MICRO-STACK-DATA-POP)	;POP OFF RETURN  ENTER HERE FROM SG STUFF.
	(JUMP-EQUAL M-J A-ZERO QMMPOX)
QMMPO2	((VMA-START-READ M-ZR) A-QLBNDP)	;NO TRANSPORT, KNOWN TO BE A FIXNUM
	(CHECK-PAGE-READ)			;BIND STACK NOT REALLY CONSISTENT, NO SEQ BRK
	((M-J) SUB M-J (A-CONSTANT 1))
	((A-QLBNDP) SUB M-ZR (A-CONSTANT 1))
	((MICRO-STACK-DATA-PUSH) READ-MEMORY-DATA)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(CALL-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FIX)) ILLOP)
	(JUMP-EQUAL M-J (A-CONSTANT 0) QMMPO3)	;THIS TO BE LAST TIME?
	(JUMP-XCT-NEXT QMMPO2)
       (CALL-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA ILLOP)  ;FIRST WD OF BLOCK?

QMMPO3	(CALL-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA ILLOP) ;LAST WD SHOULD HAVE BIT
QMMPOX	((OA-REG-LOW) DPB M-S OAL-JUMP A-ZERO)
	(JUMP 0)

;GET HERE WHEN RETURNING OUT TOP OF STACK GROUP
QMXSG	((PDL-BUFFER-POINTER) M-AP)	;AVOID GROSS SCREW WHERE P-F ROUTINES GET CONFUSED
		;ABOUT WHATS IN THE PDL-BUFFER DUE TO FACT PDL-BUFFER-POINTER WAS DECREMENTED
		;TO BEFORE ACTIVE CALL BLOCK (IE 1777 IF SG STARTED OFF AT 0@P)
	((VMA) A-QCSTKG)	;ERROR CHECK TO SEE IF DELTA S SCREWWED OR SOMETHING
	((VMA-START-READ) SUB VMA
		 (A-CONSTANT (PLUS 2 (EVAL SG-INITIAL-FCTN-INDEX))))
	(CHECK-PAGE-READ)
	((A-SG-TEM) M-T)	;VALUE GETTING RETURNED
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((PDL-BUFFER-INDEX) ADD READ-MEMORY-DATA A-PDL-BUFFER-HEAD)
	(CALL-NOT-EQUAL PDL-BUFFER-INDEX A-AP ILLOP)
	(JUMP-XCT-NEXT SG-RETURN-2)	;RETURN THIS LAST VALUE AND GO TO EXHAUSTED STATE
       ((M-TEM) (A-CONSTANT (EVAL SG-STATE-EXHAUSTED)))


;STORE LAST VALUE IN ADI CALL, FLUSH ADI FROM PDL
;MAY CLOBBER ALL REGISTERS EXCEPT M-C
QRAD1	((PDL-BUFFER-INDEX M-K) PDL-BUFFER-POINTER)	;IN CASE ENTERED FROM ARRAY CODE
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QRAD1R)))  ;DONT CARE IF THIS 
							; LAST OR NOT.
	((PDL-BUFFER-POINTER) M-AP)	;IN CASE WE SWITCH STACK GROUPS INSIDE MVR
	(CALL-XCT-NEXT MVR0)	;STORE THE LAST VALUE INTO MV IF ANY
       ((M-S) A-ZERO)
QRAD1R	((PDL-BUFFER-INDEX M-K) SUB M-AP
		(A-CONSTANT (PLUS 1 (EVAL %LP-CALL-BLOCK-LENGTH)))) ;FLUSH ADI FROM PDL
QRAD2	(POPJ-IF-BIT-CLEAR-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX)
       ((PDL-BUFFER-POINTER) SUB M-K (A-CONSTANT 1))
	(JUMP-XCT-NEXT QRAD2)
       ((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 2))

XRETN (MISC-INST-ENTRY %RETURN-N)		;RETURN N VALUES, LAST ARG IS N.
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;NOT RETURNING TO 'MISC'
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP NIL)
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP) ;NUMBER OF VALUES TO RETURN
XRETN1	((M-C) SUB M-C (A-CONSTANT 1))
	(JUMP-LESS-OR-EQUAL M-C A-ZERO XRETN2) ;LAST
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER A-C)	;NEXT ARGUMENT SLOT
	(JUMP XRETN1)

XRET2 (MISC-INST-ENTRY %RETURN-2)
	(JUMP-XCT-NEXT XRET2A)
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'

XRET3 (MISC-INST-ENTRY %RETURN-3)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))
XRET2A	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;RETURN ON LAST VAL
	(CALL-XCT-NEXT XRNVRPI)
       ((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 1))
XRETN2	(JUMP-XCT-NEXT QMDDR)			;RETURN LAST VALUE REGULAR WAY
       ((M-T) C-PDL-BUFFER-POINTER)

XRETURN-LIST (MISC-INST-ENTRY RETURN-LIST)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XRETURN-LIST-1
	; After exhausting arg, return a NIL back to MISC, which will give it to D-RETURN.
	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QMA)
       ((M-C) A-T)
	;Next element in M-T, list tail in M-C.  Return the element.
	;Push the address to return to if have no more values wanted.
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XRETURN-LIST-2)))
	(CALL XRNVR)
	(CALL-XCT-NEXT QMD)
       ((M-T) A-C)
	(JUMP XRETURN-LIST-1)

	;No more values wanted => return to MISC which will go to D-RETURN routines.
XRETURN-LIST-2
	(POPJ)

XRNV (MISC-INST-ENTRY RETURN-NEXT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMDDR))) ;GO TO QMDDR IF LAST
						;  VALUE.
	(CALL-XCT-NEXT XRNVR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FROB TO RETURN
	(JUMP QIMOVE1)				;STORE IN DESTINATION

;XRNVX MOVED BELOW
;XRNVX	(JUMP-XCT-NEXT QMDDR)			;NO MORE ADI, RETURN LAST VALUE REGULAR
;       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;WAY, FLUSHING XRNVR'S POPJ ADDRESS.

;RETURN NEXT VALUE.  SEE COMMENTS BELOW FOR INFO ON SPECIAL CALLING SEQUENCE.
XRNVRPI	((M-T) C-PDL-BUFFER-INDEX)
XRNVR	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX XRNVX)
	((M-S) (A-CONSTANT 1))			;SET FLAG AND DROP INTO MVR

;STORE A RETURN VALUE (FROM M-T) IN A MULTIPLE-VALUE CALL
;M-S 1 IF CALLING FROM %RETURN-NEXT-VALUE, 0 IF FROM FROM DESTINATION RETURN
;THIS CONTROLS THE HACK OF %RETURN-NEXT-VALUE TURNING INTO DESTINATION
;RETURN WHEN RETURNING THE LAST VALUE THE CALLER WANTED.
;ALSO, WHEN M-S IS 0 THE MULTIPLE VALUE ADI INTO WHICH THE RETURN
;VALUE IS ACTUALLY STORED (IF ANY) IS CHANGED FROM ADI-RETURN-INFO
;TO ADI-USED-UP-RETURN-INFO.  THIS ENSURES THAT THE LAST VALUE ISN'T
;RETURNED N TIMES WHEN N TAIL-RECURSIVE CALLS ARE CHAINED TOGETHER
;WITH INDIRECT ADI POINTERS, AS HAPPENS WITH 'EVAL' FOR INSTANCE.

;PROPOSED NEW FROB..
;  CALL WITH VALUE TO RETURN IN M-T PLUS TWO FROBS ON USTACK AND ALSO AN ARG IN M-S.
;M-S -> 0 DOING A "REGULAR" RETURN.  IN ADDITION TO RETURNING VALUE, THE CALL IS
;  "CLOSED OFF", RETURNING NULL VALUES FOR ANY ADDITIONAL VALUES THAT MIGHT HAVE
;BEEN REQUESTED.
;M-S -> 1 DOING A "RETURN-NEXT-VALUE".  THIS SIGNIFIES AN INTENTION TO EVENTUALLY
;RETURN MORE VALUES.
;  ON "RETURN-NEXT-VALUE" CONTROL RETURNS TO FIRST RETURN IF THIS WAS LAST VALUE EXPECTED,
;OTHERWISE SECOND RETURN.  
;  ON "REGULAR-RETURN", CONTROL MAY RETURN TO EITHER RETURN (DEPENDING ON A FEW NOT
;TOO RANDOM THINGS).  HOWEVER, IN THIS CASE, BOTH RETURNS ARE NORMALLY THE SAME SO
;IT DOESNT MAKE ANY DIFFERENCE.
;  IN ANY CASE, BOTH RETURNS ARE FLUSHED FROM THE STACK.

;  ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC <THAT-WAS-LAST-VALUE-RETURN>)))
;  (CALL MVR)
;  ... STILL EXPECTING MORE VALUES

;SEQUENCE TO RETURN TO FIRST RETURN <THAT-WAS-LAST-VALUE-EXPECTED>
;  ((M-GARBAGE) MICRO-STACK-DATA-POP)
;  (POPJ)

;SEQUENCE TO RETURN TO SECOND RETURN <MORE-VALUES-ARE-EXPECTED>
;  (POPJ-XCT-NEXT)
; ((M-GARBAGE) MICRO-STACK-DATA-POP)

;CLOBBERS A-TEM1, M-I, M-J, M-S, M-R, M-K PLUS CALLS QRDR1 (WHICH DOESNT CLOBBER ANY MORE)
;PLUS CALLS CONS, WHICH CLOBBERS MORE.  PROTECTS M-C BUT PROBABLY NOT ANYTHING ELSE.

;DROPS IN FROM ABOVE
MVR	((PDL-BUFFER-INDEX M-K) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
MVR0	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ADI)
	((M-J) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-J (A-CONSTANT (EVAL ADI-RETURN-INFO)) MVR1)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ADI-RET-STORING-OPTION)
		C-PDL-BUFFER-INDEX D-MVR)
       ((M-I) (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) C-PDL-BUFFER-INDEX)

MVR1	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)	;INFO OUT OF PHASE
	((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX MVR0) ;MORE
       ((PDL-BUFFER-INDEX M-K) SUB M-K (A-CONSTANT 1))
MVR2  ;NO ADI, THIS THE LAST VALUE
XRNVX	((M-GARBAGE) MICRO-STACK-DATA-POP)	;FLUSH SECOND RETURN
	(POPJ)					;THAT WAS LAST VALUE, TAKE FIRST RETURN

;	(JUMP-EQUAL M-S (A-CONSTANT 1) XRNVX)	;CAN'T FIND MV ADI, RET REGULAR WAY
;	(POPJ)					;OH, WELL
	
;BLOCK, PNTR TO IT IN PDL BUFFER, BLOCK MAY OR MAY NOT BE
MVRB	(CALL-LESS-OR-EQUAL M-I A-ZERO ILLOP)		;RETURNING TOO MANY VALUES
;LAST
	(JUMP-EQUAL M-I A-S XRNVX)	;LAST AND NOT DOING RETURN, TURN INTO QMDDR!!
	((M-I) SUB M-I (A-CONSTANT 1))
	((M-J) C-PDL-BUFFER-INDEX)
	((C-PDL-BUFFER-INDEX M-J) DPB M-I (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) A-J)
	(JUMP-NOT-EQUAL M-S A-ZERO MVRB0)
	((C-PDL-BUFFER-INDEX M-J) DPB (M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-J)
MVRB0	((PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	((C-PDL-BUFFER-INDEX M-I) ADD C-PDL-BUFFER-INDEX (A-CONSTANT 1))
MVRB1	((VMA-START-READ) SUB M-I (A-CONSTANT 1))	;NO TRANSP, SINCE WRITING AND NO
MVRB2	(CHECK-PAGE-READ)				;NEED TO FOLLOW INVISIBLE PNTRS HERE
	((WRITE-MEMORY-DATA-START-WRITE)	;STORE THE VALUE
		SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
        (CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)	;MORE EXPECTED, OR DOING RETURN AND THAT WAS
       ((M-GARBAGE) MICRO-STACK-DATA-POP)	;LAST, TAKE SECOND RETURN AND FLUSH FIRST

;BLOCK, NOT KNOWN WHETHER ANYTHING IN PDL BUFFER
MVRBV	(CALL-LESS-OR-EQUAL M-I A-ZERO ILLOP)		;RETURNING TOO MANY VALUES
	(JUMP-EQUAL M-I A-S XRNVX)			;LAST, TURN INTO QMDDR!!
	((M-I) SUB M-I (A-CONSTANT 1))
	((A-TEM1) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-S A-ZERO MVRBV0)
	((A-TEM1) DPB (M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-TEM1)
MVRBV0	((WRITE-MEMORY-DATA-START-WRITE)
		DPB M-I (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) A-TEM1)
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSP SINCE IT IS A FIXNUM
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA-START-WRITE M-I) ADD READ-MEMORY-DATA (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP MVRB1)

;CONS UP LIST, PNTR TO LIST TAIL IN PDL BUFFER
MVRC	(CALL CONVERT-PDL-BUFFER-ADDRESS)
	((VMA) M-K)				;LOCATIVE TO ADI TO VMA, DROP THROUGH

;CONS UP LIST
;2ND (LOWER) ADI WORD POINTS TO LIST TAIL.  INITIALLY IT IS A LOCATIVE
;TO THE LOCATION WHICH WILL EVENTUALLY HOLD THE LIST OF RETURNED VALUES,
;WHICH SHOULD BE INITIALIZED TO NIL.
;AFTER THE FIRST TIME, IT IS A LIST-POINTER TO THE LAST CONS IN THE LIST.
;XNCONS MUSTN'T CLOBBER M-C, M-I, M-R; QRDR1 MUSTN'T CLOBBER M-C OR M-R
MVRCV	((VMA-START-READ M-I) VMA)		;SAVE PNTR+1 TO PNTR TO LIST TAIL
	(CHECK-PAGE-READ)			;GET HIGHER ADI WORD
	(JUMP-NOT-EQUAL M-S A-ZERO MVRCV0)	;NO TRANSPORT SINCE IT IS A FIXNUM
	((A-TEM1) READ-MEMORY-DATA)		;FROM QMDDR, CHANGE TO USED-UP-ADI
	((WRITE-MEMORY-DATA-START-WRITE) DPB
		(M-CONSTANT -1) (LISP-BYTE %%ADI-TYPE) A-TEM1)
	(CHECK-PAGE-WRITE)
MVRCV0	(CALL-XCT-NEXT XNCONS)			;CONS UP A CONS, CDR NIL, TO M-T
       ((C-PDL-BUFFER-POINTER-PUSH M-R) M-T)	;SAVE VALUE RETURNING, WILL BE CAR
	((VMA-START-READ) SUB M-I (A-CONSTANT 1))	;GET PNTR TO LIST TAIL
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-S) READ-MEMORY-DATA)		;SAVE PNTR TO LIST TAIL
	((WRITE-MEMORY-DATA-START-WRITE) M-T)	;CHANGE PNTR TO NEW LIST TAIL
	(CHECK-PAGE-WRITE)
	(CALL QRDR1)				;RPLACD TAIL OF LIST
	(POPJ-XCT-NEXT)		;MORE <INFINITE> VALUES EXPECTED
       ((M-T) SETA A-R MICRO-STACK-PNTR-AND-DATA-POP)    ;RESTORE VALUE BEING RETURNED 
		;AND FLUSH FIRST RETURN. (PNTR-AND-DATA NECC. TO AVOID A BYTE-OP)
;MORE <INFINITE> VALUES EXPECTED.

;INDIRECT POINTER, PNTR TO IT IN PDL BUFFER
MVRI	((PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	((VMA-START-READ) C-PDL-BUFFER-INDEX)	;NO TRANSPORT SINCE IT'S A FIXNUM
;IN THIS PART OF THE CODE WE DON'T KNOW IF ANYTHING IS IN THE PDL BUFFER
MVRV0	(CHECK-PAGE-READ)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE READ-MEMORY-DATA TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ADI)
	((M-J) (LISP-BYTE %%ADI-TYPE) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-J (A-CONSTANT (EVAL ADI-RETURN-INFO)) MVRV1)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ADI-RET-STORING-OPTION)
		READ-MEMORY-DATA D-MVRV)
       ((M-I) (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING) READ-MEMORY-DATA)

MVRV1	(CALL-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA ILLOP)	;INFO OUT OF PHASE
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSPORT SINCE IT'S A FIXNUM
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA MVR2)	;NO MORE ADI
	(JUMP-XCT-NEXT MVRV0)
       ((VMA-START-READ) SUB VMA (A-CONSTANT 2))	;NO TRANSPORT SINCE IT'S A FIXNUM
	
;INDIRECT POINTER, NOT KNOWN WHETHER ANYTHING IN PDL BUFFER
MVRIV	((VMA-START-READ) SUB VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT MVRV0)
       ((VMA-START-READ) READ-MEMORY-DATA)	;NO TRANSPORT SINCE IT'S A FIXNUM

;;; THROW CODE (*THROW, *UNWIND-STACK)
;;; Register Conventions:
;;; A-CATCH-MARK is the function for which an open call is what we want (usually %CATCH)
;;; A-CATCH-TAG is the first argument to that function.  Except, T and 0 are special.
;;; A-CATCH-COUNT contains a count of active frames.  If this reaches zero, we resume
;;;  that frame instead of throwing farther.  If this is NIL, no count.
;;; A-CATCH-ACTION contains the "action", which is usually NIL, but T to coroutine back
;;;  when we reach the resumption point instead of resuming.
;;; M-T value being thrown

;;; Special *CATCH tags are:
;;;  NIL  CATCH-ALL
;;;  T    UNWIND-PROTECT.  The difference between UNWIND-PROTECT and CATCH-ALL
;;;	  is that UNWIND-PROTECT will always continue throwing, and without
;;;	  messing up the previous stack group pointer, either.

;;; Special *THROW, *UNWIND-STACK tags are:
;;;  0    Return from function (like destination-return)
;;;  T    Throw all the way out the top of the stack-group, then coroutine
;;;       back to the previous stack group.  In this case we bypass CATCH-ALLs.
;;;	  This is used for unwinding "old" stack groups.
;;;  NIL  *CATCH returns NIL as the tag if no throw or return operation occurred.
;;; If the tag is neither T nor 0, we throw to the nearest catch with that tag,
;;; or UNWIND-PROTECT, or CATCH-ALL.

;;; *UNWIND-STACK is a generalized *THROW, used by the error handler and
;;; by UNWIND-PROTECT.  The first two arguments are the same as to *THROW.
;;; The third argument is a count; if this NIL things are the same as *THROW,
;;; otherwise if this many frames are passed we resume as if a catch had been found.
;;; The fourth argument, if non-NIL, means that instead of resuming when
;;; we find the point to throw to, we coroutine back.  This is for the error
;;; handler.

XUWSTK (MISC-INST-ENTRY *UNWIND-STACK)
   (ERROR-TABLE RESTART *UNWIND-STACK)
	((A-CATCH-ACTION) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((A-CATCH-COUNT) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT XUWS0)
      ;((A-CATCH-MARK) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
      ;					 *CATCH-U-CODE-ENTRY-/#)))

XTHROW (MISC-INST-ENTRY *THROW)
   (ERROR-TABLE RESTART *THROW)
		;Note the following instruction is also XCT-NEXT'ed from above
	((A-CATCH-MARK) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
					  *CATCH-U-CODE-ENTRY-/#)))
	((A-CATCH-ACTION) A-V-NIL)
	((A-CATCH-COUNT) A-V-NIL)
XUWS0	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;Value thrown
	((M-1) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;Tag
	(JUMP-EQUAL-XCT-NEXT M-1 A-V-TRUE XTHRW7)	  ;Tag of T means all the way
       ((A-CATCH-TAG) M-1)				  ; so don't check first
	(JUMP-EQUAL M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		XTHRW7)					  ;Tag of 0 also special
;DROPS THROUGH
;DROPS IN
;Before actually going and munging anything, follow the open-call-block chain
;and find out whether the catch tag we're looking for actually exists.
;Register usage:
;  M-A	Virtual address of next call block (typeless) (either active or open)
;  M-B	Virtual address of next active call block (typeless)
;  M-C	Pdl buffer address of next call block (only low 10 bits valid)
;  M-1	arg into / result out of XTHCG
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-AP)
	((M-B) Q-POINTER M-K)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) A-IPMARK)
	((M-A) Q-POINTER M-K)
	((M-C) A-IPMARK)
	(JUMP-NOT-EQUAL M-A A-B XTHC2)			;JUMP IF FOUND OPEN CALL BLOCK
XTHC1	(CALL-XCT-NEXT XTHCG)				;GET CALL STATE Q
       ((M-1) ADD M-A (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) M-1)
	(JUMP-EQUAL M-ZR A-ZERO XTHC-ERROR)	        ;REACHED END OF PDL DIDN'T FIND MARK.
	((M-B) SUB M-B A-ZR)
XTHC4	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-1)
	((M-A) SUB M-A A-ZR)
	(JUMP-EQUAL-XCT-NEXT M-A A-B XTHC1)
       ((M-C) SUB M-C A-ZR)
XTHC2	(CALL-XCT-NEXT XTHCG)				;GET LPFEF Q
       ((M-1) M-A)
	(JUMP-NOT-EQUAL M-1 A-CATCH-MARK XTHC3)		;NO GOOD
	(CALL-XCT-NEXT XTHCG)
       ((M-1) ADD M-A (A-CONSTANT 1))			;GET FIRST ARG
	(JUMP-EQUAL M-1 A-CATCH-TAG XTHRW7)		;FOUND THE ONE WE'RE LOOKING FOR,
							;IT'S NOW SAFE TO GO THROW FOR REAL.
	(JUMP-EQUAL M-1 A-V-NIL XTHRW7)			;FOUND CATCH-ALL, THATS OK TOO.
XTHC3	(CALL-XCT-NEXT XTHCG)				;GET CALL STATE Q
       ((M-1) ADD M-A (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP XTHC4)

XTHC-ERROR
	((M-A) A-CATCH-TAG)
	((M-B) A-CATCH-COUNT)
	((M-C) A-CATCH-ACTION)
	(CALL TRAP)
   (ERROR-TABLE THROW-TAG-NOT-SEEN)	;The EH knows specially about this entry.
					;It knows the tag is in M-A, the value is in M-T,
					;the count is in M-B, and the action is in M-C.
					;It restarts at *THROW (should use *UNWIND-STACK)

;GET A WORD WHOSE UNTYPED VIRTUAL ADDRESS IS IN M-1.  FOR SPEED, ATTEMPTS
;TO FIGURE OUT IF IT IS IN THE PDL BUFFER AND IF SO GET IT DIRECTLY
;WITHOUT BOTHERING WITH PAGE TRAPS.  BASHES M-1 TO Q-TYPED-POINTER OF THE FETCHED DATA.
XTHCG	(JUMP-LESS-THAN M-1 A-PDL-BUFFER-VIRTUAL-ADDRESS XTHCG1)
	((M-1) SUB M-1 A-A)
	(POPJ-AFTER-NEXT (PDL-BUFFER-INDEX) ADD M-1 A-C)
       ((M-1) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)

XTHCG1	((VMA-START-READ) M-1)
	(CHECK-PAGE-READ)			;WILL PROBABLY ALWAYS FAULT
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-1) Q-TYPED-POINTER READ-MEMORY-DATA)

;Here from QMDDR if there are open call blocks in this frame.  It could
;be an UNWIND-PROTECT, so we come here to check it out by doing a throw
;of the value being returned, to the tag 0.
QMDDR-THROW
	(JUMP-EQUAL M-AP A-IPMARK QMDDR0)	;No active frames, can't be an unwind-protect
	((A-CATCH-MARK) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
					  *CATCH-U-CODE-ENTRY-/#)))
	((A-CATCH-ACTION) A-V-NIL)
	((A-CATCH-COUNT) A-V-NIL)
	((A-CATCH-TAG) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;0
		;drop into XTHRW7
;This is the main throw loop.  Come here for each frame.
XTHRW7	(JUMP-EQUAL-XCT-NEXT M-AP A-IPMARK XTHRW1) ;LAST FRAME ACTIVE, UNWIND IT
       ((M-R) A-V-NIL)				;GET NIL ON THE M SIDE FOR LATER
	((M-I PDL-BUFFER-INDEX) A-IPMARK)	;LAST FRAME OPEN, NOTE IT MUST ALREADY BE IN
						; PDL BUFFER, SINCE ENTIRE ACTIVE FRAME IS.
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-A A-CATCH-MARK XTHRW2)	;THATS NOT WHAT LOOKING FOR
	((PDL-BUFFER-INDEX) ADD A-IPMARK M-ZERO ALU-CARRY-IN-ONE)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-A A-V-TRUE XTHRW4)	;FOUND UNWIND-PROTECT, RESUME IT
	((M-1) A-V-TRUE)
	(JUMP-EQUAL A-CATCH-TAG M-1 XTHRW2)	;IF UNWINDING ALL THE WAY, KEEP LOOKING
	(JUMP-EQUAL M-A A-V-NIL XTHRW4)		;FOUND CATCH-ALL, RESUME IT
	(JUMP-NOT-EQUAL M-A A-CATCH-TAG XTHRW2)	;DIDN'T FIND RIGHT TAG, KEEP LOOKING
;FOUND FRAME TO RESUME
XTHRW4	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-B) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)	;PRESERVE FOR USE BELOW
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX 
		XTHRW9)		;NO ADI, HAD BETTER BE DESTINATION RETURN
	((PDL-BUFFER-INDEX M-D) SUB M-I (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
XTHRW3	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) 
		     Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ADI)
	((M-A) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-NOT-EQUAL M-A (A-CONSTANT (EVAL ADI-RESTART-PC)) XTHRW8)
	((M-J) (LISP-BYTE %%ADI-RPC-MICRO-STACK-LEVEL) C-PDL-BUFFER-INDEX)
	((PDL-BUFFER-INDEX) SUB M-D (A-CONSTANT 1))
	((M-E) Q-POINTER C-PDL-BUFFER-INDEX)	    ;RESTART PC
	((PDL-BUFFER-INDEX) M-AP)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)	    ;SIMULATES THRWD1 DISP IN LMI
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-B) C-PDL-BUFFER-INDEX)		    ;SO CAN BE DPB ED INTO EASILY
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) XTHWM1)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) XTHWU1)
	(CALL ILLOP)

XTHWU1	((C-PDL-BUFFER-INDEX) DPB M-E A-B (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC))
XTHRW5	((M-ZR) MICRO-STACK-POINTER)		;INVOLVES A LDB OP
	(JUMP-EQUAL A-ZR M-J XTHRW6)
	((M-ZR) MICRO-STACK-DATA-POP)
	(CALL-IF-BIT-SET %%-PPBSPC M-ZR BBLKP)
	(JUMP XTHRW5)

XTHWM1	(JUMP-XCT-NEXT XTHRW5)		;NOTE WHAT GETS POPPED FROM MICRO STACK VIA THIS PATH
       ((C-PDL-BUFFER-INDEX) DPB M-E A-B (LISP-BYTE %%LP-EXS-EXIT-PC))  ;HAD BETTER NOT HAVE
				;%%-PPSPC SET.  THIS WOULD CORRESPOND TO A MISC-INST MAKING
				;A BINDING BLOCK, WHICH IS ILLEGAL.

XTHRW6A	(CALL QUNBND)		;POP BINDING AND DROP THRU. CLOBBERS M-C.
 ;ON ENTRY HERE, M-D HAS PDL-BUFFER INDEX OF ADI-RESTART-PC ADI, OR -1 IF NONE.
XTHRW6	(JUMP-LESS-THAN M-D A-ZERO XTHRW6B)	;IF ENCOUNTERED *CATCH W/O ADI-RESTART-PC ADI,
			;DONT TRY TO HACK BIND STACK.  THIS CAN HAPPEN VIA INTERPRETED 
			;*CATCH S.  SINCE FRAME DESTINATION MUST BE D-RETURN,
			;NO NEED TO HACK BIND STACK ANYWAY.
	((PDL-BUFFER-INDEX) SUB M-D (A-CONSTANT 3))  ;MOVE BACK TO THE DATA Q 
		;PREVIOUS ADI BLOCK WHICH HAD BETTER BE AN ADI-BIND-STACK-LEVEL BLOCK
	((M-B) Q-POINTER C-PDL-BUFFER-INDEX)	;GET BIND-STACK-LEVEL
	(JUMP-IF-BIT-CLEAR BOXED-SIGN-BIT M-B XTHRW6C)  ;SIGN EXTEND SINCE EMPTY STACK
	((M-B) SELECTIVE-DEPOSIT M-B Q-POINTER (A-CONSTANT -1)) ;IS LEVEL OF -1
XTHRW6C	((M-J) A-QLBNDP)		; COMPUTE CURRENT RELATIVE STACK LEVEL
	((M-J) SUB M-J A-QLBNDO)
	(CALL-LESS-THAN M-J A-B ILLOP)	;ALREADY OVERPOPPED?
	(JUMP-NOT-EQUAL M-J A-B XTHRW6A) ;EVIDENTLY A BIND WAS DONE WITHIN THIS BLOCK ..
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))  ;STORE BACK QBBFL
	((M-B) C-PDL-BUFFER-INDEX)		;WHICH MAY HAVE BEEN CLEARED
	((C-PDL-BUFFER-INDEX) DPB M-FLAGS (LISP-BYTE %%LP-EXS-PC-STATUS) A-B)
XTHRW6B	((M-B) SUB M-I A-AP)			;THIS EFFECTIVELY CANCELS WHAT WILL BE
	((M-B) (BYTE-FIELD 10. 0) M-B)		; DONE AT QMEX1
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	((M-AP) (BYTE-FIELD 10. 0) M-I)		;SIMULATE ACTIVATING CATCH FRAME
	(JUMP-NOT-EQUAL A-CATCH-ACTION M-R XUWR2);ACTION NON-NIL => DONT REALLY RESUME
						; EXECUTION, COROUTINE BACK INSTEAD.
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMEX1)))
	(CALL XRNVR)				;FIRST VALUE IS VALUE THROWN (STILL IN M-T)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC QMEX1)))
	(CALL-XCT-NEXT XRNVR)			;SECOND VALUE IS TAG
       ((M-T) A-CATCH-TAG)
	(JUMP-XCT-NEXT QMEX1)			;THIRD VALUE IS COUNT, ACTION KNOWN TO BE NIL
       ((M-T) A-CATCH-COUNT)			; SO WE DON'T BOTHER RETURNING THAT 4TH VALUE

XTHRW8	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)
	((PDL-BUFFER-INDEX M-D) SUB M-D (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX XTHRW9)
	((PDL-BUFFER-INDEX M-D) SUB M-D (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTHRW3)
       ((M-D) (BYTE-FIELD 10. 0) M-D)	;ASSURE M-D POSITIVE SO CHECK AT XTHRW6 WINS.

;RAN OUT OF ADI.  THE SAVED DESTINATION HAD BETTER BE D-RETURN OR ERROR.  THIS
;CAN HAPPEN MAINLY THRU INTERPRETED CALLS TO *CATCH.
XTHRW9	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-C (A-CONSTANT 4) ILLOP)	;D-RETURN
	((M-D) (M-CONSTANT -1))		;SET FLAG THAT RESTART-PC ADI NOT FOUND, SO
				;BIND PDL HACKERY NOT ATTEMPTED.
	((M-S) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) C-PDL-BUFFER-INDEX)
	((M-I) SUB M-I A-S)
	(JUMP-XCT-NEXT XTHRW5)
       ((M-J) M-ZERO)

;SKIP THIS OPEN FRAME
XTHRW2	((PDL-BUFFER-INDEX) ADD M-I (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-ZR) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK)  C-PDL-BUFFER-INDEX)
	((M-ZR) SUB M-I A-ZR)
	(JUMP-XCT-NEXT XTHRW7)
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;ASSURE NO GARBAGE IN A-IPMARK

;UNWIND AN ACTIVE FRAME
XTHRW1	((M-TEM) MICRO-STACK-POINTER)		;INVOLVES A LDB OP
	(JUMP-EQUAL M-TEM A-ZERO XTHRW1A)	;FLUSH MICRO-STACK
	((M-TEM) MICRO-STACK-DATA-POP)
	(JUMP-XCT-NEXT XTHRW1)
       (CALL-IF-BIT-SET %%-PPBSPC M-TEM BBLKP)

XTHRW1A	((M-TEM) A-CATCH-TAG)			;CHECK FOR THROW TAG OF 0
	(JUMP-EQUAL M-TEM (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		QMDDR0)				;YES, RETURN FROM THIS FRAME
	(JUMP-EQUAL M-R A-CATCH-COUNT XTHRW1B)	;JUMP IF NO COUNT
	((A-CATCH-COUNT Q-R) ADD A-CATCH-COUNT (M-CONSTANT -1))
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 23.) Q-R XUWR1)  ;REACHED MAGIC COUNT, RESUME BY RETURNING
XTHRW1B	(CALL-IF-BIT-SET M-QBBFL BBLKP)  	;POP BINDING-BLOCK IF FRAME HAS ONE
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) C-PDL-BUFFER-INDEX)
	((M-ZR) SUB M-AP A-TEM1)		;COMPUTE PREV A-IPMARK
	((A-IPMARK) (BYTE-FIELD 10. 0) M-ZR)	;RESTORE THAT
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-ACTIVE-BLOCK) C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL A-TEM1 M-ZERO XTHRWX)	;OFF THE BOTTOM OF THE STACK
	((PDL-BUFFER-POINTER) SUB M-AP (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH))) ;FLUSH PDL
	(CALL-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT)
		C-PDL-BUFFER-INDEX QRAD1R)	;FLUSH ADDTL INFO
	((PDL-BUFFER-INDEX) SUB M-AP A-TEM1)	;RESTORE M-AP
	((M-AP) PDL-BUFFER-INDEX)	;THIS MASKS M-AP TO 10 BITS
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-PDL-BUFFER-ACTIVE-QS A-TEM1)
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS 
			(A-CONSTANT PDL-BUFFER-LOW-WARNING) PDL-BUFFER-REFILL)
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX)		;SIMULATES THRWD3 DISP IN LMI
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) XTHWL3)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) XTHWU3)  ;MICRO-CODE OR STACK-GROUP
XTHWM3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	(JUMP-XCT-NEXT XTHRW7)
       ((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
;NOT NECESSARY TO SET UP MACRO-PC SINCE WILL GO THRU QMEX1 BEFORE TRYING TO RUN FRAME

XTHWL3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-LAST-MICRO-ENTRY) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC) C-PDL-BUFFER-INDEX)
	(CALL-NOT-EQUAL M-LAST-MICRO-ENTRY (A-CONSTANT (I-MEM-LOC INTRET)) ILLOP)
XTHWU3	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-FLAGS) (LISP-BYTE %%LP-EXS-PC-STATUS) C-PDL-BUFFER-INDEX A-FLAGS)
	(CALL QMMPOP)		;RESTORE USTACK FROM BINDING STACK
	(JUMP XTHRW7)

;DROPPED OFF BOTTOM OF PDL.  LAST ACTIVE FRAME IS STILL PRESENT, BUT ITS BINDINGS ARE GONE.
XTHRWX	((M-1) A-V-TRUE)
	(JUMP-EQUAL A-CATCH-TAG M-1 XUWR2)	;SUPPOSED TO THROW ALL THE WAY
	(CALL ILLOP)				;NOT SUPPOSED TO, BARF, SHOULD HAVE DETECTED
						;THIS ON THE FIRST PASS

;HERE WHEN THE COUNT RUNS OUT
XUWR1	(JUMP-EQUAL A-CATCH-ACTION M-R QMDDR0)  ;CAUSE ACTIVE FRAME TO RETURN VALUE
;HERE TO COROUTINE BACK (ACTION NOT NIL)
XUWR2	((M-A) A-SG-PREVIOUS-STACK-GROUP)       ;FAKE UP A CALL TO THE ERROR SG.
	((A-SG-TEM) A-V-NIL)	;VALUE TO TRANSMIT.
	((A-SG-TEM1) A-V-NIL)	;ARGUMENT LIST.
	((A-NARGS) M-ZERO)	;NO ARGUMENTS.
	(JUMP-XCT-NEXT SG-CALL-2)
       ((M-B) SETO)	;THIS IS A SIMPLICFICATION FOR THE TIME BEING TO SAVE UCODE.
			; SHOULD FETCH STATE OF SG, WORRY ABOUT CALLING-ARGS-POINTER, ETC.
			; BUT THIS SHOULD DO THE RIGHT THING FOR THE TIME BEING.
			;The SETO is so that a swap will happen.

XCATCH (MISC-INST-ENTRY *CATCH)		;ONLY GET HERE WHEN NO *THROW 
	(POPJ-AFTER-NEXT 		;*CATCH WHICH COMPLETES RETURNS NIL AS SECOND VALUE
	 (M-T) C-PDL-BUFFER-POINTER-POP) ;VALUE OF FROB
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)

;	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC CPOPJ)))  ;IF ONLY ONE VALUE
;				;DESIRED, JUST POPJ
;;NOTE THIS ONLY WINS FOR MACRO-MICRO CALL. TO WIN FOR MICRO-MICRO, IT WOULD HAVE TO
;;  GO THRU HAIR TO LOCATE THE ADI, ETC ETC
;	(CALL-XCT-NEXT XRNVR)
;       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)  ;FLUSH FIRST ARG (WHICH WAS CATCH TAG)
;	(POPJ-AFTER-NEXT 
;	 (M-T) A-V-TRUE)  ;SECOND VALUE OF T SIGNALS EVALUATION COMPLETED NORMALLY
;       (NO-OP)

XCTO (MISC-INST-ENTRY %CATCH-OPEN)
	((M-T) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
				  *CATCH-U-CODE-ENTRY-/#)))
XERO1	((M-GARBAGE) MICRO-STACK-DATA-POP)
;;;RESTART ADR ON PDL WITH FLAG-BIT CLEAR.  LEAVE IT THERE TO BECOME FIRST WD OF ADI
	(CALL-XCT-NEXT SBPL-ADI)	;PUSH ADI-BIND-STACK-LEVEL BLOCK
       ((M-S) C-PDL-BUFFER-POINTER-POP)		;GET RESTART PC OFF STACK
	((C-PDL-BUFFER-POINTER-PUSH)
		DPB (M-CONSTANT -1) Q-FLAG-BIT A-S)	;PUSH RESTART PC
	((M-R) MICRO-STACK-POINTER)			;BACK.
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-R (BYTE-FIELD 5. 0)
	     (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RESTART-PC))))
	
SBPL-ADI((M-1) A-QLBNDP)		;STORE ADI-BIND-STACK-LEVEL ADI BLOCK
	((M-1) SUB M-1 A-QLBNDO)
	(POPJ-AFTER-NEXT 
	 (C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH) 
		(A-CONSTANT (PLUS (PLUS 
		  (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		  (BYTE-VALUE Q-FLAG-BIT 1))
		  (BYTE-VALUE %%ADI-TYPE ADI-BIND-STACK-LEVEL))))

XCTOM (MISC-INST-ENTRY %CATCH-OPEN-MV)
	((M-T) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-U-ENTRY)
				  *CATCH-U-CODE-ENTRY-/#)))
XEROM1	((M-GARBAGE) MICRO-STACK-DATA-POP)
	((M-D) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;# VALS TO BE RECVD
	(CALL-XCT-NEXT LMVRB)				;LEAVE RM ON PDL TO RECEIVE VALS
       ((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;RESTART PC
	(CALL SBPL-ADI)		;PUSH ADI-BIND-STACK-LEVEL BLOCK
	((C-PDL-BUFFER-POINTER-PUSH) DPB (M-CONSTANT -1) Q-FLAG-BIT A-S)
	((M-R) MICRO-STACK-POINTER)
        ((C-PDL-BUFFER-POINTER-PUSH) DPB M-R (BYTE-FIELD 5. 0)
	     (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RESTART-PC))))
	(JUMP-XCT-NEXT XCTOM1)
       ((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K) ;THIS ISN'T LAST ADI

XLEC (MISC-INST-ENTRY %LEXPR-CALL)
	(JUMP-XCT-NEXT XLEC1)
       ((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-LEXPR-CALL))))

XFEC (MISC-INST-ENTRY %FEXPR-CALL)
	((M-S) (A-CONSTANT (PLUS (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
XLEC1	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((M-T) C-PDL-BUFFER-POINTER-POP)	;FUNCTION TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH) M-S)	;STORE ADI

XLECM (MISC-INST-ENTRY %LEXPR-CALL-MV)
	(JUMP-XCT-NEXT XLECM1)
       ((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-LEXPR-CALL))))

XFECM (MISC-INST-ENTRY %FEXPR-CALL-MV)
	((M-S) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
XLECM1	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	((M-D) C-PDL-BUFFER-POINTER-POP)	;NUMBER OF VALUES DESIRED
	(CALL-XCT-NEXT LMVRB)			;MAKE ROOM ON PDL
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FCN TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) M-S)	;STORE ADI
	(JUMP-XCT-NEXT XCTOM1)
       ((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K) ;THIS ISN'T LAST ADI

XC0MVL (MISC-INST-ENTRY %CALL0-MULT-VALUE-LIST)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	(CALL XCMVL0)
	(JUMP QMRCL)

XCMVL (MISC-INST-ENTRY %CALL-MULT-VALUE-LIST)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
XCMVL0	((M-T) C-PDL-BUFFER-POINTER-POP)	;FCN TO CALL
	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;INIT CDR OF LIST, ON RET WILL BE LIST
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) PDL-BUFFER-POINTER)		;GET LOCATIVE POINTER TO THAT NIL
	((C-PDL-BUFFER-POINTER-PUSH) M-K)	;AS 2ND ADI WORD
	(JUMP-XCT-NEXT XCTO1)
       ((C-PDL-BUFFER-POINTER-PUSH)		;ADI FOR RETURN VALUES INFO
	     (A-CONSTANT (PLUS (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-MAKE-LIST))))

XC0MV (MISC-INST-ENTRY %CALL0-MULT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
	(CALL XCMV0)
	(JUMP QMRCL)

XCMV (MISC-INST-ENTRY %CALL-MULT-VALUE)
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;DON'T RETURN TO 'MISC'
XCMV0	((M-D) C-PDL-BUFFER-POINTER-POP)	;# VALUES DESIRED
XCMV1	(CALL-XCT-NEXT LMVRB)			;MAKE ROOM ON PDL
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;FCN TO CALL
XCTOM1	((C-PDL-BUFFER-POINTER-PUSH) M-K)	;RETURN VALUES BLOCK POINTER
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-D	;ADI FOR RETURN VALUES INFO
	  (LISP-BYTE %%ADI-RET-NUM-VALS-EXPECTING)
	     (A-CONSTANT (PLUS (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-BLOCK))))
XCTO1	(CALL CBM)				;STORE CALL BLOCK
	(POPJ-AFTER-NEXT
	 (PDL-BUFFER-INDEX) ADD M-ZR (A-CONSTANT (EVAL %LP-CALL-STATE)))
       ((C-PDL-BUFFER-INDEX) IOR C-PDL-BUFFER-INDEX
		(A-CONSTANT (BYTE-MASK %%LP-CLS-ADI-PRESENT)))

LMVRB	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE M-D TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ADI)
	((M-D) Q-POINTER M-D)
	(CALL-GREATER-THAN M-D (A-CONSTANT 100) TRAP)
   (ERROR-TABLE MVR-BAD-NUMBER M-D)
ULMVRB	(CALL-EQUAL M-D A-ZERO TRAP)
   (ERROR-TABLE MVR-BAD-NUMBER M-D)
	((M-K) PDL-BUFFER-POINTER)		;LOC OF BLOCK AS PDL INDEX
	((M-E) M-D)
LMVRB1	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;RESERVE SLOTS, FILL WITH NIL
	(JUMP-GREATER-THAN-XCT-NEXT M-E (A-CONSTANT 1) LMVRB1)
       ((M-E) SUB M-E (A-CONSTANT 1))
	(JUMP-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;RET BLK PNTR AS LOCATIVE
       ((M-K) ADD M-K (A-CONSTANT 1))		;FIX POINTER

;;; "LINEAR" ENTER
;   M-A HAS PNTR TO FEF TO CALL
;   M-S HAS EVENTUAL NEW ARG POINTER
;NO SEQUENCE BREAKS CAN BE TAKEN IN HERE, MOSTLY BECAUSE ALL KINDS OF
;FUNNY DATA ARE FLYING AROUND IN THE ACS, BUT ALSO BECAUSE THE  
;PDL STRUCTURE MAY NOT BE TOTALLY CONSISTENT.
;ALSO, WE DON'T SUPPORT USER COPYING AND FORWARDING OF FEFS,
;SO IT'S NOT NECESSARY TO CALL THE TRANSPORTER EVERYWHERE.  NOTE THAT
;IF THE FEF GETS TRANSPORTED BY SOME OPERATION IN HERE SUCH AS A SPECIAL
;VARIABLE ACCESS CAUSING A FLIP, WE RELY ON OUR REGISTER M-A TO GET FIXED UP.

QLENTR	((M-B) SUB M-S A-AP)			;ASSURE ROOM IN PDL-BUFFER
	((M-B) (BYTE-FIELD 10. 0) M-B)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)
       ((M-AP) M-S)	;NEW ARG POINTER (DO THIS RIGHT AWAY TO MINIMIZE PROBLEMS IF ERR OUT)
	((VMA-START-READ) M-A)
	(CHECK-PAGE-READ)
	((M-ERROR-SUBSTATUS) M-ZERO)	;CLEAR OUT ERRORS
	((A-LCTYP) M-ZERO)		;CLEAR OUT LINEAR-CALL-TYPE 
	((M-D) Q-POINTER READ-MEMORY-DATA)	;GET FEF HEADER WORD
	((M-B) (LISP-BYTE %%HEADER-TYPE-FIELD) M-D)
	(CALL-NOT-EQUAL M-B (A-CONSTANT (EVAL %HEADER-TYPE-FEF)) ILLOP)	;NOT FEF
	((A-TEMPC) (LISP-BYTE %%FEFH-PC) M-D)	;MAY GET CHANGED DUE TO OPTIONAL ARGS.
					; ALSO NOTE RELATIVE TO FEF STILL
	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-CALL-STATE)))
	(JUMP-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT) 
			C-PDL-BUFFER-INDEX QLEAI1)  ;FEXPR OR LEXPR ?
QLEAI2	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEFH-FAST-ARG) M-D QRENT)  ;NO FAST-OPTION
;NEED ERRONEOUS QUOTED ARG CHECK
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-FAST-ARG-OPT)))
	(CHECK-PAGE-READ)		;GET FAST-OPTION WORD
	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP FEF)
	((M-C) (LISP-BYTE %%FEFHI-FSO-MIN-ARGS) READ-MEMORY-DATA)
	(CALL-GREATER-THAN M-C A-NARGS SET-TOO-FEW-ARGS)
	((M-E) (LISP-BYTE %%FEFHI-FSO-MAX-ARGS) READ-MEMORY-DATA)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-QUOTED-REST) READ-MEMORY-DATA QLFOA1)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-EVALED-REST) READ-MEMORY-DATA QLFOA1)
	((A-QLOCO Q-R) ADD M-E (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	((A-TEM1) DPB Q-R (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-Q) A-NARGS)
	((M-C) DPB M-Q (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-TEM1)
QLEAI5	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((C-PDL-BUFFER-INDEX) M-C)		;STORE ENTRY STATE Q
	(CALL-LESS-THAN M-E A-NARGS SET-TOO-MANY-ARGS)
QFL2	(JUMP-LESS-OR-EQUAL M-E A-NARGS QFL1)
	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;DEFAULT UNSUPPLIED ARGS TO NIL
	(JUMP-XCT-NEXT QFL2)
       ((M-E) SUB M-E (A-CONSTANT 1))

SET-TOO-FEW-ARGS
	(POPJ-AFTER-NEXT (M-QBTFA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
       (NO-OP)

SET-TOO-MANY-ARGS
	(POPJ-AFTER-NEXT (M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
       (NO-OP)

;HAVE SET UP ARGS
QFL1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((M-T) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
QFL1C	(JUMP-EQUAL M-T A-ZERO QFL1A)
QFL1B	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL) 	;INIT LOCAL BLOCK TO NIL
	(JUMP-GREATER-THAN-XCT-NEXT M-T (A-CONSTANT 1) QFL1B)
       ((M-T) SUB M-T (A-CONSTANT 1))
QFL1A	(CALL-IF-BIT-SET (LISP-BYTE %%FEFH-SV-BIND) M-D FRMBN1)  ;MOVE S-V BINDINGS TO
		;S-V-CELLS AND PUSH PREVIOUS BINDINGS ON BINDING PDL (M-D HAS %FEFHI-IPC STILL)
;FINISH LINEARLY ENTERING
QLENX	((M-TEM) DPB M-A (BYTE-FIELD 24. 1) (A-CONSTANT 0))	;NOW UNRELOCATE PC
	((LOCATION-COUNTER) ADD M-TEM A-TEMPC OUTPUT-SELECTOR-LEFTSHIFT-1)
	(POPJ-EQUAL-XCT-NEXT M-ERROR-SUBSTATUS A-ZERO)	;RETURN TO MAIN LOOP IF NO ERROR
       ((A-IPMARK) (BYTE-FIELD 10. 0) M-AP)	;NO OPEN CALL BLOCK YET
QLEERR	((C-PDL-BUFFER-POINTER-PUSH) DPB M-ERROR-SUBSTATUS Q-POINTER ;PUSH M-ERROR-SUBSTATUS 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ; ONTO STACK SO ERROR HANDLER
	(CALL TRAP)					       ; CAN FIND IT.
   (ERROR-TABLE FUNCTION-ENTRY) ;This table entry is specially known about.

;Here if the function takes a rest arg.  M-E has # reg+opt args.
;ADL not being used, fast-arg option is active.
QLFOA1	(JUMP-NOT-EQUAL-XCT-NEXT A-LCTYP M-ZERO QLFRA1)	;Called with LEXPR/FEXPR call
       ((M-J) A-NARGS)				;For QLFOA5, QLFSA2
	;; Called with just spread arguments.
	;; If the rest arg will be NIL, push NILs for it and any missing optionals.
	(JUMP-LESS-THAN M-E A-NARGS QLFSA2)
	((M-TEM) SUB M-E A-NARGS)		;1- number of NILs to push
QLFSA1	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)
	(JUMP-GREATER-THAN-XCT-NEXT M-TEM A-ZERO QLFSA1)
       ((M-TEM) SUB M-TEM (A-CONSTANT 1))
	((A-QLOCO Q-R) ADD M-E (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	;; Args set up.  Set up entry-state and local-block (offset is in Q-R and A-QLOCO)
QLFOA5	((PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	((A-TEM1) DPB M-J (LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-INDEX) DPB Q-R (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		A-TEM1)
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((M-T) (LISP-BYTE %%FEFHI-MS-LOCAL-BLOCK-LENGTH) READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QFL1C)
       ((M-T) SUB M-T (A-CONSTANT 1))		;First local (rest arg) already pushed

	;; Called with enough spread args to get into the rest arg
QLFSA2	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M+A+1 M-S A-E)		;First of rest, %LP-INITIAL-LOCAL-BLOCK-OFFSET = 1
	((C-PDL-BUFFER-POINTER-PUSH)		;Push the rest-arg
		Q-POINTER M-K (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(JUMP-XCT-NEXT QLFOA5)			;Put the local block after the supplied args
       ((A-QLOCO Q-R) ADD M-J (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))

	;; Called with a rest arg.
QLFRA1	((M-TEM) ADD (M-CONSTANT -1) A-NARGS)	;Number of spread args
	(JUMP-EQUAL-XCT-NEXT M-E A-TEM QLFOA5)	;Matches number desired, enter
       ((A-QLOCO Q-R) ADD M-TEM (A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))
	(CALL ILLOP)				;Could use QRENT, but would ILLOP at QBNDL2

;ADDITIONAL INFO, SEE IF LEXPR OR FEXPR CALL
QLEAI1	((M-K PDL-BUFFER-INDEX) ADD M-S (A-CONSTANT (EVAL (1- %LP-CALL-STATE))))
QLEAI3	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP FEF)
	(DISPATCH (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX D-QLEAI3)
	(JUMP-XCT-NEXT QLEAI2)	;FEXPR OR LEXPR, REMEMBER WIERD CALL TYPE
       ((A-LCTYP) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)

QLEAI4	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)	;IGNORE OTHER ADI
	((M-K PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX QLEAI2);ALL ADI DONE
	(JUMP-XCT-NEXT QLEAI3)
       ((M-K PDL-BUFFER-INDEX) SUB M-K (A-CONSTANT 1))

;LINEAR ENTER WITHOUT FAST OPTION
QRENT	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-MISC)))
	(CHECK-PAGE-READ)
	((M-D PDL-BUFFER-INDEX) ADD M-S
		(A-CONSTANT (EVAL %LP-INITIAL-LOCAL-BLOCK-OFFSET)))        ;-> FIRST ARG
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)));-> S-V SLOTS
	((A-ARGS-LEFT) A-NARGS)					      ;# ARGS YET TO DO
	((A-TEM1) (LISP-BYTE %%FEFHI-MS-ARG-DESC-ORG) READ-MEMORY-DATA)
	((M-I) ADD A-TEM1 M-A)					    ;-> FIRST BIND DESC
	((M-R) (LISP-BYTE %%FEFHI-MS-BIND-DESC-LENGTH) READ-MEMORY-DATA)  ;# BIND DESCS
	((A-QLOCO) SETCA A-ZERO)		    ;SIGNAL LOCAL BLOCK NOT YET LOCATED
;	((A-QRSPCF) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;NO SPECIALS-IN-BLOCK
	(JUMP-EQUAL A-LCTYP M-ZERO QBINDL)
	((A-ARGS-LEFT) ADD (M-CONSTANT -1) A-ARGS-LEFT) ;WAS FEXPR OR LEXPR CALL
			;FLUSH NO-SPREAD-ARG AND PROCESS ANY SPREAD ARGS
;BIND LOOP USED WHILE ARGS REMAIN TO BE PROCESSED
QBINDL	(JUMP-GREATER-OR-EQUAL M-ZERO A-ARGS-LEFT QBD0)	;OUT OF SPREAD ARGS
	(JUMP-LESS-THAN
		M-R (A-CONSTANT 1) QBTMA1) ;OUT OF BIND DESC, TOO MANY ARGS
	((VMA-START-READ) M-I)		;ACCESS WORD OF BINDING OPTIONS
	(CHECK-PAGE-READ)
	((M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA QBNDL1)
	((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)	;SKIP NAME Q IF PRESENT
QBNDL1	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QREDT1)
       ((M-Q) READ-MEMORY-DATA)		;SAVE BIND DESC IN M-Q

QREW1	(CALL-LESS-THAN M-R (A-CONSTANT 1) ILLOP)
	((VMA-START-READ) M-I)		;ACCESS WORD OF BINDING OPTIONS
	(CHECK-PAGE-READ)
	((M-R) SUB M-R (A-CONSTANT 1))
	((M-Q) READ-MEMORY-DATA)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) M-Q QBNDL2)
	((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)	;SKIP NAME Q IF PRESENT
QBNDL2	((M-E) (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q)
	(JUMP-NOT-EQUAL M-E (A-CONSTANT 2) ILLOP)	;WASN'T REST ARG??
	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;SET UP LOCAL BLOCK OVER ARG
	((PDL-BUFFER-POINTER) M-D)		;SO DONT STORE LOCALS OVER ARG
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;OPTIONAL ARG IS PRESENT, SPACE PAST INITIALIZATION INFO IF ANY
QBROP1	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPNP)

QBOSP	(JUMP-XCT-NEXT QBRQA)
       ((M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)

QBOASA	((VMA-START-READ M-I) ADD A-ZERO M-I ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	((A-TEMPC) Q-POINTER READ-MEMORY-DATA)	;START LATER TO AVOID CLOBBERING

;REQUIRED ARGUMENT IS PRESENT
QBRQA	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBSPCL)

;ENTER HERE WHEN ARG HAS BEEN BOUND.  THESE CHECKS ONLY CAUSE EXCEPTIONS
QBDL1	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-DES-DT) M-Q QBDDT)
       ((M-C) Q-DATA-TYPE C-PDL-BUFFER-INDEX)
QBDDT1	;(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-QUOTE-STATUS) M-Q QBEQC)
       ;((M-C) Q-FLAG-BIT C-PDL-BUFFER-INDEX)
QBEQC1	((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE) ;NEXT ARG SLOT
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE) ;NEXT BIND DESC ENTRY
	(JUMP-XCT-NEXT QBINDL)			;PROCEED TO NEXT ARG
       ((A-ARGS-LEFT) ADD (M-CONSTANT -1) A-ARGS-LEFT)

;REST ARG - FOR NOW I ASSUME MICRO-COMPILED FUNCTIONS DO STORE CDR CODES
QBRA	(CALL-NOT-EQUAL A-LCTYP M-ZERO ILLOP)	;IF A NON-SPREAD ARG, SHOULD NOT
						;GET TO REST ARG HERE.
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)	;MAKE PNTR TO LIST OF ARGS
       ((M-K) M-D)
	(CALL-GREATER-THAN-XCT-NEXT M-ZERO A-QLOCO QLLOCB)
       ((M-D) ADD M-D A-ARGS-LEFT)	 	;LOCATE LOCAL BLOCK AFTER LAST ARG
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-K	;STORE REST ARG AS FIRST LOCAL
		Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CALL-IF-BIT-SET (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;ADVANCE TO NEXT BIND DESC

QBD0	(JUMP-NOT-EQUAL A-LCTYP M-ZERO QREW1)	;ALSO IS A NO-SPREAD ARG
;BINDING LOOP FOR WHEN ALL ARGS HAVE BEEN USED UP
QBD1	(JUMP-LESS-THAN
		M-R (A-CONSTANT 1) QBD2)	;JUMP IF FINISHED ALL BINDING
	((VMA-START-READ) M-I)			;GET NEXT BINDING DESC Q
	(CHECK-PAGE-READ)
	((M-R) SUB M-R (A-CONSTANT 1))
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-NAME-PRESENT) READ-MEMORY-DATA QBD2A)
	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)	;SKIP NAME IF PRESENT
QBD2A	(DISPATCH-XCT-NEXT (LISP-BYTE %%FEF-ARG-SYNTAX) READ-MEMORY-DATA QBDT2)
       ((M-Q) READ-MEMORY-DATA)			;SAVE BINDING DESC IN M-Q

;LOCATE LOCAL BLOCK TO WHERE M-D POINTS
;AFTER THIS HAS BEEN CALLED, USE C-PDL-BUFFER-POINTER-PUSH TO STORE LOCALS
QLLOCB	(POPJ-AFTER-NEXT		;PDL-BUFFER-PTR SHOULD BE SET ALREADY?
					;  --NOT IF TOO FEW ARGS FOR ONE--.
	 (PDL-BUFFER-POINTER) SUB M-D (A-CONSTANT 1))	;FIRST PUSH WILL STORE @ M-D
       ((A-QLOCO) SUB M-D A-S)			;OFFSET FROM AP TO LOCALS

;GOT ARG DESCRIPTOR WHEN OUT OF ARGS
QBTFA1	((M-QBTFA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)	 ;TOO FEW ARGS
	((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE) ;GENERATE A NULL ARG.
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-INDEX) A-V-NIL)

QBRA1	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;REST ARG MISSING, MAKE 1ST LOCAL NIL	
QBOPT2	((C-PDL-BUFFER-POINTER-PUSH) A-V-NIL)	;STORE MISSING ARG AS NIL (CDR CODE?)
QBD1A	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
       ((M-D) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
QBDIN1	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;INTERNAL
QBDINT	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN2)
	(JUMP-XCT-NEXT QBDIN1)	;IF SPECIAL, NO LOCAL SLOT, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

QBDIN2	(JUMP-XCT-NEXT QBOPT2)	;IF LOCAL, IGNORE AT BIND TIME BUT RESERVE LOCAL SLOT
       (CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;ALSO MUST LOCATE LOCAL BLOCK


;FREE
QBDFRE	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBDIN1) ;TAKES NO LCL SLOT
	(JUMP-XCT-NEXT QBDIN1)				    ;IF SPECIAL, TAKES S-V SLOT
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)

;AUX
QBDAUX	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)	;LOCATE LOCAL BLOCK, 
						; THEN DROP THROUGH TO INITIALIZE
QBOPT4	(DISPATCH (LISP-BYTE %%FEF-INIT-OPTION) M-Q QBOPTT)

;OPTIONAL NOT PRESENT
QBOPT1	(JUMP-GREATER-THAN M-ZERO A-QLOCO QBOPT4)
	(CALL ILLOP)		;SHOULDN'T HAVE ARGS AFTER LOCAL BLOCK IS LOCATED

;OPTIONAL ARGUMENT INIT VIA ALTERNATE STARTING ADDRESS AND NOT PRESENT
;LEAVE STARTING ADDRESS ALONE AND INIT TO SELF, COMPILED CODE WILL
;RE-INIT.  BUT DON'T FORGET TO SKIP OVER THE START ADDRESS.
QBOPT5	((M-I) ADD M-I (A-CONSTANT 1))
;OPTIONAL OR AUX, INIT TO SELF OR NONE, LATER MAY BE REINITED BY COMPILED CODE
QBOPT3	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%FEF-SPECIAL-BIT)
			M-Q QBOPT2)		;LOCAL, INIT TO NIL
	((VMA-START-READ) M-T)			;SPECIAL, GET POINTER TO VALUE CELL
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-TRAP READ-MEMORY-DATA)	;FETCH EXTERNAL VALUE CELL.
							;MUST GET CURRENT VALUE, BUT NOT BARF
							;IF DTP-NULL.  MUST NOT LEAVE AN EVCP
							;SINCE THAT WOULD SCREW PREVIOUS
							;BINDING IF IT WAS SETQ'ED.
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)
;THIS IS LIKE QBD1A, EXCEPT THAT THE THING WE ARE BINDING IT TO
;MAY BE DTP-NULL, WHICH IS ILLEGAL TO LEAVE ON THE PDL BUFFER.
;ALSO, THE VARIABLE IS KNOWN NOT TO BE AN ARGUMENT THAT WAS SUPPLIED,
;SO THERE'S NO DANGER OF CLOBBERING USEFUL DEBUGGING INFORMATION
	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEF-SPECIAL-BIT) M-Q QBLSPCL)
       ((M-D) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
	((C-PDL-BUFFER-POINTER) A-V-NIL)	;STORE NIL OVER POSSIBLE GARBAGE
	(JUMP-XCT-NEXT QBD1)
       ((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)

;INIT TO POINTER
QBOPNR	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ) M-I)			;FETCH THING TO INIT TOO, TRANSPORT IT
QBDR1	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)

;INIT TO C(POINTER)
QBOCPT	((M-I) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	((VMA-START-READ) M-I)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) READ-MEMORY-DATA)

;INIT TO CONTENTS OF "EFFECTIVE ADDRESS"
QBOEFF	((M-I VMA-START-READ) ADD M-I A-ZERO ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 6) READ-MEMORY-DATA QBOFDT) ;DISPATCH ON REG
       ((M-1) (BYTE-FIELD 6 0) READ-MEMORY-DATA)	;PICK UP DELTA FIELD

QBFE	((M-1) (BYTE-FIELD 8 0) READ-MEMORY-DATA)	;FULL DELTA
	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) ADD M-A A-1)		;FETCH FROM FEF OF FCN ENTERING

QBQT	(JUMP-XCT-NEXT QBDR1)
       ((VMA-START-READ) ADD M-1 A-V-CONSTANTS-AREA)	;FETCH FROM CONSTANTS PAGE

QBDLOC	(CALL-GREATER-THAN M-ZERO A-QLOCO ILLOP) ;TRYING TO ADDRESS LOCALS BEFORE LOCATED
	((M-1) ADD M-1 A-QLOCO)
	((PDL-BUFFER-INDEX) ADD M-1 A-S)	 ;FETCH LOCAL
	(JUMP-XCT-NEXT QBD1A)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

QBDARG	((PDL-BUFFER-INDEX) ADD M-1 A-S ALU-CARRY-IN-ONE)	;FETCH ARG
	(JUMP-XCT-NEXT QBD1A)		;(%LP-INITIAL-LOCAL-BLOCK-OFFSET = 1)
       ((C-PDL-BUFFER-POINTER-PUSH) C-PDL-BUFFER-INDEX)

;TOO MANY ARGS
QBTMA2	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	(DISPATCH-XCT-NEXT  (LISP-BYTE %%FEF-ARG-SYNTAX) M-Q QBDT2) ;FINISH BIND DESCS
       ((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCING LCL PNTR PAST THE EXTRA ARGS

;TOO MANY ARGS AND BIND DESC LIST ALL USED UP
QBTMA1	((M-QBTMA) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
	((M-D) ADD M-D A-ARGS-LEFT)	;ADVANCE LCL PNTR PAST THE EXTRA ARGS

;HERE WHEN BIND DESC LIST HAS BEEN USED UP
QBD2	(CALL-GREATER-THAN M-ZERO A-QLOCO QLLOCB)  ;SET UP LOCAL BLOCK
	((M-K) A-QLOCO)
	((A-TEM1) DPB M-K (LISP-BYTE %%LP-ENS-MACRO-LOCAL-BLOCK-ORIGIN)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;ASSEMBLE ENTRY STATE Q
			;WAS A-QRSPCF
	((M-K) A-NARGS)
	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-ENTRY-STATE)))
	(JUMP-XCT-NEXT QLENX)
       ((C-PDL-BUFFER-INDEX) DPB M-K
		(LISP-BYTE %%LP-ENS-NUM-ARGS-SUPPLIED) A-TEM1)

;COME HERE WHEN BINDING A SPECIAL TO A LOCAL
QBLSPCL	((PDL-BUFFER-INDEX) PDL-BUFFER-POINTER)

;COME HERE WHEN BINDING A SPECIAL
; NOTE CODE BELOW CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C.  THIS IS FOR THE BENEFIT OF
;FRMBN1.  ITS A CROCK, BUT NON-MODULARITY WAS DEEMED WORTH IT BECAUSE OTHERWISE
;CLEAR WOULD HAVE TO BE DONE IN A LOOP.
;NOTE THAT IF WE CAME HERE FROM QBOPT3 THERE MAY BE ILLEGAL DATA TEMPORARILY ON THE PDL BUFFER!
;LETTERED REGS CLOBBERED: M-B, M-J, M-K.  M-T HAS S-V PNTR TABLE ADDR, M-C HAS FLAGS.
QBSPCL	((VMA-START-READ) M-T)			;GET SPECIAL VALUE CELL POINTER
	(CHECK-PAGE-READ)
	((M-1) ADD (M-CONSTANT 23.) A-QLBNDP)	;TEST P.C.E. (THIS M-CONST JUST HAPPENED TO
	((M-1) SUB M-1 A-QLBNDH)		; BE AROUND AT THE WRONG TIME).
	(CALL-IF-BIT-CLEAR BOXED-SIGN-BIT M-1 ILLOP)  ;RESULT HAD BETTER BE NEGATIVE
						; (AS 24 BIT QUANTITY).
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA) ;TRANSPORT THE SPECIAL VALUE CELL PTR
	((VMA-START-READ M-B) DPB READ-MEMORY-DATA Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CHECK-PAGE-READ)			;GET CONTENTS OF INTERNAL VALUE CELL
;CODE BELOW IS LOGICALLY SOMEWHAT SIMILAR TO QBND2.
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((M-J) C-PDL-BUFFER-INDEX)		;GET VAL TO BIND TO (ARG OR LOCAL)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)	;CHASE FORWARDING PTR IF ANY
	((M-K) Q-TYPED-POINTER READ-MEMORY-DATA) ;BINDING TO SAVE
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT 
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER 
		A-J)		;NEW VALUE CELL CONTENTS
	(CHECK-PAGE-WRITE)
	((M-C) DPB M-ZERO (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) A-C) ;FOR FRMBN1'S BENEFIT
						;IF WE ARE COMING FROM THERE.
	(GC-WRITE-TEST)
	((WRITE-MEMORY-DATA) M-K)
	(JUMP-IF-BIT-SET-XCT-NEXT M-QBBFL QBSPCL1)	;JUMP IF NOT FIRST IN BLOCK
       ((M-T) ADD M-T A-ZERO ALU-CARRY-IN-ONE)	 ;ADVANCE TO NEXT S-V SLOT
	((M-K WRITE-MEMORY-DATA) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K)
	((M-QBBFL) DPB (M-CONSTANT -1) A-FLAGS)
QBSPCL1 ((VMA-START-WRITE) A-QLBNDP)
	(CHECK-PAGE-WRITE)
	((A-QLBNDP) ADD M-ZERO A-QLBNDP ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA) M-B)
	(POPJ-AFTER-NEXT 
	 (VMA-START-WRITE M-K) A-QLBNDP)	;CLEARS POSSIBLE INVISIBLE POINTER FROM M-K
       (CHECK-PAGE-WRITE)

;DATA TYPE CHECKS
QDTATM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
QDTN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-EXTENDED-NUMBER)) QBDDT1)
QBDDT3	(JUMP-XCT-NEXT QBDDT1)		;BAD DATA TYPE
       ((M-QBBDT) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)

QDTFXN	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FIX)) QBDDT1)
	(JUMP QBDDT3)

QDTSYM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-SYMBOL)) QBDDT1)
	(JUMP QBDDT3)

QDTLST	((M-C) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-C A-V-NIL QBDDT1)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-INDEX SKIP-IF-LIST)
	 (JUMP QBDDT3)
	(JUMP QBDDT1)

QDTFRM	(JUMP-EQUAL M-C (A-CONSTANT (EVAL DTP-FEF-POINTER)) QBDDT1)
	(JUMP QBDDT3)

;EVAL/QUOTE CHECKS
;QBEQE	(JUMP-EQUAL M-C A-ZERO QBEQC1)
;QBEQQ1	(JUMP-XCT-NEXT QBEQC1)
;      ((M-QBBQTS) DPB (M-CONSTANT -1) A-ERROR-SUBSTATUS)
;
;QBEQQ	(JUMP-NOT-EQUAL M-C A-ZERO QBEQC1)
;	(JUMP QBEQQ1)

;;FRAME BIND. BIND S-V S FROM FRAME FAST ENTERED USING S.V. MAP
FRMBN1	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL %FEFHI-SV-BITMAP)))
	(CHECK-PAGE-READ)
	((M-D PDL-BUFFER-INDEX) M-AP)
	((M-T) ADD M-A (A-CONSTANT (EVAL %FEFHI-SPECIAL-VALUE-CELL-PNTRS)))
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%FEFHI-SVM-ACTIVE) 
		READ-MEMORY-DATA ILLOP)  ;FOO FAST OPT 
			;SHOULD NOT BE ON UNLESS SVM IS. (IT ISNT WORTH IT TO HAVE
			;ALL THE HAIRY MICROCODE TO SPEED THIS CASE UP A TAD.)
	((M-C) (LISP-BYTE %%FEFHI-SVM-BITS) READ-MEMORY-DATA)
FRMBN2	(POPJ-EQUAL M-C A-ZERO)	  ;POPJ IF NO MORE BITS
	(CALL-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%FEFHI-SVM-HIGH-BIT) 
			M-C QBSPCL)	;QBSPCL CLEARS %%FEFHI-SVM-HIGH-BIT IN M-C
       ((M-D PDL-BUFFER-INDEX) ADD M-D A-ZERO ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT FRMBN2)
       ((M-C) M+M M-C A-ZERO)

;POP A BLOCK OF BINDINGS
BBLKP	(JUMP-XCT-NEXT BBLKP1)
       ((M-ZR) SETCA A-ZERO)

;POP A BINDING (MUSTN'T BASH M-T, M-J, M-R, M-D, M-C)
QUNBND	((M-ZR) A-ZERO)
BBLKP1	((VMA-START-READ) A-QLBNDP)		;GET PNTR TO BOUND CELL
	(CHECK-PAGE-READ)
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-Q) READ-MEMORY-DATA)
	((M-TEM) Q-DATA-TYPE M-Q)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-LOCATIVE)) ILLOP)
BBLKP3	((VMA-START-READ) A-QLBNDP)		;PREV CONTENTS
	(CHECK-PAGE-READ)
	((A-QLBNDP) ADD A-QLBNDP (M-CONSTANT -1))
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-B) READ-MEMORY-DATA)
	((VMA-START-READ) M-Q)	;ACCESS BOUND CELL
	(CHECK-PAGE-READ)		 	;NO SEQ BRK, CONTENTS PICKED UP
	(DISPATCH TRANSPORT-NO-EVCP-WRITE READ-MEMORY-DATA)	;FOLLOW ONE-Q-FORWARD
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-B)
	(CHECK-PAGE-WRITE)			;NO SEQ BRK, M-QBBFL INCONSISTENT
	(JUMP-IF-BIT-SET Q-FLAG-BIT M-B BBLKP2)	;JUMP IF LAST BINDING IN BLOCK
	(POPJ-EQUAL M-ZR A-ZERO)		;POPJ IF QUNBND
	(JUMP BBLKP1)				;LOOP IF BBLKP

BBLKP2	(POPJ-AFTER-NEXT
	 (M-QBBFL) DPB M-ZERO A-FLAGS)		;NO MORE B.B.
       (NO-OP)	

XUB (MISC-INST-ENTRY UNBIND-0)			;UNBIND N BLOCKS
    (MISC-INST-ENTRY UNBIND-1)
    (MISC-INST-ENTRY UNBIND-2)
    (MISC-INST-ENTRY UNBIND-3)
    (MISC-INST-ENTRY UNBIND-4)
    (MISC-INST-ENTRY UNBIND-5)
    (MISC-INST-ENTRY UNBIND-6)
    (MISC-INST-ENTRY UNBIND-7)
    (MISC-INST-ENTRY UNBIND-10)
    (MISC-INST-ENTRY UNBIND-11)
    (MISC-INST-ENTRY UNBIND-12)
    (MISC-INST-ENTRY UNBIND-13)
    (MISC-INST-ENTRY UNBIND-14)
    (MISC-INST-ENTRY UNBIND-15)
    (MISC-INST-ENTRY UNBIND-16)
    (MISC-INST-ENTRY UNBIND-17)
	((M-D) (BYTE-FIELD 4 0) M-B)	;GET # BINDINGS TO POP MINUS ONE
XUB1	(CALL-IF-BIT-CLEAR M-QBBFL ILLOP)	;TRYING TO OVERPOP FRAME
	(CALL QUNBND)	
	(POPJ-EQUAL M-D A-ZERO)
	(JUMP-XCT-NEXT XUB1)
       ((M-D) SUB M-D (A-CONSTANT 1))

XPOPIP (MISC-INST-ENTRY POPPDL-0)
       (MISC-INST-ENTRY POPPDL-1)
       (MISC-INST-ENTRY POPPDL-2)
       (MISC-INST-ENTRY POPPDL-3)
       (MISC-INST-ENTRY POPPDL-4)
       (MISC-INST-ENTRY POPPDL-5)
       (MISC-INST-ENTRY POPPDL-6)
       (MISC-INST-ENTRY POPPDL-7)
       (MISC-INST-ENTRY POPPDL-10)
       (MISC-INST-ENTRY POPPDL-11)
       (MISC-INST-ENTRY POPPDL-12)
       (MISC-INST-ENTRY POPPDL-13)
       (MISC-INST-ENTRY POPPDL-14)
       (MISC-INST-ENTRY POPPDL-15)
       (MISC-INST-ENTRY POPPDL-16)
       (MISC-INST-ENTRY POPPDL-17)
;	(POPJ-AFTER-NEXT
;	 (M-B) (BYTE-FIELD 4 0) M-B)	;POP PDL 1-16.  NOTE THIS CAN NOT BE CALLED BY
;					;COMPILED MICROCODE SINCE B WONT BE SET UP
;      ((PDL-BUFFER-POINTER) SUB PDL-BUFFER-POINTER A-B)
;THE FOLLOWING IS A TEMPORARY KLUDGE UNTIL THE COMPILER BUG IS FIXED. 12/19/78 MOON, PER RMS
	((M-B) (BYTE-FIELD 4 0) M-B)
	((PDL-BUFFER-POINTER M-B) SUB PDL-BUFFER-POINTER A-B)
XPOPIP-1
	((M-TEM) SUB PDL-BUFFER-POINTER A-IPMARK)
	(POPJ-IF-BIT-CLEAR (BYTE-FIELD 1 9) M-TEM) ;PP >= A-IPMARK mod 2000
	(CALL XPOP-OPEN-CALL)		;Compiler forgot to flush this open call block
	(JUMP-XCT-NEXT XPOPIP-1)	;Try again
       ((PDL-BUFFER-POINTER) M-B)	;Try to put PP where compiler seemed to want it

XMOVE-PDL-TOP (MISC-INST-ENTRY MOVE-PDL-TOP)
	(POPJ-AFTER-NEXT (M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
       (NO-OP)

XSHRINK-PDL-SAVE-TOP (MISC-INST-ENTRY SHRINK-PDL-SAVE-TOP)
	((M-2) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;AMT TO DECREMENT PP BY
	(POPJ-AFTER-NEXT
	 (M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;THING TO RETURN
       ((PDL-BUFFER-POINTER) SUB PDL-BUFFER-POINTER A-2)

XSPECIAL-PDL-INDEX (MISC-INST-ENTRY SPECIAL-PDL-INDEX)
	((M-T) A-QLBNDP)
	(POPJ-AFTER-NEXT (M-T) SUB M-T A-QLBNDO)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XUNBIND-TO-INDEX-MOVE (MISC-INST-ENTRY UNBIND-TO-INDEX-MOVE)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;VALUE TO RETURN LATER
XUNBIND-TO-INDEX (MISC-INST-ENTRY UNBIND-TO-INDEX)
	((M-D) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-D) ADD M-D A-QLBNDO)
XUNBIND-TO-INDEX-1
	(POPJ-GREATER-OR-EQUAL M-D A-QLBNDP)
	(CALL-IF-BIT-CLEAR M-QBBFL ILLOP)
	(JUMP-XCT-NEXT XUNBIND-TO-INDEX-1)
       (CALL QUNBND)

;Get rid of one open call block, setting PDL-BUFFER-POINTER back to before
;call block and associated ADI.  Note that an open call block never has any
;associated binding-pdl slots, since closures and so forth are processed
;when the call is activated.  The compiler always generates this to D-IGNORE,
;so we don't put anything in M-T (other callers may not want it clobbered.)
;Bashes only M-K.  This routine is for "macro" execution mode only.
XPOP-OPEN-CALL (MISC-INST-ENTRY POP-OPEN-CALL)
	((M-K) A-IPMARK)
	(CALL-EQUAL M-K A-AP TRAP)	;Trying to pop call block that isn't open
		(ERROR-TABLE ILLEGAL-INSTRUCTION)
	((PDL-BUFFER-INDEX) ADD M-K (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-TEM) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) C-PDL-BUFFER-INDEX)
	((M-TEM) SUB M-K A-TEM)
	((A-IPMARK) (BYTE-FIELD 10. 0) M-TEM)
	((PDL-BUFFER-POINTER) SUB M-K (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	(POPJ-IF-BIT-CLEAR (LISP-BYTE %%LP-CLS-ADI-PRESENT) C-PDL-BUFFER-INDEX)
	(JUMP-XCT-NEXT QRAD2)		;Must flush ADI.
       ((PDL-BUFFER-INDEX M-K) SUB PDL-BUFFER-POINTER (A-CONSTANT 1))

;;; CAR AND CDR
;   NOTE- ALWAYS RETURNS 0 IN FIELDS OTHER THAN POINTER AND DATA TYPE

QTADDD (MISC-INST-ENTRY CADDDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADDD (MICRO-CODE-ENTRY QMADDD)
	(CALL QMD)
QMADD (MICRO-CODE-ENTRY QMADD)
	(CALL QMD)
QMAD (MICRO-CODE-ENTRY QMAD)
	(CALL QMD)
QMA  (MICRO-CODE-ENTRY QMA) 
   (ERROR-TABLE RESTART CAR)
QCAR	(DISPATCH (I-ARG CAR-INVOKE-OP) Q-DATA-TYPE M-T CAR-PRE-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CAR)
				;DROP THROUGH IF NORMAL CAR
QCAR3	((VMA-START-READ) M-T)
	(CHECK-PAGE-READ)  
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)	;CHECK FOR INVZ, GC
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

QCARSY	(DISPATCH M-CAR-SYM-MODE CAR-SYM-DISPATCH)	;CAR OF A SYMBOL
   (ERROR-TABLE ARGTYP CONS M-T T CAR)

QCARNM	(DISPATCH M-CAR-NUM-MODE CAR-NUM-DISPATCH)	;CAR OF A NUMBER
   (ERROR-TABLE ARGTYP CONS M-T T CAR)

QTDDDD (MISC-INST-ENTRY CDDDDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDDD (MICRO-CODE-ENTRY QMDDDD)
	(CALL QMD)
QMDDD (MICRO-CODE-ENTRY QMDDD)
	(CALL QMD)
QMDD (MICRO-CODE-ENTRY QMDD)
	(CALL QMD)
QMD  (MICRO-CODE-ENTRY QMD) 
   (ERROR-TABLE RESTART CDR)
QCDR	(DISPATCH (I-ARG CDR-INVOKE-OP) Q-DATA-TYPE M-T CDR-PRE-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)
					;DROP THROUGH IF NORMAL LIST CDR
QCDR3	((VMA-START-READ) M-T)
	(CHECK-PAGE-READ)  
	(DISPATCH TRANSPORT-CDR READ-MEMORY-DATA)	;CHECK FOR INVZ, DON'T REALLY TRANSPORT
	(DISPATCH Q-CDR-CODE READ-MEMORY-DATA CDR-CDR-DISPATCH)
   (ERROR-TABLE BAD-CDR-CODE RMD)				;POPJ-XCT-NEXT IF CDR NEXT
       ((M-T) ADD VMA (A-CONSTANT 1))		;SAME DATA TYPE AS ARG

QCDRSY	(DISPATCH M-CDR-SYM-MODE CDR-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)

QCDRNM	(DISPATCH M-CDR-NUM-MODE CDR-NUM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-T T CDR)

CDR-FULL-NODE 
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)  
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;CHECK FOR INVISIBLE, GC
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

QCASE1	((M-K) Q-TYPED-POINTER M-T)	;HANDLE TAKING CAR OR CDR OF NIL
	(CALL-NOT-EQUAL M-K A-V-NIL TRAP)
   (ERROR-TABLE ARGTYP (CONS NIL) M-T T CDR)
CDR-IS-NIL 
   (MISC-INST-ENTRY FALSE)
XFALSE 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (NO-OP)

QCDPRP	((M-T) Q-TYPED-POINTER M-T)		;TAKING CDR OF SYMBOL (IN P-LIST MODE)
	(JUMP-EQUAL M-T A-V-NIL XFALSE)		;CDR OF NIL IS NIL,
 	((M-T) ADD (A-CONSTANT 3) M-T)		;OTHERWISE IS THE SYMBOL'S PLIST
	(JUMP-XCT-NEXT QCDR)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

QTAAAA (MISC-INST-ENTRY CAAAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAAAA (MICRO-CODE-ENTRY QMAAAA)
	(CALL QMA)
QMAAA  (MICRO-CODE-ENTRY QMAAA)
	(CALL QMA)
QMAA   (MICRO-CODE-ENTRY QMAA)
	(CALL QMA)
	(JUMP QMA)

QTAAAD (MISC-INST-ENTRY CAAADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAAAD (MICRO-CODE-ENTRY QMAAAD)
	(CALL QMD)
	(JUMP QMAAA)

QTDDDA (MISC-INST-ENTRY CDDDAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDDA (MICRO-CODE-ENTRY QMDDDA)
	(CALL QMA)
	(JUMP QMDDD)

QTAADD (MISC-INST-ENTRY CAADDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAADD (MICRO-CODE-ENTRY QMAADD)
	(CALL QMD)
QMAAD  (MICRO-CODE-ENTRY QMAAD)
	(CALL QMD)
	(JUMP QMAA)

QTAADA (MISC-INST-ENTRY CAADAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMAADA (MICRO-CODE-ENTRY QMAADA)
	(CALL QMA)
	(JUMP QMAAD)

QTDDAA (MISC-INST-ENTRY CDDAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDAA (MICRO-CODE-ENTRY QMDDAA)
	(CALL QMA)
QMDDA  (MICRO-CODE-ENTRY QMDDA)
	(CALL QMA)
	(JUMP QMDD)

QTDDAD (MISC-INST-ENTRY CDDADR)	
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDDAD (MICRO-CODE-ENTRY QMDDAD)
	(CALL QMD)
	(JUMP QMDDA)

QTADAA (MISC-INST-ENTRY CADAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADAA (MICRO-CODE-ENTRY QMADAA)
	(CALL QMA)
QMADA  (MICRO-CODE-ENTRY QMADA)
	(CALL QMA)
	(JUMP QMAD)

QTADAD (MISC-INST-ENTRY CADADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADAD (MICRO-CODE-ENTRY QMADAD)
	(CALL QMD)
	(JUMP QMADA)

QTADDA (MISC-INST-ENTRY CADDAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMADDA (MICRO-CODE-ENTRY QMADDA)
	(CALL QMA)
	(JUMP QMADD)

QTDADA (MISC-INST-ENTRY CDADAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDADA (MICRO-CODE-ENTRY QMDADA)
	(CALL QMA)
QMDAD  (MICRO-CODE-ENTRY QMDAD)
	(CALL QMD)
	(JUMP QMDA)

QTDADD (MISC-INST-ENTRY CDADDR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDADD (MICRO-CODE-ENTRY QMDADD)
	(CALL QMD)
	(JUMP QMDAD)

QTDAAA (MISC-INST-ENTRY CDAAAR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDAAA (MICRO-CODE-ENTRY QMDAAA)
	(CALL QMA)
QMDAA  (MICRO-CODE-ENTRY QMDAA)
	(CALL QMA)
QMDA   (MICRO-CODE-ENTRY QMDA)
	(CALL QMA)
	(JUMP QMD)

QTDAAD (MISC-INST-ENTRY CDAADR)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QMDAAD (MICRO-CODE-ENTRY QMDAAD)
	(CALL QMD)
	(JUMP QMDAA)


QTAAA (MISC-INST-ENTRY CAAAR)
	(JUMP-XCT-NEXT QMAAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAAD (MISC-INST-ENTRY CAADR)
	(JUMP-XCT-NEXT QMAAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTADA (MISC-INST-ENTRY CADAR)
	(JUMP-XCT-NEXT QMADA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTADD (MISC-INST-ENTRY CADDR)
	(JUMP-XCT-NEXT QMADD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDAA (MISC-INST-ENTRY CDAAR)
	(JUMP-XCT-NEXT QMDAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDAD (MISC-INST-ENTRY CDADR)
	(JUMP-XCT-NEXT QMDAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDDA (MISC-INST-ENTRY CDDAR)
	(JUMP-XCT-NEXT QMDDA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDDD (MISC-INST-ENTRY CDDDR)
	(JUMP-XCT-NEXT QMDDD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAA  (MISC-INST-ENTRY M-CAAR)
	(JUMP-XCT-NEXT QMAA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTAD  (MISC-INST-ENTRY M-CADR)
	(JUMP-XCT-NEXT QMAD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDA  (MISC-INST-ENTRY M-CDAR)
	(JUMP-XCT-NEXT QMDA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTDD  (MISC-INST-ENTRY M-CDDR)
	(JUMP-XCT-NEXT QMDD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTA   (MISC-INST-ENTRY M-CAR)
	(JUMP-XCT-NEXT QMA)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

QTD   (MISC-INST-ENTRY M-CDR)
	(JUMP-XCT-NEXT QMD)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

 
;;; RPLACA AND RPLACD

  (MISC-INST-ENTRY RPLACA)
XRPLCA	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART RPLACA)
QRAR1	(DISPATCH (I-ARG RPLACA-INVOKE-OP) Q-DATA-TYPE M-S QRACDT)

QRASYM	(CALL-EQUAL M-S A-V-NIL TRAP)		;RPLACA ING NIL ALWAYS ERROR
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACA)
	(DISPATCH M-CAR-SYM-MODE RPLACA-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACA)

QRAR3	((VMA-START-READ) M-S)			;FETCH WORD TO BE SMASHED
	(CHECK-PAGE-READ)			;NO INT, CALLED BY MVR
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;CHASE INVISIBLES
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)	;STORE M-T INTO Q-TYPED-PNTR
	(CHECK-PAGE-WRITE)			;NO SEQ BRK, CALLED BY MVR (???)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       ((M-T) M-S)

   (MISC-INST-ENTRY RPLACD)
;MUSTN'T CLOBBER M-C OR M-R BECAUSE CALLED BY MULTIPLE-VALUE-LIST
;NOW CLOBBERS M-S, M-T, M-I, M-A
XRPLCD	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART RPLACD)
QRDR1	(DISPATCH (I-ARG RPLACD-INVOKE-OP) Q-DATA-TYPE M-S QRDCDT)

QRDRSY	(DISPATCH M-CDR-SYM-MODE RPLACD-SYM-DISPATCH)
   (ERROR-TABLE ARGTYP CONS M-S 0 RPLACD)

QRDPRP 	((M-S) ADD (A-CONSTANT 3) M-S)		;RPLACD ING SYMBOL (IN P-LIST MODE)
	(JUMP-XCT-NEXT QRDR1)
       ((M-S) DPB M-S Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))

QRDR3	((VMA-START-READ) M-S)			;GET CAR OF CONS TO BE SMASHED
	(CHECK-PAGE-READ)			;NO SEQ BRK, CDR CODE IN HAND, ALSO MVR
	(DISPATCH TRANSPORT-CDR READ-MEMORY-DATA) ;CHASE INVISIBLE, NO NEED TO TRANSPORT
	(DISPATCH-XCT-NEXT Q-CDR-CODE READ-MEMORY-DATA RPLACD-CDR-DISPATCH)
   (ERROR-TABLE BAD-CDR-CODE RMD)
       ((M-I) READ-MEMORY-DATA)

RPLACD-FULL-NODE
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))	;GET WORD TO SMASH
	(CHECK-PAGE-READ)			;NO SEQ BRK, WORD IN HAND, ALSO MVR
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;CHASE INVISIBLES
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT	;STORE M-T INTO Q-TYPED-PNTR
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)			;NO SEQ BRK, CALLED BY MVR (???)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       ((M-T) M-S)

RPLACD-CDR-NEXT 
RPLACD-NEXT-NIL 
;THIS CODE CAN SEQUENCE BREAK!!! BEWARE!!!
	((C-PDL-BUFFER-POINTER-PUSH) M-S)		;SAVE THIS SO WE CAN RETURN IT
	((C-PDL-BUFFER-POINTER-PUSH) VMA)		;ADDR OF CELL TO BE FORWARDED
	((MD) VMA)					;ADDRESS THE MAP
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-ASSURE-MAP-VALID)
	((M-TEM) (LISP-BYTE %%REGION-REPRESENTATION-TYPE) MEMORY-MAP-DATA)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL %REGION-REPRESENTATION-TYPE-LIST)) TRAP)
    (ERROR-TABLE RPLACD-WRONG-REPRESENTATION-TYPE M-S)
	((C-PDL-BUFFER-POINTER-PUSH) M-I)		;CAR OF NEW CELL
	((C-PDL-BUFFER-POINTER-PUSH) M-T)		;CDR OF NEW CELL
	(CALL-XCT-NEXT XARN)				;IN WHAT AREA WAS THE CONS?
       ((C-PDL-BUFFER-POINTER-PUSH) Q-POINTER MD)	;MD HAS ORIGINAL VMA
	(CALL-XCT-NEXT QCONS)
       ((M-S) Q-TYPED-POINTER M-T)			;PASS ON THE AREA NUMBER
	((WRITE-MEMORY-DATA) DPB M-T Q-POINTER		;CLOBBER ORIGINAL "CAR"
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-HEADER-FORWARD)))
	((VMA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;RETURN THE ORIGINAL FIRST ARG

;;; ARRAYS

;GENERAL ON ARRAY REFERENCING--
; CODE TO DEAL WITH NON-DISPLACED ARRAYS IS CODED OPEN, WHILE THAT TO
;DEAL WITH DISPLACED ARRAYS IS IN DSP-ARRAY-SETUP.  SINCE THE DISPLACED 
;CASE EVENTUALLY DROPS INTO THE NORMAL CASE, CERTAIN CONVENTIONS ARE NECESSARY.
; THE NORMAL SEQUENCE OF CODE IS
;      1: GET ARRAY-POINTER Q INTO M-A
;      2: CALL GAHD1 TO FETCH ARRAY-HEADER Q INTO M-B.  GAHD1 MAKES SURE IT
;	    IS THE RIGHT TYPE, ETC.  M-D GET NUMBER DIMENSIONS, M-E DATA ORIGIN,
;	    M-S DATA STORAGE LENGTH IN ELEMENTS (NOT QS).
;      3: GET ELEMENT NUMBER WANT TO REF IN M-Q.
;      4: DO (CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B DSP-ARRAY-SETUP)
;	    THIS WILL CHANGE M-E AND M-S, AND MAY CHANGE M-Q.
;	    DSP-ARRAY-SETUP IS TRANSPARENT TO M-A, M-B, AND M-D.
;	    DSP-ARRAY-SETUP KNOWS ABOUT INDIRECT ARRAYS, AND WILL FOLLOW
;		DISPLACED CHAINS, ETC.
;      5: BARF IF M-Q IS GREATER THAN OR EQUAL TO M-S (INDEX OUT OF BOUNDS).
;      6: DISPATCH ON ARRAY-TYPE TO APPROPRIATE REFERENCE ROUTINE.

;M-Q, M-S, M-D, M-E PURE (TYPE-LESS) NUMBERS

;NO SEQ BRKS ALLOWED ANYWHERE IN THIS CODE.  THIS (1) CAUSES STORES
;INTO BYTE ARRAYS TO NOT LOSE SIMULTANEOUS STORES INTO OTHER BYTES SAME WORD
;(2) PREVENTS LOSSAGE FROM ONE PROCESS *REARRAYING WHILE ANOTHER IS REFERENCING
;(3) ALLOWS TWO PROCESSES TO CALL ARRAY-PUSH WITH NO TIMING ERRORS

;THE FOLLOWING REGISTERS MUST BE PRESERVED THROUGH ARRAY REFERENCING,
;FOR THE SAKE OF BITBLT: M-C, M-I, M-K, M-ZR

QARYR-TRAP
	((M-B) A-NARGS)				;Put where error-handler can find it
	(CALL TRAP)
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D M-B)

QARYR	(CALL GAHD1)				;REFERENCE ARRAY
	(JUMP-NOT-EQUAL A-NARGS M-D QARYR-TRAP)	;WRONG # DIM S
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP NIL)
	((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL (A-CONSTANT 1) M-D QARY-MULTI)	;MULTI DIM ARRAY
QARY-M1	
QARYR1	((A-QLARYL) DPB M-Q Q-POINTER 	;LAST ELEMENT # REF ED
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		 M-B DSP-ARRAY-SETUP)		;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-CALL-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-REF-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((A-QLARYH) Q-TYPED-POINTER M-A)	;PNTR TO HEADER OF LAST ARRAY REF ED
;DROPS THROUGH TO RETURN THE ARRAY CONTENTS (IN M-T)

;DROPS IN.  RETURN FROM X-TO-MACRO CALL TO AN ARRAY.
QARYR5	((M-TEM) A-IPMARK)		;GET POINTER TO (OLD) OPEN BLOCK
	((PDL-BUFFER-INDEX) ADD M-TEM (A-CONSTANT (EVAL %LP-CALL-STATE)))
	((M-C) C-PDL-BUFFER-INDEX)	;IN CASE CALL QRAD1 AND CLOBBER PDL INDEX
	((A-TEM1) (LISP-BYTE %%LP-CLS-DELTA-TO-OPEN-BLOCK) M-C)
	((M-1) SUB M-TEM A-TEM1)
	((A-IPMARK) (BYTE-FIELD 10. 0) M-1)
	((PDL-BUFFER-POINTER) SUB M-TEM (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
	(CALL-IF-BIT-SET (LISP-BYTE %%LP-CLS-ADI-PRESENT)
			 M-C		;MULTI-VALUE CALL, STORE LAST VALUE
			 QRAD1)		;IN RIGHT PLACE, ETC
	((PDL-BUFFER-INDEX) M-AP)	;DISPATCH ON FCTN TYPE RE-ENTERING
	(DISPATCH-XCT-NEXT (I-ARG DATA-TYPE-INVOKE-OP) Q-DATA-TYPE 
		C-PDL-BUFFER-INDEX QMXRT1)
       (NO-OP)				;THERE MUST BE SOMETHING TO DO IN THIS INST

;QBNEAF AND QBALM FLUSHED
QBARY1	(JUMP-XCT-NEXT QIMOVE-EXIT)		;STORE VALUE
       ((M-C) (LISP-BYTE %%LP-CLS-MACRO-SAVED-DESTINATION)
	      M-C)

QBARY2	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((M-K) (LISP-BYTE %%LP-EXS-RETURN-MICRO-PC)
	       C-PDL-BUFFER-INDEX)
	((OA-REG-LOW) DPB M-K OAL-JUMP A-ZERO)
	(JUMP 0)

;MULTI-DIMENSIONAL ARRAY
QARY-MULTI
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)	;SPACE PAST LONG LENGTH IF
	((VMA-START-READ M-J) ADD M-A A-1 ALU-CARRY-IN-ONE)	; PRESENT
QARY-MULTI-1					;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CHECK-PAGE-READ)
	((M-D) SUB M-D (A-CONSTANT 1))
	((Q-R) M-Q)
	(CALL-XCT-NEXT MPY)			;MULTIPLY M-1 
       ((M-1) Q-POINTER READ-MEMORY-DATA)	;BY CONTENTS OF Q-R, RESULT TO Q-R, BASH M-2
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP NIL)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-Q) ADD Q-R A-1)			;ADD NEXT SUBSCRIPT
	(JUMP-EQUAL (A-CONSTANT 1) M-D QARY-M1)	;JUMP IF THROUGH, FINAL SUBSC IN M-Q
	(JUMP-XCT-NEXT QARY-MULTI-1)
       ((VMA-START-READ M-J) ADD M-J A-ZERO ALU-CARRY-IN-ONE)

GAHD4	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-STACK-GROUP)) GAHD1)	;SG OK
	(CALL TRAP)			;BAD D.T. IN ARRAY-POINTER
   (ERROR-TABLE ARGTYP ARRAY M-A NIL GAHDR)

GAHDRA	((M-A) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART GAHDR)
GAHDR	((M-TEM) Q-DATA-TYPE M-A)	;FOR USE WHEN A IS NOT ALREADY KNOW TO BE
					; ARRAY-POINTER
	(JUMP-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) GAHD4)
GAHD1	((VMA-START-READ) M-A)		;GET ARRAY HEADER
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)	;GC, FOLLOW INVZ
	((M-A) VMA)			;MAY HAVE FORWARDED, GET REAL ADDRESS
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;VERIFY ARRAY HEADER DATA TYPE
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-ARRAY-HEADER)) ILLOP)
	((M-B) Q-POINTER READ-MEMORY-DATA)	;SAVE ARRAY HEADER Q
	((M-E) Q-POINTER M-A)		;INITIAL TYPELESS PNTR TO FIRST DATA ELEMENT
	((M-D) (LISP-BYTE %%ARRAY-NUMBER-DIMENSIONS) M-B)
	((M-E) ADD M-E A-D)		;ADDR OF FIRST DATA ELEMENT OF ARRAY (TYPELESS)
	(POPJ-AFTER-NEXT
	 (M-S) (LISP-BYTE %%ARRAY-INDEX-LENGTH-IF-SHORT) M-B)	;INDEX LENGTH
       (CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B GAHD3)

GAHD3	((VMA-START-READ) ADD M-A (A-CONSTANT 1))	;LONG ARRAY, GET INDEX LENGTH Q
	(CHECK-PAGE-READ)		;NO TRANSP SINCE JUST TOUCHED HEADER
	(POPJ-AFTER-NEXT (M-E) ADD M-E (A-CONSTANT 1))	;SPACE OVER INDEX Q
       ((M-S) Q-POINTER READ-MEMORY-DATA)

XAIXL (MISC-INST-ENTRY ARRAY-LENGTH)
	(CALL GAHDRA)
  (ERROR-TABLE CALLS-SUB ARRAY-LENGTH)
XAIXL1	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B)
       ((M-T) DPB M-S Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-READ) ADD M-E (A-CONSTANT 1))	;DISPLACED, GET INDEX LENGTH
XAIXL2	(CHECK-PAGE-READ)	;NO TRANSPORT SINCE JUST TOUCHED HDR
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XAAIXL (MISC-INST-ENTRY ARRAY-ACTIVE-LENGTH)
	(CALL GAHDRA)
   (ERROR-TABLE CALLS-SUB ARRAY-ACTIVE-LENGTH)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B XAIXL1)
	(JUMP-XCT-NEXT XAIXL2)			;HAS LEADER, PICK UP FILL POINTER
       ((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HDR

DSP-ARRAY-SETUP   ;CALL WITH ARRAY POINTER IN M-A, HEADER IN M-B, 
		  ; FIRST DATA ELEM IN M-E, DESIRED ELEMENT NUMBER IN M-Q.
		  ;RETURNS WITH DATA ORIGIN IN M-E, M-S CHANGED TO REFLECT ARRAY
		  ; BEING REF'ED AND POSSIBLY ADJUSTED M-Q.
	((VMA-START-READ) ADD A-ZERO M-E ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)	;TRANSPORT IN CASE POINTS TO OLDSPACE
	((M-S) Q-POINTER READ-MEMORY-DATA)	;GET NEW DATA LENGTH LIMIT
	((VMA-START-READ) M-E)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)	;TRANSPORT IN CASE POINTS TO OLDSPACE
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) DSP-ARRAY-INDIRECT)
	(POPJ-AFTER-NEXT 
	  (M-E) Q-POINTER READ-MEMORY-DATA)
       (NO-OP)

;OPERATION OF QDACMP:
; M-E HAS DATA BASE OF INDIRECT ARRAY HEADER
; M-Q HAS ENTRY NUMBER DESIRED
; READ-MEMORY-DATA HAS MEM(M-E), THE DATA TYPE OF WHICH IS ARRAY POINTER,
;  WHICH IS WHY WE GOT HERE.
;QDACMP PUSHES THE INFO RELATIVE TO THE INDIRECT ARRAY (M-A, M-B, M-D).
; M-E EVENTUALLY GETS THE DATA BASE OF THE POINTED TO ARRAY.
; M-S GETS MIN(M-S FROM INDIRECT ARRAY + INDEX OFFSET, INDEX LENGTH OF POINTED TO ARRAY).
; IN THE PROCESS, M-Q WILL BE ADJUSTED IF AN INDEX OFFSET IS ENCOUNTERED
; AFTER THE FINAL DATA BASE IS DETERMINED, M-A, M-B AND M-D ARE RESTORED.

DSP-ARRAY-INDIRECT 
QDACMP	((C-PDL-BUFFER-POINTER-PUSH) M-A)
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-D)
	((C-PDL-BUFFER-POINTER-PUSH)	;SAVE ARRAY-TYPE OF ORIGINALLY REF'ED ARRAY
		(LISP-BYTE %%ARRAY-TYPE-FIELD) M-B  ;THIS MUST BE IN 0@PP BELOW
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
QDACM2	((M-A) READ-MEMORY-DATA)	;POINTED-TO ARRAY
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA QDACM4)  ;HAS INDEX OFFSET
QDACM5	(CALL-XCT-NEXT GAHD1)		;SETS UP M-E, M-S
       ((C-PDL-BUFFER-POINTER-PUSH) M-S)	;SAVE POINTER'S INDEX LENGTH
  (ERROR-TABLE CALLS-SUB ARRAY-INDIRECT)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B QDACMI)
       ((M-D) C-PDL-BUFFER-POINTER-POP)		;NOW TAKE MINIMUM OF THE TWO LENGTHS
	((VMA-START-READ) ADD M-E (A-CONSTANT 1))	;DOUBLE DISPLACE, GET CORRECT LENGTH
	(CHECK-PAGE-READ)
	((M-S) Q-POINTER READ-MEMORY-DATA)
QDACMI	((M-1) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)  ;CHECK IF SAME ARRAY-TYPE AS ORIG REF
	(JUMP-NOT-EQUAL C-PDL-BUFFER-POINTER A-1 QDACM8)  ;NO, ORIG MUST CONTROL
	(JUMP-GREATER-OR-EQUAL M-D A-S QDACM7)
QDACM8	((M-S) M-D)
QDACM7	(JUMP-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B QDACM6) ;FURTHER INDIR
QDACM1	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH ARRAY TYPE
	((M-D) C-PDL-BUFFER-POINTER-POP) ;GOT ALL INFO, RESTORE M-A, M-B, M-D
	(POPJ-AFTER-NEXT 
	 (M-B) C-PDL-BUFFER-POINTER-POP)
       ((M-A) C-PDL-BUFFER-POINTER-POP)

QDACM6	((VMA-START-READ) M-E)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) QDACM2) ;DOUBLE INDIRECT
	(JUMP-XCT-NEXT QDACM1)				;JUST DISPLACED
       ((M-E) READ-MEMORY-DATA)

QDACM4	((VMA-START-READ) ADD (A-CONSTANT 2) M-E)	;HAS INDEX OFFSET
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE READ-MEMORY-DATA TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ARRAY)
	((M-D) Q-POINTER READ-MEMORY-DATA)		;FETCH INDEX OFFSET
	((M-S) ADD M-S A-D)				;ADJUST INDEX LIMIT
	(JUMP-XCT-NEXT QDACM5)
       ((M-Q) ADD M-Q A-D)				;ADJUST CURRENT INDEX

QBARY	((M-J) (BYTE-FIELD 2 0) M-Q)		;BYTE ARRAY
	((A-TEM1) (BYTE-FIELD 26 2) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CHECK-PAGE-READ)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 2 3))	;LSH M-J 3 BECAUSE EA BYTE 8 BITS
	((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 10 0)))) )
QBFXIT	((M-J) SUB (M-CONSTANT 40) A-TEM2)	;REFLECT BECAUSE OF SHIFTER LOSSAGE
QBFXIT1	((OA-REG-LOW) DPB M-J A-TEM3 OAL-MROT)	;MODIFY NEXT INSTRUCTION
		;DPB NECESSARY BECAUSE M-J = 40 IF A-TEM2 WAS 0
	(POPJ-AFTER-NEXT 
	 BYTE-INST (M-T) READ-MEMORY-DATA)
       ((M-T) IOR (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) M-T)

QB1RY	((A-TEM1) (BYTE-FIELD 23 5) M-Q)	;BIT ARRAY
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CHECK-PAGE-READ)
	((A-TEM2) (BYTE-FIELD 5 0) M-Q)
	(JUMP-XCT-NEXT QBFXIT)			;NO LSH SINCE EA ELEMENT ONE BIT
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))) )

QB2RY	((M-J) (BYTE-FIELD 4 0) M-Q)		;2 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 24 4) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CHECK-PAGE-READ)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 4 1))	;LSH M-J 1
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 2 0)))) )

QB4RY	((M-J) (BYTE-FIELD 3 0) M-Q)		;4 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 25 3) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CHECK-PAGE-READ)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 3 2))	;LSH M-J 2
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 4 0)))) )

QB16RY	((M-J) (BYTE-FIELD 1 0) M-Q)		;16 BIT ARRAY
	((A-TEM1) (BYTE-FIELD 27 1) M-Q)
	((VMA-START-READ) ADD A-TEM1 M-E)
	(CHECK-PAGE-READ)
	((A-TEM2) DPB M-J A-ZERO (BYTE-FIELD 1 4))	;LSH M-J 4
	(JUMP-XCT-NEXT QBFXIT)
       ((A-TEM3) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 20 0)))) )

QB32RY	((VMA-START-READ) ADD A-Q M-E)		;32 BIT ARRAY (REALLY POINTER SIZE AND FORCE
	(CHECK-PAGE-READ)			;FIXNUM DATA-TYPE) USEFUL FOR TV-BUFFER
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

QQARY	((VMA-START-READ) ADD A-Q M-E)		;Q ARRAY
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

   (MISC-INST-ENTRY GET-LOCATIVE-POINTER-INTO-ARRAY)
XGLOPR  ((M-R) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE))
		    C-PDL-BUFFER-POINTER-POP)	;FLUSH ARGUMENT
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)		;CONCEIVABLY SHOULD CHECK TO MAKE SURE Q ORIENTED
  (ERROR-TABLE CALLS-SUB GET-LOCATIVE-POINTER-INTO-ARRAY)
	(JUMP-XCT-NEXT XGLOP1)	;ARRAY
       ((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)

   (MISC-INST-ENTRY GET-LIST-POINTER-INTO-ARRAY)
XGLPA	((M-R) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST))
		     C-PDL-BUFFER-POINTER-POP)	;IGNORE ARGUMENT
					;GET LIST POINTER TO LAST ARRAY ELEMENT REF ED
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)
   (ERROR-TABLE CALLS-SUB GET-LIST-POINTER-INTO-ARRAY)
	((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)		;ENTRY NUMBER
XGLPA1	((M-TEM) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL (FIND-POSITION-IN-LIST 
						  'ART-Q-LIST 
						   ARRAY-TYPES))) TRAP)
   (ERROR-TABLE ARGTYP ART-Q-LIST-ARRAY M-A T NIL)
XGLOP1	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B 
		DSP-ARRAY-SETUP)  		;DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(POPJ-AFTER-NEXT 
	 (A-TEM3) IOR A-R M-Q)
      ((M-T) ADD A-TEM3 M-E)

     (MISC-INST-ENTRY G-L-P)		;(G-L-P <ARRAY-POINTER-TO-ART-Q-LIST-ARRAY>)
XGLPAR	(CALL-XCT-NEXT GAHD1)		; RETURNS LIST POINTER TO ARRAY CONTENTS
       ((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;IF FILL-POINTER 0, RETURN NIL
  (ERROR-TABLE CALLS-SUB G-L-P)
	(JUMP-IF-BIT-CLEAR M-B (LISP-BYTE %%ARRAY-LEADER-BIT) XGLPA2) ;JUMP ON NO LEADER
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;NO TRANSPORT SINCE JUST TOUCHED HDR
	(CHECK-PAGE-READ)
	((M-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) XFALSE)
XGLPA2	((M-R) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(JUMP-XCT-NEXT XGLPA1)  ;RETURN POINTER TO ELEMENT NUMBER 0
       ((M-Q) A-ZERO)

;Storing into arrays.  M-T has data to store, M-Q subscript, M-E etc. have GAHDR data

XXSTOR (MISC-INST-ENTRY XSTORE)
	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;STORE IN LAST ARRAY ELEM REF ED
	(CALL-XCT-NEXT GAHD1)
       ((M-A) A-QLARYH)
   (ERROR-TABLE CALLS-SUB STORE)
	((M-Q) DPB M-ZERO Q-ALL-BUT-POINTER A-QLARYL)
	(CALL-IF-BIT-SET M-B (LISP-BYTE %%ARRAY-DISPLACED-BIT) DSP-ARRAY-SETUP)
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ARRAY-TYPE-FIELD) 
		M-B ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((M-T) C-PDL-BUFFER-POINTER-POP)


;NOTE REFLECTING ABOUT 40 HACK NOT NECESSARY FOR DPB
QSBARY	((M-J) DPB M-Q (BYTE-FIELD 2 3)		;STORE IN BYTE ARRAY (8 BIT)
		(A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 10 0)))))
	((A-TEM1) (BYTE-FIELD 26 2) M-Q)	;WORD OFFSET
QSANUM	((VMA-START-READ) ADD A-TEM1 M-E)	;COMMON STORE ROUTINE FOR NUMERIC ARRAYS
	(CHECK-PAGE-READ)
	(DISPATCH Q-DATA-TYPE M-T TRAP-UNLESS-FIX)
	    (ERROR-TABLE ARGTYP FIXNUM M-T 0)	;STORING IN NUMERIC ARRAY, MUST BE FIXNUM
	((A-TEM1) READ-MEMORY-DATA)
	((OA-REG-LOW) M-J)			;MODIFY FOLLOWING INST FOR WRITE
       ((WRITE-MEMORY-DATA-START-WRITE) DPB M-T A-TEM1)
	(CHECK-PAGE-WRITE)
CPOPJ	(POPJ)

QS1RY	((M-J) DPB M-Q (BYTE-FIELD 5 0)		;STORE IN BIT ARRAY
		(A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 1 0)))))
	(JUMP-XCT-NEXT QSANUM)
       ((A-TEM1) (BYTE-FIELD 23 5) M-Q)		;WORD OFFSET

QS2RY	((M-J) DPB M-Q (BYTE-FIELD 4 1)		;STORE IN 2-BIT ARRAY
		(A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 2 0)))))
	(JUMP-XCT-NEXT QSANUM)
       ((A-TEM1) (BYTE-FIELD 24 4) M-Q)		;WORD OFFSET

QS4RY	((M-J) DPB M-Q (BYTE-FIELD 3 2)		;STORE IN 4-BIT ARRAY
		(A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 4 0)))))
	(JUMP-XCT-NEXT QSANUM)
       ((A-TEM1) (BYTE-FIELD 25 3) M-Q)		;WORD OFFSET

QS16RY	((M-J) DPB M-Q (BYTE-FIELD 1 4)		;STORE IN 16-BIT ARRAY
		(A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST (BYTE-FIELD 20 0)))))
	(JUMP-XCT-NEXT QSANUM)
       ((A-TEM1) (BYTE-FIELD 27 1) M-Q)		;WORD OFFSET

QS32RY	((VMA) ADD A-Q M-E)			;32 BIT ARRAY (ANOMALOUS)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) M-T)
       (CHECK-PAGE-WRITE)

QSQARY	((VMA) ADD A-Q M-E)			;Q ARRAY
	((WRITE-MEMORY-DATA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

QSLQRY	((VMA-START-READ) ADD A-Q M-E)		;Q-LIST ARRAY
	(CHECK-PAGE-READ)			;NO TRANSPORT SINCE STORING AND JUST
	((WRITE-MEMORY-DATA-START-WRITE)	;TOUCHED HEADER AND DON'T ALLOW ONE-Q-FORWARD
		SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)
				
   (MISC-INST-ENTRY ARRAY-PUSH)
XFARY	((M-T) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDR)
       ((M-A) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB ARRAY-PUSH)
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B TRAP)
   (ERROR-TABLE ARRAY-HAS-NO-LEADER M-A)
	((VMA-START-READ) SUB M-A (A-CONSTANT 2))	;REF FILL POINTER
	(CHECK-PAGE-READ)			;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE READ-MEMORY-DATA TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE FILL-POINTER-NOT-FIXNUM M-A)
	((M-Q) Q-POINTER READ-MEMORY-DATA)	;THIS ONE GETS RELOCATED IF INDIRECT ARY
	((A-FARY-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)  ;NOT CLOBBERED BY ARY ROUTINES
						;THIS COPY USED FOR INCREMENTING AND 
						;STORING BACK
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B 
			 DSP-ARRAY-SETUP)
	(JUMP-GREATER-OR-EQUAL M-Q A-S XFALSE)	;INDEX OUT OF BOUNDS, RETURN NIL, DON'T STORE
	((VMA) SUB M-A (A-CONSTANT 2))		;KNOW WILL WIN NOW, MUNG
	((WRITE-MEMORY-DATA-START-WRITE) ADD A-FARY-TEM M-ZERO ALU-CARRY-IN-ONE)
	(CHECK-PAGE-WRITE)
	(DISPATCH-CALL (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B 
			ARRAY-TYPE-FILL-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
	(POPJ-AFTER-NEXT 	;RETURN ELEMENT NUMBER STORED INTO.
	 (M-T) A-FARY-TEM)
       ((M-T) IOR (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) M-T)

XFALAR	((A-TEM1) M-Q)			;HERE FROM ARRAY-TYPE-FILL-DISPATCH FOR Q-LIST-ARRAY
	((VMA) ADD A-TEM1 M-E)		;MUST HACK CDR CODES
	((WRITE-MEMORY-DATA-START-WRITE)  ;NO TRANSPORTER HACKERY NEEDED SINCE ADDRESSING
	     DPB M-T Q-TYPED-POINTER      ;A "FRESH" Q.
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(CHECK-PAGE-WRITE)
	(GC-WRITE-TEST)
	(POPJ-EQUAL A-FARY-TEM M-ZERO)	;FIRST ENTRY, DO NOTHING
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;NO TRANSPORT NEEDED (JUST FIDDLING
	(CHECK-PAGE-READ)		                ;CDR CODE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE)
	     DPB READ-MEMORY-DATA Q-TYPED-POINTER
		    (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
       (CHECK-PAGE-WRITE)

   (MISC-INST-ENTRY STORE-ARRAY-LEADER)
XSALDR	(CALL XFLAD1)		;STORE IN ARRAY LEADER
;NEEDS TRANSPORTER HACKERY HERE IF ONE-Q-FORWARD S IN ARRAY-LEADERS ARE TO BE SUPPORTED.
	((M-T WRITE-MEMORY-DATA-START-WRITE) 
		Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-WRITE)		;SEQ BRK O.K. HERE
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

   (MISC-INST-ENTRY ARRAY-LEADER)
XFALDR	(CALL XFLAD1)			;FETCH ELEMENT IN ARRAY LEADER
  (ERROR-TABLE CALLS-SUB ARRAY-LEADER)
	((VMA-START-READ) VMA)
	(CHECK-PAGE-READ)		;SEQ BRK O.K. HERE
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XFLAD1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM) ;COMPUTE ADDRESS
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;OR ARRAY LEADER ELEMENT
	(CALL-XCT-NEXT GAHDR)
       ((M-A) C-PDL-BUFFER-POINTER-POP)
	(CALL-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B TRAP)	;NO LEADER
   (ERROR-TABLE ARRAY-HAS-NO-LEADER M-A)
   (ERROR-TABLE RESTART XFLAD1-A)
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;GET LENGTH OF ARRAY LEADER
	(CHECK-PAGE-READ)	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	((A-TEM1) Q-POINTER READ-MEMORY-DATA)
	(CALL-GREATER-OR-EQUAL M-Q A-TEM1 TRAP)		;SUBSCRIPT OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q RMD XFLAD1-A)
	(POPJ-AFTER-NEXT (A-TEM1) ADD M-Q (A-CONSTANT 2))
       ((VMA) SUB M-A A-TEM1)

XAHLP  (MISC-INST-ENTRY ARRAY-HAS-LEADER-P)
	(CALL GAHDRA)
  (ERROR-TABLE CALLS-SUB ARRAY-HAS-LEADER-P)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%ARRAY-LEADER-BIT) M-B XFALSE)
	(JUMP XTRUE)

XAR1   (MISC-INST-ENTRY AR-1)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
  (ERROR-TABLE CALLS-SUB AR-1)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 1) TRAP)
  (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 1)
XAR1A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-Q TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM M-Q 1)
	((M-Q) Q-POINTER M-Q)
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		M-B DSP-ARRAY-SETUP)	;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
  (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-CALL-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-REF-DISPATCH)
  (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       (NO-OP)
	(POPJ)

XAPLD (MISC-INST-ENTRY AP-LEADER)	;RETURN LOCATIVE POINTER TO LEADER ELEMENT
	(CALL XFLAD1)			;SET UP VMA
  (ERROR-TABLE CALLS-SUB AP-LEADER)
	(JUMP XAP1B)

XAP1  (MISC-INST-ENTRY AP-1)	;RETURN LOCATIVE POINTER TO ARRAY ELEMENT REF'ED
	(CALL XAR1)		;REF ARRAY, LEAVING M-B AND VMA SET UP
  (ERROR-TABLE CALLS-SUB AP-1)
XAP1A	((M-1) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)	;COULD USE DISPATCH HERE ...
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-Q ARRAY-TYPES))) XAP1B)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-Q-LIST ARRAY-TYPES))) XAP1B)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-REG-PDL ARRAY-TYPES))) XAP1B)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-SPECIAL-PDL ARRAY-TYPES))) TRAP)
  (ERROR-TABLE NUMBER-ARRAY-NOT-ALLOWED M-B)
XAP1B	(POPJ-AFTER-NEXT 
	 (M-T) DPB VMA Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (NO-OP)


XAS1  (MISC-INST-ENTRY AS-1)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB AS-1)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 1) TRAP)
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 1)
XAS1A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-Q TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM M-Q 2)
	((M-Q) Q-POINTER M-Q)
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT)
		M-B DSP-ARRAY-SETUP)		;ARRAY DISPLACED
	(CALL-GREATER-OR-EQUAL M-Q A-S TRAP)	;INDEX OUT OF BOUNDS
   (ERROR-TABLE SUBSCRIPT-OOB M-Q M-S)
	(DISPATCH-XCT-NEXT 
		(LISP-BYTE %%ARRAY-TYPE-FIELD)
		M-B 
		ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
       ((M-T) C-PDL-BUFFER-POINTER-POP)	;DATA TO STORE

XAP2  (MISC-INST-ENTRY AP-2)
	(CALL XAR2)		;DO IT THIS WAY TO SAVE A RANDOM A-CONSTANT
   (ERROR-TABLE CALLS-SUB AP-2)
	(JUMP XAP1A)

XAS2  (MISC-INST-ENTRY AS-2)
	(JUMP-XCT-NEXT XAS2B)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAS1A)))

XAR2  (MISC-INST-ENTRY AR-2)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAR1A)))
XAS2B	((M-J) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
  (ERROR-TABLE CALLS-SUB AX-2)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 2) TRAP)
  (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 2)
XAR2A	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-J TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM M-J 2)
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)   ;SPACE PAST LONG-LENGTH Q IF
	((VMA-START-READ) ADD M-A A-1 ALU-CARRY-IN-ONE)	   ; PRESENT
	(CHECK-PAGE-READ)		;NO TRANSPORT SINCE JUST TOUCHED HDR
	((M-1) Q-POINTER M-J)
	(CALL-XCT-NEXT MPY)
       ((Q-R M-D) READ-MEMORY-DATA)		;FIRST DIMENSION, SAVE IN M-D FOR BITBLT
	(POPJ-AFTER-NEXT 
	 (A-TEM1) Q-POINTER Q-R)
       ((M-Q) ADD M-Q A-TEM1)

XAP3  (MISC-INST-ENTRY AP-3)
	(CALL XAR3)
  (ERROR-TABLE CALLS-SUB AP-3)
	(JUMP XAP1A)

XAS3  (MISC-INST-ENTRY AS-3)
	(JUMP-XCT-NEXT XAS3B)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAS1A)))

XAR3  (MISC-INST-ENTRY AR-3)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XAR1A)))
XAS3B	((M-I) C-PDL-BUFFER-POINTER-POP)
	((M-J) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE CALLS-SUB AX-3)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 3) TRAP)
   (ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 3)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE M-I TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM M-I 3)
	((M-1) (LISP-BYTE %%ARRAY-LONG-LENGTH-FLAG) M-B)
	((M-1) ADD M-1 (A-CONSTANT 2))   ;TO SECOND DIMENSION
	((VMA-START-READ) ADD M-A A-1)   ;SPACE PAST LONG-LENGTH Q IF PRESENT
	(CHECK-PAGE-READ)		;NO TRANSPORT SINCE JUST TOUCHED HEADER
	((M-1) Q-POINTER M-I)
	(CALL-XCT-NEXT MPY)
       ((Q-R) READ-MEMORY-DATA)
	((A-TEM1) Q-POINTER Q-R)
	(JUMP-XCT-NEXT XAR2A)
       ((M-J) ADD M-J A-TEM1)

XCARCL (MISC-INST-ENTRY COPY-ARRAY-CONTENTS-AND-LEADER)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;TO
	((M-C) C-PDL-BUFFER-POINTER-POP)		;FROM
	(CALL-XCT-NEXT GALPTR)
       ((M-A) M-C)
	((M-Q) M-S)					;LENGTH OF FROM LEADER
	((M-J) M-E)					;HIGH ADDRESS OF FROM LEADER
	(CALL-XCT-NEXT GALPTR)
       ((M-A) M-T)
	((M-I) A-ZERO)					;CURRENT ARRAY LEADER INDEX
XCALD1	(JUMP-GREATER-OR-EQUAL M-I A-S XCARC0)		;TO LEADER DONE, GO COPY DATA
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-I A-Q XCALD2)
       ((WRITE-MEMORY-DATA) A-V-NIL)			;IF FROM LEADER EXHAUSTED, USE NIL
	((VMA-START-READ) M-J)				;GET FROM ARRAY LEADER ITEM
	(CHECK-PAGE-READ)
	((M-J) SUB M-J (A-CONSTANT 1))
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	;((WRITE-MEMORY-DATA) READ-MEMORY-DATA)
XCALD2	((VMA-START-WRITE) M-E)				;STORE IN TO ARRAY LEADER ITEM
	(CHECK-PAGE-WRITE)				;NO TRANSP HERE SINCE TOUCHED HEADER?
	(GC-WRITE-TEST)
	((M-E) SUB M-E (A-CONSTANT 1))
	(JUMP-XCT-NEXT XCALD1)
       ((M-I) ADD M-I (A-CONSTANT 1))
	
;(COPY-ARRAY-PORTION FROM-ARRAY FROM-START FROM-END TO-ARRAY TO-START TO-END)
;IF THE TO-LENGTH IS LONGER IT FILLS WITH 0 OR NIL
XCAP (MISC-INST-ENTRY COPY-ARRAY-PORTION)
	((M-R) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;TO-END
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;TO-START
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-PORTION)
	((M-R) SUB M-R A-Q)				;DON'T GET SCREWED BY DSP-ARRAY-SETUP
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B DSP-ARRAY-SETUP)
	((M-R) ADD M-R A-Q)
	((M-I) M-Q)					;TO-INDEX
	(CALL-GREATER-THAN M-R A-S TRAP)		;TO-LENGTH IN M-R MUST BE IN-BOUNDS
  (ERROR-TABLE SUBSCRIPT-OOB M-R M-S)
	((M-C) M-E)					;TO-ADDRESS
	((M-K) M-B)					;TO-ARRAY-HEADER
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;FROM-END
	(CALL-XCT-NEXT GAHDRA)
       ((M-Q) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;FROM-START
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-PORTION)
	((M-T) SUB M-T A-Q)				;DON'T GET SCREWED BY DSP-ARRAY-SETUP
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B DSP-ARRAY-SETUP)
	((M-T) ADD M-T A-Q)
	(CALL-GREATER-THAN M-T A-S TRAP)		;FROM-LENGTH IN M-T MUST BE IN-BOUNDS
  (ERROR-TABLE SUBSCRIPT-OOB M-T M-S)
	(JUMP-XCT-NEXT XCARC1)
       ((M-S) M-T)

;NOTE:  AN OPTIMIZATION TO DO IT WORD BY WORD MIGHT BE HANDY...
XCARC (MISC-INST-ENTRY COPY-ARRAY-CONTENTS)
	((M-T) C-PDL-BUFFER-POINTER-POP)		;TO
	((M-C) C-PDL-BUFFER-POINTER-POP)		;FROM
XCARC0	(CALL-XCT-NEXT GADPTR)
       ((M-A) M-T)
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-CONTENTS)
	((M-A) M-C)					;FROM-ARRAY
	((M-R) M-S)					;TO LENGTH
	((M-C) M-E)					;TO ADDRESS
	((M-I) M-Q)					;TO INITIAL INDEX
	(CALL-XCT-NEXT GADPTR)
       ((M-K) M-B)					;TO ARRAY HEADER
  (ERROR-TABLE CALLS-SUB COPY-ARRAY-CONTENTS)
XCARC1	(JUMP-GREATER-OR-EQUAL M-I A-R XTRUE)		;TO ARRAY DONE, RETURN
	(JUMP-GREATER-OR-EQUAL M-Q A-S XCARC3)		;JUMP IF FROM ARRAY EXHAUSTED
	(DISPATCH-CALL-XCT-NEXT				;M-T := FROM ITEM, CLOBBER M-J
		(LISP-BYTE %%ARRAY-TYPE-FIELD) M-B ARRAY-TYPE-REF-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-B)
XCARC4 ((C-PDL-BUFFER-POINTER-PUSH) M-Q)
	((C-PDL-BUFFER-POINTER-PUSH) M-E)
	((M-Q) M-I)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC XCARC5)))
	(DISPATCH-XCT-NEXT (LISP-BYTE %%ARRAY-TYPE-FIELD) M-K ARRAY-TYPE-STORE-DISPATCH)
   (ERROR-TABLE BAD-ARRAY-TYPE M-K)
       ((M-E) M-C)
XCARC5	((M-I) ADD M-I (A-CONSTANT 1))
	((M-E) C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT XCARC1)
       ((M-Q) ADD C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1))

;COMPUTE FILLER VALUE IN M-T, REENTER AT XCARC4
XCARC3	((M-J) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-K)
	(JUMP-LESS-THAN-XCT-NEXT M-J (A-CONSTANT 7) XCARC4)
       ((M-T) A-ZERO)			;ONE OF THE SIX BYTE ARRAYS, PAD WITH ZERO
	(JUMP-NOT-EQUAL-XCT-NEXT M-J (A-CONSTANT 9) XCARC4)
       ((M-T) A-V-NIL)			;SOME KIND OF Q ARRAY, PAD WITH NIL
	(JUMP-XCT-NEXT XCARC4)
       ((M-T) (A-CONSTANT 200))		;STRING, PAD WITH NULL

;GET ADDRESS AND LENGTH OF ARRAY LEADER
GALPTR	(CALL GAHDR)
	((M-E) SUB M-A (A-CONSTANT 2))		;ADDRESS
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-LEADER-BIT) M-B)
       ((M-S) A-ZERO)				;LENGTH
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;NO TRANSPORT SINCE JUST TOUCHED HEADER
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT
	 (M-S) Q-POINTER READ-MEMORY-DATA)
       (NO-OP)

;GET ADDRESS, LENGTH, AND INITIAL INDEX OF ARRAY
GADPTR	(CALL GAHDR)
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B)
       ((M-Q) A-ZERO)
	(JUMP DSP-ARRAY-SETUP)

XNUMBP (MISC-INST-ENTRY NUMBERP)
	((M-K) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-K POPJ-IF-NOT-NUMBER)
       ((M-T) A-V-NIL)
	(JUMP XTRUE)

XDATTP (MISC-INST-ENTRY %DATA-TYPE)
	(POPJ-AFTER-NEXT 
	 (M-T)  C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		Q-DATA-TYPE)
       (NO-OP)

XDAT   (MISC-INST-ENTRY %POINTER)
	(POPJ-AFTER-NEXT 
	 (M-T)  C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		Q-POINTER)
       (NO-OP)

XSDATP (MISC-INST-ENTRY %MAKE-POINTER)
	((A-TEM1) C-PDL-BUFFER-POINTER-POP)    ;ARG2, THE POINTER
	(POPJ-AFTER-NEXT 
	 (M-T) C-PDL-BUFFER-POINTER-POP)       ;ARG1, THE DATA TYPE
       ((M-T) DPB M-T Q-DATA-TYPE A-TEM1)
	
XSTND (MISC-INST-ENTRY %P-STORE-CONTENTS)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;NEED IN M-T FOR RETURNED VALUE
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE)
	    SELECTIVE-DEPOSIT READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

XOPLDB(MISC-INST-ENTRY %P-LDB-OFFSET)
	(JUMP-XCT-NEXT XOPLD1)			;JOIN XLDB, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION

XLLDB (MISC-INST-ENTRY %LOGLDB)			;LDB FOR FIXNUMS
	(JUMP-XCT-NEXT XLLDB1)
       ((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)

;%P-LDB treats target Q just as 32 bits.  Data type is not interpreted.
XPLDB (MISC-INST-ENTRY %P-LDB)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)			;VMA MAY POINT AT UNBOXED DATA.
XOPLD1  ((M-1) READ-MEMORY-DATA)		;VMA MAY BE LEFT POINTING AT UNBOXED DATA..
XLLDB1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) ;ARG1, BYTE POINTER.  MUST BE FIXNUM.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XLDB-ZERO)  ;WANT 0 BITS, RETURN 0
					   ; (THIS IS A FAIRLY RANDOM THING TO CHECK FOR
					   ; BUT IF WE DIDNT, IT WOULD CAUSE LOSSAGE)
	(CALL-GREATER-THAN M-K (A-CONSTANT 30) TRAP)
    (ERROR-TABLE ARGTYP FIXNUM-FIELD PP 0)
	((M-J) SUB M-K (A-CONSTANT 1))	   ;BYTE LENGTH MINUS ONE FIELD
	((M-E) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	((A-TEM2) SUB (M-CONSTANT 40) A-E)	  ;COMPENSATE FOR SHIFTER LOSSAGE
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-J A-TEM2 OAL-BYTL-1)
       ((M-T) BYTE-INST 
		M-1 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;LDB can only extract from fixnums and bignums.  The target is considered to
; have infinite sign extension.  LDB "should" always return a positive number.
; This issue currently doesn't arise, since LDB is implemented only for
; positive-fixnum-sized bytes, i.e. a maximum of 23. bits wide.  Note the
; presence of %LOGLDB, which will load a 24-bit byte of a fixnum and return
; it as a possibly-negative fixnum.
XLDB  (MISC-INST-ENTRY LDB)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)  ;Only the second operand is
	    (ERROR-TABLE ARGTYP NUMBER PP 1 XLDB)   ;processed via NUMARG.  Thus LDB is
       ((M-A) (A-CONSTANT ARITH-1ARG-LDB))	    ;considered to be a one operand op.
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)	;Arg1, byte pointer.  Must be fixnum.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
            (ERROR-TABLE ARGTYP FIXNUM PP 0)
;Fixnum case.  Data to LDB out of (arg2) sign extended in M-1.
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;Get number of bits
	(JUMP-EQUAL M-K A-ZERO XLDB-ZERO)  ;Want 0 bits, return 0
					   ; (This is a fairly random thing to check for
					   ; but if we didnt, it would cause lossage)
	(CALL-GREATER-THAN M-K (A-CONSTANT 23.) TRAP)
    (ERROR-TABLE ARGTYP FIXNUM-FIELD PP 0)
	((M-J) SUB M-K (A-CONSTANT 1))	   ;Byte length minus one field
	((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6)
		 C-PDL-BUFFER-POINTER-POP) ;Get number of places over
	((M-2) SUB (M-CONSTANT 40) A-K)	   ;Maximum M-rotate to keep byte within a word
XLDB3	(JUMP-GREATER-THAN M-E A-2 XLDB2)  ;Jump if left edge of byte off end of word
	((A-TEM2) SUB (M-CONSTANT 40) A-E) ;Compensate for shifter lossage
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-J OAL-BYTL-1 A-TEM2)
       ((M-T) BYTE-INST M-1
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  

;Get here if left edge of byte is off 32. bit word.  Arithmetic shift right until it fits.
XLDB2	((M-1) LDB (BYTE-FIELD 31. 1) M-1 A-1)
	(JUMP-XCT-NEXT XLDB3)
       ((M-E) SUB M-E (A-CONSTANT 1))

BIGNUM-LDB	;M-Q has bignum, M-C has bignum header, M-I has length of bignum.
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)	;Arg1, byte pointer.  Must be fixnum.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
            (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;Get number of bits
	(CALL-GREATER-THAN M-K (A-CONSTANT 23.) TRAP)
	    (ERROR-TABLE ARGTYP FIXNUM-FIELD PP 0)
	((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6)
			 C-PDL-BUFFER-POINTER)  ;Number of places over
	((M-D) (A-CONSTANT 1))			;Offset within bignum
BIGLDB2	(JUMP-LESS-THAN M-E (A-CONSTANT 31.) BIGLDB1)  ;Found word desired byte starts in
	((M-D) ADD M-D (A-CONSTANT 1))
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-D A-I BIGLDB2)
       ((M-E) SUB M-E (A-CONSTANT 31.))
	((OA-REG-HIGH) BIGNUM-HEADER-SIGN M-C)	;Byte off top of bignum, return sign bits
	((M-T) M-ZERO)
	(JUMP C-PDL-BUFFER-POINTER-POP BIGLDB6)	;Truncate byte and return (also flush arg)

BIGLDB1	((VMA-START-READ) ADD M-Q A-D)	;Fetch word of bignum
	(CHECK-PAGE-READ)
	((M-ZR) (A-CONSTANT 31.))	;31. useful bits in bignum word.
	(CALL-XCT-NEXT I-LDB)		;Get at least some of the right stuff into M-2
       ((M-1) READ-MEMORY-DATA)
	((M-T) Q-POINTER M-2 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) ;Force result into fixnum
	(JUMP-EQUAL M-4 A-K BIGLDB3)   ;and return it if that is entire byte
	(JUMP-EQUAL M-D A-I BIGLDB3)   ;Also return if that was last word of bignum
	((VMA-START-READ) M+A+1 M-Q A-D)	;Get next word of bignum
	(CHECK-PAGE-READ)
	((M-J) M-A-1 M-K A-4)		;Number of bits left to go minus one
	((OA-REG-LOW) DPB M-J OAL-BYTL-1 A-ZERO)
	((M-1) BYTE-INST READ-MEMORY-DATA A-ZERO)  ;Get bits from second word
	((OA-REG-LOW) DPB M-J OAL-BYTL-1 A-4)   ;Put those bits above the previous bits.
	((M-T) DPB M-1 A-T)
BIGLDB3	(POPJ-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-C)	;Done if bignum was positive
       ((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6)	;Retrieve byte pos, flush arg from pdl
			 C-PDL-BUFFER-POINTER-POP)
	;; Bignum was negative.  Take complement of the byte value retrieved.
	;; This is a 1's or 2's complement depending on whether all bits to the
	;; right are zero.  M-K still has the byte size.
	((M-T) XOR M-T (A-CONSTANT -1))	;1's complement the byte and some extra bits to left
	((VMA) M-Q)			;Scan the bignum for zeros, until start of the byte
BIGLDB4	(JUMP-LESS-OR-EQUAL M-E A-ZERO BIGLDB7)
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(JUMP-LESS-THAN M-E (A-CONSTANT 31.) BIGLDB5)
	(JUMP-EQUAL-XCT-NEXT READ-MEMORY-DATA A-ZERO BIGLDB4)
       ((M-E) SUB M-E (A-CONSTANT 31.))
BIGLDB6	((M-K) SUB M-K (A-CONSTANT 1))	;OK, truncate the byte value and return it
	(POPJ-AFTER-NEXT (OA-REG-LOW) DPB M-K OAL-BYTL-1 A-ZERO)
       ((M-T) (BYTE-FIELD 0 0) M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

BIGLDB5	((M-E) SUB M-E (A-CONSTANT 1))	;Check bits in last word
	((OA-REG-LOW) DPB M-E OAL-BYTL-1 A-ZERO)
	((M-TEM) (BYTE-FIELD 0 0) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-TEM A-ZERO BIGLDB6)
BIGLDB7	(JUMP-XCT-NEXT BIGLDB6)		;2's complement
       ((M-T) ADD M-T (A-CONSTANT 1))

XLSH-ZERO 
XLDB-ZERO 
	(POPJ-AFTER-NEXT 
	 (M-T) SETA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) ;RESULT = 0
		    C-PDL-BUFFER-POINTER-POP)	;DON'T FORGET TO POP ARG1
       (NO-OP)

;INTERNAL LDB.  TAKES DATA IN M-1, BITS IN M-K, PLACES OVER IN M-E.
; SIZE OF DATA IN M-1 IN M-ZR (MAX 32.).
; RETURNS BYTE IN M-2.  M-4 GETS NUMBER OF BITS OF M-2 THAT ACTUALLY 
; CONTAIN DESIRED BYTE, IE, SAME AS M-K IF ENTIRE BYTE WAS WITHIN M-ZR BITS,
; OTHERWISE ONE LESS FOR EACH BIT BYTE EXTENDED BEYOND M-ZR BITS, OR ZERO IF
; BYTE WAS ENTIRELY TO THE LEFT OF M-ZR BITS.  REST OF M-2 IS ZERO.
I-LDB	((M-2) ADD M-K A-E)
	(JUMP-GREATER-THAN M-2 A-ZR I-LDB0)	;LEFT EDGE OF BYTE OFF TOP
	((M-4) M-K)				;ENTIRE BYTE WILL FIT.
I-LDB2	(POPJ-EQUAL-XCT-NEXT M-4 A-ZERO)
       ((M-2) A-ZERO)				;RETURN 0 FOR 0 LENGTH BYTE.
	((A-TEM2) SUB (M-CONSTANT 40) A-E)
	((M-TEM) SUB M-4 (A-CONSTANT 1))	;HARDWARE BYTE LENGTH IS REAL VALUE -1.
	(POPJ-AFTER-NEXT
	 (OA-REG-LOW) DPB M-TEM OAL-BYTL-1 A-TEM2)
       ((M-2) BYTE-INST M-1 A-ZERO)

I-LDB0	((M-2) SUB M-2 A-ZR)			;NUMBER OF BITS OFF TOP
	(JUMP-LESS-THAN-XCT-NEXT M-E A-ZR I-LDB2) ;JUMP IF ANY BITS OF BYTE IN THIS WORD
       ((M-4) SUB M-K A-2)			;REDUCE SIZE OF BYTE TO AS MUCH AS WILL FIT
	(POPJ-AFTER-NEXT (M-4) A-ZERO)		;BYTE NOT IN THIS WORD, RETURN 0 BITS
       ((M-2) A-ZERO)

;INTERNAL DPB. TAKES DATA TO DEPOSIT IN M-1, DATA TO DEPOSIT INTO IN M-2,
; SIZE OF M-2 (MAX 32.) IN M-ZR.  BITS IN M-K, PLACES OVER IN M-E.
; RESULT IN M-2.  M-K REDUCED BY BITS THAT WERE DEPOSITED (IE WILL BE ZERO IF
; ENTIRE BYTE FIT).  IF BYTE DID NOT COMPLETELY FIT, M-1 IS SHIFTED RIGHT BY
; AMOUNT THAT DID FIT.  SMASHES M-4, TEMPS
I-DPB	(POPJ-EQUAL M-K A-ZERO)
	((M-4) ADD M-K A-E)
	(JUMP-GREATER-THAN-XCT-NEXT M-4 A-ZR I-DPB0)	;JUMP IF LEFT EDGE OF BYTE OFF TOP
       ((M-TEM) SUB M-K (A-CONSTANT 1))
	((M-K) A-ZERO)				;NONE LEFT TO DO, WHOLE BYTE IN THIS WORD
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-TEM OAL-BYTL-1 A-E)
       ((M-2) DPB M-1 A-2)

I-DPB0	(POPJ-GREATER-OR-EQUAL M-E A-ZR)	;RETURN IF ENTIRE BYTE OFF TO LEFT
	((M-K) SUB M-4 A-ZR)			;M-K GETS NUMBER OF BITS LEFT OVER
	((M-TEM) SUB M-TEM A-K)			;REDUCE SIZE OF BYTE
	((OA-REG-LOW) DPB M-TEM OAL-BYTL-1 A-E)
	((M-2) DPB M-1 A-2)			;DO THE DPB
	((A-TEM2) M-A-1 (M-CONSTANT 40) A-TEM)	;SHIFT OVER TO USE UP WHATS BEEN DPB'ED
	(POPJ-AFTER-NEXT 			;FACT BYTE SIZE IS +1 DOESNT HURT,
	 (OA-REG-LOW) DPB M-K OAL-BYTL-1 A-TEM2)	; SINCE M-1 WASN'T 32 BITS
       ((M-1) BYTE-INST M-1 A-ZERO)		;RIGHT ADJUST BITS IN M-1 FOR NEXT TIME.

XOPDPB(MISC-INST-ENTRY %P-DPB-OFFSET)
	(JUMP-XCT-NEXT XOPDP1)			;JOIN XDPB, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE DATA AND SET VMA

XLDPB (MISC-INST-ENTRY %LOGDPB)    ;DPB FOR FIXNUMS ONLY, CAN STORE INTO SIGN BIT
	((M-2) C-PDL-BUFFER-POINTER-POP)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)
	((M-E) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT I-DPB)	  ;SEMI-RANDOM TO USE THIS ROUTINE, BUT SPEED DOESNT
       ((M-ZR) (A-CONSTANT 24.))  ; MATTER AND IT SAVES A UINST OR TWO.
	(POPJ-AFTER-NEXT 
	  (M-T) DPB M-2 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XPDPB (MISC-INST-ENTRY %P-DPB)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)	;VMA MAY POINT TO UNBOXED DATA
XOPDP1  ((M-1) READ-MEMORY-DATA)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		 ;ARG2, BYTE POINTER
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER) ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XDPB-ZERO)
	((M-K) SUB M-K (A-CONSTANT 1))
	((A-TEM1) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	((OA-REG-LOW) DPB M-K A-TEM1 OAL-BYTL-1)
	((M-T) DPB C-PDL-BUFFER-POINTER-POP A-1)
	((WRITE-MEMORY-DATA-START-WRITE) M-T)	;VMA CAN BE LEFT POINTING AT UNBOXED DATA
 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (CHECK-PAGE-WRITE)
       
; DPB never changes the sign of quantity DPB'ed into, it extends
; the sign arbitrarily far to the left past the byte.
XDPB (MISC-INST-ENTRY DPB)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))	;ADDRESS ARG1
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)	;MAKE SURE NOT BIGNUM
    (ERROR-TABLE ARGTYP FIXNUM (PP -2) 0)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG) ;ONLY THE THIRD OPERAND IS 
	    (ERROR-TABLE ARGTYP NUMBER PP T XDPB)  ;PROCESSED VIA NUMARG. THUS DPB IS A
       ((M-A) (A-CONSTANT ARITH-1ARG-DPB))	   ;ONE OPERAND OP.
;FIXNUM CASE.  DATA TO DPB INTO (ARG3) SIGN EXTENDED IN M-1.
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		 ;ARG2, BYTE POINTER
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER) ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XDPB-ZERO)
	(CALL-GREATER-THAN M-K (A-CONSTANT 23.) TRAP)
	    (ERROR-TABLE ARGTYP FIXNUM-FIELD PP 0)
	((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6)
			C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
ASHDPB	((M-J) SUB M-K (A-CONSTANT 1))
	((M-2) ADD M-K A-E)
	(JUMP-GREATER-THAN M-2 (A-CONSTANT 31.) XDPB2A)
	((OA-REG-LOW) DPB M-J OAL-BYTL-1 A-E)	  ;WILL FIT IN MACHINE WORD SO GO AHEAD
	((M-1) DPB C-PDL-BUFFER-POINTER-POP A-1)
	(JUMP-GREATER-THAN M-1 (A-CONSTANT 37777777) FIX-OVERFLOW-1)
	(POPJ-AFTER-NEXT 
	 (M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (CALL-LESS-THAN M-1 (A-CONSTANT -40000000) FIX-OVERFLOW-1)

;Get here on DPB ing into fixnum at position beyond 31. bits.  Fake up bignum
; and fall into bignum case.  Hair is that it avoids creating a
; garbage bignum just to copy out of.
XDPB2A	(CALL-LESS-THAN-XCT-NEXT M-1 A-ZERO XDPB-BM)   ;MAGNITUDIFY M-1 AND SAVE SIGN
       ((M-C) A-ZERO)		    ;IN BIGNUM-HEADER-SIGN POSITION.
ASHDPB1	((M-J) DPB M-E (BYTE-FIELD (DIFFERENCE 23. 6) 6) A-K)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-J Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  ;PUSH ARG2 BACK
	((M-D) DPB M-1 Q-POINTER    ;SUBROUTINE SMASHES M-1
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  ;THIS IS NOW ALWAYS A POSITIVE
	(CALL-XCT-NEXT DPB-BIGNUM-SETUP)			; NUMBER EVEN IF IT IS SETZ
       ((M-I) A-ZERO)	;INDICATE SPECIAL CASE TO BIGNUM-COPY-EXPAND. HEADER SIGN IN M-C.
	((MD) Q-POINTER M-D)
	((VMA-START-WRITE) ADD M-T (A-CONSTANT 1))  ;STORE AWAY SAVED PIECE, CREATING
	(CHECK-PAGE-WRITE)			    ;BIGNUM TO SMASH
	(JUMP BIGDPB0)

XDPB-BM	(POPJ-AFTER-NEXT   ;MAKING NEGATIVE NUMBER.  MAGNITUDIFY AND SET BIGNUM SIGN BIT.
	 (M-1) SUB M-ZERO A-1)
       ((M-C) DPB M-MINUS-ONE BIGNUM-HEADER-SIGN A-ZERO)

;Bignum in M-T, length in M-I.  Take 2's complement of it.  Bashes M-3, M-4
BIGNEG	((M-3) (A-CONSTANT 1))		;Offset into bignum
	((M-4) (A-CONSTANT 0))		;0 if borrow, -1 if no borrow
BIGNEG1	((VMA-START-READ) ADD M-T A-3)
	(CHECK-PAGE-READ)
	((M-3) ADD M-3 (A-CONSTANT 1))
	((M-TEM) READ-MEMORY-DATA)
	(JUMP-EQUAL-XCT-NEXT READ-MEMORY-DATA A-ZERO BIGNEG2)
       ((M-TEM) SUB M-4 A-TEM)
	((M-4) (A-CONSTANT -1))		;No more borrow
BIGNEG2	((MD-START-WRITE) (BYTE-FIELD 31. 0) M-TEM)	;Make sure high bit stays clear
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-OR-EQUAL M-3 A-I BIGNEG1)
	(POPJ)

BIGNUM-DPB  ;bignum in M-Q, header in M-C, length in M-I.
	(CALL DPB-BIGNUM-SETUP)
 ;SMASHABLE BIGNUM IN M-T, HEADER IN M-C.  LENGTH IN M-I HAS BEEN SMASHED.
BIGDPB0	((M-I) BIGNUM-HEADER-LENGTH M-C)	;NEW LENGTH
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)  ;NUMBER-OF-BITS
	(CALL-GREATER-THAN M-K (A-CONSTANT 23.) TRAP)
	    (ERROR-TABLE ARGTYP FIXNUM-FIELD PP 0)
	(CALL-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BIGNEG)	;GET 2'S COMPLEMENT REPRESENTATION
	((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6)
		C-PDL-BUFFER-POINTER-POP)  ;NUMBER OF PLACES OVER
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;DATA TO DEPOSIT.
	((M-D) (A-CONSTANT 1))		;OFFSET WITHIN BIGNUM
BIGDPB2	(JUMP-LESS-THAN M-E (A-CONSTANT 31.) BIGDPB1)
	((M-D) ADD M-D (A-CONSTANT 1))		;BYTE DOES NOT START IN THIS WORD
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-D A-I BIGDPB2)
       ((M-E) SUB M-E (A-CONSTANT 31.))
	(CALL TRAP)
	   (ERROR-TABLE BIGNUM-NOT-BIG-ENUF-DPB)	;SHOULDN'T HAPPEN

BIGDPB1	((VMA-START-READ) ADD M-T A-D)	  ;FETCH WORD OF BIGNUM
	(CHECK-PAGE-READ)
	((M-ZR) (A-CONSTANT 31.))
	(CALL-XCT-NEXT I-DPB)		;DEPOSIT IN SOME
       ((M-2) READ-MEMORY-DATA)
	((MD-START-WRITE) M-2)		;WRITE THAT WORD BACK.
	(CHECK-PAGE-WRITE)
	(JUMP-EQUAL M-K A-ZERO BIGDPB3)  ;NO BITS LEFT TO DEPOSIT
	((VMA-START-READ) ADD M-T A-D ALU-CARRY-IN-ONE)
	(CHECK-PAGE-READ)
	((M-E) A-ZERO)
	(CALL-XCT-NEXT I-DPB)		;DEPOSIT THE REST OF THE BITS.
       ((M-2) READ-MEMORY-DATA)
	((MD-START-WRITE) M-2)
	(CHECK-PAGE-WRITE)
BIGDPB3	(CALL-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BIGNEG)	;If was negated, put in sign-magn form
	(JUMP BIGNUM-DPB-CLEANUP)	;bignum in M-T, header in M-C, length in M-I.

XDPB-ZERO
	((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))) 
	(POPJ-AFTER-NEXT 			;RESULT IS ARG3
	    (M-GARBAGE) C-PDL-BUFFER-POINTER-POP)
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;AND POP OTHER TWO ARGS

XOPMF (MISC-INST-ENTRY %P-MASK-FIELD-OFFSET)
	(JUMP-XCT-NEXT XOPMF1)			;JOIN XMF, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION

XPMF  (MISC-INST-ENTRY %P-MASK-FIELD)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
XOPMF1	(JUMP-XCT-NEXT XPFM1)
       ((M-1) READ-MEMORY-DATA)

XMF   (MISC-INST-ENTRY MASK-FIELD)	;LIKE LDB BUT DATA IN ORIGINAL POSITION IN Q
	((M-1) C-PDL-BUFFER-POINTER-POP)	;DATA TO EXTRACT
XPFM1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP) ;ARG1, BYTE POINTER.  MUST BE FIXNUM.
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)    ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XLDB-ZERO)  ;WANT 0 BITS, RETURN 0
					   ; (THIS IS A FAIRLY RANDOM THING TO CHECK FOR
					   ; BUT IF WE DIDNT, IT WOULD CAUSE LOSSAGE)
	((M-J) SUB M-K (A-CONSTANT 1))	   ;BECAUSE BITS IN LDB IS +1
	((A-TEM2) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	(POPJ-AFTER-NEXT 		   ;NO "SHIFTER LOSSAGE" ON SELECTIVE-DEPOSIT
	 (OA-REG-LOW) DPB M-J A-TEM2 OAL-BYTL-1)
       ((M-T) SELECTIVE-DEPOSIT 
		M-1 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XOPDF(MISC-INST-ENTRY %P-DEPOSIT-FIELD-OFFSET)
	(JUMP-XCT-NEXT XOPDF1)			;JOIN XDF, BUT FIRST
       (CALL XOMR0)				;REFERENCE THE LOCATION AND SET VMA

XPDF (MISC-INST-ENTRY %P-DEPOSIT-FIELD)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
XOPDF1	(CALL-XCT-NEXT XPDF1)
       ((A-TEM3) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) M-T)
 	(POPJ-AFTER-NEXT (M-T) A-V-NIL)
       (CHECK-PAGE-WRITE)

XDF  (MISC-INST-ENTRY DEPOSIT-FIELD)
	((A-TEM3) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG3, DATA TO STORE IN
XPDF1	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		 ;ARG2, BYTE POINTER
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER) ;GET NUMBER OF BITS
	(JUMP-EQUAL M-K A-ZERO XDPB-ZERO)
	((M-K) SUB M-K (A-CONSTANT 1))
	((A-TEM1) (BYTE-FIELD 6 6) C-PDL-BUFFER-POINTER-POP) ;GET NUMBER OF PLACES OVER
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-K A-TEM1 OAL-BYTL-1)
       ((M-T) SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER-POP A-TEM3)

XCMBS (MISC-INST-ENTRY %P-STORE-TAG-AND-POINTER)
	((A-TEM3) Q-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG3, VALUE FOR POINTER FIELD
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)	      ;ARG3 ANY TYPE, MISCBITS MUST BE FIXNUM
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE ARGTYP FIXNUM PP 2)
	((WRITE-MEMORY-DATA) DPB C-PDL-BUFFER-POINTER-POP ;ARG2, VALUE FOR TYPE, ETC.
		Q-ALL-BUT-POINTER A-TEM3)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE M-T) C-PDL-BUFFER-POINTER-POP) ;ARG1, WHERE TO STORE
       (CHECK-PAGE-WRITE)

XPDAT (MISC-INST-ENTRY %P-POINTER)
	((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-POINTER))))
XPDAT1  ((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT
	 (OA-REG-LOW) M-K)
       ((M-T) BYTE-INST READ-MEMORY-DATA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XPDATP (MISC-INST-ENTRY %P-DATA-TYPE)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-DATA-TYPE))))

XPCDRC (MISC-INST-ENTRY %P-CDR-CODE)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-CDR-CODE))))

XPFLAG (MISC-INST-ENTRY %P-FLAG-BIT)
	(JUMP-XCT-NEXT XPDAT1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (BYTE-INST Q-FLAG-BIT))))

XSPDTP (MISC-INST-ENTRY %P-STORE-DATA-TYPE)
	((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-DATA-TYPE))))
XSPDTP1 ((M-T) C-PDL-BUFFER-POINTER-POP)	;DATA TO DPB IN (ALSO RETURN AS VALUE)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	((A-TEM2) READ-MEMORY-DATA)
	((OA-REG-LOW) M-K)
	(POPJ-AFTER-NEXT 
	 (WRITE-MEMORY-DATA-START-WRITE)
	   DPB M-T A-TEM2)
       (CHECK-PAGE-WRITE)

XSPDAT (MISC-INST-ENTRY %P-STORE-POINTER)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-POINTER))))

XSPCDR (MISC-INST-ENTRY %P-STORE-CDR-CODE)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-CDR-CODE))))

XSPUSR (MISC-INST-ENTRY %P-STORE-FLAG-BIT)
	(JUMP-XCT-NEXT XSPDTP1)
       ((M-K) (A-CONSTANT (OA-LOW-CONTEXT (DPB Q-FLAG-BIT))))

;Provides a way to pick up the pointer-field of an external-value-cell
;pointer or a dtp-null pointer, or any invisible pointer,
;converting it into a locative and transporting it if it points to old-space.
XPCAL (MISC-INST-ENTRY %P-CONTENTS-AS-LOCATIVE)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)	;GET SPECD LOCATION
	(CHECK-PAGE-READ)
XPCAL1	(CALL-XCT-NEXT TRANS-OLD0)			;TRANSPORT OLDSPACE POINTER, BUT
       ((M-1) MD)					; DON'T CHASE INVISIBLE POINTERS
	(POPJ-AFTER-NEXT (M-T) Q-POINTER MD 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       (CALL-NOT-EQUAL MD A-1 XPCAL1)			;REPEAT IF E.G. SNAPPED OUT HDR-FWD

XPCALO (MISC-INST-ENTRY %P-CONTENTS-AS-LOCATIVE-OFFSET)
	(JUMP-XCT-NEXT XPCAL1)
       (CALL XOMR0)					;GET SPECD LOCATION
	
XPDIF (MISC-INST-ENTRY %POINTER-DIFFERENCE)
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	  (M-T) SUB C-PDL-BUFFER-POINTER-POP A-T)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;; (%WRITE-INTERNAL-PROCESSOR-MEMORIES CODE ADR D-HI D-LOW)
;;   CODE SELECTS WHICH MEMORY GETS WRITTEN. 1 -> I, 2 -> D, 4 -> A/M . 
;;    (THIS IS A SUBSET OF THE CODE USED IN MCR FILES).
XWIPM (MISC-INST-ENTRY %WRITE-INTERNAL-PROCESSOR-MEMORIES)
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-1) DPB C-PDL-BUFFER-POINTER (BYTE-FIELD 10 30) A-1)  ;M-1 GETS 32 BITS DATA
	((M-2) (BYTE-FIELD 20 10) C-PDL-BUFFER-POINTER-POP)      ;M-2 GETS REST BEYOND THAT
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;ADDRESS
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)		;CODE
	(JUMP-EQUAL M-B (A-CONSTANT 1) XWIPM-I)
	(JUMP-EQUAL M-B (A-CONSTANT 2) XWIPM-D)
	(CALL-NOT-EQUAL M-B (A-CONSTANT 4) TRAP)
   (ERROR-TABLE BAD-INTERNAL-MEMORY-SELECTOR-ARG)
	(JUMP-LESS-THAN M-A (A-CONSTANT 40) XWIPM-M)
	((OA-REG-LOW) DPB M-A OAL-A-DEST A-ZERO)
	((A-GARBAGE) M-1)
	(JUMP XFALSE)

XWIPM-M ((OA-REG-LOW) DPB M-A OAL-M-DEST A-ZERO)
	((M-GARBAGE) M-1)
	(JUMP XFALSE)

XWIPM-D ((OA-REG-LOW) DPB M-A OAL-DISP A-ZERO)
	(DISPATCH A-1 WRITE-DISPATCH-RAM)
	(JUMP XFALSE)

XWIPM-I ((OA-REG-LOW) DPB M-A OAL-JUMP A-ZERO)
	(WRITE-I-MEM A-2 M-1)
	(JUMP XFALSE)

;; Give this an offset into the IO part of the XBUS, not an XBUS address.
;; Someday it will return a bignum; for now, it returns the low 24 bits.
XXBR (MISC-INST-ENTRY %XBUS-READ)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;XBUS WORD ADDR
XXBWS0	(JUMP-XCT-NEXT XUBR1)
       ((VMA-START-READ) ADD M-A (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS))

XUBR (MISC-INST-ENTRY %UNIBUS-READ)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-A) (BYTE-FIELD 17. 1) C-PDL-BUFFER-POINTER-POP)	;UBUS WORD ADDR
	((VMA-START-READ) ADD M-A (A-CONSTANT LOWEST-UNIBUS-VIRTUAL-ADDRESS))
XUBR1	(CHECK-PAGE-READ)	;MUSTN'T CHECK FOR SEQUENCE BREAKS SINCE
				;ON SOME UNIBUS DEVICES READING HAS SIDE EFFECTS AND
				;IF A SEQUENCE BREAK OCCURRED WE WOULD READ IT TWICE
	(POPJ-AFTER-NEXT
	 (M-T) DPB READ-MEMORY-DATA Q-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

;; %XBUS-WRITE-SYNC w-loc w-val delay s-loc s-mask s-val
;; Waits for (LOGAND (%XBUS-READ s-loc) s-mask) to not-equal s-val, then
;; to equal s-val.  Then it loops 'delay' number of times and writes
;; w-val into w-loc.  This is intended for such things as color-map hacking.
XXBWS (MISC-INST-ENTRY %XBUS-WRITE-SYNC)
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;S-VAL
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;S-MASK
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;S-LOC
XXBWS1	(CALL XXBWS0)
	((M-T) AND M-T A-B)
	(JUMP-EQUAL M-T A-C XXBWS1)
XXBWS2	(CALL XXBWS0)
	((M-T) AND M-T A-B)
	(JUMP-NOT-EQUAL M-T A-C XXBWS2)
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;DELAY
XXBWS3	(JUMP-NOT-EQUAL-XCT-NEXT M-T A-ZERO XXBWS3)
       ((M-T) SUB M-T (A-CONSTANT 1))
	;drop into XXBW

;; See comments on %XBUS-READ above.
XXBW (MISC-INST-ENTRY %XBUS-WRITE)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;WORD TO WRITE, AND VALUE TO RETURN.
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((WRITE-MEMORY-DATA) Q-POINTER M-T)
	((M-A) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-A (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS))
       (CHECK-PAGE-WRITE)

XUBW (MISC-INST-ENTRY %UNIBUS-WRITE)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-T WRITE-MEMORY-DATA) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;WORD TO WRITE
;;; IF THIS IS MADE CONTINUABLE, THIS WILL HAVE TO BE FIXED
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
      (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-A) (BYTE-FIELD 17. 1) C-PDL-BUFFER-POINTER-POP)	;UBUS WORD ADDR
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD M-A (A-CONSTANT LOWEST-UNIBUS-VIRTUAL-ADDRESS))
       (CHECK-PAGE-WRITE)

XGET (MISC-INST-ENTRY GET)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG2, PROPERTY NAME
	(CALL-XCT-NEXT PLGET) ;ARG2, FROB TO GET FROM, GET ITS PLIST INTO M-T
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XGET1	(POPJ-EQUAL M-T A-V-NIL)		;END OF PLIST REACHED
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE THIS PLIST NODE
	(JUMP-EQUAL M-T A-A QTAD)		;GOT IT, RETURN CADR OF NODE
	(JUMP-XCT-NEXT XGET1)
       (CALL QTDD)				;TAKE CDDR AND LOOK AGAIN

;SUBROUTINE TO PICK UP THE PLIST OF THE OBJECT IN M-T, RETURNING IT IN M-T.
;RETURNS NIL IF A RANDOM TYPE, FOR MACLISP COMPATIBILITY.  UNFORTUNATELY
;NOT USEFUL FOR PLIST-CHANGING THINGS, BUT THOSE AREN'T CURRENTLY IN MICROCODE ANYWAY.
PLGET	((M-ZR) Q-DATA-TYPE M-T)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) PLGET2)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LIST)) QCDR) ;"DISEMBODIED" PROPERTY LIST
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) QCDR) ;"DISEMBODIED" PROPERTY LIST
	(JUMP XFALSE)				;GET OF RANDOM THINGS NIL IN MACLISP, SO ...

PLGET2	((VMA-START-READ) ADD M-T		;ARG1, SYMBOL TO GET FROM
		      (A-CONSTANT 3))		;GET PLIST CELL OF ARG1
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XGETL (MISC-INST-ENTRY GETL)
	((M-S) C-PDL-BUFFER-POINTER-POP)	;ARG2, LIST OF PROPERTIES
	(CALL-XCT-NEXT PLGET)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;ARG1, THING TO GET FROM
XGETL1	(POPJ-EQUAL M-T A-V-NIL)		;EXHAUSTED THE PLIST
	(CALL-XCT-NEXT QCAR)			;GET NEXT INDICATOR
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE CURRENT PLIST NODE
	((M-A) Q-TYPED-POINTER M-T)		;SAVE IT
	((M-T) Q-TYPED-POINTER M-S)		;GET LIST OF PROPERTY NAMES
XGETL2	(JUMP-EQUAL M-T A-V-NIL XGETL3)		;NO MATCH THIS ONE
	(CALL-XCT-NEXT QCAR)			;GET NEXT PROP NAME TO TRY
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL M-T A-A POP1TJ)		;GOT IT
	(CALL-XCT-NEXT QCDR)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;TRY NEXT PROP NAME
	(JUMP XGETL2)

XGETL3	(JUMP-XCT-NEXT XGETL1)       
       (CALL QTDD)				;TRY NEXT PROPERTY

POP1TJ	(POPJ-AFTER-NEXT
	  (M-GARBAGE) C-PDL-BUFFER-POINTER-POP)
       ((M-T) C-PDL-BUFFER-POINTER-POP)

XASSQ (MISC-INST-ENTRY ASSQ)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG2
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG1
XASSQ1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QMAA)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL M-T A-A QTA)
	(JUMP-XCT-NEXT XASSQ1)
       (CALL QTD)

POPTJ	(POPJ-AFTER-NEXT
	  (M-T) C-PDL-BUFFER-POINTER-POP)
       (NO-OP)

XLAST (MISC-INST-ENTRY LAST)
	((M-T) C-PDL-BUFFER-POINTER)
XLAST1	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP POPTJ)
	(CALL-XCT-NEXT QCDR)
       ((C-PDL-BUFFER-POINTER) M-T)
	(JUMP XLAST1)

XLENGT (MISC-INST-ENTRY LENGTH)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
   (ERROR-TABLE RESTART LENGTH)
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (CALL-NOT-EQUAL M-T A-V-NIL TRAP)
   (ERROR-TABLE ARGTYP LIST M-T T LENGTH)
	((C-PDL-BUFFER-POINTER-PUSH) 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XLEN1	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP POPTJ)
	(CALL QCDR)
	(JUMP-XCT-NEXT XLEN1)
       ((C-PDL-BUFFER-POINTER) ADD C-PDL-BUFFER-POINTER (A-CONSTANT 1))

XSET (MISC-INST-ENTRY SET)
	((M-T) C-PDL-BUFFER-POINTER-POP) 		;ARG2, NEW VALUE & RESULT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)		;ARG1, THE SYMBOL TO SET
			Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP 0)
	((VMA-START-READ) ADD C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1)) ;ACCESS V.C.
	(CHECK-PAGE-READ)				;READ VALUE CELL FIRST
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;FOLLOW INVISIBLES
XSET1	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA 
		Q-ALL-BUT-TYPED-POINTER A-T)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       (NO-OP)

XNOT (MISC-INST-ENTRY NOT)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-T A-V-NIL XTRUE)
	(JUMP XFALSE)

XATOM (MISC-INST-ENTRY ATOM)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
			Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-ATOM)
	(JUMP XFALSE)
	(JUMP XTRUE)

XHALT (MISC-INST-ENTRY %HALT)
	(JUMP HALT-CONS XHALT)
	(JUMP XFALSE)

XGPN  (MISC-INST-ENTRY GET-PNAME)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) DPB READ-MEMORY-DATA Q-POINTER
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-POINTER)))

; SHIFTING WITH CONS ...
;   THE CONS HARDWARE TAKES THE OPPOSITE APPROACH FROM MOST MACHINES IN THAT
; LDB AND DPB ARE PRIMITIVE AND SHIFTS HAVE TO BE BUILT UP OUT OF THEM INSTEAD
; OF THE OTHER WAY AROUND.  FOR THE PURPOSES OF CONS, THIS IS USUALLY A GREAT
; WIN, BUT IT DOES MAKE FOR A CERTAIN AMOUNT OF PAIN WHEN REALLY TRYING TO DO A SHIFT.
;   FURTHER PAIN IS CAUSED WHEN THE AMOUNT OF THE SHIFT MUST COME FROM THE
; "DATA" SIDE OF THE MACHINE (AS WITH ROT AND LSH) INSTEAD OF BEING A CONSTANT AMOUNT
; KNOWN AT MICRO-ASSEMBLY TIME.  WHEN THIS IS THE CASE,
;  (1) THE ARGUMENT MUST BE "MOVED" FROM THE DATA SIDE TO THE CONTROL SIDE BY THE USE
;	OF OA- TYPE DESTINATIONS.  AS A COLLARY OF THIS, IT IS NECESSARY TO MASK THINGS
;	CAREFULLY TO AVOID RANDOMNESS, AND THERE IS NOT MUCH FLEXIBILITY AS TO 
;	WHAT SIGNS THINGS HAVE ETC.  VARIOUS "QUIRKS" OF THE HARDWARE, NORMALLY
;	COMPENSATED FOR BY THE MICRO-ASSEMBLER, MUST BE DELT WITH BY THE USER:
;	(A) THE BYTE LENGTH FIELD IS REALLY THE	<BYTE-LENGTH-1> FIELD.
;	    ALSO, BECAUSE THE FIELD IS 5 BITS LONG, ZERO BIT BYTES DONT WIN
;	    AT ALL (THEY "BECOME" 32. BYTES).
;	(B) ONE MUST REMEMBER THE M-ROTATE IS ALWAYS A LEFT ROTATE.  THIS IS 
;	    "NATURAL" FOR DPB, BUT ON LDB THE MICROASSEMBLER NORMALLY HAS TO 
;	    BUGGER THINGS TO COMPENSATE AND MAKE IT APPEAR A RIGHT SHIFT IS
;	    BEING DONE.  NATURALLY, USING OA- MODIFIERS, THERE IS NO OPPORTUNITY
;	    FOR THIS TO HAPPEN WITHOUT BEING EXPLICITLY CODED IN MICRO-INSTRUCTIONS.
;	    THE BUGGER REQUIRED IS TO "REPLACE" THE M-ROTATE FIELD WITH
;	      (LOGAND 37 (- 40 <"NATURAL" M-ROTATE>)).
;  (2) THE POSSIBITY OF CONSTRUCTING AN "ILLEGAL" BYTE POINTER ON A DPB MUST BE 
;	CAREFULLY CONSIDERED.  BRIEFLY, THE SUM <BYTE-LENGTH-1> + <M-ROTATE> MUST BE
;	LESS THAN OR EQUAL TO 37 OCTAL.  IF IT IS GREATER, THE HARDWARE WILL
;	PRODUCE AN ALL-ZERO ANSWER (ACTUALLY, IT IS COMPLETELY IDENTICALLY EQUAL TO THE
;	A-SOURCE).  HERE A LDB DOESNT GIVE SO MUCH PROBLEM SINCE
;	THE HARDWARE JUST ROTATES THE INDICATED AMOUNT AND TAKES THE LOW N BITS.

XLSH  (MISC-INST-ENTRY LSH)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG2, AMT TO SHIFT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT M-K XLSH1)  ;SHIFT TO RIGHT
LSH-LEFT
	((M-1) SUB (M-CONSTANT 23.) A-K)	;COMPUTE BYTE LENGTH <24.-SHIFT-1>
	(JUMP-LESS-THAN M-1 A-ZERO XLSH-ZERO)
	(POPJ-AFTER-NEXT
	 (OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-K)
       ((M-T) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 0 0) 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

XLSH1	(JUMP-LESS-THAN M-K (A-CONSTANT (PLUS 1_24. -23.)) XLSH-ZERO) ;SHIFT RIGHT
	((A-TEM1) ADD M-K (A-CONSTANT (PLUS (BYTE-MASK BITS-ABOVE-FIXNUM)  ;TO SIGN EXTEND
					 40)))	; TO 32. COMPUTE 40-N .
	((M-1) ADD M-K (A-CONSTANT (PLUS (BYTE-MASK BITS-ABOVE-FIXNUM)
					 23.)))	;COMPUTE 24.-N-1
	(POPJ-AFTER-NEXT 
	 (OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-TEM1)
       ((M-T) BYTE-INST (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
			C-PDL-BUFFER-POINTER-POP)

XROT  (MISC-INST-ENTRY ROT)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((M-K) Q-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG2, AMT TO ROT
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
   (ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;ARG1, DATA TO ROT
XROT3 ;	*** THIS SHOULD PROBABLY LET YOU INTERRUPT AND SEQUENCE-BREAK OUT ***
	(JUMP-IF-BIT-SET BOXED-SIGN-BIT M-K XROT1)  ;ROT TO RIGHT
	(JUMP-EQUAL M-K A-ZERO CPOPJ)			;NO CHANGE (AVOID BYTL-1 LOSS)
	(JUMP-GREATER-OR-EQUAL M-K (A-CONSTANT 24.) XROT2)
;GENERAL IDEA: (1) SHIFT A 24.-N BIT PIECE N PLACES LEFT
;		    (ACTUALLY, A TRUE SHIFT OF A UNMASKED 32 BIT PIECE WOULD DO.
;		     ON THE OTHER HAND, WE HAVE THE UNSAFE BYTE POINTER PROBLEM.)
;	       (2) LDB A N BIT PIECE FROM 24-N BITS OVER
;	       (3) IOR THE TWO.
XROT3A	;REALLY DO THE WORK. BY NOW, 0 < M-K < 24.
						;DO LSH OF STEP ONE
	((M-1) SUB (M-CONSTANT 23.) A-K)	;COMPUTE BYTE LENGTH
;	(JUMP-LESS-THAN M-1 A-ZERO XLSH-ZERO)   ;CANT BE
	((OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-K)
	((A-TEM3) DPB M-T (BYTE-FIELD 0 0) A-ZERO)	;PART 1 DONE
	((A-TEM2) ADD M-K (A-CONSTANT 8))		;COMPUTE 40-<24.-N>
	((M-ZR) SUB M-K (A-CONSTANT 1))		;BYTE LENGTH MINUS ONE
	((OA-REG-LOW) DPB M-ZR OAL-BYTL-1 A-TEM2)
	(POPJ-AFTER-NEXT			;PART 2 DONE
	  (M-T) BYTE-INST M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) IOR M-T A-TEM3)			;PART 3

XROT2	(JUMP-XCT-NEXT XROT3)			;LOOP UNTIL RESULT AFTER
       ((M-K) SUB M-K (A-CONSTANT 24.))		;SUBTRACTION IS LESS THAN 24.

;ROTATE TO RIGHT.  CONVERT TO EQUIVALENT LEFT ROTATE (24.- <-N>)
XROT1	((M-K) SELECTIVE-DEPOSIT M-K Q-POINTER (A-CONSTANT -1))	;EXTEND SIGN
	(JUMP-XCT-NEXT XROT3)
       ((M-K) ADD M-K (A-CONSTANT 24.))

XPNPCL (MISC-INST-ENTRY PRINT-NAME-CELL-LOCATION)
	((A-TEM1) A-ZERO)
XCL1	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	(POPJ-AFTER-NEXT 
	 (M-T) DPB Q-POINTER C-PDL-BUFFER-POINTER-POP 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
       ((M-T) ADD M-T A-TEM1)

XVCL  (MISC-INST-ENTRY VALUE-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 1))

XFCL  (MISC-INST-ENTRY FUNCTION-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 2))

XPRPCL (MISC-INST-ENTRY PROPERTY-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 3))

XPACKCL (MISC-INST-ENTRY PACKAGE-CELL-LOCATION)
	(JUMP-XCT-NEXT XCL1)
       ((A-TEM1) (A-CONSTANT 4))


XFCTEV (MISC-INST-ENTRY FSYMEVAL)
	(JUMP-XCT-NEXT XSYME2)
       ((M-1) (A-CONSTANT 2))

XSYMEV (MISC-INST-ENTRY SYMEVAL)
	((M-1) (A-CONSTANT 1))
XSYME2	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
	 	  Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL PP T)
	((VMA-START-READ) ADD C-PDL-BUFFER-POINTER-POP A-1)
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA) ;GC, FOLLOW INVZ
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XMKLS (MISC-INST-ENTRY MAKE-LIST)
	(DISPATCH (I-ARG DATA-TYPE-INVOKE-OP)
		Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
  (ERROR-TABLE ARGTYP FIXNUM PP 2)
	((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG 2 NUMBER OF QS
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;ARG 1 AREA
	(JUMP-EQUAL M-B A-ZERO XFALSE)			;ZERO LENGTH LIST IS NIL
	(CALL LIST-OF-NILS)
	(POPJ-AFTER-NEXT
	 (M-T) Q-POINTER M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
       (NO-OP)

XMEMQ (MISC-INST-ENTRY MEMQ)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
XMEMQ1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(POPJ-EQUAL-XCT-NEXT M-T A-A)
       ((M-T) C-PDL-BUFFER-POINTER-POP)
	(JUMP-XCT-NEXT XMEMQ1)
       (CALL QCDR)

XFPIL (MISC-INST-ENTRY FIND-POSITION-IN-LIST)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-B) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
XFPIL1	(POPJ-EQUAL M-T A-V-NIL)
	(CALL-XCT-NEXT QCAR)
       ((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(JUMP-EQUAL-XCT-NEXT M-T A-A XFPLX)
       ((M-T) C-PDL-BUFFER-POINTER-POP)
	((M-B) ADD M-B A-ZERO ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT XFPIL1)
       (CALL QCDR)

XFPLX	(POPJ-AFTER-NEXT 
	 (M-T) M-B)
       (NO-OP)

   (MISC-INST-ENTRY LISTP)
XLISTP	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-LIST)
	(JUMP XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY NLISTP)
XNLSTP	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP SKIP-IF-ATOM)
	(JUMP XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY SYMBOLP)
XSYMP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY NSYMBOLP)
XNSYMP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY ARRAYP)
XARRYP	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) XTRUE)
	(JUMP XFALSE)

   (MISC-INST-ENTRY STRINGP)
XSTRNP	((M-A) C-PDL-BUFFER-POINTER-POP)
	((M-ZR) Q-DATA-TYPE M-A)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-ARRAY-POINTER)) XFALSE)
	((VMA-START-READ) M-A)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-ZR) (LISP-BYTE %%ARRAY-TYPE-FIELD) READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL 
		(FIND-POSITION-IN-LIST 'ART-STRING ARRAY-TYPES))) XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY FBOUNDP)
XFCTNP	(JUMP-XCT-NEXT XBOUNP1)
       ((M-1) (A-CONSTANT 2))

   (MISC-INST-ENTRY BOUNDP)
XBOUNP	((M-1) (A-CONSTANT 1))
XBOUNP1	((M-A) C-PDL-BUFFER-POINTER-POP)
	((M-ZR) Q-DATA-TYPE M-A)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-SYMBOL)) XFALSE)
	((VMA-START-READ) ADD M-A A-1)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-WRITE READ-MEMORY-DATA)	;NOT USING CONTENTS, DON'T BARF IF NULL
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)		;AND DON'T TRANSPORT
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-NULL)) XFALSE)
	(JUMP XTRUE)

   (MISC-INST-ENTRY CLOSURE)	;(CLOSURE <CLOSURE-LIST> <FCTN>)
XCLOS	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 1))
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
	((M-B) (A-CONSTANT 1))
XCLOS1	(JUMP-EQUAL M-T A-V-NIL XCLOS2)		;DETERMINE SIZE OF CLOSURE BLOCK REQD
	(CALL-XCT-NEXT QCAR)
       ((M-C) M-T)
;CHECK FOR & MUMBLES ..
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-C)
	(JUMP-XCT-NEXT XCLOS1)
       ((M-B) ADD M-B (A-CONSTANT 2))

XCLOS2	(CALL-XCT-NEXT LIST-OF-NILS)		;ALLOCATE CLOSURE OUT OF LIST SPACE
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)
	((M-1) C-PDL-BUFFER-POINTER-POP)	;FCTN
	((M-S C-PDL-BUFFER-POINTER-PUSH)	;INTO POSITION FOR RPLACA AND SAVE COPY
		Q-POINTER M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CALL-XCT-NEXT QRAR1)			;(RPLACA <CLOSURE-BLOCK> <FCTN>)
       ((M-T) M-1)				;FCTN
	(CALL QCDR)				;STEP BLOCK POINTER
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
;0(IP) -> FILL POINTER, -1(IP) -> CLOSURE BLOCK, -2(IP) CLOSURE-LIST
XCLOS4	(JUMP-EQUAL M-T A-V-NIL XCLOSX)		;BLOCK PNTR IN M-T
	(CALL QCAR)
	(DISPATCH Q-DATA-TYPE M-T TRAP-UNLESS-SYM)
   (ERROR-TABLE ARGTYP SYMBOL M-T NIL)
	((M-S) C-PDL-BUFFER-POINTER-POP)		;FILL POINTER  (IN POSITION FOR RPLACA)
	((M-T) DPB M-T Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	(CALL-XCT-NEXT QRAR1)
       ((M-T C-PDL-BUFFER-POINTER-PUSH) ADD M-T A-ZERO ALU-CARRY-IN-ONE)
					;POINTER TO INTERNAL VALUE CELL
	(CALL QCDR)		;UPDATE FILL POINTER
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)	;READ INTERNAL VALUE CELL
	(CHECK-PAGE-READ)
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;SAVE FILL POINTER
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-1) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL DTP-EXTERNAL-VALUE-CELL-POINTER)) 
			XCLOS3A)	;XFER ON EXTERNAL VALUE CELL ALREADY EXISTS
	((C-PDL-BUFFER-POINTER-PUSH) VMA)	;SAVE POINTER TO INTERNAL VALUE CELL
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;SAVE INTERNAL VALUE CELL CONTENTS
	((M-B) (A-CONSTANT 1))
	(CALL-XCT-NEXT LCONS)			;ALLOCATE EXT VAL CELL IN LIST SPACE
       ((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)
	((VMA M-T) Q-POINTER M-T		;ADDRESS OF NEW EXTERNAL V-C
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTERNAL-VALUE-CELL-POINTER)))
	((WRITE-MEMORY-DATA-START-WRITE)
		DPB C-PDL-BUFFER-POINTER Q-TYPED-POINTER  ;V-C CONTENTS
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER-POP 
		Q-ALL-BUT-TYPED-POINTER A-T)
	((VMA-START-WRITE) C-PDL-BUFFER-POINTER-POP)	;WRITE INTO INTERNAL V-C
	(CHECK-PAGE-WRITE)
XCLOS3	((M-T) DPB M-T Q-POINTER       ;TO AVOID PROFUSION OF RANDOM D.T.S.  AVOIDS LOSSAGE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE))) ;WITH CAR IN QCLS1
					;QCLS1 CHANGES BACK TO DTP-EXT-V-C EVENTUALLY
	(CALL-XCT-NEXT QRAR1)				;FORWARDING PNTR IN M-T
       ((M-S) C-PDL-BUFFER-POINTER-POP)			;GET BACK FILL POINTER
	(CALL QCDR)			;BUMP FILL POINTER
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))	;BUMP BLOCK POINTER
	(CALL-XCT-NEXT QCDR)
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-INDEX)
		;PDL-BUFFER-INDEX NOT SAVED ACROSS SEQUENCE BREAKS
	((PDL-BUFFER-INDEX) SUB PDL-BUFFER-POINTER (A-CONSTANT 2))
	(JUMP-XCT-NEXT XCLOS4)
       ((C-PDL-BUFFER-INDEX) M-T)

XCLOS3A	(JUMP-XCT-NEXT XCLOS3)
       ((M-T) READ-MEMORY-DATA)		;POINTER TO EXTERNAL V-C

XCLOSX	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH FILL POINTER
	(POPJ-AFTER-NEXT 
	 (M-T) DPB C-PDL-BUFFER-POINTER-POP Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-CLOSURE)))
       ((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)	;FLUSH CLOSURE-LIST
	    
;;; MULTIPLY SUBROUTINE
;M-1 TIMES Q-R, RESULT TO Q-R, LEAVES CORRECT HIGH HALF IN M-2.
;CALLER MUST CHECK FOR OVERFLOW, IF SHE CARES.

MPY	((M-2) MULTIPLY-STEP A-1 M-ZERO)
(REPEAT 30. ((M-2) MULTIPLY-STEP M-2 A-1))
	(POPJ-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 0) Q-R)
       ((M-2) MULTIPLY-STEP M-2 A-1)
	(POPJ-AFTER-NEXT
	 (M-2) M-2 SUB A-1)		;FINAGLE IF NEGATIVE VALUE INITIALLY IN Q-R
       (NO-OP)

;;; DIVIDE SUBROUTINE
;   DIVIDEND IN M-1, DIVISOR IN M-2
;   QUOTIENT IN Q-R, REMAINDER IN M-1, CLOBBERS A-TEM1

DIV	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-1 A-ZERO DIV1)
       ((A-TEM1 Q-R) M-1)	;Q GETS MAGNITUDE OF DIVIDEND, A-TEM1 SAVES ORIGINAL
	((Q-R) SUB M-ZERO A-TEM1)
DIV1	((M-1) DIVIDE-FIRST-STEP M-ZERO A-2)
DIV1A	(CALL-IF-BIT-SET (BYTE-FIELD 1 0) Q-R TRAP)	;DIVIDE OVERFLOW
  (ERROR-TABLE DIVIDE-BY-ZERO)
(REPEAT 31. ((M-1) DIVIDE-STEP M-1 A-2))
	((M-1) DIVIDE-LAST-STEP M-1 A-2)
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-ZERO A-TEM1 DIV2) ;JUMP IF POSITIVE DIVIDEND
       ((M-1) DIVIDE-REMAINDER-CORRECTION-STEP M-1 A-2) ;M-1 GETS MAGNITUDE OF REMAINDER
	((M-1) SUB M-ZERO A-1)		;NEGATIVE DIVIDEND => NEGATIVE REMAINDER
DIV2	((A-TEM1) XOR M-2 A-TEM1)	;IF SIGNS OF DIVIDEND AND DIVISOR ARE DIFFERENT,
	(POPJ-LESS-OR-EQUAL M-ZERO A-TEM1)
	(POPJ-AFTER-NEXT
	 (A-TEM1) Q-R)
       ((Q-R) SUB M-ZERO A-TEM1)	;THEN QUOTIENT IS NEGATIVE

;RUNTIME SUPPORT FOR MICRO COMPILED CODE (MOSTLY, ANYWAY)

XMAPLY 
UAPLY  (MISC-INST-ENTRY M-APPLY)
	((M-R) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER)
	(CALL-XCT-NEXT XARGI0)		;RETURN ARG-INFO IN M-T
       ((A-NWADI) A-ZERO)		;GO TO UAPFX TO LEAVE THEM LISTIFIED
	((M-1) (LISP-BYTE %%ARG-DESC-MAX-ARGS) M-T)
	(JUMP-NOT-EQUAL M-1 A-ZERO UAPLY1)	;IF ANY SPREAD ARGS, SPREAD THEM
				;ABOVE 2 INSTRUCTIONS ARE ONLY HERE BECAUSE
				;LINEAR ENTER WOULD BOMB OUT OTHERWISE
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-QUOTED-REST) M-T UAPFX)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-EVALED-REST) M-T UAPFX)
	(JUMP-IF-BIT-SET (LISP-BYTE %%ARG-DESC-INTERPRETED) M-T UAPFX) ;BE CONSERVATIVE
UAPLY1	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;GET BACK FCTN
	((M-C) MICRO-STACK-DATA-POP)		;MICRO RETURN ADDRESS
	(CALL P3LNK)				;PUSH CALL BLOCK, POSSIBLY WITH ADI
						; MV LINK
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;FINISH CALL BLOCK BY PUSHING FCTN
	((M-S) A-ZERO)				;COUNT OF # ARGS PUSHED
	(DISPATCH Q-DATA-TYPE M-R SKIP-IF-LIST)
	 (JUMP MMCAL4)
UAPLY5	(CALL-XCT-NEXT QCAR)
       ((M-T) M-R)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-TYPED-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	(CALL-XCT-NEXT QCDR)
       ((M-T) M-R)
	(DISPATCH Q-DATA-TYPE M-T SKIP-IF-LIST)
	 (JUMP UAPLY6)
	((M-R) M-T)
	(JUMP-XCT-NEXT UAPLY5)
       ((M-S) ADD M-S (A-CONSTANT 1))
	
UAPLY6	((C-PDL-BUFFER-POINTER) DPB C-PDL-BUFFER-POINTER Q-ALL-BUT-CDR-CODE 
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NIL)))
	(JUMP-XCT-NEXT MMCAL4)
       ((M-S) ADD M-S (A-CONSTANT 1))

UAPFX	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)  ;GET BACK FUNCTION.
	((M-C) MICRO-STACK-DATA-POP)		;MICRO RETURN ADDRESS
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE Q-FLAG-BIT 1))
		(BYTE-VALUE %%ADI-TYPE ADI-FEXPR-CALL))))
	(CALL-XCT-NEXT P3LNK)
       ((A-NWADI) (A-CONSTANT 2))
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((C-PDL-BUFFER-POINTER-PUSH) M-R)
	(JUMP-XCT-NEXT MMCAL4)
       ((M-S) (A-CONSTANT 1))

P3LNK   (JUMP-IF-BIT-SET %%-PPBMAA M-C P3LNK1)  ;M-C HAS POPPED MICRO-STACK-DATA, SEE IF
        (JUMP-IF-BIT-SET %%-PPBMIA M-C P3LNK1)	; INDIRECT POINTER TO ADI ON STACK 
						; NEEDED
P3LNK2	(JUMP-EQUAL A-NWADI M-ZERO P3ZERO)	;NO ADI HACKERY
UAPLY4	(JUMP-XCT-NEXT MMASU1)
       ((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS 
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX)
		(BYTE-VALUE %%LP-CLS-ADI-PRESENT 1))))

P3LNK1	((M-J) SUB PDL-BUFFER-POINTER A-NWADI)	;SEE IF INDIRECT ADI POINTER NEEDED
	(JUMP-IF-BIT-SET %%-PPBMIA M-C P3LNK1A)
	((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT (EVAL %LP-CALL-BLOCK-LENGTH)))
P3LNK1A	((M-K) M-J)		;HEAD OF ADI
P3LNK1B	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-INDEX TRAP-UNLESS-FIXNUM)
    (ERROR-TABLE DATA-TYPE-SCREWUP ADI)
	((M-ZR) (LISP-BYTE %%ADI-TYPE) C-PDL-BUFFER-INDEX)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL ADI-RETURN-INFO)) UAPY3B)	
						 ;YEP, FOUND RETURN VALUE ADI
	(CALL-IF-BIT-CLEAR Q-FLAG-BIT C-PDL-BUFFER-INDEX ILLOP)
	((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT 1))
	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT C-PDL-BUFFER-INDEX P3LNK1B)
       ((M-J PDL-BUFFER-INDEX) SUB M-J (A-CONSTANT 1))
	(JUMP P3LNK2)

UAPY3B	(CALL CONVERT-PDL-BUFFER-ADDRESS)	;CONVERT M-K TO VIRTUAL ADDRESS
	(JUMP-EQUAL A-NWADI M-ZERO UAPY3B1)
	((M-K) DPB (M-CONSTANT -1) Q-FLAG-BIT A-K)
UAPY3B1	((C-PDL-BUFFER-POINTER-PUSH) M-K)
	((C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (PLUS (PLUS 
		(BYTE-VALUE Q-FLAG-BIT 1)
		(BYTE-VALUE Q-DATA-TYPE DTP-FIX))
		(BYTE-VALUE %%ADI-TYPE ADI-RETURN-INFO))
		(BYTE-VALUE %%ADI-RET-STORING-OPTION ADI-ST-INDIRECT))))
	((M-1) (A-CONSTANT 2))
	(JUMP-XCT-NEXT UAPLY4)
       ((A-NWADI) ADD M-1 A-NWADI)

;%ARGS-INFO <FUNCTION>   FUNCTION CAN BE ANYTHING MEANINGFUL IN
;FUNCTION CONTEXT. RETURNS FIXNUM.  FIELDS AS IN NUMERIC-ARG-DESC-INFO IN QCOM.

XARGI (MISC-INST-ENTRY %ARGS-INFO)
	((M-S) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
;ENTER HERE FROM APPLY, ALSO REENTER TO TRY AGAIN (CLOSURE, ETC).
XARGI0	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-S XARGI-DISPATCH)  ;INHIBIT-XCT-NEXT UNLESS
       ((M-T) (A-CONSTANT (PLUS (PLUS 			    ; INTERPRETER TRAP
 		(BYTE-VALUE Q-DATA-TYPE DTP-FIX) 
		(BYTE-MASK %%ARG-DESC-INTERPRETED))
		(BYTE-MASK %%ARG-DESC-MAX-ARGS))))

XAGISG	(POPJ-AFTER-NEXT				;STACK GROUP ACCEPTS ANY NUMBER
	 (M-T) DPB (M-CONSTANT -1) (LISP-BYTE %%ARG-DESC-MAX-ARGS)	;OF EVALED ARGS
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XAGUE1	((VMA-START-READ) ADD M-S A-V-MICRO-CODE-ENTRY-AREA)
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-FIX)) XAGUE3)  ;NOT MICROCODED NOW.
	(JUMP-XCT-NEXT XAGUE2)				    ;UCODE-ENTRY
       ((VMA-START-READ) ADD M-S A-V-MICRO-CODE-ENTRY-ARGS-INFO-AREA)

XAGICL	(CALL-XCT-NEXT QCAR)				    ;CLOSURE
       ((M-T) M-S)			;REPLACE BY CAR OF IT AND TRY AGAIN.
	(JUMP-XCT-NEXT XARGI0)
       ((M-S) M-T)

XAGAR1	((VMA-START-READ) M-S)			;ARRAY-POINTER
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT 
	 (M-T)
	  (LISP-BYTE %%ARRAY-NUMBER-DIMENSIONS)
	 	 READ-MEMORY-DATA
		 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) DPB M-T (LISP-BYTE %%ARG-DESC-MIN-ARGS) A-T)  ;COPY INTO BOTH MAX AND MIN

XAGM1	((VMA-START-READ) ADD
		 M-S (A-CONSTANT (EVAL %FEFHI-FAST-ARG-OPT)));MACRO-COMPILED
XAGUE2	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

XARGI3	((VMA-START-READ) ADD M-S (A-CONSTANT 2))	;SYM, REPLACE W FCTN CELL
	(CHECK-PAGE-READ)
XAGUE3	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(JUMP-XCT-NEXT XARGI0)
       ((M-S) Q-TYPED-POINTER READ-MEMORY-DATA)

;Don't call this via JUMP-XCT-NEXT, manually push micro stack.
MMCALL	((M-C) MICRO-STACK-DATA-POP)
MMCAL1	((M-S) READ-I-ARG)	;DISPATCH CONSTANT GIVES NUMBER OF ARGS BEING PASSED
MMCAL4	;PDP10 INTERPRETER ERROR CHECKS ON DATA-TYPE OF M-AP@P, BUT THATS A
	;FAIRLY RANDOM CHECK SO IT IS OMMITTED HERE.
MMCAL5	
MMCAL5A	((PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT (EVAL %LP-EXIT-STATE)))
	((C-PDL-BUFFER-INDEX) DPB M-C Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((A-NARGS) M-S)
	((M-S) SUB PDL-BUFFER-POINTER A-NARGS)
	((M-S PDL-BUFFER-INDEX) (BYTE-FIELD 10. 0) M-S)
	(CALL-NOT-EQUAL M-S A-IPMARK ILLOP)
	((M-A) C-PDL-BUFFER-INDEX)		;GET FUNCTION TO CALL
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;DOES MLLV IF NECC
       (CALL MLLV)

XOMR (MISC-INST-ENTRY %P-CONTENTS-OFFSET)
	(CALL XOMR0)				;READ THE SPECIFIED LOCATION
	(POPJ-AFTER-NEXT DISPATCH TRANSPORT READ-MEMORY-DATA)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)	;RETURN ITS CONTENTS

XOMR0	((M-B) C-PDL-BUFFER-POINTER-POP)	;GET THE OFFSET
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)	;READ THE HEADER WORD
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)	;FOLLOW FORWARDING PTR
	(POPJ-AFTER-NEXT
	 (VMA-START-READ) ADD VMA A-B)		;NOW REFERENCE THE SPECIFIED LOCATION
       (CHECK-PAGE-READ)			;VMA COULD BE POINTING INTO UNFORWARDED DATA

XOMS  (MISC-INST-ENTRY %P-STORE-CONTENTS-OFFSET)
	(CALL XOMR0)				;READ THE SPECIFIED LOCATION, SET VMA
	(JUMP-XCT-NEXT XSET1)
       ((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)

;%MAKE-POINTER-OFFSET <new data type> <pointer> <offset> returns a pointer whose pointer
;   is (+ (%POINTER <pointer>) <offset>) and whose data type is <new data type>.  No data
;   type checks.
XMOP (MISC-INST-ENTRY %MAKE-POINTER-OFFSET)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
		(M-T) ADD C-PDL-BUFFER-POINTER-POP A-T)
       ((M-T) DPB Q-DATA-TYPE C-PDL-BUFFER-POINTER-POP A-T)

;;; %STORE-CONDITIONAL pointer, old-val, new-val
;;; This is protected against interrupts, provided that the value you
;;; are storing does not point to temporary space, and that the location
;;; is guaranteed never to contain a pointer to old-space (i.e. it
;;; only points to static areas.)  This is always protected against
;;; sequence breaks (other macrocode processes).
XSTACQ (MISC-INST-ENTRY %STORE-CONDITIONAL) ;args are pointer, old-val, new-val
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;new
	((M-B) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP) ;old
;Won't interrupt between here
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP) ;pntr
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	((M-1) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-B A-1 XFALSE)		;Return NIL if old-val was wrong
	((WRITE-MEMORY-DATA-START-WRITE)	;Otherwise, store new-val
		SELECTIVE-DEPOSIT
		READ-MEMORY-DATA Q-ALL-BUT-TYPED-POINTER A-A)
;and here
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT GC-WRITE-TEST)
       ((M-T) A-V-TRUE)

XSFP (MISC-INST-ENTRY %STACK-FRAME-POINTER)
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-AP)
	(POPJ-AFTER-NEXT (M-T) M-K)
       (NO-OP)

;TEMPORARY DOUBLE PRECISION KLUDGE.  DOESN'T CHECK FOR OVERFLOW (PRESUMABLY CAN'T ANYWAY!)
XMUL-FRACTIONS (MISC-INST-ENTRY %MULTIPLY-FRACTIONS)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %MULTIPLY-FRACTIONS)
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-2)
	(POPJ-AFTER-NEXT
	 (M-T) (BYTE-FIELD 8 24.) Q-R (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) DPB M-2 (BYTE-FIELD 16. 8) A-T)

;SPECIAL NON-OVERFLOW-CHECKING FUNCTIONS FOR WEIRD HACKS
X24ADD (MISC-INST-ENTRY %24-BIT-PLUS)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %24-BIT-PLUS)
	(POPJ-AFTER-NEXT (M-1) ADD M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

X24SUB (MISC-INST-ENTRY %24-BIT-DIFFERENCE)
	(CALL FXGTPP)
   (ERROR-TABLE CALLS-SUB %24-BIT-DIFFERENCE)
	(POPJ-AFTER-NEXT (M-1) SUB M-1 A-2)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

X24MUL (MISC-INST-ENTRY %24-BIT-TIMES)
	(CALL FXGTPP)
    (ERROR-TABLE CALLS-SUB %24-BIT-TIMES)
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-2)
	(POPJ-AFTER-NEXT (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XGCD (MISC-INST-ENTRY \\)			;GCD, STEIN'S ALGORITHM.
	(CALL-XCT-NEXT GET-FIX-OR-BIGNUM)	; SET UP FOR GCD'S BY GETTING 2 ARGS
       ((M-A) M-ZERO)				;THIS IS MAGIC INDEX ON TYPES OF ARGUMENTS
	(DISPATCH (BYTE-FIELD 2 0) M-A GCD-DISPATCH)

(LOCALITY D-MEM)
(START-DISPATCH 2)
GCD-DISPATCH
	(P-BIT R-BIT)		;FIXNUM-FIXNUM CASE (DROPS THROUGH)
	(INHIBIT-XCT-NEXT-BIT GCD-FIX-BIG)	;FIXNUM-BIGNUM CASE
	(INHIBIT-XCT-NEXT-BIT GCD-BIG-FIX)	;BIGNUM-FIXNUM CASE
	(INHIBIT-XCT-NEXT-BIT GCD-BIG-BIG)	;BIGNUM-BIGNUM CASE
(END-DISPATCH)
(LOCALITY I-MEM)

;;; DROP THROUGH ON FIX-FIX CASE (ARGUMENTS IN M-1 M-2)
GCD-FIX-FIX
	((M-A Q-R) (A-CONSTANT (OA-LOW-CONTEXT ((BYTE-FIELD 32. 0)))))
	(JUMP-GREATER-OR-EQUAL M-1 A-ZERO XGCD0)	;TAKE ABS OF ARGS
	((M-1) SUB M-ZERO A-1)
XGCD0	(JUMP-GREATER-OR-EQUAL M-2 A-ZERO XGCDL)
	((M-2) SUB M-ZERO A-2)
XGCDL	(JUMP-EQUAL M-2 A-ZERO XGCD5)
	(JUMP-GREATER-THAN M-1 A-2 XGCD1)
	((M-TEM) M-1)		;EXCHANGE ARGS SO M-1 IS THE BIGGER
	((M-1) M-2)
	((M-2) M-TEM)
XGCD1	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-1 XGCD2)
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-2 XGCD3)
	((M-A) SUB M-A (A-CONSTANT 37))			;BOTH EVEN
							;ADD1 TO ROTATE FIELD, SUB1 FROM LENGTH
        ((M-2) M-2 OUTPUT-SELECTOR-RIGHTSHIFT-1)
XGCD3	(JUMP-XCT-NEXT XGCDL)				;M-1 EVEN
       ((M-1) M-1 OUTPUT-SELECTOR-RIGHTSHIFT-1)

XGCD2	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) M-2 XGCD4)
	(JUMP-XCT-NEXT XGCDL)				;M-2 EVEN
       ((M-2) M-2 OUTPUT-SELECTOR-RIGHTSHIFT-1)

XGCD4	((M-TEM) M-2)		;BOTH ODD
	((M-2) SUB M-1 A-2)
	(JUMP-XCT-NEXT XGCDL)
       ((M-1) M-TEM)

XGCD5	((OA-REG-LOW) M-A)
	((M-1) DPB M-1 (BYTE-FIELD 0 0) A-ZERO)		;FINAL SHIFTING STEP
	(JUMP-GREATER-OR-EQUAL M-1 (A-CONSTANT 1_23.) FIX-OVERFLOW-1)
        (POPJ-AFTER-NEXT (M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

;;; GCD IS SYMMETRICAL (BIGNUM IN M-B, FIXNUM IN M-2)
;;; THIS DEPENDS ON REMAINDER-BIG-FIX NOT SMASHING M-2 AND LEAVING RESULT IN M-1
;;; SO THAT WE CAN CALL GCD-FIX-FIX IMMEDIATELY
;;;If you want you can call GCD-BIG-FIX-1 with the length of the bignum in M-C
;;; and the sign bit in the low order bit of M-A. Note that GCD-BIG-FIX-1 doesn't handle
;;; the case with a fixnum 0!
GCD-BIG-FIX 
GCD-FIX-BIG
	(JUMP-EQUAL M-2 A-ZERO GCD-IS-ABS-M-B)
	((M-C) BIGNUM-HEADER-LENGTH MD)
	((M-A) BIGNUM-HEADER-SIGN MD)
GCD-BIG-FIX-1
GCD-FIX-BIG-1 
	(JUMP-XCT-NEXT GCD-FIX-FIX)		;DO A FIXNUM FIXNUM GCD,
       (CALL REMAINDER-BIG-FIX-1)		;BUT FIRST GET (\ BIGNUM FIXNUM)

GCD-IS-ABS-M-B
	((M-I) BIGNUM-HEADER-LENGTH MD)
	(JUMP-XCT-NEXT BIGNUM-ABS)
       ((M-Q) M-B)

;;;We get here with a bignum in M-B and a bignum in M-C with its header in MD
;;; M-T also has the same thing in it as M-B
GCD-BIG-BIG
	((M-E) HEADER-REST-FIELD MD)
	((VMA-START-READ) M-B)
	(CHECK-PAGE-READ)
	((M-J) BIGNUM-HEADER-LENGTH M-E)
	((M-I) BIGNUM-HEADER-LENGTH MD)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-I A-J GCDBB-1)
       ((M-D) HEADER-REST-FIELD MD)
	((M-J) BIGNUM-HEADER-LENGTH M-D)
	((M-I) BIGNUM-HEADER-LENGTH M-E)
	((M-D) M-E)
	((M-B) M-C)
	((M-C) M-T)	;Remember M-T and M-B start with the same thing.
GCDBB-1
	(JUMP-GREATER-THAN M-J (A-CONSTANT 1) GCDBB-LONG)
	;; since M-J = 1 we can use Bignum-Fixnum case.
	((VMA-START-READ) ADD M-C (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-2) MD)
	((M-C) BIGNUM-HEADER-LENGTH M-D)
	((M-A) BIGNUM-HEADER-SIGN M-D)
	;;First do (\ bignum fixnum). REMAINDER-BIG-FIX must leave answer in
	;;M-1 and not bash M-2.
	(JUMP-XCT-NEXT GCD-FIX-FIX)
       (CALL REMAINDER-BIG-FIX-1)

;;;When we get here we have the longer bignum in M-B,M-I shorter in M-C,M-J
;;; So M-I and M-J are both 2 or more.
;;;To make this work BDIV-REMAINDER-COMMON must not touch the contents of M-C
GCDBB-LONG 
	((M-Q) M-B)
	((M-R) M-C)		;saved by BDIV-REMAINDER-COMMON
	(CALL-XCT-NEXT BDIV-REMAINDER-COMMON)
       ((M-A) A-ZERO)		;indicate quotient is not being saved.
	;; Now we have a bignum in M-Q,(M-I + 1) that is the remainder
	;;shifted left by an amount determined by M-D. M-C,M-J contains
	;;the bignum we were dividing by.
	;; We are going to pretend from now on that the bignum in
	;;M-Q is only M-J long.
	((M-T) M-C)
	((M-K) ADD M-I (A-CONSTANT 2))		;(length of bignum in M-Q) + 1
	;;Now shift down the bignum in M-Q
	((M-C) M-Q)
	(CALL-XCT-NEXT GCDBB-SHIFT)
       ((M-S) M-Q)
	(JUMP-NOT-EQUAL-XCT-NEXT M-E A-ZERO GCDBB-NO-LUCK)
       ((M-C) M-T)
	((M-1) M-Q)
	((M-Q) A-V-NIL)				;Possible pointer to garbage.
	((M-S) A-V-NIL)				;Possible pointer to garbage.
        (JUMP-XCT-NEXT UN-CONS)
       ((M-2) M-K)				;saved just for the occasion.

GCDBB-NO-LUCK
	;;Figure out how much it was shifted:
	((M-TEM) DPB M-3 (BYTE-FIELD 27. 5.) A-ZERO)
	((M-TEM) SUB M-TEM A-3)
	((M-TEM) ADD M-TEM A-4)
	((M-TEM) SUB M-TEM (A-CONSTANT 31.))
	((M-D) ADD M-TEM A-D)	;M-D had 31. - (the number of extra zeros that
				;BDIV-REMAINDER-COMMON introduced) .
	(CALL-XCT-NEXT SCONS-T)
       ((M-B) ADD M-J (A-CONSTANT 1))
	((MD) ADD M-J (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE M-R) Q-POINTER M-T
			       (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)))
	(CHECK-PAGE-WRITE)
       	(CALL-XCT-NEXT GCDBB-SHIFT)
       ((M-S) M-R)		;Prepare to call GCDBB-SHIFT
	;;M-TEM gets the number of factors of two in the bignum in M-R.
	((M-TEM) DPB M-3 (BYTE-FIELD 27. 5.) A-ZERO)
	((M-TEM) SUB M-TEM A-3)
	((M-TEM) ADD M-TEM A-4)
	;;M-D gets the power of two in the answer:
	(JUMP-LESS-THAN M-D A-TEM GCDBB-4)
       	((M-D) M-TEM)
GCDBB-4
	((M-T) M-Q)		;This one will be the answer
	((M-K) M-J)		;This is its length

;;;We get here with two odd bignums in M-Q and M-R, their actual length is in M-K,
;;; the one to return as answer is also in M-T, the number of powers of 2 in the
;;; answer is in M-D, M-J contains the length of the bignums that might still be nonzero.
GCDBB-LOOP
	((M-I) M-J)		;Step down the bignums
GCDBB-L1
	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((M-2) MD)
	((VMA-START-READ) ADD M-R A-I)
	(CHECK-PAGE-READ)
;	(JUMP-EQUAL-XCT-NEXT M-I (A-CONSTANT 1) GCD-FIX-FIX) ;something like this
;      ((M-1) MD)						;should be done.
	(JUMP-NOT-EQUAL-XCT-NEXT M-2 A-ZERO GCDBB-SUB)
       ((M-I) SUB M-I (A-CONSTANT 1))
	(JUMP-NOT-EQUAL MD A-ZERO GCDBB-ORDER)
	(JUMP-XCT-NEXT GCDBB-L1)
       ((M-J) M-I)

GCDBB-SUB-L
	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((M-2) MD)
	((VMA-START-READ) ADD M-R A-I)
	(CHECK-PAGE-READ)
       	((M-I) SUB M-I (A-CONSTANT 1))
GCDBB-SUB
	(JUMP-GREATER-THAN MD A-2 GCDBB-ORDER)
	(JUMP-LESS-THAN MD A-2 GCDBB-NORDER)
	(JUMP-GREATER-THAN M-I A-ZERO GCDBB-SUB-L)

;;;Here we are done, the answer is in M-T, although it might have to be trimmed and shifted.
;;; There is a bignum to give back in M-Q or M-R.
	(JUMP-EQUAL-XCT-NEXT M-R A-T GCDBB-GIVE-BACK-M-Q)
       ((M-2) ADD M-K (A-CONSTANT 1))	;This is how much to give back
	((M-Q) M-R)
	((M-R) A-V-NIL)				;Possible pointer to garbage.
GCDBB-GIVE-BACK-M-Q
       	((M-1) Q-POINTER M-Q)
	((M-S) A-V-NIL)				;Possible pointer to garbage.
	(CALL-XCT-NEXT UN-CONS)
       ((M-Q) A-V-NIL)				;Possible pointer to garbage.
	((M-1) M-D)
	(CALL-XCT-NEXT DIV)
       ((M-2) (A-CONSTANT 31.))
       	(JUMP-EQUAL-XCT-NEXT M-1 A-ZERO GCDBB-COPY-WORDS)
       ((M-E) Q-R)		;This is the offset we want
	((M-I) M-K)		;Real length (sig. length in M-J)
	((M-B) M-T)				;From
	((M-D) M-T)				;To
	;;Constant for LDB (M-K):
	((M-K) ADD M-1 (A-CONSTANT 1))		;MROT   = M-1 + 1
	((M-TEM) SUB M-1 (A-CONSTANT 1))	;BYTL-1 = M-1 + 1
	((M-K) DPB M-TEM OAL-BYTL-1 A-K)
	;;Constant for DPB (M-S):
	((M-TEM) (A-CONSTANT 30.))
	((M-TEM) SUB M-TEM A-1)			;BYTL-1 = 30. - M-1
	((M-S) DPB M-TEM OAL-BYTL-1 A-1)	;MROT   = M-1
	((M-ZR) SUB M-I A-E)			;Read first word from here.
	((VMA-START-READ) ADD M-D A-ZR)
	(CHECK-PAGE-READ)
	((OA-REG-LOW) M-S)
	((M-2) DPB MD (BYTE-FIELD 0 0) A-ZERO)
	(CALL-XCT-NEXT BDIV-NORMALIZE)
       ((M-ZR) SUB M-ZR (A-CONSTANT 1))
GCDBB-RETURN
	;;Cleanup Bignum in M-Q (Have to reread header to get actual length!)
	((VMA-START-READ) M-T)
	(CHECK-PAGE-READ)
	((M-D) BIGNUM-HEADER-LENGTH MD)
	((M-C) M-D)
	(JUMP-XCT-NEXT ARY-TO-BIG-CLEANUP)
       ((M-E) M-D)

GCDBB-COPY-WORDS
	(JUMP-EQUAL M-E A-ZERO GCDBB-RETURN)
	((M-A) M-K)				;Move words to here,
	((M-B) SUB M-A A-E)			;from here.
GCDBB-COPY-WORDS-1
	((VMA-START-READ) ADD M-T A-B)
	(CHECK-PAGE-READ)
	((VMA-START-WRITE) ADD M-T A-A)
	(CHECK-PAGE-WRITE)
	((M-A) SUB M-A (A-CONSTANT 1))
	(JUMP-GREATER-THAN-XCT-NEXT M-B (A-CONSTANT 1) GCDBB-COPY-WORDS-1)
       ((M-B) SUB M-B (A-CONSTANT 1))
	((MD) A-ZERO)
GCDBB-COPY-WORDS-2
	((VMA-START-WRITE) ADD M-T A-A)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-A (A-CONSTANT 1) GCDBB-COPY-WORDS-2)
       ((M-A) SUB M-A (A-CONSTANT 1))
	(JUMP GCDBB-RETURN)

GCDBB-NORDER
	((M-TEM) M-Q)
	((M-Q) M-R)
	((M-R) M-TEM)
GCDBB-ORDER
	((M-ZR) (A-CONSTANT 1))	;steps (up) thru bignums
	((M-C) A-ZERO)		;borrow from last round
	((M-S) M-R)		;we subtract into this guy
	((M-E) A-ZERO)		;For BIGNUM-RIGHT-JUST
GCDBB-STUFF
	((VMA-START-READ) ADD M-Q A-ZR)
	(CHECK-PAGE-READ)
	((M-2) ADD MD A-C)	;remember to borrow
	((VMA-START-READ) ADD M-R A-ZR)
	(CHECK-PAGE-READ)
	((M-2) SUB MD A-2)
	((M-C) (BYTE-FIELD 1 31.) M-2 A-ZERO)
	(CALL-XCT-NEXT BIGNUM-RIGHT-JUST)
       ((M-2) (BYTE-FIELD 31. 0) M-2 A-ZERO)
	(JUMP-LESS-THAN-XCT-NEXT M-ZR A-J GCDBB-STUFF)
       ((M-ZR) ADD M-ZR (A-CONSTANT 1))
	(CALL-XCT-NEXT BIGNUM-RIGHT-JUST)	;Flush last bits.
       ((M-2) A-ZERO)
	(JUMP-GREATER-THAN M-E A-J GCDBB-LOOP)
GCDBB-STUFF-1
	((MD) A-ZERO)
	((VMA-START-WRITE) ADD M-S A-E)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-E A-J GCDBB-STUFF-1)
       ((M-E) ADD M-E (A-CONSTANT 1))
	(JUMP GCDBB-LOOP)

;;;Right justify a bignum in M-C into a bignum in M-S (M-J contains the length for both.)
;;; M-I steps through M-C and BIGNUM-RIGHT-JUST is used.
;;;In case M-C contains all zeros M-E will contain 0 instead of M-J + 1.
GCDBB-SHIFT
	((M-E) A-ZERO)
	((M-3) A-MINUS-ONE)
	((M-I) (A-CONSTANT 1))	;step thru bignum in M-C
GCDBB-2
	((VMA-START-READ) ADD M-C A-I)
	(CHECK-PAGE-READ)
	(CALL-XCT-NEXT BIGNUM-RIGHT-JUST)
       ((M-2) MD)
	(JUMP-LESS-THAN-XCT-NEXT M-I A-J GCDBB-2)
       ((M-I) ADD M-I (A-CONSTANT 1))
	(CALL-XCT-NEXT BIGNUM-RIGHT-JUST)	;Flush last bits
       ((M-2) A-ZERO)
	(POPJ-GREATER-THAN M-E A-J)
	(POPJ-EQUAL M-E A-ZERO)			;M-C was all zeros!
	((MD) A-ZERO)
GCDBB-3
	((VMA-START-WRITE) ADD M-S A-E)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-E A-J GCDBB-3)
       ((M-E) ADD M-E (A-CONSTANT 1))
	(POPJ)

;;;This takes a stream of 31. bit words and right justifies it
;;; into the bignum in M-S. You hand words in in M-2.
;;; After each call M-E "points" to the location about to be stored into or 0
;;; if no ones have been found, M-3 is the number of 31. bit words of zeros skipped,
;;; M-4 is the number of bits skipped mod 31. M-A and M-B are used for internal
;;; constants for ldbing and dpbing. Temporary things are kept in M-1 as well
;;; Inits: ((M-E) A-ZERO)	;flags that no 1s have been found.
;;;	   ((M-3) A-MINUS-ONE)	;Actually init to anything you want, it will be
;;;				; incremented N+1 times.
BIGNUM-RIGHT-JUST
	(JUMP-EQUAL M-E A-ZERO BIGNUM-RIGHT-JUST-FFO)
	(JUMP-EQUAL M-4 A-ZERO BIGNUM-RIGHT-JUST-PUNT)
	((OA-REG-LOW) M-A)
	((MD) DPB M-2 (BYTE-FIELD 0 0) A-1)
	((VMA-START-WRITE) ADD M-S A-E)
	(CHECK-PAGE-WRITE)
	((OA-REG-LOW) M-B)
	(POPJ-AFTER-NEXT (M-1) (BYTE-FIELD 0 0) M-2 A-ZERO)
       ((M-E) ADD M-E (A-CONSTANT 1))

BIGNUM-RIGHT-JUST-PUNT
	((MD) M-1)
	((VMA-START-WRITE) ADD M-S A-E)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT (M-1) M-2)
       ((M-E) ADD M-E (A-CONSTANT 1))

BIGNUM-RIGHT-JUST-FFO
	(POPJ-EQUAL-XCT-NEXT M-2 A-ZERO)
       ((M-3) ADD M-3 (A-CONSTANT 1))
	((M-E) (A-CONSTANT 1))
	((M-4) A-MINUS-ONE)
	((M-2) DPB M-2 (BYTE-FIELD 31. 1) A-ZERO)
BIGNUM-RIGHT-JUST-FFO-1
	((M-2) (BYTE-FIELD 31. 1) M-2 A-ZERO)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 0) M-2 BIGNUM-RIGHT-JUST-FFO-1)
       ((M-4) ADD M-4 (A-CONSTANT 1))
	((M-1) M-2)
	;;Now for DPB (M-A) we need BYTL-1 = M-4 - 1   and MROT = 31. - M-4
	;;and for LDB (M-B) we need BYTL-1 = 30. - M-4 and MROT = 32. - M-4
	((M-TEM) (A-CONSTANT 30.))
	((M-TEM) SUB M-TEM A-4)
	((M-A) ADD M-TEM (A-CONSTANT 1))
	((M-B) ADD M-TEM (A-CONSTANT 2))
	((M-B) DPB M-TEM OAL-BYTL-1 A-B)
	(POPJ-AFTER-NEXT (M-TEM) SUB M-4 (A-CONSTANT 1))
       ((M-A) DPB M-TEM OAL-BYTL-1 A-A)

XREM (MISC-INST-ENTRY \)
	(CALL-XCT-NEXT GET-FIX-OR-BIGNUM)
       ((M-A) M-ZERO)
	(DISPATCH (BYTE-FIELD 2 0) M-A REMAINDER-DISPATCH)
;;; DROP THROUGH ON FIX-FIX CASE
REMAINDER-FIX-FIX
	(CALL DIV)
XREM1	(POPJ-AFTER-NEXT
	 (M-T) DPB M-1 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

(LOCALITY D-MEM)
(START-DISPATCH 2)
REMAINDER-DISPATCH
	(P-BIT R-BIT)		;FIXNUM-FIXNUM CASE (DROPS THROUGH)
	(INHIBIT-XCT-NEXT-BIT REMAINDER-FIX-BIG)	;FIXNUM-BIGNUM CASE
	(INHIBIT-XCT-NEXT-BIT REMAINDER-BIG-FIX)	;BIGNUM-FIXNUM CASE
	(INHIBIT-XCT-NEXT-BIT REMAINDER-BIG-BIG)	;BIGNUM-BIGNUM CASE
(END-DISPATCH)
(LOCALITY I-MEM)

;;; THE VALUE IS ALWAYS THE FIXNUM EXCEPT WHEN THE FIXNUM IS "SETZ" AND THE BIGNUM IS
;;; POSITIVE "SETZ", IN WHICH CASE THE ANSWER IS 0 (THIS DEPENDS ON THE HEADER FOR THE
;;; BIGNUM BEING IN MD)
REMAINDER-FIX-BIG
	(POPJ-NOT-EQUAL-XCT-NEXT M-2 (A-CONSTANT (PLUS (BYTE-MASK Q-ALL-BUT-POINTER)
						       MINIMUM-FIXNUM)))
       ((M-T) M-C)			;RESULT IS THE FIXNUM, USUALLY
	((M-1) BIGNUM-HEADER-LENGTH MD)	;GET THE LENGTH OF THE BIGNUM
	(POPJ-NOT-EQUAL M-1 (A-CONSTANT 1))
	((VMA-START-READ) ADD M-B (A-CONSTANT 1))	;READ THE BIGNUM
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT
	  POPJ-NOT-EQUAL MD (A-CONSTANT MINIMUM-FIXNUM))
       ((M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;RESULT IS 0

;;; HERE THE BIGNUM IS IN M-B, FIXNUM IN M-2
;;; M-1 IS USED FOR ACCUMULATOR M-B IS THE POINTER TO THE
;;; BIGNUM, M-C IS THE LOOP COUNTER (INITED WITH THE LENGTH OF THE BIGNUM) (ALSO OFFSET)
;;; M-A IS THE SIGN BIT OF THE BIGNUM
;;; REMAINDER MUST BE LEFT IN M-1 FOR THE SAKE OF GCD-BIG-FIX AND REMAINDER-BIG-BIG
;;;People will want to call REMAINDER-BIG-FIX-1 with a fixnum in M-2 a bignum in M-B
;;; its length in M-C and sign bit in the low bit of M-A. REMAINDER-BIG-FIX-1 Doesn't
;;; work if the fixnum is 0! (You must deal with that yourself.)
REMAINDER-BIG-FIX
	(JUMP-EQUAL M-2 A-ZERO RETURN-M-B)
	((M-C) BIGNUM-HEADER-LENGTH MD)
	((M-A) BIGNUM-HEADER-SIGN MD)
REMAINDER-BIG-FIX-1
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-2 A-ZERO REM-BIG-FIX-LOOP)
       ((M-1) SETZ)
	((M-2) SUB M-ZERO A-2)		;TAKE ABS OF DIVISOR
REM-BIG-FIX-LOOP
	((VMA-START-READ) ADD M-B A-C)
	(CHECK-PAGE-READ)
	((A-TEM1) SETZ)			;IMPLICIT ARGUMENT TO DIV1A
	((M-TEM) DPB M-1 (BYTE-FIELD 1 31.) A-ZERO)
	((Q-R) ADD MD A-TEM)
	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 31.) M-TEM REM-BIG-FIX-OVFL)
       ((M-1) (BYTE-FIELD 31. 1) M-1)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 31.) Q-R REM-BIG-FIX-OVFL)
	((M-1) ADD M-1 (A-CONSTANT 1))
;;; HERE M-1,,Q-R HAVE (M-1)*1_31.+MD
REM-BIG-FIX-OVFL
	(CALL-XCT-NEXT DIV1A)
       ((M-1) DIVIDE-FIRST-STEP M-1 A-2)
	(JUMP-NOT-EQUAL-XCT-NEXT M-C (A-CONSTANT 1) REM-BIG-FIX-LOOP)
       ((M-C) SUB M-C (A-CONSTANT 1))
	(POPJ-EQUAL-XCT-NEXT M-A A-ZERO)	;POPJ IF DIVIDEND POSITIVE
       ((M-T) DPB Q-POINTER M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-AFTER-NEXT (M-1) SUB M-ZERO A-1)
       ((M-T) DPB Q-POINTER M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

RETURN-M-B
 	(POPJ-AFTER-NEXT (M-T) M-B)
       (NO-OP)

;;; RETURNS IN M-A BITS SAYING WHAT THE TWO ARGUMENTS ARE (FOR \ AND \\)
;;; IN FIXNUM-FIXNUM CASE RETURNS M-A UNCHANGED (0) AND FIXNUMS IN M-1 AND M-2 (SECOND)
;;; IN THE BIGNUM-FIXNUM AND FIXNUM-BIGNUM CASE, IT RETURNS THE FIXNUM IN M-2 AND THE
;;; BIGNUM IN M-B. IN THE BIGNUM-BIGNUM CASE, IT RETURNS THE BIGNUMS IN M-B AND M-C
;;; IN ANY CASE M-T IS THE SECOND ARGUMENT, M-C IS THE FIRST
GET-FIX-OR-BIGNUM
	((M-T) C-PDL-BUFFER-POINTER-POP)
	((M-1) SELECTIVE-DEPOSIT M-T Q-DATA-TYPE A-ZERO)
	(JUMP-NOT-EQUAL-XCT-NEXT M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
			GET-ANY-BIG)
       ((M-C) C-PDL-BUFFER-POINTER-POP)
	((OA-REG-HIGH) BOXED-SIGN-BIT M-T)		;SIGN EXTEND (MUNG M SOURCE)
	((M-2) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-T)
	((M-1) SELECTIVE-DEPOSIT M-C Q-DATA-TYPE A-ZERO)
	(JUMP-NOT-EQUAL M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)) GET-BIG-FIX)
	(POPJ-AFTER-NEXT
	 (OA-REG-HIGH) BOXED-SIGN-BIT M-C)		;SIGN EXTEND (MUNG M SOURCE)
       ((M-1) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-C)
GET-FIX-ANY
	(POPJ-AFTER-NEXT
	 (OA-REG-HIGH) BOXED-SIGN-BIT M-C)		;SIGN EXTEND (MUNG M SOURCE)
       ((M-2) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-C)

GET-BIG-FIX
	((M-A) (A-CONSTANT 2))
	((M-B) M-C)
	((VMA-START-READ M-I) M-C)
	(CALL ASSURE-BIGNUM)
	(POPJ-AFTER-NEXT
	 (M-C) M-I)
       ((M-B) M-I)

GET-ANY-BIG
	((M-A) (A-CONSTANT 1))
	((VMA-START-READ M-I) M-T)
	(CALL ASSURE-BIGNUM)
	((M-T) M-I)
	((M-1) SELECTIVE-DEPOSIT M-C Q-DATA-TYPE A-ZERO)
	(JUMP-EQUAL-XCT-NEXT M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX))
			GET-FIX-ANY)
       ((M-B) M-T)		;THIS IS THE SECOND ARGUMENT BIGNUM
;;; HERE THEY ARE BIG-BIG
	((M-A) (A-CONSTANT 3))
	((VMA-START-READ M-I) M-C)
	(CALL ASSURE-BIGNUM)
	(POPJ-AFTER-NEXT
	 (M-C) M-I)
	(NO-OP)

;;; ASSURES THAT THE HEADER IN MD POINTS TO A LEGAL BIGNUM HEADER
;;; M-I CONTAINS POINTER TO THE BIGNUM
ASSURE-BIGNUM
	(CHECK-PAGE-READ)			;CHECK FOR PAGE FAULTS
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-I) VMA)		;get transported number address 
	((M-TEM) SELECTIVE-DEPOSIT M-I Q-DATA-TYPE A-ZERO)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)) TRAP)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-I NIL)
	((M-TEM) SELECTIVE-DEPOSIT MD HEADER-TYPE-FIELD A-ZERO)
	(POPJ-EQUAL M-TEM (A-CONSTANT (BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM)))
	(CALL TRAP)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-I NIL)

XDIV-DOUBLE (MISC-INST-ENTRY %DIVIDE-DOUBLE)
	(CALL XDIVD1)					;CALL DOUBLE PRECISION DIVIDE
	(POPJ-AFTER-NEXT 		;DIVIDE CAN'T OVERFLOW
	 (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       (NO-OP)

XREM-DOUBLE (MISC-INST-ENTRY %REMAINDER-DOUBLE)
	(JUMP-XCT-NEXT XREM1)
       (CALL XDIVD1)					;CALL DOUBLE PRECISION DIVIDE

;DOUBLE PRECISION DIVIDE.  ARGS ON PDL ARE DIVIDEND HIGH, DIVIDEND LOW, DIVISOR
XDIVD1	(CALL FXGTPP)					;M-1 GETS DIVIDEND LOW, M-2 DIVISOR
	(CALL-XCT-NEXT FIXGET)				;M-1 GETS DIVDND HIGH, M-2 DIVSR AGAIN
       ((M-A) M-1)					;SAVE DIVIDEND LOW
	((M-TEM) DPB M-1 (BYTE-FIELD 8 24.) A-A)	;LOW WORD HAS 32 BITS
	((M-A) (BYTE-FIELD 24. 8) M-1 A-1)		;ARITH SHIFT M-1 RIGHT 8 FOR HIGH WORD
	(JUMP-GREATER-OR-EQUAL M-1 A-ZERO XDIVD3)	;MAKE DIVIDEND POSITIVE
	(JUMP-NOT-EQUAL-XCT-NEXT M-TEM A-ZERO XDIVD2)	;DOUBLE PRECISION NEGATE M-A,,M-TEM
       ((M-TEM) SUB M-ZERO A-TEM)
	((M-A) SUB M-A (A-CONSTANT 1))			;BORROW IF LOW WORD IS ZERO
XDIVD2	((M-A) SETCM M-A)				;ONES COMPLEMENT HIGH WORD
XDIVD3	;DIVIDEND IS IN M-A (HIGH), M-TEM (LOW), DIVISOR IS IN M-2
	((A-TEM1) M-1)	;ORIGINAL SIGN OF DIVIDEND IS IN SIGN(A-TEM1) FOR DIVIDE
	((Q-R) M-TEM)					;LOW DIVIDEND TO Q-R FOR DIVIDE
	(JUMP-XCT-NEXT DIV1A)				;JOIN NORMAL DIVIDE ROUTINE
       ((M-1) DIVIDE-FIRST-STEP M-A A-2)		;BUT WITH DIFFERENT FIRST STEP

;ARITHMETIC MICROCODE.
;;; XREM, XGCD, XUPARROW, and HAIPART are not in yet.

;Generic operations save away one of these codes to indicate the operation to
;be performed, and then jump to routines that think about types and unpacking.
(ASSIGN ARITH-1ARG-ABS 0)
(ASSIGN ARITH-1ARG-MINUS 1)
(ASSIGN ARITH-1ARG-ZEROP 2)
(ASSIGN ARITH-1ARG-PLUSP 3)
(ASSIGN ARITH-1ARG-MINUSP 4)
(ASSIGN ARITH-1ARG-ADD1 5)
(ASSIGN ARITH-1ARG-SUB1 6)
(ASSIGN ARITH-1ARG-FIX 7)
(ASSIGN ARITH-1ARG-FLOAT 10)
(ASSIGN ARITH-1ARG-SMALL-FLOAT 11)
(ASSIGN ARITH-1ARG-HAULONG 12)
(ASSIGN ARITH-1ARG-LDB 13)	;DEALS WITH 2ND ARG ONLY.
(ASSIGN ARITH-1ARG-DPB 14)	;DEALS WITH 3RD ARG ONLY.
(ASSIGN ARITH-1ARG-ASH 15)
;HAIPART?
(ASSIGN NUM-UNUSED-ARITH-1ARGS 2)

(ASSIGN ARITH-2ARG-ADD 0)
(ASSIGN ARITH-2ARG-SUB 1)
(ASSIGN ARITH-2ARG-MUL 2)
(ASSIGN ARITH-2ARG-DIV 3)
(ASSIGN ARITH-2ARG-EQUAL 4)
(ASSIGN ARITH-2ARG-GREATERP 5)
(ASSIGN ARITH-2ARG-LESSP 6)
(ASSIGN ARITH-2ARG-MIN 7)
(ASSIGN ARITH-2ARG-MAX 10)
(ASSIGN ARITH-2ARG-BOOLE 11)
(ASSIGN NUM-UNUSED-ARITH-2ARGS 6)
;REMAINDER, EXPT?

;These codes are used to save the type of the first numeric argument in dyadic
;operations, so that the routines for handling various types of second arguments
;can dispatch on them.
(ASSIGN NUMBER-CODE-FIXNUM 0)
(ASSIGN NUMBER-CODE-SMALL-FLONUM 1)
(ASSIGN NUMBER-CODE-FLONUM 2)
(ASSIGN NUMBER-CODE-BIGNUM 3)
(ASSIGN NUM-UNUSED-NUMBER-CODES 4)

;This is the format of all DTP-HEADER words.
(DEF-DATA-FIELD HEADER-TYPE-FIELD 5 19.)
(DEF-DATA-FIELD HEADER-REST-FIELD 19. 0)
(ASSIGN NUM-UNUSED-HEADER-TYPES 24.)

;This is how flonums are stored in a header, and how to convert from internal
;form (see below) back into flonum form.
(DEF-DATA-FIELD HEADER-FLONUM-EXPONENT 11. 8.)
(DEF-DATA-FIELD HEADER-FLONUM-HIGH-MANTISSA 8. 0)
(DEF-DATA-FIELD FLONUM-HEADER-HIGH-MANTISSA 8. 24.)
(DEF-DATA-FIELD FLONUM-HEADER-LOW-MANTISSA 24. 0)

;Small-flonum definitions.  These are inums, with a DTP-SMALL-FLONUM data type,
;a 7-bit excess-100 exponent (10^-19 to 10^+19 approximately), and a
;17-bit 2's complement normalized mantissa (5 digits approximately).  The
;sign bit is elided since it is always the complement of the high bit of
;the mantissa, except for zero, which is represented as an all-zero exponent
;and mantissa.

(DEF-DATA-FIELD SMALL-FLONUM-EXPONENT 7 17.)	;The exponent in a small-flonum
(ASSIGN SMALL-FLONUM-EXPONENT-OFFSET 1700)	;To convert from excess-100 to excess-2000
(ASSIGN SMALL-FLONUM-MAX-EXPONENT 177)		;Largest value that fits in exponent field
(DEF-DATA-FIELD FLONUM-SMALL-MANTISSA-FIELD 17. 14.) ;DPB here to put into low-level form
(DEF-DATA-FIELD FLONUM-SMALL-USELESS-BITS 14. 0) ;Low-order discarded bits of mantissa
(DEF-DATA-FIELD FLONUM-SMALL-ROUND-BIT 1 13.)	;Highest discarded bit
(DEF-DATA-FIELD FLONUM-SMALL-GUARD-BITS 13. 0)	;The remaining discarded bits
(DEF-DATA-FIELD FLONUM-SMALL-MANTISSA-LOW-BIT 1 14.)
(DEF-DATA-FIELD SMALL-FLONUM-MANTISSA-HIGH-BIT 1 16.)

;Both flonums and small flonums are converted to an internal
;format, on which the subrouines FADD, FSUB, FMPY, FDIV, etc. work.
;Those routines are also intended to be useful for hairier functions
;such as series expansions when written in microcode.

;These routines operate on numbers which consist of a 32-bit
;normalized 2's complement mantissa in M-1 or M-2 and an excess-2000
;exponent in M-I or M-J.  The binary point is just to the right
;of the sign (bit 31).  The range of mantissas is
;1/2 <= f < 1, -1/2 > f >= -1, except for zero which has a zero
;mantissa and a zero exponent.  All results are normalized and
;properly rounded, and returned in M-1 and M-I.  Overflow and underflow
;are not detected at this level, which is a feature.  Fuzz is not
;hacked.  Rounding is towards even if the discarded bits = exactly 1/2 lsb.

;Definitions for low-level form

(DEF-DATA-FIELD FLONUM-SIGN-BIT 1 31.)
(DEF-DATA-FIELD MANTISSA-HIGH-BIT 1 30.)
(ASSIGN FLONUM-EXPONENT-EXCESS 2000)	;The exponent is excess-2000.
(DEF-DATA-FIELD SIGN-BIT-AND-MANTISSA-HIGH-THREE 4 28.)
(DEF-DATA-FIELD SIGN-BIT-AND-MANTISSA-HIGH-TWO 3 29.)
(DEF-DATA-FIELD SIGN-BIT-AND-MANTISSA-HIGH-BIT 2 30.)

;;; Packing and unpacking fixnums.

FXUNPK-P-1
	((M-1) C-PDL-BUFFER-POINTER-POP)
SIGN-EXTEND-M-1
	(POPJ-AFTER-NEXT 
		(OA-REG-HIGH) BOXED-SIGN-BIT M-1)
       ((M-1) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-1)

FXUNPK-T-2
	(POPJ-AFTER-NEXT 
		(OA-REG-HIGH) BOXED-SIGN-BIT M-T)
       ((M-2) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-T)

;;; Come to one of these to return a fixnum in M-1.
;;; Checks for fixnum overflow, and adds data type DTP-FIX.
;;; Result goes to M-T, and FIXPACK-P also pushes it on the PDL.

FIXPACK-T
	(DISPATCH-POPJ-XCT-NEXT (I-ARG 0) 
		(BYTE-FIELD 2 23.) M-1 D-FXOVCK)
       ((M-T) DPB M-1 Q-POINTER (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
						  (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))

FIXPACK-P
	(DISPATCH-POPJ-XCT-NEXT (I-ARG 1) 
		(BYTE-FIELD 2 23.) M-1 D-FXOVCK)
       ((C-PDL-BUFFER-POINTER-PUSH M-T) DPB M-1 Q-POINTER
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
				  (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))
(LOCALITY D-MEM)
;DISPATCH TABLE FOR CHECKING FOR SINGLE-BIT ADD/SUBTRACT-TYPE FIXNUM OVERFLOW
;ON VALUE WHICH IS UNBOXED IN M-1.  DISPATCH ON SIGN BIT AND LOW DATA TYPE BIT.
;I-ARG SHOULD BE 0 IF RESULT ONLY TO M-T, OR 1 IF ALSO TO PDL.  
;IN ANY CASE, DOES ESSENTIALLY POPJ-XCT-NEXT.
;NEXT SHOULD BE INSTRUCTION TO BOX M-1 AS A FIXNUM.
(START-DISPATCH 2 0)
D-FXOVCK	
	(R-BIT)					 ;BITS AGREE NO OVERFLOW
	(FIX-OVERFLOW INHIBIT-XCT-NEXT-BIT)	 ;DISAGREE => OVERFLOW
	(FIX-OVERFLOW INHIBIT-XCT-NEXT-BIT)	 ;DISAGREE => OVERFLOW
	(R-BIT)					 ;BITS AGREE NO OVERFLOW
(END-DISPATCH)
(LOCALITY I-MEM)

;;; This is called from the fixnum packing routines. M-1 contains a unboxed number
;;; IARG is 0 if the result is to go only to M-T, and 1 if it should also go to the
;;; PDL
FIX-OVERFLOW
	(JUMP-EQUAL READ-I-ARG A-ZERO FIX-OVERFLOW-1)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
FIX-OVERFLOW-1	;Enter directly here with unboxed number in M-1.  Returns bignum in M-T.
	((M-C) M-ZERO)				;sign bit
	(JUMP-GREATER-THAN-XCT-NEXT M-1 A-ZERO OVERFLOW-BIGNUM-CREATE)
       ((M-2) M-ZERO)
	(JUMP-XCT-NEXT OVERFLOW-BIGNUM-CREATE-NEGATIVE)
       ((M-1) SUB M-ZERO A-1)

;;; These return here before returning a value. This puts value from M-T
;;; also on stack for those that need it
M-T-TO-CPDL
	(POPJ-AFTER-NEXT
	 (C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE 
					 (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT))) 
       (NO-OP)

;;; This is called from the fixnum multiply. M-2 contains the high product
;;; and M-1 the low product. Result is to go to the PDL and M-T.
FIX-2-WORD-OVERFLOW
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-2 A-ZERO OVERFLOW-BIGNUM-CREATE)
       ((M-C) M-ZERO)				;sign bit
	((M-1) SUB M-ZERO A-1)
	(JUMP-NOT-EQUAL-XCT-NEXT M-1 A-ZERO OVERFLOW-BIGNUM-CREATE-NEGATIVE)
       ((M-2) M-A-1 M-ZERO A-2)		;ONE'S COMPLEMENT
	((M-2) ADD M-2 (A-CONSTANT 1))	;CARRY FROM LOW TO HIGH WORD
					;DROPS THROUGH
;;; M-2,,M-1 HAS A 64 BIT POSITIVE NUMBER THAT IS A MAX OF 47 BITS OF PRECISION
;;; M-C GETS THE SIGN BIT
;;; M-J GETS LENGTH OF BIGNUM
OVERFLOW-BIGNUM-CREATE-NEGATIVE
	((M-C) SELECTIVE-DEPOSIT M-MINUS-ONE BIGNUM-HEADER-SIGN A-ZERO)
OVERFLOW-BIGNUM-CREATE
	;; We need a 2-word bignum if non-zero bits above the low 31. 
	(JUMP-NOT-EQUAL-XCT-NEXT M-2 A-ZERO OVERFLOW-BIGNUM-CREATE-1)
       ((M-J) (A-CONSTANT 2))
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 31.) M-1 OVERFLOW-BIGNUM-CREATE-1)
	((M-J) (A-CONSTANT 1))
OVERFLOW-BIGNUM-CREATE-1
	(CALL-XCT-NEXT BNCONS)			;Cons up a bignum
       ((M-B) ADD M-J (A-CONSTANT 1))
	((VMA) ADD M-T (A-CONSTANT 1))
	((WRITE-MEMORY-DATA-START-WRITE) (BYTE-FIELD 31. 0) M-1)  ;Low 31. bits
	(CHECK-PAGE-WRITE)
	(POPJ-EQUAL M-J (A-CONSTANT 1))
	((M-TEM) (BYTE-FIELD 1 31.) M-1)
	((VMA) ADD VMA (A-CONSTANT 1))
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-2 (BYTE-FIELD 31. 1) A-TEM)
	(CHECK-PAGE-WRITE)
	(POPJ) ;NO POPJ-AFTER-NEXT, MAY BE RETURNING TO MAIN-LOOP

;;; Packing and unpacking small flonums.

;Unpack from C-PDL-BUFFER-POINTER-POP into M-1 and M-I.
SFLUNPK-P-1
	((M-I) SMALL-FLONUM-EXPONENT C-PDL-BUFFER-POINTER)
	(POPJ-EQUAL-XCT-NEXT M-I A-ZERO FLZERO)		;zero exponent => this is 0.0
       ((M-1) DPB C-PDL-BUFFER-POINTER-POP FLONUM-SMALL-MANTISSA-FIELD A-ZERO)
	((M-I) ADD M-I (A-CONSTANT SMALL-FLONUM-EXPONENT-OFFSET))
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET MANTISSA-HIGH-BIT M-1)
       ((M-1) DPB (M-CONSTANT -1) FLONUM-SIGN-BIT A-1)  ;negative => set sign bit

;Unpack from M-T into M-2 and M-J.
SFLUNPK-T-2
	((M-J) SMALL-FLONUM-EXPONENT M-T)
	(POPJ-EQUAL-XCT-NEXT M-J A-ZERO)	;zero exponent => this is 0.0
       ((M-2) DPB M-T FLONUM-SMALL-MANTISSA-FIELD A-ZERO)
	((M-J) ADD M-J (A-CONSTANT SMALL-FLONUM-EXPONENT-OFFSET))
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET SMALL-FLONUM-MANTISSA-HIGH-BIT M-T)
       ((M-2) DPB (M-CONSTANT -1) FLONUM-SIGN-BIT A-2)

;Pack from M-1 and M-I into C-PDL-BUFFER-POINTER-PUSH and M-T, rounding.
SFLPACK-P
	(JUMP-IF-BIT-CLEAR FLONUM-SMALL-ROUND-BIT M-1 SFLPCK1)	;Jump if no rounding required
	((M-T) FLONUM-SMALL-GUARD-BITS M-1)	;Discarded fraction exactly 1/2 lsb?
	(JUMP-NOT-EQUAL M-T A-ZERO SFLPCK0)	;No, round.
	(JUMP-IF-BIT-CLEAR FLONUM-SMALL-MANTISSA-LOW-BIT M-1 SFLPCK1) ;Yes, round towards even.
SFLPCK0	(CALL-XCT-NEXT FRND1)			;Round and renormalize (may bring in two
       ((M-1) ADD M-1 (A-CONSTANT (BYTE-MASK FLONUM-SMALL-ROUND-BIT))	; garbage bits from Q)
		OUTPUT-SELECTOR-RIGHTSHIFT-1)
SFLPCK1	((M-1) DPB M-ZERO FLONUM-SMALL-USELESS-BITS A-1) ;clear low-order bits so can test zero
	(POPJ-EQUAL-XCT-NEXT M-1 A-ZERO)	;Special case 0.0, which has 0 in exponent
       ((M-T C-PDL-BUFFER-POINTER-PUSH) 	;Store mantissa and data-type fields
		FLONUM-SMALL-MANTISSA-FIELD M-1
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-SMALL-FLONUM)
				  (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))
	((M-I) SUB M-I (A-CONSTANT SMALL-FLONUM-EXPONENT-OFFSET))
	(CALL-LESS-OR-EQUAL M-I A-ZERO TRAP)	;Underflow.  ZUNDERFLOW?
   (ERROR-TABLE FLOATING-EXPONENT-UNDERFLOW SFL)
	(POPJ-AFTER-NEXT
	 (M-T C-PDL-BUFFER-POINTER) DPB M-I SMALL-FLONUM-EXPONENT A-T)
       (CALL-GREATER-THAN M-I (A-CONSTANT SMALL-FLONUM-MAX-EXPONENT) SFL-E-OV) ;Overflow

SFL-E-OV (CALL TRAP)
   (ERROR-TABLE FLOATING-EXPONENT-OVERFLOW SFL)

;Pack from M-1 and M-I into M-T, rounding.
SFLPACK-T
	(CALL SFLPACK-P)
POP-PP-J
	(POPJ-AFTER-NEXT (M-GARBAGE) C-PDL-BUFFER-POINTER-POP)
       (NO-OP)

;;; Packing flonums.

;;; Note: the code to unpack flonums only exists at ARITH-FLO-ANY
;;; and ARITH-ANY-FLO, and is written there.

;;; Take a flonum in M-1/M-I, and return a DTP-EXTENDED-NUMBER to it.
FLOPACK-P
	(JUMP-EQUAL M-1 A-ZERO FLOPACK-P-ZERO) ;In this case M-I has zero, don't trap
	(CALL-LESS-OR-EQUAL M-I A-ZERO TRAP)
   (ERROR-TABLE FLOATING-EXPONENT-UNDERFLOW FLO)
 	(CALL-GREATER-OR-EQUAL M-I (A-CONSTANT 4000) TRAP)
   (ERROR-TABLE FLOATING-EXPONENT-OVERFLOW FLO)
FLOPACK-P-ZERO
	(CALL-XCT-NEXT SCONS-T)
       ((M-B) (A-CONSTANT 2))
	((VMA) ADD M-T (A-CONSTANT 1))		;Write the second word
	((MD-START-WRITE)
		FLONUM-HEADER-LOW-MANTISSA M-1
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
				  (BYTE-VALUE Q-CDR-CODE CDR-NIL))))
	(CHECK-PAGE-WRITE)			;Don't seq brk, need M-1.
	((M-TEM) FLONUM-HEADER-HIGH-MANTISSA M-1
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
				  (BYTE-VALUE Q-CDR-CODE CDR-NEXT)
				  (BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-FLONUM))))
	((VMA) M-T)
	((MD-START-WRITE) DPB M-I HEADER-FLONUM-EXPONENT A-TEM)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT (M-T C-PDL-BUFFER-POINTER-PUSH)
		 Q-POINTER M-T
			   (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)
					     (BYTE-VALUE Q-CDR-CODE CDR-NEXT))))
       (NO-OP) ;May be returning to main loop, can't popj and start-write together
	
FLOPACK-T
	(JUMP-XCT-NEXT FLOPACK-P)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC POP-PP-J)))

;;; Simple one-argument operations.

XABS (MISC-INST-ENTRY ABS) (ERROR-TABLE RESTART XABS)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XABS)
       ((M-A) (A-CONSTANT ARITH-1ARG-ABS))
	(JUMP-GREATER-OR-EQUAL M-1 A-ZERO FIXPACK-T)
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) SUB M-ZERO A-1)

XMINUS (MISC-INST-ENTRY MINUS) (ERROR-TABLE RESTART XMINUS)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XMINUS)
       ((M-A) (A-CONSTANT ARITH-1ARG-MINUS))
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) SUB M-ZERO A-1)

XZEROP (MISC-INST-ENTRY ZEROP) (ERROR-TABLE RESTART XZEROP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XZEROP)
       ((M-A) (A-CONSTANT ARITH-1ARG-ZEROP))
FLONUM-ZEROP
	((M-T) A-V-TRUE)
	(POPJ-AFTER-NEXT POPJ-EQUAL M-1 A-ZERO)
       ((M-T) A-V-NIL)

XPLUSP (MISC-INST-ENTRY PLUSP) (ERROR-TABLE RESTART XPLUSP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XPLUSP)
       ((M-A) (A-CONSTANT ARITH-1ARG-PLUSP))
FLONUM-PLUSP
	((M-T) A-V-TRUE)
	(POPJ-AFTER-NEXT POPJ-GREATER-THAN M-1 A-ZERO)
       ((M-T) A-V-NIL)

XMINUSP (MISC-INST-ENTRY MINUSP) (ERROR-TABLE RESTART XMINUSP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XMINUSP)
       ((M-A) (A-CONSTANT ARITH-1ARG-MINUSP))
FLONUM-MINUSP
	((M-T) A-V-TRUE)
	(POPJ-AFTER-NEXT POPJ-LESS-THAN M-1 A-ZERO)
       ((M-T) A-V-NIL)

X1PLS (MISC-INST-ENTRY 1+) ;ADD1 GETS FSET TO THIS
	    (ERROR-TABLE RESTART X1PLS)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T X1PLS)
       ((M-A) (A-CONSTANT ARITH-1ARG-ADD1))
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) ADD M-1 (A-CONSTANT 1))

X1MNS (MISC-INST-ENTRY 1-) ;SUB1 GETS FSET TO THIS
	    (ERROR-TABLE RESTART X1MNS)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T X1MNS)
       ((M-A) (A-CONSTANT ARITH-1ARG-SUB1))
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) SUB M-1 (A-CONSTANT 1))

XFIX (MISC-INST-ENTRY FIX) (ERROR-TABLE RESTART XFIX)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XFIX)
       ((M-A) (A-CONSTANT ARITH-1ARG-FIX))
	(JUMP FIXPACK-T)

XFLOAT (MISC-INST-ENTRY FLOAT) (ERROR-TABLE RESTART XFLOAT)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XFLOAT)
       ((M-A) (A-CONSTANT ARITH-1ARG-FLOAT))
	((M-I) (A-CONSTANT 2036))
	(CALL-XCT-NEXT FNORM)
       ((Q-R) M-ZERO)
	(JUMP FLOPACK-T)

XSMALL-FLOAT (MISC-INST-ENTRY SMALL-FLOAT) (ERROR-TABLE RESTART XSMALL-FLOAT)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XSMALL-FLOAT)
       ((M-A) (A-CONSTANT ARITH-1ARG-SMALL-FLOAT))
	((M-I) (A-CONSTANT 2036))
	(CALL-XCT-NEXT FNORM)
       ((Q-R) M-ZERO)
	(JUMP SFLPACK-T)

XHAUL (MISC-INST-ENTRY HAULONG)	;TAKES ONE ARG, RETURNS # SIGNIFICANT BITS
	    (ERROR-TABLE RESTART XHAUL)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)
	    (ERROR-TABLE ARGTYP NUMBER PP T XHAUL)
       ((M-A) (A-CONSTANT ARITH-1ARG-HAULONG))
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-1 A-ZERO XHAUL1)
       ((M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-1) SUB M-ZERO A-1)
XHAUL1	(POPJ-EQUAL M-1 A-ZERO)
	((M-T) ADD M-T (A-CONSTANT 1))
	(JUMP-XCT-NEXT XHAUL1)
       ((M-1) (BYTE-FIELD 31. 1) M-1)		;SHIFT RIGHT

XHAULFLO (CALL FLOPACK-P)	;HAULONG or LDB of a flonum.  Argument is unpacked.
	(CALL TRAP)		;Repack and hope don't mind if SFL became FLO in the process.
	    (ERROR-TABLE ARGTYP INTEGER PP T)

;;; Simple two-argument operations.

;;; Generic addition.
XMADD (MISC-INST-ENTRY M-+)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC POP-PP-J)))
QIADD	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-ADD))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(JUMP-XCT-NEXT FIXPACK-P)
       ((M-1) ADD M-1 A-2)

;;; Generic subtraction.
XMSUB (MISC-INST-ENTRY M--)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC POP-PP-J)))
QISUB	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-SUB))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(JUMP-XCT-NEXT FIXPACK-P)
       ((M-1) SUB M-1 A-2)

;;; Generic multiplication.
XMMUL (MISC-INST-ENTRY M-*)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC POP-PP-J)))
QIMUL	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-MUL))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(CALL-XCT-NEXT MPY)	;LOW PRODUCT TO Q-R, HIGH TO M-2
       ((Q-R) M-2)
	((M-TEM) SELECTIVE-DEPOSIT Q-R (BYTE-FIELD 9 23.) A-2)	;DISCARDED BITS AND SIGN
	(JUMP-EQUAL-XCT-NEXT M-TEM A-ZERO FIXPACK-P)   ;JUMP IF NON-OVERFLOWING POSITIVE RESULT
       ((M-1) Q-POINTER Q-R A-TEM)		     ;SIGN EXTEND (IF NON-OVERFLOWING)
	(JUMP-EQUAL M-TEM (A-CONSTANT -1) FIXPACK-P)   ;JUMP IF NON-OVERFLOWING NEGATIVE
	(JUMP-XCT-NEXT FIX-2-WORD-OVERFLOW)
       ((M-1) Q-R)

;;; Generic division.
XMDIV (MISC-INST-ENTRY M-//)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC POP-PP-J)))
QIDIV	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-DIV))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(CALL DIV)
        (POPJ-AFTER-NEXT 		;DIVIDE CAN'T OVERFLOW
	 (M-T) DPB Q-R Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((C-PDL-BUFFER-POINTER-PUSH M-T) DPB M-T Q-TYPED-POINTER	;RESULT TO PDL
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;;; Generic numeric equality (the "=" function).
XMEQL (MISC-INST-ENTRY M-=)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIEQL	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-EQUAL))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	((M-T) A-V-NIL)
	(POPJ-AFTER-NEXT POPJ-NOT-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

;;; Generic numeric GREATERP
XMGRTH (MISC-INST-ENTRY M->)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QIGRP	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-GREATERP))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	((M-T) A-V-NIL)
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

;;; Generic numeric LESSP
XMLESS (MISC-INST-ENTRY M-<)
	((M-T) C-PDL-BUFFER-POINTER-POP)
QILSP	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-LESSP))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	((M-T) A-V-NIL)
	(POPJ-AFTER-NEXT POPJ-GREATER-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

XMAX (MISC-INST-ENTRY *MAX)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-MAX))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(JUMP-GREATER-OR-EQUAL M-1 A-2 FIXPACK-T)
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) A-2)

XMIN (MISC-INST-ENTRY *MIN)
	((M-T) C-PDL-BUFFER-POINTER-POP)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-MIN))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1) ;Not continuable since first arg unpacked
	(JUMP-LESS-OR-EQUAL M-1 A-2 FIXPACK-T)
	(JUMP-XCT-NEXT FIXPACK-T)
       ((M-1) A-2)

;;; Boolean operations

QIAND	(JUMP-XCT-NEXT M-T-TO-CPDL)
       (CALL QIAND0)

XMAND (MISC-INST-ENTRY M-LOGAND)
	((M-T) C-PDL-BUFFER-POINTER-POP)	;Convert to Instruction calling seq
QIAND0	((M-S) (A-CONSTANT (OA-LOW-CONTEXT (AND)))) ;An extra instruction, but saves hair
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-BOOLE))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-T 1)
	(POPJ-AFTER-NEXT (M-1) AND M-2 A-1)
       ((M-T) Q-POINTER M-1 (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

QIIOR	(JUMP-XCT-NEXT M-T-TO-CPDL)
       (CALL QIIOR0)

XMIOR (MISC-INST-ENTRY M-LOGIOR)
	((M-T) C-PDL-BUFFER-POINTER-POP)	;Convert to Instruction calling seq
QIIOR0	((M-S) (A-CONSTANT (OA-LOW-CONTEXT (IOR)))) ;An extra instruction, but saves hair
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-BOOLE))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-T 1)
	(POPJ-AFTER-NEXT (M-1) IOR M-2 A-1)
       ((M-T) Q-POINTER M-1 (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

QIXOR	(JUMP-XCT-NEXT M-T-TO-CPDL)
       (CALL QIXOR0)

XMXOR (MISC-INST-ENTRY M-LOGXOR)
	((M-T) C-PDL-BUFFER-POINTER-POP)	;Convert to Instruction calling seq
QIXOR0	((M-S) (A-CONSTANT (OA-LOW-CONTEXT (XOR)))) ;An extra instruction, but saves hair
	(DISPATCH-XCT-NEXT Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG1)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) PP 0)
       ((M-A) (A-CONSTANT ARITH-2ARG-BOOLE))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-T 1)
	(POPJ-AFTER-NEXT (M-1) XOR M-2 A-1)
       ((M-T) Q-POINTER M-1 (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

;Note that the A operand is on the left.
XBOOLE (MISC-INST-ENTRY *BOOLE)
	((M-T) C-PDL-BUFFER-POINTER-POP)	;Arg 3
	((M-A) C-PDL-BUFFER-POINTER-POP)	;Arg 2
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
		(ERROR-TABLE ARGTYP FIXNUM PP 0)
	((M-S) DPB C-PDL-BUFFER-POINTER-POP	;Arg 1 as OA-REG-LOW alu function
		(BYTE-FIELD 4 3) A-ZERO)
	((C-PDL-BUFFER-POINTER-PUSH) M-A)	;Put arg 2 back in standard place
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-A D-NUMARG1)
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) PP 1)
       ((M-A) (A-CONSTANT ARITH-2ARG-BOOLE))
	(DISPATCH Q-DATA-TYPE M-T D-FIXNUM-NUMARG2 (I-ARG NUMBER-CODE-FIXNUM))
		(ERROR-TABLE ARGTYP (FIXNUM BIGNUM) M-T 2)
	((OA-REG-LOW) M-S)
	(POPJ-AFTER-NEXT (M-1) SETZ M-2 A-1)
       ((M-T) Q-POINTER M-1 (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

;Boolean function of two bignums, M-S has OA-REG-LOW to do the function.
;First arg in M-Q,M-C,M-I.  Second arg in M-B/M-T,M-D,M-J.
;Eventual ACs:  small arg in M-R,M-J.  big arg in M-Q,M-I.  alu func in M-A
; result in M-T,M-C.  M-D has bit flags:
;	bit 0 - sign of smaller arg
;	bit 1 - sign of bigger arg
;This hair is required because bignums are sign-and-magnitude,
;but BOOLE wants to treat them as 2's complement.

BBOOLE	((M-TEM) BIGNUM-HEADER-SIGN M-C)	;Sign of 1st arg
	((M-A OA-REG-LOW) M-S)			;save alu func, compute sign of result
	((M-C) SETZ M-C A-D)			; in BIGNUM-HEADER-SIGN bit of M-C
	((M-D) BIGNUM-HEADER-SIGN M-D)		;bit 0 of M-D gets sign of 2nd arg
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-I A-J BBOOL0)	;Make M-Q,M-I the longer
       ((M-D) DPB M-TEM (BYTE-FIELD 1 1) A-D)	;bit 1 of M-D gets sign of 1st arg
	(DISPATCH (BYTE-FIELD 2 0) M-D D-BOOLE-REV)	;Interchange bits 0 and 1 of M-D
	 ((M-D) XOR M-D (A-CONSTANT 3))
	((M-T) M-Q)
	((M-TEM) M-J)
	((M-J) M-I)
	((M-Q) M-B)
	(JUMP-XCT-NEXT BBOOL1)
       ((M-I) M-TEM)

;If we didn't interchange the args, interchange bits 4 and 5
;of the ALU function so as to make the first argument be on the M side.
BBOOL0	(DISPATCH (BYTE-FIELD 2 4) M-A D-BOOLE-REV)
	 ((M-A) XOR M-A (A-CONSTANT 60))	;Swap bits if different
BBOOL1	((M-R) M-T)				;Small arg in M-R,M-J, big in M-Q,M-I
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 2))		;Allocate result 1 longer than bigger arg
						; due to the damned SETZ case
	((M-B) (A-CONSTANT 1))			;Index
	((A-BOOLE-CARRY-1) M-ZERO)
	((A-BOOLE-CARRY-2) M-ZERO)
BBOOL2	((VMA-START-READ) ADD M-R A-B)		;Loop over length of smaller arg
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 0) M-D BBOL2A)
       ((M-1) ADD READ-MEMORY-DATA A-BOOLE-CARRY-1)
	((M-1) SUB M-ZERO A-1)			;Smaller arg negative, get 2's comp form
	((A-BOOLE-CARRY-1) (BYTE-FIELD 1 31.) M-1)
BBOL2A	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 1) M-D BBOL2B)
       ((M-2) ADD READ-MEMORY-DATA A-BOOLE-CARRY-2)
	((M-2) SUB M-ZERO A-2)			;Larger arg negative, get 2's comp form
	((A-BOOLE-CARRY-2) (BYTE-FIELD 1 31.) M-2)
BBOL2B	((OA-REG-LOW) M-A)
	((WRITE-MEMORY-DATA) SETZ M-2 A-1)
	((WRITE-MEMORY-DATA) (BYTE-FIELD 31. 0) WRITE-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-T A-B)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-B A-J BBOOL2)
       ((M-B) ADD M-B (A-CONSTANT 1))
	(JUMP-GREATER-THAN-XCT-NEXT M-B A-I BBOOL5)
       ((M-1) SUB M-ZERO A-BOOLE-CARRY-1)	;Sign bits for smaller arg
BBOOL3	((VMA-START-READ) ADD M-Q A-B)		;Do bigger arg against sign of smaller
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 1) M-D BBOL3B)
       ((M-2) ADD READ-MEMORY-DATA A-BOOLE-CARRY-2)
	((M-2) SUB M-ZERO A-2)			;Larger arg negative, get 2's comp form
	((A-BOOLE-CARRY-2) (BYTE-FIELD 1 31.) M-2)
BBOL3B	((OA-REG-LOW) M-A)
	((WRITE-MEMORY-DATA) SETZ M-2 A-1)
	((WRITE-MEMORY-DATA) (BYTE-FIELD 31. 0) WRITE-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-T A-B)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-B A-I BBOOL3)
       ((M-B) ADD M-B (A-CONSTANT 1))
BBOOL5	((M-2) SUB M-ZERO A-BOOLE-CARRY-2)	;Sign bits for larger arg
	((OA-REG-LOW) M-A)			;High result word comes from sign bits
	((WRITE-MEMORY-DATA) SETZ M-2 A-1)
	((WRITE-MEMORY-DATA) (BYTE-FIELD 31. 0) WRITE-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-T A-B)
	(CHECK-PAGE-WRITE)
	((M-I) ADD M-I (A-CONSTANT 1))		;Actual length of result (for BIGNEG)
	(CALL-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BIGNEG)	;Magnitude of negative result
	(JUMP BIGNUM-DPB-CLEANUP)		;Dispose of any unnecessary high words

(LOCALITY D-MEM)
(START-DISPATCH 2 (PLUS P-BIT R-BIT)) ;Skip if bits the same
D-BOOLE-REV
	(INHIBIT-XCT-NEXT-BIT)	;Bits same, no need to swap
	(0)			;Bits different, swap by XOR'ing
	(0)			;different
	(INHIBIT-XCT-NEXT-BIT)	;same
(END-DISPATCH)
(LOCALITY I-MEM)

;Mixed-mode cases...
;Bignum arg in M-Q,M-C,M-I.  Fixnum unpacked in M-2.  ALU function in M-S.
;The first arg goes on the A side, and we want the fixnum on the A side.
BFXBOOLE	;Fixnum second arg, take as first by switching ALU function
	(DISPATCH (BYTE-FIELD 2 4) M-S D-BOOLE-REV)
	 ((M-S) XOR M-S (A-CONSTANT 60))
FXBBOOLE
	((M-A) M-S)				;Stash function in M-A
	((M-D) BIGNUM-HEADER-SIGN M-C)		;M-D bit 1 gets sign of bigger arg
	((M-D) DPB M-D (BYTE-FIELD 1 1))
	((OA-REG-HIGH) (BYTE-FIELD 1 31.) M-2)	;Get sign bits for smaller arg
	((M-1) M-ZERO)
	((OA-REG-LOW) M-A)			;Compute sign of result
	((M-C) SETZ M-C A-1)
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 2))		;Allocate result one longer than bignum arg
						; due to the damned SETZ case
	((A-BOOLE-CARRY-2) M-ZERO)
	((VMA-START-READ) ADD M-Q (A-CONSTANT 1))	;Combine low word with fixnum arg
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 1) M-D BBOLFX)
       ((M-TEM) ADD READ-MEMORY-DATA A-BOOLE-CARRY-2)
	((M-TEM) SUB M-ZERO A-TEM)		;Larger arg negative, get 2's comp form
	((A-BOOLE-CARRY-2) (BYTE-FIELD 1 31.) M-TEM)
BBOLFX	((OA-REG-LOW) M-A)
	((WRITE-MEMORY-DATA) SETZ M-TEM A-2)
	((WRITE-MEMORY-DATA) (BYTE-FIELD 31. 0) WRITE-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-T (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-I (A-CONSTANT 2) BBOOL3)	;do more of bignum arg
       ((M-B) (A-CONSTANT 2))
	(JUMP BBOOL5)				;bignum arg only 1 word long

;;; Arithmetic shift.  Unlike LSH, ASH works on bignums

XASH (MISC-INST-ENTRY XASH)		;**TEMP**
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)	;arg 2, shift count
	(CALL FXUNPK-P-1)			;M-2 gets arg 2
	((M-2) M-1)
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER D-NUMARG)	;arg 1, number to shift
	    (ERROR-TABLE ARGTYP NUMBER PP 0)
       ((M-A) (A-CONSTANT ARITH-1ARG-ASH))
	;Fixnum case
	((OA-REG-HIGH) (BYTE-FIELD 1 31.) M-1)	;M-3 gets sign extension of M-1
	((M-3) M-ZERO)
	(JUMP-GREATER-THAN M-2 A-ZERO XASH2)	;Jump if left shift
	((M-2) ADD M-2 (A-CONSTANT 40))		;Number of bits preserved by right shift
	(JUMP-GREATER-THAN M-2 A-ZERO XASH1)
	((M-2) (A-CONSTANT 1))			;Shifting too far, preserve only sign
XASH1	((M-4) SUB M-2 (A-CONSTANT 1))		;Byte size -1
	((OA-REG-LOW) DPB M-4 OAL-BYTL-1 A-2)	;Use byte hardware
	((M-1) (BYTE-FIELD 0 0) M-1 A-3)	;Do the right arithmetic shift
	(JUMP FIXPACK-T)

;Left ASH of a fixnum turns into DPB.
XASH2	((C-PDL-BUFFER-POINTER-PUSH)		;Put arg 1 back on pdl
		Q-POINTER M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-1) SELECTIVE-DEPOSIT M-3 (BYTE-FIELD 9 23.) A-ZERO)	;background to DPB into (signs)
	((M-K) (A-CONSTANT 23.))		;Byte size
	(JUMP-LESS-THAN-XCT-NEXT M-2 (A-CONSTANT 9) ASHDPB)	;Jump if fit in machine word
       ((M-E) M-2)				;Byte position
	((M-1) M-ZERO)				;Bignum, DPB into background of zero
	(JUMP-XCT-NEXT ASHDPB1)			; except with signs infinitely far to the left
       ((M-C) DPB M-3 BIGNUM-HEADER-SIGN A-ZERO)

;ASH of a bignum, in M-Q,M-C,M-I.  M-2 shift distance.
BIGASH	((M-1 MD) M-2)
	(CALL-XCT-NEXT DIV)			;Split shift into words and bits
       ((M-2) (A-CONSTANT 31.))			;Q-R gets number of words, M-1 gets bits
	(JUMP-LESS-THAN MD A-ZERO BIGASHR)	;Jump if right shift
	((M-R) Q-R)				;Number of words of shifting
	((M-J) A-ZERO)				;No words discarded
BIGASH2	((M-B) ADD Q-R A-I)			;Result length is number of zero words shifted
	(CALL-XCT-NEXT BNCONS)			; in at bottom, + arg length, +1 at top
       ((M-B) ADD M-B (A-CONSTANT 2))		; for bits shift, +1 for header
	((M-E) M-R)				;Number of zero words at bottom
	(CALL-XCT-NEXT BDIV-NORMALIZE-ENCODE-SHIFT)	;Encode bit shift from M-1
       ((M-1) M-A-1 (M-CONSTANT 32.) A-1)
	((M-ZR) ADD M-I A-J)			;Number of words to read from old bignum
	((M-B) SUB M-Q A-J)			;Address of old bignum (offset if right shift)
	((M-B) Q-POINTER M-B)			;Avoid illegal pointer lying around
	((M-D) M-T)				;Address of new bignum
	(CALL-XCT-NEXT BDIV-NORMALIZE)		;Shift subroutine
       ((M-2) A-ZERO)				;0 bits in at top
	(JUMP BIGNUM-DPB-CLEANUP)		;Fix bignum length and return

BIGASHR	((M-R) (A-CONSTANT -1))			;Bottom word of left-shift result discarded
	((M-J) Q-R)				;Negative number of words discarded at
						; bottom of input bignum
	(JUMP-EQUAL M-1 A-ZERO BIGASH1)		;Convert right bit shift into left shift
	((M-1) ADD M-1 (A-CONSTANT 31.))
BIGASH1	((Q-R) SUB M-J (A-CONSTANT 1))		;Cause M-B (to cons) to match M-ZR (to norm)
	((M-TEM) ADD M-J A-I)
	(JUMP-GREATER-THAN M-TEM A-ZERO BIGASH2)	;Jump if any significance
	((OA-REG-HIGH) BIGNUM-HEADER-SIGN M-C)	;Result is just sign bits
	((M-1) M-ZERO)
	(JUMP FIXPACK-T)

;ASH of a flonum is FSC, i.e. multiply by appropriate power of 2
FLONUM-ASH
	(POPJ-AFTER-NEXT (M-I) ADD M-I A-2)	;Add shift count to exponent
       (NO-OP)

;;; Data-type dispatches for arithmetic.

;;; Dispatch on the type of a one-argument numeric function.
;;; DTP-FIX unpacks and then drops through; eveything else jumps.
(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-NUMARG
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(P-BIT FXUNPK-P-1)			;FIX
	(ARITH-XNM)				;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(ARITH-SFL)				;SMALL-FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

;;; Dispatch on the type of the first numeric arg.
;;; DTP-FIX unpacks and then drops through; eveything else jumps.
(START-DISPATCH 5 0)
D-NUMARG1
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(P-BIT FXUNPK-P-1)			;FIX
	(ARITH-XNM-ANY)				;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(ARITH-SFL-ANY)				;SMALL-FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

;;; Data type dispatch on second numeric arg, when first one was a DTP-FIXNUM.
;;; DTP-FIXNUM unpacks and drops through; everything else jumps.  First arg
;;; is unpacked into M-1.  Second arg in M-T.
(START-DISPATCH 5 0)
D-FIXNUM-NUMARG2
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT FXUNPK-T-2)	;FIX
	(INHIBIT-XCT-NEXT-BIT ARITH-ANY-XNM)	;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(INHIBIT-XCT-NEXT-BIT ARITH-FIX-SFL)	;SMALL-FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

;;; Data type dispatch for second numeric arg when first was NOT DTP-FIXNUM
;;; DTP-SMALL-FLONUM unpacks and drops through; everything else jumps.
;;; During this dispatch, the I-ARG contains a number code.
;;; The first arg has been unpacked as follows:
;;;  If BIGNUM, M-Q has BIGNUM pointer, M-C HEADER, M-I LENGTH.
;;;  If FLONUM, M-Q has FLONUM pointer, M-C HEADER, M-I exponent, M-1 mantissa.
;;;  If SMALL-FLONUM, M-I has exponent, M-1 mantissa.
(START-DISPATCH 5 0)
D-NUMARG2
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;NULL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FREE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SYMBOL
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;SYMBOL HEADER
	(ARITH-ANY-FIX)				;FIX
	(ARITH-ANY-XNM)				;EXTENDED NUMBER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;GC-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;EXTERNAL-VALUE-CELL-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ONE-Q-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;HEADER-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;BODY-FORWARD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LOCATIVE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;LIST
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;U CODE ENTRY
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ARRAY-POINTER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;STACK-GROUP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;CLOSURE
	(P-BIT SFLUNPK-T-2)			;SMALL-FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;SELECT-METHOD
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;INSTANCE-HEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;ENTITY
 (REPEAT NQZUSD (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; One-argument function.
ARITH-SFL
	(CALL SFLUNPK-P-1)
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FLONUM-1ARG)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SFLPACK-T)))

ARITH-XNM
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-Q) VMA)		;get transported number address 
	((M-TEM) Q-DATA-TYPE MD)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER)) ILLOP)
	(DISPATCH-XCT-NEXT HEADER-TYPE-FIELD MD D-XNM-ARG)
       ((M-C) HEADER-REST-FIELD MD)

(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-XNM-ARG
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ERROR
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY LEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;UNUSED
	(ARITH-FLO)				;FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;COMPLEX
	(ARITH-BIG)				;BIGNUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;RATIONAL BIGNUMS
 (REPEAT NUM-UNUSED-HEADER-TYPES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

ARITH-FLO
	((VMA-START-READ) ADD M-Q (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-I) HEADER-FLONUM-EXPONENT M-C)
	((M-1) DPB M-C FLONUM-HEADER-HIGH-MANTISSA A-ZERO)
	((M-1) SELECTIVE-DEPOSIT MD FLONUM-HEADER-LOW-MANTISSA A-1)
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FLONUM-1ARG)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-T)))

;;; This dispatch SOMETIMES executes next: viz., when the result will be a number.
;;; Dispatchers can push a PACK routine in the xct-next cycle.
(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-FLONUM-1ARG
	(FLONUM-ABS)
	(FLONUM-MINUS)
	(INHIBIT-XCT-NEXT-BIT FLONUM-ZEROP)
	(INHIBIT-XCT-NEXT-BIT FLONUM-PLUSP)
	(INHIBIT-XCT-NEXT-BIT FLONUM-MINUSP)
	(FLONUM-ADD1)
	(FLONUM-SUB1)
	(INHIBIT-XCT-NEXT-BIT FLONUM-FIX)
	(INHIBIT-XCT-NEXT-BIT FLOPACK-T)
	(INHIBIT-XCT-NEXT-BIT SFLPACK-T)
	(P-BIT INHIBIT-XCT-NEXT-BIT XHAULFLO)	;HAULONG DOESN'T WORK FOR FLONUMS
	(P-BIT INHIBIT-XCT-NEXT-BIT XHAULFLO)	;LDB DOESNT EITHER.
	(P-BIT INHIBIT-XCT-NEXT-BIT XHAULFLO)	;NOR DPB.
	(FLONUM-ASH)				;ASH OF A FLONUM = FSC
 (REPEAT NUM-UNUSED-ARITH-1ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)


FLONUM-ABS
	(POPJ-IF-BIT-CLEAR FLONUM-SIGN-BIT M-1)
	(JUMP FNEG1)

;FLONUM-MINUS is the same as FNEG1, see below.

;FLONUM-ZEROP, FLONUM-PLUSP and FLONUM-MINUSP are up with the fixnum cases,
;see above.

FLONUM-ADD1
	((M-2) DPB M-MINUS-ONE MANTISSA-HIGH-BIT A-ZERO);10_33
	(JUMP-XCT-NEXT FADD)
       ((M-J) M+A+1 M-ZERO (A-CONSTANT 2000))		;2001

FLONUM-SUB1
	((M-2) DPB M-MINUS-ONE FLONUM-SIGN-BIT A-ZERO)	;20_33
	(JUMP-XCT-NEXT FADD)
       ((M-J) (A-CONSTANT 2000))			;2000

FLONUM-FIX
	((OA-REG-HIGH) FLONUM-SIGN-BIT M-1)	;M-T gets 0 if arg positive,
       ((M-T) Q-POINTER M-ZERO			;  -1 if arg is negative.
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ-LESS-OR-EQUAL M-I (A-CONSTANT 2000)) ;return 0 or -1 if fractional
	(JUMP-GREATER-OR-EQUAL M-I (A-CONSTANT 2030) FLONUM-BIGFIX) ;big enough to be bignum
	((M-A) M-A-1 M-I (A-CONSTANT 2000))	;Byte length - 1 (maximum byte length 23.)
	((M-B) ADD M-A (A-CONSTANT 2))		;Leftward rotation of M-1.
	(POPJ-AFTER-NEXT (OA-REG-LOW) DPB M-A OAL-BYTL-1 A-B)
       ((M-T) (BYTE-FIELD 0 0) M-1 A-T)		;A boxed signed fixnum!

FLONUM-BIGFIX
	((M-C) DPB M-T BIGNUM-HEADER-SIGN A-ZERO)	;Save sign
	(CALL FLONUM-ABS)
	((M-4) M-1)				;Save magnitude of mantissa
	((M-1) SUB M-I (A-CONSTANT (DIFFERENCE 2000 30.)))	;Compute bignum length
	(CALL-XCT-NEXT DIV)			;Q-R gets number of words,
       ((M-2) (A-CONSTANT 31.))			;M-1 gets bits minus one in last word
	((M-2) M-4)				;Restore mantissa magnitude
	((M-I) Q-R)				;Bignum length
	(CALL-XCT-NEXT BNCONS)			;Allocate a bignum result
       ((M-B) ADD Q-R (A-CONSTANT 1))
	((M-3) SUB M-I (A-CONSTANT 2))		;Zero out all but high 2 words of bignum
	(JUMP-LESS-OR-EQUAL M-3 A-ZERO FLONUM-BIGFIX1)
	((WRITE-MEMORY-DATA) M-ZERO)
FLONUM-BIGFIX0
	((VMA-START-WRITE) ADD M-T A-3)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-3 (A-CONSTANT 1) FLONUM-BIGFIX0)
       ((M-3) SUB M-3 (A-CONSTANT 1))
FLONUM-BIGFIX1
	((M-3) ADD M-1 (A-CONSTANT 2))		;Get high-order word of result
	((OA-REG-LOW) DPB M-1 OAL-BYTL-1 A-3)	;[Right-justify high (M-1)+1 bits of 31.]
	((WRITE-MEMORY-DATA) (BYTE-FIELD 0 0) M-2)
	((VMA-START-WRITE) ADD M-T A-I)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN M-I (A-CONSTANT 2) BIGNUM-DPB-CLEANUP)	;No low-order word
	((M-3) M-A-1 (M-CONSTANT 32.) A-3)	;Get low-order word (may be garbage)
	((M-1) ADD M-1 (A-CONSTANT 1))		;[Left-justify low 30.-(M-1) bits in 31.]
	((OA-REG-LOW) DPB M-3 OAL-BYTL-1 A-1)
	((WRITE-MEMORY-DATA) DPB M-2 (BYTE-FIELD 0 0) A-ZERO)
	((VMA-START-WRITE) SUB VMA (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP BIGNUM-DPB-CLEANUP)		;Might really be a fixnum after all! (SETZ)

;;; Two-argument functions.

;;; The first arg, which is on the PDL, is a SMALL-FLONUM.  ARITH-2ARG is in M-A.
ARITH-SFL-ANY
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-T D-NUMARG2 (I-ARG NUMBER-CODE-SMALL-FLONUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1)	;Not continuable since first arg is unpacked
       (CALL SFLUNPK-P-1)
	;; If it comes back here, both flonums are unpacked.
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FORWARD-FLONUM-OPS)
		(ERROR-TABLE ARGTYP INTEGER M-T 1)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SFLPACK-P)))

;;; Second arg was a fixnum, but first wasn't.
;;; I-ARG contains type of first argument, M-A contains operation.
ARITH-ANY-FIX
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 0) READ-I-ARG D-ARITH-ANY-FIX)
       (CALL FXUNPK-T-2)

(LOCALITY D-MEM)
(START-DISPATCH 3 0)
D-ARITH-ANY-FIX
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FIX, SHOULN'T GET HERE.
	(ARITH-SFL-FIX)				;SMALL FLONUM
	(ARITH-FLO-FIX)				;FLONUM
	(ARITH-BIG-FIX)				;BIGNUM
 (REPEAT NUM-UNUSED-NUMBER-CODES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; First arg is a fixnum unpacked.  Second arg is a small flonum, packed.
ARITH-FIX-SFL
	(CALL-XCT-NEXT SFLUNPK-T-2)
       ((M-I) (A-CONSTANT 2036))
	(CALL-XCT-NEXT FNORM)
       ((Q-R) M-ZERO)
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FORWARD-FLONUM-OPS)
		(ERROR-TABLE ARGTYP INTEGER M-T 1)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SFLPACK-P)))

;;; We have a small flonum in M-1,M-I and a fixnum in M-2.
;;; Reverse the order, normalize the fixnum to a flonum, and call reverse operator.
ARITH-SFL-FIX
	((M-J) M-2)
	((M-2) M-1)
	((M-1) M-J)
	((M-J) M-I)
	((Q-R) M-ZERO)
	(CALL-XCT-NEXT FNORM)
       ((M-I) (A-CONSTANT 2036))
	(DISPATCH (BYTE-FIELD 4 0) M-A D-REVERSE-FLONUM-OPS)
		(ERROR-TABLE FLONUM-NO-GOOD)	;ARGTYP not usable, arg not saved
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SFLPACK-P)))

;;; We have a flonum in M-1/M-I and a fixnum in M-2.  This is just like the above.
ARITH-FLO-FIX
	((M-J) M-2)
	((M-2) M-1)
	((M-1) M-J)
	((M-J) M-I)
	((Q-R) M-ZERO)
	(CALL-XCT-NEXT FNORM)
       ((M-I) (A-CONSTANT 2036))
	(DISPATCH (BYTE-FIELD 4 0) M-A D-REVERSE-FLONUM-OPS)
		(ERROR-TABLE FLONUM-NO-GOOD)	;ARGTYP not usable, arg not saved
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-P)))

;;; Routines that look at the contents of M-A and act on it.

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-FORWARD-FLONUM-OPS
	(FADD)			;ADD
	(FSUB)			;SUB
	(FMPY)			;MUL
	(FDIV)			;DIV
	(INHIBIT-XCT-NEXT-BIT FEQL)	;=
	(INHIBIT-XCT-NEXT-BIT FGRP)	;>
	(INHIBIT-XCT-NEXT-BIT FLSP)	;<
	(FMIN)			;MIN
	(FMAX)			;MAX
	(INHIBIT-XCT-NEXT-BIT TRAP)	;BOOLE
 (REPEAT NUM-UNUSED-ARITH-2ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)

(START-DISPATCH 4 0)
D-REVERSE-FLONUM-OPS
	(FADD)			;REVERSE ADD
	(FSUB-REVERSE)		;REVERSE SUB
	(FMPY)			;REVERSE MPY
	(FDIV-REVERSE)		;REVERSE DIVIDE
	(INHIBIT-XCT-NEXT-BIT FEQL)	;REVERSE =
	(INHIBIT-XCT-NEXT-BIT FLSP)	;REVERSE >
	(INHIBIT-XCT-NEXT-BIT FGRP)	;REVERSE <
	(FMIN)			;REVERSE MIN
	(FMAX)			;REVERSE MAX
	(INHIBIT-XCT-NEXT-BIT TRAP)	;BOOLE
(REPEAT NUM-UNUSED-ARITH-2ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

FSUB-REVERSE
	(JUMP-XCT-NEXT FADD)
       (CALL FNEG1)

FDIV-REVERSE
	(JUMP-XCT-NEXT FDIV)
       (CALL SWAP-FLONUMS)

SWAP-FLONUMS
	((M-TEM) M-I)
	((M-I) M-J)
	((M-J) M-TEM)
	((M-TEM) M-1)
	(POPJ-AFTER-NEXT (M-1) M-2)
       ((M-2) M-TEM)

;;; Extended numbers.

;;; The first arg is an XNUM.  Arith op in M-A.
ARITH-XNM-ANY
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-Q) VMA)		;get transported number address 
	((M-TEM) Q-DATA-TYPE MD)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER)) ILLOP)
	(DISPATCH-XCT-NEXT HEADER-TYPE-FIELD MD D-XNM-ARG-1)
       ((M-C) HEADER-REST-FIELD MD)

(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-XNM-ARG-1
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ERROR
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY LEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;UNUSED
	(ARITH-FLO-ANY)				;FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;COMPLEX
	(ARITH-BIG-ANY)				;BIGNUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;RATIONAL BIGNUMS
 (REPEAT NUM-UNUSED-HEADER-TYPES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; First arg is a real flonum.  Pointer in M-Q, header-rest in M-C, op in M-A.
ARITH-FLO-ANY
	((VMA-START-READ) M-Q ADD (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-I) HEADER-FLONUM-EXPONENT M-C)
	((M-1) DPB M-C FLONUM-HEADER-HIGH-MANTISSA A-ZERO)
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-T D-NUMARG2 (I-ARG NUMBER-CODE-FLONUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1)	;Not continuable since first arg is unpacked
       ((M-1) SELECTIVE-DEPOSIT MD FLONUM-HEADER-LOW-MANTISSA A-1)
	;; If falls through, second arg is a small flonum, already unpacked.
ARITH-FLO-SFL ;This label is not used.  It is here for completeness.
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FORWARD-FLONUM-OPS)
		(ERROR-TABLE ARGTYP INTEGER M-Q 0)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-P)))

;;; The second arg is an extended number.  First arg is unpacked, type in I-ARG.
;;; Arith op in M-A.
ARITH-ANY-XNM
	((VMA-START-READ) M-T)
	((M-R) READ-I-ARG)			;Get number code of first arg.
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-T) VMA)		;get transported number address 
	((M-TEM) Q-DATA-TYPE MD)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER)) ILLOP)
	(DISPATCH-XCT-NEXT HEADER-TYPE-FIELD MD D-XNM-ARG-2)
       ((M-D) HEADER-REST-FIELD MD)

(LOCALITY D-MEM)
(START-DISPATCH 5 0)
D-XNM-ARG-2
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ERROR
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;FEF
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;ARRAY LEADER
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;UNUSED
	(ARITH-ANY-FLO)				;FLONUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;COMPLEX
	(ARITH-ANY-BIG)				;BIGNUM
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;RATIONAL BIGNUMS
 (REPEAT NUM-UNUSED-HEADER-TYPES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; Number code of first arg in M-R.
;;; If is is a fixnum, small flonum, or flonum, it is unpacked in M-1/M-I.
;;; Our header rest field in M-D, our pointer in M-T.
ARITH-ANY-FLO
	((VMA-START-READ) M-T ADD (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-J) HEADER-FLONUM-EXPONENT M-D)
	((M-2) DPB M-D FLONUM-HEADER-HIGH-MANTISSA A-ZERO)
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 0) M-R D-ARITH-ANY-FLO)
       ((M-2) SELECTIVE-DEPOSIT MD FLONUM-HEADER-LOW-MANTISSA A-2)

(LOCALITY D-MEM)
(START-DISPATCH 3 0)
D-ARITH-ANY-FLO
	(ARITH-FIX-FLO)
	(ARITH-SFL-FLO)
	(ARITH-FLO-FLO)
	(ARITH-BIG-FLO)
 (REPEAT NUM-UNUSED-NUMBER-CODES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

ARITH-FIX-FLO
	((M-I) (A-CONSTANT 2036))
	(CALL-XCT-NEXT FNORM)
       ((Q-R) M-ZERO)
	;drop in
ARITH-SFL-FLO 
ARITH-FLO-FLO
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FORWARD-FLONUM-OPS)
		(ERROR-TABLE FLONUM-NO-GOOD)	;ARGTYP not usable, I think I lost the arg
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-P)))

;Flonum arithmetic routines.

;These routines bash M-J, M-2, M-TEM, Q-R, A-TEMn, M-K.
;M-ZERO is an even address in M-memory.  It contains zeros, and the following
;location contains a -1.  This is used to get A-TEM1 below by hacking
;the low bit of the OA-REG-HIGH, which is the low bit of the M-source field,
;to get either a word of zeros or a word of ones depending on the sign bit
;of M-2.

;Floating Subtract.  This changes the sign of M-2 and turns into Add.
FSUB	(CALL FNEG2)
	;drop through

;Floating Add.
FADD	(JUMP-EQUAL-XCT-NEXT M-I A-J FADD2)	;Jump if exponents equal, no shifting
       ((Q-R) M-ZERO)				;Initialize discarded bits.
	(CALL-LESS-THAN-XCT-NEXT M-I A-J FADD1)	;If M-1 to shift right, exchange args
       ((M-TEM) M-A-1 M-I A-J)			;Amt to shift M-2 right minus one
	(POPJ-GREATER-OR-EQUAL M-TEM (A-CONSTANT 37)) ;Return if M-2 pales into insignificance
	((OA-REG-HIGH) FLONUM-SIGN-BIT M-2)	;Sign-extend M-2
       ((A-TEM1) M-ZERO)			;Gets either all zeros or all ones.
	((M-J) M-A-1 (M-CONSTANT 40) A-TEM)	;40 minus exponent difference
	((OA-REG-LOW) DPB M-TEM OAL-BYTL-1 A-J)	; becomes m-rotate
       ((A-TEM2) DPB M-2 (BYTE-FIELD 0 0) A-ZERO) ;Get bits shifted off right end of M-2
	((Q-R) A-TEM2)				;Put them in Q-R where they belong
	((M-TEM) SUB M-J (A-CONSTANT 1))	;Byte length minus one
	((OA-REG-LOW) DPB M-TEM OAL-BYTL-1 A-J)
       ((M-2) (BYTE-FIELD 0 0) M-2 A-TEM1)	;Arithmetically shift M-2 right
FADD2	((M-1) ADD M-1 A-2 OUTPUT-SELECTOR-RIGHTSHIFT-1	;Do the add, collect
		SHIFT-Q-RIGHT)	; the overflow, discarded bits to Q
;Normalizing loop
FNORM	(DISPATCH SIGN-BIT-AND-MANTISSA-HIGH-THREE M-1 D-FNORM) ;Maybe xct-next
       ((M-I) ADD M-I (A-CONSTANT 1))		;Adjust exponent for right shift

(LOCALITY D-MEM)
(START-DISPATCH 4 0)	;s.xyz high 4 bits of sum to be normalized
D-FNORM	(INHIBIT-XCT-NEXT-BIT FNORM3)	;0.000 shift left at least 3
	(FNORM2)			;0.001 shift left 2
	(FNORM1)			;0.010 shift left 1
	(FNORM1)			;0.011 shift left 1
	(FRND)				;0.100 OK
	(FRND)				;0.101 OK
	(FRND)				;0.110 OK
	(FRND)				;0.111 OK
	(FRND)				;1.000 OK
	(FRND)				;1.001 OK
	(FRND)				;1.010 OK
	(FRND)				;1.011 OK
	(FNORM1)			;1.100 shift left 1
	(FNORM1)			;1.101 shift left 1
	(FNORM2)			;1.110 shift left 2
	(INHIBIT-XCT-NEXT-BIT FNORM3)	;1.111 shift left at least 3
(END-DISPATCH)
(LOCALITY I-MEM)

FNORM3	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((Q-R) ANDCA Q-R (A-CONSTANT 7))	;Zero the bits brought into Q
	(JUMP-NOT-EQUAL-XCT-NEXT M-1 A-ZERO FNORM) ;Break the loop if trying
       ((M-I) SUB M-I (A-CONSTANT 3))		   ; to normalize zero
;Return a floating-point zero (in internal form)
FLZERO	(POPJ-AFTER-NEXT (M-I) A-ZERO)
       ((M-1) A-ZERO)

FNORM2	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((Q-R) ANDCA Q-R (A-CONSTANT 3))	;Zero the bits brought into Q
	(JUMP-XCT-NEXT FRND)
       ((M-I) SUB M-I (A-CONSTANT 2))

FNORM1	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)
	((Q-R) ANDCA Q-R (A-CONSTANT 1))	;Zero the bit brought into Q
	((M-I) SUB M-I (A-CONSTANT 1))
	;drops through
;Floating-point rounding routine.
;Get here with normalized mantissa in M-1, corresponding exponent in M-I,
;residual bits in Q-R.  Rounding cannot produce zero unless given zero,
;since the input is normalized.  Do not come here with zero in M-1
;unless M-I is zero and Q-R is non-negative, or an unnormalized
;result will be returned.
;After rounding, we renormalize with a 3-bit normalize since the rounding
;can make a positive number slightly bigger and a negative number slightly smaller,
;requiring a shift of 0, 1 right, or 1 left.
FRND	(POPJ-GREATER-OR-EQUAL Q-R A-ZERO)	;Return if discarded bits < 1/2 lsb, no rounding required.
	(JUMP-NOT-EQUAL Q-R (A-CONSTANT 1_31.) FRND2)	;If discarded bits = 1/2 lsb exactly,
	(POPJ-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-1) ; then round to even
FRND2	((M-1) ADD M-1 (A-CONSTANT 1)		;Add 1 lsb to mantissa, and
		OUTPUT-SELECTOR-RIGHTSHIFT-1 SHIFT-Q-RIGHT) ; capture overflow
FRND1	(DISPATCH SIGN-BIT-AND-MANTISSA-HIGH-TWO M-1 D-FRND) ;Renormalize & popj
       ((M-I) ADD M-I (A-CONSTANT 1))		;Right shift was good, fix exponent, popj

;This code is heavily bummed.  Beware.
;Note that Q normally has full low-order word.  From SFLPACK has garbage but won't be used.
FRND3	((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1 SHIFT-Q-LEFT)	;Restores the LSB from the Q.
FRND4	(POPJ-AFTER-NEXT (M-I) SUB M-I (A-CONSTANT 1))
       ((M-1) M-1 OUTPUT-SELECTOR-LEFTSHIFT-1)	;Restores the LSB from the Q.

(LOCALITY D-MEM)
(START-DISPATCH 3 0)  ;s.xx renormalize after round
D-FRND	(INHIBIT-XCT-NEXT-BIT FRND3)	;0.00 shift left two
	(FRND4)				;0.01 shift left one
	(R-BIT)				;0.10 OK
	(R-BIT)				;0.11 OK
	(R-BIT)				;1.00 OK
	(R-BIT)				;1.01 OK
	(FRND4)				;1.10 shift left one
	(INHIBIT-XCT-NEXT-BIT FRND3)	;1.11 shift left two
(END-DISPATCH)
(LOCALITY I-MEM)

;Exchange the arguments to FADD when the second has bigger exponent
FADD1	((M-I) M-J)		;Result exponent is exp of 2nd arg
	((M-TEM) M-A-1 (M-CONSTANT -1) A-TEM)	;Repair exponent difference
	((M-J) M-2)		;Exchange mantissas
	(POPJ-AFTER-NEXT (M-2) M-1)
       ((M-1) M-J)

;Negate operand 1.  
;Normally just change the sign of the mantissa, but note that
;to retain normalization 1/2 becomes -1 and -1 becomes 1/2, with adjustment of the exponent
FLONUM-MINUS 
FNEG1	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-1 A-ZERO FNEG1A)	;Jump if input positive
       ((M-1) SUB M-ZERO A-1)				;Change sign of mantissa
	(POPJ-IF-BIT-CLEAR FLONUM-SIGN-BIT M-1)		;Return if negative became positive
	(POPJ-AFTER-NEXT				;Otherwise generate 1/2 and increase
	 (M-1) DPB (M-CONSTANT -1) MANTISSA-HIGH-BIT A-ZERO) ; exponent since it must have
       ((M-I) ADD M-I (A-CONSTANT 1))			     ; been -1 which is "SETZ"
	
FNEG1A	(POPJ-NOT-EQUAL M-1 (A-CONSTANT (BYTE-MASK SIGN-BIT-AND-MANTISSA-HIGH-BIT)))
	(POPJ-AFTER-NEXT			;If result is -1/2,
	 (M-1) DPB (M-CONSTANT -1) FLONUM-SIGN-BIT A-ZERO)	;Turn it into -1
       ((M-I) SUB M-I (A-CONSTANT 1))		;and decrease exponent

;Negate operand 2.  
;Normally just change the sign of the mantissa, but note that
;to retain normalization 1/2 becomes -1 and -1 becomes 1/2, with adjustment of the exponent
FNEG2	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-2 A-ZERO FNEG2A)	;Jump if input positive
       ((M-2) SUB M-ZERO A-2)				;Change sign of mantissa
	(POPJ-IF-BIT-CLEAR FLONUM-SIGN-BIT M-2)		;Return if negative became positive
	(POPJ-AFTER-NEXT				;Otherwise generate 1/2 and increase
	 (M-2) DPB (M-CONSTANT -1) MANTISSA-HIGH-BIT A-ZERO) ; exponent since it must have
       ((M-J) ADD M-J (A-CONSTANT 1))			     ; been -1 which is "SETZ"
	
FNEG2A	(POPJ-NOT-EQUAL M-2 (A-CONSTANT (BYTE-MASK SIGN-BIT-AND-MANTISSA-HIGH-BIT)))
	(POPJ-AFTER-NEXT			;If result is -1/2,
	 (M-2) DPB (M-CONSTANT -1) FLONUM-SIGN-BIT A-ZERO)	;Turn it into -1
       ((M-J) SUB M-J (A-CONSTANT 1))		;and decrease exponent

;Floating Division.
;First, make both arguments positive, and remember if the result is to
;be negative.  Also handle arguments of zero at this stage.  Then,
;arrange for the quotient to always be normalized by dividing the
;dividend by 2 if it is greater than the divisor.  This makes the
;result mantissa be between 1/2 and 1.  Note that if the dividend and
;divisor are equal, dividing the dividend by 2 could end up producing
;an unnormalized quotient less than 1/2 because of truncation error.
;We fix this by checking specially for the case of dividend and divisor
;equal.  To get a properly-scaled quotient, we shift the dividend left
;31. bits, plus 1 more bit to get it to a word boundary.  The extra bit
;is compensated for by doing one less divide step.  After dividing, we
;do stable rounding by comparing the remainder against half the
;divisor.  Recall that divide overflow occurs if the high word of the
;dividend is greater than or equal to the divisor.
FDIV	(CALL-EQUAL M-2 A-ZERO TRAP)
		(ERROR-TABLE DIVIDE-BY-ZERO)
	(POPJ-EQUAL M-1 A-ZERO)			;(// 0.0 non-0) = 0.0
	(JUMP-LESS-THAN M-2 A-ZERO FDIV3)	;Jump if divisor negative
	(JUMP-LESS-THAN M-1 A-ZERO FDIV4)	;Jump if dividend negative
FDIV1	((M-I) M-I ADD (A-CONSTANT FLONUM-EXPONENT-EXCESS))
	(JUMP-LESS-THAN-XCT-NEXT M-1 A-2 FDIV2)	;If dividend >= divisor,
       ((M-I) SUB M-I A-J)
	(JUMP-EQUAL M-1 A-2 FDIV7)
	((M-1) (BYTE-FIELD 31. 1) M-1)		;shift dividend right 1,
	((M-I) ADD M-I (A-CONSTANT 1))		;and increase exponent of result
FDIV2	((Q-R) M-ZERO)				;Low bits of dividend
	((M-1) DIVIDE-FIRST-STEP M-1 A-2)	;Do the division, doesn't call DIV due to
(REPEAT 30. ((M-1) DIVIDE-STEP M-1 A-2))	; register conflicts and orneriness
	((M-1) DIVIDE-LAST-STEP M-1 A-2)
	((M-TEM) DIVIDE-REMAINDER-CORRECTION-STEP M-1 A-2)
	;At this point, the normalized positive quotient is in Q-R, remainder is in M-TEM
	;We'd like to shift the remainder left and do an unsigned compare, but that
	;operation isn't available so we shift the divisor right and lose a bit.
	((A-TEM1) (BYTE-FIELD 31. 1) M-2)
	(POPJ-LESS-THAN-XCT-NEXT M-TEM A-TEM1)	;Round down if remainder < 1/2 divisor
       ((M-1) Q-R)
	(JUMP-GREATER-THAN M-TEM A-TEM1 FDIV6)	;Round up if remainder > 1/2 divisor
	(POPJ-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-1);Round to even lsb if remainder = 1/2 divisor
FDIV6	(JUMP-XCT-NEXT FRND1)			;Duplicate instruction at FRND2 for speed
       ((M-1) ADD M-1 (A-CONSTANT 1)		;Add 1 lsb to mantissa, and
		OUTPUT-SELECTOR-RIGHTSHIFT-1 SHIFT-Q-RIGHT) ; capture overflow

;Divisor is negative.  Change its sign and check sign of dividend
FDIV3	(JUMP-GREATER-THAN-XCT-NEXT M-1 A-ZERO FDIV5)	;Jump on positive dividend
       (CALL FNEG2)
	(JUMP-XCT-NEXT FDIV1)			;Both negative, result is positive
       (CALL FNEG1)

;Divisor is positive but dividend is negative.  Result is negative.
FDIV4	(CALL FNEG1)				;Change sign of dividend
FDIV5	(JUMP-XCT-NEXT FNEG1)			;Result is negative, get positive
       (CALL FDIV1)				; quotient and return it negated.

;Dividend and divisor mantissas equal.  Quotient mantissa is 1/2.
FDIV7	(POPJ-AFTER-NEXT (M-1) DPB (M-CONSTANT -1) MANTISSA-HIGH-BIT A-ZERO)
       ((M-I) ADD M-I (A-CONSTANT 1))

;Floating Multiplication.
FMPY	(CALL-XCT-NEXT MPY)	;Product of mantissas to M-2(high), Q-R(low)
       ((Q-R) M-2)
	(JUMP-EQUAL M-2 A-ZERO FLZERO) ;If high product of normalized operands is zero, the
				; whole product is zero.  Return proper zero.
	((M-1) M-2)		;Get result of MPY into M-1
	((M-I) M-I SUB (A-CONSTANT FLONUM-EXPONENT-EXCESS))
	(DISPATCH-XCT-NEXT SIGN-BIT-AND-MANTISSA-HIGH-TWO
			M-1 D-FMPY) ;Normalize.  May need 0, 1, or 2 left shifts
       ((M-I) M+A+1 M-I A-J)	;Exponent of product if no shifts

(LOCALITY D-MEM)
(START-DISPATCH 3 0)	;s.xy high bits of product
D-FMPY	(FNORM2)	;0.00 shift left 2
	(FNORM1)	;0.01 shift left 1
	(FRND)		;0.10 OK
	(FRND)		;0.11 OK
	(FRND)		;1.00 OK
	(FRND)		;1.01 OK
	(FNORM1)	;1.10 shift left 1
	(FNORM2)	;1.11 shift left 2
(END-DISPATCH)
(LOCALITY I-MEM)

;= for flonums.
FEQL	(POPJ-NOT-EQUAL-XCT-NEXT M-I A-J)
       ((M-T) A-V-NIL)
	(POPJ-AFTER-NEXT POPJ-NOT-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

FGRP	(JUMP-IF-BIT-SET FLONUM-SIGN-BIT M-1 FGRP-1)
	(JUMP-IF-BIT-SET FLONUM-SIGN-BIT M-2 XTRUE)
	;; Both operands to GREATERP positive
	(JUMP-GREATER-THAN M-I A-J XTRUE)
	(POPJ-LESS-THAN-XCT-NEXT M-I A-J)
       ((M-T) A-V-NIL)	
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

FGRP-1	(JUMP-IF-BIT-CLEAR FLONUM-SIGN-BIT M-2 XFALSE)
	;; Both operands to GREATERP negative
	(JUMP-LESS-THAN M-I A-J XTRUE)
	(POPJ-GREATER-THAN-XCT-NEXT M-I A-J)
       ((M-T) A-V-NIL)	
	(POPJ-AFTER-NEXT POPJ-LESS-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

FLSP	(JUMP-IF-BIT-SET FLONUM-SIGN-BIT M-1 FLSP-1)
	(JUMP-IF-BIT-SET FLONUM-SIGN-BIT M-2 XFALSE)
	;; Both operands to LESSP positive
	(JUMP-LESS-THAN M-I A-J XTRUE)
	(POPJ-GREATER-THAN-XCT-NEXT M-I A-J)
       ((M-T) A-V-NIL)	
	(POPJ-AFTER-NEXT POPJ-GREATER-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

FLSP-1	(JUMP-IF-BIT-CLEAR FLONUM-SIGN-BIT M-2 XTRUE)
	;; Both operands to LESSP negative
	(JUMP-GREATER-THAN M-I A-J XTRUE)
	(POPJ-LESS-THAN-XCT-NEXT M-I A-J)
       ((M-T) A-V-NIL)	
	(POPJ-AFTER-NEXT POPJ-GREATER-OR-EQUAL M-1 A-2)
       ((M-T) A-V-TRUE)

FMAX	(CALL FLSP)
	(JUMP-EQUAL M-T A-V-NIL FIX-FMAX-FMIN-RETURN-ADDRESS)
	((M-1) M-2)
	((M-I) M-J)
FIX-FMAX-FMIN-RETURN-ADDRESS
	((M-TEM) MICRO-STACK-DATA-POP)
	(JUMP-EQUAL M-TEM (A-CONSTANT (I-MEM-LOC SFLPACK-P)) SFLPACK-T)
	(JUMP FLOPACK-T)

FMIN	(CALL FGRP)
	(JUMP-EQUAL M-T A-V-NIL FIX-FMAX-FMIN-RETURN-ADDRESS)
	((M-1) M-2)
	(JUMP-XCT-NEXT FIX-FMAX-FMIN-RETURN-ADDRESS)
       ((M-I) M-J)

XFLOAT-DOUBLE (MISC-INST-ENTRY %FLOAT-DOUBLE)
	(CALL FXGTPP)
	((M-1) DPB M-1 (BYTE-FIELD 24. 7) A-ZERO)
	((M-1) (BYTE-FIELD 7. 17.) M-2 A-1)
	(JUMP-EQUAL M-1 A-ZERO FLOAT-DOUBLE-2)
	((M-TEM) DPB M-2 (BYTE-FIELD 17. 15.) A-ZERO)
	((Q-R) M-TEM)
	((M-I) (A-CONSTANT 2057))
FLOAT-DOUBLE-1
	(JUMP-XCT-NEXT FLOPACK-T)
       (CALL FNORM)

FLOAT-DOUBLE-2
	((M-1) DPB M-2 (BYTE-FIELD 24. 7.) A-ZERO)
	((Q-R) A-ZERO)
	(JUMP-XCT-NEXT FLOAT-DOUBLE-1)
       ((M-I) (A-CONSTANT 2027)) 

;;;  Bignum arithmetic.

(DEF-DATA-FIELD BIGNUM-HEADER-SIGN 1 18.)
(DEF-DATA-FIELD BIGNUM-HEADER-LENGTH 18. 0)

ARITH-BIG-ANY
	(DISPATCH-XCT-NEXT Q-DATA-TYPE M-T D-NUMARG2 (I-ARG NUMBER-CODE-BIGNUM))
	    (ERROR-TABLE ARGTYP NUMBER M-T 1)
       ((M-I) BIGNUM-HEADER-LENGTH M-C)
ARITH-BIG-SFL 
ARITH-BIG-FLO
	(CALL FLOAT-A-BIGNUM)
	(DISPATCH (BYTE-FIELD 4 0) M-A D-FORWARD-FLONUM-OPS)
		(ERROR-TABLE ARGTYP INTEGER M-Q 0)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-P)))

ARITH-ANY-BIG
	(DISPATCH-XCT-NEXT (BYTE-FIELD 3 0) M-R D-ARITH-ANY-BIG)
       ((M-J) BIGNUM-HEADER-LENGTH M-D)

(LOCALITY D-MEM)
(START-DISPATCH 3 0)
D-ARITH-ANY-BIG
	(ARITH-FIX-BIG)
	(ARITH-SFL-BIG)
	(ARITH-FLO-BIG)
	(ARITH-BIG-BIG)
 (REPEAT NUM-UNUSED-NUMBER-CODES (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

ARITH-SFL-BIG 
ARITH-FLO-BIG
	((M-TEM) M-I)
	((M-I) M-J)
	((M-J) M-TEM)
	((M-Q) M-T)
	((M-C) M-D)
	(CALL-XCT-NEXT FLOAT-A-BIGNUM)
       ((M-2) M-1)
	(DISPATCH (BYTE-FIELD 4 0) M-A D-REVERSE-FLONUM-OPS)
		(ERROR-TABLE ARGTYP INTEGER M-T 1)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC FLOPACK-P)))
	
ARITH-BIG
	(DISPATCH-XCT-NEXT (BYTE-FIELD 4 0) M-A D-BIGNUM-1ARG)
       ((M-I) BIGNUM-HEADER-LENGTH M-C)

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-BIGNUM-1ARG
	(BIGNUM-ABS)
	(BIGNUM-MINUS)
	(XFALSE)		;ZEROP OF A BIGNUM!!!!!
	(BIGNUM-PLUSP)
	(BIGNUM-MINUSP)
	(BIGNUM-ADD1)
	(BIGNUM-SUB1)
	(BIGNUM-FIX)
	(BIGNUM-FLOAT)
	(BIGNUM-SMALL-FLOAT)
	(BIGNUM-HAULONG)
	(BIGNUM-LDB)
	(BIGNUM-DPB)
	(BIGASH)
 (REPEAT NUM-UNUSED-ARITH-1ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; Cons up a bignum.
;;; Inputs: M-B length+1, M-C sign in BIGNUM-HEADER-SIGN position
;;; Outputs: M-T boxed bignum, M-C sign/length part of header, M-E,M-K,M-S bashed
;;;          VMA same as M-T, MD header
;;; Note that M-1 and M-2 are preserved
BNCONS	(CALL SCONS-T)				;Cons in structure space, extra-pdl
	((M-TEM) SUB M-B (A-CONSTANT 1))	;Length to go in header
	((M-C) SELECTIVE-DEPOSIT M-C BIGNUM-HEADER-SIGN A-TEM)	;Incorporate sign
	((WRITE-MEMORY-DATA) ADD M-C		;Make rest of header
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
				  (BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	(POPJ-AFTER-NEXT (VMA-START-WRITE M-T)	;Store header, fix M-T data type
		Q-POINTER M-T (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)))
       (CHECK-PAGE-WRITE)

;; MD has the header of the bignum whether got here from ABS or from GCD
BIGNUM-ABS
	(JUMP-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN MD BIGNUM-COPY)
       ((M-C) M-I)				;Positive-signed header
RETURN-M-Q
 	(POPJ-AFTER-NEXT (M-T) M-Q)
       (NO-OP)

BIGNUM-MINUS
	(JUMP-NOT-EQUAL M-C (A-CONSTANT (BYTE-VALUE BIGNUM-HEADER-LENGTH 1))
			BIGNUM-MINUS-1)	;check for +setzness
	((VMA-START-READ) ADD M-Q (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(JUMP-NOT-EQUAL MD (A-CONSTANT MINIMUM-FIXNUM) BIGNUM-MINUS-1)
	(POPJ-AFTER-NEXT (M-T) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
						 MINIMUM-FIXNUM)))
       (NO-OP)
BIGNUM-MINUS-1
	((M-C) XOR M-C (A-CONSTANT (BYTE-MASK BIGNUM-HEADER-SIGN)))
;bignum in M-Q, new header(sign) in M-C, Length in M-I. Result in M-T.
BIGNUM-COPY
	(CALL-XCT-NEXT BNCONS)			;ALLOCATE IN STRUCTURE EXTRA-PDL
       ((M-B) ADD M-I (A-CONSTANT 1))
BIGNUM-COPY-L
	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((VMA-START-WRITE) ADD M-T A-I)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-I (A-CONSTANT 1) BIGNUM-COPY-L)
       ((M-I) SUB M-I (A-CONSTANT 1))
	(POPJ)

DPB-BIGNUM-SETUP  ;CALL HERE TO SET UP FOR DOING A DPB, SEE RELEVANT CODE.
	((M-K) (BYTE-FIELD 6 0) C-PDL-BUFFER-POINTER)
	((M-E) (BYTE-FIELD (DIFFERENCE 23. 6) 6) C-PDL-BUFFER-POINTER)
	((M-1) ADD M-K A-E)			;COMPUTE BIT POSITION OF LEFT EDGE OF BYTE
	((M-1) ADD M-1 (A-CONSTANT 31.))	;ROUND UP
		;Note the inclusion of one extra bit.  This is in case we produce
		;a negative "SETZ", which is 1 bit longer in sign-and-magnitude than
		;in 2's complement.
	(CALL-XCT-NEXT DIV)	;DIVIDE BY 31. TO GET NUMBER OF WORDS IN BIGNUM
       ((M-2) (A-CONSTANT 31.))	;RETURN QUOTIENT IN Q-R
	((M-B) Q-R)		;NEED AT LEAST THIS MANY WORDS.
BIGNUM-COPY-EXPAND   ;Copy bignum.  Resulting bignum to have at least M-B words of
		     ;significance.  Start with bignum in M-Q, header in M-C, current
		     ;length in M-I.  Result in M-T.  As a special hack, if M-I is zero,
		     ;just allocate a 0 bignum.
	(JUMP-GREATER-OR-EQUAL M-I A-B BIGNUM-COPY)     ;No expansion needed, just copy
	(CALL-XCT-NEXT BNCONS)				;Allocate in structure extra-pdl
       ((M-B) ADD M-B (A-CONSTANT 1))    		;Plus one for header
	((M-B) SUB M-B (A-CONSTANT 1))
	(CALL-NOT-EQUAL-XCT-NEXT M-I A-ZERO BIGNUM-COPY-L)	;Copy the number part (if any)
       ((M-ZR) SUB M-B A-I)		;Save how many words to zero
	((MD) A-ZERO)
BCE2	((VMA-START-WRITE) ADD M-T A-B)	;Zero out the new words.
	(CHECK-PAGE-WRITE)
	((M-ZR) SUB M-ZR (A-CONSTANT 1))
	(JUMP-GREATER-THAN-XCT-NEXT M-ZR A-ZERO BCE2)
       ((M-B) SUB M-B (A-CONSTANT 1))
	(POPJ)

BIGNUM-PLUSP
	((M-T) A-V-TRUE)		;CORRECT SINCE NO BIGNUM ZERO
	(POPJ-AFTER-NEXT POPJ-IF-BIT-CLEAR BIGNUM-HEADER-SIGN M-C)
       ((M-T) A-V-NIL)

BIGNUM-MINUSP
	((M-T) A-V-TRUE)
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET BIGNUM-HEADER-SIGN M-C)
       ((M-T) A-V-NIL)

BIGNUM-FIX
	(POPJ-AFTER-NEXT (M-T) M-Q)
       (NO-OP)

BIGNUM-HAULONG
	((VMA-START-READ) ADD M-Q A-I)	;GET HIGH ORDER WORD
	(CHECK-PAGE-READ)
	;; (length - 1) * 31. =  (length * 32.) - length - 31.
	;; XHAUL1 wants this in M-T  and the high bits in M-1.
	((M-T) DPB M-I (BYTE-FIELD 18. 5.) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-T) SUB M-T A-I)
	((M-T) SUB M-T (A-CONSTANT 31.))
	(JUMP-XCT-NEXT XHAUL1)
       ((M-1) MD)

BIGNUM-FLOAT
	(JUMP-XCT-NEXT FLOPACK-T)
       (CALL FLOAT-A-BIGNUM)

BIGNUM-SMALL-FLOAT
	(JUMP-XCT-NEXT SFLPACK-T)
       (CALL FLOAT-A-BIGNUM)

;;; Convert a bignum to a flonum.  Takes the length of the bignum in M-I,
;;; the bignum pointer in M-Q, the rest-of-header in M-C.  Leaves an internal-format
;;; flonum in M-I and M-1.  Clobbers M-4, M-3, M-1, M-K, M-TEM, M-T.  Must NOT clobber
;;; M-A, M-2 and M-J!
FLOAT-A-BIGNUM
	;; First get the second-to-highest order word into M-3.
	;; (If there is only one word, get zeroes.)
	(JUMP-EQUAL-XCT-NEXT M-I (A-CONSTANT 1) FLOAT-A-BIGNUM-X)
       ((M-3) A-ZERO)
	((M-TEM) SUB M-I (A-CONSTANT 1))
	((VMA-START-READ) ADD M-Q A-TEM)
	(CHECK-PAGE-READ)
	((M-3) MD)
FLOAT-A-BIGNUM-X
	;; Now get the highest order word in M-1 and get its length in M-T.
	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((M-T) A-ZERO)
	(CALL-XCT-NEXT XHAUL1)
       ((M-1 C-PDL-BUFFER-POINTER-PUSH) MD) ;EVIL ON PDL BUFFER, BUT WILL BE POPPED SOON
	;; If M-T contains 31. then the mantissa is on the pdl
	;; no need to ldb/dpb anything (in fact it won't work!)
	(JUMP-EQUAL M-T (A-CONSTANT 31.) FLOAT-A-BIGNUM-31)
	;; Now piece together the mantissa of the flonum into M-1.
	;; First LDB from M-3, with:
	;;		BYTL-1 = (30. - M-T)	MROT = (32. - M-T)
	;; Then DPB from C-PDL-BUFFER-POINTER-POP into M-1, with:
	;;		BYTL-1 = (M-T - 1)	MROT = (31. - M-T)
	((M-TEM) SUB (M-CONSTANT 32.) A-T)
	((M-4) SUB M-TEM (A-CONSTANT 2))
	((OA-REG-LOW) DPB M-4 OAL-BYTL-1 A-TEM)
	((M-1) (BYTE-FIELD 0 0) M-3 A-ZERO)
	((M-K) SUB M-T (A-CONSTANT 1))
	((M-TEM) ADD M-4 (A-CONSTANT 1))
	((OA-REG-LOW) DPB M-K OAL-BYTL-1 A-TEM)
	((M-1) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 0 0) A-1)
FLOAT-A-BIGNUM-DONE
	;; length in M-I   nbits (sig bits in high order word) in M-T
	;; (length - 1) * 31. + nbits + 2000 =  
	;;       (length * 32. + nbits) - length + 1741
	((M-T) DPB M-I (BYTE-FIELD 27. 5.) A-T) ;Clears data-type
	((M-T) SUB M-T A-I)
	(POPJ-AFTER-NEXT (M-I) ADD M-T (A-CONSTANT 1741))
       (CALL-IF-BIT-SET BIGNUM-HEADER-SIGN M-C FNEG1)

FLOAT-A-BIGNUM-31
	(JUMP-XCT-NEXT FLOAT-A-BIGNUM-DONE)
       ((M-1) C-PDL-BUFFER-POINTER-POP)


ARITH-BIG-BIG
	(DISPATCH-XCT-NEXT (BYTE-FIELD 4 0) M-A D-FORWARD-BIGNUM-OPS)
       ((M-B) M-T)

(LOCALITY D-MEM)
;BIGNUMS IN M-B AND M-T, M-Q.  THEIR HEADERS IN M-D, M-C.  LENGTHS IN M-J, M-I.
(START-DISPATCH 4 0)
D-FORWARD-BIGNUM-OPS
	(BADD)
	(BSUB)
	(BMPY)
	(BDIV)
	(BEQL)
	(BGRP)
	(BLSP)
	(BMIN)
	(BMAX)
	(BBOOLE)
 (REPEAT NUM-UNUSED-ARITH-2ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

BEQL	(POPJ-NOT-EQUAL-XCT-NEXT M-C A-D)
       ((M-T) A-V-NIL)
BEQL1	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((M-1) MD)
	((VMA-START-READ) ADD M-B A-I)
	(CHECK-PAGE-READ)
	(POPJ-NOT-EQUAL MD A-1)
	(JUMP-GREATER-THAN-XCT-NEXT M-I (A-CONSTANT 1) BEQL1)
       ((M-I) SUB M-I (A-CONSTANT 1))
	(POPJ-AFTER-NEXT (M-T) A-V-TRUE)
       (NO-OP)

;; this loops over two bignum's magnitudes (in M-Q,M-C,M-I and M-B,M-D,M-J) does nothing
;; if the first is larger than the second, puts M-E in M-T if they are equal
;; else moves M-A into M-T.  In any case POPJing out. Smashes M-I (which better equal M-J
;; anyway!!!!)

BSHFFL	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	((M-1) MD)
	((VMA-START-READ) ADD M-B A-I)
	(CHECK-PAGE-READ)
	(POPJ-LESS-THAN MD A-1)			;first is bigger so popj
	(JUMP-NOT-EQUAL MD A-1 BSHFFL-1)	;second is bigger, move and popj
	;equal continue looping
	(JUMP-GREATER-THAN-XCT-NEXT M-I (A-CONSTANT 1) BSHFFL)
       ((M-I) SUB M-I (A-CONSTANT 1))
	(POPJ-AFTER-NEXT (M-T) M-E)		;all equal return M-E
       (NO-OP)

BSHFFL-1
	(POPJ-AFTER-NEXT NO-OP)
       ((M-T) M-A)

;; compare two bignums (in M-Q,M-C,M-I and M-B,M-D,M-J) and return T if first
;; is bigger than the second. Uses M-A and M-T and M-E
BGRP	(JUMP-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-C BGRP-1)
       ((M-E) A-V-NIL)				;Value to return if equal
	(POPJ-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) A-V-TRUE)				;First is pos., second is neg.
	(POPJ-GREATER-THAN M-I A-J)		;Both pos. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;Both pos. Same length so loop.
       ((M-A) A-V-NIL)				;M-A gets alternate answer
	(POPJ-AFTER-NEXT (M-T) A-V-NIL)		;Both pos. Second longer.
       (NO-OP)

BGRP-1	(POPJ-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) A-V-NIL)				;First is neg. second is pos.
	(POPJ-GREATER-THAN M-I A-J)		;both neg. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;both neg. same length so loop.
       ((M-A) A-V-TRUE)				;M-A gets other answer
	(POPJ-AFTER-NEXT (M-T) A-V-TRUE)	;both neg. second longer.
       (NO-OP)

;; compare two bignums (in M-Q,M-C,M-I and M-B,M-D,M-J) and return T if second
;; is bigger than the first. Uses M-A and M-T and M-E
BLSP	(JUMP-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-C BLSP-1)
       ((M-E) A-V-NIL)				;Value to return if equal
	(POPJ-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) A-V-NIL)				;First is pos., second is neg.
	(POPJ-GREATER-THAN M-I A-J)		;Both pos. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;Both pos. Same length so loop.
       ((M-A) A-V-TRUE)				;M-A gets alternate answer
	(POPJ-AFTER-NEXT (M-T) A-V-TRUE)	;Both pos. Second longer.
       (NO-OP)

BLSP-1	(POPJ-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) A-V-TRUE)				;First is neg. second is pos.
	(POPJ-GREATER-THAN M-I A-J)		;both neg. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;both neg. same length so loop.
       ((M-A) A-V-NIL)				;M-A gets other answer
	(POPJ-AFTER-NEXT (M-T) A-V-NIL)		;both neg. second longer.
       (NO-OP)

;; compare two bignums (in M-Q,M-C,M-I and M-B,M-D,M-J) and return the bigger one.
;; Uses M-A and M-T and M-E
BMAX	(JUMP-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-C BMAX-1)
       ((M-E) M-Q)				;Value to return if equal
	(POPJ-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) M-Q)				;First is pos., second is neg.
	(POPJ-GREATER-THAN M-I A-J)		;Both pos. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;Both pos. Same length so loop.
       ((M-A) M-B)				;M-A gets alternate answer
	(POPJ-AFTER-NEXT (M-T) M-B)		;Both pos. Second longer.
       (NO-OP)

BMAX-1	(POPJ-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) M-B)				;First is neg. second is pos.
	(POPJ-GREATER-THAN M-I A-J)		;both neg. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;both neg. same length so loop.
       ((M-A) M-Q)				;M-A gets other answer
	(POPJ-AFTER-NEXT (M-T) M-Q)		;both neg. second longer.
       (NO-OP)

;; compare two bignums (in M-Q,M-C,M-I and M-B,M-D,M-J) and return the smaller one.
;; Uses M-A and M-T and M-E
BMIN	(JUMP-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-C BMIN-1)
       ((M-E) M-Q)				;Value to return if equal
	(POPJ-IF-BIT-SET-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) M-B)				;First is pos., second is neg.
	(POPJ-GREATER-THAN M-I A-J)		;Both pos. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;Both pos. Same length so loop.
       ((M-A) M-Q)				;M-A gets alternate answer
	(POPJ-AFTER-NEXT (M-T) M-Q)		;Both pos. Second longer.
       (NO-OP)

BMIN-1	(POPJ-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-D)
       ((M-T) M-Q)				;First is neg. second is pos.
	(POPJ-GREATER-THAN M-I A-J)		;both neg. First longer.
	(JUMP-EQUAL-XCT-NEXT M-I A-J BSHFFL)	;both neg. same length so loop.
       ((M-A) M-B)				;M-A gets other answer
	(POPJ-AFTER-NEXT (M-T) M-B)		;both neg. second longer.
       (NO-OP)

;; For add and subtract build the answer in M-T,M-K . sign of answer is expected to
;; be the sign bit in M-C. First arg in M-Q,M-I second in M-R,M-J (note the move to M-R)

;; For addition we want the longest BIGNUM in M-R,M-J

BADD	((M-TEM) XOR M-C A-D)
	(JUMP-IF-BIT-SET BIGNUM-HEADER-SIGN M-TEM BSUB1) ;signs don't agree so subtract
BADD1	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-J A-I BADD2)
       ((M-2) A-ZERO)				;M-2 gets the carry
	((M-TEM) M-I)				;Swap if second isn't largest.
	((M-I) M-J)
	((M-J) M-TEM)
	((M-B) M-Q)				;M-T and M-B contain the same thing!
	((M-Q) M-T)
BADD2	((M-R) M-B)
	(CALL-XCT-NEXT BNCONS)			;Allocate result bignum
       ((M-B) ADD M-J (A-CONSTANT 2))
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE 
					 (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	((M-D) (A-CONSTANT 1))			;M-D counts up
BADD3	((VMA-START-READ) ADD M-Q A-D)
	(CHECK-PAGE-READ)
	((M-1) ADD MD A-2)			;M-2 has carry from last round
	((VMA-START-READ) ADD M-R A-D)
	(CHECK-PAGE-READ)
	((M-1) ADD MD A-1)			;M-1 now has sum (carry and 31 bits out)
	((MD) (BYTE-FIELD 31. 0) M-1 A-ZERO)	;Write 31 bits
	((M-2) (BYTE-FIELD 1 31.) M-1 A-ZERO)	;save carry
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-D A-I BADD3)
       ((M-D) ADD M-D (A-CONSTANT 1))
	(JUMP-GREATER-THAN M-D A-J BADD4)	;Jump if lengths (M-I,M-J) were equal,
						; there are no more words to add in
;;FIXNUM - BIGNUM addition joins us here (can drop in)
;; Bignum in M-R,M-J. 1 (sometimes) in M-D. Fixnum in M-2. Answer in M-T with header in M-C.
BADD5	((VMA-START-READ) ADD M-R A-D)
	(CHECK-PAGE-READ)
	((M-1) ADD MD A-2)			;M-2 has carry
	((MD) (BYTE-FIELD 31. 0) M-1 A-ZERO)
	((M-2) (BYTE-FIELD 1 31.) M-1 A-ZERO)
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-D A-J BADD5)	;M-J'th word is last in M-R bignum
       ((M-D) ADD M-D (A-CONSTANT 1))
BADD4	(JUMP-GREATER-THAN M-2 A-ZERO BADD6)	;There was some carry, so store in last word.
	((M-C) SUB M-C (A-CONSTANT 1))		;no carry so give word back.
	((MD) ADD M-C (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE)
	((M-1) ADD M-T A-D)
	(JUMP-XCT-NEXT UN-CONS)
       ((M-2) (A-CONSTANT 1))

BADD6	((MD) M-2)
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(POPJ)		;NO POPJ-AFTER-NEXT, COULD BE RETURNING TO MAIN LOOP

;; Subtraction:
BSUB	((M-TEM) XOR M-C A-D)
	(JUMP-IF-BIT-SET BIGNUM-HEADER-SIGN M-TEM BADD1)	;signs don't agree so add
;; first we shuffle the bignums around to be sure of subtracting the smaller magnitude
;; from the larger. Note that if we switch them then we must complement the sign bit in M-C.
BSUB1	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
	((M-R) M-T)				;will need M-T for answer
	(JUMP-GREATER-THAN-XCT-NEXT M-I A-J BSUB-OK)
       ((M-D) M-I)				;M-D gets the number of the last different word
	(JUMP-LESS-THAN M-I A-J BSUB-SWITCH)
	;drops in
;; they are the same length so count M-D down until you find a word that is different.
;; M-J is also kept equal to M-D since there is no need to remember the words out there
;; if when you subtract them you get zero.  (7623456123-7623456032 is the same as 123-032 !)
BSUB-L	((VMA-START-READ) ADD M-Q A-D)
	(CHECK-PAGE-READ)
	((M-J) M-D)
	((M-1) MD)
	((VMA-START-READ) ADD M-R A-D)
	(CHECK-PAGE-READ)
	(JUMP-LESS-THAN MD A-1 BSUB-OK)
	(JUMP-GREATER-THAN MD A-1 BSUB-SWITCH-1)
	(JUMP-GREATER-THAN-XCT-NEXT M-D (A-CONSTANT 1) BSUB-L)
       ((M-D) SUB M-D (A-CONSTANT 1))
	(POPJ-AFTER-NEXT
	 (M-T) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;EQUAL!
       (NO-OP)

BSUB-SWITCH
	((M-TEM) M-I)				;Switch (but nobody cares about M-I)
	((M-D) M-J)
	((M-J) M-TEM)
BSUB-SWITCH-1
	((M-C) XOR M-C (A-CONSTANT (BYTE-MASK BIGNUM-HEADER-SIGN)))	;Switch sign bit.
	((M-R) M-Q)
	((M-Q) M-T)				;M-T still contains the original thing!

;; we have now cleverly arranged for M-D to be the length of the longest possible answer
;; M-Q,(M-I *) contain the bigger magnitude bignum M-R,M-J the smaller
;; correct sign bit of answer is in M-C, answer to be built in M-T,M-C (sign bit kept
;; in M-C)
;; (* note that we really don't care about M-I so we havn't actually made sure it contains
;; the correct thing)
BSUB-OK	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-D (A-CONSTANT 1))
	((M-2) A-ZERO)				;borrow
	((M-B) (A-CONSTANT 1))			;counter
BSUB-IT	((VMA-START-READ) ADD M-R A-B)
	(CHECK-PAGE-READ)
	((M-1) ADD MD A-2)
	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	((M-1) SUB MD A-1)
	((MD M-3) (BYTE-FIELD 31. 0) M-1 A-ZERO)
	((VMA-START-WRITE) ADD M-T A-B)
	(CHECK-PAGE-WRITE)
	(JUMP-EQUAL-XCT-NEXT M-3 A-ZERO BSUB-IT1)
       ((M-2) (BYTE-FIELD 1 31.) M-1 A-ZERO)
	((M-E) M-B)				;M-E gets number of last non-zero word stored
BSUB-IT1
	(JUMP-LESS-THAN-XCT-NEXT M-B A-J BSUB-IT)
       ((M-B) ADD M-B (A-CONSTANT 1))
	(JUMP-GREATER-THAN M-B A-D BCLEANUP)	;Jump if no more words to borrow into
;;FIXNUM - BIGNUM subtraction joins us here.
;; Bignum in M-Q,M-D (yes M-D!). 1 in M-B. Fixnum in M-2. Answer in M-T with header in M-C.
;; 1 should be in M-E (despite the fact that that might be wrong, the answer will be
;; spotted as a fixnum zero anyway!)
BSUB-C	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	((M-1) SUB MD A-2)
	((MD M-3) (BYTE-FIELD 31. 0) M-1 A-ZERO)
	((VMA-START-WRITE) ADD M-T A-B)
	(CHECK-PAGE-WRITE)
	(JUMP-EQUAL-XCT-NEXT M-3 A-ZERO BSUB-C1)
       ((M-2) (BYTE-FIELD 1 31.) M-1 A-ZERO)
	((M-E) M-B)				;Index of last non-zero word
BSUB-C1 (JUMP-LESS-THAN-XCT-NEXT M-B A-D BSUB-C)
       ((M-B) ADD M-B (A-CONSTANT 1))
	(JUMP BCLEANUP)

;; multiply two bignums.
BMPY	((M-R) M-T)
	((M-K) ADD M-I A-J)	;Possible length of answer
	((M-C) XOR M-C A-D)	;Sign in C is correct
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-K (A-CONSTANT 1))
	((M-K) BIGNUM-HEADER-LENGTH M-C)		;M-K was smashed by SCONS
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE 
					 (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))

;; Now we have first arg in M-Q,M-I  second in M-R,M-J .  We are building the answer in
;; M-T,M-K .  The correct header for the answer lives in M-C.
;; M-S will index into the answer, M-D into first arg, M-E + 1 into second.
;; it must be true that M-D + M-E = M-S
;; the running total is kept in M-A,M-2,M-1
;; M-B gets M-J - 1 for comparison
;; M-ZR gets M-K - 1 for comparison
	((M-B) SUB M-J (A-CONSTANT 1))
	((M-ZR) SUB M-K (A-CONSTANT 1))
	((M-S) (A-CONSTANT 1))
	((M-A) A-ZERO)
	((M-1) A-ZERO)
	((M-2) A-ZERO)
BMPY-LOOP
	(JUMP-GREATER-THAN-XCT-NEXT M-S A-I BMPY-LOOP-1)
       ((M-D) M-I)
	((M-D) M-S)		;M-D gets min{M-I,M-S}
BMPY-LOOP-1
	((VMA-START-READ) ADD M-Q A-D)
	(CHECK-PAGE-READ)
	((M-E) SUB M-S A-D)
	((M-3) MD)
	((VMA-START-READ) M+A+1 M-R A-E)
	(CHECK-PAGE-READ)
	((Q-R) MD)
	;; Having loaded the 2 31 bit things to be multiplied into Q-R and M-3
	;; this will multiply them and add the result into M-A,M-2,M-1
	;; (31 bits in M-1 and M-2, less than 24 in M-A)
(REPEAT 31. ((M-1) MULTIPLY-STEP M-1 A-3))
	((M-1) ADD M-1 A-2)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 31.) M-1 BMPY-C)
       ((M-2) (BYTE-FIELD 31. 0) M-1 A-ZERO)
	((M-A) ADD M-A (A-CONSTANT 1))
BMPY-C	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-E A-B BMPY-LOOP-1-DONE)	;M-B = M-J - 1
       ((M-1) (BYTE-FIELD 31. 1) Q-R A-ZERO)
	(JUMP-GREATER-THAN-XCT-NEXT M-D (A-CONSTANT 1) BMPY-LOOP-1)
       ((M-D) SUB M-D (A-CONSTANT 1))
BMPY-LOOP-1-DONE
	((MD) M-1)
	((VMA-START-WRITE) ADD M-T A-S)
	(CHECK-PAGE-WRITE)
	((M-1) M-2)
	((M-2) M-A)
	((M-A) A-ZERO)
	(JUMP-LESS-THAN-XCT-NEXT M-S A-ZR BMPY-LOOP)	;M-ZR = M-K - 1
       ((M-S) ADD M-S (A-CONSTANT 1))
	(JUMP-NOT-EQUAL M-1 A-ZERO BMPY-FULL)
	((M-C) SUB M-C (A-CONSTANT 1))		;Result 1 word shorter than expected
	((MD) ADD M-C (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE)
	((M-1) ADD M-T A-K)
	(JUMP-XCT-NEXT UN-CONS)
       ((M-2) (A-CONSTANT 1))

BMPY-FULL
	((MD) M-1)
	((VMA-START-WRITE) ADD M-T A-S)
	(CHECK-PAGE-WRITE)
	(POPJ)		;NO POPJ-AFTER-NEXT, MIGHT BE RETURNING TO MAIN LOOP

;;; Bignum - Bignum division: (algorithm from Knuth Vol 2)
BDIV
	;;If second bignum is longer than the first bignum then the answer is 0
	(JUMP-GREATER-THAN M-J A-I RETURN-ZERO)
	;;Get sign of answer into M-C by xoring with M-D
	((M-D) SELECTIVE-DEPOSIT BIGNUM-HEADER-SIGN M-D A-ZERO)
	((M-C) XOR M-C A-D)
	;;If second is one word long then we can do Bignum - Fixnum division
	(JUMP-GREATER-THAN-XCT-NEXT M-J (A-CONSTANT 1) BDIV-1)
       ((M-R) M-T)
	((VMA-START-READ) ADD M-T (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(JUMP-XCT-NEXT BFXDIV)
       ((M-2) MD)

BDIV-1
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
	;;Allocate a bignum for the answer: (put it in M-A)
	((M-A) SUB M-I A-J)
	((M-A) ADD M-A (A-CONSTANT 1))	;Possible length of answer.
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-A (A-CONSTANT 1))
	(CALL-XCT-NEXT BDIV-REMAINDER-COMMON)
       ((M-A) M-T)
	;;M-Q,(M-I + 1) contains garbage. M-T,M-K contains the answer (with perhaps
	;; a zero in the top word). M-C has the correct sign bit for the answer.
	((M-1) M-Q)
	((M-2) ADD M-I (A-CONSTANT 2))
	(CALL-XCT-NEXT UN-CONS)
       ((M-Q) A-V-NIL)				;clear pointer to possible garbage
	((VMA-START-READ) ADD M-T A-K)		;Quotient may be 1 too long.
	(CHECK-PAGE-READ)
	((M-D) M-K)
	((M-E) M-D)
	(JUMP-NOT-EQUAL-XCT-NEXT MD A-ZERO BCLEANUP)
       ((M-C) SELECTIVE-DEPOSIT M-C BIGNUM-HEADER-SIGN A-K)
	(JUMP-XCT-NEXT BCLEANUP)
       ((M-E) SUB M-E (A-CONSTANT 1))

;Bignum-bignum remainder
; We enter with the first bignum in M-C the second in M-B and the header
; of the first still in MD.
REMAINDER-BIG-BIG
	((M-Q) M-C)
	((M-C) HEADER-REST-FIELD MD)
	((VMA-START-READ) M-B)
	(CHECK-PAGE-READ)
	((M-R) M-B)
	((M-I) BIGNUM-HEADER-LENGTH M-C)
	((M-J) BIGNUM-HEADER-LENGTH MD)
	;;If second bignum is longer than the first bignum then the answer is the first
	(JUMP-GREATER-THAN M-J A-I RETURN-M-Q)
	;;Sign of answer is already in M-C
	;;If second is one word long then do Bignum - Fixnum remainder
	(JUMP-GREATER-THAN M-J (A-CONSTANT 1) BDIVR-2)
	((VMA-START-READ) ADD M-R (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-B) M-Q)
	((M-2) MD)
	((M-A) BIGNUM-HEADER-SIGN M-C)
	((M-C) BIGNUM-HEADER-LENGTH M-C)
	(CALL REMAINDER-BIG-FIX-1)
	(JUMP-LESS-THAN M-1 (A-CONSTANT -1_23.) FIX-OVERFLOW-1)
	(JUMP-GREATER-OR-EQUAL M-1 (A-CONSTANT 1_23.) FIX-OVERFLOW-1)
	(JUMP FIXPACK-T)

BDIVR-2
	(CALL-XCT-NEXT BDIV-REMAINDER-COMMON)
       ((M-A) A-ZERO)		;Indicate that quotient is not being saved.
	;;Now we have the remainder in M-Q,(M-I + 1) possibly shifted by
	;; an amount determined by
	;; the haulong still(!) in M-D. Sign of answer is still in M-C
	;;To shift back we perform an operation similar to BDIV-NORMALIZE:
	;; First we LDB from the current word with: (M-K)
	;;		BYTL-1 = Haulong - 1
	;;		MROT = Haulong + 1
	;; Then we DPB into that from the next higher word with: (M-S)
	;;		BYTL-1 = 30. - haulong
	;;		MROT = Haulong
	(JUMP-EQUAL-XCT-NEXT M-D (A-CONSTANT 31.) BDIVR-3)
       ((M-T) M-Q)
	((M-K) ADD M-D (A-CONSTANT 1))		;MROT
	((M-TEM) SUB M-D (A-CONSTANT 1))	;BYTL-1
	((M-K) DPB M-TEM OAL-BYTL-1 A-K)	;For LDB
	((M-TEM) (A-CONSTANT 30.))
	((M-TEM) SUB M-TEM A-D)			;BYTL-1, MROT in M-D
	((M-S) DPB M-TEM OAL-BYTL-1 A-D)	;For DPB
	((M-D) (A-CONSTANT 1))			;Counts through the bignum
	((M-E) (A-CONSTANT 1))			;Gets number of last non-zero word
	((VMA-START-READ) ADD M-T A-D)
	(CHECK-PAGE-READ)
	((M-1) MD)				;M-1 has word from last round.
BDIVR-UNNORMALIZE-LOOP
	((VMA-START-READ) M+A+1 M-T A-D)
	(CHECK-PAGE-READ)
	((OA-REG-LOW) M-K)
	((M-2) (BYTE-FIELD 0 0) M-1 A-ZERO)	;LDB out of lower word
	((M-1) MD)
	((OA-REG-LOW) M-S)
	((MD M-2) DPB M-1 (BYTE-FIELD 0 0) A-2)	;DPB in from higher word
	((VMA-START-WRITE) ADD M-T A-D)		;Put back into lower word
	(CHECK-PAGE-WRITE)
	(JUMP-EQUAL M-2 A-ZERO BDIVR-UNNORMALIZE-1)
	((M-E) M-D)
BDIVR-UNNORMALIZE-1
	(JUMP-LESS-THAN-XCT-NEXT M-D A-I BDIVR-UNNORMALIZE-LOOP)
       ((M-D) ADD M-D (A-CONSTANT 1))
	(JUMP-XCT-NEXT BCLEANUP)
       ((M-C) SELECTIVE-DEPOSIT BIGNUM-HEADER-SIGN M-C A-D)

BDIVR-3
	;;In this case (no shifting necessary) we loop downward looking
	;; for the first non-zero word. We call ARY-TO-BIG-CLEANUP to do this.
	((M-D) ADD M-I (A-CONSTANT 1))
	((M-C) SELECTIVE-DEPOSIT BIGNUM-HEADER-SIGN M-C A-D)
       	(JUMP-XCT-NEXT ARY-TO-BIG-CLEANUP)
       ((M-E) M-D)				;Counts down bignum

BDIV-REMAINDER-COMMON
	;;allocate a temporary bignum one word longer than first arg (put it in M-D)
	;; If Bignum remainder got us here then this bignum will BE the answer
	(CALL-XCT-NEXT SCONS-T)
       ((M-B) ADD M-I (A-CONSTANT 2))
	((M-TEM) ADD M-I (A-CONSTANT 1))
	((MD) ADD M-TEM (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					  (BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE M-D) Q-POINTER M-T
			       (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)))
	(CHECK-PAGE-WRITE)
	;;Now do a haulong on the high order word of second arg (for normalization)
	;; note that if the answer is 31. then there is no need to normalize or allocate
	;; a second temporary bignum
	((VMA-START-READ) ADD M-R A-J)
	(CHECK-PAGE-READ)
	((M-T) A-ZERO)
	(CALL-XCT-NEXT XHAUL1)
       ((M-1) MD)
	(JUMP-EQUAL-XCT-NEXT M-T (A-CONSTANT 31.) BDIV-PUNT-NORMALIZING)
       ((M-1) M-T)		;hide away haulong for later
	;;allocate another temporary bignum as long as the second and keep it in M-T
	(CALL-XCT-NEXT SCONS-T)
       ((M-B) ADD M-J (A-CONSTANT 1))
	((MD) ADD M-J (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE M-T) Q-POINTER M-T
			       (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)))
	(CHECK-PAGE-WRITE)
	;;So now we build the proper constants from saved haulong in M-1
	;; for ldbing (in M-K) and dpbing (in M-S) to normalize (see comment in front
	;; of BDIV-NORMALIZE)
	(CALL BDIV-NORMALIZE-ENCODE-SHIFT)
	;;Perform normalization (subroutine takes old bignum in M-B and new in M-D
	;; steps length in M-ZR, bashes M-4)
	((M-E) A-ZERO)		;No offset for BDIV-NORMALIZE.
	((M-B) M-Q)
	((M-ZR) M-I)
	(CALL-XCT-NEXT BDIV-NORMALIZE)
       ((M-2) A-ZERO)
	((M-Q) M-D)		;Replace original dividend with copy
	;;Prepare to call it again:
	((VMA-START-READ) ADD M-R A-J)
	(CHECK-PAGE-READ)
	((M-D) M-T)
	((M-B) M-R)
	((OA-REG-LOW) M-S)
	((M-2) DPB MD (BYTE-FIELD 0 0) A-ZERO)
	(CALL-XCT-NEXT BDIV-NORMALIZE)
       ((M-ZR) SUB M-J (A-CONSTANT 1))
	(JUMP-XCT-NEXT BDIV-READY)
       ((M-R) M-D)		;Replace original divisor with copy

BDIV-PUNT-NORMALIZING
	;;In this case all we do is copy the first arg:
	((M-ZR) M-I)
BDIV-PUNT-NORMALIZING-1
	((VMA-START-READ) ADD M-Q A-ZR)
	(CHECK-PAGE-READ)
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)
	((VMA-START-WRITE) ADD M-D A-ZR)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-ZR (A-CONSTANT 1) BDIV-PUNT-NORMALIZING-1)
       ((M-ZR) SUB M-ZR (A-CONSTANT 1))
	((MD) A-ZERO)
	((VMA-START-WRITE) M+A+1 M-D A-I)
	(CHECK-PAGE-WRITE)
	((M-Q) M-D)		;Replace original dividend with copy
BDIV-READY
	((M-T) M-A)		;Answer will wind up in M-T so why not now?
				;If remainder then this is a zero.
	((M-K) SUB M-I A-J)
	((M-K) ADD M-K (A-CONSTANT 1))
	((M-D) M-1)		;Saved haulong
	;;So now the situation is as follows: The sign of the answer is in
	;; BIGNUM-HEADER-SIGN in M-C. The old haulong of the top word of the second
	;; argument is in M-D (We have to save
	;; that information so we know wether or not to un-cons!) We have a bignum
	;; in M-Q,(M-I + 1) that we are dividing by a normalized bignum in M-R,M-J.
	;; Answer is being built in M-T,M-K. (M-T = 0 if remaindering.)
	((M-S) M-K)			;M-S will count down through the answer
	((M-E) M-I)			;M-E will step down bignum in M-Q
	((VMA-START-READ) ADD M-R A-J)
	(CHECK-PAGE-READ)
	((A-BDIV-V1) MD)				;V1
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((A-BDIV-V2) MD)				;V2
BDIV-LOOP
	;;Now we are ready to make an estimate of what that first 31. bits will be.
	;;Comments are notation from Knuth.
	((VMA-START-READ) M+A+1 M-Q A-E)
	(CHECK-PAGE-READ)
	((M-3) MD)					;U0
	((VMA-START-READ) ADD M-Q A-E)
	(CHECK-PAGE-READ)
	(JUMP-EQUAL M-3 A-BDIV-V1 BDIV-SIMPLE-CASE)
	((M-TEM) DPB M-3 (BYTE-FIELD 1 31.) A-ZERO)
	((Q-R) IOR MD A-TEM)				;low 32. bits of U0 * B + U1
	((M-3) (BYTE-FIELD 30. 1) M-3 A-ZERO)		;high 30. bits of same
	((M-1) A-BDIV-V1)				;Divide by V1
	;; Compute QHAT = Floor((U0 * B + U1) / V1) and RHAT = U0 * B + U1 - QHAT * V1
	((M-3) DIVIDE-FIRST-STEP M-3 A-1)
(REPEAT 31. ((M-3) DIVIDE-STEP M-3 A-1))
	((M-3) DIVIDE-LAST-STEP M-3 A-1)
	((M-3) DIVIDE-REMAINDER-CORRECTION-STEP M-3 A-1);RHAT
	(JUMP-XCT-NEXT BDIV-OPTIMIZE-QHAT)
       ((M-1) Q-R)					;QHAT

BDIV-SIMPLE-CASE
	((M-1) (A-CONSTANT 17777777777))		;QHAT = B - 1
	((M-3) ADD MD A-BDIV-V1)			;RHAT = U1 + V1
	;; If sign bit of M-3 is set then we know that RHAT * B + U2 is greater
	;; than QHAT * V2:
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 31.) M-3 BDIV-QHAT-IS-GOOD)
BDIV-OPTIMIZE-QHAT
	;;Now in order to check if RHAT * B + U2 < QHAT * V2 we first read in U2
	;; and then compute QHAT * V2 .
	((M-TEM) SUB M-E (A-CONSTANT 1))
	((VMA-START-READ) ADD M-Q A-TEM)
	(CHECK-PAGE-READ)
	((Q-R) A-BDIV-V2)
	(CALL-XCT-NEXT MPY)
       ((M-4) MD)					;U2
	((M-2) M-2 OUTPUT-SELECTOR-LEFTSHIFT-1)		;BRING IN HIGH BIT OF Q
	;;Now M-2 = High(QHAT * V2)
	;;    M-3 = RHAT = High(RHAT * B + U2)
	;;    M-4 = U2 = Low(RHAT * B + U2)
	;;    M-1 = QHAT
	;;    Q-R = Low(QHAT * V2) plus junk in sign bit
	(JUMP-GREATER-THAN M-3 A-2 BDIV-QHAT-IS-GOOD)
	((M-TEM) (BYTE-FIELD 31. 0) Q-R A-ZERO)		;Low(QHAT * V2)
	(JUMP-LESS-THAN M-3 A-2 BDIV-OPTIMIZE-QHAT-SUB1)
	(JUMP-GREATER-OR-EQUAL M-4 A-TEM BDIV-QHAT-IS-GOOD)
BDIV-OPTIMIZE-QHAT-SUB1
	;; So QHAT must be decremented and other quantities adjusted:
	((M-TEM) SUB M-TEM A-BDIV-V2)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT (BYTE-FIELD 1 31.) M-TEM BDIV-2);carry into High(QHAT * V2)
       ((M-3) ADD M-3 A-BDIV-V1)			;Adjust RHAT
	((M-TEM) (BYTE-FIELD 31. 0) M-TEM A-ZERO)
	((M-2) SUB M-2 (A-CONSTANT 1))
BDIV-2
 	;;If M-3 is negative then RHAT * B + U2 overflew and must be greater than
	;; QHAT * V2
	(JUMP-IF-BIT-SET-XCT-NEXT (BYTE-FIELD 1 31.) M-3 BDIV-QHAT-IS-GOOD)
       ((M-1) SUB M-1 (A-CONSTANT 1))			;Decrement QHAT
	(JUMP-GREATER-THAN M-3 A-2 BDIV-QHAT-IS-GOOD)
	(JUMP-LESS-THAN M-3 A-2 BDIV-OPTIMIZE-QHAT-SUB2)
	(JUMP-GREATER-OR-EQUAL M-4 A-TEM BDIV-QHAT-IS-GOOD)
BDIV-OPTIMIZE-QHAT-SUB2
	((M-1) SUB M-1 (A-CONSTANT 1))			;Decrement QHAT second time.
BDIV-QHAT-IS-GOOD
	;;QHAT contains the wrong thing only once every 716 million times!
	;;We multiply divisor by QHAT and subtract from dividend
	((M-A) (A-CONSTANT 1))			;steps through M-R
	((M-B) SUB M-E A-J)
	((M-B) ADD M-B (A-CONSTANT 1))		;steps through M-Q
	((M-ZR) A-ZERO)				;borrow from last round
	((M-2) A-ZERO)				;for multiplication scratch
BDIV-MPY-LOOP
	((VMA-START-READ) ADD M-R A-A)
	(CHECK-PAGE-READ)
	((Q-R) MD)
(REPEAT 31. ((M-2) MULTIPLY-STEP M-2 A-1))
	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	((M-TEM) (BYTE-FIELD 31. 1) Q-R A-ZERO)
	((M-TEM) SUB MD A-TEM)
	((M-TEM) SUB M-TEM A-ZR)
	((MD) (BYTE-FIELD 31. 0) M-TEM A-ZERO)
	((M-ZR) (BYTE-FIELD 1 31.) M-TEM A-ZERO)
	((VMA-START-WRITE) ADD M-Q A-B)
	(CHECK-PAGE-WRITE)
	((M-A) ADD M-A (A-CONSTANT 1))
	(JUMP-LESS-THAN-XCT-NEXT M-B A-E BDIV-MPY-LOOP)
       ((M-B) ADD M-B (A-CONSTANT 1))
	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	((M-4) SUB MD A-2)
	((MD-START-WRITE M-4) SUB M-4 A-ZR)
	(CHECK-PAGE-WRITE)
	(CALL-IF-BIT-SET (BYTE-FIELD 1 31.) M-4 BDIV-ONCE-IN-716MILLION) ;DAMN! QHAT too big.
	(JUMP-EQUAL-XCT-NEXT M-T A-ZERO BDIV-DONT-STORE)	;write QHAT into quotient
       ((M-E) SUB M-E (A-CONSTANT 1))				;If not remaindering
	((MD) M-1)
	((VMA-START-WRITE) ADD M-T A-S)
	(CHECK-PAGE-WRITE)
BDIV-DONT-STORE
	(JUMP-GREATER-THAN-XCT-NEXT M-S (A-CONSTANT 1) BDIV-LOOP)
       ((M-S) SUB M-S (A-CONSTANT 1))
	;;Now we have the answer so we give up any temp. storage and cleanup the answer.
	;;Believe it or not M-D still contains the haulong of high word of original M-R
	(POPJ-EQUAL M-D (A-CONSTANT 31.))
	((M-1) M-R)
	((M-2) ADD M-J (A-CONSTANT 1))
	(JUMP-XCT-NEXT UN-CONS)			;Tail recursive call
       ((M-R) A-V-NIL)				;clear pointer to possible garbage

;;We come here in the case where QHAT was 1 too large, we must add divisor back into
;; dividend once.
BDIV-ONCE-IN-716MILLION
	((M-A) (A-CONSTANT 1))			;steps through M-R
	((M-B) SUB M-E A-J)
	((M-B) ADD M-B (A-CONSTANT 1))		;steps through M-Q
	((M-ZR) A-ZERO)				;carry
BDIV-ONCE-IN-716MILLION-1
	((VMA-START-READ) ADD M-R A-A)
	(CHECK-PAGE-READ)
	((M-4) ADD MD A-ZR)
	((VMA-START-READ) ADD M-Q A-B)
	(CHECK-PAGE-READ)
	((M-4) ADD MD A-4)
	((M-ZR) (BYTE-FIELD 1 31.) M-4 A-ZERO)
	((MD-START-WRITE) (BYTE-FIELD 31. 0) M-4 A-ZERO)
	(CHECK-PAGE-WRITE)
	((M-A) ADD M-A (A-CONSTANT 1))
	(JUMP-LESS-THAN-XCT-NEXT M-B A-E BDIV-ONCE-IN-716MILLION-1)
       ((M-B) ADD M-B (A-CONSTANT 1))
	((MD) A-ZERO)		;Keep remainder correct.
	((VMA-START-WRITE) ADD M-Q A-B)
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT (M-1) SUB M-1 (A-CONSTANT 1))	;decrement QHAT
       (NO-OP)

;;; Set up args for the below from shift in M-1
BDIV-NORMALIZE-ENCODE-SHIFT
	((M-TEM) SUB (M-CONSTANT 32.) A-1)	;MROT = 32. - Haulong
	((M-K) SUB M-TEM (A-CONSTANT 2))	;BYTL-1 = 30. - Haulong
	((M-K) DPB M-K OAL-BYTL-1 A-TEM)	;M-K constant for LDBing
	((M-TEM) SUB M-TEM (A-CONSTANT 1))	;MROT = 31. -Haulong
	(POPJ-AFTER-NEXT
	 (M-S) SUB M-1 (A-CONSTANT 1))		;BYTL-1 = Haulong - 1
       ((M-S) DPB M-S OAL-BYTL-1 A-TEM)	;M-S constant for DPBing

;;; Subroutine for normalizing bignums:
;;; Does a left shift using M-K to ldb from C(M-B + M-ZR) into M-2 and stored at
;;; (M-D + A-ZR + 1 + M-E), and then dpb using M-S from C(M-B + M-ZR) into M-2 for the
;;; next time around:
;;;
;;;	|0| X |  Y  |	becomes:	|0|  Y  |   |  ;left in M-2 for next round.
;;;	|0|   |     |			|0|     | X |  ;written out with high half
;;;						       ; from last round.
;;;
;;; M-4 is bashed. M-2 can be loaded with whatever you want in the high part of the
;;; first word written (at M-D + M-ZR + 1 + M-E), you also load M-ZR
;;;Note that M-E is an offset in words to shift the bignum, that many words of zeros
;;; will be placed in the low bits of the bignum in M-D.
;;;This is crocked to work if M-E is 0, but not if it is negative!
;;;-1 in M-E causes the bottom word of the bignum in M-D to disappear (for ASH)
BDIV-NORMALIZE
	(JUMP-EQUAL M-ZR A-ZERO BDIV-NORMALIZE-0)
	((VMA-START-READ) ADD M-B A-ZR)
	(CHECK-PAGE-READ)
	((OA-REG-LOW) M-K)
	((M-4) (BYTE-FIELD 0 0) MD A-2)
	((OA-REG-LOW) M-S)
	((M-2) DPB MD (BYTE-FIELD 0 0) A-ZERO)
	((MD) M-4)
	((M-4) ADD M-ZR A-E)
	((VMA-START-WRITE) M+A+1 M-D A-4)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-ZR (A-CONSTANT 1) BDIV-NORMALIZE)
       ((M-ZR) SUB M-ZR (A-CONSTANT 1))
BDIV-NORMALIZE-0
	(POPJ-LESS-THAN M-E A-ZERO)
	((MD) M-2)
	((VMA-START-WRITE) M+A+1 M-D A-E)
       	(CHECK-PAGE-WRITE)
	(POPJ-EQUAL M-E A-ZERO)
	((MD) A-ZERO)
BDIV-NORMALIZE-1
	((VMA-START-WRITE) ADD M-D A-E)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-E (A-CONSTANT 1) BDIV-NORMALIZE-1)
       ((M-E) SUB M-E (A-CONSTANT 1))
	(POPJ)

ARITH-FIX-BIG
	((M-2) M-1)	;UNPACKED FIXNUM ARG
	((M-Q) M-T)	;BIGNUM ITSELF (SECOND ARG)
	((M-C) M-D)	;BIGNUM HEADER
	(DISPATCH-XCT-NEXT (BYTE-FIELD 4 0) M-A D-FIXNUM-BIGNUM-OPS)
       ((M-I) M-J)      ;BIGNUM LENGTH

(LOCALITY D-MEM)
;FIXNUM IN BOTH M-1, M-2.  BIGNUM IN BOTH M-Q, M-T.  HEADER IN M-C, M-D.  LENGTH IN M-I, M-J.
(START-DISPATCH 4 0)
D-FIXNUM-BIGNUM-OPS
	(FXBADD)
	(FXBSUB)
	(FXBMPY)
	(FXBDIV)
	(XFALSE)			;Fixnum = Bignum ???
	(FXBGRP)
	(FXBLSP)
	(FXBMIN)
	(FXBMAX)
	(FXBBOOLE)
 (REPEAT NUM-UNUSED-ARITH-2ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

ARITH-BIG-FIX
	(DISPATCH-XCT-NEXT (BYTE-FIELD 4 0) M-A D-BIGNUM-FIXNUM-OPS)
       (NO-OP)

(LOCALITY D-MEM)
;FIXNUM IN M-T, UNPACKED INTO M-2.
;BIGNUM IN M-Q, HEADER IN M-C, LENGTH IN M-I.
(START-DISPATCH 4 0)
D-BIGNUM-FIXNUM-OPS
	(BFXADD)
	(BFXSUB)
	(BFXMPY)
	(BFXDIV)
	(XFALSE)			;Bignum = Fixnum ???
	(BFXGRP)
	(BFXLSP)
	(BFXMIN)
	(BFXMAX)
	(BFXBOOLE)
 (REPEAT NUM-UNUSED-ARITH-2ARGS (P-BIT INHIBIT-XCT-NEXT-BIT ILLOP))
(END-DISPATCH)
(LOCALITY I-MEM)

FXBSUB	(JUMP-XCT-NEXT FXBADD0)
       ((M-C) XOR M-C (A-CONSTANT (BYTE-VALUE BIGNUM-HEADER-SIGN 1)))

FXBRETQ	(POPJ-AFTER-NEXT	;RETURN BIGNUM ARG.
	 (M-T) Q-TYPED-POINTER M-Q)
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE   ;LEAVE RESULT BOTH PLACES
			 (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))  ;FOR GOOD MEASURE.

BFXSUB	((M-2) SUB M-ZERO A-2)	;NO SETZ PROBLEMS!
BFXADD 
FXBADD	(JUMP-EQUAL M-2 A-ZERO FXBRETQ)  ;SPECIAL CASE IF ADDING ZERO, JUST RETURN OTHER GUY
FXBADD0	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-2 A-ZERO BFXADD-1)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
	((M-2) SUB M-ZERO A-2)			;Make positive
	(JUMP-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BFXADD-ADD)
BFXADD-SUB	;M-Q/M-I bignum, M-2 positive number to be subtracted
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 1))
	((M-D) M-I)
	((M-B) (A-CONSTANT 1))
	(JUMP-XCT-NEXT BSUB-C)
       ((M-E) (A-CONSTANT 1))

BFXADD-1
	(JUMP-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BFXADD-SUB)
BFXADD-ADD	;M-Q/M-I bignum, M-2 positive number to be added
	(CALL-XCT-NEXT BNCONS)			;ALLOCATE IN STRUCTURE EXTRA-PDL
       ((M-B) ADD M-I (A-CONSTANT 2))
	((M-I) ADD M-I (A-CONSTANT 1))
	((M-R) M-Q)
	((M-J) SUB M-I (A-CONSTANT 1)) ;Recover length of bignum in M-Q (M-R)
	(JUMP-XCT-NEXT BADD5)
       ((M-D) (A-CONSTANT 1))

BIGNUM-ADD1
	(JUMP-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-C BFXADD-ADD)
       ((M-2) (A-CONSTANT 1))
	(JUMP BFXADD-SUB)

BIGNUM-SUB1
	(JUMP-IF-BIT-CLEAR-XCT-NEXT BIGNUM-HEADER-SIGN M-C BFXADD-SUB)
       ((M-2) (A-CONSTANT 1))
	(JUMP BFXADD-ADD)

RETURN-ZERO
	(POPJ-AFTER-NEXT (M-T C-PDL-BUFFER-POINTER-PUSH)
		(A-CONSTANT (PLUS (BYTE-VALUE Q-CDR-CODE CDR-NEXT)
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
       (NO-OP)

;; A fixnum multiplied by a bignum can yield a fixnum in just two cases(!):
BFXMPY 
FXBMPY	(JUMP-EQUAL M-2 A-ZERO RETURN-ZERO)	;0*X=0
	(JUMP-NOT-EQUAL M-2 A-MINUS-ONE BFXMPY-OK)	;(-1)*(+SETZ)=(-SETZ)
	(JUMP-NOT-EQUAL M-I (A-CONSTANT 1) BFXMPY-OK)
	((VMA-START-READ) ADD M-Q A-I)
	(CHECK-PAGE-READ)
	(JUMP-NOT-EQUAL MD (A-CONSTANT MINIMUM-FIXNUM) BFXMPY-OK)
	(POPJ-AFTER-NEXT (M-T C-PDL-BUFFER-POINTER-PUSH)
		Q-POINTER MD (A-CONSTANT (PLUS (BYTE-VALUE Q-CDR-CODE CDR-NEXT)
					       (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
       (NO-OP)

BFXMPY-OK
	(JUMP-GREATER-OR-EQUAL M-2 A-ZERO BFXMPY-1)
	((M-2) SUB M-ZERO A-2)			;NEGATIVE FIXNUM, CHANGE SIGN OF RESULT
	((M-C) XOR M-C (A-CONSTANT (BYTE-VALUE BIGNUM-HEADER-SIGN 1)))
BFXMPY-1
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 2))
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-ALL-BUT-CDR-CODE 
					 (A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NEXT)))
	(CALL-XCT-NEXT MULTIPLY-ONCE)
       ((M-1) A-ZERO)
	((MD) M-1)
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(POPJ-NOT-EQUAL M-1 A-ZERO)
	((M-C) SUB M-C (A-CONSTANT 1))
	((MD) ADD M-C (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE)
	((M-1) ADD M-T A-D)
	(JUMP-XCT-NEXT UN-CONS)
       ((M-2) (A-CONSTANT 1))

;; MULTIPLY-ONCE multiplies a bignum in M-Q,M-I by a fixnum in M-2 and adds the fixnum in M-1.
;; Writes answer M-T (as if it is a bignum). Leaves last word (not written) in M-1.
;; Bashes M-D to be M-I + 1
MULTIPLY-ONCE
	((M-D) (A-CONSTANT 1))
BFXMPY-LOOP
	((VMA-START-READ) ADD M-Q A-D)
	(CHECK-PAGE-READ)
	((Q-R) MD)
(REPEAT 31. ((M-1) MULTIPLY-STEP M-1 A-2))
	((M-1) (BYTE-FIELD 31. 0) M-1)
	((MD) (BYTE-FIELD 31. 1) Q-R)
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-D A-I BFXMPY-LOOP)
       ((M-D) ADD M-D (A-CONSTANT 1))
	(POPJ)

BFXDIV
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC M-T-TO-CPDL)))
	(CALL-EQUAL M-2 A-ZERO TRAP)
		(ERROR-TABLE DIVIDE-BY-ZERO)
	(JUMP-GREATER-THAN M-2 A-ZERO BFXDIV-1)
	((M-C) XOR M-C (A-CONSTANT (BYTE-VALUE BIGNUM-HEADER-SIGN 1)))	;If fixnum is negative
	((M-2) SUB M-ZERO A-2)	;then change sign of both args.
BFXDIV-1
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 1))
	((M-R) M-T)
	(CALL-XCT-NEXT DIVIDE-ONCE)	;divide once stores into bignum in M-R,M-J
       ((M-J) M-I)
	((M-D) M-I)		;current length
	((VMA-START-READ) ADD M-T A-D)	;read last word to see if it is zeros
	(CHECK-PAGE-READ)
	(JUMP-NOT-EQUAL-XCT-NEXT MD A-ZERO BCLEANUP)	;not zeros
       ((M-E) M-D)
	(JUMP-XCT-NEXT BCLEANUP)	;zeros so length should be M-D - 1
       ((M-E) SUB M-E (A-CONSTANT 1))

;; DIVIDE-ONCE divides bignum in M-Q,M-I by positive(!) number in M-2.
;; bashes M-1 M-3 M-TEM M-D
;; answer is stored in M-R,M-J
;; remainder is left in M-1
DIVIDE-ONCE
	((M-1) A-ZERO)
	((M-3) (A-CONSTANT 1))
	((M-D) M-I)
DIVIDE-ONCE-L
	((VMA-START-READ) ADD M-Q A-D)
	(CHECK-PAGE-READ)
	((M-TEM) DPB M-3 (BYTE-FIELD 30. 1) A-ZERO)
	((A-TEM1) DPB MD (BYTE-FIELD 31. 1) A-3)
	((Q-R) A-TEM1)
(REPEAT 31. ((M-1) DIVIDE-STEP M-1 A-2))
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-D A-J DIVIDE-ONCE-1)
       ((M-3) Q-R)			;Save Q-R which is bashed by page faults
	((MD) (BYTE-FIELD 1 30.) Q-R A-TEM)
	((VMA-START-WRITE) M+A+1 M-R A-D)
	(CHECK-PAGE-WRITE)
DIVIDE-ONCE-1
	(JUMP-GREATER-THAN-XCT-NEXT M-D (A-CONSTANT 1) DIVIDE-ONCE-L)
       ((M-D) SUB M-D (A-CONSTANT 1))
	((Q-R) M-3)
	((M-1) DIVIDE-LAST-STEP M-1 A-2)
	((M-1) DIVIDE-REMAINDER-CORRECTION-STEP M-1 A-2)
	((MD) (BYTE-FIELD 31. 0) Q-R)
	(POPJ-AFTER-NEXT (VMA-START-WRITE) ADD M-R (A-CONSTANT 1))
       (CHECK-PAGE-WRITE)

;Fixnum divided by bignum is 0 except for -setz over +setz which is -1
FXBDIV
	(POPJ-NOT-EQUAL-XCT-NEXT M-2 (A-CONSTANT (PLUS (BYTE-MASK Q-ALL-BUT-POINTER)
						       MINIMUM-FIXNUM))) ;Sign extended setz
       ((M-T C-PDL-BUFFER-POINTER-PUSH) (A-CONSTANT (PLUS (BYTE-VALUE Q-CDR-CODE CDR-NEXT)
							  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
	(POPJ-IF-BIT-SET BIGNUM-HEADER-SIGN M-C)
	(POPJ-NOT-EQUAL M-I (A-CONSTANT 1))
	((VMA-START-READ) ADD M-Q (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(POPJ-AFTER-NEXT POPJ-NOT-EQUAL MD (A-CONSTANT MINIMUM-FIXNUM))
       ((M-T C-PDL-BUFFER-POINTER) DPB M-MINUS-ONE Q-POINTER A-T)

BFXGRP 
FXBLSP
	((M-T) A-V-NIL)
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET BIGNUM-HEADER-SIGN M-C)
       ((M-T) A-V-TRUE)

BFXLSP 
FXBGRP
	((M-T) A-V-TRUE)
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET BIGNUM-HEADER-SIGN M-C)
       ((M-T) A-V-NIL)

BFXMIN 
FXBMIN
	((M-T) M-Q)			;neg. bignums are less than fixnums!
	(POPJ-AFTER-NEXT POPJ-IF-BIT-SET BIGNUM-HEADER-SIGN M-C)
       ((M-T) DPB M-2 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	
BFXMAX 
FXBMAX
	((M-T) M-Q)			;positive bignums are greater than fixnums!
	(POPJ-AFTER-NEXT POPJ-IF-BIT-CLEAR BIGNUM-HEADER-SIGN M-C)
       ((M-T) DPB M-2 Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))


;; First arg a bignum second a fixnum.  The bignum is expressed in the base of the fixnum
;; and stuffed in to an appropriate art-q array.
(MISC-INST-ENTRY BIGNUM-TO-ARRAY)
BIG-TO-ARY
	((M-A) C-PDL-BUFFER-POINTER-POP)
	((M-Q) C-PDL-BUFFER-POINTER-POP)
	((M-TEM) Q-DATA-TYPE M-Q)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-EXTENDED-NUMBER)) TRAP)
		(ERROR-TABLE ARGTYP BIGNUM M-Q 0)
	((VMA-START-READ) M-Q)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-HEADER READ-MEMORY-DATA)
	((M-Q) VMA)		;get transported number address 
	((M-TEM) HEADER-TYPE-FIELD MD)
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL %HEADER-TYPE-BIGNUM)) TRAP)
		(ERROR-TABLE ARGTYP BIGNUM M-Q 0)
	((M-I) BIGNUM-HEADER-LENGTH MD)
	(DISPATCH Q-DATA-TYPE M-A TRAP-UNLESS-FIXNUM)
		(ERROR-TABLE ARGTYP POSITIVE-FIXNUM M-A 1)
	((M-1) Q-POINTER M-A)
	(CALL-LESS-OR-EQUAL M-1 A-ZERO TRAP)
		(ERROR-TABLE ARGTYP POSITIVE-FIXNUM M-A 1)
	(CALL-XCT-NEXT XHAUL1)	;M-T gets number of bits in M-A LESS ONE(!)
       ((M-T) A-MINUS-ONE)
	;; we must allocate an array at least 31*I/T long
	;; 31*I = 32*I - I
	((M-1) DPB M-I (BYTE-FIELD 18. 5) A-ZERO)
	((M-1) SUB M-1 A-I)
	(CALL-XCT-NEXT DIV)
       ((M-2) Q-POINTER M-T)
	(JUMP-EQUAL-XCT-NEXT M-1 A-ZERO BIG-TO-ARY-1)	;If no remainder then we are o.k.
       ((M-C) Q-R)
	((M-C) ADD M-C (A-CONSTANT 1))	;with remainder then allocate 1 more
BIG-TO-ARY-1
	((M-S) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF)
	(CALL-XCT-NEXT SCONS)	;Allocate space for art-q array
       ((M-B) ADD M-C (A-CONSTANT 2))
	((MD) (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-HEADER)
				(BYTE-VALUE %%ARRAY-NUMBER-DIMENSIONS 1)
				(BYTE-VALUE %%ARRAY-LONG-LENGTH-FLAG 1)
				(EVAL ART-Q))))
	((VMA-START-WRITE M-R) Q-POINTER M-T
			       (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-POINTER)))
	(CHECK-PAGE-WRITE)
	((MD) Q-POINTER M-C (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD M-R (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	;; now we have the array in M-R with length in M-C
	;; we must now allocate a bignum to divide into.
	(CALL-XCT-NEXT SCONS-T)
       ((M-B) ADD M-I (A-CONSTANT 1))
	((MD) ADD M-I (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE M-T) Q-POINTER M-T
			       (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-EXTENDED-NUMBER)))
	(CHECK-PAGE-WRITE)
	;; now we have a (temp.) bignum in M-T so we start to divide
	((M-E) M-R)		;move the array into M-E
	((M-B) M-I)		;save length of bignum
	((M-2) Q-POINTER M-A)	;fixnum to divide by
	((M-A) (A-CONSTANT 1))	;index+1 into array
	((M-R) M-T)
	(CALL-XCT-NEXT DIVIDE-ONCE)
       ((M-J) M-I)
	((M-Q) M-R)		;from now on we divide from the temp bignum to itself.
BIG-TO-ARY-L
	((MD) Q-POINTER M-1 (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) M+A+1 M-E A-A)	;write remainder.
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) ADD M-R A-J)	;Check to see if last word of quotient was zero.
	(CHECK-PAGE-READ)
	(JUMP-NOT-EQUAL MD A-ZERO BIG-TO-ARY-2)
	(JUMP-EQUAL M-I (A-CONSTANT 1) BIG-TO-ARY-CLEANUP)	;bignum is zero, done
	((M-I) SUB M-I (A-CONSTANT 1))	;pretend bignum is shorter
BIG-TO-ARY-2
	(CALL-XCT-NEXT DIVIDE-ONCE)
       ((M-J) M-I)
	(JUMP-XCT-NEXT BIG-TO-ARY-L)
       ((M-A) ADD M-A (A-CONSTANT 1))

BIG-TO-ARY-CLEANUP
	((M-T) M-E)		;array to return
	((M-1) M-R)
	((M-D) M-A)		;M-A smashed by UN-CONS
	(CALL-XCT-NEXT UN-CONS)	;Give back the bignum
       ((M-2) ADD M-B (A-CONSTANT 1))
	(POPJ-EQUAL M-C A-D)	;all array used so return it!
	;; else give back unused end of array
	((MD) Q-POINTER M-D (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE M-1) ADD M-T (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	((M-1) M+A+1 M-1 A-D)
	(JUMP-XCT-NEXT UN-CONS)	;tail recursive call
       ((M-2) SUB M-C A-D)

;; First arg a art-q array second a fixnum third the sign bit (zero or one).
;; Returns a bignum. Inverse of BIGNUM-TO-ARRAY
(MISC-INST-ENTRY ARRAY-TO-BIGNUM)
ARY-TO-BIG
	((M-C) C-PDL-BUFFER-POINTER-POP)	;sign bit.
	((M-J) C-PDL-BUFFER-POINTER-POP)	;fixnum.
	(DISPATCH Q-DATA-TYPE M-C TRAP-UNLESS-FIXNUM)
		(ERROR-TABLE ARGTYP FIXNUM M-C 2)
	((M-C) DPB M-C BIGNUM-HEADER-SIGN A-ZERO)
	(DISPATCH Q-DATA-TYPE M-J TRAP-UNLESS-FIXNUM)
		(ERROR-TABLE ARGTYP FIXNUM M-J 1)
	(CALL-XCT-NEXT GAHDRA)			;array.
       ((M-J) Q-POINTER M-J)
	(CALL-IF-BIT-SET (LISP-BYTE %%ARRAY-DISPLACED-BIT) M-B TRAP)
		(ERROR-TABLE WRONG-TYPE-ARRAY M-A)
	((M-B) SELECTIVE-DEPOSIT M-B (LISP-BYTE %%ARRAY-TYPE-FIELD) A-ZERO)
	(CALL-NOT-EQUAL M-B (A-CONSTANT (EVAL ART-Q)) TRAP)
		(ERROR-TABLE WRONG-TYPE-ARRAY M-A)
	(CALL-NOT-EQUAL M-D (A-CONSTANT 1) TRAP)
		(ERROR-TABLE ARRAY-NUMBER-DIMENSIONS M-D 1)
	;; now we have the array in M-A (origin in M-E, length in M-S)
	;; sign bit in correct spot in M-C
	;; fixnum in M-J (unboxed)
	((M-T) A-ZERO)
	(CALL-XCT-NEXT XHAUL1)			;Get # bits per array element
       ((M-1) M-J)
	((M-1) M-T)				;Size of bignum in bits
	(CALL-XCT-NEXT MPY)
       ((Q-R) M-S)
	(CALL-NOT-EQUAL M-2 A-ZERO TRAP)
		(ERROR-TABLE OVERFLOW)
	((M-1) Q-R)
	(CALL-XCT-NEXT DIV)			;Get size of bignum in words
       ((M-2) (A-CONSTANT 31.))
	((M-I) ADD Q-R (A-CONSTANT 1))
	;; we have now computed the amount of space to allocate for the bignum.
	;; The formula is I := 1+(haulong J)*S/31.
	((M-R) M-E)		;shuffle (origin of array)
	((M-D) M-S)		;suuffle (length of array)
	(CALL-XCT-NEXT BNCONS)
       ((M-B) ADD M-I (A-CONSTANT 1))
	((M-S) M-D)		;unshuffle (length of array)
	((M-2) M-J)		;"radix"
	;; now we have the array in M-A (origin in M-R length in M-S),
	;; we have the fixnum in M-2, we have the bignum in M-T (header in M-C, length in M-I)
	;; first we must zero the bignum.
	((M-D) (A-CONSTANT 1))
	((MD) A-ZERO)
ARY-TO-BIG-2
	((VMA-START-WRITE) ADD M-T A-D)
	(CHECK-PAGE-WRITE)
	(JUMP-LESS-THAN-XCT-NEXT M-D A-I ARY-TO-BIG-2)
       ((M-D) ADD M-D (A-CONSTANT 1))
	((M-Q) M-T)		;copy in M-Q
	;; now we start:
	((M-S) SUB M-S (A-CONSTANT 1))
ARY-TO-BIG-L
	((VMA-START-READ) ADD M-R A-S)
	(CHECK-PAGE-READ)
	(CALL-XCT-NEXT MULTIPLY-ONCE)
       ((M-1) Q-POINTER MD)
	(CALL-NOT-EQUAL M-1 A-ZERO ILLOP)	;overflow (should never happen)
	(JUMP-GREATER-THAN-XCT-NEXT M-S A-ZERO ARY-TO-BIG-L)
       ((M-S) SUB M-S (A-CONSTANT 1))
	;; now we see how many zeros we have at the end
BIGNUM-DPB-CLEANUP	;enters here with bignum in M-T, header in M-C
	((M-E) BIGNUM-HEADER-LENGTH M-C)
	((M-D) BIGNUM-HEADER-LENGTH M-C)
ARY-TO-BIG-CLEANUP
	((VMA-START-READ) ADD M-T A-E)
	(CHECK-PAGE-READ)
	(JUMP-NOT-EQUAL MD A-ZERO BCLEANUP)
	(JUMP-GREATER-THAN-XCT-NEXT M-E (A-CONSTANT 1) ARY-TO-BIG-CLEANUP)
       ((M-E) SUB M-E (A-CONSTANT 1))
	;; Number is nothing but sign bits
	((OA-REG-HIGH) BIGNUM-HEADER-SIGN M-C)
	((M-TEM) M-ZERO)
	((M-1) Q-POINTER M-T)				;For UN-CONS
	(JUMP-XCT-NEXT BCLEANUP-1)
       ((M-2) ADD M-D (A-CONSTANT 1))

;; Clean up and return a bignum in M-T. Hands back storage and checks for fixnums.
;; Bignum in M-T, header in M-C, length in M-D, actual length in M-E (# of non-zero words).
BCLEANUP
	(JUMP-GREATER-THAN M-E (A-CONSTANT 1) BCLEANUP-X)  ;Could answer be a fixnum?
	((VMA-START-READ) ADD M-T (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-1) Q-POINTER M-T)				;For UN-CONS
	((M-2) ADD M-D (A-CONSTANT 1))
	((M-A) (BYTE-FIELD 9. 23.) MD)			;All but 23 low bits
	(JUMP-NOT-EQUAL-XCT-NEXT M-A A-ZERO BCLEANUP-SETZP)	;no. (unless it is SETZ)
       ((M-TEM) MD)
	(JUMP-IF-BIT-CLEAR BIGNUM-HEADER-SIGN M-C BCLEANUP-1)
	((M-TEM) SUB M-ZERO A-TEM)				;Its negative.
BCLEANUP-1
	(JUMP-XCT-NEXT UN-CONS)
       ((M-T) Q-POINTER M-TEM (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

BCLEANUP-SETZP
	(JUMP-NOT-EQUAL M-TEM (A-CONSTANT MINIMUM-FIXNUM) BCLEANUP-X)	;Is it setz?
	(JUMP-IF-BIT-SET BIGNUM-HEADER-SIGN M-C BCLEANUP-1)
BCLEANUP-X
	(POPJ-EQUAL M-D A-E)
	((M-2) SUB M-D A-E)			;Number of unused words at end
	((M-C) SUB M-C A-2)			;Fix the header
	((MD) ADD M-C (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER)
					(BYTE-VALUE HEADER-TYPE-FIELD %HEADER-TYPE-BIGNUM))))
	((VMA-START-WRITE M-1) Q-POINTER M-T)
	(CHECK-PAGE-WRITE)
	((M-1) M+A+1 M-1 A-E)
;; FALLS THROUGH

;; Takes a pointer to a block of words to free up in M-1, the number of words in M-2.
;; This only works for structure space.
;; Smashes M-A,M-B,M-E,M-TEM,M-2. M-1 preserved. NO SEQUENCE BREAKS TAKEN.

UN-CONS	(POPJ-EQUAL M-2 A-ZERO)
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;Protect M-T through this routine
	(CALL-XCT-NEXT XRGN00)			;Get region number from M-1 in M-T
       ((M-A MD) Q-POINTER M-1)
	((M-TEM) Q-POINTER M-T)
	(JUMP-NOT-EQUAL M-TEM A-SCAV-REGION UN-CONS-0)
	((A-SCAV-COUNT) (A-CONSTANT 0))		;Make scavenger forget this region
UN-CONS-0
	((VMA-START-READ) ADD M-T A-V-REGION-ORIGIN)
	(CHECK-PAGE-READ)
	((M-E) ADD M-A A-2)			;M-E gets where free pointer should be
	((M-A) MD)				;M-A gets region origin
	((VMA-START-READ) ADD M-T A-V-REGION-FREE-POINTER)
	(CHECK-PAGE-READ)
	((M-E) Q-POINTER M-E)
	((M-TEM) ADD MD A-A)			;M-TEM gets actual free pointer
	((M-TEM) Q-POINTER M-TEM)
	(JUMP-NOT-EQUAL M-TEM A-E UN-CONS-FILL)	;Something else got allocated, don't mess
	((MD-START-WRITE) SUB MD A-2)		;Decrement free pointer.
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) ADD M-T A-V-REGION-GC-POINTER)	;back up scav pointer if necc
	(CHECK-PAGE-READ)
	((M-TEM) SUB M-ZERO A-2)		;Undo cons-work-done
	((A-CONS-WORK-DONE) ADD M-TEM A-CONS-WORK-DONE)
	((M-TEM) Q-POINTER READ-MEMORY-DATA)
	(POPJ-LESS-OR-EQUAL-XCT-NEXT M-TEM A-E)
       ((M-T) C-PDL-BUFFER-POINTER-POP)		;Restore M-T
	((MD-START-WRITE) SELECTIVE-DEPOSIT MD Q-ALL-BUT-POINTER A-E)
	(CHECK-PAGE-WRITE)
	(POPJ)	;NO POPJ-AFTER-NEXT, BADD4 CAN JUMP HERE, THEN WE RETURN TO MAIN LOOP

UN-CONS-FILL
	((M-2) SUB M-2 (A-CONSTANT 1))		;M-2 gets length of array to fill with
	(CALL-GREATER-THAN M-2 (A-CONSTANT (EVAL %ARRAY-MAX-SHORT-INDEX-LENGTH)) ILLOP)
	((MD) ADD M-2 (A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-ARRAY-HEADER)
					(BYTE-VALUE %%ARRAY-NUMBER-DIMENSIONS 1)
					(EVAL ART-32B))))
	((VMA-START-WRITE) M-1)		;NO POPJ-AFTER-NEXT, SEE ABOVE
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT (M-T) C-PDL-BUFFER-POINTER-POP)	;RESTORE IT.
       (NO-OP)

;;; THE TRANSPORTER

;		"Energize!"
;		     -- J. T. Kirk
;
;THIS CAN CALL CONS BUT CANNOT SEQUENCE-BREAK.  IT WILL NOT CLOBBER ANY REGISTERS
;EXCEPT WHAT PAGE-FAULTS CLOBBER.  IF IT NEEDS TO SEQUENCE BREAK, THE BREAK WILL
;ACTUALLY BE DEFERRED SO THAT EVERYONE WHO TRANSPORTS DOESN'T HAVE TO WORRY ABOUT
;SEQUENCE BREAKS.

;GET HERE BY SPECIAL DISPATCH, THE RETURN ADDRESS ON THE MICROSTACK
;IS THE ADDRESS OF THE DISPATCH INSTRUCTION ITSELF.
;PRESENTLY, WE HAVE ONE DISPATCH TABLE AND USE I-ARG'S TO DISTINGUISH THE
;CASES.  IF IT TURNS OUT WE OUGHT TO HAVE DROPPED THROUGH, WE RETURN TO
;THE DISPATCH INSTRUCTION, OA-MODIFYING IT TO DISPATCH THROUGH LOC 3777
;WHICH FORCES IT TO DROP THROUGH.  NORMALLY, WE EITHER ERR OUT OR ALTER
;VMA AND MD AND RETURN TO RE-EXECUTE THE DISPATCH.

;Enter here if either the MD is a pointer to old-space or we have a map miss
TRANS-OLD
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 1) READ-I-ARG TRANS-DROP-THROUGH);Ignore if no-transport
TRANS-OLD0	;Enter here if forwarding-pointer, mustn't ever drop-through
	((A-TRANS-VMA) VMA)			;Save where MD came from
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-GET-MAP-BITS) ;Ensure validity of meta bits
	(POPJ-IF-BIT-SET-XCT-NEXT (LISP-BYTE %%REGION-OLDSPACE-META-BIT)
		MEMORY-MAP-DATA)		;Re-transport if was just map not set up
       ((VMA) A-TRANS-VMA)			;Restoring VMA which could have been bashed
	((VMA-START-READ) MD)			;Get word out of old space
	(CHECK-PAGE-READ)	;** Should blow out here if was really free space
	((A-TRANS-MD) VMA)			;Save pointer to old space
	(DISPATCH Q-DATA-TYPE READ-MEMORY-DATA D-TRANS-OLD)

(LOCALITY D-MEM)
;Dispatch on datatype of word fetched from old space when transporting a pointer to old-space
;Usually go to TRANS-OLD-COPY to copy the containing structure.  Check specially for
;GC-FORWARD (already copied), invisibles (snap out).
(START-DISPATCH 5 INHIBIT-XCT-NEXT-BIT)
D-TRANS-OLD
	(TRANS-OLD-COPY)	;TRAP
	(TRANS-OLD-COPY)	;NULL
	(TRANS-OLD-COPY)	;FREE
	(TRANS-OLD-COPY)	;SYMBOL
	(TRANS-OLD-COPY)	;SYMBOL-HEADER
	(TRANS-OLD-COPY)	;FIX
	(TRANS-OLD-COPY)	;EXTENDED NUMBER
	(TRANS-OLD-COPY)	;HEADER
	(TRANS-OLD-GC-FWD)	;GC-FORWARD
	(TRANS-OLD-COPY)	;EXTERNAL-VALUE-CELL-POINTER
	(TRANS-OLD-COPY)	;ONE-Q-FORWARD
	(TRANS-OLD-HDR-FWD)	;HEADER-FORWARD
	(TRANS-OLD-BODY-FWD)	;BODY-FORWARD
	(TRANS-OLD-COPY)	;LOCATIVE
	(TRANS-OLD-COPY)	;LIST
	(TRANS-OLD-COPY)	;U CODE ENTRY
	(TRANS-OLD-COPY)	;FEF
	(TRANS-OLD-COPY)	;ARRAY-POINTER
	(TRANS-OLD-COPY)	;ARRAY-HEADER
	(TRANS-OLD-COPY)	;STACK-GROUP
	(TRANS-OLD-COPY)	;CLOSURE
	(TRANS-OLD-COPY)	;SMALL-FLONUM 
	(TRANS-OLD-COPY)	;SELECT-METHOD
	(TRANS-OLD-COPY)	;INSTANCE
	(TRANS-OLD-COPY)	;INSTANCE-HEADER
	(TRANS-OLD-COPY)	;ENTITY
 (REPEAT NQZUSD (TRANS-OLD-COPY))
(END-DISPATCH)
(LOCALITY I-MEM)

;;; Copy object found in oldspace
TRANS-OLD-COPY
	((C-PDL-BUFFER-POINTER-PUSH) M-A)	;Protect regs used by XARN
	((C-PDL-BUFFER-POINTER-PUSH) M-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	(CALL-XCT-NEXT XARN)			;M-T gets area# object is in
       ((C-PDL-BUFFER-POINTER-PUSH) A-TRANS-MD)
	((M-TEM) M-T)				;Allocate new copy in same area
	((M-T) C-PDL-BUFFER-POINTER-POP)	;Restore registers
	((M-B) C-PDL-BUFFER-POINTER-POP)
	((M-A) C-PDL-BUFFER-POINTER-POP)
	(CALL-XCT-NEXT TRANS-COPY)		;Make new copy
       ((A-TRANS-COPY-FWD-DTP)
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-GC-FORWARD)
				  (BYTE-VALUE Q-CDR-CODE CDR-ERROR))))
	(POPJ-AFTER-NEXT (VMA-START-WRITE) A-TRANS-VMA)	;Replace oldspace ptr with newspace ptr
       (CHECK-PAGE-WRITE-FORCE)			;and transport again

;DTP-BODY-FORWARD in old space.  Must find header, find new copy, and snap out.
TRANS-OLD-BODY-FWD
	((VMA-START-READ) MD)			;Pick up the DTP-HEADER-FORWARD
	(CHECK-PAGE-READ)
	((A-TRANS-TEM) SUB VMA A-TRANS-MD)	;Offset from particular Q to header
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;Consistency check
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER-FORWARD)) ILLOP)
	((MD) SUB READ-MEMORY-DATA A-TRANS-TEM)	;MD gets address of new copy of Q
						;Drops through
;DTP-GC-FORWARD in old space.  Take what it points to.
TRANS-OLD-GC-FWD
	((MD) Q-POINTER MD A-TRANS-MD)		;Combine new pointer with old tag
	(POPJ-AFTER-NEXT (VMA-START-WRITE) A-TRANS-VMA)	;Snap it out
       (CHECK-PAGE-WRITE-FORCE)			;and transport again

;DTP-HEADER-FORWARD in old space.  In structure space, just snap it out.
;Then transport again in case it pointed to oldspace.
;In list space, header-forward is something else entirely, namely
;rplacd-forwarding pointer.  We ignore the header-forward and do
;the usual copying operation, which will handle the header-forward suitably.
TRANS-OLD-HDR-FWD
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-GET-MAP-BITS) ;Meta bits for new copy
	(DISPATCH (LISP-BYTE %%REGION-REPRESENTATION-TYPE)
		MEMORY-MAP-DATA D-TRANS-OLD-HDR-FWD)

(LOCALITY D-MEM)
(START-DISPATCH 2 INHIBIT-XCT-NEXT-BIT)
D-TRANS-OLD-HDR-FWD
	(TRANS-OLD-COPY)	;0 list
	(TRANS-OLD-GC-FWD)	;1 structure
(REPEAT 2 (P-BIT ILLOP))	;2, 3 not used
(END-DISPATCH)
(LOCALITY I-MEM)

;Enter here for trapping data type.  If it points to old-space, and
;this is not an inum-type (DTP-NULL), will have already been
;transported.  If going to write, we ignore it, otherwise we trap anyway.
TRANS-TRAP
	(CALL-IF-BIT-CLEAR (BYTE-FIELD 1 4) READ-I-ARG TRAP)	;BARF IF READING RANDOM DATA
  (ERROR-TABLE TRANS-TRAP) ;This is a special entry, which the EH knows all about.
;Return to caller, causing dispatch to drop through by OA-modifying it.
;Assume that VMA and MD haven't been modified, or have been saved and restored.
TRANS-DROP-THROUGH	
	(POPJ-AFTER-NEXT NO-OP)
       ((OA-REG-LOW) DPB (M-CONSTANT -1) OAL-DISP A-ZERO)	;FORCE DISP TO LOC 3777

;Enter here if external-value-cell-pointer to old-space.
;If supposed to invz, transport first.  Otherwise, transport
;unless don't-transport bit is set.
TRANS-OLDP-EVCP
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 1) READ-I-ARG TRANS-OLD0) ;Transport if supposed to.
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) READ-I-ARG TRANS-OLD0) ;Transport first, if must invz
	;Drop into TRANS-EVCP if either going to drop-through and no transp desired,
	;or if going to ILLOP
;Enter here for external-value-cell-pointer to newspace.
TRANS-EVCP
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 0) READ-I-ARG TRANS-INVZ) ;JUMP IF EVCP SHOULD INVZ
	(JUMP-XCT-NEXT TRANS-DROP-THROUGH)	;SHOULDN'T INVZ, GO SIMULATE DROP THROUGH
       (CALL-IF-BIT-SET (BYTE-FIELD 1 2) READ-I-ARG ILLOP)	;BARF IF TRANSPORT-HEADER

;Enter here for one-q-forward.  Already transported if was old-space.
TRANS-OQF
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 3) READ-I-ARG TRANS-DROP-THROUGH) ;IGNORE OQF IF JUST
	(JUMP-XCT-NEXT TRANS-INVZ)					 ;CHECKING CDR CODE
       (CALL-IF-BIT-SET (BYTE-FIELD 1 2) READ-I-ARG ILLOP)	;BARF IF TRANSPORT-HEADER

;Enter here for DTP-BODY-FORWARD, always forwards, but must "go around" through header
TRANS-BFWD	
	((A-TRANS-VMA) VMA)			;REMEMBER WHERE ORIGINAL REFERENCE WAS
	((VMA-START-READ) DPB READ-MEMORY-DATA	;PICK UP DTP-HEADER-FORWARD FROM OLD HEADER
		Q-POINTER A-TRANS-VMA)		;DON'T CHANGE DATA TYPE OF VMA
	(CHECK-PAGE-READ)
	((A-TEM1) SUB VMA A-TRANS-VMA)		;MINUS OFFSET FROM HEADER TO DATA
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;THESE 2 INSTRUCTIONS ARE JUST A RANDOMNESS
	(CALL-NOT-EQUAL M-TEM (A-CONSTANT (EVAL DTP-HEADER-FORWARD)) ILLOP)	; CHECK
	((M-TEM) SUB READ-MEMORY-DATA A-TEM1)	;GET ADDRESS RELOCATED TO
	(POPJ-AFTER-NEXT			;REFERENCE THAT ADDRESS, VMA DATATYPE UNCHANGED
	 (VMA-START-READ) SELECTIVE-DEPOSIT VMA Q-DATA-TYPE A-TEM)
       (CHECK-PAGE-READ)

;Enter here for DTP-HEADER-FORWARD pointer, always forwards.
;Already transported if was old-space.
TRANS-HFWD	
;Chase forwarding pointer, restart cycle
TRANS-INVZ	
	((A-TEM1) READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT
	 (VMA-START-READ) SELECTIVE-DEPOSIT VMA		;RETAIN DATA TYPE,
			 Q-DATA-TYPE A-TEM1)		;ALTER POINTER
       (CHECK-PAGE-READ)

;;; Routine to copy what A-TRANS-MD points to into area in M-TEM.
;;; Returns with MD pointing to copy.  Leaves forwarding pointers behind,
;;; whose data-type and cdr code come from A-TRANS-COPY-FWD-DTP
;;; Note that cdr-code of the GC-forwarding pointer must be cdr-error,
;;; to avoid faking out XFSHL.
;;; Used by the transporter and the extra-pdl copier.
;;; In list space, we have to worry about complicated dealings with rplacd-forwards
;;; Can't save registers in the pdl buffer since might be called from XFLIPW
;;; and might decide to clobber the registers with GC-forwarding pointers.
TRANS-COPY
	((M-TRANSPORT-FLAG) DPB (M-CONSTANT -1) A-FLAGS) ;No sequence break out of CONS!
	((A-TRANS-SAVE-A) M-A)			;Save regs bashed by CONS, FSH
	((A-TRANS-SAVE-B) M-B)
	((A-TRANS-SAVE-E) M-E)
	((A-TRANS-SAVE-K) M-K)
	((A-TRANS-SAVE-S) M-S)
	((A-TRANS-SAVE-T) M-T)
	((M-S) M-TEM)				;Area in which to allocate
	(CALL-XCT-NEXT XFSL)			;Find start of structure (to M-T)
       ((C-PDL-BUFFER-POINTER-PUSH) A-TRANS-MD)	;arg
	((C-PDL-BUFFER-POINTER-PUSH) M-T)	;Save old object
	(CALL-XCT-NEXT STRUCTURE-INFO)		;Find size of structure
       ((MD) M-T)
	;; Cons up new copy.  If list representation, branch off to special code first.
	(DISPATCH-XCT-NEXT (LISP-BYTE %%REGION-REPRESENTATION-TYPE) M-K D-TRANS-COPY)
       ((M-B) ADD M-3 A-4)			;Total size of it
TRANS-COPY-1
	((M-K) SETO)				;Extinguish flag
TRANS-COPY-1K
	;; Copy it, boxed and unboxed Q's alike, since shouldn't transport here.
	;; Length is in M-B, last A-SINF-PAD Q's not to be copied.
	((M-E) SUB C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1)) ;Old object minus 1
TRANS-COPY-2  ;Copy loop
	((VMA-START-READ M-E) ADD M-E (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	((M-B) SUB M-B (A-CONSTANT 1))
TRANS-COPY-5
	((M-A) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE)	;Replace with GC-forwarding pointer
		Q-POINTER M-T A-TRANS-COPY-FWD-DTP)
	(CHECK-PAGE-WRITE-FORCE)
	((M-TEM) Q-DATA-TYPE M-A)		;Check data type of Q being copied
	(JUMP-EQUAL M-TEM A-K TRANS-COPY-4)	;Oops, special hair for rplacd-forwarding
	((WRITE-MEMORY-DATA) M-A)		;Store old contents in new place
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE-FORCE)
	(JUMP-GREATER-THAN-XCT-NEXT M-B A-SINF-PAD TRANS-COPY-2)
       ((M-T) ADD M-T (A-CONSTANT 1))
	(JUMP-EQUAL M-B A-ZERO TRANS-COPY-9)
TRANS-COPY-7	;"Copy" the padding.  Must store forwarding pointers but clobber contents.
	((VMA M-E) ADD M-E (A-CONSTANT 1))
	((WRITE-MEMORY-DATA-START-WRITE)	;Replace with forwarding pointer
		Q-POINTER M-T A-TRANS-COPY-FWD-DTP)
	(CHECK-PAGE-WRITE-FORCE)
	((M-B) SUB M-B (A-CONSTANT 1))
	((VMA) M-T)
	((WRITE-MEMORY-DATA-START-WRITE)	;"Copy" gets a fixnum zero
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CHECK-PAGE-WRITE-FORCE)
	(JUMP-GREATER-THAN-XCT-NEXT M-B A-ZERO TRANS-COPY-7)
       ((M-T) ADD M-T (A-CONSTANT 1))
TRANS-COPY-9
	((M-TEM) M-A-1 M-T A-E)			;Offset from old to new
	((MD) ADD M-TEM A-TRANS-MD)		;Change value being stored
TRANS-COPY-3
	((MD) Q-POINTER MD A-TRANS-MD)		;But only the address part
	((M-T) A-TRANS-SAVE-T)			;Restore registers
	((M-S) A-TRANS-SAVE-S)
	((M-K) A-TRANS-SAVE-K)
	((M-E) A-TRANS-SAVE-E)
	((M-B) A-TRANS-SAVE-B)
	(POPJ-AFTER-NEXT (M-A) A-TRANS-SAVE-A)
       ((M-TRANSPORT-FLAG) DPB (M-CONSTANT 0) A-FLAGS)

TRANS-COPY-4 ;Copy last 2 words, rplacd-forwarded list, that have been snapped in
	(CALL-NOT-EQUAL M-B (A-CONSTANT 1) ILLOP)	;Fuckup somewhere
	((VMA-START-READ) M-A)			;Get first of 2 words via forwarding ptr
	(CHECK-PAGE-READ)
	((M-E) ADD M-E (A-CONSTANT 1))
	((M-B) READ-MEMORY-DATA)		;Cdr-code will always be CDR-NORMAL
	((WRITE-MEMORY-DATA-START-WRITE)	;Replace with GC-forwarding pointer
		Q-POINTER M-T A-TRANS-COPY-FWD-DTP)
	(CHECK-PAGE-WRITE-FORCE)
	((WRITE-MEMORY-DATA) M-B)		;Store old contents in new place
	((VMA-START-WRITE) M-T)
	(CHECK-PAGE-WRITE-FORCE)
	((M-B) (A-CONSTANT 0))
	((VMA-START-READ) ADD M-A (A-CONSTANT 1))	;Get second of 2 words
	(CHECK-PAGE-READ)
	(JUMP-XCT-NEXT TRANS-COPY-5)		;Rejoin main code to do last word
       ((M-T) ADD M-T (A-CONSTANT 1))

(LOCALITY D-MEM)
(START-DISPATCH 2 0)
;Dispatch on representation type for CONS inside of TRANS-COPY
D-TRANS-COPY
	(TRANS-COPY-LIST)	;0 List
	(P-BIT SCONS)		;1 Structure
	(P-BIT ILLOP)		;2 unused
 	(P-BIT ILLOP)		;3 unused
(END-DISPATCH)
(LOCALITY I-MEM)

;;; TRANS-COPY on a list
TRANS-COPY-LIST
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 31.) M-K TRANS-COPY-LIST-0) ;Test for RPLACD-forwarding
	(JUMP-XCT-NEXT TRANS-COPY-1)		;No RPLACD-forwarding, copy just like structure
       (CALL LCONS)

TRANS-COPY-LIST-0
	(JUMP-GREATER-THAN M-B (A-CONSTANT 2) TRANS-COPY-LIST-1) ;Test for hairy case
	;; The entire list-structure (1 Q) was forwarded, so simply snap out
	((VMA-START-READ) C-PDL-BUFFER-POINTER-POP)	;Fetch forwarding pointer
	(CHECK-PAGE-READ)
	(JUMP TRANS-COPY-3)			;Use what it points at

;;; Here if the list-structure is partially in one place and partially in another.
;;; If the new node created by rplacd is in oldspace and not yet copied, we should
;;; snap-out by copying it into the same place as the old part of the list-structure.
;;; And if we didn't snap out we could be storing a pointer to oldspace which is a no-no.
;;; On the other hand, if the new node is in newspace or has already been copied,
;;; we can't snap out.  Instead we create a full-node out of the cdr-next
;;; node just before the forwarded one.
TRANS-COPY-LIST-1
	((M-T) SUB M-B (A-CONSTANT 2))		;Offset to dtp-header-forward Q
	((VMA-START-READ M-T) ADD C-PDL-BUFFER-POINTER A-T)	;Fetch him
	(CHECK-PAGE-READ)
	((M-TEM) READ-MEMORY-DATA)		;Complete read cycle
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-GET-MAP-BITS) ;Validate meta bits
	(JUMP-IF-BIT-SET (LISP-BYTE %%REGION-OLDSPACE-META-BIT) MEMORY-MAP-DATA
		TRANS-COPY-LIST-3)		;Jump if new node is in newspace
	((VMA-START-READ) MD)			;Pick up first word of new node
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)	;Look for GC-forward
	(JUMP-EQUAL M-TEM (A-CONSTANT (EVAL DTP-GC-FORWARD)) TRANS-COPY-LIST-3)
	;; New node can be merged with old node, full snapping-out
	(CALL LCONS)				;Cons new list, big enough for both
	(JUMP-XCT-NEXT TRANS-COPY-1K)		;Go join normal copy
       ((M-K) (A-CONSTANT (EVAL DTP-HEADER-FORWARD))) ;but watch out for this data type

TRANS-COPY-LIST-3 ;Can't snap out.  MD -> new node in newspace.
	((VMA) M-T)				;Clobber hdr-fwd with cdr pointer
	((MD-START-WRITE) Q-POINTER MD (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LIST)))
	(CHECK-PAGE-WRITE-FORCE)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))	;Fix cdr code of preceding word
	(CHECK-PAGE-READ)
	((M-B) SUB M-B (A-CONSTANT 1))		;Copy will be 1 Q shorter since no snapout
	((MD-START-WRITE) Q-ALL-BUT-CDR-CODE READ-MEMORY-DATA
		(A-CONSTANT (BYTE-VALUE Q-CDR-CODE CDR-NORMAL)))
	(CHECK-PAGE-WRITE-FORCE)
	(JUMP-XCT-NEXT TRANS-COPY-1)		;Copy fudged list
       (CALL LCONS)

;;; EXTRA-PDL-TRAP
;;; We get here if we just wrote a possible pointer to the extra-pdl
;;; into main memory.  If so, we must copy the object out into a normal
;;; area and do the write again.  Mustn't sequence-break while the
;;; bad thing is in memory, and mustn't clobber anything other than
;;; what page faults clobber.  SMASHES PDL-BUFFER-INDEX.
;;; (I-ARG 1) indicates coming from pdl-buffer dumper, special return
;;; indicated since map has been munged.
;;; Note that we cannot get here from inside the transporter, which
;;; is fortunate since some variables are shared.

EXTRA-PDL-TRAP
	((A-TRANS-MD) MD)			;SAVE DUBIOUS OBJECT
	(JUMP-IF-BIT-SET-XCT-NEXT		;CHECK FOR CALL FROM PDL-BUFFER DUMPER
		(BYTE-FIELD 1 0) READ-I-ARG EXTRA-PDL-TRAP-0)
       ((A-TRANS-VMA) VMA)			;SAVE ADDRESS WRITTEN INTO
EXTRA-PDL-TRAP-1
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-GET-MAP-BITS) ;ENSURE VALIDITY OF META BITS
	(POPJ-IF-BIT-SET-XCT-NEXT		;RETURN IF FALSE ALARM
		(LISP-BYTE %%REGION-EXTRA-PDL-META-BIT) MEMORY-MAP-DATA)
       ((VMA) A-TRANS-VMA)			;RESTORE VMA
;Real extra-pdl trap, copy object out into working storage
	((VMA-START-READ) MD)			;Check for forwarding pointer
	(CHECK-PAGE-READ)
	((M-TEM) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL-XCT-NEXT M-TEM (A-CONSTANT (EVAL DTP-HEADER-FORWARD)) EXTRA-PDL-TRAP-3)
       ((MD) Q-POINTER MD A-TRANS-MD)		;Change address to follow forwarding ptr
	((A-TRANS-COPY-FWD-DTP)			;Forward with header forwards
		(A-CONSTANT (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-HEADER-FORWARD)
				  (BYTE-VALUE Q-CDR-CODE CDR-ERROR))))
	(CALL-XCT-NEXT TRANS-COPY)		;Copy the frob in A-TRANS-MD
       ((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-CNSADF) ;into default area
EXTRA-PDL-TRAP-3	;New copy is now in MD, with suitable tag
	(POPJ-AFTER-NEXT (VMA-START-WRITE) A-TRANS-VMA) ;Correct store that trapped
       (CHECK-PAGE-WRITE)			; and return

;Here for EXTRA-PDL-TRAP while storing pdl-buffer.  Must unmung map before
;doing anything else, and must eventually return to P-B-MR0
EXTRA-PDL-TRAP-0
	((MD) Q-R)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	((MD) SETA A-TRANS-MD			;RESTORE DUBIOUS MD
		MICRO-STACK-PNTR-AND-DATA-POP)	;AND FLUSH USELESS RETURN ADDRESS
	(JUMP-XCT-NEXT EXTRA-PDL-TRAP-1)	;RETURN TO MAINLINE
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC P-B-MR0))) ;WITH RETURN ADDRESS BUGGERED

;;; Sophisticated audio home entertainment center.

XBEEP (MISC-INST-ENTRY %BEEP)
;;; First argument is half-wavelength, second is duration.  Both are in microseconds.
;;; M-1 contains most recent time check
;;; M-2 has 2nd argument (duration) which is added to initial time-check
;;;     to compute quitting time
;;; M-C contains 1st argument, the wavelength
;;; M-4 contains the time at which the next click must be done.
;;; Note that the 32-bit clock wraps around once an hour, we have to be careful
;;; to compare clock values in the correct way, namely without overflow checking. 
	((VMA-START-READ) (A-CONSTANT 77772050))	;Unibus 764120
	(CHECK-PAGE-READ)
	((M-1) READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT 77772051))	;Unibus 764122
	(CHECK-PAGE-READ)
	((M-1) DPB READ-MEMORY-DATA (BYTE-FIELD 20 20) A-1)
	((M-2) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-2) M-2 ADD A-1)
	((M-C) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-4) M-1)
BEEP-NEXT-CLICK
	((M-4) M-4 ADD A-C)
BEEP-WAIT
	((VMA-START-READ) (A-CONSTANT 77772050))
	(CHECK-PAGE-READ)
	((M-1) READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT 77772051))
	(CHECK-PAGE-READ)
	((M-1) DPB READ-MEMORY-DATA (BYTE-FIELD 20 20) A-1)
	((M-TEM) SUB M-1 A-2)
	(JUMP-GREATER-OR-EQUAL M-TEM A-ZERO XFALSE)
	((M-TEM) SUB M-1 A-4)
	(JUMP-LESS-OR-EQUAL M-TEM A-ZERO BEEP-WAIT)
	((VMA-START-WRITE) (A-CONSTANT 77772044))	;Unibus 764110
	(CHECK-PAGE-WRITE)
	(JUMP BEEP-NEXT-CLICK)

;;; TV ROUTINES

;(TV-DRAW-CHAR FONT-ARRAY-PNTR CHAR-CODE X-BIT-POS Y-BIT-POS ALU-FUNC)
;THE X-BIT-POS AND Y-BIT-POS ARE OF THE TOP LEFT CORNER OF THE CHARACTER.
; (0,0) IS THE TOP LEFT CORNER OF THE SCREEN
;THE ALU-FUNC IS SUITABLE FOR OA-REG-LOW.  GOOD VALUES ARE:
;	IOR	740
;	XOR	540
;	ANDCA	560
;	SETA	640
;YOU SHOULD USE THE TV-ALU- VARIABLES, THESE NUMBERS ARE MACHINE-DEPENDENT

;(TV-ERASE WIDTH HEIGHT X-BIT-POS Y-BIT-POS ALU-FUNC)
;WIDTH AND HEIGHT ARE IN BITS.  A RECTANGLE OF THE INDICATED
;SIZE, OF ALL 1S, IS CREATED AND STORED INTO THE SPECIFIED
;PART OF THE TV BUFFER USING THE SPECIFIED ALU-FUNC.  USUALLY
;THE ANDCA FUNCTION IS USED FOR ERASING, BUT XOR COULD BE USED
;FOR THE BLINKING CURSOR ETC.

;A FONT ARRAY MAY NOT BE DISPLACED OR ANYTHING HAIRY LIKE THAT.
;ITS ARRAY LEADER CONTAINS:
;	0	NOT USED IN CASE MIGHT BE FILL POINTER?
;	1	FONT (NAME-STRUCTURE-SYMBOL)
;	2	NAME
;	3	CHARACTER CELL HEIGHT
;	4	CHARACTER CELL WIDTH (USED IF ITEM 7 IS NIL)
;	5	RASTER HEIGHT
;	6	RASTER WIDTH
;	7	FLOOR 32./RASTER WIDTH (# ROWS PER WORD)
;	8	CEILING RASTER HEIGHT/#5 (# WORDS PER CHAR)
;	9	NIL OR ARRAY POINTER TO CHARACTER WIDTH TABLE
;	10	NIL OR ARRAY POINTER TO LEFT KERN TABLE

;THE DATA PART OF THE ARRAY CONTAINS AN INTEGRAL NUMBER OF WORDS
;PER CHARACTER.  EACH WORD CONTAINS AN INTEGRAL NUMBER OF ROWS
;OF RASTER, LEFT ADJUSTED AND PROCESSED FROM LEFT TO RIGHT.
;(RIGHT TO LEFT ON 32-BIT TVS)
;ALL 32 BITS OF EACH Q IN THIS ARRAY ARE USED.  FOR EASIEST PROCESSING
;BY LISP PROGRAMS, IT SHOULD BE OF 1-BIT BYTE ARRAY TYPE.

;TV-DRAW-CHAR ONLY WORKS FOR RASTER WIDTHS OF AT MOST 16 (DECIMAL).
;OR 32 ON 32-BIT TVS
;FOR LARGER WIDTHS IT TRAPS TO ILLOP.  MACROCODE DRAWS LARGER CHARACTERS
;BY DRAWING SEVERAL NARROWER CHARACTERS SIDE BY SIDE.

;TV-ERASE AND TV-DRAW-CHAR DEPEND ON THE PARAMETERS SET UP BY TV-SELECT-SCREEN

;NO SEQUENCE BREAKS IN TV ROUTINES DUE TO LARGE NUMBER OF ACS USED
;ALSO DUE TO TV-SELECT-SCREEN

;;; SELECT A TV SCREEN FOR USE BY THE OTHER FUNCTIONS
;;; HERE'S WHAT WE KNOW ABOUT SCREEN OBJECTS: (SUBSCRIPTS IN THE ARRAY)
(ASSIGN SCREEN-BUFFER-IDX 14)
(ASSIGN SCREEN-HEIGHT-IDX 3)
(ASSIGN SCREEN-LOCATIONS-PER-LINE-IDX 15)
;;; HERE ARE VARIABLES WE SET UP:
;;; A-TV-CURRENT-SCREEN A-TV-SCREEN-BUFFER-ADDRESS A-TV-SCREEN-BUFFER-END-ADDRESS
;;; A-TV-SCREEN-LOCATIONS-PER-LINE 

XTVSELSCRN (MISC-INST-ENTRY TV-SELECT-SCREEN)
	((M-A) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-EQUAL M-A A-TV-CURRENT-SCREEN)	;Nothing to be done
	(CALL-XCT-NEXT GAHDR)			;M-E gets base data address
       ((A-TV-CURRENT-SCREEN) M-A)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-BUFFER-IDX))
	(CHECK-PAGE-READ)
	((A-TV-SCREEN-BUFFER-ADDRESS) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-LOCATIONS-PER-LINE-IDX))
	(CHECK-PAGE-READ)
	((A-TV-SCREEN-LOCATIONS-PER-LINE) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-E (A-CONSTANT SCREEN-HEIGHT-IDX))
	(CHECK-PAGE-READ)
	((Q-R) A-TV-SCREEN-LOCATIONS-PER-LINE)
	(CALL-XCT-NEXT MPY12)			;M-2 gets product
       ((M-1) DPB READ-MEMORY-DATA (BYTE-FIELD 20. 12.) A-ZERO)  ;Number of raster lines
	(POPJ-AFTER-NEXT
	 (A-TV-SCREEN-BUFFER-END-ADDRESS) ADD M-2 A-TV-SCREEN-BUFFER-ADDRESS)
       (NO-OP)

;;; NEW TV-DRAW-CHAR MICROCODE, FOR 32-BIT TV BUFFERS, BITS NUMBERED RIGHT-TO-LEFT

;; THE CODE BELOW WILL NEVER READ OR STORE OUTSIDE THE MEMORY LIMITS SET BY THE SCREEN.
;;STORING BELOW THE REGULAR TV-BUFFER IS A PARTICULAR SCREW, SINCE A-MEMORY IS MAPPED THERE!
;;STORING ABOVE THE TV-BUFFER IS LESS DISASTEROUS NOW, BUT COULD EASILY CAUSE LOSSAGE
;;IN THE FUTURE.  IF (IN THE FUTURE) THIS CODE IS USED TO WRITE DIRECTLY INTO MEMORY
;;ARRAYS, IT WILL BE ESSENTIAL THAT IT NOT CLOBBER OUT OF BOUNDS.
;; THE ALTERNATIVE DECISION WOULD BE TO PUT THE RESPONSIBILITY ON THE CALLER OF TV-DRAW-CHAR
;;TO ASSURE THE ARGUMENTS WERE IN RANGE.  AGAINST THIS IS, (1) ITS CALLED TV-DRAW-CHAR
;;NOT %TV-DRAW-CHAR, SO IT SHOULDN'T BE CAPABLE OF DESTROYING STORAGE INTEGRITY AND
;;(2) STICKY PROBLEMS ARISE WITH CURSORS WHICH ARE PAINFUL TO DEAL WITH IN MACROCODE.
;;BASICALLY THE CURSOR WANTS TO BE ABLE TO POINT ANYWHERE ON THE SCREEN (INCLUDING THE
;;EDGE), MOVE SMOOTHLY, AND BE AT LEAST PARTIALLY VISIBLE AT ALL TIMES.
;; THE DISADVANTAGE OF CHECKING IN TV-DRAW-CHAR IS THAT SLOWS DOWN THE INNER LOOP
;;OF DRAWING CHARACTERS.  THIS IS CURRENTLY NOT TOO IMPORTANT SINCE CASES OF INTEREST ARE
;;DOMINATED BY PER CHARACTER MACRO-CODE EXECUTION TIMES, AND THE PERCENT SLOWDOWN
;;EVEN WITHIN TV-DRAW-CHAR IS SMALL.

XTVCHR (MISC-INST-ENTRY TV-DRAW-CHAR)
	(CALL-XCT-NEXT TVXYADR)				;M-E GETS WORD ADDR, M-T BIT OFFSET
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-J GETS ALU FUNCTION
	((M-I) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-I GETS CHARACTER CODE
	(CALL-XCT-NEXT GAHDRA)				;M-A ARRAY POINTER, M-E DATA ADDRESS
       ((M-C) M-E)					;M-C SAVES TV BUFFER ADDRESS
  (ERROR-TABLE CALLS-SUB TV-DRAW-CHAR)
	((VMA-START-READ) SUB M-A (A-CONSTANT 10.))	;GET NUMBER OF WORDS PER CHAR
	(CHECK-PAGE-READ)
	((Q-R) M-I)					;AND MULTIPLY BY CHARACTER CODE
	(CALL-XCT-NEXT MPY12)
       ((M-1) DPB READ-MEMORY-DATA (BYTE-FIELD 20. 12.) A-ZERO)	;M-2 GETS PRODUCT
	((VMA-START-READ) SUB M-A (A-CONSTANT 8.))	;M-B GETS RASTER WIDTH
	(CHECK-PAGE-READ)
	((M-B) Q-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) SUB M-A (A-CONSTANT 9.))	;M-R GETS NUMBER OF ROWS PER WORD
	(CHECK-PAGE-READ)
	(CALL-GREATER-THAN M-B (A-CONSTANT 32.) ILLOP)	;TOO WIDE
	((M-I) SUB (M-CONSTANT 40) A-B)			;40 - RASTER WIDTH
		;THIS HAS OVERFLOW BUG IF M-B=40, BUT WILL NEVER BE USED IN THAT CASE ANYWAY
	((M-Q) DPB M-I OAL-BYTL-1 A-I)			;LDB PNTR +40 TO SHIFT FONT WORD
	((M-R) Q-POINTER READ-MEMORY-DATA)		; RIGHT BY ONE RASTER ROW
	((VMA-START-READ) SUB M-A (A-CONSTANT 7))	;M-D GETS RASTER HEIGHT
	(CHECK-PAGE-READ)
	((M-K) ADD M-B A-T)				;RASTER WIDTH PLUS BIT OFFSET
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-K (A-CONSTANT 40) XTVCH4) ;JUMP IF DOESN'T CROSS
       ((M-D) Q-POINTER READ-MEMORY-DATA)		; WORD BOUNDARY
							;NOTE C(M-T) > 0, SO NO OVERFLOW
	((M-TEM) SUB (M-CONSTANT 40) A-T)		;LENGTH OF BYTE AT LEFT OF 1ST WORD
	((M-T) DPB M-TEM OAL-BYTL-1 A-T)		;DPB PNTR +40 FOR THAT BYTE
	((M-I) DPB M-K OAL-BYTL-1 A-T)			;LDB PNTR +40 FOR BYTE AT RIGHT OF 2ND
;DROPS THROUGH
;DROPS IN
	((VMA-START-READ M-E) ADD M-2 A-E)		;FETCH FIRST WORD OF RASTER
;M-1 WORD FROM FONT ARRAY
;M-A FONT ARRAY POINTER
;M-B RASTER WIDTH
;M-C TV BUFFER WORD ADDRESS
;M-D RASTER HEIGHT (NUMBER OF ROWS TO GO)
;M-E ADDRESS OF WORD IN FONT ARRAY
;M-I LDB PNTR +40 TO STORE INTO SECOND TV WORD
;M-J ALU FUNCTION
;M-Q LDB PNTR +40 TO SHIFT FONT WORD RIGHT ONE RASTER ROW
;M-R NUMBER OF RASTER ROWS PER WORD
;M-S NUMBER OF RASTER ROWS IN M-1
;M-T DPB PNTR +40 TO STORE INTO FIRST TV WORD
;HERE WITH FETCH OF NEXT RASTER WORD STARTED, IN THE CASE WHERE IT CROSSES A WORD BOUNDARY
XTVCH1	(CHECK-PAGE-READ)
	((M-S) M-R)					;THIS MANY ROWS IN THIS WORD
	((M-1) READ-MEMORY-DATA)			;M-1 GETS WORD FROM FONT ARRAY
;HERE FOR EACH ROW OF RASTER, IN THE CASE WHERE IT CROSSES A WORD BOUNDARY
XTVCH2  (JUMP-LESS-THAN M-C A-TV-SCREEN-BUFFER-ADDRESS XTVCHO1)  ;COMMENT ABOUT RANGE CHECKING 
	(JUMP-GREATER-OR-EQUAL M-C A-TV-SCREEN-BUFFER-END-ADDRESS XTVCHO1)  ;ABOVE
	((VMA-START-READ) M-C)				;GET FIRST TV BUFFER WORD
	(CHECK-PAGE-READ)
	((OA-REG-LOW) SUB M-T (A-CONSTANT 40))		;ALIGN RASTER
       ((M-2) DPB M-1 (BYTE-FIELD 0 0) A-ZERO)
	((OA-REG-LOW) M-J)				;COMBINE AND STORE BACK
       ((WRITE-MEMORY-DATA-START-WRITE) SETZ READ-MEMORY-DATA A-2)
	(CHECK-PAGE-WRITE)
XTVCHO1	((VMA) ADD M-C (A-CONSTANT 1))
	(JUMP-LESS-THAN VMA A-TV-SCREEN-BUFFER-ADDRESS XTVCHO2)
	(JUMP-GREATER-OR-EQUAL VMA A-TV-SCREEN-BUFFER-END-ADDRESS XTVCHO2)
	((VMA-START-READ) ADD M-C (A-CONSTANT 1))	;GET SECOND TV BUFFER WORD
	(CHECK-PAGE-READ)
	((OA-REG-LOW) SUB M-I (A-CONSTANT 40))		;ALIGN RASTER
       ((M-2) (BYTE-FIELD 0 0) M-1)
	((OA-REG-LOW) M-J)				;COMBINE AND STORE BACK
       ((WRITE-MEMORY-DATA-START-WRITE) SETZ READ-MEMORY-DATA A-2)
	(CHECK-PAGE-WRITE)
XTVCHO2	(JUMP-LESS-OR-EQUAL M-D (A-CONSTANT 1) XFALSE)	;STOP IF DONE
	((M-D) SUB M-D (A-CONSTANT 1))
	((M-C) ADD M-C A-TV-SCREEN-LOCATIONS-PER-LINE)	;ADVANCE TO NEXT LINE
	((OA-REG-LOW) SUB M-Q (A-CONSTANT 40))		;SHIFT RASTER RIGHT
       ((M-1) (BYTE-FIELD 0 0) M-1)
	(JUMP-GREATER-THAN-XCT-NEXT M-S (A-CONSTANT 1) XTVCH2)	;JUMP IF WORD NOT USED UP
       ((M-S) SUB M-S (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTVCH1)				;FETCH NEW WORD
       ((VMA-START-READ M-E) ADD M-E (A-CONSTANT 1))

;THIS VERSION OF THE ABOVE IS FOR THE FAST CASE, WHERE IT DOES NOT CROSS A WORD BOUNDARY
XTVCH4	((M-T) DPB M-B (BYTE-FIELD 6 5) A-T)		;DPB PNTR +40 FOR ALIGNING RASTER
		;BYTE-FIELD IS ALMOST OAL-BYTL-1
	((VMA-START-READ M-E) ADD M-2 A-E)		;FETCH FIRST WORD OF RASTER
;M-1 WORD FROM FONT ARRAY
;M-A FONT ARRAY POINTER
;M-B RASTER WIDTH
;M-C TV BUFFER WORD ADDRESS
;M-D RASTER HEIGHT (NUMBER OF ROWS TO GO)
;M-E ADDRESS OF WORD IN FONT ARRAY
;M-J ALU FUNCTION
;M-Q LDB PNTR +40 TO SHIFT FONT WORD RIGHT ONE RASTER ROW
;M-R NUMBER OF RASTER ROWS PER WORD
;M-S NUMBER OF RASTER ROWS IN M-1
;M-T DPB PNTR +40 TO STORE INTO TV WORD
;HERE WITH FETCH OF NEXT RASTER WORD STARTED
XTVCH5	(CHECK-PAGE-READ)
	((M-S) M-R)					;THIS MANY ROWS IN THIS WORD
	((M-1) READ-MEMORY-DATA)			;M-1 GETS WORD FROM FONT ARRAY
;HERE FOR EACH ROW OF RASTER
XTVCH6	(JUMP-LESS-THAN M-C A-TV-SCREEN-BUFFER-ADDRESS XTVCHO3)  ;COMMENT ABOUT RANGE CHECKING 
	(JUMP-GREATER-OR-EQUAL M-C A-TV-SCREEN-BUFFER-END-ADDRESS XTVCHO3)  ;ABOVE
	((VMA-START-READ) M-C)				;GET TV BUFFER WORD
	(CHECK-PAGE-READ)
	((OA-REG-LOW) SUB M-T (A-CONSTANT 40))		;ALIGN RASTER
       ((M-2) DPB M-1 (BYTE-FIELD 0 0) A-ZERO)
	((OA-REG-LOW) M-J)				;COMBINE AND STORE BACK
       ((WRITE-MEMORY-DATA-START-WRITE) SETZ READ-MEMORY-DATA A-2)
	(CHECK-PAGE-WRITE)
XTVCHO3	(JUMP-LESS-OR-EQUAL M-D (A-CONSTANT 1) XFALSE)	;STOP IF DONE
	((M-D) SUB M-D (A-CONSTANT 1))
	((M-C) ADD M-C A-TV-SCREEN-LOCATIONS-PER-LINE)	;ADVANCE TO NEXT LINE
	((OA-REG-LOW) SUB M-Q (A-CONSTANT 40))		;SHIFT RASTER RIGHT
       ((M-1) (BYTE-FIELD 0 0) M-1)
	(JUMP-GREATER-THAN-XCT-NEXT M-S (A-CONSTANT 1) XTVCH6)	;JUMP IF WORD NOT USED UP
       ((M-S) SUB M-S (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTVCH5)				;FETCH NEW WORD
       ((VMA-START-READ M-E) ADD M-E (A-CONSTANT 1))

;12-BIT UNSIGNED MULTIPLY
; M-1<31:12> TIMES Q-R <11:0> TO M-2<31:0>.  M-1<11:0> MUST BE ZERO.
MPY12	((M-2) MULTIPLY-STEP A-1 M-ZERO)
(REPEAT 9 ((M-2) MULTIPLY-STEP M-2 A-1))
	(POPJ-AFTER-NEXT (M-2) MULTIPLY-STEP M-2 A-1)
       ((M-2) MULTIPLY-STEP M-2 A-1)

;NEW VERSION OF TVXYADR
;POP OFF Y-BIT-POS AND X-BIT-POS AND CONVERT TO WORD AND BIT ADDRESS
;M-E GETS ABSOLUTE WORD ADDRESS, M-T GETS BIT OFFSET FROM RIGHT (LEFT) IF 32 (16) BIT.
;CLOBBER M-1, M-2
TVXYADR	((M-1) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 20. 12.) A-ZERO) ;Y POSITION (LSH 12)
	(CALL-XCT-NEXT MPY12)
       ((Q-R) A-TV-SCREEN-LOCATIONS-PER-LINE)		;M-2 GETS OFFSET TO START OF LINE
	((M-1) (BYTE-FIELD 19. 5) C-PDL-BUFFER-POINTER)	;WORD PART OF X POSITION
	((OA-REG-HIGH) (BYTE-FIELD 1 18.) M-1)
	((M-1) SELECTIVE-DEPOSIT M-ZERO (BYTE-FIELD 13. 19.) A-1)
	((M-E) ADD M-2 A-1)				;RELATIVE WORD ADDRESS
	(POPJ-AFTER-NEXT (M-E) ADD M-E A-TV-SCREEN-BUFFER-ADDRESS)
       ((M-T) (BYTE-FIELD 5 0) C-PDL-BUFFER-POINTER-POP);BIT PART OF X POSITION

;;; TV-ERASE width height x y alu

XTVERS (MISC-INST-ENTRY TV-ERASE)
	(CALL-XCT-NEXT TVXYADR)				;M-E := ADDR, M-T := BIT OFFSET
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ALU FUNC
	((M-D) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;HEIGHT IN RASTER LINES
	((M-C C-PDL-BUFFER-POINTER) ADD A-T		;ADJUST WIDTH TO PRETEND
			C-PDL-BUFFER-POINTER)		;STARTING ON WORD BOUNDARY
	((M-C) (BYTE-FIELD 19. 5) M-C)			;WIDTH IN WORDS
	((M-Q) (BYTE-FIELD 5 0) (M-CONSTANT -1))	;37 ;LOAD HANDY CONSTANT, USED LATER
	((M-K) SUB M-Q A-T)				;BYTL-1 FOR FIRST WORD
	((OA-REG-LOW) DPB M-K OAL-BYTL-1 A-T)		;GET MASK FOR BITS IN LEFT OF 1ST WD
	((M-K) DPB (M-CONSTANT -1) (BYTE-FIELD 0 0) A-ZERO)
	(JUMP-EQUAL-XCT-NEXT M-C A-ZERO XTVERS3)	;JUMP IF NARROW (LESS THAN 1 WORD)
XTVERS0((M-B) M-D)					;COPY OF HEIGHT
	(CALL-LESS-THAN M-E A-TV-SCREEN-BUFFER-ADDRESS TRAP)
  (ERROR-TABLE TV-ERASE-OFF-SCREEN)
	(CALL-GREATER-OR-EQUAL M-E A-TV-SCREEN-BUFFER-END-ADDRESS TRAP)
  (ERROR-TABLE TV-ERASE-OFF-SCREEN)			;This is special.
	((VMA-START-READ) M-E)				;FETCH TOP LEFT-HAND WORD
XTVERS1	(CHECK-PAGE-READ)				;DO FIRST COLUMN
	(JUMP-LESS-OR-EQUAL M-B A-ZERO XTVERS2)		;JUMP IF COLUMN ALL DONE
	(CALL-GREATER-OR-EQUAL VMA A-TV-SCREEN-BUFFER-END-ADDRESS TRAP)
  (ERROR-TABLE TV-ERASE-OFF-SCREEN)			;This is special.
	((OA-REG-LOW) M-J)
	((WRITE-MEMORY-DATA-START-WRITE) SETZ READ-MEMORY-DATA A-K)
	(CHECK-PAGE-WRITE)
	((M-B) SUB M-B (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTVERS1)
       ((VMA-START-READ) ADD VMA A-TV-SCREEN-LOCATIONS-PER-LINE)

XTVERS2	((M-E) ADD M-E (A-CONSTANT 1))			;NEXT COLUMN
	((M-C) SUB M-C (A-CONSTANT 1))
	(JUMP-GREATER-THAN-XCT-NEXT M-C A-ZERO XTVERS0)
       ((M-K) SETO)					;DO MIDDLE COLUMNS, MASK IS ALL BITS
	(JUMP-LESS-THAN M-C A-ZERO XFALSE)		;ALL DONE (SECOND TIME THROUGH HERE)
XTVERS3	((M-B) AND C-PDL-BUFFER-POINTER-POP A-Q)	;NUMBER BITS TO DO IN LAST COLUMN
	(JUMP-EQUAL M-B A-ZERO XFALSE)			;NO LAST COLUMN, RETURN NIL
	((M-B) SUB M-B (A-CONSTANT 1))
	((OA-REG-LOW) DPB M-B OAL-BYTL-1 A-ZERO)	;CLEAR THAT MANY BITS ON THE LEFT
	((M-K) (BYTE-FIELD 0 0) M-K)
	(JUMP XTVERS0)

;;;TV-DRAW-LINE X0 Y0 X Y ALU SCREEN
TVDRLN	(MISC-INST-ENTRY TV-DRAW-LINE)
	(CALL XTVSELSCRN)				;Select specified screen
	((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-J ALU function
	((M-4) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-4 Y
	((M-TEM) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-TEM X
	((M-2) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;M-2 Y0
	((M-S) SUB M-4 A-2)				;M-S DY
	((M-1) Q-POINTER C-PDL-BUFFER-POINTER)		;M-1 X0
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-TEM A-1 TVDRL1)	;DX0?
       ((M-R) SUB M-TEM A-1)				;M-R DX
	((M-R) SUB M-ZERO A-R)				;yes, exch X and X0
	((C-PDL-BUFFER-POINTER) M-TEM)
	((M-S) SUB M-ZERO A-S)				;and Y and Y0
	((M-2) M-4)
	;;DX now assured of being non-negative
TVDRL1	((C-PDL-BUFFER-POINTER-PUSH) M-2)
	(CALL TVXYADR)					;M-E addr M-T bit offset
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-S A-ZERO TVDRL2)
       ((M-I) A-TV-SCREEN-LOCATIONS-PER-LINE)		;M-I Y increment with correct sign
	((M-I) SUB M-ZERO A-I)
	((M-S) SUB M-ZERO A-S)
TVDRL2	((M-K) SUB M-R A-S)				;M-K flag for DY>DX
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-K A-ZERO TVDRL3)
       ((M-C) M-R)					;number of points to do along long side
	((M-C) M-S)					;exch DX and DY
	((M-S) M-R)
	((M-R) M-C)
TVDRL3	((M-A) (BYTE-FIELD 23. 1) M-R)			;M-A <length of long side>/2
TVDRL4	(JUMP-LESS-THAN M-E A-TV-SCREEN-BUFFER-ADDRESS TVDRL7) ;Clip
	(JUMP-GREATER-OR-EQUAL M-E A-TV-SCREEN-BUFFER-END-ADDRESS TVDRL7) ;Clip
	((VMA-START-READ) M-E)				;get data
	(CHECK-PAGE-READ)
	((OA-REG-LOW) M-T)				;bit offset
       ((M-1) SELECTIVE-DEPOSIT (BYTE-FIELD 1 0) (M-CONSTANT -1))	;M-1 bit to twiddle
	((OA-REG-LOW) M-J)				;ALU
       ((WRITE-MEMORY-DATA-START-WRITE) SETZ READ-MEMORY-DATA A-1)	;munge it
	(CHECK-PAGE-WRITE)
TVDRL7	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-C A-ZERO XFALSE)	;return if done stepping long side
       ((M-C) SUB M-C (A-CONSTANT 1))
	((M-A) SUB M-A A-S)
	(JUMP-LESS-THAN M-A A-ZERO TVDRL5)		;time to bump short side too?
	(JUMP-GREATER-OR-EQUAL M-K A-ZERO TVDRL6)	;just increment long side
	(JUMP-XCT-NEXT TVDRL4)				;y side longer
TVDRL5 ((M-E) ADD M-E A-I)				;increment both x and y
	((M-A) ADD M-A A-R)
TVDRL6	((M-T) ADD M-T (A-CONSTANT 1))			;increment x
	(JUMP-LESS-THAN M-T (A-CONSTANT 40) TVDRL4)	;see if past end of word
	((M-E) ADD M-E (A-CONSTANT 1))			;move to next word
	(JUMP-XCT-NEXT TVDRL4)
       ((M-T) SETZ)

; (BITBLT alu width height from-array from-x from-y to-array to-x to-y)
;Features:
; The X and Y arguments specify the coordinates of the upper-left-hand
;  corner of the <width> x <height> region to be operated on.  The operation
;  is normally performed top to bottom then left to right, but making
;  width or height negative will make it go the other way, useful when
;  regions overlap.  The X and Y should still be for the top-left corner.
; Works on any numeric array type.  For more than 1-bit bytes, the X and Y arguments
;  are in bytes rather than bits.
; If you run off the edge of the source array, it wraps around
;  to the opposite edge.  This is intended to allow such
;  things as replication of small stipple patterns through a large screen area.
;  If you run off the edge of the destination array, an error occurs.
; The function cannot be made to reference outside of the argument arrays
;  by giving it bad arguments.
;Crocks:
; Requires that the first dimension of the array be a multiple of 32. bits.
; Index-offset arrays do not work completely.
;Register conventions are commented a little bit later.

BITBLT (MISC-INST-ENTRY BITBLT)
	(CALL BITBLT-DECODE-ARRAY)			;Decode destination
	((M-C) M-1)					;Save BITBLT-DST-WIDTH
	((M-ZR) SUB Q-R A-4)				;Save eventual contents of M-T
	((M-I) M-A)					;Save eventual contents of M-D
	((M-R) M-Q)					;X offset in bits
	((M-1) SUB (M-CONSTANT 23.) A-TEM)		;Make DPB ptr to convert width
	((M-K) DPB M-1 OAL-BYTL-1 A-TEM)		; from bytes to bits
	(CALL BITBLT-DECODE-ARRAY)			;Decode source
	;; No sequence breaks after this point
	((A-BITBLT-DST-WIDTH) M-C)			;Get dest parameters saved above
	((M-T) M-ZR)
	((M-D) M-I)
	((A-BITBLT-SRC-WIDTH) M-1)			;Save source parameters
	((A-BITBLT-SRC-WIDTH-WORDS) (BYTE-FIELD 27. 5) M-1) ;This copy is always positive
	;; Set up the vertical address increments and column heights for the arrays
	((M-B) (BYTE-FIELD 27. 5) M-1)			;Word increment between source rows
	((M-C) Q-R)					;Total number of source rows
	((A-BITBLT-SRC-Y Q-R) M-4)			;Number of rows down we start at
	(CALL-XCT-NEXT MPY)				;Initial Y
       ((M-1) A-BITBLT-SRC-WIDTH-WORDS)			; times words per row
	((A-BITBLT-SRC-Y-OFFSET) Q-R)			; gives offset from top of column
	((M-A) SUB M-A A-BITBLT-SRC-Y-OFFSET)		;Start M-A at top of column
	((M-1) A-BITBLT-DST-WIDTH)
	((M-E) (BYTE-FIELD 27. 5) M-1)			;Word increment between dest rows
	;; Get the height in M-S.  If negative, make positive and rearrange parameters
	;; so that it will start at the bottom and move up.
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
	    (ERROR-TABLE ARGTYP FIXNUM PP 2)
	(JUMP-IF-BIT-CLEAR-XCT-NEXT BOXED-SIGN-BIT C-PDL-BUFFER-POINTER BITBLT-1)
       ((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((M-S) SUB M-ZERO A-S)				;Negative height, change around
	((M-S) Q-POINTER M-S)
	((M-B) SUB M-ZERO A-B)
	((M-E) SUB M-ZERO A-E)
	((M-1) SUB M-C (A-CONSTANT 1))			;Change tops of columns to bottoms
	(CALL-XCT-NEXT MPY)
       ((Q-R) SUB M-ZERO A-B)
	((M-A) ADD Q-R A-A)
	((M-1) ADD M-S A-BITBLT-SRC-Y)			;Move source offset to other end
	(CALL-XCT-NEXT DIV)				;Taking modulo size of source
       ((M-2) M-C)
	((A-BITBLT-SRC-Y Q-R) SUB M-C A-1)		;Number rows offset is up from bottom
	(CALL-XCT-NEXT MPY)
       ((M-1) SUB M-ZERO A-BITBLT-SRC-WIDTH-WORDS)
	((A-BITBLT-SRC-Y-OFFSET) Q-R)			;Negative offset up from bottom
	((M-1) SUB M-S (A-CONSTANT 1))
	(CALL-XCT-NEXT MPY)
       ((Q-R) SUB M-ZERO A-E)
	((M-D) ADD Q-R A-D)
BITBLT-1	;Now get the width, check for negative
	(DISPATCH Q-DATA-TYPE C-PDL-BUFFER-POINTER TRAP-UNLESS-FIXNUM)
	    (ERROR-TABLE ARGTYP FIXNUM PP 1)
	((OA-REG-LOW) M-K)				;Convert from bytes to bits
	((M-1) DPB C-PDL-BUFFER-POINTER-POP A-ZERO)
	(JUMP-IF-BIT-SET-XCT-NEXT BOXED-SIGN-BIT M-1 BITBLT-RTL) ;Neg width means right to left
       ((A-ALUF) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;Alu function
	((A-BITBLT-HOR-COUNT) SUB M-ZERO A-1)		;Sign-extended negative width
;Drops through into BITBLT-LTR
;drops in
	;; Now, enter a loop by columns.  Each column is as wide as will avoid
	;; crossing word boundaries in source and in destination.
	;; This is for left-to-right case
BITBLT-LTR
	;; Compute width of column to be done.
	((M-1) (BYTE-FIELD 5 0) M-Q)			;Source bit offset
	((M-2) (BYTE-FIELD 5 0) M-R)			;Destination bit offset
	((M-3) SUB M-Q A-BITBLT-SRC-WIDTH)		;Negative bits left in source array
	((M-J) SUB M-1 (A-CONSTANT 40))			;Negative bits left in source word
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-J A-3 BITBLT-LTR-1)	;Take the smaller
       ((M-I) SUB M-2 A-1)				;Left rotate for source
	((M-J) M-3)					;Reached right-hand end of array
BITBLT-LTR-1
	((M-3) SUB M-R A-BITBLT-DST-WIDTH)		;Negative bits left in dest array
	((M-1) SUB M-2 (A-CONSTANT 40))			;Negative bits left in dest word
	(JUMP-GREATER-OR-EQUAL M-1 A-3 BITBLT-LTR-2)	;Take the smaller
	((M-1) M-3)
BITBLT-LTR-2
	(JUMP-GREATER-OR-EQUAL M-J A-1 BITBLT-LTR-3)	;Take smaller of src, dest
	((M-J) M-1)
BITBLT-LTR-3
	(JUMP-GREATER-OR-EQUAL M-J A-BITBLT-HOR-COUNT BITBLT-LTR-4) ;Min with overall count
	((M-J) A-BITBLT-HOR-COUNT)
BITBLT-LTR-4	;Here M-J has negative width of this column
	(JUMP-GREATER-OR-EQUAL M-J A-ZERO XFALSE)	;Return NIL if zero width (can't do)
	((M-TEM) M-A-1 M-ZERO A-J)			;Positive byte length minus one
	((M-K) DPB M-TEM (BYTE-FIELD 27. 5) A-R)	;Byte pointer to part of destination
	(CALL-XCT-NEXT BITBLT-INNER-LOOP)		; to be modified
       ((A-BITBLT-HOR-COUNT) M+A+1 M-TEM A-BITBLT-HOR-COUNT)	;Advance negative bit count
	(JUMP-LESS-OR-EQUAL M-ZERO A-BITBLT-HOR-COUNT XFALSE)	;Return NIL if done
	((M-TEM) (BYTE-FIELD 5 0) (M-CONSTANT -1) A-Q)	;Last bit this source word
	((M-Q) SUB M-Q A-J)				;Advance source X bit offset
	(JUMP-LESS-OR-EQUAL M-Q A-TEM BITBLT-LTR-5)
	((M-A) ADD M-A (A-CONSTANT 1))			;Entered next word
BITBLT-LTR-5
	(JUMP-LESS-THAN M-Q A-BITBLT-SRC-WIDTH BITBLT-LTR-6)
	((M-Q) SUB M-Q A-BITBLT-SRC-WIDTH)		;Wrap around (M-Q should get 0 here)
	((M-A) SUB M-A A-BITBLT-SRC-WIDTH-WORDS)
BITBLT-LTR-6
	((M-TEM) (BYTE-FIELD 5 0) (M-CONSTANT -1) A-R)	;Last bit this destination word
	((M-R) SUB M-R A-J)				;Advance destination X bit offset
	(JUMP-LESS-OR-EQUAL M-R A-TEM BITBLT-LTR-7)
	((M-D) ADD M-D (A-CONSTANT 1))			;Entered next word
BITBLT-LTR-7
	(JUMP-LESS-THAN M-R A-BITBLT-DST-WIDTH BITBLT-LTR)	;Loop for more columns
	(CALL TRAP)
	    (ERROR-TABLE BITBLT-DESTINATION-TOO-SMALL)

	;; Now, enter a loop by columns.  Each column is as wide as will avoid
	;; crossing word boundaries in source and in destination.
	;; This is for right-to-left case
BITBLT-RTL
	((M-1) Q-POINTER M-1 (A-CONSTANT -1))		;Sign-extended negative width
	((A-BITBLT-HOR-COUNT) SUB M-ZERO A-1)		;We want it positive
	;; Adjust parameters to point to after right-most column to be done
	((M-TEM) (BYTE-FIELD 27. 5) M-R)
	((M-D) SUB M-D A-TEM)
	((M-R) ADD M-R A-BITBLT-HOR-COUNT)		;Bit offset to right of dest area
	(CALL-GREATER-THAN M-R A-BITBLT-DST-WIDTH TRAP)
	    (ERROR-TABLE BITBLT-DESTINATION-TOO-SMALL)
	((M-TEM) (BYTE-FIELD 27. 5) M-R)
	((M-D) ADD M-D A-TEM)				;Corresponding word address
	((M-TEM) (BYTE-FIELD 27. 5) M-Q)
	((M-A) SUB M-A A-TEM)
	((M-1) ADD M-Q A-BITBLT-HOR-COUNT)		;Bit offset to right of source area
	(CALL-XCT-NEXT DIV)				;Take modulo source width
       ((M-2) A-BITBLT-SRC-WIDTH)			; to effect wrap-around
	((M-Q) M-1)					;Remainder is initial bit offset
	((M-TEM) (BYTE-FIELD 27. 5) M-Q)
	((M-A) ADD M-A A-TEM)				;Corresponding word address
BITBLT-RTL-LOOP
	;; Compute width of column to be done, to left of these bit offsets
	(JUMP-GREATER-THAN M-Q A-ZERO BITBLT-RTL-0)	;Check for wrap-around
	((M-Q) A-BITBLT-SRC-WIDTH)
	((M-A) ADD M-A A-BITBLT-SRC-WIDTH-WORDS)
BITBLT-RTL-0
	((M-J) (BYTE-FIELD 5 0) M-Q)			;Source bit offset
	(JUMP-NOT-EQUAL M-J A-ZERO BITBLT-RTL-1)	;Jump if not at left of word
	((M-A) SUB M-A (A-CONSTANT 1))			;Else back up to previous word
	((M-J) (A-CONSTANT 40))				;And there are 40 bits in it
BITBLT-RTL-1
	((M-2) (BYTE-FIELD 5 0) M-R)			;Destination bit offset
	(JUMP-NOT-EQUAL-XCT-NEXT M-2 A-ZERO BITBLT-RTL-2) ;Jump if not at left of word
       ((M-I) SUB M-2 A-J)				;Left rotate for source
	((M-D) SUB M-D (A-CONSTANT 1))			;Else back up to previous word
	((M-2) (A-CONSTANT 40))				;And there are 40 bits in it
BITBLT-RTL-2
	(JUMP-LESS-OR-EQUAL M-J A-2 BITBLT-RTL-3)	;Take lesser of bits left in words
	((M-J) M-2)
BITBLT-RTL-3
	(JUMP-LESS-OR-EQUAL M-J A-Q BITBLT-RTL-4)	;Min with bits left in source array
	((M-J) M-Q)					;(Dest array already range-checked)
BITBLT-RTL-4
	(JUMP-LESS-OR-EQUAL M-J A-BITBLT-HOR-COUNT BITBLT-RTL-5)
	((M-J) A-BITBLT-HOR-COUNT)			;Min with bits left to do
BITBLT-RTL-5	;M-J now has positive number of bits in this column
	(JUMP-LESS-OR-EQUAL M-J A-ZERO XFALSE)		;Return NIL if zero width (can't do)
	((M-K) SUB M-R A-J)				;<5:0>=MROT for dest bits to modify
	((M-TEM) SUB M-J (A-CONSTANT 1))		;BYTL-1 for dest bits to modify
	((M-K) DPB M-TEM (BYTE-FIELD 27. 5) A-K)	;Byte pointer to part of destination
	((M-TEM) SUB M-ZERO A-J)			; to be modified
	(CALL-XCT-NEXT BITBLT-INNER-LOOP)
       ((A-BITBLT-HOR-COUNT) ADD M-TEM A-BITBLT-HOR-COUNT)	;Decrease bit count
	((M-Q) SUB M-Q A-J)				;Decrease source bit offset
	(JUMP-LESS-THAN-XCT-NEXT M-ZERO A-BITBLT-HOR-COUNT BITBLT-RTL-LOOP)
       ((M-R) SUB M-R A-J)				;Decrease destination bit offset 
	(JUMP XFALSE)					;Done

;;; Inner loop of vertical BITBLT
;;; Note, does wrap-around in the vertical coordinates of the source
;;; Args:  (none of these are modified)
;;;  A-ALUF alu-function (source is "A" operand)
;;;  M-I left rotate for source word (only low 5 bits looked at)
;;;  M-K selective-deposit B.P. for part of destination to change
;;;  M-S height of column
;;;  M-A source column address (top if M-B positive, bottom inclusive if M-B negative)
;;;  M-B source address increment, M-C source column height
;;;  A-BITBLT-SRC-Y, A-BITBLT-SRC-Y-OFFSET Y coord and word offset thereof
;;;   These determine the initial location referenced in the source column
;;;  M-D destination column address (top if M-E positive, bottom inclusive if M-E negative)
;;;      This is the first destination address referenced
;;;  M-E destination address increment, M-T destination column height
;;; Temps:
;;;  M-1 source address, M-2 destination address, A-BITBLT-TEM rotated source word
;;;  M-3 source rows before wrap-around
;;;  A-BITBLT-COUNT negative rows before done, M-4 loop counter for inner inner loop
;;; Only used in caller:
;;;  M-Q horizontal bit offset in source
;;;  M-R horizontal bit offset in destination
;;;  M-J bit count (width of this column)

BITBLT-INNER-LOOP
	((M-1) SUB M-A A-B)				;Init source address
	((M-1) ADD M-1 A-BITBLT-SRC-Y-OFFSET)		;Offset to actual starting place
	((M-3) SUB M-C A-BITBLT-SRC-Y)			;Number source rows until wrap-around
	((M-2) SUB M-D A-E)				;Init destination address
	(CALL-LESS-THAN M-T A-S TRAP)			;Range-check destination
	    (ERROR-TABLE BITBLT-DESTINATION-TOO-SMALL)
	((A-BITBLT-COUNT) SUB M-ZERO A-S)		;Init negative total row count
BITBLT-INNER-0		;Loops back to here
	(JUMP-GREATER-THAN-XCT-NEXT M-3 A-ZERO BITBLT-INNER-1)	;Check source wrap-around
       ((M-4) SUB M-ZERO A-BITBLT-COUNT)		;Assume we'll be doing all rows at once
	((M-1) SUB M-A A-B)				;Wrap-around, init source address
	((M-3) M-C)					; and row count to top
BITBLT-INNER-1
	(JUMP-GREATER-THAN M-3 A-4 BITBLT-INNER-2)	;Do only up to
	((M-4) M-3)					; next source wrap point
BITBLT-INNER-2
	(POPJ-LESS-OR-EQUAL M-4 A-ZERO)			;Zero-length array, or we're done
	((A-BITBLT-COUNT) ADD M-4 A-BITBLT-COUNT)	;Count down remaining rows
	((M-3) SUB M-3 A-4)				;Count down source rows before wrap
BITBLT-INNER-3		;This is the inner inner loop
	((VMA-START-READ M-1) ADD M-1 A-B)		;Fetch source word
	(CHECK-PAGE-READ)
	((OA-REG-LOW) DPB M-I OAL-MROT A-ZERO)		;Rotate it into position
	((A-BITBLT-TEM) (BYTE-FIELD 32. 0) READ-MEMORY-DATA)
	((VMA-START-READ M-2) ADD M-2 A-E)		;Fetch destination word
	(CHECK-PAGE-READ)
	((OA-REG-LOW) A-ALUF)				;ALU func
	((M-TEM) SETZ READ-MEMORY-DATA A-BITBLT-TEM)	;Combine source and dest
	((A-TEM1) READ-MEMORY-DATA)			;Get onto A side
	((OA-REG-LOW) M-K)				;Store back under byte control
	((WRITE-MEMORY-DATA-START-WRITE)
		SELECTIVE-DEPOSIT M-TEM (BYTE-FIELD 0 0) A-TEM1)
	(CHECK-PAGE-WRITE)
	(JUMP-GREATER-THAN-XCT-NEXT M-4 (A-CONSTANT 1) BITBLT-INNER-3)
       ((M-4) SUB M-4 (A-CONSTANT 1))
	(POPJ-XCT-NEXT)
       (CALL-NOT-EQUAL M-ZERO A-BITBLT-COUNT BITBLT-INNER-0)	;Jump if more to do

;;; Decode array, x, y on the stack into:
;;; M-1	X dimension of array in bits
;;; Q-R	Y dimension of array
;;; M-4 initial Y-coordinate argument
;;; M-Q original X coordinate in bits
;;; M-A word address of selected bit
;;; M-TEM OA-REG-LOW value to convert bytes to bits 
;;; Preserves: M-C, M-I, M-K, M-R, M-ZR (array routines better preserve these)
;;; Doesn't really win with index-offset arrays

BITBLT-DECODE-ARRAY
	;; Shuffle the stack to allow doing AR2 without losing original coordinates
	;; array, X, Y --> X, Y, array, X, Y
	((M-3) C-PDL-BUFFER-POINTER-POP)		;Pop and push turns out to be
	((M-2) C-PDL-BUFFER-POINTER-POP)		; the fastest way, strangely enough
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((C-PDL-BUFFER-POINTER-PUSH) M-2)
	((C-PDL-BUFFER-POINTER-PUSH) M-3)
	((C-PDL-BUFFER-POINTER-PUSH) M-1)
	((C-PDL-BUFFER-POINTER-PUSH) M-2)
	((C-PDL-BUFFER-POINTER-PUSH) M-3)
	(CALL XAR2)					;Access the array in usual way
	;; Leaves following stuff sitting around:
	;; M-A the array, M-E base address, VMA word address
	;; M-D first dimension, M-S product of dimensions, M-B array header
	((M-TEM) (LISP-BYTE %%ARRAY-TYPE-FIELD) M-B)	;Array type.  For a numeric array,
	((M-TEM) SUB M-TEM (A-CONSTANT 1))		; it is 1+ log2 of the byte size.
	(CALL-GREATER-THAN M-TEM (A-CONSTANT 5) TRAP)	;Bigger than 32-bit byte? Non-numeric
	    (ERROR-TABLE NOT-NUMERIC-ARRAY M-A)
	((M-1) Q-POINTER M-S)				;Compute second dimension (in Q-R)
	(CALL-XCT-NEXT DIV)
       ((M-2) Q-POINTER M-D)
	((OA-REG-LOW) M-TEM)				;Rotate first dimension left
	((M-1) (BYTE-FIELD 32. 0) M-2)
	((M-2) (BYTE-FIELD 5 0) M-1)			;Width must be multiple of 32 bits
	(CALL-NOT-EQUAL M-2 A-ZERO TRAP)
	    (ERROR-TABLE BITBLT-ARRAY-FRACTIONAL-WORD-WIDTH M-A)
	((M-4) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;Original Y argument
	((M-3) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;Original X argument
	((OA-REG-LOW) M-TEM)				;Convert X coordinate to bits
	(POPJ-AFTER-NEXT (M-Q) (BYTE-FIELD 32. 0) M-3)
       ((M-A) Q-POINTER VMA)				;Word address of selected bit

;;; PAGE FAULT HANDLER

;PAGE FAULTS GENERALLY DO NOT CLOBBER ANYTHING.
;EXCEPTIONS:
;	THE A-PGF-MUMBLE REGISTERS ARE CLOBBERED.  ONLY THE PAGE FAULT
;		ROUTINES SHOULD USE THEM.
;	M-TEM, A-TEM1, A-TEM2, AND A-TEM3 ARE CLOBBERED.  THEY ARE SUPER-TEMPORARY.
;	THE DISPATCH CONSTANT AND THE Q REGISTER ARE CLOBBERED.
;	THE DATA-TYPE OF VMA -MUST NOT- BE CLOBBERED.
;	THE PDL-BUFFER-INDEX ISN'T CLOBBERED, BUT IT SHOULD BE.
;
;IF AN INTERRUPT OCCURS, IT HAS ALMOST NO SIDE-EFFECTS OTHER THAN WHAT
;PAGE FAULTS HAVE.
;
;IF A SEQUENCE BREAK IS ALLOWED AND OCCURS, IT OCCURS AFTER A WRITE CYCLE
;IS SUCCESSFULLY COMPLETED, BUT EFFECTIVELY BEFORE A READ CYCLE.
;THE MD IS RESET FROM THE VMA.  THE LETTERED M ACS ARE SAVED,
;AND MUST CONTAIN GC MARKABLE STUFF OR DTP TRAP (OR -1).  RANDOM
;MISCELLANEOUS ACS LIKE A-TEM'S ARE CLOBBERED BY SEQUENCE BREAKS.

; DEFINITIONS OF FIELDS IN THE MAP HARDWARE
;  BITS IN MEMORY-MAP-DATA (FUNCTIONAL SOURCE 11).

(DEF-DATA-FIELD MAP-READ-FAULT-BIT 1 30.)
(DEF-DATA-FIELD MAP-WRITE-FAULT-BIT 1 31.)
(DEF-DATA-FIELD MAP-PHYSICAL-PAGE-NUMBER 14. 0)
(DEF-DATA-FIELD MAP-META-BITS 6 14.)    	;THE HIGH TWO OF THESE ARE HACKABLE BY
						; DISPATCH INSTRUCTION
						;THE REST ARE JUST FOR SOFTWARE TO LOOK AT
(DEF-DATA-FIELD MAP-STATUS-CODE 3 20.)
(DEF-DATA-FIELD MAP-ACCESS-CODE 2 22.)		;NOTE BIT 22 IS IN TWO FIELDS
(DEF-DATA-FIELD MAP-FIRST-LEVEL-MAP 5 24.)	;NOTE NOT THE SAME AS WHERE IT WRITES
(DEF-DATA-FIELD MAP-SECOND-LEVEL-MAP 24. 0)
(DEF-DATA-FIELD MAP-ACCESS-STATUS-AND-META-BITS 10. 14.)
(DEF-DATA-FIELD MAP-HARDWARE-READ-ACCESS 1 23.)	;HARDWARE PERMITS (AT LEAST) READ ACCESS
						; IF THIS BIT SET.

;FIELDS IN VMA WHEN WRITING MAP.
(DEF-DATA-FIELD MAP-WRITE-SECOND-LEVEL-MAP 24. 0)
(DEF-DATA-FIELD MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1 25.)
(DEF-DATA-FIELD MAP-WRITE-ENABLE-FIRST-LEVEL-WRITE 1 26.)
(DEF-DATA-FIELD MAP-WRITE-FIRST-LEVEL-MAP 5 27.) ;NOTE NOT THE SAME AS WHERE IT READS

; DEFINITIONS OF FIELDS IN PAGE HASH TABLE

 ;WORD 1
(DEF-DATA-FIELD PHT1-VIRTUAL-PAGE-NUMBER 16. 8)	;ALIGNED SAME AS VMA
(DEF-DATA-FIELD PHT1-SWAP-STATUS-CODE 3 0)
 (DEF-DATA-FIELD PHT1-ALL-BUT-SWAP-STATUS-CODE 29. 3)
(DEF-DATA-FIELD PHT1-MODIFIED-BIT 1 5)		;SET IF PAGE MODIFIED
(DEF-DATA-FIELD PHT1-VALID-BIT 1 6)
 ;WORD 2  THESE ARE NOW THE SAME BIT POSITIONS AS IN THE SECOND LEVEL MAP
(DEF-DATA-FIELD PHT2-META-BITS 6 14.)
(DEF-DATA-FIELD PHT2-MAP-STATUS-CODE 3 20.)
(DEF-DATA-FIELD PHT2-MAP-ACCESS-CODE 2 22.)
(DEF-DATA-FIELD PHT2-ACCESS-STATUS-AND-META-BITS 10. 14.)
(DEF-DATA-FIELD PHT2-PHYSICAL-PAGE-NUMBER 14. 0) 

; DEFINITIONS OF FIELDS IN THE ADDRESS

(DEF-DATA-FIELD VMA-MAP-BLOCK-PART 11. 13.)	;ADDRESS BLOCK OF 32. PAGES
(DEF-DATA-FIELD VMA-PAGE-ADDR-PART 16. 8)	;VIRTUAL PAGE NUMBER
(DEF-DATA-FIELD VMA-PHYS-PAGE-ADDR-PART 14. 8)	;PHYSICAL PAGE NUMBER
(DEF-DATA-FIELD VMA-LOW-BITS 8 0)		;ADDR WITHIN PAGE
(DEF-DATA-FIELD ALL-BUT-VMA-LOW-BITS 24. 8)

;NOTE: PGF-R, ETC CAN BE ENTERED RECURSIVELY IF THE PAGE IS SWAPPED OUT AND THE DISK 
;ROUTINES FAULT WHEN REFERENCING THE DISK CONTROL.

;THESE COMMENTS APPLY TO SEQUENCE BREAK
;INTERRUPT MAY BE INSERTED -AFTER- THE READ CYCLE, HOWEVER
;IT IS EFFECTIVELY BEFORE SINCE ON DISMISS READ-MEMORY-DATA RESTORED FROM VMA!!
;NOTE THAT THIS ORDERING ALLOWS AN EFFECTIVE READ-PAUSE-WRITE CYCLE
;TO BE DONE JUST BY DOING A READ THEN A WRITE, EVEN
;THOUGH AFTER EACH CYCLE IS STARTED INTERRUPTS ARE CHECKED.

;PUSHJ HERE ON PAGE FAULT, INTERRUPT REQUEST, OR SEQUENCE BREAK DURING READ CYCLE
;PGF-R-SB

;PUSHJ HERE ON PAGE FAULT OR INTERRUPT REQUEST DURING READ CYCLE
PGF-R-I	(JUMP-CONDITIONAL NO-PG-FAULT INTR)	;IF NO PG FAULT, TAKE INTERRUPT

;PUSHJ HERE ON READ CYCLE PAGE FAULT WHEN DESIRE NOT TO TAKE INTERRUPT
;GUARANTEED TO RETURN WITHOUT ANY INTERRUPTS HAPPENING, OR ELSE TO GO TO ILLOP
PGF-R	((MD) VMA)				;ADDRESS THE MAP
	(DISPATCH-XCT-NEXT MAP-STATUS-CODE MEMORY-MAP-DATA D-PGF-R)
       ((M-PGF-WRITE) DPB (M-CONSTANT 0) A-FLAGS)
;IF IT RETURNS HERE, WE RESTART THE READ REFERENCE
	((VMA-START-READ) A-PGF-VMA)
	(POPJ-AFTER-NEXT NO-OP)
       (CHECK-PAGE-READ-NO-INTERRUPT)		;DIDN'T ENTIRELY SUCCEED, TRY AGAIN

;PUSHJ HERE ON PAGE FAULT, INTERRUPT, OR SEQUENCE BREAK DURING WRITE CYCLE
;PGF-W-SB

;PUSHJ HERE ON PAGE FAULT OR INTERRUPT REQUEST DURING WRITE CYCLE
PGF-W-I	(JUMP-CONDITIONAL NO-PG-FAULT INTR)	;NO PAGE FAULT, THEN TAKE INTERRUPT

;PUSHJ HERE ON PAGE FAULT WHEN DESIRE NOT TO TAKE INTERRUPT
;GUARANTEED TO RETURN WITH NO INTERRUPT, OR TO GO TO ILLOP
PGF-W	((A-PGF-WMD) MD)			;SAVE DATA BEING WRITTEN
	((MD) VMA)				;ADDRESS THE MAP
	(DISPATCH-XCT-NEXT MAP-STATUS-CODE MEMORY-MAP-DATA D-PGF-W)
       ((M-PGF-WRITE) DPB (M-CONSTANT -1) A-FLAGS)
;IF IT RETURNS HERE, WE RESTART THE WRITE REFERENCE
	((WRITE-MEMORY-DATA) A-PGF-WMD)
	((VMA-START-WRITE) A-PGF-VMA)		; ASSUMES WE WERE TRYING TO DO A WRITE CYCLE
	(POPJ-AFTER-NEXT NO-OP)
       (CHECK-PAGE-WRITE-NO-INTERRUPT)		;DIDN'T ENTIRELY SUCCEED, TRY AGAIN

;HERE ON PAGE FAULT IF READ-ONLY NOT TO BE RESPECTED
;THIS IS IDENTICAL TO PGF-W EXCEPT FOR A DIFFERENT DISPATCH TABLE
PGF-W-FORCE
	((A-PGF-WMD) MD)			;SAVE DATA BEING WRITTEN
	((MD) VMA)				;ADDRESS THE MAP
	(DISPATCH-XCT-NEXT MAP-STATUS-CODE MEMORY-MAP-DATA D-PGF-W-FORCE)
       ((M-PGF-WRITE) DPB (M-CONSTANT -1) A-FLAGS)
;IF IT RETURNS HERE, WE RESTART THE WRITE REFERENCE
	((WRITE-MEMORY-DATA) A-PGF-WMD)
	((VMA-START-WRITE) A-PGF-VMA)		; ASSUMES WE WERE TRYING TO DO A WRITE CYCLE
	(POPJ-AFTER-NEXT NO-OP)
       (CHECK-PAGE-WRITE-FORCE)			;DIDN'T ENTIRELY SUCCEED, TRY AGAIN

(LOCALITY D-MEM)
(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-PGF-R	(P-BIT PGF-MAP-MISS)	;0 LEVEL 1 OR 2 MAP NOT VALID
	(P-BIT PGF-MAP-MISS)	;1 META BITS ONLY, TAKE AS MAP MISS
	(P-BIT ILLOP)		;2 READ ONLY
	(P-BIT ILLOP)		;3 READ/WRITE FIRST
	(P-BIT ILLOP)		;4 READ/WRITE
	(PGF-R-PDL)		;5 MAY BE IN PDL BUFFER
	(PGF-MAR)		;6 POSSIBLE MAR BREAK
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-PGF-W	(P-BIT PGF-MAP-MISS)	;0 LEVEL 1 OR 2 MAP NOT VALID
	(P-BIT PGF-MAP-MISS)	;1 META BITS ONLY, TAKE AS MAP MISS
	(TAKE-MPV-FAULT)	;2 WRITE IN READ ONLY
	(P-BIT PGF-RWF)		;3 WRITE IN READ/WRITE FIRST
	(P-BIT ILLOP)		;4 READ/WRITE
	(PGF-W-PDL)		;5 MAY BE IN PDL BUFFER
	(PGF-MAR)		;6 POSSIBLE MAR BREAK
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-PGF-W-FORCE
	(P-BIT PGF-MAP-MISS)	;0 LEVEL 1 OR 2 MAP NOT VALID
	(P-BIT PGF-MAP-MISS)	;1 META BITS ONLY, TAKE AS MAP MISS
	(FORCE-WR-RDONLY)	;2 WRITE IN READ ONLY
	(P-BIT PGF-RWF)		;3 WRITE IN READ/WRITE FIRST
	(P-BIT ILLOP)		;4 READ/WRITE
	(PGF-W-PDL)		;5 MAY BE IN PDL BUFFER
	(PGF-MAR)		;6 POSSIBLE MAR BREAK
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

;THIS DISPATCH MAKES SURE THAT MAP[MD] IS SET UP. SMASHES VMA, WHATEVER PAGE FAULTS SMASH.
;NOTE THAT IT SWAPS IN THE PAGE MD POINTS TO.
(START-DISPATCH 3 0)		;DISPATCH ON MAP STATUS
D-ASSURE-MAP-VALID
	(P-BIT INHIBIT-XCT-NEXT-BIT AMV)	;0 LEVEL 1 OR 2 MAP NOT VALID
	(P-BIT INHIBIT-XCT-NEXT-BIT AMV)	;1 META BITS ONLY, TAKE AS MAP MISS
	(P-BIT R-BIT)				;2 READ ONLY
	(P-BIT R-BIT)				;3 READ/WRITE FIRST
	(P-BIT R-BIT)				;4 READ/WRITE
	(P-BIT R-BIT)				;5 MAY BE IN PDL BUFFER
	(P-BIT R-BIT)				;6 POSSIBLE MAR BREAK
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 NOT USED
(END-DISPATCH)

;THIS DISPATCH IS FOR GETTING META BITS FROM MAP[MD] WITHOUT SWAPPING IN
;WHAT IT POINTS TO.  SMASHES VMA.
(START-DISPATCH 3 0)
D-GET-MAP-BITS
	(P-BIT INHIBIT-XCT-NEXT-BIT GET-MAP-BITS) ;0 LEVEL 1 OR 2 MAP NOT VALID
	(P-BIT R-BIT)				;1 GOT MAP BITS ANYWAY
	(P-BIT R-BIT)				;2 READ ONLY
	(P-BIT R-BIT)				;3 READ/WRITE FIRST
	(P-BIT R-BIT)				;4 READ/WRITE
	(P-BIT R-BIT)				;5 MAY BE IN PDL BUFFER
	(P-BIT R-BIT)				;6 POSSIBLE MAR BREAK
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 NOT USED
(END-DISPATCH)
(LOCALITY I-MEM)

AMV	((VMA-START-READ) MD)			;MAP NOT SET UP, TAKE FAULT
	(CHECK-PAGE-READ-NO-INTERRUPT)		;BE SURE INTERRUPT DOESN'T DISTURB MAP
	(POPJ-XCT-NEXT)
       ((MD) VMA)				;RESTORE MD (DELAYS UNTIL READ CYCLE OVER)

;MAP MISS WHEN TRYING TO GET META BITS.  GET FROM REGION TABLE, SET UP META-BITS-ONLY STATUS
GET-MAP-BITS
	((A-META-BITS-MAP-RELOADS) ADD M-ZERO A-META-BITS-MAP-RELOADS ALU-CARRY-IN-ONE)
	(CALL-XCT-NEXT PGF-SAVE-1)		;Save MD, M-A, M-B, M-T
       ((A-PGF-VMA) MD)				;Address of reference
	((M-TEM) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)	;Check for level 1 map miss
	(CALL-EQUAL M-TEM (A-CONSTANT 37) LEVEL-1-MAP-MISS)
	((M-A) DPB M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT		;Check for A-memory or I/O address
		M-A (A-CONSTANT LOWEST-A-MEM-VIRTUAL-ADDRESS) GET-MAP-BITS-1)
       ((MD) (A-CONSTANT (PLUS (BYTE-MASK %%REGION-OLDSPACE-META-BIT)
			       (BYTE-MASK %%REGION-EXTRA-PDL-META-BIT)
			       (BYTE-VALUE %%REGION-REPRESENTATION-TYPE
					   %REGION-REPRESENTATION-TYPE-STRUCTURE))))
	(CALL XRGNPF)				;Normal address, get meta bits from region
	(CALL-EQUAL M-T A-V-NIL ILLOP)		;Region not found
	((VMA-START-READ) ADD M-T A-V-REGION-BITS)	;Fetch meta bits
	(ILLOP-IF-PAGE-FAULT)
GET-MAP-BITS-1
	((VMA) SELECTIVE-DEPOSIT READ-MEMORY-DATA MAP-META-BITS
		(A-CONSTANT (PLUS (BYTE-VALUE MAP-STATUS-CODE %PHT-MAP-STATUS-META-BITS-ONLY)
				  (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE))))
	((MD-WRITE-MAP) A-PGF-VMA)
	(JUMP PGF-RESTORE)			;Restore M-A, M-B, M-T
		;Note that POPJ-AFTER-NEXT cannot be used, because we mustn't return
		;with a map-write in progress, since there is no pass-around path
		;on the map, and the caller is going to look at the map in the
		;first instruction returned to.

;PDL BUFFER HANDLING CONVENTIONS:
;  THE LINEAR PUSHDOWN LIST MUST ALWAYS BE COMPOSED OF PAGES FROM AN AREA WHOSE
;REGION-BITS Q HAS %PHT-MAP-STATUS-PDL-BUFFER IN THE MAP STATUS PORTION OF ITS
;%%REGION-MAP-BITS FIELD.  THUS ANY MEMORY CYCLE REF'ING 
;SUCH AN AREA WILL TRAP AND COME HERE, WHERE THE CODE CHECKS TO SEE IF IT IS REALLY
;IN THE PDL-BUFFER NOW.  IF NOT, IT TURNS ON R/W ACCESS TEMPORARILY AND PERFORMS THE
;REQUESTED CYCLE, ETC.
;  THESE PAGES ARE TREATED ENTIRELY AS NORMAL PAGES FOR SWAPPING PURPOSES, AND MAY
;EVEN BE SWAPPED OUT WHILE ACTUALLY RESIDENT IN THE PDL-BUFFER! THE ONLY DIFFERENCE
;IS THAT THE PAGE MUST ALWAYS BE WRITTEN TO THE DISK ON SWAP-OUT, SINCE THE R-W-F
;MECHANISM IS NOT AVAILABLE TO KEEP TRACK OF WHETHER IT HAS ACTUALLY BEEN MODIFIED.
;  PDL-BUFFER-POINTER IS TAKEN TO MARK THE HIGHEST PDL-BUFFER LOCN WHICH IS REALLY VALID.

;READ REFERENCE TO LOCATION THAT MAY BE IN THE PDL BUFFER
PGF-R-PDL	
	((M-PGF-TEM) SUB PDL-BUFFER-POINTER A-PDL-BUFFER-HEAD)
	((M-PGF-TEM) ADD M-PGF-TEM (A-CONSTANT 1))	;*** THIS CODE COULD USE BUMMING ***
	((M-PGF-TEM) (BYTE-FIELD 10. 0) M-PGF-TEM)	;COMPUTE # ACTIVE WDS IN PDL-BUFFER
	((A-PGF-B) ADD M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-PGF-TEM) Q-POINTER VMA)	;GET ADDRESS BEING REFERENCED SANS EXTRA BITS
	(JUMP-LESS-THAN M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS PGF-R-NOT-REALLY-IN-PDL-BUFFER)
	(JUMP-GREATER-THAN M-PGF-TEM A-PGF-B PGF-R-NOT-REALLY-IN-PDL-BUFFER) ;GREATER BECAUSE 
							;(PP) IS A VALID WD.
	;READ REFERENCE TO LOCATION THAT IS IN THE PDL BUFFER
	((A-PDL-BUFFER-READ-FAULTS) ADD A-PDL-BUFFER-READ-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((M-PGF-TEM) SUB M-PGF-TEM 
		A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;GET RELATIVE PDL LOC REFERENCED
	((A-PGF-A) PDL-BUFFER-INDEX)	;DON'T CLOBBER PDL-BUFFER-INDEX
	((PDL-BUFFER-INDEX) ADD M-PGF-TEM A-PDL-BUFFER-HEAD)	;TRUNCATES TO 10 BITS
	(POPJ-AFTER-NEXT (MD) C-PDL-BUFFER-INDEX)
       ((PDL-BUFFER-INDEX) A-PGF-A)

;READ REFERENCE TO LOCATION NOT IN THE PDL BUFFER, BUT IT MIGHT HAVE BEEN.
PGF-R-NOT-REALLY-IN-PDL-BUFFER	
	((A-PDL-BUFFER-MEMORY-FAULTS) ADD A-PDL-BUFFER-MEMORY-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((M-PGF-TEM) MAP-SECOND-LEVEL-MAP MEMORY-MAP-DATA)	;SAVE CORRECT MAP CONTENTS
	((VMA-WRITE-MAP) IOR M-PGF-TEM		;TURN ON ACCESS
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3)))) ;R/W
	((VMA-START-READ) MD)			;READ OUT THAT LOCATION
	(ILLOP-IF-PAGE-FAULT)			;I THOUGHT WE JUST TURNED ON ACCESS
	((A-PGF-WMD) READ-MEMORY-DATA)		;SAVE CONTENTS 
	((MD) VMA)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	(POPJ-AFTER-NEXT			;RESTORE REGISTERS AND RETURN
	 (VMA) MD)
       ((MD) A-PGF-WMD)

;WRITE REFERENCE TO LOCATION THAT MAY BE IN THE PDL BUFFER
PGF-W-PDL	
	((M-PGF-TEM) SUB PDL-BUFFER-POINTER A-PDL-BUFFER-HEAD)
	((M-PGF-TEM) ADD M-PGF-TEM (A-CONSTANT 1))	;*** THIS CODE COULD USE BUMMING ***
	((M-PGF-TEM) (BYTE-FIELD 10. 0) M-PGF-TEM)	;COMPUTE # ACTIVE WDS IN PDL-BUFFER
	((A-PGF-B) ADD M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS) ;HIGHEST VIRT LOC IN P.B,
	((M-PGF-TEM) Q-POINTER VMA)	;GET ADDRESS BEING REFERENCED SANS EXTRA BITS
	(JUMP-LESS-THAN M-PGF-TEM A-PDL-BUFFER-VIRTUAL-ADDRESS PGF-W-NOT-REALLY-IN-PDL-BUFFER)
	(JUMP-GREATER-THAN M-PGF-TEM A-PGF-B PGF-W-NOT-REALLY-IN-PDL-BUFFER) ;GREATER BECAUSE
							;(PP) IS A VALID WD
	;WRITE REFERENCE TO LOCATION THAT IS IN THE PDL BUFFER
	((A-PDL-BUFFER-WRITE-FAULTS) ADD A-PDL-BUFFER-WRITE-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((M-PGF-TEM) SUB M-PGF-TEM 
		A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;GET RELATIVE PDL LOC REFERENCED
	((A-PGF-A) PDL-BUFFER-INDEX)	;DON'T CLOBBER PDL-BUFFER-INDEX
	((PDL-BUFFER-INDEX) ADD M-PGF-TEM A-PDL-BUFFER-HEAD)	;TRUNCATES TO 10 BITS
	((MD) A-PGF-WMD)
	(POPJ-AFTER-NEXT
	 (C-PDL-BUFFER-INDEX) MD)	;DO THE WRITE
       ((PDL-BUFFER-INDEX) A-PGF-A)	;RESTORE REGS AND RETURN FROM FAULT

;WRITE REFERENCE TO LOCATION NOT IN THE PDL BUFFER, BUT IT MIGHT HAVE BEEN
PGF-W-NOT-REALLY-IN-PDL-BUFFER	
	((A-PDL-BUFFER-MEMORY-FAULTS) ADD A-PDL-BUFFER-MEMORY-FAULTS M-ZERO ALU-CARRY-IN-ONE)
	((M-PGF-TEM) MAP-SECOND-LEVEL-MAP MEMORY-MAP-DATA)	;SAVE CORRECT MAP CONTENTS
	((VMA-WRITE-MAP) IOR M-PGF-TEM		;TURN ON ACCESS
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3)))) ;R/W
	((VMA) MD)				;WRITE INTO THAT LOCATION
	((WRITE-MEMORY-DATA-START-WRITE) A-PGF-WMD)
	(ILLOP-IF-PAGE-FAULT)			;I THOUGHT WE JUST TURNED ON ACCESS
	((MD) VMA)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	(POPJ-AFTER-NEXT			;RESTORE REGISTERS AND RETURN
	 (VMA) MD)
       ((MD) A-PGF-WMD)

;SAVE REGISTERS UPON ENTERING PAGE FAULT HANDLER
PGF-SAVE
	((A-PGF-VMA) VMA)
PGF-SAVE-1
	((A-PGF-A) M-A)
	(POPJ-AFTER-NEXT (A-PGF-B) M-B)
       ((A-PGF-T) M-T)

;RESTORE REGISTERS AND LEAVE PAGE FAULT HANDLER
;DOESN'T RESTORE VMA SINCE CYCLE RESTARTER (POPJED TO) WILL DO THAT
PGF-RESTORE	
	((M-A) A-PGF-A)
	(POPJ-AFTER-NEXT (M-B) A-PGF-B)
       ((M-T) A-PGF-T)

;ROUTINE TO HANDLE LEVEL-1 MAP MISSES.  CALLED FROM PGF-MAP-MISS AND FROM GET-MAP-BITS.
;ADDRESS IN MD ON CALL AND RETURN, VMA CLOBBERED.  PGF-SAVE MUST HAVE BEEN CALLED.
LEVEL-1-MAP-MISS
	((A-FIRST-LEVEL-MAP-RELOADS) ADD A-FIRST-LEVEL-MAP-RELOADS M-ZERO ALU-CARRY-IN-ONE)
	((M-T) A-SECOND-LEVEL-MAP-REUSE-POINTER)	;ALLOCATE A BLOCK OF LVL 2 MAP
	((MD M-A) SELECTIVE-DEPOSIT MD VMA-MAP-BLOCK-PART A-ZERO) ;-> 1ST ENTRY IN BLOCK
	((VMA-WRITE-MAP) DPB M-T MAP-WRITE-FIRST-LEVEL-MAP	;POINT 1ST LVL AT IT
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-FIRST-LEVEL-WRITE)))
	((M-PGF-TEM) ADD M-T (A-CONSTANT 40))		;REVERSE 1ST LVL MAP IN 40-77 OF
	((VMA-START-READ) ADD M-PGF-TEM A-V-SYSTEM-COMMUNICATION-AREA)  ;SYS COM AREA.
	(ILLOP-IF-PAGE-FAULT)				;THIS POINTS MD AT THE OLD MAP
	(JUMP-LESS-THAN READ-MEMORY-DATA A-ZERO PGF-L1C) ;DON'T WRITE MAP IF NO PREVIOUS
	((VMA-WRITE-MAP) DPB				;AND 37-IFY OLD 1ST LVL MAP
		(M-CONSTANT -1) MAP-WRITE-FIRST-LEVEL-MAP	;ENTRY SO WILL FAULT IF USED
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-FIRST-LEVEL-WRITE)))
	((VMA) ADD M-PGF-TEM A-V-SYSTEM-COMMUNICATION-AREA)
PGF-L1C	((WRITE-MEMORY-DATA-START-WRITE) M-A)		;UPDATE REVERSE FIRST LVL MAP
	(ILLOP-IF-PAGE-FAULT)				;THIS POINTS MD AT 1ST ENTRY IN BLOCK
	((M-T) (M-CONSTANT 40))				;DO ALL 32. ENTRIES IN BLOCK
PGF-L1A	((VMA-WRITE-MAP)				;FILL 2ND-LEVEL MAP WITH MAP-MISS (0)
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	((MD M-A) ADD M-A (A-CONSTANT (BYTE-VALUE VMA-PAGE-ADDR-PART 1)))
	(JUMP-GREATER-THAN-XCT-NEXT M-T (A-CONSTANT 1) PGF-L1A)
       ((M-T) SUB M-T (A-CONSTANT 1))
	((MD) A-PGF-VMA)				;RESTORE MD (ADDRESS OF REFERENCE)
	;DROP THROUGH ADVANCE-SECOND-LEVEL-MAP-REUSE-POINTER, AND RETURN
;ROUTINE TO ADVANCE SECOND LEVEL MAP REUSE POINTER, WITH CARE.  CLOBBERS Q-R
ADVANCE-SECOND-LEVEL-MAP-REUSE-POINTER	
	((Q-R A-SECOND-LEVEL-MAP-REUSE-POINTER)
		ADD M-ZERO A-SECOND-LEVEL-MAP-REUSE-POINTER ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT POPJ-LESS-THAN Q-R (A-CONSTANT 37))
       ((A-SECOND-LEVEL-MAP-REUSE-POINTER)
		A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT)	;WRAP AROUND TO AFTER THE WIRED ONES

;MAP MISS COMES HERE.  ADDRESS IN VMA AND MD BOTH.
;SET UP FIRST-LEVEL MAP IF NECESSARY.  THEN DEAL WITH PAGE-FAULT.
PGF-MAP-MISS
	(CALL-XCT-NEXT PGF-SAVE)	;SAVE A,B,T,VMA
       ((M-TEM) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)	;CHECK FOR 1ST-LEVEL MISS
	(CALL-EQUAL M-TEM (A-CONSTANT 37) LEVEL-1-MAP-MISS)
	;; MD HAS ADDRESS, VMA SAVED AND CLOBBERED.  HANDLE 2ND-LEVEL MISS
	((A-SECOND-LEVEL-MAP-RELOADS) ADD A-SECOND-LEVEL-MAP-RELOADS M-ZERO ALU-CARRY-IN-ONE)
	((M-T) SELECTIVE-DEPOSIT M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA) ;ADDRESS SANS EXTRA BITS
	(JUMP-LESS-THAN M-T (A-CONSTANT LOWEST-A-MEM-VIRTUAL-ADDRESS) PGF-L2A)
	(JUMP-LESS-THAN M-T (A-CONSTANT LOWEST-IO-SPACE-VIRTUAL-ADDRESS)
		PGF-SPECIAL-A-MEMORY-REFERENCE)
;REFERENCE TO UNIBUS OR X-BUS IO VIRTUAL ADDRESS.  FAKE UP PAGE HASH TABLE ENTRY
	((M-T) VMA-PHYS-PAGE-ADDR-PART M-T
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	((M-A) (A-CONSTANT 1460))		;RW ACCESS, STATUS=4, NO AREA TRAPS, REP TYPE 0
	(JUMP-XCT-NEXT PGF-RESTORE)		;GO RETRY REFERENCE
       ((VMA-WRITE-MAP) DPB M-A MAP-ACCESS-STATUS-AND-META-BITS A-T)

;REFERENCE TO ORDINARY VIRTUAL ADDRESS.  LOOK IN PAGE HASH TABLE
PGF-L2A	(CALL SEARCH-PAGE-HASH-TABLE)
	(DISPATCH PHT1-SWAP-STATUS-CODE READ-MEMORY-DATA D-PGF-PHT) ;FOUND, CHK SW STS

(LOCALITY D-MEM)
(START-DISPATCH 3 INHIBIT-XCT-NEXT-BIT)	;DISPATCH ON SWAP STATUS
D-PGF-PHT	
	(SWAPIN)		;0 PHT ENTRY INVALID, GET PAGE FROM DISK
	(PGF-RL)		;1 NORMAL, RELOAD PAGE MAP
	(PGF-FL)		;2 FLUSHABLE, CHANGE BACK TO NORMAL
	(P-BIT ILLOP)		;3 NOT USED, WAS PDL BUFFER
	(PGF-AG)		;4 AGE, CHANGE BACK TO NORMAL
	(PGF-RL)		;5 WIRED DOWN, RELOAD PAGE MAP
	(P-BIT ILLOP)		;6 NOT USED
	(P-BIT ILLOP)		;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)	;DROP THROUGH IF MAR BREAK NOT TO GO OFF, ELSE CALL TRAP
D-MAR	(P-BIT R-BIT)				;0 READ, MAR DISABLED
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;1 READ, READ-TRAP
	(P-BIT R-BIT)				;2 READ, WRITE-TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;3 READ, READ-WRITE-TRAP
	(P-BIT R-BIT)				;4 WRITE, MAR DISABLED
	(P-BIT R-BIT)				;5 WRITE, READ-TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;6 WRITE, WRITE-TRAP
	(P-BIT INHIBIT-XCT-NEXT-BIT TRAP)	;7 WRITE, READ-WRITE-TRAP
(END-DISPATCH)
(LOCALITY I-MEM)

;HERE ON REFERENCE TO PAGE CONTAINING THE MAR'ED LOCATION
PGF-MAR	((M-PGF-TEM) M-FLAGS-NO-SEQUENCE-BREAK)	;If can't take trap now
	(JUMP-NOT-EQUAL M-PGF-TEM A-ZERO PGF-MAR1) ;then don't take one
	((M-PGF-TEM) Q-POINTER VMA (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(JUMP-LESS-THAN M-PGF-TEM A-MAR-LOW PGF-MAR1)	;CHECK ADDRESS BOUNDS
	(JUMP-GREATER-THAN M-PGF-TEM A-MAR-HIGH PGF-MAR1)
	(DISPATCH M-FLAGS-MAR-DISP D-MAR)	;TAKE MAR BREAK IF NECESSARY
   (ERROR-TABLE MAR-BREAK) ;This is a special entry which the EH knows all about.
PGF-MAR1	
	;FALSE ALARM, SIMULATE THE MEMORY CYCLE
	;BUT IT MIGHT BE IN THE PDL BUFFER, SO SIMULATE THAT TRAP
	;ANYWAY THAT CODE IS PRETTY EXPERIENCED AT SIMULATING MEMORY CYCLES
	(JUMP-IF-BIT-CLEAR M-PGF-WRITE PGF-R-PDL)
	(JUMP PGF-W-PDL)

;HERE ON REFERENCE TO LOCATION MAPPED INTO A/M SCRATCHPAD, ADDRESS IN M-T
PGF-SPECIAL-A-MEMORY-REFERENCE
	(JUMP-IF-BIT-SET-XCT-NEXT M-PGF-WRITE PGF-SA-W)	;JUMP IF CYCLE IS A WRITE
       ((M-GARBAGE) MICRO-STACK-PNTR-AND-DATA-POP)	;FLUSH RETRY-CYCLE RETURN
	((OA-REG-HIGH) DPB M-T OAH-A-SRC A-ZERO)	 ;NOTE LOWEST-A-MEM-VIRTUAL-ADDRESS 
	((MD) A-GARBAGE)			 ;MUST BE 0 MODULO A-MEMORY SIZE
	(JUMP-XCT-NEXT PGF-RESTORE)
       ((VMA) A-PGF-VMA)		;NOBODY ELSE WILL PUT BACK VMA

PGF-SA-W((M-A) (BYTE-FIELD 10. 0) M-T)
	(JUMP-LESS-THAN M-A (A-CONSTANT 40) PGF-SM-W)  ;LOCN REALLY IN M-MEM.
	((OA-REG-LOW) DPB M-T OAL-A-DEST A-ZERO)
	((A-GARBAGE) A-PGF-WMD)
	((MD) A-PGF-WMD)
	(JUMP-XCT-NEXT PGF-RESTORE)
       ((VMA) A-PGF-VMA)		;NOBODY ELSE WILL PUT BACK VMA

PGF-SM-W((OA-REG-LOW) DPB M-T OAL-M-DEST A-ZERO)
	((M-GARBAGE MD) A-PGF-WMD)
	(JUMP-XCT-NEXT PGF-RESTORE)
       ((VMA) A-PGF-VMA)		;NOBODY ELSE WILL PUT BACK VMA

;Write in read-only.  Could trap, checking whether legal to do so.
TAKE-MPV-FAULT				
	((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-INHIBIT-READ-ONLY)
	(CALL-EQUAL M-TEM A-V-NIL ILLOP)
		;drop into FORCE-WR-RDONLY
;Forced write in nominally read-only area.
;Second-level map is set-up and grants read-only access.
FORCE-WR-RDONLY
	(CALL PGF-SAVE)
	((VMA-WRITE-MAP) (BYTE-FIELD 22. 0) MEMORY-MAP-DATA	;Force read/write access
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3))))
	((VMA) A-PGF-VMA)		;Restore original VMA
	((MD-START-WRITE) A-PGF-WMD)	;Do the write
	(ILLOP-IF-PAGE-FAULT)
	((MD) VMA)			;Address map again
	((VMA-WRITE-MAP) (BYTE-FIELD 22. 0) MEMORY-MAP-DATA	;Set read-only access again
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 2))))
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)	;Find PHT entry to mark page as modified
       ((M-T) A-PGF-VMA)
	(CALL-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA ILLOP) ;not found?
	((WRITE-MEMORY-DATA-START-WRITE)
		IOR READ-MEMORY-DATA (A-CONSTANT (BYTE-MASK PHT1-MODIFIED-BIT)))
	(ILLOP-IF-PAGE-FAULT)
	(CALL PGF-RESTORE)
	(POPJ-AFTER-NEXT		;Memory cycle completed, return
	 (VMA) A-PGF-VMA)
       ((MD) A-PGF-WMD)

;HERE FOR READ-WRITE-FIRST TRAP
;FIND PAGE HASH TABLE ENTRY, CHANGE STATUS TO READ/WRITE, AND RELOAD MAP
PGF-RWF	(CALL PGF-SAVE)
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)
       ((M-T) A-PGF-VMA)
	(CALL-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA ILLOP)	;NOT IN PHT??
	((WRITE-MEMORY-DATA-START-WRITE)		;MARK PAGE MODIFIED
		IOR READ-MEMORY-DATA (A-CONSTANT (BYTE-MASK PHT1-MODIFIED-BIT)))
	(ILLOP-IF-PAGE-FAULT)
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))	;GET SECOND WORD
	(ILLOP-IF-PAGE-FAULT)				;TABLE SUPPOSED TO BE WIRED
	((M-A) A-PGF-A)					;RESTORE A REG DURING MEM CYCLE
	((M-T) (A-CONSTANT 4))				;NORMAL STATUS
	((M-B) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE M-T) DPB M-T
		PHT2-MAP-STATUS-CODE A-B)
	(ILLOP-IF-PAGE-FAULT)
	((M-B) A-PGF-B)
	((MD) A-PGF-VMA)				;ADDRESS THE MAP
	(POPJ-AFTER-NEXT				;PHT2 IS IDENTICAL TO 2ND LVL MAP
	 (VMA-WRITE-MAP) MAP-WRITE-SECOND-LEVEL-MAP M-T
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
       ((M-T) A-PGF-T)					;GO RETRY MEMORY CYCLE

;REFERENCE TO PAGE MARKED FLUSHABLE.  WE WANT THIS PAGE AFTER ALL, CHANGE BACK TO NORMAL
PGF-FL	
;REFERENCE TO PAGE WITH AGE TRAP.  CHANGE BACK TO NORMAL TO INDICATE PAGE
;HAS BEEN REFERENCED, AND SHOULDN'T BE SWAPPED OUT OR MADE FLUSHABLE.
PGF-AG	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
		PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT 1))	;SW STS := NORMAL
	(ILLOP-IF-PAGE-FAULT)				;THEN DROP THROUGH

;RELOAD HARDWARE MAP FROM PAGE HASH TABLE
PGF-RL	((MD) A-PGF-VMA)				;ADDRESS THE MAP
	((M-T) MAP-FIRST-LEVEL-MAP MEMORY-MAP-DATA)
	(CALL-EQUAL M-T (A-CONSTANT 37) ILLOP)		;ABOUT TO CLOBBER
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))	;GET SECOND WORD OF PHT ENTRY
	(ILLOP-IF-PAGE-FAULT)				;TABLE SUPPOSED TO BE WIRED
	((M-A) A-PGF-A)					;RESTORE REGS DURING MEM CYCLE
	((M-B) A-PGF-B)
	(DISPATCH PHT2-MAP-STATUS-CODE READ-MEMORY-DATA D-SWAPAR)	;VERIFY THE BITS
		;; This will go to ILLOP if this is a page of a free region
	((VMA) MAP-WRITE-SECOND-LEVEL-MAP READ-MEMORY-DATA	;VALUE TO WRITE INTO MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	(POPJ-AFTER-NEXT				;COMES DIRECTLY FROM PHT2
	 (MD-WRITE-MAP) A-PGF-VMA)			;WRITE THE MAP AND RETURN
       ((M-T) A-PGF-T)

;ROUTINE TO LOOK FOR PAGE ADDRESSED BY M-T IN THE PAGE HASH TABLE
;RETURNS WITH VMA AND READ-MEMORY-DATA POINTING TO PHT1 WORD,
;OR VMA POINTING TO FIRST HOLE IN HASH TABLE AND PHT1-VALID-BIT
;OF READ-MEMORY-DATA ZERO.  IN THIS CASE, THE SWAP STATUS FIELD
;OF READ-MEMORY-DATA WILL ALSO BE ZERO.  CLOBBERS M-A, M-B, M-T, A-TEM1, A-TEM3

SEARCH-PAGE-HASH-TABLE	
	((A-TEM3) M-T)				;SAVE FOR COMPARISON BELOW
	(CALL COMPUTE-PAGE-HASH)		;M-T := HASH (M-T)
SPHT1	((M-T) AND M-T A-PHT-INDEX-MASK)
	((VMA-START-READ) ADD A-V-PAGE-TABLE-AREA M-T)	;GET PHT ENTRY
	(ILLOP-IF-PAGE-FAULT)			;SUPPOSED TO BE WIRED
	((M-T) ADD M-T (A-CONSTANT 2))		;BUMP INDEX IN CASE
	(POPJ-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA) ;PAGE NOT IN PHT
	((M-A) XOR A-TEM3 READ-MEMORY-DATA)	;XOR VIRTUAL ADDRESSES
	(POPJ-AFTER-NEXT			;(HOPING WE'LL WIN AND RETURN)
	 (M-B) PHT1-VIRTUAL-PAGE-NUMBER M-A)	;ZERO IF MATCH
       (CALL-NOT-EQUAL M-B A-ZERO SPHT1)	;IF NOT FOUND, TRY NEXT

XCPH (MISC-INST-ENTRY %COMPUTE-PAGE-HASH)
	((M-T) Q-POINTER C-PDL-BUFFER-POINTER-POP)
COMPUTE-PAGE-HASH	
	((A-TEM1) (BYTE-FIELD 10. 14.) M-T)	;VMA<23:14>
	((M-T) (BYTE-FIELD 18. 6) M-T)		;VMA<23:8>x4+C
	((M-T) ANDCA M-T (A-CONSTANT 3))	;-C
	((M-T) XOR M-T A-TEM1)
	(POPJ-AFTER-NEXT
	 (M-T) AND M-T A-PHT-INDEX-MASK)
       ((M-T) DPB M-T Q-POINTER (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

;COMES HERE WHEN A PAGE NEEDS TO BE READ IN FROM DISK.
;
;FIRST, FIND SOME MEMORY.  ENTER A PIPELINED LOOP THAT SEARCHES PAGE HASH TABLE
;AT MEMORY SPEED, STARTING FROM LAST PLACE STOPPED, FOR A FLUSHABLE PAGE.  IF NONE
;FOUND, SEARCH INSTEAD FOR ANY NON WIRED PAGE. (THE EMERGENCY CASE.)
;
;HAVING FOUND A PAGE TO REPLACE, WRITE IT TO THE DISK IF NECESSARY.  THEN DELETE
;THAT ENTRY FROM THE PAGE HASH TABLE (HARD), AND FROM THE HARDWARE MAP (EASY).
;
;PERFORM THE DISK READ INTO THE CORE PAGE THUS MADE FREE.
;
;USE A PIPELINED LOOP TO SEARCH THE REGION TABLES AT MEMORY SPEED TO FIND THE
;REGION CONTAINING THE PAGE BEING REFERENCED, AND GET THE META BITS.
;
;NOW RE-HASH THE ADDRESS ORIGINALLY BEING
;REFERENCED TO FIND THE FIRST HOLE (MAY HAVE MOVED DUE TO DELETION) AND PUT
;IN AN ENTRY FOR THAT PAGE.  RESTART THE REFERENCE (SET UP THE MAP FIRST?)
;
;
;THIS IS FIRST TRY AT THIS CODE.  MAKES NO ATTEMPT TO OVERLAP TABLE LOOK UPS
;WITH DISK I/O.  MAKES NO ATTEMPT TO DO DISK WRITES WHILE THE MACHINE IS RUNNING.
;MAKES NO ATTEMPT TO USE SYSTEM
;COMMUNICATION AREA, NOR TO SIGNAL SWAP-SCHEDULER PROCESS WHEN FLUSHABLE MEMORY
;GETS LOW, NOR EVEN TO KEEP TRACK OF AMOUNT OF FLUSHABLE MEMORY.
;
;NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
;THIS CODE ASSUMES THAT THE LOCATION IMMEDIATELY FOLLOWING PAGE-TABLE-AREA
;IS WIRED.  THIS SIMPLIFIES THE TERMINATION CONDITION FOR "PIPELINED" SEARCHES.

SWAPIN	(CALL-IF-BIT-SET M-INTERRUPT-FLAG ILLOP)	;UH UH, NO PAGING FROM INTERRUPTS
	(JUMP-IF-BIT-CLEAR-XCT-NEXT M-SCAVENGE-FLAG SWAPIN0)
       ((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC SWAPIN1))) ;CONTINUATION AFTER FINDCORE
	((M-TEM) DPB M-ZERO Q-ALL-BUT-TYPED-POINTER A-SCAVENGER-WS-ENABLE)
	(JUMP-EQUAL M-TEM A-V-NIL SWAPIN0)
	;; Page being brought in by the scavenger.  Attempt to replace another
	;; such page rather than kicking out part of the user's working set.
	((M-TEM) A-SCAV-PAGE-TABLE-PTR)			;A-mem address
	((OA-REG-HIGH) DPB M-TEM OAH-A-SRC A-ZERO)
	((M-T) A-GARBAGE)				;Get -1 or VA of page to replace
	((OA-REG-LOW) DPB M-TEM OAL-A-DEST A-ZERO)
	((A-GARBAGE) DPB M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA)	;Put this page there
	(JUMP-LESS-THAN-XCT-NEXT M-TEM
		(A-CONSTANT (PLUS (A-MEM-LOC A-SCAV-PAGE-TABLE) SCAV-WS-SIZE -1)) SWAPIN00)
       ((A-SCAV-PAGE-TABLE-PTR) ADD M-TEM (A-CONSTANT 1))
	((A-SCAV-PAGE-TABLE-PTR) (A-CONSTANT (A-MEM-LOC A-SCAV-PAGE-TABLE)))
SWAPIN00
	(JUMP-LESS-THAN M-T A-ZERO SWAPIN0)		;Jump if no replacement page
	(CALL SEARCH-PAGE-HASH-TABLE)			;See if replacement page really in
	((M-B) VMA)					;PHT entry address
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA SWAPIN0)	;nope
	(DISPATCH PHT1-SWAP-STATUS-CODE READ-MEMORY-DATA D-SCAV-SWAPOUT)  ;Check for wired
       ((M-A) READ-MEMORY-DATA)				;Go to COREFOUND1

XFINDCORE (MISC-INST-ENTRY %FINDCORE)
	((MICRO-STACK-DATA-PUSH) (A-CONSTANT (I-MEM-LOC RETURN-M-B)))
SWAPIN0	((M-B) A-V-PAGE-TABLE-AREA)
	((M-T) ADD M-B A-FINDCORE-SCAN-POINTER)	;RESUME SCAN FROM WHERE LEFT OFF
	((M-B) ADD M-B A-PHT-INDEX-MASK)	;BOUND (HIGHEST PHT ENTRY ADDRESS)
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT
			M-T A-B FINDCORE2)	;IF ALREADY AT END, SKIP FIRST LOOP
       ((M-A) A-ZERO)				;PRELOAD BUFFER WITH INVALID CODE	
						;DROP INTO PIPELINE LOOP
;SEARCH THROUGH PHT FOR A FLUSHABLE PAGE, AT MEMORY SPEED.  NOTE PAGE FAULTS CAN'T HAPPEN.
;THIS LOOP GOES FROM THE STARTING POINT TO THE END OF THE TABLE.
FINDCORE1
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(ILLOP-IF-PAGE-FAULT)				;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A D-FINDCORE)	;SEE IF PREVIOUS ONE WINS
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE1)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE

;SECOND TIME AROUND.  SEARCH THE WHOLE TABLE.  PRESUMABLY WILL FIND SOMETHING
;BEFORE WE REACH ORIGINAL STARTING POINT.
FINDCORE2
	((M-T) A-V-PAGE-TABLE-AREA)			;START FROM BEGINNING
	((M-T) SUB M-T (A-CONSTANT 2))
	((M-A) A-ZERO)
FINDCORE3	
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(ILLOP-IF-PAGE-FAULT)				;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A D-FINDCORE)	;SEE IF PREVIOUS ONE WINS
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE3)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE

;*EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY* *EMERGENCY*
;CAN'T FIND ANY CORE.  WELL, JUST GRAB ANY PAGE AT RANDOM, MORE OR LESS.
	((M-T) A-FINDCORE-SCAN-POINTER)			;START FROM "RANDOM" PLACE
FINDCORE4	
	((M-T) ADD M-T A-V-PAGE-TABLE-AREA)
	((M-A) A-ZERO)					;INIT THE PIPELINE
FINDCORE5	
	((VMA-START-READ M-T) ADD M-T (A-CONSTANT 2))	;GET NEXT PHT ENTRY
	(ILLOP-IF-PAGE-FAULT)				;SHOULDN'T FAULT
	(DISPATCH PHT1-SWAP-STATUS-CODE M-A		;SEE IF PREVIOUS ONE WINS
			 D-FINDCORE-EMERGENCY)
	(JUMP-LESS-OR-EQUAL-XCT-NEXT M-T A-B FINDCORE5)	;LOOP UNLESS OUT OF BOUNDS
       ((M-A) READ-MEMORY-DATA)				;SAVE RESULT OF THIS MEMORY CYCLE
	(JUMP-XCT-NEXT FINDCORE4)			;OUT OF BOUNDS, WRAP AROUND
       ((M-T) SUB M-ZERO (A-CONSTANT 2))		;IF NO FREE MEM, INFINITE LOOP

(LOCALITY D-MEM)
(START-DISPATCH 3 0)		;DISPATCH TABLE TO LOOK FOR FLUSHABLE PAGES
D-FINDCORE			;DISPATCH ON SWAP STATUS
	(P-BIT R-BIT)			;0 ILLEGAL
	(P-BIT R-BIT)			;1 NORMAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);2 FLUSHABLE
	(P-BIT R-BIT)			;3 NOT USED, WAS PDL BUFFER
	(P-BIT R-BIT)			;4 AGE TRAP
	(P-BIT R-BIT)			;5 WIRED DOWN
	(P-BIT R-BIT)			;6 NOT USED
	(P-BIT R-BIT)			;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;SAME FOR WHEN DESPERATE
D-FINDCORE-EMERGENCY		;DISPATCH ON SWAP STATUS
	(P-BIT R-BIT)			;0 ILLEGAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);1 NORMAL
	(INHIBIT-XCT-NEXT-BIT COREFOUND);2 FLUSHABLE
	(P-BIT R-BIT)			;3 NOT USED, WAS PDL BUFFER
	(INHIBIT-XCT-NEXT-BIT COREFOUND);4 AGE TRAP
	(P-BIT R-BIT)			;5 WIRED DOWN
	(P-BIT R-BIT)			;6 NOT USED
	(P-BIT R-BIT)			;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;FOR SWAP-OUT CANDIDATE FROM SCAV WORKING-SET
D-SCAV-SWAPOUT			;DISPATCH ON SWAP STATUS
	(INHIBIT-XCT-NEXT-BIT SWAPIN0)	;0 ILLEGAL
	(COREFOUND1)			;1 NORMAL - TAKE
	(COREFOUND1)			;2 FLUSHABLE - TAKE
	(INHIBIT-XCT-NEXT-BIT SWAPIN0)	;3 NOT USED, WAS PDL BUFFER
	(COREFOUND1)			;4 AGE TRAP - TAKE
	(INHIBIT-XCT-NEXT-BIT SWAPIN0)	;5 WIRED DOWN
	(INHIBIT-XCT-NEXT-BIT SWAPIN0)	;6 NOT USED
	(INHIBIT-XCT-NEXT-BIT SWAPIN0)	;7 NOT USED
(END-DISPATCH)

(START-DISPATCH 3 0)		;DISPATCH TABLE TO DROP THROUGH IF PAGE NEEDS WRITING
D-WRITEBACK-NEEDED		;DISPATCH ON MAP STATUS
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;0 ILLEGAL (LVL 1 MAP)
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;1 ILLEGAL (LVL 2 MAP)
	(COREFOUND2)				;2 READ ONLY
	(COREFOUND2)				;3 READ/WRITE FIRST
	(P-BIT R-BIT)				;4 READ/WRITE - INDICATES PAGE MODIFIED
	(P-BIT R-BIT)				;5 PDL BUFFER, ALWAYS WRITE PDL-BUFFER PAGES
						;   SINCE R/W/F MECHANISM NOT AVAILABLE.
	(P-BIT R-BIT)				;6 MAR BREAK, ALWAYS WRITE FOR SAME REASON
	(INHIBIT-XCT-NEXT-BIT P-BIT ILLOP)	;7 ILLEGAL (NOT USED)
(END-DISPATCH)
(LOCALITY I-MEM)

;HERE WHEN WE'VE FOUND A PAGE TO EVICT
COREFOUND	
	(JUMP-LESS-OR-EQUAL M-T A-V-PAGE-TABLE-AREA COREFOUND1)  ;IF WRAP AROUND, ALREADY IN B
	((M-B) SUB M-T (A-CONSTANT 2))			;COMPUTE PHT ENTRY ADDRESS
;CALL HERE FROM XDPPG
;AT THIS POINT, M-A HAS PHT1 AND M-B HAS THE ADDRESS OF PHT1
COREFOUND1
	(CALL-NOT-EQUAL A-PAGE-TRACE-PTR M-ZERO PAGE-TRACE-OUT) ;TRACE PAGE EVICTION
	;; Remove from scavenger working-set, if present
	((M-TEM) (A-CONSTANT (A-MEM-LOC A-SCAV-PAGE-TABLE)))
SCAV-WS-OUT-1
	((OA-REG-HIGH) DPB M-TEM OAH-A-SRC A-ZERO)
	((Q-R) XOR M-A A-GARBAGE)			;Compare virtual address in WS
	((A-TEM1) VMA-PAGE-ADDR-PART Q-R)		;table against PHT1 of evicted page
	(JUMP-EQUAL A-TEM1 M-ZERO SCAV-WS-OUT-2)
	(JUMP-LESS-THAN-XCT-NEXT M-TEM
		(A-CONSTANT (PLUS (A-MEM-LOC A-SCAV-PAGE-TABLE) SCAV-WS-SIZE -1))
		SCAV-WS-OUT-1)
       ((M-TEM) ADD M-TEM (A-CONSTANT 1))
	(JUMP SCAV-WS-OUT-3)

SCAV-WS-OUT-2
	((OA-REG-LOW) DPB M-TEM OAL-A-DEST A-ZERO)	;Set WS table entry to -1
	((A-GARBAGE) SETO)
SCAV-WS-OUT-3
	((VMA-START-READ) ADD M-B (A-CONSTANT 1))	;GET PHT2
	(ILLOP-IF-PAGE-FAULT)				;PHT SHOULD BE ADDRESSABLE
	((M-B) PHT2-PHYSICAL-PAGE-NUMBER READ-MEMORY-DATA)	;PAGE FRAME NUMBER
	(JUMP-IF-BIT-SET-XCT-NEXT PHT1-MODIFIED-BIT M-A COREFOUND1A)
       ((M-A) SELECTIVE-DEPOSIT M-A PHT1-VIRTUAL-PAGE-NUMBER A-ZERO) ;VIRTUAL ADDRESS
	(DISPATCH-XCT-NEXT PHT2-MAP-STATUS-CODE
		 READ-MEMORY-DATA D-WRITEBACK-NEEDED)	;SEE IF NEEDS WRITING
COREFOUND1A
       ((A-FINDCORE-SCAN-POINTER)
		M-A-1 VMA A-V-PAGE-TABLE-AREA)		;STORE BACK SCAN POINTER
;If we get here, the page needs to be written out
	((C-PDL-BUFFER-POINTER-PUSH) VMA)		;NEEDS WRITING, SAVE ADDR(PHT2)
RD-COMP-REWRITE 
	(CALL-XCT-NEXT DISK-SWAP-HANDLER)		;DO THE WRITE
       ((M-T) (A-CONSTANT DISK-WRITE-COMMAND))
	((A-DISK-PAGE-WRITE-COUNT) ADD M-ZERO A-DISK-PAGE-WRITE-COUNT ALU-CARRY-IN-ONE)
  ;DO READ-COMPARE 
	(CALL-XCT-NEXT DISK-SWAP-HANDLER)
       ((M-T) (A-CONSTANT DISK-READ-COMPARE-COMMAND))
	(JUMP-NOT-EQUAL M-T A-V-NIL RD-COMP-E)	;JUMP IF ORDINARY DISK ERROR
	((M-T) A-DISK-LAST-STATUS)		;NO ERROR, CHECK READ-COMPARE-FLAG
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 22.) M-T RD-COMP-X)	;NO ERROR, GOOD
	((A-DISK-READ-COMPARE-DIFFERENCES) M+A+1 M-ZERO A-DISK-READ-COMPARE-DIFFERENCES)
RD-COMP-E
	(JUMP-XCT-NEXT RD-COMP-REWRITE)         ;LOST, TRY AGAIN.
       ((A-DISK-READ-COMPARE-REWRITES) M+A+1 M-ZERO A-DISK-READ-COMPARE-REWRITES)

RD-COMP-X
	((VMA) C-PDL-BUFFER-POINTER-POP)		;RESTORE PHT ENTRY ADDRESS+1
;DROPS THROUGH
;DROPS IN
;AT THIS POINT, VMA HAS ADDR+1 OF PHT ENTRY TO BE DELETED,
;M-A HAS ITS VIRTUAL ADDRESS, M-B HAS ITS PAGE FRAME NUMBER (NOT! PHYSICAL ADDRESS)
;DELETION WORKS BY FINDING PAGES THAT SHOULD HAVE HASHED TO THE
;HOLE WHERE THE THING WAS DELETED, AND EXCHANGING THEM WITH THE HOLE.
;NOTE THAT THE ALGORITHM IN THE PAGING MEMO IS WRONG.
;CONVENTIONS: M-B POINTS AT THE HOLE, VMA POINTS AT THE ITEM SUSPECTED
;OF BEING IN THE WRONG PLACE, M-PGF-TEM POINTS AT THE UPPERMOST ENTRY IN THE PHT,
;M-T POINTS AT WHERE (VMA) SHOULD HAVE HASHED TO. THESE ARE TYPELESS ABSOLUTE ADDRESSES.

COREFOUND2	
	((C-PDL-BUFFER-POINTER-PUSH) Q-POINTER M-B	;SAVE PAGE FRAME NUMBER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-B) SUB VMA (A-CONSTANT 1))			;-> PHT ENTRY TO DELETE
	((M-PGF-TEM) DPB M-ZERO Q-ALL-BUT-POINTER A-V-PAGE-TABLE-AREA)
	((M-PGF-TEM) ADD M-PGF-TEM A-PHT-INDEX-MASK)	;-> LAST ENTRY ON TABLE
PHTDEL1	((WRITE-MEMORY-DATA)
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;DELETE PHT ENTRY
	((VMA-START-WRITE M-B) Q-POINTER M-B)
	(ILLOP-IF-PAGE-FAULT)				;SUPPOSED TO BE WIRED
PHTDEL2	(JUMP-GREATER-OR-EQUAL VMA A-PGF-TEM PHTDEL5)	;JUMP IF WRAP AROUND
	((VMA-START-READ) ADD VMA (A-CONSTANT 2))	;CHECK LOCATION FOLLOWING HOLE
PHTDEL3	(ILLOP-IF-PAGE-FAULT)
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA PHTDELX)
	((M-T) SELECTIVE-DEPOSIT READ-MEMORY-DATA	;CHECK FOR DUMMY ENTRY
		PHT1-VIRTUAL-PAGE-NUMBER (A-CONSTANT -1))	;WHICH HAS AN ADDRESS OF -1
	(JUMP-EQUAL-XCT-NEXT M-T (A-CONSTANT -1) PHTDEL7)	;DUMMY ALWAYS HASHES
       ((M-T) M-B)					; TO THE HOLE
	(CALL-XCT-NEXT COMPUTE-PAGE-HASH)		;SOMETHING THERE, REHASH IT
       ((M-T) READ-MEMORY-DATA)
	((M-T) ADD M-T A-V-PAGE-TABLE-AREA)		;CONVERT FIXNUM HASH TO ADDRESS
	((M-T) Q-POINTER M-T)				;SANS EXTRA BITS
PHTDEL7	(JUMP-LESS-THAN VMA A-T PHTDEL4)		;JUMP ON FUNNY WRAP AROUND CASE
	(JUMP-GREATER-THAN M-T A-B PHTDEL2)		;JUMP IF HOLE IS NOT BETWEEN WHERE
	(JUMP-LESS-THAN VMA A-B PHTDEL2)		; THE FROB IS AND WHERE IT HASHES TO
PHTDEL6	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)	;MOVE THE CELL INTO THE HOLE
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	((M-T) SUB VMA (A-CONSTANT 1))			;SAVE PNTR TO MOVED CELL
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)		;COMPLETE THE CYCLE
	((VMA-START-WRITE) ADD M-B (A-CONSTANT 1))	;ADDRESS THE HOLE, STORE PHT2
	(ILLOP-IF-PAGE-FAULT)
	((VMA) SUB VMA (A-CONSTANT 1))
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP) ;STORE PHT1
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-XCT-NEXT PHTDEL1)				;MAKE THE MOVED CELL INTO NEW HOLE
       ((M-B) M-T)

PHTDEL4	(JUMP-LESS-OR-EQUAL M-T A-B PHTDEL6)		;JUMP IF HOLE IS BETWEEN WHERE THE
	(JUMP-GREATER-OR-EQUAL VMA A-B PHTDEL6)		; FROB IS AND WHERE IT HASHES TO
	(JUMP PHTDEL2)					;IT'S NOT, LOOP MORE

PHTDEL5	(JUMP-XCT-NEXT PHTDEL3)				;WRAP AROUND TO BEG OF PHT
       ((VMA-START-READ) DPB M-ZERO Q-ALL-BUT-POINTER A-V-PAGE-TABLE-AREA)

PHTDELX	((M-B) C-PDL-BUFFER-POINTER-POP)		;RESTORE FOUND PAGE FRAME
	(POPJ-AFTER-NEXT (MD) M-A)			;ACCESS MAP FOR VIRT PAGE DELETED
       ((VMA-WRITE-MAP)					;FLUSH 2ND LVL MAP, IF ANY
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
				;NOTE THAT IF WE HAVE A FIRST-LEVEL MAP MISS, THIS DOES NO HARM

;WE HAVE FOUND CORE, CONTINUE SWAPPING IN.  NEXT STEP IS TO
; SEARCH REGION TABLES TO FIND META BITS.

SWAPIN1	(CALL PAGE-IN-0)
	(CALL-NOT-EQUAL A-PAGE-TRACE-PTR M-ZERO PAGE-TRACE-IN) ;TRACE PAGE SWAPIN
	(JUMP-IF-BIT-SET M-DONT-SWAP-IN CZRR)		;IF FRESH PAGE DON'T REALLY SWAP IN
	(CALL-XCT-NEXT DISK-SWAP-HANDLER)		;READ THE PAGE IN FROM DISK
       ((M-T) (A-CONSTANT DISK-READ-COMMAND))
	((A-DISK-PAGE-READ-COUNT) ADD M-ZERO A-DISK-PAGE-READ-COUNT ALU-CARRY-IN-ONE)
;This seems not be needed
;	(JUMP-EQUAL A-DISK-PARITY-CHECK M-ZERO SWAPIN2)
;	;; Scan the page just read to see if bad parity was written by the disk
;	((MD) A-ZERO)				;ADDRESS MAP LOCATION 0@2
;	((A-TEM3) MAP-WRITE-SECOND-LEVEL-MAP	;SAVE IT (READ & WRITE THE SAME)
;		  MEMORY-MAP-DATA
;		  (A-CONSTANT (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)))
;	((VMA-WRITE-MAP) MAP-PHYSICAL-PAGE-NUMBER M-B ;R/W ACCESS TO SPECIFIED PAGE FRAME
;		(A-CONSTANT (PLUS (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)
;				  (BYTE-VALUE MAP-ACCESS-CODE 3))))
;	((VMA) (M-CONSTANT -1))			;SCAN IT OUT, USING VIRTUAL PAGE ZERO
;DISK-PARITY-CHECK
;	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
;	(ILLOP-IF-PAGE-FAULT)
;	    (ERROR-TABLE DISK-PARITY-CHECK)	;PC IN LIGHTS WHEN HALTS FOR PARITY ERROR
;	(JUMP-LESS-THAN-XCT-NEXT VMA (A-CONSTANT 377) DISK-PARITY-CHECK)
;      ((A-TEM2) READ-MEMORY-DATA)		;DIE HERE IF BAD PARITY
;	((MD) A-ZERO)				;RESTORE THE MAP
;	((VMA-WRITE-MAP) A-TEM3)
;	;; End of parity scan code
SWAPIN2	(JUMP-XCT-NEXT PGF-RESTORE)	;TAKE FAULT AGAIN SINCE DISK XFER
       (CALL PAGE-IN-1)			;MAY HAVE FAULTED AND FLUSHED SECOND LEVEL MAP BLOCK.

;;; First part of making a page known in core
PAGE-IN-0
	((M-A) DPB M-ZERO Q-ALL-BUT-POINTER A-PGF-VMA)	;M-A DISK ADDRESS TO BE READ IN
							;M-B PAGE FRAME TO READ IT INTO
	(CALL-XCT-NEXT XRGNPF)				;ADDR IN M-A => REGION NUMBER IN M-T
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-B Q-POINTER	;PRESERVE AND PROTECT PAGE FRAME NUMBER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-EQUAL M-T A-V-NIL ILLOP)			;SWAPPING IN A PAGE NOT IN A REGION
	((WRITE-MEMORY-DATA) DPB M-T Q-POINTER		;MAKE PHYSICAL-PAGE-REGION-NUMBER ENTRY
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) ADD C-PDL-BUFFER-POINTER A-V-PHYSICAL-PAGE-REGION-NUMBER)
	(ILLOP-IF-PAGE-FAULT)				;SHOULD BE WIRED DOWN	
	((VMA-START-READ) ADD M-T A-V-REGION-BITS)	;GET MISC BITS WORD
	(ILLOP-IF-PAGE-FAULT)				;SHOULD BE WIRED DOWN
	((M-B) C-PDL-BUFFER-POINTER)			;RESTORE PAGE FRAME NUMBER
	((M-TEM C-PDL-BUFFER-POINTER-PUSH)		;SAVE THE MISC BITS FOR MAP
		SELECTIVE-DEPOSIT READ-MEMORY-DATA (LISP-BYTE %%REGION-MAP-BITS) A-ZERO)
	((M-T) A-MAR-LOW)				;CHECK VMA AGAINST MAR
	((M-T) SELECTIVE-DEPOSIT M-T VMA-PAGE-ADDR-PART A-ZERO)
	(POPJ-LESS-THAN M-A A-T)
	((M-T) A-MAR-HIGH)
	((M-T) SELECTIVE-DEPOSIT M-T VMA-PAGE-ADDR-PART A-ZERO)
	(POPJ-GREATER-THAN M-A A-T)
	(POPJ-AFTER-NEXT (M-T) (A-CONSTANT (EVAL %PHT-MAP-STATUS-MAR)))
       ((C-PDL-BUFFER-POINTER) DPB M-T PHT2-MAP-STATUS-CODE A-TEM) ;YEP, CHANGE MAP STATUS

;;; Second part.
PAGE-IN-1
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)		;FIND HOLE IN PHT FOR IT
       ((M-T) A-PGF-VMA)
	(CALL-IF-BIT-SET PHT1-VALID-BIT READ-MEMORY-DATA ILLOP)	;SUPPOSED TO BE A HOLE!
	((M-A) A-PGF-VMA)
	((WRITE-MEMORY-DATA-START-WRITE)		;CONSTRUCT AND STORE PHT1 WORD
	    SELECTIVE-DEPOSIT M-A PHT1-VIRTUAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
					(BYTE-VALUE PHT1-VALID-BIT 1))
				  (BYTE-VALUE PHT1-SWAP-STATUS-CODE 1))))
	(ILLOP-IF-PAGE-FAULT)				;SHOULD BE WIRED
	((M-PGF-TEM) SELECTIVE-DEPOSIT C-PDL-BUFFER-POINTER-POP
		PHT2-ACCESS-STATUS-AND-META-BITS	;RESTORE ACCESS, STATUS, AND META BITS
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(DISPATCH (LISP-BYTE %%PHT2-MAP-STATUS-CODE) M-PGF-TEM D-SWAPAR) ;VERIFY THE BITS
		;; This will go to ILLOP if this is a page of a free region
	((VMA) ADD VMA (A-CONSTANT 1))			;ADDRESS PHT2
	(POPJ-AFTER-NEXT
	    (WRITE-MEMORY-DATA-START-WRITE)		;CONSTRUCT AND STORE PHT2 WORD
	    DPB C-PDL-BUFFER-POINTER-POP
	    PHT2-PHYSICAL-PAGE-NUMBER A-PGF-TEM)
       (ILLOP-IF-PAGE-FAULT)				;SHOULD BE WIRED

(LOCALITY D-MEM)
(START-DISPATCH 3 0)				;DISPATCH ON MAP-STATUS
D-SWAPAR					;VERIFY MAP STATUS CODE FROM CORE
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;0 MAP NOT SET UP ERRONEOUS
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;1 META BITS ONLY ERRONEOUS
	(P-BIT R-BIT)				;2 READ ONLY
	(P-BIT R-BIT)				;3 READ WRITE FIRST
	(P-BIT R-BIT)				;4 READ WRITE
	(P-BIT R-BIT)				;5 PDL BUFFER
	(P-BIT R-BIT)				;6 MAR BREAK
	(P-BIT INHIBIT-XCT-NEXT-BIT ILLOP)	;7 UNUSED CODE
(END-DISPATCH)
(LOCALITY I-MEM)

;INITIALIZE A FRESH PAGE BY FILLING IT WITH <DTP-TRAP .>
;M-A/ VIRTUAL ADDR (NO TYPE BITS), M-B/ PAGE FRAME NUMBER
CZRR	((MD) A-ZERO)				;CLOBBER MAP 0 TO POINT TO PAGE
	((M-T) MEMORY-MAP-DATA)			;SAVE 0@2
	((VMA-WRITE-MAP) DPB M-B MAP-PHYSICAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3)))) ;R/W
	((VMA) A-ZERO)
	((A-TEM1) SELECTIVE-DEPOSIT M-A VMA-PAGE-ADDR-PART A-ZERO)	;PAGE BASE ADDRESS
CZRR1	((WRITE-MEMORY-DATA-START-WRITE)	;STORE TRAPS POINTING TO SELF
		ADD VMA A-TEM1)			;NOTE DTP-TRAP = 0
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-LESS-THAN-XCT-NEXT VMA (A-CONSTANT 377) CZRR1)
       ((VMA) ADD VMA (A-CONSTANT 1))
	((A-FRESH-PAGE-COUNT) ADD M-ZERO A-FRESH-PAGE-COUNT ALU-CARRY-IN-ONE)
	((MD) A-ZERO)
	(JUMP-XCT-NEXT SWAPIN2)			;RETURN TO MAIN SWAP-IN CODE
       ((VMA-WRITE-MAP) MAP-WRITE-SECOND-LEVEL-MAP M-T	;RESTORE 0@2
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))

;AGER. CALLED FROM DISK-SWAP-HANDLER, MAY CLOBBER M-C, M-1, A-TEM1, A-TEM2, A-TEM3.
;THIS ADVANCES A-AGING-SCAN-POINTER C(A-AGING-RATE) STEPS THROUGH THE PHT.
;IF A PAGE IS FOUND WITH NORMAL SWAP-STATUS, IT IS CHANGED TO AGE TRAP.
;IF A PAGE IS FOUND WITH AGE-TRAP STATUS, IT IS CHANGED TO FLUSHABLE.
AGER	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER A-AGING-RATE) ;GET NUMBER OF TIMES AROUND LOOP
	(POPJ-EQUAL M-1 A-ZERO)				;RETURN AT ONCE IF AGING IS OFF
	((M-C) A-AGING-SCAN-POINTER)			;GET SCAN POINTER ON M SIDE
AGER0	((VMA-START-READ) ADD M-C A-V-PAGE-TABLE-AREA)	;GET A PHT1 WORD
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-LESS-THAN M-C A-PHT-INDEX-MASK AGER1)	;JUMP IF NO WRAP AROUND
	((M-C) SUB M-ZERO (A-CONSTANT 2))		;OTHERWISE WILL RESET TO ZERO
AGER1	(DISPATCH-XCT-NEXT PHT1-SWAP-STATUS-CODE READ-MEMORY-DATA D-AGER)
       ((M-C) ADD M-C (A-CONSTANT 2))			;ADVANCE POINTER
	(JUMP-GREATER-THAN-XCT-NEXT M-1 (A-CONSTANT 1) AGER0)	;LOOP
       ((M-1) SUB M-1 (A-CONSTANT 1))
	(POPJ-AFTER-NEXT				;DONE, RETURN
	 (A-AGING-SCAN-POINTER) M-C)			;UPDATING SCAN POINTER
       (NO-OP)

(LOCALITY D-MEM)
(START-DISPATCH 3 0) ;XCT-NEXT
D-AGER	(P-BIT R-BIT)	;0 PHT ENTRY INVALID, IGNORE
	(P-BIT AGER2)	;1 NORMAL, SET AGE TRAP
	(P-BIT R-BIT)	;2 FLUSHABLE, IGNORE
	(P-BIT ILLOP)	;3 NOT USED (FORMERLY PDL BUFFER)
	(P-BIT AGER3)	;4 AGE TRAP, CHANGE TO FLUSHABLE
	(P-BIT R-BIT)	;5 WIRED, IGNORE
	(P-BIT ILLOP)	;6 NOT USED, ERROR
	(P-BIT ILLOP)	;7 NOT USED, ERROR
(END-DISPATCH)
(LOCALITY I-MEM)

;CHANGE NORMAL TO AGE-TRAP, ALSO TURN OFF HARDWARE MAP ACCESS
AGER2	((A-PAGE-AGE-COUNT) ADD M-ZERO A-PAGE-AGE-COUNT ALU-CARRY-IN-ONE)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
	    PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT (EVAL %PHT-SWAP-STATUS-AGE-TRAP)))
	(ILLOP-IF-PAGE-FAULT)
	(POPJ-XCT-NEXT)
       ((VMA-WRITE-MAP)				;FLUSH 2ND LVL MAP, IF ANY
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))

;CHANGE AGE-TRAP TO FLUSHABLE
AGER3	((A-PAGE-FLUSH-COUNT) ADD M-ZERO A-PAGE-FLUSH-COUNT ALU-CARRY-IN-ONE)
	(POPJ-AFTER-NEXT
	 (WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT READ-MEMORY-DATA
	    PHT1-ALL-BUT-SWAP-STATUS-CODE (A-CONSTANT (EVAL %PHT-SWAP-STATUS-FLUSHABLE)))
       (ILLOP-IF-PAGE-FAULT)

;GIVEN AN ADDRESS FIND WHAT AREA IT IS IN.  RETURNS THE AREA NUMBER OR NIL.
;THIS WORKS BY FINDING THE REGION NUMBER, THEN FINDING WHAT AREA THAT REGION LIES IN.
XARN (MISC-INST-ENTRY %AREA-NUMBER)
	(CALL XRGN)			;GET REGION NUMBER FROM ARG ON PDL
	(POPJ-EQUAL M-T A-V-NIL)	;NONE
;GIVEN A REGION NUMBER IN M-T, FIND THE AREA-NUMBER (IN M-T WITH DATA-TYPE)
REGION-TO-AREA 
	((VMA-START-READ) ADD M-T A-V-REGION-LIST-THREAD)
	(CHECK-PAGE-READ-NO-INTERRUPT)		;MAYBE CALLED FROM INSIDE INTR HAN
	(JUMP-IF-BIT-CLEAR-XCT-NEXT BOXED-SIGN-BIT READ-MEMORY-DATA REGION-TO-AREA)
       ((M-T) BOXED-NUM-EXCEPT-SIGN-BIT READ-MEMORY-DATA	;GET NEXT IN LIST
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(POPJ)				;END OF LIST, M-T HAS AREA NUMBER

;GIVEN AN ADDRESS FIND WHAT REGION IT IS IN.  RETURNS THE REGION NUMBER OR NIL
;IF NOT IN ANY REGION.  MUST CLOBBER ONLY M-T, M-TEM, Q-R, A-TEM1, A-TEM2, A-TEM3, M-A, M-B
;SINCE IT IS CALLED BY THE PAGE FAULT ROUTINES.
;RETURNS IN M-T.
XRGN (MISC-INST-ENTRY %REGION-NUMBER)
	((M-A MD) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;AN ADDRESS IN THE REGION
XRGN00	((M-TEM) MAP-STATUS-CODE MEMORY-MAP-DATA)
	(JUMP-LESS-THAN M-TEM (A-CONSTANT 2) XRGNPF)	;JUMP IF MAP NOT SET UP
	((M-TEM) MAP-PHYSICAL-PAGE-NUMBER MEMORY-MAP-DATA);PAGE IS IN CORE, USE QUICK METHOD
	((VMA-START-READ) ADD M-TEM A-V-PHYSICAL-PAGE-REGION-NUMBER)
	(ILLOP-IF-PAGE-FAULT)
	(POPJ-XCT-NEXT)
       ((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)

;ENTER HERE FROM PAGE FAULT ROUTINES
XRGNPF	((M-T) A-V-REGION-SORTED-BY-ORIGIN)	;LOWER BOUND FOR LOG SEARCH
	((M-TEM) (A-CONSTANT (EVAL SIZE-OF-AREA-ARRAYS))) ;RANGE
	((A-TEM3) ADD M-T A-TEM)		;UPPER LIMIT
XRGN0	(JUMP-EQUAL M-TEM (A-CONSTANT 1) XRGN2)	;MOVING DOWN AND RANGE = 1 => DONE
XRGN1	((M-TEM) ADD A-ZERO M-TEM ALU-CARRY-IN-ONE	;DECREASES RANGE BY 1/2
		 OUTPUT-SELECTOR-RIGHTSHIFT-1)
	((VMA-START-READ Q-R) ADD M-T A-TEM)	;PROBE CENTER OF TABLE
	(ILLOP-IF-PAGE-FAULT)			;SHOULD BE WIRED
	(JUMP-GREATER-OR-EQUAL VMA A-TEM3 XRGN0) ;IF RUN OFF TOP OF TABLE, MOVE DOWN
	((VMA-START-READ) ADD READ-MEMORY-DATA A-V-REGION-ORIGIN)
	(ILLOP-IF-PAGE-FAULT)			;SHOULD BE WIRED
	((A-TEM2) Q-POINTER READ-MEMORY-DATA)	;GET ORIGIN OF REGION PROBING AT
	(JUMP-LESS-THAN M-A A-TEM2 XRGN0)	;JUMP IF MOVE DOWN
	(JUMP-XCT-NEXT XRGN1)
       ((M-T) Q-R)				;MOVE UP

;HERE WHEN HAVE NARROWED IT TO ONE ITEM, VMA AND READ-MEMORY-DATA
;HAVE THE REGION-ORIGIN ENTRY FOR THE WRONG REGION, BUT M-T POINTS
;AT THE REGION-SORTED-BY-ORIGIN ENTRY FOR THE ONLY POSSIBLE CORRECT REGION PROBABLY
XRGN2	((VMA-START-READ Q-R) M-T)		;DIG UP THE REGION NUMBER, SAVE M-T
	(ILLOP-IF-PAGE-FAULT)
	((M-T) Q-TYPED-POINTER READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-T A-V-REGION-ORIGIN) ;GET ORIGIN OF CORRECT REGION
	(ILLOP-IF-PAGE-FAULT)
	((M-B) Q-POINTER READ-MEMORY-DATA)
	(JUMP-LESS-THAN M-A A-B XFALSE)		;OUTSIDE REGION, RETURN NIL
	((VMA-START-READ) ADD M-T A-V-REGION-LENGTH)
	(ILLOP-IF-PAGE-FAULT)			;GET LENGTH, SHOULD BE WIRED
	((A-TEM2) Q-POINTER READ-MEMORY-DATA)
	((M-B) ADD M-B A-TEM2)			;UPPER BOUND OF THIS REGION
	(POPJ-LESS-THAN M-A A-B)		;RETURN IF INSIDE REGION, # IN M-T
	(JUMP-NOT-EQUAL A-TEM2 M-ZERO XFALSE)	;IT'S ABOVE THIS REGION
	(JUMP-XCT-NEXT XRGN1)			;ZERO LENGTH, TRY NEXT REGION SAME ORIGIN
       ((M-T) ADD Q-R (A-CONSTANT 1))

;DISK HANDLER (CADR VERSION)
;ENTER WITH M-A/ VIRTUAL ADDR, M-B/ PAGE FRAME NUMBER, M-T/ DISK COMMAND
;CLOBBERS A-TEM1, A-TEM2, A-TEM3, VMA, M-T.  M-A MUST NOT HAVE ANY EXTRA BITS ON.

DISK-SWAP-HANDLER
	(CALL-GREATER-OR-EQUAL M-A A-DISK-MAXIMUM ILLOP)	;ADDRESS OUT OF BOUNDS
	((M-A) ADD M-A A-DISK-OFFSET)			;RELOCATE TO APPROPRIATE PART OF DISK
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-VMA)		;SAVE PAGE FAULT HANDLER VARIABLES
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-WMD)		;IN CASE OF RECURSIVE FAULT
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-T)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-A)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-B)
	((C-PDL-BUFFER-POINTER-PUSH) M-C)		;ARG TO DISK ROUTINE
	((C-PDL-BUFFER-POINTER-PUSH) M-1)		;CLOBBERED BY DISK ROUTINE
	((C-PDL-BUFFER-POINTER-PUSH) M-2)		;..
	((WRITE-MEMORY-DATA) DPB M-MINUS-ONE (BYTE-FIELD 24. 0) A-ZERO);TURN ON DISK RUN LIGHT
	((VMA-START-WRITE) A-DISK-RUN-LIGHT)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) SETZ)			;TURN OFF CPU RUN LIGHT
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 2))
	(CHECK-PAGE-WRITE)
DISK-SWAP-RETRY 
	(CALL-XCT-NEXT DISK-OP)				;CALL DISK ROUTINE
       ((M-C) DPB (M-CONSTANT -1) (BYTE-FIELD 24. 8) A-ZERO) ;-400 ;NEGATIVE 16BIT WD COUNT
	(CALL AGER)					;RUN AGER WHILE IN DISK WAIT
	(CALL-XCT-NEXT DISK-WAIT)			;NOW WAIT FOR OPERATION TO COMPLETE
       ((M-2) M-T)		;SAVE OP IN CASE NEEDED FOR RETRY
	(JUMP-EQUAL M-2 (A-CONSTANT DISK-READ-COMPARE-COMMAND) DISK-SWAP-X)  ;CALLER WILL CHECK
				;FOR ERROR ON READ-COMPARE
	(JUMP-NOT-EQUAL M-T A-V-NIL DISK-SWAP-ERR)	;IF DISK ERROR OCCURRED
DISK-SWAP-X
	((WRITE-MEMORY-DATA) SETZ)			;TURN OFF DISK RUN LIGHT
	((VMA-START-WRITE) A-DISK-RUN-LIGHT)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) DPB M-MINUS-ONE (BYTE-FIELD 24. 0) A-ZERO)	;TURN ON CPU RUN LIGHT
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 2))
	(CHECK-PAGE-WRITE)
	((M-A) SUB M-A A-DISK-OFFSET)			;FIX M-A
	((M-2) C-PDL-BUFFER-POINTER-POP)		;RESTORE REGISTERS
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((M-C) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-B) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-A) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-T) C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT
	 (A-PGF-WMD) C-PDL-BUFFER-POINTER-POP)
       ((A-PGF-VMA) C-PDL-BUFFER-POINTER-POP)

DISK-SWAP-ERR
	(CALL-IF-BIT-SET (BYTE-FIELD 1 37) M-2 ILLOP)	;LOST THREE TIMES IN A ROW
	(CALL-IF-BIT-SET (BYTE-FIELD 1 36) M-2 DISK-RECALIBRATE)  ;SECOND TRY
	((A-DISK-ERROR-COUNT) ADD M-ZERO A-DISK-ERROR-COUNT ALU-CARRY-IN-ONE)
	(JUMP-XCT-NEXT DISK-SWAP-RETRY)		;RESTORE OP, BUT SET SIGN IN CASE LOSE AGAIN
       ((M-T) ADD M-2 (A-CONSTANT (BYTE-MASK 3601)))

DISK-RECALIBRATE
	((A-DISK-RECALIBRATE-COUNT) M+A+1 M-ZERO A-DISK-RECALIBRATE-COUNT)
	(CALL-XCT-NEXT DISK-OP-LOW)		;Start operation
       ((MD) (A-CONSTANT 1005))	;RECALIBRATE COMMAND	
DISK-RECALIBRATE-WAIT
	((VMA-START-READ) VMA)			;Now await on-cylinder so disk doesn't bite
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 8) MD DISK-RECALIBRATE-WAIT)
	(POPJ)

;THIS DISK ROUTINE IS A REWRITE OF THE OLD ONE FOR THE NEW DISK CONTROL,
;IT IS TEMPORARY AND WILL BE REPLACED WHEN THE HAIRY REAL THING IS WRITTEN.
;LOCATION 777, THE LAST WORD IN THE SYSTEM COMMUNICATION AREA, IS USED FOR COMMAND LIST
DISK-OP	((VMA-START-READ) A-DISK-REGS-BASE)		;WAIT FOR DISK CONTROL TO BE READY
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) READ-MEMORY-DATA DISK-OP)
	((WRITE-MEMORY-DATA) DPB M-B VMA-PHYS-PAGE-ADDR-PART A-ZERO)	;CCW
	((VMA-START-WRITE) (A-CONSTANT 777))
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) M-T)			;STORE COMMAND
	((VMA-START-WRITE) A-DISK-REGS-BASE)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) (A-CONSTANT 777))		;STORE CLP
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	((M-1) VMA-PAGE-ADDR-PART M-A)			;GET DISK BLOCK NUMBER
	(CALL-XCT-NEXT DIV)				;DIVIDE TO GET CYLINDER IN Q-R,
       ((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-DISK-BLOCKS-PER-CYLINDER)	;REMAINDER IN M-1
        ((MD) DPB Q-R (BYTE-FIELD 12. 16.) A-ZERO)	;SAVE CYLINDER
	(CALL-XCT-NEXT DIV)				;DIVIDE TO GET HEAD IN Q-R, BLK IN M-1
       ((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-DISK-BLOCKS-PER-TRACK)
	((M-1) DPB Q-R (BYTE-FIELD 8 8) A-1)
	((WRITE-MEMORY-DATA) IOR MD A-1)		;CONSTRUCT DISK ADDRESS
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(POPJ-AFTER-NEXT
	 (VMA-START-WRITE) ADD VMA (A-CONSTANT 1))	;START TRANSFER
       (CHECK-PAGE-WRITE)

DISK-OP-LOW	;DO LOW LEVEL DISK OP IN MD.  WAIT FOR CONTROL IDLE AFTERWARDS.
	((VMA-START-WRITE) A-DISK-REGS-BASE)
	(CHECK-PAGE-WRITE)		;WRITE COMMAND REG.
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 3))
	(CHECK-PAGE-WRITE)		;START OP.
;WAIT FOR DISK COMPLETION, RETURN NIL IF OK OR T IF ERROR.  LEAVES DISK-STATUS WORD IN
; A-DISK-LAST-STATUS.
DISK-WAIT	
	((VMA-START-READ) A-DISK-REGS-BASE)		;AWAIT IDLE
	(CHECK-PAGE-READ)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) READ-MEMORY-DATA DISK-WAIT)
	((A-DISK-LAST-STATUS) READ-MEMORY-DATA)
	((M-T) AND READ-MEMORY-DATA (A-CONSTANT 47777560))
		;M-T GETS ERROR BITS: INTERNAL PARITY, NXM, MEM PAR, HEADER COMPARE,
		; HEADER ECC, ECC HARD, ECC SOFT, READ OVERRUN, WRITE OVERRUN,
		; START-BLOCK ERR, TIMEOUT, SEEK ERR, OFF LINE, OFF CYL, FAULT, NO SEL, MUL SEL
	(JUMP-NOT-EQUAL M-T A-ZERO XTRUE)		;ERROR
       (JUMP XFALSE)					;NO ERROR, RESULT IS NIL

;;; MISCELLANEOUS FUNCTIONS FOR LISP PROGRAMS TO HACK THE PAGE HASH TABLE

XCPGS (MISC-INST-ENTRY %CHANGE-PAGE-STATUS)
	;ARGS ARE VIRTUAL ADDRESS, SWAP STATUS CODE, ACCESS STATUS AND META BITS
	;DOESN'T DO ERROR CHECKING, IF YOU DO THE WRONG THING YOU WILL LOSE.
	((M-E) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;Access, status, and meta bits
	((M-D) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)	;Swap status code
;Here from UPDATE-REGION-PHT.  Must bash only M-A, M-B, M-T, tems.
;Returns address which came in on pdl, in MD.
;Note magic kludge -- sign of M-D means get rid of page entirely (for FREE-REGION)
XCPGS0	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)
       ((M-T) Q-POINTER C-PDL-BUFFER-POINTER)	;Virtual address
	(JUMP-IF-BIT-CLEAR-XCT-NEXT		;If not swapped in, return NIL, and make
		PHT1-VALID-BIT READ-MEMORY-DATA XCPGS2)	; sure to clear the map
       ((M-T) A-V-NIL)
	((M-T) A-V-TRUE)			;Get ready to return T
	(JUMP-EQUAL M-D A-V-NIL XCPGS1)		;See if should change swap-status
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 31.) M-D XCPGS3) ;If sign bit of M-D set,
	((A-TEM2) ANDCA MD (A-CONSTANT (BYTE-MASK PHT1-MODIFIED-BIT))) ;clear modified flag
	((MD) DPB (M-CONSTANT -1) PHT1-VIRTUAL-PAGE-NUMBER A-TEM2) ;and forget virtual page
XCPGS3	((WRITE-MEMORY-DATA-START-WRITE)
		SELECTIVE-DEPOSIT MD PHT1-ALL-BUT-SWAP-STATUS-CODE A-D)
	(ILLOP-IF-PAGE-FAULT)
XCPGS1	(JUMP-EQUAL M-E A-V-NIL XCPGS2)
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	((A-TEM2) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-E PHT2-ACCESS-STATUS-AND-META-BITS A-TEM2)
	(ILLOP-IF-PAGE-FAULT)
XCPGS2	(POPJ-AFTER-NEXT (MD) C-PDL-BUFFER-POINTER-POP)	;ADDRESS LOCATION BEING HACKED
       ((VMA-WRITE-MAP)				;FLUSH 2ND LVL MAP, IF ANY
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
			;NO HARM DONE IF MAP MISS ALREADY, EITHER LEVEL

XCPPG (MISC-INST-ENTRY %CREATE-PHYSICAL-PAGE)
	;ARG IS PHYSICAL ADDRESS
	((VMA-START-READ) A-V-PAGE-TABLE-AREA)		;FIND FIRST HOLE
XCPPG0	(ILLOP-IF-PAGE-FAULT)
	((M-TEM) SUB VMA A-V-PAGE-TABLE-AREA)
	(CALL-GREATER-THAN M-TEM A-PHT-INDEX-MASK ILLOP)	;OUT OF BOUNDS
	(JUMP-IF-BIT-SET-XCT-NEXT PHT1-VALID-BIT READ-MEMORY-DATA XCPPG0)
       ((VMA-START-READ) ADD VMA (A-CONSTANT 2))
	(NO-OP)						;USELESS MEM CYCLE
	((VMA) SUB VMA (A-CONSTANT 2))			;ADDRESS PHT1 OF HOLE
	((WRITE-MEMORY-DATA-START-WRITE) DPB (M-CONSTANT -1)	;FAKE VIRTUAL ADDRESS
		PHT1-VIRTUAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE PHT1-SWAP-STATUS-CODE 2) ;FLUSHABLE
					(BYTE-VALUE PHT1-VALID-BIT 1))
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
	(ILLOP-IF-PAGE-FAULT)
	((VMA) ADD VMA (A-CONSTANT 1))
	(JUMP-XCT-NEXT XTRUE)
       ((WRITE-MEMORY-DATA-START-WRITE) 
		VMA-PHYS-PAGE-ADDR-PART C-PDL-BUFFER-POINTER-POP
		(A-CONSTANT (PLUS (BYTE-VALUE PHT2-ACCESS-STATUS-AND-META-BITS 1200) ;RO
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))

XDPPG (MISC-INST-ENTRY %DELETE-PHYSICAL-PAGE)
	;ARG IS PHYSICAL ADDRESS
	((M-T) VMA-PHYS-PAGE-ADDR-PART C-PDL-BUFFER-POINTER-POP)
XDPPG3	;Arg already in T.
	((M-A) ADD M-ZERO A-V-PAGE-TABLE-AREA ALU-CARRY-IN-ONE)	;SCAN THROUGH ALL OF PHT
	((M-Q VMA-START-READ) ADD M-A A-PHT-INDEX-MASK)	;IN BACKWARDS ORDER, READING PHT2'S
XDPPG0	(ILLOP-IF-PAGE-FAULT)
	((A-TEM1) PHT2-PHYSICAL-PAGE-NUMBER READ-MEMORY-DATA)
	(JUMP-EQUAL M-T A-TEM1 XDPPG2)			;SEEMS TO MATCH
XDPPG1	(JUMP-GREATER-THAN-XCT-NEXT M-Q A-A XDPPG0)
       ((M-Q VMA-START-READ) SUB M-Q (A-CONSTANT 2))
	(JUMP XFALSE)					;NOT FOUND

XDPPG2	((M-B VMA-START-READ) SUB M-Q (A-CONSTANT 1))	;CHECK PHT1
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA XDPPG1) ;FALSE ALARM
	(CALL-XCT-NEXT COREFOUND1)			;SWAP IT OUT, DELETE PHT ENTRY
       ((M-A) READ-MEMORY-DATA)
	(JUMP XTRUE)					;DONE

XPAGE-IN (MISC-INST-ENTRY %PAGE-IN)
	((A-PGF-VMA) DPB C-PDL-BUFFER-POINTER-POP	;ARG 2 - VIRTUAL PAGE NUMBER
		VMA-PAGE-ADDR-PART A-ZERO)
	(CALL-XCT-NEXT SEARCH-PAGE-HASH-TABLE)		;SEE IF ALREADY IN
       ((M-T) A-PGF-VMA)
	(JUMP-IF-BIT-SET-XCT-NEXT PHT1-VALID-BIT READ-MEMORY-DATA XFALSE) ;YES, RETURN NIL
       ((M-B) Q-POINTER C-PDL-BUFFER-POINTER-POP)	;ARG 1 - PAGE FRAME
	(CALL PAGE-IN-0)				;NO, PUT IT IN
	(CALL PAGE-IN-1)
	(JUMP XTRUE)					;RETURN T

XPHYADR (MISC-INST-ENTRY %PHYSICAL-ADDRESS)
	((MD) C-PDL-BUFFER-POINTER-POP)		;ADDRESS THE MAP
	(DISPATCH MAP-STATUS-CODE MEMORY-MAP-DATA D-ASSURE-MAP-VALID)
	(POPJ-AFTER-NEXT (M-T) DPB MEMORY-MAP-DATA
		 VMA-PHYS-PAGE-ADDR-PART (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
       ((M-T) VMA-LOW-BITS MD A-T)

;Set up to do page-tracing.  We get a wired-down array and fill in 4-word
;entries for page-in and page-out.  An entry looks like:
;	Microsecond clock value
;	Virtual address
;	Bit 31: swap-out flag, bits 15-0: micro-pc
;	Current function (just randomly picks up @M-AP, hopefully reasonable)
;If A-PAGE-TRACE-PTR is non-zero, it's the next location to write into,
;and A-PAGE-TRACE-START is the lowest value, A-PAGE-TRACE-END is the wrap-around point
;The array better be wired, have 32-bit elements, and be a multiple of 4 long
;or the machine will blow totally away.
X-PAGE-TRACE (MISC-INST-ENTRY %PAGE-TRACE)
	((M-T) Q-TYPED-POINTER C-PDL-BUFFER-POINTER-POP)
	(POPJ-EQUAL-XCT-NEXT M-T A-V-NIL)
       ((A-PAGE-TRACE-PTR) SETZ)		;Assume trace to be shut off
	(CALL-XCT-NEXT GAHDR)
       ((M-A) M-T)				;M-E origin, M-S length, untyped
	((A-PAGE-TRACE-PTR) M-E)
	(POPJ-AFTER-NEXT (A-PAGE-TRACE-START) M-E)
       ((A-PAGE-TRACE-END) ADD M-E A-S)	

;Make a page-trace entry for swap in.
;Only call this if A-PAGE-TRACE-PTR is non-zero
;Can take recursive page faults.
;Note that map faults, such as the interrupt routine can take, don't cause page tracing.
PAGE-TRACE-OUT	;Here when swapping page out
	((A-PAGE-TRACE-VMA) SELECTIVE-DEPOSIT M-A PHT1-VIRTUAL-PAGE-NUMBER A-ZERO)
	((A-TEM1) MICRO-STACK-DATA-POP)
	((A-TEM2) MICRO-STACK-DATA-POP)
	((A-TEM3) MICRO-STACK-DATA-POP)
	((A-PAGE-TRACE-UPC) MICRO-STACK-DATA	;Call to PGF-R, PGF-W
			    (A-CONSTANT (BYTE-MASK SIGN-BIT)))
	(JUMP-XCT-NEXT PAGE-TRACE-0)
       ((MICRO-STACK-DATA-PUSH) A-TEM3)

PAGE-TRACE-IN	;Here when swapping page in
	((A-PAGE-TRACE-VMA) A-PGF-VMA)
	((A-TEM1) MICRO-STACK-DATA-POP)
	((A-TEM2) MICRO-STACK-DATA-POP)
	((A-PAGE-TRACE-UPC) MICRO-STACK-DATA)	;Call to PGF-R, PGF-W
PAGE-TRACE-0
	((MICRO-STACK-DATA-PUSH) A-TEM2)
	((MICRO-STACK-DATA-PUSH) A-TEM1)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-VMA)	;Allow recursive faulting, like disk routine
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-WMD)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-T)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-A)
	((C-PDL-BUFFER-POINTER-PUSH) A-PGF-B)
	((C-PDL-BUFFER-POINTER-PUSH) PDL-BUFFER-INDEX)
	((C-PDL-BUFFER-POINTER-PUSH) M-FLAGS)
	((M-INTERRUPT-FLAG) DPB (M-CONSTANT -1) A-FLAGS) ;No page swapping (error check)
	((VMA-START-READ) (A-CONSTANT 77772050))	;Microsecond clock (764120)
	(CHECK-PAGE-READ)
	((A-TEM1) READ-MEMORY-DATA)		;Stash low word
	((VMA-START-READ) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)			;Map should be set up, don't bash A-TEM1
	((WRITE-MEMORY-DATA) DPB READ-MEMORY-DATA (BYTE-FIELD 20 20) A-TEM1)
	((VMA-START-WRITE) A-PAGE-TRACE-PTR)	;1st trace word: clock
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) A-PAGE-TRACE-VMA)	;2nd trace word: address referenced
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))	
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) A-PAGE-TRACE-UPC)	;3rd trace word: swap-out flag, address ref'd
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))	
	(CHECK-PAGE-WRITE)
	((PDL-BUFFER-INDEX) M-AP)		;4th trace word: macro-function
	((WRITE-MEMORY-DATA) C-PDL-BUFFER-INDEX)
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))	
	(CHECK-PAGE-WRITE)
	((VMA) ADD VMA (A-CONSTANT 1))		;Next trace entry address
	(JUMP-LESS-THAN VMA A-PAGE-TRACE-END PAGE-TRACE-1)
	((VMA) A-PAGE-TRACE-START)		;Wrap around
PAGE-TRACE-1
	((A-PAGE-TRACE-PTR) VMA)
	((M-FLAGS) C-PDL-BUFFER-POINTER-POP)	;Restore and return
	((PDL-BUFFER-INDEX) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-B) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-A) C-PDL-BUFFER-POINTER-POP)
	((A-PGF-T) C-PDL-BUFFER-POINTER-POP)
	(POPJ-AFTER-NEXT (A-PGF-WMD) C-PDL-BUFFER-POINTER-POP)
       ((A-PGF-VMA) C-PDL-BUFFER-POINTER-POP)

;;; Support for "user" disk I/O

XDSKOP (MISC-INST-ENTRY %DISK-OP)
	(CALL GAHDRA)		;Get disk-rq array, which must be temp-wired
	;; For now, no queueing, just perform request immediately
	((M-2) ADD (M-CONSTANT -1) A-DISK-REGS-BASE)	;Write user's values into disk control
	((M-3) (A-CONSTANT 4))		;3 real values plus 1 to start operations up
	((M-1) ADD M-E (A-CONSTANT (EVAL (1- (// %DISK-RQ-COMMAND 2)))))
XDSKOP1	((VMA-START-READ M-1) ADD M-1 (A-CONSTANT 1))
	(CHECK-PAGE-READ-NO-INTERRUPT)	;No interrupt in case disk hacked at interrupt level
					; which it currently is not.
	((M-3) SUB M-3 (A-CONSTANT 1))
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;Causes data to get parity-checked
	((VMA-START-WRITE M-2) ADD M-2 (A-CONSTANT 1))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(JUMP-GREATER-THAN M-3 A-ZERO XDSKOP1)
XDSKOP2	((VMA-START-READ) A-DISK-REGS-BASE)	;Await controller ready
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%DISK-STATUS-LOW-READY) READ-MEMORY-DATA XDSKOP2)
	((M-2) ADD M-E (A-CONSTANT (EVAL (1- (// %DISK-RQ-STATUS-LOW 2))))) ;Give status back
	((M-1) ADD (M-CONSTANT -1) A-DISK-REGS-BASE)
XDSKOP3	((VMA-START-READ M-1) ADD M-1 (A-CONSTANT 1))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-3) ADD M-3 (A-CONSTANT 1))
	((VMA-START-WRITE M-2) ADD M-2 (A-CONSTANT 1))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(JUMP-LESS-THAN M-3 (A-CONSTANT 4) XDSKOP3)	;Status is 4 words
	((WRITE-MEMORY-DATA) SETO)	;Set completion flag
	((VMA-START-WRITE) ADD M-E (A-CONSTANT (EVAL (// %DISK-RQ-DONE-FLAG 2))))
	(CHECK-PAGE-WRITE)
	(JUMP XFALSE)

;;; INTERRUPTS

;;; This code looks for a Unibus interrupt.  If it finds one it checks whether
;;; it was a keyboard interrupt; if so the character is read out and stored
;;; into the keyboard buffer.  Then the bus interface is readied to take another
;;; interrupt.

;;; Interrupts may clobber only what page faults clobber, plus the A-INTR-TEM
;;; registers.  Interrupts may take page faults to set up the map, but may
;;; not swap in pages.  Interrupts save and restore VMA and MD, but may
;;; possibly invalidate MAP[VMA] and MAP[MD].  Note that if you use
;;; (CHECK-PAGE-READ), an interrupt may occur after the read, and if you
;;; use (CHECK-PAGE-WRITE), an interrupt may occur after the write,
;;; or before it if the page is not swapped in.
;;; It is best if interrupts don't touch the pdl buffer.

INTR	(CALL-IF-BIT-SET M-INTERRUPT-FLAG ILLOP);Recursive interrupt!
	((A-INTR-VMA) VMA)			;Mustn't bash the VMA
	((A-INTR-MD) MD)			; nor the MD
	((M-INTERRUPT-FLAG) DPB (M-CONSTANT -1) A-FLAGS) ;No page faults allowed here
	((VMA-START-READ) (A-CONSTANT 77773020)) ;Unibus address 766040 (interrupt status)
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-A) M-A)			;I need a couple M registers
	((A-INTR-B) M-B)
	(CALL-IF-BIT-CLEAR (BYTE-FIELD 1 15.) MD ILLOP)	;If not unibus interrupt, lossage
	((M-B) SELECTIVE-DEPOSIT MD (BYTE-FIELD 8 2) A-ZERO)	;Interrupt vector address
	(JUMP-EQUAL M-B (A-CONSTANT 270) CHAOS-INTR)	;Chaos net has special handler
	;No specially provided device handler, maybe this is a general buffered device
	;E.g. the keyboard is one.
	((M-A) (A-CONSTANT (EVAL (+ 400 %SYS-COM-UNIBUS-INTERRUPT-LIST
				    %UNIBUS-CHANNEL-VECTOR-ADDRESS
				    (- %UNIBUS-CHANNEL-LINK)))))
INTR-0	((VMA-START-READ) ADD M-A
		(A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-LINK %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(CALL-EQUAL READ-MEMORY-DATA A-ZERO ILLOP)	;Reached end of list, lossage occurring
	((VMA-START-READ M-A) ADD MD (A-CONSTANT (EVAL %UNIBUS-CHANNEL-VECTOR-ADDRESS)))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-NOT-EQUAL MD A-B INTR-0)		;Loop until find device with this vector
	((VMA-START-READ) ADD M-A
	    (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-CSR-BITS %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-TEM1) READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-A
	    (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-CSR-ADDRESS %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((VMA-START-READ) READ-MEMORY-DATA)
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-TEM1) AND READ-MEMORY-DATA A-INTR-TEM1)
	(JUMP-EQUAL A-INTR-TEM1 M-ZERO UB-INTR-RET)	;Device's ready bit not on
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-BUFFER-IN-PTR
						       %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-B) READ-MEMORY-DATA)
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-DATA-ADDRESS
						       %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-IF-BIT-CLEAR Q-FLAG-BIT READ-MEMORY-DATA INTR-1)	;Jump if one-word device
	((VMA-START-READ) ADD MD (A-CONSTANT 1))	;Two-word device (kbd) needs to
	(CHECK-PAGE-READ-NO-INTERRUPT)			; read the high-order word first.
	((A-INTR-TEM1) DPB READ-MEMORY-DATA (BYTE-FIELD 20 20) A-ZERO)
	((VMA-START-READ) SUB VMA (A-CONSTANT 1))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-XCT-NEXT INTR-2)
       ((MD) (BYTE-FIELD 20 0) READ-MEMORY-DATA A-INTR-TEM1)

INTR-1	((VMA-START-READ) READ-MEMORY-DATA)	;Get device data
	(CHECK-PAGE-READ-NO-INTERRUPT)
INTR-2	((VMA-START-WRITE) M-B)			;Write into buffer
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-BUFFER-END
						       %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-B) ADD M-B (A-CONSTANT 1))		;Advance storing pointer
	(JUMP-GREATER-THAN READ-MEMORY-DATA A-B INTR-3)
	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-BUFFER-START
						       %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-B) READ-MEMORY-DATA)
INTR-3	((VMA-START-READ) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-BUFFER-OUT-PTR
						       %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-EQUAL READ-MEMORY-DATA A-B UB-INTR-RET)	;Don't advance IN ptr if buffer full
	((WRITE-MEMORY-DATA) M-B)
	((VMA-START-WRITE) ADD M-A (A-CONSTANT (EVAL (- %UNIBUS-CHANNEL-BUFFER-IN-PTR
						        %UNIBUS-CHANNEL-VECTOR-ADDRESS))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
UB-INTR-RET
	((MD) A-ZERO)				;Clear Unibus interrupt flag
	((VMA-START-WRITE) (A-CONSTANT 77773021)) ;Unibus address 766042
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((MD) (A-CONSTANT 6000))		;Enable one more Unibus interrupt
	((VMA-START-WRITE) (A-CONSTANT 77773020)) ;Unibus address 766040
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((M-B) A-INTR-B)
	((M-A) A-INTR-A)
	((M-INTERRUPT-FLAG) DPB (M-CONSTANT 0) A-FLAGS)	;Allow page faults again
	(POPJ-AFTER-NEXT (MD) A-INTR-MD)	;Dismiss
       ((VMA) A-INTR-VMA)

;;; Come here for Unibus interrupt from Chaos network

(ASSIGN CHAOS-NUMBER-TRANSMIT-RETRIES 3)

CHAOS-INTR
	((VMA-START-READ M-B) A-CHAOS-CSR-ADDRESS) ;M-B has base address of hardware
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%CHAOS-CSR-RECEIVE-DONE) READ-MEMORY-DATA
		CHAOS-XMT-INTR)			;See if received a packet
	((A-INTR-TEM2) Q-POINTER READ-MEMORY-DATA	;Save CSR for later
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT CHAOS-LIST-GET)		;M-A gets next packet from free list
       ((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-FREE-LIST))))
	(JUMP-EQUAL M-A A-V-NIL CHAOS-XMT-INTR)	;Can't receive now, hold up
	;; Read out the packet into this buffer, along with CSR1, CSR2, Bit-count
	;; M-A points at the buffer and M-B points at the hardware
	;; Buffer is assumed to be big enough for max possible word count (255)
	((WRITE-MEMORY-DATA) A-INTR-TEM2)	;Save CSR1
	((VMA-START-WRITE) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-CSR-1))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((VMA-START-READ) ADD M-B (A-CONSTANT (EVAL %CHAOS-BIT-COUNT-OFFSET)))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((WRITE-MEMORY-DATA M-TEM) M+A+1 READ-MEMORY-DATA	;Type bits are 0, bit count is
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	;off by 1
	((A-INTR-TEM1) (BYTE-FIELD 8 4) M-TEM)	;Get word count, then save bit count
	((VMA-START-WRITE) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-BIT-COUNT))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((WRITE-MEMORY-DATA) SELECTIVE-DEPOSIT WRITE-MEMORY-DATA
		Q-ALL-BUT-POINTER A-INTR-TEM1)	;Save word count
	((VMA-START-WRITE) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-WORD-COUNT))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((A-INTR-TEM2) (A-CONSTANT 1))		;Offset in buffer array
CHAOS-RCV-INTR-LOOP	;Read two words out of the hardware, then store them
	((VMA-START-READ) ADD M-B (A-CONSTANT (EVAL %CHAOS-READ-BUFFER-OFFSET)))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-TEM1) ADD (M-CONSTANT -1) A-INTR-TEM1)	;Count down word count
	((M-TEM) READ-MEMORY-DATA)		;Save low word
	(JUMP-EQUAL M-ZERO A-INTR-TEM1 CHAOS-RCV-INTR-1)	;If word count was odd
	((VMA-START-READ) VMA)			;Get high word
	(ILLOP-IF-PAGE-FAULT)			;Mustn't bash M-TEM
	((A-INTR-TEM1) ADD (M-CONSTANT -1) A-INTR-TEM1)	;Count down word count
CHAOS-RCV-INTR-1
	((WRITE-MEMORY-DATA) DPB READ-MEMORY-DATA (BYTE-FIELD 20 20) A-TEM)
	((VMA-START-WRITE) ADD M-A A-INTR-TEM2)	;Write two halfwords into buffer
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(JUMP-LESS-THAN-XCT-NEXT M-ZERO A-INTR-TEM1 CHAOS-RCV-INTR-LOOP)
       ((A-INTR-TEM2) M+A+1 M-ZERO A-INTR-TEM2)
	;; Now save CSR2, enable next receive, and cons onto receive list
	((VMA-START-READ) M-B)			;Get CSR
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((WRITE-MEMORY-DATA) Q-POINTER READ-MEMORY-DATA
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-CSR-2))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((WRITE-MEMORY-DATA) IOR WRITE-MEMORY-DATA
		(A-CONSTANT (BYTE-MASK %%CHAOS-CSR-RECEIVER-CLEAR)))
	((VMA-START-WRITE) M-B)			;Write CSR to clear receiver
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(CALL-XCT-NEXT CHAOS-LIST-PUT)		;Add packet in M-A to receive list
       ((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-RECEIVE-LIST))))
;drops through
;drops in
;; Here to dismiss the interrupt.  We must decide on the interrupt enables.
;; If there are any free buffers, we can enable receive interrupts.
;; If there are any buffers wanting to be transmitted, we can enable transmit interrupts.
CHAOS-INTR-EXIT (MISC-INST-ENTRY %CHAOS-WAKEUP)	;User also calls this! Note nothing in M-T!
	((M-A) SETZ)				;20 = receive-enable, 40 = transmit-enable
	((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-FREE-LIST))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-V-NIL CHAOS-INTR-EXIT-1)
	((M-A) DPB (M-CONSTANT -1) (LISP-BYTE %%CHAOS-CSR-RECEIVE-ENABLE) A-A)
						;Free list not empty, enable receive done
CHAOS-INTR-EXIT-1
	((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-TRANSMIT-LIST))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-TEM) Q-TYPED-POINTER READ-MEMORY-DATA)
	(JUMP-EQUAL M-TEM A-V-NIL CHAOS-INTR-EXIT-2)
	((M-A) DPB (M-CONSTANT -1) (LISP-BYTE %%CHAOS-CSR-TRANSMIT-ENABLE) A-A)
						;Xmt list not empty, enable transmit done
CHAOS-INTR-EXIT-2
	((VMA-START-READ) A-CHAOS-CSR-ADDRESS)	;M-B not valid if called as misc inst
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-TEM) READ-MEMORY-DATA)
	((WRITE-MEMORY-DATA-START-WRITE) SELECTIVE-DEPOSIT M-A
		(LISP-BYTE %%CHAOS-CSR-INTERRUPT-ENABLES) A-TEM)
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(JUMP UB-INTR-RET)

;;; Transmit interrupt handler
;;; A-CHAOS-TRANSMIT-RETRY-COUNT is 0 if nothing going on, otherwise number of retries
;;; before we should give up.  Note buffer not removed from list until done.
CHAOS-XMT-INTR
	((VMA-START-READ) M-B)			;Fetch CSR again
	(CHECK-PAGE-READ-NO-INTERRUPT)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%CHAOS-CSR-TRANSMIT-DONE) READ-MEMORY-DATA
		CHAOS-INTR-EXIT)
	(JUMP-EQUAL M-ZERO A-CHAOS-TRANSMIT-RETRY-COUNT CHAOS-XMT-0) ;Jump if transmit idle
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%CHAOS-CSR-TRANSMIT-ABORT) READ-MEMORY-DATA
		CHAOS-XMT-DONE)			;Jump if transmit done and not aborted
	((A-COUNT-CHAOS-TRANSMIT-ABORTS) M+A+1 M-ZERO A-COUNT-CHAOS-TRANSMIT-ABORTS)
	;; If transmit aborted, keep trying until count runs out, then give up
	((A-CHAOS-TRANSMIT-RETRY-COUNT) ADD (M-CONSTANT -1) A-CHAOS-TRANSMIT-RETRY-COUNT)
	(JUMP-EQUAL M-ZERO A-CHAOS-TRANSMIT-RETRY-COUNT CHAOS-XMT-DONE)	;Give up
CHAOS-XMT-0
	;; Get current or next transmit packet
	((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-TRANSMIT-LIST))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((M-A) Q-TYPED-POINTER READ-MEMORY-DATA) ;Note, don't call CHAOS-LIST-GET
						;since we are leaving it on the list for now
	(JUMP-EQUAL M-A A-V-NIL CHAOS-INTR-EXIT)	;Nothing to transmit, give up
	;; If this is not a retransmission, initialize retry count
	(JUMP-NOT-EQUAL M-ZERO A-CHAOS-TRANSMIT-RETRY-COUNT CHAOS-XMT-1)
	((A-CHAOS-TRANSMIT-RETRY-COUNT) (A-CONSTANT CHAOS-NUMBER-TRANSMIT-RETRIES))
CHAOS-XMT-1
	((VMA-START-READ) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-WORD-COUNT))))
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-TEM2) (A-CONSTANT 1))		;Offset in buffer
	((A-INTR-TEM1) Q-POINTER READ-MEMORY-DATA)	;Halfword count
CHAOS-XMT-2
	((VMA-START-READ) ADD M-A A-INTR-TEM2)	;Get a pair of halfwords
	(CHECK-PAGE-READ-NO-INTERRUPT)
	((A-INTR-TEM1) ADD (M-CONSTANT -1) A-INTR-TEM1)	;Count down word count
	((WRITE-MEMORY-DATA) READ-MEMORY-DATA)	;Write first halfword into hardware
	((VMA-START-WRITE) ADD M-B (A-CONSTANT (EVAL %CHAOS-WRITE-BUFFER-OFFSET)))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	(JUMP-EQUAL M-ZERO A-INTR-TEM1 CHAOS-XMT-3)	;Done if was odd number of words
	((WRITE-MEMORY-DATA-START-WRITE) (BYTE-FIELD 20 20) WRITE-MEMORY-DATA)
	(CHECK-PAGE-WRITE-NO-INTERRUPT)		;Write second halfword into hardware
	((A-INTR-TEM1) ADD (M-CONSTANT -1) A-INTR-TEM1)	;Count down word count
	(JUMP-LESS-THAN-XCT-NEXT M-ZERO A-INTR-TEM1 CHAOS-XMT-2)
       ((A-INTR-TEM2) M+A+1 M-ZERO A-INTR-TEM2)
CHAOS-XMT-3
	((VMA-START-READ) ADD M-B (A-CONSTANT (EVAL %CHAOS-START-TRANSMIT-OFFSET)))
	(CHECK-PAGE-READ-NO-INTERRUPT)		;Initiate transmission
	(JUMP CHAOS-INTR-EXIT)

;; Here when we were are through with a transmit packet.
CHAOS-XMT-DONE
	(CALL-XCT-NEXT CHAOS-LIST-GET)		;Pull this guy off xmt list, we're done with it
       ((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-TRANSMIT-LIST))))
	(CALL-XCT-NEXT CHAOS-LIST-PUT)		;Add to free list
       ((VMA-START-READ) (A-CONSTANT (EVAL (+ 400 %SYS-COM-CHAOS-FREE-LIST))))
	(JUMP-XCT-NEXT CHAOS-XMT-0)		;Now transmit more if possible
       ((A-CHAOS-TRANSMIT-RETRY-COUNT) SETZ)	;Transmit not in progress now

;;; Take packet off list which has been VMA-START-READ, return it in M-A
;;; M-A can return with NIL in it.  Uses A-INTR-TEM1
CHAOS-LIST-GET
	(CHECK-PAGE-READ-NO-INTERRUPT)		;MD gets first buffer on list
	((A-INTR-TEM1) VMA)			;Save address of list header
	((M-A) Q-TYPED-POINTER READ-MEMORY-DATA)
	(POPJ-EQUAL M-A A-V-NIL)		;Return if list empty
	((VMA-START-READ) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-THREAD))))
	(CHECK-PAGE-READ-NO-INTERRUPT)		;MD gets next buffer on list
	((WRITE-MEMORY-DATA) Q-TYPED-POINTER READ-MEMORY-DATA)
	(POPJ-AFTER-NEXT (VMA-START-WRITE) A-INTR-TEM1)
       (CHECK-PAGE-WRITE-NO-INTERRUPT)

;;; Put packet in M-A onto list which has been VMA-START-READ
;;; Uses A-INTR-TEM1
CHAOS-LIST-PUT
	(CHECK-PAGE-READ-NO-INTERRUPT)		;MD gets present first buffer on list
	((A-INTR-TEM1) VMA)			;Save address of list header
	((WRITE-MEMORY-DATA) Q-TYPED-POINTER READ-MEMORY-DATA)	;Thread onto new first buffer
	((VMA-START-WRITE) SUB M-A (A-CONSTANT (EVAL (+ 2 %CHAOS-LEADER-THREAD))))
	(CHECK-PAGE-WRITE-NO-INTERRUPT)
	((WRITE-MEMORY-DATA) Q-TYPED-POINTER M-A)	;Change list header
	(POPJ-AFTER-NEXT (VMA-START-WRITE) A-INTR-TEM1)
       (CHECK-PAGE-WRITE-NO-INTERRUPT)

;PDL-BUFFER LOADING CONVENTIONS:
;   1. THE CURRENT RUNNING FRAME IS ALWAYS COMPLETELY CONTAINED WITHIN THE PDL-BUFFER.
;   2. SO IS ITS CALLING ADI (LOCATED IMMEDIATELY BEFORE IT ON PDL).
;   3. POINTERS ASSOCIATED WITH ADI (SUCH AS MULTIPLE VALUE STORING POINTERS
;	AND INDIRECT-ADI POINTERS) MAY POINT AT REGIONS OF THE PDL WHICH
;	ARE NOT CONTAINED WITHIN THE PDL-BUFFER.

;CHECKING TO SEE IF PDL-BUFFER NEEDS TO BE REFILLED:
;   SINCE M-AP CHANGES MUCH LESS FREQUENTLY THAN THE PDL-BUFFER POINTER ITSELF,
; ALL TESTING FOR PDL-BUFFER DUMPING/REFILLING IS DONE WITH REFERENCE TO M-AP.
; AS A RESULT, 400 (OCTAL) WORDS (THE MAXIMUM FRAME SIZE) EXTRA SLOP MUST BE LEFT.
; M-PDL-BUFFER-ACTIVE-QS CONTAINS THE NUMBER OF QS BETWEEN A-PDL-BUFFER-HEAD
; AND M-AP (MOMENTARILY, IT MAY BE NEGATIVE).
; WHENEVER M-AP IS CHANGED, M-PDL-BUFFER-ACTIVE-QS MUST LIKEWISE BE ADJUSTED.
;    CLEARLY, M-PDL-BUFFER-ACTIVE-QS MUST BE AT LEAST 4 FOR ANY CODE TO BE RUNNABLE.
; IN ADDITION, THE ADI OF THE RUNNING FRAME, IF ANY, MUST ALSO BE IN THE PDL-BUFFER.
; IF M-PDL-BUFFER-ACTIVE-QS IS GREATER THAN THE CONSTANT PDL-BUFFER-LOW-WARNING
; (SET TO 4 + MAX LENGTH OF ADI), IT MAY SAFELY BE ASSUMED THAT THE ADI, IF ANY,
; IS IN.
;    WHENEVER M-AP IS ADJUSTED DOWNWARD (POPPED), M-AP SHOULD BE ADJUSTED BEFORE
; M-PDL-BUFFER-ACTIVE-QS TESTED, SO THAT M-AP IS AT ITS NEW VALUE IF AND WHEN 
; PDL-BUFFER-REFILL IS REACHED.

;ROUTINE TO UNLOAD PDL-BUFFER INTO MAIN MEMORY, MAKING AT LEAST N WDS
; OF ROOM IN PDL BUFFER.  GENERAL IDEA IS START AT PDL-BUFFER INDEX A-PDL-BUFFER-HEAD
; AND VIRTUAL ADDRESS A-PDL-BUFFER-VIRTUAL-ADDRESS, WRITING OUT CRUFT AND INCREMENTING
; BOTH POINTERS.  ONE OPTIMIZATION IS WE FIDDLE MAP TO AVOID GOING THRU
; PAGE FAULT HANDLER ON EVERY CYCLE (WHICH WOULDNT QUITE WORK ANYWAY SINCE IT
; WOULD WRITE THE STUFF BACK IN THE PDL-BUFFER).  THUS, WE HAVE TO KEEP TRACK OF
; WHICH MAP PAGE WE HAVE HACKED AND PUT IT BACK AT END.  ALSO, CHECK IF MOVING TO A
; NEW PAGE, ETC.

PDL-BUFFER-DUMP 
	((M-2) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
	(CALL-NOT-EQUAL M-2 A-PDL-BUFFER-HIGH-WARNING TRAP)	;PUSH-DOWN CAPACITY EXCEEDED
   (ERROR-TABLE PDL-OVERFLOW REGULAR)	;I.E. ALREADY NEAR END, THERE IS PROBABLY JUST
					;ENOUGH SPACE LEFT TO DUMP WHAT'S IN THE PDL BUFFER NOW
			;HERE I AM ASSUMING THAT A-PDL-BUFFER-HIGH-WARNING IS GUARANTEED
			;NOT TO COME OUT NEGATIVE AFTER PDL-BUFFER-MAKE-ROOM RETURNS,
			;BECAUSE OF THE CHECK ABOVE.  THIS USED TO BE CHECKED.
;ARG IN M-2 -> HIGHEST "SATISFACTORY" VALUE FOR M-PDL-BUFFER-ACTIVE-QS.
; COMMON VALUES ARE PDL-BUFFER-HIGH-LIMIT TO UNBLOAT PDL-BUFFER OR
;   0 TO COMPLETELY DUMP PDL-BUFFER (THRU M-AP) OR
; - (PP - M-AP) [MINUS SIZE OF ACTIVE FRAME] TO REALLY COMPLETELY DUMP PDL-BUFFER
PDL-BUFFER-MAKE-ROOM 			;ARG IN M-2
	((A-PDLB-TEM) PDL-BUFFER-INDEX)	;PRESERVE..
P-B-MR0
	((VMA-START-READ) A-PDL-BUFFER-VIRTUAL-ADDRESS)  ;TAKE A READ CYCLE TO
	(CHECK-PAGE-READ-NO-INTERRUPT)			 ;MAKE SURE 2ND LVL MAP SET UP, ETC
		;NOTE A REFERENCE IS GUARANTEED TO SET UP 2ND LEVEL MAP
		;EVEN IF IT TURNS OUT TO BE IN THE PDL-BUFFER AND NO MAIN MEMORY
		;CYCLE IS MADE.
	((MD Q-R) VMA)				;ADDRESS THE MAP
	((M-PGF-TEM) MAP-SECOND-LEVEL-MAP MEMORY-MAP-DATA)
						;SAVE CORRECT MAP CONTENTS
						;OK TO USE M-PGF-TEM SINCE NOT GOING TO FAULT
	((VMA-WRITE-MAP) IOR M-PGF-TEM		;TURN ON ACCESS
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3)))) ;R/W
P-B-MR1	(JUMP-LESS-OR-EQUAL M-PDL-BUFFER-ACTIVE-QS A-2 P-B-MRX)	;THROUGH, CLEAN UP
	((VMA) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((PDL-BUFFER-INDEX) A-PDL-BUFFER-HEAD)
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-INDEX)
	(ILLOP-IF-PAGE-FAULT)			;WRITE-ACCESS SUPPOSEDLY TURNED ON.
	(DISPATCH Q-DATA-TYPE WRITE-MEMORY-DATA D-ILLOP-IF-BAD-DATA-TYPE)
						;ERROR-CHECK STUFF BEING WRITTEN
	((M-PDL-BUFFER-ACTIVE-QS) SUB 
		M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))		;MADE ONE Q WORTH OF ROOM
	((M-1) ADD M-ZERO A-PDL-BUFFER-HEAD ALU-CARRY-IN-ONE)
	((A-PDL-BUFFER-HEAD) DPB M-1 (BYTE-FIELD 10. 0) A-ZERO)
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) 
	    ADD M-ZERO A-PDL-BUFFER-VIRTUAL-ADDRESS ALU-CARRY-IN-ONE)
	(GC-WRITE-TEST (I-ARG 1))	;CHECK FOR WRITING PTR TO EXTRA-PDL
						;IF TRAPS, WILL RETURN TO P-B-MR0
	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER-WITHIN-PAGE A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(JUMP-NOT-EQUAL M-ZERO A-1 P-B-MR1)	;NOT MOVING TO A NEW PAGE, CONTINUE
;HERE TO RESTORE THE MAP.  VMA POINTS AT THE LAST LOCATION ON THE PAGE.
P-B-MR2	((MD) Q-R)				;ADDRESS THE MAP
	(JUMP-XCT-NEXT P-B-MR0)			;LOOP BACK BECAUSE 2ND LVL MAP FOR NEW
						; PAGE MAY NOT BE SET UP.
       ((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))

;HERE WHEN WE'RE DONE, BUT STILL HAVE TO UNMUNG THE MAP.
P-B-MRX	((MD) Q-R)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
;HERE WHEN WE'RE DONE
P-B-X1	((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-QLPDLH)	;RECOMPUTE A-PDL-BUFFER-HIGH-WARNING
	((M-2) SUB M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-2) SUB M-2 (A-CONSTANT 2000))  ;GET NEGATIVE NUMBER IF NOT ENUF ROOM IN STACK IN
								;MAIN MEM TO HOLD ENTIRE P.B
	(JUMP-LESS-THAN M-2 A-ZERO P-B-SL-1)
	(POPJ-AFTER-NEXT			;ENUF ROOM, ALLOW P.B. TO FILL
	 (A-PDL-BUFFER-HIGH-WARNING) (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
       ((PDL-BUFFER-INDEX) A-PDLB-TEM)		;RESTORE

;GETTING NEAR THE END OF THE STACK.  SET A-PDL-BUFFER-HIGH-WARNING
;SO THAT WE WILL TRAP TO PDL-BUFFER-DUMP BEFORE GETTING MORE STUFF
;INTO THE PDL BUFFER THAN THERE IS ROOM TO STORE INTO MAIN MEMORY.
;NOTE THAT THIS RESULT CAN ACTUALLY BE NEGATIVE IF WE ARE CURRENTLY
;IN THE PROCESS OF TAKING A PDL-OVERFLOW TRAP.
P-B-SL-1(POPJ-AFTER-NEXT
	 (A-PDL-BUFFER-HIGH-WARNING) ADD M-2 (A-CONSTANT PDL-BUFFER-HIGH-LIMIT))
       ((PDL-BUFFER-INDEX) A-PDLB-TEM)		;RESTORE

;ATTEMPT TO REFILL PDL-BUFFER FROM MAIN MEMORY SUCH THAT
;M-PDL-BUFFER-ACTIVE-QS IS AT LEAST PDL-BUFFER-LOW-WARNING.
PDL-BUFFER-REFILL	
	((A-PDLB-TEM) PDL-BUFFER-INDEX)	;PRESERVE IT.
	((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-QLPDLO)	;SO AS TO HAVE A COPY IN M-MEM, 
					; ALSO FLUSH GARBAGE.
P-R-0	(JUMP-GREATER-OR-EQUAL M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS 
				P-R-AT-BOTTOM)	;NO MORE PDL TO RELOAD, MAP NOT HACKED.
	((VMA-START-READ) ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(CHECK-PAGE-READ-NO-INTERRUPT)		;TAKE CYCLE TO ASSURE 2ND LVL MAP SET UP
	((MD Q-R) VMA)				;ADDRESS THE MAP
	((M-PGF-TEM) MAP-SECOND-LEVEL-MAP MEMORY-MAP-DATA)	;SAVE CORRECT MAP CONTENTS
	((VMA-WRITE-MAP) IOR M-PGF-TEM		;TURN ON ACCESS TO MEM WHICH SHADOWS PDL BUF
		(A-CONSTANT (PLUS (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)
				  (BYTE-VALUE MAP-ACCESS-CODE 3)))) ;R/W
P-R-1	(JUMP-GREATER-OR-EQUAL M-PDL-BUFFER-ACTIVE-QS 
	   (A-CONSTANT PDL-BUFFER-LOW-WARNING) P-B-MRX)	;ENOUGH IN THERE TO WIN.
	(JUMP-GREATER-OR-EQUAL M-2 A-PDL-BUFFER-VIRTUAL-ADDRESS 
			P-R-AT-BOTTOM-1)	;NO MORE PDL TO RELOAD, MAP IS HACKED.
	((VMA-START-READ) ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(ILLOP-IF-PAGE-FAULT)			;MAP SHOULD BE HACKED
	(DISPATCH Q-DATA-TYPE-PLUS-ONE-BIT	;TRANSPORT THE DATA JUST READ FROM MEMORY
		DISPATCH-ON-MAP-19
		READ-MEMORY-DATA D-PB-TRANS)	;RUNNING CLEANUP HANDLER FIRST
	((PDL-BUFFER-INDEX) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)
	((C-PDL-BUFFER-INDEX) READ-MEMORY-DATA)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))
	((A-PDL-BUFFER-HEAD) PDL-BUFFER-INDEX)	;ALSO EFFECTIVELY PERFORMS MASKING
	((A-PDL-BUFFER-VIRTUAL-ADDRESS)
	    ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)
	((M-1) DPB M-ZERO Q-ALL-BUT-POINTER-WITHIN-PAGE A-PDL-BUFFER-VIRTUAL-ADDRESS)
	(JUMP-NOT-EQUAL M-1 A-ZERO P-R-1)	;XFER ON NEXT WORD IN SAME PAGE AS THIS
	((MD) Q-R)				;ADDRESS THE MAP
	(JUMP-XCT-NEXT P-R-0)
       ((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))

;HERE IF TRANSPORT REQUIRED WHILE RELOADING.  CLEAN UP THE MAP FIRST.
PB-TRANS((C-PDL-BUFFER-POINTER-PUSH) A-PDLB-TEM)	;SAVE STUFF MOMENTARILY
	((C-PDL-BUFFER-POINTER-PUSH) MD)
	((MD) VMA)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
	((VMA) MD)				;RESTORE VMA
	((MD) C-PDL-BUFFER-POINTER-POP)		;RESTORE MD
	(DISPATCH TRANSPORT MD)			;NOW INVOKE THE TRANSPORTER
	((A-PDLB-TEM) C-PDL-BUFFER-POINTER-POP)	;RESTORE A-PDLB-TEM, LOST BY TRANSPORTER
	((PDL-BUFFER-INDEX) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)
	((C-PDL-BUFFER-INDEX) READ-MEMORY-DATA)	;SAVE THE TRANSPORTED DATUM ON THE PDL
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 1))
	((A-PDL-BUFFER-HEAD) PDL-BUFFER-INDEX)	;ALSO EFFECTIVELY PERFORMS MASKING
	(JUMP-XCT-NEXT P-R-0)			;NOW RE-START FAST LOOP FOR NEXT WORD
       ((A-PDL-BUFFER-VIRTUAL-ADDRESS)
	    ADD (M-CONSTANT -1) A-PDL-BUFFER-VIRTUAL-ADDRESS)

P-R-AT-BOTTOM-1 
	((MD) Q-R)				;ADDRESS THE MAP
	((VMA-WRITE-MAP) DPB M-PGF-TEM		;RESTORE THE MAP
		MAP-WRITE-SECOND-LEVEL-MAP
		(A-CONSTANT (BYTE-MASK MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE)))
P-R-AT-BOTTOM
	(CALL-LESS-THAN M-PDL-BUFFER-ACTIVE-QS (A-CONSTANT 4) ILLOP)	;OVER POP ..
	(JUMP P-B-X1)

;STACK-GROUP STUFF
; THE STACK GROUP QS MAY BE CONSIDERED TO BE DIVIDED INTO THREE GROUPS:
;   STATIC POINTERS, DYNAMIC STATE, AND LINKAGE QS.
; STATIC POINTERS ARE THINGS LIKE PDL ORIGINS.  THEY ARE LOADED, BUT NEVER STORED
;  BY STACK GROUP HACKING ROUTINES.
; DYNAMIC STATE ARE THINGS WHICH ARE CHANGED DURING THE OPERATION OF THE MACHINE.
;  THEY ARE BOTH LOADED AND STORED.
; LINKAGE QS ARE THINGS LIKE SG-STATE, SG-PREVIOUS-STACK-GROUP, ETC.  THEY ARE NOT
;  LOADED AND UNLOADED FROM A-MEMORY BY THE LOW LEVEL ROUTINES, BUT NOT "UPDATED".
;EACH OF THESE GROUPS IS ALLOCATED A CONTIGIOUS AREA WITHIN THE STACK-GROUP-HEADER.

; WHEN SAVING STATE, THINGS ARE FIRST SAVED IN THE PDL-BUFFER.  THE ENTIRE BLOCK
;IS THEN WRITTEN TO MAIN MEMORY.  WHEN RESTORING, THE ENTIRE BLOCK IS READ INTO
;THE PDL BUFFER, THEN RESTORED TO THE APPROPRIATE PLACES.  SINCE GENERALLY THE MOST
;"VOLATILE" THINGS WANT TO BE SAVED FIRST AND RESTORED LAST, A SORT OF PUSH DOWN LIKE
;OPERATION IS APPROPRIATE.  THUS THE VMA PUSHED ONTO THE PDL-BUFFER FIRST.
;ON THE STORE INTO MAIN MEMORY, IT IS STORED LAST.  THE STORING PROCEEDS IN LEADER
;INDEX ORDER (IE COUNTING DOWN IN MEMORY).  THUS THE VMA WINDS UP IN THE LOWEST
;Q OF THE ARRAY LEADER (JUST BEYOND THE LEADER-HEADER).  ON THE RELOAD,
;THE VMA IS THE FIRST THING READ FROM MEMORY.  IT THUS BECOMES DEEPEST ON THE PDL-BUFFER
;STACK, AND IS THE LAST THING RESTORED TO THE REAL MACHINE.  (ACTUALLY, THE VERY FIRST
;THING SAVED IS THE PDL-BUFFER-PHASING Q, WHICH IS SOMEWHAT SPECIAL SINCE IT IS ACTUALLY
;"USED" WHEN FIRST READ ON THE RELOAD).

;STORE DYNAMIC STATE OF MACHINE IN CURRENT STACK GROUP
;  MUST NOT CLOBBER M-A ON IMMEDIATE RETURN (THAT CAN HAVE SG-GOING-TO)
SGLV		;STORE EVERYTHING IN PDL-BUFFER IN REVERSE ORDER ITS TO BE WRITTEN TO MEMORY
		;M-TEM HAS DESIRED NEW STATE FOR CURRENT STACK GROUP.  SWAP L-B-P OF
		;CURRENT STACK GROUP UNLESS 1.7 OF M-TEM IS 1.
	((M-STACK-GROUP-SWITCH-FLAG) DPB (M-CONSTANT -1) A-FLAGS) ;SHUT OFF TRAPS, ETC.
	((M-3) A-QCSTKG)
	((M-3) Q-DATA-TYPE M-3)
	(CALL-NOT-EQUAL M-3 (A-CONSTANT (EVAL DTP-STACK-GROUP)) ILLOP)

	((A-SG-STATE) DPB M-TEM (LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
	((M-4) PDL-BUFFER-POINTER)		;SAVE ORIGINAL PDL LVL

	((C-PDL-BUFFER-POINTER-PUSH) DPB M-4 Q-POINTER 		;SAVE PDL-BUFFER-POINTER
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))	; FOR PHASING.
	((C-PDL-BUFFER-POINTER-PUSH) DPB VMA Q-POINTER	;SAVE VMA AS A LOCATIVE
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))
	((M-3) Q-ALL-BUT-POINTER VMA		;SAVE TAGS OF VMA, M-1, AND M-2 AS FIXNUM
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA) Q-ALL-BUT-POINTER M-1)
	((M-3) DPB VMA (BYTE-FIELD 8 8) A-3)
	((VMA) Q-ALL-BUT-POINTER M-2)
	((C-PDL-BUFFER-POINTER-PUSH) DPB VMA (BYTE-FIELD 8 16.) A-3)
	((C-PDL-BUFFER-POINTER-PUSH) Q-POINTER M-1	;SAVE POINTERS OF M-1, M-2 AS FIXNUMS
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((C-PDL-BUFFER-POINTER-PUSH) Q-POINTER M-2
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-1) (A-CONSTANT (M-MEM-LOC M-ZR)))   ;SAVE REGS M-ZR THROUGH M-K
SGLV0	((OA-REG-HIGH) DPB M-1 OAH-M-SRC A-ZERO)
	((C-PDL-BUFFER-POINTER-PUSH) M-GARBAGE)		;M-GARBAGE = 0@M
	(JUMP-LESS-THAN-XCT-NEXT M-1 (A-CONSTANT (M-MEM-LOC M-K)) SGLV0)
       ((M-1) ADD M-1 (A-CONSTANT 1))

	(JUMP-IF-BIT-SET-XCT-NEXT M-TEM (BYTE-FIELD 1 6) SGLV2)	;WANT TO SWAP THIS GUY' L-B-P?
       ((C-PDL-BUFFER-POINTER-PUSH) DPB M-FLAGS Q-POINTER 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-J) A-QLBNDP)
SGLV3	(JUMP-LESS-OR-EQUAL M-J A-QLBNDO SGLV4)		;XFER ON THRU
	((VMA-START-READ) M-J)
	(CHECK-PAGE-READ)
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) SGLV5)
SGVSP	(JUMP-IF-BIT-SET-XCT-NEXT Q-FLAG-BIT READ-MEMORY-DATA SGLV3)  ;NOT BINDING BLOCK
       ((M-J) SUB M-J (A-CONSTANT 1))				      ; SPACE PAST.
	(JUMP-LESS-OR-EQUAL M-J A-QLBNDO SGLV4)
	((VMA-START-READ) M-J)
	(CHECK-PAGE-READ)
	(JUMP SGVSP)

SGLV5	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-C) READ-MEMORY-DATA)		;POINTER TO INTERNAL V.C.
	((VMA-START-READ M-J) SUB M-J (A-CONSTANT 1))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-D) READ-MEMORY-DATA)		;OLD BINDING TO BE RESTORED
	((VMA-START-READ) M-C)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-ZR) READ-MEMORY-DATA)		;NEW BINDING TO BE SAVED
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-D Q-TYPED-POINTER A-ZR)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) DPB M-ZR Q-TYPED-POINTER A-D)
	((VMA-START-WRITE) M-J)
	(CHECK-PAGE-WRITE)
	(JUMP-XCT-NEXT SGLV3)		;IN THIS DIRECTION, NO NEED TO CHECK FLAG BITS
       ((M-J) SUB M-J (A-CONSTANT 1))	;SINCE THINGS MUST REMAIN PAIRED AS LONG AS IN BINDINGS

SGLV4	((A-SG-STATE) DPB (M-CONSTANT -1) (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) A-SG-STATE)
SGLV2	((C-PDL-BUFFER-POINTER-PUSH) A-QLARYL)
	((C-PDL-BUFFER-POINTER-PUSH) A-QLARYH)

	((C-PDL-BUFFER-POINTER-PUSH) A-TRAP-MICRO-PC)

	((PDL-BUFFER-INDEX) M-AP)		;IF RUNNING MACRO-CODE, SAVE MACRO PC
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;SIMULATES SGSTR DISPATCH IN LMI
	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) QLLV)

	((M-B) MICRO-STACK-DATA-POP)		;TAKE OFF RETURN FOR SGLV (AC'S SAVED NOW)
;	((PDL-BUFFER-INDEX) M-AP)		;UNCOMMENT THIS CODE WHEN MICROCOMPILED FCTNS
;	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ; REALLY EXIST. WOULD JUST WASTE SPACE TILL
;	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) MLLV)  ;THEN.  IDEA IS TO STORE
						;USTACK IN STANDARD FORM; (1) FOR CONSISTANCY
						;(2) BECAUSE IT MAY BE RESPONSIBLE FOR 
						;SPECIAL-PDL BINDING BLOCKS.
	(CALL QMMPSH)				;TRANSFER USTACK TO SPECIAL-PDL
	((MICRO-STACK-DATA-PUSH) M-B)		;PUT BACK RETURN FOR SGLV
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-T Q-POINTER 		;RECORD # QS XFER ED
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))  ;SG-U-STACK-QS

	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)		;SAVE A-IPMARK
       ((M-K) A-IPMARK)
	((M-K) SUB M-K A-QLPDLO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB Q-POINTER M-K 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)		;SAVE M-AP
       ((M-K) M-AP)
	((M-K) SUB M-K A-QLPDLO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB Q-POINTER M-K 
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

	((M-1) A-QLBNDP)
	((M-1) SUB M-1 A-QLBNDO)
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 		;SAVE L-B-P LEVEL
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K) M-4)			;SAVE P-B-POINTER AS RELATIVE ADR TO ENTIRE PDL
	((M-1) SUB M-K A-QLPDLO)	; ARRAY
	((C-PDL-BUFFER-POINTER-PUSH) DPB M-1 Q-POINTER 		;SAVE PDL LEVEL
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))

	((C-PDL-BUFFER-POINTER-PUSH) A-TRAP-AP-LEVEL)
;	((C-PDL-BUFFER-POINTER-PUSH) A-SG-FOLLOWING-STACK-GROUP)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-CALLING-ARGS-NUMBER)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-CALLING-ARGS-POINTER)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-PREVIOUS-STACK-GROUP)
	((C-PDL-BUFFER-POINTER-PUSH) A-SG-STATE)

	((M-2) SUB M-AP A-4)		;GET - QS IN ACTIVE FRAME (AS 10. BIT NEG NUMBER OR 0)
	(JUMP-EQUAL M-2 A-ZERO SGLV1)
	((M-2) (BYTE-FIELD 10. 0) M-2 (A-CONSTANT -1))	;EXTEND SIGN TO MAKE REAL NEG NUMBER.
SGLV1	(CALL PDL-BUFFER-MAKE-ROOM) ;CAUSE ENTIRE PDL-BUFFER TO GET WRITTEN OUT.
				    ;BUT NOT THE SG-LEADER STUFF PUSHED ABOVE
	((VMA) A-QCSTKG)
	((VMA) SUB VMA (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))  ;2 FOR LEADER HEADER
	(CALL-XCT-NEXT SG-WRITE-BLOCK-FROM-PDL-BUFFER)
      ((M-ZR) ADD M-ZERO (A-CONSTANT (DIFFERENCE (EVAL SG-PDL-PHASE) (EVAL SG-STATE)))
			ALU-CARRY-IN-ONE)	;WANT PHASE-STATE+1
	(POPJ-XCT-NEXT)
       ((M-STACK-GROUP-SWITCH-FLAG) DPB (M-CONSTANT 0) A-FLAGS)

SG-WRITE-BLOCK-FROM-PDL-BUFFER 
	((WRITE-MEMORY-DATA-START-WRITE) C-PDL-BUFFER-POINTER-POP)
	(CHECK-PAGE-WRITE)
	(GC-WRITE-TEST)
	(POPJ-LESS-OR-EQUAL M-ZR (A-CONSTANT 1))
	((M-ZR) SUB M-ZR (A-CONSTANT 1))
	(JUMP-XCT-NEXT SG-WRITE-BLOCK-FROM-PDL-BUFFER)
       ((VMA) SUB VMA (A-CONSTANT 1))

SG-LOAD-BLOCK-INTO-PDL-BUFFER 
	((VMA-START-READ) VMA)
	(CHECK-PAGE-READ)
	(POPJ-LESS-OR-EQUAL M-ZR (A-CONSTANT 0))  ;IN THIS CASE, USELESS READ DONE & IGNORED
	((M-ZR) SUB M-ZR (A-CONSTANT 1))
	(DISPATCH TRANSPORT-AC READ-MEMORY-DATA)
	((C-PDL-BUFFER-POINTER-PUSH) READ-MEMORY-DATA)
SG-L-P-B-1
	(JUMP-XCT-NEXT SG-LOAD-BLOCK-INTO-PDL-BUFFER)
       ((VMA) ADD VMA (A-CONSTANT 1))

SG-LOAD-STATIC-STATE 		;LOAD STATIC STATE FOR STACK GROUP
	((M-A) A-QCSTKG)
	((M-1) Q-DATA-TYPE M-A)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL DTP-STACK-GROUP)) ILLOP)
	((VMA-START-READ) SUB M-A (A-CONSTANT (PLUS 2 (EVAL SG-REG-PDL-ARRAY))))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(CALL-XCT-NEXT GAHD1)		;SET UP ARRAY LENGTH IN M-S AND DATA ORIGIN IN M-E
       ((M-A) READ-MEMORY-DATA)
  (ERROR-TABLE CALLS-SUB SG-REG-PDL)
	((A-QLPDLO) M-E)
	((A-QLPDLH) ADD M-E A-S)
	((M-A) A-QCSTKG)
	((VMA-START-READ) SUB M-A (A-CONSTANT (PLUS 2 (EVAL SG-LINEAR-BINDING-ARRAY))))
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT READ-MEMORY-DATA)
	(CALL-XCT-NEXT GAHD1)		;COMPUTE SAME THINGS FOR LINEAR-BINDING-ARRAY
       ((M-A) READ-MEMORY-DATA)
   (ERROR-TABLE CALLS-SUB SG-SPECIAL-PDL)
	(POPJ-AFTER-NEXT 
	 (A-QLBNDO) M-E)
       ((A-QLBNDH) ADD M-E A-S)

;PDL BUFFER "PHASING".  IF A STACK-GROUP IS INTERRUPTED AND LATER RESUMED,
;  IT HAS BEEN DECIDED TO PRESERVE THE "PHASING" OF THE PDL-BUFFER.
;  THIS MEANS THAT (FOR EXAMPLE) M-AP, A-IPMARK, PP, ETC, WILL HAVE THE
;  SAME OCTAL VALUES AS THEY DID (NOT MERELY POINT TO THE SAME QS, ETC).
;  IF THIS WERE NOT DONE, ONE COULD NOT "HOLD" A PDL-BUFFER INDEX ACROSS A 
;  POSSIBLE PAGE-FAULT BOUNDARY.  ALTHOUGH THAT MIGHT BE A LIVABLE-WITHABLE RESTRICTION,
;  IT SEEMS WORTH IT TO AVOID THAT CLASS OF POSSIBLE BUGS.

;CHANGE STACK-GROUP STATE TO ACTIVE.  RETURN IN M-TEM PREVIOUS STATE.  IF L-B-P WAS
; SWAPPED, SWAP IT BACK.
SGENT	(CALL-XCT-NEXT SG-LOAD-STATIC-STATE)
       ((M-STACK-GROUP-SWITCH-FLAG) DPB (M-CONSTANT -1) A-FLAGS)
	((VMA) A-QCSTKG)
	((VMA-START-READ) SUB VMA (A-CONSTANT (PLUS 2 (EVAL SG-PDL-PHASE))))
	(CHECK-PAGE-READ)			;NO TRANSPORT SINCE IT'S A FIXNUM
	((PDL-BUFFER-POINTER) READ-MEMORY-DATA)		;RESTORE PP WITH CORRECT PHASING
	((M-1) Q-POINTER READ-MEMORY-DATA)
	((A-PDL-BUFFER-HEAD) ADD M-1 (A-CONSTANT 1))	;POINTS AT PDL-BUFFER LOCN WITH VALID
						;DATA (IE NONE YET)
	(CALL-XCT-NEXT SG-L-P-B-1)
       ((M-ZR) ADD M-ZERO		;-1 BECAUSE ONE FROB ALREADY HACKED, BUT +1 BECAUSE
	   (A-CONSTANT (DIFFERENCE (EVAL SG-PDL-PHASE) (EVAL SG-STATE))))  ;WANT PHASE-STATE+1

	((A-SG-STATE) C-PDL-BUFFER-POINTER-POP)
	((A-SG-PREVIOUS-STACK-GROUP) C-PDL-BUFFER-POINTER-POP)
	((A-SG-CALLING-ARGS-POINTER) C-PDL-BUFFER-POINTER-POP)
	((A-SG-CALLING-ARGS-NUMBER) C-PDL-BUFFER-POINTER-POP)
;	((A-SG-FOLLOWING-STACK-GROUP) C-PDL-BUFFER-POINTER-POP)
	((A-TRAP-AP-LEVEL) C-PDL-BUFFER-POINTER-POP)

		;GET PDL-BUFFER RELOAD POINTER BACK INTO PHASE
	((M-1) ADD A-QLPDLO C-PDL-BUFFER-POINTER-POP ALU-CARRY-IN-ONE)  ;V.A. OF P.B. LOCN W/
	((A-PDL-BUFFER-VIRTUAL-ADDRESS) Q-POINTER M-1)		;VALID DATA (IE NONE YET).
	((M-1) ADD A-QLBNDO C-PDL-BUFFER-POINTER-POP)
	((A-QLBNDP) Q-POINTER M-1)
	(CALL-XCT-NEXT GET-PDL-BUFFER-INDEX)
       ((M-K) ADD C-PDL-BUFFER-POINTER-POP A-QLPDLO)
	((M-AP) M-K)					;RESTORE M-AP
	(CALL-XCT-NEXT GET-PDL-BUFFER-INDEX)
       ((M-K) ADD C-PDL-BUFFER-POINTER-POP A-QLPDLO)
	((A-IPMARK) M-K)				;RESTORE A-IPMARK
	((M-LAST-MICRO-ENTRY) MICRO-STACK-DATA-POP)	;SAVE RETURN TO SGENT

;COMPUTE LENGTH OF ACTIVE FRAME AND LOAD MINUS THAT INTO M-PDL-BUFFER-ACTIVE-QS.
;THEN PDL-BUFFER-REFILL WILL RELOAD ENTIRE ACTIVE FRAME PLUS PDL-BUFFER-LOW-WARNING
;WORTH OF OTHER STUFF.
	((M-1) ADD (M-CONSTANT -1) A-PDL-BUFFER-HEAD)   ;WHAT PP WILL BE WHEN ALL THIS IS OVER
	((M-PDL-BUFFER-ACTIVE-QS) SUB M-AP A-1) 	;GET - LENGTH OF ACTIVE FRAME MODULO
	(JUMP-EQUAL M-PDL-BUFFER-ACTIVE-QS A-ZERO SGENT1)  ;P.B. WRAPAROUND PROBLEMS
	((M-PDL-BUFFER-ACTIVE-QS) (BYTE-FIELD 10. 0) M-PDL-BUFFER-ACTIVE-QS 
		 (A-CONSTANT -1))		;EXTEND SIGN TO MAKE REAL NEG NUMBER.
SGENT1	(CALL PDL-BUFFER-REFILL)		;REFILL PDL-BUFFER WITH GOOD STUFF
	(CALL-GREATER-THAN M-ZERO A-PDL-BUFFER-HIGH-WARNING TRAP)  ;LOSEY LOSEY IT CANT EVEN
   (ERROR-TABLE PDL-OVERFLOW REGULAR)				   ; HOLD 1 MAXIMUM SIZE FRAME
	((PDL-BUFFER-INDEX) M-AP)		;IF RUNNING MACRO-CODE, RESTORE MACRO PC
	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;SIMULATES SGLOD DISPATCH IN LMI
	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-FEF-POINTER)) QLLENT)  ;GETS MAIN LOOP BACK
						;INTO PHASE AND PUSHES RIGHT RETURN ON USTACK

;	((PDL-BUFFER-INDEX) M-AP)		;UNCOMMENT THIS WHEN MICROCOMPILED FCTNS
;	((M-ZR) Q-DATA-TYPE C-PDL-BUFFER-INDEX) ;REALLY EXIST
;	(CALL-EQUAL M-ZR (A-CONSTANT (EVAL DTP-U-ENTRY)) QMMPOP)

;;; NOW SET UP THE CORRECT BASE OF THE STACK
	((M-GARBAGE) MICRO-STACK-DATA-POP)	;POP OFF THE CURRENT BASE
	((M-1) A-SG-STATE)			;GET THE STATE OF THIS STACK GROUP
	((M-1) (LISP-BYTE %%SG-ST-INST-DISP) M-1)	;READ OUT THE INSTRUCTION DISPATCH
	((M-1) ADD M-1 (A-CONSTANT (A-MEM-LOC A-MAIN-DISPATCH)))
	((OA-REG-HIGH) DPB M-1 A-ZERO OAH-A-SRC)
	((MICRO-STACK-DATA-PUSH) A-GARBAGE)	;PUSH THE BASE ADDRESS

	(CALL-XCT-NEXT QMMPO1)			;TRANSFER OTHER STUFF BACK TO USTACK
       ((M-J) Q-POINTER C-PDL-BUFFER-POINTER-POP)

	((MICRO-STACK-DATA-PUSH) M-LAST-MICRO-ENTRY)	;PUSH BACK RETURN FROM SGENT

	((A-TRAP-MICRO-PC) C-PDL-BUFFER-POINTER-POP)

	((A-QLARYH) C-PDL-BUFFER-POINTER-POP)
	((A-QLARYL) C-PDL-BUFFER-POINTER-POP)
	((M-FLAGS) C-PDL-BUFFER-POINTER-POP)

	((M-1) A-SG-STATE)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) M-1 
		SGENT2)		;FALL THRU ON L-B-P SWAPPED
	((M-A) A-QLBNDO)	;POINTS TO FIRST WD OF FIRST BLOCK.
SGENT3	((VMA-START-READ M-A) ADD M-A (A-CONSTANT 1))	;IS 2ND WD OF BLOCK PNTR TO VALUE
	(CHECK-PAGE-READ)				; CELL?
	(JUMP-GREATER-THAN M-A A-QLBNDP SGENT4)		;XFER ON THRU
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA SGENT3)  ;MUST NOT BE 1ST WD OF BLOCK
							;IF IT IS, LOOP BACK FOR THAT BLOCK
	((M-ZR) Q-DATA-TYPE READ-MEMORY-DATA)
	(JUMP-NOT-EQUAL M-ZR (A-CONSTANT (EVAL DTP-LOCATIVE)) SGENT6)
SGENT5	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-C) READ-MEMORY-DATA)			;M-C HAS POINTER TO INTERNAL V.C.
	((VMA-START-READ) SUB M-A (A-CONSTANT 1))	;FIRST WD OF PAIR HOLDS INACTIVE 
	(CHECK-PAGE-READ)				; BINDING
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-D) READ-MEMORY-DATA)			;M-D HAS NEW VALUE BEING RESTORED
	((VMA-START-READ) M-C)
	(CHECK-PAGE-READ)
	(DISPATCH TRANSPORT-NO-EVCP READ-MEMORY-DATA)
	((M-ZR) READ-MEMORY-DATA)			;M-ZR HAS OLD VALUE BEING SAVED
	((WRITE-MEMORY-DATA-START-WRITE) DPB M-D Q-TYPED-POINTER A-ZR)
	(CHECK-PAGE-WRITE)
	((WRITE-MEMORY-DATA) DPB M-ZR Q-TYPED-POINTER A-D)
	((VMA-START-WRITE) SUB M-A (A-CONSTANT 1))
	(CHECK-PAGE-WRITE)
	(JUMP-XCT-NEXT SGENT3)
       ((M-A) ADD M-A (A-CONSTANT 1))			;SPACE TO FIRST Q OF NEXT PAIR

SGENT6	((VMA-START-READ M-A) ADD M-A (A-CONSTANT 1))  ;THIS NOT A BINDING BLOCK, SPACE OVER
	(CHECK-PAGE-READ)			       ; IT.
	(JUMP-IF-BIT-SET Q-FLAG-BIT READ-MEMORY-DATA SGENT3)  ;FOUND FIRST Q OF NEXT BLOCK
	(JUMP-GREATER-OR-EQUAL M-A A-QLBNDP SGENT4)
	(JUMP SGENT6)					;KEEP LOOKING

SGENT4	((A-SG-STATE) DPB M-ZERO (LISP-BYTE %%SG-ST-IN-SWAPPED-STATE) A-SG-STATE)
SGENT2
	((M-1) (A-CONSTANT (M-MEM-LOC M-K)))   		;RESTORE REGS
SGENT0	((OA-REG-LOW) DPB M-1 OAL-M-DEST A-ZERO)
	((M-GARBAGE) C-PDL-BUFFER-POINTER-POP)		;M-GARBAGE = 0@M
	(JUMP-GREATER-THAN-XCT-NEXT M-1 (A-CONSTANT (M-MEM-LOC M-ZR)) SGENT0)
       ((M-1) SUB M-1 (A-CONSTANT 1)) 

	((M-2) C-PDL-BUFFER-POINTER-POP)		;RESTORE POINTER FIELDS OF M-1,M-2
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((M-3) (BYTE-FIELD 8 16.) C-PDL-BUFFER-POINTER)	;THEN RESTORE THEIR TAG FIELDS
	((M-2) DPB M-3 Q-ALL-BUT-POINTER A-2)
	((M-3) (BYTE-FIELD 8 8) C-PDL-BUFFER-POINTER)
	((M-1) DPB M-3 Q-ALL-BUT-POINTER A-1)
	((M-3) DPB C-PDL-BUFFER-POINTER-POP Q-ALL-BUT-POINTER A-ZERO) ;TAG FOR VMA

	((M-4) A-QCSTKG)				;CHANGE SG-STATE TO ACTIVE
	((VMA) SUB M-4 (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))
	((M-4) (A-CONSTANT (EVAL SG-STATE-ACTIVE)))
	((WRITE-MEMORY-DATA-START-WRITE M-4)
		DPB M-4 (LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
	(CHECK-PAGE-WRITE)
	((VMA-START-READ) Q-POINTER C-PDL-BUFFER-POINTER-POP A-3)     ;RESTORE VMA AND MD
	(CHECK-PAGE-READ)
	((M-STACK-GROUP-SWITCH-FLAG) DPB (M-CONSTANT 0) A-FLAGS)
	(POPJ-AFTER-NEXT				;PGF-x SMASHES M-TEM, DELAY LOADING
		(M-TEM) DPB M-ZERO (ALL-BUT-LISP-BYTE %%SG-ST-CURRENT-STATE) A-SG-STATE)
       ((A-SG-STATE) M-4)

;; High-level stack group stuff.

;; Takes a stack group in M-2, returns the SG-STATE word in M-TEM,
;; and the state subfield in M-1.
GET-SG-STATE
	((VMA-START-READ) SUB M-2 (A-CONSTANT (PLUS 2 (EVAL SG-STATE))))
	(CHECK-PAGE-READ)			;NO TRANSPORT SINCE IT'S A FIXNUM
	(POPJ-AFTER-NEXT 
	 (M-TEM) READ-MEMORY-DATA)
      ((M-1) (LISP-BYTE %%SG-ST-CURRENT-STATE) READ-MEMORY-DATA)

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
TRAP-ON-BAD-SG-STATE
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ERROR
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ACTIVE
	(P-BIT R-BIT)				;SG-STATE-RESUMABLE
	(P-BIT R-BIT)				;SG-STATE-AWAITING-RETURN
	(P-BIT R-BIT)				;SG-STATE-INVOKE-CALL-ON-RETURN
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INTERRUPTED-DIRTY
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-ERROR-RECOVERY
	(P-BIT R-BIT)				;SG-STATE-AWAITING-CALL 
	(P-BIT R-BIT)				;SG-STATE-AWAITING-INITIAL-CALL
	(P-BIT TRAP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-EXHAUSTED
(REPEAT 6 (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)
(LOCALITY I-MEM)

;;     This routine handles a stack group's being called as a function;
;; it is reached from the D-QMRCL dispatch.  Thus, M-A contains the new stack group.
;;  First, error checking: if both SG's are SAFE, then the called one has to be
;; in the AWAITING-CALL or AWAITING-INITIAL-CALL state.
SG-CALL	(CALL-XCT-NEXT GET-SG-STATE)        ;GET STATE OF SG GOING TO.  ALSO USE THIS BELOW.
       ((M-2) M-A)
	(DISPATCH (BYTE-FIELD 4 0) M-1 TRAP-ON-BAD-SG-STATE)
    (ERROR-TABLE WRONG-SG-STATE M-A)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-SAFE) M-TEM SG-CALL-1)
	(JUMP-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)) SG-CALL-1)
	((M-2) A-SG-STATE)
	(JUMP-IF-BIT-CLEAR (LISP-BYTE %%SG-ST-SAFE) M-2 SG-CALL-1)
	(CALL-NOT-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-INITIAL-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE M-A)

SG-CALL-1		;SG-STATE OF SG GOING TO IN M-TEM HERE.
;; Now assure that there is room for us in the PDL buffer.
	((M-B) SUB M-S A-AP)
	((M-B) (BYTE-FIELD 10. 0) M-B)
	((M-PDL-BUFFER-ACTIVE-QS) ADD M-PDL-BUFFER-ACTIVE-QS A-B)
	(CALL-GREATER-THAN-XCT-NEXT M-PDL-BUFFER-ACTIVE-QS 
			   A-PDL-BUFFER-HIGH-WARNING PDL-BUFFER-DUMP)  ;CLOBBERS M-2, M-TEM
       ((M-B) M-TEM)	;SAVE SG-STATE
	((M-AP) M-S)
;; Set up the argument list.
	((A-SG-TEM) A-V-NIL)
	(JUMP-EQUAL-XCT-NEXT M-ZERO A-NARGS SG-CALL-2)
       ((A-SG-TEM1) A-V-NIL)			; No args, list is NIL.
	(CALL-XCT-NEXT CONVERT-PDL-BUFFER-ADDRESS)
       ((M-K PDL-BUFFER-INDEX) ADD M-AP (A-CONSTANT 1))		; List pointer to arg list.
	((A-SG-TEM1) M-K)
	((A-SG-TEM) C-PDL-BUFFER-INDEX)

;We enter here from *UNWIND-STACK, at the label XUWR2, slight hack.
SG-CALL-2
;; Leave old SG in awaiting-return, and don't swap if both of these bits are off.
	((M-2) (A-CONSTANT (EVAL SG-STATE-AWAITING-RETURN)))
	((M-C) A-SG-STATE)
	(JUMP-IF-BIT-SET (LISP-BYTE %%SG-ST-SWAP-SV-ON-CALL-OUT) M-C SG-CALL-3)
	(JUMP-IF-BIT-SET (LISP-BYTE %%SG-ST-SWAP-SV-OF-SG-THAT-CALLS-ME) M-B SG-CALL-3)
	((M-2) DPB (M-CONSTANT -1) (BYTE-FIELD 1 6) A-2)	;Set 100 bit; don't swap L-B-P
SG-CALL-3
	((VMA) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-LOCATIVE)))  ;VMA NOT IMPORTANT IN
			;THIS PATH, FLUSH ANY GARBAGE.  CRUFT POSSIBLE VIA PATH FROM
			;XUWR2, AT LEAST.
	(CALL-XCT-NEXT SGLV)			; Leave!
       ((M-TEM) M-2)   ;M-TEM has the new state, plus 100 bit says to not swap L-B-P.
;; Drops through.

;; More high-level stack group stuff.

;; Drops in.

SG-ENTER
; This is the common routine for activating a new stack group.  It takes the following
; things:  the new stack group itself in M-A, the transmitted value in A-SG-TEM,
; the argument list in A-SG-TEM1, and the argument count in A-NARGS.
	((A-SG-TEM2) A-QCSTKG)
	(CALL-XCT-NEXT SGENT)
       ((A-QCSTKG) M-A)
	((A-SG-PREVIOUS-STACK-GROUP) A-SG-TEM2)
SG-ENTER-1
	((A-SG-CALLING-ARGS-POINTER) A-SG-TEM1)
	((M-1) A-NARGS)
	((A-SG-CALLING-ARGS-NUMBER) DPB M-1 Q-POINTER	;A-NARGS is typeless.
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
;; Now dispatch to separate routines, based on what state the new SG is in.
;; SGENT left that state in M-TEM.  It only dispatches on the low four bits
;; of the state because there are only 10. states implemented, and although
;; the state is a 6 bit field, it would waste lot of D-MEM to make the table
;; that large.
	(DISPATCH (BYTE-FIELD 4 0) M-TEM D-SG-ENTER)
       ((M-T) A-SG-TEM)				;SOMETIMES executes next!!

(LOCALITY D-MEM)
(START-DISPATCH 4 0)
D-SG-ENTER
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ERROR
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-ACTIVE
	(R-BIT INHIBIT-XCT-NEXT-BIT)		;SG-STATE-RESUMABLE
	(QMDDR0)				;SG-STATE-AWAITING-RETURN
	(SG-ENTER-CALL INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INVOKE-CALL-ON-RETURN
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-INTERRUPTED-DIRTY
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-ERROR-RECOVERY
	(R-BIT)					;SG-STATE-AWAITING-CALL 
	(SG-ENTER-CALL INHIBIT-XCT-NEXT-BIT)	;SG-STATE-AWAITING-INITIAL-CALL
	(P-BIT ILLOP INHIBIT-XCT-NEXT-BIT)	;SG-STATE-EXHAUSTED
(REPEAT 6 (P-BIT ILLOP INHIBIT-XCT-NEXT-BIT))
(END-DISPATCH)
(LOCALITY I-MEM)

SG-ENTER-CALL
;; This is similar to QMRCL, but it never does a "leave".
	((M-K) SUB PDL-BUFFER-POINTER A-IPMARK)	;Count arguments
	((A-NARGS) (BYTE-FIELD 7 0) M-K)
	((PDL-BUFFER-INDEX M-S) A-IPMARK)	;Get fef pointer pointer
	((M-A) C-PDL-BUFFER-INDEX)		;M-A := Function to call
	(DISPATCH Q-DATA-TYPE M-A D-QMRCL)	;Dispatch on data type
       (NO-OP)					;No leave neccesary.

;; More high-level stack group stuff.
;; This page contains STACK-GROUP-RETURN, and the SG-ENTER-NO-PREV entry-point.

     (MISC-INST-ENTRY STACK-GROUP-RETURN)
SG-RETURN
	((M-2) A-SG-STATE)
	(CALL-IF-BIT-CLEAR-XCT-NEXT (LISP-BYTE %%SG-ST-SAFE) M-2 TRAP)
    (ERROR-TABLE SG-RETURN-UNSAFE)
       ((A-SG-TEM1) A-V-NIL)			; Arg list (just in case...)
	(CALL-XCT-NEXT GET-SG-STATE)		; Get state of prev. SG in M-1
       ((M-2) A-SG-PREVIOUS-STACK-GROUP)
	(CALL-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)
	(CALL-EQUAL M-1 (A-CONSTANT (EVAL SG-STATE-AWAITING-INITIAL-CALL)) TRAP)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)
	(DISPATCH (BYTE-FIELD 4 0) M-1 TRAP-ON-BAD-SG-STATE)
    (ERROR-TABLE WRONG-SG-STATE A-SG-PREVIOUS-STACK-GROUP)

SG-RETURN-1
	((A-SG-TEM) C-PDL-BUFFER-POINTER-POP)	; Get the value being transmitted.
	((M-TEM) (A-CONSTANT (EVAL SG-STATE-AWAITING-CALL)))
SG-RETURN-2  ; Entrypoint from QMXSG, which is where we exit the top of a stack group.
	(CALL SGLV)
	((M-A) A-SG-PREVIOUS-STACK-GROUP)
;; Falls into:


; This is like SG-ENTER (q.v.) except that it doesn't set up the PREVIOUS-STACK-GROUP
; at all, and so it takes no arg in A-SG-TEM2.
SG-ENTER-NO-PREV
	(CALL-XCT-NEXT SGENT)
       ((A-QCSTKG) M-A)
	(JUMP SG-ENTER-1)

;LOADING THE INITIAL MAP.
; THE FIRST STEP IS TO ADDRESS THE SYSTEM COMMUNICATION AREA AND FIND
; OUT MUCH VIRTUAL MEMORY SHOULD BE WIRED AND STRAIGHT-MAPPED (%SYS-COM-WIRED-SIZE).
; THE MAP IS THEN SET UP FOR THOSE PAGES.  THE REMAINDER OF VIRTUAL
; SPACE IS MADE "MAP NOT SET UP."  STUFF WILL THEN BE PICKED
; UP OUT OF THE PAGE HASH TABLE.  IT IS ALSO NECESSARY TO SET UP THE
; LAST BLOCK OF LEVEL 2 MAP TO "MAP NOT SET UP (ZERO)".

INITIAL-MAP
	;FIRST SET ALL LEVEL 1 MAP TO 37
	((VMA) DPB (M-CONSTANT -1) MAP-WRITE-FIRST-LEVEL-MAP 
		   (A-CONSTANT (BYTE-VALUE MAP-WRITE-ENABLE-FIRST-LEVEL-WRITE 1)))
	((MD) DPB (M-CONSTANT -1) (BYTE-FIELD 1 24.) A-ZERO)
INIMAP1	((MD-WRITE-MAP) SUB MD (A-CONSTANT 20000))
	(JUMP-NOT-EQUAL MD A-ZERO INIMAP1)
	(CALL-XCT-NEXT PHYS-MEM-READ)		;ADDRESS SYSTEM COMMUNICATION AREA
       ((VMA) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-WIRED-SIZE))))
	((M-A) Q-POINTER MD)			;SAVE NUMBER OF WIRED WORDS
	;THEN ZERO LAST BLOCK OF LEVEL 2 MAP
	((MD) A-ZERO)
INIMAP2	((VMA-WRITE-MAP) DPB (M-CONSTANT -1) MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE A-ZERO)
	((MD) ADD MD (A-CONSTANT 400))
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 13.) MD INIMAP2)
	;NOW SET UP WIRED LEVEL 1 MAP
	((MD) A-ZERO)
	((M-C) DPB (M-CONSTANT -1) MAP-WRITE-ENABLE-FIRST-LEVEL-WRITE A-ZERO)
INIMAP7	((VMA-WRITE-MAP) M-C) 
	((MD) ADD MD (A-CONSTANT 20000))
	(JUMP-LESS-THAN-XCT-NEXT MD A-A INIMAP7)
       ((M-C) ADD M-C (A-CONSTANT (BYTE-VALUE MAP-WRITE-FIRST-LEVEL-MAP 1)))
	((A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT) 
		MAP-WRITE-FIRST-LEVEL-MAP M-C)	;FIRST NON-WIRED
	;THEN SET UP WIRED LEVEL 2 MAP
	((MD) SETZ)
INIMAP3	((VMA-WRITE-MAP) VMA-PHYS-PAGE-ADDR-PART MD	;SELF-ADDRESS
		(A-CONSTANT (PLUS (BYTE-VALUE MAP-ACCESS-CODE 3)   ;RW
				  ;(BYTE-VALUE MAP-STATUS-CODE 0)  ;4 READ/WRITE
				  (BYTE-VALUE MAP-META-BITS 64) ;NOT OLD, NOT EXTRA-PDL, STRUC
				  (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1))))
	((MD) ADD MD (A-CONSTANT 400))			;NEXT PAGE
	(JUMP-LESS-THAN MD A-A INIMAP3)		;LOOP UNTIL DONE ALL WIRED ADDRESSES
INIM3A	((M-1) (BYTE-FIELD 5 8) MD)		;IF NOT AT EVEN 1ST LVL MAP BOUNDARY...
	(JUMP-EQUAL M-1 A-ZERO INIM3B)		; INITIALIZE REST OF 2ND LVL BLOCK TO
	((VMA-WRITE-MAP)			; MAP NOT SET UP.
	   (A-CONSTANT (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)))
	(JUMP-XCT-NEXT INIM3A)
       ((MD) ADD MD (A-CONSTANT 400))

INIM3B						;INITIALIZE REVERSE 1ST LVL MAP
	((A-SECOND-LEVEL-MAP-REUSE-POINTER) A-SECOND-LEVEL-MAP-REUSE-POINTER-INIT)
					;REVERSE 1ST LVL MAP LOCS 40-77
	((WRITE-MEMORY-DATA) M-ZERO)	;VALUE TO GO IN WIRED ENTRIES
	((VMA) (A-CONSTANT 437))	;A-V-SYSTEM-COMMUNICATION-AREA IS 400
INIMAP5	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
	((WRITE-MEMORY-DATA) ADD WRITE-MEMORY-DATA (A-CONSTANT 20000))
	(JUMP-LESS-THAN WRITE-MEMORY-DATA A-A INIMAP6)	;JUMP IF STILL WIRED
	((M-A WRITE-MEMORY-DATA) (M-CONSTANT -1))	;REST OF ENTRYS ARE -1.
INIMAP6	(JUMP-LESS-THAN VMA (A-CONSTANT 477) INIMAP5)
	(POPJ)

;PHYSICAL MEMORY REFERENCING.
;THIS WORKS BY TEMPORARILY CLOBBERING LOCATION 0 OF THE SECOND-LEVEL MAP.
;A-TEM1, A-TEM2, AND A-TEM3 ARE USED AS TEMPORARIES.  ARGS ARE IN VMA AND MD.
PHYS-MEM-READ 
	((A-TEM1) VMA)				;SAVE ADDRESS
	((MD) A-ZERO)				;ADDRESS MAP LOCATION 0@2
	((A-TEM3) MAP-WRITE-SECOND-LEVEL-MAP	;SAVE IT (READ & WRITE THE SAME)
		  MEMORY-MAP-DATA
		  (A-CONSTANT (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)))
	((VMA-WRITE-MAP) VMA-PHYS-PAGE-ADDR-PART VMA
		(A-CONSTANT (PLUS (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)
				  (BYTE-VALUE MAP-ACCESS-CODE 3))))
	((VMA-START-READ) DPB M-ZERO		;READ, USING LOC WITHIN PAGE ZERO
		ALL-BUT-VMA-LOW-BITS A-TEM1)
	(ILLOP-IF-PAGE-FAULT)			;FOO, I JUST SET UP THE MAP
	((A-TEM2) READ-MEMORY-DATA)		;GET RESULT TO BE RETURNED
	((MD) A-ZERO)				;RESTORE THE MAP
	((VMA-WRITE-MAP) A-TEM3)
	(POPJ-AFTER-NEXT (VMA) A-TEM1)		;RETURN CORRECT VALUES IN VMA AND MD
       ((MD) A-TEM2)

PHYS-MEM-WRITE 
	((A-TEM1) VMA)				;SAVE ADDRESS
	((A-TEM2) MD)				;AND DATA
	((MD) A-ZERO)				;ADDRESS MAP LOCATION 0@2
	((A-TEM3) MAP-WRITE-SECOND-LEVEL-MAP	;SAVE IT (READ & WRITE THE SAME)
		  MEMORY-MAP-DATA
		  (A-CONSTANT (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)))
	((VMA-WRITE-MAP) VMA-PHYS-PAGE-ADDR-PART VMA
		(A-CONSTANT (PLUS (BYTE-VALUE MAP-WRITE-ENABLE-SECOND-LEVEL-WRITE 1)
				  (BYTE-VALUE MAP-ACCESS-CODE 3))))
	((MD) A-TEM2)				;RESTORE THE DATA TO BE WRITTEN
	((VMA-START-WRITE) DPB M-ZERO		;WRITE, USING LOC WITHIN PAGE ZERO
		ALL-BUT-VMA-LOW-BITS A-TEM1)
	(ILLOP-IF-PAGE-FAULT)			;FOO, I JUST SET UP THE MAP
	((MD) A-ZERO)				;RESTORE THE MAP
	((VMA-WRITE-MAP) A-TEM3)
	(POPJ-AFTER-NEXT (VMA) A-TEM1)		;RETURN CORRECT VALUES IN VMA AND MD
       ((MD) A-TEM2)

;;; COLD BOOT, %DISK-RESTORE and %DISK-SAVE code

;(%DISK-SAVE main-memory-size high-16-bits-of-partition-name low-16-bits)
;The second and third arguments may be zero to specify the current partition.
DISK-SAVE (MISC-INST-ENTRY %DISK-SAVE)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((M-1) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 20 20) A-1)
	((M-S) Q-POINTER C-PDL-BUFFER-POINTER-POP)
	((C-PDL-BUFFER-POINTER-PUSH) M-1)	;Preserve M-1.
	(CALL SWAP-OUT-ALL-PAGES)		;Make sure disk has valid data for all pages.
	((M-1) C-PDL-BUFFER-POINTER-POP)
	(CALL COLD-READ-LABEL)			;Find the specified partition, and PAGE.
	((M-A) M-I)				;Interchange their starts and sizes
	((M-I) M-Q)				;so that we copy from PAGE to the other.
	((M-Q) M-A)
	((M-A) M-J)
	((M-J) M-R)
	((M-R) M-A)
	(CALL DISK-COPY)			;Copy.
	(JUMP COLD-SWAP-IN)			;Physical core now clobbered, so re-swap-in.

;Make sure all pages are correct on disk.
;Requires that M-S contain the number of words of physical main memory.
;All physical memory except that used for wired pages is forgotten from
;the PHT, so in order to continue execution after this you must
;mark then as existing and free again.
;For %DISK-SAVE, that doesn't matter since we just re-boot anyway.
SWAP-OUT-ALL-PAGES
	((C-PDL-BUFFER-POINTER-PUSH) M-S)
	((M-S) LDB (BYTE-FIELD 16. 8) M-S A-ZERO)	;Number of physical pages.
	((VMA-START-READ) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-WIRED-SIZE))))
	(ILLOP-IF-PAGE-FAULT)
	((M-T) (BYTE-FIELD 16. 8) READ-MEMORY-DATA)	;Number of wired pages.
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
;Swap out all unwired pages first, using %DELETE-PHYSICAL-PAGE and updating the PHT normally.
SWAP-OUT-ALL-PAGES-1
	((C-PDL-BUFFER-POINTER-PUSH) M-T)
	((C-PDL-BUFFER-POINTER-PUSH) M-S)
	(CALL XDPPG3)
	((M-S) C-PDL-BUFFER-POINTER-POP)
	((M-T) ADD C-PDL-BUFFER-POINTER-POP (A-CONSTANT 1))
	(JUMP-LESS-THAN M-T A-S SWAP-OUT-ALL-PAGES-1)
;Now swap out all the wired pages
	((M-A) (A-CONSTANT DISK-WRITE-COMMAND))
	((M-B) A-ZERO)				;Number of first physical page to write.
	((M-C) A-DISK-OFFSET)
	((M-C) LDB (BYTE-FIELD 16. 8) M-C)	;Block number on disk of 1st page.
	((M-D) C-PDL-BUFFER-POINTER-POP)	;Number of wired pages
	(JUMP-XCT-NEXT COLD-DISK)
       ((M-S) C-PDL-BUFFER-POINTER-POP)

;;; Note that this code must run without using paging, since we can't set
;;; up the map until we have the system communication area.  We use 
;;; PHYS-MEM-READ and PHYS-MEM-WRITE.

COLD-BOOT
	((M-1) A-ZERO)				;0 => use current band.
	(JUMP DISK-RESTORE-1)			;Load world from there

;(%DISK-RESTORE high-16-bits-of-partition-name low-16-bits)
;The first and second arguments may be zero to specify the current partition.
DISK-RESTORE (MISC-INST-ENTRY %DISK-RESTORE)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	((M-1) DPB C-PDL-BUFFER-POINTER-POP (BYTE-FIELD 20 20) A-1)
DISK-RESTORE-1

;;; Determine size of main memory
	((MD) (A-CONSTANT 40))			;Turn off ERROR-STOP-ENABLE
	(CALL-XCT-NEXT PHYS-MEM-WRITE)		;40 is PROM-DISABLE
       ((VMA) (A-CONSTANT 17773005))		;Unibus 766012
	((M-S) SETZ)
MEM-SIZE-LOOP
	((VMA M-S) ADD M-S (A-CONSTANT 40000))	;Memory comes in 16K increments
	(CALL-XCT-NEXT PHYS-MEM-WRITE)
       ((MD) (A-CONSTANT 37))			;Some 1's, some 0's
	(CALL PHYS-MEM-READ)
	(JUMP-EQUAL MD (A-CONSTANT 37) MEM-SIZE-LOOP)
	;M-S now has the first non-existent location
	((MD) (A-CONSTANT 46))			;Turn ERROR-STOP-ENABLE back on
	(CALL-XCT-NEXT PHYS-MEM-WRITE)		;40 is PROM-DISABLE, 2 is NORMAL speed.
       ((VMA) (A-CONSTANT 17773005))		;Unibus 766012

	(CALL COLD-READ-LABEL)			;Find PAGE partition and specified partition.
	(CALL DISK-COPY)			;Copy that partition into PAGE.

;;; Initialize physical memory from its swapped-out image on disk.
;;; First, read in page zero, the system communication area, and the scratchpad-init-area
COLD-SWAP-IN
	((M-R) A-DISK-OFFSET)
	((M-R) LDB (BYTE-FIELD 16. 8) M-R A-ZERO)
	((M-B) (A-CONSTANT 0))			;Core pages 0, 1 and 2
	((M-C) M-R)				;From start of PAGE partition
	((M-D) (A-CONSTANT 2))			;2 pages first, so as not to clobber ccw list!
	(CALL COLD-DISK-READ)
	((M-B) (A-CONSTANT 1000))		;Get third page
	((M-C) ADD M-R (A-CONSTANT 2))
	((M-D) (A-CONSTANT 1))
	(CALL COLD-DISK-READ)
;;; Read in the rest of wired memory (the sys comm area has its size).
;;; Don't clobber the MICRO-CODE-SYMBOL-AREA
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-WIRED-SIZE))))
	((M-D) (BYTE-FIELD 16. 8) READ-MEMORY-DATA)	;Number of wired pages
	((A-PGF-VMA) Q-POINTER READ-MEMORY-DATA)	;Save for later
	((M-B) (A-CONSTANT 2400))		;First location after MICRO-CODE-SYMBOL-AREA
	((M-C) ADD M-R (A-CONSTANT 5))
	((M-D) SUB M-D (A-CONSTANT 5))
	(CALL COLD-DISK-READ)
;;; Here we can set up the map.
	(CALL INITIAL-MAP)
;;; Set things up according to actual main memory size
	((WRITE-MEMORY-DATA) Q-POINTER M-S (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((VMA-START-WRITE) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-MEMORY-SIZE))))
	(ILLOP-IF-PAGE-FAULT)
;;; We may want to allow changing the size of the PAGE partition.  This isn't
;;; currently supported; something would have to go through and fix the free regions.
;;; For now, assume that changing this requires building a new world-load.

;;; Reinitialize the page hash table.  Delete all entries for non-wired pages.
;;; We assume that the wired pages were put in first, so there is no
;;; need for the hairy rehashing stuff the normal page fault routines use.
	((VMA-START-READ) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-PAGE-TABLE-PNTR))))
	(ILLOP-IF-PAGE-FAULT)
	((A-V-PAGE-TABLE-AREA) READ-MEMORY-DATA)
	((VMA-START-READ) (A-CONSTANT (PLUS 400 (EVAL %SYS-COM-PAGE-TABLE-SIZE))))
	(ILLOP-IF-PAGE-FAULT)
	((M-1) Q-POINTER READ-MEMORY-DATA)
	((A-PHT-INDEX-MASK) SUB M-1 (A-CONSTANT 2))
	((M-A) SETZ)
COLD-REINIT-PHT
	((VMA-START-READ) ADD M-A A-V-PAGE-TABLE-AREA)	;Get PHT1
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-IF-BIT-CLEAR PHT1-VALID-BIT READ-MEMORY-DATA COLD-REINIT-PHT-1)
	((M-B) SELECTIVE-DEPOSIT READ-MEMORY-DATA PHT1-VIRTUAL-PAGE-NUMBER A-ZERO)
	(JUMP-LESS-THAN M-B A-PGF-VMA COLD-REINIT-PHT-1)	;Wired, leave alone
	((WRITE-MEMORY-DATA-START-WRITE) (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(ILLOP-IF-PAGE-FAULT)				;Clear out this entry
	((VMA-START-WRITE) ADD VMA (A-CONSTANT 1))
	(ILLOP-IF-PAGE-FAULT)
COLD-REINIT-PHT-1
	(JUMP-LESS-THAN-XCT-NEXT M-A A-PHT-INDEX-MASK COLD-REINIT-PHT)
       ((M-A) ADD M-A (A-CONSTANT 2))
;;; Then create free entries for the rest of main memory.
	((M-B) A-PGF-VMA)				;Core address
COLD-REINIT-PHT-2A
	((M-A) SETZ)					;PHT index
COLD-REINIT-PHT-2
	((VMA-START-READ) ADD M-A A-V-PAGE-TABLE-AREA)	;Get PHT1
	(ILLOP-IF-PAGE-FAULT)
	(JUMP-IF-BIT-SET PHT1-VALID-BIT READ-MEMORY-DATA COLD-REINIT-PHT-3)
	((WRITE-MEMORY-DATA-START-WRITE)		;Construct and store PHT1 word
	    SELECTIVE-DEPOSIT M-MINUS-ONE PHT1-VIRTUAL-PAGE-NUMBER	; for free page
		(A-CONSTANT (PLUS (PLUS (BYTE-VALUE Q-DATA-TYPE DTP-FIX)
					(BYTE-VALUE PHT1-VALID-BIT 1))
				  (BYTE-VALUE PHT1-SWAP-STATUS-CODE 2)))) ;Flushable
	(ILLOP-IF-PAGE-FAULT)				;should be wired
	((M-1) VMA-PHYS-PAGE-ADDR-PART M-B)		;Physical page number to be freed
	((VMA) ADD VMA (A-CONSTANT 1))			;Address PHT2
	((WRITE-MEMORY-DATA-START-WRITE)		;Construct and store PHT2 word
		DPB M-1 PHT2-PHYSICAL-PAGE-NUMBER
		(A-CONSTANT (PLUS (BYTE-VALUE PHT2-ACCESS-STATUS-AND-META-BITS 1200) ;Read only
				  (BYTE-VALUE Q-DATA-TYPE DTP-FIX))))
	(ILLOP-IF-PAGE-FAULT)				;Should be wired
	((M-B) ADD M-B (A-CONSTANT 400))		;Next free page
	(JUMP-GREATER-OR-EQUAL M-B A-S BEG0000)		;Done, go start up world
	((M-A) ADD M-A (A-CONSTANT 2))			;Leave room so it's not grossly slow
COLD-REINIT-PHT-3
	(JUMP-LESS-THAN-XCT-NEXT M-A A-PHT-INDEX-MASK COLD-REINIT-PHT-2)
       ((M-A) ADD M-A (A-CONSTANT 2))
	(JUMP COLD-REINIT-PHT-2A)			;If more main memory, fill in gaps

;;; Read the disk label and find the main load partition to be used,
;;; and the PAGE partition.  The main load to be used is either the
;;; one whose name is in M-1, or the current one if M-1 is zero.
;;; Also set A-LOADED-BAND for later macrocode use.
COLD-READ-LABEL 
	((C-PDL-BUFFER-POINTER-PUSH) M-1)
	((M-B) A-ZERO)				;Core address
	((M-C) A-ZERO)				;Disk address
	((M-D) (A-CONSTANT 1))			;1 block
	(CALL COLD-DISK-READ)
	;Location 7 contains the name of the main load partition.
	;Location 200 contains the partition table.
	;We must also find the PAGE partition and set up A-DISK-OFFSET and A-DISK-MAXIMUM
	(CALL-XCT-NEXT PHYS-MEM-READ)		; Read the number of blocks per track
       ((VMA) (A-CONSTANT 4))
	((A-DISK-BLOCKS-PER-TRACK) Q-POINTER READ-MEMORY-DATA
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT PHYS-MEM-READ)		; Read the number of heads
       ((VMA) (A-CONSTANT 3))
	((Q-R) READ-MEMORY-DATA)		; Get number of blocks per cylinder
	(CALL-XCT-NEXT MPY)			; Blocks/track * tracks/cylinder
       ((M-1) DPB M-ZERO Q-ALL-BUT-POINTER A-DISK-BLOCKS-PER-TRACK)
	((A-DISK-BLOCKS-PER-CYLINDER) Q-POINTER Q-R
			(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL-XCT-NEXT COLD-FIND-PARTITION)
       ((M-A) (A-CONSTANT 10521640520))		; PAGE = 105 107 101 120 = 10521640520
	((A-DISK-OFFSET) DPB M-I (BYTE-FIELD 16. 8) A-ZERO)
	((A-DISK-MAXIMUM) DPB M-J (BYTE-FIELD 16. 8) A-ZERO)
	((M-Q) M-I)
	((M-R) M-J)
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) (A-CONSTANT 7))
	((M-A) READ-MEMORY-DATA)
	((M-1) C-PDL-BUFFER-POINTER-POP)
	(JUMP-EQUAL M-1 A-ZERO COLD-READ-LABEL-1)
	((M-A) A-1)
COLD-READ-LABEL-1
	((A-LOADED-BAND) (BYTE-FIELD 30 10) M-A (A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	(CALL COLD-FIND-PARTITION)		;Set up M-I, M-J for partition to load.
	(POPJ)

;;; Here on a warm boot, we have to read the label in order to find where the
;;; PAGE partition is.  But we mustn't bash core page 0.
WARM-READ-LABEL
	((M-A) (A-CONSTANT DISK-WRITE-COMMAND))	;Save page 0
	((M-B) A-ZERO)				;Core address
	((M-C) (A-CONSTANT 1))			;Disk address
	((M-D) (A-CONSTANT 1))			;1 block
	(CALL COLD-DISK)
	(CALL-XCT-NEXT COLD-READ-LABEL)		;Go get the label
       ((M-1) SETZ)				;not worrying about load partition
	((A-LOADED-BAND)			;We don't know which band this is
		(A-CONSTANT (BYTE-VALUE Q-DATA-TYPE DTP-FIX)))
	((M-B) A-ZERO)				;Core address (restore page 0)
	((M-C) (A-CONSTANT 1))			;Disk address
	(POPJ-AFTER-NEXT (M-D) (A-CONSTANT 1))	;1 block
       (CALL COLD-DISK-READ)

;Copy one sequence of disk blocks into another.
;M-I and M-J now have the start and size of the partition to be copied from.
;M-Q and M-R have the start and size of the partition to be copied into.
;M-S has the size of main memory (in words)
;Clobbers M-A, M-B, M-C, M-D, M-I, M-J, M-K, M-Q.
;Leaves first 10 pages of main memory alone, to avoid clobbering system
;communication area and micro code symbol area.  (Actually, currently 6 pages
;would be sufficient.)  Pages 10 and 11 are used for the command list, allowing
;transferring 512. pages (6 T-80 cylinders, 128K words) at a time.
;The size is computed from %SYS-COM-VALID-SIZE in the source band.
DISK-COPY
	((M-B) (A-CONSTANT 5000))		;Core address
	((M-C) ADD M-I (A-CONSTANT 1))		;Disk address
	((M-D) (A-CONSTANT 1))			;1 block
	(CALL COLD-DISK-READ)
	(CALL-XCT-NEXT PHYS-MEM-READ)		;Get useful size of partition, in words
       ((VMA) ADD M-B (A-CONSTANT (EVAL %SYS-COM-VALID-SIZE)))
	((M-R) (BYTE-FIELD 16. 8) MD)		;Number of valid pages
	(JUMP-GREATER-OR-EQUAL M-R A-J DISK-COPY-PART-1)
	((M-J) M-R)				;M-J is number of pages to copy (min sizes)
DISK-COPY-PART-1
	((M-K) (BYTE-FIELD 14. 8) M-S)		;Number of pages in main memory
	((M-K) SUB M-K (A-CONSTANT 12))		;Don't use first 12 for buffer
	(JUMP-LESS-THAN M-K (A-CONSTANT 1000) DISK-COPY-PART-2)
	((M-K) (A-CONSTANT 1000))		;At most 1000 pages at a time since that is
						; size of 2-page command list
DISK-COPY-PART-2
	;Here M-I is the from-address, M-Q is the to-address, M-J is the
	;number of blocks to transfer, and M-K is the number of blocks to
	;transfer at a whack.
	(POPJ-EQUAL M-J A-ZERO)			;If done.
	(JUMP-GREATER-OR-EQUAL-XCT-NEXT M-J A-K DISK-COPY-PART-3)
       ((M-D) M-K)				;Number to do this time
	((M-D) M-J)
DISK-COPY-PART-3
	((M-B) (A-CONSTANT 5000))		;Page 12 is first page to use as buffer
	((M-C) M-I)				;Read some in
	(CALL-XCT-NEXT COLD-DISK-BIG-CMD-LIST)
       ((M-A) (A-CONSTANT DISK-READ-COMMAND))
	((M-C) M-Q)				;Write some out
	(CALL-XCT-NEXT COLD-DISK-BIG-CMD-LIST)
       ((M-A) (A-CONSTANT DISK-WRITE-COMMAND))
	((M-I) ADD M-I A-D)			;Advance pointers
	((M-Q) ADD M-Q A-D)
	((M-J) SUB M-J A-D)
	(JUMP DISK-COPY-PART-2)

;;; With the label in location 0, this routine finds a partition whose name is in M-A
;;; and returns its start and size (in blocks) in M-I and M-J.
COLD-FIND-PARTITION
	(CALL-XCT-NEXT PHYS-MEM-READ)		;Get number of partitions
       ((VMA) (A-CONSTANT 200))
	((M-I) READ-MEMORY-DATA)
	(CALL-XCT-NEXT PHYS-MEM-READ)		;Get words per partition
       ((VMA) ADD VMA (A-CONSTANT 1))
	((M-J) READ-MEMORY-DATA)
	((VMA) ADD VMA (A-CONSTANT 1))
COLD-FIND-PART-LOOP
	(CALL-EQUAL M-I A-ZERO ILLOP)		;Out of partitions, not found, die
	(CALL PHYS-MEM-READ)			;Get name of a partition
	((M-I) SUB M-I (A-CONSTANT 1))
	(JUMP-NOT-EQUAL-XCT-NEXT READ-MEMORY-DATA A-A COLD-FIND-PART-LOOP)
       ((VMA) ADD VMA A-J)
	((VMA) SUB VMA A-J)
	(CALL-XCT-NEXT PHYS-MEM-READ)		;Found it, get start and size
       ((VMA) ADD VMA (A-CONSTANT 1))
	((M-I) READ-MEMORY-DATA)
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) ADD VMA (A-CONSTANT 1))
	(POPJ-AFTER-NEXT (M-J) READ-MEMORY-DATA)
       (NO-OP)

;;; This routine is the disk handler used by cold boot.
;;; Opcode in M-A, core address in M-B, disk address in M-C, block count in M-D
;;; Memory from 777 downward the number of blocks to be xferred is clobbered to make
;;;  the command chain.  Thus, to not clobber SYSTEM-COMMUNICATION-AREA, the xfer
;;;  count should not exceed 340 (octal).
;;; Enter at COLD-DISK-BIG-CMD-LIST to use pages 10 and 11 for command list instead
COLD-DISK-READ
	((M-A) (A-CONSTANT DISK-READ-COMMAND))
COLD-DISK
	(JUMP-XCT-NEXT COLD-DISK-0)		;Normal entry for short command list
       ((M-4) (A-CONSTANT 1000))

COLD-DISK-BIG-CMD-LIST
	((M-4) (A-CONSTANT 5000))		;Address of long command list, last word
COLD-DISK-0
	(CALL-XCT-NEXT PHYS-MEM-READ)		;WAIT FOR DISK CONTROL TO BE READY
       ((VMA) A-DISK-REGS-BASE)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) READ-MEMORY-DATA COLD-DISK-0)
	((VMA M-1) SUB M-4 A-D)			;Start address of CCW list
	((M-3) SUB M-4 (A-CONSTANT 1))		;Inclusive end address of CCW list
	((MD) SELECTIVE-DEPOSIT M-B (BYTE-FIELD 14. 8) (A-CONSTANT 1)) ;First CCW
COLD-DISK-CCW-LOOP
	(JUMP-LESS-THAN VMA A-3 COLD-DISK-CCW-1)
	((MD) SUB MD (A-CONSTANT 1))		;Last CCW
COLD-DISK-CCW-1
	(CALL PHYS-MEM-WRITE)
	((MD) ADD MD (A-CONSTANT 400))
	(JUMP-LESS-THAN-XCT-NEXT VMA A-3 COLD-DISK-CCW-LOOP)
       ((VMA) ADD VMA (A-CONSTANT 1))
	((MD) M-A)				;Store command
	(CALL-XCT-NEXT PHYS-MEM-WRITE)
       ((VMA) A-DISK-REGS-BASE)
	((MD) M-1)				;Store CLP
	(CALL-XCT-NEXT PHYS-MEM-WRITE)
       ((VMA) ADD VMA (A-CONSTANT 1))
	((M-1) M-C)				;Convert disk address to physical addr
	(CALL-XCT-NEXT DIV)			;Divide to get cylinder in Q-R,
       ((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-DISK-BLOCKS-PER-CYLINDER)	;Remainder in M-1
        ((MD) DPB Q-R (BYTE-FIELD 12. 16.) A-ZERO)	;Save cylinder
	(CALL-XCT-NEXT DIV)			;Divide to get head in Q-R, blk in M-1
       ((M-2) DPB M-ZERO Q-ALL-BUT-POINTER A-DISK-BLOCKS-PER-TRACK)
	((M-1) DPB Q-R (BYTE-FIELD 8 8) A-1)
	((MD) IOR MD A-1)			;Construct disk address
	(CALL-XCT-NEXT PHYS-MEM-WRITE)
       ((VMA) ADD VMA (A-CONSTANT 1))
	(CALL-XCT-NEXT PHYS-MEM-WRITE)		;Start transfer
       ((VMA) ADD VMA (A-CONSTANT 1))
	;Now, wait for disk completion and loop if any error.
COLD-DISK-WAIT 
	(CALL-XCT-NEXT PHYS-MEM-READ)
       ((VMA) A-DISK-REGS-BASE)
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) READ-MEMORY-DATA COLD-DISK-WAIT)
	((M-1) AND READ-MEMORY-DATA (A-CONSTANT 47777560))
		;M-1 GETS ERROR BITS: INTERNAL PARITY, NXM, MEM PAR, HEADER COMPARE,
		; HEADER ECC, ECC HARD, ECC SOFT, READ OVERRUN, WRITE OVERRUN,
		; START-BLOCK ERR, TIMEOUT, SEEK ERR, OFF LINE, OFF CYL, FAULT, NO SEL, MUL SEL
	(JUMP-NOT-EQUAL M-1 A-ZERO COLD-DISK-0)	;Error, try over and over
	(POPJ)					;Won.

))
;;---					T H E   E N D



