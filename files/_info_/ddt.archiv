DDT 1380	    RWK 5/25/79		-*- TEXT -*-

1)  DDT now prints [Home dir=USERS1] (or whatever) when you log in
and your home directory is not the same as your XUNAME.  This should
be more understandable than the old USERS it used to print.

2)  DDT will not print system mail (i.e. SYS:SYSTEM MAIL) except when
you first type ^Z or connect to the machine.  If you run
:PTY or :CRTSTY you will no longer see the messages twice.

3)  If you type 100/  MOVE B?,100<cr> you'll now get an ILGL UNDF SYM?
error.  This used to just do the wrong thing.  Also, MOVE 100(B?)
now does the right thing (puts it in the left half when B is defined).

DDT 1370	    RWK 5/23/79

:SFAUTH will now work on links.

DDT 1369	    RWK 5/17/79

Mostly bug fixes.  The main changes which should be user-detectable
are:

1)  DDT will no longer offer --INIT-- when logging in for the second
time when alredy logged in, if the init file which would be run is one of the
default init files (USERS1;* LOGIN or GUEST1;* LOGIN or linked to them).  It
will simply run the init.  This is for the sake of naive users, allowing them
to get their safe settings always.

2)  Typeing ^X does not give the job TTY even instantaneously.  Thus
typing ^X will not cause a %PIATY interrupt.

DDT 1353	    RWK 3/17/79

:COPY and :MOVE (but NOT :COPYN) now copy the file author as well as the
creation date of the file.

DDT 1350	    RWK 12/23/78

SYS3;	DDT will now search the SYS3 directory if it exists when looking
	for a program.  This should relieve the directory space crunch
	on the SYS directories for a while.  A SYS3 directory has been
	created on MC.  It is not required that other systems add a SYS3
	directory if they value the directory slot more than the SYS directory
	space.

:DDTSYM OMAILF
	giving OMAILF a value of zero now asks for a yes-no answer rather than
	a space-rubout answer, because it was too easy to accidentally delete
	your mail.

--MSGS--
	typing CR to a --MSGS-- has been changed to read in the CR so that it
	doesn't flush latter --MORE--'s and such.  This is consistant with
	the treatment of rubout after a --MORE--.

The <space> lossage has been fixed.

:ICHAN <chan>
	<chan> is taken to be a channel number (it may be an expression)
	Status info for that channel in the inferior is printed.

:IOPEN <chan>,<control bits>,<filename>
	This opens <filename> with mode <control bits> on channel <chan>
	in the current job.  The resulting TRUENAME is then printed.

:8TYPE <value> or
:8TYPE<cr>
	This is a quick-and-dirty crock to aid CHAOSNET hackers and CRTSTY
	hackers.  If used in the :8TYPE<cr> form, it uses the value of Q,
	otherwise it uses the given value, and prints it if it were a word
	of 8 bit characters.  If the 200 bit is on, the character is proceeded
	by a ~.  The characters are separated by spaces.
	At some point in the future this should be re-done as a typeout mode
	that you can put on & or % or such.  Also, there should be a way to
	type this stuff in.  Suggestions for exactly what it should do are
	welcome, in the meantime, I offer this crock as a way of getting it
	into this version.

:JCLPRT	prints the JCL of a job

:LJCL	is not new, but now should work properly, so it is being anounced now.
	It allows you to give the current job arbitrary length JCL, ended with
	a control-C, so	carriage returns can be included in the JCL.  This is
	useful for mail from init files, for example.  It provides the same
	editing that :SEND does.  See also :LRUN

:RUN <program> <optional one line of JCL><return>
	not so useful, but see :LRUN

:LRUN <program> <optional line(S) of JCL><control-C>
	is not new, but now should work properly, so is being anounced now.
	It is like a cross between :LJCL and :RUN.  The editing features of
	:SEND are also present.



DDT 1262	    RWK 10/28/78

:SEND now has a true kill buffer, and ^Z while in a :SEND will exit,
	saving the text of your message in the kill buffer.
:SEND now has a ^T command to exchange (toggle) the last two characters
	typed
:SEND now includes single-quote as part of words
:SEND now is self-documenting.  Type the HELP key (^_H on non-TV's)

:SELF is equivalent to HACTRNJ except works if the JNAME isn't HACTRN

:JOBP FOO is like :JOB FOO, but returns 0 if it succeeds, or non-zero if
	it fails
:FJOB FOO is like :JOB FOO, but will never reown the job.  The job is
	marked as permenently forieng, and subsequent $J's to it will not
	reown.  To reown it, do :FORGET and :JOB FOO
:FJOB FOO BAR is like a combination of :UJOB FOO BAR and :FJOB

:LJCL <long jcl with many lines, edited like :SEND>^C now exists.
	if a program expects to handle long JCL, it should terminate it's
	scan on ^C or ^_ or null

:LRUN FOO <long jcl>^C
	is like :FOO but allows FOO to be given long JCL.  Useful with
	:LRUN MAIL <person> This moby init file
		has been run
		again^C

:DDTSYM CKQFLG/  This flag is not new, it's default value of -1 and alternate
	value of 0 remain the same.  However, if given a positive value,
	it will cause :FOO<space> to beep at you if FOO can't be found.
	(-1 is normal, and 0 would cause it to error out as soon as you typed
	 the space, not letting you rub out)

:MSGS now clears the screen before each message, rather than just homing up

:6TYPE <expression> will type the expression as sixbit, with no quoting or
	delimiters.  If no  <expression> is given, it uses Q for its arg.

:DATPRT <expression>  :DATPRT was released earlier using Q for it's argument.
	if no <expression> is given, it will still use Q for it's argument.

:TERPRI will print a CRLF iff the cursor is not already at the left margin.
	It will do this even with the TTY off, so it can be done in init
	files without needing a " " to turn it on which would cause it
	to echo a space and thereby always forcing a CRLF.

:MAILNT <-2, -1, 0, 1, or 2>  -- Mail notify
	This command is only useful if you turn off COMSAT's telling you
	of mail arivals (or if you gag yourself, but that's not really
	useful)  This turning off can be done by an entry of the form
	(RWK (EQV-LIST (FILE [RWK;RWK MAIL]))) which will cause the mailer
	to only send the mail to your mail file, and not to notify you.
	The advantage of this is that 1) You can turn off mail notification,
	but not higher priority :SENDS while in EMACS (see ..SENDRP/-2 and
	..URANDM/ %URMAL), and then get the notification of arrival of
	mail when you return to DDT, while getting your SENDS immediatly.
	2)  DDT will do a better job (I think) of telling you who sent the
	mail then the mailer will with the (R-OPTION SMALL-CLI) (which means
	to only give one-line notifications).

:MAILNT 0  --  The default, do not notify
:MAILNT -1 --  beep on arrival of mail, but print nothing
:MAILNT 1  --  print who the message is from and how long it is.  Assumes
	       the message will be the first one in the file.

:MAILNT 2 or -2 are like 1 and -1 except mail is deferred while in any
inferior 

Mail notification can be inhibited while in a specific inferior by doing
..URANDM/ Q100
from DDT or a valret string or by setting the URANDM word with a .BREAK 12,

If  and friends are given an argument, it is now an error.
^O is disabled if ..DELWARN is 3.
^O, and ONLY ^O is flushed by ^S or ^Z, because it's too often what
randoms expect it to do.  It will not be extended to other commands because
^S is supossed to be typeable with typeahead at any point, and this is a
special exception.

:EXISTS USR:<uname> BAR now works properly, it will not create a job BAR.

^X to a stopped job will tell you that the job is stopped, and print
the PC and instruction just like it would for a running one.

:FOO and FOO^K now look on your home (HSNAME) directory first, and your
working directory (MSNAME) isn't looked at until after searching SYS:


DDT 1072	RWK 10/12/78

Bug fixes prepratory to release to other machines, primarily.

:MSGS (and :GMSGS) now uses a database of dates, rather than a date file.
This eliminates the need for a large percentage of the files on the public
directories, and side-steps the question of what the file should be
called.

:PMDATE prints the date of the last message seen.  Only messages new than
	that will be printed
:SMDATE <date> sets that date.  It takes a date in the same format as
	:SFDATE and friends.  (:SMDATE 10/15/78 16:40:25).  Notable
	special cases are :SMDATE 0, which sets it to NOW, and :SMDATE -
	which sets it to print all of them.

:DATPRT retypes Q as a date.  I.e. it assumes that Q is an ITS
	disk-format date word, and types it in human-readable format.

:DATWRD	<date> has as a value the ITS disk-format date word corresponding
	to date, in the same format taken by :SMDATE, :SFDATE, and
	friends.  This does not work quite properly at the moment, but
100/ :DATWRD 10/15/78 16:40:25<cr><cr> will deposit the date word for
	Oct. 15, 1978, 4:40:25 pm in location 100.  Someday I'll get
	around to fixing this.

DDT 1000	RWK 9/26/78

Bug fixes, growing pains.

OMAILF has been changed.  It can be set negative, zero, or positive.
If negative, mail will be renamed to OMAIL after :PRMAIL prints it.
If zero, it will offer to delete it instead.  If positive, it will never
rename or delete it.   This is useful for people who use RMAIL.

Thus to get the old behaviour, -1 is the same as the old non-zero behaviour
and 1 is the same as the old value of zero.
(I.e. :DDTSYM OMAILF/1)


DDT 988		RWK 9/25/78

Large variety of changes, notably the use of INQUIR to facilitate a uniform
init file/mail file scheme, and the fixing of the problem of SENDS's being
lost when the disk is full.

*  <xuname>, <xuname> and :PRMAIL <xuname> know which directory on which
machine to look for the mail on, providing entries haven't been made in
.MAIL.;NAMES > to confuse things.  I.e. if you forward your mail using
INQUIR, DDT will understand and :PRMAIL will know where to look for it.

* AI, AI, (and ML, MC, DM) use the same XUNAME as last time, but
look on the specified machine instead.

*  :PRMAIL FOO@AI syntax works.  This over-rides DDT's looking for FOO's
mail on FOO's home machine, forcing it to look only on the specified machine.

* :PRSENDS FOO@AI syntax works as well.

* :SEND FOO@AI works as well!
  To go along with this, the header format of :SEND has been changed
experimentally, to be a single line of info as follows.  It provides it's
own header now, because otherwise :SEND FOO@AI would yeild a first like
like "MESSAGE FROM 306J12 MLSLV".  As an experiment, the format has been
completely re-vamped, with the criteria used being 1) take up only one
line (that's one less line of your screen cleared).  2)  Moderately complete
info (time of day, etc.).  3)  Visual standout.  I.e. doesn't hid itself among
the message..it's easy to pick the header out of the crowd.  If you don't
like the new header tell me why, and your preferences on the matter.

* :PRMAIL<cr> will offer to delete your mail for you, iff you don't have an
RMAIL file, rather than renaming to OMAIL.

* :OMAIL and :OMAIL work with the FOO@AI syntax, but no one should use them
   anyway!

* (MC only)  :SSTATU prints the # of MACSYMA's in the system as well as the
other information.

*  is the Inclusive OR operator.  Better choise of character-assignment
  solitited.

* 1U now runs no init file, doesn't offer to read messages, mail or anything.
I.e. Super-Fast Login, faster than 0U.  This used to be used for the DM
LOGIN program, but that is obsolete now.  1U is easier to type than 0U!


Relating to init files, mail files, and HSNAMES

Definitions for those who never knew or have forgotten:

  XUNAME:  "Who you are".  This is what you normally log in as.  However,
	   if you log in more than once, the second time you'll be logged in
	   as a slightly different name, but your XUNAME will still be the
	   same.  For example, FOO logs in twice, the second time he becomes
	   FOO0, but his XUNAME is FOO in both instances.

  HSNAME:  A decoding of the XUNAME into a directory.  The directory on which
	   a user's mail and init files go.  This is a permanent parameter of
	   a given user.  (You don't move your mail file from day to day.)
	   There is no command to change this, it must be done through INQUIR.
	   There is, however, a command to use someone else's HSNAME and XUNAME
	   for the next command.  FOO will use FOO's XUNAME (FOO, of course)
	   and HSNAME for the next program you run.

  MSNAME:  "Master SNAME".  This is what directory you are hacking, your
	   "Working directory".  I.e. if today you are working on a program
	   kept on LISPM, and tomorrow on a system who's files are on your
	   own directory, the first case you might set your MSNAME to LISPM
	   and the second to your own directory.  It's purpose is to tell
	   programs what directory to assume when you don't specify all of a
	   filename.  It is subject to whims of convenience, and a command
	   exists to change it:  :CWD FOO (or FOO) set's the MSNAME to FOO.
	   A program determines the MSNAME from it's SNAME at startup time.

NOTE:  Normally, one should have a null FILE DIRECTORY entry in INQUIR.
It is only in unusual cases where DDT's default actions are inadaquate that
they should be over-ridden by your INQUIR entry.

     When you log in, DDT calculates your HSNAME from your XUNAME, by looking
in INQUIR.  If you have an INQUIR entry, with a non-null FILE DIRECTORY entry,
it parses that.  It should consist of entries separated by commas, like

VSDB,SIPB@MC,BLAH@MIT-ML

The entries are checked one at a time.  An entry with no @ or % is taken to be
a directory, and if the directory exists, it is taken as the HSNAME and parsing
stops.  If there is no such directory, the next is tried.  Similarly, in an
entry with a @ or %, the part before the % or @ is taken as a directory, and
the part after the @ or % is taken as the machine on which it is aplicable.
The entry is ignored either if it applies to a different machine or the
directory does not exist.

If none of the entries in INQUIR applies, DDT then checks if there is a
directory of the same name as the XUNAME.  If so, that is used as the HSNAME.
So people with their own directories don't need to have INQUIR entries
specifying what directory to use.

If none of the above applies, DDT assigns you to one of several public
directories, according to your position in the alphabet, and whether or
not you are a tourist (MC only).  The public directories are called
USERS1, USERS2, USERS3, etc.  On MC there are also GUEST1 GUEST2 and GUEST3
for tourists.  On other machines, no distinction is made.

The mailer uses the same algorithm to find what directory to put your
mail on.  This is how DDT knows where to find your mail with the :PRMAIL
command.

init files and mail files and the like have the following naming convention:
<hsname>;<xuname> <program-ID> where <program-ID> is something like MAIL,
LISP, LOGIN, LOGOUT, etc.  For example

      Old regime	     New Regime
      ----------	     ----------
<random>;.LISP. (INIT)	     <hsname>;<xuname> LISP
(INIT);<xuname> .LISP. 
<random>;.DDT.	(INIT)	     <hsname>;<xuname> LOGIN
(INIT);<xuname> .DDT.
<random>;.DDT_	(INIT)       <hsname>;<xuname> LOGOUT
(INIT);<xuname>	.DDT_

As you can see, the new scheme is simpler conceptually.  Also, given a person's
XUNAME, if you had a way of calculating the HSNAME, you'd be able to run his
init files, no matter where he kept them.  This was not true of the old scheme.
The way to do this is with the <xuname> command.  This command has the same
meaning as it always did, that is, "for the next program you run, pretend you
are <xuname>".  Howver, it is smart about HSNAME's and set's the HSNAME as
well as the XUNAME, so if the program follows the conventions, it will find
FOO's init file if you do FOO LISP

Group directories:
   Often people sharing a single directory wish to share a common init file.
This can be done using "*" for the first file name, rather than the XUNAME.
"*" means "match any XUNAME".  Thus if several people, say A, B, and C, using
directory DD, all want the same init file, they can call the file
DD;* LISP or DDT;* LOGIN or whatever.  If a person F also uses that directory,
but wants a different action, he can call his init file DD;F LISP and it
will be found in preference to the * LISP.

** Two new .BREAK 12,'s to aid the new init/mail scheme
*  ..RHSNAME (16)   --- Translate an XUNAME into an HSNAME
This performs the lookup function of , plus being generalized to inquire
about on other ITS's The RH points to a two word block.  The first is only read
by DDT, not written.  If it is zero, the HSNAME of the ITS on which it is
running is read.  If it isn't zero, it is expected to contain an ITS, and the
HSNAME for that site is used.  The second word should contain the XUNAME to
look up, and DDT will return the HSNAME in that location.

* ..RMAIL (17)  --- Find a user's mail file.  This performs the function of
.  The RH points to a 3-word block of info.  The first is the ITS name,
the second is the XUNAME, just like ..RHSNAME.  The third is used only
to return a value.  The value's returned are 1) ITS his mail file would be
on.  If an ITS was explicitly specified, it will, of course, be the same
as specified.  The XUNAME is clobbered to be the XUNAME mailed to.  If the
FOO has a BAR@MC Network Address in INQUIR, the ITS returned would be MC,
and the XUNAME would be BAR.  BAR's HSNAME would be returned in the third
word.  The third word is always the HSNAME corresponding to the XUNAME
returned in the second word, regardless of whether a XUNAME translation is
made because of the Network Address entry.

	     ******  Long Standing Problem Fixed  ******

The problem where SENDs when there was no disk space would throw you to
DDT with an error, has been fixed.  Sends are now read in completely before
beginning to write them out.  If an error occurs while trying to write them
out, it prints them immediately, instead, with a warning message telling you
that the disk is full.  Each time you get a send it tries to write them
out, and when it succeeds, it returns to normal.


* ..SENDRP/-2
This is a new mode for ..SENDRP, which says "while I'm in an inferior,
only print the most recent message, not all message since I entered my
inferior.  All messages are printed on exiting, so you can check for
messages you overlooked.

** :SEND now has winning rubout processing
In addition to rubout, control-W rubs out an entire word, and control-U
an entire line.  Control-Y will undo a series of rubouts, ^W's and ^U's
provided it is the first character after such a sequence.  Control-R re-types
the line you are on, and control-K retypes the whole message without clearing
the screen first.  Control-L continues to clear the screen and re-type.  Even
better rubout processing for printing terminals is planned in the near future.

** ..RPUR -- Special hack for LISP.
The RH of the .BREAK 12, is interpreted as an address, and the page that
address is on is unpurified.  This is so LISP doesn't have to reserve
a page for depurificaton.  This is defined to do whatever LISP wants it
to do, so if LISP decides LISP wants something else, it will be changed
or deleted, unless you explicitly tell me you are using it for one reason
or another.

* :CORTYP <loc> prints information on the type of page that <loc> is on in
the current job.

* :CORPRT maps :CORTYP over the existing pages of the current job.

* ..PCPNT hackery improved.
POPJ and POP when printed as the instruction to be executed (..PCPNT) print
the contents of the top slot on the stack.  I.e. the PC about to be POPJ'd to
or the value about to be moved into the effective address.

** For init files which wish to test such things:
OSPEED, ISPEED, and SMARTS variables are available, as in :DDTSYM SMARTS/
TTYMXH and TTYMXV are the horizontal and vertical sizes of the terminal,
respecitively.
:DDTSYM ERASE means that this is a terminal that can handle X properly.
None of these variables should be set by the user!

* For DDT debugging:  HHACK has -1, or location of last deposit into a location
deemed not for user depositing.  Helps to detect crash dumps from things
like people depositing into their stack pointer.

* Bug fixes
 always does ..PCPRT printing, ignores ..C.ZPRT
Getting mail while in the middle of reading mail with :Prmail doensn't
cause that message to be lost

 no longer produces that obnoxious warning message about links.
if DELSARN/-3.

Spurious 's are no longer put at the end of the SENDS file.

Bug where inferior's could type while you were on COM link
has been fixed, as well as the bug where jobs would get 'ed accientally
    
Raid register display bugs fixed

Impure can overflow onto page 1 without lossage.  Currently smaller

----------
DDT 694		RWK 6/02/78

* New command  :PDUMPI <file>,<ifile>
Like :PDUMP <file>, but instead of dumping symbols, writes an indirect symbol
table pointer to <ifile>.  It will give an error if you try writing it with
an indirect pointer to itself.

----------

DDT 678		RWK 06/01/78

Here is a summary of the changes I've made in DDT since version 659.

* ..DELWARN has a new meaningful value: 3.  If it is set to 3, :LINKN
	    will not work.  :LINK will work but with an explanitory message
	    to explain what is going on.  This is to help the problem of
	    people trying to do COM-links with :LINK and creating links on
	    random directories.

* ..CONFRM  controls whether or not , U, and  require confirmation
	    of a "." (or space in the case of <job>)
	    If it is non-zero (the default), they require it.

* ..MASSCP  if non-zero, . will do a :MASSACRE, killing all jobs.
	    This is not new, but was deleted because it is somewhat dangerous
	    for the novice.  The default is 0, meaning don't allow it, but it
	    is again available for those who want it.

* ..LINKP   if this is >0,  links files ala :LINKN, if this is <0, ala :LINK
	    and if 0, (currently the default, although if desired this may be
	    changed) it is not allowed.

* ..PROMPT  this is a new name for the symbol PROMPT, which formerly could
	    only be accessed via HACTRN$J or :DDTSYM ...  it is XCT'd
	    to perform the prompting.
* ..RPRMPT  is an instruction, like PROMPT, which is XCT'd if C.ZPRT is zero
	    when ^Z returns you to DDT.  See ..C.ZPRT.
* ..C.ZPRT  if non-zero, print out the instruction being executed when an
	    inferior is ^Z'd, I.e. the normal action.  If this is zero,
	    ..RPRMPT is XCT'd instead.

* ..SNDFLG  if non-zero, :SEND is disabled as a command.  Thus, if you have
	    a file TS SEND on your directory, it will be run instead.  If you
	    don't, on the SYS directory is a link to QSEND.  :OSEND will always
	    get the :SEND command.

*	    The special-case code for :LOGIN on DM has been flushed.


* FOO    DDT now does FOO correctly, never selecting the wrong job if FOO
	    was trying to kill itself, and will never create the job if it
	    didn't exist.

* .TEMP.;   If there is a directory .TEMP.;, DDT will use it for SENDS files.
	    :PRSENDS and  know about this.  .TEMP.; is intended as a
	    directory which gets reaped very quickly by a system demon.  Thus
	    sends files go away if left for a day.  This is intended to avoid
	    the directory full problems encountered with COMMON on some
	    machines.


* <foo>X   If the instruction <foo> skips, rather than skipping, DDT will now
	    print <SKIP>.  This is intended to make it easier to distinguish
	    between skiping and non-skipping.  Thus CAIAX would look like:
	    
	    CAIAX
	    <SKIP>
	    *

* SYSDBG    when ITS goes from a state of being debugged to a state of not
	    being debugged, DDT will now print "ITS not being debugged!!"
	    rather than "ITS being debugged".

; new commands:


* :MOVE	    :MOVE <file1>,<file2> now exists.  It deletes the old file after
	    doing a copy.  Note, however, that it is safe to do:
	    :MOVE FOO BAR,SECOND: ... it does a delete while open on the old
	    file, and thus is guarenteed to do the right thing.

Useful in trying to sort out conversations via :SEND etc are the following.
I do not guarantee that these will remain unchanged.

* 	    ^A prints the same sends as the last time  was used, defaulting
	    to your own.
  FOO	    prints FOO's sends, and set's the default for ^A to FOO
  0	    prints your sends, like 0 prints your directory.

* 	    is like , but prints mail files instead.

* 	    is like , but prints OMAIL or RMAIL files.

These all use the same default.
Eventually, these will know where to look, based on the HSNAME for that user.
Currently, however, FOO will look in COMMON;FOO MAIL and FOO;FOO MAIL

------

DDT 659   RMS 12/22/77

* Binary files can now contain additional information on when
they were generated, what conditions were when they were dumped, etc.
At the moment, DDT just preserves this information on loading
and dumps it again.

* The :DUMP command has been eliminated.  You must use $Y to get
an SBLK file dump.  :DUMP will now run the DUMP program.

* If the 40 bit is set in a job's ..URANDM word
in DDT, then while that job owns the terminal other jobs
will not be allowed to type out even if they were ^P'd.
This should be useful for things like IMLOAD.

* :CHUNAM will now aleays "reset all", instead of just offering to.

* When :SEND turns into :MAIL, it uses the XUNAME of the person
whose UNAME was specified in the :SEND.  Thus, if :SEND FOO1
turns into :MAIL, it will mail to FOO.  Of course, :SEND FOO1
when FOO1 is not logged in can't determine the XUNAME and
will still mail to FOO1.
  In addition, :SEND will pause and retry if any temporary
problem occurs.

* DDT attempts to maintain the "home directory" name.
It is initialized to be the same as your XUNAME (the default
DDT init file may alter it according to your INQUIR entry).
Deposit SIXBIT in ..HSNAME to change it.

* All the "type out" commands such as "=", "=", "#", "'", "&", etc.
now are like ";" in that a single level of ^W-age doesn't prevent
them from typing out, though it does prevent them from echoing.
Two ^W's will prevent them from typing out.

* Logging out will ask for confirmation if you have an alarm pending.

* If a forgotten job interrupts, DDT will tell you about it
(but will not "remember" it any more than that;
you must J it to do so).

* DDT will not open any locations when a program is stopped
at a .CALL instruction.  Thus, :CALPRT will do the right thing
at such a time.

* If you load a program, kill the symbols, and try to dump it back
out in the same file, DDT will ask for confirmation to prevent
you from losing the symbols.


DDT 650 RMS 8/15/77
^C's in files, :CORBLK, :FORGET, :NOMSG, .BREAK 12, .LOGOUT 1

* ^R will no longer stop printing when it comes to a ^C in the file.

* DDT init and exit files for people with no directories
should now be on DDTINI; rather than (INIT);.
This is because (INIT); has been getting full.

* :CORBLK can be used to create, delete, purify and unpurify pages.
:CORBLK FRESH <n> puts a fresh page at address <n> of the current job.
:CORBLK NONE <n> deletes the page at address <n>.
:CORBLK PURE <n> purifies the page at address <n>.
:CORBLK IMPURE <n> unpurifies the page at <n> (like :UNPURE <n>).

* :FORGET tells DDT to forget about the current job.
It remains DDT's inferior (if it was), but DDT doesn't know that.
Explicitly selecting it again with $J will make DDT type
"Reowned" and recommence to know about it.

* :NOMSG 0 now does not inhibit notices that the system will
go down within 15 minutes.

* A binary file can now contain an indirect symbol table pointer.
Dumping a job with no symbols, but which has had a file loaded,
will produce a binary with an indirect symbol table pointing
at the last file loaded.  When attempting to load the symbols
of such a file, the symbol table will be read from the file
pointed at by the indirect pointer.  Thus, if you dump a crashed
system program which had been loaded without symbols,
loading the dump file will load the system program's symbols.

* .BREAK 12,[14,,loc] now reads a new word of per-job flags,
and .BREAK 12,[400014,,[value]] writes it.
The flag now defined is 20, which means, if set, that
unsolicited typeouts should not be printed while this job
has the tty (a local form of :NOMSG 0).

* .LOGOUT 1, is a new way for a program to commit suicide,
that works if it is disowned and if it is under a DDT.
Other programs (such as LISP) that can handle .BREAK 16,
should learn to handle this as if it were .BREAK 16,160000 .


DDT 645  RMS 4/24/77
:CWD <dir>  sets your MSNAME to <dir>.


DDT 643  RMS 4/22/77
<job>$^X kills <job>.  It does not change the current job unless
that is the one you kill.


DDT 643  RMS 4/13/77 Preventing :PRMAIL<cr> from renaming to OMAIL
If you deposit 0 in :DDTSYM OMAILF, :PRMAIL<cr> will act
like :PRMAIL <your xuname> in that it will read but not rename
the mail file.  RMAIL users should like this.


DDT 642  RMS 4/11/77  Features involve:
Deferred CALL, $$^P, :PRSEND, literals, raid reg display,
^K clears out the MAR, how to alter DDT's prompts,
:XFILE programming features:  :ALSO and :ELSE, :JUMP and :TAG.
<name>$0U, :COPY, .BREAK to read idx of previously selected job,
.CALL instruction typeout, DDT vars for conditional TCTYP'ing

Now here are the details.

:COPY is now equivalent to :COPYD.  :COPYN is the old sort of
copy (which does not preserve the date or the version number).
$^R is a short form of :COPY/:COPYD.

Deferred CALL:  ^_D, or Control-CALL, is a "deferred" CALL.
It does not take effect until it is read by a program.  At that time,
it interrupts the program and returns to DDT, which will not discard
type-ahead.  Thus, you can use the deferred CALL to type ahead
commands to DDT or other programs.  You also don't need to wait
until you have seen that the running program is finished.

$$^P starts the current job running, allowed to type out
on the terminal but not read from it.  DDT continues to read
commands.  You can run any number of jobs in this way;  any of them
can type out whenever it wants to.  Use this when you have a job
which you expect to type out a little text every so often, and
you don't want to devote the tty to it or it stop it.

:PRSEND prints out a SENDS file.
:PRSEND<cr> prints out your own SENDS file.
:PRSEND <user> <cr> prints out <user>'s SENDS file.
Your SENDS file contains a copy of all :SENDs you have
received in this session.  It is COM:<uname> SENDS.

Literals:  when typing in code you can specify a literal
by typing $$(.  DDT will type a symbol such as "$LT001" and
a closeparen.  You can then type more of the expression.
The $$($LT001) acts like an undefined symbol forward
reference.
   Then, as soon as it's possible (no location open, no
patch or literal in progress), DDT will define the symbol
$LT001 or whatever at the start of the patch area and
open it.  You will see "$LT001/ 0 " printed then.
You should then type in the definition of the literal.
Use the name of the symbol to match the literal up with the
place you referred to it.  Store the last word of the definition
with $$), which will update the value of PATCH.  At this time,
if there are any remaining undefined literals, you will be
asked to define the next one.  Note that a literal not inside
any other literal or patch will be defined as soon as you close
the location you put it in.
   If you cancel a $$( with rubout or ^D, DDT will still think
that the literal needs definition.  When DDT asks you to define
it, just type $$) immediately.  This will restore "." and not
change PATCH.

Raid register redisplay is now smarter.  Registers which have
not changed are not updated.  The only exception is when a plain
$V with no arguments is done - then, all the registers are updated.
It can happen that some raid registers have been overwritten without
DDT's knowing it.  A simple $V will fix that.

^K flushes the MAR, when it re-uses an existing job.
It also sets ..PERMIT and ..SYSUUO to -1 (allows the job to execute
system calls and .VALUEs).

PROMPT and PRMMCH are locations in DDT with which the user can
tailor the way DDT indicates that a command is finyshed.
PROMPT contains an instruction, normally a UUO which types a "*".
PRMMCH, if nonzero, causes DDT to type the machine name (AI, ML, etc)
as part of the prompt.

:ALSO and :ELSE conditionals exist.  :ELSE<cr> and :ALSO<cr>, like
uses of :IF, should be followed by conditionalized commands,
surrounded by a $( and a $).  :ELSE succeeds if the last conditional
failed, while :ALSO succeeds if the last conditional succeeded.

:JUMP and :TAG allow arbitrary transfers of control, including
loops, in valret strings and execute files.  :TAG <tag> defines a tag
and :JUMP <tag> moves the execution pointer to the matching :TAG.

<name>$0U logs in as if you had no init file.

When DDT prints a filename whose device is NET:, the filenames
are printed out with the appropriate interpretation as socket
numbers and host number.

.BREAK 12,[11,,adr] reads the system job number of the job
which was selected in DDT before the current one.  Use this to
write programs which do things to the current job, as if they
were DDT debugging commands.  As yet, there's no way to write in
that job, except via valrets, but you can decode its data structures.
.BREAK 12, options 9 and 10 have been flushed, since they were
useless or obsolete.

When DDT prints out a .CALL instruction, the type of call
will be printed in parentheses after the address.  For example,
100/  .CALL OPNBLK (OPEN) if OPNBLK+1 contains SIXBIT/OPEN/

The terminal's TTYTYP and TCTYP variables are now available
in DDT in the locations TTYTYP and TCTYP, for the sake of init files.
You must use :DDTSYM to access them.
The correct way to do a TCTYP iff you are TELNETing or dialing up
is to cxeck that either %TYSTY or %TYDIL is set in the RH of TTYTYP,
and that TCTYP contains 0.
:DDTSYM TTYTYP/
:IF N $Q&<%TYSTY+%TYDIL>
$( :DDTSYM TCTYP/
   :IF E $Q
   $( :TCTYP LINEL 69. etc.
$)$)
Note that GETTY only contains the TCTYP when the terminal is a display.
TCTYP always contains it.  Thus, SUPDUP'ing from a printing terminal
will not confuse this kind of test.

:SFDATE <file>,- sets <file>'s creation date to "unknown".

..PERMIT is now ..SYSUUO+1, for your convenience.


DDT 637
RMS 9/16/76 Manual, :COPY, --More--, .LOSE, ..SYSUUO, :MASACRE, :UJOB
0) The DDT manual is now installed as .INFO.;DDT DOC.
Its reference section is still DDT ORDER, but a couple
of sections of it were moved into DDT DOC.
1) :COPY and :COPYD now leave the filename defaults set
to the name of the old file instead of the name of the new one.
:SFDATE <file>,<cr> sets <file>'s date to right now.
$$^F works on devices other than DSK (but not longer than 3 chars).
2) :TCTYP NOMORE will now make DDT stop doing --More-- at
the bottom of the screen.
3) .LOSE can produce more complete error messages now,
optionally including the name of the file being operated on
when the lossage occurred.  See DDT DOC, section "DDT Services
to Programs".
4) Depositing 0 in ..SYSUUO causes a job to stop once before
each system call it tries to execute.  Depositing 0 in ..PERMIT
makes it stop once before each .VALUE to execute a string,
each .BREAK 16, to commit suicide, and each .BREAK 12, to write
DDT.  In either case, $P will proceed past the instruction that
caused the stop.
5)The way to open someone else's job is now :UJOB <uname> <jname>,
not <uname>$U <jname>$J
6) When DDT offers to attach a detached tree, it says whether
you have any other detached trees, and whether they are alive
and attachable or dead.
7) $^O is gone.  $$^X. is changed to :MASACRE.  These changes
are to avoid accidental loss of data.
8) $^N now considers words with opcodes 774 and up to be
arguments.  This means that calls to SPECBIND can be $^N'd over
with no special care, and can be ^^'d over.


DDT 625:
RMS 6/12/76 ^H, ?, :RATE, :RAIDRP, SYS2;, $$Q, $X locations
1) ^H with no argument is equivalent to $J $P.
 ^H now apparently echoes as uparrow-H, when used as
 a command.
2) After a "?U?" error message, typing "?" will make
 a forward reference to the undefined symbol.
 Previously, it was necessary to type the "?" right away,
 and once the error message came out it was necessary
 to retype the symbol.
  In addition, the list of such forward references is
 now dumped and loaded by $Y and $L.  The documentation
 of symbol table format has been updated.
3) :RATE <addr> sets up a raid register that displays the
 rate of change of <addr>'s contents.  :ATB <addr> sets
 up a raid register that displays the inverse rate (the
 average time between increments).  Together with
 :RAIDRP <n>, which enters a loop that displays the raid
 registers every <n> seconds until a character is typed in,
 these commands make it possible to observe the dynamic
 performance of a program.  The MON program is hereby
 superseded, and has been flushed.
4) The directory SYS2; now exists, and is searched when
 a system program is run.
5) $$Q has the value of ($Q).  $$<n>Q has the value of ($$<n>Q).
6) Command lines to programs will now be terminated by ^_
 as well as by ^C and C.R.
7) The core locations in the inferior used by DDT for such
 purposes as $X and breakpoint conditional instructions
 are now documented, under .40ADDR.  That is because
 the left half of .40ADDR can now be used to specify
 the location of that 20-word block.  The left half should
 be the address of the block, except that for compatibility
 if it is zero the block starts at 20 (its default location).
8) $$1U now logs out, without running the .DDT_ (INIT) file
 and without doing a :OUTTEST instead.  $$0U continues
 to do a :OUTTEST.
  Attempting to log out will cause a DDT that is not top
 level to commit suicide with a .BREAK 16,.
9) $<n>^X.  is like $^X., but after killing the current job
 does $<n>J to select another one.
10) $G now saves the previous PC in ..XECP, just as $X does.


DDT 618:
RMS 5/27/76 $$^F, :SFDUMP
1) The new variable ..DIRFN1 in DDT controls which
mode of the DIR: device is used by $$^F.  For example,
putting $$1'cdate down$ in ..DIRFN1 and ..DIRFN1+1
will make $$^F use that mode.  See DDT ORDER.
2) :SFDUMP now exists, for setting/clearing the dumped
bit of a file.  It takes a filename and <0 or 1>.


DDT 616:
RMS 5/21/76 :RETRY, :<PRGM>, $$^F, $<N>J.
1) :RETRY <prgm> now is the alternative to :NEW <prgm>;
whereas :NEW will always try to make a second copy,
:RETRY will always clobber an existing copy of <prgm>.
simple :<prgm> will do either a :RETRY or a :NEW
as ..GENJFL is either zero or nonzero.  it is now
initially -1, so 
  :<prgm> has been switched back to making an
  additional copy of <prgm>.
2) $$^F is now equivalent to :PRINT DIR:FIRST ^X
(except that it doesn't alter the defaults).
it prints an abbreviated directory listing, containing
only the files whose fn1 matches the current default.
<NAME>$$^F sets the default fn1 to <name> before
printing the directory, so that files with fn1
equal to <name> are printed.  this change in the
defaults is permanent.
3) $<n>J is a generalization of $1J;  it pops the job
pdl <n> times instead of once.  Its main use is after
a :NEW FOO ... :KILL, to return to the job current
before the :NEW FOO.  $1J $1J won't do, soince the first
one would try to reselect FOO, causing an error.
$2J will do the trick.


DDT 612:
RMS 5/14/76 RAID REGS, :NEW, :COPYD, :MSGS, :MSG, $J, ..U010, :LISTS
1) A DISPLAY DEBUGGING FEATURE NOW EXISTS:  ONE CAN SET UP
 SEVERAL LOCATIONS TO HAVE THEIR CONTENTS AUTOMATICALLY DISPLAYED.
 THEY ARE UPDATED EACH TIME THE JOB RETURNS TO DDT, OR ON COMMAND.
 THE $V COMMAND MANIPULATES THEM - SEE DDT ORDER FOR DETAILS.
 SEE ALSO :RAIDFL AND ..RAID
2) :<PRGM> WILL NOW ACT JUST LIKE <PRGM>^K IN THAT IT WILL
 CLOBBER AN EXISTING JOB, NOT CREATE A NEW JOB.  :NEW <PRGM>
 SHOULD BE USED TO CREATE A SECOND COPY OF THE PROGRAM.
 TO PROTECT USERS FROM LOSSAGE WHEN TRYING TO USE :<PRGM>
 TO MAKE A SECOND COPY, FOR A FEW WEEKS DDT WILL ALWAYS QUERY
 "--CLOBBER EXISTING JOB--" IN THAT CASE (BUT <PRGM>^K WILL
 NOT DO SO UNLESS ..CLOBRF IS SET).
3) :COPYD <OLDFILE>,<NEWFILE> WILL COPY THE FILE GIVING THE
 COPY THE SAME CREATION DATE THAT THE ORIGINAL HAD.  IN ADDITION,
 THE REAL NAMES OF THE <OLDFILE> WILL BE USED AS THE DEFAULT
 NAMES FOR THE <NEWFILE>, SO THAT :COPYD FOO >,BAR WILL PRESERVE
 THE ORIGINAL FN2.
4) :MSGS WILL NOW TAKE A LIST OF MACHINES, AND SHOW ALL MESSAGES
 INTENDED FOR ANY OF THOSE MACHINES' COMMUNITIES.  :MSGS<CR>
 WILL SHOW ONLY THE MESSAGES FOR THE MACHINE IT IS RUN ON.
 :MSGS DOES NOT GO OVER THE NETWORK TO DO THIS;  INSTEAD, EACH
 MESSAGE IS PRESENT ON ALL MACHINES, BUT SAYS WHICH MACHINES IT
 IS REALLY MEANT FOR.
5) THE DDT COMMAND :MSG HAS BEEN ELIMINATED.  :MSG NOW RUNS QMAIL,
 WHICH WILL BEHAVE APPROXIMATELY THE WAY :MSG USED TO:  THE ARGUMENT
 SHOULD BE THE TOPIC, WHICH WILL BECOME THE FN1 OF THE MESSAGE FILE.
6) DDT NOW CAN DETECT WHEN A BREAKPOINT HAS BEEN CLOBBERED BY THE
 PROGRAM, AND WILL PRINT A MESSAGE TO THAT EFFECT.  ALSO, IF A
 BREAKPOINT CAN'T BE INSERTED, DDT WILL COMPLAIN, CLEAR THE BREAKPOINT,
 AND CONTINUE.
7) $J DONE IN A JOB THAT'S WAITING TO RETURN BECAUSE
 IT WANTS TO .VALUE OR USE THE TTY, WILL NO LONGER PROCEED
 THE JOB.  USE $P TO DO THAT.
8) A PROGRAM CAN NOW TELL DDT WHICH OF ITS UUOS USE THEIR MEMORY
 LOCATIONS AND ACCUMULATORS, FOR THE SAKE OF OPENING THEM AUTOMATICALLY
 A LA ..PCPNTF.  THIS IS DONE BY DEFINING SYMBOLS WITH NAMES SUCH AS
 ..U010, WHERE THE 3 DIGITS ARE THE OP-CODE IN QUESTION.  SEE DDT ORDER.
9) AFTER A :LINK, THE DEFAULT FILE NAMES WILL BE THE NAME OF THE LINK.
10) :SLIST IS NOW CALLED :LISTS.  IT LISTS ALL THE CURRENT JOB'S SYMBOLS.


DDT 598
RMS 2/1/76 ..SAFE, $>, $1J, ..MORWARN, :SFREAPB, :SFAUTH, $$10^K
1) You can protect a job from being clobbered accidentally
  by depositing a nonzero value in its ..SAFE variable.
  After that, anything which is likely to clobber it (such as
  logging out, :KILL, $L, ^K ...) will query first: "--KILL
  PROTECTED JOB--" or "--RELOAD PROTECTED JOB--".
2) $> works on I/O instructions.  For example, after "CONO PI,A",
  "PTR,$>" will have the value "CONO PTR,A".
3) $1J selects the job that was selected before the current one,
  by popping a stack.  "FOO$J $1J" is guaranteed never to change
  the current job.  This is most useful in valret strings.
4) Verbose --MORE--'s (that say "(SPACE=YES, RUBOUT=NO)" are now
  controlled by a new flag ..MORWARN, rather than by ..CLOBRF.
  By the way, "--MORE--" is now used instead of "**MORE**", for
  uniformity.
5) :sfauth <file>,<author> sets the author name of the sepecified
  file (works only on DM)
6) :sfreapb <file>,<0 or 1> sets the inhibit-reap bit of the file.
  Automatic reaping such as is done on ML and DM will not delete a
  file whose inhibit-reap bit is 1.
7) $$10^K disowns the current job, and marks it as to be killed
  if it is ever stopped or blocked for an hour.


DDT 594:
RMS 1/9/76 :REAP, ..SMLINS, ..SYMOFS, 0^F, 0$>, "(SPACE=YES, RUBOUT=NO)",...
1) :REAP SAYS THAT A FILE SHOULD BE THROWN AWAY IN THE NEXT GRIM
REAP IF IT ISN'T REFERRENCED AGAIN.
2) :SEND TO A USER WHO LOGS OUT WHILE IT IS BEING TYPED IN
WILL ONCE AGAIN MAIL.
3) FOR NAIVE USERS (..CLOBRF NONZERO), DDT WILL PRINT
"(SPACE=YES, RUBOUT=NO)" AFTER EVERY **MORE** OR OTHER SUCH
UNSOLICITED OFFER.
4) ..SMLINS: THE USER CAN REQUEST THAT DDT TRUNCATE :SENDS TO A
CERTAIN NUMBER OF LINES.
5) KL-10 OPCODES ARE NOW KNOWN TO DDT
6) DDT NOW KNOWS ABOUT THE .XUNAME VARIABLE IN AN INTEGRATED WAY.
THE XUNAME DOESN'T CHANGE WHEN THE RUNAME CHANGES.  THE XUNAME
IS NOW USED FOR FINDING INIT FILES, SO DIFFERENT PEOPLE SHARING
A DIRECTORY CAN HAVE DIFFERENT INIT FILES.
7) FOO$^S BEFORE BAR^K CAUSES BAR TO BE RUN AS IF FOO WERE RUNNING
IT.  MORE PRECISELY, BAR IS RUN WITH FOO AS ITS .XUNAME.
ALL PROGRAMS SHOULD NOW USE .XUNAME TO DECIDE WHAT INIT FILE TO USE,
ETC, SO THAT THIS FEATURE WILL WORK.
8) :CHUNAME NOW OFFERS TO --RESET ALL-- DDT AND SYSTEM USER-OPTIONS.
9) ..SYMOFS MAY BE SET TO CONTROL HOW LARGE A NUMERIC OFFSET MAY
APPEAR IN A SYMBOLIC TYPEOUT
10) 0^F IS NOW THE SAME AS <MSNAME>^F
11) 0$>  0 $> NOW CLEAR OUT THE ADDRESS AND OP-CODE FIELDS.
12) .UAI, ETC. ARE NOW PREDEFINED SYMBOLS
13) WHEN THE NEXT INSN A PROGRAM WILL EXECUTE IS IMMEDIATE,
AND IS INDEXED OR INDIRECT, DDT WILL PRINT OUT ITS EFFECTIVE ADDRESS.


DDT 581:
RMS 8/6/75 :LINKN, $P, $J, :SNARF
1) :LINKN IS LIKE :LINK BUT IS WILL GO AHEAD AND CLOBBER
 AN EXISTING FILE OR LINK, WHEREAS :LINK WILL (AS BEFORE)
 ERR OUT WITH "FILE ALREADY EXISTS".
2) $P WHEN THE CURRENT JOB IS WAITING FOR THE TTY OR WAITING
 TO VALRET A STRING WILL NOW START THE JOB UP IMMEDIATELY.
 THE SAME GOES FOR $J WITH NO ARGUMENT, WHEN THE JOB IT REACHES
 WANTS THE TTY OR WANTS TO VALRET.
3) :SNARF WILL NOW WORK EVEN IF THE DDT BEING SNARFED FROM
 HAS FATAL INTERRUPTS (AS DETACHED, DEAD HACTRN'S DO).


DDT 579:
RMS 8/1/75 NOW, BETTER THAN DECODING YOUR JNAME,
IS DECODING YOUR XJNAME (FOUND IN ..XJNAME, OR READ WITH
A .BREAK 12,). THE XJNAME ALWAYS REFLECTS THE PROGRAM
NAME SPECIFIED BY THE USER - THE JNAME MAY NOT (":FOO"
MAY YIELD A JNAME OF "FOO0" BUT THE XJNAME WILL DEFINITELY
BE "FOO"). ONE PROBLEM IS THAT YOU MAY HAVE TROUBLE RUNNING
UNDER RANDOM SUPERIORS OTHER THAN DDT.
** LATER NOTE: A .XJNAME USER VARIABLE EXISTS, THAT YOU
   CAN LOOK AT WITH .SUSET.  THAT'S THE BEST WAY TO OBTAIN IT **

DDT 577:
RMS 7/29/75 MAILING USES QMAIL!  :?, $?, $$^K
1) :MAIL, :BUG, :FEATURE HAVE BEEN FLUSHED AS DDT COMMANDS,
  AND NOW RUN QMAIL.
  :BUGA AND :MAILA HAVE BEEN FLUSHED.
  :SEND WILL SEND DIRECTLY IF THE TARGET IS LOGGED IN;
  OTHERWISE, IT TURNS INTO :MAIL (THAT IS, RUNS QMAIL).
  :SHOUT AND :MSG STILL LIVE ENTIRELY INSIDE DDT.
  :OMAIL AND :OMAILA PROVIDE THE OLD FUNCTIONS OF
  :MAIL AND :MAILA IN CASE A) YOU WANT MAILA OR
  B) QMAIL IS SCREWED UP.
2) :? NOW PRINTS MORE INFORMATION, CLEARLY DESCRIBING THE
  ARGUMENTS USED BY EACH COLON COMMAND. THE INFORMATION
  NOW LIVES IN A FILE, .INFO.;DDT :CMNDS
3) STRAINING TO DECODE A .SUSET OR .USET WORD?
  JUST DO .R$?? OR .S$?? (I PRESUME YOU CAN TELL WHICH
  ONE IS APPROPRIATE, BY LOOKING AT THE SIGN BIT). .R AND .S
  HAVE INITIAL DEFINITIONS IN DDT TO MAKE THEM WORK.
4) $$^K HAS NEW FEATURES FOR THOSE HACKING SYSTEM DEMONS.


DDT 574:
RMS 7/26/75 ?, $Y, :PDUMP, :CHUNAME, $?
1) ? FOLLOWING A SYMBOL STILL MAKES A FORWARD REFERENCE TO
    AN UNDEFINED SYMBOL, BUT ? IN ANY OTHER CONTEXT MEANS
    "RETYPE THE ARGUMENT OR $Q IN BIT TYPEOUT MODE"
    (SPECIFICALLY, IN $?$H MODE). IF YOU ARE WORRIED ABOUT
    ACCIDENTALLY GETTING THE WRONG MEANING OF ?, PUT A
    SPACE IN FRONT OF IT WHEN BIT TYPEOUT IS INTENDED.
2) $Y AND :PDUMP WILL NO LONGER CLOBBER AN OLD BIN FILE
    WHEN THEY ARE QUIT OUT OF WITH ^G.
3) :CHUNAME <NEWUNAME> IS LIKE LOGGING OUT AND LOGGING BACK
    IN AS <NEWUNAME>, BUT FASTER.
4) BIT TYPEOUT MODE WILL NO LONGER EVER USE LEFT-HALF BITS
    TO TYPE OUT A RIGHT HALF, OR VICE-VERSA. IF THERE ARE
    NO RIGHT HALF BITS IN EITHER THE MAIN OR THE ALTERNATE
    BIT TYPEOUT MODE, THE RIGHT HALF WILL BE TYPED OUT
    AS AN ADDRESS; SIMILARLY FOR THE LEFT HALF.
5) IF THE SYMBOL <PREFIX> IS UNDEFINED, <PREFIX>$? WILL
    LOOK FOR THE SYMBOL ..B<PREFIX> BEFORE DEFAULTING THE
    BIT PATTER TO 525252,,525252.


DDT 569
RMS 7/9/75 BIT TYPEOUT, :TCTYP BEFORE LOGIN, $1L, $<N>=, ^F
1) A NEW TYPEOUT MODE, "BIT TYPEOUT MODE", EXISTS,FOR TYPING OUT
 A WORD IN TERMS OF A PARTICULAR SET
 OF SYMBOLS FOR SPECIFIC BITS. A SPECIAL SECTION OF DDT ORDER
 DOCUMENTS THIS MODE. IT IS SELECTED WITH $?. MOST OF THE
 IDEAS WERE DUE TO GLS.
2) PROGRAMS MAY NOW BE RUN BY ^K AND : COMMANDS WITHOUT
 FIRST LOGGING IN. LOGGING IN KILLS ALL INFERIORS (THIS
 CAN'T BE AVOIDED).
3) 6-CHARACTER DEVICE NAMES NOW WORK.
4) <USER>^F <DEVICE>^F  NOW LISTS THE DIRECTORY
 OF THE SPECIFIED USER ON THE SPECIFIED DEVICE.
5) $<R>= PRINTS ITS ARGUMENT OR $Q IN RADIX <R>.
6) $1L LOADS WITHOUT SYMBOLS.
7) $N, $W, $E WILL NOW SEARCH THROUGH DDT IF GIVEN
 ADDRESSES WHICH ARE DDT-REFERENCES.
8) ..MSNAME CONTAINS THE MSNAME, IN SIXBIT.
9) MESSAGES SENT THAT START WITH RUBOUTS, DO NOT HAVE
 "MESSAGE FROM <UNAME> <JNAME> ADDED BY DDT.
10) :SHOUT'S NOW NORMALLY SAY "SHOUT" INSIDE THE MESSAGE
 TO AVOID SOUNDING PERSONAL.


DDT 555
RMS 5/3/75 ^P, $^P, :SHOUT, $^N, ^O, $>, .BREAK 12
1) WHEN A JOB THAT HAS BEEN ^P'D TRIES TO USE THE TTY IN ANY WAY
IT WILL NOW INTERRUPT DDT, WHICH WILL SAY
"JOB <JNAME> WANTS THE TTY". $P'ING THE JOB WILL START IT UP
AGAIN; $J'ING TO IT OR ^X'ING IT WILL CAUSE IT TO SAY
"DTTY; <PC> >> <INSN>" AFTER WHICH $P WILL START IT UP.
THE NEW COMMAND $^P IS JUST LIKE ^P EXCEPT THAT AFTER BEING
$^P'D, THE JOB WILL JUST HANG DUMBLY IF IT TRIES TO USE THE
TTY. THIS INTERRUPTING FEATURE CAN BE TOTALLY DISABLED, EXCEPT
FOR PROGRAMS THAT SPECIFICALLY TURN IT ON, BY PUTTING ZERO
IN ..TWAIT.

2) $^N IS NOW CLEVER ABOUT FIGURING OUT WHEN A CALL IS
FOLLOWED BY ARGUMENTS.
HOWEVER, IT CAN RECOGNIZE ARGUMENTS ONLY WHEN THEY HAVE
ZERO IN THE OP-CODE FIELD. $^N PUTS ITS TEMPORARY BREAKPOINTS
ON THE FIRST WORD THAT DOESN'T LOOK LIKE AN ARGUMENT (HAS
A NONZERO OP-CODE FIELD), AND ON THE WORD AFTER THAT.
THIS FEATURE IS OVERRIDDEN IF $^N IS GIVEN AN INFIX ARG
SAYING EXPLICITLY HOW MANY ARGUMENTS THERE ARE AFTER THE CALL,
OR IF $^N IS GIVEN A PREFIX ARGSAYING EXACTLY WHERE THE CALL
WILL RETURN TO.

3) :SHOUT <MSG>^C IS A DDT COMMAND THAT SENDS THE MESSAGE TO
ALL LOGGED-IN, NON-GAGGED USERS, EXCEPT THE SHOUTER HIMSELF.
AS USERS ARE SHOUTED AT, THEIR NAMES ARE TYPED OUT.
SINCE IT DOESN'T REQUIRE A JOB SLOT, IT CAN BE USED FOR
COMPLAINING THAT THERE ARE NO JOB SLOTS.

4) SINGLE-CHARACTER FILE-HANDLING COMMANDS MAY NOW BE VERBOSE.
THE DEFAULT IS THAT ONLY ^O IS VERBOSE.
THE FEATURE IS CONTROLLED BY THE CONTENTS OF ..DELWARN,
AS FOLLOWS:
 0 => NO COMMANDS ARE VERBOSE
 1 => ^O IS VERBOSE
 2 => ALL SINGLE-CHARACTER FILE HANDLING COMMANDS
	ARE (IDEALLY, AT LEAST) VERBOSE.
..DELWARN INITIALLY CONTAINS 1.

5) $> IS NOW MUCH CLEVERER, AND WORKS WITH UNDEFINED SYMBOLS
(EG "FOO?$>"). "()$>" CLEARS THE INDEX FIELD,
"@@$>" CLEARS THE INDIRECT BIT (SINCE @'S NOW XOR TOGETHER
RATHER THAN IOR'ING) AND "0,$>" CLEARS THA AC FIELD.

6) .BREAK 12, FOR READING A SYMBOL'S VALUE NOW WORKS
ON THE SYMBOL ".", AND GETS THE CURRENT LOCATION.



DDT 543
RMS 10/16/74 UNAMES, :MSGS, $$0U, BPTS, SEARCH MASKS.
1) WHEN YOU LOG IN AS "FOO1", DDT MAY NOW REALIZE
THAT YOU ARE RALLY "FOO", AND USE FOO'S INIT FILE,
MAIL, _MSGS_ FILE, ETC. FOR DETAILS, SEE DDT ORDER,
UNDER "DDT'S UNAMES".
2) :MSGS NOW SAYS --MSGS-- BEFORE THE FIRST MESSAGE,
AS WELL AS ALL THE OTHERS. THIS IS FOR THE SAKE OF
INIT FILES.
3) $$0U WILL LOG OUT WITHOUT TRYING TO RUN THE
DDT EXIT FILE (.DDT_ (INIT)). THIS IS USEFUL IF
THE EXIT FILE HANGS UP (EG IT RUNS A PROGRAM, BUT
THERE ARE NO FREE JOB SLOTS IN THE SYSTEM).
4) WHEN A JOB HITS A BREAKPOINT, DDT WILL NOW
PRINT OUT THE NEXT INSN TO BE EXECUTED AS WELL AS THE PC.
5) DDT'S 7 ALTERNATE SEARCH MASKS ARE NOW INIT'ED TO
USEFUL VALUES. IN PARTICULAR, $1M IS 777777,
SO $1W WILL SEARCH THE RIGHT HALVES OF WORDS.
THE REMAINING ONES ARE $2M=777777,,;
$3M= 0 17,; $4M= (17). $5M, $6M AND $7M ARE STILL -1
(AS IS $0M, THE USUAL MASK).


DDT 536
RMS 6/29/74 :OUTTES, .DDT_ (INIT) FILES, SCROLL MODE.
1) DDT NOW DOES BLOCK MODE TTY OUTPUT FOR GREATER SPEED.

2) :OUTTEST PERFORMS ALL THE ACTIONS NORMALLY ASSOCIATED
WITH LOGGING OUT: CHECKING FOR RUNNING INFERIORS,
DELETION OF OMAIL AND SENDS FILES, AND CLEARING THE SCREEN.
U AND :LOGOUT NORMALLY DO A :OUTTES, BUT IF THERE IS A
.DDT_ (INIT) FILE THAT IS SUPPRESSED. THE :OUTTES COMMAND
MAKES IT EASY FOR THE .DDT_ (INIT) FILE TO REQUEST THOSE
ACTIONS ANYWAY IF DESIRED.
THE DEFINITION OF U IS NOW:
 IF THERE IS A .DDT_ (INIT) FILE, EXECUTE IT;
 ELSE DO A :OUTTES;
 LOG OUT.
THEREFORE, .DDT_ (INIT) FILES NEED NOT CONTAIN .LOGOUT ..DDTX
ANY MORE. IF THEY DON'T, THEY ARE EASIER TO TEST WITH :XFILE.

3) IN SCROLL MODE, DDT WILL NEVER CLEAR THE SCREEN (BUT ^L WILL
STILL ECHO AS A CLEAR SCREEN).

4) :MORE AND :IF MORE NO LONGER TURN ON TTY OUTPUT.
THEY NOW DO NOT ALTER ..TTYFLG AT ALL.

5) ..CLOBRF IS NOW INITIALLY ON, AND CLEARED BY $U,
INSTEAD OF INITIALLY OFF, AND SET BY :LOGIN.


DDT 534A
DS 04/11/74 17:02:26  ^K AND ^H HAVE BEEN INTERCHANGED, INCLUDING
PRECEEDING ALTMOD FORMS OF.


DDT 534
RMS 4/4/74 ^H, ^K, :, :GENJOB, :TPL, EXIT FILES, ..SENDRP.
1) FOO^K, FOO^H AND :FOO  ARE NOW DIFFERENT.
THEY ALL DO WHAT THEY USED TO IF THERE IS NO JOB NAMED FOO.
IF THERE IS A JOB FOO ALREADY: FOO^K WILL $P IT INSTEAD OF
LOADING A NEW FOO; FOO^H WILL CLOBBER THE OLD JOB, QUERYING
FIRST IF THE JOB WAS DISOWNED OR ..CLOBRF WAS SET;
:FOO (WITH OR WITHOUT A COMMAND STRING) WILL LOAD A NEW COPY OF THE
PROGRAM FOO INTO A NEW JOB NOT NAMED FOO. (THE NAME CHOSEN WILL
BE TYPED OUT BEFORE THE NEW JOB IS STARTED). BEFORE CREATING
THE NEW JOB, DDT WILL QUERY IF ..CLOBRF IS SET.
..CLOBRF IS INITIALLY OFF, BUT IS SET BY :LOGIN ($U DOESN'T SET IT)
THIS IS AN ATTEMPT TO DISTINGUISH TWO CLASSES OF USERS
AUTOMATICALLY.

2) FILE EXECUTED ON LOGOUT.
IF A FILE <UNAME>;.DDT_ (INIT), OR A FILE (INIT); <UNAME> .DDT_,
EXISTS, $$U AND :LOGOUT WILL :XFILE IT
INSTEAD OF LOGGING OUT AND ALL THAT NORMALLY GOES
WITH IT (EG DELETION OF THE OMAIL AND SENDS FILES).
IF THE EXIT FILE TRIES TO LOG OUT NORMALLY IT WILL CALL ITSELF.
IT CAN LOG OUT BY DOING ".LOGOUT ..DDT$X" TO AVOID THAT.

3) :GENJOB RENAMES THE CURRENT JOB WITH A NAME CHOSEN BY DDT,
WHICH WILL END IN A DIGIT.

4) :TPL, IF GIVEN A NON-DISK FILE, COPIES THE FILE
TO THE TPL INSTEAD OF LINKING TO THE FILE.

5) :<PRGM> WHERE TS <PRGM> CANNOT BE FOUND WILL NOT RESULT
IN AN ERROR MESSAGE UNTIL THE <CR> IS TYPED. IT IS POSSIBLE
TO RUB BACK AND CORRECT THE NAME OF <PRGM>
IF PEOPLE DON'T LIKE THIS I WILL CHANGE IT BACK.

6) ..SENDRP NOW HAS 3 STATES:
0 => PRINT SENDS WHEN RECEIVED, AND WHEN RETURN TO DDT, BUT DON'T
REPEAT THEM.
POSITIVE => DO REPEAT THEM, AND VALUE = REPETITION PERIOD
IN 60'THS OF A SECOND.
-1 => DON'T PRINT THEM AT ALL UNTIL DDT HAS THE TTY.


DDT 530
RMS 3/18/74 WORD SEARCH & MAR FEATURES, ^K DOESN'T CLOBBER,INTERRUPT PRINTOUTS.
1) THERE NOW EXIST 8 MASKS FOR USE IN WORD SEARCHES ($W, $N).
<MASK>$<N>M SETS MASK <N>, FOR <N> FROM 0 TO 7.
<MASK>$M SETS MASK 0.
$<N>W AND $<N>N SEARCH USING MASK <N>. OLD-FASHIONED $N AND $W
WITH NO INFIX ARG USE MASK 0. THUS, DO 777777$1M (17)$2M 17,$3M;
THEN P$1W, (P)$2W AND P,$3W SEARCH THE RH, INDEX AND AC FIELDS.

2) THE MAR (SET BY $I) MAY NOW BE MADE CONDITIONAL BY PLACING
A NONZERO INSTRUCTION IN ..MARC. THE MAR BREAKS ONLY IF THE
INSTRUCTION SKIPS WHEN EXECUTED IN THE INFERIOR.
TO EXECUTE AN ARBITRARY STRING OF DDT COMMANDS WHENEVER THE MAR
IS TRIPPED, PUT IT IN THE JOB AND PUT ITS ADDRESS IN ..MARX.

3) IF <PRGM>^K OR :<PRGM> IS DONE AND A JOB <PRGM> ALREADY EXISTS,
DDT WILL ASK THE USER WHETHER TO GO AHEAD AND CLOBBER IT:
"--CLOBBER EXISTING JOB--". A SPACE SAYS YES.
(THIS IS DONE ONLY IF ..CLOBRF, A LOCATION IN DDT, HOLDS NONZERO,
AS IT INITIALLY DOES). IN AN INIT FILE, TO MAKE SURE THE ^K
SUCCEEDS WITHOUT QUERYING, DO <PRGM>$J $^X. <PRGM>^K.

4) WHEN A JOB RETURNS TO DDT AND HAS PENDING NONFATAL
INTERRUPTS, DDT WILL STATE THEIR NAMES IN PARENTHESES. EG
MPV; (SCLOCK;) 100>>JRST FOO
MEANS THAT THE JOB RETURNED BECAUSE OF AN MPV, AND HAS A SLOW
CLOCK INTERRUPT PENDING.

5) :INTPRT PRINTS OUT $Q AS A LIST OF INTERRUPTS. EG
TSINT/  40   :INTPRT ILUUO;		SINCE 40 IS THE ILOPR BIT

6) $Y WILL NO LONGER DELETE AN EXISTING FILE WITH THE SAME NAME
AS THE NEW FILE BEFORE DUMPING. THIS MATTERS WHEN DUMPING AS >.

7) :NOMSG 0  NOW CAUSES :SENDS TO BE MAILED, JUST AS :GAG 0 DOES.
THE MESSAGES DO NOT GO INTO THE COM:<UNAME> SENDS FILE.
NOTE THAT :NOMSG DOES NOT PREVENT ^_C'S - DO ^_R FOR THAT.


DDT 527
RMS 1/10/74 :SNARF, COMMA, $^N, ..SEND, :NOMSG.
1) IF YOU HAVE A DDT OPEN AS THE CURRENT JOB, AND IT HAS
AN INFERIOR NAMED J, ":SNARF J " WILL MAKE THE JOB J
BE AN INFERIOR OF THE DDT EXECUTING THE COMMAND, RATHER THAN
THE INFERIOR DDT. THIS COMMAND DOES NOT REQUIRE THE
COOPERATION OF THE INFERIOR DDT AND IS USEFUL IF THE INFERIOR
IS A DDT THAT DIED AND GOT DETACHED BY THE SYSTEM.

2) <A>,<B>  WILL NOW PUT <A> IN THE ACCUMULATOR FIELD.

3) <PDL>,$^N WILL PUT BREAKPOINTS AT THE PLACE THAT
THE CURRENT JOB WOULD POPJ <PDL>, TO, AND THE NEXT WORD.

4) ..SEND HOLDS THE TIME BETWEEN REPETITIONS OF RANDOM TYPEOUTS.
THE INITIAL VALUE IS 60.*60. . SETTING IT TO 0 CAUSES RANDOM
TYPEOUTS NOT TO BE REPEATED (EXCEPT ONCE IMMEDIATELY AFTER
RETURNING TO DDT).

5) :NOMSG 0  PREVENTS ALL UNSOLICITED TYPEOUT BY DDT
(INCLUDING "SYSTEM GOING DOWN"!). :NOMSG 1  ALLOWS THEM AGAIN.
ANY MESSAGES THAT ARRIVED IN THE MEANWHILE ARE PRINTED
IMMEDIATELY. IN :NOMSG 0 MODE LOGGING OUT DOES NOT DELETE
THE SENDS FILE ON COM:


DDT 526
RMS 12/22/73 02:43:36  random typeouts; :sends saved; :; :link
1) Random typeouts by DDT, on graphics TTYs when
 an inferior has the TTY, no longer keep the TTY in DDT.
 Instead, they are simply repeated every 20 sec as long
 as the TTY stays with the inferior, and once more when
 the inferior returns to DDT. All random typeouts are now
 always accompanied by bells.
 "JOB <jname> WAITING" is typed when a job without
 the TTY wants to return to DDT, instead of an uparrow.

2) All messages :sent to <user> are put in COM:<user> SENDS
 by <user>'s DDT. That file is deleted when <user> logs out.

3) When a symbol is defined with :, if it exists
 in any block containing the current block it will be redefined
 in that block rather than in the current block.
 This is so that redefining PATCH will always win.
 (PATCH should be in the global block - just say PATCH": in midas)

4) :LINK or :TPL to a non-disk device (in particular,
 to other machines) is now an error.

5) When <prgm>^K or :<prgm> is done, if a disowned
job named <prgm> exists, after reowning it DDT will type
"--CLOBBER EXISTING JOB--". A space tells it to
go ahead and reload the job. Anything else tells
it to quit, with the job reowned but not clobbered.

DDT 525
RMS 12/08/73 23:57:10  INIT FILES FOR THOSE WITH NO DIRS.
1) IF <UNAME> LOGS IN, AND <UNAME>;.DDT. (INIT)
 DOES NOT EXIST (PERHAPS BECAUSE <UNAME> HAS NO DIR)
 DDT WILL LOOK FOR (INIT);<UNAME> .DDT. .
 IF THAT FILE IS FOUND, IT WILL BE USED AS THE INIT FILE.

2) ITS-GOING-DOWN, ITS-BEING-DEBUGGED, ALARM
 MESSAGES PRINTED ON A DISPLAY WHEN
 AN INFERIOR HAS THE TTY, NOW ALL KEEP THE TTY IN DDT FOR
 15 SEC TO PREVENT THE INFERIOR FROM WIPING IT OUT, JUST
 AS :SENT MESSAGES DO. THEY ALSO NOW PRINT A MESSAGE TELLING
 WHAT IS GOING ON. SEE THE NEW "RANDOM TYPEOUTS"SECTION IN DDT ORDER

DDT 520
RMS1 08/08/73 14:20:52  ", :VERSIO, SYS1, AUTO-ATTACH, :IF MORE,
:MONMOD, :MSGS.
1) THE INFIX ARG IN 0" OR 1" NOW SPECIFIES THE LOW BIT
OF THE ASCII VALUE. ONLY THE LOW BIT OF THE INFIX ARG MATTERS.
2) :VERSIO PRINTS YOUR UNAME AND JNAME IF YOU'RE LOGGED IN.
THIS IS THE EASIEST WAY TO FIND OUT WHO'S USING A TERMINAL.
3) BECAUSE THE SYS; DIRECTORY IS FULL, DDT WILL NOW LOK ON
SYS1; AS WELL (FOR ^K AND :-COMMANDS THAT RUN PROGRAMS)
LESS IMPORTANT PROGRAMS SHOULD GO ON SYS1;.
4) LOGGING IN, :INTEST, ETC. WILL CHECK WHETHER YOU HAVE A DETACHED
TREE AROUND (USR:<UNAME> HACTRO) AND SAY --ATTACH YOUR DETACHED JOB--.
A SPACE WILL TELL IT TO DO SO.
5) :IF MORE  IS A CONDITIONAL THAT CAN BE USED TO MAKE
PARTS OF AN INIT FILE OPTIONAL. IT READS A CHARACTER AND SUCCEEDS IF
IT'S A SPACE.6) FOR DM LOSERS, :MONMOD ENTERS MONIT MODE.
7) EVEN IF YOU HAVE NO DIRECTORY YOU WILL GET SYSTEM MESSAGES.
THE DATE FILES ARE KEPT ON _MSGS_;.
8) :NEWTTY TELLS DDT THAT ITS TTY'S TYPE HAS CHANGED.
9) $J THAT OWNS A DISOWNED JOB WILL ALWAYS TYPE :$REOWNED$<CR>

DDT 516
RMS 6/22/73  TTY^F, .BREAK 12, $B, MULTI-STEPPING.
1) TTY^F NO LONGER CHANGES THE $L AND :PRINT DEFAULTS.

2) BREAKPOINTS MAY NOW BE SET AND CLEARED IN RUNNING JOBS.

3) .BREAK 12, OPTION 8 CONVERTS A NUMBER TO A SYMBOL
AND AN OFFSET, AS DDT'S SYMBOLIC TYPEOUT DOES.
SEE DDT ORDER FOR DETAILS.

4) IT IS POSSIBLE TO CAUSE AN INDIVIDUAL SUBROUTINE TO APPEAR TO BE
A SINGLE INSTRUCTION WHEN MULTI-STEPPING, BY PUTTING A SETAI
INSTRUCTION AT THE BEGINNING. THE WORD ADDRESSED BY THE
SETAI SHOULD CONTAIN THE RETURN ADDRESS (EG "SETAI (P)").
THIS AFFECTS ONLY ^^, NOT ^N WHICH WILL STOP AFTER DOING THE
SUBROUTINE CALL, AS IT USED TO.

5) :UINIT, :ASSIGN, :DESIGN   ARE LIKE :FLAP.


HUR 06/02/73 01:51:20  ^C NO LONGER ENDS VALRETS.
COMPLAIN TO ERIC OSMAN.  


DDT 512
RMS 5/5/73  :TPL, :TPLN, #, TYPEOUT MODES, <ARG>$0L, .OPTION, :BUG.
1) :TPL ON A NONEXISTENT FILE IS NOW AN ERROR.
:TPLN, A NEW COMMAND, IS NOT AN ERROR (SAME AS OLD :TPL)..

2) #, IF NOT PRECEDED BY ARGS, RETYPES $Q IN THE # MODE,
NORMALLY SINGLE-CHARACTER ASCII MODE.

3)USER-SETTABLE TYPEOUT MODES ARE NOW ALL PER-JOB;
ALSO, IF YOU DO, FOR EXAMPLE, $#, FROM THEN ON TYPEOUT WILL
USE THE # MODE OF WHATEVER JOB YOU ARE IN AT THE TIME.
THUS, INSTRUCTIONS WON'T BE $X'D EXCEPT IN THE JOBS THEY BELONG WITH.
VARIABLES ..TPERCE, ETC. ARE NOW PER JOB VARIABLES;
..MPERCE, ETC. EXIST AND ARE USED TO INITIALIZE NEW JOBS
(AND USED DIRECTLY WHEN THERE IS NO JOB)
4) <ARG>$0L IS LIKE $0L BUT READS IN STARTING AT
ADDRESS <ARG>. <ARG>$L ALSO LOADS WITH OFFSET, BUT DOES'T
WORK FOR PDUMPED FILES.

5) DDT WILL NOW SET BIT 4.5 OF THE .OPTION USET VARIABLE
OF ALL OF ITS INFERIORS, TO TELL THEM THAT IT IS CAPABLE OF
HANDLING ALL .BREAK 12,'S, ETC.
IF DDT HAS A COMMAND FOR THE JOB, BIT 4.6 (OPTCMD BIT) WILL
BE SET. (IT WILL BE CLEARED IF THE COMMAND IS FLUSHED)
THE IDEA IS THAT PROGRAMS WILL CHECK THOSE BITS BEFORE
USING .BREAK 12,'S FOR SYMBOLS, ETC. OR READING
A COMMAND STRING, RESPECTIVELY, IF THEY CAN GET AWAY WITHOUT
DOING SO. THEY WILL THEN BE ABLE TO RUN UNDER SUPERIORS OTHER THAN
DDT OR AT TOP LEVEL WITHOUT RUNNING INTO TROUBLE BECAUSE THOSE
INSTRUCTIONS AREN'T HANDLED.

6) IT IS POSSIBLE TO ARRANGE FOR :BUG WITH A PARTICULAR PROGRAM
NAME NOT TO MAIL TO SYS. SEE :BUG IN DDT ORDER.


DDT 510
RMS 4/13/73 $$U, &, $%, :OLOAD, ..TMS ETC.
1) $$U, :LOGOUT, $U. WILL CHECK TO SEE IF THERE ARE RUNNING
INFERIORS. IF THERE ARE, --KILL RUNNING INFERIORS-- WILL BE TYPED.
IF YOU TYPE A SPACE, DDT WILL GO AHEAD; OTHERWISE IT WILL TYPE
"FLUSHED" AND DO NOTHING.

3) :OLOAD EXISTS, FOR LOADING SOME FILES MADE BY OLD STINKS
THAT WON'T $L PROPERLY. ANY FILE WHICH LOADS
INTO ADDRESSES ABOVE 400000 REQUIRES :OLOAD. FILES MADE BY STINK SINCE
MID JANUARY WILL LOAD WITH $L.

4) ..TMS, ..TMSQ, ..TM6, ETC. ARE THE ADDRESSES OF DDT'S TYPEOUT ROU-
TINES.  THEY CAN BE USED FOR UN-SETTING USER-DEFINED TYPEOUT MODES.
SEE DDT ORDER FOR DETAILS.


DDT 508
RMS 04/03/73 23:06:29  E&S TYPEOUT, USER TYPEOUT MODES, .BREAK 12,
ADDS TO SYMTAB.
1) .BREAK 12, OPTION 7 ACTS LIKE A ^Y ON WRITING;
AN $$^Y ON READING.

2) $E AND $$E SPECIFY E&S DISPLAY INSTRUCTION TYPEOUT MODE.
DISPLAY INSN AND REGISTER NAMES ARE INITIALLY DEFINED (OPTIONALLY)
SEE ..ESSYM IN DDT ORDER.

3) USER-DEFINED TYPEOUT MODES ARE POSSIBLE!
THE USER CAN REDEFINE THE TYPEOUT MODES ASSOCIATED
WITH $%, ', ", $#, & AND $$ TO USER INSNS TO $X WITH THE VALUE
TO BE TYPED OUT PUT IN 37 . SEE THOSE COMMANDS AND THE SYMBOLS
..TPERCE, ..TDOLLA, ..TDQUOT, ETC. IN DDT ORDER.

4) .BREAK 16, WON'T TYPE ANYTHING OUT OR CLOSE THE OPEN LOCATION
IF BIT 4000 IS SET.


DDT 502
RMS 03/25/73 00:10:06  ^D STOPS SEARCHES, "CARE" MODE IN ^N.
1) ^D STOPS $E, $N, $W THE WAY SPACES ONCE DID.

2) SETTING THE STEPPING FLAG Y PUTS YOU IN "CARE" MODE,
IN WHICH ^N'ING THROUGH A UUO RUNS THE WHOLE
UUO HANDLER AND RETURNS ONLY WHEN (AND IF) THE HANDLER RESTORES
THE FLAGS WITH A JRST 2,


DDT 501
RMS 03/24/73 00:46:55  ^N, $^N, ^^, --INIT--, &, ..LIMIT
1) ^N, $^N, $$^N, ^^, $^^
WILL NO LONGER TYPE CR'S BEFORE PROCEDING THE JOB.
CR'S WILL STILL BE TYPED WHEN THE JOB RETURNS.
THUS, THERE WILL NOT BE A BLANK LINE BETWEEN ^N'S, ETC.
THIS CAN BE CHANGED EASILY ENOUGH.

2) WHEN YOU START A DDT WHEN YOU ARE ALREADY LOGGED IN,
IF YOU HAVE AN INIT FILE, DDT WILL TYPE --INIT--,
AND DO THE INIT FILE ONLY IF YOU TYPE A SPACE, ETC.

3) &, WHICH IS LOGICAL AND, WILL NOW TYPE OUT $Q IN SQUOZE MODE
IF IT IS NOT PRECEDED BY A POSSIBLE OPERAND.

4) ..LIMIT HOLDS THE JOB'S DEFAULT SEARCH LIMITS
(USED BY $E, $N, $W) AS LOW-LIMIT,,HIGH-LIMIT
(INITIALLY 0,,-1)


DDT 498
RMS 03/20/73 16:14:05 CR ECHOES, MAR, ^X, ^P, IO INSN TYPEOUT
CR (^M) NOW ECHOES IN DDT.

WHEN THE MAR IS TRIPPED, THE INSN THAT TRIPPED IT
WILL BE PRINTED AS WELL AS THE NEXT INSN, AS FOLLOWS:
MAR. 100>>MOVE 1,MARWRD
101>>JRST FOO

^X NOW DOES NOTHING TO A STOPPED JOB (IT HAD BEEN AN ERROR)
^P DOES NOTHING TO A RUNNING JOB.

IO-INSTRUCTIONS WITH DEVICE CODES APR, PI, TTY AND DIS
WILL ALWAYS BE TYPED OUT AS IO-INSTRUCTIONS,
REGARDLESS OF WHETHER THE ..D!DEV SYMBOLS FOR THEM ARE DEFINED.


DDT 494
RMS 2/17/73 ^B, :WALBEG, ;, $0L, $0Y, :DDTSYM, :SYMTYP.
1) ^B, ^E, :WALLP HAVE BEEN CHANGED.
:WALBEG (OR :WALLP) OPENS A WALLPAPER FILE, :WALEND CLOSES IT.
^E STOPS OUTPUT TO IT WITHOUT CLOSING IT,
^B CANCELS A ^E (LIKE ^W AND ^V FOR THE TTY)
..LPTFLG IS FOR THE WALLPAPER FILE AS ..TTYFLG IS FOR THE TTY.

2) ; WILL NOW TEMPORARILY SOS ..TTYFLG WHILE IT PRINTS,
SO A FILE CAN TYPE SOMETHING OUT WITHOUT ECHOING.
$; AND $$; WON'T DO THIS, HOWEVER.

3) THE STEPPING FLAGS Y AND Z NO LONGER EXIST.
INSTEAD OF 0 Y$^^ TRY PUTTING 0 IN ..DOZTIM .
DOZING IS NOW DONE FOR AUTO-PROCEDING BREAKPOINTS, TOO.

4) $0L READS A FILE INTO CORE WORD-FOR-WORD.
THE FILE MAY CONTAIN ANYTHING; NO FORMAT IS ASSUMED OR DECODED.
$0Y WRITES CORE INTO A FILE (CAN TAKE ARGS SAYING WHAT RANGE TO WRITE)

5) :SYMTYP <SYM> GIVES INFO ON WHETHER <SYM> IS DEFINED.
:DDTSYM <SYM> RETURNS ..DDT+<VALUE OF <SYM> IN DDT>
..DDT+<INSN>$X EXECUTES <INSN> IN DDT RATHER THAN IN THE CURRENT JOB.
(SO SETZM :DDTSYM LPTOPN$X TELLS DDT THE LPT'S NOT OPEN)


DDT 486
RMS 02/07/73 15:46:02 CONDITIONALS(:IF), :EXISTS, :COPY, $$^C
1) CONDITIONALS LOOK LIKE :IF <CONDIT> <ARG> <CR>  $( ...... $)

2) :EXISTS <FILE>   RETURNS A VALUE OF 0 IF <FILE> CAN BE OPENED,
NONZERO OTHERWISE.

3) :COPY <FILE1>,<FILE2>  COPIES A FILE.

4) $$^C HALF KILLS THE LAST SYMBOL TYPED OUT
EXCEPT AS THE INDEX FIELD OF AN INSTRUCTION, THEN
RETYPES $Q IN THE CURRENT MODE.

5) $( AND $) ARE OPERATORS THAT ARE IGNORED COMPLETELY WHEN READ IN.
(THEY DON'T EVEN STAY AROUND TO BE RUBBED OUT.)

DDT 482
RMS 2/5/73   SYMBOL TABLES, :GAG,  IO INSN TYPEOUT, :ALARM
(VERY IMPORTANT!)
1) SYMBOLS ARE NOW KEPT IN ORDER OF VALUE BY DDT
FOR FAST SYMBOLIC TYPEOUT. THE SYMBOL TABLE STRUCTURE HAS CHANGED,
AND THE EXACT ACTIONS OF <NAME>$:, <NAME>$$:, :PRGM, :LISTP, <SYM>: .
(EG <SYM>: NOW DEFINES IN THE CURRENT BLOCK, NOT GLOBALLY)
LOADING A FILE NOT DUMPED BY THE NEW DDT REQUIRES A SORT
OF THE SYMBOL TALE, WHICH IS SLOW, SO LOAD YOUR FILE AND DUMP IT OUT
AGAIN.  ANY MIDAS-PRODUCED BLOCK-STRUCTURED FILES MUST BE REASSEMBLED.
(BUT NOT PROGRAMS THAT DON'T USE .BEGIN AND .END)

2) $S-MODE TYPEOUT IS CLEVERER AND USER-DEFINED OPCODES
LIKE CALL=PUSHJ P,  NAND  CRR=PUSHJ P,CRF
WILL BE TYPED OUT WHEN APPROPRIATE.
ALSO, NOTHING WILL BE TYPED OUT AS AN IO INSTRUCTION
WITH DEVICE CODE XXX UNLESS A SYMBOL ..D!XXX IS DEFINED.
(IT WILL BE TYPED AS IN HALFWORD FORM OR AS
A NEGATIVE INTEGER). THUS DEFINE ..D120 IF YOU DO
IO INSNS TO THE TTY, ETC.

3) :GAG <NONZERO> NOW ALLOWS RECEIPT OF :SEND'S FROM ANYONE.
:SEND TO A GAGGED USER WILL MAIL.

4) :ALARM <HOUR>:<MIN>
IS THE NEW FORMAT (YOU CAN ADD :<SEC> IF YOU WANT)

5) $$^Y ACTS SOMEWHAT DIFFERENTLY.
A(AND INCOMPATIBLY)

6) :V, :VP, :VK IN VALRETS AND FILES NOW
ONLY SOS ..TTYFLG, RATHER THAN ZEROING IT.

SEE .INFO.;DDT ORDER, WHICH NOW
DOCUMENTS THE SYMBOL TABLE FORMAT AND
THE NAMES THAT SIGNIFY VARIOUS FATAL INTERRUPTS
FROM THE INFERIOR.


DDT 477
RMS 01/28/73 03:27:49 :MAILA, :BUG, :MORE, ^^, ^V, ^W, .VALUE,
.BREAK 12,.
1) :MAILA ADDS TO PREVIOUS MAIL
(PUTS NEW MAIL YOUR EARLIER MAIL)
:MAIL, AS BEFORE, PUTS A NEW NOTE AT THE BEGINNING..

2) :BUG NOW MAILS TO SYS AS WELL AS ANY NUMBER OF USERS
WHO ARE LISTED IN COM:SYSTEM PROGMS FOR THE PROGRAM SPECIFIED.
THE RECIPIENTS ARE ALL NAMED AFTER ^C IS TYPOD.
:BUGA ALSO EXISTS.

3) :MORE ACTS SLIGHTLY DIFFERENTLY. IT DOESN'T TURN ON THE TTY -
USE :MORE^V FOR THAT.

4) ^W NOW AOSES A TTY-OUTPUT-SUPPRESSION COUNT
(HELD IN ..TTYFLG), ^V IN VALRETS AND FILES SOSES IT.
^V ON TTY WILL STILL CANCEL ANY NUMBER OF ^W'S, HOWEVER.
ERRORS NOW TURN ON TTY OUTPUT.

5) .BREAK 12, CAN NOW BE USED TO READ AND SET DDT'S FILENAME DEFAULTS.

6) ONE CAN NOW MULTI-STEP, STOPPING BEFORE JUMPS, BY J$^^, ETC.
ALSO SEE ..DOZTIM.

7) .VALUE 0 NO LONGER CAUSES "FOO>>.VALUE 0" -
INSTEAD IT TYPES ".VALUE 0. FOO+1>>WHATEVER"
WHERE WHATEVER IS THE NEXT INSTRUCTION.


DDT 475
RMS 1/17/73 MULTI-STEPPING, ^^, :BUG, :MAIL, :DETACH, $^N
1) UNPACHING IS NOW DONE WITH $$^], NOT ^^.

2) $^N PROCEDES ONE INSTRUCTION BY PUTTING A PAIR
OF TEMPORARY BREAKPOINTS AFTER IT, WHICH WILL GO AWAY
WHEN THEY ARE HIT. IT WILL STEP OVER A SUBROUTINE CALL AT FULL SPEED.

3) ^^ DOES MULTI-STEPPING:
IT STEPS OVER AN INSN WITH ^N OR $^N, PRINTS THE NEXT INSN, AND REPEATS. 
$^^ AND $$^^ ARE ALSO DEFINED.

4) $<N>G, <LOC>$<N>G SET THE PC AND THEN MULTI-STEP
<N> TIMES, WHERE <N> MAY BE ZERO.

5) :BUG HAS A NEW FORMAT:   :BUG <PRGM> <MESSAGE>^C
THE MESSAGE IS SENT TO <PRGM>'S MAINTAINER.

6) :MAIL PUTS STUFF AT THE START OF THE MAIL FILE AGAIN.

7) :DETACH DETACHES YOUR TREE FROM YOU CONSOLE AND LEAVES
THE TREE DISOWNED AND THE CONSOLE FREE.

8) AUTOMATIC UNPURIFICATION IS NOW INITIALLY ON.
IT HAD BEEN INITIALLY OFF. SEE UNDER SYMBOL ..UNPU IN DDT ORDER.

9) A JOB CAN NOW USE .BREAK 16, TO DIRECT DDT TO KILL IT
IMMEDIATELY EVEN IF IT IS NOT THE CURRENT JOB. IN THAT CASE, IT WILL
GO AWAY WITHOUT THE USER'S BEING INFORMED.

SEE .INFO.;DDT ORDER FOR DETAILS.


RMS 12/21/72 02:54:39 MAIL, AUTO-UNPURE
[ (NO LONGER TRUE)
MAIL IS NOW PUT AT THE END OF AN EXISTING
 MAIL FILE RATHER tHAN AT THE BEGINNING.
]

THE AUTO-UNPURIFICATION FEATURE, WHICH IS ENABLED IFF
 ..UNPURE CONTAINS NONZERO (THIS IS INITIALLY THE CASE)
 CAUSES ANY ATTEMPT TO DEPOSIT WITH DDT INTO A READ-ONLY PAGE OF
 AN INFERIOR CAUSES THAT PAGE TO BE UNPURIFIED.
 ABSOLUTE PAGES ARE NOT UNPURIFIED AUTOMATICALLY.
 ":UNPURE <ADDR> " IS TYPED AS A WARNING,
  (WHERE <ADDR> IS THE ADDRESS BEING STORED IN.

RMS 11/03/72 22:28:54 :UNPURE, :TPL, :LISTF, PAGE-MAP VARIABLES.
:TPL <FILE>    MAKES A LINK FROM THE TPL TO <FILE> .
	USES :PRINT'S DEFAULTS.

:LISTF <FILE>	 NOW LISTS THE DIRECTORY SPECIFIED IN <FILE>
	EXCEPT THAT IF A FILE-NAME APPEARS IN <FILE>
	IT WILL BE USED AS AN SNAME. THUS,
	:LISTF FOO<CR>,  :LISTF FOO;<CR> ARE IDENTICAL.
	:LISTF DSK:FOO<CR> IS ANOTHER REASONABLE EXAMPLE.

:UNPURE<CR>	UNPURIFIES ALL PAGES IN THE CURRENT JOB THAT
	ARE READ-ONLY OR SHARED, EXCEPT ABSOLUTE PAGES.

PAGE MAP VARIABLES:
.UPC+200+<N>   IS PSEUDO-LOCATION OF PAGE MAP VARIABLE <N> .
	FORMAT OF CONTENTS DESCRIBED IN RMS;CORDOC > .


RMS 09/29/72 22:11:34  $$^M, :UNPURE
$$^M DOES NOTHING IF NO LOCATION OPEN.
ELSE, UNPURIFIES THE PAGE CONTAINING THE OPEN LOCATION
(BY REPLACING IT WITH A READ-WRITE COPY)
AND STORES ITS ARG, IF ANY IN THE LOCATION,
CLOSING IT.  THE TEMPORARY TYPEOUT MODES AREN'T RESET.

:UNPURE <ARG>
UNPURIFIES THE PAGE <ADDR> IS IN.


RMS 09/15/72 00:44:55 ^_ TERMINATES :SEND, ETC.
^_ MAY BE USED INSTEAD OF ^C TO TERMINATE A :SEND,
:MAIL, :MSG, OR :BUG. THIS MAKES IT POSSIBLE TO VALRET
THOSE COMMANDS (THAT USED TO BE IMPOSSIBLE BECAUSE
^C TERMINATES A VALRET STRING OR EXECUTE FILE)

^N RETURN ONCE AGAIN RESETS THE TTY INPUT BUFFER.


RMS 09/04/72  DDT 460  ^L, :SEND,ETC.
IF THE TARGET OF A :SEND LOGS OUT WHILE THE MESSAGE
IS BEING TYPED IN, THE MESSAGE WILL BE MAILED.
^L TYPED IN DURING A :SEND, :MAIL, :MSG OR :BUG
WILL CAUSE ALL THE CHARS IN THE MESSAGE TO BE RETYPED.
THOSE COMMANDS NOW ALLOW RUBBING OUT ALL THE WAY TO THE
BEGINNING OF THE MESSAGE.

RMS 09/02/72  DDT 453  ERRORS, DDT ASSEMBLY.
ALL ERRORS BUT ^G WILL PUSH
VALRETS AND XFILES (AND TYPE OUT ":INPUSH " IF ONE IS PUSHED)
RATHER THAN FLUSHING THEM.

<SYMBOL>? IN AN EXPRESSION IS AN UNDEFINED REFERENCE TO <SYMBOL>
IF YOU DEPOSIT THAT, OR THAT + ANYTHING, IN
A JOB'S CORE, AND LATER DO <SYMBOL>: TO DEFINE <SYMBOL>,
THE CORE LOCATION WILL BE UPDATED. :LISTU LISTS
ALL SUCH REFERENCES THAT HAVEN'T BEEN SATISFIED BY THE DEFINITION
OF THE SYMBOL. SEE .INFO.;DDT ORDER.

MOST ERROR MESSAGES (BUT NOT ^G AND ^D) FLUSH FEW
SYLLABLES. TO SEE WHAT IS DONE IN SOME CASE USE ^L TO SEE WHAT
REMAINS.

RMS 8/25/72  DDT 444.
NESTING OF VALRET STRINGS AND EXECUTE FILES:

  IF A :XFILE COMMAND IS GIVEN OR A PROGRAM WHICH
VALRETS STUFF IS RUN FROM WITHIN AN EXECUTE FILE OR VALRET
STRING, THE PREVIOUS ONE WILL BE PUSHED AND THE NEW ONE WILL
BE READ. WHEN IT TERMINATES, READING OF THE OLD ONE WILL
CONTINUE. THE MAXIMUM DEPTH ALLOWED IS 8. IF AN INPUT
SOURCE TO BE PUSHED HAS NO MORE CHARACTERS LEFT IT WILL
BE DISCARDED RATHER THAN SAVED, SO IT IS STILL POSSIBLE
TO CAUSE AN EXECUTE FILE TO LOOP BY MAKING
:XFILE BE THE LAST COMMAND IN IT.
  EXITING FROM A PROGRAM IN ANY WAY THAT .RESET'S TTY INPUT
(EG. ^Z'ING IT, HITTING A BREAKPOINT) WILL CAUSE ANY
VALRET STRING OR EXECUTE FILE TO BE PUSHED AND ":INPUSH "
TO BE TYPED. :INPUSH MAY ALSO BE GIVEN IN THE STRING ITSELF.
INPUT WILL THEN COME FROM THE TTY UNTIL A :INPOP COMMAND
IS GIVEN. THIS COMMAND READS A LINE AND CAUSES THE CURRENT
INPUT SOURCE TO BE POPPED OUT OF AFTER THAT LINE IS
PROCESSED. (EG ":INPOP $P <CR>" MAY BE USEFUL)
NOTE THAT IF AN INPUT SOURCE ENDS WITH AN INCOMPLETE COMMAND,
IT WILL NO LONGER BE FLUSHED. THUS, AFTER VALRETTING
":$PURIFIED$" YOU CAN THEN TYPE "PDUMP FOO BAR <CR>"
SINCE THE COLON HAS ALREADY BEEN SUPPLIED.
   ALL SAVED INPUT SOURCES WILL BE FLUSHED BY ^G'ING,
MOST ERRORS, AND BY THE :INFLS COMMAND.

OPENING .USET VARIABLES AND LOCATIONS IN DDT:

   IT USED TO BE THAT OPENING .UPC, FOR EXAMPLE,
WAS EQUIVALENT TO OPENING LOCATION 760000 .
THIS IS NO LONGER SO. ALL NAMES OF .USET VARIABLES AND
DDT'S USER VARIABLES ARE SPECIAL IN THAT THEIR PRESENCE
IN AN EXPRESSION SAYS THAT IT IS AN ADDRESS IN DDT OR A .USET
VARIABLE NUMBER. THE SYMBOL "." ALSO HAS THAT PROPERTY
WHEN SUCH A LOCATION IS OPEN; THUS, OPENING .+1 WILL WORK.
(AS WILL LINEFEEDING) THE RING BUFFER OF POINT ALSO WORKS.
   THE SYMBOL ..DDT IS LOCATION 0 IN DDT, SO TO OPEN
LOCATION 5000 IN DDT JUST OPEN ..DDT+5000 .
OPENING ..DDT+.UNAME WILL SHOW DDT'S UNAME.
ALL THE INITIAL SYMBOLS ARE NOW DEFINED EVEN WHEN THERE IS NO JOB.

   ^V, ^W, ^B, ^E ARE NOW INTERPRETED AN INTERRUPT LEVEL
FROM THE TTY. THEY ARE COMPLETELY IGNORED EXCEPT FOR THEIR
I-O CONTROL FUNCTIONS. TO ENTER THEM IN ASCII TYPEIN
USE UPARROW FOLLOWED BY THE UN-CONTROLLED CHARACTER.

   SEARCHES WILL NO LONGER BE STOPPED BY ANY RANDOM
CHARACTER TYPED. THEY CAN BE STOPPED BY ^G OR,
IF NOT WALLPAPERING, BY ^S OR ^W.
(IF WALLPAPERING, ^E IS NEEDED)
^G WILL NO LONGER TERMINATE WALLPAPERING.

   .BREAK 16,0 AND .BREAK 16,100000 WILL NOW EXECUTE INVISIBLY
IN JOBS OTHER THAN THE CURRENT JOB. THAT IS, THE JOB'S STATUS
WILL SIMPLY BE SET TO "PROCEDABLE".

   A .VALUE WITH NONZERO ARGUMENT THAT CANNOT BE PROCESSED (BE-
CAUSE NOT FROM CURRENT JOB, DDT HAS TTY, OR ..PERM VARIABLE HAS POS-
ITIVE CONTENTS) WILL CAUSE THE PC TO BE BACKED UP TO BEFORE THE .VALUE.

   WHEN A PROGRAM IS RUN BY ^K OR A :-COMMAND,
THE DEFAULT $L DEVICE IS SET TO WHERE THE PROGRAM WAS FOUND.
HOWEVER, IF THAT WAS SYS: BY DEFAULT, THE NEXT DUMPING COMMAND
WILL CAHNGE THE DEVICE TO DSK: .
THIS WILL NOT HAPPEN IF THE DEVICE SYS: WAS EXPLICITLY SPECIFIED.

   FOO$0B    WILL DELETE THE BREAKPOINT AT FOO.

   $$^C	HALF-KILLS THE SYMBOL DDT TYPED LAST, AND
RETYPES $Q IN THE CURRENT MODE.

   .BREAK 12,[400005,,X]
WILL NOW CLEAR THE JOB'S COMMAND BUFFER REGARDLESS OF WHAT IS AT X.
THE COMMAND BUFFER MAY BE SET BY VALRETTING A :JCL COMMAND.
IF ANYONE IS ALREADY USING.BREAK TO SET THE COMMAND BUFFER
TO OTHER THAN 0, I CAN CHANGE THIS BACK;
THEREFORE AN ARGUMENT OF [0] SHOULD BE USED
JUST IN CASE FOR THE NEXT WEEK OR TWO.

   TRAILING ^@'S (NULLS) IN ASCII TYPEOUT
AND TRAILING SPACES IN SIXBIT TYPEOUT WILL NOT BE PRINTED.

   ^D WILL NO LONGER CLOSE THE LOCATION OPEN.

RMS 8/8/72 ^L, :-COMMANDS, :LISTB, SEARCHES.
^L NO LONGER MERELY CLEARS THE SCREEN; IT ALSO RETYPES
ANY UNPROCESSED TYPED IN SYLLABLES AND CHARACTERS.
THE COLON STARTING A COLON COMMAND MAY NOW BE RUBBED OUT.

COLON COMMANDS CAN NOW SPECIFY A PARTICULAR DEVICE
AND/OR SNAME ON WHICH A FILE TO BE RUN SHOULD BE FOUND.
EXAMPLE:
:DSK:FOO;BAR
WILL RUN FOO;TS BAR .
ALSO, ALTMODE-COLON WILL RUN A PROGRAM WITH SYMBOLS.
AS USUAL, A COMMAND MAY BE PASSED TO THE PROGRAM
BY FOLLOWING ITS NAME WITH A SPACE AND THE COMMAND.
IF AN EXPLICIT DEVICE OR SNAME IS GIVEN,
DDT WILL INSIST ON RUNNING A PROGRAM, EVEN IF A BUILT-IN
COLON COMMAND EXISTS WITH THE SPECIFIED NAME.

:LISTB - LISTS ALL BREAKPOINTS IN THE FOLLOWING FORMAT:
<BPT-NUM>  <ADDR-TO-OPEN>,,<ADDR-OF-BPT>   <CONDITONAL INSN>  <COUNT>

TABS AND LINEFEEDS NOW ECHO WHEN TYPED IN A :SEND.
:SEND, ETC. ARE LEGAL BEFORE LOGGING IN
BUT WILL TYPE "(LOGIN?) " AS A REMINDER TO THE USER.

RMS 07/12/72 02:43:25 $#, ^X AND ^Y IN FILESPECS.
$# SETS TEMPORARY SINGLE-CHARACTER TYPEOUT MODE.
$$# SETS THE PERMANENT MODE.
$0# READS IN ONE ASCII CHARACTER, WHICH MAY BE QUOTED BY 
OR TURNED INTO A CONTROL CHARACTER BY ^, AND PRODUCES A NUMERIC
VALUE. FOR EXAMPLE,
101 $# ;$1#A    $1#A=101    

^X IN A FILESPEC IS EQUIVALENT TO THE DEFAULT FN1 BETWEEN SPACES.
^Y IS SIMILAR, FOR THE FN2.
THUS:  L SYSBIN;TECO BIN
L SYS;TS
IS REASONABLE.

DDT NOW HANDLES BLOCK STRUCTURED SYMBOL TABLES. SEE PJ.
ALSO, THE CURRENT RELOCATABLE PROGRAM IS REMEMBERED
INDEPENDANTLY FOR EACH JOB.
RMS 6/21/72 PREFIX OPS, PATCHING.
UNARY MINUS, ETC. NOW HAVE HIGH PRIORITY: THEY APPLY TO THE
FOLLOWING SYLLABLE.

PATCHING MAKES USE OF THE LOCATION ..PATCH IN DDT'S USER VARS.
IT HOLDS 0 IF NO PATCH IS BEING MADE,
ADDRESS-PATCHED-FROM,,PATCH-AREA   WHILE PATCHING.
THUS, PATCHING IN ONE JOB DOESN'T INTERACT WITH PATCHING
IN ANOTHER; ALSO, IT IS POSSIBLE TO QUIT MAKING A PATCH BY
PUTTING 0 IN ..PATCH  .

$X, :, $K, $$K, ^\, ^], ^^, ^T, ^U  ARE NOW LEGAL IN HACTRN^K MODE.
AC 17 IS NEVER USED IN DDT.

RMS 06/13/72 04:58:24 BREAKPOINTS, ^F, $^F,:LISTF.
DDT NOW REMEMBERS WHICH BPTS HAVE BEEN SET TO AUTO-PROCEED
(BY B OR P) FOR EACH JOB SEPARATELY. ALSO,
TERMINATING AN AUTO-PROCEED BY TYPING A CHARACTER
WILL CAUSE THE BREAKPOINT TO LEAVE AUTO-PROCEED MODE.

IF AN ARG IS GIVEN TO ^F, THE DEFAULT DIRECTORY FOR ^O, :PRINT ETC.
AND THE DEFAULT FOR LOADING AND DUMPING ARE SET TO THE DIRECTORY
WHOSE CONTENTS WERE PRINTED.
HOWEVER, IF $^F IS USED INSTEAD OF ^F, THAT WILL NOT BE DONE.
:LISTF NOW TAKES ONE ARG, WHICH IT TREATS THE WAY ^F TREATS ITS ARG.

RMS 5/20/72 ^T, ^U, .VALUE, $$!, :SYMADD.
1) ^T, $^T, $$^T NOW MAKE USE OF SNAMES.
THEY READ 2 FILESPECS. THE 1ST DEFAULTS TO *:*;* *
; THE SECOND, TO THE FIRST.
^T TRANSLATES FOR THE CURRENT JOB;
$^T, FOR ALL DDT'S *INFERIORS;
$$^T, FOR CURRENT JOB AND ALL *INFERIORS.

^U, $^U, $$^U UNTRANSLATE. THEY READ ONLY 1 FILESPEC.
IT SHOULD BE THE 1ST OF THE 2 GIVEN TO A ^T, $^T, $$^T RESP.

2) .VALUE WITH NONZERO ARG WILL NOT .RESET TTY INPUT.

3) :SYMADD IS LIKE :SYMLOD, BUT DOESN'T FLUSH ALREADY DEFINED SYMS.

5) IF A LOCATION IS OPENED BY $$!, $Q WILL BE SET EVEN THOUGH
NOTHING WILL BE PRINTED OUT.

RMS 05/12/72 23:09:58 , :CLEAR
<USER-NAME> WILL PRINT HIS DIRECTORY,
UNLESS HIS NAME COINCIDES WITH A DEVICE NAME,
IN WHICH CASE THAT DEVICE'S DIRECTORY WILL BE PRINTED,
OF COURSE. THAT SHOULD BE OBVIOUS IF IT
HAPPENS, SINCE "NON DIRECTORY DEVICE" WILL PROBABLY BE TYPED.

:CLEAR CLEARS THE SCREEN. USEFUL FROM FILES AND VALRETS

RMS 5/6/72   :RENAME, :SFDATE, OUTPUT TO TTYS, NEW PREDEF SYMS.
1) WHEN OUTPUTTING TO A NON-GRAPHICS TTY,
DDT WILL NOW INSERT AN EXCLAMATION POINT AND CARRIAGE RETURNTO PREVENT CHARACTERS FROM PILING UP AT THE END,
JUST AS THE MONITOR DOES ON GRAPHICS TTYS.
THE LINEL IS KEPT IN TYOLSZ, AND CAN BE CHANGED BY
HACTRN TYOLSZ[ <NEW LINEL> <CR>

2) :RENAME <FILE1>, <FILE2>
(ALSO $$^O)
RENAMES FILE1 AS FILE2, OF COURSE.
THE 2ND FILE'S NAMES DEFAULT TO THE FIRST FILE'S NAMES,
AS WITH :LINK.

3) :LINK <FILE1>, <FILE2>
CREATES A LINK FROM FILE1 TO FILE2.
IT GIVES AN ERROR MESSAGE IF A FILE NAMED FILE1 ALREADY EXISTS.
(IT USED TO DELETE THE FILE).

4) :SFDATE <FILE1>, <DATE>
SETS FILE1'S DATE TO DATE1.
DATE1 SHOULD LOOK LIKE
MM/DD/YY/HH/MM/SS
WHERE EACH "/" MAY BE REPLACED BY ANY NON-DIGIT. EG:
4/20/72 10:25:7

5) :SFDATE, :DELETE, :RENAME, :PRINT, :LINK
NOW REMEMBER AND UPDATE THE SAME FILENAME.
IT DEFAULTS TO DSK:______ MAIL
:WALLP REMEMBERS ITS OWN FILENAME, WHICH DEFAULTS TO LPT:WALL PAPER
:XFILE REMEMBERS A FILENAME WHICH DEFAULTS TO DSK:.DDT. (INIT)

6) SOME NEW SYMBOLS ARE NOW PREDEFINED IN DDT.
THESE SYMBOLS ARE USED AS .UNAME, ETC. ARE, BUT
THEY REFER TO DDT'S VARIABLES FOR THE CURRENT JOB.
THE ONES LIKELY TO BE GENERALLY USEFUL ARE:

..UPIR		JOB'S INTERRUPTS WHICH INTERRUPTED DDT.
..PPC		PC DDT WILL START JOB AT FOR $P, ^N.
..UIWD		INDICATES WHAT STOPPED JOB.
		  0 => RUNNING, 21 => NEVER STARTED,
		 -1 => RANDOM INT., ELSE AC FIELD OF .BREAK .
..FURN		SET IF FOREIGN JOB.
..INCNT		1-PROCEDE COUNT, 1-PROC UNTIL 0 OR LESS.
..OIPC		$$^N PC, OR 0.
		  IF NOT 0, DECREM. COUNT ONLY THERE OR THERE+1.
..STAR		0, OR A JRST TO STARTING ADDRESS
..PERM		IF <0, JOB CAN DO .VALUE & .BREAK 12, .
..PATCH		0 IF NOT PATCHING, ELSE <PATCHED-FROM>,,<PATCH-AREA>
..UFNA		4 WDS HOLDING LOADED FILE NAME.
..UFIL		3 WDS HOLDING $L, $Y, ETC. DEFAULT FILENAME.
..UFIL+4	$L, $Y ETC. DEFAULT SNAME.
..UCHB		AOBJN PTR TO COMMAND BUFFER.
..PRGM		AOBJN -> THAT PART OF SYM TAB FOLLOWING CURRENT PROGRAM
		NAME.
..JOBS		AOBJN PTR TO SYMBOLS FOR JOB.


RMS 4/30 - :MSGS, :MORE, --MORE--, .BREAK .
1) COMMA TERMINATES FILE-SPECS. TO PUT A COMMA
IN A FILENAME ^Q IS NECESSARY.

3) IT IS NOW POSSIBLE TO ^N THRU A .BREAK 12,  .

4) 4) CHANGES TO :MSGS

WHEN :MSGS TYPES "--MORE--", IT MEANS THAT THERE IS
MORE OF THE MESSAGE BEING PRINTED.
A RUBOUT WILL FLUSH THE REST OF THE MESSAGE.

"--MSGS--" INDICATES THAT MORE MESSAGES REMAIN.
A RUBOUT IS THEN EQUIVALENT TO A SPACE.

IN EITHER CASE, A SPACE WILL CAUSE TYPING TO CONTINUE.

A ^S WILL STOP TYPEOUT UNTIL THE END OF THE MESSAGE OR ITS 1ST LINE.

A ^G WILL STOP TYPEOUT AND NOT FLUSH THE MESSAGES -
  THEY WILL ALL BE SEEN AGAIN IN THE NEXT :MSGS

ANY OTHER CHAR. WILL FLUSH ALL THAT REMAINS.
  THE CHAR WON'T BE FLUSHED; IT WILL BE READ NORMALLY.


EXCEPTION!!! IN AN AUTOMATIC :MSGS ON LOGIN, "--MSGS--" WILL
BE TYPED BEFORE THE 1ST MESSAGE. AT THAT TIME, ANY CHARACTER
BUT SPACE OR RUBOUT WILL STOP TYPEOUT AS USUAL, BUT WILL NOT
FLUSH THE MESSAGES. THUS, IF YOU ARE IN A HURRY, YOU CAN JUST
IGNORE THE "--MSGS--" TYPED BY THE AUTOMATIC :MSGS AND
IT WILL BE AS IF THE AUTOMATIC :MSGS HAD NEVER BEEN DONE.
(THE "--MAIL--" TYPEOUT AT LOGIN TIME ACTS THE SAME WAY.)

5) INTERRUPT LEVEL CHARS (^B, ^E, ^V, ^W) DO NOT AFFECT
CAUSE --MORE-- TO FLUSH.

6) THE :MORE COMMAND TURNS ON TYPEOUT, THEN READS IN AND ECHOES A LINE.
IT THEN READS 1 CHAR. FROM THE TTY, AND GENERATES AN ERROR UNLESS
IT IS A SPACE. THIS COMMAND IS USEFUL IN :XFILE FILES
TO PAUSE BEFORE DOING SOMETHING THAT WILL CLEAR THE SCREEN,
AND TO PROVIDE A CHANCE TO CANCEL.

1)CHANGES IN DEFAULTING OF FILENAMES.

COMMANDS THAT REFER TO FILES FALL INTO THE FOLLOWING CLASSES:

LOADING AND DUMPING: $L, $$L, $Y, $$Y, :LOAD, :DUMP, :PDUMP,
  :SL, :SYMLOD, $^K, ^K.

  THESE COMMANDS ALL REMEMBER AND UPDATE THE SAME FILENAME;
HOWEVER, THERE IS A SEPARATE FILENAME FOR EACH JOB.
ONE OF THESE COMMANDS GIVEN IN ONE JOB DOESN'T INTERACT
WITH THE FILENAMES BEING REMEMBERED FOR OTHER JOBS.
WHEN A JOB IS CREATED BY $J OR :JOB,
THE FILENAME IS INITIALIZED TO DSK: <MSNAME>; <JNAME> BIN   ;
WHEN CREATED BY ^K OR $^K,
TO THE NAME OF THE FILE WHICH WAS LOADED.

^F, :LISTF

  THESE REMEMBER A DEV. AND SNAME.
IF ^F IS GIVEN AN ARG, IT IS FIRST TRIED AS A DEVICE,
THEN AS AN SNAME. THE DEFAULT DIRECTORIES FOR LOADING, ETC.
IN THE CURRENT JOB, AND THE :PRINT-:DELETE DIRECTORY ARE SET.
THEY ARE BOTH SET BY ARGS TO :LISTF.
ALSO, THE SNAME IS SET BY <NAME>$^S .
ALSO, ANY COMMAND OF THE ABOVE TWO TYPES SETS THEM TO THE
ONES USED BY THAT COMMAND.


WITH ANY COMMAND THAT TAKES A FOLLOWING FILE-SPEC,
IF THE SPEC IS TERMINATED BY AN ALTMODE,
THE NAMES OF THE FILE THAT THE COMMAND WOULD HAVE USED ARE TYPED
OUT, AND THEY BECOME THE DEFAULTS (AS IF A PREVIOUS COMMAND HAD USED
THEM). THEN THE COMMAND READS ANOTHER SPEC. THIS REPEATS UNTIL
A SPEC. IS TERMINATED BY A ^M, AT WHICH TIME THE COMMAND WILL RUN.



2) CHANGES TO :NFDIR, :OFDIR.

:OFDIR^M	CLEARS THE MAIN SNAME SEARCH LIST, TURNS OFF SEARCH.
:OFDIR <LIST OF NAMES>	DELETES THOSE NAMES FROM THE LIST.
:NFDIR^M	TURNS ON THE SEARCH FEATURE.
:NFDIR <LIST OF NAMES>	ADDS THOSE NAMES TO FRONT OF LIST.

BESIDES THE MAIN LIST, THERE IS ANOTHER LIST CONTAINING THE
8 MOST RECENTLY USED SNAMES, WHICH IS ALSO SEARCHED
WHEN THE SEARCH FEATURE IS ON.


3) THE :CR, :ST AND :ED COMMANDS ARE GONE.


5) ALTMODE-TYPE COMMENTS IN :-CMDS MUST IMMEDIATELY FOLLOW THE ":".

*********************************************************


A new .BREAK 16, feature has been added, see
common; .BREAK 12,16  .   -- dee
**************************************************
     Line feeds are now ignored after carriage returns
in valret strings (.VALUE) or executed files
(:XFILE).
**************************************************
   Several changes and additions have been made
in the DDT MSGS and MAIL features as explained
below.   --  dee
   As of now, if you have a DDT init file,
neither mail nor messages will be printed
automatically but the commands :PRMAIL (print
mail) and :MSGS (print messages) are
available for possilbe inclusion in init
files.  If you have no init file but you do
have mail, DDT will type out "--MAIL--" and
proceed to type your mail if you type a space
or leave the mail alone if you type any other
character.  If you have no init file but
you do have "messages" (see next paragraph)
DDT will type out "--MSGS--" and proceed to
type out messages if you type a space or leave
the messages if you type any other character.
   Messages are any files in the .MSGS. disk
directory with a creation date later than
a _MSGS_ UNAME file in your directory (where
UNAME is your uname).  When messages are typed
out this file is rewritten by DDT so that
you will normally see each message only once.
If you have no initial date file, all
messages are eligable for type out unless
the problem is that you have no disk
directory.  In that case no messages
are automatically output but all will be on
an explicit :MSGS command.
   When DDT decides to print a message,
it types out the file name, a colon, and the
first line of the file.  It then types
"--MORE--" and will print the rest of the
message if you type a space.  If you type
a rub-out, DDT will go on to the next message,
if any.  If you type anything else, the remaining
messages are not printed.  (On display consoles,
"END MESSAGE" is output after each message
that is typed in full.)
   The :MSG command has been added to conveniently
write .MSGS. files.  Like :MAIL it takes one
symbol after it which should be the "subject"
of the message.  A file with the subject
as the first name and > as the second will
be written on .MSGS. using the same
input conventions as :MAIL.
The existance of this command is not meant
to discourage careful composition of
messages, say with TECO, but they should
include the date and authors identification.
   The use of the .MSGS. feature will result
in more garbage then ever being typed
out at you unless it is used with restraint.
Also try to group information so as to produce
a few slightly broader and longer messages rather
than many very specific messages.  "SYSTEM MAIL" on
SYS; is still the right place for very
important messages.  Note that
there is no automatic garbage collection
mechanism for .MSGS.  Needless to
say, if people don't delete there
own messages eventually some helpful soul
will.
   The following miscellaneous commands have
also been added to DDT:

   :LFILE  Types out last file loaded into
current job.
   :INTEST  Repeat actions normal on
successful LOGIN (looks for init file, etc.)
(BUT IF EXECUTED IN INIT FILE, DOESN'T LOOK FOR IT AGAIN).

*****************************************************

   Old DDT mode has finally been eliminated.  Here
is the old NDDT - ODDT differences note. -- dee

1)  NDDT tries to be much more incremental on input and
in handling error conditions.  Single character rub-out is
available within a syllable or operator.  After rubbing-out
the current syllable or operator, entire previous syllables
and operators are rubbed-out.  (^D has the old effect of
rub-out.)
1a)  Typing an undefined operator will cause the type out
" OP?" but otherwise the operator will be ignored.  Thus
100Lif one types "TECO^H" DDT will respond " OP?" but one can
immediately type "^K" and get a TECO.
1b)  Typing an undefined symbol will cause the type out "?U?"
as soon as the following operator is read to be one that evaluates
symbols before it; DDT will then ignore both the undefined
symbol and the operator that was typed after it.

2)  The argument separators for DDT commands taking several
numeric arguments before them have changed.  "<" and ">" are
now numeric grouping as in MIDAS and "$," or "$ " (thats alt-
mode comma or alt-mode space) should be used to separate ex-
pressions as arguments.  (This should be easy to remember as
analogous to "," and " " serarating expressions making up a
word.)

3)  NDDT has operator precidence and otherwise executes infix
operators left to right.  Highest binding power are "#", "&",
"$_", and "$$_" (xor, and, logical shift, and floating scale).
Next are "*", "$*", "!", and "$!" (fixed and floating multiply
and divide).  Lowest are "+", "$+", "-", and "$-" (fixed and
floating addition and subtraction).

4)  ASCII and SIXBIT input and output have been completely
revamped.  NDDT makes some attempt to type out character strings
im the same manner ans you would type them in.  See the "'"
and """ family of operators below.

5)  There have been many changes in the ":" commands.  Try
a :? to get a list.

6)  For the time being the "DDT assembly" feature does not
exist in NDDT.

^C     Types out a carriage return, line feed but does not
affect the current expression, register open status, etc.  Will
terminate a syllable.

$^C    Types out a CR, LF and then repeats what DDT typed out
recently.

$$^C   Has the old effect of ^C.

^D, $^D, $$^D   Have the old effect of rub-out.

!      Fixed divide.

$!     Floating divide.

"      Types out its argument or, if none, $Q as ASCII in ap-
proximately the form it can be typed in.

$", $$"   Sets type out mode temporarily or permanently to ASCII,
respectively.

$n"    Where n is a non-null numeric string.  This operator followed
by a character string terminated with an alt mode has the
value of the ascii for the first up to five characters of the
string except as follows:  control characters can be input
without side effects by typing an up-arrow followed by the
character controlified; up-arrow and alt mode may be input by
preceeding them with control Q.
(examples:  $1"FOO$, $69"BAR~q~~g$).

$$n"   Similar to $n" except that when one more than a multiple of
five characters is typed a line feed preceeded by the ASCII value
of the preceeding five is simulated and "$$1"" followed by
the extra character is then typed.  This operator
can be used to type in multiword ASCII strings.  If it
appears embedded in an expression, the expression is affected
only by the last value generated by typing in the alt mode
to terminate the $$n".

#      The logical "XOR" infix operator.

$#	REPRINT ARG OR $Q AS A SINGLE ASCII CHARACTER.

&      The logical "AND" infix operator.

$&, $$&   Set type out mode termporarily or permanently to SQUOZE,
respectively.

$n&    Has The value of the SQUOZE for the following up to six
symbol constituents with the 3.6-3.3 bits of n in the mode bits.
The terminating symbol non-constituent is not absorbed but
processed by NDDT as a normal input character.

',$',$$',$n', $$n'   Similar to the """ family of operators above
but on type in and the string is terminated by the
first non-sixbit character which is then absorbed by the
"$n'" or "$$n'" operator.

$*     Floating multiply.

$+     Floating add.

$-     Floating subtract.

$.     Has the value of the current job's user mode program counter.

<, >   Numeric grouping as in MIDAS.

$<     Not currently defined, but a use is planned for it.

$=     Like "=" but prints out in floating point mode.

$$=    A command mainly used for debugging NDDT.  It takes up to
three arguments and types them out.

$E     Now works for programs with discontinuous core images.

$I, $nI   Takes MAR mode as an infix numeric argument, with default
value 3.  0 implies never break, 1 implies break on instruction fetch
only, 2 implies break on write cycles, and 3 implies break on any
reference.  Thus "FOO$2I" will MAR break on an attempt to write in
location FOO.

$N     Now works for programs with discontinuous core images.

$nR, $$nR   Output radix is now set by using an infix numeric argument.
Thus "FOO$2R$C/" prints out the contents of location FOO in binary.

$nT, $$nT   As for $nR, now takes the number of bits per byte
as an infix argument.

$W     Now works for programs with discontinuous core images.

$Y     Now works for discontinuous core images and can take
dump limit arguments like arguments to $Z.  Prefix device arguments
no longer work.

$$Z    Works for programs with discontinuous core images.  Ignores
pure and absolute memory pages.  If given a third argument, sets the
area "zeroed" to that argument rather than to zero.

$[, $]   Same as "[" and "]" but exaimine using left half of argument
or $Q for address (as in $/).

$_     Logical shift infix operator (3$_2=14).

$$_    Floating scale infix operator (3.0$$_2$=12.0).
