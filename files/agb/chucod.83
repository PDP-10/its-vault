;PDL FORMAT:
;  PIECE MOVED,, ORIGIN
;  PIECE-CAPT ,, DESTINATION
;  SAVED FLAGCELL
;  SAVED ALPHA/BETA 

;SIGNALING BETWEEN THE UNIBUS AND THE RUNNING CHEOPS PROGRAM IN THE "CLOSELY 
;    COUPLED" MODE. 
;  CHEOPS -> UNIBUS.  INFO PASSED VIA 6 BIT STAR REGISTER.
;  UNIBUS -> CHEOPS.  INFO PASSED VIA PDP-11-FLAG-0 AND PDP-11-FLAG-1.
;		THESE SHOW UP AS FLAGWORD BITS.

;OPERATION IN "CLOSE-COUPLED" MODE (10 LOADS POSITION DIRECTLY INTO CHEOPS MEMORIES)
;0  INITIAL STATE: STAR ZERO, FLAGBITS 0.
;1  CHEOPS PROCESS SIGNALS IT IS ALIVE: 1 -> STAR
;1  UNIBUS COMMANDS CHEOPS TO START CLOSE COUPLED POSITION EVALUATION:
;     UNIBUS COMMAND 1
;2  CHEOPS ACKNOWLEGES THAT IT IS SEARCHING:  2-> STAR
;3A CHEOPS SIGNALS THAT IT HAS COMPLETED SEARCH:  4-> STAR AND CHEOPS HALTS
;3B  IF CHEOPS DETECTS A FATAL ERROR CONDITION: CHEOPS HALTS

;OPERATION IN "BUFFERRED" MODE.
;   BUFFERED MODE MAKES USE OF A PDP-11 MEMORY WHICH IS CONNECT ON THE UNIBUS
; WITH THE 10-11 INTERFACE AND THE UNIFACE. THIS MEMORY IS CURRENTLY 4096 WORDS.
; THE MEMORY IS (SOFTWARILY) SECTIONED INTO A PARAMETER AREA, A "RANDOM POSITION"
; AREA, AN A "POSITION BUFFER".  A STANDARD 100 (OCTAL) WORD BLOCK IS USED
; TO DESCRIBE EACH "INPUT" ARGUMENT TO CHEOPS.  CONTAINED WITHIN THIS BLOCK
; IS THE BOARD POSITION TOGETHER WITH ALL OTHER PARAMETERS AND DATA (INITIAL ALPHA
; AND BETA, DEPTH TO SEARCH, INITIAL FLAGWORD, SIDE-TO-MOVE, ETC ETC).
; THE "POSITION BUFFER"
; CONSISTS OF A FIXED NUMBER OF SUCH BLOCKS.  WHEN CHEOPS FINISHES WITH ONE
; SUCH BLOCK, IT STORES THE RESULTS BACK IN THE BLOCK, THEN ADVANCES TO THE
; NEXT BLOCK IN RING BUFFER FASHION.  EACH BLOCK HAS A STATEWORD WHICH REFLECTS
; ITS CURRENT STATUS (FREE, HOLDING ARGUMENT TO CHEOPS, OR HOLDING RESULT FROM CHEOPS).
;  THE PARAMETER AREA IS USED TO HOLD THE RING BUFFER POINTERS TO THE POSITION
; BUFFER.  ADDITIONALLY, CAPABILITY IS PROVIDED TO "INSERT" AN ARGUMENT BLOCK INTO
; THE NORMAL SEQUENCE DESCRIBED BY THE RING BUFFER.  THIS PARAMETER BLOCK WOULD
; BE STORED IN THE RANDOM POSITION BUFFER, AND IS PROCESSED ON A PRIORITY BASIS.
; (EVENTUALLY, CHEOPS WILL ACTUALLY INTERRUPT THE SEARCH IN PROGRESS, SAVE ITS STATE,
; AND BEGIN WORK ALMOST IMMEDIATELY ON THE NEW BLOCK.  LATER, IT WILL PICK UP WHERE
; IT LEFT OFF AND CONTINUE PROCESSING POSITIONS FROM THE POSITION BUFFER.)
;  BUFFERED MODE IS INITIATED BY UNIBUS COMMAND 2.  FROM THAT POINT, THE PROCESS
; IS CONTROLLED BY THE PARAMETER AREA AND THE FLAGWORDS IN THE ARGUMENT BLOCKS.

;  THE ARGUMENT BLOCK:
;     ;WD0  STATEWORD  0 -> BLOCK FREE
;     ;		       1 -> BLOCK CONTAINS CHEOPS RESULTS
;     ;		      -1 -> BLOCK CONTAINS CHEOPS ARGUMENTS
;     ;WD1  ALWAYS 0  (FOR CONVIENENCE OF PDP-10)
;     ;WD2  BITS AND MODES:
;     ;  100000 SIDE-TO-MOVE,  1 -> BLACK
;     ;   40000 ALPHA-CARRY-OVER-MODE, 1 -> INITIALIZE ALPHA FROM VALUE OF LAST SEARCH
;     ;   20000 BETA-CARRY-OVER-MODE,  1 ->    "        BETA  "
;     ;   10000 USE ALPHA AS DELTA AROUND CURRENT MATERIAL VALUE WHEN SETTING UP REAL
;     ;   	  ALPHA AND BETA
;     ;    4000 ASYMETRICAL A/B MODE.  ONCE IT IS VERIFIED STM IS NOT GETTING MATED,
;     ;		  AUTOMATICALLY GIVE HIM THE OPTION OF TAKING PCSATS + OR - 1.
;     ;		  THIS MODE IS USEFUL FOR OCM PMG AND PCG WHICH ARENT INTERESTED IN HOW
;     ;		  MUCH WORSE VALUE IS FOR STM UNLESS STM IS MATED.
;     ;WD3  DEPTH TO SEARCH (SETD)
;     ;WD4  INITIAL ALPHA
;     ;WD5  INITIAL BETA
;     ;WD6  INITIAL FLAGWORD
;     ;WD16 "RETURNED" STATA (LOW ORDER)
;     ;WD17 "RETURNED" STATB (HIGH ORDER)
;     ;WD20 RETURNED VALUE
;     ;WD21 INITIAL MATERIAL 
;     ;WD22-WD27 RETURNED PRINCIPLE VARIATION.
;     ;WD37 BEGINS PIECE LOCATION DESCRIPTION. 
;	     EACH WORD HAS PIECE NUMBER IN LEFT HALF, SQUARE IN RIGHT HALF
;	     LIST IS TERMINATED BY AN ALL ZERO WORD. SINCE THERE CAN BE 32 PIECES
;            MAX, THE ZERO MUST OCCUR BY WD77.
;	;PROMOTED PC TYPES-OF-WOOD?

;  THE PARAMETER AREA
;     ;WD0 ALWAYS 0
;     ;WD1 IF NOT 105, CHEOPS IS BEING USED FOR DEBUGGING, SPECIAL RUNS, ETC
;     ;   AND NOT LOOKING AT ALL THIS CRUFT.
;     ;WD2,WD3  PDP-10 SIDE PARAMETER AREA SOFTWARE LOCK.  IN NORMAL IDLE STATE,
;     ;   THESE ARE BOTH -1 (THUS -20 AS SEEN FROM 10).
;     ;   A PDP-10 PROCESS WISHING TO LOCK THESE PARAMETERS SHOULD DO:
;     ;   	MOVEI AC,20
;     ;		ADDB AC,<THIS LOCN>
;     ;   IF AC GETS 0, THE PROCESS HAS THE LOCK AND SHOULD STORE ITS PDP-10
;     ;   JOB NUMBER IN WDS 4 AND 5 FOR DEBUGGING PURPOSES.  OTHERWISE, BETTER
;     ;   LUCK NEXT TIME
;     ;WD4,WD5 SEE ABOVE
;     ;WD6,WD7 FILLING POINTER TO POSITION BUFFER
;     ;WD10,WD11 EMPTYING POINTER TO POSITION BUFFER (ADVANCED BY CHEOPS)
;     ;WD12,WD13 POINTER TO PRIORITY ARG BLOCK, 0 -> NONE

;  BACKGROUND - FOREGROUND HACKERY -- THE DOORBELL
;     THE DOORBELL IS A 4 BIT R/W REGISTER ACCESSIBLE TO THE UNIBUS.  IN ADDITION,
;  THE TOP BIT CAN BE TESTED  CONVENIENTLY BY CHEOPS VIA THE @DOORBELL CONDITION.
;  WHEN THE 10 WANTS TO BUZZ CHEOPS, IT WRITES INTO THE DOOBELL ONES IN THE LOW TWO
;  BITS PLUS A 2 BIT CODE AS DESIRED IN THE HIGH TWO BITS.  WHEN CHEOPS SENSES THE
;  LOW BIT SET, IT INTERRUPTS WHAT IT WAS DOING AND SAVES ITS STATE.
;  CHEOPS ACKNOWLEDGES RECEIPT OF THE COMMAND BY CLEARING THE LOW BIT OF THE DOORBELL.
;  AFTER HAVING COMPLETELY EXECUTED COMMAND, CHEOPS SIGNALS THE 10 OF THIS BY
;  CLEARING THE 2ND FROM LOW BIT IN THE DOORBELL REGISTER.  CHEOPS MEANWHILE, 
;  RESTORES THE SAVED STATE AND PICKS UP WHERE IT WAS WHEN INTERRUPTED.
;    THE DOORBELL COMMANDS SUPPORTED INITIALLY ARE COMMENCE FORGROUND SEARCH,
;  ABORT FORGROUND SEARCH AND ABORT BACKGROUND SEARCH.

;  THE POSITION BUFFER IS THE TOP 3/4 OF BUFFER MEMORY (2000-7777).
;     SINCE EACH ARGUMENT BLOCK IS 100 WORDS, THE POSITION BUFFER CAN HOLD
;     60 OCTAL ( 48.) BLOCKS.

;ON THE SIGNIFICANCE OF THE DEEP FLAG:
;    BIT 5 IN THE FLAGCELL REGISTER IS CALLED THE DEEP FLAG.
;     IT CAN BE SET AND CLEARED DIRECTLY BY FLAG-CONTROL OPERATIONS.
;     OF COURSE, IT IS ALSO LOADED WITH ALL THE OTHER BITS ON A
;	LOAD-FLAGCELL-FROM-NEXT-FLAGCELL OPERATION.
;   WHEN AN INITIALIZE-NEXT-FLAGCELL-WORD OPERATION IS DONE, BITS 15 THRU 4 OF
;	THE NEXT-FLAGCELL REGISTER ARE CLEARED.  BIT 5 IS NOT AFFECTED BY
;	SUBSEQUENT OPERATIONS, THUS BIT 5 OF THE FLAGCELL IS ALWAYS 0
;	WHEN REACHING <MOVE-OR-CAPTURE>-PLAYED.
;   IF IT IS DETERMINED THAT WDEPTH > DEEP-PARAMETER AND KCHK IS 0,
;       DEEP IS SET.  IN ANY CASE, THE PROGRAM PROCEEDS TO SEARCH CAPTURES
;       STARTING AT GENALLCAPT.  WHEN ALL CAPTURES ARE EXHAUSTED, DEEP IS
;	EXAMINED TO DETERMINE WHETHER THE DECISION WAS MADE TO ALSO LOOK AT MOVES.
;   WHEN RETURNING FROM A POSITION WITHOUT HAVING MADE A MOVE,
;	IT IS NOT A CHECKMATE OR STALEMATE UNLESS DEEP IS ZERO.

;ON KCHK VS F-C-BIT-KCHK ETC:
;   THE KCHK CONDITION CAN BE TESTED AT TWO DIFFERENT POINTS BY THE COND
;    MULTIPLEXOR.  HOWEVER, THEY ARE NOT THE SAME!!!  F-C-BIT-KCHK COMES
;    DIRECTLY OFF THE FLAGCELL REGISTER.  JUST KCHK IS A FLIP-FLOP WHICH
;    IS LOADED FROM F-C-BIT-KCHK.  THUS AFTER F-C-BIT-KCHK CHANGES,
;    KCHK CHANGES ON THE NEXT CLOCK.  KCHK SHOULD BE USED WHEN IT IS ASSURED
;    TO HAVE BEEN AT LEAST ONE CLOCK SINCE F-C-BIT-KCHK CHANGED, SINCE
;    THAT GIVES THE MICRO-ASSEMBLER GREATER FLEXIBILITY IN LAYING OUT STORAGE.
;   THE SAME RELATION HOLDS BETWEEN F-C-BIT-DEEP AND DEEP AND BETWEEN
;    F-C-BIT-LEGAL AND LEGAL.  IN THESE CASES, THO, THERE IS NO ADVANTAGE TO
;    USING THE NON F-C- TYPE ONES WHERE IT DOESNT MAKE ANY LOGICAL DIFFERENCE.

;A SPECIAL NOTE ON THE PAWN-MOVE CONDITION (AN THUS ON PROMOTE-MOVE)
;   THE HARDWARE USES THE MOFSEL LOGIC TO LOCATE THE MOVING PIECE.
;    IF DESTINATION-ARRAY IS SELECTED, MOVING PIECE IS ASSUMED TO COME FROM PR.
;				       DESTINATION SQUARE FROM SR.
;    IF ORIGIN-ARRAY IS SELECTED, MOVING PIECE IS ASSUMED TO COME FROM POUT.
;				       DESTINATION SQUARE FROM SIR.
;   THE SPECIAL POINT IS THAT FOR DESTINATION ARRAY, PAWN-MOVE DOES NOT
;    BECOME VALID UNTIL ONE CYCLE AFTER PR AND SR HAVE BEEN LOADED.

;STORAGE LAYOUT IN DATA-PDL MEMORY

; 0       NOT USED (HACKED WITH BY CONSOLE PROGRAM)
; 1-24    (ACTIVE-PDL-BLOCK-ORIGIN THRU ACTIVE-PDL-BLOCK-END)
;           ACTIVE VARIABLES
; 40-51   SAVED STATE OF AC S, AAC S, ETC, DURING FORGROUND SEARCH
;157-200  STORAGE OF PDL CONSTANTS (ASSIGNED BY CONSLP, THIS WORKS DOWN)
;300 ->   MOVE PDL, 4 WDS PER LEVEL OF RECURSION
;1600 -> 1677  (SAVED-PDL-BLOCK-ORIGIN THRU SAVED-PDL-BLOCK-END)
;	    SAVED COPY OF ACTIVE PDL BLOCK VARIABLES
;1700 -> 1777  SAVED BOARD POSITION.  IN PIECE,,SQUARE FORM.

;  FOR CONVENIENCE OF THE CONSOLE PROGRAM, THE MOVE PDL IS DEFINED TO BE BASED AT
;A LOCATION WHICH IS A MULTIPLE OF 4.  IT IS SOMETIMES REFERENCED UP TO +4(PAR).
;THUS, WHEN STATE-SAVING, 10 (FOR GOOD MEASURE) IS ADDED TO THE PAR AND THE RESULT
;ADJUSTED UPWARDS TO THE NEAREST MULTIPLE OF 4.
; 
;THE FOLLOWING ARE STATIC PARAMETER ASSIGNMENTS.
;THEY ARE READ IN AND EXECUTED AS A LISP FUNCTION.
& (PROG NIL 
   (CHEOPS-PARAMETERS 
	(DEFINE-AC WDEPTH 0)
	(DEFINE-AC ALPHA 1)
	(DEFINE-AC BETA 2)
	(DEFINE-AC MATERIAL 3)
	(DEFINE-AC VALUE 4)
	(DEFINE-AC TEMP 5)
	(DEFINE-AC NULL-SQUARE-AC 6)		;USED TO HOLD NULL-SQUARE AS CONSTANT
						;DATA. THIS MAKES IT POSSIBLE TO
						;INITIALIZE THE SR WITH AN ARRAY
						;INSTRUCTION.
	(DEFINE-AC TEMP1 7)			;USED ONLY DURING REVERT-PROMOTING-CAPT
						;AND CAPT-ILL-PROMOTING-CAPT,
						;AND REVERT-EP-CAPT
						;AND IN PV HACKERY
	(DEFINE-AAC PAR 0)
	(DEFINE-AAC C-LEFT-40 1)		;HOLDS CONSTANT 40 IN LEFT HALF
						;FOR USE DURING PROMOTION
	(DEFINE-AAC C-PLUS-10 2)		;CONSTANT FOR USE DURING EP CAPT
	(DEFINE-AAC C-MINUS-10 3)
	(DEFINE-AAC MATED-VALUE 4)
	(DEFINE-AAC PAR-SV 5)		;USED DURING PRINCIPLE VARIATION HACKING
	(DEFINE-AAC AAC-TO 6)		;USED DURING PDL-BLOCK BLTS IN SAVE RESTORE
	(DEFINE-AAC AAC-FROM 7)		; "    "

	(SET-CONSTANT PAWN-FILES 202)
	(SET-CONSTANT PAWN-FILES-1 203)
	(SET-CONSTANT WHITE-NULL-PAWN 220)
	(SET-CONSTANT WHITE-NULL-NOBLE-PIECE 240)
	(SET-CONSTANT WHITE-NULL-PROMOTED-PAWN 260)
	(SET-CONSTANT BLACK-NULL-PAWN 230)
	(SET-CONSTANT BLACK-NULL-NOBLE-PIECE 250)
	(SET-CONSTANT BLACK-NULL-PROMOTED-PAWN 270)

	(SET-CONSTANT NULL-SQUARE 200)

	(SET-CONSTANT W-KING-PIECE-INDEX 40)
	(SET-CONSTANT W-KR-PIECE-INDEX 42)
	(SET-CONSTANT W-QR-PIECE-INDEX 43)
	(SET-CONSTANT B-KING-PIECE-INDEX 50)
	(SET-CONSTANT B-KR-PIECE-INDEX 52)
	(SET-CONSTANT B-QR-PIECE-INDEX 53)

	(SET-CONSTANT BLACK-QUEEN-TYPE-WOOD 302)
	(SET-CONSTANT WHITE-QUEEN-TYPE-WOOD 202)
	(SET-CONSTANT WHITE-ROOK-TYPE-WOOD 203)
	(SET-CONSTANT WHITE-BISHOP-TYPE-WOOD 204)
	(SET-CONSTANT WHITE-KNIGHT-TYPE-WOOD 205)

	(SET-CONSTANT PAWN-VALUE 8.)	;THESE VALUES ARE ALL EVEN, TO ASSURE
	(SET-CONSTANT KNIGHT-VALUE 26.)	;THE BOARD VALUE IS ALWAYS EVEN. THIS
	(SET-CONSTANT BISHOP-VALUE 28.)	;ALLOW THE USE OF ODD NUMBERS FOR
	(SET-CONSTANT ROOK-VALUE 40.)	;DISTINGUISHABLE INITIAL ALPHA S AND BETA S.
	(SET-CONSTANT QUEEN-VALUE 70.)
	(SET-CONSTANT KING-VALUE 254.)

	(SET-CONSTANT QUEEN-MINUS-PAWN-VALUE 62.)

	(SET-CONSTANT WQR1 0)
	(SET-CONSTANT WQB1 2)
	(SET-CONSTANT WQ1 3)
	(SET-CONSTANT WK1 4)
	(SET-CONSTANT WKB1 5)
	(SET-CONSTANT WKN1 6)
	(SET-CONSTANT WKR1 7)
	(SET-CONSTANT BQR1 70)
	(SET-CONSTANT BQB1 72)
	(SET-CONSTANT BQ1 73)
	(SET-CONSTANT BK1 74)
	(SET-CONSTANT BKB1 75)
	(SET-CONSTANT BKN1 76)
	(SET-CONSTANT BKR1 77)

	(SET-CONSTANT DOORBELL-UNIBUS-ADR 177001)	;NOTE THIS A WORD ADR

    (SET-CONSTANT ACTIVE-PDL-BLOCK-ORIGIN 1)
     (SET-CONSTANT ACTIVE-PDL-BLOCK-ORIGIN-1 
	   (- ACTIVE-PDL-BLOCK-ORIGIN 1))
	(DEFINE-PDL-REGISTER DEEP-PARAMETER 1 2)
	(DEFINE-PDL-REGISTER MATED-CONSTANT 2 10000)
	(DEFINE-PDL-REGISTER ARG-BLOCK-ORIGIN 3 40000)
	(DEFINE-PDL-REGISTER PV00A  4 0)	;PRINCIPLE VARIATION FROM 0 PLY POS,
						; ELEM 0, WD A (PIECE-MOVED, ORIG)
	(DEFINE-PDL-REGISTER PV00B  5 0) 	;   "   , WD B (PIECE-CAPT, DEST)
	(DEFINE-PDL-REGISTER PV01A  6 0) 	; ELEM 1, WD A
	(DEFINE-PDL-REGISTER PV01B  7 0)	;   "   , WD B
	(DEFINE-PDL-REGISTER PV02A 10 0)	; ELEM 2, WD A
	(DEFINE-PDL-REGISTER PV02B 11 0)	;   "   , WD B
	(DEFINE-PDL-REGISTER PV10A 12 0)	;PRINCIPLE VARIATION FROM 1 PLY POS,
						; ELEM 0, WD A
	(DEFINE-PDL-REGISTER PV10B 13 0)	;   "   , WD B
	(DEFINE-PDL-REGISTER PV11A 14 0)	; ELEM 1, WD A
	(DEFINE-PDL-REGISTER PV11B 15 0)	;   "   , WD B
	(DEFINE-PDL-REGISTER PV20A 16 0)	;PRINCIPLE VARIATION FROM 2 PLY POS,
						; ELEM 0, WD A
	(DEFINE-PDL-REGISTER PV20B 17 0)	;   "   , WD B

	(DEFINE-PDL-REGISTER BITS-AND-MODES 20 0)  ;HOLDS COMMAND WD GIVING SAME ..
	(DEFINE-PDL-REGISTER INITIAL-MATERIAL 21 0);HOLDS INITIAL AC[MATERIAL]
  ;PDL-304, ETC ARE USED DURING PV HACKERY, EFFECTIVELY TO DETERMINE CURRENT PLY
  ;  DEPTH IN TREE. THEY ARE NORMALLY CONSTANT, BUT CAN BE CHANGED IF A BACKGROUND
  ;  SEARCH IS SUSPENDED TO RUN FOREGROUND.
	(DEFINE-PDL-REGISTER PDL-304 22 304)
	(DEFINE-PDL-REGISTER PDL-310 23 310)
	(DEFINE-PDL-REGISTER PDL-314 24 314)
    (SET-CONSTANT ACTIVE-PDL-BLOCK-END 24)
    (SET-CONSTANT SAVED-PDL-BLOCK-ORIGIN 1600)
      (SET-CONSTANT SAVED-PDL-BLOCK-ORIGIN-1 (- SAVED-PDL-BLOCK-ORIGIN 1))
      (SET-CONSTANT SAVED-PDL-BLOCK-END 
	   (+ SAVED-PDL-BLOCK-ORIGIN 
	      (- ACTIVE-PDL-BLOCK-END ACTIVE-PDL-BLOCK-ORIGIN)))

    (SET-CONSTANT SAVED-BOARD-PDL-ORIGIN 1700)

;FOLLOWING GROUP OF REGISTERS USED TO SAVE STATE OF MACHINE IN BACKGROUND 
;  (BLUNDER STOPPER) MODE WHEN SWITCHING TO FOREGROUND (STABILITY PRED) MODE.

  ;AC S
	(DEFINE-PDL-REGISTER S-WDEPTH 40 0)
	(DEFINE-PDL-REGISTER S-ALPHA  41 0)
	(DEFINE-PDL-REGISTER S-BETA   42 0)
	(DEFINE-PDL-REGISTER S-MATERIAL 43 0)
	(DEFINE-PDL-REGISTER S-VALUE  44 0)
;TEMP IS SCRATCH
;NULL-SQUARE-AC IS CONSTANT ...
;TEMP1 IS SCRATCH

  ;AAC S
	(DEFINE-PDL-REGISTER S-PAR 45 0)
;OTHERS ARE CONSTANT OR SCRATCH
  ;OTHER RANDOM REGISTERS
	(DEFINE-PDL-REGISTER S-STATA 46 0)
	(DEFINE-PDL-REGISTER S-STATB 47 0)
	(DEFINE-PDL-REGISTER S-FCELL 50 0)	;SAVED FLAGCELL
	(DEFINE-PDL-REGISTER S-STM   51 0)	;SAVED STM (SIGN-SET -> BLACK)

; NEXT 4 REGISTERS MUST BE IN THIS ORDER
	(SET-CONSTANT PDL-Q-VAL-REG 52)

	(DEFINE-PDL-REGISTER PDL-Q-VAL 52 70.)
	(DEFINE-PDL-REGISTER PDL-R-VAL 53 40.)
	(DEFINE-PDL-REGISTER PDL-B-VAL 54 28.)
	(DEFINE-PDL-REGISTER PDL-N-VAL 55 26.)

	(DEFINE-PDL-REGISTER PDL-TEM 201 0)
	(DEFINE-PDL-REGISTER ISOL-PWN-VAL 214 1)
	(DEFINE-PDL-REGISTER DBL-PWN-VAL 215 1)

;  PR SR SIR ALL SCRATCH AT SWITCHING TIME

	(SET-STARTING-ADDRESS GO)
)
	(RETURN T)
)

;Microcode Outline:

;INITIAL CONDITION, STM=STM
&(WHITE-TO-PLAY)
GO:		ALU:	O-BUS FROM IMMEDIATE-DATA[1],	;SIGNAL ALIVE
			-> STAR $
AWAIT-COMMAND:	ALU:	ALU-FCTN[SETZ], -> USP,
		     @PDP-11-FLAG-1+PDP-11-FLAG-0 
			AWAIT-COMMAND|BEGIN-SEARCH|BEGIN-BUFFERED-MODE|AWAIT-COMMAND $

BEGIN-SEARCH:	ALU:	O-BUS FROM IMMEDIATE-DATA[2],	;ACKNOWLEGE COMMAND TO BEGIN
			-> STAR 
		     @PUSHJ, GO1 $			; SEARCH
		ALU:	O-BUS FROM IMMEDIATE-DATA[4],	;SIGNAL SEARCH COMPLETED
			-> STAR $
AWAIT-RESET:	ALU:	-> HALT,
		     @PDP-11-FLAG-1+PDP-11-FLAG-0
			GO|AWAIT-RESET|AWAIT-RESET|AWAIT-RESET $

BEGIN-BUFFERED-MODE:
		ALU:	O-BUS FROM PDL[CONSTANT 20013],	; SEE IF PRIORITY BLOCK SET UP
			-> UAR 
		     @PUSHJ MEM-READ $		;RETURN WITH DATA IN UDR AND AC[TEMP]
		ALU:	O-BUS FROM AC[TEMP],
			-> PDL[ARG-BLOCK-ORIGIN] ;SAVE ADR OF ARG BLOCK WORKING ON
		     @O-BUS-15 BUF-MOD-1|BEGIN-BUFFERED-MODE $ ;POINTER NOT SET UP
BUF-MOD-1:	ALU:	O-BUS FROM AC[TEMP],
			-> UAR 
		     @PUSHJ MEM-READ $	;GET BUFFER STATE WORD FOR BLOCK
		ALU:	NO-OP			;STATE-WORD MUST BE -1 TO WIN
		     @ALU-EQUAL BEGIN-BUFFERED-MODE|BUF-MOD-2 $
BUF-MOD-2:	ALU:	NO-OP 			;LOAD BOARD AND PARAMETERS
		     @PUSHJ LOAD-POSITION $
		ALU:	O-BUS FROM IMMEDIATE-DATA[0]
			-> STATA $
		ALU:	O-BUS FROM IMMEDIATE-DATA[0]	;DO SEARCH
			-> STATB
		     @PUSHJ GO1 $
STORE-RESULT:	ALU:	O-BUS FROM PDL[ARG-BLOCK-ORIGIN],
			-> AC[TEMP] $
		ALU:	ALU-FCTN[+],
			B-BUS FROM AC[TEMP]		;ORIGIN OF ARG BLOCK
			A-BUS FROM IMMEDIATE-DATA[16]	;PLACE TO STORE RESULT
			-> UAR $
		ALU:	O-BUS FROM STATB	;SAVE HIGH ORDER STAT COUNTER
			-> AAC[PAR-SV] $	; SO IT WONT GET INCREMENTED EXCESSIVELY
		ALU:	O-BUS FROM STATA	;STORE LOW ORDER STAT COUNTER
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM ALU,		;STORE SAVED HIGH ORDER STAT COUNTER
			ALU-FCTN[SET-B],
			B-BUS FROM AAC[PAR-SV]
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM AC[VALUE],
			-> UDR 
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM AC[MATERIAL],	;STORE INITIAL MATERIAL
			-> UDR 				; (FOR COMPARISON PURPOSES)
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV00A]		;STORE PRINCIPLE VAR.
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV00B]
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV01A]
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV01B]
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV02A]
			-> UDR
		     @PUSHJ MEM-WRITE $
		ALU:	O-BUS FROM PDL[PV02B]
			-> UDR
		     @PUSHJ MEM-WRITE $
;RESULTS STORED SO RELEASE BLOCK
		ALU:	O-BUS FROM PDL[ARG-BLOCK-ORIGIN],
			-> UAR $
		ALU:	O-BUS FROM IMMEDIATE-DATA[1],
			-> UDR
		     @PUSHJ MEM-WRITE $
BUF-MOD-EXIT:	ALU:	NO-OP
		     @GO $

GO1:		ALU:	O-BUS FROM IMMEDIATE-DATA[300]
			-> AAC[PAR] $
		ALU:	ALU-FCTN[SET-A],		;STORE 40 IN LEFT HALF
			A-BUS FROM IMMEDIATE-DATA[40],	;IN C-LEFT-40
			O-BUS FROM ALU-SWAPPED,
			-> AAC[C-LEFT-40] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[10],
			-> AAC[C-PLUS-10] $
		ALU:	ALU-FCTN[SET-C-A],
			A-BUS FROM IMMEDIATE-DATA[7],
			-> AAC[C-MINUS-10] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[NULL-SQUARE],
			-> AC[NULL-SQUARE-AC] $
		ALU:	O-BUS FROM PDL[MATED-CONSTANT],
			-> AAC[MATED-VALUE] $
;MAYBE SET UP ALPHA/BETA IF IN THAT MODE, ETC
		ALU:	O-BUS FROM PDL[BITS-AND-MODES],
			-> AC[TEMP] $
		ALU:	ALU-FCTN[OR-C-A]
			B-BUS FROM AC[TEMP],
			A-BUS FROM PDL[CONSTANT 10000] $
		ALU:	O-BUS FROM AC[MATERIAL],	;SAVE A COPY FOR USE IN 
			-> PDL[INITIAL-MATERIAL] 	; ASYMETRICAL A/B MODE
		      @ALU-EQUAL GO-AB-2|GO-AB-1 $
GO-AB-1:	ALU:	ALU-FCTN[+],		;USE ALPHA AS DELTA AROUND CURRENT
			B-BUS FROM AC[MATERIAL],;MATERIAL VALUE 
			A-BUS FROM AC[ALPHA],
			-> AC[BETA] $
		ALU:	ALU-FCTN[-],
			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[ALPHA],
			-> AC[ALPHA] $
GO-AB-2:	ALU:	O-BUS FROM IMMEDIATE-DATA[0]
			-> AC[WDEPTH]
		      @STM WHITE-TAG LOOK-ALL-MOVES|BLACK-TAG LOOK-ALL-MOVES $
&T 
LOOK-ALL-MOVES:			;GETTING HERE WITH DEEP=0 WILL RESULT IN
				; LOOKING AT ALL MOVES
GENCAPT:	ARRAY:  DESTINATION-ARRAY, ORIG-ALL-SQUARES,
			ENABLE-ALL-PIECES, CAPTURE-MODE	;SEE IF ANY
			SQUARE-SCANNER FROM SR,		;CAPTS POSSIBLE
			PIECE-SCANNER FROM PR,
			PIECE-BUS FROM NEXT-PIECE $
GENC1:		ALU:
&(WHITE-TO-PLAY)	PDL[HW-CONST BLACK-NULL-NOBLE-PIECE NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST WHITE-NULL-NOBLE-PIECE NULL-SQUARE],
&T 						;WHILE WAITING, SET UP SQUARE
			-> PR-SR $		;SCANNER AND PIECE SCANNER
GENC2:		ARRAY-HOLD: GENCAPT
			SR FROM NEXT-SQUARE,
			SIR FROM PIECE-LOC,
			-> SIR			;LOCN OF MOST VALUABLE EXISTANT
						;PIECE. USEFUL IN CASE OF 
						;GENALLCAPT.
			-> SR			;LOCATION OF A CAPT. USEFUL IN
						;CASE OF GEN1CAPT, GEN2CAPT
		     @ANY-SQUARES GEN-MOVES|GENALLCAPT-NOBLE $

;GENC3:		ALU:	NO-OP			;NSCOUNT NOT SET UP IN TIME
;						;TO WIN AT GENC2
;		     @NSCOUNT SQ-CNT-ERR|GEN1CAPT|GEN2CAPT|<5>GENALLCAPT-NOBLE $

;SEE IF HIS MOST VALUABLE EXISTING PIECE, WHOSE LOCATION HAS BEEN PUT IN SIR,
;CAN BE CAPTURED.
GENALLCAPT-NOBLE:
		ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
			ENABLE-ALL-PIECES, CAPTURE-MODE
			PIECE-SCANNER FROM PR,
			PR FROM NEXT-PIECE,
			PIECE-BUS FROM NEXT-PIECE,
			SQUARE-SCANNER FROM SR,
			SQUARE-BUS FROM NEXT-SQUARE,
			SIR FROM PIECE-LOC,		;USEFUL IN INSTS THAT ARRAY
							;HERE
			-> PR				;PIECE LOOKING AT
;NOTE: THIS TEST OF A-M-P ONLY WINS BECAUSE NXP WAS SET UP ABOVE AT GENCAPT AND GENC1
		    @E-LONG ANY-MORE-PIECES FOO1|GEN-CN-2-TEST $  ;K HAD BETTER EXIST
;A-M-S ALSO SET UP EARLY FIRST TIME THRU
GEN-CN-2-TEST:	ARRAY-HOLD: GENALLCAPT-NOBLE,	;HAD BETTER NOT BE ANY CAPTS OF K
			-> SIR
			SR FROM NEXT-SQUARE,
			-> SR	;SAVE FOR DEBUGGING IF THERE'S A PC THAT CAN CAPT K
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @ANY-SQUARES GEN-CN-3|FOO1 $
GEN-CN-2:	ARRAY-HOLD: GENALLCAPT-NOBLE,
						;IF NO CAPTS OF THIS GUY,
			-> SIR			; START ARRAY LOOKING FOR CAPTS
						; OF NEXT GUY (THIS WILL BE
						; INVALID IF NEXT THRU (IE NO
						; NEXT GUY)
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-CN-3|PLAY-CAPT-NOBLE-1 $
				;TO N-3 IF NO MORE CAPTS OF THIS NOBLE.
				;TO NOBLE-1 IF SQUARE SCANNER HAS SQUARE FROM WHICH
				; A PIECE CAN COME TO CAPT THIS NOBLE.		
GEN-CN-3:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			PR FROM NEXT-PIECE,
			-> PR				;TO NEXT NOBLE
			A-BUS FROM AC[NULL-SQUARE-AC],
			SR FROM A-BUS,
			-> SR				;INITIALIZE SQUARE REG
		    @ANY-MORE-PIECES GENALLCAPT-PAWN|GEN-CN-4 $
				;TO -PAWN IF THRU WITH ALL CAPTURES OF PIECES
				;TO N-1 TO LOOK AT CAPTURES OF NEXT NOBLE.

;A-M-S STARTS GETTING VALID AFTER SR LOADED BY GEN-CN-3.
GEN-CN-4:	ALU:	NO-OP	;CLOCKS IN VALID A-M-S
		    @GEN-CN-2 $

;HIS PIECE IN PR WHICH IS LOCATED AT SQUARE IN SIR BEING CAPT ED BY
;OUR PIECE IN POUT WHICH IS LOCATED AT SQUARE IN NEXT-SQUARE.
;NEXT FLAGCELL WORD INITIALIZED.
PLAY-CAPT-NOBLE-1:
		ARRAY-HOLD: GENALLCAPT-NOBLE,
			SR FROM NEXT-SQUARE,
			-> SR,
			SQUARE-BUS FROM NEXT-SQUARE,
			PS-BUS FROM POUT--SQUARE-BUS,
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR],
		    @PUSHJ,PLAY-CAPT-2 $
		;CALL PLAY CAPT 2 TO COMPLETE CAPT PLAYING, INVESTIGATION,
		;REVERTING, A-B TEST, AND MINI-MAX.
		;  IF A-B CUTOFF, FLUSH THIS RETURN FROM STACK 
		;	AND RETURN FROM POSITION.
		;  IF NOT, DO MINIMAX AND RETURN.
		;	ON RETURN, PR, SR, SIR, ORIGIN-ARRAY, DEST-FROM-SIR,
		;	AND ENABLE-ALL-PIECES HAVE BEEN RESTORED, AND
		;	LONG ENUF AGO THAT ANY-MORE-SQUARES HAS REGENERATED
		;	ITSELF.
PLAY-CAPT-NOBLE-2:
		ARRAY-HOLD: GENALLCAPT-NOBLE,
			-> SIR
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-CN-3|PLAY-CAPT-NOBLE-1 $


;FIRST WD PIECE-MOVED,,ORIGIN  ALREADY ON PDL.
;NEXT-FLAGCELL INITIALIZED.
PLAY-CAPT-2:	ARRAY:	ORIGIN-ARRAY,		;SO FLAG-CONTROL WILL WIN.
			SQUARE-BUS FROM SR,
			PS-BUS FROM POUT--SQUARE-BUS,
			-> AC[TEMP],		;SAVE PIECE DOING THE CAPTURING (POUT)
			PIECE-BUS FROM PR,
			ZERO-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			FLAG-CONTROL[SAVE-NEXT-GHOST-POSITION] $
;NOTE: POUT MUST BE SAVED BECAUSE IT IS NOT A REGISTER, MERELY THE OUTPUT
;   OF A MEMORY WHICH WILL CHANGE IF ITS ADDRESS INPUT CHANGES.
;   FURTHERMORE THE OUTPUT OF THE POUT MEMORY GOES AWAY WHEN THE
;   MEMORY IS WRITE-ENABLED. THUS IT IS NOT POSSIBLE TO WRITE IN POUT
;   AND READ OUT THE PREVIOUS DATA ON THE SAME U-INST.  THIS IS WHY
;   IT WOULD NOT WIN TO SAVE POUT IN UINST PLAY-CAPT-2A.
PLAY-CAPT-2A:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			PS-BUS FROM PR--SIR,	;PUSH PIECE-CAPT,,DESTINATION
			-> PDL-POINTED-TO-BY-PAR,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,		;CLEAR ORIGIN SQUARE
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
			PAF[+1 -> PAR] 
		   @PROMOTE-MOVE+E-P-CAPT
			 PLAY-CAPT-3|PLAY-EP-CAPT|PLAY-PROMOTING-CAPT|PLAY-CAPT-ERR $
;NOTE: CAPT TYPE BITS WERE SET UP AT END OF PREVIOUS INSTRUCTION, SO
;IT IS OK TO DISPATCH ON THEM NOW.
PLAY-CAPT-3:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SET UP TO SEE  
			ENABLE-ALL-PIECES, CAPTURE-MODE,	;IF WE ARE 
			SQUARE-BUS FROM SIR,			;CHECKING HIM
			A-BUS FROM AC[TEMP],
			PIECE-BUS FROM LEFT-A-BUS,
			SQUARE-SCANNER FROM HIS-K-LOCN,
			-> WMOVE,	;PUT MOVING PIECE ON DESTINATION SQUARE.
			SET-PIECE-EXISTS-BIT,		;THIS ALREADY SET UNLESS 
			-> PIECE-EXISTS-REGISTER,	; PROMOTION
			PS-BUS FROM FLAGCELL,		;PUSH CURRENT FLAGS
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
		   @E-LONG KCHK PLAY-CAPT-4|PLAY-CAPT-4A $ ;E-LONG BECAUSE AC S->WMOVE
			;INCR WDEPTH UNLESS WE ARE IN CHECK IN CURRENT POSITION.
PLAY-CAPT-4:	ALU:	ALU-FCTN[+],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH]
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE]
		   @E-LONG PLAY-CAPT-5 $	;TO ALLOW SELECTED-SQUARE TO SET UP
PLAY-CAPT-5:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;START SEEING
			ENABLE-ALL-PIECES, CAPTURE-MODE,	;IF THIS MOVE 
			SQUARE-SCANNER FROM HIS-K-LOCN,		;WAS LEGAL PLACE
			PIECE-BUS FROM PR,
			PS-BUS FROM PIECE-VALUE,
			FLAG-CONTROL[LOAD-FLAGCELL-FROM-NEXT-FLAGCELL]  $
PLAY-CAPT-6:	ALU:   
&(WHITE-TO-PLAY)	O-BUS FROM AC[BETA]	;PUSH ALPHA-BETA VARIABLE
&(BLACK-TO-PLAY)	O-BUS FROM AC[ALPHA]	;PUSH THE ONE HE S ABOUT TO CLOBBER
&T 			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]
		   @PUSHJ PLAY-CAPT-7 $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING AT FLAGCELL WORD
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL
REVERT-CAPT-1:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-1 -> PAR] $	;INDEX TO PIECE-CAPT,,DESTINATION
REVERT-CAPT-2:	ARRAY:	PIECE-BUS FROM A-BUS,
			SQUARE-BUS FROM A-BUS,
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PR FROM A-BUS,
			-> PR,
			SIR FROM SQUARE-BUS,
			-> SIR,
			PS-BUS FROM PIECE-VALUE
			-> AC[TEMP] 		;SAVE VALUE OF CAPTED PIECE
						;(SO CAN RESTORE AC[MATERIAL]
						; CLEVERLY)
			SET-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			-> WMOVE,		;PUT PIECE CAPT BACK
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]
			PAF[-1 -> PAR]		;INDEX TO PIECE-MOVED,,ORIG
		   @E-LONG REVERT-CAPT-3 $	;BECAUSE PDL -> WMOVE
REVERT-CAPT-3:	ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,		;START GETTING READY
			ENABLE-ALL-PIECES, CAPTURE-MODE,	;TO LOOK FOR MORE
			SQUARE-SCANNER FROM SR,			;CAPTS OF THIS PIECE.
			PIECE-SCANNER FROM PR,
			PIECE-BUS FROM A-BUS,
			SQUARE-BUS FROM A-BUS,
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			SR FROM A-BUS,
			-> SR,
			-> WMOVE,
			SET-PIECE-EXISTS-BIT,		;WILL ALREADY BE SET UNLESS
			-> PIECE-EXISTS-REGISTER,	;REVERTING A PROMOTING CAPTURE
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION],
			PS-BUS FROM PR--SIR,	;THIS MATTERS ONLY IF EP CAPT
		   @E-LONG KCHK REVERT-CAPT-3A|REVERT-CAPT-4A $	;BECAUSE PDL->WMOVE
;E-P-CAPT STARTS GETTING VALID AFTER SR LOADED
REVERT-CAPT-3A:	ARRAY-HOLD: REVERT-CAPT-3 
			SQUARE-BUS FROM SR, $		;CLOCK IN VALID E-P-CAPT
REVERT-CAPT-4:	ALU:	ALU-FCTN[-],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1]
			-> AC[WDEPTH]
		   @PROMOTE-MOVE+E-P-CAPT
			 REVERT-CAPT-5|REVERT-EP-CAPT|REVERT-PROMOTING-CAPT|REVERT-CAPT-ERR $
REVERT-CAPT-5:
REVERT-C-A-B:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[VALUE],
&(WHITE-TO-PLAY)	A-BUS FROM AC[BETA],
&(BLACK-TO-PLAY)	A-BUS FROM AC[ALPHA],
&T			 $
REVERT-C-A-B-1:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[VALUE],
&(WHITE-TO-PLAY)	A-BUS FROM AC[ALPHA],
		   @ALU-LESS REVERT-C-A-B-CUT|REVERT-C-BSF-TEST  
&(BLACK-TO-PLAY)	A-BUS FROM AC[BETA],
		   @ALU-LESS-OR-EQUAL REVERT-C-BSF-TEST|REVERT-C-A-B-CUT 
&T			 $		;CUT ON ALU BETTER FOR ME
REVERT-C-BSF-TEST:
		ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[-],
&(BLACK-TO-PLAY)	ALU-FCTN[+],
&T			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[TEMP],
			-> AC[MATERIAL],
&(WHITE-TO-PLAY)   @ALU-LESS-OR-EQUAL REVERT-C-NEW-BSF|TAG-IN-GENERATION 0 CPOPJ  
&(BLACK-TO-PLAY)   @ALU-LESS TAG-IN-GENERATION 0 CPOPJ|REVERT-C-NEW-BSF
&T			 $
REVERT-C-NEW-BSF:			;ALSO GET HERE FROM REVERT-M-BSF-TEST
		ALU:	ALU-FCTN[B-A-1],	;TEST IF IN TOP 3 PLIES
			B-BUS FROM PAR,
			A-BUS FROM PDL[PDL-314] $
		ALU:	O-BUS FROM AC[VALUE],
&(WHITE-TO-PLAY)	 -> AC[ALPHA],
&(BLACK-TO-PLAY)	 -> AC[BETA],
&T @ALU-LESS TAG-IN-GENERATION 0 CPOPJ|TAG-IN-GENERATION 0 REVERT-SAVE-PV $

&(WHITE-TO-PLAY)	;ONLY NEED ONE COPY THIS CODE
REVERT-SAVE-PV:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM PAR,
			A-BUS FROM PDL[PDL-310] 
			PAF[ PAR -> PAR-SV], $
R-S-PV-1:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,	;PIECE-MOVED,,ORIG
			-> AC[TEMP1],
			PAF[+1 -> PAR],			;INDEX TO PIECE-CAPT,,DEST 
		   @ALU-LESS R-PV-3RD-PLY|R-S-PV-2 $
R-S-PV-2:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM PAR,
			A-BUS FROM PDL[PDL-304] $
		ALU:	NO-OP,
		   @ALU-LESS R-PV-2ND-PLY|R-PV-1ST-PLY $

R-PV-3RD-PLY:	ALU:	O-BUS FROM AC[TEMP1],
			-> PDL[PV20A] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1],
			-> PDL[PV20B],
			PAF[ PAR-SV -> PAR]
		   @POPJ $
R-PV-2ND-PLY:	ALU:	O-BUS FROM AC[TEMP1],
			-> PDL[PV10A] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1],
			-> PDL[PV10B] $
		ALU:	O-BUS FROM PDL[PV20A],
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1],
			-> PDL[PV11A] $
		ALU:	O-BUS FROM PDL[PV20B],
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			->PDL[PV11B],
			PAF[ PAR-SV -> PAR]
		   @POPJ $
			
R-PV-1ST-PLY:	ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV00A] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV00B] $
		ALU:	O-BUS FROM PDL[PV10A]
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV01A] $
		ALU:	O-BUS FROM PDL[PV10B]
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV01B] $
		ALU:	O-BUS FROM PDL[PV11A]
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV02A] $
		ALU:	O-BUS FROM PDL[PV11B]
			-> AC[TEMP1] $
		ALU:	O-BUS FROM AC[TEMP1]
			-> PDL[PV02B],
			PAF[ PAR-SV -> PAR] $
		ALU:	O-BUS FROM PDL[BITS-AND-MODES]
			-> AC[TEMP1] $
		ALU:	ALU-FCTN[OR-C-A]
			B-BUS FROM AC[TEMP1]
			A-BUS FROM PDL[CONSTANT 4000] $
		ALU:	O-BUS FROM PDL[BITS-AND-MODES]	;FOR TEST AT A-A-B
		  @ALU-EQUAL TAG-IN-GENERATION 0 CPOPJ|ASYMMETRICAL-A-B $

;ASYMMETRICAL ALPHA BETA MODE:
;  THE 4000 BIT IN BITS-AND-MODES, IF 1, SPECIFIES ASYMMETRICAL A-B MODE.
;THE IDEA IS TO ACCURATELY DETERMINE IF THE TOP-LEVEL STM IS MATED, BUT ONCE
;IT IS CLEAR THAT HE IS NOT, TO DISCARD INFORMATION ABOUT <HOW MUCH> WORSE
;THE TRUE VALUE IS FOR THE STM BEYOND THE FACT IT IS WORSE.  THIS CORRESPONDS TO
;ALLOWING THE STM TO "TAKE" A VALUE OF INITIAL-MATERIAL + OR - 1 (DEPENDING ON SIDE)
;ONCE IT IS CLEAR HE HAS ANY OTHER NON-MATE OPTION AT THE TOPMOST LEVEL.
;  THE MOTOVATION FOR WANTING THIS PARTICULAR FUNCTION IS THAT IN "INTEGRATED"
;SEARCHES, OCM CANT MAKE ANY USE OF THE HOW-MUCH INFO BEYOND THE MATED VS NOT-MATED
;AND WORSE-FOR-STM VS NOT-WORSE-FOR-STM BITS.  FURTHERMORE, THIS MODE SHOULD SAVE
;CONSIDERABLE TIME IN CHEOPS ESPECIALLY WHERE THE FIRST MOVE LOOKED AT BY CHEOPS
;HAPPENS TO BE A BLUNDER.
ASYMMETRICAL-A-B:
		ALU:	O-BUS FROM PDL[INITIAL-MATERIAL] ;CONDITIONAL UPON
			-> AC[TEMP1]			 ; STM TO MOVE AT TOPMOST LVL
		   @ALU-LESS A-A-B-W|A-A-B-B $

A-A-B-W:	ALU:	ALU-FCTN[B-A-1]
			B-BUS FROM AC[VALUE]
			A-BUS FROM PDL[CONSTANT -7040] $	;- MATED-CONSTANT + 40
		ALU:	ALU-FCTN[B-A-1]		;SET UP TEST ON DOES HE WANT OPTION 
			B-BUS FROM AC[ALPHA]	; ANYWAY FOR NEXT TIME
			A-BUS FROM PDL[INITIAL-MATERIAL]
   ;POPJ ON THIS VALUE IS MATE. -> NO OPTION
		   @ALU-LESS-OR-EQUAL A-A-B-W-1|TAG-IN-GENERATION 0 CPOPJ $
A-A-B-W-1:	ALU:	NO-OP
		   @ALU-LESS TAG-IN-GENERATION 0 CPOPJ|A-A-B-W-2 $
A-A-B-W-2:	ALU:	ALU-FCTN[DEC-B]		;GOBBLE OPTION
			B-BUS FROM AC[TEMP1]
			-> AC[ALPHA]
		   @POPJ $

A-A-B-B:	ALU:	ALU-FCTN[B-A-1]
			B-BUS FROM AC[VALUE]
			A-BUS FROM PDL[CONSTANT 7040] $		; MATED-CONSTANT - 40
		ALU:	ALU-FCTN[B-A-1]
			B-BUS FROM AC[BETA]
			A-BUS FROM PDL[INITIAL-MATERIAL]
		   @ALU-LESS TAG-IN-GENERATION 0 CPOPJ|A-A-B-B-1 $
A-A-B-B-1:	ALU:	NO-OP
		   @ALU-LESS-OR-EQUAL A-A-B-B-2|TAG-IN-GENERATION 0 CPOPJ $
A-A-B-B-2:	ALU:	ALU-FCTN[+],
			B-BUS FROM AC[TEMP1]
			A-BUS FROM IMMEDIATE-DATA[1]
			-> AC[BETA]
		   @POPJ $	
&T 

REVERT-CAPT-4A:	ARRAY-HOLD: REVERT-CAPT-3
			SQUARE-BUS FROM SR, $
		ALU:	NO-OP
		   @PROMOTE-MOVE+E-P-CAPT 
			REVERT-CAPT-5|REVERT-EP-CAPT|REVERT-PROMOTING-CAPT|REVERT-CAPT-ERR $

PLAY-CAPT-7:	ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[+],
&(BLACK-TO-PLAY)	ALU-FCTN[-],
&T 			B-BUS FROM AC [MATERIAL],
			A-BUS FROM PS-BUS,
			-> AC [MATERIAL],
		   @SELECTED-SQUARE OTHER-SIDE-TAG CAPT-PLAYED|CAPT-ILLEGAL $
CAPT-PLAYED:	ALU:	NO-OP, @PUSHJ TAG-IN-GENERATION 0  PAWN-STR-FCTN $
			; RETURN FUNCTION IN TEMP1
		ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		   @KCHK CAPT-PLAYED-1|LOOK-ALL-MOVES $
CAPT-PLAYED-1:		ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[TEMP1],
&(WHITE-TO-PLAY)	A-BUS FROM AC[BETA],
&(BLACK-TO-PLAY)	A-BUS FROM AC[ALPHA],
&T 		   @ALU-LESS LOOK-CAPTS-ONLY|LOOK-ALL-MOVES $
LOOK-CAPTS-ONLY:
		ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[TEMP1],
&(WHITE-TO-PLAY)	A-BUS FROM AC[ALPHA],
		   @ALU-LESS A-B-CUT-V-MAT|LOOK-CAPTS-ONLY-1 
&(BLACK-TO-PLAY)	A-BUS FROM AC[BETA],
		   @ALU-LESS-OR-EQUAL LOOK-CAPTS-ONLY-1|A-B-CUT-V-MAT
&T 			 $
LOOK-CAPTS-ONLY-1:					;THIS INSTRUCTION REACHED FROM
		ARRAY-HOLD:GENCAPT			;PLAY-MOVE TOO
;--SHOULD BE DOING USEFUL WORK WITH THIS INST
			FLAG-CONTROL[SET-DEEP],
&(WHITE-TO-PLAY)   @ALU-LESS-OR-EQUAL LOOK-CAPTS-NEW-BSF|GENC1 
&(BLACK-TO-PLAY)   @ALU-LESS GENC1|LOOK-CAPTS-NEW-BSF
&T 			 $
LOOK-CAPTS-NEW-BSF:
		ALU:
			O-BUS FROM AC[TEMP1],
&(WHITE-TO-PLAY)	 -> AC[ALPHA],
&(BLACK-TO-PLAY)	 -> AC[BETA],
&T 		   @GENC1 $

PLAY-CAPT-4A:	ALU:	NO-OP			;ALLOW KCHK TO SET UP
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE]
		   @E-LONG PLAY-CAPT-5 $	;EVEN LONGER FOR KCHK

CAPT-ILLEGAL:	ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[-],
&(BLACK-TO-PLAY)	ALU-FCTN[+],
&T 			B-BUS FROM AC [MATERIAL],
			A-BUS FROM PS-BUS,
			-> AC[MATERIAL]
			PAF[-2 -> PAR]		;MUST POP FIRST.
						;SKIP OVER SAVED A-B WORD TEMPORARILY
		   @POP-USP CAPT-ILL-2 $	;WON'T NEED RETURN TO A-B HACKER, ETC
;PUSHJ AND POPJ BIT BOTH SET SOS ES USP, DOES NOT AFFECT PC
CAPT-ILL-2:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-1 -> PAR] $
CAPT-ILL-3:	ARRAY:	PIECE-BUS FROM A-BUS,
			SQUARE-BUS FROM A-BUS,
			A-BUS FROM PDL-POINTED-TO-BY-PAR,  ;POP PIECE-CAPT,,DESTINATION
			PR FROM A-BUS,
			-> PR,
			SIR FROM SQUARE-BUS,
			-> SIR,
			SET-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			-> WMOVE,		;PUT PIECE CAPTURED BACK
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]
			PAF[-1 -> PAR]
		    @E-LONG CAPT-ILL-4 $	;BECAUSE PDL -> WMOVE
CAPT-ILL-4:	ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,	;GET STARTED GETTING READY
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM SR,
			PIECE-SCANNER FROM PR,
			PIECE-BUS FROM A-BUS,		;TO LOOK FOR MORE CAPTS OF
			SQUARE-BUS FROM A-BUS,		;THIS PIECE
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			SR FROM A-BUS,
			-> SR,
			-> WMOVE,
			PS-BUS FROM PR--SIR,		;THIS ONLY FOR EP CAPT
			SET-PIECE-EXISTS-BIT,		;THIS ALREADY SET UNLESS
			-> PIECE-EXISTS-REGISTER,	; PROMOTING CAPTURE
		    @E-LONG KCHK CAPT-ILL-5|CAPT-ILL-5A $	;BECAUSE PDL->WMOVE
CAPT-ILL-5:	ARRAY-HOLD: CAPT-ILL-4
			SQUARE-BUS FROM SR $	;CLOCK IN VALID E-P-CAPT
		ALU:	ALU-FCTN[-],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH]
		    @PROMOTE-MOVE+E-P-CAPT 
   TAG-IN-GENERATION 0 CPOPJ|CAPT-ILL-EP-CAPT|CAPT-ILL-PROMOTING-CAPT|CAPT-ILL-ERR $

CAPT-ILL-5A:	ARRAY-HOLD: CAPT-ILL-4
			SQUARE-BUS FROM SR $
		ALU:	NO-OP
		    @PROMOTE-MOVE+E-P-CAPT 
   TAG-IN-GENERATION 0 CPOPJ|CAPT-ILL-EP-CAPT|CAPT-ILL-PROMOTING-CAPT|CAPT-ILL-ERR $


;COME HERE FROM GENALLCAPT-NOBLE WITH INVERSE ARRAY CONFIGURED TO
;FIND CAPTS OF PIECE COMMING FROM PIECE SCANNER
GENALLCAPT-PAWN:
		ALU:
&(WHITE-TO-PLAY)	PDL[HW-CONST BLACK-NULL-PAWN NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST WHITE-NULL-PAWN NULL-SQUARE],
&T 			-> PR-SR $
GEN-CP-1:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			PR FROM NEXT-PIECE,
			-> PR,			;FIRST PAWN OR GARBAGE
			PIECE-BUS FROM NEXT-PIECE,
			SIR FROM PIECE-LOC,
			-> SIR $		;ITS LOCN OR GARBAGE
GEN-CP-1A:	ALU:	NO-OP 		;XFER AWAY ON PREV INST LOADED GARBAGE
		    @E-LONG ANY-MORE-PIECES GENALLCAPT-PROM-PAWN|GEN-CP-2 $
;--CONFIRMED E-LONG BECAUSE OF A-M-S
;FIRST TIME THRU, ENTIRE ARRAY SETTLING MUST HAPPEN DURING THIS U-INST SO E-LONG
GEN-CP-1B:	ALU:	NO-OP
		    @ANY-MORE-PIECES GENALLCAPT-PROM-PAWN|GEN-CP-2$
;REST OF THE TIME, SIR WAS LOADED FULL U-INST AGO, SO NO E-LONG
GEN-CP-2:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			-> SIR
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-CP-3|PLAY-CAPT-PAWN-1 $
GEN-CP-3:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			PR FROM NEXT-PIECE,
			-> PR
			A-BUS FROM AC[NULL-SQUARE-AC],
			SR FROM A-BUS,
			-> SR
		    @ANY-MORE-PIECES GENALLCAPT-PROM-PAWN|GEN-CP-1B $
PLAY-CAPT-PAWN-1:
		DUPLICATE-OP: PLAY-CAPT-NOBLE-1	;LOAD SR, PUSH FIRST WD OF MOVE
		    @PUSHJ,PLAY-CAPT-2 $
PLAY-CAPT-PAWN-2:
		DUPLICATE-OP: PLAY-CAPT-NOBLE-2	
		    @INHIBIT-WRITE-IF-BRANCH,	;OF PR
			ANY-MORE-SQUARES GEN-CP-3|PLAY-CAPT-PAWN-1 $

;GENERATE CAPTS OF HIS PROMOTED PAWNS
GENALLCAPT-PROM-PAWN:
		ALU:
&(WHITE-TO-PLAY)	PDL[HW-CONST BLACK-NULL-PROMOTED-PAWN NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST WHITE-NULL-PROMOTED-PAWN NULL-SQUARE],
&T 			-> PR-SR $
GEN-CPP-1:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			PR FROM NEXT-PIECE,	;FIRST PROMOTED P OR GARBAGE IF NONE
			-> PR,
			PIECE-BUS FROM NEXT-PIECE,
			SIR FROM PIECE-LOC,	;ITS LOCN OR GARBAGE
			-> SIR $
GEN-CPP-1A:	ALU:	NO-OP 	;XFER AWAY ON PREV INST LOADED GARBAGE
		     @E-LONG ANY-MORE-PIECES GEN-MOVES|GEN-CPP-2 $
;SEE COMMENT AT GEN-CP-1A  CONFIRMED E-LONG
GEN-CPP-1B:	ALU:	NO-OP
		     @ANY-MORE-PIECES GEN-MOVES|GEN-CPP-2 $
GEN-CPP-2:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			-> SIR
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		     @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-CPP-3|PLAY-PROM-PAWN-CAPT-1 $
GEN-CPP-3:	ARRAY-HOLD: GENALLCAPT-NOBLE,
			PR FROM NEXT-PIECE,
			-> PR
			A-BUS FROM AC[NULL-SQUARE-AC],
			SR FROM A-BUS,
			-> SR
		     @ANY-MORE-PIECES GEN-MOVES|GEN-CPP-1B $ 

PLAY-PROM-PAWN-CAPT-1:
		DUPLICATE-OP: PLAY-CAPT-NOBLE-1	;LOAD SR, PUSH FIRST WD OF MOVE
		     @PUSHJ, PLAY-CAPT-2 $
PLAY-PROM-PAWN-CAPT-2:
		DUPLICATE-OP: PLAY-CAPT-NOBLE-2	
		     @INHIBIT-WRITE-IF-BRANCH,		;OF PR
			ANY-MORE-SQUARES GEN-CPP-3|PLAY-PROM-PAWN-CAPT-1 $

;PIECE SCANNER SELECTED FROM PR, PIECE BUS FROM NEXT-PIECE
GEN-MOVES:	ALU:	
&(WHITE-TO-PLAY)	PDL[HW-CONST WHITE-NULL-PAWN NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST BLACK-NULL-PAWN NULL-SQUARE],
&T 			-> PR-SR 
		     @DEEP GEN-PAWN-MOVES-1|RETURN-VALUE $	;GENERATE MOVES ONLY IF
								;NOT DEEP
;A-M-P STARTS GETTING VALID AFTER PR LOADED BY THIS INST
GEN-PAWN-MOVES-1:
		ARRAY:	DESTINATION-ARRAY, ORIG-FROM-SIR,
			ENABLE-ALL-PIECES, MOVE-MODE,
			SQUARE-SCANNER FROM SR,
			PIECE-SCANNER FROM PR,
			PIECE-BUS FROM NEXT-PIECE,
			SIR FROM PIECE-LOC,	;LOCN OF OUR FIRST P
			-> SIR 			;(OR GARBAGE IF NONE)
			PR FROM NEXT-PIECE,	;LIKEWISE, GET GARBAGE OR
			-> PR $			;PIECE NUMBER INTO PR
;THIS INST CLOCKS THE VALID A-M-P INTO FLAGWORD
;A-M-S AND NEXT-SQUARE START GETTING VALID AFTER SIR LOADED BY THIS INST.
GEN-PAWN-MOVES-2A:
		ALU:	NO-OP 
		     @E-LONG ANY-MORE-PIECES GEN-NOBLE-MOVES|GEN-PAWN-MOVES-3 $
;ENTIRE ARRAY CYCLE HAPPENS DURING THIS INST.
;  HOWEVER, WE KNOW NO SLIDING PCS ARE IN ORIGIN AREA.
;THIS INST CLOCKS VALID A-M-S INTO FLAGWORD
GEN-PAWN-MOVES-2B:
		ALU:	NO-OP 
		     @ANY-MORE-PIECES GEN-NOBLE-MOVES|GEN-PAWN-MOVES-3 $
GEN-PAWN-MOVES-3:
		ARRAY-HOLD: GEN-PAWN-MOVES-1
			SR FROM NEXT-SQUARE,
			-> SR,
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		     @ANY-MORE-SQUARES GEN-PAWN-MOVES-4|PLAY-PAWN-MOVE-1 $
;NOT NECESSARY (HOPEFULLY) TO PLAY INHIBIT-WRITE-IF-BRANCH GAME BECAUSE
; ARRAY GENERATES PAWN MOVES QUICKLY (NO SLIDING ACTION).
GEN-PAWN-MOVES-4:
		ARRAY-HOLD: GEN-PAWN-MOVES-1
			-> SIR			;LOC OF NEXT PIECE
			PR FROM NEXT-PIECE,
			-> PR			;ADVANCE TO NEXT PIECE
			A-BUS FROM AC[NULL-SQUARE-AC],
			-> SR			;INITIALIZE SQARE REG
		     @ANY-MORE-PIECES GEN-NOBLE-MOVES|GEN-PAWN-MOVES-2B $
;PIECE TO MOVE IN PR.
;ITS LOCATION IN SIR,  SQUARE TO MOVE TO IN SR.
;NEXT-FLAGCELL INITIALIZED.
;NOTE THAT PR AND SR MUST BE VALID BEFORE THIS INST SO THAT THE PROMOTE-MOVE
;  CONDITION TESTED BY PLAY-MOVE-2 WILL BE VALID
PLAY-PAWN-MOVE-1:
		ARRAY-HOLD: GEN-PAWN-MOVES-1
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SIR,
			-> WMOVE,		;CLEAR ORIGIN SQUARE
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
		    @PUSHJ RETURN-TARGET GEN-PAWN-MOVES-3, PLAY-MOVE-2 $
;ON RETURN, SR AND SIR HAVE BEEN SET FOR SEVERAL INSTS WHILE MOVE WAS REVERTED

PLAY-MOVE-2:	ARRAY:	DESTINATION-ARRAY,		;SO FLAG LOGIC WILL KNOW WHERE
							;TO GET STUFF FROM
			SQUARE-BUS FROM SR,
			PIECE-BUS FROM PR,
			-> WMOVE,			;PUT PIECE ON DESTINATION SQUARE
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,	;PUSH PIECE-MOVED,,ORIGIN
			PAF[+1 -> PAR]
	FLAG-CONTROL [SAVE-NEXT-GHOST-POSITION-AND-MODIFY-NEXT-CASTLE-FLAGS]
		   @PROMOTE-MOVE PLAY-MOVE-3|PLAY-PROMOTING-MOVE $
PLAY-MOVE-3:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF CHECKING HIM
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM HIS-K-LOCN,
			SQUARE-BUS FROM SR,
			PIECE-BUS FROM NULL-PIECE,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS
			-> PDL-POINTED-TO-BY-PAR,	;PUSH PIECE CAPT (IE NULL)
			PAF [+1 -> PAR]			;DESTINATION
		   @KCHK PLAY-MOVE-4|PLAY-MOVE-4A $
PLAY-MOVE-4:	ALU:	ALU-FCTN[+],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[+1],
			-> AC[WDEPTH],
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE] $
PLAY-MOVE-5:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF MOVE LEGAL IN
			ENABLE-ALL-PIECES, CAPTURE-MODE,	;FIRST PLACE
			SQUARE-SCANNER FROM HIS-K-LOCN,
			PS-BUS FROM FLAGCELL,
			-> PDL-POINTED-TO-BY-PAR,
			PAF [+1 -> PAR]				;PUSH CURRENT FLAGS
			FLAG-CONTROL [LOAD-FLAGCELL-FROM-NEXT-FLAGCELL] $
PLAY-MOVE-6:	ALU:
&(WHITE-TO-PLAY)	O-BUS FROM AC[BETA],	;PUSH ALPHA-BETA VARIABLE
&(BLACK-TO-PLAY)	O-BUS FROM AC[ALPHA],	;PUSH THE ONE HE S ABOUT TO CLOBBER
&T 			-> PDL-POINTED-TO-BY-PAR,	;NOTE STM HAS BEEN CHANGED
			PAF [+1 -> PAR]
		      @PUSHJ, PLAY-MOVE-7 $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING TO FLAGCELL WORD
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL
REVERT-MOVE-1:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-1 -> PAR]	$		;INDEX TO DESTINATION
REVERT-MOVE-2:	ARRAY:	PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM A-BUS
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> WMOVE,			;CLEAR OUT DESTINATION SQUARE
			SR FROM A-BUS,
			-> SR,
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]
			PAF[-1 -> PAR] 			;INDEX TO PIECE-MOVED,,ORIGIN
		     @E-LONG REVERT-MOVE-3 $		;BECAUSE PDL -> WMOVE
REVERT-MOVE-3:	ARRAY:	DESTINATION-ARRAY, ORIG-FROM-SIR,
			ENABLE-ALL-PIECES, MOVE-MODE,
			SQUARE-SCANNER FROM SR,
			PIECE-SCANNER FROM PR,
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PR FROM A-BUS,
			-> PR,
			SQUARE-BUS FROM A-BUS,
			SIR FROM SQUARE-BUS,
			-> SIR,
			PIECE-BUS FROM A-BUS,
			-> WMOVE,			;PUT PIECE BACK ON ORIGIN SQUARE
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION],
			PS-BUS FROM PR--SIR,	;THIS ONLY MATTERS IF GET TO
						;REVERT-PROMOTING-MOVE.
			SET-PIECE-EXISTS-BIT,	;PIECE-EXISTS BIT WILL ALREADY BE
			-> PIECE-EXISTS-REGISTER,	;SET UNLESS REVERTING A 
		      @E-LONG KCHK REVERT-MOVE-4|REVERT-MOVE-4A $	;PROMOTING MOVE
						;E-LONG BECAUSE PDL -> WMOVE
REVERT-MOVE-4:	ALU:	ALU-FCTN[-],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH] $
;CLOCK IN VALID PROMOTE-MOVE CONDITION.  PR AND SR WERE SET AT BEGINNING OF THIS
;  INST. REVERT-M-A-B IS REACHED FROM CASTLING LOGIC, AND PROMOTE-MOVE IS 
;  GUARENTEED TO BE 0 THEN.
REVERT-MOVE-5:
REVERT-M-A-B:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[VALUE],
&(WHITE-TO-PLAY)	A-BUS FROM AC[BETA],
&(BLACK-TO-PLAY)	A-BUS FROM AC[ALPHA],
&T		      @PROMOTE-MOVE REVERT-M-A-B-1|REVERT-PROMOTING-MOVE $
REVERT-M-A-B-1:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[VALUE],
&(WHITE-TO-PLAY)	A-BUS FROM AC[ALPHA],
		      @ALU-LESS REVERT-M-A-B-CUT|REVERT-M-BSF-TEST 
&(BLACK-TO-PLAY)	A-BUS FROM AC[BETA],
		      @ALU-LESS-OR-EQUAL REVERT-M-BSF-TEST|REVERT-M-A-B-CUT
&T 			 $
REVERT-M-BSF-TEST:
		ALU:	NO-OP
&(WHITE-TO-PLAY)      @ALU-LESS-OR-EQUAL REVERT-C-NEW-BSF|TAG-IN-GENERATION 0 CPOPJ 
&(BLACK-TO-PLAY)      @ALU-LESS TAG-IN-GENERATION 0 CPOPJ|REVERT-C-NEW-BSF
&T 			 $

REVERT-MOVE-4A:	ALU:	NO-OP 
		      @REVERT-MOVE-5 $

;GET HERE WITH HIS-K-LOC COMMING INTO SQUARE-SCANNER, ETC.
PLAY-MOVE-7:	ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		      @SELECTED-SQUARE OTHER-SIDE-TAG MOVE-PLAYED|MOVE-ILLEGAL $
MOVE-PLAYED:		ALU:	NO-OP,
			FLAG-CONTROL[CLEAR-LEGAL-MOVE-FROM-THIS-POSITION]
 		      @ALU-LESS MOVE-PLAYED-1|LOOK-ALL-MOVES $
MOVE-PLAYED-1:	ALU:	NO-OP, @PUSHJ TAG-IN-GENERATION 0 PAWN-STR-FCTN $
		; COMPUTE FUNCTION INTO TEMP1
		ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[TEMP1],
&(WHITE-TO-PLAY)	A-BUS FROM AC[BETA],
&(BLACK-TO-PLAY)	A-BUS FROM AC[ALPHA],
&T		      @KCHK MOVE-PLAYED-1A|LOOK-ALL-MOVES $
;WITH KCHK INSTEAD OF DEEP IN FLAG QUARTER 5 THE ABOVE INSTRUCTION COULD BE FLUSHED
MOVE-PLAYED-1A:	ALU:	ALU-FCTN[B-A-1],		;COMPUTE NEW BSF CONDITION FOR 
			B-BUS FROM AC[TEMP1],	;NEXT TIME
&(WHITE-TO-PLAY)	A-BUS FROM AC[ALPHA],
		      @ALU-LESS A-B-CUT-V-MAT|LOOK-CAPTS-ONLY-1
&(BLACK-TO-PLAY)	A-BUS FROM AC[BETA],
 		      @ALU-LESS-OR-EQUAL
 			LOOK-CAPTS-ONLY-1|A-B-CUT-V-MAT 
&T			 $
PLAY-MOVE-4A:	ALU:	NO-OP
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE]
		      @PLAY-MOVE-5 $

MOVE-ILLEGAL:	ARRAY:	PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE		;CLEAR OUT DESTINATION SQUARE
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]
			PAF[-2 -> PAR]		;INDEX BACK TO FLAG-CELL WD
		      @POP-USP,MOVE-ILL-2 $
MOVE-ILL-2:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL	;RESTORE FLAGS
			PAF[-2 -> PAR] $	;INDEX TO PIECE-MOVED,,ORIGIN
;GET FLAGCELL BACK
MOVE-ILL-2A:	ARRAY:	DESTINATION-ARRAY, ORIG-FROM-SIR,
			ENABLE-ALL-PIECES, MOVE-MODE,
			SQUARE-SCANNER FROM SR,
			PIECE-SCANNER FROM PR,
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PR FROM A-BUS,		;RESET PR AND SR
			-> PR,			; THIS IS A NO-OP, UNLESS
			SQUARE-BUS FROM A-BUS, 	; MOVE WAS A PROMOTION
			SIR FROM SQUARE-BUS,	;THIS ALWAYS A NO-OP
			-> SIR,			; JUST FOR RANDOMNESS
			PIECE-BUS FROM A-BUS,
			-> WMOVE,		;PUT PIECE BACK ON ORIGIN SQ
			PS-BUS FROM PR--SIR	;THIS ONLY MATTERS IF GET TO
						;REVERT-ILL-PROMOTING-MOVE
			SET-PIECE-EXISTS-BIT,	;ALSO A NO-OP EXCEPT IN CASE
			-> PIECE-EXISTS-REGISTER 	;OF PROMOTION
		      @E-LONG MOVE-ILL-3 $	;BECAUSE PDL -> WMOVE
;CLOCK VALID FLAGCELL BIT INTO KCHK FLAGWORD BIT
MOVE-ILL-3:	ALU:	NO-OP
		      @KCHK MOVE-ILL-4|MOVE-ILL-4A $
MOVE-ILL-4:	ALU:	ALU-FCTN[-],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH]
		      @PROMOTE-MOVE TAG-IN-GENERATION 0 CPOPJ|MOVE-ILL-PROMOTING-MOVE $
MOVE-ILL-4A:	ALU:	NO-OP	
		      @PROMOTE-MOVE TAG-IN-GENERATION 0 CPOPJ|MOVE-ILL-PROMOTING-MOVE $
&(WHITE-TO-PLAY)
CPOPJ:		ALU:	NO-OP
		      @POPJ $
&T 

;NOTE: THE LAST ARRAY INSTRUCTION EXECUTED BEFORE HERE HAD BETTER HAVE
;PIECE-SCANNER FROM PR SPECIFIED SO A-M-P WILL BECOME VALID AFTER
;GEN-NOBLE-MOVES, IN TIME TO BE TESTED BY GEN-NOBLE-MOVES-1
GEN-NOBLE-MOVES:
		ALU:
&(WHITE-TO-PLAY)	PDL[HW-CONST WHITE-NULL-NOBLE-PIECE NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST BLACK-NULL-NOBLE-PIECE NULL-SQUARE],
&T 			-> PR-SR $
;A-M-P STARTS GETTING VALID AFTER PR LOADED BY THIS INST
GEN-NOBLE-MOVES-1:
		ARRAY:	DESTINATION-ARRAY, ORIG-FROM-SIR,
			ENABLE-ALL-PIECES, MOVE-MODE,
			SQUARE-SCANNER FROM SR,
			PIECE-SCANNER FROM PR,
			PIECE-BUS FROM NEXT-PIECE,
			SIR FROM PIECE-LOC,		;LOCN OF FIRST NOBLE
			-> SIR,				;OR GARBAGE IF NONE
			PR FROM NEXT-PIECE,		;LIKEWISE, GET GARBAGE OR
			-> PR $				;PIECE NUMBER INTO PR
;THIS INST CLOCKS VALID A-M-P INTO FLAGWORD.
;A-M-S STARTS GETTING VALID AFTER SIR LOADED BY THIS INST.
GEN-NOBLE-MOVES-2A:
		ALU:	NO-OP
;THIS VALID NOW, SEE ABOVE COMMENT.
		      @E-LONG ANY-MORE-PIECES GEN-PROM-PAWN-MOVES|GEN-NOBLE-MOVES-3 $
;CONFIRMED E-LONG DUE TO A-M-S
;THIS INST CLOCKS VALID A-M-S INTO FLAGWORD.
GEN-NOBLE-MOVES-2B:
		ALU:	NO-OP		;NO E-LONG, SIR SET UP LONGER IN LOOPING PATH
		      @ANY-MORE-PIECES GEN-PROM-PAWN-MOVES|GEN-NOBLE-MOVES-3 $
GEN-NOBLE-MOVES-3:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			-> SIR	  ;IF THIS WRITE TAKES PLACE, IT LOADS THE SIR 
				  ;WITH THE LOCN OF THE NEXT PIECE, IF ANY.
				  ;THIS GETS THE ARRAY STARTED AS QUICKLY AS POSSIBLE
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		      @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-NOBLE-MOVES-4|PLAY-NOBLE-MOVE-1 $
GEN-NOBLE-MOVES-4:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			PR FROM NEXT-PIECE,
			-> PR			;ADVANCE TO NEXT PIECE
			A-BUS FROM AC[NULL-SQUARE-AC],
			SR FROM A-BUS,
			-> SR			;INITIALIZE SQUARE REG
;NOTE THE SAME A-M-P EXISTED ON PREV CYCLE, SO THIS WINS.
;A-M-S STARTS GETTING VALID AFTER SR LOADED BY THIS INST.
;HOWEVER, ARRAY HAS BEEN SETTLING SINCE SIR LOADED BY GEN-NOBLE-MOVES-3.
		      @ANY-MORE-PIECES GEN-PROM-PAWN-MOVES|GEN-NOBLE-MOVES-2B $

PLAY-NOBLE-MOVE-1:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			SR FROM NEXT-SQUARE,
			-> SR,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SIR,
			-> WMOVE,		;CLEAR ORIGIN SQUARE
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
		     @PUSHJ RETURN-TARGET GEN-NOBLE-MOVES-3, PLAY-MOVE-2 $
;SR AND SIR HAVE BEEN SET FOR SEVERAL INSTS WHILE MOVE WAS REVERTED.

GEN-PROM-PAWN-MOVES:
		ALU:
&(WHITE-TO-PLAY)	PDL[HW-CONST WHITE-NULL-PROMOTED-PAWN NULL-SQUARE],
&(BLACK-TO-PLAY)	PDL[HW-CONST BLACK-NULL-PROMOTED-PAWN NULL-SQUARE],
&T 			-> PR-SR $
GEN-PROM-PAWN-MOVES-1:
		DUPLICATE-OP: GEN-NOBLE-MOVES-1 $
GEN-PROM-PAWN-MOVES-2A:
		ALU:	NO-OP
		     @E-LONG ANY-MORE-PIECES GEN-CASTLE-MOVES|GEN-PROM-PAWN-MOVES-3 $
;CONFIRMED E-LONG, SEE ABOVE
GEN-PROM-PAWN-MOVES-2B:
		ALU:	NO-OP	;NO E-LONG, IN LOOPING PATH
		     @ANY-MORE-PIECES GEN-CASTLE-MOVES|GEN-PROM-PAWN-MOVES-3 $
GEN-PROM-PAWN-MOVES-3:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			-> SIR
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		     @INHIBIT-WRITE-IF-BRANCH,
			ANY-MORE-SQUARES GEN-PROM-PAWN-MOVES-4|PLAY-PROM-PAWN-MOVE-1 $
GEN-PROM-PAWN-MOVES-4:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			PR FROM NEXT-PIECE
			-> PR
			A-BUS FROM AC[NULL-SQUARE-AC],
			SR FROM A-BUS,
			-> SR
		     @ANY-MORE-PIECES GEN-CASTLE-MOVES|GEN-PROM-PAWN-MOVES-2B $

PLAY-PROM-PAWN-MOVE-1:
		ARRAY-HOLD: GEN-NOBLE-MOVES-1
			SR FROM NEXT-SQUARE,
			-> SR,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SIR,
			-> WMOVE,			;CLEAR ORIGIN SQUARE
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
		    @PUSHJ RETURN-TARGET GEN-PROM-PAWN-MOVES-3, PLAY-MOVE-2 $

GEN-CASTLE-MOVES:
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SET UP ARRAY TO SEE IF
			ENABLE-ALL-PIECES, CAPTURE-MODE,	;CASTLING LEGAL
			PIECE-BUS FROM PR,
			SIR FROM PIECE-LOC,		   ;ENABLE HIS PCS SO CAN
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]  ;SEE IF CASTLING IS OK
&(WHITE-TO-PLAY)    @W-Q-CS-NOT-POS+W-K-CS-NOT-POS
			GEN-W-CS-K|GEN-W-CS-Q|GEN-W-CS-K|CHANGE-STM-AND-RETURN-VALUE
&(BLACK-TO-PLAY)    @B-Q-CS-NOT-POS+B-K-CS-NOT-POS
			GEN-B-CS-K|GEN-B-CS-Q|GEN-B-CS-K|CHANGE-STM-AND-RETURN-VALUE
&T $			;DISPATCH ON WHETHER CASTLING PRIVILEGES EXIST

&(WHITE-TO-PLAY) 
;GET HERE WITH STM = BLACK, READY TO SEE IF CASTLING LGL FOR WHITE
GEN-W-CS-K:	ALU:	NO-OP $		;CLOCK IN VALID K-CAS-LGL
GEN-W-CS-K-1:	ALU:	PDL[HW-CONST W-KING-PIECE-INDEX WK1]
			-> PR-SR,
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD],	;JUST TO CLEAR
		    @K-CAS-LGL GEN-W-CS-Q|PLAY-W-CS-K $	;OUT RANDOM BITS

PLAY-W-CS-K:	ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;CLEAR OUT K1
			SIR FROM SQUARE-BUS,
			-> SIR,				;SO WILL BE AVAIL FOR PUSHING
							;PIECE-MOVED--ORIG ON PDL
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
			$ 				;ELEMINATE ANY FUTURE CASTLING

		ALU:	IMMEDIATE-DATA[WKN1]		;CHANGE STM BACK TO US SO
			-> SR,				;CAN SEE IF WE'RE CHECKING HIM
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,		;PUT K ON KN1
			-> WMOVE, 
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]			;RECORD K,,K1 AS 
							; PIECE-MOVED--ORIGIN
			$
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS,
			-> PDL-POINTED-TO-BY-PAR,	;RECORD NULL,,N1 AS
			PAF[+1 -> PAR]			;PIECE-CAPT--DESTINATION
			$
		ALU:	PDL[HW-CONST W-KR-PIECE-INDEX WKR1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM NULL-PIECE
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM KR1
			PS-BUS FROM FLAGCELL,
			-> PDL-POINTED-TO-BY-PAR,	;SAVE CURRENT FLAGS
			PAF[+1 -> PAR] $
		ALU:	IMMEDIATE-DATA[WKB1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON KB1
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF CHECKING HIM
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM HIS-K-LOCN, $
		ALU:	ALU-FCTN[+],			;CAN NOT HAVE BEEN IN CHECK
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[+1],
			-> AC[WDEPTH],
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE] $
		ALU:	O-BUS FROM AC[BETA],		;PUSH ALPHA-BETA VARIABLE
			-> PDL-POINTED-TO-BY-PAR,	;WHITE TO PLAY
			PAF [+1 -> PAR],
			FLAG-CONTROL[LOAD-FLAGCELL-FROM-NEXT-FLAGCELL] $
		ALU:	ALU-FCTN[B-A-1],		;DUPLICATES OP AT PLAY-MOVE-7
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		     @PUSHJ, OTHER-SIDE-TAG MOVE-PLAYED $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING AT FLAGCELL WORD,
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL (SAME AS REVERT-MOVE-1)
REVERT-W-CS-K:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-2 -> PAR] $
		ALU:	IMMEDIATE-DATA[WKB1] -> SR, 
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE], $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM KB1
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION] $
		ALU:	PDL[HW-CONST W-KR-PIECE-INDEX WKR1]
			-> PR-SR $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON KR1
		ALU:	IMMEDIATE-DATA[WKN1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR
			-> WMOVE, $			;FLUSH K FROM KN1
		ALU:	PDL[HW-CONST W-KING-PIECE-INDEX WK1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT K ON K1
		ALU:	ALU-FCTN[B-A],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH],
		    @PUSHJ, REVERT-M-A-B $
;DO A-B TEST. IF CUT FLUSH THIS RETURN AND RETURN VALUE.
; IF NOT, DO BSF TEST AND UPDATE IF SO, THEN RETURN
; AND DROP INTO TRY Q CASTLING
		ARRAY-HOLD: GEN-CASTLE-MOVES	;BUT HAVE TO DROP IN WITH STM = BLACK
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $

;CAN GET HERE EVEN IF NO Q CASTLE PRIVILEGES (IF K CASTLE PRIVILEGES EXIST IN FACT)
;BUT THIS OK BECAUSE HARDWARE WILL ASSURE Q-CAS-LGL IS ZERO.
;GET HERE WITH STM = BLACK.
GEN-W-CS-Q:	ALU:	NO-OP $		;CLOCK IN VALID Q-CAS-LGL
GEN-W-CS-Q-1:	ALU:	PDL[HW-CONST W-KING-PIECE-INDEX WK1]
			-> PR-SR,
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @Q-CAS-LGL CHANGE-STM-AND-RETURN-VALUE|PLAY-W-CS-Q $
PLAY-W-CS-Q:	ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;CLEAR OUT K1
			SIR FROM SQUARE-BUS,
			-> SIR,				;SO WILL BE AVAIL FOR PUSHING
							;PIECE-MOVED--ORIG ON PDL
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
			$ 				;ELEMINATE ANY FUTURE CASTLING

		ALU:	IMMEDIATE-DATA[WQB1]		;CHANGE STM BACK SO 
			-> SR, 				;CAN SEE IF WE'RE CHECKING HIM
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,		;PUT K ON QB1
			-> WMOVE, 
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]			;RECORD K,,K1 AS 
							; PIECE-MOVED--ORIGIN
			$
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS,
			-> PDL-POINTED-TO-BY-PAR,	;RECORD NULL,,QB1 AS
			PAF[+1 -> PAR]			;PIECE-CAPT--DESTINATION
			$
		ALU:	PDL[HW-CONST W-QR-PIECE-INDEX WQR1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM NULL-PIECE
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM QR1
			PS-BUS FROM FLAGCELL,
			-> PDL-POINTED-TO-BY-PAR,	;SAVE CURRENT FLAGS
			PAF[+1 -> PAR] $
		ALU:	IMMEDIATE-DATA[WQ1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON Q1
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF CHECKING HIM
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM HIS-K-LOCN, $
		ALU:	ALU-FCTN[+],			;CAN NOT HAVE BEEN IN CHECK
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[+1],
			-> AC[WDEPTH],
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE] $
		ALU:	O-BUS FROM AC[BETA],		;PUSH ALPHA-BETA VARIABLE
			-> PDL-POINTED-TO-BY-PAR,	;WHITE TO PLAY
			PAF [+1 -> PAR],
			FLAG-CONTROL[LOAD-FLAGCELL-FROM-NEXT-FLAGCELL] $
		ALU:	ALU-FCTN[B-A-1],		;DUPLICATES OP AT PLAY-MOVE-7
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		     @PUSHJ, OTHER-SIDE-TAG MOVE-PLAYED $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING AT FLAGCELL WORD,
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL (SAME AS REVERT-MOVE-1)
REVERT-W-CS-Q:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-2 -> PAR] $
		ALU:	IMMEDIATE-DATA[WQ1] -> SR, 
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE], $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM Q1
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION] $
		ALU:	PDL[HW-CONST W-QR-PIECE-INDEX WQR1]
			-> PR-SR $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON QR1
		ALU:	IMMEDIATE-DATA[WQB1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR
			-> WMOVE, $			;FLUSH K FROM QB1
		ALU:	PDL[HW-CONST W-KING-PIECE-INDEX WK1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT K ON K1
		ALU:	ALU-FCTN[B-A],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH],
		    @PUSHJ, REVERT-M-A-B $
;DO A-B TEST. IF CUT FLUSH THIS RETURN AND RETURN VALUE.
; IF NOT, DO BSF TEST AND UPDATE IF SO, THEN RETURN
; AND DROP THRU INTO RETURN-VALUE. NOTE STM IS NORMAL (WHITE).
&(BLACK-TO-PLAY) 
;GET HERE WITH STM = HIM (WHITE)
GEN-B-CS-K:	ALU:	NO-OP $		;CLOCK IN VALID K-CAS-LGL
GEN-B-CS-K-1:	ALU:	PDL[HW-CONST B-KING-PIECE-INDEX BK1]
			-> PR-SR,
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD],	;JUST TO CLEAR
		    @K-CAS-LGL GEN-B-CS-Q|PLAY-B-CS-K $	;OUT RANDOM BITS

PLAY-B-CS-K:	ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;CLEAR OUT K1
			SIR FROM SQUARE-BUS,
			-> SIR,				;SO WILL BE AVAIL FOR PUSHING
							;PIECE-MOVED--ORIG ON PDL
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
			$ 				;ELEMINATE ANY FUTURE CASTLING

		ALU:	IMMEDIATE-DATA[BKN1]		;CHANGE STM BACK SO CAN
			-> SR,				;SEE IF WE RE CHECKING HIM
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,		;PUT K ON KN1
			-> WMOVE, 
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]			;RECORD K,,K1 AS 
							; PIECE-MOVED--ORIGIN
			$
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS,
			-> PDL-POINTED-TO-BY-PAR,	;RECORD NULL,,N1 AS
			PAF[+1 -> PAR]			;PIECE-CAPT--DESTINATION
			$
		ALU:	PDL[HW-CONST B-KR-PIECE-INDEX BKR1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM NULL-PIECE
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM KR1
			PS-BUS FROM FLAGCELL,
			-> PDL-POINTED-TO-BY-PAR,	;SAVE CURRENT FLAGS
			PAF[+1 -> PAR] $
		ALU:	IMMEDIATE-DATA[BKB1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON KB1
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF CHECKING HIM
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM HIS-K-LOCN, $
		ALU:	ALU-FCTN[+],			;CAN NOT HAVE BEEN IN CHECK
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[+1],
			-> AC[WDEPTH],
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE] $
		ALU:	O-BUS FROM AC[ALPHA],		;PUSH ALPHA-BETA VARIABLE
			-> PDL-POINTED-TO-BY-PAR,	;BLACK TO PLAY
			PAF[+1 -> PAR],
			FLAG-CONTROL[LOAD-FLAGCELL-FROM-NEXT-FLAGCELL] $
		ALU:	ALU-FCTN[B-A-1],		;DUPLICATES OP AT PLAY-MOVE-7
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		     @PUSHJ, OTHER-SIDE-TAG MOVE-PLAYED $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING AT FLAGCELL WORD,
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL (SAME AS REVERT-MOVE-1)
REVERT-B-CS-K:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-2 -> PAR] $
		ALU:	IMMEDIATE-DATA[BKB1] -> SR, 
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE], $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM KB1
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION] $
		ALU:	PDL[HW-CONST B-KR-PIECE-INDEX BKR1]
			-> PR-SR $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON KR1
		ALU:	IMMEDIATE-DATA[BKN1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR
			-> WMOVE, $			;FLUSH K FROM KN1
		ALU:	PDL[HW-CONST B-KING-PIECE-INDEX BK1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT K ON K1
		ALU:	ALU-FCTN[B-A],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH],
		    @PUSHJ, REVERT-M-A-B $
;DO A-B TEST. IF CUT FLUSH THIS RETURN AND RETURN VALUE.
; IF NOT, DO BSF TEST AND UPDATE IF SO, THEN RETURN
; AND DROP INTO TRY Q CASTLING
		ARRAY-HOLD: GEN-CASTLE-MOVES		;CHANGE STM TO HIM
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $
;CAN GET HERE EVEN IF NO Q CASTLE PRIVILEGES (IF K CASTLE PRIVILEGES EXIST IN FACT)
;BUT THIS OK BECAUSE HARDWARE WILL ASSURE Q-CAS-LGL IS ZERO.
;GET HERE WITH STM = HIM (WHITE)
GEN-B-CS-Q:	ALU:	NO-OP $		;CLOCK IN VALID Q-CAS-LGL
GEN-B-CS-Q-1:	ALU:	PDL[HW-CONST B-KING-PIECE-INDEX BK1]
			-> PR-SR,
			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
		    @Q-CAS-LGL CHANGE-STM-AND-RETURN-VALUE|PLAY-B-CS-Q $
PLAY-B-CS-Q:	ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;CLEAR OUT K1
			SIR FROM SQUARE-BUS,
			-> SIR,				;SO WILL BE AVAIL FOR PUSHING
							;PIECE-MOVED--ORIG ON PDL
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
			$ 				;ELEMINATE ANY FUTURE CASTLING

		ALU:	IMMEDIATE-DATA[BQB1]	;CHANGE STM BACK TO US TO CAN
			-> SR,			;SEE IF WE'RE CHECKING HIM
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE] $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,		;PUT K ON QB1
			-> WMOVE, 
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]			;RECORD K,,K1 AS 
							; PIECE-MOVED--ORIGIN
			$
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS,
			-> PDL-POINTED-TO-BY-PAR,	;RECORD NULL,,QB1 AS
			PAF[+1 -> PAR]			;PIECE-CAPT--DESTINATION
			$
		ALU:	PDL[HW-CONST B-QR-PIECE-INDEX BQR1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM NULL-PIECE
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM QR1
			PS-BUS FROM FLAGCELL,
			-> PDL-POINTED-TO-BY-PAR,	;SAVE CURRENT FLAGS
			PAF[+1 -> PAR] $
		ALU:	IMMEDIATE-DATA[BQ1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON Q1
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,	;SEE IF CHECKING HIM
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-SCANNER FROM HIS-K-LOCN, $
		ALU:	ALU-FCTN[+],			;CAN NOT HAVE BEEN IN CHECK
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[+1],
			-> AC[WDEPTH],
	FLAG-CONTROL[CHANGE-SIDE-TO-MOVE-AND-SET-NEXT-KCHK-FROM-SELECTED-SQUARE] $
		ALU:	O-BUS FROM AC[ALPHA],		;PUSH ALPHA-BETA VARIABLE
			-> PDL-POINTED-TO-BY-PAR,	;BLACK TO PLAY
			PAF[+1 -> PAR],
			FLAG-CONTROL[LOAD-FLAGCELL-FROM-NEXT-FLAGCELL] $
		ALU:	ALU-FCTN[B-A-1],		;DUPLICATES OP AT PLAY-MOVE-7
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[DEEP-PARAMETER],
		     @PUSHJ, OTHER-SIDE-TAG MOVE-PLAYED $
;RETURN HERE AT END OF SEARCH WITH VALUE IN AC[VALUE]
;PAR POINTING AT FLAGCELL WORD,
;ALPHA-BETA VARIABLE ALREADY RESTORED FROM PDL (SAME AS REVERT-MOVE-1)
REVERT-B-CS-Q:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			 -> FLAGCELL,
			PAF[-2 -> PAR] $
		ALU:	IMMEDIATE-DATA[BQ1] -> SR, 
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE], $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,			;FLUSH ROOK FROM Q1
			FLAG-CONTROL[SET-LEGAL-MOVE-FROM-THIS-POSITION] $
		ALU:	PDL[HW-CONST B-QR-PIECE-INDEX BQR1]
			-> PR-SR $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT ROOK ON QR1
		ALU:	IMMEDIATE-DATA[BQB1]
			-> SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES 
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR
			-> WMOVE, $			;FLUSH K FROM QB1
		ALU:	PDL[HW-CONST B-KING-PIECE-INDEX BK1]
			-> PR-SR, $
		ARRAY-HOLD: GEN-CASTLE-MOVES
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE, $			;PUT K ON K1
		ALU:	ALU-FCTN[B-A],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM IMMEDIATE-DATA[1],
			-> AC[WDEPTH],
		    @PUSHJ, REVERT-M-A-B $
;DO A-B TEST. IF CUT FLUSH THIS RETURN AND RETURN VALUE.
; IF NOT, DO BSF TEST AND UPDATE IF SO, THEN RETURN
; AND DROP THRU INTO RETURN-VALUE
&T 

RETURN-VALUE:	ALU:
&(WHITE-TO-PLAY)	O-BUS FROM AC[ALPHA] 
&(BLACK-TO-PLAY)	O-BUS FROM AC[BETA] 
&T			 -> AC[VALUE]
 			PAF[-1 -> PAR]			;INDEX BACK TO SAVED ALPHA-BETA 
		    @DEEP+LEGAL R-V-MATE-OR-STALEMATE|<3>R-V-1 $
R-V-1:		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
&(WHITE-TO-PLAY)	-> AC[ALPHA],
&(BLACK-TO-PLAY)	-> AC[BETA],
&T 			PAF[-1 -> PAR]			;LEAVE PAR POINTING AT FLAGCELL
		    @POPJ $

A-B-CUT-V-MAT:	ALU:	O-BUS FROM AC[TEMP1] 
			 -> AC[VALUE]	;ALPHA BETA CUT WITH VALUE OF
			PAF[-1 -> PAR]			;CURRENT POSITION IN
		    @R-V-1 $				;AC[MATERIAL]

CHANGE-STM-AND-RETURN-VALUE:			;CHANGE STM BACK AFTER HAVE CHANGED
		ALU:				; IT TO SEE IF CASTLING WAS OK.
&(WHITE-TO-PLAY)	O-BUS FROM AC[ALPHA] 
&(BLACK-TO-PLAY)	O-BUS FROM AC[BETA] 
&T			 -> AC[VALUE]
 			PAF[-1 -> PAR]			;INDEX BACK TO SAVED ALPHA-BETA 
			FLAG-CONTROL[CHANGE-SIDE-TO-MOVE]
		    @DEEP+LEGAL R-V-MATE-OR-STALEMATE|<3>R-V-1 $

;GET HERE IF A-B CUT WITH CURRENT VALUE IN AC[VALUE].
;ALSO AN EXTRA POP-USP NEEDS TO BE DONE AND AC[TEMP]
;HAS VALUE OF PIECE JUST UNCAPTURED.

REVERT-C-A-B-CUT:
		ALU:	ALU-FCTN[B-A-1],	;CHECK TO SEE IF WANT TO UPDATE P.V.
			B-BUS FROM PAR,		;IE IF IN TOP THREE PLIES
			A-BUS FROM PDL[PDL-314] $
		ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[-],
&(BLACK-TO-PLAY)	ALU-FCTN[+],
&T			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[TEMP],
			-> AC[MATERIAL],
			PAF[-1 -> PAR]
		    @POP-USP ALU-LESS, R-V-1|R-V-A-B-UPDATE-PV $

REVERT-M-A-B-CUT:
		ALU:	ALU-FCTN[B-A-1],	;CHECK TO SEE IF WANT TO UPDATE P.V.
			B-BUS FROM PAR,		;IE IF IN TOP THREE PLIES
			A-BUS FROM PDL[PDL-314] $
		ALU:	NO-OP
			PAF[-1 -> PAR]
		    @POP-USP ALU-LESS, R-V-1|R-V-A-B-UPDATE-PV $

R-V-A-B-UPDATE-PV:
		ALU:	NO-OP
			PAF[+1 -> PAR]	;COMPENSATE FOR -1 DONE PREVIOUSLY
		    @PUSHJ TAG-IN-GENERATION 0 REVERT-SAVE-PV $
		ALU:	NO-OP
			PAF[-1 -> PAR]	;BACK SO R-V-1 CAN RESTORE A/B VAR
		    @R-V-1 $

R-V-MATE-OR-STALEMATE:
		ALU:	O-BUS FROM USP, -> AC[VALUE] $
		ALU:	ALU-FCTN[-],
&(WHITE-TO-PLAY)	B-BUS FROM AC[VALUE],
			A-BUS FROM PDL[MATED-CONSTANT],	;DODGE BECAUSE AAC S DONT MAKE
							; IT TO A-BUS
&(BLACK-TO-PLAY)	B-BUS FROM AAC[MATED-VALUE],
			A-BUS FROM AC[VALUE],
&T			 -> AC[VALUE]
		    @KCHK R-V-STALEMATE|R-V-1 $
R-V-STALEMATE:	ALU:	ALU-FCTN[SETZ], -> AC[VALUE], @R-V-1 $


;;GET HERE IF THERE IS ONLY ONE SQUARE ON ENTIRE BOARD TO WHICH A 
;;CAPTURE CAN BE MADE.  THIS SQUARE IS IN SR.
;
;GEN1CAPT:	ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
;			ENABLE-ALL-PIECES, CAPTURE-MODE,
;			SQUARE-BUS FROM SR,
;			SIR FROM SQUARE-BUS,
;			 -> SIR,
;			SQUARE-SCANNER FROM SR,		;GET POUT INTO PR VIA 
;			PS-BUS FROM POUT--SQUARE-BUS,		;DEVIOUS MEANS
;			 -> AC[TEMP] $
;GEN1CAPT-1:	ALU:	IMMEDIATE-DATA[NULL-SQUARE]
;			 -> SR $
;GEN1CAPT-2:	ALU:	A-BUS FROM AC[TEMP],
;			 -> PR $			;PIECE BEING CAPTED
;GEN1CAPT-3:	ARRAY-HOLD: GEN1CAPT,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		    @ANY-MORE-SQUARES GEN-MOVES|PLAY-1CAPT-1 $
;
;PLAY-1CAPT-1:
;		ARRAY-HOLD: GENALLCAPT-NOBLE,
;			SR FROM NEXT-SQUARE,
;			-> SR,
;			PS-BUS FROM POUT--SQUARE-BUS,
;			-> PDL-POINTED-TO-BY-PAR,
;			PAF[+1 -> PAR]
;		     @PUSHJ,PLAY-CAPT-2 $
;PLAY-1CAPT-2:	ARRAY-HOLD: GENALLCAPT-NOBLE,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		     @ANY-MORE-SQUARES GEN-MOVES|PLAY-1CAPT-1 $
;
;;GET HERE IF THERE ARE EXACTLY TWO SQUARES TO WHICH CAPTURES CAN BE MADE.
;;THE LOWER NUMBERED OF THEM IS IN SR.  SINCE THE SQUARE SCANNER IS SELECTED
;;FROM SR, THE OTHER IS CURRENTLY COMMING OUT OF THE SQUARE SCANNER.
;;CODE BELOW IS SUPPOSED TO DETERMINE WHICH OF THE TWO SQUARES HAS THE
;;MOST VALUABLE PIECE ON IT, AND LOOK AT CAPTURES OF THAT ONE FIRST.
;
;GEN2CAPT:	ARRAY-HOLD: GENCAPT
;			SQUARE-BUS FROM SR,
;			PIECE-BUS FROM POUT,
;			PS-BUS FROM PIECE-VALUE,
;			-> AC[TEMP] $		;VALUE OF PIECE ON SR SQUARE
;GEN2CAPT-1:	ARRAY-HOLD: GENCAPT
;			SQUARE-SCANNER FROM SR,
;			SQUARE-BUS FROM NEXT-SQUARE,
;			PIECE-BUS FROM POUT,
;			PS-BUS FROM PIECE-VALUE,
;		    @ANY-MORE-SQUARES GEN2CAPT-ERR|GEN2CAPT-2 $
;GEN2CAPT-2:	ALU:	ALU-FCTN[-],
;			B-BUS FROM AC[TEMP],
;			A-BUS FROM PS-BUS $
;GEN2CAPT-3:	ARRAY-HOLD: GENCAPT			;DO THIS CYCLE FOR HIGH FIRST
;			SQUARE-SCANNER FROM SR,
;			SQUARE-BUS FROM NEXT-SQUARE,
;			SIR FROM SQUARE-BUS,
;			-> SIR,				;HIGH CAPT SQUARE
;		    @ALU-LESS GEN2CAPT-LOW-FIRST|GEN2CAPT-HIGH-FIRST-1 $
;GEN2CAPT-LOW-FIRST:
;		ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
;			ENABLE-ALL-PIECES, CAPTURE-MODE,
;			SQUARE-BUS FROM SR,
;			SIR FROM SQUARE-BUS,
;			-> SIR,				;LOW CAPT SQUARE
;			SQUARE-SCANNER FROM SR,
;			PS-BUS FROM POUT--SQUARE-BUS,	;GET POUT INTO PR VIA 
;			-> AC[TEMP] $			;DEVIOUS MEANS
;GEN2CAPT-L-1:	ALU:	IMMEDIATE-DATA[NULL-SQUARE] -> SR $
;GEN2CAPT-L-2:	ALU:	A-BUS FROM AC[TEMP] -> PR $		;PIECE BEING CAPTED
;GEN2CAPT-L-3:	ARRAY-HOLD: GENALLCAPT-NOBLE,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		   @ANY-MORE-SQUARES GEN2CAPT-LH|PLAY-2CAPT-L-1 $
;PLAY-2CAPT-L-1:	DUPLICATE-OP: PLAY-1CAPT-1
;		   @PUSHJ,PLAY-CAPT-2 $
;PLAY-2CAPT-L-2:	DUPLICATE-OP: PLAY-1CAPT-2
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		   @ANY-MORE-SQUARES GEN2CAPT-LH|PLAY-2CAPT-L-1 $
;
;;GET HERE IF 1) THERE WERE EXACTLY TWO SQUARES TO WHICH CAPTURES COULD BE MADE,
;;	     2) OF THOSE TWO, THE LOWER NUMBERED ONE WAS OCCUPPIED BY A PIECE
;;	 	OF HIGHER VALUE.
;;	     3) WE HAVE NOW LOOKED AT ALL CAPTURES OF THAT PIECE (ON THE LOWER
;;		NUMBERED SQUARE) AND ARE NOW READY TO LOOK AT CAPTURES
;;		OF THE HIGHER NUMBERED SQUARE.
;
;GEN2CAPT-LH:	ARRAY-HOLD: GENCAPT $		;REGENERATE CAPTURE SQUARES
;GEN2CAPT-LH-1:	ALU: IMMEDIATE-DATA[NULL-SQUARE] -> SR, $
;GEN2CAPT-LH-2:	ARRAY-HOLD: GENCAPT
;			SR FROM NEXT-SQUARE,
;			-> SR $			;GET LOWER SQUARE BACK INTO SR
;GEN2CAPT-LH-3:	ARRAY-HOLD: GENCAPT
;			SQUARE-SCANNER FROM SR,
;			SQUARE-BUS FROM NEXT-SQUARE,
;			SIR FROM SQUARE-BUS,
;			-> SIR,			;GET HIGHER SQUARE IN SIR,
;			SR FROM NEXT-SQUARE,
;			-> SR $			;ALSO INTO SR
;GEN2CAPT-LH-4:	ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
;			ENABLE-ALL-PIECES, CAPTURE-MODE,
;			SQUARE-SCANNER FROM SR,	;SO WILL BE THERE WHEN SR GETS SET UP
;			SQUARE-BUS FROM SIR,	;BELOW
;;NOTE-- THIS DOESNT WIN, WANTS TO BE SR
;			PS-BUS FROM POUT--SQUARE-BUS,
;			-> AC[TEMP] $
;GEN2CAPT-LH-5:	ALU:	IMMEDIATE-DATA[NULL-SQUARE] -> SR $
;GEN2CAPT-LH-6:	ALU:	A-BUS FROM AC[TEMP] -> PR $
;GEN2CAPT-LH-7:	ARRAY-HOLD: GENALLCAPT-NOBLE,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		     @ANY-MORE-SQUARES GEN-MOVES|PLAY-2CAPT-LH-1 $
;PLAY-2CAPT-LH-1:
;		DUPLICATE-OP: PLAY-1CAPT-1
;		     @PUSHJ, PLAY-CAPT-2 $
;PLAY-2CAPT-LH-2:
;		DUPLICATE-OP: PLAY-1CAPT-2
;		     @ANY-MORE-SQUARES GEN-MOVES|PLAY-2CAPT-LH-1 $
;
;;GET HERE IF 1) THERE ARE EXACTLY 2 SQUARES TO WHICH CAPTURES CAN BE MADE.
;;	     2) THE HIGHER NUMBERED OF THEM CONTAINS THE MORE VALUABLE PIECE.
;;  SIR HAS BEEN LOADED WITH THE HIGHER NUMBERED SQUARE.
;GEN2CAPT-HIGH-FIRST-1:
;		ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
;			ENABLE-ALL-PIECES, CAPTURE-MODE,
;			SQUARE-SCANNER FROM SR,
;			SQUARE-BUS FROM SR,
;			PS-BUS FROM POUT--SQUARE-BUS,
;			-> AC[TEMP] $
;GEN2CAPT-H-2:	ALU:	IMMEDIATE-DATA[NULL-SQUARE] -> SR $
;GEN2CAPT-H-3:	ALU:	A-BUS FROM AC[TEMP] -> PR $
;GEN2CAPT-H-4:	ARRAY-HOLD: GENALLCAPT-NOBLE,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		     @ANY-MORE-SQUARES GEN2CAPT-HL|PLAY-2CAPT-H-1 $
;PLAY-2CAPT-H-1:	DUPLICATE-OP: PLAY-1CAPT-1
;		     @PUSHJ, PLAY-CAPT-2 $
;PLAY-2CAPT-H-2:	DUPLICATE-OP: PLAY-1CAPT-2
;		     @ANY-MORE-SQUARES GEN2CAPT-HL|PLAY-2CAPT-H-1 $
;
;;GET HERE IF 1) THERE WERE EXACTLY 2 SQUARES TO WHICH CAPTURES COULD BE MADE,
;;	     2) THE HIGHER NUMBERED OF THEM CONTAINS THE MORE VALUABLE PIECE,
;;	     3) HAVE NOW LOOKED AT ALL CAPTS OF THAT HIGHER VALUED PIECE
;;		AND ARE READY TO LOOK AT CAPTS OF THE LOWER NUMBERED SQUARE.
;
;GEN2CAPT-HL:	ARRAY-HOLD: GENCAPT $	;REGENERATE CAPTURE SQUARES
;GEN2CAPT-HL-1:	ALU: IMMEDIATE-DATA[NULL-SQUARE] -> SR $
;GEN2CAPT-HL-2:	ARRAY-HOLD: GENCAPT
;			SR FROM NEXT-SQUARE,
;			-> SR,
;			SQUARE-BUS FROM NEXT-SQUARE,
;			SIR FROM SQUARE-BUS,
;			-> SIR $	;AND ALSO SIR
;GEN2CAPT-HL-3:	ARRAY:	ORIGIN-ARRAY, DEST-FROM-SIR,
;			ENABLE-ALL-PIECES, CAPTURE-MODE,
;			SQUARE-SCANNER FROM SR,		;SO WILL BE THERE WHEN SR GETS
;			SQUARE-BUS FROM SIR,		;SET UP BELOW
;;NOTE!! THIS DOESNT WIN WANTS TO BE SR
;			PS-BUS FROM POUT--SQUARE-BUS,
;			-> AC[TEMP] $
;GEN2CAPT-HL-4:	ALU:	IMMEDIATE-DATA[NULL-SQUARE] -> SR $
;GEN2CAPT-HL-5:	ALU:	A-BUS FROM AC[TEMP] -> PR $
;GEN2CAPT-HL-6:	ARRAY-HOLD:	GENALLCAPT-NOBLE,
;			FLAG-CONTROL[INITIALIZE-NEXT-FLAGCELL-WORD]
;		    @ANY-MORE-SQUARES GEN-MOVES|PLAY-2CAPT-HL-1 $
;PLAY-2CAPT-HL-1:
;		DUPLICATE-OP: PLAY-1CAPT-1
;		    @PUSHJ, PLAY-CAPT-2 $
;PLAY-2CAPT-HL-2:
;		DUPLICATE-OP: PLAY-1CAPT-2
;		    @ANY-MORE-SQUARES GEN-MOVES|PLAY-2CAPT-HL-1 $

;GET HERE FROM PLAY-MOVE-2.  MOVE HAS BEEN PLAYED IN NORMAL FASHION ON BOARD,
; PIECE-MOVED ORIGIN HAS BEEN PUSHED.  NOTE THAT PIECE-MOVED THAT WAS PUSHED 
; WAS THE UNPROMOTED PAWN.  ALSO NOTE THE PS-BUS SELECTOR HAS BEEN LEFT AT
; PR--SIR.

PLAY-PROMOTING-MOVE:
		ALU:	NO-OP, @ POP-USP PL-PR-MV-2 $
PL-PR-MV-2:	ALU:	ALU-FCTN[SETZ], -> AC[TEMP1], @ PUSHJ PL-PR-MV-SUBR $
		ALU:	O-BUS FROM IMMEDIATE-DATA[1], -> AC[TEMP1], @PUSHJ PL-PR-MV-SUBR-A $
		ALU:	O-BUS FROM IMMEDIATE-DATA[2], -> AC[TEMP1], @PUSHJ PL-PR-MV-SUBR-A $
		ALU:	O-BUS FROM IMMEDIATE-DATA[3], -> AC[TEMP1], 
		  @PUSHJ RETURN-TARGET GEN-PAWN-MOVES-3, PL-PR-MV-SUBR-A $

PL-PR-MV-SUBR-A:
		ARRAY-HOLD: GEN-PAWN-MOVES-1
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SIR,
			-> WMOVE,		;CLEAR ORIGIN SQUARE
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS] $
		ARRAY-HOLD:	PLAY-MOVE-2, -> WMOVE, -> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR] $
PL-PR-MV-SUBR:	ALU:	ALU-FCTN[IOR],		;COMPUTE INDEX OF CORRESPONDING
			B-BUS FROM AAC[C-LEFT-40]	;PROMOTED PAWN
			A-BUS FROM PS-BUS,
			-> AC[TEMP] $
;NOTE PR CAN NOT BE LOADED DIRECTLY SINCE IT LOADS FROM A-BUS, NOT ALU-OUTPUT.
		ARRAY:	A-BUS FROM AC[TEMP],
			PR FROM A-BUS,
			-> PR,				;PR GETS PROMOTED PAWN INDEX
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			ZERO-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER, 		;CLEAR PIECE EXISTS BIT 
			PAF[PAR -> PAR-SV] $
		ALU:	ALU-FCTN[+], B-BUS FROM AC[TEMP1],
			A-BUS FROM IMMEDIATE-DATA[PDL-Q-VAL-REG], -> AAC[PAR] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, -> PIECE-VALUE $
		ALU:	ALU-FCTN[+],
&(WHITE-TO-PLAY)	A-BUS FROM IMMEDIATE-DATA[WHITE-QUEEN-TYPE-WOOD],
&(BLACK-TO-PLAY)	A-BUS FROM IMMEDIATE-DATA[BLACK-QUEEN-TYPE-WOOD],
&T 			B-BUS FROM AC[TEMP1],
			-> PIECE-TYPE $
		ARRAY:	PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			SET-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			-> WMOVE $		;PLUNK DOWN NEW Q,R,B,N ON DESTINATION SQ
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, 
			-> AC[TEMP1], PAF[PAR-SV -> PAR] $
		ALU:	ALU-FCTN[-], B-BUS FROM AC[TEMP1], 
			A-BUS FROM IMMEDIATE-DATA[PAWN-VALUE], -> AC[TEMP] $
		ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[+],
&(BLACK-TO-PLAY)	ALU-FCTN[-],
&T 			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[TEMP],
			-> AC[MATERIAL]
		     @PLAY-MOVE-3 $

; SUBROUTINE USED IN REVERTING PROMOTIONS

REVERT-PROMOTION-SUBR:
		ALU:	ALU-FCTN[IOR]	;COMPUTE INDEX OF PROMOTED PAWN
			B-BUS FROM AAC[C-LEFT-40]
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> AC[TEMP1] $
		ARRAY-HOLD: REVERT-MOVE-3,		;KEEP THINGS SET UP FOR
			A-BUS FROM AC[TEMP1],		;RETURN TO GEN-PAWN-MOVES
			PIECE-BUS FROM LEFT-A-BUS,	;CLEAR PIECE-EXISTS BIT
			ZERO-PIECE-EXISTS-BIT,		;OF PROMOTED-PAWN
			-> PIECE-EXISTS-REGISTER,
			PS-BUS FROM PIECE-VALUE $
		ALU:	A-BUS FROM AC[TEMP1],		; PR PAWN INDEX
			O-BUS FROM PS-BUS,
			-> AC[TEMP1] $
		ALU:	ALU-FCTN[-], B-BUS FROM AC[TEMP1],
			A-BUS FROM IMMEDIATE-DATA[PAWN-VALUE],
			-> AC[TEMP1] $			; PROMOTED-PIECE-VAL MINUS PAWN-VAL
		ALU:
&(WHITE-TO-PLAY) 	ALU-FCTN[-],
&(BLACK-TO-PLAY) 	ALU-FCTN[+],
&T 			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[TEMP1],
			-> AC[MATERIAL],
			 @POPJ $

;GET HERE FROM REVERT-MOVE-5. (PATH FROM REVERT-M-A-B IS IMPOSSIBLE).
;MOVE ITSELF HAS BEEN REVERTED, NOW UNQUEEN.  PS-BUS SELECTOR HAS BEEN LEFT
; IN PR--SIR STATE BY REVERT-MOVE-3.  SINCE THE PIECE-MOVED PUSHED WAS THE 
; UNPROMOTED PAWN INDEX, THE UNMOVING OPERATION HAS PUT THE UNPROMOTED PAWN
; BACK ON THE CORRECT ORIGIN SQUARE AND SET ITS PIECE-EXISTS BIT. 
; ALL THAT NEEDS TO BE DONE IS TO CLEAR THE PIECE-EXISTS BIT OF THE PROMOTED PAWN,
; AND ADJUST AC[MATERIAL].

REVERT-PROMOTING-MOVE:
		ALU:	NO-OP, @ PUSHJ REVERT-PROMOTION-SUBR $
		ARRAY-HOLD:	REVERT-MOVE-3  $	; KEEP THINGS SET UP
						; FOR RETURN TO GEN-PAWN-MOVES
		DUPLICATE-OP: REVERT-MOVE-5,	;DUPLICATE INST DISCARDED
		     @REVERT-M-A-B-1 $

;GET HERE IF PROMOTING MOVE ILLEGAL FROM MOVE-ILL-4 OR -4A.
;MOVE HAS BEEN REVERTED, SO SAME COMMENTS AS AT REVERT-PROMOTING-MOVE APPLY.

MOVE-ILL-PROMOTING-MOVE:  
		ALU:	NO-OP, @ PUSHJ REVERT-PROMOTION-SUBR $
		ARRAY-HOLD:	REVERT-MOVE-3, @ POPJ $	; KEEP THINGS SET UP

;GET HERE FROM PLAY-CAPT-2A.  PIECE-MOVED--ORIGIN AND PIECE-CAPT--DEST HAVE
;BEEN PUSHED, AND THE ORIGIN SQUARE HAS BEEN CLEARED.  PIECE-MOVED IS
;IN AC[TEMP] AND THE PIECE-EXISTANCE BIT OR PIECE-CAPT HAS BEEN CLEARED.

PLAY-PROMOTING-CAPT:
		ALU:	@ POP-USP PL-PR-C-2 $
PL-PR-C-2:	ALU:	ALU-FCTN[SETZ], -> AC[TEMP1], @ PUSHJ PL-PR-CAPT-SUBR $
		ALU:	O-BUS FROM IMMEDIATE-DATA[1], -> AC[TEMP1], 
			@ PUSHJ PL-PR-CAPT-SUBR-A $
		ALU:	O-BUS FROM IMMEDIATE-DATA[2], -> AC[TEMP1],
			@ PUSHJ PL-PR-CAPT-SUBR-A $
		ALU:	O-BUS FROM IMMEDIATE-DATA[3], -> AC[TEMP1],
			@ PUSHJ PL-PR-CAPT-SUBR-A $
		ALU:	O-BUS FROM PS-BUS, -> AC[TEMP1] $
		ALU:	ALU-FCTN[B-A-1], A-BUS FROM PDL[HW-CONST 60 0],
			B-BUS FROM AC[TEMP1], $
		ALU:	NO-OP, @ALU-LESS PLAY-PROM-PAWN-CAPT-2|PLAY-CAPT-NOBLE-2 $

; PIECE CAPT'D MUST HAVE BEEN PIECE OR PROM. PAWN

PL-PR-CAPT-SUBR-A:
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, -> AC[TEMP] $
		ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM SR,
			-> WMOVE,		;CLEAR ORIGIN SQUARE
			PAF[+2 -> PAR]  $	; READY TO PUSH FLAGCELL AT PLAY-CAPT-3
PL-PR-CAPT-SUBR:
		ARRAY:	A-BUS FROM AC[TEMP],	  ;CLEAR PXR BIT OF PAWN
			PIECE-BUS FROM LEFT-A-BUS,
			ZERO-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER $
		ALU:	ALU-FCTN[IOR],		;COMPUTE INDEX OF CORRESPONDING
			B-BUS FROM AAC[C-LEFT-40]	;PROMOTED PAWN
			A-BUS FROM AC[TEMP],
			-> AC[TEMP] $
;NOTE PR CAN NOT BE LOADED DIRECTLY SINCE IT LOADS FROM A-BUS, NOT ALU-OUTPUT.
		ARRAY:	A-BUS FROM AC[TEMP],
			PR FROM A-BUS,
			-> PR,				;PR GETS PROMOTED PAWN INDEX
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SIR,
			PS-BUS FROM PR--SIR,
			-> PDL-POINTED-TO-BY-PAR,	; SAVE # OF CAPT'D PIECE
			ZERO-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER, 		;CLEAR PIECE EXISTS BIT 
			PAF[PAR -> PAR-SV] $
		ALU:	ALU-FCTN[+], B-BUS FROM AC[TEMP1],
			A-BUS FROM IMMEDIATE-DATA[PDL-Q-VAL-REG], -> AAC[PAR] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> PIECE-VALUE $
		ALU:	ALU-FCTN[+],
&(WHITE-TO-PLAY)	A-BUS FROM IMMEDIATE-DATA[WHITE-QUEEN-TYPE-WOOD],
&(BLACK-TO-PLAY)	A-BUS FROM IMMEDIATE-DATA[BLACK-QUEEN-TYPE-WOOD],
&T 			B-BUS FROM AC[TEMP1],
			-> PIECE-TYPE $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR,
			-> AC[TEMP1], PAF[PAR-SV -> PAR] $
		ARRAY:	A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PR FROM A-BUS, -> PR,
			PIECE-BUS FROM PR,
			SQUARE-BUS FROM SIR,
			SET-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			-> WMOVE $		;PLUNK DOWN NEW Q,R,B,N ON DESTINATION SQ
		ALU:	ALU-FCTN[-], B-BUS FROM AC[TEMP1], 
			A-BUS FROM IMMEDIATE-DATA[PAWN-VALUE], -> AC[TEMP1] $
		ALU:
&(WHITE-TO-PLAY)	ALU-FCTN[+],
&(BLACK-TO-PLAY)	ALU-FCTN[-],
&T 			B-BUS FROM AC[MATERIAL],
			A-BUS FROM AC[TEMP1],
			-> AC[MATERIAL]
		    @PLAY-CAPT-3 $

;GET HERE FROM REVERT-CAPT-4+1 OR 4A+1.
;CAPTURE HAS BEEN REVERTED AS NORMAL, NOW UNQUEEN. AS FOR REVERT-PROMOTING-MOVE,
; THE UNCAPTURING OPERATION HAS PUT THE MOVING PAWN BACK ON THE CORRECT SQUARE
; AND SET ITS PIECE-EXISTS BIT. ALL THAT NEEDS TO BE DONE IS CLEAR THE 
; PIECE-EXISTS BIT OF THE PROMOTED PAWN AND ADJUST AC[MATERIAL].
; AC[TEMP] HAS VALUE OF CAPTURED PIECE. PDL-POINTED-TO-BY-PAR HAS 
; PIECE-MOVED--ORIGIN NOW.

REVERT-PROMOTING-CAPT:
		ALU:	NO-OP, @ PUSHJ REVERT-PROMOTION-SUBR $
		ARRAY-HOLD:	REVERT-CAPT-3, @ REVERT-CAPT-5 $
		
;GET HERE FROM CAPT-ILL-5+1 OR 5A+1. SITUATION SIMILAR TO REVERT-PROMOTING-CAPTURE.

CAPT-ILL-PROMOTING-CAPT:
		ALU:	NO-OP, @ PUSHJ REVERT-PROMOTION-SUBR $
		ARRAY-HOLD:	CAPT-ILL-4, @POPJ $

;GET HERE FROM PLAY-CAPT-2A. ORIGIN SQUARE HAS BEEN CLEARED.
; PIECE-MOVED,,ORIGIN AND PIECE-CAPT,,DESTINATION HAVE BOTH BEEN PUSHED.
; PEX OF CAPTED P HAS BEEN CLEARED. 
;TO DO SPECIALLY:  CAPTING PIECE MUST BE PUT DOWN ON GHOST SQUARE, NOT "DESTINATION"
; 			SQUARE.
;		   CAPTED PIECE MUST BE CLEARED ON BOARD SINCE IT WILL NOT GET
;			OVERWRITTEN BY CAPTING PIECE.
PLAY-EP-CAPT:
;THE FOLLOWING INST DOES A SORT OF BYTE OPERATION, GETTING A WORD
; WITH PIECE-CAPTING IN THE LH AND LOCN OF CAPTED PIECE IN THE RH
; PDL-POINTED-TO-BY-PAR IS USED FOR TEMPORARY STORAGE.
		ARRAY:	SQUARE-BUS FROM SIR,
			A-BUS FROM AC[TEMP],	;PIECE CAPTING
			PIECE-BUS FROM LEFT-A-BUS,
			PS-BUS FROM PIECE-BUS--SQUARE-BUS, 
			-> PDL-POINTED-TO-BY-PAR, $
		ALU:	ALU-FCTN[+],
&(WHITE-TO-PLAY)	B-BUS FROM AAC[C-PLUS-10],	;COMPUTE GHOST LOCN
&(BLACK-TO-PLAY)	B-BUS FROM AAC[C-MINUS-10],
&T			A-BUS FROM PDL-POINTED-TO-BY-PAR,	  
			-> AC[TEMP], $
		ARRAY:	A-BUS FROM AC[TEMP],
			PIECE-BUS FROM LEFT-A-BUS,
			SQUARE-BUS FROM RIGHT-A-BUS,
			-> WMOVE, 		;PUT CAPTING PIECE ON GHOST SQ
		      @E-LONG PLAY-EP-CAPT-3 $	;BECAUSE AC -> WMOVE
PLAY-EP-CAPT-3:	ARRAY:	DESTINATION-ARRAY, ORIG-ALL-SQUARES,
			ENABLE-ALL-PIECES, CAPTURE-MODE,
			SQUARE-BUS FROM SIR,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-SCANNER FROM HIS-K-LOCN,
			-> WMOVE,	;CLEAR OUT DESTINATION SQ, CAUSING CAPTED P
			PS-BUS FROM FLAGCELL,	;TO GO AWAY
			-> PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR]
		FLAG-CONTROL[MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS]
		    @KCHK PLAY-CAPT-4|PLAY-CAPT-4A $

;GET HERE FROM REVERT-CAPT-4.  CAPTED PIECE HAS BEEN PUT BACK ON CORRECT SQUARE,
; SO HAS CAPTURING PIECE.  ONLY THING SPECIAL THAT NEEDS TO BE DONE IS CLEAR
; CAPTING PIECE OFF GHOST SQUARE.
;NOTE!! CAN NOT USE AC[TEMP] SINCE VALUE OF PIECE CAPTED STORED THERE!!
;       CAN NOT CLOBBER PDL-POINTED-TO-BY-PAR SINCE THAT NEEDED BY PV STUFF

REVERT-EP-CAPT:	ALU:	ALU-FCTN[+],		;COMPUTE GHOST SQUARE.
			A-BUS FROM PS-BUS,	;SET UP TO PR--SIR
&(WHITE-TO-PLAY)	B-BUS FROM AAC[C-PLUS-10],
&(BLACK-TO-PLAY)	B-BUS FROM AAC[C-MINUS-10],
&T			-> AC[TEMP1] $
		ARRAY-HOLD: REVERT-CAPT-3	;LEAVE ARRAY SET UP TO CONTINUE
			A-BUS FROM AC[TEMP1],
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM RIGHT-A-BUS,
			-> WMOVE		;CLEAR OUT GHOST SQUARE
		    @E-LONG REVERT-CAPT-5 $	;AC -> WMOVE, WHY TAKE A CHANCE?

;GET HERE FROM CAPT-ILL-5 OR 5A. SIMILAR TO REVERT-EP-CAPT
CAPT-ILL-EP-CAPT:
		ALU:	ALU-FCTN[+],
			A-BUS FROM PS-BUS,
&(WHITE-TO-PLAY)	B-BUS FROM AAC[C-PLUS-10],
&(BLACK-TO-PLAY)	B-BUS FROM AAC[C-MINUS-10],
&T			-> PDL-POINTED-TO-BY-PAR $
		ARRAY-HOLD: CAPT-ILL-4
			A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PIECE-BUS FROM NULL-PIECE,
			SQUARE-BUS FROM RIGHT-A-BUS,
			-> WMOVE
		   @POPJ $

SQ-CNT-ERR: 
PLAY-CAPT-ERR: 
REVERT-CAPT-ERR: 
CAPT-ILL-ERR:  
;GEN2CAPT-ERR: 
FOO:		ALU:	-> HALT,			 ;SUPPOSEDLY IMPOSSIBLE CONDITIONS
		     @FOO $ 

;MISSING ROUTINES:
FOO1:		ALU:	-> HALT,			;CAPT OF K POSSIBLE
		     @FOO1 $

&(WHITE-TO-PLAY)

MEM-READ:	ALU:	INITIATE-UNIBUS-READ-CYCLE $ 	;READ UNIBUS ADR IN UAR.
		ALU:	O-BUS FROM A-BUS,
			A-BUS FROM UAR,			;LEAVE OLD UAR IN AC[TEMP1]
			-> AC[TEMP1] $		;TAKES ONE CYCLE FOR UNIBUS TO START
MEM-WAIT:	ALU:	NO-OP
		     @UNIBUS-CYCLE MEM-READ-DONE|MEM-WAIT $
MEM-READ-DONE:	ALU:	ALU-FCTN[+],
			A-BUS FROM IMMEDIATE-DATA[1],
			B-BUS FROM AC[TEMP1],
			-> UAR $			;INCREMENT UAR
		ALU:	O-BUS FROM UDR,			;RETURN DATA IN AC[TEMP]
			-> AC[TEMP],			;AS WELL AS UDR
		     @POPJ $

MEM-WRITEBACK:	ALU:	O-BUS FROM AC[TEMP1],		;ENTER HERE TO WRITE-BACK
			-> UAR $			; LOCATION JUST READ
MEM-WRITE:	ALU:	INITIATE-UNIBUS-WRITE-CYCLE $	;WRITE UNIBUS, ADR IN UAR
		ALU:	O-BUS FROM UAR, 		;ALLOW UNIBUS TO START
			-> AC[TEMP1] $
MEM-WRITE-WAIT:	ALU:	NO-OP,		;DONT TRY TO OVERLAP SINCE UAR AND UDR MUST
		     @UNIBUS-CYCLE MEM-WRITE-DONE|MEM-WRITE-WAIT $	;REMAIN SET UP
MEM-WRITE-DONE:	ALU:	ALU-FCTN [+],	;INCR UAR FOR NEXT TIME
			B-BUS FROM AC[TEMP1]
			A-BUS FROM IMMEDIATE-DATA[1]
			-> UAR
		     @POPJ $
;LOAD POSITION FROM STANDARD PARAMTER BLOCK POINTED TO BY AC[TEMP1]
; (NORMALLY, TEMP1 HAS JUST BEEN LOADED FROM UAR BY MEM-READ)
LOAD-POSITION:	ALU:	ALU-FCTN[+],
			B-BUS FROM AC[TEMP1],		;GET READY TO READ WD2 OF BLOCK
			A-BUS FROM IMMEDIATE-DATA[2],
			-> UAR
		     @PUSHJ MEM-READ $	;READ BITS AND MODES WD
		ALU:	O-BUS FROM AC[TEMP],
			-> AC[VALUE] 		;KEEP THAT IN AC[VALUE]
	FLAG-CONTROL[FORCE-WHITE-TO-MOVE],
		     @O-BUS-15 LOAD-P-WTM|LOAD-P-BTM $
LOAD-P-BTM:	ALU:	NO-OP,
	FLAG-CONTROL[FORCE-BLACK-TO-MOVE] $
LOAD-P-WTM:	ALU:	O-BUS FROM AC[VALUE],	;KEEP COPY FOR FUTURE REFERENCE ..
			-> PDL[BITS-AND-MODES]
		     @PUSHJ MEM-READ $		;START READING DEPTH
		ALU:	O-BUS FROM AC[TEMP], -> PDL[DEEP-PARAMETER],
			@ INHIBIT-WRITE-IF-BRANCH,	;DONT LOAD DEPTH IF NEGATIVE
		     O-BUS-15 LOAD-POS-2|LOAD-POS-2 $
LOAD-POS-2:	ALU:	ALU-FCTN[SETZ], -> AC[MATERIAL],	;CLEAR OUT AC[MATERIAL]
		     @PUSHJ MEM-READ $		;START READING INIT ALPHA
		ALU:	O-BUS FROM AC[TEMP],
			-> AC[ALPHA],
		     @PUSHJ MEM-READ $		;START READING INIT BETA
		ALU:	O-BUS FROM AC[TEMP],
			-> AC[BETA],
		     @PUSHJ MEM-READ $		;START READING INIT FLAGWORD
		ALU:	O-BUS FROM AC[TEMP],
			-> FLAGCELL 
		     @PUSHJ CLEAR-POSITION $
		ALU:	ALU-FCTN[+],
			A-BUS FROM IMMEDIATE-DATA[31],	;SKIP OVER UNREAD WORDS
			B-BUS FROM AC[TEMP1],
			-> UAR, @PUSHJ SET-PP-TYP $	;SET TYP AND VAL
							  ; FOR PROMOTED PAWNS
							;DROP INTO LOAD-PIECES
LOAD-PIECES:	ALU:	NO-OP,				;LOAD A PIECE FROM UNIBUS
		     @PUSHJ MEM-READ $			; MEM STARTING AT ADR IN UAR
		ALU:	ALU-FCTN[SET-C-B],		;ALU-FCTN SETS FLAGS ONLY
			B-BUS FROM AC[TEMP],		; KEEP TRACK OF MATERIAL IN
			A-BUS FROM AC[TEMP],		; AC[MATERIAL]
			-> PR-SR $			; LOADS FROM A-BUS NOT O-BUS
		ALU:	ALU-FCTN[OR-C-A],
			A-BUS FROM PDL[HW-CONST 60 0],
			B-BUS FROM AC[TEMP],		; RESULT -1 IF PROMOTED PAWN
			@ALU-EQUAL LOAD-PC-1|CPOPJ $	; 0 TERMINATES PIECE LIST
LOAD-PC-1:	ALU:	ALU-FCTN[OR-C-A],		;DIG OUT COLOR BIT OF PC #
			B-BUS FROM AC[TEMP],
			A-BUS FROM PDL[HW-CONST 10 0],
			O-BUS FROM ALU-SWAPPED,
			-> AC[TEMP1],			;-1 IF BLACK TO MOVE
		     @ALU-EQUAL LOAD-PC-2|LOAD-PROMOTED-PAWN $
LOAD-PROMOTED-PAWN:
		ALU:	ALU-FCTN[AND], A-BUS FROM IMMEDIATE-DATA[300],
			B-BUS FROM AC[TEMP], -> AC[TEMP] $
		ALU:	ALU-FCTN[B-PLUS-B], B-BUS FROM AC[TEMP], -> AC[TEMP] $
		ALU:	ALU-FCTN[B-PLUS-B], B-BUS FROM AC[TEMP],
			O-BUS FROM ALU-SWAPPED, -> AC[TEMP] $
		ALU:	ALU-FCTN[+], A-BUS FROM IMMEDIATE-DATA[PDL-Q-VAL-REG],
			B-BUS FROM AC[TEMP], -> AAC[PAR] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, -> PIECE-VALUE $
		ALU:	ALU-FCTN[+], A-BUS FROM IMMEDIATE-DATA[130], ; (- 202 PDL-Q-VAL-REG)
			B-BUS FROM AAC[PAR], -> AC[TEMP] $
		ALU:	O-BUS FROM AC[TEMP1] $
		ALU:	NO-OP, @ALU-EQUAL LOAD-W-PR-PAWN|LOAD-B-PR-PAWN $
LOAD-W-PR-PAWN:	ALU:	O-BUS FROM AC[TEMP], -> PIECE-TYPE, @LOAD-PC-2 $
LOAD-B-PR-PAWN:	ALU:	ALU-FCTN[IOR], A-BUS FROM IMMEDIATE-DATA[100],
			B-BUS FROM AC[TEMP], -> PIECE-TYPE, @LOAD-PC-2 $

LOAD-PC-2:	ALU:	O-BUS FROM AC[TEMP1] $
		ARRAY:	PIECE-BUS FROM PR,
			SQUARE-BUS FROM SR,
			-> WMOVE,
			SET-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER,
			PS-BUS FROM PIECE-VALUE 
		     @E-LONG ALU-EQUAL LOAD-W-PC|LOAD-B-PC $
LOAD-W-PC:	ALU:	ALU-FCTN[+],
			B-BUS FROM AC[MATERIAL],
			A-BUS FROM PS-BUS,
			-> AC[MATERIAL],
		     @LOAD-PIECES $
LOAD-B-PC:	ALU:	ALU-FCTN[-],
			B-BUS FROM AC[MATERIAL],
			A-BUS FROM PS-BUS,
			-> AC[MATERIAL],
		     @LOAD-PIECES $

LOAD-POSITION-ERR:
		ALU:	-> HALT
		     @LOAD-POSITION-ERR $

CLEAR-POSITION:	ALU:	O-BUS FROM IMMEDIATE-DATA[0],	;CLEAR ALL PIECE-EXISTS BITS
			-> AC[WDEPTH] $			;AND ALL SQUARES ON BOARD.
C-P-1:		ARRAY:	A-BUS FROM AC[WDEPTH],		;USES WDEPTH TO COUNT SQUARE
			SQUARE-BUS FROM A-BUS,
			PIECE-BUS FROM NULL-PIECE,
			-> WMOVE,
		     @E-LONG C-P-2 $
C-P-2:		ARRAY:	A-BUS FROM AC[WDEPTH],
			PIECE-BUS FROM A-BUS,
			ZERO-PIECE-EXISTS-BIT,
			-> PIECE-EXISTS-REGISTER $
		ALU:	ALU-FCTN[B-A-1],
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[HW-CONST 77 77] $
		ALU:	ALU-FCTN[+]
			B-BUS FROM AC[WDEPTH],
			A-BUS FROM PDL[HW-CONST 1 1],
			-> AC[WDEPTH],
		     @ALU-EQUAL C-P-1|CPOPJ $
SET-PP-TYP:	ARRAY:	PIECE-BUS FROM LEFT-A-BUS $
		ALU:	ALU-FCTN[SET-A], A-BUS FROM IMMEDIATE-DATA[60],
			O-BUS FROM ALU-SWAPPED, -> AC[TEMP] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[QUEEN-VALUE], -> AAC[C-PLUS-10] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[202], -> AC[TEMP1], @PUSHJ SET-PP-TYP-2 $
		ALU:	O-BUS FROM IMMEDIATE-DATA[302], -> AC[TEMP1] $
SET-PP-TYP-2:	ALU:	O-BUS FROM IMMEDIATE-DATA[7], -> AC[VALUE] $
SET-PP-TYP-3:	ALU:	ALU-FCTN[SET-B], A-BUS FROM AC[TEMP],
			B-BUS FROM AC[TEMP1], -> PIECE-TYPE,
			@ INHIBIT-WRITE-IF-BRANCH ALU-EQUAL SET-PP-TYP-4|CPOPJ $
SET-PP-TYP-4:	ALU:	ALU-FCTN[SET-B], A-BUS FROM AC[TEMP],
			B-BUS FROM AAC[C-PLUS-10], -> PIECE-VALUE $
		ALU:	ALU-FCTN[+], A-BUS FROM PDL[HW-CONST 1 0],
			B-BUS FROM AC[TEMP], -> AC[TEMP] $
		ALU:	ALU-FCTN[DEC-B], B-BUS FROM AC[VALUE], -> AC[VALUE],
			@ SET-PP-TYP-3 $

; PAWN STRUCTURE FUNCTION
; COUNTS NUMBER OF FILES WITH ISOLATED OR DOUBLED PAWNS

PAWN-S-F:	ALU:	O-BUS FROM IMMEDIATE-DATA[PAWN-FILES] -> AAC[PAR] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[10] -> AAC[C-PLUS-10] $
PAWN-S-F-2:	ALU:	ALU-FCTN[SETZ] -> PDL-POINTED-TO-BY-PAR
			PAF[+1 -> PAR] @ALU-EQUAL PAWN-S-F-3|PAWN-S-F-4 $
PAWN-S-F-3:	ALU:	ALU-FCTN[DEC-B] B-BUS FROM AAC[C-PLUS-10]
			-> AAC[C-PLUS-10] @ PAWN-S-F-2 $

PAWN-S-F-4:	ARRAY:	PIECE-SCANNER FROM PR, PR FROM NEXT-PIECE,
			-> PR, PS-BUS FROM PIECE-LOC,
			PIECE-BUS FROM PR,
			@ ANY-MORE-PIECES PAWN-S-F-6|PAWN-S-F-5 $
PAWN-S-F-5:	ALU:	O-BUS FROM PS-BUS, -> AC[TEMP] $
		ALU:	ALU-FCTN[AND], A-BUS FROM IMMEDIATE-DATA[7],
			B-BUS FROM AC[TEMP], -> AC[TEMP] $
		ALU:	ALU-FCTN[+], A-BUS FROM IMMEDIATE-DATA[PAWN-FILES-1],
			B-BUS FROM AC[TEMP], -> AAC[PAR] $
		ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, -> AC[TEMP] $
		ALU:	ALU-FCTN[DEC-B], B-BUS FROM AC[TEMP], 
			-> PDL-POINTED-TO-BY-PAR, @PAWN-S-F-4 $

PAWN-S-F-6:	ALU:	ALU-FCTN[SETZ], -> AC[TEMP1] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[PAWN-FILES-1], -> AAC[PAR] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[7], -> AAC[C-PLUS-10] $
PAWN-S-F-7:	ALU:	ALU-FCTN[SET-A], A-BUS FROM PDL-POINTED-TO-BY-PAR,
			PAF[+1 -> PAR], @ ALU-EQUAL PAWN-S-F-7A|CPOPJ $
PAWN-S-F-7A:	ALU:	@ ALU-LESS+ALU-LESS-OR-EQUAL
			PAWN-S-F-10|PAWN-S-F-8A|FOO|PAWN-S-F-8 $
PAWN-S-F-8:	ALU:	ALU-FCTN[+], A-BUS FROM PDL[DBL-PWN-VAL],
			B-BUS FROM AC[TEMP1], -> AC[TEMP1],
			PAF[-2 -> PAR] $
PAWN-S-F-9:	ALU:	O-BUS FROM PDL-POINTED-TO-BY-PAR, -> AC[TEMP],
			PAF[+2 -> PAR] $
		ALU:	ALU-FCTN[IOR], A-BUS FROM PDL-POINTED-TO-BY-PAR,
			B-BUS FROM AC[TEMP] $
		ALU:	ALU-FCTN[+], A-BUS FROM PDL[ISOL-PWN-VAL],
			B-BUS FROM AC[TEMP1], -> AC[TEMP1],
			@ INHIBIT-WRITE-IF-BRANCH, 
			 ALU-LESS-OR-EQUAL PAWN-S-F-10|PAWN-S-F-10 $
PAWN-S-F-10:	ALU:	ALU-FCTN[DEC-B], B-BUS FROM AAC[C-PLUS-10],
			-> AAC[C-PLUS-10], @PAWN-S-F-7 $
PAWN-S-F-8A:	ALU:	PAF[-2 -> PAR], @PAWN-S-F-9 $

PAWN-STR-FCTN:	ALU:	O-BUS FROM PDL[BITS-AND-MODES] $
		ALU:	O-BUS FROM AC[MATERIAL], -> AC[TEMP1],
			@O-BUS-0 CPOPJ|PAWN-STR-1 $
PAWN-STR-1:	ALU:	A-BUS FROM PDL[HW-CONST WHITE-NULL-PAWN 0], -> PR-SR
			PAF[PAR -> PAR-SV] $
		ARRAY:	PIECE-SCANNER FROM PR, @PUSHJ PAWN-S-F $
		ALU:	O-BUS FROM AC[TEMP1], -> PDL[PDL-TEM] $
		ALU:	A-BUS FROM PDL[HW-CONST BLACK-NULL-PAWN 0], -> PR-SR
			@PUSHJ PAWN-S-F $
		ALU:	ALU-FCTN[-], B-BUS FROM AC[TEMP1],
			A-BUS FROM PDL[PDL-TEM], -> AC[TEMP1] $
		ALU:	ALU-FCTN[+], A-BUS FROM AC[MATERIAL],
			B-BUS FROM AC[TEMP1], -> AC[TEMP1],
			PAF[PAR-SV -> PAR] $
		ALU:	O-BUS FROM IMMEDIATE-DATA[10], -> AAC[C-PLUS-10], @ POPJ $

DEBUG-TEST:	ARRAY:	PIECE-BUS FROM LEFT-A-BUS,
			PS-BUS FROM PIECE-TYPE $
		ALU:	A-BUS FROM PDL[HW-CONST 40 0],
			O-BUS FROM PS-BUS, -> AC[TEMP1] $
		ALU:	ALU-FCTN[OR-C-A], A-BUS FROM IMMEDIATE-DATA[201],
			B-BUS FROM AC[TEMP1] $
		ALU:	O-BUS FROM PDL[BITS-AND-MODES], @ ALU-EQUAL DEBUG2|CPOPJ $
DEBUG2:		ALU:	-> HALT, @ DEBUG2$
&T  
