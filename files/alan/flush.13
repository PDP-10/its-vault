;;;-*-lisp-*-

(mapatoms
 '(lambda (x)
	  ((lambda (p)
		   (and (not (atom p))
			(memq (cadr p)
			      '(defmax backq let defmacro lodbyt
				defvst defsetf setf sharpm macaid cgol))
			(remprop x 'autoload)))
	   (get x 'autoload))))

(declare (load '|alan;flush >|))

;;;BACKQUOTE:
;;; The flags passed back by BACKQUOTIFY can be interpreted as follows:
;;;
;;;   |`,|: [a] => a
;;;    NIL: [a] => a			;the NIL flag is used only when a is NIL
;;;      T: [a] => a			;the T flag is used when a is self-evaluating
;;;  QUOTE: [a] => (QUOTE a)
;;; APPEND: [a] => (APPEND . a)
;;;  NCONC: [a] => (NCONC . a)
;;;   LIST: [a] => (LIST . a)
;;;  LIST*: [a] => (LIST* . a)
;;;
;;; The flags are combined according to the following set of rules:
;;;  ([a] means that a should be converted according to the previous table)
;;;
;;;    \ car   ||    otherwise    |    QUOTE or     |     |`,@|      |     |`,.|      |
;;;  cdr \     ||		  |    T or NIL     |                |		      |
;;;====================================================================================
;;;    |`,|    || LIST* ([a] [d]) | LIST* ([a] [d]) | APPEND (a [d]) | NCONC  (a [d]) |
;;;    NIL     || LIST    ([a])   | QUOTE    (a)    | <hair>    a    | <hair>    a    |
;;; QUOTE or T || LIST* ([a] [d]) | QUOTE  (a . d)  | APPEND (a [d]) | NCONC  (a [d]) |
;;;   APPEND   || LIST* ([a] [d]) | LIST* ([a] [d]) | APPEND (a . d) | NCONC  (a [d]) |
;;;   NCONC    || LIST* ([a] [d]) | LIST* ([a] [d]) | APPEND (a [d]) | NCONC  (a . d) |
;;;    LIST    || LIST  ([a] . d) | LIST  ([a] . d) | APPEND (a [d]) | NCONC  (a [d]) |
;;;    LIST*   || LIST* ([a] . d) | LIST* ([a] . d) | APPEND (a [d]) | NCONC  (a [d]) |
;;;
;;;<hair> involves starting over again pretending you had read ".,a)" instead of ",@a)"

(setsyntax '/` 'macro 'xr-backquote-macro)

(setsyntax '/, 'macro 'xr-comma-macro)

(declare (special **backquote-count** **backquote-flag**
		  **backquote-/,-flag** **backquote-/,/@-flag** **backquote-/,/.-flag**))

(setq **backquote-count** 0
      **backquote-/,-flag** (copysymbol '|`,| nil)
      **backquote-/,/@-flag** (copysymbol '|`,@| nil)
      **backquote-/,/.-flag** (copysymbol '|`,.| nil)
      )

(defun xr-backquote-macro ()
       ((lambda (**backquote-count** **backquote-flag** thing)
		(setq thing (backquotify (read)))
		(cond ((eq **backquote-flag** **backquote-/,/@-flag**)
		       (error '|-- ",@" right after a "`".| thing))
		      ((eq **backquote-flag** **backquote-/,/.-flag**)
		       (error '|-- ",." right after a "`".| thing))
		      (t
		       (backquotify-1 **backquote-flag** thing))))
	(1+ **backquote-count**)
	nil
	nil))

(defun xr-comma-macro ()
       (or (> **backquote-count** 0)
	   (error '|Comma not inside a backquote.|))
       ((lambda (c **backquote-count**)
		(cond ((= c 100)			;#/@
		       (tyi)
		       (cons **backquote-/,/@-flag** (read)))
		      ((= c 56)				;#/.
		       (tyi)
		       (cons **backquote-/,/.-flag** (read)))
		      (t (cons **backquote-/,-flag** (read)))))
	(tyipeek)
	(1- **backquote-count**)))

(defun backquotify (code)
       (prog (aflag a dflag d)
	     (cond ((atom code)
		    (cond ((null code)
			   (setq **backquote-flag** nil)
			   (return nil))
			  ((or (numberp code)
			       (eq code t))
			   (setq **backquote-flag** t)
			   (return code))
			  (t (setq **backquote-flag** 'quote)
			     (return code))))
		   ((eq (car code) **backquote-/,-flag**)
		    (setq code (cdr code))
		    (go comma))
		   ((eq (car code) **backquote-/,/@-flag**)
		    (setq **backquote-flag** **backquote-/,/@-flag**)
		    (return (cdr code)))
		   ((eq (car code) **backquote-/,/.-flag**)
		    (setq **backquote-flag** **backquote-/,/.-flag**)
		    (return (cdr code))))
             (setq a (backquotify (car code)))
	     (setq aflag **backquote-flag**)
	     (setq d (backquotify (cdr code)))
	     (setq dflag **backquote-flag**)
	     (and (eq dflag **backquote-/,/@-flag**)
		  (error '|-- ",@" after a ".".| code))
	     (and (eq dflag **backquote-/,/.-flag**)
		  (error '|-- ",." after a ".".| code))
	     (cond ((eq aflag **backquote-/,/@-flag**)
		    (cond ((null dflag)
			   (setq code a)
			   (go comma)))
		    (setq **backquote-flag** 'append)
		    (return (cond ((eq dflag 'append)
				   (cons a d))
				  (t (list a (backquotify-1 dflag d))))))
		   ((eq aflag **backquote-/,/.-flag**)
		    (cond ((null dflag)
			   (setq code a)
			   (go comma)))
		    (setq **backquote-flag** 'nconc)
		    (return (cond ((eq dflag 'nconc)
				   (cons a d))
				  (t (list a (backquotify-1 dflag d))))))
		   ((null dflag)
		    (cond ((memq aflag '(quote t nil))
			   (setq **backquote-flag** 'quote)
			   (return (list a)))
			  (t (setq **backquote-flag** 'list)
			     (return (list (backquotify-1 aflag a))))))
		   ((memq dflag '(quote t))
		    (cond ((memq aflag '(quote t nil))
			   (setq **backquote-flag** 'quote)
			   (return (cons a d)))
			  (t (setq **backquote-flag** 'list*)
			     (return (list (backquotify-1 aflag a)
					   (backquotify-1 dflag d)))))))
	     (setq a (backquotify-1 aflag a))
	     (and (memq dflag '(list list*))
		  (setq **backquote-flag** dflag)
		  (return (cons a d)))
	     (setq **backquote-flag** 'list*)
	     (return (list a (backquotify-1 dflag d)))
       comma (cond ((atom code)
		    (cond ((null code)
			   (setq **backquote-flag** nil)
			   (return nil))
			  ((or (numberp code)
			       (eq code 't))
			   (setq **backquote-flag** t)
			   (return code))
			  (t (setq **backquote-flag**
				   **backquote-/,-flag**)
			     (return code))))
		   ((eq (car code) 'quote)
		    (setq **backquote-flag** 'quote)
		    (return (cadr code)))
		   ((memq (car code) '(append list list* nconc))
		    (setq **backquote-flag** (car code))
		    (return (cdr code)))
		   ((eq (car code) 'cons)
		    (setq **backquote-flag** 'list*)
		    (return (cdr code)))
		   (t (setq **backquote-flag** **backquote-/,-flag**)
		      (return code)))))

(defun backquotify-1 (flag thing)
       (cond ((or (eq flag **backquote-/,-flag**)
		  (memq flag '(t nil)))
	      thing)
	     ((eq flag 'quote)
	      (list 'quote thing))
	     ((eq flag 'list*)
	      (cond ((null (cddr thing))
		     (cons 'cons thing))
		    (t (cons 'list* thing))))
	     (t (cons flag thing))))

(declare (special let-macro-vals))

(defun (let macro) (x)
       (do ((body (cddr x))
	    (pairs (reverse (cadr x)) (cdr pairs))
	    (vars nil)
	    (let-macro-vals nil)
	    (tem))
	   ((null pairs)
	    (displace x
		      (cond ((not (null vars))
			     `((lambda ,vars . ,body) . ,let-macro-vals))
			    ((null (cdr body))
			     (car body))
			    (t `(progn . ,body)))))
	   (cond ((atom (car pairs))
		  (or (symbolp (car pairs))
		      (error '|-- gubbish found in LET pattern.| (car pairs)))
		  (setq vars (cons (car pairs) vars))
		  (setq let-macro-vals (cons nil let-macro-vals)))
		 (t
		  (setq tem vars)
		  (setq vars (let-macro-get-vars (caar pairs) vars))
		  (or (eq tem vars)
		      (setq body (nconc (let-macro-hair (caar pairs)
							(cadar pairs)
							let-macro-vals)
					body)))))))

(defun let-macro-get-vars (pattern vars)
       (cond ((null pattern) vars)
	     ((atom pattern)
	      (or (symbolp pattern)
		  (error '|-- gubbish found in LET pattern.| pattern))
	      (setq let-macro-vals (cons nil let-macro-vals))
	      (cons pattern vars))
	     (t (let-macro-get-vars (cdr pattern)
				    (let-macro-get-vars (car pattern) vars)))))

(defun (desetq macro) (x)
       (do ((p (cdr x) (cddr p))
	    (body nil)
	    tem)
	   ((null p)
	    (displace x `(progn . ,body)))
	   (cond ((atom (cdr p))
		  (error '|-- odd number of args to DESETQ.| x))
		 ((atom (car p))
		  (or (symbolp (car p))
		      (error '|-- gubbish found in DESETQ pattern.| (car p)))
		  (and (null (car p))
		       (error '|-- bad DESETQ pattern.| (car p)))
		  (setq body (nconc body `((setq ,(car p) ,(cadr p))))))
		 (t
		  (setq tem (cons nil nil))
		  (setq body (nconc body
				    `((setq ,(let-macro-get-last-var (car p))
					    . ,tem)
				      . ,(let-macro-hair (car p) (cadr p) tem))))))))
				    
(defun let-macro-get-last-var (pattern)
       (cond ((atom pattern) pattern)
	     (t
	      (or (let-macro-get-last-var (cdr pattern))
		  (let-macro-get-last-var (car pattern))))))

(defun let-macro-hair (pattern code cell)
       (cond ((null pattern) nil)
	     ((atom pattern)
	      (rplaca cell code)
	      nil)
	     (t
	      ((lambda (avar dvar)
		    (cond ((null avar)
			   (cond ((null dvar) nil)
				 (t (let-macro-hair (cdr pattern)
						    `(cdr ,code)
						    cell))))
			  ((null dvar)
			   (let-macro-hair (car pattern)
					   `(car ,code)
					   cell))
			  (t
			   (rplaca cell code)
			   ((lambda (acell dcell)
				 (cons `(setq ,avar . ,acell)
				       (nconc (let-macro-hair (car pattern)
							      `(car ,dvar)
							      acell)
					      (cons `(setq ,dvar . ,dcell)
						    (let-macro-hair (cdr pattern)
								    `(cdr ,dvar)
								    dcell)))))
			    (cons nil nil)
			    (cons nil nil)))))
	       (let-macro-get-last-var (car pattern))
	       (let-macro-get-last-var (cdr pattern))))))

(defun (let* macro) (x)
       (do ((a (reverse (cadr x)) (cdr a))
	    (b (cddr x) `((let (,(car a)) . ,b))))
	   ((null a)
	    (displace x
		      (cond ((null (cdr b)) (car b))
			    (t `(progn . ,b)))))))

(defun (defmacro macro) (x)
   (let (((nil name pattern . body) x)
	 (var (gensym))
	 normal optional rest tail check-args)
	(prog (pat x)
	      (setq pat pattern)
	 norm (cond ((null pat) (return t))
		    ((atom pat) (setq rest pat) (return t)))
	      (setq x (car pat))
	      (cond ((eq x '&optional)
		     (go opt))
		    ((eq x '&rest)
		     (go rst))
		    ((eq x '&aux)
		     (go ax)))
	      (setq normal (cons x normal)
		    pat (cdr pat))
	      (go norm)
	  opt (cond ((null (setq pat (cdr pat))) (return t))
		    ((atom pat) (setq rest pat) (return t)))
	      (setq x (car pat))
	      (cond ((eq x '&optional)
		     (go barf))
		    ((eq x '&rest)
		     (go rst))
		    ((eq x '&aux)
		     (go ax)))
	      (cond ((atom x)
		     (setq optional (cons (list x nil) optional)))
		    (t
		     (setq optional (cons x optional))))
	      (go opt)
	  rst (or (and (not (null (setq pat (cdr pat))))
		       (not (atom pat))
		       (atom (setq x (car pat))))
		  (go barf))
	      (setq rest x)
	      (or (setq pat (cdr pat))
		  (return t))
	      (and (or (atom pat)
		       (not (eq (car pat) '&aux)))
		   (go barf))
	   ax (setq body `((let* ,(cdr pat) . ,body)))
	      (return t)
	 barf (error '|-- bad pattern to DEFMACRO.| pattern))
	(setq check-args (length normal))
	(setq normal
	      (nreconc normal
		       (cond ((null optional) rest)
			     (t (setq tail (gensym))))))
	(setq check-args
	      (let ((cnd (cond ((null rest)
				(cond ((null tail)
				       `(= (length ,var) ,(1+ check-args)))
				      (t
				       `(and (> (length ,var)
						,check-args)
					     (< (length ,var)
						,(+ 2
						    check-args
						    (length optional)))))))
			       ((null normal) nil)
			       (t `(> (length ,var) ,check-args)))))
		   (and cnd
			`((or ,cnd
			      (error '|-- wrong number of args in macro form|
				     ,var))))))
	`(defun (,name macro) (,var)
	    (comment ,pattern)
	    ,@check-args
	    (displace
	     ,var
	     (let ((,normal (cdr ,var)))
		  . ,(cond (tail
			    (do ((o optional (cdr o))
				 (first t nil)
				 (b (cond (rest
					   `((let ((,rest (cdr ,tail)))
						  . ,body)))
					  (t body))
				    `((let ((,(caar o)
					     (cond (,(cond ((null (cdr o))
							    tail)
							   (t
							    `(setq ,tail (cdr ,tail))))
						    (car ,tail))
						   (t ,(cadar o)))))
					   . ,b))))
				((null o) b)))
			   (t body)))))
	))

;A winning macro to store things anywhere:
(defun (setf macro) (qc-sux)				;(expr val)
    (prog (head y expr val)
	  (or (= 3 (length qc-sux))
	      (error '|-- wrong number of args (SETF).| qc-sux))
	  (setq expr (cadr qc-sux))
	  (setq val (caddr qc-sux))
	  (go A)
	B (setq expr (funcall (cadr y) expr))
	A (cond ((atom expr)
		 (or (symbolp expr)
		     (error '|-- SETF can't handle this.| expr))
		 (return (displace qc-sux `(setq ,expr ,val)))))
	  (setq head (car expr))
	  (or (symbolp head)
	      (error '|-- SETF can't handle this.| expr))
	  (and (setq y (get head 'setf))
	       (return (displace qc-sux (funcall y expr val))))
	  (setq y (getl head '(macro autoload subr lsubr
			       expr fsubr fexpr array)))
	  (and (eq (car y) 'macro)
	       (go B))
	  (or (eq (car y) 'autoload)
	      (error '|-- SETF can't handle this.| expr))
	  (load (cadr y))
	  (and (setq y (get head 'setf))
	       (return (displace qc-sux (funcall y expr val))))
	  (setq y (getl head '(macro autoload subr lsubr
			       expr fsubr fexpr array)))
	  (cond ((eq (car y) 'macro)
		 (go B))
		(t
		 (error '|-- SETF can't handle this.| expr)))))

(defun car-cdr/ setf (x v)
       (let ((p (get (car x) 'car-cdr/ setf)))
	    `(,(car p) (,(cdr p) ,(cadr x)) ,v)))

(putprop 'caar '(rplaca . car) 'car-cdr/ setf)
(putprop 'caar 'car-cdr/ setf 'setf)
(putprop 'cdar '(rplacd . car) 'car-cdr/ setf)
(putprop 'cdar 'car-cdr/ setf 'setf)
(putprop 'cadr '(rplaca . cdr) 'car-cdr/ setf)
(putprop 'cadr 'car-cdr/ setf 'setf)
(putprop 'cddr '(rplacd . cdr) 'car-cdr/ setf)
(putprop 'cddr 'car-cdr/ setf 'setf)
(putprop 'caaar '(rplaca . caar) 'car-cdr/ setf)
(putprop 'caaar 'car-cdr/ setf 'setf)
(putprop 'cdaar '(rplacd . caar) 'car-cdr/ setf)
(putprop 'cdaar 'car-cdr/ setf 'setf)
(putprop 'cadar '(rplaca . cdar) 'car-cdr/ setf)
(putprop 'cadar 'car-cdr/ setf 'setf)
(putprop 'cddar '(rplacd . cdar) 'car-cdr/ setf)
(putprop 'cddar 'car-cdr/ setf 'setf)
(putprop 'caadr '(rplaca . cadr) 'car-cdr/ setf)
(putprop 'caadr 'car-cdr/ setf 'setf)
(putprop 'cdadr '(rplacd . cadr) 'car-cdr/ setf)
(putprop 'cdadr 'car-cdr/ setf 'setf)
(putprop 'caddr '(rplaca . cddr) 'car-cdr/ setf)
(putprop 'caddr 'car-cdr/ setf 'setf)
(putprop 'cdddr '(rplacd . cddr) 'car-cdr/ setf)
(putprop 'cdddr 'car-cdr/ setf 'setf)
(putprop 'caaaar '(rplaca . caaar) 'car-cdr/ setf)
(putprop 'caaaar 'car-cdr/ setf 'setf)
(putprop 'cdaaar '(rplacd . caaar) 'car-cdr/ setf)
(putprop 'cdaaar 'car-cdr/ setf 'setf)
(putprop 'cadaar '(rplaca . cdaar) 'car-cdr/ setf)
(putprop 'cadaar 'car-cdr/ setf 'setf)
(putprop 'cddaar '(rplacd . cdaar) 'car-cdr/ setf)
(putprop 'cddaar 'car-cdr/ setf 'setf)
(putprop 'caadar '(rplaca . cadar) 'car-cdr/ setf)
(putprop 'caadar 'car-cdr/ setf 'setf)
(putprop 'cdadar '(rplacd . cadar) 'car-cdr/ setf)
(putprop 'cdadar 'car-cdr/ setf 'setf)
(putprop 'caddar '(rplaca . cddar) 'car-cdr/ setf)
(putprop 'caddar 'car-cdr/ setf 'setf)
(putprop 'cdddar '(rplacd . cddar) 'car-cdr/ setf)
(putprop 'cdddar 'car-cdr/ setf 'setf)
(putprop 'caaadr '(rplaca . caadr) 'car-cdr/ setf)
(putprop 'caaadr 'car-cdr/ setf 'setf)
(putprop 'cdaadr '(rplacd . caadr) 'car-cdr/ setf)
(putprop 'cdaadr 'car-cdr/ setf 'setf)
(putprop 'cadadr '(rplaca . cdadr) 'car-cdr/ setf)
(putprop 'cadadr 'car-cdr/ setf 'setf)
(putprop 'cddadr '(rplacd . cdadr) 'car-cdr/ setf)
(putprop 'cddadr 'car-cdr/ setf 'setf)
(putprop 'caaddr '(rplaca . caddr) 'car-cdr/ setf)
(putprop 'caaddr 'car-cdr/ setf 'setf)
(putprop 'cdaddr '(rplacd . caddr) 'car-cdr/ setf)
(putprop 'cdaddr 'car-cdr/ setf 'setf)
(putprop 'cadddr '(rplaca . cdddr) 'car-cdr/ setf)
(putprop 'cadddr 'car-cdr/ setf 'setf)
(putprop 'cddddr '(rplacd . cdddr) 'car-cdr/ setf)
(putprop 'cddddr 'car-cdr/ setf 'setf)

(defmacro defsetf (name pat var . body)
     (let ((sym (gensym)))
	  `(defun (,name setf) (,sym ,var)
		  (let ((,pat (cdr ,sym)))
		       . ,body))))

(defsetf car (x) v `(rplaca ,x ,v))

(defsetf cdr (x) v `(rplacd ,x ,v))

(defsetf cxr (n x) v `(rplacx ,n ,x ,v))

(defsetf nth (n x) v `(rplaca (nthcdr ,n ,x) ,v))

(defsetf arraycall tail v `(store (arraycall . ,tail) ,v))

(defsetf get (sym ind) v `(putprop ,sym ,v ,ind))

(defsetf plist (x) v `(setplist ,x ,v))

(defsetf symeval (x) v `(set ,x ,v))

(defsetf arg (x) v `(setarg ,x ,v))

(defsetf args (x) v `(args ,x ,v))

(defsetf sfa-get (sfa n) v `(sfa-store ,sfa ,n ,v))

(defsetf ldb (ppss x) v `(setf ,x (dpb ,v ,ppss ,x)))

(defsetf xcar (x) v `(xrplaca ,x ,v))

(defsetf xcdr (x) v `(xrplacd ,x ,v))

(defsetf xcxr (n x) v `(xrplacx ,n ,x ,v))

(defsetf progn body v
	 (or (null (cdr body))
	     (error '|-- SETF can't handle this.| `(progn . ,body)))
	 `(setf ,(car body) ,v))

(defmacro push (item list)
	  `(setf ,list (cons ,item ,list)))

(defmacro pop (x)
	  `(prog1 (car ,x) (setf ,x (cdr ,x))))

(sstatus feature alan/;flush)