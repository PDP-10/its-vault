
;2 DEC 71, 1655:
;DRUM AND DISK DRIVERS AND ALLOCATORS

;DISK PACKAGE- RPO2 DISK PACKS.   D. MURPHY

	INTERN DSKIO,DSKCHK,UDSKIO,CVDSK,CDSKVA,DIDSCI
	EXTERN NOFN,BLOCK1,DSKTIM,DISKP,FPTA,JFNOFN,NXTDMP
	EXTERN SETMPG,SETPT,DBUGSW,PSKED,CORWB,DIDSCA,SWPZPG,DEVMPE

NDVMAX==10		;MAX NUMBER OF DRIVES
DSK=250			;DEVICE NUMBER
DSKCP=62		;COMMAND POINTER

DWRBIT==1B18		;WRITE REQUEST FROM SWAPPER (LH OF AC1)
DSKSIP=1B19		;SEEK IN PROGRESS, LH OF DSKSTS
DSKCMR=1B20		;COMMAND READY, LH OF DSKSTS
DSKUIO=1B21		;UDSKIO TYPE OPERATION, LH OF DSKSTS
DSKIRQ==1B32		;PI REQUEST BIT IN CONI WORD
NEWFB==1B33		;NEW FILE BIT (IN LINEAR ADDRESS)
CLASS0==0		;CLASS FOR FREE BLOCKS
DSKRDA==0B20		;OP CODE FOR READ COMMAND
DSKWDA==1B20		; .. WRITE
DSKPOS==4B20		; .. POSITION (SEEK)
DSKCAT==5B20		; .. CLEAR ATTENTIONS
DSKNOP==6B20		; .. NOP
DSKCAL==7B20		; .. RECALIBRATE

NDSKCM==10		;SIZE OF UDSKIO COMMAND BUFFER
NDSKPD==10		;SIZE OF INTERRUPT PDL
NPD1==20		;SIZE OF LOCAL (MAIN) PDL

;STATUS OF DRIVE IS RECORDED IN DSKSTS
;RH CONTAINS NUMBER OF TRACK AT WHICH DRIVE IS CURRENTLY POSITIONED,
; OR WHICH DRIVE IS SEEKING IN BITS 24-31
; ERROR COUNT IN BITS 32-35
;LH BITS 13-17 ARE AN INDEX INTO THE UDSKIO COMMAND BUFFER
;DSKUIO BIT ON INDICATES UDSKIO TYPE OPERATION
;STATE OF DRIVE IS INDICATED BY DSKSIP AND DSKCMR BITS IN LH
; 00 - NOTHING HAPPENING
; 10 - DRIVE SEEKING TRACK
; 01 - DRIVE POSITIONED, TRANSFER READY TO BE STARTED
; 11 - TRANSFER IN PROGRESS (ALSO USED WHEN REQUEST BEING UNQUEUED)

;STORAGE

LS DSKFCL,1		;FREE LIST FOR UDSKIO REQUEST PAIRS
LS DSKCCT,1		;COUNT OF UDSKIO REQUESTS
LS DSKCL,2*NDSKCM	;COMMAND BUFFER FOR UDSKIO REQUESTS
LS DSKLUN,1		;LAST UNIT XFERRING, -1 IF NO UNIT XFERRING
LS DSKCCM,2		;BUFFER FOR DF10 CHANNEL COMMAND

LS DSKWI,NDVMAX		;WRITE QUEUE IN
LS DSKWO,NDVMAX		;WRITE QUEUE OUT
LS DSKRI,NDVMAX		;READ QUEUE IN
LS DSKRO,NDVMAX		;READ QUEUE OUT
LS DSKUI,NDVMAX		;UTILITY QUEUE IN
LS DSKUO,NDVMAX		;UTILITY QUEUE OUT

LS DSKDAW,NDVMAX	;DISK ADDRESS FOR CURRENT OPERATION
LS DSKCAW,NDVMAX	;CORE ADDRESS AND COUNT FOR CURRENT OPERATION
LS DSKSTS,NDVMAX	;STATUS OF DRIVE,,CURRENT TRACK

LS DSKPD1,NPD1+1	;LOCAL MAIN PDL

LS DSKSVR,1		;INTERRUPT SERVICE RETURN
LS DSKACP,1		;SAVED AC-P
LS DSKPDL,NDSKPD	;INTERRUPT PDL
LS DSKLSV,1		;TIME OF LAST DISK INTERRUPT SERVICE

;DO NOT REORDER ERROR WORDS, USED BY GETAB

NDSKEW==^D10		;NUMBER OF ERROR WORDS FOR GETAB

LS DSKRCE,1		;COUNT OF RECOVERABLE ERRORS
LS DSKRER,4		;COMMAND WORDS AND ERROR BITS OF LAST ERROR
LS DSKNRE,1		;COUNT OF NON-RECOVERABLE ERRORS
LS DSKLER,4		;COMMAND WORDS AND ERROR BITS LAST NON-REC ERR

DSKNTR==^D5		;NUMBER OF TRIES ON RECOVERABLE ERRORS

;DISK I/O DRIVER - CALLED FROM SWAPPER

	RESCD

DSKIO:	MOVEM P,DSKPD1		;SETUP LOCAL STACK
	MOVE P,[XWD -NPD1,DSKPD1]
	PUSH P,1
	MOVE 3,CST2(1)		;SET ABOUT FINDING CLASS
	TLNE 3,-1
	JRST DSKI1
	CAIGE 3,NOFN
	JRST DSKI2
	MOVE 3,SPTH(3)
DSKI1:	HLRZ 3,3
DSKI2:	HLRZ 3,SPTH(3)
	LSH 3,-4
	ANDI 3,777
	MOVE 4,CST1(1)		;GET DISK ADDRESS
	TLNN 4,10		;REGULAR DISK ADDRESS?
	JRST [	PUSH P,1	;NO, MUST BE SWAPPING ADDRESS
		MOVE 1,4
		CALL DSKIS	;CONVERT TO REGULAR DISK ADDRESS
		MOVE 4,1
		POP P,1
		MOVEI 3,1777	;CLASS FOR SWAPPING
		JRST DSKI7]
	TLZE 4,NEWFB		;NEWLY ASSIGNED PAGE?
	JRST DSKI6		;YES
DSKI7:	DPB 3,[POINT 10,1,17]	;SAVE CLASS AND CLASS CONTROL BIT
	ADDI 1,CST3
	HLLZM 1,0(1)		;IN LH OF QUEUE POINTER, 0 MARKS END
	PUSH P,1
	MOVE 1,4		;DISK ADDRESS
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,4
	HLRZ 1,1		;GET DRIVE NUMBER FOR INDEX
	PIOFF			;MUST NOT INTERRUPT QUEUEING
	JUMPL 4,[HRRM 4,@DSKWI(1) ;WRITE, APPEND TO WRITE QUEUE
		HRRZM 4,DSKWI(1) ;OF APPROPRIATE DRIVE
		JRST DSKI4]
	HRRM 4,@DSKRI(1)	;READ, APPEND TO READ QUEUE
	HRRZM 4,DSKRI(1)
DSKI4:	PION
	SKIPGE DSKLUN		;TRANSFER NOW IN PROGRESS?
	CALL DSKRC		;NO, GO START THIS OPERATION
DSKIR:	POP P,1
	MOVE P,DSKPD1		;RESTORE CALLERS STACK
	RET

DSKI6:	TLNE 1,DWRBIT		;NEW PAGE AND WRITE?
	JRST DSKI8		;YES
	CALL SWPZPG		;READ, ZERO THE NEW PAGE
	JSP 4,SWPDON		;INDICATE IO COMPLETION
	JRST DSKIR

DSKI8:	MOVEM 4,CST1(1)		;UPDATE DISK ADDRESS (NEWFB CLEARED)
	TRO 3,1000		;CAUSE WRITE OF CLASS
	JRST DSKI7

;IF SWAPPING TO DISK, DISK ADDRESS DISGUISED AS DRUM ADDRESS

DSKIS:	SKIPE DRUMP		;REALLY SWAPPING ON DISK?
	BUG(HLT,<DSKIO - BAD SWAP ADDRESS>)
	HRRZS 2,1		;LINEARIZE 'DRUM' ADDRESS
	ANDI 2,77		;SECTOR
	LSH 1,-6		;BAND
	IMULI 1,DRMSEC
	ADD 1,2
	IMULI 1,NSECPG		;TIMES SECTORS PER PAGE
	ADD 1,[DSKSWA]		;BEGINNING OF SWAP AREA
	RET

;PERIODIC ROUTINE TO CHECK FOR QUEUED REQUESTS NOT IN COMMAND LIST

DSKCHK:	MOVEI 1,^D100		;RESET CLOCK FOR 100 MSEC
	MOVEM 1,DSKTIM
	SKIPGE DSKLUN		;TRANSFER IN PROGRESS?
	JRST DSKPC1		;NO
	MOVE 1,DSKLSV		;YES, TIME OF LAST INTERRUPT SERVICE
	ADDI 1,^D5000		;PLUS FIVE SECONDS
	CAML 1,TODCLK		;WAITED 5 SECS OR MORE?
	JRST DSKPC1		;NO
	MOVEM 1,DSKLSV		;YES, UPDATE CLOCK
	BUG(HLT,<DSKCHK - DSK FAILED TO GIVE EXPECTED INTERRUPT>)
DSKPC1:	RET

DSKRC:	MOVSI 3,DSKSIP+DSKCMR
	CHNOFF DSKCHN
	SKIPGE DSKLUN		;CONTROL BUSY, OR
	TDNE 3,DSKSTS(1)	;THIS DRIVE NOW DOING SOMETHING?
	JRST [	CHNON DSKCHN	;YES, LEAVE IT
		RET]
	CALL DSKRCK		;NO, GO GET IT GOING
	CHNON DSKCHN
	RET

;UTILITY DISK I/O
; AC1/ HARDWARE DISK ADDRESS
; AC2/ BIT 13 - WRITE HEADER, BIT 14 - WRITE, BIT 15 - COMPARE CLASS
;      BITS 16-24 - CLASS, BITS 25-35 WORD COUNT
; AC3/ REAL CORE ADDRESS
;RETURNS +1 WITH ERROR BITS IN AC1 24-35 (0 IF NO ERRORS)

	EXTERN DISGET,SCHEDP,EDISMS

UDSKIO:
UDSK3:	SOSGE DSKCCT		;COMMAND BUFFER FULL?
	JRST UDSK1		;YES, GO WAIT FOR ROOM
	NOSKED
	MOVE 4,@DSKFCL		;GET A COMMAND PAIR
	EXCH 4,DSKFCL
	HRLZM 1,0(4)		;STORE DISK ADDRESS LH OF FIRST WORD
	HRRZM 3,1(4)		;CORE ADDRESS RH OF SECOND WORD
	HRLM 2,1(4)		;WORD COUNT IN BITS 7-17
	MOVEI 3,0(4)
	SUBI 3,DSKCL		;INDEX FOR THIS PAIR
	TLNE 2,(1B14)		;READ OR WRITE?
	TROA 3,600000B46	;WRITE
	TRO 3,400000B46		;READ, B0 ALWAYS SET
	DPB 3,[POINT 7,1(4),6]	;TO BITS 0-6
	HLRZ 1,1		;DRIVE NUMBER
	ANDI 1,NDVMAX-1
	PIOFF
	HRRM 4,@DSKUI(1)	;APPEND TO UTILITY QUEUE
	HRRZM 4,DSKUI(1)
	PION
	PUSH P,4
	SKIPGE DSKLUN		;STARTUP POSSIBLE?
	CALL DSKRC		;YES
	POP P,4
	OKSKED
	MOVEI 1,DISGET		;SCHEDULER .GE. TEST
	HRLI 1,1(4)		;WILL TEST SECOND WORD OF PAIR
	JSYS SCHEDP
	NOSKED
	MOVE 1,1(4)		;ERROR BITS RETURNED HEREIN
	EXCH 4,DSKFCL		;RETURN PAIR TO FREE LIST
	MOVEM 4,@DSKFCL
	AOS DSKCCT
	OKSKED
	RET

UDSK1:	PUSH P,1
	AOS DSKCCT		;CORRECT COUNT
	MOVEI 1,UDSK2
	JSYS EDISMS		;DISMISS TILL ROOM IN COMMAND LIST
	POP P,1
	JRST UDSK3

UDSK2:	SKIPG DSKCCT		;ROOM NOW?
	JRST 0(4)		;KEEP WAITING
	JRST 1(4)		;RUN

;ROUTINE TO REMOVE REQUESTS FOR READ AND WRITE QUEUES AND
;INITIATE SEEK OPERATIONS
;CALLED AT MAIN AND INTERRUPT LEVEL WITH DRIVE NUMBER IN 1

DSKRCK:	IORM 3,DSKSTS(1)	;SET BITS TO INDICATE UNQUEUEING IN PROG
	SKIPE 2,DSKUO(1)	;UTILITY QUEUE WAITING?
	JRST DSKRC3		;YES, IS FIRST PRIORITY
	SKIPE 2,DSKRO(1)	;READ WAITING?
	JRST DSKRC1		;YES, UNQUEUE IT
	SKIPN 2,DSKWO(1)	;WRITE WAITING?
	JRST [	ANDCAM 3,DSKSTS(1) ;NO, NOTHING TO DO. CLEAR BITS
		RET]
	HRRZ 2,0(2)		;UNQUEUE REQUEST FROM WRITE QUEUE
	JUMPN 2,.+3
	MOVEI 3,DSKWO(1)	;0 MARKS END OF LIST,
	MOVEM 3,DSKWI(1)	;FIXUP INPUT POINTER
	EXCH 2,DSKWO(1)		;UPDATE OUTPUT POINTER
DSKRC2:	SUBI 2,CST3		;CONVERT BACK TO CORE PAGE NUMBER
	HLL 2,CST3(2)		;GET WRITE AND CLASS INFO
	MOVE 3,[XWD DWRBIT+DSKUIO,17] ;CLEAR ERROR COUNT AND
	ANDCAM 3,DSKSTS(1)	;CLEAR BITS
	MOVSI 3,DWRBIT
	TLNE 2,DWRBIT		;WRITE BIT ON?
	IORM 3,DSKSTS(1)	;YES, PUT IT ON IN STATUS WORD
	MOVEI 3,0(2)
	LSH 3,^D9		;MAKE PAGE NUMBER INTO CORE ADDRESS
	HRLI 3,-1000		;WITH ONE PAGE WORD COUNT
	MOVEM 3,DSKCAW(1)	;LEAVE IT FOR TRANSFER STARTUP
	PUSH P,1
	MOVE 1,CST1(2)		;DISK ADDRESS
	TLNN 1,10		;REGULAR?
	CALL DSKIS		;NO, SWAPPING. CONVERT
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	MOVE 2,1
	POP P,1
DSKRC4:	LSH 2,^D12		;SHIFT FOR DATAO
	MOVEM 2,DSKDAW(1)	;LEAVE FOR OTHER ROUTINES
	HRLZ 3,DSKSTS(1)	;CURRENT TRACK FOR THIS DRIVE
	XOR 2,3			;COMPARE WITH TRACK OF THIS REQUEST
	TLNN 2,(377B13)		;EQUAL?
	JRST [	CONSO PI,1B<DSKCHN+^D20> ;YES, ON PI LEVEL?
		JRST DSKSVX	;NO, GO START TRANSFER
		MOVSI 2,DSKSIP	;YES, SET STATE TO READY
		ANDCAM 2,DSKSTS(1) ;TRANSFER WILL BE STARTED BEFORE DBRK
		RET]
	MOVSI 2,DSKCMR		;CLEAR READY BIT
	ANDCAM 2,DSKSTS(1)
	MOVE 2,DSKDAW(1)	;NOT EQUAL
	TLZ 2,17		;CLEAR ERROR COUNT
	HLRM 2,DSKSTS(1)	;SET NEW (DESIRED) TRACK IN STATUS
	TLO 2,DSKPOS		;CONSTRUCT SEEK COMMAND
	DATAO DSK,2		;START SEEK
	RET

DSKRC1:	HRRZ 2,0(2)		;UNQUEUE REQUEST FROM READ QUEUE
	JUMPN 2,.+3
	MOVEI 3,DSKRO(1)	;END OF LIST,
	MOVEM 3,DSKRI(1)	;FIXUP INPUT POINTER
	EXCH 2,DSKRO(1)		;UPDATE OUTPUT POINTER
	JRST DSKRC2

DSKRC3:	HRRZ 2,0(2)		;UNQUEUE
	JUMPN 2,.+3
	MOVEI 3,DSKUO(1)	;FIXUP ON END
	MOVEM 3,DSKUI(1)
	EXCH 2,DSKUO(1)
	MOVE 3,[XWD DWRBIT+DSKUIO,17] ;CLEAR ERROR COUNT
	ANDCAM 3,DSKSTS(1)	;BITS
	LDB 3,[POINT 5,1(2),6]	;DSKCL INDEX
	DPB 3,[POINT 5,DSKSTS(1),17] ;WHERE INTERRUPT ROUTINE CAN GET
	HLLZ 3,1(2)		;WORD COUNT
	TLZ 3,774000
	MOVNM 3,DSKCAW(1)	;TO LH OF CHANNEL WORD
	MOVE 4,1(2)		;CORE ADDRESS AND BITS
	HRRM 4,DSKCAW(1)	;STORE CORE ADDRESS
	MOVSI 3,DSKUIO		;SET UTILITY BIT IN ANY CASE
	TLNE 4,200000		;AND IF WRITE,
	MOVSI 3,DSKUIO+DWRBIT	;SET WRITE BIT TOO
	IORM 3,DSKSTS(1)	;YES
	HLRZ 2,0(2)		;DISK ADDRESS
	HRLI 2,0(1)		;INCLUDE UNIT
	JRST DSKRC4

;DISK INTERRUPT SERVICE

	INTERN DSKSV

DSKSV:	XWD DSKSVR,.+1
	CONSO DSK,DSKIRQ	;DISK REQUESTING?
	JRST @DSKSVR		;NO
	MOVEM P,DSKACP		;SAVE AC
	MOVE P,[IOWD NDSKPD,DSKPDL] ;SET UP LOCAL STACK POINTER
	SKIPE PWRDWN		;PWR FAIL?
	JRST [	CONO DSK,175700+1B32 ;CLEAR PI ASSMT AND MISC BITS
		JRST DSKSV1]
	CONSZ DSK,777760-202000 ;ERROR? (IGNORING END-OF-CYLAND NOT READY)
	JRST DSKERR		;YES
	SKIPGE 1,DSKLUN		;WAS A DRIVE TRANSFERRING?
	JRST DSKSV2		;NO
DSKSV7:	MOVSI 2,DSKSIP+DSKCMR	;YES, IT MUST HAVE FINISHED
	ANDCAB 2,DSKSTS(1)	;SO CLEAR ALL BITS FOR THAT DRIVE
	CONO DSK,1B32+DSKCHN	;CLEAR DONE FLAG
	TLNE 2,DSKUIO		;UTILITY OP?
	JRST DSKSVU		;YES
	HRRZ 1,DSKCAW(1)	;GET CORE ADDRESS JUST FINISHED
	LSH 1,-^D9		;PAGE NUMBER
	JSP 4,SWPDON		;NOTE XFER COMPLETED
DSKSV2:	DATAI DSK,0		;GET ATTENTION (SEEK COMPLETE) BITS
	MOVSI 1,-NDVMAX
DSKSV6:	MOVSI 3,DSKSIP+DSKCMR
	TDNE 0,BITS+^D27(1)	;SEEK COMPLETE ON THIS DRIVE?
	JRST DSKSV4		;YES
	TDNN 3,DSKSTS(1)	;THIS DRIVE FREE?
	CALL DSKRCK		;YES, SEE IF ANY WAITING REQUESTS
DSKSV5:	AOBJN 1,DSKSV6		;CHECK ALL DRIVES
	AOS 1,DSKLUN		;START WITH NEXT UNIT, OR 0 IF NONE
	HRLI 1,-NDVMAX
DSKSV3:	MOVEI 2,0(1)
	CAIL 2,NDVMAX
	HRRI 1,0		;WRAPAROUND DRIVE NUMBER
	MOVE 3,DSKSTS(1)
	TLNE 3,DSKCMR		;COMMAND READY AND NO SEEK IN PROGRESS?
	TLNE 3,DSKSIP
	JRST [	AOBJN 1,DSKSV3	;NO, CHECK NEXT DRIVE
		SETOM DSKLUN	;ALL DRIVES CHECKED, NONE XFERRING
		JRST DSKSV1]	;GO DEBREAK
	CALL DSKSVX		;START TRANSFER
DSKSV1:	MOVE P,DSKACP		;RESTORE AC-P
	UNBRK DSK		;DEBREAK

DSKSVX:	MOVSI 3,DSKSIP+DSKCMR	;ROUTINE TO START XFER ON READY DRIVE
	IORB 3,DSKSTS(1)	;SET STATE TO XFER IN PROGRESS
	MOVE 2,TODCLK
	MOVEM 2,DSKLSV		;SAVE CURRENT TIME
	MOVE 2,DSKCAW(1)	;CORE ADDRESS AND COUNT
	HRRI 2,-1(2)		;LIKE IOWD, ADDRESS IN 1 LESS
	MOVEM 2,DSKCCM		;FIXED LOCATION FOR CHANNEL COMMAND
	MOVE 2,DSKDAW(1)	;DISK ADDRESS
	IORI 2,DSKCP		;INCLUDE INITIAL COM WD ADDRESS
	TLNE 3,DWRBIT		;READ OR WRITE?
	TLOA 2,DSKWDA		;WRITE, CONSTRUCT COMMAND
	TLO 2,DSKRDA		;CONSTRUCT READ COMMAND
	PIOFF
	DATAO DSK,2		;START XFER
	HRRZM 1,DSKLUN		;REMEMBER NUMBER OF DRIVE XFERRING
	PION
	RET

DSKSV4:	MOVE 2,DSKDAW(1)
	IOR 2,BITS+^D27(1)	;BIT TO CLEAR ATTENTION
	TLO 2,DSKCAT		;CLEAR ATTENTION COMMAND
	DATAO DSK,2
	MOVSI 3,DSKSIP
	XOR 3,DSKSTS(1)
	TLNE 3,DSKSIP+DSKCMR	;WAS SEEK IN PROGRESS?
	JRST DSKSV5		;NO, IGNORE (POSSIBLY POWER ON, ETC.)
	DATAI DSK,2		;GET BITS FOR THIS DRIVE
	TLNE 2,(1B11)		;SEEK INCOMPLETE?
	JRST DSKSKE		;YES
	TLNN 2,(1B12)		;ON CYLINDER?
	BUG(HLT,<DSK - ATTENTION UP BUT NOT ON CYLINDER>)
	ROT 2,-3+^D18		;ALIGN WITH TRACK IN STS
	XOR 2,DSKSTS(1)		;COMPARE
	TRNE 2,377B31		;SAME?
	JRST [	MOVE 2,DSKDAW(1) ;NO, PROBABLY RESULT OF RECAL COMMAND
		TLO 2,DSKPOS	;CONSTRUCT NEW POSITION COMMAND
		DATAO DSK,2	;ISSUE IT
		JRST DSKSV5]
	MOVSI 3,DSKSIP+DSKCMR
	XORM 3,DSKSTS(1)	;CHANGE STATE TO COMMAND READY
	JRST DSKSV5

DSKSKE:	MOVE 2,DSKDAW(1)	;SEEK FAILED, GET DRIVE NUMBER
	TLO 2,DSKCAL		;CONSTRUCT CALIBRATE COMMAND
	DATAO DSK,2		;SHOULD GIVE SEEK COMPL WHEN DONE
	JRST DSKSV5

DSKUER:	TLZA 2,400000		;RETURN ERROR BITS (B0 SHOULD BE OFF)
DSKSVU:	SETZ 2,			;0 MEANS NO ERRORS
	HLRZ 3,DSKSTS(1)	;FROM INTERRUPT ROUTINE
	ANDI 3,37		;GET COMMAND INDEX
	MOVEM 2,DSKCL+1(3)	;WORD GOING POSITIVE INDICATES DONE
	AOS PSKED		;SIG SCHED
	JRST DSKSV2

;DISK ERROR

	INTERN DSKERR

DSKERR:	CONI DSK,2		;GET ALL ERROR BITS
	CONO DSK,175700+1B32+DSKCHN ;CLEAR ALL ERR BITS, CLR DONE
	SKIPGE 1,DSKLUN		;WAS ON XFER COMMAND?
	JRST DSKER1		;NO
	MOVE 3,DSKDAW(1)	;SAVE ERROR WORDS
	MOVEM 3,DSKRER
	MOVE 3,DSKCAW(1)
	MOVEM 3,DSKRER+1
	MOVE 3,DSKSTS(1)
	MOVEM 3,DSKRER+2
	MOVEM 2,DSKRER+3	;AND ERROR BITS
	AOS DSKRCE		;COUNT REC ERRORS
	AOS 3,DSKSTS(1)		;COUNT ERRORS ON THIS REQUEST
	ANDI 3,17
	CAILE 3,DSKNTR		;UNRECOVERABLE?
	JRST DSKERP		;YES
DSKER2:	TRNE 2,1B21		;SEARCH FAILED?
	JRST DSKER3		;YES, GO REPOSITION
	CALL DSKSVX		;START XFER OVER AGAIN
	JRST DSKSV1		;DEBREAK

DSKER3:	MOVSI 3,DSKCMR
	ANDCAM 3,DSKSTS(1)	;CLEAR COMMAND READY
	MOVE 3,DSKDAW(1)	;GET DRIVE NUMBER
	TLO 3,DSKCAL		;CONSTRUCT RECALIBRATE COMMAND
	DATAO DSK,3		;ISSUE IT
	JRST DSKSV2		;CONTINUE PROCESSING INTERRUPTS

DSKERP:	TLNE 2,(1B14+1B16)	;PCI?
	JRST [	AOS DEVMPE	;YES, REQUEST CORE SCAN
		ISB APRCHN
		JRST DSKER2]	;TRY AGAIN
	BUG(CHK,<UNRECOVERABLE DSK ERROR - CAUSES NOT WELL UNDERSTOOD>)
	MOVNI 3,DSKNTR
	ADDM 3,DSKRCE		;REMOVE FROM RECOVERABLE COUNT
	AOS DSKNRE		;COUNT IRRECOVERABLE
	MOVE 3,[XWD DSKRER,DSKLER]
	BLT 3,DSKLER+3		;SAVE COMMAND WORDS
	MOVSI 3,DSKUIO
	TDNE 3,DSKSTS(1)	;UTILITY OP?
	JRST DSKUER		;YES
	TRNE 2,113700		;BAD ERRORS?
	BUG(HLT,<BAD DSK ERRORS, DONT KNOW WHAT TO DO>)
	HRRZ 2,DSKCAW(1)	;'NORMAL' IRREC TYPE ERROR
	LSH 2,-^D9		;GET PAGE NUMBER
	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;NOTIFY SWAPPER OF ERROR
	JRST DSKSV7		;TREAT REQUEST AS COMPLETED

DSKER1:	BUG(HLT,<DSK ERROR WHILE NOT TRANSFER IN PROGRESS>)

;DISK DRIVER INITIALIZATION

	INTERN DSKINI,DSKRST

DSKINI:	SKIPN DISKP
	RET
	SETOM DSKBLK
	MOVEI 1,DSKCL+2*NDSKCM-2
	SETZM 0(1)		;END OF LIST
	MOVEM 1,-2(1)		;INIT UTILITY FREE LIST
	SUBI 1,2
	CAILE 1,DSKCL
	JRST .-3
	MOVEM 1,DSKFCL
	MOVEI 1,NDSKCM
	MOVEM 1,DSKCCT		;INIT UTILITY COMMAND FREE COUNT
	MOVEI 1,DSKCCM
	MOVEM 1,DSKCP		;INITIAL COMMAND WORD FOR CHANNEL
	SETOM DSKLUN
	MOVSI 1,-NDVMAX		;FOR EACH UNIT, DO:
DSKII1:	MOVEI 2,DSKWO(1)	;INIT WRITE QUEUE
	MOVEM 2,DSKWI(1)
	MOVEI 2,DSKRO(1)	;INIT READ QUEUE
	MOVEM 2,DSKRI(1)
	MOVEI 2,DSKUO(1)	;INIT UTILITY QUEUE
	MOVEM 2,DSKUI(1)
	MOVEI 3,0(1)		;UNIT NUMBER
	ROT 3,-6		;CONSTRUCT NOP COMMAND
	TLO 3,DSKNOP
	DATAO DSK,3		;ISSUE IT, SELECTING UNIT
	DATAI DSK,3		;GET BITS FOR THAT UNIT
	LDB 2,[POINT 3,3,2]	;GET UNIT NUMBER AS REPORTED
	CAIE 2,0(1)		;AGREES?
	BUG(HLT,<DSK - FAILED TO SELECT UNIT>)
	TLNN 3,(1B15)		;NO SUCH UNIT? OR
	TLNN 3,(1B13)		;NOT ON LINE?
	JRST [	SETOM DSKSTS(1)	;YES, PREVENT USE OF DRIVE
		JRST DSKII3]
	MOVEI 3,0(1)
	ROT 3,-6		;CONSTRUCT RECALIBRATE COMMAND
	TLO 3,DSKCAL
	DATAO DSK,3		;ISSUE IT
DSKII2:	DATAI DSK,3		;CHECK STATUS OF DRIVE
	LDB 2,[POINT 8,3,10]	;TRACK
	JUMPN 2,DSKII2		;WAIT FOR TRACK 0
	TLNN 3,(1B12)		;AND 'ON CYLINDER'
	JRST DSKII2
	MOVEI 3,0(1)
	ROT 3,-6
	TLO 3,DSKCAT		;CONSTRUCT CLEAR ATTENTIONS COMMAND
	IOR 3,BITS+^D27(1)
	DATAO DSK,3		;ISSUE IT
	SETZM DSKSTS(1)		;CLEAR STATUS AND SET TRACK TO 0
DSKII3:	AOBJN 1,DSKII1
	CONO DSK,DSKCHN		;GIVE IT IT'S PI ASSMT
	IFNDEF DRMCHN,<CALL DRMINI> ;INIT SWAP BIT TABLE
	RET

DSKRST:	SKIPN DISKP
	RET
	CONO DSK,DSKCHN		;GIVE PI ASSMT
	SKIPL 1,DSKLUN		;XFER IN PROGRESS?
	CALL DSKSVX		;YES, RESTART IT
	RET

;RELOAD RES MON, CALLED FROM SYSGO

RLRMA==3000		;RUN LOCATION OF RELOAD ROUTINE
RLRCA==36		;FIRST CORE LOCATION RESTORED

RLRMON:	MOVE 1,[XWD RLMX0,RLRMA]
	BLT 1,RLRMA+777		;MOVE RELOAD ROUTINE TO RUN LOCATION
	JRST RLMGO		;IT RELOADS AND STARTS MON

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPG,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20		;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI 1,20
	HRRI 1,21
	BLT 1,777
	MOVEI 7,100		;SETUP RETURN TO DDT WHEN LOADED
RLMGO:	MOVSI 10,-PPRMPG+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE 1,RLMC5(10)	;DISK ADDRESS
	LSH 1,^D12
	TLO 1,DSKPOS
	DATAO DSK,1		;POSITION HEADS
RLMG1:	DATAI DSK,2
	TLNN 2,(1B11)		;ERROR?
	TLNN 2,(1B13)		;OR NOT ON LINE?
	JRST 4,RLMGO		;YES
	TLNN 2,(1B12)		;ON CYL?
	JRST RLMG1		;NO, WAIT
	CONO DSK,1B32		;CLEAR DONE
	MOVEI 2,-1(11)		;CONSTRUCT CHANNEL COMMAND
	HRLI 2,-1000		;TRANSFER ONE PAGE
	MOVEM 2,RLMNB
	SETZM RLMNB+1		;ONE WORD CHAN PGM
	MOVEI 2,RLMNB
	MOVEM 2,DSKCP		;INITIAL CHANNEL LOC
	TLZ 1,DSKPOS
	TLO 1,DSKRDA		;CONSTRUCT READ COMMAND
	IORI 1,DSKCP		;INCLUDES CHAN ADDRESS
	DATAO DSK,1		;ISSUE READ
	CONSO DSK,1B31		;WAIT TILL BUSY OFF AND DONE ON
	CONSO DSK,1B32
	JRST .-2
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)		;RETURN

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:

;DISK ALLOCATOR

NPACKS==1		;NUMBER OF RPO2 DRIVES
NTKUN=^D200		;NUMBER OF TRACKS PER DRIVE (UNIT)

NTRACK=NTKUN*NPACKS	;EACH DRIVE CONSIDERED A GROUP OF TRACKS

NWSEC==200		;RPO2'S HAVE 128 WORDS/SECTOR,
NSECS==^D10		; 10 SECTORS PER ROTATION,
NSURFS==^D20		; AND 20 SURFACES PER UNIT
NSECPG==1000/NWSEC	; 4 SECTORS PER PAGE

;THERE ARE NSURFS*NSECS=200 SECTORS/TRACK
;THERE ARE 200*(NWSEC/1000)=50 PAGES + 0 SECTORS PER TRACK

NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT

HITRK=^D150		;UPPER LIMIT OF TRACKS TO USE
LOTRK==0		;LOWER LIMIT OF TRACKS TO USE

;FIXED AREAS OF DISK FOR SPECIAL PURPOSES

DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING
DSKSWA==<^D150>*NSECTK		;SWAPPING AREA

DSKRMA==<^D200>*NSECTK		;RESIDENT MON IMAGE FOR RELOADING
DSKSMA==DSKRMA+PPRMPG*4		;SWAP MON IMAGE (NOT USED)

DSKABT==10		;BITS IOR'D TO LH OF DISK ADDRESS
DSKMSK==777774		;BITS NOT USED IN LH OF DISK ADDRESS

NGS DSKFCT,NTRACK	;COUNT OF FREE PAGES EACH TRACK
NGS DSKBTB,NTRACK*NBWTK	;BIT TABLE
XX==NTRACK+NTRACK*NBWTK		;SIZE OF ACTUAL STORAGE FOR CNT AND BITS
NGS DSKDMY,<<<XX+777>/1000>*1000>-XX ;FILL TO NEXT PAGE BOUNDARY

LS DSKBLK,1		;BIT TABLE LOCK
LS DBTJFN,1		;JFN OF BIT TABLE FILE

;DISC ADDRESS OF INDEX FILE

DIDSC0==<HITRK+LOTRK>/2*NSECTK	;PUT IN MIDDLE OF FILE AREA

DIDSCI:	XWD 30,DIDSC0
GS DIDSCA,1

;CONVERT LINEAR ADDRESS TO HARDWARE DISK ADDRESS

CVDSK:	TLZ 1,DSKMSK		;FLUSH EXTRA BITS
	IDIVI 1,NSECTK		;GET TRACK, SECTORS
	PUSH P,2
	IDIVI 1,NTKUN		;GIVES DRIVE NO IN 1, TRACK IN 2
	LSH 2,^D10		;TRACK TO BITS 18-25
	HRL 2,DRIVTB(1)		;PHYS. DRIV NO FOR TRK GROUP TO B15-17
	POP P,1
	PUSH P,2
	IDIVI 1,NSECS		;GET SURFACE, SECTOR
	LSH 1,5			;SURFACE TO B26-30
	IORI 1,0(2)		;WITH SECTOR IN B31-35
	POP P,2			;RECOVER DRIVE AND TRACK
	IOR 1,2			;MERGE ALL FIELDS
	RET

;CONVERT HARDWARE FORMAT TO LINEAR ADDRESS

CDSKVA:	HLRZ 2,1		;15-17 IS DRIVE
	ANDI 2,7
	HLRZ 3,DRIVTB(2)	;GET CORRESPONDING TRACK GROUP NO
	IMULI 3,NTKUN		;FIRST OF THIS GROUP OF TRACKS
	LDB 2,[POINT 8,1,25]	;18-25 IS TRACK ON SPECIFIED DRIVE
	ADDI 3,0(2)		;NOW HAVE ACTUAL TRACK NUMBER
	IMULI 3,NSECTK		;COMPUTE SECTOR NUMBER
	LDB 2,[POINT 5,1,30]	;26-30 IS SURFACE
	IMULI 2,NSECS		;FIRST SECTOR THIS SURFACE
	ANDI 1,37		;31-35 IS SECTOR
	ADDI 1,0(2)		;TOTAL SECTORS
	ADD 1,3
	RET

;TABLE FOR CONVERSION BETWEEN PHYSICAL DRIVE NUMBERS AND INTERNAL
;TRACK GROUPS NUMBERS.  INDEXED BY INTERNAL, RH GIVES PHYSICAL.
;INDEXED BY PHYSICAL, LH GIVES INTERNAL

DRIVTB:	XWD 0,0
	XWD 1,1
	XWD 2,2
	XWD 3,3
	XWD 4,4
	XWD 5,5
	XWD 6,6
	XWD 7,7

	SWAPCD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         