
;24 NOV 71, 1305: - DLM

;JSYS INSTRUCTIONS AND ERROR MNEMONICS FOR TENEX

XLIST

IFDEF IFAVL,<%%FAIL__1		;BEING ASSEMBLED BY FAIL
IFNDEF INTERF,<INTERF__0>
>
IFNDEF IFAVL,<%%FAIL==0		;BEING ASSEMBLED BY MACRO
IFNDEF INTERF,<INTERF==0>
>

DEFINE DEFJS (NAME,NUM)
<OPDEF NAME [104B8+NUM]
IFN INTERF,<INTERN NAME
	NAME=104B8+NUM>
>

DEFJS JSYS,0

DEFJS LOGIN,1
DEFJS CRJOB,2
DEFJS LGOUT,3
DEFJS CACCT,4
DEFJS EFACT,5
DEFJS SMON,6
DEFJS TMON,7
DEFJS GETAB,10
DEFJS ERSTR,11
DEFJS GETER,12
DEFJS GJINF,13
DEFJS TIME,14
DEFJS RUNTM,15
DEFJS SYSGT,16
DEFJS GNJFN,17
DEFJS GTJFN,20
DEFJS OPENF,21
DEFJS CLOSF,22
DEFJS RLJFN,23
DEFJS GTSTS,24
DEFJS STSTS,25
DEFJS DELF,26
DEFJS SFPTR,27
DEFJS JFNS,30
DEFJS FFFFP,31
DEFJS RDDIR,32
DEFJS CPRTF,33
DEFJS CLZFF,34
DEFJS RNAMF,35
DEFJS SIZEF,36
DEFJS GACTF,37

DEFJS STDIR,40
DEFJS DIRST,41
DEFJS BKJFN,42
DEFJS RFPTR,43
DEFJS CNDIR,44
DEFJS RFBSZ,45
DEFJS SFBSZ,46
DEFJS SWJFN,47
DEFJS BIN,50
DEFJS BOUT,51
DEFJS SIN,52
DEFJS SOUT,53
DEFJS RIN,54
DEFJS ROUT,55
DEFJS PMAP,56
DEFJS RPACS,57
DEFJS SPACS,60
DEFJS RMAP,61
DEFJS SACTF,62
DEFJS GTFDB,63
DEFJS CHFDB,64
DEFJS DUMPI,65
DEFJS DUMPO,66
DEFJS DELDF,67
DEFJS ASND,70
DEFJS RELD,71
DEFJS CSYNO,72
DEFJS PBIN,73
DEFJS PBOUT,74
DEFJS PSIN,75
DEFJS PSOUT,76
DEFJS MTOPR,77
DEFJS CFIBF,100
DEFJS CFOBF,101
DEFJS SIBE,102
DEFJS SOBE,103
DEFJS DOBE,104
DEFJS GTABS,105
DEFJS STABS,106
DEFJS RFMOD,107
DEFJS SFMOD,110
DEFJS RFPOS,111
DEFJS RFCOC,112
DEFJS SFCOC,113
DEFJS STI,114
DEFJS DTACH,115
DEFJS ATACH,116
DEFJS DVCHR,117

DEFJS STDEV,120
DEFJS DEVST,121
DEFJS MOUNT,122
DEFJS DSMNT,123
DEFJS INIDR,124
DEFJS SIR,125
DEFJS EIR,126
DEFJS SKPIR,127
DEFJS DIR,130
DEFJS AIC,131
DEFJS IIC,132
DEFJS DIC,133
DEFJS RCM,134
DEFJS RWM,135
DEFJS DEBRK,136
DEFJS ATI,137
DEFJS DTI,140
DEFJS CIS,141
DEFJS SIRCM,142
DEFJS RIRCM,143
DEFJS RIR,144
DEFJS GDSTS,145
DEFJS SDSTS,146
DEFJS RESET,147
DEFJS RPCAP,150
DEFJS EPCAP,151
DEFJS CFORK,152
DEFJS KFORK,153
DEFJS FFORK,154
DEFJS RFORK,155
DEFJS RFSTS,156
DEFJS SFORK,157
DEFJS SFACS,160
DEFJS RFACS,161
DEFJS HFORK,162
DEFJS WFORK,163
DEFJS GFRKH,164
DEFJS RFRKH,165
DEFJS GFRKS,166
DEFJS DISMS,167
DEFJS HALTF,170
DEFJS GTRPW,171
DEFJS GTRPI,172
DEFJS RTIW,173
DEFJS STIW,174
DEFJS SOBF,175
DEFJS RWSET,176
;LOWEST HOLE

DEFJS GET,200
DEFJS SFRKV,201
DEFJS SAVE,202
DEFJS SSAVE,203
DEFJS SEVEC,204
DEFJS GEVEC,205
DEFJS GPJFN,206
DEFJS SPJFN,207
DEFJS SETNM,210
DEFJS FFUFP,211
DEFJS DIBE,212
DEFJS FDFRE,213
DEFJS GDSKC,214
DEFJS LITES,215
DEFJS TLINK,216
;HOLE
DEFJS ODTIM,220
DEFJS IDTIM,221
DEFJS ODCNV,222
DEFJS IDCNV,223
DEFJS NOUT,224
DEFJS NIN,225
DEFJS STAD,226
DEFJS GTAD,227
DEFJS ODTNC,230
DEFJS IDTNC,231
DEFJS FLIN,232
DEFJS FLOUT,233
DEFJS DFIN,234
DEFJS DFOUT,235

DEFJS CRDIR,240
DEFJS GTDIR,241
DEFJS DSKOP,242
DEFJS SPRIW,243
DEFJS DSKAS,244
DEFJS SJPRI,245
; HOLE
DEFJS ASNDP,260
DEFJS RELDP,261
DEFJS ASNDC,262
DEFJS RELDC,263
DEFJS STRDP,264
DEFJS STPDP,265
DEFJS STSDP,266
DEFJS RDSDP,267
DEFJS WATDP,270

DEFJS ATPTY,274
DEFJS CVSKT,275

DEFJS GCVEC,300
DEFJS SCVEC,301

IFE %%FAIL,<
DEFINE ...QQQ (E,N,F)<
IFN INTERF,<INTERN E>
IFE F,<
E=600000+N>
IFN F,<
E=600000+N+F'B21>>
>

IFN %%FAIL,<
DEFINE ...QQQ'(E,N,F)<
IFN INTERF,<INTERN E>
IFIDN <F>,<>,<
E_600000+N>
IFDIF <F>,<>,<
E_600000+N+F'B21>
SUPPRESS E>
>

...QQQ (LGINX1,10)
...QQQ (LGINX2,11)
...QQQ (LGINX3,12)
...QQQ (LGINX4,13)
...QQQ (LGINX5,14)

...QQQ (CRJBX1,20)
...QQQ (CRJBX2,21)
...QQQ (CRJBX3,22)
...QQQ (CRJBX4,23)
...QQQ (CRJBX5,24)
...QQQ (CRJBX6,25)
...QQQ (CRJBX7,26)

...QQQ (LOUTX1,35)
...QQQ (LOUTX2,36)

...QQQ (CACTX1,45)
...QQQ (CACTX2,46)

...QQQ (EFCTX1,50)
...QQQ (EFCTX2,51)
...QQQ (EFCTX3,52)

...QQQ (GJFX1,55)
...QQQ (GJFX2,56)
...QQQ (GJFX3,57)
...QQQ (GJFX4,60)
...QQQ (GJFX5,61)
...QQQ (GJFX6,62)
...QQQ (GJFX7,63)
...QQQ (GJFX8,64)
...QQQ (GJFX9,65)
...QQQ (GJFX10,66)
...QQQ (GJFX11,67)
...QQQ (GJFX12,70)
...QQQ (GJFX13,71)
...QQQ (GJFX14,72)
...QQQ (GJFX15,73)
...QQQ (GJFX16,74)
...QQQ (GJFX17,75)
...QQQ (GJFX18,76)
...QQQ (GJFX19,77)
...QQQ (GJFX20,100)
...QQQ (GJFX21,101)
...QQQ (GJFX22,102)
...QQQ (GJFX23,103)
...QQQ (GJFX24,104)
...QQQ (GJFX25,105)
...QQQ (GJFX26,106)
...QQQ (GJFX27,107)
...QQQ (GJFX28,110)
...QQQ (GJFX29,111)
...QQQ (GJFX30,112)
...QQQ (GJFX31,113)
...QQQ (GJFX32,114)
...QQQ (GJFX33,115)

...QQQ (OPNX1,120)
...QQQ (OPNX2,121)
...QQQ (OPNX3,122)
...QQQ (OPNX4,123)
...QQQ (OPNX5,124)
...QQQ (OPNX6,125)
...QQQ (OPNX7,126)
...QQQ (OPNX8,127)
...QQQ (OPNX9,130)
...QQQ (OPNX10,131)
...QQQ (OPNX11,132)
...QQQ (OPNX12,133)
...QQQ (OPNX13,134)
...QQQ (OPNX14,135)
...QQQ (OPNX15,136)
...QQQ (OPNX16,137)
...QQQ (OPNX17,140)
...QQQ (OPNX18,141)
...QQQ (OPNX19,142)
...QQQ (OPNX20,143)
...QQQ (OPNX21,144)
...QQQ (OPNX22,145)

...QQQ (DESX1,150)
...QQQ (DESX2,151)
...QQQ (DESX3,152)
...QQQ (DESX4,153)
...QQQ (DESX5,154)
...QQQ (DESX6,155)
...QQQ (DESX7,156)

...QQQ (CLSX1,160)
...QQQ (CLSX2,161)

...QQQ (RJFNX1,165)
...QQQ (RJFNX2,166)
...QQQ (RJFNX3,167)

...QQQ (DELFX1,170)

...QQQ (SFPTX1,175)
...QQQ (SFPTX2,176)
...QQQ (SFPTX3,177)

...QQQ (CNDIX1,200)
...QQQ (CNDIX2,201)
...QQQ (CNDIX3,202)
...QQQ (CNDIX4,203)
...QQQ (CNDIX5,204)

...QQQ (SFBSX1,210)
...QQQ (SFBSX2,211)

...QQQ (IOX1,215)
...QQQ (IOX2,216)
...QQQ (IOX3,217)
...QQQ (IOX4,220)
...QQQ (IOX5,221)
...QQQ (IOX6,222)

...QQQ (PMAPX1,240)
...QQQ (PMAPX2,241)

...QQQ (SPACX1,245)


...QQQ (FRKHX1,250)
...QQQ (FRKHX2,251)
...QQQ (FRKHX3,252)
...QQQ (FRKHX4,253)
...QQQ (FRKHX5,254)
...QQQ (FRKHX6,255)

...QQQ (GTABX1,267)
...QQQ (GTABX2,270)
...QQQ (GTABX3,271)

...QQQ (RUNTX1,273)

...QQQ (STADX1,275)
...QQQ (STADX2,276)

...QQQ (ASNDX1,300)
...QQQ (ASNDX2,301)
...QQQ (ASNDX3,302)

...QQQ (CSYNX1,312)

...QQQ (ATACX1,320)
...QQQ (ATACX2,321)
...QQQ (ATACX3,322)
...QQQ (ATACX4,323)
...QQQ (ATACX5,324)

...QQQ (DCHRX1,330)	;USED ?

...QQQ (STDVX1,332)

...QQQ (DEVX1,335)
...QQQ (DEVX2,336)
...QQQ (DEVX3,337)

...QQQ (MNTX1,345)
...QQQ (MNTX2,346)
...QQQ (MNTX3,347)

...QQQ (TERMX1,350)

...QQQ (ATIX1,352)
...QQQ (ATIX2,353)

...QQQ (DTIX1,355)

...QQQ (TTYX1,360)

...QQQ (CFRKX2,362)
...QQQ (CFRKX3,363)


...QQQ (KFRKX1,365)
...QQQ (KFRKX2,366)

...QQQ (RFRKX1,367)

...QQQ (GFRKX1,371)

...QQQ (GETX1,373)
...QQQ (GETX2,374)

...QQQ (SFRVX1,377)

...QQQ (NOUTX1,407)
...QQQ (NOUTX2,410)

...QQQ (IFIXX1,414)
...QQQ (IFIXX2,415)
...QQQ (IFIXX3,416)

...QQQ (GFDBX1,424)
...QQQ (GFDBX2,425)
...QQQ (GFDBX3,426)

...QQQ (CFDBX1,430)
...QQQ (CFDBX2,431)
...QQQ (CFDBX3,432)
...QQQ (CFDBX4,433)

...QQQ (DUMPX1,440)
...QQQ (DUMPX2,441)
...QQQ (DUMPX3,442)
...QQQ (DUMPX4,443)

...QQQ (RNAMX1,450)
...QQQ (RNAMX2,451)

...QQQ (BKJFX1,454)

...QQQ (TIMEX1,460)
...QQQ (ZONEX1,461)
...QQQ (ODTNX1,462)
;463 FREE
...QQQ (DILFX1,464)
...QQQ (TILFX1,465)
...QQQ (DATEX1,466)
...QQQ (DATEX2,467)
...QQQ (DATEX3,470)
...QQQ (DATEX4,471)
...QQQ (DATEX5,472)
...QQQ (DATEX6,473)

...QQQ (TMONX1,515)
...QQQ (SMONX1,515)

...QQQ (CPRTX1,520)

...QQQ (SACTX1,530)
...QQQ (SACTX2,531)
...QQQ (SACTX3,532)
...QQQ (SACTX4,533)

...QQQ (GACTX1,540)
...QQQ (GACTX2,541)

...QQQ (FFUFX1,544)
...QQQ (FFUFX2,545)
...QQQ (FFUFX3,546)

...QQQ (DSMX1,555)

...QQQ (RDDIX1,560)

...QQQ (SIRX1,570)

...QQQ (SSAVX1,600)
...QQQ (SSAVX2,601)

...QQQ (SEVEX1,610)

...QQQ (WHELX1,614)

...QQQ (CRDIX1,620)
...QQQ (CRDIX2,621)
...QQQ (CRDIX3,622)
...QQQ (CRDIX4,623)
...QQQ (CRDIX5,624)
...QQQ (CRDIX6,625)

...QQQ (GTDIX1,640)
...QQQ (GTDIX2,641)

...QQQ (FLINX1,650)
...QQQ (FLINX2,651)
...QQQ (FLINX3,652)
...QQQ (FLINX4,653)

...QQQ (FLOTX1,660)
...QQQ (FLOTX2,661)
...QQQ (FLOTX3,662)

...QQQ (FDFRX1,700)
...QQQ (FDFRX2,701)

...QQQ (ATPX1,710)
...QQQ (ATPX2,711)
...QQQ (ATPX3,712)
...QQQ (ATPX4,713)
...QQQ (ATPX5,714)
...QQQ (ATPX6,715)
...QQQ (ATPX7,716)
...QQQ (ATPX8,717)
...QQQ (ATPX9,720)
...QQQ (ATPX10,721)
...QQQ (ATPX11,722)
...QQQ (ATPX12,723)
...QQQ (ATPX13,724)

...QQQ (CVSKX1,730)
...QQQ (CVSKX2,731)

...QQQ (DPX1,734)
...QQQ (DPX2,735)
...QQQ (STRDX1,740)
...QQQ (STRDX2,741)
...QQQ (STRDX3,742)

;ADD JSYS ERROR CODES HERE

...QQQ (ILINS1,770)
...QQQ (ILINS2,771)
...QQQ (ILINS3,772)

IFE %%FAIL,<PURGE ...QQQ>

LIST

;8 NOV 71, 1633:
;PARAMETERS FOR SYSTEM A

DEFINE SYSTXT
<	FOO <BBN-TENEX 1.28, SYSTEM-A>>
SVNM==^D128		;VERSION NUMBER FOR FILES

NJOBS==^D40		;NUMBER OF JOBS ON SYSTEM
NLINES=^D73		;NUMBER OF TTY LINES INCLUDING CTY
			;MUST BE CONSISTENT WITH NLINES IN FPARAM
NTTYS==^D65		;48 SCANNER AND CTY
NTTBF==^D159		;NUMBER OF TTY BUFFERS
TTSIZ==20		;SIZE OF INDIVIDUAL TTY BUFFER (POWER OF 2)
SSPT==6000		;SIZE OF SPT (H'WARE MAX IS 20000)
NDST=<^D18*^D170>	;FOR BRYANT DRUM, 3060 PAGES
TMZONE==5	;LOCAL TIME ZONE, NUMBER OF HRS LAGS GMT, SEE DATIME

;IF PI CHANNEL FOR DEVICE IS NOT DEFINED, CODE FOR THAT DEVICE
;IS NOT ASEMBLED

MTDCHN==1		;MAG TAPE DATA CHANNEL
MTACHN==4		;MAG TAPE FLAGS CHANNEL
DTDCHN==2		;DECTAPE DATA
DTACHN==4		;DECTAPE CONTROL
DSKCHN==4		;DISK
DRMCHN==4		;DRUM
DLSCHN==5		;DLS AND TTY PI CHANNEL
 BBNDLS==1		;FOR BBN-MODIFIED SCANNER
PTRCHN==5		;PAPER TAPE READER
IMPCHN==5		;IMP (NETWORK)
PTPCHN==6		;PAPER TAPE PUNCH
PLTCHN==6		;PLOTTER
LPTCHN==6		;LINE PRINTER PI CHANNEL

;STORAGE BOUNDARIES, JUGGLED TO USE SPACE BETWEEN CST0 AND SPT

MAXCOR==1000

DST=5000		;DRUM STATUS TABLE, 18*170 = 3060 WORDS BRYANT

TTBUFS==13000		;TTY BUFFERS FOR NTTBF .LE. 159
TTBUFF==1		;INDICATES TTBUFS DEFINED HERE, NOT TTYSRV
SPT=20000		;SPT (HARDWARE DETERMINED)
SPTH=SPT+SSPT		;26000
CST2=SPTH+SSPT		;34000
CST3=CST2+MAXCOR	;35000
RESLOC=CST3+MAXCOR	;36000, RESIDENT STORAGE, USED IN LDINIT
RESMON==51000		;START OF RESIDENT MONITOR

;MAX END OF SYMBOL TABLE, USED BY POSTLD

MAXSYM==124000

;SWAPPABLE STORAGE AND CODE BOUNDARIES

NRESBG=200000		;BEGINNING OF SWAPPABLE VARIABLE STORAGE
NRPLBG=410000		; " " SWAPPABLE PAGE STORAGE
;SWMP0 IS DEFINED IN FPARAMS - FIRST PAGE OF SWAPPABLE CODE
SWPMPC=261000		;START OF SWAPPABLE CODE IN SWPMON

;PARAMETERS FOR BUG STRING STORAGE

MONBGP==5000	;BUG STRING POINTERS FOR MON
SWPBGP==5200	; " FOR SWPMON
MONBGS==6000	;BUG STRINGS FOR MON
SWPBGS==7000	; " FOR SWPMON

;22 NOV 71, 1759:

;GENERAL PARAMETERS AND MACROS

EOL=37			;END OF LINE CHARACTER

UMODF==10000		;USER MODE FLAG IN PC WORD
UIOF==4000		;USER I/O MODE IN PC WORD
NUPDL==100		;PDL FOR MONITOR CALLS

NFKS==3*NJOBS		;NUMBER OF FORKS
NSAC==16		;HIGHEST AC SAVED BY MENTR
NTERMI==^D36		;NUMBER OF TERMINAL INTERRUPTS
NPILEV==3		;NUMBER OF PSEUDO-INTERRUPT LEVELS
NPIPDL==40		;SIZE OF PSI LOCAL PDL
NTSK==50		;SIZE OF PAGE TRAP PDL
NUFKS==30		;MAX NUMBER FORKS/JOB
NLFKS==20		;NUMBER OF LOCAL FORKS

APRCHN==3		;APR PI CHANNEL
SCDCHN==7		;SCHEDULER PI CHANNEL

;PAGER BITS

READB==1B20		;READ ALLOW
WRITEB==1B21		;WRITE ALLOW
XCTB==1B22		;EXECUTE ALLOW
TRAPUB==1B26		;TRAP TO USER BIT
ACCESB==1B30		;ACCESS ALLOW
COPYB==1B27		;COPY ON WRITE
RWXB==READB+WRITEB+XCTB+ACCESB	;ALL ACCESS
RWX==RWXB-ACCESB

;ENABLE MULTI-LINE LITERALS

	MLON

;FIXED REAL CORE LOCATIONS

CST1=2000		;CST ASSIGNMENTS VALID FOR MAXCOR .LE. 1000
MMAP=3000		;RESIDENT MAP (RES MON, PPR MON, SWP MON)
CST0=4000		;CORE STATUS TABLE, PART 0 (AGE AND PROCESS BITS)

;MONITOR MAP BOUNDARIES

IF2,<IFDEF SCDV1,<INTERN PJMPG,PJMA,PPMPG,PPMA,PSB,JSB>>

PPRMPG==140		;PER PROCESSOR REGION
PPRMA==<PPRMPG>B26

SWPMPG==200		;SWAPPABLE REGION
SWPMA==<SWPMPG>B26

PJMPG==600		;PER JOB REGION
PJMA==<PJMPG>B26

PPMPG==740		;PER PROCESS REGION
PPMA==<PPMPG>B26

;MONITOR MAP PAGE ASSIGNMENTS

JSBPG==PPMPG		;JSB IS FIRST PAGE IN PER PROCESS REGION
JSB=<JSBPG>B26

CXBPG==PPMPG+1		;INDEX BLOCK PAGE USED BY REMAP ROUTINES
CXBPGA=<CXBPG>B26	;IS SECOND PAGE IN PER PROCESSOR REGION

CPTPG==PPMPG+2		;CURRENT PAGE TABLE FOR MAP SWITCHING
CPTPGA=<CPTPG>B26

CPYPG==PPMPG+3		;USED ON COPY-ON-WRITE TRAPS
CPYPGA=<CPYPG>B26

CSWPG==PPRMPG		;SWAPPER TEMP PAGE
CSWPGA=<CSWPG>B26

FITPG==PPRMPG+1		;FORK INIT TEMP PAGE
FITPGA=<FITPG>B26

NRSPG==2		;NUMBER OF PAGES RESERVED AT BOTTOM OF SWP MON

PSB=777000		;PSB IS TOP PAGE OF MAP
PSBPG==<PSB>B44
UPTA=PSB-1000		;USER PAGE TABLE
UPTPG==<UPTA>B44
UACPG==PSBPG-2		;VIRTUAL PAGE FOR AC SAVE BLOCKS

FPBPG==757		;FORK TEMP PAGE
FPBPGA=<FPBPG>B26
FTPG1==FPBPG-1		;GENERAL TEMP PAGE
FTPG1A=<FTPG1>B26

PSIPG==FPBPG-2		;PAGE FOR PSI STORAGE
PSIPGA=<PSIPG>B26

DDPG1==FPBPG-3		;PAGES FOR PERIODIC DUMP ROUTINE
DDPG1A=<DDPG1>B26
DDPG2==FPBPG-4
DDPG2A=<DDPG2>B26

FPG2==DDPG1
FPG2A=DDPG1A
FPG3==DDPG2
FPG3A=DDPG2A

ALRMAX==0		;NUMBER OF PAGES RESERVED FOR ALR
ALRVAL==10-<ALRMAX>B40	;3-BIT QUANTITY FOR PAGER ALR

;AC DEFINITIONS

P=17		;UNIVERSAL STACK

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]
OPDEF XCTUU [XCT 7,0]
OPDEF XCTMU [XCT 1,0]
OPDEF XCTUM [XCT 4,0]

IF2,<IFNDEF MENTR,<EXTERN MENTR,MRETN,MRETNE,UJSYS>>

;LOCAL STORAGE ALLOCATION MACRO

DEFINE LS (T,N)
<	IFB <N>,<ASSIGN T,RESVLC,1>
	IFNB <N>,<ASSIGN T,RESVLC,N>>

;GLOBAL STORAGE

DEFINE GS (T,N)
<	IFB <N>,<ASSIGN T,RESVLC,1>
	IFNB <N>,<ASSIGN T,RESVLC,N>
>

;SWAPPABLE STORAGE

DEFINE NGS (T,N)
<	IFB <N>,<ASSIGN T,NRESLC,1>
	IFNB <N>,<ASSIGN T,NRESLC,N>
>

;SWAPPABLE STORAGE ASSIGNED PAGE-AT-A-TIME

DEFINE NGSP(T,N)
<	IFB <N>,<ASSIGN T,NRPLOC,1000>
	IFNB <N>,<ASSIGN T,NRPLOC,N*1000>
>

;SWAPPABLE, RESIDENT CODE

DEFINE SWAPCD
<	IFG .-200000,<PRINTX BAD USE OF SWAPCD>
	LOC SWPPC>

DEFINE RESCD
<	IFLE .-200000,<PRINTX BAD USE OF RESCD>
	SWPPC=.
	RELOC>

;SWPPC MUST BE DEFINED IN EACH ASSEMBLY

OPDEF PIOFF [CONO PI,1B27]
OPDEF PION [CONO PI,1B28]

DEFINE CHNOFF (CHN)
<	CONO PI,1B26+1B<28+CHN>>

DEFINE CHNON (CHN)
<	CONO PI,1B25+1B<28+CHN>>

DEFINE ISB (CHN)
<	CONO PI,4000+1B<28+CHN>>

DEFINE UNBRK (DEV)
<	EXTERN DEV'CHR
	JRST DEV'CHR>

;INSTRUCTION TRAP ERROR

DEFINE ITERR (ERN)
<IFNB <ERN>,<
	EXTERN ERN
	JRST [	MOVEI 1,ERN
		JRST ITRAP1]
>
IFB <ERN>,<
	JRST ITRAP
>>
DEFINE RETERR (ERN)
<IFNB <ERN>,<
	EXTERN ERN
	JRST [	MOVEI 1,ERN
		JRST MRETNE]
>
IFB <ERN>,<
	JRST MRETN
>>

;MACROS FOR DEFINING BUGHLT AND BUGCHK STRINGS

;THIS IS THE MACRO THAT APPEARS IN THE CODE.  ITS FIRST ARG IS
;CHK OR HLT, AND CAUSES ASSEMBLY OF JSR BUGCHK OR JSR BUGHLT
;RESPECTIVELY.  ITS SECOND ARGUMENT IS A STRING DEFINING THE
;PROBLEM REPRESENTED BY THE CHECK.

DEFINE BUG (TYP,STR,%TAG,%NAM)
<%TAG:	JSR BUG'TYP
   DEFINE %NAM
<	XWD %TAG,[ASCIZ /STR/]
	IF2, <PURGE %TAG> >
	BUGREM <%NAM>
>

;THIS IS A SET OF REMOTE MACROS

DEFINE BUGREM (..XXX)
<	BUGRM2 <..XXX>,
>

DEFINE BUGRM2 (..NEW,..OLD)
<	DEFINE BUGREM (..XXX)
	<	BUGRM2 <..XXX>,<..OLD
		..NEW
>>>

;THIS APPEARS ONCE IN EACH ASSEMBLY AT THE END

DEFINE BGHERE (PC1,PC2)
<	LIT			;ALL REGULAR LITERALS IN ASSEMBLY
	LOC PC1			;ADDRESS OF TAGS AND POINTERS
	DEFINE BUGRM2 (..NEW,..OLD)
	<..OLD>
	BUGREM ()		;PUTS DOWN ALL POINTERS
	LOC PC2			;ADDRESS OF STRINGS
	LIT			;ALL BUG STRINGS FOR THIS ASSBY
	IFL PC2+1000-.,<PRINTX BUGSTRINGS OVERFLOW ONE PAGE>
>

;SCHEDULING CONTROL MACROS

IF2,<IFNDEF ISKED,<EXTERN ISKED,NSKED,RSKED>>

DEFINE NOSWAP
<	AOS NSWAP>

DEFINE OKSWAP
<	SOSG NSWAP
	AOS ISKED>

DEFINE RESKED
<	AOS ISKED
	ISB SCDCHN>

DEFINE NOSKED
<	AOS NSKED>

DEFINE OKSKED
<	SOSG NSKED
	XCT RSKED>

;NOSKED AND OKSKED FOR CODE POSSIBLY BEING RUN UNDER SCHEDULER

DEFINE NOSKD1
<	SKIPN INSKED
	AOS NSKED>

DEFINE OKSKD1
<	SKIPN INSKED
	SOSLE NSKED
	CAIA
	XCT RSKED>

IF2,<IFNDEF BUGHLT,<EXTERN BUGHLT,BUGCHK>>

DEFINE SETACB (A)
<	DPB A,[POINT 5,PGR71,22]
	CONO PGR,10>

;PSI CONTROL

DEFINE NOINT
<	AOS INTDF>

DEFINE OKINT
<	XCT INTDFF>

DEFINE TSTINT
<	SKIPE PSIBW>

;TS BLOCK ASSIGNMENTS

DEFINE TS (T,N)
<	IF2,<
	IFNDEF SCDV1,<EXTERN T>
	IFDEF SCDV1,<
	IFB <N>,<ASSIGN T,TSBLOC,1>
	IFNB <N>,<ASSIGN T,TSBLOC,N>
>>>

UACB=PSB+420		;ADDRESS OF FIRST BLOCK FOR AC STORAGE
EUACB==PSB+560		;END OF AC BLOCKS IN PSB

ACBAS=PSB+570		;LOCATION OF AC'S FOR FORCED USER REFS
TRAPS0=PSB+571		;PAGER TRAP STATUS WORD
TRAPWD=PSB+572		;PAGER TRAP WRITE DATA
TRAPPC=PSB+573		;PAGER TRAP PC
TRAPAP=PSB+574		;PAGER TRAP AC-P
TRAPSW=PSB+575		;TRAP OLD STATUS WORD
UTRSW=PSB+576		;SAVED TRAPSW FOR USER
UTRWD=PSB+577		;SAVED TRAPWD FOR USER

TS JOBNO,1		;JOB NUMBER TO WHICH THIS FORK BELONGS
TS JOBBIT,1		;SCHEDULER CONTROL BITS
TS JOBCK0,1		;VARIABLES FOR SCHEDULER TIME QUARANTEE
TS JOBCK1,1		; ..

TS FKTAB,NLFKS/2	;LOCAL FORK HANDLE TO JOB HANDLE TABLE

TS FORKN,1		;JOB FORK NUMBER OF TOP FORK,,THIS FORK
TS FKRT,1		;FORK RUN TIME
TS ENTVEC,1		;ENTRY VECTOR POINTER
TS PATADR,1		;10/50 COMPATABILITY ENTRY VECTOR
TS PATU40,1		;WHERE TO STORE C(40), SETUP AS UMOVEM 1,XX
TS PATUPC,1		;WHERE TO STORE PC, SETUP AS UMOVEM 1,YY

TS MPP,1		;MONITOR SAVED STACK POINTER AT LAST MENTR
TS UPP,1		;MON ROUTINES STACK POINTER
TS SLOWF,1		;SLOW MON ROUTINE FLAG
TS XMENTR,1		;MENTR-MRETN TEMP
TS XMENT1,1		;MENTR TEMP
TS INTDF,1		;DEFER INTERRUPTS IF .GE. 0
TS INTDFF,1		;SOS INTDF  OR JSYS PSISV1
TS MJRSTF,1		;JRSTF @FPC  OR  JRST PSISV0
TS ACBAS1,1		;ACBAS FOR FIRST MON CALL

TS TW1,1		;MON ROUTINE TEMPS
TS TW2,1
TS ITFPC,1		;FPC AT LAST ITRAP (FOR MON DEBUGGING)

TS PAC,20		;PROCESS AC'S
TS PPC,1		;PROCESS PC
TS PSB40,1		;PROCESS LOCATION 40

TS ENSKR,1		;SCHEDULER TEMP (RETURN)
TS SKDPC,1		;SCHEDULER TEMP (RETURN)
TS NSKED,1		;NO-SCHEDULE WORD
TS RSKED,1		;NO-SCHEDULE TRAP
TS NSWAP,1		;NO-SWAP FLAG

TS TRAPSK,NTSK		;STACK USED DURING PAGER TRAPS
TS PGTIM,1		;TIME SINCE LAST PAGE FAULT
TS TRAPC,1		;PAGER TRAP RECURSION COUNT
TS UTRPCT,1		;COUNT OF PAGER TRAPS FOR THIS PROCESS
TS USWPCT,1		;COUNT OF SWPINW CALLS FOR THIS PROCESS
TS PTTIM,1		;TIME SPENT IN PAGER TRAPS

TS MONBK,1		;INTERRUPT TO MONITOR IF NON-0
TS PIPC,1		;SAVED PC DURING INITIAL PI SERVICE
TS PIMSK,1		;PSI REQUEST WORD BEING PASSED TO PSI SERVICE
TS PIPDB,NPIPDL		;PSI ROUTINES STACK
TS PIAC,17		;SAVED USER AC'S DURING BREAK START
TS PIAC17,1		;SAVED USER AC17 .. ..

TS PSICHA,NTERMI/6	;CHANNEL ASSIGNED TO TERM CODE
TS PSIBW,1		;BREAK WAITING WORD
TS FORCTC,1		;CHANNEL WHICH CAUSED FORCED FORK TERMINATION
TS PSICHM,1		;CHANNEL ENABLED WORD
TS SUPCHN,1		;CHANNELS RESERVED BY SUPERIOR
TS PSIBIP,1		;BREAK IN PROGRESS WORD (LEVELS)
TS PSIPT,1		;PSI STORAGE LIST POINTER
TS PIOLDS,1		;FKSTAT PRIOR TO PSI IF WAS WAITING
TS LEVCHN,1		;LEVEL TABLE,,CHANNEL TABLE  ADDRESSES
TS PSISYS,1		;NON-0 IF PSI SYSTEM OFF
TS MONCHN,1		;CHANNELS RESERVED BY MONITOR
TS MONINT,1		;FOR DDT BREAKPOINTS
TS OVFLG,1		;NON-0 => INITIATE INTERRUPTS ON MONITOR OV'S

TS UPDL,NUPDL		;PDL FOR MONITOR CALLS

TS FPC,1		;MENTR-MRETN JSYS PC

;JOB STORAGE BLOCK ASSIGNMENTS

DEFINE JS (T,N)
<	IF2,<
	IFNDEF SCDV1,<EXTERN T>
	IFDEF SCDV1,<
	IFB <N>,<ASSIGN T,JSBLOC,1>
	IFNB <N>,<ASSIGN T,JSBLOC,N>
>>>

JS SYSFK,NUFKS		;JOB FORK INDEX TO SYSTEM FORK INDEX
JS FKPTRS,NUFKS		;FORK POINTERS (STRUCTURE)
JS FKPSIE,NUFKS		;TERM INTERRUPT ENABLED WORD
JS FREJFK,1		;FREE JOB FORK SLOT LIST

JS CTRLTT,1		;LINE NUMBER OF CONTROLLING TTY
JS TTSPSI,1		;CODE ENABLED ANYWHERE IN THIS JOB
JS JOBPMF,1		;JFN OF PRIV MEM FILE
JS CONSTO,1		;CONSOLE TIME ON
JS ACCTPT,1		;ACCOUNT NUMBER+5B2 OR ACCOUNT STRING PTR
JS LOGBUF,5		;LOGIN-OUT EFACT DATA, MUST PRECEDE ACCTSR
JS ACCTSR,11		;ACCOUNT STRING

;JSYS DISPATCH TABLE, INITIALIZED TO ALL ILLEGAL

IFDEF LDINIT,<
	EXTERN ITRAP
JSYSLC==0
>
;JSYS DEFINITIONS

DEFINE JD (N,A)
<	OPDEF N [JSYS A]
IFDEF LDINIT,<
	LOC 1000+JSYSLC
	IFL A-JSYSLC,<PRINTX JSYS'S MUST BE DEFINED IN ORDER>
	REPEAT A-JSYSLC,<XWD FPC,UJSYS>
	EXTERN .'N
	XWD FPC,.'N
JSYSLC==.-1000
	RELOC
>>

JD LOGIN,1
JD CRJOB,2
JD LGOUT,3
JD CACCT,4
JD EFACT,5
JD SMON,6
JD TMON,7
JD GETAB,10
JD ERSTR,11
JD GETER,12
JD GJINF,13
JD TIME,14
JD RUNTM,15
JD SYSGT,16
JD GNJFN,17
JD GTJFN,20
JD OPENF,21
JD CLOSF,22
JD RLJFN,23
JD GTSTS,24
JD STSTS,25
JD DELF,26
JD SFPTR,27
JD JFNS,30
JD FFFFP,31
JD RDDIR,32
REPEAT 0,<JD CPRTF,33>
JD CLZFF,34
JD RNAMF,35
JD SIZEF,36
JD GACTF,37

JD STDIR,40
JD DIRST,41
JD BKJFN,42
JD RFPTR,43
JD CNDIR,44
JD RFBSZ,45
JD SFBSZ,46
JD SWJFN,47
JD BIN,50
JD BOUT,51
JD SIN,52
JD SOUT,53
JD RIN,54
JD ROUT,55
JD PMAP,56
JD RPACS,57
JD SPACS,60
JD RMAP,61
JD SACTF,62
JD GTFDB,63
JD CHFDB,64
JD DUMPI,65
JD DUMPO,66
JD DELDF,67
JD ASND,70
JD RELD,71
JD CSYNO,72
JD PBIN,73
JD PBOUT,74
JD PSIN,75
JD PSOUT,76
JD MTOPR,77

JD CFIBF,100
JD CFOBF,101
JD SIBE,102
JD SOBE,103
JD DOBE,104
JD GTABS,105
JD STABS,106
JD RFMOD,107
JD SFMOD,110
JD RFPOS,111
JD RFCOC,112
JD SFCOC,113
JD STI,114
JD DTACH,115
JD ATACH,116
JD DVCHR,117
JD STDEV,120
JD DEVST,121
JD MOUNT,122
JD DSMNT,123
JD INIDR,124
JD SIR,125
JD EIR,126
JD SKPIR,127
JD DIR,130
JD AIC,131
JD IIC,132
JD DIC,133
JD RCM,134
JD RWM,135
JD DEBRK,136
JD ATI,137
JD DTI,140
JD CIS,141
JD SIRCM,142
JD RIRCM,143
JD RIR,144
JD GDSTS,145
JD SDSTS,146
JD RESET,147

JD RPCAP,150
JD EPCAP,151
JD CFORK,152
JD KFORK,153
JD FFORK,154
JD RFORK,155
JD RFSTS,156
JD SFORK,157
JD SFACS,160
JD RFACS,161
JD HFORK,162
JD WFORK,163
REPEAT 0,<JD GFRKH,164
JD RFRKH,165
JD GFRKS,166>
JD DISMS,167
JD HALTF,170
JD GTRPW,171
JD GTRPI,172
JD RTIW,173
JD STIW,174
JD SOBF,175
REPEAT 0,<JD RWSET,176>

JD GET,200
JD SFRKV,201
JD SAVE,202
JD SSAVE,203
JD SEVEC,204
JD GEVEC,205
JD GPJFN,206
JD SPJFN,207
JD SETNM,210
JD FFUFP,211
JD DIBE,212
JD FDFRE,213
JD GDSKC,214
JD LITES,215
JD TLINK,216

JD ODTIM,220
JD IDTIM,221
JD ODCNV,222
JD IDCNV,223
JD NOUT,224
JD NIN,225
JD STAD,226
JD GTAD,227
JD ODTNC,230
JD IDTNC,231
JD FLIN,232
JD FLOUT,233
JD DFIN,234
JD DFOUT,235

JD CRDIR,240
JD GTDIR,241
JD DSKOP,242
JD SPRIW,243
JD DSKAS,244
JD SJPRI,245

IFDEF DSPCHN,<
JD ASNDP,260		; E&S JSYS'S
JD RELDP,261
JD ASNDC,262
JD RELDC,263
JD STRDP,264
JD STPDP,265
JD STSDP,266
JD RDSDP,267
JD WATDP,270
>

IFDEF IMPCHN,<
JD ATPTY,274
JD CVSKT,275
>

JD GCVEC,300
JD SCVEC,301

;TEMPORARY DEF'S
JD MRPAC,772
JD TTMSG,775
JD EXEC,777
;2 DEC 71, 1659:

;PI DISPATCH MODULE - D. MURPHY
;SYSTEM INITIALIZATION

;CELLS NOT CHANGED DURING DISK RELOAD OF RES MON

	EXTERN RLRMON,DIDSCI,DIDSCA
	INTERN SYSGO1,MSTKOV,SYSGO,SYSLOD

CRSTD1=27		;CRASH TIME AND DATE SAVED WHILE RELOADING
BUGHAD=26		;BUGHLT AND CHK ADDRESSES SAVED WHILE RELOADING
DBUGS1=25		;DBUGSW SAVED WHILE RELOADING

;MANUAL START TRANSFER VECTOR

	LOC 140
	JRST SYSRST		;RESTART
	0
	0
	0
	0
	0
	JRST SYSGO		;146/ RELOAD AND START
	JRST SYSGO1		;147/ START
	RELOC

;DEFINE APPROPRIATE SYMBOLS FOR EXISTENT DEVICES

IFDEF DSKCHN,<	INTERN DSKCHN,DSKCHR
	EXTERN DSKINI,DSKRST,DSKSV>
IFDEF DRMCHN,<	INTERN DRMCHN,DRMCHR
	EXTERN DRMINI,DRMRST,DRMSV>
IFDEF MTACHN,<	INTERN MTACHN,MTDCHN,MTACHR
	EXTERN MTASV,MTARST>
IFDEF LPTCHN,<	INTERN LPTCHN,LPTCHR
	EXTERN LPTSV,LPTRST>
IFDEF DSPCHN,<	INTERN DSPCHN,DSPCHR,DSPBIT
	EXTERN DSPSV,NRUNG,DSPCNT,DSPRSK,DSPRST>
IFDEF DTACHN,<	INTERN DTACHN,DTDCHN,DTACHR
	EXTERN DTASV,DTARST>
IFDEF PTRCHN,<	INTERN PTRCHN,PTRCHR
	EXTERN PTRSV,PTRRST>
IFDEF PTPCHN,<	INTERN PTPCHN,PTPCHR
	EXTERN PTPSV,PTPRST>
IFDEF PLTCHN,<	INTERN PLTCHN,PLTCHR
	EXTERN PLTSV,PLTRST>
IFDEF DLSCHN,<	INTERN DLSCHN,DLSCHR
	EXTERN TTINIT,TTRSET,CTYLIN,DLSSV>
IFDEF IMPCHN,<	INTERN IMPCHN,IMPCHR
	EXTERN IMPSV,IMPRST>

GS DBUGSW,1	;0=UNATTENDED, 1=ATTENDED, 2=DEBUGGING
GS GETSMF,1	;MONITOR SAVED ON DSK IF NON-0
GS CRSTAD,1	;TIME AND DATE SAVED ON LAST AUTO-RESTART

;RELOAD SYSTEM FROM DISK AND RESTART

SYSGO:	PIOFF 610000		;RESET PI
	CONO APR,200000		;RESET IO
	MOVE 1,BUGHLT		;SAVE POSSIBLY INTERESTING CELLS
	HRL 1,BUGCHK
	MOVEM 1,BUGHAD
	MOVE 1,DBUGSW
	MOVEM 1,DBUGS1
	SKIPLE DISKP		;IF NO DISK
	SKIPG GETSMF		;OR NO SAVED MONITOR
	JRST .+2		;DON'T TRY TO RELOAD
	JSP 7,RLRMON		;RELOAD MON FROM DISK, THEN START
	MOVE 1,BUGHAD		;RESTORE CELLS
	HRRZM 1,BUGHLT
	HLRZM 1,BUGCHK
	MOVE 1,CRSTD1
	MOVEM 1,CRSTAD
	MOVE 1,DBUGS1
	MOVEM 1,DBUGSW

;START FROM SCRATCH AFTER DECTAPE LOADING

SYSGO1:	SKIPA 7,DIDSCI
SYSLOD:	SETZ 7,			;CLEAR DIDSCA TO RELOAD DISK
	MOVE P,PI7P
	CONO APR,200000		;RESET IO DEVICES
	CONO PI,610000		;RESET PI
	MOVE 1,[XWD 5000,5000+1]
	SETZM -1(1)
	BLT 1,SCDVE
	MOVEM 7,DIDSCA
	AOS INSKED
	MOVE 1,[JRST BUGH0]	;SETUP JSR DISPATCHES
	MOVEM 1,BUGHLT+1
	MOVE 1,[JRST BUGC0]
	MOVEM 1,BUGCHK+1
	MOVE 1,MONCOR
	CAME 1,SWPCOR		;DDT BEING FLUSHED?
	JRST .+3		;NO
	SETZM DBUGSW		;YES, MUST BE NOT BREAKPOINTS
	SETZM 100		;AND NO MANUAL DDT START
	CALL PGRINI		;INIT DST, CST, ETC.
	IFDEF DRMCHN,<CALL DRMINI>		;DRUM
	IFDEF DSKCHN,<CALL DSKINI>		;DISK
	IFDEF DLSCHN,<CALL TTINIT>		;TELETYPE MODULE
	CALL SCDIN		;SCHEDULER
	CALL PIINIT		;PI MODULE - LAST INIT
	MOVE 1,[XWD CTYLIN,JOBSRT]
	CALL SCDRQ7		;INITIATE FIRST JOB
	JRST SCHED0		;TO SCHEDULER

;RESTART SYSTEM

	DEFINE DEVRST (A)
<	IFDEF A'CHN,<CALL A'RST>>

SYSRST:	MOVE P,PI7P
	CONO APR,200000
	CONO PI,410000
	SETZM PWRDWN
	CALL PGRRST
	IFDEF DLSCHN,<CALL TTRSET>
	DEVRST DRM
	DEVRST DSK
	DEVRST MTA
	DEVRST LPT
	DEVRST DSP
	DEVRST DTA
	DEVRST PTR
	DEVRST PTP
	DEVRST PLT
	DEVRST IMP
	PUSH P,INSKED
	MOVEI 1,1
	MOVEM 1,INSKED
	SETZM SKEDF1
	SETZM SYNCC
	CALL PIINIT
	CALL SWPRST		;SWAPPER CLEANUP
	POP P,1
	JUMPN 1,SCHED0		;RESUME SCHED IF THERE AT CRASH
	SETZM INSKED
	SETOM TRAPC
	MOVSI 1,UMODF		;CRASH PROCESS RUNNING AT CRASH
	MOVEM 1,FPC
	JRST ITRAP

;IMPOSSIBLE SITUATION HALT

	EXTERN BUGTYO,BUGMSG,EXBUGH,TADDAY

LS BUGHLT,2

BUGH0:	SOS BUGHLT
	SKIPE DBUGSW		;DEBUG MODE?
	JRST 4,@BUGHLT		;YES
	AOS JB0FLG		;GET IT REPORTED SOON
	SKIPN INSKED		;IN SCHEDULER?
	CONSZ PI,177B27		;OR IN PI?
	JRST .+2
	JRST EXBUGH		;NO, CRASH THIS JOB
	PIOFF			;TURN OFF SYSTEM
	MOVEI 1,[SIXBIT '$BUGHLT AT /']
	JSR BUGMSG		;TYPE CRASH MESSAGE
	HRLZ 2,BUGHLT
	MOVEI 3,6		;TYPE 6 DIGITS
BUGH1:	SETZ 1,
	LSHC 1,3
	ADDI 1,"0"
	JSR BUGTYO
	SOJG 3,BUGH1
	MOVEI 1,[SIXBIT '$/']
	JSR BUGMSG
	SETZM CRSTD1
	SKIPGE TADSEC		;TIME AND DATE NOW SET?
	JRST BUGH2		;NO
	MOVE 1,TODCLK		;YES, REMEMBER IT FOR RESTART
	IDIVI 1,^D1000
	ADDI 1,^D10		;ADD 10 SECS FOR WHEN CLOCK IS OFF
	ADD 1,TADSEC		;CONVERT TODCLK AND OFFSET TO
	IDIVI 1,^D24*^D3600	;INTERNAL FORM TIME AND DATE
	ADD 1,TADDAY		;SEE GTAD
	HRLI 2,0(1)
	MOVEM 2,CRSTD1		;CRASH TIME AND DATE
BUGH2:	JRST SYSGO

;LESS SERIOUS HALT

LS BUGCHK,2

BUGC0:	SKIPE DBUGSW		;DEBUG MODE?
	JFCL			;YES, BREAKPOINT HERE
	AOS JB0FLG		;GET IT REPORTED
	JRST @BUGCHK		;CONTINUE

;PI SYSTEM INITIALIZATION

PIINIT:	MOVSI 1,<JSYS>B53	;SETUP JSYS DISPATCHES IN LOWER CORE
	MOVSI 3,-NPISET
PII1:	HRR 1,PISETT(3)		;DISPATCH ADDRESS WITH JSYS
	HLRZ 2,PISETT(3)	;LOC OF WHERE IT GOES
	MOVEM 1,0(2)
	AOBJN 3,PII1
	CONO APR,473550+APRCHN	;SET APR FLAGS
	CONO PI,642200+177	;CLEAR FLAGS, SET CHANNELS ON
	RET

;IMAGE OF LOW CORE PI LOCS

	DEFINE PILC (C,A)
<	XWD 40+2*C,A>

PISETT:	XWD 41,UUOH		;UUO'S AND ILLEG. INSTR'S
	PILC APRCHN,PIAPR	;APR CHANNEL
	PILC 4,PISC4		;GENERAL CHANNELS
	PILC 5,PISC5
	PILC 6,PISC6
	PILC 7,PISC7
	XWD 61,UU60		;UNIMPLEMENTED INSTR'S
	XWD 70,PGRTRP		;PAGER TRAP
NPISET==.-PISETT

LS PIAPRX,1
LS PI1AC1,1

LS PISC5R,1
LS PI5AC,5

;CHANNEL DISPATCH ROUTINES

PIAPR:	XWD PIAPRX,.+1
	CONSO OAP,1B28		;1MS. CLOCK?
	JRST PIAPR1		;NO
	CONO OAP,1B28		;YES, CLEAR THE FLAG
	AOS TODCLK		;COUNT DAYTIME
	SOSG SYNCC		;TIME TO SYNC?
	CONO OAP,1B29		;YES, TURN OFF CLOCK
IFDEF DSPCHN,<		;IF DISPLAY ON SYSTEM,
	SKIPE NRUNG		;CHECK FOR END OF FRAME RESCHEDULE
	SOSLE DSPCNT
	JEN @PIAPRX
	SKIPN DSPCNT
	SETOM DSPRSK
	ISB DSPCHN>
	JEN @PIAPRX

PIAPR1:	CONSZ APR,1B26		;60 CY CLOCK
	JRST APCLK1
	MOVEM 1,PI1AC1
	CONSZ APR,1B21		;ADR BRK?
	JRST ADRBK
	CONSZ APR,1B19		;PDL OVF
	JRST P1POV
	CONSZ PI,1B18		;PWR FAIL?
	JRST ACFAIL		;YES
	SKIPN DEVMPE		;DEVICE DETECTED MPE?
	CONSZ PI,1B19		;PARITY ERROR?
	JRST MEMPAR		;YES
	CONSZ APR,1B23+1B22	;NXM, MEM PROT
	JRST P1NXM
	CONI APR,1		;OV OR FOV
	TRC 1,3B29+3B32
	TRNN 1,3B29		;FOV AND FOV ENABLED
	JRST P1FOV
	TRNN 1,3B32		;OV AND OV ENABLED
	JRST P1OV
	JRST OV0		;NOTHING, DEBREAK

;ADDRESS BREAK, ASSUMED TO BE USED FOR WRITE ONLY

ADRBK:	CONO APR,1B21+APRCHN	;CLEAR FLAG
	MOVE 1,ADRBKW		;CHECK TO SEE IF PROTECTED WORD NOW
	CAMN 1,@ADRBKA		;WRONG.  ANY OTHER APPROPRIATE
	JRST OV0		;CHECK ROUTINE CAN BE PATCHED IN HERE
	JRST OV0

LS ADRBKW,1			;PROPER CONTENTS OF CHECKED WORD
LS ADRBKA,1			;ADDRESS OF CHECKED WORD

;OVERFLOWS

P1FOV:	TRNN 1,3B32		;OV ENABLED TOO?
	SKIPA 1,[1B0+1B3]	;YES, CLEAR OV AND FOV FLAGS
	MOVSI 1,(1B3)		;NO, CLEAR FOV ONLY
	ANDCAM 1,PIAPRX		;CLEAR FLAG CAUSING INTERRUPT
	MOVEI 1,P7FOV
	JRST FOV1

P1OV:	MOVSI 1,(1B0)
	ANDCAM 1,PIAPRX		;CLEAR FLAG
	MOVEI 1,P7OV
FOV1:	SKIPN INSKED		;IGNORE IF: IN SCHED, OR
	CONSZ PI,177B27-1B<APRCHN+20> ;IN PI SERVICE
	JRST OV0
	JFCL 17,.+1		;CLEAR FLAGS
	HLL 1,PIAPRX
	TLNN 1,UMODF		;IF IN USER MODE, OR
	SKIPE OVFLG		;IN MONITOR WITH FLAG SET,
	JRST OV1
	HRL 1,PIAPRX
	TLC 1,PGRTRP+1
	TLNE 1,-1		;CAME FROM FIRST INSTRUCTIONOF PGR TRP?
	JRST OV0		;NO
	HLL 1,TRAPPC		;YES, SO REAL PC IS THERE
	TLNE 1,UMODF		;IS THAT USER?
	JRST OV1		;YES, REQUEST INTERRUPT
	JRST OV0

P1NXM:	CONSZ APR,1B22		;MEM PROT?
	JRST P1PRT		;YES
	BUG(CHK,<NXM DETECTED BY PROCESSOR>)
	CONO APR,1B23+APRCHN	;THEN CLEAR FLAGS
	MOVE 1,PIAPRX
	TLNN 1,UMODF		;USER PC?
	BUG(HLT,<FATAL XNM>)
	MOVEI 1,MPEINT		;GIVE USER MPE INTERRUPT
	JRST OV1

P1PRT:	BUG(CHK,<MEM PROT VIOL REPORTED BY PROCESSOR>)
	DATAO APR,[XWD 776776,0] ;RESET IT IN CASE WAS CLEARED RANDOMLY
	CONO APR,1B22+APRCHN	;CLEAR FLAG
	JRST OV0		;AND PROCEED

P1POV:	CONO APR,1B18+APRCHN	;CLEAR FLAG
	MOVE 1,PIAPRX
	TLNN 1,UMODF		;FROM MONITOR?
	JRST P1SOV
P1UPOV:	MOVEI 1,P7POV
OV1:	HRL 1,FORKX
	JSR SCDRQ		;REQUEST SCHEDULER ACTION
	RESKED
OV0:	MOVE 1,PI1AC1
	JEN @PIAPRX

P1SOV:	MOVEI 1,0(1)
	CAIE 1,PGRTRP+1		;FROM PAGER TRAP STARTING?
	JRST P1MSOV		;NO, REAL MSOV
	MOVE 1,TRAPPC		;MEM TRAP AS WELL AS SOV, GET PC
	TLNE 1,UMODF		;THIS ONE USER?
	JRST P1UPOV		;YES
P1MSOV:	MOVE 1,PI1AC1
	JEN @[MSTKOV]

MSTKOV:	CONSO PI,177B27		;BAD ONE?
	SKIPE INSKED
	BUG(HLT,<PDL OVERFLOW IN SCHEDULER OR WHILE PI IN PROGRESS>)
	BUG(CHK,<PDL OVERFLOW IN MONITOR>)
	SETOM TRAPC		;NOT SO BAD
	MOVE P,UPP		;GET A REASONABLE STACK
	ADD P,BHC+2
	JRST ITRAP

;AC FAIL

ACFAIL:	CONO PI,1B18		;CLEAR FLAG
	AOS PWRDWN		;SET FLAG TO NOTIFY SCHED
	RESKED			;NOW
	JRST OV0

;MEMORY PARITY ERROR DETECTED

MEMPAR:	PIOFF
	SETZB 1,6		;TO COUNT BAD AND FATAL WORDS
	MOVEM 7,MEMPA+7		;SAVE SOME AC'S
	MOVEI 7,MEMPA
	BLT 7,MEMPA+6
	CONO PI,1B19+1B20	;CLEAR PAR FLAG AND DISABLE INTERRUPT
	CONO PGR,4		;TURN OFF PAGER
	MOVEI 1,[SIXBIT '$DEVICE DETECTED/']
	SKIPE DEVMPE		;REQUEST FROM DEVICE?
	JSR BUGMSG		;YES, SAY SO
	MOVEI 1,[SIXBIT '$MPE, PC=/']
	JSR BUGMSG
	HRRZ 1,PIAPRX
	JSR BUGOPT
	MOVEI 1,[SIXBIT ', MONITOR/']
	MOVSI 2,UMODF
	TDNE 2,PIAPRX
	MOVEI 1,[SIXBIT ', USER/']
	JSR BUGMSG
	MOVEI 1,[SIXBIT '$ LOC    CONTENTS$/']
	JSR BUGMSG
	MOVEI 2,20		;START AT LOC 20
MEMP2:	MOVE 0(2)		;REFERENCE THE LOCATION
	CONSZ APR,1B23		;NXM?
	JRST [	ADDI 2,1000-1	;YES, INCREMENT TO NEXT PAGE
		CONO APR,1B23+APRCHN ;CLEAR NXM FLAG
		JRST MEMP4]
	CONSZ PI,1B19		;MPE IN THIS LOCATION?
	JRST MEMP1		;YES, GO REPORT IT
MEMP4:	CAIGE 2,777777		;DONE ALL OF CORE?
	AOJA 2,MEMP2		;NO, DO NEXT LOCATION
	MOVEI 1,[SIXBIT '$/']
	SKIPN MEMPA+1		;IF NO DETECTED ERRORS,
	MOVEI 1,[SIXBIT '$NONE FOUND$/'] ;SAY SO
	JSR BUGMSG		;TYPE EOL
	CONO PI,1B21		;RE-ENABLE MPE INTERRUPT
	CONO PGR,6		;TURN PAGER BACK ON
	MOVSI 7,MEMPA		;RESTORE AC'S
	BLT 7,7
	PION
	BUG(CHK,<MEMORY PARITY ERROR DETECTED BY APR OR DEVICE>)
	JUMPN 6,MEMP8		;CRASH IF FATAL ONES FOUND
	SKIPE DEVMPE		;DEVICE DETECTED?
	JRST MEMP7		;YES, PROCEED
	MOVE 1,PIAPRX		;NO, APR
	TLNN 1,UMODF		;WAS IN MONITOR MODE?
MEMP8:	BUG(HLT,<FATAL PARITY ERROR>)
	MOVEI 1,MPEINT		;GIVE INTERRUPT TO USER
	HRL 1,FORKX
	JSR SCDRQ
	RESKED
MEMP7:	SETZM DEVMPE
	MOVE 1,TODCLK		;HERE TO PROCEED, UNLESS...
	EXCH 1,PARTIM		;SET TIME OF THIS MPE, GET TIME OF LAST
	SKIPE DBUGSW		;SYSTEM ATTENDED?
	JRST OV0		;YES, SKIP TIME CHECK
	ADD 1,[^D300000]	;WAS LAST ERROR WITHIN 5 MINUTES?
	CAML 1,TODCLK
	JRST MEMP8		;YES, FATAL
	JRST OV0		;NO, CONTINUE RUNNING

;FOUND MEM PAR ERR ON DIRECT REFERENCE

MEMP1:	MOVEM 0(2)		;REWRITE WORD TO ELIMINATE MPE
	AOS 1,MEMPA+1		;COUNT ERRORS
	CONO PI,1B19		;CLEAR FLAG
	CAIL 1,20		;REPORTED A LOT ALREADY?
	JRST MEMP4		;YES, QUIT REPORTING THEM
	MOVEI 1," "
	JSR BUGTYO
	MOVEI 1,0(2)
	JSR BUGOPT		;TYPE ADDRESS
	MOVEI 1," "
	JSR BUGTYO
	HLRZ 1,0(2)
	JSR BUGOPT		;TYPE LH OF BAD WORD
	MOVEI 1,","
	JSR BUGTYO
	HRRZ 1,0(2)
	JSR BUGOPT		;TYPE RH OF BAD WORD
	MOVEI 1,[SIXBIT '$/']	;TYPE EOL
	JSR BUGMSG
	MOVEI 1,0(2)		;TRY TO DECIDE IF ERROR IS IN SENSITIVE
	LSH 1,-^D9		;PAGE. IF SO, BUMP FATAL COUNT
	CAMGE 1,SWPCOR		;RESIDENT MON?
	JRST MEMP5		;YES, TOO BAD
	MOVSI 3,SWPERR		;MARK ERROR IN PAGE
	IORM 3,CST3(1)
	MOVE 3,CST2(1)		;OWNER
	TLNE 3,-1		;SPT?
	JRST MEMP6		;NO
	CAIGE 3,NOFN		;YES, INDEX BLOCK
	JRST MEMP5		;DANGEROUS TO HAVE BAD XB'S AROUND
	MOVE 3,SPTH(3)		;GET OWNER
	JUMPE 3,MEMP5		;DANGEROUS TO HAVE BAD PT'S OR PSB'S
MEMP6:	HLRZ 3,3		;OWNING PT
	CAMN 3,MMSPTN		;MON MAP?
MEMP5:	AOJ 6,			;COUNT FATAL ERRORS
	JRST MEMP4		;CONTINUE CORE SCAN

LS MEMPA,10		;STORAGE FOR AC'S

GS DEVMPE,1		;AOS'D TO REQUEST CORE SCAN
LS PARTIM,1		;TIME OF LAST PAR ERR

;NON-PI 6-DIGIT NUMBER TYPEOUT ON CONSOLE TTY

BUGOP1:	0
BUGOPT:	0
	MOVEM 1,BUGOP1
	MOVE 0,[POINT 3,BUGOP1,17]
BUGOP2:	ILDB 1,0
	ADDI 1,"0"
	JSR BUGTYO
	TLNE 0,770000
	JRST BUGOP2
	JRST @BUGOPT

IFDEF DTACHN,<INTERN DTABIT	;BIT FOR DTA CHANNEL IN CONO PI,
	DTABIT==1B<DTACHN+28>
>

PISC4:	XWD PI4R,.+1
	MOVEM 4,PI4AC+4
	MOVEI 4,PI4AC
	BLT 4,PI4AC+3
	IFDEF DRMCHN,<JSYS DRMSV>
	IFDEF DTACHN,<JSYS DTASV>
	IFDEF DSKCHN,<JSYS DSKSV>
	IFDEF MTACHN,<JSYS MTASV>

MTACHR:
DTACHR:			;DEVICE RETURNS
DRMCHR:
DSKCHR:	MOVSI 4,PI4AC
	BLT 4,4
	JEN @PI4R

LS PI4AC,5
LS PI4R,1

PISC5:	XWD PISC5R,.+1
	MOVEM 4,PI5AC+4		;SAVE AC'S 0-4
	MOVEI 4,PI5AC
	BLT 4,PI5AC+3
	IFDEF DLSCHN,<JSYS DLSSV>
	IFDEF PTRCHN,<JSYS PTRSV>
	IFDEF IMPCHN,<JSYS IMPSV>
IMPCHR:
PTRCHR:
DLSCHR:	MOVSI 4,PI5AC		;RETURN FROM DEVICE ROUTINES HERE
	BLT 4,4			;RESTORE AC'S 0-4
	JRST 12,@PISC5R

PISC6:	XWD PI6R,.+1
	MOVEM 4,PI6AC+4
	MOVEI 4,PI6AC
	BLT 4,PI6AC+3
	IFDEF DSPCHN,<JSYS DSPSV>
	IFDEF LPTCHN,<JSYS LPTSV>
	IFDEF PTPCHN,<JSYS PTPSV>
	IFDEF PLTCHN,<JSYS PLTSV>
PLTCHR:
PTPCHR:
DSPCHR:
LPTCHR:	MOVSI 4,PI6AC
	BLT 4,4
	JRST 12,@PI6R

LS PI6R,1
LS PI6AC,5

	INTERN MENTR,MRETN,MONUUO,UJSYS,MRETNE
	EXTERN GETPAT

UU60:	XWD FPC,ILUUO		;JSYS AT 61

IUUO:	MOVE 1,XMENTR		;RESTORE AC1
ILUUO:	ITERR ILINS1		;ILLEGAL UUO

;UUO DISPATCH

UUOH:	XWD FPC,.+1		;41 CONTAINS JSYS UUOH
	MOVEM 1,XMENTR		;SAVE AC1
	MOVE 1,FPC
	TLNE 1,UMODF		;USER CALL?
	JRST UUOHX		;YES
	MOVE 1,XMENTR
	BUG(CHK,<UUO FROM MONITOR>)
MONUUO:	JRST ILUUO

UUOHX:	HLRZ 1,40		;GET OP CODE
	LSH 1,-^D9
	CAIL 1,100		;OUT OF BOUNDS?
	JRST IUUO		;YES, ILLEGAL INSTRUCTION
	CAIL 1,40		;10/50 UUO?
	JRST UU1050		;YES
	JUMPE 1,IUUO		;0 IS ALWAYS ILLEG
	BUG(HLT,<01-37 UUO FROM USER MODE>)

REPEAT 0,<	;THIS WON'T BE USED UNLESS SOMEBODY WANTS
		;MON-MON OR USER-MON UUO'S INSTALLED
	SKIPL 1,UUOT(1)		;GET DISPATCH WORD, CHECK TYPE
	JRST UUOH2		;SLOW
	EXCH 1,XMENTR		;FAST, RESTORE AC1, SETUP DISPATCH ADR
	JRST @XMENTR		;COMMENCE ROUTINE
>

UU1050:	SKIPN PATADR		;GOT PAT NOW?
	JRST [	MOVE 1,XMENTR	;NO
		JRST GETPAT]	;GO GET IT
	MOVE 1,40		;MOVE STUFF FOR 10/50 COMPAT
	XCT PATU40		;CONTAINS UMOVEM 1,MONUUO
	MOVE 1,FPC
	XCT PATUPC		;CONTAINS UMOVEM 1,MONUPC
	MOVE 1,PATADR		;ENTRY VECTOR
	HRRM 1,FPC
	MOVE 1,XMENTR
	XCT MJRSTF

;ALL UNDEFINED JSYS'S

UJSYS:	ITERR ILINS2

;SLOW-CALL SETUP ROUTINE

MENTR:	XWD XMENTR,UUOH1	;SLOW JSYS'S BEGIN WITH  JSYS MENTR

UUOH2:	EXCH 1,XMENTR		;SLOW UUO'S ENTER HERE
UUOH1:	SETOM SLOWF
	EXCH 0,FPC		;GET RETURN PC
	TLNE 0,UMODF		;USER OR MONITOR MODE?
	JRST MENT1		;USER
	AOSGE INTDF		;INTDF ALLRIGHT?
	BUG(CHK,<AT MENTR - INTDF OVERLY DECREMENTED>)
	SOS INTDF
	PUSH P,INTDF
	PUSH P,MPP		;SAVE PREVIOUS ERRORSET
	PUSH P,0		;SAVE RETURN
	MOVEM P,MPP		;SAVE CURRENT STACK POINTER
	AOS P,ACBAS		;GET NEXT AC BASE ADR
	CAIL P,<EUACB>B39	;USED ALL BLOCKS OF AC'S?
	BUG(HLT,<MENTR - NO MORE AC BLOCKS>)
	SETACB P		;GIVE IT TO PAGER
MENT2:	MOVE 0,XMENTR		;LOCAL RETURN => FPC
	EXCH 0,FPC		;AC0 => 0
	SETZ P,
	XCTMU [BLT P,P-1]	;MOVE FROM REAL AC'S TO USER BLOCK
	MOVE P,MPP		;RESTORE P
	SETZM SLOWF
	XCT MJRSTF		;JRSTF @FPC  OR INTERRUPT

MENT1:	MOVEM P,XMENT1		;SAVE USER'S AC-P
	MOVE P,UPP		;GET STACK POINTER
	PUSH P,0		;TWO RETURNS
	PUSH P,0		;SO ONE CAN BE DIDDLED
	MOVEM P,MPP
	SETOM INTDF
	MOVE P,ACBAS1		;FIRST AC BASE TO USE
	MOVEM P,ACBAS
	SETACB P		;SET PAGER
	MOVE P,XMENT1		;RESOTRE USER'S AC-P
	UMOVEM P,P		;PUT USER'S AC-P WHERE IT BELONGS
	JRST MENT2

;SLOW-CALL RETURN

MRETNE:	MOVEM 1,LSTERR		;ERROR RETURN, SAVE ERROR CODE
	UMOVEM 1,1		;AND RETURN IT TO USER ALSO
MRETN:	SETOM SLOWF		;RESET FLAG
	AOSGE INTDF		;INTDF OK?
	BUG(CHK,<AT MRETN - INTDF OVERLY DECREMENTED>)
	MOVE P,MPP		;GET STACK POINTER AT LAST ENTRY
	POP P,0			;POP RETURN
	MOVEM 0,FPC		;SETUP RETURN
	TLNN 0,UMODF		;USER MODE?
	JRST MRETN1		;NO
	SETZ P,
	XCTUM [BLT P,P]		;RESTORE USER AC'S
	XCT MJRSTF		;RETURN OR INTERRUPT

MRETN1:	MOVEM P,MPP		;SAVE P
	SETZ P,
	XCTUM [BLT P,P-1]	;RESTORE AC'S
	SOS P,ACBAS		;RESET AC BASE TO LAST ONE
	CAIGE P,<UACB>B39	;BEFORE BEGINNING OF AC BLOCKS?
	BUG(HLT,<MRETN - TRIED TO OVER-POP AC BLOCKS>)
	SETACB P
	MOVE P,MPP
	POP P,MPP		;RESTORE PREVIOUS STACK POINTER
	POP P,INTDF		;RESTORE INTERRUPT DEFERRED STATE
	SETZM SLOWF
	XCT MJRSTF		;RETURN OR INTERRUPT

REPEAT 0,<	;NOT USED UNLESS MON-MON OR USER-MON UUO'S INSTALLED

;UUO DISPATCH TABLE

	DEFINE UUD (N,T)
<	EXTERN N
	XWD T*400000,N>

UUOT:	REPEAT 40,<XWD 400000,ILUUO>

	REPEAT 40,<XWD 0,GETPAT> ;LOADS 10/50 COMPATIBILITY
>

;LAST PAGE

	BGHERE MONBGP,MONBGS

	END

;2 DEC 71, 1645:

	TITLE SWPMON

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY

	EXTERN FORKX,FKPGS,INSKED,NPMAX,JB0FLG,DDTIME,IOIP
	EXTERN CHNSON,ITRAP,JOBPT,JOBRT,PSIRQB,TODCLK,FKJOB
	EXTERN GETCHA,RSKP,R,JFNOFN,SETMPG,BLOCKW
	EXTERN JBFINI,FILINI,SYSIFG,MMSPTN,CHKTIM,DRMIN0
	EXTERN JOBDNO,MRPACS,SWAKES,SBLKTM,FKWSP,PSILOB
	EXTERN ASSFK,EDISMS,FKPT,FKSTAT,FREFK,JSKP,JRET,WTLST,HLTJB
	EXTERN ILIST,DDMP,FPTA,SETPT,HALTF1,BLOCK1,FKOLDS
	EXTERN CLRM0,FKINT,FORCTM,HLTFK1,PSIR4,SUSFKR,SUSWT,WTFPGS
	EXTERN PRIMRY,CAPMSK,CAPENB,MLKPG,MULKPG,TENDMP
	EXTERN NXTDMP,TTPSRQ,UCLOCK,ITRAP1,SETOVF,SPTC,SPC1
	EXTERN JOBNAM,NNAMES,SNAMES,STIMES,SPFLTS,CRSTAD,CGFLG
	EXTERN SUPERP,PARALP,INFERP,PSIT1A,SWPMP0,PWRDWN,PASSWC
IFDEF IMPCHN,<
	EXTERN NETKFK>
IFDEF DSPCHN,<
	EXTERN DSPKFK>


WHEEL==1B18
OPER==1B19
LOG==1B21	;LEFT HALF

	INTERN .CFORK,.KFORK,.FFORK,.RFORK,.RFSTS,.SFORK,.RIR
	INTERN .RFACS,.SFACS,.HFORK,.WFORK,.SFRKV,.SEVEC,.GEVEC
	INTERN .RPCAP,.EPCAP,.DTACH,.ATACH,.SJPRI,.SIRCM,.RIRCM
	INTERN EXEC0,EXECI,.EXEC,EXBUGH,TTFRKT,SETLFK,GETMST,WMST
	INTERN WHEEL,OPER,FRZWT,.RTIW,.STIW,SWCEND,SVNM,SVN,SWPPC
	INTERN JB0TT,MDDT,.GCVEC,.SCVEC

JB0TTY==0		;TTY FOR JOB 0 MESSAGES, -1 FOR NONE
LOGTTY==0		;TTY FOR LOGIN/LOGOUT MESSAGES, -1 FOR NONE
MDDT=770000
SSTSIZ==30000		;MAX SIZE OF SWP SYM TAB
LMDDT==5000
EMDDT==MDDT+LMDDT
DDTSYM=MDDT+1

NGSP PHDDT,LMDDT/1000		;IMAGE OF MON DDT
NGSP BUGTAB,6			;BUG TABLE AND STRINGS
NGSP SWPST,SSTSIZ/1000		;SWP SYM TAB

;SYSTEM VERSION TEXT

DEFINE FOO (A)
<	ASCIZ @A@>
SVN:	SYSTXT
	0			;FOR PATCHES
SVNE:

	DEFINE TMSG
<	PUSHJ P,TMSGQ>

;PC FOR SWAPPABLE CODE FOR THIS ASSEMBLY

	SWPPC==SWPMPC	;DEFINED IN PARAMS

EXEC0:	MOVSI 1,UMODF		;SIMULATE CALL FROM USER
	MOVEM 1,FPC
	JSYS MENTR
	SKIPN SYSIFG		;NEW SYSTEM?
	CALL GETSWM		;YES, GET SWAPPABLE MONITOR
	MOVEI 1,FKPTRS
	MOVEI 2,NUFKS
	CALL ILIST
	MOVE 1,0(1)		;GRAB FIRST SLOT FOR TOP FORK
	MOVEM 1,FREJFK
	SETZM FKPTRS
	MOVE 1,FORKX
	MOVEM 1,SYSFK
	MOVE 1,[XWD SYSFK+1,SYSFK+2]
	SETOM -1(1)		;INIT REMAINDER OF TABLE
	BLT 1,SYSFK+NUFKS-1
	MOVSI 1,<JFCL>B53
	MOVEM 1,MONINT		;FOR DDT BREAKPOINT
	MOVE 1,[XWD ITFPC,EXECI]
	MOVEM 1,MONBK
	SETZ 1,
	MOVEI 2,3		;ENABLE CHANS 34 AND 35 FOR ^P
	MOVEM 2,MONCHN		;AND GRAB THEM IF THEY HAPPEN
	AIC
	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES
	CALL FILINI		;INIT FILE SYSTEM
	CALL MAPBTF		;INIT DSK BIT TABLE
	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK

SYSINE:	HRROI 2,[ASCIZ /<PMFDIR0>JOBPMF/]
	MOVE 1,JOBNO
	CAIGE 1,10
	HRROI 2,[ASCIZ /<SYSTEM>JOBPMF/] ;SYSTEM DIR FOR FIRST JOBS
	MOVSI 1,(1B5+1B8+1B17)	;TEMP FILE,IGN DEL AND SHORT FORM GTJFN
	GTJFN
	JRST PMFBAD
	HRRZM 1,JOBPMF
	MOVEI 2,1B19+1B20+1B21+1B25	;IN, OUT, XCT, THAWED
	OPENF			;OPEN PMF
	JRST PMFBAD
	MOVE 1,CTRLTT
	HRLI 1,600012		;CONSTRUCT DEVICE DESIGNATOR FOR CTRLTTY
	JFCL ;	ASND			;ASSIGN IT
	JFCL
	TIME
	MOVEM 1,CONSTO		;SET CONSOLE TIME ON
	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIGE 1,NSPECJ		;IS THIS ONE OF THEM?
	JRST [	MOVE 2,BHC+1	;YES, FAKE A LOGIN AS SYSTEM
		MOVEM 2,JOBDIR(1)
		HRRZ 2,SPECJT(1)
		JRST 0(2)]	;GO DO THE SPECIAL FUNCTION
	MOVEI 1,100
	MOVE 2,ETMOD		;GET TTY TO STANDARD STATE
	MOVE 3,CTRLTT
	CAIL 3,NTTYS		;NETWORK TTY?
	IORI 2,3B33		;YES, SET TO HALF-DUPLEX
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	MOVE 2,TAB81		;GET STANDARD TAB STOPS
	MOVE 4,2
	MOVE 3,TAB82
	STABS			;SET CONTROLLING TTY
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
	JRST STEX		;GO START EXEC

PMFBAD:	MOVEI 1,[SIXBIT 'NO PMF$/']
	TMSG
PMFB1:	HRROI 1,SVN
	PSOUT
	JRST EXCRR

;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.
 IFDEF IMPCHN,<XWD 0,RUNNET>	;START NETSER IF NETWORK EXISTS

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;DO LOGIN STUFF
	DTACH
	MOVE 1,JOBNO
	CAIGE 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST DONS1		;YES
	SETOM ENTFLG		;NO, PERMIT ENTRIES NOW
	GTAD
	JUMPGE 1,.+3		;OR DO WE NEED TIME AND DATE?
DONS1:	MOVE 1,[XWD CTYLIN,JOBSRT]
	CALL SCDRQ7		;START A JOB ON CTY
	RET

;THIS SPECIAL JOB STARTS NETSER (LOGGER, ETC.)

RUNNET:	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>NETSER.SAV/]
	GTJFN
	JRST [	MOVEI 1,[SIXBIT '$NO NETSER$/']
		TMSG
		CALL DONSJ	;COULDN'T START PROGRAM, DTACH ANYHOW
		JRST STEX]	;AND ENTER EXEC
	HRLI 1,400000
	GET
	CALL DONSJ		;DETACH AND START NEXT JOB
	MOVE 1,[XWD 20,^D34]
	ATI			;ENABLE ^P
	HRRZ 1,ENTVEC
	ADDI 1,1		;'REENTER' FOR DETACHED OPERATION
	HRRM 1,0(P)
	JRST MRETN

;GET SWAPPABLE MONITOR

	INTERN GETSWM,ULKSM1,RUNDD
	EXTERN BGTEND,LWTEND,GETSMF

GETSWM:	PUSH P,NPMAX		;SAVE CURRENT MAX SIZE
	MOVE 1,TOTRC
	MOVEM 1,NPMAX		;ALLOW ALL OF CORE WHILE GETTING SWM
	MOVEI 7,SWPMP0		;FIRST PAGE OF SWM
	MOVE 10,[DSKSMA]	;SWP MONS DISK ADDRESS
	NOSKED
LOKSM1:	MOVEI 2,0(7)
	LSH 2,^D9
	SKIP 0(2)		;REF THE PAGE THEREBY ASSIGNING IT
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	PUSH P,7
	CALL MLKPG		;LOCK THE PAGE
	POP P,7
	SKIPG GETSMF		;GETTING MONITOR FROM DISK?
	JRST LOKSM2		;NO
	MOVE 1,10		;YES, GET CURRENT ADDRESS
	CALL CVDSK		;CONVERT TO H'WARE FORMAT
	MOVEI 2,1000		;READ 1000 WORDS
	LDB 3,[POINT 11,MMAP(7),35] ;CORE PAGE NUMBER
	LSH 3,^D9		;CORE ADDRESS
	CALL UDSKIO		;OPERATE THE DISK
	ADDI 10,4		;INCREMENT DISK ADDRESS 4 SECTORS
LOKSM2:	CAMGE 7,SWCEND		;HIGHEST PAGE OF SWM
	AOJA 7,LOKSM1
	SKIPLE GETSMF		;GETTING FROM DISK?
	JRST LOKSM3		;YES, SKIP TENDMP CALL
	MOVSI 1,1
	SOJG 1,.		;WAIT AWHILE FOR DRUM OPS TO COMPLETE
	MOVE 1,[XWD BGTEND,LWTEND]
	BLT 1,377777		;MOVE TENDMP TO HIGH LOCATION
	PIOFF			;TO PREVENT DATA LATE
	MOVEM P,TW1
	JSR TENDMP		;CALL TO INTERPRET PRE-STORED STRING
	MOVE P,TW1
	PION

;GETSWM ...

LOKSM3:	MOVSI 6,WRITEB		;SET TO CLEAR WRITE BIT FROM MMAP
	MOVE 1,DBUGSW
	CAIN 1,2		;BUT IF DBUGSW = 2,
	SETZ 6,			;LEAVE IT WRITABLE
	MOVEI 7,SWPMP0
	MOVE 10,[DSKSMA]	;DISK ADDRESS FOR POSSIBLE WRITING
ULKSM1:	ANDCAM 6,MMAP(7)	;CLEAR ANY UNWANTED ACCESS
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	CALL MULKPG		;UNLOCK THE PAGES
	CAMGE 7,SWCEND
	AOJA 7,ULKSM1
	OKSKED
	POP P,NPMAX		;RESTORE NORMAL MAX SIZE
	SKIPN GETSMF		;IF FRESH START FROM DTA
	SKIPN DISKP		;AND DISK AVAILABLE
	RET
	PUSH P,CAPENB		;SAVE CURRENT CAPS
	MOVEI 1,WHEEL		;WE NEED WHEEL FOR THE FOLLOWING
	IORM 1,CAPENB
	CALL WRMON		;WRITE RES AND SWP MON ON DISK
	CALL WRSWM
	POP P,CAPENB
	AOS GETSMF		;FLAG MON NOW ON DISK
	RET

;SWCEND IS SET BY POSTLD TO CONTAIN THE NUMBER OF THE HIGHEST
;PAGE CONTAINING SWAPPABLE CODE

SWCEND:	0

	SWAPCD

RUNDD:	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS
	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;NO
	STAD			;YES, SET IT
	JFCL
RUNDD3:	MOVEI 1,101
	DOBE
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX RESTARTING, WAIT.../]
	TTMSG
	SKIPG DISKP
	JRST RUNDD2		;SKIP DISK STUFF IF NO DISK
	CALL CHKBT		;CHECK CONSISTENCY OF DISK BIT TABLE
	MOVE 2,DBUGSW
	CAIN 2,2		;IF REAL DEBUGGING,
	JRST RUNDD2		;SKIP DISK CHECKING
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>CHECKDSK.SAV/]
	GTJFN
	JRST RUNDD1
	HRLI 1,400000
	GET			;GET DISK BIT TABLE CHECKER FILE
	MOVEI 1,RUNDD2
	HRRM 1,MONBK		;SET ADDRESS FOR INTERRUPTS
	JRST GEX1		;START CHECKER

RUNDD1:	HRROI 1,[ASCIZ / NO CHECKDSK
/]
	PSOUT
RUNDD2:	SETZM PSIBW		;CHECKDSK RETURNS TO HERE ON HALTF
	MOVSI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR		;RE-ESTABLISH MONITOR CONTEXT
	SETO 2,
	DIC
	CALL DTIALL
	MOVEI 1,EXECI
	HRRM 1,MONBK		;RESTORE DEFAULT INTERRUPT
	MOVE 1,CAPMSK
	MOVEM 1,CAPENB		;RESTORE CAPABILITIES
	MOVEI 1,101
	DOBE			;WAIT FOR ANY CHECKDSK OUTPUT
	GTAD
	JUMPL 1,.+4		;DON'T TYPE MESSAGE IF NO DATE SET
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX IN OPERATION
/]
	TTMSG

	MOVE 1,JB0TT		;JOB 0 TTY
	JUMPG 1,RUNDD4
	MOVSI 1,(1B0+1B17)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.REPORT/]
	GTJFN
	BUG(CHK,<CAN'T GTJFN ERROR REPORT FILE>)
	MOVE 2,[44B5+1B20]
	OPENF
	BUG(CHK,<CAN'T OPENF ERROR REPORT FILE>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT 
	MOVEI 1,[SIXBIT '$RUNNING DDMP$$/']
	TMSG			;ON TTY 0
	MOVSI 1,(740B8)
	MOVEM 1,LOGBUF
	HRROI 1,LOGBUF
	EFACT			;RESTART ENTRY IN FACT FILE
	BUG(CHK,<FAILED TO MAKE RESTART ENTRY IN FACT FILE>)
	AOS SYSIFG		;MAKE SYSTEM AVAILABLE
	CALL DONSJ		;START NEXT SPECIAL JOB
	MOVEI 1,103
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	MOVEI 1,CHKRI
	HRRM 1,MONBK		;SET DISPATCH FOR INTERRUPTS
	JRST CHKR		;GO DO BACKGROUND

;MAP DDT FROM IMAGE FILE

GETDDT:	SKIPE GOTDDT		;GOT DDT NOW?
	RET			;YES
	MOVSI 1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>MDDT.SAV/]
	GTJFN
	JRST NODDT
	MOVEI 2,1B19		;READ
	OPENF
	JRST NODDT
	PUSH P,1
	MOVSI 1,0(1)
	CALL JFNOFN
	BUG(HLT,<GETDDT - JFNOFN FAILED>)
	MOVE 2,[XWD READB,PHDDT]
	MOVEI 5,LMDDT/1000
	CALL SETMPG		;MAP FILE PAGES INTO SWP MON MAP
	ADDI 1,1		;NEXT FILE PAGE
	ADDI 2,1000		;NEXT MON MAP PAGE
	SOJG 5,.-3
	POP P,1			;RECOVER JFN
	CLOSF			;CLOSE THE FILE
	JFCL
	AOS GOTDDT		;GOT DDT NOW!
	RET

NODDT:	MOVEI 1,[SIXBIT '$NO MDDT FILE$/']
	TMSG
	JRST NODD1

JB0TT:	JB0TTY!400000		;JOB 0 TTY, OR -1 FOR NONE

LS SWPSTP,1			;POINTER TO SWAPPABLE SYMTAB
LS GOTDDT,1			;REMEMBERS IF WE HAVE MAPPED DDT

;READ IN MONITOR SYMBOL TABLE FROM FILE

GETMST:	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT
	HRRI 1,SVNM		;USE CORRECT VERSION FOR THIS SYSTEM
	HRROI 2,[ASCIZ /<SYSTEM>MONSYMS.TBL/]
	GTJFN
	JRST NOSYMS		;NO FILE
	MOVE 2,[44B5+1B19]	;36 BIT READ
	OPENF
	JRST [	RLJFN
		JFCL
		JRST NOSYMS]
	BIN			;GET XWD -LENGTH,ADDRESS
	HLRE 3,2
	MOVM 3,3		;POSITIVE OF LENGTH
	CAILE 3,SSTSIZ		;TOO BIG?
	HRLI 2,-SSTSIZ		;YES, READ ONLY TO MAX
	HRRI 2,SWPST		;ADDRESS WHERE TABLE TO BE PUT
	MOVEM 2,SWPSTP
	MOVE 7,2
	BIN
	MOVEM 2,0(7)
	AOBJN 7,.-2
	CLOSF
	JFCL
NOSYMS:	RET

EWMST:	MOVEI 1,[SIXBIT 'RITE MON SYM TAB/']
	TMSG
	CALL OKGO
	SKIPE 1,@DDTSYM		;DDT HAS CURRENT POINTER?
	MOVEM 1,SWPSTP		;YES, UPDATE IT
	JSP 4,WMST		;WRITE TABLE ONTO FILE
	JRST EXCRR

;WRITE MONITOR SYMBOL TABLE ONTO FILE
;CALLED WITH JSP 4,WMST

WMST:	HRROI 1,[ASCIZ /
SYMBOL TABLE LARGER THAN SWAPPABLE STORAGE ALLOCATED FOR IT.
/]
	HLRE 2,SWPSTP
	MOVM 2,2
	CAILE 2,SSTSIZ		;TOO LARGE?
	PSOUT			;YES, PRINT MESSAGE
	HRROI 1,[ASCIZ /
SYMBOL TABLE WRITTEN ON FILE /]
	PSOUT
	MOVSI 1,(1B0+1B17)
	HRRI 1,SVNM		;VERSION NUMBER FOR THIS SYSTEM
	HRROI 2,[ASCIZ /MONSYMS.TBL/]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	JFNS			;TYPE THE FILE NAME
	MOVE 1,2
	MOVE 2,SWPSTP
	BOUT			;OUTPUT -LENGTH,,ADR
	MOVE 7,2
	MOVE 2,0(7)
	BOUT
	AOBJN 7,.-2
	CLOSF
	JFCL
	JRST 0(4)

EXEC2:	MOVEI 1,100		;ESTABLISH CORRECT TTY MODES
	MOVE 2,ETMOD
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL
	MOVE 1,[XWD 20,^D34]
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 2,JOBNO
	MOVEI 3,1		;ASSUMED NUMBER OF SYSTEM DIRECTORY
	HRRZ 1,JOBDIR(2)
	CAIN 1,0		;LOGGIN IN?
	HRRM 3,JOBDIR(2)	;NO, FUDGE LOGIN
	MOVEI 1,"."
	PBOUT
EXECT1:	PBIN			;AWAIT USER INPUT
	CAIN 1,"E"
	JRST GEX
	CAIN 1,"B"
	JRST EBLT		;BLT SWP MON TO USER SPACE
	CAIN 1,"M"
	JRST EMNT		;MOUNT DTA-
	CAIN 1,"R"
	JRST EREST		;RESET USER MAP AND FILES
	CAIN 1,"G"		;G - GET FILE
	JRST EGET
	CAIN 1,"S"		;S - START
	JRST EST
	CAIN 1,"D"		;D - DUMP ON FILE
	JRST EDMP
	CAIN 1,"I"
	JRST EINI
	CAIN 1,"H"
	JRST EHLT		;HALT T.S.
	CAIN 1,"W"
	JRST EWMST
	CAIN 1,"!"
	JRST EX2
	CAIN 1,"^"
	JRST MRETN
	CAIN 1,"/"
	JRST TODDT
	JRST EXERR		;NOTA

TODDT:	MOVEI 1,EOL
	PBOUT
	SKIPE MDDT		;DDT ALREADY LOADED?
	JRST MDDT		;YES
	CALL GETDDT		;GET PROTOTYPE DDT
	MOVE 1,[XWD PHDDT,MDDT]
	BLT 1,EMDDT-1		;MOVE DDT TO PP AREA
	SKIPN SWPSTP		;NON RES SYMTAB HERE?
	CALL GETMST		;NO, TRY TO GET IT
	SKIPN 1,SWPSTP		;USE NON-RES SYMTAB IF PRESENT
	MOVE 1,36		;MOVE MONITOR SYMBOL POINTER
	MOVEM 1,@DDTSYM
	JRST MDDT		;GO TO DDT

ETMOD:	EXP ^D66B10+^D72B17+17B23+2B25+1B29+1B31

EX2:	XCTUU [SKIPE MDDT]	;DDT ALREADY LOADED?
	JRST EX2L
	CALL GETDDT
	MOVE 1,[XWD PHDDT,MDDT]
	XCTMU [BLT 1,EMDDT]	;MOVE DDT TO USER SPACE
EX2L:	MOVEI 1,MDDT
	HRRM 1,0(P)		;RETURN ADDRESS
	JRST MRETN		;TO DDT IN USER MODE

;BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

EBLT:	MOVEI 1,[SIXBIT 'LT SWP MON/']
	TMSG
	CALL OKGO
	SKIPLE DISKP		;IF DISK,
	CALL WRSWM		;WRITE IT ON DISK
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVEI 1,SWPMP0		;FIRST PAGE
	LSH 1,^D9
	HRLI 1,0(1)
	XCTMU [BLT 1,777(2)]
	JRST EXCRR

EREST:	MOVEI 1,[SIXBIT 'ESET/']
	TMSG
	CALL OKGO
	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVSI 7,-1000
	MOVNI 1,1
	MOVSI 2,400000
	SETZ 3,
	HRRI 2,0(7)
	PMAP
	AOBJN 7,.-2
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	JRST EXCRR

OKGO:	PBIN
	CAIN 1,"."
	RET			;PERIOD MEANS GO
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

GEX:	MOVEI 1,[SIXBIT 'XEC$/']
	TMSG
STEX:	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
	GTJFN
	JRST [	HRROI 1,[ASCIZ /NO EXEC/]
		PSOUT
		JRST EXCRR]
	HRLI 1,400000
	GET
	JRST GEX1

;INIT DISK BIT TABLE, BAD SPOTS, ETC

EINI:	MOVEI 1,[SIXBIT 'NIT BIT TABLE/']
	TMSG
	CALL OKGO
	CALL DSKRBS		;READ BAD SPOTS
	JRST EXCRR

;HALT TENEX

EHLT:	MOVEI 1,[SIXBIT 'ALT TENEX/']
	TMSG
	CALL OKGO
	SETZM NXTDMP		;REQUEST DDMP ACTION
	SETZM DDTIME		;FORCE DDMP RUN
	AOS JB0FLG		;REQUEST JOB 0
	MOVEI 1,^D1000
	DISMS			;WAIT A SECOND
	SKIPN CGFLG		;SWAPPING AND
	SKIPL NXTDMP		;DDMP FINISHED?
	JRST .-4		;NO
	MOVSI 1,400000
	MOVEM 1,20		;HALT SCHED
	JRST EXCRR

;MOUNT DECTAPE

EMNT:	MOVEI 1,[SIXBIT 'OUNT DTA/']
	TMSG
	PBIN
	CAIL 1,"0"		;USER TYPES DIGIT
	CAILE 1,"7"		;FROM 0 TO 7
	JRST EXERR		;BAD CHAR
	MOVE 10,[ASCIZ /DTA0/]
	DPB 1,[POINT 7,10,27]	;CONSTRUCT STRING WITH UNIT NUMBER
	HRROI 1,10
	STDEV
	JRST EXERR		;NO SUCH DEVICE
	MOVE 1,2
	MOUNT
	JRST EXERR
	JRST EXCRR

EGET:	MOVEI 1,[SIXBIT 'ET FILE /']
	TMSG
	MOVSI 1,(1B2+1B4+1B16+1B17)	;OLD FILE,TERMINATION,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	JRST EXCRR

EST:	MOVEI 1,[SIXBIT 'TART/']
	TMSG
	CALL OKGO
	MOVEI 1,EOL
	PBOUT
GEX1:	HRRZ 1,ENTVEC
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	HRRM 1,0(P)
	JRST MRETN

EDMP:	MOVEI 1,[SIXBIT 'UMP ON FILE /']
	TMSG
	MOVSI 1,(1B0+1B3+1B4+3B17)	;NEW V,PNT O/N,TERM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD 777760,20]	;ALL EXCEPT AC'S
	SAVE
	JRST EXCRR

EXERR:	MOVEI 1,[SIXBIT '  ?/']
	TMSG
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
EXCRR:	MOVEI 1,EOL
	PBOUT
	JRST EXEC2

;PSI TRAPPED TO HERE

EXECI:	XCT MONINT		;FOR DDT BREAKPOINT
	EXCH 1,ITFPC		;SAVE 1, GET TRAP PC
	TLNN 1,UMODF		;USER?
	JRST EXECI1		;NO
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFPC		;RESTORE AC1
EXECI2:	JSYS MENTR
	SETOM PRIMRY
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	MOVEI 1,400000
	SETO 2,
	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	MOVEI 1,EM2
	TMSG
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 1,1(P)		;GET USER PC
	HRLI 1,UMODF
	MOVEM 1,FPC
	HRLZ P,ACBAS1		;RECOVER USER AC'S
	LSH P,4
	BLT P,17
	JRST EXECI2

EXECI3:	MOVEI 1,EM3
	TMSG
	MOVEI 1,101
	HRRZ 2,UPP
	HRRZ 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	JFCL
	MOVE 1,CAPMSK
	TRNE 1,WHEEL+OPER
	JRST EXCRR		;TO MINI-EXEC IF WHEEL OR OPERATOR
	JRST STEX		;START EXEC OTHERWISE

EM2:	SIXBIT '$ABORT$/'
EM3:	SIXBIT '$INTERRUPT AT /'

;JSYS TO ENTER MINI-EXEC

.EXEC:	JSYS MENTR
	MOVEI 1,WHEEL+OPER
	TDNN 1,CAPENB
	JRST ITRAP
	JRST EXEC2

EXBUGH:	MOVE P,UPP		;TRY TO RESET WORLD
	SETOM TRAPC
	SETZM NSKED
	SETZM INTDF
	SETZM SLOWF
	MOVEI 1,-1
	HRROI 2,[ASCIZ /
BUGHLT AT /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2,EOL
	BOUT
	JRST ITRAP

;EXEC UTILITY ROUTINES

;MESSAGE TYPER - ADR OF SIXBIT TEXT IN 1

TMSGQ:	HRLI 1,440600		;CONSTRUCT BYTE POINTER
	PUSH P,1
TMSG1:	ILDB 1,0(P)
	ADDI 1,40		;CONVERT TO ASCII
	CAIN 1,"/"		;SLASH IS TERMINATOR
	JRST TMSG2
	CAIN 1,"$"		;DOLLARS MEANS EOL
	MOVEI 1,EOL
	PBOUT
	JRST TMSG1

TMSG2:	POP P,1			;FLUSH TEMP
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

	INTERN CHKR

CHKR:	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADDI 1,^D120000		;NOW PLUS TWO MINUTES
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SKIPE BUGHLT		;BUGHLTS LATELY?
	CALL CHKHLT		;REPORT
	SKIPE BUGCHK		;BUGCHK?
	CALL CHKBUG		;YES
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE 1,DRMCFE		;DRUM ERROR COUNT
	CAME 1,CHKDMC		;DIFFERENT FROM LAST TIME?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT THAN LAST CHECK?
	CALL CHKDE1		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK		;PRINT INFO
IFDEF IMPCHN,<
	SKIPN IMPBGL		;IMP BUG?
	SKIPE NETTCH		;NETWORK CHANGED STATE?
	CALL CHKNET		;YES, LOG IT
>
	CALL DDMP		;DISK BACKUP
	MOVE 2,TODCLK		;SETUP DISMISS CONDITION FOR
	ANDI 2,377777		;NOW PLUS 30 SEC
	MOVSI 1,^D30000(2)
	HRRI 1,JB0TST		;OR JB0FLG
	JSYS EDISMS
	JRST CHKR

	RESCD

JB0TST:	MOVE 3,4		;SAVE RETURN
	JSP 4,BLOCKW		;TEST CLOCK
	SKIPE JB0FLG		;OR FLAG
	JRST 1(3)		;RUN
	JRST 0(3)

	SWAPCD

CHKH1:	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
CHKR1:	GTAD			;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	MOVEI 1,37
	PBOUT
	RET

CHKHLT:	HRROI 1,[ASCIZ /
*****BUGHLT AT /]
	PSOUT
	HRRZ 2,BUGHLT
	SETZM BUGHLT
	JRST CHKBG1

CHKBUG:	HRROI 1,[ASCIZ /
*****BUGCHK AT /]
	PSOUT
	HRRZ 2,BUGCHK
	SUBI 2,1		;TO POINT AT JSR
	SETZM BUGCHK
CHKBG1:	PUSH P,2		;SAVE ADDRESS
	CALL CHKH1		;PRINT IT
	SKIPE BUGTAB		;HAVE BUG TABLE NOW?
	JRST BUGLK5		;YES
	MOVE 1,[1B2+1B17+SVNM]
	HRROI 2,[ASCIZ /<SYSTEM>BUGTABLE.IMG/]
	GTJFN
	JRST BUGLK0
	MOVE 2,[44B5+1B19]
	OPENF
	JRST BUGLK0
	MOVE 7,[XWD -6000,BUGTAB]
BUGLK3:	BIN
	JUMPN 2,BUGLK2
	GTSTS
	TLNE 2,(1B8)		;EOF?
	JRST BUGLK4		;YES
	SETZ 2,
BUGLK2:	MOVEM 2,0(7)
	AOBJN 7,BUGLK3
BUGLK4:	CLOSF
	JFCL
BUGLK5:	POP P,1			;BUG ADDRESS
	MOVSI 7,-1000
BUGLK1:	SKIPN 6,BUGTAB(7)
	RET			;FAILED TO FIND ADDRESS, PRINT NOTHING
	HLRZ 2,6
	CAME 1,2
	AOBJN 7,BUGLK1		;SHOULD NEVER CONTINUE
	HRROI 1,[ASCIZ / - /]
	PSOUT
	HRROI 1,BUGTAB+1000(6)	;STRING STORAGE STARTS IN NEXT PAGE
	PSOUT
	JRST CHKR2		;PRINT EOL AND RETURN

BUGLK0:	HRROI 1,[ASCIZ @ - (FAILED TO GTJFN/OPEN BUGTABLE FILE)
@]
	PSOUT
	POP P,1
	RET

CHKDRM:	MOVEM 1,CHKDMC		;STORE NEW COUNT
	HRROI 1,[ASCIZ /
*****DRUM ERR: /]
	PSOUT
	MOVEI 6,DRMCFE
	JRST CHKDE2

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****DRUM SPACE LOW, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****SPT SPACE LOW, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1

CHKDSK:	MOVEM 1,CHKDNE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
***NON-REC DISK ERROR: /]
	MOVEI 6,DSKLER		;4 WORD BLOCK OF COMMANDS AND ERR BITS
CHKDE2:	PSOUT
	MOVEI 1,101
	HRLI 6,-4		;REPORT 4 WORDS
	MOVE 3,[1B0+^D8]	;IN MAGNITUDE OCTAL
CHKD1:	MOVE 2,0(6)
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
	AOBJN 6,CHKD1
	JRST CHKR1

CHKDE1:	MOVEM 1,CHKDRE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
*DISK ERROR: /]
	MOVEI 6,DSKRER		;4 WORD BLOCK OF COMMANDS, ETC.
	JRST CHKDE2

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****JOB 0 CRASH, CONTINUING
/]
	PSOUT
	JRST CHKR

LS CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
LS CHKDNE,1			; "" NON-REC. ""
LS CHKDMC,1

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO

	INTERN GETPAT

GETPAT:	JSYS MENTR		;GETS HERE FROM UUO HANDLER
	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCT PATUPC
	MOVE 1,40
	XCT PATU40
	JRST MRETN		;GO TO COMPATIBILITY

;INFO JSYS'S

	INTERN .GJINF,.TIME,.RUNTM,.GTRPI

.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.RUNTM:	JSYS MENTR
	JSP 3,UCLOCK		;UPDATE CLOCKS
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	JSYS MENTR
	CALL SETLFK
	MOVE 1,UTRPCT
	MOVE 2,USWPCT
	MOVE 3,PTTIM
	JRST RETA3

	INTERN .GETAB,.SYSGT

;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

.SYSGT:	JSYS MENTR
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ 1,GTTAB(4)		;ADDRESS OF FIRST WORD
	MOVE 1,0(1)
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

.GETAB:	JSYS MENTR
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR GTABX3		;NO  *** CHANGE TO GTABX3 ASAP ***
	HLRE 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR GTABX1		;NO
	HLRZ 1,GTTAB(3)		;GET SIZE OF TABLE
	JUMPL 2,RETN1		;RETURN SIZE IF INDEX <0
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR GTABX2
	ADD 2,GTTAB(3)		;COMPUTE ADDRESS OF DESIRED WORD
	MOVE 1,0(2)		;GET WORD
RET1:	UMOVEM 1,1		;RETURN IT TO USER
URSKP:	AOS 0(P)		;SKIP RETURN
	JRST MRETN

RETN1:	XCTUU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	JRST URSKP		;SKIP RETURN

;TABLE OF TABLES

	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN NSTAT,SKDTM0,TOTRC,MAXQ,QSUM

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKRCE
	XWD NDRMEW,DRMCFE
	XWD SVNE-SVN,SVN
	XWD 3,UTRPCT
	XWD NSTAT,SKDTM0
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
IFDEF IMPCHN,<
	EXTERN NHOSTS,NSKT,HOSTAB,HOSTN,LSKT,FSKT,NETAWD,NETBAL,NETSTS,NETBUF
	XWD 2,IMPRDY
	XWD IMPLBT,IMPHRT
	XWD NHOSTS,HOSTAB
	XWD NHOSTS,HOSTN
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD NSKT,NETAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
>
GTBSIZ==.-GTTAB

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB:	SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
	SIXBIT /DRMERR/
	SIXBIT /SYSVER/
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HOSTAB/
	SIXBIT /HOSTN/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
>

IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>

;SUBSYSTEM STATISTICS LOGIC

	INTERN .SETNM

.SETNM:	JSYS MENTR
	NOINT
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOS SNMPT		;UPDATE POINTER
	MOVEM 1,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	JRST MRETN

GS SNMPT,1		;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1		;LOCK FOR SNAMES TABLE

	INTERN .LITES

.LITES:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;LOGOUT

	INTERN .LGOUT,FLOGO

.LGOUT:	JSYS MENTR
	NOINT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO
LOGO:	SKIPE FORKN		;TOP FORK?
	JRST [	MOVSI 1,LOG
		TDNN 1,CAPMSK	;LOG PERMITTED?
		JRST LOGOE1	;NO, ERROR RETURN
		HLRZ 1,FORKN	;NO, GET ITS NUMBER
		HRRZ 2,SYSFK(1)
		NOSKED
		MOVSI 1,400000+PSILOB
		IORM 1,FKINT(2)	;REQUEST LOGOUT
		CALL PSIR4
		OKSKED
		RESKED
		OKINT
		JRST HALTF1]	;HALT THIS ONE
FLOGO1:				;LOGOUT PSI REQUEST ENTERS HERE
IFDEF DSPCHN,<
	SETO 1,
	RELDP
	RELDC>
	SETO 1,
	CLOSF			;CLOSE FILES
	JFCL
	MOVEI 1,-4
	KFORK			;DELETE FORKS
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	MOVE 1,JOBNO
	HLRZ 1,JOBDIR(1)	;CONNECTED DIRECTORY
	DELDF			;DELETE DELETED FILES
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	MOVE 1,JOBNO
	HRRZ 1,JOBDIR(1)
	JUMPE 1,LOG1		;IF JOB NOT LOGGED IN
	MOVE 1,LOGDES
	CALL LOGTOT		;SUMMARY TO LOG TTY
LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	MOVEI 1,400000(1)	;YES, PRINT LOGOUT MESSAGE
	CALL LOGTOT
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
	MOVE 2,CTRLTT
	CALL TTHNGU		;HANG UP LINE
LOG2:	JRST HLTJB

ELOGO:	MOVE 2,JOBNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN 2,0(1)		;SELF?
LOGOE1:	RETERR LOUTX1		;YES, CAN'T SAY IT THAT WAY
	CAIGE 1,NJOBS		;REASONABLE NUMBER?
	CAIGE 1,0
LOGOE2:	RETERR LOUTX2		;NO
	SKIPGE JOBRT(1)		;EXISTS?
	JRST LOGOE2
	HRRZ 3,JOBDIR(1)	;LOGIN DIRECTORY OF OBJECT JOB
	XOR 3,JOBDIR(2)
	TRNN 3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	MOVEI 3,WHEEL+OPER	;OTHERWISE MUST BE WHEEL
	TDNN 3,CAPENB
	JRST LOGOE1		;ILLEGAL
ELOGO1:	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	NOSKED
	MOVSI 1,400000+PSILOB
	IORM 1,FKINT(2)		;REQUEST LOGOUT
	CALL PSIR4
	OKSKED
	RESKED
	AOS 0(P)		;RETURN GOOD
	JRST MRETN

FLOGO:	SKIPGE SLOWF		;ALREADY IN JSYS?
	JSYS MENTR		;NO, DUMMY UP ENTRY
	NOINT
	MOVE P,UPP		;MAKE SURE WE HAVE EMPTY STACK
	ADD P,BHC+2
	JRST FLOGO1

;LOGGING FUNCTIONS

	INTERN LOGTOT,LOGDES,LOGONM,LOGCJM

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT:	CAIL 1,0
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /KILLED/]
	CALL LOGMES
	CALL LOGJOB		;PRINTS JOB NO, TTY NO, TIME
	HRROI 2,[ASCIZ /
  USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5		;FOR WHOLE JOB
	RUNTM
	MOVEM 1,3(7)		;RUNTIME FOR EFACT
	MOVEM 3,4(7)		;CONSOLE TIME FOR EFACT
	MOVE 2,1
	POP P,1
	PUSH P,3
	CALL LOGTIM		;PRINT CPU TIME
	HRROI 2,[ASCIZ / IN /]
	CALL LOGMES
	POP P,2
	CALL LOGTIM		;PRINT CONSOLE TIME
	CAME 1,LOGDES		;ON LOG TTY?
	JRST LOGCR		;NO
	MOVEI 2,141		;LOGOUT CODE
	DPB 2,[POINT 9,0(7),8]
	PUSH P,1
	MOVSI 1,-5		;SIZE OF LOGOUT BLOCK
LOGFCT:	HRRI 1,0(7)		;LOC OF LOGOUT BLOCK
	EXCH 1,0(P)		;OUTPUT DESIGNATOR
	CALL LOGCR
	EXCH 1,0(P)
	NOINT
	PUSH P,CAPENB
	MOVSI 2,LOG
	IORM 2,CAPENB		;BE SURE WE HAVE LOG CAPABILITY
	EFACT
	BUG(CHK,<EFACT FAILED - LOGIN, LOGOUT, ATTACH, ETC.>)
	POP P,CAPENB		;RESTORE CAPS
	OKINT
	POP P,1
	RET

;LOGON MESSAGE, CALLED FROM .LOGIN

LOGONM:	SKIPL 1,LOGDES
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /LOGIN/]
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,501		;LOGIN CODE
LOGCJ1:	DPB 1,[POINT 9,0(7),8]
	MOVE 1,4(7)		;ACCOUNT WORD
	JUMPL 1,[SUBI 1,4	;STRING ACCOUNT, ROUND CHAR COUNT
		IDIVI 1,5	;COMPUTE WORD COUNT
		MOVSI 1,-5(1)	;ADD WORD COUNTS FOR STRING AND BLOCK
		JRST .+2]
	MOVSI 1,-5		;WORD COUND INCLUDES BLOCK ONLY
	JRST LOGFCT

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM:	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /CHANGED/]
	CALL LOGMES
	CALL LOGJOB
	HRROI 2,[ASCIZ /
 USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5
	RUNTM			;RUNTIME OF JOB
	MOVEM 1,3(7)		;SAVE FOR FACT FILE
	MOVE 2,1
	POP P,1
	CALL LOGTIM		;PRINT ON LOG TTY
	PUSH P,1
	MOVEI 1,502
	JRST LOGCJ1

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

DETMSG:	HRROI 2,[ASCIZ /DETACHED/] ;WORD FOR LOG TTY
	SKIPL 1,LOGDES
	DOBE
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,143		;DETACH CODE
ATAMS2:	DPB 1,[POINT 9,0(7),8]
	MOVSI 1,-3		;SIZE OF BLOCK
	JRST LOGFCT

ATAMSG:	MOVEI 7,LOGBUF
	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /ATACHED JOB /]
	CALL LOGMES
	HLRZ 2,0(7)		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / TO TTY /]
	CALL LOGMES
	LDB 2,[POINT 12,0(7),29] ;TTY NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
	PUSH P,1
	MOVEI 1,142		;ATACH CODE
	JRST ATAMS2

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

LOGJOB:	MOVEI 7,LOGBUF		;BLOCK FOR EFACT
	HRROI 2,[ASCIZ / JOB /]
	CALL LOGMES
	MOVE 2,JOBNO
	DPB 2,[POINT 9,0(7),17]	;JOB NUMBER FOR EFACT
	CALL LOGNUM
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, USER /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRRM 2,1(7)		;DIRECT NUMBER FOR EFACT
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	JFCL
	HRROI 2,[ASCIZ /, ACCT /]
	CALL LOGMES
	MOVE 2,ACCTPT
	CALL LOGACC
LOGJ3:	MOVE 2,CTRLTT
	DPB 2,[POINT 12,0(7),29] ;TTY NUMBER FOR EFACT
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,CTRLTT
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:	HRROI 2,[ASCIZ /, AT /]
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	GTAD
	MOVEM 1,2(7)		;TOD FOR EFACT
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	MOVSI 3,045240		;MOST ABBREVIATED DATE AND TIME
	CAIL 2,0
	ODTIM
	RET

LOGJ1:	HRROI 2,[ASCIZ /, DETACHED/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	LDB 3,[POINT 3,2,2]
	CAIE 3,5		;STRING OR NUMBER?
	JRST LOGAC1		;STRING
	TLZ 2,700000
	MOVEM 2,4(7)		;ACCOUNT NUMBER FOR EFACT
	JRST LOGNUM		;PRINT NUMBER

LOGAC1:	SETZ 4,			;TO COUNT CHARS
	MOVE 3,2		;STRING PTR
LOGAC2:	ILDB 2,3		;CHAR OF ACCOUNT STRING
	JUMPE 2,LOGAC3		;NULL IS END OF STRING
	CAIL 1,0
	BOUT			;PRINT IT ON LOG TTY
	AOJA 4,LOGAC2		;COUNT IT

LOGAC3:	MOVNM 4,4(7)		;LEAVE NEG OF WORD COUNT FOR EFACT
	RET

LOGMES:	SETZ 3,
	JUMPL 1,R
	SOUT
	RET

LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	JUMPL 1,R
	NOUT
	BUG(CHK,<LGNOUT - NOUT FAILED>)
	RET

LOGCR:	MOVEI 2,EOL
	JUMPL 1,R
	BOUT
	RET

LOGDES:	LOGTTY!400000		;LOG TTY OR -1

;FORK CREATION AND CONTROL JSYS'S

.CFORK:	JSYS MENTR
	NOINT
	MOVEI 1,-1
	CALL GFKH		;GET LOCAL HANDLE
	RETERR FRKHX6		;NONE
	PUSH P,1		;SAVE IT
	NOSKED
	MOVE 2,SPTC		;CURRENT SPT COUNT
	CAML 2,SPC1		;ROOM LEFT?
	JRST CFBAD		;NO
	SKIPE FREFK		;ROOM IN SYSTEM?
	SKIPN FREJFK		;ROOM IN JOB?
	JRST CFBAD		;NO
	CALL ASSFK		;ASSIGN FORK IN SYSTEM
	MOVE 1,FORKX
	MOVE 1,FKJOB(1)		;GET JOB NO AND JSB
	MOVEM 1,FKJOB(7)	;SET FOR NEW FORK
	OKSKED
	MOVSI 1,0(7)
	CALL WAITFK		;WAIT FOR IT TO INITIALIZE
	CALL ASSJFK		;ASSIGN JOB FORK SLOT
	HRRZM 7,SYSFK(1)
	SETZM FKPTRS(1)
	HRRZ 2,FORKN		;PUT NEW FORK INTO STRUCTURE LISTS
	MOVEI 6,FKPTRS(2)
	HLL 6,INFERP
	LDB 3,6			;GET INFERIORS OF THIS FORK
	DPB 1,6			;PUT NEW FORK AT HEAD OF IT
	MOVEI 6,FKPTRS(1)
	HLL 6,SUPERP
	DPB 2,6			;THIS FORK IS SUPERIOR OF NEW FORK
	HLL 6,PARALP
	DPB 3,6			;OTHER INFERIORS ARE PARALLEL TO NEW FORK
	PUSH P,1
	CALL SETLF1		;MAP PSB OF NEW FORK
	MOVE 2,0(P)		;NEW FORK'S JOB HANDLE
	MOVEM 2,FORKN(1)
	MOVE 2,JOBNO
	MOVEM 2,JOBNO(1)
	MOVE 2,PRIMRY
	MOVEM 2,PRIMRY(1)
	MOVE 2,JOBBIT
	MOVEM 2,JOBBIT(1)	;PASS PRIORITY
	SETZM CAPMSK(1)
	SETZM CAPENB(1)
	UMOVE 2,1		;GET ARG
	TLNE 2,(1B1)		;GIVE SPEC CAP?
	CALL CFK3
	TLNE 2,(1B3)		;INIT AC'S?
	CALL CFK1		;YES
	TLNE 2,(1B4)		;START FORK
	CALL CFK2
	CALL CLRLFK		;UNMAP PSB
	POP P,1
	MOVE 2,0(P)		;LOCAL HANDLE
	ANDI 2,377777
	IDIVI 2,2
	ADD 2,FKPTAB(3)
	DPB 1,2			;PUT JOB INDEX IN LOCAL TABLE
	POP P,1			;RETURN LOCAL HANDLE
	UMOVEM 1,1
	AOS 0(P)
	JRST MRETN

CFBAD:	OKSKED
	RETERR CFRKX3		;NO ROOM

;FORK CONTROL SUBRS

CFK1:	XCTUU [HRLZ 3,2]	;GET LOC OF INITIAL AC'S
	HRRI 3,PAC(1)		;MOVE TO NEW FORK'S PSB
	XCTUM [BLT 3,PAC+17(1)]
	RET

CFK2:	MOVEI 3,0(2)		;START ADDRESS
	HRLI 3,UMODF		;IN USER MODE
	MOVEM 3,PPC(1)
	MOVEI 3,JSKP
	MOVEM 3,FKSTAT(7)	;MAKE FORK RUNNABLE
	RET

CFK3:	MOVE 3,CAPMSK		;GIVE NEW FORK SAME SPEC CAP
	MOVEM 3,CAPMSK(1)
	MOVE 3,CAPENB
	MOVEM 3,CAPENB(1)
	RET

WAITFK:	HRRI 1,WTFKT
	JSYS EDISMS
	RET

	RESCD			;SCHEDULER TEST, MUST BE RESIDENT

WTFKT:	HLRZ 2,FKPT(1)		;SCHEDULER TEST - GET STATE OF FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	JRST 1(4)		;YES

	SWAPCD

ASSJFK:	NOSKED
	MOVE 1,@FREJFK
	EXCH 1,FREJFK
	OKSKED
	SUBI 1,FKPTRS
	RET

.SEVEC:	JSYS MENTR
	CALL SETLFK
	HLRZ 3,2		;GET SIZE
	CAIN 3,<JRST>B53	;10/50 STYLE?
	JRST SEV1		;YES
	CAIL 3,1
	CAIL 3,1000
ESVX1:	ITERR SEVEX1		;NOT LEGAL
SEV1:	MOVEM 2,ENTVEC(1)
	JRST CLFRET

.GEVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,ENTVEC(1)
GCV1:	UMOVEM 2,2
	JRST CLFRET

;GET/SET COMPATIBILITY ENTRY VECTOR AND PARAMETERS

.GCVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PATADR(1)
	MOVE 3,PATUPC(1)
	HRL 3,PATU40(1)
	UMOVEM 3,3
	JRST GCV1

.SCVEC:	JSYS MENTR
	CALL SETLFK
	MOVEM 2,PATADR(1)
	HRRM 3,PATUPC(1)
	HLRM 3,PATU40(1)
	JRST MRETN

;GET TRAP WORDS FROM FORK

	INTERN .GTRPW

.GTRPW:	JSYS MENTR
	CALL SETLFK		;MAP PSB
	MOVE 2,UTRSW(1)		;TRAP STATUS WORD
	UMOVEM 2,1		;RETURNED IN 1
	MOVE 2,UTRWD(1)		;WRITE DATA
	UMOVEM 2,2		;RETURNED IN 2
	JRST CLFRET

;SET SCHEDULER PRIORITY WORD

	INTERN .SPRIW

.SPRIW:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX		;MUST BE PRIVILEGED
	CALL SETLFK
SPRI1:	UMOVE 2,2
	MOVEM 2,JOBBIT(1)
	JRST CLFRET

;SET PRIORITY WORD FOR ANOTHER JOB

.SJPRI:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX
	NOINT
	CAIL 1,0		;LEGAL JOB NUMBER?
	CAIL 1,NJOBS
	JRST MRETN		;NO
	SKIPGE JOBRT(1)		;JOB EXISTS?
	JRST MRETN		;NO
	HRRZ 1,JOBPT(1)		;TOP FORK
	HRRZ 1,FKPGS(1)		;ITS PSB
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB
	AOS 0(P)		;DO SKIP RETURN FOR OK
	JRST SPRI1

;GET AND SET PRIMARY IO JFN'S

	INTERN .GPJFN,.SPJFN

.GPJFN:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PRIMRY(1)
	UMOVEM 2,2
	JRST CLFRET

.SPJFN:	JSYS MENTR
	CALL SETLFK
	UMOVE 2,2
	MOVEM 2,PRIMRY(1)
	JRST CLFRET

;KILL FORKS

.KFORK:	JSYS MENTR
	CALL MAPFKH		;FREEZE ALL FORKS FIRST
	 CALL FFORK1		;TO BE SURE THEY ARE INTERRUPTABLE
	UMOVE 1,1
	NOINT
	MOVEI 1,0(1)
	CAIN 1,-4		;ALL INFERIORS?
	JRST KFORK2		;YES
	CALL SETJFK		;NO, ANY ONE FORK
	CALL KFORK1		;KILL IT
	JRST MRETN

KFORK2:	CALL KALLI		;KILL ALL INFERIORS
	JRST MRETN

KFORK1:	JUMPE 1,R		;DON'T KILL TOP FORK
	CALL SKIIF
	ITERR FRKHX2		;DONT KILL NON-INFERIOR FORKS
KFORK0:	CALL DASFKH		;DEASSIGN LOCAL FORK HANDLE
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS FORK?
	ITERR KFRKX2		;CAN'T KILL SELF
	MOVE 5,6		;REMOVE FORK FROM STRUCTURE
	ADD 5,SUPERP
	LDB 5,5			;GET SUPERIOR
	ADD 5,INFERP
KFK01:	LDB 4,5			;GET NEXT PARALLEL
	CAIN 4,0(6)		;DESIRED FORK?
	JRST KFK02		;YES
	MOVE 5,4
	ADD 5,PARALP
	JRST KFK01

KFK02:	ADD 4,PARALP		;FOUND FORK TO BE KILLED IN LIST
	LDB 4,4
	DPB 4,5			;PUT NEXT IN LAST, REMOVING FORK FROM LIST
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;SUSPEND FORK
	NOSKED
	MOVEI 2,KSELF
	MOVEM 2,PPC(1)		;START IT SO AS TO KILL ITSELF
	MOVEI 2,JSKP
	HRRM 2,FKSTAT(7)
	OKSKED
	RESKED
	CALL CLRLFK
	MOVSI 1,0(7)
	HRRI 1,KFK0T
	JSYS EDISMS		;WAIT TILL FORK IS KILLED
	MOVEI 1,JSKP
	HRRM 1,FKSTAT(7)	;LET IT FINISH UP
	MOVEI 1,FKPTRS(6)
	EXCH 1,FREJFK		;PUT JOB SLOT BACK ON LIST
	MOVEM 1,@FREJFK
	RET

;FORK KILL SELF

	INTERN KSELF

KSELF:	MOVE 7,FORKX
	MOVSI 1,200000
	MOVEM 1,FKINT(7)	;DISABLE ANY FURTHER INTERRUPTS
	MOVSI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR		;GET INTO REASONABLE MONITOR STATE
	SETZM PSIBW
	CALL DTIALL		;DEASSIGN TERM INTERRUPTS
	MOVE 1,[1B4+400000]	;REASSIGN STILL-MAPPED FILES
	CLZFF			;CLOSE FILES HERE AND BELOW
IFDEF IMPCHN,<
	CALL NETKFK>		;FLUSH FORK FROM NET TABLES
IFDEF DSPCHN,<
	CALL DSPKFK>		; RELEASE DISPLAY PROCESSES OF THIS FORK
	CALL KALLI
	MOVE 7,FORKX
	HLRZ 1,FKPGS(7)
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT OF UPT
	PUSH P,2		;SAVE IT FOR LATER CHECK
	SETO 1,
	MOVSI 2,400000
KSEF1:	PMAP			;CLEAR ALL PAGES FROM USER MAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF1
	HRRZ 1,FORKN
	SETOM SYSFK(1)		;INDICATE FORK NOW KILLED
	MOVEI 1,KRET
	JSYS EDISMS		;AND WAIT TILL NOTIFICATION SEEN
KSEF2:	POP P,2			;SHARE COUNT OF UPT
	CAIE 2,1		;UNSHARED?
	JRST KSEF3
	MOVE 7,FORKX
	SETZM PSB+UPTPG
	SETZM PSB+UACPG
	SETZM PSB+JSBPG		;CLEAR SPECIAL MAP WORDS
	MOVE 6,[XWD CPTPG+1-PSBPG,CPTPG+1]
	HRLZ 2,FKPGS(7)
	CALL CLRM0		;CLEAR PP AREA OF MON MAP
	CALL WTFPGS		;WAIT FOR UPT AND PSB TO BE UNMAPPED
	JRST HLTFK1		;GO DELETE UPT AND PSB

KSEF3:	MOVEI 1,^D5000
	DISMS			;WAIT FOR 5 SECS
	HLRZ 1,FKPGS(7)		;THEN CLEAR MAP AGAIN
	LDB 2,[POINT 14,SPT(1),13]
	PUSH P,2
	SETZ 1,
	HLLZ 2,FKPGS(7)
KSEF4:	CALL SETPT		;BUT NOT USING PMAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF4
	JRST KSEF2

	RESCD

KFK0T:	HRRZ 2,FKSTAT(1)
	CAIE 2,KRET		;WAIT TILL FORK ALMOST KILLED STATE
KRET:	JRST 0(4)
	JRST 1(4)

FRZWT:	JRST 0(4)

	SWAPCD

KALLI:	HRRZ 1,FORKN
	ADD 1,INFERP
	LDB 1,1			;GET NEXT INFERIOR
	JUMPE 1,R		;NO MORE
	CALL KFORK0		;KILL ALL INFERIORS TOO
	JRST KALLI

;FREEZE FORK

.FFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL FFORK1
	JRST MRETN

FFORK1:	JUMPE 1,R		;NOT TOP FORK
	CALL STPFK		;STOP FORK
	HRRZ 2,FKSTAT(7)
	CAIN 2,FRZWT		;ALREADY FROZEN?
	JRST FFORK2		;YES
	MOVEI 2,FRZWT
	HRRM 2,FKSTAT(7)
FFORK2:	OKSKED
	JRST CLRLFK

;RESUME FORK

.RFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL RFORK1
	JRST MRETN

RFORK1:	JUMPE 1,R
	CALL STPFK		;NOP IF ALREADY FROZEN
	SKIPN 2,PIOLDS(1)	;WAS RUNNING BEFORE FREEZE?
	MOVEI 2,JSKP		;YES
	JRST RFORK2		;GO SET NEW STATUS

;READ FORK STATUS

.RFSTS:	JSYS MENTR
	TRNE 1,200000		;LOCAL DESIGNATOR?
	JRST RFST9		;NO
	ANDI 1,377777
	JUMPE 1,RFST9		;THIS FORK
	CAIL 1,NLFKS		;LEGAL?
	ITERR FRKHX1		;NO
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	CAIA
	JRST RFST8		;YES
	SETO 1,			;NOT ASSIGNED, RETURN -1
	JRST RFSTSR

RFST9:	CALL SETJFK		;NOT MULTIPLE FORKS
RFST8:	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	MOVE 2,PPC(1)		;GET PC
	TLNN 2,UMODF		;USER MODE?
	MOVE 2,UPDL(1)		;NO, USER PC IS FIRST ON STACK
	UMOVEM 2,2
	CALL CLRLFK
	HLRZ 1,FKPT(7)
	CAIN 1,WTLST		;WAITING?
	JRST RFST1		;YES
	SETZ 1,			;RUNNING, RETURN 0
RFSTSR:	UMOVEM 1,1
	JRST MRETN

RFST1:	HRRZ 2,FKSTAT(7)	;IS WAITING, GET STATE
	SETZ 1,
	CAIN 2,FRZWT		;FROZEN?
	JRST RFST4		;YES
RFST5:	CAIN 2,FORCTM		;FORCED TERMINATION?
	JRST RFST3		;YES
	CAIN 2,JRET		;REGULAR TERMINATION?
	JRST RFST2		;YES
	CAIE 2,TRMTST		;WAITING FOR FORK TERMINATION
	CAIN 2,TRMTS1		;EITHER FLAVOR?
	JRST RFST6		;YES
	TLO 1,1			;N.O.T.A., MUST BE I/O
	JRST RFSTSR

RFST2:	TLO 1,2			;REGULAR TERMINATION GIVES 2
	JRST RFSTSR

RFST6:	TLO 1,4
	JRST RFSTSR

RFST3:	PUSH P,1
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	MOVE 2,FORCTC(1)	;GET CHANNEL CAUSING FORCED TERM
	HRRM 2,0(P)		;PUT IN RH OF STATUS WORD
	CALL CLRLFK
	POP P,1
	TLO 1,3			;WITH 3 INDICATING FORCED TERM
	JRST RFSTSR

RFST4:	TLO 1,400000		;FROZEN, INDICATE IN BIT 0
	HLRZ 2,FKSTAT(7)	;AND GET OLD STATUS
	JUMPE 2,RFSTSR
	JRST RFST5

;START FORK VIA ENTRY VECTOR

.SFRKV:	JSYS MENTR
	CALL SETJFK
	PUSH P,1
	CALL SETLF1
	UMOVE 2,2		;GET RELATIVE POSITION
	HLRZ 3,ENTVEC(1)	;SIZE OF VEC IN DEST FORK
	CAIN 3,<JRST>B53	;OLD TYPE?
	MOVEI 3,2		;YES, IMPLIES 2
	CAIL 3,1		;REASONABLE VECTOR LENGTH?
	CAIL 3,1000
	JRST SFRKV2		;NO
	CAIL 2,0(3)		;LEGAL ARG?
	JRST SFRKV2		;NO
	MOVEM 2,FORCTC(1)	;LEAVE FOR FOR TO START SELF
	CALL CLRLFK
	POP P,1			;RECOVER JOB HANDLE
	CALL STPFK
	SETOM SLOWF(1)
	MOVEI 2,SFRKV1		;START FORK IN MONITOR
	JRST SFORK1

SFRKV2:	CALL CLRLFK
	ITERR SFRVX1		;ILLEGAL RELATIVE NUMBER

SFRKV1:	MOVEM 1,FPC		;ENTER HERE FORK STARTS SELF
	MOVSI 1,UMODF		;AT ENTVEC + C(FORTCT)
	EXCH 1,FPC
	JSYS MENTR
	HRRZ 1,ENTVEC
	MOVE 2,FORCTC		;RELATIVE ADDRESS
	HLRZ 3,ENTVEC		;SIZE OR JRST
	CAIN 3,<JRST>B53	;OLD STYLE?
	JRST SFRKV3		;YES
	ADDI 1,0(2)
SFRKV4:	HRRM 1,0(P)
	JRST MRETN		;START IN USER MODE

SFRKV3:	CAIN 2,0		;0 MEANS JOBSA
	UMOVE 1,120
	CAIN 2,1		;1 MEANS JOBREN
	UMOVE 1,124
	JRST SFRKV4

;START FORK

.SFORK:	JSYS MENTR
	CALL SETJFK
	CALL STPFK		;STOP FORK
	UMOVE 2,2
	TLZ 2,UIOF+2037		;USER I/O, CALFRMMON, IDX AND IND OFF
	TLO 2,UMODF		;AND USER ON
SFORK1:	SETOM SLOWF(1)		;NORMALIZE FLAG
	EXCH 2,PPC(1)		;SET PC
	TLNE 2,UMODF		;WAS IN USER MODE?
	JRST SFORK2		;YES
	MOVSI 2,UACB(1)		;NO, MOVE AC'S
	HRRI 2,PAC(1)
	BLT 2,PAC+17(1)
SFORK2:	MOVEI 2,JSKP
	MOVEM 2,FKSTAT(7)	;MAKE FORK RUNNABLE
	CALL CLRSFK		;AND CLEAR SUSPENSION
	OKSKED
	RESKED
	JRST CLFRET

;STOP FORK, USED BY SEVERAL FORK JSYS'S

STPFK:	CALL SKIIF		;JOB FORK NUMBER IN 1, IS INFERIOR?
	JRST FRKE2		;NO
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS SAME FORK?
	ITERR			;YES
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;NO, SUSPEND FORK
	NOSKED
	RET

;READ/SET FORK AC'S

.RFACS:	JSYS MENTR
	CALL FACS
	MOVS 3,3
	MOVEI 2,17(3)
	XCTMU [BLT 3,0(2)]	;FROM FORK'S PSB TO USER
	OKSKED
	JRST MRETN

.SFACS:	JSYS MENTR
	CALL FACS
	MOVEI 2,17(3)
	XCTUM [BLT 3,0(2)]	;FROM USER TO FORK'S PSB
	OKSKED
	JRST MRETN

;COMMON AC ROUTINE

FACS:	CALL SETJFK		;ONE FORK ONLY
	CALL SKIIF		;AND IT MUST BE INFERIOR
FRKE2:	ITERR FRKHX2
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING?
	ITERR FRKHX4		;YES
	MOVE 2,PPC(1)		;GET PC
	MOVEI 3,PAC(1)		;LOC OF AC'S
	TLNN 2,UMODF		;IF IN USER MODE, OTHERWISE
	MOVEI 3,UACB(1)		;AC'S ARE IN FIRST AC BLOCK
	XCTUU [HRL 3,2]		;GET ADDRESS OF USER'S BLOCK
	RET

;HALT FORK

.HFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL HFORK1
	JRST MRETN

HFORK1:	JUMPE 1,R		;NOT TOP SORK
	CAMN 1,FORKN		;THIS FORK?
	JRST HALTF1		;YES, MAKE LIKE HALTF
	CALL STPFK		;STOP THE FORK
	MOVEI 2,JRET
RFORK2:	MOVEM 2,FKSTAT(7)	;TERMINATED STATE
	CALL CLRSFK		;BUT INTERRUPTABLE
	JRST FFORK2

;CALL FROM TTY SERVICE TO RESOLVE FORK CONFLICT

TTFRKT:	SKIPGE 2,SYSFK(1)	;DOES OTHER FORK REALLY EXIST?
	RET			;NO
	HRRZ 2,FKSTAT(2)	;GET ITS STATUS
	CAIE 2,TCITST		;STILL WAITING FOR TTY?
	RET			;NO
	CALL SKIIF		;IS IT INFERIOR
	JRST HALTF1		;NO, HALT OURSELF
	JRST HFORK1		;HALT THE OTHER GUY

;WAIT FOR FORK TO TERMINATE

.WFORK:	JSYS MENTR
	CAIN 1,-4		;ALL INFERIORS?
	JRST WFORK2		;YES
	CALL SETJFK		;ONE FORK, GET ITS JOB HANDLE
	HRLZ 1,SYSFK(1)		;SETUP TEST ON FORK INDEX
	HRRI 1,TRMTST
	JSYS EDISMS		;AND DISMISS
	JRST MRETN

WFORK2:	MOVEI 1,TRMTS1		;SETUP TEST TO WAIT UNTIL CHANGED
	JSYS EDISMS
	JRST MRETN

	RESCD

TRMTST:	HLRZ 2,FKPT(1)		;SCHEDULER TEST, GET LOC OF FORK  NOW
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	HRRZ 2,FKSTAT(1)
	CAIE 2,JRET		;WAITING BECAUSE TERMINATION?
	CAIN 2,FORCTM		;OR FORCED TERM?
	JRST 1(4)		;YES
	JRST 0(4)		;NO, KEEP WAITING

TRMTS1:	JRST 0(4)

	SWAPCD

;SUSPEND FORK SO IT CAN BE DIDDLED

SUSFK:	PUSH P,1
	PUSH P,2
	CAMN 7,FORKX
	BUG(HLT,<SUSFK - GIVEN SELF AS ARG>)
SUSF6:	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING NOW?
	JRST SUSF4		;NO
	HRRZ 2,FKSTAT(7)	;GET WAITING STATUS
	CAIE 2,SUSWT		;ALREADY SUSPENDED OR FROZEN?
	CAIN 2,FRZWT
	JRST SUSF2		;YES
	CAIE 2,TCITST		;CAME FROM TTY WAIT?
	JRST SUSF5		;NO
	HLRZ 1,FKSTAT(7)	;YES, GET LINE
	HLLOS TTFORK(1)		;CLEAR WAITING STATE FROM LINE
SUSF5:	MOVSI 1,400000+SUSFKR	;SUSPEND FORK REQUEST BIT FOR PSI
	IORM 1,FKINT(7)		;LEAVE IT FOR SPECIFIED FORK
	MOVEI 2,0(7)
	CALL PSIR4		;INTERRUPT THE FORK
	OKSKED
	MOVSI 1,0(7)		;SETUP SCHEDULER TEST TO WAIT
	HRRI 1,SUSFKT		;UNTIL FORK HAS SUSPENDED ITSELF
	JSYS EDISMS
SUSF3:	POP P,2
	POP P,1
	RET

SUSF2:	OKSKED
	JRST SUSF3

SUSF4:	SKIPN FKINT(7)		;TRANSITIONAL STATE?
	JRST SUSF5		;NO
	OKSKED			;YES, WAIT AWHILE
	MOVEI 1,^D500
	DISMS
	JRST SUSF6		;AND CHECK AGAIN

;SCHEDULER TEST FOR SUSPENSION

	RESCD

SUSFKT:	HLRZ 2,FKPT(1)		;GET LOC OF SPECIFIED FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)
	HRRZ 2,FKSTAT(1)
	CAIE 2,SUSWT		;SUSPENSION?
	CAIN 2,FRZWT
	JRST 1(4)
	JRST 0(4)

	SWAPCD

;CLEAR FORK WHICH HAD BEEN SUSPENDED

CLRSFK:	MOVSI 2,200000
	ANDCAM 2,FKINT(7)	;CLEAR PSI STARTING STATE
	RET

;PERFORM MAPPING FOR FORK CONTROL FUNCTION WHICH OPERATE ON SEVERAL
;FORKS

	INTERN MAPFKH

MAPFKH:	HRROI 1,0(1)		;GET FORK HANDLE
	TRNN 1,200000		;SPECIAL?
	ANDI 1,377777		;NO
	JUMPLE 1,MAPFK1
	CAIL 1,NLFKS
	ITERR FRKHX1
	IDIVI 1,2		;REGULAR HANDLE, GET JOB HANDLE
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	ITERR FRKHX1		;NO
	RET			;RETURN AND DO FUNCTION ONCE

MAPFK1:	ADDI 1,2
	JUMPL 1,MAPFK2		;MULTIPLE INDICATION
	XCT SETJFT(1)		;SINGLE, GET JOB HANDLE
	RET

MAPFK2:	ADDI 1,3
	JUMPGE 1,MAPFT(1)	;GO TO ROUTINE
	ITERR FRKHX1		;HANDLE ILLEGAL

MAPFT:	JRST MAPF5		;-5, ALL FORKS IN JOB
	JRST MAPF4		;-4, ALL INFERIORS
	JRST MAPF3		;-3, SELF AND ALL INFERIORS

MAPF3:	HRRZ 1,FORKN		;SELF
MAPF51:	PUSH P,1
	XCT @-1(P)		;DO THIS FORK
	POP P,1
MAPFI:	MOVE 16,@0(P)		;GET INSTRUCTION, WILL STAY IN 16
MAPF41:	ADD 1,INFERP		;DO INFERIORS
MAPF42:	LDB 1,1			;GET NEXT IN LIST
	JUMPE 1,RSKP		;END OF LIST, RETURN AND SKIP INSTR
	HRLM 1,0(P)		;SAVE THIS FORK NUMBER
	CALL MAPF41		;DO INFERIORS OF IT
	BUG(HLT,<MAPF41 FAILED TO SKIP>)
	HLRZ 1,0(P)		;GET FORK NUMBER BACK
	XCT 16			;DO THIS FORK
	HLRZ 1,0(P)
	ADD 1,PARALP		;POINT TO NEXT IN LIST
	JRST MAPF42

MAPF4:	HRRZ 1,FORKN		;GET SELF
	JRST MAPFI		;DO INFERIORS

MAPF5:	HLRZ 1,FORKN		;GET TOP
	JRST MAPF51		;DO THAT AND INFERIORS

;FORK RELATIVITY TESTS

	INTERN SKIIF,SKISF,SKIIFA

;SKIP IF FORK IN 1 IS INFERIOR TO SELF

SKIIF:	PUSH P,2
	HRRZ 2,FORKN		;GET SELF
	CALL SKIIFA		;DO TEST
	JRST POP2		;RETURN NO SKIP
SKISF2:	POP P,2
	JRST RSKP

;SKIP IF FORK IN 1 IS INFERIOR TO FORK IN 2

SKIIFA:	HRLM 2,0(P)		;SAVE FORK NUMBER
SKIIF4:	CAIN 1,0(2)		;SAME?
	JRST SKIIF1		;YES
	ADD 2,INFERP		;NO, GET POINTER TO INFERIOR LIST
SKIIF2:	LDB 2,2			;NEXT INFERIOR
	JUMPE 2,SKIIF6		;END OF LIST
	CALL SKIIFA		;IS THIS FORK OR INFERIOR?
	JRST SKIIF5		;NO
SKIIF1:	HLRZ 2,0(P)		;SUCCEEDS, RETURN +2
	JRST RSKP

SKIIF6:	HLRZ 2,0(P)
	RET			;FAILS RETURN +1

SKIIF5:	ADD 2,PARALP		;LOOK PARALLEL
	JRST SKIIF2

;SKIP IF FORK IN 1 IS SUPERIOR OF THIS FORK

SKISF:	PUSH P,2
	HRRZ 2,FORKN
SKISF1:	CAIN 1,0(2)
	JRST SKISF2		;SAME, RETURN GOOD
	JUMPE 2,POP2		;END OF LIST, RETURN BAD
	ADD 2,SUPERP		;GET SUPERIOR POINTER
	LDB 2,2
	JRST SKISF1

;JSYS'S FOR CONTROLLING PSI SYSTEM

	INTERN .SIR,.EIR,.SKPIR,.DIR,.AIC,.IIC,.DIC
	INTERN .RCM,.RWM,.ATI,.DTI,.CIS

;MAP PSB OF FORK, GIVEN USER HANDLE IN 1
;RETURN WITH OFFSET TO MAPPED PSB IN 1

SETLFK:	TRNE 1,200000		;SPECIAL DESIGNATOR?
	JRST FRKE1		;NOT ALLOWED
	CALL SETJFK		;GET JOB FORK INDEX
SETLF1:	NOINT
	HRRZ 1,SYSFK(1)		;GET SYSTEM FORK INDEX
	CAMN 1,FORKX		;CURRENT FORK?
	JRST SETLF2		;YES
	HRRZ 1,FKPGS(1)		;GET PSB OF DESIGNATED FORK
	PUSH P,2
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB	;RETURN OFFSET USUAL PSB TO MAP PSB
	JRST POP2

SETLF2:	SETZ 1,			;USE CURRENT PSB, NO OFFSET
	RET

CLRLFK:	SKIPN PSB+FPBPG		;NOW MAPPED?
	JRST CLRLFX		;NO
	SETZ 1,
	MOVEI 2,FPBPGA
	CALL SETMPG
CLRLFX:	OKINT
	RET

;GET JOB FORK HANDLE GIVEN USER HANDLE IN 1
;FOR SINGLE (NOT MULTIPLE) FORK HANDLES ONLY

SETJFK:	HRROI 1,0(1)
	TRNN 1,200000
	ANDI 1,377777
	JUMPLE 1,SETJF1
	CAIL 1,NLFKS
FRKE1:	ITERR FRKHX1
	PUSH P,2
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1			;GET JOB FORK INDEX (HALF WORD)
	CAIGE 1,NUFKS		;FORK HANDLE ASSIGNED?
	SKIPG SYSFK(1)
	JRST FRKE1		;NO
	JRST POP2

SETJF1:	ADDI 1,2
	JUMPL 1,ITRAP
	XCT SETJFT(1)
	RET

SETJFT:	HLRZ 1,FORKN		;-2, TOP FORK
	CALL GETSPF		;-1, SUPERIOR
	HRRZ 1,FORKN		;0, CURRENT

GETSPF:	HRRZ 1,FORKN		;GET SUPERIOR FORK
	MOVE 1,FKPTRS(1)
	LSH 1,-^D24
	RET

.SIR:	JSYS MENTR
	CALL SETLFK
	JUMPE 2,SIR1		;ALL 0 IS LEGAL
	HLRZ 3,2		;GET ADDRESSES GIVEN
	MOVEI 4,0(2)
	CAIL 3,20		;BOTH .GE. 20?
	CAIGE 4,20
	ITERR SIRX1		;NO
SIR1:	MOVEM 2,LEVCHN(1)
CLFRET:	CALL CLRLFK
	JRST MRETN

.EIR:	JSYS MENTR
	TRNE 1,200000		;SPECIAL?
	ITERR FRKHX1		;ILLEGAL
	CALL SETJFK
	PUSH P,SYSFK(1)		;REMEMBER FORK INDEX
	CALL SETLF1		;MAP PSB
	SETZM PSISYS(1)		;0 IS ON
	POP P,2
	SKIPN PSIBW(1)		;ANY BREAKS WAITING?
	JRST CLFRET		;NO
	SETZ 1,			;YES, INITIATE SERVICE
	NOSKED
	CALL PSIRQB
	OKSKED
	JRST CLFRET

.SKPIR:	JSYS MENTR
	CALL SETLFK
	SKIPN PSISYS(1)
	AOS 0(P)
	JRST CLFRET

.DIR:	JSYS MENTR
	CALL SETLFK
	SETOM PSISYS(1)
	JRST CLFRET

.AIC:	JSYS MENTR
	CALL SETLFK
	IORM 2,PSICHM(1)
ICR:	CAIN 1,0		;SELF?
	CALL SETOVF		;YES, POSSIBLE CHANGE TO APR FLAGS
	JRST CLFRET

.DIC:	JSYS MENTR
	CALL SETLFK
	ANDCM 2,MONCHN(1)		;NOR MONITOR RESERVED CHANNELS
	ANDCAM 2,PSICHM(1)
	JRST ICR

.IIC:	JSYS MENTR
	CALL SETJFK
	PUSH P,1
	CALL SETLF1		;MAP DEST PSB
	UMOVE 2,2
	ANDCM 2,MONCHN(1)	;DISALLOW MON RESERVED CHANS
	PUSH P,2
	CALL CLRLFK
	POP P,2
	POP P,1
	MOVE 1,SYSFK(1)
	EXCH 1,2
	NOSKED
	CALL PSIRQB
	OKSKED
	RESKED			;INITIATE RESCHEDULE TO GET INTERRUPT
	JRST MRETN

.RCM:	JSYS MENTR
	CALL SETLFK
	MOVE 1,PSICHM(1)
	JRST RETA1

.RWM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PSIBIP(1)
	UMOVEM 2,2		;REPORT BREAKS IN PROGRESS IN 2
	MOVE 1,PSIBW(1)
RETA1:	UMOVEM 1,1		;RETURN VALUE IN 1
	JRST CLFRET

.SIRCM:	JSYS MENTR
	CALL SETLFK
	CAIN 1,0		;SELF?
	JRST FRKE1		;ILLEGAL
	MOVEM 2,SUPCHN(1)
	JRST CLFRET

.RIRCM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,SUPCHN(1)
RETA2:	UMOVEM 2,2
	JRST CLFRET

.RIR:	JSYS MENTR
	CALL SETLFK
	MOVE 2,LEVCHN(1)	;RETURN LEVEL AND CHANNEL DISPATCHES
	JRST RETA2

.ATI:	JSYS MENTR
	NOINT
	PUSH P,1
	HLRZ 1,1
	CAIL 1,^D36		;REASONABLE TERM CODE?
	JRST ATIE1		;NO
	CAIE 1,3		;CONTROL-C?
	JRST .+4		;NO
	MOVE 3,CAPENB		;YES, SEE IF LEGAL
	TLNN 3,(1B0)
ATX2E:	ITERR ATIX2		;ISN'T
	HRRZ 4,FORKN
	MOVE 3,BITS(1)
	SKIPL 2,CTRLTT
	IORM 3,TTPSI(2)		;IF THERE IS A CONTROLLING TTY
	IORM 3,TTSPSI
	IORM 3,FKPSIE(4)
	CALL GETCHA
	HRRZ 3,0(P)		;GET REQUESTED CHANNEL NUMBER
	DPB 3,2			;ASSIGN IT TO THIS CODE
ATI2:	OKINT
	POP P,1
	JRST MRETN

GETTCD:	CAIGE 1,PSICHL		;IN LOW GROUP?
	JRST GTCD1		;YES
	CAIGE 1,PSICHU		;IN HIGH GROUP?
ATIE1:	ITERR TERMX1		;NO, ERROR
	SUBI 1,PSICHO		;OFFSET HIGH GROUP
GTCD1:	MOVE 1,PSICH(1)
	RET

.DTI:	JSYS MENTR
	NOINT
	CAIL 1,^D36		;REASONABLE CODE?
	JRST ATIE1		;NO
	HRRZ 2,FORKN
	MOVE 6,BITS(1)
	ANDCAM 6,FKPSIE(2)	;CLEAR FROM THIS FORK
	CALL UPDTI		;UPDATE JOB WORDS
	OKINT
	JRST MRETN

;UPDATE JOB TPSI WORDS BY SCANNING FORK WORDS

UPDTI:	HLRZ 1,FORKN		;START WITH TOP FORK
	SETO 5,
	TDNE 6,FKPSIE(1)	;HERE?
	MOVEI 5,0(1)		;YES
	CALL PSIT1A		;SCAN INFERIORS
	JUMPGE 5,[IORM 6,TTSPSI	;IS ON IN ONE OR MORE FORKS
		SKIPL 2,CTRLTT
		IORM 6,TTPSI(2)
		RET]
	ANDCAM 6,TTSPSI		;IS NOT ON ANYWHERE
	SKIPL 2,CTRLTT
	ANDCAM 6,TTPSI(2)
	RET

;DEASSIGN ALL TERMINAL INTERRUPTS FOR THIS FORK

DTIALL:	HRRZ 1,FORKN
	MOVE 1,FKPSIE(1)	;GET BITS OF ACTIVATED CODES
	JFFO 1,.+2		;ANY ON?
	RET			;NO
	MOVE 1,2		;YES, PUT CODE IN 1
	DTI			;DEASSIGN THIS ONE
	JRST DTIALL		;SEE IF ANY MORE

.CIS:	SETZM PSIBIP
	SETZM PSIBW
	MOVEM 1,PSIPT
	MOVE 1,[IOWD 1000,PSIPGA]
	EXCH 1,PSIPT		;RESET PSI STORAGE
	XCT MJRSTF

;READ/SET TERMINAL INTERRUPT WORD

.RTIW:	JSYS MENTR
	MOVEI 1,0(1)
	CAIN 1,-5		;WHOLE JOB?
	JRST [	MOVE 2,TTSPSI	;YES
		JRST RTIW1]
	CALL SETJFK		;GET JOB INDEX
	MOVE 2,FKPSIE(1)
RTIW1:	UMOVEM 2,2
	JRST MRETN

.STIW:	JSYS MENTR
	MOVEI 1,0(1)
	CAIN 1,-5
	JRST [	MOVE 3,CAPENB
		TLNN 3,(1B0)	;^C CAPABILITY?
		JRST ATX2E	;NO, DON'T PERMIT CHANGE TO JOB TI
		MOVEM 2,TTSPSI	;SET WHOLE JOB WORD
		SKIPL 3,CTRLTT
		MOVEM 2,TTPSI(3) ;AND TERMINAL IF ATTACHED
		JRST MRETN]
	CALL SETJFK
	EXCH 2,FKPSIE(1)	;SET NEW, REMEMBER OLD
	XOR 2,FKPSIE(1)		;DIFFERENCES
STIW1:	JFFO 2,.+2		;ANOTHER BIT DIFFERENT?
	JRST MRETN		;NO
	MOVE 6,BITS(3)		;YES, GET IT
	TDZ 2,6
	PUSH P,2
	CALL UPDTI		;UPDATE JOB WORDS FOR CHANGE
	POP P,2
	JRST STIW1

;FORK HANDLE - PTN CONVERSION ROUTINES

	INTERN FKHPTN,PTNFKH

;TRANSLATE FKH.PN TO PTN.PN

FKHPTN:	PUSH P,2
	PUSH P,1
	TRNE 1,777000		;LEGAL PAGE NUMBER?
	JRST FRKE1		;NO
	HLRZ 1,1
	CALL SETJFK		;GET JOB FORK INDEX
	CALL SKIIF
	JRST [	MOVSI 2,(1B9)	;NOT INFERIOR
		TDNN 2,CAPENB	;ALLOWED TO MAP SUPERIOR?
		JRST FRKE2	;NO
		MOVE 2,1	;YES, SAVE OBJECT FORK
		CALL GETSPF	;GET HANDLE OF SUPERIOR
		EXCH 1,2
		CAME 1,2	;IS OBJECT FORK IMMED SUPERIOR?
		JRST FRKE2	;NO
		JRST .+1]
	HRRZ 2,SYSFK(1)		;GET SYSTEM FORK INDEX
	POP P,1
FKHP2:	HLL 1,FKPGS(2)		;GET PAGE TABLE PTN
	TLNE 1,-1		;IS ONE?
	JRST FKHP3		;YES
	BUG(HLT,<FKHPTN - FORK HAS NO PAGE TABLE>)

FKHP3:	POP P,2
	JRST RSKP

;TRANSLATE PTN TO FKH

PTNFKH:	PUSH P,2
	PUSH P,3
	PUSH P,1
	HLRZ 2,1		;GIVEN PTN
	MOVSI 3,-NUFKS		;SETUP FOR SCAN OF JOB FORK TABLE
PTNF3:	HRRE 1,SYSFK(3)
	JUMPL 1,PTNF2		;UNUSED
	HLRZ 1,FKPGS(1)
	CAIN 2,0(1)		;IS PT?
	JRST PTNF1		;YES
PTNF2:	AOBJN 3,PTNF3
	SETOM 0(P)		;NOT FOUND, RETURN -1
	JRST PTNF4

PTNF1:	MOVEI 1,0(3)		;JOB INDEX
	CALL GFKH		;CONVERT TO LOCAL HANDLE
	ITERR FRKHX6
	HRLM 1,0(P)		;CONSTRUCT FHK,,PN
PTNF4:	POP P,1
POP32:	POP P,3
POP2:	POP P,2
	RET

;FIND OR INSERT LOCAL FORK HANDLE
;GIVEN JOB FORK INDEX

GFKH:	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
	HRRZ 2,FORKN
	CAIN 2,0(1)		;IS IT SELF?
	SOJA 4,GFKH4		;YES, 0
	HRLI 1,400000		;USE LH TO REMEMBER ANY EMPTY ENTRIES
GFKH1:	ILDB 2,3		;LOOK AT NEXT HALF-WORD
	CAIN 2,-1		;ASSIGNED?
	JRST GFKH2		;NO
	CAIN 2,0(1)		;IS GIVEN?
	JRST GFKH4		;YES
GFKH3:	AOBJN 4,GFKH1
	TLNE 1,400000		;NOT FOUND, ROOM TO ADD ENTRY?
	RET			;NO
	HLRZ 3,1		;GET INDEX OF FIRST FREE ENTRY
	IDIVI 3,2		;CONSTRUCT POINTER TO IT
	ADD 3,FKPTAB(4)
	DPB 1,3			;STORE JOB INDEX IN ENTRY
	HLRZ 4,1
GFKH4:	MOVEI 1,400000(4)	;RETURN LOCAL HANDLE WITH BIT
	AOS -3(P)
POP4:	POP P,4
	JRST POP32

GFKH2:	TLNE 1,400000		;FIRST EMPTY SLOT?
	HRLI 1,0(4)		;YES, SAVE INDEX
	JRST GFKH3

;DEASSIGN LOCAL FORK HANDLE GIVEN JOB HANDLE IN 1

DASFKH:	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
DASFK1:	ILDB 2,3		;GET THIS ENTRY
	CAIN 2,0(1)		;THE ONE WE WANT?
	JRST DASFK2		;YES
	AOBJN 4,DASFK1		;NO, KEEP LOOKING
	JRST POP4		;NOT FOUND, SO IGNORE IT

DASFK2:	MOVEI 2,-1		;PUT A -1 WHERE ENTRY WAS
	DPB 2,3
	JRST POP4

;TABLE OF BYTE POINTERS, HALF WORD

	POINT 18,FKTAB,-1
FKPTAB:	POINT 18,FKTAB,17
	POINT 18,FKTAB,35

;SPECIAL CAPABILITIES CONTROL

.RPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SETLF1
	MOVE 2,CAPMSK(1)
	UMOVEM 2,2		;RETURN POSSIBLE IN 2
	MOVE 3,CAPENB(1)
	UMOVEM 3,3		;ENABLED IN 3
	JRST CLFRET

.EPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SKIIF
	ITERR FRKHX2		;INFERIORS ONLY
	CALL SETLF1
	JUMPE 1,[XOR 3,CAPMSK(1) ;IF SELF, DON'T MODIFY 14-17
		TLZ 3,(17B17)
		XOR 3,CAPMSK(1)
		JRST EPC1]
	MOVE 4,CAPMSK
	TLO 4,(777B17)		;9-17 DETERMINED BY SUPERIOR
	AND 2,4
	MOVEM 2,CAPMSK(1)
EPC1:	AND 3,CAPMSK(1)
	MOVEM 3,CAPENB(1)
	JRST CLFRET

;DETACH FROM CONTROLLING TTY

.DTACH:	JSYS MENTR
	NOINT
	SKIPG CTRLTT		;IS ONE?
	JRST MRETN		;NO, DO NOTHING
	MOVE 1,JOBNO
	HRRE 2,JOBDIR(1)
	CAIE 2,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	MOVE 2,CTRLTT
	SETOM CTRLTT
	SETOM TTFORK(2)
	SETZM TTPSI(2)
	MOVE 1,JOBNO
	HRROS JOBPT(1)
	JRST MRETN

;ATTACH JOB TO TTY

	EXTERN ATACX4

.ATACH:	JSYS MENTR
	NOINT
	PUSH P,1		;SAVE JOB NO
	MOVEI 1,WHEEL+OPER
	TDNE 1,CAPENB		;PRIVILEGED?
	JRST ATACH3		;YES, NO PASSWORD CHECK
	PUSH P,2
	MOVEI 1,0(2)
	MOVE 2,3
	CALL PASSWC		;CHECK PASSWORD
	JRST [	MOVEI 1,^D3000
		DISMS		;WRONG PASSWORD, DELAY TO FOIL THIEVES
		MOVEI 1,ATACX4
		JRST MRETNE]
	POP P,2
ATACH3:	HRRZ 1,0(P)
	CAIL 1,0
	CAIL 1,NJOBS		;LEGAL JOB NO?
	RETERR ATACX1		;NO
	HRRZ 3,JOBDIR(1)	;DIRECTORY OF  OTHER JOB
	PUSH P,3		;SAVE FOR FACT FILE
	CAIE 3,0(2)		;SAME AS SPECIFIED?
	RETERR ATACX3		;NO
	SKIPGE CTRLTT		;THIS JOB NOT ATTACHED? OR
	RETERR ATACX2		;YES
	MOVE 4,CAPENB
	TRNN 4,WHEEL+OPER	;WHEEL OR OPER?
	SKIPGE JOBPT(1)		;OR OTHER JOB NOT ATACHED?
	CAIA			;YES, PERMISSABLE
	RETERR ATACX2		;ILLEGAL
	HRRZ 1,JOBPT(1)		;TOP FORK OF OTHER JOB
	HRRZ 1,FKPGS(1)		;GET PSB OF IT
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	LDB 1,[POINT 13,FPBPGA+JSBPG,26]	;GET JSB NO
	CALL SETMPG
	MOVEI 6,FPBPGA-JSB
	SKIPL 4,CTRLTT(6)	;OTHER JOB NOW UNATACHED?
	JRST [	NOSKED		;NO, MUST DETACH IT FIRST
		MOVE 3,PSICH+3	;CONTROL-C INTERRUPT CODE
		MOVEI 2,0(4)	;LINE NUMBER
		CALL TTPSRQ	;FAKE A CONTROL-C ON OTHER JOB
		SETZM TTPSI(4)	;CLEAR TTY WORDS
		SETOM TTFORK(4)
		SETOM CTRLTT(6)
		MOVE 1,-1(P)	;OTHER JOB NUMBER
		HRROS JOBPT(1)
		OKSKED
		JRST ATACH2]

ATACH2:	PUSH P,CTRLTT
	DTACH
	NOSKED
	POP P,5			;TTY
	DPB 5,[POINT 12,LOGBUF,29] ;TTY NUMBER FOR EFACT
	POP P,4			;OTHER JOB'S DIRECTORY NUMBER
	HRRM 4,LOGBUF+1		;PUT IN EFACT BLOCK
	POP P,4			;DESTINATION JOB NO
	HRLM 4,LOGBUF		;PUT IN EFACT BLOCK
	MOVEM 5,CTRLTT(6)	;SET CTRLTT IN DEST JOB
	HRLM 5,JOBPT(4)
	HRLM 4,TTFORK(5)
	MOVE 1,TTSPSI(6)
	MOVEM 1,TTPSI(5)
	CALL CLRLFK
	OKSKED
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE 1,JOBNO
	HRRE 1,JOBDIR(1)
	JUMPE 1,LOGO		;VANISH IF NOT LOGGED IN
	AOS 0(P)		;RETURN SKIP
	JRST MRETN

;GET AND SAVE ROUTINES

	INTERN .GET,.SAVE,.SSAVE

.GET:	JSYS MENTR
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST ALL ACCESS AND THAWED
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	MOVE 6,2
	HLRZ 2,2
	CAIL 2,1000
	CAIL 2,10000
	JRST .+2
	JRST SGET
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1
	CALL GET3		;SET MAP FOR PAGE
	JRST GET5

GET4:	TRNN 6,777		;JUST CROSSED PAGE BOUNDARY?
	CALL GET3		;YES, REMAP
GET5:	BIN
	MOVEM 2,0(5)
	JUMPE 2,[GTSTS		;0 ENCOUNTERED, GOOD TIME TO CHECK EOF
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES, BAD FILE. GIVE UP
		JRST .+1]	;ALL IS WELL, KEEP GOING
	ADDI 5,1
	AOBJN 6,GET4
	JRST GET2		;NEXT BLOCK

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
	MOVEI 1,0(16)		;JFN
	MOVE 3,2
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	BUG(HLT,<GET - FKHPTN FAILED>)
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE1:	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	ITERR GETX1

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR

.SAVE:	JSYS MENTR
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	JRST SAVE3B		;PT DOESN'T EXIST
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK

;WRITE ALL OR PART OF ONE PAGE

SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
SAVE4:	MOVE 2,0(5)
	BOUT
	ADDI 5,1
	AOBJN 6,SAVE4
	SUBI 6,0(7)		;UPDATE POINTER AND COUNT
	HRLI 6,0(6)
	ADD 7,6
	RET

;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	JSYS MENTR
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	JRST SAVE1		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	BUG(HLT,<SSAVE - FKHPTN FAILED>)
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET

;22 NOV 71, 1804:

	TITLE MON

;TENEX SCHEDULER - D. MURPHY

	EXTERN TTCH7,TTPSI,TADSEC,LSTERR,FACTSW,FLOGO
	EXTERN DIRLCK,DIRUSE,TCITST,TCOTST,TTEMES,FRZWT,CAPMSK,CAPENB

	INTERN ITRAP,BLOCK1,DISGE,DISGET,DISL,RSKP,R,JRET,JSKP,NJOBS
	INTERN ASSFK,WTFPGS,WTSPT,SUSFKR,SUSWT,UCLOCK,ITRAP1
	INTERN STIME,ETIME,NSTAT,SETOVF,MAXQ,DISG,DISGT,BLOCKW
	INTERN SUPERP,PARALP,INFERP,PSILOB,TMZONE

OAP=20			;DEVICE NUMBER FOR 'OTHER PROCESSOR' REALLY 1MS CLOCK

NBP==^D25		;MAX NUMBER PROCESSES IN BAL SET
MINPG==6		;MIN FREE PAGES TO CONSIDER ADDING PROCESS

NSKDP==40		;LOCAL PUSH LIST
NSCDRQ==20		;SIZE OF SCHEDULER REQUEST QUEUE

MAXQ==4			;HIGHEST QUEUE NUMBER

HQJOB==1B19		;IN JOBBIT - JOB SHOULD BE HI-Q ON DISMISS

MINNR==3		;MIN SIZE OF RPLQ FOR LOADING FORK


;STORAGE

LS SKDPDL,NSKDP		;SCHEDULER LOCAL PDL

LS MSCNT,1		;INDEX TO MSEC/TICK TABLE
LS APCLKC,1		;COMMUNICATION TO CH7 FROM CH1 CLOCK INTERRUPT
LS CLKAC2,1		;CLOCK ROUTINE TEMP
LS CLKAC1,1		;  "
LS SYNCC,1		;  "
LS OLDTCK,1		;  "
LS PISC7R,1
LS FKPT6M,1		;-FKPT(6)

GS FORKX,1		;INDEX OF CURRENTLY RUNNING FORK

GS FKPGS,NFKS		;PTB,,PSB   SPT NUMBERS
GS FKSTAT,NFKS		;FORK STATUS
GS FKWSP,NFKS		;WORKING SET PARAMETERS - TAV,,N
GS FKPGST,NFKS		;TEST WORD WHILE IN PAGE WAIT
GS FKOLDS,NFKS		;FORK STATUS PREVIOUS TO INTERRUPT
GS FKPT,NFKS		;LOCATION OF FORK,,FORK QUEUE POINTERS
GS FKINT,NFKS		;FORK INTERRUPT COMMUNICATION REG
GS FKINTB,NFKS		;INTERRUPT CHANNELS REQUEST
GS FKJOB,NFKS		;JOB NUMBER ,, JSB
GS FKNR,NFKS		;AGE,,BALANCE SET SIZE (RESERVE)
GS FKTIME,NFKS		;TIME AT WHICH FORK WAS PUT ON CURRENT QUEUE
GS FKCNO,NFKS		; -- ,, CORE NUMBER
LS FREFK,1		;LIST OF FREE FORKS
GS SYSIFG,1		;SYSTEM HAS BEEN INITIALIZED IF NOT 0
GS ENTFLG,1		;PERMIT NEW JOB ON ^C IF NON-0
GS PWRDWN,1		;POWER FAILURE DETECTED IF .G. 0, DONE IF .L. 0

GS JOBDIR,NJOBS		;ATTACHED DIRECTORY,,LOGIN DIRECTORY
GS JOBNAM,NJOBS		;JOB SUBSYSTEM NAME INDEX FOR SETNM
GS JOBRT,NJOBS		;JOB RUN TIME
GS JOBPT,NJOBS		;CONTROL TTY,,TOP FORK
LS FREJOB,1		;LIST OF FREE JOBS

LS WTLST,1		;WAITING FORK LIST
LS WTLSTL,1		; ... LAST

LS GOLST,1		;RUNNABLE FORK LIST
LS GOLSTL,1		; ... LAST

LS JB0FLG,1		;RUN JOB 0 REQUEST
LS FRECB,1		;FREE CORE NUMBER BITS

;BALANCE SET VARIABLES

LS BALSET,NBP		;BALANCE SET LIST **DO NOT REORDER BALSET, NBT**
LS NBT,NBP		;RUN TIME SINCE ENTERING BALSET
LS FBALS,1		;1 + HIGHEST BALSET SLOT IN USE
LS NBPROC,1		;NUMBER OF PROCESSES IN BAL SET
LS MAXBSQ,1		;Q OF WORST PROCESS IN BAL SET
LS MAXBP,1		;MAX NUMBER OF JOBS IN BAL SET

GS TOTRC,1		;TOTAL NUMBER REAL CORE PAGES
GS TOTRC2,1		;MAX SIZE OF PROCESS FOR SEVERAL JOBS RUNNABLE
GS SUMNR,1		;SUM OF RESERVE PAGES, ALL PROCESSES
GS BALSHC,1		;COUNT OF PAGES IN BALSET BECAUSE OF SHARING
GS PUBCL,1		;PROCESS USE BITS TO BE CLEARED AT GCCOR
LS EXNR,1		;UNCOLLECTABLE PAGES
GS MAXNR,1		;MAX VALUE OF SUMNR
LS MINNRC,1		;MIN SIZE OF RPLQ FOR ALLOWING SWAPIN OF PAGE
GS CGFLG,1		;DEASSIGNED PAGES MAY EXIST IF >0
LS NEBAL,1		;NUMBER OF PROCESSES NOW ENTERING BALSET
LS RUNT1,1		;RUNTIME SINCE FORK BEGAN EXECUTION

GS NRPMIN,1		;MIN VALUE OF NRPLQ FOR GCCOR
GS NRPLQ,1		;NUMBER OF PAGES ON REPLACABLE QUEUE
GS RPLQ,1		;REPLACABLE QUEUE    END,,BGN

GS NPMAX,1		;MAX NUMBER OF PAGES IN CORE FOR ONE PROCESS

;SCHEDULER VARIABLES

LS SKEDF1,1		;START PROCESS VIA CH7 BREAK IN 1
LS SKEDF2,1		;PROCESS BECAME RUNNABLE
LS INSKED,1		;IN SCHEDULER IF NON-ZERO
LS SSKED,1		;LAST JOB RUNNING WAS NOSKED

GS PSKED,1		;PAGE TRANSFER COMPLETED
GS ISKED,1		;SCHEDULE REQUEST FLAG

LS NGOJOB,1		;NUMBER OF RUNNABLE JOBS

LS BSCTIM,1		;TIME AT LAST CHANGE TO NBPROC
LS RJTTIM,1		;TIME AT LAST UPDATE TO RJTSUM
LS RJATIM,1		;TIME OF NEXT RJAV UPDATE
LS RJAVS1,1		;RJTSUM AT LAST RJAV UPDATE

;TABLES FOR SETNM

	INTERN NNAMES

NNAMES==^D40		;NUMBER OF NAMES ALLOWED

GS SNAMES,NNAMES	;SIXBIT NAME OF SUBSYSTEM
GS STIMES,NNAMES	;ACCUMULATED RUNTIME OF SUBSYSTEM
GS SPFLTS,NNAMES	;ACCUMULATED PAGE FAULTS OF SUBSYSTEM
GS SWAKES,NNAMES	;WAKEUPS 0-14, SIZE INTEGRAL 15-35
GS SBLKTM,NNAMES	; BLOCKED FOR TTY TIME

;MONITOR STATISTICS

GS SKDTM0,1		;TIME SPENT IN SKED WITH NO RUNNABLE JOBS
GS SKDTM1,1		;TIME SPENT IN SKED WITH 1 OR MORE RUNNABLE JOBS
GS SKDTM2,1		;TIME SPENT IN GCCOR
GS SPTTIM,1		;TIME SPENT IN PAGER TRAP CODE

GS DRMRD,1		;NUMBER OF DRUM READS
GS DRMWR,1		;NUMBER OF DRUM WRITES
GS DSKRD,1		;NUMBER OF DISK READS
GS DSKWR,1		;NUMBER OF DISK WRITES

GS TTYBKS,1		;NUMBER OF TTY WAKEUPS
GS TTINTS,1		;NUMBER OF TERMINAL INTERRUPTS
GS BSTSUM,1		;INTEGRAL OF NBPROC DT
GS RJTSUM,1		;INTEGRAL OF NBPROC+NGOJOB DT

NRJAVS==3		;NUMBER OF EXPONENTIAL AVERAGES MAINTAINED
GS RJAV,NRJAVS		;EXPONENTIAL AVERAGE OF NUMBER RUNNABLE FORKS

NSTAT==14+NRJAVS		;NUMBER OF STATISTICS WORDS

GS QSUM,MAXQ+1		;ACCUMULATED TIME OF JOBS OF RESPECTIVE Q'S

;CLOCKS COUNTED DOWN AND TESTED, PARALLEL TO PCLKT, DON'T REORDER

LS RJQNT,1		;RUNNING JOB REMAINING QUANTUM
GS TTBTIM,1		;TIME TO NEXT TTY BIG BUFFER SERVICE
GS TIM2,1		;SECOND CLOCK, 100 MS

;LESS PRECISE CLOCKS, COUNTED DOWN AND TESTED PARALLEL TO CLK2CL

GS DSKTIM,1		;TIME TO NEXT DSK RE-QUEUE CHECK
IFDEF MTACHN,<GS MTATIM,1>	;MAG TAPE
IFDEF PTPCHN,<GS PTPTIM,1>	;PAPER TAPE PUNCH
IFDEF PLTCHN,<GS PLTTIM,1>	;PLOTTER
IFDEF DTACHN,<GS DTATIM,1>	;DTA

;END OF PROCESS CLOCKS

LS JOBRTT,1		;JOB RUNTIME SINCE LAST UPDATE

LS SCDRQI,1		;SCHEDULER REQUEST QUEUE
LS SCDRQO,1
LS SCDRQB,NSCDRQ

GS TODCLK,1		;MILLISECOND CLOCK, MONOTONICALLY INCREASING
GS CHKTIM,1		;ONE MINUTE PAST LAST JOB 0 CHECK

LS SCDRN1,1			;RUN ONLY FORK N IF N > -1

;PATCH SPACE FOR RES MON

	INTERN FFF,P1,P2,INDFLG

SCDV1==1		;IF DEFINED MEANS ASSEMBLING MON
SCDVE==.-1		;UPPER LIMIT FOR CORE CLEAR ON STARTUP

FFF:
P1:
P2:	REPEAT 300,<0>

INDFLG:	0			; .NE. 0 MEANS LOCK JSB
				; .L. 0 MEANS USE NO INDIRECT PTRS

;SCHEDULER INITIALIZATION

	INTERN SCDIN

SCDIN:	SETZM SYSIFG
	SETZM PWRDWN
	SETZM ENTFLG
	MOVE 1,[JRST SCDRQ0]
	MOVEM 1,SCDRQ+1		;DISPATCH FOR JSR-CALLED ROUTINE
	MOVEI 1,GOLST
	MOVEM 1,GOLSTL
	MOVEI 1,WTLST
	MOVEM 1,WTLSTL
	MOVNI 1,FKPT		;BECAUSE MACRO DOESN'T HAVE NEG RELOC'N
	HRLI 1,6
	MOVEM 1,FKPT6M		;-FKPT(6)
	MOVEI 1,SCDRQB
	MOVEM 1,SCDRQI
	MOVEM 1,SCDRQO
	MOVEI 1,FKPT
	MOVEI 2,NFKS
	CALL ILIST		;INIT FREE FORK LIST
	MOVEM 1,FREFK
	MOVEI 1,JOBPT
	MOVEI 2,NJOBS
	CALL ILIST
	MOVEM 1,FREJOB		;INIT FREE JOB LIST
	SETOM JOBRT
	MOVE 1,[XWD JOBRT,JOBRT+1]
	BLT 1,JOBRT+NJOBS-1
	SETZM 20
	SETOM SCDRN1
	SETOM FORKX
	SETOM TADSEC
	SETOM SSKED
	MOVE 1,[XWD 000377,777777] ;BITS IN PROCESS USE REG.
	MOVEM 1,FRECB
	MOVEI 1,BALSET
	MOVEM 1,FBALS
	MOVEM 1,INSKED
	SETOM FACTSW
	MOVSI 1,(1B1)
	MOVEM 1,CHKTIM		;PREVENT JOB 0 ALARM UNTIL INITIALIZED
	RET

	INTERN ILIST

ILIST:	ADDI 1,-1(2)
	SETZM 0(1)		;INIT FREE LIST, BLOCK ADR IN AC1,
	SOJLE 2,ILIST1		;  SIZE OF BLOCK IN 2
	MOVEM 1,-1(1)
	SUBI 1,1
	SOJG 2,.-2
ILIST1:	RET

;CHANNEL 7 INTERRUPT
;CLOCK, POSSIBLE RESCHEDULING, OR START PROCESS FROM SCHEDULER

PISC7:	XWD PISC7R,.+1

	SKIPG ISKED		;SCHEDULER REQUEST, OR
	SKIPE APCLKC		;CLOCK TICK?
	JRST APCLK		;SERVICE IT
APCLKX:	SKIPE SKEDF1		;INITIATED BY SCHEDULER?
	JRST SCDR		;YES, GO START PROCESS
	SKIPG INSKED		;IN SCHEDULER NOW, OR
	SKIPG ISKED		;NO SCHEDULING REQUESTS?
	JEN @PISC7R		;IGNORE INTERRUPT
	SKIPN TRAPPC		;PAGER TRAP STARTING?
	SKIPE NSKED		;OK TO RESCHEDULE?
	JRST SCDW		;NO, GO SET TRAPS
	MOVEM 17,PAC+17		;YES, SAVE PROCESS AC'S
	MOVEI 17,PAC
	BLT 17,PAC+16
	MOVE 1,40
	MOVEM 1,PSB40
	MOVE 1,PISC7R
	MOVEM 1,PPC
	AOS INSKED
	JEN @[SCHED0]

SCDW:	MOVEM 1,RSKED		;SAVE AC1
	MOVE 1,RSKEDT		;GET TRAP INSTRUCTION
	EXCH 1,RSKED		;LEAVE IT TO GET EXECUTED
	JEN @PISC7R

RSKEDN:	JFCL 0			;NO-TRAP CONTENTS OF RSKED
RSKEDT:	JSYS RSKD0		;TRAP CONTENTS OF RSKED

;SETUP AND RESUME PROCESS

SCDR:	SETZM SKEDF1		;CLEAR LOCAL FLAG
	SKIPE ISKED		;ANY REQUESTS LATELY?
	JEN @[SCHED0]		;YES, RESCHEDULE AGAIN
	SETZM INSKED		;NO LONGER IN SCHEDULER
	SETOM SSKED
	MOVE 1,PSB40
	MOVEM 1,40
	MOVSI 17,PAC		;RESTORE PROCESS AC'S
	BLT 17,17
	JEN @PPC		;RUN PROCESS

;VARIOUS WAYS OF ENTERING SCHEDULER

	INTERN .HALTF,EDISMS,HALTF1

;JSYS HALTF - DISMISS FORK UNTIL INTERRUPT OR EXTERNALLY RESTARTED

.HALTF:	JSYS MENTR
HALTF1:	CALL FKTMI		;FORK TERM INTERRUPT
HALTX:	MOVEI 1,JRET
	JSYS EDISMS
	JRST MRETN		;IF CONTINUED

;EXEC DISMISS - AC1 CONTAINS  XWD DATA,TEST ROUTINE ADR

EDISMS:	XWD FPC,EDMSQ
EDMSQ:	JSYS ENSKED		;ENTER SCHEDULER
DISMS1:	MOVE 2,FPC		;USE JSYS RETURN AS PPC
	MOVEM 2,PPC
DISMSE:	SKIPN NSKED		;CHECK FOR BUGGY DISMISS
	TRNE 1,600000		;CHECK FOR NON-RES TEST
	BUG(HLT,<DISMISS WHILE NOSKED OR WITH NON-RES TEST ADDRESS>)
	PUSH P,1
	CALL SAVRT
	SETZM JOBCK0		;INIT MEASURING INTERVAL
	POP P,1
	EXCH 1,FKSTAT(7)	;SET NEW STATUS, GET OLD
	MOVE 2,JOBBIT
	TLNE 2,HQJOB		;HI-Q THIS JOB ON DISMISS?
	MOVE 1,QBASE+1		;YES
	MOVEM 1,FKOLDS(7)	;SAVE QUEUE VALUE
	CALL REMBSJ		;REMOVE JOB FROM BAL SET
	CALL WTCONC		;PUT ON WAIT LIST
	HRRZ 1,FKCNO(7)		;CORE NUMBER
	MOVE 1,BITS(1)		;PROCESS USE BIT
	IORM 1,PUBCL		;CLEAR BIT AT NEXT GC
	SETOB 7,FORKX
	JRST SCHED0

;RESCHEDULE ON PAGE WAIT

	INTERN SCHEDP

SCHEDP:	XWD SKDPC,.+1
	SKIPE INSKED
	BUG(HLT,<CALL TO SCHEDULER WHEN ALREADY IN SCHEDULER>)
	JSYS ENSKED
SCHP1:	PUSH P,1
	CALL SAVRT
	POP P,1
	MOVEM 1,FKPGST(7)
	MOVE 1,SKDPC
	MOVEM 1,PPC
	MOVSI 1,400000
	CALL SCHP2
	JRST SCHED0

SCHP2:	SKIPE NSKED
	MOVEM 7,SSKED		;REMEMBER FORK NUMBER OF NOSKED FORK
	HRRZ 10,FKPT(7)		;PROCESS NUMBER
	SKIPN NSWAP		;NON-SWAPPABLE?
	SKIPE NSKED		;NON-RESCHEDULABLE?
	TLO 1,200000		;YES
	HLLM 1,BALSET(10)	;WAITING FLAG
	HRRZS FKPT(7)
	SETOB 7,FORKX
	RET

;DO OKSKED AND RESCHEDULE

SCHEDR:	XWD SKDPC,.+1
	SKIPE INSKED
	BUG(HLT,<CALL TO SCHEDULER WHEN ALREADY IN SCHEDULER>)
	JSYS ENSKED
	SOSGE NSKED
	BUG(HLT,<OKSKED WHEN NOT NOSKED>)
	JRST SCHP1

;DEFERRED SCHEDULING REQUEST TRAP

RSKD0:	XWD SKDPC,.+1
	JSYS ENSKED		;ENTER SCHEDULER
	MOVE 1,SKDPC
RSKD2:	MOVEM 1,PPC
RSKD3:	MOVE 1,RSKEDN
	MOVEM 1,RSKED
	JRST SCHED0

RSKD1:	JSYS ENSKED		;FROM PGUNTP
	HRRZ 1,MJRSTF
	CAIN 1,FPC		;DEFERRED INTERRUPT WAITING?
	JRST RSKD3		;NO
	MOVEI 1,PSISV2		;YES
	EXCH 1,PPC		;SET TO CHECK IT NEXT RUNNING
	MOVEM 1,PIPC
	JRST RSKD3

;COMMON SCHEDULER ENTER ROUTINE, SAVE AC'S AND SET INSKED FLAG

ENSKED:	XWD ENSKR,.+1
	AOS INSKED		;PREVENT ACTION BY CH7 BREAK
	MOVEM 17,PAC+17		;SAVE PROCESS AC'S
	MOVEI 17,PAC
	BLT 17,PAC+16
	MOVE 7,40
	MOVEM 7,PSB40
	MOVE 7,FORKX		;GET INDEX OF CURRENT FORK
	MOVE P,PI7P		;GET PDL POINTER
	JRST @ENSKR

;INSTRUCTION TRAP - TRAP PC IN FPC, ASSUMED TO BE I +1

ITRAP1:	MOVEM 1,LSTERR		;SAVE ERROR CODE GIVEN IN 1
ITRAP:	SKIPE INSKED
	BUG(HLT,<INSTRUCTION TRAP WHILE IN SCHEDULER>)
	SKIPL FORKX		;NO FORK RUNNING, OR
	CONSZ PI,177B27		;PI IN PROGRESS?
	BUG(HLT,<INSTRUCTION TRAP WHILE PI IN PROGRESS OR IN SCHEDULER>)
	SKIPGE SLOWF		;NOW IN SLOW CODE?
	JSYS MENTR		;NO, ENTER
ITR3:	MOVE 1,MPP		;STACK PTR ON ENTERING THIS CONTEXT
	MOVE 2,0(1)		;RETURN PC
	TLNN 2,UMODF		;PREVIOUS CONTEXT INTERRUPTABLE?
	SKIPGE -2(1)		;I.E. USER MODE, OR INTDF .L. 0
	JRST ITR2		;YES, OK
	BUG(CHK,<INSTRUCTION TRAP AND PREVIOUS CONTEXT WAS NOINT>)
ITR2:	SETZM NSKED
	SETOM TRAPC		;CLEAR FLAGS AND COUNTERS
	SETZM INTDF		;SET TO 1 LEVEL NOINTERRUPT
	MOVEI 1,^D15		;INITIATE CHANNEL 15 INTERRUPT
	CALL PSIRQ0
	RESKED			;GET THE INTERRUPT "SEEN"
	OKINT			;INTERRUPT SHOULD TAKE HERE
	MOVE P,UPP		;RETURN TO USER IF CONTINUED
	ADD P,BHC+2
	JRST MRETN

;BLOCK UNTIL CONDITION SATISFIED

BLOCK1:	XWD SKDPC,.+1
	JSYS ENSKED
	MOVNI 1,^D100
	ADDM 1,RJQNT		;CHARGE Q TO PREVENT HOGGING
	MOVNI 1,2
	ADDM 1,SKDPC		;MAKE RETURN TO INSTRUCTION BEFORE CALL
	MOVE 1,TODCLK
	ANDI 1,377777
	ADDI 1,^D100		;ADD 100 MILLISECS
	MOVSI 1,0(1)
	HRRI 1,BLOCKW
	JRST SCHP1		;DISMISS, KEEP IN BAL SET

BLOCKW:	MOVE 2,TODCLK		;SCHEDULER TEST, GET TIME
	ANDI 2,377777
	SUB 1,2			;DESIRED - NOW = WAIT LEFT
BLK2:	JUMPLE 1,1(4)		;NO WAIT TIME LEFT
	CAIGE 1,200000		;BIG DIFFERENCE?
	JRST 0(4)		;NO, KEEP WAITING
	SUBI 1,400000		;YES, COMPENSATE FOR WRAPAROUND
	JRST BLK2

;DISMISS UNTIL WORD .GE. 0

DISGE:	PUSH P,1
	HRLI 1,DISGET		;GIVEN MON ADDRESS IN 1
DISXE:	MOVS 1,1
	JSYS EDISMS
	POP P,1
	RET

DISGET:	SKIPGE 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS UNTIL WORD .L. 0

DISL:	PUSH P,1
	HRLI 1,DISLT
	JRST DISXE

DISLT:	SKIPL 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS UNTIL WORD .G. 0

DISG:	PUSH P,1
	HRLI 1,DISGT
	JRST DISXE

DISGT:	SKIPG 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS FOR SPECIFIED TIME JSYS

	INTERN .DISMS

.DISMS:	JSYS MENTR
	JUMPLE 1,MRETN
	CAIL 1,100000		;LONG OR SHORT TIME?
	JRST TDIS1		;LONG
	MOVE 2,TODCLK
	ANDI 2,377777
	ADDI 2,0(1)		;COMPUTE TIME TO RESTART
	MOVSI 1,0(2)
	HRRI 1,BLOCKW
TDIS2:	JSYS EDISMS		;DISMISS WITH SPECIFIED TEST
	JRST MRETN

TDIS1:	CAML 1,[XWD 400,0]
	MOVSI 1,400		;APPROX 17 HRS IS MAX PERMITTED
	MOVE 2,TODCLK
	TLZ 2,777000
	ADD 2,1			;COMPUTE TIME TO RESTART
	LSH 2,-^D10		;DIVIDE BY 1024
	MOVSI 1,0(2)
	HRRI 1,BLOCKT
	JRST TDIS2		;GO COMPLETE DISMISSAL

;SCHEDULER WAIT TEST FOR LONG WAIT

BLOCKT:	LSH 1,^D10		;RESTORE WAKEUP TIME TO FULL SIZE
	MOVE 2,TODCLK		;GET TIME NOW
	TLZ 2,777000
	SUB 1,2			;DESIRED-NOW = TIME LEFT TO WAIT
BLKT1:	JUMPLE 1,1(4)		;WAKEUP IF NEGATIVE
	CAMG 1,[XWD 400,0]	;VERY LARGE DIFFERENCE?
	JRST 0(4)		;NO, KEEP WAITING
	SUB 1,[XWD 1000,0]	;COMPENSATE FOR WRAPAROUND
	JRST BLKT1		;CHECK AGAIN

;SCHEDULER

	INTERN SCHED0

SCHED0:	SETZ 0,			;FOR PEOPLE WATCHING LIGHTS
SCH0:	CONSZ PI,177B27		;ANY PI IN PROGRESS?
	BUG(HLT,<ENTERED SCHEDULER WITH PI IN PROGRESS>)
	MOVE P,PI7P		;SETUP LOCAL PDL
	MOVE 1,NBPROC
	ADD 1,NGOJOB
	MOVE 2,TODCLK
	SUBM 2,RJTTIM		;REAL TIME SINCE LAST UPDATE TO RJTSUM
	EXCH 2,RJTTIM
	IMUL 2,1		;COMPUTE NBPROC+NGOJOB DT
	ADDM 2,RJTSUM
	MOVE 2,TODCLK
	CAML 2,RJATIM		;TIME FOR RJAV UPDATE?
	CALL DORJAV		;YES
	LSH 1,^D9
	ADD 1,NBPROC
	HRLI 0,0(1)		;DISPLAY NBPROC, NBPROC+NGOJOB IN LH 0
	MOVEM 0,22		;AND 22
	MOVSI 16,-NPCLKS	;SCAN PROCESS CLOCKS
	SKIPG RJQNT(16)		;EXHAUSTED? (RJQNT IS FIRST IN TABLE)
	XCT PCLKT(16)		;YES, SERVICE WHATEVER
	AOBJN 16,.-2
	MOVE 4,SCDRQO
	CAME 4,SCDRQI		;ANY REQUESTS?
	CALL SCDRQ1		;YES
	SKIPE ISKED		;POSSIBLE CHANGE OF STATE?
	CALL SCHED1		;YES, GO TEST WAITING JOBS
	SKIPN PSKED		;PAGE TRANSFER COMPLETE, OR
	SKIPE SKEDF2		;JOB CHANGED STATE?
	CALL DISMSJ		;YES, DISMISS CURRENT JOB
SCH1:	SKIPE PWRDWN		;POWER FAIL DETECTED?
	JRST SCHPRF		;YES
	SKIPE 1,20		;REQUEST FROM SWITCHES?
	JSP 4,SWTST		;YES
	SKIPL 7,FORKX		;JOB TO CONTINUE?
	JRST SCHED3		;YES
	CALL SKDJOB		;NO, GO SCHEDULE ONE

SCHED3:	SETZM SKEDF2
	SKIPGE 1,FKINT(7)	;INTERRUPT REQUEST?
	TLNE 1,200000		;AND NOT ONE IN PROGRESS
	JRST SCHED4
	MOVSI 1,200000		;CLEAR WORD EXCEPT FOR PI IN PROG
	EXCH 1,FKINT(7)
	MOVEM 1,PIMSK		;PASS REQUEST WORD TO SERVICE ROUTINE
	MOVEI 1,PIRQ		;PSEUDO-INTERRUPT SERVICE
	EXCH 1,PPC
	MOVEM 1,PIPC		;SAVE OLD PC
SCHED4:	AOS SKEDF1		;SET FLAG FOR CH7 ROUTINE
	ISB SCDCHN		;LET IT START PROCESS

	DEFINE ECALL (D)
<IFDEF D'CHN,<EXTERN D'CHK
	CALL D'CHK
>>

;TABLE OF SERVICE CALLS FOR PROCESS CLOCKS

PCLKT:	CALL QNTDMS		;RUNNING JOB QUANTUM OVERFLOW
BKGNDT:	CALL SKDLV8		;EVERY TICK STUFF ('LEVEL 8')
	CALL CLK2		;SECOND LEVEL CLOCK
NPCLKS==.-PCLKT
NBKR==.-BKGNDT		;THE (LAST) N OF THESE TO RUN ANYTIME

SKDLV8:	ECALL IMP		;NETWORK
	JRST TTCH7		;TTY BIG BUFFER

;SECOND PROCESS CLOCK, LESS PRECISE, UPDATES EVERY 100 MS

CLK2:	MOVSI 1,(1B1)
	SKIPL SCDRN1		;RUNNING SPECIFIC JOB?
	MOVEM 1,CHKTIM		;YES, DISABLE JOB 0 CHECK
	MOVE 1,TODCLK
	CAML 1,CHKTIM		;JOB 0 OVERDUE?
	BUG(HLT,<JOB 0 NOT RUN FOR TOO LONG, PROBABLE SWAPPING HANGUP>)
	MOVEI 15,^D100
	EXCH 15,TIM2		;SET NEW TIME, GET OLD
	SUBI 15,^D100		;COMPUTE ACTUAL TIME SINCE LAST UPDATE
	MOVSI 14,-N2CLKS	;SET TO SCAN SECOND LEVEL CLOCKS
CLK21:	ADDM 15,DSKTIM(14)	;UPDATE CLOCK
	SKIPG DSKTIM(14)	;COUNTED OUT?
	XCT CLK2CL(14)		;YES, DO WHATEVER
	AOBJN 14,CLK21
	AOS SKEDF2
	RET

;TABLE OF CALLS FOR SECOND LEVEL CLOCKS

CLK2CL:	ECALL DSK		;DISK RE-QUEUE CHECK
	ECALL MTA		;MAG TAPE
	ECALL PTP		;PAPER TAPE PUNCH
	ECALL PLT		;PLOTTER
	ECALL DTA		;DECTAPE
N2CLKS==.-CLK2CL

RSKP:	AOS 0(P)		;RETURN (VIA PDL) SKIPPING
R:	RET

PI7P:	IOWD NSKDP,SKDPDL

;UPDATE RUNNABLE JOB AVERAGES

DORJAV:	MOVEI 2,^D1000
	ADDM 2,RJATIM		;SET TIME OF NEXT UPDATE
	MOVE 4,RJTSUM		;CURRENT INTEGRAL OF NBPROC+NGOJOB
	SUBM 4,RJAVS1		;DIFFERENCE FROM LAST UPDATE
	EXCH 4,RJAVS1
	FSC 4,233		;FLOAT IT
	FDVRI 4,(1000.0)	;AVERAGE OVER LAST 1000 MS
	JOV .+1			;CLEAR OV FLAG
	MOVSI 2,-NRJAVS
SCHC1:	MOVE 3,EXPFF(2)
	FMPRM 3,RJAV(2)		;SUM*EXP(-T/C) -) SUM
	JOV [	SETZM RJAV(2)	;THAT MAY HAVE UNDERFLOWED,
		JRST .+1]	;IF SO, CLEAR IT TO 0
	MOVE 3,4
	FMPR 3,EXPGF(2)
	FADRM 3,RJAV(2)		;TERM*(1-EXP(-T/C)) + SUM -) SUM
	AOBJN 2,SCHC1
	RET

;TABLE OF EXP(-T/C) FOR T = 1 SEC.

EXPFF:	EXP 0.983471454		;C = 1 MIN
	EXP 0.996672216		;C = 5 MIN
	EXP 0.998889506		;C = 15 MIN

;TABLE OF 1-EXP(-T/C) FOR T = 1 SEC

EXPGF:	EXP 0.0165285462	;C = 1 MIN
	EXP 0.00332778395	;C = 5 MIN
	EXP 0.00111049406	;C = 15 MIN

;TEST WORD DEPOSITED BY SWITCHES IN 20

SWTST:	SETZM 20
	JFFO 1,.+1
	CAIGE 2,NSWTT
	XCT SWTT(2)
SWTST1:	JRST 0(4)		;RESUME SCHEDULER

SWTT:	JRST SWHLT		;HALT T.S.
	JRST SWRUN1		;RUN ONLY SPECIFIED JOB
	JRST SWCRSH		;INITIATE JOB0 FUNCTION
NSWTT==.-SWTT

SWHLT:	CALL DISMSJ		;DISMISS CURRENT JOB
	MOVNI 0,1
	JRST .

SWRUN1:	HRREI 1,0(1)		;-1 OR JOB NUMBER IN RH
	JUMPL 1,SWRUN2		;-1 MEANS RESTORE TO NORMAL
	CAIGE 1,NJOBS		;LEGAL JOB NUMBER?
	SKIPGE JOBRT(1)		;RIGHT HALF OF SWITCHES SPECIFIES JOB
	JRST SWTST1		;EXCEPT THAT JOB DOESN'T EXIST
SWRUN2:	MOVEM 1,SCDRN1		;ALLOW ONLY THAT JOB TO RUN
	CALL DISMSJ		;DISMISS CURRENT FORK
	JRST SWTST1

SWCRSH:	CALL DISMSJ
	SETZM SCDRN1		;RUN ONLY JOB 0
	SETZM NXTDMP		;CAUSE DISK BACKUP OPERATION
	MOVEI 1,^D60000
	ADDM 1,TODCLK		;BUMP CLOCK TO GET IT GOING
	JRST SWTST1

;POWER FAIL DETECTED

SCHPRF:	CALL DISMSJ		;FLUSH CURRENT FORK
	MOVEI 1,^D2000
	SOJG 1,.		;WAIT FOR ABOUT 5 MS FOR IO, ETC.
	PIOFF 610000		;CLEAR WORLD
	CONO APR,1B19
	SETOM PWRDWN		;SAYS WE FINISHED PWR DWN SEQUENCE
	JRST 4,.		;SYSTEM SHOULD BE RESTARTABLE AT SYSRST

;SCHEDULER REQUEST PROCESSOR

	INTERN SCDRQ7

;SCDRQ7 CALLED BY ROUTINES HAVING PDL POINTER IN P

SCDRQ7:	PIOFF
	JSR SCDRQ
	PION
	RET

;SCDRQ CALLED BY JSR AFTER HAVING TURNED OFF PI SYSTEM

LS SCDRQ,2

SCDRQ0:	MOVEM 1,@SCDRQI
	AOS 1,SCDRQI
	CAIE 1,SCDRQB+NSCDRQ
	JRST @SCDRQ
	MOVEI 1,SCDRQB
	MOVEM 1,SCDRQI
	JRST @SCDRQ

;PROCESS SCHEDULER REQUESTS

SCDRQ1:	CAMN 4,SCDRQI
	RET
	MOVE 2,0(4)		;WORD CONTAINS DATA,,DISPATCH ADR
	HLRZ 1,2
	CALL 0(2)
	AOS 4,SCDRQO
	CAIE 4,SCDRQB+NSCDRQ
	JRST SCDRQ1
	MOVEI 4,SCDRQB
	MOVEM 4,SCDRQO
	JRST SCDRQ1

;SCHEDULER REQUESTS

	INTERN JOBSRT

JOBSRT:	MOVE 2,SPTC		;CURRENT SPT COUNT
	CAIL 2,SSPT-NOFN-100	;NEARLY FULL?
	JRST JOBSR1		;YES, DON'T PERMIT LOGIN
	MOVE 2,DRMFRE
	CAMG 2,DRMIN0		;ENOUGH DRUM SPACE?
	JRST JOBSR1		;NO
	SKIPE FREJOB		;ROOM FOR NEW JOB
	SKIPN FREFK		;AND NEW FORK?
	JRST JOBSR1		;NO
	PUSH P,1		;START JOB (FROM TTY SRV)
	CALL ASSFK		;GET A FORK
	POP P,1
	HRLI 1,NEWJBF
	IORM 1,FKINT(7)		;LEAVE TTY NUMBER FOR STARTUP ROUTINE
	RET

JOBSR1:	MOVEI 2,0(1)		;LINE NUMBER
	MOVE 1,[POINT 7,[ASCIZ /FULL
/]]
	CALL TTEMES		;GIVE USER BAD NEWS
	SETOM TTFORK(2)		;CLEAR TTY
	RET

;ASSIGN FORK SLOT

ASSFK:	HRRZ 7,@FREFK
	EXCH 7,FREFK		;GET FORK, UPDATE LIST
	SUBI 7,FKPT
	MOVEI 1,JSKP
	MOVEM 1,FKSTAT(7)	;MAKE STATUS RUNNABLE AT NEXT TEST
	MOVE 1,QBASE+1
	MOVEM 1,FKOLDS(7)	;ESTABLISH QUEUE
	CALL WTCONC		;PUT ON WAIT QUEUE
	MOVSI 1,400000+NEWFKF
	MOVEM 1,FKINT(7)	;LEAVE INTERRUPT REQUEST
	SETZM FKINTB(7)
	SETZM FKPGS(7)		;CLEAR PT AND PSB WORD
	SETZM FKJOB(7)
	SETZM FKWSP(7)
	MOVE 1,[XWD 100,3]	;INIT AGE TO 100, W.S. TO 3
	MOVEM 1,FKNR(7)
	AOS ISKED
	RET

;PROCESSOR INTERRUPTS REFERRED FROM CHANNEL 1

P7OV:	MOVEI 2,6		;OVERFLOW, FLOATING OVERFLOW
	JRST P7PI1

P7FOV:	MOVEI 2,7		;FLOATING OVERFLOW CHANNEL
	JRST P7PI1

P7POV:	MOVEI 2,^D9		;PDL OVERFLOW
P7PI1:	EXCH 1,2		;FORK NUMBER LEFT BY APR ROUTINE
	CALL PSIRQ
	RET

MPEINT:	MOVEI 2,^D11		;GIVES IO ERROR INTERRUPT
	JRST P7PI1

;BALANCE SET SCHEDULER
;CALLED TO SELECT JOB TO RUN

SKDJOB:	SETZM 21		;CLEAR JOB-NOW-RUNNING DISPLAY

LDJB5:	MOVE 1,NRPLQ
	ADD 1,IOIP
	CAIL 1,MINNR		;NEED GC?
	SKIPLE CGFLG		;NEED GARBAGE COLLECTION?
	CALL GCCOR		;YES
	MOVE 1,MAXNR		;MAX PERMISSABLE CONTINUING SUMNR
	MOVE 2,NBPROC
	CAMG 2,MAXBP		;BAL SET FULL?
	CAMGE 1,SUMNR		;OVER RESERVED?
	JRST REMJOB		;YES, REMOVE A PROCESS
	SKIPN NEBAL		;PRESENTLY PROCESS ENTERING BALSET? OR
	SKIPL SSKED		;WAIT FOR NOSKED JOB?
	JRST SKDJ7		;YES, DONT CONSIDER ADDING TO BALSET
	SKIPE NGOJOB		;JOB WAITING TO ENTER BALSET?
	JRST LDJOB		;YES, GO LOOK AT IT

SKDJ7:	MOVEI 10,BALSET		;SETUP TO SELECT BEST JOB IN B.S.
	SETO 5,
	SETZM PSKED
	MOVEI 6,-1		;HIGHER THAN HIGHEST POSS Q VAL
SKDJ1:	CAML 10,FBALS		;ALL JOBS EXAMINED?
	JRST SKDJ2		;YES
	SKIPGE 7,0(10)		;THIS ONE RUNNABLE?
	JRST SKDJ3		;NO, GO TEST IT
SKDJ4:	TLNE 7,200000		;NO-SWAP FORK?
	JRST SKDHQ		;YES, GIVE PREFERENCE
SKDHQ1:	CALL CORFCT		;GET PRIORITY VALUE
	SKIPL SCDRN1		;RUN SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(7)	;YES, GET JOB NUMBER OF THIS FORK
		CAME 1,SCDRN1	;CORRECT ONE?
		JRST SKDJ5	;NO
		JRST .+1]	;YES
	CAIL 1,0(6)		;LESS THAN MIN SO FAR?
	JRST SKDJ5		;NO
	MOVEI 6,0(1)		;YES, SO IS PREFERABLE
SKDHQ2:	MOVEI 5,0(7)		;REMEMBER FORK NUMBER AND Q
SKDJ5:	AOJA 10,SKDJ1

;TEST WAITING BALSET FORK

SKDJ3:	TLNE 7,100000		;UNUSED ENTRY?
	JRST SKDJ5		;YES
	MOVE 2,FKPGST(7)	;GET TEST ROUTINE ADDRESS
	HLRZ 1,2		;AND HALF WORD DATA
	JSP 4,0(2)		;CALL TEST ROUTINE
	JRST SKDJ5		;STILL WAITING
	TLZ 7,400000
	MOVEM 7,0(10)
	TLNN 7,(1B3)		;THIS FORK DESIGNATED FOR REMOVAL?
	JRST SKDJ4		;NO
	SUBI 10,BALSET
	HRRZ 1,FKNR(7)		;BUMP RESERVE SO REMBSJ CAN REDUCE IT
	ADDM 1,SUMNR
	CALL REMBSJ		;REMOVE FROM BAL SET
	CALL GOCONC		;ADD TO READY LIST
	JRST SKDJ7		;START OVER

SKDJ2:	SKIPE PSKED		;PAGE TRANSFER FINISHED LATELY?
	JRST SKDJ7		;YES, RECHECK
	JUMPL 5,BKGND1		;-1 MEANS FOUND NO JOB TO RUN
	SKIPL SSKED		;CAN RUN ANY JOB?
	JRST SKDHQ3		;NO, ONLY NOSKED ONE
	SKIPL SCDRN1		;RUN SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(5)	;GET SELECTED FORKS JOB NO
		CAME 1,SCDRN1	;CORRECT ONE?
		JRST REMJOB	;NO, REMOVE FROM BAL SET
		JRST .+1]
SKDHQ4:	MOVEI 7,0(5)
SETRT:	AOS APCLKC
	ISB SCDCHN		;UPDATE RUN CLOCKS
	HRRZM 7,FORKX
	CALL SETPPG		;SETUP PAGER FOR THIS PROCESS
	HRRZ 10,FKPT(7)
	HRRZS BALSET(10)	;CLEAR ANY FLAGS
	HLRZ 2,FKSTAT(7)	;SETUP REMAINING TIME
	HRRZ 3,FKSTAT(7)
	SUB 3,QBASE(2)
	MOVEM 3,RJQNT
	SETZB 2,RUNT1
	EXCH 2,JOBRTT
	ADDM 2,SKDTM1		;CHARGE TIME TO SCHEDULER
	MOVEI 2,0
	HRLM 2,FKPT(7)		;PROCESSOR NUMBER
	HLRZ 1,FKSTAT(7)	;QUEUE LEVEL OF FORK
	HLRZ 2,FKJOB(7)		;JOB NUMBER OF FORK
	IOR 1,BITS(2)		;BIT POSITION DESIGNATES JOB NUMBER
	MOVEM 1,21		;FORK NUMBER AND STATUS FOR LIGHTS
SETOVF:	MOVEI 2,5B29+5B32	;CLEAR OV AND FOV FLAGS
	MOVE 1,PSICHM		;GET THIS FORKS CHANNEL MASK
	TLNE 1,(1B6)		;CHANNEL 6?
	TRC 2,6B32		;YES, ENABLE OVERFLOW
	TLNE 1,(1B7)		;CHANNEL 7?
	TRC 2,6B29		;YES, ENABLE FLOATING OVERFLOW
	CONO APR,APRCHN(2)	;SET APR ACCORDING TO FORGOING
	RET

SKDHQ:	MOVEI 7,0(7)		;FORK NUMBER
	CAME 7,SSKED		;THE NOSKED ONE?
	JRST SKDHQ1		;NO, USE ORDINARY ALGORITHM
	SETZ 6,			;MAKE SURE FORK GET SELECTED
	JRST SKDHQ2

;BACKGROUND ACTIVITIES, IF NO PROCESS TO RUN

SKDHQ3:	CAMN 5,SSKED		;THE NOSKED FORK?
	JRST SKDHQ4		;YES, RUN IT
BKGND1:	MOVSI 16,-NBKR		;PERFORM ANY PERIODIC ROUTINES
	XCT BKGNDT(16)		;WHICH CAN BE RUN MORE OFTEN THAN
	AOBJN 16,.-1		;WHEN THEIR CLOCK RUN OUT
	SKIPN PIAPRX		;RECENT CLOCK INTERRUPT?
	JRST BKGND2		;NO, NOTHING TO UPDATE
	AOS ISKED		;CHECK WAITING JOBS NEXT TIME
	SETZM PIAPRX		;SO AS TO NOTE WHEN APR INT HAPPENS
	AOS APCLKC
	ISB SCDCHN		;UPDATE RUN CLOCKS
	SETZ 1,
	EXCH 1,JOBRTT		;GET TIME SINCE LAST UPDATE
	SKIPE 2,NBPROC		;RUNNABLE JOBS IN EXISTENCE?
	ADDM 1,SKDTM1		;YES, CHARGE 'INEFFICIENCY' CLOCK
	CAIG 2,0
	ADDM 1,SKDTM0		;NO, CHARGE 'NULL' CLOCK
BKGND2:	AOJA 0,SCH0		;TRY AGAIN

;CORE OVER RESERVED, SELECT JOB TO REMOVE
;SELECT THE ONE WITH LARGEST Q VALUE

REMJOB:	MOVEI 10,BALSET
	SETZB 6,5
REMJ2:	CAML 10,FBALS
	JRST REMJ1
	HRRZ 7,0(10)		;GET FORK INDEX
	SKIPL SCDRN1		;RUNNING SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(7)	;YES, GET THIS FORKS JOB NO
		CAMN 1,SCDRN1	;THIS ONE?
		AOJA 10,REMJ2	;YES, DON'T REMOVE IT
		JRST .+1]
	HRRZ 1,FKPGST(7)	;GET WAITING STATUS
	SKIPGE 2,0(10)
	CAIE 1,SWPINT		;ENTERING BALSET?
	TLNE 2,240000		;RESCHEDULABLE AND NOT REMOVED?
	AOJA 10,REMJ2		;NO
	HRRZ 1,FKWSP(7)		;SIZE
	IMUL 1,BTFACT		;TIMES FACTOR
	CAMLE 1,NBP(10)		;(INDEX NBT) IN BALSET LONG ENOUGH?
	JRST [	HLRZ 1,FKSTAT(7) ;NO, MAKE FORK HIGH PRIORITY, USE Q
		JRST .+2]
	CALL CORFCT		;GET WEIGHTED FORK STATUS
	CAMGE 1,6		;MAX SO FAR?
	AOJA 10,REMJ2		;NO
	MOVEI 5,0(10)		;YES, SAVE PROC NUMBER AND VALUE
	MOVEI 6,0(1)
	AOJA 10,REMJ2

REMJ1:	JUMPE 5,REMJ5		;NO REMOVABLE JOB FOUND
	SUBI 5,BALSET
	SKIPGE 7,BALSET(5)	;FORK IN PAGE WAIT?
	JRST REMJ4		;YES
	CALL REMBSJ		;REMOVE JOB FROM BAL SET
	CALL GOCONC		;PUT ON READY LIST
	JRST LDJB5

REMJ4:	MOVSI 1,1B21		;INDICATE FORK DESIGNATED FOR REMOVAL
	IORM 1,BALSET(5)
	HRRZ 1,FKNR(7)		;GET RESERVE
	MOVN 1,1
	ADDM 1,SUMNR		;RELEASE IT
	JRST LDJB5

REMJ5:	JRST SKDJ7		;NOTHING ELSE TO DO

;MAINTAIN INTEGRAL NBPROC DT

BSMEAS:	MOVE 1,TODCLK
	SUBM 1,BSCTIM		;DT - TIME SINCE LAST UPDATE
	EXCH 1,BSCTIM
	IMUL 1,NBPROC		;NBPROC * DT
	ADDM 1,BSTSUM
	RET

;REMOVE JOB FROM BALANCE SET

REMBSJ:	HRRZ 10,FKPT(7)		;GET PROCESS POINTER
	HRRZ 2,FKNR(7)		;GET RESERVE
	MOVN 1,2
	ADDM 1,SUMNR		;REDUCE BALSET SIZE
	CAML 2,NPMAX		;BUT WITHIN SYSTEM MAX
	MOVE 2,NPMAX
	HRRM 2,FKNR(7)		;SET AS RESERVE FOR NEXT RUNNING
	AOS CGFLG		;MAY HAVE LEFT GARBAGE
	MOVSI 2,-PLKV
	SKIPN INDFLG		;LOCKING JSB'S?
	JRST REMB1		;NO
	HRRZ 1,FKJOB(7)		;GET JSB SPT INDEX
	MOVE 1,SPT(1)		;CORE ADR
	ADDM 2,CST1(1)		;DECREASE LOCK COUNT
REMB1:	HRRZ 1,FKPGS(7)
	MOVE 1,SPT(1)
	ADDM 2,CST1(1)		;UNLOCK PSB
	HLRZ 1,FKPGS(7)
	JUMPE 1,.+3
	MOVE 1,SPT(1)
	ADDM 2,CST1(1)		;UNLOCK PT
	MOVE 4,FBALS
	SETOM BALSET(10)	;SET PROCESS WORD TO EMPTY
	CALL BSMEAS		;UPDATE MEASUREMENTS
	SOSG NBPROC
	SETZM SUMNR		;BALSET EMPTY, BE SURE SUMNR NOW 0
	CAIN 4,BALSET+1(10)	;LAST WORD IN USE?
	JRST REMBS3		;YES, GO ADJUST LIMITS OF TABLE
REMBS2:	RET

REMBS3:	SETO 1,
REMBS1:	SOS 4,FBALS		;ADJUST END OF TABLE POINTER
	CAIN 4,BALSET		;TABLE EMPTY?
	JRST REMBS2		;YES
	CAME 1,-1(4)		;LAST ENTRY EMPTY?
	JRST REMBS2		;NO
	JRST REMBS1		;YES, KEEP CHECKING

SETRES:	HRRZ 3,FKPT(7)		;GET BALSET NUMBER
	HRRZ 2,FKNR(7)		;CURRENT RESERVE
	SUB 1,2			;DIFFERENCE
	ADDM 1,SUMNR
	ADDM 1,FKNR(7)		;ADJUST
	RET

;ADD JOB TO BALANCE SET IF POSSIBLE

LDJOB:	SETZM MINNRC		;0 UNLESS TRYING TO LOAD FORK
	CALL SCDRUN		;SELECT BEST RUNNABLE FORK
	JUMPL 7,SKDJ7		;WASN'T ONE
	SKIPG NBPROC		;BALSET NOW EMPTY?
	JRST LDJB6		;YES, LOAD RUNNABLE FORK
	CALL GETMBQ		;COMPUTE MAX FKSTAT OF BALSET FORKS
	CALL CORFCT		;GET WEIGHTED FKSTAT OF NEW PROCESS
	CAMGE 1,MAXBSQ		;BETTER THAN WORST NOW IN BAL SET?
	JRST LDJB6		;YES, LOAD IT
	MOVE 1,NBPROC
	CAML 1,MAXBP		;ROOM IN BALSET?
	JRST LDJB1		;NO, DON'T LOAD
	HRRZ 1,FKNR(7)		;GET RESERVE
	ADD 1,SUMNR		;INCREASE SUM OF RESERVES
	MOVE 2,MAXNR
	SUB 2,NBPROC		;TOTAL CORE LESS ONE PAGE/ACTIVE PROC
	CAIGE 2,0(1)		;ROOM FOR SELECTED JOB?
	JRST LDJB1		;NO
LDJB6:	MOVE 3,NRPLQ		;PAGES NOW ON REPLACABLE
	CAIGE 3,MINNR		;ENOUGH TO LOAD PSB AND UPT?
	JRST LDJB7		;NO
	MOVEI 10,BALSET		;SELECT PROCESS NUMBER
	SETO 1,
LDJB2:	CAML 10,FBALS
	JRST LDJB3
	CAME 1,0(10)		;DELETED ENTRY?
	AOJA 10,LDJB2		;NO

LDJB4:	SUBI 10,BALSET
	MOVEM 7,BALSET(10)	;YES, STORE FORK INDEX IN SLOT
	HRRZM 10,FKPT(7)	;REMEMBER PROCESS POINTER
	CALL BSMEAS
	AOS NBPROC		;COUNT NUMBER OF PROCESSES
	HRRZ 1,FKNR(7)		;GET WORKING SET SIZE
	ADDM 1,SUMNR		;UPDATE SUM OF NR
	HRRZS 1,FKWSP(7)	;START TAV AT 0
	IMUL 1,BTFACT		;INIT NBT ACCORDING TO NUMBER OF
	MOVEM 1,NBT(10)		;PAGES NOW IN CORE
	HRRZ 1,FKPGS(7)		;GET PSB INTO CORE
	JUMPN 1,.+3
	CALL ASSPT		;NO PSB, GO ASSIGN ONE
	HRRZM 1,FKPGS(7)
	CALL SWPIN0
	HLRZ 1,FKPGS(7)
	JUMPN 1,.+3
	CALL ASSPT		;NO UPT, ASSIGN ONE
	HRLM 1,FKPGS(7)
	CALL SWPIN0
	HRRZ 1,FKJOB(7)		;GET JSB SPTN
	JUMPN 1,.+3		;IS ONE?
	CALL ASSPT		;NO, ASSIGN FOR NEW JOB
	HRRM 1,FKJOB(7)
	SKIPE INDFLG		;LOCKING JSB'S?
	CALL SWPIN0		;SWAP IT IN AND LOCK IT
LDJB8:	MOVEI 1,SWPINT
	MOVEM 1,FKPGST(7)	;SET TEST TO WAIT FOR PSB AND PT
	MOVSI 1,400000
	HLLM 1,BALSET(10)
	AOS NEBAL		;ONE MORE JOB NOW ENTERING BALSET
	JRST LDJB5		;CONTINUE SCHEDULING

LDJB1:	CALL GOCONC		;PUT PROCESS BACK ON READY LIST
	JRST SKDJ7

LDJB3:	AOS FBALS		;INCREASE END OF TABLE POINTER
	JRST LDJB4

LDJB7:	CALL GOCONC		;PUT FORK BACK ON GOLST
	MOVEI 1,MINNR
	MOVEM 1,MINNRC		;SET RPLQ MINIMUM TO RESERVE SPACE
	ADD 3,IOIP		;ROOM TO LOAD PSB AND UPT WHEN CURRENT
	CAIL 3,MINNR		;WRITES COMPLETE?
	JRST SKDJ7		;YES, CONTINUE TO RUN WHILE WRITES COMPL
	JRST REMJOB		;NO, REMOVE A FORK FROM BALSET

;COMPUTE MAX Q OF PROCESSES NOW IN BALSET (I.E. LEAST PREFERABLE FORK)

GETMBQ:	PUSH P,7
	MOVEI 5,BALSET
	SETZ 6,
GMB1:	CAML 5,FBALS		;LOOKED AT ALL?
	JRST [	MOVEM 6,MAXBSQ	;YES, SAVE MAX
		POP P,7
		RET]
	HRRZ 7,0(5)		;GET FORK NUMBER
	CAIN 7,-1		;SLOT IN USE?
	AOJA 5,GMB1		;NO
	HRRZ 1,FKWSP(7)
	IMUL 1,BTFACT		;MIN TIME IN BALSET
	CAMLE 1,NBP(5)		;(INDEXES NBT) BEEN IN LONG ENOUGH?
	AOJA 5,GMB1		;NO, TREAT AS HIGHEST PRIORITY
	CALL CORFCT		;GET WEIGHTED FKSTAT
	CAIL 1,0(6)		;MAX?
	MOVEI 6,0(1)		;YES
	AOJA 5,GMB1

BTFACT:	EXP ^D20		;MS/PAGE MINIMUM FOR BALSET

;DISMISS JOB FOR RESCHEDULING

DISMSJ:	MOVE 7,FORKX
	JUMPL 7,R		;NO JOB
	CALL SAVRT		;UPDATE QUEUE AND QUANTUM
QNTDM1:	SETZ 1,
	EXCH 1,PGTIM		;TIME SINCE LAST PAGER TRAP
	HRRZ 2,FKWSP(7)		;CURRENT SIZE
	IDIVI 1,0(2)
	MOVSI 1,0(1)
	ADDM 1,FKWSP(7)		;UPDATE P-FAULT AVERAGE
	SETZ 1,
	JRST SCHP2

;DISMISS FORK ON QUANTUM OVERFLOW

QNTDMS:	MOVE 7,FORKX
	JUMPL 7,R
	CALL SAVRT		;UPDATE QUEUE VALUE
	HRRZ 1,FKWSP(7)
	CALL SETRES		;SET RESERVE TO CURRENT SIZE
	JRST QNTDM1

;TIMER ROUTINES

;	JSP 4,STIME	;STARTS TIMING
;	..		;PROGRAM
;	JSP 4,ETIME	;ENDS TIMING, RETURNS TIME IN 1
;	ADDM 1,CLOCK	;ADD TIME TO APPROPRIATE CLOCK

STIME:	AOS APCLKC
	ISB SCDCHN		;UPDATE CLOCKS
	SETZ 1,
	EXCH 1,JOBRTT		;GET AND RESET RUNTIME
	PUSH P,1
	JRST 0(4)

ETIME:	AOS APCLKC
	ISB SCDCHN
	POP P,1			;OLD RUNTIME
	EXCH 1,JOBRTT		;RESTORE OLD RUNTIME, GET RUNTIME OF
	JRST 0(4)		;TIMED CODE AND RETURN IT

;UPDATE QUEUE NUMBER AND TIME USED VALUE

SAVRT:	JSP 3,UCLOCK		;UPDATE CLOCKS
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE NUMBER
	HRLOI 1,377777		;LARGEST NUMBER
	EXCH 1,RJQNT		;GET REMAINING QUANTUM
	MOVE 3,RUNT1		;RUNTIME THIS RUNNING
	ADDM 3,QSUM(2)		;ACCUMULATE STATISTIC
	HRRZ 10,FKPT(7)		;BALSET INDEX
	ADDM 3,NBT(10)		;ACCUMULATE RUNTIME IN BALSET
	JUMPG 1,DISMJ1		;NOT EXHAUSTED
	MOVE 1,JOBNO
	SKIPE JOBCK0		;GUARANTEE WORDS INIT'ED?
	JRST SAVRT7		;YES, GO CHECK CURRENT PERFORMANCE
	MOVE 3,TODCLK		;INITIALIZE TIME QUARANTEE WORDS
	MOVEM 3,JOBCK0
	MOVE 3,JOBRT(1)
	MOVEM 3,JOBCK1
SAVRT7:	LDB 3,[POINT 7,JOBBIT,17] ;GET GUARANTEE PERCENTAGE
	JUMPE 3,SAVRT8		;NOT SPECIAL
	MOVE 4,JOBRT(1)		;COMPUTE RUNTIME DURING TEST INTERVAL
	SUB 4,JOBCK1
	MOVE 1,TODCLK		;COMPUTE REAL TIME OF TEST INTERVAL
	SUB 1,JOBCK0
	IMULI 4,^D100		;COMPUTE RUNTM*100%/PCT TO GET
	IDIV 4,3		;EXPECTED REAL TIME
	SUB 4,1			;EXCESS OR DEFICIT OF REAL TIME
	MOVEM 4,23		;FOR LIGHT WATCHERS
	HRLM 2,23		; ..
	JUMPGE 4,SAVRT5		;.G. 0 MEANS BETTER THAN GUARANTEE
	MOVEI 2,0		;KEEP ON QUEUE 0 TO GET EXCLUSIVE TIME
	JRST SAVRT9

SAVRT8:	SETZM FKTIME(7)
	LDB 3,[POINT 6,JOBBIT,35] ;GET MAX Q FOR THIS JOB
	CAIL 2,0(3)		;IF REACHED MAX Q, AND 
	JUMPN 3,[LDB 2,[POINT 6,JOBBIT,29] ;PRIORITY WORD NOT 0,
		MOVEM 7,23	;FOR DISPLAY
		JRST SAVRT9]	;SET NEW Q AS SPECIFIED
	CAIGE 2,MAXQ		;NOW ON MAX Q?
	AOJA 2,SAVRT9		;NO, GO TO NEXT ONE
SAVRT9:	MOVSM 2,FKSTAT(7)
	MOVE 3,TODCLK
	SKIPN FKTIME(7)		;TIME ON QUEUE ALREADY SET?
	MOVEM 3,FKTIME(7)	;NO, SET IT
	SKIPA 1,QBASE+1(2)	;NEXT QUEUE TIME
DISMJ1:	ADD 1,QBASE(2)		;INCREASE BY BASE TIME
	HRRM 1,FKSTAT(7)
	RET

;4 NOW CONTAINS TIME SUCH THAT AFTER THAT REAL-TIME INTERVAL,
;WITH NO RUNNING OF PROGRAM, ACTUAL PCT WILL EXACTLY EQUAL DESIRED PCT

SAVRT5:	CAIGE 4,LOWQT		;ACCUMULATED EXCESS .GE. LOW-Q QUANT?
	JRST [	CAIGE 2,MAXQ-1	;NO, STILL ON HIGHER QUEUES?
		JRST SAVRT8	;YES, FOLLOW NORMAL ALGORITHM
		MOVEI 2,MAXQ-1	;STAY ON SECOND LOWEST QUEUE
		SETZM FKTIME(7)
		JRST SAVRT9]
	CAIGE 4,2*LOWQT		;ACCUMULATED LARGE EXCESS?
	JRST SAVRT6		;NO
	SUBI 4,2*LOWQT		;YES, REMOVE EXCESS OVER 2*LOWQT
	MOVN 4,4
	ADDM 4,JOBCK0		;FROM CONSIDERATION
	MOVEI 4,2*LOWQT
SAVRT6:	ADD 4,TODCLK		;COMPUTE WHEN TO RUN AGAIN
	MOVEM 4,FKTIME(7)
	MOVEI 2,0		;AND RUN ON 0 AT THAT TIME
	JRST SAVRT9

;UPDATE USER CLOCKS ON REQUEST
;CALLED WITH  JSP 3,UCLOCK

UCLOCK:	AOS APCLKC
	ISB SCDCHN		;UPDATE SCHEDULER CLOCKS
	MOVE 2,JOBNO
	SETZ 1,
	EXCH 1,JOBRTT		;RUN TIME SINCE LAST UPDATE
	ADDM 1,JOBRT(2)		;ACCOUNT FOR JOB
	ADDM 1,FKRT		;ACCOUNT FOR FORK
	ADDM 1,PGTIM		;PAGE TRAPS
	ADDM 1,RUNT1		;LOCAL RUNTIME
	HRRZ 2,JOBNAM(2)	;GET SUBSYSTEM INDEX
	ADDM 1,STIMES(2)	;ACCUMULATE SUBSYSTEM TIME
	JRST 0(3)

WTCONC:	MOVE 1,TODCLK		;SAVE TIME FORK WAS PUT INTO WAITING
	MOVEM 1,FKPGST(7)
	HRRZ 1,FKWSP(7)
	JUMPN 1,WTCON1		;NO PAGES IN CORE?
	HRRZ 1,FKCNO(7)		;YES, HAS CORE NUMBER?
	JUMPE 1,WTCON1
	MOVE 1,BITS(1)		;YES, DEASSIGN IT
	IORM 1,FRECB
	HLLZS FKCNO(7)
WTCON1:	MOVEI 1,WTLST
	HRLZM 1,FKPT(7)		;REMEMBER WHERE FORK IS
	MOVEI 6,FKPT(7)		;PUT FORK ON WAIT LIST
	HRRM 6,@WTLSTL
	MOVEM 6,WTLSTL
	RET

;TEST ALL WAITING JOBS FOR READY (CONDITION SATISFIED)

SCHED1:	SETZM ISKED
	MOVEI 6,WTLST		;HEAD OF WAITING LIST
SCHEDA:	MOVEI 5,0(6)		;KEEP POINTER TO LAST ONE IN 5,
SCHEDB:	HRRZ 6,0(5)		;POINTER TO CURRENT ONE IN 6
	JUMPE 6,R		;DONE, LIST EMPTY
	MOVEI 7,@FKPT6M		;FORK INDEX
	MOVE 2,FKSTAT(7)	;FKSTAT/  TEST VALUE,,ADR OF TEST ROUTINE
	HLRZ 1,2
	JSP 4,0(2)		;CALL TEST ROUTINE
	JRST SCHEDI		;NO SKIP => STILL NOT RUNNABLE
	CALL NEWST		;ESTABLISH NEW QUEUE STATUS
SCHEDJ:	HRRZ 2,0(6)		;REMOVE FROM WAIT LIST
	HRRM 2,0(5)
	CAMN 6,WTLSTL
	MOVEM 5,WTLSTL
	CALL GOCONC		;PUT ON READY LIST
	AOS SKEDF2		;RESCHED SINCE THIS JOB MIGHT BE BETTER
	JRST SCHEDB

SCHEDI:	SKIPGE 1,FKINT(7)	;INTERRUPT WAITING?
	TLNE 1,200000		;AND ACCEPTABLE?
	JRST SCHEDA		;NO
	MOVSI 1,PSIWTF		;YES, REMEMBER WAS IN WAIT STATE
	IORM 1,FKINT(7)
	PUSH P,FKSTAT(7)	;INTERRUPT - SAVE WAIT TEST
	CALL NEWST		;COMPUTE NEW STATUS
	POP P,FKOLDS(7)		;REMEMBER WAIT TEST
	JRST SCHEDJ		;GO MAKE RUNNABLE

GOCONC:	MOVEI 2,GOLST		;REMEMBER WHERE FORK IS
	HRLZM 2,FKPT(7)
	MOVEI 6,FKPT(7)
	HRRM 6,@GOLSTL		;ADD TO READY LIST
	MOVEM 6,GOLSTL
	AOS NGOJOB		;KEEP COUNT OF READY JOBS
	HRRZ 2,FKCNO(7)
	JUMPN 2,R		;HAS CORE NUMBER ALREADY?
	PUSH P,3		;NO, ASSIGN ONE
	MOVE 2,FRECB
	JFFO 2,.+2
	MOVEI 3,^D35		;NONE AVAILABLE, USE 35
	MOVE 2,BITS(3)
	ANDCAM 2,FRECB		;MAKE IT NO LONGER FREE
	HRRM 3,FKCNO(7)
	POP P,3
	RET

JSKP:	JRST 1(4)
JRET:	JRST 0(4)

;COMPUTE PRIORITY NUMBER FOR FORK

CORFCT:	MOVE 1,FKTIME(7)	;TIME ON CURRENT QUEUE
	SUB 1,TODCLK		;NEGATIVE OF INTERVAL ON CURRENT QUEUE
	JUMPG 1,[ADDI 1,400000	;NOT YET TIME TO RUN, RETURN VERY LOW
		RET]		;PRIORITY NUMBER
	PUSH P,2
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE NUMBER
	ASH 1,@TFACTR(2)	;DIVIDE TIME AS FUNCTION OF QUEUE
	ADD 1,TBASE(2)
	CAIGE 1,0		;IN CASE WAITED VERY LONG
	SETZ 1,			;SET TO MAX PRIORITY
	POP P,2
	RET

;QUEUE PARAMETER TABLES

	RADIX 10

QBASE:	0
	100
	500
	2500
	4500
	14500

LOWQT=10000			;TIME QUANTUM OF LOWEST QUEUE

TBASE:	1000
	3000
	8000
	10500
	16750

TFACTR:	Z 0			;INDIRECTED TO BY ASH INSTRUCTION
	Z -1
	Z -2
	Z -3
	Z -4

	RADIX 8

;HEURISTIC FOR ADJUSTING QUEUE LEVEL AFTER I/O WAIT

NEWST:	MOVE 1,TODCLK		;CALCULATE ACTUAL WAITING TIME
	SUB 1,FKPGST(7)
	ADDM 1,FKTIME(7)	;DON'T COUNT WAIT TIME
	JFCL .+4		;JFCL THIS TO INCLUDE NJOB WEIGHTING
	MOVE 2,NGOJOB		;CALC NUMBER OF CURRENT CPU JOBS
	ADD 2,NBPROC
	IDIVI 1,1(2)		;PLUS 1 FOR SELF
	CAMGE 1,QBASE+1		;WAITED AT LEASE QUEUE 0 QUANTUM?
	JRST [	MOVE 2,FKOLDS(7) ;NO, GIVE NO CREDIT
		JRST NEWST2]	;KEEP OLD VALUES
	HRRZ 2,FKWSP(7)		;NUMBER OF PAGES NOW IN CORE
	CAIGE 2,MINNR
	MOVEI 2,MINNR		;BUT AT LEAST REQUIRED PAGES
	HRRM 2,FKNR(7)
	HRRZ 2,FKOLDS(7)	;OLD QUEUE VALUE
	SUB 2,1			;LESS ADJUSTED WAITING TIME
	CAMG 2,QBASE+2		;WAITED LONG ENOUGH FOR HIGH-QUEUE?
	JRST NEWST1		;YES
	HLRZ 1,FKOLDS(7)	;PREVIOUS QUEUE LEVEL
	SUBI 1,2		;BUMP UP AT LEAST ONE
	CAML 2,QBASE+1(1)	;LONGEST?
	MOVE 2,QBASE+1(1)	;YES, MAKE 2ND LONGEST
	CAMGE 2,QBASE(1)	;ABOVE BASE FOR THIS LEVEL?
	SOJG 1,.-1		;NO, GO A LEVEL DOWN
NEWST5:	MOVE 2,TBASE		;REQUEUE WITH PRIORITY EQUAL TO QUEUE 0
	SUB 2,TBASE(1)
	MOVN 3,TFACTR(1)
	ASH 2,0(3)
	ADD 2,TODCLK
	MOVEM 2,FKTIME(7)	;YES
	MOVE 2,QBASE(1)		;GIVE QUEUE 0 QUANTUM
	ADD 2,QBASE+1
	HRLI 2,0(1)		;CONSTRUCT FKSTAT WORD
NEWST2:	MOVEM 2,FKSTAT(7)
	RET

NEWST1:	MOVE 2,QBASE+1
	MOVE 1,TODCLK
	MOVEM 1,FKTIME(7)	;REMEMBER TIME ON CURRENT QUEUE
	JRST NEWST2

;SCHEDULE BEST JOB TO RUN NOW

SCDRUN:	MOVEI 6,GOLST		;LIST OF READY JOBS
	MOVEI 4,-1		;LOWEST NUMBER SO FAR
SCHEDC:	MOVEI 5,0(6)
	HRRZ 6,0(5)
	JUMPE 6,SCHEDD		;LIST EMPTY, NO MORE TO TEST
	MOVEI 7,@FKPT6M		;COMPUTE FORK INDEX
	CALL CORFCT		;GET PRIORITY VALUE
	CAIL 1,0(4)		;LOWEST YET?
	JRST SCHEDC		;NO
	SKIPL SCDRN1		;RUN ONLY SPECIFIED FORK
	JRST [	HLRZ 2,FKJOB(7)	;GET, THIS FORKS JOB NUMBER
		CAME 2,SCDRN1	;RUN THIS ONE?
		JRST SCHEDC	;NO, IGNORE
		JRST .+1]
	MOVEI 4,0(1)		;YES, REMEMBER NEW VALUE
	MOVEI 3,0(5)		;AND LOCATION
	JRST SCHEDC

SCHEDD:	MOVNI 7,1
	CAIN 4,-1		;ANY JOB FOUND?
	RET			;NO, RETURN NULL JOB
	HRRZ 6,0(3)		;REMOVE FROM READY LIST
	HRRZ 2,0(6)
	HRRM 2,0(3)
	CAMN 6,GOLSTL
	MOVEM 3,GOLSTL
	SOS NGOJOB
	MOVEI 7,@FKPT6M		;RETURN FORK INDEX
	RET

;CLOCK ROUTINES

;CALLED FROM APR INTERRUPT, 60 CY CLOCK INITIATES BREAK ON CH7
;FOR SERVICE

APCLK1:	CONO APR,1000+APRCHN	;TURN OFF FLAG
	AOS APCLKC		;FOR CH7 ROUTINE
	ISB 7
	SOSLE MSCNT		;THIRD TICK?
	JEN @PIAPRX
	MOVEM 1,MSCNT		;THIRD TICK (50 MS.), SYNC 1 MS. CLOCK
	SKIPE 1,SYNCC		;COUNTED 50 MS.?
	JRST [	ADDM 1,TODCLK	;NO, FINISH UP LAST TICKS
		JRST .+2]	;AND LEAVE IT RUNNING
	CONO OAP,1B29		;TURN CLOCK BACK ON
	MOVEI 1,^D50
	MOVEM 1,SYNCC		;SET TO SYNC AFTER 50 TICKS
	MOVEI 1,3		;AND 3 TICKS OF 60 HZ CLOCK
	EXCH 1,MSCNT
	JEN @PIAPRX

;SCHEDULER CLOCK UPDATE

APCLK:	SETZM APCLKC		;CLEAR REQUEST FLAG
	MOVEM 1,CLKAC1		;SAVE COUPLE AC'S
	MOVEM 2,CLKAC2
	MOVE 1,TODCLK		;CLOCK UPDATED BY 1MS INTERRUPT
	SUBM 1,OLDTCK		;COMPUT NUMBER MS. SINCE LAST UPDATE
	EXCH 1,OLDTCK		;SAVE 'NOW' IN OLDTCK
	ADDM 1,JOBRTT
	MOVN 1,1
	MOVSI 2,-NPCLKS		;UPDATE PROCESS CLOCKS
APCLK3:	ADDM 1,RJQNT(2)		;UPDATE (RJQNT IS FIRST OF TABLE)
	SKIPG RJQNT(2)		;TIMED OUT?
	AOS ISKED		;YES, NOTIFY SCHED
	AOBJN 2,APCLK3
	MOVE 2,CLKAC2		;RESTORE AC2
	MOVE 1,CLKAC1
	JRST APCLKX

;HALT JOB

	INTERN HLTJB,HLTFK1,CLRM0
	EXTERN KSELF,LOGTOT,LOGDES

HLTJB:	HRRE 6,CTRLTT
	JUMPL 6,HLTJB1		;IF JOB DETACHED
	SETZM TTPSI(6)		;CLEAR TTY WORDS
	SETOM TTFORK(6)
HLTJB1:	MOVE 5,JOBNO
	SETZM CTRLTT		;CLEAR CONTROL TTY WORDS
	HRRZS JOBPT(5)
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE ALL INTERRUPTS
	MOVNI 1,1
	CLOSF
	JFCL
	RELD			;RELEASE ALL DEVICES
	JFCL
	MOVEI 1,-4
	KFORK			;KILL ALL INFERIOR FORKS
	MOVE 7,FORKX		;THIS FORK.
	HLLZ 2,FKPGS(7)		;FORKS PT
	MOVSI 6,-1000
	CALL CLRM0		;CLEAR UPT
	MOVE 6,[XWD PJMPG-PPMPG,PJMPG+40]
	HRLZ 2,FKJOB(7)		;GET SPTN OF JSB
	CALL CLRM0		;CLEAR ANY PAGES MAPPED IN JOB AREA
	SETO 1,
	HRLZ 2,JOBPMF
	MOVSI 6,-1000
	HRRI 2,0(6)
	PMAP			;DELETE CONTENTS OF PMF
	AOBJN 6,.-2
	HRRZ 1,JOBPMF
	SETOM JOBPMF		;ENABLE CLOSE OF PMF
	CLOSF			;CLOSE PMF - NO JSYS' AFTER HERE
	JFCL
HLTJB4:	SETZM PSB+UPTPG
	SETZM PSB+UACPG		;CURRENTLY CAN ONLY BE PSB
	MOVE 6,[XWD CPTPG+1-PSBPG,CPTPG+1]
	HRLZ 2,FKPGS(7)
	CALL CLRM0		;CLEAR PAGES IN PP AREA
	HRRZ 1,FKJOB(7)		;JSB
	CALL WTSPT		;WAIT FOR IT TO BE UNSHARED
	CALL WTFPGS		;WAIT FOR PSB AND UPT TO BE IN NO MAPS
	MOVE 1,JOBNO		;RELEASE JOB NUMBER
	SETZM JOBDIR(1)		;CLEAR DIRECTORY NUMBER
	SETOM JOBRT(1)		;INDICATE JOB NUMBER NOT IN USE

	ADDI 1,JOBPT
	EXCH 1,FREJOB		;PUT SLOT ON FREE LIST
	MOVEM 1,@FREJOB
HLTFK1:	JSYS ENSKED		;ENTER SCHEDULER
	CALL REMBSJ		;REMOVE FORK FROM BAL SET
	MOVEI 1,(1B0)
	HRLM 1,FKPT(7)		;NOTE FORK NOT IN BALSET
	MOVSI 1,1
	ADDM 1,CGFLG		;INSIST ON GCCOR
	HRRZ 1,FKJOB(7)		;JSB
	LDB 2,[POINT 14,SPT(1),13] ;SHARE COUNT NOW 1?
	CAIE 2,1		;LAST USE OF JSB?
	JRST [	MOVSI 2,-1B31	;NO, REDUCE SHARE COUNT
		ADDM 2,SPT(1)
		JRST .+2]
	CALL DESPT		;YES, DELETE IT (LOGOUT CASE)
	HLRZ 1,FKPGS(7)		;UPT
	CALL DESPT		;DELETE IT
	HRRZ 1,FKPGS(7)
	CALL DESPT		;DEASSIGN PSB
	SETOM FORKX
	PUSH P,7
	ADDI 7,FKPT
	EXCH 7,FREFK		;PUT FORK NUMBER ON FREE LIST
	TLO 7,400000
	MOVEM 7,@FREFK
	CALL GCCOR		;CLEAN UP PAGES
	POP P,7
	HRRZ 1,FKWSP(7)		;MAKE SURE FORK CLEANED UP
	HRRZ 2,FKCNO(7)
	CAIN 1,0
	CAIE 2,0
	BUG(CHK,<FORK NOT PROPERLY DELETED>)
	JRST SCHED0		;NOW THERE IS NOTHING LEFT OF JOB...

CLRM0:	SETZ 1,
CLRM1:	HRRI 2,0(6)		;PUT PAGE NUMBER WITH PTN
	CALL SETPT
	AOBJN 6,CLRM1
	RET

;WAIT FOR PSB AND UPT TO HAVE SHARE COUNT OF 1

WTFPGS:	HRRZ 1,FKPGS(7)		;PSB
	CALL WTSPT
	HLRZ 1,FKPGS(7)		;UPT
WTSPT:	PUSH P,4
WTSPT2:	JSP 4,WTSPTT		;TEST PAGE NOW
	JRST WTSPT1		;MUST WAIT
	POP P,4			;NOW OK
	RET

WTSPT1:	MOVSI 1,0(1)
	HRRI 1,WTSPTT
	JSYS EDISMS
	HLRZ 1,1
	JRST WTSPT2

WTSPTT:	LDB 2,[POINT 14,SPT(1),13]	;GET SHARE COUNT
	CAIE 2,1
	JRST 0(4)
	JRST 1(4)

;PRELIMINARY FORK INIT

	EXTERN TTFORK,EXEC0

FKSET:	MOVE 1,PSB+PSBPG	;SETUP USER MAP WORD
	MOVEM 1,PSB+UACPG	;SAME AS PSB UNTIL OVERFLOW
	MOVE 1,[IOWD NUPDL,UPDL]
	MOVEM 1,UPP		;MON ROUTINES PDL
	MOVE 1,[IOWD 1000,PSIPGA]
	MOVEM 1,PSIPT		;PSI STORAGE STACK
	MOVEI 1,<UACB>B39	;SETUP AC BASE
	MOVEM 1,ACBAS
	MOVEM 1,ACBAS1
	SETACB 1
	MOVE 1,INTDF0		;INTERRUPT SWITCHES
	MOVEM 1,INTDFF
	MOVE 1,MJRST0
	MOVEM 1,MJRSTF
	SETZM NSKED
	MOVE 1,RSKEDN
	MOVEM 1,RSKED
	MOVSI 1,<UMOVEM 1,0>B53
	MOVEM 1,PATU40		;SETUP INSTRUCTION PART FOR COMPAT
	MOVEM 1,PATUPC		;ENTRY PROCEDURE
	SETOM SLOWF
	SETOM INTDF
	SETOM TRAPC
	SETOM FKTAB
	MOVEI 1,FKTAB+1
	HRLI 1,-1(1)
	BLT 1,FKTAB+NLFKS/2-1
	MOVE 2,FORKX
	HLRZ 1,FKPGS(2)		;GET SPTN OF PAGE TABLE
	LSH 1,^D9		;CONSTRUCT SHARE POINTER
	TLO 1,RWXB-XCTB+SHRBIT
	MOVEM 1,PSB+UPTPG
	MOVE 6,FORKX
	TLNE 7,NEWJBF		;NEW JOB TOO?
	JRST FKSET1		;YES
	HRRZ 1,FKJOB(6)		;GET JSB
	MOVSI 2,1B31
	ADDM 2,SPT(1)		;BUMP SHARE COUNT
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT	;CONSTRUCT SHARE POINTER
	MOVEM 1,PSB+JSBPG
	MOVEI 1,FKSET2
FKSET3:	MOVEM 1,PIPC
	SETZM PIOLDS
	MOVE 1,PSB+JSBPG	;GET JSB POINTER
	TLC 1,SHRBIT+INDBIT	;MAKE INTO INDIRECT POINTER
	ADDI 1,1000-PPMPG+PJMPG	;JOB PT OFFSET
	MOVEI 2,PJMPG
	MOVEM 1,PSB(2)		;FILL MON MAP WITH IND POINTERS
	ADDI 2,1
	CAIGE 2,PPMPG
	AOJA 1,.-3
	JRST PIRQR		;DEBREAK - RUN IN NORMAL MODE

;INIT NEW JOB

FKSET1:	MOVEI 2,0(7)		;GET NUMBER OF CONTROLLING TTY
	MOVE 1,@FREJOB		;ASSIGN JOB NUMBER
	EXCH 1,FREJOB
	SUBI 1,JOBPT
	MOVEM 1,JOBNO
	HRLM 1,FKJOB(6)		;JOB NUMBER TO FORK TABLE
	MOVSM 2,JOBPT(1)	;TTY ASSIGNED TO JOB
	HRLM 1,TTFORK(2)	;JOB CONTROLLED BY TTY
	MOVE 2,FORKX
	HRRM 2,JOBPT(1)		;TOP FORK OF JOB
	SETZM JOBRT(1)		;JOB RUNTIME
	HRRZ 1,FKJOB(6)		;JSB
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT
	MOVEM 1,PSB+JSBPG	;SETUP JSB
	MOVE 1,JOBNO
	HLRZ 2,JOBPT(1)		;CONTROLLING TTY
	MOVEM 2,CTRLTT		;IN JSB
	MOVEI 1,EXEC0
	JRST FKSET3

FKSET2:	SETZ 0,			;START WITH 0 AC'S
	MOVEI 17,1
	BLT 17,16
	SETZ 17,
	JSYS ENSKED
	MOVSI 1,UMODF
	MOVEM 1,PPC
	MOVEI 1,JRET
	JRST DISMSE

INTDF0:	SOS INTDF		;NORMAL CONTENTS OF INTDFF
MJRST0:	JRSTF @FPC		;NORMAL CONTENTS OF MJRSTF
CHNSON:	EXP 1B9+1B11+1B15+1B16+1B17+1B18+1B20	;ALWAYS ON PSI CHANS

;PSEUDO-INTERRUPT SYSTEM

	EXTERN BHC,BITS,CH6TAB

NEWFKF==1B20			;INITIATE NEW FORK - PI FLAG
NEWJBF==1B21			;INITIATE NEW JOB - PI FLAG
PSIIF==1B22			;CHANNEL INTERRUPT REQUESTED IN FKINTB
PSIT1F==1B23			;TERMINAL CODE INTERRUPT, PHASE 1
PSIT2F==1B24			;TERMINAL CODE INTERRUPT, PHASE 2
SUSFKR==1B25			;SUSPEND FORK REQUEST
PSIWTF==1B26			;JOB WAS IN WAIT STATUS
PSILOB==1B27			;LOGOUT JOB REQUEST

;SCHEDULER CAUSES JOB TO BE STARTED HERE ON PI REQUEST
;SAVED PC IN PIPC
;PIMSK CONTAINS INTERRUPT REQUEST WORD

PIRQ:	MOVEM P,PIAC17
	MOVEI P,PIAC		;SAVE USER AC'S
	BLT P,PIAC+NSAC
	MOVE P,PIPDL		;SET UP LOCAL STACK
	MOVE 7,PIMSK		;INTERRUPT REQUEST WORD
	MOVE 6,FORKX
	SETZ 2,
	TLNE 7,PSIWTF		;WAS JOB IN WAIT STATUS?
	MOVE 2,FKOLDS(6)	;YES, GET OLD STATUS
	MOVEM 2,PIOLDS		;SAVE OLD STATUS, OR 0 IF WAS RUNNING
	TLNE 7,NEWFKF		;START NEW FORK?
	JRST FKSET		;YES
	TLNE 7,PSIT1F
	JRST PSIT1		;TERMINAL, PHASE 1
	TLNE 7,PSIT2F
	JRST PSIT2		;TERMINAL, PHASE 2
PSITR1:	TLNE 7,PSIIF+SUSFKR+PSILOB
	JRST PSII		;CHANNEL INTERRUPT SPEC. BY FKINTB
PIRQR:	CALL UNPIR		;LEAVE PI STATE
PSIDF1:	SKIPN 1,PIOLDS		;WAS RUNNING BEFORE PSI?
	JRST SCHED0		;YES
	JRST DISMSE		;NO, REPLACE ON WAIT LIST

UNPIR:	AOS INSKED		;ENTER SCHEDULER
	MOVE 1,[XWD PIAC,PAC]
	BLT 1,PAC+NSAC		;PUT AC'S BACK
	MOVE 1,PIAC17
	MOVEM 1,PAC+17
	MOVE 1,PIPC
	MOVEM 1,PPC
	MOVSI 1,200000
	MOVE 7,FORKX
	ANDCAM 1,FKINT(7)
	RET

PIPDL:	IOWD NPIPDL,PIPDB	;INTERRUPT ROUTINES LOCAL PDL

;REQUEST INTERRUPT
;AC1 CONTAINS INTERRUPT NUMBER
;AC2 CONTAINS FORK INDEX

	INTERN PSIRQ0,PSIRQF,PSIRQB,CHNSON,PSIR4,FORCTM,PSIRQ

PSIRQ0:	MOVE 2,FORKX		;REQUEST INTERRUPT IN CURRENT FORK
PSIRQF:	NOSKED			;REQUEST INTERRUPT, FORK IN AC2
	CALL PSIRQ
	OKSKED
	RET

;ENTERED FROM SCHEDULER REQUEST PROCESSOR

PSIRQ:	MOVE 1,BITS(1)
PSIRQB:	IORM 1,FKINTB(2)	;SET BIT IN INTERRUPT WAITING BUFFER
PSITQ:	MOVSI 1,400000+PSIIF	;REGULAR INTERRUPT FLAG
	IORM 1,FKINT(2)
	CAMN 2,FORKX		;FOR THIS FORK?
	RET			;YES
PSIR4:	HLRZ 1,FKPT(2)		;NO, GET STATUS OF FORK
	CAIL 1,NBP		;IN BAL SET, OR
	CAIN 1,GOLST		;ON GOLIST?
	JRST PSIR6		;YES
TTPS1:	AOS ISKED		;CAUSE CHECK OF WAITING FORKS
	RET

;SET NEW SCHED STATUS FOR PSI'D FORK

PSIR6:	PUSH P,7
	MOVEI 7,0(2)
	HLRZ 1,FKSTAT(7)	;CURRENT QUEUE
	CAIG 1,1		;HIGH ONES?
	JRST [	CALL NEWST1	;YES, REINIT
		JRST PSIR61]
	PUSH P,3
	PUSH P,4
	CALL NEWST5		;SET SHORT QUANTUM, HIGH PRIORITY
	POP P,4
	POP P,3
PSIR61:	MOVEI 2,0(7)
	POP P,7
	RET

;TERMINAL INTERRUPT
;PHASE ONE - CALLED FROM TERM SERVICE ROUTINES
; 2/ LINE NO.,   3/ INTERRUPT CODE
;SEND TO TOP FORK TO FIND PROPER DESTINATION

	INTERN TTPSRQ

TTPSRQ:	HLRZ 2,TTFORK(2)	;GET JOB USING THIS TTY
	ANDCMI 2,600000		;FLUSH EXTRANEOUS BITS
	HRRZ 2,JOBPT(2)		;GET INDEX OF TOP FORK
	MOVSI 1,1B18+PSIT1F	;PHASE ONE REQUEST
	IORM 1,FKINT(2)
	HRRM 3,FKINT(2)		;INTERRUPT CODE
	JRST PSIR4		;SET NEW STATUS

;ROUTINES TO HANDLE INTERRUPT CONDITIONS AS SPECIFIED BY BITS
;IN LEFT HALF OF FKINT

;TERMINAL INTERRUPT, PHASE ONE
;THIS CODE RUN IN TOP FORK ONLY

PSIT1:	MOVE 6,BITS(7)
	HLRZ 1,FORKN		;START WITH TOP FORK
	SETO 5,
	TDNE 6,FKPSIE(1)	;TERM CODE ON IN FORK?
	MOVEI 5,0(1)		;YES, REMEMBER FORK
	CALL PSIT1A		;LOOK AT ALL INFERIORS
	JUMPL 5,[ANDCAM 6,TTSPSI ;NOT FOUND, SO TURN OFF CODE
		SKIPL 2,CTRLTT
		ANDCAM 6,TTPSI(2)
		JRST PSITR1]
	HRRZ 2,SYSFK(5)		;GET SYSTEM INDEX OF FORK TO GET INTERPT
	CAMN 2,FORKX		;THIS FORK?
	JRST PSIT2		;YES, GO DIRECTLY TO PHASE TWO
	NOSKED
	HRRM 7,FKINT(2)		;NO, SETUP TO INTERRUPT PROPER FORK
	MOVSI 1,PSIT2F+400000	;PHASE TWO REQUEST FLAG
	IORM 1,FKINT(2)
	CALL PSIR4
	OKSKED
	JRST PSITR1

;SEARCH FORK STRUCTURE FOR FORK TO INTERRUPT

	INTERN PSIT1A

PSIT1A:	ADD 1,INFERP		;LOOK AT INFERIOR LIST
PSIT1B:	LDB 1,1			;GET NEXT IN LIST
	JUMPE 1,R		;RETURN AT END OF LIST
	TDNE 6,FKPSIE(1)	;FORK HAS CODE ENABLED?
	MOVEI 5,0(1)		;YES, REMEMBER IT
	HRLM 1,0(P)		;REMEMBER CURRENT FORK
	CALL PSIT1A		;CHECK INFERIORS
	HLRZ 1,0(P)		;RECOVER CURRENT
	ADD 1,PARALP		;DO PARALLELS
	JRST PSIT1B

;FORK STRUCTURE POINTERS

SUPERP:	POINT 12,FKPTRS,11	;SUPERIOR
PARALP:	POINT 12,FKPTRS,23	;PARALLEL
INFERP:	POINT 12,FKPTRS,35

;TERMINAL INTERRUPT, PHASE TWO

PSIT2:	MOVEI 1,0(7)
	CALL GETCHA
	LDB 2,2
	MOVE 1,BITS(2)		;AND SET BIT IN INT. WAITING WORD
	AND 1,PSICHM		;BUT ONLY FOR ENABLED CHANNELS
	IORM 1,PSIBW
	JRST PSII		;THEN GO PROCESS IT

;SUSPEND FORK REQUEST

PIRSFK:	MOVE 1,PIPC
	CALL PITEST		;NOW INTERRUPTABLE?
	JRST PIRSF1		;NO
	MOVEI 3,SUSWT		;SUSPENDED FORK TEST
PIRSK1:	MOVE 2,FORKX
	MOVSI 1,SUSFKR
	ANDCAM 1,FKINT(2)
	CALL UNPIR		;LEAVE INTERRUPT STATE
	IORM 1,FKINT(7)		;KEEP INTERRUPT STARTING BIT
	MOVEI 1,0(3)		;SUSWT OR FRZWT
	HRL 1,PIOLDS		;WITH OLD STATUS
	JRST DISMSE		;DISMISS

PIRSF1:	MOVE 7,FORKX
	MOVSI 1,SUSFKR		;TURN REQUEST BIT BACK ON
	IORM 1,FKINT(7)
	JRST PSIDFR		;AND SET DEFERRED INTERRUPTS

SUSWT:	JRST 0(4)		;SCHEDULER TEST FOR SUSPENDED FORK

;LOGOUT REQUEST

PIRLGO:	MOVE 1,PIPC
	CALL PITEST		;OK TO INTERRUPT?
	JRST [	MOVE 7,FORKX	;NO, REMEMBER REQUEST
		MOVSI 1,PSILOB
		IORM 1,FKINT(7)
		JRST PSIDFR]
	SETZM PIOLDS		;MAKE FORK RUNNABLE
	MOVEI 1,FLOGO
	EXCH 1,PIPC
	SKIPGE SLOWF
	JRST [	MOVEM 1,FPC	;IN USER MODE, SIMULATE JSYS
		JRST PIRQR]
	MOVE 2,PIAC17		;IN MON MODE, SIMULATE PUSHJ
	PUSH 2,1
	MOVEM 2,PIAC17
	JRST PIRQR

;PROCESS INTERRUPT(S) FOR THIS FORK AS SPECIFIED BY FKINTB

PSII:	MOVE 1,MJRST0		;NORMALIZE ALL DEFER TRAPS
	MOVEM 1,MJRSTF
	MOVE 1,INTDF0
	MOVEM 1,INTDFF
	TLNE 7,SUSFKR		;FORK SUSPENSION REQUEST?
	JRST PIRSFK		;YES
	TLNE 7,PSILOB		;LOGOUT REQUEST?
	JRST PIRLGO
	MOVE 2,FORKX
	MOVEI 1,0
	EXCH 1,FKINTB(2)	;RESET FKINTB TO 0
	MOVE 2,PSICHM		;USERS ENABLED CHANNELS
	IOR 2,CHNSON		;WITH ALWAYS ON CHANNELS
	IOR 2,SUPCHN		;WITH SUPERIOR RESERVED CHANNELS
	AND 1,2			;FLUSH DISABLED CHANNELS
	IORB 1,PSIBW		;SET BITS IN BREAK WAITING WORD
	JUMPE 1,PIRQR		;RETURN IF NO BREAKS WAITING
	MOVE 1,PIPC		;PROCESS PC
	CALL PITEST		;CAN PROCESS BE INTERRUPTED NOW?
	JRST PSIDFR		;NO, GO SETUP DEFERRED INTERRUPT
PSIS:	MOVE 1,PSIBW
	TDNE 1,MONCHN		;MONITOR RESERVED CHANNEL?
	JRST PSIMB		;YES
	AND 1,SUPCHN		;LOOK AT SUPERIOR RESERVED CHANS
	JUMPN 1,PSIN1		;TERMINATE IF ANY
	MOVE 1,PSIBW
	AND 1,CHNSON		;LOOK AT SPECIAL CHANNELS
	SKIPE PSISYS		;IF THIS PROCESS NOT TAKING PSI'S,
	JUMPN 1,PSIN1		;TERMINATE IT IF ANY SPECIALS
	ANDCM 1,PSICHM		;AND'ING WITH USER'S 'OFF' CHANNELS
	JUMPN 1,PSIN1		;TERMINATE CAUSE CHANNEL NOT ACTIVE
	SKIPE PSISYS		;PSI SYSTEM ON?
	JRST PIRQR		;NO
	SKIPN LEVCHN		;THIS PROCESS TAKING INTERRUPTS?
	JRST PSIN1		;NO, GO TRANSMIT THE PSI
	MOVE 1,PSIBW		;FIND HIGHEST PRIORITY INTERRUPT
	MOVEI 2,0		;NOW WAITING
	MOVSI 3,1
PSIS1:	JUMPL 1,PSIS2		;THIS CHANNEL HAS WAITING BREAK?
PSIS4:	LSH 1,1			;NO, SHIFT TO NEXT CHANNEL
	ADDI 2,1		;COUNT CHANNEL NUMBER
	JUMPN 1,PSIS1		;KEEP LOOKING IF ANY BITS LEFT

;AC3 NOW CONTAINS LEVEL OF HIGHEST PRIORITY INTERRUPT FOUND
;AC5 CONTAINS CORRESPONDING CHANNEL NUMBER

	JUMPE 3,PSID1		;NO LEVEL ASSIGNED? GO XMIT INTERRUPT
	CAILE 3,NPILEV		;LEGAL LEVEL?
	JRST PSID2		;NO, SPECIAL ACTION
	MOVE 1,BITS(3)
	CAMG 1,PSIBIP		;OK TO BREAK ON THIS LEVEL?
	JRST PIRQR		;NO, EQUAL OR HIGHER LEVEL IN PROGRESS
	IORM 1,PSIBIP		;YES, REMEMBER  BREAK THIS LEVEL
	HRRZ 1,LEVCHN		;GET ADR OF USER'S CHANNEL TABLE
	ADDI 1,0(5)		;COMPUTE ADR OF USER'S CHANNEL WORD
	UMOVE 1,0(1)		;GET ADR OF USER'S INT ROUTINE
	HRLI 1,UMODF		;USER MODE ON, OTHER FLAGS OFF
	EXCH 1,PIPC		;SET TO START THERE, GET OLD PC
	TLNE 1,UMODF		;WAS IN USER MODE?
	JRST PSIS5		;YES

;SPECIAL ROUTINE TO SAVE STATE OF INTERRUPTED MONITOR
;ROUTINE

	MOVS 2,BITS(3)		;NO, REMEMBER MONITOR INTERRUPT
	IORM 2,PSIBIP		;IN RH OF BIP WORD
	MOVE 7,PSIPT		;STORAGE STACK POINTER
	HLRE 6,7		;SEE IF ENOUGH ROOM
	MOVN 6,6		;GET POSITIVE COUNT
	CAIGE 6,NUPDL+<EUACB-UACB>+30
	BUG(HLT,<PSI STORAGE STACK OVERFLOW>)
	MOVE 10,7		;SAVE POINTER
	PUSH 7,1
	PUSH 7,40
	PUSH 7,60
	PUSH 7,MPP
	PUSH 7,FPC
	PUSH 7,PIOLDS
	PUSH 7,XMENTR
	MOVSI 6,UPDL		;STORE ENTIRE MONITOR STACK
	HRRI 6,1(7)
	ADD 7,[XWD NUPDL,NUPDL]
	BLT 6,0(7)
	MOVSI 1,PIAC		;STORE CURRENT MONITOR AC'S
	HRRI 1,1(7)		;NOW LIVING IN PIAC
	ADD 7,[XWD 20,20]
	BLT 1,0(7)
	HRRZ 1,ACBAS		;STORE ALL AC BLOCKS IN USE
	HRRZ 2,ACBAS1
	SUBI 1,-1(2)		;COMPUTE NUMBER OF BLOCKS IN USE
	LSH 2,^D18+4
	MOVE 4,2
	HRRI 2,1(7)
	LSH 1,4
	HRLI 1,0(1)		;NUMBER OF WORDS BOTH HALFS
	ADD 7,1
	BLT 2,0(7)
	PUSH 7,1		;SAVE COUNT FOR DEBRK
	PUSH 7,ACBAS		;AND CURRENT ACBAS
	HRRI 4,PIAC		;RECOVER USER AC'S AT TIME OF MON CALL
	BLT 4,PIAC+17
	MOVE 1,UPDL		;USER PC AT MONITOR CALL
	PUSH 7,10		;PSI STACK BEFORE ALL THIS PUSHING
	PUSH 7,1
	MOVEM 7,PSIPT
	TLZ 1,UMODF		;SO HE CAN TELL IT WAS MON INTERRUPT
	SETOM SLOWF

PSIS5:	SETZM PIOLDS
	HLRZ 2,LEVCHN		;GET ADR OF USER'S LEVEL TABLE
	ADDI 2,-1(3)		;COMPUTE ADR OF USER'S LEVEL WORD
	UMOVE 2,0(2)		;GET ADR OF PC WORD FOR THIS LEVEL
	TRNN 2,777760		;ADDRESS IS AC?
	MOVEM 1,PIAC(2)		;YES, STRANGE BUT ALLOW IT
	TRNE 2,777760		;NORMALLY,
	UMOVEM 1,0(2)		;STORE BREAK PC IN USER'S MEMORY
PSID3:	MOVE 1,BITS(5)		;CLEAR WAITING BREAK BIT FOR THIS CHANNEL
	ANDCAM 1,PSIBW
	JRST PIRQR		;TO USER

PSIS2:	HRRZ 4,LEVCHN		;GET ADR OF USER'S CHANNEL TABLE
	ADDI 4,0(2)		;COMPUTE ADR OF USER'S CHANNEL WORD
	XCTUU [HLRZ 4,0(4)]	;GET LEVEL NUMBER FOR THIS CHANNEL
	CAIG 3,0(4)		;OLD LEVEL GREATER THAN CURRENT?
	JRST PSIS4		;NO
	MOVEI 3,0(4)		;YES, REMEMBER NEW LEVEL
	MOVEI 5,0(2)		;AND CHANNEL NUMBER
	JRST PSIS4		;RESUME SCAN

;SPECIAL ACTION (NOT LEVEL NUMBER) IN LH OF CHN+C

PSID2:	JRST PSID3		;IGNORE INTERRUPT

;MONITOR ROUTINE IS SHORTSTOPPING INTERRUPTS - SIMULATE  JSYS MONBK

PSIMB:	HRRZ 1,MONBK		;ROUTINE ADDRESS
	EXCH 1,PIPC		;GET OLD PC
	SETZM PIOLDS
	HLRZ 2,MONBK		;RET LOC
	MOVEM 1,0(2)		;STORE RETURN
	JRST PIRQR

;XMIT INTERRUPT TO SUPERIOR FORK

PSIT:	HRRZ 2,FORKN
	MOVE 2,FKPTRS(2)	;POINTERS RELATIVE TO FORK
	LSH 2,-^D24		;SUPERIOR FORK POINTER
	HRRZ 2,SYSFK(2)		;SYSTEM FORK INDEX
	JRST PSIRQF		;REQUEST INTERRUPT

;THIS FORK WON'T TAKE INTERRUPT, DISMISS IT AND RECORD WHY

PSID1:	MOVEI 2,0(5)		;CHANNEL WITH NO LEVEL ASSIGNED
	JRST PSIN2

PSIN1:	MOVE 1,PSIBW		;INTERRUPTS OFF OR NO LEVCHN
	JFFO 1,.+1		;CALCULATE CHANNEL NUMBER
PSIN2:	MOVEM 2,FORCTC		;SAVE CHANNEL NUMBER FOR STATUS
	MOVE 1,BITS(2)		;JUST ONE CHANNEL AT A TIME
	ANDCAM 1,PSIBW		;RESET WAITING BIT
	CALL FKTMI		;GIVE FORK TERM INTERRUPT
	MOVEI 3,FRZWT		;FORK FROZEN STATE TEST
	MOVE 1,CAPENB
	TLNE 1,(1B17)		;SUPERIOR WANTS FROZEN STEAD HALT?
	JRST PIRSK1		;YES, GO FREEZE
	CALL UNPIR		;LEAVE PI STATE, MOVE AC'S ETC.
	MOVE P,PI7P
	MOVEI 1,FORCTM
	JRST DISMSE		;THIS ONE IS BEING DISMISSED

FORCTM:	JRST 0(4)		;SCHEDULER TEST FOR FORCED TERM FORK

;INTERRUPT SUPERIOR FORK ON TERMINATION

FKTMI:	PUSH P,1
	HRRZ 1,FORKN
	SKIPN 1
	SKIPA 1,[^D35]		;TERMINATING TOP FORK, GIVE CH 35
	MOVEI 1,^D19		;19 IS FORK TERMINATED
	CALL PSIT		;TRANSMIT IT
	POP P,1
	RET

	INTERN GETCHA

GETCHA:	MOVEI 2,0(1)
	IDIVI 2,6
	ADDI 2,PSICHA
	HLL 2,CH6TAB(3)
	RET

;DEFERRED INTERRUPT LOGIC
;SET TRAPS TO RECHECK INTERRUPTS WHEN STATE CHANGES

PSIDFR:	MOVE 1,MJRST1
	MOVEM 1,MJRSTF
	MOVE 1,INTDF1
	MOVEM 1,INTDFF
	CALL UNPIR		;LEAVE BREAK STARTING STATE
	IORM 1,FKINT(7)		;BUT LEAVE PENDING BIT
	JRST PSIDF1		;RESUME

MJRST1:	JRSTF @[PSISV0]
INTDF1:	JSYS PSISV1

PSISV1:	XWD PIPC,.+1
	SOS INTDF
	JRSTF @[PSISV2]

PSISV0:	MOVEM 1,PIPC		;SAVE AC1
	MOVE 1,FPC		;FPC NOW CONTAINS USER'S PC
	EXCH 1,PIPC
PSISV2:	MOVEM P,PIAC17		;SAVE USER'S AC17
	MOVEI P,PIAC		;AND AC'S 0-NSAC
	BLT P,PIAC+NSAC
	MOVE P,PIPDL		;RESTORE INTERRUPT STARTING STATE
	SETZM PIOLDS
PSISV3:	MOVE 2,FORKX
	MOVE 7,FKINT(2)
	JRST PSII		;ENTER MAIN SEQUENCE

;TEST FOR IMMEDIATE OR DEFERRED INTERRUPT
;SKIP => IMMEDIATE
;NOSKIP => DEFERRED
;CALLED WITH TEST USER PC IN AC1

PITEST:	TLNE 1,UMODF		;USER MODE?
	JRST RSKP		;YES, IMMEDIATE
	SKIPL SLOWF		;NO, SLOW CODE?
	SKIPL INTDF		;YES, INTERRUPTABLE
	RET			;NO, DEFER
	SKIPN NSKED		;IN CASE NOSKED W/O NOINT
	SKIPL TRAPC		;IN PAGER TRAP, OR
	RET			;YES, DEFER
	JRST RSKP		;IMMEDIATE

;DEBREAK

	INTERN .DEBRK

.DEBRK:	SKIPN PSIBIP		;ANY BREAKS IN PROGRESS?
	XCT MJRSTF		;NO, ACTS AS NOP
	MOVEM 1,TW1		;SAVE USER AC1,2
	MOVEM 2,TW2
	MOVE 2,FORKX
	MOVSI 1,200000
	IORM 1,FKINT(2)		;SET INTERRUPT STARTING BIT
	MOVE 2,TW2
	MOVE 1,TW1
	MOVEM P,PIAC17		;ENTER INTERRUPT STARTING STATE
	MOVEI P,PIAC
	BLT P,PIAC+NSAC
	MOVE P,PIPDL
	SETZM PIOLDS
PSIDBK:	MOVE 2,PSIBIP		;BREAKS NOW IN PROGRESS
	JFFO 2,.+2		;FIND HIGHEST ONE
	JRST 4,.		;IMPOSSIBLE
	HLRZ 1,LEVCHN		;COMPUTE ADDRESS OF RETURN PC
	ADDI 1,-1(3)
	UMOVE 1,0(1)
	TRNN 1,777760		;ADDRESS IS AC?
	SKIPA 1,PIAC(1)		;YES
	UMOVE 1,0(1)		;GET RETURN PC FROM USER MEMORY
	MOVS 2,BITS(3)
	TDNE 2,PSIBIP		;WAS THIS MONITOR INTERRUPT?
	JRST PSIS7		;YES, GO UNWIND
PSIS8:	TLZ 1,7637		;FLUSH TROUBLESOME BITS
	TLO 1,UMODF		;MAKE SURE USER MODE IS ON
	MOVEM 1,PIPC		;SET TO DEBREAK AT THAT ADDRESS
PSIS6:	MOVE 1,BITS(3)
	ANDCAM 1,PSIBIP		;CLEAR BIP THIS LEVEL
	JRST PSISV3		;GO CHECK FOR OTHER INTERRUPTS AND RETURN

PSIS7:	ANDCAM 2,PSIBIP		;CLEAR MON BREAK FLAG FOR THIS LEVEL
	MOVE 7,PSIPT
	POP 7,4			;PC GIVEN TO USER
	POP 7,PSIPT		;TOP OF THIS BLOCK OF PSI STORAGE
	TLON 1,UMODF		;IF IT WAS DIDDLED AT ALL,
	CAME 1,4
	JRST PSIS8		;DON'T RESUME MON ROUTINE
	POP 7,2
	MOVEM 2,ACBAS
	SETACB 2
	POP 7,4
	SUB 7,4
	HRRZ 5,ACBAS1
	LSH 5,4
	MOVE 2,5		;SAVE ACB ADDRESS
	HRLI 5,1(7)
	ADDI 4,0(5)
	BLT 5,-1(4)		;RESTORE AC BLOCKS
	MOVSI 5,PIAC		;PUT USER CURRENT AC'S INTO TOP BLOCK
	HRRI 5,0(2)
	BLT 5,17(2)
	SUB 7,[XWD 20,20]
	MOVEI 2,PIAC
	HRLI 2,1(7)
	BLT 2,PIAC+17		;RESTORE MONITOR AC'S
	SUB 7,[XWD NUPDL,NUPDL]
	MOVEI 2,UPDL
	HRLI 2,1(7)
	BLT 2,UPDL+NUPDL-1	;RESTORE STACK
	POP 7,XMENTR
	POP 7,PIOLDS
	POP 7,FPC
	POP 7,MPP
	POP 7,60
	POP 7,40
	POP 7,PIPC		;ACTUAL MON INTERRUPT PC
	SETZM SLOWF
	SETOM INTDF
	JRST PSIS6		;NOW DEBRK

;10 NOV 71, 1153:

;TENEX PAGE MANAGEMENT MODULE - D. MURPHY

	INTERN ASOFN,RELOFN,SETMPG,READB,MRPACS,MSPACS,MRMAP,NOFN
	INTERN MLKPG,MULKPG,FPTA,MRPT,SETPT,DISKP,DRUMP,RWX,SWPCOR
	INTERN DDMP,DELOFN,MONCOR,COPYB,SPT,SPTH,CORWB,SPC1,SWPZPG
	INTERN MULKCR,MULKMP,CST0,CST1,CST2,CST3

	EXTERN GDSTX,DRMASN,DSKASN,DASDRM,DEDSK,DRMFRE
	EXTERN SWPERR,JFNOFN,OFNJFN,JFNDCR,OPNX16,OPNX9,OPNX10

;PARAMETERS

DISKP:	1		;DISK ON SYSTEM
DRUMP:	1<IFNDEF DRMCHN,<-1>> ;1 = DRUM AVAIL, 0 = USE DISK, -1 = USE NOTHING
NOFN==400		;NUMBER OF OFN SLOTS
SPTM==17777		;MASK FOR SPT INDICES
THAWB==1B20		;THAW BIT
FILWB==1B19		;FILE WRITE BIT
SPTLKB==1B22		;LH OF SPTH(OFN), XB IN USE BY DDMP
NEWFB==1B33		;NEW FILE (OR FILE PAGE) BIT
DRPERM==1B23		;PERMANENT ON DRUM PAGE
BWRBIT==1B31		;WRITTEN (CHANGED) FROM HOME COPY
CORWB==1B27		;CHANGED IN CORE, SET BY PAGER
PLKV==1B27		;FOR LOCK VALUE IN CST1
BP1==^D10		;BIT POSITION OF PROCESS 0 IN CST0
DSKSWB==1B20		;SWAP TO DISK REQUESTED

;BITS IN MAP WORD

SHRBIT==1B19		;SHARE POINTER
INDBIT==1B18		;INDIRECT POINTER

PGR==24
PGR71=71		;PAGER RELOAD REG (PT.PSB)
PGR72=72		;PAGER RELOAD REG (AGE.PROCESS BIT)

DEFINE MONCLR
<	CONO PGR,1>

LS SPTC,1		;COUNT OF SPT (EXCLUDING OFN) ENTRIES IN SPT
LS NOF,1		;COUNT OF ENTRIES IN OFN PART OF SPT
LS FRESPT,1		;FREE SPT LIST
LS MAXSPL,1		;MAX NUMBER OF PROBES TO SPTH
LS MMSPTN,1		;OFN OF MONITOR MAP
GS LOKPGS,1		;COUNT OF LOCKED PAGES, VIA MLKPG
GS LOKSUM,1		;NET NUMBER OF LOCKS, MLKPG-MULKPG
GS MAXLOK,1		;MAX NUMBER OF PAGES TO BE LOCKED
GS NXTDMP,1		;FLAG TO CAUSE DDMP ACTION
GS DDTIME,1		;TIME NEXT DDMP DUE
LS IOIP,1		;SWAP WRITES IN PROGRESS
GS DRMIN0,1		;MIN DRUM SPACE

SPC0:	EXP <SSPT-NOFN>*5/6
SPC1:	EXP SSPT-NOFN-40

;INITIALIZATION, SPT, CST, ETC.

PGRINI:	SETZM SPTC
	SETZM NOF
	SETZM MAXSPL
	MOVEI 1,SPT+NOFN
	MOVEI 2,SSPT-NOFN
	CALL ILIST		;MAKE LIST OF FREE SPT ENTRIES
	MOVEM 1,FRESPT
	SETZM SPTH
	MOVE 1,[XWD SPTH,SPTH+1]
	BLT 1,SPTH+NOFN-1	;ZERO OUT SPTH
	CALL ASSPT		;ASSIGN SPT SLOT FOR MMAP
	MOVE 2,[XWD 1B31,MMAP/1000]
	MOVEM 2,SPT(1)
	MOVEM 1,MMSPTN
	MOVSI 2,0(1)
	SETZ 1,			;START WITH CORE PAGE 0
	MOVSI 3,400000
	MOVSI 4,RWXB
PGRI1:	MOVEM 1,MMAP(2)		;MAKE MAPPED MON EQUIVALENT TO UNMAPPED
	HLLM 4,MMAP(2)		;PRIVATE POINTER, ALL ACCESS
	MOVEM 3,CST0(1)		;LEGAL AGE WORD
	MOVEM 1,CST1(1)		;BACKUP ADDRESS IS SELF
	MOVEM 2,CST2(1)		;OFN.PN
	ADDI 1,1
	CAMGE 1,SWPCOR		;FILL TO END OF RES MON
	AOJA 2,PGRI1
	MOVSI 4,WRITEB
	ANDCAM 4,MMAP+1		;PROTECT JSYS TABLE
	MOVEI 3,P2+777
	LSH 3,-^D9		;FIRST PAGE OF RES MON
PGRI5:	CAIGE 3,100		;DON'T PROTECT PAGES ALWAYS MAPPED
	ANDCAM 4,MMAP(3)	;WRITE PROTECT RES MON
	ADDI 3,2
	CAMGE 3,MONCOR		;MON WILL BE WRITE PROTECTED IF
	SOJA 3,PGRI5		;MAPRESMON FLOP MANUALLY TURNED ON

	ADDI 2,MMAP+2
	HRLI 2,-1(2)
	SETZM -1(2)
	BLT 2,MMAP+PJMPG-1	;ZERO REMAINDER OF MON MAP
	SETZM TOTRC
	SETZM NRPLQ
	CONO APR,1B23		;MAKE SURE NXM OFF
	MOVE 1,SWPCOR
	MOVE 2,[XWD RPLQ,RPLQ]
	MOVEM 2,RPLQ		;REPLACEMENT QUEUE EMPTY
PGRI2:	SETZM CST1(1)		;CLEAR CST ENTRIES
	SETZM CST2(1)
	SETZM CST3(1)
	MOVEI 2,0(1)		;CHECK FOR MEMORY EXISTANT
	LSH 2,^D9
	MOVE 0(2)		;MAY GET NXM
	CONSZ APR,1B23		;NXM?
	JRST PGRI3		;YES
	SETZM CST0(1)		;NO, PAGE EXISTS
	JSP 4,ONRQ		;PUT PAGE ON REPLACABLE QUEUE
	PIOFF
	AOS TOTRC		;COUNT PAGES OF CORE FOUND

PGRI4:	CAIGE 1,MAXCOR-1		;CHECK 256K
	AOJA 1,PGRI2
	MOVE 1,TOTRC
	SUBI 1,3
	MOVEM 1,MAXNR		;MAX VALUE OF SUMNR
	SUBI 1,6
	MOVEM 1,NPMAX
	ASH 1,-1
	MOVEM 1,TOTRC2
	ASH 1,-1		;1/4 REAL CORE
	CAIGE 1,10		;OR 10, WHICHEVER IS LARGER
	MOVEI 1,10
	MOVEM 1,MAXLOK		;IS MAX NUMBER PAGES TO LOCK
	MOVE 1,NPMAX
	SUBI 1,40		;LOWER MAX FOR FORK WILL BE NPMAX-40
	CAIL 1,40		;UNLESS THATS LESS THAN 40, IN WHICH
	MOVEM 1,TOTRC2		;CASE IT WILL BE NPMAX/2
	MOVEI 1,10
	MOVEM 1,NRPMIN		;MAINTAIN NRPLQ AT THIS LEVEL
	MOVE 1,TOTRC
	LSH 1,-3
	CAIL 1,NBP
	MOVEI 1,NBP-1
	MOVEM 1,MAXBP
	MOVEI 1,NDST		;NUMBER OF PAGES ON DRUM
	IDIVI 1,10
	MOVEM 1,DRMIN0		;TAKE SPECIAL ACTION IF DRUM .GE. 7/8
	SETZM PGR71
	MOVSI 1,400000
	MOVEM 1,PGR72
PGRRST:	CONO PGR,6
	CONO PGR,0		;TURN ON PAGER
	DATAO APR,[XWD 776776,0]	;RELOC AND PROTECT STILL WORKS
	RET

PGRI3:	CONO APR,1B23		;TURN OFF NXM FLAG
	MOVSI 2,010000
	MOVEM 2,CST0(1)
	JRST PGRI4

;BOUNDARIES SET BY POSTLD

MONCOR:	0			;NUMBER PAGES OF RES MON
SWPCOR:	0			;FIRST PAGE OF REAL CORE FOR SWAPPING

;RESTART SWAPPER - REINITIATE IO OPERATIONS IN PROGRESS AT TIME OF CRASH

SWPRST:	SETZM IOIP
	MOVE 6,SWPCOR		;SCAN CST AND CHECK STATE OF PAGES
SWPRS1:	LDB 1,[POINT 6,CST0(6),5] ;GET STATE CODE
	CAIN 1,06		;READ IN PROGRESS?
	JRST SWPRSR		;YES, GO RESTART IT
	CAIN 1,04		;WRITE?
	JRST SWPRSW		;YES
SWPRS2:	CAIGE 6,MAXCOR-1	;LOOKED AT ALL PAGES?
	AOJA 6,SWPRS1		;NO
	RET

SWPRSW:	MOVSI 1,DWRBIT		;WRITE OPERATION
	AOSA IOIP		;COUNT WRITES IN PROGRESS
SWPRSR:	SETZ 1,			;READ OPERATION
	HRRI 1,0(6)
	MOVE 2,CST1(6)		;BACKUP ADDRESS
	TLNE 2,10		;DISK?
	JRST SWPRS3		;YES
	TLNN 2,16		;DRUM?
	BUG(HLT,<ILLEGAL ADDRESS IN CST1 ENTRY, CAN'T RESTART>)
	CALL DRMIO
	JRST SWPRS2

SWPRS3:	CALL DSKIO
	JRST SWPRS2

;PERIODIC ROUTINE TO TRICKLE PAGES TO DISK

	EXTERN CVDSK,UDSKIO

DDMP:	MOVE 1,TODCLK
	CAMGE 1,DDTIME		;TIME YET?
	RET			;NO
	SKIPE DISKP		;DISK ON SYSTEM, AND
	SKIPE NXTDMP		;DUMP REQUESTED?
	RET			;NO
	ADDI 1,^D30000		;NEXT ONE DUE IN 30 SEC.
	MOVEM 1,DDTIME
	SETZ 0,			;CLEAR FLAGS
	MOVE 1,DRMFRE
	CAMGE 1,DRMIN0		;ENOUGH DRUM SPACE?
	TLO 1,(1B0)		;NO, TAKE SPECIAL ACTION
	AOS NXTDMP		;TO DETECT REQUESTS DURING ROUTINE
	MOVE 11,FORKX		;CONSTRUCT HANDLE FOR DDPG2
	HRLZ 11,FKPGS(11)
	HRRI 11,DDPG2		;WILL BE USED LATER
	MOVSI 10,-NOFN		;PREPARE TO SCAN ALL OFN'S
	AOBJN 10,.+1		;0 NOT USED
DDMP9:	NOSKED
	MOVE 1,SPTH(10)		;GET HASH WORD FOR THIS OFN
	JUMPLE 1,DDMP1S		;NOT IN USE
	MOVE 1,SPT(10)		;IN USE, GET CURRENT ADR
	TLNE 1,10		;XB ON DISK?
	JRST DDMP1E		;FORGET IT
	MOVSI 2,SPTLKB
	IORM 2,SPTH(10)		;LOCK OFN AGAINST RELEASE
	MOVEI 1,0(10)		;MAP THE XB
	MOVE 2,[XWD RWX,DDPG1A]
	CALL SETMPG
	SETZ 6,
	CALL DDMPXA		;GET XB DISK ADDRESS
	PUSH P,6		;SAVE WRITE FLAG FOR XB
	CAIGE 7,DST+NDST	;IN DST?
	CAIGE 7,DST
	JRST .+3		;NO
	MOVSI 3,BWRBIT		;YES, CLEAR BACKUP WRITE BIT
	ANDCAM 3,0(7)
	OKSKED
	MOVE 2,[XWD DDPG2A,DDPG2A+1]
	SETZM DDPG2A		;ZERO A PAGE TO GET THE BACKUP XB
	BLT 2,DDPG2A+777
	MOVSI 7,-1000		;SCAN ALL WORDS OF XB
DDMP8:	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP61		;QUICK CHECK FOR NULL
	NOSKED
DDMP81:	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP6		;NOT IN USE
	TLNN 1,SHRBIT		;SHARE POINTER?
	JRST DDMP4		;NO, PRIVATE
	LSH 1,-^D9		;GET SPT NUMBER
	ANDI 1,SPTM
	MOVE 1,SPT(1)
	TLZ 1,-1B31		;FLUSH SHARE COUNT
	TLNN 1,16		;CHECK FOR UNASSIGNED
	TLNN 1,1
	JRST DDMP4
	JRST DDBAD

DDMP6:	OKSKED
	JRST DDMP61

DDMP1E:	TLNE 1,-1B31		;SHARE COUNT 0?
	JRST DDMP1S		;NO
	SETOM SPTH(10)		;YES, RELEASE OFN
	SOS NOF
DDMP1S:	OKSKED
	JRST DDMP1

DDMPXA:	MOVE 1,SPT(10)		;SET ABOUT FINDING DISK ADDRESS
	TLNE 1,17
	JRST DDMPX1		;IN DST
	MOVE 7,CST2(1)
	CAIE 7,0(10)		;ALL CONSISTENT?
	JRST DDBAD1		;NO
	MOVE 7,CST0(1)		;GET CORE WRITE BIT
	TLNE 7,CORWB		;WRITTEN IN CORE?
	SETO 6,			;YES
	MOVEI 7,CST1(1)		;IF IN CST, REMEMBER WHERE
DDMPX2:	MOVE 1,0(7)
	TLNE 1,10		;DISK?
	RET			;YES, DONE
DDMPX1:	MOVE 2,1
	CALL GDSTX
	MOVE 7,DST(2)		;GET DRUM WRITE BIT
	TLNE 7,BWRBIT		;WRITTEN ON DRUM?
	SETO 6,			;YES
	MOVEI 7,DST(2)		;REMEMBER WHERE DISK ADDRESS IS
	JRST DDMPX2

DDMP4:	TLNE 1,617700		;ANY STRANGE BITS?
	JRST DDBAD		;YES, SKIP IT
	TLNN 1,10		;PAGE NOW ON DISK?
	JRST DDMP5		;NO
	JRST DDMP3A		;YES, ALL SET

DDMP3:	TLNE 1,NEWFB		;NEW ADDRESS?
	MOVES DDPG1A(7)		;YES, CAUSE XB TO BE WRITTEN AGAIN
DDMP3A:	OKSKED
	TLNN 1,10		;JUST MAKE SURE WE HAVE DISK ADR
	JRST DDBAD
	MOVEM 1,DDPG2A(7)	;STORE DISK ADDRESS IS XB COPY
	LDB 1,[POINT 12,DDPG1A(7),13]	;GET ACCESS BITS FROM ORIG PTR
	DPB 1,[POINT 14,DDPG2A(7),13]	;STORE THEM IN XB COPY
DDMP61:	AOBJN 7,DDMP8		;SCAN OVER WORDS IN XB
DDMPXB:	NOSKED
	POP P,1			;GET XB WRITE FLAG
	JUMPE 1,DDMPX3		;DON'T WRITE XB IF NOT CHANGED
	MOVE 1,11		;GET ID OF COPY PAGE
	CALL MLKPG		;LOCK THE PAGE
	PUSH P,1		;SAVE CORE PAGE NUMBER
	CALL DDMPXA		;GET XB DISK ADDRESS
	MOVE 2,[1B14+1000]	;DISK IO CONTROL WORD, WRITE+1000 WORDS
	TLNN 1,NEWFB		;NEW FILE BIT?
	TLO 2,(1B15)		;NO, DO COMPARE CLASS
	TLZE 1,NEWFB		;CLEAR NEW FILE BIT
	MOVEM 1,0(7)
	OKSKED
	PUSH P,2
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,2
	LDB 3,[POINT 9,SPTH(10),13]	;GET CLASS
	DPB 3,[POINT 9,2,24]	;IN CONTROL WORD
	POP P,3			;CORE PAGE NUMBER
	LSH 3,^D9
	CALL UDSKIO		;OPERATE DISK
	AOS DSKWR		;COUNT OPERATIONS
	MOVE 6,1		;SAVE ERROR BITS
	MOVE 1,11
	CALL MULKPG		;UNLOCK PAGE
	JUMPN 6,.+1		;NON-ZERO MEANS ERRORS
	NOSKED
DDMPX3:	MOVE 1,DDPG1A		;MAKE SURE XB IN CORE BEFORE UNMAPPING
	SETZ 1,
	MOVEI 2,DDPG1A
	CALL SETMPG		;UNMAP XB
	MOVSI 2,SPTLKB
	ANDCAM 2,SPTH(10)	;UNLOCK OFN
	OKSKED
DDMP1:	AOBJN 10,DDMP9		;COUNT OFN'S
	MOVNS NXTDMP		;RESET IF NO INTERVENING REQUESTS
	MOVSI 1,1
	ADDM 1,CGFLG		;INSIST ON GC
	RET

DDMP5:	TLNN 1,17		;IN CORE?
	JRST DDMP52		;YES
	MOVE 2,1		;ON DRUM, GET DST WORD
	CALL GDSTX
	MOVE 1,DST(2)
	TLNN 1,BWRBIT		;CHANGED FROM BACKUP?
	JUMPGE 0,DDMP3		;NO, IGNORE IF NOT LOW ON DRUM SPACE
	MOVE 1,DDPG1A(7)	;GET PAGE SWAPPED IN
	TLNE 1,SHRBIT
	JRST DDMP51		;SHARE POINTER, GET SPTN
	MOVSI 1,0(10)		;CONSTRUCT OFN.PN
	HRRI 1,0(7)
DDMP53:	PUSH P,7
	CALL SWPINW		;SWAP IN PAGE AND WAIT
	POP P,7
	JRST DDMP81		;NOW PAGE IS IN CORE

DDMP51:	LSH 1,-^D9		;GET SPTN
	ANDI 1,SPTM
	JRST DDMP53

DDMP52:	TRNE 1,-MAXCOR		;LIKELY PAGE?
	JRST DDBAD		;NO
	MOVSI 6,400000		;FLAG TO NOTE IF WRITING NEEDED
	AND 6,0			;INIT TO DRUM SPACE FLAG
	MOVE 2,CST0(1)
	TLNE 2,CORWB		;PAGE WRITTEN WHILE IN CORE?
	SETO 6,			;YES
	MOVE 2,CST1(1)		;GET BACKUP ADR
	TLNE 2,10		;DISK?
	JRST DDMP54		;YES
	CALL GDSTX
	MOVE 2,DST(2)		;GET NEXT BACKUP ADR
	TLNE 2,BWRBIT		;CHANGED ON DRUM?
	SETO 6,			;YES
DDMP54:	JUMPE 6,DDMP55		;DISK ADR NOW IN 2, WRITING NEEDED?
	PUSH P,7
	MOVE 3,CST0(1)
	TLNN 3,700000		;IF AGE OK, LEAVE IT ALONE
	CALL AGESET		;YES
	POP P,7
	MOVSI 3,DSKSWB
	IORB 3,CST3(1)		;REQUEST DISK SWAP AT NEXT SWAP TIME
	HLRZ 3,3		;GET PROCESS ASSMT
	ANDI 3,7777
	CAME 3,FORKX		;ASSIGNED HERE?
	JRST DDMP55		;NO
	MOVSI 6,7777
	IORM 6,CST3(1)		;DEASSIGN
	SOS FKWSP(3)
	AOS CGFLG		;NOTE GARBAGE
DDMP55:	MOVE 1,2
	JRST DDMP3

;LOSSAGE PRINTOUT

DDBAD1:	POP P,1
DDBAD:	POP P,1			;FLUSH JUNK
	SETZM NSKED
	HRROI 1,[ASCIZ /
*****BAD INDEX BLOCK, OFN /]
	PSOUT
	MOVEI 1,101
	MOVEI 2,0(10)
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 1,EOL
	PBOUT
	JRST DDMP1

;ASSIGN OFN
; AC1/ 14-35 INDEX BLOCK FILE ADDRESS (DISK, DRUM OR CORE)
;       5-13 CLASS FIELD (IF DISK)
;          1 WRITE BIT
;          2 THAWED BIT
;	   3 NEW FILE BIT
;RETURN SKIP WITH OFN IN AC1 IF PROPER OPENING
;RETURN NO-SKIP IF ILLEGAL SHARED OPENING (ILLEGAL CONFIGURATION
;      OF THAWED AND WRITE BITS)

ASOFN:	TLNN 1,10		;DISK?
	JRST [	SKIPE DISKP	;NO, DISK ON SYSTEM?
		RET		;YES, MUST BE DISK ADDRESS
		JRST .+1]	;NO, ACCEPT OTHER ADDRESSES
	NOSKED
	PUSH P,1
	TLZ 1,-1B31		;FLUSH CLASS AND BITS
	MOVE 6,1
	MOVE 4,MAXSPL		;MAX NUMBER OF PROBES INTO SPTH
	SETO 5,
	SETZ 1,			;START SEARCH WITH 0

ASOF1:	ADDI 1,1		;LOOK LINEARLY
	MOVEI 3,0(1)

REPEAT 0,<			;THIS IS HASH LOOKUP NOT CURRENTLY USED
	IMUL 1,[5654123]	;HASH INDEX BLOCK ADDRESS
	HLRZS 3,1		;USE LEFT HALF
	ANDI 3,NOFN-1		;MAX NUMBER OPEN FILES
	JUMPE 3,ASOF1		;DON'T USE SLOT 0
>
	MOVE 2,SPTH(3)		;GET ENTRY
	JUMPLE 2,ASOF2		;0 IS FREE, -1 IS DELETED
	TLZ 2,-1B31		;FLUSH BITS
	CAMN 2,6		;COMPARE ADDRESSES
	JRST ASOF3		;FOUND
ASOF7:	SOJG 4,ASOF1		;COUNT TRYS AND PROBE AGAIN
	JUMPGE 5,ASOF6		;NOT FOUND. DELETED ENTRY ENCOUNTERED?
	AOS MAXSPL		;NO, INCREASE MAX LOOK COUNT
	JRST ASOF1		;KEEP LOOKING FOR USABLE SLOT

ASOF2:	JUMPE 2,ASOF4		;FREE => NOT FOUND
	JUMPGE 5,ASOF7		;FIRST DELETED ENCOUNTERED?
	MOVE 5,3		;YES, SAVE IT
	JRST ASOF7

;ASOFN (CONT.)

ASOF4:	JUMPL 5,.+2		;DELETED ENCOUNTERED?
ASOF6:	MOVE 3,5		;YES, USE IT
	POP P,1			;RECOVER CLASS AND BITS
	TLZE 1,1B21		;NEWLY ASSIGNED XB?
	TLNN 1,10		;AND DISK ADDRESS?
	JRST .+2		;NO
	TLO 6,NEWFB		;YES, INDICATE IN DISK ADDRESS
	MOVEM 1,SPTH(3)
	MOVEM 6,SPT(3)		;PUT ADDRESS IN SPT
	AOS NOF			;COUNT OPEN FILES
	SKIPE DISKP		;NO DISK ON SYSTEM, OR
	TLNE 6,NEWFB		;NEW FILE?
	JRST ASOF5		;YES
	MOVSI 1,1B31
	ADDM 1,SPT(3)		;BUMP SHARE COUNT
	PUSH P,3		;SAVE OFN
	CALL SETXB1		;MAP XB
	POP P,3
	MOVE 1,CXBPGA		;GET XB IN CORE
	MOVE 1,SPT(3)		;CORE ADDRESS
	MOVSI 2,SWPERR
	TDNE 2,CST3(1)		;DISK ERROR IN XB?
	JRST ASCHK3		;YES, DON'T OPEN
	MOVSI 1,-1000		;SETUP TO SCAN XB
ASCHK1:	MOVE 2,CXBPGA(1)	;GET WORD FROM XB
	JUMPE 2,ASCHK2		;NOT IN USE
	TLC 2,ACCESB+10		;MUST HAVE ACCESS AND DISK BITS ON,
	TLNE 2,777770-RWX	;RWX AND OTHER ADDRESS BITS DONT CARE,
	JRST ASCHK3		;OTHERS ALL OFF, OTHERWISE DONT OPEN
ASCHK2:	AOBJN 1,ASCHK1
	CALL RELCXB		;OK, RELEASE XB
	JRST ASOF9

ASCHK3:	CALL RELCXB		;FILE NO GOOD, RELEASE XB
	MOVE 1,SPT(3)		;CLEAR OFN AND CORE PAGE
	SETOM SPTH(3)
	SOS NOF
	CALL DECOR
	SETZM CST2(1)
	JSP 4,ONRQ
	MOVEI 1,OPNX16		;ERROR NUMBER FOR BAD XB
	JRST SKORET		;RETURN BAD

;SHARED OPEN, CHECK WRITE AND THAWED BITS FOR LEGAL COMBINATION

ASOF3N:	NOSKED
ASOF3:	MOVSI 2,SPTLKB
	TDNE 2,SPTH(3)		;LOCKED BY DDMP?
	JRST [	OKSKED		;YES
		CAIA
		JRST ASOF3N
		JSYS BLOCK1]	;THIS RETURNS CALLER -1
	POP P,2			;RECOVER CLASS AND BITS
	MOVSI 1,-1B31
	TDNN 1,SPT(3)		;SHARE COUNT 0?
	JRST ASOF8		;YES (FILE EFFECTIVELY NOT OPEN)
	MOVE 1,SPTH(3)		;GET EXISTING BITS
	XOR 1,2			;XOR PRODUCES 0 IF BITS THE SAME
	TLNE 1,THAWB		;THAWED BITS EQUAL?
	JRST ASOFB		;NO, ILLEGAL OPEN
	MOVE 1,SPTH(3)
	IOR 1,2
	TLNN 1,FILWB		;BOTH WRITE BITS 0?
	JRST ASOF5		;YES, LEGAL OPENING, NO CHANGE TO WB
	TLNN 1,THAWB		;THAWED BITS 1?
	JRST ASOFB		;NO, ILLEGAL TO HAVE SHARED WRITING
	AND 2,[XWD FILWB,0]	;LEGAL OPENING, THAWED BITS BOTH 1
	IORM 2,SPTH(3)		;IOR WRITE BITS
ASOF5:	MOVSI 1,1B31		;INCREMENT SHARE COUNT
	ADDM 1,SPT(3)
ASOF9:	OKSKED
	MOVEI 1,0(3)		;RETURN OFN (SPT INDEX)
	JRST RSKP

ASOF8:	MOVE 1,SPT(3)
	TLNE 1,17		;NOW IN CORE?
	JRST ASOF81		;NO
	MOVSI 4,DWRBIT		;YES, WAIT FOR ANY WRITE TO COMPLETE
	TDNE 4,CST3(1)
	JRST .-1
ASOF81:	XOR 2,SPTH(3)		;SET THAW AND WRITE BITS TO GIVEN
	AND 2,[XWD FILWB+THAWB,0]
	XORM 2,SPTH(3)
	JRST ASOF5		;RETURN OK

ASOFB:	MOVEI 1,OPNX9		;ERROR NUMBER FOR FILE BUSY
	JRST SKORET

;RELEASE OPEN FILE NUMBER, OFN IN AC1

RELOFN:	MOVSI 2,SPTLKB
RELOF4:	NOSKED
	TDNE 2,SPTH(1)		;LOCKED BY DDMP?
	JRST [	OKSKED		;YES
		CAIA		;WAIT A LITTLE, THEN TRY AGAIN
		JRST RELOF4
		JSYS BLOCK1]	;THIS RETURNS CALLER -1
	MOVEI 3,0(1)
	CALL SETXB1		;MAP INDEX BLOCK
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT
	SKIPE DISKP		;NO DISK, OR
	CAIE 2,1		;IS THIS FINAL CLOSE?
	JRST RELOF1		;NO
	MOVSI 3,-1000		;SCAN XB
RELOF3:	MOVE 2,CXBPGA(3)	;GET XB WORD
	JUMPE 2,RELOF2		;EMPTY
	TLNN 2,10		;ADDRESS OK IF ON DISK OR IN CORE
	TLNN 2,17
	TLNE 2,SHRBIT+INDBIT	;POINTER TYPE OK IF PRIVATE
	JRST RELBAD
RELOF2:	AOBJN 3,RELOF3
RELOF1:	MOVSI 2,-1B31		;REDUCE SHARE COUNT OF XB ONCE MORE
	ADDM 2,SPT(1)		;FOR CLOSING
SETMPX:	CALL RELCXB		;RELEASE TEMP MAPPING
	OKSKED
	RET

RELBAD:	BUG(CHK,<BAD POINTER TYPE IN INDEX BLOCK>)
	MOVE 2,SPT(1)
	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;INDICATE ERROR IN PAGE SO IT WON'T
	JRST RELOF1		;BE WRITTEN ON DISK

;ASSIGN PSB FOR NEW PROCESS

ASPSB:	NOSKED
	CALL ASSPT
	JRST SKORET

ASSPT:	SKIPG 1,FRESPT		;ANY FREE CELLS?
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 1,0(1)
	EXCH 1,FRESPT
	SUBI 1,SPT
	AOS SPTC		;ASSIGN SPT SLOT
	MOVSI 2,1B31+1
	MOVEM 2,SPT(1)		;SHARE COUNT OF 1, NO ADDRESS
	SETZM SPTH(1)
	RET

;DEASSIGN SPT AND RELEASE STORAGE

DESPTN:	NOSKED
	CALL DESPT
	JRST SKORET

DESPT:	MOVSI 2,-1B31
	ADDB 2,SPT(1)		;REDUCE SHARE COUNT
	TLNE 2,-1B31		;NOW ZERO?
	BUG(HLT,<TRIED TO RELEASE SPT SLOT BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	PUSH P,1
	CALL REMFP1		;RELEASE CORE AND/OR DRUM
	POP P,1
	ADDI 1,SPT
	EXCH 1,FRESPT		;PUT ON FREE LIST
	EXCH 1,@FRESPT
	SOS SPTC
	RET

;DELETE XB ASSOCIATED WITH OFN
;LAST STAGE OF DELETE FILE

DELOFN:	CALL WTSPT		;WAIT FOR SPT TO BE UNSHARED
	NOSKED
	JSP 4,WTSPTT		;SHARE COUNT NOW 1?
	JRST DELO1		;NO, GO WAIT SOME MORE
	MOVSI 2,-1B31		;SHARE COUNT SHOULD NOW BE 1
	ADDB 2,SPT(1)		;FOR LAST OPENING
	TLNE 2,-1B31		;NOW 0?
	BUG(HLT,<TRIED TO DELETE INDEX BLOCK BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	SETOM SPTH(1)
	PUSH P,1
	CALL REMFP1		;DELETE ALL STORAGE
	POP P,1
	SOS NOF
	OKSKED
	RET

DELO1:	OKSKED
	JRST DELOFN

;READ MAP GIVEN VIRTUAL ADDRESS

MRMAP:	CALL FPTA		;GET PAGE TABLE ADDRESS

;GENERAL MAP READ
;ENTER HAVING PTN.PN IN 1
; RETURN +1 IF PTN.PN
; RETURN +2 IF OFN.PN

MRPT:	CALL SETCPT
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RDMQ5		;EMPTY
	PUSH P,1		;SAVE ORIG IDENT
	PUSH P,2
	TLNN 2,SHRBIT+INDBIT	;PRIVATE?
	JRST MRMP		;YES
	TLNN 2,SHRBIT		;SHARED OR INDIRECT
	JRST MRMI		;INDIRECT
	LSH 2,-^D9		;GET SPT NUMBER
	ANDI 2,SPTM
	CAIL 2,NOFN		;INDEX BLOCK?
	MOVE 2,SPTH(2)		;NO, GET OFN.PN
MRM1:	MOVE 1,2
	HLRZ 2,1
	CAIL 2,NOFN		;OWNED BY OFN?
	JRST MRMQ		;NO
	AOS -2(P)		;YES, SKIP RETURN
MRMQ1:	POP P,2			;ORIGINAL POINTER
	POP P,3			;FLUSH ORIG IDENT
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	TLO 2,1B23		;EXISTS BIT
	JRST RELCPT

MRMI:	LSHC 2,-^D9		;RE-FORMAT INTO OFN.PN OR PTN.PN
	ANDI 2,SPTM
	LSH 3,-^D9
	LSHC 2,^D18
	JRST MRM1

RDMQ5:	SETZB 1,2		;RETURN 0
	JRST RELCPT

MRMQ:	CAME 1,-1(P)		;OWNED BY ORIG IDENT?
	JRST MRMQ1		;NO
MRMP:	PUSH P,1
	HLRZ 2,1
	CAMN 2,MMSPTN		;SWP MON MAP?
	JRST MRMP1		;YES, DON'T PUT IN PMF
	CALL RELCPT
	MOVE 1,JOBPMF		;ASSIGN NEW PAGE FROM PMF
	FFFFP
	CALL JFNOFN
	BUG(HLT,<FAILED TO CONVERT JFN FROM FFFFP TO OFN>)
	MOVSI 3,RWX		;PUT PAGE IN PMF WITH ALL ACCESS
	MOVE 2,1
	EXCH 1,0(P)
	CALL SETPT		;PUT PAGE IN PMF
MRMP1:	POP P,2			;OFN.PN OF NEW PAGE
	JRST MRM1

;READ PAGE ACCESSIBILITY

MRPACS:	PUSH P,[0]
	PUSH P,[XWD RWXB+TRAPUB+COPYB,0]
MRP4:	HLRZ 3,1		;SOURCE PTN
	CAIG 3,0
	BUG(HLT,<ILLEGAL LH OF 1 ARG TO MRPACS>)
	CALL SETXB1		;MAP PT
	MOVE 3,CXBPGA(1)	;GET MAP WORD
MRP6:	SKIPN -1(P)		;FIRST MAP WORD?
	HLRZM 3,-1(P)		;YES, SAVE FIRST PT ACCESS
	TLC 3,TRAPUB+COPYB	;FOR THESE BITS, WE'RE AND'ING 0'S
	ANDM 3,0(P)		;COMPUTE AND OF ALL MAP WORDS
	TLNN 3,INDBIT		;INDIRECT?
	JRST MRP2		;NO, SHARED OR PRIVATE
	CALL RELCXB
	ROTC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 3,SPTM
	LSH 3,^D9
	ROTC 2,^D9
	MOVE 1,3
	JRST MRP4

MRP2:	POP P,1			;AND OF ALL MAP WORDS
	POP P,2			;FIRST POINTER ACCESS
	TLC 1,TRAPUB+COPYB	;BITS FOR WHICH AND'ING 0'S
	JUMPE 2,RELCXB		;RETURN 0 IF FIRST POINTER WAS 0
	TLNN 3,SHRBIT+INDBIT	;FINAL PTR PRIVATE?
	TLO 1,(1B10)		;YES, SO INDICATE
	TLZE 1,ACCESB		;ANY ACCESS?
	TLO 1,(1B5)		;YES, SET BIT IN RESULT
	TRNE 2,INDBIT		;FIRST POINTER INDIRECT?
	TLO 1,(1B6)		;YES, NOTE
	ANDI 2,RWX+TRAPUB+COPYB	;BITS OF ORIG PTR TO GIVE TO USER
	HRRI 1,1B23(2)		;ORIG PTR ACCESS WITH EXISTS BIT TO RH
	JRST RELCXB		;RELEASE PT AND RETURN

;SET PAGE ACCESSIBILITY

MSPACS:	PUSH P,2
	CALL SETCPT		;MAP PT
	POP P,2
	SKIPN CPTPGA(1)		;PAGE EXISTS?
	JRST RELCPT		;NO, IGNORE CALL
	HLRZ 3,1
	CAIGE 3,NOFN		;FILE?
	TLZ 2,TRAPUB+COPYB	;YES, DISALLOW BITS
	XOR 2,CPTPGA(1)		;SET BITS 2-4
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	XORB 2,CPTPGA(1)
	JRST RELCPT

;MRAPCS - JSYS FOR MONITOR DDT
;DOESN'T WORK CORRECTLY FOR RES MON ADDRESSES WHEN MAPRESMON IS ON

	INTERN .MRPAC

.MRPAC:	JSYS MENTR
	MOVE 2,0(P)		;RETURN PC
	TLNE 2,UMODF		;FROM MONITOR?
	JRST ITRAP		;NO, ILLEGAL FROM USER
	TLNE 1,400000		;USER?
	JRST [	CALL FPTA	;YES, GET PTN.PN
		JRST MRPC3]
	MOVEI 2,0(1)		;MONITOR, GET ADDRESS
	CAIGE 2,100000		;RESIDENT MON?
	JRST [	MOVSI 1,RWX+1B28 ;YES, MEANS PRIVATE AND ALL ACCESS
		JRST MRPC2]
	CAIGE 2,PPRMA		;NON-RES MON?
	JRST [	LSH 2,-^D9	;NO, IS RESIDENT MAPPED MON
		SKIPE 1,MMAP(2)	;REQUESTED PAGE EXISTS?
		TLO 1,1B28	;YES
		JRST MRPC2]	;RETURN CONTENTS OF MMAP
	CALL FPTA
	MOVEI 2,0(1)
	CAIL 2,PPRMPG+NRSPG	;SWAPPER RESERVED PAGE, OR
	CAIN 2,CXBPG		;MAP RESERVED PAGE?
	JRST MRPC1		;DON'T ALLOW
MRPC3:	CALL MRPACS
MRPC2:	UMOVEM 1,2		;RETURN RESULT IN 2 LIKE RPACS
	JRST MRETN

MRPC1:	SETZ 1,
	JRST MRPC2

;SET PAGE IN MONITOR OR USER MAP (INTERNAL MONITOR CALL)
; AC1/ OFN,,PN   (OFN IS SPT POINTER, PN IS 0-777)
; AC2/ 18-35 VIRTUAL ADDRESS OF PAGE (NOT PAGE NUMBER)
;       0    1 => USER MAP, 0 => MONITOR MAP
;       2-4, 8, 9  READ, WRITE, XCT ALLOW BITS (SAME AS PAGER MAP WORD)
;      15-17 DISPOSAL INFO FOR OLD PAGE, 0 => NO SPECIAL ACTION,
;             PAGE TO BE HANDLED AS USUAL. 1 => NO FURTHER USE FOR
;             PAGE, SHOULD BE MOVED TO HOME ADDRESS.

SETMPG:	PUSH P,7		;SAVE AC'S
	MOVEI 7,1(P)
	ADD P,BHC+7
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	HLLZ 3,2		;GET ACCESS AND DISPOSAL
	PUSH P,3
	EXCH 1,2
	CALL FPTA		;CONVERT ADDRESS TO PTN.PN
	JRST SETP8

;SET PAGE TABLE (FOR PROCESS OR FILE)
; AC1/ SOURCE IDENTIFIER
; AC2/ DESTINATION IDENTIFIER
; AC3/ 2-4, 8, 9 ACCESS PERMISSION, 15-17 DISPOSAL

;IDENT IS OFN.PN (PAGE IN FILE), 0.OFN (INDEX BLOCK),
; PTN.PN (PAGE IN PROCESS), OR 0.PTN (PROCESS PT)

SETPT:	PUSH P,7		;SAVE AC'S
	MOVEI 7,1(P)
	ADD P,BHC+7
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	PUSH P,3		;SAVE ACCESS
	EXCH 1,2
SETP8:	CALL RELMPG		;RELEASE EXISTING PAGE
	NOSKED
	JUMPE 2,SETPT1		;NO NEW PAGE TO SET
SETP5A:	CAMN 1,2		;DON'T ALLOW MAP TO SELF
	JRST SETPF1
	HLRZ 3,2		;GET OFN
	JUMPE 3,SETMXB		;OFN=0 MEANS SPTN IN RH
	TDNE 2,[XWD -SPTM-1,777000] ;LEGAL PTN AND PN?
	BUG(HLT,<ILLEGAL SOURCE IDENTIFIER GIVEN TO SETPT>)
	CALL SETXB1		;MAP INDEX BLOCK
SETP72:	MOVE 3,CXBPGA(2)	;GET WORD FROM XB
	HLRZ 4,1		;GET DESTINATION PTN
	CAIGE 4,NOFN		;FILE?
	JRST SETP7		;YES
	HLRZ 4,2		;GET SOURCE PTN
	CAIL 4,NOFN		;PROCESS?
	JRST SETP5		;YES, GO SETUP INDIRECT POINTER
	TLNE 3,SHRBIT+INDBIT	;PRIVATE?
	JRST SETMP3		;NO
	TLNN 3,ACCESB		;PAGE EXISTS?
	JRST SETP3		;NO, GO CREATE IT
SETP4:	MOVE 4,SPTC		;YES
	CAMGE 4,SPC0		;ROOM IN SPT? (SPT < C FULL)
	JRST SETMP6		;YES
	SETCM 4,3		;GET ACCESS OF SOURCE
	TLNE 4,RWX		;ALL POSSIBLE?
	SKIPG FRESPT		;NO, SHOULDN'T USE IND PTR
	JRST SETP5		;USE IND PTR
	JRST SETMP6		;USE SHR PTR

SETP5:	SKIPGE INDFLG		;ALLOWING USE OF INDIRECT POINTERS?
	JRST SETPF2		;NO, GO TRY ALTERNATIVES
	TLNE 3,INDBIT		;SOURCE CONTAINS IND PTR?
	JRST [	CALL RELCXB	;YES, TRACE DOWN
		ROTC 2,-^D9	;CONSTRUCT IDENT OF PAGE POINTED
		ANDI 3,SPTM	;TO BY IND PTR
		LSH 2,-^D9
		ROTC 2,-^D18
		JRST SETP5A]	;AND USE THAT AS SOURCE
	LSHC 2,-^D9		;CONSTRUCT INDIRECT POINTER
	LSH 2,-^D9
	LSHC 2,^D9
	TLO 2,ACCESB+INDBIT
SETMP4:	LDB 3,[POINT 13,2,26]	;GET OFN OF INDEX BLOCK
SETMP5:	MOVSI 4,1B31
	CAIE 3,0		;IF NO OWNING PT
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT OF INDEX BLOCK
	POP P,3
	XOR 2,3			;PUT ACCESS BITS IN PTR
	TLZ 2,RWX+TRAPUB+COPYB	;USER ALLOWED TO SPECIFY THESE
	XOR 2,3
	MOVEM 2,CPTPGA(1)	;PUT MAP WORD IN MAP
SETPT2:	CALL RELCPT		;RELEASE PT MAPPING
	SUB P,BHC+7
	MOVSI 7,1(P)
	BLT 7,6
	POP P,7			;RESTORE AC'S
	JRST SETMPX

SETPT1:	POP P,3			;FLUSH JUNK
	JRST SETPT2

SETP3:	MOVSI 3,RWXB+1
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST SETP3A		;NO, USE UNASSIGNED ADDRESS INDICATOR
	PUSH P,1
	PUSH P,2
	HLRZ 2,2		;GET DISK ADDRESS OF XB
	MOVE 1,SPTH(2)
	CALL DSKASN		;ASSIGN DISK ADDRESS
	JRST SETP3B		;DISK FULL
	TLO 1,RWXB+NEWFB	;ACCESS AND INDICATE NEW ASSIGNMENT
	MOVE 3,1
SETP3H:	POP P,2
	POP P,1
SETP3A:	MOVEM 3,CXBPGA(2)	;PUT IN XB
	JRST SETP4

SETP3B:	MOVEI 1,OPNX10		;LEAVE ERROR NUMBER
	MOVEM 1,LSTERR
	MOVEI 1,^D11
	CALL PSIRQ0		;SEND FILE ERROR INTERRUPT
	SUB P,BHC+3		;CLEAR STACK
	JRST SETPT2		;RETURN HAVING DONE NOTHING

;SETMPG (CONT.)

SETPF2:	TLNE 3,SHRBIT+INDBIT	;SHARED NOW?
	JRST SETMP3		;YES, USE SAME POINTER
	JUMPE 3,[MOVSI 3,RWXB+1	;IF SOURCE CURRENTLY EMPTY,
		JRST SETP3A]	;USE UNASSIGNED ADDRESS INDICATION
	SKIPLE FRESPT		;ANY SPT SPACE AT ALL?
	JRST SETMP6		;YES, GO ASSIGN A SLOT
	MOVEI 1,		;GIVE ERROR INDICATION
	JRST SETPTE

SETMP3:	MOVE 2,3		;ALREADY SHARED, USE SAME POINTER
	TLNE 2,INDBIT		;INDIRECT?
	JRST SETMP4		;YES
SETMP7:	LDB 3,[POINT 13,2,26]
	MOVSI 4,1B31		;SHARED,
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT IN SPT
	HLRZ 3,SPTH(3)		;GET OFN FOR THIS PAGE
	JRST SETMP5		;GO INCREMENT SHARE COUNT OF XB

SETMP6:	SKIPG 4,FRESPT		;ASSIGN NEW SPT SLOT
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 4,0(4)		;GET CDR
	EXCH 4,FRESPT		;LIST OF FREE SLOTS
	SUBI 4,SPT		;MAKE RELATIVE
	AOS SPTC		;COUNT OF USED SPT ENTRIES
	TLNE 3,17		;IN CORE?
	JRST SETP2
	CAME 2,CST2(3)		;CHECK OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(3)		;RECORD NEW LOCATION OF CORE ADDRESS
	HLRZ 6,2		;YES, UPDATE LOCK COUNT FOR
	MOVE 6,SPT(6)		;OWNING PT
	MOVSI 5,-PLKV		;REDUCE IT, BECAUSE IT WILL HAVE
	ADDM 5,CST1(6)		;ONE LESS CORE ADDRESS IN IT
SETP2:	TLZ 3,-1B31		;FLUSH BITS IN ORIGINAL POINTER
	MOVEM 3,SPT(4)		;PUT IT IN SPT
	MOVEM 2,SPTH(4)		;PUT OFN.PN IN SPTH
	HLRZ 3,2		;SAVE OFN
	LSH 4,^D9		;CONSTRUCT SHARE POINTER
	TLO 4,SHRBIT
	XOR 4,CXBPGA(2)		;WITH PROTECTION BITS FROM PT
	TLZ 4,RWXB
	XORB 4,CXBPGA(2)	;PUT CONSTRUCTED SHARE POINTER IN PT
	MOVE 2,4		;AS WELL AS PROCESS MAP
	MOVSI 4,1B31		;BUMP SHARE COUNT FOR POINTER PUT
	ADDM 4,SPT(3)		;IN XB
	JRST SETMP7		;GO INCREMENT SHARE COUNTS, ETC.

SETMXB:	CAIL 2,SSPT		;LEGAL NUMBER?
	BUG(HLT,<ILLEGAL SPT INDEX GIVEN TO SETMXB>)
	HLRZ 3,1		;GET DESTINATION PTN
	CAIGE 3,NOFN		;FILE?
	BUG(HLT,<ILLEGAL DESTINATION IDENTIFIER TO SETMPG OR SETPT>)
	MOVEI 3,0(2)		;REQUEST WAS FOR INDEX BLOCK
	LSH 2,^D9		;MAKE IT INTO SHARE POINTER
	TLO 2,SHRBIT+RWXB
	JRST SETMP5

;DESTINATION IS FILE

SETP7:	HLRZ 4,2		;GET SOURCE PTN
	CAIGE 4,NOFN		;IS FILE?
	JRST SETPF1		;YES, ERROR
	TLNE 3,SHRBIT+INDBIT	;NOT PRIVATE?
	JRST SETPF		;YES
	JUMPE 3,SETP7K		;PAGE NEVER REFERENCED
	TLNE 3,10		;NOW ON DISK?
	JRST SETP71		;YES
	TLNE 3,16		;NOW ON DRUM?
	JRST SETP7D		;YES, GO ADJUST DRUM BACKUP ADR
	PUSH P,1		;IN CORE,
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	POP P,1
	MOVSI 4,PLKV		;IN CORE,
	ADDB 4,CST1(3)		;GET BACKUP ADR AND LOCK PAGE
	TLNE 4,10		;DISK?
	JRST SETP7C		;YES
	TLNE 4,16		;DRUM?
	JRST SETP7E		;YES
	MOVEI 4,CST1(3)		;NOT ASSIGNED, PUT BACKUP ADR IN CST1
	CALL SETP7A		;ASSIGN BACKUP ADR AND STORE IT
SETP7C:	PUSH P,3
	MOVEM 1,CST2(3)		;IN CORE, ADJUST CST
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;UNLOCK PAGE
	HLRZ 4,2		;SOURCE PTN
	MOVE 4,SPT(4)
	MOVSI 3,-PLKV
	ADDM 3,CST1(4)		;REDUCE LOCK COUNT OF PT
	HLRZ 4,1
	MOVE 4,SPT(4)
	MOVSI 3,PLKV
	ADDM 3,CST1(4)		;INCREASE LOCK COUNT OF XB
	POP P,3
SETP71:	SETZM CXBPGA(2)		;PUT SOURCE PTR IN DEST MAP
	HLRZ 4,0(P)		;GET USER SPECIFIED ACCESS
	ANDI 4,RWX
	TLZ 3,-1B31
	TLO 3,ACCESB(4)		;PUT ACCESS AND ACCESS BIT IN PTR
	MOVEM 3,CPTPGA(1)
	EXCH 1,2		;EXCHANGE SOURCE AND DESTINATION PT'S
	MOVE 3,PSB+CPTPG
	EXCH 3,PSB+CXBPG
	MOVEM 3,PSB+CPTPG
	MONCLR			;CLEAR MONITOR AR'S
	JRST SETP72		;NOW AS IF PAGE WAS IN FILE

SETP7K:	MOVSI 3,RWXB		;NEW PAGE, SETUP POINTER
	MOVEI 4,3		;WHERE TO STORE ADDRESS
	JRST SETP73

SETP7D:	MOVE 4,3
SETP7E:	PUSH P,2
	PUSH P,3
	MOVE 2,4		;DRUM ADDRESS
	CALL GDSTX		;GET DST INDEX
	MOVEI 4,DST(2)		;WHERE TO STORE ADDRESS
	POP P,3
	POP P,2
	MOVE 5,0(4)		;PRESENT BACKUP
	TLNN 5,10		;DISK?
SETP73:	CALL SETP7A		;NO, ASSIGN DISK ADDRESS AND STORE IT
	TLNN 3,17
	JRST SETP7C
	JRST SETP71

SETP7A:	HLRZ 5,1		;GET OFN OF DESTINATION FILE
	PUSH P,1		;SAVE STUFF
	PUSH P,2
	PUSH P,3
	PUSH P,4
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST [	MOVSI 1,1	;USE DEFAULT ADDRESS
		JRST SETP7Y]
	MOVE 1,SPTH(5)		;GET XB ADRESS AND CLASS
	CALL DSKASN		;ASSIGN DISK ADDRESS FOR PAGE
	JRST SETP7X		;DISK FULL
	TLO 1,NEWFB		;INDICATE NEW ASSIGNMENT
SETP7Y:	MOVE 5,1
	POP P,4
	POP P,3
	POP P,2
	POP P,1
	DPB 5,[POINT 22,0(4),35]	;STORE ADDRESS WHERE GIVEN
	RET

SETP7X:	SUB P,BHC+4+1		;FLUSH 4 TEMPS AND 1 RETURN
	JRST SETP3B		;GO DO NO-ROOM ERROR AND RETURN

;POINTER NOW IN SPT OWNED BY FORK. MOVE IT TO FILE

SETPF:	LDB 4,[POINT 13,3,26]	;GET SPTN
	CAMN 2,SPTH(4)		;IS OWNED BY SOURCE?
	TLNE 3,INDBIT		;AND NOT INDIRECT?
	JRST SETPF1		;SORRY, CAN'T GIVE AWAY UNOWNED PAGES
	MOVEM 1,SPTH(4)		;SET NEW OWNERSHIP
	MOVSI 5,-1B31
	AND 5,SPT(4)		;GET CURRENT SHARE COUNT
	HLRZ 4,1
	ADDM 5,SPT(4)		;TRANSFER SHARE COUNT TO NEW OWNING PT
	MOVN 5,5
	HLRZ 4,2
	ADDM 5,SPT(4)		;AWAY FROM OLD PT
	JRST SETMP3		;NOW SETUP SHARE POINTER IN DEST

SETPF1:	MOVEI 1,		;ILLEGAL PAGE TO FILE ATTEMPTED
SETPTE:	MOVEM 1,LSTERR
	MOVEI 1,^D11		;IO ERROR CHANNEL
	CALL PSIRQ0
	JRST SETPT1		;CLEAN UP AND EXIT

;PUT INDEX BLOCK IN FIXED PAGE (CXBPG) OF PP MAP FOR TEMP USE

SETXB1:	CALL RELCXB		;RELEASE CURRENT ONE
	NOINT			;NO INTERRUPTS WHILE XB MAPPED
	LSH 3,^D9
	TLO 3,RWXB-XCTB+SHRBIT	;MAKE INTO SHARE POINTER, NO XCT
	MOVEM 3,PSB+CXBPG	;PUT INTO CURRENT X BLOCK PAGE
	RET

;RELEASE INDEX BLOCK NOW IN FIXED PAGE

RELCXB:	SKIPN PSB+CXBPG
	RET			;NONE THERE NOW
	SETZM PSB+CXBPG		;CLEAR MAP
	MONCLR			;CLEAR MONITOR AR'S
	OKINT
	RET

POP1:	POP P,1
	RET

;MAP CURRENT PAGE TABLE FOR TEMP USE

SETCPT:	CALL RELCPT		;RELEASE CURRENT ONE
	NOINT
	HLRZ 2,1		;MAKE SHARE POINTER
	LSH 2,^D9
	TLO 2,RWXB-XCTB+SHRBIT
	MOVEM 2,PSB+CPTPG
	RET

;RELEASE CURRENT PT MAPPING

RELCPT:	SKIPN PSB+CPTPG		;ANYTHING THERE?
	RET			;NO
	SETZM PSB+CPTPG		;CLEAR MAP
	MONCLR			;CLEAR AR'S
	OKINT
	RET

;RELEASE PAGE FROM MAP
; AC1/ OFN.PN OF PAGE

RELMPG:	PUSH P,3
	PUSH P,2
	CALL SETCPT
	PUSH P,1
	NOSKED
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RELMPR		;EMPTY
	CONO PGR,0		;CLEAR AR'S
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELP3
RELMP1:	HLRZ 3,1		;GET PTN
	TLNE 2,INDBIT		;INDIRECT POINTER
	JRST RELMP3		;THAT'S OK
	CAIGE 3,NOFN		;OWNED BY FILE?
	JRST RELMP4		;CAN'T DELETE FILE PAGE STILL SHARED
	LDB 3,[POINT 13,2,26]	;GET SPTN
	CAMN 1,SPTH(3)		;OWNER TRYING TO DELETE?
	JRST RELMP4		;MUST WAIT TILL UNSHARED
RELMP3:	SETZM CPTPGA(1)		;CLEAR MAP WORD
	MOVE 3,2		;SAVE POINTER
	LSH 2,-^D9
	ANDI 2,SPTM		;GET SPT INDEX
	MOVSI 1,-1B31
	TLNN 3,INDBIT		;INDIRECT POINTER, OR
	CAIGE 2,NOFN		;OFN?
	JRST RELP1		;YES
	HLRZ 3,SPTH(2)		;IS SHARE POINTER, GET OFN
	JUMPE 3,RELP1		;IF UNOWNED SPTN
	ADDM 1,SPT(3)		;REDUCE SHARE COUNT OF OFN
	ADDB 1,SPT(2)		;REDUCE SHARE COUNT OF PAGE OR XB
	TLNE 1,-1B31		;COUNT NOW 0?
	JRST RELMPR		;NO
	TLNE 1,17		;CORE?
	JRST RELMP2		;NO
	CALL AGESET		;IN CORE, SET AGE
	MOVSI 4,PLKV
	ADDM 4,CST1(1)		;AND LOCK WHILE ADJUSTING

RELMP2:	MOVSI 4,-1B31
	ADDM 4,SPT(3)		;REDUCE SHARE COUNT OF XB
	CALL SETXB1		;MAP OWNING XB
	MOVE 4,SPTH(2)		;GET OWNING PTN.PN
	XOR 1,CXBPGA(4)		;PUT ADDRESS BACK IN XB WITH ORIGINAL
	TLZ 1,-1B31-SHRBIT-INDBIT
	XORB 1,CXBPGA(4)	;ACCESS BITS
	CALL RELCXB		;RELEASE XB
	MOVE 3,2
	ADDI 2,SPT
	EXCH 2,FRESPT		;RETURN SPT SLOT TO FREE LIST
	MOVEM 2,@FRESPT
	SOS SPTC
	TLNE 1,17		;PAGE IN CORE?
	JRST RELP4		;NO
	CAME 3,CST2(1)		;CONFIRM OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(1)		;YES, CHANGE RECORD OF OWNING PT
	HLRZ 4,4		;PTN OF OWNING PT
	MOVE 4,SPT(4)		;CORE ADDRESS OF IT
	MOVSI 2,PLKV
	ADDM 2,CST1(4)		;INCREMENT LOCK COUNT
	MOVSI 4,-PLKV
	ADDM 4,CST1(1)		;UNLOCK PAGE
	JRST RELP2

RELP4:	TLNN 1,10		;ON DISK? OR
	TLNN 1,16		;NOT ASSIGNED?
	JRST RELMPR		;YES
	MOVE 1,4
	CALL SWPINP		;GET IT OFF DRUM
RELP2:	CALL AGESET		;MAKE PAGE IN USE
	CALL DECOR		;DEASSIGN
RELMPR:	POP P,1
	POP P,2
	POP P,3
SKORET:	OKSKED			;RE-ENABLE SCHEDULING
	RET

RELP3:	CALL REMFPG		;RELEASE ALL STORAGE
	JRST RELMPR

RELP1:	ADDM 1,SPT(2)
	JRST RELMPR

RELMP4:	SUB P,BHC+3		;FLUSH TEMPS
	MOVEI 1,		;ILLEG UNMAPPING
	MOVEM 1,LSTERR
	MOVEI 1,^D11
	CALL PSIRQ0		;GENERATE ITRAP
	SETZB 1,2
	JRST SKORET

;REMOVE PAGE FROM SYSTEM (DELETE PERMANENT AND TEMPORARY ADDRESSES)

REMFPG:	MOVE 3,CPTPGA(1)	;GET MAP WORD
	SETZM CPTPGA(1)		;CLEAR MAP WORD
REMFP1:	TLNE 3,10		;DISK?
	JRST REMFF		;YES
	TLNE 3,16		;DRUM?
	JRST REMFD		;YES
	TLNE 3,17		;CORE?
	RET			;DONE
	MOVEI 1,0(3)
	CAIGE 1,MAXCOR		;LEGAL PAGE?
	CAMGE 1,SWPCOR
	BUG(HLT,<ILLEGAL CORE PAGE NUMBER TO REMFPG>)
	CALL AGESET
	CALL DECOR
	HLRZ 2,CST2(1)		;GET PTN OF OWNING PT
	JUMPE 2,REMFP2		;NONE, SPT
	MOVE 3,SPT(2)		;GET ADR OF OWNING PT
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;DECREMENT LOCK COUNT
REMFP2:	MOVSI 2,DWRBIT
	MOVSI 3,(77B5)
	MOVSI 4,-PLKV
	PIOFF
	SETZM CST2(1)		;FLUSH SOURCE
	TDNE 3,CST0(1)		;PAGE NOW ON RPLQ?
	TDNE 4,CST1(1)		;LOCKED?
	JRST REMF21		;YES, IS OR WILL BE PUT ON RPLQ
	TDNE 2,CST3(1)		;BEING WRITTEN?
	JRST [	PION		;YES, MUST WAIT
		JRST REMFP2]
	PION
	JSP 4,ONRQ		;PUT PAGE ON RPLQ
REMF22:	MOVSI 3,-PLKV
	AND 3,CST1(1)		;FLUSH BACKUP ADDRESS, LEAVE LK CNT
	EXCH 3,CST1(1)		;GET BACKUP ADDRESS
	JRST REMFP1

REMF21:	PION
	JRST REMF22

REMFD:	MOVE 1,3
	PUSH P,1
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,2
	CALL GDSTX
	MOVE 3,DST(2)		;GET BACKUP ADDRESS
	SETOM DST(2)		;MAKE DST SLOT EMPTY
	JRST REMFP1

REMFF:	MOVE 1,3
	CALL DEDSK		;DEASSIGN DISK ADDRESS
	RET

;CONSTRUCT PTN.PN FOR
;ADDRESS GIVEN IN 18-35 OF AC1
;BIT 0 OF AC1 SAYS USER (IF 1) OR MONITOR (IF 0) ADDRESS
;RETURN WITH PTN.PN IN AC1

FPTA:	PUSH P,1
	MOVEI 1,0(1)		;CLEAR LH
	LSH 1,-^D9		;GET PAGE NUMBER
	EXCH 1,0(P)		;GET ARG, SAVE PN
	JUMPL 1,FPTAU		;USER MODE IF BIT 0 IS 1
	MOVE 1,0(P)
	CAIL 1,PPMPG		;WHICH PART OF MONITOR?
	JRST FPTA1		;PRIVATE PER PROCESS
	CAIL 1,PJMPG
	JRST FPTA2		;PRIVATE PER JOB
	CAIL 1,PPRMPG
	JRST FPTA3		;PRIVATE PER PROCESSOR AND SWAPPABLE
	BUG(HLT,<FPTA - ARG POINTS TO RESIDENT MONITOR>)

FPTA1:	MOVE 1,FORKX		;GET SPTN OF PSB
	JRST FPTA4

FPTAU:	MOVE 1,FORKX		;GET SPTN OF UPT OR IF NONE, PSB
	HLL 1,FKPGS(1)
	TLNN 1,-1
FPTA4:	HRLZ 1,FKPGS(1)
FPTAR:	HLLM 1,0(P)		;COMBINE WITH PAGE NUMBER
	JRST POP1		;POP TO 1 AND RETURN

FPTA2:	LDB 1,[POINT 13,PSB+JSBPG,26]	;SPTN OF JSB
	HRLM 1,0(P)
	MOVEI 1,1000-PPMPG	;OFFSET
	ADDM 1,0(P)
	JRST POP1

FPTA3:	HRL 1,MMSPTN		;PERMANENT SPTN OF MON MAP
	JRST FPTAR

;LOCK, UNLOCK PAGE ON REQUEST (FOR DTA IO, ETC.)

MLKPG:	PUSH P,1
	CALL GETONT		;GET PTN.PN OR OWNING PT
	TLNN 2,17		;PAGE NOW IN CORE?
	JRST MLKPG1		;YES
	CALL SWPINP		;INITIATE SWAP AND WAIT FOR COMPL.
	POP P,1
	OKSKED
	JRST MLKPG		;TRY AGAIN

MLKPG1:	POP P,1
	MOVE 1,CST1(2)
	TLNE 1,-PLKV		;PAGE LOCKED NOW?
	JRST .+3		;YES
	AOS LOKPGS		;NO, COUNT IT
	SOS MAXNR		;REDUCE MAX AVAILABLE FOR SWAPPING
	MOVSI 1,PLKV
	ADDM 1,CST1(2)		;INCREMENT LOCK COUNT
	AOS LOKSUM
	MOVEI 1,0(2)
	CALL AGESET		;SET AGE
	JRST SKORET		;OKSKED AND RETURN

MULKPG:	PUSH P,2
	CALL GETONT		;GET OWNING PT
	TLNE 2,17		;PAGE NOW IN CORE?
	BUG(HLT,<MULKPG - TRIED TO UNLOCK PAGE NOT LOCKED>)
	CALL MULK1
	POP P,2
	JRST SKORET

MULK1:	MOVSI 1,-PLKV
	TDNN 1,CST1(2)		;LOCK COUNT NON-ZERO?
	BUG(HLT,<TRIED TO UNLOCK PAGE NOT LOCKED>)
	ADDB 1,CST1(2)		;DECREMENT LOCK COUNT
	TLNE 1,-PLKV		;NOW UNLOCKED?
	JRST MULK2		;NO
	SOS LOKPGS
	AOS MAXNR		;RESTORE PAGE TO SWAPPING POOL
	SKIPE CST2(2)		;STILL EXISTS?
	JRST MULK2		;YES
	PUSH P,4		;NO, HAS BEEN DELETED
	MOVEI 1,0(2)
	JSP 4,ONRQ		;PUT ON REPLACABLE QUEUE
	POP P,4
MULK2:	SOS LOKSUM
	RET

;UNLOCK PAGE GIVEN MONITOR ADDRESS
;ASSUMED NOSKED OR INSKED

MULKMP:	MOVEI 1,0(1)
	LSH 1,-^D9
	CAIL 1,PPRMPG+NRSPG
	CAIL 1,PPMPG
	BUG(HLT,<MULKMP - ILLEGAL MONITOR ADDRESS>)
	MOVE 1,MMAP(1)		;GET CORE ADDRESS
	TLZ 1,-1B31		;FLUSH POINTER BITS
	JRST MULKCR

;UNLOCK PAGE GIVEN CORE PAGE NUMBER IN 1

MULKCR:	CAML 1,SWPCOR		;LEGAL?
	CAIL 1,MAXCOR
	BUG(HLT,<MULKCR - ILLEGAL CORE PAGE NUMBER>)
	PUSH P,2
	MOVEI 2,0(1)
	CALL MULK1
	POP P,2
	RET

;GET OWNING PAGE TABLE
;GIVEN PTN.PN, LOCATE PT CURRENTLY HAVING ADDRESS OF PAGE

GETONT:	CALL SETCPT		;MAP GIVEN PAGE TABLE
	NOSKED
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELCPT		;YES, RELEASE CPT AND RETURN
	TLNN 2,INDBIT		;INDIRECT POINTER?
	JRST GETON1		;NO, SHARE POINTER.
	OKSKED
	LSHC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 2,SPTM
	LSH 2,^D9
	LSHC 2,^D9
	CALL RELCPT		;RELEASE CPT
	MOVE 1,2
	JRST GETONT		;TRY AGAIN

GETON1:	LDB 1,[POINT 13,2,26]	;FOR SHARE POINTER, RETURN SPTN
	MOVE 2,SPT(1)		;AND CURRENT ADDRESS
	JRST RELCPT		;RELEASE CPT AND RETURN

;SETUP PAGER FOR PROCESS

SETPPG:	HRRZ 10,FKPT(7)		;GET PROCESS NUMBER
	HRRZ 1,FKPGS(7)		;GET PSB
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PSB NOT IN CORE>)
	CALL AGESET
	HRRZM 1,PGR71		;LEAVE CORE PAGE NUMBER FOR PAGER
	HRRZ 1,FKPGS(7)
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT	;MAKE SHARE POINTER TO PSB
	MOVEM 1,MMAP+FITPG	;PUT IN PPR MAP
	MOVEM 1,FITPGA+PSBPG	;IN PSB
	HLRZ 1,FKPGS(7)		;GET PT
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PT NOT IN CORE>)
	CALL AGESET
SETPG1:	HRLM 1,PGR71		;LEAVE FOR PAGER
	HRRZ 1,FKCNO(7)
	MOVE 2,BITS-^D9(1)	;PROCESS USE BIT
	HLRZ 1,FKNR(7)		;GET PROCESS AGE
	ROTC 1,-^D9
	MOVEM 2,PGR72
	CONO PGR,0		;LOAD PAGER FROM 71,72
	MOVE 1,ACBAS		;SET AC BASE REGISTER
	SETACB 1
	RET

;DEASSIGN CORE

DECOR:	PUSH P,3		;MUST BE TRANSPARENT TO AC'S
	PUSH P,2
	PUSH P,1
	TLNE 1,17		;GIVEN MAP WORD, NOW IN CORE?
	JRST DECRR		;NO, NOTHING TO DO
	MOVE 3,CST0(1)
	TLNN 3,(70B5)		;PAGE IN USE?
	JRST DECRR		;NO
	HLRZ 2,CST3(1)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;ASSIGNED?
	JRST DECRR		;NO, NOTHING ELSE TO DO
	PUSH P,1
	CALL SOSWSP		;REDUCE N FOR THIS PROCESS
	POP P,1
	MOVSI 2,7777
	IORM 2,CST3(1)		;MAKE PAGE UNASSIGNED
	AOS CGFLG		;PAGE IS NOW GARBAGE
DECRR:	POP P,1
	POP P,2
	POP P,3
	RET

;GARBAGE COLLECT CORE, REMOVE PAGES OF PROCESSES NOT IN BAL SET

GCCOR:	MOVE 1,CGFLG
	MOVE 10,NRPLQ
	ADD 10,IOIP		;WRITES NOW IN PROGRESS
	CAML 10,NRPMIN		;REPLACABLE QUEUE BELOW MINIMUM?
	TLNE 1,-1		;OR ESSENTIAL GC REQUESTED?
	JRST GCCOR1		;YES
	SETZM CGFLG		;NO, IGNORE REQUEST
	RET

GCCOR1:	JSP 4,STIME		;TIME GCCOR ACTIVITY
	MOVN 1,BALSHC		;RESET COUNT OF PAGES RETAINED IN
	ADDM 1,SUMNR		;BALSET BECAUSE OF SHARING
	SETZB 11,BALSHC		;INIT WORD TO HOLD USE BITS OF BALSET
	MOVEI 5,BALSET		;PROCESSES
GCCOR3:	CAML 5,FBALS		;LOOKED AT ALL BALSET PROCESSES?
	JRST GCCOR2		;YES
	MOVE 1,0(5)
	TLNE 1,(1B2+1B3)	;VALID PROCESS NUMBER?
	AOJA 5,GCCOR3		;NO
	HRRZ 1,FKCNO(1)
	IOR 11,BITS(1)		;PROCESS IN BALSET
	AOJA 5,GCCOR3

GCCQ1:	AOS EXNR		;COUNT UNCOLLECTABLE PAGES
GCCQ:	HLRZ 2,CST3(6)		;GET FORK ASSIGNMENT
	ANDI 2,7777
	CAIGE 2,NFKS		;NONE?
	SKIPL FKPT(2)		;OR CURRENTLY EXISTENT FORK?
	JRST GCC1		;YES
	CALL SOSWSP
	MOVSI 1,7777		;PAGE ASSIGNED TO DELETED FORK
	IORM 1,CST3(6)		;REMOVE ASSIGNMENT
	JRST GCC1

;DECREMENT WSP AND RELEASE CORE NUMBER IF WSP 0

SOSWSP:	SOS 1,FKWSP(2)
	TRNE 1,777777		;WSP NOW 0?
	RET			;NO
	HLRZ 1,FKPT(2)
	CAIE 1,GOLST		;PROCESS STILL ACTIVE?
	CAIGE 1,NBP
	RET			;YES, DON'T RELEASE NUMBER
	HRRZ 1,FKCNO(2)
	JUMPE 1,R		;NO NUMBER (?)
	HLLZS FKCNO(2)
	MOVE 1,BITS(1)
	IORM 1,FRECB
	RET

GCCOR2:	ANDCAM 11,PUBCL		;FOR PROCESSES WHICH CAME BACK IN BALSET
	SETZM EXNR		;INIT COUNT OF UNCOLLECTABLE PAGES
	MOVE 6,SWPCOR		;START AFTER RES MON
	SETZ 5,			;BITS FOR PROCESSES
GCC2:	MOVE 1,CST0(6)		;GET STATUS
	TLNN 1,700000		;IN USE?
	JRST GCC1		;NO
	JUMPE 10,GCCS		;GET AT LEAST 1 PAGE IF NONE NOW AVAIL
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;PAGE NOW ASSIGNED?
	JRST GCCS		;NO, COLLECT IT
	MOVE 1,PUBCL		;PROCESS BITS TO BE CLEARED
	ANDCAB 1,CST0(6)
	SKIPGE 3,FKPT(2)	;FORK HAS BEEN DELETED?
	JRST GCCS		;YES, COLLECT
	HLRZ 3,3		;CURRENT LOCATON
	CAIE 3,WTLST		;ON WAIT LIST, OR
	TDNN 1,11		;NO USERS IN BALSET?
	JRST GCCS		;YES, COLLECT
	CAIL 3,NBP		;OWNER IN BALSET?
	JRST GCCOR4		;NO
	HRRZ 3,FKPT(2)
	MOVSI 1,(1B3)
	TDNE 1,BALSET(3)	;OWNER LEAVING BALSET?
GCCOR4:	AOS BALSHC		;YES, COUNT PAGE AS ONE IN BALSET BUT
	JRST GCC1		;NOT ASSIGNED TO BALSET PROCESS

GCCS:	MOVE 2,CST1(6)		;BACKUP ADDRESS
	SKIPGE DRUMP		;DRUM ON SYSTEM?
	TLNE 2,16		;NO, IS NO BACKUP ADR, OR
	TLNE 2,-PLKV		;PAGE LOCKED?
	JRST GCCQ1		;YES, LEAVE IT
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;PAGE BEING WRITTEN?
	JRST GCCQ		;YES, LEAVE IT
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIGE 2,NFKS		;ASSIGNED?
	CALL SOSWSP
	MOVEI 1,0(6)		;SWAPOUT
	PUSH P,5
	CALL SWPOUT
	AOJ 10,			;COUNT PAGES COLLECTED
	POP P,5
GCC1:	CAIGE 6,MAXCOR-1
	AOJA 6,GCC2
	MOVE 1,BALSHC
	ADDM 1,SUMNR		;UPDATE TOTAL RESERVE FOR SHARED PAGES
	SETZM PUBCL
	SETZM CGFLG
	JSP 4,ETIME		;END TIMING OF GCCOR
	ADDM 1,SKDTM2		;CLOCK FOR GCCOR TIME
	RET

;INITIATE SWAP OF PAGE
;CALLED IN SCHEDULER FROM GCCOR

SWPOUT:	SKIPN 2,CST2(1)		;GET BACKUP
	JRST BKUPN		;PAGE HAS NO BACKUP, FLUSH IT
	TLNE 2,-1		;SPT?
	JRST SWPU1		;NO
	MOVE 3,SPT(2)
	TLNN 3,-1B31		;SHARE COUNT 0?
	JRST BKUPD		;YES, SWAP TO DISK
	CAIL 2,NOFN		;OFN?
	JRST BKUPS		;NO, SHARED PAGE. GO CHECK REQUEST BIT
BKUP0:	MOVE 2,CST1(1)		;CORE PAGE NUMBER IN 1, GET BACKUP ADR
	TLNE 2,16
	TLNE 2,10		;DISK OR NOTHING?
	JRST SWPO4		;YES
	MOVE 3,CST0(1)		;NO, DRUM.
	TLNE 3,CORWB		;PAGE WRITTEN INTO?
	JRST SWPO1		;YES
SWPOQ:	TLNE 3,77B23		;PAGE NOW ON REPLACABLE QUEUE?
	JSP 4,ONRQ		;NO, PUT IT THERE
SWPO3:	RET

SWPU1:	HLRZ 2,2		;GET PTN
	CAIGE 2,NOFN		;FILE?
	JRST BKUPD		;YES, SWAP TO DISK
BKUPS:	MOVE 2,CST3(1)
	TLNE 2,DSKSWB		;SWAP TO DISK REQUESTED?
	JRST BKUPDR		;YES
	JRST BKUP0		;PROCESS, SWAP TO DRUM

SWPO1:	CALL GDSTX
SWPO5:	MOVSI 3,BWRBIT		;SET BACKUP WRITTEN BIT
	IORM 3,DST(2)
SWPO2:	MOVSI 3,CORWB
	ANDCAM 3,CST0(1)	;CLEAR WRITTEN BIT
	MOVEI 3,4
	DPB 3,[POINT 6,CST0(1),5]	;SET TRAP CODE TO WRITE IN PROG.
	AOS IOIP		;NOTE WRITE IN PROGRESS
	HRLI 1,DWRBIT		;WRITE REQUEST BIT
	CALL DRMIO		;INITIATE DRUM WRITE
	AOS DRMWR		;COUNT DRUM WRITES FOR STATISTICS
	JRST SWPO3

SWPO4:	MOVSI 3,SWPERR
	TDNE 3,CST3(1)		;ERROR READING FROM DISK?
	JRST BKUPN		;YES, DON'T WRITE IT
	MOVE 3,DRMFRE
	CAMGE 3,DRMIN0		;DRUM NEARLY FULL?
	TLNN 2,10		;YES, SEND TO DISK IF HAVE DISK ADDRESS
	SKIPGE DRUMP		;SWAPPING POSSIBLE?
	JRST BKUPD		;NO, SEND PAGE TO DISK
	PUSH P,1
	SETZ 1,
	CALL DRMASN		;ASSIGN DRUM ADDRESS
	BUG(HLT,<DRUM COMPLETELY FULL>)
	MOVE 2,1
	POP P,1
	MOVE 4,CST1(1)		;GET PREVIOUS BACKUP ADDRESS
	MOVEM 2,CST1(1)		;SET DRUM AS NEW BACKUP ADDRESS
	CALL GDSTX
	MOVEM 4,DST(2)		;PREVIOUS BACKUP ADDRESS TO DST
	MOVE 3,CST0(1)
	TLNE 3,1B27		;PAGE WRITTEN WHILE IN CORE?
	JRST SWPO5		;YES, SET BACKUP WRITTEN BIT ALSO
	JRST SWPO2		;NO

;SWAP PAGE TO DISK

BKUPD:	MOVSI 2,DSKSWB
	ANDCAM 2,CST3(1)	;FLUSH REQUEST BIT IF ANY
BKUPDR:	MOVE 2,CST1(1)		;GET BACKUP ADDRESS
	TLNN 2,16		;NONE?
	JRST BKUP7		;YES
	TLNE 2,10		;DISK?
	JRST BKUP3		;YES
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST BKUP0		;NO, SEND PAGE TO DRUM
	CALL GDSTX		;DRUM
	MOVE 3,DST(2)		;GET NEXT LEVEL BACKUP ADDRESS
	MOVSI 4,CORWB
	TLZE 3,BWRBIT		;WRITTEN SINCE BACKUP?
	IORM 4,CST0(1)		;YES, SET CORE WRITTEN BIT
	SETOM DST(2)		;RELEASE DST SLOT
	EXCH 3,CST1(1)
	PUSH P,1
	MOVE 1,3
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,1
	JRST BKUPDR

BKUP7:	SKIPG DISKP		;DISK ON SYSTEM?
	JRST BKUP0		;NO, SEND TO DRUM
	BUG(HLT,<BKUPD - BAD CST1 ENTRY OR INCONSISTENT CST>)

BKUP3:	MOVSI 3,CORWB		;CLEAR CHANGED IN CORE BIT
	MOVSI 2,SWPERR
	TDNN 2,CST3(1)		;DON'T WRITE IF ERROR FROM READ
	TDNN 3,CST0(1)		;CHANGED?
	JRST BKUPN		;NO, DON'T HAVE TO WRITE
	ANDCAM 3,CST0(1)
	HRLI 1,DWRBIT		;REQUEST WRITE
	AOS DSKWR		;COUNT IT FOR STATISTICS
	AOS IOIP		;NOTE WRITE IN PROGRESS
	MOVEI 3,4		;OTHERWISE INDICATE WRITE IN PROGRESS
	DPB 3,[POINT 6,CST0(1),5]
	CALL DSKIO
	JRST SWPO3

BKUPN:	MOVE 3,CST0(1)
	JRST SWPOQ		;GO PUT PAGE IN QUEUE

;PAGER TRAP

PGRTRP:	XWD TRAPPC,.+1
	SKIPN INSKED
	CONSZ PI,177B27		;FROM PI ROUTINE?
	BUG(HLT,<PAGER TRAP FROM SCHEDULER OR WHILE PI IN PROGRESS>)
	AOSLE NSKED
	AOSGE INTDF
	BUG(HLT,<PAGER TRAP WITH BAD NSKED OR INTDF>)
	AOSE TRAPC		;FIRST TRAP?
	JRST PGRT4		;NO, GO CHECK RECURSIVE OR ITERATIVE
	MOVEM P,TRAPAP		;SAVE AC-P
	MOVE P,TRAPSP		;SETUP TRAP STACK
	AOS UTRPCT		;COUNT TRAPS (BUT NOT RECURSIVE ONES)
	PUSH P,7		;SAVE AC'S 1-7
PGRT2:	MOVEI 7,1(P)		;ON STACK
	HRLI 7,1		;START WITH AC1
	ADD P,BHC+6
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	MOVE 1,TRAPPC		;RETURN
	PUSH P,1		;SAVE IT
	TLNE 1,UMODF		;FROM USER?
	MOVEM 1,UPDL		;YES, LEAVE IT WHERE IT CAN BE FOUND
PGRT3:	SKIPE TRAPC		;IF RECURSIVE TRAP,
	PUSH P,TRAPSW		;OLD STATUS WORD
	PUSH P,TRAPWD		;WRITE DATA
	MOVE 1,TRAPS0		;FROM WHERE PAGER STORED IT
	TLNE 1,(1B10+1B12)	;PI CYC OR NXM?
	BUG(HLT,<PAGER TRAP ON PI CYCLE OR NXM>)
	MOVEM 1,TRAPSW		;TO SAFE PLACE
	SKIPE TRAPC
	JRST .+3		;NESTED TRAP, DON'T COUNT TIME TWICE
	JSP 3,UCLOCK		;INIT CLOCK TO TIME TRAP CODE
	PUSH P,FKRT
	SETZM TRAPPC		;INDICATE TRAP STARTED
PGRTD:	HLLZ 1,TRAPSW		;GET TRAP STATUS
	TLNE 1,(1B9)		;PARITY ERROR?
	JRST PGRME		;YES
	SETZ 2,
	ROTC 1,2		;GET TOP 2 BITS
	MOVE 3,TABA(2)		;APPROPRIATE DISPATCH TABLE
	JFFO 1,.+2		;FIND TRAP-CAUSING BIT
	BUG(HLT,<PAGER TRAP WITH BAD OR MISSING TRAP STATUS WORD>)
	MOVE 7,FORKX		;GET FORK AND PROCESS NUMBER
	JRST 0(3)

PGRT4:	PUSH P,7		;TRAPSK ALREADY EXISTS
	HRRZ 7,TRAPPC		;CHECK TRAP PC FOR EITHER OF THE
	CAIE 7,PGMV1+1		;WRITE INSTRUCTIONS DONE TO
	CAIN 7,PGMV2+1		;FINISH UP A WRITE TRAP
	SOSA TRAPC		;TRAP IS ITERATIVE NOT RECURSIVE
	JRST PGRT2		;TRUE RECURSIVE TRAP
	SOS NSKED		;UNDO EFFECTS OF ENTERING TRAP CODE
	SOS INTDF
	POP P,7			;ADJUST VARIABLES AND REPROCESS TRAP
	JRST PGRT3

PGRME:	AOS DEVMPE		;REQUEST CORE SCAN
	ISB APRCHN
	BUG(CHK,<PARITY ERROR DETECTED BY PAGER>)
	JRST PGUNTP		;TRY AGAIN

;DISPATCH PROCEDURE FOR TRAP STATUS BITS

TABA:	EXP TRP0,TRP1,TRP2,TRP3

TRP1:	CAIL 2,7
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB1(2)

TAB1:	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	JRST NIC		;SHARED NOT IN CORE
	JRST NIC		;PAGE TABLE NOT IN CORE
	JRST NIC		;2ND INDIRECT PRIV NOT IN CORE
	JRST NIC		;INDIRECT SHARED NOT IN CORE
	JRST NIC		;IND PT NIC
	JRST ILIND		;EXCESSIVE IND.

TRP2:
TRP3:	CAIL 2,7		;INDIRECT OR ORIGINAL PT EQUIVALENT
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB2(2)

TAB2:	JRST NIC		;PRIVATE NOT IN CORE
	JRST WCPY		;WRITE COPY TRAP
	JRST UTRP		;USER TRAP
	JRST NPG		;ACCESS (OR BIT 10-11 = 3)
	JRST ILRD		;ILLEGAL READ OR XCT
	JRST ILWR		;ILLEGAL WRITE
	BUG(HLT,<PAGER TRAP ON ALR VIOLATION OR ILLEGAL FORMAT>)

;TRAP CODE 0, CST WORD BITS 0-2 = 0

TRP0:	CALL GETTPD		;DECODE EFFECTIVE ADDRESS
	TLNE 2,17		;PAGE MUST BE IN CORE
	BUG(HLT,<CST LESS THAN 100 PAGER TRAP BUT PAGE NOT IN CORE>)
	HLRZ 1,CST0(2)		;GET AGE CODE
	LSH 1,-^D12
	CAIL 1,10
	BUG(HLT,<CST LESS THAN 100 PAGER TRAP, CST0 INCONSISTENT>)
	CAIE 1,6		;READ IN PROGRESS OR READY?
	CAIN 1,2
	JRST TRP0R		;YES, SPECIAL RESHEDULE
	PUSH P,[PGUNTP]		;RETURN TO DE-TRAP ROUTINE
	PUSH P,2
	JRST AGESX

TRAPSP:	IOWD NTSK,TRAPSK	;POINTER TO LOCAL STACK

;ASSIGN PAGE AND SET AGE

AGESET:	MOVE 7,FORKX
AGESN:	PUSH P,2
	MOVEI 2,0(1)
AGES1:	HLRZ 1,CST0(2)
	LSH 1,-^D12
	CAIL 1,10		;NOW ASSIGNED?
	JRST [	HLRZ 1,CST3(2)	;YES, FIND OUT WHERE
		ANDI 1,7777
		CAML 2,SWPCOR	;NOT SWAPPABLE PAGE? OR
		CAIN 1,0(7)	;THIS PROCESS?
		JRST AGES2	;YES, OK
		CAIL 1,NFKS	;ANY PROCESS?
		JRST ATP1	;NO
		PUSH P,2
		MOVEI 2,0(1)
		CALL SOSWSP	;REDUCE WSP
		POP P,2
		JRST ATP1]	;GO ASSIGN TO THIS PROCESS
AGESX:	XCT TRP0T(1)
AGES2:	MOVEI 1,0(2)
	POP P,2
	RET

TRP0T:	JRST ATP0		;AVAILABLE AND ON REPLACABLE QUEUE
	JRST ATP1R		;AVAILABLE, NOT ON REPLACABLE QUEUE
	JRST ATP2		;READ COMPLETED
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP4		;WRITE IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP2		;READ IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)

TRP0R:	MOVSI 1,0(2)
	HRRI 1,SWPRT
	JSYS SCHEDR
	NOSKED
	JRST NIC2

ATP1R:	MOVSI 1,SWPERR		;CHECK FOR ERROR ON READ
	TDNN 1,CST3(2)
	JRST ATP1		;NO ERROR
	PUSH P,2
	MOVEI 1,^D11		;FILE DATA ERROR PSI CHANNEL
	MOVEI 2,0(7)		;GET FORK NUMBER
	CALL PSIRQ		;INTERRUPT THE FORK
	RESKED
	POP P,2
	JRST ATP1

ATP2:	MOVSI 1,0(2)
	HRRI 1,SWPRT		;READ NOW IN PROGRESS OR COMPLETED
	JSYS SCHEDP		;RESCHEDULE UNTIL AVAILABLE
	JRST AGES1		;CHECK AGE AGAIN

ATP4:	MOVSI 1,(1B5)		;WRITE IN PROGRESS, CHANGE CODE SO AS TO
	EXCH 1,CST0(2)		;PREVENT COMPLETION ACTION
	TLNE 1,4B23		;IF WRITE STILL NOT COMPLETED,
	JRST [	SOS IOIP	;REDUCE WRITE IN PROGRESS COUNT
		JRST ATP1]	;GO ASSIGN PAGE
ATP0:	SOS NRPLQ		;ONE LESS PAGE ON REPLACABLE
	PIOFF
	MOVE 1,CST3(2)		;UNQUEUE PAGE FROM REPLACABLE
	HLLM 1,0(1)
	MOVS 1,1
	HLRM 1,0(1)
	PION
	SETZM CST3(2)
ATP1:	AOS 1,FKWSP(7)		;INCREASE OWNERSHIP COUNT
	PUSH P,2
	MOVEI 1,0(1)
	PUSH P,1
	HRRZ 2,FKPT(7)		;GET PROCESS NUMBER
	MOVSI 1,1B21
	TDNE 1,BALSET(2)	;HALF REMOVED PROCESS?
	JRST ATP1A		;YES
	MOVSI 1,1
	ADD 1,FKNR(7)		;INCREASE AGE
	TLNE 1,1000		;ABOVE MAX?
	HRLI 1,100		;YES, WRAPAROUND
	MOVEM 1,FKNR(7)
	MOVEI 1,0(1)		;GET CURRENT RESERVE VALUE
	CAML 1,0(P)		;LESS THAN CURRENT SIZE?
	JRST ATP1A		;NO, OK
	SUB 1,0(P)		;YES, CALCULATE DIFFERENCE
	MOVN 1,1
	ADDM 1,FKNR(7)		;INCREASE RESERVE
	ADDM 1,SUMNR
ATP1A:	SUB P,BHC+1		;FLUSH GARBAGE
	HLRZ 1,FKNR(7)		;GET UPDATED AGE
	POP P,2			;RESTORE PAGE NUMBER
	DPB 1,[POINT 9,CST0(2),8]	;NEW AGE OF PAGE
	DPB 1,[POINT 9,PGR72,8]	;FOR PAGER
	DPB 7,[POINT 12,CST3(2),17]	;ASSIGN PAGE TO PROCESS
	JRST AGES2

;ILLEGAL REFERENCE TRAPS

ILRD:	MOVEI 1,^D16		;MR TRAP CHANNEL
	MOVE 2,TRAPSW
	TLNE 1,2		;EXECUTE REFERENCE?
	MOVEI 1,^D18		;YES, MX
ILRF:	CALL PSIRQ0		;REQUEST INTERRUPT, THIS FORK
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;IN CASE USER WANTS TRAP STATUS
	MOVE 2,-1(P)		;WRITE DATA (ASSUMING TOP-LEVEL TRAP)
	MOVEM 2,UTRWD
	MOVE 2,-2(P)		;PC
	TLNN 2,UMODF		;USER?
	SKIPGE INTDF		;OR INTERRUPTABLE?
	JRST .+3		;YES
	TLNE 1,12		;MUST DEFER INTERRUPT, READ REF?
	AOS -2(P)		;YES, DONOT RESTART INSTRUCTION
	TLO 1,12		;SET BITS TO PREVENT WRITE-COMPLETION
	MOVEM 1,TRAPSW		;ACTION ON UNTRAP
	JRST PGUNTP

ILWR:	MOVE 1,TRAPSW
	TLNE 1,1		;MON REF BELOW 400000?
	TRNE 1,400000
	SKIPA 1,[^D17]		;NO, INITIATE MW INTERRUPT
	BUG(HLT,<ATTEMPTED MODIFY REFERENCE TO PROTECTED MONITOR>)
	JRST ILRF

ILIND:	MOVE 1,TRAPSW		;SEE IF READ OR WRITE
	TLNE 1,12
	JRST ILRD		;GIVE READ TRAP INTERRUPT
	JRST ILWR		;OR WRITE TRAP INTERRUPT

UTRP:	MOVEI 3,TRAPUB
	CALL GETTD1		;FIND PAGE WITH TRAPUB SET
	HLRZ 6,1
	CAIGE 6,NOFN		;COULDN'T BE IN FILE XB
	BUG(HLT,<TRAP-TO-USER IN FILE INDEX BLOCK>)
	CALL SETSPG		;MAP PT HOLDING PTR
	MOVSI 2,TRAPUB
	ANDCAM 2,CSWPGA(1)	;CLEAR THE BIT
	CALL RELSPG
	MOVEI 1,^D21
	CALL PSIRQ0		;INTERRUPT ON CHN 21
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;SAVE TRAP STATUS WORD ONLY
	JRST PGUNTP		;FINISH UP WRITE IF ANY AND UNTRAP

;PAGE NOT IN EXISTANCE TRAPS

NPG:	MOVE 1,TRAPSW
	TLNE 1,1		;MONITOR?
	JRST [	MOVEI 1,0(1)	;YES, LEGAL PAGE?
		CAIL 1,<PPMPG>B26
		CAIL 1,<PPMPG+4>B26
		JRST NPG1	;YES
		JRST MILRF1]	;MONITOR MALFUNCTION
NPG1:	CALL GETTPD		;NEW PAGE NEEDED
	HLRZ 6,1		;GET PT NUMBER
	CAIGE 6,NOFN		;MUST BE PT, NOT OFN
	JRST NPG2
	CALL SETSPG		;MAP IT
	SKIPE 2,CSWPGA(1)	;BE SURE PT SLOT NOW EMPTY
	JRST NPGBAD		;IT'S NOT, PROBABLY SPURIOUS TRAP
	MOVSI 2,RWXB+1
	MOVEM 2,CSWPGA(1)	;SETUP NULL POINTER
	CALL RELSPG		;RELEASE MAP
	MOVE 1,PSICHM
	TRNN 1,1B22		;CHANNEL 22 ON?
	JRST NIC		;NO
	MOVEI 1,^D22		;YES, REQUEST INTERRUPT
	CALL PSIRQ0
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW
	JRST NIC

MILRF1:	BUG(HLT,<ILLEGAL ADDRESS REFERENCE IN MONITOR>)

NPGBAD:	TLNN 2,ACCESB		;ACCESS BIT ON?
	BUG(HLT,<BAD POINTER IN PAGE TABLE>)
	BUG(CHK,<PROBABLE SPURIOUS PAGER TRAP>)
	CALL RELSPG		;CLEAN UP
	JRST PGUNTP		;GO UNTRAP AND TRY AGAIN

;THIS COULD CONCEIVABLY HAPPEN ON AN IND PTR TO A FILE FROM WHICH
;THE PAGE WAS REMOVED

NPG2:	JRST ILIND		;CAN ONLY GIVE TRAP TO USER

;COPY-ON-WRITE TRAP

WCPY:	MOVE 1,TRAPSW
	TLNE 1,(1B4+1B6)	;OTHER TRAPS ALSO?
	JRST [	TLZ 1,(1B3)	;YES, CLEAR WRITE COPY
		MOVEM 1,TRAPSW	;FROM TRAP CAUSE
		JRST PGRTD]	;AND GO HANDLE THE OTHER CAUSE
	MOVEI 3,COPYB
	CALL GETTD1		;WILL STOP ON FIRST POINTER WITH COPYB
	HLRZ 6,1		;PTN
	CAIG 6,NOFN
	BUG(HLT,<COPY-WRITE POINTER IN INDEX BLOCK>)
	CALL SETSPG		;MAP THE PT
	MOVSI 2,RWX
	AND 2,CSWPGA(1)		;GET ACCESS OF SOURCE PAGE
	IOR 2,[XWD WRITEB+ACCESB+1,1] ;MAKE PRIV PTR WITH UNASS ADR
	EXCH 2,CSWPGA(1)	;EXCH IT WITH THE WC POINTER
	TLNN 2,SHRBIT+INDBIT	;IT SHOULD BE SHARED OR INDIRECT
	JRST WCPY4		;BUT IT'S NOT
	TLO 2,READB		;MAKE SURE WE CAN READ FROM THE PAGE
	MOVEM 2,PSB+CPYPG	;PUT THE ORIG POINTER IN MON MAP
	CALL RELSPG
	PUSH P,1		;SAVE ORIG PTN.PN
WCPY2:	MOVEI 1,CPYPG		;CONSTRUCT IDENT FOR COPY SOURCE PAGE
	HRL 1,FKPGS(7)
	CALL GETPGD		;TRACK IT DOWN
	TLNE 2,17		;IN CORE?
	JRST [	CALL SWPINP	;NO, SWAP IT IN
		JRST WCPY2]	;THEN LOOK AGAIN
	MOVEI 1,0(2)
	CALL AGESET		;FIX THE PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;AND LOCK IT DURING NEXT SWAPIN
	EXCH 1,0(P)		;SAVE CORE PN, GET ORIG PTN.PN
	CALL SWPINP		;THIS WILL COPY FROM CPYPG TO A NEW PAGE
	POP P,1
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK THE SOURCE PAGE
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
	CALL MRPT		;GET IDENT OF SHARE PAGE BEING RELEASED
	SETZ 1,			;INDIRECT TO FORK
	PUSH P,1
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
	CALL RELMPG		;RELEASE THE ORIG PAGE FROM MON MAP
	CALL RELCPT		;CLEANUP FROM RELMPG
	OKSKED
	POP P,1
	JUMPE 1,WCPY3		;IGNORE INDIRECT TO FORK PTR
	MOVE 5,0
	MOVE 6,11		;SAVE AC'S USED BY OFNJFN
	CALL JFNDCR		;DECREMENT MAP COUNT FOR JFN
	MOVE 0,5
	MOVE 11,6		;RESTORE AC'S
WCPY3:	NOSKED
	JRST NIC		;UPDATE STATS AND CONTINUE

WCPY4:	TLZ 2,COPYB		;MAKE IT LOOK LIKE WE COPIED IT
	TLO 2,WRITEB
	MOVEM 2,CSWPGA(1)
	CALL RELSPG
	JRST NIC2

;NOT IN CORE TRAP

NIC:	JSP 3,UCLOCK		;UPDATE CLOCKS
	HLRZ 1,FKWSP(7)		;CURRENT TAV OF PROCESS
	HRRZ 3,FKWSP(7)		;CURRENT N OF PROCESS
	IMULI 1,0(3)		;COMPUTE (TAV*(N-1) + T)/N
	ADD 1,PGTIM
	SETZM PGTIM
	IDIVI 1,1(3)
	HRLM 1,FKWSP(7)		;BECOMES NEW TAV
	CAMLE 1,PTAV		;IF PROCESS'S TAV IS .G. THE PARAMETER,
	JRST NIC3		;IMPLIES CURRENT W.S. EST TOO LARGE
NIC3A:	HRRZ 1,FKNR(7)		;CURRENT RESERVE
	HRRZ 3,FKWSP(7)		;PAGES NOW ASSIGNED
	CAIG 1,0(3)		;RESERVE SUFFICIENT FOR NEW PAGE?
	JRST NIC3C		;NO, ADJUST
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE
	CAIL 2,2		;ON HIGHER QUEUES? OR
	CAMGE 1,TOTRC2		;RESERVE NOW 'SMALL'?
	JRST NIC92		;YES, ALLOW NEW PAGE
	SKIPE NGOJOB		;FORKS WAITING FOR BAL SET?
	JRST NIC3		;YES, COLLECT
	MOVE 3,NBPROC
	CAIG 3,1		;OTHER FORKS IN BALSET NOW?
	JRST NIC92		;NO, PERMIT NEW PAGE
	ADD 3,SUMNR
	CAMGE 3,MAXNR		;BAL SET HAS ROOM FOR ANOTHER PAGE?
NIC92:	CAML 1,NPMAX		;WITHIN MAX SIZE FOR FORK?
	JRST NIC3		;NO, COLLECT
NIC2:	CALL GETTPD		;DECODE TRAP ADDRESS
	TLNE 2,17		;PAGE IN CORE?
	JRST NIC6		;NO
	MOVEI 1,0(2)		;YES
	CALL AGESET		;SET AGE
	JRST PGUNTP		;RESUME PROCESS

NIC6:	MOVE 3,NRPLQ
	CAMG 3,MINNRC		;PAGE AVAILABLE?
	JRST NIC7		;NO
NIC8:	CALL SWPINW		;SWAP IN THE PAGE
	JRST NIC2

PTAV:	EXP ^D66		;IDEAL TAV BETWEEN PAGE FAULTS

NIC7:	MOVE 3,NSKED
	CAILE 3,1		;RESHEDULABLE PROCESS?
	JRST NIC8		;NO, START SWAP
	OKSKED
	AOS CGFLG		;REQUEST GC
	MOVEI 1,NIC7T
	JSYS SCHEDP		;WAIT FOR ROOM
	NOSKED
	JRST NIC2		;TRY AGAIN

NIC7T:	HRRZ 2,FKPT(7)		;BALSET NUMBER
	MOVSI 1,1B21
	TDNE 1,BALSET(2)	;PROCESS TO BE REMOVED?
	JRST 1(4)		;YES,LET IT HAPPED
	MOVE 1,NRPLQ
	CAMG 1,MINNRC		;ROOM NOW?
	JRST 0(4)		;NO
	JRST 1(4)

NIC3:	HRRZS 3,FKWSP(7)	;SET TAV TO 0
	HRRZ 1,FKNR(7)		;RESERVE
	CAIE 3,-1(1)		;USED ALL OF RESERVE?
	JRST NIC3C		;NO, ADJUST FIRST
	MOVEI 1,0(3)		;COMPUTE CUTOFF DIFFERENCE AS
	ASH 1,-3		;1/8 CURRENT SIZE
	PUSH P,3		;SAVE SIZE NOW
	CALL XGC		;COLLECT PAGES
	POP P,3			;SIZE BEFORE COLLECTION
	HRRZ 1,FKWSP(7)		;SIZE NOW
	CAIL 1,0(3)		;LESS THAN BEFORE?
	JRST [	SETZ 1,		;NO, SET CUTOFF DIFFERENCE TO 0
		CALL XGC	;AND COLLECT AGAIN. SHOULD GET ALL
		JRST NIC3B]	;PAGES
NIC3B:	HRRZ 1,FKWSP(7)		;COMPUTE 1.25 (5/4) CURRENT SIZE
	IMULI 1,5
	ASH 1,-2
	HRRZ 3,FKNR(7)		;ADJUST RESERVE
	SUB 1,3
	ADDM 1,SUMNR
	ADDM 1,FKNR(7)
	JRST NIC3A

NIC3C:	SUBI 3,-1(1)		;SET RESERVE TO BE CURRENT SIZE +1
	ADDM 3,SUMNR
	ADDM 3,FKNR(7)
	JRST NIC3A

;COLLECT OLD PAGES FOR THIS PROCESS, CALLED WITH CUTOFF DIFFERENCE IN 1
;THE PAGES ASSIGNED TO THIS PROCESS ARE ASSUMED TO HAVE AGES RANGING
;FROM M1 TO M2.  M2 IS THE CURRENT AGE, LH OF FKNR. WE WISH TO
;FLUSH ALL PAGES OLDER THAN M, WHERE M1<M<M2.  IF EACH PAGE     >>
;HAS BEN REFERENCED ONLY ONCE, THE AGES WOULD BE EVENLY DISTRIBUTED
;BETWEEN M1 AND M2.  HOWEVER, PAGES ACTIVELY BEING USED SHOULD
;HAVE AGES CLOSER TO M2.  THEREFORE, WE PICK A CUTOFF AGE BY
;SUBTRACTING A SMALL NUMBER FROM M2.  TO PREVENT EXCESSIVE COLLECTION
;WHERE ALL PAGES HAVE BEEN REFERENCED RECENTLY, WE SET A LIMIT
;ON THE TOTAL NUMBER OF PAGES WHICH CAN BE FLUSHED, AND STOP
;IF WE HIT THIS LIMIT. ALSO, SINCE AGES CAN WRAP AROUND THE 9-BIT
;FIELD, AGES GREATER THAN M2 ARE ASSUMED TO BE LEFT FROM THE PREVIOUS
;WRAP AROUND AND ARE ADJUSTED ACCORDINGLY.

XGC:	HRRZ 4,FKCNO(7)
	PUSH P,BITS(4)		;PROCESS USE BIT FOR THIS PROCESS
	MOVE 6,SWPCOR		;FIRST SWAPPING PAGE
	HRRZ 4,FKWSP(7)		;NUMBER PAGES NOW IN CORE
	ASH 4,-1		;COMPUTE 1/2 CURRENT SIZE
	PUSH P,4		;MAX NUMBER OF PAGES TO COLLECT
	HLRZ 3,FKNR(7)		;CURRENT AGE CLOCK
	PUSH P,3
	SUBI 3,0(1)		;CUTOFF AGE, 'OLD'=NOW-DIFFERENCE
	PUSH P,3
XGC2:	HLRZ 1,CST0(6)
	TRNN 1,700000		;PAGE IN USE?
	JRST XGC1		;NO
	HLRZ 2,CST3(6)
	ANDI 2,7777
	CAIE 2,0(7)		;ASSIGNED TO THIS PROCESS?
	JRST XGC1		;NO
	LSH 1,-^D9		;YES, GET AGE FIELD
	MOVE 2,-3(P)		;PROCESS USE BIT
	ANDCA 2,CST0(6)		;LOOK AT OTHER PROCESS USE BITS
	TDNE 2,[377777777]	;IF ANY ON, MEANS REFERENCES BY OTHER
	HLRZ 1,FKNR(7)		;PROCESSES, AGE INVALID SO USE CURRENT
	CAMLE 1,-1(P)		;IF .G. NOW, MUST NOT HAVE WRAPPED
	SUBI 1,1000-100		;SO WRAP IT
	CAMLE 1,0(P)		;.G. OLD?
	JRST XGC1		;YES, SAVE IT
	MOVE 2,CST1(6)
	SKIPGE DRUMP		;DON'T SWAP PAGE IF NO DRUM AND
	TLNE 2,16		;NO BACKUP ADDRESS FOR PAGE
	TLNE 2,-PLKV		;DON'T SWAP PAGE IF LOCKED
	JRST XGC1
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;DON'T SWAP PAGE IF NOW BEING WRITTEN
	JRST XGC1
	SOS FKWSP(7)		;DEASSIGN PAGE FROM THIS PROCESS
	MOVEI 1,0(6)
	CALL SWPOUT		;SWAP IT OUT
	SOSG -2(P)		;COLLECTED ENOUGH PAGES?
	JRST XGC3		;YES
	OKSKED			;DON'T HOG MACHINE FOR TOO LONG
	NOSKED
XGC1:	CAIGE 6,MAXCOR-1	;LOOKED AT ALL CORE?
	AOJA 6,XGC2		;NO, LOOK AT NEXT PAGE
XGC3:	SUB P,BHC+4		;FLUSH STACK
	CONO PGR,0		;CLEAR AR'S
	RET

;RESUME PROCESS AFTER PAGER TRAP

PGUNTP:	SKIPE TRAPC		;OUTER LEVEL TRAP?
	JRST PGU4		;NO
	JSP 3,UCLOCK		;COMPLETE TIMING OF TRAP CODE
	POP P,1			;FKRT AT TIME OF ENTRY
	MOVE 2,FKRT
	SUB 2,1			;TIME OF TRAP CODE
	ADDM 2,PTTIM		;PAGE TRAP TIME FOR THIS FORK
	ADDM 2,SPTTIM		;PAGE TRAP TIME FOR SYSTEM
PGU4:	CONO PGR,0		;LOAD WITH NEW AGE
	POP P,2			;RECOVER WRITE DATA
	MOVE 3,TRAPSW		;GET TRAP BITS
	SKIPE TRAPC		;IF RECURSIVE TRAP,
	POP P,TRAPSW		;RESTORE OLD STATUS WORD
	TLNE 3,12		;READ OR XCT?
	JRST PGU1		;YES, RESTART INSTRUCTION
	TLNE 3,1		;USER OR MONITOR?
	JRST PGU2		;MONITOR
PGMV1:	UMOVEM 2,0(3)		;USER
PGU1:	POP P,1			;GET RETURN
	TLNN 1,UMODF		;TO USER?
	JRST PGU3		;NO, MONITOR
	MOVEM 1,FPC		;USER, CAN PUT RETURN IN FPC
	MOVSI 7,-5(P)		;RESTORE AC'S
	HRRI 7,1
	BLT 7,6
	MOVE 7,-6(P)
	MOVE P,TRAPAP		;USER MODE, SO MUST BE TOP LEVEL TRAP
	SETOM TRAPC
	SETOM INTDF		;FOR USER, MUST BE -1
	OKSKED
	XCT MJRSTF		;RETURN, WILL GET DEFERRED INTERRUPT TOO

PGMV2:
PGU2:	MOVEM 2,0(3)		;STORE MONITOR WRITE DATA
	JRST PGU1

PGU3:	AOS INSKED		;ENTER SCHEDULER FLAG
	SOS NSKED		;LIKE OKSKED
	MOVEM 1,PPC		;SETUP TO RETURN THROUGH SCHEDULER
	MOVSI 7,-5(P)		;RESTORE AC'S
	HRRI 7,1
	BLT 7,6
	SUB P,BHC+6
	POP P,7
	SOSGE TRAPC		;TOP LEVEL TRAP?
	MOVE P,TRAPAP		;RESTORE AC-P
	SOS INTDF		;REDUCE NO-PSI COUNT
	JRST RSKD1		;EXIT THROUGH SCHEDULER

;GET PAGE DATA
;TRACES PTN.PN IN 1 TO NOT IN CORE OR CORE PAGE NUMBER OR WRITE COPY
;RETURN AS GETTPD

GETPGD:	HLRZ 2,1		;PTN TO 2
	MOVEI 1,0(1)		;PN TO 1
	SETZ 3,			;NO SPECIAL BITS TO STOP ON
	JRST GETPD1		;FOLLOW LIKE IND POINTER

;GET TRAP DATA
;RETURNS OFN.PN OR 0.SPTN IN 1
; MAP WORD IN 2

GETTPD:	SETZ 3,			;NO SPECIAL BITS TO STOP ON
GETTD1:	HRRZ 1,TRAPSW		;TRAP EFFECTIVE ADDRESS
	LSH 1,-^D9		;PAGE NUMBER
	HLRZ 2,TRAPSW		;TRAP BITS
	TRNE 2,1		;USER OR MONITOR?
	JRST NIC4		;MONITOR
	HLL 1,FKPGS(7)		;USER, GET PAGE TABLE SPTN
	MOVE 2,UPTA(1)
NICI2:	TLNE 2,0(3)		;REQUESTED BIT ON?
	RET			;YES, STOP HERE
	TLNE 2,INDBIT		;INDIRECT POINTER?
	JRST NICI		;YES
	TLNN 2,SHRBIT		;SHARE POINTER?
	RET			;NO, PRIVATE
	LSH 2,-^D9		;YES, SHIFT TO B35
	ANDI 2,SPTM		;FLUSH BITS
NICI1:	MOVEI 1,0(2)
	MOVE 2,SPT(1)
	RET

NICI:	SETZ 1,			;INDIRECT POINTER.
	ROTC 1,-^D9		;GET OFN TO 2, PN TO 1
	ROT 1,^D9
	ANDI 2,SPTM
GETPD1:	MOVE 6,SPT(2)		;GET PAGE TABLE ADDRESS
	TLNE 6,17		;IN CORE?
	JRST NICI1		;NO, THAT'S THE TROUBLE.
	HRLI 1,0(2)		;YES, PUT OFN IN 1
	MOVEI 6,0(2)
	CALL SETSPG		;MAP PT
	MOVE 2,CSWPGA(1)	;GET MAP WORD
	CALL RELSPG		;CLEAR TEMPORARY MAP WORD
	JRST NICI2		;GO ANALYZE THIS POINTER

NIC4:	CAIL 1,PJMPG		;MONITOR MAP, WHICH ONE?
	JRST NIC4A		;IN PSB
	CAIL 1,PPRMPG+NRSPG
	JRST NIC4B		;IN RES MON
	BUG(HLT,<PAGE FAULT ON RESIDENT MONITOR ADDRESS>)

NIC4A:	HRL 1,FKPGS(7)		;PSB
	MOVE 2,PSB(1)
	JRST NICI2

NIC4B:	HRL 1,MMSPTN		;PERMANENT SWP MON OFN
	MOVE 2,MMAP(1)
	JRST NICI2

;SWAP IN PAGE TABLE OR PSB
;CALLED FROM SCHED

SWPIN0:	TLNE 1,-1		;SPTN?
	JRST SWP01		;NO
	MOVE 3,SPT(1)		;YES, GET CURRENT ADDRESS
	TLNE 3,17		;OUT OF CORE?
	JRST SWP01		;YES
	LDB 2,[POINT 6,CST0(3),5] ;AGE CODE
	CAIE 2,2		;BEING READ OR COMPLETED?
	CAIN 2,6
	JRST SWP03		;YES
	MOVEI 1,0(3)
	CALL AGESN		;GRAB PAGE OFF RPLQ
SWP03:	MOVSI 1,0(3)		;ALREADY IN CORE
	JRST SWP02

SWP01:	CALL SWPIN
	HLRZ 3,1
SWP02:	MOVSI 2,PLKV
	ADDM 2,CST1(3)		;LOCK PAGE
	RET

;SWAPIN AND WAIT AND STAY NOSKED

SWPINP:	NOSKED
	CALL SWPINW
	OKSKED
	RET

;SWAP IN AND WAIT FOR COMPLETION

SWPINW:	MOVE 7,FORKX
	MOVE 2,JOBNO
	HRRZ 2,JOBNAM(2)	;GET SUBSYSTEM INDEX
	AOS SPFLTS(2)		;COUNT SUBSYSTEM PAGE FAULTS
	AOS USWPCT		;COUNT SWAPS
	TLNE 1,-1		;PT?
	JRST SWPIW2		;YES
	CALL SWPIN		;SWAPIN AND WAIT FOR COMPLETION
SWPIW1:	HRRZ 4,FKWSP(7)
	CAILE 4,^D20
	MOVEI 4,^D20
	MOVN 4,4		;CHARGE SOMETHING FOR PAGE FAULT
	ADDM 4,RJQNT
	HRRI 1,SWPRT
	JSYS SCHEDR
	HLRZ 1,1		;RESTORE PAGE NO TO R.H.
	NOSKED
	RET

SWPIW2:	PUSH P,1		;SAVE ORIG REQUEST
	HLRZ 1,1		;GET PT
	MOVE 3,SPT(1)
	TLNE 3,17		;CORE?
	JRST SWPIW3		;NO
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;SO IT DOESN'T SNEAK AWAY
SWPIW4:	EXCH 1,0(P)		;SAVE CORE PAGE NUMBER, GET ORIG OFN.PN
	CALL SWPIN		;SWAP THE ORIG PAGE
	EXCH 1,0(P)		;GET PT CORE PAGE NUMBER
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK IT
	POP P,1
	JRST SWPIW1

SWPIW3:	NOSKED
	CALL SWPIN		;SWAP IN THE PT
	OKSKED
	HLRZ 2,1
	MOVSI 3,PLKV
	ADDM 3,CST1(2)		;LOCK IT
	HRRI 1,SWPRT
	JSYS SCHEDP		;WAIT TO FINISH
	HLRZ 1,1
	CALL AGESET
	JRST SWPIW4		;NOW GO GET THE PAGE

;SWAP IN PAGE
;AC1/ OFN.PN OR 0.SPTN
;RETURNS AC1/ CORE PAGE NO IN LH

SWPIN:	MOVE 3,NRPLQ		;NUMBER OF REPLACABLE PAGES
	CAIGE 3,6		;RUNNING LOW?
	AOS CGFLG		;YES, REQUEST GC
	JUMPE 3,SWPQT		;GO WAIT IF NONE
SWPIL1:	SOS NRPLQ
	HRRZ 3,RPLQ		;YES, REMOVE FROM QUEUE
	SUBI 3,CST3
	PIOFF
	MOVE 4,CST3(3)
	HLLM 4,0(4)
	MOVS 4,4
	HLRM 4,0(4)
	PION
	SETZM CST3(3)
	CALL DEPG		;RESET PREVIOUS OWNERSHIP
	TLNE 1,-1		;NEW PAGE FROM PT OR SPT?
	JRST SWPI3		;PT
	MOVE 4,SPT(1)		;SPT, GET ADDRESS
	TLNN 4,17
	BUG(HLT,<SWPIN - SPT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,SPT(1),35]	;STORE NEW (CORE) ADDRESS
SWPI4:	TLZ 4,-1B31		;FLUSH BITS
	MOVEM 4,CST1(3)		;STORE BACKUP ADDRESS
	MOVEM 1,CST2(3)		;STORE LOCATION OF OWNING PT
	TLNE 4,16		;BACKUP ADDRESS ASSIGNED?
	JRST SWPI5		;YES, GO READ IN PAGE
	MOVSI 1,400000		;SET LEGAL AGE SO PAGER DOESN'T TRAP
	MOVEM 1,CST0(3)
	TLO 3,RWXB		;NO, ZERO OUT PAGE
	MOVEM 3,MMAP+CSWPG
	SETZM CSWPGA
	MOVEI 1,CSWPGA+1
	HRLI 1,-1(1)
	TRNE 4,1		;SPECIAL UNASSIGNED POINTER?
	MOVE 1,[XWD CPYPGA,CSWPGA] ;YES, COPY FROM CPYPG
	BLT 1,CSWPGA+777
	CALL RELSPG
	MOVSI 1,2B23		;SET STATUS OF PAGE TO READ COMPLETED
	MOVEM 1,CST0(3)
	MOVSI 1,0(3)		;RETURN PAGE NUMBER
	RET

SWPI3:	HLRZ 6,1		;GET OWNING PT OFN
	CALL SETSPG		;MAP PT
	MOVSI 4,PLKV
	ADDM 4,CST1(6)		;INCREMENT LOCK COUNT
	MOVE 4,CSWPGA(1)
	TLNN 4,17
	BUG(HLT,<SWPIN - PT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,CSWPGA(1),35]	;STORE NEW (CORE) ADDRESS
	CALL RELSPG
	JRST SWPI4

SWPQT:	PUSH P,1		;SAVE REQUESTED PAGE IDENT
	AOS CGFLG		;BE SURE TO GC
	MOVEI 1,SWPWTT		;RESCHEDULE UNTIL NRPLQ NON-0
	JSYS SCHEDP
	POP P,1
	JRST SWPIN

SWPWTT:	SKIPLE NRPLQ
	JRST 1(4)
	JRST 0(4)

	EXTERN DRMIO,DSKIO,DWRBIT

SWPI5:	MOVEI 1,0(3)
	MOVE 2,CST2(1)		;FIGURE OUT IF PAGE IS MAYBE A PT
	TLNE 2,-1		;IN SPT?
	JRST SWPI6		;NO, COULDN'T BE PAGE TABLE
	CAIL 2,NOFN		;PAGE IS PAGE TABLE IF IT IS FILE XB,
	SKIPN SPTH(2)		;OR IF IT IS SHARED BUT DOES NOT
	JRST .+2		;BELONG TO ANY PT OR XB
	JRST SWPI6
	MOVEI 2,0(1)		;BEFORE INITIATING SWAP OF PT,
	TLO 2,RWXB		;FILL THE ENTIRE CORE PAGE WITH
	MOVEM 2,MMAP+CSWPG	;PTRS WHICH WILL CAUSE THE PAGER TO
	MOVSI 2,400000		;TRAP IN A SAFE WAY SHOULD IT HAPPEN
	MOVEM 2,CST0(1)		;TO INTERPRET AN INDIRECT PTR WHICH
	MOVE 2,[XWD CSWPGA,CSWPGA+1] ;GOES THROUGH THIS PT BEFORE
	MOVSI 3,RWXB+1		;THE READ IS COMPLETED. THIS IS DONE
	MOVEM 3,-1(2)		;BECAUSE THE PAGER DOES NOT CHECK
	BLT 2,CSWPGA+777	;CST0 WHEN READING A PTR FROM AN IND
	CALL RELSPG		;PT AND SO DOESN'T NOTICE IF THE PAGE
SWPI6:	MOVSI 2,6B23		;IS BEING SWAPPED IN.
	MOVEM 2,CST0(1)		;PUT READ-IN-PROGRESS CODE IN CST0
	TLNE 4,10		;DISK?
	JRST SWPIK		;YES
	TLNE 4,14		;DRUM?
	BUG(HLT,<SWPIN - ILLEGAL SWAP ADDRESS>)
	CALL DRMIO		;YES, INITIATE READ
	AOS DRMRD		;COUNT DRUM READS FOR STATISTICS
SWPIR:	MOVSI 1,0(1)
	RET

SWPIK:	CALL DSKIO		;INITIATE DISK READ
	AOS DSKRD		;COUNT DISK READS FOR STATISTICS
	JRST SWPIR

DEPG:	MOVE 4,CST2(3)		;GET LOCATION OF PT OWNING OLD CONTENTS
	JUMPE 4,R		;0 => WAS NONE
	MOVE 5,CST1(3)		;GET BACKUP ADDRESS
	TLNE 4,-1		;PT OR SPT
	JRST SWPI1		;PT
	DPB 5,[POINT 22,SPT(4),35]	;SPT, RESTORE BACKUP ADDRESS
	MOVSI 6,-1B31
	CAIGE 4,NOFN		;FILE XB?
	TDNE 6,SPT(4)		;WITH SHARE COUNT NOW 0?
	RET			;NO
	SETOM SPTH(4)		;DELETE OFN
	SOS NOF
	RET

SWPI1:	HLRZ 6,4
	CALL SETSPG		;MAP PT
	MOVSI 2,-PLKV
	ADDB 2,CST1(6)		;DECREMENT LOCK COUNT
	TLNN 2,-PLKV		;COUNT NOW 0?
	AOS CGFLG		;YES, INDICATE POSSIBLE GARBAGE
	DPB 5,[POINT 22,CSWPGA(4),35]	;STORE BACKUP ADDRESS
	CALL RELSPG		;RELEASE TEMPORARY MAP WORD
	RET

SETSPG:	PUSH P,1
	MOVE 1,SPT(6)		;GET ADDRESS
	TDNE 1,[XWD 17,-MAXCOR]
	BUG(HLT,<SWPIN - PAGE TABLE NOT IN CORE>)
	CALL AGESN		;SET AGE
	LSH 6,^D9		;MAKE SHARE POINTER FROM OFN IN 6
	TLO 6,RWXB-XCTB+SHRBIT
	MOVEM 6,MMAP+CSWPG	;PUT IN PAGE RESERVED FOR SWAPPER
	MOVEI 6,0(1)		;RETURN CORE ADR
	POP P,1
	RET

RELSPG:	SETZM MMAP+CSWPG	;CLEAR MAP WORD
	MONCLR			;CLEAR MON AR'S
	RET

;ZERO CORE PAGE GIVEN IN 1

SWPZPG:	MOVEI 2,0(1)
	TLO 2,RWXB		;CONSTRUCT PRIVATE POINTER TO PAGE
	MOVEM 2,MMAP+CSWPG	;PUT IN MON MAP
	MOVSI 3,400000		;GET LEGAL AGE
	EXCH 3,CST0(1)		;SAVE OLD AGE
	MOVE 2,[XWD CSWPGA,CSWPGA+1]
	SETZM -1(2)
	BLT 2,CSWPGA+777	;ZERO THE PAGE
	TLO 3,CORWB		;NOTE PAGE WRITTEN INTO
	MOVEM 3,CST0(1)		;RESTORE AGE
	JRST RELSPG		;CLEAR PAGE FROM MMAP AND RETURN

;SCHEDULER TEST FOR PSB AND PT READ COMPLETED

	INTERN SWPINT

SWPINT:	MOVE 3,4		;SAVE RETURN
	HRRZ 1,FKPGS(7)		;PSB
	MOVE 1,SPT(1)		;ASSIGNED PAGE
	JSP 4,SWPRT		;DONE?
	JRST 0(3)		;NO, RETURN NOT RUNNABLE
	SKIPN INDFLG		;LOCKING PSB'S?
	JRST SWPIT1		;NO
	HRRZ 1,FKJOB(7)		;YES, GET SPT
	MOVE 1,SPT(1)		;CORE ADDRESS
	JSP 4,SWPRT		;CHECK IT
	JRST 0(3)		;NOT READY
SWPIT1:	HLRZ 1,FKPGS(7)		;PT
	MOVE 1,SPT(1)
	JSP 4,SWPRT		;PT READY?
	JRST 0(3)		;NO
	SOS NEBAL		;ALL PAGES READY, PROCESS NOW ENTERED
	JRST 1(3)

;SCHEDULER TEST FOR READ COMPLETED

SWPRT:	MOVE 2,CST0(1)		;GET TRAP CODE
	TLNE 2,70B23		;PAGED GRABBED BY OTHER PROCESS?
	JRST 1(4)		;YES, OK TO RUN
SWPT1:	TLNN 2,2B23		;NO, READ OPERATION?
	JRST 1(4)		;NO, OK
	TLNE 2,4B23		;I/O STILL IN PROGRESS?
	JRST 0(4)		;YES, FAIL
	MOVSI 2,3B23		;YES, CHANGE CODE TO READY
	XORM 2,CST0(1)
	CALL AGESN		;ASSIGN PAGE
	JRST 1(4)		;RETURN OK

;WAIT FOR WRITE TO COMPLETE

SWPWT:	MOVE 2,CST0(1)		;JUST LIKE SWPRT, EXCEPT
	TLNE 2,70B23
	JRST 1(4)
	TLNE 2,4B23		;TEST I/O BIT FIRST
	JRST 0(4)
	JRST SWPT1

;SWAP COMPLETION ROUTINE, CALLED FROM DRUM AND DISK INTERRUPT CODE

	INTERN SWPDON

SWPDON:	MOVSI 2,DWRBIT		;WRITE BIT
	TDNE 2,CST3(1)		;WAS WRITE?
	JRST SWPD1		;YES
	AOS PSKED		;INDICATE READ COMPLETED
	ISB SCDCHN
	MOVSI 2,4B23
SWPD2:	ANDCAM 2,CST0(1)	;CLEAR I/O IN PROGRESS
	JRST 0(4)

SWPD1:	ANDCAM 2,CST3(1)	;CLEAR WRITE BIT
	LDB 2,[POINT 6,CST0(1),5]	;GET TRAP CODE
	CAIE 2,4		;STILL SAYS WRITE?
	JRST [	SKIPE CST2(1)	;NO, PAGE USED AGAIN.  STILL EXISTS?
		JRST 0(4)	;YES
		JRST ONRQ]	;IT WAS DELETED, PUT ON RPLQ
	SOS IOIP		;WRITE NO LONGER IN PROGRESS
ONRQ:	MOVEI 2,CST3(1)		;YES, PUT ON REPLACABLE QUEUE
	PIOFF
	HLRZ 3,RPLQ
	HRL 3,0(3)
	HRRM 2,0(3)
	MOVSM 3,0(2)
	HRLM 2,RPLQ
	PION
	AOS NRPLQ
	MOVSI 2,77B23
	JRST SWPD2

	BEGINP	JSYS		R.S.Tomlinson	 19 November 1971 1600:

USE SWAPPC

^WHEEL__400000
^OPR__200000
^LOG__040000

EXTERN	NXTDMP	; Zero to dump open files
EXTERN	MAPFKH	; Maps over a fork handle
EXTERN	SKIIFA	; Skips if fork(a) < fork(b)
EXTERN	ACCTPT	; Login accoutn string pointer or number
EXTERN	ACCTSR	; Account string storage
EXTERN	LOGONM	; Dlm's logon message typer
EXTERN	LOGCJM	; Type change job number on logtty
EXTERN	JOBRT	; Job runtime table
EXTERN	CONSTO	; Console time on word
EXTERN	MJRSTF	; Thing to execute to leave fast jsys code
LS(FACTSW)	; Fact switches
JS(ACCTSL)
EXTERN	JOBDIR
EXTERN	NJOBS
EXTERN	NTTYS	; Number of ttys (not ptys)
EXTERN	TODCLK	; Time since system start in msec
EXTERN	SKIIF	; Skip if forkn in a is inferior or equal to self
JS(MODES)	; Ddbmod word from login
JS(GROUPS)	; Groups to which login user belongs
EXTERN	TTBKPT	; Routine to backup tty pointer one character
EXTERN	JOBPMF	; Jfn of pmf
EXTERN	MRPT	; Read page table
EXTERN	SETPT	; Map manipulator routine
EXTERN	MSPACS	; Set access of a page
EXTERN	FKHPTN	; Converts fork handle to ptn
EXTERN	PTNFKH	; Converts ptn to fork handle
EXTERN	SETLFK,DELOFN
EXTERN	TTCIBF,TTCOBF,TTSIBE,TTDIBE,TTSOBE,TTSOBF,TTDOBE,TTGTBS,TTSTBS
EXTERN	TTRMOD,TTSMOD,TTRPOS,TTSPOS,TTRCOC,TTSCOC,TTSTI,TTILIN,TTSOBF
EXTERN	SYSIFG,LOGBUF	; Logging stuff
EXTERN	SYSFK	; Table of job forks
EXTERN	NORMTF,TTICB1,TTICB2,TAB81,TAB82	;TTY MODES

; Entries to this section

INTERN	BOUTA,NOUTXX,CHKTTM,JFNDCR
INTERN	.GDSTS,.SDSTS
INTERN	.OPENF,.CLOSF,.RLJFN,.GTSTS,.STSTS,.DELF,.SFPTR,.RFPTR
INTERN	.DELDF,.CLZFF,.RESET
INTERN	.JFNS,.RNAMF,.SIZEF,.GACTF,.SACTF,.BKJFN,.RFBSZ,.SFBSZ,.SWJFN
INTERN	.STDIR,.DIRST,.PMAP,.RPACS,.SPACS,.RMAP,.FFFFP,.FFUFP,.FDFRE
INTERN	.GTFDB,.CHFDB
INTERN	.ASND,.RELD,.CSYNO
INTERN	.DVCHR,.STDEV,.DEVST,.MOUNT,.DSMNT
INTERN	.INIDR,.RDDIR,.MTOPR,.CRDIR,.GTDIR
INTERN	.CFIBF,.CFOBF,.SIBE,.SOBE,.DIBE,.DOBE,.GTABS,.STABS
INTERN	.RFPOS,.SFPOS,.RFCOC,.SFCOC,.STI,.SOBF
INTERN		.RFMOD,.SFMOD,.ERSTR,.GETER,.STAD,.GTAD
INTERN	.LOGIN,.CNDIR,.CACCT,.EFACT,.SMON,.TMON
INTERN	.CRJOB,DELDEL,PASSWC

; Error macro definitions

DEFINE	ERUNLK(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERUNLD]>

DEFINE	ERR(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERRD]>

DEFINE	ERABRT(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERABRD]>

^ERUNLD:PUSH P,A
	MOVEM A,LSTERR
	PUSHJ P,UNLCKF
	XCTMU [POP P,1]
	JRST MRETN

^ERRD:	UMOVEM A,1
	MOVEM A,LSTERR
	JRST MRETN

ERABRD:	MOVEM A,LSTERR
	JRST ITRAP

DEFINE	NIY'(X)<
^.'X:	JSYS MENTR
	JSP A,NIYET
	ASCIZ /X/>

FOR A IN (CRJOB,CSYNO),<
	NIY(A)>

^NIYET:	PUSH P,A
	HRROI B,[ASCIZ /
JSYS /]
	MOVEI A,101
	MOVEI C,0
	SOUT
	POP P,B
	HRLI B,777777
	SOUT
	HRROI B,[ASCIZ / IS NOT IMPLEMENTED YET./]
	SOUT
	JRST ITRAP

; Open a file
; Call:	1	; Job file number
;	2(0-5)	; Byte size
;	2(6-9)	; Data mode
;	RH(2)	; Access flags (see jsys manual or filsts description)
;	OPENF
; Return
;	+1	; Cannot open file, error code in 1
;	+2	; Successful

^.OPENF:JSYS MENTR		; Become slow, save ac's
	PUSH P,2
	MOVE JFN,1		; Get jfn
	PUSHJ P,CHKJFN		; What kind of designator is this?
	ERR()			; Garbage designator
	JFCL
	JRST [	POP P,2		; Tty and byte pointer are always good
		JRST OPENFZ]
	TEST(NE,OPENF)
	ERUNLK OPNX1		; Already open
	MOVE B,(P)
		; Get access bits
	LDB A,[POINT 6,B,5]	; Get byte size
	CAILE A,=36
	ERUNLK SFBSX2
	DPB A,PBYTSZ		; Store as byte size of pointer
	LDB A,[POINT 4,B,9]	; Get data mode
	HRRM A,FILSTS(JFN)
	HRR STS,A
	ANDCM STS,[XWD READF!WRTF!XCTF!RNDF!ASPF!CALLF!LONGF!EOFF!ERRF!HLTF!WNDF!ENDF!SIZF,777760]
	ANDI B,774000		; Ignore bits user cant set
	TRZE B,400000		; Bit 18 = 1?
	TRO B,HLTF		; Yes, move it down to hltf
	TLO STS,(B)		; Put user's bits into sts
	POP P,B
	ANDI B,17B28
	IORI STS,(B)
	MOVE A,CAPENB
	TRNN  A,OPR!WHEEL	; Have operator or wheel status?
	TRNN STS,1B27		; Or is he not trying to cheat
	JRST .+2
	ERUNLK OPNX11		; Illegal
	SETZM FILCNT(JFN)
	PUSHJ P,@OPEND(DEV)	; Call the device dependent routine
	JRST OPENR		; Cannot open
	TEST(O,OPENF)		; Success
	MOVSI B,1
	HLLM B,FILLFW(JFN)
OPENFZ:	SKIPRT
	PUSHJ P,UNLCKF
	JRST MRETN

OPENR:	CAIE A,OPNX9
	ERUNLK()
	HRRZ B,DEV
IFDEF LPTN,<	CAIN B,LPTDTB
	TRO STS,1B26>
	TRNN STS,1B28
	TRNN STS,1B26
	ERUNLK()
	PUSHJ P,UNLCKF
	SETZM INTDF
	XCT INTDFF
	MOVEI A,"["
	PBOUT
	MOVEI A,101
	UMOVE B,1
	MOVEI C,0
	JFNS
	HRROI A,[ASCIZ / Busy-/]
	PSOUT
OPENR1:	MOVEI A,=3000
	DISMS
	UMOVE A,A
	UMOVE 2,2
	TRO B,1B28
	JSYS 21
	JRST OPENR1
	UMOVEM 1,1
	HRROI 1,[ASCIZ /Go]
/]
	PSOUT
	JRST SKMRTN

; Close a file
; Call:	RH(1)	; Jfn
;	1(0)	; If 1 do not release jfn
;	CLOSF
; Returns
;	+1	; Cannot close
;	+2	; Ok

^.CLOSF:JSYS MENTR
	CAMN 1,[-1]		; -1 means all
	JRST CLZALL
	HRRZ JFN,1
	PUSHJ P,CLZF
	ERR()			; Can't close, reason in a
	XCTUU [SKIPL 1]		; Don't release jfn
	TEST(NE,OPENF)		; Or still open?
	JRST SKMRTN		; Yes. all done.
	PUSHJ P,RELJFN		; No, release jfn.
	JRST SKMRTN

CLZALL:	MOVE A,[XWD (1B2),400000]
	CLZFF
	JRST SKMRTN

^CLZF:	MOVEI A,CLSX2
	HRRZ B,PRIMRY
	CAME JFN,JOBPMF
	CAMN JFN,B
	POPJ P,
	HLRZ B,PRIMRY
	CAME JFN,B
	PUSHJ P,CHKJFN
	POPJ P,			; Garbage
	JFCL
	JRST SKPRET		; Byte and tty always succeeds
	TEST(NN,OPENF)
	JRST [	MOVEI A,CLSX1
		JRST UNLCKF]
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNE B,777777
	JRST CLZF2
	PUSHJ P,@CLOSD(DEV)	; Call device dependent stuff
	JRST UNLCKF
	TEST(Z,OPENF)
CLZF2:	AOS (P)
	JRST UNLCKF

; Release jfn
; Call:	1	; Jfn
;	RLJFN
; Returns
;	+1	; Error
;	+2	; Success
; Cannot release jfn if being assigned unless this same process as
; Assigner, and not at interrupt level

^.RLJFN:JSYS MENTR
	CAMN 1,[-1]		; Release all
	JRST RLALL
	HRRZ JFN,1
	PUSHJ P,RLJF
	ERR()
	SKIPRT
	JRST MRETN

RLALL:	MOVSI JFN,-NJFN
RLAL1:	PUSHJ P,RLJF
	JFCL			; Ignore errors
	AOBJN JFN,RLAL1
	SKIPRT
	JRST MRETN

RLJF:	PUSH P,JFN
	HRRZS JFN
	PUSHJ P,CHKJFN
	JRST RLJF1		; Garbage jfn
	JFCL
	JRST [	MOVEI A,DESX4	; Tty or byte illegal
		JRST RLJF3]
	TEST(NE,OPENF)
	JRST [	MOVEI A,OPNX1	; File is open
		JRST RLJF4]
RLJF2:	PUSHJ P,RELJFN		; Finally we can release it
	AOSA -1(P)
RLJF4:	PUSHJ P,UNLCKF
RLJF3:	POP P,JFN
	POPJ P,

RLJF1:	CAIE A,DESX3		; Is no name attached to this jfn?
	JRST RLJF3		; Some other error
	HLRZ B,FILVER(JFN)	; Get fork number of originator
	SKIPGE SYSFK(B)		; Fork still exists?
	JRST RLJF2		; No, ok to release
	CAME B,FORKN		; Is it me?
	JRST RLJF3		; No
	SKIPE PSIBIP		; Test if pi in progress
	JRST RLJF3		; Yes
	JRST RLJF2		; No pi in progress, ok to release

; Close files given fork handle
; Call:	RH(1)	; Fork handle
;	B0(1)	; Not below the fork(s) specified
;	B1(1)	; Not at the fork(s) specified
;	B2(1)	; Close only (no release)
;	B3(1)	; Release only (no close)
;	B4(1)	; Unrestrict file
;	B5(1)	; Close regardless of map count
;	CLZFF
; Return
;	+1	; Always
; Traps if fork handle is bad

^.CLZFF:JSYS MENTR
	HRRZS A
	PUSHJ P,MAPFKH		; Call routine to map over the fork hdl
	PUSHJ P,CLZFF1		; Call this for each fork
	JRST MRETN

CLZFF1:	MOVSI JFN,-NJFN
CLZFF2:	HLRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3		; Don't affect primary files
	HRRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3
	MOVE B,JOBPMF
	CAIN B,(JFN)
	JRST CLZFF3		; Or pmf
	PUSH P,JFN
	PUSH P,1
	HRRZS JFN
	PUSHJ P,CHKJFN		; See if this jfn is in use
	JRST CLZFF8		; No name check for asgf
	JRST CLZFF4		; Should not happen
	JRST CLZFF4
	MOVSI B,777777
	TEST(NE,OPENF)		; If file is open
	TDNE B,FILLFW(JFN)	; And map count is zero
	SKIPA
	JRST CLZFF5		; Then it's ok to close it
	HLRZ B,FILVER(JFN)
	MOVE A,(P)
	CAMN B,A		; Was this jfn created by this fork
	JRST [	UMOVE C,1
		TLNE C,(1B1)	; Are we to close files at the fork?
		JRST CLZFF7	; No, skip this jfn
		JRST CLZFF5]	; Yes, do it
	EXCH A,B
	PUSHJ P,SKIIFA		; Skip if fork(a) < fork(b)
	JRST CLZFF7

CLZFF5:	UMOVE C,1
	TLNE C,(1B4)		; Un restrict this file?
	TEST(Z,FRKF)		; Yes
	TEST(NE,OPENF)
	TLNE C,(1B3)
	JRST CLZFF6
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNN C,(1B5)
	TLNN B,777777
	PUSHJ P,@CLOSD(DEV)
	JRST CLZFF7
	TEST(Z,OPENF)
CLZFF6:	UMOVE C,1
	TEST(NN,OPENF)
	TLNE C,(1B2)
	JRST CLZFF7
CLZFF9:	PUSHJ P,RELJFN
	JRST CLZFF4

CLZFF7:	PUSHJ P,UNLCKF
CLZFF4:	POP P,1
	POP P,JFN
CLZFF3:	AOBJN JFN,CLZFF2
	POPJ P,

CLZFF8:	CAIE A,DESX3
	JRST CLZFF4		; ??
	HLRZ B,FILVER(JFN)
	SKIPGE SYSFK(B)
	JRST CLZFF9
	CAME B,FORKN
	JRST CLZFF4
	SKIPE PSIBIP
	JRST CLZFF4
	JRST CLZFF9

; Reset jsys
; Call:	RESET
; Closes all files, resets tty status etc

^.RESET:JSYS MENTR
	MOVNI A,4
	KFORK			; Kill all inferior forks
	MOVEI A,101
	RFMOD
	AND B,[1B1!1B2!1B3!1B26!1B27!3B33]	;KEEP HDWR,  LINK AND DUPLEX MODES
	IOR B,NORMTF		;NORMAL MODES
	SFMOD
	MOVE 6,B
	MOVE B,TTICB1
	MOVE C,TTICB2		;NORMAL CC MODES
	TLNE 6,(1B2)
	TRZ B,200000
	TLNE 6,(1B1)
	TRZ B,002000
	SFCOC
	MOVE B,TAB81		;8 CHARS/TAB
	MOVE C,TAB82
	MOVE D,B
	STABS
	MOVEI A,400000
	CIS
	DIR
	MOVNI 2,1
	DIC
	MOVEI 1,400000
	CLZFF
	JRST MRETN

; Get open file status
; Call:	1	; Jfn
;	GTSTS
; Return
;	+1
;	1	; Status word as in filsts

^.GTSTS:NOINT
	JUMPL 1,GTST1
	CAIGE 1,NJFN
	AOSE FILLCK(1)
	JRST GTST1
	EXCH 2,FILSTS(1)
	TLNN 2,NAMEF
	JRST [	MOVEM 2,FILSTS(1)
		SETZ 2,
		JRST GTST0]
	MOVEM 2,FILSTS(1)
GTST0:	SETOM FILLCK(1)
	OKINT
	XCT MJRSTF

GTST1:	OKINT
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST GTSTS1		; Illegal, return 0
	JRST GTSTS2		; Illegal, return 0
	JRST GTSTS2		; Illegal, return 0
	PUSHJ P,UNLCKF
	UMOVEM STS,2
	JRST MRETN

GTSTS2:	PUSHJ P,UNLCKF
GTSTS1:	XCTUU [SETZM 2]
	JRST MRETN

; Set status
; Call:	1	; Jfn
;	2	; New status
;	STSTS
; Returns
;	+1	; Erro2
;	+2	; Ok (only errf, hltf, and frkf can be changed)

^.STSTS:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()			; Bad jfn
	JFCL
	ERR(DESX4)		; Tty and byte bad
	UMOVE A,2		; Get new status
	ANDCA A,[XWD ERRF!HLTF!FRKF,0]
	TDZ STS,A
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get device status
; Call:	1	; Jfn
;	GDSTS
; Returns
;	+1	; Error
;	+2	; Ok

^.GDSTS:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERABRT()
	JFCL
	ERABRT(DESX4)
	MOVE A,STS
	ANDI A,17
	PUSHJ P,@GDSTD(DEV)
	UMOVEM A,2
	JRST UNL

; Set device status
; Call:	1	; Jfn
;	SDSTS
; Returns
;	+1	; Always unless traps

^.SDSTS:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERABRT()
	JFCL
	ERABRT(DESX4)
	UMOVE A,2
	PUSHJ P,@SDSTD(DEV)
	JRST UNL

; Delete file
; Call:	1	; Jfn
;	DELF
; Return
;	+1	; Error, cannot delete
;	+2	; Success

^.DELF:	JSYS MENTR		; Become slow
	HRRZ JFN,1
	PUSHJ P,CHKJFN		; Check it out
	JRST GBGJFN
	JFCL
	ERUNLK DESX4		; Tty or byte illegal
	PUSHJ P,@DELD(DEV)	; Call device dependent routine
	ERUNLK()		; Couldn't delete
	UMOVE A,1
	TLNE A,777777
	JRST DELF1
	TEST(NN,OPENF)
	JRST [	PUSHJ P,RELJFN
		JRST SKMRTN]
DELF1:	PUSHJ P,UNLCKF
	JRST SKMRTN

; Rename file
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	RNAMF
; Return
;	+1	; Error
;	+2	; Ok

^.RNAMF:JSYS MENTR
	CAMN 1,2
	JRST SKMRTN
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)		; Cannot rename tty or byte
	TEST(NE,OPENF)
	ERUNLK(OPNX1)		; File must not be open
	PUSH P,JFN
	PUSH P,DEV
	UMOVE JFN,2
	PUSHJ P,CHKJFN		; Check the second jfn
	ERUNLK(,<POP P,DEV
		POP P,JFN>)
	JFCL
	ERUNLK(DESX4,<POP P,DEV
		POP P,JFN>)
	TEST(NE,OPENF)
	ERUNLK(OPNX1,<PUSHJ P,UNLCKF
		POP P,DEV
		POP P,JFN>)
	POP P,A
	CAME A,DEV		; Can only rename on the same device
	ERUNLK(RNAMX1,<PUSHJ P,UNLCKF
		POP P,JFN>)
	MOVE A,(P)
	PUSH P,JFN
	PUSHJ P,@REND(DEV)
	ERUNLK(,<POP P,JFN
		PUSHJ P,UNLCKF
		POP P,JFN>)
	POP P,JFN
	PUSHJ P,UNLCKF
	POP P,JFN
	PUSHJ P,RELJFN
	AOS (P)
	JRST MRETN

; Convert jfn to string
; Call:	1	; Jfn
;	2	; String pointer
;	3	; Format specification (see jsys manual)

^.JFNS:	JSYS MENTR
	HRRZ JFN,2
	PUSHJ P,CHKJFN
	ERABRT()
	JFCL
	ERABRT(DESX4)
	PUSHJ P,UNLCKF
	UMOVE A,1
	TLNN A,777777
	 JRST JFNSZ		; Not byte pointer
	TLC A,777777
	TLCN A,777777
	 HRLI A,440700		; -1 in lh, fill in
	SETZ B,
	XCTMU [IDPB B,A]	; Deposit initial null in case
JFNSZ:	XCTUM [HLLZ F1,2]
	XCTUU [SKIPN E,3]
	MOVE E,[BYTE (3)2,2,1,1,2,0,0(1)1(4)0(5)0,11]
	HLRZ A,FILDDN(JFN)	; Get pointer to device block
	MOVN B,(A)
	HRLI A,-2(B)
	PUSHJ P,DEVLUK
	MOVEI A,0
	TLNE A,(1B2)
	TROA E,100
	TRZ E,100
	TLNE A,(1B4)
	TROA E,200
	TRZ E,200
	HLRZ A,FILDDN(JFN)
	MOVE C,1(A)		; The first word of the device name
	ANDCMI C,377		; Get rid of low byte
	LDB D,[POINT 3,E,2]	; Get format control byte for device
	PUSHJ P,TAB4
	CAIN D,2		; If it is suppress system default
	CAME C,[ASCIZ /DSK/]	; And the device is dsk, then skip
	CAIN D,0		; Or if control is "no print"
	JRST JFNS0		; Don't print
	PUSHJ P,JFNSS		; Output the string in a
	MOVEI B,":"
	PUSHJ P,PUNCT
JFNS0:	HRRZ A,FILDDN(JFN)	; Get directory number
	LDB D,[POINT 3,E,5]	; And format control
	PUSHJ P,TAB4		; Tab before field if desired
	TEST(NE,DIRSF)
	JRST JFNS0A
	CAIN D,2		; If suppressing default,
	CAME A,JOBDNO		; And it is default

JFNS0A:	CAIN D,0		; Or if no print is wanted
	JRST JFNS1		; Then don't print
	MOVEI B,"<"
	PUSHJ P,PUNCT		; Print punctuation if desired
	TEST(NE,DIRSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS0B]
	HRRZ A,FILDDN(JFN)
	PUSHJ P,GDIRST		; Get string for this number
	BUG(HLT,<JFNS: GDIRST CANNOT FIND STRING FOR DIRECTORY.>)
	UNLOCK DIRLCK
	PUSHJ P,JFNSS		; Copy string to output
	OKINT
JFNS0B:	MOVEI B,">"
	PUSHJ P,PUNCT		; And output terminating punct

JFNS1:	HLRZ A,FILNEN(JFN)	; Get location of file name block
	LDB D,[POINT 3,E,8]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS2		; No print wanted
	TEST(NE,NAMSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS2]
	PUSHJ P,JFNSS		; Copy string to output
JFNS2:	HRRZ A,FILNEN(JFN)	; Get location of extension block
	LDB D,[POINT 3,E,11]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS3		; No print wanted
	MOVEI B,"."
	TRNE E,100
	PUSHJ P,PUNCT		; Output punctuation if desired
	TEST(NE,EXTSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS3]
	PUSHJ P,JFNSS		; Copy to output
JFNS3:	HRRZ A,FILVER(JFN)	; Get version number
	LDB D,[POINT 3,E,14]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS4		; No print wanted
	TRNN E,200
	JRST JFNS4
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVE B,A
	MOVEI C,12
	TEST(NE,VERSF)
	JRST [	PUSHJ P,JFSTAR
		JRST MRETN]
	TEST(NE,RVERF)
	MOVNI B,0
	TEST(NE,HVERF)
	MOVNI B,1
	TEST(NE,LVERF)
	MOVNI B,2
	PUSHJ P,NOUTXX

JFNS4:	HRRZ A,NLUKD(DEV)
	CAIN A,MDDNAM
	PUSHJ P,GETFDB		; Get a pointer to the fdb
	JRST MRETN
	UNLOCK DIRLCK		; Unlock directory
	PUSH P,A
	LDB D,[POINT 3,E,17]
	PUSHJ P,TAB4
	MOVE B,FDBPRT(A)	; File protection word
	CAIN D,2
	CAME B,DIRDPW
	CAIN D,0
	JRST JFNS5
	PUSH P,B
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"P"
	PUSHJ P,PUNCT
	POP P,A
	MOVEI C,10
	PUSHJ P,JFNSN

JFNS5:	LDB D,[POINT 3,E,20]
	PUSHJ P,TAB4
	JUMPE D,JFNS6
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"A"
	PUSHJ P,PUNCT
	MOVE A,(P)
	MOVE A,FDBACT(A)
	MOVEI C,=10
	TLNN A,777777
	ADDI A,DIRORG+1
	PUSHJ P,JFNSN
JFNS6:	MOVE A,(P)
	LDB D,[POINT 1,E,21]
	PUSHJ P,TAB4
	MOVE B,FDBCTL(A)
	TLNE B,FDBTMP
	CAIN D,0
	JRST JFNS7
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"T"
	PUSHJ P,BOUTA
JFNS7:	LDB D,[POINT 1,E,22]
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	JUMPE D,JFNS8
	MOVE A,(P)
	LDB B,PFILPC
	MOVEI C,=10
	PUSHJ P,NOUTXX

JFNS8:	MOVE A,(P)
	MOVE B,FDBCRV(A)
	TRNE E,1B23
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	MOVE B,FDBWRT(A)
	TRNE E,1B24
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	MOVE B,FDBREF(A)
	TRNE E,1B25
	PUSHJ P,JFNDAT
	JFCL
	JRST MRETN

JFNSN:	JUMPG A,JFNSS		; Copy to output
	MOVE B,A
	TLZ B,700000
NOUTXX:	PUSH P,JFN
	PUSH P,DEV
	PUSH P,STS
	PUSH P,F1
	PUSH P,E
	PUSH P,D
	PUSH P,F
	PUSH P,C
	PUSH P,B
	PUSHJ P,NOUTX
	JFCL
	POP P,B
	POP P,C
	POP P,F
	POP P,D
	POP P,E
	POP P,F1
	POP P,STS
	POP P,DEV
	POP P,JFN
	POPJ P,

JFNDAT:	PUSH P,B
	MOVEI D,1
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	POP P,B
	MOVEI C,10
	AOS (P)
	JRST NOUTXX

JFNCOM:	MOVEI B,","
	CAIE D,0
	TRNN E,10
	POPJ P,
	JRST BOUTA

JFSTAR:	MOVEI B,"*"
	JRST BOUTA

PUNCT:	TRNE E,1
	JRST BOUTA
	POPJ P,

TAB4:	MOVEI B,11
	TRNE E,2
	CAIG D,0
	TRNE E,4
	TRON E,40
	POPJ P,
BOUTA:	JRST BOUTN

JFNSS:	MOVE C,A
	HRLI C,(<POINT 7,0,35>)
JFNSS1:	ILDB B,C
	JUMPE B,CPOPJ
	PUSHJ P,BOUTA
	JRST JFNSS1

; Get size of file
; Call:	1	; Jfn
;	SIZEF
; Return
;	+1	; Error, cannot get size of file
;	+2	; Success
;	1	; Size in bytes
;	2	; Size in pages

^.SIZEF:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST GBGJFN
	JFCL
	ERUNLK DESX4
	HRRZ B,DEV		; Get dispatch address
	MOVEI A,DESX7
	CAIE B,DSKDTB
	ERUNLK()
	PUSHJ P,GETFDB		; Get pointer to fdb
	ERUNLK OPNX2
	LDB B,PFILPC		; Get number of pages
	MOVE A,FDBSIZ(A)	; And length
	UMOVEM A,2
	UMOVEM B,3
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	SKIPRT
	JRST MRETN

GBGJFN:	UMOVEM A,1
	JRST MRETN

; Backup file pointer by 1 byte
; Call:	1	JFN
;	BKJFN
; Returns
;	+1	; Error, cannot backup this designator
;	+2	; Ok.

^.BKJFN:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JRST BKJTTY
	JRST BKJBYT
	MOVEI A,-TTYDTB(DEV)
	JUMPE A,BKJTT1
	TEST(NN,OPENF)
	ERR(DESX5,<PUSHJ P,UNLCKF>)
	MOVE A,FILBYN(JFN)
	SOJL A,[ERR(SFPTX3,<PUSHJ P,UNLCKF>)]
	PUSHJ P,SFBNR
	ERR(,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	JRST SKMRTN

BKJTT1:	PUSHJ P,UNLCKF
BKJTTY:	HLRZ 2,DEV
	PUSHJ P,TTBKPT
	ERR(BKJFX1)
	JRST SKMRTN

BKJBYT:	MOVE A,JFN
	PUSHJ P,DBP
	UMOVEM A,1
^SKMRTN:AOS (P)
	JRST MRETN

; Read file byte number
; Call:	1	; Jfn
;	RFPTR
; Return
;	+1	; Error
; 	+2	; Success
;	2	; File byte number

^.RFPTR:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)
	TEST(NN,OPENF)
	ERUNLK(DESX5)
	MOVE A,FILBYN(JFN)
	UMOVEM A,2
	PUSHJ P,UNLCKF
	SKIPRT
	JRST MRETN


; Set file byte number
; Call:	1	; Job file number
;	2	; Byte number
;	SFPTR
; Return
;	+1	; Error
;	+2	; Successful

^.SFPTR:JSYS MENTR		; Become slow etc.
	MOVE JFN,1
	PUSHJ P,CHKJFN		; Find out what we are dealing with
	ERR()
	JFCL
	ERR(DESX4)		; Tty or byte pointer illegal
	TEST(NN,OPENF)
	ERUNLK(CLSX1)
	UMOVE A,2
	PUSHJ P,SFBNR		; Set the byte number
	ERUNLK()
	SKIPRT			; Skip return
	PUSHJ P,UNLCKF
	JRST MRETN

; Set file byte number common code
; Call:	A	; Byte number
;	PUSHJ P,SFBNR
; Return
;	+1	; Error of some sort, error number in a
;	+2	; Success
; Clobbers most temps

^SFBNR:	TEST(NN,RNDF)
	JRST [	MOVEI A,SFPTX2
		POPJ P,]	; Illegal to reset pointer for this file
	CAMN A,[-1]
	MOVE A,FILLEN(JFN)	; Set to end of file if -1
	JUMPL A,[MOVEI A,SFPTX3
		POPJ P,]	; Illegal byte number
	MOVEM A,FILBYN(JFN)
	TEST(Z,EOFF)
	CAML A,FILLEN(JFN)
	TEST(O,EOFF)
	PUSHJ P,NEWWND		; Set window pointers
	AOS (P)
	POPJ P,

^NFBSZ:	MOVEI C,=36
	IDIVM C,A		; Number of bytes per word
	MOVEI C,=36
	IDIV C,B		; New number of bytes per word
	PUSH P,C
	IMUL C,FILBYN(JFN)	; Adjust byte number
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILBYN(JFN)
	POP P,C
	IMUL C,FILLEN(JFN)	; And adjust file length
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILLEN(JFN)
	DPB B,PBYTSZ		; Deposit new byte size
	POPJ P,

; Read file byte size
; Call:	1	; Jfn
;	RFBSZ

^.RFBSZ:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERABRT(DESX4)
	TEST(NN,OPENF)
	ERABRT(DESX5)
	LDB A,PBYTSZ
	UMOVEM A,2
	PUSHJ P,UNLCKF
	JRST MRETN


; Set file byte size jsys
; Call:	1	; Job file number
;	2	; Byte size (1 to 36)
;	SFBSZ
; Return
;	+1	; Error number in a
;	+2	; Success

^.SFBSZ:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)		; Tty and byte pointers illegal
	TEST(NN,OPENF)
	ERUNLK(CLSX1)		; File not open
	XCTUU [SKIPLE B,2]
	CAILE B,=36
	ERUNLK SFBSX2		; Illegal byte size
	TEST(NE,SIZF)
	ERUNLK SFBSX1		; Illegal to change byte size
	LDB A,PBYTSZ		; Get previous byte size
	PUSHJ P,NFBSZ
	PUSHJ P,NEWWND		; Recompute window pointers
	PUSHJ P,UNLCKF		; Unlock file
	AOS (P)
	JRST MRETN

; Swap jfn's
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	SWJFN

^.SWJFN:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST ERABRD
	JFCL
	ERABRT(DESX4)
	PUSH P,JFN
	UMOVE JFN,2
	PUSHJ P,CHKJFN
	ERABRT(,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	JFCL
	ERABRT(DESX4,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	POP P,A
	MOVEI B,[FILBYT
		FILBYN
		FILLEN
		FILCNT
		FILLCK
		FILWND
		FILSTS
		FILDEV
		FILOFN
		FILLFW
		FILDDN
		FILNEN
		FILVER]
	HRLI B,-15
	HRLI A,D
	HRLI JFN,D
SWJFNL:	MOVE D,(B)
	MOVE C,@JFN
	EXCH C,@A
	MOVEM C,@JFN
	AOBJN B,SWJFNL
	HRRZS JFN
	PUSHJ P,UNLCKF
	HRRZ JFN,A
	PUSHJ P,UNLCKF
	JRST MRETN

; Get fdb entry
; Call:	1	JFN
;	LH(2)	; Number of words to read
;	RH(2)	; First word to read
;	3	; Location to store words
;	GTJFN

^.GTFDB:JSYS MENTR
	UMOVE A,2
	HLRZ B,A		; Get count
	HRRZS A			; Offset
	CAIL A,FDBLEN
	ERABRT(GFDBX1)		; Offset too big
	ADD A,B
	CAIE B,0		; 0 words illegal
	CAILE A,FDBLEN
	ERABRT(GFDBX2)		; Count too big
	UMOVE JFN,1
	PUSHJ P,CHKJFN		; Check the jfn
	ERABRT()		; Garbage
	JFCL
	ERABRT(DESX4)		; Tty or byte illegal
	HRRZ A,NLUKD(DEV)	; Get name lookup dispatch
	CAIE A,MDDNAM		; Must be mddnam
	ERABRT(GFDBX1,<PUSHJ P,UNLCKF>)	; Cannot read fdb for device
	PUSHJ P,GETFDB		; Get pointer to the fdb
	ERABRT(DESX3,<PUSHJ P,UNLCKF>)
	UMOVE B,2
	ADDI A,(B)		; Offset pointer to fd
	UMOVE C,3		; To address
	HRL C,A			; From address
	HLRZS B			; Count
	ADDI B,(C)		; Last address+1
	XCTMU [BLT C,-1(B)]
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST MRETN

; Change fdb
; Call:	LH(1)	; Offset
;	RH(1)	; Jfn
;	2	; Mask
;	3	; Data
;	CHFDB

^.CHFDB:JSYS MENTR
	UMOVE A,1
	HRRZ JFN,A
	HLRZS A
	CAIL A,FDBLEN
	ERABRT(CFDBX1)		; Offset too big
	PUSHJ P,CHKJFN		; Check jfn
	ERABRT()		; Garbage
	JFCL
	ERABRT(DESX4)		; Tty or byte illegal
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERABRT(CFDBX1)		; No fdb fon non mdd devices
	PUSHJ P,GETFDB		; Get the fdb
	ERABRT(DESX3,<PUSHJ P,UNLCKF>)
	XCTUU [HLRZ D,1]
	PUSH P,A		; Save fdb loc
	UMOVE B,2		; Mask
	ANDCM B,WRTR(D)		; Writer bits?
	JUMPN B,CHFDB1		; No, check owner and wheel
	HRLI A,100000		; Yes check for write access
	PUSHJ P,ACCCHK
	JRST CHFDB3		; No write access, still ok if owner
	JRST CHFDB2		; Ok, go ahead

CHFDB1:	ANDCM B,OWNER(D)
	JUMPN B,CHFDB4		; Requires mor than owner status
CHFDB3:	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Check if we have owner rights
	JRST CHFDB5
	JRST CHFDB2

CHFDB4:	ANDCM B,WOPR(D)
	JUMPN B,CHFDB6		; Can't be done
CHFDB5:	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CHFDB2
CHFDB6:	MOVEI A,CFDBX2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST ERABRD

CHFDB2:	POP P,A
	ADD A,D
	UMOVE C,3		; Data
	MOVE B,(A)		; Old data
	UMOVE D,2		; Mask
	AND C,D			; Retain masked bits of new data
	ANDCM B,D		; Flush bits to be replaced from old
	IOR B,C
	MOVEM B,(A)
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST MRETN

; Access tables for chfdb

WRTR:	0
	0
	0
	0
	0
	0
	0
	0
	0
	007700000000
	777777777777
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0

OWNER:	0		; Fdbctl
	463000000000	; Fdbctl
	0		; Fdbext
	0		; Fdbadr
	000000777777	; Fdbprt
	0		; Fdbcre
	777777000000	; Fdbuse
	0		; Fdbver
	0		; Fdbact
	777700000000	; Fdbbyv (byte size and # backups)
	777777777777	; Fdbsiz
	0		; Fdbcrv
	0		; Fdbwrt
	0		; Fdbref
	0		; Fdbcnt
	0		; Backup
	0
	0
	0
	0
	777777777777	; Fdbusw

WOPR:	0		; Header
	200000000000
	0
	0
	0
	777777777777	; Creation date
	0
	0
	0
	0
	0
	777777777777	; Fdbcrv
	777777777777	; Fdbwrt
	777777777777	; Fdbref
	777777777777	; Fdbcnt
	777777777777
	777777777777
	777777777777
	777777777777
	777777777777
	0

; String to directory
; Call:	1	; Positive for no recognition
;	2	; Source designato$
;	STDIR
; Return
;	+1	; No match
;	+2	; Ambiguous
;	+3	; Unique match

^.STDIR:JSYS MENTR
	MOVE A,2
	PUSHJ P,CPYFUS
	JRST MRETN
	PUSH P,A		; Save location of the temp block
	PUSH P,B		; Save string pointer to tail
	MOVEI JFN,-FILOPT(P)	; Set jfn so filopt(jfn) refers to pdl
	XCTUU [SKIPL 1]
	TEST(OA,NREC)
	TEST(Z,NREC)
	PUSHJ P,DIRLUK
	SOS -2(P)		; Undo one skip
	JRST STDIR1
	XCTUU [EXCH A,1]	; Return the directory number
	SUB P,[XWD 1,1]
	JUMPGE A,STDIR4		; If no recognition, then no tail to copy
	UMOVE A,2		; Get the user's pointer
	MOVE B,(P)
	PUSHJ P,CPYTUS
STDIR4:	UMOVE A,1		; Get the directory number back
	PUSHJ P,GETDDB
	BUG(HLT,<STDIR: GETDDB FAILED WHEN DIRLUK DIDN'T.>)
	MOVE A,DDBMOD(A)
	XCTUU [HLLM A,1]
	UNLOCK DIRLCK
	AOSA -1(P)
STDIR1:	POP P,B
	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	SKIPRT
	JRST MRETN

; Directory number to string conversion
; Call:	1	; Sink designator
;	2	; Directory number
;	DIRST
; Return
;	+1	; Error
;	+2	; Ok

^.DIRST:JSYS MENTR
	UMOVE A,2
	PUSHJ P,GDIRST
	JRST MRETN
	UNLOCK DIRLCK
	PUSHJ P,JFNSS
	AOS (P)
	JRST MRETN

; Make a new fd
; Call:	A	; Pointer to parameter block
;	MAKFD
; Return
;	+1	; Error
;	+2	; Success
;	1	; User number
; In parameter block
;	0	; Pointer to name string
;	1	; Pointer to password string, 0 if none
;	2-N	; Copy of ddb image

^.CRDIR:JSYS MENTR
	MOVE A,CAPENB
	TRNN A,WHEEL!OPR
	ERABRT(CRDIX1)
	UMOVE E,2
	UMOVE A,1
	PUSHJ P,CPYFUS		; Copy directory name string
	ERR CRDIX3		; No room in jsb
	MOVE B,1(A)
	TLNN B,774000
	ERR CRDIX5		; Null name illegal
	PUSHJ P,DIRLUU		; Look up the name in directory
	JRST MAKNFD		; Non-existent, must make a new one
	PUSH P,A
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release free storage used for name
	UNLOCK DIRLCK
	POP P,A
	TLNE E,(1B6)
	XCTUU [CAMN A,6(E)]
	JRST CRDIR1
	ERABRT(CRDIX2)		; Directory number disagrees

CRDIR1:	PUSHJ P,GETDDB		; Setup a pointer to the ddb
	BUG(HLT,<CRDIR: GETDDB FAILED WHEN DIRLUU DIDN'T.>)
	MOVE NUM,A		; Save pointer in num
MAKFD0:	TLNN E,(1B1)
	JRST CRDIR3		; No password change
	UMOVE A,1(E)		; Get pointer to password
	PUSHJ P,CPYFUS		; Copy new password to free storage
	ERR CRDIX3,<UNLOCK DIRLCK>
	PUSHJ P,SETMSK		; Store in directory
	PUSHJ P,CPYDIR		; And copy string to directory
	ERR(CRDIX4,<MOVE B,DIRINP
		MOVEI B,1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE	; Release job storage
		UNLOCK DIRLCK>)
	HLRZ B,DDBNAM(NUM)	; Get old password pointer
	HRRZS DDBNAM(NUM)	; Zero old pntr
	PUSH P,A
	JUMPE B,MAKFD1
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release storage if any
MAKFD1:	POP P,A
	SUBI A,DIRORG
	HRLM A,DDBNAM(NUM)	; Store as password
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release jsb storage

CRDIR3:	UMOVE A,2(E)		; Get max disk storage
	TLNE E,(1B2)
	MOVEM A,DDBMAX(NUM)
	UMOVE A,3(E)		; Get privilege bits
	TLNE E,(1B3)
	MOVEM A,DDBPRV(NUM)
	UMOVE A,4(E)
	TLNE E,(1B4)
	MOVEM A,DDBMOD(NUM)
	SETZM DDBRES(NUM)
	UMOVE A,13(E)
	TLNE E,(1B11)
	MOVEM A,DDBGRP(NUM)
	PUSH P,DDBNUM(NUM)
	UNLOCK DIRLCK
	HRLOI A,600000
	PUSHJ P,CHKDEV		; Get index for dsk
	BUG(HLT,<CRDIR: CHKDEV FAILED TO FIND DEV DSK:.>)
	HLRZ B,DEVDSP(B)	; Get ofn of fd
	POP P,A
	PUSHJ P,SETDIR
	BUG(HLT,<CRDIR: SETDIR FAILED ON DIRECTORY FOUND IN INDEX.>)
	UMOVE A,7(E)		; Default file protection
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B7)
	MOVEM A,DIRDPW
	UMOVE A,10(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B8)
	MOVEM A,DIRPRT
	UMOVE A,11(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B9)
	MOVEM A,DIRDBK
	UMOVE A,14(E)
	TLNE E,(1B12)
	MOVEM A,DIRGRP
	PUSH P,DIRNUM
	UNLOCK DIRLCK
	MOVEI A,JSBFRE
	MOVEI B,20
	PUSHJ P,ASGFRE
	 JRST CRDIR4

	MOVE B,(P)
	MOVEM A,(P)
	HRLI A,(<POINT 7,0,34>)
	MOVEI C,"<"
	IDPB C,A
	DIRST
	 JRST CRDIR5
	PUSH P,A
	MOVE B,-1(P)
	ADDI B,1
	HRLI B,(<POINT 7,0,6>)
	SETZ A,
	STDIR
	 JFCL
	 JRST [	POP P,A
		JRST CRDIR5]
	TLNE A,(1B0)
	 JRST [	POP P,A
		JRST CRDIR5]
	POP P,A
	HRROI B,[ASCIZ />MESSAGE.TXT;1;P770404/]
	SETZ C,
	SOUT
	MOVE B,(P)
	HRLI B,(<POINT 7,0,34>)
	MOVSI A,400001
	GTJFN
	 JRST CRDIR5
	HRLI A,FDBCTL
	MOVSI B,FDBPRM!FDBNXF!FDBDEL
	MOVSI C,FDBPRM!FDBDEL
	CHFDB
	HRRZS A
	RLJFN
	 JFCL
CRDIR5:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
CRDIR4:	SETZM NXTDMP
	JRST MRETN

MAKNFD:	MOVEI B,DDBLEN
	PUSHJ P,ASGDFR		; Assign space for the ddb
	ERABRT(CRDIX4,<UNLOCK DIRLCK
		MOVE B,DIRINP
		MOVEI B,-1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE>)
	MOVEI NUM,(A)		; Point num to the ddb
	SETZM DDBNAM(NUM)	; Clear name pointers
	SETZM DDBNUM(NUM)	; Clear number
	MOVE A,[=250000/1000]
	MOVEM A,DDBMAX(NUM)	; Default disc allocation
	SETZM DDBPRV(NUM)	; Default privileges
	SETZM DDBMOD(NUM)	; Default modes
	SETZM DDBGRP(NUM)
	SETZM DDBRES(NUM)
	PUSHJ P,CPYDIR		; Copy name to directory
	ERR CRDIX4,<MOVE B,NUM
		PUSHJ P,RELDFR
		UNLOCK DIRLCK>
	SUBI A,DIRORG		; Convert to relative pointer
	HRRM A,DDBNAM(NUM)	; Save as name
	HRLZ C,A		; Right half yet to be filled in
	SOS B,DIRLOC
	SOS A,SYMBOT
	CAMG A,FRETOP
	PUSHJ P,XPAND
	CAML A,B
	JRST MAKNFZ
	ADDI A,DIRORG
	HRLI A,1(A)
	BLT A,DIRORG-1(B)
MAKNFZ:	MOVEM C,DIRORG(B)
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	MOVN A,DIRNUM		; Get subindex number
	IMULI A,10000		; Convert to position in file
	ADD NUM,A		; Of the ddb
	SUBI NUM,DIRORG
	UMOVE A,6(E)
	TLNE E,(1B6)
	JRST FNN01
	MOVEI A,0
	PUSHJ P,SETDIR		; Look at block 0
	BUG(HLT,<CRDIR: SETDIR FAILED FOR BLOCK 0.>)
FNN00:	MOVEI B,1
FNN0:	MOVN A,DIRHTL
	HRLZS A
	HRR A,DIRHTO

FNN:	HRRE C,DIRORG(A)
	CAMN B,C
	AOJA B,FNN0
	AOBJN A,FNN
	MOVE A,B
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK		; Is this number available?
	JRST FNN2		; Yes, use it
	JRST FNN00		; No, try another

FNN2:	CAIL A,1
	CAIL A,NFDIB*100
	BUG(HLT,<CRDIR: HSHLUK RETURN INVALID DIRECTORY NUMBER.>)
	MOVEM A,DIRORG(B)	; Store directory number in rh
	HRLM NUM,DIRORG(B)	; And ddb location in left
	MOVE B,NUM
	IDIVI B,10000		; Recover block containing ddb
	ADDI B+1,DIRORG
	PUSH P,B+1
	PUSH P,A
	UNLOCK DIRLCK
	MOVN A,B
	PUSHJ P,MAPDIR		; Return to original subindex
	POP P,A
	POP P,NUM
	HRRM A,DDBNUM(NUM)
	MOVE B,DIRLOC
	HRRM A,DIRORG(B)
	HRRZS A			; Retain only directory number
	PUSH P,DIRNUM		; Save current directory number
	PUSH P,A		; And new directory number
	HRLOI A,600000
	PUSHJ P,CHKDEV
	BUG(HLT,<CRDIR: CHKDEV FAILED TO FIND DEVICE DSK:.>)
	MOVE A,(P)
	HLRZ B,DEVDSP(B)
	PUSHJ P,MAPDIR		; Map the new directory
	PUSHJ P,INIBLK		; Initialize it
	POP P,DIRNUM		; Set its directory number
	POP P,A
	UNLOCK DIRLCK		; Unlock the new directory
	PUSHJ P,MAPDIR		; Restore to mapping current di
	JRST MAKFD0

FNN01:	CAIL A,1
	CAIL A,NFDIB*100
	JRST FNN05
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK
	JRST FNN2
FNN05:	UNLOCK DIRLCK		; Number unavailable, abort
	MOVE B,NUM
	IDIVI B,10000
	MOVEI C,DIRORG(B+1)	; Location in subindex of ddb
	PUSH P,C
	MOVN A,B		; Subindex number
	PUSHJ P,MAPDIR		; Get back to it
	POP P,NUM
	HRRZ B,DDBNAM(NUM)	; Get location of name string
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release it
	MOVE B,NUM		; Location of ddb
	PUSHJ P,RELDFR		; Release it
	MOVE B,DIRLOC		; Location where symtab entry was put
FNN03:	CAMG B,SYMBOT		; Something left to move?
	JRST FNN04		; No
	MOVE A,DIRORG-1(B)
	MOVEM A,DIRORG(B)
	SOJA B,FNN03

FNN04:	AOS SYMBOT
	UNLOCK DIRLCK
	ERABRT(CRDIX6)

; Get directory info
; Call:	1	; Directory number
;	2	; Pointer to parameter block
;	3	; String pointer for password
;	GTDIR

^.GTDIR:JSYS MENTR
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	ERABRT(GTDIX1)		; Not wheel or opr
	PUSHJ P,GETDDB
	ERABRT(GTDIX2)
	UMOVE E,2
	UMOVE C,3
	JUMPGE C,GTDIR1
	CAML C,[777777000000]
	HRLI C,(<POINT 7,0>)
GTDIR1:	HLRZ B,DDBNAM(A)
	ADDI B,DIRORG
	HRLI B,(<POINT 7,0,35>)
	UMOVEM C,1(E)
	UMOVEM C,3
	ILDB D,B
	XCTMU [IDPB D,C]
	JUMPN D,.-3
	MOVE D,DDBMAX(A)
	UMOVEM D,2(E)
	MOVE D,DDBPRV(A)
	UMOVEM D,3(E)
	MOVE D,DDBMOD(A)
	UMOVEM D,4(E)
	MOVEI D,0
	UMOVEM D,5(E)
	MOVE D,DDBNUM(A)
	UMOVEM D,6(E)
	HRRZ D,(A)
	CAIGE D,DDBLEN
	JRST GTDIR2
	MOVE D,DDBDAT(A)
	UMOVEM D,12(E)

GTDIR2:	MOVE D,DDBGRP(A)
	UMOVEM D,13(E)
	PUSH P,DDBNUM(A)
	HRLOI A,600000
	PUSHJ P,CHKDEV
	BUG(HLT,<GTDIR: CHKDEV FAILED TO FIND DEVICE DSK:.>)
	HLRZ B,DEVDSP(B)
	POP P,A
	UNLOCK DIRLCK
	PUSHJ P,MAPDIR
	MOVE D,DIRDPW
	UMOVEM D,7(E)
	MOVE D,DIRPRT
	UMOVEM D,10(E)
	MOVE D,DIRDBK
	UMOVEM D,11(E)
	MOVE D,DIRGRP
	UMOVEM D,14(E)
	JRST MRETN

; Pmap jsys
; Call:	1	; Page ident (frk.pn or jfn.pn)
;	2	; Page ident
;	3	; Bits 2,3,4 to set page table access
;	PMAP

^.PMAP:	JSYS MENTR
	IOR 1,2
	JUMPGE 1,[MOVEI A,PMAPX2
		JRST PMAPER]
	UMOVE A,2
	PUSHJ P,CPMAP
	TLNN C,(1B3)
	ERABRT(PMAPX1)
	PUSH P,A
	UMOVE A,1
	CAMN A,[-1]		; Delete wanted?
	AOJA A,PMAP2		; Yes, put 0 in a
	PUSHJ P,CPMAP
PMAP2:	PUSH P,C
	PUSH P,A
	XCTUU [SKIPGE A,1]	; Is from a file?
	JRST PMAP4		; No.
	HLRZS A			; Yes, get jfn
	MOVSI B,2
	ADDM B,FILLFW(A)	; Increment count of reasons for opening
PMAP4:	XCTUU [SKIPL A,2]	; Is "to" a file?
	JRST [	XCTUU [SKIPL B,1]
		ERABRT(PMAPX2)
		HLRZS A
		MOVSI C,2
		CAME B,[-1]
		ADDM C,FILLFW(A)
		JRST PMAP3]
	MOVE A,-2(P)		; Get ptn.pn of "to"
	PUSHJ P,MRPACS		; Find out what's currently there.
	JUMPE A,PMAP3		; Jump if empty
	TLNE A,(1B10)
	JRST PMAP3		; Or if private
	MOVE A,-2(P)		; Is indirect or share
	PUSHJ P,MRPT		; Get it's id
	JRST PMAP3		; Not file
	PUSHJ P,OFNJFX		; Convert to jfn
	JRST PMAP3		; No jfn
	MOVSI B,-2
	HLRZS A
	ADDB B,FILLFW(A)
	TLNN B,777777
	CLOSF			; Close the file if count goes to 0
	JFCL

PMAP3:	POP P,A
	POP P,C
	POP P,B
	TLO C,1407		; Retain write copy bit and disposal
	XCTUU [AND C,3]
	PUSHJ P,SETPT
	JFCL
	JRST MRETN

PMAPER:	MOVEM A,LSTERR
	MOVEM B,ERRSAV
	JRST ITRAP

CPMAP:	JUMPL A,FRKMAP
	PUSHJ P,JFNOFN
	ERABRT(,<MOVEM JFN,ERRSAV>)
	MOVE C,STS
	AND C,[XWD READF!WRTF!XCTF,0]
	LSH C,-1
	TEST(NN,ASPF)
	POPJ P,
	PUSH P,A
	PUSHJ P,MRPACS
	MOVE C,A
	POP P,A
	AND C,[XWD 160000,0]
	POPJ P,

FRKMAP:	PUSHJ P,FKHPTN
	BUG(HLT,<FRKMAP: FKHPTN YIELDED IMPOSSIBLE NO-SKIP RETURN.>)
	MOVSI C,160000
	POPJ P,

; Rhis routine is called from write copy code in pagem to reduce the
; The map count of a page
; Call:	1	; Ofn.pn
;	PUSHJ P,JFNDCR
; Returns +1 always

JFNDCR:	PUSHJ P,OFNJFX
	POPJ P,
	HLRZS A
	MOVSI B,-2
	ADDB B,FILLFW(1)
	TLNE B,777777
	 POPJ P,
	MOVSI B,FRKF
	ANDCAM B,FILSTS(JFN)
	POPJ P,

; Read map
; Call:	LH(1)	; Fork handle
;	RH(1)	; Page number
;	RMAP
; Retrn
;	+1
;	LH(1)	; Jfn
;	RH(1)	; Page number
;	2	; Access read, write,execute,nonexistent in bits 2-5

^.RMAP:	JSYS MENTR
	PUSHJ P,FRKMAP		; Convert frk.pn to ptn.pn
	PUSHJ P,MRPT		; Call map routine
	 JRST RMAPFK
	PUSH P,B
	PUSHJ P,OFNJFN
RMAP0:	 SETO A,		; Unidentifiable
RMAP1:	POP P,B
	UMOVEM A,1
	UMOVEM B,2
	JRST MRETN

RMAPFK:	PUSH P,B
	JUMPE A,RMAP0
	PUSHJ P,PTNFKH
	JRST RMAP1

; Read accessiblity of page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	RPACS

^.RPACS:JSYS MENTR
	TRNE 1,777000
	SKIPGE 1
	JRST RPACS1
	HLRZS A
	MOVE A,FILSTS(A)
	TLNN A,LONGF
	JRST [	XCTUU [SETZM 2]	; File not long
		JRST MRETN]
	UMOVE 1,1
RPACS1:	PUSHJ P,CPMAP
	PUSHJ P,MRPACS
	UMOVEM 1,2
	JRST MRETN

; Set accessibility of a page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	SPACS

^.SPACS:JSYS MENTR
	PUSHJ P,CPMAP		; Convert to ptn.pn
	UMOVE B,1
	JUMPL B,SPACFK
	TEST(NN,WRTF)		; Must be able to write
SPACER:	JRST [	MOVEI A,SPACX1
		MOVEM A,LSTERR
		JRST ITRAP]
	MOVSI C,160000
	JRST SPAC1

SPACFK:	PUSH P,A		; Save page handle
	PUSHJ P,MRPACS		; Get access of page
	TLNN A,(1B5)
	JRST SPACER		; Non-existent page
	TLNE A,(1B10)
	JRST SPACPR		; Private page
	PUSH P,A		; Save access
	MOVE A,-1(P)		; Get back the page handle
	PUSHJ P,MRPT		; Get map contents
	JRST SPACP1		; Indirect or shared to fork
	PUSHJ P,OFNJFN		; Convert to jfn.pn
	JRST SPACCF		; Closed file
	PUSHJ P,CPMAP		; Get allowable access
	SUB P,[XWD 1,1]
	JRST SPAC2

SPACCF:	POP P,C
	AND C,[XWD 160000,0]
	JRST SPAC2

SPACP1:	SUB P,[XWD 1,1]
SPACPR:	MOVSI C,160000
SPAC2:	TLO C,1400
	POP P,A
SPAC1:	UMOVE B,2
	AND B,C
	PUSHJ P,MSPACS
	JRST MRETN

; Find first free file page
; Call:	1	; Jfn
;	FFFFP
; Return
;	+1
;	1	; Jfn.pn of first free page

^.FFFFP:JSYS MENTR
	HRLZS A
FFFFPL:	RPACS
	JUMPE B,FFFFP1
	AOJA A,FFFFPL

FFFFP1:	UMOVEM A,1
	JRST MRETN

; Find first used file page
; Call:	LH(1)	; Jfn
;	RH(1)	; Page number to start with
;	FFUFP
; Returns
;	+1	; Error
;	+2	; Success jfn.pn of first used page in 1

^.FFUFP:JSYS MENTR
	HLRZ JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)		; Tty and byte no good
	TEST(NN,OPENF)
	ERUNLK(FFUFX1)		; Not open
	MOVEI A,@NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(FFUFX2)		; Not disk
	TEST(NE,LONGF)
	JRST FFUFPL
	UMOVE A,1
	TRNE A,777000
	ERUNLK(FFUFX3)		; Page beyond 777 of short can't exist
	HLL A,FILOFN(JFN)
	PUSHJ P,FFUFF
	ERUNLK(FFUFX3)		; No pages in use
FFUFPX:	XCTUU [HRRM A,1]
	PUSHJ P,UNLCKF
	JRST SKMRTN

FFUFPL:	UMOVE A,1
	HRRZS A
FFUFP1:	MOVE B,A
	LSH B,-9		; Get ptt number
	ADD B,FILLFW(JFN)
	SKIPE (B)		; Check for pt existence
	JRST FFUFP2		; Exists, scan it
FFUFP3:	ADDI A,1000
	ANDCMI A,777
	TLNN A,777777
	JRST FFUFP1
	ERUNLK(FFUFX3)

FFUFP2:	PUSH P,A
	PUSHJ P,JFNOF1		; Get ofn.pn for this page
	BUG(HLT,<FFUFP: IMPOSSIBLE FAILURE OF JFNOF1.>)
	PUSHJ P,FFUFF		; Scan the pt for stuff
	JRST [	POP P,A	; None found
		JRST FFUFP3]
	POP P,B
	ANDI B,777000
	ADD A,B
	JRST FFUFPX		; Success

FFUFF:	PUSH P,A
	PUSHJ P,ASGPAG		; Get a page to map the pt
	JRST [	POP P,A
		POPJ P,]
	MOVE B,A
	HRLI B,100000
	HLRZ A,(P)
	PUSHJ P,SETMPG		; Map the pt
	HRRZ A,(P)		; Get starting page number
	ADDI A,(B)		; Location of disc address
FFUFF0:	SKIPE (A)		; Empty?
	JRST FFUFF1		; No, found it
	CAIGE A,777(B)		; Whole pt scanned?
	AOJA A,FFUFF0		; No, try next one.
FFUFF2:	MOVEI A,0
	PUSHJ P,SETMPG		; Unmap the pt
	HRRZ A,B
	PUSHJ P,RELPAG		; Release the page
	POP P,A
	POPJ P,

FFUFF1:	ANDI A,777		; Get pn part
	MOVEM A,(P)
	AOS -1(P)		; Skip return
	JRST FFUFF2

; Check for tty designator

CHKTTM:	SKIPA JFN,1
CHKTTY:	UMOVE JFN,1
	PUSHJ P,CHKJFN
	ERABRT()
	JRST .+2
	ERABRT(DESX6)
	MOVEI A,-TTYDTB(DEV)
	JUMPN A,CPOPJ		; Not tty, no skip
	HLRZ 2,DEV
	JRST SKPRET

; Jsys's see jsys manual for description of calling sequences

; Clear input buffer

^.CFIBF:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	PUSHJ P,TTCIBF
UNL:	PUSHJ P,UNLCKF
	JRST MRETN

; Clear file output buffer

^.CFOBF:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	PUSHJ P,TTCOBF
	JRST UNL

; Skip if input buffer empty

^.SIBE:	JSYS MENTR
	PUSHJ P,CHKTTY
	JRST SIBE1
	PUSHJ P,TTSIBE
	JRST UNL1		; RETURN NO. OF BYTES IN BUFFER
SKPUNL:	AOS (P)
	JRST UNL

SIBE1:	TEST(NE,OPENF)
	TEST(NN,READF)
	 JRST SKPUNL
	SKIPLE A,FILCNT(JFN)
	 JRST UNL1
IFDEF NETN,<HRRZ A,DEV
	CAIE A,NETDTB
	 JRST SKPUNL
	HLRZ A,DEV
	SKIPLE A,NETCNT(A)
	 JRST UNL1>
	JRST SKPUNL

; Dismiss until input buffer is empty

^.DIBE:	JSYS MENTR
	PUSHJ P,CHKTTY
	JRST MRETN
	PUSHJ P,TTDIBE
	JRST UNL

; SKIP IF OUTPUT BUFFER FULL

^.SOBF:	JSYS MENTR
	PUSHJ P,CHKTTY
	TDZA A,A		;RETURN +1 WITH 0
	PUSHJ P,TTSOBF
	JRST UNL1		;RETURN +1 WITH NO. BYTES IN BUFFER
	AOS (P)
UNL1:	UMOVEM 1,2		;RETURN COUNT OF BYTES IN BUFFER
	JRST UNL

; Skip if output buffer is empty

^.SOBE:	JSYS MENTR
	PUSHJ P,CHKTTY
	JRST SOBE1
	PUSHJ P,TTSOBE
	JRST UNL1
SOBE1:	AOS (P)
	JRST UNL

; Dismiss until output buffer is empty

^.DOBE:	JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	PUSHJ P,TTDOBE
	JRST UNL

; Get tab settings

^.GTABS:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST [	XCTUU [SETZB A,2]
		UMOVEM A,3
		UMOVEM A,4
		JRST UNL]
	PUSHJ P,TTGTBS
	UMOVEM 1,2
	UMOVEM 3,3
	UMOVEM 4,4
	JRST UNL

; Set tab stops

^.STABS:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	UMOVE 4,4
	PUSHJ P,TTSTBS
	JRST UNL

; Read modes

^.RFMOD:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST RFMOD1
	PUSHJ P,TTRMOD
	UMOVEM 1,2
	JRST UNL

RFMOD1:	MOVE A,STS
	ANDI A,17
	ADD A,[=66B10+=72B17+=7B3]
	UMOVEM A,2
	JRST UNL

; Set file modes

^.SFMOD:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSMOD
	JRST UNL

; Read file position

^.RFPOS:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST [	XCTUU [SETZM 2]
		JRST UNL]
	PUSHJ P,TTRPOS
	UMOVEM 1,2
	JRST UNL

; Set file position

^.SFPOS:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSPOS
	JRST UNL

; Read control character output control

^.RFCOC:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST RFCOC1
	PUSHJ P,TTRCOC
	UMOVEM 1,2
	UMOVEM 3,3
	JRST UNL

RFCOC1:	MOVE A,[BYTE (2)2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
	UMOVEM A,2
	UMOVEM A,3
	JRST UNL

; Set control character output control

^.SFCOC:JSYS MENTR
	PUSHJ P,CHKTTY
	JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	PUSHJ P,TTSCOC
	JRST UNL

; Simulate teletype input

^.STI:	JSYS MENTR
	PUSHJ P,CHKTTY
	ERABRT(TTYX1)
	UMOVE 1,2
	PUSHJ P,TTSTI
	JRST UNL

; Check device designator
; Call:	A	; Device designator
;	PUSHJ P,CHKDEV
; Return
;	+1	; Error, number in a
;	+2	; Ok
;	B	; Index into device tables
;	C	; Device characteristics word
;	A	; Unit number
;	LH(DEV)	; Unit
;	RH(DEV)	; Dispatch address

^CHKDEV:TLNN A,777777		; Left half zero means tty designator
	JRST TTYDEV
	TLZ A,600000		; These bits always on
	MOVSI B,-NDEV
CHKDVL:	HLLZ C,DEVCHR(B)	; Construct device designator for this dev
	TLZ C,777000
	HRR C,DEVUNT(B)
	CAME C,A		; Is it the same as user's
	AOBJN B,CHKDVL		; No, continue scan
	JUMPGE B,[MOVEI A,DEVX1
		POPJ P,]	; Illegal designator
	HLRZ A,DEVUNT(B)	; Get device assignment
	CAME A,JOBNO
	CAIN A,777777
	JRST CHKDV1		; Assigned this job or unassigned
	MOVEI A,DEVX2
	POPJ P,			; Device not available

CHKDV1:	HRRZ A,C		; Leave unit in a
	MOVE DEV,DEVDSP(B)
	HRL DEV,A		; Dispatch in dev
	MOVE C,DEVCHR(B)	; And characteristics in c
	JRST SKPRET

TTYDEV:	CAIN A,777777
	JRST CTTYDV
	TRZ A,400000		; Convert tty designator to
	HRLI A,600000+12	; To ordinary device designator
	JRST CHKDEV		; And try again

CTTYDV:	MOVE B,JOBNO
	HRLZI A,JOBPT(B)
	HRRI A,DISGET
	SKIPGE B,JOBPT(B)
	JSYS EDISMS
	HLRZ A,B
	JRST TTYDEV

; Assign device
; Call:	1	; Device designator
;	ASND
; Return
;	+1	; Error, not assignable or bad designator etc.
;	+2	; Ok, the device specified is now assigned to this job

^.ASND:	JSYS MENTR
	LOCK DEVLCK
	PUSHJ P,CHKDEV
	ERR(,<UNLOCK DEVLCK>)
	TLNN C,(1B3)		; Is this an assignable device?
	ERR(ASNDX1,<UNLOCK DEVLCK>)
	LDB D,[POINT 9,C,17]
	CAIN D,12
	JRST [	HLRZ D,TTFORK(A)
		CAIE D,777777
		CAMN D,JOBNO
		CAMN A,CTRLTT
		ERR(DEVX2,<UNLOCK DEVLCK>)
		MOVE D,JOBNO
		HRLM D,TTFORK(A)
		JRST .+1]
	MOVSI A,(1B6)
	IORM A,DEVCHR(B)	; Mark this device as assigned by asnd
	MOVE A,JOBNO
	HRLM A,DEVUNT(B)	; Assign to this job
	UNLOCK DEVLCK
	JRST SKMRTN

; Release device
; Call:	1	; Device designator or -1 to release all devices
;	RELD
; Returns
;	+1	; Error, bad designator or not assigned to this job
;	+2	; Ok.

^.RELD:	JSYS MENTR
	LOCK DEVLCK
	CAMN 1,[-1]
	JRST RELDAL
	PUSHJ P,CHKDEV
	ERR(,<UNLOCK DEVLCK>)
	PUSHJ P,RELDD
	UNLOCK DEVLCK
	JRST SKMRTN

RELDAL:	MOVSI B,-NDEV
RELDA1:	HLRZ A,DEVUNT(B)
	CAME A,JOBNO
	JRST RELDA2
	PUSHJ P,RELDD
RELDA2:	AOBJN B,RELDA1
	UNLOCK DEVLCK
	JRST SKMRTN

RELDD:	HRROS DEVUNT(B)
	MOVSI D,(1B6)
	ANDCA D,DEVCHR(B)
	EXCH D,DEVCHR(B)
	TLNN D,(1B6)
	POPJ P,
	LDB D,[POINT 9,D,17]
	MOVE A,DEVUNT(B)
	CAIN D,12
	CAMN A,CTRLTT
	POPJ P,
	HRROS TTFORK(A)
IFDEF NETN,<
	HRRZ B,A
	CAIL B,NTTYS
	PUSHJ P,PTYDET
>
	POPJ P,

; Get device characteristics
; Call:	1	; Device designator
;	DVCHR
; Return
;	+1	; Ok
;	2	; Device characteristics word
;	LH(3)	; Job to which device is assigned
;	RH(3)	; Unit number

^.DVCHR:JSYS MENTR
	HLRZ B,1
	TRZ B,777
	CAIL 1,400000		; Is this a tty designator?
	CAIL 1,400000+NLINES
	CAIN B,600000		; Or a device designator
	JRST DVCHR1		; Yes, do directly
	UMOVE JFN,1		; No. translate first
	PUSHJ P,CHKJFN
	ERABRT()
	JFCL
	JRST [	UMOVEM JFN,1
		JRST DVCHR1]
	HLRZ A,FILDDN(JFN)	; Get pointer to device name block
	HRLI A,(<POINT 7,0,35>)
	STDEV			; Convert string to device designator
	ERABRT(<(2)>,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	UMOVEM 2,1
DVCHR1:	UMOVE A,1
	PUSHJ P,CHKDEV
	JRST [	CAIE A,DEVX2	; Was error due to unavailablity
		JRST ERABRD	; No, abort
		MOVE C,DEVCHR(B)
		JRST .+2]
	TLO C,(1B5)
	UMOVEM C,2
	MOVE A,DEVUNT(B)
	UMOVEM A,3
	JRST MRETN

; String to device
; Call:	1	; Device designator
;	STDEV
; Return
;	+1	; Error
;	+2	; Ok
;	2	; Device designator

^.STDEV:JSYS MENTR
	UMOVE A,1
	PUSHJ P,CPYFUS
	ERR(GJFX22)
	PUSH P,A
	PUSHJ P,DEVLUK		; Look up the device name
	JRST [	CAIE A,GJFX16
		JRST .+1
		MOVEI A,STDVX1
		UMOVEM A,2
		JRST STDEV1]	; No such device
	AOS -1(P)
	HRRZ A,DEVUNT(B)
	HLL A,DEVCHR(B)
	TLZ A,777000
	TLO A,600000
	UMOVEM A,2
STDEV1:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	JRST MRETN

; Device to string
; Call:	1	; Destination designator
;	2	; Device designator
;	DEVST
; Return
;	+1	; Ok

^.DEVST:JSYS MENTR
	UMOVE A,2
	PUSHJ P,CHKDEV
	JRST [	CAIE A,DEVX2
		ERR()
		JRST .+1]
	MOVE C,DEVNAM(B)
	MOVE D,[POINT 6,C]
DEVST0:	ILDB B,D
	JUMPE B,DEVST1
	ADDI B,40
	PUSHJ P,BOUTN
	JRST DEVST0

DEVST1:	UMOVE A,1		; Preserve user 1
	PUSHJ P,BOUTN		; Write the null
	UMOVEM A,1		; Restore user 1
	AOS (P)
	JRST MRETN

; Mount device
; Call:	1	; Device designator
;	MOUNT
; Return
;	+1	; Error
;	+2	; Ok

^.MOUNT:JSYS MENTR
	UMOVE A,1
	TLZN A,(1B3)		; Directory to be read?
	TDZA B,B		; Yes
	SETO B,			; No
	PUSH P,B
	PUSHJ P,CHKDEV
	ERR()
	UMOVE 1,1
	TLZ 1,(1B3)
	TLNE C,(1B8)		; Already mounted?
	 JRST [	DSMNT		; ATTEMPT TO DISMOUNT FIRST
		 ERR()		; ERROR IF CAN'T
		JRST .+1]
	TLNN C,(1B7)		; Mountable?
	ERR(MNTX3)		; No
	EXCH B,(P)		; Save b, get directory read flag
	PUSHJ P,@MNTD(DEV)	; Call device mount routine
	ERR(MNTX2)		; Not mountable
	POP P,B
	MOVSI C,(1B8)
	IORB C,DEVCHR(B)	; Mark device as mounted
	JRST SKMRTN

; Dismount device
; Call:	1	; Device designator
;	DSMNT
; Return
;	+1	; Error
;	+2	; Ok

^.DSMNT:JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	ERR()			; Illegal designator or not available
	TLNN C,(1B8)		; Mounted?
	ERR(DEVX3)		; No, can't dismount
	PUSH P,B
	PUSHJ P,@DSMD(DEV)	; Call device dismount
	ERR(DSMX1)		; Files open, can't dismount
	MOVSI C,(1B8)
	POP P,B
	ANDCAM C,DEVCHR(B)	; Mark as not mounted
	AOS (P)
	JRST MRETN

; Initialize directory
; Call:	1	; Device designator
;	INIDR
; Return
;	+1	; Error
;	+2	; Ok

^.INIDR:JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	ERR()
	TLNN C,(1B8)
	ERR(DEVX3)		; Not mounted
	PUSHJ P,@INDD(DEV)
	AOS (P)
	JRST MRETN

; Read directory

^.RDDIR:JSYS MENTR
	PUSHJ P,CHKDEV
	JRST MRETN
	MOVEI B,(DEV)
IFDEF DTAN,<CAIE B,DTADTB>
	ERR(RDDIX1)
IFDEF DTAN,<
	PUSH P,A
	PUSHJ P,DRWAIT
	POP P,A
	MOVS B,DTASTS(A)
	TRNE B,DIRIC
	TLNN B,777777
	ERR(RDDIX1)
	UMOVE A,2
	HRR B,A
	XCTMU [BLT B,177(A)]
	JRST SKMRTN>

; File directory free space
; Call:	1	; Device designator (must be dsk for now)
;	2	; User number
;	FDFRE
; Returns
;	+1	; Error
;	+2	; Success, in 2 the space left in the specified fd
^.FDFRE:JSYS MENTR
	PUSHJ P,CHKDEV
	ERR()			; Some kind of error
	TLNN C,(1B4)
	ERR(FDFRX1)		; Don't know about non-mdd stuff
	UMOVE A,2		; Get directory number
	PUSHJ P,GETDDB
	ERR(FDFRX2)		; No such user
	UNLOCK DIRLCK
	UMOVE A,2
	PUSHJ P,MAPDIR
	MOVE A,DIRFRE+2
	UMOVEM A,2
	JRST SKMRTN

; Special file operation
; Call:	1	; Jfn
;	2	; Operation desired
;	MTOPR

^.MTOPR:JSYS MENTR
	UMOVE JFN,1
	PUSHJ P,CHKJFN
	ERABRT()
	JFCL
	ERABRT(DESX4)
	TEST(NN,OPENF)
	ERABRT(CLSX1,<PUSHJ P,UNLCKF>)
	TEST(Z,ERRF,EOFF)
	UMOVE B,2
	PUSHJ P,@MTPD(DEV)
	PUSHJ P,UNLCKF
	JRST MRETN

; Error number to string
; Call:	1	; Output designator
;	2	; Error number
;	ERSTR

^.ERSTR:JSYS MENTR
	HLRZ 1,2
	PUSHJ P,SETLFK		; Map psb of the fork
	UMOVE B,3
	HRLZI C,ERRSAV(1)
	HRRI C,4
	TRNN B,1B19
	BLT C,10
	XCTUU [HRRZ C,2]
	CAIN C,777777
	MOVE C,LSTERR(1)
	ANDI C,37777
	CAIL C,1000
	JRST MRETN		; Illegal error number
; We now have error number in c, parameters in 4-10, bits and count in b
	PUSH P,B
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.MNEMONICS/]
	MOVSI 1,100001
	GTJFN			; Get jfn for error mnemonics
	JRST NOFIL
	MOVE 2,[XWD 440000,200000]
	PUSH P,1
	JSYS 21
	JRST [	POP P,1
		RLJFN
		JFCL
		JRST NOFIL]
	POP P,1
	ANDI C,777
	RIN			; Read byte number of message
	JUMPE 2,NOFIL2
	PUSH P,2
	MOVEI 2,7
	SFBSZ
	BUG(HLT,<ERSTR: SFBSZ FAILED FOR ERROR.MNEMONICS.>)
	POP P,2
	SFPTR			; Start reading here
	JRST NOFIL2
	POP P,C
	HLRES C
	SKIPE C
	AOS C

CPYER1:	BIN
	CAIN 2,"@"
	JRST ERSTDN
	CAIN 2,"%"
	JRST EXPND
	PUSHJ P,ERST9
	JRST [	AOS (P)
		JRST NOFIL2]
	JRST CPYER1

ERST9:	SKIPE C
	SOJLE C,CPOPJ
	PUSHJ P,SAVAC
	UMOVE JFN,1
	PUSHJ P,ERBOUT
	SOS -NSAC(P)
	UMOVEM JFN,1
	PUSHJ P,RESAC
	JRST SKPRET

ERBOUT:	PUSHJ P,CHKJFN
	POPJ P,
	JFCL
	JFCL
	TEST(NE,ENDF)
	JRST UNLCKF
	TEST(NE,OPENF)
	TEST(NN,WRTF)
	JRST UNLCKF
	AOS (P)
	JRST BYTOUA

NOFIL:	POP P,B
	MOVE D,[POINT 7,[ASCIZ /CANNOT FIND ERROR MESSAGE FILE/]]
NOFILL:	ILDB B,D
	JUMPE B,MRETN
	PUSHJ P,ERST9
	JRST MRETN
	JRST NOFILL

EXPND:	MOVEI D,0
	BIN
	CAIN B,"%"
	JRST CPYER1
EXPND1:	CAIG 2,"9"
	CAIGE 2,"0"
	JRST EXPNDD
	IMULI D,=10
	ADDI D,-60(B)
	BIN
	JRST EXPND1

EXPNDD:	CAIN B,"E"
	JRST EXPEXP
	CAIL D,5
	JRST EXPND
	CAIN B,"A"
	JRST EXPASC
	CAIN B,"O"
	JRST EXPOCT
	CAIN B,"D"
	JRST EXPOCT
	CAIN B,"H"
	JRST EXPHLF
	CAIN B,"F"
	JRST EXPFLT
	CAIN B,"L"
	JRST EXPLOC
	CAIN B,"N"
	JRST EXPJFN
	CAIE B,"@"
	JRST EXPND
	JRST EXPND

EXPEXP:	JRST EXPND

EXPASC:	MOVE B,ERRSAV(D)
	PUSHJ P,ERST9
	JRST ERSTD0
	JRST EXPND

EXPOCT:	MOVE B,ERRSAV(D)
	MOVEI D,10
	PUSHJ P,ERNOUT
	JRST ERSTD0
	JRST EXPND

EXPDEC:	MOVE B,ERRSAV(D)
	MOVEI D,12
	PUSHJ P,ERNOUT
	JRST ERSTD0
	JRST EXPND

ERNOUT:	PUSH P,A
	MOVE A,B
	PUSHJ P,ERNOU1
	SOS -1(P)
	POP P,A
	JRST SKPRET

ERNOU1:	IDIV A,D
	HRLM A+1,(P)
	JUMPE A,.+3
	PUSHJ P,ERNOU1
	POPJ P,
	HLRZ B,(P)
	ADDI B,"0"
	JRST ERST9

EXPHLF:	MOVE D,ERRSAV(D)
	PUSH P,D
	HLRZ B,D
	MOVEI D,10
	PUSHJ P,ERNOUT
	JRST ERSTD1
	POP P,D
	MOVEI B,","
	PUSHJ P,ERST9
	JRST ERSTD0
	PUSHJ P,ERST9
	JRST ERSTD0
	HRRZ B,D
	MOVEI C,10
	PUSHJ P,ERNOUT
	JRST ERSTD0
	JRST EXPND

EXPFLT:
EXPLOC:
EXPJFN:	JRST EXPND

ERSTD1:	POP P,D
	JRST ERSTD0

ERSTDN:	AOS (P)
	AOS (P)
ERSTD0:NOFIL2:	CLOSF
	JFCL
NOFIL1:	RLJFN
	JFCL
	JRST MRETN

; Get last error
; Call:	1	; Fork designator
;	GETER

^.GETER:JSYS MENTR
	PUSHJ P,SETLFK
	MOVE B,LSTERR(1)
	XCTUU [HRL B,1]
	UMOVEM B,2
	MOVEI B,4
	HRLI B,ERRSAV(1)
	XCTMU [BLT B,10]
	JRST MRETN

; Delete deleted files

^.DELDF:JSYS MENTR
	MOVE B,CAPENB
	CAME A,JOBDNO
	TRNE B,WHEEL!OPR
	JRST .+2
	JRST MRETN
	PUSHJ P,GETDDB
	JRST MRETN
	UNLOCK DIRLCK
	OKINT
	UMOVE JFN,1
	PUSHJ P,DELDEL
	JRST MRETN

DELDEW:	MOVEI A,=1000
	DISMS
DELDEL:	MOVE E,TODCLK
	ADDI E,=4000
	SETZ F,
	HRLOI A,600000
	PUSHJ P,CHKDEV
	POPJ P,
	HLRZ B,DEVDSP(B)
	MOVE A,JFN
	PUSHJ P,SETDIR		; Map the appropriate directory
	POPJ P,
	PUSHJ P,ASGPAG		; Get a whole page for stack
	JRST DELP0		; None free
	MOVEI A,-1(A)
	HRLI A,-1000		; Makes a stack pointer
	PUSH A,P		; Save old p as first thing
	MOVE P,A
	MOVE D,SYMBOT
DELP1:	CAMGE D,SYMTOP
	JRST DELP2
	MOVEI A,(P)
	POP P,P
	PUSHJ P,RELPAG
	PUSHJ P,GCDIR
DELP0:	UNLOCK DIRLCK
	OKINT
	JUMPN F,DELDEW
	POPJ P,

DELP2:	HRRZ A,DIRORG(D)
	TRNE A,700000
	AOJA D,DELP1
	PUSH P,D
	MOVE D,A
	PUSHJ P,DELP3
	JUMPE D,DELP4
	POP P,A
	HRRM D,DIRORG(A)
	AOS D,A
	JRST DELP1

DELP4:	MOVE D,(P)
	HLRZ B,DIRORG(D)
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release name block
	MOVE D,(P)
DELP5:	CAMG D,SYMBOT
	JRST DELP6
	MOVE A,DIRORG-1(D)
	MOVEM A,DIRORG(D)
	SOJA D,DELP5

DELP6:	AOS SYMBOT
	POP P,D
	AOJA D,DELP1

DELP3:	CAML E,TODCLK
	SKIPN D
	POPJ P,
	PUSH P,D
	HRRZ D,FDBVER+DIRORG(D)
	PUSHJ P,DELP7
	MOVE A,(P)
	HRRM D,FDBVER+DIRORG(A)
	MOVE D,A
	PUSHJ P,DELTST
	JRST DELP8
	PUSHJ P,DELFIL
	JRST DELP8
	HRRZ A,FDBVER+DIRORG(D)
	JUMPE A,[HLRZ B,FDBEXT+DIRORG(D)
		ADDI B,DIRORG
		CAIE B,DIRORG
		PUSHJ P,RELDFR
		MOVE D,(P)
		HRRZ A,FDBEXT+DIRORG(D)
		HRRM A,(P)
		JRST DELP9]
	HRRM A,(P)
	HRRZ B,FDBEXT+DIRORG(D)
	HRRM B,FDBEXT+DIRORG(A)
DELP9:	MOVEI B,DIRORG(D)
	PUSHJ P,RELDFR
	POP P,D
	JRST DELP3

DELP8:	HRRZ D,FDBEXT+DIRORG(D)
	PUSHJ P,DELP3
	POP P,A
	HRRM D,FDBEXT+DIRORG(A)
	MOVE D,A
	POPJ P,

DELP7:	CAML E,TODCLK
	SKIPN D
	POPJ P,
	PUSH P,D
	PUSHJ P,DELTST
	JRST DELPA
	PUSHJ P,DELFIL
	JRST DELPA
	MOVEI B,DIRORG(D)
	HRRZ D,FDBVER(B)
	HRRM D,(P)
	PUSHJ P,RELDFR
	POP P,D
	JRST DELP7

DELPA:	HRRZ D,FDBVER+DIRORG(D)
	PUSHJ P,DELP7
	POP P,A
	HRRM D,FDBVER+DIRORG(A)
	MOVE D,A
	POPJ P,

DELTST:	MOVE A,FDBCTL+DIRORG(D)
	TLNE A,FDBDEL!FDBNXF!FDBNEX
	JRST SKPRET
	TLNN A,FDBTMP
	POPJ P,
	HLRZ A,FDBVER+DIRORG(D)
	SUBI A,=100000
	SKIPL A			; If not normal temporary
	CAMN A,JOBNO		; Or temp for this job
	JRST SKPRET		; Then skip
	CAIL A,NJOBS
	JRST SKPRET
	PUSH P,B
	HLRZ B,JOBDIR(A)
	CAMN B,DIRNUM
	JRST DELTS1
	HRRZ B,JOBDIR(A)
	CAME B,DIRNUM
	AOS -1(P)
DELTS1:	POP P,B
	POPJ P,

^DELFIL:PUSH P,F
	PUSH P,E
	PUSH P,D
	SKIPN A,FDBADR+DIRORG(D)
	JRST DELFI3
	TLO A,(1B1)
	PUSHJ P,ASOFN
	 JRST [	CAIN A,OPNX16
		JRST DELFI3	; Bad index block, forget it
		JRST DELFI1]	; File is open, cannot expunge
	MOVE D,(P)
	MOVE E,FDBCTL+DIRORG(D)
	TLNE E,FDBLNG
	JRST DELFI4		; Long file
	PUSHJ P,DELPT
DELFI3:	MOVE D,(P)
	SETZM FDBADR+DIRORG(D)
	SETZM FDBSIZ+DIRORG(D)
	HRLOI B,7777
	ANDCAM B,FDBBYV+DIRORG(D)
	SKIPLE B,DIRORG+FDBACT(D)
	SOS DIRORG+1(B)
	MOVSI B,FDBLNG!FDBSHT
	ANDCAB B,FDBCTL+DIRORG(D)
	TLNN B,FDBPRM
	AOS -3(P)
	TLNN B,FDBPRM
	AOS -2(P)
DELFI1:	POP P,D
	POP P,E
	POP P,F
	POPJ P,

DELPT:	HRLZ 2,1
	MOVEI 1,0
	PUSHJ P,SETPT
	AOS 2
	TRNN 2,777000
	JRST .-3
	HLRZ 1,2
	PUSHJ P,DELOFN
	POPJ P,

DELFI4:	PUSH P,A
	PUSHJ P,ASGPAG
	JRST [	POP P,A
		PUSHJ P,RELOFN
		JRST DELFI1]
	PUSH P,A
	MOVE B,A
	HRLI B,140000
	MOVE A,-1(P)
	PUSHJ P,SETMPG
	HRLI B,-1000
DELFI6:	SKIPN A,(B)
	JRST DELFI5
	PUSH P,B
	MOVE B,-2(P)		; Get ofn of pt table
	HLLZ B,SPTH(B)		; Get class field
	TLZ B,760017
	TLZ A,40
	IOR A,B
	PUSHJ P,ASOFN
	 JRST [	CAIN A,OPNX16
		JRST DELFI7
		BUG(HLT,<DELFIL: ASOFN GAVE FAIL RETURN (BUSY) FOR A LONG FILE PAGE TABLE.>)]
	PUSHJ P,DELPT
DELFI7:	POP P,B
	SETZM (B)
DELFI5:	AOBJN B,DELFI6
	MOVE B,(P)
	MOVEI A,0
	PUSHJ P,SETMPG
	POP P,A
	PUSHJ P,RELPAG
	POP P,A
	PUSHJ P,DELOFN
	JRST DELFI3

; Set time and date
; Call:	1	; Date and time in standard format
;	STAD
; Return
;	+1	; Can't set because not wheel or opr
;	+2	; Ok

^.STAD:	JSYS MENTR
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	SKIPGE TADSEC
	JRST STAD1
	MOVEI A,STADX1
	JRST ERRD

STAD1:	SETZ C,
	MOVE A,TODCLK
	IDIVI A,=1000		; Convert to seconds
	XCTUU [HRRZ B,1]	; Get time
	SUB B,A			; Compute offset
	JUMPGE B,.+3
	ADDI B,=24*=3600	; If less than 0, augment
	AOJA C,.-2
	XCTUU [HLRZ A,1]
	SUB A,C
	MOVEM A,TADDAY
	MOVEM B,TADSEC
STAD2:	MOVE A,JOBNO		; This job
	HRRZ B,JOBDIR(A)	; User number
	MOVEM B,LOGBUF+1
	UMOVE B,1		; Tad as given
	MOVEM B,LOGBUF+2
	IORI A,(741B8)		; Tad reset code for fact file
	MOVSM A,LOGBUF
	MOVE A,CTRLTT
	DPB A,[POINT 12,LOGBUF,29] ; Tty
	MOVE 1,[XWD -3,LOGBUF]	;MAKE FACT FILE ENTRY FOR TIME SET
	EFACT
	JFCL
	JRST SKMRTN

; Read time and date
; Call:	RTAD
; Return
;	+1
;	1	; Current date and time or -1 if not set

^.GTAD:	JSYS MENTR
	SKIPGE A+1,TADSEC
	JRST GTAD1		; Not set
	MOVE A,TODCLK
	IDIVI A,=1000
	ADD A,TADSEC
	IDIVI A,=24*=3600
	ADD A,TADDAY
	HRL A+1,A
GTAD1:	UMOVEM A+1,1
	JRST MRETN

LS(TADDAY)
LS(TADSEC)

; Set fact switch
; Call:	1	; New setting
;	SMON
; Traps if process hasn't log privilege

^.SMON:JSYS MENTR
	MOVE C,CAPENB
	TLNN C,LOG
	ERABRT(EFCTX1)
	ANDCAM 1,FACTSW
	AND 2,1
	IORM 2,FACTSW
	JRST MRETN

; Read fact switch
; Call:	TMON
; Return
;	+1	; Always
;	1	; The current fact switch setting

^.TMON:	TDNE 1,FACTSW
	AOS FPC
	XCT MJRSTF

; Enter fact file
; Call:	LH(1)	; Minus entry size
;	RH(1)	; Location of entry
;	EFACT
; Return
;	+1	; Error
;	+2	; Ok

^.EFACT:JSYS MENTR
	MOVE B,CAPENB
	TLNN B,LOG
	ERR(EFCTX1)
	MOVE B,FACTSW
	TLNN B,(1B0)
	JRST SKMRTN		; Fact file not on
	HLRO B,A		; Get size
	CAMG B,[-=64]
	ERR(EFCTX2)		; Too big
	NOINT
	PUSH P,CAPENB		;SAVE CURRENT CAPS
	MOVEI A,WHEEL+OPR	;SET BITS TO ENSURE ACCESS TO
	IORM A,CAPENB		;ACCOUNTS DIRECTORY AND FACT FILE
	MOVEI C,=30
EFACT2:	HRROI B,[ASCIZ /<ACCOUNTS>FACT/]
	MOVSI A,1
	GTJFN
	JRST EFACT3
	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	JSYS 21			; Open for append
	JRST EFACT4
EFACT6:	POP P,1
	POP P,CAPENB		;RESTORE CAPS
	UMOVE C,1
	UMOVE B,(C)
	HLRE D,C
	MOVNS D
	DPB D,[POINT 6,B,35]
	JRST .+2
EFACT1:	UMOVE B,(C)
	BOUT
	AOBJN C,EFACT1
	CLOSF
	BUG(CHK,<EFACT: CLOSF FAILED TO CLOSE FACT FILE.>)
	JRST SKMRTN

EFACT4:	CAIE A,OPNX9
	SETZ C,
	POP P,1
	RLJFN
	JFCL
	SOJLE C,EFACT3
	MOVEI A,=4000
	DISMS
	JRST EFACT2

EFACT3:	HRROI 2,[ASCIZ /<ACCOUNTS>FACT/]
	MOVSI 1,400001
	GTJFN
	JRST EFACT9
	MOVEI C,=30
EFACT8:	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	JSYS 21
	JRST EFACT5
	JRST EFACT6

EFACT5:	CAIE A,OPNX9
	JRST EFACT7
	SOJLE C,EFACT7
	MOVEI A,=4000
	DISMS
	POP P,1
	JRST EFACT8

EFACT7:	POP P,1
	RLJFN
	JFCL
EFACT9:	POP P,CAPENB		;RESTORE CAPS
	BUG(CHK,<EFFACT: COULD NOT REFERENCE FACT FILE.>)
	ERR(EFCTX3)

; Set account for file
; Call:	1	; Jfn
;	2	; String pointer of 500000000000+account number
;	SACTF
; Return
;	+1	; Error
;	+2	; Ok

^.SACTF:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(SACTX1)
	PUSHJ P,GETFDB
	ERUNLK(SACTX4)
	HRLI A,40000
	PUSHJ P,DIRCHK
	ERUNLK(SACTX4,<UNLOCK DIRLCK>)
	UNLOCK DIRLCK
	PUSH P,FILACT(JFN)	; Save current contents of this cell
	UMOVE A,2
	TLNN A,777777
	HRLI A,440700
SACTF1:	CAMG A,[577777777777]
	CAMGE A,[500000000000]
	JRST SACTF2		; Pointer
	MOVEM A,FILACT(JFN)
	PUSHJ P,INSACT
	JRST SACTF3

SACTF2:	MOVE B,MODES
	TLNN B,(1B1)
	ERUNLK(SACTX3)		; Alphanumeric accounts not allowed
	PUSHJ P,CPYFUS		; Copy from the user
	ERUNLK(SACTX2)		; Cannot copy
	HRRZM A,FILACT(JFN)
	PUSHJ P,INSACT
	HRRZ B,FILACT(JFN)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
SACTF3:	POP P,FILACT(JFN)
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get account of file
; Call:	1	; Jfn
;	2	; Core location to put string if any
;	GACTF
; Return
;	+1	; Error
;	+2
;	2	; 500000000000+number of string pointer

^.GACTF:JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERR(GACTX1)
	PUSHJ P,GETFDB
	ERUNLK(GACTX2)
	SKIPLE B,FDBACT(A)
	JRST GACTF1
	TLZ B,700000
	UMOVEM B,2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	AOS (P)
	JRST SKMRTN

GACTF1:	UMOVE E,2
	HRLI E,440700
	UMOVEM E,2
	HRLI E,DIRORG+2(B)
	HRRZ B,DIRORG(B)
	ADDI B,-3(E)
	XCTMU [BLT E,(B)]
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Login

^.LOGIN:JSYS MENTR
	MOVE A,JOBNO
	MOVEI B,777777
	TDNE B,JOBDIR(A)	; Is this job currently logged in?
	ERR(LGINX5)
	UMOVE A,1
	PUSHJ P,GETDDB		; Get directory descriptor block
	ERR(LGINX2)
	MOVE B,DDBGRP(A)
	MOVEM B,GROUPS
	MOVE B,DDBMOD(A)	; Get mode bits
	MOVEM B,MODES
	TLNE B,(1B0)
	ERR(LGINX2,<UNLOCK DIRLCK>)
	PUSHJ P,CHKPSW
	ERR(LGINX4,<UNLOCK DIRLCK>)
	MOVE B,DDBPRV(A)
	HRRM B,CAPMSK
	HLLOS CAPENB
	PUSH P,A
	UMOVE A,3
	PUSHJ P,SETACT		; Set account number/string
	ERR(LGINX1,<UNLOCK DIRLCK>)	; Bad account number
	GTAD
	POP P,B
	HRRZ C,0(B)
	CAILE C,DDBDAT		; Does this user have a ddbdat
	SKIPGE A
	JRST .+2
	EXCH A,DDBDAT(B)
	XCTUU [EXCH A,1]
	MOVEM A,JOBDNO
	HRLS A
	MOVE B,JOBNO
	MOVEM A,JOBDIR(B)
	UNLOCK DIRLCK
	PUSHJ P,LOGONM		; Type logon message
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	SETZM CAPENB
	JRST SKMRTN

; Change account

^.CACCT:JSYS MENTR
	MOVE A,JOBNO
	MOVE B,JOBDIR(A)
	TRNN B,777777
	ERR(CACTX2)
	UMOVE A,1
	PUSHJ P,SETACT
	ERR(CACTX1)
	PUSHJ P,LOGCJM
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	JRST SKMRTN

SETACT:	CAML A,[500000000000]
	CAMLE A,[577777777777]
	JRST .+2
	JRST SETACN		; Numeric
	MOVE B,MODES
	TLNN B,(1B1)
	POPJ P,			; Numeric account required
	MOVE B,A
	MOVEI A,ACCTSR-1
	PUSHJ P,CPYFU1		; Copy account string
	BUG(HLT,<CACCT: IMPOSSIBLE FAILURE OF CPYFU1.>)
	HLRE B,A
	MOVNS B
	ADDI B,2
	MOVEM B,ACCTSL
	HRLI A,(<POINT 7,0,35>)
SETACN:	MOVEM A,ACCTPT
	JRST SKPRET

;PASSWORD CHECK FOR INTERNAL USE
; 1/ directory number
; 2/ password string ptr

PASSWC:	MOVEI A,0(A)
	PUSH P,2
	PUSHJ P,GETDDB
	JRST [	POP P,2
		POPJ P,]
	POP P,2
	PUSHJ P,CHKPSX
	CAIA
	AOS 0(P)
	UNLOCK DIRLCK
	POPJ P,

CHKPSW:	UMOVE B,2
CHKPSX:	PUSH P,B
	HLRZ B,DDBNAM(A)	; Get pointer to password
	JUMPE B,[SUB P,[XWD 1,1]
		POPJ P,]
	MOVE C,DIRORG+1(B)
	TLNN C,774000
	JRST [	SUB P,[XWD 1,1]
		POPJ P,]	; Null password never matches
	HRLI B,(<POINT 7,0,35>)
	ADDI B,DIRORG
	POP P,C
	JUMPGE C,CHKPS1
	CAML C,[777777000000]
	HRLI C,(<POINT 7,0>)
CHKPS1:	XCTMU [ILDB D,C]
	ILDB E,B
	CAME D,E
	POPJ P,
	JUMPN D,CHKPS1
	JRST SKPRET

; Connect to directory
; Call:	1	; Directory number (b0 for check of pswd only)
;	2	; String pointer to password
;	CNDIR
; Return
;	+1	; Error
;	+2	; Ok

^.CNDIR:JSYS MENTR
	MOVE A,JOBNO
	HRRZ B,JOBDIR(A)	; Get directory of login
	UMOVE A,1
	JUMPL A,CNCHK		; Check only wanted
	CAIN B,0		; Must be logged in to connect
	ERR(CNDIX5)
	CAMN A,B
	JRST CNDIR3		; Can always connect to login directory
	PUSHJ P,GETDDB
	ERR(CNDIX3)		; No such directory
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CNDIR2		; Bypass checks for wheels and oprs
	HLRZ B,DDBNAM(A)	; Does this directory have a password
	JUMPE B,CNDIR1		; No
	PUSHJ P,CHKPSW		; Yes, check it
	JRST CNDIR1		; Wrong password, still ok if access
	JRST CNDIR2		; Correct password, success

CNDIR1:	UNLOCK DIRLCK
	OKINT
	UMOVE A,1
	HRRZS A
	PUSHJ P,SETDIR		; Map the directory
	JRST CNDIRQ
	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Do we have the proper access to this
	JRST CNDIRE
CNDIR2:	UNLOCK DIRLCK
CNDIR3:	UMOVE A,1
	MOVE B,JOBNO
	HRLM A,JOBDIR(B)
	HRRZM A,JOBDNO
	JRST SKMRTN

CNCHK:	CAIE B,0
	ERR(CNDIX4)		; Logged in
	HRRZS A
	PUSHJ P,GETDDB
	ERR(CNDIX3)
	PUSHJ P,CHKPSW
	JRST CNDIRE
	UNLOCK DIRLCK
	JRST SKMRTN

CNDIRQ:	BUG(CHK,<CNDIR - SETDIR FAILED>)
	MOVEI 1,CNDIX3
	JRST ERRD

CNDIRE:	MOVEI 1,=3000
	DISMS			;WAIT 3 SECS TO FOIL PASSWORD THIEVES
	UNLOCK DIRLCK
	MOVEI 1,CNDIX1
	JRST ERRD

	BENDP	JSYS

; Copy string to user
; Call:	A	; User pointer
;	B	; Locatin of string block
;	PUSHJ P,CPYTUS

CPYTUS:	JUMPGE A,STDIR0
	CAML A,[777777000000]
	HRLI A,(<POINT 7,0>)
STDIR0:	HRLI B,(<POINT 7,0,35>)
STDIR2:	ILDB C,B
	JUMPE C,STDIR3
	XCTMU [IDPB C,A]
	JRST STDIR2

STDIR3:	UMOVEM A,2
	XCTMU [IDPB C,A]
	POPJ P,

	BEGINP	GTJFN		R.S.TOMLINSON	13 OCTOBER 1971	1310:

USE SWAPPC

EXTERN	NXTDMP		; Zero this to cause open files to be written
EXTERN	MPP		; Saved push pointer on entry to gtjfn
INTERN	.GTJFN,.GNJFN

DEFINE	TMSG'(M)<
	HRROI B,[ASCIZ M]
	PUSHJ P,TSTR>

DEFINE	CHOUT(C)<
	MOVEI B,C
	PUSHJ P,OUTCH>

DEFINE	ERUNLK(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERUNLD]>

DEFINE	ERR(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERRD]>

DEFINE	ERRLJF(N,EXTRA)<
JRST	[EXTRA
	IFDIF <N>,<>,<MOVEI A,N>
	JRST ERRDO]>

; Get a jfn for a file name
; Call:	1	; E
;	2	; String designator
;	GTJFN
; Or
;	LH(1)		; Flags (bit 17 = 1)
;	RH(1)		; Default version
;	2		; String designator or xwd infile,outfile
;	GTJFN
; Return
; +1 error, in 1, error code
; +2 ok, in 1, the jfn for the file

;	LH(E)	; Flags
;	RH(E)	; Default version
;	LH(E+1)	; Input jfn (377777 means none)
;	RH(E+1)	; Output jfn (377777 means none)
;	E+2	; Default string pointer device
;	E+3	; Default string pointer directory
;	E+4	; Default string pointer name
;	E+5	; Default string pointer extension
;	E+6	; Default string pointer protection
;	E+7	; Default string pointer account
;	E+10	; Desired jfn if jfnf=1 (optional)

; In flags

FLG(^OUTPF,L,F,400000)	; Bit 0 for output use
FLG(^NEWNF,L,F,200000)	; Bit 1 new file name only
FLG(^OLDNF,L,F,100000)	; Bit 2 old file only
FLG(PONFF,L,F,040000)	; Bit 3 print "old file"/"new file" etc.
FLG(CFRMF,L,F,020000)	; Bit 4 confirmation required
FLG(^TMPFF,L,F,010000)	; Bit 5 temporary file
FLG(RTYPF,L,F,004000)	; Bit 6 retype whole file name when complete
FLG(NACCF,L,F,002000)	; Bit 7 no access to other forks
FLG(^IGDLF,L,F,001000)	; Bit 8 ignore deleted bit in files
FLG(JFNF,L,F,000400)	; Bit 9 use jfn given in e+11
FLG(JFNAF,L,F,000200)	; Bit 10 use alternate if jfn in e+11 na
FLG(ASTAF,L,F,000100)	; Asterisk allowed
FLG(OSTRF,L,F,000040)	; Output stars allowed
FLG(FILF,L,F,000002)	; If short form, 2 has xwd infile,outfile
FLG(SHTF,L,F,000001)	; Dummy bit to cause 1 to be taken as flags

; If a default string pointer is 0, then it is assumed unspecified
; If the lh of a default string pointer is 777777, 440700 is assumed

; Flags in rh of f used by gtjfn

FLG(DEVF,R,F,400000)	; Device is specified
FLG(DIRF,R,F,200000)	; Directory specified
FLG(NAMF,R,F,100000)	; Name specified
FLG(EXTF,R,F,040000)	; Extension specified
FLG(VERF,R,F,020000)	; Version specified
FLG(PRTF,R,F,010000)	; Protection specified
FLG(ACTF,R,F,004000)	; Account specified
FLG(DEVTF,R,F,002000)	; Device was typed in
FLG(DIRTF,R,F,001000)	; Directory was typed in
FLG(NAMTF,R,F,000400)	; Name was typed in
FLG(EXTTF,R,F,000200)	; Extension was typed in
FLG(VERTF,R,F,000100)	; Version was typed in
FLG(ACTTF,R,F,000040)	; Account was typed in
FLG(PRTTF,R,F,000020)	; Protection was typed in
FLG(TMPTF,R,F,000010)	; Temporary flag was set by type in
FLG(CNTVF,R,F,000004)	; Control-v typed
FLG(^NNAMF,R,F,000002)	; No name device
FLG(^NVERF,R,F,000001)	; No versions etc.

; Flags in rh of sts used locally

FLG(^MTCHF,R,F1,400000)	; Match seen during lookup ooerations
FLG(^AMBGF,R,F1,200000)	; More than one match seen during operations
FLG(OCTF,R,F1,100000)	; Octal number is being collected
FLG(NEGF,R,F1,040000)	; Minus sign was typed
FLG(^UNLKF,R,F1,020000)	; Used by directory to remember to unlock
FLG(STRF,R,F1,010000)	; String input exists
FLG(^NREC,R,F1,004000)	; Don't perform recognition
FLG(^NREC1,R,F1,002000)	; Used by lookup routines as for norec
FLG(^DIRXF,R,F1,001000)	; Directory was stepped
FLG(^NAMXF,R,F1,000400)	; Name was stepped
FLG(DIRFF,R,F1,000200)	; Directory is being specified
FLG(EXTFF,R,F1,000100)	; Extension is being specified
FLG(PRTFF,R,F1,000040)	; Protection is being specified
FLG(ACTFF,R,F1,000020)	; Account is being specified
FLG(NUMFF,R,F1,000010)	; Number is being collected
FLG(KEYFF,R,F1,000004)	; Looking for t, p, a
FLG(^NEWF,R,F1,000002)	; A new file name was created
FLG(^NEWVF,R,F1,000001)	; A new version of an existing file was created

; Flags in lh of f1 (scan control)

FLG(^DIRSF,L,F1,100000)	; Scan directories <*>
FLG(^NAMSF,L,F1,040000)	; Scan names (^*.)
FLG(^EXTSF,L,F1,020000)	; Scan extensions (^.*)
FLG(^VERSF,L,F1,010000)	; Scan versions (;*)
FLG(^RVERF,L,F1,004000)	; Most recent version specified
FLG(^HVERF,L,F1,002000)	; New version specified
FLG(^LVERF,L,F1,001000)	; Lowest version specified
FLG(^FXACT,L,F1,000400)	; Account specified with *'s
FLG(^FXTMP,L,F1,000200)	; ;t specified with *'s
FLG(^EXTXF,L,F1,000100)	; Extension was stepped
FLG(DFSTF,L,F1,000004)	; * in default string
FLG(STARF,L,F1,000002)	; Set by *
FLG(^STEPF,L,F1,000001)	; Step flag

; Parameters

^MAXLC__=39
^MAXLW__8


; Table of byte pointers for getting character class

CCSIZE__5			; Width of character class field

	RADIX =10

CPTAB:	FOR Q_CCSIZE-1,=36,CCSIZE
<	POINT CCSIZE,CCTAB(B),Q
>

	RADIX 8

; Character classification table

DEFINE	CCN'(C,N)<
	FOR Q_1,N
<CC1(C)>>

DEFINE	CC1'(C)<
QW__QW+C<=36-QQ>
QQ__QQ+CCSIZE
IFG QQ-44,<
	QW
QW__0
QQ__CCSIZE
>
>

QQ__CCSIZE
QW__0

CCTAB:	CC1(17)			; Null
	CC1(2)			; Control-a
	CCN 17,4		; Control-b to e
	CC1(3)			; Control-f
	CCN 17,2		; Control-g & h
	CCN 7,2			; Control-i, j
	CC1(17)			; Control-k
	CCN 7,2			; Control-l, m (ff carret)
	CCN 17,4		; Control-n - q
	CC1(4)			; Control-r
	CCN 17,3		; Control-s, t, u
	CC1(16)			; Control-v
	CC1(5)			; Control-w
	CC1(6)			; Control-x
	CCN 17,2		; Control-y & z
	CC1(10)			; Alt-mode
	CCN 17,3		; 34-36
	CC1(7)			; Eol
	CC1(7)			; Space
	CCN 0,9			; ! to )
	CC1(20)			; Asterisk
	CC1(0)			; +
	CC1(7)			; Comma
	CC1(30)			; -
	CC1(14)			; Dot
	CC1(0)			; Slash
	CCN 21,12		; Digits
	CC1(11)			; Colon
	CC1(15)			; Semi-colon
	CC1(12)			; <
	CC1(0)			; =
	CC1(13)			; >
	CC1(0)			; ?
	CC1(7)			; @
	CC1(24)			; A
	CCN 0,16		; B - o
	CC1(23)			; P
	CCN 0,3			; Q - s
	CC1(22)			; T
	CCN 0,6			; U - z
	CCN 0,4			; [\]^
	CC1(7)			; _
	CC1(17)			; Acute accent
	CC1(27)			; Lower case a
	CCN 1,16		; Lower case b - o
	CC1(26)			; Lower case p
	CCN 1,3			; Lower case q - s
	CC1(25)			; Lower case t
	CCN 1,6			; Lower case u - z
	CCN 17,4		; Curly brackets vert bar complement
	CC1(17)			; Rubout

	QW

^.GTJFN:JSYS MENTR		; Enter slow code
	MOVE E,A		; Set pointer to parameter block
	TLNE E,777777		; Lh is non-zero?
	HRRI E,1		; Point to ac's
	XCTUU [HLLZ F,0(E)]	; Get flags from user
	MOVEI F1,0		; Clear f1
	TEST(NE,NACCF)
	TEST(O,FRKF)
	TLNE E,2		; Is 2 a pointer
	JRST GTJFZ		; No, skip the following
	XCTUU [HLRZ A,2]	; Get lh of byte pointer
	HRLZI B,(<POINT 7,0>)
	TRNN A,777777
	XCTUU [SETZM 2]		; Clear pointer if lh = 0
	CAIN A,777777
	XCTUU [HLLM B,2]	; Put 7 bit byte into lh if -1
	CAIE A,0		; Does string pointer exist?
	TEST(OA,STRF)		; Yes it does
GTJFZ:	TEST(Z,STRF)		; No it does not
	PUSHJ P,INFTST
	JRST GTJFZ1
	RFCOC
	PUSH P,B
	PUSH P,C
	RFMOD
	PUSH P,B
	PUSH P,A
	TRZ B,777700
	IORI B,164100
	SFMOD
	PUSHJ P,SFCC0
GTJFZ1:	TLNN E,777777		; Can't specify jfn if short form
	TEST(NN,JFNF)		; Is user trying to specify jfn?
	JRST GTJF1		; No.
	XCTUU [SKIPL JFN,10(E)]	; Yes, get his version of jfn
	CAIL JFN,NJFN
	ERRLJF GJFX1,<MOVEM JFN,ERRSAV>
	NOINT
	LOCK JFNLCK
	SKIPN FILSTS(JFN)	; Is this jfn free?
	JRST [	PUSHJ P,ASGJF1	; Yes, assign it
		JRST GTJF0]
	UNLOCK JFNLCK
	OKINT
	TEST(NN,JFNAF)
	ERRLJF GJFX2,<MOVEM JFN,ERRSAV>
GTJF1:	PUSHJ P,ASGJFN
	ERR(GJFX3)		; Jfn not available
GTJF0:	PUSHJ P,SETTMP		; Set up temporary string block

GTJF2:	PUSHJ P,GCH		; Get next character
	JRST ENDALL		; No more input
	TEST(ZE,CNTVF)		; Control-v pending?
	JRST [	PUSHJ P,UCCH	; Yes, ignore any special meanings
		JRST GTJF2]
	MOVE B,A
	IDIVI B,=36/CCSIZE	; Prepare to get character class
	LDB B,CPTAB(B+1)	; Get character class
	CAIL B,ECHDTB-CHDTB
	ERRLJF GJFX4,<MOVEM A,ERRSAV>
	XCT CHDTB(B)		; Execute the dispatch table
	JRST GTJF2		; Most action characters return here
	JRST GTJF2		; Some things skip for other reasons

; Character dispatch table

CHDTB:	PUSHJ P,UCCH		; (0) upper case letter
	PUSHJ P,LCCH		; (1) lower case letter
	PUSHJ P,DELCH		; (2) cont-a
	PUSHJ P,RECFLD		; (3) cont-f
	PUSHJ P,RETYPE		; (4) cont-r
	PUSHJ P,DELFLD		; (5) cont-w
	PUSHJ P,DELALL		; (6) cont-x
	JRST ENDALL		; (7) cr, lf, ff, tab, _, ,, space, eol
	JRST RECALL		; (10) alt-mode
	PUSHJ P,ENDDEV		; (11) colon
	PUSHJ P,BEGDIR		; (12) <
	PUSHJ P,ENDDIR		; (13) >
	PUSHJ P,ENDNAM		; (14) .
	PUSHJ P,ENDEXT		; (15) ;
	TEST(O,CNTVF)		; (16) control-v
	ERRLJF GJFX4,<MOVEM A,ERRSAV>	; (17) illegal character
	PUSHJ P,STAR	; (20) asterisk
	PUSHJ P,DIGIT		; (21) digits
	PUSHJ P,TCH		; (22) t
	PUSHJ P,PCH		; (23) p
	PUSHJ P,ACH		; (24) a
	PUSHJ P,LCTCH		; (25) lower case t
	PUSHJ P,LCPCH		; (26) lower case p
	PUSHJ P,LCACH		; (27) lower case a
	PUSHJ P,MINUS		; (30) minus sign
ECHDTB:

; Continuation of gtjfn code

; Digits

DIGIT:	MOVE C,FILCNT(JFN)
	CAIGE C,MAXLC-7		; String longer than 7 digits
	JRST UCCH
	TEST(NE,OCTF)
	CAIGE A,"8"
	TEST(NN,NUMFF)		; Or not collecting number
	JRST UCCH		; Treat as letter
	MOVEI B,12
	TEST(NE,OCTF)
	MOVEI B,10
	IMUL NUM,B		; Otherwise collect number
	TEST(NN,NEGF)
	ADDI NUM,-60(A)
	TEST(NE,NEGF)
	SUBI NUM,-60(A)
	JRST LTR		; Also pack into string

; Simple characters

LCCH:	SUBI A,40		; Convert lower case to upper
UCCH:	TEST(Z,NUMFF)		; Number is invalid now
LTR:	TEST(NE,STARF)
	ERRLJF GJFX31
	SOSGE FILCNT(JFN)
	ERRLJF GJFX5		; String too long
	IDPB A,FILOPT(JFN)	; Append character to string
	POPJ P,

; Letter a

ACH:	TEST(ZN,KEYFF)		; Are we looking for a key letter?
	JRST UCCH		; No. treat same as other letter
ACH1:	TEST(NE,ACTF)		; Already have account?
	ERRLJF GJFX12		; Yes. syntax error
	TEST(O,ACTFF,NUMFF)	; We are now collecting account number
	POPJ P,

LCACH:	TEST(ZN,KEYFF)		; Same as for upper case a above
	JRST LCCH
	JRST ACH1

; Letter p

PCH:	TEST(ZN,KEYFF)		; Are we looking for key letter?
	JRST UCCH		; No. treat as for letter
PCH1:	TEST(NE,PRTF)		; Already have protection?
	ERRLJF GJFX13		; Yes, illegal syntax
	TEST(O,PRTFF,NUMFF)
	TEST(O,OCTF)
	POPJ P,

LCPCH:	TEST(ZN,KEYFF)
	JRST LCCH
	JRST PCH1

; Letter t

TCH:	TEST(NN,KEYFF)		; Looking for key?
	JRST UCCH		; No. treat as letter
TCH1:	TEST(O,TMPFF)		; Yes. set temp file flag
	POPJ P,

LCTCH:	TEST(NN,KEYFF)
	JRST LCCH
	JRST TCH1

; Minus sign

MINUS:	JUMPN NUM,UCCH		; If any number has been typed
	TEST(OE,NEGF)
	JRST UCCH		; Or 2 minus signs, treat as letter
	JRST LTR

; Device name terminator (:)
; The string in the block addressed by tmpptr
; Is taken as a device. if the device exists, the string is saved
; As the device name for this file.
; Exits with tmpptr reset to a null string

ENDDEV:	TEST(NE,STARF)
	ERRLJF GJFX31
	TEST(OE,DEVF)
	ERRLJF GJFX6		; Device already specified (syntax)
	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSHJ P,DEVLUK		; Lookup device in device tables
	ERRLJF()		; No such device
	MOVEM DEV,FILDEV(JFN)	; Value of lookup is initial fildev
	PUSHJ P,ENDTMP		; Truncate block
	HRLM A,FILDDN(JFN)	; Store as device name
	OKINT
	TEST(O,DEVTF)		; Remember that device was typed in
	JRST SETTMP		; Reset temp block and return

; Directory name prefix (<)
; Sets dirff to remember that we are getting a directory name

BEGDIR:	TEST(NN,DIRF)		; Already have directory?
	TEST(OE,DIRFF)		; Or currently gettin one
	ERRLJF GJFX7		; Yes. syntax error
	POPJ P,

; Directory terminator (>)
; The string in tmpptr is taken as a directory name.
; If recognized, the corresponding directory number is saved
; As the directory number for this file.
; Exits with tmpptr reset to null

ENDDIR:	TEST(ZE,DIRFF)		; Were we collecting it?
	TEST(OE,DIRF)		; And do we not yet have it?
	ERRLJF GJFX8		; No. error in syntax
	TEST(NN,DEVF)		; Do we have a device yet?
	PUSHJ P,DEFDEV		; No. default it first
	TEST(ZE,STARF)
	JRST STRDIR		; User typed <*>
	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSHJ P,DIRLKX		; Lookup directory (no recognition)
	JFCL
	ERRLJF GJFX17		; No such directory
ENDDI1:	HRRM A,FILDDN(JFN)	; Save directory number
	TEST(O,DIRTF)		; Remember that directory was typed in
	JRST SETTMP		; Reset temp block and return

STRDIR:	TEST(O,DIRSF)
	MOVEI A,1
	JRST ENDDI1

; Name terminator (.)
; The string in tmpptr is taken as a file name.
; If found, the string is saved as the file name of this file.
; Exits with tmpptr reset to null

ENDNAM:	TEST(OE,NAMF)		; Do we already have a name?
	ERRLJF GJFX9		; Yes. syntax error
	TEST(NN,DIRF)		; Do we have a directory yet?
	PUSHJ P,DEFDIR		; No. default it
	TEST(ZE,STARF)
	JRST STRNAM
	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSHJ P,NAMLKX		; Look up name without recognition
	JRST ERRDO		; No such file name
	JRST ERRDO
	PUSHJ P,ENDTMP		; Truncate temp block
ENDNA1:	HRLM A,FILNEN(JFN)	; Save as file name
	OKINT
	TEST(O,NAMTF)
	TEST(O,EXTFF)
	JRST SETTMP		; Reset temp block and return

STRNAM:	TEST(O,NAMSF,STEPF)
	SETZ A,
	PUSHJ P,NAMLKX
	 JRST [	TEST(NN,NNAMF)
		JRST ERRDO
		JRST .+2]
	JRST ERRDO
	HRRZ A,FILTMP(JFN)
	NOINT
	HLLZS FILTMP(JFN)
	JRST ENDNA1

; Semicolon
; Control comes here when a semicolon appears in the input
; Input preceding the semicolon may be:
; 1. a file name if no name has yet been input
; 2. an extension if a name has been input, but no extension
; 3. a protection if neither 1 or 2, and the field was started with p
; 4. a version number if neither 1,2, or 3 and input was numeric
; 5. an account number/string if field was preceded by an a
; Exits with tmpptr reset to null, and keyff=1, numff=1,

ENDEXT:	TEST(NN,NAMF)		; Do we have a name yet?
	PUSHJ P,ENDNAM		; No. take input string as name
	TEST(OE,EXTF)		; Do we have an extension yet?
	JRST ENDEX1		; Yes
	TEST(ZE,STARF)
	JRST STREXT
	PUSHJ P,ENDSTR		; No, terminate, get lookup pointer
	PUSHJ P,EXTLKX		; Lookup extension without recognition
	JRST ERRDO		; No extension
	JRST ERRDO
	PUSHJ P,ENDTMP		; Truncate temp block
ENDEX6:	HRRM A,FILNEN(JFN)	; Store as file extension
	OKINT
	TEST(O,EXTTF)		; Remember that extension was typed in
	TEST(Z,EXTFF)
ENDEX0:	TEST(O,KEYFF,NUMFF)	; Looking for key letters or numbers
	TEST(Z,OCTF)
	JRST SETTMP		; Reset temp block and return

ENDEX1:	TEST(ZN,PRTFF)		; Were we collecting a protection
	JRST ENDEX2		; No
	SKIPL NUM		; Negative numbers are illegal
	TEST(NN,NUMFF)		; Must be number for now
	ERRLJF GJFX14		; Illegal protection
	TLO NUM,500000
	MOVEM NUM,FILPRT(JFN)
	TEST(O,PRTF,PRTTF)	; Have a protection and it was typed
	JRST ENDEX0

STREXT:	TEST(O,EXTSF,STEPF)
	SETZ A,
	PUSHJ P,EXTLKX
	JRST ERRDO
	JRST ERRDO
	HRRZ A,FILTMP(JFN)
	NOINT
	HLLZS FILTMP(JFN)
	JRST ENDEX6

ENDEX2:	TEST(ZN,ACTFF)		; Were we collecting an account
	JRST ENDEX5		; No
	SKIPL NUM		; Positive number and
	TEST(NN,NUMFF)		; Was a number typed?
	JRST ENDEX3		; No
	TLO NUM,500000
	MOVEM NUM,FILACT(JFN)	; Yes, save its negative
	JRST ENDEX4

ENDEX3:	HRRO A,CAPENB
	TRNN A,WHEEL!OPR
	MOVE A,MODES
	TLNN A,(1B1)
	ERRLJF(GJFX30)
	PUSHJ P,ENDSTR		; Account is a string
	PUSHJ P,ENDTMP
	MOVEM A,FILACT(JFN)	; Save positive account block pointer
	OKINT
ENDEX4:	TEST(O,ACTF,ACTTF)
	JRST ENDEX0

ENDEX5:	TEST(NN,NUMFF)		; Was a number input?
	ERRLJF GJFX10
	TEST(OE,VERF)		; And do we not yet have a version?
	ERRLJF GJFX11		; No. syntax error
	TEST(ZE,STARF)
	JRST STRVER
	SKIPN A,NUM
	TEST(O,RVERF)
	CAMN A,[-1]
	TEST(O,HVERF)
	CAMN A,[-2]
	TEST(O,LVERF)
	CAMN A,[-3]
	JRST STRVER
	PUSHJ P,VERLUK		; Lookup this version
	ERRLJF GJFX20		; No such version
STRVR1:	HRRM A,FILVER(JFN)
	TEST(O,VERTF)		; Remember that version was input
	JRST ENDEX0

STRVER:	TEST(O,VERSF,STEPF)
	SETZ A,
	PUSHJ P,VERLUK
	ERRLJF(GJFX20)
	JRST STRVR1

; Default device
; Call:	PUSHJ P,DEFDEV
; Return
;	+1	; Always
; Gets default device string from user or "dsk"
; And stores as the device for the file given in jfn
; Clobbers a,b,c,d

DEFDEV:	TLNN E,777777		; No defaults if short form
	XCTUU [SKIPN A,2(E)]	; Get user's default pointer
	JRST DEFDV1		; None specified, use dsk
	PUSHJ P,REDFLT		; Copy the default string
	TEST(ZE,DFSTF)
	JRST [	MOVEI A,GJFX31
		JRST ERRDO]
	PUSHJ P,DEVLUK		; Lookup device
	ERRLJF()		; None such
	MOVEM DEV,FILDEV(JFN)
	NOINT
	HLRZ A,FILTMP(JFN)
	HRRZS FILTMP(JFN)
	HRLM A,FILDDN(JFN)
	OKINT
	TEST(O,DEVF)
	POPJ P,

DEFDV1:	MOVEI A,JSBFRE		; Prepare to get a block of storage
	MOVEI B,2		; Need two words
	NOINT
	PUSHJ P,ASGFRE
	ERRLJF GJFX22		; No space available
	HRLM A,FILDDN(JFN)	; The block is for the device name
	OKINT
	MOVE B,[ASCIZ /DSK/]
	MOVEM B,1(A)		; The device is "dsk"
	PUSHJ P,DEVLUK
	ERRLJF()		; Dsk should always exist
	MOVEM DEV,FILDEV(JFN)
	TEST(O,DEVF)
	POPJ P,

; Default directory
; Call:	JFN
;	PUSHJ P,DEFDIR
; Returns
;	+	; If successful
; Does not return if unsuccesfull
; Clobbers a,b,c,d

DEFDIR:	TEST(NN,DEVF)
	PUSHJ P,DEFDEV
	TLNN E,777777		; No default if short form
	XCTUU [SKIPN A,3(E)]	; Get default pointer
	JRST DEFDI1		; None specified
	PUSHJ P,REDFLT		; Copy default string
	TEST(ZE,DFSTF)
	JRST STRDIR
	PUSHJ P,DIRLKX		; Look it up
	JFCL
	ERRLJF GJFX17		; None such
	HRRM A,FILDDN(JFN)
	MOVEI A,JSBFRE
	NOINT
	HLRZ B,FILTMP(JFN)
	PUSHJ P,RELFRE		; Release the block
	HRRZS FILTMP(JFN)
	OKINT
	TEST(O,DIRF)
	POPJ P,

DEFDI1:	MOVE A,JOBDNO		; Get the directory number of login
	HRRM A,FILDDN(JFN)
	TEST(O,DIRF)
	POPJ P,

; Default name
; Call:	JFN, ETC.
;	PUSHJ P,DEFNAM
; Return
;	+1	; No default specified
;	+2	; If successful, the name specified is set as filnam
; Does not return if users default does not exist
; Clobbers a,b,c,d

DEFNAM:	TEST(NN,DIRF)
	PUSHJ P,DEFDIR
	TLNN E,777777		; No default for short form
	XCTUU [SKIPN A,4(E)]	; Get user's default pointer
	POPJ P,			; None specified
	PUSHJ P,REDFLT		; Read default string
	TEST(ZE,DFSTF)
	JRST DFSTRN
	PUSHJ P,NAMLKX		; Lookup name
	JRST [	TEST(NE,NNAMF)
		POPJ P,
		JRST ERRDO]
	JRST ERRDO
	NOINT
	HLRZ B,FILTMP(JFN)
	HRRZS FILTMP(JFN)
	HRLM B,FILNEN(JFN)
	OKINT
	TEST(O,NAMF,NAMTF)
	AOS (P)
	TEST(NN,NREC)
	PUSHJ P,TSTRB		; Output the default name
	POPJ P,

DFSTRN:	PUSHJ P,STRNAM
	TEST(Z,EXTFF)
	TEST(O,NAMF,NAMTF)
	TEST(NN,NREC)
	PUSHJ P,TYSTR
	JRST SKPRET

; Default extension
; Call:	JFN, ETC.
;	PUSHJ P,DEFEXT
; Return
;	+1	; User default does not exist
;	+2	; Hunky dory, the string specified by the user becomes
;		; The extension

DEFEXT:	TLNN E,777777		; No default if short form
	XCTUU [SKIPN A,5(E)]	; Get user's default pointer
	POPJ P,
	TEST(NE,NNAMF)
	POPJ P,
	PUSHJ P,REDFLT		; Copy default string
	TEST(ZE,DFSTF)
	JRST DFSTRE
	PUSHJ P,EXTLKX		; Look it up
	POPJ P,
	POPJ P,			; None such
	NOINT
	HLRZ B,FILTMP(JFN)
	HRRZS FILTMP(JFN)
	HRRM B,FILNEN(JFN)
	OKINT
	TEST(O,EXTF,EXTTF)
	AOS (P)
	TEST(NN,NREC)
	TEST(NE,NNAMF)
	POPJ P,
	PUSH P,B
	MOVEI B,"."
	TEST(ZN,EXTFF)
	PUSHJ P,OUTCH
	POP P,B
	PUSHJ P,TSTRB		; Output the default extension
	TEST(NE,NVERF)
	POPJ P,
	CHOUT <";">
	JRST ENDEX0

DFSTRE:	MOVEI B,"."
	TEST(ON,EXTFF)
	TEST(NE,NREC)
	JRST DFSTE1
	TEST(NN,NNAMF)
	PUSHJ P,OUTCH
DFSTE1:	PUSHJ P,STREXT
	TEST(NN,NREC)
	PUSHJ P,TYSTR
	TEST(NN,NREC)
	TEST(NE,NVERF)
	JRST SKPRET
	CHOUT <";">
	JRST SKPRET

; Default version
; Call:	JFN ETC.
;	PUSHJ P,DEFVER
; Return
;	+1	; Unless error
; Sets the file version number to the default specified by user
; Clobbers a,b,c,d

DEFVER:	MOVEI A,0
	TEST(NE,NVERF,NNAMF)
	POPJ P,
	XCTUU [HRRE A,0(E)]	; Get default version
	SKIPN A
	TEST(NN,OUTPF)
	JRST .+2
	SOS A			; 0 default becomes -1 for output
	TEST(NE,TMPFF)
	SKIPLE A
	JRST DEFVR1
	MOVE A,JOBNO		; Default becomes job number for temp
	ADDI A,=100000
DEFVR1:	CAMN A,[-3]
	JRST DFSTRV
	CAMN A,[-2]
	TEST(O,LVERF)
	CAMN A,[-1]
	TEST(O,HVERF)
	SKIPN A
	TEST(O,RVERF)
	PUSHJ P,VERLUK		; Extant?
	JRST ERRDO
	HRRM A,FILVER(JFN)
	MOVE B,A
	TEST(O,VERTF,VERF)
	TEST(NN,NREC)
	PUSHJ P,DNOUT
	POPJ P,

DFSTRV:	PUSHJ P,STRVER
	TEST(O,VERTF,VERF)
	TEST(NN,NREC)
	PUSHJ P,TYSTR
	POPJ P,

; Default account
; Call:	JFN ETC.
;	PUSHJ P,DEFACT
; Returns
;	+1	; Always
; Sets filact to that specified by program
; Clobbers a,b,c,d

DEFACT:	TEST(NE,NVERF,NNAMF)
	POPJ P,
	TLNN E,777777		; No default if short form
	XCTUU [SKIPN A,7(E)]	; Get default account
	POPJ P,			; Nono specified
	TLNN A,777777		; Lh = 0?
	HRLI A,440700		; Yes, set up 7 bit bytes
	CAMG A,[577777777777]	; String pointer?
	CAMGE A,[500000000000]
	JRST DEFAC2		; Yes
	MOVEM A,FILACT(JFN)	; No. numeric
	JRST DEFAC3

DEFAC2:	MOVE B,MODES
	TLNN B,(1B1)
	POPJ P,
	PUSHJ P,REDFLT		; Copy string to temp block
	NOINT
	HLRZ A,FILTMP(JFN)
	HRRZS A,FILTMP(JFN)
	MOVEM A,FILACT(JFN)
	OKINT
DEFAC3:	TEST(O,ACTF)
	POPJ P,

; Default protection
; Call:	JFN ETC.
;	PUSHJ P,DEFPRT
; Return
;	+1	; unless error
; Sets the file protection to default specified by user or directory
; Clobbers a,b,c,d

DEFPRT:	TEST(NE,NVERF,NNAMF)
	POPJ P,
	TLNN E,777777		; No default if short form
	XCTUU [SKIPN A,6(E)]	; Get the default protection from user
	POPJ P,
	CAMG A,[577777777777]	; Must be numeric
	CAMGE A,[500000000000]
	ERRLJF GJFX14		; Otherwise error
	MOVEM A,FILPRT(JFN)
	TEST(O,PRTF)
	POPJ P,

; Copy default string
; Call:	A	; A default string pointer
;	PUSHJ P,REDFLT
; Returns
;	+1	; In a, a lookup pointer
; Copies the default string into a block addressed by lh(filtmp(jfn))
; Clobbers a,b,c,d

REDFLT:	PUSH P,A
	HLRZ A,FILTMP(JFN)
	JUMPN A,REDFL0
	MOVEI A,JSBFRE
	MOVEI B,MAXLW+1
	NOINT
	PUSHJ P,ASGFRE
	ERRLJF GJFX22		; Insufficient space
	HRLM A,FILTMP(JFN)
	OKINT
REDFL0:	HRLI A,(<POINT 7,0>)
	AOS C,A
	POP P,A
	MOVEI D,MAXLC
	MOVEI B,0		; Null byte if next instruction jumps
	TEST(Z,DFSTF)
	JUMPE A,REDFL2		; No pointer
	TLNE A,777777
	JUMPGE A,REDFL1
	CAML A,[777777000000]
	HRLI A,440700
REDFL1:	XCTMU [ILDB B,A]
	PUSH P,C
	PUSH P,B
	IDIVI B,=36/CCSIZE
	LDB C,CPTAB(B+1)
	POP P,B
	CAIN C,20
	JRST REDFST
	CAIL C,21
	CAILE C,24
	CAIN C,30
	JRST .+3
	SKIPE C
	MOVEI B,0
	POP P,C

REDFL2:	IDPB B,C
	SOSG D
	ERRLJF GJFX5
	JUMPN B,REDFL1
	HLRZ A,FILTMP(JFN)
	MOVE B,C
	PUSHJ P,TRMBLK		; Trim the block and return excess
	HLRZ A,FILTMP(JFN)
	MOVN B,(A)
	HRLI A,2(B)
	POPJ P,

REDFST:	TEST(O,DFSTF)
	SUB P,[XWD 1,1]
	POPJ P,

; Delete character

DELCH:	MOVE C,FILCNT(JFN)
	CAIL C,MAXLC		; Any character left in string?
	JRST DELCH2
	CHOUT "\"		; Output backslash
	LDB B,FILOPT(JFN)	; Get last character
	PUSHJ P,OUTCH		; And output it
	AOS FILCNT(JFN)
	MOVE A,FILOPT(JFN)
	PUSHJ P,DBP		; Decrement byte pointer
	MOVEM A,FILOPT(JFN)
	MOVE A,NUM
	TEST(NN,NUMFF)
	POPJ P,
	TEST(NE,OCTF)
	JRST [	IDIVI A,8
		JRST .+2]
	IDIVI A,=10
	MOVE NUM,A
	POPJ P,

DELCH2:	TEST(ZE,STARF)
	SKIPA B,["*"]
DELCH1:	MOVEI B,7
	JRST OUTCH		; Type bell and return to main loop

; Delete current field

DELFLD:	MOVE C,FILCNT(JFN)
	CAIL C,MAXLC		; Any thing in this field?
	JRST [	TEST(ZE,STARF)
		JRST .+1
		JRST DELCH1]
	TMSG </_/>
	JRST SETTMP		; Reset tmp, return to main loop

; Delete everything

DELALL:	MOVE B,[BYTE (2)0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0]
	MOVE C,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	PUSHJ P,SFCC
	TMSG </___
/>
	PUSHJ P,SFCC0
	NOINT
	PUSHJ P,RELJFN		; Release jfn (to clear free storage)
	PUSHJ P,ASGJFN		; And reassign
	ERRLJF GJFX3		; Should not happen, but in case
	XCTUU [HLLZ F,0(E)]
	MOVEI F1,0
	JRST SETTMP		; And start over

; Recognize current field
; Called from gtjfn loop
; Decides which field was being input, and then attempts to recognize it

RECFLD:	TLNE F1,DIRSF!NAMSF!EXTSF!VERSF!STARF
	JRST DING		; Cannot recognize after *
	TEST(NE,DIRFF)		; Find which field is being input
	JRST RECDIR		; Directory name is
	TEST(NE,EXTFF)
	JRST RECEX0		; Extension is
	TEST(NN,NAMF)
	JRST RECNA0		; Recognize name
	MOVE C,FILCNT(JFN)
	CAIE C,MAXLC
	JRST RECFL1		; Some thing typed, treat like cont-f
	TEST(NE,VERF)
	JRST DING		; Can recognize no more
	JRST DEFVER		; Default version

RECFL0:	TEST(NE,DIRFF)
	JRST RECDIR
	TEST(NE,EXTFF)
	JRST RECEXT
	TEST(NN,NAMF)
	JRST RECNAM
RECFL1:	MOVEI B,";"
	TEST(NN,NREC)
	PUSHJ P,OUTCH
	AOS (P)
	JRST ENDEXT

; Recognize directory name
; Call:	RH(FILTMP(JFN))	; Pointer to string block to recognize
;	FILOPT(JFN)	; Pointer to last character in string
; Flags norec, devf, dirf,dirff,dirtf are updated or used
;	PUSHJ P,RECDIR
; Return
;	+1	; Ambiguous
;	+2	; Ok
; Does not return if directory could not exist
; Clobbers most everything

RECDIR:	TEST(NN,DEVF)
	PUSHJ P,DEFDEV		; Default device first
	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
	PUSHJ P,DIRLUK		; Lookup directory name get number
	ERRLJF GJFX17		; No such directory
	JRST [	PUSHJ P,DING
		POP P,FILOPT(JFN)
		POPJ P,]
	HRRM A,FILDDN(JFN)	; Store directory number
	POP P,B
	PUSHJ P,TSTR		; Output remainder of string
	CHOUT(">")		; Terminate
	TEST(O,DIRF,DIRTF)
	TEST(Z,DIRFF)
	AOS (P)
	JRST SETTMP		; Reset temp block and return

; Recognize extension
; This routine operates in the same way as recdir described above

RECEXT:	PUSHJ P,RECEXX
	JRST ERRDO
	JRST DING
	JRST SKPRET

RECEXX:	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
	PUSHJ P,EXTLUK		; Lookup extension
	SOS -1(P)		; No such extension
	JRST [	POP P,FILOPT(JFN)
		JRST SKPRET]	; Ambiguous
	PUSHJ P,ENDTMP		; Truncate temp string get pointer
	HRRM A,FILNEN(JFN)	; Store as extension
	OKINT
	TEST(O,EXTF,EXTTF)
	TEST(Z,EXTFF)
	POP P,B
	AOS (P)
	AOS (P)
	TEST(NN,NNAMF)
	TEST(NE,NREC)		; Were we performing recognition?
	JRST SETTMP		; No. done
	PUSHJ P,TSTR		; Yes, output tail
	TEST(NE,NVERF)
	JRST SETTMP
	CHOUT <";">		; And semicolon
	TEST(O,KEYFF,NUMFF)	; And act like the user did it
	JRST SETTMP		; Reset temp block and return

RECEX0:	PUSHJ P,RECEXX
	 JFCL
	 SKIPA
	 JRST SKPRET
	MOVE C,FILCNT(JFN)
	CAIN C,MAXLC
	PUSHJ P,DEFEXT
	JRST DING
	JRST SKPRET

; Recognize name
; This routine operates in the same way as recdir and recext above

RECNA0:	PUSHJ P,RECNA1
	JRST [	PUSHJ P,DEFNAM
		JRST DING
		JRST .+1]
	TEST(NE,NNAMF)
	JRST SKPRET
	CHOUT "."
	TEST(O,EXTFF)
	JRST SKPRET

RECNAM:	PUSHJ P,RECNA1
	JRST DING
	JRST SKPRET

RECNA1:	TEST(NN,DIRF)
	PUSHJ P,DEFDIR		; Default directory
	PUSHJ P,ENDSTR		; Terminate string, get lookup pointer
	PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing tail
	PUSHJ P,NAMLUK		; Lookup name in directory
	JRST ERRDO
	JRST [	POP P,FILOPT(JFN)
		POPJ P,]	; Ambiguous
	PUSHJ P,ENDTMP		; Truncate temp block, and get pointer
	HRLM A,FILNEN(JFN)	; To put in file name
	OKINT
	TEST(O,NAMF,NAMTF)
	POP P,B
	AOS (P)
	TEST(NN,NNAMF)
	TEST(NE,NREC)
	JRST SETTMP		; Setup new temp, and return
	PUSHJ P,TSTR		; Type remainder
	JRST SETTMP

; Retype input so far

RETYPE:	MOVE B,[BYTE (2)0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0]
	MOVE C,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	PUSHJ P,SFCC
	TMSG </
/>
	PUSHJ P,SFCC0
	HLRZ B,FILDDN(JFN)
	TEST(NN,DEVTF)
	JRST RETY1
	PUSHJ P,TSTRB
	CHOUT ":"
RETY1:	TEST(NN,DIRTF)
	JRST RETY2
	CHOUT("<")
	TEST(NE,DIRSF)
	JRST [	PUSHJ P,TYSTR
		JRST RETY1A]
	HRRZ A,FILDDN(JFN)
	PUSHJ P,GDIRST		; Get the directory name
	JRST RETY1A		; Not supposed to happen
	MOVE B,A
	PUSHJ P,TSTRB		; Type the string
	UNLOCK DIRLCK
	OKINT
RETY1A:	CHOUT(">")
RETY2:	TEST(NE,NNAMF)
	POPJ P,
	TEST(NN,NAMTF)
	JRST RETY3
	TEST(NE,NAMSF)
	JRST [	PUSHJ P,TYSTR
		JRST RETY2A]
	HLRZ B,FILNEN(JFN)
	PUSHJ P,TSTRB
RETY2A:	CHOUT "."
	TEST(NN,EXTTF)
	JRST RETY3
	TEST(NE,EXTSF)
	JRST [	PUSHJ P,TYSTR
		JRST RETY2B]
	HRRZ B,FILNEN(JFN)
	PUSHJ P,TSTRB

RETY2B:	TEST(NE,NVERF)
	POPJ P,
	CHOUT <";">
	TEST(NN,VERTF)
	JRST RETY4
	TEST(NE,VERSF)
	JRST [	PUSHJ P,TYSTR
		JRST RETY4]
	HRRZ B,FILVER(JFN)
	PUSHJ P,DNOUT
RETY4:	TEST(NN,TMPTF)
	JRST RETY5
	TMSG </;T/>
RETY5:	TEST(NN,PRTF)
	JRST RETY3
	TMSG </;P/>
	MOVE B,FILPRT(JFN)
	TLNE B,777777
	JRST [	TLZ B,700000
		PUSHJ P,ONOUT
		JRST RETY3]
	PUSHJ P,TSTRB
RETY3:	TEST(NN,ACTTF)
	JRST RETY6
	TMSG </;A/>
	SKIPLE B,FILACT(JFN)
	JRST [	PUSHJ P,TSTRB
		JRST RETY6]
	TLZ B,700000
	PUSHJ P,DNOUT
RETY6:	PUSHJ P,ENDSTR
	HRRZ B,A
	MOVE C,FILCNT(JFN)
	CAIE C,MAXLC
	PUSHJ P,TSTRB
	TEST(NN,STARF)
	POPJ P,
TYSTR:	TMSG </*/>
	POPJ P,

; Terminator seen, finish up

ENDALL:	TEST(O,NREC)		; Suppress recognition
	TEST(NE,CFRMF)
	JRST ENDALZ
	TEST(NN,PONFF,RTYPF)
	CAIL A,40
	JRST ENDALZ
	MOVE B,[BYTE (2)0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0]
	MOVE C,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	PUSH P,A
	PUSHJ P,SFCC
	POP P,B
	PUSHJ P,OUTCH
	PUSHJ P,SFCC0
	JRST ENDALZ

RECALL:	TLNE F1,DIRSF!NAMSF!EXTSF!VERSF!STARF
	JRST [	PUSHJ P,DING
		JRST GTJF2]
ENDALZ:	TEST(NE,STARF)
	PUSHJ P,[TEST(NN,NAMF)
		JRST ENDNAM
		JRST ENDEXT]
	MOVE C,FILCNT(JFN)
	CAIE C,MAXLC		; Is input string null?
	JRST [	PUSHJ P,RECFL0	; No. recognize field first
		JRST GTJF2	; Ambiguous
		JRST .+1]
	TEST(NE,NAMF)		; Do we have a name?
	JRST ENDAL0		; Yes.
	PUSHJ P,DEFNAM		; No, try the default name
	JRST [	PUSHJ P,RECNAM	; No default, try recognizing null
		JRST GTJF2	; Ambiguous
		JRST ENDAL0]	; Ok, found
ENDAL0:	TEST(NE,EXTF)		; After all that, do we have ext?
	JRST ENDAL4		; Yes
	TEST(NN,EXTFF)
	PUSHJ P,DEFEXT		; Attempt to default extension
	JRST ENDAL6
ENDAL4:	TEST(NN,VERF)		; Do we have a version?
	PUSHJ P,DEFVER		; No, default it
	TEST(NN,NEWF,NEWVF)
	JRST ENDAL7
	TEST(NN,PRTF)		; Do we have protection?
	PUSHJ P,DEFPRT		; No, default it
	TEST(NN,ACTF)		; Do we have an account?
	PUSHJ P,DEFACT		; No, default it
ENDAL7:	TEST(NE,RTYPF)		; User request retyping name?
	PUSHJ P,RETYPE		; Yes, do it
	TEST(NN,PONFF)		; User request print of old/new file etc
	JRST ENDAL3		; No

ENDAL1:	MOVE B,[BYTE (2)0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0]
	MOVE C,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	PUSHJ P,SFCC
	HRROI B,[ASCIZ / [Old file]/]
	TEST(NN,NVERF)
	HRROI B,[ASCIZ / [Old version]/]
	TEST(NE,NEWVF)		; Did we generate a new version?
	HRROI B,[ASCIZ / [New version]/]
	TEST(NE,NEWF)		; Did we generate a new file
	HRROI B,[ASCIZ / [New file]/]
	TEST(NN,NNAMF)
	JRST ENDAL9
	HRROI B,[ASCIZ / [OK]/]
	TEST(NE,CFRMF)
	HRROI B,[ASCIZ / [Confirm]/]
ENDAL9:	TLNN F1,DIRSF!NAMSF!EXTSF!VERSF
	PUSHJ P,TSTR		; Print it
	PUSHJ P,SFCC0
ENDAL3:	XCTUU [HLRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	JRST ENDAL2		; No input file
	TEST(NN,CFRMF)
	JRST ENDAL2		; Or no confirmation requested
	MOVE B,[BYTE (2)1,1,1,1,1,1,1,2,1,2,2,2,2,2,1,1,1,0]
	MOVE C,[BYTE (2)1,1,1,1,1,1,0,1,1,1,1,1,1,2]
	PUSHJ P,SFCC
	BIN			; Else read confirmation character
	IDIVI B,=36/CCSIZE
	LDB B,CPTAB(B+1)	; Get character class
	CAIN B,6
	JRST [	PUSHJ P,DELALL
		JRST GTJF2]
	CAIN B,4
	JRST [	PUSHJ P,RETYPE	; And control-r
		JRST ENDAL1]
	CAIE B,7		; Terminator
	CAIN B,10		; Or alt-mode
	JRST ENDAL2		; Is ok
	ERRLJF GJFX15		; Improper confirmation

ENDAL2:	TEST(NE,PRTF)		; Do we have a protection?
	PUSHJ P,@PLUKD(DEV)	; Insert it into the directory
	TEST(NE,ACTF)		; Do we have an account string?
	PUSHJ P,@ALUKD(DEV)	; Yes, insert it into the directory
	MOVSI B,FDBTMP
	TEST(NE,TMPFF)		; Is this file to be temp?
	PUSHJ P,@SLUKD(DEV)
	NOINT
	MOVEI A,JSBFRE
	SKIPLE B,FILACT(JFN)
	PUSHJ P,RELFRE		; Release storage used to hold account
	SKIPLE B,FILPRT(JFN)
	PUSHJ P,RELFRE		; And protection
	HRRZ B,FILTMP(JFN)
	SKIPE B
	PUSHJ P,RELFRE		; And temp
	HLRZ B,FILTMP(JFN)
	SKIPE B
	PUSHJ P,RELFRE
	FOR @' VAR IN (TMP,PRT,ACT,OPT,CNT),<
	SETZM FIL'VAR(JFN)>
	MOVE STS,FILSTS(JFN)
	TEST(Z,ASGF)		; Clear assign flag
	TEST(O,NAMEF)		; Set name attached flag
	TEST(NE,NACCF)
	TEST(O,FRKF)
	MOVEM STS,FILSTS(JFN)
	PUSHJ P,INFTST
	JRST ENDAL5
	POP P,A
	POP P,B
	SFMOD
	POP P,C
	POP P,B
	SFCOC
ENDAL5:	OKINT
	SKIPRT			; Done, skip return
	TEST(NE,ACTTF)
	TEST(O,FXACT)
	TEST(NE,TMPTF)
	TEST(O,FXTMP)
	TLNN F1,DIRSF!NAMSF!EXTSF!VERSF
	 JRST ENDA51
	HLL JFN,F1
	AND JFN,[XWD DIRSF!NAMSF!EXTSF!VERSF!HVERF!LVERF!RVERF,-1]
	TEST(NN,IGDLF)
	 TLO JFN,(1B12)
ENDA51:	UMOVEM JFN,1		; Return jfn to user
	JRST MRETN		; And exit.

ENDAL6:	MOVEI B,"."
	TEST(ON,EXTFF)
	TEST(NE,NREC)
	JRST .+3
	TEST(NN,NNAMF)
	PUSHJ P,OUTCH
	PUSHJ P,RECEXX
	JRST [	PUSHJ P,DEFEXT
		JRST ERRDO
		JRST ENDAL4]
	JRST [	PUSHJ P,DING
		JRST GTJF2]
	JRST ENDAL4

; Star typed

STAR:	MOVE C,FILCNT(JFN)
	TEST(NE,ASTAF)
	CAIE C,MAXLC		; Any characters typed?
	ERRLJF GJFX31		; Illegal *
	TEST(O,STARF)
	POPJ P,

; Set up temp string block for this jfn
; Call:	JFN IN JFN
;	JSYS SETTMP
; Sets up filopt(jfn) and rh(filtmp(jfn)) and filcnt(jfn)
; Clobbers a,b,c
; Clears num

SETTMP:	HRRZ A,FILTMP(JFN)	; Is block assigned?
	JUMPN A,SETTM1		; Yes, use it
	MOVEI A,JSBFRE
	MOVEI B,MAXLW+1
	NOINT
	PUSHJ P,ASGFRE		; Assign a free storage area in psb
	ERRLJF GJFX22		; No room
	HRRM A,FILTMP(JFN)	; Save in tmpptr
	OKINT
SETTM1:	HRLI A,(<POINT 7,0>)
	AOS A
	MOVEM A,FILOPT(JFN)	; Set filopt(jfn)
	MOVEI A,MAXLC
	MOVEM A,FILCNT(JFN)
	MOVEI NUM,0		; Clear number
	TEST(Z,NEGF)
	POPJ P,

; Get character from string of file
; Call:	PUSHJ P,GCH
; Return
;	+1	; No more input
;	+2	; Ok, in a, the character
; Clobbers b

GCH:	TEST(NN,STRF)		; Does string exist?
	JRST GCH1		; No, get from file
	XCTUU [ILDB A,2]	; Get character increment byte ptr
	JUMPN A,SKPRET		; Return if non-null
	TEST(Z,STRF)		; No more string input
GCH1:	XCTUU [HLRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777		; Is there an input file?
	POPJ P,			; No, error return
	BIN			; Yes get a byte
	MOVE A,B
	AOS (P)
	POPJ P,

; Assign a jfn
; Call:	PUSHJ P,ASGJFN
; Return
;	+1	; Error none available
;	+2	; Ok, in jfn the jfn
; Clobbers jfn

ASGJFN:	MOVSI JFN,-NJFN
	NOINT
	LOCK JFNLCK
	SKIPE FILSTS(JFN)	; Free jfns have zero filsts words
	AOBJN JFN,.-1
	JUMPGE JFN,ASGJF2	; None available
	AOS (P)
ASGJF1:	HRLI JFN,ASGF
	HLLZM JFN,FILSTS(JFN)	; Mark this jfn as assigned
	HRRZS JFN
	HRRZ A,FORKN		; Get fork number
	HRLZM A,FILVER(JFN)
	SETZM FILTMP(JFN)
	SETZM FILDDN(JFN)
	SETZM FILNEN(JFN)
	SETOM FILLCK(JFN)
ASGJF2:	UNLOCK JFNLCK
	OKINT
	POPJ P,

; Release jfn
; Call:	IN JFN, JFN
;	PUSHJ P,RELJFN
; Clobbers a,b,c,d

^RELJFN:NOINT
	LOCK JFNLCK
	SKIPN FILSTS(JFN)
	JRST RELJF2		; Already released
	MOVEI A,JSBFRE
	HLRZ B,FILDDN(JFN)
	SKIPE B
	PUSHJ P,RELFRE		; Release device string block
	HLRZ B,FILNEN(JFN)
	SKIPE B
	PUSHJ P,RELFRE		; Release name string block
	HRRZ B,FILNEN(JFN)
	SKIPE B
	PUSHJ P,RELFRE		; Release extension string block
	MOVE B,FILSTS(JFN)
	TLNN B,ASGF		; Was this jfn being assigned?
	JRST RELJF2		; No, skip the following
	HRRZ B,FILTMP(JFN)
	SKIPE B
	PUSHJ P,RELFRE		; Release temp block
	HLRZ B,FILTMP(JFN)
	SKIPE B
	PUSHJ P,RELFRE
	MOVE B,FILPRT(JFN)
	JUMPE B,RELJF1
	TLNN B,777777
	PUSHJ P,RELFRE		; Release space for protection block
RELJF1:	MOVE B,FILACT(JFN)
	JUMPE B,RELJF2
	TLNN B,777777
	PUSHJ P,RELFRE		; Release storage for account string
RELJF2:	SETZM FILDDN(JFN)
	SETZM FILNEN(JFN)
	SETZM FILPRT(JFN)
	SETZM FILACT(JFN)
	SETZB STS,FILSTS(JFN)
	SETOM FILLCK(JFN)
	UNLOCK JFNLCK
	OKINT
	POPJ P,

; Terminate string
; Call:	FILOPT(JFN)	; Addresses last byte of string
;	RH(FILTMP(JFN))	; Addresses beginning of string block
;	PUSHJ P,ENDSTR
; Returns with a null deposited on the end of the string and
; In a, a pointer to the string as required by the recognition routines
; Does not modify filopt(jfn), clobbers a,b

^ENDSTR:MOVE A,FILOPT(JFN)
	MOVEI B,0
	IDPB B,A		; Append null to string
	SUB A,FILTMP(JFN)
	MOVNI A,-1(A)		; Number of full words instring
	HRL A,FILTMP(JFN)
	MOVSS A			; Yields iowd # fuul words, first word
	POPJ P,

; Trim temp storage block and return excess to free store pool
; Call:	FILOPT(JFN)	; Addresses the last byte of the string
;	RH(FILTMP(JFN))	; Addresses the beginning of the string block
;	PUSHJ P,ENDTMP
; Returns in a, origin of the string block
; Deposits a null byte on the end of the string
; Returns excess storage in the block to free storage pool
; Clears rh(filtmp(jfn))
; Clobbers a,b,c,d
; Leaves psi off

ENDTMP:	MOVEI B,0
	IDPB B,FILOPT(JFN)	; Deposit a null on the end
	HRRZ A,FILTMP(JFN)	; Origin of block
	MOVE B,FILOPT(JFN)
	PUSHJ P,TRMBLK		; Trim excess from the block
	NOINT
	HRRZ A,FILTMP(JFN)
	HLLZS FILTMP(JFN)
	POPJ P,

; Trim excess from a block and return it to free storage
; Call:	A		; Origin of the block
;	RH(B)		; Last location in block used
;	PUSHJ P,TRMBLK
; Clobbers a,b,c,d

^TRMBLK:MOVEI B,1(B)		; Loc of first unused word
	HRRE C,(A)		; Original length of block
	SUBI C,(B)
	ADDI C,(A)		; Length of excess
	JUMPLE C,CPOPJ		; No excess
	NOINT
	HRROM C,(B)		; Make residue into legit block
	MOVNS C
	ADDM C,(A)		; Shorten original block
	MOVEI B,(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release the residue
	OKINT
	POPJ P,

; I-o routines for local use
; Call:	B		; Pointer to string to be typed
;	PUSHJ P,TSTRB	; If b addresses a string block
; Or
;	PUSHJ P,TSTR	; If b address the first byte
; Outputs the string to the file specified in the call to gtjfn
; Clobbers a,b

TSTRB:	ADD B,[XWD 777777,1]
TSTR:	XCTUU [HRRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	POPJ P,
	MOVEI C,0
	SOUT
	POPJ P,

; Ding the bell
; Call:	PUSHJ P,DING

DING:	XCTUU [HLRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	POPJ P,
	MOVEI B,7		; Fall into outch to type a bell

; Output character
; Call:	B		; The character right justified
;	PUSHJ P,OUTCH
; Outputs the character on the file specified in the call to gtjfn
; Clobbers a

OUTCH:	XCTUU [HRRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	POPJ P,
	BOUT
	POPJ P,

INFTST:	XCTUU [HLRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	POPJ P,
	JRST SKPRET

SFCC0:	MOVE B,[BYTE (2)1,0,1,1,1,1,0,2,1,0,0,1,0,0,1,1,1,1]
	MOVE C,[BYTE (2)0,1,1,1,0,0,0,1,1,0,1,1,1,0]
SFCC:	PUSHJ P,INFTST
	POPJ P,
	SFCOC
	POPJ P,

; Output number
; Call:	B		; The number
;	PUSHJ P,DNOUT	; For decimal output
; Or
;	PUSHJ P,ONOUT	; For octal output
; Clobbers a,c

DNOUT:	SKIPA C,[12]
ONOUT:	MOVEI C,10
	XCTUU [HRRZ A,1(E)]
	TLNE E,777777
	TLNE E,2
	CAIN A,377777
	POPJ P,
	NOUT
	POPJ P,
	POPJ P,

; Process errors during gtjfn
; Call:	A	; Error number
;	JRST ERRDO

ERRDO:	MOVEM A,LSTERR
	PUSHJ P,RELJFN
	MOVE A,LSTERR
	UMOVEM A,1
	PUSHJ P,INFTST
	JRST MRETN
	MOVE A,MPP
	ADD A,[XWD 4,4]
	MOVE P,A
	POP P,A
	POP P,B
	SFMOD
	POP P,C
	POP P,B
	SFCOC
	JRST MRETN

; Get next jfn
; Call:	LH(1)	; Flags dirsf...hverf
;	RH(1)	; Jfn
;	GNJFN
; Returns
;	+1	; Error, jfn not attached to name, no more names
;	+2	; Ok, the jfn refers to the next file in the directory

^.GNJFN:JSYS MENTR
	HRRZ JFN,1
	PUSHJ P,CHKJFN
	ERR()
	JFCL
	ERR(DESX4)
	TEST(NN,OPENF)
	JRST GNJFN1
	ERUNLK(OPNX1)

GNJFN1:	SETZM FILTMP(JFN)
	SETZM FILPRT(JFN)
	SETZM FILACT(JFN)
	SETZM FILOPT(JFN)
	XCTUU [HLLZ F1,1]
	UMOVE A,1
	TLZ A,(37B16)
	HRRZ A,FILVER(JFN)
	TEST(O,STEPF)
	MOVSI F,IGDLF
	TEST(O,OLDNF)
	TEST(NE,HVERF)
	MOVNI A,1
	TEST(NE,RVERF)
	MOVNI A,0
	TEST(NE,LVERF)
	MOVNI A,2
	TLNE F1,DIRSF!NAMSF!EXTSF!VERSF
	PUSHJ P,VERLUK
	ERR(,<PUSHJ P,RELJFN>)
	HRRM A,FILVER(JFN)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	 JRST [	SETZ A,
		JRST GNJFN2]	; NOT FDB FOR NON-MDD DEVICES
	PUSHJ P,GETFDB
	 JRST GNJFN1
	PUSH P,A
	HRLI A,10000
	PUSHJ P,ACCCHK
	 JRST [	UNLOCK DIRLCK
		OKINT
		POP P,A
		JRST GNJFN1]
	MOVSI A,READF
	PUSHJ P,DIRCHK
	 JRST [	UNLOCK DIRLCK
		OKINT
		POP P,A
		JRST GNJFN1]
	POP P,A
	MOVE A,FDBCTL(A)
	UNLOCK DIRLCK
	OKINT
GNJFN2:	UMOVE B,1
	TLNN B,(1B12)
	TLNN A,FDBDEL
	 JRST [	TLNN B,(1B13)
		TLNE A,FDBDEL
		 JRST GNJFN1
		JRST .+1]
	PUSHJ P,UNLCKF
	SETZ A,
	TEST(NE,DIRXF)
	TLO A,(1B14)
	TEST(NE,NAMXF)
	TLO A,(1B15)
	TEST(NE,EXTXF)
	TLO A,(1B16)
	XCTUU [HLLM A,1]
	JRST SKMRTN

	BENDP	GTJFN

;13 OCT 71, 2330:

	TITLE POSTLD
	MLON
	BLOCK 40		;LEAVE SOME SPACE AFTER LAST PROG
RESEND:			;DEFINES END OF CODE, SYMTAB MOVED TO HERE

	LOC 4000		;GET THIS CODE OUT OF THE WAY

;POST-LOADING ONE-SHOT INIT

JOBSYM==116
JOBFF==121
JOBSA==120
P=17

	EXTERN MONCOR,SYSGO1,WMST,SWPSTP,SWPCOR,DDTX,SWCEND,SVN
	EXTERN SMDSKA,P2

SYSG0:	MOVE P,[IOWD 40,PDL]
	PUSHJ P,SMDSKA		;SETUP DSK RELOAD ADDRESSES
	HRRZ 2,JOBFF
	SUBI 2,1
	LSH 2,-^D9
	MOVEM 2,SWCEND
	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	HRROI 1,[ASCIZ / IS LAST PAGE OF SWAPPABLE CODE.
/]
	PSOUT
	HLRE 1,JOBSYM		;GET LENGTH OF SYMTAB
	MOVM 1,1		;GET POSITIVE OF IT
	ADDI 1,RESEND		;NEW END
	HRLZ 2,JOBSYM		;MOVE SYMTAB FROM OLD LOCATION
	HRRI 2,RESEND		;TO END OF RESIDENT MON
	HRRM 2,JOBSYM		;AND RECORD NEW LOCATION
	BLT 2,-1(1)
	HRRZM 1,JOBFF		;SET END OF LOW CODE
	HRLM 1,JOBSA
	MOVEI 2,DDTX		;START OF EDDT
	ADDI 2,777
	LSH 2,-^D9
	MOVEM 2,MONCOR		;END OF MONITOR CORE
	MOVE 2,[JRST DDTX]	;SETUP EDDT DISPATCH
	MOVEM 2,100
	HRRM 2,JOBSA
	MOVEI 1,400000
	SEVEC

;SORT THE BUG TABLE BY BUG ADDRESS

	MOVSI 7,-1000
BUGSR4:	MOVSI 5,-1000(7)	;SCAN FROM HERE TO END
	HRRI 5,0(7)
	MOVSI 3,1		;INITIAL MIN
BUGSR1:	HLRZ 1,MONBGP(5)	;BUG ADDRESS
	JUMPE 1,BUGSR2		;IGNORE ZEROS
	CAML 1,3		;MIN SO FAR?
	JRST BUGSR2		;NO
	MOVEI 3,0(1)		;YES, REMEMBER VALUE
	MOVEI 4,0(5)		;AND LOCATION
BUGSR2:	AOBJN 5,BUGSR1
	TLNE 3,-1		;FOUND A MIN?
	JRST BUGSR3		;NO, NOTHING BUT ZEROS LEFT
	MOVE 1,MONBGP(4)	;INTERCHANGE MIN WITH TOP OF TABLE
	EXCH 1,MONBGP(7)
	MOVEM 1,MONBGP(4)
	AOBJN 7,BUGSR4
BUGSR3:

;DUMP BUG TABLE AND STRINGS TO FILES

	MOVE 1,[1B0+1B17+SVNM]	;USE SYSTEM VERSION NUMBER
	HRROI 2,[ASCIZ /BUGSTRINGS.TXT/]
	GTJFN
	0
	MOVE 2,[7B5+1B20]
	OPENF
	0
	SETZ 3,
	HRROI 2,SVN		;SYSTEM VERSION TEXT
	SOUT
	HRROI 2,[ASCIZ /
BUGHLT AND BUGCHK LOCATIONS AND DESCRIPTIONS

/]
	SOUT
	MOVSI 7,-1000
BUGD1:	SKIPN 6,MONBGP(7)	;TABLE ENTRY?
	JRST BUGD2		;NO, SKIP OVER SPACE
	HLRZ 2,6		;ADDRESS
	MOVE 3,[1B2+6B17+10B35]	;OCTAL PRINT, USE EXACTLY 6 COLUMNS
	NOUT
	0
	MOVEI 2," "
	BOUT
	HRROI 2,0(6)
	SETZ 3,
	SOUT			;PRINT THE STRING
	HRROI 2,[ASCIZ /
/]
	SOUT
BUGD2:	AOBJN 7,BUGD1
	CLOSF
	0
	MOVE 1,[1B0+1B17+SVNM]
	HRROI 2,[ASCIZ /BUGTABLE.IMG/]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVSI 7,-1000
	SKIPE 2,MONBGP(7)
	SUBI 2,MONBGS		;MAKE STRING POINTERS RELATIVE
	BOUT
	AOBJN 7,.-3
	MOVSI 7,-5000
	MOVE 2,MONBGS(7)
	BOUT			;OUTPUT STRINGS
	AOBJN 7,.-2
	CLOSF
	0

;REMOVE REDUNDANT SYMBOLS FROM TABLE

	HRRZ 10,JOBSYM
	HLRE 11,JOBSYM
	MOVEI 7,0(10)
	SUB 7,11
SS2:	SUBI 7,2
	CAMGE 7,10
	JRST SS8
	MOVE 1,0(7)		;GET SYMBOL
	TLCE 1,14B23		;PROGRAM NAME, OR
	TLCN 1,14B23		;BLOCK NAME?
	JRST SS2		;YES
	TLNE 1,20B23		;DELETE NO-INPUT SYMBOLS
	JRST SS6
	MOVE 2,1(7)		;GET VALUE
	CAIGE 2,20		;VALUE 0-17?
	JUMPGE 2,SS22
	MOVE 3,1
	TLZ 1,14B23		;FLUSH LOCAL-GLOBAL BITS
	MOVEI 6,0(7)
SS1:	SUBI 6,2
	CAMGE 6,10
	JRST SS2
	MOVE 4,0(6)		;GET SYMBOL
	TLCE 4,14B23		;PROGRAM NAME, OR
	TLCN 4,14B23		;BLOCK NAME?
	JRST SS1		;YES
	XOR 4,3
	TDNN 4,[XWD 037777,-1]	;SYMBOL EQUAL (EXCLUDING BITS)?
	CAME 2,1(6)		;AND VALUE SAME?
	JRST SS1		;NO
	SETZM 0(6)		;YES, DELETE SYMBOL
	TLON 1,04B23		;AND MAKE ORIGINAL GLOBAL
	MOVEM 1,0(7)
	JRST SS1

SS22:	TLNE 1,04B23		;NOT GLOBAL, OR
	TLNE 1,10B23		;LOCAL+GLOBAL (BLOCK SYMBOL)
	JRST SS2		;YES, DONT CHANGE
	TLO 1,40B23		;GLOBAL AND 0-17, MAKE NO OUTPUT
	MOVEM 1,0(7)
	JRST SS2

SS6:	SETZM 0(7)		;DELETE NO-INPUT SYMBOL
	JRST SS2

SS8:	MOVE 7,JOBSYM		;SCAN TABLE AND COMPACT
	MOVEI 6,0(7)		;WILL BE NEW TABLE POINTER
SS5:	SKIPN 1,0(7)		;DELETED?
	JRST SS4		;YES
	MOVEM 1,0(6)
	MOVE 1,1(7)
	MOVEM 1,1(6)
	ADD 6,[XWD -2,2]	;MOVE TO NEW POSITION
SS4:	AOBJN 7,.+1
	AOBJN 7,SS5
	HLLM 6,JOBSYM		;STORE NEW COUNT
	HRLM 6,JOBSA		;STORE NEW END
	HRRM 6,JOBFF
	MOVEI 2,0(6)		;PRINT NEW END
	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVE 1,JOBSYM
	MOVEM 1,SWPSTP		;PUT POINTER WHERE WMST WILL SEE IT
	JSP 4,WMST		;WRITE SYMBOL TABLE ONTO FILE
	SETZM SWPSTP
	MOVEI 1,37
	PBOUT

	MOVSI 16,-NPNMS		;NUMBER OF PRG NAMES TO SCAN
CKS1:	HRRZ 10,JOBSYM
	HLRE 11,JOBSYM
	SUB 10,11		;CURRENT END OF TABLE
	SUBI 10,MAXSYM		;EXCESS WORDS OF TABLE
	MOVEI 1,0(16)		;TABLE INDEX
	CAIG 10,0		;CRUNCH IF OVERLAP EXISTS, OR
	SKIPL PNAMES+1(16)	;IF ALL SYMBOLS BEING REMOVED
	JSP 17,CSS		;REMOVE LOCAL SYMBOLS IN THIS PRG
	AOBJN 16,.+1		;2 WORDS PER ENTRY
	AOBJN 16,CKS1		;CHECK NEXT PROGRAM
	JUMPLE 10,CSS7		;QUIT IF NOW NO EXCESS
	HRROI 1,[ASCIZ /
SYMBOL TABLE STILL OVERFLOWS.
/]
	PSOUT
CSS7:	MOVE 3,JOBSYM		;MOVE POINTER TO EXEC DDT LOCATION
	MOVEM 3,36
	HRRZ 3,JOBFF		;END OF SYMTAB
	ADDI 3,777		;ADJUST TO NEXT PAGE BOUNDARY
	LSH 3,-^D9		;NUMBER OF FIRST PAGE AFTER SYMTAB
	MOVEM 3,SWPCOR
	HRROI 1,[ASCIZ /
SWPCOR= /]
	PSOUT
	MOVEI 1,101
	MOVE 2,3
	MOVEI 3,^D8
	NOUT
	0
	MOVEI 1,37
	PBOUT
	SETO 1,
	MOVE 2,[XWD 400000,5]	;SETUP TO FLUSH UNUSED PAGES
	MOVEI 4,P2
	LSH 4,-^D9		;FIRST PAGE OF RES MON
	SUBI 4,5
	PMAP
	ADDI 2,1
	SOJG 4,.-2
	MOVE 1,[XWD 2000,2001]
	SETZM -1(1)		;SETUP TO CLEAR CORE
	MOVE 10,[BLT 1,4777]
	MOVE 11,[HALTF]
	JRST 10			;FLUSH ALL GARBAGE THEN HALT

;PROGRAM AND BLOCK NAMES TO FLUSH LOCAL SYMS

	DEFINE PN (A)
<	RADIX50 0,A
	XWD -1,[ASCIZ /A/]
>

	DEFINE PNX (A)
<	RADIX50 0,A
	XWD 0,[ASCIZ /A/]
>

PNAMES:	PNX <EDDT>		;FLUSH ALL SYMS OF EDDT
	PNX <TENDMP>
	PNX <POSTLD>
	PN <NIL>
	PN <CONVER>
	PN <IO>
	PN <DEVICE>
	PN <STRING>
	PN <TTY>
	PN <PTR>
	PN <PTP>
	PN <DECTAP>
	PN <LINEPR>
	PN <DISC>
	PN <FREE>
	PN <INIT>
	PN <MAGTAP>
	PN <PLOTTE>
	PN <LOOKUP>
	PN <DIRECT>
	PN <GTJFN>
	PN <JSYS>
	PN <SWPMON>

NPNMS==.-PNAMES

;REMOVE LOCAL SYMBOLS FROM BLOCK OR PROGRAM
;INDEX TO PNAMES TABLE GIVEN IN 1
;CALLED WITH JSP 17,CSS

CSS:	MOVE 5,PNAMES(1)	;GET RADIX50 OF NAME
	HRRO 1,PNAMES+1(1)	;GET ASCIZ OF NAME
	PSOUT			;SO WE KNOW WHAT WAS CRUNCHED
	MOVE 7,JOBSYM		;SCAN WHOLE TABLE
	MOVE 6,7		;REMEMBER START OF CURRENT PRG
CSS1:	MOVE 1,0(7)
	TLCE 1,(14B5)		;PRG OR
	TLCN 1,(14B5)		;BLOCK NAME?
	JRST CSS2		;YES
CSS3:	AOBJN 7,.+1
	AOBJN 7,CSS1		;KEEP SCANNING TABLE
	HRROI 1,[ASCIZ / - NOT FOUND
/]
	PSOUT
	JRST 0(17)

CSS2:	TLZ 1,(74B5)		;CLEAR TYPE BITS
	CAMN 1,5		;DESIRED NAME?
	JRST CSS4		;YES
	MOVE 6,7		;NO, REMEMBER LOC OF END OF BLOCK
	ADD 6,[XWD 2,2]
	JRST CSS3

;FOUND DESIRED BLOCK, NOW REMOVE LOCAL SYMBOLS

CSS4:	MOVE 5,6
CSS6:	CAMN 5,7		;SCANNED WHOLE BLOCK?
	JRST CSS8		;YES
	MOVE 1,0(5)		;GET NEXT SYMBOL
	SKIPGE PNAMES+1(16)	;FLUSHING ALL SYMS THIS PGM, OR
	TLNE 1,(10B5)		;LOCAL?
	SOJA 10,[SOJG 10,CSS5	;ELIMINATED EXCESS SYMBOLS YET?
		SKIPL PNAMES+1(16) ;YES, REMOVING ALL OF PGR BLOCK?
		JRST CSS5	;YES, KEEP REMOVING
		ADD 5,[XWD 2,2]	;YES
		JRST CSS8]	;FINISH UP
	MOVEM 1,0(6)		;NOT LOCAL, MOVE IT
	MOVE 1,1(5)
	MOVEM 1,1(6)		;MOVE VALUE
	ADD 6,[XWD 2,2]		;UPDATE 'TO' POINTER
CSS5:	ADD 5,[XWD 2,2]		;UPDATE 'FROM' POINTER
	JRST CSS6

CSS8:	MOVSI 1,0(5)		;MOVE REST OF TABLE WITH BLT
	HRRI 1,0(6)
	HLRE 2,5		;COMPUTE NEW END OF TABLE
	MOVEI 3,0(6)		;AS AMOUNT LEFT TO MOVE PLUS
	SUB 3,2			;CURRENT 'TO' LOCATION
	BLT 1,-1(3)		;MOVE REST OF TABLE
	MOVEM 3,JOBFF		;UPDATE LOWER CORE
	HRLM 3,JOBSA
	HRRZ 2,JOBSYM		;CALC NEW LENGTH AS
	SUB 2,3			;BEG-END
	HRLM 2,JOBSYM
	MOVEI 1,37
	PBOUT
	JRST 0(17)

	LIT

PDL:	BLOCK 40

	END SYSG0
