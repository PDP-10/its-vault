	IFNDEF EDDT,<
;3 DEC 71, 1700: - DLM
	EDDT=1			;MAKE EXEC DDT
>
;ALL OTHER REFERENCES TO VERSION # ARE TAKEN CARE OF BY THIS DEFINITION

DDTVER==22

SUBTTL	2 JUN 69
REPEAT 0,<


DDT ASSEMBLY INSTRUCTIONS

THE SOURCE FILE OF DDT.13 WILL ASSEMBLE INTO SEVERAL DIFFERENT
VERSIONS; THE ASSEMBLY IS CONTROLLED BY THE VALUE ASSIGNED
TO THE SYMBOL "EDDT". THE SYMBOL "EDDT" IS DECODED AS FOLLOWS:

BIT 35	=0;	ASSEMBLE A USER MODE DDT
	=1;	ASSEMBLE AN EXECUTIVE MODE DDT

BIT 34	=0;	DO NOT ASSEMBLE THE PAPER TAPE FEATURES INTO DDT
	=1;	ASSEMBLE THE PAPER TAPE FEATURES BUT ONLY IF
			ASSEMBLING AN EXECUTIVE MODE DDT

BIT 33	=0;	FOR USER MODE DDT ONLY- ASSEMBLE USING THE
			"TTCALL" UUO FOR TELETYPE IO
	=1;	FOR USER MODE DDT ONLY- ASSEMBLE USING THE
			"DDTIN" AND "DDTOUT" UUO'S FOR TELETYPE IO

BIT 32  =1;	ASSEMBLE A FILE DDT

BITS (0-17)
	=0;	ASSEMBLE A RELOCATABLE VERSION OF DDT (RELOC 0)
     NOT=0;	ASSEMBLE AN ABSOLUTE (NON-RELOCATABLE) VERSION
			OF DDT WITH A STARTING ADDRESS BEING THE
			NUMBER IN BITS 0-17

(IF THE SYMBOL "EDDT" IS NOT DEFINED AT ALL, DDT WILL BE ASSEMBLED
	WITH EDDT=0.)

EXAMPLES OF "EDDT" DEFINITIONS:
	EDDT=0	ASSEMBLE A RELOCATABLE USER MODE DDT WITH TELETYPE
		I/O DONE BY THE "TTCALL" UUO

	EDDT=1	ASSEMBLE A RELOCATABLE EXECUTIVE MODE DDT

	EDDT=<XWD 4000,3>
		ASSEMBLE AN ABSOLUTE EXECUTIVE MODE DDT
		WITH PAPER TAPE FEATURES, AND WHOSE STARTING
		ADDRESS IS LOCATION 4000.











EXAMPLE OF A MACRO ASSEMBLY COMMAND:

.^C

.R MACRO

*DSK:UDDT,/C_TTY:,DTA2:DDT.12
EDDT=0
^Z

END OF PASS 1			;THIS LINE TYPED BY MACRO
^Z

NO ERRORS DETECTED		;TYPED BY MACRO

PROGRAM BREAK IS 003340		;TYPED BY MACRO

*				;TYPED BY MACRO


OTHER VERSIONS OF DDT ARE ASSEMBLED IN A SIMILAR MANNER
BY DEFINING "EDDT" A DIFFERENT WAY WHERE THE EXAMPLE
DEFINED "EDDT=0".

>	;END OF REPEAT 0

IFNDEF EDDT,<EDDT==0>

	MLON

DEFINE XP (X.,Y.),<
	IF2,<X.=Y.
	INTERN X.>>


IFN EDDT&1,<DEFINE HEADER (VERSION),<
	TITLE EDDT	V0'VERSION	-EXEC MODE DDT
	JOBREL==37
	JOBSYM==36
	ZLOW==40
>>

IFE EDDT&1,<DEFINE HEADER (VERSION),<
IFE EDDT&10,<
	TITLE UDDT	V0'VERSION	-USER MODE DDT>
IFN EDDT&10,<
	TITLE FILDDT	V0'VERSION	-FILE DDT>
	EXTERN JOBREL,JOBSYM,JOBSA,JOBHRL
	ZLOW==140>>

;DO NOT SET LOWER CORE IF EXEC DDT(OK USER OR FILDDT)
IFE EDDT&1,<
JOBVER==137
	LOC JOBVER
	DDTVER			;PUT VERSION # IN JOBVER
JOBDDT==74
	LOC JOBDDT
	XWD DDTEND,DDT
RELOC 0
>

IFN EDDT&<XWD -1,0>,<LOC <EDDT>B53>

HEADER \DDTVER
		;THE HEADER MACRO CONSTRUCTS THE TITLE AND VERSION #

IFN EDDT&10,<	CM=2		;DEFINE SOFTWARE CHANS.
		DP=3
>
;DEFINE ACCUMULATORS

F=0		;FLAGS
P=1		;PUSH DOWN
R=<A=2>		;POINTERS TO TABLES, CORE, ETC.
S=<B=3>
W=<C=4>		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T=5		;TRANSFER DATA
W1=6
W2=7
SCH=10		;MODE CONTROL SWITCH FOR OUTPUT
AR=11		;MODE CONTROL SWITCH FOR OUTPUT
ODF=12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=13		;TEMPORARY
TT1=14	;TEMPORARY

;DEFINE I/O DEVICE MNEMONICS FOR DDT USE
PRS==4
TTYY==120
PTRR==104
PTPP==100

;DEFINE PUSH DOWN LENGTH
LPDL=50		;MAX LENGTH PUSH DOWN LIST

;DEFINE BITS FOR USE IN LEFT HALF OF ACCUMULATOR F
COMF==200000		;COMMA TYPED FLAG
TIF==100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF==100		; +, -, OR * HAS BEEN TYPED
CTF==400
SF==4		;SYLLABLE FLAG
QF==1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40		; $  TYPED
CCF==10000	; $$  TYPED
MF==2		;MINUS SIGN TYPED IN
LTF==20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10		;REGISTER OPEN FLAG
STF==4000
FAF==1000		; < TYPED
SAF==2000		; > TYPED

FPF==20000		; . TYPED IN
FEF==400000		; E FLAG

MLF==200		;*FLAG
DVF==40000		;DIVIDE FLAG

;PID IS 20 IF SYM TAB POINTER IS INDIRECT JOBSYM
PID==0		;=0 IF SYMBOL TABLE POINTER IS IN JOBSYM

;DEFINE BITS FOR USE IN RIGHT HALF OF ACCUMULATOR F

ITF==2	;INSTRUCTION TYPED IF ITF=1
OUTF==4	;OUTPUT IF OUTF=1
CF1==400		;OUTPUT 1 REGISTER AS CONSTANT
LF1==2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F==1		;NUMBER TYPED AFTER ALT MODE 
R20F==10	;TEMP FLAG USED IN SETUP
SBF==20
NAF==200		;NEGATIVE ADDRESSES PERMISSABLE
POWF==4000		;ARGUMENT FOR EXPONENT COMING

;DEFINE SYMBOL TABLE SYMBOL TYPES
GLOBAL==040000		;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000		;PROGRAM NAME
DELI==200000		;DELETE INPUT
DELO==400000		;DELETE OUTPUT

DDT:	INTERN DDTEND	;DECLARE END OF DDT AS INTERNAL, FOR
			; USER TO SEE (USER MODE) AND ONCE ONLY CODE
			; (MONITOR)
	IFE EDDT&1,<	ENTRY DDT
		>
	IFN EDDT&1,<	INTERNAL DDT
			DDTX=DDT
			ENTRY DDTX		;NEEDED BY MONITOR>


;DEFINE $ SYMBOLS INTERNAL TO DDT
OPDEF DDTINT [Z 0,]			;ADDRESS FLAG FOR INTERNAL REGISTERS

RADIX 10
NBP==8	;NUMBER OF BREAKPOINTS
DEFINE DBPNT (Z.)<XP $'Z.'B,<DDTINT B1ADR+3*Z.-3>>
ZZ==0
REPEAT NBP,<DBPNT \<ZZ==ZZ+1>>
RADIX 8


XP $M,<DDTINT MSK>
XP $I,<DDTINT SAVPI>

SETUWP=36

;DEFINE I/O DEVICE MNEMONICS

IFN EDDT&1,<

XP PI,4B11
XP PTP,100B11
XP PTR,104B11
XP CDR,114B11
XP TTY,120B11
XP LPT,124B11
XP DC,200B11
XP DIS,130B11
XP PLT,140B11
XP CR,150B11
XP DSK,170B11
XP UTC,210B11
XP UTS,214B11
XP DCSA,300B11
XP DCSB,304B11
XP DF,270B11
XP MTC,220B11
XP MTS,224B11
XP MTM,230B11
XP DLS,240B11
XP MDF,260B11
XP DTC,320B11
XP DTS,324B11
XP TMC,340B11
XP TMS,344B11	>

;DEFINE EXTENDED OPERATIONS

XP JOV,2554B11
XP JEN,2545B11
XP HALT,2542B11



IFE EDDT&10,<
DDT:	JSR SAVE
	PUSHJ P,REMOVB
	HLRZ T,ESTU		;THIS SEQUENCE INITS SYM TABLE LOGIC
	SUB T,ESTU
	MOVE W,@SYMP
	ADD T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	TRNE T,-1		; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	HRRZM W,ESTU		; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	MOVE T,PRGM
	SUB T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	TSC T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	MOVE W1,PRGM		; SAME PLACE, OR THEY DO NOT BOTH START ON
	XOR W1,W		; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	TRNE W1,1		; PRGM .GE. 0, THEN RE-INIT PRGM.
	JRST DDT0		;EVEN-ODD PROBLEM
	SKIPN T		;POINTERS DON'T END TOGETHER
	SKIPL PRGM		;IF PRGM .GE. 0, THEN RE-INIT
DDT0:	MOVEM W,PRGM		;PRGM_C(JOBSYM)
>


IFN EDDT&10,<
DDT:	CALLI
	MOVEI T,SYMSET
	MOVEM T,JOBREN		;SET REENTER ADDRESS
	MOVEI P,PS
	INIT 1,17
	SIXBIT .DSK.
	Z
	HALT .-3
	SETZM CRASH+3		;CLEAR PPN
	SETZM COMNDS+3		;CLEARN PPN IN CASE FILDDT SAVED AFTER STARTING
	SETZM SNAP+3		;ALSO GOOD PRACTICE TO BE SELF INITIALIZING
	SETZM CRASHS		;ASSUME NO CRASH.SAV(IE. PEEK AT CURRENT MONITOR)
	LOOKUP 1,CRASH
	JRST NOCSH		;LET USER PASS. HE MAY WANT TO PEEK AT MON.
				; OR JUST WANT TO TYPE OUT VALUE OF SOME SYMBOLS
	SETOM CRASHS		;FLAG CRASH.SAV EXISTS ON DSK
	USETI 1,1
	INPUT 1,RSILST
	STATZ 1,740000
	HALT .-3
	SETOM RSAVE		;FORCE READING OF "CURRENT" BLOCK
				; ON FIRST EXAMINE
NOCSH:	INIT CM,0
	SIXBIT .SYS.
	XWD 0,CBUF
	HALT .-3
	SETOM COMAND		;ASSUME A COMMAND FILE
	LOOKUP CM,COMNDS
NOLPT:	SETZM COMAND		;NO FILE IF NOT FOUND
	SKIPN COMAND
	JRST DD1		;USE TTY I/O
	INIT DP,1
	SIXBIT .LPT.		;PREPARE FOR LPT OUTPUT IN AL MODE
	XWD LBUF,0
	JRST NOLPT		;TREAT AS THO NO FILE
	ENTER DP,SNAP
	JRST NOLPT		;TREAT AS NO FILE IF CAN'T ENTER
	JRST DD1

REPEAT 0,<
HOW TO COPY MONITOR SYMBOL TABLE INTO FILDDT
1) USE FDDD10 TO LOAD AN UNRUN VERSION OF YOUR MONITOR
   AS SAVED AFTER BUILDING OR LOADING.
2) RENAME IT AS CRASH.SAV
3) LOAD A PRISTINE VERSION OF FILDDT AND START IT TO SET
   REENTER ADDRESS.
4) TYPE ^C   REENTER
5) FILDDT WILL EXPAND AS NECESSARY AND COPY THE SYMBOL
   TABLE FROM CRASH.SAV INTO ITSELF
6) AFTER CARRIAGE RETURN IS TYPED FILDDT IS DONE.
7) SAVE FILDDT WITH A NEW NAME SO AS NOT TO CONFUSE IT WITH THE
   ORIGINAL FILDDT.SAV

THE MONITOR CAN BE LOADED IN ANY OF THREE WAYS(IN ORDER OF PREFERENCE):
   1. UNDER TIME SHARING WITH REGULAR LOADER AND COMMON
   2. UNDER REGULAR 10/30 MONITOR WITH REGULAR 10/30 LOADER & COMMON
   3. UNDER SPECIAL 10/30 MONITOR(SPMON) WITH BUILD

THE 3 WAYS LEAVE DDTSYM(36),JOBSYM(116) & T30SYM(131) IN DIFFERENT STATES:

       DDTSYM          JOBSYM          T30SYM

   1.  JUNK            S.T.PTR         JUNK
   2.  JUNK            JUNK(NON-NEG)   S.T.PTR
   3.  S.T.PTR         S.T.PTR         JUNK
>

DDTSYM=36

T30SYM=131

EXTERNAL JOBFF,JOBREN

SYMSET:	MOVEI R,JOBSYM
	PUSHJ P,FETCH
	JRST ERR
	MOVEM T,JOBSYM		;POSSIBLE SYMBOL POINTER
	MOVEI R,DDTSYM
	PUSHJ P,FETCH
	JRST ERR
	MOVEM T,DDTSTP		;YET ANOTHER CANDIDATE
	MOVEI R,T30SYM		;ASSUME LOADED BY 10/30
	PUSHJ P,FETCH
	JRST ERR
	SKIPL JOBSYM		;OR IS JOBSYM A POINTER (-VE)?
	JRST REGT30		;LOADED BY 10/30
	SKIPL DDTSTP		;DDTSYM A VALID POINTER (-VE)?
	MOVE T,JOBSYM		;NO TAKE JOBSYM AS THE POINTER
REGT30:	MOVEM T,JOBSYM		;SAVE IT OVER OLD JOBSYM
	HLRES T,T
	MOVMS T,T		;LENGTH OF SYMBOL TABLE
	MOVE W,JOBFF
	ADDI W,1300		;LEAVE SPACE FOR COMMAND & LPT BUFFERS
				; OR DSK BUFFERS AND EXTRA SYMBOL DEFNS.
	HRRZ W1,W		;SAVE LOC FOR COPY
	ADD W,T			;ADD TABLE LENGTH
	IORI W,1777		;REQUEST INTEGRAL # OF K.
	CALLI W,11		;GET CORE
	HALT			;UGH!
	MOVE R,JOBSYM		;WHEREABOUTS OF MONITOR SYMBOLS
	HRRM W1,JOBSYM		;NOW POINT TO FILDDT SYMBOLS
TCOPY:	PUSHJ P,FETCH		;GET A WORD
	JRST ERR
	MOVEM T,0(W1)		;STASH IT
	AOS W1
	AOBJN R,TCOPY
	JRST NOLPT		;GO TRY IT
DDTSTP:	Z			;SAVE POSSIBLE SYMBOL POINTER
>

DD1:	PUSHJ P,CRF
DD1.5:	TLZ F,ROF		;CLOSE ANY OPEN REGISTER
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD ACS
DD2:	CLEARM PRNC		;PARENTHESES COUNT
	MOVEI P,PS
LIS:	MOVE T,ESTU
	MOVEM T,ESTUT		;INIT UNDEFINED SYM ASSEM
	TDZ F,[XWD 777777-ROF-STF,LF1+CF1+SBF+2+Q2F]
LIS0:	TDZ F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	CLEARM,WRD
LIS1:	CLEARM,FRASE
LIS2:	MOVEI T,1
	MOVEM T,FRASE1
	TLZ F,MLF+DVF
L1:	TLZ F,CF+CCF+SF+FPF		;TURN OFF CONTROL, SYL, PERIOD FLAG
	CLEARM,SYL
L1RPR:	CLEARM,SYM
	MOVEI T,6
	MOVEM T,TEM		;INIT SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]
	MOVEM T,CHP		;SETUP FOR OPEVAL SYMBOL
	CLEARM,DEN
	CLEARM,WRD2

L2:	PUSHJ P,TIN		;PICK UP CHARACTER
	CAIL T,"A"+40		;LOWER CASE A
	CAILE T,"Z"+40		;LOWER CASE Z
	JRST .+2
	TRC T,40		;CHANGE LOWER CASE TO UPPER CASE
	TLNE F,CF		;CONTROL FLAG
	JRST L21
	CAIG T,"Z"		;Z
	CAIGE T,"A"		;A
	JRST .+2
	JRST LET
L21:	MOVE R,T
	CAILE T,137	;DISPATCH TABLE HAS ENTRIES ONLY .LE. 137
	JRST ERR
	IDIVI R,3		;REMAINDER GIVES COLUMN, QUOTIENT GIVES ROW
	LDB W,BDISP(R+1)	;GET 12 BIT ADDRESS FROM DISPATCH TABLE
	CAIGE W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST DDT(W)


	MOVE T,SYL
	TLZN F,LTF
	JRST POWER
	MOVE T,[XWD OPEVAL,EVAL]	;GET ADDRESSES OF LOOKUP ROUTINES
	SKIPN WRD		;IF C(WRD)=0, CALL OPEVAL FIRST, OTHERWISE EVAL FIRST
	MOVSS T
	MOVEM T,SAVE
	JRST L213

L212:	HLRZS T,SAVE		;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	PUSHJ P,(T)	;CALL OPEVAL OR EVAL
	JRST L212		;SYMBOL NOT FOUND
L4:	TLZE F,MF
	MOVN T,T
	TLNN F,SF
	CAIE W,LPRN-DDT
	JRST .+2
	JRST LPRN

	EXCH T,FRASE1
	TLNN F,DVF
	IMULB T,FRASE1
	TLZE F,DVF
	IDIVB T,FRASE1
	CAIGE W,ASSEM-DDT
	JRST DDT(W)		;MULTIPLY OR DIVIDE
	ADDB T,FRASE
	CAIGE W,SPACE-DDT
	JRST DDT(W)		; + - @ ,

	ADD T,WRD
	TLNE F,TIF		;TRUNCATE INDICATOR FLAG
	HLL T,WRD		;TRUNCATE
	MOVEM T,WRD
	TLNN F,QF
	MOVE T,LWT
	CLEARM,R
	MOVE W1,ESTUT
	CAMN W1,ESTU
	JRST L5
	CAILE W,CARR-DDT
	JRST ERR
L5:	CAIG W,RPRN-DDT
	JRST DDT(W)
	PUSH P,KILRET
	SKIPN PRNC
	JRST DDT(W)

ERR:	MOVEI W1,"?"
	JRST WRONG1
UNDEF:	MOVEI W1,"U"
	JRST WRONG1
WRONG:	MOVE W1,[ASCII /XXX/]
WRONG1:	MOVEI P,PS
	PUSHJ P,TEXT
	PUSHJ P,LCT		;TYPE TAB
	PUSHJ P,LISTEN		;GOBBLE ANY INPUT CHARACTER
	JFCL
	JRST DD2
RET:	MOVEI P,PS
	PUSHJ P,LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST DD2

UND1:	MOVE R,ESTUT		;UNDEFINED SYM ASSEMBLER
	HLRE S,ESTUT
	ASH S,-1		;SETUP EVAL END TEST
	PUSHJ P,EVAL2
	CAIN W,ASSEM-DDT
	TLNN F,ROF
	JRST UNDEF
	SKIPE PRNC
	JRST UNDEF
	MOVEI T,"#"
	CAIE W,ASSEM-DDT
	PUSHJ P,TOUT

	MOVN R,[XWD 2,2]
	ADDB R,ESTUT
	MOVE T,SYM
	TLO T,GLOBAL
	MOVEM T,(R)
	HRRZ T,LLOCO
	TLNE F,MF
	TLO T,400000
	MOVEM T,1(R)
	MOVEI T,0
	JRST L4

QUESTN:	PUSHJ P,CRF		;LIST UNDEFINED SYMBOLS
	MOVE R,ESTU
QUEST1:	JUMPGE R,DD1
	MOVE T, (R)
	SKIPA W1,ESTU

QUEST2:	ADD W1,[XWD 2,2]
	CAME T,(W1)
	JRST QUEST2
	CAME R,W1
	JRST QUEST4
	PUSHJ P,SPT
	PUSHJ P,CRF
QUEST4:	ADD R,[XWD 2,2]
	JRST QUEST1

NUM:	ANDI T,17		;T HOLDS CHARACTER
	TLNE F,CF+FPF
	JRST NM1
	MOVE W,SYL
	LSH W,3
	ADD W,T
	MOVEM W,SYL
	MOVE W,DEN
	IMULI W,12		;CONVERT TO DECIMAL
	ADD W,T
	MOVEM W,DEN
	AOJA T,LE1A

DOLLAR:	SKIPA T,[46+101-13]	;RADIX 50 $ TO BE
PERC:	MOVEI T,47+101-13	;PERCENT SIGN
LET:	TLC F,SF+FPF		;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN F,LTF+FEF+SF+FPF
	CAIE T,105		; E
	TLOA F,LTF
	TLOA F,FEF
	JRST LET1
	TLZN F,MF
	SKIPA W1,SYL
	MOVN W1,SYL
	MOVEM W1,FSV
	CLEARM DEN
LET1:	SUBI T,101-13		;FORM RADIX 50 SYMBOL
LE1A:	TLO F,SF+QF
LE2:	MOVE W,SYM
	MOVEI R,101-13(T)
	IMULI W,50		;CONVERT TO RADIX 50
	ADD W,T
	SOSGE TEM		;IGNORE CHARACS AFTER 6
	JRST L2
	MOVEM W,SYM
	IDPB R,CHP
	MOVEM W,SYM
	JRST L2

NUM1:	EXCH T,WRD2		;FORM NUMBER AFTER $
	IMULI T,12
	ADDM T,WRD2
	TRO F,Q2F
	JRST L2

NM1:	TLNE F,CF
	JRST NUM1
	MOVEI W1,6		;FORM FLOATING POINT NUMBER
	AOS NM1A
NM1A:	MOVEI W2,0
	MOVSI R,201400
NM1A1:	TRZE W2,1
	FMPR R,FT(W1)
	JUMPE W2,NM1B
	LSH W2,-1
	SOJG W1,NM1A1
NM1B:	MOVSI W1,211000(T)
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM R,SYL
	AOJA T,LE1A

POWER:	TLNN F,FEF
	JRST L4		;NO EXPONENT
	CAIE W,PLUS
	CAIN W,MINUS
	TROE F,POWF
	TRZA F,POWF
	JRST (W)		; E+-

	MOVE W2,DEN
	CLEARM FRASE
	MOVEI W1,FT-1
	TLZE F,MF
	MOVEI W1,FT01
	SKIPA T,FSV
POW2:	LSH W2,-1
	TRZE W2,1
	FMPR T,(W1)
	JUMPE W2,L4
	SOJA W1,POW2

PERIOD:	MOVE T,LLOC
	TLNE F,SF		;SYLLABLE STARTED
	MOVE T,DEN
	MOVEM T,SYL
	TLNE	F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	TLO	F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON F,FPF+SF+QF
	MOVEI T,0
	IDIVI T,400
	SKIPE T
	TLC T,243000
	TLC W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM T,FH
	HLLZS NM1A
	MOVEI T,45		;RADIX 50 PERIOD
	JRST LE2

PILOC:	MOVEI T,SAVPI		;ADR SETUP FOR $I
QUANIN:	TLOA T,(DDTINT)		;MARK FOR ADR INTERNAL TO DDT
QUAN:	MOVE T,LWT		;PICK UP LAST QUANTITY TYPED
QUAN1:	MOVEM T,SYL
QUAN2:	TLO F,SF+QF		;WRD,SYL STARTED
	TLZ F,CF+CCF
	JRST L2

CONTRO:				;SOME KIND OF ALTMODE
IFN EDDT&1,<	MOVEI T,"$"	;$
	PUSHJ P,TOUT		;TYPE OUT $
>
	TLOE F,CF
	TLO F,CCF
	JRST L2

EVAL:	MOVE R,PRGM		;LOOK UP SYMBOL
EVAL0:	HRLOI W1,37777+DELI
	HLRE S,@SYMP
	ASH S,-1	;SETUP END TEST
	JRST EVAL3

EVAL1:	ADD R,[XWD 2,2]
EVAL2:	SKIPL R
	MOVE R,@SYMP
	AOJG S,CPOPJ		;TRNASFER IF NO SYMBOL FOUND
EVAL3:	MOVE T,(R)
	TLC T,LOCAL+GLOBAL
	TLCN T,LOCAL+GLOBAL	;LOCAL AND GLOBAL BOTH ON?
	JRST EVAL1		;YES, FAIL BLOCK NAME, IGNORE
	XOR T,SYM
	TLNN T,PNAME
	TLOA W1,LOCAL-LOCAL	;REMOVE -LOCAL TO RESTORE LOCAL EFFECT
	TDNE T,W1
	JRST EVAL1
	TLNN T,340000
	JRST EVAL1
	MOVE T,1(R)
CPOPJ1:	AOS (P)		;FOUND SYMBOL, SKIP
CPOPJ:	POPJ P,

;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME

TEXI:	PUSHJ P,TEXIN		;INPUT TEXT
	MOVEM T,SYL
	MOVEI W1,5
	MOVEI T-1,0
	PUSHJ P,TEXIN
	CAIN T,33		;NEW ALT MODE, ESCAPE
	JRST QUAN2
	TLNE F,CF
	JRST SIXBIN
	SKIPA
TEXI2:	PUSHJ P,TEXIN
	CAMN T,SYL
	SOJA W1,TEXI3
	ROT T,-7
	LSHC T-1,7
	SOJA W1,TEXI2

TEXI3:	LSHC T-1,-43
	JUMPL W1,QUAN1
	LSH T,7
	SOJA W1,.-2

SIXBI1:	PUSHJ P,TEXIN    ; INPUT TEXT (SIXBIT)
SIXBIN:	CAMN T,SYL
	JRST SIXBI2
	CAIL T,"A"+40		;IS CHAR BETWEEN LOWER CASE "A" AND
	CAILE T,"Z"+40		; LOWER CASE "Z"?
	SKIPA			;NO
	TRC T,40		;YES, CONVERT TO UPPER CASE
	CAIL T," "		;IS CHAR IN SIXBIT SET?
	CAILE T,"_"
	JRST ERR		;NO
	ANDI T,77		;YES, MASK TO 6 BITS
	TRC T,40		;CONVERT TO SIXBIT FORM
	ROT T,-6
	LSHC T-1,6
	SOJA W1,SIXBI1
SIXBI2:	MOVE T,T-1
	JUMPL W1,QUAN1
	LSH T,6
	SOJA W1,.-2

KILL:	TLNN F,LTF		;DELETE SYMBOLS
	JRST ERR
	PUSHJ P,EVAL
	JRST KILL1
	MOVEI T,DELO/200000		;DELETE OUTPUT
	TLNE F,CCF
	MOVEI T,DELI/200000		;NO INPUT OR OUTPUT
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
KILRET:	JRST RET		;USED AS A CONSTANT


KILL1:	MOVE R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE R,UNDEF
KILL2:	PUSHJ P,EVAL0
	JRST RET
	PUSHJ P,REMUN
	JRST KILL2

REMUN:	MOVE S,[XWD 2,2]	;REMOVE ONE UNDEFINED SYMBOL
	ADDB S,ESTU
	MOVE W,-2(S)
	MOVEM W,(R)
	MOVE W,-1(S)
	MOVEM W,1(R)
	POPJ P,

TAG:	TLNN F,LTF   ; NO LETTERS IS ERROR
	JRST ERR   ; GO SAY ERROR
	TLNE F,FAF   ; DEFINE SYMBOLS
	JRST DEFIN		;A<B:
	TLNE F,CF		;DEFINE SYMBOL AS OPEN REGISTER
	JRST SETNAM
	MOVE W,LLOCO
	HRRZM W,DEFV

DEFIN:	PUSHJ P,EVAL		;DEFINED SYMBOL?
	JRST DEF1		;NO - DEFINE
	JRST DEF2		;YES, REDEFINE
DEF1:	MOVN R,[XWD 2,2]
	ADDB R,@SYMP	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ T,ESTU
	SUBI T,2
	HRL T,ESTU
	HRRM T,ESTU
	SKIPGE ESTU
	BLT T,-1(R)
DEF2:	MOVE T,DEFV
	MOVEM T,1(R)		;PUT IN NEW VALUE
	MOVSI T,GLOBAL
	IORB T,SYM
	MOVEM T,(R)		;PUT IN NEW SYM AS GLOBAL
	MOVE R,ESTU

DEF3:	JUMPGE R,RET		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE T,SYM
	CAME T,(R)
	JRST DEF4
	MOVE S,DEFV
	SKIPGE, 1(R)
	MOVN S,S
	PUSH P,R
	MOVE R,1(R)
	PUSHJ P,FETCH
	JRST ERR
	ADD S,T
	HRRM S,T
	PUSHJ P,DEP
	 JFCL
	POP P,R
	PUSHJ P,REMUN
DEF4:	ADD R,[XWD 2,2]		;REMOVE THE NOW DEFINED SYMBOL
	JRST DEF3

SETNAM:	MOVE R,@SYMP		;SET PROGRAM NAME - DOLLAR COLON
SET1:	MOVE W,R
SET2:	JUMPGE R,UNDEF
	MOVE T,(R)
	ADD R,[XWD 2,2]
	TLNE T,PNAME
	JRST SET2
	CAME T,SYM
	JRST SET1
	MOVEM W,PRGM
	JRST RET

;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***
MULT:	TLOA F,PTF+MLF		;*
DIVD:	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:	JRST PLUS		;#
MINUS:	TLO F,MF
PLUS:	TLO F,PTF
	JRST LIS2

LPRN:	CAML P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST ERR
	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS,PRNC
	JRST LIS

INDIRECT:	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:	MOVE R,T		;COMMA PROCESSOR
ACCCF:	MOVSI T,.-.		;LEFT HALF OF A,,B
	TLOE F,COMF		;COMMA TYPED BEFORE?
	JRST ACCF1		;YES
	HRRM R,ACCCF		;NO, SAVE LEFT HALF OF A,,B
	HLLZ T,R
	LDB W1,[POINT 3,WRD,2]	;CHECK FOR IO INSTRUCTION
	IDIVI W1,7
	LSH R,27(W1)
	ADD T,R
	ADDB T,WRD
	JRST SPACE+1

ACCF1:	MOVEM T,WRD		;SET LEFT HALF OF A,,B
	JRST SPACE+1

SPACE:	TLNE F,QF
	TLO F,TIF
	TLZ F,MF+PTF
	JRST LIS1

RPRN:	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
	SOSGE,PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:	ADDB T,WRD
	TLO F,QF
	JRST L1RPR-1

;REGISTER EXAMINATION LOGIC

LINEF:	PUSHJ P,DEPRA	;NEXT REGISTER
IFE EDDT&1,<PUSHJ P,CRNRB
	JRST .+2>
LI0:	PUSHJ P,CRF
	AOS T,LLOC
LI1:		;PUSHJ P,LINCHK		;TRUNCATE ADRS (UNLESS INSIDE DDT)
	HRRZM T,LLOC
	HRRZM T,LLOCO
	PUSHJ P,PAD
	MOVEI T,"/"
	TLNE F,STF
	MOVEI T,"!"
	PUSHJ P,TOUT
LI2:	TLZ F,ROF
	PUSHJ P,LCT
	MOVE R,LLOCO
	PUSHJ P,FETCH
	JRST ERR
	TLO F,ROF
	TLNE F,STF
	JRST DD2
	JRST CONSYM		;RETURN IS A POPJ

REPEAT 0,<
LINCHK:	CAML T,[DDTINT SAVPI]	;TRUNCATE ADDRESSES
	CAMLE T,[DDTINT BNADR+2]
	HRRZS T
	MOVEM T,LLOC
	MOVEM T,LLOCO
	POPJ P,
>

VARRW:	PUSHJ P,DEPRA		;^
	PUSHJ P,CRF
	SOS T,LLOC
	JRST LI1

CARR:	PUSHJ P,DEPRA		;CLOSE REGISTER
	IFN EDDT&1,<JRST DD1>
	IFE EDDT&1,<	PUSHJ P,TIN
	CAIN T,15
	JRST .-2
	JRST DD1.5>


OCON:	TROA F,LF1+CF1		;OPEN AS CONSTANT
OSYM:	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1
SUPTYO:	TLOA F,STF		;SUPPRESS TYPEOUT
SLASH:	TLZ F,STF		;TYPE OUT REGISTER
	TLNN F,QF		;WAS ANY QUANTITY TYPED?
	JRST SLAS1		;NO. DO NOT CHANGE MAIN SEQUENCE
	MOVE R,LLOC		;YES. SAVE OLD SEQUENCE AND
	MOVEM R,SAVLOC
	HRRZM T,LLOC	;PUSHJ P,LINCHK		;TRUNCATE ADRS- SET UP NEW SEQUENCE
SLAS1:	HRRZM T,LLOCO
	JRST LI2

ICON:	TLNN F,ROF	;REGISTER OPENED OR ERR
	JRST ERR
	PUSHJ P,DEPRS
	JRST SLAS1

TAB:	PUSHJ P,DEPRS	;OPEN REGISTER OF Q
	MOVEI T,-1(T)
	EXCH T,LLOC		;SET UP NEW SEQUENCE AND
	MOVEM T,SAVLOC		;SAVE OLD SEQUENCE
	HRROI T,700000	;3 RUBOUTS
	PUSHJ P,TEXTT
	JRST LI0

DEPRA:	MOVE R,SAVLOC
	TLNE F,CF		;RESTORE OLD SEQUENCE IF $CR,$CF, OR
	EXCH R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM R,SAVLOC		;SETUP "NEW" OLD SEQUENCE
	TLNE F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST DEPRS		;SYMBOL REFERENCES TO IT
	MOVE R,ESTU
	MOVEM W1,ESTU
DEPRA2:	JUMPGE R,DEPRS
	HRRZ W,1(R)
	CAMN W,LLOCO
	PUSHJ P,REMUN
	ADD R,[XWD 2,2]
	JRST DEPRA2

EQUAL:	TROA F,LF1+CF1		;=
PSYM:	TRZ F,CF1		;@
	TRO F,LF1
	PUSHJ P,CONSYM
	JRST RET

R50PNT:	LSH T,-36	;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	PUSHJ P,TOC
	PUSHJ P,TSPC
	MOVEI W1,LWT	;SETUP FOR SPT
	JRST SPT

SIXBP:	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:	MOVEI T,0
	ROTC T,6
	ADDI T,40
	PUSHJ P,TOUT
	AOJL W2,SIXBP1
	POPJ P,

;MODE CONTROL SWITCHES

TEXO:	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
HWRDS:	ADDI R,HLFW-TFLOT		;H
SFLOT:	ADDI R,TFLOT-PIN		;F
SYMBOL:	ADDI R,PIN-FTOC		;S
CON:	ADDI R,FTOC		;C
	HRRZM R,SCH
	JRST BASE1

RELA:	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:	ADDI R,TOC		;A
	HRRZM R,AR
	JRST BASE1

BASECH:	MOVE T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N>1
	CAIGE T,2
	JRST ERR
	HRRZM T,ODF
BASE1:	MOVS S,[XWD SCHM,SCH]
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM	;WITH $$, MAKE MODES PERMANENT
	JRST RET

SEMIC:	MOVEM T,LWT		;SEMICOLON TYPES IN CURRENT MODE
	JRST @SCH

;GO AND EXECUTE LOGIC

GO:	HRLI T,(JRST)             ;G
IFE EDDT&1,<
	TLON F,QF
	HRR T,JOBSA>	;GET STARTING ADDRESS

XEC:	TLNN F,QF		;X
	JRST ,ERR
XEC0:	MOVEM T,TEM
	PUSHJ P,CRF
	PUSHJ P,TTYLEV
	PUSHJ P,INSRTB
	JSP T,RESTORE
	XCT,TEM
XEC1:	JRST DDT		;USED  AT PROC0
	JFCL			;IN CASE DOUBLE SKIP
	JSR,SAVE
	PUSHJ P,REMOVB
	PUSHJ P,CRF
	JRST DD1

;BREAK POINT LOGIC
BP1:	REPEAT NBP,<	0		;JSR TO HERE FOR BREAKPOINT
	JSA T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
>

B1INS=BP1+2
BPN=.-3

BCOM:	0
	POP T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI T,B1SKP-B1INS+1(T)
	HRRM T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI T,B1CNT-B1SKP(T)
	HRRM T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE T,BP1-B1CNT(T)
	HLLM T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH T,BCOM

BCOM3:	SKIPE B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	XCT @.-1
BCOM2:	SOSG B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST BREAK

	MOVEM T,AC0+T
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL T,264	;JSR
	CAILE T,266	;JSA,JSP
	TRNN T,700	;UUO
	JRST PROC1		;MUST BE INTERPRETED
	CAIE T,260	;PUSHJ
	CAIN T,256	;XCT
	JRST PROC1		;MUST BE INTERPRETED
	MOVE T,AC0+T
	JRST 2,@LEAV1
LEAV1:	XWD 0,LEAV

BREAK:	SETZM SARS		;BE SURE TO SAVE ACS ON BREAK
	JSR SAVE		;SAVE THE WORLD
	PUSHJ P,REMOVB		;REMOVE BREAKPOINTS
	SOS T,BCOM3
	HRRZS T			;GET ADR OF CONDITIONAL BREAK INST
	SUBI T,B1ADR-3		;CHANGE TO ADDRESS OF $0B
	IDIVI T,3		;QUOTIENT IS BREAK POINT NUMBER
	HRRM T,BREAK2		;SAVE BREAK POINT #
	MOVE W1,[ASCII /$0B>/]	;PRELIMINARY TYPEOUT MESSAGE
	SKIPG @BCOM2		;TEST PROCEED COUNTER
	TRO W1,">"_1		;CHANGE T TO /$0B>>/
	DPB T,[POINT 4,W1,13]	;INSERT BREAK POINT # IN MESSAGE
	PUSHJ P,TEXT2
	MOVE T,BCOM
	HLLM T, SAVPI		;SAVE PROCESSOR FLAGS
	MOVEI T,-1(T)
	MOVE W1,LLOC
	MOVEM W1,SAVLOC		;SAVE SEQUENCE
	HRRZM T,LLOC		;SET SEQUENCE TO BREAK PC
	PUSHJ P,PAD		;TYPE PC AT BREAK
	HRRZ T,@BCOM3
	HRRM T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ T,@BCOM3
	JUMPE T,BREAK1		;TEST FOR REGISTER TO EXAMINE
	PUSHJ P,LCT		;PRINT TAB
	HLRZ T,@BCOM3
	PUSHJ P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	MOVSI S,400000
BREAK2:	ROT S,.-.		;ROT BY # OF BREAK POINT
	PUSHJ P,LISTEN		;DONT PROCEED IF TTY KEY HIT
	TDNN S,AUTOPI		;DONT PROCEED IF NOT AUTOMATIC
	JRST RET		;DONT PROCEED
	JRST PROCD1

PROCEDE: TLNN F,QF		;N$P	;PROCEED AT A BREAKPOINT
	MOVEI T,1
	MOVEM T,@BCOM2
	HRRZ R,BCOM3
	PUSHJ P,AUTOP
PROCD1:	PUSHJ P,CRF
	PUSHJ P,TTYLEV
PROC0:	HRRZI R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ P,FETCH
	JRST BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM T,LEAV
	PUSHJ P,INSRTB
	JRST PROC2

PROC1:	MOVE T,AC0+T
	JSR SAVE
	JFCL
PROC2:	MOVEI W,100
	MOVEM W,TEM1		;SETUP MAX LOOP COUNT
	JRST IXCT5

IXCT4:	IFE EDDT&1,<	SUBI T,041
	JUMPE T,BPLUP
	AOJGE T,IXCT6>				;DONT PROCEDE FOR INIT
				;DONT INTERPRET FOR SYSTEM UUOS
	MOVEM R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI R,41
IXCT:	SOSL TEM1
	PUSHJ P,FETCH
	JRST BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM T,LEAV
IXCT5:	IFN EDDT&1,<
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN T,254		;DON'T DO ANYTHING TO JRST IN EXEC MODE
	JRST IXCT6>
	HRLZI 17,AC0
	BLT 17,17
	MOVEI T,@LEAV
	DPB T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
	LDB W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB T,[POINT 9,LEAV,8]		;PICK UP INSTRUCTION FIELD
	MOVEI P,PS
	CAIN T,260
	JRST  IPUSHJ		;INTERPRET PUSHJ

	CAIN T,264
	JRST IJSR		;INTERPRET JSR
	CAIN T,265
	JRST IJSP		;INTERPRET JSP
	CAIN T,266
	JRST IJSA		;INTERPRET JSA
	MOVE R,LEAV
	TRNN T,700
	JRST IXCT4		;INTERPRET UUO
	CAIN T,256
	JUMPE W1,IXCT		;INTERP XCT UNLESS AC NOT 0 (UXCT)

IXCT6:	JSP T,RESTORE
LEAV:	0			;INSTRUCTION MODIFIED
	JRST @BCOM
	AOSA BCOM		;SINGLE SKIP
	AOSA BCOM		;DOUBLE SKIP
	JRST @BCOM
	JRST LEAV+2

BPLUP:	PUSHJ P,REMOVB		;BREAKPOINT PROCEED ERROR
BPLUP1:	JSR SAVE
	JFCL
	JRST ERR

IPUSHJ:	DPB W1,[POINT 4,CPUSHP,12]	;STORE AC FIELD INTO A PUSH
	CLEARM,TEM3
	MOVE T,LEAV
	JRST RESTR1

IJSA:	MOVE T,BCOM		;INTERPRET JSA
	HRL T,LEAV
	EXCH T,AC0(W1)
	JRST IJSR2

IJSR:	MOVE T,BCOM		;INTERPRET JSR
	HLL T,SAVPI
IJSR2:	MOVE R,LEAV
	PUSHJ P,DEP
	 JRST BPLUP		;ERROR, CAN'T STORE
	AOSA T,LEAV
IJSR3:	MOVE T,LEAV
	JRST RESTORE

IJSP:	MOVE W,BCOM		;INTERPRET JSP
	HLL T,SAVPI
	MOVEM W,AC0(W1)
	JRST IJSR3

;INSERT BREAKPOINTS

INSRTB:	MOVE S,[JSR BP1]
INSRT1:	SKIPE R,B1ADR-BP1(S)
	PUSHJ P,FETCH
	JRST INSRT3
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEP
	 JFCL			;HERE ONLY IF CAN'T WRITE IN HIGH SEG
INSRT3:	ADDI S,3
	CAMG S,[JSR BPN]
	JRST INSRT1
	POPJ P,

;REMOVE BREAKPOINTS

REMOVB:	MOVEI S,BNADR
REMOV1:	MOVE T,B1INS-B1ADR(S)
	SKIPE R,(S)
	PUSHJ P,DEP
	 JFCL			;HERE ONLY IF NO WRITE IN HIGH SEG
	SUBI S,3
	CAIL S,B1ADR
	JRST REMOV1
	IFN EDDT&1,<JRST TTYRET>
	IFE EDDT&1,<POPJ P,>
;IN EXEC MODE, SAVE UP TTY STATUS	;IN USER MODE, DONE BY SAVE

;ALL $B COMMANDS GET HERE IN FORM: <A>$<N>B


BPS:	TLZE F,QF		;HAS <A> BEEN TYPED?
	JRST BPS1		;YES
	TRZE F,Q2F		;NO, HAS <N> BEEN TYPED?
	JRST BPS2		;YES
	MOVE T,[XWD B1ADR,B1ADR+1]	;NO, COMMAND IS $B - CLEAR ALL BREAKPOINTS
	CLEARM B1ADR
	BLT T,AUTOPI		;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEDE REGESTER
	JRST RET

BPS1:	TRZN F,Q2F		;HAS <N> BEEN TYPED?
	JRST BPS3		;NO
	MOVE R,T		;YES, PROCESS THE COMMAND A$NB
	TRO F,2
BPS2:	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR
	IMULI T,3
	ADDI T,B1ADR-3
	TRZN F,2
	JRST MASK2
	EXCH R,T
	JRST BPS5

BPS3:	MOVEI R,B1ADR		;PROCESS THE COMMAND A$B
BPS4:	HRRZ W,(R)
	CAIE W,(T)
	SKIPN (R)
	JRST BPS5
	ADDI R,3
	CAIG R,BNADR
	JRST BPS4
	JRST ERR
BPS5:	MOVEM T,(R)
	CLEARM,1(R)
	CLEARM,2(R)

AUTOP:	SUBI R,B1ADR		;AUTO PROCEDE SETUP SUBROUTINE
	IDIVI R,3
	MOVEI S,1
	LSH S,(R)
	ANDCAM S,AUTOPI
	TLNE F,CCF
	IORM S,AUTOPI
	POPJ P,

;FETCH AND DEPOSIT INTO MEMORY


DEPRS:	MOVEM T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE F,ROF
	TLNN F,QF
	POPJ P,0
		;CAIL R,DDT
		;CAILE R,DDTEND-1
	PUSHJ P,DEP		;STORE AWAY
	JRST ERR		;CAN'T STORE (IN DDT OR OUT OF BOUNDS)
	POPJ P,			;RETURN

;DEPOSIT INTO MEMORY SUBROUTINE

IFE EDDT&10,<
DEP:	IFE EDDT&1,<
	JSP TT1,CHKADR		;LEGAL ADDRESS?
	JRST DEP4		;YES BUT IN HI SEGMENT>
	TRNN R,777760
	JRST DEPAC		;DEPOSIT IN AC

IFE EDDT&10,<	MOVEM T,(R) >
	JRST CPOPJ1		;SKIP RETURN

DEPAC:	MOVEM T,AC0(R)		;DEPOSIT IN AC
	JRST CPOPJ1		;SKIP RETURN

IFE EDDT&1,<
DEP4:	MOVEI W,0
	CALLI W,SETUWP		;IS HI SEGMENT PROTECTED? TURN OFF
	POPJ P,			;PROTECTED, NO SKIP RETURN
	MOVEM T,(R)		;STORE WORD IN HI SEGMENT
	TRNE W,1		;WAS WRITE PROTECT ON?
	CALLI W,SETUWP		;YES, TURN IT BACK ON
	JFCL
	JRST CPOPJ1		;SKIP RETURN
>
>	;END NOT-FILDDT COND.

IFN EDDT&10,<DEP=CPOPJ1>	;ALWAYS OK NO-OP IF FILE DDT

;FETCH FROM MEMORY SUBROUTINE

FETCH:	IFE EDDT&10,<IFE EDDT&1,
	<JSP TT1,CHKADR		;LEGAL ADDRESS?
	JFCL>			;HIGH OR LOW OK FOR FETCH
	TRNN R,777760		;ACCUMULATOR?
	SKIPA T,AC0(R)		;YES
	MOVE T,(R)		;NO
	JRST CPOPJ1		;SKIP RETURN ONLY FOR LEGAL ADDRESS>

IFN EDDT&10,<	SKIPN CRASHS		;CRASH.SAV EXIST?
	JRST MONPEK		;NO - GO PEEK AT RUNNING MONITOR
	MOVEM R,TEM4		;SAVE THE AOBJN POINTER
	HRRZ R,R		;STRIP OFF POSSIBLE COUNT
	ADD R,OFFSET
	IDIVI R,4000		;R HAD LOCATION
	CAIL R,30		;R=NO. OF INPTS  R+1=LOCATION
	POPJ P,			;LARGER THAN 48K
	TRNN S,777000		;S=R+1
	JUMPE R,RSDNT		;LOC IS IN RESIDENT BLOCK
	CAMN R,RSAVE		;IS LOC INCORE ?
	JRST INCORE		;S=LOC
	MOVEM R,RSAVE		;INPT NO.
	IMULI R,20		;16/INPT
	USETI 1,1(R)		;BLK 0 DOES NOT EXIST
	INPUT 1,CURLST		;GET 16 BLKS
	STATZ 1,740000
	HALT .-2		;YEP
INCORE:	SKIPA T,CURENT(S)
RSDNT:	MOVE T,RSIDNT(S)
	MOVE R,TEM4		;RESTORE AOBJN POINTER
	JRST CPOPJ1
TEM4:	0			;HOLD AOBJN POINTER
MONPEK:	HRRZ T,R		;REMOVE COUNT
	CALLI T,33		;DO PEEK UUO
	JRST CPOPJ1		;RETURN VALUE IN AC T
>

IFE EDDT&1,<	;DO ADDRESS CHECKS ONLY IN USER MODE
CHKADR:	HRRZ TT,JOBREL		;GET HIGHEST ADDRESS IN LOW SEGMENT
	CAIL TT,(R)		;CHECK FOR WITHIN LOW SEGMENT
	JRST 1(TT1)		;ADDRESS IS OK IN LOW SEGMENT, SKIP RETURN
	HRRZ TT,JOBHRL		;GET HIGHEST ADDRESS IN HIGH SEGMENT
	TRNE R,400000		;IS THE ADDRESS IN HIGH SEGMENT?
	CAIGE TT,(R)		;IS THE ADR TOO BIG FOR HIGH SEGMENT?
	POPJ P,			;NO,YES- ILL. ADR.
	JRST 0(TT1)

>	;END OF IFE EDDT&1

IFN EDDT&1,<CHKADR==CPOPJ>	;NO ADDRESS CHECKS IN EXEC MODE

FIRARG:	MOVEM T,DEFV
	TLO F,FAF
	JRST ULIM1
ULIM:	TLO F,SAF
	HRRZM T,ULIMIT
ULIM1:	TLNN F,QF
	JRST ERR
	JRST LIS0


LOOK:	SKIPL R,PRGM	;LOOK UP SYMBOL
	MOVE R,@SYMP
	HLRE S,@SYMP
	ASH S,-1	;SETUP COUNT FOR LENGTH OF SYM TABLE
	TLZ F,400000
	HRLZI W2,DELO+DELI
	MOVEM T,TEM

LOOK1:	TDNE W2,(R)
	JRST LOOK3
	MOVE T,(R)
	TLC T,LOCAL+GLOBAL
	TLCN T,LOCAL+GLOBAL	;LOCAL AND GLOBAL BOTH ON?
	JRST LOOK3		;YES, FAIL BLOCK NAME, IGNORE
	TLNN T,PNAME		;PRG NAME?
	JRST [	MOVE T,TEM	;YES, CONTINUE TO CHECK LOCAL SYMS IF
		TLNN T,-1	;LEFT HALF OF VALUE IS 0, AND
		TRNN T,-100	;VALUE IS .GE. 100 (EXCLUDES AC'S AND
		TLO W2,LOCAL	;BIT 30-35 FLAGS) SET BIT TO SKIP LOCAL
		JRST LOOK3]
	MOVE T,TEM
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPLE W,LOOK3
LOOK2:	HRR W1,R		;POINTER BEST VALUE SO FAR
	TLO F,400000
	JUMPE T,SPT0
LOOK3:	ADD R,[XWD 2,2]
	SKIPL R
	MOVE R, @SYMP
	AOJLE S,LOOK1	;TERMINATING CONDITION
	MOVE T,TEM
	TLNE F,400000
	SUB T,1(W1)
	JRST CPOPJ1

CONSYM:	MOVEM T,LWT
	TRNN F,LF1
	JRST @SCH		;PIN OR FTOC
	TRNE F,CF1
	JRST  FTOC

PIN:				;PRINT INSTRUCTION
	TLC T,700000
	TLCN T,700000
	JRST INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND T,[XWD 777000,0]	;EXTRACT OPCODE BITS
	JUMPE T,HLFW		;TYPE AS HALF WORDS
	PUSHJ P,OPTYPE
PIN1:	TRNE F,ITF		;INSTRUCTION TYPED?
	JRST PFULI1		;YES
	MOVE T,LWT		;NO, GET WORD
	TLNE T,777		;AC, @, OR X NON-0?
	JRST PFULI1		;YES, DON'T LOOK FOR FULL WORD MATCH
	PUSHJ P,LOOK		;TRY FOR FULL WORD MATCH
	JRST PADS1		;FOUND, GO PRINT IT
PFULI1:	MOVSI	T,777000
	AND 	T,LWT
	TRNN F,ITF		;HAS INSTRUCTION BEEN TYPED?
	PUSHJ P,LOOK		;NO, LOOK IN SYMBOL TABLE
	TROA F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	JRST HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	PUSHJ P,TSPC
	LDB T,[XWD 270400,LWT]	;GET AC FIELD
	JUMPE T,PI4
	PUSHJ P,PAD
PI3A:	MOVEI W1,","
	PUSHJ P,TEXT
PI4:	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ P,TOUT
	HRRZ T,LWT
	LDB W,[XWD 331100,LWT]	;INSTRUCTION BITS
	CAIL W,240
	CAILE W,247
	JRST PI8		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMBOLIC ADRS
	TLNN W1,20
	CAIN W,<JFFO>_-33
	JRST PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	PUSHJ P,PADS3A	;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ F,NAF	
	LDB R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE R,PADS1		;EXIT
	MOVEI T,"("
	PUSHJ P,TOUT
	MOVE T,R
	PUSHJ P,PAD
	MOVEI T,")"
	JRST TOUT		;EXIT

PI8:	PUSHJ P,PAD
	JRST PI7

HLFW:	REPEAT 0,<	MOVE T,LWT
	CAML T,[DDTINT SAVPI]
	CAMLE T,[DDTINT BNADR+2]
	SKIPA
	JRST PAD>
	HLRZ T,LWT		;PRINT AS HALF WORDS
	JUMPE T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO F,NAF		;ALLOW NEGATIVE ADDRESSES
	PUSHJ P,PAD
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
HLFW1:	HRRZ T,LWT

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

PAD:	ANDI T,-1
	JRST @AR		;PADSO OR PAD1

PADSO:	JUMPE T,FP7B		;PRINT A ZERO
	PUSHJ P,LOOK
PADS1:	POPJ P,0
	JUMPGE F,PADS3		;NO SYMBOL FOUND, PRINT NUMBER
	MOVE W2,1(W1)
	CAIGE T,100
	CAIGE W2,60
	JRST PADS3
	MOVEM T,TEM
	PUSHJ P,SPT0
	MOVEI T,"+"
PADS1A:	PUSHJ P,TOUT
	HRRZ T,TEM
PAD1:	JRST TOC		;EXIT

PADS3:	MOVE T,TEM
PADS3A:	TRNE F,NAF
	CAIGE T,776000
	JRST TOC
PADS3B:	MOVNM T,TEM
	MOVEI T,"-"
	JRST PADS1A

INOUT:	TDC T,[XWD -1,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN T,[XWD -1,400000]
	JRST PADS3B		;TYPE AS NEG NUM
	LDB R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL R,700_-2		;IF DEVICE .L. 700, THEN TYPE
	JRST HLFW		;TYPE AS HALF WORDS
	LDB R,[POINT 3,T,12]
	DPB R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ P,OPTYPE
	PUSHJ P,TSPC
	MOVSI T,077400
	AND T,LWT
	JUMPE T,PI4
	PUSHJ P,LOOK		;LOOK FOR DEVICE NUMBER
	JRST PI3A
	MOVE T,TEM
	LSH T,-30
	PUSHJ P,TOC
	JRST PI3A
MASK:	TLNE F,QF
	JRST MASK1
	MOVEI T,MSK
MASK2:	MOVEI W,1
	MOVEM W,FRASE1
	JRST QUANIN
MASK1:	MOVEM T,MSK
	JRST RET

EFFEC:	TLO F,LTF
	HRRZ T,T
WORD:	MOVEI R,322000-326000	;JUMPE-JUMPN
NWORD:	ADDI R,326000+40*T	;JUMPN T,
	HRLM R,SEAR2
	TLZN F,QF
	JRST ERR
	SETCAM T,WRD
	MOVSI T,FRASE-DEN-1		;PREVENT TYPE OUT OF DDT PARTS
	SETCMM FRASE(T)
	AOBJN T,.-1
	MOVE T,ULIMIT
	TLNE F,SAF
	TLO F,QF		;SIMULATE A $Q TYPED
	PUSHJ P,SETUP
	PUSHJ P,CRF
SEAR1:	PUSHJ P,FETCH
	JRST SEAR2B
	TLNE F,LTF	;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0
	EQV T,WRD
	AND T,MSK
SEAR2:	JUMPE T,SEAR3		;OR JUMPN T
SEAR2A:	AOS R,DEFV	;GET NEXT LOCATION
	PUSHJ P,LISTEN	;ANYTHING TYPED?
	CAMLE R,ULIMIT	;OR END OF SEARCH?
	JRST SEARFN	;YES
	JRST SEAR1	;NO, LOOK SOME MORE

SEAR2B:	MOVEI R,400000-1	;MOVE UP TO HI SEGMENT
	IORB R,DEFV		;PUT IN MEMORY TOO
	TRNN R,400000		;ALREADY IN HI SEGMENT?
	JRST SEAR2A		;NO
SEARFN:	SETCMM LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	JRST DD1

SEAR3:	MOVE R,DEFV
	PUSHJ P,FETCH
	JRST ERR
	TLZ F,STF	;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE T,DEFV
	PUSHJ P,LI1	;CALL REGISTER EXAMINATION LOGIC TO TYPE OUT
	PUSHJ P,CRF
	SETCMM LWT
	SETCMM TEM
SEAR4:	JRST  SEAR2A

EFFEC0:	MOVEI W,100
	MOVEM W,TEM
EFFEC1:	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE R,EFFEC2
	PUSHJ P,FETCH
	JRST ERR
	ADD T,W
EFFEC2:	HRR R,T
	TLNN W,20		;INDIRECT BIT CHECK
	JRST EFFEC3
	SOSE,TEM
	PUSHJ P,FETCH
	JRST SEAR4
	JRST EFFEC1
EFFEC3:	EQV T,WRD
	ANDI T,777777
	JRST SEAR2

SETUP:	TLNN F,QF		;QUANTITY TYPED?

IFN EDDT&10,<MOVEI T,137777	;DON'T SEARCH BEYOND 48K>
IFE EDDT&10,<
IFE EDDT&1,<MOVEI T,777777	;NO, GET LAST ADR>
IFN EDDT&1,<HRRZ T,@SYMP	;NO, GET 1ST ADR SYM TABLE>
>

	HRRZM T,ULIMIT		;SAVE LAST ADDRESS OF SEARCH
	HRRZS R,DEFV		;GET 1ST ADDRESS
	TLNN F,FAF		;WAS A 1ST ADR SPECIFIED?
	SETZB R,DEFV		;NO, MAKE IT ZERO
	CAMLE R,ULIMIT		;LIMITS IN A REASONABLE ORDER?
	JRST ERR		;NO
	POPJ P,		;YES, RETURN

ZERO:	TLNN F,CCF
	JRST ERR
	PUSHJ P,SETUP
	HRRZ S,@SYMP	;GET 1ST ADR OF SYMBOL TABLE
	HLRE W1,@SYMP	;GET LENGTH OF SYM TABLE
	SUB W1,S	;GET NEG OF LAST ADR
	MOVNS W1	;GET POS LAST ADR
	MOVEI T,0	;0 TO STORE IN MEMORY
ZERO1:	TRNN R,777760
	JRST ZEROR	;OK TO ZERO AC'S
	CAIGE R,ZLOW
	MOVEI R,ZLOW	;DON'T ZERO 20 THRU ZLOW
	CAIL R,DDT
	CAILE R,DDTEND
	JRST .+2
	MOVEI R,DDTEND	;DON'T ZERO DDT
	CAML R,S
	CAMLE R,W1
	JRST .+2
	HRRZ R,W1	;DON'T ZERO SYMBOL TABLE
ZEROR:	CAMLE R,ULIMIT	;ABOVE LIMITS?
	JRST DD1	;YES, STOP
	PUSHJ P,DEP	;DEPOSIT T
	 TROA R,377777	;
	AOJA R,ZERO1
	TRNN R,400000	;HI SEGMENT?
	AOJA R,ZERO1	;NO, KEEP GOING
	JRST DD1	;FINISH

FTOC:		;NUMERIC OUTPUT SUBROUTINE
TOC:	HRRZ W1,ODF
	CAIN W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	TLNN T,-1		;ARE THERE  NO LEFT HALF BITS?
	JRST TOCA		;YES, DO NOTHING SPECIAL
	HRRM T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS T			;GET LEFT HALF
	PUSHJ P,TOC0		;TYPE LEFT HALF
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
TOCS:	MOVEI T,.-.		;GET RIGHT HALF BACK
TOCA:	HRRZ W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN W1,12
	JRST TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC T,-43
	LSH W1,-1		;W1=T+1
	DIVI T,@ODF
	HRLM W1,0(P)
	SKIPE T
	PUSHJ P,TOC0
	HLRZ T,0(P)
	ADDI T,"0"
	JRST TOUT

TOC4:	MOVM A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE T,TOC5
	MOVEI T,"-"
	PUSHJ P,TOUT
TOC5:	PUSHJ P,FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI T,"."
	JRST TOUT

;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM W1,SPSAV		;SAVE POINTER TO TYPED SYM
SPT:		;RADIX 50 SYMBOL PRINT
	LDB T,[POINT 32,0(W1),35]	;GET SYMBOL
SPT1:	IDIVI T,50
	HRLM W1,0(P)
	JUMPE T,SPT2
	PUSHJ P,SPT1
SPT2:	HLRZ T,0(P)
	JUMPE T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI T,260-1
	CAILE T,271
	ADDI T,301-272
	CAILE T,332
	SUBI T,334-244
	CAIN T,243
	MOVEI T,256
	JRST TOUT

SYMD:	MOVEI T,DELO/200000	;$D ;DELETE LAST SYM & PRINT NEW
	HRRZ R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	MOVE T,LWT
	JRST CONSYM		;PRINT OUT NEXT BEST SYMBOL

;FLOATING POINT OUTPUT

TFLOT:	MOVE A,T
	JUMPG A, TFLOT1
	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	PUSHJ P,TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:	TLNN A, 400
	JRST TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:	MOVEI C,0

FP3:	MULI A,400
	ASHC B,-243(A)
	SETZM TEM1	;INIT 8 DIGIT COUNTER
	SKIPE A,B	;DON'T TYPE A LEADING 0
	PUSHJ P,FP7	;PRINT INTEGER PART OF 8 DIGITS
	PUSHJ P,TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE T,W1
	MULI T,12
	PUSHJ P,FP7B
	SKIPE,W1
	AOJL A,FP3A
	POPJ P,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT,FCP(B)
	JRST FP4B
	FMPR A,@FCP+1(B)
	IORI W2,1
FP4B:	AOJN C,FP4A
	PUSH P,W2	;SAVE EXPONENT
	PUSH P,FSGN(B)	;SAVE "E+" OR "E-"
	PUSHJ P,FP3	;PRINT OUT FFF.FFF PART OF NUMBER
	POP P,W1	;GET "E+" OR "E-" BACK
	PUSHJ P,TEXT
	POP P,A		;GET EXPONENT BACK

FP7:	IDIVI A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS,TEM1
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7

FP7A1:	HLRZ T,(P)
FP7B:	ADDI T,260
	JRST TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FCP:	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	Z FT0(C)

FSGN:	ASCII .E-.
	ASCII .E+.

TEXTT:	MOVE W1,T
TEXT:	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35
TEXT2:	MOVEI T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC T,7
	PUSHJ P,TOUT
	JUMPN W1,TEXT2
	POPJ P,

WRD:	0
WRD2:	0
PRNC:	0

FRASE:	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:	0
LWT:	0
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0

PRGM:	0
ESTU:	0
ESTUT:	0
FSV:	0
FH:	0
SYM:	0
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0
ULIMIT:	0
LLOC:	0
LLOCO:	0
SAVLOC:	0		;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
SYMP:	XWD PID,JOBSYM

SAVPI:	0
	1177
SAVTTY:	0
MSK:	XWD -1,-1
B1ADR:	0
B1SKP:	0
B1CNT:	0

REPEAT NBP*3-3, <	0>

BNADR=.-3
AUTOPI:	0

IFE EDDT&10,<
AC0:	BLOCK 17

AC17:	0
>

SCHM:	EXP PIN		;DO NOT CHANGE ORDER
ARM:	EXP PADSO
ODFM:	EXP 10

SARS:	0
TEM:	0
TEM1:	0
IFN EDDT&10,< OFFSET:	0 >

IFN EDDT&1&<EDDT>B36,<


PUNCH:	TLC F,FAF+QF
	TLCE F,FAF+QF
	JRST ERR		;ONE ARGUMENT MISSING
PUN2:	ADDI T,1
	HRRZM T,TEM1
	SUB T,DEFV
	JUMPLE T,ERR

PUN1:	MOVEI T,4		;PUNCH 4 FEED HOLES
	PUSHJ P,FEED
	TLNE F,CF		;PUNCH NON-ZERO BLOCKS?
	JRST PUNZ		;YES
	HRRZ R,DEFV
	IORI R,37
	ADDI R,1
	CAMLE R,TEM1
	MOVE R,TEM1
	EXCH R,DEFV
	MOVE T,R
	SUB T,DEFV
	HRL R,T
	JUMPGE R,RET		;EXIT OR PUNCH

PBLK:	MOVE T,R
	SOS W,T		;INIT CHECKSUM
	PUSHJ P,PWRD
PBLK1:	PUSHJ P,FETCH
	JRST ERR
	ADD W,T
	PUSHJ P,PWRD
	AOBJN R,PBLK1
	MOVE T,W
	PUSHJ P,PWRD
	JRST PUN1

;PUNCH NON-ZERO BLOCKS

PUNZ0:	AOS DEFV		;LOOK AT NEXT WORD
PUNZ:	HRRZ W,DEFV		;ENTER HERE - GET STARTING ADDRESS
	MOVE R,W
	SUB W,TEM1		;CALCULATE NEGATIVE LENGTH
	HRL R,W			;SET UP AOBJN POINTER
	JUMPGE R,RET		;FINISHED?
	CAMG R,[XWD -40,0]	;BLOCK LONGER THAN 40?
	HRLI R,-40		;YES, FIX IT UP
	MOVSI W1,400000		;W1 NEGATIVE MEANS FLUSH 0 WORDS
PUNZ2:	PUSHJ P,FETCH		;GET WORD FROM MEMORY
	JRST ERR
	JUMPE T,[AOJA W1,PUNZ4]	;IF WORD IS 0, INDEX 0 WORD COUNTER
	MOVEI W1,0		;CLEAR 0 WORD COUNTER
PUNZ4:	JUMPL W1,PUNZ0		;FLUSH 0 WORD, GET ANOTHER
	CAIL W1,3		; NOSKIP FOR 3RD 0 WORD AFTER NON 0 WORD
	AOSA R			;ADVANCE R TO LAST ADR+1
	AOBJN R,PUNZ2
	ADD W1,DEFV		;CALCULATE DEFV-R+W1=-WORD COUNT
	SUB W1,R
	HRLM W1,DEFV		;PUT -WC IN LEFT HALF OF FA
	EXCH R,DEFV		;SAVE ADR FOR NEXT BLOCK, GET POINTER
	JRST PBLK


LOADER:	TLNE F,QF
	JRST ERR
	MOVEI T,400
	PUSHJ P,FEED
	MOVE R,LOADE
LOAD1:	MOVE T,0(R)
	PUSHJ P,PWRD
	AOBJN R,LOAD1
	MOVEI T,20
LOAD2:	PUSHJ P,FEED
	JRST RET

BLKEND:	TLNN F,QF		;BLOCK END
	MOVE T,[JRST 4,DDT]
	TLNN T,777000		;INSERT JRST IF NO OPCODE
	TLO T,(JRST)
	PUSH P,T
	MOVEI T,20
	PUSHJ P,FEED
	POP P,T
	PUSHJ P,PWRD
	PUSHJ P,PWRD	;EXTRA WORD FOR READER TO STOP ON
	MOVEI T,400
	JRST LOAD2

PWRD:	MOVEI W1,6
PWRD2:	ROT T,6
	CONSZ PTPP,20
	JRST .-1
	CONO PTPP,50
	DATAO PTPP,T
	SOJG W1,PWRD2
	POPJ P,0

FEED:	CONSZ PTPP,20
	JRST .-1
	CONO PTPP,10
	DATAO PTPP,FEED1
	SOJN T,FEED
FEED1:	POPJ P,0	;ADDRESS USED AS A CONSTANT


LOADB:

PHASE 0			;RIM10B CHECKSUM LOADER
	XWD -16,0
BEG:	CONO PTRR,60
	HRRI AA,RD+1
RD:	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,@TBL1-RD+1(AA)
	XCT	TBL1-RD+1(AA)
	XCT	TBL2-RD+1(AA)
AA:	SOJA AA,

TBL1:	CAME CKSM,ADR
	ADD CKSM,1(ADR)
	SKIPL CKSM,ADR

TBL2:	JRST 4,BEG
	AOBJN ADR,RD
ADR:	JRST BEG+1
CKSM=ADR+1

DEPHASE

LOADE:	XWD LOADB-.,LOADB
>	;END OF IFN EDDT$1&<EDDT>B36
	;FOR PAPER TAPE IO


SAVE:	0		;SAVE THE ACS AND PI SYSTEM
	SKIPN SARS
	JRST SAV1
	AOS SAVE
	JRST SAV5
SAV1:	IFN EDDT&1,<
	CONI PRS,SAVPI
	CONO PRS, @SAVPI+1>
	MOVEM 17,AC17
	HRRZI 17,AC0
	BLT 17,AC0+16
	MOVE T, SAVE
	HLLM T, SAVPI
SAV5:
;IFE EDDT&1,<HRRZS SAVUWP		;ASSUME UWP WILL BE ZEROED
;	 SETZB T,F		;T=F=0
;	 CALLI T,SETUWP			;REQUEST TO CLEAR UWP
;	 HRROS SAVUWP			;FAILED, UWP (BIT 0) STILL 1
;	 SKIPN SARS			;USER'S STATE SAVED ALREADY?
;	 HRRM T,SAVUWP>			;NO, SAVE STATE OF UWP

	SETOM SARS			;FLAG PROTECTING SAVED REGISTERS
	MOVEI P,PS
	IFE EDDT&1,<PUSHJ P,TTYRET>	;IN USER MODE, GET INTO DDT MODE
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD THE ACS WITH MODE SWITCHES
	SETZ F,			;CLEAR FLAGS
	JRST @SAVE

RESTORE: SETOM TEM3	;RESTORE ACS AND PI SYSTEM
RESTR1:	HRRM T,SAVE
	MOVE T,SAVPI
	HLLM T, SAVE
IFN EDDT&1,<
	AND T, SAVPI+1
	IORI T, 2000	;TURN ON CHANNELS
	MOVEM T, SAVPI>
;IFE EDDT&1,<HRRZ T,SAVUWP		;GET OLD UWP
;	CALLI T,SETUWP		;CHANGE IT TO OLD
;	JFCL>			;ES MACHT NICHTS
	HRLZI 17,AC0
	BLT 17,17
	SETZM SARS
	SKIPL,TEM3
CPUSHP:	PUSH BCOM	;PROGRAM MODIFIED AT IPUSHJ
IFN EDDT&1,<	CONO PRS,@SAVPI>
	JRST 2,@SAVE

CRN:	MOVEI T,15		;CARRIAGE RETURN
	JRST TOUT

IFE EDDT&1,<
CRNRB:	PUSHJ P,CRN
	MOVEI T,177
	JRST TOUT>

CRF:	PUSHJ P,CRN
	MOVEI T,12		;LINE FEED
	JRST TOUT

LCT:	IFN EDDT&1,<PUSHJ P,TSPC
	PUSHJ P,TSPC>
	IFE EDDT&1,<MOVEI T,11
	JRST TOUT>		;TYPE A TAB

TSPC:	MOVEI T,40		;SPACE
	JRST TOUT

IFN EDDT&1,<	;EXECUTIVE MODE TELETYPE I/O

TIN:	PUSHJ P,LISTEN		;TELETYPE CHARACTER INPUT
	 JRST .-1
	CAIE T,175
	CAIN T,176
	MOVEI T,33	;CHANGE ALL ALT MODES TO NEW
	CAIN T,177	;RUBOUT?
	JRST WRONG	;YES, TYPE XXX
	TRNE T,140	;DON'T ECHO CR,LF,ALT,TAB,BACK SPACE,ETC
TOUT:	CAIG T,04	;DON'T TYPE EOT OR LOWER CHARS
	POPJ P,
	HRLM T,(P)
	IMULI T,200401		;GENERATE PARITY
	AND T,[11111111]
	IMUL T,[11111111]
	HLR T,(P)
	TLNE T,10
	TRC T,200		;MAKE PARITY EVEN
	CONSZ TTYY,20
	JRST .-1
	DATAO TTYY,T
	ANDI T,177		;FLUSH PARITY
	POPJ P,0

LISTEN:	CONSO TTYY,40	;LISTEN FOR TTY
	POPJ P,
	DATAI TTYY,T
	ANDI T,177
	JRST CPOPJ1

TTYRET:	MOVEI  T,3410
TTY1:	CONI TTYY,SAVTTY	;SAVE PI ASSMT
	CONO TTYY,0		;SET PI ASSMT TO 0
	MOVEI W2,40000
	CONSZ TTYY,120
	SOJG W2,.-1
	CONI TTYY,W2		;GET TTY STATE BITS
	XOR W2,SAVTTY		;USE PI FROM PREVIOUS CONI
	ANDI W2,777770
	XORM W2,SAVTTY
	DATAI TTYY,W2
	HRLM W2,SAVTTY
	CONO TTYY,(T)
	POPJ P,

TTYLEV:	MOVE T,SAVTTY
	TRZ T,160
	TRO T,3600
	TRNE T,10
	TRZ T,200
	JRST TTY1


TEXIN:	PUSHJ P,TIN	;INPUT SUBROUTINE FOR TEXT MODES
	TRNN T,140
	JRST TOUT	;ECHO CHARACTERS (0-37) NOT ECHOED
	POPJ P,
>

IFE EDDT&1,<	;USER MODE TELETYPE I/O
  IFN EDDT&4,<	;ASSEMBLE WITH OLD DDT MODE IO

TIN:	MOVE T,POUTBF		;GET NEXT CHARACTER ROUTINE
	CAME T,[POINT 7,INBFF]
	PUSHJ P,FINOUT

IFE EDDT&10,<	ILDB T,PINBFF >
IFN EDDT&10,<	PUSHJ P,INCHR >

	CAIE T,176
	CAIN T,175
	MOVEI T,33	;CHANGE TO NEW ALT MODE
	CAIN	T,177	;RUBOUT?
	JRST	WRONG	;YES PRINT XXX
	JUMPN T,CPOPJ
	MOVE T,[POINT 7,INBFF]
	MOVEM T,PINBFF
	CALL T,[SIXBIT /DDTIN/]
	JRST TIN

TOUT:	JUMPE	T,CPOPJ	;OUT PUT A CHARACTER FLUSH NULLS

IFN EDDT&10,<	SKIPE COMAND
	JRST PUTCHR >

	IDPB T,POUTBF
	CAIE T,12
	POPJ P,
TTYLEV:
FINOUT:	MOVEI T,0
	IDPB T,POUTBF
	MOVE T,[POINT 7,INBFF]
	MOVEM T,PINBFF
	MOVEM T,POUTBF
	CALL T,[SIXBIT /DDTOUT/]
	CLEARM INBFF
	POPJ P,

PINBFF:	POINT 7,INBFF
POUTBF:	POINT 7,INBFF

LISTEN=CPOPJ
INBFF:	BLOCK 21

TTYRET:	MOVE T,[POINT 7,INBFF]
	MOVEM T,POUTBF
	MOVEM T,PINBFF
	CLEARM INBFF
	POPJ P,

TEXIN=TIN	;USE NORMAL INPUT FOR TEXT WHEN IN USER MODE
>

   IFE EDDT&4,<	;ASSEMBLE WITH TTCALL TELETYPE IO

OPDEF TTCALL [51B8]

TEXIN:
TIN:

IFE EDDT&10,<	TTCALL 0,T		;GET NEXT CHARACTER INTO T >
IFN EDDT&10,<	PUSHJ P,INCHR >

	CAIE T,175
	CAIN T,176
	MOVEI T,33		;CHANGE OLD ALT MODES TO NEW
	CAIN T,177
	JRST WRONG		;TYPE XXX FOR A RUBOUT
	POPJ P,

TOUT:

IFN EDDT&10,<	SKIPE COMAND		;IS THERE A COMMAND FILE?
	JRST PUTCHR			;YES >

	TTCALL 1,T		;OUTPUT A CHARACTER
	POPJ P,

LISTEN:	TTCALL 2,T		;GET NEXT CHAR, NO IO WAIT
	POPJ P,			;NO CHARACTER EXISTED, RETURN
	JRST CPOPJ1		;CHARACTER WAS THERE, SKIP RETURN

TTYRET:	TTCALL 6,		;WHEN RETURNING TO DDT, FLUSH ALL
	POPJ P,			;WAITING INPUT CHARACTERS

TTYLEV==CPOPJ			;NOTHING SPECIAL TO DO WHEN LEAVING DDT

>	;END OF IFN EDDT&4

IFN EDDT&10,<
INCHR:	SKIPE COMAND
	JRST GETCHR

IFN EDDT&4,<	ILDB T,PINBFF		;NO COMMAND FILE >
IFE EDDT&4,<	TTCALL 0,T		;O/P CHAR. >

	POPJ P,

GETCHR:	SOSLE CBUF+2		;ANY REMAINING?
	JRST GETOK		;YES.
	INPUT CM,
	STATZ CM,740000
	HALT .+1
	STATZ CM,20000		;END-OF-FILE?
	JRST GETEND

GETOK:	ILDB T,CBUF+1
	JUMPE T,GETCHR		;BYPASS ZERO CHARACTERS
	PUSHJ P,PUTCHR		;COPY INPUT TO OUTPUT FILE
	POPJ P,

GETEND:	CLOSE DP,		;CLOSE OUTPUT WHEN INPUT EXHAUSTED
	RELEASE DP,
	RELEASE CM,
	JRST NOLPT		;REVERT TO TTY WHEN COMMANDS EXHAUSTED

PUTCHR:	SOSLE LBUF+2		;ANY ROOM?
	JRST PUTOK		;YES
	OUTPUT DP,
	STATZ DP,740000		;ERRORS?
	HALT .+1		;YES

PUTOK:
	IDPB T,LBUF+1	;DEPOSIT CHAR.
	POPJ P,

>	;END OF IFN EDDT&10
>	;END OF IFE EDDT&1

BDISP:	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35
DISP:	
DEFINE D (Z1,Z2,Z3)<		<Z1-DDT>_30+<Z2-DDT>_14+Z3-DDT>
	;THIS MACRO PACKS 3 ADDRESSES INTO ONE WORD; EACH ADR IS 12 BITS

IFE EDDT&1&<EDDT>B36,<	PUNCH==ERR
	BLKEND==ERR
	LOADER==ERR>

D ERR,ERR,ERR
D ERR,ERR,ERR
D ERR,ERR,VARRW
D TAB,LINEF,ERR
D ERR,CARR,ERR
D ERR,ERR,ERR
D PUNCH,ERR,ERR
D ERR,ERR,ERR
D ERR,ERR,ERR
D CONTROL,ERR,ERR
D ERR,ERR,SPACE
D SUPTYO,TEXI,ASSEM
D DOLLAR,PERC,ERR
D DIVD,LPRN,RPRN
D MULT,PLUS,ACCF
D MINUS,PERIOD,SLASH
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,TAG,SEMIC
D FIRARG,EQUAL,ULIM
D QUESTN,INDIRECT,ABSA
D BPS,CON,SYMD
D EFFEC,SFLOT,GO
D HWRDS,PILOC,BLKEND
D KILL,LOADER,MASK
D NWORD,BITO,PROCEDE
D QUAN,RELA,SYMBOL
D TEXO,ERR,ERR
D WORD,XEC,ERR
D ZERO,OCON,ICON
D OSYM,VARRW,PSYM

;THIS TABLE DOES NOT HAVE ENTRIES FOR CHARS .GE. 140; THESE
; ARE DETECTED AS ERRORS NEAR L21:

BITO:	MOVEI	R,BITT	;BYTE OUTPUT SUBROUTINE
	HRRZI	AR,TOC
	TRZN	F,Q2F
	JRST	ERR
	MOVE	T,WRD2
	MOVEM	T,SVBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVE	T+1,LWT
	MOVEM	T+1,SVBT3
	PUSH P,LWT
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T,LWT
	MOVEM	T+1,SVBT3
	CAIE	AR,PADSO
	PUSHJ	P,TOCA
	CAIE	AR,TOC
	PUSHJ	P,PIN
	SOSG	SVBT2
	JRST BITT4
	MOVEI	T,","
	PUSHJ	P,TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

BITT4:	POP P,LWT
	POPJ P,

SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0

;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.

;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE A-73(8)RD
;	        BYTE IN THE TABLE.
;
;MACROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ^ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;      DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;      SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;      ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;      THE MACHINE CODE FOR JRST IS 254
;          INST    0  1  0  1  0  1  1  0  0
;      THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63^).
;      THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;      2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;      HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33^.  APPLYING
;      THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;      OVER:
;          1.  MV/
;               MOV      PRINTING TEXT
;          2.  MO/
;          3.  ML/
;          4.  DV/
;          5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03^ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;              EXC      PRINTING TEXT
;          1.  S3/
;              BL       PRINTING TEXT
;              T        PRINTING TEXT
;          2.  .
;          3.  AO/
;          4.  AOB/
;          THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T; A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;          THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A
;	TREE SEARCH METHOD IS USED.

REPEAT 0,<

DEFINE REDEF (XX)<
DEFINE INFO (AA,BB)<
AA XX'BB>>


DEFINE BYT9 (L)<
XLIST
REDEF %
 ZZ==0
 ZZZ==0
 ZZM==1

 IRPC L,<
	Z=="L"
	IFE Z-":",<INFO <>,<==CLOC>
		IFNDEF FIR.,<FIR.==CLOC>
		IFGE CLOC+73-1000-FIR.,<PRINTX OPTABLE TOO LONG>
		Z==0>
	IFE Z-"/",<IF1 <OUTP 1>
		IF2,<INFO OUTP,+73-FIR.>
		Z==0>
 IFE Z-"^",<OUTP <ZZ&70/2+ZZ&7-1>
	Z==0>
 IFE <Z-",">*<Z-".">*<Z-40>,<IFN ZZZ,<
				REPEAT 5,<ZZ==ZZZ&77
					IFN ZZ,<OUTP ZZ>
					ZZZ==ZZZ/100>>
				IFE Z-".",<OUTP 40>
				Z==0>
 IFN Z,<INFO REDEF,L
	ZZ==ZZ*10+Z&7
	ZZZ==ZZZ+<Z-40>*ZZM
	ZZM==ZZM*100>
 IFE Z,<REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1>>
LIST>

DEFINE OUTP (A)<
	BINRY==BINRY*400+BINRY*400+A
	BINC==BINC-1
	IFE BINC,<EXP BINRY
		BINRY==0
		BINC==4>
	CLOC==CLOC+1>

TBL:		;OPDECODER BYTE TABLE

BINRY==0
CLOC==0		;SET BYTE LOCATION COUNTER TO 0
BINC==4		;INIT BYTES/WORD COUNTER

BYT9 <63^UUO/FLO/HAK/ACCP/BOOLE/H HWT/T ACBM/>

;IO INSTRUCTIONS
BYT9 <21^BD/CON,11^OI/S,01^Z/O/>
BYT9 <BD:01^BLK,IO/DATA,IO:11^I/O/OI:01^O/I/>

;UUOS
BYT9 <UUO:51^.,32^U40/U50/U60/21^U703/11^USET/01^>
BYT9 <LOOKU,P/ENTE,R/USET:USET,01^I/O/>
BYT9 <U40:03^CAL/INI T/.....,CALL I/>
BYT9 <U60:21^U603/01^IN,BPUT/OUT,BPUT:11^BU,F:F.,PU,T/>
BYT9 <U603:01^U6062/STAT,11^O:O.,Z:Z.,U6062:11^S,U62/G,U62:ETST,S/>
;BYTE AND FLOATING INSTRUCTIONS

BYT9 <FLO:51^BYTE/F 32^ AD A/SB A/MP A/DV A:>
BYT9 <21^LMB/R,IMB/LMB:02^.,L:L.,M:M.,B:B.,BYTE:32^...,03^UF,PA/DF,N/>
BYT9 <FS C/IB P:P.,I LD/LD:LD B/I DP/DP:DP B/>

;FWT,FIXED POINT ARITH,MISC.

BYT9 <HAK:33^MV/MV:MOV MO/ML/DV/SH/H1/JP/>
BYT9 <21^ADD IMB/SU BIMB:B IMB:02^.,I:I.,M/B/MO:22^>
BYT9 <EIMS:E IMS/S IMS/N IMS/M IMS:02^.,I/M/S:S.,>
BYT9 <ML:21^I ML1/ML1:MUL IMB/DV:21^I DV1/DV1:>
BYT9 <DI DV2:V IMB/H1:03^EXC S3/BL T:T.,AO/AO:AOBJ,>
BYT9 <AOB/JRS T/JFC L/XC T/.AOB:01^P/N/>
BYT9 <JP:03^PU/PU:PUSH PUS/PO/PO:POP POP/JS,R:R.,>
BYT9 <JS P/JS PA:A.,JR PA/PUS:01^J:J..,POP:>
BYT9 <01^.,J/SH:02^A S2/ROT S1/L S2:S S3:H S1/JFF O/S1:21^.,C:C.,>

;ARITH COMP,SKIP,JUMP

BYT9 <ACCP:42^CA CA1/SJ/A JS/S JS:O 31^>
BYT9 <J COMP/S COMP/CA1:31^I COMP/M COMP/>
BYT9 <SJ:31^JUM PSJ/SKI PSJ:P COMP:>
BYT9 <03^.,L/E:E.,L E/PA/G E/N:N.,G.,>

;HALF WORDS

BYT9 <HWT:51^HW1/21^R HW2/L HW2:R HW3/HW1:>
BYT9 <21^L HW4/R HW4:L HW3:32^IMS/Z IMS/O IMS/EIMS/>

;TEST INSTRUCTIONS

BYT9 <ACBM:31^AC1/01^D AC2/S AC2/AC1:01^R AC2/L,>
BYT9 <AC2:42^N EAN/Z EAN/C EAN/O EAN:12^.,E/PA/N/>


;BOOLEAN

BYT9 <BOOLE:24^ST/AN:AND B2/AN/ST/AN/ST/>
BYT9 <X OR:OR B2/I OR/AN/EQ DV2/ST/OR/ST/OR/OR/>
BYT9 <ST:SET B2:24^Z IMB/IMB/CA:C TA/TM:M IMB/>
BYT9 <CM:C TM/TA:A IMB/IMB/IMB/CB:C BIMB/IMB/CA/>
BYT9 <CA/CM/CM/CB/O IMB/>

;MORE UUO'S
BYT9 <U50:03^OPE,N/TT,CAL:CAL L/...,RENAM,E/I,N/OU,T/>
BYT9 <U703:02^CLOS,E/RELEA,S/MTAP,E/UGET,F/>

REPEAT BINC,<BINRY==BINRY*400+BINRY*400>
IFN BINRY,<EXP BINRY>
>	;END OF REPEAT 0

IFN EDDT&10,<			;FILDDT STUFF
CRASH:	SIXBIT .CRASH.		;CANONICAL NAME FOR CRASH
	SIXBIT .SAV.
	Z
	Z
COMNDS:	SIXBIT .FILDDT.		;CANONICAL NAME FOR COMMAND LIST
	SIXBIT .TXT.
	Z
	Z
SNAP:	SIXBIT .SNAP.		;NAME FOR OUTPUT IF TO RETRIEVABLE DEVICE
	SIXBIT .LST.
	Z
	Z
CBUF:	BLOCK 3			;RING HEADERS
LBUF:	BLOCK 3
COMAND:	Z			;-1 IF COMMAND FILE ,0 IF NOT
CRASHS:	Z			;-1 IF CRASH.SAV ON DISK ,0 IF PEEK AT MONITOR
AC0=.
AC17=.+17
RSIDNT:	BLOCK 1000		;LOCS 0-777 ALWAYS IN CORE
CURENT:	BLOCK 4000		;WINDOW TO THE FILE ON DISK
RSAVE:	BLOCK 1			;INDEX OF THE CURRENT BLOCK. 0,1,...
RSILST:	IOWD 1000,RSIDNT
	Z
CURLST:	IOWD 4000,CURENT
	Z
>

SUBTTL	OP DECODER

DEFINE BYT9 (A) <IRP A,<
A>>

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
DEFINE	.ADR	(X) <
%'X==	CLOC
IFGE	<LASTB==CLOC+73-FIR.>-1000, <PRINTX OPTABLE TOO LONG>>>

DEFINE	.TRA	<
CLOC==	CLOC+1 ;>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>	;END OF IF1
IF2,<

DEFINE .ADR (A)<IFN %'A-CLOC,<PRINTX PHASE ERR AT: %'A>>

DEFINE	.TRA	(A) <
OUTP	%'A+73-FIR.>

DEFINE	.DIS	(A) <
OUTP	A&70/2+A&7-1>

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
BINRY==	BINRY+<A>_<BINC==BINC-9>
IFE BINC, <
		+BINRY
BINRY==0
BINC==^D36 >
CLOC==CLOC+1 >

>

TBL:  ;OPDECODER BYTE TABLE

BINRY== 0
CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER

;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************

BYT9 <

.DIS 63,.END,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM


;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,
	.ADR O,.END O,.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR F,.END F,.ADR Z,.END Z

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END,.TXT
	.ADR L,.END L,.TXT,.ADR M,.END M,.TXT
.ADR B,.END B,.TXT,.ADR BYTE,.DIS 32,.TRA BBN,.END,.END,.TXT
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B

;BBN ADDED INSTRUCTIONS

.ADR BBN,.DIS 21,.TXT U,.TRA MV,.END

;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END,.TXT
	.ADR I,.END I,.TXT,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TXT,.TRA I,.TRA M,.ADR S,.END S,.TXT
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TXT,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.END
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R,.TXT
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.TXT,.ADR POP
.DIS 01,.END,.TXT,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.TXT JFF,.TRA O
	.ADR S1,.DIS 21,.END,.TXT,.ADR C,.END C,.TXT

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TXT,.TRA L,.ADR E,.END E,.TXT,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.TXT,.END G,.TXT

;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TXT,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB

;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>


IF1,<	BLOCK	<CLOC+3>/4>

IF2,<	IFN BINC-^D36,<	+BINRY>>



IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>

PNTR:	EXP INST	;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK 2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0		;SAVE PUSH DOWN LIST POINTER

BTAB:	POINT 9,TBL	;TABLE USED TO GET NEXT BYTE POINTER
	POINT 9,TBL,8	;FOR TRANSFER BYTE
	POINT 9,TBL,17
	POINT 9,TBL,26

OPEVAL:	MOVEI T,0		;EVALUATE FOR AN OP CODE
	IDPB T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM P,SAVPDL
	TRZA F,OUTF
OPTYPE:	TRO F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH T,-33
	MOVEM T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE T,[XWD 440700,TXT]
	MOVEM T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	CLEARB R,W1
	MOVE W2,BTAB
DC1:	ILDB T,W2		;GET NEXT BYTE IN TBL
	CAILE T,40
	CAIL T,73
	SOJGE R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI T,40
	JUMPE T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG T,DC2
	DPB T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ T,-4
	AOS T
	DPB T,[XWD 300600,PNTR]
	TRNN F,OUTF
	JRST DC6		;FOR OPEVAL ONLY
	LDB R,PNTR		;GET # BYTES TO SKIP OVER
	JRST DC1

DC2:	HRREI T,-33(T)
	JUMPL T,DECT		;TYPE OUT A LETTER
	MOVEI W1,FIR.(T)		;BYTE IS A TRANSFER
	IDIVI W1,4
	MOVE W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI W2,(W1)
	JRST DC1


DECT:	TRNE F,OUTF
	JRST DC8	;TYPE OUT A LETTER
	ILDB W1,CHP	;GET NEXT INPUT LETTER
	CAIE W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST NOMAT	;DOESNT MATCH
	JRST DC1	;MATCHES, TRY NEXT

DECX:	TRNE F,OUTF	;STOP (CODE 40) HAS BEEN SEEN
	POPJ P,		;IF FOR OUTPUT, RETURN
	ILDB W1,CHP	;GET NEXT INPUT CHAR IF ANY
	JUMPE W1,DC7	;DOES # OF CHARS MATCH
NOMAT:	POP P,R		;NO, BACK UP AND TRY SOME MORE
	POP P,W2
	POP P,PNTR
	POP P,CHP
NOMAT1:	AOS R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB R,PNTR	;STUFF INTO ANSWER
	LDB R,PNTR
	JUMPN R,DC6AA	;IF =0, BYTE WAS TOO BIG
	CAME P,SAVPDL
	JRST NOMAT	;NOT AT TOP LEVEL
	POPJ P,		;UNDEFINED, FINALLY

DC6:	MOVEI R,0	;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB R,PNTR
DC6AA:	CAMN P,SAVPDL
	JRST DC6BB
	LDB T,-2(P)	;OLD VALUE OF PNTR
	CAME T,(P)
	JRST NOMAT1
DC6BB:	PUSH P,CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,R
	JRST DC1

DC7:	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINTER
	MOVE T,INST
	LSH T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB R,[POINT 3,T,8]
	TLC T,700000
	TLCN T,700000
	DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI T,133(T)
	PUSHJ P,TOUT		;OUTPUT A LETTER
	CLEARM SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST DC1

LIT


PS:	BLOCK LPDL


DDTEND:		;ONLY STARTING ADDRESS FOR FILDDT
		;NO START ADDRESS FOR EXEC OR USER DDT
		;BECAUSE MONITOR IS LOADED WITH BOTH EXEC AND USER DDTS
		;BUT STILL WANTS TO BE STARTED AT ITS OWN START ADDRESS
		;USER DDT IS LOADED LAST. - T.H.
IFN EDDT&10,<END DDT>
	END



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              