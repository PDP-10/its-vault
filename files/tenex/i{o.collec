
	BEGINP	DEVICE		R.S.TOMLINSON	 3 DECEMBER 1971	0857:

EXTERN	FORKX,NTTYS,CTYLIN
INTERN	NDEV

; Initial device tables used to initialize the working device tables

DEFINE	DV(NAME,UNITS,TYPE,DISP,CHAR,MODES)<
	XWD <SIXBIT /   NAME/>,UNITS
	XWD 0,DISP
	XWD CHAR+TYPE,MODES
IFE UNITS,<NDEV__NDEV+1>
NDEV__NDEV+UNITS>

NDEV__2	; Leaves room to patch 2 devices

USE

INIDVT:	DV(DSK,0,0,DSKDTB,720000,1)
IFDEF MTAN,<	DV(MTA,MTAN,2,MTADTB,643000,100000)>
IFDEF DTAN,<	DV(DTA,DTAN,3,DTADTB,742000,100001)>
IFDEF PTRN,<	DV(PTR,0,4,PTRDTB,240000,177777)>
IFDEF PTPN,<	DV(PTP,0,5,PTPDTB,440000,177777)>
IFDEF LPTN,<	DV(LPT,0,7,LPTDTB,400000,1)>
	DV(TTY,NLINES,12,TTYDTB,640000,1)
	DV(NIL,0,15,NILDTB,600000,177777)
IFDEF NETN,<	DV(NET,0,16,NETDTB,700000,3)>
IFDEF PLTN,<	DV(PLT,0,17,PLTDTB,440000,177777)>
INIDVE:	BLOCK 6


LS(DEVLCK)	; Lock for assigning devices
LS(DEVNAM,NDEV)	; Sixbit device name
LS(DEVCHR,NDEV)	; Device characteristics
LS(DEVDSP,NDEV)	; Lh ==> ofn if any, rh ==> dispatch table address
LS(DEVUNT,NDEV)	; Lh ==> job of assigner, rh ==> unit number

; Initialize device tables

^DEVINI:SETOM DEVLCK
	MOVSI C,-NDEV
	MOVSI D,INIDVT-INIDVE
INIDVL:	HRRZ A,INIDVT(D)	; Get number of units
	PUSH P,A		; Save
INIDV0:	MOVE A,INIDVT+1(D)	; Get initial dispatch address
	MOVEM A,DEVDSP(C)
	MOVE A,INIDVT+2(D)	; Get device characteristics
	MOVEM A,DEVCHR(C)
	MOVE A,INIDVT(D)	; Get name and units
	HLLZM A,DEVNAM(C)	; Save fixed part of name
	TRNN A,777777		; Multiple units?
	JRST INIDV1		; No.
	SOS B,(P)		; Yes, get real unit number
	HRRZS A
	SUBI A,1(B)
	HRROM A,DEVUNT(C)	; Save in devunt
	PUSHJ P,NUMSIX		; Convert number to sixbit string
	HLRM A,DEVNAM(C)	; Save in rh of name
	AOBJN C,.+1
	SKIPLE (P)		; Any more units of this kind?
	JRST INIDV0		; Yes.
	JRST INIDV2		; No.

INIDV1:	SETOM DEVUNT(C)		; No units, no job assigned
	AOBJN C,.+1
INIDV2:	ADD D,[XWD 3,3]		; Setp to next entry
	POP P,A
	JUMPL D,INIDVL		; Loop until done
	JUMPGE C,CPOPJ
	SETZM DEVNAM(C)		; Clear unused entries
	SETZM DEVCHR(C)
	SETZM DEVUNT(C)
	SETZM DEVDSP(C)
	AOBJN C,.-4
	POPJ P,

USE	SWAPPC

; Device lookup

^DEVLUK:MOVE B,1(A)
	TLNN B,774000
	JRST DEVLK5		; Null name not ok
	ANDCMI B,377
	CAMN B,[ASCIZ /CTY/]
	JRST [	MOVEI A,CTYLIN
		JRST DEVLK4]
	CAME B,[ASCIZ /TTY/]
	JRST DEVLK0
	MOVE B,JOBNO
	HLRZ A,JOBPT(B)
	CAIN A,777777
	JRST DEVLK5
DEVLK4:	HRLI A,600012
	PUSHJ P,CHKDEV
	JRST DEVLK5
	JRST DEVLK3

DEVLK0:	PUSHJ P,ASCSIX		; Convert to sixbit
	JRST DEVLK5		; Non-sixbit or too many
	MOVSI B,-NDEV
DEVLK1:	CAME A,DEVNAM(B)
	AOBJN B,DEVLK1
	JUMPGE B,DEVLK5
DEVLK3:	MOVE DEV,DEVDSP(B)
	HLRZ A,DEVUNT(B)
	CAIE A,777777
	CAMN A,JOBNO
	JRST DEVLK7
	MOVEI A,GJFX29
	POPJ P,

DEVLK7:	MOVE A,DEVCHR(B)
	TLNN A,(1B4)
	HRL DEV,DEVUNT(B)
	TLNE A,(1B7)
	TLNE A,(1B8)
	JRST SKPRET
	MOVEI A,GJFX28
	POPJ P,

DEVLK5:	MOVEI A,GJFX16
	POPJ P,

; Convert number to sixbit characters

USE

NUMSIX:	PUSH P,C
	PUSH P,B
	PUSH P,D
	MOVE C,[POINT 6,D]
	MOVEI D,0
	PUSHJ P,NUMSI1
	MOVE A,D
	POP P,D
	POP P,B
	POP P,C
	POPJ P,

NUMSI1:	IDIVI A,8
	HRLM B,(P)
	SKIPE A
	PUSHJ P,NUMSI1
	HLRZ A,(P)
	ADDI A,20
	IDPB A,C
	POPJ P,

USE	SWAPPC

; Routine to convert ascii to sixbit
; Call:	A	; Lookup pointer
;	PUSHJ P,ASCSIX	; For six characters
; Or
;	PUSHJ P,ASC3SX	; For three characters

^ASCSIX:SKIPA C,[6]
^ASC3SX:MOVEI C,3
	HRLI A,(<POINT 7,0,35>)
	PUSH P,A
	SETZB A,B
	PUSH P,D
ASCSX1:	ILDB D,-1(P)
	JUMPE D,ASCSX3		; Null, done
	SOJL C,ASCSXR		; Too many characters, error
	SUBI D,40
	JUMPL D,ASCSXR		; Not sixbit
	CAIL D,100
	JRST ASCSXR
	ROTC A,6
	IOR A,D
	IORI B,77
	JRST ASCSX1

ASCSX4:	ROTC A,6
ASCSX3:	TLNN A,770000
	JUMPN A,ASCSX4
	AOS -2(P)
ASCSXR:	POP P,D
	POP P,C
	POPJ P,

	BENDP DEVICE

	BEGINP	LOOKUP ROUTINES (DEVICE INDEPENDENT)

; Name lookup
; Call:	A		; Iowd # full words in string,1st word of string
;	FLAG NREC	; =1 for no partial string recognition
;	FILOPT(JFN)	; Should address the last byte of input
;	PUSHJ P,NAMLUK	; For recognition
; Or
;	PUSHJ P,NAMLKX	; For no recognition
; Return
;	+1	; Match is impossible
;	+2	; Ambiguous
;	+3	; Match, the complete string replaces the input
; A contains address of fdb for the first file of the name
; B contains the location of the pointer whose rh points to the fdb
; Clobbers a,b,c,d, and bits norec1, mtchf, and ambgf

^NAMLKX:TEST(OA,NREC1)		; Enter here for recognition
^NAMLUK:TEST(Z,NREC1)
	TEST(ZA,UNLKF)
NAMLUU:	TEST(O,UNLKF,NREC1)
	TEST(Z,MTCHF,AMBGF)
	PUSH P,A		; Save a
	TEST(NE,DIRSF,NAMSF)	; Are we stepping?
	JRST NAMSTP		; Yes.
	HRRZ A,FILDDN(JFN)	; Get directory number of this file
	HLRZ B,DEV
	PUSHJ P,@DLUKD(DEV)	; Map the directory, and lock it
	JRST [	TEST(O,NNAMF)	; Nameless device
		POP P,A
		MOVSI B,774000
		SKIPL A		; Check for null name
		TDNE B,1(A)
		JRST [	MOVEI A,GJFX25
			POPJ P,]; Non-null name and no dir
		TEST(NN,UNLKF)	; Null name and no directory
		JRST SK2RET	; Yields success if normal lookup
		JRST SKPRET]	; And single skip if called from extluk
	BUG(CHK,<NAMLUK: SINGLE SKIP FROM @DLUKD(DEV) WHEN NOT STEPPING>)
	POP P,A
	JRST @NLUKD(DEV)	; Continue with device dependent portion

NAMSTP:	TEST(NE,STEPF)
	TEST(O,NAMXF)
	TEST(NE,STEPF)
	TEST(NE,NAMSF)		; Is name to be stepped?
	JRST NAMST1		; Yes.
NAMST4:	HRRZ A,FILDDN(JFN)	; Get directory number
	HLRZ B,DEV
	HLRZ B,DEV
	TEST(NE,STEPF)
	TEST(O,DIRXF)
	PUSHJ P,@DLUKD(DEV)	; Step directory
	JRST NAMFAI		; Stepping nameless device fails
	JRST NAMFAI		; No directories left
	MOVE A,DIRNUM
	HRRM A,FILDDN(JFN)
	JRST NAMST2

NAMST1:	PUSH P,F1
	TEST(Z,STEPF)
	HRRZ A,FILDDN(JFN)
	HLRZ B,DEV
	PUSHJ P,@DLUKD(DEV)	; Set directory
	JRST [	POP P,F1
		JRST NAMFAI]
	BUG(CHK,<NAMSTP: SINGLE SKIP FROM @DLUKD(DEV) WHEN NOT STEPPING>)
	AND F1,[XWD EXTXF,NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
NAMST2:	MOVE A,(P)		; Get lookup pointer
	PUSHJ P,@NLUKD(DEV)	; Step the name
	JRST NAMST3		; No more
	BUG(HLT,<EXTLUK: SKIP FROM @NLUKD(DEV) WHEN STEPPING>)
	SUB P,[XWD 1,1]
	TEST(Z,STEPF)
	JRST SK2RET		; Double skip

NAMST3:	MOVEI A,GJFX32
	TEST(NN,DIRSF)		; Able to step directory?
	JRST NAMFAI
	TEST(NE,NAMSF)
	SETZM (P)		; Cause first name to be set
	TEST(O,STEPF)
	JRST NAMST4

NAMFAI:	SUB P,[XWD 1,1]
	POPJ P,

; Extension lookup
; Call:	RH(FILDDN(JFN))	; The directory number
;	LH(FILNEN(JFN))	; The file name string block location
;	LH(A)		; Minus number of full words in string
;	RH(A)		; Location of first word of string -1
;	FILOPT(JFN)	; Location of last byte of input if recognition
;	PUSHJ P,EXTLUK	; For recognition
; Or
;	PUSHJ P,EXTLKX	; For no recognition
; Return
;	+1	; Error, no match
;	+2	; Ambiguous
;	+3	; Match
;	A	; Location of fdb of first version
;	B	; Location of pointer to fdb  in a
; Directory locked
; Clobbers a,b,c,d,filopt(jfn), and bits mtchf, ambgf, norec1

^EXTLUK:TEST(ZA,NREC1)
^EXTLKX:TEST(O,NREC1)
	TEST(ZA,UNLKF)
^EXTLUU:TEST(O,UNLKF,NREC1)
	PUSH P,A
	TEST(NN,EXTSF)
	TEST(NE,NAMSF,DIRSF)
	JRST EXTSTP		; Stepping
	PUSH P,F1
	PUSHJ P,EXTNLK		; Get pointer to fdb for this name
	JRST [	SUB P,[XWD 2,2]
		POPJ P,]	; ????? name wasn't there!!!!!
	JRST [	POP P,F1
		POP P,A
		MOVSI B,774000
		SKIPL A		; Check for null extension
		TDNE B,1(A)
		JRST [	MOVEI A,GJFX26
			POPJ P,]	; Non-null ext and no direct
		TEST(NN,UNLKF)
		JRST SK2RET
		JRST SKPRET]
	POP P,F1		; Restore f1
	TEST(Z,MTCHF,AMBGF)
	POP P,A
	JRST @ELUKD(DEV)	; Continue with device dependent portion

EXTSTP:	TEST(NE,STEPF)
	TEST(O,EXTXF)
	TEST(NE,STEPF)
	TEST(NE,EXTSF)		; Stepping extension?
	JRST EXTST1		; Yes.
EXTST4:	PUSH P,FILOPT(JFN)
	HLRZ A,FILNEN(JFN)
	ADD A,[POINT 7,0,35]
	MOVEM A,FILOPT(JFN)
	PUSH P,F1
	PUSHJ P,EXTNLK
	JFCL
	JRST [	POP P,F1
		POP P,FILOPT(JFN)
		JRST EXTFAI]	; Failed
	AND F1,[XWD EXTXF,NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
	POP P,FILOPT(JFN)
	JRST EXTST2

EXTST1:	PUSH P,F1
	TEST(Z,STEPF)
	PUSHJ P,EXTNLK		; Lookup name for this file
	JFCL
	JRST [	POP P,F1
		JRST EXTFAI]
	POP P,F1
EXTST2:	MOVE A,(P)
	PUSHJ P,@ELUKD(DEV)
	JRST EXTST3		; No more extensions
	BUG(HLT,<VERLUK: SKIP FROM @ELUKD(DEV) WHEN STEPPING>)
	SUB P,[XWD 1,1]
	TEST(Z,STEPF)
	JRST SK2RET		; Success

EXTST3:	TEST(NN,DIRSF,NAMSF)
	JRST EXTFAI		; Can't step either name or dir
	TEST(NE,EXTSF)
	SETZM (P)
	TEST(O,STEPF)
	JRST EXTST4

EXTNLK:	HLRZ A,FILNEN(JFN)
	HRLI A,700
	ILDB B,A		; Search for the null
	JUMPN B,.-1
	HLRZ B,FILNEN(JFN)
	SUBI B,-1(A)		; Number of full words
	HRLZ A,B
	HLR A,FILNEN(JFN)
	JRST NAMLUU

EXTFAI:	SUB P,[XWD 1,1]
	POPJ P,

; Get pointer to an fdb
; Call:	LH(FILDDN(JFN))	; Device name block location
;	RH(FILDDN(JFN))	; Directory number
;	LH(FILNEN(JFN))	; File name block location
;	RH(FILNEN(JFN)	; Extension block location
;	RH(FILVER(JFN))	; File version number
;	PUSHJ P,GETFDB
; Return
;	+1	; Not found
;	+2	; Found, a has location of the fdb
; Leaves directory locked and psi off
; Clobbers a,b,c,d

^GETFDB:PUSH P,F1
	PUSH P,F
	HRRZ A,FILVER(JFN)	; Get the version number in a
	HRRZ F,NLUKD(DEV)
	CAIE F,MDDNAM
	BUG(HLT,<GETFDB: CALLED FOR NON-MDD DEVICE>)
	MOVSI F,OLDNF!IGDLF
	TEST(O,NREC)
	TLZ F1,-1
	PUSHJ P,VERLKX
	SOS -2(P)
	POP P,F
	POP P,F1
	AOS (P)
	POPJ P,

; Version lookup
; Call:	LH(FILDDN(JFN))	; Device name block location
;	RH(FILDDN(JFN))	; Directory number
;	LH(FILNEN(JFN))	; File name block location
;	RH(FILNEN(JFN)	; Extension block location
;	A		; Version number to find 0 => most recent
;			; -1 => next higher than most recent
;	PUSHJ P,VERLUK
; Return
;	+1	; Not found
;	+2	; Found, a points to the pertinent fdb
; Leaves directory locked and psi off if successfull
; Clobbers a,b,c,d

VERLKX:	TEST(OA,UNLKF)
^VERLUK:TEST(Z,UNLKF)
	PUSH P,A		; Preserve a
	TEST(NN,VERSF,EXTSF)
	TEST(NE,NAMSF,DIRSF)
	JRST VERSTP		; Stepping
	PUSH P,F1		; Save f1, since extluu will clobber
	PUSHJ P,VERELK		; Lookup extension (name directory etc)
	JRST [	SUB P,[XWD 2,2]
		POPJ P,]
	JRST [	POP P,F1
		POP P,A
		JRST SKPRET]
	POP P,F1
	POP P,A			; Restore version to look up
	JRST @VLUKD(DEV)

VERSTP:	TEST(NE,STEPF)
	TEST(NE,VERSF)		; Stepping versions?
	JRST VERST1
VERST4:	PUSH P,FILOPT(JFN)
	HRRZ A,FILNEN(JFN)
	ADD A,[POINT 7,0,35]
	MOVEM A,FILOPT(JFN)
	PUSH P,F1
	PUSHJ P,VERELK
	JFCL
	JRST [	POP P,F1
		POP P,FILOPT(JFN)
		JRST VERFAI]	; Failure
	AND F1,[XWD EXTXF,NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
	POP P,FILOPT(JFN)
	JRST VERST2

VERST1:	PUSH P,F1
	TEST(Z,STEPF)
	PUSHJ P,VERELK		; Find the extension
	JRST [	POP P,F1
		JRST VERFAI]
	BUG(HLT,<VERLUK: IMPOSSIBLE SKIP RETURN FROM EXTLUU>)
	POP P,F1
VERST2:	MOVE A,(P)
	PUSHJ P,@VLUKD(DEV)	; Step the version
	JRST VERST3		; None left
	SUB P,[XWD 1,1]
	TEST(Z,STEPF)
	JRST SKPRET		; Success

VERST3:	TLNN F1,EXTSF!NAMSF!DIRSF
	JRST VERFAI		; Not stepping anything else
	TEST(NE,VERSF)
	SETZM (P)		; To find most recent
	TEST(O,STEPF)
	JRST VERST4

VERELK:	HRRZ A,FILNEN(JFN)
	HRLI A,(<POINT 7,0,35>)
	ILDB B,A
	JUMPN B,.-1
	HRRZ B,FILNEN(JFN)
	SUBI B,-1(A)
	HRLZ A,B
	HRR A,FILNEN(JFN)
	JRST EXTLUU

VERFAI:	SUB P,[XWD 1,1]
	POPJ P,

	BENDP	LOOKUP

INTERN	DIRLCK,DIRUSE

; Variables in directory

DIRORG__760000
SET DRCTPC,760000	; Set directory pc to directory origin
USE DRCTPC		; And use it

DIRLCK:	BLOCK 1		; Directory lock
DIRUSE: BLOCK 1		; Directory use indicator
DIRNUM:	BLOCK 1		; Number of this directory
SYMBOT:	BLOCK 1		; Symbol table bottom
SYMTOP:	BLOCK 1		; Symbol table top
DIRFRE:	BLOCK 7		; Free storage header
FRETOP:	BLOCK 1		; Current top of free storage area
DIRDPW:	BLOCK 1		; Default file protection word
DIRPRT:	BLOCK 1		; Directory protection word
DIRDBK:	BLOCK 1		; Default backup specification
DIRGRP:	BLOCK 1		; Groups having access to this directory
SPARE:	BLOCK 4		; Locations for additional variables
DIRLOC:	BLOCK 1		; Temp used for saving location in the directory
DIRINP:	BLOCK 1		; Temp to save pointer to input for lookup
DIRINC:	BLOCK 1		; Temp to hold increment for searching
DIRMSK:	BLOCK 1		; Temp to hold mask for lookups
DIRSCN:	BLOCK 1		; Temp to save pointer to pointer
DIFREE:	BLOCK 0		; Beginning of free area

; Variables in subindex directory block 0

DIRHTO__DIRDPW		; Directory number hash table origin
DIRHTL__DIRPRT		; Directory number hash table length
^FDADR__DIRDBK		; Disc address of fd ib

SBIDTB:	BLOCK <200+4>/5	; Directory subindex dispatch
ESBIDT:

; Parameters and bits pertinent to directories

SET TPC,0
USE TPC			; Symbols relative to fdb origin
	BLOCK 1		; The header, not referenced symbolically
FDBCTL_:BLOCK 1		; Lh ==> control bits (see below)
			; Rh ==> location of file name block
FDBEXT_:BLOCK 1		; Lh ==> location of extension block
			; Rh ==> pointer to other extensions
FDBADR_:BLOCK 1		; The file address & class field
FDBPRT_:BLOCK 1		; File protection word
FDBCRE_:BLOCK 1		; Creation date & time of version 1
FDBUSE_:BLOCK 1		; Lh ==> last writer directory number
			; Rh ==> use count (+1 for each indirect pointer
			;  and saved environment)
FDBVER_:BLOCK 1		; Lh ==> version number
			;  this is job number for temp files
			; Rh ==> pointer to other versions
FDBACT_:BLOCK 1		; Account infor for charging
			;  + for location of string block
			;  - for number
FDBBYV_:BLOCK 1		; 0-5 ==> number of version to retain
			; 6-11 ==> last byte size
			; Rh ==> count of actual pages in file
FDBSIZ_:BLOCK 1		; Length of file in bytes
FDBCRV_:BLOCK 1		; Creation date and time of this version
FDBWRT_:BLOCK 1		; Date & time of last write
FDBREF_:BLOCK 1		; Date & time of last reference
FDBCNT_:BLOCK 1		; Lh ==> count of writes
			; Rh ==> count of references
FDBBCK_:BLOCK 5		; Words for backup system
FDBUSW_:BLOCK 1		; User settable word
FDBLEN:			; Length of fdb

USE

; Pointers to things in fdb

PFILPC:	POINT 18,FDBBYV(A),35	; Pointer to size in pages of file
PFILBS:	POINT 6,FDBBYV(A),11	; Pointer to last byte size
PFILVC:	POINT 6,FDBBYV(A),5	; Pointer to version retention count

; Bits in lh of fdbctl

FDBTMP__400000		; File is temporary
FDBPRM__200000		; File is permanent
FDBNEX__100000		; No extension for this fdb yet
			;  the file does not really exist
FDBDEL__040000		; File is deleted
FDBNXF__020000		; File does not exist (first write not complete)
FDBLNG__010000		; Long file
FDBSHT__004000		; Compressed page table
FDBENV__002000		; Environment file
FDBSUB__001000		; Subroutine file

; Symbols in directory descriptor block

SET TPC,0
USE TPC

	BLOCK 1		; Header not referenced symbollically
DDBNAM_:BLOCK 1		; Lh ==> pointer to password string block
			; Rh ==> pointer to name string block
DDBMAX_:BLOCK 1		; Maximum disk storage for this directory
DDBLOG_:BLOCK 1		; Time and date of last login
DDBPRV_:BLOCK 1		; Privilege bits
DDBMOD_:BLOCK 1		; Mode bits
DDBRES_:BLOCK 1		; Special resource information
DDBNUM_:BLOCK 1		; Lh ==> directory number
			; Rh ==> pointer to special information block
			; 0 means no special info
DDBDAT_:BLOCK 1		; Date and time of last login
DDBGRP_:BLOCK 1		; Groups to which this user belongs
DDBLEN_:

USE	SWAPPC

	BEGINP	DIRECTORY & SUBINDEX ROUTINES

; Check protection of file/directory
; Call:	LH(A)	; Readf, wrtf etc. bits in left half
;	RH(A)	; Location of fdb if call to accchk
;	PUSHJ P,DIRCHK	; To check access to a directory
; Or
;	PUSHJ P,ACCCHK	; To check access to a file
; Return
;	+1	; Error, access not allowed
;	+2	; Ok
; The directory in which the protection is checked must be locked

^DIRCHK:SKIPA B,DIRPRT
^ACCCHK:MOVE B,FDBPRT(A)	; Get protection of this file
	MOVE C,CAPENB
	TRNE C,WHEEL!OPR
	JRST SKPRET
	MOVE C,JOBNO
	HRRZ C,JOBDIR(C)
	CAMN C,DIRNUM		;REFERENCE TO OWN DIR?
	JRST ACCCH9		;YES
	MOVE C,DIRNUM
	CAME C,JOBDNO		; If current directory
	JRST [	MOVE C,GROUPS	; Groups of this user
		TDNN C,DIRGRP
		LSH B,6
		LSH B,6
		JRST .+1]
ACCCH9:	ANDCAI B,770000		; Mask off 6 bits and complement
	LSH B,=18-1
	AND A,B			; Get bad bits
	JFFO A,ACCCH2		; If any ones, access not permitted
	JRST SKPRET

ACCCH2:	SOS B,A+1		; Get bit number
	ROT B,-1		; Divide by 2
	HRRZ A,ACCERT(B)	; Get error number
	SKIPL B
	HLRZ A,ACCERT(B)
	POPJ P,

ACCERT:	XWD OPNX3,OPNX4
	XWD OPNX5,OPNX6
	XWD OPNX12,OPNX13

; Directory lookup
; Call:	A		; Iowd # full words in input, loc first word
;	FILOPT(JFN)	; Location of last byte if recognition
;	PUSHJ P,DIRLUK	; For recognition
; Or
;	PUSHJ P,DIRLKX	; For no recognition
; Return
; +1	ERROR, NO MATCH
; +2	ERROR, AMBIGUOUS
; +3	OK, IN A, THE DIRECTORY NUMBER
; Clobbers a,b,c,d, filopt(jfn) and bits mtchf, ambgf, norec1

^DIRLUU:TEST(O,UNLKF)
	TEST(O,NREC1)
	JRST DIRLU0

^DIRLUK:
	TEST(ZA,NREC1)
^DIRLKX:
	TEST(O,NREC1)
	TEST(Z,UNLKF)
DIRLU0:	TEST(Z,MTCHF,AMBGF)
	PUSH P,A		; Save input pointer
	MOVEI A,0
	PUSHJ P,SETDIR		; Map block 0 of directory index
	JRST [	POP P,A		; Does not exist. if this happens,
				; The index is screwed up
		POPJ P,]	; Proceed as for failure
	MOVE A,(P)		; Get the input pointer
	MOVE A,1(A)		; Get the first word of the input string
	LSH A,-=29		; Shift over to the first character
	IDIVI A,5		; Prepare to dispatch to proper subindex
	LDB A,DPTAB(A+1)
	JUMPE A,[POP P,A	; There is no subindex for this char
		UNLOCK DIRLCK
		OKINT
		POPJ P,]	; Fail
	MOVNS A			; Convert to negative subindex number
	UNLOCK DIRLCK
	OKINT
	PUSHJ P,SETDIR		; And map the correct subindex
	JRST [POP P,A		; Subindex does not exist
				; Indicates fouled up directory index
		POPJ P,]	; Treat as failure
	POP P,A			; Restore input pointer
	MOVEI B,0
	PUSHJ P,LOOKUP
	JRST DIRFND
DIRLK9:	HRRZ A,DIRLOC		; Get directory number rh(symtabptr)
	HRRZ A,DIRORG(A)
	TEST(NE,UNLKF)		; If entry at dirluu,
	JRST SKPRET		; Return skipping with directory locked
	UNLOCK DIRLCK
	OKINT
	JRST SK2RET		; Double skip return

DIRFND:	MOVEM B,DIRLOC		; Save where
	TEST(NE,MTCHF)
	TEST(NE,NREC,NREC1)	; Since we do not have an exact match
	JRST DIRFD2
	TEST(NE,AMBGF)
	JRST AMBRET		; Ambiguous
	AOS B			; Ok so far, make sure not ambiguous
	CAMGE B,SYMTOP		; By examining the next entry
	PUSHJ P,NAMCMM
	JRST DIRUNQ		; If not equal, we win
	JRST DIRUNQ
	JRST AMBRET		; Otherwise it is ambiguous
	JRST AMBRET

DIRFD2:	TEST(NN,UNLKF)		; If entry not at dirluu,
	JRST ERRET		; Return unlocking directory
	POPJ P,			; Otherwise, return no skip

DIRUNQ:	MOVE B,DIRLOC		; Get location of symtabptr
	MOVE A,DIRINP		; And input pointer
	MOVNI A,(A)		; Negative of origin of input
	ADD A,FILOPT(JFN)	; Get end of input relative to beginning
	HLRZ C,DIRORG(B)	; Get location of string block
	ADDI A,DIRORG+1(C)	; Yields pointer to tail of string
	LDB C,A
	DPB C,FILOPT(JFN)
DIRUN1:	ILDB C,A		; Copy tail to input
	JUMPE C,[MOVEI C,0
		MOVE B,FILOPT(JFN)
		IDPB C,B
		JRST DIRLK9]
	IDPB C,FILOPT(JFN)
	JRST DIRUN1

; Pointers to subindex dispatch table

RADIX =10

DPTAB:	FOR Q_6,=36,7
<	POINT 7,SBIDTB(B),Q
>

RADIX 8

; Directory number to string conversion
; Call:	A	; The directory number
;	PUSHJ P,GDIRST
; Return
;	+1	; Error, no such directory number
;	+2	; Ok, in a, pointer to string block holding the name
; The directory index is locked upon exit, and must be unlocked
; After the string is used
; Clobbers a,b,c,d

^GDIRST:PUSHJ P,GETDDB		; Get the ddb
	POPJ P,			; None
	HRRZ A,DDBNAM(A)	; Get pointer to name
	ADDI A,DIRORG		; As absolute address
	JRST SKPRET

; Initilize a directory block
; Call:	A	; Most common block size in the directory
;		; At dirorg, the directory in question
;	PUSHJ P,INIBLK

USE

^INIBLK:PUSH P,A
	MOVE A,[XWD DIRORG,DIRORG+1]
	SETZM DIRORG
	BLT A,DIFREE		; Clear all of fixed storage
	POP P,DIRFRE+3
	SETZM DIRLCK		; Intially locked
	MOVE A,[XWD 500000,777752]
	MOVEM A,DIRDPW		; Default protection is all access
	MOVE A,[XWD 500000,777740]
	MOVEM A,DIRPRT		; Directory protection is all access
	MOVEI A,2
	MOVEM A,DIRDBK
	MOVEI A,7777
	MOVEM A,SYMBOT		; Null symbol table
	MOVEM A,SYMTOP
	MOVEI A,DIFREE-DIRORG
	HRLZM A,DIRFRE
	MOVEI B,6000		; 6000 words of free storage
	MOVEM B,DIFREE
	MOVEM B,DIRFRE+2
	ADDI B,DIFREE-DIRORG
	MOVEM B,FRETOP
	SETOM DIRFRE+1
	POPJ P,

USE	SWAPPC

; Get directory descriptor block location
; Call:	A	; Directory number
;	PUSHJ P,GETDDB
; Return
;	+1	; No such directory
;	+2	; Ok, a addresses the directory descriptor block
; Leaves the directory subindex locked and psi off
; Clobbers a,b,c,d

^GETDDB:PUSHJ P,HSHLUK		; Look up number in hash table
	JRST [	UNLOCK DIRLCK
		OKINT
		POPJ P,]	; Not found
	UNLOCK DIRLCK		; Release block 0
	OKINT
	HLRZ A,C		; Location of the descriptor block
	IDIVI A,10000		; Separate subindex number and offset
	PUSH P,A+1		; Save offset
	MOVNS A
	PUSHJ P,SETDIR		; Map the pertinent subindex
	JRST [	POP P,A
		POPJ P,]
	POP P,A
	ADDI A,DIRORG
	JRST SKPRET		; Skip return

; Hash table lookup routine
; Call:	A	; Directory number
;	PUSHJ P,HSHLUK
; Return
;	+1	; Error, no such number
;	+2	; Success
;	LH(C)	; Location of ddb
;	B	; Location of hash table entry

^HSHLUK:PUSH P,A		; Save directory number
	MOVEI A,0
	PUSHJ P,SETDIR		; Map block 0 of the directory subindex
	BUG(HLT,<HSHLUK: IMPOSSIBLE FAILURE OF CALL TO SETDIR FOR BLOCK 0>)
	POP P,A
	MOVE B,A
	IMULI B,741633		; Hash on the directory number
	ROT B,7
	TSC B,B
	LSH B,-1
	MUL B,DIRHTL
	ADD B,DIRHTO		; Initial location to probe
	PUSH P,B
	PUSH P,[0]
GETDD1:	MOVE C,DIRORG(B)	; Get the hash table entry
	JUMPLE C,[CAMG C,[XWD -2,0]
		JRST HSHLU1	; Place-holder
		SKIPN (P)	; Position found yet?
		MOVEM B,(P)	; No, save this pointer
		JUMPL C,HSHLU1
		POP P,B		; Lookup failure
		SUB P,[XWD 1,1]
		POPJ P,]	; Return
	CAIN A,(C)		; Compare rh to input number
	JRST [	SUB P,[XWD 2,2]
		JRST SKPRET]
HSHLU1:	SOS B			; Cycle backward through table
	CAMGE B,DIRHTO
	ADD B,DIRHTL
	CAME B,-1(P)
	JRST GETDD1
	POP P,B
	SUB P,[XWD 1,1]
	POPJ P,

; Insert account string/number in fdb
; Call:	A		; Location of fdb
;	FILACT(JFN)	; Negative number or positive string location
;	PUSHJ P,INSACT
; Returns +1 always
; Clobbers b,c

^INSACT:PUSHJ P,GETFDB
	POPJ P,
	PUSHJ P,INSAC0
	JRST ERRET

INSAC0:	PUSH P,A
	SKIPLE B,FILACT(JFN)	; Number?
	JRST CPYACT		; No. must copy string
	POP P,A
	MOVEM B,FDBACT(A)
	POPJ P,

CPYACT:	HRRO A,CAPENB
	TRNN A,WHEEL!OPR
	MOVE A,MODES
	TLNN A,(1B1)
	 JRST CPYACF
	MOVN A,(B)
	HRLZI A,2(A)
	HRR A,B
	MOVEI B,100000
	PUSHJ P,LOOKUP
	JRST CPYAC1
	MOVE B,DIRLOC
	HLRZ B,DIRORG(B)
CPYAC0:	AOS DIRORG+1(B)		; Increment share count
CPYACG:	POP P,A			; Restore fdb pointer
	MOVEM B,FDBACT(A)	; Store as account
	POPJ P,

CPYACF:	MOVE B,[XWD 500000,=69]
	JRST CPYACG

CPYAC1:	MOVE A,SYMBOT
	ADDI A,2
	CAMG A,FRETOP		; Room for new symtab entry?
	 JRST [	PUSHJ P,XPAND	; No, try to expand symtab
		 JRST CPYACF	; Can't.
		JRST .+1]
	HLRE A,DIRINP
	MOVN B,A
	ADDI B,3
	PUSH P,B
	PUSHJ P,ASGDFR
	JRST [	POP P,B
		JRST CPYACF]
	HRLZ B,DIRINP
	HRRI B,2(A)
	POP P,D
	ADDI D,-3(B)
	BLT B,(D)
	MOVE C,DIRMSK
	ANDM C,(D)
	SETZM 1(A)
	MOVEI B,-DIRORG(A)
	HRLZ C,B
	HRRI C,100000
	SOS B,DIRLOC
	SOS A,SYMBOT
	ADDI A,DIRORG
	HRLI A,1(A)
	CAIL B,-DIRORG+1(A)
	BLT A,DIRORG-1(B)
	MOVEM C,DIRORG(B)
	HLRZ B,C
	JRST CPYAC0

; Insert protection into fdb
; Call:	FILPTR(JFN)	; Protection number
;	A		; Location of fdb
;	PUSHJ P,INSPRT
; Returns +1
; Clobbers b

^INSPRT:PUSHJ P,GETFDB
	POPJ P,
	PUSH P,A
	MOVSI A,XCTF		; Check for owner privilege
	PUSHJ P,DIRCHK
	 JRST [	POP P,A
		JRST ERRET]
	POP P,A
	MOVE B,FILPRT(JFN)
	MOVEM B,FDBPRT(A)
	JRST ERRET

; Initialize fdb
; Call:	A		; Location of fdb
;	PUSHJ P,FDBINI
; Return +1 always
; Initializes the fdb as follows:
;	FDBCTL	; Fdbnxf (non-existent)
;	FDBCRE	; Date and time of now
;	FDBCRV	; Date and time of now
; All else is zeroed including fdbext, fdbver, etc.
; Clobbers b,c,d
; Preserves a

FDBINI:	MOVEI B,400100
	HRLM B,(A)		; Mark the block as fdb type
	HRLZI B,1(A)
	HRRI B,2(A)
	SETZM 1(A)
	BLT B,FDBLEN-1(A)	; Clear the entire fdb
	PUSH P,A
	GTAD			; Get today
	POP P,B
	MOVEM A,FDBCRE(B)	; Set creation dates
	MOVEM A,FDBCRV(B)
	MOVSI A,FDBNXF
	MOVEM A,FDBCTL(B)
	MOVE A,DIRDPW
	MOVEM A,FDBPRT(B)
	MOVE A,B
	MOVE B,ACCTPT		; Get login account pointer/number
	CAML B,[500000000000]
	CAMLE B,[577777777777]
	MOVEI B,ACCTSR-1		; String, setup address of block
	SKIPN B
	TLO B,500000		; Convert 0 to 0
	MOVEM B,FILACT(JFN)
	MOVE B,ACCTSL
	MOVEM B,ACCTSR-1
	PUSH P,DIRINP
	PUSH P,DIRLOC
	PUSH P,DIRSCN
	PUSH P,DIRMSK
	PUSHJ P,INSAC0
	POP P,DIRMSK
	POP P,DIRSCN
	POP P,DIRLOC
	POP P,DIRINP
	SETZM FILACT(JFN)
	POPJ P,

; Set directory or directory index
; Call:	A	; Directory number or subindex number
;	B	; Ofn of the appropriate directory unless its the di
;	PUSHJ P,SETDIR	; For mapping a directory
; Or
;	PUSHJ P,SETDIR	; For mapping a directory subindex
; Return
;	+1	; Non-existent directory
;	+2	; Normal, the 10 pages starting at dirorg are set up
; Clobbers a,b,c,d

USE

^SETDIR:NOINT
	PUSH P,A
	PUSH P,B
	MOVEI A,DIRORG
	PUSHJ P,MRMAP		; Read the ident of current directory
	JRST [	SKIPE A		; Non-existent page?
		BUG(CHK,<SETDIR: DIRECTORY PAGE 0 BELONGS TO A FORK>)
		POP P,B		; Yes, skip the following
		MOVE A,0(P)
		JRST SETDI1]
	PUSHJ P,MRPACS		; Read access of page
	MOVE C,A
	POP P,B
	MOVE A,0(P)		;DIRECTORY NUMBER
	TLNE C,(1B5)		; If non-existent
	CAME A,DIRNUM		; Or different
SETDI1:	PUSHJ P,MAPDIR		; Must map it first
	MOVEI A,DIRORG
	PUSHJ P,MRMAP
	BUG(HLT,<SETDIR: DIRECTORY PAGE 0 IS NOT A FILE PAGE>)
	PUSHJ P,MRPACS
	MOVE C,A
	POP P,A			;DIRECTORY NUMBER
	TLNE C,(1B5)		;IF STILL NO ACCESS,
	CAME A,DIRNUM		;OR NUMBER DOESN'T COMPARE,
	JRST [	OKINT		; Directory non-existent
		POPJ P,]	; Give no-skip return
	LOCK DIRLCK
	PUSH P,FORKX
	POP P,DIRUSE
	JRST SKPRET

^MAPDIR:JUMPLE A,[MOVE B,DIOFN
		MOVMS A
		JRST MAPDI0]
	CAIL A,NFDIB*100
	BUG(HLT,<MAPDIR: ATTEMPT TO MAP INVALID DIRECTORY NUMBER>)
	IDIVI A,100
	EXCH A,B
	MOVE B,FDOFN(B)
MAPDI0:	LSH A,3			; Convert to page number
	HRL A,B			; Put ofn in lh
	MOVE B,[XWD 140000,DIRORG]
MAPDI1:	PUSHJ P,SETMPG		; Put pages of fd in map
	ADDI B,1000
	CAMGE B,[XWD 140000,DIRORG+10000]
	AOJA A,MAPDI1
	POPJ P,

USE	SWAPPC

; Multiple directory device directory lookup routine
; Call:	A	; Directory number
;	PUSHJ P,MDDDIR
; Returns
;	+1	; Not used here, means non-directory device
;	+2	; No such directory
;	+3	; Ok, the directory is mapped and locked

^MDDDIR:AOS (P)			; Always skips atleast once
	TEST(NE,STEPF)
	TEST(NN,DIRSF)
	JRST SETDIR
	PUSH P,A
	MOVEI A,0
	PUSHJ P,SETDIR		; Map the index block 0
	BUG(HLT,<MDDDIR: IMPOSSIBLE FAILURE OF CALL TO SETDIR FOR BLOCK 0>)
	MOVEI A,777777		; Larger than any possible dir number
	AOS (P)			; Looking for one greater than last
	MOVE B,DIRHTO
	ADD B,DIRHTL
	SOS B
MDDDI0:	MOVE C,DIRORG(B)	; Get hash table entry
	JUMPLE C,MDDDI1		; Empty slot
	HRRZS C			; Extract directory number
	CAMN C,(P)		; Is this what we are looking for
	JRST MDDDI2		; Yes, map it etc.
	CAMLE C,(P)
	CAML C,A
	JRST MDDDI1
	MOVE A,C		; Better than any other
MDDDI1:	CAMLE B,DIRHTO
	SOJA B,MDDDI0		; Loop through entire hash table
	CAIE A,777777		; Were any found?
	JRST MDDDI3		; Yes
	POP P,A
	UNLOCK DIRLCK
	OKINT
	POPJ P,

MDDDI3:	MOVEM A,(P)
MDDDI2:	UNLOCK DIRLCK
	OKINT
	POP P,A
	JRST SETDIR

; Multiple directory device name lookup routine
; Call:	A	; Lookup pointer
;	DIRORG-	; The correct subdirectory, locked and psi off
;	JRST MDDNAM
; Return
;	+1	; Match is impossible
;	+2	; Ambiguous
;	+3	; Success, if nrec&nrec1 are 0, the remainder if any
;		; Is appended to the string addressed by filopt(jfn)

^MDDNAM:JUMPE A,MDDSTP
	MOVEI B,0
	PUSHJ P,LOOKUP
	JRST NAMFND
	TEST(NE,STEPF)
	TEST(NN,NAMSF)
	JRST NAMLK9
	AOS B,DIRLOC		; Location in symtab of next after match
MDDSN1:	MOVE C,DIRORG(B)	; Get the entry
	TRNN C,700000		; Not name?
	CAML B,SYMTOP		; Or still in symtab?
	JRST [	MOVEI A,GJFX18
		JRST ERRET]	; None left
	HLRZS C
	; Pointer to name string
	MOVEI A,DIRORG+1(C)
	HRLI A,(<POINT 7,0>)
	JRST UNIQL1		; Copy new name to filopt

NAMLK9:	MOVE B,DIRLOC
	ADDI B,DIRORG
	HRRZ A,(B)
	ANDCMI A,700000		; Mask off entry type bits
	ADDI A,DIRORG		; Convert to absolute address
NAMLKM:	TEST(NE,UNLKF)
	JRST SK2RET		; Do not unlock directory
	UNLOCK DIRLCK
	OKINT
	JRST SK2RET

USE

^SK2RET:AOS (P)
^SKPRET:AOS (P)
^CPOPJ:	POPJ P,			; Double skip return

USE	SWAPPC

MDDSTP:	MOVE B,SYMBOT		; Get bottom of symbol table
	MOVEM B,DIRLOC
	JRST MDDSN1

NAMFND:	TEST(NE,NREC,NREC1)	; Is recognition being performed
	JRST NEWNAM		; No. try to insert a new name
	MOVEI A,GJFX18
	TEST(NE,AMBGF)		; Ambiguous?
	JRST AMBRET		; Yes
	TEST(NN,MTCHF)		; Yes, did at least one string match?
	JRST ERRET		; Error return, no match possible
	AOS B			; Point b to following entry
	CAMGE B,SYMTOP		; If not above top,
	PUSHJ P,NAMCMM		; Compare strings
	JRST UNIQUE		; Only one string is superset
	JRST UNIQUE
	JFCL
	MOVEI A,GJFX18
	JRST AMBRET

USE

AMBRET:	TEST(NN,UNLKF)		; Ambiguity is downright failure if unlkf
	AOS (P)
ERRET:	UNLOCK DIRLCK
	OKINT
	POPJ P,

USE	SWAPPC

UNIQUE:	MOVE B,DIRLOC		; Location in symtab of matching entry
	HLRZ C,DIRORG(B)	; Matching string block origin
UNIQU1:	MOVE A,DIRINP		; Start of input string
	MOVNI A,(A)
	ADD A,FILOPT(JFN)	; End of input relative to beginning
	ADDI A,DIRORG+1(C)	; Start of tail
	LDB C,A
	DPB C,FILOPT(JFN)
UNIQL1:	ILDB C,A		; Copy tail to input string
	JUMPE C,[MOVE A,FILOPT(JFN)
		IDPB C,A
		JRST NAMLK9]	; Terminate with null
	IDPB C,FILOPT(JFN)
	JRST UNIQL1

NEWNAM:	MOVE A,DIRINP
	TLNN A,-1
	SKIPE DIRMSK
	JRST .+3
	MOVEI A,GJFX33
	JRST ERRET		; Null names not allowed
	MOVEI A,GJFX24
	TEST(NE,OLDNF)		; Are new names ok?
	JRST ERRET		; No new names, error return
	MOVSI A,RNDF
	PUSHJ P,DIRCHK		; Does this user have append access
	JRST [	MOVEI A,GJFX24
		JRST ERRET]
	MOVE A,SYMBOT
	ADDI A,2
	CAMG A,FRETOP		; Room to expand symtab?
	 JRST [	PUSHJ P,XPAND	; No, attempt to expand it
		 JRST [	MOVEI A,GJFX23
			JRST ERRET]; No room
		JRST .+1]
	TEST(O,NEWF)		; Remember we entered a new file name
	MOVEI B,FDBLEN
	PUSHJ P,ASGDFR		; Assign space for fdb
	JRST [	MOVEI A,GJFX23
		JRST ERRET]
	PUSH P,SYMBOT		; Save current symbol table bottom
	PUSHJ P,FDBINI		; Initialize fdb
	POP P,B			; Get old bottom
	MOVNS B
	ADD B,SYMBOT		; Get amount of change during fdbini
	ADDM B,DIRLOC		; Adjust dirloc
	MOVSI B,FDBNEX!FDBNXF
	IORM B,1(A)		; Set "no extension" flag in fdb
	PUSH P,A		; Save loc of fdb
	PUSHJ P,CPYDIR		; Copy the input string into directory
	JRST [	POP P,B
		PUSHJ P,RELDFR
		MOVEI A,GJFX23
		JRST ERRET]
	MOVEI C,400001
	HRLM C,(A)		; Mark as string block for name
	POP P,C			; Get fdb location
	SUBI A,DIRORG
	HRRM A,FDBCTL(C)	; Store location of name string in fdb
	SUBI C,DIRORG		; Relative to directory origin
	HRL C,A			; Put string block loc in lh
	SOS B,DIRLOC		; Restore sym tab location
	SOS A,SYMBOT		; Move bottom of symbol table down
	ADDI A,DIRORG
	HRLI A,1(A)
	CAIL B,-DIRORG+1(A)
	BLT A,DIRORG-1(B)	; Blt lower part of symtab down
	MOVEM C,DIRORG(B)	; Insert symtab pointer in symtab
	JRST NAMLK9

; Multiple directory device extension lookup
; Call:	A	; Lookup pointer
;	B	; Pointer to start pointer (as left by mddnam)
;	JRST MDDEXT
; Return
;	+1	; No match
;	+2	; Ambiguous
;	+3	; Ok, the remaining string is appended to filopt(jfn)

^MDDEXT:JUMPE A,MDDSTE		; Set to first extension
	HRRZM B,DIRSCN		; Save loc of pointer
	PUSHJ P,SETMSK		; Set up mask etc
	MOVE A,DIRSCN		; Save location of pointer
	MOVEM A,DIRLOC
	HRRZ A,@DIRSCN		; Get loc of first fdb
	ADDI A,DIRORG		; As absolute address
	MOVE B,FDBCTL(A)	; Get flags
	TLNE B,FDBNEX		; Is this fdb simply holding a place
				; Because no extension is known?
	JRST NEWEXT		; Yes, then fill in extension
EXTLK1:	HLRZ B,FDBEXT(A)	; Get pointer to extension block
	ADDI B,DIRORG+1		; As absolute address
	MOVN C,-1(B)		; Get length of block
	HRLI B,2(C)		; Account for header and partial word
	MOVE A,DIRINP		; Get pointer to input
	MOVE C,DIRMSK		; And mask
	PUSHJ P,STRCMP		; Compare strings
	JRST EXTNEQ		; Not equal
	JRST EXTNEQ		; Not equal
	JRST EXTSUB		; Substring
	TEST(NE,STEPF)
	TEST(NN,EXTSF)
	JRST EXTLKL
	MOVE B,DIRSCN		; Get loc of pointer
	HRRZ B,(B)		; Location of fdb
	MOVEI B,DIRORG+FDBEXT(B); Location of pointer to next fdb
MDDSTE:	MOVEM B,DIRSCN
	MOVEM B,DIRLOC
	HRRZ A,(B)
	JUMPE A,[MOVEI A,GJFX19
		JRST ERRET]	; None left
	MOVE C,FDBCTL+DIRORG(A)
	TLNE C,FDBNEX
	JRST [	MOVEI A,GJFX19
		JRST ERRET]	; Non-existent
	HLRZ A,FDBEXT+DIRORG(A)	; Location of extension string
	ADDI A,DIRORG+1
	MOVNI B,DIRORG
	ADDM B,DIRLOC
	HRLI A,(<POINT 7,0>)
	JRST UNIQL1

EXTLKL:	MOVE B,DIRSCN		; Exact match. get loc of pointer
	HRRZ A,(B)
	ADDI A,DIRORG		; And loc of fdb
	MOVE C,FDBCTL(A)
	TLNE C,FDBTMP		; File already temp?
	TEST(O,TMPFF)		; Yes, set tmpff
	JRST NAMLKM		; Double skip return & unlock directory

EXTSUB:	TEST(NE,NREC,NREC1)
	JRST EXTNEQ
	MOVE A,DIRSCN
	MOVEM A,DIRLOC		; Save location of pointer to match fdb
	MOVEI A,GJFX19
	TEST(OE,MTCHF)		; Set mtchf, was it already set?
	JRST AMBRET		; Yes,  ambiguous return
EXTNEQ:	HRRZ B,@DIRSCN		; Get loc of next fdb
	ADDI B,DIRORG+FDBEXT
	MOVEM B,DIRSCN
	HRRZ A,(B)		; Get loc of next fdb
	JUMPN A,[ADDI A,DIRORG
		JRST EXTLK1]
	TEST(NE,NREC,NREC1)
	JRST NEWEX1		; New extension
	MOVEI A,GJFX19
	TEST(NN,MTCHF)
	JRST ERRET
	HRRZ B,@DIRLOC		; Get pointer to fdb
	MOVE C,FDBCTL+DIRORG(B)
	TLNE C,FDBTMP
	TEST(O,TMPFF)
	MOVNI C,DIRORG
	ADDM C,DIRLOC
	HLRZ C,FDBEXT+DIRORG(B)	; Get pointer to extension block
	JRST UNIQU1		; And copy tail to input

NEWEX1:	MOVEI A,GJFX24
	TEST(NE,OLDNF)		; Are new files allowed?
	JRST ERRET
	MOVSI A,RNDF
	PUSHJ P,DIRCHK		; Append access ok?
	JRST [	MOVEI A,GJFX24
		JRST ERRET]
	MOVEI B,FDBLEN
	PUSHJ P,ASGDFR		; Get space for new fdb
	JRST [	MOVEI A,GJFX23
		JRST ERRET]
	PUSH P,SYMBOT
	PUSHJ P,FDBINI		; Initialize the fdb
	POP P,B
	MOVNS B
	ADD B,SYMBOT
	ADDM B,DIRLOC
	MOVE B,@DIRLOC		; Location of fdb with correct name
	HRRZ C,FDBCTL+DIRORG(B)
	HRRM C,FDBCTL(A)	; Move name pointer to new fdb
	PUSH P,A		; Save fdb location
	PUSHJ P,CPYDIR		; Copy extension string to directory
	JRST [	POP P,B
		PUSHJ P,RELDFR
		MOVEI A,GJFX23
		JRST ERRET]
	MOVEI C,400002
	HRLM C,(A)		; Mark as string block for extension
	EXCH A,(P)
	MOVE C,DIRSCN		; Location of last extension pointer
	SUBI A,DIRORG		; Convert pointer to fdb to relative
	HRRZ B,(C)
	HRRM A,(C)		; Point last to this
	HRRM B,DIRORG+FDBEXT(A)	; Point this to next
	POP P,A
	JRST NEWEX2
	
NEWEXT:	TEST(NN,NREC,NREC1)
	JRST [	MOVEI A,GJFX19
		JRST ERRET]	; Recognition wanted
	TEST(NE,OLDNF)
	JRST [	MOVEI A,GJFX24
		JRST ERRET]	; No new files
	PUSH P,A
	PUSHJ P,CPYDIR		; Copy string block into directory
	JRST [	MOVEI A,GJFX23
		JRST ERRET]
	MOVEI C,400002
	HRLM C,(A)		; Mark as string block for extension
	MOVSI B,FDBNEX
	POP P,C
	ANDCAM B,FDBCTL(C)	; No longer no extension
NEWEX2:	HRRZ B,@DIRSCN
	ADDI B,DIRORG
	SUBI A,DIRORG
	HRLM A,FDBEXT(B)	; Save in extension
	TEST(O,NEWF)		; Remember this is a new file
	MOVE B,DIRSCN
	HRRZ A,(B)
	ADDI A,DIRORG
	JRST NAMLKM		; Double skip return


; Multiple directory device version lookup routine
; Call:	A	; Desired version
;	DIRORG-	; The appropriate directory locked and psi off
;	JRST MDDVER
; Return
;	+1	; Version not found
;	+2	; Success version in a if unlkf=1
;		; Fdb address in a if unlkf=0

^MDDVER:HRRES A			; Extend sign
	MOVEM A,DIRINP
	MOVEM B,DIRLOC
	HRRZ D,@B
	CAMN A,[-2]
	MOVEM D,DIRLOC
	HLRZ C,DIRORG+FDBVER(D)
	JUMPE C,VERLK7		; This is first version of this file
VERLK0:	MOVEM B,DIRSCN		; Save scan pointer
	ADDI D,DIRORG		; Convert to absolute address
	MOVE C,FDBCTL(D)	; Get flag word
VERLKA:	TLNE C,FDBTMP		; If we ever see a temp version
	TEST(O,TMPFF)		; Consider this as temporary also
	JUMPG A,VERLK1		; Specific version wanted
	CAMN A,[-2]
	JRST VERLKC
	JUMPL A,VERLK2		; New version wanted
	TLNE C,FDBDEL
	TEST(NE,IGDLF)
	TLNE C,FDBNXF		; Does this version exist yet?
	JRST VERLK1		; Go to next one
VERLK3:	MOVE A,D		; Found
VERLK8:	TEST(NE,NEWVF,NEWF)
	JRST VERLKB
	TEST(NE,NEWNF)
	JRST [	MOVEI A,GJFX27
		JRST ERRET]
VERLKB:	TEST(NE,STEPF)
	TEST(NN,VERSF)
	JRST VERLKE
	SKIPN DIRINP
	JRST VERLKE
VERLKF:	HRRZ B,FDBVER(A)	; Location of fdb of next version
	MOVEI A,GJFX20
	JUMPE B,ERRET		; No more versions
	MOVEI A,DIRORG(B)
	MOVE B,FDBCTL(A)
	TEST(NN,IGDLF)
	TLNN B,FDBNXF
	TLNE B,FDBNEX
	JRST VERLKF
VERLKE:	TEST(NE,UNLKF)
	JRST SKPRET		; Return without unlocking directory
	HLRZ A,FDBVER(A)
	UNLOCK DIRLCK
	OKINT
	JRST SKPRET

VERLK7:	SKIPG A
	MOVEI A,1		; However it can be most recent+1
	HRLM A,DIRORG+FDBVER(D)	; Or specific version
	MOVEI A,DIRORG(D)
	JRST VERLK8

VERLK2:	TEST(O,NEWVF)
	TEST(Z,NEWF)
	TLNE C,FDBNXF		; Want next newer version
	TLNE C,FDBDEL		; If this version is deleted or
	JRST .+2		; In existence, then create a new one
	JRST VERLK3		; Otherwise, this one is the one
VERLK6:	MOVEI A,GJFX24
	TEST(NE,OLDNF)
	JRST ERRET		; Old files only
	MOVSI A,RNDF
	PUSHJ P,DIRCHK		; Check for append access to directory
	JRST [	MOVEI A,GJFX24
		JRST ERRET]
	MOVEI B,FDBLEN
	PUSHJ P,ASGDFR		; Assign space for a new fdb
	JRST [	MOVEI A,GJFX23
		JRST ERRET]
	PUSH P,SYMBOT
	PUSHJ P,FDBINI		; Initialize the fdb
	POP P,B
	MOVNS B
	ADD B,SYMBOT
	ADDM B,DIRLOC
	MOVE C,DIRSCN
	SUBI C,DIRORG
	CAML C,SYMBOT
	ADDM B,DIRSCN
	HRRZ C,@DIRLOC
	ADDI C,DIRORG
	FOR @' VAR IN (CTL,EXT,CRE)<
	MOVE D,FDB'VAR(C)
	IFIDN <VAR>,<CTL>,<TLZ D,FDBDEL!FDBLNG
	TLO D,FDBNXF>
	MOVEM D,FDB'VAR(A)>	; Copy things from previous versions
	SOSGE D,DIRINP		; Was specific version given?
	HLRZ D,FDBVER(C)	; No, get previous version number
	AOS D			; Increment
	HRLM D,FDBVER(A)	; And store in new fdb
	SUBI A,DIRORG
	HRRZ B,@DIRSCN
	HRRM A,@DIRSCN		; Point predecessor to new fdb
	ADDI A,DIRORG
	HRRM B,FDBVER(A)
	MOVE B,DIRSCN
	TEST(O,NEWVF)		; Remember we created a new version
	JRST VERLK8

VERLKC:	TLNE C,FDBDEL
	TEST(NE,IGDLF)
	TLNE C,FDBNXF
	JRST VERLK1
	MOVEI C,-DIRORG(D)	; GET RELATIVE LOCATION
	MOVEM C,DIRLOC		; SAVE FOR LATER
VERLK1:	HLRZ C,FDBVER(D)	; Get version number of this fdb
	CAMG C,A		; Below desired version?
	JRST VERLK5		; Yes, we have found where it belongs
	HRRZ B,@DIRSCN		; Step to next fdb
	ADDI B,FDBVER+DIRORG
	HRRZ D,@B
	JUMPN D,VERLK0		; Continue search
	JUMPE A,[MOVEI A,GJFX20
		JRST ERRET]	; Not found, can't create most recent
	CAMN A,[-2]
	JRST VERLKD
	HRRZ C,@DIRSCN
	ADDI C,DIRORG
	MOVEM B,DIRSCN
	JRST VERLK6		; Insert new version here
	JRST VERLK0		; And loop

VERLKD:	TEST(Z,NEWF,NEWVF)
	MOVEI A,GJFX20
	MOVE D,DIRLOC
	MOVE C,FDBCTL+DIRORG(D)
	TLNE C,FDBDEL
	TEST(NE,IGDLF)
	TLNE C,FDBNXF
	JRST ERRET
	MOVEI A,DIRORG(D)
	JRST VERLK8

VERLK5:	CAME C,A		; Exactly the right one?
	JRST VERLK6		; Insert a new one
	MOVE B,DIRSCN
	HRRZ A,(B)
	ADDI A,DIRORG
	HLLZ C,FDBCTL(A)	; Get flags from fdb
	TLNE C,FDBDEL
	TEST(NE,OUTPF,IGDLF)
	JRST .+3
	MOVEI A,GJFX20
	JRST ERRET
	TEST(NE,OUTPF)
	TLZ C,FDBDEL
	HLLM C,FDBCTL(A)
	TLNE C,FDBNXF		; Does the file exist?
	TEST(O,NEWVF)
	JRST VERLK8		; Found

; Lookup of string in a directory
; Call:	A	; Lookup pointer
;	B	; Entry type
;	PUSHJ P,LOOKUP
; Return
;	+1	; No exact match found
;	+2	; Exact match found

LOOKUP:	PUSH P,B		; Save entry type
	PUSHJ P,SETMSK		; Set up input pointer and mask
	MOVE A,SYMTOP
	SUB A,SYMBOT		; Get length of symbol table
	JFFO A,.+2		; Get top 1 bit
	MOVEI A+1,=35
	MOVNS A+1
	MOVSI A,400000
	LSH A,(A+1)		; Largest power of 2 <= length
	MOVE B,SYMBOT
	SOS B			; Start just below symbol table
MOVUP:	JUMPE A,STRFND		; And move up
	ADD B,A
	ASH A,-1		; Halve increment
	CAMGE B,SYMTOP		; Too big?
	JRST SYMCMP		; No, compare strings
MOVDN:	JUMPE A,STRFDD
	SUB B,A
	ASH A,-1
	CAML B,SYMTOP
	JRST MOVDN
	CAMGE B,SYMBOT
	BUG(HLT,<LOOKUP: SYMBOL SEARCH FOULED UP.>)

SYMCMP:	MOVEM A,DIRINC		; Save increment
	MOVEM B,DIRLOC		; And symtab loc
	MOVE A,(P)
	PUSHJ P,NAMCM1
	JRST [	MOVE B,DIRLOC	; A<b
		MOVE A,DIRINC
		JRST MOVDN]
	JRST [	MOVE B,DIRLOC	; A>b
		MOVE A,DIRINC
		JRST MOVUP]
	JRST [	TEST(OE,MTCHF)	; A<b and subset
		TEST(O,AMBGF)
		MOVE B,DIRLOC
		MOVE A,DIRINC
		JRST MOVDN]
	POP P,A
	JRST SKPRET

STRFND:	AOS B
STRFDD:	MOVEM B,DIRLOC
	SUB P,[XWD 1,1]
	POPJ P,

NAMCMM:	MOVEI A,0
NAMCM1:	HRRZ C,DIRORG(B)	; Get entry type
	ANDI C,700000		; Extract entry type
	CAMGE C,A		; Less than that being sought?
	JRST SKPRET		; Yes.
	CAMLE C,A		; Greater than entry type being sought?
	POPJ P,
	HLRZ A,DIRORG(B)	; Get loc of string block for this entry
	MOVN B,DIRORG(A)	; Get length of string block
	CAIGE C,100000
	JRST SYMCM1
	AOS A			; For entries greater than 0, there
	AOS B			; Is a share count which must be ignored
SYMCM1:	HRLZI B,2(B)		; To lh of b
	HRRI B,DIRORG+1(A)	; Rh  in absolute address
	MOVE A,DIRINP		; Set up pointer to input string
	MOVE C,DIRMSK		; Set up mask
	JRST STRCMP		; And continue with string compare

; Setup mask and input pointer for directory looks
; Call:	A	; Lookup pointer
;	PUSHJ P,SETMSK
; Return
;	+1	; In dirinp, a string compare pointer to input
; In dirmsk, a mask of ones for masking last word of input string
; Clobbers a,b,c,d

^SETMSK:HLRE D,A		; Get size of the string block
	SUBM A,D		; Get loc of last full word
	MOVSI B,774000		; 7 bit mask left justified
	MOVNI C,1		; Mask of bits to ignore
SETMS0:	TDNN B,1(D)		; Look for the terminating null
	JRST SETMS1		; There it is, c has 1's for ignoration
	LSH B,-7		; Not there, shift to next bit
	LSH C,-7
	JRST SETMS0

SETMS1:	SETCAM C,DIRMSK		; Get mask of bits to test in last word
	AOS A
	MOVEM A,DIRINP		; Save input pointer
	POPJ P,

	BENDP	DIRECT

; Copy the dirinp string to a new string block in directory
; Call:	DIRINP		; The input pointer
;	PUSHJ P,CPYDIR
; Return
;	+1	; No room
;	+2	; Ok, in a, the location of the string block
; Clobbers a,b,c,d

CPYDIR:	HLRE A,DIRINP		; Get length of input
	MOVN B,A		; Make positive and account
	ADDI B,2		;  for header and partial word
	PUSH P,B		; Save for below
	PUSHJ P,ASGDFR		; Assign space for name string
	JRST [	POP P,B		; No room
		POPJ P,]
	HRLZ B,DIRINP		; Get loc of input string block
	HRRI B,1(A)		; And string block in directory
	POP P,D			; Length of block
	ADDI D,-2(B)		; Points to last word of new string
	BLT B,(D)		; Copy string into directory
	MOVE C,DIRMSK		; Get mask
	ANDM C,(D)		; Zero low part of last word of string
	AOS (P)
	POPJ P,

; Expand symbol table region of a directory
; Call:	PUSHJ P,XPAND

XPAND:	PUSHJ P,GCDIR		; First garbage collect directory
	PUSH P,A
	HLRZ A,DIRFRE		; Get location of the free block
	JUMPE A,XPAND1		; No room
	PUSH P,B
	HRRZ B,DIRORG(A)	; Get size of the free block
	PUSH P,B
	CAILE B,40		; If greater than 40 words
	SUBI B,10		; Reduce size by 10
	SUBI B,1		; Reduce by 1 more anyway
	HRRM B,DIRORG(A)
	SKIPN B			; If zero size,
	HRRZS DIRFRE		; Then no free blocks left
	POP P,A			; Get former block size
	MOVNI A,(A)
	ADD A,B			; Yields -delta
	ADDM A,FRETOP		; Modify top pointer
	POP P,A
	AOS (P)
	POPJ P,

XPAND1:	POP P,A
	POPJ P,

; String compare routine
; Call:	LH(A)		; Minus number of full words in string 1
;	RH(A)		; Loc of first word of string
;	LH(B)		; Minus number of full words in string 2
;	RH(B)		; Loc of first word of string
;	C		; A mask of 1's for last word of string1
;	PUSHJ P,STRCMP
; Return
;	+1	; A < b
;	+2	; A > b
;	+3	; A = initial subset of b
;	+4	; A = b
; Clobbers a,b,c,d

STRCMP:	PUSH P,C
STRCM0:	JUMPGE A,STRCM1		; Down to last word of string a
	JCRY0 .+1		; Cleap carry 0
	MOVE D,(B)		; Get word of string b
	MOVE C,(A)		; And word of string a

	ANDCMI C,1		; Get rid of superfluous bits 35

	ANDCMI D,1
	SUB D,C			; Compare the words
	JUMPE D,STRCM2		; Equal, step to next word
	JCRY0 .+2		; A < b
STRCM3:	AOS -1(P)		; A > b
	POP P,C
	POPJ P,

STRCM2:	JUMPGE B,STRCM3		; Is b gone?
	AOBJN A,.+1		; No, step to next word
	AOBJN B,STRCM0
	JRST STRCM0

STRCM1:	POP P,C
	MOVE D,(A)		; Get last word of string a
	AND D,C			; Get rid of garbage
	SKIPL B			; If string b is also down to last word,
	CAME D,(B)		; Check for exact match
	JRST STRCM4		; Not exact match
	MOVEI D,3		; Exact match
	ADDM D,(P)		; Triple skip
	POPJ P,

STRCM4:	AND C,(B)		; Truncate string b to same length as a
	JCRY0 .+1		; Clear carry 0
	SUB C,D			; Compare a to truncated b
	JUMPE C,SK2RET		; Equal, subset
	JCRY0 CPOPJ		; A < b
	JRST SKPRET		; A > b

; Copy string from user to a free area in the jsb
; Call:	A	; String pointer
;	PUSHJ P,CPYFUS
; Return
;	+1	; No room
;	+2	; Ok
;	A	; Lookup pointer

CPYFUS:	PUSH P,A
	MOVEI A,JSBFRE
	MOVEI B,MAXLW+1
	NOINT
	PUSHJ P,ASGFRE
	JRST [	POP P,A
		POPJ P,]
	POP P,B
CPYFU1:	MOVEI C,MAXLC		; Enter here when storage isnt needed
	PUSH P,A
	EXCH A,B
	HRLI B,(<POINT 7,0,35>)
	JUMPGE A,CPYUS1
	CAML A,[777777000000]
	HRLI A,(<POINT 7,0>)
CPYUS1:	XCTMU [ILDB D,A]
	SOSG C
	MOVEI D,0		; After maxlc chars, force null
	JUMPE D,CPYUS2
	IDPB D,B
	JRST CPYUS1

CPYUS2:	MOVE A,(P)
	MOVEM B,(P)
	IDPB D,B
	HRL B,A			; Location to lh of a
	SUB A,B			; Compute number of full words
	HRRI B,1(A)
	MOVS A,B		; Is now a lookup pointer
	POP P,B
	JRST SKPRET

	BEGINP	IO		R.S.Tomlinson	19 November 1971	1612:

USE SWAPPC

INTERN	.PBIN,.PBOUT,.BIN,.BOUT,.SIN,.SOUT,.RIN,.ROUT,.DUMPI,.DUMPO
INTERN	.PSIN,.PSOUT,BIN1

DEFINE	NIY'(X)<
^.'X:	JSYS MENTR
	JSP NIYET
	ASCIZ \X\>

FOR A IN (PSIN),<
NIY(A)>

DEFINE	FILINT(N,EXTRA)<
PUSHJ P,[EXTRA
	MOVEI A,N
	JRST DOINT]>

DEFINE	FILABT(N,EXTRA)<
JRST [	EXTRA
	MOVEI A,N
	JRST ABTDO]>

DOINT:	MOVEM JFN,ERRSAV
	PUSHJ P,UNLCKF
	MOVEM A,LSTERR
	TEST(NE,HLTF)
	JRST ITRAP		; Halt on these conditions
	MOVEI 1,400000
	MOVSI 2,(1B11)
	IIC
	POPJ P,

ABTDO:	MOVEM A,LSTERR
	PUSHJ P,UNLCKF
	JRST ITRAP

; Check tenex source/destination designator
; Call:	JFN		; The designator
;	PUSHJ P,CHKJFN
; Return
;	+1	; Error, as has error #
;	+2	; Tty
;	+3	; Byte pointer
;	+4	; File
; In all cases, the following is set up
;	LH(DEV)	; Unit number (tty no dta no etc)
;	RH(DEV)	; Loc of device dispatch table
;	JFN	; True jfn for files, byte pointer for same
;	STS	; File status bits
; The file is locked if it is a file


^CHKJFN:SETZB F,F1
	TLNE JFN,777777		; Lh zero?
	JRST CHKJF1		; No, some kind of byte pointer
	CAIN JFN,100		; Primary input designator?
	HLRZ JFN,PRIMRY		; Get primary input jfn from psb
	CAIN JFN,101		; Primary output designator?
	HRRZ JFN,PRIMRY		; Get primary output jfn from psb
	CAIGE JFN,NJFN		; True jfn?
	JRST CHKJF3		; Yes
	CAIN JFN,777777		; Controlling tty
	JRST CHKJF4		; Yes
	CAIGE JFN,400000+NLINES	; Valid tty designator?
	CAIGE JFN,400000
	JRST CHKJF7		; No, garbage designator
	HLRZ DEV,TTFORK-400000(JFN)	; Get assignment of tty
	CAIE DEV,777777		; Unattached?
	CAMN DEV,JOBNO		; Or assigned to this job?
	JRST CHKJF5		; Yes, ok to use
	MOVE A,CAPENB
	TRNE A,WHEEL!OPR
	JRST CHKJF5
	MOVEI A,DESX2		; Illegal tty designator
	POPJ P,

CHKJF4:	MOVE A,JOBNO
	MOVEI A,JOBPT(A)
	SKIPGE DEV,(A)
	PUSHJ P,DISGE		; Dismiss until it is greater or equal
	SKIPGE DEV,(A)
	JRST CHKJF4
	HLRZS DEV
	MOVEI JFN,400000(DEV)
CHKJF5:	MOVEI DEV,TTYDTB	; Set up dev to be tty
	HRLI DEV,-400000(JFN)	; And the proper unit
	HRLZI STS,READF!WRTF!OPENF
	JRST SKPRET		; Skip return

CHKJF3:	MOVEI A,=60		; Try 60 times t_ lock file
CHKJF2:	SOJL A,CHKJFB		; Then fail
	NOINT
	AOSE FILLCK(JFN)
	 JRST [	OKINT
		MOVEI A,=1000
		DISMS
		JRST CHKJF2]
	MOVE STS,FILSTS(JFN)
	TEST(NN,NAMEF)
	JRST CHKJF8
	TEST(NN,FRKF)		; Test for file restricted to one fork
	JRST CHKJF9
	HLRZ A,FILVER(JFN)
	PUSHJ P,SKIIF
	JRST CHKJF8		; Can't access
CHKJF9:	MOVE DEV,FILDEV(JFN)	; Set up dev
	HRRZ A,DEV
	CAIN A,TTYDTB
	 JRST [	SETOM FILLCK(JFN)
		OKINT
		JRST .+1]
	AOS (P)
	JRST SK2RET		; Triple skip return

CHKJF8:	UNLOCK FILLCK(JFN)
CHKJFB:	MOVEI A,DESX3
	POPJ P,

CHKJF1:	JUMPGE JFN,CHKJF6
	CAML JFN,[777777000000]
	HRLI JFN,440700		; Insert if lh = 777777
	CAMGE JFN,[444500000000]
	JRST CHKJF6
CHKJF7:	MOVEI A,DESX1		; Garbage designator
	POPJ P,

CHKJF6:	MOVEI DEV,STRDEV	; Set up to dispatch to string routines
	HRLZI STS,READF!WRTF!OPENF
	JRST SK2RET		; Double skip return

; Unlock file
; Call:	JFN	; Job file number
;	PUSHJ P,UNLCKF

^UNLCKF:TLNE JFN,777777
	UMOVEM JFN,1
	CAIL JFN,0
	CAIL JFN,NJFN
	POPJ P,
	HLLM STS,FILSTS(JFN)
	PUSH P,A
	MOVEI A,(DEV)
	CAIN A,TTYDTB
	 JRST [	POP P,A
		POPJ P,]
	POP P,A
	SETOM FILLCK(JFN)
	OKINT
	POPJ P,

NOTOPN:	FILABT CLSX1

^IOERR:	MOVEM A,LSTERR
	JRST ITRAP

; Bin from primary io file
; Call:	1	; Character
;	PBIN

^.PBIN:	JSYS MENTR
	HLRZ JFN,PRIMRY
	PUSHJ P,BYTIN
	UMOVEM B,1
	JRST MRETN

; Byte input jsys
; Call:	1	; Tenex source designator
;	BIN
; Return
;	+1
;	B	; A byte

PS(BIOAC0)

^.BIN:	NOINT
	JUMPL 1,SLBIN
	CAIGE 1,NJFN
	AOSE FILLCK(1)
	JRST SLBIN
	MOVE 2,FILSTS(1)
	TLC 2,OPENF!READF
	TLCN 2,OPENF!READF
	TLNE 2,ERRF!FRKF
	JRST SLBIN1
	SOSGE FILCNT(1)
	JRST SLBIN2
	AOS 2,FILBYN(1)
	CAMLE 2,FILLEN(1)
	JRST SLBIN3
	ILDB 2,FILBYT(1)
	SETOM FILLCK(1)
	OKINT
	XCT MJRSTF

SLBIN3:	SOS FILBYN(1)
SLBIN2:	AOS FILCNT(1)
SLBIN1:	SETOM FILLCK(1)
SLBIN:	OKINT
	JSYS MENTR		; Become slow etc.
	MOVE JFN,1
	PUSHJ P,BYTIN		; Read the byte
	XCTUU [MOVEM B,2]	; Store in user's ac
	JRST MRETN		; Restore user ac's and return

; Random input jsys
; Call:	1	; Tenex source designator
;	3	; Byte number
;	RIN
; Returns
;	+1
;	2	; The byte

^.RIN:	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST IOERR
	JFCL
	FILABT DESX4		; Tty and byte designators are illegal
	TEST(NN,RNDF)
	FILABT IOX3		; Illegal to change pointer
	TEST(NN,READF)
	FILABT IOX1		; Illegal to read
	UMOVE A,3
	PUSHJ P,SFBNR		; Set up byte pointer
	JRST ABTDO
	PUSHJ P,BYTINA		; Get the byte
	UMOVEM B,2
	JRST MRETN

; String input jsys
; Call:	1	; Tenex source designator
;	2	; Byte pointer (lh = 777777 will be filled in)
;	3	; Byte count or zero
;		; If zero, the a zero byte terminates
;		; If positive then transfer the specified number
;		; Of characters, or terminate on reading a byte
;		; Equal to that given in 4
;		; If negative, then transfer the specified number
;		; Of bytes
;	4	; (optional) if 3 is > 0, 4 has a terminating byte
;	SIN
; Return
;	+1	; Always
;	2	; Updated string pointer
;	3	; Updated count (always counts toward zero)
; The updated string pointer always points to the last byte read
; Unless 3 contained zero, then it points to the last non-zero byte.

^.SIN:	JSYS MENTR		; Become slow etc.
	HRLZI C,440700
	JUMPG 2,SIN0
	CAML 2,[777777000000]
	XCTUU [HLLM C,2]
SIN0:	UMOVE JFN,1
	PUSHJ P,BYTIN		; Read a byte from the source
	JUMPE B,[TEST(NN,EOFF)
		XCTUU [SKIPN 3]
		JRST SIN2
		JRST .+1]
	XCTUU [IDPB B,2]	; Deposit the byte
	JSP A,SIONXT		; Test for end of string
	JRST SIN0		; Not end, continue

SIN2:	UMOVE A,2
	XCTMU [IDPB B,A]
	JRST MRETN

; Check for end of string io string
; Call:	B	; Character just transfered
; User	3	; Sin/sout argument
; User	4	; Sin/sout argument
;	JSP A,SIONXT
; Return
;	+1	; Continue
;	MRETN	; If no more left to do
; Updates user 3

SIONXT:	TLNE JFN,777777		; If byte pointer,
	UMOVEM JFN,1		; Restore updated jfn
	XCTUU [SKIPN C,3]
	JRST (A)
SIO1:	JUMPG C,SIO2		; Positive
	XCTUU [AOSGE 3]
	JRST (A)
	JRST MRETN

SIO2:	XCTUU [SOSLE 3]
	XCTUU [CAMN B,4]
	JRST MRETN
	JRST (A)

; Byte input subroutine
; Call:	1	; Source designator
;	PUSHJ P,BYTIN
; Return
;	+1	; Ok
;	B	; A byte
; Clobbers most everything

^BYTIN:	PUSHJ P,CHKJFN		; Check the designator
	JRST IOERR		; Bad designator 
	JFCL			; Tty
	JFCL			; Byte pointer
BYTINA:	JUMPGE STS,NOTOPN
	TEST(NN,READF)
	FILABT IOX1		; Illegal read
	TEST(NE,ERRF)
	FILINT(IOX5)		; Generate data error interrupt
	TEST(NE,EOFF)
	JRST INEOF
	PUSHJ P,@BIND(DEV)	; Dispatch to device dependent code
	TEST(NE,ERRF)
	FILINT(IOX5)
	TEST(NE,EOFF)
	JRST INEOF
	MOVE B,A
	JUMPN B,UNLCKF
	CAIL JFN,0
	CAIL JFN,NJFN
	JRST UNLCKF		; Don't flush nulls except for files
	LDB A,PBYTSZ
	TRNN STS,17
	CAIE A,7
	JRST UNLCKF
	PUSHJ P,UNLCKF		; Flush nulls if normal 7-bit mode
	JRST BYTIN

INEOF:	MOVEI A,IOX4
	MOVEM A,LSTERR
	MOVEM JFN,ERRSAV
	MOVEI 1,400000
	MOVSI 2,(1B10)
	IIC			; Initiate interrupt on channel 10
	MOVEI B,0
	JRST UNLCKF

; Output to primary output file
; Call:	1	BYTE
;	PBOUT

^.PBOUT:JSYS MENTR
	HRRZ JFN,PRIMRY
	UMOVE B,1
	PUSHJ P,BYTOUT
	JRST MRETN

; Byte output
; Call:	1	; Tenex destination designator
;	2	; A byte
;	BOUT

^.BOUT:	NOINT
	JUMPL 1,SLBOU
	CAIGE 1,NJFN
	AOSE FILLCK(1)
	JRST SLBOU
	MOVEM C,BIOAC0
	MOVE C,FILSTS(1)
	TLC C,OPENF!WRTF
	TLCN C,OPENF!WRTF
	TLNE C,FRKF!ERRF
	JRST SLBOU1
	SOSGE FILCNT(1)
	JRST SLBOU2
	AOS C,FILBYN(1)
	CAMLE C,FILLEN(1)
	MOVEM C,FILLEN(1)
	IDPB 2,FILBYT(1)
	MOVE C,BIOAC0
	SETOM FILLCK(1)
	OKINT
	XCT MJRSTF

SLBOU2:	AOS FILCNT(1)
SLBOU1:	MOVE C,BIOAC0
	SETOM FILLCK(1)
SLBOU:	OKINT
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,BYTOUT		; Output the byte
	JRST MRETN

; Random output jsys
; Call:	1	; Tenex source designator
;	2	; A byte
;	3	; Byte number
;	ROUT

^.ROUT:	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST IOERR
	JFCL
	FILABT DESX4		; Tty and byte designators are illegal
	JUMPGE STS,NOTOPN
	TEST(NN,RNDF)
	FILABT IOX3		; Illegal to change pointer
	TEST(NN,WRTF)
	FILABT IOX2		; Illegal write
	UMOVE A,3
	PUSHJ P,SFBNR
	JRST ABTDO
	UMOVE B,2
	PUSHJ P,BYTOUA
	JRST MRETN

; String output to primary io file
; Call:	1	; String pointer, designator, or location of string
;	PSOUT

^.PSOUT:JSYS MENTR
	TLNE 1,777777
	JUMPGE 1,PSOUT0
	HRLZI C,440700
	CAML 1,[777777000000]
	XCTUU [HLLM C,1]
PSOUT0:	XCTUU [ILDB B,1]
	JUMPE B,MRETN
	HRRZ JFN,PRIMRY
	PUSHJ P,BYTOUT
	JRST PSOUT0

; String output
; Call:	1	; Tenex source designator
;	2	; Byte pointer (lh = 777777 will be filled in)
;	3	; Byte count or zero
;		; If zero, the a zero byte terminates
;		; If positive then transfer the specified number
;		; Of characters, or terminate on reading a byte
;		; Equal to that given in 4
;		; If negative, then transfer the specified number
;		; Of bytes
;	4	; (optional) if 3 is > 0, 4 has a terminating byte
;	SOUT
; Return
;	+1	; Always
;	2	; Updated string pointer
;	3	; Updated count (always counts toward zero)
; The updated string pointer always points to the last byte read
; Unless 3 contained zero, then it points to the last non-zero byte.

^.SOUT:	JSYS MENTR		; Become slow etc
	JUMPGE 2,SOUT0
	HRLZI C,440700
	CAML 2,[777777000000]
	XCTUU [HLLM C,2]
SOUT0:	XCTUU [ILDB B,2]
	XCTUU [SKIPN 3]
	JUMPE B,MRETN		; Don't write zero bytes if arg3 = 0
	UMOVE JFN,1
	PUSH P,B
	PUSHJ P,BYTOUT
	POP P,B
	PUSHJ P,APPNUL
	JSP A,SIONXT
	JRST SOUT0

; Byte output subroutine
; Call:	1	; Source designator
;	PUSHJ P,BYTOUT
; Return
;	+1	; Ok
; Clobbers most everything

^BYTOUT:PUSHJ P,CHKJFN		; Check the designator
	JRST IOERR		; Bad designator 
	JFCL			; Tty
	JFCL			; Byte pooutter
^BYTOUA:JUMPGE STS,NOTOPN
	TEST(NN,WRTF)
	FILABT IOX2		; Illegal write
	TEST(NE,ENDF)
	FILABT(IOX6)		; Past abs end of file
	TEST(NE,ERRF)
	FILINT(IOX5)		; Error interrupt
	MOVE A,B
	PUSHJ P,@BOUTD(DEV)	; Dispatch to device dependent code
	JRST UNLCKF

; Append null to string output designator

^APPNUL:PUSH P,JFN
	PUSH P,C
	MOVEI C,0
	TLZ JFN,7700
	TLO JFN,700
	CAMN JFN,-1(P)
	XCTMU [IDPB C,JFN]
	POP P,C
	POP P,JFN
	POPJ P,

; Dump io
; Parameters and variables

NDUMP__10
LS(DMPASW)		; Dump buffer assignment word
LS(DMPCNT)		; Dump buffer free count
LS(DMPLCK)		; Dump buffer assignment lock
NRP(DMPBUF,NDUMP*1000)	; Dump buffers

; Initialize dump io

USE

^DMPINI:MOVEI A,NDUMP
	MOVEM A,DMPCNT
	SETOM DMPLCK
	SETCM A,[-1<=36-NDUMP>]
	MOVEM A,DMPASW
	POPJ P,

USE	SWAPPC

; Dump input
; Call:	1	; Jfn
;	2	; Pointer to first command
;	DUMPI
; Return
;	+1	; Error
;	+2	; Ok

^.DUMPI:JSYS MENTR
	PUSHJ P,DUMPC		; Call common dump code
	TEST(NN,READF)		; Executed to discover file access
	IOX1			; Error number for no read access
	PUSHJ P,@DMPID(DEV)	; Device dependent routine dispatch
	040400000000		; MEMORY ACCESS NEEDED

; Dump output
; Call:	1	; Jfn
;	2	; Pointer to first command
;	DUMPO
; Return
;	+1	; Error
;	+2	; Ok

^.DUMPO:JSYS MENTR
	PUSHJ P,DUMPC
	TEST(NN,WRTF)
	IOX2
	PUSHJ P,@DMPOD(DEV)
	100000000000		; MEMORY ACCESS NEEDED

; Dump common code

DMPSEB:	JUMPE B,[AOS -1(P)
		JRST MRETN]
	UMOVEM B,2
DUMPC:	UMOVE A,2		; Get command pointer
	UMOVE B,(A)		; And command
	JUMPGE B,DMPSEB		; Branch or disconnect
	PUSH P,B		; Save iowd
	HLRE A,B		; - word count
	MOVNS A			; Word count
	ADDI A,(B)		; Last address
	CAILE A,777777		; Must not cross end of memory
	JRST [	MOVEI A,DUMPX3	; Error if happens
		JRST ERRD]
	MOVEI B,1(B)		; First address
	LSH A,-9		; Last page number
	LSH B,-9		; First page number
	SUBM B,A
	SOS A			; -# pages
	CAMGE A,[-NDUMP]
	JRST [	MOVEI A,DUMPX3
		JRST ERRD]	; Too many pages
	NOINT
	MOVE C,-1(P)		; GET SAVED PC
	PUSH P,3(C)		; SAVE ACCESS BITS
	LOCK DMPLCK,<PUSHJ P,LCKTST>
DMPSE0:	MOVSI B,400000
	ASH B,1(A)		; Get a one for each page needed
	HRLZ C,A		; Initial aobjn word
DMPSE1:	TDNN B,DMPASW		; Are these contiguous buffers free
	JRST DMPSE2		; Yes, assign them
	ROT B,-1		; No, try next set
	AOS C			; Modify aobjn word
	JUMPGE B,DMPSE1		; When low bit wraps around
	PUSH P,1		; We have failed
	HRLZ A,DMPCNT
	HRRI 1,DMPTST
	JSYS EDISMS		; Dismiss until buffers released
	POP P,1
	JRST DMPSE0		; Then try again

DMPSE2:	IORM B,DMPASW		; Mark these buffers as taken
	ADDM A,DMPCNT		; Decrement count of free buffers
	UNLOCK DMPLCK
	PUSH P,C		; Save aobjn word
	HRRZ A,-2(P)		; Get user first address-1
	AOS A
	LSH A,-9		; Page number
	JSP B,.+1
	TLNN B,2000		; Call from monitor?
	HRLI A,400000		; No, insert fork id

DMPSE3:	PUSH P,A		; Save vulnerable ac's
	PUSH P,C
	JUMPGE A,[LSH A,9
		PUSHJ P,FPTA	; Convert monitor address to ptn.pn
		JRST DMPSE5]
	PUSHJ P,FKHPTN		; Convert user address to ptn.pn
	BUG(HLT,<DUMPI/O: FKHPTN ALWAYS SHOULD SKIP.>)
DMPSE5:	PUSH P,A		; Save ptn.pn
	PUSHJ P,MRPACS		; Read access of page
	JUMPE A,[MOVE A,-2(P)	; Non-existent page, create it
		LSH A,9
		UMOVE A,(A)	; By referencing it
		POP P,A
		JRST DMPSE5]
	TDNN A,-4(P)		; Test against needed access
	JRST DMPSE4		; Access not permitted
	TLNN A,(1B6)		; Indirect?
	JRST DMPSE7		; No.
	POP P,A			; Yes, track it down
	PUSHJ P,MRPT		; Get id of page pointed to
	JRST DMPSE5		; Not file, continue
	PUSH P,A		; File, repush
	JRST DMPSE6

DMPSE7:	TLNN A,400		; Write copy?
	 JRST DMPSE6		; No.
	MOVE B,-4(P)		; Yes.
	TLNN B,40000		; Write?
	 JRST DMPSE6		; No.
	TLNN A,100000		; Yes, can we read?
	 JRST DMPSE4		; No, must fail
	MOVE B,-2(P)
	LSH B,9
	UMOVES (B)		; Write in page to make not write copy
	POP P,A
	POP P,C
	POP P,A
	JRST DMPSE3		; Recompute

DMPSE6:	HRRZ A,-1(P)		; Get buffer number
	LSH A,9
	ADDI A,DMPBUF		; Convert to address
	MOVE B,A
	EXCH A,(P)		; Save address, get ptn.pn
	HRLI B,140000
	PUSHJ P,SETMPG		; Map the user page into monitor
	POP P,A			; Get back address
	PUSHJ P,FPTA
	PUSHJ P,MLKPG		; Lock the page
	POP P,C			; Restore vulnerable ac's
	POP P,A
	AOS A			; Next page
	AOBJN C,DMPSE3		; Until done
	POP P,C			; Aobjn word
	MOVEM C,(P)		; Back to stack (clobers access bit)
	MOVEI A,DMPBUF/1000(C)	; Page number of first buffer
	AOS -1(P)
	DPB A,[POINT 9,-1(P),26]; Modify iowd to address monitor buffer
	SOS -1(P)

; At this point the dump region has been mapped into the monitor
; Buffer region and access checked
; -1(p) has the iowd needed for the data xfer
; 0(p) has the aobjn word needed to restore buffers when finished

	UMOVE JFN,1
	PUSHJ P,CHKJFN
	JRST DMPER1		; Error, release buffers
	JFCL
	JRST [	MOVEI A,DESX4
		JRST DMPER1]
	TEST(NN,OPENF)
	JRST [	MOVEI A,DESX5
		JRST DMPER2]
	MOVE B,STS
	ANDI B,17
	CAIE B,17
	JRST [	MOVEI A,DUMPX2
		JRST DMPER2]
	MOVE B,-2(P)
	MOVE A,1(B)
	XCT 0(B)
	JRST DMPER2
	POP P,A
	EXCH A,(P)		; Get iowd, leave aobjn word on stack
	XCT 2(B)		; Call device dependent routine
	POP P,A
	PUSHJ P,DMPREL		; Release buffers
	OKINT
	PUSHJ P,UNLCKF
	MOVEI A,IOX4
	TEST(NE,EOFF)
	JRST [	UMOVEM A,1
		JRST MRETN]		; Stop if eof
	MOVEI A,IOX5
	TEST(NE,ERRF)
	JRST [	UMOVEM A,1
		JRST MRETN]		; Or error
	XCTUU [AOS 2]
	JRST DUMPC

DMPER2:	PUSHJ P,UNLCKF
DMPER1:	EXCH A,(P)
	PUSHJ P,DMPREL
	XCTMU [POP P,1]
	JRST MRETN

DMPSE4:	POP P,A
	POP P,A
	POP P,B
	PUSH P,A
	PUSHJ P,DMPRL1		; Release buffers assigned but unlocked
	POP P,C
	HLRES C
	MOVNS C
	HRLZS C
	POP P,A
	ADD A,C
	SKIPGE A
	PUSHJ P,DMPREL		; Release buffers both lock and assigned
	MOVEI A,DUMPX4
	JRST ERRD		; Access error

DMPREL:	PUSH P,A
DMPRL0:	PUSH P,A
	LSH A,9
	MOVEI A,DMPBUF(A)
	PUSH P,A
	PUSHJ P,FPTA
	PUSHJ P,MULKPG
	POP P,B
	MOVEI A,0
	PUSHJ P,SETMPG
	POP P,A
	AOBJN A,DMPRL0
	POP P,A
DMPRL1:	HLRE B,A
	MOVSI C,400000
	ASH C,1(B)
	MOVNI A,(A)
	ROT C,(A)
	ANDCAM C,DMPASW
	MOVNS B
	ADDM B,DMPCNT
	POPJ P,

^LCKTST:PUSH P,1
	MOVE 1,-1(P)
	HRLZ 1,-2(1)
	HRRI 1,LCKTSS
	JSYS EDISMS
	POP P,1
	POPJ P,

USE

LCKTSS:	AOSE 0(1)
	JRST 0(4)
	JRST 1(4)

DMPTST:	CAML 1,DMPCNT
	JRST 0(4)
	JRST 1(4)

USE	SWAPPC

	BENDP	IO

	BEGINP	CONVERSION ROUTINES

INTERN	.NIN,.NOUT

; Fixed point number output
; Call:	1		; Destination designator
;	2		; Number to be output
;	RH(3)		; Radix
;	3(0)		; 1 to treat number as 36 bit magnitude
;	3(1)		; 1 to always print some kind of sign
;	3(2)		; Right justify the number
;	3(3)		; Print leading zeros if any
;	3(4)		; Print something on errors
;	3(5)		; Print * on errors rather than whole number
;	3(11-17)	; Field width, 0 means large enough to hold all
;	NOUT
; Return
;	+1		; Error, bad radix, or number too big for field
;	+2		; Successful

^.NOUT:	JSYS MENTR
	PUSHJ P,NOUTX
	JRST [	MOVE A,LSTERR
		UMOVEM A,3
		JRST MRETN]
	AOS (P)
	JRST MRETN

^NOUTX:	HRRZ D,C		; Get radix
	CAIL D,2
	CAILE D,12		; Must be 2 - 10
	JRST [	MOVEI A,NOUTX1
		MOVEM A,LSTERR
		POPJ P,]
	HLL D,C			; Save flags in d too
	LDB F,[POINT 8,D,17]	; Extract column width
	MOVEI E,1		; Initilize digit counter
	TLNN D,(1B0)		; Magnitude printout?
	CAIL B,0		; Or positive number?
	TLZA D,(1B6)		; Yes, remember not minus sign
	TLO D,(1B6+1B1)		; No, remember minus sign
	TLNE D,(1B6)		; - sign to be printed?
	MOVMS B			; Yes complement number
	TLNE D,(1B1)		; A sign of some sort to be printed?
NOUT1:	AOS E			; Yes, count as digit
	LSHC B,-=35		; Make into double
	LSH C,-1		; Length dividend
	DIVI B,(D)		; Produce a digit
	PUSH P,C		; Save on stack
	JUMPN B,NOUT1		; Repeat until all digits generated
	CAIN F,0		; Zero field width specified?
	MOVE F,E		; Yes, make it same as number of digits
	TLNE D,(1B2)		; Right justify number?
NOUT2:	CAML E,F		; And filler needed?
	JRST NOUT3		; No
	TLNE D,(1B3)		; Yes. leading 0's?
	PUSHJ P,SGNOUT		; Yes, output sign now
	MOVEI B," "		; Get a space
	TLNE D,(1B3)		; Unless 0's wanted
	MOVEI B,"0"		; Then get a 0
	PUSHJ P,BOUTN		; Call bout so strings will work
	SOJA F,NOUT2		; Decrease remaining width and loop

NOUT3:	CAML F,E		; Sufficient room?
	JRST NOUT4		; Yes
	MOVEI B,NOUTX2		; Error
	MOVEM B,LSTERR
	TLNN D,(1B4)		; Print something anyway?
	JRST NOUT7		; No, go away
	TLNN D,(1B5)		; Asterisks?
	JRST NOUT4		; No, print the whole number
	MOVEI B,"*"		; Yes,
NOUT6:	SOJL F,NOUT7		; Column filled
	PUSHJ P,BOUTN
	JRST NOUT6

NOUT7:	TLNE D,(1B1)		; If one position reserved for -,
	SOS E			; One less thing on stack
NOUT71:	SOJL E,CPOPJ
	POP P,B
	JRST NOUT71

NOUT4:	PUSHJ P,SGNOUT		; Output sign before number
NOUT5:	SOJL E,NOUT8		; Any digits left?
	POP P,B			; Yes, get one
	ADDI B,"0"
	PUSHJ P,BOUTN		; Print it
	SOJA F,NOUT5		; Decrease field width

NOUT8:	SKIPL F
	SKIPRT			; Skip if no error
	MOVEI B," "
	JRST NOUT6		; Insert trailing blanks if necessary

SGNOUT:	TLZN D,(1B1)		; Sign still needed?
	POPJ P,			; No, return immediately
	MOVEI B,"-"
	TLNN D,(1B6)
	MOVEI B,"+"
	PUSHJ P,BOUTN
	SOS E			; Decrement digit count
	SOS F			; Decrement remaining field width
	POPJ P,

; Call bout

^BOUTN:	PUSH P,A
	UMOVE A,1		; Output designator
	TLNN A,777777		; String pointer?
	JRST BOUTN1		; No
	TLC A,777777		; Yes
	TLCN A,777777		; Lh = -1?
	HRLI A,440700		; Yes. fill in
	XCTMU [IDPB B,A]
	UMOVEM A,1
	PUSH P,B
	SETZ B,
	XCTMU [IDPB B,A]
	POP P,B
	POP P,A
	POPJ P,

BOUTN1:	BOUT			; For ordinary jfn's just do a bout
	POP P,A
	POPJ P,

; Number input
; Call:	1	; Source designator
;	NIN
; Return
;	+1	; Error
;	+2	OK
;	2	NUMBER

^.NIN:	JSYS MENTR
	CAILE 3,1
	CAILE 3,=10
	JRST [	MOVEI A,IFIXX1	; Illegal radix
		UMOVEM A,3
		JRST MRETN]
	MOVEI 1,400000
	RCM			; Read interrupt enables
	PUSH P,1		; Save to restore when done
	MOVEI 1,400000
	MOVSI 2,(1B6)
	DIC			; Turn off overflow int
	JOV .+1
	MOVEI C,0
	PUSHJ P,BIN1
	CAIN B,40
	JRST .-2		; Skip leading spaces
	CAIN B,"-"
	JRST MININ
	CAIN B,"+"
	PUSHJ P,BIN1
	PUSHJ P,DIGIN1
	JRST [	MOVEI A,IFIXX2
		UMOVEM A,3
		JRST PLINX]
PLIN:	PUSHJ P,NIN9
	UMOVEM C,2
	JOV [	MOVEI A,IFIXX3
		UMOVEM A,3
		JRST PLINX]
	AOS -1(P)
PLINX:	POP P,2			; Get back interrupt enables
	MOVEI 1,400000
	AIC			; Re-enable
	JRST MRETN

MININ:	PUSHJ P,NIN91
	MOVNS C
	JRST PLIN+1

NIN9:	XCTUU [MUL C,3]
	ASH C,=34		; Shift lost bits off setting ovrflo
	LSH C,1			; Position old b35 at b0
	ADD C+1,C		; Complete the 36-bit mult
	EXCH C,C+1		; 36-bit prod to c, hi part to c+1
	ADD C+1,C+1		; Set overflow if sign is wrong now
	ADD C,B			; Add in digit
NIN91:	PUSHJ P,DIGIN
	POPJ P,
	JRST NIN9

DIGIN:	PUSHJ P,BIN1
DIGIN1:	SUBI 2,60
	JUMPL 2,CPOPJ
	XCTUU [CAMGE 2,3]
	AOS (P)
	POPJ P,

^BIN1:	PUSH P,A
	UMOVE A,1
	TLNN A,777777
	JRST BIN1A
	TLC A,777777
	TLCN A,777777
	HRLI A,440700
	XCTMU [ILDB B,A]
	UMOVEM A,1
	POP P,A
	POPJ P,

BIN1A:	BIN
	POP P,A
	POPJ P,
	POPJ P,


	BENDP	CONVER
;22 NOV 71, 1837:

;TELETYPE SERVICE ROUTINES - D. MURPHY

;PARAMETERS

	INTERN NLINES,NTTYS,CTYLIN,TCI,TCO,TTHNGU,TTEMES
	INTERN .TLINK,NORMTF,TAB81,TAB82

;NLINES PARAMETER IN PROLOG

TTBSIZ==200		;BIG BUFFER SIZE
NTABBF==^D20		;NUMBER OF TABS BUFFERS
NDLSPD==10		;SIZE OF DLS PI-LEVEL STACK
CTYLIN==NTTYS-1		;CTY IS ONE AFTER HIGHEST SCANNER
TTLCBT==40000		;LOWER CASE FLAG BIT
TTWKCT==TTSIZ*4-20	;TTY EARLY WARNING COUNT
DLSRCF==400		;DLS RECEIVER FLAG, DATAI WORD
DLSXMF==1000		;DLS XMITTER FLAG, DATAI WORD
DLSCXF==1B25		;CARRIER XITION FLAG
DLSACT==1B26		;ACTIVATE LEVEL IN DATAO
DLSDLB==1B29		;DIRECTED LINE BIT, LH OF DATAO

TTLIND=="%"		;LOWER CASE INDICATION CHARACTER
TTCIND=="^"		;CONTROL INDICATION CHARACTER

T7TIM==^D15		;MAX MILLISECS BETWEEN BIG BUF SERVICE

	EXTERN JOBPT,FORKX,EDISMS,TODCLK,CHKTTM,ENTFLG
	EXTERN SCDRQ7,JOBSRT,RSKP,SYSIFG,TTYBKS,TTINTS

;RANGE OF LINES TO ACCEPT FROM SCANNER

	RESCD

HILIN:	NTTYS-1
LOLIN:	0

	SWAPCD

;STORAGE

LS TTOIN,NLINES		;OUTPUT BUFFER POINTERS (IN)
LS TTOOUT,NLINES		;	(OUT)
LS TTOCT,NLINES		;	(COUNT)

LS TTEIN,NLINES		;ECHO OUTPUT BUFFER POINTERS (IN)
LS TTEOUT,NLINES		;	(OUT)
LS TTECT,NLINES		;	(COUNT)

LS TTIIN,NLINES		;INPUT BUFFER POINTERS (IN)
LS TTIOUT,NLINES		;	(OUT)
LS TTICT,NLINES		;	(COUNT)

;TTY BUFFERS--INPUT, OUTPUT, AND ECHO
;BUFFERS ARE OF SIZE TTSIZ, AND START AT LOCATIONS N*TTSIZ+1

IFNDEF TTBUFF,<		;IF DEFINED, MEANS TTBUFS ALREADY DEFINED
LS TTBUFS,NTTBF*TTSIZ+TTSIZ >
LS TTFREC,1		;COUNT OF FREE BUFFERS
LS TTFREB,1		;LIST OF FREE BUFFERS

LS TTFLGS,NLINES		;FLAGS
LS TTLINK,NLINES		;OUTPUT-LINKED LINES (9-BIT BYTES)

LS FCMOD1,NLINES
LS FCMOD2,NLINES		;CONTROL CHARACTER MODES

LS TTLPOS,NLINES		;PAGE,,LINE POSITION
LS TTPSI,NLINES		;PSEUDO-INTERRUPT MASK
GS TTFORK,NLINES		;OWNERSHIP STATUS,,INPUT WAIT STATUS
GS TTCS,NLINES			;CONTROL STATE
GS TTBFRC,NLINES		;BUFFER CONTROL FIELDS
GS TTMOD1,NLINES		;LAST CHAR INPUT, AND TAB TABLE ADR

LS TABLST,1		;LIST OF FREE TAB BUFFERS
LS TABBFR,NTABBF*3	;TAB BUFFERS

;BIG BUFFER

LS TTBIGI,1		;INPUT INDEX
LS TTBIGO,1		;OUTPUT INDEX
LS TTBIGC,1		;COUNT
LS TTBBUF,TTBSIZ		;BUFFER

;MISC TTY STORAGE

LS TTNIT1,1			;ISB COMMUNICATION REG
LS TCOUTD,1			;DISPATCH TO TCOUT OR TCEOUT
LS XDLSSV,1		;PI RETURN
LS TTCQLN,1			;CONTROL OP CURRENT LINE NUMBER
LS DLSLPI,1		;DLS LOST PI ASMT COUNT
LS TTHNGL,1		;LINE BEING EXAMINED FOR HUNG
LS TTHNGT,1		;TIME AT WHICH LINE WILL BE DEFINED AS HUNG
LS TTHNGN,1		;LAST HUNG LINE ,, NUMBER UNHANGS DONE

LS DLSVAP,1		;PI-LEVEL STORAGE
LS DLSPDL,NDLSPD	;PI-LEVEL PDL

	RESCD

;NON PI ROUTINES

	INTERN BUGTYO,BUGMSG

BUGTYO:	0
	CONSZ TTY,1B31
	JRST .-1
	DATAO TTY,1
	CONSZ TTY,1B31
	JRST .-1
	JRST @BUGTYO

BUGMSG:	0
	MOVE 7,1
	HRLI 7,440600
BUGM2:	ILDB 1,7
	ADDI 1,40
	CAIN 1,"/"
	JRST @BUGMSG
	CAIN 1,"$"
	JRST BUGM1
BUGM3:	JSR BUGTYO
	JRST BUGM2

BUGM1:	MOVEI 1,15
	JSR BUGTYO
	MOVEI 1,12
	JRST BUGM3

	SWAPCD

;SENDS MESSAGES TO ALL TTYS VIA ECHO BUFFER

	INTERN .TTMSG

.TTMSG:	JSYS MENTR
	MOVE 7,0(P)
	TLNE 7,UMODF		;FROM MONITOR?
	JRST UJSYS		;NO, ILLEGAL
	TLNE 2,007000
	HRLI 2,440700		;MAKE BYTE POINTER
	PUSH P,2
	JUMPGE 1,TPA5		;NOT ALL TTYS
	MOVSI 16,-NLINES
TPA6:	MOVE 14,0(P)		;BYTE POINTER
	MOVEI 2,0(16)		;LINE NUMBER
TPA3:	XCTMU [ILDB 1,14]
	JUMPE 1,TPA1		;TERMINATE ON NULL
	CALL TCEO2
	JRST TPA3

TPA1:	AOBJN 16,TPA6
	POP P,2
	JRST MRETN

TPA5:	HRROI 16,0(1)		;DO ONE LINE OF GIVEN NUMBER
	JRST TPA6

;SEND SYSTEM CRASH MESSAGE TO ALL TTYS

	RESCD

LS CRSMSG,2			;CALLED BY JSR CRSMSG

CRSMS0:	MOVEM 17,CRSAC+17	;SAVE AC'S
	MOVEI 17,CRSAC
	BLT 17,CRSAC+16
	MOVE P,[IOWD NCRSPD,CRSPDL]
	MOVSI 16,-NLINES	;DO ALL EXISTING LINES
CRSM3:	MOVEI 14,[ASCIZ /
**TENEX IS DOWN**
/]
	HRLI 14,440700
	MOVEI 2,0(16)		;LINE NUMBER
CRSM2:	ILDB 1,14		;CHARACTER
	JUMPE 1,CRSM1		;NULL MARKS END
	CALL TCEO2		;OUTPUT VIA ECHO BUFFER
	JRST CRSM2

CRSM1:	AOBJN 16,CRSM3
	MOVSI 17,CRSAC		;RESTORE ACS
	BLT 17,17
	JRST @CRSMSG

LS CRSAC,20
NCRSPD==10
LS CRSPDL,NCRSPD

;INITIALIZATION

	INTERN TTINIT,TTRSET

TTINIT:	MOVEI 1,TTBUFS		;COMPUTE BEGINNING OF BUFFERS
	TRNE 1,TTSIZ-2		; TO BE N*TTSIZ+1
	ADDI 1,TTSIZ		;FIRST WORD IN BUFFER AREA
	ANDCMI 1,TTSIZ-1	;WHICH IS 0 MOD TTSIZ
	ADDI 1,1		;SUCH THAT EACH BUFFER ENDS 0 MOD ADR
	MOVEI 2,NTTBF
	MOVEM 2,TTFREC		;FREE BUFFER COUNT
	SUBI 2,1
	MOVEM 1,TTSIZ(1)	;CONSTRUCT LIST OF FREE BUFFERS
	ADDI 1,TTSIZ
	SOJG 2,.-2
	MOVEM 1,TTFREB		;FREE BUFFER LIST
	ADD 1,[XWD 441100,1]	; +1 AND MAKE INTO BYTE POINTER
	MOVSI 7,-NLINES
TTIB1:	SETZM TTOIN(7)
	SETZM TTOOUT(7)
	SETZM TTOCT(7)		;INITIALIZE OUTPUT BUFFER WORDS
	SETZM TTEIN(7)
	SETZM TTEOUT(7)
	SETZM TTECT(7)		; ... ECHO BUFFER WORDS
	SETZM TTIIN(7)
	SETZM TTIOUT(7)
	SETZM TTICT(7)		; ... INPUT BUFFER WORDS
	SETOM TTFORK(7)
	SETZM TTFLGS(7)
	MOVE 1,[<^D20>B7+2B12+2B17+<2*<TTSIZ-1>*4>B26+<2*<TTSIZ-1>*4-2>B35]
	MOVEM 1,TTBFRC(7)	;NORMAL IS 2 BUFFERS FOR IN AND OUT
	AOBJN 7,TTIB1
	MOVSI 2,-NLINES
	CALL TTILIN
	AOBJN 2,.-1
	MOVEI 2,NTABBF-1	;INIT FREE LIST OF TAB BUFFERS
	MOVEI 1,TABBFR
	MOVEM 1,3(1)
	ADDI 1,3
	SOJG 2,.-2
	MOVEM 1,TABLST
	SETZM TTBIGI
	SETZM TTBIGO
	SETZM TTBIGC
	CONO TTY,DLSCHN
	CONO DLS,DLSCHN
TTACTL:	SETZM TTHNGT
	SETZM TTHNGN
	MOVEI 2,TCOUTX
	MOVEM 2,TCOUTD		;REGULAR OUTPUT DISPATCH
	MOVE 1,[JRST CRSMS0]	;SETUP JSR DISPATCH
	MOVEM 1,CRSMSG+1
	MOVSI 2,-NLINES+1	;ACTIVATE DLS LINES (BUT NOT CTY)
	MOVE 1,[XWD DLSDLB,DLSACT+1B27]	;DIRECTED LINE, ACTIVATE, NO XMIT
	DPB 2,[POINT 6,1,17]	;PUT LINE NUMBER IN DATAO WORD
	DATAO DLS,1
	AOBJN 2,.-2
	RET

;RESUME RUNNING TTY'S AFTER RESTART

TTRSET:	MOVSI 2,-NLINES
	CONO TTY,DLSCHN
	CONO DLS,DLSCHN		;ASSUMES I-O RESET WAS DONE
TTRST1:	SKIPL TTFLGS(2)		;WAS XMITTER IN OPERATION
	JRST .+3		;NO
	HRRZM 2,TTNIT1		;YES, SIMULATE INTERRUPT TO RESUME ACTION
	ISB DLSCHN
	AOBJN 2,TTRST1
	JRST TTACTL

;TTY BUFFER CONTROL ROUTINES

;POINTERS TO FIELDS IN TTBFRC WORD

TTOMAX:	POINT 9,TTBFRC(2),35	;MAX BYTES IN OUTPUT BUFFER(S)
TTIMAX:	POINT 9,TTBFRC(2),26	; " INPUT BUFFER(S)
TTNOU:	POINT 5,TTBFRC(2),17	;NUMBER OF OUTPUT BUFFERS TO ASSIGN
TTNIN:	POINT 5,TTBFRC(2),12	;NUMBER OF INPUT BUFFERS TO ASSIGN
TTOWRN:	POINT 8,TTBFRC(2),7	;OUTPUT WAKEUP LEVEL

;ASSIGN AND SETUP TTY BUFFERS
; 3/ NUMBER OF BUFFERS TO GET
;  RETURNS +1 TRANSPARENT, EXCEPT
; 3/ BYTE POINTER FOR INPUT AND OUTPUT POINTER WORDS
;THIS ROUTINE ASSUMES THAT IT IS PROTECTED FROM INTERRUPS OR RESCHEDULING
; WHICH COULD RESULT IN OTHER USE OF THE FREE LIST

TTGTBF:	PUSH P,1		;TRANSPARENT TO ALL AC'S EXCEPT 3
	PUSH P,3		;SAVE COUNT
	SETZ 1,
TTGTB1:	SOSGE TTFREC		;REDUCE FREE BUFFER COUNT
	BUG(HLT,<RAN OUT OF TTY BUFFERS>)
	HRRZ 3,@TTFREB		;GET BUFFER FROM LIST
	EXCH 3,TTFREB
	JUMPE 1,[MOVSI 1,0(3)	;FIRST BUFFER, REMEMBER ITS ADDRESS
		JRST .+2]
	HRRZM 3,0(1)		;CONC NEW BUFFER ONTO LIST
	HRRI 1,0(3)
	SOSLE 0(P)		;GOT REQUESTED NUMBER OF BUFFERS?
	JRST TTGTB1		;NO
	HLRZ 3,1		;ADDRESS OF FIRST BUFFER IN LIST
	HRRZM 3,0(1)		;COMPLETE CIRCULAR LIST
	ADD 3,[XWD 441100,1]	;CONSTRUCT 9-BIT BYTE POINTER
	POP P,1			;JUNK
	POP P,1
	RET

;RELEASE LIST OF TTY BUFFERS
; 3/ BYTE POINTER ANYWHERE IN ANY BUFFER OF LIST
;  RETURNS +1, CLOBBERS 3
;ASSUMES INTERRUPT PROTECTION AS ABOVE

TTRLBF:	MOVEI 3,0(3)
	JUMPE 3,R		;IN CASE NO BUFFERS
	PUSH P,1
	TDNN 3,WRPMSK		;NOW AT END OF BUFFER?
	SUBI 3,TTSIZ		;YES
	ANDCM 3,WRPMSK		;NORMALIZE POINTER TO FIRST WD OF BFR
	ADDI 3,1		;WHICH IS 1 AFTER THE 0 MOD TTSIZ
	PUSH P,3		;SAVE ADDRESS OF FIRST BUFFER
TTRLB1:	MOVEI 1,0(3)
	HRRZ 3,0(3)		;NEXT BUFFER IN LIST
	EXCH 1,TTFREB		;PUT BUFFER ON FREE LIST
	MOVEM 1,@TTFREB
	AOS TTFREC
	CAME 3,0(P)		;CIRCLED AROUND TO FIRST BUFFER?
	JRST TTRLB1		;NO
	POP P,3
	POP P,1
	RET

;RELEASE OUTPUT BUFFERS
; 2/ LINE NUMBER
;  RETURNS +1, CLOBBERS 3
;ASSUMES INTERRUPT PROTECTION AS ABOVE

TTRLOB:	SKIPN 3,TTEOUT(2)	;ECHO BUFFER TO RELEASE?
	JRST .+4		;NO
	SETZM TTEOUT(2)
	SETZM TTEIN(2)
	CALL TTRLBF		;RELEASE IT
	SKIPN 3,TTOOUT(2)	;OUTPUT BUFFERS TO RELEASE?
	JRST .+4		;NO
	SETZM TTOOUT(2)
	SETZM TTOIN(2)
	CALL TTRLBF		;RELEASE THEM
	RET

;TTY CONTROL ROUTINES

	INTERN TTCOBF,TTCIBF,TTILIN

TTCOBF:	NOSKD1
	CHNOFF DLSCHN
	SETZM TTOCT(2)		;ZERO OUTPUT COUNT
	SETZB 3,TTOOUT(2)
	EXCH 3,TTOIN(2)
	CALL TTRLBF		;RELEASE BUFFERS
	SETZM TTECT(2)		;CLEAR ECHO BUFFER TOO
	SETZB 3,TTEOUT(2)
	EXCH 3,TTEIN(2)
	CALL TTRLBF
	CHNON DLSCHN
	OKSKD1
	RET

TTCIBF:	NOSKD1
	MOVEI 1,1B34
	ANDCAM 1,TTFLGS(2)	;CLEAR BKJFN FLAG
	CHNOFF DLSCHN
	SETZM TTICT(2)
	SETZB 3,TTIOUT(2)
	EXCH 3,TTIIN(2)
	CALL TTRLBF		;RELEASE BUFFERS
	HLLOS TTFORK(2)		;RESET WAITING FORK
	CHNON DLSCHN
	OKSKD1
	RET

TTILIN:	CALL TTCIBF		;INITIALIZE TTY LINE
	MOVE 1,NORMTF		;USUAL DEVICE FLAGS AND STATUS
	DPB 1,[POINT 35,TTFLGS(2),35]
	SETZM TTPSI(2)
	SETZM TTLPOS(2)
	MOVE 1,TTICB1		;SETUP USUAL CONTROL CHARACTER MODES
	MOVEM 1,FCMOD1(2)
	MOVE 1,TTICB2
	MOVEM 1,FCMOD2(2)
	MOVEI 1,TAB81		;NORMAL TABS
	MOVEM 1,TTMOD1(2)
	RET

;USUAL DEVICE FLAGS AND STATUS
; 66 LINES/PAGE, 75 CHARS/LINE
; WAKEUP ON ALL, ECHO MODE 2 (DEFERRED OR IMMED)
; DATA MODE ASCII, CONVERT LOWER TO UPPER ON INPUT

NORMTF:	XWD <^D66B28>+^D72,17B23+2B25+1B29+1B31

TAB81:	EXP 1B0+1B8+1B16+1B24+1B32
TAB82:	EXP 1B4+1B12+1B20+1B28
TAB83:	EXP 1B0+1B8+1B16+1B24+1B32

TTOBET:	SKIPE TTOCT(1)		;SCHEDULER TEST - NOW EMPTY?
	JRST 0(4)
	JRST 1(4)		;YES, RESCHED

TTIBET:	SKIPE TTICT(1)		;SCHEDULER TEST FOR INPUT BUF EMPTY
	JRST 0(4)		;NOT EMPTY
	JRST 1(4)		;EMPTY

	SWAPCD

;MORE CONTROL ROUTINES
;ALL TAKE LINE NUMBER IN AC2, ARG/VALUE IN 1, 2ND ARG/VALUE IN 3, ...

	INTERN TTSIBE,TTSOBE,TTSOBF,TTDOBE,TTGTBS,TTSTBS,TTSPOS
	INTERN TTRMOD,TTSMOD,TTRPOS,TTRCOC,TTSCOC,TTSTI,TTBKPT
	INTERN TTDIBE

TTSIBE:	MOVEI 3,1B34		;BACKUP BIT
	SKIPG 1,TTICT(2)	;SOMETHING IN BUFFER?
	TDNE 3,TTFLGS(2)	;OR CAN RE-READ PREVIOUS CHAR?
	RET			;YES, BUFFER NOT EMPTY
	JRST RSKP

TTSOBE:	SKIPG 1,TTOCT(2)	;SKIP IF OUTPUT BUFFER EMPTY
	AOS 0(P)
	RET

TTSOBF:	LDB 3,TTOMAX		;CAPACITY OF OUTPUT BUFFER
	MOVE 1,TTOCT(2)		;SKIP IF OUTPUT BUFFER FULL
	CAIL 1,0(3)
	AOS 0(P)
	RET

TTDOBE:	SKIPG 1,TTOCT(2)	;DISMISS UNTIL OUTPUT BUFFER EMPTY
	RET			;NOW EMPTY
	MOVEI 1,TTOBET
	HRLI 1,0(2)		;LINE NUMBER
	JSYS EDISMS
	JRST TTDOBE

TTGTBS:	HRRZ 1,TTMOD1(2)	;TAB TABLE ADR
	MOVE 3,1(1)
	MOVE 4,2(1)
	MOVE 1,0(1)
	RET

TTSTBS:	PUSH P,1
	HRRZ 1,TTMOD1(2)	;ADDRESS OF CURRENT TABS
	CAIN 1,TAB81		;STANDARD?
	JRST TTSTB1		;YES, NOTHING TO RELEASE
	NOSKED
	EXCH 1,TABLST		;PUT BUFFER ON FREE LIST
	MOVEM 1,@TABLST
	OKSKED
TTSTB1:	POP P,1
	CAME 1,TAB81		;SEE IF REQUEST TABS ARE STANDARD
	JRST TTSTB2		;NO
	CAMN 3,TAB82
	CAME 4,TAB83
	JRST TTSTB2		;NO, NO
TTSTB4:	MOVEI 1,TAB81		;ADDRESS OF STANDARD TABS
TTSTB3:	HRRM 1,TTMOD1(2)
	RET

TTSTB2:	PUSH P,1
	NOSKED
	SKIPN TABLST		;FREE TAB BUFFERS?
	JRST [	OKSKED		;NO
		POP P,1
		JRST TTSTB4]	;USE STANDARD
	MOVE 1,@TABLST		;GET BUFFER
	EXCH 1,TABLST
	OKSKED
	MOVEM 4,2(1)		;STORE BIT WORDS IN BUFFER
	MOVEM 3,1(1)
	POP P,0(1)
	JRST TTSTB3

TTDIBE:	SKIPN TTICT(2)
	RET
	MOVEI 1,TTIBET		;INPUT BUFFER EMPTY TEST
	HRLI 1,0(2)
	JSYS EDISMS
	JRST TTDIBE

TTRMOD:	MOVE 1,TTFLGS(2)	;READ MODES
	RET

TTSMOD:	PUSH P,1
	XOR 1,TTFLGS(2)		;SET RH BITS
	ANDI 1,776374		;BUT DON'T CHANGE BITS 26,27,34,35
	XORM 1,TTFLGS(2)
	LDB 1,[POINT 7,0(P),10]
	CAIL 1,10		;LEGAL PAGE SIZE?
	CAIL 1,200
	MOVEI 1,^D66		;NO, USE DEFAULT
	DPB 1,[POINT 7,TTFLGS(2),10]
	LDB 1,[POINT 7,0(P),17]
	CAIL 1,10		;LEGAL WIDTH
	CAIL 1,200
	MOVEI 1,^D72		;USE DEFAULT
	DPB 1,[POINT 7,TTFLGS(2),17]
	LDB 1,[POINT 3,0(P),3]
	DPB 1,[POINT 3,TTFLGS(2),3]	;LH BITS
	POP P,1
	HLLOS TTFORK(2)		;RESET LINE TO NO-WAIT STATE
	RET

TTRPOS:	MOVE 1,TTLPOS(2)	;READ POSITION
	RET

TTRCOC:	MOVE 1,FCMOD1(2)	;READ CONTROL CHARACTER MODES
	MOVE 3,FCMOD2(2)
	RET

TTSCOC:	MOVEM 1,FCMOD1(2)	;SET CONTROL CHARACTER MODES
	MOVEM 3,FCMOD2(2)
	RET

;HANG UP DATASET

TTHNGU:	CAIL 2,CTYLIN		;CAN'T HANGUP CTY
	RET
	CALL TTDOBE		;WAIT TILL NO OUTPUT
	MOVEI 1,TTHU0		;HANGUP FIRST STATE ROUTINE
	CALL TTQAD		;ADD TO QUEUE
	RET

;"BACKUP" INPUT POINTER - CAN ONLY BACKUP ONE

TTBKPT:	MOVEI 3,1B34
	TDNE 3,TTFLGS(2)	;ALREADY BACKUPED?
	RET			;YES
	IORM 3,TTFLGS(2)	;SET FLAG TO BE NOTICED AT NEXT TCI
	JRST RSKP

TTSPOS:	MOVEM 1,TTLPOS(2)	;SET LINE CHARACTER POSITION
	RET

;SIMULATE TTY INPUT

TTSTI:	ANDI 1,377		;ISOLATE CHARACTER
	HRLI 1,0(2)		;COMBINE WITH LINE NUMBER
	IORI 1,DLSRCF		;SET RECEIVER FLAG
	NOSKD1
	CHNOFF DLSCHN
	AOS 3,TTBIGI		;PUT SIMULATE DLS WORD IN BIG BUF
	CAIN 3,TTBSIZ
	SETZB 3,TTBIGI
	MOVEM 1,TTBBUF(3)
	AOS TTBIGC
	CHNON DLSCHN
	OKSKD1
	MOVEI 1,^D100		;DISMISS FOR 100 MS. TO GIVE
	DISMS			;DISTINATION TIME TO DIGEST CHARACTER
	MOVEI 3,200000
	SKIPE TTICT(2)		;DEST INPUT BUFFER NOW EMPTY?
	IORM 3,TTFORK(2)	;NO, BE SURE JOB GIVEN WAKEUP
	RET

;TLINK JSYS

.TLINK:	JSYS MENTR
	MOVEI 1,0(1)
	CALL CHKTTM		;CHECK DESIGNATOR, GET LINE NO IN 2
	RETERR DESX1		;NOT TTY DESIGNATOR
	CAIGE 2,1		;DISALLOW 0 AS OBJECT, CAUSE IT'S
	JRST MRSKP		;USED FOR NIL, SHOULD BE FIXED
	PUSH P,2		;SAVE OBJECT LINE NUMBER
	UMOVE 1,1
	TLNN 1,(74B5)		;SECOND DESIGNATOR REQUIRED?
	JRST TL1		;NO
	XCTUU [HRRZ 2,2]
	CAIN 2,-1		;'ALL' ?
	JRST TL1		;YES, LEAVE AS IS
	TRZE 2,1B18		;4XXXXX?
	JRST TL2		;YES
	MOVE 1,2		;ASSUME REGULAR JFN
	CALL CHKTTM
	RETERR DESX1		;NOT TTY
TL2:	CAIGE 2,NLINES		;LEGAL LINE?
	CAIGE 2,1
	RETERR DESX1		;NO
TL1:	POP P,7			;OBJECT DESIGNATOR
	UMOVE 6,1		;GET FUNCTION FLAGS
	TLNE 6,(1B0)
	CALL TLINK0		;CLEAR REMOTE TO OBJECT
	TLNE 6,(1B1)
	CALL TLINK1		;CLEAR OBJECT TO REMOTE
	TLNE 6,(1B2)
	CALL TLINK2		;SET OBJECT TO REMOTE
	TLNE 6,(1B3)
	CALL TLINK3		;SET REMOTE TO OBJECT
	TLNE 6,(1B4)
	CALL TLINK4		;SET ACCEPT BIT TO C(B5)
MRSKP:	AOS 0(P)
	JRST MRETN

;CLEAR REMOTE TO OBJECT

TLINK0:	CAIE 2,-1		;ALL REMOTES?
	JRST [	CALL TL0C	;NO, DO THE ONE SPECIFIED
		RET]
	PUSH P,2
	MOVEI 2,0		;SCAN ALL LINES
	CALL TL0C		;CLEARING ANY LINKS TO OBJECT
	CAIGE 2,NLINES-1
	AOJA 2,.-2
	POP P,2
	RET

TL0C:	CALL TLTST1		;LOOK AT REMOTE LINE
	JUMPL 1,R		;DONE IF NO LINKS TO OBJ
	SETZ 1,
	DPB 1,5			;CLEAR THE LINK JUST FOUND
	JRST TL0C

;CLEAR OBJECT TO REMOTE

TLINK1:	CAIE 2,-1		;ALL?
	JRST [	CALL TL1C	;NO, CLEAR SPECIFIC
		RET]
	MOVE 5,[POINT 9,TTLINK(7),-1]
	PUSH P,2
TL12:	ILDB 2,5		;SCAN ALL FIELDS OF OBJECT LINE
	JUMPE 2,.+4
	PUSH P,5
	CALL TL1C
	POP P,5
	TLNE 5,(7B2)
	JRST TL12
	POP P,2
	RET

TL1C:	CALL TLTST2		;FIND LINK TO REMOTE
	JUMPL 1,R		;NONE, DONE
	MOVE 1,CAPMSK
	TRNE 1,WHEEL+OPER	;PRIVILEGED?
	JRST TL13		;YES, SKIP CHECK
	PUSH P,5
	CALL TLTST1		;EXISTS REMOTE TO OBJECT?
	POP P,5
	JUMPG 1,MRETN	;ERROR IF YES
TL13:	SETZ 1,
	DPB 1,5			;CLEAR LINK JUST FOUND
	JRST TL1C

;SET OBJECT TO REMOTE

TLINK2:	CAIN 2,-1
	RETERR DESX1		;NON-SPECIFIC DESIGNATOR ILLEG HERE
	CAMN 2,7		;LINK TO SELF?
	RET			;YES, IGNORE
	CALL TLTST2		;LINK ALREADY EXISTS?
	JUMPG 1,R		;IGNORE IF YES
	MOVEI 5,5		;DO 5 RINGS
TL21:	MOVEI 3,1B26		;ACCEPT BIT
	MOVE 4,CAPENB
	TRNN 4,WHEEL+OPER	;PRIVILEGED? OR
	TDNE 3,TTFLGS(2)	;REMOTE ACCEPTING?
	JRST TL22		;YES
	JUMPLE 5,MRETN	;NO, QUIT AFTER 5 RINGS
	MOVEI 4,^D10		;A RING IS 10 BELLS
	MOVEI 1,"G"-100		;BELL
TL23:	CALL TCEO2		;RING REMOTE
	EXCH 2,7
	CALL TCEO2		;RING LOCAL
	EXCH 2,7
	SOJG 4,TL23
	MOVEI 1,^D3000		;WAIT FOR 3 SECONDS, THE BELL WILL BE
	DISMS			;RINGING FOR THE FIRST SECOND OF WAIT
	SOJA 5,TL21		;GO SEE IF REMOTE NOW ACCEPTING

TL22:	PUSH P,2
	SETZ 2,
	CALL TLTST2		;FIND FREE FIELD IN OBJECT
	POP P,2
	JUMPL 1,MRETN	;LINKS FULL
	DPB 2,5			;DEPOSIT REMOTE NUMBER IN FIELD
	RET

;SET REMOTE TO OBJECT

TLINK3:	CAIN 2,-1
	RETERR DESX1		;MULTIPLE DESIGNATOR ILLEGAL
	CAMN 2,7		;LINK TO SELF?
	RET			;YES, IGNORE
	CALL TLTST1		;LINK ALREADY EXISTS?
	JUMPG 1,R		;RETURN IF SO
	MOVE 1,CAPENB
	TRNE 1,WHEEL+OPER	;PRIVILEGED?
	JRST TL31		;YES, SKIP SHECK
	CALL TLTST2		;CHECK OBJ TO REMOTE
	JUMPL 1,MRETN	;ERROR, OBJ TO REMOTE NOT DONE FIRST
TL31:	PUSH P,7
	SETZ 7,
	CALL TLTST1		;FIND FREE FIELD IN REMOTE
	POP P,7
	JUMPL 1,MRETN	;LINK WORD FULL
	DPB 7,5			;DEPOSIT OBJ NUMBER IN FIELD
	RET

;SET ACCEPT BIT

TLINK4:	MOVEI 1,1B26		;IT IS BIT 26 IN TTFLGS
	TLNE 6,(1B5)		;SET IT?
	IORM 1,TTFLGS(7)	;YES
	TLNN 6,(1B5)		;CLEAR IT?
	ANDCAM 1,TTFLGS(7)	;YES
	RET

;CHECK FOR EXISTENCE OF REMOTE TO OBJECT
; VALUE .GE. 0 MEANS YES

TLTST1:	MOVE 5,[POINT 9,TTLINK(2),-1]
TLT1:	ILDB 1,5		;SCAN REMOTE
	CAMN 1,7		;FOUND OBJECT?
	RET			;YES
	TLNE 5,(7B2)		;NO, SCANNED ALL FIELDS?
	JRST TLT1		;NO
	SETO 1,			;YES, RETURN NEGATIVE VALUE
	RET

;CHECK FOR EXISTENCE OF OBJECT TO REMOTE
; VALUE .GE. 0 MEANS YES

TLTST2:	MOVE 5,[POINT 9,TTLINK(7),-1]
TLT2:	ILDB 1,5		;SCAN OBJECT
	CAMN 1,2		;FOUND REMOTE?
	RET			;YES
	TLNE 5,(7B2)		;NO, SCANNED ALL FIELDS?
	JRST TLT2		;NO
	SETO 1,			;YES, RETURN NEG VALUE
	RET

	RESCD

;PSEUDO-INTERRUPT CHARACTER TABLE
	INTERN PSICH
	RADIX 10
NU==36		;NOT USED VALUE

PSICH:	0	;CONTROL GROUP - @ (BREAK)
	1	;A
	2	;B
	3	;C
	4	;D
	5	;E
	6	;F
	7	;G

	8	;H
	9	;I
	10	;J
	11	;K
	12	;L
	13	;M (CR)
	14	;N
	15	;O

	16	;P
	17	;Q
	18	;R
	19	;S
	20	;T
	21	;U
	22	;V
	23	;W

	24	;X
	25	;Y
	26	;Z
	27	;ALTMODE
	NU	;34
	NU	;35
	NU	;36
	NU	;37

	29	;SPACE
PSICHH:	NU	;173
	NU	;174
	27	;175 (OLD ALTMODE)
	27	;176 (OLD ALTMODE)
	28	;177 (RUBOUT)
	RADIX 8

PSICHU==173		;FIRST CHARACTER OF UPPER GROUP
PSICHL==PSICHH-PSICH	;SIZE OF LOWER GROUP
PSICHO==PSICH+PSICHU-PSICHH	;UPPER GROUP OFFSET

;CHARACTER CLASS TABLE (FOR WAKEUP CONTROL)

FC==10		;FORMAT CONTROL
C==4		;CONTROL, NON-FORMAT
PC==2		;PUNCTUATION
A==1		;ALPHANUMERIC

TTWKTB:	BYTE (6) C,C,C,C,C,C		;NULL - E(C)
	BYTE (6) C,C,FC,FC,FC,C		;F(C) - K(C)
	BYTE (6) FC,FC,C,C,C,C		;L(C) - Q(C)
	BYTE (6) C,C,C,C,C,C		;R(C) - W(C)
	BYTE (6) C,C,C,FC,C,C		;X(C) - Z(C), ESC - 035
	BYTE (6) C,FC,PC,PC,PC,PC	;036, EOL, SPACE - #
	REPEAT 2,<BYTE (6) PC,PC,PC,PC,PC,PC>
					;$ - /
	BYTE (6) A,A,A,A,A,A		;0 - 5
	BYTE (6) A,A,A,A,PC,PC		;6 - 9, COLON, SEMI
	BYTE (6) PC,PC,PC,PC,PC,A	;LEFT ANG BK - AT, A
	REPEAT 4,<BYTE (6) A,A,A,A,A,A>
					;B - Y
	BYTE (6) A,PC,PC,PC,PC,PC	;Z, LEFT BK - LARR
	BYTE (6) PC,A,A,A,A,A		;140, A(LC) - E
	REPEAT 3,<BYTE (6) A,A,A,A,A,A>
					;;F(LC) - W(LC)
	BYTE (6) A,A,A,PC,PC,PC		;X - Z(LC), 173 - 175
	BYTE (6) PC,FC			;176, RUBOUT

	INTERN CH6TAB,BHC

;6-BIT POINTER TABLE

	POINT 6,0,-1
CH6TAB:	POINT 6,0,5
	POINT 6,0,11
	POINT 6,0,17
	POINT 6,0,23
	POINT 6,0,29
	POINT 6,0,35

XX=0
BHC:	REPEAT 20,<EXP XX*1000001
		XX=XX+1>

	INTERN BITS

XX==0
BITS:	REPEAT ^D36,<EXP 1B<XX>
		XX=XX+1>

;ROUTINE TO OUTPUT CHARACTER TO TELETYPE,
;CONVERTING FROM INTERNAL TO ASCII, AND HANDLING FORMAT EFFECTORS

TCOX:	PUSH P,1
	JRST TCOX1

TCO:	PUSH P,1		;CHARACTER IN 1, LINE NO. IN 2
	MOVE 3,TTFLGS(2)	;FLAGS
	TRNN 3,3B29		;BINARY (8 BIT) MODE?
	JRST TTCO3		;YES
TCOX1:	ANDI 1,177
	CAIL 1,177
	JRST TTCO3		;RUBOUT
	CAIGE 1,40
	JRST TTCO1		;CONTROL GROUP
	CAIL 1,140
	JRST TTCO2		;LOWER CASE GROUP
TTCO6:	AOS 3,TTLPOS(2)		;SPACING CHARACTER
TTCO8:	LDB 4,[POINT 7,TTFLGS(2),17] ;GET RIGHT MARGIN
	CAIL 4,0(3)		;CHECK FOR OVERFLOW
	JRST TTCO3
	PUSH P,1		;LINE OVERFLOW, DO CR AND CONTINUATION
	MOVEI 1,15
	CALL TCOUT
	MOVEI 1,12
	CALL TCOUT
	MOVSI 1,1
	ADD 1,TTLPOS(2)		;INCREMENT LINE COUNT
	HRRI 1,2		;SET CHAR COUNT FOR 2 *'S
	MOVEM 1,TTLPOS(2)
	MOVEI 1,52
	CALL TCOUT
	CALL TCOUT
	POP P,1
	JRST TTCO6

TTCO3:	CALL TCOUT		;PUT CHARACTER IN OUTPUT BUFFER
TTCOR:	POP P,1
	RET

;LOWER CASE GROUP

TTCO2:	MOVE 3,TTFLGS(2)	;DEVICE CHARACTERISTICS
	TLNE 3,TTLCBT		;HAS LOWER CASE?
	JRST TTCO6		;YES
	SUBI 1,40		;INDICATE LOWER CASE AND CONVERT
	TRNN 3,40		;INDICATE LC?
	JRST TTCO6		;NO.
	PUSH P,1
	MOVEI 1,TTLIND		;INDICATION CHARACTER
	JRST TTCO7

;CONTROL GROUP
;FOR EACH CHARACTER, ACTION IS CONTROLLED BY TWO BITS:
; 00 => IGNORE, DO NOT SEND
; 01 => SEND PRINTING INDICATION (I.E. &C)
; 10 => SEND ACTUAL CODE AND ACCOUNT LINE AND PAGE POSITION
; 11 => SIMULATE FORMAT ACTION AND ACCOUNT

TTCO1:	MOVE 4,FCMOD2(2)	;SECOND CONTROL MODES WORD
	MOVE 3,FCMOD1(2)	;FIRST CONTROL MODES WORD
	ROTC 3,0(1)		;GET TWO BIT MODE FOR THIS CHAR
	ROTC 3,0(1)
	TLNE 3,400000
	JRST @TTCTAB(1)		;DISPATCH TO FORMAT ROUTINE
	TLNN 3,200000
	JRST TTCOR		;IGNORE
	ADDI 1,100		;MAKE INTO PRINTING EQUIVALENT
	PUSH P,1
	MOVEI 1,TTCIND		;INDICATOR CHARACTER
TTCO7:	CALL TCOUT		;SEND INDICATOR
	AOS TTLPOS(2)		;LINE WILL NOT BE SPLIT AFTER INDICATOR
	POP P,1
	JRST TTCO6

;DISPATCH TABLE FOR FORMAT EFFECTING CONTROL CHARACTERS

NC=TTCO3	;DISPATCH FOR NON-FORMAT CONTROLS

TTCTAB:	NC	;@
	NC	;A
	NC	;B
	NC	;C
	NC	;D
	NC	;E
	NC	;F
	NC	;G

	TTSM4	;H - BACKSPACE
	TTSM1	;I - TAB
	TTSM2	;J - LINE FEED
	NC	;K
	TTSM3	;L - FORM
	TTSM5	;M - CARRIAGE RETURN
	NC	;N
	NC 	;O

	NC	;P
	NC	;Q
	NC	;R
	NC	;S
	NC	;T
	NC	;U
	NC	;V
	NC	;W

	NC	;X
	NC	;Y
	NC	;Z
	TTSALT	;[ AND ALTMODE
	NC	;\
	NC	;]
	NC	;^
	TTSM6	;_, EOL

;NORMAL CONTROL CHARACTER SETTINGS

	INTERN TTICB1,TTICB2

TTICB1:	BYTE (2) 0,1,1,1,1,1,1,2,1,3,2,1,3,2,1,1,1,1
TTICB2:	BYTE (2) 1,1,1,1,1,1,1,1,1,3,1,1,1,2

;TAB
;TAB STOPS ARE INDICATED BY BITS CORRESPONDING TO LINE POSITIONS
;THERE ARE 108 STOPS (3 WORDS)

TTSM1:	PUSH P,3
	MOVEI 7,1		;7 WILL CONTAIN SKIP DISTANCE ( >0 )
	HRRZ 3,TTLPOS(2)	;OLD POSITION
	ADDI 3,1		;MOVE AT LEAST ONE
	IDIVI 3,^D36		;36 TAB STOPS / WORD
TTSM11:	CAILE 3,2		;BEYOND END OF LINE?
	JRST TTSM15		;YES
	HRRZ 5,TTMOD1(2)	;TAB TABLE FOR THIS LINE
	ADDI 5,0(3)
	MOVE 5,0(5)		;GET BITS
	LSH 5,0(4)		;GET TO PRESENT POSITION
	JFFO 5,TTSM12		;FIND NEXT STOP
	ADDI 7,^D36		;NOT IN THIS WORD - UPDATE COUNT AND
	SUBI 7,0(4)
	MOVEI 4,0		;START AT BEGINNING OF NEXT WORD
	AOJA 3,TTSM11

TTSM12:	ADDI 7,0(6)		;ADD IN NUMBER SKIPPED, THIS WORD
TTSM15:	POP P,3			;MODE WORD
	TLNN 3,200000		;REAL OR SIMULATED
	JRST TTSM13		;REAL
	MOVEI 1,40		;SIMULATE WITH SPACES
	CALL TCOX
	SOJG 7,.-1
	JRST TTCOR

TTSM13:	MOVEI 1,11		;SEND REAL TAB
	CALL TCOUT
	MOVE 4,7		;PLUS RUBOUTS TO KILL TIME
	IDIVI 4,4		;ASSUME FOUR SPACES PER RUBOUT
	JUMPLE 4,TTSM14
	MOVEI 1,177
	CALL TCOUT
	SOJG 4,.-1
TTSM14:	ADDB 7,TTLPOS(2)	;UPDATE POSITION
	MOVEI 3,0(7)
	JRST TTCO8

;ALTMODE

TTSALT:	TLNN 3,200000		;SIMULATE?
	JRST TTCO3		;NO, SEND
	MOVEI 1,"$"		;SIMULATE MEANS SEND DOLLARS
	JRST TCOX1

;LINE FEED

TTSM2:	MOVSI 3,1		;INCREMENT PAGE POSITION
	ADDM 3,TTLPOS(2)
	JRST TTCO3

;FORM FEED

TTSM3:	HLRZ 4,TTLPOS(2)	;PRESENT PAGE POSITION
	HRRZS TTLPOS(2)		;RESET
	PUSH P,3
	LDB 3,[POINT 7,TTFLGS(2),10] ;PAGE SIZE
	IDIVI 4,0(3)
	SUBM 3,5		;DIFFERENCE TO END OF PAGE
	POP P,3
	TLNN 3,200000		;REAL OR SIMULATED
	JRST TTSM32		;REAL
	MOVEI 1,12		;SIMULATE WITH LINE FEEDS
TTSM31:	JUMPE 5,TTCOR
	CALL TCOUT
	SOJA 5,TTSM31

TTSM32:	CALL TCOUT		;SEND REAL CHARACTER
	IDIVI 5,10		;PLUS RUBOUTS TO WASTE TIME
	MOVEI 1,177
	AOJA 5,TTSM31

;BACKSPACE

TTSM4:	HRRZ 4,TTLPOS(2)	;REDUCE LINE POSITION
	JUMPE 4,.+2		;IF NOT AT BEGINNING OF LINE
	SOS TTLPOS(2)
	TLNN 3,200000		;REAL OR SIMULATED
	JRST TTCO3
	MOVEI 1,15		;SIMULATE WITH CR AND SPACES (UGH)
	CALL TCOUT
	HRRZ 4,TTLPOS(2)
	MOVEI 1,40
	JUMPE 4,TTCOR
	CALL TCOUT
	SOJA 4,.-2

;CARRIAGE RETURN

TTSM5:	HLLZS TTLPOS(2)		;RESET LINE POSITION
	JRST TTCO3

;EOL

TTSM6:	MOVEI 1,15		;BECOMES CR, LF
	CALL TCOX
	MOVEI 1,12
	JRST TCOX1

;OUTPUT ONE CHARACTER TO SPECIFIED TTY LINE
;CHARACTER IN 1, LINE NUMBER IN 2

TCOUT:	MOVEI 3,3B29		;MODE BITS
	CAIL 2,NTTYS
	 JRST @TCOUTD		; NO PARITY FOR NVT
	CAIGE 1,40		;CONTROL CHARACTER, AND
	TDNN 3,TTFLGS(2)	;NOT BINARY?
	JRST @TCOUTD		;DISPATCH TO APPROPRIATE ROUTINE
	MOVEI 3,0(1)
	IMULI 3,200401		;COMPUTE PARITY FOR CONTROL CHAR
	AND 3,[11111111]
	IMUL 3,[11111111]
	TLNE 3,(1B14)		;(EVEN PARITY) BIT ON?
	TRO 1,200		;YES, PUT (EVEN PARITY) BIT ON
	JRST @TCOUTD

TCOUTX:	SKIPE 3,TTLINK(2)	;LINKS ON THIS LINE?
	CALL TTLNK3		;YES, GO DO THEM
TCOUTY:	LDB 3,TTOMAX		;CAPACITY OF OUTPUT BUFFERS
	CAMG 3,TTOCT(2)		;FULL?
	JRST TCOUT1		;YES
TCEO3:	NOSKD1
	CHNOFF DLSCHN		;MUST PREVENT DEASSIGN OF BUFFERS
	SKIPN 3,TTOIN(2)	;BUFFERS EXIST?
	JRST [	LDB 3,TTNOU	;NO, GET NUMBER TO ASSIGN
		CALL TTGTBF	;ASSIGN THEM
		MOVEM 3,TTOOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK		;END OF BUFFER?
	HRR 3,1-TTSIZ(3)	;YES, GET ADDRESS OF NEXT BUFFER
	IDPB 1,3
	MOVEM 3,TTOIN(2)
	AOS TTOCT(2)
	CHNON DLSCHN		;SAFE TO TURN CHN ON AFTER AOS
	OKSKD1
TCEO1:
IFDEF IMPCHN,<
	CAIL 2,NTTYS		;PSEUDO TTY?
	JRST [	CALL NTTCSO	;YES, DO OUTPUT IF POSSIBLE
		JRST TCEO4]
>
	SKIPGE TTFLGS(2)	;TEST OUTPUT ACTIVE
	JRST .+3
	MOVEM 2,TTNIT1		;SIMULATE INTERRUPT THIS LINE
	ISB DLSCHN
TCEO4:	POP P,3
	JRSTF 0(3)		;RESTORE FLAGS

;SCAN LINK WORD, SENDING CHAR TO LINES SPECIFIED BY NON-0 BYTES

TTLNK3:	PUSH P,2		;SAVE CURRENT LINE NUMBER
TTLNK2:	SETZ 2,
	LSHC 2,^D9		;GET NEXT FIELD
	JUMPE 2,TTLNK1		;0 MEANS NOT USED
	PUSH P,3
	PUSH P,1		;SAVE CHARACTER
	CAIL 2,NTTYS		;NETWORK LINE?
	ANDI 1,177		;YES, FLUSH PARITY BIT
	SKIPE INSKED		;IF INSKED, SEND LINKED OUTPUT
	CALL TCOUTZ		;VIA ECHO ROUTE
	SKIPN INSKED
	CALL TCOUTY		;OTHERWISE VIA NORMAL ROUTE
	POP P,1
	POP P,3
TTLNK1:	JUMPN 3,TTLNK2		;DO MORE IF ANY
	POP P,2			;RESTORE ORIG LINE NUMBER
	RET

;ACTION WHEN BUFFER FULL

TCOUT1:	PUSH P,1		;SAVE CHARACTER
	MOVEI 1,TCOTST		;SETUP SCHEDULER TEST WORD
	HRLI 1,0(2)		;  LINE NO,,TEST ROUTINE ADR
	JSYS EDISMS
	POP P,1
	JRST TCOUTY

;CALLED FROM SCHEDULER TO TEST FOR RUNNABLE

	INTERN TCITST,TCOTST

TCOTST:	MOVEI 2,0(1)		;LINE NUMBER TO REGULAR AC
	LDB 1,TTOWRN		;REGULAR WAKEUP COUNT
	SKIPE FKINT(7)		;BUT IF INTERRUPT WAITING,
	LDB 1,TTOMAX		;WAKEUP IF BUFFER IS NOT FULL
	CAMG 1,TTOCT(2)		;AT OR BELOW WAKEUP LEVEL?
	JRST 0(4)		;NO
	JRST 1(4)		;YES

	SWAPCD

;ROUTINE TO GET CHARACTER FROM TELETYPE
;CONVERT FROM ASCII TO INTERNAL AND GENERATE ECHOS
;AS REQUESTED

TCI:	MOVEI 3,1B34
	TDNE 3,TTFLGS(2)	;REPEAT LAST CHAR?
	JRST TCIRC		;YES
	NOSKED
	SKIPG 1,TTICT(2)		;ANY CHARS IN BUFFER?
	JRST TCI1		;NO
	SKIPN 3,TTIOUT(2)	;GET POINTER
	BUG(HLT,<TCI - NO BUFFER POINTER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)	;NEW BUFFER
	ILDB 1,3
	MOVEM 3,TTIOUT(2)
	CHNOFF DLSCHN
	SOSG TTICT(2)		;REDUCE COUNT, NOW EMPTY?
	JRST [	SETZB 3,TTIOUT(2) ;YES, RELEASE BUFFERS
		EXCH 3,TTIIN(2)
		CALL TTRLBF
		JRST .+1]
	CHNON DLSCHN
	OKSKED
	MOVE 3,TTFLGS(2)
	TRNN 3,3B29		;BINARY?
	JRST TCIR		;YES
	TRNE 3,2B33		;HDX?
	JRST TCIN		;YES, NO DEFERRED ECHOS
	ANDI 3,3B25		;ISOLATE ECHO MODE BITS
	JUMPE 3,TCIN		;NO ECHO
	TRNE 1,400		;HAS CHAR BEEN ECHOED?
	CAIN 3,3B25		;BOTH IMMED AND DEFERRED?
TCIY:	CALL TCO		;YES, DO ECHO
TCIN:	ANDI 1,177
TCIR:	DPB 1,TTYLCH		;SAVE LAST CHAR
	RET

TCIRC:	ANDCAM 3,TTFLGS(2)	;CLEAR BIT
	LDB 1,TTYLCH		;GET LAST CHARACTER
	RET

TTYLCH:	POINT 9,TTMOD1(2),8

;ACTION IF BUFFER IS EMPTY

TCI1:	OKSKED
	HRRZ 3,TTFORK(2)
	CAIE 3,-1		;LINE NOW AVAILABLE?
	JRST TCIF1		;NO
TCIF2:	MOVE 3,FORKN		;GET INDEX OF THIS FORK
	HRRM 3,TTFORK(2)	;RECORD THIS FORK WAITING FOR TTY
IFDEF IMPCHN,<
	CAIL 2,NTTYS		;NETWORK TTY?
	CALL NETCAP		;YES, CHECK ALLOCATE
>
	MOVEI 1,TCITST		;SETUP SCHEDULER TEST WORD
	HRLI 1,0(2)		;  LINE NO,,TEST ROUTINE ADR
	SKIPE TTICT(2)		;STILL EMPTY?
	JRST TCI3		;NO
	CALL TTYBLK		;DISMISS AND ACCOUNT
TCI3:	HLLOS TTFORK(2)		;SET RIGHT HALF TO ONES
	JRST TCI		;TRY AGAIN

TCIF1:	CAMN 3,FORKN		;THIS FORK?
	JRST TCIF2		;OK
	PUSH P,1
	MOVEI 1,0(3)
	ANDI 1,7777
	PUSH P,2
	CALL TTFRKT		;GO RESOLVE CONFLICT BY HALTING FORK
	POP P,2
	POP P,1
	JRST TCIF2

;BLOCK FORK FOR TTY I/O, DO STATISTICS

TTYBLK:	PUSH P,4
	MOVE 4,JOBNO		;GET JOB NUMBER
	HRRZ 4,JOBNAM(4)	;CURRENT SUBSYSTEM INDEX
	MOVE 3,FORKX
	HRRZ 3,FKWSP(3)		;CURRENT SIZE
	HRLI 3,(1B14)		;0-14 IS WAKEUP COUNT
	ADDM 3,SWAKES(4)	;15-35 IS SIZE INTEGRAL
	MOVN 3,TODCLK		;REMEMBER TIME NOW
	JSYS EDISMS		;DISMISS
	ADD 3,TODCLK		;COMPUTE TIME DISMISSED
	ADDM 3,SBLKTM(4)	;ACCUMULATE PER SUBSYSTEM
	AOS TTYBKS		;COUNT TOTAL WAKEUPS
	POP P,4
	RET

;SCHEDULER TEST ROUTINE FOR FORKS WAITING FOR TTY INPUT
;CALLED WITH JSP 4,
;AC 1 CONTAINS LINE NUMBER
;AC 7 CONTAINS FORK NUMBER OF FORK BEING TESTED

	RESCD

TCITST:	HRRZ 2,TTFORK(1)
	TRZN 2,200000		;WAKEUP SEEN?
	JRST 0(4)		;NO, RETURN NO-SKIP
	JRST 1(4)		;YES

;TELETYPE INPUT CHANNEL 7 ROUTINE
;RUN EVERY SO OFTEN TO MOVE CHARACTERS FROM BIG BUFFER TO LINE BUFFERS,
;GENERATE ECHOS AND HANDLE CARRIER TRANSITIONS
;ENTERED BY  CALL  FROM SCHED

	INTERN TTCH7
	EXTERN TTBTIM

TTCH7X:	CONI DLS,1		;CHECK FOR LOST PI
	ANDI 1,7
	CAIN 1,DLSCHN		;CORRECTLY SET?
	JRST .+3		;YES
	AOS DLSLPI		;NO, COUNT LOSSAGES
	CONO DLS,DLSCHN		;AND RESET IT
	SKIPN 1,TTHNGT		;ACTIVE LINE TO BE CHECKED?
	JRST TTHNG1		;NO
	MOVE 2,TTHNGL		;YES, GET LINE NUMBER
	CAML 1,TODCLK		;INTERRUPT OVERDUE?
	JRST TTHNG4		;NO, KEEP WAITING
	AOS TTHNGN		;YES, COUNT UNHANGS
	HRLM 2,TTHNGN		;REMEMBER LAST HUNG LINE
	MOVEM 2,TTNIT1		;SIMULATE OUTPUT INTERRUPT
	ISB DLSCHN
TTHNG1:	AOS 2,TTHNGL		;GET NEXT LINE
	CAIL 2,NTTYS
	SETZB 2,TTHNGL		;WRAPAROUND LINE NUMBERS
	MOVE 1,TODCLK
	ADDI 1,^D500		;HALF-SECOND FROM NOW
	MOVEM 1,TTHNGT		;IS TIME AT WHICH LINE IS CALLED HUNG
	SKIPL TTFLGS(2)		;LINE NOW ACTIVE?
	SETZM TTHNGT		;NO, DON'T CHECK
TTHNG4:	MOVE 2,TTCQLN		;BEFORE LEAVING, CHECK CONTROL ON
	MOVEI 4,10		;A FEW LINES
TTCQ3:	SKIPN 1,TTCS(2)		;ANYTHING ON THIS LINE?
	JRST TTCQ2		;NO
	HRRZ 3,TODCLK		;SEE IF NOW TIME TO DO IT
	ANDI 3,377777
	HLRZ 1,1
	SUB 1,3			;DESIRED TIME MINUS NOW
TTCQ1:	JUMPLE 1,TTCQ4		;0 OR NEGATIVE TIME LEFT TO WAIT
	CAIGE 1,200000		;GREATER THAN MAX POSSIBLE?
	JRST TTCQ2		;NO, KEEP WAITING
	SUBI 1,400000		;ACCOUNT FOR WRAPAROUND
	JRST TTCQ1		;CHECK AGAIN

TTCQ4:	HRRZ 1,TTCS(2)		;GET ADDRESS OF FUNCTION TO DO
	SETZM TTCS(2)		;CLEAR CONTROL STATE
	CALL 0(1)		;DO THE FUNCTION
TTCQ2:	ADDI 2,1		;GO TO NEXT LINE
	CAIL 2,NLINES		;WRAPAROUND
	SETZ 2,
	SOJG 4,TTCQ3		;DONE ENOUGH FOR THIS TIME?
	MOVEM 2,TTCQLN		;YES, START AT THIS LINE NEXT TIME
	MOVEI 1,T7TIM		;SETUP TIME TO NEXT SERVICE
	MOVEM 1,TTBTIM
	RET

;ADD ITEM TO CONTROL QUEUE

TTQAD1:	HRLI 1,^D1000		;ITEM TO BE DONE IN 1 SEC.
TTQAD:	HRLZ 3,TODCLK		;WAIT TIME IN LH OF 1
	TLZ 3,400000		;ROUTINE ADDRESS IN RH OF 1
	ADD 1,3			;COMPUTE TIME TO DO FUNCTION
	MOVEM 1,TTCS(2)
	RET

TTCH7:	SKIPG TTBIGC		;BIG BUFFER EMPTY?
	JRST TTCH7X		;YES, RETURN
	AOS 3,TTBIGO		;NO, GET WORD
	CAIN 3,TTBSIZ		;WRAPAROUND IF NECESSARY
	SETZB 3,TTBIGO
	MOVE 1,TTBBUF(3)
	SOS TTBIGC
	HLRZ 2,1		;GET LINE NUMBER
	TRNE 1,DLSCXF		;CARRIER TRANSITION?
	JRST TT7CX		;YES
	TRNN 1,DLSRCF		;RECEIVER?
	JRST TTCH7		;NO (SHOULD NOT HAPPEN) - RESUME  SCAN
	ANDI 1,377
IFDEF IMPCHN,<
	CAIGE 2,NTTYS		;NETWORK LINE?
	JRST TTNET1		;NO
	CALL NTTRC1		;YES, HANDLE ALLOCATION STUFF
	TRZE 1,200		;TELNET CONTROL CODE?
	JRST TTCH7		;YES, FLUSH IT
	MOVSI 3,IMPTB2
	TDNE 3,TTNETW(2)	;WAS LAST CHAR A CR?
	JRST [	ANDCAM 3,TTNETW(2) ;YES, CLEAR THE BIT
		CAIN 1,12	;AND IS THIS A LF?
		JRST TTCH7	;YES, FLUSH IT
		JRST .+1]	;NO, KEEP IT
	CAIN 1,15		;IS THIS A CR?
	IORM 3,TTNETW(2)	;YES, REMEMBER TO FLUSH FOLLOWING LF
TTNET1:
>
	SKIPGE 3,TTFORK(2)	;ASSIGNED TO A JOB?
	JRST TTC7N		;NO

;CHECK FOR INTERRUPT INDICATING CHARACTER

	MOVEI 4,0(1)
	ANDI 4,177
	CAIGE 4,PSICHL		;TRANSLATE TO INTERRUPT CODE
	JRST TTCH71
	CAIGE 4,PSICHU
	JRST TTCH72		;NOT INTERRUPT CHAR
	SUBI 4,PSICHO
TTCH71:	MOVE 3,PSICH(4)
	CAIN 3,NU		;NOT USED?
	JRST TTCH72		;YES
	MOVE 5,TTPSI(2)		;TERMINAL INTERRUPT MASK
	TDNE 5,BITS(3)		;THIS CODE ASSIGNED?
	JRST TTPSI1		;YES, GO INITIATE INTERRUPT

;DETERMINE ECHO STATUS

TTCH72:	LDB 3,TTIMAX		;CAPACITY OF INPUT BUFFERS
	CAMG 3,TTICT(2)		;FULL?
	JRST [	MOVE 3,TTFLGS(2) ;YES, GET MODE
		TRNN 3,3B29	;BINARY?
		JRST TTCH7	;YES, ECHO NOTHING
		JRST TTCH7F]	;NO, ECHO BELL
	MOVEI 3,TCEOUT		;SETUP OUTPUT (ECHO) DISPATCH
	EXCH 3,TCOUTD
	PUSH P,3		;SAVE CURRENT DISPATCH
	MOVS 3,TTFLGS(2)
	TLNN 3,3B29		;BINARY?
	JRST TTRNE		;YES, NO ECHOS
	ANDI 1,177
	CAIN 1,15		;CR?
	JRST TTREC5		;YES
	TRNE 3,1B21		;HAS LOWER CASE?
	JRST TTREC6		;YES
	CAIE 1,175		;NO, OLD ALTMODES?
	CAIN 1,176
	MOVEI 1,33		;YES, CONVERT TO NEW
	JRST TTREC6

TTREC5:	MOVEI 1,EOL		;END OF LINE CHARACTER
	JRST TTREC2

TTREC6:	TLNN 3,1B31		;CONVERT LC?
	JRST TTREC2		;NO
	CAIGE 1,173		;YES - LC?
	CAIGE 1,140
	JRST TTREC2		;NO
	TRZ 1,40		;YES, CONVERT
TTREC2:	TLCE 3,3B33		;REGULAR FDX LINE?
	JRST TTHDX1		;NO, SOME FLAVOR OF HDX
TTHDX2:	TLNN 3,3B25		;ANY ECHOS?
	JRST TTRNE		;NO
	HRR 3,TTFORK(2)		;GET STATUS OF FORK WAITING FOR INPUT
	TLNE 3,2000		;IMMEDIATE ECHOS?
	JRST TTREC4		;YES
	TRNE 3,200000		;MAYBE - IS FORK WAITING?
	JRST TTRNE		;NO - DEFER ECHOS
TTREC4:	TRO 1,400		;BIT TO DISABLE DEFERRED ECHO THIS CHAR
	CAIE 1,377		;SPECIAL CHAR (RUBOUT)?
	CALL TCOX		;NO - TRANSLATE AND OUTPUT TO ECHO BUFFER

;PUT CHAR IN BUFFER AND CHECK FOR WAKEUP

TTRNE:	SKIPN 3,TTIIN(2)	;INPUT BUFFERS EXIST?
	JRST [	LDB 3,TTNIN	;NO, GET NUMBER TO ASSIGN
		CALL TTGTBF	;ASSIGN THEM
		MOVEM 3,TTIOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	IDPB 1,3
	MOVEM 3,TTIIN(2)
	AOS 3,TTICT(2)
	CAIL 3,TTWKCT		;BUFFER NEARLY FULL?
	JRST TTWKTG		;YES - WAKEUP
	MOVEI 3,0(1)		;NO - WAKEUP CHARACTER?
	ANDI 3,177
	IDIVI 3,6
	ADDI 3,TTWKTB
	HLL 3,CH6TAB(4)
	LDB 4,3			;GET FLAGS THIS CHAR
	LDB 3,[POINT 6,TTFLGS(2),23] ;GET FLAGS THIS FORK
	TDNN 3,4		;ANY THE SAME?
	JRST TTWKT1		;NO DONT WAKE
TTWKTG:	MOVEI 3,200000		;YES - INDICATE WAKEUP READY
	IORM 3,TTFORK(2)
	AOS ISKED
TTWKT1:	POP P,TCOUTD		;RESTORE OUTPUT DISPATCH
	JRST TTCH7		;RESUME BIG BUFFER SCAN

TTCH7F:	MOVEI 1,07		;INPUT BUFFER FULL,
	CALL TCEO2		;ECHO BELL
	JRST TTCH7		;RESUME BUFFER SCAN

;HALF-DUPLEX LOGIC

TTHDX1:	TLCN 3,3B33		;HDX MODE 3?
	JRST TTRNE		;YES, NO ECHOS AT ALL
	TLNN 3,2B33		;MODE 2 OR 1?
	JRST TTHDX2		;1 NOT DEFINED, TREAT AS 0
	CAIE 1,EOL		;NO ECHOS FOR MODE 2 CEPT EOL, TAB, FF
	JRST TTHDX3		;NOT EOL
	MOVEI 1,12		;MUST ECHO LF FOR CR
	CALL TCOX
	MOVEI 1,EOL
	JRST TTRNE

TTHDX3:	CAIN 1,"I"-100		;TAB?
	TRNE 3,(1B2)		;AND NO MECH TAB ON DEVICE?
	JRST TTHDX4		;NO
	JRST TTREC4		;YES, ECHO TO SIMULATE TAB

TTHDX4:	CAIN 1,"L"-100		;FORM?
	TRNE 3,(1B1)		;AND NO MECH FORM ON DEVICE?
	JRST TTRNE		;NO, NO OTHER POSSIBLE ECHOS TO DO
	JRST TTREC4		;YES, ECHO TO SIMULATE FORMFEED

;CARRIER ON/OFF

TT7CX:	MOVEI 3,1		;CARRIER STATE FLAG
	TRNN 1,1B24		;CARRIER NOW ON?
	JRST TTCX1		;NO, OFF
	SKIPGE TTFORK(2)	;TTY ASSIGNED OR
	TDNE 3,TTFLGS(2)	;CARRIER NOT OFF BEFORE?
	JRST TTCH7		;YES, INTERRUPT IS SPURIOUS
	IORM 3,TTFLGS(2)	;UPDATE SOFTWARE FLAG
	MOVEI 1,TTCON		;QUEUE A CHECK TO GO IN 1 SEC.
	CALL TTQAD1
	JRST TTCH7

TTCON:	MOVEI 3,1
	TDNN 3,TTFLGS(2)	;CARRIER STILL ON?
	RET			;NO, IGNORE IT
	SKIPL 3,TTFORK(2)	;JOB ACTIVE HERE?
	JRST TTCH7F		;YES, SEND BELL, OTHERWISE IGNORE
	JRST TTC7SJ		;NO, START JOB

TTCX1:	TDNN 3,TTFLGS(2)	;WAS ON BEFORE?
	JRST TTCH7		;NO, SPURIOUS INTERRUPT
	ANDCAM 3,TTFLGS(2)	;UPDATE SOFTWARE FLAG
	MOVEI 1,TTCOF		;QUEUE A CHECK FOR 1 SEC.
	CALL TTQAD1
	JRST TTCH7

TTCOF:	MOVEI 3,1
	TDNE 3,TTFLGS(2)	;CARRIER STILL OFF?
	RET			;NO, IGNORE
	MOVEI 1,TTHU0		;YES, QUEUE A HANGUP-REACTIVATE SEQUENCE
	CALL TTQAD		;TO START IMMEDIATELY
	SKIPGE TTFORK(2)	;JOB ATTACHED?
	JRST TTCH7		;NO, IGNORE
PTYCOF:	MOVEI 3,^D30		;YES, INITIATE A CODE 30 INTERRUPT
	MOVE 5,TTPSI(2)
	TDNE 5,BITS(3)		;IF ITS ASSIGNED
	JRST TTPSI1
	RET			;OTHERWISE IGNORE

;HANGUP-REACTIVATE SEQUENCE

TTHU0:	MOVEI 1,TTHU0		;MAYBE SAME ROUTINE AGAIN
	SKIPGE TTFLGS(2)	;OUTPUT NOT ACTIVE?
	JRST TTQAD1		;NO, RE-QUEUE THIS ROUTINE FOR 1 SEC.
	MOVSI 3,DLSDLB(2)	;CONSTRUCT DATAO WORD
	HRRI 3,1B27		;DIRECTED LINE+NO XMIT BITS
	DATAO DLS,3
	MOVE 1,[XWD ^D100,TTHU1] ;QUEUE NEXT OP TO GO IN 100 MS.
	JRST TTQAD

TTHU1:	MOVSI 3,DLSDLB(2)	;CONSTRUCT DATAO WORD TO REACTIVATE
	HRRI 3,DLSACT+1B27	;DIRECTED LINE+ACTIVATE+NO XMIT
	DATAO DLS,3
	RET

;RECEIVED CHARACTER ON UNASSIGNED LINE

TTC7N:	ANDI 1,177
	CAIE 1,003		;CONTROL-C?
	JRST TTCH7F		;NO, SEND BELL
TTC7SJ:	SKIPE ENTFLG		;SYSTEM PERMITTING ENTRIES
	TLNN 3,1		;REALLY UNASSIGNED?
	JRST TTCH7		;NO, IGNORE
	MOVSI 1,-2		;YES, SET TO JOB STARTING STATE
	HLLM 1,TTFORK(2)
	MOVEI 1,JOBSRT		;REQUEST SCHEDULER- START JOB
	HRLI 1,0(2)		;ON SPECIFIED TTY LINE
	CALL SCDRQ7
	JRST TTCH7

	EXTERN TTPSRQ

TTPSI1:	CALL TTPSRQ		;REQUEST INTERRUPT FROM PSI SYSTEM
	AOS TTINTS		;COUNT INTERRUPTS
	JRST TTCH7

;ROUTINE TO PUT CHAR IN ECHO BUFFER - CALLED FROM TCO

TCEOUT:	SKIPE 3,TTLINK(2)	;LINKS FOR THIS LINE?
	CALL TTLNK3		;YES, DO THEM
TCOUTZ:	LDB 3,TTOMAX		;OUTPUT BUFFER CAPACITY
	ADDI 3,2		;PLUS RESERVE FOR ECHO
	CAMLE 3,TTOCT(2)	;OUTPUT BUFFER FULL?
	JRST TCEO3		;NO, GO PUT IN OUTPUT BUFFER

TCEO2:	MOVE 3,TTECT(2)		;BUFFER FULL?
	CAIL 3,<TTSIZ-1>*4
	RET			;YES - IGNORE CHARACTER
	NOSKD1
	CHNOFF DLSCHN
	SKIPN 3,TTEIN(2)	;BUFFERS EXIST?
	JRST [	MOVEI 3,1	;NO, ASSIGN 1
		CALL TTGTBF
		MOVEM 3,TTEOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	IDPB 1,3
	MOVEM 3,TTEIN(2)
	AOS TTECT(2)
	CHNON DLSCHN
	OKSKD1
	JRST TCEO1

;TYPE (SHORT) MESSAGE VIA ECHO BUFFER

TTEMES:	PUSH P,1		;GIVEN BYTE POINTER TO STRING IN 1
TTEM1:	ILDB 1,0(P)		;LINE NUMBER IN 2
	JUMPE 1,[POP P,1	;NULL TERMINATES
		RET]
	CALL TCEO2		;OUTPUT VIA ECHO BUFFER
	JRST TTEM1

;DLS CHANNEL INTERRUPT SERVICE
;CALLED WITH JSYS FROM CHANNEL SEQUENCE

	INTERN DLSSV

DLSSV:	XWD XDLSSV,.+1
	SKIPL TTNIT1
	JRST TTNITS
	CONSZ DLS,330		;PI REQ, CAR XITION, XMIT, RECV
	JRST DLSSV2
	CONI TTY,1		;CONSOLE TTY
	TRNE 1,7		;PI ASSIGNED?
	TRNN 1,50		;AND SERVICE NEEDED?
	JRST @XDLSSV		;NO
	JRST TTYSV

;SERVICE DLS

DLSSV2:	DATAI DLS,1
   IFE BBNDLS,<
	TRNE 1,DLSRCF>		;IF NOT RECEIVER FLAG, OR
	TRNE 1,DLSXMF		;IF TRANSMITTER FLAG,
	DATAO DLS,[400+DLSACT]	;RELEASE SCANNER
	HLRZ 2,1		;LINE NUMBER
	CAML 2,LOLIN		;WITHIN PROPER RANGE OF LINES?
	CAML 2,HILIN
	JRST DLSSV3		;UNDEFINED LINE
TTYSV1:	TRNN 1,DLSRCF+DLSCXF	;RECEIVER OR XITION
	JRST DLSSV1
	AOS 3,TTBIGI		;PUT WORD IN BIG BUFFER
	CAIN 3,TTBSIZ
	SETZB 3,TTBIGI		;WRAPAROUND
	MOVEM 1,TTBBUF(3)
	AOS TTBIGC		;COUNT CONTENTS
DLSSV1:   IFE BBNDLS,<
	TRNE 1,DLSRCF>		;IF NOT RECEIVER FLAG, OR
	TRNE 1,DLSXMF		;TRANSMITTER
	JSP 4,TTSND
	TRNE 1,DLSRCF		;RECEIVER
	JFCL 0			;NO SPECIAL ACTION
DLSSV3:	UNBRK DLS

;INITIATED INTERRUPT TO START OUTPUT ON LINE

TTNITS:	MOVEI 1,0
	MOVE 2,TTNIT1		;LINE NUMBER
	SETOM TTNIT1
	JSP 4,TTSND		;DO OUTPUT
	JRST DLSSV3

;CONSTANTS

WRPMSK:	XWD 770000,TTSIZ-1	;MASK FOR WRAPAROUND OF CHAR POINTER

;SERVICE INTERRUPT FROM CONSOLE TTY
;CONSTRUCT WORD LIKE SCANNER DATAI

TTYSV:	MOVEI 1,0
	CONSO TTY,40		;INPUT DONE
	JRST .+3
	DATAI TTY,1
	TRO 1,DLSRCF		;SCANNER RECEIVER BIT
	CONSO TTY,10		;OUTPUT DONE
	JRST .+3
	TRO 1,DLSXMF		;SCANNER TRANSMITTER
	CONO TTY,200+DLSCHN	;TURN OFF OUTPUT DONE
	HRLI 1,CTYLIN		;PSEUDO-LINE NUMBER
	MOVEI 2,CTYLIN
	JRST TTYSV1

DLSVSP:	IOWD NDLSPD,DLSPDL	;INTERRUPT LEVEL STACK POINTER

;SEND CHARACTER TO TTY LINE,
;FROM ECHO BUFFER IF NOT EMPTY, OTHERWISE
;FROM OUTPUT BUFFER IF NOT EMPTY; OTHERWISE
;CLEAR OUTPUT-ACTIVE FLAG

TTSND:	CAMN 2,TTHNGL		;LINE BEING CHECK FOR OUTPUT INTERRUPTS?
	SETZM TTHNGT		;YES, MAKE CHECK OK
	SKIPE TTECT(2)		;CHECK ECHO BUFFER
	JRST TTSNDE
	SKIPE TTOCT(2)		;CHECK OUTPUT BUFFER
	JRST TTSNDO
	MOVSI 3,400000
	ANDCAM 3,TTFLGS(2)	;CLEAR OUTPUT-ACTIVE
	MOVEM P,DLSVAP		;SETUP STACK
	MOVE P,DLSVSP
	CALL TTRLOB		;RELEASE OUTPUT BUFFERS, SINCE EMPTY
	MOVE P,DLSVAP
	JRST TTSND1

TTSNDE:	SKIPN 3,TTEOUT(2)	;GET POINTER
	BUG(HLT,<TTY ECHO OUTPUT - NO BUFFER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	MOVEM 3,TTEOUT(2)	;WRAP POINTER
	ILDB 3,TTEOUT(2)
	SOS TTECT(2)
	JRST TTSND2

TTSNDO:	SKIPN 3,TTOOUT(2)	;GET BUFFER POINTER
	BUG(HLT,<TTY OUTPUT - NO BUFFER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	MOVEM 3,TTOOUT(2)	;WRAP POINTER
	ILDB 3,TTOOUT(2)
	SOS TTOCT(2)
TTSND2:	ANDI 3,377
	CAIE 2,CTYLIN		;IS CONSOLE TTY?
	JRST TTSND5		;NO
	DATAO TTY,3		;YES
	JRST TTSND4

TTSND5:	HRLI 3,DLSDLB(2)	;DIRECTED LINE BIT
	IORI 3,DLSACT		;ACTIVATE BIT
	DATAO DLS,3
TTSND4:	MOVSI 3,400000
	IORM 3,TTFLGS(2)	;SET OUTPUT-ACTIVE
TTSND1:	JRST 0(4)

	SWAPCD

IFDEF DTAN,<
	BEGINP	DECTAPE		R.S.TOMLINSON	3 DEC 71 1710:

; Entries to the part

INTERN	DTASV	; Flag interrupt routine
INTERN	DTARST	; Restart dta
INTERN	DTACHK	; Dta clock check routine

; Externally defined symbols used herein

EXTERN	EDISMS	; Dismiss until test succeeds
EXTERN	NSKED	; No-schedule flag
EXTERN	RSKED	; Pending schedule waiting
EXTERN	MLKPG	; Lock a page of monitor
EXTERN	MULKPG	; Unlock a page of monitor
EXTERN	FPTA	; Convert address to ptn.pn
EXTERN	DTDCHN	; Data interrupt channel
EXTERN	DTACHN	; Flag interrupt channel
EXTERN	DTACHR	; Return from dectape interrupt
EXTERN	DTABIT	; Pi bit for dtachn
EXTERN	DTATIM	; Dta clock word

; Accumulators used locally

DIR_4		; Pointer to directory entry
?UNIT_5		; Dectape unit number
?IOS_6		; Device status word

DEFINE	NOSKED<AOS NSKED>
DEFINE	OKSKED<SOSG NSKED
	XCT RSKED>
DEFINE	PIOFF<NOSKED
	CONO PI,1000+DTABIT>
DEFINE	PION <CONO PI,2000+DTABIT
	OKSKED>

; Parameters

?PI__4
?DTC_320			; Device definitions
?DTS_324
DEFINE DTALOC<40+2*DTDCHN>	; Define interrupt location for data
DEFINE DTBOTH<10*DTDCHN+DTACHN>	; Interrupt assignment bits
DEFINE DTTURN<DTBOTH+300200>	; Cono to turn around
DTTRY__7			; Times to try on errors
DIRBLK__=100			; Block number for directory
TOPBLK__1101			; Last legal block number
NAMSTR__=83			; Location of first name in directory
EXTSTR__=105			; Location of first extension
QUANT__5			; Blocks before relinquishing control
MINDIS__14			; Min dead reckoning search
SPACE__3			; Minimum spacing of successive blocks
NBUF__3*DTAN+2			; Number of buffers is one for read
				; One for write, one for directory, and
				; 2 more for double buffering 1st files
NBUF__(NBUF+3)/4*4		; Round to next higher page boundary
NDBMSK_-1(=36-3*DTAN)		; Mask for unavailble 2nd buffers

; Private storage for dectapes

LS(DTALCK,DTAN)	; Lock word
LS(DTASTS,DTAN)	; Lh ==> status bits (see below)
		; Rh ==> directory location (0 if none)
LS(DTIBF1,DTAN)	; Bit 0 ==> buffer busy
		; Bit 1 ==> error in this buffer
		; Bits 2-11 ==> next input block number
		; Bits 13-17 ==> input file number
		; Rh ==> location of input buffer 1
LS(DTIBF2,DTAN)	; Bit 0 ==> buffer busy
		; Bit 1 ==> error in this buffer
		; Bits 2-11 ==> current block number
		; Bit 12 ==> if doing a nop spacing (rew etc)
		; Bit 13 ==> if unloading
		; Rh ==> location of input buffer 2 (0 if none)
LS(DTOBF1,DTAN)	; Bit 0 ==> buffer busy
		; Bit 1 ==> error in this buffer
		; Bits 2-11 ==> next output block number
		; Bit 12 ==> last buffer
		; Bits 13-17 ==> output file number
		; Rh ==> location of output buffer 1
LS(DTOBF2,DTAN)	; Bit 0 ==> buffer busy
		; Bit 1 ==> error in this buffer
		; Bits 2-11 ==> first block number of output file
		; Bit 12 ==> last buffer
		; Rh ==> location of output buffer 2 (0 if none)
LS(DTAPTR,DTAN)	; Temp pointer to directory entry
LS(DTAIOW,DTAN)	; Iowd during dead reckoning
LS(DTARKN,DTAN)	; Bit 0 ==> dead reckoning for a write
		; Bit 1 ==> going backward
		; Bits 8-17 ==> block number
		; Rh ==> chain to next dead reckoning unit (-1 if end)
LS(DTARCE,DTAN)	; Total error count
NRP(DTABUF,NBUF*200)	; Dectape buffers
LS(PNTR)	; Iowd for blki/o
LS(SVPNTR)	; Saved pntr for retries
LS(DTAUNT)	; Unit number of currently attached drive
LS(DTAUNS)
LS(DTREQ)	; Non-zero if another dectape request is pending
LS(DTDTMP)	; Temp for data interrupt channel
LS(DTABLK)	; Block number currently being sought
LS(QUANTM)	; Count of operations for currently attached drive
LS(DTERRC)	; Error counter
LS(DTASKP)	; Skip count for short records in reverse
LS(DTAWST)	; Waste word for skipping words in reverse
LS(DTABIO)	; Blki or blko dtc,for data xfer
LS(DTAOPR)	; Current operation (read or write)
LS(DTDINR)	; Return address for dectape interrupt routine
LS(DTSINR)	; Return address for dectape interrupt routine
LS(DTBFAV)	; Word of available buffers
LS(DTBLCK)	; Lock for above word

; Pointers to fields of dectape variables

USE

PCBLK:	POINT 10,DTIBF2(UNIT),11
PIBLK:	POINT 10,DTIBF1(UNIT),11
PFBLK:	POINT 10,DTOBF2(UNIT),11
POBLK:	POINT 10,DTOBF1(UNIT),11
PIFILN:	POINT 5,DTIBF1(UNIT),17
POFILN:	POINT 5,DTOBF1(UNIT),17

DTASPC:	SPACE			; MIN BLOCK SPACING

USE	SWAPPC

; Flags in lh(dtasts) (also ios at times)

FLG(IO,L,IOS,400000)	; 1 if current activity is output on this unit
FLG(INOPN,L,IOS,200000)	; Input side of dta is open
FLG(OUOPN,L,IOS,100000)	; Output side of dta open
FLG(ABFIP,L,IOS,040000)	; Alternate buffer for input program
FLG(ABFII,L,IOS,020000)	; Alternate buffer for input interrupt
FLG(ABFOP,L,IOS,010000)	; Alternate buffer for output program
FLG(ABFOI,L,IOS,004000)	; Alternate buffer for output interrupt
FLG(RVRS,L,IOS,002000)	; Blocks being assigned in reverse order
FLG(ACTO,L,IOS,001000)	; Output active
FLG(ACTI,L,IOS,000400)	; Input active
FLG(NSTD,L,IOS,000200)	; Tape in non-standard mode
FLG(FSTBK,L,IOS,000100)	; Looking for first block
FLG(RWDIR,L,IOS,000040)	; Reading or writing the directory
FLG(^DIRIC,L,IOS,000020); Directory in core
FLG(MNTF,L,IOS,000010)	; Unit is mounted
FLG(OUERR,L,IOS,000004)	; Output error flag
FLG(FULF,L,IOS,000002)	; Tape full flag
FLG(TFLG1,L,IOS,000001)	; Temp flag

; Dispatch table

^DTADTB:DTASET		; Directory setup
	DTANAM		; Name lookup
	DTAEXT		; Extension lookup
	DTAVER		; Version lookup (always succeeds)
	CPOPJ		; Protection insertion
	CPOPJ		; Account insertion
	CPOPJ		; Status modification
	DTAOPN		; Open file
	DTASQI		; Sequential input
	DTASQO		; Sequential output
	DTACLZ		; Close file
	DTAREN		; Rename file
	DTADEL		; Delete file
	DTDMPI		; Dump input
	DTDMPO		; Dump output
	DTAMNT		; Mount
	DTADSM		; Dismount
	DTINID		; Initialize directory
	DTMTP		; Mtape
	CPOPJ		; Get status
	CPOPJ		; Set status

; Initialize dectape controller

USE

^DTAINI:CONO DTC,0		; Stop all activity
	SETZM DTAUNT		; No unit currently attached
	SETZM DTAUNS
	MOVSI UNIT,-DTAN
DTAIN1:	FOR A IN (DTASTS,DTIBF1,DTIBF2,DTOBF1,DTOBF2),<
	SETZM A(UNIT)>
	SETOM DTALCK(UNIT)
	AOBJN UNIT,DTAIN1
	MOVSI B,400000
	ASH B,-NBUF+1		; Get a one for each buffer
	MOVEM B,DTBFAV		; Save as record of available buffers
	SETOM DTBLCK		; And leave unlocked
	MOVEI A,DTAN
DTAIN2:	SOJL A,CPOPJ
	HRRZ B,A
	LSH B,11
	CONO DTC,30000(B)	; Select the unit
	CONSZ DTS,100		; See if it's on-line
	JRST DTAIN2		; Not online, try next
	HRLM A,(P)		; Save unit number
	PUSHJ P,DTAIN2		; And get others
	HLRZ A,(P)		; Get the unit number back
	HRLI A,600003
	MOUNT
	BUG(CHK,<DTAINI: CANNOT MOUNT SELECTED DECTAPE.>)
	POPJ P,

; Restart dectape

DTARST:	SETZM DTAUNT
	HRROI UNIT,DTAN-1
	JRST DTANXT

; Mount dectape
; Call:	A	; Unit
;	B	; Bit 0, 1 if no directory, rest reel number
;	PUSHJ P,DTAMNT
; Return
;	+1	; Error, already mounted
;	+2	; Ok

DTAMNT:	MOVEI UNIT,(A)
	NOINT
	LOCK DTALCK(UNIT)
	PIOFF			; Disable ints so dtasts wont change
	MOVE IOS,DTASTS(UNIT)
	TEST(OE,MNTF)
	JRST DTAMN1		; Already mounted
	JUMPL B,DTAMN2		; No directory
	TEST(O,RWDIR)
	HLLM IOS,DTASTS(UNIT)
	PION
	PUSHJ P,ASGBUF
	HRRM A,DTASTS(UNIT)
	PUSHJ P,DTSTRI		; Start reading the directory
	AOS (P)
	JRST DTAMN3

DTAMN2:	HLLM IOS,DTASTS(UNIT)
	AOS (P)
DTAMN1:	PION
DTAMN3:	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

USE	SWAPPC

; Dismount dectape
; Call:	A	; Unit
;	PUSHJ P,DTADSM
; Return
;	+1	; Cannot dismount (not mounted or files open)
;	+2	; Ok

DTADSM:	MOVEI UNIT,(A)
	NOINT
	LOCK DTALCK(UNIT)
	MOVSI IOS,INOPN!OUOPN
	TDNE IOS,DTASTS(UNIT)
	JRST [	UNLOCK DTALCK(UNIT)
		OKINT
		POPJ P,]
	MOVSI IOS,MNTF
	TDNN IOS,DTASTS(UNIT)
	JRST [	UNLOCK DTALCK(UNIT)
		OKINT
		POPJ P,]
	MOVSI A,RWDIR
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVSI IOS,MNTF!DIRIC
	ANDCAB IOS,DTASTS(UNIT)
	HRRZ A,DTASTS(UNIT)
	HLLZS DTASTS(UNIT)
	SKIPE A
	PUSHJ P,RELBUF
	UNLOCK DTALCK(UNIT)
	OKINT
	JRST SKPRET

; Initialize dectape directory
; Call:	1	UNIT
;	PUSHJ P,DTINID
; Return
;	+1	; Error, not mounted
;	+2	; Ok

DTINID:	MOVEI UNIT,(1)
	NOINT
	LOCK DTALCK(UNIT)
	MOVE IOS,DTASTS(UNIT)
	TEST(NN,MNTF)
	JRST DTIND1		; Not mounted, error!
	MOVSI A,INOPN!OUOPN
	TDNE A,DTASTS(UNIT)
	JRST DTIND1
	MOVSI A,RWDIR
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVE IOS,DTASTS(UNIT)
	TEST(NE,DIRIC)
	JRST DTIND2
	PUSHJ P,ASGBUF
	HRRM A,DTASTS(UNIT)
DTIND2:	HRRZ A,DTASTS(UNIT)
	HRLI B,(A)
	HRRI B,1(A)
	SETZM (A)
	BLT B,177(A)
	MOVE B,[BYTE (5)36,36]
	MOVEM B,(A)
	MOVE B,[BYTE (5)0,36]
	MOVEM B,16(A)
	MOVE B,[BYTE (5)0,0,0,37,37,37,37]
	MOVEM B,=82(A)
	MOVSI IOS,RWDIR!DIRIC
	IORB IOS,DTASTS(UNIT)
	PUSHJ P,DTSTRO
	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

DTIND1:	UNLOCK DTALCK(UNIT)
	POPJ P,

; Directory setup
; Call:	B	; Unit number
;	PUSHJ P,DTASET
; Return
;	+1	; Error, no directory for this device
;	+2	; Ok
;	DIR	; As required for "dtanam"
;		; The dectape is locked

USE

DTASET:	MOVEI UNIT,(B)		; Set up unit
DTASE0:	NOINT
	LOCK DTALCK(UNIT)
	PIOFF
	MOVE IOS,DTASTS(UNIT)
	TEST(NN,MNTF)
	JRST DTASEE		; Not mounted
	TEST(NE,RWDIR)
	TEST(NE,IO)
	JRST DTASE1		; Ok if directory in core
	PION
	UNLOCK DTALCK(UNIT)
	OKINT
	MOVSI A,RWDIR
	PUSHJ P,DISBIT
	JRST DTASE0

DTASE1:	TEST(NN,DIRIC)
	JRST DTASEE
	HRRZ DIR,DTASTS(UNIT)
	HRLI DIR,-=22
	TEST(O,NVERF)
	AOS (P)
	AOS (P)
	NOINT			; So when we leave we will be non-int
DTASEE:	PION
	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

USE	SWAPPC

; Name lookup
; Call:	DIR	; Aobjn pointer to first name
;	UNIT	; Unit number
;	A	; Lookup pointer

DTANAM:	JUMPE A,DTAFNM
	PUSH P,DIR
	PUSHJ P,ASCSIX		; Convert input to sixbit
	JRST [	POP P,DIR
		JRST ERRET]
	POP P,DIR
DTANA1:	MOVE C,NAMSTR(DIR)	; Get a name
	JUMPE C,DTANA0
	CAMN C,A		; Exact match?
	JRST DTAFNZ		; Yes
	AND C,B			; No
	CAMN C,A		; Partial match?
	JRST DTANA2		; Yes
DTANA0:	AOBJN DIR,DTANA1	; Scan through all files
	TEST(NE,NREC,NREC1)	; Recognition wanted?
	JRST DTANNW		; No, see if new files are ok
	MOVEI A,GJFX18
	TEST(NE,AMBGF)		; More than one partial match found?
	JRST AMBRET		; Yes, give ambiguous return
	TEST(NN,MTCHF)		; Was a match found?
	JRST ERRET		; No, give error return
	MOVE DIR,DTAPTR(UNIT)	; Get pointer to the directory entry
	ANDCA B,NAMSTR(DIR)	; Get tail of the name
DTAUNQ:	JUMPE B,DTANA3
	TLNE B,770000		; Left justify it
	JRST DTANA3
	ROT B,6
	JRST DTAUNQ

DTAFNZ:	TEST(NE,STEPF)
	TEST(NN,NAMSF)
	JRST DTANA9
DTAFNY:	AOBJN DIR,DTAFNM
DTAFNX:	MOVEI A,GJFX18
	JRST ERRET

DTAFNM:	MOVEM DIR,DTAPTR(UNIT)
	SKIPN B,NAMSTR(DIR)
	JRST DTAFNY
	MOVE C,DTASTS(UNIT)
	HRLI C,-=22
DTAFNV:	CAMN C,DIR
	JRST DTAUNQ		; Never seen this name before
	CAMN B,NAMSTR(C)	; Have we seen this
	JRST DTAFNY		; Yes, try again
	AOBJN C,DTAFNV
	JRST DTAFNX

DTANA3:	MOVEI A,0		; Prepare to unpack tail
	ROTC A,6		; Get a character
	JUMPE A,DTANA5		; Done if zero
	ADDI A,40		; Else convert to ascii
	IDPB A,FILOPT(JFN)	; And deposit on the end 
	JRST DTANA3		; Copy all characters

DTANA5:	MOVE B,FILOPT(JFN)
	IDPB A,B		; Deposit a null at the end
	MOVE DIR,DTAPTR(UNIT)
DTANA9:	MOVE B,DIR		; Leave the pointer in b and dir
	TEST(NE,UNLKF)
	JRST SK2RET		; Done if unlkf=1
	AOS (P)
AMBRET:	TEST(NN,UNLKF)
	AOS (P)			; Single skip if unlkf=1 and ambiguous
ERRET:	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

DTANA2:	TEST(ON,MTCHF)		; Partial match found, any previous?
	JRST [	MOVEM DIR,DTAPTR(UNIT)
		JRST DTANA0]
	MOVE C,DTAPTR(UNIT)
	MOVE C,NAMSTR(C)
	CAME C,NAMSTR(DIR)
	TEST(O,AMBGF)
	JRST DTANA0

DTANNW:	MOVEI A,GJFX24
	TEST(NE,OLDNF)		; Are new names allowed?
	JRST ERRET		; No, error
	PUSHJ P,FNDNUL		; Yes, is there room for one?
	JRST [	MOVEI A,GJFX23
		JRST ERRET]	; No room
	TEST(O,NEWF)		; Remember this is to be a new file
	JRST DTANA9		; And proceed as for exact match

; Lookup dectap extension
; Call:	B	; Pointer to first name
;	A	; Lookup pointer
;	UNIT	; Unit number
;	PUSHJ P,DTAEXT
; Return
;	+1	; Not found
;	+2	; Ambiguous
;	+3	; Match found

DTAEXT:	JUMPE A,DTAFEX
	PUSH P,B
	PUSHJ P,ASC3SX		; Convert three characters to sixbit
	JRST [	POP P,DIR
		POPJ P,]
	POP P,DIR
	TEST(NE,NEWF)
	JRST DTANA9		; Always successful if new file
DTAEX1:	HLLZ C,EXTSTR(DIR)	; Get the extension of this entry
	CAMN C,A		; Exact match?
	JRST [	TEST(NE,STEPF)
		TEST(NN,EXTSF)
		JRST DTANA9
		JRST DTAEX4]
	AND C,B			; Get rid of tail
	CAMN C,A		; Partial match?
	JRST DTAEX2		; Yes
DTAEX0:	MOVE C,NAMSTR(DIR)	; Get the name of this file
	AOBJP DIR,DTAEX3
	CAME C,NAMSTR(DIR)
	JRST .-2		; Scan for a file of the same name
	JRST DTAEX1
DTAEX3:	TEST(NE,NREC,NREC1)	; No matches, recognition allowed?
	JRST DTANNW		; No, check for allowed new files
	MOVEI A,GJFX19
	TEST(NE,AMBGF)		; More than one partial match found?
	JRST AMBRET		; Yes, give ambiguous return
	TEST(NN,MTCHF)		; Was one match found?
	JRST ERRET		; No, give error return
	MOVE DIR,DTAPTR(UNIT)
	ANDCA B,EXTSTR(DIR)	; Get the tail of the extension
	HLLZS B
	JRST DTAUNQ		; And copy to input string

DTAEX2:	TEST(OE,MTCHF)		; Remember a match was found
	TEST(OA,AMBGF)		; If match already, remember ambiguous
	MOVEM DIR,DTAPTR(UNIT)	; Save the pointer to the first match
	JRST DTAEX0		; And continue scan

DTAVER:	MOVEI A,0
	TEST(NE,UNLKF)
	JRST SKPRET
	UNLOCK DTALCK(UNIT)
	OKINT
	JRST SKPRET


DTAEX4:	MOVE C,NAMSTR(DIR)
	MOVEI A,GJFX19
	AOBJP DIR,ERRET
	CAME C,NAMSTR(DIR)
	JRST .-2
	MOVE B,DIR
DTAFEX:	MOVEM B,DTAPTR(UNIT)
	HLLZ B,EXTSTR(B)
	JRST DTAUNQ

; Delete file

DTADEA:	HLRZ UNIT,DEV
	TEST(Z,NEWF,OLDNF)
	HRRZ A,FILNEN(JFN)
	PUSHJ P,EXTLUU
	POPJ P,
	POPJ P,
	SKIPN NAMSTR(DIR)
	JRST DTADES
	HLRE B,DIR
	ADDI B,=23
	LDB C,PIFILN
	MOVSI A,INOPN
	TDNE A,DTASTS(UNIT)
	CAME B,C
	JRST DTADE1
	UNLOCK DTALCK(UNIT)
	POPJ P,

DTADE1:	LDB C,POFILN
	MOVSI A,OUOPN
	TDNE A,DTASTS(UNIT)
	CAME B,C
	JRST DTADE3
	UNLOCK DTALCK(UNIT)
	POPJ P,

DTADE3:	SETZM NAMSTR(DIR)
	MOVEI A,1
DTADE2:	PUSHJ P,BLKSR0
	JRST SKPRET
	PUSH P,A
	MOVEI A,0
	DPB A,C
	POP P,A
	JRST DTADE2

DTADEL:	PUSHJ P,DTADEA
	POPJ P,
DTADE9:	MOVSI IOS,RWDIR
	IORB IOS,DTASTS(UNIT)
	PUSHJ P,DTSTRO
DTADES:	UNLOCK DTALCK(UNIT)
	JRST SKPRET

; Rename dectape file
; Call:	A	; Jfn of old file
;	JFN	; Jfn of new file name
;	PUSHJ P,DTAREN

DTAREN:	PUSH P,A		; Save old name jfn
	PUSHJ P,DTADEA		; Delete any existing version of new
	JFCL
	EXCH JFN,(P)		; Get old name jfn, save new
	SETZB F,F1
	HRRZ A,FILNEN(JFN)	; Get extension
	PUSHJ P,EXTLUU		; And lookup old file
	JFCL
	JRST [	POP P,A
		POPJ P,]
	POP P,JFN
	HLRZ A,FILNEN(JFN)	; Get name block of new name
	PUSH P,DIR
	PUSHJ P,ASCSIX		; Convert to sixbit
	BUG(HLT,<DTAREN: ASCSIX FAILURE ON PREVIOUSLY OK NAME.>)
	MOVE DIR,(P)
	MOVEM A,NAMSTR(DIR)	; Store new name
	HRRZ A,FILNEN(JFN)
	PUSHJ P,ASC3SX		; Convert extension to sixbit
	BUG(HLT,<DTAREN: ASC3SX FAILURE ON PREVIOUSLY OK EXTENSION.>)
	POP P,DIR
	HLLM A,EXTSTR(DIR)
	JRST DTADE9		; Finish by writing directory

; Open a dectape file
; Call:	LH(STS)	; Access desired
;	RH(STS)	; Byte size and mode
;	PUSHJ P,DTAOPN
; Return
;	+1	; Error, cannot open, reason in a
;	+2	; Ok, the file is opened

DTAOPN:	HLRZ UNIT,DEV
	MOVE IOS,DTASTS(UNIT)
	TLNE STS,74000		; Xct etc modes not allowed
	JRST DTAACC		; Return error
	HRRZ A,FILNEN(JFN)
	PUSHJ P,EXTLUU		; Files. lookup the file name
	JRST DTANXN		; Non-existent name
	JRST NONSTD		; No directory, check for non-standard
	LDB A,[POINT 4,STS,9+18]
	JUMPN A,DTILM		; Illegal mode
	TEST(NE,WRTF)		; Write access desired?
	JRST DTAW		; Yes.
	TEST(NN,READF)		; Read access desired?
	JRST DTAAC1		; No, user spastic, no access desired

DTAR:	SKIPN NAMSTR(DIR)
	JRST DTILR		; Cannot read new file
	TEST(NE,INOPN)		; Is this unit open for input already?
	JRST INBUSY		; Yes, busy
	PUSHJ P,WTDIR		; Wait for directory write if necessary
	HLRES B			; Get file number of this file
	ADDI B,=23
	DPB B,PIFILN		; Deposit as input file number
	PUSHJ P,SAMWAT		; Wait if same file being written
	JRST BUSY
	LDB A,PCBLK		; Get current block number
	SUBI A,SPACE
	PUSHJ P,BLKSRB		; Search for a block of the file
	JRST EMPTY		; No blocks, give immediate eof
	DPB A,PIBLK		; Store as block number for input
	SETZM FILBYN(JFN)
	PUSHJ P,BLKCNT		; Count number of blocks in this file
	IMULI A,177		; Times number of data words per block
	MOVEM A,FILLEN(JFN)	; Gives best estimate of file length
	LDB B,PBYTSZ		; Get file's byte size
	MOVEI A,=36
	PUSHJ P,NFBSZ		; Convert fillen to desired byte size
	MOVSI A,FSTBK!INOPN
	IORM A,DTASTS(UNIT)	; Say looking for the first block
	MOVSI A,ABFIP!ABFII
	ANDCAM A,DTASTS(UNIT)	; Start with 1st buffers, (not altrnt)
	MOVSI A,400000
	IORM A,DTIBF1(UNIT)	; Make both buffers busy
	IORM A,DTIBF2(UNIT)
	PUSHJ P,ASGBUF		; Get a buffer
	HRRM A,DTIBF1(UNIT)	; For input
	PUSHJ P,ASGBF1		; Assign second buffer if available
	HRRM A,DTIBF2(UNIT)	; Yields 0 if none
	PUSHJ P,DTSTRI		; Mark input active, and start dta
	TEST(O,WNDF)		; Flag that byte pointer must be set
	UNLOCK DTALCK(UNIT)
	OKINT
	JRST SKPRET

DTAW:	TEST(NE,READF)		; Write desired, read also?
	JRST DTAAC1		; Yes, can't be done
	TEST(NE,OUOPN)		; Output side already open?
	JRST OUBUSY		; Yes, return busy
	PUSHJ P,WTDIR		; Wait for directory write if necessary
	HLRES B			; Get file number
	ADDI B,=23
	DPB B,POFILN		; Save as output file number
	PUSHJ P,SAMWAT		; Wait if same file being read
	JRST BUSY
	LDB B,PBYTSZ		; Get desired byte size
	MOVEI A,=36
	PUSH P,DIR		; Save dir cause nfbsz clobers
	PUSHJ P,NFBSZ
	POP P,DIR
	LDB B,POFILN
	SKIPE NAMSTR(DIR)
	JRST DTAW0
	HLRZ A,FILNEN(JFN)
	PUSH P,DIR
	PUSHJ P,ASCSIX		; Get sixbit of name
	BUG(HLT,<DTAOPN: ASCSIX FAILURE ON PREVIOUSLY OK NAME.>)
	POP P,DIR
	MOVEM A,NAMSTR(DIR)	; Store in directory
	HRRZ A,FILNEN(JFN)
	PUSH P,DIR
	PUSHJ P,ASC3SX		; Get sixbit of extension
	BUG(HLT,<DTAOPN: ASC3SX FAILURE ON PREVIOUSLY OK EXTENSION.>)
	POP P,DIR
	HLLZM A,EXTSTR(DIR)	; Store as extension
	JRST DTAW1

DTAW0:	MOVEI A,1
	PUSHJ P,BLKSR0		; Search for a block of the file
	JRST DTAW1		; None left
	PUSH P,A
	MOVEI A,0
	DPB A,C			; Deposit a 0 over it to deassign
	POP P,A
	JRST DTAW0		; And find next block

DTAW1:	GTAD			; Get current time and date
	SKIPGE B,A
	JRST DTAW1A		; No date, skip it
	PUSH P,4		; Preserve ac4
	SETZ 4,			; No special conversion
	ODCNV			; Convert to month day year
	HLRZ A,B		; Extract year
	SUBI A,=1964		; Make relative to 1964 ala dec
	IMULI A,=12		; Repack like dec dates
	ADDI A,(B)		; Month
	IMULI A,=31
	HLRZS C
	ADD A,C			; Day
	POP P,4
	HRRM A,EXTSTR(DIR)
DTAW1A:	SETZB A,B		; Search for free block from 0
	PUSHJ P,BLKSRB		; Backward
	JRST FULL		; None found
	LDB B,POFILN
	DPB B,C			; Assign it
	DPB A,POBLK		; Deposit as first output block
	DPB A,PFBLK		; Save as first block of file
	MOVSI A,OUOPN
	IORM A,DTASTS(UNIT)
	MOVSI A,ABFOP!ABFOI!OUERR
	ANDCAM A,DTASTS(UNIT)	; Not using alternate buffer
	MOVSI A,(1B0+1B12)
	ANDCAM A,DTOBF1(UNIT)	; Neither buffer is busy
	ANDCAM A,DTOBF2(UNIT)
	PUSHJ P,ASGBUF
	HRRM A,DTOBF1(UNIT)
	PUSHJ P,ASGBF1
	HRRM A,DTOBF2(UNIT)
	SETZM FILBYN(JFN)
	SETZM FILLEN(JFN)
	TEST(O,WNDF)
	UNLOCK DTALCK(UNIT)
	OKINT
	JRST SKPRET

SAMWAT:	PUSH P,A
	PUSH P,B
	LDB A,PIFILN
	LDB B,POFILN
	TEST(NE,INOPN,OUOPN)
	CAME A,B
	AOS -2(P)
	POP P,B
	POP P,A
	POPJ P,

NONSTD:	NOINT
	LOCK DTALCK(UNIT),<PUSH P,LCKTST>
	LDB A,[POINT 4,STS,35]
	CAIE A,17		; Dump mode?
	JRST DTILM		; Illegal mode
	TEST(NE,OUOPN,INOPN)
	JRST BUSY
	MOVSI A,OUOPN!INOPN!NSTD
	IORB A,DTASTS(UNIT)	; Set active bits and non-standard bit
	MOVEI A,1
	DPB A,PIBLK
	DPB A,POBLK		; Set input and output block numbers
	UNLOCK DTALCK(UNIT)
	OKINT
	JRST SKPRET

^DRWAIT:MOVE UNIT,1
WTDIR:	MOVSI A,RWDIR
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	POPJ P,

DTANXN:	MOVEI A,OPNX2		; Non-existent file
	POPJ P,

DTAACC:	MOVEI A,OPNX15		; Illegal access
	POPJ P,

DTAAC1:	MOVEI A,OPNX15		; Illegal access
DTAOPE:	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

EMPTY:	TEST(O,EOFF)		; Empty file
	SETZM FILLEN(JFN)
	AOS (P)
	JRST DTAOPE

FULL:	MOVEI A,OPNX10		; No room for new file
	JRST DTAOPE

DTILM:	MOVEI A,OPNX14		; Illegal mode
	JRST DTAOPE

DTILR:	MOVEI A,OPNX2		; Attempting to read a new file
	JRST DTAOPE

INBUSY:
OUBUSY:
BUSY:	MOVEI A,OPNX9		; Dectape busy
	JRST DTAOPE

; Directory block assignment and search routines

; Search backward
; Call:	A	; Starting block number
;	B	; Entry number to search for
;	PUSHJ P,BLKSRB
; Return
;	+1	; None-found
;	+2	; Ok
;	A	; Blk number

USE

BLKSRB:	MOVSI IOS,RVRS
	IORB IOS,DTASTS(UNIT)	; Force reverse
BLKSRC:	TEST(Z,TFLG1)		; Entry to search in current direction
BLKSR0:	CAIGE A,1
	MOVEI A,1
	CAILE A,TOPBLK
	MOVEI A,TOPBLK
	PUSH P,B
	PUSH P,A
	PUSHJ P,SETPTR		; Compute byte pointer
	POP P,A
BLKSRL:	LDB B,C
	CAMN B,(P)
	JRST [	POP P,B
		JRST SKPRET]
	TEST(NE,RVRS)
	JRST BLKSR1
BLKLUP:	CAIL A,TOPBLK		; At end?
	JRST BLKSR2		; Yes, change direction
	IBP C			; No, increment to next block
	AOJA A,BLKSRL

BLKSR2:	TEST(C,RVRS)		; Complement cirection
	TEST(ON,TFLG1)		; First reversal?
	JRST BLKSRL
	POP P,B
	POPJ P,			; Entire tape scanned without luck

BLKSR1:	CAIG A,1		; At beginning?
	JRST BLKSR2		; Yes, change direction
	JUMPL C,BLKSR3		; No, decrement and continue
	ADD C,[BYTE (6)5]
	JUMPG C,BLKSR4
	HRLI C,010500
	SOJA C,BLKSR4

BLKSR3:	HRLI C,060500
	SOS C
BLKSR4:	SOJA A,BLKSRL

; Count number of blocks in a particular file
; Call:	B	; File number
;	PUSHJ P,BLKCNT
; Return
;	+1
;	A	; Number of blocks

BLKCNT:	MOVEI A,1
	PUSH P,[0]
	TEST(O,TFLG1)		; Quit on first reversal
	TEST(Z,RVRS)
	PUSHJ P,BLKSR0
BLKCN1:	JRST [	POP P,A
		POPJ P,]
	AOS (P)
	PUSH P,[BLKCN1]		; Put a return address on the stack
	PUSH P,B
	JRST BLKLUP		; Go back into block search routine

; Convert block number to byte pointer
; Call:	A	; Block number
;	PUSHJ P,SETPTR

SETPTR:	SOS A
	IDIVI A,7
	IMULI A+1,5
	MOVN B,A+1
	ADDI B,=36-5
	ADD A,DTASTS(UNIT)
	ROT B,=12
	MOVSI C,000500(B)
	HRR C,A
	POPJ P,

; Find empty directory slot
; Call:	PUSHJ P,FNDNUL
; Return
;	+1	; None found
;	+2	; Found, dir points to it

FNDNUL:	HRRZ DIR,DTASTS(UNIT)
	HRLI DIR,-=22
	SKIPN NAMSTR(DIR)
	JRST SKPRET
	AOBJN DIR,.-2
	POPJ P,

; Assign a buffer
; Call:	PUSHJ P,ASGBUF	; For first buffer
; Or
;	PUSHJ P,ASGBF1	; For second buffer

USE	SWAPPC

ASGBF1:	LOCK DTBLCK
	MOVE A,DTBFAV
	ANDCM A,[NDBMSK]	; Enough buffers to allow two?
	JUMPN A,ASGBF2		; Yes, proceed
	UNLOCK DTBLCK
	MOVEI A,0		; No, return 0
	POPJ P,

ASGBUF:	LOCK DTBLCK
	MOVE A,DTBFAV		; Get bits
ASGBF2:	PUSH P,A+1
	JFFO A,.+1		; Find a one
	MOVSI A,400000
	MOVN B,A+1
	ROT A,(B)
	ANDCAM A,DTBFAV		; Remove the bit
	MOVN A,B
	POP P,A+1
	IMULI A,200
	ADDI A,DTABUF		; Convert to address
	UNLOCK DTBLCK
	MOVES (A)		; Reference the buffer to make sure
	PUSHJ P,SAVAC
	PUSHJ P,FPTA
	PUSHJ P,MLKPG		; Lock the page
	PUSHJ P,RESAC
	POPJ P,

RELBUF:	PUSHJ P,SAVAC
	PUSHJ P,FPTA
	PUSHJ P,MULKPG		; Unlock the page
	PUSHJ P,RESAC
	SUBI A,DTABUF		; Convert to a bit
	PUSH P,A+1
	IDIVI A,200
	MOVN A+1,A
	MOVSI A,400000
	ROT A,(B)
	IORM A,DTBFAV		; Return to the pool
	UNLOCK DTBLCK
	POP P,A+1
	POPJ P,

; Byte input from dectape
; Call:	LH(DEV)	; Unit number
;	LH(STS)	; File status bits
;	FILLEN(JFN) ETC
;	PUSHJ P,DTASQI
; Return
;	A	; The byte

DTASQI:	HLRZ UNIT,DEV
	MOVE IOS,DTASTS(UNIT)
	MOVE B,FILBYN(JFN)
	CAML B,FILLEN(JFN)
	JRST [	TEST(O,EOFF)
		POPJ P,]
	TEST(ZE,WNDF)
	PUSHJ P,SETBFI
	SOSGE FILCNT(JFN)
	PUSHJ P,LODBFI
	MOVE B,FILBYN(JFN)
	CAML B,FILLEN(JFN)
	JRST [	TEST(O,EOFF)
		POPJ P,]
	ILDB A,FILBYT(JFN)	; Load the byte
	AOS FILBYN(JFN)		; Count bytes
	POPJ P,			; If first data word, done

USE

DTASI2:	PIOFF			; Prevent dta interrupts
	MOVE IOS,DTASTS(UNIT)
	MOVEI B,DTIBF1(UNIT)
	TEST(CN,ABFIP)
	MOVEI B,DTIBF2(UNIT)
	HLLM IOS,DTASTS(UNIT)
	PION
	HRRZ B,(B)
	JUMPE B,DTASI2		; Alternate buffer non-existent
	UNLOCK DTALCK(UNIT)
	OKINT
	POPJ P,

USE	SWAPPC

LODBFI:	MOVSI B,400000
	MOVEI C,DTIBF1(UNIT)
	TEST(NE,ABFIP)
	MOVEI C,DTIBF2(UNIT)
	IORB B,(C)		; Mark old current buffer as busy
	LDB B,[POINT 10,(B),17]	; Get block number of continuation
	JUMPE B,LODBI9
	PUSHJ P,DTSTRI		; And start up dectape to load it
	NOINT
	LOCK DTALCK(UNIT)
	PUSHJ P,DTASI2
	PUSHJ P,SETBFI
	SOSL FILCNT(JFN)
	POPJ P,
LODBI9:	MOVE B,FILBYN(JFN)
	MOVEM B,FILLEN(JFN)
	POPJ P,

SETBFI:	MOVEI B,DTIBF1(UNIT)	; Get address of buffer pointer
	TEST(NE,ABFIP)		; Using alternate?
	MOVEI B,DTIBF2(UNIT)
	SKIPGE (B)
	PUSHJ P,BUFWAT		; Yes, wait for non-busy
	MOVE B,(B)
	TLNE B,(1B1)
	TEST(OA,ERRF)
	TEST(Z,ERRF)
	HRRM B,FILBYT(JFN)	; Store in byte pointer
	LDB C,PBYTSZ
	MOVE A,(B)
	ANDI A,177
	MOVEI B,=36
	IDIV B,C
	SUBI A,177
	IMUL A,B
	ADDB A,FILLEN(JFN)
	IMULI B,177
	SUB A,FILBYN(JFN)
	CAMG A,B
	MOVE B,A
	MOVEM B,FILCNT(JFN)
	MOVEI A,0
	DPB A,PBYTPO
	POPJ P,

; Dectape sequential output
; Call:	A	; The byte to output
; Everything else like dtasqi
;	PUSHJ P,DTASQO

DTASQO:	HLRZ UNIT,DEV
	MOVE IOS,DTASTS(UNIT)
	TEST(ZE,WNDF)
	PUSHJ P,SETBUF
	JRST DTASO0

USE

DTASO0:	PIOFF
	MOVE IOS,DTASTS(UNIT)
	TEST(ZE,OUERR)
	TEST(O,ERRF)
	HLLM IOS,DTASTS(UNIT)
	PION
	JRST DTASO1

USE	SWAPPC

DTASO1:	PUSH P,A
	SOSGE FILCNT(JFN)
	PUSHJ P,DMPBUF
	POP P,A
	IDPB A,FILBYT(JFN)
	AOS B,FILBYN(JFN)
	MOVEM B,FILLEN(JFN)
	POPJ P,

DMPBUF:	MOVSI B,400000
	MOVEI C,DTOBF1(UNIT)
	TEST(NE,ABFOP)
	MOVEI C,DTOBF2(UNIT)
	IORM B,(C)
	PUSHJ P,DTSTRO
	NOINT
	LOCK DTALCK(UNIT)
	PUSHJ P,DTASO2
	PUSHJ P,SETBUF
	SOS FILCNT(JFN)
	POPJ P,

USE

DTASO2:	PIOFF
	MOVE IOS,DTASTS(UNIT)
	MOVEI B,DTOBF1(UNIT)
	TEST(CE,ABFOP)
	MOVEI B,DTOBF2(UNIT)
	HLLM IOS,DTASTS(UNIT)
	PION
	HRRZ B,(B)
	JUMPE B,DTASO2
	UNLOCK DTALCK(UNIT)
	OKINT
	TEST(O,WNDF)
	POPJ P,

USE	SWAPPC

; Check for buffer ready

SETBUF:	MOVEI B,DTOBF1(UNIT)
	TEST(NE,ABFOP)
	MOVEI B,DTOBF2(UNIT)
	SKIPGE (B)
	PUSHJ P,BUFWAT		; Buffer busy, wait
	MOVE B,(B)		; Get location of buffer
	HRRM B,FILBYT(JFN)
	HRLZ C,B
	HRRI C,1(B)
	SETZM (B)
	BLT C,177(B)
	MOVEI C,177
	DPB C,[POINT 8,(B),35]	; Put word count in buffer header
	MOVEI B,0
	DPB B,PBYTPO
	MOVEI B,=36
	LDB C,PBYTSZ
	IDIV B,C
	IMULI B,177
	MOVEM B,FILCNT(JFN)
	TEST(Z,WNDF)
	POPJ P,

; Dismiss until buffer is not busy
; Call:	B	; Address of buffer header
;	PUSHJ P,BUFWAT
; Returns
;	+1	; When the buffer is no longer busy

BUFWAT:	EXCH A,B
	PUSHJ P,DISGE
	EXCH A,B
	POPJ P,

; Mtopr for dectape

DTMTP:	HLRZ UNIT,DEV
	LOCK DTALCK(UNIT),<PUSHJ P,LCKTST>
	MOVSI A,ACTI
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT		; Wait for input to stop
	MOVSI A,ACTO
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT		; Wait for output to stop
	MOVE IOS,DTASTS(UNIT)
	CAIE B,1
	CAIN B,11
	JRST RWND		; Rewind and/or unload
	CAIE B,30		; Space record
	JRST DTMTPX		; Nop
	TEST(NN,NSTD)
	JRST DTMTPX		; Must be non-standard mode
	UMOVE A,3		; Get block number
	CAIL A,0
	CAILE A,TOPBLK
	JRST DTMTPX		; Out of range
	DPB A,PIBLK
	DPB A,POBLK
DTMTPX:	UNLOCK DTALCK(UNIT)
	POPJ P,

RWND:	MOVSI A,(1B12)
	CAIN B,11
	TLO A,(1B13)
	IORM A,DTIBF2(UNIT)	; Mark this spacing op
	PUSHJ P,DTSTRI		; Start input
	JRST DTMTPX

; Dump i/o for dectape

DTDMPI:	TDZA IOS,IOS
DTDMPO:	MOVSI IOS,IO
	HLRZ UNIT,DEV
	MOVE B,A
	LOCK DTALCK(UNIT),<PUSHJ P,LCKTST>
	MOVSI A,ACTI
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVSI A,ACTO
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	HRRM B,DTIBF1(UNIT)
	HLRES B
	MOVNS B
	HRRM B,DTIBF2(UNIT)
	MOVSI A,(1B1)
	ANDCAM A,DTIBF1(UNIT)
	ANDCAM A,DTIBF2(UNIT)
	TEST(NN,IO)
	JRST DTDMP1
	PUSHJ P,DTSTRO
	MOVSI A,ACTO
	PUSHJ P,DISBIT
	JRST DTDMP2

DTDMP1:	PUSHJ P,DTSTRI
	MOVSI A,ACTI
	PUSHJ P,DISBIT
DTDMP2:	MOVE A,DTIBF1(UNIT)
	TLNE A,(1B1)
	TEST(O,ERRF)
	MOVE A,DTIBF2(UNIT)
	TLNE A,(1B1)
	TEST(O,EOFF)
	UNLOCK DTALCK(UNIT)
	POPJ P,

; Close dectap file
; Call:	PUSHJ P,DTACLZ

DTACLZ:	HLRZ UNIT,DEV
	MOVE IOS,DTASTS(UNIT)
	TEST(NE,NSTD)
	JRST CLZNST
	TEST(NE,READF)
	JRST DTCLZR
	TEST(ZE,WNDF)
	PUSHJ P,SETBUF		; Wait if necessary for buffer free
	MOVEI A,DTOBF1(UNIT)
	TEST(NE,ABFOP)
	MOVEI A,DTOBF2(UNIT)
	MOVSI B,(1B12)
	IORM B,(A)		; Mark the buffer as the last
	HRRZ B,FILBYT(JFN)
	HRRZ A,(A)
	SUB B,A
	DPB B,[POINT 8,(A),35]
	PUSHJ P,DMPBUF		; Write the final buffer
	MOVSI A,ACTO
	PUSHJ P,DISBIT		; Dismiss until acto bit goes off
	MOVSI IOS,RWDIR
	IORB IOS,DTASTS(UNIT)
	PUSHJ P,DTSTRO		; Start writing directory
	HRRZ A,DTOBF1(UNIT)
	HLLZS DTOBF1(UNIT)
	PUSHJ P,RELBUF
	HRRZ A,DTOBF2(UNIT)
	HLLZS DTOBF2(UNIT)
	SKIPE A
	PUSHJ P,RELBUF
	MOVSI IOS,OUOPN
	ANDCAB IOS,DTASTS(UNIT)
	JRST SKPRET

DTCLZR:	MOVSI A,ACTI
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	HRRZ A,DTIBF1(UNIT)
	HLLZS DTIBF1(UNIT)
	PUSHJ P,RELBUF
	HRRZ A,DTIBF2(UNIT)
	HLLZS DTIBF2(UNIT)
	SKIPE A
	PUSHJ P,RELBUF
	MOVSI IOS,INOPN
	ANDCAB IOS,DTASTS(UNIT)
	JRST SKPRET

CLZNST:	MOVSI A,ACTI
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVSI A,ACTO
	TDNE A,DTASTS(UNIT)
	PUSHJ P,DISBIT
	LDB A,PCBLK
	FOR A IN (DTIBF1,DTIBF2,DTOBF1,DTOBF2),<
	SETZM A(UNIT)>
	DPB A,PCBLK
	MOVSI IOS,OUOPN!INOPN!NSTD
	ANDCAB IOS,DTASTS(UNIT)
	JRST SKPRET

; Dismiss until a bit of dtasts goes off

DISBIT:	PUSH P,A+1
	JFFO A,.+1
	PUSH P,A
	MOVEI A,BITTST
	DPB A+1,[POINT 9,A,8]
	DPB UNIT,[POINT 9,A,17]
	JSYS EDISMS
	POP P,A
	POP P,A+1
	POPJ P,

USE

BITTST:	LDB 2,[POINT 9,1,26]
	LDB 3,[POINT 9,1,35]
	MOVE 3,DTASTS(3)
	ROT 3,(2)
	JUMPL 3,0(4)
	JRST 1(4)

	BEGINP	DTA DRIVERS

BLK_D

LDTSTK__20
LS(DTSTK,LDTSTK)		; Stack for dectape interrupt

; Dectape start up routines
; Call:	UNIT	; The unit to be started
;	PUSHJ P,DTSTRI	; For input
; Or
;	PUSHJ P,DTSTRO	; For output
; The unit is marked as input or output active, and the control started
; If necessary

^DTSTRI:MOVSI IOS,ACTI
	JRST DTSTR1

^DTSTRO:MOVSI IOS,ACTO
DTSTR1:	IORB IOS,DTASTS(UNIT)
	PIOFF
	PUSH P,A
	SKIPE A,DTAUNT		; Is the controller active?
	JRST [	CAIE UNIT,(A)	; Yes, for this unit?
		SETOM DTREQ	; No. request for controller
		JRST DTSTR2]
	PUSH P,UNIT
	HRROI UNIT,DTAN-1
	PUSHJ P,DTANXT		; Scan dectapes for something to do
	POP P,UNIT
DTSTR2:	POP P,A
	PION
	POPJ P,

; The following code is executed both at interrupt and non-interrupt
; Level.  however, it is never executed at both levels simultaneously.
; It is only run at non-interrupt level, if the dectape control is not
; Busy

; Find next unit waiting for service
; Call:	UNIT	; Aobjn pointer to unit to start after
;	PUSHJ P,DTANXT
; Return
;	+1	; Always
; The dectape found is  started searching for the appropriate block

^DTANXT:PUSH P,UNIT		; Save starting point
DTANX1:	AOBJN UNIT,.+2
	MOVSI UNIT,-DTAN
	MOVSI B,ACTI!ACTO
	TDNE B,DTASTS(UNIT)
	JRST DTADO		; A unit requiring service has been found
	CAME UNIT,(P)
	JRST DTANX1		; Scann all units
	SETZM DTREQ
	POP P,UNIT
	POPJ P,

DTADO:	SUB P,[XWD 1,1]
	MOVE IOS,DTASTS(UNIT)
	TEST(NE,ACTI)
	TEST(ZA,IO)
	TEST(O,IO)
	HLLM IOS,DTASTS(UNIT)
	MOVE A,DTIBF2(UNIT)
	TLNE A,(1B12)		; Spacing op?
	JRST DTAREW
	TEST(NE,RWDIR)		; Directory read or write?
	JRST DTADOD
	TEST(NE,NSTD)
	JRST DTADNS
	MOVEI A,QUANT
	MOVEM A,QUANTM
	TEST(NE,ACTO)
	JRST DTADOO		; Do output
DTADOI:	MOVEI B,DTIBF1(UNIT)
	TEST(NE,ABFII)
	MOVEI B,DTIBF2(UNIT)
	MOVSI A,(1B1)
	ANDCAM A,(B)		; Clear input error bit
	LDB BLK,PIBLK		; Get next input block
	JUMPE BLK,[MOVSI IOS,ACTI
		ANDCAB IOS,DTASTS(UNIT)
		POPJ P,]
	HRRZ B,(B)
	HRLI B,-200
	SOS B			; Make into iowd
	MOVE A,[BLKI DTC,300]
	JRST DTAOP

DTADOO:	MOVEI B,DTOBF1(UNIT)
	TEST(NE,ABFOI)
	MOVEI B,DTOBF2(UNIT)
	PUSH P,B
	MOVE B,(B)
	TLNE B,(1B12)
	JRST [	MOVEI A,0	; Last buffer, put in 0 link
		JRST DTDOO1]
	LDB A,POBLK		; Get block number for this buffer
	JUMPE A,[MOVSI IOS,ACTO	; Really have no more to do
		ANDCAM IOS,DTASTS(UNIT)
		MOVSI IOS,FULF!OUERR
		IORM IOS,DTASTS(UNIT)
		MOVEM UNIT,DTAUNT
		SETOM DTABLK
		PUSH P,P
		JSYS [XWD DTSINR,FAKINT]
		POP P,B
		POPJ P,]
	MOVE B,DTASPC		; BLOCK SPACING
	TEST(NE,RVRS)		; REVERSE?
	MOVN B,B		; YES, SUBTRACT IT
	ADD A,B
	MOVEI B,0
	PUSHJ P,BLKSRC	; Look for a free block
	JRST [	MOVEI A,0
		JRST DTDOO1]
	MOVSI B,RVRS
	AND IOS,B
	ANDCAM B,DTASTS(UNIT)
	IORB IOS,DTASTS(UNIT)
	LDB B,POFILN
	DPB B,C			; Assign the block
DTDOO1:	POP P,B
	MOVSI C,(1B1)
	ANDCAM C,(B)
	HRRZ B,(B)
	LDB BLK,POBLK
	DPB A,POBLK
	DPB A,[POINT 10,(B),17]
	LDB A,PFBLK
	DPB A,[POINT 10,(B),27]
	HRLI B,-200
	SOS B			; Make into iowd
	MOVE A,[BLKO DTC,700]

DTAOP:	MOVEM UNIT,DTAUNT
	MOVEM B,PNTR		; Iowd for forward xfer
	MOVEM B,SVPNTR		; Save pntr for error retries
	MOVEM BLK,DTABLK	; Block number to search for
	HRRZM A,DTAOPR		; Save read data or write data op
	HRRI A,PNTR
	MOVEM A,DTABIO		; Blki/o instruction
	MOVEI A,DTTRY
	MOVEM A,DTERRC
DTREGO:	HRRZ C,UNIT
	LSH C,11
	CONSZ DTC,20000		; Unit already selected?
	JRST [	CONSZ DTC,200000; Yes, setup for current direction
		TROA C,200000
		TRO C,100000
		JRST DTRGO1]
	CONO DTC,30000(C)	; Connect to dtan
	HRRZ A,DTAOPR
	CAIN A,700		; Write op?
	CONSO DTS,4000		; Yes. write lock?
	CONSZ DTS,100
	JRST [	SETOM DTABLK	; Write lock or select error
		PUSH P,DTSINR
		PUSH P,P
		JSYS [XWD DTSINR,FAKINT]
		POP P,DTSINR
		POPJ P,]
	LDB A,PCBLK		; Get current position of tape
	MOVEI C,230000(C)	; Get ready to go forward
	CAML A,DTABLK		; Unless desired block is < current
	TRC C,300000
DTRGO1:	MOVE A,[JSYS DTASRI]
	MOVEM A,DTALOC		; Setup data interrupt
	CONO DTC,DTBOTH+200(C)	; Start up in read block number mode
	CONO DTS,670000		; Enable all int's except job done
	POPJ P,			; Go away, all else is done at int level

; Rewind operation

DTAREW:	TLNE A,(1B13)		; Unload?
	SKIPA A,[JFCL 0(1)]
	MOVSI A,(<JFCL>)
	SETZB B,BLK
	JRST DTAOP

DTADOD:	HRRZ B,DTASTS(UNIT)
	HRLI B,-200
	SOS B
	MOVEI BLK,DIRBLK
	TEST(NE,ACTI)
	SKIPA A,[BLKI DTC,300]
	MOVE A,[BLKO DTC,700]
	JRST DTAOP

DTADNS:	HRRZ B,DTIBF1(UNIT)
	HRRZ A,DTIBF2(UNIT)
	CAILE A,200
	MOVEI A,200
	ADDM A,DTIBF1(UNIT)
	MOVNS A
	ADDM A,DTIBF2(UNIT)
	HRL B,A
	LDB BLK,PIBLK
	TEST(NE,ACTI)
	SKIPA A,[BLKI DTC,300]
	MOVE A,[BLKO DTC,700]
	JRST DTAOP

; The following code is executed only at interrupt level


; Block number search interrupt

DTASRI:	XWD DTDINR,.+1
	MOVEM A,DTDTMP		; Save working ac
	DATAI DTC,A		; Read block number
	ANDI A,1777
	EXCH UNIT,DTAUNT
	DPB A,PCBLK		; Keep current block up to date
	EXCH UNIT,DTAUNT
	SUB A,DTABLK		; Compare with desired block
	JUMPE A,FOUND		; If equal, the block is found
	CONSO DTC,100000
	MOVNS A			; Complement delta, a is how far to
	JUMPGE A,SRCHA		; Go in current direction
SRCHD:	CONO DTC,DTTURN		; Change direction
	SOSG DTERRC		; Count turnarounds as pseudo-errors
	JRST SRCHE		; Too many constitute an error
SRCHXT:	MOVE A,DTDTMP
	JEN @DTDINR

SRCHA:	JRST SRCHXT		; Dead reckoning stuff goes here

SRCHE:	EXCH UNIT,DTAUNT
	AOS DTARCE(UNIT)
	EXCH UNIT,DTAUNT
	SETOM DTABLK		; Remember bad block encountered
	CONO DTS,770001		; Generate job done int
	JRST SRCHXT

FOUND:	SKIPL A,DTABIO
	JRST ENDSPA
	CONSZ DTC,100000	; Reverse transfer needed?
	JRST FNDRVS		; Yes
	JRST DTAGO

; End spacing

ENDSPA:	CONO DTS,770001			; Cause job done int
	JRST SRCHXT

FNDRVS:	HLRE A,PNTR		; Get count
	MOVNS A
	SOS A
	ADDM A,PNTR		; Adjust pntr to end of data
	SUBI A,177		; Yields zero if full block
	JUMPE A,FNDRV1
	MOVEM A,DTASKP
	SKIPA A,[JSYS SKPREV]
FNDRV1:	MOVE A,[JSYS DTAREV]
DTAGO:	MOVEM A,DTALOC
	MOVE A,[JSYS DTATHR]
	MOVEM A,DTALOC+1	; Set up interrupt loc+1
	HRRZ A,DTAOPR
	CONO DTC,DTBOTH(A)
	CONO DTS,770000
	JRST SRCHXT

; Data interrupt going reverse

SKPREV:	XWD DTDINR,.+1		; Here while skipping
	DATAI DTC,DTAWST	; Waste
	AOSGE DTASKP
	JEN @DTDINR
	MOVEM A,DTALOC
	MOVE A,[JSYS DTAREV]
	EXCH A,DTALOC
	JEN @DTDINR

DTAREV:	XWD DTDINR,.+1		; Jsys dispatch
	XCT DTABIO		; Do the blki/o
	JRST REVTHR		; Done
	SOS PNTR
	SOS PNTR		; Make the iowd increment backward
	JEN @DTDINR		; Return

; Data interrupt, blki/o done

DTATHR:	XWD DTDINR,REVTHR
REVTHR:	CONO DTS,770001		; Generate job done interrupt
	JEN @DTDINR

; Dectape flag interrupt

^DTASV:	XWD DTSINR,.+1
	CONSO DTS,2
	JRST @DTSINR		; Not dectape interrupt
	EXCH A,DTSINR
	MOVEI A,DTACHR
	EXCH A,DTSINR
	CONSZ DTS,20000		; End zone?
	SKIPGE DTABLK		; And no block error?
	JRST DTAIN1		; No, check job done etc.
	CONSZ DTC,500		; Reading block numbers?
	JRST DTAIN1		; Can only happen with dump mode
				; Or if system stops
	CONO DTC,DTTURN		; Reverse direction
	JRST @DTSINR		; Return

DTAIN1:	MOVEM P,DTSTK		; Set up a stack
	MOVE P,[XWD -LDTSTK+1,DTSTK]
FAKINT:	PUSH P,UNIT		; Save ac's not saved by interrupt
	PUSH P,IOS
	MOVE UNIT,DTAUNT
	MOVE IOS,DTASTS(UNIT)
	SKIPGE DTABLK
	JRST ERRS		; Some kind of block number error
	CONSZ DTS,100000
	CONSZ DTS,670000
	JRST ERRS
DTAIN9:	SKIPL DTABIO
	JRST REWDON
	TEST(NE,NSTD)
	JRST DMPTHR		; Dump mode i/o finished
	TEST(NE,RWDIR)
	JRST DIRTHR		; Through with a directory op
	TEST(ZN,FSTBK)		; Looking for first block?
	JRST DTAIN3		; No.
	HRRZ A,DTIBF1(UNIT)
	LDB A,[POINT 10,(A),27]	; Extract first block from header
	DPB A,PIBLK
	CAMN A,DTABLK
	JRST DTAIN3		; Treat same as input if equal
	HLLM IOS,DTASTS(UNIT)
	PUSHJ P,DTADOI		; Otherwise start up input
	JRST DTSXIT

ERRS:	CONO DTC,400000
	CONO DTC,10000
	AOS DTARCE(UNIT)
	SKIPL DTABLK
	SOSGE DTERRC
	JRST [	SETOM DTABLK
		JRST DTAIN9]
	MOVE B,SVPNTR
	MOVEM B,PNTR
	PUSHJ P,DTREGO
	JRST DTSXIT

DIRTHR:	SKIPL DTABLK
	TEST(O,DIRIC)
	TEST(Z,RWDIR,ACTI)
	JRST DTAGOX

DTAIN3:	TEST(NE,IO)
	JRST OUTHRU		; Output done
	MOVEI A,DTIBF1(UNIT)
	TEST(NE,ABFII)
	MOVEI A,DTIBF2(UNIT)
	MOVSI B,400000
	ANDCAM B,(A)		; Mark buffer not busy
	MOVSI B,(1B1)
	SKIPGE DTABLK
	IORM B,(A)		; Mark buffer as erroneous
	HRRZ A,(A)
	LDB C,[POINT 10,(A),17]	; Get next input block
	DPB C,PIBLK
DTAIN4:	MOVEI A,DTIBF1(UNIT)
	TEST(CN,ABFII)
	MOVEI A,DTIBF2(UNIT)
	HRRZ B,(A)
	JUMPE B,DTAIN4
	JUMPE C,DTAGNX
	SOSG QUANTM
	SKIPN DTREQ
	SKIPL (A)
	JRST DTAGNX
	HLLM IOS,DTASTS(UNIT)
	SKIPGE DTABLK
	JRST DTAGNX		; Stop if error
	PUSHJ P,DTADOI
	JRST DTSXIT

DTAGOX:	TEST(ZA,ACTO)
DTAGNX:	TEST(Z,ACTI)
	HLLM IOS,DTASTS(UNIT)
	SETZM DTAUNT
	MOVNI A,2
	CONSZ DTC,200000
	MOVNS A
	LDB B,PCBLK
	ADD B,A			; Bump current block for stop time
	DPB B,PCBLK
	CONO DTC,400000
	CONO DTC,10000
	PUSHJ P,DTANXT		; Find something else to do
DTSXIT:	POP P,IOS
	POP P,UNIT
	POP P,P
	JRST @DTSINR

OUTHRU:	MOVEI A,DTOBF1(UNIT)
	TEST(NE,ABFOI)
	MOVEI A,DTOBF2(UNIT)
	MOVSI B,400000
	ANDCAM B,(A)
	SKIPGE DTABLK
	TEST(O,OUERR)
	HRRZ A,(A)
	LDB C,[POINT 10,(A),17]
OUTHR1:	MOVEI A,DTOBF1(UNIT)
	TEST(CN,ABFOI)
	MOVEI A,DTOBF2(UNIT)
	HRRZ B,(A)
	JUMPE B,OUTHR1		; No second buffer
	JUMPE C,DTAGOX
	SOSG QUANTM
	SKIPN DTREQ
	SKIPL (A)
	JRST DTAGOX		; Release the control
	SKIPGE DTABLK
	JRST DTAGOX		; No more transfers if error
	HLLM IOS,DTASTS(UNIT)
	PUSHJ P,DTADOO
	JRST DTSXIT

DMPTHR:	LDB A,PIBLK
	AOS A
	SKIPGE DTABLK
	 JRST [	TEST(Z,ACTI,ACTO)
		MOVSI A,(1B1)
		IORM A,DTIBF2(UNIT)
		JRST DTAGNX]
	CAILE A,TOPBLK
	JRST DMPTH1
	DPB A,PIBLK
	HRRZ A,DTIBF2(UNIT)
	JUMPE A,[TEST(NN,ACTI)
		JRST DTAGOX
		JRST DTAGNX]
	HLLM IOS,DTASTS(UNIT)
	PUSHJ P,DTADNS
	JRST DTSXIT

DMPTH1:	MOVSI A,(1B1)
	TEST(NN,ACTI)
	JRST DMPTH2
	IORM A,DTIBF2(UNIT)
	JRST DTAGNX

DMPTH2:	IORM A,DTIBF2(UNIT)
	JRST DTAGOX

REWDON:	MOVSI A,(1B13)
	TDNE A,DTIBF2(UNIT)
	JRST REWUNL
	MOVSI A,(1B12)
	ANDCAM A,DTIBF2(UNIT)
	JRST DTAGNX

REWUNL:	CONO DTC,140000		; Continue reverse
	CONO DTC,10000		; Deselect
	CONO DTS,0
	MOVEI A,=3000
	MOVEM A,DTATIM
	SETOM DTAUNS
	JRST DTSXIT

^DTACHK:MOVEI A,=60000
	MOVEM A,DTATIM
	SKIPE DTAUNS
	SKIPN A,DTAUNT
	POPJ P,
	SETZM DTAUNS
	MOVE UNIT,A
	LSH A,=9
	ANDI A,7000
	CONO DTC,20000(A)
	CONO DTC,200000
	CONO DTC,400000
	CONO DTC,10000
	SETZM DTAUNT
	MOVSI A,60
	ANDCAM A,DTIBF2(UNIT)
	MOVSI A,ACTI
	ANDCAM A,DTASTS(UNIT)
	JRST DTANXT

	BENDP	DTA
	BENDP	DECTAPE>

IFDEF PLTN,<
	BEGINP	PLOTTER		R.S.TOMLINSON	14 JUNE 1971	1538:

; Ac's

IOS_6

; Parameters

PLT_140		; Plt device code
PI__4		; Pi device
PLTDON__10	; Done coni/o bit
PLTBSY__20	; Busy coni/o bit
PLTEOT__40	; No paper coni bit
BUFSIZ__101	; Size of plt buffer
PLTPIN__=200	; Plot steps per inch

; Entries to this part

INTERN	PLTSV		; Interrupt service routine
INTERN	PLTCHK		; Entry to clock routine
INTERN	PLTRST		; Reset

; Externally defined things

EXTERN	PLTCHN	; Plt pi channel
EXTERN	PLTCHR	; Plt interrupt return
EXTERN	PLTTIM	; Clock word for plt restart
EXTERN	DISGET	; Greater/equal dismiss test

; Storage

LS(PLTBF1,BUFSIZ)	; First buffer
LS(PLTBF2,BUFSIZ)	; Second buffer
LS(PLTSTS)		; Status word
LS(PLTLCK)		; Plt open lock
LS(PLTCNT)		; Count of full buffers
LS(PLTITC)		; Count of items remaining in current buffer
LS(PLTFDC)		; Count of steps left to feed
LS(PLTPTR)		; Byte bointer for emptying current buffer
LS(PLTSVR)		; Interrupt return address
LS(PLTSIO)		; Saved ios during interrupt
LS(PLTMAX)		; Maximum x excursion during plot
LS(PLTXPO)		; Current x position of plot

; Flags in pltsts and ios

FLG(ALTP,L,IOS,400000)	; Buffer 2 for prog
FLG(ALTI,L,IOS,200000)	; Buffer 1 for int
FLG(OPN,L,IOS,040000)	; Plt is open
FLG(STOP,L,IOS,002000)	; Plt is stopped due to no power off

; Plt dispatch table

USE SWAPPC

^PLTDTB:CPOPJ		; Set directory
	CPOPJ		; Name lookup
	CPOPJ		; Extension lookup
	CPOPJ		; Version lookup
	CPOPJ		; Protection insertion
	CPOPJ		; Account insertion
	CPOPJ		; Status insertion
	PLTOPN		; Plt open
	CPOPJ		; Input
	PLTSQO		; Output
	PLTCLZ		; Close
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dumpi
	CPOPJ		; Dumpo
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Init directory
	CPOPJ		; Mtopr
	CPOPJ		; Get status
	CPOPJ		; Set status

; Initialize plotter
; Call:	PUSHJ P,PLTINI
; Returns
;	+1	; Always (called at system initialization time

USE

^PLTINI:SETZM PLTSTS
	SETOM PLTLCK
	SETOM PLTCNT
	SETZM PLTFDC
	POPJ P,

; Plotter reset routine turns plotter back on if it should be

PLTRST:	SKIPL PLTCNT
	CONO PLT,PLTDON+PLTCHN
	POPJ P,

; Open plt
; Call:	JFN	; Jfn
;	PUSHJ P,PLTOPN
; Returns
;	+1	; Error, error number in 1
;	+2	; Ok

USE SWAPPC

PLTOPN:	LOCK PLTLCK,<PUSHJ P,LCKTST>
	MOVE IOS,PLTSTS
	CONSO PLT,PLTEOT	; Power on?
	 JRST [	UNLOCK PLTLCK	; No. give error return
		MOVEI A,OPNX8
		POPJ P,]
	TEST(OE,OPN)		; Test and set opn flag
	 JRST [	UNLOCK PLTLCK	; Already opn
		MOVEI A,OPNX9	; Give busy error return
		POPJ P,]
	TLZ IOS,ALTP!ALTI!STOP
PLTOP1:	MOVEI B,5		; Get 5 bit bytes
	DPB B,[POINT 6,PLTPTR,11]
				; Store in byte pointer
	MOVEM IOS,PLTSTS	; Store status word
	SETOM PLTCNT		; No full buffers
	SETZM PLTITC		; No items left in current buffer
	SETZM PLTMAX
	SETZM PLTXPO
	UNLOCK PLTLCK
	HRROI A,11		; Pen up command
	MOVEM A,PLTFDC
	CONO PLT,PLTDON+PLTCHN	; Set done flag to cause interrupt
	SETZM FILBYN(JFN)
	SETZM FILLEN(JFN)
	TEST(O,WNDF)
	JRST SKPRET

; Close plt
; Call:	JFN	; Jfn
;	PUSHJ P,PLTCLZ
; Returns
;	+1	; Always

PLTCLZ:	SKIPE FILBYN(JFN)
	PUSHJ P,DMPBUF		; Dump partial buffer
	MOVE A,[XWD PLTCNT,DISLT]
	SKIPL PLTCNT
	JSYS EDISMS		; Dismiss til last buffer being dumped
	MOVE A,[XWD PLTITC,DISLET]
	SKIPLE PLTITC
	JSYS EDISMS		; Dismiss till last buffer out
	HRROI B,11
	PUSHJ P,DOSTEP
	MOVE B,PLTMAX
	SUB B,PLTXPO		; How far to go to get to last point
	ASH B,-1		; Double steps
	ADDI B,=12*PLTPIN	; Plus twelve more inches
	PUSHJ P,DOSTEP
	SETZM PLTSTS
	JRST SKPRET

USE

DOSTEP:	CONO PI,400
	MOVEM B,PLTFDC
	CONSO PLT,PLTBSY
	CONO PLT,PLTDON+PLTCHN
	CONO PI,200
	MOVE A,[XWD PLTFDC,DISET]
	JSYS EDISMS
	POPJ P,

USE SWAPPC

; Plt sequential output
; Call:	A	; Byte
;	JFN	; Jfn
;	PUSHJ P,PLTSQO
; Returns
;	+1	; Always

PLTSQO:	MOVE IOS,PLTSTS		; Get status word
	PUSH P,A		; Preserve byte
	TEST(ZE,WNDF)		; Buffers set up yet?
	PUSHJ P,SETBUF		; No, do it
	SOSGE FILCNT(JFN)	; Buffer full?
	PUSHJ P,DMPBUF		; Yes, dump it
	AOS FILBYN(JFN)		; Count bytes in buffer
	POP P,A
	IDPB A,FILBYT(JFN)	; Deposit in buffer
	POPJ P,

DMPBUF:	MOVSI IOS,ALTP
	XORB IOS,PLTSTS		; Complement buffer
	MOVEI A,PLTBF1
	TEST(NN,ALTP)
	MOVEI A,PLTBF2
	PUSH P,A
	MOVEI A,=36
	LDB B,PBYTSZ		; User's byte size
	IDIV A,B		; User bytes per word
	MOVEI B,7		; 7 bytes per word
	IMUL B,FILBYN(JFN)
	IDIV B,A		; Number of output bytes in buffer
	SKIPE C
	AOS B			; Round up
	POP P,A			; Get buffer location
	HRRZM B,(A)		; Store count in buffer word 0
	AOSN PLTCNT		; Count one more full buffer
	CONO PLT,PLTDON+PLTCHN	; If this is first one, start plotter
	PUSHJ P,SETBUF
	SOS FILCNT(JFN)
	POPJ P,

SETBUF:	MOVE A,[XWD PLTCNT,DISLET]
	SKIPLE PLTCNT		; Are all buffers non-empty?
	JSYS EDISMS		; Yes, wait for one to empty
	MOVEI A,PLTBF1+1	; Use buffer 1
	TEST(NE,ALTP)		; Unles alternate flag
	MOVEI A,PLTBF2+1	; Then use 2
	HRRM A,FILBYT(JFN)	; Point program byte pointer to buffer
	MOVEI A,=36
	DPB A,PBYTPO		; Position to left of first word
	MOVEI A,=36
	LDB B,PBYTSZ		; User's byte size
	IDIV A,B		; Bytes per word
	IMULI A,BUFSIZ-1	; Bytes per buffer
	MOVEM A,FILCNT(JFN)	; Init filcnt
	SETZM FILBYN(JFN)	; No bytes written yet
	POPJ P,

; Plt interrupt routine

USE

PLTSV:	XWD PLTSVR,.+1
	CONSO PLT,PLTDON	; Plt interrupt?
	JRST @PLTSVR		; No
	MOVEM IOS,PLTSIO	; Save ios
	MOVE IOS,PLTSTS		; Get status word
	CONSO PLT,PLTEOT	; Out of tape?
	 JRST [	TEST(O,STOP)
		CONO PLT,0
		SETZM PLTTIM
		JRST PLTXIT]
	SKIPGE PLTFDC		; Negative?
	 JRST [	DATAO PLT,PLTFDC; Yes, has a special plot command
		SETZM PLTFDC
		JRST PLTXIT]
	SKIPG PLTFDC		; Greater than 0?
	JRST PLTSV1		; No, check for data
	DATAO PLT,[2]		; Yes, plot +x
	SOS PLTFDC
PLTXIT:	MOVEM IOS,PLTSTS
	MOVE IOS,PLTSIO
	JRST PLTCHR

PLTSV1:	SKIPG PLTITC		; Items left in buffer?
	JRST PLTSV2		; No.
	ILDB A,PLTPTR		; Yes, get one
	TRNE A,10		; Codes with this bit are funny
	JRST PLTSV4
	TRNN A,3
	JRST PLTSV5		; These codes don't move x
	MOVEI B,1
	TRNE A,4
	MOVNI B,1		; These codes decrement x
	TRNN A,20
	ASH B,1			; Double step codes
	JRST PLTSV6

PLTSV4:	TRNN A,20
	JRST PLTSV5		; Codes 10-17 dont move
	MOVEI B,1
	TRNE A,1
	MOVNI B,1		; Odd codes move negative
	TRNN A,2
	ASH B,1			; Double step codes
PLTSV6:	ADDB B,PLTXPO		; New x position
	CAMGE B,[-4*PLTPIN]
	 JRST [	IDIVI A,7
		MOVE A,PLTCMT(A)
		IMULI B,5
		ROT A,5(B)
		ANDI A,37
		JRST PLTSV5]	; There isn't room
	CAMLE B,PLTMAX
	MOVEM B,PLTMAX		; Keep track of extent of plot
PLTSV5:	DATAO PLT,A
	SOSLE PLTITC		; Count items
	JRST PLTXIT		; Some left
	SOS PLTCNT
	JRST PLTXIT

PLTSV2:	SKIPGE PLTCNT
	JRST [	CONO PLT,0	; Turn off plotter
		JRST PLTXIT]
	MOVEI A,PLTBF1
	TEST(CE,ALTI)
	MOVEI A,PLTBF2
	HRRZ B,(A)		; Get item count of buffer
	AOS A
	MOVEM B,PLTITC
	HRRM A,PLTPTR		; Point pointer to the first word
	MOVEI A,44
	DPB A,[POINT 6,PLTPTR,5]; Point to left of first byte
	JRST PLTSV1		; And continue with the new buffer

PLTCMT:	BYTE (5)0,0,10,4,4,4,10,0,10,10,10,10,10,10,10,10,20,20,10,24,24,24,10,20,20,20,0,0,24,24,4,4

; This routine is called periodically when plotter power has gone off
; To restart when power is returned

PLTCHK:	MOVEI A,=60000
	MOVEM A,PLTTIM		; 1 minute if not active
	MOVE A,PLTSTS
	TLNE A,OPN
	TLNN A,STOP
	POPJ P,			; Plotter not in use or not stopped
	MOVEI A,=5000
	MOVEM A,PLTTIM
	CONSO PLT,PLTEOT
	POPJ P,			; Power is still off
	MOVSI A,STOP		; Power back on
	ANDCAM A,PLTSTS		; Clear stop bit
	CONO PLT,PLTDON+PLTCHN	; Turn plotter back on
	POPJ P,

^DISET:	SKIPE 0(1)
	JRST 0(4)
	JRST 1(4)

BENDP	PLOTTER>

IFDEF PTPN,<
	BEGINP	PTP		R.S.TOMLINSON	23 APRIL 1971	1002:

INTERN	PTPSV,PTPCHK,PTPRST

; Ac's

IOS_6

; Parameters

PTP_100		; Ptp device code
PI__4		; Pi device
PTPDON__10	; Done coni/o bit
PTPBSY__20	; Busy coni/o bit
PTPEOT__100	; No tape coni bit
BUFSIZ__41	; Size of ptp buffer

; Entries to this part

INTERN	PTPSV		; Interrupt service routine
INTERN	PTPCHK		; Entry to clock routine

; Externally defined things

EXTERN	PTPCHN	; Ptp pi channel
EXTERN	PTPCHR	; Ptp interrupt return
EXTERN	PTPTIM	; Clock word for ptp restart
EXTERN	DISGET	; Greater/equal dismiss test

; Storage

LS(PTPBF1,BUFSIZ)	; First buffer
LS(PTPBF2,BUFSIZ)	; Second buffer
LS(PTPSTS)		; Status word
LS(PTPLCK)		; Ptp open lock
LS(PTPCNT)		; Count of full buffers
LS(PTPITC)		; Count of items remaining in current buffer
LS(PTPFDC)		; Count of lines of feed left to punch
LS(PTPPTR)		; Byte bointer for emptying current buffer
LS(PTPSVR)		; Interrupt return address
LS(PTPSIO)		; Saved ios during interrupt

; Flags in ptpsts and ios

FLG(ALTP,L,IOS,400000)	; Buffer 2 for prog
FLG(ALTI,L,IOS,200000)	; Buffer 1 for int
FLG(OPN,L,IOS,040000)	; Ptp is open
FLG(IMAGE,L,IOS,020000)	; Ptp is operating in image mode (10)
FLG(PTPBI,L,IOS,010000)	; Ptp is operating in binary mode (14)
FLG(PTPIB,L,IOS,004000)	; Ptp is operating in image binary mode (13)
FLG(STOP,L,IOS,002000)	; Ptp is stopped due to no tape

; Ptp dispatch table

USE SWAPPC

^PTPDTB:CPOPJ		; Set directory
	CPOPJ		; Name lookup
	CPOPJ		; Extension lookup
	CPOPJ		; Version lookup
	CPOPJ		; Protection insertion
	CPOPJ		; Account insertion
	CPOPJ		; Status insertion
	PTPOPN		; Ptp open
	CPOPJ		; Input
	PTPSQO		; Output
	PTPCLZ		; Close
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dumpi
	CPOPJ		; Dumpo
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Init directory
	CPOPJ		; Mtopr
	CPOPJ		; Get status
	CPOPJ		; Set status

; Initialize punch
; Call:	PUSHJ P,PTPINI
; Returns
;	+1	; Always (called at system initialization time

USE

^PTPINI:SETZM PTPSTS
	SETOM PTPLCK
	SETOM PTPCNT
	SETZM PTPFDC
	POPJ P,

PTPRST:	SKIPL PTPCNT
	CONO PTP,PTPDON+PTPCHN
	POPJ P,

; Open ptp
; Call:	JFN	; Jfn
;	PUSHJ P,PTPOPN
; Returns
;	+1	; Error, error number in 1
;	+2	; Ok, 200 lines of feed is punched

USE SWAPPC

PTPOPN:	LOCK PTPLCK,<PUSHJ P,LCKTST>
	MOVE IOS,PTPSTS
	CONSZ PTP,PTPEOT	; Any tape in punch?
	 JRST [	UNLOCK PTPLCK	; No. give error return
		MOVEI A,OPNX8
		POPJ P,]
	TEST(OE,OPN)		; Test and set opn flag
	 JRST [	UNLOCK PTPLCK	; Already opn
		MOVEI A,OPNX9	; Give busy error return
		POPJ P,]
	TLZ IOS,ALTP!ALTI!IMAGE!PTPBI!PTPIB!STOP
	LDB A,[POINT 4,STS,35]	; Get mode
	JUMPE A,[LDB A,PBYTSZ	; In mode 0, infer mode from byte size
		CAIN A,8
		TEST(O,IMAGE)
		CAIN A,=36
		TEST(O,PTPBI)
		JRST PTPOP1]
	CAIN A,14		; If binary
	TEST(O,PTPBI)		; Set binary flag
	CAIN A,13		; If image binary
	TEST(O,PTPIB)		; Set image binary flag
	CAIN A,10		; If image
	TEST(O,IMAGE)		; Set image flag
PTPOP1:	MOVEI B,7		; Get 7 bit bytes
	TEST(NE,IMAGE)		; Unless image mode
	MOVEI B,8		; Then 8 bits
	TEST(NE,PTPBI,PTPIB)	; Unless binary or image binary
	MOVEI B,6		; Then get 6
	DPB B,[POINT 6,PTPPTR,11]
				; Store in byte pointer
	MOVEM IOS,PTPSTS	; Store status word
	SETOM PTPCNT		; No full buffers
	SETZM PTPITC		; No items left in current buffer
	UNLOCK PTPLCK
	MOVEI A,200
	MOVEM A,PTPFDC		; Feed 200 lines
	MOVEI A,PTPCHN
	CONO PTP,PTPDON(A)	; Set done flag to cause interrupt
	SETZM FILBYN(JFN)
	SETZM FILLEN(JFN)
	TEST(O,WNDF)
	JRST SKPRET

; Close ptp
; Call:	JFN	; Jfn
;	PUSHJ P,PTPCLZ
; Returns
;	+1	; Always

PTPCLZ:	SKIPE FILBYN(JFN)
	PUSHJ P,DMPBUF		; Dump partial buffer
	MOVE A,[XWD PTPCNT,DISLT]
	SKIPL PTPCNT
	JSYS EDISMS		; Dismiss til last buffer being dumped
	MOVE A,[XWD PTPITC,DISLET]
	SKIPLE PTPITC
	JSYS EDISMS		; Dismiss till last buffer out
	MOVEI B,400
	MOVEM B,PTPFDC
	MOVEI A,PTPCHN
	JRST [	CONO PI,400	; Pi off, (literal to make resident)
		CONSO PTP,PTPBSY
		CONO PTP,PTPDON(A)
		CONO PI,200
		JRST .+1]
	MOVE A,[XWD PTPFDC,DISLET]
	JSYS EDISMS		; Wait for feed
	SETZM PTPSTS
	JRST SKPRET

; Ptp sequential output
; Call:	A	; Byte
;	JFN	; Jfn
;	PUSHJ P,PTPSQO
; Returns
;	+1	; Always

PTPSQO:	MOVE IOS,PTPSTS		; Get status word
	PUSH P,A		; Preserve byte
	TEST(ZE,WNDF)		; Buffers set up yet?
	PUSHJ P,SETBUF		; No, do it
	SOSGE FILCNT(JFN)	; Buffer full?
	PUSHJ P,DMPBUF		; Yes, dump it
	AOS FILBYN(JFN)		; Count bytes in buffer
	POP P,A
	IDPB A,FILBYT(JFN)	; Deposit in buffer
	POPJ P,

DMPBUF:	MOVSI IOS,ALTP
	XORB IOS,PTPSTS		; Complement buffer
	MOVEI A,PTPBF1
	TEST(NN,ALTP)
	MOVEI A,PTPBF2
	PUSH P,A
	MOVEI A,=36
	LDB B,PBYTSZ		; User's byte size
	IDIV A,B		; User bytes per word
	MOVEI B,5		; 5 punch bytes per word
	TEST(NE,IMAGE)		; Unless image mode
	MOVEI B,4		; Then 4
	TEST(NE,PTPIB,PTPBI)	; Unless a binary mode
	MOVEI B,1		; Then 1
	IMUL B,FILBYN(JFN)
	IDIV B,A		; Number of output bytes in buffer
	SKIPE C
	AOS B			; Round up
	POP P,A			; Get buffer location
	HRRZM B,(A)		; Store count in buffer word 0
	TEST(NN,PTPBI)
	JRST NOCHKS
	PUSH P,A
	MOVNS B			; Negate count
	HRL A,B			; Make aobjn word
	AOS A			; Start with word 1
	SETZ B,			; Clear b

CHKSML:	ADD B,(A)		; Sum words of buffer
	AOBJN A,CHKSML
	SETZ A,
	ROTC A,=12		; High 12 bits to a
	ROT B,=12		; Middle 12 to low end of b
	ADDI A,(B)		; Add middle to high
	ROT B,=12
	ANDI B,7777		; Get low 12
	ADDB B,A		; Add everything together
	ANDI A,7777		; Retain low 12 in a
	LSH B,-=12		; Get excess
	JUMPN B,.-3		; Do end around carry for 1's comp
	POP P,B			; Get back buffer loc
	HRLM A,(B)		; Store checksum
NOCHKS:	MOVEI A,PTPCHN
	AOSN PTPCNT		; Count one more full buffer
	CONO PTP,PTPDON(A)	; If this is first one, start punch
	PUSHJ P,SETBUF
	SOS FILCNT(JFN)
	POPJ P,

SETBUF:	MOVE A,[XWD PTPCNT,DISLET]
	SKIPLE PTPCNT		; Are all buffers non-empty?
	JSYS EDISMS		; Yes, wait for one to empty
	MOVEI A,PTPBF1+1	; Use buffer 1
	TEST(NE,ALTP)		; Unles alternate flag
	MOVEI A,PTPBF2+1	; Then use 2
	HRRM A,FILBYT(JFN)	; Point program byte pointer to buffer
	MOVEI A,=36
	DPB A,PBYTPO		; Position to left of first word
	MOVEI A,=36
	LDB B,PBYTSZ		; User's byte size
	IDIV A,B		; Bytes per word
	IMULI A,BUFSIZ-1	; Bytes per buffer
	MOVEM A,FILCNT(JFN)	; Init filcnt
	SETZM FILBYN(JFN)	; No bytes written yet
	POPJ P,

; Ptp interrupt routine

USE

PTPSV:	XWD PTPSVR,.+1
	CONSO PTP,PTPDON	; Ptp interrupt?
	JRST @PTPSVR		; No
	MOVEM IOS,PTPSIO	; Save ios
	MOVE IOS,PTPSTS		; Get status word
	CONSZ PTP,PTPEOT	; Out of tape?
	 JRST [	TEST(O,STOP)
		CONO PTP,0
		SETZM PTPTIM
		JRST PTPXIT]
	SKIPGE PTPFDC		; Negative?
	JRST [	DATAO PTP,PTPFDC; Yes, has a special character to output
		SETZM PTPFDC
		JRST PTPXIT]
	SKIPG PTPFDC		; Greater than 0?
	JRST PTPSV1	; No, check for data
	DATAO PTP,[0]		; Yes, punch blank line
	SOS PTPFDC
PTPXIT:	MOVEM IOS,PTPSTS
	MOVE IOS,PTPSIO
	JRST PTPCHR

PTPSV1:	SKIPG PTPITC		; Items left in buffer?
	JRST PTPSV2		; No.
	ILDB A,PTPPTR		; Yes, get one
	TEST(NE,PTPBI,PTPIB)	; A binary mode?
	JRST PTPSV3		; Yes, skip the following
	TEST(NE,IMAGE)		; Image mode?
	JRST PTPSV4		; Yes, skip even more
	CAIE A,0
	CAIN A,177
	JRST [	SOSLE PTPITC	; Skip nulls and rubouts
		JRST PTPSV1	; Not empty, get another character
		SOS PTPCNT
		JRST PTPSV2]	; Empty, get another buffer
	MOVEI B,10
	CAIN A,14		; If form feed,
	MOVEM B,PTPFDC		; Feed 10 lines after it
	CAIE A,11		; After tab
	CAIN A,13		; Or vert tab,
	SETOM PTPFDC		; Punch rubout
	MOVE B,A
	IMULI B,200401		; Compute parity
	AND B,[11111111]
	IMUL B,[11111111]
	TLNN B,(1B14)		; If even
PTPSV3:	IORI A,200		; Set bit (here for binary too)

PTPSV4:	DATAO PTP,A		; Jump here for image mode
	SOSLE PTPITC		; Count items
	JRST PTPXIT		; Some left
	SOS PTPCNT
	MOVEI B,10
	TEST(NE,PTPBI)		; If binary,
	MOVEM B,PTPFDC		; Folow each buffer with blank tape
	JRST PTPXIT

PTPSV2:	SKIPGE PTPCNT
	JRST [	CONO PTP,0	; Turn off punch
		JRST PTPXIT]
	MOVEI A,PTPBF1
	TEST(CE,ALTI)
	MOVEI A,PTPBF2
	HRRZ B,(A)		; Get item count of buffer
	TEST(NE,PTPBI)		; If binary
	AOSA B			; One more to include header
	AOS A			; If not, start with word 1
	TEST(NE,PTPIB,PTPBI)	; If a binary mode,
	IMULI B,6		; There are six 6-bit bytes per word
	MOVEM B,PTPITC
	HRRM A,PTPPTR		; Point pointer to the first word
	MOVEI A,44
	DPB A,[POINT 6,PTPPTR,5]; Point to left of first byte
	JRST PTPSV1		; And continue with the new buffer

PTPCHK:	MOVEI A,=60000
	MOVEM A,PTPTIM
	MOVE A,PTPSTS
	TLNE A,OPN
	TLNN A,STOP
	POPJ P,
	MOVEI A,=5000
	MOVEM A,PTPTIM
	CONSZ PTP,PTPEOT
	POPJ P,
	MOVSI A,STOP
	ANDCAM A,PTPSTS
	CONO PTP,PTPDON+PTPCHN
	POPJ P,

^DISLT:	SKIPL (1)
	JRST (4)
	JRST 1(4)

^DISLET:SKIPLE (1)
	JRST 0(4)
	JRST 1(4)

^DISGT:	SKIPG (1)
	JRST 0(4)
	JRST 1(4)

BENDP	PTP>

IFDEF PTRN,<
	BEGINP	PTR		R.S.TOMLINSON	18 MAY 1971	1328:

INTERN	PTRSV,PTRRST

; Ac's

IOS_6

; Parameters

PTR_104		; Ptr device code
PTRDON__10	; Done coni/o bit
PTRBSY__20	; Busy coni/o bit
PTRBIN__40	; Binary mode coni/o bit
PTREOT__400	; End of tape coni bit
BUFSIZ__41	; Size of ptr buffers

; Externally defined things

EXTERN	PTRCHN	; Ptr pi channel
EXTERN	PTRCHR	; Return from ptr interrupt

; Storage

LS(PTRBF1,BUFSIZ)	; First buffer
LS(PTRBF2,BUFSIZ)	; Second buffer
LS(PTRSTS)		; Status word
LS(PTRLCK)		; Ptr open lock
LS(PTRCNT)		; Count of full buffers
LS(PTRITC)		; Count of room left in filling buffer
LS(PTRCHC)		; Count of items inserted in buffer
LS(PTRPTR)		; Byte pointer for filling buffers
LS(PTRSVR)		; Interrupt return location
LS(PTRSIO)		; Saved ios during int

; Flags in ptrsts and ios

FLG(ALTP,L,IOS,400000)	; Buffer 2 for prog
FLG(ALTI,L,IOS,200000)	; Buffer 2 for int
FLG(OPN,L,IOS,040000)	; Ptr is open
FLG(IMAGE,L,IOS,020000)	; Ptr operating in image mode (10)
FLG(PTRBI,L,IOS,010000)	; Ptr operating in binary mode (14)
FLG(PTRIB,L,IOS,004000)	; Ptr operation in image binary mode (13)
FLG(STOP,L,IOS,002000)	; Don't do datai next int
FLG(FIRST,L,IOS,001000)	; First word of binary block
FLG(EOTF,L,IOS,000400)	; End of tape seen ==> eof

; Initialize ptr
; Call:	PUSHJ P,PTRINI
; Returns
;	+1	; Always (used at system initialization time)
USE

^PTRINI:SETZM PTRSTS
	SETOM PTRLCK
	SETOM PTRCNT
	POPJ P,

PTRRST:	SKIPL PTRCNT
	CONO PTR,PTRDON+PTRCHN
	POPJ P,

USE SWAPPC

; Ptr dispatch table

^PTRDTB:CPOPJ		; Set directory
	CPOPJ		; Name lookup
	CPOPJ		; Extension lookup
	CPOPJ		; Version lookup
	CPOPJ		; Protection insertion
	CPOPJ		; Account insertion
	CPOPJ		; Status insertion
	PTROPN		; Open
	PTRSQI		; Input
	CPOPJ		; Output
	PTRCLZ		; Close
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dumpi
	CPOPJ		; Dumpo
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Init directory
	CPOPJ		; Mtopr
	CPOPJ		; Get status
	CPOPJ		; Set status

; Open ptr
; Call:	JFN	; The job file number
;	PUSHJ P,PTROPN
; Return
;	+1	; Error, error number in 1
;	+2	; Success

PTROPN:	LOCK PTRLCK,<PUSHJ P,LCKTST>	; Lock up this routine
	MOVE IOS,PTRSTS
	CONSO PTR,PTREOT	; Any tape in reader?
	 JRST [	UNLOCK PTRLCK	; No, fail
		MOVEI A,OPNX8
		POPJ P,]
	TEST(OE,OPN)		; Set open bit, already open?
	 JRST [	UNLOCK PTRLCK	; Yes, give busy error
		MOVEI A,OPNX9
		POPJ P,]
	TLZ IOS,ALTP!ALTI!IMAGE!PTRIB!PTRBI!STOP!FIRST
	LDB A,[POINT 4,STS,35]	; Get mode
	JUMPE A,[LDB A,PBYTSZ	; Mode 0, default format by byte size
		CAIN A,8
		TEST(O,IMAGE)
		CAIN A,=36
		TEST(O,PTRBI,FIRST)
		JRST PTROP1]
	CAIN A,14		; Binary?
	TEST(O,PTRBI,FIRST)	; Yes, set binary and first flags
	CAIN A,13		; Image binary?
	TEST(O,PTRIB)		; Yes, set image binary flag
	CAIN A,10		; Image?
	TEST(O,IMAGE)		; Yes, set image flag

PTROP1:	MOVEI A,7		; Store 7 bit bytes
	TEST(NE,IMAGE)		; Unless image mode,
	MOVEI A,8		; Then store 8 bit bytes
	TEST(NE,PTRBI,PTRIB)	; Unless binary or image binary
	MOVEI A,44		; Then 36 bit bytes
	IORI A,4400
	DPB A,[POINT 12,PTRPTR,11]
	MOVEM IOS,PTRSTS
	SETZM PTRCNT		; Zero full buffers
	MOVEI A,5*(BUFSIZ-1)	; Character count
	TEST(NE,IMAGE)
	MOVEI A,4*(BUFSIZ-1)	; Unless image mode
	TEST(NE,PTRBI,PTRIB)
	MOVEI A,BUFSIZ-1	; Unless binary mode
	MOVEM A,PTRITC
	MOVEI A,PTRBF1
	TEST(NN,PTRBI)
	MOVEI A,PTRBF1+1
	HRRM A,PTRPTR
	SETZM PTRCHC
	MOVEI A,PTRCHN
	TEST(NE,PTRBI,PTRIB)
	MOVEI A,PTRBIN(A)
	CONO PTR,PTRBSY(A)	; Set busy and let it go
	UNLOCK PTRLCK
	SETZM FILLEN(JFN)
	SETZM FILCNT(JFN)
	JRST SKPRET

; Ptr close
; Call:	JFN	; Jfn
;	PUSHJ P,PTRCLZ

PTRCLZ:	CONO PTR,0
	PUSHJ P,PTRINI
	JRST SKPRET

; Ptr sequential input
; Call:	JFN	; Jfn
;	PUSHJ P,PTRSQI
; Returns
;	+1	; Always, byte in a, sets eof if no more input

PTRSQI:	MOVE IOS,PTRSTS		; Get status of ptr
	SOSGE FILCNT(JFN)	; Any thing left in buffer?
	PUSHJ P,WATBUF		; No, wait for it to fill
	TEST(NE,EOFF)
	POPJ P,
	ILDB A,FILBYT(JFN)
	POPJ P,

WATBUF:	MOVSI A,EOTF
	TDNE A,PTRSTS
	 JRST [	SOSL PTRCNT
		JRST WATBU1
		TEST(O,EOFF)
		POPJ P,]
	MOVEI A,PTRCHN
	TEST(NE,PTRIB,PTRBI)
	MOVEI A,PTRCHN+PTRBIN
	SOSN B,PTRCNT
	CONO PTR,PTRDON(A)	; If this cono is executed, the
				; State of the ptr is with a word
				; In the buffer

	MOVE A,[XWD PTRCNT,DISGET]
	CAIGE B,0
	JSYS EDISMS
WATBU1:	MOVSI IOS,ALTP
	XORB IOS,PTRSTS
	MOVEI A,PTRBF1
	TEST(NN,ALTP)
	MOVEI A,PTRBF2
	HRRZ B,(A)		; Get count
	JUMPE B,WATBUF		; Empty buffer, ignore it
	PUSH P,B		; Save

; Checksum check here
	HRRM A,FILBYT(JFN)	; Point byte pointer to the buffer
	MOVEI C,0
	DPB C,PBYTPO
	MOVEI C,5		; Number of bytes per word in ascii
	TEST(NE,IMAGE)
	MOVEI C,4		; In image
	TEST(NE,PTRBI,PTRIB)
	MOVEI C,1
	LDB B,PBYTSZ		; Users byte size
	MOVEI A,=36
	IDIV A,B		; Bytes per word for user
	POP P,B
	IMUL A,B
	IDIV A,C
	MOVEM A,FILCNT(JFN)
	SOS FILCNT(JFN)
	ADDM A,FILLEN(JFN)
	POPJ P,

; Ptr interrupt service routine

USE

PTRSV:	XWD PTRSVR,.+1
	CONSO PTR,PTRDON
	JRST @PTRSVR
	MOVEM IOS,PTRSIO	; Save ios
	MOVE IOS,PTRSTS
	TEST(ZE,STOP)
	JRST [	CONO PTR,0
		JRST PTRXIT]
	CONSO PTR,PTREOT
	JRST PTROFF		; End of tape
	DATAI PTR,A		; Read the character
	TEST(ZE,FIRST)
	JRST [	HRRZI B,(A)	; Get word conut
		CAILE B,BUFSIZ-1	; Too big?
		HRRI A,BUFSIZ-1	; Make it max
		MOVEI B,1(A)
		MOVEM B,PTRITC
		JRST .+1]
	TLNN IOS,IMAGE!PTRBI!PTRIB
	JRST [	ANDI A,177	; Ascii
		JUMPE A,PTRXIT
		CAIN A,177
		JRST PTRXIT
		JRST .+1]
	IDPB A,PTRPTR
	AOS B,PTRCHC
	SOSLE PTRITC
	JRST PTRXIT

PTRIN:	MOVEI A,PTRBF1
	TEST(CE,ALTI)
	MOVEI A,PTRBF2
	TEST(ZN,FIRST)
	TEST(NN,PTRBI)
	HRRZM B,(A)
	MOVEI A,PTRBF1
	TEST(NE,ALTI)
	MOVEI A,PTRBF2
	SETZM PTRCHC
	TEST(NN,PTRBI)
	AOS A
	HRRM A,PTRPTR
	MOVEI A,44
	DPB A,[POINT 6,PTRPTR,5]
	MOVEI A,5*(BUFSIZ-1)
	TEST(NE,IMAGE)
	MOVEI A,4*(BUFSIZ-1)
	TEST(NE,PTRIB,PTRBI)
	MOVEI A,BUFSIZ-1
	MOVEM A,PTRITC
	TEST(NE,PTRBI)
	TEST(O,FIRST)
	AOSLE PTRCNT
	TEST(O,STOP)
PTRXIT:	MOVEM IOS,PTRSTS
	MOVE IOS,PTRSIO
	JRST PTRCHR

PTROFF:	MOVE B,PTRCHC
	TEST(O,EOTF)
	CONO PTR,0
	JRST PTRIN

	BENDP	PTR>
IFDEF MTAN,<
	BEGINP	MAGTAP		R.S.TOMLINSON	 23 SEPTEMBER 1971	1625:

; Externally defined symbols used herein

EXTERN	MTACHN		; Flag channel
EXTERN	MTDCHN		; Data channel
EXTERN	MTACHR		; Return from magtape interrupt
EXTERN	MTATIM		; Countdown for testing rewinding tapes
EXTERN	NSKED		; No schedule flag
EXTERN	RSKED		; Reschedule instruction
EXTERN	EDISMS		; Exec dismiss

; Entries to this part

INTERN	MTASV		; Interrupt service routine
INTERN	MTARST
INTERN	MTACHK		; Clock level routine to check rewinding tapes

DEFINE	MTALOC<MTDCHN*2+40>
DEFINE	MTBOTH<MTACHN*10+MTDCHN>
DEFINE	NOSKED<AOS NSKED>
DEFINE	OKSKED<SOSG NSKED
	XCT RSKED>

UNIT_5
IOS_6
PI__4
MTC_340
MTS_344
MTTRY__5

; Private storage for magtapes

LS(MTALCK,MTAN)	; Lock word
LS(MTASTS,MTAN)	; Status of unit
MTSTKL__20
LS(MTSTK,MTSTKL); Stack for mta int
LS(REWCNT)	; Number of rewinding units
LS(MTIOWD,MTAN)	; Iowd for next transfer
LS(MTERAS)	; Rewrite erase counter
LS(MTPNTR)	; Iowd during transfer
LS(MTAUNT)	; Unit currently attached to controller
LS(MTERRC)	; Retry counter
LS(MTERFL)	; State of retry
LS(MTACOM)	; Cono word of current operation
LS(MTAINR)	; Return address from flag interrupt
LS(MTDINR)	; Return address from data interrupt
LS(MTACLS)	; Clock routine switch, 0 for no clock wanted
LS(MTARCE,MTAN)	; Total error count

; Pointers to fields of interrest

USE

PMTOP:	POINT 9,MTASTS(UNIT),17	; Mtape operation code
PDENS:	POINT 3,MTASTS(UNIT),28	; Density and parity

USE	SWAPPC

; Flags in lh of mtasts (or ios)

FLG(IO,L,IOS,400000)	; Direction of transfer
FLG(IOACT,L,IOS,200000)	; Action in progress or about to be
FLG(OPN,L,IOS,100000)	; This unit is open
FLG(REW,L,IOS,040000)	; Rewind in progress
FLG(MTP,L,IOS,020000)	; Mtape op wanted

; Dispatch table

^MTADTB:MTASET
	MTANAM
	MTAEXT
	MTAVER
	CPOPJ
	CPOPJ
	CPOPJ
	MTAOPN
	MTASQI
	MTASQO
	MTACLZ
	MTAREN
	MTADEL
	MTDMPI
	MTDMPO
	MTAMNT
	MTADSM
	MTINID
	MTMTAP
	MTSTS
	MTRTS

; Initialize magtape

USE

^MTAINI:CONO MTC,0
	SETZM REWCNT
	SETZM MTAUNT
	SETZM MTERRC
	SETOM MTERFL
	MOVSI UNIT,-MTAN
MTAINL:	SETOM MTALCK(UNIT)
	SETZM MTASTS(UNIT)
	AOBJN UNIT,MTAINL
	POPJ P,

MTARST:	SKIPN MTAUNT
	POPJ P,
	PUSH P,P
	POPJ P,UNIT
	PUSH P,IOS
	MOVE UNIT,MTAUNT
	MOVE IOS,MTASTS(UNIT)
	JSYS [XWD MTAINR,MTARS1]
	POPJ P,

MTARS1:	SKIPL A,MTERFL
	JRST TRYAGN
	JRST DATEN1

USE	SWAPPC

; Mount magtape

MTAMNT:	JRST SKPRET		; Any kind of mount is ok for now
	JUMPL B,SKPRET		; Directoryless mount only
	POPJ P,

; Dismount magtape

MTADSM:	JRST SKPRET

; Initialize directory

MTINID:	POPJ P,

; Get mag tape status

MTSTS:	HLRZ UNIT,DEV
	MOVSI A,IOACT
	TDNE A,MTASTS(UNIT)
	 PUSHJ P,DISBIT		; WAIT FOR IOACT TO GO OFF
	MOVE B,MTIOWD(UNIT)
	UMOVEM B,3
	IOR A,MTASTS(UNIT)
	POPJ P,

; Set mag tape status

MTRTS:	HLRZ UNIT,DEV
	PUSH P,A
	MOVSI A,IOACT
	TDNE A,MTASTS(UNIT)
	 PUSHJ P,DISBIT
	POP P,A
	ANDCMI A,17
	HRRM A,MTASTS(UNIT)
	POPJ P,

; Set magtape directory

MTASET:	POPJ P,

; Name lookup

MTANAM:	POPJ P,

; Extension lookup

MTAEXT:	POPJ P,

; Version lookup

MTAVER:	MOVEI A,0
	TEST(NE,UNLKF)
	JRST SKPRET
	UNLOCK MTALCK(UNIT)
	OKINT
	JRST SKPRET

; Open magtape

MTAOPN:	HLRZ UNIT,DEV
	MOVE IOS,MTASTS(UNIT)
	TLNE STS,74000
	JRST MTAACC		; Execute access etc not allowed
	LDB A,[POINT 4,STS,35]	; Get mode
	CAIE A,17
	JRST MTAILM		; Must be dump mode for now
	LOCK MTALCK(UNIT),<PUSHJ P,LCKTST>
	TEST(NE,OPN)
	JRST BUSY		; Unit is busy, wait
	MOVSI A,OPN
	IORM A,MTASTS(UNIT)
	HLLZS MTASTS(UNIT)
	UNLOCK MTALCK(UNIT)
	JRST SKPRET

; Mtape uuo
; Call:	B	; The operation wanted
;	PUSHJ P,MTMTAP

MTMTAP:	CAIL B,20
	POPJ P,
	HLRZ UNIT,DEV
	LOCK MTALCK(UNIT),<PUSHJ P,LCKTST>
	MOVSI A,IOACT
	TDNE A,MTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVE IOS,MTASTS(UNIT)
	TRZ IOS,1B18!1B19!1B20!1B22!1B23!1B24!1B25!7B31!17B35
	TEST(O,IOACT,MTP)
	MOVEM IOS,MTASTS(UNIT)
	DPB B,PMTOP
	UNLOCK MTALCK(UNIT)
	HRROI UNIT,MTAN-1
	SETZM MTACLS
	SKIPN MTAUNT
	PUSHJ P,MTNXT
	POPJ P,

USE

MTPTBL:	XWD 101,0		; Rew nop
	XWD 405,0		; Eof nil
	XWD 0,0			; Nil nil
	XWD 107,6		; Bkspc rec, skip rec
	XWD 111,0		; Rew&unload, nil
	XWD 415,0		; Blank tape, nil
	XWD 0,0			; Nil nil
	XWD 117,16		; Back file, skip file

USE	SWAPPC

; Sequential input

MTASQI:	BUG(HLT,<MTASQI: NO WAY TO GET HERE.>)

; Sequential output

MTASQO:	BUG(HLT,<MTASQO: NO WAY TO GET HERE.>)

; Delete file

MTADEL:	POPJ P,

; Rename file

MTAREN:	POPJ P,

MTACLZ:	HLRZ UNIT,DEV
	MOVSI A,IOACT
	LOCK MTALCK(UNIT)
	TDNE A,MTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVSI A,OPN
	ANDCAM A,MTASTS(UNIT)
	UNLOCK MTALCK(UNIT)
	JRST SKPRET

MTAACC:	MOVEI A,OPNX15
	POPJ P,

MTDMPI:	TDZA IOS,IOS
MTDMPO:	MOVSI IOS,IO
	HLRZ UNIT,DEV
	MOVE B,A
	LOCK MTALCK(UNIT),<PUSHJ P,LCKTST>
	MOVSI A,IOACT
	TDNE A,MTASTS(UNIT)
	PUSHJ P,DISBIT
	MOVEM B,MTIOWD(UNIT)
	EXCH IOS,MTASTS(UNIT)
	TEST(Z,IO)
	TRZ IOS,1B18!1B19!1B20!1B23!1B25!1B22!1B24
	TEST(O,IOACT)
	IORB IOS,MTASTS(UNIT)
	UNLOCK MTALCK(UNIT)
	PUSH P,UNIT
	HRROI UNIT,MTAN-1
	SETZM MTACLS
	SKIPN MTAUNT
	PUSHJ P,MTNXT		; Start up magtape io
	POP P,UNIT
	MOVSI A,IOACT
	PUSHJ P,DISBIT		; Hang til complete
	HRRZ A,MTASTS(UNIT)	; Get status of transfer
	TRNE A,1B18!1B19!1B20!1B23!1B25
	TEST(O,ERRF)		; Set error flag
	TRNE A,1B22
	TEST(O,EOFF)
	POPJ P,

; Routine called periodically to check completion of rewinds

USE

MTACHK:	MOVEI A,=60000
	MOVEM A,MTATIM
	SKIPL MTACLS
	POPJ P,
	HRROI UNIT,MTAN-1

; Start up mag tape control
; Scans for mag tape units needing action starting with the
; One following that in unit

MTNXT:	SETZM MTACLS
	PUSH P,UNIT		; Save starting point
MTNXT1:	AOBJN UNIT,MTNXT2
	MOVSI UNIT,-MTAN
MTNXT2:	MOVE IOS,MTASTS(UNIT)
	TEST(NN,IOACT)
	JRST MTNXT0		; No active, try next
	MOVEI A,(UNIT)		; Prepare to seize tm10
	LSH A,=15
	CONSO MTS,2		; Control free?
	JRST [	MOVEM UNIT,MTAUNT
		TRO A,10400+MTACHN*10
		JRST MTNXT4]	; Do nop with next unit enable
	PUSHJ P,SETDEN
	CONO MTC,(A)		; Connect to the rewind tape
	CONSZ MTS,200000	; Still rewinding?
	JRST MTNXT9		; Yes, continue
	TEST(NN,REW)		; Rewinding?
	JRST MTNXT3		; No.
	TEST(Z,REW,IOACT)	; Clear rew and ioact
	HLLM IOS,MTASTS(UNIT)
	SOS REWCNT		; Decrease count of rewinding units
MTNXT0:	CAME UNIT,(P)
	JRST MTNXT1
	MOVEI A,=1000		; Delay for one second
	MOVEM A,MTATIM
MTNXTX:	SKIPLE REWCNT
	AOS MTACLS		; One more reason for running clock rout
	SKIPN MTAUNT
	MOVNS MTACLS		; Make neg if unless controller busy
	POP P,UNIT
	POPJ P,

MTNXT9:	TEST(NE,REW)		; Do we think it's rewinding?
	JRST MTNXT0		; Yes, go to next unit
	AOS MTACLS		; Have a reason for running clock
	MOVEI A,=1000
	MOVEM A,MTATIM
	CAME UNIT,(P)
	JRST MTNXT1
	JRST MTNXTX

MTNXT3:	MOVEM UNIT,MTAUNT
	TEST(NE,MTP)		; Mtape op wanted?
	JRST MTDOOP		; Yes
	MOVSI A,(<BLKI MTC,>)
	TEST(NE,IO)
	MOVSI A,(<BLKO MTC,>)
	HRRI A,MTPNTR
	MOVEM A,MTALOC
	MOVE A,[JSYS MTATHR]
	MOVEM A,MTALOC+1
	MOVE A,MTIOWD(UNIT)
	MOVEM A,MTPNTR
	MOVEI A,MTTRY
	MOVEM A,MTERRC
	SETZM MTERAS		; Erase 0 tape initially
	SETOM MTERFL
	HRRZ A,UNIT
	LSH A,=15
	TEST(NE,IO)
	TROA A,4000+MTBOTH	; Write function
	TRO A,2000+MTBOTH	; Read function
MTNXT4:	PUSHJ P,SETDEN		; Insert density and parity
	HRRM A,MTACOM
	CONO MTC,(A)
	JRST MTNXTX

MTDOOP:	MOVEI A,(UNIT)
	LSH A,=15
	PUSHJ P,SETDEN
	CONO MTC,(A)		; Connect to unit
	LDB B,PMTOP		; Get mtap word
	ROT B,-1
	SKIPL B
	SKIPA B,MTPTBL(B)
	HLRZ B,MTPTBL(B)
	TRZE B,100		; Backward?
	CONSO MTS,100000	; Yes, and at bot?
	JRST .+3
	TRO IOS,1B24		; Set bot bit and
	MOVEI B,0		; Change to nop
	ANDI B,17
	JUMPE B,[TLZ IOS,MTP!IOACT!777
		MOVEM IOS,MTASTS(UNIT)
		SETZM MTAUNT
		JRST MTNXT0]
	LSH B,9
	IORI A,MTACHN*10(B)
	PUSHJ P,SETDEN
	HRRM A,MTACOM
	TLZ IOS,777!MTP
	MOVEM IOS,MTASTS(UNIT)
	CONO MTC,(A)
	JRST MTNXTX

SETDEN:	LDB B,PDENS
	TRZN B,4
	TRO A,1B21
	CAIN B,0
	MOVEI B,3
	SOS B
	LSH B,6
	IOR A,B
	POPJ P,

; Data done interrupt

MTATHR:	XWD MTDINR,.+1
	CONO MTS,1
	JEN @MTDINR

; Flag interrupt

MTASV:	XWD MTAINR,.+1
	CONSZ MTC,400		; Next unit enable
	CONSO MTS,2		; And control free
	CONSZ MTS,440100	; Or illop, hung xprt, job done
	JRST .+2		; Is reason for interrupt
	JRST @MTAINR		; Else this is not a mag tape int
	MOVEI A,MTACHR
	MOVEM A,MTAINR
	MOVEM P,MTSTK
	MOVE P,[XWD -MTSTKL+1,MTSTK]
	PUSH P,UNIT
	PUSH P,IOS
	MOVE UNIT,MTAUNT
	MOVE IOS,MTASTS(UNIT)
	CONSZ MTC,400		; Next unit interrupt?
	JRST MTASV3		; Yes, go look for something to do
	SKIPL A,MTERFL		; Are we trying to recover from an error
	JRST TRYAGN		; Yes
	CONSZ MTS,400000+1B27
	JRST THRTAP
	CONSZ MTS,040000
	JRST ILLOP
	CONSZ MTC,7		; Data operation?
	JRST DATEND		; Yes
	LDB A,[POINT 4,MTACOM,26]	; Get cono word
	CONSZ MTS,10000		; Eof?
	TRO IOS,1B22		; Yes, set device eof
	CAIE A,1		; Rewind
	CAIN A,11		; Or unload
	JRST MTARW1

THRTAP:	CONI MTS,A
	TRNE A,1B20
	TROA IOS,1B24		; Set bot
	TRZ IOS,1B24
	TRNE A,1B24
	TRO IOS,1B25		; Eot
	TRNE A,1B22!1B25!1B28
	TRO IOS,1B20		; Data error
	TRNE A,1B27!1B18

	TRO IOS,1B19		; Data late or hung xprt
	LSH A,-=14
	ANDI A,7B31		; Get character count
	CONSO MTS,1B26		; Incorrect record length?
	JRST MTASV1		; No
	TRZ IOS,7B31		; Yes, clear old character count
	TRO IOS,1B23		; Set incorrect record length bit
	IORI IOS,(A)		; And set count
MTASV1:	TEST(Z,IOACT)		; Io no longer active
MTASV2:	MOVEM IOS,MTASTS(UNIT)
MTASV3:	MOVE A,MTACOM
	TRZ A,17477
	CONO MTC,(A)		; Clear bits
	SETZM MTAUNT
	PUSHJ P,MTNXT		; Find something else
MTAXIT:	POP P,IOS
	POP P,UNIT
	POP P,P
	JRST @MTAINR

ILLOP:	LDB A,[POINT 4,MTACOM,26]
	CAIE A,4
	CAIN A,14
	SKIPA
	CAIN A,5
	CONSO MTS,1B32
	TROA IOS,1B19
	TRO IOS,1B18
	JRST THRTAP

DATEND:	CONSO MTS,21600		; Data errors?
	JRST DATND1
DATEN1:	AOS MTARCE(UNIT)
	TRNE IOS,1B21
	JRST DATND1
	SOSG MTERRC
	JRST PRMERR		; Permanent error
RETRY0:	MOVE A,MTERAS
	ADDI A,2
RETRY1:	MOVEM A,MTERFL		; Initialize error sequence
	MOVE A,MTACOM		; Get original command
	ANDI A,760770		; Retain unit, density etc
	CONO MTC,7000(A)	; Space backward
	JRST MTAXIT

DATND1:	HRRZ A,MTPNTR
	SUB A,MTIOWD(UNIT)
	HRLZM A,MTIOWD(UNIT)
	CONSZ MTS,10000
	TRO IOS,1B22
	JRST THRTAP

PRMERR:	TEST(NN,IO)		; Write?
	JRST DATND1		; No, report error and quit
	AOS MTERAS
	MOVEI A,MTTRY
	MOVEM A,MTERRC
	JRST RETRY0

TRYAGN:	CONSZ MTS,100000	; Bot?
	MOVE A,MTERAS
	SOJL A,TRYAG1
	MOVEM A,MTERFL
	CAMLE A,MTERAS
	JRST RETRY1
	CAME A,MTERAS
	JRST TRYAG2
	MOVEM A,MTERFL
	MOVE A,MTACOM		; Now space forward over preceeding rec
	ANDI A,760770
	CONO MTC,6000(A)
	JRST MTAXIT

TRYAG2:	JUMPL A,TRYAG1
	MOVE A,MTACOM
	ANDI A,760770
	CONO MTC,15000(A)	; Erase tape
	JRST MTAXIT

TRYAG1:	SETOM MTERFL
	MOVE A,MTIOWD(UNIT)
	MOVEM A,MTPNTR
	MOVE A,MTACOM
	CONO MTC,(A)		; Redo original op
	JRST MTAXIT

MTARW1:	TEST(O,REW)		; Remember this tape is rewinding
	AOS REWCNT
	JRST MTASV2


BUSY:	MOVEI A,OPNX9
	UNLOCK MTALCK(UNIT)
	POPJ P,

MTAILM:	MOVEI A,OPNX14
	POPJ P,

DISBIT:	PUSH P,A+1
	JFFO A,.+1
	PUSH P,A
	MOVEI A,BITTST
	DPB A+1,[POINT 9,A,8]
	DPB UNIT,[POINT 9,A,17]
	JSYS EDISMS
	POP P,A
	POP P,A+1
	POPJ P,

USE

BITTST:	LDB 2,[POINT 9,1,26]
	LDB 3,[POINT 9,1,35]
	MOVE 3,MTASTS(3)
	ROT 3,(2)
	JUMPL 3,0(4)
	JRST 1(4)

USE	SWAPPC

	BENDP	MAGTAP>

IFDEF LPTN,<
	BEGINP	LINEPRINTER	R.S.TOMLINSON	23 SEPTEMBER 1971	1625:

; Externally defined symbols

EXTERN	LPTCHN		; Interrupt channel
EXTERN	LPTCHR		; Return from line printer interrupt
EXTERN	NSKED		; No schedule flag
EXTERN	RSKED		; Reschedule instruction
EXTERN	EDISMS		; Exec dismiss

; Entries to this part

INTERN	LPTSV,LPTRST		; Interrupt routine

; Parameters and fixed core locations

LPTCCW__167		; Line printer control word location
LPT_124			; Line printer device
PI__4
IOS_6

LS(LPTTIM)		; Should be in clock stuff
LS(LPTINR)		; Return address in interrupt routine
LS(LPTCLS)		; Switch turns on clock stuff
LPSTKL__20
LS(LPSTK,LPSTKL)	; Stack for interrupt routine
LS(LPTLCK)		; Lock on opening lpt
LS(LPTSTS)		; Status word
LS(LPTRLP)		; Real core address for line printer
LS(LPTCNT)		; Buffer counter
LS(LPTPOS)		; Page position word
LS(LPTJOB)		; Job of last lpt opener
NRP(LPTBUF,1000)

FLG(ALTP,L,IOS,400000)
FLG(ALTI,L,IOS,200000)
FLG(OUERR,L,IOS,100000)	; Output error
FLG(OPN,L,IOS,040000)	; Line printer open
FLG(ESC,L,IOS,020000)	; Escape character seen
FLG(CRSW,L,IOS,010000)	; Carret seen

; Line printer dispatch table

^LPTDTB:CPOPJ		; Set directory
	CPOPJ		; Name lookup
	CPOPJ		; Extension
	CPOPJ		; Version
	CPOPJ		; Protection insertion
	CPOPJ		; Account
	CPOPJ
	LPTOPN
	CPOPJ
	LPTSQO		; Output
	LPTCLZ
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dump
	CPOPJ
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Initialize directory
	CPOPJ		; Mtape
	CPOPJ		; Get status
	CPOPJ		; Set status

; Initialize line printer

USE

^LPTINI:SETZM LPTSTS
	SETOM LPTCNT
	SETZM LPTPOS
	SETOM LPTLCK
	POPJ P,

LPTRST:	MOVE IOS,LPTSTS
	SKIPL LPTCNT
	JRST LPTSTR
	POPJ P,

USE	SWAPPC

; Open line printer

LPTOPN:	LOCK LPTLCK,<PUSHJ P,LCKTST>
	MOVE IOS,LPTSTS
	CONSO LPT,20
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX8
		POPJ P,]
	TEST(OE,OPN)
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX9
		POPJ P,]	; Busy
	TLZ IOS,ALTP!ALTI!OUERR!ESC
	MOVEM IOS,LPTSTS
	SETOM LPTCNT		; Lpt idle
	MOVEI A,LPTBUF
	MOVES (A)
	PUSHJ P,FPTA		; Get ptn.pn for buffer
	PUSHJ P,MLKPG		; Lock the page
	LSH A,9			; Real page number to real address
	TLO A,-400*4		; 400 word count
	MOVEM A,LPTRLP		; Save
	MOVEI A,8
	DPB A,PBYTSZ		; 8 bit bytes
	MOVEI A,0
	DPB A,PBYTPO		; Position
	MOVEI A,LPTBUF-1
	HRRM A,FILBYT(JFN)	; Point to buffer
	MOVEI A,400*3
	MOVEM A,FILBYN(JFN)	; Character count
	TEST(Z,WNDF)
	SETZM LPTPOS		; Column zero, line 0
	UNLOCK LPTLCK
	MOVEI A,240
	PUSHJ P,LPTOUT
	MOVEI A,77
	PUSHJ P,LPTOUT
	MOVE A,JOBNO
	MOVEM A,LPTJOB
	HRRZ A,JOBDIR(A)	; Get login directory number
	PUSHJ P,GDIRST		; Get name string location
	JRST LPTOP4
	UNLOCK DIRLCK		; No need to keep directory locked
	OKINT
	HRLI A,(<POINT 7,0,35>)	; Make it a byte pointer
	PUSH P,A		; Save on stack
	PUSH P,[=30]		; Number of lines of ident

LPTOP1:	PUSH P,[=10]		; Number of names per line
LPTOP2:	PUSH P,-2(P)		; Copy byte pointer to stack
LPTOP3:	ILDB A,(P)		; Get byte from string
	JUMPE A,LPTOP4		; End
	PUSHJ P,LPTSQO		; Print it
	JRST LPTOP3		; And loop thru all characters

LPTOP4:	POP P,A			; Flush spent byte pointer
	MOVEI A,11
	PUSHJ P,LPTSQO		; Follow name with tab
	SOSLE (P)		; Count names per line
	JRST LPTOP2		; Repeat
	POP P,A			; Flush spent count
	MOVEI A,37
	PUSHJ P,LPTSQO		; End line with eol
	SOSLE (P)		; Count lines of heading
	JRST LPTOP1		; Repeat for each line
	POP P,A			; Flush spent count
	MOVEI A,14
	PUSHJ P,LPTSQO		; Output form feed
	POP P,A			; Flush saved byte pointer
	JRST SKPRET

; Close line printer

LPTCLZ:	MOVEI A,40
	PUSHJ P,LPTSQO
	MOVE A,LPTPOS
	MOVEI B,4		; End with 4 form feeds to expel listing
	TRNE A,777777		; Unless not at top of form
	MOVEI B,5		; Then one more
	PUSH P,B
	MOVEI A,14
	PUSHJ P,LPTSQO
	SOSLE (P)
	JRST .-3
	POP P,A
	MOVEI A,240
LPTCL0:	PUSHJ P,LPTOUT		; Fill buffer with ignored chars
	MOVEI A,200
	TEST(NN,WNDF)		; Wndf is set when full
	JRST LPTCL0
	MOVEI 1,LPTCNT
	PUSHJ P,DISL		; Wait for line printer to stop
	MOVEI A,LPTBUF
	PUSHJ P,FPTA
	PUSHJ P,MULKPG
	MOVSI IOS,OPN
	ANDCAM IOS,LPTSTS
	JRST SKPRET

; Line printer sequential character output

LPTSQO:	ANDI A,177
	MOVSI IOS,ESC
	TDNE IOS,LPTSTS
	JRST [	IORI A,400	; Make it look like no special char
		ANDCAM IOS,LPTSTS
		JRST LPTNOR]
	CAIN A,177
	JRST [	MOVSI IOS,ESC
		IORM IOS,LPTSTS
		POPJ P,]
	CAIN A,37		; Check for special characters
	JRST LPTEOL
	JUMPE A,CPOPJ
	CAIL A,12
	CAIL A,25
	JRST LPTNOR
	CAIN A,15
	JRST [	MOVSI IOS,CRSW
		IORM IOS,LPTSTS
		HRRZS LPTPOS
		POPJ P,]
LPTFRM:	SUBI A,12
	IDIVI A,6
	EXCH A,B
	MOVE C,LPTFR1(B)
	MOVE B,LPTFR2(B)
	IMULI A,6
	ROTC B,6(A)
	ANDI B,77
	ANDI C,77
	CAIN C,60
	JRST [	MOVE A,B
		JRST LPTNOR]
	MOVSI A,CRSW
	ANDCAM A,LPTSTS		; Forget about preceding cr's
	HRRZ A,LPTPOS		; Get current line#
	PUSH P,A		; Save
	ADDI A,(B)		; Add skip for this format control
	PUSH P,B		; Save skip
	IDIV A,B		; Reduce to nearest lesser line#
	IMUL A,(P)
	POP P,B
	POP P,B			; Get back old line#
	SUBM A,B		; Get line feeds needed to simulate
	CAIL A,=60
	TRNE C,40		; Are we to skip end ofpage?
	JRST LPTFRR		; No
	SETZ A,
	MOVEI C,20

LPTFRR:	PUSH P,B		; Save line feed count for simulation
	IDIVI A,=66		; Reduce new line# mod linesperpage
	HRRM B,LPTPOS
	PUSH P,LPTPOS		; Save current column
	PUSH P,C		; Save format character and bits
	MOVEI A,240
	PUSHJ P,LPTOUT		; Terminate current line
	HRRZS LPTPOS
	POP P,A
	CAIE A,77
	TRZE A,20		; Simulate?
	JRST LPTFRZ
LPTFRQ:	SOSG -1(P)
	JRST LPTFRX
	MOVEI A,240
	PUSHJ P,LPTOUT
	JRST LPTFRQ

LPTFRX:	MOVEI A,40
LPTFRZ:	PUSHJ P,LPTOUT
	POP P,A
	SUB P,[XWD 1,1]
	HLRZS A
	JRST LPTSPC

; Format control tables
; Lptfr1 has the line space count for each format character in
; The range 12 - 24. for non-format characters in this
; Range, it contains the original character code
; Lptfr2 contains the format character to use plus bits as follows
; 40 -- spaces over end of page
; 20 -- not to be simulated with line feeds

LPTFR1:	BYTE (6)1,=20,=60,0,16,17,=30,2,3,1,=10
LPTFR2:	BYTE (6)37,5,20,77,60,60,6,2,3,40,4

LPTEOL:	HRRZS LPTPOS
	MOVEI A,12
	JRST LPTFRM

LPTCR:	MOVEI A,15
	JRST LPTFRM

LPTNOR:	MOVSI IOS,CRSW
	TDNE IOS,LPTSTS
	JRST [	ANDCAM IOS,LPTSTS
		PUSH P,A
		PUSHJ P,LPTCR
		POP P,A
		JRST .+1]
	CAIN A,11
	JRST LPTTAB
LPTNO1:	PUSHJ P,LPTOUT
	MOVSI A,1
	ADDM A,LPTPOS
	POPJ P,

LPTTAB:	HLRZ A,LPTPOS		; Get current column
	ADDI A,10
	ANDCMI A,7
	HLRZ B,LPTPOS
	SUB A,B
LPTSPC:	SOJL A,CPOPJ
	PUSH P,A
	MOVEI A,40
	PUSHJ P,LPTNO1
	POP P,A
	JRST LPTSPC

; Put 8-bit character in buffer

LPTOUT:	TEST(NE,WNDF)
	PUSHJ P,BUFWAT
	HRLZI B,201000
	IBP FILBYT(JFN)
	CAMGE B,FILBYT(JFN)	; Left 12 bits are not used
	HLLM B,FILBYT(JFN)	; Skip them
	DPB A,FILBYT(JFN)
	SOSLE FILBYN(JFN)
	POPJ P,
	MOVE IOS,LPTSTS
	AOSN LPTCNT
	PUSHJ P,LPTSTR
	MOVSI IOS,ALTP
	XORB IOS,LPTSTS
	MOVEI B,LPTBUF-1
	TEST(NN,ALTP)
	HRRM B,FILBYT(JFN)
	MOVEI B,400*3
	MOVEM B,FILBYN(JFN)
	TEST(O,WNDF)
	POPJ P,

BUFWAT:	PUSH P,1
	MOVEI 1,LPTCNT
	SKIPLE (1)
	PUSHJ P,DISLE
	TEST(Z,WNDF)
	POP P,1
	POPJ P,

DISLE:	HRLZS 1
	HRRI 1,DISLET
	JSYS EDISMS
	POPJ P,

USE

DISLET:	SKIPLE (1)
	JRST (4)
	JRST 1(4)

; Line printer interrupt

LPTSV:	XWD LPTINR,.+1
	CONSO LPT,10
	JRST @LPTINR
	MOVEI A,LPTCHR
	MOVEM A,LPTINR
	MOVEM P,LPSTK
	MOVE P,[IOWD LPSTKL-1,LPSTK+1]
	PUSH P,IOS
	MOVE IOS,LPTSTS
	CONI LPT,A
	ANDI A,1600
	TRNE A,1600		; Error?
	JRST LPTER
LPTSV1:	CONO LPT,70(A)		; Reset everything
	TEST(C,ALTI)
	MOVEM IOS,LPTSTS
	SOSL LPTCNT
	PUSHJ P,LPTSTR		; More to do
LPTXIT:	MOVEM IOS,LPTSTS
	POP P,IOS
	POP P,P
	JRST @LPTINR

LPTER:	TRNE A,600
	JRST LPTBER
	CONO LPT,70(A)
	SETOM LPTCLS		; Put in a request to restart when ready
	JRST LPTXIT

LPTBER:	BUG(CHK,<LINE PRINTER: NXM OR PARITY ERROR.>)
	JRST LPTSV1

LPTCHK:	MOVEI A,=2000
	MOVEM A,LPTTIM
	SKIPN LPTCLS
	POPJ P,
LPTSTR:	SETZM LPTCLS
	PUSH P,A
	MOVE A,LPTRLP
	TEST(NE,ALTI)
	ADDI A,400
	MOVEM A,LPTCCW
	CONO LPT,1110+LPTCHN
	POP P,A
	POPJ P,

USE	SWAPPC

	BENDP	LINEPRINTER>
IFDEF NDP,<
	BEGINP	DISPLAY		R.S.TOMLINSON	23 SEPTEMBER 1971	1621:

; Entries to this part

INTERN	DSPSV,DSPSKV,DSPINI,DSPRST,DSPKFK
INTERN	.ASNDP,.RELDP,.ASNDC,.RELDC,.STRDP,.STPDP,.STSDP,.RDSDP,.WATDP
FOR @' Q_0,7
<INTERN	.LDS'Q
>

USE

; New definition of instructions for the escc display system
; For 101129-101 type channel controls including all devices.  
; 23 september 1970  cls & gwh

DEFINE	DPRGS<
; The display processor registers :

RAR_0
WAR_1
PC_2
SP_3
P1_4
P2_5
DSP_6
UR_7
RCR_10
WCR_11
DIR_12
RSR_13
SR_14
NEXT_17
>

DEFINE	XDPRGS<
SUPPRESS RAR,WAR,PC,SP,P1,P2,DSP,UR,RCR,WCR,DIR,RSR,SR,NEXT
>

DEFINE	DPMDS<
; The next-mode's :

XQTM_10
RPTM_4
PEELM_2
PROGM_1
>

DEFINE	DPCND<
; Conditions which may be checked :

PF0_0		; Program flag #0
PF1_1		; Program flag #1
PF2_2		; Program flag #2
PF3_3		; Program flag #3
RCRN_10		; Rcr less than -1
WCRN_11		; Wcr less than -1
HITF_12		; Hit flag
AICF_13		; Area in common flag
STOPF_17	; Stop flag
>

DEFINE	XDPCND<
SUPPRESS PF0,PF1,PF2,PF3,RCRN,WCRN,HITF,AICF,STOPF
>

DEFINE	CDRGS<
; The clipper-divider registers :

SAVELB_0	; Two components
SAVERT_1	; Two components
VIEWLB_2	; Two components
VIEWRT_3	; Two components
WINDLB_4	; Two components
WINDRT_5	; Two components
INSTLB_6	; Two components
INSTRT_7	; Two components
NAME_10		; Two components
CDIR_11		; Two components
HITANG_12	; Two components
SELINT_13	; Two components

SAVE_14		; Four components
VIEW_15		; Four components
WIND_16		; Four components
INST_17		; Four components
>

DEFINE	XCDRGS<
SUPPRESS SAVELB,SAVERT,VIEWLB,VIEWRT,WINDLB,WINDRT,INSTLB,INSTRT
SUPPRESS NAME,CDIR,HITANG,SELINT,SAVE,VIEW,WIND,INST
>

DEFINE	CBRGS<
; Character bubble registers

FONT_17
CHAR_0
>

DEFINE	XCBRGS<
SUPPRESS FONT,CHAR
>

DEFINE	SBRGS<
; Sbkl registers

LITS_16
SWCH_14
>

DEFINE	XSBRGS<
SUPPRESS LITS,SWCH
>

DEFINE	DPOPS0<
; Group 0 - load immediate instructions

OPDEF	LI	[000000000000]	; Load immediate
OPDEF	LIPSH	[040000000000]	; Load imm. psh-old-value
OPDEF	LIPSHM	[060000000000]	; Load imm. psh-old-value marked
OPDEF	PSH	[LIPSH @0]	; Psh-old-value, without load
OPDEF	PSHM	[LIPSHM @0]	; Psh-old-value marked, without loading
OPDEF	NOP	[LI @0]
OPDEF	JMP	[LI PC,0]	; Note: jmp for display, jump for 10
OPDEF	JMPPSH	[LIPSHM PC,0]	; A marked [jmp 0] is saved in stack
OPDEF	NWSTK	[LIPSH SP,0]	; Unmarked [li sp,0] is saved in stack
OPDEF	NWSTKM	[LIPSHM SP,0]	; A marked [li sp,0] is saved in stack
OPDEF	XQTA	[LI RAR,(XQTM)]	; Xqt the instruction in e
OPDEF	XQT	[NOP (XQTM)]	; Entqr sqt mode
OPDEF	RPT	[NOP (RPTM)]	; Enter rpt mode
OPDEF	PEEL	[NOP (PEELM)]	; Enter peel mode
OPDEF	PROG	[NOP (PROGM)]	; Enter prog mode
>

DEFINE	DPOPS2<
; Group 2 - conditional load immediate

OPDEF	LIF	[200000000000]	; Li if condition holds
OPDEF	LIFCL	[210000000000]	; Lif and clear
OPDEF	LIFST	[220000000000]	; Lif and set
OPDEF	LIFCM	[230000000000]	; Lif and complement

OPDEF	LAL	[240000000000]	; Li always, lal is slower than li
OPDEF	LALCL	[250000000000]	; Lal and clear
OPDEF	LALST	[260000000000]	; Lal and set
OPDEF	LALCM	[270000000000]	; Lal and complement

OPDEF	JIF	[LIF PC,]	; Jmp if condition holds
OPDEF	JIFCL	[LIFCL PC,]	; Jif and clear
OPDEF	JIFST	[LIFST PC,]	; Jif and set
OPDEF	JIFCM	[LIFCM PC,]	; Jif and complement

OPDEF	JAL	[LAL PC,]	; Jmp always, jal is slower than jmp
OPDEF	JALCL	[LALCL PC,]	; Jal and clear
OPDEF	JALST	[LALST PC,]	; Jal and set
OPDEF	JALCM	[LALCM PC,]	; Jal and complement

OPDEF	JIFDED	[JIF (STOPF)]	; Jmp if stopped
OPDEF	IJNRCR	[JIFST (RCRN)]	; Increment rcr, jmp if negative
OPDEF	IJNWCR	[JIFST (WCRN)]	; Increment wcr, jmp if negative
OPDEF	IJPRCR	[IJNRCR @0]	; Increment rcr, jmp if positive
OPDEF	IJPWCR	[IJNWCR @0]	; Increment wcr, jmp if positive
OPDEF	CL	[LALCL @0]	; Clear condition
OPDEF	ST	[LALST @0]	; Set condition
OPDEF	CM	[LALCM @0]	; Complement condition
OPDEF	STOP	[ST (STOPF)]
>

; Group 3 - external register transmission

DEFINE	CDOPS<
; Clipper--dev 00xx--

OPDEF	LOCLA	[300000000000]	; Load clipper absolute
OPDEF	LOCLR	[301000000000]	; Load clipper relative
OPDEF	LOCLSA	[302000000000]	; Load clipper size absolute
OPDEF	LOCLSR	[303000000000]	; Load clipper size relative
OPDEF	STCL	[320000000000]	; Store clipper absolute
OPDEF	RTCLA	[340020000000]	; Retreive clipper absolute
OPDEF	RTCLR	[341020000000]	; Retreive clipper relative
OPDEF	RTCLSA	[342020000000]	; Retreive clipper size absolute
OPDEF	RTCLSR	[343020000000]	; Retreive clipper size relative
OPDEF	SKCL	[360020000000]	; Sink clipper absolute
>

DEFINE	MMOPS<
; Matrix multiplier -- device 01xx --

OPDEF	LOMM	[304000000000]
OPDEF	LOMMR	[305000000000]
OPDEF	LOMMP	[306000000000]
OPDEF	LOMDIR	[307000000000]
OPDEF	STMM	[324000000000]
OPDEF	NOMM	[325020000000]
OPDEF	POPMM	[326020000000]
OPDEF	STMDIR	[327000000000]
OPDEF	RTMM	[344020000000]
OPDEF	RTMMS	[345020000000]
OPDEF	RTMDIR	[347020000000]
OPDEF	SKMM	[364020000000]
OPDEF	SKMMS	[365020000000]
OPDEF	PUSHMM	[366020000000]
OPDEF	SKMDIR	[367020000000]
>

DEFINE	CBOPS<
; Character bubble -- device 1101 --

OPDEF	LOCB	[315000000000]
OPDEF	STCB	[335000000000]
OPDEF	RTCB	[355020000000]
OPDEF	SKCB	[375020000000]
>

DEFINE	SBOPS<
; Sbkl -- device 1111 --

OPDEF	LOSBKL	[317000000000]
OPDEF	STSBKL	[337000000000]
OPDEF	RTSBKL	[357020000000]
OPDEF	SKSBKL	[377020000000]
OPDEF	LOLITS	[LOSBKL LITS,0(1)]
OPDEF	STSWCH	[STSBKL SWCH,0(1)]
>

DEFINE	DIOPS<
; Group 4-7 - display instructions

DD_400000000000	; Do direct
DI_500000000000	; Do indirect
DN_600000000000	; Do internal

; The what-to-do machine :

LNS_060000000000	; Lines_(set-drawto)**
LT_070000000000		; ?????_(drawto-set)**
PO_030000000000		; Polyg_set-(drawto)**
TO_020000000000		; To_(drawto)**
SS_040000000000		; Star_set-(drawfrom)**
FR_050000000000		; From_(drawfrom)**
DT_010000000000		; Dots_(dot)**
BX_000000000000		; Boxes_(box)**

; The abs/rel-modes machine :

RX_007000000000		; (rel-abs)**
AX_006000000000		; (abs-rel)**
RA_003000000000		; Rel-(abs)**
AB_002000000000		; (abs)**
AR_004000000000		; Abs-(rel)**
RE_005000000000		; (rel)**
SL_001000000000		; (size rel)**
SA_000000000000		; (size abs)**

OPDEF	SETPTA	[DD+LNS+AB]	; Set-point-absolute
OPDEF	SETPTR	[DD+LNS+RE]	; Set-point-relative
OPDEF	DRAWTA	[DD+TO+AB]	; Draw-to-absolute
OPDEF	DRAWTR	[DD+TO+RE]	; Draw-to-relative
OPDEF	DRAWFA	[DD+FR+AB]	; Draw-from-absolute
OPDEF	DRAWFR	[DD+FR+RE]	; Draw-from-relative
OPDEF	LINAA	[DD+LNS+AB]	; Line-(absolute-absolute)
OPDEF	LINAR	[DD+LNS+AX]	; Line-(absolute-relative)
OPDEF	LINRA	[DD+LNS+RX]	; Line-(relative-absolute)
OPDEF	LINRR	[DD+LNS+RE]	; Line-(relative-relative)
OPDEF	LINIAA	[DI+LNS+AB]	; Line-indirect-(absolute-absolute)
OPDEF	LINIAR	[DI+LNS+AX]	; Line-indirect-(absolute-relative)
OPDEF	LINIRA	[DI+LNS+RX]	; Line-indirect-(relative-absolute)
OPDEF	LINIRR	[DI+LNS+RE]	; Line-indirect-(relative-relative)
OPDEF	POLAA	[DD+PO+AB]	; Polygon-absolute's
OPDEF	POLAR	[DD+PO+AR]	; Polygon-absolute-relative's
OPDEF	POLRR	[DD+PO+RE]	; Polygon-relative's
OPDEF	POLRA	[DD+PO+RA]	; Polygon-relative-absolute's (???)
OPDEF	POLIAA	[DI+PO+AB]	; Polygon-indirect-(absolute's)
OPDEF	POLIAR	[DI+PO+AR]	; Polygon-indirect-(absolute-relative's)
OPDEF	POLIRR	[DI+PO+RE]	; Polygon-indirect-(relative's)
OPDEF	POLIRA	[DI+PO+RA]	; Polygon-indirect-(relative-absolute's)
OPDEF	STARAA	[DD+SS+AB]	; Star-absolute's
OPDEF	STARAR	[DD+SS+AR]	; Star-absolute-relative's
OPDEF	STARRR	[DD+SS+RE]	; Star-relative's
OPDEF	STARRA	[DD+SS+RA]	; Star-relative-absolute's(???)
OPDEF	DOTSAA	[DD+DT+AB]	; Dots-absolute's
OPDEF	DOTSAR	[DD+DT+AR]	; Dots-absolute-relative's
OPDEF	DOTSRR	[DD+DT+RE]	; Dots-relative's
OPDEF	DOTSRA	[DD+DT+RA]	; Dots-relative-absolute's(???)
OPDEF	BOXA	[DD+BX+AB]	; Box-absolute
OPDEF	BOXR	[DD+BX+RE]	; Box-relative
OPDEF	BOXSA	[DD+BX+SA]	; Box-size-absolute
OPDEF	BOXSR	[DD+BX+SL]	; Box-size-relative

OPDEF	DOCHAR	[700000000000]

SUPPRESS LNS,LT,PO,TO,SS,FR,DT,BX
SUPPRESS RX,AX,RA,AB,AR,RE,SL,SA
>

DPRGS
DPMDS
DPCND
CDRGS
DPOPS0
DPOPS2
CDOPS
DIOPS

; Externally defined things

EXTERN	MRETNE
EXTERN	DSPBIT		; Interrupt channel bit
EXTERN	MAXLOK,LOKPGS
EXTERN	DSPCHN		; Interrupt channel
EXTERN	DSPCHR		; Return from int
EXTERN	CORWB		; Modified bittin cst
EXTERN	CST0		; Coreestatus table
EXTERN	FKHPTN		; Converts fork handle to ptn
EXTERN	FPTA		; Convert monitor address to ptn.pn
EXTERN	FORKX		; System fork index
EXTERN	MLKPG		; Lock page
EXTERN	MULKCR		; Unlock real core page
EXTERN	EDISMS		; Dismiss
EXTERN	PSIRQ		; Routine to call to cause interrupt

; Display processor variables and parameters

DP_130			; Display device code
PI__4			; Pi device
DSPSTL__20		; Stack length
IOS_6
NINT__3			; Number of words for dispatching to psi chan
STPINT__0
HITINT__1
ITRINT__2
ERRINT__3
MEMINT__4
CNTINT__5		; Interrupt and continue
NTCKPF__=20		; Number of ticks per frame
STOP__400000
RUN__200000
FSTOP__100000
QSTOP__040000

; Table of dp info locations

DPLOC:	FOR @' Q_0,NDP-1
<	DPLCK'Q
>

; Define the format of a dp info block
; * indicates those data which can be set with stsdp

DEFINE	DPBLK'(Q)<
XXX(DPLCK'Q,1)		; Process lock word
XXX(DPJOB'Q,1)		; Lh: jobno of assigner, rh: forkn of starter
XXX(CTL'Q,1)		; Lh control bits, rh last interrupt number
XXX(MAPW'Q,1)		; * lh: - # of pages in map, rh: first page
XXX(ITR'Q,1)		; * iteration counter
XXX(DCMSK'Q,1)		; * mask of consoles for this dp
XXX(DPCNI'Q,1)		; * coni of last stop
XXX(INT'Q,3)		; * psi dispatch
XXX(DPR'Q,0)		;   beginning of display processor registers
XXX(DPWCR'Q,1)		; * write count register
XXX(DPRCR'Q,1)		; * read count register
XXX(DPUR'Q,1)		; * unused register
XXX(DPRAR'Q,1)		; * read address register
XXX(DPWAR'Q,1)		; * write address register
XXX(DPDSP'Q,1)		; * real data sink pointer
XXX(DPP1'Q,1)		; * p1 (used for flagging stops)
XXX(DPDIR'Q,1)		; * directive register
XXX(DPPC'Q,1)		; * program counter
XXX(DPRSR'Q,1)		; * repeat status register
XXX(DPSR'Q,1)		; * status register
XXX(DPSP'Q,1)		; * stack pointer
XXX(CDREG'Q,14)		; * clipper divider
XXX(MAP'Q,20)		; Page map for dp
>

; Define xxx to define indices into the info block

DEFINE	XXX(NAME,COUNT)<
NAME__QQ
QQ__QQ+COUNT
>

QQ__0
DPBLK()

NDPR__MAP-DPR

; Redefine xxx to allocate resident storage for each dp

DEFINE	XXX(NAME,COUNT)<
LS(NAME,COUNT)
>

FOR Q_0,NDP-1
<DPBLK(Q)
>

; Storage for lds-1 itself

LS(DSPACT)		; Dp currently being run (0 if none)
LS(DSPINF)		; Initialization and stopping flag
			;  0 if neither, +1 for stopping, -1 for start
LS(DSPINS)		; Holds a display instruction to be xqta'ed
LS(DSPIN2)		; Holds another instruction to be xqta'ed
LS(DSPSVR)		; Saved return for interrupt
LS(DSPRSK)		; Switch for calling display scheduler
LS(DCLCK)		; Lock on assigning consoles
LS(NRUNG)		; Number of durrently running dp's
LS(DSPCNT)		; Count of ticks left in this quantum
LS(DSPNTL)		; Number of ticks left in this frame
LS(DSPNPL)		; Number of process left for this frame
LS(AVDC)		; Mask of available consoles
LS(DSPSTK,DSPSTL)	; Stack for dsp interrupt
LS(DCJOB,NDC)		; Assigner of a dc
PS(LDSFRK)		; Has fork handle of elt's stuff
JS(JOBDC)		; Mask of consoles assigned to this job

; Initialize display processor routines
; Called during system initialization from filini
; Call:	PUSHJ P,DSPINI

USE

^DSPINI:MOVSI A,-NDP
DPINIL:	MOVE IOS,DPLOC(A)	; Set ios to storage for this dp
	SETOM DPJOB(IOS)	; No job assigned
	SETZM CTL(IOS)		; Clear all flags
	SETOM DPLCK(IOS)	; Unlock the dp
	AOBJN A,DPINIL		; Loop through all dp's
	MOVE A,[-1(=36-NDC)]	; Get mask of non-existant consoles
	SETCAM A,AVDC		; Store as available
	MOVSI A,-NDC		; For all dc's
	SETOM DCJOB(A)		; Clear assigned job
	AOBJN A,.-1
	SETZM DSPRSK
	SETZM DSPCNT
	SETZM DSPNTL
	SETZM DSPNPL
	SETOM DCLCK
	SETZM NRUNG
	SETZM DSPACT		; It is not active
	SETZM DSPINF		; Clear initialization flag
	POPJ P,

DSPRST:	MOVEI A,1
	MOVEM DSPCNT
	POPJ P,

; KILL FORK -- RELDP

DSPKFK:	MOVSI B,-NDP
DSPKF0:	MOVE A,DPLOC(B)
	HRRZ C,DPJOB(A)
	CAME C,FORKX
	 JRST DSPKF1
	HRRZ A,B
	RELDP
DSPKF1:	AOBJN B,DSPKF0
	POPJ P,

USE SWAPPC

; Assign display process jsys
; Call:	ASNDP
; Return
;	+1	; None a,available
;	+2	; Success, in 1, the process number assigned

^.ASNDP:JSYS MENTR		; Set up for slow code
	MOVSI B,-NDP		; Index through all dp's
ASNDLP:	MOVE IOS,DPLOC(B)	; Loop back for each dp til find one
	NOINT			; No interrupts until we set the lock
	AOSE DPLCK(IOS)
	 JRST [	OKINT		; Busy, must wait. ints on first
		HRLZI A,DPLCK(IOS)
		HRRI A,DISLT
		JSYS EDISMS
		JRST .-2]
	SKIPL DPJOB(IOS)	; Is this one assigned?
	 JRST ASNDP1		; Yes.
	HRLZ A,JOBNO		; No, get jobno
	HRR A,FORKN		; And forkn
	MOVEM A,DPJOB(IOS)	; Assign the dp
	UNLOCK DPLCK(IOS)	; Unlock
	XCTUU [HRRZM B,1]	; Return the dp number to the user
	JRST SKMRTN		; And skip

ASNDP1:	UNLOCK DPLCK(IOS)	; Unlock this dp
	OKINT
	AOBJN B,ASNDLP		; And try the next one
	JRST MRETN		; None left, fail return

; Release display process jsys
; Call:	1	; Display process number to be released (-1 for all)
;	RELDP
; Return
;	+1	; Always

^.RELDP:JSYS MENTR		; Become slow
	CAMN 1,[-1]		; Releasing all?
	 JRST RELADP		; Yes
	PUSHJ P,CHKDP		; Check validity
	 JRST MRETN		; Invalid, return
	PUSHJ P,STPDPX		; Stop dp if running
	SETOM DPJOB(IOS)	; Deassign the dp
	UNLOCK(DPLCK(IOS))
	JRST MRETN

RELADP:	MOVSI 1,-NDP		; Loop through all dp's
	RELDP			; And do reldp for each one
	AOBJN 1,.-1
	JRST MRETN

; Assign display consoles jsys
; Call:	1	; Mask of consoles jsys to assign
;	ASNDC
; Return
;	+1	; Not all available
;	+2	; Success

^.ASNDC:JSYS MENTR		; Become slow
	NOINT			; No ints while trying to lock
	AOSE DCLCK
	 JRST [	OKINT		; Turn ints back on while waiting
		MOVE 1,[XWD DCLCK,DISLT]
		JSYS EDISMS	; Dismiss until lock is -
		JRST .-2]
	UMOVE A,1
	ANDCM A,JOBDC		; Mask out consoles already assigned
	TDNE A,AVDC		; Are all consoles available?
	 JRST DCNAV		; No.
;	IORM A,AVDC		; Mark as assigned (temp don't to share one console)
	IORM A,JOBDC		; And to this job
	MOVE C,JOBNO
	AOS (P)			; Skip return
MRKDC:	JFFO A,MRKDC1		; Enter here from reldc also
	UNLOCK DCLCK		; All marked
	JRST MRETN

MRKDC1:	MOVEM C,DCJOB(B)	; Save jobno of assigner or -1
	ROT A,(B)
	TLZ A,(1B0)		; Clear this bit
	MOVNS B
	ROT A,(B)
	JRST MRKDC		; Mark the rest

DCNAV:	UNLOCK DCLCK
	JRST MRETN

; Release display consoles
; Call:	1	; Mask of consoles to release, -1 for all
;	RELDC
; Return
;	+1	; Always

^.RELDC:JSYS MENTR		; Begin slow code
	NOINT			; No ints while lock is set
	AOSE DCLCK
	 JRST [	OKINT
		MOVE 1,[XWD DCLCK,DISLT]
		JSYS EDISMS	; Wait
		JRST .-2]
	UMOVE A,1		; Get mask
	AND A,JOBDC		; Consider only assigned consoles
	ANDCAM A,JOBDC		; Deassign from job
	ANDCAM A,AVDC		; Return to available pool
	SETO C,
	JRST MRKDC		; And clear all jobno's

; Start display process jsys
; Call:	LH(1)	; If non-zero, set status (same as stsdp)
;	RH(1)	; Process number
;	2	; Location of table to set status from if lh(1) neq 0
;	STRDP
; Return
;	+1	; Error
;	+2	; Ok

^.STRDP:JSYS MENTR		; Become slow
	PUSHJ P,CHKDP		; Check validity of dp number
	 JRST MRETNE		; Invalid
STRDP0:	PUSHJ P,STPDPX		; Stop dp first if running
	UMOVE A,1		; Get args
	UMOVE B,2
	TLNE A,-1		; Set status?
	 PUSHJ P,STSDPX		; Yes. set status first
	MOVSI B,STOP
	ANDCAM B,CTL(IOS)	; Clear stopping bit
	MOVE C,MAPW(IOS)	; Get the map word
	HLRE B,C		; Get count
	MOVNS B			; Make positive
	ADDI B,(C)		; Yields end of mapped area
	TLC C,777700
	CAIG B,1000		; If end beyond mem end or
	TLCE C,777700		; Count bad
	 JRST [	SETOM DPLCK(IOS)
		MOVEI A,STRDX1
		JRST MRETNE]	; Invalid mapw
	MOVE B,[POINT 9,MAP(IOS)]
STRDPL:	HRRZ A,C		; Get page number
	PUSH P,C		; Save vulnerable ac's
	PUSH P,B
	JSP B,.+1
	TLNE B,2000		; Test for call from monitor
	 JRST [	LSH A,9
		PUSHJ P,FPTA	; Convert monitor address to ptn.pn
		JRST STRDP1]
	HRLI A,400000
	PUSHJ P,FKHPTN		; Convert user address to ptn.pn
	 JRST [	SETZ A,
		JRST STRDP2]
STRDP1:	PUSH P,A
	PUSHJ P,MRPACS		; See if the page exists
	MOVE B,A
	POP P,A
	TLNN B,(1B5)
	 JRST [	SETZ A,
		JRST STRDP2]	; Non-existent page
	TLNE B,400
	 JRST [	TLNN B,100000
		 JRST .+1
		PUSH P,A
		HRRZS A
		LSH A,9
		UMOVES 777(A)
		POP P,A
		JRST STRDP1]
	TLC B,160000
	TLNE B,160000
	 JRST [PUSHJ P,RELMAP	; Can't have non-readable-writable-
		MOVEI A,STRDX3	; Executable pages
		UNLOCK DPLCK(IOS)
		JRST MRETN]
	PUSH P,IOS
	PUSHJ P,MLKPG		; Lock the page
	MOVSI B,CORWB
	IORM B,CST0(A)		; Mark page as modified
	POP P,IOS

STRDP2:	POP P,B			; Get byte pointer back
	IDPB A,B		; Deposit rca or 0 in map
	POP P,C			; Restore aobjn word
	AOBJN C,STRDPL		; Loop through all pages of map
	SETZ A,
	CAME B,[POINT 9,MAP+17(IOS),35]
	 JRST [	IDPB A,B	; Deposit 0's in unused slots
		JRST .-1]
	MOVE A,LOKPGS
	CAML A,MAXLOK
	 JRST [	PUSHJ P,RELMAP	; Too many pages locked. unlock
		UNLOCK DPLCK(IOS)
		MOVEI A,STRDX2
		JRST MRETNE]	; And fail
	MOVSI A,14-NDPR		; Set to index through dp regs
	MOVEI B,DPR(IOS)
	HRLI B,A
SANIT:	MOVE C,SAVTAB(A)	; Get proper left half
	HRLO D,C
	ANDM D,@B
	HLLZS C
	IORM C,@B
	AOBJN A,SANIT		; Loop through all settable dp regs
	MOVE A,DPSP(IOS)
	TLNN A,17
	TLO A,PROGM
	MOVEM A,DPSP(IOS)	; Force program mode if user fails to
	MOVE A,FORKX
	HRRM A,DPJOB(IOS)	; Save forkx of starter
	MOVSI B,RUN
	IORM B,CTL(IOS)		; Set the run bit
	CONO 4,400		; Disallow scheduling and dsp ints
	AOS A,NRUNG		; Increment count of running dp's
	CAIG A,1		; If this is the first one
	MOVEM A,DSPCNT		; Init count so it will go thru 0
	CONO PI,200		; Turn pi back on
	UNLOCK DPLCK(IOS)
	JRST SKMRTN

SAVTAB:	LI WCR,0
	LI RCR,0
	LI UR,0
	LI RAR,0
	LI WAR,0
	LI DSP,0
	LI P1,
	LI DIR,(PROGM)
	LI PC,
	LI RSR,0
	LI SR,
	LI SP,17


; Stop display process jsys
; Call:	1	; Process number
;	STPDP
; Return
;	+1	; Always

^.STPDP:JSYS MENTR
	PUSHJ P,CHKDP
	 JRST MRETN
	PUSHJ P,STPDPX
	UNLOCK DPLCK(IOS)
	JRST MRETN

; Set display process status jsys
; Call:	RH(1)	; Process number
;	B0(1)	; If one, set the memory map
;	B1(1)	; If one, change frame iteration count
;	B2(1)	; If one, set console mask
;	B3(1)	; If one, set coni word
;	B4(1)	; If one, set dp psints
;	B5(1)	; If one, set initial dp reg's
;	2	; Location of table from which to set status
;	STSDP
; Returns
;	+1	; Error
;	+2	; Ok

^.STSDP:JSYS MENTR
	PUSHJ P,CHKDP
	 JRST MRETNE
	MOVE A,CTL(IOS)
	TLNE A,RUN
	JRST STRDP0		; If running, stsdp=strdp
	PUSHJ P,STPDPX
	UMOVE A,1
	UMOVE B,2
	PUSHJ P,STSDPX
	UNLOCK DPLCK(IOS)
	JRST SKMRTN

; Read display status jsys
; Call:	1	; Display process number
;	2	; Location where to store status
;	RDSDP
; Return
;	+1	; Error
;	+2	; Ok

^.RDSDP:JSYS MENTR
	PUSHJ P,CHKDP
	 JRST MRETNE
	UMOVE A,2		; Get location where to store
	MOVE B,MAPW(IOS)
	UMOVEM B,0(A)		; Store mapw
	MOVE B,ITR(IOS)
	UMOVEM B,1(A)		; And itr
	MOVE B,DCMSK(IOS)
	ROT B,9
	AND B,[776000000000]
	HRR B,CTL(IOS)
	UMOVEM B,2(A)
	MOVE B,DPCNI(IOS)
	UMOVEM B,3(A)
	MOVEI B,4(A)
	HRLI B,INT(IOS)
	XCTMU [BLT B,4+NINT-1(A)]
	MOVEI B,4+NINT(A)
	HRLI B,DPR(IOS)
	XCTMU [BLT B,4+NINT+NDPR-1(A)]
	UNLOCK DPLCK(IOS)
	JRST SKMRTN

; Wait for dp to stop
; Call:	1	; Dp number
;	WATDP
; Returns +1 when the dp is stopped, returns immediately if bad number

^.WATDP:JSYS MENTR
	HRRZS A
	CAIL A,NDP
	JRST MRETN
	MOVSI B,RUN
	MOVE A,DPLOC(A)
	TDNN B,CTL(A)
	JRST MRETN
	MOVSI A,CTL(A)
	HRRI A,STPTST
	JSYS EDISMS
	JRST MRETN

; The following n jsys's do nothing except dispatch to a user fork
; Presumed to contain elt's routines via its entry
; Vector.  if the fork does not yet exist, it is created.

FOR @' Q_0,7
<.LDS'Q:JSYS MENTR
	MOVEI A,Q
	JRST LDSDO
>

LDSDO:	PUSH P,A
	SKIPN LDSFRK
	PUSHJ P,GETLDS		; Do the get first
	POP P,B
	PUSHJ P,LDSXCT
	SFRKV			; Executed by ldsxct
	MOVEI B,(P)
	ADD P,[XWD 2,2]
	PUSHJ P,LDSXCT
	RFACS
	MOVE B,1(B)
	SUB P,[XWD 2,2]
	SKIPN B
	AOS (P)
	JRST MRETN

LDSXCT:	PUSH P,[0]
	SKPIR
	SETOM (P)
	DIR
	WFORK
	XCT @-1(P)
	SKIPN (P)
	EIR
	SUB P,[XWD 1,1]
	AOS (P)
	POPJ P,

GETLDS:	MOVEI A,0
	CFORK
	 JRST [	MOVEI A,0
		MOVEM A,LSTERR
		JRST ITRAP]
	MOVEM A,LDSFRK
	MOVSI A,100001
	HRROI B,[ASCIZ /<SUBSYS>ELTDSP.SAV/]
	GTJFN
	 JRST [	MOVE A,LDSFRK
		KFORK
		SETZM LDSFRK
		MOVEI A,0
		MOVEM A,LSTERR
		JRST ITRAP]
	HRL A,LDSFRK
	GET
	POPJ P,

; Check and lock display process
; Call:	RH(A)	; Process number
;	PUSHJ P,CHKDP
; Return
;	+1	; Invalid, not assigned etc.
;	+2	; Ok, the process is locked

CHKDP:	HRRZ IOS,A		; Get rh(a)
	CAIL IOS,0		; Check range if dp number
	CAIL IOS,NDP
	 JRST [	MOVEI A,DPX2
		POPJ P,]	; Illegal dp number
	MOVE IOS,DPLOC(IOS)	; Get location of storage block
	PUSH P,A
	NOINT			; No interrupts while setting lock
	AOSE DPLCK(IOS)
	 JRST [	OKINT
		HRLZI 1,DPLCK(IOS)
		HRRI 1,DISLT
		JSYS EDISMS
		JRST .-2]
	HLRZ A,DPJOB(IOS)	; Get job no of assigner
	CAME A,JOBNO		; Are we they?
	 JRST CHKDP1		; No, error
	POP P,A
	JRST SKPRET		; Yes, return ok

CHKDP1:	POP P,A
	MOVEI A,DPX1
	UNLOCK DPLCK(IOS)
	POPJ P,

; Stop display process subroutine
; Call:	IOS	; Process info location
;	PUSHJ P,STPDPX
; Return
;	+1	; Always

STPDPX:	PUSH P,A
	MOVE A,CTL(IOS)		; Get control word
	TLNN A,RUN		; Running?
	 JRST STPDPZ		; No, just return
	MOVSI A,STOP		; Yes.
	IORM A,CTL(IOS)		; Request a stop
	HRLZI A,CTL(IOS)
	HRRI A,STPTST
	JSYS EDISMS		; Wait for it
STPDPZ:	POP P,A
	POPJ P,

USE

STPTST:	MOVSI 2,RUN
	TDNE 2,(1)
	JRST (4)
	JRST 1(4)

USE SWAPPC

; Set display status subroutine
; Call:	2	; Same as stsdp
;	PUSHJ P,STSDPX
; Returns
;	+1	; Always

STSDPX:	HLL B,A
	UMOVE A,0(B)		; Get mapw
	TLNE B,(1B0)		; Are we to set it?
	MOVEM A,MAPW(IOS)	; Yes
	UMOVE A,1(B)		; Same for itr
	TLNE B,(1B1)
	MOVEM A,ITR(IOS)
	UMOVE A,2(B)		; Get console mask
	AND A,JOBDC		; Allow only assigned consoles
	ROT A,-9		; Make into permit bits
	TLO A,1000		; And set select to 0
	TLNE B,(1B2)
	MOVEM A,DCMSK(IOS)
	UMOVE A,3(B)		; Get coni word
	TLNE B,(1B3)
	MOVEM A,DPCNI(IOS)	; And if he wants to, let him set it
	HRLZI A,4(B)		; Start of int words in user space
	HRRI A,INT(IOS)
	TLNE B,(1B4)
	XCTUM [BLT A,INT+NINT-1(IOS)]
	HRLZI A,4+NINT(B)	; Start of dp regs in user space
	HRRI A,DPR(IOS)
	TLNE B,(1B5)
	XCTUM [BLT A,DPR+NDPR-1(IOS)]
	POPJ P,

; Display processor schedular
; Call:	PUSHJ P,DSPSKV
; Sets dsp cnt to count ticks for next dp to run
; If all dp's have run once, then the first dp found to have
; Not frame stopped is given the remainder of the frame time

USE

DSPSKV:	SETZ A,
	EXCH A,DSPCNT		; Get remainder, prevent more dp sched
	ADDM A,DSPNTL		; Credit remainder to ticks left
	SKIPLE DSPNTL		; Any ticks left in this frame?
	JRST DSPSK2		; Yes
DSPSK0:	MOVEI A,NTCKPF		; No, get ticks per frame
	ADDB A,DSPNTL		; Augment ticks left
	JUMPLE A,.-2
	MOVE A,NRUNG
	ADDM A,DSPNPL		; Augment number of dp's left to do
	SETZM DSPACT		; So we will start at beginning
DSPSK2:	SKIPN DSPNPL		; Any dp's left to schedule?
	JRST DSPSK4		; No, go run any body
	MOVE A,DSPNTL		; Get ticks left
	IDIV A,DSPNPL		; Get this guy's share
	SKIPE B
	AOS A			; Round up to give first dp's the split
	MOVN B,A
	ADDM B,DSPNTL		; Debit ticks left
	ADDB A,DSPCNT		; Set quantum
	JUMPLE A,DSPSKV		; We're getting behind
	SOS DSPNPL		; One less guy left
	SETZ D,			; Find anybody
	JRST DSPSCH

DSPSK4:	MOVE A,DSPNTL
	ADDB A,DSPCNT
	JUMPE A,DSPSK0		; Will jump if frame has ended
	SETZM DSPNTL
	SETZM DSPACT
	MOVSI D,FSTOP		; Find nobody who is frame stopped

DSPSCH:	SKIPN A,DSPACT
	HRLOI A,-NDP-2
	SETZM DSPACT
	AOBJP A,CPOPJ
	MOVSI C,RUN
DSPNX1:	MOVE IOS,DPLOC(A)	; Get location of dp data
	TDNE C,CTL(IOS)
	TDNE D,CTL(IOS)
	 JRST [	AOBJN A,DSPNX1	; Not running, or frame stopped
		POPJ P,]
	MOVSI D,FSTOP
	ANDCAM D,CTL(IOS)
	MOVEM A,DSPACT		; This is the active dp
DSPRGO:	SETOM DSPINF		; Set initialization flag
	CONO DP,615310
	CONO DP,20
	CONSO DP,4000		; Wait for io stop
	JRST .-1
	DATAO DP,[LI SR,0(PROGM)]	; Start with sr of 0
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LI DIR,52505]
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LI RSR,0]
	MOVE A,[LOCLA SELINT,(1)]
	HRRI A,DCMSK(IOS)
	CONSO DP,4000
	JRST .-1
	DATAO DP,A		; Set select register
	MOVE A,[LI SP,(PEELM)]
	ADDI A,DPR(IOS)
	MOVEM A,DSPINS		; This is executed to start restore
	MOVE A,[LOCLA (14)]
	ADDI A,CDREG(IOS)
	MOVEM A,DSPIN2		; Executed to start loading clipper
	CONSO DP,4000
	JRST .-1
	DATAO DP,[JMP RESTR1]	; Point pc to restore code
	CONO DP,2610+DSPCHN	; Clear io stop and prg stop
	POPJ P,			; And leave

; The following code actually appears in the msec closk routine
; In pisrv, it is reproduced here for reference
;; Display clock
;; Enter here periodically at apr interrupt level
;
;DSPCLK:	SKIPE NRUNG
;	SOSLE DSPCNT
;	JRST @DSPCLK+2
;	SKIPN DSPCNT
;	SETOM DSPRSK
;	CONO PI,4000+DSPBIT
;	JRST @DSPCLK+2

; Display processor code for restoring state

RESTR1:	XQTA DSPIN2		; Contains locla 0,location(14)
OPDEF	LOTP	[310B8]
	LOTP @			; Map is right after cd regs
	XQTA DSPINS		; Li sp,stack(peelm)
	STOP			; Rest is spoon fed

; Save dp registers

SAVDP:	PSH P1,
	PSH DSP,
	PSH WAR,
	PSH RAR,
	PSH UR,
	PSH RCR,
	PSH WCR,
	XQTA DSPINS
	STOP

; Display processor interrupt routine

DSPSV:	XWD DSPSVR,.+1
	SKIPN DSPRSK		; Was int due to clock or
	CONSZ DP,1B32		; Was interrupt due to lds-1
	JRST DSPSV1		; Yes
	JRST @DSPSVR		; No.

DSPSV1:	MOVEM P,DSPSTK		; Put p on stack
	MOVE P,[XWD -DSPSTL+1,DSPSTK]
	PUSH P,IOS
	SKIPE DSPRSK
	JRST DSPSV2
DSPSV3:	MOVEI A,DSPCHR
	MOVEM A,DSPSVR		; Change return address
	MOVE IOS,DSPACT		; Point to current dp
	MOVE IOS,DPLOC(IOS)
	CONI DP,B		; Get dp status
	SKIPN DSPINF		; Starting or stopping
	JRST DSPNRM		; No, normal interrupt
	TRNE B,40
	JRST SELERR		; Select error
	TRNE B,640000		; Any of these while starting or stpng
	JRST BADER1		; Indicates monitor malfunction
	SKIPL DSPINF		; Starting?
	JRST STPING		; No, stopping
	CONO DP,4200		; Yes, set iostop
	CONSO DP,4000		; Wait for io stop
	JRST .-1
	DATAO DP,DPPC(IOS)	; Spoon feed the pc
	CONSO DP,4000
	JRST .-1
	DATAO DP,DPRSR(IOS)	; And the rsr
	CONSO DP,4000
	JRST .-1
	DATAO DP,DPSR(IOS)	; And the sr
	CONSO DP,4000
	JRST .-1
	DATAO DP,DPSP(IOS)	; And the sp
	CONSO DP,4000
	JRST .-1
	SETZM DSPINF		; No longer initializing
	MOVE A,CTL(IOS)
	TLNE A,1		; Single step mode?
	 JRST [	CONO DP,40200
		CONO DP,40
		CONI DP,B
		JRST DSPNRM]
	CONO DP,60610+DSPCHN	; Let it go, mapped
DSPXIT:	POP P,IOS
	POP P,P
	JRST @DSPSVR

DSPSV2:	SETZM DSPRSK
	SKIPN DSPACT		; Any dp running now?
	 JRST [	PUSHJ P,DSPSKV	; No, call scheduler directly
		JRST DSPXIT]
	SKIPLE A,DSPINF		; Dp stopping?
	JRST DSPXIT		; Yes, wait for it
	CONO DP,6010+DSPCHN	; Set io-stop
	JRST DSPXIT		; And wait for it

DSPNRM:	MOVEM B,DPCNI(IOS)	; Save for later
	TRNE B,600000		; Parity and nxm are impossible
	JRST BADERR		; Bad news if it happens
	TRNE B,40000		; If page fault
	CONO DP,400000		; Do system clear
	CONO DP,4000		; In any case set io stop
	MOVSI A,(<NWSTKM>)
	TRNE B,40000		; If page fault
	MOVSI A,(<LI SP,>)	; Prepare to save mar instead of sp
	ADDI A,DPSP+1(IOS)
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LAL @]		; Group 2 nop to empty pipeline
	CONSO DP,4000
	JRST .-1
	CONO DP,20		; Now turn off map
	DATAO DP,A		; Do a nwstkm
	CONSO DP,4000
	JRST .-1
	TRZE B,40000
	 JRST [	DATAO DP,[PSHM 15,]
		JRST .-3]
	DATAO DP,[LIPSH SR,0(PROGM)]	; Save sr and reset it
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LIPSH RSR,0]	; Save rsr and set to 0
	MOVE A,[STCL (14)]
	ADDI A,CDREG(IOS)
	MOVEM A,DSPINS		; Executed to save cd regs
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LIPSH PC,SAVDP]
	CONSO DP,4000
	JRST .-1
	DATAO DP,[LIPSHM DIR,52505]
	MOVEI A,1
	MOVEM A,DSPINF		; Set flag for stopping
	CONO DP,2610+DSPCHN	; And start lds to save itself
	JRST DSPXIT		; Exit and come back when done saving

STPING:	CONO DP,511110
	CONO DP,20
	MOVE B,DPCNI(IOS)	; Get coni word as of first interrupt
	TRNE B,040040		; Protection violation and select
	JRST USRERR		; Are programming errors of user
	TRNE B,100
	JRST DHIT		; Hit stop
	TRNE B,1000
	JRST DMMINT		; Memory to memory stop
	TRNE B,200
	JRST DSPHLT		; Halted itself
	TRNE B,400		; Iostop is quantum ovrflo
	JRST DSPSKQ		; Run dsp schedular
	JRST BADER2		; Cannot find cause of interrupt

SELERR:	SKIPGE DSPINF		; Selection error before started
	MOVEM B,DPCNI(IOS)
USRERR:	PUSHJ P,DSPSTP		; Some kind of error
	MOVEI A,ERRINT
	PUSHJ P,DDPINT		; Generate interrupt
	JRST DSPXIT

BADERR:				; Parity and nxm while running
BADER1:				; Parity nxm or map while start/stopping
BADER2:				; Unknown lds-1 interrupt
	CONO DP,511110
	CONO DP,20
	BUG(CHK,<DISPLAY: PARITY ERROR OR NXM FROM LDS-1.>)
	JRST USRERR

DHIT:	PUSHJ P,DSPSTP		; Hit stop
	MOVEI A,1B28
	ANDCAM A,DPSR(IOS)
	MOVEI A,HITINT
	PUSHJ P,DDPINT
	JRST DSPXIT

DMMINT:	PUSHJ P,DSPSTP		; Memory-memory stop
	MOVEI A,MEMINT
	PUSHJ P,DDPINT
	JRST DSPXIT

DSPSKQ:	MOVSI A,QSTOP
	IORM A,CTL(IOS)		; Remember we stopped for quantum
DSPSKD:	MOVSI A,STOP		; Io-stop (means run next dp)
	TDNE A,CTL(IOS)
	JRST DSTOP
	PUSHJ P,DSPSKV
	JRST DSPXIT

DSPHLT:	MOVEI B,4
	ANDCAM B,DPSR(IOS)	; Clear stop bit
	HRRZ A,DPP1(IOS)	; Get p1 register
	CAIL A,NSYSH
	JRST DSPUSH
	JRST @HLTDTB(A)

DSPUSH:	MOVEI B,4		; Program stops not handled by monitor
	ANDCAM B,DPSR(IOS)	; Clear stop flag
	PUSHJ P,DSPSTP
	MOVEI A,STPINT
	PUSHJ P,DDPINT
	JRST DSPXIT

HLTDTB:	FRAME
	INTCON
NSYSH__.-HLTDTB

FRAME:	MOVSI B,FSTOP
	MOVSI A,QSTOP
	TDNE A,CTL(IOS)
	MOVSI B,0		; Don't frame stop if previous q stop
	ANDCAM A,CTL(IOS)
		IORM B,CTL(IOS)
	SKIPE ITR(IOS)		; End of frame stop
	SOSLE ITR(IOS)
	JRST DSPSKD
	PUSHJ P,DSPSTP
	MOVEI A,ITRINT
	PUSHJ P,DDPINT
	JRST DSPXIT

INTCON:	MOVEI A,CNTINT
	PUSHJ P,DDPINT
	PUSHJ P,DSPRGO
	JRST DSPXIT

DSTOP:	HLLOS CTL(IOS)		; All ones for this kind of stop		; User program issued stpdp jsys
	PUSHJ P,DSPSTP
	JRST DSPXIT

DSPSTP:	MOVSI A,RUN!STOP	; Common routine to stop a dp
	ANDCAM A,CTL(IOS)
	PUSHJ P,RELMAP
	SOS NRUNG
	PUSH P,IOS
	PUSHJ P,DSPSKV
	POP P,IOS
	POPJ P,

; Do dp interrupt

DDPINT:	HRRM A,CTL(IOS)		; Save interrupt code
	IDIVI A,6
	IMULI B,6
	MOVNS B
	ADDI B,=30
	ROT B,-6
	ADD B,[POINT 6,INT(IOS),35]
	ADD A,B
	LDB A,A			; Psi channel in b
	HRRZ B,DPJOB(IOS)	; Forkn in a
	CAIL A,0
	CAIL A,=36
	POPJ P,			; Not legal psi channel
	PUSHJ P,PSIRQ		; Cause interrupt
	POPJ P,

; Release locked pages for a dp

RELMAP:	PUSH P,[POINT 9,MAP(IOS)]
	PUSH P,[100]
RELMAL:	ILDB A,-1(P)
	JUMPE A,RELMA1
	SETZ 2,
	DPB 2,-1(P)
	PUSHJ P,MULKCR
RELMA1:	SOSLE (P)
	JRST RELMAL
	SUB P,[XWD 2,2]
	POPJ P,

USE SWAPPC
	BENDP	DISPLAY>

; DIRECT NETWORK FILE ACCESS CODE

BEGS__0
BEGS2__-1
FRE__-2
DJFN__-3
SKT__-4
DIRC__-5
NVAR__5

OPNHST:	TLNE STS,54000
	 JRST ILLACC		; ILLEGAL ACCESS FOR XCT ETC.
	TEST(NN,READF)
	 JRST OPNHS1		; NOT READ
	TEST(NE,WRTF,RNDF)
	 JRST ILLACC		; ONLY ONE KIND OF ACCESS ALLOWED
	PUSH P,["R"]
	JRST OPNHS3

OPNHS1:	TEST(NN,WRTF)
	 JRST OPNHS2		; NOT WRITE
	TEST(NE,RNDF)
	 JRST ILLACC		; ONLY ONE ACCESS AT A TIME
	PUSH P,["W"]
	JRST OPNHS3

OPNHS2:	TEST(NN,RNDF)
	 JRST ILLACC		; NO ACCESS WANTED
	PUSH P,["A"]
OPNHS3:	ADD P,[XWD NVAR,NVAR]
	JUMPGE P,MSTKOV
	MOVEI A,JOBFRE
	MOVEI B,3
	PUSHJ P,ASGFRE		; GET SOME FREE STORAGE TO MAKE STRING
	 JRST NOFRE		; NO FREE STORAGE
	MOVEM A,FRE(P)
	HRLI A,(<POINT 7,0,35>)
	MOVEM A,BEGS(P)		; BYTE POINTER TO BEGINNING OF STRING
	HRROI B,[ASCIZ /NET:/]
	SETZ C,
	SOUT
	MOVEI B,100(JFN)	; USE SOCKET 100 PLUS JFN
	MOVEI C,10
	NOUT			; PUT OCTAL SOCKET NUMBER IN STRING
	 JSR BUGHLT		; CAN'T HAPPEN
	MOVEI B,"."
	IDPB B,A
	HLRZ B,FILDDN(JFN)	; POINTER TO DEVICE NAME -- HOST
	HRLI B,(<POINT 7,0,35>)
	SETZ C,
	SOUT
	MOVEM A,BEGS2(P)	; BEGINNING OF FS
	HRROI B,[ASCIZ /-6;T/]
	SOUT
	MOVE B,BEGS(P)
	MOVSI A,(1B17!1B7)	; RESTRICT JFN TO THIS FORK SHORT FORM
	GTJFN
	 JRST NOJFN		; NO JFN FOR DIALOGUE
	MOVEM A,DJFN(P)		; SAVE
	MOVE B,[XWD 40000,200000]
	OPENF			; OPEN TO READ 32-BIT BYTES
	 JRST NOOPN		; CAN'T OPEN
	BIN			; GET THE SOCKET NUMBER
	JUMPE B,NOSKT		; REJECTED
	MOVEM B,SKT(P)
	CLOSF
	 JSR BUGHLT		; CAN'T HAPPEN
	MOVE A,BEGS2(P)		; GET POINTER TO SOCKET PART
	MOVNS B
	MOVEI C,10
	NOUT			; INSERT SECOND SOCKET
	 JSR BUGHLT		; CAN'T HAPPEN
	HRROI B,[ASCIZ /;T/]
	SETZ C,
	SOUT
	MOVE B,BEGS(P)
	MOVSI A,(1B8!1B17)
	GTJFN
	 JRST NOJF2		; CAN'T GET SECOND JFN
	MOVEM A,DJFN(P)		; SAVE IT
	MOVE B,[XWD 70000,100000]
	OPENF			; OPEN TO WRITE 7-BIT BYTES
	 JRST NOOP2		; CAN'T OPEN
	MOVE B,FILNEN(JFN)	; EXTENSION HAS FOREIGN USER-PSWD
	HRLI B,(<POINT 7,0,35>)
	SETZ C,
	SOUT
	MOVEI B,"-"
	BOUT
	MOVE B,DIRC(P)
	BOUT			; OUTPUT DIRECTION
	HRROI B,[ASCIZ /-0-/]
	SOUT
	LDB B,PBYTSZ
	MOVEI C,12
	NOUT
	 JSR BUGHLT
	MOVEI B,"-"
	BOUT
	HLRZ B,FILNEN(JFN)
	HRLI B,(<POINT 7,0,35>)
	SETZ C,
	SOUT
	HRLI A,400000
	CLOSF			; CLOSE BUT RETAIN JFN
	HRRZS A
	MOVE B,[XWD 70000,200000]
	OPENF			; OPEN TO READ REPLY
	 JRST NOOP3		; CAN'T
	BIN
	JUMPN B,NOOK		; REJECTED
	HRLI A,400000
	CLOSF
	 JSR BUGHLT
	HRRZS A
	UMOVE B,2
	TLZ B,7400
	OPENF			; OPEN THE REAL NETWORK FILE
	 JRST NOOP4		; CAN'T
	MOVE STS,FILSTS(A)
	MOVEM STS,FILSTS(JFN)
	FOR @' X IN (BYT,BYN,OFN,CNT),<
	MOVE B,FIL'X(A)
	MOVEM B,FIL'X(JFN)
	HLL DEV,FILDEV(A)
	HLLM DEV,FILDEV(JFN)
>
	MOVE B,FRE(P)
	MOVEI A,JOBFRE
	PUSHJ P,RELFRE
	SUB P,[XWD NVAR,NVAR]
	JRST SKPRET
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                IFDEF	NETN,<
	BEGINP	NETWRK		R.S.TOMLINSON	3 DECEMBER 1971	1700:

USE

; Entries to this part

; Externally defined things

EXTERN	MULKMP
EXTERN	PSIRQ	; Generate psi request
EXTERN	MRETNE	; Error return to user
EXTERN	IMPLCK	; Aos this to prevent control msg processing
EXTERN	FKINT	; Bit 1 tested to see if deferred int
EXTERN	EDISMS	; Dismiss til test
EXTERN	MLKPG	; Lock page
EXTERN	MULKPG	; Unlock page
EXTERN	FPTA	; Find page table from address
EXTERN	PSIBW	; Breaks waiting mask
EXTERN	INSKED	; Flag says in scheduler
EXTERN	NSKED
EXTERN	RSKED
EXTERN	NETTIM
EXTERN	IMPBUG	; Bugchk for imp-netwrk stuff

; Linkage to imp driver section

EXTERN	IMPALL,IMPSRO,NETON,IMPCLL,IMPOPL,IMPCLS,IMPINR,IMPINS
EXTERN	IMPRTS,IMPSTR,IMPRRP,IMSRST,ASNPTY,PTYDET,IMPHRT,IMPRDY

INTERN	NSKT,NHOSTS,HOSTN,HOSTAB,NETHDN,NETDWN,NETCHK,RECRST
INTERN	RECINS,RECINR,NETKFK
INTERN	RECSTR,RECRTS,RCRFNM,RECCLS,PLINK,PFHST,PFSM,LHOSTN
INTERN	PBPBYT,PBFSIZ,PBPBUF,PBPBPO
INTERN	EOTF,RFNMB,ERRB,.ATPTY,.CVSKT,PTYCLZ

; Macros to turn imp on and off

DEFINE	IMPON<SOS IMPLCK>

DEFINE	IMPOFF<AOS IMPLCK>

; Local accumulators

UNIT_5		; Pseudo-unit number
IOS_6		; Status flags (loaded from netsts(unit))

; Parameters

BUFSIZ__200	; Buffer size (best if this be power of two)
NBUF_NNETBF	; Number of buffers
NAVB__(NBUF+=35)/=36	; Number of words for netavb
FLINK__2	; First link number to use

; Control messages opcodes

NOP__0		; No operation
RTS__1		; Receiver to sender request for connection
STR__2		; Sender to receiver request for connection
CLS__3		; Close connection
ALL__4		; Notify sender of space allocated by receiver for messages
GVB__5		; Give back space (request for neg allocate)
RET__6		; Space returned (resp to gvb)
INR__7		; Interrupt receiver???
INS__10		; Interrupt sender
ECO__11		; Echo this message
ERP__12		; This is the echo
ERR__13		; Here is an error message

; Storage

LS(LSKT,NSKT)		; Local socket number
LS(FSKT,NSKT)		; Foreign socket number
LS(NETAWD,NSKT)		; B0-8 -- foreign host number (777 for none)
			; B9-17 -- link number (0 for none)
			; B18-23 -- time-out countdown
			; B24-26 -- unused
			; B27-35 -- assigned link number
LS(NETBAL,NSKT)		; Bits of allocation
LS(NETBUF,NSKT)		; B0-17 -- bytes per buffer
			; B18-35 -- buffer location -1 (0 for none)
LS(IMPPTR,NSKT)		; Pointer for emptying/loading buffers
LS(NETEND,NSKT)		; Byte pointer to last byte of buffer
LS(NETSTS,NSKT)		; B0-3 -- fsm state
			; B4-11 -- flag bits
			; B12-17 -- bit stream byte size
			; B18-35 -- message allocation
LS(NETCNT,NSKT)		; Send: bytes remaining to be sent
			; Recv: bytes remaining to be seen by program
LS(NETFRK,NSKT)		; B0-b5 -- interrupt channel for ins
			; B6-b11 -- interrupt channel for inr
			; B12-b17 -- unused
			; B18-b35 -- forkx of fork to interrupt
LS(SKTLCK)		; Lock on assigning socket slots
LS(NETAVB,NAVB)		; Mask of available net buffers
LS(NETAVC)		; Count of available buffers
LS(NETAVL)		; Lock on netavb
LS(NETCNC)		; Count of total conections opened
LS(FUNNYC)		; Count of funny inputs to fsm
NR(NETBFS,NBUF*BUFSIZ)	; Buffers

; Flags in lh of netsts

FLG(BFSND,L,IOS,020000)	; Buffered send mode
FLG(ERRB,L,IOS,010000)	; Error has occurred
FLG(EOTF,L,IOS,004000)	; End of transmission flag
FLG(RFNMB,L,IOS,002000)	; Outstanding rfnm bit
FLG(ORFNB,L,IOS,001000)	; RFNM NOTICED AS OUTSTANDING
FLG(DEDF,L,IOS,000400)	; Host is dead
FLG(KILDF,L,IOS,000200)	; Set if socket is to be freed from kild state

; Pointers to various fields of a connection

PLINK:	POINT 9,NETAWD(UNIT),8	; Pointer to link number
PLNK2:	POINT 9,NETAWD(UNIT),35	; Pointer to assigned link
PFHST:	POINT 9,NETAWD(UNIT),17	; Pointer to foreign host number
PCLKS:	POINT 6,NETAWD(UNIT),23	; Pointer to time-out counter
PINSCH:	POINT 6,NETFRK(UNIT),5	; Pointer to ins psi channel
PINRCH:	POINT 6,NETFRK(UNIT),11	; Pointer to inr psi channel
PFSMCH:	POINT 6,NETFRK(UNIT),17	; POINTER TO PSI CHANNEL FOR FSM CHANGE
PFSM:	POINT 4,NETSTS(UNIT),3	; Pointer to current state of fsm
PBPBYT:	POINT 6,NETSTS(UNIT),17	; Pointer to net bit stream byte size
PBFSIZ:	POINT 18,NETBUF(UNIT),17; Pointer to bytes per buffer
PBPBUF:	POINT 6,IMPPTR(UNIT),11	; Pointer to buffer byte size
PBPBPO:	POINT 6,IMPPTR(UNIT),5	; Pointer to byte position
PBPEBF:	POINT 6,NETEND(UNIT),11	; Pointer to size field of end pointer
PBPEPO:	POINT 6,NETEND(UNIT),5	; Pointer to posn field of end pointer

; Bbn socket numbers description
; A socket number is a 32-bit number which in conjunction with
; A host number specifies one end of a connection
; For bbn sockets, the 32 bit field is divided in 3 parts:
; The high 17 bits is used as follows:
;  if 0:      then this is a system socket
;  if <100000 then the number is a bbn user number and the socket is
;             is called a user socket
;  if >99999  then the number is tss job-number plus 100000, and the
;             socket is called a job socket

; A job socket is analogous to a temporary file and is guaranteed to
; Be unique to that job.  a user socket is analogous to a regular file
; And is guaranteed to be unique to that user.  a system socket is
; For use as agreed upon by members of the network for such purposes
; As inter system communication, memo-distribution etc.

; The next 14 bits are an arbitrary number which may be defaulted
; To the jfn associated with the socket or specified by the name field
; Of the file name string.  the low order bit is determined by
; The gender of the socket.  a socket opened for for writing
; Will have this bit equal to one. a socket opened for reading will
; Have this bit equal to zero.

; Network dispatch table

USE SWAPPC

^NETDTB:NETSET		; Directory setup
	NETNAM		; Name lookup
	NETEXT		; Extension lookup
	NETVER		; Version lookup
	CPOPJ		; Protection insert
	CPOPJ		; Account insert
	CPOPJ		; Status insert
	NETOPN		; Open
	NETSQI		; Byte input
	NETSQO		; Byte output
	NETCLZ		; Close
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dump
	CPOPJ
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Initialize
	NETMTP		; Mtopr
	NETGST		; Get status
	NETSST		; Set status

; Host tables

USE

HOSTAB:	SIXBIT /  UCLA/
	SIXBIT /UCLA36/
	SIXBIT /SRIARC/
	SIXBIT /   NIC/
	SIXBIT / SRIAI/
	SIXBIT /  UCSB/
	SIXBIT /  UTAH/
	SIXBIT /   BBN/
	SIXBIT /  BBNB/
	SIXBIT /MULTCS/
	SIXBIT / MITDG/
	SIXBIT /  RAND/
	SIXBIT /RAND10/
	SIXBIT /   SDC/
	SIXBIT /HARV10/
	SIXBIT / HARV1/
	SIXBIT /HARV11/
	SIXBIT /LNC360/
	SIXBIT /LNCTX2/
	SIXBIT /  STAN/
	SIXBIT /   ILL/
	SIXBIT /  CASE/
	SIXBIT /  CARN/
	SIXBIT / PAOLI/
	SIXBIT /  AMES/
	SIXBIT /AMES36/
	SIXBIT / MITRE/
	SIXBIT / RADCH/
	SIXBIT /RADCTP/
	SIXBIT / NBS11/
	SIXBIT /NBSTIP/
	SIXBIT /  ETAC/
	SIXBIT /TINKER/
	SIXBIT /MCCLEL/
	SIXBIT /   USC/
	SIXBIT /USCTIP/
	SIXBIT /   GWC/
	SIXBIT /  NCAR/
	SIXBIT /NCARTP/
	SIXBIT /BBNTIP/
NHOSTS__.-HOSTAB
	BLOCK 10		; Patch space

HOSTN:	1
	101
	2
	2
	102
	3
	4
	105
	205
	6
	106
	7
	107
	10
	11
	111
	211
	12
	112
	13
	14
	15
	16
	17
	220
	20
	221
	22
	222
	23
	223
	224
	25
	26
	27
	227
	230
	31
	231
	236
IFN .-HOSTN-NHOSTS,<PRINTX /HOSTN AND HOSTAB ARE NOT THE SAME LENGTH.
/>
	BLOCK 10		; Patch space

USE SWAPPC

; Initialize network stuff

USE

^NETINI:SETZM LSKT
	MOVE A,[XWD LSKT,LSKT+1]
	BLT A,LSKT+NSKT-1
	SETZM NETSTS
	MOVE A,[XWD NETSTS,NETSTS+1]
	BLT A,NETSTS+NSKT-1
	SETZM NETCNC
	IFG NAVB-1,<
	SETOM NETAVB
	MOVE A,[XWD NETAVB,NETAVB+1]
	BLT A,NETAVB+NAVB-1
>
	MOVNI A,1
	LSH A,NAVB*=36-NBUF
	MOVEM A,NETAVB+NAVB-1
	MOVEI A,NBUF
	MOVEM A,NETAVC
	SETOM SKTLCK
	SETOM NETAVL
	SETZM FUNNYC
	SETOM NETON		; Net on
	POPJ P,

USE SWAPPC

; Prepare to lookup network names

NETSET:	NOINT
	JRST SK2RET		; Complicated huh?

; Name lookup routine

NETNAM:	TEST(NN,NREC,NREC1)	; Recognition always
	JRST AMBRET		; Produces ambiguous return
	JUMPE A,NAMBAD		; *. -- failure
	HRLI A,(<POINT 7,0,35>)	; Make lookup pointer into byte pointer
	PUSHJ P,NAMDEC		; Decode name
	JRST NAMBAD		; Bad syntax
OKRET:	TEST(NE,UNLKF)
	JRST SK2RET
	OKINT
	JRST SK2RET

AMBRET:	TEST(NN,UNLKF)
	AOS (P)
ERRET:	OKINT
	POPJ P,

NAMBAD:	MOVEI A,GJFX18
	JRST ERRET		; Error return

; Extension lookup routine

NETEXT:	TEST(NN,NREC,NREC1)	; Recognition always
	JRST AMBRET		; Produces ambiguous return
	JUMPE A,NAMBAD		; .* -- failure
	HRLI A,(<POINT 7,0,35>)	; Make lookup pointer into byte pointer
	PUSHJ P,EXTDEC		; Decode extension to check syntax
	JRST EXTBAD		; Bad syntax
	PUSHJ P,HSTCHK
	JRST EXTBAD
	JRST OKRET		; Success

EXTBAD:	MOVEI A,GJFX19
	JRST ERRET

; Version lookup

NETVER:	HRRES A			; Extend sign
	CAIGE A,=100000		; If lss 100000
	HRRZ A,FILDDN(JFN)	; Then use user number
	TEST(NE,UNLKF)
	JRST SKPRET
	OKINT
	JRST SKPRET
	
; Decode extension string
; Called both at gtjfn and openf to decode extension string into
; Foreign socket number and host number

EXTDEC:	MOVEI B,6		; 6 chars max in host name
	SETZ C,			; Accumulate sixbit name here
EXTDE0:	ILDB D,A		; Loop to here for each character
	CAIL D,140
	SUBI D,40		; Convert lower case to upper case
	CAIE D,"-"
	CAIG D,40
	 JRST EXTDE3
EXTDE2:	SUBI D,40		; Convert to sixbit
	ROT D,-=6
	ROTC C,6		; Shift into name
	SOJG B,EXTDE0		; Do for six chars
	ILDB D,A		; Get next
EXTDE3:	JUMPE D,EXTDE5		; No socket number
	CAIE D,"-"
	POPJ P,			; Host name must be followed by -
	MOVSI B,-NHOSTS
	CAMN C,HOSTAB(B)	; Search host table for match
	JRST EXTDE4
	AOBJN B,.-2
	TDNN C,[777777505050]	; No such host, was octal number typed?
	TRNN C,202020		; Will be 2x2x2x if so
	 POPJ P,		; Not number either
	ANDI C,070707		; Extract digits
	LSHC C,-3		; Pack together
	LSH C,-3
	LSHC C,-3
	LSH C,-3
	LSHC C,6
	TRNE C,77		; No site 0
	CAILE C,377		; Nor above 377
	 POPJ P,
	PUSH P,A
	PUSH P,C
	IDIVI C,=36		; Convert host number to bit address
	MOVSI B,400000
	MOVN D,C+1
	ROT B,(D)
	TDNE B,IMPHRT(C)	; Is this host alive?
	 JRST EXTDE6		; Yes, already to go
	MOVE A,0(P)		; Get host number
	PUSHJ P,IMSRST		; Send rst
	MOVEI A,=10000
	DISMS			; Wait 10 sec
EXTDE6:	POP P,D
	POP P,A
	JRST EXTDE7

EXTDE4:	MOVE D,HOSTN(B)		; Get corresponding host number
EXTDE7:	MOVEI C,10
	NIN			; Convert remainder of string to number
	POPJ P,			; No number there
	LDB C,A			; Get terminator
	JUMPN C,CPOPJ		; String too long
	MOVE A,D
	JRST SKPRET		; Return in a host number, in b socket

EXTDE5:	JUMPN C,CPOPJ		; If any part of host name spec'ed, fail
	SETOB A,B
	JRST SKPRET		; Else return -1's

; Decode name string
; Called both at gtjfn and openf to decode name string into
; Local socket number

NAMDEC:	MOVEI C,10		; Perhaps this should be decimal?
	NIN			; Convert to a number
	JRST NAMDE1		; Failure: no number there
	LDB C,A			; Get terminator
	CAIE C,"#"		; If not number sign
	JRST NAMDE2		; Then ordinary
	MOVE C,CAPMSK		; Else system socket
	TRNN C,WHEEL!OPR	; Must be operator or wheel
	POPJ P,			; Else fail
	ILDB C,A		; Get next ch
	TDZA A,A		; Zero for high 17 bits
NAMDE2:	HRRZ A,FILVER(JFN)	; Use filver for high 17 bits
	JUMPN C,CPOPJ		; String too long
	ANDI B,77776
	ROT A,=15
	IOR A,B
	JRST SKPRET

NAMDE1:	LDB C,A
	JUMPN C,CPOPJ		; Not number, fail
	MOVE B,JFN		; Default to jfn
	LSH B,3			; Jfn will end up lsh'ed 3
	JRST NAMDE2

; Open network file

NETOPN:	TEST(NE,XCTF,RNDF)
	JRST ILLACC		; Illegal to access in append or xct
	TEST(NE,READF)
	TEST(NN,WRTF)
	TEST(NN,READF,WRTF)
	JRST ILLACC		; Must be only one of read or write
	LDB A,PBYTSZ
	CAIG A,=36
	CAIG A,0
	 JRST [	MOVEI A,SFBSX2
		POPJ P,]	; Bad byte size
	HLRZ A,FILNEN(JFN)
	HRLI A,(<POINT 7,0,35>)
	PUSHJ P,NAMDEC		; Decode name
	JRST ILLACC		; Can only happen if wheel lost
	TEST(NE,WRTF)
	TROA A,1		; If writing set gender bit for local
	TRZ A,1			; Else clear it
	PUSH P,A		; Save for later
	HRRZ A,FILNEN(JFN)
	HRLI A,(<POINT 7,0,35>)
	PUSHJ P,EXTDEC		; Decode extension
	BUG(HLT,<NETOPN: EXTDEC FAILURE AFTER PREVIOUS NON-FAILURE.>)
	TEST(NE,READF)
	TROA B,1		; If reading set gender bit for forskt
	TRZ B,1			; Else clear
	POP P,C
	LDB D,PBYTSZ		; Get file byte size
	CAIN D,7
	MOVEI D,8		; Make ascii be net ascii
	JUMPL A,OPNLSN		; No foreign socket, do a listen
	PUSHJ P,CONNECT		; Connect
	 POPJ P,
	TEST(Z,WNDF)		; Remember this was not a listen

NETOP1:	HRLM UNIT,DEV		; Remember unit number
	HRLM UNIT,FILDEV(JFN)
	SETZ IOS,		; Clear status bits
	LDB A,[POINT 4,STS,35]
	CAIE A,5		; In modes 5
	CAIN A,7		; Or 7
	TEST(O,BFSND)		; Do buffered transmission
	IORB IOS,NETSTS(UNIT)	; Set it in status word
	LDB B,PBYTSZ		; Get file's byte size
	DPB B,PBPBUF		; Store in imp's pointer
	DPB B,PBPEBF		; Set size of end pointer
	MOVEI A,=36		; Bits per word
	LDB B,PBYTSZ		; Bits per byte
	IDIV A,B		; Gives bytes per word and remainder
	DPB B,PBPBPO		; Remainder is byte position
	DPB B,PBPEPO		; Set position of end pointer
	DPB B,PBYTPO		; And file pointer
	IMULI A,BUFSIZ		; Bytes per word times words per buffer
	DPB A,PBFSIZ		; Gives bytes per buffer
	SETZM NETCNT(UNIT)	; Empty buffer
	SETZM FILBYN(JFN)	; About to reference byte 0 of buffer
	SETZM FILOFN(JFN)	; Also started with byte zer0
	TEST(O,SIZF)		; Cannot change byte size
	TEST(OE,WNDF)		; No buffer yet. also if listen
	JRST SKPRET		; Return immediately
	LDB A,[POINT 4,STS,35]
	CAIE A,6		; Also in modes 6
	CAIN A,7		; And 7
	JRST SKPRET		; Return immediately
	LDB A,PFSM		; No. get current state
	CAIN A,RFCS		; Will usually be rfcs
	PUSHJ P,WATNOT		; If so, wait for it to not be
	IMPOFF
	LDB A,PFSM		; Then get the state
	MOVE IOS,NETSTS(UNIT)	; And get status
	IMPON			; Imp back on
	CAIE A,OPND		; If opened
	TEST(NE,EOTF)		; Or end of file
	 JRST SKPRET		; Then successful opening
	JRST OPNFAI		; Else failure

OPNLSN:	PUSHJ P,LISTEN
	 POPJ P,		; Can't listen
	TEST(O,WNDF)		; To remember that this was a listen
	JRST NETOP1		; First bin/out is accept

OPNFAI:	MOVE B,A
	MOVEI A,CLZR
	CAIN B,CLZW
	PUSHJ P,DOFSM
	MOVEI A,KILD
	PUSHJ P,WATFOR
	MOVEI A,FREE
	DPB A,PFSM		; If so, free the slot
	MOVEI A,OPNX21
	POPJ P,			; And give bad return

ILLACC:	MOVEI A,OPNX14
	POPJ P,

; Wait for fsm to leave state given in a

WATNOT:	HRLI A,NOTTST
WATNO1:	MOVE B,UNIT
	ROT B,-9
	MOVSS A
	IOR A,B
	SKIPE INSKED
	BUG(HLT,<WATNOT: WAS CALLED FROM SCHEDULER LEVEL.>)
	JSYS EDISMS
	POPJ P,

; Wait for fsm to enter a particular state

WATFOR:	HRLI A,WATTST
	JRST WATNO1

USE

NOTTST:	LDB B,[POINT 9,A,26]
	ANDI A,777
	EXCH UNIT,B
	LDB C,PFSM
	EXCH UNIT,B
	CAME A,C
	JRST 1(4)
	JRST WATTS1

WATTST:	LDB B,[POINT 9,A,26]
	ANDI A,777
	EXCH B,UNIT
	LDB C,PFSM
	EXCH B,UNIT
	CAMN C,A
	JRST 1(4)
WATTS1:	MOVE C,FKINT(7)		; Look for deferred interrupts
	TLNN C,(1B1)
	JRST 0(4)		; None. return no skip
	EXCH B,UNIT		; Deferred interrupt, get back unit
	SETZ C,
	DPB C,PCLKS		; Set clock to zero to hasten time-out
	EXCH B,UNIT
	JRST 0(4)

USE SWAPPC

; Close network file

NETCLZ:	HLRZ UNIT,DEV
	SETOM NETFRK(UNIT)
	LDB A,PFSM
	TEST(NN,WNDF)		; If no buffer ever assigned
	TEST(NN,WRTF)		; Or if reading
	JRST NETCL1		; Then skip the following
	MOVE IOS,NETSTS(UNIT)
	MOVE A,FILBYN(JFN)
	CAME A,FILOFN(JFN)
	PUSHJ P,DMPBUF		; Dump last buffer
	MOVEI 1,NETET
	HRL 1,UNIT
	JSYS EDISMS
NETCL1:	LDB A,PFSM
	CAIN A,KILD
	JRST NETCL2
	IMPOFF
	UMOVE A,1
	MOVSI B,KILDF
	TDNN A,[XWD 1,400000]	; Check for clzff or closf(-1)
	TLNN A,(1B1)
	IORM B,NETSTS(UNIT)
	MOVSI A,RFNMB
	TDNE A,NETSTS(UNIT)	; If rfnm outstanding
	TEST(NN,WRTF)		; And sending
	SKIPA A,[CLZR]
	MOVEI A,CLZS		; Then do clzs
	PUSHJ P,DOFSM
	IMPON
	UMOVE A,1
	TDNN A,[XWD 1,400000]
	TLNN A,(1B1)
	 JRST SKPRET		; Return immediately if no bit 1
	LDB B,PFSM
	MOVEI A,KILD
	CAIE B,KILD
	PUSHJ P,WATFOR
NETCL2:	MOVEI A,FREE
	DPB A,PFSM
	JRST SKPRET

USE

NETET:	MOVSI B,EOTF!DEDF
	TDNN B,NETSTS(1)
	SKIPG NETCNT(1)
	JRST 1(4)
	JRST 0(4)

PTYCLZ:	MOVEI A,CLZR
	JRST DOFSM

USE SWAPPC

; Network mtopr routines

NETMTP:	HLRZ UNIT,DEV
	MOVE IOS,NETSTS(UNIT)
	CAIG B,24
	CAIGE B,20
	 POPJ P,
	JRST .+1-20(B)
	JRST NETACP
	JRST NETDMP
	JRST SNDINS
	JRST SNDINR
	JRST NETINT

NETACP:	IMPOFF
	LDB B,PFSM
	MOVEI A,ACPT
	CAIN B,RFCR
	 PUSHJ P,DOFSM
	IMPON
	POPJ P,

NETDMP:	TEST(NE,BFSND)
	TEST(NN,WRTF)
	 POPJ P,
	TEST(NE,WNDF)
	 POPJ P,
	PUSHJ P,DMPBUF
	POPJ P,

SNDINS:	LDB A,PFHST
	LDB B,PLINK
	IMPOFF
	LDB C,PFSM
	CAIN C,OPND
	PUSHJ P,IMPINS
	IMPON
	POPJ P,

SNDINR:	LDB A,PFHST
	LDB B,PLINK
	IMPOFF
	LDB C,PFSM
	CAIN C,OPND
	PUSHJ P,IMPINR
	IMPON
	POPJ P,

NETINT:	UMOVE B,3
	HRR B,FORKX
	MOVEM B,NETFRK(UNIT)
	POPJ P,

NETKFK:	PUSH P,UNIT
	PUSH P,A
	MOVSI UNIT,-NSKT
NETKF1:	HRRE A,NETFRK(UNIT)
	CAMN A,FORKX
	 SETOM NETFRK(UNIT)
	AOBJN UNIT,NETKF1
	POP P,A
	POP P,UNIT
	POPJ P,

; Network file sequential byte input

NETSQI:	HLRZ UNIT,DEV
	MOVE IOS,NETSTS(UNIT)
	TEST(NE,WNDF)
	PUSHJ P,FIRSTI		; Wait for listen set up buffers etc.
	SOSGE FILCNT(JFN)
	PUSHJ P,LODBUF		; Get another bufferful
	TEST(NE,EOFF)
	POPJ P,
	ILDB A,FILBYT(JFN)
	AOS FILBYN(JFN)
	POPJ P,

LODBUF:	MOVSI IOS,ERRB
	TDNE IOS,NETSTS(UNIT)
	TEST(O,ERRF)
	ANDCAB IOS,NETSTS(UNIT)
	SKIPN B,NETCNT(UNIT)
	 JRST [	TLNE IOS,EOTF!DEDF
		JRST [	TEST(O,EOFF)
			POPJ P,]
		PUSHJ P,UNLCKF
		MOVEI A,NETIT
		HRL A,UNIT
		JSYS EDISMS	; Wait for non-zero netcnt
		MOVE P,MPP
		SOS (P)
		JRST MRETN]
	LDB A,PBFSIZ		; Get bytes per buffer
	SUB A,FILBYN(JFN)	; Room left to end of buffer
	JUMPLE A,[MOVE A,NETBUF(UNIT)
		HRRM A,FILBYT(JFN)
		SETZM FILBYN(JFN)
		LDB A,PBFSIZ
		JRST .+1]
	CAML B,A
	MOVE B,A		; Keep min of the two
	LDB A,PBFSIZ
	ASH A,-1		; Half a buffer
	CAML B,A
	MOVE B,A		; Not more than 1/2 buffer at a time
	MOVN A,B
	ADDM A,NETCNT(UNIT)	; Extract this many bytes
	MOVEM B,FILCNT(JFN)	; How many to bin before returning
	SOS FILCNT(JFN)
	ADDM B,FILLEN(JFN)
	PUSHJ P,NETALL
	POPJ P,

NETALL:	LDB B,PBFSIZ		; Bytes per buffer
	ADD A,B			; Minus those given to program
	LDB B,PBPBYT		; Get byte size
	IMPOFF
	SUB A,NETCNT(UNIT)	; Bytes currently being held by int rout
	IMUL A,B		; Convert to bits
	SUB A,NETBAL(UNIT)	; Minus current outstanding allocation
	IMPON			; Yields additional allocation to be given
	PUSH P,C		; Save ac's
	PUSH P,D
	LDB C,PBFSIZ		; Bytes per buffer
	LDB D,PBPBYT		; Bits per byte
	IMUL C,D		; = bits per buffer
	ASH C,-2		; 1/4 buffer
	CAMG A,C		; Don't send allocate of less
	JRST NETAL1		; Than 1/4 buffer
	MOVE D,A
	MOVEI C,1		; Do one message allocation to prime
	LDB A,PFHST
	LDB B,PLINK
	PUSHJ P,IMPALL		; Send allocate
NETAL1:	POP P,D
	POP P,C
	POPJ P,

FIRSTI:	PUSHJ P,WATLSN		; Wait for connection completion
	PUSHJ P,ASGBUF
	 JRST WATBUF		; No buffers right now
	TEST(Z,WNDF)
	SETZ A,
	JRST NETALL		; Send allocate, 0 space used by program

WATBUF:	MOVE P,MPP		; Reset stack
	SOS (P)			; Adjust return to redo jsys
	PUSHJ P,UNLCKF		; Unlock file and turn on ints
	MOVE A,[XWD NETAVC,DISGT]
	JSYS EDISMS
	JRST MRETN

WATLSN:	IMPOFF
	LDB A,PFSM		; Get state of this connection
	CAIN A,OPND
	 JRST [	IMPON
		POPJ P,]
	CAIN A,RFCR
	 JRST [	MOVEI A,ACPT
		PUSHJ P,DOFSM
		IMPON
		POPJ P,]
	CAIN A,RFCS		; If still waiting for rfc
	 JRST WATLS1		; Continue waiting
	CAIE A,LSNG
	 JRST [	IMPON
		MOVSI IOS,EOTF
		TDNE IOS,NETSTS(UNIT)
		 POPJ P,	; Null file sent
		MOVSI IOS,ERRB!EOTF	; Connection never actually opened
		IORB IOS,NETSTS(UNIT)
		POPJ P,]
WATLS1:	IMPON
	MOVE P,MPP		; Reset stack
	SOS (P)			; Adjust return to redo jsys
	PUSHJ P,UNLCKF		; Unlock file and turn ints back on
	PUSHJ P,WATNOT		; Wait to leave current state
	JRST MRETN		; Back to user to restart jsys

USE
NETIT:	MOVSI B,EOTF!DEDF
	TDNN B,NETSTS(A)
	SKIPE NETCNT(A)
	JRST 1(4)
	JRST 0(4)

USE SWAPPC

; Network file sequential byte output

NETSQO:	HLRZ UNIT,DEV
	MOVE IOS,NETSTS(UNIT)
	TEST(NE,DEDF,EOTF)
	 POPJ P,
	PUSH P,A
	TEST(NE,WNDF)
	PUSHJ P,FIRSTO
	TEST(NE,BFSND)		; Immediate send
	 JRST NTSQO1		; No
	PUSHJ P,WATBFO
	AOS FILBYN(JFN)
	POP P,A
	IDPB A,FILBYT(JFN)	; Deposit the byte
	AOS A,NETCNT(UNIT)
	CAIG A,1
	PUSHJ P,IMPSRO
	SETZM FILCNT(JFN)
	MOVE A,FILBYN(JFN)
	LDB B,PBFSIZ
	CAIL A,(B)
	 JRST [	MOVE A,NETBUF(UNIT)
		HRRM A,FILBYT(JFN)
		SETZB A,FILBYN(JFN)
		JRST .+1]
	MOVEM A,FILOFN(JFN)
	POPJ P,

WATBFO:	LDB B,PBFSIZ
	CAMLE B,NETCNT(UNIT)
	POPJ P,
	MOVEI A,NETOT
	HRL A,UNIT
	JSYS EDISMS
	POPJ P,

NTSQO1:	SOSGE FILCNT(JFN)
	PUSHJ P,DMPBUF
	AOS FILBYN(JFN)
	POP P,A
	IDPB A,FILBYT(JFN)
	POPJ P,

DMPBUF:	MOVSI IOS,ERRB
	TDNE IOS,NETSTS(UNIT)
	TEST(O,ERRF)
	ANDCAB IOS,NETSTS(UNIT)
	TEST(NE,EOTF)
	 JRST [	SETZM FILBYT(JFN)
		SETZM FILBYN(JFN)
		SETZM FILOFN(JFN)
		HRLOI A,377777
		MOVEM A,FILCNT(JFN)
		POPJ P,]
	MOVE B,FILBYN(JFN)	; Get where we are in buffer
	SUB B,FILOFN(JFN)	; Minus where we were give how many
	IMPOFF
	ADD B,NETCNT(UNIT)	; Augment netcnt
	EXCH B,NETCNT(UNIT)	; Get old netcnt
	IMPON
	SKIPN B
	PUSHJ P,IMPSRO		; Restart output
	PUSHJ P,SETBUF		; Set up next output buffer
	SOS FILCNT(JFN)
	POPJ P,

SETBUF:	LDB B,PBFSIZ		; Bytes per buffer
	SUB B,NETCNT(UNIT)	; Gives room left
	JUMPE B,[MOVEI A,NETOT
		HRL A,UNIT
		JSYS EDISMS
		JRST SETBUF]
	LDB A,PBFSIZ
	SUB A,FILBYN(JFN)	; Room left in buffer
	CAML B,A
	MOVE B,A		; Keep the lesser
	LDB A,PBFSIZ
	ASH A,-1
	CAML B,A
	MOVE B,A		; No more than 1/2 buffer
SETBU1:	MOVEM B,FILCNT(JFN)
	ADDM B,FILLEN(JFN)
	LDB B,PBFSIZ
	MOVE A,FILBYN(JFN)
	CAIL A,(B)		; At end of buffer
	 JRST [	MOVE A,NETBUF(UNIT)	; Yes, reset pointers
		HRRM A,FILBYT(JFN)
		SETZB A,FILBYN(JFN)
		JRST .+1]
	MOVEM A,FILOFN(JFN)	; Save this filbyn
	POPJ P,

FIRSTO:	PUSHJ P,WATLSN		; Wat for connection complete
	PUSHJ P,ASGBUF		; Assign and lock buffers
	 JRST WATBUF		; None available now
	TEST(Z,WNDF)
	TEST(NE,BFSND)
	JRST SETBUF
	POPJ P,

USE
NETOT:	EXCH UNIT,1
	LDB B,PBFSIZ
	MOVSI C,EOTF!DEDF
	TDNE C,NETSTS(UNIT)
	SETZM NETCNT(UNIT)
	CAMLE B,NETCNT(UNIT)
	AOS 4
	EXCH 1,UNIT
	JRST 0(4)

USE SWAPPC

; Attach sockets to pty
; Call:	1	; Receive jfn of opened network connection
;	2	; Send jfn of opened network connection
;	ATPTY
; Returns
;	+1	; Cannot attach
;	+2	; Ok.  the jfns are released, ac 1 has line number of
;		; Attached pty.

^.ATPTY:JSYS MENTR
	UMOVE JFN,1
	PUSHJ P,CHKJFN		; Check jfn of receive connection
	 JRST ATPER0		; Only real jfns are legal
	 JRST ATPER0
	 JRST ATPER0
	MOVEI A,ATPX2		; Error code if test skips
	TEST(NE,READF)		; Must be opened for reading
	PUSHJ P,CHKATP		; Check for dev=net, open, no buffer
	 JRST ATPER1		; Failed one of the above
	PUSH P,DEV		; Save dev and jfn
	PUSH P,JFN
	UMOVE JFN,2		; Get send jfn
	PUSHJ P,CHKJFN		; Check it
	JRST ATPER2		; Must also be a real jfn
	JRST ATPER2
	JRST ATPER2
	MOVEI A,ATPX2		; Becomes atpx8 at atper3
	TEST(NE,WRTF)		; This one must be for writing
	PUSHJ P,CHKATP		; And dev=net, open, no buffer
	 JRST ATPER3		; Failed above tests
	HLRZ UNIT,DEV
	LDB A,PFSM
	CAIN A,RFCS
	PUSHJ P,WATNOT		; Wait for response from foreign host
	MOVEI A,ATPX12		; Error code for refused send
	LDB B,PFSM		; Now get state
	CAIE B,OPND		; If not opnd
	JRST ATPER4		; Then fail
	EXCH DEV,-1(P)		; Switch to receive connection
	HLRZ UNIT,DEV
	LDB A,PFSM		; Get its state
	CAIN A,RFCS
	PUSHJ P,WATNOT		; Wait for response from foreign host
	MOVEI A,ATPX6		; Error code for refused receive
	LDB B,PFSM
	CAIE B,OPND		; If not opnd
	JRST ATPER4		; Then fail
	PUSH P,UNIT
	IMPOFF
	LDB A,PFSM
	CAIE A,OPND
	 JRST [	MOVEI A,ATPX6
		JRST ATPERZ]
	HLRZ UNIT,-2(P)
	LDB A,PFSM
	CAIE A,OPND
	 JRST [		MOVEI A,ATPX12
		JRST ATPERZ]
	MOVE 1,0(P)		; Set up args, receive unit in 1
	HLRZ 2,-2(P)		; Send unit in 2
	PUSHJ P,ASNPTY		; Assign pty to these units
	 JRST [	MOVEI A,ATPX13	; Can't, no pty's
		JRST ATPERZ]
	POP P,UNIT
	MOVSI B,KILDF		; Cause automatic deletion of this
	IORM B,NETSTS(UNIT)	; Connection when closed
	HRRM 1,NETBUF(UNIT)	; Store pty number here
	HLRZ UNIT,-1(P)
	IORM B,NETSTS(UNIT)	; Auto delete
	HRRM 1,NETBUF(UNIT)	; Put pty here also
	IMPON
	IORI A,400000		; Convert pty to tty designator
	UMOVEM A,1		; Return to user
	PUSHJ P,RELJFN		; Release send jfn
	POP P,JFN
	PUSHJ P,RELJFN		; And receive jfn
	SUB P,[XWD 1,1]
	JRST SKMRTN		; Return skipping

; Check validity of jfn for atpty

CHKATP:	MOVEI A,ATPX3		; Receive not open
	TEST(NN,OPENF)
	POPJ P,
	HRRZ B,DEV
	MOVEI A,ATPX4
	CAIE B,NETDTB
	POPJ P,
	MOVEI A,ATPX5
	TEST(NN,WNDF)
	POPJ P,
	JRST SKPRET

ATPERZ:	IMPON
	POP P,UNIT
	JRST ATPER4

ATPER2:	MOVEI A,ATPX1		; Bad jfn, modified below
ATPER3:	ADDI A,ATPX7-ATPX1	; Convert receive errors to send errors
ATPER4:	PUSHJ P,UNLCKF
	POP P,JFN
	POP P,DEV
ATPER1:	PUSHJ P,UNLCKF
	JRST MRETNE		; Save error return in ac1

ATPER0:	MOVEI A,ATPX1		; Bad receive jfn
	JRST MRETNE

; Convert jfn to absolute network socket number
; Call:	1	; Jfn
;	CVSKT
; Returns
;	+1	; Error
;	+2	; Ok, in 2 the absolute socket number

.CVSKT:	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST CVSER0
	 JRST CVSER0
	 JRST CVSER0
	HLRZ A,FILNEN(JFN)
	HRLI A,(<POINT 7,0,35>)
	PUSHJ P,NAMDEC
	 JRST CVSER1
	TRZ A,1
	PUSHJ P,UNLCKF
	UMOVEM A,2
	JRST SKMRTN

CVSER1:	PUSHJ P,UNLCKF
	SKIPA A,[CVSKX2]
CVSER0:	MOVEI A,CVSKX1
	JRST MRETNE

; Get net status

NETGST:	HLRZ UNIT,DEV
	MOVE A,NETSTS(UNIT)
	LDB B,PFHST
	UMOVEM B,3
	MOVE B,FSKT(UNIT)
	UMOVEM B,4
	POPJ P,

; Set net status

NETSST:	POPJ P,

; Assign and lock buffers

ASGBUF:	PUSH P,A		; Save ac's
	PUSH P,B
	PUSH P,C
	MOVSI C,-NAVB		; Set to index through all bit masks
	LOCK NETAVL		; Set lock
ASGBFL:	MOVE A,NETAVB(C)	; Loop to here for each bit mask
	JFFO A,ASGBFG		; Find a one
	AOBJN C,ASGBFL		; Loop through all masks
	UNLOCK NETAVL		; Failure
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

ASGBFG:	MOVSI A,400000
	MOVNS B
	ROT A,(B)
	ANDCAM A,NETAVB(C)
	SOS NETAVC		; One less available buffer
	UNLOCK NETAVL
	HRRZ A,C
	POP P,C
	IMULI A,=36
	SUBM A,B
	IMULI B,BUFSIZ
	MOVEI A,NETBFS(B)
	PUSH P,A
	MOVES (A)
	PUSHJ P,FPTA
	PUSHJ P,MLKPG
	MOVE A,(P)
	ADDI A,BUFSIZ-1
	MOVES (A)
	PUSHJ P,FPTA
	PUSHJ P,MLKPG
	POP P,A
	SUBI A,1
	HRRM A,FILBYT(JFN)
	HRRM A,NETBUF(UNIT)
	HRRM A,IMPPTR(UNIT)
	ADDI A,BUFSIZ
	HRRM A,NETEND(UNIT)
	SETZM NETCNT(UNIT)
	POP P,B
	POP P,A
	JRST SKPRET

; Release buffers

USE

RELBUF:	HRRZ A,NETBUF(UNIT)
	AOS A
	HLLZS NETBUF(UNIT)
RELBFF:	CAIN A,0
	POPJ P,
	PUSH P,A
	SUBI A,NETBFS
	IDIVI A,BUFSIZ		; Get buffer number
	IDIVI A,=36
	MOVNS B
	PUSH P,A
	MOVSI A,400000
	ROT A,(B)		; Get bit for this buffer
	POP P,B
	IORM A,NETAVB(B)
	AOS NETAVC		; One more buffer available
	MOVE A,(P)
	ADDI A,BUFSIZ-1
	SKIPE INSKED
	JRST RELBFW
	PUSHJ P,FPTA
	PUSHJ P,MULKPG		; Unlock page at end of buffer
	POP P,A
	PUSHJ P,FPTA
	JRST MULKPG		; Unlock page at beginning of buffer

RELBFW:	PUSHJ P,MULKMP
	POP P,A
	JRST MULKMP

; The following code and tables implement a finite state machine
; Implementation of the transitions and actions produced by various
; Events associated with a connection
; Assumed are that unit indexes the proper local socket

; Events are numbered as follows

RRFC__0		; Received an rfc
CLSR__1		; Cls for a receive socket
CLSS__2		; Cls for a send socket
CLZR__3		; Close done on a receive socket
CLZS__4		; Close done on a send socket
ACPT__5		; Program issued an accept
CONN__6		; Program issued a connect
LISN__7		; Program issued a listen
RRFM__10	; Received a rfnm
RRFN__11	; Received a rfnm with no more data outstanding
HUNG__12	; Time out event (happens 2 minutes after last dofsm)

; Actions are numbered as follows

ANOP__0		; No operation
AFNY__1		; No operation (unexpected event)
ACLS__2		; Send cls
ARFC__3		; Send rfc
ACLL__4		; Close link
ACLO__5		; Close link and send cls
AEOR__6		; Finish reception
ACKR__7		; Simulate rfnm if none outstanding

; States are numbered as follows

DEAD__0		; Never used
CLZD__1		; Closed
PNDG__2		; Pending. rfc received while closed
LSNG__3		; Listening. listen issued while closed
RFCR__4		; Rfc received while listening
CLW2__5		; Close wait #2. cls from pndg
RFCS__6		; Rfc sent
OPND__7		; Opened
CLSW__10	; Waiting for a cls
DATW__11	; Waiting for all data to be sent
RFN1__12	; Waiting for last rfnm
CLZW__13	; Waiting for program to do close
RFN2__14	; Waiting for rfnm after clss
KILD__15	; Prematurely killed by distant host
FREE__16	; Not in use

; The following table of byte pointers is used to get to the next state
; Given the current state and the event
; This table is indexed by event, the table addressed by this table
; Is indexed by old state

RADIX =10

CBPFSM:	FOR QQ_3,35,4
<	POINT 4,NXTSTT(B),QQ
>
	FOR QQ_3,35,4
<	POINT 4,NXTSTT+1(B),QQ
>

; Following table of pointers is used to get the action to be taken
; Given the current state and the event
; This table is indexed by event, the table addressed by this table
; Is indexed by old state

CBAFSM:	FOR QQ_3,35,4
<	POINT 4,ACTION(B),QQ
>
	FOR QQ_3,35,4
<	POINT 4,ACTION+1(B),QQ
>

; This is the transition table
; Each word contains the new state for a given old state
; Successive bytes are used for different events

; Event rrfc clsr clss clzr clzs acpt conn lisn rrfm rrfe  old state

NXTSTT:
BYTE (4)DEAD,DEAD,DEAD,DEAD,DEAD,DEAD,DEAD,DEAD,DEAD,DEAD,DEAD	; Dead
BYTE (4)PNDG,CLZD,CLZD,CLZD,CLZD,CLZD,RFCS,LSNG,CLZD,CLZD,CLZD	; Clzd
BYTE (4)PNDG,FREE,FREE,PNDG,PNDG,PNDG,OPND,RFCR,PNDG,PNDG,CLW2	; Pndg
BYTE (4)RFCR,LSNG,LSNG,KILD,KILD,LSNG,LSNG,LSNG,LSNG,LSNG,LSNG	; Lsng
BYTE (4)RFCR,KILD,KILD,CLSW,CLSW,OPND,RFCR,RFCR,RFCR,RFCR,RFCR	; Rfcr
BYTE (4)CLW2,FREE,FREE,CLW2,CLW2,CLW2,CLW2,CLW2,CLW2,CLW2,FREE	; Clw2
BYTE (4)OPND,KILD,KILD,CLSW,CLSW,RFCS,RFCS,RFCS,RFCS,RFCS,CLSW	; Rfcs
BYTE (4)OPND,CLZW,RFN2,CLSW,DATW,OPND,OPND,OPND,OPND,OPND,OPND	; Opnd
BYTE (4)CLSW,KILD,KILD,CLSW,CLSW,CLSW,CLSW,CLSW,CLSW,CLSW,KILD	; Clsw
BYTE (4)DATW,DATW,RFN1,DATW,DATW,DATW,DATW,DATW,DATW,CLSW,CLSW	; Datw
BYTE (4)RFN1,RFN1,RFN1,RFN1,RFN1,RFN1,RFN1,RFN1,KILD,KILD,KILD	; Rfn1
BYTE (4)CLZW,CLZW,CLZW,KILD,KILD,CLZW,CLZW,CLZW,CLZW,CLZW,CLZW	; Clzw
BYTE (4)RFN2,RFN2,RFN2,RFN1,RFN1,RFN2,RFN2,RFN2,CLZW,CLZW,CLZW	; Rfn2
BYTE (4)KILD,KILD,KILD,KILD,KILD,KILD,KILD,KILD,KILD,KILD,KILD	; Kild
BYTE (4)FREE,FREE,FREE,FREE,FREE,FREE,FREE,FREE,FREE,FREE,FREE	; Free

; This is the action table
; It is referenced the same as the transition table

; Event rrfc clsr clss clzr clzs acpt conn lisn rrfm rrfe  old state

ACTION:
BYTE (4)AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Dead
BYTE (4)ANOP,AFNY,AFNY,AFNY,AFNY,AFNY,ARFC,ANOP,AFNY,AFNY,ANOP	; Clzd
BYTE (4)AFNY,ACLS,ACLS,AFNY,AFNY,AFNY,ARFC,ANOP,AFNY,AFNY,ACLS	; Pndg
BYTE (4)ANOP,AFNY,AFNY,ANOP,ANOP,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Lsng
BYTE (4)AFNY,ACLS,ACLS,ACLS,ACLS,ARFC,AFNY,AFNY,AFNY,AFNY,ANOP	; Rfcr
BYTE (4)AFNY,ANOP,ANOP,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Clw2
BYTE (4)ANOP,ACLS,ACLS,ACLS,ACLS,AFNY,AFNY,AFNY,AFNY,AFNY,ACLS	; Rfcs
BYTE (4)AFNY,AEOR,ACKR,ACLS,ANOP,AFNY,AFNY,AFNY,ANOP,AFNY,ANOP	; Opnd
BYTE (4)AFNY,ACLL,ACLL,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ACLL	; Clsw
BYTE (4)AFNY,AFNY,ACKR,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP,ACLS,ACLS	; Datw
BYTE (4)AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ACLO,ACLO,ACLO	; Rfn1
BYTE (4)AFNY,AFNY,AFNY,ANOP,ANOP,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Clzw
BYTE (4)AFNY,AFNY,AFNY,ANOP,ANOP,AFNY,AFNY,AFNY,ACLO,ACLO,ACLO	; Rfn2
BYTE (4)AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Kild
BYTE (4)AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,AFNY,ANOP	; Free

; Dispatch table for actions
; Routines are called effectively by pushj p,@actab(action#)

ACTAB:	CPOPJ		; Nop
	FUNNY		; Unexpected event
	SNDCLS		; Send cls
	SNDRFC		; Send str or rts
	NETCLL		; Close link
	NETCLB		; Close link and send cls
	DOEOR		; Finish up input
	CHKRFN		; Check and simulate rfnm

RADIX 8

; Unexpected event

FUNNY:	PUSHJ P,IMPBUG
	AOS FUNNYC		; Count them
	POPJ P,			; And do nothing

CHKRFN:	MOVSI A,RFNMB
	TDNE A,NETSTS(UNIT)
	POPJ P,
	MOVEI A,RRFM
	JRST DOFSM

DOEOR:	PUSHJ P,SNDCLS
	HRRZ B,NETBUF(UNIT)
	JUMPE B,NETCLL
	CAIL B,1000
	JRST NETCLL
EORPTY:	PUSH P,UNIT
	PUSHJ P,PTYDET
	POP P,UNIT
	MOVE IOS,NETSTS(UNIT)
NETCLL:	LDB A,PFHST
	MOVE B,LSKT(UNIT)
	TRNE B,1
	IORI A,1000
	LDB B,PLINK
	JUMPE B,CPOPJ
	TEST(NE,DEDF)
	 POPJ P,
	JRST IMPCLL

NETCLB:	PUSHJ P,NETCLL
SNDCLS:	LDB A,PFHST		; Get foreign host
	MOVE C,FSKT(UNIT)	; And foreign socket
	MOVE B,LSKT(UNIT)	; And local socket
	TEST(NN,DEDF)
	PUSHJ P,IMPCLS		; Send the control message
	POPJ P,

SNDRFC:	TEST(NE,DEDF)
	 POPJ P,
	LDB A,PFHST		; Get foreign host
	MOVE B,LSKT(UNIT)	; And local socket
	MOVE C,FSKT(UNIT)
	LDB D,PBPBYT		; Byte size
	TRNE B,1
	JRST IMPSTR
	MOVEI D,FLINK(UNIT)
	DPB D,PLNK2
	JRST IMPRTS		; Send control message

; This here is the main fsm routine

DOFSM:	MOVE IOS,NETSTS(UNIT)
	TEST(NN,DEDF)
	 JRST DOFSMA
	PUSHJ P,DOFSMA
	LDB A,PFSM
DOFSMB:	PUSH P,A
	MOVEI A,HUNG
	PUSHJ P,DOFSMA
	LDB A,PFSM
	POP P,B
	CAME A,B
	 JRST DOFSMB
	POPJ P,

DOFSMA:	IMPOFF			; Allow no control messages while here
	MOVEI B,=24		; TIME OUT IN 2 MINUTES
	DPB B,PCLKS
	LDB B,PFSM		; Get old state
	PUSH P,B
	LSH B,1			; Two words per old state
	LDB C,CBPFSM(A)		; Get new state
	LDB B,CBAFSM(A)		; Get action
	DPB C,PFSM
	PUSH P,B		; Save action
	MOVE B,-1(P)		; GET OLD STATE
	CAME C,B		; STATE CHANGED?
	 JRST [	HRRE A,NETFRK(UNIT)
		JUMPL A,.+1	; NO FORK FOR INTERRUPTS
		LDB B,PFSMCH	; GET PSI CHANNEL
		CAIL B,=36
		 JRST .+1
		EXCH A,B
		PUSHJ P,PSIRQ
		JRST .+1]
	MOVE B,-1(P)
	CAIN C,OPND		; Entering opnd?
	CAMN C,B		; And not there before?
	JRST DOFSM0
	AOS NETCNC
	PUSH P,C
	LDB A,PFHST
	MOVE B,LSKT(UNIT)
	TRNE B,1
	IORI A,1000
	LDB B,PLNK2
	DPB B,PLINK
	TEST(NN,DEDF)
	PUSHJ P,IMPOPL
	POP P,C
	POP P,B
	SUB P,[XWD 1,1]
	PUSHJ P,@ACTAB(B)
	IMPON
	POPJ P,

DOFSM0:	MOVE A,-1(P)
	CAIN A,OPND
	CAMN C,A
	JRST DOFSM1
	MOVSI A,EOTF
	IORM A,NETSTS(UNIT)
DOFSM1:	MOVE A,-1(P)
	CAME A,C
	CAIE C,KILD
	JRST DOFSM2
	HRRZ A,NETBUF(UNIT)
	CAIL A,1000
	PUSHJ P,RELBUF
	MOVEI A,FREE
	TEST(NE,KILDF)
	DPB A,PFSM
DOFSM2:	POP P,B
	SUB P,[XWD 1,1]
	PUSHJ P,@ACTAB(B)	; Call action routine
	IMPON
	POPJ P,

; Make a socket or find existing one

GETSKT:	TDZA D,D
MAKSKT:	SETO D,
	PUSH P,D
	PUSH P,A		; Save foreign host
	PUSH P,B		; Save foreign socket
	PUSH P,C		; Save local socket
	MOVE UNIT,C
	XOR UNIT,B
	TRNN UNIT,1		; Homosexual?
	JRST MAKSKX		; Yes. error
	ROT C,-4
	MOVS UNIT,C
	IMULI C,123431
	XOR UNIT,C		; Randomize from local socket
	LSH UNIT,-1
	MULI UNIT,NSKT		; Initial probe
	MOVEI D,NSKT
	SETO C,
MAKSKJ:	IMPOFF
	LOCK(SKTLCK,<JRST [IMPON
			MOVE A,[XWD SKTLCK,DISLT]
			JSYS EDISMS
			JRST MAKSKJ]>)
MAKSKL:	LDB A,PFSM		; Get state of this socket
	CAIE A,FREE
	CAIN A,DEAD
	JRST MAKSK1
	CAIE A,CLZW
	CAIN A,KILD
	JRST MAKSKN		; Kild & CLZW sockets are invisible
	MOVE B,LSKT(UNIT)	; What local socket is this for?
	CAME B,(P)
	JRST MAKSKN		; Not the one we're after, try next
MAKSK3:	SKIPGE -2(P)
	JRST MAKSK6
	LDB B,PFHST
	MOVE A,FSKT(UNIT)
	CAIN B,777
	JRST MAKSK4		; Match if no fhost specified
	CAMN B,-2(P)
	CAME A,-1(P)
	JRST MAKSKN
MAKSK4:	POP P,C
	JRST MAKSKF

MAKSK6:	POP P,C
	SUB P,[XWD 3,3]
	MOVE B,FSKT(UNIT)
	LDB A,PFHST
	UNLOCK SKTLCK
	IMPON
	JRST SKPRET

MAKSKN:	SOJLE D,MAKSKE		; Full, error
	SOJGE UNIT,MAKSKL	; Loop back for next slot
	MOVEI UNIT,NSKT-1
	JRST MAKSKL

MAKSK1:	SKIPGE C
	MOVE C,UNIT		; Save where it's at
	CAIE A,DEAD
	JRST MAKSKN		; Space keeper, test next
MAKSK5:	SKIPN -3(P)
	JRST MAKSKR
	MOVE UNIT,C
FOR A IN (NETSTS,NETBUF,NETAWD,NETBAL,IMPPTR,NETEND,NETCNT),<
	SETZM A(UNIT)>
	SETOM NETFRK(UNIT)
	MOVEI A,CLZD
	DPB A,PFSM		; Set its state to be closed
	POP P,C
	MOVEM C,LSKT(UNIT)
MAKSKF:	POP P,B			; Common for old and new
	MOVEM B,FSKT(UNIT)
	POP P,A
	DPB A,PFHST
	SUB P,[XWD 1,1]
	UNLOCK SKTLCK
	IMPON
	JRST SKPRET

MAKSKE:	JUMPGE C,MAKSK5
MAKSKR:	UNLOCK SKTLCK
	IMPON
MAKSKX:	POP P,C
	POP P,B
	POP P,A
	SUB P,[XWD 1,1]
	POPJ P,

; Do a listen (openf for file with no foreign host/socket)

LISTEN:	PUSHJ P,HSTCHK
	POPJ P,
	PUSH P,D		; Save byte size
	PUSHJ P,MAKSKT		; Make a socket
	 JRST [	POP P,D
		MOVEI A,OPNX10
		POPJ P,]	; No room
	MOVEI A,LISN
	JRST CONNE1

; Do a connect (openf for file with foreign host/socket specified)

CONNEC:	PUSHJ P,HSTCHK
	POPJ P,
	PUSH P,D		; Save byte size
	PUSHJ P,MAKSKT		; Make a socket or find existing one
	 JRST [	POP P,D
		MOVEI A,OPNX10
		POPJ P,]	; No room
	MOVEI A,CONN
CONNE1:	IMPOFF
	LDB B,PFSM
	CAIN B,CLZD		; Received any rfc here?
	 JRST CONNE2		; No
	CAIN B,PNDG		; Same question
	 JRST CONNE3		; Yes
	MOVEI A,OPNX9		; Already in use
	POP P,D
	IMPON
	POPJ P,

CONNE2:	POP P,D			; My choice of byte size
	DPB D,PBPBYT		; Set byte size
	PUSHJ P,DOFSM		; Send rfc etc
	IMPON
	JRST SKPRET

CONNE3:	TRNE C,1		; Are we sender?
	 JRST CONNE2		; Also our choice
	LDB D,PBPBYT		; Get his byte size
	CAMN D,0(P)		; Does byte size agree?
	 JRST CONNE2		; Yes, same as if my choice
	MOVEI A,HUNG		; Flush his connection attempt
	PUSHJ P,DOFSM
	POP P,D
	IMPON
	MOVEI A,OPNX22		; Bad byte size error
	POPJ P,
L
; Check if host is available

HSTCHK:	SKIPL IMPRDY
	 JRST [	MOVEI A,OPNX19
		POPJ P,]
	JUMPL A,SKPRET
	PUSH P,A
	PUSH P,B
	IDIVI A,=36
	MOVE A,IMPHRT(A)
	ROT A,(B)
	POP P,B
	JUMPGE A,[POP P,A
		MOVEI A,OPNX20
		POPJ P,]
	POP P,A
	JRST SKPRET

; Routines to call when control messages are received

; Receive cls
; Reccls(fhost,fskt,lskt)--nil

RECCLS:	PUSHJ P,GETSKT		; Get the socket entry
	POPJ P,			; Wasn't there, ignore
RECCL1:	MOVE B,LSKT(UNIT)
	TRNN B,1
	SKIPA A,[CLSR]
	MOVEI A,CLSS
	JRST DOFSM

; Receive str
; Recstr(fhost,fskt,lskt)--nil

RECSTR:	PUSH P,A
	PUSHJ P,HSTCHK		; Do we consider this host up?
	 JRST [	POP P,A		; No
		JRST IMSRST]	; Respond with reset
	POP P,A
	PUSH P,D		; Save byte size
	PUSHJ P,MAKSKT
	 JRST [	POP P,D
		POPJ P,]
	LDB A,PFSM		; What is state of this connection
	CAIE A,CLZD		; If not clzd
	 JRST [	LDB D,PBPBYT	; Then get user's byte size
		CAMN D,0(P)	; If not the same
		JRST .+1
		MOVEI A,RRFC
		PUSHJ P,DOFSM
		MOVEI A,CLZR
		PUSHJ P,DOFSM
		POP P,D
		POPJ P,]
	POP P,D
	DPB D,PBPBYT
	MOVEI A,FLINK(UNIT)
	DPB A,PLNK2
	MOVEI A,RRFC
	PUSHJ P,DOFSM
	MOVE A,UNIT
	LDB B,PLINK
	POPJ P,

; Receive rts
; Recrts(fhost,fskt,lskt,link)

RECRTS:	PUSH P,A
	PUSHJ P,HSTCHK
	 JRST [	POP P,A
		JRST IMSRST]
	POP P,A
	PUSH P,D
	PUSHJ P,MAKSKT
	 JRST [	POP P,D
		POPJ P,]
	POP P,A
	DPB A,PLNK2
	MOVEI A,RRFC
	PUSHJ P,DOFSM
	POPJ P,

; Receive rfnm

RCRFNM:	MOVSI A,ORFNB
	ANDCAM A,NETSTS(UNIT)
	MOVSI A,EOTF
	TDNE A,NETSTS(UNIT)
	SKIPLE NETCNT(UNIT)
	SKIPA A,[RRFM]
	MOVEI A,RRFN
	JRST DOFSM

; Receive ins/inr

RECINR:	LDB B,PINRCH
	JRST RCINRS

RECINS:	LDB B,PINSCH
RCINRS:	LDB A,PFSM
	CAIE A,OPND
	 POPJ P,
	HRRZ A,NETBUF(UNIT)
	SKIPE A
	CAIL A,1000
	CAIA
	 POPJ P,
	HRRE A,NETFRK(UNIT)
	JUMPL A,CPOPJ
	EXCH A,B
	PUSHJ P,PSIRQ
	POPJ P,

; Receive reset message

RECRST:	PUSHJ P,NETHDN
	JRST IMPRRP

NETDWN:	MOVSI UNIT,-NSKT
	PUSHJ P,SKTDWN
	AOBJN UNIT,.-1

NETCHK:	MOVSI UNIT,-NSKT
NETCKL:	LDB A,PFSM
	CAIE A,DEAD
	CAIN A,FREE
	 JRST NETCKN
	CAIE A,OPND
	 JRST NETCK0
	LDB A,PCLKS
	SOS A
	DPB A,PCLKS
	JUMPG A,NETCK1
	MOVSI A,ORFNB
	TDNE A,NETSTS(UNIT)
	 JRST [	PUSHJ P,SKTDWN	; LOST A RFNM, DECLARE IT DEAD
		JRST NETCK1]
	IORM A,NETSTS(UNIT)
	MOVEI A,12
	DPB A,PCLKS
	JRST NETCK1

NETCK0:	MOVSI A,DEDF
	TDNN A,NETSTS(UNIT)
	SKIPL IMPRDY
	JRST NETCK1
	LDB B,PCLKS
	SOS B
	DPB B,PCLKS
	JUMPG B,NETCKN
NETCK1:	MOVEI A,HUNG
	PUSHJ P,DOFSM
NETCKN:	AOBJN UNIT,NETCKL
	MOVEI A,=5000
	ADD A,TODCLK
	MOVEM A,NETTIM
	POPJ P,

; Host has died

NETHDN:	MOVSI UNIT,-NSKT
	PUSH P,A
NETHDL:	LDB A,PFSM
	CAIE A,FREE
	CAIN A,DEAD
	JRST NETHDX
	LDB A,PFHST
	CAMN A,(P)
	PUSHJ P,SKTDWN
NETHDX:	AOBJN UNIT,NETHDL
	POP P,A
	POPJ P,

SKTDWN:	SETZ A,
	DPB A,PFHST
	MOVSI A,ERRB!DEDF
	IORM A,NETSTS(UNIT)
	LDB A,PFSM		; Get state
	CAIN A,OPND		; If opnd
	PUSHJ P,RECCL1		; Simulate receipt of cls
	MOVEI A,HUNG
	PUSHJ P,DOFSM
	POPJ P,

USE SWAPPC

BENDP	NETWRK>

;13 OCT 71, 2213:
;IMP DRIVER - D. MURPHY

IFDEF IMPCHN,<	;THIS WHOLE FILE IS INCLUDED ONLY IF IMP EXISTS

;PARAMETERS

	RESCD

IMPBFS==20		;SIZE OF SINGLE BUFFER
IMPBFF==IMPBFS+1	;SIZE INCLUDING OVERHEAD
IMPNBF==20		;NUMBER OF BUFFERS
IMPNLK==40		;SIZE OF LINK TABLE
IMP8XS==40		;SIZE OF IRREG MES BUFFER
IMPCMS==20		;SIZE OF CONTROL QUEUE

IMPNPD==60		;SIZE OF 8-LEVEL ROUTINE STACK
N8CB==100		;SIZE OF CONTROL MESSAGE BUFFER
IMPLBT==400/^D36+1	;SIZE OF BIT TABLES FOR HOST STATES
NTTMXA==<TTBSIZ/^D10>*^D8	;MAX OUTSTANDING ALLOC FOR PTY CONN'N
CLINK==0		;CONTROL LINK

IMPUN==5		;AC FOR 'UNIT'

IMPTB1==1		;BIT IN TTNETW, ALLOCATION REQ QUEUED
IMPTB2==2		;BIT IN TTNETW, LAST CHAR WAS CR

;CONO-CONI BITS

IMP=550

IMPINB==1B32		;INPUT WORD READY
IMPOUB==1B28		;READY FOR NEXT OUTPUT WORD
IMPEIB==1B24		;END OF INPUT
IMPGEB==1B23		;CLEAR EIB
IMPEOB==1B22		;END OF OUTPUT
IMPSTO==1B21		;STOP OUTPUT

IMPIOF==10B27+10		;E OF CONO TO CLEAR INPUT PI ASMT
IMPION==<10+IMPCHN>B27+<10+IMPCHN> ;E OF CONO TO SET INPUT PI ASMT
IMPOON==<10+IMPCHN>B31		;E OF CONO TO SET OUTPUT PI ASMT

PTNETI:	POINT 9,TTNETW(2),35	;INPUT UNIT
PTNETO:	POINT 9,TTNETW(2),26	;OUTPUT UNIT

INTERN IMPSV,IMPCHK,IMPOPL,IMPCLL,IMPRTS,IMPSTR,IMPCLS,IMPALL,IMPSRO
INTERN ASNPTY,PTYDET,IMPRST,IMPRRP,IMPBUG,IMSRST,TTNETW,IMPINR,IMPINS

EXTERN RECRTS,RECSTR,RECCLS,RCRFNM,DISG,PFHST,PLINK,EOTF,PTYCLZ
EXTERN NETBUF,NETCNT,NETSTS,IMPPTR,PBPBYT,PBPBUF,PBFSIZ,RFNMB
EXTERN ERRB,NETDWN,NETHDN,NETCHK,HOSTN,NHOSTS,DISGT
EXTERN RECRST,NETBAL,NETEND,LHOSTN,RECINR,RECINS

DEFINE IMPOFF
<	SKIPN INSKED
	NOINT
	AOS IMPLCK>

DEFINE	IMPON
<	SOS IMPLCK
	SKIPN INSKED
	OKINT>

;STORAGE
;STORAGE IS ZEROED AT INIT TIME FROM IMPRDY TO IMPBFR

LS IMPRDY,1		;0=DOWN, 1=GOING DOWN, -1=UP
LS NETON,1		;0=NETWORK OFF
LS NETTCH,1		;STATE OF NET HAS CHANGED IF NON-0
LS IMPFRE,1		;LIST OF FREE BUFFERS
LS IMPNF,1		;COUNT OF FREE BUFFERS
LS IMPIBI,1		;INPUT BUFFERS IN (PI LEVEL) POINTER
LS IMPIBO,1		;INPUT BUFFERS OUT (8-LEVEL) POINTER
LS IMPOBI,1		;OUTPUT BUFFERS IN POINTER
LS IMPOBO,1		;OUTPUT BUFFERS OUT POINTER
LS IMPIB,1		;BUFFER NOW BEING FILLED BY PI ROUTINE
LS IMPOB,1		;BUFFER NOW BEING EMPTIED BY PI ROUTINE
LS IMPINP,1		;BLKI POINTER ON INPUT
LS IMPOUP,1		;BLKO POINTER
LS IMPSVX,1		;PI SERVICE RETURN
LS IMPCK1,1		;TIME AT WHICH TO STOP 8-LEVEL PROCESSING
LS NETTIM,1		;TIME OF NEXT CHECK OF FSM FOR HANGS
LS IMPTIM,1		;TIME OF NEXT CHECK OF DEAD HOSTS
LS RFNTIM,1		;TIME OF NEXT CHECK FOR LOST RFNM'S
LS LSTHDR,1		;HEADER WORD OF MSG CURRENTLY GOING OUT PI LVL

LS IMPSTK,IMPNPD	;STACK FOR 8-LEVEL ROUTINE
LS IMPAC,17		;AC STORAGE ...
LS IMPSP,1		;STACK POINTER STORAGE ...
LS IMPAP,1		;SAVED ACP WHILE IN 8-LEVEL

LS IMP8BC,1		;BYTE COUNT ...
LS IMP8BS,1		;BYTE SIZE INDEX
LS IMPIML,1		;LIST OF BUFFERS FOR CURRENT INPUT MESSAGE

LS IMPLTB,IMPNLK	;CONNECTION TABLE
LS TTNETX,NLINES-NTTYS		;STUFF FOR PSEUDO (NETWORK) TTYS
TTNETW=TTNETX-NTTYS		;RELATIVE TO 0

LS IMP8CB,N8CB		;CONTROL MESSAGE BUFFER
LS IMPCBC,1		;CONTROL MESSAGE BYTE COUNT
LS IMP8CI,1		;INPUT BYTE POINTER FOR CTRL MES RING BFR
LS IMP8CO,1		;OUTPUT .. ..
LS IMPCHO,1		;HOST NUMBER OF CONTROL MESS, MUST PRECEDE I8CAL
LS I8CAL,5		;ARGS OF CONTROL OPERATION, MUST FOLLOW IMPCHO
LS IMPFLS,1		;COUNT (NEG) OF MESSAGES TO FLUSH
LS IMPE1C,1		;COUNT OF TYPE 1 ERRORS
LS IMPLCK,1		;LOCK ON INCOMING CONTROL MESSAGES
LS IMPCCH,1		;INDEX TO HOST NUMBER FOR PERIODIC CHECK
LS SNDERR,1		;HEADER WORD OF OUTGOING MSG WHICH GOT IMP ERR

LS IMPCMI,1		;CONTROL QUEUE IN
LS IMPCMO,1		; .. OUT
LS IMPCMC,1		; .. COUNT
LS IMPCMB,IMPCMS	; .. BUFFER

LS IMP8XI,1		;IRREG MES BUFFER IN PTR
LS IMP8XO,1		; .. .. OUT
LS IMP8XC,1		; .. .. COUNT
LS IMP8XB,IMP8XS	;IRREG MES BUFFER

LS IMPCLT,IMPLBT	;RFNM BITS FOR ALL CONTROL LINKS
LS IMPHRT,IMPLBT	;HOST READY BITS
LS IMPRF2,IMPLBT	;RFNM OVERDUE BITS

LS IMPBFR,IMPBFF*IMPNBF		;BUFFERS

LS IMPBGC,1		;IMPBUG COUNT
LS IMPBGL,1		;IMPBUG LOCATION

;PI DISPATCH

IMPSV:	XWD IMPSVX,.+1
	CONI IMP,1
	TRNN 1,7		;INPUT TURNED OFF?
	JRST IMPSV1		;YES
	TRNE 1,IMPINB
	JRST IMPIN		;WORD IN
	TRNE 1,IMPEIB
	JRST IMPEIN		;END INPUT MESSAGE
IMPSV1:	TRNE 1,IMPOUB
	JRST IMPOUT		;WORD OUT
	JRST @IMPSVX		;N.O.T.A

IMPSP0:	IOWD IMPNPD,IMPSTK	;INITIAL STACK POINTER

;CALLED BY PERIODIC CHECK ROUTINE IF NETTCH NON-0

	SWAPCD

CHKNET:	SKIPE IMPBGL	;IMPBUG LATELY?
	JRST CHKN1	;YES
	HRROI 1,[ASCIZ /
***** NETWORK /]
	PSOUT
	HRROI 1,[ASCIZ /ON/]
	SKIPN NETON
	HRROI 1,[ASCIZ /OFF/]
	PSOUT
	HRROI 1,[ASCIZ /, IMP /]
	PSOUT
	HRROI 1,[ASCIZ /ON/]
	SKIPL IMPRDY
	HRROI 1,[ASCIZ /OFF/]
	PSOUT
	MOVEI 1," "
	PBOUT
	CONI IMP,2
	SETZM NETTCH
	JRST CHKH1		;GO PRINT CONI WORD AND TOD

CHKN1:	HRROI 1,[ASCIZ /
***IMPBUG /]
	PSOUT
	MOVEI 1,101
	MOVEI 3,^D10
	MOVE 2,IMPBGC
	NOUT
	JFCL
	HRROI 1,[ASCIZ / AT /]
	PSOUT
	HRRZ 2,IMPBGL
	SETZM IMPBGL
	JRST CHKH1

	RESCD

;'CHANNEL-8' PROCESS, RUN PERIODICALLY BY SCHEDULER

IMPCHK:	SKIPN NETON		;NETWORK TURNED OFF?
	JRST IMPNOF		;YES
	CONI IMP,1
	TRNE 1,1B19		;INTERFACE POWER STILL ON? AND
	TRNE 1,1B22		;IMP STILL UP?
	JRST IMPNOF		;NO, BEGIN OR CONTINUE CLEANUP
	MOVN 1,IMPRDY
	CAIE 1,1		;IMP IN NORMAL OPERATION?
	JRST IMPNRD		;NO
IMP84:	MOVE 1,TODCLK		;GET NOW
	ADDI 1,2		;2 MS. FROM NOW
	MOVEM 1,IMPCK1		;WHEN TO STOP, EVEN IF NOT FINISHED
IMP80:	MOVE 1,TODCLK
	CAML 1,IMPCK1		;OUT OF TIME?
	RET			;YES, RETURN TO SCHED
	PUSH P,[IMP80]		;RETURN FOR FOLLOWING ROUTINE(S)
	SKIPE IMPIBO		;INPUT READY?
	JRST IMP8IN		;YES, DISTRIBUTE IT
	CAML 1,RFNTIM		;TIME TO CHECK OVERDUE RFNM'S?
	JRST IMPCC1		;YES
IMP82:	MOVEM 0,0(P)		;SAVE SCHEDULER CONTEXT
	MOVEM P,IMPAP
	MOVSI 14,IMPAC		;LOAD IMP OUTPUT CONTEXT
	BLT 14,14
	SETZ P,
	EXCH P,IMPSP		;GET STACK FOR OUTPUT CONTEXT
	JUMPN P,R		;RETURN TO IT
	BUG(HLT,<IMPCHK - NO STACK, POSSIBLE RECURSIVE ENTRY>)

IMP81:	PUSH P,[IMP81]		;RETURN FOR FOLLOWING ROUTINES
	MOVE 1,TODCLK
	CAML 1,IMPCK1		;OUT OF TIME?
	JRST IMP8QT		;YES
	SKIPE IMPCMC		;CONTROL COMMANDS TO SEND?
	JRST IMPCMM		;YES
	SKIPE IMPLCK		;NCP LOCKED?
	JRST IMP83		;YES
	SKIPE IMP8XC		;IRREG MESS FOR PROCESSING?
	JRST IMP8XM		;YES
	SKIPE IMPCBC		;CONTROL MESSAGE TO BE PROCESSED?
	JRST IMP8CT		;YES
	CAML 1,NETTIM		;TIME FOR FSM OVERDUE CHECKS?
	JRST NETCHK		;YES
IMP83:	CAML 1,IMPTIM		;TIME FOR IMP OVERDUE CHECKS?
	JRST NETCH0		;YES
IMP8QT:	SKIPN IMPSP		;NOT NOW IN OUTPUT CONTEXT? OR
	SKIPN INSKED		;NOT UNDER SCHED?
	BUG(HLT,<IMP8QT CALLED WHILE NOT IN SCHED OR NOT IN IMP CONTEXT>)
	MOVEM P,IMPSP		;SAVE IMP CONTEXT AND RETURN TO SCHED
	MOVEI P,IMPAC		;SAVE ACS
	BLT P,IMPAC+14
	MOVE P,IMPAP		;RESTORE SCHED STACK
	POP P,0
	RET			;RETURN TO SCHED

;SEND RST TO ALL HOSTS ON STARTUP

NETCH0:	MOVEI 1,LHOSTN		;LOCAL HOST NUMBER
	IDIVI 1,^D36
	MOVE 2,BITS(2)
	TDNE 2,IMPHRT(1)	;DOES SUBNET THINK WE ARE UP?
	JRST IMPCC5		;YES, GO SEND RST TO ALL OTHER HOSTS
	ANDCAM 2,IMPCLT(1)	;DON'T WAIT FOR RFNM'S
	MOVEI 1,LHOSTN
	CALL IMPRRP		;SEND RRP TO OURSELF
	MOVEI 1,^D1000		;TRY AGAIN IN A SECOND
	JRST IMPCC6

IMPCC5:	SKIPE 7,IMPCCH		;CHECKING HOSTS?
	JRST IMPCC4		;YES
	MOVSI 7,-400		;SCAN ALL POSSIBLE HOST NUMBERS
IMPCC2:	MOVEI 1,0(7)
	IDIVI 1,^D36
	MOVE 2,BITS(2)
	ANDCAM 2,IMPCLT(1)	;CLEAR RFNM WAIT IF ANY
	MOVEI 1,0(7)		;GET NEXT HOST NUMBER
	CALL IMSRST		;SEND RST, SHOULD RECEIVE RRP
	MOVEM 7,IMPCCH		;OR RST IF/WHEN HOST IS UP
	MOVEI 1,^D15		;WAIT 15MS BEFORE CHECKING NEXT HOST
IMPCC6:	ADD 1,TODCLK		;TO AVOID CLOGGING CHANNELS
	MOVEM 1,IMPTIM
	RET

IMPCC4:	AOBJN 7,IMPCC2
	SETZM IMPCCH		;START WITH 0 NEXT TIME
	MOVSI 1,(1B1)		;SET NEXT TIME TO INFINITY
	MOVEM 1,IMPTIM
	SETZM NETTIM		;GET OTHER CHECKS GOING
	SETZM RFNTIM
	RET

;PERIODIC CHECK FOR LOST RFNM'S

IMPCC1:	MOVSI 3,-IMPLBT		;CHECK OVERDUE RFNM TABLE
	MOVE 1,IMPRF2(3)
	JFFO 1,[MOVE 1,BITS(2)	;CONTROL RFNM STILL OUTSTANDING FROM
		ANDCAM 1,IMPCLT(3) ;LAST TIME, CLEAR IT
		ANDCAM 1,IMPRF2(3) ;AND OVERDUE BIT
		JRST IMPCC1]
	AOBJN 3,.-2
	MOVE 1,[XWD IMPCLT,IMPRF2]
	BLT 1,IMPRF2+IMPLBT-1	;REMEMBER CURRENT RFNM TABLE
	MOVE 1,TODCLK
	ADDI 1,^D30000		;CHECK AGAIN IN 30 SEC
	MOVEM 1,RFNTIM
	RET

;EMPTY INPUT BUFFERS
;COPY TO APPROPRIATE DESTINATION, REFORMATTING AS NECESSARY

IMP8IN:	CALL IMP8G		;GET BUFFERS IN MESSAGE
	JRST IMP82		;NOT ALL READY YET
	SKIPE IMPRDY		;IMP READY?
	AOSG IMPFLS		;HAVE WE FLUSHED FIRST FEW MESSAGES?
	JRST IMP8FM		;NO, FLUSH THIS ONE
	MOVE 2,1(1)		;FIRST WORD CONTAINS HEADER
	TLNE 2,(1B1+17B7)	;FROM IMP OR IRREG MESS?
	JRST IMP8IM		;YES, E.G. RFNM
	LDB 3,[POINT 16,2(1),27] ;BYTE COUNT FIELD FROM SENDER
	MOVEM 3,IMP8BC
	LDB 3,[POINT 8,2(1),11]	;BYTE SIZE
	MOVSI 4,-NIBTSZ		;SETUP TO SCAN BYTE SIZE TABLE
	CAMN 3,IMBTSZ(4)
	JRST IMP8N1
	AOBJN 4,.-2
	CALL IMPBUG		;DON'T KNOW HOW TO HANDLE THIS BYTE SIZE
	JRST IMP8FM

IMP8N1:	HRRZM 4,IMP8BS		;SAVE TABLE INDEX
	LDB 3,[POINT 8,2,23]	;REG MESS, GET LINK NUMBER
	CAIN 3,CLINK		;CONTROL LINK?
	JRST IMP8IC		;YES, GO COPY TO CONTROL BUFFER
	LSH 2,-^D12
	ANDI 2,177777		;GET SOURCE HOST AND LINK
	MOVSI 3,-IMPNLK		;TRY TO FIND CONNECTION IN TABLE
	HRRZ 4,IMPLTB(3)
	CAIN 4,0(2)		;FOUND MATCHING ENTRY?
	JRST IMPRMS		;YES
	AOBJN 3,.-3		;NO
	CALL IMPBUG
IMP8FM:	CALL IMP8RB		;RELEASE BUFFER
	SKIPN IMPIML		;MORE BUFFERS?
	RET			;NO, DONE
	CALL IMP8GB		;GET NEXT BUFFER
	JRST IMP8FM		;AND FLUSH IT TOO

;SOME FLAVOR OF ERROR - FLUSH MESSAGE
;CALLED BY JSP 4,IMP8IB

IMP8IB:	CALL IMPBUG
	JRST IMP8FM		;FLUSH BUFFERS

;FROM IMP OR IRREG MESS

IMP8IM:	TLNE 2,(1B1)		;FROM IMP?
	JSP 4,IMP8IB		;YES, IGNORE
	MOVE 3,2
	XOR 3,[5B7+<CLINK>B23]	;COMPARE WITH RFNM, CONTROL LINK
	TDNN 3,[377B7+377B23]	;IS IT?
	JRST [	LSH 2,-^D20	;YES, GET HOST
		ANDI 2,377
		IDIVI 2,^D36
		MOVE 4,BITS(3)
		ANDCAM 4,IMPCLT(2) ;CLEAR RFNM AWAITED
		ANDCAM 4,IMPRF2(2)
		JRST IMP8FM]
	CALL IMP8XQ		;QUEUE THE MSG
	JRST IMP8FM

;QUEUE IRREG MSG OR SPECIAL ACTION

IMP8XQ:	AOS 3,IMP8XI		;INCREMENT INPUT INDEX
	CAIL 3,IMP8XS
	SETZB 3,IMP8XI		;WRAPAROUND
	MOVEM 2,IMP8XB(3)
	AOS IMP8XC
	RET

IMP8XM:	AOS 3,IMP8XO		;RETRIEVE STUFF FROM QUEUE
	CAIL 3,IMP8XS
	SETZB 3,IMP8XO		;WRAPAROUND
	MOVE 2,IMP8XB(3)
	SOS IMP8XC
	JUMPL 2,[HLRZ 1,2	;SPECIAL FUNCTION, GET DATA FROM LH
		ANDCMI 1,400000	;FLUSH BIT
		JRST 0(2)]
	LDB 3,[POINT 4,2,7]	;MESSAGE TYPE CODE
	LDB 2,[POINT 16,2,23]	;HOST-LINK
	XCT IMPMTT(3)		;DISPATCH TO APPROPRIATE ROUTINE
	RET

XX==CALL IMPBUG		;UNIMPLEMENTED CODE, IGNORE

IMPMTT:	BUG(HLT,<IMP - REGULAR MESSAGE ON IRREG QUEUE>)
	JRST IMPEC1		;ERROR
	JRST IMPDN2		;IMP GOING DOWN
	XX			;BLOCKED LINK
	JFCL			;NOP
	JRST IMRFNM		;RFNM
	XX			;LINK TABLE FULL
	JRST IMPDD1		;DESTINATION DEAD
	JRST IMRFNM		;ERROR
	JRST IMRFNM		;INCOMPLETE TRANSMISSION
	XX			;CEASE ON LINK
	XX			;CEASE TIMEOUT
	XX			;CEASE SENT
	XX			;UNASSIGNED
	XX			; "
	XX			; "

;UNPACK CONTROL MESSAGE AND PLACE IN CONTROL BUFFER

IMP8IC:	LDB 3,[POINT 8,2,15]	;HOST NUMBER
	PUSH P,1
	PUSH P,3
	MOVEI 1,377
	CALL IMPCN1		;PUT HOST MARK INDICATOR IN STREAM
	POP P,1
	CALL IMPCN1		;PUT HOST NUMBER ...
	MOVE 3,IMP8BS		;BYTE SIZE INDEX
	MOVEI 4,^D8		;BYTE SIZE OF CONTROL MESSAGES
	CAME 4,IMBTSZ(3)	;OK?
	JSP 4,[	POP P,1		;NO, FLUSH
		JRST IMP8IB]
	HRRZ 4,0(P)		;SETUP AOBJN PTR TO BUFFER
	ADD 4,[XWD -<IMPBFS-1>,2]
	SETZ 6,			;INIT UNPACKING INDEX
IMP8C1:	XCT IMBTRA(3)		;GET BYTE FROM IMP BUFFER
	CALL IMPCN1		;PUT IT INTO CTRL BUFFER
	SOSLE IMP8BC		;COUNT BYTES
	AOJA 6,IMP8C1
IMPUP2:	POP P,1
	JUMPN 1,IMP8FM		;RELEASE REMAINING BUFFERS
	RET			;NONE

;PUT 8-BIT BYTE IN CONTROL STREAM

IMPCN1:	MOVE 2,IMP8CI
	CAME 2,[POINT 8,IMP8CB-1+N8CB,31] ;PTR AT END OF BUFFER
	JRST .+3		;NO
	HRRI 2,IMP8CB-1		;WRAPAROUND
	MOVEM 2,IMP8CI
	IDPB 1,IMP8CI
	AOS 2,IMPCBC		;COUNT CHARS IN CTRL BUFFER
	CAIGE 2,N8CB*4		;TOO MANY?
	RET
	CALL IMPBUG
	SETZM IMPCBC
	RET

;UNPACK AND DISTRIBUTE REGULAR MESSAGE

IMPRMS:	HLRZ IMPUN,IMPLTB(3)	;GET UNIT INDEX
	MOVSI 3,EOTF
	TDNE 3,NETSTS(IMPUN)	;THIS CONNECTION NOW CLOSED?
	JRST IMP8FM		;YES, FLUSH INPUT
	MOVE 3,IMP8BS		;AND BYTE SIZE INDEX
	LDB 4,PBPBYT		;BYTE SIZE OF CONNECTION
	CAME 4,IMBTSZ(3)	;THIS MESSAGE AGREES?
	JSP 4,IMP8IB		;NO
	HRRZ 4,NETSTS(IMPUN)	;CURRENT MSG ALLOC
	CAIG 4,0
	JSP 4,IMP8IB		;SENDER SCREWED UP
	SOS NETSTS(IMPUN)
	LDB 2,PPTY
	CAIL 2,NTTYS		;PTY CONNECTION?
	CAIL 2,NLINES
	JRST IMPRM1		;NO, SETUP FOR REGULAR BYTES
	MOVEI 7,IMP8TI		;ROUTINE TO DISTRIBUTE PTY CHARS
IMPUP0:	MOVEI 4,2(1)		;SETUP BUFFER PTR
	HRLI 4,-<IMPBFS-1>	;SKIPPING SIZE AND COUNT FIELDS
	PUSH P,1
	SETZ 6,			;INIT UNPACKING STATE COUNTER
IMPUP1:	XCT IMBTRA(3)		;GET BYTE INTO 1
	CALL 0(7)		;CALL ROUTINE TO STORE BYTE
	SOSLE IMP8BC		;COUNT BYTES
	AOJA 6,IMPUP1
	HRRZ 2,NETSTS(IMPUN)	;CHECK MSG ALLOC NOW OUT
	CAIL 2,5		;RUNNING LOW?
	JRST IMPUP2		;NO, GO RELEASE REMAINING BUFFERS
	MOVSI 2,0(IMPUN)	;YES, QUEUE ALLOC
	HRRI 2,IMP8SA
	CALL IMPCMQ
	JRST IMPUP2		;GO RELEASE REMAINING BUFFERS

IMP8SA:	MOVEI IMPUN,0(1)
	LDB 1,PFHST
	LDB 2,PLINK
	MOVEI 3,^D20		;ALLOC 20 MSGS
	HRRZ 4,NETSTS(IMPUN)
	SUB 3,4			;LESS ANY NOW OUT
	SETZ 4,			;ALLOCATE NO BITS
	JRST IMPALL		;SEND ALLOCATION

IMPRM1:	MOVN 4,IMP8BC		;BYTE COUNT THIS MESSAGE
	IMUL 4,IMBTSZ(3)	;BITS THIS MESSAGE
	ADDB 4,NETBAL(IMPUN)	;REDUCE OUTSTANDING ALLOC
	CAIGE 4,0
	JSP 4,IMP8IB		;SENDER SCREWED UP
	MOVEI 7,IMPRM2		;ROUTINE TO DISPATCH BYTES
	JRST IMPUP0

;DISTRIBUTE REG BYTE

IMPRM2:	MOVE 2,IMPPTR(IMPUN)
	CAME 2,NETEND(IMPUN)	;END OF BUFFER?
	JRST .+3		;NO
	HRR 2,NETBUF(IMPUN)	;WRAP POINTER
	MOVEM 2,IMPPTR(IMPUN)
	IDPB 1,IMPPTR(IMPUN)	;STORE BYTE
	AOS NETCNT(IMPUN)
	RET

;DISTRIBUTE PTY BYTE

IMP8TI:	MOVE 2,TTBSIZ-40
	CAMG 2,TTBIGC		;BIG BUFFER TOO FULL?
	RET			;YES, FLUSH CHAR
	LDB 2,PPTY		;GET LINE NUMBER
	HRLI 1,1B19(2)		;CONSTRUCT SCANNER INPUT WORD
	IORI 1,DLSRCF		;WITH RECEIVER FLAG
	PIOFF
	AOS 2,TTBIGI		;PUT WORD IN BIG BUFFER
	CAIN 2,TTBSIZ
	SETZB 2,TTBIGI
	MOVEM 1,TTBBUF(2)
	AOS TTBIGC
	PION
	RET

;BYTE UNPACKING TABLES

IMBTSZ:	^D8
	^D32
	^D36
NIBTSZ==.-IMBTSZ

IMBTRA:	XCT IMBT08(6)		;8 BIT
	CALL IMBT32		;32 BIT
	CALL IMBT3A		;36 BIT

;36-BIT UNPACKING ROUTINE

IMBT3A:	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	MOVE 1,0(4)		;GET WORD
	RET

;8-BIT UNPACKING TABLES - 9 BYTES PER 2 WORDS

IMBT08:	CALL IMBT80
	LDB 1,[POINT 8,0(4),15]
	LDB 1,[POINT 8,0(4),23]
	LDB 1,[POINT 8,0(4),31]
	CALL IMBT81
	LDB 1,[POINT 8,0(4),11]
	LDB 1,[POINT 8,0(4),19]
	LDB 1,[POINT 8,0(4),27]
	CALL IMBT82

IMBT80:	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	LDB 1,[POINT 8,0(4),7]
	RET

IMBT81:	MOVE 1,0(4)
	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	HLL 1,0(4)
	ROT 1,4
	ANDI 1,377
	RET

IMBT82:	LDB 1,[POINT 8,0(4),35]
	SETO 6,
	RET

;32 BIT ROUTINE

IMBT32:	CAIN 6,^D8		;LAST BYTE IN CYCLE?
	JRST [	MOVE 1,0(4)	;YES, IS RIGHT JUSTIFIED IN WORD
		SETO 6,
		JRST IMBT3C]
	MOVE 2,0(4)		;GET FIRST PART OF BYTE
	HRRE 1,IMBT3B(6)	;GET SHIFT N
	ADDI 1,^D36		;DERIVE 36-N
	LSH 2,0(1)		;ALIGN FIRST PART OF BYTE
	AOBJN 4,.+2		;INDEX BUFFER
	CALL IMBTXB		;GET NEW BUFFER
	MOVE 1,0(4)		;GET SECOND PART OF BYTE
	LSH 1,@IMBT3B(6)	;ALIGN IT
	IOR 1,2			;COMBINE PARTS
IMBT3C:	TLZ 1,(-1B3)		;FLUSH EXTRA BITS
	RET

	DEFINE FO (Y)
	<XWD 0,-^D'Y>

IMBT3B:	FO 4
	FO 8
	FO 12
	FO 16
	FO 20
	FO 24
	FO 28
	FO 32

;GET NEW BUFFER, FLUSH OLD ONE

IMBTXB:	EXCH 1,-2(P)		;GET CURRENT BUFFER ADR
	CALL IMP8RB		;RELEASE IT
	SKIPN IMPIML		;ANOTHER BUFFER?
	JRST IMBTXX		;NO, SENDERS BYTE COUNT WRONG
	CALL IMP8GB		;GET NEW BUFFER
	MOVEI 4,1(1)		;FIRST DATA WORD IN BUFFER
	HRLI 4,-IMPBFS		;NUMBER OF DATA WORDS
	EXCH 1,-2(P)
	RET

;RAN OUT OF BUFFERS BEFORE BYTE COUNT EXHAUSTED

IMBTXX:	CALL IMPBUG
	SETZB 4,IMP8BC		;CLEAR BYTE COUNT AND BFR WORD COUNT
	SETZM -2(P)		;NOTE NO BUFFER TO BE RELEASED
	SUB P,BHC+1
	RET			;RETURN AND QUIT

;GET NEXT BUFFER FROM INPUT LIST
;COMPUTE NUMBER OF WORDS AND NUMBER OF BITS IN BUFFER

IMP8G:	MOVE 3,IMPIML		;GET BUFFERS ALREADY SCANNED
IMP8G5:	PIOFF
	SKIPN 1,IMPIBO		;BUFFER ON LIST?
	JRST [	PION		;NO
		MOVEM 3,IMPIML	;SAVE BUFFERS SCANNED
		RET]		;RETURN NOSKIP MEANS BUFFERS NOT ALL IN
	HRRZ 1,0(1)		;UNQUEUE IT
	JUMPN 1,.+3
	MOVEI 2,IMPIBO
	MOVEM 2,IMPIBI
	EXCH 1,IMPIBO
	PION
	HLLZS 0(1)		;CLEAR CHAIN POINTER
	MOVSI 2,(1B1)
	TDNN 2,0(1)		;MORE BUFFERS TO COME?
	JRST IMP8G2		;NO
	JUMPN 3,.+2		;FIRST BUFFER?
	TLOA 3,0(1)		;YES, REMEMBER ADDRESS
	HRRM 1,0(3)		;ADD TO LIST
	HRRM 1,3		;UPDATE LAST POINTER
	JRST IMP8G5

IMP8G2:	JUMPN 3,.+2		;CONC LAST BUFFER
	TLOA 3,0(1)
	HRRM 1,0(3)
	HRRM 1,3
	HLRZM 3,IMPIML		;LIST OF BUFFERS IN THIS MESSAGE
	AOS 0(P)		;SKIP TO INDICATE ALL BUFFERS IN
	JRST IMP8GB		;NOW GET AND RETURN FIRST BUFFER

;GET NEXT BUFFER IN MESSAGE

IMP8GB:	PUSH P,2
	HRRZ 1,@IMPIML
	EXCH 1,IMPIML
	HLRZ 2,0(1)		;COUNT
	ANDI 2,777
	MOVNI 2,0(2)
	HRLI 1,0(2)
	POP P,2
	RET

;RELEASE BUFFER

IMP8RB:	MOVEI 1,0(1)
	PIOFF
	EXCH 1,IMPFRE		;RETURN BUFFER TO FREE LIST
	MOVEM 1,@IMPFRE
	AOS 1,IMPNF		;UPDATE COUNT
	CAIN 1,1		;WENT FROM 0 TO 1?
	CONO IMP,IMPION		;YES, RE-ENABLE INPUT
	PION
	RET

;PI SERVICE FOR INPUT REQUEST

IMPIN:	SKIPG IMPIB		;BUFFER SETUP?
	JRST IMPI1		;NO
	BLKI IMP,IMPINP		;INPUT THE WORD
	JRST .+2		;BUFFER FILLED
	UNBRK IMP

IMPEIN:	SKIPG 2,IMPIB		;BUFFER ADDRESS
	JRST IMPEI2		;NOT SET UP
	HRRM 2,@IMPIBI		;QUEUE IT FOR 8-LEVEL ROUTINE
	HRRZM 2,IMPIBI
	HLRE 3,IMPINP		;COUNT FROM BLKI
	ADDI 3,IMPBFS		;COMPUTE NUMBER OF WORDS
	TRNN 1,IMPEIB		;END INPUT?
	JRST IMPI1A		;NO, GO SETUP ANOTHER BUFFER
	HRLZM 3,0(2)		;STORE COUNT IN BUFFER
	SETZM IMPIB
IMPEI2:	CONO IMP,IMPGEB		;CLEAR PI REQ
	UNBRK IMP

IMPI1A:	IORI 3,(1B1)		;PUT ON CONTINUE BIT
	HRLZM 3,0(2)		;STORE IN BUFFER
IMPI1:	SOSGE IMPNF		;TRY TO GET ANOTHER BUFFER, ANY AVAIL?
	JRST [	AOS IMPNF	;NO, CORRECT COUNT
		SETOM IMPIB	;NOTE INPUTTING INTERRUPTED
		CONO IMP,IMPIOF	;NO, MAKE THE IMP SHUT UP
		JRST IMPUB]
	SKIPN 2,IMPFRE		;FREE BUFFER LIST
	BUG(HLT,<IMP INPUT - BUFFER LIST AND FREE COUNT INCONSISTENT>)
	HRRZ 3,0(2)		;GET ONE OFF FREE LIST
	EXCH 3,IMPFRE
	HRLI 3,-IMPBFS		;SETUP BLKI POINTER
	MOVEM 3,IMPINP
	HRRZM 2,IMPIB		;SAVE BUFFER ADDRESS
IMPUB:	UNBRK IMP

;PROCESS CONTROL MESSAGE NOW IN CONTROL BUFFER

IMP8CT:	CALL IMPIBP		;CHECK AND WRAP BYTE POINTER
	ILDB 1,IMP8CO		;FIRST BYTE IS OP CODE
	CAIN 1,377		;HOST MARKER?
	JRST [	CALL IMPIBP	;YES
		ILDB 1,IMP8CO	;GET HOST NUMBER
		MOVEM 1,IMPCHO	;AND LEAVE IT FOR FOLLOWING COMMANDS
		IDIVI 1,^D36	;COMPUTE INDEX TO BIT TABLES
		MOVE 3,BITS(2)
		IORM 3,IMPHRT(1) ;MARK HOST ALIVE
		JRST IMP8T5]
	CAIL 1,I8NCCM		;LEGAL CODE?
	JRST IMP8T4		;NO, FLUSH WHOLE MESSAGE
	MOVEI 3,I8CCM(1)	;ADDRESS OF TABLE ENTRY FOR THIS CODE
	HRLI 3,220300		;PNTR FOR 3-BIT BYTES SPECIFYING FIELDS
	MOVEI 4,I8CAL		;ARGS BUFFER
IMP8T1:	ILDB 5,3		;NUMBER OF (8-BIT) BYTES IN NEXT ARG
	SETZ 6,			;CLEAR WORD TO CONSTRUCT ARG
	JUMPN 5,IMP8T2		;0 MEANS NO MORE ARGS
	HLRZ 7,I8CCM(1)		;DISPATCH ADDRESS
	MOVE 6,[XWD IMPCHO,1]	;MOVE ARGS TO ACS 1-6
	BLT 6,6			;AC1 (IMPCHO) ALWAYS GETS HOST NUMBER
	CALL 0(7)		;DO FUNCTION
IMP8T5:	SKIPLE IMPCBC		;ANOTHER CONTROL FUNCTION?
	JRST IMP8CT		;YES
IMP8T4:	SETZM IMPCBC		;CLEAR COUNT
	MOVE 2,IMP8CI		;SYNC BYTE POINTERS
	MOVEM 2,IMP8CO
	RET

IMP8T2:	CALL IMPIBP
	ILDB 7,IMP8CO		;NEXT (8-BIT) BYTE OF ARG
	ROT 7,-^D8
	LSHC 6,^D8		;PACK INTO ARG WORD
	SOJG 5,IMP8T2		;ALL BYTES PACKED?
	MOVEM 6,0(4)		;YES, STORE ARG IN BUFFER
	AOJA 4,IMP8T1

IMPIBP:	SOSGE IMPCBC		;BYTE LEFT?
	JRST [	CALL IMPBUG	;NO, LOSSAGE
		POP P,1
		JRST IMP8T4]
	MOVE 2,IMP8CO
	CAME 2,[POINT 8,IMP8CB-1+N8CB,31] ;POINTER AT END OF BUFFER
	RET			;NO
	HRRI 2,IMP8CB-1		;WRAPAROUND
	MOVEM 2,IMP8CO
	RET

;CONTROL TABLE FOR CONTROL OPCODES

	DEFINE CTOP (A,C)
<	XWD IM8'A,C>

I8CCM:	CTOP NOP,0
	CTOP RTS,441000
	CTOP STR,441000
	CTOP CLS,440000
	CTOP ALL,124000

	CTOP GVB,111000
	CTOP RET,124000
	CTOP INR,100000
	CTOP INS,100000
	CTOP ECO,100000

	CTOP ERP,100000
	CTOP ERR,144200
	CTOP RST,0
	CTOP RRP,0
I8NCCM==.-I8CCM

;CONTROL ROUTINES

IM8NOP:	RET

IM8RTS=RECRTS
IM8STR=RECSTR
IM8CLS=RECCLS
IM8INR=RECINR
IM8INS=RECINS

IM8ALL:	LSH 1,^D8		;CONCAT HOST AND LINK
	IORI 1,1B18(2)		;BIT FOR SEND CONNECTION
	CALL LNKLUK		;LOOKUP IN CONNECT TABLE
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	HRRZ 2,NETSTS(IMPUN)	;GET CURRENT MSG ALLOC
	ADD 2,3
	CAILE 2,777777		;BIGGER THAN MAX?
	CALL IMPBUG
	HRRM 2,NETSTS(IMPUN)
	ADDB 4,NETBAL(IMPUN)	;UPDATE BIT ALLOCATION
	CAML 4,[1B3]		;EXCESSIVE?
	CALL IMPBUG
	LDB 2,PPTY
	CAIL 2,NTTYS		;PTY ATTACHED?
	CAIL 2,NLINES
	JRST IMPMO		;NO, TEST MORE OUTPUT FOR REG. CONNET'N
	JRST NETTCS		;YES

;RFNM, FROM IRREGULAR MESSAGE DISPATCH

IMRFNM:	MOVE 1,2		;HOST AND LINK
	ANDI 2,377		;LINK
	CAIN 2,CLINK		;CONTROL LINK?
	JRST IMRFN2		;YES, HANDLED AT PI LEVEL
	IORI 1,1B18		;DENOTE SEND CONNECTION
	CALL LNKLUK		;LOOKUP IN LINK TABLE
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	MOVSI 1,RFNMB
	ANDCAM 1,NETSTS(IMPUN)	;NOW NO MESSAGE OUTSTANDING
	MOVSI 1,ERRB
	CAIE 3,5		;REGULAR RFNM?
	IORM 1,NETSTS(IMPUN)	;NO, INDICATE ERROR
	LDB 2,PPTY
	CAIL 2,NTTYS
	CAIL 2,NLINES		;TTY?
	JRST [	CALL RCRFNM	;NO, ANNOUNCE RFNM TO FSM
		JRST IMPMO]	;MAYBE DO MORE OUTPUT
	JRST NETTCS		;MAYBE SEND MORE OUTPUT

IM8ECO:
IM8ERP:	RET

IM8ERR:	CALL IMPBUG		;SHOULDN'T GET THESE
	RET

IMRFN2:	CAIN 3,5		;REGULAR RFNM?
	RET			;YES, DONE
	LSH 1,-^D8		;NO, GET HOST
	ANDI 1,377
	IDIVI 1,^D36
	MOVE 4,BITS(2)
	ANDCAM 4,IMPCLT(1)	;CLEAR RFNM BITS
	ANDCAM 4,IMPRF2(1)
	RET

IM8GVB:	LSH 1,^D8		;GIVE BACK REQUESTED
	IORI 1,1B18(2)		;CONSTRUCT HOST-LINK FOR SEND SOCKET
	CALL LNKLUK
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	HRRZ 2,NETSTS(IMPUN)	;MSG ALLOC
	CAIL 3,200		;ALL?
	JRST .+3		;YES
	IMUL 2,3		;NO, CALC HOW MUCH
	IDIVI 2,200
	HRRZ 3,NETSTS(IMPUN)
	SUB 3,2			;REDUCE CURRENT MSG ALLOC
	HRRM 3,NETSTS(IMPUN)
	PUSH P,2
	MOVE 2,NETBAL(IMPUN)	;BIT ALLOCATION
	CAIL 4,200		;RETURN ALL?
	JRST .+3		;YES
	MUL 2,4			;NO, CALC HOW MUCH
	DIVI 2,200
	MOVN 3,2
	ADDM 3,NETBAL(IMPUN)	;REDUCE BIT ALLOC
	MOVE 4,2		;SETUP CALL FOR RET
	POP P,3
	LDB 2,PLINK
	LDB 1,PFHST
	CALL IMPRET		;SEND THE RET
	RET

IM8RET:	CALL IMPBUG
	JRST IMPALL		;WE NEVER DO GVB'S, SO ANY RET'S WE
				;RECEIVE WILL IMMED BE REALLOCATED

;GETS HERE BY JSP 2,

BADLUK:	CALL IMPBUG		;HOST-LINK NOT FOUND IN IMPLTB
	RET

;DESTINATION DEAD MESSAGE

IMPDD1:	LDB 3,[POINT 8,2,27]	;HOST NUMBER
	IDIVI 3,^D36
	MOVE 5,BITS(4)
	ANDCAM 5,IMPCLT(3)	;CLEAR RFNM'S FOR THAT HOST
	ANDCAM 5,IMPRF2(3)
	TDNN 5,IMPHRT(3)	;DID WE ALREADY KNOW HE WAS DOWN?
	RET			;YES
	ANDCAM 5,IMPHRT(3)	;NO, MARK HIM DOWN
	LDB 1,[POINT 8,2,27]	;HOST NUMBER
	CALL IMPXLT		;CLEAR LINK TABLE FOR DEAD HOST
	CALL NETHDN		;CLEAN UP ANY CONNECTIONS TO HOST
	RET

;RESET AND RESET-REPLY CTRL MSG

IM8RST:	PUSH P,1
	CALL IMPXLT		;CLEAR LINK TABLE FOR HOST
	CALL RECRST		;NOTIFY FSM
	POP P,1
IM8RRP:	IDIVI 1,^D36		;GET BIT FOR HOST TABLES
	MOVE 5,BITS(2)
	IORM 5,IMPHRT(1)	;MARK HOST ALIVE
	ANDCAM 5,IMPCLT(1)
	ANDCAM 5,IMPRF2(1)
	RET

;CLEAR LINK TABLE FOR PARTICULAR HOST

IMPXLT:	MOVSI 2,-IMPNLK
	LDB 3,[POINT 8,IMPLTB(2),27] ;HOST NUMBER FOR THIS LINK
	CAIN 1,0(3)		;SPECIFIED ONE?
	SETOM IMPLTB(2)		;YES, FLUSH IT
	AOBJN 2,.-3
	RET

;HOST-LINK LOOKUP

LNKLUK:	PUSH P,3
	PUSH P,4
	MOVSI 3,-IMPNLK
LNKL2:	HRRZ 4,IMPLTB(3)
	CAIN 4,0(1)
	JRST [	MOVEI 1,0(3)	;FOUND, RETURN INDEX TO TABLE
		AOS -2(P)	;SKIP RETURN
		JRST LNKL1]
	AOBJN 3,LNKL2		;RETURN NO-SKIP ON NOT FOUND
LNKL1:	POP P,4
	POP P,3
	RET

;ERRORS REPORTED BY IMP

IMPEC1:	AOSLE IMPE1C		;COUNT ERRORS
	BUG(CHK,<RECEIVED MESSAGE TYPE 1 FROM IMP - ERROR WITHOUT SPECIFICATION>)
	RET

;CALLS FROM NCP

;OPEN LINK, I.E. ASSOCIATE HOST-LINE AND UNIT

IMPOPL:	LSH 1,^D8
	IORI 1,0(2)		;CONCAT HOST AND LINK
	CALL LNKLUK		;NOW IN TABLE?
	JRST .+2		;NO, OK
	JSP 2,BADLUK
	MOVSI 3,-IMPNLK
	SKIPGE IMPLTB(3)	;FREE SLOT?
	JRST IMPOP1		;YES
	AOBJN 3,.-2
	JSP 2,BADLUK

IMPOP1:	MOVEM 1,IMPLTB(3)	;STORE HOST-LINK IN RH
	HRLM IMPUN,IMPLTB(3)	;UNIT IN LH
	RET

;CLOSE LINK, INVERSE OF ABOVE

IMPCLL:	LSH 1,^D8		;CONCAT HOST AND LINK
	IORI 1,0(2)
	CALL LNKLUK		;LOOKUP IN LINK TABLE
	JSP 2,BADLUK
	SETOM IMPLTB(1)		;CLEAR ENTRY
	RET

;RTS, STR, CLS, ALL

IMPNOP:	PUSH P,[XWD 0,0]	;NOP, NO ARGS
	JRST IMPSCM

IMPRTS:	PUSH P,[XWD 441000,1]	;ARG DESCRIPTOR,,OPCODE
	JRST IMPSCM		;CONSTRUCT MESSAGE AND OUTPUT

IMPSTR:	PUSH P,[XWD 441000,2]
	JRST IMPSCM

IMPCLS:	PUSH P,[XWD 440000,3]
	JRST IMPSCM

IMPALL:	CAIGE 3,0		;DON'T SEND NEG ALLOCS
	SETZ 3,
	CAIGE 4,0
	SETZ 4,
	ADDM 3,NETSTS(IMPUN)	;MAINTAIN COUNTS, MESSAGES
	ADDM 4,NETBAL(IMPUN)	;BITS
	PUSH P,[XWD 124000,4]
	JRST IMPSCM

IMPRET:	PUSH P,[XWD 124000,6]
	JRST IMPSCM

IMPINR:	PUSH P,[XWD 100000,^D7]
	JRST IMPSCM

IMPINS:	PUSH P,[XWD 100000,^D8]
	JRST IMPSCM

IMSRST:	PUSH P,[XWD 0,^D12]
	JRST IMPSCM

IMPRRP:	PUSH P,[XWD 0,^D13]
	JRST IMPSCM

;CONTROL MSG OUTPUT QUEUE ROUTINES

IMPCMQ:	AOS 3,IMPCMI
	CAIL 3,IMPCMS
	SETZB 3,IMPCMI		;WRAPAROUND
	MOVEM 2,IMPCMB(3)	; XWD DATA,ADDRESS
	AOS IMPCMC
	RET

IMPCMM:	AOS 3,IMPCMO
	CAIL 3,IMPCMS
	SETZB 3,IMPCMO
	MOVE 2,IMPCMB(3)
	SOS IMPCMC
	HLRZ 1,2		;ARBITRARY DATA
	JRST 0(2)

;SEND CONTROL MESSAGE
; 1/ DEST HOST
; 0(P) ARG DESCRIPTOR,,OPCODE

IMPSCM:	SKIPN IMPRDY		;IMP UP?
	JRST [	SUB P,BHC+1	;NO
		RET]
	EXCH 13,0(P)
	PUSH P,IMPUN
	PUSH P,6
	PUSH P,7
	PUSH P,10
	PUSH P,11
	PUSH P,12
	PUSH P,14
IMPSC7:	SKIPN INSKED		;AT 8-LEVEL? OR
	SKIPN IMPCMC		;CTRL CMND QUEUE EMPTY?
	JRST IMPSC8		;YES
	PUSH P,1
	MOVEI 1,IMPSFT
	JSYS EDISMS		;WAIT TIL CTRL MSG QUEUE EMPTY
	POP P,1
	JRST IMPSC7

IMPSC8:	MOVEI 10,0(1)		;HOST
	IDIVI 10,^D36		;COMPUTE INDEX TO RFNM BIT TABLE
	MOVE 14,BITS(11)
IMPSC5:	PIOFF
	TDNE 14,IMPCLT(10)	;MESSAGE NOW OUTSTANDING?
	JRST IMPSC6		;YES
	IORM 14,IMPCLT(10)	;NO, SET IT SO
	PION
	MOVEI 10,1(P)		;USE 3 WORDS ON STACK AS BUFFER
	ADD P,BHC+3
	HRLI 10,441000		;CONSTRUCT BYTE POINTER, 8-BITS
	PUSH P,10		;SAVE IT FOR LATER USE
	IDPB 13,10		;STORE OPCODE AS FIRST BYTE OF MESSAGE
	MOVEI 11,1		;INIT MESSAGE BYTE COUNT
	MOVEI 14,2		;INDEX TO ARGS
IMPSC4:	SETZ 12,
	LSHC 12,3		;NEXT ARG DESCRIPTOR BYTE
	JUMPN 12,IMPSC3		;0 MEANS DONE
	POP P,10		;RECOVER INITIAL BYTE PTR
	LSH 1,^D8
	MOVEI 2,CLINK(1)	;SPECIFIED HOST WITH CONTROL LINK
	MOVEI 1,IMPSC1		;ROUTINE TO SUPPLY BYTES
	MOVEI 3,^D8		;BYTE SIZE
	CALL IMPMSO		;OUTPUT MESSAGE
	SUB P,BHC+3
	POP P,14
	POP P,12
	POP P,11
	POP P,10
	POP P,7
	POP P,6
	POP P,IMPUN
	POP P,13
	RET

IMPSC3:	ADDI 11,0(12)		;ACCUMULATE BYTE COUNT OF MESSAGE
	MOVNI 6,0(12)		;COMPUTE NUMBER OF BITS TO LEFT OF ARG
	IMULI 6,^D8		;NUMBER BYTES TIMES BITS PER BYTE
	ADDI 6,^D36		;SUBTRACTED FROM SIZE OF WORD
	MOVE 7,0(14)		;GET NEXT ARG
	LSH 7,0(6)		;SHIFT OUT UNUSED BITS
	ROT 7,^D8		;SHIFT NEXT BYTE INTO PLACE
	IDPB 7,10		;STORE IT IN MESSAGE BUFFER
	SOJG 12,.-2		;FOR ALL BYTES
	AOJA 14,IMPSC4		;INDEX ARG POINTER

;RESCHEDULE BECAUSE CONTROL LINK TO SPECIFIED HOST CURRENTLY BUSY

IMPSC6:	PION
	SKIPE INSKED		;8 LEVEL?
	JRST [	CALL IMP8QT	;YES, QUIT
		JRST IMPSC5]	;THEN TRY AGAIN
	MOVSI 1,0(1)
	HRRI 1,IMPSCT
	JSYS EDISMS
	HLRZ 1,1
	JRST IMPSC5		;TRY AGAIN

IMPSCT:	IDIVI 1,^D36		;SCHEDULER TEST, GIVEN HOST NUMBER
	MOVE 3,BITS(2)
	TDNE 3,IMPCLT(1)	;STILL BUSY?
	JRST 0(4)		;YES
	JRST 1(4)

IMPSFT:	SKIPE IMPCMC
	JRST 0(4)
	JRST 1(4)

IMPSC1:	ILDB 1,10
	RET

;CALLED BY FILE ROUTINES TO START OUTPUT WHEN OUTPUT BUFFER
;BECOMES NON-EMPTY

IMPSRO:	MOVSI 2,400000(IMPUN)
	HRRI 2,IMPMOU
	NOSKED
	CALL IMP8XQ		;QUEUE REQUEST FOR 8-LEVEL ACTION
	OKSKED
	RET

;DO FILE OUTPUT IF CONDITIONS PERMIT

IMPMOU:	MOVEI IMPUN,0(1)
IMPMO:	SKIPG NETCNT(IMPUN)	;SOMETHING TO SEND?
	RET			;NO
	LDB 3,PBPBYT		;GET BYTE SIZE
	MOVSI 1,RFNMB
	MOVSI 2,EOTF
	TDNN 2,NETSTS(IMPUN)	;DO NOTHING IF NO LONGER OPEN
	TDNE 1,NETSTS(IMPUN)	;RFNM NOW OUTSTANDING?
	RET			;YES, WILL CHECK AGAIN WHEN IT ARRIVES
	IORM 1,NETSTS(IMPUN)
	HRRZ 4,NETSTS(IMPUN)	;MSG ALLOC
	JUMPLE 4,IMPMO1		;CAN SEND ONE MSG?
	MOVE 11,NETCNT(IMPUN)	;YES, GET NUMBER OF BYTES IN BUFFER
	MOVEI 4,0(11)
	IMUL 4,3		;NUMBER OF BITS IN BUFFER
	CAMG 4,NETBAL(IMPUN)	;CAN SEND ALL?
	JRST IMPMO2		;YES
	CAMLE 3,NETBAL(IMPUN)	;CAN SEND AT LEAST ONE?
	JRST IMPMO1		;NO
	MOVE 11,NETBAL(IMPUN)	;CURRENT BIT ALLOCATION
	IDIV 11,3		;GIVES MAX NUMBER OF BYTES TO SEND
IMPMO2:	MOVN 4,11
	ADDM 4,NETCNT(IMPUN)	;UPDATE FILE BUFFER COUNT
	IMUL 4,3
	ADDM 4,NETBAL(IMPUN)	;UPDATE AVAILABLE ALLOCATION
	SOS NETSTS(IMPUN)	;AND MSG ALLOCATION
	LDB 1,PFHST		;CONSTRUCT HEADER
	LSH 1,^D8
	LDB 2,PLINK
	IORI 2,0(1)
	MOVEI 1,IMPMOR		;ADR OF ROUTINE TO GET CHARS
	MOVE 10,IMPUN
	CALL IMPMSO		;DO OUTPUT
	MOVE IMPUN,10
	JRST IMPMO

;INSUFFICIENT ALLOCATION

IMPMO1:	MOVSI 1,RFNMB
	ANDCAM 1,NETSTS(IMPUN)	;CLEAR RFNM BIT
	RET			;WILL CHECK AGAIN WHEN ALLOC ARRIVES

;GET BYTE FROM FILE BUFFER

IMPMOR:	MOVE 1,IMPPTR(10)
	CAME 1,NETEND(10)	;AT END OF BUFFER?
	JRST .+3		;NO
	HRR 1,NETBUF(10)	;WRAPAROUND
	MOVEM 1,IMPPTR(10)
	ILDB 1,IMPPTR(10)
	RET

;IMP MESSAGE OUT
; 1/ ADDRESS OF ROUTINE TO SUPPLY CHARACTER
; 2/ HEADER, RIGHT JUSTIFIED. I.E. 13-15 BITS,
;     16-19 MESSAGE TYPE, 20-27 DESTINATION, 28-35 LINK
; 3/ BYTE SIZE
; 11/ BYTE COUNT
; CLOBBERS ACS 1-7

IMPMSO:	SKIPN IMPRDY
	RET			;DON'T SEND IF IMP OFF
	PUSH P,[0]		;SLOT ON PDL FOR BUFFER COUNT
	PUSH P,[0]		;PUSH A 0 FOR LIST POINTERS
	SETZB 6,7
	PUSH P,1		;SAVE FN ARG
	MOVE 4,11		;BYTE COUNT
	IMUL 4,3		;COMPUTE NUMBER OF BITS IN MESSAGE, PLUS
	ADDI 4,^D72+IMPBFS*^D36-1 ;HEADER, AND ROUND UP TO FULL BFR
	IDIVI 4,IMPBFS*^D36	;NUMBER OF BUFFERS NEEDED FOR MESSAGE
	MOVEM 4,-2(P)		;SAVE ESTIMATED BUFFER COUNT
IMPMS6:	MOVN 1,4
	PIOFF
	ADDB 1,IMPNF		;TRY TO GET ALL NEEDED BUFFERS
	JUMPL 1,IMPMS4		;SUCCESSFUL?
	PION			;YES
IMPMS2:	PIOFF
	SKIPN 4,IMPFRE		;GET A FREE BUFFER
	BUG(HLT,<IMP OUTPUT - BUFFER LIST AND FREE COUNT INCONSISTENT>)
	SOS -2(P)		;REDUCE BUFFER COUNT FOR THIS MESSAGE
	HRRZ 4,0(4)		;GET BUFFER FROM FREE LIST
	EXCH 4,IMPFRE
	PION
	MOVEM 4,-1(P)		;LAST BUFFER OF LIST
	HRLM 4,-1(P)		;FIRST BUFFER IN LIST
	HRLI 4,-IMPBFS		;INIT AOBJN PNTR
	SETZM 1(4)		;CLEAR COUNT AND SIZE WORDS
	SETZM 2(4)
	DPB 2,[POINT 24,1(4),23] ;HEADER
	DPB 3,[POINT 8,2(4),11]	;SIZE
	DPB 11,[POINT 16,2(4),27] ;COUNT
	MOVEI 2,0(3)		;SETUP TO FIND BYTE SIZE INDEX
	MOVSI 3,-NIBTSZ
	CAMN 2,IMBTSZ(3)
	JRST IMPMS7
	AOBJN 3,.-2
	CALL IMPBUG		;DON'T KNOW ABOUT THIS BYTE SIZE
	JRST IMPMS5

IMPMS7:	MOVEI 4,2(4)		;SETUP PTR FOR FIRST BUFFER
	HRLI 4,-<IMPBFS-1>
	SETZ 6,
IMPMS1:	SOJL 11,IMPMS3		;COUNT BYTES
	CALL @0(P)		;GET OUTGOING BYTE
	XCT IMOURA(3)		;PUT IT IN IMP BUFFER
	AOJA 6,IMPMS1

;NO MORE CHARS FROM SOURCE

IMPMS3:	HRRZ 1,-1(P)		;BUFFER ADDRESS
	HLRE 4,4		;COMPUTE NUMBER OF WORDS IN BUFFER
	ADDI 4,IMPBFS+1
	HRLZM 4,0(1)		;PUT IN BUFFER WITH NO CONT BIT
	HLRZ 2,-1(P)		;FIRST BUFFER OF CHAIN
	PIOFF
	HRRM 2,@IMPOBI		;ADD TO OUTPUT LIST
	HRRZM 1,IMPOBI
	PION
	SKIPN IMPOB		;OUTPUT NOW IN PROGRESS?
	JSP 4,IMPIOU		;NO, START IT
IMPMS5:	SUB P,BHC+2		;FLUSH STUFF FROM STACK
	POP P,4			;BUFFERS ASSIGNED BUT NOT USED
	ADDM 4,IMPNF		;CORRECT COUNT
	RET

IMPMS4:	ADDM 4,IMPNF		;RESTORE COUNT
	PION
	SKIPN INSKED		;IN IMP CONTEXT?
	JRST IMPMS8		;NO
	CALL IMP8QT		;TRY AGAIN LATER
	JRST IMPMS6

IMPMS8:	MOVEI 1,IMPMST
	HRLI 1,0(4)
	JSYS EDISMS		;DISMISS UNTIL ENOUGH BUFFERS
	JRST IMPMS6

IMPMST:	CAMLE 1,IMPNF
	JRST 0(4)
	JRST 1(4)

;PACKING ROUTINES AND TABLES

IMOURA:	XCT IMOU08(6)		;8-BIT
	CALL IMOU32
	CALL IMOU36

;36 BIT

IMOU36:	AOBJN 4,.+2		;COUNT WORDS
	CALL IMOUXB		;GET NEW BUFFER
	MOVEM 1,0(4)
	RET

;32 BIT

IMOU32:	CAIN 6,^D8		;LAST BYTE OF CYCLE?
	JRST [	DPB 1,[POINT 32,0(4),35] ;YES, STORE IT
		SETO 6,		;RESET CYCLE COUNTER
		RET]
	LSH 1,4			;LEFT JUSTIFY BYTE
	MOVE 5,IMOU2T(6)	;N FOR SHIFTING
	MOVNI 7,-^D36(5)	;36-N
	JUMPE 6,.+5		;FIRST OF CYCLE MEANS NO FIRST PART
	MOVE 2,0(4)		;GET PARTIAL WORD FROM BUFFER
	ROT 2,0(5)
	ROTC 1,0(7)		;SHIFT IN FIRST PART OF BYTE
	MOVEM 2,0(4)		;STORE COMPLETE WORD
	AOBJN 4,.+2		;GET NEXT WORD
	CALL IMOUXB		;NEW BUFFER
	MOVEM 1,0(4)		;STORE SECOND PART OF BYTE
	RET

IMOU2T:	DEC 36,32,28,24,20,16,12,8

;8-BIT TABLE

IMOU08:	CALL IMOU80
	DPB 1,[POINT 8,0(4),15]
	DPB 1,[POINT 8,0(4),23]
	DPB 1,[POINT 8,0(4),31]
	CALL IMOU81
	DPB 1,[POINT 8,0(4),11]
	DPB 1,[POINT 8,0(4),19]
	DPB 1,[POINT 8,0(4),27]
	CALL IMOU82

IMOU80:	AOBJN 4,.+2		;FIRST OF CYCLE, GET NEXT WORD
	CALL IMOUXB
	DPB 1,[POINT 8,0(4),7]
	RET

IMOU81:	ROT 1,-4
	DPB 1,[POINT 4,0(4),35]	;STORE FIRST PART OF BYTE
	AOBJN 4,.+2		;GET NEXT WORD
	CALL IMOUXB
	MOVEM 1,0(4)		;STORE SECOND PART LEFT JUSTIFIED
	RET

IMOU82:	DPB 1,[POINT 8,0(4),35]	;LAST BYTE OF CYCLE
	SETO 6,			;RESET CYCLE INDEX
	RET

;GET NEXT BUFFER FOR FILLING

IMOUXB:	PUSH P,1
	MOVE 1,-4(P)		;CURRENT BUFFER
	MOVEI 4,IMPBFS+1B19	;COUNT AND CONTINUE BIT
	HRLZM 4,0(1)
	PIOFF
	SKIPN 4,IMPFRE		;GET ANOTHER BUFFER
	BUG(HLT,<IMP OUTPUT - RAN OUT OF BUFFERS, SHOULD HAVE BEEN RESERVED>)
	HRRZ 4,0(4)
	EXCH 4,IMPFRE
	PION
	SOS -5(P)		;COUNT DOWN RESERVE
	HRRM 4,0(1)		;ADD BUFFER TO EXISTING CHAIN
	HRRM 4,-4(P)		;STORE NEW 'LAST' POINTER
	MOVEI 4,1(4)
	HRLI 4,-IMPBFS		;INIT AOBJN PTR
	POP P,1
	RET

;PI SERVICE FOR OUTPUT

IMPOUT:	SKIPL IMPOUP		;POINTER NOW SETUP?
	JRST IMPOUE		;NO
	BLKO IMP,IMPOUP		;OUTPUT A WORD
	HRRZS IMPOUP		;THAT WAS LAST WORD, MAKE PTR POSITIVE
	UNBRK IMP

IMPOUE:	SKIPGE IMPOB		;EOB ALREADY SENT FOR THIS BUFFER?
	JRST [	HRRZS 1,IMPOB	;NO, INDICATE DONE WITH BUFFER
		MOVSI 2,(1B1)
		TDNE 2,0(1)	;MORE BUFFERS IN MESSAGE?
		JRST IMPOU2	;YES, GO SETUP NEXT ONE
		CONO IMP,IMPEOB	;NO, ISSUE EOB
		CONSZ IMP,1B21	;ERROR DURING THIS MESSAGE?
		JRST IMPOER	;YES
		SETZM LSTHDR	;CLEAR SAVED HEADER
		JRST IMPUB]
IMPOU2:	JSP 4,IMPIOU		;SETUP NEXT BUFFER IF ANY
	UNBRK IMP

;ROUTINE TO SETUP BUFFER AND START OUTPUT
;CALLED AT MAIN AND PI LEVEL

IMPIOU:	SKIPG 1,IMPOB		;OLD BUFFER TO DISPOSE OF?
	JRST IMPOU1		;NO
	EXCH 1,IMPFRE		;PUT IT BACK ON FREE LIST
	MOVEM 1,@IMPFRE
	AOS 1,IMPNF		;UPDATE COUNT
	CAIN 1,1		;WAS FREE LIST EMPTY?
	CONO IMP,IMPION		;YES, RE-ENABLE INPUT IN CASE STOPPED
IMPOU1:	SKIPN 1,IMPOBO		;ANY OUTPUT WAITING?
	JRST [	CONO IMP,IMPSTO	;NO, SHUT OFF PI REQ
		SETZM IMPOB
		JRST 0(4)]
	HRRZ 1,0(1)		;GET BUFFER OFF QUEUE
	JUMPN 1,.+3
	MOVEI 2,IMPOBO
	MOVEM 2,IMPOBI
	EXCH 1,IMPOBO
	HRROM 1,IMPOB		;SAVE BUF ADR, NEG TO USE AS FLAG
	MOVE 2,1(1)		;FIRST DATA WORD IN BUFFER
	SKIPN LSTHDR		;DO WE HAVE SAVED HEADER?
	MOVEM 2,LSTHDR		;NO, THIS MUST BE IT
	HLRZ 2,0(1)		;GET COUNT
	ANDI 2,777		;FLUSH EXTRA BITS
	MOVNI 2,0(2)		;MAKE NEG FOR BLKO
	HRLI 1,0(2)		;CONSTRUCT BLKO WORD
	MOVEM 1,IMPOUP
	BLKO IMP,IMPOUP		;DO FIRST OUTPUT
	HRRZS IMPOUP		;IN CASE ONE WORD BUFFER
	JRST 0(4)

;ERROR BIT SET (IMP FLAPPED READY LINE)

IMPOER:	MOVE 2,LSTHDR		;HEADER OF MESSAGE IN ERROR
	MOVEM 2,SNDERR
	SETZM LSTHDR
	CONO IMP,1B19		;CLEAR ERROR STATUS
	JRST IMPUB

;NETWORK TTY LOGIC
;FOR CONNECTION DRIVEN VIA THE TTY SERVICE ROUTINES

;ASSIGN A PSEUDO (NETWORK) TTY
; 1/ RECEIVE UNIT
; 2/ SEND UNIT
; RETURNS 1/ LINE NUMBER

ASNPTY:	MOVEI 3,NTTYS		;PTY'S START AFTER SCANNER TTYS
	NOSKED
ASNPT1:	SKIPGE TTNETW(3)	;FREE?
	JRST ASNPT3		;YES
	CAIGE 3,NLINES-1	;LOOKED AT ALL PTY'S?
	AOJA 3,ASNPT1		;NO
	OKSKED			;YES,
	RET			;RETURN BAD

ASNPT3:	SETZM TTNETW(3)		;GRAB WORD AND INIT TO 0
	OKSKED
	EXCH 2,3
	DPB 1,PTNETI		;REMEBER UNITS
	DPB 3,PTNETO
	CALL TTCOBF
	CALL TTCIBF		;CLEAR BUFFERS
	MOVEI 1,0(2)		;RETURN LINE NUMBER
	AOS 0(P)		;RETURN GOOD
	RET

;CLOSE A FULL DUPLEX NET TTY CONNECTION

PTYDET:	PUSH P,2
	SKIPL TTFORK(2)		;LINE ATTACHED?
	CALL PTYCOF		;YES, INITIATE CARRIER OFF PSI
	MOVE 2,0(P)
	CALL TTCOBF
	CALL TTCIBF
	SKIPG TTNETW(2)		;REASONABLE UNITS?
	JRST PTYDT1		;NO
	LDB IMPUN,PTNETI	;INPUT UNIT
	CALL PTYCLZ		;CLOSE IT
	MOVE 2,0(P)
	LDB IMPUN,PTNETO	;OUTPUT UNIT
	CALL PTYCLZ		;CLOSE IT
PTYDT1:	POP P,2
	SETOM TTNETW(2)
	SETZM TTPSI(2)
	RET

PPTY:	POINT 18,NETBUF(IMPUN),35	;USED TO GET PTY LINE NUMBER

;CHECK STATE OF OUTPUT AND SEND IF POSSIBLE

NETTCS:	NOSKD1
	SKIPG TTNETW(2)		;CONNECTIONS ATTACHED?
	JRST NETTN		;NO, FLUSH OUTPUT
	SKIPE TTECT(2)		;STUFF TO SEND FROM ECHO BUFFER?
	JRST NETTE		;YES
	SKIPE TTOCT(2)		;STUFF TO SEND FROM REG BUFFER
	JRST NETTO		;YES
NETTN:	CHNOFF DLSCHN
	CALL TTRLOB		;RELEASE OUTPUT BUFFERS
	SETZM TTECT(2)
	SETZM TTOCT(2)		;BE SURE COUNT IN SYNC
	CHNON DLSCHN
	OKSKD1
	RET			;NOTHING TO DO

NETTE:	OKSKD1
	MOVE 11,TTECT(2)	;COUNT
	MOVEI 1,NETTEO		;ADDRESS OF CHAR ROUTINE
	JRST NETTC2

NETTO:	OKSKD1
	MOVE 11,TTOCT(2)
	MOVEI 1,NETTOO
				;FALLS INTO NETTC2

NETTC2:	PUSH P,6
	PUSH P,7
	PUSH P,10
	PUSH P,11
	PUSH P,1
	LDB IMPUN,PTNETO	;OUTPUT UNIT
	SKIPG IMPNF		;BUFFERS AVAIL?
	JRST NETTCX		;NO  *** THIS SHOULD BE IMPROVED ***
	PIOFF
	MOVSI 1,RFNMB
	TDNE 1,NETSTS(IMPUN)	;RFNM OUTSTANDING?
	JRST [	PION		;YES, CAN'T SEND NOW
		JRST NETTCX]
	IORM 1,NETSTS(IMPUN)
	PION
	HRRZ 3,NETSTS(IMPUN)
	MOVE 1,NETBAL(IMPUN)	;AVAILABLE BIT ALLOCATION
	CAIL 1,^D8		;AT LEAST ONE BYTE?
	CAIGE 3,1		;ALLOCATION FOR AT LEAST 1 MSG?
	JRST [	MOVSI 1,RFNMB	;NO, CAN'T SEND NOW
		ANDCAM 1,NETSTS(IMPUN) ;CLEAR BIT JUST SET
		JRST NETTCX]
NETTS1:	MOVEI 3,0(11)		;BYTE COUNT
	IMULI 3,^D8		;BITS TO BE SEND
	CAIGE 1,0(3)		;SUFFICIENT ALLOCATION?
	JRST [	MOVEI 3,0(1)	;NO, FIND HOW MANY BYTES CAN BE SENT
		IDIVI 3,^D8
		MOVEI 11,0(3)
		JRST NETTS1]	;AND SEND THAT MANY
	MOVNI 1,0(3)
	ADDM 1,NETBAL(IMPUN)	;UPDATE ALLOCATION FOR THIS MESSAGE
	SOS NETSTS(IMPUN)
	MOVEI 10,0(2)		;LINE NUMBER
	LDB 1,PFHST		;CONSTRUCT HEADER OF HOST AND
	LSH 1,^D8
	LDB 2,PLINK		;LINK
	IORI 2,0(1)
	MOVE 1,0(P)		;ROUTINE TO GET CHARS FOR OUTPUT
	MOVEI 3,^D8		;BYTE SIZE
	CALL IMPMSO		;SEND MESSAGE
	MOVEI 2,0(10)		;RESTORE LINE NUMBER
NETTCX:	POP P,1
	POP P,11
	POP P,10
	POP P,7
	POP P,6
	RET

;GET CHARS FOR OUTPUT FROM ECHO BUFFER

NETTOO:	SKIPN 1,TTOOUT(10)
	RET			;STUFF VANISHED, RETURN 0
	TDNN 1,WRPMSK
	HRR 1,1-TTSIZ(1)
	MOVEM 1,TTOOUT(10)
	ILDB 1,TTOOUT(10)
	SOS TTOCT(10)
	RET

;GET CHARS FOR OUTPUT FROM ECHO BUFFER

NETTEO:	SKIPN 1,TTEOUT(10)
	RET			;STUFF VANISHED, RETURN 0
	TDNN 1,WRPMSK
	HRR 1,1-TTSIZ(1)
	MOVEM 1,TTEOUT(10)
	ILDB 1,TTEOUT(10)
	SOS TTECT(10)
	RET

;CALLED FROM TCOUT

NTTCSO:	IMPOFF
	PUSH P,1
	PUSH P,4
	PUSH P,5
	CALL NETTCS
	POP P,5
	POP P,4
	POP P,1
	IMPON
	RET

;CALLED FROM TCI

NETCAP:	SKIPGE TTNETW(2)	;STILL CONNECTED?
	RET			;NO
	IMPOFF
	PUSH P,IMPUN
	PUSH P,2
	LDB IMPUN,PTNETI
	CALL NETTCA
	POP P,2
	POP P,IMPUN
	IMPON
	RET

;UPDATE ALLOCATION FOR CHAR RECEIVED INTO LINE BUFFER

NTTRC1:	TRZE 2,1B19		;IGNORE IF CHAR DID NOT COME FROM NET
	SKIPGE TTNETW(2)
	RET			;NOT ATTACHED
	PUSH P,IMPUN
	PUSH P,3
	LDB IMPUN,PTNETI
	MOVNI 3,^D8
	ADDB 3,NETBAL(IMPUN)	;UPDATE FOR CHAR RECEIVED
	JUMPGE 3,.+3		;CHECK FOR LOSSAGE BY SENDER
	CALL IMPBUG		;SENT TOO MUCH
	SETZM NETBAL(IMPUN)
	LDB 3,TTIMAX		;MAX CHARS IN INPUT BUFFER FOR LINE
	ASH 3,-1		;HALF THAT
	CAMG 3,NETBAL(IMPUN)	;ALLOCATION RUNNING LOW?
	JRST NTTRC2		;NO
	MOVSI 3,IMPTB1
	TDNE 3,TTNETW(2)	;REALLOC REQUEST NOW PENDING?
	JRST NTTRC2		;YES, DON'T SEND ANOTHER
	IORM 3,TTNETW(2)
	PUSH P,2		;YES, MUST REALLOCATE
	MOVSI 2,0(IMPUN)
	HRRI 2,NTTRC3
	CALL IMPCMQ		;QUEUE A CALL TO NETTCA
	POP P,2
NTTRC2:	POP P,3
	POP P,IMPUN
	RET

NTTRC3:	MOVEI IMPUN,0(1)
	LDB 2,PPTY
NETTCA:	MOVSI 3,IMPTB1
	ANDCAM 3,TTNETW(2)	;CLEAR REQUEST BIT
	LDB 3,TTIMAX		;CAPACITY OF LINE
	SUB 3,TTICT(2)		;GIVES SPACE NOW IN LINE BUFFER
	SKIPE TTPSI(2)		;INTERRUPTS ON THIS LINE?
	ADDI 3,1		;YES, ALWAYS ALLOW AT LEAST ONE CHAR
	IMULI 3,^D8
	CAIL 3,NTTMXA
	MOVEI 3,NTTMXA		;BUT NO LARGER THAN LIMIT
	SUB 3,NETBAL(IMPUN)	;DESIRED ALL LESS ALL NOW OUT
	JUMPLE 3,R		;MAY BE NONE TO SEND
	LDB 1,PFHST
	LDB 2,PLINK
	MOVE 4,3
	HRRZ 3,NETSTS(IMPUN)	;CURRENT MESSAGES ALLOCATED
	MOVN 3,3
	ADDI 3,^D20		;RAISE IT TO 20
	JRST IMPALL		;AND SEND IT

;IMP DOWN

IMPNOF:	SKIPE IMPRDY		;IMP COMPLETELY DOWN? OR
	SKIPE IMPLCK		;LOCK SET?
	RET			;YES, DO NOTHING
	MOVN 1,IMPRDY		;CURRENT IMP STATE
	CAIG 1,1		;NOTED DOWN ALREADY?
	JRST [	MOVEI 1,^D10000	;NO, SET DELAY OF 10 SECS
		ADD 1,TODCLK
		MOVNM 1,IMPRDY	;NEG, NOT -1 MEANS PROBABLE DOWN
		RET]
	CAML 1,TODCLK		;DELAY ELAPSED?
	RET			;NO
	SETZM IMPRDY		;YES, SAY IMP TOTALLY DOWN
	CALL NETDWN		;NOTIFY NCP
	CONO IMP,1B20+10B27+10B31+10 ;SET HOST DOWN, CLEAR ALL PI
	AOS NETTCH		;NOTE CHANGE OF IMP STATE
	RET

;IMP GOING DOWN MESSAGE

IMPDN2:	MOVEI 1,^D30000		;30 SECONDS
	ADD 1,TODCLK		;PLUS NOW
	MOVEM 1,IMPRDY
	RET

;IMP UP, BUT NOT RECORDED AS SUCH

IMPNRD:	SKIPN SYSIFG		;SYSTEM INITIALIZED?
	JRST [	CONO IMP,1B19	;TURN ON OUR READY LINE
		RET]		;BUT DO NOTHING ELSE
	SKIPN 1,IMPRDY		;IMP COMPLETELY OFF?
	JRST IMPINI		;YES, INIT IMP TABLES
	JUMPL 1,.+2		;IF IMP WAS OFF, SET IT ON NOW, NO REINIT
	CAMG 1,TODCLK		;IMP GOING DOWN. FOR MORE THAN 30 SECS?
	SETOM IMPRDY		;YES, DEFINE IT BACK UP
	JRST IMP84

;BUG OR UNTREATED NET ERROR

IMPBUG:	AOS IMPBGC		;COUNT THEM
	EXCH 1,0(P)
	MOVEM 1,IMPBGL		;SAVE ITS LOCATION
	EXCH 1,0(P)
	RET

;INITIALIZATION, CALLED FROM FILINI

IMPINI:	SKIPE NETTCH		;DO NOTHING UNTIL CHANGE LOGGED
	RET			;YES
	CALL IMPGO		;FIRE UP IMP
	RET			;IMP DOWN, DEAD
	MOVE 1,[XWD IMPRDY,IMPRDY+1]
	SETZM -1(1)
	BLT 1,IMPBFR		;CLEAR STORAGE
	MOVEI 1,IMPIBO		;INIT BUFFER LISTS
	MOVEM 1,IMPIBI
	MOVEI 1,IMPOBO
	MOVEM 1,IMPOBI
	MOVE 1,[POINT 8,IMP8CB,-1]
	MOVEM 1,IMP8CI		;INIT CONTROL BUFFER RING PTRS
	MOVEM 1,IMP8CO
	MOVNI 1,2
	MOVEM 1,IMPFLS		;INIT FLUSH COUNT
	MOVNI 1,1
	MOVEM 1,IMPE1C		;IGNORE FIRST ERROR
	MOVEI 1,IMPBFR		;INIT LIST OF FREE BUFFERS
	SETZ 2,
IMPIL2:	MOVEM 2,0(1)
	MOVEI 2,0(1)
	ADDI 1,IMPBFF
	CAIGE 1,IMPBFR+IMPBFF*IMPNBF
	JRST IMPIL2
	MOVEM 2,IMPFRE
	MOVEI 1,IMPNBF
	MOVEM 1,IMPNF		;COUNT OF FREE BUFFERS
	MOVSI 1,-IMPNLK
	SETOM IMPLTB(1)		;MAKE ALL LINKS UNUSED
	AOBJN 1,.-1
	MOVSI 1,NTTYS-NLINES	;MINUS NUMBER NET LINES
	SETOM TTNETW+NTTYS(1)	;INIT ALL NET LINES TO FREE
	AOBJN 1,.-1
	MOVE 1,TODCLK
	ADDI 1,^D30000		;INIT CHECK ROUTINES TO START
	MOVEM 1,IMPTIM		;AFTER IMP STARTUP INTERVAL
	MOVSI 1,(1B1)
	MOVEM 1,NETTIM
	MOVEM 1,RFNTIM
	MOVE 1,IMPSP0		;INIT OUTPUT CONTEXT
	PUSH 1,[IMP81]
	MOVEM 1,IMPSP
IMPRS1:	CONO IMP,IMPION+IMPOON	;GIVE PI ASMTS
	SETOM IMPRDY		;NOTE IMP UP
	AOS NETTCH
	AOS NETON		;NET NOW ON
	RET

;RESTART

IMPRST:	CALL IMPGO
	JRST IMPNOF
	JRST IMPRS1

;DO INITIALIZING SEQUENCE FOR IMP

IMPGO:	CONSO IMP,1B22		;IMP UP? AND
	CONSO IMP,1B19		;INTERFACE POWER UP?
	RET			;NO, LEAVE NET OFF UNTIL OPER ACTION
	CONO IMP,1B19		;SET HOST READY LINE, CLEAR IMP ERROR
	AOS NETTCH		; CAUSE CHANGE IN STATE TO BE NOTED
	SETZM NETON		; NET WILL BE OFF IF FOLLOWING FAILS
	DATAI IMP,1		;HELPS TO CLEAR INTERFACE
	CONO IMP,IMPSTO+IMPGEB
	AOS 0(P)
	RET

	SWAPCD
>		;END OF IFDEF IMPCHN ON PAGE 1
