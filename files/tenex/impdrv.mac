
;13 OCT 71, 2213:
;IMP DRIVER - D. MURPHY

IFDEF IMPCHN,<	;THIS WHOLE FILE IS INCLUDED ONLY IF IMP EXISTS

;PARAMETERS

	RESCD

IMPBFS==20		;SIZE OF SINGLE BUFFER
IMPBFF==IMPBFS+1	;SIZE INCLUDING OVERHEAD
IMPNBF==20		;NUMBER OF BUFFERS
IMPNLK==40		;SIZE OF LINK TABLE
IMP8XS==40		;SIZE OF IRREG MES BUFFER
IMPCMS==20		;SIZE OF CONTROL QUEUE

IMPNPD==60		;SIZE OF 8-LEVEL ROUTINE STACK
N8CB==100		;SIZE OF CONTROL MESSAGE BUFFER
IMPLBT==400/^D36+1	;SIZE OF BIT TABLES FOR HOST STATES
NTTMXA==<TTBSIZ/^D10>*^D8	;MAX OUTSTANDING ALLOC FOR PTY CONN'N
CLINK==0		;CONTROL LINK

IMPUN==5		;AC FOR 'UNIT'

IMPTB1==1		;BIT IN TTNETW, ALLOCATION REQ QUEUED
IMPTB2==2		;BIT IN TTNETW, LAST CHAR WAS CR

;CONO-CONI BITS

IMP=550

IMPINB==1B32		;INPUT WORD READY
IMPOUB==1B28		;READY FOR NEXT OUTPUT WORD
IMPEIB==1B24		;END OF INPUT
IMPGEB==1B23		;CLEAR EIB
IMPEOB==1B22		;END OF OUTPUT
IMPSTO==1B21		;STOP OUTPUT

IMPIOF==10B27+10		;E OF CONO TO CLEAR INPUT PI ASMT
IMPION==<10+IMPCHN>B27+<10+IMPCHN> ;E OF CONO TO SET INPUT PI ASMT
IMPOON==<10+IMPCHN>B31		;E OF CONO TO SET OUTPUT PI ASMT

PTNETI:	POINT 9,TTNETW(2),35	;INPUT UNIT
PTNETO:	POINT 9,TTNETW(2),26	;OUTPUT UNIT

INTERN IMPSV,IMPCHK,IMPOPL,IMPCLL,IMPRTS,IMPSTR,IMPCLS,IMPALL,IMPSRO
INTERN ASNPTY,PTYDET,IMPRST,IMPRRP,IMPBUG,IMSRST,TTNETW,IMPINR,IMPINS

EXTERN RECRTS,RECSTR,RECCLS,RCRFNM,DISG,PFHST,PLINK,EOTF,PTYCLZ
EXTERN NETBUF,NETCNT,NETSTS,IMPPTR,PBPBYT,PBPBUF,PBFSIZ,RFNMB
EXTERN ERRB,NETDWN,NETHDN,NETCHK,HOSTN,NHOSTS,DISGT
EXTERN RECRST,NETBAL,NETEND,LHOSTN,RECINR,RECINS

DEFINE IMPOFF
<	SKIPN INSKED
	NOINT
	AOS IMPLCK>

DEFINE	IMPON
<	SOS IMPLCK
	SKIPN INSKED
	OKINT>

;STORAGE
;STORAGE IS ZEROED AT INIT TIME FROM IMPRDY TO IMPBFR

LS IMPRDY,1		;0=DOWN, 1=GOING DOWN, -1=UP
LS NETON,1		;0=NETWORK OFF
LS NETTCH,1		;STATE OF NET HAS CHANGED IF NON-0
LS IMPFRE,1		;LIST OF FREE BUFFERS
LS IMPNF,1		;COUNT OF FREE BUFFERS
LS IMPIBI,1		;INPUT BUFFERS IN (PI LEVEL) POINTER
LS IMPIBO,1		;INPUT BUFFERS OUT (8-LEVEL) POINTER
LS IMPOBI,1		;OUTPUT BUFFERS IN POINTER
LS IMPOBO,1		;OUTPUT BUFFERS OUT POINTER
LS IMPIB,1		;BUFFER NOW BEING FILLED BY PI ROUTINE
LS IMPOB,1		;BUFFER NOW BEING EMPTIED BY PI ROUTINE
LS IMPINP,1		;BLKI POINTER ON INPUT
LS IMPOUP,1		;BLKO POINTER
LS IMPSVX,1		;PI SERVICE RETURN
LS IMPCK1,1		;TIME AT WHICH TO STOP 8-LEVEL PROCESSING
LS NETTIM,1		;TIME OF NEXT CHECK OF FSM FOR HANGS
LS IMPTIM,1		;TIME OF NEXT CHECK OF DEAD HOSTS
LS RFNTIM,1		;TIME OF NEXT CHECK FOR LOST RFNM'S
LS LSTHDR,1		;HEADER WORD OF MSG CURRENTLY GOING OUT PI LVL

LS IMPSTK,IMPNPD	;STACK FOR 8-LEVEL ROUTINE
LS IMPAC,17		;AC STORAGE ...
LS IMPSP,1		;STACK POINTER STORAGE ...
LS IMPAP,1		;SAVED ACP WHILE IN 8-LEVEL

LS IMP8BC,1		;BYTE COUNT ...
LS IMP8BS,1		;BYTE SIZE INDEX
LS IMPIML,1		;LIST OF BUFFERS FOR CURRENT INPUT MESSAGE

LS IMPLTB,IMPNLK	;CONNECTION TABLE
LS TTNETX,NLINES-NTTYS		;STUFF FOR PSEUDO (NETWORK) TTYS
TTNETW=TTNETX-NTTYS		;RELATIVE TO 0

LS IMP8CB,N8CB		;CONTROL MESSAGE BUFFER
LS IMPCBC,1		;CONTROL MESSAGE BYTE COUNT
LS IMP8CI,1		;INPUT BYTE POINTER FOR CTRL MES RING BFR
LS IMP8CO,1		;OUTPUT .. ..
LS IMPCHO,1		;HOST NUMBER OF CONTROL MESS, MUST PRECEDE I8CAL
LS I8CAL,5		;ARGS OF CONTROL OPERATION, MUST FOLLOW IMPCHO
LS IMPFLS,1		;COUNT (NEG) OF MESSAGES TO FLUSH
LS IMPE1C,1		;COUNT OF TYPE 1 ERRORS
LS IMPLCK,1		;LOCK ON INCOMING CONTROL MESSAGES
LS IMPCCH,1		;INDEX TO HOST NUMBER FOR PERIODIC CHECK
LS SNDERR,1		;HEADER WORD OF OUTGOING MSG WHICH GOT IMP ERR

LS IMPCMI,1		;CONTROL QUEUE IN
LS IMPCMO,1		; .. OUT
LS IMPCMC,1		; .. COUNT
LS IMPCMB,IMPCMS	; .. BUFFER

LS IMP8XI,1		;IRREG MES BUFFER IN PTR
LS IMP8XO,1		; .. .. OUT
LS IMP8XC,1		; .. .. COUNT
LS IMP8XB,IMP8XS	;IRREG MES BUFFER

LS IMPCLT,IMPLBT	;RFNM BITS FOR ALL CONTROL LINKS
LS IMPHRT,IMPLBT	;HOST READY BITS
LS IMPRF2,IMPLBT	;RFNM OVERDUE BITS

LS IMPBFR,IMPBFF*IMPNBF		;BUFFERS

LS IMPBGC,1		;IMPBUG COUNT
LS IMPBGL,1		;IMPBUG LOCATION

;PI DISPATCH

IMPSV:	XWD IMPSVX,.+1
	CONI IMP,1
	TRNN 1,7		;INPUT TURNED OFF?
	JRST IMPSV1		;YES
	TRNE 1,IMPINB
	JRST IMPIN		;WORD IN
	TRNE 1,IMPEIB
	JRST IMPEIN		;END INPUT MESSAGE
IMPSV1:	TRNE 1,IMPOUB
	JRST IMPOUT		;WORD OUT
	JRST @IMPSVX		;N.O.T.A

IMPSP0:	IOWD IMPNPD,IMPSTK	;INITIAL STACK POINTER

;CALLED BY PERIODIC CHECK ROUTINE IF NETTCH NON-0

	SWAPCD

CHKNET:	SKIPE IMPBGL	;IMPBUG LATELY?
	JRST CHKN1	;YES
	HRROI 1,[ASCIZ /
***** NETWORK /]
	PSOUT
	HRROI 1,[ASCIZ /ON/]
	SKIPN NETON
	HRROI 1,[ASCIZ /OFF/]
	PSOUT
	HRROI 1,[ASCIZ /, IMP /]
	PSOUT
	HRROI 1,[ASCIZ /ON/]
	SKIPL IMPRDY
	HRROI 1,[ASCIZ /OFF/]
	PSOUT
	MOVEI 1," "
	PBOUT
	CONI IMP,2
	SETZM NETTCH
	JRST CHKH1		;GO PRINT CONI WORD AND TOD

CHKN1:	HRROI 1,[ASCIZ /
***IMPBUG /]
	PSOUT
	MOVEI 1,101
	MOVEI 3,^D10
	MOVE 2,IMPBGC
	NOUT
	JFCL
	HRROI 1,[ASCIZ / AT /]
	PSOUT
	HRRZ 2,IMPBGL
	SETZM IMPBGL
	JRST CHKH1

	RESCD

;'CHANNEL-8' PROCESS, RUN PERIODICALLY BY SCHEDULER

IMPCHK:	SKIPN NETON		;NETWORK TURNED OFF?
	JRST IMPNOF		;YES
	CONI IMP,1
	TRNE 1,1B19		;INTERFACE POWER STILL ON? AND
	TRNE 1,1B22		;IMP STILL UP?
	JRST IMPNOF		;NO, BEGIN OR CONTINUE CLEANUP
	MOVN 1,IMPRDY
	CAIE 1,1		;IMP IN NORMAL OPERATION?
	JRST IMPNRD		;NO
IMP84:	MOVE 1,TODCLK		;GET NOW
	ADDI 1,2		;2 MS. FROM NOW
	MOVEM 1,IMPCK1		;WHEN TO STOP, EVEN IF NOT FINISHED
IMP80:	MOVE 1,TODCLK
	CAML 1,IMPCK1		;OUT OF TIME?
	RET			;YES, RETURN TO SCHED
	PUSH P,[IMP80]		;RETURN FOR FOLLOWING ROUTINE(S)
	SKIPE IMPIBO		;INPUT READY?
	JRST IMP8IN		;YES, DISTRIBUTE IT
	CAML 1,RFNTIM		;TIME TO CHECK OVERDUE RFNM'S?
	JRST IMPCC1		;YES
IMP82:	MOVEM 0,0(P)		;SAVE SCHEDULER CONTEXT
	MOVEM P,IMPAP
	MOVSI 14,IMPAC		;LOAD IMP OUTPUT CONTEXT
	BLT 14,14
	SETZ P,
	EXCH P,IMPSP		;GET STACK FOR OUTPUT CONTEXT
	JUMPN P,R		;RETURN TO IT
	BUG(HLT,<IMPCHK - NO STACK, POSSIBLE RECURSIVE ENTRY>)

IMP81:	PUSH P,[IMP81]		;RETURN FOR FOLLOWING ROUTINES
	MOVE 1,TODCLK
	CAML 1,IMPCK1		;OUT OF TIME?
	JRST IMP8QT		;YES
	SKIPE IMPCMC		;CONTROL COMMANDS TO SEND?
	JRST IMPCMM		;YES
	SKIPE IMPLCK		;NCP LOCKED?
	JRST IMP83		;YES
	SKIPE IMP8XC		;IRREG MESS FOR PROCESSING?
	JRST IMP8XM		;YES
	SKIPE IMPCBC		;CONTROL MESSAGE TO BE PROCESSED?
	JRST IMP8CT		;YES
	CAML 1,NETTIM		;TIME FOR FSM OVERDUE CHECKS?
	JRST NETCHK		;YES
IMP83:	CAML 1,IMPTIM		;TIME FOR IMP OVERDUE CHECKS?
	JRST NETCH0		;YES
IMP8QT:	SKIPN IMPSP		;NOT NOW IN OUTPUT CONTEXT? OR
	SKIPN INSKED		;NOT UNDER SCHED?
	BUG(HLT,<IMP8QT CALLED WHILE NOT IN SCHED OR NOT IN IMP CONTEXT>)
	MOVEM P,IMPSP		;SAVE IMP CONTEXT AND RETURN TO SCHED
	MOVEI P,IMPAC		;SAVE ACS
	BLT P,IMPAC+14
	MOVE P,IMPAP		;RESTORE SCHED STACK
	POP P,0
	RET			;RETURN TO SCHED

;SEND RST TO ALL HOSTS ON STARTUP

NETCH0:	MOVEI 1,LHOSTN		;LOCAL HOST NUMBER
	IDIVI 1,^D36
	MOVE 2,BITS(2)
	TDNE 2,IMPHRT(1)	;DOES SUBNET THINK WE ARE UP?
	JRST IMPCC5		;YES, GO SEND RST TO ALL OTHER HOSTS
	ANDCAM 2,IMPCLT(1)	;DON'T WAIT FOR RFNM'S
	MOVEI 1,LHOSTN
	CALL IMPRRP		;SEND RRP TO OURSELF
	MOVEI 1,^D1000		;TRY AGAIN IN A SECOND
	JRST IMPCC6

IMPCC5:	SKIPE 7,IMPCCH		;CHECKING HOSTS?
	JRST IMPCC4		;YES
	MOVSI 7,-400		;SCAN ALL POSSIBLE HOST NUMBERS
IMPCC2:	MOVEI 1,0(7)
	IDIVI 1,^D36
	MOVE 2,BITS(2)
	ANDCAM 2,IMPCLT(1)	;CLEAR RFNM WAIT IF ANY
	MOVEI 1,0(7)		;GET NEXT HOST NUMBER
	CALL IMSRST		;SEND RST, SHOULD RECEIVE RRP
	MOVEM 7,IMPCCH		;OR RST IF/WHEN HOST IS UP
	MOVEI 1,^D15		;WAIT 15MS BEFORE CHECKING NEXT HOST
IMPCC6:	ADD 1,TODCLK		;TO AVOID CLOGGING CHANNELS
	MOVEM 1,IMPTIM
	RET

IMPCC4:	AOBJN 7,IMPCC2
	SETZM IMPCCH		;START WITH 0 NEXT TIME
	MOVSI 1,(1B1)		;SET NEXT TIME TO INFINITY
	MOVEM 1,IMPTIM
	SETZM NETTIM		;GET OTHER CHECKS GOING
	SETZM RFNTIM
	RET

;PERIODIC CHECK FOR LOST RFNM'S

IMPCC1:	MOVSI 3,-IMPLBT		;CHECK OVERDUE RFNM TABLE
	MOVE 1,IMPRF2(3)
	JFFO 1,[MOVE 1,BITS(2)	;CONTROL RFNM STILL OUTSTANDING FROM
		ANDCAM 1,IMPCLT(3) ;LAST TIME, CLEAR IT
		ANDCAM 1,IMPRF2(3) ;AND OVERDUE BIT
		JRST IMPCC1]
	AOBJN 3,.-2
	MOVE 1,[XWD IMPCLT,IMPRF2]
	BLT 1,IMPRF2+IMPLBT-1	;REMEMBER CURRENT RFNM TABLE
	MOVE 1,TODCLK
	ADDI 1,^D30000		;CHECK AGAIN IN 30 SEC
	MOVEM 1,RFNTIM
	RET

;EMPTY INPUT BUFFERS
;COPY TO APPROPRIATE DESTINATION, REFORMATTING AS NECESSARY

IMP8IN:	CALL IMP8G		;GET BUFFERS IN MESSAGE
	JRST IMP82		;NOT ALL READY YET
	SKIPE IMPRDY		;IMP READY?
	AOSG IMPFLS		;HAVE WE FLUSHED FIRST FEW MESSAGES?
	JRST IMP8FM		;NO, FLUSH THIS ONE
	MOVE 2,1(1)		;FIRST WORD CONTAINS HEADER
	TLNE 2,(1B1+17B7)	;FROM IMP OR IRREG MESS?
	JRST IMP8IM		;YES, E.G. RFNM
	LDB 3,[POINT 16,2(1),27] ;BYTE COUNT FIELD FROM SENDER
	MOVEM 3,IMP8BC
	LDB 3,[POINT 8,2(1),11]	;BYTE SIZE
	MOVSI 4,-NIBTSZ		;SETUP TO SCAN BYTE SIZE TABLE
	CAMN 3,IMBTSZ(4)
	JRST IMP8N1
	AOBJN 4,.-2
	CALL IMPBUG		;DON'T KNOW HOW TO HANDLE THIS BYTE SIZE
	JRST IMP8FM

IMP8N1:	HRRZM 4,IMP8BS		;SAVE TABLE INDEX
	LDB 3,[POINT 8,2,23]	;REG MESS, GET LINK NUMBER
	CAIN 3,CLINK		;CONTROL LINK?
	JRST IMP8IC		;YES, GO COPY TO CONTROL BUFFER
	LSH 2,-^D12
	ANDI 2,177777		;GET SOURCE HOST AND LINK
	MOVSI 3,-IMPNLK		;TRY TO FIND CONNECTION IN TABLE
	HRRZ 4,IMPLTB(3)
	CAIN 4,0(2)		;FOUND MATCHING ENTRY?
	JRST IMPRMS		;YES
	AOBJN 3,.-3		;NO
	CALL IMPBUG
IMP8FM:	CALL IMP8RB		;RELEASE BUFFER
	SKIPN IMPIML		;MORE BUFFERS?
	RET			;NO, DONE
	CALL IMP8GB		;GET NEXT BUFFER
	JRST IMP8FM		;AND FLUSH IT TOO

;SOME FLAVOR OF ERROR - FLUSH MESSAGE
;CALLED BY JSP 4,IMP8IB

IMP8IB:	CALL IMPBUG
	JRST IMP8FM		;FLUSH BUFFERS

;FROM IMP OR IRREG MESS

IMP8IM:	TLNE 2,(1B1)		;FROM IMP?
	JSP 4,IMP8IB		;YES, IGNORE
	MOVE 3,2
	XOR 3,[5B7+<CLINK>B23]	;COMPARE WITH RFNM, CONTROL LINK
	TDNN 3,[377B7+377B23]	;IS IT?
	JRST [	LSH 2,-^D20	;YES, GET HOST
		ANDI 2,377
		IDIVI 2,^D36
		MOVE 4,BITS(3)
		ANDCAM 4,IMPCLT(2) ;CLEAR RFNM AWAITED
		ANDCAM 4,IMPRF2(2)
		JRST IMP8FM]
	CALL IMP8XQ		;QUEUE THE MSG
	JRST IMP8FM

;QUEUE IRREG MSG OR SPECIAL ACTION

IMP8XQ:	AOS 3,IMP8XI		;INCREMENT INPUT INDEX
	CAIL 3,IMP8XS
	SETZB 3,IMP8XI		;WRAPAROUND
	MOVEM 2,IMP8XB(3)
	AOS IMP8XC
	RET

IMP8XM:	AOS 3,IMP8XO		;RETRIEVE STUFF FROM QUEUE
	CAIL 3,IMP8XS
	SETZB 3,IMP8XO		;WRAPAROUND
	MOVE 2,IMP8XB(3)
	SOS IMP8XC
	JUMPL 2,[HLRZ 1,2	;SPECIAL FUNCTION, GET DATA FROM LH
		ANDCMI 1,400000	;FLUSH BIT
		JRST 0(2)]
	LDB 3,[POINT 4,2,7]	;MESSAGE TYPE CODE
	LDB 2,[POINT 16,2,23]	;HOST-LINK
	XCT IMPMTT(3)		;DISPATCH TO APPROPRIATE ROUTINE
	RET

XX==CALL IMPBUG		;UNIMPLEMENTED CODE, IGNORE

IMPMTT:	BUG(HLT,<IMP - REGULAR MESSAGE ON IRREG QUEUE>)
	JRST IMPEC1		;ERROR
	JRST IMPDN2		;IMP GOING DOWN
	XX			;BLOCKED LINK
	JFCL			;NOP
	JRST IMRFNM		;RFNM
	XX			;LINK TABLE FULL
	JRST IMPDD1		;DESTINATION DEAD
	JRST IMRFNM		;ERROR
	JRST IMRFNM		;INCOMPLETE TRANSMISSION
	XX			;CEASE ON LINK
	XX			;CEASE TIMEOUT
	XX			;CEASE SENT
	XX			;UNASSIGNED
	XX			; "
	XX			; "

;UNPACK CONTROL MESSAGE AND PLACE IN CONTROL BUFFER

IMP8IC:	LDB 3,[POINT 8,2,15]	;HOST NUMBER
	PUSH P,1
	PUSH P,3
	MOVEI 1,377
	CALL IMPCN1		;PUT HOST MARK INDICATOR IN STREAM
	POP P,1
	CALL IMPCN1		;PUT HOST NUMBER ...
	MOVE 3,IMP8BS		;BYTE SIZE INDEX
	MOVEI 4,^D8		;BYTE SIZE OF CONTROL MESSAGES
	CAME 4,IMBTSZ(3)	;OK?
	JSP 4,[	POP P,1		;NO, FLUSH
		JRST IMP8IB]
	HRRZ 4,0(P)		;SETUP AOBJN PTR TO BUFFER
	ADD 4,[XWD -<IMPBFS-1>,2]
	SETZ 6,			;INIT UNPACKING INDEX
IMP8C1:	XCT IMBTRA(3)		;GET BYTE FROM IMP BUFFER
	CALL IMPCN1		;PUT IT INTO CTRL BUFFER
	SOSLE IMP8BC		;COUNT BYTES
	AOJA 6,IMP8C1
IMPUP2:	POP P,1
	JUMPN 1,IMP8FM		;RELEASE REMAINING BUFFERS
	RET			;NONE

;PUT 8-BIT BYTE IN CONTROL STREAM

IMPCN1:	MOVE 2,IMP8CI
	CAME 2,[POINT 8,IMP8CB-1+N8CB,31] ;PTR AT END OF BUFFER
	JRST .+3		;NO
	HRRI 2,IMP8CB-1		;WRAPAROUND
	MOVEM 2,IMP8CI
	IDPB 1,IMP8CI
	AOS 2,IMPCBC		;COUNT CHARS IN CTRL BUFFER
	CAIGE 2,N8CB*4		;TOO MANY?
	RET
	CALL IMPBUG
	SETZM IMPCBC
	RET

;UNPACK AND DISTRIBUTE REGULAR MESSAGE

IMPRMS:	HLRZ IMPUN,IMPLTB(3)	;GET UNIT INDEX
	MOVSI 3,EOTF
	TDNE 3,NETSTS(IMPUN)	;THIS CONNECTION NOW CLOSED?
	JRST IMP8FM		;YES, FLUSH INPUT
	MOVE 3,IMP8BS		;AND BYTE SIZE INDEX
	LDB 4,PBPBYT		;BYTE SIZE OF CONNECTION
	CAME 4,IMBTSZ(3)	;THIS MESSAGE AGREES?
	JSP 4,IMP8IB		;NO
	HRRZ 4,NETSTS(IMPUN)	;CURRENT MSG ALLOC
	CAIG 4,0
	JSP 4,IMP8IB		;SENDER SCREWED UP
	SOS NETSTS(IMPUN)
	LDB 2,PPTY
	CAIL 2,NTTYS		;PTY CONNECTION?
	CAIL 2,NLINES
	JRST IMPRM1		;NO, SETUP FOR REGULAR BYTES
	MOVEI 7,IMP8TI		;ROUTINE TO DISTRIBUTE PTY CHARS
IMPUP0:	MOVEI 4,2(1)		;SETUP BUFFER PTR
	HRLI 4,-<IMPBFS-1>	;SKIPPING SIZE AND COUNT FIELDS
	PUSH P,1
	SETZ 6,			;INIT UNPACKING STATE COUNTER
IMPUP1:	XCT IMBTRA(3)		;GET BYTE INTO 1
	CALL 0(7)		;CALL ROUTINE TO STORE BYTE
	SOSLE IMP8BC		;COUNT BYTES
	AOJA 6,IMPUP1
	HRRZ 2,NETSTS(IMPUN)	;CHECK MSG ALLOC NOW OUT
	CAIL 2,5		;RUNNING LOW?
	JRST IMPUP2		;NO, GO RELEASE REMAINING BUFFERS
	MOVSI 2,0(IMPUN)	;YES, QUEUE ALLOC
	HRRI 2,IMP8SA
	CALL IMPCMQ
	JRST IMPUP2		;GO RELEASE REMAINING BUFFERS

IMP8SA:	MOVEI IMPUN,0(1)
	LDB 1,PFHST
	LDB 2,PLINK
	MOVEI 3,^D20		;ALLOC 20 MSGS
	HRRZ 4,NETSTS(IMPUN)
	SUB 3,4			;LESS ANY NOW OUT
	SETZ 4,			;ALLOCATE NO BITS
	JRST IMPALL		;SEND ALLOCATION

IMPRM1:	MOVN 4,IMP8BC		;BYTE COUNT THIS MESSAGE
	IMUL 4,IMBTSZ(3)	;BITS THIS MESSAGE
	ADDB 4,NETBAL(IMPUN)	;REDUCE OUTSTANDING ALLOC
	CAIGE 4,0
	JSP 4,IMP8IB		;SENDER SCREWED UP
	MOVEI 7,IMPRM2		;ROUTINE TO DISPATCH BYTES
	JRST IMPUP0

;DISTRIBUTE REG BYTE

IMPRM2:	MOVE 2,IMPPTR(IMPUN)
	CAME 2,NETEND(IMPUN)	;END OF BUFFER?
	JRST .+3		;NO
	HRR 2,NETBUF(IMPUN)	;WRAP POINTER
	MOVEM 2,IMPPTR(IMPUN)
	IDPB 1,IMPPTR(IMPUN)	;STORE BYTE
	AOS NETCNT(IMPUN)
	RET

;DISTRIBUTE PTY BYTE

IMP8TI:	MOVE 2,TTBSIZ-40
	CAMG 2,TTBIGC		;BIG BUFFER TOO FULL?
	RET			;YES, FLUSH CHAR
	LDB 2,PPTY		;GET LINE NUMBER
	HRLI 1,1B19(2)		;CONSTRUCT SCANNER INPUT WORD
	IORI 1,DLSRCF		;WITH RECEIVER FLAG
	PIOFF
	AOS 2,TTBIGI		;PUT WORD IN BIG BUFFER
	CAIN 2,TTBSIZ
	SETZB 2,TTBIGI
	MOVEM 1,TTBBUF(2)
	AOS TTBIGC
	PION
	RET

;BYTE UNPACKING TABLES

IMBTSZ:	^D8
	^D32
	^D36
NIBTSZ==.-IMBTSZ

IMBTRA:	XCT IMBT08(6)		;8 BIT
	CALL IMBT32		;32 BIT
	CALL IMBT3A		;36 BIT

;36-BIT UNPACKING ROUTINE

IMBT3A:	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	MOVE 1,0(4)		;GET WORD
	RET

;8-BIT UNPACKING TABLES - 9 BYTES PER 2 WORDS

IMBT08:	CALL IMBT80
	LDB 1,[POINT 8,0(4),15]
	LDB 1,[POINT 8,0(4),23]
	LDB 1,[POINT 8,0(4),31]
	CALL IMBT81
	LDB 1,[POINT 8,0(4),11]
	LDB 1,[POINT 8,0(4),19]
	LDB 1,[POINT 8,0(4),27]
	CALL IMBT82

IMBT80:	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	LDB 1,[POINT 8,0(4),7]
	RET

IMBT81:	MOVE 1,0(4)
	AOBJN 4,.+2
	CALL IMBTXB		;GET NEW BUFFER
	HLL 1,0(4)
	ROT 1,4
	ANDI 1,377
	RET

IMBT82:	LDB 1,[POINT 8,0(4),35]
	SETO 6,
	RET

;32 BIT ROUTINE

IMBT32:	CAIN 6,^D8		;LAST BYTE IN CYCLE?
	JRST [	MOVE 1,0(4)	;YES, IS RIGHT JUSTIFIED IN WORD
		SETO 6,
		JRST IMBT3C]
	MOVE 2,0(4)		;GET FIRST PART OF BYTE
	HRRE 1,IMBT3B(6)	;GET SHIFT N
	ADDI 1,^D36		;DERIVE 36-N
	LSH 2,0(1)		;ALIGN FIRST PART OF BYTE
	AOBJN 4,.+2		;INDEX BUFFER
	CALL IMBTXB		;GET NEW BUFFER
	MOVE 1,0(4)		;GET SECOND PART OF BYTE
	LSH 1,@IMBT3B(6)	;ALIGN IT
	IOR 1,2			;COMBINE PARTS
IMBT3C:	TLZ 1,(-1B3)		;FLUSH EXTRA BITS
	RET

	DEFINE FO (Y)
	<XWD 0,-^D'Y>

IMBT3B:	FO 4
	FO 8
	FO 12
	FO 16
	FO 20
	FO 24
	FO 28
	FO 32

;GET NEW BUFFER, FLUSH OLD ONE

IMBTXB:	EXCH 1,-2(P)		;GET CURRENT BUFFER ADR
	CALL IMP8RB		;RELEASE IT
	SKIPN IMPIML		;ANOTHER BUFFER?
	JRST IMBTXX		;NO, SENDERS BYTE COUNT WRONG
	CALL IMP8GB		;GET NEW BUFFER
	MOVEI 4,1(1)		;FIRST DATA WORD IN BUFFER
	HRLI 4,-IMPBFS		;NUMBER OF DATA WORDS
	EXCH 1,-2(P)
	RET

;RAN OUT OF BUFFERS BEFORE BYTE COUNT EXHAUSTED

IMBTXX:	CALL IMPBUG
	SETZB 4,IMP8BC		;CLEAR BYTE COUNT AND BFR WORD COUNT
	SETZM -2(P)		;NOTE NO BUFFER TO BE RELEASED
	SUB P,BHC+1
	RET			;RETURN AND QUIT

;GET NEXT BUFFER FROM INPUT LIST
;COMPUTE NUMBER OF WORDS AND NUMBER OF BITS IN BUFFER

IMP8G:	MOVE 3,IMPIML		;GET BUFFERS ALREADY SCANNED
IMP8G5:	PIOFF
	SKIPN 1,IMPIBO		;BUFFER ON LIST?
	JRST [	PION		;NO
		MOVEM 3,IMPIML	;SAVE BUFFERS SCANNED
		RET]		;RETURN NOSKIP MEANS BUFFERS NOT ALL IN
	HRRZ 1,0(1)		;UNQUEUE IT
	JUMPN 1,.+3
	MOVEI 2,IMPIBO
	MOVEM 2,IMPIBI
	EXCH 1,IMPIBO
	PION
	HLLZS 0(1)		;CLEAR CHAIN POINTER
	MOVSI 2,(1B1)
	TDNN 2,0(1)		;MORE BUFFERS TO COME?
	JRST IMP8G2		;NO
	JUMPN 3,.+2		;FIRST BUFFER?
	TLOA 3,0(1)		;YES, REMEMBER ADDRESS
	HRRM 1,0(3)		;ADD TO LIST
	HRRM 1,3		;UPDATE LAST POINTER
	JRST IMP8G5

IMP8G2:	JUMPN 3,.+2		;CONC LAST BUFFER
	TLOA 3,0(1)
	HRRM 1,0(3)
	HRRM 1,3
	HLRZM 3,IMPIML		;LIST OF BUFFERS IN THIS MESSAGE
	AOS 0(P)		;SKIP TO INDICATE ALL BUFFERS IN
	JRST IMP8GB		;NOW GET AND RETURN FIRST BUFFER

;GET NEXT BUFFER IN MESSAGE

IMP8GB:	PUSH P,2
	HRRZ 1,@IMPIML
	EXCH 1,IMPIML
	HLRZ 2,0(1)		;COUNT
	ANDI 2,777
	MOVNI 2,0(2)
	HRLI 1,0(2)
	POP P,2
	RET

;RELEASE BUFFER

IMP8RB:	MOVEI 1,0(1)
	PIOFF
	EXCH 1,IMPFRE		;RETURN BUFFER TO FREE LIST
	MOVEM 1,@IMPFRE
	AOS 1,IMPNF		;UPDATE COUNT
	CAIN 1,1		;WENT FROM 0 TO 1?
	CONO IMP,IMPION		;YES, RE-ENABLE INPUT
	PION
	RET

;PI SERVICE FOR INPUT REQUEST

IMPIN:	SKIPG IMPIB		;BUFFER SETUP?
	JRST IMPI1		;NO
	BLKI IMP,IMPINP		;INPUT THE WORD
	JRST .+2		;BUFFER FILLED
	UNBRK IMP

IMPEIN:	SKIPG 2,IMPIB		;BUFFER ADDRESS
	JRST IMPEI2		;NOT SET UP
	HRRM 2,@IMPIBI		;QUEUE IT FOR 8-LEVEL ROUTINE
	HRRZM 2,IMPIBI
	HLRE 3,IMPINP		;COUNT FROM BLKI
	ADDI 3,IMPBFS		;COMPUTE NUMBER OF WORDS
	TRNN 1,IMPEIB		;END INPUT?
	JRST IMPI1A		;NO, GO SETUP ANOTHER BUFFER
	HRLZM 3,0(2)		;STORE COUNT IN BUFFER
	SETZM IMPIB
IMPEI2:	CONO IMP,IMPGEB		;CLEAR PI REQ
	UNBRK IMP

IMPI1A:	IORI 3,(1B1)		;PUT ON CONTINUE BIT
	HRLZM 3,0(2)		;STORE IN BUFFER
IMPI1:	SOSGE IMPNF		;TRY TO GET ANOTHER BUFFER, ANY AVAIL?
	JRST [	AOS IMPNF	;NO, CORRECT COUNT
		SETOM IMPIB	;NOTE INPUTTING INTERRUPTED
		CONO IMP,IMPIOF	;NO, MAKE THE IMP SHUT UP
		JRST IMPUB]
	SKIPN 2,IMPFRE		;FREE BUFFER LIST
	BUG(HLT,<IMP INPUT - BUFFER LIST AND FREE COUNT INCONSISTENT>)
	HRRZ 3,0(2)		;GET ONE OFF FREE LIST
	EXCH 3,IMPFRE
	HRLI 3,-IMPBFS		;SETUP BLKI POINTER
	MOVEM 3,IMPINP
	HRRZM 2,IMPIB		;SAVE BUFFER ADDRESS
IMPUB:	UNBRK IMP

;PROCESS CONTROL MESSAGE NOW IN CONTROL BUFFER

IMP8CT:	CALL IMPIBP		;CHECK AND WRAP BYTE POINTER
	ILDB 1,IMP8CO		;FIRST BYTE IS OP CODE
	CAIN 1,377		;HOST MARKER?
	JRST [	CALL IMPIBP	;YES
		ILDB 1,IMP8CO	;GET HOST NUMBER
		MOVEM 1,IMPCHO	;AND LEAVE IT FOR FOLLOWING COMMANDS
		IDIVI 1,^D36	;COMPUTE INDEX TO BIT TABLES
		MOVE 3,BITS(2)
		IORM 3,IMPHRT(1) ;MARK HOST ALIVE
		JRST IMP8T5]
	CAIL 1,I8NCCM		;LEGAL CODE?
	JRST IMP8T4		;NO, FLUSH WHOLE MESSAGE
	MOVEI 3,I8CCM(1)	;ADDRESS OF TABLE ENTRY FOR THIS CODE
	HRLI 3,220300		;PNTR FOR 3-BIT BYTES SPECIFYING FIELDS
	MOVEI 4,I8CAL		;ARGS BUFFER
IMP8T1:	ILDB 5,3		;NUMBER OF (8-BIT) BYTES IN NEXT ARG
	SETZ 6,			;CLEAR WORD TO CONSTRUCT ARG
	JUMPN 5,IMP8T2		;0 MEANS NO MORE ARGS
	HLRZ 7,I8CCM(1)		;DISPATCH ADDRESS
	MOVE 6,[XWD IMPCHO,1]	;MOVE ARGS TO ACS 1-6
	BLT 6,6			;AC1 (IMPCHO) ALWAYS GETS HOST NUMBER
	CALL 0(7)		;DO FUNCTION
IMP8T5:	SKIPLE IMPCBC		;ANOTHER CONTROL FUNCTION?
	JRST IMP8CT		;YES
IMP8T4:	SETZM IMPCBC		;CLEAR COUNT
	MOVE 2,IMP8CI		;SYNC BYTE POINTERS
	MOVEM 2,IMP8CO
	RET

IMP8T2:	CALL IMPIBP
	ILDB 7,IMP8CO		;NEXT (8-BIT) BYTE OF ARG
	ROT 7,-^D8
	LSHC 6,^D8		;PACK INTO ARG WORD
	SOJG 5,IMP8T2		;ALL BYTES PACKED?
	MOVEM 6,0(4)		;YES, STORE ARG IN BUFFER
	AOJA 4,IMP8T1

IMPIBP:	SOSGE IMPCBC		;BYTE LEFT?
	JRST [	CALL IMPBUG	;NO, LOSSAGE
		POP P,1
		JRST IMP8T4]
	MOVE 2,IMP8CO
	CAME 2,[POINT 8,IMP8CB-1+N8CB,31] ;POINTER AT END OF BUFFER
	RET			;NO
	HRRI 2,IMP8CB-1		;WRAPAROUND
	MOVEM 2,IMP8CO
	RET

;CONTROL TABLE FOR CONTROL OPCODES

	DEFINE CTOP (A,C)
<	XWD IM8'A,C>

I8CCM:	CTOP NOP,0
	CTOP RTS,441000
	CTOP STR,441000
	CTOP CLS,440000
	CTOP ALL,124000

	CTOP GVB,111000
	CTOP RET,124000
	CTOP INR,100000
	CTOP INS,100000
	CTOP ECO,100000

	CTOP ERP,100000
	CTOP ERR,144200
	CTOP RST,0
	CTOP RRP,0
I8NCCM==.-I8CCM

;CONTROL ROUTINES

IM8NOP:	RET

IM8RTS=RECRTS
IM8STR=RECSTR
IM8CLS=RECCLS
IM8INR=RECINR
IM8INS=RECINS

IM8ALL:	LSH 1,^D8		;CONCAT HOST AND LINK
	IORI 1,1B18(2)		;BIT FOR SEND CONNECTION
	CALL LNKLUK		;LOOKUP IN CONNECT TABLE
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	HRRZ 2,NETSTS(IMPUN)	;GET CURRENT MSG ALLOC
	ADD 2,3
	CAILE 2,777777		;BIGGER THAN MAX?
	CALL IMPBUG
	HRRM 2,NETSTS(IMPUN)
	ADDB 4,NETBAL(IMPUN)	;UPDATE BIT ALLOCATION
	CAML 4,[1B3]		;EXCESSIVE?
	CALL IMPBUG
	LDB 2,PPTY
	CAIL 2,NTTYS		;PTY ATTACHED?
	CAIL 2,NLINES
	JRST IMPMO		;NO, TEST MORE OUTPUT FOR REG. CONNET'N
	JRST NETTCS		;YES

;RFNM, FROM IRREGULAR MESSAGE DISPATCH

IMRFNM:	MOVE 1,2		;HOST AND LINK
	ANDI 2,377		;LINK
	CAIN 2,CLINK		;CONTROL LINK?
	JRST IMRFN2		;YES, HANDLED AT PI LEVEL
	IORI 1,1B18		;DENOTE SEND CONNECTION
	CALL LNKLUK		;LOOKUP IN LINK TABLE
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	MOVSI 1,RFNMB
	ANDCAM 1,NETSTS(IMPUN)	;NOW NO MESSAGE OUTSTANDING
	MOVSI 1,ERRB
	CAIE 3,5		;REGULAR RFNM?
	IORM 1,NETSTS(IMPUN)	;NO, INDICATE ERROR
	LDB 2,PPTY
	CAIL 2,NTTYS
	CAIL 2,NLINES		;TTY?
	JRST [	CALL RCRFNM	;NO, ANNOUNCE RFNM TO FSM
		JRST IMPMO]	;MAYBE DO MORE OUTPUT
	JRST NETTCS		;MAYBE SEND MORE OUTPUT

IM8ECO:
IM8ERP:	RET

IM8ERR:	CALL IMPBUG		;SHOULDN'T GET THESE
	RET

IMRFN2:	CAIN 3,5		;REGULAR RFNM?
	RET			;YES, DONE
	LSH 1,-^D8		;NO, GET HOST
	ANDI 1,377
	IDIVI 1,^D36
	MOVE 4,BITS(2)
	ANDCAM 4,IMPCLT(1)	;CLEAR RFNM BITS
	ANDCAM 4,IMPRF2(1)
	RET

IM8GVB:	LSH 1,^D8		;GIVE BACK REQUESTED
	IORI 1,1B18(2)		;CONSTRUCT HOST-LINK FOR SEND SOCKET
	CALL LNKLUK
	JSP 2,BADLUK		;NOT FOUND
	HLRZ IMPUN,IMPLTB(1)	;GET UNIT
	HRRZ 2,NETSTS(IMPUN)	;MSG ALLOC
	CAIL 3,200		;ALL?
	JRST .+3		;YES
	IMUL 2,3		;NO, CALC HOW MUCH
	IDIVI 2,200
	HRRZ 3,NETSTS(IMPUN)
	SUB 3,2			;REDUCE CURRENT MSG ALLOC
	HRRM 3,NETSTS(IMPUN)
	PUSH P,2
	MOVE 2,NETBAL(IMPUN)	;BIT ALLOCATION
	CAIL 4,200		;RETURN ALL?
	JRST .+3		;YES
	MUL 2,4			;NO, CALC HOW MUCH
	DIVI 2,200
	MOVN 3,2
	ADDM 3,NETBAL(IMPUN)	;REDUCE BIT ALLOC
	MOVE 4,2		;SETUP CALL FOR RET
	POP P,3
	LDB 2,PLINK
	LDB 1,PFHST
	CALL IMPRET		;SEND THE RET
	RET

IM8RET:	CALL IMPBUG
	JRST IMPALL		;WE NEVER DO GVB'S, SO ANY RET'S WE
				;RECEIVE WILL IMMED BE REALLOCATED

;GETS HERE BY JSP 2,

BADLUK:	CALL IMPBUG		;HOST-LINK NOT FOUND IN IMPLTB
	RET

;DESTINATION DEAD MESSAGE

IMPDD1:	LDB 3,[POINT 8,2,27]	;HOST NUMBER
	IDIVI 3,^D36
	MOVE 5,BITS(4)
	ANDCAM 5,IMPCLT(3)	;CLEAR RFNM'S FOR THAT HOST
	ANDCAM 5,IMPRF2(3)
	TDNN 5,IMPHRT(3)	;DID WE ALREADY KNOW HE WAS DOWN?
	RET			;YES
	ANDCAM 5,IMPHRT(3)	;NO, MARK HIM DOWN
	LDB 1,[POINT 8,2,27]	;HOST NUMBER
	CALL IMPXLT		;CLEAR LINK TABLE FOR DEAD HOST
	CALL NETHDN		;CLEAN UP ANY CONNECTIONS TO HOST
	RET

;RESET AND RESET-REPLY CTRL MSG

IM8RST:	PUSH P,1
	CALL IMPXLT		;CLEAR LINK TABLE FOR HOST
	CALL RECRST		;NOTIFY FSM
	POP P,1
IM8RRP:	IDIVI 1,^D36		;GET BIT FOR HOST TABLES
	MOVE 5,BITS(2)
	IORM 5,IMPHRT(1)	;MARK HOST ALIVE
	ANDCAM 5,IMPCLT(1)
	ANDCAM 5,IMPRF2(1)
	RET

;CLEAR LINK TABLE FOR PARTICULAR HOST

IMPXLT:	MOVSI 2,-IMPNLK
	LDB 3,[POINT 8,IMPLTB(2),27] ;HOST NUMBER FOR THIS LINK
	CAIN 1,0(3)		;SPECIFIED ONE?
	SETOM IMPLTB(2)		;YES, FLUSH IT
	AOBJN 2,.-3
	RET

;HOST-LINK LOOKUP

LNKLUK:	PUSH P,3
	PUSH P,4
	MOVSI 3,-IMPNLK
LNKL2:	HRRZ 4,IMPLTB(3)
	CAIN 4,0(1)
	JRST [	MOVEI 1,0(3)	;FOUND, RETURN INDEX TO TABLE
		AOS -2(P)	;SKIP RETURN
		JRST LNKL1]
	AOBJN 3,LNKL2		;RETURN NO-SKIP ON NOT FOUND
LNKL1:	POP P,4
	POP P,3
	RET

;ERRORS REPORTED BY IMP

IMPEC1:	AOSLE IMPE1C		;COUNT ERRORS
	BUG(CHK,<RECEIVED MESSAGE TYPE 1 FROM IMP - ERROR WITHOUT SPECIFICATION>)
	RET

;CALLS FROM NCP

;OPEN LINK, I.E. ASSOCIATE HOST-LINE AND UNIT

IMPOPL:	LSH 1,^D8
	IORI 1,0(2)		;CONCAT HOST AND LINK
	CALL LNKLUK		;NOW IN TABLE?
	JRST .+2		;NO, OK
	JSP 2,BADLUK
	MOVSI 3,-IMPNLK
	SKIPGE IMPLTB(3)	;FREE SLOT?
	JRST IMPOP1		;YES
	AOBJN 3,.-2
	JSP 2,BADLUK

IMPOP1:	MOVEM 1,IMPLTB(3)	;STORE HOST-LINK IN RH
	HRLM IMPUN,IMPLTB(3)	;UNIT IN LH
	RET

;CLOSE LINK, INVERSE OF ABOVE

IMPCLL:	LSH 1,^D8		;CONCAT HOST AND LINK
	IORI 1,0(2)
	CALL LNKLUK		;LOOKUP IN LINK TABLE
	JSP 2,BADLUK
	SETOM IMPLTB(1)		;CLEAR ENTRY
	RET

;RTS, STR, CLS, ALL

IMPNOP:	PUSH P,[XWD 0,0]	;NOP, NO ARGS
	JRST IMPSCM

IMPRTS:	PUSH P,[XWD 441000,1]	;ARG DESCRIPTOR,,OPCODE
	JRST IMPSCM		;CONSTRUCT MESSAGE AND OUTPUT

IMPSTR:	PUSH P,[XWD 441000,2]
	JRST IMPSCM

IMPCLS:	PUSH P,[XWD 440000,3]
	JRST IMPSCM

IMPALL:	CAIGE 3,0		;DON'T SEND NEG ALLOCS
	SETZ 3,
	CAIGE 4,0
	SETZ 4,
	ADDM 3,NETSTS(IMPUN)	;MAINTAIN COUNTS, MESSAGES
	ADDM 4,NETBAL(IMPUN)	;BITS
	PUSH P,[XWD 124000,4]
	JRST IMPSCM

IMPRET:	PUSH P,[XWD 124000,6]
	JRST IMPSCM

IMPINR:	PUSH P,[XWD 100000,^D7]
	JRST IMPSCM

IMPINS:	PUSH P,[XWD 100000,^D8]
	JRST IMPSCM

IMSRST:	PUSH P,[XWD 0,^D12]
	JRST IMPSCM

IMPRRP:	PUSH P,[XWD 0,^D13]
	JRST IMPSCM

;CONTROL MSG OUTPUT QUEUE ROUTINES

IMPCMQ:	AOS 3,IMPCMI
	CAIL 3,IMPCMS
	SETZB 3,IMPCMI		;WRAPAROUND
	MOVEM 2,IMPCMB(3)	; XWD DATA,ADDRESS
	AOS IMPCMC
	RET

IMPCMM:	AOS 3,IMPCMO
	CAIL 3,IMPCMS
	SETZB 3,IMPCMO
	MOVE 2,IMPCMB(3)
	SOS IMPCMC
	HLRZ 1,2		;ARBITRARY DATA
	JRST 0(2)

;SEND CONTROL MESSAGE
; 1/ DEST HOST
; 0(P) ARG DESCRIPTOR,,OPCODE

IMPSCM:	SKIPN IMPRDY		;IMP UP?
	JRST [	SUB P,BHC+1	;NO
		RET]
	EXCH 13,0(P)
	PUSH P,IMPUN
	PUSH P,6
	PUSH P,7
	PUSH P,10
	PUSH P,11
	PUSH P,12
	PUSH P,14
IMPSC7:	SKIPN INSKED		;AT 8-LEVEL? OR
	SKIPN IMPCMC		;CTRL CMND QUEUE EMPTY?
	JRST IMPSC8		;YES
	PUSH P,1
	MOVEI 1,IMPSFT
	JSYS EDISMS		;WAIT TIL CTRL MSG QUEUE EMPTY
	POP P,1
	JRST IMPSC7

IMPSC8:	MOVEI 10,0(1)		;HOST
	IDIVI 10,^D36		;COMPUTE INDEX TO RFNM BIT TABLE
	MOVE 14,BITS(11)
IMPSC5:	PIOFF
	TDNE 14,IMPCLT(10)	;MESSAGE NOW OUTSTANDING?
	JRST IMPSC6		;YES
	IORM 14,IMPCLT(10)	;NO, SET IT SO
	PION
	MOVEI 10,1(P)		;USE 3 WORDS ON STACK AS BUFFER
	ADD P,BHC+3
	HRLI 10,441000		;CONSTRUCT BYTE POINTER, 8-BITS
	PUSH P,10		;SAVE IT FOR LATER USE
	IDPB 13,10		;STORE OPCODE AS FIRST BYTE OF MESSAGE
	MOVEI 11,1		;INIT MESSAGE BYTE COUNT
	MOVEI 14,2		;INDEX TO ARGS
IMPSC4:	SETZ 12,
	LSHC 12,3		;NEXT ARG DESCRIPTOR BYTE
	JUMPN 12,IMPSC3		;0 MEANS DONE
	POP P,10		;RECOVER INITIAL BYTE PTR
	LSH 1,^D8
	MOVEI 2,CLINK(1)	;SPECIFIED HOST WITH CONTROL LINK
	MOVEI 1,IMPSC1		;ROUTINE TO SUPPLY BYTES
	MOVEI 3,^D8		;BYTE SIZE
	CALL IMPMSO		;OUTPUT MESSAGE
	SUB P,BHC+3
	POP P,14
	POP P,12
	POP P,11
	POP P,10
	POP P,7
	POP P,6
	POP P,IMPUN
	POP P,13
	RET

IMPSC3:	ADDI 11,0(12)		;ACCUMULATE BYTE COUNT OF MESSAGE
	MOVNI 6,0(12)		;COMPUTE NUMBER OF BITS TO LEFT OF ARG
	IMULI 6,^D8		;NUMBER BYTES TIMES BITS PER BYTE
	ADDI 6,^D36		;SUBTRACTED FROM SIZE OF WORD
	MOVE 7,0(14)		;GET NEXT ARG
	LSH 7,0(6)		;SHIFT OUT UNUSED BITS
	ROT 7,^D8		;SHIFT NEXT BYTE INTO PLACE
	IDPB 7,10		;STORE IT IN MESSAGE BUFFER
	SOJG 12,.-2		;FOR ALL BYTES
	AOJA 14,IMPSC4		;INDEX ARG POINTER

;RESCHEDULE BECAUSE CONTROL LINK TO SPECIFIED HOST CURRENTLY BUSY

IMPSC6:	PION
	SKIPE INSKED		;8 LEVEL?
	JRST [	CALL IMP8QT	;YES, QUIT
		JRST IMPSC5]	;THEN TRY AGAIN
	MOVSI 1,0(1)
	HRRI 1,IMPSCT
	JSYS EDISMS
	HLRZ 1,1
	JRST IMPSC5		;TRY AGAIN

IMPSCT:	IDIVI 1,^D36		;SCHEDULER TEST, GIVEN HOST NUMBER
	MOVE 3,BITS(2)
	TDNE 3,IMPCLT(1)	;STILL BUSY?
	JRST 0(4)		;YES
	JRST 1(4)

IMPSFT:	SKIPE IMPCMC
	JRST 0(4)
	JRST 1(4)

IMPSC1:	ILDB 1,10
	RET

;CALLED BY FILE ROUTINES TO START OUTPUT WHEN OUTPUT BUFFER
;BECOMES NON-EMPTY

IMPSRO:	MOVSI 2,400000(IMPUN)
	HRRI 2,IMPMOU
	NOSKED
	CALL IMP8XQ		;QUEUE REQUEST FOR 8-LEVEL ACTION
	OKSKED
	RET

;DO FILE OUTPUT IF CONDITIONS PERMIT

IMPMOU:	MOVEI IMPUN,0(1)
IMPMO:	SKIPG NETCNT(IMPUN)	;SOMETHING TO SEND?
	RET			;NO
	LDB 3,PBPBYT		;GET BYTE SIZE
	MOVSI 1,RFNMB
	MOVSI 2,EOTF
	TDNN 2,NETSTS(IMPUN)	;DO NOTHING IF NO LONGER OPEN
	TDNE 1,NETSTS(IMPUN)	;RFNM NOW OUTSTANDING?
	RET			;YES, WILL CHECK AGAIN WHEN IT ARRIVES
	IORM 1,NETSTS(IMPUN)
	HRRZ 4,NETSTS(IMPUN)	;MSG ALLOC
	JUMPLE 4,IMPMO1		;CAN SEND ONE MSG?
	MOVE 11,NETCNT(IMPUN)	;YES, GET NUMBER OF BYTES IN BUFFER
	MOVEI 4,0(11)
	IMUL 4,3		;NUMBER OF BITS IN BUFFER
	CAMG 4,NETBAL(IMPUN)	;CAN SEND ALL?
	JRST IMPMO2		;YES
	CAMLE 3,NETBAL(IMPUN)	;CAN SEND AT LEAST ONE?
	JRST IMPMO1		;NO
	MOVE 11,NETBAL(IMPUN)	;CURRENT BIT ALLOCATION
	IDIV 11,3		;GIVES MAX NUMBER OF BYTES TO SEND
IMPMO2:	MOVN 4,11
	ADDM 4,NETCNT(IMPUN)	;UPDATE FILE BUFFER COUNT
	IMUL 4,3
	ADDM 4,NETBAL(IMPUN)	;UPDATE AVAILABLE ALLOCATION
	SOS NETSTS(IMPUN)	;AND MSG ALLOCATION
	LDB 1,PFHST		;CONSTRUCT HEADER
	LSH 1,^D8
	LDB 2,PLINK
	IORI 2,0(1)
	MOVEI 1,IMPMOR		;ADR OF ROUTINE TO GET CHARS
	MOVE 10,IMPUN
	CALL IMPMSO		;DO OUTPUT
	MOVE IMPUN,10
	JRST IMPMO

;INSUFFICIENT ALLOCATION

IMPMO1:	MOVSI 1,RFNMB
	ANDCAM 1,NETSTS(IMPUN)	;CLEAR RFNM BIT
	RET			;WILL CHECK AGAIN WHEN ALLOC ARRIVES

;GET BYTE FROM FILE BUFFER

IMPMOR:	MOVE 1,IMPPTR(10)
	CAME 1,NETEND(10)	;AT END OF BUFFER?
	JRST .+3		;NO
	HRR 1,NETBUF(10)	;WRAPAROUND
	MOVEM 1,IMPPTR(10)
	ILDB 1,IMPPTR(10)
	RET

;IMP MESSAGE OUT
; 1/ ADDRESS OF ROUTINE TO SUPPLY CHARACTER
; 2/ HEADER, RIGHT JUSTIFIED. I.E. 13-15 BITS,
;     16-19 MESSAGE TYPE, 20-27 DESTINATION, 28-35 LINK
; 3/ BYTE SIZE
; 11/ BYTE COUNT
; CLOBBERS ACS 1-7

IMPMSO:	SKIPN IMPRDY
	RET			;DON'T SEND IF IMP OFF
	PUSH P,[0]		;SLOT ON PDL FOR BUFFER COUNT
	PUSH P,[0]		;PUSH A 0 FOR LIST POINTERS
	SETZB 6,7
	PUSH P,1		;SAVE FN ARG
	MOVE 4,11		;BYTE COUNT
	IMUL 4,3		;COMPUTE NUMBER OF BITS IN MESSAGE, PLUS
	ADDI 4,^D72+IMPBFS*^D36-1 ;HEADER, AND ROUND UP TO FULL BFR
	IDIVI 4,IMPBFS*^D36	;NUMBER OF BUFFERS NEEDED FOR MESSAGE
	MOVEM 4,-2(P)		;SAVE ESTIMATED BUFFER COUNT
IMPMS6:	MOVN 1,4
	PIOFF
	ADDB 1,IMPNF		;TRY TO GET ALL NEEDED BUFFERS
	JUMPL 1,IMPMS4		;SUCCESSFUL?
	PION			;YES
IMPMS2:	PIOFF
	SKIPN 4,IMPFRE		;GET A FREE BUFFER
	BUG(HLT,<IMP OUTPUT - BUFFER LIST AND FREE COUNT INCONSISTENT>)
	SOS -2(P)		;REDUCE BUFFER COUNT FOR THIS MESSAGE
	HRRZ 4,0(4)		;GET BUFFER FROM FREE LIST
	EXCH 4,IMPFRE
	PION
	MOVEM 4,-1(P)		;LAST BUFFER OF LIST
	HRLM 4,-1(P)		;FIRST BUFFER IN LIST
	HRLI 4,-IMPBFS		;INIT AOBJN PNTR
	SETZM 1(4)		;CLEAR COUNT AND SIZE WORDS
	SETZM 2(4)
	DPB 2,[POINT 24,1(4),23] ;HEADER
	DPB 3,[POINT 8,2(4),11]	;SIZE
	DPB 11,[POINT 16,2(4),27] ;COUNT
	MOVEI 2,0(3)		;SETUP TO FIND BYTE SIZE INDEX
	MOVSI 3,-NIBTSZ
	CAMN 2,IMBTSZ(3)
	JRST IMPMS7
	AOBJN 3,.-2
	CALL IMPBUG		;DON'T KNOW ABOUT THIS BYTE SIZE
	JRST IMPMS5

IMPMS7:	MOVEI 4,2(4)		;SETUP PTR FOR FIRST BUFFER
	HRLI 4,-<IMPBFS-1>
	SETZ 6,
IMPMS1:	SOJL 11,IMPMS3		;COUNT BYTES
	CALL @0(P)		;GET OUTGOING BYTE
	XCT IMOURA(3)		;PUT IT IN IMP BUFFER
	AOJA 6,IMPMS1

;NO MORE CHARS FROM SOURCE

IMPMS3:	HRRZ 1,-1(P)		;BUFFER ADDRESS
	HLRE 4,4		;COMPUTE NUMBER OF WORDS IN BUFFER
	ADDI 4,IMPBFS+1
	HRLZM 4,0(1)		;PUT IN BUFFER WITH NO CONT BIT
	HLRZ 2,-1(P)		;FIRST BUFFER OF CHAIN
	PIOFF
	HRRM 2,@IMPOBI		;ADD TO OUTPUT LIST
	HRRZM 1,IMPOBI
	PION
	SKIPN IMPOB		;OUTPUT NOW IN PROGRESS?
	JSP 4,IMPIOU		;NO, START IT
IMPMS5:	SUB P,BHC+2		;FLUSH STUFF FROM STACK
	POP P,4			;BUFFERS ASSIGNED BUT NOT USED
	ADDM 4,IMPNF		;CORRECT COUNT
	RET

IMPMS4:	ADDM 4,IMPNF		;RESTORE COUNT
	PION
	SKIPN INSKED		;IN IMP CONTEXT?
	JRST IMPMS8		;NO
	CALL IMP8QT		;TRY AGAIN LATER
	JRST IMPMS6

IMPMS8:	MOVEI 1,IMPMST
	HRLI 1,0(4)
	JSYS EDISMS		;DISMISS UNTIL ENOUGH BUFFERS
	JRST IMPMS6

IMPMST:	CAMLE 1,IMPNF
	JRST 0(4)
	JRST 1(4)

;PACKING ROUTINES AND TABLES

IMOURA:	XCT IMOU08(6)		;8-BIT
	CALL IMOU32
	CALL IMOU36

;36 BIT

IMOU36:	AOBJN 4,.+2		;COUNT WORDS
	CALL IMOUXB		;GET NEW BUFFER
	MOVEM 1,0(4)
	RET

;32 BIT

IMOU32:	CAIN 6,^D8		;LAST BYTE OF CYCLE?
	JRST [	DPB 1,[POINT 32,0(4),35] ;YES, STORE IT
		SETO 6,		;RESET CYCLE COUNTER
		RET]
	LSH 1,4			;LEFT JUSTIFY BYTE
	MOVE 5,IMOU2T(6)	;N FOR SHIFTING
	MOVNI 7,-^D36(5)	;36-N
	JUMPE 6,.+5		;FIRST OF CYCLE MEANS NO FIRST PART
	MOVE 2,0(4)		;GET PARTIAL WORD FROM BUFFER
	ROT 2,0(5)
	ROTC 1,0(7)		;SHIFT IN FIRST PART OF BYTE
	MOVEM 2,0(4)		;STORE COMPLETE WORD
	AOBJN 4,.+2		;GET NEXT WORD
	CALL IMOUXB		;NEW BUFFER
	MOVEM 1,0(4)		;STORE SECOND PART OF BYTE
	RET

IMOU2T:	DEC 36,32,28,24,20,16,12,8

;8-BIT TABLE

IMOU08:	CALL IMOU80
	DPB 1,[POINT 8,0(4),15]
	DPB 1,[POINT 8,0(4),23]
	DPB 1,[POINT 8,0(4),31]
	CALL IMOU81
	DPB 1,[POINT 8,0(4),11]
	DPB 1,[POINT 8,0(4),19]
	DPB 1,[POINT 8,0(4),27]
	CALL IMOU82

IMOU80:	AOBJN 4,.+2		;FIRST OF CYCLE, GET NEXT WORD
	CALL IMOUXB
	DPB 1,[POINT 8,0(4),7]
	RET

IMOU81:	ROT 1,-4
	DPB 1,[POINT 4,0(4),35]	;STORE FIRST PART OF BYTE
	AOBJN 4,.+2		;GET NEXT WORD
	CALL IMOUXB
	MOVEM 1,0(4)		;STORE SECOND PART LEFT JUSTIFIED
	RET

IMOU82:	DPB 1,[POINT 8,0(4),35]	;LAST BYTE OF CYCLE
	SETO 6,			;RESET CYCLE INDEX
	RET

;GET NEXT BUFFER FOR FILLING

IMOUXB:	PUSH P,1
	MOVE 1,-4(P)		;CURRENT BUFFER
	MOVEI 4,IMPBFS+1B19	;COUNT AND CONTINUE BIT
	HRLZM 4,0(1)
	PIOFF
	SKIPN 4,IMPFRE		;GET ANOTHER BUFFER
	BUG(HLT,<IMP OUTPUT - RAN OUT OF BUFFERS, SHOULD HAVE BEEN RESERVED>)
	HRRZ 4,0(4)
	EXCH 4,IMPFRE
	PION
	SOS -5(P)		;COUNT DOWN RESERVE
	HRRM 4,0(1)		;ADD BUFFER TO EXISTING CHAIN
	HRRM 4,-4(P)		;STORE NEW 'LAST' POINTER
	MOVEI 4,1(4)
	HRLI 4,-IMPBFS		;INIT AOBJN PTR
	POP P,1
	RET

;PI SERVICE FOR OUTPUT

IMPOUT:	SKIPL IMPOUP		;POINTER NOW SETUP?
	JRST IMPOUE		;NO
	BLKO IMP,IMPOUP		;OUTPUT A WORD
	HRRZS IMPOUP		;THAT WAS LAST WORD, MAKE PTR POSITIVE
	UNBRK IMP

IMPOUE:	SKIPGE IMPOB		;EOB ALREADY SENT FOR THIS BUFFER?
	JRST [	HRRZS 1,IMPOB	;NO, INDICATE DONE WITH BUFFER
		MOVSI 2,(1B1)
		TDNE 2,0(1)	;MORE BUFFERS IN MESSAGE?
		JRST IMPOU2	;YES, GO SETUP NEXT ONE
		CONO IMP,IMPEOB	;NO, ISSUE EOB
		CONSZ IMP,1B21	;ERROR DURING THIS MESSAGE?
		JRST IMPOER	;YES
		SETZM LSTHDR	;CLEAR SAVED HEADER
		JRST IMPUB]
IMPOU2:	JSP 4,IMPIOU		;SETUP NEXT BUFFER IF ANY
	UNBRK IMP

;ROUTINE TO SETUP BUFFER AND START OUTPUT
;CALLED AT MAIN AND PI LEVEL

IMPIOU:	SKIPG 1,IMPOB		;OLD BUFFER TO DISPOSE OF?
	JRST IMPOU1		;NO
	EXCH 1,IMPFRE		;PUT IT BACK ON FREE LIST
	MOVEM 1,@IMPFRE
	AOS 1,IMPNF		;UPDATE COUNT
	CAIN 1,1		;WAS FREE LIST EMPTY?
	CONO IMP,IMPION		;YES, RE-ENABLE INPUT IN CASE STOPPED
IMPOU1:	SKIPN 1,IMPOBO		;ANY OUTPUT WAITING?
	JRST [	CONO IMP,IMPSTO	;NO, SHUT OFF PI REQ
		SETZM IMPOB
		JRST 0(4)]
	HRRZ 1,0(1)		;GET BUFFER OFF QUEUE
	JUMPN 1,.+3
	MOVEI 2,IMPOBO
	MOVEM 2,IMPOBI
	EXCH 1,IMPOBO
	HRROM 1,IMPOB		;SAVE BUF ADR, NEG TO USE AS FLAG
	MOVE 2,1(1)		;FIRST DATA WORD IN BUFFER
	SKIPN LSTHDR		;DO WE HAVE SAVED HEADER?
	MOVEM 2,LSTHDR		;NO, THIS MUST BE IT
	HLRZ 2,0(1)		;GET COUNT
	ANDI 2,777		;FLUSH EXTRA BITS
	MOVNI 2,0(2)		;MAKE NEG FOR BLKO
	HRLI 1,0(2)		;CONSTRUCT BLKO WORD
	MOVEM 1,IMPOUP
	BLKO IMP,IMPOUP		;DO FIRST OUTPUT
	HRRZS IMPOUP		;IN CASE ONE WORD BUFFER
	JRST 0(4)

;ERROR BIT SET (IMP FLAPPED READY LINE)

IMPOER:	MOVE 2,LSTHDR		;HEADER OF MESSAGE IN ERROR
	MOVEM 2,SNDERR
	SETZM LSTHDR
	CONO IMP,1B19		;CLEAR ERROR STATUS
	JRST IMPUB

;NETWORK TTY LOGIC
;FOR CONNECTION DRIVEN VIA THE TTY SERVICE ROUTINES

;ASSIGN A PSEUDO (NETWORK) TTY
; 1/ RECEIVE UNIT
; 2/ SEND UNIT
; RETURNS 1/ LINE NUMBER

ASNPTY:	MOVEI 3,NTTYS		;PTY'S START AFTER SCANNER TTYS
	NOSKED
ASNPT1:	SKIPGE TTNETW(3)	;FREE?
	JRST ASNPT3		;YES
	CAIGE 3,NLINES-1	;LOOKED AT ALL PTY'S?
	AOJA 3,ASNPT1		;NO
	OKSKED			;YES,
	RET			;RETURN BAD

ASNPT3:	SETZM TTNETW(3)		;GRAB WORD AND INIT TO 0
	OKSKED
	EXCH 2,3
	DPB 1,PTNETI		;REMEBER UNITS
	DPB 3,PTNETO
	CALL TTCOBF
	CALL TTCIBF		;CLEAR BUFFERS
	MOVEI 1,0(2)		;RETURN LINE NUMBER
	AOS 0(P)		;RETURN GOOD
	RET

;CLOSE A FULL DUPLEX NET TTY CONNECTION

PTYDET:	PUSH P,2
	SKIPL TTFORK(2)		;LINE ATTACHED?
	CALL PTYCOF		;YES, INITIATE CARRIER OFF PSI
	MOVE 2,0(P)
	CALL TTCOBF
	CALL TTCIBF
	SKIPG TTNETW(2)		;REASONABLE UNITS?
	JRST PTYDT1		;NO
	LDB IMPUN,PTNETI	;INPUT UNIT
	CALL PTYCLZ		;CLOSE IT
	MOVE 2,0(P)
	LDB IMPUN,PTNETO	;OUTPUT UNIT
	CALL PTYCLZ		;CLOSE IT
PTYDT1:	POP P,2
	SETOM TTNETW(2)
	SETZM TTPSI(2)
	RET

PPTY:	POINT 18,NETBUF(IMPUN),35	;USED TO GET PTY LINE NUMBER

;CHECK STATE OF OUTPUT AND SEND IF POSSIBLE

NETTCS:	NOSKD1
	SKIPG TTNETW(2)		;CONNECTIONS ATTACHED?
	JRST NETTN		;NO, FLUSH OUTPUT
	SKIPE TTECT(2)		;STUFF TO SEND FROM ECHO BUFFER?
	JRST NETTE		;YES
	SKIPE TTOCT(2)		;STUFF TO SEND FROM REG BUFFER
	JRST NETTO		;YES
NETTN:	CHNOFF DLSCHN
	CALL TTRLOB		;RELEASE OUTPUT BUFFERS
	SETZM TTECT(2)
	SETZM TTOCT(2)		;BE SURE COUNT IN SYNC
	CHNON DLSCHN
	OKSKD1
	RET			;NOTHING TO DO

NETTE:	OKSKD1
	MOVE 11,TTECT(2)	;COUNT
	MOVEI 1,NETTEO		;ADDRESS OF CHAR ROUTINE
	JRST NETTC2

NETTO:	OKSKD1
	MOVE 11,TTOCT(2)
	MOVEI 1,NETTOO
				;FALLS INTO NETTC2

NETTC2:	PUSH P,6
	PUSH P,7
	PUSH P,10
	PUSH P,11
	PUSH P,1
	LDB IMPUN,PTNETO	;OUTPUT UNIT
	SKIPG IMPNF		;BUFFERS AVAIL?
	JRST NETTCX		;NO  *** THIS SHOULD BE IMPROVED ***
	PIOFF
	MOVSI 1,RFNMB
	TDNE 1,NETSTS(IMPUN)	;RFNM OUTSTANDING?
	JRST [	PION		;YES, CAN'T SEND NOW
		JRST NETTCX]
	IORM 1,NETSTS(IMPUN)
	PION
	HRRZ 3,NETSTS(IMPUN)
	MOVE 1,NETBAL(IMPUN)	;AVAILABLE BIT ALLOCATION
	CAIL 1,^D8		;AT LEAST ONE BYTE?
	CAIGE 3,1		;ALLOCATION FOR AT LEAST 1 MSG?
	JRST [	MOVSI 1,RFNMB	;NO, CAN'T SEND NOW
		ANDCAM 1,NETSTS(IMPUN) ;CLEAR BIT JUST SET
		JRST NETTCX]
NETTS1:	MOVEI 3,0(11)		;BYTE COUNT
	IMULI 3,^D8		;BITS TO BE SEND
	CAIGE 1,0(3)		;SUFFICIENT ALLOCATION?
	JRST [	MOVEI 3,0(1)	;NO, FIND HOW MANY BYTES CAN BE SENT
		IDIVI 3,^D8
		MOVEI 11,0(3)
		JRST NETTS1]	;AND SEND THAT MANY
	MOVNI 1,0(3)
	ADDM 1,NETBAL(IMPUN)	;UPDATE ALLOCATION FOR THIS MESSAGE
	SOS NETSTS(IMPUN)
	MOVEI 10,0(2)		;LINE NUMBER
	LDB 1,PFHST		;CONSTRUCT HEADER OF HOST AND
	LSH 1,^D8
	LDB 2,PLINK		;LINK
	IORI 2,0(1)
	MOVE 1,0(P)		;ROUTINE TO GET CHARS FOR OUTPUT
	MOVEI 3,^D8		;BYTE SIZE
	CALL IMPMSO		;SEND MESSAGE
	MOVEI 2,0(10)		;RESTORE LINE NUMBER
NETTCX:	POP P,1
	POP P,11
	POP P,10
	POP P,7
	POP P,6
	RET

;GET CHARS FOR OUTPUT FROM ECHO BUFFER

NETTOO:	SKIPN 1,TTOOUT(10)
	RET			;STUFF VANISHED, RETURN 0
	TDNN 1,WRPMSK
	HRR 1,1-TTSIZ(1)
	MOVEM 1,TTOOUT(10)
	ILDB 1,TTOOUT(10)
	SOS TTOCT(10)
	RET

;GET CHARS FOR OUTPUT FROM ECHO BUFFER

NETTEO:	SKIPN 1,TTEOUT(10)
	RET			;STUFF VANISHED, RETURN 0
	TDNN 1,WRPMSK
	HRR 1,1-TTSIZ(1)
	MOVEM 1,TTEOUT(10)
	ILDB 1,TTEOUT(10)
	SOS TTECT(10)
	RET

;CALLED FROM TCOUT

NTTCSO:	IMPOFF
	PUSH P,1
	PUSH P,4
	PUSH P,5
	CALL NETTCS
	POP P,5
	POP P,4
	POP P,1
	IMPON
	RET

;CALLED FROM TCI

NETCAP:	SKIPGE TTNETW(2)	;STILL CONNECTED?
	RET			;NO
	IMPOFF
	PUSH P,IMPUN
	PUSH P,2
	LDB IMPUN,PTNETI
	CALL NETTCA
	POP P,2
	POP P,IMPUN
	IMPON
	RET

;UPDATE ALLOCATION FOR CHAR RECEIVED INTO LINE BUFFER

NTTRC1:	TRZE 2,1B19		;IGNORE IF CHAR DID NOT COME FROM NET
	SKIPGE TTNETW(2)
	RET			;NOT ATTACHED
	PUSH P,IMPUN
	PUSH P,3
	LDB IMPUN,PTNETI
	MOVNI 3,^D8
	ADDB 3,NETBAL(IMPUN)	;UPDATE FOR CHAR RECEIVED
	JUMPGE 3,.+3		;CHECK FOR LOSSAGE BY SENDER
	CALL IMPBUG		;SENT TOO MUCH
	SETZM NETBAL(IMPUN)
	LDB 3,TTIMAX		;MAX CHARS IN INPUT BUFFER FOR LINE
	ASH 3,-1		;HALF THAT
	CAMG 3,NETBAL(IMPUN)	;ALLOCATION RUNNING LOW?
	JRST NTTRC2		;NO
	MOVSI 3,IMPTB1
	TDNE 3,TTNETW(2)	;REALLOC REQUEST NOW PENDING?
	JRST NTTRC2		;YES, DON'T SEND ANOTHER
	IORM 3,TTNETW(2)
	PUSH P,2		;YES, MUST REALLOCATE
	MOVSI 2,0(IMPUN)
	HRRI 2,NTTRC3
	CALL IMPCMQ		;QUEUE A CALL TO NETTCA
	POP P,2
NTTRC2:	POP P,3
	POP P,IMPUN
	RET

NTTRC3:	MOVEI IMPUN,0(1)
	LDB 2,PPTY
NETTCA:	MOVSI 3,IMPTB1
	ANDCAM 3,TTNETW(2)	;CLEAR REQUEST BIT
	LDB 3,TTIMAX		;CAPACITY OF LINE
	SUB 3,TTICT(2)		;GIVES SPACE NOW IN LINE BUFFER
	SKIPE TTPSI(2)		;INTERRUPTS ON THIS LINE?
	ADDI 3,1		;YES, ALWAYS ALLOW AT LEAST ONE CHAR
	IMULI 3,^D8
	CAIL 3,NTTMXA
	MOVEI 3,NTTMXA		;BUT NO LARGER THAN LIMIT
	SUB 3,NETBAL(IMPUN)	;DESIRED ALL LESS ALL NOW OUT
	JUMPLE 3,R		;MAY BE NONE TO SEND
	LDB 1,PFHST
	LDB 2,PLINK
	MOVE 4,3
	HRRZ 3,NETSTS(IMPUN)	;CURRENT MESSAGES ALLOCATED
	MOVN 3,3
	ADDI 3,^D20		;RAISE IT TO 20
	JRST IMPALL		;AND SEND IT

;IMP DOWN

IMPNOF:	SKIPE IMPRDY		;IMP COMPLETELY DOWN? OR
	SKIPE IMPLCK		;LOCK SET?
	RET			;YES, DO NOTHING
	MOVN 1,IMPRDY		;CURRENT IMP STATE
	CAIG 1,1		;NOTED DOWN ALREADY?
	JRST [	MOVEI 1,^D10000	;NO, SET DELAY OF 10 SECS
		ADD 1,TODCLK
		MOVNM 1,IMPRDY	;NEG, NOT -1 MEANS PROBABLE DOWN
		RET]
	CAML 1,TODCLK		;DELAY ELAPSED?
	RET			;NO
	SETZM IMPRDY		;YES, SAY IMP TOTALLY DOWN
	CALL NETDWN		;NOTIFY NCP
	CONO IMP,1B20+10B27+10B31+10 ;SET HOST DOWN, CLEAR ALL PI
	AOS NETTCH		;NOTE CHANGE OF IMP STATE
	RET

;IMP GOING DOWN MESSAGE

IMPDN2:	MOVEI 1,^D30000		;30 SECONDS
	ADD 1,TODCLK		;PLUS NOW
	MOVEM 1,IMPRDY
	RET

;IMP UP, BUT NOT RECORDED AS SUCH

IMPNRD:	SKIPN SYSIFG		;SYSTEM INITIALIZED?
	JRST [	CONO IMP,1B19	;TURN ON OUR READY LINE
		RET]		;BUT DO NOTHING ELSE
	SKIPN 1,IMPRDY		;IMP COMPLETELY OFF?
	JRST IMPINI		;YES, INIT IMP TABLES
	JUMPL 1,.+2		;IF IMP WAS OFF, SET IT ON NOW, NO REINIT
	CAMG 1,TODCLK		;IMP GOING DOWN. FOR MORE THAN 30 SECS?
	SETOM IMPRDY		;YES, DEFINE IT BACK UP
	JRST IMP84

;BUG OR UNTREATED NET ERROR

IMPBUG:	AOS IMPBGC		;COUNT THEM
	EXCH 1,0(P)
	MOVEM 1,IMPBGL		;SAVE ITS LOCATION
	EXCH 1,0(P)
	RET

;INITIALIZATION, CALLED FROM FILINI

IMPINI:	SKIPE NETTCH		;DO NOTHING UNTIL CHANGE LOGGED
	RET			;YES
	CALL IMPGO		;FIRE UP IMP
	RET			;IMP DOWN, DEAD
	MOVE 1,[XWD IMPRDY,IMPRDY+1]
	SETZM -1(1)
	BLT 1,IMPBFR		;CLEAR STORAGE
	MOVEI 1,IMPIBO		;INIT BUFFER LISTS
	MOVEM 1,IMPIBI
	MOVEI 1,IMPOBO
	MOVEM 1,IMPOBI
	MOVE 1,[POINT 8,IMP8CB,-1]
	MOVEM 1,IMP8CI		;INIT CONTROL BUFFER RING PTRS
	MOVEM 1,IMP8CO
	MOVNI 1,2
	MOVEM 1,IMPFLS		;INIT FLUSH COUNT
	MOVNI 1,1
	MOVEM 1,IMPE1C		;IGNORE FIRST ERROR
	MOVEI 1,IMPBFR		;INIT LIST OF FREE BUFFERS
	SETZ 2,
IMPIL2:	MOVEM 2,0(1)
	MOVEI 2,0(1)
	ADDI 1,IMPBFF
	CAIGE 1,IMPBFR+IMPBFF*IMPNBF
	JRST IMPIL2
	MOVEM 2,IMPFRE
	MOVEI 1,IMPNBF
	MOVEM 1,IMPNF		;COUNT OF FREE BUFFERS
	MOVSI 1,-IMPNLK
	SETOM IMPLTB(1)		;MAKE ALL LINKS UNUSED
	AOBJN 1,.-1
	MOVSI 1,NTTYS-NLINES	;MINUS NUMBER NET LINES
	SETOM TTNETW+NTTYS(1)	;INIT ALL NET LINES TO FREE
	AOBJN 1,.-1
	MOVE 1,TODCLK
	ADDI 1,^D30000		;INIT CHECK ROUTINES TO START
	MOVEM 1,IMPTIM		;AFTER IMP STARTUP INTERVAL
	MOVSI 1,(1B1)
	MOVEM 1,NETTIM
	MOVEM 1,RFNTIM
	MOVE 1,IMPSP0		;INIT OUTPUT CONTEXT
	PUSH 1,[IMP81]
	MOVEM 1,IMPSP
IMPRS1:	CONO IMP,IMPION+IMPOON	;GIVE PI ASMTS
	SETOM IMPRDY		;NOTE IMP UP
	AOS NETTCH
	AOS NETON		;NET NOW ON
	RET

;RESTART

IMPRST:	CALL IMPGO
	JRST IMPNOF
	JRST IMPRS1

;DO INITIALIZING SEQUENCE FOR IMP

IMPGO:	CONSO IMP,1B22		;IMP UP? AND
	CONSO IMP,1B19		;INTERFACE POWER UP?
	RET			;NO, LEAVE NET OFF UNTIL OPER ACTION
	CONO IMP,1B19		;SET HOST READY LINE, CLEAR IMP ERROR
	AOS NETTCH		; CAUSE CHANGE IN STATE TO BE NOTED
	SETZM NETON		; NET WILL BE OFF IF FOLLOWING FAILS
	DATAI IMP,1		;HELPS TO CLEAR INTERFACE
	CONO IMP,IMPSTO+IMPGEB
	AOS 0(P)
	RET

	SWAPCD
>		;END OF IFDEF IMPCHN ON PAGE 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              