
;2 DEC 71, 1645:

	TITLE SWPMON

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY

	EXTERN FORKX,FKPGS,INSKED,NPMAX,JB0FLG,DDTIME,IOIP
	EXTERN CHNSON,ITRAP,JOBPT,JOBRT,PSIRQB,TODCLK,FKJOB
	EXTERN GETCHA,RSKP,R,JFNOFN,SETMPG,BLOCKW
	EXTERN JBFINI,FILINI,SYSIFG,MMSPTN,CHKTIM,DRMIN0
	EXTERN JOBDNO,MRPACS,SWAKES,SBLKTM,FKWSP,PSILOB
	EXTERN ASSFK,EDISMS,FKPT,FKSTAT,FREFK,JSKP,JRET,WTLST,HLTJB
	EXTERN ILIST,DDMP,FPTA,SETPT,HALTF1,BLOCK1,FKOLDS
	EXTERN CLRM0,FKINT,FORCTM,HLTFK1,PSIR4,SUSFKR,SUSWT,WTFPGS
	EXTERN PRIMRY,CAPMSK,CAPENB,MLKPG,MULKPG,TENDMP
	EXTERN NXTDMP,TTPSRQ,UCLOCK,ITRAP1,SETOVF,SPTC,SPC1
	EXTERN JOBNAM,NNAMES,SNAMES,STIMES,SPFLTS,CRSTAD,CGFLG
	EXTERN SUPERP,PARALP,INFERP,PSIT1A,SWPMP0,PWRDWN,PASSWC
IFDEF IMPCHN,<
	EXTERN NETKFK>
IFDEF DSPCHN,<
	EXTERN DSPKFK>


WHEEL==1B18
OPER==1B19
LOG==1B21	;LEFT HALF

	INTERN .CFORK,.KFORK,.FFORK,.RFORK,.RFSTS,.SFORK,.RIR
	INTERN .RFACS,.SFACS,.HFORK,.WFORK,.SFRKV,.SEVEC,.GEVEC
	INTERN .RPCAP,.EPCAP,.DTACH,.ATACH,.SJPRI,.SIRCM,.RIRCM
	INTERN EXEC0,EXECI,.EXEC,EXBUGH,TTFRKT,SETLFK,GETMST,WMST
	INTERN WHEEL,OPER,FRZWT,.RTIW,.STIW,SWCEND,SVNM,SVN,SWPPC
	INTERN JB0TT,MDDT,.GCVEC,.SCVEC

JB0TTY==0		;TTY FOR JOB 0 MESSAGES, -1 FOR NONE
LOGTTY==0		;TTY FOR LOGIN/LOGOUT MESSAGES, -1 FOR NONE
MDDT=770000
SSTSIZ==30000		;MAX SIZE OF SWP SYM TAB
LMDDT==5000
EMDDT==MDDT+LMDDT
DDTSYM=MDDT+1

NGSP PHDDT,LMDDT/1000		;IMAGE OF MON DDT
NGSP BUGTAB,6			;BUG TABLE AND STRINGS
NGSP SWPST,SSTSIZ/1000		;SWP SYM TAB

;SYSTEM VERSION TEXT

DEFINE FOO (A)
<	ASCIZ @A@>
SVN:	SYSTXT
	0			;FOR PATCHES
SVNE:

	DEFINE TMSG
<	PUSHJ P,TMSGQ>

;PC FOR SWAPPABLE CODE FOR THIS ASSEMBLY

	SWPPC==SWPMPC	;DEFINED IN PARAMS

EXEC0:	MOVSI 1,UMODF		;SIMULATE CALL FROM USER
	MOVEM 1,FPC
	JSYS MENTR
	SKIPN SYSIFG		;NEW SYSTEM?
	CALL GETSWM		;YES, GET SWAPPABLE MONITOR
	MOVEI 1,FKPTRS
	MOVEI 2,NUFKS
	CALL ILIST
	MOVE 1,0(1)		;GRAB FIRST SLOT FOR TOP FORK
	MOVEM 1,FREJFK
	SETZM FKPTRS
	MOVE 1,FORKX
	MOVEM 1,SYSFK
	MOVE 1,[XWD SYSFK+1,SYSFK+2]
	SETOM -1(1)		;INIT REMAINDER OF TABLE
	BLT 1,SYSFK+NUFKS-1
	MOVSI 1,<JFCL>B53
	MOVEM 1,MONINT		;FOR DDT BREAKPOINT
	MOVE 1,[XWD ITFPC,EXECI]
	MOVEM 1,MONBK
	SETZ 1,
	MOVEI 2,3		;ENABLE CHANS 34 AND 35 FOR ^P
	MOVEM 2,MONCHN		;AND GRAB THEM IF THEY HAPPEN
	AIC
	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES
	CALL FILINI		;INIT FILE SYSTEM
	CALL MAPBTF		;INIT DSK BIT TABLE
	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK

SYSINE:	HRROI 2,[ASCIZ /<PMFDIR0>JOBPMF/]
	MOVE 1,JOBNO
	CAIGE 1,10
	HRROI 2,[ASCIZ /<SYSTEM>JOBPMF/] ;SYSTEM DIR FOR FIRST JOBS
	MOVSI 1,(1B5+1B8+1B17)	;TEMP FILE,IGN DEL AND SHORT FORM GTJFN
	GTJFN
	JRST PMFBAD
	HRRZM 1,JOBPMF
	MOVEI 2,1B19+1B20+1B21+1B25	;IN, OUT, XCT, THAWED
	OPENF			;OPEN PMF
	JRST PMFBAD
	MOVE 1,CTRLTT
	HRLI 1,600012		;CONSTRUCT DEVICE DESIGNATOR FOR CTRLTTY
	JFCL ;	ASND			;ASSIGN IT
	JFCL
	TIME
	MOVEM 1,CONSTO		;SET CONSOLE TIME ON
	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIGE 1,NSPECJ		;IS THIS ONE OF THEM?
	JRST [	MOVE 2,BHC+1	;YES, FAKE A LOGIN AS SYSTEM
		MOVEM 2,JOBDIR(1)
		HRRZ 2,SPECJT(1)
		JRST 0(2)]	;GO DO THE SPECIAL FUNCTION
	MOVEI 1,100
	MOVE 2,ETMOD		;GET TTY TO STANDARD STATE
	MOVE 3,CTRLTT
	CAIL 3,NTTYS		;NETWORK TTY?
	IORI 2,3B33		;YES, SET TO HALF-DUPLEX
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	MOVE 2,TAB81		;GET STANDARD TAB STOPS
	MOVE 4,2
	MOVE 3,TAB82
	STABS			;SET CONTROLLING TTY
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
	JRST STEX		;GO START EXEC

PMFBAD:	MOVEI 1,[SIXBIT 'NO PMF$/']
	TMSG
PMFB1:	HRROI 1,SVN
	PSOUT
	JRST EXCRR

;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.
 IFDEF IMPCHN,<XWD 0,RUNNET>	;START NETSER IF NETWORK EXISTS

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;DO LOGIN STUFF
	DTACH
	MOVE 1,JOBNO
	CAIGE 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST DONS1		;YES
	SETOM ENTFLG		;NO, PERMIT ENTRIES NOW
	GTAD
	JUMPGE 1,.+3		;OR DO WE NEED TIME AND DATE?
DONS1:	MOVE 1,[XWD CTYLIN,JOBSRT]
	CALL SCDRQ7		;START A JOB ON CTY
	RET

;THIS SPECIAL JOB STARTS NETSER (LOGGER, ETC.)

RUNNET:	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>NETSER.SAV/]
	GTJFN
	JRST [	MOVEI 1,[SIXBIT '$NO NETSER$/']
		TMSG
		CALL DONSJ	;COULDN'T START PROGRAM, DTACH ANYHOW
		JRST STEX]	;AND ENTER EXEC
	HRLI 1,400000
	GET
	CALL DONSJ		;DETACH AND START NEXT JOB
	MOVE 1,[XWD 20,^D34]
	ATI			;ENABLE ^P
	HRRZ 1,ENTVEC
	ADDI 1,1		;'REENTER' FOR DETACHED OPERATION
	HRRM 1,0(P)
	JRST MRETN

;GET SWAPPABLE MONITOR

	INTERN GETSWM,ULKSM1,RUNDD
	EXTERN BGTEND,LWTEND,GETSMF

GETSWM:	PUSH P,NPMAX		;SAVE CURRENT MAX SIZE
	MOVE 1,TOTRC
	MOVEM 1,NPMAX		;ALLOW ALL OF CORE WHILE GETTING SWM
	MOVEI 7,SWPMP0		;FIRST PAGE OF SWM
	MOVE 10,[DSKSMA]	;SWP MONS DISK ADDRESS
	NOSKED
LOKSM1:	MOVEI 2,0(7)
	LSH 2,^D9
	SKIP 0(2)		;REF THE PAGE THEREBY ASSIGNING IT
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	PUSH P,7
	CALL MLKPG		;LOCK THE PAGE
	POP P,7
	SKIPG GETSMF		;GETTING MONITOR FROM DISK?
	JRST LOKSM2		;NO
	MOVE 1,10		;YES, GET CURRENT ADDRESS
	CALL CVDSK		;CONVERT TO H'WARE FORMAT
	MOVEI 2,1000		;READ 1000 WORDS
	LDB 3,[POINT 11,MMAP(7),35] ;CORE PAGE NUMBER
	LSH 3,^D9		;CORE ADDRESS
	CALL UDSKIO		;OPERATE THE DISK
	ADDI 10,4		;INCREMENT DISK ADDRESS 4 SECTORS
LOKSM2:	CAMGE 7,SWCEND		;HIGHEST PAGE OF SWM
	AOJA 7,LOKSM1
	SKIPLE GETSMF		;GETTING FROM DISK?
	JRST LOKSM3		;YES, SKIP TENDMP CALL
	MOVSI 1,1
	SOJG 1,.		;WAIT AWHILE FOR DRUM OPS TO COMPLETE
	MOVE 1,[XWD BGTEND,LWTEND]
	BLT 1,377777		;MOVE TENDMP TO HIGH LOCATION
	PIOFF			;TO PREVENT DATA LATE
	MOVEM P,TW1
	JSR TENDMP		;CALL TO INTERPRET PRE-STORED STRING
	MOVE P,TW1
	PION

;GETSWM ...

LOKSM3:	MOVSI 6,WRITEB		;SET TO CLEAR WRITE BIT FROM MMAP
	MOVE 1,DBUGSW
	CAIN 1,2		;BUT IF DBUGSW = 2,
	SETZ 6,			;LEAVE IT WRITABLE
	MOVEI 7,SWPMP0
	MOVE 10,[DSKSMA]	;DISK ADDRESS FOR POSSIBLE WRITING
ULKSM1:	ANDCAM 6,MMAP(7)	;CLEAR ANY UNWANTED ACCESS
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	CALL MULKPG		;UNLOCK THE PAGES
	CAMGE 7,SWCEND
	AOJA 7,ULKSM1
	OKSKED
	POP P,NPMAX		;RESTORE NORMAL MAX SIZE
	SKIPN GETSMF		;IF FRESH START FROM DTA
	SKIPN DISKP		;AND DISK AVAILABLE
	RET
	PUSH P,CAPENB		;SAVE CURRENT CAPS
	MOVEI 1,WHEEL		;WE NEED WHEEL FOR THE FOLLOWING
	IORM 1,CAPENB
	CALL WRMON		;WRITE RES AND SWP MON ON DISK
	CALL WRSWM
	POP P,CAPENB
	AOS GETSMF		;FLAG MON NOW ON DISK
	RET

;SWCEND IS SET BY POSTLD TO CONTAIN THE NUMBER OF THE HIGHEST
;PAGE CONTAINING SWAPPABLE CODE

SWCEND:	0

	SWAPCD

RUNDD:	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS
	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;NO
	STAD			;YES, SET IT
	JFCL
RUNDD3:	MOVEI 1,101
	DOBE
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX RESTARTING, WAIT.../]
	TTMSG
	SKIPG DISKP
	JRST RUNDD2		;SKIP DISK STUFF IF NO DISK
	CALL CHKBT		;CHECK CONSISTENCY OF DISK BIT TABLE
	MOVE 2,DBUGSW
	CAIN 2,2		;IF REAL DEBUGGING,
	JRST RUNDD2		;SKIP DISK CHECKING
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>CHECKDSK.SAV/]
	GTJFN
	JRST RUNDD1
	HRLI 1,400000
	GET			;GET DISK BIT TABLE CHECKER FILE
	MOVEI 1,RUNDD2
	HRRM 1,MONBK		;SET ADDRESS FOR INTERRUPTS
	JRST GEX1		;START CHECKER

RUNDD1:	HRROI 1,[ASCIZ / NO CHECKDSK
/]
	PSOUT
RUNDD2:	SETZM PSIBW		;CHECKDSK RETURNS TO HERE ON HALTF
	MOVSI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR		;RE-ESTABLISH MONITOR CONTEXT
	SETO 2,
	DIC
	CALL DTIALL
	MOVEI 1,EXECI
	HRRM 1,MONBK		;RESTORE DEFAULT INTERRUPT
	MOVE 1,CAPMSK
	MOVEM 1,CAPENB		;RESTORE CAPABILITIES
	MOVEI 1,101
	DOBE			;WAIT FOR ANY CHECKDSK OUTPUT
	GTAD
	JUMPL 1,.+4		;DON'T TYPE MESSAGE IF NO DATE SET
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX IN OPERATION
/]
	TTMSG

	MOVE 1,JB0TT		;JOB 0 TTY
	JUMPG 1,RUNDD4
	MOVSI 1,(1B0+1B17)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.REPORT/]
	GTJFN
	BUG(CHK,<CAN'T GTJFN ERROR REPORT FILE>)
	MOVE 2,[44B5+1B20]
	OPENF
	BUG(CHK,<CAN'T OPENF ERROR REPORT FILE>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT 
	MOVEI 1,[SIXBIT '$RUNNING DDMP$$/']
	TMSG			;ON TTY 0
	MOVSI 1,(740B8)
	MOVEM 1,LOGBUF
	HRROI 1,LOGBUF
	EFACT			;RESTART ENTRY IN FACT FILE
	BUG(CHK,<FAILED TO MAKE RESTART ENTRY IN FACT FILE>)
	AOS SYSIFG		;MAKE SYSTEM AVAILABLE
	CALL DONSJ		;START NEXT SPECIAL JOB
	MOVEI 1,103
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	MOVEI 1,CHKRI
	HRRM 1,MONBK		;SET DISPATCH FOR INTERRUPTS
	JRST CHKR		;GO DO BACKGROUND

;MAP DDT FROM IMAGE FILE

GETDDT:	SKIPE GOTDDT		;GOT DDT NOW?
	RET			;YES
	MOVSI 1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>MDDT.SAV/]
	GTJFN
	JRST NODDT
	MOVEI 2,1B19		;READ
	OPENF
	JRST NODDT
	PUSH P,1
	MOVSI 1,0(1)
	CALL JFNOFN
	BUG(HLT,<GETDDT - JFNOFN FAILED>)
	MOVE 2,[XWD READB,PHDDT]
	MOVEI 5,LMDDT/1000
	CALL SETMPG		;MAP FILE PAGES INTO SWP MON MAP
	ADDI 1,1		;NEXT FILE PAGE
	ADDI 2,1000		;NEXT MON MAP PAGE
	SOJG 5,.-3
	POP P,1			;RECOVER JFN
	CLOSF			;CLOSE THE FILE
	JFCL
	AOS GOTDDT		;GOT DDT NOW!
	RET

NODDT:	MOVEI 1,[SIXBIT '$NO MDDT FILE$/']
	TMSG
	JRST NODD1

JB0TT:	JB0TTY!400000		;JOB 0 TTY, OR -1 FOR NONE

LS SWPSTP,1			;POINTER TO SWAPPABLE SYMTAB
LS GOTDDT,1			;REMEMBERS IF WE HAVE MAPPED DDT

;READ IN MONITOR SYMBOL TABLE FROM FILE

GETMST:	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT
	HRRI 1,SVNM		;USE CORRECT VERSION FOR THIS SYSTEM
	HRROI 2,[ASCIZ /<SYSTEM>MONSYMS.TBL/]
	GTJFN
	JRST NOSYMS		;NO FILE
	MOVE 2,[44B5+1B19]	;36 BIT READ
	OPENF
	JRST [	RLJFN
		JFCL
		JRST NOSYMS]
	BIN			;GET XWD -LENGTH,ADDRESS
	HLRE 3,2
	MOVM 3,3		;POSITIVE OF LENGTH
	CAILE 3,SSTSIZ		;TOO BIG?
	HRLI 2,-SSTSIZ		;YES, READ ONLY TO MAX
	HRRI 2,SWPST		;ADDRESS WHERE TABLE TO BE PUT
	MOVEM 2,SWPSTP
	MOVE 7,2
	BIN
	MOVEM 2,0(7)
	AOBJN 7,.-2
	CLOSF
	JFCL
NOSYMS:	RET

EWMST:	MOVEI 1,[SIXBIT 'RITE MON SYM TAB/']
	TMSG
	CALL OKGO
	SKIPE 1,@DDTSYM		;DDT HAS CURRENT POINTER?
	MOVEM 1,SWPSTP		;YES, UPDATE IT
	JSP 4,WMST		;WRITE TABLE ONTO FILE
	JRST EXCRR

;WRITE MONITOR SYMBOL TABLE ONTO FILE
;CALLED WITH JSP 4,WMST

WMST:	HRROI 1,[ASCIZ /
SYMBOL TABLE LARGER THAN SWAPPABLE STORAGE ALLOCATED FOR IT.
/]
	HLRE 2,SWPSTP
	MOVM 2,2
	CAILE 2,SSTSIZ		;TOO LARGE?
	PSOUT			;YES, PRINT MESSAGE
	HRROI 1,[ASCIZ /
SYMBOL TABLE WRITTEN ON FILE /]
	PSOUT
	MOVSI 1,(1B0+1B17)
	HRRI 1,SVNM		;VERSION NUMBER FOR THIS SYSTEM
	HRROI 2,[ASCIZ /MONSYMS.TBL/]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	JFNS			;TYPE THE FILE NAME
	MOVE 1,2
	MOVE 2,SWPSTP
	BOUT			;OUTPUT -LENGTH,,ADR
	MOVE 7,2
	MOVE 2,0(7)
	BOUT
	AOBJN 7,.-2
	CLOSF
	JFCL
	JRST 0(4)

EXEC2:	MOVEI 1,100		;ESTABLISH CORRECT TTY MODES
	MOVE 2,ETMOD
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL
	MOVE 1,[XWD 20,^D34]
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 2,JOBNO
	MOVEI 3,1		;ASSUMED NUMBER OF SYSTEM DIRECTORY
	HRRZ 1,JOBDIR(2)
	CAIN 1,0		;LOGGIN IN?
	HRRM 3,JOBDIR(2)	;NO, FUDGE LOGIN
	MOVEI 1,"."
	PBOUT
EXECT1:	PBIN			;AWAIT USER INPUT
	CAIN 1,"E"
	JRST GEX
	CAIN 1,"B"
	JRST EBLT		;BLT SWP MON TO USER SPACE
	CAIN 1,"M"
	JRST EMNT		;MOUNT DTA-
	CAIN 1,"R"
	JRST EREST		;RESET USER MAP AND FILES
	CAIN 1,"G"		;G - GET FILE
	JRST EGET
	CAIN 1,"S"		;S - START
	JRST EST
	CAIN 1,"D"		;D - DUMP ON FILE
	JRST EDMP
	CAIN 1,"I"
	JRST EINI
	CAIN 1,"H"
	JRST EHLT		;HALT T.S.
	CAIN 1,"W"
	JRST EWMST
	CAIN 1,"!"
	JRST EX2
	CAIN 1,"^"
	JRST MRETN
	CAIN 1,"/"
	JRST TODDT
	JRST EXERR		;NOTA

TODDT:	MOVEI 1,EOL
	PBOUT
	SKIPE MDDT		;DDT ALREADY LOADED?
	JRST MDDT		;YES
	CALL GETDDT		;GET PROTOTYPE DDT
	MOVE 1,[XWD PHDDT,MDDT]
	BLT 1,EMDDT-1		;MOVE DDT TO PP AREA
	SKIPN SWPSTP		;NON RES SYMTAB HERE?
	CALL GETMST		;NO, TRY TO GET IT
	SKIPN 1,SWPSTP		;USE NON-RES SYMTAB IF PRESENT
	MOVE 1,36		;MOVE MONITOR SYMBOL POINTER
	MOVEM 1,@DDTSYM
	JRST MDDT		;GO TO DDT

ETMOD:	EXP ^D66B10+^D72B17+17B23+2B25+1B29+1B31

EX2:	XCTUU [SKIPE MDDT]	;DDT ALREADY LOADED?
	JRST EX2L
	CALL GETDDT
	MOVE 1,[XWD PHDDT,MDDT]
	XCTMU [BLT 1,EMDDT]	;MOVE DDT TO USER SPACE
EX2L:	MOVEI 1,MDDT
	HRRM 1,0(P)		;RETURN ADDRESS
	JRST MRETN		;TO DDT IN USER MODE

;BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

EBLT:	MOVEI 1,[SIXBIT 'LT SWP MON/']
	TMSG
	CALL OKGO
	SKIPLE DISKP		;IF DISK,
	CALL WRSWM		;WRITE IT ON DISK
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVEI 1,SWPMP0		;FIRST PAGE
	LSH 1,^D9
	HRLI 1,0(1)
	XCTMU [BLT 1,777(2)]
	JRST EXCRR

EREST:	MOVEI 1,[SIXBIT 'ESET/']
	TMSG
	CALL OKGO
	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVSI 7,-1000
	MOVNI 1,1
	MOVSI 2,400000
	SETZ 3,
	HRRI 2,0(7)
	PMAP
	AOBJN 7,.-2
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	JRST EXCRR

OKGO:	PBIN
	CAIN 1,"."
	RET			;PERIOD MEANS GO
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

GEX:	MOVEI 1,[SIXBIT 'XEC$/']
	TMSG
STEX:	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
	GTJFN
	JRST [	HRROI 1,[ASCIZ /NO EXEC/]
		PSOUT
		JRST EXCRR]
	HRLI 1,400000
	GET
	JRST GEX1

;INIT DISK BIT TABLE, BAD SPOTS, ETC

EINI:	MOVEI 1,[SIXBIT 'NIT BIT TABLE/']
	TMSG
	CALL OKGO
	CALL DSKRBS		;READ BAD SPOTS
	JRST EXCRR

;HALT TENEX

EHLT:	MOVEI 1,[SIXBIT 'ALT TENEX/']
	TMSG
	CALL OKGO
	SETZM NXTDMP		;REQUEST DDMP ACTION
	SETZM DDTIME		;FORCE DDMP RUN
	AOS JB0FLG		;REQUEST JOB 0
	MOVEI 1,^D1000
	DISMS			;WAIT A SECOND
	SKIPN CGFLG		;SWAPPING AND
	SKIPL NXTDMP		;DDMP FINISHED?
	JRST .-4		;NO
	MOVSI 1,400000
	MOVEM 1,20		;HALT SCHED
	JRST EXCRR

;MOUNT DECTAPE

EMNT:	MOVEI 1,[SIXBIT 'OUNT DTA/']
	TMSG
	PBIN
	CAIL 1,"0"		;USER TYPES DIGIT
	CAILE 1,"7"		;FROM 0 TO 7
	JRST EXERR		;BAD CHAR
	MOVE 10,[ASCIZ /DTA0/]
	DPB 1,[POINT 7,10,27]	;CONSTRUCT STRING WITH UNIT NUMBER
	HRROI 1,10
	STDEV
	JRST EXERR		;NO SUCH DEVICE
	MOVE 1,2
	MOUNT
	JRST EXERR
	JRST EXCRR

EGET:	MOVEI 1,[SIXBIT 'ET FILE /']
	TMSG
	MOVSI 1,(1B2+1B4+1B16+1B17)	;OLD FILE,TERMINATION,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	JRST EXCRR

EST:	MOVEI 1,[SIXBIT 'TART/']
	TMSG
	CALL OKGO
	MOVEI 1,EOL
	PBOUT
GEX1:	HRRZ 1,ENTVEC
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	HRRM 1,0(P)
	JRST MRETN

EDMP:	MOVEI 1,[SIXBIT 'UMP ON FILE /']
	TMSG
	MOVSI 1,(1B0+1B3+1B4+3B17)	;NEW V,PNT O/N,TERM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD 777760,20]	;ALL EXCEPT AC'S
	SAVE
	JRST EXCRR

EXERR:	MOVEI 1,[SIXBIT '  ?/']
	TMSG
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
EXCRR:	MOVEI 1,EOL
	PBOUT
	JRST EXEC2

;PSI TRAPPED TO HERE

EXECI:	XCT MONINT		;FOR DDT BREAKPOINT
	EXCH 1,ITFPC		;SAVE 1, GET TRAP PC
	TLNN 1,UMODF		;USER?
	JRST EXECI1		;NO
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFPC		;RESTORE AC1
EXECI2:	JSYS MENTR
	SETOM PRIMRY
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	MOVEI 1,400000
	SETO 2,
	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	MOVEI 1,EM2
	TMSG
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 1,1(P)		;GET USER PC
	HRLI 1,UMODF
	MOVEM 1,FPC
	HRLZ P,ACBAS1		;RECOVER USER AC'S
	LSH P,4
	BLT P,17
	JRST EXECI2

EXECI3:	MOVEI 1,EM3
	TMSG
	MOVEI 1,101
	HRRZ 2,UPP
	HRRZ 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	JFCL
	MOVE 1,CAPMSK
	TRNE 1,WHEEL+OPER
	JRST EXCRR		;TO MINI-EXEC IF WHEEL OR OPERATOR
	JRST STEX		;START EXEC OTHERWISE

EM2:	SIXBIT '$ABORT$/'
EM3:	SIXBIT '$INTERRUPT AT /'

;JSYS TO ENTER MINI-EXEC

.EXEC:	JSYS MENTR
	MOVEI 1,WHEEL+OPER
	TDNN 1,CAPENB
	JRST ITRAP
	JRST EXEC2

EXBUGH:	MOVE P,UPP		;TRY TO RESET WORLD
	SETOM TRAPC
	SETZM NSKED
	SETZM INTDF
	SETZM SLOWF
	MOVEI 1,-1
	HRROI 2,[ASCIZ /
BUGHLT AT /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2,EOL
	BOUT
	JRST ITRAP

;EXEC UTILITY ROUTINES

;MESSAGE TYPER - ADR OF SIXBIT TEXT IN 1

TMSGQ:	HRLI 1,440600		;CONSTRUCT BYTE POINTER
	PUSH P,1
TMSG1:	ILDB 1,0(P)
	ADDI 1,40		;CONVERT TO ASCII
	CAIN 1,"/"		;SLASH IS TERMINATOR
	JRST TMSG2
	CAIN 1,"$"		;DOLLARS MEANS EOL
	MOVEI 1,EOL
	PBOUT
	JRST TMSG1

TMSG2:	POP P,1			;FLUSH TEMP
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

	INTERN CHKR

CHKR:	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADDI 1,^D120000		;NOW PLUS TWO MINUTES
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SKIPE BUGHLT		;BUGHLTS LATELY?
	CALL CHKHLT		;REPORT
	SKIPE BUGCHK		;BUGCHK?
	CALL CHKBUG		;YES
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE 1,DRMCFE		;DRUM ERROR COUNT
	CAME 1,CHKDMC		;DIFFERENT FROM LAST TIME?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT THAN LAST CHECK?
	CALL CHKDE1		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK		;PRINT INFO
IFDEF IMPCHN,<
	SKIPN IMPBGL		;IMP BUG?
	SKIPE NETTCH		;NETWORK CHANGED STATE?
	CALL CHKNET		;YES, LOG IT
>
	CALL DDMP		;DISK BACKUP
	MOVE 2,TODCLK		;SETUP DISMISS CONDITION FOR
	ANDI 2,377777		;NOW PLUS 30 SEC
	MOVSI 1,^D30000(2)
	HRRI 1,JB0TST		;OR JB0FLG
	JSYS EDISMS
	JRST CHKR

	RESCD

JB0TST:	MOVE 3,4		;SAVE RETURN
	JSP 4,BLOCKW		;TEST CLOCK
	SKIPE JB0FLG		;OR FLAG
	JRST 1(3)		;RUN
	JRST 0(3)

	SWAPCD

CHKH1:	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
CHKR1:	GTAD			;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	MOVEI 1,37
	PBOUT
	RET

CHKHLT:	HRROI 1,[ASCIZ /
*****BUGHLT AT /]
	PSOUT
	HRRZ 2,BUGHLT
	SETZM BUGHLT
	JRST CHKBG1

CHKBUG:	HRROI 1,[ASCIZ /
*****BUGCHK AT /]
	PSOUT
	HRRZ 2,BUGCHK
	SUBI 2,1		;TO POINT AT JSR
	SETZM BUGCHK
CHKBG1:	PUSH P,2		;SAVE ADDRESS
	CALL CHKH1		;PRINT IT
	SKIPE BUGTAB		;HAVE BUG TABLE NOW?
	JRST BUGLK5		;YES
	MOVE 1,[1B2+1B17+SVNM]
	HRROI 2,[ASCIZ /<SYSTEM>BUGTABLE.IMG/]
	GTJFN
	JRST BUGLK0
	MOVE 2,[44B5+1B19]
	OPENF
	JRST BUGLK0
	MOVE 7,[XWD -6000,BUGTAB]
BUGLK3:	BIN
	JUMPN 2,BUGLK2
	GTSTS
	TLNE 2,(1B8)		;EOF?
	JRST BUGLK4		;YES
	SETZ 2,
BUGLK2:	MOVEM 2,0(7)
	AOBJN 7,BUGLK3
BUGLK4:	CLOSF
	JFCL
BUGLK5:	POP P,1			;BUG ADDRESS
	MOVSI 7,-1000
BUGLK1:	SKIPN 6,BUGTAB(7)
	RET			;FAILED TO FIND ADDRESS, PRINT NOTHING
	HLRZ 2,6
	CAME 1,2
	AOBJN 7,BUGLK1		;SHOULD NEVER CONTINUE
	HRROI 1,[ASCIZ / - /]
	PSOUT
	HRROI 1,BUGTAB+1000(6)	;STRING STORAGE STARTS IN NEXT PAGE
	PSOUT
	JRST CHKR2		;PRINT EOL AND RETURN

BUGLK0:	HRROI 1,[ASCIZ @ - (FAILED TO GTJFN/OPEN BUGTABLE FILE)
@]
	PSOUT
	POP P,1
	RET

CHKDRM:	MOVEM 1,CHKDMC		;STORE NEW COUNT
	HRROI 1,[ASCIZ /
*****DRUM ERR: /]
	PSOUT
	MOVEI 6,DRMCFE
	JRST CHKDE2

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****DRUM SPACE LOW, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****SPT SPACE LOW, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1

CHKDSK:	MOVEM 1,CHKDNE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
***NON-REC DISK ERROR: /]
	MOVEI 6,DSKLER		;4 WORD BLOCK OF COMMANDS AND ERR BITS
CHKDE2:	PSOUT
	MOVEI 1,101
	HRLI 6,-4		;REPORT 4 WORDS
	MOVE 3,[1B0+^D8]	;IN MAGNITUDE OCTAL
CHKD1:	MOVE 2,0(6)
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
	AOBJN 6,CHKD1
	JRST CHKR1

CHKDE1:	MOVEM 1,CHKDRE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
*DISK ERROR: /]
	MOVEI 6,DSKRER		;4 WORD BLOCK OF COMMANDS, ETC.
	JRST CHKDE2

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****JOB 0 CRASH, CONTINUING
/]
	PSOUT
	JRST CHKR

LS CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
LS CHKDNE,1			; "" NON-REC. ""
LS CHKDMC,1

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO

	INTERN GETPAT

GETPAT:	JSYS MENTR		;GETS HERE FROM UUO HANDLER
	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCT PATUPC
	MOVE 1,40
	XCT PATU40
	JRST MRETN		;GO TO COMPATIBILITY

;INFO JSYS'S

	INTERN .GJINF,.TIME,.RUNTM,.GTRPI

.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.RUNTM:	JSYS MENTR
	JSP 3,UCLOCK		;UPDATE CLOCKS
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	JSYS MENTR
	CALL SETLFK
	MOVE 1,UTRPCT
	MOVE 2,USWPCT
	MOVE 3,PTTIM
	JRST RETA3

	INTERN .GETAB,.SYSGT

;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

.SYSGT:	JSYS MENTR
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ 1,GTTAB(4)		;ADDRESS OF FIRST WORD
	MOVE 1,0(1)
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

.GETAB:	JSYS MENTR
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR GTABX3		;NO  *** CHANGE TO GTABX3 ASAP ***
	HLRE 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR GTABX1		;NO
	HLRZ 1,GTTAB(3)		;GET SIZE OF TABLE
	JUMPL 2,RETN1		;RETURN SIZE IF INDEX <0
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR GTABX2
	ADD 2,GTTAB(3)		;COMPUTE ADDRESS OF DESIRED WORD
	MOVE 1,0(2)		;GET WORD
RET1:	UMOVEM 1,1		;RETURN IT TO USER
URSKP:	AOS 0(P)		;SKIP RETURN
	JRST MRETN

RETN1:	XCTUU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	JRST URSKP		;SKIP RETURN

;TABLE OF TABLES

	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN NSTAT,SKDTM0,TOTRC,MAXQ,QSUM

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKRCE
	XWD NDRMEW,DRMCFE
	XWD SVNE-SVN,SVN
	XWD 3,UTRPCT
	XWD NSTAT,SKDTM0
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
IFDEF IMPCHN,<
	EXTERN NHOSTS,NSKT,HOSTAB,HOSTN,LSKT,FSKT,NETAWD,NETBAL,NETSTS,NETBUF
	XWD 2,IMPRDY
	XWD IMPLBT,IMPHRT
	XWD NHOSTS,HOSTAB
	XWD NHOSTS,HOSTN
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD NSKT,NETAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
>
GTBSIZ==.-GTTAB

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB:	SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
	SIXBIT /DRMERR/
	SIXBIT /SYSVER/
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HOSTAB/
	SIXBIT /HOSTN/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
>

IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>

;SUBSYSTEM STATISTICS LOGIC

	INTERN .SETNM

.SETNM:	JSYS MENTR
	NOINT
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOS SNMPT		;UPDATE POINTER
	MOVEM 1,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	JRST MRETN

GS SNMPT,1		;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1		;LOCK FOR SNAMES TABLE

	INTERN .LITES

.LITES:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;LOGOUT

	INTERN .LGOUT,FLOGO

.LGOUT:	JSYS MENTR
	NOINT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO
LOGO:	SKIPE FORKN		;TOP FORK?
	JRST [	MOVSI 1,LOG
		TDNN 1,CAPMSK	;LOG PERMITTED?
		JRST LOGOE1	;NO, ERROR RETURN
		HLRZ 1,FORKN	;NO, GET ITS NUMBER
		HRRZ 2,SYSFK(1)
		NOSKED
		MOVSI 1,400000+PSILOB
		IORM 1,FKINT(2)	;REQUEST LOGOUT
		CALL PSIR4
		OKSKED
		RESKED
		OKINT
		JRST HALTF1]	;HALT THIS ONE
FLOGO1:				;LOGOUT PSI REQUEST ENTERS HERE
IFDEF DSPCHN,<
	SETO 1,
	RELDP
	RELDC>
	SETO 1,
	CLOSF			;CLOSE FILES
	JFCL
	MOVEI 1,-4
	KFORK			;DELETE FORKS
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	MOVE 1,JOBNO
	HLRZ 1,JOBDIR(1)	;CONNECTED DIRECTORY
	DELDF			;DELETE DELETED FILES
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	MOVE 1,JOBNO
	HRRZ 1,JOBDIR(1)
	JUMPE 1,LOG1		;IF JOB NOT LOGGED IN
	MOVE 1,LOGDES
	CALL LOGTOT		;SUMMARY TO LOG TTY
LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	MOVEI 1,400000(1)	;YES, PRINT LOGOUT MESSAGE
	CALL LOGTOT
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
	MOVE 2,CTRLTT
	CALL TTHNGU		;HANG UP LINE
LOG2:	JRST HLTJB

ELOGO:	MOVE 2,JOBNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN 2,0(1)		;SELF?
LOGOE1:	RETERR LOUTX1		;YES, CAN'T SAY IT THAT WAY
	CAIGE 1,NJOBS		;REASONABLE NUMBER?
	CAIGE 1,0
LOGOE2:	RETERR LOUTX2		;NO
	SKIPGE JOBRT(1)		;EXISTS?
	JRST LOGOE2
	HRRZ 3,JOBDIR(1)	;LOGIN DIRECTORY OF OBJECT JOB
	XOR 3,JOBDIR(2)
	TRNN 3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	MOVEI 3,WHEEL+OPER	;OTHERWISE MUST BE WHEEL
	TDNN 3,CAPENB
	JRST LOGOE1		;ILLEGAL
ELOGO1:	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	NOSKED
	MOVSI 1,400000+PSILOB
	IORM 1,FKINT(2)		;REQUEST LOGOUT
	CALL PSIR4
	OKSKED
	RESKED
	AOS 0(P)		;RETURN GOOD
	JRST MRETN

FLOGO:	SKIPGE SLOWF		;ALREADY IN JSYS?
	JSYS MENTR		;NO, DUMMY UP ENTRY
	NOINT
	MOVE P,UPP		;MAKE SURE WE HAVE EMPTY STACK
	ADD P,BHC+2
	JRST FLOGO1

;LOGGING FUNCTIONS

	INTERN LOGTOT,LOGDES,LOGONM,LOGCJM

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT:	CAIL 1,0
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /KILLED/]
	CALL LOGMES
	CALL LOGJOB		;PRINTS JOB NO, TTY NO, TIME
	HRROI 2,[ASCIZ /
  USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5		;FOR WHOLE JOB
	RUNTM
	MOVEM 1,3(7)		;RUNTIME FOR EFACT
	MOVEM 3,4(7)		;CONSOLE TIME FOR EFACT
	MOVE 2,1
	POP P,1
	PUSH P,3
	CALL LOGTIM		;PRINT CPU TIME
	HRROI 2,[ASCIZ / IN /]
	CALL LOGMES
	POP P,2
	CALL LOGTIM		;PRINT CONSOLE TIME
	CAME 1,LOGDES		;ON LOG TTY?
	JRST LOGCR		;NO
	MOVEI 2,141		;LOGOUT CODE
	DPB 2,[POINT 9,0(7),8]
	PUSH P,1
	MOVSI 1,-5		;SIZE OF LOGOUT BLOCK
LOGFCT:	HRRI 1,0(7)		;LOC OF LOGOUT BLOCK
	EXCH 1,0(P)		;OUTPUT DESIGNATOR
	CALL LOGCR
	EXCH 1,0(P)
	NOINT
	PUSH P,CAPENB
	MOVSI 2,LOG
	IORM 2,CAPENB		;BE SURE WE HAVE LOG CAPABILITY
	EFACT
	BUG(CHK,<EFACT FAILED - LOGIN, LOGOUT, ATTACH, ETC.>)
	POP P,CAPENB		;RESTORE CAPS
	OKINT
	POP P,1
	RET

;LOGON MESSAGE, CALLED FROM .LOGIN

LOGONM:	SKIPL 1,LOGDES
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /LOGIN/]
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,501		;LOGIN CODE
LOGCJ1:	DPB 1,[POINT 9,0(7),8]
	MOVE 1,4(7)		;ACCOUNT WORD
	JUMPL 1,[SUBI 1,4	;STRING ACCOUNT, ROUND CHAR COUNT
		IDIVI 1,5	;COMPUTE WORD COUNT
		MOVSI 1,-5(1)	;ADD WORD COUNTS FOR STRING AND BLOCK
		JRST .+2]
	MOVSI 1,-5		;WORD COUND INCLUDES BLOCK ONLY
	JRST LOGFCT

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM:	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /CHANGED/]
	CALL LOGMES
	CALL LOGJOB
	HRROI 2,[ASCIZ /
 USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5
	RUNTM			;RUNTIME OF JOB
	MOVEM 1,3(7)		;SAVE FOR FACT FILE
	MOVE 2,1
	POP P,1
	CALL LOGTIM		;PRINT ON LOG TTY
	PUSH P,1
	MOVEI 1,502
	JRST LOGCJ1

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

DETMSG:	HRROI 2,[ASCIZ /DETACHED/] ;WORD FOR LOG TTY
	SKIPL 1,LOGDES
	DOBE
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,143		;DETACH CODE
ATAMS2:	DPB 1,[POINT 9,0(7),8]
	MOVSI 1,-3		;SIZE OF BLOCK
	JRST LOGFCT

ATAMSG:	MOVEI 7,LOGBUF
	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /ATACHED JOB /]
	CALL LOGMES
	HLRZ 2,0(7)		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / TO TTY /]
	CALL LOGMES
	LDB 2,[POINT 12,0(7),29] ;TTY NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
	PUSH P,1
	MOVEI 1,142		;ATACH CODE
	JRST ATAMS2

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

LOGJOB:	MOVEI 7,LOGBUF		;BLOCK FOR EFACT
	HRROI 2,[ASCIZ / JOB /]
	CALL LOGMES
	MOVE 2,JOBNO
	DPB 2,[POINT 9,0(7),17]	;JOB NUMBER FOR EFACT
	CALL LOGNUM
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, USER /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRRM 2,1(7)		;DIRECT NUMBER FOR EFACT
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	JFCL
	HRROI 2,[ASCIZ /, ACCT /]
	CALL LOGMES
	MOVE 2,ACCTPT
	CALL LOGACC
LOGJ3:	MOVE 2,CTRLTT
	DPB 2,[POINT 12,0(7),29] ;TTY NUMBER FOR EFACT
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,CTRLTT
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:	HRROI 2,[ASCIZ /, AT /]
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	GTAD
	MOVEM 1,2(7)		;TOD FOR EFACT
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	MOVSI 3,045240		;MOST ABBREVIATED DATE AND TIME
	CAIL 2,0
	ODTIM
	RET

LOGJ1:	HRROI 2,[ASCIZ /, DETACHED/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	LDB 3,[POINT 3,2,2]
	CAIE 3,5		;STRING OR NUMBER?
	JRST LOGAC1		;STRING
	TLZ 2,700000
	MOVEM 2,4(7)		;ACCOUNT NUMBER FOR EFACT
	JRST LOGNUM		;PRINT NUMBER

LOGAC1:	SETZ 4,			;TO COUNT CHARS
	MOVE 3,2		;STRING PTR
LOGAC2:	ILDB 2,3		;CHAR OF ACCOUNT STRING
	JUMPE 2,LOGAC3		;NULL IS END OF STRING
	CAIL 1,0
	BOUT			;PRINT IT ON LOG TTY
	AOJA 4,LOGAC2		;COUNT IT

LOGAC3:	MOVNM 4,4(7)		;LEAVE NEG OF WORD COUNT FOR EFACT
	RET

LOGMES:	SETZ 3,
	JUMPL 1,R
	SOUT
	RET

LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	JUMPL 1,R
	NOUT
	BUG(CHK,<LGNOUT - NOUT FAILED>)
	RET

LOGCR:	MOVEI 2,EOL
	JUMPL 1,R
	BOUT
	RET

LOGDES:	LOGTTY!400000		;LOG TTY OR -1

;FORK CREATION AND CONTROL JSYS'S

.CFORK:	JSYS MENTR
	NOINT
	MOVEI 1,-1
	CALL GFKH		;GET LOCAL HANDLE
	RETERR FRKHX6		;NONE
	PUSH P,1		;SAVE IT
	NOSKED
	MOVE 2,SPTC		;CURRENT SPT COUNT
	CAML 2,SPC1		;ROOM LEFT?
	JRST CFBAD		;NO
	SKIPE FREFK		;ROOM IN SYSTEM?
	SKIPN FREJFK		;ROOM IN JOB?
	JRST CFBAD		;NO
	CALL ASSFK		;ASSIGN FORK IN SYSTEM
	MOVE 1,FORKX
	MOVE 1,FKJOB(1)		;GET JOB NO AND JSB
	MOVEM 1,FKJOB(7)	;SET FOR NEW FORK
	OKSKED
	MOVSI 1,0(7)
	CALL WAITFK		;WAIT FOR IT TO INITIALIZE
	CALL ASSJFK		;ASSIGN JOB FORK SLOT
	HRRZM 7,SYSFK(1)
	SETZM FKPTRS(1)
	HRRZ 2,FORKN		;PUT NEW FORK INTO STRUCTURE LISTS
	MOVEI 6,FKPTRS(2)
	HLL 6,INFERP
	LDB 3,6			;GET INFERIORS OF THIS FORK
	DPB 1,6			;PUT NEW FORK AT HEAD OF IT
	MOVEI 6,FKPTRS(1)
	HLL 6,SUPERP
	DPB 2,6			;THIS FORK IS SUPERIOR OF NEW FORK
	HLL 6,PARALP
	DPB 3,6			;OTHER INFERIORS ARE PARALLEL TO NEW FORK
	PUSH P,1
	CALL SETLF1		;MAP PSB OF NEW FORK
	MOVE 2,0(P)		;NEW FORK'S JOB HANDLE
	MOVEM 2,FORKN(1)
	MOVE 2,JOBNO
	MOVEM 2,JOBNO(1)
	MOVE 2,PRIMRY
	MOVEM 2,PRIMRY(1)
	MOVE 2,JOBBIT
	MOVEM 2,JOBBIT(1)	;PASS PRIORITY
	SETZM CAPMSK(1)
	SETZM CAPENB(1)
	UMOVE 2,1		;GET ARG
	TLNE 2,(1B1)		;GIVE SPEC CAP?
	CALL CFK3
	TLNE 2,(1B3)		;INIT AC'S?
	CALL CFK1		;YES
	TLNE 2,(1B4)		;START FORK
	CALL CFK2
	CALL CLRLFK		;UNMAP PSB
	POP P,1
	MOVE 2,0(P)		;LOCAL HANDLE
	ANDI 2,377777
	IDIVI 2,2
	ADD 2,FKPTAB(3)
	DPB 1,2			;PUT JOB INDEX IN LOCAL TABLE
	POP P,1			;RETURN LOCAL HANDLE
	UMOVEM 1,1
	AOS 0(P)
	JRST MRETN

CFBAD:	OKSKED
	RETERR CFRKX3		;NO ROOM

;FORK CONTROL SUBRS

CFK1:	XCTUU [HRLZ 3,2]	;GET LOC OF INITIAL AC'S
	HRRI 3,PAC(1)		;MOVE TO NEW FORK'S PSB
	XCTUM [BLT 3,PAC+17(1)]
	RET

CFK2:	MOVEI 3,0(2)		;START ADDRESS
	HRLI 3,UMODF		;IN USER MODE
	MOVEM 3,PPC(1)
	MOVEI 3,JSKP
	MOVEM 3,FKSTAT(7)	;MAKE FORK RUNNABLE
	RET

CFK3:	MOVE 3,CAPMSK		;GIVE NEW FORK SAME SPEC CAP
	MOVEM 3,CAPMSK(1)
	MOVE 3,CAPENB
	MOVEM 3,CAPENB(1)
	RET

WAITFK:	HRRI 1,WTFKT
	JSYS EDISMS
	RET

	RESCD			;SCHEDULER TEST, MUST BE RESIDENT

WTFKT:	HLRZ 2,FKPT(1)		;SCHEDULER TEST - GET STATE OF FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	JRST 1(4)		;YES

	SWAPCD

ASSJFK:	NOSKED
	MOVE 1,@FREJFK
	EXCH 1,FREJFK
	OKSKED
	SUBI 1,FKPTRS
	RET

.SEVEC:	JSYS MENTR
	CALL SETLFK
	HLRZ 3,2		;GET SIZE
	CAIN 3,<JRST>B53	;10/50 STYLE?
	JRST SEV1		;YES
	CAIL 3,1
	CAIL 3,1000
ESVX1:	ITERR SEVEX1		;NOT LEGAL
SEV1:	MOVEM 2,ENTVEC(1)
	JRST CLFRET

.GEVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,ENTVEC(1)
GCV1:	UMOVEM 2,2
	JRST CLFRET

;GET/SET COMPATIBILITY ENTRY VECTOR AND PARAMETERS

.GCVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PATADR(1)
	MOVE 3,PATUPC(1)
	HRL 3,PATU40(1)
	UMOVEM 3,3
	JRST GCV1

.SCVEC:	JSYS MENTR
	CALL SETLFK
	MOVEM 2,PATADR(1)
	HRRM 3,PATUPC(1)
	HLRM 3,PATU40(1)
	JRST MRETN

;GET TRAP WORDS FROM FORK

	INTERN .GTRPW

.GTRPW:	JSYS MENTR
	CALL SETLFK		;MAP PSB
	MOVE 2,UTRSW(1)		;TRAP STATUS WORD
	UMOVEM 2,1		;RETURNED IN 1
	MOVE 2,UTRWD(1)		;WRITE DATA
	UMOVEM 2,2		;RETURNED IN 2
	JRST CLFRET

;SET SCHEDULER PRIORITY WORD

	INTERN .SPRIW

.SPRIW:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX		;MUST BE PRIVILEGED
	CALL SETLFK
SPRI1:	UMOVE 2,2
	MOVEM 2,JOBBIT(1)
	JRST CLFRET

;SET PRIORITY WORD FOR ANOTHER JOB

.SJPRI:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX
	NOINT
	CAIL 1,0		;LEGAL JOB NUMBER?
	CAIL 1,NJOBS
	JRST MRETN		;NO
	SKIPGE JOBRT(1)		;JOB EXISTS?
	JRST MRETN		;NO
	HRRZ 1,JOBPT(1)		;TOP FORK
	HRRZ 1,FKPGS(1)		;ITS PSB
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB
	AOS 0(P)		;DO SKIP RETURN FOR OK
	JRST SPRI1

;GET AND SET PRIMARY IO JFN'S

	INTERN .GPJFN,.SPJFN

.GPJFN:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PRIMRY(1)
	UMOVEM 2,2
	JRST CLFRET

.SPJFN:	JSYS MENTR
	CALL SETLFK
	UMOVE 2,2
	MOVEM 2,PRIMRY(1)
	JRST CLFRET

;KILL FORKS

.KFORK:	JSYS MENTR
	CALL MAPFKH		;FREEZE ALL FORKS FIRST
	 CALL FFORK1		;TO BE SURE THEY ARE INTERRUPTABLE
	UMOVE 1,1
	NOINT
	MOVEI 1,0(1)
	CAIN 1,-4		;ALL INFERIORS?
	JRST KFORK2		;YES
	CALL SETJFK		;NO, ANY ONE FORK
	CALL KFORK1		;KILL IT
	JRST MRETN

KFORK2:	CALL KALLI		;KILL ALL INFERIORS
	JRST MRETN

KFORK1:	JUMPE 1,R		;DON'T KILL TOP FORK
	CALL SKIIF
	ITERR FRKHX2		;DONT KILL NON-INFERIOR FORKS
KFORK0:	CALL DASFKH		;DEASSIGN LOCAL FORK HANDLE
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS FORK?
	ITERR KFRKX2		;CAN'T KILL SELF
	MOVE 5,6		;REMOVE FORK FROM STRUCTURE
	ADD 5,SUPERP
	LDB 5,5			;GET SUPERIOR
	ADD 5,INFERP
KFK01:	LDB 4,5			;GET NEXT PARALLEL
	CAIN 4,0(6)		;DESIRED FORK?
	JRST KFK02		;YES
	MOVE 5,4
	ADD 5,PARALP
	JRST KFK01

KFK02:	ADD 4,PARALP		;FOUND FORK TO BE KILLED IN LIST
	LDB 4,4
	DPB 4,5			;PUT NEXT IN LAST, REMOVING FORK FROM LIST
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;SUSPEND FORK
	NOSKED
	MOVEI 2,KSELF
	MOVEM 2,PPC(1)		;START IT SO AS TO KILL ITSELF
	MOVEI 2,JSKP
	HRRM 2,FKSTAT(7)
	OKSKED
	RESKED
	CALL CLRLFK
	MOVSI 1,0(7)
	HRRI 1,KFK0T
	JSYS EDISMS		;WAIT TILL FORK IS KILLED
	MOVEI 1,JSKP
	HRRM 1,FKSTAT(7)	;LET IT FINISH UP
	MOVEI 1,FKPTRS(6)
	EXCH 1,FREJFK		;PUT JOB SLOT BACK ON LIST
	MOVEM 1,@FREJFK
	RET

;FORK KILL SELF

	INTERN KSELF

KSELF:	MOVE 7,FORKX
	MOVSI 1,200000
	MOVEM 1,FKINT(7)	;DISABLE ANY FURTHER INTERRUPTS
	MOVSI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR		;GET INTO REASONABLE MONITOR STATE
	SETZM PSIBW
	CALL DTIALL		;DEASSIGN TERM INTERRUPTS
	MOVE 1,[1B4+400000]	;REASSIGN STILL-MAPPED FILES
	CLZFF			;CLOSE FILES HERE AND BELOW
IFDEF IMPCHN,<
	CALL NETKFK>		;FLUSH FORK FROM NET TABLES
IFDEF DSPCHN,<
	CALL DSPKFK>		; RELEASE DISPLAY PROCESSES OF THIS FORK
	CALL KALLI
	MOVE 7,FORKX
	HLRZ 1,FKPGS(7)
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT OF UPT
	PUSH P,2		;SAVE IT FOR LATER CHECK
	SETO 1,
	MOVSI 2,400000
KSEF1:	PMAP			;CLEAR ALL PAGES FROM USER MAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF1
	HRRZ 1,FORKN
	SETOM SYSFK(1)		;INDICATE FORK NOW KILLED
	MOVEI 1,KRET
	JSYS EDISMS		;AND WAIT TILL NOTIFICATION SEEN
KSEF2:	POP P,2			;SHARE COUNT OF UPT
	CAIE 2,1		;UNSHARED?
	JRST KSEF3
	MOVE 7,FORKX
	SETZM PSB+UPTPG
	SETZM PSB+UACPG
	SETZM PSB+JSBPG		;CLEAR SPECIAL MAP WORDS
	MOVE 6,[XWD CPTPG+1-PSBPG,CPTPG+1]
	HRLZ 2,FKPGS(7)
	CALL CLRM0		;CLEAR PP AREA OF MON MAP
	CALL WTFPGS		;WAIT FOR UPT AND PSB TO BE UNMAPPED
	JRST HLTFK1		;GO DELETE UPT AND PSB

KSEF3:	MOVEI 1,^D5000
	DISMS			;WAIT FOR 5 SECS
	HLRZ 1,FKPGS(7)		;THEN CLEAR MAP AGAIN
	LDB 2,[POINT 14,SPT(1),13]
	PUSH P,2
	SETZ 1,
	HLLZ 2,FKPGS(7)
KSEF4:	CALL SETPT		;BUT NOT USING PMAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF4
	JRST KSEF2

	RESCD

KFK0T:	HRRZ 2,FKSTAT(1)
	CAIE 2,KRET		;WAIT TILL FORK ALMOST KILLED STATE
KRET:	JRST 0(4)
	JRST 1(4)

FRZWT:	JRST 0(4)

	SWAPCD

KALLI:	HRRZ 1,FORKN
	ADD 1,INFERP
	LDB 1,1			;GET NEXT INFERIOR
	JUMPE 1,R		;NO MORE
	CALL KFORK0		;KILL ALL INFERIORS TOO
	JRST KALLI

;FREEZE FORK

.FFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL FFORK1
	JRST MRETN

FFORK1:	JUMPE 1,R		;NOT TOP FORK
	CALL STPFK		;STOP FORK
	HRRZ 2,FKSTAT(7)
	CAIN 2,FRZWT		;ALREADY FROZEN?
	JRST FFORK2		;YES
	MOVEI 2,FRZWT
	HRRM 2,FKSTAT(7)
FFORK2:	OKSKED
	JRST CLRLFK

;RESUME FORK

.RFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL RFORK1
	JRST MRETN

RFORK1:	JUMPE 1,R
	CALL STPFK		;NOP IF ALREADY FROZEN
	SKIPN 2,PIOLDS(1)	;WAS RUNNING BEFORE FREEZE?
	MOVEI 2,JSKP		;YES
	JRST RFORK2		;GO SET NEW STATUS

;READ FORK STATUS

.RFSTS:	JSYS MENTR
	TRNE 1,200000		;LOCAL DESIGNATOR?
	JRST RFST9		;NO
	ANDI 1,377777
	JUMPE 1,RFST9		;THIS FORK
	CAIL 1,NLFKS		;LEGAL?
	ITERR FRKHX1		;NO
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	CAIA
	JRST RFST8		;YES
	SETO 1,			;NOT ASSIGNED, RETURN -1
	JRST RFSTSR

RFST9:	CALL SETJFK		;NOT MULTIPLE FORKS
RFST8:	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	MOVE 2,PPC(1)		;GET PC
	TLNN 2,UMODF		;USER MODE?
	MOVE 2,UPDL(1)		;NO, USER PC IS FIRST ON STACK
	UMOVEM 2,2
	CALL CLRLFK
	HLRZ 1,FKPT(7)
	CAIN 1,WTLST		;WAITING?
	JRST RFST1		;YES
	SETZ 1,			;RUNNING, RETURN 0
RFSTSR:	UMOVEM 1,1
	JRST MRETN

RFST1:	HRRZ 2,FKSTAT(7)	;IS WAITING, GET STATE
	SETZ 1,
	CAIN 2,FRZWT		;FROZEN?
	JRST RFST4		;YES
RFST5:	CAIN 2,FORCTM		;FORCED TERMINATION?
	JRST RFST3		;YES
	CAIN 2,JRET		;REGULAR TERMINATION?
	JRST RFST2		;YES
	CAIE 2,TRMTST		;WAITING FOR FORK TERMINATION
	CAIN 2,TRMTS1		;EITHER FLAVOR?
	JRST RFST6		;YES
	TLO 1,1			;N.O.T.A., MUST BE I/O
	JRST RFSTSR

RFST2:	TLO 1,2			;REGULAR TERMINATION GIVES 2
	JRST RFSTSR

RFST6:	TLO 1,4
	JRST RFSTSR

RFST3:	PUSH P,1
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	MOVE 2,FORCTC(1)	;GET CHANNEL CAUSING FORCED TERM
	HRRM 2,0(P)		;PUT IN RH OF STATUS WORD
	CALL CLRLFK
	POP P,1
	TLO 1,3			;WITH 3 INDICATING FORCED TERM
	JRST RFSTSR

RFST4:	TLO 1,400000		;FROZEN, INDICATE IN BIT 0
	HLRZ 2,FKSTAT(7)	;AND GET OLD STATUS
	JUMPE 2,RFSTSR
	JRST RFST5

;START FORK VIA ENTRY VECTOR

.SFRKV:	JSYS MENTR
	CALL SETJFK
	PUSH P,1
	CALL SETLF1
	UMOVE 2,2		;GET RELATIVE POSITION
	HLRZ 3,ENTVEC(1)	;SIZE OF VEC IN DEST FORK
	CAIN 3,<JRST>B53	;OLD TYPE?
	MOVEI 3,2		;YES, IMPLIES 2
	CAIL 3,1		;REASONABLE VECTOR LENGTH?
	CAIL 3,1000
	JRST SFRKV2		;NO
	CAIL 2,0(3)		;LEGAL ARG?
	JRST SFRKV2		;NO
	MOVEM 2,FORCTC(1)	;LEAVE FOR FOR TO START SELF
	CALL CLRLFK
	POP P,1			;RECOVER JOB HANDLE
	CALL STPFK
	SETOM SLOWF(1)
	MOVEI 2,SFRKV1		;START FORK IN MONITOR
	JRST SFORK1

SFRKV2:	CALL CLRLFK
	ITERR SFRVX1		;ILLEGAL RELATIVE NUMBER

SFRKV1:	MOVEM 1,FPC		;ENTER HERE FORK STARTS SELF
	MOVSI 1,UMODF		;AT ENTVEC + C(FORTCT)
	EXCH 1,FPC
	JSYS MENTR
	HRRZ 1,ENTVEC
	MOVE 2,FORCTC		;RELATIVE ADDRESS
	HLRZ 3,ENTVEC		;SIZE OR JRST
	CAIN 3,<JRST>B53	;OLD STYLE?
	JRST SFRKV3		;YES
	ADDI 1,0(2)
SFRKV4:	HRRM 1,0(P)
	JRST MRETN		;START IN USER MODE

SFRKV3:	CAIN 2,0		;0 MEANS JOBSA
	UMOVE 1,120
	CAIN 2,1		;1 MEANS JOBREN
	UMOVE 1,124
	JRST SFRKV4

;START FORK

.SFORK:	JSYS MENTR
	CALL SETJFK
	CALL STPFK		;STOP FORK
	UMOVE 2,2
	TLZ 2,UIOF+2037		;USER I/O, CALFRMMON, IDX AND IND OFF
	TLO 2,UMODF		;AND USER ON
SFORK1:	SETOM SLOWF(1)		;NORMALIZE FLAG
	EXCH 2,PPC(1)		;SET PC
	TLNE 2,UMODF		;WAS IN USER MODE?
	JRST SFORK2		;YES
	MOVSI 2,UACB(1)		;NO, MOVE AC'S
	HRRI 2,PAC(1)
	BLT 2,PAC+17(1)
SFORK2:	MOVEI 2,JSKP
	MOVEM 2,FKSTAT(7)	;MAKE FORK RUNNABLE
	CALL CLRSFK		;AND CLEAR SUSPENSION
	OKSKED
	RESKED
	JRST CLFRET

;STOP FORK, USED BY SEVERAL FORK JSYS'S

STPFK:	CALL SKIIF		;JOB FORK NUMBER IN 1, IS INFERIOR?
	JRST FRKE2		;NO
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS SAME FORK?
	ITERR			;YES
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;NO, SUSPEND FORK
	NOSKED
	RET

;READ/SET FORK AC'S

.RFACS:	JSYS MENTR
	CALL FACS
	MOVS 3,3
	MOVEI 2,17(3)
	XCTMU [BLT 3,0(2)]	;FROM FORK'S PSB TO USER
	OKSKED
	JRST MRETN

.SFACS:	JSYS MENTR
	CALL FACS
	MOVEI 2,17(3)
	XCTUM [BLT 3,0(2)]	;FROM USER TO FORK'S PSB
	OKSKED
	JRST MRETN

;COMMON AC ROUTINE

FACS:	CALL SETJFK		;ONE FORK ONLY
	CALL SKIIF		;AND IT MUST BE INFERIOR
FRKE2:	ITERR FRKHX2
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING?
	ITERR FRKHX4		;YES
	MOVE 2,PPC(1)		;GET PC
	MOVEI 3,PAC(1)		;LOC OF AC'S
	TLNN 2,UMODF		;IF IN USER MODE, OTHERWISE
	MOVEI 3,UACB(1)		;AC'S ARE IN FIRST AC BLOCK
	XCTUU [HRL 3,2]		;GET ADDRESS OF USER'S BLOCK
	RET

;HALT FORK

.HFORK:	JSYS MENTR
	CALL MAPFKH
	 CALL HFORK1
	JRST MRETN

HFORK1:	JUMPE 1,R		;NOT TOP SORK
	CAMN 1,FORKN		;THIS FORK?
	JRST HALTF1		;YES, MAKE LIKE HALTF
	CALL STPFK		;STOP THE FORK
	MOVEI 2,JRET
RFORK2:	MOVEM 2,FKSTAT(7)	;TERMINATED STATE
	CALL CLRSFK		;BUT INTERRUPTABLE
	JRST FFORK2

;CALL FROM TTY SERVICE TO RESOLVE FORK CONFLICT

TTFRKT:	SKIPGE 2,SYSFK(1)	;DOES OTHER FORK REALLY EXIST?
	RET			;NO
	HRRZ 2,FKSTAT(2)	;GET ITS STATUS
	CAIE 2,TCITST		;STILL WAITING FOR TTY?
	RET			;NO
	CALL SKIIF		;IS IT INFERIOR
	JRST HALTF1		;NO, HALT OURSELF
	JRST HFORK1		;HALT THE OTHER GUY

;WAIT FOR FORK TO TERMINATE

.WFORK:	JSYS MENTR
	CAIN 1,-4		;ALL INFERIORS?
	JRST WFORK2		;YES
	CALL SETJFK		;ONE FORK, GET ITS JOB HANDLE
	HRLZ 1,SYSFK(1)		;SETUP TEST ON FORK INDEX
	HRRI 1,TRMTST
	JSYS EDISMS		;AND DISMISS
	JRST MRETN

WFORK2:	MOVEI 1,TRMTS1		;SETUP TEST TO WAIT UNTIL CHANGED
	JSYS EDISMS
	JRST MRETN

	RESCD

TRMTST:	HLRZ 2,FKPT(1)		;SCHEDULER TEST, GET LOC OF FORK  NOW
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	HRRZ 2,FKSTAT(1)
	CAIE 2,JRET		;WAITING BECAUSE TERMINATION?
	CAIN 2,FORCTM		;OR FORCED TERM?
	JRST 1(4)		;YES
	JRST 0(4)		;NO, KEEP WAITING

TRMTS1:	JRST 0(4)

	SWAPCD

;SUSPEND FORK SO IT CAN BE DIDDLED

SUSFK:	PUSH P,1
	PUSH P,2
	CAMN 7,FORKX
	BUG(HLT,<SUSFK - GIVEN SELF AS ARG>)
SUSF6:	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING NOW?
	JRST SUSF4		;NO
	HRRZ 2,FKSTAT(7)	;GET WAITING STATUS
	CAIE 2,SUSWT		;ALREADY SUSPENDED OR FROZEN?
	CAIN 2,FRZWT
	JRST SUSF2		;YES
	CAIE 2,TCITST		;CAME FROM TTY WAIT?
	JRST SUSF5		;NO
	HLRZ 1,FKSTAT(7)	;YES, GET LINE
	HLLOS TTFORK(1)		;CLEAR WAITING STATE FROM LINE
SUSF5:	MOVSI 1,400000+SUSFKR	;SUSPEND FORK REQUEST BIT FOR PSI
	IORM 1,FKINT(7)		;LEAVE IT FOR SPECIFIED FORK
	MOVEI 2,0(7)
	CALL PSIR4		;INTERRUPT THE FORK
	OKSKED
	MOVSI 1,0(7)		;SETUP SCHEDULER TEST TO WAIT
	HRRI 1,SUSFKT		;UNTIL FORK HAS SUSPENDED ITSELF
	JSYS EDISMS
SUSF3:	POP P,2
	POP P,1
	RET

SUSF2:	OKSKED
	JRST SUSF3

SUSF4:	SKIPN FKINT(7)		;TRANSITIONAL STATE?
	JRST SUSF5		;NO
	OKSKED			;YES, WAIT AWHILE
	MOVEI 1,^D500
	DISMS
	JRST SUSF6		;AND CHECK AGAIN

;SCHEDULER TEST FOR SUSPENSION

	RESCD

SUSFKT:	HLRZ 2,FKPT(1)		;GET LOC OF SPECIFIED FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)
	HRRZ 2,FKSTAT(1)
	CAIE 2,SUSWT		;SUSPENSION?
	CAIN 2,FRZWT
	JRST 1(4)
	JRST 0(4)

	SWAPCD

;CLEAR FORK WHICH HAD BEEN SUSPENDED

CLRSFK:	MOVSI 2,200000
	ANDCAM 2,FKINT(7)	;CLEAR PSI STARTING STATE
	RET

;PERFORM MAPPING FOR FORK CONTROL FUNCTION WHICH OPERATE ON SEVERAL
;FORKS

	INTERN MAPFKH

MAPFKH:	HRROI 1,0(1)		;GET FORK HANDLE
	TRNN 1,200000		;SPECIAL?
	ANDI 1,377777		;NO
	JUMPLE 1,MAPFK1
	CAIL 1,NLFKS
	ITERR FRKHX1
	IDIVI 1,2		;REGULAR HANDLE, GET JOB HANDLE
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	ITERR FRKHX1		;NO
	RET			;RETURN AND DO FUNCTION ONCE

MAPFK1:	ADDI 1,2
	JUMPL 1,MAPFK2		;MULTIPLE INDICATION
	XCT SETJFT(1)		;SINGLE, GET JOB HANDLE
	RET

MAPFK2:	ADDI 1,3
	JUMPGE 1,MAPFT(1)	;GO TO ROUTINE
	ITERR FRKHX1		;HANDLE ILLEGAL

MAPFT:	JRST MAPF5		;-5, ALL FORKS IN JOB
	JRST MAPF4		;-4, ALL INFERIORS
	JRST MAPF3		;-3, SELF AND ALL INFERIORS

MAPF3:	HRRZ 1,FORKN		;SELF
MAPF51:	PUSH P,1
	XCT @-1(P)		;DO THIS FORK
	POP P,1
MAPFI:	MOVE 16,@0(P)		;GET INSTRUCTION, WILL STAY IN 16
MAPF41:	ADD 1,INFERP		;DO INFERIORS
MAPF42:	LDB 1,1			;GET NEXT IN LIST
	JUMPE 1,RSKP		;END OF LIST, RETURN AND SKIP INSTR
	HRLM 1,0(P)		;SAVE THIS FORK NUMBER
	CALL MAPF41		;DO INFERIORS OF IT
	BUG(HLT,<MAPF41 FAILED TO SKIP>)
	HLRZ 1,0(P)		;GET FORK NUMBER BACK
	XCT 16			;DO THIS FORK
	HLRZ 1,0(P)
	ADD 1,PARALP		;POINT TO NEXT IN LIST
	JRST MAPF42

MAPF4:	HRRZ 1,FORKN		;GET SELF
	JRST MAPFI		;DO INFERIORS

MAPF5:	HLRZ 1,FORKN		;GET TOP
	JRST MAPF51		;DO THAT AND INFERIORS

;FORK RELATIVITY TESTS

	INTERN SKIIF,SKISF,SKIIFA

;SKIP IF FORK IN 1 IS INFERIOR TO SELF

SKIIF:	PUSH P,2
	HRRZ 2,FORKN		;GET SELF
	CALL SKIIFA		;DO TEST
	JRST POP2		;RETURN NO SKIP
SKISF2:	POP P,2
	JRST RSKP

;SKIP IF FORK IN 1 IS INFERIOR TO FORK IN 2

SKIIFA:	HRLM 2,0(P)		;SAVE FORK NUMBER
SKIIF4:	CAIN 1,0(2)		;SAME?
	JRST SKIIF1		;YES
	ADD 2,INFERP		;NO, GET POINTER TO INFERIOR LIST
SKIIF2:	LDB 2,2			;NEXT INFERIOR
	JUMPE 2,SKIIF6		;END OF LIST
	CALL SKIIFA		;IS THIS FORK OR INFERIOR?
	JRST SKIIF5		;NO
SKIIF1:	HLRZ 2,0(P)		;SUCCEEDS, RETURN +2
	JRST RSKP

SKIIF6:	HLRZ 2,0(P)
	RET			;FAILS RETURN +1

SKIIF5:	ADD 2,PARALP		;LOOK PARALLEL
	JRST SKIIF2

;SKIP IF FORK IN 1 IS SUPERIOR OF THIS FORK

SKISF:	PUSH P,2
	HRRZ 2,FORKN
SKISF1:	CAIN 1,0(2)
	JRST SKISF2		;SAME, RETURN GOOD
	JUMPE 2,POP2		;END OF LIST, RETURN BAD
	ADD 2,SUPERP		;GET SUPERIOR POINTER
	LDB 2,2
	JRST SKISF1

;JSYS'S FOR CONTROLLING PSI SYSTEM

	INTERN .SIR,.EIR,.SKPIR,.DIR,.AIC,.IIC,.DIC
	INTERN .RCM,.RWM,.ATI,.DTI,.CIS

;MAP PSB OF FORK, GIVEN USER HANDLE IN 1
;RETURN WITH OFFSET TO MAPPED PSB IN 1

SETLFK:	TRNE 1,200000		;SPECIAL DESIGNATOR?
	JRST FRKE1		;NOT ALLOWED
	CALL SETJFK		;GET JOB FORK INDEX
SETLF1:	NOINT
	HRRZ 1,SYSFK(1)		;GET SYSTEM FORK INDEX
	CAMN 1,FORKX		;CURRENT FORK?
	JRST SETLF2		;YES
	HRRZ 1,FKPGS(1)		;GET PSB OF DESIGNATED FORK
	PUSH P,2
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB	;RETURN OFFSET USUAL PSB TO MAP PSB
	JRST POP2

SETLF2:	SETZ 1,			;USE CURRENT PSB, NO OFFSET
	RET

CLRLFK:	SKIPN PSB+FPBPG		;NOW MAPPED?
	JRST CLRLFX		;NO
	SETZ 1,
	MOVEI 2,FPBPGA
	CALL SETMPG
CLRLFX:	OKINT
	RET

;GET JOB FORK HANDLE GIVEN USER HANDLE IN 1
;FOR SINGLE (NOT MULTIPLE) FORK HANDLES ONLY

SETJFK:	HRROI 1,0(1)
	TRNN 1,200000
	ANDI 1,377777
	JUMPLE 1,SETJF1
	CAIL 1,NLFKS
FRKE1:	ITERR FRKHX1
	PUSH P,2
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1			;GET JOB FORK INDEX (HALF WORD)
	CAIGE 1,NUFKS		;FORK HANDLE ASSIGNED?
	SKIPG SYSFK(1)
	JRST FRKE1		;NO
	JRST POP2

SETJF1:	ADDI 1,2
	JUMPL 1,ITRAP
	XCT SETJFT(1)
	RET

SETJFT:	HLRZ 1,FORKN		;-2, TOP FORK
	CALL GETSPF		;-1, SUPERIOR
	HRRZ 1,FORKN		;0, CURRENT

GETSPF:	HRRZ 1,FORKN		;GET SUPERIOR FORK
	MOVE 1,FKPTRS(1)
	LSH 1,-^D24
	RET

.SIR:	JSYS MENTR
	CALL SETLFK
	JUMPE 2,SIR1		;ALL 0 IS LEGAL
	HLRZ 3,2		;GET ADDRESSES GIVEN
	MOVEI 4,0(2)
	CAIL 3,20		;BOTH .GE. 20?
	CAIGE 4,20
	ITERR SIRX1		;NO
SIR1:	MOVEM 2,LEVCHN(1)
CLFRET:	CALL CLRLFK
	JRST MRETN

.EIR:	JSYS MENTR
	TRNE 1,200000		;SPECIAL?
	ITERR FRKHX1		;ILLEGAL
	CALL SETJFK
	PUSH P,SYSFK(1)		;REMEMBER FORK INDEX
	CALL SETLF1		;MAP PSB
	SETZM PSISYS(1)		;0 IS ON
	POP P,2
	SKIPN PSIBW(1)		;ANY BREAKS WAITING?
	JRST CLFRET		;NO
	SETZ 1,			;YES, INITIATE SERVICE
	NOSKED
	CALL PSIRQB
	OKSKED
	JRST CLFRET

.SKPIR:	JSYS MENTR
	CALL SETLFK
	SKIPN PSISYS(1)
	AOS 0(P)
	JRST CLFRET

.DIR:	JSYS MENTR
	CALL SETLFK
	SETOM PSISYS(1)
	JRST CLFRET

.AIC:	JSYS MENTR
	CALL SETLFK
	IORM 2,PSICHM(1)
ICR:	CAIN 1,0		;SELF?
	CALL SETOVF		;YES, POSSIBLE CHANGE TO APR FLAGS
	JRST CLFRET

.DIC:	JSYS MENTR
	CALL SETLFK
	ANDCM 2,MONCHN(1)		;NOR MONITOR RESERVED CHANNELS
	ANDCAM 2,PSICHM(1)
	JRST ICR

.IIC:	JSYS MENTR
	CALL SETJFK
	PUSH P,1
	CALL SETLF1		;MAP DEST PSB
	UMOVE 2,2
	ANDCM 2,MONCHN(1)	;DISALLOW MON RESERVED CHANS
	PUSH P,2
	CALL CLRLFK
	POP P,2
	POP P,1
	MOVE 1,SYSFK(1)
	EXCH 1,2
	NOSKED
	CALL PSIRQB
	OKSKED
	RESKED			;INITIATE RESCHEDULE TO GET INTERRUPT
	JRST MRETN

.RCM:	JSYS MENTR
	CALL SETLFK
	MOVE 1,PSICHM(1)
	JRST RETA1

.RWM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PSIBIP(1)
	UMOVEM 2,2		;REPORT BREAKS IN PROGRESS IN 2
	MOVE 1,PSIBW(1)
RETA1:	UMOVEM 1,1		;RETURN VALUE IN 1
	JRST CLFRET

.SIRCM:	JSYS MENTR
	CALL SETLFK
	CAIN 1,0		;SELF?
	JRST FRKE1		;ILLEGAL
	MOVEM 2,SUPCHN(1)
	JRST CLFRET

.RIRCM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,SUPCHN(1)
RETA2:	UMOVEM 2,2
	JRST CLFRET

.RIR:	JSYS MENTR
	CALL SETLFK
	MOVE 2,LEVCHN(1)	;RETURN LEVEL AND CHANNEL DISPATCHES
	JRST RETA2

.ATI:	JSYS MENTR
	NOINT
	PUSH P,1
	HLRZ 1,1
	CAIL 1,^D36		;REASONABLE TERM CODE?
	JRST ATIE1		;NO
	CAIE 1,3		;CONTROL-C?
	JRST .+4		;NO
	MOVE 3,CAPENB		;YES, SEE IF LEGAL
	TLNN 3,(1B0)
ATX2E:	ITERR ATIX2		;ISN'T
	HRRZ 4,FORKN
	MOVE 3,BITS(1)
	SKIPL 2,CTRLTT
	IORM 3,TTPSI(2)		;IF THERE IS A CONTROLLING TTY
	IORM 3,TTSPSI
	IORM 3,FKPSIE(4)
	CALL GETCHA
	HRRZ 3,0(P)		;GET REQUESTED CHANNEL NUMBER
	DPB 3,2			;ASSIGN IT TO THIS CODE
ATI2:	OKINT
	POP P,1
	JRST MRETN

GETTCD:	CAIGE 1,PSICHL		;IN LOW GROUP?
	JRST GTCD1		;YES
	CAIGE 1,PSICHU		;IN HIGH GROUP?
ATIE1:	ITERR TERMX1		;NO, ERROR
	SUBI 1,PSICHO		;OFFSET HIGH GROUP
GTCD1:	MOVE 1,PSICH(1)
	RET

.DTI:	JSYS MENTR
	NOINT
	CAIL 1,^D36		;REASONABLE CODE?
	JRST ATIE1		;NO
	HRRZ 2,FORKN
	MOVE 6,BITS(1)
	ANDCAM 6,FKPSIE(2)	;CLEAR FROM THIS FORK
	CALL UPDTI		;UPDATE JOB WORDS
	OKINT
	JRST MRETN

;UPDATE JOB TPSI WORDS BY SCANNING FORK WORDS

UPDTI:	HLRZ 1,FORKN		;START WITH TOP FORK
	SETO 5,
	TDNE 6,FKPSIE(1)	;HERE?
	MOVEI 5,0(1)		;YES
	CALL PSIT1A		;SCAN INFERIORS
	JUMPGE 5,[IORM 6,TTSPSI	;IS ON IN ONE OR MORE FORKS
		SKIPL 2,CTRLTT
		IORM 6,TTPSI(2)
		RET]
	ANDCAM 6,TTSPSI		;IS NOT ON ANYWHERE
	SKIPL 2,CTRLTT
	ANDCAM 6,TTPSI(2)
	RET

;DEASSIGN ALL TERMINAL INTERRUPTS FOR THIS FORK

DTIALL:	HRRZ 1,FORKN
	MOVE 1,FKPSIE(1)	;GET BITS OF ACTIVATED CODES
	JFFO 1,.+2		;ANY ON?
	RET			;NO
	MOVE 1,2		;YES, PUT CODE IN 1
	DTI			;DEASSIGN THIS ONE
	JRST DTIALL		;SEE IF ANY MORE

.CIS:	SETZM PSIBIP
	SETZM PSIBW
	MOVEM 1,PSIPT
	MOVE 1,[IOWD 1000,PSIPGA]
	EXCH 1,PSIPT		;RESET PSI STORAGE
	XCT MJRSTF

;READ/SET TERMINAL INTERRUPT WORD

.RTIW:	JSYS MENTR
	MOVEI 1,0(1)
	CAIN 1,-5		;WHOLE JOB?
	JRST [	MOVE 2,TTSPSI	;YES
		JRST RTIW1]
	CALL SETJFK		;GET JOB INDEX
	MOVE 2,FKPSIE(1)
RTIW1:	UMOVEM 2,2
	JRST MRETN

.STIW:	JSYS MENTR
	MOVEI 1,0(1)
	CAIN 1,-5
	JRST [	MOVE 3,CAPENB
		TLNN 3,(1B0)	;^C CAPABILITY?
		JRST ATX2E	;NO, DON'T PERMIT CHANGE TO JOB TI
		MOVEM 2,TTSPSI	;SET WHOLE JOB WORD
		SKIPL 3,CTRLTT
		MOVEM 2,TTPSI(3) ;AND TERMINAL IF ATTACHED
		JRST MRETN]
	CALL SETJFK
	EXCH 2,FKPSIE(1)	;SET NEW, REMEMBER OLD
	XOR 2,FKPSIE(1)		;DIFFERENCES
STIW1:	JFFO 2,.+2		;ANOTHER BIT DIFFERENT?
	JRST MRETN		;NO
	MOVE 6,BITS(3)		;YES, GET IT
	TDZ 2,6
	PUSH P,2
	CALL UPDTI		;UPDATE JOB WORDS FOR CHANGE
	POP P,2
	JRST STIW1

;FORK HANDLE - PTN CONVERSION ROUTINES

	INTERN FKHPTN,PTNFKH

;TRANSLATE FKH.PN TO PTN.PN

FKHPTN:	PUSH P,2
	PUSH P,1
	TRNE 1,777000		;LEGAL PAGE NUMBER?
	JRST FRKE1		;NO
	HLRZ 1,1
	CALL SETJFK		;GET JOB FORK INDEX
	CALL SKIIF
	JRST [	MOVSI 2,(1B9)	;NOT INFERIOR
		TDNN 2,CAPENB	;ALLOWED TO MAP SUPERIOR?
		JRST FRKE2	;NO
		MOVE 2,1	;YES, SAVE OBJECT FORK
		CALL GETSPF	;GET HANDLE OF SUPERIOR
		EXCH 1,2
		CAME 1,2	;IS OBJECT FORK IMMED SUPERIOR?
		JRST FRKE2	;NO
		JRST .+1]
	HRRZ 2,SYSFK(1)		;GET SYSTEM FORK INDEX
	POP P,1
FKHP2:	HLL 1,FKPGS(2)		;GET PAGE TABLE PTN
	TLNE 1,-1		;IS ONE?
	JRST FKHP3		;YES
	BUG(HLT,<FKHPTN - FORK HAS NO PAGE TABLE>)

FKHP3:	POP P,2
	JRST RSKP

;TRANSLATE PTN TO FKH

PTNFKH:	PUSH P,2
	PUSH P,3
	PUSH P,1
	HLRZ 2,1		;GIVEN PTN
	MOVSI 3,-NUFKS		;SETUP FOR SCAN OF JOB FORK TABLE
PTNF3:	HRRE 1,SYSFK(3)
	JUMPL 1,PTNF2		;UNUSED
	HLRZ 1,FKPGS(1)
	CAIN 2,0(1)		;IS PT?
	JRST PTNF1		;YES
PTNF2:	AOBJN 3,PTNF3
	SETOM 0(P)		;NOT FOUND, RETURN -1
	JRST PTNF4

PTNF1:	MOVEI 1,0(3)		;JOB INDEX
	CALL GFKH		;CONVERT TO LOCAL HANDLE
	ITERR FRKHX6
	HRLM 1,0(P)		;CONSTRUCT FHK,,PN
PTNF4:	POP P,1
POP32:	POP P,3
POP2:	POP P,2
	RET

;FIND OR INSERT LOCAL FORK HANDLE
;GIVEN JOB FORK INDEX

GFKH:	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
	HRRZ 2,FORKN
	CAIN 2,0(1)		;IS IT SELF?
	SOJA 4,GFKH4		;YES, 0
	HRLI 1,400000		;USE LH TO REMEMBER ANY EMPTY ENTRIES
GFKH1:	ILDB 2,3		;LOOK AT NEXT HALF-WORD
	CAIN 2,-1		;ASSIGNED?
	JRST GFKH2		;NO
	CAIN 2,0(1)		;IS GIVEN?
	JRST GFKH4		;YES
GFKH3:	AOBJN 4,GFKH1
	TLNE 1,400000		;NOT FOUND, ROOM TO ADD ENTRY?
	RET			;NO
	HLRZ 3,1		;GET INDEX OF FIRST FREE ENTRY
	IDIVI 3,2		;CONSTRUCT POINTER TO IT
	ADD 3,FKPTAB(4)
	DPB 1,3			;STORE JOB INDEX IN ENTRY
	HLRZ 4,1
GFKH4:	MOVEI 1,400000(4)	;RETURN LOCAL HANDLE WITH BIT
	AOS -3(P)
POP4:	POP P,4
	JRST POP32

GFKH2:	TLNE 1,400000		;FIRST EMPTY SLOT?
	HRLI 1,0(4)		;YES, SAVE INDEX
	JRST GFKH3

;DEASSIGN LOCAL FORK HANDLE GIVEN JOB HANDLE IN 1

DASFKH:	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
DASFK1:	ILDB 2,3		;GET THIS ENTRY
	CAIN 2,0(1)		;THE ONE WE WANT?
	JRST DASFK2		;YES
	AOBJN 4,DASFK1		;NO, KEEP LOOKING
	JRST POP4		;NOT FOUND, SO IGNORE IT

DASFK2:	MOVEI 2,-1		;PUT A -1 WHERE ENTRY WAS
	DPB 2,3
	JRST POP4

;TABLE OF BYTE POINTERS, HALF WORD

	POINT 18,FKTAB,-1
FKPTAB:	POINT 18,FKTAB,17
	POINT 18,FKTAB,35

;SPECIAL CAPABILITIES CONTROL

.RPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SETLF1
	MOVE 2,CAPMSK(1)
	UMOVEM 2,2		;RETURN POSSIBLE IN 2
	MOVE 3,CAPENB(1)
	UMOVEM 3,3		;ENABLED IN 3
	JRST CLFRET

.EPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SKIIF
	ITERR FRKHX2		;INFERIORS ONLY
	CALL SETLF1
	JUMPE 1,[XOR 3,CAPMSK(1) ;IF SELF, DON'T MODIFY 14-17
		TLZ 3,(17B17)
		XOR 3,CAPMSK(1)
		JRST EPC1]
	MOVE 4,CAPMSK
	TLO 4,(777B17)		;9-17 DETERMINED BY SUPERIOR
	AND 2,4
	MOVEM 2,CAPMSK(1)
EPC1:	AND 3,CAPMSK(1)
	MOVEM 3,CAPENB(1)
	JRST CLFRET

;DETACH FROM CONTROLLING TTY

.DTACH:	JSYS MENTR
	NOINT
	SKIPG CTRLTT		;IS ONE?
	JRST MRETN		;NO, DO NOTHING
	MOVE 1,JOBNO
	HRRE 2,JOBDIR(1)
	CAIE 2,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	MOVE 2,CTRLTT
	SETOM CTRLTT
	SETOM TTFORK(2)
	SETZM TTPSI(2)
	MOVE 1,JOBNO
	HRROS JOBPT(1)
	JRST MRETN

;ATTACH JOB TO TTY

	EXTERN ATACX4

.ATACH:	JSYS MENTR
	NOINT
	PUSH P,1		;SAVE JOB NO
	MOVEI 1,WHEEL+OPER
	TDNE 1,CAPENB		;PRIVILEGED?
	JRST ATACH3		;YES, NO PASSWORD CHECK
	PUSH P,2
	MOVEI 1,0(2)
	MOVE 2,3
	CALL PASSWC		;CHECK PASSWORD
	JRST [	MOVEI 1,^D3000
		DISMS		;WRONG PASSWORD, DELAY TO FOIL THIEVES
		MOVEI 1,ATACX4
		JRST MRETNE]
	POP P,2
ATACH3:	HRRZ 1,0(P)
	CAIL 1,0
	CAIL 1,NJOBS		;LEGAL JOB NO?
	RETERR ATACX1		;NO
	HRRZ 3,JOBDIR(1)	;DIRECTORY OF  OTHER JOB
	PUSH P,3		;SAVE FOR FACT FILE
	CAIE 3,0(2)		;SAME AS SPECIFIED?
	RETERR ATACX3		;NO
	SKIPGE CTRLTT		;THIS JOB NOT ATTACHED? OR
	RETERR ATACX2		;YES
	MOVE 4,CAPENB
	TRNN 4,WHEEL+OPER	;WHEEL OR OPER?
	SKIPGE JOBPT(1)		;OR OTHER JOB NOT ATACHED?
	CAIA			;YES, PERMISSABLE
	RETERR ATACX2		;ILLEGAL
	HRRZ 1,JOBPT(1)		;TOP FORK OF OTHER JOB
	HRRZ 1,FKPGS(1)		;GET PSB OF IT
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	LDB 1,[POINT 13,FPBPGA+JSBPG,26]	;GET JSB NO
	CALL SETMPG
	MOVEI 6,FPBPGA-JSB
	SKIPL 4,CTRLTT(6)	;OTHER JOB NOW UNATACHED?
	JRST [	NOSKED		;NO, MUST DETACH IT FIRST
		MOVE 3,PSICH+3	;CONTROL-C INTERRUPT CODE
		MOVEI 2,0(4)	;LINE NUMBER
		CALL TTPSRQ	;FAKE A CONTROL-C ON OTHER JOB
		SETZM TTPSI(4)	;CLEAR TTY WORDS
		SETOM TTFORK(4)
		SETOM CTRLTT(6)
		MOVE 1,-1(P)	;OTHER JOB NUMBER
		HRROS JOBPT(1)
		OKSKED
		JRST ATACH2]

ATACH2:	PUSH P,CTRLTT
	DTACH
	NOSKED
	POP P,5			;TTY
	DPB 5,[POINT 12,LOGBUF,29] ;TTY NUMBER FOR EFACT
	POP P,4			;OTHER JOB'S DIRECTORY NUMBER
	HRRM 4,LOGBUF+1		;PUT IN EFACT BLOCK
	POP P,4			;DESTINATION JOB NO
	HRLM 4,LOGBUF		;PUT IN EFACT BLOCK
	MOVEM 5,CTRLTT(6)	;SET CTRLTT IN DEST JOB
	HRLM 5,JOBPT(4)
	HRLM 4,TTFORK(5)
	MOVE 1,TTSPSI(6)
	MOVEM 1,TTPSI(5)
	CALL CLRLFK
	OKSKED
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE 1,JOBNO
	HRRE 1,JOBDIR(1)
	JUMPE 1,LOGO		;VANISH IF NOT LOGGED IN
	AOS 0(P)		;RETURN SKIP
	JRST MRETN

;GET AND SAVE ROUTINES

	INTERN .GET,.SAVE,.SSAVE

.GET:	JSYS MENTR
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST ALL ACCESS AND THAWED
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	MOVE 6,2
	HLRZ 2,2
	CAIL 2,1000
	CAIL 2,10000
	JRST .+2
	JRST SGET
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1
	CALL GET3		;SET MAP FOR PAGE
	JRST GET5

GET4:	TRNN 6,777		;JUST CROSSED PAGE BOUNDARY?
	CALL GET3		;YES, REMAP
GET5:	BIN
	MOVEM 2,0(5)
	JUMPE 2,[GTSTS		;0 ENCOUNTERED, GOOD TIME TO CHECK EOF
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES, BAD FILE. GIVE UP
		JRST .+1]	;ALL IS WELL, KEEP GOING
	ADDI 5,1
	AOBJN 6,GET4
	JRST GET2		;NEXT BLOCK

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
	MOVEI 1,0(16)		;JFN
	MOVE 3,2
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	BUG(HLT,<GET - FKHPTN FAILED>)
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE1:	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	ITERR GETX1

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR

.SAVE:	JSYS MENTR
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	JRST SAVE3B		;PT DOESN'T EXIST
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK

;WRITE ALL OR PART OF ONE PAGE

SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
SAVE4:	MOVE 2,0(5)
	BOUT
	ADDI 5,1
	AOBJN 6,SAVE4
	SUBI 6,0(7)		;UPDATE POINTER AND COUNT
	HRLI 6,0(6)
	ADD 7,6
	RET

;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	JSYS MENTR
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	JRST SAVE1		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	BUG(HLT,<SSAVE - FKHPTN FAILED>)
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             