
;14 OCT 71, 1319:
;BRYANT DRUM DRIVER - D. MURPHY

	INTERN DRMIO,DRMSV,DRMIOI,DRMRST,DRMES,DRMEP
	EXTERN SWPDON,DRUMP

;CST3 LH CONTROL BITS

	INTERN DWRBIT,SWPERR
DWRBIT==400000
SWPERR==200000

DRM==30			;DEVICE NO. OF DRUM
DRMSEC==22		;NO. OF DRUM SECTORS
DRMBND==^D170		;NO. OF DRUM BANDS
NRETRY==7		;NUMBER OF REPEAT TRIES ON ERROR
DRUMCP==64		;LOCATION OF DRUM COMMAND POINTER
DRMEST==65		;LOCATION OF ERROR STATUS DUMP LOCATION

LS DRMCL,DRMSEC*2+1	;DRUM COMMAND LIST

LS DRMRI,DRMSEC		;DRUM READ  QUEUE INPUT POINTER
LS DRMRO,DRMSEC		;DRUM READ  QUEUE OUTPUT POINTER
LS DRMWI,DRMSEC		;DRUM WRITE QUEUE INPUT POINTER
LS DRMWO,DRMSEC		;DRUM WRITE QUEUE OUTPUT POINTER

LS LASTCP,1		;COMMAND LIST POINTER ON ENTRY TO INTERRUPT SERV
LS DRMCMC,1		;COMMANDS PENDING COUNT

NDRMEW==4		;NUMBER OF DRUM ERROR WORDS FOR GETAB

LS DRMCFE,1		;COUNT OF CFM ERRORS
LS DRMLER,3		;LAST ERRONEOUS DRUM COMMAND AND ERROR BITS

LS DRMMLE,1		;COUNT OF MISSED LATENCY ERRORS
LS DRMSVR,1		;INTERRUPT SERVICE RETURN

IFN NDST-<DRMSEC*DRMBND>,<PRINTX NDST INCONSISTENT WITH DRUM STORAGE ASSIGNMENT>

	RESCD

;DRUM ERROR FLAGS SAVED IN DRMEST (65) WHEN ERROR OCCURS

CFM==2			;CHECK FIELD (=LONGITUDINAL PARITY) MISMATCH
PCI==4			;PARITY FROM COMPUTER INCORRECT
CRJ==10			;COMMAND REJECT
ISA==20			;ILLEGAL STARTING ADDRESS
RAM==100		;RECORD ADDRESS MISMATCH
DNA==200		;DEVICE NOT AVAILABLE (POWER OFF OR HW FAILURE)
DTL==1000		;DATA LATE FROM MEMORY
IWC==2000		;ILLEGAL WORD COUNT
IPO==4000		;ILLEGAL PAGE OVERFLOW
PAV==10000		;PROTECTED AREA VIOLATION

EC1==4			;ERROR TYPE 1 (CFE, PCI, DTL)
EC2==10			;ERROR TYPE 2 (EVERYTHING ELSE)

IRDRM==200		;"INT REQ" BIT IN DRUM CONI
DRMBSY==100		;"BUSY" BIT IN DRUM CONI
DSTOP==103+DRMCHN*10	;DISCONNECT & INTERRUPT CONO
DGO==102+DRMCHN*10	;GO-CHAIN CONO
DGONO==101+DRMCHN*10	;GO-NO-CHAIN (ONE COMMAND ONLY) CONO
DRESET==100		;RESET CONO
;BITS IN COMMAND WORDS

INT==100000		;INTERRUPT APR ON COMPLETION (IN D.A.W.)
WC512==40		;BIT FOR WORD COUNT=512 (IN D.A.W.)
IO==40000		;I/O BIT (IN DRUM ADDRESS WORD)
DT==400000		;DATA TRANSFER BIT
DIS==200000		;DISCONNECT BIT

;DRUM IO DRIVER

; AC1/ 18-35 CORE PAGE NUMBER (CST INDEX) OF PAGE
;      DWRBIT WRITE OPERATION IF 1, READ IF 0

DRMIO:	SKIPG DRUMP		;DRUM ON SYSTEM?
	JRST DSKIO		;NO, USE DISK
	PUSH P,1
	AOSG DRMCMC		;INCREMENT COMMANDS IN PROGRESS CNT
	JFCL			;CONO DRM,DGO  FOR SPECIAL OPERATION
	MOVE 2,CST1(1)		;GET DRUM ADDRESS
	ANDI 2,37		;GET SECTOR NUMBER
	ADDI 1,CST3		;MAKE POINTER OUT OF PAGE NUMBER
	HLLZM 1,0(1)		;STORE WRITE BIT, 0 MARKS LAST WORD
	PIOFF			;MUST NOT INTERRUPT QUEUEING
	JUMPL 1,[HRRM 1,@DRMWI(2) ;ADD ENTRY TO END OF WRITE QUEUE
		HRRZM 1,DRMWI(2)
		JRST DRMOP2]
	HRRM 1,@DRMRI(2)	;PUT THIS ENTRY ON APPROPRIATE QUEUE
	HRRZM 1,DRMRI(2)	;UPDATE INPUT (LAST WORD) POINTER
DRMOP2:	PION
	SUBI 2,2		;LOOK AT SECTOR -2
	JUMPGE 2,.+2
	ADDI 2,DRMSEC		;WRAPAROUND
	SKIPN DRMWO(2)
	SKIPE DRMRO(2)		;THAT SECTOR NON-EMPTY?
	JRST DRMOP1		;YES, SO COMMAND MUST BE WAITING
	LSH 2,1			;COMPUTE INDEX INTO COMMAND LIST
	MOVSI 3,INT		;CAUSE INTERRUPT AT THAT SECTOR WHICH
	IORM 3,DRMCL(2)		;WILL SETUP COMMAND FOR THIS SECTOR
DRMOP1:	POP P,1
	RET

;INTERRUPT SERVICE

DRMSV:	XWD DRMSVR,.+1		;CALLED BY JSYS IN PISRV
	CONSZ DRM,IRDRM
	JRST DRMINT
	JRST @DRMSVR

;DRUM INTERRUPT ROUTINE
;WILL CLEAN UP AFTER PAGE JUST TRANSFERRED, AND SETUP COMMAND
;FOR NEXT SECTOR (I.E. LAST SECTOR + 2)

DRMINT:	SKIPE PWRDWN
	JRST [	CONO DRM,DRESET	;FLUSH PI ASSMT
		JRST DRMINX]
	HRRZ 1,DRUMCP		;DRUM COMMAND POINTER
	CAIN 1,DRMCL+2*DRMSEC	;END OF COMMAND LIST?
	JRST [	MOVEI 1,DRMCL	;SHOULDN'T HAPPEN EXCEPT IN SPEC'L OPN
		MOVEM 1,DRUMCP	;MAKE IT RIGHT
		JRST .+1]
	SKIPE 2,DRMEST		;ERRORS?
	JRST DRMERR		;YES
	MOVEM 1,LASTCP		;SAVE IT FOR LATER CHECK
	SUBI 1,DRMCL+2		;CONVERT TO INDEX INTO DRMCL
	TRNE 1,1		;COMMAND LIST PARITY STILL CORRECT?
	BUG(HLT,<DRUM COMMAND POINTER FOULED, POINTS TO ODD WORD>)
	JUMPGE 1,.+2
	ADDI 1,DRMSEC*2		;WRAPAROUND
	HRRZS DRMCL+1(1)	;CLEAR ANY OLD ERROR BITS
	MOVEI 2,0(1)		;GET CL INDEX
	LSH 2,-1		;MAKE INTO SECTOR NUMBER
	HRLI 2,DT		;WC0 COMMAND FOR THIS SECTOR
	EXCH 2,DRMCL(1)		;EXCHANGE WITH COMMAND JUST COMPLETED
	TLNN 2,WC512		;WAS IT A DATA TRANSFER COMMAND?
	JRST DRMI1		;NO
	HRRZ 1,DRMCL+1(1)	;YES, GET CORE ADDRESS
	LSH 1,-^D9		;CONVERT TO PAGE NUMBER
	JSP 4,SWPDON		;NOTIFY SWAPPER THAT XFER COMPLETED
	SOSGE DRMCMC		;DECREMENT COMMANDS IN PROGRESS CNT
	JFCL			;CONO DRM,DGONO  FOR SPECIAL OPER'N

;DRMINT...

DRMI1:	MOVE 1,LASTCP
	SUBI 1,DRMCL-2		;CONVERT TO INDEX, LAST SECTOR +2
	CAIL 1,2*DRMSEC
	SETZ 1,			;WRAPAROUND
	LSH 1,-1		;CONVERT TO INDEX TO QUEUES
	SKIPE 2,DRMRO(1)	;CHECK READ QUEUES FIRST, ANYTHING?
	JRST DRMIQ		;YES
	SKIPN 2,DRMWO(1)	;ANYTHING ON WRITE QUEUE?
	JRST DRMI2		;NO
	HRRZ 2,0(2)		;REMOVE ENTRY FROM WRITE SECTOR QUEUE
	JUMPN 2,.+3
	MOVEI 3,DRMWO(1)	;WAS LAST ON LIST,
	MOVEM 3,DRMWI(1)	;MUST UPDATE INPUT POINTER
	EXCH 2,DRMWO(1)
DRMI4:	SUBI 2,CST3		;CONVERT BACK TO CORE PAGE NUMBER
	LSH 1,1
	MOVSI 3,DWRBIT		;GET WRITE BIT
	AND 3,CST3(2)
	TLZE 3,DWRBIT		;USE IT TO SET IO BIT IN DRUM COMMAND
	TLOA 3,WC512+DT+INT+IO
	TLO 3,WC512+DT+INT	;USUAL COMMAND BITS
	HRR 3,CST1(2)		;DRUM ADDRESS
	LSH 2,^D9		;CONVERT TO CORE ADDRESS
	MOVEM 2,DRMCL+1(1)	;PUT CORE ADDRESS IN COMMAND LIST
	MOVEM 3,DRMCL(1)	;DRUM ADR AND COMMAND 
	SUBI 1,4
	JUMPGE 1,.+2		;GET ADR OF SEC -2
	ADDI 1,DRMSEC*2
	MOVSI 2,INT
	IORM 2,DRMCL(1)		;MAKE SURE WE GET INTERRUPT
DRMI2:	MOVE 4,LASTCP		;COMMAND POINTER ON ENTRY
	CAME 4,DRUMCP		;SAME AS COMMAND POINTER NOW?
	JRST DRMI3		;NO, MISSED LATENCY
DRMINX:	UNBRK DRM		;DISMISS BREAK

DRMIQ:	HRRZ 2,0(2)		;REMOVE ENTRY FROM SECTOR READ QUEUE
	JUMPN 2,.+3
	MOVEI 3,DRMRO(1)
	MOVEM 3,DRMRI(1)
	EXCH 2,DRMRO(1)		;UPDATE OUTPUT POINTER
	JRST DRMI4

;ERROR CONDITIONS

;ERROR FLAGS DETECTED IN 65

DRMERR:	SUBI 1,DRMCL
	TRNE 1,1		;COMMAND LIST PARITY OK?
	BUG(HLT,<DRUM ERROR AND COMMAND POINTER FOULED, ODD ADDRESS>)
	MOVEM 2,DRMLER+2	;SAVE ERROR BITS
	MOVSI 3,DRMCL(1)	;SAVE COMMAND WORDS
	HRRI 3,DRMLER
	BLT 3,DRMLER+1
	HLRZ 3,DRMCL+1(1)
	JUMPN 3,DRMER1		;PREVIOUS ERRORS THIS TRANSFER
	MOVEI 3,<NRETRY>B21	;SETUP COUNT FOR RETRYS
DRME1:	SETZM DRMEST		;CLEAR ERROR WORD
	TRNN 2,CFM+PCI+DTL	;DATA ERROR?
	JRST DRMES		;NO
	MOVEI 2,EC1		;REMEMBER AS ERROR TYPE 1
DRMES1:	AOS DRMCFE		;YES, COUNT OCCURRANCES
	IORI 2,0(3)		;PUT RETRY COUNT WITH ERROR BITS
	MOVSI 4,INT
	IORM 4,DRMCL(1)		;BE SURE IT INTERRUPTS ON RETRY
	TRNN 2,-1B21		;RETRY COUNT NOW 0?
	JRST DRMEP		;YES, CONSIDER ERROR PERMANENT
	HRLM 2,DRMCL+1(1)	;NO, STORE ERROR BITS AND RETRY COUNT
DRMEGO:	CONO DRM,DGO		;RESTART DRUM
	JRST DRMINX		;DEBREAK

DRMER1:	ANDI 3,-1B21		;GET THE PREVIOUS RETRY COUNT
	SUBI 3,1B21		;REDUCE IT
	JRST DRME1

;STRANGE DRUM ERROR

DRMES:	MOVEI 2,EC2		;REMEMBER AS ERROR TYPE 2
	JRST DRMES1		;GO TRY AGAIN IF CONTINUED

;UNRECOVERABLE ERROR

DRMEP:	IORI 2,<NRETRY>B21	;IN CASE ON MANUAL GO TO DRMEGO-1
	MOVE 3,DRMLER+2		;ERROR BITS
	TRNE 3,1B33		;PCI?
	JRST [	AOS DEVMPE	;YES, REQUEST CORE SCAN
		ISB APRCHN
		HRLM 2,DRMCL+1(1)
		JRST DRMEGO]	;TRY AGAIN, ERROR MAY BE REMOVED
	BUG(CHK,<UNRECOVERABLE DRUM ERROR, DRMEGO-1$G TO RETRY>)
	HRRZ 2,DRMCL+1(1)	;GET CORE ADDRESS
	LSH 2,-^D9		;PAGE NUMBER
	MOVSI 3,SWPERR		;SET ERROR BIT IN
	IORM 3,CST3(2)		;CST3 ENTRY FOR DETECTION BY SWAPPER
	ADDI 1,DRMCL+2		;GO TO NEXT SECTOR
	CAIL 1,DRMCL+DRMSEC*2
	MOVEI 1,DRMCL
	MOVEM 1,DRUMCP
	CONO DRM,DGO		;RESTART DRUM
	JRST DRMINT		;PROCESS THIS SECTOR AS IF NO ERROR

;HERE IF COMMAND POINTER ADVANCED WHILE SETTING UP COMMAND
;MEANS COMMAND PROBABLY NOT EXECUTED
;THIS SHOULD ***NEVER*** HAPPEN. IF IT DOES, IT MEANS THIS INTERRUPT
;ROUTINE FAILED TO GET SERVICE AND COMPLETE IN ABOUT 1.9 MSEC

DRMI3:	CONO DRM,DRESET		;STOP DRUM
	BUG(CHK,<DRUM BAD COMMAND POINTER, CONTROLLER SCREWUP OR MISSED LATENCY>)
	MOVEM 4,DRUMCP
	JRST DRMEGO		;START DRUM AND DEBREAK

;INITIALIZE DRUM IO

;SPECIAL OPERATION MEANS TURNING THE DRUM OFF WHENEVER THERE ARE
;NO COMMANDS WAITING TO BE DONE. IT RESULTS IN SOMEWHAT SLOWER
;OPERATION, BUT IS USEFUL FOR DEBUGGING H'WARE AND/OR S'WARE.
;IT IS EFFECTED BY REPLACING THE JFCL'S WITH THE INDICATED CONO'S AT
;DRMIO+2 AND DRMI1-1

DRMIOI:	SETOM DST		;MAKE ALL DST ENTRIES EMPTY
	MOVE 1,[XWD DST,DST+1]
	BLT 1,DST+NDST-1
DRMRST:	SKIPG DRUMP		;DRUM EXISTS?
	RET			;NO
	MOVSI 1,-DRMSEC
DRMII2:	SETZM DRMRO(1)		;0 ALL OUTPUT QUEUE POINTERS
	SETZM DRMWO(1)
	MOVEI 2,DRMRO(1)
	MOVEM 2,DRMRI(1)	;INPUT POINTERS SET TO OUTPUT
	MOVEI 2,DRMWO(1)
	MOVEM 2,DRMWI(1)	;DRMQO(N) => ALL DRMQI(N)
	AOBJN 1,DRMII2
	MOVSI 1,DT		;WORD COUNT 0 COMMANDS =>
	MOVSI 2,-2*DRMSEC
DRMII1:	MOVEM 1,DRMCL(2)	;WC0 COMMAND WITH CORRESPONDING SECTOR
	SETZM DRMCL+1(2)	;0 => ERROR BITS AND CORE ADDRESS
	ADDI 1,1		;INCREMENT SECTOR NUMBER
	AOBJN 2,.+1
	AOBJN 2,DRMII1
	MOVE 1,[XWD 600000,DRMCL]
	MOVEM 1,DRMCL+2*DRMSEC	;BRANCH COMMAND TO BEGINNING OF LIST
	SETZM DRMEST
	SETOM DRMCMC		;COMMAND COUNT WORD
	MOVEI 1,DRMCL
	MOVEM 1,DRUMCP		;START DRUM AT BEGINNING OF COMMAND LIST
	CONO DRM,DGO
	RET

;THE FOLLOWING ROUTINES ARE IN THIS PACKAGE & CALLED FROM OUTSIDE.

INTERN ASDRMS		;ASSIGN SPECIFIC DRUM ADDRESSES
INTERN DRMASF		;ASSIGN A DRUM PAGE, EMPTIEST SECTOR.
INTERN ASDRM		;ASSIGN DRUM PAGE NEAR A SPECIFIC SECTOR
INTERN DEDRM		;DEASSIGN A DRUM PAGE
INTERN BNDLK,BNDULK	;ROUTINES TO PREVENT/ENABLE ASSIGNMENT OF
			;DRUM ADDRESSES AT PARTICULAR BANDS.
INTERN DRMINI		;INITIALIZATION ROUTINE FOR THE DRUM
DRMBSZ==<DRMBND+^D35>/^D36	;SIZE OF BIT TABLE CHUNK FOR 1 SECTOR
DRMNOS==DRMBND-<DRMBND/44>*44	;NUMBER OF BITS (SECTORS) IN PTL WD
LS DRMBLK		;LOCKOUT WORD FOR DRUM BIT TABLE
LS DRMSC,DRMSEC		;FREE PAGE COUNT TABLE (ONE WORD/SECTOR)
LS DRMFRE		;TOTAL FREE PAGE COUNT FOR DRUM
LS BNDLO,DRMBSZ		;BAND MASK OUT TABLE
GS DRMBIT,DRMSEC*DRMBSZ	;DRUM BIT TABLE

Z==0
A==1
B==2
C==3
D==4
E==5
F==6
G==7
AA==10
BB==11
CC==12
DD==13
EE==14
FF==15
GG==16

;ASSIGN PAGE, EMPTIEST SECTOR

;"DRMASF" RETURNS CALLER+1 IF THE DRUM IS FULL OR UNAVAILABLE, ELSE
;CALLER+2 WITH THE DRUM ADDRESS ASSIGNED IN A.  THE SECTOR CHOSEN FOR
;THE ASSIGNMENT HAS THE MOST FREE PAGES.  "ASDRM" TRIES TO ASSIGN
;A PAGE AT SECTOR (A)+1 OR AS SOON AFTER AS POSSIBLE.  IT RETURNS CALLER+1
;IF NO FREE PAGES ARE LEFT OR CALLER+2 WITH THE DRUM ADDRESS IN A.

	INTERN DRMASN

DRMASN:
DRMASF:	SKIPG DRMFRE		;ROOM AVAILABLE?
	JRST DRMSA3		;NO, RETURN BAD
	HRLZI C,-DRMSEC		;CHOOSE EMPTIEST SECTOR FOR PAGE ASSIGNMENT
	MOVE B,DRMSC(C)		;GET FREE PAGE COUNT FOR THIS SECTOR
	HRRZ A,C		;BEST SECTOR SO FAR IN 1.
	CAMG B,DRMSC+1(C)
	AOBJN C,.-3
	AOBJN C,.-2
	JUMPG B,DRMASL
	JRST DRMSA3		;RETURN CALLER+1 IF DRUM FULL

;ASSIGN PAGE NEAR GIVEN SECTOR

ASDRM:	ANDI A,37
	CAIL A,DRMSEC		;CHECK FOR LEGAL ARGUMENT
	JRST DRMASF
DRMASS:	SKIPG DRMFRE
	JRST DRMSA3		;GO MAKE NO FREE PAGES RETURN
DRMAS1:	CAIGE A,DRMSEC-1
	AOJA A,.+2
	SETZ A,
	SKIPG DRMSC(A)
	JRST DRMAS1		;LOOP IF NO FREE PAGES HERE
DRMASL:	SOS DRMSC(A)		;DECREMENT NO. FREE PAGES ON THIS SECTOR
	MOVE B,A
	IMULI B,DRMBSZ
	HRLI B,-DRMBSZ
	SKIPE C,DRMBIT(B)
	JFFO C,SECFND
	AOBJN B,.-2
DBTFU:	BUG(HLT,<DRUM BIT TABLE FOULED, COUNT AND BITS DISAGREE>)

;CONVERT DRUM ADDRESS INTO INDEX INTO DST

	INTERN GDSTX

GDSTX:	TLNN 2,15		;INSIST ON REGULAR DRUM ADDRESS
	TLNN 2,2
	BUG(HLT,<GDSTX - BAD ADDRESS>)
	HRRZS 3,2		;SPLIT BAND AND SECTOR
	ANDI 3,37		;SECTOR
	LSH 2,-6		;BAND
	IMULI 2,DRMSEC
	ADDI 2,0(3)
	CAIL 2,NDST
	BUG(HLT,<GDSTX - BAD ADDRESS>)
	RET

	INTERN DASDRM

DASDRM:	CALL DEDRM
	JFCL
	BUG(HLT,<ATTEMPT TO DEASSIGN BAD OR UNASSIGNED DRUM ADDRESS>)
	RET

SECFND:	HLRO C,B
	MOVEI C,@BANDT(C)		;GET THE BAND NUMBER & 1 IN BIT 23
	LSH C,6			;POSITIONS THE BAND FIELD & 1 IN BIT 17
	IOR A,C			;DRUM ADDRESS NOW IN A
	MOVE C,BITS(D)		;GET BIT FOR BAND WORD
	ANDCAM C,DRMBIT(B)	;CLEAR THE BIT FROM THE BIT TABLE.
DRMSA1:	SOS DRMFRE		;DECREMENT TOTAL FREE PAGES ON DRUM
DRMSA2:	AOS (P)			;MAKE SKIP RETURN
DRMSA3:
DRMAS2:
RETN:	RET

	FOO==0
	REPEAT DRMBSZ,<XWD D,FOO+1B22
	FOO==FOO+44>
BANDT:
;ROUTINES TO ATTEMPT ASSIGNMENT OF A SPECIFIC DRUM ADDRESS

ASDRMS:	JSP E,DRMBS
	TDNN D,DRMBIT(B)	;SKIP IF PAGE IS AVAILABLE
	JRST DRMSA3
	ANDCAM D,DRMBIT(B)
	SOS DRMSC(C)		;REDUCE FREE PAGE COUNT FOR THIS SECTOR
	JRST DRMSA1

;ROUTINE TO RELEASE A DRUM PAGE

DEDRM:	JSP E,DRMBS
	TDNE D,BNDLO(A)		;CHECK IF BAND LOCKED OUT
	TDNE D,DRMBIT(B)	;CHECK IF NOT YET ASSIGNED
	RET			;SKIP RETURN 
	IORM D,DRMBIT(B)
	AOS DRMSC(C)		;INCREMENT FREE PAGE COUNT FOR THIS SECTOR
	AOS DRMFRE
	AOS (P)
	RET			;MAKE DOUBLE SKIP RETURN

;CHECKS FOR LEGAL DRUM ADDRESS & GETS WORD & BIT INDICES TO BIT TABLE
;RETURNS BIT CHUNK WORD INDEX IN A, BIT TABLE WORD INDEX IN B,
;SECTOR NO. IN C, AND BIT POSITION MASK IN D

DRMBS:	ANDI A,-1
	MOVE C,A
	ANDI C,37
	CAIGE A,DRMBND*100	;LEGAL BAND?
	CAIL C,DRMSEC		;LEGAL SECTOR?
	RET 
	AOS (P)
DRMSA0:	LSH A,-6		;GET BAND NO.
	IDIVI A,44		;WORD IN CHUNK & BIT IN WORD
	MOVEI D,1
	MOVN B,B
	LSH D,43(B)		;BIT MASK
	MOVE B,C
	IMULI B,DRMBSZ		;1ST WORD OF BIT CHUNK
	ADD B,A
	JRST (E)

;LOCK BAND
;ACCEPTS IN A BAND TO LOCK.
; RETURN 1 => ILLEGAL ADDRESS
; RETURN 2 => BAND LOCKED, NOT ALL PAGES WERE FREE
; RETURN 3 => BAND LOCKED, ALL PAGES WERE FREE

BNDLK:	JSP E,BNDLUE
	SETZ D,
	TDNN C,BNDLO(A)
	JRST DRMSA3
	ANDCAM C,BNDLO(A)	;CLEAR BIT IN LOCKOUT TABLE
BNDLP:	TDNN C,DRMBIT(A)
	JRST BNDCON
	SUBI D,1
	ANDCAM C,DRMBIT(A)	;CLEAR BIT IN EACH OF SECTOR BIT TABLES
	SOS DRMSC(B)		;& ADJUST FREE PAGE COUNT
BNDCON:	ADDI A,DRMBSZ
	AOBJN B,BNDLP
	ADDM D,DRMFRE
	CAIG D,-DRMSEC
	JRST DRMSA3
	JRST DRMSA2

;UNLOCK BAND
;ACCEPTS IN A BAND TO LOCK.
; RETURN 1 => ILLEGAL ADDRESS
; RETURN 2 => BAND NOT PREVIOUSLY LOCKED
; RETURN 3 => UNLOCKED SUCCESSFULLY

BNDULK:	JSP E,BNDLUE
	TDNE C,BNDLO(A)
	JRST DRMAS2		;NOT PREVIOUSLY LOCKED--MAKE ERROR RETURN
	IORM C,BNDLO(A)
BNDU1:	TDNE C,DRMBIT(A)
	JRST DBTFU
	IORM C,DRMBIT(A)
	AOS DRMSC(B)
	AOS DRMFRE
	ADDI A,DRMBSZ
	AOBJN B,BNDU1
	JRST DRMSA2

BNDLUE:	JUMPL A,RETN
	CAIL A,DRMBND
	RET	 		;ILLEGAL ARGUMENT RETURN
	AOS (P)
	IDIVI A,44
	MOVN B,B
	MOVEI C,1
	LSH C,43(B)
	HRLZI B,-DRMSEC
	JRST (E)

;INITIALIZE DRUM BIT TABLES

DRMINI:	SETOM DRMBIT		;EACH "ONE" REPRESENTS A FREE PAGE
	MOVE A,[XWD DRMBIT,DRMBIT+1]
	BLT A,DRMBIT+DRMBND/44-1
	MOVE A,[-1B<DRMNOS-1>]
	MOVEM A,DRMBIT+DRMBND/44
	MOVE A,[XWD DRMBIT,DRMBIT+DRMBSZ]
	BLT A,DRMBIT+DRMSEC*DRMBSZ-1
	MOVE A,[XWD DRMBIT,BNDLO]
	BLT A,BNDLO+DRMBSZ-1	;INIT. BAND LOCKOUT TABLE TO ALL ONES
	MOVEI A,DRMBND*DRMSEC	;NO. OF PAGES ON DRUM
	MOVEM A,DRMFRE
	MOVEI A,DRMBND		;NO. BANDS=NO. PAGES/SECTOR
	HRLZI B,-DRMSEC
	MOVEM A,DRMSC(B)		;INITIALIZE FREE PAGE COUNT FOR EACH SECTOR
	AOBJN B,.-1

;INITIALIZE BAND LOCK OUT TABLE

	MOVEI F,0
DRMIN1:	MOVE A,DRMBBT(F)
	JUMPL A,DRMIN2		;DONE ON -1
	CALL BNDLK
	JFCL 0
	JFCL 0
	AOJA F, DRMIN1

DRMIN2:	MOVEI F,0
DRMIN4:	MOVE A,DRMBST(F)
	JUMPL A,DRMIOI		;DONE ON -1
	CALL ASDRMS		;ASSIGN ALL THE BAD AREAS
	JFCL 0
	JFCL 0
	AOJA F, DRMIN4

DRMBBT:	-1
	BLOCK 6			;FOR OTHER BAD BANDS

DRMBST:	-1
	BLOCK 10

	BGHERE SWPBGP,SWPBGS
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           