	Our systems programmer, Ben Bitdiddle is implementing a LISP
interpreter for a new machine based on our state machine evaluator.
While working on the storage allocation system he gets a brilliant idea
about how to avoid periodic garbage collection.

Ben's idea is to associate with each cons cell a "reference count"
which is the number of pointers in the system which point at that
cell.  This reference count is maintained by the interpreter whenever
it makes or deletes a pointer to the cons cell: When a new pointer is
made to a cell, the reference count is incremented by one; when the
pointer is deleted the reference count is decremented by one.  If the
reference count of a cell becomes zero, there are no pointers to it
and thus it is garbage and can be returned to free storage
immediately.

Ben reasons that to make this scheme actually work, the act of setting
an interpreter register to a new value must decrement the count of
anything pointed at by the old value of the register and it must
increment the count of anything pointed at by the new value of the
register.

We shall store this reference count at the beginning of each cons cell. 
Suppose, for example, that the EXP register contained a quoted expression
which is also pointed at by the VAL register and some other unknown place
as follows:



If we go to EVAL-DISPATCH we will execute the following line of code:

(setq val (cadr exp))

a.  Draw the new state of the structures pointed at by the EXP and the
VAL registers with the appropriate reference counts.

b.  Why is it important that the reference count of the new value of a
register be incremented before the reference count of the old value is
decremented when a register is assigned?  (Hint:  What if the register
is about to be assigned to its current value?)


Ben told his friend Harry Reasoner what he was up to.  Harry said that
the idea of reference counts had a fundamental bug.  He said that if
there are circular structures, the reference count scheme would fail to
collect cells which were otherwise garbage.

c.  What is a circular structure and how could it be produced?

d.  Explain Harry's objection to Ben's idea.  Draw a circular structure
and show why it would not be collected even if nothing pointed at it.

	For each of the following circuits you must:

a. Identify a set of independent state variables.

b. Say if SIMUL could simulate this circuit.  If not say why not.

c. Write an output equation for the indicated output variable.

d. Select a graph which could be the behavior of the output variable
for some set of initial conditions.  (Caution: there may be more than
one possible graph that works ... you need select only one, however.) 

Ben Bitdiddle is implementing a computer.  Part of Ben's hardware must
compute the parity of three bits.  The parity function on a set of bits
is a boolean function.  Its output value is 1 if the number of input bits
whose values are 1 is odd and its output value is 0 if the number of
input bits whose value is 1 is even.  The parity of three bits can easily
be computed as a combinational function of those bits.

a.  Write a truth table describing the parity function of three input bits.

b.  Write a boolean expression, in disjunctive normal form (ie. as the OR
of a bunch of ANDS of the input boolean variables and their NOTs), for
the parity function on the three input bits.

c.  Draw a logic diagram using only AND, OR, NAND, NOR, and NOT gates which
computes the parity function on three bits.

d.  Draw an electircal circuit diagram implementing the parity function on
three bits using MOS transistors.