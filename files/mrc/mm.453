TITLE MM
SUBTTL Assembly switches

;Version # stuff

VWHO==0
VMIN==^D8
VMAJ==1
VEDIT==^D453

; Historical notes:
;
;  The original version of MM was written by Michael McMahon at SRI
; International, presently at MIT.  At the time, it used a unique
; command parser designed by McMahon (ULTCMD), and had a similar user
; interface to the then-popular Tenex MSG program.  Stuart McLure Cracraft
; at SRI was also involved in early MM development and was primarily
; responsible for early popularizing of MM.
;
;  In the summer of 1978, a version of MM came to DEC.  Ted Hess at DEC
; converted it to MACRO and to use the COMND JSYS instead of ULTCMD.
; At this point, MM and the program which was later to become DEC's MS
; product diverged.  Since then, there has been a friendly competition
; between the MM and MS developers, although they address different
; audiences in the features they each have.
;
;  McMahon subsequently fixed MM to compile under both FAIL and MACRO
; as well as having ULTCMD available as an option (later ULTCMD was
; removed entirely).  Since the summer of 1979 most of the MM maintainence
; and development has been done by McMahon and Mark Crispin at Stanford
; University, with occasional contributions from others too numerous to
; name.  MM has matured to become the standard mailsystem on a number of
; systems, and extensive input from its numerous users has made MM a
; powerful and reliable mailsystem.
;
;  Communications about MM should be addressed to the MM maintainers:
;
;	Michael McMahon			Mark Crispin
;	MIT AI Lab		and/or	Department of Computer Science
;	545 Technology Square		Stanford University
;	Cambridge, MA  02139		Stanford, CA  94305
;	 MMcM@MIT-AI			 Admin.MRC@SU-SCORE

SEARCH MONSYM
IFNDEF .OSFAIL,<SALL>			;Clean MACRO listings

;;;Assembly flags

;Switches controlling site-dependent stuff

IFNDEF BBNSW,<BBNSW==0>			;BBN
 IFN BBNSW,<BBNSW==1>
IFNDEF CITSW,<CITSW==0>			;Cal Tech
 IFN CITSW,<CITSW==1>
IFNDEF CLSCSW,<CLSCSW==0>		;College of Science, Utah
 IFN CLSCSW,<CLSCSW==1>
IFNDEF COLSW,<COLSW==0>			;Columbia
 IFN COLSW,<COLSW==1>
IFNDEF DREASW,<DREASW==0>		;DREA
 IFN DREASW,<DREASW==1>
IFNDEF HPSW,<HPSW==0>			;Hewlett-Packard
 IFN HPSW,<HPSW==1>
IFNDEF ISISW,<ISISW==0>			;USC-ISI
 IFN ISISW,<ISISW==1>
IFNDEF MITSW,<MITSW==0>			;Any MIT site
 IFN MITSW,<MITSW==1>
IFNDEF RANDSW,<RANDSW==0>		;RAND-AI
 IFN RANDSW,<RANDSW==1>
IFNDEF RUTGSW,<RUTGSW==0>		;RUTGERS
 IFN RUTGSW,<RUTGSW==1>
IFNDEF SRISW,<SRISW==0>			;SRI-KL
 IFN SRISW,<SRISW==1>
IFNDEF STANSW,<STANSW==0>		;Any Stanford site
 IFN STANSW,<STANSW==1>
IFNDEF UTAHSW,<UTAHSW==0>               ;UTAH-20
 IFN UTAHSW,<UTAHSW==1>
IFNDEF UTEXSW,<UTEXSW==0>		;UTEXAS-20
 IFN UTEXSW,<UTEXSW==1>

;Stanford sites

IFNDEF GSBSW,<GSBSW==0>			;Stanford GSB
 IFN GSBSW,<GSBSW==1>
IFDEF LOTSW,<LOTSSW==LOTSW>		;Standard name for LOTS switch
IFNDEF LOTSSW,<LOTSSW==0>		;Stanford LOTS
 IFN LOTSSW,<LOTSSW==1>
IFNDEF SCORSW,<SCORSW==0>		;Stanford SCORE
 IFN SCORSW,<SCORSW==1>
IFNDEF SUMXSW,<SUMXSW==0>		;Stanford SUMEX 2020
 IFN SUMXSW,<SUMXSW==1>
IFN <GSBSW+LOTSSW+SCORSW+SUMXSW>,<STANSW==1>

;MIT sites

IFNDEF EECSSW,<EECSSW==0>		;MIT-EECS
 IFN EECSSW,<EECSSW==1>
IFNDEF SPCHSW,<SPCHSW==0>		;SPEECH-TWENEX
 IFN SPCHSW,<SPCHSW==1>
IFNDEF XXSW,<XXSW==0>			;MIT-XX
 IFN XXSW,<XXSW==1>
IFN <EECSSW+SPCHSW+XXSW>,<MITSW==1>

;All other sites default to "virgin DEC"

IFNDEF DECSW,<DECSW==1-<BBNSW!CITSW!CLSCSW!COLSW!DREASW!HPSW!ISISW!MITSW!RANDSW!RUTGSW!SRISW!STANSW!UTAHSW!UTEXSW>>
IFN DECSW,<DECSW==1>

;MM feature switches

IFNDEF REL3F,<REL3F==DREASW!HPSW!SRISW!SUMXSW>
					;TOPS-20 Release 3 misfeatures
IFNDEF NEWQF,<NEWQF==MITSW!RUTGSW!STANSW>;New network mailer (must use HOSTS2)
IFNDEF HOST2F,<HOST2F==NEWQF>		;Use HOSTS2.BIN host table
	;Note: if HOST2F is set SYSTEM:HOSTS2.BIN must exist for MM to work.
	;Also DECnet is currently not supported with HOSTS2.
IFNDEF SIPCFF,<SIPCFF==CLSCSW!COLSW!DREASW!RUTGSW!STANSW!UTAHSW!UTEXSW>
					;Special IPCF MAILER interface; FL%MM
					; in the request file suppresses IPCF
					; MAILER-generated headers.
IFNDEF OIPCFF,<OIPCFF==SIPCFF*<DREASW!RUTGSW>>;Old special IPCF interface; a
					; Date and From line are generated by
					; the MAILER irregardless of FL%MM
IFNDEF IPCFF,<IPCFF==CITSW!DECSW!SIPCFF!OIPCFF>;Use IPCF MAILER for local mail
IFNDEF PRNMSF,<PRNMSF==0>		;Suppress personal names in local mail
IFNDEF BDUPDF,<BDUPDF==HPSW!MITSW!SRISW>;Both read and write date updated when
					; file written
IFNDEF LPTCFF,<LPTCFF==RUTGSW>		;Require confirm for lineprinter output
IFNDEF INSTLF,<INSTLF==RUTGSW>		;Support for EXEC INSTALL command
IFNDEF LSQLMF,<LSQLMF==SRISW>		;Specifying a too-large sequence means
					; last message in file
IFNDEF CTLEKF,<CTLEKF==SRISW>		;Transpose functions of ^E and ^K
IFNDEF VPRMTF,<VPRMTF==1-<MITSW!SRISW!<STANSW-LOTSSW>>>
					;Verbose prompt for message text
IFNDEF EXBUGF,<EXBUGF==DECSW!UTEXSW>	;Compensate for bug in EXEC "I MAIL"
					; (see SETREF)
IFNDEF VTSSW,<VTSSW==MITSW>		;VTS clearing of screen
IFNDEF SPELLF,<SPELLF==1>		;Include the SPELL program linkage
IFNDEF NMSGS,<NMSGS==2000>		;Number of messages we can handle
IFNDEF PAGE0,<PAGE0==44>		;First free page
IFNDEF NEDPGS,<NEDPGS==^D20>		;Number of pages between MM and editor
IFNDEF NTXPGS,<NTXPGS==100>		;Number of pages for text input

;Check for obvious lossage in switch settings

IFNDEF .OSFAIL,<			;Tell MACRO what .FATAL means
 DEFINE .FATAL(MSG)<
  PASS2
  PRINTX ?MSG
  END
 >;DEFINE .FATAL
>;IFNDEF .OSFAIL

IFN 1-<BBNSW+CITSW+CLSCSW+COLSW+DECSW+DREASW+HPSW+ISISW+MITSW+RANDSW+RUTGSW+SRISW+STANSW+UTAHSW+UTEXSW>,<
	.FATAL Site conflicts>
IFN MITSW-<EECSSW+SPCHSW+XXSW>,<
	.FATAL MIT site conflicts>
IFN STANSW-<GSBSW+LOTSSW+SCORSW+SUMXSW>,<
	.FATAL Stanford site conflicts>
IFN NEWQF,<IFE HOST2F,<.FATAL HOST2F must be set if NEWQF>>

SUBTTL Macros

;;;This should be everything that depends on one dialect or another of
;;;the assembler

;;;Stuff for FAIL

IFDEF .OSFAIL,<

;Define useful conditionals
FOR @' MAC IN (BBN,CIT,CLSC,COL,DEC,DREA,EECS,HP,ISI,MIT,RAND,RUTG,SRI,STAN,UTAH,UTEX,LOTS,GSB,SCOR,SUMX,XX,SPCH)
   <	DEFINE MAC,<IFN MAC'SW>
	DEFINE NO'MAC,<IFE MAC'SW>
   >

DEFINE DEFPAG (ADDR,LENGTH)
   <	ADDR__PAGEN*1000
	IFIDN <LENGTH>,<>,<PAGEN==PAGEN+1>
	IFDIF <LENGTH>,<>,<PAGEN==PAGEN+LENGTH>
   >

DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST,MSK) <
    ..XX==0
    IFDIF <FLGS>,<>,<..XX==FLGS>
    ..XX==<TYP>*1B8+..XX
    IFDIF <HLPM>,<>,<..XX_CM%HPP!..XX>
    IFDIF <DEFM>,<>,<..XX_CM%DPP!..XX>
    IFDIF <MSK>,<>,<..XX_CM%BRK!..XX>
    IFDIF <LST>,<>,<..XX+LST>
    IFIDN <LST>,<>,<..XX>
    IFDIF <DATA>,<>,<DATA>
    IFIDN <DATA>,<>,<0>
    IFDIF <HLPM>,<>,<HLPM>
    IFIDN <HLPM>,<>,<0>
    IFDIF <DEFM>,<>,<DEFM>
    IFIDN <DEFM>,<>,<0>
    IFDIF <MSK>,<>,<MSK>
>
>;FAIL

;;;Stuff for MACRO-10

IFNDEF .OSFAIL,<

DEFINE DEFSIT(MAC) <
    IRP MAC,<
	DEFINE MAC,<IFN MAC'SW>
	DEFINE NO'MAC,<IFE MAC'SW>
>>

DEFSIT (<BBN,CIT,CLSC,COL,DEC,DREA,EECS,HP,ISI,MIT,RAND,RUTG,SRI,STAN,UTAH,UTEX,LOTS,GSB,SCOR,SUMX,XX,SPCH>)

DEFINE DEFPAG (ADDR,LENGTH)
   <	ADDR==PAGEN*1000
	IFIDN <LENGTH>,<>,<PAGEN==PAGEN+1>
	IFDIF <LENGTH>,<>,<PAGEN==PAGEN+LENGTH>
   >

DEFINE POS(MASK)<<^L<<MASK>&<-<MASK>>>>>
DEFINE FLD(VAL,MSK)<<VAL>B<POS(MSK)>>
DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST,MSK) <
	..XX==<FLD(TYP,CM%FNC)>+FLGS+<Z LST>
	IFNB <HLPM>,<..XX==CM%HPP!..XX>
	IFNB <DEFM>,<..XX==CM%DPP!..XX>
	IFNB <MSK>,<..XX==CM%BRK!..XX>
	..XX
	IFNB <DATA>,<DATA>
	IFB <DATA>,<0>
	IFNB <HLPM>,<HLPM>
	IFB <HLPM>,<0>
	IFNB <DEFM>,<DEFM>
	IFB <DEFM>,<0>
	IFNB <MSK>,<MSK>
>
>;MACRO

;;;Assembler independant macros

DEFINE REL3,<IFN REL3F>
DEFINE NOREL3,<IFE REL3F>
DEFINE IPCF,<IFN IPCFF>
DEFINE NOIPCF,<IFE IPCFF>
DEFINE SIPCF,<IFN SIPCFF>
DEFINE NOSIPCF,<IFE SIPCFF>
DEFINE OIPCF,<IFN OIPCFF>
DEFINE HOSTS2,<IFN HOST2F>
DEFINE NOHST2,<IFE HOST2F>
DEFINE NEWQ,<IFN NEWQF>
DEFINE NONEWQ,<IFE NEWQF>
DEFINE SPELL,<IFN SPELLF>
DEFINE VTS,<IFN VTSSW>
DEFINE NOVTS,<IFE VTSSW>

DEFINE CTL(CHAR) <"CHAR"-100>		;Useful for defining control characters

DEFINE DEFERR (X,Y)
   <	DEFINE X (Z)
	   <	IFIDN <Z>,<>,<UERR Y,0>
		IFDIF <Z>,<>,<UERR Y,[ASCIZ/Z/]>
	   >
   >

DEFINE	CMD ' (X,Y,Z) <
    IFIDN <Z>,<>,<
	IFIDN <Y>,<>,<[ASCIZ\X\],,.'X>
	IFDIF <Y>,<>,<[ASCIZ\X\],,Y>
    >
    IFDIF <Z>,<>,<
	IFIDN <Y>,<>,<[	Z
			ASCIZ\X\],,.'X>
	IFDIF <Y>,<>,<[	Z
			ASCIZ\X\],,Y>
    >
>

DEFINE	CMD1 (X,Y,Z) <
   IFIDN <Z>,<>,<CMD (X,Y,<CM%FW>)>
   IFDIF <Z>,<>,<CMD (X,Y,<CM%FW!Z>)>
>

DEFINE VAR (X,Y,Z)
   <	[ASCIZ/X/],,[Z,,Y]
   >

DEFINE HDY (X,Y,Z)
   <	RADIX 5+5
	[ASCIZ/X/],,[<Y-1>*512+<Z-1>,,DATHDY]
	RADIX 8
   >

DEFINE TYPE (X)
   <	UTYPE [ASCIZ/X/]
   >
DEFINE CTYPE (X)
   <	UTYPE 10,[ASCIZ/X/]
   >
DEFINE CITYPE (X)
   <	UTYPE 1,[ASCIZ/X/]
   >

DEFINE ETYPE (X)
   <	UETYPE [ASCIZ/X/]
   >
DEFINE CETYPE (X)
   <	UETYPE 10,[ASCIZ/X/]
   >
DEFINE CIETYP (X)
   <	UETYPE 1,[ASCIZ/X/]
   >

DEFINE NOISE (X)
   <	UNOI [ASCIZ/X/]
   >

DEFINE DEFALT (X,Y)
   <	UDEF [ASCIZ/X/]
   >

DEFINE PROMPT (X)
   <	UPRMT [ASCIZ/X/]
   >

DEFINE CONFRM
   <	CALL CONF
   >

DEFINE RETSKP
   <	JRST CPOPJ1
   >

DEFERR WARN,3
DEFERR JWARN,7
DEFERR CERR,10
DEFERR JCERR,14
DEFERR ERROR,11
DEFERR JERROR,15
DEFERR FATAL,12
DEFERR JFATAL,16
DEFERR SNARL,13				;Snarl = "error, but return to caller"
DEFERR JSNARL,17

SUBTTL Definitions

;;;AC's

F=0					;Flags
A=1					;Temp and JSYS
B=2					;Ditto
C=3					;Ditto
D=4					;Ditto
E=5					;Temp & local to routine
T=6					;Ditto
U=7					;Ditto
V=10					;Ditto 
W=11					;Ditto
L=12
M=13					;Current message if any
N=14
O=15
X=16
P=17

;;;Opdef's

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]
OPDEF CALLRET [JRST]
OPDEF PRINT [1B8]
OPDEF UTYPE [2B8]
OPDEF UETYPE [3B8]
OPDEF UERR [4B8]
OPDEF UNOI [5B8]
OPDEF UDEF [6B8]
OPDEF UPRMT [7B8]

CM%BRK==:<20,,0>			;COMND break mask present
OPDEF GTHST% [JSYS 273]			;Get host table
.GTHSZ==:0				;Host table sizes
.GTHIX==:1				;Index to string conversion
.GTHNS==:2				;Number to string conversion
.GTHSN==:3				;String to number conversion
.GTHHN==:4				;Host number to status
.GTHHI==:5				;Host index to status

;;;Flags

F%F1==1B0				;Temp
F%F2==1B1
F%F3==1B2
F%F4==1B3
F%F5==1B4
F%AT==1B5				;@ see in address
F%ADR==1B6				;Seen non-blank part of an address
F%QOT==1B7				;Inside a quoted string
F%STAD==1B8				;Inside structured address
F%CC==1B9				;In CC command
F%COMA==1B10				;Type comma except before 1st field
F%TYPS==1B11				;Type out numbers of messages handled
NEWQ,<
F%NEWQ==1B12				;Generate quoted host names
>;NEWQ

F%READ==1B18				;Inside the READ command
F%SEND==1B19				;Inside the SEND commands
F%RSCN==1B20				;Called by command line
F%MOD==1B21				;Reading system mail
F%AMOD==1B22				;Auto MOD handling
F%TECO==1B23				;Using TECO based editor
F%RONL==1B24				;Read only file
F%RPLY==1B25				;Inside a reply to this message
F%ESND==1B26				;Editor said send it off
F%TECP==1B27				;Editor supports hairy TECO interface
F%DIRE==1B28				;In message dired mode
F%HOER==1B29				;Halt on error
F%RPTO==1B30				;Processed a Reply-To
F%ARPA==1B31				;Queued ARPANET mail
F%DECN==1B32				;Queued DECnet mail
F%ALIA==1B33				;Aliasing another user

ESC==33					;ESCAPE key
EOL==37					;Newline for PRINT UUO

SYSCOD==-2				;Special user number for SYSTEM
BBDCOD==-3				;Special user number for BBOARD
					; (used only by MM!  MAILER doesn't
					;  know about it)

IPCF,<
NACK1==2				;Total wipeout by MAILER
SIPCF,<
FL%MM==1B0				;Don't generate headers, we will
>;SIPCF
>;IPCF

HOSTS2,<
;The format of the compiled HOSTS2 file is:

HSTSID==0	; wd 0	SIXBIT /HOSTS2/
NAMPTR==10	; wd 10 Address in file of NAME table.
SITPTR==11	; wd 11	Address in file of SITE table.
NETPTR==12	; wd 12 Address in file of NETWORK table.

;NETWORK table
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (2)
NETNUM==0	; wd 0	network number
NTLNAM==1	; wd 1 LH - address in file of name of network
NTRTAB==1	; wd 1 RH - address in file of network's address table

;ADDRESS table(s)
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (2)
ADDADR==0	; wd 0	Network address of this entry including network number
ADLSIT==1	; wd 1 LH - address in file of SITE table entry
ADRCDR==1	; wd 1 RH - address in file of next ADDRESS entry for this site
		;	    0 = end of list

;SITE table
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (3)
STLNAM==0	; wd 0 LH - address in file of official host name
STRADR==0	; wd 0 RH - address in file of first ADDRESS table entry for
		;	    this site.  Successive entries are threaded
		;	    together through ADRCDR.

;NAMES table:
; wd 0	Number of entries
; wd 1	Number of words per entry. (1)
NMLSIT==0	; lh	address in file of SITE table entry for this host.
NMRNAM==0	; rh	address in file of host name

; All names are ASCIZ strings, all letters upper case.
; The strings are stored before, after and between the tables.
; All strings are word-aligned, and fully zero-filled in the last word.

;Network addresses are defined as follows, for purposes of this table:
;    4.9     0
;    4.8-4.1 network number
;    Chaos net (number 7):
;	3.9-2.8	0
;	2.7-1.1 address (2.7-1.9 subnet, 1.8-1.1 host)
;    ARPANET (number 12):	(note, old-format ARPANET addresses
;	3.9-3.8	0	 	never appear in the host table.)
;	3.7-2.1	IMP
;	1.9	0
;	1.8-1.1	Host
;    Dialnet (number 26):
;	3.9-3.1	0
;	2.9-1.1	address in file of ASCIZ string of phone number

NW%CHS==7	;Chaos net
NW%ARP==12	;ARPANET
NW%DLN==26	;Dialnet
>;HOSTS2

SUBTTL Page allocation

PAGEN==PAGE0				;Start allocating there

DEFPAG HDRPAG				;Headers
DEFPAG HDNPAG				;Copy for DECnet headers
DEFPAG TXTPAG,NTXPGS			;Message text page
DEFPAG TOPAG,10				;Storage for TO/CC lists
DEFPAG FWDPAG				;Page for mapping to MAILBOX program
NOHST2,<
DEFPAG HSTNAM,2				;Host names
DEFPAG HOSTN				;Host numbers
DEFPAG HOSTAB				;Pointers to above
>;NOHSTS2
HOSTS2,<
DEFPAG HSTPAG,10			;Place to map HOSTS2.BIN
>;HOSTS2
DEFPAG FLGPAG				;For MAILER.FLAGS
DEFPAG EDBPAG				;Editor buffer block page
DEFPAG EDPAGE,NEDPGS			;Editor pages for data
SPELL,<
DEFPAG SPLPAG,NEDPGS			;SPELL pages for transfer (quicker
>;SPELL					; than reusing the editor pages)
DEFPAG WRTPGS,2				;Map file for write to update
DEFPAG KEYPAG				;Page full of keyword names
DEFPAG USRHDR				;Page for user generated headers

MSGLEN==11				;Length of block
DEFPAG MSGPGS,<NMSGS/1000*MSGLEN>	;Storage for message data

MSGALL==MSGPGS+0			;Starting byte of message
MSGSAL==MSGPGS+1			;Size of whole message
MSGBOD==MSGPGS+2			;Size of message body,,starting byte
MSGFRM==MSGPGS+3			;Size of from field,,starting byte
MSGSUB==MSGPGS+4			;Size of subject,,starting byte offset
MSGDAT==MSGPGS+5			;Date of message
MSGFLG==MSGPGS+6
 MSGHLN==MSGFLG				;Length of the message header portions
MSGBTS==MSGPGS+7			;Msg bits
MSGFBS==MSGPGS+10			;Bits in file

M%SEEN==1				;Message has been seen
M%DELE==2				;Message is deleted
M%ATTN==4				;Message wants attention (always-show)
M%RPLY==10				;Message has been replied to

M%RECE==1B0				;Message is recent (sign bit)
M%FRME==1B1				;Message is from me
M%FRNM==1B2				;Messages is from someone else

MSGPAG==PAGEN				;Start of file mapping area

SUBTTL Impure storage

LOC 41
	CALL UUOH			;UUO handler
LOC 120					;need 116, 117 for DDT
	NPDL==177			;Size of PDL
PDL:	BLOCK NPDL			;Pushdown list

CMDRET:	BLOCK 1				;Usual return dispatch for error
PRGNAM:	BLOCK 2				;Save area for subsystem/program names

MYDIR:	BLOCK 1				;Login directory
MYCDIR:	BLOCK 1				;Connected directory
MYDIRS:	BLOCK 10			;ASCII of login directory

NOVTS,<
TTYPE:	BLOCK 1				;Terminal type
>;NOVTS
SAVMOD:	BLOCK 5				;Normal tty modes
EDMOD:	BLOCK 5				;Editor modes

MSGSEQ:	BLOCK NMSGS/3			;Table of numbers of messages
MSGSQZ==.

ZERMEM==.				;Start clearing here at startup
SNDCAL:	BLOCK 1				;Caller of send subcommands
OKTINT:	BLOCK 1				;Is it ok for timer to interrupt now?
CHKTIM:	BLOCK 1				;Next time to check for new messages
MSGJFN:	BLOCK 1				;JFN for current message file
MSGJF2:	BLOCK 1				;JFN to open for write
OUTJFN:	BLOCK 1				;Output file JFN
INIJFN:	BLOCK 1				;MM.INIT JFN
TMPJFN:	BLOCK 1				;Temporary files
HSTJFN:	BLOCK 1				;Host tables, etc.
LASTM:	BLOCK 1				;Number of messages in current file
FILPGS:	BLOCK 1				;Size of the file in pages
FILSIZ:	BLOCK 1				;Size of the file (bytes)
FILCRV:	BLOCK 1				;Creation date
FILWRT:	BLOCK 1				;Write date
LASTRD:	BLOCK 1				;Last read date of file
NRECNT:	BLOCK 1				;Number of recent messages
NUNSEE:	BLOCK 1				;Number of unseen messages
NDELET:	BLOCK 1				;Number of deleted messages
PRIORM:	BLOCK 1				;Saved current message number
LSTMSG:	BLOCK 1				;Saved last message for typing out seq
DOMSG:	BLOCK 1				;Dispatch to process next message
NXTMSD:	BLOCK 1				;Dispatch to fetch next message
RPVSAV:	BLOCK 1				;Saved state for read mode prev command
LHOSTN:	BLOCK 1				;Local host number, -1 if not ARPANET
MYHNAM:	BLOCK 20			;ARPANET host name
DNHNAM:	BLOCK 20			;DECnet host name
HOSTS2,<
LHOSTP:	BLOCK 1				;Local host pointer
>;HOSTS2
PSIPC1:	BLOCK 1				;Saved pc from psi routine
PSIPC2:	BLOCK 1				;Ditto
EXECFK:	BLOCK 1				;Saved fork handle for EXEC
EDFORK:	BLOCK 1				;Editor fork
EFRKPC:	BLOCK 1				;Editor fork's PC
EDPAG0:	BLOCK 1				;First page of editor fork mapped in
SPELL,<
SPLFRK:	BLOCK 1				;SPELL's fork handle
SPLIFL:	BLOCK 1				;Input file JFN
SPLOFL:	BLOCK 1				;Output file JFN
>;SPELL
TOLIST:	BLOCK 1				;TO list pointers tail,,head
CCLIST:	BLOCK 1				;CC list pointers tail,,head
BCCLST:	BLOCK 1				;BCC list
FREETO:	BLOCK 1				;Pointer to free space for to/cc lists
LCLIST:	BLOCK 1				;List of local recipients
FILIST:	BLOCK 1				;List of file "recipients"
NETLST:	BLOCK 1				;List of network recipients
MSGSIZ:	BLOCK 1				;Size of last message we sent
MOVDSP:	BLOCK 1				;Dispatch for typing or setting to, etc
REPDAT:	BLOCK 1				;Reply date
SAVU:	BLOCK 1				;Used by address parser
SAVL:	BLOCK 1				;Saved sequence pointer
NXTIME:	BLOCK 1				;Time for before/after/on filters
CLEVEL:	BLOCK 1				;Command/subcommand level
TPADD1:	BLOCK 1				;Top level command dispatch
TPADDR:	BLOCK 1				;Reparse address for COMND reparsing
LSTCHR:	BLOCK 1				;Confirming character
BUFNAM:	BLOCK 2				;Name of the editor buffer
EDINAM:	BLOCK 2				;Type of edit being performed
HSTPTR:	BLOCK 1				;Pointer to host table
UNTHDR:	BLOCK 1				;Save of unto header word
KEYPTR:	BLOCK 1				;Pointer to keyword string area
KEYBTS:	BLOCK 1				;Bit masks for keywords
RMLPTR:	BLOCK 1				;String pointer and flag for REMAIL
RSTMOD:	BLOCK 1				;Type of restore draft
UUOACS:	BLOCK 20			;AC's during LUUO call
INTACS:	BLOCK 20			;During timer interrupt routines
FRKACS:	BLOCK 20			;Setup for editor fork's ac's
SPELL,<
SPLACS:	BLOCK 20			;SPELL's ACs
>;SPELL
	CSBFSZ==1000
CSBUF:	BLOCK CSBFSZ			;Command line buffer
	PATSTR==CSBUF+CSBFSZ/2		;Also used for from filters
CMDGTB:	BLOCK .GJATR+1			;GTJFN block
CMDFLB:	BLOCK 4				;Individual field block
	STRBSZ==1000
SRCBUF==.
FILNAM==.
STRBUF:	BLOCK STRBSZ			;Temporary string space

;;;User variables

RINCME:	BLOCK 1				;Include me in any replies by default
RCCOTH:	BLOCK 1				;Reply cc's everyone other than from
GTCNDR:	BLOCK 1				;>0 conn dir always, <0 login, 0 ask
BLNKER:	BLOCK 1				;-1 if an error occurred so no blank
ESCSND:	BLOCK 1				;Escape sends automatically
REPDIS:	BLOCK 1				;Reply command automatically displays
RFMDEF:	BLOCK 1				;Reply<cr> means just from, not all
BLSCST:	BLOCK 1				;Blank screen on startup
CRSEND:	BLOCK 1				;Just return sends message
HDR733:	BLOCK 1				;Personal Name <User at SITE> style
LSTHDR:	BLOCK 1				;Output a list of headers at the start
					; of the listing
SNDVBS:	BLOCK 1				;Degree of sending verbosity
ABOFLG:	BLOCK 1				;^N aborts >0 always, 0 ask, <0 never
CMIMWK:	BLOCK 1				;Non-zero means CM%WKF on commands
LSTPAG:	BLOCK 1				;List messages on separate pages
SAVFIL:	BLOCK 10			;SAVED.MESSAGES file to use
PERNAM:	BLOCK 20			;Personal name
DEFCCL:	BLOCK 20			;Default cc list
DEFBCL:	BLOCK 20			;Default bcc list
DEFPRO:	BLOCK 1				;Default protection for .TXT files
DEFPST:	BLOCK 2				;String version of above
KEYTBL:	BLOCK 23			;Table of keywords for messages
USRHTB:	BLOCK 23			;Table of user message headers
SPRHDR:	BLOCK 23			;Table of headers to not type out
ONLHDR:	BLOCK 23			;Table of headers to only type out
TOPRMT:	BLOCK 10			;Top-level prompt string
REPRMT:	BLOCK 10			;Read-level prompt string
SEPRMT:	BLOCK 10			;Send-level prompt string
REL3,<
EDITOR:	BLOCK 10			;Editor name
>;REL3
ZEREND==.-1				;End of where to clear

SPELL,<
SPLNAM:	ASCIZ/SYS:SPELL.EXE/		;Name of SPELL program
SPLOFF==2				;Entry vector offset to run at
>;SPELL

TTXTIB:	7
	RD%JFN
	.PRIIN,,.PRIOU
TXTPTR:	0				;Put updated pointer here
TXTCNT:	0				;Put count here
	POINT 7,TXTPAG			;Where it starts
	0
	TXTMSK				;Break table for text

FSCPKL:	0				;a LSHC A,<n> for SHIFT-IN goes here
	LSH A,1
	MOVEM A,(C)			;Address of dest stored in RH here
	0				;a LSHC A,<n> for SHIFT-OUT goes here
	MOVE B,(C)			;Address of source stored in RH here
	AOBJN C,FSCPKL
	JRST @FENTRM(D)

CMDBLK:	REPARS				;COMND state table
	.PRIIN,,.PRIOU
	0
	POINT 7,CSBUF
	POINT 7,CSBUF
	CSBFSZ*5
	0
	POINT 7,STRBUF
	STRBSZ*5
	CMDGTB

IPCF,<
PIDGET:	IP%CPD				;Block for finding [SYSTEM]MAILER
	0
	0
	ENDPID-.,,.+1			;Pointer to actual message
	1,,1				;Get PID for name
	0
	ASCIZ/[SYSTEM]MAILER/
ENDPID==.
>;IPCF

REQID=='MM'				;Request ID for our ENQing

ENQBLK:	1,,ENQBLL			;Number of locks, block size
	REQID				;Interrupt channel, request ID
	0				;Flags, level number,,JFN
	-1,,[ASCIZ/Mail expunge interlock/]	;Pointer to name string
	0				; (this name used because MS uses it)
	0
ENQBLL==.-ENQBLK			;Length of ENQ BLOCK

ACCBLK:	BLOCK 3				;Block for ACCES JSYS

SUBTTL Pure storage

;;;Break mask for slurping up a user name

UNMMSK:	777777777760			;no controls
	767544001760			;%, *, -, .. numerics
	400000000760			;upper case alphabetics
	400000000760			;lower case alphabetics

;;;TEXTI break mask for user input

UTXTMS:	000220000400			;^J, ^M, ESC
	000040001000			;, :
	400000000000			;@
	000000000000

;;;TEXTI break mask for text input

TXTMSK:	110140001400			;^B, ^E, ^K, ^L, ^Z, ESC
	000000000000
	000000000000
	000000000000

;;;Interrupt storage

LEVTAB:	PSIPC1
	PSIPC2
	0
CHNTAB:	BLOCK 4
	1,,ABOINT			;^N on chan 4
	2,,TMRINT			;Timer on chan 5
	BLOCK 36

EVEC:	JRST GO				;Entry vector
	JRST GOAMOD
VERNUM:	BYTE (3) VWHO (9) VMAJ (6) VMIN (18) VEDIT
EVECL==.-EVEC

SUBTTL Command tables

;;;Top level commands

CMDTAB:	NCMDS,,NCMDS 
	CMD1 (A,ENTANS,CM%ABR!CM%INV)
	CMD ALIAS
ENTANS:	CMD ANSWER
	CMD APPEND
	CMD BBOARD,.MSBBD
	CMD BLANK
	CMD BUG
	CMD CHECK
	CMD CONTINUE
	CMD COPY
	CMD COUNT
	CMD CREATE-INIT,.CRINI
	CMD1 (D,ENTDEL,CM%ABR!CM%INV)
	CMD DAYTIME
ENTDEL:	CMD DELETE
	CMD DIRED
	CMD EDIT
	CMD ENABLE
	CMD1 (EX,ENTXIT,CM%ABR!CM%INV)
	CMD EXAMINE
ENTXIT:	CMD EXIT
	CMD EXPUNGE
	CMD FILE-LIST,.FLIST
	CMD FLAG
	CMD FORWARD
	CMD GET
	CMD1 (H,ENTHDR,CM%ABR!CM%INV)
ENTHDR:	CMD HEADERS
	CMD HELP
	CMD JUMP
	CMD KEYWORDS
	CMD LIST
	CMD LITERAL-TYPE,.LTYPE
	CMD LOGOUT
	CMD1 (MAIL,.SEND,CM%INV)
	CMD MARK
	CMD MOVE
	CMD1 (N,ENTNXT,CM%ABR!CM%INV)
	CMD NET-MAIL,.MAILE
ENTNXT:	CMD NEXT
	CMD PREVIOUS
	CMD PROFILE
	CMD PUSH
	CMD QUIT
	CMD1 (R,ENTRED,CM%ABR!CM%INV)
ENTRED:	CMD READ
	CMD REMAIL
	CMD1 (REPLY,.ANSWE,CM%INV)
	CMD RESTORE-DRAFT,.RESTO
	CMD1 (S,ENTSND,CM%ABR!CM%INV)
ENTSND:	CMD SEND
	CMD SET,.VARIA
	CMD STATUS
	CMD SYSTEM-MSGS,.MSGOD
	CMD TYPE
	CMD UNANSWER
	CMD UNDELETE
	CMD UNFLAG
	CMD UNKEYWORDS
	CMD UNMARK
	CMD VERSION
NCMDS==.-CMDTAB-1

;;;READ commands

RCMDTB:	NRCMDS,,NRCMDS
	CMD1 (ANSWER,.REPLY,CM%INV)
	CMD BLANK
	CMD CONTINUE
	CMD COPY
	CMD DELETE,.RDELM
	CMD EDIT,.REDIT
	CMD1 (FILE-LIST,.COPY,CM%INV)
	CMD FLAG,.RFLAG
	CMD FORWARD,.RFORW
	CMD1 (H,ENTRHE,CM%ABR!CM%INV)
ENTRHE:	CMD HEADER,.RHEAD
	CMD HELP
	CMD KEYWORDS,.RKEYW
	CMD1 (L,ENTRLS,CM%ABR!CM%INV)
ENTRLS:	CMD LIST
	CMD LITERAL-TYPE,.LRTYP
	CMD1 (MAIL,.SEND,CM%INV)
	CMD MOVE
	CMD1 (N,ENTRNE,CM%ABR!CM%INV)
	CMD NET-MAIL,.MAILE
ENTRNE:	CMD NEXT,.RNEXT
	CMD1 (P,ENTRPR,CM%ABR!CM%INV)
ENTRPR:	CMD PREVIOUS,.RPREV
	CMD PUSH
	CMD QUIT,.RQUIT
	CMD1 (R,ENTRRP,CM%ABR!CM%INV)
	CMD REMAIL,.RREMA
ENTRRP:	CMD REPLY
	CMD1 (S,ENTSEN,CM%ABR!CM%INV)
ENTSEN:	CMD SEND
SPELL,<
	CMD SPELL,.RSPEL
>;SPELL
	CMD TYPE,.TYPMS
	CMD1 (U,ENTRUN,CM%ABR!CM%INV)
	CMD UNANSWER,.RUNAN
ENTRUN:	CMD UNDELETE,.RUDLM
	CMD UNFLAG,.RUFLG
	CMD UNKEYWORDS,.RUKEY
	CMD UNMARK,.RUMRK
NRCMDS==.-RCMDTB-1

;;;SEND (and REPLY) commands

SCMDTB:	NSCMDS,,NSCMDS
	CMD BCC
	CMD BLANK
	CMD CC
	CMD DISPLAY
	CMD EDIT,.SEDIT
	CMD ERASE
	CMD HELP
	CMD INSERT,.INSFL
	CMD LITERAL-TYPE,.LRTYP
	CMD1 (MAIL,.SSEND,CM%INV)
	CMD PUSH
	CMD QUIT,.SQUIT
	CMD REMOVE,.UNTO
	CMD RESTORE-DRAFT,.SREST
	CMD1 (S,ENTSDR,CM%ABR!CM%INV)
	CMD SAVE-DRAFT,.SSAVE
ENTSDR:	CMD SEND,.SSEND
SPELL,<
	CMD SPELL,.SSPEL
>;SPELL
	CMD SUBJECT
	CMD TEXT
	CMD TO
	CMD TYPE,.TYPMS
	CMD USER-HEADER,.USHDR
NSCMDS==.-SCMDTB-1

;;;ERASE commands

ECMDTB:	NECMDS,,NECMDS
	CMD ALL,.ERSAL
	CMD BCC,.ERSBC
	CMD CC,.ERSCC
	CMD REPLY-DATE,.ERSDT
	CMD SUBJECT,.ERSSB
	CMD TEXT,.ERSTX
	CMD TO,.ERSTO
NECMDS==.-ECMDTB-1

;;;DISPLAY commands

DCMDTB:	NDCMDS,,NDCMDS
	CMD ALL,.DSALL
	CMD BCC,.DSBCC
	CMD CC,.DSCC
	CMD SUBJECT,.DSSUB
	CMD TEXT,.DSTXT
	CMD TO,.DSTO
NDCMDS==.-DCMDTB-1

;;;EDIT commands

EDCMTB:	NEDCMS,,NEDCMS
	CMD HEADERS,.EDHEA
	CMD TEXT,.EDTXT
NEDCMS==.-EDCMTB-1

;;;REPLY commands

RPCMTB:	NRPCMS,,NRPCMS
	CMD ALL,.REPAL
	CMD SENDER,.REPFM
NRPCMS==.-RPCMTB-1

;;;Sequence commands

SQCMTB:	NSQCMS,,NSQCMS
	CMD1 (A,ENTALL,CM%INV!CM%ABR)
	CMD1 (AFTER,STQAFT,CM%INV)
ENTALL:	CMD ALL,STQALL
	CMD ANSWERED,STQANS
	CMD BEFORE,STQBEF
	CMD CURRENT,STQCUR
	CMD DELETED,STQDEL
	CMD1 (F,ENTFRM,CM%INV!CM%ABR)
	CMD FLAGGED,STQFLG
ENTFRM:	CMD FROM,STQFRM
	CMD INVERSE,STQREV
	CMD KEYWORDS,STQKEY
	CMD LAST,STQLST
	CMD NEW,STQNEW
	CMD ON,STQON
	CMD PREVIOUS-SEQUENCE,STQPRV
	CMD RECENT,STQREC
	CMD SEEN,STQSEE
	CMD SINCE,STQAFT
	CMD SUBJECT,STQSBJ
	CMD TEXT,STQTXT
	CMD TO,STQTO
	CMD UNANSWERED,STQUNA
	CMD UNDELETED,STQUND
	CMD UNFLAGGED,STQUNF
	CMD UNKEYWORDS,STQUNK
	CMD UNSEEN,STQUNS
NSQCMS==.-SQCMTB-1

;;;RSCAN commands

RSCMTB:	NRSCMS,,NRSCMS
	CMD ALIAS
	CMD BBOARD,.MSBBD
	CMD EXAMINE
	CMD GET
	CMD HEADERS,.RSHEA
	CMD1 (R,ENTRSR,CM%INV!CM%ABR)
ENTRSR:	CMD READ,.RSREA
	CMD RESTORE-DRAFT,.RESTO
	CMD1 (S,ENTSNR,CM%INV!CM%ABR)
ENTSNR:	CMD SEND
	CMD SYSTEM-MSGS,.MSGOD
NRSCMS==.-RSCMTB-1

;;;Date keywords

DATTAB:	NDATBS,,NDATBS
	VAR FRIDAY,DATDOW,4
	VAR MONDAY,DATDOW,0
	VAR SATURDAY,DATDOW,5
	VAR SUNDAY,DATDOW,6
	VAR THURSDAY,DATDOW,3
	VAR TODAY,DATDAY,0
	VAR TUESDAY,DATDOW,1
	VAR WEDNESDAY,DATDOW,2
	VAR YESTERDAY,DATDAY,1
NDATBS==.-DATTAB-1

;;;Holiday keywords

HOLDAY:	NHLDYS,,NHLDYS
	HDY APRIL-FOOLS,4,1
	HDY BASTILLE-DAY,7,14
	HDY BEETHOVENS-BIRTHDAY,12,16
	HDY BILBOS-BIRTHDAY,9,22
	HDY CHRISTMAS,12,25
	HDY COLUMBUS-DAY,10,12
	HDY FLAG-DAY,6,14
	HDY FRODOS-BIRTHDAY,9,22
	HDY GONDORIAN-NEW-YEAR,3,25
	HDY GROUND-HOGS-DAY,2,2
	HDY GUY-FAWKES-DAY,11,5
	HDY HALLOWEEN,10,31
	HDY INDEPENDENCE-DAY,7,4
	HDY LEAP-DAY,2,29
	HDY LINCOLNS-BIRTHDAY,2,12
	HDY MAY-DAY,5,1
	HDY NEW-YEARS,1,1
	HDY SAINT-PATRICKS-DAY,3,17
	HDY SHERLOCK-HOLMES-BIRTHDAY,1,6
	HDY VALENTINES-DAY,2,14
	HDY WASHINGTONS-BIRTHDAY,2,22
NHLDYS==.-HOLDAY-1

SUBTTL Main program

GO:	TDZA F,F			;Reset flags
GOAMOD:	 MOVEI F,F%AMOD			;Automatic mod handling
	RESET
	MOVE P,[IOWD NPDL,PDL]
	MOVE A,[SIXBIT /MM/]
	SETNM
	SETO A,				;Get our names
	MOVE B,[-2,,PRGNAM]
	MOVEI C,.JISNM
	GETJI
	 JFATAL
	MOVE A,[JRST CMDRES]		;Setup initial return dispatch
	MOVEM A,CMDRET
IPCF,<
	SETZM PIDGET+1			;Forget any garbage PID
>;IPCF
	CALL INIT			;Init interrupts and tty modes

;;;Now ready to read in the user's MM.INIT.  Clear any previous init settings.

GOINIT:	SETZM ZERMEM
	MOVE A,[ZERMEM,,ZERMEM+1]
	BLT A,ZEREND			;Clear out garbage stuff
	SETOM RFMDEF			;Reply<cr> means just from, not all
	SETOM BLSCST			;Blank screen on startup
	SETOM CRSEND			;Just return sends message
	SETOM HDR733			;Personal Name <User at SITE> style
	SETOM LSTHDR			;Output a list of headers in listings
	AOS SNDVBS			;Degree of sending verbosity
	MOVE A,[ASCII/MM>/]		;Top-level prompt
	MOVEM A,TOPRMT
	DMOVE A,[ASCII/R>/		;Read prompt
		 ASCII/S>/]		;Send prompt
	MOVEM A,REPRMT
	MOVEM B,SEPRMT
REL3,<
	MOVE A,[ASCII/EMACS/]		;Default editor
	MOVEM A,EDITOR
	SETZM EDITOR+1
>;REL3
	MOVEI A,KEYPAG
	MOVEM A,KEYPTR			;Initialize pointer free space
	SETZM USRHDR			;Reset user headers
	CALL DOINIT			;Parse init file
	SKIPL BLNKER			;Did an error happen?
	 JRST GOINI1			;No, don't offer to rewrite init
	PROMPT <May I rewrite your MM.INIT file?>
	CALL YESNO			;Yes, offer to fix it
	 JRST GOINI1			;User said no, don't blank screen
	CALL CRINI0			;Fix it
	SETZM BLNKER			;Allow blanking since user fixed it
;	JRST GOINI1

;;;Here after INIT file has been processed

GOINI1:	TRNE F,F%AMOD			;Auto mod handling?
	 JRST MSGOD0			;Yes, go enter that right now
	CALL DORSCN			;Do RSCAN hacking
	SKIPE BLSCST			;Clear off the screen, maybe
	 AOSN BLNKER			;Error in init processing?
	  CAIA				;No blanking at startup, or init error
	   CALL BLANK1			;Blank screen
	CALL .VERS1			;Tell version
	CALL GETFIL			;Get and parse file,
	CALL RECENT			;Show data on recent messages
	CALL SUMMRY			;And a summary of the files contents

CMDRES:	MOVE P,[IOWD NPDL,PDL]		;Errors that return to command level
					; come here
CMDLUP:	TRNE F,F%RSCN			;Command line routine terminated?
	 CALL QUIT0			;Yes, go get rid of file and stop
	CALL CHECK			;Check for new messages
	SKIPGE M			;Make sure have a valid message
	 SKIPA M,PRIORM			;Don't, use last one then
	  MOVEM M,PRIORM		;Yes, save in case for next time
	MOVE A,[TOPRMT,,CMDTAB]		;Pointer to current command
	CALL CMDINI			;Init command state, etc.
	SETOM OKTINT			;OK for timer interrupt here
	CALL GETCMD
	CALL (A)
	JRST CMDLUP			;And keep going

SUBTTL Command routines

.HHEAD:	[ASCIZ/
The HEADERS command takes one argument, a message sequence.  It will then
output all the headers of that sequence in order of lowest message number
to highest.
/]
.HRHEA:	[ASCIZ/
The HEADER command outputs the one-line header summary of the current
message sequence.
/]

;;;Headers of messages

.RSHEA:	CALL RSCFIL			;RSCAN call, get the file
.HEADE:	CALL DFSQTH			;Get sequence, default to current
	MOVEI A,TYPHDR			;Setup to type out header
	CALLRET DOMSGS			;And go handle them all

.HSTAT:	[ASCIZ/
The STATUS command tells you relevant information and statistics about
your current message file, i.e. how many messages are deleted, unseen, how
large the file is, etc.
/]

;;;Give status

.STATU:	CONFRM
	SKIPG A,MSGJFN
	 ERROR (No current file)
	TLZ F,(F%F1)			;Don't type headers
	PUSH P,M			;Save where we are
	ETYPE < File: %1J>		;Say what file we are using
	CALL RECEN0
	CALL SUMMRY
.STAT1:	POP P,M
	CIETYP < Currently at msg %M.
>
	RET

.HTYPE:	[ASCIZ/
The TYPE command takes a single argument, a message sequence. It then
types out the bodies of those messages.
/]
.HRTYP:	[ASCIZ/
The TYPE command types out the message again.
/]
.HSTYP:	[ASCIZ/
The TYPE command types out the current message (not the one you are sending!).
/]

.HLTYP:	[ASCIZ/
The LITERAL-TYPE command takes a single argument, a message sequence. It then
types out the bodies of those messages, without regard to ONLY-TYPE-HEADERS
or DONT-TYPE-HEADERS.
/]
.HLRTY:	[ASCIZ/
The LITERAL-TYPE command types out the message again, without suppressing
any headers.
/]
.HLSTY:	[ASCIZ/
The LITERAL-TYPE command types out the current message (not the one you are
sending!), without suppressing any headers.
/]

;;;Type messages

.TYPE:	CALL DFSQTH
	MOVEI A,TYPE1
	CALLRET DOMSGS
	
TYPE1:	CALL CHKDEL			;Not the deleted ones
	 RET
	CALLRET TYPMSG

;;; Literal typing (no filters)
.LTYPE:	CALL DFSQTH
	MOVEI A,LTYPE
	CALLRET DOMSGS

LTYPE:	CALL CHKDEL
	 RET
	CALLRET TYPMSL

.HMARK:	[ASCIZ/
The MARK command takes one argument, a message sequence.  It will then mark
the messages in that sequence as seen.
/]
.HDELE:	[ASCIZ/
The DELETE command takes one argument, a message sequence and marks it for
deletion.  The messages are not erased until the EXPUNGE command is given.
/]
.HRDEL:	[ASCIZ/
The DELETE command deletes the message currently being read.
/]

;;;Mark messages

.MARK:	SKIPA A,[MRKMSG]

;;;Delete messages

.DELET:	 MOVEI A,DELMSG
DELET0:	MOVEM A,DOMSG			;Set up handler
	CALL DFSQTH			;Get sequence, default to current
DELET1:	TLOA F,(F%TYPS)			;Say to print numbers of things done
DOMSGS:	 MOVEM A,DOMSG			;Enter here with routine to handle them in A
DELET2:	CALL NXTMSG			;Next message spec'd
	 RET
	CALL @DOMSG			;Process the message
	CALLRET DELET2

;;;Put keywords on messages
.HKEYW:	.+1
	ASCIZ/
The KEYWORDS command takes two arguments, a keywords list and a message
sequence.  It will then mark the messages in that sequence as being
included in the keyword.  To define a keyword, put a line in your MM.INIT
of the form:
	KEYWORDS list-of-keywords
This feature is useful for classifying old messages.
/
.HUNKE:	[ASCIZ/
The UNKEYWORDS command takes two arguments, a keywords list and a message
sequence.  It will then mark the messages in that sequence as not being
included in the keyword.
/]

.UNKEY:	SKIPA A,[UNKMSG]
.KEYWO:	 MOVEI A,KEYMSG
	PUSH P,A
	CALL GETKY0			;Get list of keywords
	HLRM U,KEYBTS			;Save mask bits
	POP P,A
	CALLRET DELET0			;And go handle sequence

.HNEXT:	[ASCIZ/
The NEXT command goes to the next message in the file (or message sequence
if in READ mode) and types it if undeleted.
/]
.NEXT:	NOISE (MESSAGE)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)
	CAML M,LASTM			;At last message?
	 JRST [	CIETYP < Currently at end, msg %M.
>
		RET]
	ADDI M,MSGLEN			;Nope, increment him
.NEXT1:	CALL CHKDEL			;Deleted?
	 RET
	CALLRET TYPMSG			;No, type the next one then

.HPREV:	[ASCIZ/
The PREVIOUS command goes to the previous message in the file and types it
if undeleted.
/]
.PREVI:	NOISE (MESSAGE)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)
	JUMPE M,[CIETYP < Currently at beginning, msg %M.
>
		 RET]
	SUBI M,MSGLEN
	CALLRET .NEXT1

.HJUMP:	[ASCIZ/
The JUMP command allows you to specify a message in the current message
file to jump to.  This means make the new current message will be the
JUMP'ed message.
/]
.JUMP:	SKIPG MSGJFN
	 ERROR (No current file)
	NOISE (TO MSG NUMBER)
	MOVEI B,[FLDDB. .CMNUM,,^D10]	;Read a number
	CALL CMDFLD
	PUSH P,B
	CONFRM
	EXCH M,(P)			;Get back number typed
	SUBI M,1
	IMULI M,MSGLEN			;Convert to msg pointer
	CAMG M,LASTM
	 JUMPGE M,CPOPAJ		;Number ok, just flush saved value
	POP P,M
BADNUM:	ERROR (Number out of range)

.HFLAG:	[ASCIZ/
The FLAG command takes one argument, a message sequence. It marks the
messages in that sequence with the FLAG bit. So with other commands that
take message sequences as arguments, the FLAGGED sequence will access
those messages.
/]
.HUNFL:	[ASCIZ/
The UNFLAG command takes a single argument, a message sequence and unflags
all the messages in that sequence.  Use the FLAG command to make messages
of importance "stand out" in your message file.  You can then access them
via the FLAGGED message sequence.
/]
.HRUNF:	[ASCIZ/
The UNFLAG command unflags the message currently being read.
/]
.FLAG:	SKIPA A,[FLGMSG]		;Flag messages
.UNFLA:	 MOVEI A,UFLMSG			;Unflag messages
	CALLRET DELET0

.HUNAN:	[ASCIZ/
The UNANSWER command takes a single argument, a message sequnce and then
removes the answered status from all the messages in that sequence.
/]
.HRUNA:	[ASCIZ/
The UNANSWER command removes the answered status from the message
currently being read.
/]
.UNANS:	MOVEI A,UANMSG			;Unanswer messages
	CALLRET DELET0

.HUNMA:	[ASCIZ/
The UNMARK command takes a single argument, a message sequnce and then
unmarks all the messages in that sequence, i.e. makes them appear unseen.
/]
.HUNDE:	[ASCIZ/
The UNDELETE command takes a single argument, a message sequence and then
undeletes all the messages in that sequence.
/]
.HRUND:	[ASCIZ/
The UNDELETE command undeletes the message currently being read.
/]
.UNMAR:	SKIPA A,[UMKMSG]
.UNDEL:	MOVEI A,UNDMSG
	CALLRET DELET0

.HBLAN:	[ASCIZ/
The BLANK command blanks the terminal screen if it is a display.
/]
.BLANK:	NOISE (SCREEN)
	CONFRM
BLANK1:	MOVEI A,.PRIOU			;Enter here for things that blank incidentally
VTS,<
	RTCHR
	TLNN B,(TC%CLR)			;Can it clear the screen?
	 RET				;No, skip it
	MOVEI B,.VTCLR
	VTSOP				;Do so
	RET
>;VTS
NOVTS,<
	RFMOD				;Change to
	PUSH P,B
	TRZ B,TT%DAM			;Binary mode
	SFMOD
	MOVE B,TTYPE
	CAIGE B,NCLRSC			;More than the number I support?
	 SKIPN A,CLRSCN(B)		;Get right magic
	  JRST BLANK2			;Hardcopy can't do this
	TLOE A,-1			;More than 5 chars?
	 HRROI A,CLRSCN(B)		;No, use immediate
	PSOUT
	MOVEI A,.PRIOU
	SETZ B,				;Tell monitor we are at top of page
	SFPOS
BLANK2:	MOVEI A,.PRIOU
	POP P,B
	SFMOD
	RET

;;;Display clearing codes

DEFINE ADMHAZEL <BYTE (7) 176,34,CTL(Z),0>;ADM+Hazeltine
DEFINE CLRASCII <BYTE (7) ESC,"H",ESC,"J",0>;Standard ASCII screen clear
DEFINE FORMFEED <BYTE (7) CTL(L),0>	;Traditional screen clear

CLRSCN:	0				;0 TTY33
	0				;1 TTY35
RAND,<
	FORMFEED			;2 Ann Arbor
>;RAND
NORAND,<
	0				;2 TTY37
>;NORAND
	0				;3 TI
CIT,<
	BYTE (7) ESC,"?",ESC,CTL(C),0	;4 Concept 100
	CLRASCII			;5 HP2640
>;CIT
CLSC,<
	FORMFEED			;4 Glass
	ADMHAZEL			;5 Televideo
	ADMHAZEL			;6 Hazeltine 1500
>;CLSC
DREA,<
	BYTE (7) CTL(Z),0		;4 ADM-3
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	[BYTE (7) ESC,133,"H",ESC,133,"J",0];6 VT100 in native mode
	BYTE (7) ESC,"?",ESC,CTL(C),0	;7 Concept 100
>;DREA
HP,<
	ADMHAZEL			;4 ADM-3
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	CLRASCII			;6 HP2640
	ADMHAZEL			;7 Hazeltine 1500
>;HP
ISI,<
	BYTE (7) ESC,"(",177,0		;4 LP Datamedia
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	CLRASCII			;6 HP2640
>;ISI
RAND,<
	0				;4 unused
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	CLRASCII			;6 Heath 19
	[BYTE (7) ESC,133,"H",ESC,133,"J",0];7 Ann Arbor Ambassador
>;RAND
RUTG,<
	BYTE (7) ESC,"+",CTL(L),CTL(Z),0;4 Video unspecified
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	[BYTE (7) ESC,"6","h",ESC,"2","J",ESC,"0","Q",0];6 I400
	FORMFEED			;7 Datamedia 1520
>;RUTG
SRI,<
	BYTE (7) CTL(Z),0		;4 ADM-3
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	CLRASCII			;6 HP2640
	0				;7 Terminet
>;SRI
STAN,<
	ADMHAZEL			;4 ADM-3
	BYTE (7) 035,CTL(^),0		;5 Datamedia 2500
	CLRASCII			;6 HP2640
	ADMHAZEL			;7 Hazeltine 1500
>;STAN
UTAH,<
	FORMFEED	    		;4 Glass teletype
	CLRASCII			;5 Fox
	BYTE (7) CTL(Z),0		;6 ADM-3A
	CLRASCII			;7 Teleray 1061
>;UTAH
	REPEAT <^D8>-<.-CLRSCN>,<0>	;4-7 Customer reserved codes
	0				;8 default
	0				;9 PTY, NVT (aka "ideal")
	BYTE (7) 035,CTL(_),CTL(_),CTL(_),0;10 VT05
	CLRASCII			;11 VT50
	0				;12 LA30
SRI,<
	BYTE (7) ESC,"(",177,0		;13 LP Datamedia
>;SRI
NOSRI,<
	BYTE (7) 035,CTL(_)		;13 GT40
>;NOSRI
	0				;14 LA36
	CLRASCII			;15 VT52
NOHP,<
	[BYTE (7) ESC,133,"H",ESC,133,"J",0];16 VT100
	0				;17 LA38
	0				;18 LA120
>;NOHP
COL,<
	REPEAT 4,<0>			;19-22 left unused
	FORMFEED			;23 Concept 100 (very old ones)
	CLRASCII			;24 Fox
	FORMFEED			;25 Datamedia 1520
	FORMFEED			;26 Glass
	CLRASCII			;27 Datamedia 3000
	CLRASCII			;28 HP 2621
	CLRASCII			;29 I100
	BYTE (7) ESC,"K",0		;30 Bantam
>;COL
HP,<
	0				;16 TTY43
	BYTE (7) CTL(V),0		;17 Tec
	BYTE (7) CTL(Y),0		;18 Gillotine
	CLRASCII			;19 Teleray 1061
	0				;20 GDP
	CLRASCII			;21 HP2621
>;HP
RUTG,<
	REPEAT 3,<0>			;19-21 left unused
	[BYTE (7) 176,34,177,177,177,177,0];22 Hazeltine Modular 1
	[BYTE (7) 176,34,177,177,177,177,0];23 Hazeltine 1500
	[BYTE (7) ESC,"v",ESC,"3",ESC,"j",ESC,"b",ESC,"\",ESC,"l",ESC,"G",0] ;24 Visual 200
	FORMFEED			;25 NIH 5200
	CLRASCII			;26 Heath 19
	BYTE (7) ESC,"?",ESC,CTL(C),0	;27 Concept 100
>;RUTG
SRI,<
	0				;19 TTY43
	BYTE (7) CTL(V),0		;20 Tec
	BYTE (7) CTL(Y),0		;21 Gillotine
	CLRASCII			;22 Teleray 1061
	[BYTE (7) 34,"E","R","A",";",0]	;23 Tektronix 4025
	FORMFEED			;24 Ann Arbor
	CLRASCII			;25 Heath 19
	0				;26 IMLAC
	FORMFEED			;27 Datamedia 1520
	CLRASCII			;28 Fox
	BYTE (7) ESC,"?",ESC,CTL(C),0	;29 Concept 100
>;SRI
STAN,<
	0				;19 TTY43
	BYTE (7) ESC,"+",0		;20 Soroc 120
	BYTE (7) CTL(Y),0		;21 Gillotine
	CLRASCII			;22 Teleray 1061
	[BYTE (7) 34,"E","R","A",";",0]	;23 Tektronix 4025
	FORMFEED			;24 Ann Arbor
	CLRASCII			;25 Heath 19
	BYTE (7) ESC,"?",ESC,CTL(C),0	;26 Concept 100
	BYTE (7) ESC,"K",0		;27 IBM 3101
>;STAN
NCLRSC==.-CLRSCN			;Maximum # of terminal types
>;NOVTS

.HEXIT:	[ASCIZ/
The EXIT command is used to erase any deleted messages in the current
message file and end a session with MM.
/]
.EXIT:	NOISE (AND UPDATE MESSAGE FILE)
	CONFRM
	SKIPLE MSGJFN			;If have a file,
	 CALL EXPUNG			;Expunge first
	CALLRET QUIT0			;And then quit

.HLOGO:	[ASCIZ/
The LOGOUT command will stop MM, expunge your message file, and log you
out from the system.
/]
.LOGOU:	NOISE (AND UPDATE MESSAGE FILE)
	CONFRM
	SKIPLE MSGJFN			;If have a file,
	 CALL EXPUNG			;Expunge first
	SETO A,				;Flush us
	LGOUT				;Do the kill
	 ERROR (Logout failed)		;Woops, bombed?
	JRST .-2

.HEXPU:	[ASCIZ/
The EXPUNGE command is used to erase deleted messages from the current
message file and write out a new copy of the file.
/]
.EXPUN:	NOISE (DELETED MESSAGES)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)

EXPUNG:	TRNN F,F%MOD!F%RONL		;Not on system mail you don't
	 CALL GETJF2			;Get write JFN so no one interferes
	  RET				;Failed, or system mail
	SETZB L,M			;Zero start, offset with first msg
	SETZ X,				;Init count of bytes saved

EXPN00:	MOVEI A,M%DELE			;Deleted bit
	TDNN A,MSGBTS(M)		;Is it deleted?
	 JRST EXPN20			;No, must save it
	JUMPN L,EXPN10			;The first deleted msg we have seen?
	MOVSI A,(EN%BLN)		;Exclusive use, no level numbers
	HRR A,MSGJFN			;File's JFN
	MOVEM A,ENQBLK+.ENQLV
	DMOVE A,[.ENQMA			;Change our lock to be exclusive
		 ENQBLK]
	ENQ
	 ERJMP [WARN (Can't do expunge - another process has the file open)
		CALLRET CLSJF2]		;Get rid of the JFN we made
	MOVE V,X
	CALL CHR2BP			;Yes, byte pointer to last saved byte
	MOVE O,A			;Init pointer to output area
	MOVEI A,MSGPAG*1000		;And make messages private
	HRRZ B,FILPGS
EXPN01:	MOVES (A)
	SOJLE B,EXPN10
	ADDI A,1000
	JRST EXPN01
EXPN10:	SUB L,MSGSAL(M)			;Increment count of byte offset
	JRST EXPN30			;And go process next msg

EXPN20:	MOVE C,MSGSAL(M)		;Get length of this message
	ADD X,C				;Keep track of total
	JUMPE L,EXPN30			;If no bytes deleted yet, no moving
	MOVE V,MSGALL(M)		;Get starting byte of message
	CALL CHR2BP			;Get byte pointer in a to old msg
	CALL FSCOPY			;Do a fast string copy
	ADDM L,MSGALL(M)		;Update position in file of start

EXPN30:	CAMGE M,LASTM			;At the last msg?
	 JRST [	ADDI M,MSGLEN
		JRST EXPN00]		;No, do next then
	JUMPE L,EXPN33			;No msgs deleted, nothing more to do
	JUMPE X,EXPN34			;No msgs retained, delete the file
	CITYPE < Expunging deleted messages
>
	MOVE B,X			;See how many pages touched
	IDIVI B,5000
	JUMPE C,.+2
	 ADDI B,1
	PUSH P,B			;Save new count for later
	HRRZ C,FILPGS			;Number we had mapped to start
	SUBI C,(B)			;Less number touched
	JUMPE C,EXPN31			;All pages touched
	SETO A,
	ADD B,[.FHSLF,,MSGPAG]
	HRLI C,(PM%CNT)
	PMAP				;Unmap those not touched
	HRLZ B,MSGJF2			;Write msg file JFN
	HRR B,(P)			;Number of pages touched
	PMAP				;Make pages in the file go away
	 ERJMP [JFATAL <Can't unmap file pages, probably another user has file open>]

EXPN31:	HRRZ A,MSGJF2			;Write msg file JFN
	HRROI B,MSGPAG*1000		;Write out new pages
	MOVN C,X
	SOUT
	POP P,C				;Get back count of pages touched
	HRRM C,FILPGS			;Update count of pages really in file
	MOVEM X,FILSIZ
	HRLI A,.FBSIZ
	SETO B,
	MOVE C,X			;Update byte count
	CHFDB
	LDB B,[POINT 6,FILPGS,11]	;Get byte size
	CAIN B,7			;If not 7,
	 JRST EXPN32
	HRLI A,.FBBYV			;Make it be
	MOVSI B,(FB%BSZ)
	MOVSI C,(7B11)
	CHFDB
	ANDCAM B,FILPGS
	IORM C,FILPGS
EXPN32:	CALL CLSJF2			;Get rid of write JFN
	MOVSI A,(EN%BLN!EN%SHR)		;No level number, shared access
	HRR A,MSGJFN
	MOVEM A,ENQBLK+.ENQLV		;Change the access back to shared
	DMOVE A,[.ENQMA
		 ENQBLK]
	ENQ
	 ERJMP .+1			;Don't care
	SETZB X,M			;Update message numbers
	SKIPA B,[M%DELE]
EXPN41:	 ADDI M,MSGLEN
	TDNN B,MSGBTS(M)		;Deleted?
	 JRST EXPN43			;No, save numbers then
EXPN42:	CAMGE M,LASTM			;Done?
	 JRST EXPN41
	SUBI X,MSGLEN
	MOVEM X,LASTM			;Yes, update new count
	MOVEI M,(X)			;And go there
	RET				;And done

EXPN43:	CAIN X,(M)			;Still none deleted?
	 JRST EXPN44
	MOVSI A,MSGALL(M)		;Having to move, update header pointers
	HRRI A,MSGALL(X)
	BLT A,MSGALL+MSGLEN-1(X)
EXPN44:	ADDI X,MSGLEN
	JRST EXPN42

EXPN33:	CITYPE < No messages deleted, so no update needed.
>
	CALLRET CLSJF2

EXPN34:	CITYPE < All messages deleted, deleting file.
>
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	SKIPLE A,MSGJFN			;Make damn sure this JFN is out of
	 CLOSF				; the way, so the DELF doesn't get a
	  NOP				; DELFX2 loser
	SETOM MSGJFN
	CALL CLSJF2
	SETZM FILSIZ
	HRRZ A,MSGJF2
	TLO A,(DF%EXP)
	DELF
	 JWARN
	HRRZ A,MSGJF2
	RLJFN
	 NOP
	SETOM MSGJF2
	RET

.HANSW:	.+1				;MACRO chokes on this as a literal
	ASCIZ/
The ANSWER command takes 1 argument, a message sequence you would like to
answer. So, to reply to message 3 you would say >ANSWER 3 where 3 is the
message number. Or you could answer any other message sequence. After
typing >ANSWER 3 and then carriage return it asks you "Reply msg #3 to:"
and awaits one of "ALL" or "SENDER". If you respond with ALL, then your
answer will go to everyone in the header of the message: the person who
sent it to you and everyone else.  If you respond with SENDER, then your
answer will only go to the sender of the message.
/
.ANSWE:	CALL DFSQTH			;Get in sequences, def to current
	MOVEI A,ANSRET			;Return here on error
	HRRM A,CMDRET
ANSWE0:	CALL NXTMSG			;Get next message
	 JRST .AQUIT			;Unless all done
	CALL CHKDEL			;Deleted?
	 JRST ANSWE0			;Yes, forget it
	MOVE A,[POINT 7,STRBUF+40]
	MOVEI B,[ASCIZ/ Reply msg # /]
	CALL MOVSTR
	MOVEI B,MSGLEN(M)
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 JCERR
	MOVEI B,[ASCIZ/ To: /]
	CALL MOVST0
	UPRMT STRBUF+40			;Prompt for all/sender
	MOVEM L,SAVL
	SETOM CLEVEL			;Don't let ^U go to top level
	MOVEI A,REPLY0			;Set reparse address
	HRRM A,CMDBLK+.CMFLG
	CALL REPLY0			;Reply to it
ANSRET:	MOVE L,SAVL
	CALLRET ANSWE0			;How about another?

.AQUIT:	MOVEI A,CMDRES			;Reset the error handler
	HRRM A,CMDRET
	JRST CMDRES			;And back to snarf a command

;;;Count messages
.HCOUN:	[ASCIZ/
The COUNT command takes a message sequence, and prints out the number
of messages in that sequence.
/]
.COUNT:	CALL DFSQAL			;Get sequence, default is all
	SETZM NRECNTT			;Place to store count
	MOVEI A,CNTMSG
	MOVEM A,DOMSG
	CALL DELET1			;Map over them, printing and counting
	SKIPN A,NRECNT			;Get the total count
	 JRST [	CITYPE (No messages.)
		RET]
	ETYPE ( = %1D message%1P.)
	RET

CNTMSG:	AOS NRECNT
	RET

;;;Append messages together

.HAPPE:	[ASCIZ/
The APPEND command takes a message sequence, and appends those messages
together into one message.
/]
.APPEN:	SKIPG MSGJFN			;Must have a file
	 ERROR (No current file)
	CALL GETSEQ			;Get a bunch of messages no default
	TLO F,(F%TYPS)			;Type out numbers of messages
	CALL NXTMSG			;Get first sequence?
	 RET				;Nothing to append
	PUSH P,[POINT 7,TXTPAG]		;Lots of string space
	PUSH P,[0]
APPEN1:	CALL DELMSG			;Delete it
	HRRZ V,MSGBOD(M)
	CALL MCH2BP			;Get byte pointer to message
	HLRZ C,MSGBOD(M)		;And length
	ADDM C,(P)			;Update total length
	MOVE O,-1(P)
	CALL FSCOPY			;Copy in the message
	MOVEM O,-1(P)
	CALL NXTMSG			;Get next message
	 CAIA				;All done
	  JRST APPEN1			;For the whole sequence
	CALL UNDMSG			;Undelete the last one of them
	MOVE A,[POINT 7,TXTPAG]
	POP P,C				;Get total length
	CALL RPLMSG			;Go replace that message
	UETYPE [ASCIZ/ => %M/]
	JRST CPOP1J

.HREAD:	[ASCIZ/
The READ command takes one argument, a message sequence and starts reading
the messages in that sequence in special read-mode.
/]
.RSREA:	CALL RSCFIL			;Get file for rscan command handling
.READ:	CALL DFSQNW			;Get sequence, default to unseen
	TRO F,F%READ			;Say in read command
	MOVEI A,REDRET			;Return here
	HRRM A,CMDRET			;On error
READ0:	CALL NXTMSG			;Get next message
	 JRST RQUIT0			;None, all done
READ1:	CALL CHKDEL			;Don't if deleted msg
	 JRST REDRET
	SKIPE BLSCST			;Unless user doesnt want it
	 CALL BLANK1			;Clear the screen perhaps
	CALL TYPMSG			;And type the message out
	SKIPGE RINCME			;Special include me mode?
	 SETZM SAVFIL			;Yes, reset default moved to

REDRET:	MOVE P,[IOWD NPDL,PDL]		;Reset stack
REDCLP:	MOVE A,[REPRMT,,RCMDTB]		;Read command
	CALL CMDINI
	DEFALT (NEXT)			;CR moves on to next message
	CALL GETCMD
	CALL (A)
	JRST REDCLP			;Keep going

.RNEXT:	CONFRM
	CALL UPDBT0			;Update message
 	CALLRET READ0

.RQUIT:	CONFRM
RQUIT0:	CALL UPDBT0			;Update this message
	TRZ F,F%READ
	SETZM RPVSAV
	MOVEI A,CMDRES
	HRRM A,CMDRET
	JRST CMDRES			;And return to top level

;;; Read mode previous command, note this is clever about saving state so
;;; that backing up in the middle of a read undeleted where you delete some
;;; messages will cycle through the same messages no matter what the path.
.RPREV:	CONFRM
	CAMN L,[POINT 12,MSGSEQ,11]
	 ERROR (Already at start of sequence)
	CALL UPDBT0			;Update file
	MOVE A,NXTMSD			;Get next mesage dispatch
	CAIN A,NXTSEQ			;Numeric sequences are easy
	 JRST RPREV1
	HRLM A,RPVSAV			;Save old one
	HRRM M,RPVSAV
	MOVEI A,NXTSEQ
	MOVEM A,NXTMSD
RPREV1:	IDIVI M,MSGLEN			;For ease of computation
	SETO B,				;Do this also in case not normalized
	ADJBP B,L
	LDB A,L				;Get current entry in list
	LDB C,B				;Get start of range or previous entry
	TRZN A,2000			;Is this a range type?
	 JRST RPREV3			;No, just number, take the previous
	CAIG A,(C)			;Start before end?
	 AOJA M,RPREV2
	CAIL A,(C)
	 SUBI M,1			;Else decrement
RPREV2:	CAIN M,(C)			;This puts us at the start?
RPREV3:	 DMOVE L,B			;Point to this new spot
	TRZ M,2000
	IMULI M,MSGLEN			;Back to right unit
	CALLRET READ1			;Pretend user got there to other way

.HSSEN:	[ASCIZ/
The SEND command sends the message.  Also, if you simply type carriage
return in send mode, it will attempt to send out the message.
/]
.HSEND:	[ASCIZ/
The SEND command starts sending a message. It prompts for the addresses,
subjects and text of the message.  To send the message, type ^Z after
finishing typing the text in. Then confirm with a carriage return or use
the command in send-mode to modify and edit the message before sending it.
/]
.HCONT:	[ASCIZ/
The CONTINUE command resumes a SEND which was interrupted or QUITed out of.
/]

;;;Sending subcommands

.CONTI:	NOISE (SENDING MESSAGE)
	CONFRM
	SKIPL SNDCAL
	 ERROR (There is no sending to continue)
	SETZM LSTCHR			;Don't accidentally send it off
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	CALLRET SEND0			;Enter send mode

.SEND:	NOISE (MESSAGE TO)
	CALL SNDINI
	CALL GETTO0			;Get to: without prompting
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVEI A,SNDRET			;Enter SEND level here so error on ^E
	HRRM A,CMDRET			; leaves us at SEND level
	SKIPE TOLIST
	 JRST [	CALL GETMS1		;Get message without cc or to
		JRST SEND0]		;And fall in to rest
	TRZ F,F%HOER			;User wants hand-holding, no more halt
	CALL SNDINI			;Reset fields
	CALL GETMSG			;Prompt for message
SEND0:	CALL CLRABO			;Don't allow ^N any more
	MOVE A,LSTCHR			;Get last character
	SKIPG ESCSND			;Escape sends automatically?
	 JRST SEND01			;No
	CAIN A,ESC			;Yes, wants that?
	 JRST SSEND1			;Yes, just send if off then
	JRST SEND1			;Else go get some commands

SEND01:	CAIE A,CTL(Z)
	 JRST SEND1
	SKIPL ESCSND			;^Z sends automatically?
	 TRNE F,F%RSCN			;Or called in command line?
	  JRST SSEND1			;Yes, do so
SEND1:	MOVEI A,SNDRET			;Enter SEND level
	HRRM A,CMDRET
	TRO F,F%SEND
SNDRET:	MOVE P,[IOWD NPDL,PDL]		;Reset stack
SNDLUP:	TRZE F,F%ESND			;Editor said to send it?
	 JRST SSEND1			;Yes, do that right away
	MOVE A,[SEPRMT,,SCMDTB]
	CALL CMDINI
	SKIPE CRSEND			;Does bare CR send message?
	 DEFALT (SEND)
	CALL GETCMD
	CALL (A)
	JRST SNDLUP

.SSEND:	CONFRM
SSEND1:	CALL SNDMSG			;Send it off
	HRRZS SNDCAL			;Don't let user continue this one
	MOVEI A,M%RPLY			;Mark replying to this message
	TRZE F,F%RPLY			;Was this a reply we just sent?
	 IORM A,MSGBTS(M)		;Yes, mark message as answered
	CALLRET SQUI1

.HSQUI:	[ASCIZ/
The QUIT command gets out of this mode and returns back to the top level
prompt.
/]
.SQUIT:	CONFRM
SQUI1:	TRZ F,F%SEND			;Not in send command any more
	HRRZ A,SNDCAL			;Get where we entered from
	HRRM A,CMDRET			;Set up to go back there
	TRNE F,F%DIRE			;From dired mode?
	 JRST DIREDR			;Yes, resume that then
	JRST (A)			;And do

.HREDI:	[ASCIZ/
The EDIT command edits the message currently being read.
/]
.HSEDI:	[ASCIZ/
The EDIT command takes one of the following arguments:

	HEADERS	-- edit the headers of the message
	TEXT	-- edit the text of the message

(If you simply type EDIT followed by a carriage return it defaults to
TEXT.)
/]
.SEDIT:	DEFALT (TEXT)
	MOVEI A,EDCMTB
	CALLRET .ERAS2			;Get field to edit

.HSERA:	[ASCIZ/
The ERASE command takes one of the following arguments:

	All	   -- erase the entire message
	Bcc	   -- erase the blind carbon-copies address list
	Cc	   -- erase the carbon-copies address list
	Reply-date -- erase the reply date
	Subject	   -- erase the subject
	Text	   -- erase the text
	To	   -- erase the to address list
/]
.ERASE:	NOISE (MESSAGE FIELD)
	DEFALT (TEXT)
	MOVEI A,ECMDTB
.ERAS2:	CALL SUBCMD
	PUSH P,A
	CONFRM
	POP P,A
	CALL (A)
	JRST @CMDRET

.HSDIS:	[ASCIZ/
The DISPLAY command takes one of the following arguments:

	ALL 	-- shows the entire message
	BCC 	-- shows only the blind-carbon copy addresses
	CC  	-- shows only the carbon copy addresses
	SUBJECT -- shows only the subject
	TEXT	-- shows only the text
	TO	-- shows only the to recipients

(If you simply type DISPLAY followed by a carriage return it displays the
entire message.)
/]
.DISPL:	NOISE (MESSAGE FIELD)
	DEFALT (ALL)
	MOVEI A,DCMDTB
	CALLRET .ERAS2

.HRREP:	[ASCIZ/
The REPLY command replies to the message currently being read.
/]
.REPLY:	NOISE (TO)
REPLY0:	MOVEI A,[ASCIZ/ALL/]
	SKIPE RFMDEF
	 MOVEI A,[ASCIZ/SENDER/]
	UDEF (A)			;Setup right default
	MOVEI A,RPCMTB
	CALLRET .ERAS2

.REPAL:	TLOA F,(F%F3)			;Say reply to everyone
.REPFM:	 TLZ F,(F%F3)			;Say just reply to sender
.REPL6:	CALL SNDIN0			;Erase drafts
	TRO F,F%RPLY			;In reply mode
	CALL FNDSDT			;Find send date
	MOVEM B,REPDAT			;Set up as reply date
	CALL REPSUB			;Construct the subject
	MOVEI T,[ASCIZ/
Reply-To: /]				;Look for overiding header
	CALL FNDHDR
	 JRST .REPL5			;Not found, use from then
	SETZ E,				;No host name defaulting
	TLZ F,(F%CC!F%AT!F%F4)
	CALL PRADDT			;Get the guy and add him in
	TROA F,F%RPTO			;Flag that we processed a Reply-To
.REPL5:	 TRZ F,F%RPTO			;Didn't do a Reply-To
	HRRZ V,MSGFRM(M)		;Handle From so we use its flags
	JUMPE V,.REPL2			;Don't know who it's from
	CALL MCH2BP
	SETZ E,				;No host name defaulting
	TRNE F,F%RPTO			;Doing Reply-To?
	 TLOA F,(F%F4)			;Yes, don't type any error message
	  TLZ F,(F%CC!F%AT!F%F4)	;Otherwise do the normal thing
	CALL PRADDR			;Process the address
	TRZN F,F%RPTO			;Did we see a Reply-To just now?
	 CALL ADDTO			;No, add the address then
.REPL0:	TLZN F,(F%F3)			;Wants reply to all addresses?
	 JRST .REPL1			;No, have enough now
	MOVEI T,[ASCIZ/
To: /]					;Find start of addresses
	CALL FNDHDR
	 JRST .REPL1			;Not there, forget it
	CALL PRTOCC			;Get to and cc lists
	MOVEI U,TOPAG+4			;First recipient's name
	MOVEI N,1			;Allow only one occurance
	CALL DOUNTO
	MOVEI U,MYDIRS			;Remove me from the list
	SETZ N,				;Allow 0 occurances
	CALL DOUNTO
.REPL1:	SKIPN RINCME			;Include me in replies?
	 JRST .REPL3			;No, forget it
	HRROI B,MYDIRS			;Me
	MOVE U,FREETO			;Get some free space
	PUSH P,B
	MOVEI A,4(U)
	HRLI A,(<POINT 7,0>)
	CALL MOVST0
	MOVEI A,1(A)			;Point to next free word
	MOVEI W,(A)			;Get new end of area
	SUBI A,(U)			;Get length
	HRLZM A,(U)			;Store size field
	SETZM 1(U)
	POP P,B
	MOVSI A,(RC%EMO)		;Require an exact match
	RCUSR
	MOVEM C,2(U)
	SETZM 3(U)
	MOVEI T,CCLIST			;Add a cc from this string
	CALL ADDTO0
	SKIPL RINCME			;Want special cc to self?
	 JRST .REPL3
	HLRZ B,CCLIST
	SETOM 2(B)			;Flag special user number for this file
.REPL3:	CALL PRSCCL			;Parse default bcc list here
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVEI A,SNDRET			;Enter SEND level now just in case
	HRRM A,CMDRET
	TRNE F,F%DIRE			;From dired mode?
	 JRST [	CALL EDTXT0		;Yes, go into edit right away
		CALLRET SEND0]
	SKIPE REPDIS			;Display reply at startup?
	 CALL .DSREP			;Yes, do so
.REPL7:	CALL GETTXT			;Get text of reply
	CALLRET SEND0			;And go get more or send it off
.REPL2:	CITYPE (Can't tell who message is from)
	CALL GETTO			;Ask him who it's to then...
	JRST .REPL0

;;;Add user headers
.HUSER:	[ASCIZ/
The USER-HEADER command takes two arguments; a header keyword as
defined in the USER-HEADERS line in the MM.INIT file, and a header
text line, and inserts the line with that name in the message
header.
/]

.USHDR:	SKIPN USRHTB			;Any user headers defined?
	 ERROR (No defined user headers)
	MOVEI B,[FLDDB. .CMKEY,,USRHTB]
	CALL CMDFLD			;Get a keyword
	HLRZ U,(B)			;Save address of string
	CALL GETLIN
	CALL USHDRL			;New header line
	MOVEI B,(U)			;Address of string
	CALL USHDR1
	MOVEI B,[ASCIZ/: /]
	CALL USHDR1
	MOVEI B,STRBUF			;And finally user's line
	CALL USHDR1
	DMOVEM D,USRHDR+2
	IDPB C,D			;End with a null
	RET

USHDRL:	DMOVE D,USRHDR+2		;Get pointers so far
	JUMPE D,[DMOVE D,[POINT 7,USRHDR+4
			  1-776*5]
		 RET]			;First time out, init pointer
	MOVEI B,CRLF0			;Else put in newline first
USHDR1:	HRLI B,(<POINT 7,0>)		;Copy a string and update count
USHDR2:	ILDB C,B
	JUMPE C,CPOPJ
	IDPB C,D
	AOJL E,USHDR2
USHDRE:	ERROR (String space exhausted)

;;;Save current message draft in a file
.HSAVE:	[ASCIZ/
The SAVE-DRAFT takes one argument, a file name, and saves the message
currently being composed into that file to be retrieved later using the
RESTORE-DRAFT command.
/]

.SSAVE:	CALL GETOFI			;Get output file with no default
	CONFRM
	MOVE O,[POINT 7,HDRPAG]
	SKIPN A,USRHDR			;Has any user headers?
	 JRST SSAVE1			;No, none
	ILDB A,A			;Just header options?
	JUMPE A,SSAVE1			;Yes, go on to other header items
	MOVE A,[IDPB A,O]
	MOVEM A,MOVDSP			;Set up to move into memory
	MOVE B,USRHDR			;Pointer to start of user headers
	CALL MOVSB3			;Go add that in
SSAVE1:	TLZ F,(F%AT)			;Don't put in host names
	CALL SETHD7			;Output headers
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Cannot open file)
	MOVE B,[POINT 7,HDRPAG,13]
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;And put in text
	SOUT
CLOSFR:	CLOSF
	 NOP
	RET

;;;Restore saved message draft
.HREST:	[ASCIZ/
The RESTORE-DRAFT command takes a single argument, a file name created
by the SAVE-DRAFT command, and restores the state of the send from that
draft.
/]

.RESTO:	CALL .SREST			;Load it up
	SKIPGE RSTMOD			;/SEND?
	 JRST SNDMSG			;Yes, just send it
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVEI A,SNDRET			;Enter SEND level now just in case
	HRRM A,CMDRET
	SKIPE RSTMOD			;/COMMAND?
	 JRST SEND0			;Yes, go to command mode right away
	CALL .DSRST			;Display what we brought back
	SKIPN TXTPAG			;Is there text to the message?
	 JRST .REPL7			;No, prompt for it and so on
	CALL SETABO
	UTYPE [BYTE (7) 15,12,15,12,0]
	CALL .TEXT2			;No, typeout and get some more text
	CALLRET SEND0			;And enter send more

.SREST:	NOISE (FROM FILE)
	MOVEI B,[FLDDB. .CMIFI]
	CALL CMDFLD			;Get the file
	MOVEM B,TMPJFN
	SETZM RSTMOD
	MOVEI B,[FLDDB. .CMCFM,,,,,<[
		 FLDDB. .CMSWI,,<[3,,3
				  [ASCIZ/COMMAND/],,1
				  [ASCIZ/SEND/],,-1
				  [ASCIZ/TEXT/],,0]>]>]
	CALL CMDFLD
	LDB D,[POINT 9,(C),8]
	CAIN D,.CMCFM			;Confirm?
	 JRST RESTO0			;Yes
	HRRE B,(B)
	MOVEM B,RSTMOD
	CONFRM
RESTO0:	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JERROR (Cannot open input file)
	CALL SNDINI			;Erase everything so far
	MOVE A,TMPJFN
	MOVEI C,5000
	MOVEI D,12			;Read a line at a time
	MOVE B,[POINT 7,HDRPAG]		;Read the headers in
RESTO1:	MOVE E,B			;Save the start of this line
	SIN
	ILDB T,E			;Get character at start of line
	CAIE T,15			;Blank line?
	 CAIN T,12
	  TDZA T,T
	JUMPN T,RESTO1
	DPB T,E				;Make it end with a null anyway
	SKIPA E,[POINT 7,HDRPAG]
RSTLUP:	 SKIPA E,B
RESTO2:	MOVE B,E			;Get copy of pointer
	MOVE C,[POINT 7,STRBUF]
	SETZM STRBUF
	SETZM STRBUF+1
RESTO3:	ILDB T,B
	JUMPE T,RSTTXT			;Done with headers
	CAIE T,15			;End of line before : is an error
	 CAIN T,12
	  JRST [MOVEI A,STRBUF
		ERROR (%1S does not look like a header line)]
	CAIL T,"a"
	 CAILE T,"z"
	  CAIA
	   SUBI T,"a"-"A"		;Make uppercase
	IDPB T,C
	CAIE T,":"			;End of the name of it?
	 JRST RESTO3
	DMOVE C,STRBUF
	CAME C,[ASCIZ/TO:/]
	 CAMN C,[ASCIZ/CC:/]
	  JRST RSTTO			;Parse a to or cc list
	CAMN C,[ASCII /SUBJE/]
	 CAME D,[ASCIZ/CT:/]
	  JRST RSTRND			;Random line, insert as user option
RSTSB1:	ILDB T,B			;Flush whitespace
	CAIE T," "
	 CAIN T,11
	  JRST RSTSB1
	SKIPA C,[POINT 7,HDRPAG+700]	;Where the subject goes
RSTSB2:	 ILDB T,B
	CAIE T,15
	 CAIN T,12
	  JRST RSTSB3
	JUMPE T,RSTSB3
	IDPB T,C
	JRST RSTSB2
RSTSB3:	CAIN T,15
	 IBP B				;Move over LF after CR
	MOVEI D,0
	IDPB D,C
	JUMPN T,RSTLUP

RSTTXT:	MOVE A,TMPJFN
RSTTX0:	BIN
	JUMPE B,CLOSFR			;Eof, no text then
	CAIE B,15
	 CAIN B,12
	  JRST RSTTX0			;Flush CRLFs
	BKJFN
	 NOP
	CALLRET INSFL3			;And now insert the file as text

RSTRND:	PUSH P,E			;Save current line
	CALL USHDRL			;New header line
	POP P,B				;Get line again
RSTRN1:	ILDB T,B
	CAIE T,15
	 CAIN T,12
	  JRST RSTRN2
	JUMPE T,RSTRN2
	AOJGE E,USHDRE
	IDPB T,D
	JRST RSTRN1
RSTRN2:	DMOVEM D,USRHDR+2		;Update pointers
	JRST RSTSB3

RSTTO:	MOVE A,E			;Get start of line again
	PUSH P,RCCOTH			;Don't change type of message
	SETZM RCCOTH
	TLZ F,(F%AT)			;Prevent PRTOCC from being confused
	CALL PRTOCC			;Parse to and cc lines
	POP P,RCCOTH
	MOVE E,A
RSTTO1:	LDB B,E				;Now back up to start of line that didn't match
	CAIE B,15
	 CAIN B,12
	  JRST RESTO2
	JUMPE B,RSTTXT
	ADD E,[7B5]
	SKIPGE E
	 SUB E,[43B5+1]
	JRST RSTTO1

.HRCOP:	[ASCIZ/
The COPY command takes one argument, a filename, and copies the message
currently being read into that file.
/]
.HCOPY:	[ASCIZ/
The COPY command takes two arguments.  The first is a filename and the
second is a message sequence.  It copies the specified message sequence
into the given file leaving it intact in the current file.
/]
.HRMOV:	[ASCIZ/
The MOVE command takes one argument, a filename.  It moves the message
currently being read into that file and deletes the message.
/]
.HMOVE:	[ASCIZ/
The MOVE command takes two arguments.  The first is a filename and the
second is a message sequence.  It moves the specified message sequence into
the given file and deletes the sequence from the current file.
/]

;;;Move messages into files

.COPY:	SKIPA A,[PUTMSG]
.MOVE:	 MOVEI A,MOVMSG
	MOVEM A,DOMSG
	TRNE F,F%READ			;In read command?
	 JRST .RCOP1			;Yes
	CALL GETOUT			;Get output file
	CALL DFSQTH			;Get message sequence
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		SETZM OUTJFN
		JSNARL			;Give error message
		RET]
.COPY1:	CALL DELET1			;Go handle the sequence
.COPY2:	SKIPL RINCME			;Special include me mode?
	 JRST .COPY3			;No
	HRROI A,SAVFIL			;Yes, update name of last moved file
	MOVE B,OUTJFN
	SETZ C,
	JFNS
.COPY3:	MOVE A,OUTJFN
	CLOSF
	 JERROR (Can't close output file)
	SETOM OUTJFN
	RET

.RCOP1:	CALL GETOUT			;Get output file
	CONFRM
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		SETZM OUTJFN
		JSNARL			;Give error message
		RET]
.RCOP2:	CALL @DOMSG			;Process it
	CALLRET .COPY2			;And go close it up

.HRLIS:	[ASCIZ/
The LIST command prints the message currently being read on device LPT:
(usually the lineprinter).
/]
.HLIST:	[ASCIZ/
The LIST command takes one argument, a message sequence. It lists the
sequence on device LPT:, (usually the lineprinter).
/]
.HFILE:	[ASCIZ/
The FILE-LIST command is like LIST, except that it will ask you which file
you would like to LIST to.  After the file argument, it takes a message
sequence.
/]

.FLIST:	CALL GETOFI
	CAIA
.LIST:	 SETZM OUTJFN			;Forget any old output file
	MOVEI A,LPTMSG
	MOVEM A,DOMSG
	TRNE F,F%READ
	 JRST .RLIS1
	CALL DFSQTH			;Get sequence
	CALL GETLPT			;Get LPT: file
	 RET				;He didn't really mean it
	SKIPE LSTHDR			;Include headers in the list?
	 CALL .LISHD			;Yes, list them now
	CALLRET .COPY1

.LISHD:	CALL NXTMSG			;Else cycle through messages once
	 JRST .LIST2
	MOVEI A,M%DELE
	TDNE A,MSGBTS(M)		;Deleted?
	 JRST .LISHD			;Yes, skip it but don't complain this pass
	MOVE O,[POINT 7,WRTPGS]
	CALL TYPHD0
	MOVE A,OUTJFN
	HRROI B,WRTPGS
	SETZ C,
	SOUT
	JRST .LISHD

.LIST2:	MOVE A,OUTJFN			;All done, put this on one page
	HRROI B,[ASCIZ/
/]
	SETZ C,
	SOUT
	MOVEI B,CTL(L)			;Form feed
	BOUT
	HRROI B,[ASCIZ/
/]
	SOUT
	CALLRET GTSQNS			;And output messages from saved seq

.RLIS1:	NOISE (ON LINE-PRINTER)
	CONFRM
	CALL GETLP0
	 RET
	CALLRET .RCOP2

.HRFOR:	[ASCIZ/
The FORWARD command takes one argument, the list of addresses to
forward to.  It forwards the message currently being read to that
list.  If the argument is not specified, it is prompted for with
To: when you try to send the message.
/]
.HFORW:	[ASCIZ/
The FORWARD command takes one argument, a message sequence.  It forwards the
messages in the sequence to an address which you specify after typing
carriage return.
/]

.RFORW:	NOISE (MESSAGE TO)
	CALL SNDINI
	CALL GETTO0			;Get To: without prompting
	JRST .FORW0			;Join common code

.FORWA:	CALL DFSQTH			;Get message sequence, default to this
	CALL SNDINI			;Reset message drafts
	CALL GETTO			;Get recipients
.FORW0:	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVEI A,FWDRET			;Make sure we continue in case error
	HRRM A,CMDRET
	CALL GETTXT			;Get initial comments
FWDRET:	SETZ A,				;Get canonical pointer to text field
	ADJBP A,TXTPTR
	CAMN A,[POINT 7,TXTPAG-1,34]	;Empty?
	 JRST .FORW1			;Yes, no initial dashes then
	LDB C,A				;Get last char
	MOVEI B,CRLF0
	CAIE C,12			;Unless have crlf
	 CALL MOVSTR			;Put one in
	MOVEI B,[ASCIZ/                ---------------
/]
	CALL MOVSTR
	MOVEM A,TXTPTR			;Update pointer
.FORW1:	TRNN F,F%READ			;If not in read
	 JRST .FORW2			;Handle list
	CALL FORMSG			;Forward current message
	JRST .FORW3			;Finish it up and return

.FORW2:	CALL NXTMSG			;Get next guy in list
	 JRST .FORW3
	CALL CHKDEL			;Don't forward deleted msgs
	 JRST .FORW2
	CALL FORMSG			;Forward this one too
	JRST .FORW2

.FORW3:	MOVE A,TXTPTR
	MOVEI B,[ASCIZ/                ---------------
/]
	CALL MOVST0
	ADD A,[7B5]			;Back over the null
	MOVEM A,TXTPTR
	CALLRET SEND0			;Maybe send it off or get more

;;;Remail a message to someone
.HREMA:	[ASCIZ/
The REMAIL command is similar to FORWARD, except instead of inserting
the message after typein, the message is sent as is with the header
modified to indicate who did the remailing.
/]
.RREMA:	NOISE (MESSAGE TO)
	CALL SNDINI
	CALL GETTO0			;Get To: without prompting
	JRST .REMA0			;Join common code

.REMAI:	CALL DFSQTH			;Get a sequence and default it
	CALL SNDINI			;Erase the message draft
	CALL GETTO			;Get the to: list
.REMA0:	TRNE F,F%READ			;In read mode?
	 JRST RMLMSG			;Yes, process it and return
	MOVEI A,RMLMSG
	CALLRET DOMSGS			;Handle list of messages

.HSYST:	[ASCIZ/
The SYSTEM-MSGS command will read in the system messages file
SYSTEM:MAIL.TXT.
/]
.MSGOD:	CONFRM
MSGOD1:	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ/SYSTEM:MAIL.TXT.1/]
	GTJFN
	 ERROR (No system message file)
MSGOD2:	PUSH P,A			;Save JFN
	TRO F,F%MOD!F%RONL		;Flag for doing system mail
	TLZ F,(F%F1)			;Not the examine command
	CALLRET GETF1

.HBBOA:	[ASCIZ/
The BBOARD command will read in the bulletin board file <BBOARD>MAIL.TXT.
/]
.MSBBD:	CONFRM
MSBBD1:	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ/PS:<BBOARD>MAIL.TXT.1/]
	GTJFN
	 ERROR (No BBOARD message file)
	CALLRET MSGOD2

MSGOD0:	CALL MSGOD1			;Setup for system mail
	MOVEI A,NXTNEW			;Setup sequencer
	MOVEM A,NXTMSD
	MOVNI M,MSGLEN
	MOVEI A,TYPE1			;Msg processing routine
	CALL DOMSGS			;Go do messages
	PUSH P,[GO]			;In case of continue
	CALLRET QUIT0			;And exit

.HWHEN:	[ASCIZ/
This command tells you the current date and time.
/]
.DAYTI:	CONFRM
	MOVEI A,.PRIOU
	SETOB B,C
	ODTIM				;Give us ye old daytime
	RET

.HALIA:	[ASCIZ/
The ALIAS command takes a single argument, a user name.  It then causes
MM to behave as if you were that user; all mail sent will be "from" that
user (your login name will be the "sender"), and MM will be reading the
aliased user's mail file.
/]

.ALIAS:	MOVEI B,[FLDDB. .CMUSR]
	CALL CMDFLD
	MOVEM B,(P)
	CONFRM
	TRZN F,F%ALIA			;Already accessing a directory?
	 JRST .ALI.1			;Nope, so don't END-ACCESS
	MOVSI A,(AC%REM)		;Remove access of what's in blk
	HRRI A,3			;Length of argument block
	MOVEI B,ACCBLK
	ACCES
	 ERJMP .+1
.ALI.1:	SETZ A,				;No flags
	MOVE B,(P)			;Pick up required user to access
	RCDIR				;Convert to user number
	MOVEM C,ACCBLK+.ACDIR
	SETZM ACCBLK+.ACPSW		;First try without password
	SETOM ACCBLK+.ACJOB
.ALI.2:	MOVSI A,(AC%OWN)		;ACCESS and not CONNECT
	HRRI A,3			;Length of alias block
	MOVEI B,ACCBLK			;Try the access
	ACCES
	 ERJMP [MOVEI A,.FHSLF		;Failed, see if need a psw
		GETER
		HRRZS B
		CAIE B,ACESX3
		 ERROR (Unable to access user directory because: %2E)
		PROMPT <Password: >
		MOVEI A,.PRIIN		;Get current TTY mode
		RFMOD
		PUSH P,B		;Save for later
		TRZ B,TT%ECO		;Kill echo
		TRO B,TT%LIC		;Raise input
		SFMOD
		STPAR
		CALL GETLIN		;Get password string
		CONFRM
		CALL CRLF		;Echo a CRLF
		MOVEI A,.PRIIN		;Restore echo
		POP P,B
		SFMOD
		STPAR
		HRROI B,STRBUF		;Try again with the password
		MOVEM B,ACCBLK+.ACPSW
		JRST .ALI.2]
	POP P,B
	CALL SETDIR
	HRROI A,[ASCIZ//]		;Only do this once
	RSCAN
	 NOP
	SETZB F,USRHDR			;Clear all flags and user headers
	SETZM SPRHDR
	SETZM KEYTBL
	SETZM ONLHDR
	SETZM USRHTB
	TRO F,F%ALIA			;But set the ALIAS flag
	CALLRET GOINIT

.MSGSE:	.+1				;MACRO-10 cannot handle big literals
	ASCIZ\
A message sequence is a series of messages that have some trait in common.
The message sequences available are:

AFTER		Equivalent to SINCE
ALL		Every message in your file, whether deleted or not.
ANSWERED	Messages you have REPLY'd to or ANSWER'd
BEFORE		Messages before a given date
CURRENT		MM keeps a pointer to the current message it is
		set at.  This sequence (which consists of only 1
		message obviously) is that message.
DELETED		Messages you have marked for deletion with the
		DELETE command or the MOVE command
FLAGGED		Messages you have marked with the FLAG command
FROM		Followed with a word or phrase denoting the
		the senders of the message; e.g. HEADERS FROM SMITH
		would show all the headers of the messages you've
		received from SMITH.
INVERSE		This is the exact opposite of ALL. Instead of
		of taking the sequence as lowest message number to
		highest, it takes it from highest to lowest
KEYWORDS	Messages included in the specified keyword
LAST		Followed with a number specifying the last n messages
		in the file
NEW		Messages that are new as of this MM session
ON		Messages on a given date
PREVIOUS-SEQUENCE
		The last sequence used in an MM command
RECENT		Messages that were new as of this MM session but which
		have already been seen
SEEN		Messages that you have read
SINCE		Messages after a given date (entered as	DATE/MONTH/YEAR)
SUBJECT		Followed with a word or phrase denoting the subject
		of the message; e.g. HEADERS SUBJECT MEETING would show
		you all the headers of the messages about a meeting
		(assuming they say MEETING in the header)
TEXT		Followed with a word, phrase or sentence denoting
		the text of the message; e.g. HEADERS TEXT BIZARRE
		would show you all the headers of the messages with
		the word BIZARRE in their text
TO		Followed with the name of a recipient, shows messages
		whose To or Cc fields contain that recipient.
UNANSWERED	Messages you have not REPLY'd to or ANSWER'd
UNDELETED	Messages that haven't been deleted via the DELETE or
		MOVE commands
UNFLAGGED	Messages that haven't been flagged by the FLAG command
UNKEYWORDS	Messages not included in the specified keyword
UNSEEN		Messages you haven't seen via the READ or TYPE command

Also, message numbers are allowed to be specified as a sequence, i.e.
	1,2,3,5,8   -	 Messages 1,2,3,5, and 8
	1:3,7:10    -	 Messages 1 through 3 and 5 through 8
	5	    -	 Message number 5
\

.HRGEN:	.+1			;MACRO chokes on this as a literal
	ASCIZ/
You are currently at READ level, invoked by giving the READ command.  READ
allows you to process your new messages (or for that matter old ones) in a
sequential obvious manner. Type a ? for a list of the commands you can use
at this level. They represent a subset of the top level commands, and
unless otherwise specified each command operates only on the message you
are currently reading. For more information type HELP followed by ? for a
list of the things you can get help on here.
/

.HSGEN:	.+1			;MACRO chokes on this as a literal
	ASCIZ/
You are currently at SEND level, invoked by giving the SEND command.  SEND
allows you to compose a message to send to someone and edit the particular
fields of interest (subject, to-list, cc-list, bcc-list, text, etc.). You
may use your editor to edit the text by giving the text command. Note that
while typing text in you may type ^K to have what you have typed thus far
re-displayed, ^E to invoke your editor, and ^B to insert a file. To exit,
use ^Z or <ESC>. For more help, you can type HELP ? to get a list of the
commands help is available for at this level.
/
	
.GENER:	HRROI B,[ASCIZ/HLP:MM.HLP/]	;Note: hrroi = 561
	MOVSI A,(GJ%OLD!GJ%SHT)
	GTJFN
	 JRST NOHELP
	MOVEM A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST NOHLP0
HELP1:	MOVE A,TMPJFN
	BIN
	JUMPE B,HELP2
	MOVEI A,.PRIOU
	BOUT
	JRST HELP1

HELP2:	GTSTS
	TLNN B,(GS%EOF)			;Null, did we hit eof?
	 JRST HELP1			;No, spurious
CLSTMP:	SKIPG A,TMPJFN
	 RET
	CLOSF
CLSTM0:	 SKIPA A,TMPJFN
	  JRST CLSTM1
	RLJFN
	 NOP
CLSTM1:	SETOM TMPJFN
	RET

NOHLP0:	CALL CLSTM0
NOHELP:	JWARN (No help available)
	RET

.HELP:	NOISE (ON TOPIC)
	DEFALT (GENERAL)
	MOVEI A,H1CMDT			;Otherwise, help for top-level
	TRNE F,F%READ			;In read command?
	 MOVEI A,H1RCMD
	TRNE F,F%SEND			;In send command?
	 MOVEI A,H1SCMD
	CALL SUBCMD
	PUSH P,A
	CONFRM
	POP P,A
	SKIPG B,(A)			;Routine or fixed string?
	 JRST (A)			;Routine, go do it
	HRROI A,(B)
	PSOUT
	RET

;;Help for send-level

H1SCMD:	N1HSCM,,N1HSCM
	CMD (BCC,.HSBCC)
	CMD (BLANK,.HBLANK)
	CMD (CC,.HSCC)
	CMD (DISPLAY,.HSDISPLY)
	CMD (EDIT,.HSEDIT)
	CMD (ERASE,.HSERASE)
	CMD (GENERAL,.HSGENERAL)
	CMD (INSERT,.HSINSERT)
	CMD (LITERAL-TYPE,.HLSTY)
	CMD (MSG-SEQUENCE,.MSGSE)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HSQUIT)
	CMD (REMOVE,.HSUNTO)
	CMD (RESTORE-DRAFT,.HREST)
	CMD (SAVE-DRAFT,.HSAVE)
	CMD (SEND,.HSSEND)
SPELL,<
	CMD (SPELL,.HSSPE)
>;SPELL
	CMD (SUBJECT,.HSSUBJECT)
	CMD (TEXT,.HSTEXT)
	CMD (TO,.HSTO)
	CMD (TYPE,.HSTYPE)
	CMD (USER-HEADER,.HUSER)
N1HSCM==.-H1SCMD-1

;; Help for read-level

H1RCMD:	N1HRCM,,N1HRCM
	CMD (BLANK,.HBLANK)
	CMD (CONTINUE,.HCONT)
	CMD (COPY,.HRCOPY)
	CMD (DELETE,.HRDELETE)
	CMD (EDIT,.HREDIT)
	CMD (FLAG,.HFLAG)
	CMD (FORWARD,.HRFORWARD)
	CMD (GENERAL,.HRGENERAL)
	CMD (HEADER,.HRHEADER)
	CMD (KEYWORDS,.HKEYWORDS)
	CMD (LIST,.HRLIST)
	CMD (LITERAL-TYPE,.HLRTY)
	CMD (MOVE,.HRMOVE)
	CMD (MSG-SEQUENCE,.MSGSE)
	CMD (NET-MAIL,.HMAILER)
	CMD (NEXT,.HNEXT)
	CMD (PREVIOUS,.HPREVIOUS)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HSQUIT)
	CMD (REMAIL,.HREMA)
	CMD (REPLY,.HRREPLY)
	CMD (SEND,.HSEND)
SPELL,<
	CMD (SPELL,.HRSPE)
>;SPELL
	CMD (TYPE,.HRTYPE)
	CMD (UNANSWER,.HRUNANSWER)
	CMD (UNDELETE,.HRUNDELETE)
	CMD (UNFLAG,.HRUNFLAG)
	CMD (UNKEYWORDS,.HUNKEYWORDS)
N1HRCM==.-H1RCMD-1

;;Help options for top-level stuff

H1CMDT:	N1HCMD,,N1HCMD
	CMD (ALIAS,.HALIAS)
	CMD (ANSWER,.HANSWER)
	CMD (APPEND,.HAPPEND)
	CMD (BBOARD,.HBBOARD)
	CMD (BLANK,.HBLANK)
	CMD (BUG,.HBUG)
	CMD (CHECK,.HCHECK)
	CMD (CONTINUE,.HCONT)
	CMD (COPY,.HCOPY)
	CMD (COUNT,.HCOUN)
	CMD (CREATE-INIT,.HCRINI)
	CMD (DAYTIME,.HWHEN)
	CMD (DELETE,.HDELETE)
	CMD (DIRED,.HDIRED)
	CMD (EDIT,.HEDIT)
	CMD (ENABLE,.HENABLE)
	CMD (EXAMINE,.HEXAMINE)
	CMD (EXIT,.HEXIT)
	CMD (EXPUNGE,.HEXPUNGE)
	CMD (FILE-LIST,.HFILE)
	CMD (FLAG,.HFLAG)
	CMD (FORWARD,.HFORWARD)
	CMD (GENERAL)
	CMD (GET,.HGET)
	CMD (HEADERS,.HHEADERS)
	CMD (JUMP,.HJUMP)
	CMD (KEYWORDS,.HKEYWORDS)
	CMD (LIST,.HLIST)
	CMD (LITERAL-TYPE,.HLTYP)
	CMD (LOGOUT,.HLOGO)
	CMD (MARK,.HMARK)
	CMD (MOVE,.HMOVE)
	CMD (MSG-SEQUENCE,.MSGSE)
	CMD (NET-MAIL,.HMAILER)
	CMD (NEXT,.HNEXT)
	CMD (PREVIOUS,.HPREVIOUS)
	CMD (PROFILE,.HPROFILE)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HQUIT)
	CMD (READ,.HREAD)
	CMD (REMAIL,.HREMA)
	CMD (REPLY,.HANSWER)
	CMD (RESTORE-DRAFT,.HREST)
	CMD (SEND,.HSEND)
	CMD (SET,.HSET)
	CMD (STATUS,.HSTATUS)
	CMD (SYSTEM-MSGS,.HSYSTEM)
	CMD (TYPE,.HTYPE)
	CMD (UNANSWER,.HUNANSWER)
	CMD (UNDELETE,.HUNDELETE)
	CMD (UNFLAG,.HUNFLAG)
	CMD (UNKEYWORDS,.HUNKEYWORDS)
	CMD (UNMARK,.HUNMARK)
	CMD (VERSION,.HVERSION)
N1HCMD==.-H1CMDT-1

.HENAB:	[ASCIZ/
The ENABLE command enables your capabilities (if you have any.)
/]
.ENABL:	NOISE (CAPABILITIES)
	CONFRM
	TRZ F,F%RONL			;This may let us munge a file
	MOVEI A,.FHSLF
	SETO C,
	EPCAP
	RET

.HQUIT:	[ASCIZ/
The QUIT command quits out of MM without erasing any deleted messages.
/]
.QUIT:	CONFRM
QUIT0:	CALL UNMAPF			;Unmap old file
	SKIPG MSGJFN			;If we don't have a JFN,
	 JRST QUIT1			;Don't try to close it
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	MOVE A,MSGJFN
	TLO A,(CO%NRJ)			;Don't release JFN
	CLOSF				;Close file
	 NOP
QUIT1:	CALL CLOSF1
	HALTF				;Quit back to the EXEC
REL3,<
;  This test tries to catch the mail file JFN being yanked out from under us.
; Evidentally restricted JFN's aren't implemented in release 3.  Unfortunately,
; this test isn't really paranoid enough, since another JFN could have taken
; its place.  In that case, however, PARSEF would probably barf completely.
	SKIPG B,MSGJFN			;If we have JFN
	 RET
	MOVEI A,.NULIO			;Make sure JFN still there
	SETZB C,D
	JFNS
	 ERJMP [SETZM MSGJFN		;No JFN there, give up
		CALLRET GETFIL]
>;REL3
	SKIPG A,MSGJFN			;If we have JFN
	 RET
	PUSH P,M			;Save current message number
	PUSH P,LASTM			;And total number of messages
	TRO F,F%AMOD			;Hack to not print stuff
	CALL GETF3			;Get file back
	TRZ F,F%AMOD			;Undo mischief
	MOVE A,-1(P)			;Range check saved current message
	CAML A,LASTM
	 SETZM -1(P)			;Else go to the beginning I guess
	CALLRET CHECKN			;Print any new messages

.HBUG:	[ASCIZ/
The BUG command can be used to report problems or suggestions you
have for MM to the maintainers of MM.  BUG puts you into SEND
mode with a predefined list of addresses to send the bug to.  You
send it the normal way you would send a message.  The response
may take a short while, e.g. several days.
/]

;;;List of recipients of ARPANET bug reports for this version of MM
BUGLST:	ASCIZ/MMcM@MIT-XX,Admin.MRC@SU-SCORE/

.BUG:	CONFRM
	CALL SNDINI			;Setup for sending a message

;;;First we handle special local bug recipients for non-ARPANET sites
BUG0:
CLSC,<	MOVE A,[POINT 7,[ASCIZ/C-Griss/]]>
COL,<	MOVE A,[POINT 7,[ASCIZ/OC.MRC/]]>
DREA,<	MOVE A,[POINT 7,[ASCIZ/Hemphill/]]>
HP,<	MOVE A,[POINT 7,[ASCIZ/Eldredge,MRC/]]>
GSB,<	MOVE A,[POINT 7,[ASCIZ/A.MRC/]]>
LOTS,<	MOVE A,[POINT 7,[ASCIZ/M.MRC/]]>
SUMX,<	MOVE A,[POINT 7,[ASCIZ/Crispin/]]>
IFN .-BUG0,<
	SETZ E,				;Set the folks up
	TLZ F,(F%CC)			;As to recipients
	CALL PRADDT
>;IFN .-BUG0

;;;Next, we include REMARKS and ACTION so the site's local wizards get a copy
NOSCOR,< ;;I am ACTION@SCORE and don't want to get the message twice!
	MOVE A,[POINT 7,[ASCIZ/Remarks,Action/]];Catchall names
	SETZ E,
	TLO F,(F%F4!F%CC)		;As cc recipient with no error
	CALL PRADT1			;Put this list in
>;NOSCOR

;;;Finally, we send the copy to the bug list
	SKIPN A,HSTPTR			;Set up host tables yet?
	 CALL HSTINI			;No, get them then
	HRROI B,[ASCIZ/MIT-XX/]		;Is MIT-XX a known concept here?
	TBLUK
	SETZ E,				;Now we set up the primary recipients
	TLZ F,(F%CC)			;As to recipients
	TLNE B,(TL%NOM!TL%AMB)		;Failing match?
	 SKIPA A,[POINT 7,[ASCIZ/Operator/]];No, use Operator if nothing else
	  SKIPA A,[POINT 7,BUGLST]	;Yes, can use the bug list
	   SKIPN CCLIST			;Don't send to opr if have someone else
	    CALL PRADDT			;Process list of bug report recipients
	MOVE A,[POINT 7,HDRPAG+700]
	MOVEI B,[ASCIZ/Bug in/]
	CALL MOVSTR			;Setup default subject for this
	PUSH P,A
	CALL GETVER			;Tell what version is buggy
	POP P,A
	MOVEI B,STRBUF
	CALL MOVST0
	MOVEI A,[ASCIZ/ESCAPE or ^Z/]
	SKIPGE ESCSND
	 MOVEI A,[ASCIZ/ESCAPE to get to MM command level, ^Z to send/]
	SKIPLE ESCSND
	 MOVEI A,[ASCIZ/^Z to get to MM command level, ESCAPE to send/]
	CIETYP < Please enter your MM comments or suggestions, terminated
with %1S:
>
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVEI A,SNDRET			;Enter SEND level now just in case
	HRRM A,CMDRET
	CALL .TEXT0			;Get text of reply
	CALLRET SEND0			;And go get more or send it off

.HVERS:	[ASCIZ/
The VERSION command shows the version number of the current MM, including
its configuration.
/]
.VERSI:	CONFRM
DEC,<	CITYPE (DEC default)>;DEC
BBN,<	CITYPE (BBN)>;BBN
CIT,<	CITYPE (Cal Tech)>;CIT
CLSC,<	CITYPE (Utah College of Science)>;CLSC
COL,<	CITYPE (Columbia)>;COL
DREA,<	CITYPE (D.R.E.A.)>;DREA
EECS,<	CITYPE (MIT-EECS)>;EECS
GSB,<	CITYPE (Stanford GSB)>;GSB
HP,<	CITYPE (Hewlett-Packard)>;HP
ISI,<	CITYPE (USC-ISI)>;ISI
LOTS,<	CITYPE (Stanford LOTS)>;LOTS
XX,<	CITYPE (MIT-XX)>;XX
SPCH,<	CITYPE (MIT Speech)>;SPCH
RAND,<	CITYPE (RAND)>;RAND
RUTG,<	CITYPE (Rutgers)>;RUTG
SCOR,<	CITYPE (Stanford SCORE)>;SCOR
SRI,<	CITYPE (SRI)>;SRI
SUMX,<	CITYPE (SUMEX)>;SUMX
UTAH,<	CITYPE (UTAH-20)>;UTAH
UTEX,<	CITYPE (U. of Texas)>;UTEX
	CALL .VERS1
REL3,<	CITYPE (TOPS-20 release 3 support)>;REL3
HOSTS2,<CITYPE (HOSTS2 host table support)>;HOSTS2
IPCF,<	CITYPE (IPCF mailer for local mail)>;IPCF
NEWQ,<	CITYPE (XMAILR multi-network mailer)>;NEWQ
	RET

.VERS1:	CALL GETVER
	UTYPE STRBUF
	RET

.HSET:	[ASCIZ/
The SET command allows you to change certain defaults that MM uses in
handling your messages. To see the various possibilities you can do SET ?.
This command can be used in conjunction with the the CREATE-INIT command.
You could first type CREATE-INIT and then edit the resultant MM.INIT in
your directory (see HELP CREATE-INIT for more information) or you can SET
variables and then type CREATE-INIT which will put out those defaults in
MM.INIT.
/]
.VARIA:	NOISE (VARIABLE)
	MOVEI B,[FLDDB. .CMKEY,,INIVTB]
	CALL CMDFLD			;Get the name of the variable
	HRRZ T,(B)
	MOVE T,(T)			;Get pointer to variable
	NOISE (TO)
	HLRE N,T			;Get length of string
	JUMPE N,.VRNUM			;Not a string, get a number
	CALL GETLIN			;Read a line
	CONFRM
	JUMPG N,[MOVEI U,(T)		;Do routine if specified
		 MOVE T,[POINT 7,STRBUF]
		 JRST (N)]
	HRROI A,(T)			;Where it goes
	HRROI B,STRBUF
	MOVE C,N
	SOUT				;Move the guy over
	RET

.VRNUM:	MOVEI B,[FLDDB. .CMNUM,,^D8]
	CALL CMDFLD
	PUSH P,B
	CONFRM
	POP P,(T)
	RET

SUBTTL Command subroutines

;;; Once only type initialization
INIT:	MOVEI A,.CTTRM
NOVTS,<
	GTTYP
	MOVEM B,TTYPE
>;NOVTS
	MOVEI D,SAVMOD
	CALL GETTYM			;Get current tty modes
	MOVE T,[SAVMOD,,EDMOD]		;Give a reasonable set of editor modes
	BLT T,EDMOD+4
	TRZ C,3B19			;Don't echo esc
	SFCOC
	MOVEM C,2(D)
	MOVEI A,.FHSLF			;Setup interrupt stuff
	RPCAP
	TRZ B,-1			;Only enable lh caps at first
	IOR C,B
	EPCAP
	MOVE B,[LEVTAB,,CHNTAB]
	SIR
	EIR
	MOVSI B,(3B5)			;^N and timer chans
	AIC
	CALL SETTIM			;Set up timer interrupt
	GJINF
	DMOVEM A,MYDIR			;Save directory
	MOVE B,A
SETDIR:	HRROI A,MYDIRS			;Temp name for speed
	DIRST
	 NOP
	RET

.RFLAG:	CONFRM
FLGMSG:	SKIPA A,[M%ATTN]		;Flag message
REPMSG:	 MOVEI A,M%RPLY			;Mark as replied to
	CALLRET SETBIT

.RDELM:	CONFRM				;Confirm first
DELMSG:	SKIPA A,[M%DELE]		;Mark as deleted
MRKMSG:	 MOVEI A,M%SEEN			;Mark as seen
SETBIT:	IORM A,MSGBTS(M)
	CALLRET UPDBIT			;Go update the message bits, maybe

.RUFLG:	CONFRM
UFLMSG:	MOVEI A,M%ATTN			;Unflag message
	CALLRET CLRBIT

.RUNAN:	CONFRM
UANMSG:	MOVEI A,M%RPLY			;Unanswer message
	CALLRET CLRBIT

.RUMRK:	CONFRM
	CALLRET UMKMSG			;Go mark as unseen

.RUDLM:	CONFRM
UNDMSG:	SKIPA A,[M%DELE]		;Mark as undeleted
UMKMSG:	 MOVEI A,M%SEEN			;Mark as unseen
CLRBIT:	ANDCAM A,MSGBTS(M)
	CALLRET UPDBIT			;Go update the message bits, maybe

.RUKEY:	CALL GETKEY			;Remove keywords
	HLRM U,KEYBTS			;Save mask bits
	CONFRM
UNKMSG:	HRLZ A,KEYBTS
	CALLRET CLRBIT

.RKEYW:	CALL GETKEY			;Add keywords
	HLRM U,KEYBTS
	CONFRM
KEYMSG:	HRLZ A,KEYBTS
	CALLRET SETBIT

;;; Get an output file, defaulting to the SAVED-MESSAGES-FILE file if known,
;;; giving it the NEW-FILE-PROTECTION protection.  GETOFI doesn't have the
;;; SAVED-MESSAGES-FILE default, although it still defaults the protection.
GETOUT:	SETZM CMDGTB+.GJGEN		;Default to highest generation
REL3,<
	SKIPN SAVFIL			;Release 3 didn't allow null defaults
	 JRST GETOU0
>;REL3
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/output filespec/]>,<-1,,SAVFIL>]
	JRST GETOU2			;Join common code

GETOFI:	MOVEI A,.GJNHG			;Use next higher generation
	MOVEM A,CMDGTB+.GJGEN
GETOU0:	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/output filespec/]>]
GETOU2:	PUSH P,B			;Save block we selected
	NOISE (INTO FILE)		;Get an output file
	SETZM CMDGTB+.GJSRC		;Get space for GTJFN
	MOVE A,[CMDGTB+.GJSRC,,CMDGTB+.GJSRC+1]
	BLT A,CMDGTB+.GJATR
	SKIPN B,DEFPRO			;Have default protection?
	 JRST GETOU1
	HRROI A,DEFPST			;Where to put string
	MOVEM A,CMDGTB+.GJPRO		;Set up pointer to default
	MOVE C,[6,,^D8]			;Columns,,radix
	NOUT
	 JERROR (New file protection error)
GETOU1:	POP P,B				;Get back block user specified
	CALL CMDFLD			;Get the file
	MOVEM B,OUTJFN			;Save it
	RET

GETLPT:	SKIPLE A,OUTJFN
	 JRST GETLP1			;Use specified file
GETLP0:
IFN LPTCFF,<
	PROMPT <Do you really want to output to a lineprinter?>
	CALL YESNO1
	 JRST [	HRROI A,GETLPH
		PSOUT
		RET]
>;IFN LPTCFF
	MOVSI A,(GJ%FOU!GJ%SHT)
	HRROI B,[ASCIZ/LPT:/]
	GTJFN
	 JERROR (Can't get LPT)
GETLP1:	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open LPT)
	MOVEM A,OUTJFN
	RETSKP
IFN LPTCFF,<
GETLPH:	ASCIZ/
Use the TYPE command to type a message on your terminal.  Use
the FILE-LIST command to list a message to a file, or the COPY
command if you want to write the file in mail file format.
/
>;IFN LPTCFF

MOVMSG:	CALL CHKDEL			;Is it deleted?
	 RET				;Yes, then don't move it
	CALL PUTMS1			;No, go ahead and move it
	CALLRET DELMSG			;And delete it afterwards

LPTMSG:	CALL CHKDEL
	 RET
	CALL PUTMS1			;Output the message
	SKIPN LSTPAG			;Separate pages?
	 RET				;No, done
	HRROI B,[ASCIZ/
/]
	SETZ C,
	SOUT				;Yes, output formfeed after each one
	MOVEI B,CTL(L)
	BOUT
	HRROI B,[ASCIZ/
/]
	SOUT
	RET

PUTMSG:	CALL CHKDEL			;Not deleted msgs
	 RET
PUTMS1:	MOVE V,MSGALL(M)		;Get start of the message
	CALL CHR2BP
	MOVE B,A
	MOVN C,MSGSAL(M)		;Length
	MOVE A,OUTJFN			;Where it goes
	SOUT				;That's it
	RET

;;; Make up the correct subject for a reply to the current message
REPSUB:	SKIPN A,MSGSUB(M)
	 RET				;No subject
	MOVE B,[POINT 7,STRBUF]
	CALL FORMSS			;Move it to temp space
	SETZ D,
	IDPB D,B			;And a null
	MOVE A,STRBUF			;Get start of it
	ANDCM A,[<BYTE (7) 40,40,0,0,177>+1];Uppercase and clear last byte
	CAMN A,[ASCIZ/RE: /]		;Already a response?
	 JRST REPSB1			;Yes, don't propogate Re: 's
	MOVE A,[ASCIZ/Re: /]
	MOVEM A,HDRPAG+700		;Start subject off right
	SKIPA A,[POINT 7,HDRPAG+700,27]	;Start going into last byte
REPSB1:	 MOVE A,[POINT 7,HDRPAG+700]	;Start at start of subject
	MOVEI B,STRBUF			;From here
	CALLRET MOVST0			;Move it and the null

;;; Forward the current message
FORMSG:	SKIPN A,MSGFRM(M)		;Has an author?
	 JRST FORMS2			;No
	MOVE B,[POINT 7,HDRPAG+700]
	MOVEI C,"["
	IDPB C,B
	CALL FORMSS
	MOVEI C,":"
	IDPB C,B
	SKIPN A,MSGSUB(M)
	 JRST FORMS1
	MOVEI C," "
	IDPB C,B
	CALL FORMSS
FORMS1:	MOVEI C,"]"
	IDPB C,B
	SETZ C,
	IDPB C,B
FORMS2:	MOVE A,MSGBOD(M)		;Body of the message
	MOVE B,TXTPTR
	CALL FORMSS
	MOVEM B,TXTPTR
	RET

;;;Output the portion of the message pointed to by A into byte pointer in B
FORMSS:	HLRZ C,A
	JUMPE C,CPOPJ			;None to do
	MOVEI V,(A)			;Get byte offset of field
	CALL MCH2BP			;Get byte pointer to it
FRMSS1:	ILDB D,A			;Get char
	SKIPE D				;Never put in a null
	 IDPB D,B
	SOJG C,FRMSS1
	RET

;;;Remail a single message
RMLMSG:	CALL .ERSTX			;Erase vestiges of previous REMAIL
	HRRZ V,MSGBOD(M)		;Get pointer to message body
	CALL MCH2BP
	HLRZ C,MSGBOD(M)		;Length of it
	MOVE B,[POINT 7,HDRPAG]		;Start of some headers
OIPCF,<
	MOVEI E,15			;We need a leading CRLF for places
	IDPB E,B			; with a special interface, but whose
	MOVEI E,12			; MAILERs insist upon putting in their
	IDPB E,B			; headers!
	SUBI C,2			;Account for the characters
>;OIPCF
	MOVEI E,12			;Start at new line
RMLMS1:	SOJL C,[ERROR (Badly formatted message)]
	ILDB D,A			;Get character
	IDPB D,B			;Stick it in
	EXCH D,E
	CAIN E,15			;This char a CR?
	 CAIE D,12			;And previous LF
	  JRST RMLMS1			;No, continue
	ADD B,[7B5]
	MOVEM B,RMLPTR			;This is the pointer to end of headers
	SOJL C,RMLMS2			;If there is more text
	IBP A				;Move over the LF
	MOVE B,TXTPTR			;Move the rest of it into text
	CALL FRMSS1
	MOVEM B,TXTPTR			;Update text pointer
	IDPB C,B			;Make sure it ends with a null
RMLMS2:	CALLRET SNDMSG			;Go send the message off

;;;Replace current message

RPLMSG:	PUSH P,A			;Save byte pointer
	PUSH P,C			;And byte count
	CALL GETJF2			;Get a write JFN
	 JRST POPCA			;Failed
	MOVEM A,OUTJFN			;Save it here as well
	MOVE B,MSGALL(M)		;Get start of whole message
	IDIVI B,5000			;Round down to start of page
	PUSH P,C			;Save remainder
	IMULI B,5000			;Set to start of page
	SFPTR
	 JERROR
	MOVE V,MSGALL(M)
	CALL CHR2BP			;Get byte pointer to message
	MOVE E,A			;Save it
	ANDI A,777000			;Get page number of start
	PUSH P,A			;Save start of core page
	MOVEI B,-MSGPAG*1000(A)		;Get page offset
	LSH B,-9
	PUSH P,B			;Save starting disk page
	HRRZ C,FILPGS			;Get number of pages in the file
	SUBI C,(B)			;Less where we started
	PUSH P,C			;Save count
RPLMS0:	MOVES (A)			;Make all pages after that private
	ADDI A,1000
	SOJG C,RPLMS0
;;;Remove the old pages from the file
	SETO A,				;Remove these pages from file
	POP P,C				;Count
	TLO C,(PM%CNT)
	POP P,B				;Starting page
	HRL B,MSGJF2			;JFN
	PMAP				;Kill the old copies from file
	 ERJMP .+1
;;;Copy from start of first page up to message we are concerned with
	HRRZ A,MSGJF2			;Get write JFN again
	POP P,B				;Start of first page
	TLO B,-1			;Make byte pointer
	POP P,C				;Count
	MOVN C,C			;Negate: use exact count
	SKIPE C				;Forget if count=0
	 SOUT				;Copy to file
;;;Now put out revised message
RPLMS1:	ILDB B,E			;Get character
	BOUT
	CAIE B,","			;Until start of byte count
	 JRST RPLMS1
	MOVE B,(P)			;New byte count
	MOVEI C,^D10
	NOUT
	 JERROR
RPLMS2:	ILDB B,E
	CAIE B,";"			;Now look for start of message bits
	 JRST RPLMS2
RPLMS3:	BOUT
	ILDB B,E
	CAIE B,12			;Until end of line
	 JRST RPLMS3
	BOUT				;And that as well
	MOVE B,-1(P)			;Get byte pointer
	MOVN C,(P)			;And byte count
	SOUT				;Put that in now
	PUSH P,M			;Save current message
	ADDI M,MSGLEN
RPLMS4:	CAMLE M,LASTM			;Reached end of file?
	 JRST RPLMS5			;Yes
	CALL PUTMS1			;Move this into file
	ADDI M,MSGLEN
	JRST RPLMS4			;For all messages

RPLMS5:	MOVE A,OUTJFN
	RFPTR
	 JFATAL
	HRLI A,.FBSIZ
	MOVE C,B			;Current position
	SETO B,
	CHFDB				;Make this the new end of the file
	CALL CLSJF2			;Close off file
	CALL SIZFIL			;Get its new size info
	MOVE M,(P)			;Get back current message
	CALL PARSEF			;Reparse the file
	CALLRET POPMCA			;Restore current message and return

;;;Get TTY modes

GETTYM:	MOVEI A,.FHJOB			;Get job's interrupt word
	RTIW
	DMOVEM B,3(D)
	MOVEI A,.PRIOU
	RFMOD
	MOVEM B,0(D)
	RFCOC
	DMOVEM B,1(D)
	RET

;;;Set TTY modes

SETTYM:	MOVEI A,.FHJOB
	DMOVE B,3(D)
	STIW
	 ERJMP .+1
	MOVEI A,.PRIOU
	MOVE B,0(D)
	SFMOD
	DMOVE B,1(D)
	SFCOC
	RET

.HCHEC:	[ASCIZ/
The CHECK command is used to check for new messages that may have arrived
while you are using MM.
/]
.CHECK:	NOISE (FOR NEW MESSAGES)
	CONFRM
CHECKT:	SETZM CHKTIM			;Force check now.

;;;Check for new messages periodically

CHECK:	CALL CHECK0			;Check for new messages
	 RET				;None

;;;Print message when there are new guys

CHECKS:	MOVE A,MSGJFN
	CALL SETREF			;Set read date
	PUSH P,M			;Save current message
	MOVE M,LASTM			;Start at the end
	PUSH P,M			;Save number of messages
	ADDI M,MSGLEN			;From that one on,
	CALL PARSEF			;Parse these new ones
CHECKN:	POP P,A				;Get old number
	SUB A,LASTM			;Get number of new guys
	JUMPE A,POPMJ			;None - someone's mucking with the file
	IDIVI A,MSGLEN
	MOVM A,A
	MOVEI B,[ASCIZ/are/]
	CAIN A,1
	 MOVEI B,[ASCIZ/is/]
	CIETYP < There %2S %1D additional message%1P
>
	CALL RECENT			;Give the headers of the recent ones
	CALLRET .STAT1			;Restore current message and tell user

POPMJ:	POP P,M				;Restore current message
	RET

CHECK0:	GTAD
	CAMGE A,CHKTIM			;Time we had a look?
	 RET				;Nope, back to work then
	ADDI A,<5B17/^D<24*60>>		;Five minutes from now
	MOVEM A,CHKTIM			;Is next time to look
	SKIPG MSGJFN			;Have a file?
	 JRST CHKNEW
	PUSH P,FILSIZ			;Save current size
	CALL SIZFIL			;Get the current poop on it
	POP P,T				;Get back old size
	MOVE A,FILWRT
IFN BDUPDF,<
	CAML A,LASTRD			;Both dates updated on some systems
>;IFN BDUPDF
IFE BDUPDF,<
	CAMLE A,LASTRD			;Written since last read?
>;IFE BDUPDF
	 CAMN T,FILSIZ			;And size changed?
	  RET				;No, nothing changed
	RETSKP				;Yes, skip return

;;;Check if MAIL.TXT has been undeleted

CHKNEW:	TLO F,(F%F1)
	CALL FNDFL0			;Has it?
	 RET				;Nope, return
	SKIPN FILSIZ			;If file is empty, ignore it
	 JRST [	RLJFN			;Get rid of the file
		 NOP			;Ignore failure
		RET]
	TRNE F,F%RONL			;Read-only file?
	 JRST CHKNW3			;Yes, don't lock
	MOVSI A,(EN%SHR!EN%BLN)		;Shared access, no level #'s
	HRR A,MSGJFN			;This file
	MOVEM A,ENQBLK+.ENQLV
CHKNW2:	DMOVE A,[.ENQAA			;Try and get lock, but don't wait
		 ENQBLK]
	ENQ
	 ERJMP [WARN (File is locked, waiting...)
		MOVEI A,^D5000		;Wait a bit
		DISMS
		JRST CHKNW2]		;Now try again
CHKNW3:	MOVNI A,MSGLEN			;Flag for full parse
	MOVEM A,LASTM
	SETZ M,
	RETSKP

;;;Build string of version number in strbuf

GETVER:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/ MM Version /]
	CALL MOVSTR
	LDB B,[POINT 9,VERNUM,11]
	JUMPE B,GTVER1
	MOVEI C,^D8
	NOUT
	 NOP
GTVER1:	LDB B,[POINT 6,VERNUM,17]
	JUMPE B,GTVER3
	SUBI B,1
	IDIVI B,^D26
	JUMPE B,GTVER2
	ADDI B,"A"-1
	IDPB B,A
GTVER2:	ADDI C,"A"
	IDPB C,A
GTVER3:	HRRZ B,VERNUM
	JUMPE B,GTVER4
	MOVEI C,"("
	IDPB C,A
	MOVEI C,^D8
	NOUT
	 NOP
	MOVEI C,")"
	IDPB C,A
GTVER4:	LDB B,[POINT 3,VERNUM,2]
	JUMPE B,GTVER5
	MOVEI C,"-"
	IDPB C,A
	MOVEI C,^D8
	NOUT
	 NOP
GTVER5:	MOVEI C,0			;Put null in at end
	IDPB C,A
	RET

SUBTTL Lower level subroutines

;;;Move a string from B to A

MOVSTR:	HRLI B,(<POINT 7,0>)
MOVST1:	ILDB C,B
	JUMPE C,MOVST3
	IDPB C,A
	JRST MOVST1

;;;Move string and terminating null

MOVST0:	HRLI B,(<POINT 7,0>)
MOVST2:	ILDB C,B
	IDPB C,A
	JUMPN C,MOVST2
MOVST3:	RET

;;;Unmap pages from file

UNMAPF:	SETO A,
	MOVE B,[.FHSLF,,MSGPAG]
	HRRZ C,FILPGS			;Number of pages
	HRLI C,(PM%CNT)
	PMAP
	RET

;;;Close the file

CLOSEF:	SKIPG MSGJFN
	 JRST CLOSF1
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	MOVE A,MSGJFN
	CLOSF
	 NOP
	SETOM MSGJFN
CLOSF1:	SKIPLE A,MSGJF2
	 RLJFN
	  NOP
	SETOM MSGJF2
	RET

SUBTTL Interrupt routines

;;;Timer interrupt

TMRINT:	MOVEM 16,INTACS+16
	MOVEI 16,INTACS
	BLT 16,INTACS+15
	CALL SETTIM			;Set next timer up
	SKIPE OKTINT			;OK for timer at this time?
	 JRST TMRIN1			;Yes, check for new messages
TMRIN2:	MOVSI 16,INTACS
	BLT 16,16
	DEBRK				;No, return

SETTIM:	MOVE A,[.FHSLF,,.TIMEL]		;Elapsed time
	MOVEI B,^D<1*60*1000>		;1 min
	MOVEI C,5			;Chan 5
	TIMER
	 NOP
	RET

TMRIN1:	SETZM CHKTIM			;Force ...
	CALL CHECK0			;Check for new guys
	 JRST TMRIN2			;None, return for commands
	CIS				;Clear out interrupt
	MOVEI D,SAVMOD
	CALL SETTYM			;Restore tty modes
	CALL CHECKS			;Print message on new guys
	JRST @CMDRET			;And return to command

;;;^N interrupt routines

SETABO:	MOVE A,[.TICCN,,4]		;Assign ^N on chan 4
	ATI
	RET

CLRABO:	MOVEI A,.TICCN			;Deassign abort interrupt
	DTI
	RET

ABOINT:	PUSH P,A			;Here on actual interrupt
	SKIPGE A,ABOFLG			;Never abort?
	 JRST ABOIN1			;Yes, just return
	JUMPG A,ABOIN2			;Always abort
	CALL CRIF
	HRROI A,[ASCIZ/Abort? /]
	PSOUT
	MOVEI A,.PRIIN
	CFIBF
	PUSH P,B
	RFMOD
	PUSH P,B
	TRO B,TT%WAK			;Wakeup on everything
	SFMOD
	BIN
	EXCH B,(P)
	SFMOD
	POP P,A
	POP P,B
	CAIE A,"Y"
	 CAIN A,"y"
	  JRST ABOIN2			;Ok to abort
	CALL CRIF
ABOIN1:	POP P,A				;Don't abort
	DEBRK

ABOIN2:	MOVEI A,.TICCN			;Don't allow any more
	DTI
	CIS				;Abort back to command level
	MOVEI A,.PRIIN			;Make sure TTY input buffer empty
	CFIBF
	 ERJMP .+1
	MOVEI A,CMDRES			;Restore return address
	TRNE F,F%READ
	 MOVEI A,REDRET
	HRRM A,CMDRET
	SETZM CMDFLB+.CMDEF		;Clear any default setup during this
	JRST (A)

SUBTTL File parsing subroutines

GETFIL:	CALL FNDFIL			;Try to find it first
	 RET				;Not there, forget it
GETFL1:	SKIPN FILSIZ			;Is the file empty?
	 JRST [	MOVE A,MSGJFN		;Yes, get JFN for error message
		CIETYP (There are no messages in %1J.)
		RLJFN			;Get rid of the JFN
		 NOP
		SETOM MSGJFN		;Save we haven't seen it
		JRST CMDRES]
	TRNE F,F%RONL			;Read-only file?
	 JRST GETFL3			;Yes, don't lock
	MOVSI A,(EN%SHR!EN%BLN)		;Shared access, no level #'s
	HRR A,MSGJFN			;This file
	MOVEM A,ENQBLK+.ENQLV
GETFL2:	DMOVE A,[.ENQAA			;Try and get lock, but don't wait
		 ENQBLK]
	ENQ
	 ERJMP [WARN (File is locked, waiting...)
		MOVEI A,^D5000		;Wait a bit
		DISMS
		JRST GETFL2]		;Now try again
GETFL3:	SETZ M,				;Parse all messages
	CALLRET PARSEF			;Now return

;;;Try to find a MAIL.TXT

FNDFIL:	TLZ F,(F%F1)			;Ok to type messages if none there
FNDFL0:	CALL CLOSEF			;Get rid of old file perhaps
	TRNN F,F%ALIA			;Aliasing another user?
	 SKIPGE GTCNDR			;Or always get login directory?
	  JRST FNDFL7			;Yes, force that then
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ/MAIL.TXT.1/]
	GTJFN
	 JRST FNDFL2			;Not there, try login directory
	MOVEM A,MSGJFN			;Save the JFN away
	MOVE C,MYDIR
	TLO C,040000			;Make login user look like directory
	MOVE B,MYCDIR			;Ready to compare logged vs conncted
	SKIPG GTCNDR			;Always get connected directory?
	 CAMN C,B			;Are they the same?
	  JRST FNDFL1			;Yes, then go ahead and read it
	TRNN F,F%RSCN			;Don't ask if RSCAN - it can't win!
	 TLNE F,(F%F1)
	  JRST FNDFL1
	CIETYP <You are connected to directory %2U.>
	PROMPT <Read MAIL.TXT here?>	;Get extra confirmation
	CALL YESNO
	 JRST [	MOVE A,MSGJFN		;Answer was no.  Do login directory
		RLJFN
		 NOP
		SETZM MSGJFN
		SETOM GTCNDR		;Make sure get from login at check time
		MOVE C,MYDIR
		TLO C,040000		;Make login user look like directory
		CIETYP <Trying %3U...>
		JRST FNDFL7]
FNDFL1:	CALL SIZFIL			;Get the size of the file, etc.
	MOVEI B,OF%RD			;Try to open it
	OPENF
	 JRST FNDFL5
CPOPJ1:	AOS (P)				;Skip return
	RET

;;; Here to get a YES or NO reply, skip if YES
YESNO1:	MOVEI B,[FLDDB. .CMKEY,CM%SDH,<[2,,2
		 [ASCIZ/NO/],,0
		 [ASCIZ/YES/],,-1]>,<
		 POINT 7,[ASCIZ/YES or NO/]>]
	SKIPA A,[YESNO1]
YESNO:	 DMOVE A,[YESNO			;Set reparse address back to here
		  [FLDDB. .CMKEY,CM%SDH,<[2,,2
		   [ASCIZ/NO/],,0
		   [ASCIZ/YES/],,-1]>,<
		   POINT 7,[ASCIZ/YES or NO/]>,<POINT 7,[ASCIZ/YES/]>]]
	HRRM A,CMDBLK+.CMFLG
	MOVEI A,CMDBLK
	COMND
	TLNE A,(CM%NOP)			;Make sure valid answer
	 JRST YESNOE
	HRRE D,(B)			;Get answer
	MOVEI B,[FLDDB. .CMCFM]		;Make sure confirmed
	COMND
	TLNE A,(CM%NOP)
	 JRST YESNOE
	JUMPN D,CPOPJ1
	RET

YESNOE:	CITYPE <?Please answer YES or NO>
	SOS (P)
	SOS (P)
	RET

;;;Get another message file

.HGET:	[ASCIZ/
The GET command takes one argument, a filename.  It will read in that
message file, parse the messages and act as if that were the default
message file.  All commands now apply to that file.
/]
.HEXAM:	[ASCIZ/
The EXAMINE command takes one argument, a filename.  It is like the
GET command, except that the file is read-only, and the file reference
date is not updated.  Any command which alters the file is a no-op.
/]

.EXAMI:	TLOA F,(F%F1)			;Examine command
.GET:	 TLZ F,(F%F1)			;Get command
	NOISE (MSGS FROM FILE)
	DMOVE A,[ASCII/MAIL.TXT.1/]	;Default to connected directory mail
	DMOVEM A,STRBUF+40		; Default this way so unwelcome .TXT
	SETZM STRBUF+42			; defaulting won't happen
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMIFI,,,,<-1,,STRBUF+40>]
	COMND
	TLNN A,(CM%NOP)			;Parsed successfully?
	 JRST GETF0
	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR
	HRROI A,[ASCIZ/MAIL/]		;Parse failed, try parse with a
	MOVEM A,CMDGTB+.GJNAM		; file default of MAIL.TXT so
	HRROI A,[ASCIZ/TXT/]		; "GET <BBOARD>" will still work
	MOVEM A,CMDGTB+.GJEXT
	MOVEI B,[FLDDB. .CMFIL]
	CALL CMDFLD
GETF0:	PUSH P,B			;Save JFN
	CONFRM
	TRZ F,F%AMOD!F%MOD!F%RONL	;Not hacking system mail any more
	TLNE F,(F%F1)
	 TRO F,F%RONL			;Read only for examine command
GETF1:	SKIPG MSGJFN			;Any current file?
	 JRST GETF2			;No, don't need to unmap then
	CALL UNMAPF			;Unmap old file
	CALL CLOSEF			;Release old cruft
GETF2:	POP P,MSGJFN			;Restore new msgJFN
GETF3:	CALL SIZFIL			;And the size
	MOVEI B,OF%RD			;Read access
	TLNE F,(F%F1)			;Examine command?
	 TRO B,OF%PDT			;Yes, don't update anything
	OPENF
	 JRST [	JSNARL (Can't open file)
		JRST FNDFL4]
	CALL GETFL1			;Get file and parse it, barf if empty
	TRNN F,F%AMOD			;Unless auto mod
	 TRNN F,F%MOD			;Mod prints headers
	  TRNE F,F%RSCN			;Allow return to top-level
	   TLOA F,(F%F1)		;Type headers if from command line
	    TLZ F,(F%F1)
	CALL RECEN0
	TRNN F,F%AMOD			;No summary if auto mod
	 CALL SUMMRY
	TRZ F,F%RSCN
	RET

FNDFL2:	GJINF				;See if there is one elsewhere
	MOVEM B,MYCDIR			;Keep this updated
	TLO A,040000			;Make look like directory
	CAMN A,B			;Different?
	 JRST FNDFL3			;No, no MAIL.TXT then
	TLNN F,(F%F1)			;Supress messages?
	 CIETYP < No MAIL.TXT in %2U, trying %1U...>
FNDFL7:	MOVE A,[POINT 7,FILNAM]		;Get string pointer
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Login directory string
	CALL MOVSTR
	MOVEI B,[ASCIZ/>MAIL.TXT.1/]
	CALL MOVST0
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,FILNAM
	GTJFN
	 JRST FNDFL3
	MOVEM A,MSGJFN
	JRST FNDFL1

FNDFL3:	TLNN F,(F%F1)			;Suppress messages here?
	 CITYPE ( You have no MAIL.TXT.)
FNDFL4:	SETOB A,MSGJFN			;Get rid of stray JFNs
	RLJFN
	 NOP
	JRST CMDRES

FNDFL5:	TLNN F,(F%F1)
	 CITYPE ( Can't open MAIL.TXT)
	JRST FNDFL4

;;;Get size of current file

SIZFIL:	MOVE A,MSGJFN
	MOVE B,[5,,.FBBYV]
	MOVEI C,FILPGS
	GTFDB				;Get the size stuff
	 ERJMP [JSNARL
		RET]
	TRNN F,F%MOD			;Getting system mail?
	 JRST SIZFL1			;No
	SETO A,				;This job
	HRROI B,LASTRD			;Where to stick info
	MOVEI C,.JILLN			;Get time of last login
	GETJI
	 SETZM LASTRD
	MOVE A,MSGJFN			;Get back JFN
SIZFL1:	LDB U,[POINT 6,FILPGS,11]	;Get byte size
	MOVE V,FILSIZ			;Else get the size now
	CAIN U,7			;If 7 bit,
	 JRST SIZFL3			;Are almost done
	CAIN U,^D36			;36 bit is easier
	 JRST SIZFL2
	MOVEI T,^D36
	IDIVI T,(U)			;Get number of bytes in a word
	IDIVI V,(T)			;Get number of words
SIZFL2:	IMULI V,5			;Into bytes
	MOVEM V,FILSIZ			;Save the size
SIZFL3:	IDIVI V,5000			;Since we have the file open, the
	JUMPE V+1,.+2			;Page count may be too little
	 ADDI V,1			;So, we must check against the
	HRRZ T,FILPGS			;Size according to the byte count
	CAIN V,(T)			;If GTFDB equals computed,
	 RET				;Then done
	MOVE A,MSGJFN			;Find first free page,
	GTSTS				;If file is open
	TLNN B,(GS%OPN)			;Is it open?
	 JRST [	HRRM V,FILPGS		;No, use what we have
		RET]
	FFFFP				;Get first free page
	HRRM A,FILPGS			;And use it
	RET

;;;Parse the file from message (M) on

PARSEF:	HRRZ C,FILPGS
	CAILE C,1000-MSGPAG		;Enough room?
	 JRST [	SETZM FILPGS		;Keep UNMAPF from getting confused
		CALL CLOSEF		;Get rid of JFN, etc
		ERROR (File is too large)]
	JUMPE M,[SETZ A,		;First message, start at first page
		JRST PARSF2]		;And go map it all in
	MOVE A,MSGALL-MSGLEN(M)		;Get start of message
	ADD A,MSGSAL-MSGLEN(M)
	ADDI A,1			;Get size in bytes plus one
	IDIVI A,5000			;Get first page we will need
	SUBI C,(A)			;Get real page count
PARSF2:	MOVEI B,MSGPAG(A)		;First page here to map into
	HRL A,MSGJFN			;File they come from
	HRLI B,.FHSLF
	HRLI C,(PM%CNT!PM%RD!PM%CPY)
	PMAP				;Map them in

	SETZ V,				;Assume
	JUMPE M,PARS10			;Start at start
	MOVE V,MSGALL-MSGLEN(M)		;Or at end of last message
	ADD V,MSGSAL-MSGLEN(M)

PARS10:	CALL CHR2BP			;Get byte pointer to this
	MOVEM V,MSGALL(M)		;Start of whole message
PARS11:	ILDB T,A			;Get character
	JUMPE T,[CALL BP2CHR		;Get character pointer
		 CAMGE V,FILSIZ		;Running off end of file?
		  JRST PARS11		;Not yet folks
		 WARN (File has bad format: EOF pointer probably bad)
		 SUBI M,MSGLEN		;Yes, this isn't a real message
		 MOVEM M,LASTM
		 RET]
	CAIE T,","
	 JRST PARS11
	MOVEI C,^D10			;Decimal
	CALL $NIN
	HRLM B,MSGBOD(M)		;Save length of real message
	MOVEI C,10			;Octal
	CALL $NIN
	MOVEM B,MSGBTS(M)		;Save message bits
	MOVEM B,MSGFBS(M)
	SETZM MSGFLG(M)
PARS12:	ILDB T,A
	JUMPE T,[CALL BP2CHR		;Get character pointer
		 CAMGE V,FILSIZ		;Running off end of file?
		  JRST PARS12		;Not yet folks
		 WARN (File has bad format: garbage at end of file)
		 SUBI M,MSGLEN		;Yes, this isn't a real message
		 MOVEM M,LASTM
		 RET]
	CAIE T,15			;Ignore extra CR's too
	 CAIN T,40			;Ignore spaces; HERMES inserts 'em
	  JRST PARS12
	CAIE T,12			;Until end of line
	 JRST [	WARN (File has bad format: garbage at the start of message %M)
		JRST PARS12]
	CALL BP2MCH			;Get character position
	HRRM V,MSGBOD(M)		;Save start of real message
	HLRZ B,MSGBOD(M)		;Get size again
	ADDI B,(V)			;Get end of whole thing
	MOVEM B,MSGSAL(M)		;Save size of whole message
	ADD B,MSGALL(M)			;Compute absolute byte of end of message
	PUSH P,B			;Save it for later

	CALL FNDSUB			;Find the subject
	HRRZM V,MSGSUB(M)
	HRLM W,MSGSUB(M)		;Save position and size

	CALL FNDFRM			;Find the from/sender
	HRRZM V,MSGFRM(M)
	HRLM W,MSGFRM(M)

	CALL FNDDAT			;Find the date
	MOVEM B,MSGDAT(M)		;Receive date

	POP P,V				;Recover ending address
	CAML V,FILSIZ			;Is this the last one
	 JRST PARS13			;Yes, all done then
	CAIE M,MSGLEN*<NMSGS-1>		;Got all we can handle?
	 JRST [	ADDI M,MSGLEN
		JRST PARS10]		;No, keep going
	WARN (File has too many messages)
PARS13:	MOVEM M,LASTM			;Save total number of messages
	RET

;;; Our own version of NIN, does not hack negative or anything like that
$NIN:	SETZ B,
$NIN1:	ILDB D,A
	CAIL D,"0"
	 CAILE D,"0"-1(C)
	  RET				;Done
	CAIN C,^D8			;This makes overflow not happen
	 LSH B,3
	CAIE C,^D8
	 IMULI B,(C)
	ADDI B,-"0"(D)
	JRST $NIN1

;;;Find the subject of the message

FNDSUB:	MOVEI T,[ASCIZ/
Subject: /]
	CALL FNDHDR			;Try to find this header
	 JRST FNDSB3			;Not there
FNDSB1:	SETZ W,				;Count size of field in w
FNDSB2:	ILDB T,A			;Get char
	CAIE T,15			;Until the CR
	 AOJA W,FNDSB2
	RET
FNDSB3:	MOVEI T,[ASCIZ/
Re: /]					;Try this then
FNDSB4:	CALL FNDHDR
	 JRST FNDSB5			;Not there either
	JRST FNDSB1			;Found it then
FNDSB5:	SETZB V,W			;Say we didnt find it anywhere
	RET

;;;Find the author of a message

FNDFRM:	MOVEI T,[ASCIZ/
From: /]
	CALL FNDHDR
	 CAIA
	  JRST FNDSB1
	MOVEI T,[ASCIZ/
Sender: /]
	JRST FNDSB4

;;;Find the date field

FNDDAT:	MOVE V,MSGALL(M)		;First thing in header is recv date
	CALL CHR2BP
	SETZB B,C
	IDTIM
	 JRST [	WARN (File has bad format: message %M has no receive date)
	 	SETO B,
		RET]
	RET

FNDSDT:	MOVEI T,[ASCIZ/
Date: /]
	CALL FNDHDR
	 JRST FNDDT1			;Not there
	SETZB B,C
	IDTIM				;Try to parse it
FNDDT1:	 MOVE B,MSGDAT(M)		;Bad format, use recv date
	RET

;;;Try to find a header in the message body

FNDHDR:	HRRZ W,MSGHLN(M)		;Length of header
	JUMPN W,FNDHD1
	HLRZ W,MSGBOD(M)		;Number of bytes in whole
	PUSH P,T
	MOVEI T,[BYTE (7) 15,12,15,12]
	CALL FNDHD1			;Find blank line indicating end
	 SETZ V,
	POP P,T
	HRRM V,MSGHLN(M)		;Save length of header
	SKIPN W,V
	 HLRZ W,MSGBOD(M)
FNDHD1:	HRRZ V,MSGBOD(M)		;Starting byte
	CALL SEARCH			;Try to find it
	 RET				;No good
	AOS (P)
	CALLRET BP2MCH			;And get char pointer

SEARCH:	HRLI T,(<POINT 7,0>)
SEARC0:	SETZ A,
SEARC1:	ILDB B,T			;Get a character
	MOVEM B,SRCBUF(A)		;Compile search table
	JUMPE B,SEARC2
	AOJA A,SEARC1

SEARC2:	CAIGE W,(A)			;Pattern too long for whole thing?
	 RET				;Yes, don't bother then
	CALL MCH2BP			;Get byte pointer
	JUMPL A,SEARC4			;Aligned to word boundary already
	MOVEI U,1			;Have to do at least one comparison
	SKIPA E,A
SEARC3:	 MOVE A,E
	CALL EQSTR			;See if the strings match
	 CAIA				;No
	  RETSKP			;Yes, skip return
	IBP E				;Try next combination
	TLNE E,760000
	 AOJA U,SEARC3

SEAR3A:	MOVEI A,1(E)			;Start with the next word
	SUBI W,(U)			;Discount comparisons done manually
	JUMPL W,CPOPJ			;Did more than we wanted to
SEARC4:	MOVEI B,(W)			;Number of bytes to do
	IDIVI B,5			;Get number of words
	SKIPE C
	 ADDI B,1
	MOVEI W,(B)			;That is number of words to try to do
	MOVE N,SRCBUF			;First character
	IMUL N,[<BYTE (7) 1,1,1,1,1>/2]
	LSH N,1
	MOVE O,N
	XOR O,[BYTE (7) 40,40,40,40,40]
	MOVE X,[BYTE (7) 1,1,1,1,1]

SEARC5:	MOVE B,N			;Pattern to match
	MOVE C,O			;Case indept one
	MOVE D,(A)			;Word to try
	MOVE E,(A)
	JCRY0 .+1			;Clear carry flags
	EQVB D,B
	EQVB E,C
	ADD D,X
	ADD E,X
	EQV D,B
	EQV E,C
	JCRY0 SEARC6			;Found a match
	TDNN D,X
	 TDNE E,X
	  JRST SEARC6
SEAR5B:	SOJLE W,CPOPJ			;Not found
	AOJA A,SEARC5			;Try some more

SEARC6:	MOVSI U,-5			;Try matching withing this word
	SKIPA E,A
SEARC7:	 MOVEI A,(E)			;Get back start of right word
	HRL A,BPS(U)
	CALL EQSTR			;Try to match string
	 AOBJN U,SEARC7			;No match, keep trying
	JUMPL U,CPOPJ1			;Found it, skip return
	MOVEI A,(E)			;Point to start of word again
	JRST SEAR5B			;Not found this word, try some more

;;;Try to match pattern against one in SRCBUF

EQSTR:	SETZ B,
EQSTR1:	SKIPN C,SRCBUF(B)		;Get next char
	 RETSKP				;Null, we found a match
	ILDB D,A			;Get next char
	CAIN D,(C)			;Matches?
	 AOJA B,EQSTR1			;Yes, keep trying
	TRC D,(C)			;Try case indept
	CAIE D,40
	 RET				;No good, fails
	AOJA B,EQSTR1			;Yes, keep trying

;;;Convert byte count in V to byte pointer in A

MCH2BP:	ADD V,MSGALL(M)			;Enter here with relative byte count
CHR2BP:	PUSH P,B
	MOVE A,V
	IDIVI A,5
	ADDI A,MSGPAG*1000		;Offset it right
	HRL A,BPS(B)
CPOPBJ:	POP P,B
	RET

;;;Vice versa

BP2MCH:	CALL BP2CHR
	SUB V,MSGALL(M)			;Return relative byte count
	RET

BP2CHR:	LDB C,[POINT 6,A,5]		;Get position field
	MOVEI V,1-MSGPAG*1000(A)	;Clear out bp field
	IMULI V,5
	IDIVI C,7
	SUBI V,(C)
	RET

BPS:	440700
	350700
	260700
	170700
	100700

;;;Parse the rest of this line as addresses from byte pointer in A,
;;;Inserting default host name pointed to by E,
;;;Using free space from FREETO

PRADDR:	MOVE W,FREETO			;Start pointer out right
PRADD0:	SETZ C,				;Not looking for anything
	MOVE V,[-10,,<STRBUF+STRBSZ-11>];Get some room for pdl
	MOVEI U,STRBUF			;Get some random string space
PRAD00:	MOVEI T,(U)			;Save start of address
	HRLI U,(<POINT 7,0>)		;Make byte pointer for storing name
NEWQ,<
	TLZ F,(F%F5!F%AT!F%NEWQ!F%ADR!F%QOT!F%STAD)	;Clear state flags
>;NEWQ
NONEWQ,<
	TLZ F,(F%F5!F%AT!F%ADR!F%QOT!F%STAD)
>;NONEWQ
PRAD01:	ILDB B,A			;Get char
	CAIN B,","
	 JRST PRADD0			;Null address, forget it
	CAIE B,15
	 CAIN B,0
	  JRST ADDTO			;End of this address prematurely, fix things up
	CAIE B,11
	 CAIN B," "
	  JRST PRAD01			;Flush leading white space
	CAIA				;Start with this character

;;;Here is the main parsing loop

PRADD1:	 ILDB B,A			;Get next character
PRAD10:	CAIN B,42			;Start or end of quoted string?
	 JRST PRAD21			;Yes, get rest of it
	CAIN B,15			;Ignore random CR
	 ILDB B,A
	CAIN B,12			;End of line?
	 JRST [	MOVE B,A
		ILDB B,B		;See if continuation
		CAIE B," "
		 CAIN B,11
		  JRST PRADD1		;Continuation, continue parse
		JRST PRADD5]		;End of line, do address
	JUMPE B,PRADD5
	TLNE F,(F%QOT)			;Quoted string?
	 JRST PRAD13			;Just insert all other characters
	TLNE F,(F%STAD)			;In middle of one?
	 JRST PRAD26			;Yes, go check char for balancing
	CAIN B,"{"			;Start of structured address? }
 	 JRST PRAD25			;Yes
	JUMPE C,PRAD11			;Looking for a special character?
	CAIN B,(C)			;Yes, found it?
	 JRST PRAD14			;Yes
	JUMPL C,PRAD11			;Allowed addresses inside?
	CAIN B,"("			;Going in another level?
	 ADDI D,1			;Yes, count it up
	TLNN F,(F%F5)			;Ignoring characters?
	 JRST PRAD12			;No, go ahead and process it
	JRST PRADD1			;Otherwise just toss it out

PRAD11:	CAIN B,","			;End of address?
	 JRST PRADD5			;Yes, finish up
	TLNE F,(F%F5)			;Ignoring characters?
	 JRST PRADD1			;Yes, don't do anything with this one
	CAIN B,"<"			;Start of address after junk?
	 JRST PRAD22			;Yes, set to look for matching >
	CAIN B,":"			;Or filename: junk;?
	 JRST PRAD23			;Yes, look for ;
	CAIN B,"("			;Start of comment?
	 JRST PRAD24			;Yes, look for )
PRAD12:	CAIN B," "			;End of a token?
	 JRST PRADD3			;Yes, check for things like "at"
	CAIN B,"@"			;Start of some hostname?
	 JRST PRADD4			;>
	CAIE B,"<"			;Don't let these filter in
	 CAIN B,";"
	  JRST PRADD1
PRAD13:	CALL PRADPB			;Ordinary character, just stick it in
	TLO F,(F%ADR)			;This address is non-null
	JRST PRADD1			;And on for more

PRAD14:	CAIN B,")"			;Close paren?
	 SOJG D,PRAD11			;If count unexpired, treat as ordinary
	MOVE D,C			;Found matching frob
	POP V,C
	TLZ F,(F%F5)			;Don't ignore any more chars
	TLNE D,200000			;Don't insert char?
	 JRST PRADD1
	JRST PRAD13			;Yes, do so

PRAD21:	TLC F,(F%QOT)			;Complement " state
;;;RFC733 says don't include the quotes
;;;	TLNN F,(F%F5)			;Ignoring characters?
;;;	 CALL PRADPB			;No, stick it in
	JRST PRADD1			;And go get some more
					;< watch these comments just in case
PRAD22:	SKIPA B,[">"]
PRAD23:	 MOVEI B,";"
	PUSH V,C			;Save previous state
	HRROI C,(B)			;Allow nesting with these
	MOVEI U,(T)			;Flush whatever there was before
	JRST PRAD00			;And go re-init all fields

PRAD24:	PUSH V,C
	MOVEI C,")"			;Will look for matching close
	TLOE F,(F%ADR)			;Had anything before?
	 TLOA F,(F%F5)			;Yes, this is a comment, ignore it
	  CAIA				;No, make this address and self-insert
	   TLOA C,200000		;Comments don't insert when done though
	    CALL PRADPB			;Address does
	MOVEI D,1			;Init nesting count
	JRST PRADD1

PRAD25:	TLO F,(F%STAD)			;Starting structured address
	MOVEI D,1			;No, init count
	JRST PRAD13			;Go insert it too

PRAD26:	CAIN B,"{"			;Going deeper?
	 AOJA D,PRAD13			;Yes, count one more and insert
	CAIN B,"}"			;Closing a level?
	 SOSLE D			;This the end?
	  JRST PRAD13			;No or no, just insert character
	TLZ F,(F%STAD)			;No longer within one
	JRST PRAD13

;;;End of a token, check for " at " or @

PRADD3:	PUSH P,A			;Save where we are now
	PUSH P,B			;And the current character
PRAD30:	ILDB B,A			;Get next one
PRAD36:	CAIE B,11
	 CAIN B," "
	  JRST PRAD30			;Flush whitespace
	CAIN B,15			;Ignore random CR
	 ILDB B,A
	CAIN B,12			;Line feed?
	 JRST [	MOVE B,A		;Yes, peek at next character
		ILDB B,A		;Continuation?
		CAIE B,11
		 CAIN B," "
		  JRST PRAD36		;Yes, handle it
		JRST PRAD31]		;Otherwise punt
	CAIN B,"("
	 JRST PRAD32
	CAIN B,"@"
	 JRST PRAD34
	CAIE B,"A"
	 CAIN B,"a"
	  CAIA
	   JRST PRAD31
	ILDB B,A
	CAIE B,"T"
	 CAIN B,"t"
	  CAIA
	   JRST PRAD31
PRAD34:	ILDB B,A			;Allow continuation
	CAIN B,15			;Ignore random CR
	 ILDB B,A
	CAIN B,12			;Line feed?
	 ILDB B,A			;Yes, maybe a continuation line
	CAIE B,11
	 CAIN B," "
	  JRST PRAD33			;Matched, go treat like "@"
PRAD31:	POP P,B				;Get back character that fooled us
	POP P,A				;And byte pointer after it
	JRST PRAD13			;And go treat like normal one
PRAD32:	ADJSP P,-2
	JRST PRAD10
PRAD33:	ADJSP P,-2			;Flush what we saved and enter @ code
	PUSH P,A			;Save current pointer
PRAD35:	ILDB B,A
	CAIE B,11			;Ignore excess whitespace
	 CAIN B," "
	  JRST PRAD35
	CAIN B,15			;Ignore CR too
	 ILDB B,A
	CAIE B,12			;Linefeed?
	 JRST [	POP P,A			;No, assume start of host name
		JRST PRADD4]
	ILDB B,A			;Yes, continuation line?
	CAIE B,11
	 CAIN B," "
	  JRST [ADJSP P,-1		;Yes, update pointer to here
		JRST PRADD4]
	POP P,A				;This is a wierd case

;;;Hairy multiple @ parser

PRADD4:	TLON F,(F%AT)			;An @, have we seen more than one?
	 JRST PRAD43			;No, this is the first
NEWQ,<
	TLO F,(F%NEWQ)			;Remember that this is a hard case
>;NEWQ
	HLRZ D,T			;Get what we thought was the hostname
	HRLI D,(<POINT 7,0>)		;Make byte pointer
	SKIPA B,["@"]			;Join the two with an @
PRAD41:	 ILDB B,D			;Get next char from old hostname
	CAMN D,U			;Got to end (where we are now before)
	 JRST PRAD42			;Yes, have appended them
	IDPB B,SAVU
	JRST PRAD41

PRAD42:	IDPB B,SAVU
	SKIPA U,SAVU
PRAD43:	 MOVEM U,SAVU
	MOVEI B,0
	IDPB B,U			;Stick a null onto end of address
	MOVEI U,1(U)			;Point to next word
	HRLI T,(U)			;This will be the start of the hostname
	HRLI U,(<POINT 7,0>)
	JRST PRAD01

;;;Here when we have finished parsing the address, stick in any host default
;;;and build up the final block

PRADD5:	PUSH P,A			;Save byte pointer
	CAIE B,","
	 TLZA F,(F%COMA)
	  TLO F,(F%COMA)
PRAD50:	LDB B,U				;Flush trailing whitespace
	CAIE B," "
	 CAIN B,11
	  JRST [ADD U,[7B5]
		SKIPGE U
		 SUB U,[43B5+1]
		JRST PRAD50]
	SETZ B,
	IDPB B,U			;End with null
	MOVEI U,(W)
	MOVEM U,SAVU			;In case of final parse error
	MOVEI A,4(W)
	HRLI A,(<POINT 7,0>)
	MOVEI B,(T)
	CALL MOVST0			;Move in user name
	MOVEI A,1(A)			;Point to next free word
	SUBM A,W			;Get length
	EXCH A,W
	HRLZM A,(U)
	SETZM 1(U)
	SETZM 3(U)
	TLNE F,(F%AT)			;Host name seen?
	 JRST PRAD54			;Yes, handle network recipient
	SKIPE C,E			;Was there a default host?
	 JRST PRAD52			;Yes, use it then
PRAD51:	TLZ F,(F%AT)			;Pretend no @ was there, for PRTOCC
	MOVSI A,(RC%EMO)
	HRROI B,(T)			;User name
	RCUSR
	 ERJMP [MOVEI B,[ASCIZ/address/]
		MOVEI C,(T)
		JRST PRAD56]
	TLNE A,(RC%NOM!RC%AMB)		;Bad local user?
	 JRST [	MOVE A,[POINT 7,(T)]
		CALL CHKFWD		;Try forwarding
		 JRST PRAD55		;Not found, complain and flush it
		SKIPN HSTPTR		;Make sure host table present
		 CALL HSTINI
NOHST2,<
		MOVE C,LHOSTN		;Get host number
>;NOHST2
HOSTS2,<
		MOVE C,LHOSTP		;Get host string pointer
>;HOSTS2
		JRST PRAD52]
	TDZA A,A			;Local recipient
PRAD52:	 MOVEI A,2			;Network recipient
	DPB A,[POINT 9,(U),8]		;Store type field
	MOVEM C,2(U)			;And host/user number
PRAD53:	POP P,A				;Get back byte pointer
	TLNE F,(F%COMA)			;Unless end of line
	 JRST PRADD0			;Get next one as well
	RET				;All done, return

PRAD54:	SKIPN A,HSTPTR
	 CALL HSTINI
	HLRO B,T			;Host name
	TBLUK
	TLNE B,(TL%NOM!TL%AMB)		;Bad host name?
	 JRST PRAD57
	HRRZ C,(A)
NOHST2,<
	MOVE C,(C)			;Get host number
	CAMN C,LHOSTN			;Really local?
>;NOHST2
HOSTS2,<
	HLRZ C,(C)			;Get pointer to official host name
	CAMN C,LHOSTP			;Really local?
>;HOSTS2
	 JRST PRAD51
NEWQ,<
	TLZN F,(F%NEWQ)			;More than one host?
>;NEWQ
	 JRST PRAD52

NEWQ,<
;; If there was more than one host, maybe we can flush the route given
	MOVEI V,4(U)			;Point to start of user
	HRLI V,(<POINT 7,0>)
	MOVEI T,-1(W)
	HRLI T,(<POINT 7,0,34>)		;Point to end of hosts
PRAD58:	ADD T,[7B5]
	CAMN T,V			;Reached end?
	 JRST PRAD52			;Yes, done then
	JUMPGE T,.+2
	 SUB T,[43B5+1]
	LDB D,T				;Get character
	CAIE D,"@"
	 JRST PRAD58
	MOVE A,HSTPTR
	MOVE B,T			;See if we know this host
	PUSH P,C
	TBLUK
	POP P,C
	TLNE B,(TL%NOM!TL%AMB)		;Matched ok?
	 JRST [	DPB D,T			;Put back in @
		JRST PRAD52]		;And forget it
	SETZ D,				;Truncate user name
	DPB D,T
	HRRZ C,(A)			;A winner, save new host
	HLRZ C,(C)			;Get pointer to official host name
	CAME C,LHOSTP			;Really local?
	 JRST PRAD58
	MOVE T,V			;Put username pointer in T for PRAD51
	JRST PRAD51
>;NEWQ

PRAD55:	MOVEI B,[ASCIZ/local user/]
	MOVEI C,(T)
PRAD56:	TLNN F,(F%F4)			;Unless silence requested
	 CIETYP < No such %2S as "%3S", address flushed>
	MOVE W,SAVU
	JRST PRAD53

PRAD57:	MOVEI B,[ASCIZ/host/]
	HLRZ C,T
	JRST PRAD56

;;;Deposit header byte into buffer after checking for overflow (some insanely
;;;long header, etc.)
PRADPB:	PUSH P,B			;Save character
	HRRZ B,U
	CAIL B,STRBUF+STRBSZ-20		;Beyond a reasonable maximum?
	 JRST [	ADJSP P,-1		;Yes, ignore request
		RET]
	POP P,B
	IDPB B,U
	RET

;;;Get To and cc lists from message

PRTOCC:	SETZ E,				;Assume default
	TLNN F,(F%AT)			;Was there an @ in the main name?
	 JRST PRTO10
	MOVE E,TOLIST
	MOVE E,2(E)			;Yes, get default host number then
PRTO10:	SKIPE RCCOTH			;Make everybody cc?
	 TLOA F,(F%CC)			;Yes, do this from the start
	  TLZ F,(F%CC)			;Not in CC yet
PRTO11:	CALL PRADDT			;Parse this line
	LDB B,A				;Get terminating character
	JUMPE B,CPOPJ			;Null means all done now
	CAIN B,15			;Was it a CR?
	 IBP A				;Yes, move over the LF too
PRTO12:	ILDB B,A			;Get next char
	JUMPE B,CPOPJ
	CAIE B,11			;Whitespace indicates continuation
	 CAIN B," "
	  JRST PRTO11
	JRST PRTO15			;Look for To/cc

PRTO14:	ILDB B,A			;Here if don't allow continuation
	JUMPE B,CPOPJ			;Punt if done
PRTO15:	CAIE B,"T"			;More to maybe
	 CAIN B,"t"
	  JRST PRTO20
	CAIE B,"C"			;Or maybe start of cc
	 CAIN B,"c"
	  JRST PRTO30
	CAIN B,15			;Look like CR?
	 ILDB B,A			;Yes, get the LF?
	CAIN B,12			;Blank line?
	 RET				;Yes, done with headers
PRTO13:	ILDB B,A			;Otherwise soak up line
	CAIN B,12			;Saw linefeed yet?
	 JRST PRTO14			;Yes, try this line (no continuation)
	JUMPN B,PRTO13			;Keep on going unless EOM
	RET

PRTO20:	ILDB B,A
	CAIE B,"O"
	 CAIN B,"o"
	  CAIA
	   RET
	ILDB B,A
	CAIE B,":"
	 RET				;No good I guess
	JRST PRTO11			;Get rest of this line then

PRTO30:	ILDB B,A
	CAIE B,"C"
	 CAIN B,"c"
	  CAIA
	   RET
	ILDB B,A
	CAIE B,":"
	 RET
	TLO F,(F%CC)			;Now doing cc
	JRST PRTO11			;And now go get more

;;;Add new recipients to the appropriate lists

ADDTO:	 TLNE F,(F%CC)
	  SKIPA T,[CCLIST]
	   MOVEI T,TOLIST
ADDTO0:	HRRZ U,FREETO
	HRRZM W,FREETO			;Update free pointer now
ADDTO1:	CAIN U,(W)			;Got to where we left off?
	 RET				;Yes, done
	LDB B,[POINT 4,(U),8]		;Get type field
	MOVEI B,LCLIST(B)
	CALL ADDLST			;Add into transmission medium list
	 JRST ADDTO2			;Duplicate entry
	SKIPN (T)			;This the first entry?
	 HRRM U,(T)			;Yes, store it as head then
	HLRZ B,(T)			;Get old tail
	SKIPE B
	 HRRM U,(B)			;Link to old tail
	HRLM U,(T)			;This is new tail
ADDTO2:	LDB B,[POINT 9,(U),17]		;Get size
	ADDI U,(B)
	JRST ADDTO1

;;;Thread block in U into list in B

ADDLST:	MOVE C,2(U)
	SKIPN V,(B)
	 JRST ADDLS5			;Empty list, this is where it goes
ADDLS1:	CAMG C,2(V)
	 JRST ADDLS4
	HRRZ D,1(V)			;Get next element of list
	JUMPE D,ADDLS2			;None there, put on end of list
	MOVEI V,(D)
	JRST ADDLS1

ADDLS2:	HRRM U,1(V)			;Add this to end of list
ADDLS3:	HRLM V,1(U)			;Link to previous
	RETSKP

ADDLS4:	CAIN B,LCLIST
	 CAME C,2(V)			;Local user matches exactly?
	  SKIPA D,V
	   RET				;Yes, flush it
	HRRM V,1(U)			;Link to next
	HLRZ V,1(V)			;Get previous
	HRLM U,1(D)			;Link to previous
	JUMPN V,ADDLS2
ADDLS5:	HRRM U,(B)			;No previous, store this at the end
	RETSKP

;;;Remove element in W from transmission medium list

REMLST:	HLRZ A,1(W)			;Link to previous this medium
	HRRZ B,1(W)			;Link to next this transmission medium
	SKIPE B				;Unless tail of list...
	 HRLM A,1(B)			;New link to previous for next element
	SKIPE A				;Unless head of list...
	 HLRM B,1(A)			;New link to next for previous element
	JUMPN A,REMLS1			;If this was the head of the list
	LDB A,[POINT 4,(W),8]		;Get transmission medium type
	HRRM B,LCLIST(A)		;Set as starting pointer
	RET

REMLS1:	HRRM B,1(A)			;Link as next
	RET

SUBTTL Message handling subroutines

;;;Type out header of a message

.RHEAD:	CONFRM				;Type header of current message
TYPHDR:	CALL CRIF			;Get a fresh line
	MOVE O,[POINT 7,WRTPGS]		;Place to put the string
	CALL TYPHD0
	HRROI A,WRTPGS			;Now type it out
	PSOUT
	RET

;;;Stick the header for a message into the string in O

TYPHD0:	MOVE T,MSGBTS(M)		;Get messages bits
	SKIPL MSGFLG(M)
	 JRST TYPH0A
	MOVEI A,"R"			;Recent
	TRON T,M%SEEN			;Unseen as well (o so no U later)
	 TRCA A,<"N"!"R">-<"N"&"R">	;Yes, is new then
TYPH0A:	  MOVEI A," "
	IDPB A,O
	TRNE T,M%SEEN
	 SKIPA A,[" "]
	  MOVEI A,"U"			;Unseen
	IDPB A,O
	TRNN T,M%ATTN			;Flagged
	 SKIPA A,[" "]
	  MOVEI A,"F"
	IDPB A,O
	TRNN T,M%RPLY			;Answered
	 SKIPA A,[" "]
	  MOVEI A,"A"
	IDPB A,O
	TRNN T,M%DELE
	 SKIPA A,[" "]
	  MOVEI A,"D"			;Deleted
	IDPB A,O
	MOVE A,O
	MOVEI B,MSGLEN(M)		;Message number
	IDIVI B,MSGLEN
	MOVE C,[NO%LFL+3B17+^D10]
	NOUT
	 NOP
	MOVEI B," "
	IDPB B,A
	PUSH P,A
	SKIPG B,MSGDAT(M)		;Date
	 JRST [	DMOVE T,[ASCIZ/      /]	;Fill with spaces if not there
		JRST TYPHD2]
	HRROI A,T			;Where to stick string
	MOVSI C,(OT%NTM)
	ODTIM
	TLZ U,(<BYTE (7) 0,177>)	;Clear out year and anything else
TYPHD2:	MOVE A,(P)
	MOVEI B,T
	CALL MOVSTR
	MOVEM A,(P)
	CALL FRMMEP			;Check if message is from me or not
	 MOVE A,MSGFRM(M)		;Isnt, show from field
	MOVEI B,^D20			;Limited to 20 chars
	SKIPE KEYTBL			;If have keywords, make a little shorter
	 MOVEI B,^D15
	POP P,O				;Get back string pointer
	CALL TYPHDS
	JUMPE B,TYPHD3			;None more needed
	MOVEI A," "
	IDPB A,O
	SOJG B,.-1			;Fill with spaces
TYPHD3:	HLLZ A,MSGBTS(M)		;Relevant keyword flags
	CALL KEYSTR			;Insert string for that
	MOVE A,MSGSUB(M)		;Subject field
	MOVEI B,^D30			;Limited to 30 chars
	SUBI B,(T)			;Less what we used for keywords
	CALL TYPHDS
	MOVE A,O
	MOVEI B,[ASCIZ/ (/]
	CALL MOVSTR
	HLRZ B,MSGBOD(M)		;Length of message
	MOVEI C,^D10
	NOUT
	 NOP
	MOVEI B,[ASCIZ/ chars)
/]
	CALL MOVST0
	ADD A,[7B5]			;Return pointer before null
	SKIPG O,A
	 SUB A,[43B5+1]
	RET

TYPHDS:	MOVEI D," "
	IDPB D,O
	JUMPE A,CPOPJ			;Nothing there to type
	HRRZ V,A			;Start of field
	HLRZ C,A			;Length
	JUMPE C,CPOPJ
	CAILE C,(B)			;Or truncate
	 MOVEI C,(B)
	SUBI B,(C)			;Get number of chars needed to fill
	CALL MCH2BP			;Get byte pointer
TYPHS1:	ILDB D,A
	IDPB D,O
	SOJG C,TYPHS1	
	RET

;;;Check if message is from me, and setup to type out To: field if so

FRMMEP:	MOVE A,MSGFLG(M)
	TLNE A,(M%FRME!M%FRNM)		;See if we have done this before
	 JRST FRMME2			;Yes, we have, don't need to check
	HRRZ V,MSGFRM(M)
	JUMPE V,FRMME1			;Don't know who it's from
	CALL MCH2BP
	SETZ E,				;No host name defaulting
	PUSH P,F			;Save all flags
	MOVEI W,TOPAG
	SKIPN FREETO			;Make sure have some free space to
	 MOVEM W,FREETO			; work with
	TLO F,(F%F4)			;Don't type error messages
	CALL PRADDR			;Get the guy, but don't add to anything
	POP P,F
	MOVE W,FREETO			;Get the address just added
	HRROI A,MYDIRS
	HRROI B,4(W)
	STCMP
	JUMPN A,FRMME1			;Not from me
	SKIPA A,[M%FRME]		;Yes, from me
FRMME1:	 MOVSI A,(M%FRNM)		;Not from me
	IORB A,MSGFLG(M)
FRMME2:	TLNN A,(M%FRME)			;From me?
	 RET				;No, single return to use from field
	MOVEI T,[ASCIZ/
To: /]
	CALL FNDSB4
	HRREI A,-4(V)			;Include length of "To: "
	JUMPL A,CPOPJ			;Didnt find to, still need from
	HRLI A,4(W)
	RETSKP

;;; Translate bits into string, byte pointer in O, bits in A, returns bytes output in T
KEYSTR:	TLZ F,(F%COMA)
	SETZ T,				;Init count
KEYST1:	JFFO A,KEYST2			;{
	MOVEI C,"}"
	TLZE F,(F%COMA)			;Anything output?
	 IDPB C,O			;Yes, finish it up
	RET
KEYST2:	MOVSI C,400000
	MOVN D,B
	LSH C,(D)
	XOR A,C				;Clear out the bit in question
	HLRZ C,KEYTBL			;Number of entries in table
	MOVEI D,KEYTBL+1		;Start of table
KEYST3:	SOJL C,KEYST1			;Failed to find anything, forget it
	HRRZ E,(D)			;Get number for this frob
	CAIE E,(B)			;Matches?
	 AOJA D,KEYST3			;Keep looking
	TLON F,(F%COMA)
	 JRST [	MOVEI C," "
		IDPB C,O
		MOVEI C,"{"		;}
		AOJA T,KEYST4]
	MOVEI C,","
	IDPB C,O			;Start list or insert comma
	MOVEI C," "
KEYST4:	IDPB C,O
	ADDI T,2			;", " or "{}"
	HLRZ D,(D)
	HRLI D,(<POINT 7,0>)
KEYST5:	ILDB C,D
	JUMPE C,KEYST1
	IDPB C,O
	AOJA T,KEYST5

;;;Type out a message

.LRTYP:	SKIPG MSGJFN
	 ERROR (No current file)
	CONFRM				;Confirm first
	CALLRET TYPMSL

.TYPMS:	SKIPG MSGJFN
	 ERROR (No current file)
	CONFRM				;Confirm first
TYPMSG:	TLZA F,(F%F5)			;Normal filtering
TYPMSL:	 TLO F,(F%F5)			;Literally from message
	HLRZ C,MSGBOD(M)		;Length of message
	CIETYP < Msg %M (%3D chars) -- >
	MOVN C,C
	HRRZ V,MSGBOD(M)
	CALL MCH2BP
	MOVE B,A
	TLNE F,(F%F5)			;Unless literal headers requested
	 JRST TYPMSS
	SKIPN SPRHDR			;Any suppressed headers?
	 SKIPE ONLHDR			;Or only certain ones?
	  JRST TYPSHD			;Yes, process the slow way then
TYPMSS:	MOVEI A,.PRIOU
	SOUT				;Print the message out
TYPMSM:	MOVEI A,M%SEEN			;Mark message as seen
	IORM A,MSGBTS(M)
	CALLRET UPDBIT			;And maybe update

;;;Type out the headers not in the suppressed list only, count in C, bp in B
TYPSHD:	TLZ F,(F%F5)			;Clear state flag
TYPSH0:	ILDB D,B			;Get first character of line
	CAIN D,15			;Start of blank line?
	 JRST [	ADD B,[7B5]		;Yes, back over it
		JRST TYPMSS]		;And type rest of message
	SETZ E,				;Reset pointer to :
	CAIE D,40			;Space
	 CAIN D,11			;Or tab is continuation line
	  ADDI E,1			;Remember this specially
	SKIPA A,[POINT 7,STRBUF]	;Save header here
TYPSH1:	 ILDB D,B			;Get next character
	AOJGE C,TYPMSM			;Nothing but headers
	IDPB D,A			;Stick it in
	JUMPN E,TYPSH2			;Unless already saw a :
	CAIN D,":"			;If this is one
	 SKIPA E,A			;Remember it's position
TYPSH2:	CAIE D,12			;End of a line?
	 JRST TYPSH1			;No, continue accumulating
	SETZ D,				;See if this is a losing header
	IDPB D,A			;Make line end with null
	JUMPE E,TYPSH3			;Didnt see a :, type the line out
	CAIN E,1			;Continuation line?
	 JRST TYPSH4			;Yes, check against last case
	DPB D,E
	PUSH P,B			;Save current pointer
	HRROI B,STRBUF
	PUSH P,C
	SKIPE ONLHDR			;Have headers to type out explicitly?
	 JRST [	MOVEI A,ONLHDR
		TBLUK
		TLNE B,(TL%NOM!TL%AMB!TL%ABR)	;Complement the flags,
		 TDZA A,A		;if no match, say it matched
		  MOVSI A,(TL%NOM)
		JRST TYPSH5]
	MOVEI A,SPRHDR
	TBLUK				;Look for it
	HLLZ A,B			;Get result flags
TYPSH5:	POP P,C
	POP P,B
	TLNN A,(TL%NOM!TL%AMB!TL%ABR)	;One we know to flush?
	 TLOA F,(F%F5)			;Yes, remember we flushed it
	  TLZA F,(F%F5)			;No, will print it
	   JRST TYPSH0			;Handle next line
	MOVEI D,":"			;Put back in the :
	DPB D,E
TYPSH3:	HRROI A,STRBUF
	PSOUT				;Type out a winning line
	JRST TYPSH0			;And continue to next one
TYPSH4:	TLNE F,(F%F5)			;Continuation line, last one flushed?
	 JRST TYPSH0			;Yes, flush this too
	JRST TYPSH3			;No, type this part too

CHKDEL:	MOVEI A,M%DELE
	TDNN A,MSGBTS(M)		;Deleted?
	 RETSKP				;No, skip return
	CIETYP < Msg %M deleted.
>
	RET				;Single return

;;;Type out headers of recent messages

RECENT:	TLO F,(F%F1)			;Say type headers
RECEN0:	SETZB M,NRECNT
	SETZM NUNSEE
	SETZM NDELET
RECEN1:	SKIPLE B,MSGDAT(M)		;Get recv date of message
	 CAMG B,LASTRD			;Check against last read date
	  JRST RECEN4
	MOVSI A,(M%RECE)		;Bit to set if recent
	IORM A,MSGFLG(M)		;Say it's recent
	AOS NRECNT			;Count one more
	TRNN F,F%MOD			;If system mail
	 JRST RECEN2
	MOVEI A,M%SEEN
	ANDCAM A,MSGBTS(M)		;Make all recent unseen
RECEN2:	TLNE F,(F%F1)			;Want headers
	 CALL TYPHDR			;Yes, tell him what it's about
RECEN3:	MOVE A,MSGBTS(M)
	TRNN A,M%SEEN			;Count unseen and deleted messages
	 AOS NUNSEE
	TRNE A,M%DELE
	 AOS NDELET
	CAMGE M,LASTM			;Thru with all msgs?
	 JRST [	ADDI M,MSGLEN
		JRST RECEN1]		;No
	MOVE A,NRECNT
	IMULI A,MSGLEN
	SKIPE M				;Unless all messages are new,
	 SUBI M,(A)			;Set current msg to last non-recent
	MOVNI A,MSGLEN			;Set prior M to -1 in case all new
	MOVEM A,PRIORM
	RET

RECEN4:	TRNE F,F%MOD			;If doing system mail
	 JRST RECEN5			;Make sure not seen by us either
	MOVEI A,M%ATTN			;Flagged (always-show)?
	TDNN A,MSGBTS(M)
	 JRST RECEN3			;No, don't do it then
	JRST RECEN2			;Yes, type it anyway

RECEN5:	MOVEI A,M%SEEN
	IORM A,MSGBTS(M)		;Make all old messages seen
	JRST RECEN3

;;;Type out summary of the current file

SUMMRY:	MOVE A,LASTM			;Get number of messages
	IDIVI A,MSGLEN
	AOS D,A
	MOVEI B,[ASCIZ/Last read: %3T/]
	TRNE F,F%MOD			;Special message for system mail
	 MOVEI B,[ASCIZ/Last login: %3T/]
	SKIPG C,LASTRD			;Last read date
	 MOVEI B,[ASCIZ/Never read/]
	SUB D,NRECNT			;Number of old messages
	SKIPN NRECNT
	 TDZA E,E
	  MOVEI E,[ASCIZ/ (%4D old)/]
	HRRZ T,FILPGS			;Number of pages
	CETYPE < %2S, %1D msg%1P%5S, %6D page%6P>
	MOVE T,NUNSEE
	SUB T,NRECNT
	SKIPG T
	 TDZA E,E
	  MOVEI E,[ASCIZ/ %6D message%6P unseen/]
	SKIPG D,NDELET
	 TDZA C,C
	  JRST [MOVEI C,[ASCIZ/; %4D deleted/]
		SKIPG T
		 MOVEI C,[ASCIZ/ %4D message%4P deleted/]
		JRST .+1]
	CETYPE (%5S%3S)
	RET

;;;Update the file copy of the message bits, unless in read command

UPDBIT:	TRNE F,F%RONL
	 RET				;In which case noop

;;;Insist on update, even in read mode

UPDBT0:	MOVE B,MSGBTS(M)		;Get new copy of bits
	TRNN F,F%MOD!F%RONL		;Don't try to munge system mail
	 CAMN B,MSGFBS(M)		;Old matches new?
	  RET				;Yes, no need to do any more
	CALL GETJF2			;Get a second JFN if don't already
	 RET				;Failed
	MOVE V,MSGALL(M)		;Start of the message header
	CALL CHR2BP			;Get byte pointer
UPDBT1:	ILDB B,A			;Get char
	CAIN B,15			;At end of line??
	 ERROR (File has bad format: unable to find message flag field)
	CAIE B,";"			;At start of bits?
	 JRST UPDBT1
	SUBI A,MSGPAG*1000		;Get absolute pointer
	TLNN A,760000			;Make sure point to correct first word
	 ADD A,[43B5+1]
	PUSH P,A			;Save that pointer
	ANDI A,-1
	IDIVI A,1000			;Get page number we need
	HRL A,MSGJF2
	CAIL B,775			;If near end of page
	 SKIPA C,[PM%CNT+PM%WR+PM%RD+2]	;Map two pages
	  MOVSI C,(PM%WR!PM%RD)
	MOVE B,[.FHSLF,,WRTPGS/1000]
	PMAP

	POP P,A				;Get back byte pointer
	TRZ A,777000			;Just relative to page
	ADDI A,WRTPGS			;Offset right
	MOVE B,MSGBTS(M)		;Bits to set out
	MOVE C,[NO%MAG+NO%LFL+NO%ZRO+14B17+^D8]
	NOUT				;Write them out
	 NOP
	MOVEI C,15			;Kill the null
	IDPB C,A			;With a CR
	MOVEM B,MSGFBS(M)		;This is now the file version
	SETO A,
	MOVE B,[.FHSLF,,WRTPGS/1000]
	MOVE C,[PM%CNT+2]
	PMAP				;Unmap the pages
CLSJF2:	HRLZ A,MSGJF2			;JFN,,first file page
	MOVEI B,777			;Update all pages
	UFPGS
	 JWARN (File update failed)
	HRRZ A,MSGJF2
	TLO A,(CO%NRJ)			;Keep this JFN around
	CLOSF
	 NOP
	HRRZ A,MSGJF2
;	CALLRET SETREF			;Set read date to now

SETREF:	TRNE F,F%RONL			;Never set reference date if read-only
	 RET
	MOVE C,A			;Save JFN
IFN EXBUGF,<
;  The standard DEC EXEC has a bug where it considers mail files whose write
; and reference dates are equal to have new mail.  The bug is a CAMLE C,D at
; MALCH2-3 - it should be a CAML.  Here we go and make sure we "now" is one
; GTAD unit in the future from the last write
	MOVEI A,^D330			;GTAD units are 329.59ms apart
	DISMS
>;IFN EXBUGF
	GTAD				;Set read date to now 
	EXCH C,A			;Get back JFN
	HRLI A,.FBREF
	SETO B,				;Cause we are going to reparse
	CHFDB
	 ERJMP .+1			;Maybe no access, don't worry
	RET				;Done

GETJF2:	SKIPLE A,MSGJF2			;Have one already?
	 JRST GETJ2A			;Yes, use it
	HRROI A,FILNAM
	MOVE B,MSGJFN			;One we do have
	SETZ C,
	JFNS
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,FILNAM
	GTJFN
	 JERROR (Can't get second handle on file)
	MOVEM A,MSGJF2			;Save JFN
GETJ2A:	MOVE B,[7B5+OF%RD!OF%WR]	;Open file for write as well (it is
	OPENF				;now write-locked against new msgs).
	 JRST [	TRON F,F%RONL		;Can't open for write, now read only?
		 JWARN (Can't open for write)
		RET]
	CALL CHECKT			;Get size and new msgs, now
					;That file is locked
	HRRZ A,MSGJF2			;Return value
	RETSKP

SUBTTL Message sequence subroutines

;;;Get sequence, default to current message

DFSQTH:	SKIPA A,[[ASCIZ/CURRENT/]]	;Setup default number to this message
DFSQNW:	 MOVEI A,[ASCIZ/UNSEEN/]	;Default to unseen
	CALLRET DFSQA1

DFSQRC:	SKIPA A,[[ASCIZ/RECENT/]]	;Default to recent
DFSQAL:	 MOVEI A,[ASCIZ/ALL/]		;Default to all messages
DFSQA1:	SKIPG MSGJFN			;Must have a file
	 ERROR (No current file)
	UDEF (A)			;This is the default
	CALLRET GETSEQ

STQALL:	CONFRM				;All messages = 1:n
	MOVE A,LASTM
	IDIVI A,MSGLEN
	LSH A,^D12
	IOR A,[BYTE (12) 0,2000,3777]
	MOVEM A,MSGSEQ
	CALLRET GTSQNS

STQPRV:	CONFRM				;Previous-sequence
	SKIPN NXTMSD			;Was there a previous sequence?
	 ERROR (No previous sequence)
	SKIPG NXTMSD			;Still valid?
	 ERROR (Previous sequence clobbered)
	CALLRET GTSQNS			;Handle like numeric sequence

STQREV:	SKIPA A,[NXTREV]		;Reverse order
STQDEL:	 MOVEI A,NXTDEL			;Deleted
STQDL0:	MOVEM A,NXTMSD
	CONFRM
STQDL1:	MOVNI M,MSGLEN			;Init search before start of messages
	RET

STQREC:	SKIPA A,[NXTREC]		;Recent
STQUND:	 MOVEI A,NXTUND			;Undeleted
	CALLRET STQDL0

STQNEW:	SKIPA A,[NXTNEW]		;New
STQSEE:	 MOVEI A,NXTSEE			;Seen
	CALLRET STQDL0

STQFLG:	SKIPA A,[NXTFLG]		;Flagged
STQUNF:	 MOVEI A,NXTUNF			;Unflagged
	CALLRET STQDL0

STQANS:	SKIPA A,[NXTANS]		;Answered
STQUNA:	 MOVEI A,NXTUNA			;Unanswered
	CALLRET STQDL0

STQTHS:	HRROM M,LSTMSG			;This message, save current number
	SKIPA A,[NXTTHS]
STQUNS:	 MOVEI A,NXTUNS			;Unseen
	CALLRET STQDL0

STQLST:	NOISE (NUMBER OF MESSAGES)
	MOVEI B,[FLDDB. .CMNUM,,^D10,,<POINT 7,[ASCIZ/1/]>]
	CALL CMDFLD			;Get a number
	JUMPLE B,BADNUM			;Must be positive number
	CAIN B,1			;Just one?
	 JRST STQLS1			;Last one message
	MOVE C,LASTM
	IDIVI C,MSGLEN
	SUBM C,B			;Starting message of sequence
	AOJL B,BADNUM			;Number out of range
	CALL GTSQLC			;Put that in as the start
	MOVEI B,2000(C)			;Last message as end of sequence
	CALLRET STQLS2			;And go handle that sequence

STQCUR:	JUMPL M,[ERROR (No current sequence)]
	SKIPA B,M			;Current message
STQLS1:	 MOVE B,LASTM			;Just last message
	IDIVI B,MSGLEN
STQLS2:	CALL GTSQLC			;Save on list
	CONFRM				;Guarantee EOL
	CALLRET GTSQNR			;Done with list

STQTO:	SKIPA X,[NXTTO]			;Match to string
STQFRM:	 MOVEI X,NXTFRM			;Match from string
	CALLRET STQSB0			;Common routine to get pattern

STQTXT:	SKIPA X,[NXTTXT]		;Match text substring
STQSBJ:	 MOVEI X,NXTSBJ			;Match subject string
STQSB0:	NOISE (STRING)
	CALL GETLIN			;Read a line from the user
	HRROI B,STRBUF			;Copy string to pattern buffer
	HRROI A,PATSTR
	SETZ C,
	SOUT
STQSB1:	MOVEI A,(X)			;Routine addrs
	CALLRET STQDL0

STQBEF:	SKIPA X,[NXTBEF]		;Before date
STQAFT:	 MOVEI X,NXTAFT			;After date
	CALLRET STQON1

STQON:	MOVEI X,NXTON			;On date
STQON1:	NOISE (DATE)
	CALL GETDAT
	MOVEM B,NXTIME
	CALLRET STQSB1

STQKEY:	SKIPA X,[NXTKEY]		;Keyword
STQUNK:	 MOVEI X,NXTUNK			;Unkeyword
	CALL GETKEY
	HLLM U,KEYBTS			;Save bits
	CALLRET STQSB1

;;;Get the next message in this sequence and maybe type out its number

NXTMSG:	CALL @NXTMSD			;Get next
	 JRST NXTMS6			;All done, finish up
	AOS (P)				;Skip return when done
	MOVEI A,NXTSEQ			;Already a numeric sequence?
	CAMN A,NXTMSD
	 JRST NXTMS2			;No, return with message
	MOVEI A,(M)			;Copy of new current message
	IDIVI A,MSGLEN
	JUMPL L,NXTMS1			;Always start new when beginning
	LDB B,L				;Get last one out
	TRZN B,2000			;Already a range?
	 HRROS B			;No, must use next slot
	CAIN A,1(B)			;Next in numeric order?
	 TROA A,2000			;Yes, construct a range
	  CAIA
	   JUMPGE B,[DPB A,L		;Put it in place
		     JRST NXTMS2]
NXTMS1:	IDPB A,L			;Use next slot
NXTMS2:	TLNN F,(F%TYPS)			;Want to type out numbers?
	 RET				;No, all done
	SKIPGE A,LSTMSG			;Any last message?
	 JRST NXTMS5			;No, install this one then
	CAIN M,MSGLEN(A)		;Yes, is this one the next one?
	 JRST NXTMS4			;Yes, keep accumulating
	CALL PRTSEQ			;Print what is there now otherwise
NXTMS3:	HRLM M,LSTMSG			;And set ourselves up as start
NXTMS4:	HRRM M,LSTMSG			;Set ourselves up as next link in chain
	RET

NXTMS5:	TLZ F,(F%COMA)			;Reset comma flag
	JRST NXTMS3

NXTMS6:	MOVEI A,NXTSEQ
	MOVEI B,3777
	CAME A,NXTMSD
	 IDPB B,L			;Mark end of sequence if we generated one
	TLNE F,(F%TYPS)			;Finishing up, type last number?
	 SKIPG LSTMSG			;And have non-empty sequence
	  RET				;No, done
PRTSEQ:	TLOE F,(F%COMA)			;Maybe a comma first
	 PRINT ","
	PRINT " "
	MOVEI A,.PRIOU
	HLRZ T,LSTMSG			;Get start of sequence
	MOVEI B,MSGLEN(T)
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 NOP
	HRRZ B,LSTMSG			;Get end
	CAIN B,(T)			;Same?
	 RET				;Yes, that's it
	PRINT ":"
	ADDI B,MSGLEN
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 NOP
	RET

;;;Get next message selecting routines

NXTTHS:	JUMPGE M,CPOPJ			;Already did it, done now
	HRRZ M,LSTMSG			;Else get it
	RETSKP				;And skip return

NXTSEQ:	SKIPE A,RPVSAV			;Have a recorded backtrack?
	 CAIE M,(A)
	  CAIA
	   JRST [SETZM RPVSAV
		 HLRZM A,NXTMSD		;Yes, unwound back to where we were
		 JRST @NXTMSD]		;Reenter old mode
	JUMPL L,NXTSQ1			;Always get it at start
	LDB A,L				;Get last one
	TRZN A,2000			;Part of range?
	 JRST NXTSQ1			;No, get next byte then
NXTSQ0:	IMULI A,MSGLEN
	CAIGE M,(A)			;Before end of range?
	 JRST [	ADDI M,MSGLEN
		RETSKP]			;Yes, increment toward it
	CAIE M,(A)			;At end of range?
	 JRST [	SUBI M,MSGLEN
		RETSKP]			;No, decrement toward it
NXTSQ1:	ILDB A,L			;Get next byte
	CAIN A,3777			;End?
	 RET				;Yes, single return
	TRZE A,2000
	 JRST NXTSQ0
	IMULI A,MSGLEN
NXTSQ2:	MOVEI M,(A)			;No, this is next message
	RETSKP				;Skip return

NXTANS:	SKIPA B,[M%RPLY]		;Answered
NXTSEE:	 MOVEI B,M%SEEN			;Seen => seen bit set
	CALLRET NXTDL0

NXTFLG:	SKIPA B,[M%ATTN]		;Flagged
NXTDEL:	 MOVEI B,M%DELE			;Deleted
NXTDL0:	SKIPA C,[TDNE B,MSGBTS(A)]	;Bit must be set
NXTREC:	 MOVE C,[SKIPGE MSGFLG(A)]	;Recent
	CALLRET NXTAL0

NXTUNA:	SKIPA B,[M%RPLY]		;Unanswered
NXTUNF:	 MOVEI B,M%ATTN			;Unflagged
	CALLRET NXTUD0

NXTUNS:	SKIPA B,[M%SEEN]		;Unseen => seen bit clear
NXTUND:	 MOVEI B,M%DELE			;Undeleted
NXTUD0:	SKIPA C,[TDNN B,MSGBTS(A)]	;Bit must be clear
NXTALL:	MOVSI C,(<NOP>)			;All => pass all thru
NXTAL0:	MOVEI A,MSGLEN(M)		;Start here
NXTAL1:	CAMLE A,LASTM			;Done?
	 RET				;Yes, return
	XCT C				;Test it out
	 JRST NXTSQ2			;Matches
	ADDI A,MSGLEN
	JRST NXTAL1			;No good, try next one

NXTREV:	JUMPGE M,NXTRV1			;First time here?
	HRRZ A,LASTM			;Yes - start at end
	JRST NXTSQ2

NXTRV1:	HRREI A,-MSGLEN(M)		;Try next
	JUMPGE A,NXTSQ2			;Keep going till all done
	RET

NXTNEW:	MOVEI A,MSGLEN(M)		;New
NXTNW1:	CAMLE A,LASTM
	 RET
	MOVEI B,M%SEEN
	SKIPGE MSGFLG(A)		;New => recent
	 TDNE B,MSGBTS(A)		;& unseen
	  CAIA
	   JRST NXTSQ2
	ADDI A,MSGLEN
	JRST NXTNW1			;No, keep looking

NXTKEY:	HLLZ B,KEYBTS			;Get the bits to mask against
	CALLRET NXTDL0			;Print those with bits set
NXTUNK:	HLLZ B,KEYBTS
	CALLRET NXTUD0

;;;Find substring in From field

NXTSBJ:	SKIPA C,[CALL SBJSTR]		;Routine to match Subject string
NXTFRM:	MOVE C,[CALL FRMSTR]		;Routine to match From string
	CALLRET NXTAL0			;Use common loop

NXTTO:	SKIPA C,[CALL TOSTR]		;Routine to match To string
NXTTXT:	 MOVE C,[CALL TXTSTR]		;Routine to match text substring
	CALLRET NXTAL0

FRMSTR:	PUSH P,A
	PUSH P,C
	MOVEI T,PATSTR			;String to match
	HRRZ V,MSGFRM(A)		;From field for this message
	HLRZ W,MSGFRM(A)
FRMST2:	PUSH P,M
	HRRZM A,M			;Setup this temporarily so search works
	CALL SEARCH			;Look for string
FRMST3:	 AOS -3(P)			;Didnt find it, skip return
POPMCA:	POP P,M
POPCA:	POP P,C
	POP P,A
	RET				;Found - use this

SBJSTR:	PUSH P,A			;Messages with string in subject
	PUSH P,C
	MOVEI T,PATSTR			;String to match
	HRRZ V,MSGSUB(A)		;Subject field for this message
	HLRZ W,MSGSUB(A)
	CALLRET FRMST2

TXTSTR:	PUSH P,A			;Messages with string in their body
	PUSH P,C
	MOVEI T,PATSTR
	HRRZ V,MSGBOD(A)
	HLRZ W,MSGBOD(A)
	CALLRET FRMST2

TOSTR:	PUSH P,A			;Messages with string in to or cc field
	PUSH P,C
	PUSH P,M
	MOVEI M,(A)			;Temporarily point to right message
	MOVEI T,[ASCIZ/
To: /]
	CALL FNDHDR
	 JRST FRMST3			;Didn't find it, skip return
	POP P,M
	TDZA W,W
TOSTR1:	 ADDI W,2			;Count the crlf too
	CALL FNDSB2			;Count characters in this line
	IBP A				;Skip LF too
	ILDB T,A
	CAIE T,11
	 CAIN T," "			;Continuation line?
	  JRST TOSTR1			;Yes, get some more
	CAIE T,"T"
	 CAIN T,"t"
	  JRST TOSTR2
	CAIE T,"C"
	 CAIN T,"c"
	  JRST TOSTR4
	MOVE A,-1(P)
	MOVEI T,PATSTR
	CALLRET FRMST2			;End of recipients, go do the search

TOSTR2:	ILDB T,A			;Looking for TO:
	CAIE T,"O"
	 CAIN T,"o"
	  JRST TOSTR3
	CALLRET FRMST2

TOSTR3:	ILDB T,A
	CAIE T,":"
	 JRST FRMST2
	ADDI W,3			;Count TO: itself
	JRST TOSTR1

TOSTR4:	ILDB T,A			;Looking for CC:
	CAIE T,"C"
	 CAIN T,"c"
	  JRST TOSTR3
	CALLRET FRMST2

NXTBEF:	SKIPA C,[CAMLE B,MSGDAT(A)]	;Before date
NXTAFT:	 MOVE C,[CAMG B,MSGDAT(A)]	;After date
	MOVE B,NXTIME
	CALLRET NXTAL0

NXTON:	MOVE C,[CALL NXTON1]		;On date
	CALLRET NXTAL0

NXTON1:	MOVE B,MSGDAT(A)
	SUB B,NXTIME
	TLNE B,-1			;More than a day's difference?
	 AOS (P)			;Yes, fail
	RET

SUBTTL Sending subroutines

SNDINI:	CALL SNDIN0
PRSCCL:	SKIPN DEFCCL			;Any default cc list?
	 JRST PRSCC0			;No
	MOVE A,[POINT 7,DEFCCL]
	SETZ E,
	TLO F,(F%CC)			;As cc recipients
	TLZ F,(F%F4)
	CALL PRADDR			;Process default CC list
	MOVEI T,CCLIST			;Set up CC list
	CALL ADDTO0			;Go add whole bunch to list then
PRSCC0:	SKIPN DEFBCL			;Any default bcc list?
	 RET				;No
	MOVE A,[POINT 7,DEFBCL]
	SETZ E,
	TLO F,(F%CC)			;As cc recipients
	TLZ F,(F%F4)
	CALL PRADDR			;Process default BCC list
	MOVEI T,BCCLST			;Set up BCC list
	CALLRET ADDTO0			;Go add whole bunch to list then

;;; Version of SNDINI that does not parse DEFCCL
SNDIN0:	TRZ F,F%RPLY			;Assume not a reply to anyone
	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	CALL .ERSAL			;Go erase everything
	SETZM RMLPTR			;Not remail yet
	RET

PRADDT:	TLZ F,(F%F4)
PRADT1:	CALL PRADDR			;Process list
	CALLRET ADDTO			;Go add whole bunch to list then

;;;Set up host name
NAMINI:	SETZM MYHNAM			;Assume no host name
	SETZM DNHNAM
	MOVEI A,.GTHNS			;Get host number and name
	MOVE B,[POINT 7,MYHNAM,27]
	SETOB C,LHOSTN			;My host number/name
	GTHST%
	 ERJMP NAMIND			;No ARPANET, try DECnet
	MOVEM C,LHOSTN			;Set LHOSTN
	MOVE C,[ASCII/ at /]		;Found a host name, stick " at " in
	IORM C,MYHNAM
NAMIN1:	MOVE A,[MYHNAM,,DNHNAM]		;Copy in case no DECnet name
	BLT A,DNHNAM+17
NAMIND:	MOVEI A,.NDGLN			;Get DECnet local hostname
	MOVEI B,C
	MOVE C,[POINT 7,DNHNAM,27]
	NODE
	 ERJMP NAMINS
	SKIPL LHOSTN			;Have ARPANET?
	 RET
	MOVE A,[ASCII/ at /]		;Found a host name, stick " at " in
	IORM A,DNHNAM
	MOVE A,[DNHNAM,,MYHNAM]		;No, set host name from DECnet name
	BLT A,MYHNAM+17
	RET

NAMINS:
COL,<	MOVEI B,[ASCIZ/COLUMBIA/]>;COL
DREA,<	MOVEI B,[ASCIZ/DREA/]>;DREA
EECS,<	MOVEI B,[ASCIZ/MIT-EECS/]>;EECS
GSB,<	MOVEI B,[ASCIZ/GSB/]>;GSB
LOTS,<	MOVEI B,[ASCIZ/LOTS/]>;LOTS
SUMX,<	MOVEI B,[ASCIZ/SUMEX-2020/]>;SUMX
SPCH,<	MOVEI B,[ASCIZ/MIT-SPEECH/]>;SPCH
IFN .-NAMINS,<
	MOVE A,[POINT 7,MYHNAM,27]
	MOVE C,A
	ILDB C,C
	JUMPE C,MOVST0
	MOVE A,[MYHNAM,,DNHNAM]		;Copy to DECnet name as well
	BLT A,DNHNAM+17
>;IFN .-NAMINS
	RET

;;;Set up host table
NOHST2,<
HSTINI:	MOVEI A,HOSTAB			;Return pointer to host table
	MOVEM A,HSTPTR
	PUSH P,E
	PUSH P,T
	MOVEI A,777			;Length of table (max)
	MOVEM A,HOSTAB
	MOVEI E,HOSTN			;Init free pointers for host numbers
	MOVEI T,HSTNAM			;And names
	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	SKIPG LHOSTN
	 JRST HSTIND			;Try to get DECnet hosts
	MOVEI A,.GTHSZ			;Get # of hosts, etc.
	GTHST%
	 JFATAL (GTHST failed)
	MOVE T,B			;Set up pointer for AOBJN in T
	HRROI B,HSTNAM			;Start writing into HSTNAM table
HSTIN1:	MOVEI A,.GTHIX			;Index to number
	MOVEI C,(T)			;Index from AOBJN pointer
	HRLZ E,B			;Save name pointer for TBADD
	GTHST%
	 JFATAL (GTHST failed)
	MOVEM C,HOSTN(T)		;Save host number
	SETZ C,				;Make sure a null byte terminates name
	IDPB C,B
	MOVEI A,HOSTAB			;Pointer to beginning of table
	EXCH B,E			;Retrieve name pointer, save updated
	HRRI B,HOSTN(T)			;String pointer,,address pointer
	TBADD				;Insert in table
	 ERJMP .+1			;Ignore if duplicated (happens at BBN)
	HRROI B,1(E)			;Continue at next word of name table
	AOBJN T,HSTIN1
	MOVEI E,HOSTN(T)		;Start of free address area for DECnet
	MOVEI T,(B)			;Start of free string area for DECnet
;	CALLRET HSTIND

;;;Init DECnet hosttable

HSTIND:	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ/SYSTEM:DECNET-HOSTS.TXT/]
	GTJFN
	 ERJMP HSTINE			;Can't get host table, done
	MOVE B,[7B5+OF%RD]
	OPENF
	 JFATAL (Can't open DECnet host table)
	MOVEM A,HSTJFN			;Save it away
HSTID1:	MOVE A,HSTJFN
	HRROI B,(T)			;Where to start string
	MOVEI C,HSTNAM+1777
	SUBI C,(T)
	IMULI C,5			;Amount of room left
	MOVEI D,12			;Until end of line
	SIN
	 ERJMP HSTID2			;Must be eof
	JUMPE C,[FATAL (Host table buffer exhausted)]
	ADD B,[7B5]
	SKIPGE B
	 SUB B,[43B5+1]			;Back up byte pointer
	MOVEI D,0
	DPB D,B				;Replace CR with null
	HRROI B,1(B)
	EXCH B,T			;Update free pointer

;;;Scan this string to see if comment or synonym
	PUSH P,B
	HRLI B,(<POINT 7,0>)		;Make byte pointer
HSTID4:	ILDB A,B			;Get a character from the line
	CAIN A," "			;Flush whitespace if present
	 JRST HSTID4
	CAIN A,","			;Routing list?
	 JRST HSTID6
	CAIE A,"!"			;Comment?
	 CAIN A,";"
	  JRST HSTID6			;Yes, end the line here
	CAIN A,"="			;Synonym?
	 JRST [	SETZ A,			;Yes, end this string
		DPB A,B
		HRROI T,1(B)		;Update free pointer
		MOVE A,HSTPTR		;Is string in table?
		TBLUK
		TLNE B,(TL%NOM!TL%AMB)	;No good?
		 JRST [	WARN (Synonym error in SYSTEM:DECNET-HOSTS.TXT)
			ADJSP P,-1	;Fix up stack context
			JRST HSTID2]
		POP P,B			;Restore start pointer
		MOVSI B,(B)
		HRR B,(A)		;Get data for real name
		MOVE A,HSTPTR		;TBADD table address
		JRST HSTID5]
	JUMPN A,HSTID4			;Character okay, try next
HSTID3:	POP P,B
	HRROS B				;Mark DECnet host
	MOVEM B,(E)			;Save number
	MOVE A,HSTPTR
	MOVSI B,(B)
	HRRI B,(E)
HSTID5:	TBADD
	 ERJMP .+1			;In case an ARPANET name too
	CAIL E,HOSTN+777
	 FATAL (Host number buffer exhausted)
	AOJA E,HSTID1

HSTID6:	SETZ A,
	DPB A,B
	JRST HSTID3			;And continue processing

HSTID2:	MOVE A,HSTJFN
	CLOSF
	 JWARN
	SETOM HSTJFN
HSTINE:	POP P,T
	POP P,E
	MOVE A,HSTPTR			;Return pointer to things
	RET				;Done
>;NOHST2

HOSTS2,<
;;;Read in the HOSTS2 table

HSTINI:	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ/SYSTEM:HOSTS2.BIN/]
	GTJFN
	 JFATAL <Cannot find host table>
	MOVEI B,OF%RD
	OPENF
	 JFATAL <Cannot open host table>
	SIZEF
	 JFATAL <Cannot get host table size>
	MOVSI A,(A)			;Start with page 0
	MOVE B,[.FHSLF,,HSTPAG/1000]
	HRLI C,(PM%CNT!PM%RD!PM%CPY)
	PMAP
	MOVE A,HSTPAG+HSTSID
	CAME A,[SIXBIT /HOSTS2/]
	 FATAL <Host table has bad format>
	MOVE A,HSTPAG+NAMPTR		;Pointer to name table
	ADDI A,HSTPAG+1
	MOVEM A,HSTPTR			;Setup pointer to tbluk table
	HRL A,-1(A)			;Number of entries
	HLRM A,(A)
	HLLM A,(A)
	ADD A,[-1,,1]			;Form AOBJN pointer
	TLC A,-1
	MOVE B,[HSTPAG,,HSTPAG]
HSTIN1:	ADDM B,(A)
	MOVSS C,(A)
	MOVE D,(C)			;May be pointed to more than once, so
	TRNN D,700000			;if right half address unnormalized,
	 ADDI D,HSTPAG			;do it now
	TLNN D,700000			;Same for left half
	 ADD D,[HSTPAG,,]
	MOVEM D,(C)
	AOBJN A,HSTIN1
	MOVE A,HSTPTR
	MOVE B,[POINT 7,MYHNAM,27]
	TBLUK
	HRRZ C,(A)
	HLRZ C,(C)			;Get pointer to official name
	MOVEM C,LHOSTP			;Also save the pointer
	MOVE A,HSTPTR			;Return pointer to things
	RET
>;HOSTS2

;;;Host name converter
;;;a/ destination string pointer
;;;b/ zero for local host, host address if not HOSTS2, pointer to address entry
;;;	if HOSTS2

$CVHST:
HOSTS2,<
	JUMPN B,CVHDCN			;If non-zero, must be a pointer
>;HOSTS2
NOHST2,<
	JUMPE B,CVHST2
	HLRO C,B			;Get network type
	AOJE C,CVHDCN			;-1 in LH means DECnet
	MOVEI C,10			;Just in case
	CVHST
	 NOUT
	  NOP
	RET
>;NOHST2

CVHST2:	SKIPA B,[POINT 7,MYHNAM,27]	;Use local host-name if none there now
CVHDCN:	 HRLI B,(<POINT 7,0>)
NEWQ,<
	TLNE F,(F%NEWQ)
	 JRST [	PUSH P,B
		MOVEI B,177
		BOUT
		POP P,B
		CALL .+1
		HRROI B,[BYTE (7) 177,0]
		SOUT
		RET]
>;NEWQ
	SETZ C,
	SOUT
	RET

;;;Send the current message off

SNDMS5:	CALL GETTO			;Insist upon having a to-list
SNDMSG:	SKIPE TOLIST			;Is there a to-list?
	 JRST SNDMS0			;Yes, go send it
	SKIPN A,CCLIST			;Try moving cc-list to to-list
	 JRST SNDMS5			;No recipients, demand some
	SETZM CCLIST
	MOVEM A,TOLIST			;Move appropriate list to to-list
SNDMS0:	TLZ F,(F%F5)			;Haven't got funny SAVFIL yet
	MOVE A,TXTPTR			;Get end of message
	MOVEI B,[ASCIZ/
/]
	LDB C,A
	CAIN C,12			;Unless ended with CRLF
	 JRST .+3
	CALL MOVST0			;Put one in now
	ADD A,[7B5]			;And back over the null
	MOVEM A,TXTPTR
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ/>MAIL.CPY.-1;P770000;T/]
	CALL MOVST0			;And the null
	MOVSI A,(GJ%FOU!GJ%NEW!GJ%SHT)
	HRROI B,STRBUF			;Get it back
	GTJFN
	 JERROR (Can't get MAIL.CPY)
	PUSH P,A			;Save JFN in case OPENF fails
SNDMS4:	MOVE B,[7B5+OF%WR]
	OPENF
	 JRST [	JSNARL (Can't open MAIL.CPY)
		HALTF
		MOVE A,(P)		;Let user try CONTINUE
		JRST SNDMS4]
	ADJSP P,-1
	HRROI B,TXTPAG
	SETZ C,
	SOUT
	RFPTR
	 JERROR
	SKIPN RMLPTR			;Unless remail
	 ADDI B,9			;Count for dashes later
	MOVEM B,MSGSIZ			;Save size of text portion of message
STAN,<
	DELF				;Make file deleted
	 JERROR
>;STAN
	CLOSF
	 NOP
	SKIPN LCLIST			;Any local recipients?
	 SKIPE FILIST			;Or file recipients?
	  JRST SNDMS1
	SKIPN SAVFIL			;Or uses SAVED.MESSAGES feature
	 JRST SNDMS2			;No, just go send network out then
SNDMS1:	TLZ F,(F%AT)			;Setup headers for local recipients
	PUSH P,MSGSIZ
	CALL SETHDR
	CALL SNDLCL			;Try to send local messages
IPCF,<
	TLO F,(F%AT)			;Make sure complete header is included
	MOVE A,0(P)			;Get back original msg size, since
	MOVEM A,MSGSIZ			;We are starting over with the header
	SKIPN FILIST			;Any file recipients?
	 SKIPE SAVFIL
	  CALL SETHDR			;Yes, local headers and from: field
>;IPCF
	CALL SNDFIL			;Try to send file messages
	SKIPL RINCME			;Special include me mode?
	 JRST SNDMS3			;No
	TLZN F,(F%F5)			;Yes, did we see that address?
	 SETZM SAVFIL			;No, don't send any file guy then
SNDMS3:	CALL FILMSG			;Store SAVED.MESSAGES
	POP P,MSGSIZ
SNDMS2:	SKIPN NETLST			;Any network recipients?
	 RET
NEWQ,<
	TLO F,(F%AT!F%NEWQ)		;Set headers for network recipients
>;NEWQ
NONEWQ,<
	TLO F,(F%AT)
>;NONEWQ
	CALL SETHDR
	CALL SETHDN
	CALL SNDNET
	CALLRET MAIFLG			;Set MAILER.FLAGS for our queued mail

;;;Setup header of message for this kind of recipient

; Separate entry point for DECnet mail, in case on both ARPANET and DECnet
;with different "local host names"!
SETHDN:	SKIPN A,RMLPTR			;Doing remail command?
	 JRST [	MOVE A,[POINT 7,HDNPAG]	;No, simple case
		JRST SETHD0]
	MOVE B,[HDRPAG,,HDNPAG]		;Yes, copy header to DECnet block
	BLT B,HDNPAG+777
	ADDI A,HDNPAG-HDRPAG		;Offset remail pointer properly
	JRST SRMLH1

SETHDR:	SKIPE A,RMLPTR			;Doing remail command?
	 JRST SRMLH1			;Yes
IPCF,<
OIPCF,<
	TLNN F,(F%AT)			;ARPA address?
	 JRST SETHD2			;No, make shorter header
>;OIPCF
NOSIPCF,<
	TLNN F,(F%AT)			;ARPA address?
	 JRST [	MOVE O,[POINT 7,HDRPAG]
		CALL MOVUSH		;No, just put in user headers
		CALL MOVSUB		; and subject
		SKIPLE REPDAT		;Any reply date?
		 CALL MOVRDT		;Yes, insert it too
		JRST SRMLH3]		;Rejoin common code
>;NOSIPCF
>;IPCF
	MOVE A,TXTPTR
	MOVEI B,[ASCIZ/-------
/]
	CALL MOVST0			;Put in dashes at end
	SKIPA A,[POINT 7,HDRPAG]	;Start of where to assemble msg headers
SRMLH1:	 SKIPA B,[[ASCIZ/Remailed-date: /]]
SETHD0:	  MOVEI B,[ASCIZ/Date: /]
	CALL MOVSTR
	SETO B,				;Now
	MOVSI C,(OT%4YR!OT%SPA!OT%NSC!OT%NCO!OT%TMZ)	;"12 Dec 1977 1906-PST"
	ODTIM
	SKIPE RMLPTR
	 JRST [	MOVEI B,[ASCIZ/
Remailed-from: /]
		JRST SRMLH2]
	CALL CHKUSR			;Check the user name variable
	 JRST SETHD5
	MOVEI B,[ASCIZ/
Sender: /]
	CALL MOVSTR
	MOVE B,MYDIR			;Login directory
	DIRST
	 JFATAL
	TLNN F,(F%AT)
	 JRST SETHD5
NONEWQ,<
	HRRZ B,A			;Look at address part
	TRZ B,777			;Only page number
	CAIE B,HDRPAG
	 SKIPA B,[DNHNAM]		;Making DECnet headers
	  MOVEI B,MYHNAM
	CALL MOVSTR
>;NONEWQ
NEWQ,<
	CALL MOVMHN			;Output local host
>;NEWQ
SETHD5:	MOVEI B,[ASCIZ/
From: /]
SRMLH2:	CALL MOVSTR
IFN PRNMSF,<
	TLNN F,(F%AT)
	 JRST SETHD3
>;IFN PRNMSF
	SKIPE HDR733			;Wants Person <NAME at SITE>?
	 SKIPN PERNAM			;And has a personal name?
	  JRST SETHD3			;No or no
	MOVEI B,PERNAM
	CALL MOVSTR
	MOVEI B,[ASCIZ/ </]		;>
	CALL MOVSTR
SETHD3:	MOVEI B,MYDIRS			;My name
	CALL MOVSTR			;Put it in
IFN PRNMSF,<
	TLNN F,(F%AT)			;Going to network?
	 JRST SETHD1			;No
>;IFN PRNMSF
NONEWQ,<
IFE PRNMSF,<
	TLNN F,(F%AT)			;Going to network?
	 JRST SETHD6			;No
>;IFE PRNMSF
	HRRZ B,A			;Look at address part
	TRZ B,777			;Only page number
	CAIE B,HDRPAG
	 SKIPA B,[DNHNAM]		;Making DECnet headers
	  MOVEI B,MYHNAM		;Non-DECnet headers
	CALL MOVSTR			;Yes, put in at SITE (Mumble)
SETHD6:
>;NONEWQ
NEWQ,<
IFE PRNMSF,<
	TLNE F,(F%AT)			;Going to network?
>;IFE PRNMSF
	 CALL MOVMHN			;Yes, put in at SITE
>;NEWQ
	SKIPN PERNAM			;Has a personal name?
	 JRST SETHD1
	SKIPE HDR733			;Generate brocket style from?
	 JRST SETHD4			;Yes
	MOVEI B,[ASCIZ/ (/]
	CALL MOVSTR
	MOVEI B,PERNAM
	CALL MOVSTR
	SKIPA B,[")"]
SETHD4:	 MOVEI B,">"
	IDPB B,A
SETHD1:	SKIPA O,A			;Get pointer set up right
SETHD2:	 MOVE O,[POINT 7,HDRPAG]
	SKIPE RMLPTR			;Remail command?
	 JRST [	MOVEI T,[ASCIZ/
Remailed-to: /]
		MOVE A,[IDPB A,O]	;Output to string
		MOVEM A,MOVDSP
		CALL MOVTRM
		JRST SRMLH3]
	CALL MOVUSH			;Insert user-generated headers
SETHD7:	CALL MOVSUB			;Insert subject
	CALL MOVTO			;And to
	CALL MOVCC			;And CC
	SKIPLE REPDAT			;Has a reply date?
	 CALL MOVRDT			;Yes, insert it too
SRMLH3:	MOVEI B,[ASCIZ/

/]
	CALL MOVSB2			;And a couple blank lines
	SETZ A,
	IDPB A,O			;Mark end of this with a null too
	LDB B,[POINT 6,O,5]
	IDIVI B,7
	MOVEI A,1-HDRPAG(O)
	IMULI A,5			;Compute number of characters used in headers
	SUBI A,1(B)
	ADDM A,MSGSIZ			;Update size of whole thing
	RET

;;;Check that the user name variable is ok

CHKUSR:	PUSH P,A
	MOVSI A,(RC%EMO)
	HRROI B,MYDIRS
	RCUSR
	 ERJMP CHKUS2
	TLNE A,(RC%NOM!RC%AMB)		;No good?
	 JRST CHKUS2			;Yes, fix it up then
	CAME C,MYDIR			;Same as login directory?
	 AOS -1(P)			;No, need to put in sender field then
	JRST CPOPAJ
	
CHKUS2:	HRROI A,MYDIRS
	MOVE B,MYDIR
	DIRST
	 NOP
	JRST CPOPAJ

;;;File away the message in SAVED.MESSAGES if in logged directory

FILMSG:	SKIPN SAVFIL			;Wants one at all?
	 RET				;No
	MOVEI T,M%SEEN			;Mark message as seen
	HRROI B,SAVFIL
	MOVSI A,(GJ%OLD!GJ%SHT)		;Enter here to send to a file
FILMS1:	GTJFN				;Try to get guy's SAVED.MESSAGES
	 RET				;Not there, don't worry about it
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JERROR (Couldn't open file recipient)
	SKIPLE SNDVBS			;Verbose sending mode?
	 TLOA F,(F%F1)			;Yes, type out filename
FILMS2:	  TLZ F,(F%F1)			;Don't type out filename
	SETO B,				;Now
	MOVSI C,(OT%TMZ)		;Timezone as well
	ODTIM
	MOVEI B,","
	BOUT
	MOVE B,MSGSIZ			;Get back size
	MOVEI C,^D10			;Decimal
	NOUT
	 JERROR
	MOVEI B,";"
	BOUT
	MOVE B,T			;Bits to put in
	MOVE C,[NO%LFL!NO%ZRO!NO%MAG!14B17!^D8] ;"000000000000"
	NOUT
	 JERROR
	HRROI B,CRLF0
	SETZ C,
	SOUT				;Write header bits and crlf
	HRROI B,HDRPAG
	SOUT				;Copy the headers
	HRROI B,TXTPAG
	SOUT				;And the text
	TLZE F,(F%F1)			;Want filename?
	 CIETYP < *%1J -- ok>
	CLOSF
	 JWARN (Couldn't close message file)
	RET

;;;Send other disk file recipients

SNDFIL:	HRRZ W,FILIST
SNDFL1:	JUMPE W,CPOPJ			;Done with file recipients
	MOVEI T,0			;Mark as unseen
	MOVSI A,(GJ%SHT)
	HRROI B,4(W)			;Get name of file
	CALL FILMS1			;Send it off
	HRRZ W,1(W)			;Get next one
	JRST SNDFL1

NOIPCF,<				;If doing local appending
;;;Try to send local mail, queue what we can't handle now

SNDLCL:	HRRZ W,LCLIST			;Get start of local recipients
SNDLC1:	JUMPE W,CPOPJ			;Done with list
	MOVE A,2(W)			;Is this special local recipient?
	AOJE A,[TLON F,(F%F5)		;Yes, setup as saved.messages file
		 SKIPE SAVFIL		;Unless have one from moving
		  JRST SNDLC2
		HRROI A,SAVFIL
		MOVE B,MSGJFN
		SETZ C,
		JFNS
		JRST SNDLC2]
	CALL SNDMSL			;Try to send locally
	 JRST SNDLC3
SNDLC2:	HRRZ W,1(W)			;Get next in list
	JRST SNDLC1

SNDLC3:	SETZM 2(W)			;Clear host/user number for this guy
	MOVEI B,NETLST			;Thread entry into network recipients
	MOVEI U,(W)
	HRRZ W,1(W)			;Get next link for next time
	SETZM 1(U)			;Clear any previous links
	CALL ADDLST			;Add onto this list
	 NOP				;Don't worry about duplicate
	JRST SNDLC1			;And try some more

;;;Attempt to deliver local mail right away for this user

SNDMSL:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,4(W)			;Local user name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ/>MAIL.TXT.1/]
	CALL MOVST0			;And the null
;  The following code is here due to a moby loss in GTJFN.  If both GJ%FOU
; and GJ%OLD are set, and the destination mail file is deleted, permanent,
; and empty, what happens is that the file is depermanentized, flushed, and
; the GTJFN fails.
;  This bug exists in both release 3 and release 4.
	MOVSI A,(GJ%OLD!GJ%DEL!GJ%SHT)	;Verify there is a mail file there
	HRROI B,STRBUF
	GTJFN
	 RET				;Not there, single return
	RLJFN				;Now get rid of this JFN
	 NOP
	MOVSI A,(GJ%FOU!GJ%DEL!GJ%SHT)	;Get the JFN we really want
	HRROI B,STRBUF
	GTJFN				;Try to get guys mail file
	 RET				;This shouldn't have happened, oh well
	MOVEM A,OUTJFN			;Save it
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		RET]
	MOVEI T,0			;Mark as unseen
	CALL FILMS2			;Go actually append it
	MOVEI A,4(W)			;Get the guy's name again
	SKIPL SNDVBS			;Super-terse sending?
	 CIETYP < %1S -- ok>		;No, tell of local sending
	RETSKP				;Skip return for success
>;NOIPCF

IPCF,<
;;;Send local mail via IPCF mailer

SNDLCL:	SKIPN W,LCLIST			;Any local mail to do?
	 RET				;No, forget it then
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	PUSH P,A			;Save string pointer
	GJINF				;Get logged-in user number in B
	MOVE B,A			;This is to prevent any problems
	POP P,A				; with security checks in IPCF
	DIRST				; mailer if we ALIAS elsewhere...
	 JFATAL
	MOVEI B,[ASCIZ/>MSG.TMP.-1;P770000;T/]
	CALL MOVST0			;And the null
	MOVSI A,(GJ%FOU!GJ%NEW!GJ%SHT)
	HRROI B,STRBUF			;Get it back
	GTJFN
	 JERROR (Can't get temporary file)
	MOVEM A,TMPJFN
SNDLC0:	MOVE B,[44B5+OF%WR]		;Open initially in 36-bit mode
	OPENF
	 JRST [	JSNARL (Can't open temporary file)
		HALTF
		MOVE A,TMPJFN		;Let user try CONTINUE
		JRST SNDLC0]
SIPCF,<
	MOVSI B,(FL%MM)			;Flag for our own headers
>;SIPCF
NOSIPCF,<
	SETZ B,				;DEC doesn't have this feature
>;NOSIPCF
	BOUT
SNDLC1:	MOVE B,2(W)			;Get directory number
	CAME B,[-1]			;Special local one?
	 JRST SNDL1A
	TLON F,(F%F5)			;Yes, use saved.messages file
	 SKIPE SAVFIL			;If have it from move command
	  JRST SNDLC2
	MOVE B,MYDIR			;Otherwise just reply to me
SNDL1A:	BOUT
SNDLC2:	HRRZ W,1(W)			;Get next in list
	JUMPN W,SNDLC1			;For all
	SETZ B,				;Mark end of list
	BOUT
	BOUT
	MOVEI B,7			;Now get ready to output text
	SFBSZ
	 JERROR
NOSIPCF,<
	LDB B,[POINT 7,HDRPAG,6]	;Skip over leading CRLF if present
	CAIN B,15
	 SKIPA B,[POINT 7,HDRPAG,13]
>;NOSIPCF
	  HRROI B,HDRPAG		;Output our headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;And text of message
	SETZ C,
	SOUT
	HRLI A,(CO%NRJ)			;Close but keep the JFN for later
	CLOSF
	 JWARN (Couldn't close temporary file)

;;;Now try to find IPCF mailer

IPCFI:	TLZ F,(F%F1)			;Flag for warning message
	SKIPE PIDGET+1			;Have a PID already?
	 TDZA A,A			;Yes, use it
IPCFI1:	  MOVSI A,(IP%CPD)		;No, make one with first message
	MOVEM A,PIDGET
IPCFI2:	MOVEI B,PIDGET			;Get [SYSTEM]MAILER's PID
	SETZM PIDGET+2			;Send to info
	MOVEI A,4			;Length of block
	MSEND
	 JRST [	TLON F,(F%F1)		;Already gave warning?
		 JWARN <Waiting...>
		SETZM PIDGET+1		;Maybe our PID was invalid
		MOVEI A,^D500		;Wait 1/2 sec
		DISMS
		JRST IPCFI1]
	MOVSI A,(IP%CPD)		;Don't need to make a PID any more
	ANDCAM A,PIDGET
IPCFI3:	SETZB T,U			;No flags, any sender
	MOVE V,PIDGET+1			;The PID I got last time
	MOVE W,[10,,WRTPGS]		;Some place for messages
	MOVEI A,4			;Size of block
	MOVEI B,T			;Pointer to block
	MRECV				;Get message from info
	 NOP
	LDB U,[POINT 3,T,32]		;See who sent message
	CAIE U,1			;From monitor
	 CAIN U,2			;Or info
	  CAIA				;Yes, good
	   JRST IPCFI3			;No, get another message
	TRNE T,7			;Was it undeliverable?
	 JRST IPCFI2			;Yes, try sending it again
	LDB U,[POINT 6,T,29]		;Get error field
	JUMPE U,IPCFM			;None
	CAIN U,.IPCSN			;INFO crash?
	 JRST IPCFI3			;Yes, go get more messages
	MOVEI A,[ASCIZ/MAILER not running/]
	CALLRET SNLQAL			;Go queue all messages

;;;Now send to MAILER file to process

IPCFM:	MOVE V,WRTPGS+1			;Get MAILER's PID
	MOVEM V,PIDGET+2		;Save for later too
	SETZB D,WRTPGS
	HRROI A,WRTPGS+1
	MOVE B,TMPJFN			;Temp file
	MOVE C,[111110,,1]		;Print all fields
	JFNS
	IDPB D,A			;Move over null
	MOVSI W,-WRTPGS(A)		;Get length of string
	MOVEI A,(B)			;Now can get rid of JFN
	RLJFN
	 NOP
	SETOM TMPJFN
	HRRI W,WRTPGS+1			;Where message is
	SETZ T,				;No flags
	MOVE U,PIDGET+1			;Sent by me
IPCFM1:	MOVEI A,4			;Length
	MOVEI B,T			;Address
	MSEND
	 JRST [	MOVEI A,^D500		;Failed, wait a bit
		DISMS
		JRST IPCFM1]
	CITYPE <Processing local mail...>
IPCFM2:	MOVEI A,4
	MOVEI B,T
	SETZB T,U
	MOVE V,PIDGET+1
	MOVE W,[1000,,WRTPGS+1000]
	MRECV				;Get message from MAILER
	 NOP
	LDB B,[POINT 3,T,32]		;Get sender type
	JUMPE B,IPCFO			;Not special, must be mailer
	CAIE B,2			;From info
	 CAIN B,3			;Or private info
	  JRST IPCFM2			;Yes, get some more
	MOVEI A,[ASCIZ/Could not send to MAILER/]
	CALLRET SNLQAL			;Queue them all if network

;;;Now see how things got sent

IPCFO:	CAME U,PIDGET+2
	 JRST IPCFM2			;Not from mailer, get some more
	LDB T,[POINT 6,T,29]		;Get error code
	JUMPE T,IPCFN			;No errors
	CAIE T,NACK1			;Total wipeout?
	 JRST IPCFE			;No, tell what happened
	MOVEI A,[ASCIZ/Processing errors occurred/]
	CALLRET SNLQAL

;;;Report errors or queue failures

IPCFE:	SUB W,[1,,0]
	TLC W,-1			;Form aobjn pointer
	HRRI W,WRTPGS+1000		;Point to list of failed things
IPCFE1:	MOVE T,1(W)			;Get bad guy
	MOVE U,LCLIST			;Get list of local recipients
IPCFE2:	CAMN T,2(U)			;This the guy?
	 JRST IPCFE3			;Yes
	HRRZ U,1(U)			;Get next in list
	JUMPN U,IPCFE2
	WARN < Error reported for %6U, but mail not sent>
	JRST IPCFE5			;Forget about it

IPCFE3:	EXCH U,W
	CALL REMLST			;Remove from present list
	EXCH U,W
	SKIPL LHOSTN			;Are we going to be able to queue this?
	 JRST IPCEF8			;Yes, go do so
	HLRZ B,(W)			;Get error type from mailer
	JUMPE B,IPCFE7			;JSYS type error?
	CAIE B,1			;Message within range of known?
IPCFE4:	 TDZA A,A			;No, don't have anything
	  MOVEI A,[ASCIZ/ because of quota exceeded/]
IPCFE5:	MOVEI C,4(U)
	CIETYP < %3S not sent%1S>
IPCFE6:	AOBJN W,.+1
	AOBJN W,IPCFE1			;Go handle next baddie
	JRST IPCFN

IPCFE7:	HRRZ B,(W)			;Get error code
	JUMPE B,IPCFE4
	MOVEI A,[ASCIZ/ because of %2E/]
	JRST IPCFE5

IPCEF8:	SETZM 1(U)			;Queue for mailing through network
	SETZM 2(U)
	MOVEI B,NETLST
	CALL ADDLST
	 NOP
	JRST IPCFE6

;;;Print out successes now too

IPCFN:	SKIPL SNDVBS			;Doesnt want to here about this
	 SKIPN U,LCLIST
	  RET
IPCFN1:	MOVEI A,4(U)			;Get user name string
	CIETYP < %1S -- ok>		;Tell about it
	HRRZ U,1(U)
	JUMPN U,IPCFN1
	RET				;All done

;;;Gross failure, queue all messages if there is a network, else bomb

SNLQAL:	SKIPG LHOSTN			;Is there a network
	 ERROR <%1S, no messages sent>
	CIETYP <%1S, all messages will be queued>
	MOVE W,LCLIST
SNLQA1:	JUMPE W,CPOPJ
	MOVEI U,(W)
	SETZM 2(U)			;Clear host number
	HRRZ W,1(U)			;Get next link
	SETZM 1(U)			;Clear links
	MOVEI B,NETLST
	CALL ADDLST			;Link to net list now
	 NOP
	JRST SNLQA1
>;IPCF

;;;Queue network mail

SNDNET:	
NEWQ,<
	TLZ F,(F%NEWQ)
	TRO F,F%ARPA			;Flag we have queued ARPANET mail
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ/>[--NETWORK-MAIL--]..-1;P770000/]
	CALL MOVST0			;put in start of filename
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF	
	GTJFN
	 JERROR (Can't get queue file)
	MOVEM A,OUTJFN
	HRLI A,.FBBYV
	MOVSI B,(FB%RET)
	SETZ C,
	CHFDB				;Make keep all versions
	 ERJMP .+1
SNDNTO:	MOVE A,OUTJFN
	MOVE B,[7B5+OF%WR]
	OPENF
	 JRST [	JSNARL (Can't open queue file)
		HALTF			;Give the user a chance to expunge,
		JRST SNDNTO]		;and try again
>;NEWQ
	SETO E,				;Clear last host sent
	HRRZ W,NETLST			;Get start of network list
SNDNT1:
NONEWQ,<
	JUMPE W,CPOPJ			;End of list
	MOVE A,[POINT 7,STRBUF]
	HLRO B,2(W)			;Get network number
	AOJE B,SNDNTD			;Send DECnet
	TRO F,F%ARPA			;Flag we have queued ARPANET mail
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ/>[--UNSENT-MAIL--]./]
	CALL MOVSTR			;put in start of filename
	MOVEI B,4(W)			;Get this address
	HRLI B,(<POINT 7,0>)
	MOVEI D,CTL(V)
SNDNT2:	ILDB C,B			;Get char of name
	JUMPE C,SNDNT3			;End
	IDPB D,A			;Quote it
	IDPB C,A
	JRST SNDNT2			;No

SNDNT3:	IDPB D,A			;^V
	MOVEI C,"@"			;Put in @ for good measure
	IDPB C,A
	SKIPE B,2(W)			;Get host address
SNDNT4:	 CALL $CVHST			;Put in name
	MOVEI B,[ASCIZ/.-1;P770000/]	;Set protection to 770000
	CALL MOVST0
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Can't get queue file)
	PUSH P,A
	HRLI A,.FBBYV
	MOVSI B,(FB%RET)
	SETZ C,
	CHFDB				;Make keep all versions
	 ERJMP .+1
	POP P,A
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open queue file)
	HRROI B,HDRPAG			;Start of headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;Start of text
	SOUT
	CLOSF				;All there is to it
	 JERROR (Can't close message file)
>;NONEWQ
NEWQ,<
	MOVE A,OUTJFN			;Get back JFN for output
	JUMPE W,SNDNT7			;End of list, finish up
	MOVE B,2(W)			;Get host number
	CAMN B,E			;Same as last time?
	 JRST SNDNT2
	MOVE E,B
	MOVEI B,CTL(L)			;Formfeed separates hosts
	BOUT
	MOVE B,E
	CALL $CVHST
	HRROI B,CRLF0
	SOUT
SNDNT2:	HRROI B,4(W)			;Name of recipient
	SETZ C,
	SOUT
	HRROI B,CRLF0
	SOUT
>
SNDNT5:	SKIPG SNDVBS			;Super-verbose sending?
	 JRST SNDNT6			;No, don't tell of queuing
	MOVEI A,4(W)			;Guy's name
	SKIPG C,2(W)			;Get host number
	 TDZA B,B
	  MOVEI B,[ASCIZ/ at %3N/]
	CIETYP < %1S%2S -- queued
>
SNDNT6:	HRRZ W,1(W)			;Get next one to do
	JRST SNDNT1

NONEWQ,<
SNDNTD:	TRO F,F%DECN			;Flag we have queued DECnet mail
	MOVE B,2(W)			;Get DECnet host number
	CAMN B,E			;Same as last time?
	 JRST SNDNT5			;Yes, only one file per host needed
	MOVE E,B
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	PUSH P,A			;Save string pointer
	GJINF				;Get true logged-in user number in B
	MOVE B,A			;Set it up for DIRST
	POP P,A
	DIRST
	 JFATAL
	MOVEI B,[ASCIZ/>[--DECNET-MAIL--]./]
	CALL MOVSTR
	MOVE B,E
	CALL $CVHST			;Put in name
	MOVEI B,[ASCIZ/.-1;P770000/]	;Set protection to 770000
	CALL MOVST0
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Can't get queue file)
	PUSH P,A
	HRLI A,.FBBYV
	MOVSI B,(FB%RET)
	SETZ C,
	CHFDB				;Make keep all versions
	 ERJMP .+1
	POP P,A
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open queue file)
	HRROI B,HDNPAG			;Start of headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;Start of text
	SOUT
	CLOSF				;All there is to it
	 JERROR (Can't close message file)
	JRST SNDNT5
>;NONEWQ

NEWQ,<
SNDNT7:	HRROI B,[BYTE (7) CTL(L),15,12,0] ;Finish up hosts with <form><crlf>
	SETZ C,
	SOUT
	HRROI B,HDRPAG			;Start of headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;Start of text
	SOUT
	CLOSF				;All there is to it
	 JERROR (Can't close message file)
	RET
>;NEWQ

;;;Set the MAILER flags

MAIFLG:	MOVSI A,(GJ%OLD!GJ%SHT)
NONEWQ,<
	HRROI B,[ASCIZ/SYSTEM:MAILER.FLAGS.1/]
>;NONEWQ
NEWQ,<
	HRROI B,[ASCIZ/SYSTEM:XMAILR.FLAGS.1/]
>;NEWQ
	TRZN F,F%ARPA			;Any ARPANET mail to do?
	 RET
	CALL MAIFL1			;Yes, set the bit if possible
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ/SYSTEM:DECNET-MAILER.FLAGS.1/]
	TRZN F,F%DECN			;Any DECnet mail to do?
	 RET
MAIFL1:	GTJFN				;Get JFN on flags file
	 JRST MAFLE1			;No file, or no DECnet mail; done
	PUSH P,A
	MOVEI B,OF%THW!OF%WR!OF%RD
	OPENF
	 JRST MAIFLE
	HRLZ A,(P)			;Page 0
	MOVE B,[.FHSLF,,FLGPAG/1000]
	MOVSI C,(PM%RD!PM%WR)
	PMAP
	GJINF				;Get true logged-in user number in A
	HRRZ C,A			;Login directory
	IDIVI C,^D36
	MOVSI A,(1B0)
	MOVN D,D
	ROT A,(D)
	IORM A,FLGPAG(C)		;Set my bit
	SETO A,
	MOVE B,[.FHSLF,,FLGPAG/1000]
	SETZ C,
	PMAP
	POP P,A
	CLOSF
	 NOP
	RET

MAIFLE:	POP P,A
	RLJFN
	 NOP
MAFLE1:	JWARN <Unable to set mailer flags>
	RET

.HMAIL:	[ASCIZ/
The NET-MAIL command will attempt to send any messages that may be queued
in your directory.
/]

;;;Run MAILER to send off what we queued

.MAILE:	NOISE (QUEUED MESSAGES)
	CONFRM
NEWQ,<
NOSTAN,<
	HRROI B,[ASCIZ/SYS:XMAILR.EXE/]
>;NOSTAN
STAN,<
	HRROI B,[ASCIZ/SYSTEM:XMAILR.EXE/]
>;STAN
	TLO F,(F%F3)			;Make sure it doesn't run enabled
	CALL RUNFL0
	KFORK				;Don't need it any more
>;NEWQ
NONEWQ,<
.MAIL1:
ISI,<	HRROI B,[ASCIZ/SYS:MAILER.EXE/]>;ISI
MIT,<	HRROI B,[ASCIZ/SYS:MAILER.EXE/]>;MIT
SRI,<	HRROI B,[ASCIZ/SYS:MAILER.EXE/]>;SRI
UTAH,<	HRROI B,[ASCIZ/SYSTEM:NMAILR.EXE/]>;UTAH
IFE .-.MAIL1,<
	HRROI B,[ASCIZ/SYS:NMAILR.EXE/]
>;IFE .-.MAIL1
	TLO F,(F%F3)			;Make sure it doesn't run enabled
	MOVSI A,(GJ%OLD!GJ%SHT)
	GTJFN
	 ERJMP .MAIL2			;Okay if no ARPANET mailer
	CALL RUNFL3
	KFORK				;Don't need it any more
	CALL CRIF			;Make sure delimited between the two
.MAIL2:	TLO F,(F%F3)			;Make sure it doesnt run enabled
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ/SYS:DMAILR.EXE/];DECnet mailer
	GTJFN
	 ERJMP .MAIL3			;Okay if no DECnet mailer
	CALL RUNFL3
	KFORK				;Don't need it any more
.MAIL3:
>;NONEWQ
	CALLRET .PUSH1			;Do an automatic CHECK

RUNFIL:	TLZ F,(F%F3)			;Default run enabled
RUNFL0:	MOVSI A,(GJ%OLD!GJ%SHT)
RUNFL1:	GTJFN
	 JERROR (Couldn't find file to run)
RUNFL3:	PUSH P,A			;Save the JFN
	TLNE F,(F%F3)			;Wants to run enabled?
	 TDZA A,A			;No
	  MOVSI A,(CR%CAP)		;Yes, give it our caps
	CFORK
	 JERROR (Couldn't create fork)
	PUSH P,C			;Make sure ARPANET users can use NMAILR
	SETO B,				;All priv's possible
	SETZ C,				;But none enabled
	TLZE F,(F%F3)			;If not to be enabled
	 EPCAP				;At least give him possibles
	POP P,C
	EXCH A,(P)			;Get back JFN
	HRL A,(P)
	GET
	POP P,A				;Get back fork handle
RUNFL2:	SETZ B,
	SFRKV				;At regular startup point
	WFORK
	PUSH P,A
	DMOVE A,PRGNAM			;Restore names
	SETSN
	 JFATAL
	POP P,A
	RET

.HPUSH:	[ASCIZ/
The PUSH command will give you a new EXEC. This means that you'll get a
fresh copy of the TOPS-20 command interpreter which prompts you with @. At
this point you can then do anything, and you may get back to MM by typing
POP.
/]
.PUSH:	CONFRM
	SKIPLE A,EXECFK
	 JRST [	CALL RUNFL2		;Already have one, just run it
		CALLRET .PUSH1]
	HRROI B,[ASCIZ/SYSTEM:EXEC.EXE/]
	CALL RUNFIL			;Else make a fork and run it
	MOVEM A,EXECFK			;And keep the fork handle
.PUSH1:	SKIPN MSGJFN			;Do we have a mail file?
	 RET				;No, don't do any check then
	SETZM CHKTIM			;Always check
	PUSH P,M			;Remember msg sequence
	SETZ M,				;Reparse entire file
	CALL CHECK0			;Did file change?
	 JRST [	CALL PARSEF		;Reparse anyway in case bits changed
		POP P,M
		RET]
	PUSH P,LASTM			;Save current last message for CHECKN
	CALL PARSEF			;Reparse the whole file
	CALLRET CHECKN			;Print new messages, restore M, return

;;;Erase fields

.ERSAL:	SETZM HDRPAG+700		;Reset subject
	SETZM TOLIST			;Reset to and cc pointers
	SETZM CCLIST
	SETZM BCCLST
	SETZM LCLIST
	SETZM FILIST
	SETZM NETLST
	SETZM REPDAT			;No reply date
	MOVEI A,TOPAG
	MOVEM A,FREETO			;Reset free space pointer
.ERSTX:	MOVE A,[POINT 7,TXTPAG]
	MOVEM A,TXTPTR			;Reset pointer to text space
	SETZM TXTPAG			;And make sure it starts with null
	MOVEI A,477777			;100 pages less null
	MOVEM A,TXTCNT
	DMOVE A,USRHDR			;User's headers from init file
	DMOVEM A,USRHDR+2		;Set up as current user headers
	MOVEI B,0
	IDPB B,A			;Make sure they end with a null
	RET

.ERSDT:	SETZM REPDAT			;No reply date
	RET

.ERSSB:	SETZM HDRPAG+700
	RET

.ERSBC:	MOVEI T,BCCLST			;Erase bcc list
	CALLRET ERSTO0

.ERSCC:	SKIPA T,[CCLIST]		;Erase cc list
.ERSTO:	 MOVEI T,TOLIST			;Erase to list
ERSTO0:	HRRZ W,(T)
	JUMPE W,ERSTO2
ERSTO1:	CALL REMLST			;Remove from transmission medium list
	HRRZ W,(W)			;Get next in list
	JUMPN W,ERSTO1
ERSTO2:	SETZM (T)
	SKIPN CCLIST			;All list empty now?
	 SKIPE TOLIST
	  RET
	SKIPE BCCLST
	 RET
	MOVEI A,TOPAG			;Yes, reset free pointer
	MOVEM A,FREETO
	RET

;;;Display fields

.DSREP:	MOVE A,[PBOUT]			;Display reply text
	TLZ F,(F%AT)			;Don't show network headers
	CALL MOVTO0
	CALL MOVCC1
	CALL MOVUS1
	CALL MOVSB1
	SKIPG REPDAT
	 RET				;No reply date
	MOVEI O,.PRIOU
	CALLRET MOVRDT

.DSALL:	MOVE A,[PBOUT]			;Set up to type it out to tty
	CALL MOVUS0
	CALL MOVSB1
	TLZ F,(F%AT)			;Don't show network headers
	CALL MOVTO1
	CALL MOVCC1
	CALL MOVBC1
	CALLRET MOVTX1

.DSRST:	MOVE A,[PBOUT]			;Set up to type it out to tty
	CALL MOVUS0
	CALL MOVSB1
	TLZ F,(F%AT)			;Don't show network headers
	CALL MOVTO1
	CALLRET MOVCC1

.DSSUB:	SKIPA B,[MOVSB0]
.DSTXT:	 MOVEI B,MOVTX0
	CALLRET .DSCC1

.DSTO:	SKIPA B,[MOVTO0]
.DSCC:	 MOVEI B,MOVCC0
.DSCC1:	MOVE A,[PBOUT]
	TLZ F,(F%AT)			;Don't ever type network type for local
	CALLRET (B)

.DSBCC:	MOVEI B,MOVBC0
	CALLRET .DSCC1

MOVUSH:	MOVE A,[IDPB A,O]
MOVUS0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVUS1:	SKIPN USRHDR+2			;Has any user headers?
	 RET				;No, none
	MOVEI B,CRLF0			;Put in crlf first
	CALL MOVSB2
	MOVEI B,USRHDR+4
	CALLRET MOVSB2			;Go add that in

MOVSUB:	MOVE A,[IDPB A,O]		;Output subject
MOVSB0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVSB1:	LDB A,[POINT 7,HDRPAG+700,6]
	JUMPE A,CPOPJ			;No subject
	MOVEI B,[ASCIZ/
Subject: /]
	CALL MOVSB2			;Print header part
	MOVEI B,HDRPAG+700		;Start of actual string
MOVSB2:	HRLI B,(<POINT 7,0>)
MOVSB3:	ILDB A,B			;Get char
	JUMPE A,CPOPJ			;Done
	XCT MOVDSP			;Handle it
	JRST MOVSB3

MOVTXT:	MOVE A,[IDPB A,O]		;Output text
MOVTX0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVTX1:	MOVEI B,[ASCIZ/

/]
	CALL MOVSB2
	MOVEI B,TXTPAG
	CALL MOVSB2
	LDB A,TXTPTR
	MOVEI B,CRLF0
	CAIE A,12			;Unless ended with CRLF
	 CALL MOVSB2			;Put one in
	MOVEI B,[ASCIZ/-------
/]
	CALLRET MOVSB2			;And end it up

MOVBC0:	MOVEM A,MOVDSP			;Output BCC
MOVBC1:	MOVEI T,[ASCIZ/
Bcc: /]
	HRRZ W,BCCLST
	CALLRET MOVTO2

MOVCC:	MOVE A,[IDPB A,O]		;Output CC
MOVCC0:	MOVEM A,MOVDSP
MOVCC1:	MOVEI T,[ASCIZ/
cc: /]
	HRRZ W,CCLIST
	CALLRET MOVTO2

MOVTO:	MOVE A,[IDPB A,O]		;Output to
MOVTO0:	MOVEM A,MOVDSP
MOVTO1:	MOVEI T,[ASCIZ/
To: /]
MOVTRM:	HRRZ W,TOLIST
MOVTO2:	JUMPE W,CPOPJ			;None here, forget it
	SKIPL (W)			;Show this one in headers, etc?
	 JRST MOVT31			;Yes, ok
	HRRZ W,(W)			;No, get next one
	JRST MOVTO2

MOVTO3:	SKIPN HDR733			;RFC733 continuation lines?
MOVT31:	 SKIPA B,T			;No, use keyword then
MOVT32:	  MOVEI B,[ASCIZ/
    /]					;Yes, just indent
	CALL MOVSB2			;Print header
	MOVEI X,3			;Init horizontal position
MOVTO4:	MOVEI B,4(W)			;Get name
	TLZ F,(F%F1)			;First time through
MOVTO5:	HRLI B,(<POINT 7,0>)
MOVTO6:	ILDB A,B
	JUMPE A,MOVTO7
	XCT MOVDSP
	AOJA X,MOVTO6

MOVTO7:	TLOE F,(F%F1)			;This the first time through?
	 JRST MOVTO9			;No, done with this address
	LDB A,[POINT 4,(W),8]		;Get type field
	CAIN A,3			;Distribution list?
	 JRST MOVT10			;Yes, handle that
	JUMPN A,MOVTO8			;Non-local recipient
	TLNN F,(F%AT)			;This going out over network?
	 JRST MOVTO9			;No, that is enough for local then
	TDZA B,B			;Yes, use local host then
MOVTO8:	 MOVE B,2(W)			;Get host number
	HRROI A,STRBUF
	CALL $CVHST			;Put in name
	MOVEI B,[ASCIZ/ at /]
	CALL MOVSB2
	ADDI X,4			;Count 4 chars for this
	MOVEI B,STRBUF
	JRST MOVTO5

MOVT10:	MOVEI B,[ASCIZ/:/]
	SKIPE HDR733			;RFC733 style?
	 MOVEI B,[ASCIZ/: ;/]		;Yes, empty list then
	JRST MOVTO5

MOVTO9:	HRRZ W,(W)			;Get next in list
	JUMPE W,CPOPJ
	SKIPGE (W)			;Print it?
	 JRST MOVTO9			;No, try next then
	MOVEI A,","
	XCT MOVDSP
NEWQ,<
	TLNE F,(F%NEWQ)			;Always generate continuation line
	 AOJA E,MOVT32
>;NEWQ
	CAIL X,^D65			;Near end?
	 AOJA E,MOVTO3			;Yes, get new line for more then
	MOVEI A," "
	XCT MOVDSP
	ADDI X,2
	JRST MOVTO4

MOVRDT:	MOVEI B,[ASCIZ/
In-Reply-To: Your message of /]
	CALL MOVSB2
	MOVE A,O
	MOVE B,REPDAT
	MOVSI C,(OT%NSC!OT%NCO!OT%TMZ!OT%SCL)
	ODTIM
	MOVE O,A
	RET

NEWQ,<
MOVMHN:	TLNN F,(F%NEWQ)
	 JRST [	MOVEI B,MYHNAM
		CALLRET MOVSTR]
	MOVEI B,[BYTE (7) " ","a","t"," ",177,0]
	CALL MOVSTR
	MOVE B,[POINT 7,MYHNAM,27]
	CALL MOVST1
	MOVEI B,177
	IDPB B,A
	RET
>;NEWQ

;;;Get some more text

GETTXT:
IFN VPRMTF,<
	MOVEI A,[ASCIZ/end with ESCAPE or ^Z/]
	TRNN F,F%RSCN
	 SKIPGE ESCSND
	  MOVEI A,[ASCIZ/ESCAPE to MM command level, ^Z to send/]
	SKIPLE ESCSND
	 MOVEI A,[ASCIZ/^Z to MM command level, ESCAPE to send/]
	CIETYP < Message (%1S):
>
>;IFN VPRMTF
IFE VPRMTF,<
	CITYPE < Msg:
>
>;IFE VPRMTF
	CALLRET .TEXT0

.HSTEX:	[ASCIZ/
The TEXT command allows you to continue typing the text of the message.
/]
.TEXT:	CONFRM
.TEXT0:	CALL SETABO			;Allow ^N
.TEXT1:	MOVEI A,TTXTIB
	TEXTI
	 JERROR
	LDB B,TXTPTR
	MOVEM B,LSTCHR			;Save terminator
	SETZ A,
	DPB A,TXTPTR			;Replace terminator with null
	SETO A,
	ADJBP A,TXTPTR
	MOVEM A,TXTPTR
	AOS TXTCNT
	CAIN B,CTL(B)			;^B inserts file
	 JRST TXTFIL
IFE CTLEKF,<
	CAIN B,CTL(E)			;^E - enter editor on text
>;IFE CTLEKF
IFN CTLEKF,<
	CAIN B,CTL(K)			;^K - enter editor on text
>;IFN CTLEKF
	 JRST TXTED
IFE CTLEKF,<
	CAIN B,CTL(K)			;Wants retype of whole thing?
>;IFE CTLEKF
IFN CTLEKF,<
	CAIN B,CTL(E)			;Wants retype of whole thing?
>;IFN CTLEKF
	 JRST .TEXT2
	CAIE B,CTL(L)			;Clear and retype?
	 RET				;No, must have terminated right
	CALL BLANK1			;Yes
	CITYPE < Msg:>
.TEXT2:	CALL CRIF
	HRROI A,TXTPAG			;Start of stuff
	PSOUT
	JRST .TEXT1			;And go get some more

TXTFIL:	PROMPT <(Insert file: >
	MOVEI B,TXTFL1
	HRRM B,CMDBLK+.CMFLG
	MOVEI A,CMDBLK
TXTFL1:	MOVEI B,[FLDDB. .CMIFI]
	COMND
	TLNE A,(CM%NOP)
	 JRST TXTFLE
	MOVEM B,TMPJFN
	MOVEI B,[FLDDB. .CMCFM]
	COMND				;Confirm
	TLNE A,(CM%NOP)
	 JRST TXTFLE
	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST TXTFLE
	CALL INSFL3
	TYPE <...EOF)
>
	JRST .TEXT1

TXTFLE:	JWARN				;Error getting file, return for text
	CALL CRLF
	JRST .TEXT1

TXTED:	CALL CRIF			;Edit text, get fresh line
	CALLRET EDTXT0			;And go start doing it

.HSINS:	[ASCIZ/
The INSERT command takes one argument, a filename. It inserts that file
after the current text of the message.
/]
.INSFL:	MOVEI B,[FLDDB. .CMIFI]
	CALL CMDFLD			;Get the file
	MOVEM B,TMPJFN
	CONFRM
	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST [	JWARN (Can't open input file)
		CALLRET CRLF]
INSFL3:	MOVE B,TXTPTR
	MOVN C,TXTCNT
	SIN
	CLOSF
	 NOP
	SETOM TMPJFN
	SKIPL C
	 ERROR (Buffer overflow - file too large)
	EXCH B,TXTPTR		;B - source of copy to remove nulls
	MOVE A,B		;A - dest of copy
	MOVNM C,TXTCNT		;C - current character
INSFL1:	CAMN B,TXTPTR		;TXTPTR - end of source text
	 JRST INSFL2
	ILDB C,B		;copy 
	SKIPE C			;removing nulls
	 IDPB C,A
	SKIPN C			;each one skipped increases free space
	 AOS TXTCNT
	JRST INSFL1
INSFL2:	MOVEM A,TXTPTR		;updated end of text
	RET

.HSSUB:	[ASCIZ/
The SUBJECT command takes a line of text as an argument to make the
subject of the message you are sending.
/]
;;;Get a new subject

GETSUB:	TRZ F,F%HOER			;No more error halting
	PROMPT < Subject: >
	CALL SETABO			;Allowed to ^N out of here
.SUBJE:	CALL GETLIN
	JUMPE B,.ERSSB			;None given, erase the subject then
	MOVE A,[STRBUF,,HDRPAG+700]
	BLT A,HDRPAG+777		;Move over the subject
	RET

.HSBCC:	[ASCIZ/
The BCC command takes an argument consisting of addresses separated by
commas. These addresses will receive blind carbon copies of your outgoing
message which means that those recipients who are addressed in the normal
manner, i.e. TO: and CC: will not see that the BCC: addresses have
received the message as well.
/]

.BCC:	PUSH P,[BCCLST]			;Add someone to bcc list
	CALLRET CC1

.HSCC:	[ASCIZ/
The CC command takes an arugment consisting of addresses separated by
commas. These addresses will receive carbon copies of your outgoing
message.
/]
GETCC:	PROMPT < cc: >
	CALL SETABO
.CC:	PUSH P,[CCLIST]
CC1:	TLO F,(F%CC)			;Say in cc command
	CALLRET .TO2			;And enter TO command

.HSTO:	[ASCIZ/
The TO command takes a list of addresses separated by commas as an
argument.  It adds these address as to recipients for the message.
/]
GETTO:	PROMPT < To: >
GETTO0:	CALL SETABO
.TO:	PUSH P,[TOLIST]			;What list to add to
	TLZ F,(F%CC)
.TO2:	TLZ F,(F%F3!F%COMA!F%F4)	;Don't allow funny local names
	MOVE W,FREETO			;Start with some free space
	PUSH P,CMDRET			;Save error dispatch
.TO3:	CALL GETUSR			;Get the user name
	 JRST .TO4			;Null field, return
	TLNE F,(F%COMA)			;Comma seen?
	 JRST .TO3			;Yes, get another then
.TO4:	POP P,CMDRET
	POP P,T				;Get list to add to
	CALLRET ADDTO0			;Now add the whole line in and return

;;;Get prompted message

GETMSG:	CALL GETTO
	CALL GETCC
GETMS1:	CALL GETSUB
	CALLRET GETTXT

.HSUNT:	[ASCIZ/
The REMOVE command takes a list of addresses separated by commas as an
argument. It removes those from the recipient lists of the message.
/]

;;;Remove user

.UNTO:	TLZ F,(F%COMA!F%F4)		;No comma seen yet
	TLO F,(F%F3)			;Allow funny addresses
	MOVE W,FREETO			;Some random space to use
.UNTO1:	CALL GETUSR			;Get a user name
	 ERROR (Null address illegal)
	TLNE F,(F%COMA)			;Wants more?
	 JRST .UNTO1			;Yes, get them
	HRRZS W				;Just in case
	PUSH P,W			;Save tail of list
	HRRZ U,FREETO			;Get head of list
.UNTO2:	PUSH P,U			;Save current pointer
	MOVEI U,4(U)			;Point to text of name
	SETZ N,				;Allow 0 occurances of that name
	CALL DOUNTO			;Remove the name
	JUMPE N,[ERROR (Address "%7S" not found)]
	POP P,U
	LDB B,[POINT 9,(U),17]		;Get size
	ADDI U,(B)
	CAME U,(P)			;End of list yet?
	 JRST .UNTO2
	ADJSP P,-1			;No more, fix up stack and return
	RET

;;;Remove name from string in U, allowing only (n) occurances

DOUNTO:	MOVEI V,TOLIST			;Get to pointers
	CALL DOUNTL
	MOVEI V,CCLIST
	CALL DOUNTL
	MOVEI V,BCCLST
DOUNTL:	MOVEM V,UNTHDR			;Save header address for fixing last
DOUNT0:	HRRZ W,(V)
	JUMPE W,CPOPJ			;None of this class
	MOVEI B,(U)			;Target string
	HRLI B,(<POINT 7,0>)
	MOVEI A,4(W)			;This particular one
	HRLI A,(<POINT 7,0>)

DOUNT1:	ILDB C,B			;Get char from target
	ILDB D,A
	JUMPE C,DOUNT3			;Null means it matches
	CAIN D,(C)
	 JRST DOUNT1			;Chars match?
	TRC D,(C)
	CAIN D,40			;Case only?
	 JRST DOUNT1			;Yes, keep looking
DOUNT2:	MOVEI V,(W)			;Setup to get next in list
	JRST DOUNT0

DOUNT3:	JUMPN D,DOUNT2
	SOJGE N,DOUNT2			;Count one more occurance
	LDB A,[POINT 9,(W),17]		;Get length of this block
	ADDI A,(W)			;Point to start of next block
	CAMN A,FREETO			;Was this the last entry?
	 MOVEM W,FREETO			;Yes, just update end pointer
	CALL REMLST			;Remove from transmission medium list
	HRRZ W,(W)			;Get next link in to/cc list
	HRRM W,(V)			;Relink previous
	JUMPN W,DOUNT0			;If this is the end of the list now
	HRLM V,@UNTHDR			;Update last (this fixes a bug)
	CAIE V,TOLIST			;Was this the head of the list?
	 CAIN V,CCLIST
	  SETZM (V)			;Yes, clear whole thing
	CAIN V,BCCLST
	 SETZM (V)
	JRST DOUNT0

SPELL,<
SUBTTL SPELL interfacing subroutines

.HRSPE:	[ASCIZ/
The SPELL command invokes the SPELL program on the whole message.
See the SPELL program's documentation for how to use it.
/]

.HSSPE:	[ASCIZ/
The SPELL command invokes the SPELL program in the TEXT field of the message.
See the SPELL program's documentation for how to use it.
/]

;;;SEND/REPLY command entry
.SSPEL:	CONFRM
	CALL SPLSET			;Set up for SPELL
	MOVE A,[POINT 7,TXTPAG]		;Starting byte pointer
	MOVE B,TXTPTR			;Ending one
	CALL SPLLEN			;Compute size of field
	CALL SPLICP			;Copy it into SPELL's input file
	CALL SPLGET			;Set up the SPELL fork
	CALL SPLRUN			;Run SPELL
	 RET
	MOVE A,[POINT 7,TXTPAG]		;Put updated text here
	MOVEI C,NTXPGS*1000*5		;Maximum size of receiving area
	CALL SPLOCP			;Get the updated text
	MOVEM B,TXTPTR			;Update end of text pointer
	SETZ C,
	IDPB C,B			;End it with a null too
	CALLRET SPLCLN			;Cleanup and return

;;;READ command entry
.RSPEL:	CONFRM				;Spell check this message
	CALL CHKDEL			;Make sure there is a message
	 RET
	CALL SPLSET			;Set up for SPELL
	HRRZ V,MSGBOD(M)
	CALL MCH2BP			;Get byte pointer to the message
	HLRZ C,MSGBOD(M)		;And its length
	CALL SPLICP			;Copy the msg and return
	CALL SPLGET			;Set up the SPELL fork
	CALL SPLRUN			;Run SPELL
	 RET
	MOVE A,[POINT 7,SPLPAG]		;Get the updated msg into here
	MOVEI C,NEDPGS*1000*5		;Size of that area
	CALL SPLOCP			;Get the updated msg
	CALL RPLMSG			;Replace the current msg with it
	CALLRET SPLCLN			;Cleanup and return

;;;Routine to set up temp file for SPELL to use as input
;;;On exit:
;;; SPLIFL/ JFN to the text to correct
;;; SPLOFL/ JFN of temp file for SPELL to return text in
;;;Clobbers ACs: A, B

SPLSET:	MOVSI A,(GJ%FOU!GJ%SHT!GJ%TMP)	;Get a temp file for SPELL input
	HRROI B,[ASCIZ/MM-SPELL-IN.TMP/]
	GTJFN
	 JERROR (Can't get SPELL input temporary file)
	MOVE B,[7B5+OF%WR]		;We want to write msg into it
	OPENF
	 JERROR (Can't open SPELL input temporary file)
	MOVEM A,SPLIFL			;Save it
	MOVSI A,(GJ%FOU!GJ%SHT!GJ%TMP)	;Get SPELL's output file
	HRROI B,[ASCIZ/MM-SPELL-OUT.TMP/]
	GTJFN
	 JERROR (Can't get SPELL output temporary file)
	MOVEM A,SPLOFL
	RET				

;;;Routine to compute the size of the current TEXT field
;;;On entry:
;;; A/ start byte pointer of field
;;; b/ end byte pointer of field
;;;On exit:
;;; C/ size of field in characters
;;;Clobbers ACs: B

SPLLEN:	LDB C,[POINT 6,B,5]
	IDIVI C,7			;Get chars within word
	SUBI B,(A)
	HRREI B,(B)			;Get number of words
	IMULI B,5			;Into chars
	SUBI B,(C)			;Get total number of chars
	LDB C,[POINT 6,A,5]
	IDIVI C,7
	ADDI B,(C)
	MOVE C,B			;Leave size in AC c
	RET

;;;Routine to copy text into SPELL's input file
;;;On entry:
;;; A/ start of text pointer
;;; C/ length of field in characters
;;; SPLIFL/ SPELL's input file opened for write
;;;On exit:
;;; SPLIFL/ good JFN, but closed
;;;Clobbers ACs: A, B, C

SPLICP:	MOVE B,A
	MOVE A,SPLIFL
	MOVNS C
	SOUT
	HRLI A,(CO%NRJ)			;Don't release the JFN
	CLOSF
	 JFATAL
	RET

;;;Routine to get a SPELL fork
;;;On exit:
;;; A/ fork handle just gotten
;;; SPLFRK/ fork handle which is ready to run SPELL in
;;;Clobbers ACs: a,b

SPLGET:	SKIPE A,SPLFRK			;Do we have a fork yet?
	 JRST SPLGE1			;Yes, just fill in the fork
	MOVSI A,(CR%CAP)		;Create a fork for SPELL
	CFORK
	 JERROR (Can't create SPELL fork)
	MOVEM A,SPLFRK			;Save the fork handle
SPLGE1:	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,SPLNAM			;Name of SPELL program
	GTJFN
	 JERROR (Can't find find SPELL program)
	HRL A,SPLFRK			;Get the fork handle again
	GET
	HLRZS A				;Return with the fork handle in A
	RET

;;;Routine to run SPELL
;;;On entry:
;;; SPLFRK/ fork handle of SPELL or 0 if none yet
;;; SPLIFL/ JFN of the text to correct (should be in the file already)
;;; SPLOFL/ JFN of where to write the corrected code
;;;Clobbers ACs: A, B, C

SPLRUN:	MOVEI B,SPLACS			;Get the old ACs
	RFACS
	MOVE C,SPLIFL			;Set the input
	MOVEM C,A(B)
	MOVE C,SPLOFL			;And output JFNs in SPELL's ACs
	MOVEM C,B(B)
	SFACS
	MOVEI B,SPLOFF			;Start SPELL, HERMES entry point
	SFRKV
	 ERJMP [JSNARL (Can't start SPELL)
		CALLRET SPLCLN]
	WFORK				;And wait for SPELL to finish
	DMOVE A,PRGNAM			;Restore our program name
	SETSN
	 JFATAL
	RETSKP

;;;Routine to get (into the edit buffer) the changed text
;;;On entry:
;;; A/ pointer to where to put the text
;;; C/ size of where to put the text
;;; SPLOFL/ JFN for SPELL's output file (not opened)
;;;On exit:
;;; SPLOFL/ same JFN, but closed
;;; A/ pointer to buffer
;;; B/ pointer to end of buffer
;;; C/ count (in characters) of size of buffer
;;;Clobbers AC: B

SPLOCP:	PUSH P,A			;Save where to put the text
	PUSH P,C			;And size of area
	MOVE A,SPLOFL			;Get the JFN again
	MOVE B,[7B5+OF%RD]		;Open for read this time
	OPENF
	 JERROR
	MOVE B,-1(P)			;Get the start of the area
	MOVN C,(P)			;Maximum count
	SIN				;Read it in there
	HRLI A,(CO%NRJ)			;Don't release the JFN (yet)
	CLOSF
	 NOP
	ADD C,(P)			;Compute byte count
	POP P,A
	POP P,A				;And point to start of text
	RET

;;;Routine to clean up after finishing with SPELL this time
;;;On exit:
;;; SPLIFL/ garbage
;;; SPLOFL/ garbage
;;;Clobbers ACs: a

SPLCLN:	HRRZ A,SPLIFL
	TLO A,(DF%EXP)			;Delete and expunge the input file
	DELF
	 NOP				;Ignore errors
	HRR A,SPLOFL			;Same here
	DELF
	 NOP
	RET
>;SPELL

SUBTTL Editor interfacing subroutines

.HEDIT:	[ASCIZ/
The EDIT command takes one argument, a message sequence.  It proceeds to
edit each message in that message sequence using the editor specified in
your MM.INIT file.
/]

;;;Edit commands

.EDIT:	CALL DFSQTH			;Edit specifies messages
	MOVEI A,.REDI1
	CALLRET DOMSGS

.REDIT:	CONFRM				;Edit this message
.REDI1:	CALL CHKDEL
	 RET
	CALL SEDMSG			;Set editor to munge current message
	TRNN F,F%TECO			;Teco based?
	 JRST .REDI2			;No
	MOVE A,EDBPAG+0(T)		;BJ
	MOVEM A,EDBPAG+2(T)
.REDI2:	DMOVE A,[ASCIZ/Message/]
	DMOVEM A,EDINAM
	DMOVEM A,BUFNAM
	CALL RESTED			;Now edit it
	CALL GEDBUF			;Get the editted text
	 CAIA				;If changed,
	  CALL RPLMSG			;Replace current message with that
	CALLRET .EDFIN			;Go restore tty modes
	
;;;Prepare for editting the current message

SEDMSG:	DMOVE A,[ASCIZ/Message/]
	DMOVEM A,BUFNAM
	HRRZ V,MSGBOD(M)
	CALL MCH2BP			;Get byte pointer to message
	HLRZ B,MSGBOD(M)		;And length
	CALLRET EDREPL			;Load message into the editor

;;;Edit message text

.EDTXT:					;Used to be a CONFRM here
EDTXT0:	CALL CLRABO			;Don't ^N out of editor
	DMOVE A,[ASCIZ/Reply/]
	TRNN F,F%RPLY
	 DMOVE A,[ASCIZ/Send/]
	DMOVEM A,EDINAM			;Name of edit type
	DMOVE A,[ASCIZ/Reply/]		;Name of the buffer
	DMOVEM A,BUFNAM
	MOVE A,[POINT 7,TXTPAG]		;Starting byte pointer
	MOVE B,TXTPTR			;Ending one
	CALL SEDBUF			;Setup editor text
	TRNN F,F%TECP			;Hairy interface?
	 JRST EDTXT1			;No, just edit this field
	CALL SEDMSG			;Put message in the message buffer
	CALL SEDHDR			;And headers in the headers buffer
EDTXT1:	DMOVE A,[ASCIZ/Reply/]
	DMOVEM A,BUFNAM
	CALL RESTED			;Run the editor
	CALL GEDTXT			;Get the new text
	TRNN F,F%TECP
	 JRST .EDFIN
	CALL GEDHDR			;Get updated headers if need be
	CALLRET .EDFIN

;;;Get it back and update if necessary

GEDTXT:	DMOVE A,[ASCIZ/Reply/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get the editted text
	 RET				;Isnt changed
	MOVE B,[POINT 7,TXTPAG]		;Replace it here
	CALL FRMSS1			;Move string
	MOVEM B,TXTPTR			;Update pointer
	SETZ D,
	IDPB D,B			;And end with a null too
	RET

;;;All done, restore TTY modes for program

.EDFIN:	MOVEI D,EDMOD			;Save editor modes
	CALL GETTYM
	MOVEI D,SAVMOD			;And restore ours
	CALLRET SETTYM

;;;Edit headers

.EDHEA:	DMOVE A,[ASCIZ/Default/]
	DMOVEM A,EDINAM
	CALL SEDHDR			;Put in headers
	CALL RESTED			;Edit them
	CALL GEDHDR			;Get new ones
	CALLRET .EDFIN			;And all done

;;;Put in headers

SEDHDR:	MOVE O,[POINT 7,WRTPGS]		;Some temp space
	CALL MOVTO
	CALL MOVCC1
	CALL MOVSUB
	CALL MOVUSH
	DMOVE A,[ASCIZ/Headers/]
	DMOVEM A,BUFNAM
	MOVE A,[POINT 7,WRTPGS]		;Starting pointer
SEDHD1:	ILDB B,A
	CAIE B,15			;Move over blank lines
	 CAIN B,12
	  JRST SEDHD1
	ADD A,[7B5]
	MOVE B,O			;Ending one
	CALLRET SEDBUF			;Setup editor for that

;;;Get the new headers

GEDHDR:	DMOVE A,[ASCIZ/Headers/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get what it gave back
	 RET				;Didnt change
	PUSH P,A			;Save pointers to editor text
	PUSH P,C
	CALL .ERSTO			;Erase to field
	CALL .ERSCC			;And cc field
	CALL .ERSSB			;And subject field
	POP P,C				;Get back pointers
	POP P,A
	JUMPLE C,CPOPJ			;No text there
	ADJBP C,A			;Get ending byte pointer
	SETZ D,
	IDPB D,C			;Put a null at the end
	TLZ F,(F%CC!F%AT)		;Start with to field
	SETZ E,				;No default host name
GEDHD1:	ILDB B,A			;Get next char
	CAIE B,11			;Whitespace indicates continuation
	 CAIN B," "
	  JRST GEDHDS
	CAIE B,"T"			;More to maybe
	 CAIN B,"t"
	  JRST GEDHTO
	CAIE B,"C"			;Or maybe start of cc
	 CAIN B,"c"
	  JRST GEDHCC
	CAIE B,"s"
	 CAIN B,"S"
	  JRST EDSUBJ			;Get the subject now
GEDHD2:	CAIN B,12			;Saw linefeed yet?
	 JRST GEDHD1			;Yes, try this line
	JUMPE B,CPOPJ			;Keep on going unless EOM
	ILDB B,A			;Otherwise soak up line
	JRST GEDHD2

GEDHTO:	ILDB B,A
	CAIE B,"O"
	 CAIN B,"o"
	  CAIA
	   JRST GEDHD2			;Soak up line if no match
	ILDB B,A
	CAIE B,":"
	 JRST GEDHD2			;No good I guess
GEDHDS:	CALL PRADDT			;Parse this line
	LDB B,A				;Get terminating character
	JUMPE B,CPOPJ			;Null means all done now
	CAIN B,15			;Was terminator CR?
	 IBP A				;Yes, move over the LF too
	JRST GEDHD1			;Try for another line

GEDHCC:	ILDB B,A
	CAIE B,"C"
	 CAIN B,"c"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,":"
	 JRST GEDHD2
	TLO F,(F%CC)			;Now doing cc
	JRST GEDHDS			;And now go get addresses

EDSUBJ:	ILDB B,A
	CAIE B,"U"
	 CAIN B,"u"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,"B"
	 CAIN B,"b"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,"J"
	 CAIN B,"j"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,"E"
	 CAIN B,"e"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,"C"
	 CAIN B,"c"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,"T"
	 CAIN B,"t"
	  CAIA
	   JRST GEDHD2
	ILDB B,A
	CAIE B,":"
	 JRST GEDHD2
EDSUB1:	ILDB B,A
	JUMPE B,CPOPJ
	CAIE B,12
	 CAIN B,15
	  JRST GEDHD2
	CAIE B,40
	 CAIN B,11
	  JRST EDSUB1
	MOVE C,[POINT 7,HDRPAG+700]
EDSUB2:	IDPB B,C
	ILDB B,A
	CAIE B,15
	 CAIN B,12
	  SETZ B,
	JUMPN B,EDSUB2
	IDPB B,C
	JRST GEDHD2

;;;Setup the editor's text

SEDBUF:	LDB C,[POINT 6,B,5]
	IDIVI C,7			;Get chars within word
	SUBI B,(A)
	HRREI B,(B)			;Get number of words
	IMULI B,5			;Into chars
	SUBI B,(C)			;Get total number of chars
	LDB C,[POINT 6,A,5]
	IDIVI C,7
	ADDI B,(C)
;	CALLRET EDREPL			;Run editor over this field

;;;Replace the editor's buffer with a given string, pointer in A, byte count in B

EDREPL:	PUSH P,A			;Save pointer
	PUSH P,B			;Save char count
	SKIPLE EDFORK			;If don't have a fork yet,
	 JRST EDREP1
	CALL GETED			;Get one now
	TRNN F,F%TECO			;If it isnt teco based,
	 JRST EDREP2			;Do it thru a temp file
	MOVEI B,[ASCIZ/0fsexit/]	;Telling it to return right away,
	CALL MOVST0
	CALL RUNED			;Start up the editor
	SKIPN FRKACS+3			;Exitted other than with 0?
	 JRST EDREP1
	TRO F,F%TECP			;Say have hairy editor interface
	CALL RESTE0			;And continue it
EDREP1:	MOVEI D,EDMOD			;Restore editor tty modes
	CALL SETTYM
	LDB T,[POINT 9,FRKACS+2,35]	;Get position in page
	TRNE F,F%TECP			;Fancy interface, fssuperior will
	 JRST EDREP3			;Do it all, and in the right buffer
	MOVE B,EDBPAG+5(T)		;Save addr of end of buffer
	MOVSI A,EDBPAG+0(T)		;Start with beginning addr
	HRRI A,EDBPAG+1(T)		;Into virtual beg
	BLT A,EDBPAG+5(T)		;Up to end pointer
	SUB B,EDBPAG+5(T)		;See how many chars we "deleted"
	ADDM B,EDBPAG+6(T)		;Increase the gap that many
	SETZM EDBPAG+9(T)		;Not modified yet
EDREP3:	MOVE B,(P)			;Get char count
	CALL EDINS			;Call worker routine
	 JRST [	ADJSP P,-3		;EDINSC backed out of, percolate it up
		RET]			; to SEDxxx's caller
	POP P,C				;Get back char count
	POP P,B				;Get back byte pointer
	ILDB D,B
	IDPB D,A
	SOJG C,.-2			;For all requested
	RET

EDINS:	CALL EDINSC			;Request it to insert
	MOVE A,EDBPAG+2(T)		;Address of current position
	SUB A,-1(P)			;Back over the chars to be inserted
	CALL EDCHR1			;Get byte pointer
	RETSKP

;;;Do it thru a temp file for non-teco editors

EDREP2:	PUSH P,A			;Save start of JCL
	MOVSI A,(GJ%SHT!GJ%FOU)		;Note: can't use GJ%TMP because
	MOVE B,[7B5+OF%WR]		; of cretinous release 4 EDIT
	CALL GEDTMP
	EXCH A,(P)			;Get back pointer for JCL
	MOVE B,(P)
	MOVE C,[001110,,JS%PAF]
	JFNS
	MOVEI B,[ASCIZ/
/]					;Finish up command line
	CALL MOVST0
	POP P,A				;Recover JFN
	POP P,C				;Recover byte point
	MOVN C,C
	POP P,B				;Recover string
	SOUT				;Write it out
	CLOSF
	 NOP
	CALLRET RUNED			;And go start it

;;; Generate a temp file unique to this job

GEDTMP:	PUSH P,B			;Save OPENF args
	PUSH P,A			;Save GTJFN args
	GJINF
	HRROI A,STRBUF+20		;Some string space
	MOVEI B,(C)			;Job number
	MOVE C,[NO%LFL!NO%ZRO+3B17+^D10]
	NOUT
	 MOVE A,[POINT 7,STRBUF+20]
	MOVEI B,[ASCIZ/MM.TMP.0/]
	CALL MOVST0
	POP P,A
	HRROI B,STRBUF+20
	GTJFN
	 JERROR (Can't get TMP file)
	POP P,B
	OPENF
	 JERROR (Can't open TMP file)
	RET

;;;Here to make a new editor, returns with start of JCL in A and F%TECO
;;;setup correctly

GETED:	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]	;Allows:
	BLT A,CMDGTB+.GJATR		; DEFINE EDITOR:SYS:EMACS
	MOVSI A,(GJ%OLD)		;to work instead of only:
	MOVEM A,CMDGTB+.GJGEN		; DEFINE EDITOR:SYS:EMACS.EXE
	MOVE A,[.NULIO,,.NULIO]		;--subtle, but consistent with
	MOVEM A,CMDGTB+.GJSRC		;  how EXEC handles same...
	HRROI A,[ASCIZ/EXE/]
	MOVEM A,CMDGTB+.GJEXT
	MOVEI A,CMDGTB
	HRROI B,[ASCIZ/EDITOR:/]
	GTJFN
REL3,<
	 CAIA
	  JRST GETED0
	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR
	MOVSI A,(GJ%OLD)
	MOVEM A,CMDGTB+.GJGEN
	MOVE A,[.NULIO,,.NULIO]
	MOVEM A,CMDGTB+.GJSRC
	HRROI A,[ASCIZ/SYS/]
	MOVEM A,CMDGTB+.GJDEV
	HRROI A,[ASCIZ/EXE/]
	MOVEM A,CMDGTB+.GJEXT
	MOVEI A,CMDGTB
	HRROI B,EDITOR			;Name of user's editor
	GTJFN
>;REL3
	 JERROR (Can't get editor)
GETED0:	PUSH P,A			;Save JFN around fork creation
	MOVSI A,(CR%CAP!CR%ACS)
	MOVEI B,FRKACS			;Set these initial ac's
	CFORK
	 JERROR (Can't create editor fork)
	MOVEM A,EDFORK			;Save it
	POP P,A				;Restore JFN
	MOVE B,[1,,.FBUSW]
	MOVEI C,C
	GTFDB				;Get user word
	TRZ F,F%TECO!F%TECP		;Assume not TECO based
	HLRZ C,C
	CAIN C,(<SIXBIT /TEC/>)		;Check for teco based
CLSC,<
	 TRO F,F%TECO			;Don't need msg since gen of .0 solves
>;CLSC
NOCLSC,<
	 TROA F,F%TECO			;It is, remember that
	  CIETYP <[%1J is not TECO based, you must write out file when done]
>
>;NOCLSC				;Make sure guy doesnt lose big
	MOVEI B,(A)			;Get file again
	HRROI A,STRBUF
	MOVSI C,001000			;Just name
	JFNS
	MOVEI C," "
	IDPB C,A
	PUSH P,A
	MOVEI A,(B)
	HRL A,EDFORK
	GET				;Get in the editor
	JRST CPOPAJ			;Restore string pointer and return

;;;Here to run the editor

RUNED:	HRROI A,STRBUF			;Set that up for user
	RSCAN
	 NOP
	MOVE A,EDFORK
	SETZ B,				;Start at normal entry
	SFRKV
	CALLRET WAITED

;;;Here to restart fork to edit something

RESTED:	TRNN F,F%TECO			;Already all done if not teco based
	 RET
	TRNN F,F%TECP			;Hairy interface?
	 JRST RESTE0			;Just resume editor
	MOVE A,[POINT 7,STRBUF]		;Else setup to tell all that's going on
	MOVEI B,[ASCIZ/FOO /]
	CALL MOVSTR
	MOVEI B,BUFNAM
	CALL MOVSTR
	MOVEI B,ESC
	IDPB B,A
	MOVEI B,EDINAM
	CALL MOVSTR
	MOVEI B,[ASCIZ/
/]
	CALL MOVST0
	CALLRET RUNED			;Start over so ..L run again
RESTE0:	MOVE A,EDFORK
	MOVE B,EFRKPC			;Forks old PC
	SFORK

;;;Here to wait for the editor fork

WAITED:	MOVE A,EDFORK
	RFORK				;Thaw it
	WFORK				;And wait for it to terminate
	DMOVE A,PRGNAM			;Restore our name
	SETSN
	 JFATAL
	MOVE A,EDFORK
	TRNE F,F%TECO			;TECO based?
	 JRST EDFTRM			;Yes, check on it's status
	KFORK				;No, can't reuse it
	SETOM EDFORK			;Forget we had it at all
	RET

;;;Here when fork terminates

EDFTRM:	FFORK				;Freeze it
	RFSTS				;Get its status
	TLZ A,(RF%FRZ)			;We know it's frozen already
	HLRZ A,A
	CAIE A,.RFHLT			;Voluntary termination?
	 JRST KILLED			;No, kill it off, it's bombed
	MOVEM B,EFRKPC			;Save the PC for restarting it
	MOVE A,EDFORK			;Need fork again
	RWM				;See why it stopped
	TLNE B,(1B1)			;Level 1 in progress?
	 JRST CTLCED			;Yes, means the guy ^C'd out
	MOVE A,EDFORK
	MOVEI B,FRKACS			;Get its AC's
	RFACS
	MOVE A,FRKACS+2			;Pointer to buffer block
	IDIVI A,1000			;Get page number of block
	MOVEI T,(B)			;Save position in page
	HRL A,EDFORK
	MOVE B,[.FHSLF,,EDBPAG/1000]	;Into our area
	MOVSI C,(PM%RD!PM%WR)		;Read write
	PMAP
	MOVE A,EDBPAG(T)		;Char address of beginning of buffer
	IDIVI A,5000			;Get page number
	HRL A,EDFORK
	MOVE B,[.FHSLF,,EDPAGE/1000]
	MOVE C,[PM%CNT+PM%RD+PM%WR+NEDPGS]
	PMAP				;Map those pages too, read/write
	LSH A,9				;Get word address
	HRREI A,-EDPAGE(A)
	MOVEM A,EDPAG0			;Save address of first page mapped
	HLRE A,FRKACS+3			;Negative argument to fs exit?
	JUMPGE A,CPOPJ			;No, done
	HRRE B,FRKACS+3			;Select a different message?
	JUMPL B,EDFTR2			;No
	IMULI B,MSGLEN
	CAMG B,LASTM			;And in range
	 MOVE M,B			;Select it
EDFTR2:	AOJE A,[TRO F,F%ESND		;-1fs exit to send the message off
		RET]
	AOJE A,[ADJSP P,-1		;-2fs exit says don't update fields
		CALLRET .EDFIN]
	AOJE A,[CALL SEDMSG		;-3fs exit says update current message
		CALLRET RESTE0]
	AOJE A,.REPL6			;-4fs exit says reply to this message
	RET

;;;Editor terminated badly

KILLED:	MOVE A,EDFORK
	KFORK				;Kill it off
	SETOM EDFORK			;And forget about it
	MOVEI D,SAVMOD			;Restore program's modes
	CALL SETTYM
	SNARL <Editor fork terminated involuntarily, edit lost>
	ADJSP P,-1			;Flush editor call
	RET				;And return to its caller

;;;^C typed from editor, make it percolate up

CTLCED:	HALTF
	CALLRET RESTE0			;And resume it afterwards

;;;Get the editted field

GEDBUF:	TRNN F,F%TECO			;Was this teco based editor
	 JRST GEDBF2			;No, get updated version of file
	SKIPE EDBPAG+11(T)		;Was buffer modified
	 AOS (P)			;Yes, skip return when done
	PUSH P,EDBPAG+4(T)
	POP P,EDBPAG+2(T)		;ZJ
	TRNN F,F%TECP			;Ordinary teco,
	 TDZA B,B			;Insert 0 chars
	  SETO B,			;Else negative so don't kill
	CALL EDINSC			;Move gap to end
	MOVE C,EDBPAG+4(T)
	SUB C,EDBPAG+1(T)		;Number of chars in it
	MOVE A,EDBPAG+1(T)		;Start of virtual buffer
	CALLRET EDCHRP			;Get byte pointer and return

GEDBF2:	MOVSI A,(GJ%OLD!GJ%SHT)
	MOVE B,[7B5+OF%RD]
	CALL GEDTMP			;Find the temp file again
	HRROI B,EDPAGE			;Where to put it
	MOVNI C,NEDPGS*1000*5
	SIN
	MOVEI B,0			;Editor may have made new non-temp vers
	DELNF
	 NOP
	CLOSF
	 NOP
	ADDI C,NEDPGS*1000*5		;Compute byte count
	MOVE A,[POINT 7,EDPAGE]
	RETSKP

;;;Convert char address to byte pointer, taking gap into account

EDCHRP:	CAML A,EDBPAG+3(T)
	 ADD A,EDBPAG+6(T)
EDCHR1:	IDIVI A,5
	SUB A,EDPAG0			;Make absolute
	HRL A,BPS(B)
	RET

;;;Request editor to insert (b) chars at PT

EDINSC:	MOVEM B,EDBPAG+8(T)		;Set up as SUPARG
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/FOO /]		;Be stupid or TECO will outsmart itself
	CALL MOVSTR
	MOVEI B,BUFNAM
	CALL MOVSTR
	MOVEI B,[ASCIZ/
/]
	CALL MOVST0
	HRROI A,STRBUF			;Tell it which buffer to use
	RSCAN
	 NOP
	MOVE A,EDFORK
	HRRZ B,EDBPAG+7(T)		;Where to start it
	SFORK				;Start it
	RFORK				;Thaw it
	WFORK				;Wait for it
	DMOVE A,PRGNAM			;Restore our name
	SETSN
	 JFATAL
	MOVE A,EDFORK
	CALLRET EDFTRM			;Remap the right page, etc

;;;Message dired mode

.HDIRE:	.+1
	ASCIZ/
The DIRED command takes a list of message sequences, and starts the
DIRED subsystem of the MMAIL package to maintain your message file
ala disk DIRED (the message headers are your mail file's "directory").

To use DIRED, your editor must be EMACS and you must load the MMAIL
library.  If the system EMACS.INIT does not already do this, you can
do so by adding the following line to your EMACS.INIT:
	FS XJNAME$ [J F~JMM$"E M(M.M Load Library$)MMAIL$'(note that $ = escape).
/

.DIRED:	CALL DFSQAL			;Get sequence, default to all messages
	TRO F,F%DIRE			;Entering dired mode
	PUSH P,[POINT 7,WRTPGS]		;Get some string space
DIRED1:	CALL NXTMSG
	 JRST DIRED2
	MOVE O,(P)
	CALL TYPHD0			;Insert the headers
	MOVEM O,(P)
	JRST DIRED1
DIRED2:	DMOVE A,[ASCIZ/Dired/]
	DMOVEM A,BUFNAM
	DMOVEM A,EDINAM
	MOVE A,[POINT 7,WRTPGS]		;Starting pointer
	POP P,B				;Ending
	CALL SEDBUF			;Stick it in the editor
	TRNE F,F%TECP
	 JRST DIRED5
	WARN <You do not have the hairy MMAIL interface loaded>
	CETYPE <Type "HELP DIRED" at MM top-level for more information>
	MOVEI A,^D5000			;Make sure message stays around a bit
	DISMS
DIRED5:	CALL RESTED			;Run the editor over it
	TRZ F,F%DIRE			;Done with dired mode
	DMOVE A,[ASCIZ/Dired/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get what it gave back
	 RET				;Didnt change
	JUMPLE C,CPOPJ			;No text there
	ADJBP C,A			;Get ending byte pointer
	SETZ D,
	IDPB D,C			;Put a null at the end
DIRED3:	ILDB B,A			;Get start of line
	JUMPE B,.EDFIN			;All done
	SETZ E,				;Accumulate bits here
	ILDB B,A			;Seen
	CAIN B," "
	 TRO E,M%SEEN
	ILDB B,A			;Flagged
	CAIE B," "
	 TRO E,M%ATTN
	ILDB B,A
;	CAIE B," "
;	 TRO E,M%RPLY
	ILDB B,A
	CAIE B," "
	 TRO E,M%DELE
	MOVEI C,^D10
	NIN
	 JRST DIRED4			;Skip it
	IMULI B,MSGLEN
	MOVEI M,-MSGLEN(B)
	MOVEI B,M%SEEN!M%ATTN!M%DELE	;Change these bits
	ANDCAM B,MSGBTS(M)
	IORM E,MSGBTS(M)
	PUSH P,A
	CALL UPDBIT
	POP P,A
DIRED4:	ILDB B,A			;Flush the rest of the line
	JUMPE B,.EDFIN
	CAIN B,12
	 JRST DIRED3
	JRST DIRED4

;;;Continue dired

DIREDR:	MOVE P,[IOWD NPDL,PDL]
	PUSH P,A			;Setup return address
	DMOVE A,[ASCIZ/Dired/]
	DMOVEM A,BUFNAM
	DMOVEM A,EDINAM
	JRST DIRED5

SUBTTL Init file handler

;;;For the time being the syntax is just
;;;<variable> <val><crlf>, where val is just an octal number or string

DOINIT:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS
	CALL MOVSTR
	MOVEI B,[ASCIZ/>MM.INIT/]
	CALL MOVST0
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 RET				;None there, forget it, use defaults
	MOVE B,[7B5+OF%RD]
	OPENF
	 JWARN (Can't open init file)
	MOVEM A,INIJFN			;Save this for later

INILUP:	SKIPG A,INIJFN
	 RET				;Bug trap
	HRROI B,STRBUF
	MOVEI C,STRBSZ*5
	MOVEI D,12			;Read a line
	SIN
	 ERJMP CLSINI			;All done with it
	MOVE T,[POINT 7,STRBUF]		;Handle this line
INILP1:	ILDB C,T
	CAIE C,15			;Reached end of line
	 CAIN C,12
	  JRST INILPX			;Can't understand it then
	CAIE C,11			;Tab or space ok
	 CAIN C,40
	  JRST INILP2
	JRST INILP1

INILP2:	SETZ C,
	DPB C,T				;Stick in a null
	MOVEI A,INIVTB			;Init file variables
	HRROI B,STRBUF
	TBLUK
	TLNE B,(TL%NOM!TL%AMB)		;No good?
	 JRST INILPX			;Yes, complain
	HRRZ A,(A)
	HRRZ U,(A)			;Get address of corresponding variable
	HLRE E,(A)			;Get string length allowed
	JUMPE E,INININ			;Zero means variable is fixnum
	JUMPG E,[CALL (E)		;Call routine if there is one
		 JRST INILUP]
	HRLI U,(<POINT 7,0>)		;Make byte pointer to it
INISTR:	ILDB C,T
	JUMPE C,INIST3
	CAIE C,15
	 CAIN C,12
	  JRST INIST3
INIST2:	AOJG E,INILPX			;Ran out of room in variable
	IDPB C,U
	JRST INISTR

INIST3:	MOVEI C,0
	IDPB C,U
	JRST INILUP

INININ:	SETZB A,B			;Here to input a fixnum variable
ININI1:	ILDB C,T			;Get next char
	JUMPE C,ININI2
	CAIE C,11
	 CAIN C,40
	  JRST ININI1			;Ignore blanks
	CAIE C,15
	 CAIN C,12			;End of line?
	  JRST ININI2
	CAIN C,"-"
	 AOJA A,ININI1			;Negativize
	CAIL C,"0"
	 CAILE C,"7"
	  JRST INILPX			;Not an octal digit, barf
	LSH B,C
	ADDI B,-"0"(C)
	JRST ININI1

ININI2:	TRNE A,1			;Did it get negative?
	 MOVN B,B			;Yes
	MOVEM B,(U)			;Save variable value
	JRST INILUP

INILPX:	CALL INIERR			;Log error
	JRST INILUP

CLSINI:	MOVE A,INIJFN
	CLOSF
	 JERROR
	SETZM INIJFN
	RET

;;; Initialize a table of keywords from a comma separated list
INIKEY:	SETZM (U)			;Originally no keywords
INIKY0:	ILDB C,T			;Get first character
	CAIE C,11
	 CAIN C," "
	  JRST INIKY0
	CAIE C,15			;No entries
	 CAIN C,12
	  RET
	JUMPE C,CPOPJ			;This will happen from SET command
	MOVEI A,^D18			;Initialize header of table
	MOVEM A,(U)
	HRLZ B,KEYPTR			;Initial string pntr,,0 (for TBADD)
	MOVSI D,(<POINT 7,0>)
	HLR D,B				;Byte pointer to string
INIKY2:	CAIN C,","			;End of keyword?
	 JRST INIKY3
	IDPB C,D			;Store as a keyword character
INIKY1:	ILDB C,T			;Get next character
	CAIE C,11
	 CAIN C," "
	  JRST INIKY1
	CAIE C,15
	 CAIN C,12
	  JRST INIKY3
	JUMPE C,INIKY3			;This will happen from SET command
	JRST INIKY2

INIKY3:	HLRZ A,D			;Check pointer
	CAIN A,(<POINT 7,0>)		;Was the keyword null?
	 JRST [	SNARL (Null keyword illegal)
		JRST INIERR]
	MOVEI A,0
	IDPB A,D
	MOVEI A,(U)			;Table pointer
	TBADD
	 ERJMP [JSNARL (Keyword setup error)
		JRST INIERR]
	ADDI D,1			;Update pointer
	CAIE C,","			;More to come?
	 JRST [	HRRZM D,KEYPTR		;No, update free string pointer
		RET]
	HRLI D,(<POINT 7,0>)		;Yes, make byte pointer
	HRLI B,(D)			;Update TBADD copy as well
	AOJA B,INIKY1

;;; Init a string that gets extended by lines
INILNS:	ILDB C,T
	CAIE C,11
	 CAIN C," "
	  JRST INILNS			;Flush whitespace
	ADD T,[7B5]			;Back over first character
	SKIPN D,(U)			;Is there something already?
	 JRST [	MOVNI E,776*5-1
		MOVEI D,4(U)
		HRLI D,(<POINT 7,0>)
		JRST INILN1]		;No, init to start at after 4 words
	AOS E,1(U)			;Extend it with a crlf
	AOJGE E,INIERR
	MOVEI C,15
	IDPB C,D
	MOVEI C,12
INILN2:	IDPB C,D
INILN1:	AOJGE E,INIERR			;Ran out of room in variable
	ILDB C,T
	JUMPE C,INILN3
	CAIE C,15
	 CAIN C,12
	  JRST INILN3
	JUMPE C,INILN3			;This will happen with SET command
	JRST INILN2

INILN3:	DMOVEM D,(U)			;Store ending pointer and count
	MOVEI C,0			;And end string with null
	IDPB C,D
	RET

INIERR:	SKIPN INIJFN			;Init file in progress?
	 RET				;No, don't do this barfage
	CALL CRIF			;Output CRLF if necessary
	MOVEI A,STRBUF			;Tell user the losing line
	CIETYP <There is a problem with your user profile file MM.INIT,
occurring around keyword "%1S".
Your profile file was probably created by an obsolete
version of MM, and rewriting it will fix it.
>
	SETOM BLNKER
	RET

INIVTB:	NINVRS,,NINVRS			;User variables
	VAR BLANK-SCREEN-STARTUP,BLSCST
	VAR COMMAND-IMMEDIATE-WAKEUP,CMIMWK
	VAR CONTROL-N-ABORT,ABOFLG
	VAR DEFAULT-BCC-LIST,DEFBCL,-117
	VAR DEFAULT-CC-LIST,DEFCCL,-117
	VAR DONT-TYPE-HEADERS,SPRHDR,INIKEY
REL3,<
	VAR EDITOR,EDITOR,-47
>;REL3
	VAR ESCAPE-AUTOMATIC-SEND,ESCSND
	VAR GET-CONNECTED-DIRECTORY,GTCNDR
	VAR HEADER-OPTIONS,USRHDR,INILNS
	VAR KEYWORDS,KEYTBL,INIKEY
	VAR LIST-INCLUDE-HEADERS,LSTHDR
	VAR LIST-ON-SEPARATE-PAGES,LSTPAG
	VAR NEW-FILE-PROTECTION,DEFPRO
	VAR ONLY-TYPE-HEADERS,ONLHDR,INIKEY
	VAR PERSONAL-NAME,PERNAM,-117
	VAR READ-PROMPT,REPRMT,-47
	VAR REPLY-CC-OTHERS,RCCOTH
	VAR REPLY-INCLUDE-ME,RINCME
	VAR REPLY-INITIAL-DISPLAY,REPDIS
	VAR REPLY-SENDER-ONLY-DEFAULT,RFMDEF
	VAR RFC733-STYLE-HEADERS,HDR733
	VAR SAVED-MESSAGES-FILE,SAVFIL,-47
	VAR SEND-PROMPT,SEPRMT,-47
	VAR SEND-RETURN-SENDS,CRSEND
	VAR SEND-VERBOSE-FLAG,SNDVBS
	VAR TOP-LEVEL-PROMPT,TOPRMT,-47
	VAR USER-HEADERS,USRHTB,INIKEY
	VAR USER-NAME,MYDIRS,-47
NINVRS==.-INIVTB-1

.HPROF:	.+1
	ASCIZ/
The PROFILE command will help you setup an environment for using MM
corresponding to your desires in message handling. It asks you a series of
questions and then makes MM remember them (via the MM.INIT file).

It does not go through all of the MM.INIT options possible.  To set the
fancier options, you can use the SET command along with CREATE-INIT, or
use an editor on the MM.INIT file.  HELP CREATE-INIT will list all the
available MM.INIT options.
/

;;; Create a new MM.INIT prompting in ENGLISH!
.PROFI:	CONFRM

;;;SEND-VERBOSE-FLAG
	MOVEI A,1			;Set up for super-verbose
	MOVEM A,SNDVBS
	CITYPE <Normally, when you send a message you are told this disposition of
each address; whether it was delivered or queued for later delivery.
>
	PROMPT <Do you want to suppress this typeout?>
	CALL YESNO1
	 CAIA				;No
	  SETOM SNDVBS			;Yes, super-terse

;;;REPLY-INCLUDE-ME
	SETZM RINCME			;Set up for no replies to me
	PROMPT <Do you want to receive copies of your replies to messages?>
	CALL YESNO1
	 CAIA				;No
	  AOS RINCME			;Yes, include me in replies

;;;REPLY-SENDER-ONLY-DEFAULT
	SETZM RFMDEF			;Set up for reply to everybody
	CITYPE <Normally, when you REPLY to or ANSWER a message, the reply will
default to only sending to the person you got the message from.
You can have MM default instead to replying to everybody listed in
the message header.>
	PROMPT <Do you want REPLY to default to everybody?>
	CALL YESNO1
	 SETOM RFMDEF			;No, reply to sender only

;;;BLANK-SCREEN-STARTUP
	SETOM BLSCST			;Set up for screen blanking
	PROMPT <Do you want to erase the screen at startup and between messages?>
	CALL YESNO1
	 SETZM BLSCST			;No, no screen blanking

;;;CONTROL-N-ABORT
	SETZM ABOFLG			;Set up to ask before aborting
	CITYPE <Normally the abort command control-N asks for confirmation before
aborting.>
	PROMPT <Do you want control-N to abort without asking?>
	CALL YESNO1
	 CAIA				;No
	  AOS ABOFLG			;Yes, abort without asking

	CITYPE <Other (fancier) profile options may be set by using the SET command
to set the option, and CREATE-INIT to update your MM.INIT profile file.
You may also edit MM.INIT with an editor.  Type HELP CREATE-INIT for a
complete listing of the MM.INIT options.>
	CALLRET CRINI0

.HCRIN:	.+1
	ASCIZ/
The CREATE-INIT command will make a file, MM.INIT in your directory which
MM subsequently reads when you start up a new MM. In it, you can set
various switches to make your MM environment more comfortable and easy to
use for your own personal tastes. The following are the settings possible:

  BLANK-SCREEN-STARTUP ..number..
	(If non-zero, the default, then clear the screen at startup
	 and before each message typed out when in READ mode.)
  COMMAND-IMMEDIATE-WAKEUP ..number..
	(If non-zero, the command parser wakes up on every field
	 instead of waiting for a break character.  Some people prefer
	 this.  The default is zero.)
  CONTROL-N-ABORT ..number..
	(If negative, never abort on ^N; if zero, the default, ask
	 if should abort; if positive, always abort.)
  DEFAULT-CC-LIST ...names here...
	(A list of addresses to always cc your outgoing messages to.)
  DONT-TYPE-HEADERS ..keyword-list..
	(A list of header keywords which should be suppressed in the
	 TYPE and related commands.)
  ESCAPE-AUTOMATIC-SEND ..number..
	(If zero, the default, then both escape and ^Z in message text
	 input mode will return to send level unless MM was invoked
	 from the EXEC, in which case escape enters send level and ^Z
	 sends the message.  If positive, then escape sends the message
	 and ^Z returns to send level.  If negative, then ^Z sends the
	 message and escape returns to send level.)
  GET-CONNECTED-DIRECTORY ..number..
	(If zero, the default, ask where to read in the mail file from
	 if connected to another directory.  If positive then read from
	 the connected directory always; if negative, then read from the
	 login directory always.)
  HEADER-OPTIONS ..text line..
	(Specifies a header to be inserted by default in a message.)
  KEYWORDS ..keyword-list..
	(A list of keywords by which you wish to tag your messages using
	 the KEYWORD command.)
  LIST-INCLUDE-HEADERS ..number..
	(If non-zero, the default, output a list of headers at the
	 beginning of a listing made by the LIST command.)
  LIST-ON-SEPARATE-PAGES ..number..
	(If non-zero, each message is listed on a separate page.  The
	 default is zero.)
  NEW-FILE-PROTECTION ..protection..
	(The default protection to be given to text files created by
	 MOVE, COPY, etc.  The default is the system default protection.)
  ONLY-TYPE-HEADERS ..keyword-list..
	(A list of header that are the only ones typed out by TYPE and
	 related commands.)
  PERSONAL-NAME ..your name here..
	(A personal name to be included in the From: item in outgoing
	 network mail messages.)
  READ-PROMPT ...the prompt meaning you're in read mode...
	(The default is R>.)
  REPLY-CC-OTHERS ..number..
	(If non-zero, reply to ALL cc's everyone other than from.  If
	 zero, the default, then people in the to-list are to'd, not cc'd.)
  REPLY-INCLUDE-ME ..number..
	(If positive, then include yourself in replies, if negative then
	 if message was moved or copied to a file then the reply will go
	 to that file as well.  If zero, the default, you aren't included
	 in replies.)
  REPLY-INITIAL-DISPLAY ..number..
	(If non-zero then display text of reply initially.  The default
	 is zero.)
  REPLY-SENDER-ONLY-DEFAULT ..number..
	(If non-zero, the default, then default to replying only to
	 the sender of the message.)
  RFC733-STYLE-HEADERS ..number..
	(If non-zero, the default, then write out RFC733 style
	 'John Doe <Doe at Site>' headers.)
  SAVED-MESSAGES-FILE ..filename..
	(Initial file to receive copies of your outgoing messages.)
  SEND-PROMPT ...the prompt meaning you're in send mode..
	(The default is S>.)
  SEND-RETURN-SENDS ..number..
	If non-zero, the default command at SEND level is SEND, so that
	just return will send the message.
  SEND-VERBOSE-FLAG ..number..
	(If negative, then superterse, i.e. say nothing about sending mail.
	 If 0 then tell of local delivery; if positive, the default, then
	 superverbose, i.e. tell of the disposition of all messages.)
  TOP-LEVEL-PROMPT ..the prompt meaning you're at top level..
	(The default is MM>.)
  USER-HEADERS ..keyword-list..
	(Specifies a list of special headers you may want to generate.
	 The send-mode USER-HEADER command will add it to the current
	 message.)
  USER-NAME ..your user name..
	(Defaults to your logged in user name.  This is what MM uses
	 as your "login directory".)
/

;;;Create the guy an init file

.CRINI:	CONFRM
CRINI0:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ/PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS
	CALL MOVSTR
	MOVEI B,[ASCIZ/>MM.INIT/]
	CALL MOVST0
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Can't get init file)
	MOVE B,[7B5+OF%WR]
	OPENF
	 JWARN (Can't open init file)
	MOVEM A,TMPJFN			;Save this for later
	MOVE U,[-NINVRS,,INIVTB+1]

CRILUP:	HRRZ T,(U)
	MOVE T,(T)			;Get info
	MOVE A,TMPJFN
	HLRO B,(U)			;Get name of variable
	SETZ C,
	TLNE T,-1			;Check for routine type entry
	 JUMPG T,CRILP4
	SOUT
	MOVEI B," "
	BOUT
	TLNE T,-1			;A string
	 JRST CRILP3			;Yes
	MOVE B,(T)
	MOVEI C,^D8
	NOUT
	 JWARN
CRILP1:	HRROI B,CRLF0
	SETZ C,
	SOUT
CRILP2:	AOBJN U,CRILUP
	CLOSF
	 JWARN (Couldn't close init file)
	SETOM TMPJFN
	RET

; String-type entry

CRILP3:	HRROI B,(T)			;Type out string
	SOUT
	JRST CRILP1

; Routine-type entry.  We must handle each of these as a special case

CRILP4:	CAMN T,[INILNS,,USRHDR]		;HEADER-OPTIONS?
	 JRST CRIL41
	HLRZ D,T			;Get dispatch item
	CAIN D,INIKEY			;Keyword table?
	 JRST CRIL45
CRILUZ:	HLRZ B,(U)			;Something new; get the losing string
	WARN (Unprocessable SET option "%2S")
	JRST CRILP2			;Try next item

CRIL41:	SKIPN USRHDR			;Are there any header options?
	 JRST CRILP2			;No, don't output this entry
	SOUT				;Yes, write out option name
	MOVEI B," "
	BOUT
	MOVE T,[POINT 7,USRHDR+4]	;Get pointer to string
CRIL42:	ILDB B,T			;Get byte from string
	JUMPE B,CRILP1			;Null means all done
	BOUT				;Write byte in file
	CAIE B,12			;Line feed?
	 JRST CRIL42
	HRROI B,[ASCIZ/HEADER-OPTIONS /];Yes, write new header and continue
	SOUT
	JRST CRIL42

CRIL45:	HLRZ D,(T)			;Is there anything in this table?
	JUMPE D,CRILP2			;No, don't try to hack it then
	SOUT				;Yes, write out option name
	MOVEI B," "
	BOUT
	HLLO D,(T)			;Get size of table
	EQVI D,(T)			;Form AOBJN pointer to table
	ADJSP D,1			;Skip past header word
	CAMN T,[INIKEY,,KEYTBL]		;Message keyword table?
	 JRST CRIL50			;Ugh.  Must do even more kludgery
CRIL46:	HLRO B,(D)			;Get a keyword string entry
	SOUT
	AOBJN D,[MOVEI B,","		;Insert comma delimiter
		 BOUT
		 JRST CRIL46]
	JRST CRILP1

; This routine is pretty cretinous, but it works and the table isn't that big

CRIL50:	PUSH P,D			;Save the table pointer
	HLLZ T,D			;Set up outside loop counter
CRIL51:	HRRZ B,(D)			;Get the keyword index for this entry
	CAIE B,(T)			;Is this the index we want?
	 AOBJN D,CRIL51			;No, try again
	JUMPGE D,[FATAL <Keyword table messed up>];Bug trap
	HLRO B,(D)			;Found the index, now output its string
	SOUT
	AOBJN T,[MOVEI B,","		;Insert comma delimiter if more to come
		 BOUT
		 MOVE D,(P)		;Restore search pointer
		 JRST CRIL51]
	ADJSP P,-1			;Clean up stack
	JRST CRILP1			;Now try next index

SUBTTL UUO handler

UUOH:	MOVEM 16,UUOACS+16		;Save all AC's
	MOVEI 16,UUOACS
	BLT 16,UUOACS+15
	LDB A,[POINT 9,40,8]		;Get opcode field
	CALL @UUOS(A)			;Do the right routine
	MOVSI 16,UUOACS			;Restore ac's
	BLT 16,16
	RET

UUOS:	0
	%PRINT
	%TYPE
	%ETYPE
	%ERROR
	%NOISE
	%DEFAL
	%PRMPT

%PRINT:	HRRZ A,40			;Get byte
	CAIN A,EOL			;Print EOL means do CRLF
	 JRST CRLF
%PRIN0:	PBOUT
	RET

%TYPE:	CALL TYCRIF			;Check if we should do a CRLF
%TYPE0:	HRRO A,40			;Get string
	PSOUT
	RET

%PRMPT:	SETZM CLEVEL
	HRLZ A,40			;Get prompt string
	JRST CMDINI			;Setup that as prompt

TYCRIF:	MOVE A,40			;Get instruction
	TLNE A,(<10,0>)			;Wants cr all the time?
	 JRST CRLF			;Yes
	TLNE A,(<1,0>)			;Wants fresh line?
	 JRST CRIF			;Yes
	RET

CRIF:	PUSH P,A
	PUSH P,B
	MOVEI A,.PRIOU
	RFPOS
	HRROI A,CRLF0
	TRNE B,-1			;If not at start of line,
	 PSOUT				;Type crlf
POP21J:	POP P,B
CPOP1J:	POP P,A
CPOPJ:	RET

CRLF:	PUSH P,A
	HRROI A,CRLF0
	PSOUT
CPOPAJ:	POP P,A
	RET

CRLF0:	BYTE (7) 15,12,0

%ERROR:	CALL CRIF			;Get a fresh line
	MOVE B,40			;Get instruction
	TLNE B,(<10,0>)			;Wants %?
	 SKIPA A,["?"]			;No
	  MOVEI A,"%"
	PBOUT
	TRNN B,-1			;Any message to print?
	 JRST %ERR2			;No
	CALL %ETYE0			;Yes, print it out
	MOVE B,40			;And recover instruction
%ERR2:	TLNN B,(<4, 0>)			;Wants JSYS error message?
	 JRST %ERR3
	HRROI A,[ASCIZ/ - /]
	TRNE B,-1			;If a previous message, type delimiter
	 PSOUT
	MOVEI A,.PRIOU
	HRLOI B,.FHSLF			;This fork
	SETZ C,
	ERSTR
	 NOP
	 NOP
%ERR3:	LDB A,[POINT 2,40,12]		;Get low order bits of ac field
	TRZE F,F%HOER			;Doing MAIL "monitor command"?
	 HALTF				;Yes, return to EXEC, allow continue
	XCT %ERRS(A)
	JRST %FATAL			;Shouldn't happen

%ERRS:	JRST CMDRES			;0 - return to top level commands
%ERRET:	XCT CMDRET			;1 - user settable return
	JRST %FATAL			;2 - return to exec
	RET				;3 - return to user

%FATAL:	HALTF
	HRROI A,[ASCIZ/?Can't continue
/]
	PSOUT
	JRST %FATAL

%ETYPE:	CALL TYCRIF			;Type a CR maybe
%ETYE0:	HRRZ U,40
%ETYS0:	HRLI U,(<POINT 7,0>)		;Get byte pointer to string
%ETYP1:	ILDB A,U			;Get char
	JUMPE A,CPOPJ			;Done
	CAIE A,"%"			;Escape code?
	 JRST %ETYP0			;No, just print it out
	SETZ V,				;Reset ac
%ETYP2:	ILDB A,U
	CAIL A,"0"			;Is it part of addr spec?
	 CAILE A,"7"
	  JRST %ETYP3			;No
	IMULI V,10			;Yes, increment address
	ADDI V,-"0"(A)
	JRST %ETYP2
%ETYP3:	CAIG A,"Z"
	 CAIGE A,"A"
	  JRST %ETYP0
	CALL @%ETYTB-"A"(A)		;Do dep't thing
	JRST %ETYP1

%ETYP0:	PBOUT
	JRST %ETYP1

%ETYTB:	%ETYPA				;A - Print time
	%ETYPB				;B - Print date
	%ETYP0				;C
	%ETYPD				;D - print decimal
	%ETYER				;E - error code
	%ETYPF				;F - floating
	%ETYP0				;G
	%ETYPH				;H - RH as octal
	%ETYP0				;I
	%ETYPJ				;J - filename
	REPEAT 2,<%ETYP0>		;K, L
	%ETYPM				;M - current msg number
	%ETYPN				;N - host name
	%ETYPO				;O - octal
	%ETYPP				;P - pluralizer
	REPEAT 2,<%ETYP0>		;Q, R
	%ETYPS				;S - string
	%ETYPT				;T - date and time
	%ETYPU				;U - user name
	REPEAT 5,<%ETYP0>		;V, W, X, Y, Z

%ETYPA:	MOVSI C,(OT%NDA)		;No day, just time
	JRST %ETYB0

%ETYPT:	TDZA C,C			;Both date and time
%ETYPB:	 MOVSI C,(OT%NTM)		;No time, just day
%ETYB0:	JUMPE V,.+2			;If ac field spec'd
	 SKIPA B,UUOACS(V)		;Use it
	  SETO B,			;Else use now
	MOVEI A,.PRIOU
	ODTIM
	RET

%ETYPD:	SKIPA C,[^D10]			;Decimal
%ETYPO:	 MOVEI C,^D8			;Octal
	MOVE B,UUOACS(V)		;Get data
%ETYO0:	MOVEI A,.PRIOU
	NOUT
	 NOP
	RET

%ETYER:	MOVEI A,.PRIOU
	MOVSI B,.FHSLF			;This fork
	HRR B,UUOACS(V)			;Get error code
	ERSTR
	 NOP
	 NOP
	RET

%ETYPM:	HRRZ B,UUOACS+M			;Current message
	IDIVI B,MSGLEN
	MOVEI C,^D10			;Decimal
	AOJA B,%ETYO0			;Zero is msg 1

%ETYPF:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	SETZ C,
	FLOUT
	 NOP
	RET

%ETYPH:	MOVEI C,^D8
	HRRZ B,UUOACS(V)
	JRST %ETYO0

%ETYPJ:	MOVEI A,.PRIOU
	HRRZ B,UUOACS(V)
	MOVE C,[211110,,1]		;Def dev, frc, dir, name, etc
	JFNS
	RET

%ETYPN:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	CALLRET $CVHST

%ETYPP:	MOVEI A,"s"
	MOVE B,UUOACS(V)
	CAIE B,1
	 PBOUT				;Make plural unless just one
	RET

%ETYPS:	PUSH P,U
	SKIPE U,UUOACS(V)
	 CALL %ETYS0			;Recursive call
CPOPUJ:	POP P,U
	RET

%ETYPU:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	DIRST
	 NOP
	RET

SUBTTL FSCOPY - Fast String Copy
;	Courtesy of KLH
;	A - Source BP
;	O - Dest BP
;	C - char count
;	Updates destination pointer in O, smashes AC's A-C freely

KLWINC==^D18	;# chars at which hairy word move starts wining over bp loop

$STENT==1	;offset from beg of loop for entry to STORE phase
$GENT==4	;offset from beg of loop for entry to GET phase

FSCOPY:	CAIL C,KLWINC			;Less than break-even point?
	 JRST FSCPY2			;No, use hairy word copy.
	ILDB B,A			;simple byte-by-byte copying.
	IDPB B,O
	SOJG C,.-2
	POPJ P,

;Wheee, using hairy word copying!

FSCPY2:	DMOVEM N,UUOACS+N	;This is a pain, but faster than using PDL,
	MOVE N,[D,,UUOACS+D]	;And we need to do something
	BLT N,UUOACS+N-1	;Since ACs will be massacred.

	LDB E,[360300,,A]	;Get low 3 bits of P field for source
	SKIPGE E,FSCHTB(E)	;Get resulting # chars, skip if addr ok
	 MOVEI A,1(A)		;P= 01, must bump address.
	MOVEI L,1(A)		;Anyway, get addr+1 into 12.
	LDB D,[360300,,O]	;Repeat procedure for dest
	SKIPGE D,FSCHT2(D)	;Using slightly different table
	 AOSA V,O		;And addr goes into 10
	  MOVEI V,(O)		;And isn't normally bumped.
	MOVEI O,(C)		;Update the destination pointer in o
	ADJBP O,UUOACS+O	;From initial value
;Now get index for shift values, and count for words
	SUBI C,(E)		;Get # chars minus those in 1st src wd.
	ADDI E,-6(D)		;Get E index - D*5+S, zero based.
	IDIVI C,5		;Find # words to loop through, rem in d.
	MOVE B,-1(L)		;And get 1st word of source.
	JRST @FPATH(E)		;Must now pick a path...

;Blt possible!  Jump to FSBLT0 if no shifting needed for setup.

FSBLT0:	MOVEM B,(V)		;Store source word directly
	JRST FSBLT4
FSBLT:	LSH B,@SHASL(E)		;Shift source up against left
	MOVE A,(V)		;Get 1st wd of dest.
	LSH A,@SHADR(E)		;Right-adjust it
	LSHC A,@SHFIX(E)	;And get everything into A.
	LSH A,1			;Need one more bit's worth.
	MOVEM A,(V)		;Store 1st wd of dest...

;Now settle down to serious BLT'ing.

FSBLT4:	MOVEI T,(C)		;Transfer word count
	ADDI T,(V)		;Find addr of last dest word
	MOVEI V,1(V)		;Now get 1st dest addr,
	HRLI V,(L)		;And put 1st source addr in LH.
	BLT V,(T)		;Zoom!!
	JUMPE D,FSCPY9		;If no remainder, super win - done!
	ADDI L,(C)		;Hmm, must get last source word.
	MOVE B,(L)		;Like so.
	MOVE A,FBMSK(D)		;And a word mask for chars
	AND B,A			;Clear unused bits from source,
	ANDCAM A,1(T)		;And zap target bits in dest.
	IORM B,1(T)		;And stick last chars in.
	JRST FSCPY9		;Ok, all done...

;Can't do BLT.  Well, get A and B set up for magical shift loop.

SHSKP2:	LSH B,@SHASL(E)		;Here, only need to adjust source,
	JRST SHSKP5		;Since dest will be totally clobbered.
FSSHFT:	LSH B,@SHASL(E)		;Here, both src and dest must be integrated.
SHSKP1:	MOVE A,(V)		;Here, only need adjust dest;src wd is full.
	LSH A,@SHADR(E)
SHSKP5:	LSHC A,@SHFIX(E)	;Stuff as many chars as possible into A.
	CAIE D,0		;If any remainder,
	 MOVEI C,1(C)		;Add 1 more word.
	MOVNI C,(C)		;Make AOBJN pointer.
	MOVSI C,(C)

;Now make another index for termination wrapup purposes.

	ADD D,FFINDX(E)		;Make new index using # chs left in last wd.

;Now set things up for loop, and enter it.

FSCPY3:	HRLI V,(<MOVEM A,(C)>)
	MOVEM V,FSCPKL+2	;Address for MOVEM
	HRRM L,FSCPKL+4		;Address for MOVE
	MOVE L,FSHINT(E)	;Get LSH for shift-in
	MOVEM L,FSCPKL
	MOVE L,FSHOUT(E)	;And shift-out
	MOVEM L,FSCPKL+3
	JUMPGE D,FSCPKL+$STENT	;Depending on flag in D, enter loop at store
	SOS V,FSCPKL+2
	JRST FSCPKL+$GENT	;Or at get.

;---------------------------------------------------------------------------
;Come here when loop finished.  The last word of the source string
;will be in B.  It may have 1 to 5 chars left for moving, but will
;never have 0.

;Long wrapup.

FSCPTL:	LSHC A,@FSCPKL	;Perform a shift-in
	LSH A,1
	MOVEM A,@10	;Store full word.
	MOVEI C,1(C)	;Increment address index
			;And drop through to Medium wrapup.

;Medium wrapup.

FSCPTM:	LSHC A,@FLOUT(D)	;Shift rest of source word into A
	MOVE B,@10		;Get dest word it will be stored into
	LSH B,@FLADJ(D)		;Left-adjust chars to preserve.
				;And drop thru to Short wrapup.

;Short wrapup.

FSCPTS:	LSHC A,@FFLOUT(D)	;Do final, last, shift-out.
	ANDCMI A,1
	MOVEM A,@10		;And store last dest word.

;Done!!  Just restore regs and return.

FSCPY9:	MOVE N,[UUOACS+D,,D]
	BLT N,N
	POPJ P,

;Indexed by low 3 bits of P field, returns # chars
;existing to right of loc BP points to.  Hence value
;ranges from 5 to 1;if P = 01, SETZ indicates that
;bp address needs incrementing.

FSCHTB:	1	;P=10
	SETZ 5	;P=01, increment addr
	0
	0	;Randomness
	5	;P=44, full word
	4	;P=35, 4 chars to go
	3	;P=26
	2	;P=17

;This table is just like FSCHTB except values are pre-multiplied
;by 5 for easy addition into E.

FSCHT2:	1*5	;P=10
	SETZ 5*5 ;P=01, increment addr
	0
	0	;Random
	5*5
	4*5
	3*5
	2*5

;This table is indexed by D when it has # chars remaining from
;dividing # chars (in C) by 5.  Provides mask for these chars.

FBMSK:	0	;Nothing here.
	BYTE (7) 177
	BYTE (7) 177, 177
	BYTE (7) 177, 177, 177
	BYTE (7) 177, 177, 177, 177

;FPATH table vectors off to BLT and other minor stuff as
;soon as all the basic computations are made.
;Indexed by E.

FPATH:	FSBLT
	FSSHFT
	FSSHFT
	FSSHFT
	SHSKP1
	FSSHFT
	FSBLT
	FSSHFT
	FSSHFT
	SHSKP1
	FSSHFT
	FSSHFT
	FSBLT
	FSSHFT
	SHSKP1
	FSSHFT
	FSSHFT
	FSSHFT
	FSBLT
	SHSKP1
	SHSKP2
	SHSKP2
	SHSKP2
	SHSKP2
	FSBLT0

DEFINE ENT (A,B,C,D,E) <
	A*7
	B*7
	C*7
	D*7
	E*7
   >
;SHASL table, contains # bits to shift first source wd left so
;as to left-adjust it in B.  Indexed by E.

SHASL:	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0

;SHADR table, contains # bits to shift first dest wd right so
;as to right-adjust it in A.  Indexed by E.

DEFINE ENT1 (A,B,C,D,E) <
	0,,A*7-1
	0,,B*7-1
	0,,C*7-1
	0,,D*7-1
	0,,E*7-1
   >
SHADR:
	ENT1 -1,-1,-1,-1,-1
	ENT1 -2,-2,-2,-2,-2
	ENT1 -3,-3,-3,-3,-3
	ENT1 -4,-4,-4,-4,-4
	ENT1 -5,-5,-5,-5,-5

;SHFIX table, contains # bits to left-shift A and B combined so
;as to move as many characters out of B as possible.  Indexed
;by E.  MIN(d,e) (d and e after fschtb)

SHFIX:	ENT 1,1,1,1,1
	ENT 1,2,2,2,2
	ENT 1,2,3,3,3
	ENT 1,2,3,4,4
	ENT 1,2,3,4,5

;FSHINT table, containing appropriate LSHC instructions for shifting
;in the first chars of a fresh source word.  Indexed by E.

DEFINE ENTL (ARG1,ARG2,ARG3,ARG4,ARG5) <
	LSHC A,ARG1*7
	LSHC A,ARG2*7
	LSHC A,ARG3*7
	LSHC A,ARG4*7
	LSHC A,ARG5*7
   >
FSHINT:	ENTL 5,4,3,2,1
	ENTL 1,5,4,3,2
	ENTL 2,1,5,4,3
	ENTL 3,2,1,5,4
	ENTL 4,3,2,1,5

;FSHOUT table, containing appropriate LSHC instructions for shifting
;out the last chars of an old source word, to make room for a
;new one.  Indexed by E.

FSHOUT:	ENTL 0,1,2,3,4
	ENTL 4,0,1,2,3
	ENTL 3,4,0,1,2
	ENTL 2,3,4,0,1
	ENTL 1,2,3,4,0

;FFINDX table, contains part of D index for fast add-in.
;Indexed by E.  Similar to FSHOUT.  Sign bit also indicates
;whether entry point is $STENT (pos) or $GENT (neg).

DEFINE ENTS (A,B,C,D,E) <
	ENT5 A
	ENT5 B
	ENT5 C
	ENT5 D
	ENT5 E
   >
DEFINE ENT5 (X,Y) <
	X+<Y*5>
>
S==0B0
G==1B0

FFINDX:	ENTS (<S,0>,<S,1>,<S,2>,<S,3>,<S,4>)
	ENTS (<G,4>,<S,0>,<S,1>,<S,2>,<S,3>)
	ENTS (<G,3>,<G,4>,<S,0>,<S,1>,<S,2>)
	ENTS (<G,2>,<G,3>,<G,4>,<S,0>,<S,1>)
	ENTS (<G,1>,<G,2>,<G,3>,<G,4>,<S,0>)

DEFINE ENTX (A,B,C,D,E) <	;Last item (5) is actually first (0)
	7*E
	7*A
	7*B
	7*C
	7*D
   >

;FENTRM table, dispatching to appropriate wrapup routine when fast AC
;loop is finished.  Indexed by D.

FENTRM:
DEFINE ENTXJ ' (A,B,C,D,E) <
	FSCPT'E
	FSCPT'A
	FSCPT'B
	FSCPT'C
	FSCPT'D
>
	ENTXJ M,M,M,M,S
	ENTXJ M,M,M,S,L
	ENTXJ M,M,S,L,L
	ENTXJ M,S,L,L,L
	ENTXJ S,L,L,L,L

;FLOUT table, for use by Medium wrapup routine;pushes out remaining
;source chars in B, making room for incoming dest word.
;Indexed by D.

FLOUT:	ENTX 1,2,3,4,0
	ENTX 1,2,3,0,1
	ENTX 1,2,0,1,2
	ENTX 1,0,1,2,3
	ENTX 0,1,2,3,4

;FLADJ table, also for Medium wrapup routine;adjusts dest word in
;B to left-adjust chars to be preserved.

FLADJ:	ENTX 1,2,3,4,5
	ENTX 2,3,4,5,1
	ENTX 3,4,5,1,2
	ENTX 4,5,1,2,3
	ENTX 5,1,2,3,4

;FFLOUT table, for Short wrapup routine.  Final Last shift-out of
;chars in B, so that the last dest word can be stored from A.
;Indexed by D.  Adds 1 extra bit since MOVEM A, done right after it,
;and nothing to preserve in B.

FFLOUT:
DEFINE ENTX1 (A,B,C,D,E) <
	E*7+1
	A*7+1
	B*7+1
	C*7+1
	D*7+1
   >
	ENTX1 4,3,2,1,5
	ENTX1 3,2,1,4,4
	ENTX1 2,1,3,4,3
	ENTX1 1,2,4,3,2
	ENTX1 1,4,3,2,1


SUBTTL Command parsing routines

CMDINI:	TRZ F,F%HOER			;No more exiting on errors if command
					;level (user typed ESC or something)
	HLROM A,CMDBLK+.CMRTY		;Set up prompt string
	MOVSI B,(CM%XIF)
	ANDCAM B,CMDBLK+.CMFLG
	MOVEM A,TPADD1			;Save command pointers
	MOVEI A,REPARS			;Setup reparse address
	SKIPE CMIMWK
	 TLO A,(CM%WKF)			;In case user wants immediate wakeup
	MOVEM A,CMDBLK+.CMFLG
IFN INSTLF,<
	PUSH P,CMDBLK+.CMIOJ		;Save I/O JFNs
	MOVE B,[.NULIO,,.NULIO]		;Get null JFNs
	MOVEI A,.RSCNT			;Find count of RSCAN characters
	RSCAN
	 ERJMP .+3			;Assume not rescanning
	  SKIPE A			;If we're reading from rescan buffer
	   MOVEM B,CMDBLK+.CMIOJ	;Do I/O to null this time
>;IFN INSTLF
	MOVEI A,CMDBLK			;COMND state pointer
	MOVEI B,[FLDDB. .CMINI]		;Init command block
	COMND
IFN INSTLF,<
	POP P,CMDBLK+.CMIOJ		;Restore I/O JFNs
>;IFN INSTLF
	SETZM CMDFLB			;Init command field block
	MOVE A,[CMDFLB,,CMDFLB+1]
	BLT A,CMDFLB+3
	POP P,TPADDR			;Save address of caller
CMDIN2:	MOVE A,TPADD1			;Get back command pointers
	JRST @TPADDR			;And return

REPARS:	SKIPE CLEVEL			;If not at top-level
	 SETZM CMDFLB+.CMDEF		;Reset default
	CALL CLSTMP			;Get rid of stray JFNs
	SKIPLE A,OUTJFN
	 CLOSF
	  NOP
	CALLRET CMDIN2

CONF:	MOVEI B,[FLDDB. .CMCFM]		;Get confirmation
	CALLRET CMDFLD

SUBCMD:	AOSA CLEVEL			;One level deeper
GETCMD:	 SETZM CLEVEL			;At the top
	HRRZM A,CMDFLB+.CMDAT		;Address of keyword table
	SETZM CMDFLB+.CMFNP		;.CMKEY = 0
	CALL CMDNO2			;Parse the field
	SETZM CMDFLB+.CMHLP		;Reset default and help messages
	SETZM CMDFLB+.CMDEF
	HRRZ A,(B)			;Get address of routine
	SETZM OKTINT			;No more timer ints now
	AOS CLEVEL			;Know that we arent top-level
	RET

%NOISE:	MOVSI A,(<BYTE (9) .CMNOI,0>)
	MOVEM A,CMDFLB+.CMFNP
	HRRO A,40
CMDNO1:	MOVEM A,CMDFLB+.CMDAT
CMDNO2:	MOVSI A,(CM%DPP)
	SKIPE CMDFLB+.CMDEF		;Default provided?
	 IORM A,CMDFLB+.CMFNP		;Yes, say there is one
	MOVEI B,CMDFLB
CMDFLD:	MOVEI A,CMDBLK
	COMND
	TLNE A,(CM%NOP)
	 JERROR				;Give JSYS error message and return
	RET				;Did ok

%DEFAL:	HRRZ B,40
	HRROM B,CMDFLB+.CMDEF		;Save default string
	RET

GETLIN:	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,,,[FLDDB. .CMTXT]]
	SKIPE CLEVEL
	 JRST [	HRRZ B,(B)		;Not at top level, don't need cfm option
		CALLRET CMDFLD]
	MOVEI A,GETLIN
	HRRM A,CMDBLK+.CMFLG		;Reparse address is just us if at top
	SETZM STRBUF			;Else make sure atom buffer clear
	CALLRET CMDFLD			;Just go read a line

GETDAT:	MOVEI B,[FLDDB. .CMTAD,,CM%IDA!CM%ITM,,,<[
		 FLDDB. .CMTAD,,CM%IDA,,,<[
		 FLDDB. .CMTAD,,CM%ITM,,,<[
		 FLDDB. .CMKEY,,DATTAB,,,<[
		 FLDDB. .CMKEY,,HOLDAY]>]>]>]>]
	CALL CMDFLD
	LDB C,[POINT 9,(C),8]		;Get field type parsed
	CAIN C,.CMTAD			;Date and time?
	 RET				;Yes, just return that time
	HRRZ T,(B)			;Else get data for it
	MOVE T,(T)
	CALLRET (T)			;And call the right routine

DATDOW:	SETO B,
	SETZ D,
	ODCNV
	MOVSI C,8(C)			;Get day of week into lh
	SUBM C,T			;Get difference from desired
DATDAY:	HLLZ B,T			;Get number of days to offset
	CAMLE B,[7,,0]			;If week wrapped around,
	 SUB B,[7,,0]			;Take next one
	GTAD
	SUBM A,B
	SETZ D,
	ODCNV
	SETZ D,				;Midnight of that day
	IDCNV
	 SETO B,
	RET

DATHDY:	GTAD				;Get now for later
	SETO B,
	SETZ D,
	ODCNV
	HLRZ E,B			;Save year
DATHD1:	LDB B,[POINT 9,T,8]		;Get month
	HRLI B,(E)			;Get year
	HLLZ C,T
	TLZ C,777000			;Get day of month
	SETZ D,
	IDCNV
	 SETO B,
	CAML B,A			;Must be before today
	 SOJA E,DATHD1			;Else try last year
	RET

;;;Message sequence handler

GETSEQ:	NOISE (MSGS)
	TLZ F,(F%TYPS)			;Default don't type numbers of sequence
	SETOB X,LSTMSG
	MOVE L,[POINT 12,MSGSEQ]	;Pointer to where to store messages
	MOVE A,[FLDDB. .CMTOK,CM%HPP!CM%SDH,,,,TKNDOT] ;Build the first pointer
	MOVEM A,CMDFLB+.CMFNP		;With our default string
	HRROI A,[ASCIZ/%/]
	MOVEM A,CMDFLB+.CMDAT
	HRROI A,HLPTXT
	MOVEM A,CMDFLB+.CMHLP
	CALL CMDNO2
	SETZM CMDFLB+.CMHLP		;Reset default and help messages
	SETZM CMDFLB+.CMDEF
	LDB A,[POINT 9,(C),8]		;Get field type
	CAIN A,.CMTOK
	 JRST GETSQT
	CAIN A,.CMNUM			;Number?
	 JRST GETSQN			;Yes - get that
GETSQK:	HRRZ A,(B)			;Must be keyword, get routine addrs
	CALLRET (A)			;Go there and return

;;;Token - check for % or . and supply number

GETSQT:	LDB A,[POINT 7,STRBUF,6]	;Get token character
	CAIE A,"*"
	 CAIN A,"%"
	  SKIPA B,LASTM			;% = last message number
	   MOVE B,M			;. = current message
	JUMPL B,[ERROR (No current sequence)]
	ADDI B,MSGLEN			;Handle as number now
	IDIVI B,MSGLEN
;	CALLRET GETSQN

;;;Number parsed - handle n:m n,m or n alone

GETSQN:	JUMPE B,BADNUM			;Range error
	SOJL B,BADNUM
	MOVE C,LASTM
	IDIVI C,MSGLEN
	CAILE B,(C)			;His number > last message?
IFE LSQLMF,<
	 JRST BADNUM
>;IFE LSQLMF
IFN LSQLMF,<
	 MOVEI B,(C)			;Yes, then default to last one
>;IFN LSQLMF
	JUMPGE X,GTSQ2N			;2nd in series n:m
	CALL GTSQLC			;Save number on list
	MOVEI B,GTNBK1			;Now try for <cr> ! , ! :
GTSQNF:	CALL CMDFLD
	LDB A,[POINT 9,(C),8]		;Get fcn parsed
	CAIN A,.CMCFM			;EOL?
	 JRST GTSQNR			;Yes - done
	CAIE A,.CMCMA			;Comma?
	 LDB X,L			;Must be ":" , setup for 2nd arg
	MOVEI B,GTNBK2			;Yes - try for <number> ! . ! %
	CALL CMDFLD
	LDB A,[POINT 9,(C),8]		;Get fcn parsed
	CAIN A,.CMCFM			;EOL?
	 JRST GTSQNR			;Yes - done
	CAIN A,.CMNUM			;Number?
	 JRST GETSQN			;Yes - handle
	CALLRET GETSQT			;Handle token

GTSQLC:	CAMN L,[141400,,MSGSQZ-1]	;Reached end of list?
	 ERROR (Too many messages in list)
	IDPB B,L			;Save number in list
	SETOM NXTMSD			;Flag that previous sequence has been clobbered
	RET

;;;2nd in range seen - fill list
GTSQ2N:	TRO B,2000			;Mark as end of range
	CALL GTSQLC			;Save in table
;	CALLRET GTSQNC			;Go try for more

GTSQNC:	SETO X,				;Say looking for 1st number of pair
	MOVEI B,GTNBK3			;Try for <cr> ! ,
	CALLRET GTSQNF

;;;EOL seen, wrapup numbers

GTSQNR:	MOVEI B,3777			;Mark end of list
	IDPB B,L
GTSQNS:	MOVE L,[POINT 12,MSGSEQ]	;Reset list
	MOVEI A,NXTSEQ			;Nest in the sequence
	MOVEM A,NXTMSD			;Setup as dispatch
	RET				;Return

HLPTXT:	ASCIZ/Message sequence in the form:
   n 	- Single message number
   n,m,...,k	- List of message numbers
   n:m		- Range of message numbers
     or any combination of ranges in a list.
   "."	- Current message number
   "%" or "*" - Last message in file
     Terminate list with <CR>/

TKNDOT:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/./]>,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/*/]>,,,<[
	FLDDB. .CMNUM,CM%SDH,^D10,,,<[
	FLDDB. .CMKEY,,SQCMTB]>]>]>

TKNCLN:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/:/]>

GTNBK1:	FLDDB. .CMCFM,CM%SDH,,<-1,,HLPTXT>,,<[
	FLDDB. .CMCMA,CM%SDH,,,,TKNCLN]>

GTNBK2:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/%/]>,<-1,,HLPTXT>,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/./]>,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/*/]>,,,<[
	FLDDB. .CMNUM,CM%SDH,^D10]>]>]>

GTNBK3:	FLDDB. .CMCFM,CM%SDH,,<-1,,HLPTXT>,,<[
	FLDDB. .CMCMA,CM%SDH]>

;;;Get User@site string, W/ addr where to stick block, return in U
;;;Note: leave the POINT 7,'s as they are, the code depends upon them

USRLST:	FLDDB. .CMCFM,,,,,USRLS1
USRLS1:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/*/]>,<-1,,[ASCIZ/"*" for sending to a file
  or "@" to send indirect from a file/]>,,<[
	FLDDB. .CMUSR,,,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/./]>,<-1,,[ASCIZ/"." for yourself/]>,,<[
	FLDDB. .CMKEY,,<[2,,2
			[ASCIZ/BBOARD/],,BBDCOD
			[ASCIZ/SYSTEM/],,SYSCOD]>,<-1,,[ASCIZ/special mailbox,/]>,,<[
	FLDDB. .CMQST,,,,,<[
	FLDDB. .CMFLD,,,<-1,,[ASCIZ/Network address/]>,,,UNMMSK
			]>]>]>]>]>

CMDUSE:	MOVEI A,CMDBLK			;Here for error
	MOVEI B,[FLDDB. .CMINI]		;Re-init comnd state block
	COMND
CMDUS0:	MOVSI A,(CM%XIF)		;Here for reparse
	ANDCAM A,CMDBLK+.CMFLG
	MOVE P,TPADDR
	MOVE W,TPADD1			;Reset list as of start
	TLZ F,(F%COMA!F%F4)
GETUSR:	MOVEI B,USRLST			;Set up user command list
	TLZE F,(F%COMA)			;Is this the first one?
	 SKIPA B,[USRLS1]		;Yes, don't allow CRLF
	  SKIPE CLEVEL			;At top level?
	   JRST CMDUS2
	MOVEI A,CMDUS0			;Setup reparse address for this routine
	HRRM A,CMDBLK+.CMFLG
	MOVEI A,CMDUSE			;Setup error dispatch
	HRRM A,CMDRET
	MOVEM P,TPADDR
	MOVEM W,TPADD1			;Save list so far
CMDUS2:	CALL CMDFLD			;Parse a field
	LDB E,[POINT 9,(C),8]
	CAIN E,.CMCFM
	 RET				;Null field, return
	MOVEI U,(W)
	TLNN F,(F%F4)
	 TDZA A,A
	  MOVSI A,400000		;Invisible if requested
 	MOVEM A,(U)			;Setup flags
	CAIE E,.CMKEY			;Keyword?
	 CAIN E,.CMUSR			;Username?
	  MOVEM B,2(U)			;Save keyword pointer or user number
	CAIE E,.CMTOK			;Token?
	 JRST CMDUS3			;No, just a string then
	MOVE A,.CMDAT(C)
	ILDB A,A			;Get first char of token
	CAIN A,"*"			;File type?
	 JRST CMDUFL			;Yes, handle that
	MOVE B,MYDIR			;Must be . meaning me
	MOVEM B,2(U)
	SKIPA B,[MYDIRS]		;Use my name string too
CMDUS3:	 MOVEI B,STRBUF
	MOVEI A,4(W)
	HRLI A,(<POINT 7,0>)
	CALL MOVST0			;Move in user name
	MOVEI A,1(A)			;Point to next free word
	SUBM A,W			;Get length
	EXCH A,W
	DPB A,[POINT 9,(U),17]		;Store it away
	SETZM 1(U)
	SETZM 3(U)
;falls through

;drops in
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/@/]>,<-1,,CUSHLP>,,<[
		 FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/:/]>]>]
	MOVSI D,(CM%XIF)
	IORM D,CMDBLK+.CMFLG
	COMND
	ANDCAM D,CMDBLK+.CMFLG
	TLNN A,(CM%NOP)			;Was it @ or :?
	 JRST CMDUTK			;Yes, get host or do group then
	CAIE E,.CMUSR			;Was it a user before?
	 TLNE F,(F%F3)			;Or funny addresses ok?
	  JRST CMDUS4
	CAIN E,.CMTOK			;Filename/token?
	 JRST CMDUS4
	CAIE E,.CMKEY			;Was it BBoard/System?
	 JRST CMDUS5			;No, check for forwarding address
	HRRE B,@2(U)			;Get the special user number
	MOVEM B,2(U)			;Set it in the block
	CAMN B,[SYSCOD]			;System?
	 JRST CMDUS6			;Yes, super simple
	MOVSI A,(RC%EMO)		;Is BBoard a user?
	HRROI B,[ASCIZ/BBoard/]
	RCUSR
	TLNN A,(RC%NOM!RC%AMB)		;Match?
	 JRST [	MOVEM C,2(U)		;Yes, save the user number
		MOVEI B,[ASCIZ/BBoard/]	;And set the new user string
		JRST CMDUS7]
	MOVSI A,(GJ%SHT!GJ%OLD)		;Perhaps files-only BBOARD
	HRROI B,[ASCIZ/PS:<BBOARD>MAIL.TXT.1/]
	GTJFN				;Does the mailbox exist?
	 ERJMP [MOVEI A,4(U)		;Return error
		ERROR (No such local user as "%1S")]
	RLJFN				;Don't need the JFN any more
	 ERJMP .+1
	MOVEI A,401			;Files-only BBoard exists, set up
	DPB A,[POINT 9,(U),8]		; to mail to it
	SETZM 2(U)
	SKIPA B,[[ASCIZ/PS:<BBOARD>MAIL.TXT.1/]]
CMDUS6:	 MOVEI B,[ASCIZ/System/]
CMDUS7:	MOVEI W,(U)			;Re-initialize W from base in U
	MOVEI A,4(W)			;Pointer to string area
	HRLI A,(<POINT 7,0>)
	CALL MOVST0			;Move in filename string
	MOVEI A,1(A)			;Point to next free word
	SUBM A,W			;Get length
	EXCH A,W
	DPB A,[POINT 9,(U),17]		;Store it away
	JRST CMDUS4

;;; Looks like a local address, but not a user.  Try forwarding.
CMDUS5:	MOVE A,[POINT 7,4(U)]
	CALL CHKFWD			;Did we find it?
	 JRST [	MOVEI A,4(U)		;Else return error
		ERROR (No such local user as "%1S")]
	PUSH P,D			;In case HSTINI is called
	SKIPN HSTPTR			;Make sure host table present
	 CALL HSTINI
	POP P,D				;Sigh
NOHST2,<
	MOVE A,LHOSTN			;Get host number
>;NOHST2
HOSTS2,<
	MOVE A,LHOSTP			;Get host string pointer
>;HOSTS2
	MOVEM A,2(U)			;Set up host properly
	MOVEI A,2			;Network recipient
	TLNE F,(F%F4)
	 TRO A,400			;Make invisible is requested
	DPB A,[POINT 9,(U),8]		;Store type field and flags
CMDUS4:	MOVEI B,[FLDDB. .CMCFM,,,,,<[FLDDB. .CMCMA]>]
	CALL CMDFLD			;Must be comma or confirm here
	LDB D,[POINT 9,(C),8]		;Get field type
	CAIN D,.CMCMA
	 TLO F,(F%COMA)
	RETSKP

CUSHLP:	ASCIZ/confirm with carriage return
 or "," for another address
 or "@" for a network host name
 or ":" to make this a group name
/

CMDUTK:	MOVE A,.CMDAT(C)
	ILDB A,A
	CAIN A,":"			;Distribution list
	 JRST [	TLO F,(F%F4!F%COMA)	;Say we are within a distribution list
					;Also pretend there was a comma so the
					; reparse setup code isn't confused
		MOVEI A,3		;Distribution list type recipient
		DPB A,[POINT 9,(U),8]
		JRST GETUSR]		;And go get some more guys
	SETZM CMDFLB+.CMFNP		;Must be a host name
	SKIPN A,HSTPTR
	 CALL HSTINI
	MOVEM A,CMDFLB+.CMDAT
	MOVEI A,CMDBLK
	MOVEI B,CMDFLB
	COMND
	TLNE A,(CM%NOP)
	 JERROR (Unrecognized host name)
	HRRZ A,(B)			;Get pointer to site entry in A
NOHST2,<
	MOVE A,(A)
>;NOHST2
HOSTS2,<
	HLRZ A,(A)			;Get pointer to offical host name
>;HOSTS2
	MOVEM A,2(U)			;Save host number
	MOVEI A,2			;Network recipient
	TLNE F,(F%F4)
	 TRO A,400			;Make invisible is requested
	DPB A,[POINT 9,(U),8]		;Store type field and flags
	MOVEI B,[FLDDB. .CMCFM,,,,,<[
		 FLDDB. .CMCMA]>]
	CALL CMDFLD
	LDB D,[POINT 9,(C),8]
	CAIN D,.CMCMA
	 TLO F,(F%COMA)
	RETSKP

CMDUFL:	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]	;Note that .CMOFI is NOT used since
	BLT A,CMDGTB+.GJATR		; it uses existing gen# + 1
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/file name to output message to/]>]
	CALL CMDFLD
	MOVEI A,(B)
	RLJFN				;Don't need it till later
	 NOP
	MOVEI A,401			;File recipient
	DPB A,[POINT 9,(U),8]
	SETZM 2(U)
	JRST CMDUS3			;Go stick in the filename, etc

;;; Parse list of keywords and return mask in U.

GETKEY:	SKIPA B,[[FLDDB. .CMCMA,CM%SDH,,<-1,,[ASCIZ/","
 or confirm with carriage return/]>]]
GETKY0:	 MOVEI B,[FLDDB. .CMCMA,CM%SDH,,<-1,,[ASCIZ/","
 or message sequence/]>]
	PUSH P,B
	SETZ U,				;Init bits
	MOVEI B,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ/*/]>,,,<[
		 FLDDB. .CMKEY,,KEYTBL]>]
	CALL CMDFLD
	LDB D,[POINT 9,(C),8]
	CAIE D,.CMTOK
	 JRST GETKY2
	SETO U,
	ADJSP P,-1
	RET

GETKY1:	MOVEI B,[FLDDB. .CMKEY,,KEYTBL]
	CALL CMDFLD			;Get a keyword
GETKY2:	HRRZ B,(B)
	MOVNI B,(B)
	MOVSI A,400000
	LSH A,(B)
	IOR U,A				;Set the given bit
	MOVEI A,CMDBLK
	MOVE B,(P)
	COMND
	TLNN A,(CM%NOP)
	 JRST GETKY1
	ADJSP P,-1
	RET				;Not a comma, return

;;;Check for forwarding.  Pointer to string in A, skip returns if exists

CHKFWD:	PUSH P,A			;Save pointer
	MOVSI A,(GJ%OLD!GJ%SHT)		;Get JFN of forwarder
	HRROI B,[ASCIZ/SYS:MAILBOX.EXE/]
	GTJFN
	 ERJMP [POP P,A
		RET]			;Can't
	PUSH P,A			;Save JFN
	MOVSI A,(CR%CAP)		;Create an inferior fork
	CFORK
	 JERROR (Can't create forwarding fork)
	EXCH A,(P)			;Save fork handle, get JFN
	HRL A,(P)			;Get prog into fork
	GET
	HRLZ A,(P)			;Page 0 of inferior
	MOVE B,[.FHSLF,,FWDPAG/1000]	;Mapped to this fork's FWDPAG
	MOVSI C,(PM%RD!PM%WR)		;Read+write access
	PMAP
	POP P,A				;Get back fork handle
	EXCH A,(P)			;Put fh on stack, get string pointer
	SKIPA B,[POINT 7,FWDPAG+140]	;Copy string
	 IDPB C,B
	ILDB C,A
	JUMPN C,.-2
	MOVE A,(P)			;Set inferior's AC1 to 1 for local site
	MOVEI B,[1]-1
	SFACS
	MOVEI B,2			;Start up inferior
	SFRKV
	WFORK
	RFSTS				;See if it finished ok
	HLRZ A,A
	CAIE A,.RFHLT			;HALTF?
	 JRST FWDERR
	MOVE A,(P)			;Now get the answer from its AC1
	MOVEI B,UUOACS			;Do not use FRKACS, they are for editor
	RFACS
	SKIPLE UUOACS+1			;Success answer?
	 AOS -1(P)			;Indicate success
FWDERR:	SETO A,				;Unmap shared page
	MOVE B,[.FHSLF,,FWDPAG/1000]	;Mapped to this fork's FWDPAG
	SETZ C,
	PMAP
	POP P,A				;Flush the fork
	KFORK
	RET

;;;Parse command line

DORSCN:	SETZ A,
	RSCAN
	 SETZ A,
	JUMPE A,CPOPJ			;No command line
IFN INSTLF,<
	MOVSI A,[BYTE (7) "M","M",76]	;Prompt which will be dummied
>;IFN INSTLF
IFE INSTLF,<
	MOVSI A,[ASCIZ//]		;Dummy prompt
>;IFE INSTLF
	CALL CMDINI			;Init COMND state block
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMKEY,,<[3,,3
				  [ASCIZ/MAIL/],,.SEND
				  [ASCIZ/MM/],,0
				  [ASCIZ/NMM/],,0]>]
	COMND
	TLNE A,(CM%NOP)
	 JRST DORSCE			;Error, flush line
	HRRZ A,(B)
	JUMPN A,[NOISE (TO)		;In case EXEC has (TO) noise word
		 TRO F,F%HOER		;Return to EXEC on any error
		 JRST DORSC1]
	HRROI A,[ASCIZ/ To: /]		;In case of error,
	MOVEM A,CMDBLK+.CMRTY		;Set up reasonable prompt string
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMKEY,,RSCMTB]	;Parse MM SEND
	COMND
	TLNE A,(CM%NOP)
	 JRST DORSCE
	HRRZ A,(B)			;Get dispatch address
DORSC1:	TRO F,F%RSCN			;Say called from command line
	CALL (A)
	JRST CMDRES			;And go to top-level

DORSCE:	MOVEI A,.PRIOU			;Error, flush rest of line
	BKJFN
	 NOP
	PBIN
	CAIE A,12
	 JRST .-2
	DMOVE A,[POINT 7,CSBUF		;Avoid embarassment if user types ^H
		 CSBFSZ*5]		; first thing
	DMOVEM A,CMDBLK+.CMPTR
	RET

;;;Read in file for rscan command handling

RSCFIL:	CALL GETFIL			;For read from command line
	TLZ F,(F%F1)			;Don't type out headers
	CALLRET RECEN0

XLIST					;for clean listings
	LIT
LIST					;literals are XLISTed out
IFG .-<PAGE0*1000>,<.FATAL PAGE0 overlaps program area, set PAGE0 higher>

END <EVECL,,EVEC>

;;;Local modes:
;;;Mode: FAIL
;;;Comment column:40
;;;End:
   