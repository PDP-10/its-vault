.IIF NDF SMSDSK,SMSDSK=1
.IIF NDF RKDSK,RKDSK=0
FOO==.
				;SET UP INTERUPT VECTORS
.IF DF FLEMT
.=10
	FLEMT
.=244
	FLFIS
.ENDC
LSITRV=34
.=LSITRV
	LSITRP
	0
.IFNZ LSCLK
CLKBRV=100
.=CLKBRV
	CLKBRK
	340
.ENDC
.IFNZ LSDISK
.IF NZ SMSDSK
.=SMSBRV
	SMSBRK
	340
.ENDC
.ENDC
.IFNZ LSTTY
.=60
	LSRIN0
	340
	LSTIN0
	340
.ENDC
.IFNZ LSPRNT
.=LPBRV
	LPINT
	340
.ENDC
.=14
	.+2
	HALT
.=0
	BPT
.=FOO

				;MACRO TO GENERATE A CONDITIONAL ERROR TRAP
.MACRO LSERRC COND,ERR,F1,F2
	RBRPP4 COND
	LSERR ERR,F1,F2
.ENDM

				;MACRO TO GENERATE AN ERROR TRAP
.MACRO LSERR ERR,F1,F2
ERRCOD==.E'ERR!TRPZBT
	EFLAG F1
	EFLAG F2
	TRAP ERRCOD
.ENDM

				;MACRO TO HELP OUT ERROR
.MACRO EFLAG FLAG
.IIF IDN FLAG,SZ,ERRCOD==ERRCOD!TRPZBT
.IIF IDN FLAG,CZ,ERRCOD==ERRCOD&<-TRPZBT-1>
.IIF IDN FLAG,SV,ERRCOD==ERRCOD!TRPVBT
.IIF IDN FLAG,CV,ERRCOD==ERRCOD&<-TRPVBT-1>
.ENDM

TRPZBT==200
TRPVBT==100

				;MACRO TO BRANCH TO .+4 (PP4) ON THE OPPISITE OF THE SUPPLIED CONDITON
.MACRO RBRPP4 COND
	BRO .+4,COND,MI,PL
	BRO .+4,COND,EQ,NE
	BRO .+4,COND,LT,GE
	BRO .+4,COND,LE,GT
	BRO .+4,COND,HIS,LO
	BRO .+4,COND,LOS,HI
	BRO .+4,COND,CS,CC
	BRO .+4,COND,VS,VC
.ENDM

				;MACRO TO GENERATE BRANCH OF OPPISTIE CONDITION
.MACRO BRO ADDR,COND,A,Q
.IIF IDN COND,A,	B'Q ADDR
.IIF IDN COND,Q,	B'A ADDR
.ENDM
				;LITTLE SITS EMULATOR
LSITSB::			;BEGGINING OF LITTLE SITS


.IFNZ LSCLK
.IIF NDF HSECTK,HSECTK==30.	;DEFAULT IS 60 HURTS
CLKBRK:	JSR F,LSACSV
.IFNZ LSDISK&SMSDSK
	TST LSDKOF		;ALREADY OFF?
	BEQ 3$			;YUP
	DEC LSDKOF		;TIME TO TURN OFF?
	BNE 3$			;NOPE
	JSR PC,DSKOFF		;TURN DISK OFF
3$:
.ENDC
	INC LSTIME
	BNE 1$			;OVERFLOW?
	INC LSTIME+2		;YUP
1$:	DEC HSECNT		;TIME TO INC HSECS?
	BGT 2$
	INC HSECS
	MOV HSEC,HSECNT		;NUMBER OF TICKS IN A HALF SECOND
	DEC SECNT		;TIEM TO UPDATE SECONDS?
	BGT 2$			;NOPE
	MOV #2,SECNT		;2 HALF SECS IN A SEC
	JSR PC,DATEIN		;GO UPDATE SECS ETC.
2$:
.IF NZ METERS
	TST MTFLAG		;METERS TURNED ON?
	BNE 6$			;NOPE
	INC MTCLK
	BNE 7$
	INC MTCLK+2
7$:	INC @METERP
	BNE 5$
	MOV METERP,A
	INC 2(A)
5$:	MOV 6*2(P),A		;THE PC TRAPPED FROM
	ASH #-9.,A
	BIC #177603,A		;ONE OF 32 AREAS
	INC PCMETR(A)
	BNE 4$
	INC PCMETR+2(A)
4$:
6$:
.ENDC
	JSR F,LSACRT
	RTT

DATEIN:	MOV LSMON,A		;THE MONTH
	MOVB MONS-1(A),DAYL	;SET THE LIMIT ON DAYS FOR THIS MONTH
	MOV #LSSEC,A		;POINT TO TABLES
	MOV #SECONL,B		;THE LIMITS
	MOV #RESETT,C		;VALUES TO RESET TO
DATEI1:	INC (A)			;INCREMENT THIS
	CMP (A),(B)+		;HAS THIS OVERFLOWED?
	BLT DATEI2		;NO, DONE
	MOV (C)+,(A)+		;BACK TO BEGINNING OF MIN, HOUR, DAY, MON OR YEAR
	BR DATEI1		;GO DO NEXT
DATEI2:	RTS PC

				;THE GET/SET TIME CALL
ETIME:	MOV (E)+,A		;GET POINTER FROM CALLER
	MOV #6,B
	MOV #LSSEC,C		;TABLE OF TIMES
	MTPS #340
ETIME1:	SAVE (A)		;GET WORD FROM USER
	BGE ETIME2		;HE DOESN'T WANT TO SET THIS WORD
	BIC #100000,(P)		;CLEAR FLAG
	MOV (P),(C)		;SET THIS ONE
ETIME2:	MOV (C)+,(P)		;GET VALUE TO RETURN
	REST (A)+		;RETURN IT
	SOB B,ETIME1
	MTPS #0
	RTS PC

				;.SLEEP:
				;1 ARG IS TOP 2 WORDS ON STACK (LOW ORDER IS TOP WORD)
				;NEGATIVE=>NEGATIVE OF SYSTEM TIME TO CONTINUE
				;POSITIVE=>NUMBER OF 60THS TO SLEEP
ESLEEP:	MOV (E)+,C		;SAVE IT IN C
	MOV (E)+,D		;SAVE IT IN D
	TST D			;IS IT NEGATIVE?
	BLT ESLEE1		;YES, GO SEE IF IT'S TIME YET
	NEG C			;NEGATE DOUBLE WORD NUMBER
	ADC D
	NEG D
	SUB LSTIME,C		;NOW COMPUTE NEGATIVE TIME TO WAKE UP
	SBC D
	SUB LSTIME+2,D
	MOV D,-2(E)
	MOV C,-4(E)
ESLEE1:	
.IFNZ LSTTY
.IF DF BRAKE
	TST LSIBRK
	BNE 1$			;EXIT ON A BRAKE
.ENDC
.ENDC
	MOV C,A			;COPY TIME TO WAKE UP
	MOV D,B
	ADD LSTIME,A
	ADC B
	ADD LSTIME+2,B
	BLT ESLEE1
1$:	RTS PC
.ENDC
ESSTAT:	MOV (E)+,A
	MOV #%FNAM2,(A)+
.IFNZ LSCLK
	MOV LSTIME,(A)+
	MOV LSTIME+2,(A)+
.IFF
	CLR (A)+
	CLR (A)+
.ENDC
	CLR (A)+
	CLR (A)+
	RTS PC

EGERRW:	TST LSERCD		;ERROR?
	LSERRC EQ,NUL
	MOV LSERCD,-(E)
	BIC #177700,(E)
	MOV LSERPC,-(E)
ENOOP:ESINK:EFLOAT:	RTS PC


LSACSV:	SAVE <E,D,C,B,A>
	JMP (F)

LSACRT:	TST (P)+
	REST <A,B,C,D,E>
	RTS F


.SBTTL LSI TTY INTERRUPT ROUTINES
.MACRO LSTTYI NUMBER
LSRIN'NUMBER:	SAVE B
	MOV #NUMBER*2,B
	BR LSRINT

LSTIN'NUMBER:	SAVE B
	MOV #NUMBER*2,B
	BR LSTINT
.ENDM

.REPT LSTTY-1
	LSTTYI \.RPCNT+1
.ENDR
				;TTY RECIEVER INTERRUPT HANDLER
LSRIN0:	SAVE B
	CLR B			;THIS IS TTY ZERO
LSRINT:	SAVE <A,C>
	MOVB @LSRBUF(B),C
	BIC #177600,C
.IF DF BRAKE
	TST B			;TTY ZERO?
	BNE 1$			;NOPE
	CMPB C,#'G-100		;CTRL G?
	BEQ LSBRAK
	CMPB C,#'Z-100		;CTRL Z?
	BEQ LSPAUS
1$:
.ENDC
	MOV LSTIBT(B),A		;INPUT BUFFER
	JSR PC,LSBFPT		;PUT INTO INPUT BUFFER
	BEQ RTTAL		;IF SO, THIS CHAR LOSES
.IIF Z DMPCAS,RTTAL:
RTTA:	REST <C,A,B>
	RTT
.IF NZ DMPCAS
RTTAL:	INC LSILSC		;ONE MORE LOST CHARACTER
	BR RTTA
.ENDC
.IF DF BRAKE
LSBRAK:	MOV #1,BRAKE		;SIGNAL LOGO THAT THERE'S A BREAK
BRRET:	MOV #1,LSIBRK		;AND SIGNAL LSITTY CODE AS WELL
	BR RTTA

LSPAUS:	MOV #-1,BRAKE		;SIGNAL LOGO THAT THERE'S A PAUSE
	BR BRRET
.ENDC
LSTIN0:	SAVE B
	CLR B			;I AM TTY 0
LSTINT:	SAVE <A,C>
	MOV LSTOBT(B),A		;THE OUTPUT BUFFER
	JSR PC,LSBFGT		;GET A CHARACTER
	BEQ 3$			;IF NONE, DONE
	MOVB C,@LSTBUF(B)	;XMIT CHAR
2$:	REST <C,A,B>
	RTT
3$:	BIC #100,@LSTTCS(B)		;DISABLE INTERUPTS
	BR 2$

				;INIT THE LITTLE SITS EMULATOR
LSINIT:	MOV #LSINTB,A
1$:	MOV (A)+,B
	BEQ 2$
	MOV (A)+,(B)
	BR 1$
2$:	RTS PC

CCTTCP:	JSR PC,GETCPS
	MOV 2(E),A		;GET THE TTY NUMBER
	CMP #LSTTY,A		;TOO BIG?
	LSERRC LOS,BAD
	ASL A
	SAVE 4		;SAVE THE TRAP VECTOR
	MOV #1$,4		;SET UP FOR THE TRAP
	BIS #100,@LSTRCS(A)
	REST 4
	MOV A,LSCRN1(F)
	MOV #.TTCAP,LSCPTB(F)	;CREATE THE CAP
	ADD #4,E
	RTS PC

1$:	REST <,,4>
	LSERR BAD		;NO INTERFACE FOR THIS TTY ON THIS MACHINE


TTDELC:	CLR LSCPTB(C)
	ADD #6,E
	RTS PC

.SBTTL LSI EMULATOR TRAP ROUTINE
				;HERE WE IMPLEMENT SOME PSEUDO-SITS SYSTEM CALLS, NOTABLY BYTI/O AND SOME
				;TTY INVOKES

LSITRP:	SAVE A
	MOV 2(P),A		;GET THE PC
	BIT #200,-(A)		;TRAP TO USER?
	BEQ 1$			;NOPE
	REST A			;YUP
	JMP @40			;GO THROUGH 40 ON THE LSI
1$:	REST A
	REST <LSPC,LSPS>	;SAVE THE USER PC AND PS
	BIC #17,LSPS		;IF WE WIN WE EXIT WITH COND CODES CLEAR
	MOV P,LSTRPP		;SAVE PTR TO TOP OF STACK
	MOV #LSETRP,LSITRV	;SET UP FOR ERROR CALLS
	CMP -(P),-(P)		;THIS IS SO GERRW DOESN'T CLOBBER THE STACK
	JSR F,LSACSV
.IF NZ METERS
	SAVE METERP
	MOV #MTLSIT,METERP
.ENDC
	MOV P,LSEPDL
	MOV LSTRPP,E
	MOV LSPC,A
	MOV -(A),A		;GRAB TRAP INSTR
	BIC #177700,A		;CLEAR ALL BUT DISPATCH #

	CMP #LSETOP,A		;IS THIS IN RANGE?
	LSERRC LT,BAD
	ASL A			;=>WORD OFFSET
	JSR PC,@LSETAB(A)	;DISPATCH
	MOV E,LSTRPP
LSERET:
.IF NZ METERS
	REST METERP
.ENDC
	JSR F,LSACRT
	MOV LSTRPP,P
	MOV #LSITRP,LSITRV	;BACK TO REGULAR TRAPS
	SAVE <LSPS,LSPC>
	RTI

				;WHEN A SYSTEM CALL LOSES IT DOES AN TRP, WHICH GETS US HERE
LSETRP:	CMP #LSITSB,(P)		;MAKE SURE WE WERE IN LSITS
	BLOS 2$
1$:	MOV #LSITRP,LSITRV	;SHOULD HAVE GONE TO REGULAR TRAP HANDLER
	JMP LSITRP		;SO GO THERE
2$:	CMP #LSITSE,(P)
	BLOS 1$
	REST <A>		;GET THE PC
	TST -(A)		;POINT TO THE TRAP
	MOV A,LSERPC		;FOR THE POOR LOSER TRYING TO FIGURE OUT WHAT HAPPENED
	MOV LSPC,LSUERP		;SAVE USER ADDRESS OF ERROR CALL
.IIF NZ LSDISK,	CLR TRNERR	;MAKE SURE TRANSFER ERROR ONLY GETS US ONCE
	MOVB (A),LSERCD		;SAVE THE ERROR CODE
	BIT #TRPZBT,(A)		;SET Z?
	BEQ 4$
	BIS #4,LSPS
4$:	BIT #TRPVBT,(A)		;SET V?
	BEQ 5$	
	BIS #2,LSPS
5$:	BIT #4,LSPS		;IS Z SET?
	BEQ 3$			;THEN THIS CALL DISN'T REALLY LOSE
	MOV LSPC,B		;GET THE CALLERS ADDRESS
	BIT #100,-(B)		;DID HE WANT TO LOSE ON ERROR?
	BEQ 3$
	BPT
3$:	MOV LSEPDL,P		;RESET THE PDL
	BR LSERET





.SBTTL TTY INVOKS
				;LSITRP IS TRAPPED TO BY PSEUDO-SITS SYSTEM CALLS,
				;AND DISPATCHES HERE THRU LSETAB
				;LSEMTB HOLDS PTR TO IMMEDIATELY POST-TRAP TOP OF STACK
				;LSINVK CAN CLOBBER A, B, C
LSINVK:	MOVB (E),C		;GET THE CAP NUMBER
	CMP #LSMAXC,C		;COMPARE TO MAX POSSIBLE
	LSERRC LO,BAD		;LOSE IF TOO BIG
	ASL C			;MAKE A WORD INDEX
	MOV LSCPTB(C),D		;GET THE CAP TYPE
	LSERRC EQ,BCN		;NO CAP THERE
	MOVB 1(E),B		;GET THE FUNCTION
	BLT LSSYSF		;SYSTEM WIDE TYPE FUNCTION
	ASL B			;MAKE FUNCTION A WORD INDEX
.IFNZ LSTTY			;IF TTY IMPLEMENTED
	CMP #.TTCAP,D		;IS THIS A TTY?
	BNE 1$			;NOPE
	CMP #LSTTIM*2,B		;BIGGER THAN MAX?
	LSERRC LO,BFUN
	MOV LSCRN1(C),F		;THE TTY INDEX
	JMP @LSITAB(B)		;GO SERVICE FUNCTION	
.ENDC
1$:
.IFNZ LSDISK			;IF DISK IMPLEMENTED
	CMP #.FACAP,D		;IS IT A FA CAP?
	BNE 2$			;NOPE
	ASR B
	CMP #LSFAIM*2,B		;BIGGER THAN MAX?
	LSERRC LO,BFN
	JMP @LSFAIT(B)		;GO SERVICE THAT
2$:
.ENDC
FOO=0
.IIF G LSTTY-1,FOO=1
.IFNZ LSDISK!LSPRNT!FOO
	CMP #.CCCAP,D		;CREATE CAP?
	BNE 3$			;NOPE
	JMP CCINVK		;GO DO INVOK OF CREATE CAP
3$:
.ENDC
.IFNZ LSPRNT
				;NO PRINTER INVOKES IMPLEMENTED
.ENDC

	LSERR BCT
LSLOSE:	LSERR BAD

.IFNZ LSDISK!LSPRNT!FOO
CCINVK:
.IFNZ LSDISK
	CMPB 1(E),#.FACAP	;DOES HE WANT FA CAP?
	BNE 1$
	JMP CCFACP
1$:
.ENDC
.IFNZ LSPRNT
	CMPB 1(E),#.LPCAP
	BNE 2$
	JMP CCLPCP
2$:
.ENDC
.IF NZ FOO
	CMPB 1(E),#.TTCAP	;DOES HE WANT A MULTIPLE TTY CAP?
	BNE 3$
	JMP CCTTCP
3$:
.ENDC
	LSERR BCT

LSSYSF:	BIC #177400,B		;FLUSH SIGN EXTEND
	CMP #<.DELCP_-8>&377,B	;IS IT A DELETE CAP?
	BEQ LSDELC
	CMP #<.CPYCP_-8>&377,B	;IS IT COPY CAP?
	BEQ LSCPYC
	LSERR BFUN

LSDELC:
.IFNZ LSDISK
	CMP #.FACAP,D
	BNE 2$
	JMP FADELC
2$:
.ENDC
.IFNZ LSPRNT
	CMP #.LPCAP,D
	BNE 3$
	JMP LPDELC
3$:
.ENDC
.IF G LSTTY-1			;MULTIPLE TTYS
	CMP #.TTCAP,D
	BNE 4$
	JMP TTDELC
4$:
.ENDC
	LSERR BFUN		;DON'T WANT ANYTHING ELSE DELETED

LSCPYC:
.IFNZ LSDISK
	CMP #.FACAP,D
	BNE 1$
	JMP FACPYC
1$:
.ENDC
	LSERR BFUN


LSBYTI:	MOV #LSBITB,A
	BR LSDOIO

LSBYTO:	MOV #LSBOTB,A
	BR LSDOIO

LSWRDI:	MOV #LSWITB,A
	BR LSDOIO

LSWRDO:	MOV #LSWOTB,A
	BR LSDOIO

LSBLKI:	MOV #LSBLIT,A
	BR LSDOIO

LSBLKO:	MOV #LSBLOT,A

LSDOIO:	MOVB (E),F		;GET CAP NUMBER FORM USER
	CMP #LSMAXC,F		;TOO BIG?
	LSERRC LOS,BCN
	ASL F			;MAKE AN INDEX
	MOV LSCPTB(F),C		;GET TYPE
.IFNZ LSTTY
	CMP #.TTCAP,C		;TTY?
	BNE 1$
	MOV LSCRN1(F),LSCTTY	;SET UP THE CURRENT TTY NUMBER
	JMP @LSTTIO(A)		;WHERE A IS THE TABLE AND LSTTIO IS THE INDEX!!!
1$:
.ENDC

.IFNZ LSDISK
	CMP #.FACAP,C		;DISK?
	BNE 2$
	JMP @LSFAIO(A)
2$:
.ENDC

.IFNZ LSPRNT
	CMP #.LPCAP,C		;PRINTER?
	BNE 3$
	JMP @LSLPIO(A)
3$:
.ENDC
	LSERR BCT

.IFNZ LSTTY			;STUFF FOR THE TTY ONLY
				;INVOK DISPATCH ROUTINES ARE CALLED FROM LSINVK THRU LSITAB
				;CALLED WITH IMMEDIATELY POST-TRAP STACK PTR IN A
				;THESE ROUTINES REFORM THE STACK SO IT'LL BE THE RIGHT THING WHEN THE $INVOK RETURNS
				;MAY CLOBBER A,B,C


				;.TTMOV ROUTINE
LSTTMV:	MOV 2(E),LSITTS(F)	;MOVE 2ND INVOK ARG TO LSITTS
				;OTHERS ENTER HERE TO FLUSH 3 INVOK ARGS FROM MID-STACK
LSSTF3:	ADD #6,E		;POINT TO WORD UNDER RETURN PSW
	RTS PC


				;.TTBIS ROUTINE
LSTTBS:	BIS 2(E),LSITTS(F)	;SET LSITTS BITS AS SPECIFIED BY 2ND INVOK ARG
	BR LSSTF3		;AND FLUSH INVOK'S 3 ARGS FROM MID-STACK


				;.TTBIC ROUTINE
LSTTBC:	BIC 2(E),LSITTS(F)	;CLEAR LSITTS BITS AS SPECIFIED BY 2ND INVOK ARG
	BR LSSTF3		;AND FLUSH INVOK'S 3 ARGS FROM MID-STACK


				;.TTRD ROUTINE
LSTTRD:	MOV LSITTS(F),4(E)	;CLOBBER INVOK'S 2ND STACKED ARG WITH LSITTS
LSTTR1:	JMP LSSTF2		;AND FLUSH 2 ARGS FROM MID-STACK


				;.TTCNO ROUTINE
LSTTCN:
	MOV LSCHNO,4(E)		;CLOBBER INVOK'S 2ND STACKED ARG WITH LSCHNO
	BR LSTTR1

LSTTPK:	MOV LSTIBT(F),A		;THE INPUT BUFFER
	TST LSBFCN(A)		;ANY CHARS?
	BNE 1$			;YES
	MOV #-1,4(E)		;NO, RETURN -1 IN LIEU OF STACKED TTYCAP
	BR LSTTR1
1$:	MOVB @LSBFOP(A),4(E)	;WE'VE GOT A CHAR, RETURN IT
	CLRB 5(E)
	BR LSTTR1

LSTTSL:	MOV 2(E),LSCHMX		;SET LINE LENGTH
	BR LSSTF3

.SBTTL LSITYI AND LSITYO
				;THESE ARE IN LIEU OF SITS TYI & TYO, NOT *LOGO* TYI & TYO
				;PUT NEXT INPUT BUFFER CHAR INTO A
LSITYI:	TST LSIBRK		;BREAK?
	BNE 2$			;IF SO, RETURN IMMEDIATELY
	SAVE C
	MOV LSCTTY,A		;WHATEVER THE CURRENT TTY IS
	MOV LSTIBT(A),A		;THE INPUT BUFFER
	JSR PC,LSBFGT		;GET A CHARACTER
	BNE 3$			;IF NOT, WAIT
.IIF NZ METERS,	MOV #MTTYI,METERP
.IIF DF XORFLG,	JSR PC,INCHK	;DO AN INCREMENT OF CHECKING WHILE WAITING
	REST C
	BR LSITYI
3$:	MOV C,A
	REST C
.IIF NZ METERS,	MOV #MTLSIT,METERP
	CLZ			;SIGNAL NO BREAK
	RTS PC
2$:
.IIF NZ METERS,	MOV #MTLSIT,METERP
	CLR A
	RTS PC			;RETURN WITH Z SET

				;SPECIAL FOR MEMORY ERROR MESSAGES
LSISTY:	SAVE B
	MOV D,B
	CLR LSCTTY
	JSR PC,LSITY3		;IGNORE BREAKS
	MOV #LSTOB0,B
1$:	TST LSBFCN(B)		;DON'T RETURN TILL BUFFER EMPTY
	BNE 1$
	REST B
	RTS PC
				;PUT BYTE FROM B INTO OUTPUT BUFFER
LSITYO:	TST LSIBRK		;BREAK?
	BNE LSITY2		;IF SO,RETURN IMMEDIATELY
LSITY3:	SAVE <A,C>
	MOV LSCTTY,A
	MOV LSTOBT(A),A		;OUTPUT BUFFER
	MOV B,C
1$:	JSR PC,LSBFPT		;PUT INTO IT
	BEQ 1$			;IF SO, WAIT
	MOV LSCTTY,A
	BIS #100,@LSTTCS(A)	;ENABLE INTERUPT TO BE SURE CHAR GETS OUT
	REST <C,A>
LSITY2:	RTS PC



.SBTTL LSI BYTI
;LSBYTI IS CALLED THRU A DISPATCH TABLE (LSETAB) FROM LSITRP, WHERE
;PSEUDO-SITS SYSTEM CALLS TRAP TO.
;LEAVES BYTE ON STACK WHERE $BYTI'ER EXPECTS IT.
;CLOBBERS A,B (THO LSITRP WILL RESTORE THEM TO THEIR PRE-TRAP VALUES)
;LSBYTI RTNS DISPATCHED THRU LSBIDS MAY CLOBBER A,B
;LSBYTI ACT PRETTY MUCH LIKE SITS BYTI, USING LSITTS AS THE TTY STATUS WD
;NOTE, HOWEVER:
;		1) CTRL Y ISN'T IMPLEMENTED HERE. RATHER, THE PREVIOUS TYPED
;		LINE IS BY DEFAULT IN THE EDIT BUFFER (IN FACT THERE IS
;		NO EDIT BUFFER, JUST THE OLD LINE BUFFER) AND ALL LINE-
;		INPUT BYTI'S ARE IN EDIT MODE (NO .TIEDM BIT)
;
;		2) IF BACKSPACEABLE TTY (LSTVEE=1), RUBOUTS AND CTRL W'S WORK
;		THE RIGHT WAY, AND CTRL S AND CTRL D EDIT COMMANDS ARE FLUSHED.
;
;		3) SOME TTY MODE BITS AREN'T IMPLEMENTED HERE

LSTBYI:	JSR PC,LSRSET		;RESET TTY BUFFERS IF BREAK OCCURRED
.IF Z LSLINE
	BR LSNLIM		;ONLY IMAGE INPUT
.IFF
	MOV LSCTTY,A		;WHATEVER THE CURRENT TTY IS
	BIT #.TLIPM,LSITTS(A)	;LINE INPUT MODE?
	BEQ LSNLIM		;NO
	TST LSBYLP		;YES, IS THERE A LINE PENDING FROM A PREVIOUS .TLIPM BYTI?
	BNE LSBRTC		;IF SO, JUST RETURN A CHAR FROM LINBUF
	INC LSBYLP		;IF NOT, THERE IS NOW--MAKE FLAG NONZERO
LSBLLL:	JSR PC,LSITYI		;GET NEXT INPUT-BUFFER BYTE INTO A
	BEQ LSBYDN		;IF INTERRUPTED BY A BREAK, RETURN IMMEDIATELY
	JSR PC,LSBIUC		;UPPER-CASIFY A IF APPROPRIATE
	ASL A
	JSR PC,LSBIDP		;DISPATCH ON CHAR, SEZ IFF UNQUOTED CR
	CMP #15,A		;IS IT A CR?
	BEQ 7$
	CMP LSCLNN,#LSLINL	;IF NOT, IS LSCLIN FULL?
	BNE LSBLLL		;IF NOT, KEEP GOING

7$:	MOV #LSLINL/2,A		;STASH CURRENT LINE IN OLD LIN BUF TOO
	MOV #LSCLIN,B
1$:	MOV (B)+,LSLINL-2(B)
	SOB A,1$
	MOV LSCLNA,LSOLNA	;STASH POINTERS AS WELL
	ADD #LSLINL,LSOLNA
	MOV LSCLNZ,LSOLNZ
	ADD #LSLINL,LSOLNZ
	MOV LSCLNN,LSOLNN	;AND # OF BYTES

LSBRTC:	MOVB @LSCLNA,A		;GRAB NEXT BYTE FROM LINBUF
	DEC LSCLNN
	TST LSCLNN		;ANY MORE BYTES?
	BLE LSBYNM		;NO
	INC LSCLNA		;YES, INC PTR
	CMP LSCLNA,#LSCLIN+LSLINL	;TIME TO WRAP?
	BLO 1$
	MOV #LSCLIN,LSCLNA	;YES
1$:	CMPB A,#15		;END OF LINE?
	BNE LSBYDN		;IF NOT, GO FINISH UP

LSBYNM:	CLR LSBYLP		;NO MORE PENDING LINE
	CLR LSCLNN		;NO MORE BYTES IN CUR LIN BUF
	MOV #LSCLIN,LSCLNA	;REINIT PTRS
	MOV #LSCLIN,LSCLNZ
	
.ENDC ;LSLINE

LSBYDN:	MOV A,(E)		;BYTI'S RETURN VALUE REPLACES BYTI'S ARG ON STACK
	BIC #4,LSPS		;CLZ FOR RETURN PSW
	RTS PC

;NOTE THAT IF LSLINE FLAG IS ZERO WE FALL IN HERE FROM ABOVE
LSNLIM:	JSR PC,LSITYI		;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC		;UPPER-CASIFY A IF APPROPRIATE
	CMP #37,A		;IS IT CONTROLIFY?
	BNE LSBYDN
	BIT #.TICTM,LSITTS	;CONTROLIFY?
	BEQ LSBYDN		;NOPE
	JSR PC,LSITYI		;GET NEXT
	JSR PC,LSBIUC
	BIC #100,A
	BR LSBYDN		; (DEPENDING ON LSITTS BITS) VALUE IN A

.IF NZ LSLINE
LSBIDP:	CMP #100,A		;CONTROL?
	BHI 1$			;YES, DISPATCH
	CMP #376,A		;RUBOUT?
	BNE 2$
	JMP LSBIRU		;YUP
2$:	JMP LSBINO
1$:	JMP @LSBIDS(A)

LSBIDS:	LSBINO,LSBINO,LSBINO,LSBI.C,LSBI.D,LSBINO,LSBINO,LSBINO	;0-7
	LSBIRU,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBI.N,LSBINO	;10-17
	LSBINO,LSBI.Q,LSBI.R,LSBI.S,LSBINO,LSBINO,LSBINO,LSBI.W	;20-27
	LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBIUP	;30-37
.ENDC ;LSLINE
				;CONVERT BYTE IN A TO UPPER CASE IF .TICVM SET
LSBIUC:	BIT #.TICVM,LSITTS	;=> UPPER CASE MODE?
	BEQ 1$
	CMP A,#141		; < a ?
	BLT 1$
	CMP A,#172		; > z ?
	BGT 1$
	BIC #40,A		;NO, UPPER CASIFY
1$:	RTS PC


LSRSET:	TST LSIBRK		;IF BREAK OCCURRED, RESET THE TTY BUFFERS
	BEQ 1$			;IF NOT, NOOP
	CLR LSIBRK		;DON'T WANT TO DO THIS AGAIN
	SAVE A
	MOV #LSTIB0,A		;INPUT BUFFER
	JSR PC,LSBFRS		;RESET
	MOV #LSTOB0,A		;OUTPUT BUFFER
	JSR PC,LSBFRS
	REST A
.IF NZ LSLINE
	MOV #LSCLIN,LSCLNA
	MOV #LSCLIN,LSCLNZ
	CLR LSCLNN
	MOV #LSOLIN,LSOLNA
	MOV #LSOLIN,LSOLNZ
	CLR LSOLNN
	CLR LSBYLP
.ENDC ;LSLINE
1$:	RTS PC

.IF NZ LSLINE
				;ALL BYTI DISPATCH ROUTINES ARE CALLED FROM LSBYTI THRU LSBIDS, OR FROM OTHER
				;BYTI DISPATCH ROUTINES.
				;ALL BYTI DISPATCH ROUTINES ARE CALLED WITH BYTE*2 IN A.
				;BYTI DISPATCH ROUTINES MAY CLOBBER A,B
				;ONLY THE ROUTINE FOR AN UNQUOTED CR SHOULD RETURN WITH Z SET.

				;NORMAL MODE. RETURNS BYTE IN LSCLIN IF .TLIPM SET,
				; OR IN A IF .TLIPM CLEARED. ECHOS CHAR IFF .TIECM SET.
LSBINO:	ASR A			;=>BACK TO RIGHT-JUSTIFIED BYTE
	MOVB A,@LSCLNZ		;YES, STICK IN IN THE LINE BUFFER
	INC LSCLNZ		;ADVANCE  PTR
	CMP LSCLNZ,#LSCLIN+LSLINL	;WRAP?
	BLO 1$			;NO
	MOV #LSCLIN,LSCLNZ	;YES
1$:	INC LSCLNN		;INC COUNTER
LSBIN1:	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSBIN2		;NO, ALL DONE
	BIT #.TIMGO,LSITTS	;ECHO ONLY WORKS IF NOT IN IMAGE OUT MODE
	BNE LSBIN2
	TST LSTVEE		;TV-TYPE TTY?
	BNE 5$			;IF SO, WE DON'T CARE ABOUT RUBOUTS

	TST LSRIP		;RUBOUT IN PROGRESS?
	BEQ 5$			;NO
	CLR LSRIP		;YES, BUT NO
	MOV #'\*2,B		;TYPE BACKSLASH
	JSR PC,LSBONO

5$:	MOV A,B			;SET UP ARG IN B FOR ECHO
	JSR PC,LSBOD		;AND DISPATCH THRU BYTO'S TABLE TO ECHO
LSBIN2:	RTS PC


				;RUBOUT ROUTINE
LSBIRU:	JSR PC,LSRUBO		;PUT LAST CHAR, IF ANY, IN A, FLUSHING FROM LSCLIN
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSBIR4		;NO, GO HOME
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE LSBIR4		;YES, LIKEWISE
				;LSBI.W ENTERS HERE
LSBIR1:	TST LSTVEE		;BACKSPACE/ERASABLE CONSOLE?
	BEQ LSBIR5		;NO, SHIT
	TST A			;WAS THERE A CHAR TO RUB OUT?
	BMI LSBIR4		;NO, NOOP
	MOV #10*2,B		;BSPER CHAR
	JSR PC,LSBOBE		;TYPE BACKSPACE/ERASE
LSBIR4:	RTS PC

LSBIR5:	TST A			;WAS THERE A CHAR TO RUB OUT?
	BMI LSNMRB		;NO
LSBIR2:	TST LSRIP		;YES, IS RUBOUT IN PROGRESS? (LSBI.S & LSBI.D ENTER HERE)
	BNE 4$			;YES
	INC LSRIP		;NO, NOW IT IS
	MOV #'\*2,B
	JSR PC,LSBONO		;TYPE BACKSLASH
4$:	MOV A,B			;SET UP ARG IN B FOR LSBODS
	JSR PC,LSBOD		;ECHO RUBBED CHARACTER
	CLZ
	RTS PC

LSNMRB:	TST LSRIP		;NOTHING LEFT TO RUB. RUBOUT IN PROGRESS?
	BEQ 5$			;NO, NOOP
	CLR LSRIP		;YES, BUT NO LONGER
	MOV #'\*2,B		;TYPE BACKSLASH
	JSR PC,LSBONO
5$:	CLZ
	RTS PC


				;CTRL W ROUTINE
LSBI.W:
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ 4$			;NO, GO TO SILENT LOOP
	BIT #.TIMGO,LSITTS	;IMAGE OUT?
	BNE 4$			;YES, GO TO SILENT LOOP

	JSR PC,LSRUBO		;PUT LAST CHAR IN A (IF ANY, ELSE -1=>A), FLUSHING FROM BUFFER
	JSR PC,LSBIR1		;BORROW LSBIRU CODE FOR ECHOING, ETC
2$:	JSR PC,LSRUB1		;RUBOUT AGAIN, UNLESS NONE LEFT, **OR WORD BOUNDARY**
	BEQ 3$
	JSR PC,LSBIR1		;IF NOT, GO ON
	BR 2$
3$:	RTS PC
	
4$:	JSR PC,LSRUBO		;SILENT LOOP--RUBOUT WORD WITHOUT ECHOING
5$:	JSR PC,LSRUB1	
	BNE 5$
	RTS PC

				;CTRL C ROUTINE
LSBI.C:	JSR PC,LSEBTI		;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO LSCLIN AND A
	BEQ LSRTSX		;IF NONE, NOOP
	JMP LSBIN1		;DO PROPER ECHOING


				;CTRL N ROUTINE
LSBI.N:	JSR PC,LSEBTI		;GET NEXT BYTE,IF ANY,FROM EDIT BUFER INTO LSCLIN AND A
	BEQ LSRTSX		;IF NOTHING LEFT, QUIT
	JSR PC,LSBIN1		;ECHO
	TSTB LSBOUN(A)		;WORD BOUNDARY CHAR?
	BEQ LSBI.N		;IF NOT, GO ON
LSRTSX:	CLR A			;MAKE SURE NO LEFT OVER CR HERE
	RTS PC
				;CTRL R ROUTINE
LSBI.R:	JSR PC,LSEBTI		;GET NEXT BYTE, IF ANY, FROM EDIT BUFFER INTO LSCLIN AND A
	BEQ LSRTSX		;IF NOTHING LEFT, QUIT
	JSR PC,LSBIN1		;ECHO CHARACTER
	BR LSBI.R		;AND GO ON TO NEXT


				;CTRL D ROUTINE
LSBI.D:	TST LSTVEE		;GOOD TTY?
	BEQ 3$			;IF NOT, PROCEED
	JMP LSBINO		;IF SO, WE DON'T WANT A CTRL D EDIT CHAR, TREAT AS NORMAL
	
3$:	JSR PC,LSEBI1		;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO A
	BEQ LSRTSX		;IF NONE, NOOP
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSRTSX		;IF NOT, ALL DONE
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE LSRTSX		;IF SO, ALL DONE
	JMP LSBIR2		;USE RUBOUT CODE TO ECHO SKIPPED CHAR PROPERLY

				;CTRL S ROUTINE
LSBI.S:	TST LSTVEE		;GOOD TTY?
	BEQ 3$			;IF NOT, PROCEED
	JMP LSBINO		;IF SO, WE DON'T WANT A CTRL S EDIT CHAR, TREAT AS NORMAL

3$:	JSR PC,LSEBI1		;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO A
	BEQ LSRTSX		;IF NONE, GIVE UP
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ 4$			;IF NOT, SKIP THE ECHO
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE 4$			;IF SO, SKIP THE ECHO
	JSR PC,LSBIR2		;USE RUBOUT CODE TO ECHO SKIPPED CHAR PROPERLY
4$:	TSTB LSBOUN(A)		;DID WE JUST SKIP A WORD BOUNDARY CHAR?
	BEQ 3$			;IF NOT, CONTINUE
2$:	RTS PC


				;UPARROW ROUTINE
LSBIUP:	BIT #.TICTM,LSITTS	;CONTROLIFY MODE?
	BNE 1$			;IF SO, PROCEED
	JMP LSBINO		;IF NOT, JUST RETURN CHAR IN A

1$:	JSR PC,LSITYI		;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC		;UPPER-CASIFY IF APPROPRIATE
	BIC #100,A		;CONTROLIFY THE CHARACTER
	ASL A
	JMP LSBIDP		;AND REDISPATCH


				;CONTROL Q ROUTINE
LSBI.Q:	JSR PC,LSITYI		;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC		;UPPER-CASIFY IF APPROPRIATE
	ASL A
	JMP LSBINO		;AND TREAT IT AS A NORMAL CHARACTER, WHATEVER IT IS

				;(NOT A DISPATCH ROUTINE)
				;FLUSH LAST CHAR FROM LSCLIN, PUTTING IT IN A
				;IF NO CHAR THERE, RETURN WITH Z SET & -1 IN A
LSRUBO:	TST LSCLNN		;ANYTHING LEFT TO RUB OUT?
	BEQ LSRBLU		;NO, RETURN WITH -1 IN A
	MOV LSCLNZ,A
	MOVB -1(A),A		;GET LAST BYTE INTO A
	BIC #177400,A
	BR LSRUB2

LSRUB1:	TST LSCLNN		;LIKE LSRUBO BUT FAILS ON WORD-BOUNDARY CHAR AS WELL
	BEQ LSRBLU		; AS WHEN NO CHAR LEFT IN BUFFER
	MOV LSCLNZ,A
	MOVB -1(A),A
	BIC #177400,A
	TSTB LSBOUN(A)		;BOUNDARY CHAR?
	BNE LSRBLU		;YES, LOSE

LSRUB2:	DEC LSCLNN		;ONE LESS CHAR IN LINBUF
	DEC LSCLNZ		;RETREAT PTR
	CMP LSCLNZ,#LSCLIN	;BKWDS WRAP?
	BHIS 2$			;NO
	MOV #LSCLIN+LSLINL,LSCLNZ	;YES
2$:	CLZ
	RTS PC
LSRBLU:	MOV #177777,A
	SEZ
	RTS PC



				;(NOT A DISPATCH ROUTINE)
				;READ CHAR FROM EDIT BUF INTO A
				;RETURN WITH Z SET IFF NOTHING THERE
LSEBI1:	TST LSOLNN		;ANY CHARS LEFT?
	BEQ 1$			;IF NOT, RETURN WITH Z SET
	MOVB @LSOLNA,A		;GET NEXT CHAR INTO A
	BIC #177400,A
	CMP A,#15		;CR?
	BEQ 1$			;IF SO, RETURN WITH Z SET
	DEC LSOLNN		;DEC COUNTER
	INC LSOLNA		;ADVANCE POINTER
	CMP LSOLNA,#LSOLIN+LSLINL	;WRAP?
	BNE 1$			;NO, RETURN WITH Z CLR
	MOV #LSOLIN,LSOLNA	;YES, RETURN WITH Z CLR
1$:	RTS PC


				;(NOT A DISPATCH ROUTINE)
LSEBTI:	JSR PC,LSEBI1		;PUT NEXT CHAR, IF ANY, FROM EDIT BUFFER INTO A
	BNE 2$			;IF SOMETHING WAS THERE, PROCEED
1$:	RTS PC			;ELSE, RETURN WITH Z SET

2$:	CMP LSCLNN,#LSLINL	;BUFFER FULL?
	BEQ 1$			;IF SO, RETURN WITH Z SET
	MOVB A,@LSCLNZ		;PUT CHAR INTO CURRENT LINE BUFFER
	INC LSCLNN		;INC COUNTER
	INC LSCLNZ		;ADVANCE PTR
	CMP LSCLNZ,#LSCLIN+LSLINL	;TIME TO WRAP?
	BNE 3$			;NO, RETURN WITH Z CLEAR
	MOV #LSCLIN,LSCLNZ	;YES, RETURN WITH Z CLEAR
3$:	RTS PC

.ENDC ;LSLINE

.SBTTL LSBYTO
				;LSBYTO IS DISPATCHED THRU LSETAB FROM LSITRP, WHICH PSEUDO-SITS CALLS TRAP TO
				;LSBYTO MAKES LSITRP EMULATE SITS $BYTO, USING LSITTS AS TTY STATUS WORD
				;A,B ARE CLOBBERED (BUT RESTORED TO PRE-TRAP STATE BY LSITRP)
				;$BYTO'S 2 ARGS ARE FLUSHED FROM MID-STACK BEFORE RETURN
LSTBYO:	JSR PC,LSRSET		;RESET TTY BUFFERS IF BREAK OCCURRED
	MOV 2(E),B		;GET CHAR TO BYTO
	BIC #177400,B
.IF NZ LSLINE
	BIT #.TTEDM,(E)		;WRITE INTO "EDIT" (OLD LINE) BUFFER?
	BNE LSEBTO		;YES
.ENDC
	TST LSCTTY		;TTY ZERO?
	BNE 2$			;NO, ALWAYS IMAGE
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BEQ 1$			;NO, PROCEED
2$:	JSR PC,LSITYO		;YES, JUST SPIT IT OUT
	BR LSBTO1
1$:	JSR PC,LSBOD		;DISPATCH
LSBTO1:	BIC #4,LSPS		;CLZ FOR TRAP RETURN
				;(OTHERS ENTER HERE TO FLUSH 2 TRP ARGS FROM MID-STACK)
LSSTF2: ADD #4,E		;POINT TO WORD UNDER RETURN PSW
	RTS PC

.IF NZ LSLINE
LSEBTO:	BIT #.TERST,LSITTS	;RESET "EDIT" (OLD LINE) BUFFER?
	BEQ 1$			;NO
	CLR LSOLNN		;YES, NO CHARS IN BUFFER
	MOV #LSOLIN,LSOLNA	;INIT PTRS
	MOV #LSOLIN,LSOLNZ
	BIC #.TERST,LSITTS	;DON'T WANT TO DO THIS AGAIN
	BR 3$
1$:	CMP LSOLNN,#LSLINL	;OLD LINE BUFFER FULL?
	BEQ LSBTO1		;OH WELL, NOTHING CAN BE DONE ABOUT THAT
3$:	MOVB B,@LSOLNZ		;PUT CHAR IN BUFFER
	INC LSOLNZ		;ADVANCE PTR
	CMP LSOLNZ,#LSOLIN+LSLINL	;WRAP?
	BLO 2$
	MOV #LSOLIN,LSOLNZ
2$:	INC LSOLNN		;INC COUNTER
	BR LSBTO1
.ENDC

				;LSBLKO IS TO $BLKO AS LSBYTO IS TO $BYTO
LSTBLO:	JSR PC,LSRSET		;RESET TTY BUFFER IF BREAK OCCURRED
	MOV 4(E),F		;GET PTR TO BYTES TO XFER
	MOV 2(E),D		;GET NEG # OF BYTES TO XFER
	NEG D			;MAKE # POSITIVE
	BEQ 3$
	BPL 2$			;(WE HOPE)
	BPT			;ONLY $BLKO, NOT .BLKO, SO MISTAKE CRAPS OUT HERE
2$:	MOVB (F)+,B		;GET NEXT BYTE
	TST LSCTTY		;TTY ZERO?
	BNE 1$			;NO, ALWAYS IMAGE
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BEQ 4$			;NO, PROCEED
1$:	JSR PC,LSITYO		;YES, JUST TYPE IT
	BR 5$
4$:	JSR PC,LSBOD		;AND BYTO IT
5$:	TST LSIBRK		;IF BREAK, FLUSH THE REST
	BNE 3$
	SOB D,2$		;IF NOT, GO BACK FOR MORE, IF ANY
3$:	JMP LSSTF3		;FLUSH THE 3 BLKO ARGS & RETURN	

LSBODS:	LSBON.,LSBO.A,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBOFL
	LSBOBE,LSBOTX,LSBOLF,LSBON.,LSBOFF,LSBOCR,LSBON.,LSBON.
	LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.
	LSBON.,LSBOBS,LSBOUP,LSBON.,LSBOHD,LSBOHU,LSBOCL,LSBOCF

LSBOUN:	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,1,1,0,1,1,0,0	;CR,LF,FF,TAB
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 1,0,0,0,0,0,0,0	;SPACE
	.BYTE 1,1,1,1,0,1,0,1	;(,),*,+,-,/
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,0,0,0,1,1,1,0	;<,=,>
	.BLKB 30
	.BYTE 0,0,0,0,0,1,1,1	;[,\,]
	.BLKB 40

				;THIS ROUTINE REPLACES THE LARGE DISPATCH TABLE
LSBOD:	ASL B
	CMP #100,B
	BLE LSBONO
	JMP @LSBODS(B)

				;BYTO DISPATCH ROUTINES ARE CALLED FROM LSBYTO THRU LSBODS,
				;AND FROM VARIOUS BYTI DISPATCH ROUTINES, EITHER DIRECTLY OR THRU LSBODS.
				;ALL BYTO DISPATCH ROUTINES ARE CALLED WITH CHAR*2 IN B.
				;BYTO DISPATCH ROUTINES MAY CLOBBER B, BUT *NOT* A.

				;NORMAL CHAR BYTO DISPATCH ROUTINE
LSBONO:	ASR B			;NORMALIZE CHARACTER
	JSR PC,LSITYO		;AND OUTPUT IT
	INC LSCHNO		;ONE MORE CHARACTER IN LINE
	BR LSEOL


				;TAB ROUTINE
LSBOTX:	ASR B
	JSR PC,LSITYO		;OUTPUT THE TAB
	BIC #7,LSCHNO		;RAISE CHAR COUNT TO NEXT HIGEST MULTIPLE OF EIGHT
	ADD #10,LSCHNO
				;FALL THOUGH TO LSEOL

LSEOL:	CMP LSCHNO,LSCHMX	;SEE IF WE'VE COME TO THE END OF THE LINE
	BLT LSEOL2		;IF NOT, ALL DONE
				;THIS PART IS THE ACTUAL BYTO DISPATCH CR ROUTINE
LSBOCR:	MOV #15,B
	JSR PC,LSITYO		;TYPE CR
	MOV #12,B
	JSR PC,LSITYO		;TYPE LF
	CLR LSCHNO		;NO CHARS ON NEW TYPED LINE
	TST LSTVEE		;DO WE NEED TO WORRY ABOUT PAGE BOTTOM, CLR EOL'S?
	BEQ LSEOL2		;NO, DONE
	INC LSLNNO		;ONE MORE LINE ON PAGE
	CMP LSLNNO,LSLNMX	;END OF PAGE?
	BLT LSEOL1		;NO, DONE
	MOV #35,B		;HOME UP
	JSR PC,LSITYO
LSEOL1:	MOV #36,B		;CLEAR EOL
	JSR PC,LSITYO
	CLR LSLNNO		;NO MORE LINES
LSEOL2:	RTS PC


				;UNSPECIAL CONTROL CHARS ROUTINE
LSBON.:	MOV B,C			;SAVE B,
	MOV #'^,B		;TYPE UPARROW,
	JSR PC,LSITYO
	INC LSCHNO		;1 MORE CHAR ON THIS TYPED LINE
	JSR PC,LSEOL		;SEE ABOUT EOL, EOP
	MOV C,B
	ASR B
	BIS #100,B		;DECONTROLIFY CHAR,
	JSR PC,LSITYO		;AND TYPE IT
	INC LSCHNO		;1 MORE CHAR
	BR LSEOL		;SEE ABOUT EOL, EOP AGAIN


				;CTRL A ROUTINE
LSBO.A:	MOV #12,B		;CTRLA A PRINTS AS CR
	JSR PC,LSITYO
	CLR LSCHNO		;NO MORE CHARS ON TYPED LINE
	RTS PC

				;LINEFEED ROUTINE
LSBOHU:
LSBOLF:	CMP LSLNNO,LSLNMX	;ARE WE ON THE LAST LINE?
	BEQ 1$			;IF SO, NOOP
	ASR B			;NORMALIZE THE LF
	JSR PC,LSITYO		;TYPE THE LF
	INC LSLNNO		;1 MORE LINE
1$:	RTS PC


				;CURSOR-UP ROUTINE
LSBOUP:	TST LSLNNO		;ALREADY AT THE TOP?
	BEQ 1$			;IF SO, NOOP
	ASR B			;NORMALIZE THE CHAR
	JSR PC,LSITYO		;TYPE IT
	DEC LSLNNO		;1 LESS LINE
1$:	RTS PC


				;FORMFEED ROUTINE
LSBOFF:	ASR B			;NORMALIZE FF
	JSR PC,LSITYO		;TYPE IT
	CLR LSCHNO		;NO MORE CHARS ON LINE
	CLR LSLNNO		;NO MORE LINES ON PAGE
	RTS PC
				;THESE SPECIAL-CHARACTER ROUTINES ASSUME CONSOLE WHICH IS, OR BEHAVES LIKE, A DATAPOINT.


				;ROUTINE FOR CTRL CHARS WHICH HAVE NO EFFECT OF
				; CURSOR POSITION, BUT WHICH ARE ONLY SPECIAL TO TV-TYPE CONSOLE

LSBOCF:				;CLEAR EOF
LSBOCL:				;CLEAR EOL
LSBOFL:				;FLASH (BELL)
	TST LSTVEE		;TV-TYPE TERMINAL?
	BEQ LSBOX2
LSBOX1:	ASR B			;IF SO,
	JSR PC,LSITYO		; OUTPUT CHAR
	RTS PC
LSBOX2:	BR LSBON.		;IF NOT, TREAT AS NORMAL CTRL CHAR


				;ROUTINE FOR BACKSPACE
LSBOBS:	TST LSTVEE		;TV-TYPE TERMINAL?
	BEQ LSBON.		;IF NOT, TREAT AS NONSPECIAL CONTROL CHAR
	TST LSCHNO		;IF SO, BACKSPACE
	BEQ LSRTS
	DEC LSCHNO
	BR LSBOX1

				;ROUTINE FOR BACKSPACE/ERASE
LSBOBE:	TST LSTVEE
	BEQ LSBON.
	TST LSCHNO
	BEQ LSRTS
	DEC LSCHNO
	ASR B
	JSR PC,LSITYO		;BACKSPACE
	MOV #40,B		;CLEAR EOL
	JSR PC,LSITYO
	MOV #10,B
	JSR PC,LSITYO		;BACKSPACE AGAIN
LSRTS:	RTS PC
				;ROUTINE FOR HOME-DOWN
LSBOHD:	TST LSTVEE		;TV-TYPE TERMINAL?
	BEQ 1$			;IF NOT, TREAT AS NOSPECIAL CONTROL CHAR
	MOV LSLNMX,LSLNNO	;IF SO, CURSOR WILL MOVE TO BOTTOM LINE,
	CLR LSCHNO		;1ST CHAR POSITION
	RTS PC

1$:	BR LSBON.

.ENDC				;END OF TTY STUFF

.SBTTL GENERAL BUFFER STUFF
.IF NZ LSTTY!LSPRNT

;PUT THE CHARACTER IN C INTO THE BUFFER POINTED TO BY A
LSBFPT:	CMP LSBFSZ(A),LSBFCN(A)	;IS THE BUFFER FULL?
	BEQ 2$			;YUP, NO ROOM
	CMP LSBFIP(A),LSBFEN(A)	;TIME TO WRAP?
	BLO 1$			;NOPE
	MOV LSBFBG(A),LSBFIP(A)	;RESET POINTER
1$:	MOVB C,@LSBFIP(A)	;PUT IN THE CHARACTER
	INC LSBFIP(A)		;INC THE POINTER
	INC LSBFCN(A)		;CHARACTER GOING IN
2$:	RTS PC			;RETURN WITH Z CLEAR IF WE WON, SET OTHERWISE

;TAKE A CHARACTER FROM THE BUFFER POINTED TO BY A AND RETURN IT IN C
;SET Z IF THERE ARE NONE AVAILABLE
LSBFGT:	TST LSBFCN(A)		;ANY THERE?
	BEQ 1$			;NOPE, RETURN WITH Z SET
	MOVB @LSBFOP(A),C	;GET A CHARACTER
	BIC #177400,C		;FLUSH SIGN EXTEND
	DEC LSBFCN(A)		;ONE LESS IN BUFFER
	INC LSBFOP(A)		;MOVE UP POINTER
	CMP LSBFOP(A),LSBFEN(A)	;AT THE END?
	BLO 1$			;NO, RETURN WITH Z CLEAR
	MOV LSBFBG(A),LSBFOP(A)	;YES, RESET POINTER
1$:	RTS PC


;RESET THE BUFFER POINTED TO BY A
LSBFRS:	CLR LSBFCN(A)		;ZERO CHARACTERS
	MOV LSBFBG(A),LSBFOP(A)	;RESET OUTPUT POINTER
	MOV LSBFBG(A),LSBFIP(A)	;AND INPUT POINTER
	RTS PC

.ENDC

.IFNZ LSDISK			;DISK STUFF
				;COPY FA CAP
FACPYC:	JSR PC,GETCPS		;SET UP CAP (FIND NEW ONE IF -1 )
	MOV LSCIPN(C),B		;GET ITEM POINTER
	INC MFRFCN(B)		;INC REF COUNT
	MOV B,LSCIPN(F)		;PUT ITEM POINTER INTO NEW CAP
	MOV LSCPTB(C),LSCPTB(F)	;COPY TYPE
	JSR PC,CLRCAP
	CMP (E)+,(E)+
	RTS PC

CLRCAP:	MOV #-1,LSCRN1(F)	;NO CURRENT BLOCK
	CLR LSCRN2(F)		;SET POINTER
	CLR LSCRN3(F)		;TO ZERO
	RTS PC

GETCPS:	MOV 4(E),F		;GET CAP # USER SPECIFIED
	BLT 1$			;IF <0 HE WANTS US TO FIND A FREE ONE
	CMP #LSMAXC,F		;TOO BIG?
	LSERRC LOS,BCN		;ERROR IF TOO HIGH
	ASL F			;MAKE INTO WORD INDEX
	TST LSCPTB(F)		;ALREADY USED?
	LSERRC NE,BCN
	RTS PC
1$:	MOV #<LSMAXC*2>+LSCPTB,F	;POINT PAST END OF TABLE
2$:	TST -(F)		;FREE?
	BEQ 3$			;YUP
	CMP #LSCPTB,F		;AT BOTTOM
	BNE 2$			;NOPE
	LSERR BCN
3$:	SUB #LSCPTB,F
	MOV F,4(E)
	ASR 4(E)
	RTS PC


				;DELETE FILE ACCESS CAP
FADELC:	MOV C,F			;MOVE CAP INDEX INTO THE STANDARD PLACE
FADEL1:	CLR LSCPTB(F)		;ACTUALLY DELETE THE CAP
	MOV LSCIPN(F),D		;GET POINTER TO THE ITEM
	JSR PC,DELFAR		;GO DELETE REFERENCE
	ADD #6,E	
	RTS PC

;DELETE A REFERENCE TO THE MFI IN D
;THIS ROUTINE CLOBBERS A
DELFAR:	DEC MFRFCN(D)		;ONE LESS REFERENCE
	BNE DELFA1		;STILL MORE, THIS ITEM STAYS AROUND
	TST MFDELF(D)		;HAS FILE BEEN DELETED?
	BEQ 1$			;NOPE
	JSR PC,MFIBFL		;DELETE THE BLOCKS
	BR DELFA2		;AVOID INSERTING DELETED ENTRY
1$:	TST MFMODF(D)		;HAS THIS BEEN MODIFIED?
	BEQ DELFA2		;NO MODS, DON'T NEED TO WRITE IT OUT
	JSR PC,MFIINS		;INSERT THE CURRENT THING INTO THE DIR

DELFA2:	SAVE D
	MOV MFDKNO(D),A
	DEC MFDKRF(A)		;ONE LESS REFERENCE
	BGT 3$
	JSR PC,DKUNMT		;NO REFS, FLUSH THIS DISK
3$:	MOV MFBACK(D),D		;POINT UP
	BEQ 4$			;NOBODY ABOVE HERE
	JSR PC,DELFAR		;RECURSIVELY DELETE
4$:	REST D
				;FALLS IN TO DELITM
DELITM:	MOV #MFOPNF,A		;POINTER TO OPEN FILES
1$:	CMP (A),D		;DOES HE POINT AT ME?
	BEQ 2$			;YUP, GOT POINT HIM PAST ME
	MOV (A),A		;NEXT ONE
	BNE 1$
	BPT			;ITEM NOT IN LIST
2$:	MOV (D),(A)		;POINT THE GUY PAST ME
	MOV MFILST,(D)		;I POINT TO ALL FREE ONES
	MOV D,MFILST		;LINK THIS ONE IN
DELFA1:	RTS PC

				;CREATE CAPABILITY. CURRENTLY CAN ONLY CREATE ROOT FA CAPS
CCFACP:	JSR PC,GETCPS		;GET A CAP SLOT TO PUT IT INTO
	MOV @2(E),C		;GET DISK NUMBER
	BIC #177400,C
	TST LSDMNT(C)		;IS DISK ALREADY MOUNTED?
	LSERRC NE,BAD	
	JSR PC,GETITM		;GET A MFI, RETURN INDEX IN D
	MOV D,B			;COPY POINTER
	JSR PC,LSFCIN		;INC REF COUNT, CLEAR CAP
	MOV #46,LSCRN1(F)	;BLOCK 46 IS THE ROOT
	MOV #46,MFBLKN(D)	;NEED THAT HERE TOO
	CLR MFFLNO(D)		;THE SELF ENTRY IS THE ZEROTH
	MOV PC,MFDIRF(D)	;THIS IS DEFINITELY A DIR
	MOV C,MFDKNO(D)		;SET IN DISK NUMBER
	MOV PC,LSDMNT(C)	;MOUNTED NOW
	MOV #1,MFDKRF(C)	;EXACTLY ONE REFERENCE
.IIF Z RXDISK,	MOV #-1,LSDEN(C)	;SET DENSITY TO UNKNOWN
.IIF NZ RXDISK,	MOV #0,LSDEN(C)		;RX DISK IS ALWAYS SINGLE DENSITY
	ASR C			;WAS MULTIPLE OF 2
	BISB LSBMT(C),LSDKLT	;SET INTO LIGHT REGISTER
.IIF NZ SMSDSK,	MOV LSDKLT,SMSLGT	;TURN ON LIGHT
	JSR PC,DSKBGT		;READ IN THE ROOT DIR
	TST TRNERR		;ERROR?
	BNE 1$
	JSR PC,ENTMFC		;COPY ENTRY INTO MFI
	JSR PC,ENTFRS		;SET FREE BYTE COUNT
	MOV #.FACAP,LSCPTB(F)	;NOW IT'S OFFICIAL
	ADD #4,E		;FLUSH EXTRA ARGS
	RTS PC			;AND RETURN
1$:	JSR PC,FADEL1		;DELETE THE CAP
	LSERR DSKE		;DISK ERROR

				;UNMOUNT A MOUNTED DISK
DKUNMT:	JSR PC,LSFLSB		;MAKE DOUBLE SURE
	MOV #-1,BLOKNO		;MAKE SURE NO ONE EVER BELIEVES THE BUFFER AGAIN
	TST MFBITP(A)		;DID IT HAVE A BIT TABLE ASSSINGED?
	BEQ 1$
	JSR PC,WRTBIT
	MOV LSBTBS,@MFBITP(A)	;GOING TO FREE
	MOV MFBITP(A),LSBTBS	;THE BIT TABLE
1$:	CLR LSDMNT(A)
	ASR A
	BICB LSBMT(A),LSDKLT
.IIF NZ SMSDSK,	MOV LSDKLT,SMSLGT
	RTS PC



				;COPY ENTRY POINTED TO BY B INTO MFI POINTED TO BY D
ENTMFC:	SAVE <A,D,B>
	TST (B)			;DOES IT HAVE EOF WORDS?
	BGE 2$			;NOPE
	MOV 4(B),A		;HIGH ORDER PART
	MOV 6(B),B		;LOW ORDER
	ASH #3,B		;MOVE UP
	ASHC #-3,A		;AND BACK
	BIC #160000,A
	MOV A,MFEOFH(D)
	MOV B,MFEOFL(D)	
	MOV (P),B
2$:	MOV (B),A
	INC A
	BIC #177401,A
	ASR A
	ADD #MFENTY,D
1$:	MOV (B)+,(D)+
	SOB A,1$
	REST <B,D,A>
	RTS PC
				;GET THE REAL BLOCK NUMBER FOR THE CURRENT ACCESS POINTER
				;CALL WITH THE CAP POINTER IN F 
LSGETB:	SAVE A
	MOV LSCRN2(F),A		;HIGH BITS
	MOV LSCRN3(F),B		;LOW BITS
	ASHC #-10.,A		;NOW B HAS BLOCK # IN FILE
	MOV LSCIPN(F),A		;ITEM POINTER
	JSR PC,GTBLK
	REST A
	RTS PC

				;GET BLOCK NUMBER FOR FILE BLOCK NUMBER IN B, ITEM POINTER IN A
GTBLK:	JSR F,LSACSV
	ADD #MFENTY,A		;POINTER TO ENTYR IN ITEM
	MOV (A),C		;HEADER WORD
	BIC #177400,C		;CLEAR CRAP
	ADD A,C			;POINT TO END OF ENTRY
	MOV C,ENTRYE		;SAVE THAT
	MOV (A),C		;HEADER AGAIN
	ADD #4,A		;POINT PAST HEADER AND VERSION #
	BIT #MFEOFB,C		;DOES IT HAVE EOF?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP EOF, TIME+DATE
1$:	BIT #MFACCB,C		;ACCESS CODES?
	BEQ 3$			;NOPE
2$:	ADD #2,A
	TSTB (A)+
	BLT 2$
3$:	TSTB (A)+
	BGE 3$
	MOV #-1,E		;E IS THE CURRENT REAL BLOCK #
	MOV #ADDSKP,ENTLST	;IF NO VALID BYTES, SKP IS THE TYPE
GETLOP:	MOV E,ENTLSB
	INC E			;EVERY NEW BYTE ADDS ONE TO E
	CMP A,ENTRYE		;AT THE END?
	BLO 1$			;NOPE
	MOV #-1,E		;JUST RETURN -1
	BR GTGOT
1$:	MOV A,ENTLSP
	MOVB (A)+,C		;NEXT BYTE 
	MOV C,D			;COPY
	BIC #177700,D		;GET DATA PART
	BIC #177477,C		;GET CODE PART
	ASH #-5,C		;CONVERT CODE TO DISPATCH
	JMP @2$(C)		;DISPATCH
2$:	GTSKIP
	GTGET
	GTSET
	GTSKG

GTSKIP:	MOV #ADDSKP,ENTLST
	ADD D,E			;SKIP N AND GRAB ONE
	CLR F			;GRAB ONE
	BR GTGRBN

GTGET:	MOV #ADDGET,ENTLST
	MOV D,F			;GET N
GTGRBN:	DEC B			;GOT ENOUGH?
	BLT GTGOT		;YUP
	DEC F			;ANY MORE TO GET?
	BLT GETLOP		;NOPE
	INC E			;GET NEXT ONE THEN
	BR GTGRBN

GTSET:	MOV #ADDSET,ENTLST
	MOV D,F			;SET ADDRESS AND GET N
	MOVB (A)+,E		;LOW BYTE
	SWAB E			;SAVE IN HIGH BYTE
	BIC #377,E		;FLUSH CRAP
	BISB (A)+,E		;GET HIGH BYTE
	SWAB E			;MAKE THINGS LIKE GOD INTENDED THEM TO BE
	BR GTGRBN		;AND DO A REGULAR GRAB

GTSKG:	MOV #ADDSKG,ENTLST
	MOV D,F			;SKIP AND GRAB, COPY DATA
	ASH #-3,D		;GET SKIP PART
	ADD D,E			;SKIP
	BIC #70,F		;GET GRAB PART
	BR GTGRBN		;AND DO REGULAR GRAB

GTGOT:	MOV E,2(P)		;THE GOODIE TO RETURN
	JSR F,LSACRT
	RTS PC



				;ADD BLOCK NUMBER IN B TO ENTRY OF ITEM IN D
				;ENTLSB,T,P HAVE BEEN SET UP BY LSGETB RUNNING TO END OF DESC
ADDBLK:	JSR F,LSACSV
	CMP #3,MFRSFR(D)	;HAVE WE GOT ENOUGH RESERVED?
	BLE 2$
	MOV #6,C		;RESERVE PLENTY
	JSR PC,DIRCMT
	LSERRC EQ,DRF
2$:	MOV PC,MFMODF(D)	;WE WILL MODIFY ENTRY
	MOV ENTRYE,F		;PLACE TO PLACE NEW BYTE(S)
	MOV ENTLSB,E		;LAST ALLOCATED BLOCK
	INC E			;NORMAL NEXT BLOCK
	SUB B,E			;DIFFERENCE
	NEG E
	BNE ADDNEW		;NOT ZERO=>SPECIAL BYTE
	JMP @ENTLST		;MAYBE CAN ADD TO LAST BYTE

ADDNEW:	JSR PC,ADDBYT		;INC ENTRY AND DEC RESERVED
	CMP #7,E		;SKIP-GET POSSIBLE?
	BHIS ADDNSG		;ADD ONE
	CMP #77,E		;SKIP?
	BHIS ADDNSK		;ADD IT
	MOVB #200,(F)+		;ADD SET ADDRESS
	MOVB B,(F)+
	SWAB B
	MOVB B,(F)+
	JSR PC,ADD2BY		;ADD TWO BYTES
ADDRET:	JSR F,LSACRT
	RTS PC

ADDNSG:	ASH #3,E		;MOVE SKIP FIELD
	BIS #300,E
ADDNSK:	MOVB E,(F)+
	BR ADDRET

ADDSET:	MOV #77,C		;THESE TWO ACT THE SAME (ALMOST)
	BR ADDGT1
ADDGET:	MOV #37,C
ADDGT1:	MOVB @ENTLSP,A		;GET OLD GET COUNT BYTE
	INC A			;ADD ANOTHER TO IT
	BIT C,A			;DID IT OVERFLOW?
	BEQ ADDNGT		;YES, MUST ADD A GET
ADDOLD:	MOVB A,@ENTLSP		;PUT BYTE BACK
	BR ADDRET

ADDSKP:
ADDNGT:	JSR PC,ADDBYT
	MOVB #100,(F)+
	BR ADDRET

ADDSKG:	MOVB @ENTLSP,A
	INC A			;TRY ADDING A BLOCK
	BIT #7,A		;OVERFLOW?
	BEQ ADDNGT		;YUP, ADD A GET
	BR ADDOLD		;NOPE, PUT IT BACK

ADD2BY:	JSR PC,(PC)
ADDBYT:	INC MFENTY(D)		;ONE MORE BYTE INTHE ENTRY
	DEC MFRSFR(D)		;ONE LESS RESERVED
	RTS PC

				;FIND A FREE BLOCK ON THE DISK
FNDBLK:	JSR F,LSACSV
	MOV MFDKNO(D),A
	TST MFFREE(A)		;ANY FREE
	LSERRC EQ,DFL
	DEC MFFREE(A)
	MOV PC,MFBITM(A)	;MODIFIED BIT TABLE
	MOV MFBITP(A),B		;GET POINTER TO BIT TABLE
	TST (B)+		;PASS THE COUNT
	MOV B,C			;COPY
1$:	CMPB #377,(C)+		;ANY FREE HERE?
	BEQ 1$
	DEC C
	CLR E
2$:	BITB LSBMT(E),(C)	;FREE?
	BEQ 3$
	INC E
	BR 2$
3$:	BISB LSBMT(E),(C)
	SUB B,C			;RELATIVE
	ASH #3,C		;EACH BYTE=8 BLOCKS
	ADD E,C
	MOV C,2(P)		;RETURN IN B
	MOV A,D			;SAVE DISK INDEX
	MOV MFBITP(A),A		;GET POINTER TO BIT TABLE
	JSR PC,BITCNT		;COUNT UP THE BITS
	CMP A,MFFREE(D)		;IS THIS RIGHT?
	BEQ 4$
	HALT			;NOPE, SOMEBODY CLOBBERED THE BIT TABLE
4$:	JSR F,LSACRT
	RTS PC



				;FILE BYTE INPUT
LSFBYI:	MOV #1,A		;NUMBER OF BYTES WE WANT
	JSR PC,LSGTBY		;GO GET BYTES
	LSERRC EQ,RPEF,SV	;READ PAST EOF
	MOVB (B),(E)
	CLRB 1(E)
	RTS PC


				;FILE WORD INPUT
LSFWDI:	MOV #1,A
	JSR PC,LSGTBY		;GO GET 1 BYTE
	LSERRC EQ,RPEF,SV
	MOVB (B),(E)
	MOV #1,A
	JSR PC,LSGTBY		;GO GET 1 BYTE
	LSERRC EQ,RPEF,SV
	MOVB (B),1(E)
	RTS PC

				;FILE BLOCK INPUT
LSFBLI:	MOV 2(E),A
	BEQ 1$
	NEG A
	JSR PC,LSGTBY
	LSERRC EQ,RPEF,SV
	ADD A,2(E)
	MOV 4(E),C		;POINTER TO USERS DATA AREA
	ADD A,4(E)		;UPDATE THAT TOO
2$:	MOVB (B)+,(C)+
	SOB A,2$
	BR LSFBLI		;TRY AGAIN
1$:	ADD #6,E
	RTS PC




				;GET BYTES FOR INPUT. CALL WITH NUMBER OF BYTES DESIRED IN A
				;CAP IN F
				;THIS ROUTINE CLOBBERS D TO BE THE ITEM
				;RETURN WITH NUMBER OF BYTES GOTTEN IN A, POINTER TO THEM IN B
LSGTBY:	SAVE A			;SAVE NUMBER OF BYTES HE WANTS
	MOV LSCIPN(F),D		;GET ITEM POINTER
	CMP LSCRN2(F),MFEOFH(D)	;CHECK HIGH WORDS
	LSERRC HI,APEF		;ACCESS PAST END OF FILE
	BLO 8$			;NOT EVEN IN LAST 65K BYTES
	MOV MFEOFL(D),A		;GET THE EOF WORD
	SUB LSCRN3(F),A		;GET NUMBER OF BYTES LEFT ON THIS PAGE
	LSERRC LO,APEF		;ACCESS PAST END OF FILE
	BEQ 9$			;AT END OF FILE
	CMP #2000,A		;MORE THAN A BLOCK?
	BHI 9$			;NOPE, CAN USE WHOLE THING
8$:	MOV #2000,A		;AT LEAST ONE BLOCK BEFORE EOF
9$:	SAVE A			;THSI IS HOW MUCH BEFORE EOF
	MOV LSCRN3(F),A		;NOW WE WNAT HOW MUCH IS LEFT ON BLOCK
	BIC #176000,A
	BNE 2$			;WE ARE NOT ON BLOCK BOUNDARY
	MOV #-1,LSCRN1(F)	;CLOBBER CURRENT BLOCK IF THERE IS ONE
2$:	SUB #2000,A		;COMPUTE HOW MUCH
	NEG A			;IS LEFT IN THIS BLOCK
				;NOW WE WANT TO RETURN MIN(A,(P),2(P))
	CMP A,(P)
	BLT 3$			;A IS LESS
	MOV (P),A
3$:	CMP A,2(P)
	BLT 4$
	MOV 2(P),A
4$:	CMP (P)+,(P)+		;FLUSH EXTRA STUFF
	TST A
	BEQ LSGTB1		;NO BYTES, DON'T TRY TO GET BLOCK
LSGTBL:	JSR PC,DSKBGC		;GET A POINTER IN B TO THE RIGHT BLOCK
	SAVE B
	MOV LSCRN3(F),B
	BIC #176000,B
	ADD (P)+,B
	ADD A,LSCRN3(F)		;ADD NUMBER OF BYTES GOTTEN TO ACCESS POINTER
	ADC LSCRN2(F)		;OVERFLOW TO HIGH WORD
	TST A
LSGTB1:	RTS PC

				;GET ROOM FOR OUTPUT BYTES
				;CALL WITH NUMBER OF BYTES DESIRED IN A, CAP IN F
				;D GETS CLOBBERED TO BE ITEM POINTER, B POINTS TO WHERE TO
				;PUT THE BYTES AND A RETURNS NUMBER OF BYTES ACTUALLY GOTTEN
LSGTBO:	SAVE A			;SAVE NUMBER DESIRED
	JSR PC,LSGTBY		;FIRST SEE IF THERE ARE ANY BEFORE THE EOF	
	BNE LSGTO1		;YUP, USE THEM UP FIRST
				;SINCE WE GOT HERE WE ARE AT THE EOF
	MOV PC,MFMODF(D)	;SO WE WILL BE CHANGING THE EOF
	MOV LSCRN3(F),A		;GET EOF POINTER
	BIC #176000,A		;CLEAR EXTRA BITS
	BEQ LSGTO2		;WE ARE AT BEGGINING OR PAST END OF LAST BLOCK
	SUB #2000,A		;NEGATIVE OF AMOUNT LEFT ON THIS BLOCK
	NEG A			;REAL AMOUNT
LSGTO3:	CMP A,(P)		;IS AMOUNT AVAILABLE MORE THAN WE WANT?
	BLT 1$			;NO, LESS
	MOV (P),A		;GIVE HIM ONLY WHAT HE WANTS
1$:	ADD A,MFEOFL(D)		;WE ARE PUSHING THE EOF BY THIS MUCH
	ADC MFEOFH(D)
	BIT #1777,MFEOFL(D)	;AT THE END OF THE BLOCK
	BNE 2$
	BIC #MFLSTB,MFENTY(D)	;THEN LAST BLOCK NO LONGER EXISTS
2$:	JSR PC,LSGTBL		;GET THE BLOCK WE ARE ON
LSGTO1:	MOV PC,BLOKMD
	TST (P)+
	TST A
	RTS PC

LSGTO2:	BIT #MFLSTB,MFENTY(D)	;IS THE LAST BLOCK ALREADY THERE?
	BEQ 1$			;NOPE
3$:	MOV #2000,A		;YUP, HAVE A WHOLE BLOCK
	BR LSGTO3
1$:	JSR PC,LSGETB		;PROCESS TO LAST BLOCK IN FILE
	CMP #-1,B		;BETTER NOT EXIST
	BEQ 2$
	BPT
2$:	JSR PC,FNDBLK		;FIND A FREE BLOCK
	JSR PC,ADDBLK		;ADD IT TO DESC
	BIS #MFLSTB,MFENTY(D)
	BR 3$












				;FILE BYTE OUTPUT
LSFBYO:	TST (E)+		;FLUSH CAP
	MOV #1,A		;NUMBER OF BYTES WE WANT
	JSR PC,LSGTBO		;GO GET BYTES
	MOVB (E),(B)
	TST (E)+
	RTS PC


				;FILE WORD OUPUT
LSFWDO:	TST (E)+		;FLUSH CAP
	MOV #1,A
	JSR PC,LSGTBO		;GO GET 1 BYTE
	MOVB (E),(B)
	MOV #1,A
	JSR PC,LSGTBO		;GO GET 1 BYTE
	MOVB 1(E),(B)
	TST (E)+
	RTS PC

				;FILE BLOCK OUTPUT
LSFBLO:	MOV 2(E),A
	BEQ 1$
	NEG A
	JSR PC,LSGTBO
	ADD A,2(E)
	MOV 4(E),C		;POINTER TO USERS DATA AREA
	ADD A,4(E)		;UPDATE THAT TOO
2$:	MOVB (C)+,(B)+
	SOB A,2$
	BR LSFBLO		;TRY AGAIN
1$:	ADD #6,E
	RTS PC

				;RETURN A BLOCK OF DATA ABOUT THE FILE THIS IS A CAPABILITY TO
				;C= POINTS TO DESTINATION OF DATA
				;D= NEGATIVE OF THE MAXIMUM NUMBER OF BYTES TO GIVE USER

LSFARI:	MOV C,F			;PUT CAP POINTER INTO USUAL PLACE
	MOV 2(E),D		;BYTE COUNT
	MOV 4(E),C		;USER'S POINTER
	TST D			;IS IT NEGATIVE
	BPL 1$
	NEG D			;MAKE IT POSITIVE
1$:	BNE MFARI9
	MOV #400,D		;GIVE HIM ALL THERE IS
MFARI9:	SUB #5,D		;MINIMUM
	ASL D
	LSERRC LE,BAD
	MOV LSCPTB(F),(C)	;CAP. FLAGS
				;GIVE USER FLAGS
	MOV LSCIPN(F),A		;ITEM POINTER
	CLR B
	TST MFDIRF(A)
	BEQ 2$			;FILE
	MOV #.FADIR,B		;DIR
2$:	BIS B,(C)+
	MOV B,(C)+
	MOV MFEOFL(A),B
	MOV MFEOFH(A),A
	ASHC #-10.,A
	MOV LSCIPN(F),A
	INC B
	BIT #MFLSTB,MFENTY(A)
	BNE 1$
	DEC B
1$:	MOV B,(C)+
	MOV 10(A),(C)+		;DATE
	MOV 12(A),(C)+
	MOV LSCIPN(F),A
	ADD #MFENTY,A
	JSR PC,MFNDNM		;MAKE A POINT TO NAME
MFARI1:	MOVB (A)+,(C)+
	BLT 9$
	SOB D,MFARI1
	BR MFARI6		;NO MORE ROOM, EXIT
9$:	BICB #200,-1(C)

	MOV LSCIPN(F),A		;POINTER TO MFI
	ADD #MFENTY,A
	MOV 2(A),B		;VERSION NUMBER
	BLT 6$			;NONE, DONE
	MOVB #'#,(C)+
	DEC D
	BLE MFARI6
	SAVE #-1
7$:	CLR A
	DIV #10.,A
	SAVE B
	MOV A,B
	BNE 7$
5$:	REST B
	BLT 6$
	ADD #60,B
	MOVB B,(C)+
	SOB D,5$
4$:	TST (P)+
	BGE 4$
	BR MFARI6
6$:	CLRB (C)+
MFARIX:	ADD #6,E
	RTS PC

MFARI6:	BIS #1,LSPS		;SET CARRY BIT
	BR MFARIX

MFNDNM:	SAVE B		;(A)= POINTER TO ENTRY
	MOV (A)+,B		;HEADER WORD
	TST (A)+		;SKIP VERSION NUMBER
	BIT #MFEOFB,B		;TIEM DATE, EOF ETC?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP EOF DATE AND TIME
1$:	BIT #MFACCB,B		;ACCESS CODES?
	BEQ MFND.2
MFND.1:	ADD #2,A		;SKIP ACCESS CODES
	TSTB (A)+
	BLT MFND.1		;MORE ACCESS CODES?
MFND.2:	REST B
	RTS PC			;DONE

LSFASP:	MOV 2(E),LSCRN2(C)
	MOV 4(E),LSCRN3(C)
	MOV #-1,LSCRN1(C)
	ADD #6,E
	RTS PC


LSFARP:	ADD #6,E
	MOV LSCRN3(C),-(E)
	MOV LSCRN2(C),-(E)
	RTS PC

LSFARE:	ADD #6,E
	MOV LSCIPN(C),A
	MOV MFEOFL(A),-(E)
	MOV MFEOFH(A),-(E)
	RTS PC


				;RETURN INFO ABOUT THE DISK A FILE IS ON
LSFADI:	ADD #6,E
	MOV LSCIPN(C),A
	MOV MFDKNO(A),B
	ASR B
	MOV B,-(E)		
	ASL B
	MOV MFFREE(B),-(E)
	RTS PC


				;SEARCH THE DIRECTORY FOR THE FILE POINTED
				;TO BY THE FIXED "FILE NAME BLOCK"
				;F POINTS TO THE CAP TO THE DIR TO SEARCH
				;RETURN IN B A POINTER TO THE "EXACT" MATCH IF ONE WAS FOUND.
				;IF THE FNB HAS NO VERSION NUMBER OR A SPECIFIC VERSION NUMBER,
				;THEN THE DIRECTORY ENTRY MUST HAVE THE SAME FOR AN EXACT MATCH
				;IF THE FNB HAS < FOR A VERSION NUMBER, THE FIRST FILE
				;WITH A VERSION NUMBER IS AN EXACT MATCH. IF THE FNB HAS
				;> AS A VERSION NUMBER, THEN THE LAST FILE WITH THE RIGHT
				;NAME AND A VERSION NUMBER IS AN EXACT MATCH. NOTE THAT
				;> AND < NEVER EXACT MATCH TO A FILE WITH NO VERSION NUMBER,
				;AND A FILE WITH NO VERSION NUMBER NEVER EXACT MATCHES A FILE
				;WITH ONE
				;THE VERSION NUMBER OF THE EXACT MATCH IS RETURNED IN C
				;AND Z IS SET IF NO EXACT MATHC IS FOUND
				;CRETURNS WITH POINTER TO ENTRY IN B, IF FOUND
DIRSER:	JSR F,LSACSV
	CLR 2(P)		;RETURNED B
	MOV #1,FNBFNO		;FIRST FILE (WE SKIP THE SELF ENTRY)
	MOV 12(P),F		;RECOVER F
	MOV LSCIPN(F),A		;GET ITEM POINTER
	TST MFDIRF(A)		;IS IT A DIR?	
	LSERRC EQ,BAD
	JSR PC,CLRCAP
	JSR PC,DSKBGC		;GET POINTER TO THE DIR
	MOV B,A
	MOV 6(A),E		;EOF POINTER
	ADD A,E			;REAL END POINTER NOW
	MOV (A),B		;FIRST WORD OF SELF ENTRY
	INC B			;ROUND OFF BYTE COUNT
	BIC #177401,B		;BYTE COUNT
	ADD B,A			;SKIP SELF
				;AND THEN SKIP THE PARENT ENTRY TOO
DIRSE1:	INC FNBFNO		;NEXT FILE
	MOV (A),B		;GET FIRST WORD OF ENTRY
	INC B			;ROUND OFF BYTE COUNT
	BIC #177401,B		;GET BYTE COUNT
	ADD B,A			;GO TO NEXT ENTRY
	MOV A,(P)		;SAVE FOR CALLER
	CMP A,E			;ARE WE AT OR PAST THE END?
	BHIS DIRSE2		;YUP, RETURN TO CALLER
	JSR PC,NAMCMP		;COMPARE THE FILE NAMES
	BGT DIRSE1		;HAVEN'T GONE FAR ENOUGH YET
	BLT DIRSE2		;WE'VE GONE TOO FAR
	MOV FNBVER,D		;MATCHED FILE NAMES, GET VERSION FROM FNB
	INC D			;WAS IT NO VERSION?
	BGE DIRSE4		;YES, OR POSITIVE VERSION
	CMP #-1,C		;NO VERSION ON THE DIR ENTRY?
	BEQ DIRSE1		;THEN IT CAN'T MATCH < OR >
	MOV A,2(P)		;THIS A REAL MATCH FOR <, AND A POSSIBLE FOR >
	MOV C,4(P)		;SO SAVE IT
	INC D			;WAS IT >?
	BEQ DIRSE1		;SEE IF WE CAN FIND A BIGGER ONE
DIRSE2:	CMP #-2,FNBVER		;IS IT >?
	BNE 1$			;NOPE
	DEC FNBFNO		;CORRECT FILE NUMBER
1$:	JSR F,LSACRT		;RESTORE THE CLOBBERED RESGISTERS
	TST B			;SET Z IF NO EXACT MATCH
	RTS PC
DIRSE4:	DEC D			;COMPENSATE FOR TEST
	CMP D,C			;BOTH HAVE VERSIONS OR NO VERSION
	BGT DIRSE1		;FNB VERSION > FOUND VERSION, KEEP TRYING	
	BLT DIRSE2		;FNB VERSION < FOUND, GIVE UP
	MOV A,2(P)		;EXACT MATCH
	MOV C,4(P)		;PREPARE TO RETURN
	BR DIRSE2
				;COMPARE THE NAME IN A FNB WITH THE NAME IN A DIRECTORY AN DECIDE
				;IF THEY ARE GREATER, EQUAL OR LESS
				;POINTER TO FNB IS IN E, POINTER TO DIR IS IN A
NAMCMP:	SAVE <#0,A,B,E>
	MOV A,B			;COPY DIRECTORY POINTER
	MOV #FNBFN,E		;POINT TO FILE NAME IN FILE NAME BLOCK
	MOV 2(A),C		;GET VERSION NUMBER TO RETURN TO CALLER
	ADD #4,A		;POINT TO POTENTIAL NAME
	BIT #MFEOFB,(B)		;ARE THERE TIEM DATE ETC?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP STUFF
1$:	BIT #MFACCB,(B)		;ACCESS CODES?
	BEQ NAMCM2		;NOPE
NAMCM1:	ADD #3,A		;SKIP ONE SET OF CODES
	TSTB -1(A)		;LAST?
	BLT NAMCM1		;KEEP GOING
NAMCM2:	CMPB (A)+,(E)+		;COMPARE CHARACTERS
	BNE NAMCM3		;NOT EQUAL, GO FINISH UP
	TSTB -1(A)		;DID THEY BOTH END?
	BGE NAMCM2		;NOPE
NAMCM4:	REST <E,B,A>
	TST (P)+		;SET CONDITION CODES
	RTS PC
NAMCM3:	MOVB -(A),A		;GET LAST CHAR FROM DIRECTORY
	MOV A,B			;COPY IT
	MOVB -(E),E		;GET LAST FROM FNB
	BIC #177600,A		;FLUSH CRAP
	BIC #177600,E		;LIKEWISE
	DEC 6(P)		;ASSUME FNB IS LESS
	CMP E,A			;WHICH IS GREATER?
	BLT NAMCM4		;ASSUMED RIGHT	
	BGT NAMCM5		;DIRETORY IS LESS
	TST B			;TEST SIGN EXTENDED DIRECTORY CHARACTER
	BGE NAMCM4		;DIRETORY ENDED FIRST, FNB IS BIGGER
NAMCM5:	MOV #1,6(P)		;DIRECTORY ENTRY IS SMALLER THAN FNB
	BR NAMCM4

LSFAMU:	MOV C,F			;PUT CAP INDEX IN ITS PLACE
LSFAM1:	MOV 2(E),D		;POINTER TO THE NAME STRING
	JSR PC,MFFNG		;GO GOBBLE DOWN THE FILE NAME
	BNE 1$
	ADD #6,E
	RTS PC
1$:	JSR PC,DIRSER		;SEARCH FOR FILE
	LSERRC EQ,FNF		;FILE NOT FOUND
	SAVE B			;SAVE POINTER
	MOV LSCIPN(F),A		;POINTER TO DIR MFI
	MOV #MFOPNF,B		;OPEN FILES
2$:	MOV (B),B		;NEXT!
	BEQ 3$
	CMP FNBFNO,MFFLNO(B)	;SAME FILE NUMBER?
	BNE 2$			;NOPE
	CMP A,MFBACK(B)		;SAME DIR?
	BNE 2$			;NOPE
	DEC MFRFCN(A)		;REFERENCE GOING AWAY WITHOUT NEW ONE TAKING ITS PLACE
	BNE 6$
	BPT
6$:	JSR PC,LSFCIN		;INIT THE CAP
	TST (P)+		;FLUSH SAVED B
4$:	MOV D,2(E)
	BR LSFAM1		;NEXT NAME
3$:	REST B
	SAVE D
	JSR PC,GETITM
	MOV MFDKNO(A),MFDKNO(D)
	MOV FNBFNO,MFFLNO(D)	;PUT IN FILE NUMBER
	JSR PC,ENTMFC
	MOV D,B
	MOV MFDKNO(B),D
	INC MFDKRF(D)
	REST D
	MOV LSCIPN(F),MFBACK(B)	;OLD CAP POINTED AT NEW'S PARENT
	JSR PC,LSFCIN		;INIT CAP
	MOV MFENTY(B),A		;GET HEADER WORD
	BIC #170777,A		;CLKEAR ALL BUT TYPE
	CMP #MFDIRE,A		;IS IT A DIR?
	BNE 4$			;NO, WE ARE DONE THEN
	MOV PC,MFDIRF(B)
	SAVE D
	MOV B,D			;SAVED ITEM POINTER
	JSR PC,DSKBGC		;GET THE BLOCK THEN
	JSR PC,ENTMFC		;COPY THE SELF ENTRY
	JSR PC,ENTFRS		;SET FREE BYTES
	MOV BLOKNO,MFBLKN(D)	;SAVE BLOCK NUMBER OF DIR
	REST D
	BR 4$			;DONE!

ENTFRS:	MOV MFEOFL(D),B		;GET EOF POINTER
	SUB #2000,B		;GET NEG OF BYTES LEFT IN DIR
	NEG B
	MOV B,MFRSFR(D)		;SAVE AS NUMBER OF FREE BYTES
	RTS PC

LSFCIN:	INC MFRFCN(B)		;THIS IS A GOODIE
	MOV B,LSCIPN(F)		;POINT CAP AT IT
	JSR PC,CLRCAP
	RTS PC

				;PROCESS USER NAME STRING INTO THE "FILE NAME BLOCK"
MFFNG:	SAVE <A,B,C>
	MOV #-1,B		;VERSION #
2$:	MOVB (D)+,A		;GET A CHAR
	BEQ 1$			;WE ARE AT END
	CMP #40,A		;SPACE?
	BEQ 2$			;IGNORE LEADING SPACE
	MOV #FNBFN,C
3$:	MOVB A,(C)+
	MOVB (D)+,A		;NEXT CHAR
	BEQ MFFNDN		;DONE
	CMP #' ,A
	BEQ MFFNDN		;LIKEWISE
	CMPB #'#,A
	BEQ MFFNGN		;GET A NUMBER
	CMPB #'>,A
	BEQ MFFNGT		;GREATER THAN
	CMPB #'<,A
	BEQ MFFNLT		;LESS THAN
	CMPB #'",A
	BNE 3$			;JUST PUT IT IN
	MOVB (D)+,A		;GET THE QUOTED CHAR
	BR 3$			;PUT IT INTO STRING AND GET NEXT

1$:	REST <C,B,A>
	SEZ
	RTS PC





MFFNDN:	MOV B,FNBVER
	BISB #200,-(C)		;SET END MARKER
MFFND1:	DEC D			;POINT AT TERMINATOR
	REST <C,B,A>
	CLZ
	RTS PC

MFFNGT:	MOV #-2,B		;SET VERSION
	BR MFFNL1

MFFNLT:	MOV #-3,B
MFFNL1:	TSTB (D)+		;SHOUDL BE TERMINATOR
	BEQ MFFNDN		;IS
	CMPB #' ,-1(D)
	BEQ MFFNDN		;CLOSE ENOGUH
	LSERR BFN

MFFNGN:	CLR B
1$:	MOVB (D)+,A		;NEXT
	BEQ MFFNDN		;DONE
	CMPB #' ,A
	BEQ MFFNDN
	SUB #60,A
	LSERRC LT,BFN
	CMP #9.,A
	LSERRC LT,BFN
	MUL #10.,B
	ADD A,B
	BR 1$

				;SET UP BIT TABLE FOR THE DISK THE BIT TABLE FILE IS ON
LSFAMB:	MOV C,F			;MOVE CAP POINTER TO STANDARD PLACE
	MOV LSCIPN(F),A		;GET ITEM POINTER
	MOV MFDKNO(A),D		;GET DISK NUMBER
	JSR PC,CLRCAP		;SET POINTER TO ZERO
	JSR PC,DSKBGC		;GET BITS BLOCK
				;THE BIT TABLE HAD BETTER BE LESS THAN ONE BLOCK
	MOV B,A			;COPY POINTER TO BLOCK
				;HERE COPY BLOCK INTO INTERNAL BLOCK
	CMP (A),#<LSBTLN-4>*8.	;WILL THERE BE ROOM FOR THE WHOLE THING?
	LSERRC HIS,NIS		;NOPE
	MOV LSBTBS,C		;GET A BIT TABLE
	LSERRC EQ,NIS		;NO SPACE
	MOV (C),LSBTBS		;LINK IT OUT
	MOV C,MFBITP(D)		;SAVE BIT TABLE POINTER FOR DISK
	SAVE F
	MOV (A),F		;NUMBER OF BLOCKS
	ASH #-4,F		;16 BLOCKS PER WORD
	ADD #2,F		;FOR GOOD MEASURE
1$:	MOV (B)+,(C)+	
	SOB F,1$
	REST F
	MOV BLOKNO,MFBITB(D)	;SAVE BLOCK NUMBER OF BIT TABLE
	JSR PC,BITCNT		;COUNT UP THE FREE BLOCKS
	MOV A,MFFREE(D)		;NUMBER OF FREE BLOCKS
	ADD #6,E
	RTS PC

;COUNT NUMBER OF FREE BITS IN BIT TABLE POINTED TO BY A
;RETURN RESULT IN A
;CLOBBERS EVERYTHING BUT E AND D
BITCNT:	SAVE E
	MOV A,E			;COPY THE POINTER
	CLR A			;SAVE THE COUNT HERE
	MOV (E)+,B		;NUMBER OF BLOCKS ON EMPTY DISK
1$:	MOV #16.,C		;NUMBER OF BITS/WORD
	MOV (E)+,F		;GET A WORD OF BITS
2$:	ROR F			;GET A BIT TO TEST
	BCS 4$			;NOT FREE
	INC A
4$:	DEC B			;PAST TOTAL BLOCKS?
	BEQ 3$			;YUP
	SOB C,2$		;DO WHOLE WORD
	BR 1$			;DO NEXT WORD
3$:	REST E
	RTS PC

				;COMMON BEGINNING FOR DELETE AND SUPER DELETE
MFACDL:	MOV C,F			;MOVE CAP POINTER TO USUAL PLACE
	MOV LSCIPN(F),D		;GET POINTER TO ITEM
	TST MFDELF(D)		;ALREADY SORT OF GONE?
	LSERRC NE,FNF		;WELL, NOT IN DIRECTORY ANYWAY
	RTS PC

				;SUPER DELETE, DELETE A DIR EVEN IF IT ISN'T EMPTY
LSFSDL:	JSR PC,MFACDL		;DO COMMON STUFF
	TST MFDIRF(D)		;IS IT A DIR?
	LSERRC EQ,BAD		;SUPER DELETE ISN'T NEEDED, SLAP HIS WRIST
	CMP #1,MFRFCN(D)	;IS THERE A FILE OPEN IN THIS DIR?
	LSERRC NE,CDD		;DANGEROUS TO DELETE IF MORE THAN ONE CAP
	BR MFADL2		;GO DELETE IT, WHATEVER IT IS

				;REGULAR DELETE
LSFADL:	JSR PC,MFACDL		;DO COMMON START
	TST MFDIRF(D)		;IS IT A DIR?	
	BEQ MFADL2		;IF A FILE, DON'T NEED EXTRA CHECKING

				;CHECK THAT DIR IS EMPTY
	JSR PC,CLRCAP
	JSR PC,DSKBGC
	SAVE B
	MOV #2,C		;DO TWICE
MFADL1:	MOV (B),A		;GET HEADER WORD
	INC A			;IN CASE COUNT IS ODD
	BIC #177401,A		;EVEN IT
	ADD A,B
	SOB C,MFADL1
	SUB (P)+,B		;UNRELATIVE IT
	CMP B,MFEOFL(D)
	LSERRC NE,CDD		;CAN'T DELETE DIRECTORY THAT ISN'T EMPTY
				;FALLS THROUGH
				;FALLS IN
MFADL2:	MOV PC,MFDELF(D)	;DELETE BLOCKS OF FILE WHEN LAST CAP FLUSHED
	MOV #-1,F		;ONE LESS FILE IN DIR
	JSR PC,MFIUND		;ADJUST ANY ACTIVE MFIS ABOVE THIS FILE
	JSR PC,MFGTDR		;GET POINTER TO THE DIR
	SAVE B
	MOV MFFLNO(D),C		;FILE NUMBER BEFORE GETTING HACKED
	INC C			;MFIUND DECED US TOO
MFADL3:	MOV (B),A		;GET HEADER WORD OF ENTRY
	INC A			;IN CASE ODD
	BIC #177401,A		;EVEN IT OUT
	ADD A,B			;POINT TO NEXT ENTRY
	SOB C,MFADL3		;TILL WE GET TO THE ONE WE'RE INTERESTED IN
	MOV (B),F		;GET HEADER WORD
	INC F			;IN CASE ODD
	BIC #177401,F		;MAKE EVEN
	MOV B,C
	REST B
	SUB F,6(B)		;ADJUST EOF POINTER IN DIR
	MOV C,A			;COPY POINTER TO ENTRY BEING FLUSHED
	ADD F,C			;POINT TO BEG OF NEXT ENTRY
	ADD 6(B),B		;POINT TO NEW END
MFADL4:	CMP B,A			;ARE WE ABOUT TO COPY PAST THE END?
	BEQ MFADL5		;YUP
	MOV (C)+,(A)+		;COPY NE WORD
	BR MFADL4
MFADL5:	MOV PC,BLOKMD		;INDICATE BLOCK MODIFIED
	MOV MFBACK(D),B		;POINT TO MFI OF PARENT
	SUB F,MFEOFL(B)		;ADJUST EOF
	ADD F,MFRSFR(B)		;AND FREE BYTES
	JSR PC,LSFLSB		;FLUSH BUFFERS
	ADD #6,E
	RTS PC

MFGTDR:	MOV MFBACK(D),B		;POINTER TO PARENT
	MOV MFBLKN(B),A		;THE BLOCK NUMBER
	MOV MFDKNO(B),B		;THE DISK NUMBER
	JSR PC,DSKRD		;READ IT IN
	RTS PC

				;DELETE THE BLOCKS BELONGING TO THE FILE WHOSE MFI IS IN D
MFIBFL:	JSR F,LSACSV
	BIT #MFSHRB,MFENTY(D)	;SHARED BLOCKS?
	BNE MFIBF3
	MOV MFDKNO(D),A		;GET THE RIGHT BIT TABLE
	MOV MFBITP(A),C		;GET AGAIN
	MOV PC,MFBITM(A)	;INDICATE MODIFIED
	SAVE A			;SAVE DISK NUMBER FOR LATER USE
	MOV MFEOFH(D),E		;EOF BYTE POINTER
	MOV MFEOFL(D),F
	ASHC #-10.,E		;MAKE INTO BLOCK COUNT
	INC F			;JUST FOR GOOD MEASURE
MFIBF1:	MOV D,A			;ITEM POINTER
	MOV F,B			;BLOCK NUMBER IN FILE
	JSR PC,GTBLK		;GET REAL BLOCK NUMBER
	CMP #-1,B		;REALLY THER?
	BEQ MFIBF2		;NO, IGNORE THIS ONE
	CMP B,(C)		;BIGGER THAN BIGGEST?
	BLO 1$
	BPT
1$:	MOV B,E			;COPY BLOCK NUMBER
	BIC #177770,E		;GET BIT NUMBER
	ASH #-3,B		;AND BYTE NUMBER
	ADD C,B			;BYTE POINTER
	BICB LSBMT(E),2(B)	;TABLE IS OFFSET BY 2
	MOV (P),B		;DISK NUMBER
	INC MFFREE(B)		;ONE MORE BLOCK FREE
MFIBF2:	DEC F
	BGE MFIBF1
	REST A			;GET DISK NUBMER AGAIN
	JSR PC,WRTBIT		;WRITE OUT THIS DISKS BIT TABLE
MFIBF3:	JSR F,LSACRT
	RTS PC

				;FIX UP ANY MFI'S THAT ARE ABOVE A ENTRY BEING CREATED OR DELETED
				;CALL WITH: NUMBER OF AFFECTED FILE IN C
				;ITEM # OF DIRECTORY MFI IN D
				;AMOUNT TO ADJUST BY IN F (I.E. 1 OR -1)
MFIUND:	JSR F,LSACSV
	MOV MFBACK(D),E		;DIR MFI
	MOV MFFLNO(D),C		;FILE BEING ADDED OR DELETED
	MOV MFOPNF,A
MFINU4:	CMP E,MFBACK(A)		;IS THIS MFI IN THE RIGHT DIR?
	BNE MFINU2		;NOPE
	CMP C,MFFLNO(A)		;SAME OR ABOVE BEING HACKED ENTRY?
	BGT MFINU2		;NO
	ADD 12(P),MFFLNO(A)	;ADJUST THIS ONE
MFINU2:	MOV (A),A		;GET NEXT IN LINE
	BNE MFINU4		;NO MORE
	JSR F,LSACRT
	RTS PC

				;ADD A FILE TO A DIR, AND MUTATE TO THAT FILE
LSFAAD:	MOV C,F			;PUT CAP INDEX IN ITS PLACE
	MOV 2(E),D		;POINTER TO THE NAME STRING
	JSR PC,MFFNG		;GO GOBBLE DOWN THE FILE NAME
	LSERRC EQ,BFN		;NO FILE NAME???
	CMP #-3,FNBVER		;FOO< ?
	LSERRC EQ,BFN		;CAN'T CREATE THAT
	JSR PC,DIRSER		;LOOK FOR FILE IN DIR
	BEQ MFAAD2		;NOT THERE, THAT'S FINE
	CMP #-2,FNBVER		;ARE WE ADDING >?
	LSERRC NE,EAE		;NO, FILE ALREADY EXISTS
	INC C			;NEXT VERSION NUMBER
	INC FNBFNO		;GO TO NEXT SPOT IN DIR
	BR MFAAD3		;ADD THAT ONE
MFAAD2:	MOV FNBVER,C		;SPECIFIED VERSION NUMBER
	CMP #-2,C		;ARE WE ADDING >?
	BNE MFAAD3	
	INC FNBFNO		;GO TO NEXT SPOT
	MOV #1,C		;VERSION NUMBER 1
MFAAD3:	MOV C,FNBVER
	MOV LSCIPN(F),D		;GET ITEM POINTER
	TST MFDELF(D)
	LSERRC NE,BCT		;WELL, SORT OF
	JSR PC,GETITM		;GET AN ITEM FOR THE NEW THING
	INC MFRFCN(D)		;REFERENCED ONCE
	MOV LSCIPN(F),C		;POINTER TO THING ABOUT TO BE A PARENT
	MOV MFDKNO(C),MFDKNO(D)	;SAME DISK NUMBER
	MOV FNBFNO,MFFLNO(D)	;AND FILE NUMBER
	MOV C,MFBACK(D)		;THIS WHILE BE THE PARENT
	MOV PC,MFADDF(D)	;THIS IS A NEW FILE
	MOV MFDKNO(D),C		;DISK NUMBER
	INC MFDKRF(C)		;ONE MORE REFERENCE
	MOV D,C
	ADD #MFENTY+14,C	;GET POINTER TO PLACE FOR ENTRY NAME
	MOV #FNBFN,A		;POINTER TO FILE NAME
1$:	MOVB (A)+,(C)+
	BGE 1$			;COPY NAME
	SUB #2,C		;BACK OFF
	MOV D,A			;POINTER TO ITEM AGAIN
	MOV C,MFENDP(A)
	SUB D,C
	SUB #MFENTY-2,C		;NOW THE LENGTH
	JSR PC,DIRCMT		;COMMIT THAT MANY BYTES INTHE DIRECTORY
	BEQ 2$			;COULDN'T GET BYTES, BACK OFF
	BIS #MFFILE!MFEOFB,C
	ADD #MFENTY,A		;POINT TO ENTRY
	MOV C,(A)+		;HEADER WORD
	MOV FNBVER,(A)+		;VERSION NUMBER
	CLR (A)+		;EOF POINTER
	CLR (A)+
	JSR PC,CMDATE		;GO COMPUTE DATE AND TIME
	MOV FDATE,(A)+		;DATE
	MOV FTIME,(A)+		;TIME
	SAVE F
	MOV #1,F		;ADDING A FILE
	JSR PC,MFIUND		;ADJUST OTHER FILES IN THE DIR
	DEC MFFLNO(D)		;DON'T WANT JUST ADDED ENTRY ADJUSTED
	JSR PC,MFIINS		;PUT IT INTO DIR
	REST F
	MOV D,LSCIPN(F)		;MUTATE CAP
	JSR PC,CLRCAP
	ADD #6,E
	RTS PC

				;COME HERE TO FLUSH ITEM, NOT ENOUGH ROOM IN DIR
2$:	JSR PC,DELITM
	LSERR DRF

;COMPUTE THE DATE AND TIME WORDS FOR A FILE
CMDATE:	JSR F,LSACSV
	MOV #LSYEAR,C	;POINTER TO UPDATED DATE+TIME
	TST (C)+	;HAS YEAR BEEN SET?
	BLT CMDAT2	;NO, LEAVE FILE DATES -1
	MOV #TSHIFT,D	;TABLE OF SHIFT COUNTS
	MOV #5,E	;NUMBER OF PARTS
	CLR B		;CLEAR LOW ORDER PATE OF 2 WORDS
	MTPS #340
CMDAT1:	BIS -(C),B	;SET THIS PART IN
	ASHC (D)+,A	;SHIFT UP
	SOB E,CMDAT1	
	MOV -(C),E	;SECONDS
	ASR E
	BIS E,B		;SECONDS GET DIVIDED BY 2
	MTPS #0
	MOV A,FDATE	;THE DATE
	MOV B,FTIME	;AND TIME
CMDAT2:	JSR F,LSACRT
	RTS PC
				;COMMIT SPACE IN A DIR
DIRCMT:	SAVE <A,C>
	MOV MFBACK(D),A
	INC C			;ALWAYS ALLOCATE
	BIC #1,C		;AN EVEN NUMBER OF BYTES
	CMP C,MFRSFR(A)		;DO THAT MANY UNCOMMITED FREE BYTES EXIST?
	BHIS 1$			;LOST
	SUB C,MFRSFR(A)		;COMMIT THAT MANY
	ADD C,MFRSFR(D)		;WE HAVE THAT MANY COMMITTED NOW
	REST <C,A>
	CLZ
	RTS PC
1$:	REST <C,A>
	SEZ
	RTS PC

				;INSERT MFI IN D INTO ITS DIRECTORY
MFIINS:	JSR F,LSACSV
	JSR PC,MFGTDR		;GET THE DIR
	MOV PC,BLOKMD		;WE WILL MODIFY IT
	TST MFDIRF(D)		;IF IT'S A DIR WE ARE DOING A FAMD
	BNE 9$			;DON'T PUT IN EOF WORDS
	MOV MFEOFL(D),F		;GET LOW PART OF EOF
	MOV F,A
	MOV MFEOFH(D),E		;HIGH BITS
	ASHC #3,E		;GOBBLE HIGH BITS
	MOV E,MFENTY+4(D)	;PUT HIGH BITS INTO ENTRY
	BIC #160000,A
	MOV A,MFENTY+6(D)	;PUT IN LOW BITS
9$:	MOV MFBACK(D),F		;POINTER TO ITEM FOR DIR
	MOV B,C			;COPY DIR POINTER
	MOV MFFLNO(D),A		;GET FILE NUMBER
1$:	MOV (C),E		;HEADER WORD
	INC E
	BIC #177401,E
	ADD E,C
	SOB A,1$
	MOV (C),E		;HEADER OF THE OLD ENTRY
	INC E
	BIC #177401,E		;OLD BYTE COUNT
	TST MFADDF(D)		;BEING ADDED?
	BEQ 2$			;NOPE, OLD ENTRY
	CLR E			;OLD ENTYR HAD ZERO BYTES
2$:	CLR MFADDF(D)
	SAVE D			;SAVE FOR LATER
	ADD #MFENTY,D		;POINT AT ENTRY
	MOV (D),A		;HEADER WORD
	INC A
	BIC #177401,A		;NEW BYTE COUNT
	SAVE <C,A>
	SUB A,E			;GET DIFF OLD-NEW	
				;IF ZERO THEY ARE THE SAME LENGTH
				;IF POSITIVE, NEW IS SHORTER
				;IF NEGATIVE NEW IS LONGER
	ADD MFRSFR-MFENTY(D),MFRSFR(F)	;FREE ALL COMMITTED BYTES
	CLR MFRSFR-MFENTY(D)
	ADD E,MFRSFR(F)		;AND GRAB THOSE ACTUALLY USED
	SUB E,6(B)		;ADJUST DIR EOF
	SUB E,MFEOFL(F)		;ADJUST EOF POINTER IN PARENT
	TST E			;CHECK SIGN OF DIFF
	BLT MFIIN2		;NEW ONE IS BIGGER THAN OLD
	BEQ MFIIN3		;NEW ONE IS SAME SIZE AS OL
				;FALL THROUGH IF NEW IS SMALLER THAN OLD

	ADD A,C
	ADD C,E
	ADD MFEOFL(F),B		;POINT TO NEW EOF
MFIIN4:	CMP B,C			;AT NEW EOF?
	BEQ MFIIN3		;YUP
	MOV (E)+,(C)+
	BR MFIIN4

MFIIN2:	ADD MFEOFL(F),B		;GET NEW EOF
	SUB B,E			;NEGATIVE OF NEW END-DIFFER
	NEG E
MFIIN5:	CMP B,C			;AT END?
	BEQ MFIIN3		;YUP
	MOV -(B),-(E)		;COPY A WORD
	BR MFIIN5

MFIIN3:	REST <B,C,E>		;B=BYTE COUNT, C=DIR POINTER, E=MFI POINTER
	MOV E,A			;COPY MFI POINTER
	ADD #MFENTY,E		;POINT AT ENTRY IN MFI
1$:	MOVB (E)+,(C)+		;COPY NEW ENTRY INTO DIR
	SOB B,1$
	JSR PC,LSFLDR		;WRITE OUT CHANGED BLOCK
	MOV MFDKNO(A),A		;GET DISK NUMBER
	JSR PC,WRTBIT		;WRITE OUT CHANGED BIT TABLE (IF CHANGED)
	JSR F,LSACRT
	RTS PC




				;CHANGE A FILE INTO A DIRECTORY
LSFAMD:	MOV C,F			;MOVE CAP TO USUAL PLACE
	MOV LSCIPN(F),D		;AND ITEM POINTER
	TST MFDIRF(D)		;IS IT ALREADY A DIR?
	LSERRC NE,BAD		;YES!
	TST MFEOFH(D)		;IS IT > 8 BLOCKS?
	LSERRC NE,BAD		;YES, THAT'S A NO-NO
	CMP #2000,MFEOFL(D)	;IS IT > 1 BLOCK?
	LSERRC LT,BAD		;SO IS THAT
	TST MFEOFL(D)		;BUT IS THERE SOMETHING THERE?
	LSERRC EQ,BAD		;NOPE!
	JSR PC,CLRCAP
	JSR PC,DSKBGC		;GET DESIRED BLOCK
	SAVE <D,MFBACK(D),F,#0>
	MOV BLOKNO,MFBLKN(D)	;SAVE BLOCK NUMBER OF DIR
	MOV #MFSLFE,F		;FOR THE SELF ENTRY
	JSR PC,MFAMDC		;COPY ENTRY INTO DIR
	MOV 4(P),D		;POINTER TO PARENT
	MOV B,4(P)		;SAVE POINTER INTO DIR
	MOV #MFPARE,F		;PARENT ENTRY
	JSR PC,MFAMDC		;COPY PARENT INTO DIR	
	MOV 4(P),B		;GET BACK POINTER TO WHAT WILL BECOME PARENT ENTRY
	BIC #100000,(B)		;FLUSH THE EOF BIT
	SUB #10,(B)		;FLUSH THE BYTES WE WILL FLUSH
	MOV (B)+,C		;THE HEADER WORD
	INC C
	BIC #177401,C		;SAVE JUST COUNT
	ASR C			;WORD COUNT
	SUB #2,C		;HEADER+VERSION NUMBER
	SUB #10,(P)		;ON THE STACK TOO
	TST (B)+		;PAST VERSION NUMBER
1$:	MOV 10(B),(B)+
	SOB C,1$
	SUB (P),B		;GULP, DOES THIS WORK?
	CLR 4(B)		;NUMBER OF REAL PAGES
	MOV (P),6(B)		;NUMBER OF USED BYTES
	MOV 2(P),F		;RECOVER CAP POINTER
	MOV LSCIPN(F),A		;ITEM POINTER
	ADD #MFENTY,A		;POINT TO ENTYR IN MFI
	MOV (A),B		;GET HEADER WORD
	INC B
	BIC #177401,B		;GET A BYTE COUNT
	ASR B			;WORD
	SUB #6,B		;LESS EOF+TIEM+DATE+HEADER+VERN
	SAVE <A,B>
	BIC #117000,(A)		;FLUSH TYPE AND EOF BIT
	BIS #MFDIRE,(A)		;IT IS A DIR
	SUB #10,(A)+		;FLUSH 8. BYTES
	TST (A)+		;DON'T TOUCH VERN

MFAMD3:	MOV 10(A),(A)+	
	SOB B,MFAMD3
	MOV LSCIPN(F),D		;GET ITEM POINTER AGAIN
	MOV PC,MFDIRF(D)
	JSR PC,MFIINS		;INSERT THIS INTO THE PARENT
	CLR MFMODF(D)		;DON'T WANT IT INSERTED AGAIN
	REST <B,A>
	ADD #10,(A)
	BIS #100000,(A)+
	TST (A)+		;SKIP VERN
	ADD B,A
	ADD B,A			;GET TO THE END OF THE GOOD STUFF
MFAMD2:	MOV -(A),10(A)		;COPY UP
	SOB B,MFAMD2
	REST <B,F,,D>
	CLR MFEOFH(D)
	MOV B,MFEOFL(D)
	MOV PC,MFDIRF(D)	;SAY THIS IS A DIR
	NEG B
	ADD #2000,B		;GET NUMBER OF FREE BYTES
	MOV B,MFRSFR(D)		;THAT MANY FREE BYTES IN DIR
	JSR PC,LSFLDR
	ADD #6,E
	RTS PC

MFAMDC:	ADD #MFENTY,D		;POINT TO ENTRY ITSELF
	MOV (D),C		;GET HEARER WORD
	INC C			;ROUND UP
	BIC #177401,C		;CLEAR CRAP
	ADD C,2(P)		;SAVE LENGTH IN BYTES
	ASR C			;FOR THE SOB
	MOV (D)+,(B)		;COPY THIS INTO DIR
	BIC #17000,(B)		;CLEAR OLD TYPE
	BIS F,(B)+		;CHANGE TO A SELF ENTRY
	DEC C
MFAMD1:	MOV (D)+,(B)+		;A WORD AT A TIME
	SOB C,MFAMD1
	RTS PC
SMSBRK:	RTT		;NO INTERUPTS YET

WRTBIT:	TST MFBITM(A)		;MODIFIED?
	BEQ 1$
	CLR MFBITM(A)
	SAVE <B,BLOKNO,WCHDSK>
	MOV MFBITP(A),B
	MOV MFBITB(A),BLOKNO
	MOV A,WCHDSK
	JSR PC,DSKWRT
	REST <WCHDSK,BLOKNO,B>
	JSR PC,LSERBD		;IF ERROR, VERY BAD
1$:	RTS PC

DSKBGC:	JSR PC,DSKBGT		;READ BLOCK
	TST TRNERR
	LSERRC NE,DSKE
	RTS PC

LSFLDR:	JSR PC,LSFLSB
LSERBD:	TST TRNERR
	LSERRC NE,DVBE		;VERY BAD DISK ERRROR
	RTS PC

LSFLSB:	TST BLOKMD		;MODIFIED?
	BEQ 1$
	CLR BLOKMD
	SAVE B
.IF NDF LSNDB
	MOV #LSDBUF,B		;IF WE ALLOCATE
.IFF
	JSR PC,LSGDBA		;IF SOMEONE ELSE DOES
.ENDC
	JSR PC,DSKWRT
	REST B
1$:	RTS PC

DSKRED:	MOV #DISKRD,DISKIO
	BR DSKBLK

DSKWRT:	MOV #DISKWR,DISKIO
	BR DSKBLK


.IF NZ RKDSK
RKCS=177404
RKWC=177406
RKCA=177410
RKDA=177412

DSKBLK:	JSR F,LSACSV
.IF NZ METERS
	MOV #MTDISK,METERP
	TST MTFLAG
	BNE 1$
	INC MTDSKC		;ONE MORE BLOCK XFERED
1$:
.ENDC
	CLR TRNERR		;NO ERROR
	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
2$:	MOV TRNSLE,RKWC
	MOV B,RKCA
	MOV BLOKNO,D
	CLR C
	ASL D
	DIV #12.,C
	ASH #4,C		;MUL QUOTIENT BY 16
	BIS C,D
	MOV WCHDSK,C
	ASH #12.,C
	BIS C,D
	MOV D,RKDA
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ 3$			;YUP
	MOV #5,RKCS		;READ
	BR 4$
3$:	MOV #3,RKCS
4$:	TSTB RKCS
	BGE 4$
	TST RKCS
	BGT 5$			;NO ERROR, DONE
	MOV #1,RKCS		;RESET CONTROLLER
6$:	TSTB RKCS
	BGE 6$
	BIT #3,RETRYS
	BNE 7$
	MOV #15,RKCS		;RESET DRIVE
7$:	TSTB RKCS
	BGE 7$
	DEC RETRYS
	BGT 2$
	INC TRNERR
5$:
.IIF NZ METERS,	MOV #MTLSIT,METERP
	JSR F,LSACRT
	RTS PC

.ENDC
.IF NZ SMSDSK!RXDISK
				;DISK ROUTINES FOR THE FLOPPY DISK
DSKBLK:	JSR F,LSACSV
.IF NZ METERS
	MOV #MTDISK,METERP
	TST MTFLAG
	BNE 1$
	INC MTDSKC		;ONE MORE BLOCK XFERED
1$:
.ENDC
.IIF Z RXDISK,	JSR PC,DISKON		;MAKE SURE DISK IS ON
	CLR TRNERR
	MOV TRNSLE,FLOPWC
	MOV BLOKNO,F		;THE BLOCK NUMBER
	MOV WCHDSK,A
	CLR E
	TST LSDEN(A)		;SINGLE OR DOUBLE?
	BNE 2$			;DOUBLE
	ASHC #3,E		;8 SECTORS/BLOCK
	DIV #26.,E		;26 SECTORS/TRACK
	MOV #128.,SECSIZ
	MOV #27.,SECLIM
	BR 3$
2$:	ASHC #1,E		;2 SECTORS/BLOCK
	DIV #16.,E		;16 SECTORS/TRACK
	MOV #512.,SECSIZ
	MOV #17.,SECLIM
3$:	INC E
	MOV E,FLOPTR		;TRACK
	INC F			;SECTORS ARE NUMBERED FUNNY
	MOV F,FLOPSC		;SECTOR
DSKBLS:	MOV B,FLOPCA		;SAVE STARTING CORE ADDRESS
.IFZ RXDISK
	MOV #SMSCSR,F		;THE CONTROL REGISTER
	MOV #SMSDBF,E		;THE DATA BUFFER
.ENDC ;Z RXDISK
	MOV WCHDSK,A
.IIF Z RXDISK,	JSR PC,FLPSE1		;FORCE AN INITIAL SEEK

DSKBL1:	TST FLOPWC		;ANY WORDS LEFT TO XFER?
	BNE 1$			;YUP
.IIF NZ METERS,	MOV #MTLSIT,METERP
	JSR F,LSACRT
	RTS PC
1$:


	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
DSKBL2:
.IFZ RXDISK
	JSR PC,FLPSEK
	BEQ FLPERR
.ENDC ;Z RXDISK
	JSR PC,SECMUN
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ FLOPWR
.IFZ 105			;WRITE CHECK NOT USED
	CMP #DISKWC,DISKIO	;WRITE CHECK?
	BEQ FLOPCM
.ENDC
	CMP #DISKRD,DISKIO	;READ?
	BEQ FLOPRD
2$:	BPT
	BR 2$

FLOPWR:
.IFZ RXDISK
	MOV #SMSWRT!SMSHTB,A	;TRANSFER BLOCK TO BUFFER
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
1$:	MOVB (A)+,(E)
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	MOV #SMSWRT!SMSBTD,A	;TRANFER BUFFER TO THE DISK
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	BR FLPSEC		;DONE WITH THIS SECTOR	
.IFF
	MOV #RXFLBF,RXCSR	;GIVE FILL BUFFER CMND
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #RXTR,RXCSR		;WAIT FOR XFER RQST
	BEQ 2$
	MOVB (A)+,RXDBR
	SOB B,2$
3$:	BIT #RXDONE,RXCSR	;WAIT UNTIL DONE
	BEQ 3$
	MOV #RXWRTS,A		;WRITE SECTOR COMMAND
	JSR PC,RXRDWR		;COMMON READ-WRITE HANDSHAKE CODE
	BR FLPSEC		;DONE WITH THIS SECTOR	

RXRDWR:	JSR PC,RXCMND		;INSERT DRIVE SELECT BIT AND ISSUE COMMAND
4$:	BIT #RXTR,RXCSR
	BEQ 4$
	MOV FLOPSS,RXDBR	;FIRST GIVE IT SECTOR ADDR
5$:	BIT #RXTR,RXCSR
	BEQ 5$
	MOV FLOPTR,RXDBR	;THEN GIVE IT THE TRACK ADDR
6$:	BIT #RXDONE,RXCSR	;WAIT TIL DONE
	BEQ 6$
	BIT #RXERR,RXCSR	;DID IT WORK?
	BNE FLPERR		;NOPE
	RTS PC

RXCMND:	TST WCHDSK		;WHICH DISK ARE WE USING
	BEQ 1$			;JUMP IF DISK 0, COMMAND ALL SET
	BIS #RXDSK1,A		;DISK 1, SET THE BIT
1$:	BIT #RXDONE,RXCSR
	BEQ 1$			;WAIT UNTIL DISK IS READY
	MOV A,RXCSR		;ISSUE THE COMMAND
	RTS PC

.ENDC ;RXDISK

FLPERR:	JMP FLPERX

FLOPRD:
.IFZ RXDISK
	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
1$:	MOVB (E),(A)+
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC		;DONE WITH THIS SECTOR	
.IFF
	MOV #RXREDS,A		;READ SECTOR COMMAND
	JSR PC,RXRDWR		;COMMON CODE WITH WRITE
	MOV #RXMTBF,RXCSR	;NOW GIVE EMPTY BUFFER CMD
	MOV FLOPCA,A		;BUFFER ADDR
	MOV SECSIZ,B		;SECTOR SIZE
1$:	BIT #RXTR,RXCSR		;WAIT FOR XFER REQ
	BEQ 1$
	MOVB RXDBR,(A)+		;THE ACTUAL MOVE
	SOB B,1$
	BR FLPSEC		;CAN'T FAIL AT THIS POINT (IT SEZ HERE)
.ENDC ;RXDISK

.IFZ 105			;WRITE CHECK NOT USED
FLOPCM:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
1$:	CMPB (E),(A)+
	BNE FLPERC
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC
.ENDC
.IFZ RXDISK
FLPERC:	DEC B			;ONE LESS BYTE
	BEQ 2$			;ERROR ON LAST BYTE
1$:	MOV (E),A		;TO EMPRY BUFFER
	SOB B,1$
2$:	JSR PC,GETST
	BR FLPERR		;NOW DO THE ERROR
.ENDC ;Z RXDISK

FLPSEC:	MOV SECSIZ,A
	ADD A,FLOPCA
	ASR A
	ADD A,FLOPWC		;TRANSFERED 64. WORDS
	BEQ 1$			;DONE TRANSFER
	INC FLOPSC		;OR ONE SECTOR
	CMP SECLIM,FLOPSC		;OVER TRACK BOUNDARY?
	BGT 1$
	MOV #1,FLOPSC		;TO START ON NEXT TRACK
	INC FLOPTR
1$:	JMP DSKBL1		;GO CONTINUE THE TRANSFER


SECMUN:	SAVE <A,B>
	MOV WCHDSK,A
	TST LSDEN(A)		;DOUBLE OR SINGLE?
	BNE 1$			;DOUBLE
	MOV FLOPTR,B		;NEW IS HARDER
	DEC B
	MUL #3,B		;SECTORS ARE OFFSET BY 6 FOR EACH TRACK
	CLR A
	ADD FLOPSC,B
	DEC B
	DIV #13.,A
	ASL B
	INC B
	CMP #13.,FLOPSC
	ADC B
	BR 2$
1$:	MOVB FLOPSC,B
	MOVB DBLSCM(B),B	
2$:	MOV B,FLOPSS
	REST <B,A>
	RTS PC




.IF Z RXDISK
FLPSEK:	MOV WCHDSK,A
	CMP FLOPTR,FLOPRT(A)	;ON THE TRACK?
	BEQ FLPSE2
FLPSE1:	TST FLOPRT(A)		;IS THIS DRIVE INITED?
	BGE 2$			;YES
	SAVE <A,FLOPTR>
	CLR FLOPTR
	JSR PC,2$
	REST <FLOPTR,A>
2$:	MOV FLOPTR,FLOPRT(A)
	TST FLOPRT(A)
	MOV #SMSSEK,A		;REENTER HERE ON ERROR
	JSR PC,DCMD
	MOV FLOPTR,A
	JSR PC,CMD2		;SEEK TO TRACK	
	JSR PC,GETST		;GET STATUS OF THE SEEK
	RTS PC
FLPSE2:	CLZ
	RTS PC
.ENDC ;Z RXDISK 

FLPERX:	DEC RETRYS		;TIME TO GIVE UP?
	BGE 1$
2$:	INC TRNERR		;SAY THERE WAS AN ERROR ON THIS XFER
	BR FLPSEC		;AND CONTINUE
1$:
.IFZ RXDISK
	MOV FERRST,A
	ASL A
	JMP @.+4(A)
	DSKBL2			;STRANGE, ERROR DISAPPEARED???
	BADER			;COMMAND ERROR IS BAD
	DRERR			;DRIVE ERROR
	OPRERR			;OPERATION ERROR

DRERR:
BADER:	INC TRNERR		;GIVE UP
	BR FLPSEC

OPRERR:	BIT #SMSHPE,ERRDAT	;SEEK ERROR?
	BEQ OPRER1		;NOPE
RECAL:	MOV WCHDSK,A
	MOV #-1,FLOPRT(A)
OPRER1:	JMP DSKBL2		;TRY AGAIN
.IFF
	JMP DSKBL2		;FOR RXDISK, ALWAYS TRY AGAIN
.ENDC ;RXDISK

.IFZ RXDISK
				;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

				;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A		;GET STATUS
	JSR PC,DCMD		;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2		;SECOND BYTE IGNORED
	JMP GETST		;GET THE STATUS
				;IF WE GET BACK WITHOUT ERROR IT WILL BE DISK STATUS

				;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A
	MOV WCHDSK,A
	ASH #2,A		;DISK # ALREADY SHIFTED BY 1
	BIS (P)+,A
	MOV A,SMSCMD		;GIVE COMMAND
	RTS PC

				;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	BIT #SMSCMW,(F)		;WAITING?
	BEQ CMD2		;NOT YET
	MOV A,SMSCMD	
	RTS PC

GETST:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BEQ GETST
	BIT #SMSERR,(F)		;ERROR?
	BNE 3$			;YUP
4$:	MOV SMSDBF,A		;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL		;GOBBLE ERROR STATUS
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,FERRST
	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC


DISKON:	MTPS #340		;TO PREVENT CLOCK FROM TURNING IT OFF AS WE TURN IT ON
	TST LSDKOF
	BNE 3$
	MOV #30.*60.,LSDKOF
	MTPS #0
	SAVE <A,B,F>
	BIS #SMSRSB!SMSPWR,SMSCSR	;RESET CONTROLLER AND POWER DRIVES ON
	CLR A			;FOR TIMER
	MOV #30.,B		;ALSO
1$:	BIT #SMSFDO,SMSCSR	;IS IT RESET YET?
	BEQ 2$
	SOB A,1$		;WAIT
	SOB B,1$		;A LONG TIME

2$:	MOV #10000.,B
	MOV #SMSCSR,F
4$:	MOV #SMSSTS,A
	JSR PC,DCMD
	JSR PC,CMD2
	JSR PC,GETST
	BIT #SMSDNR,A		;READY?
	BEQ 5$
	SOB B,4$

5$:	MOV #LSMXDK,A
	MOV #FLOPRT,B
6$:	MOV #-1,(B)+
	SOB A,6$
	REST <F,B,A>
3$:	MOV #30.*60.,LSDKOF	;TIME FOR DISK TO STAY ON
	MTPS #0
	JSR PC,SETDEN		;GET THE DENSITY RIGHT
	RTS PC

DSKOFF:	CLR LSDKOF
	BIS #SMSRSB,SMSCSR
	BIC #SMSPWR,SMSCSR
1$:	RTS PC

SETDEN:	SAVE <A,F>
	MOV #SMSCSR,F	
	MOV WCHDSK,A		;DISK WE WANT TO HACK
	TST SMSSNG		;IS IT A DOUBLE DENSITY CONTROLLER?
	BNE SETSNG		;NO, JUST SET TO SINGLE
	TST LSDEN(A)		;DO WE KNOW THE DENSITY?
	BGE SETDE1		;YUP
	CLR LSDEN(A)		;TRY SINGLE DENSITY
	JSR PC,GETDE1
	BNE SETDE2		;OK, SINGLE DENSITY
	MOV WCHDSK,A
	MOV #SMSDBL!SMS512,LSDEN(A)	;TRY DOUBLE
	JSR PC,GETDE1
SETDE2:	REST <F,A>
	RTS PC

SETDE1:	JSR PC,SETDNH		;SET THE HARDWARE DENSITY
	BR SETDE2

SETSNG:	CLR LSDEN(A)		;SET TO SINGLE
	BR SETDE2

GETDE1:	JSR PC,SETDNH
	MOV #SMSRID,A		;TRY TO READ THE ID
	JSR PC,DCMD
	JSR PC,CMD2
1$:	BIT #SMSXFW,SMSCSR
	BEQ 1$
	TST SMSCSR		;ERROR?
	BLT 2$			;YES, TRY FOR DOUBLE DENSITY
3$:	JSR PC,GETBYT
	JSR PC,GETBYT
	MOV #30.,A
4$:	BIT #SMSXFW,SMSCSR	;READY TO XFR?
	BNE 5$			;YUP
	SOB A,4$		;WAIT
	MOV #1,SMSSNG		;WE HAVE A SINGLE DENSITY CONTROLLER
	BR 6$
5$:	JSR PC,GETBYT
6$:	CLZ
	RTS PC
2$:	JSR PC,GETBYT		;GET THE ERROR BYTE
	SEZ
	RTS PC

GETBYT:	BIT #SMSXFW,SMSCSR
	BEQ GETBYT
	MOV SMSDBF,A
	RTS PC

SETDNH:	MOV #SMSRST!SMSINI,A
	JSR PC,DCMD
	MOV WCHDSK,A
	MOV LSDEN(A),A
	JSR PC,CMD2
1$:	BIT #SMSFDO,SMSCSR
	BNE 1$
	RTS PC
.ENDC ;Z RXDISK
.IFNZ RXDISK
.INSRT MARG;RXDUMP >
.ENDC ;RXDISK
.ENDC ;SMSDSK

GETITM:	MOV MFILST,D
	LSERRC EQ,NIS
	MOV (D),MFILST
	SAVE <A,D>
	MOV #MFILEN/2,A
1$:	CLR (D)+
	SOB A,1$
	REST <D,A>	
	MOV MFOPNF,(D)		;POINT ME AT OLD OPEN FILE LIST
	MOV D,MFOPNF		;I AM NOW AT HEAD OF LIST
	RTS PC



				;RETURN IN A B POINTER TO THE BLOCK THAT THE CAP IN F
				;IS "INTERESTED" IN. IF THE "CURRENT BLOCK" (LSCRN1)
				;IS NON-NEGATIVE THEN IT IS DEFINED TO BE THE INTERESTING
				;BLOCK. OTHERWISE THE BLOCK MUST BE COMPUTED FROM
				;THE ACCESS POINTER AND DESCRIPTOR
DSKBGT:	JSR F,LSACSV
	MOV 12(P),F		;RECOVER F CLOBBERED BY ACSAV
DSKBG2:	MOV LSCRN1(F),A		;READY TO GO?
	BLT DSKBG1		;NOPE, GO FOOL AROUND
	MOV LSCIPN(F),E		;GET POINTER TO ITEM
	MOV MFDKNO(E),B		;GET DISK NUMBER
	JSR PC,DSKRD		;"READ" THE BLOCK, RETURNING POINTER TO IT IN B
	MOV B,2(P)
	JSR F,LSACRT
	RTS PC

				;GIVEN BLOCK # IN A, DISK # IN B RETURN IN B A POINTER TO THE BLOCK
DSKRD:	CMP A,BLOKNO		;ALREADY GOT IT?
	BNE 1$			;NOPE
	CMP B,WCHDSK		;RIGHT DISK?
	BEQ 2$			;YUP, WE ALREADY HAVE THE BLOCK
1$:	JSR PC,LSFLSB
	MOV B,WCHDSK
	MOV A,BLOKNO
.IF NDF LSNDB
	MOV #LSDBUF,B		;IF WE ALLOCATE
.IFF
	JSR PC,LSGDBA		;IF SOMEONE ELSE DOES
.ENDC
	JSR PC,DSKRED		;READ IT IN
	TST TRNERR
	BEQ 2$			;NO ERROR
	MOV #-1,BLOKNO		;ERROR, NOBODY BELIEVE THIS BLOCK
2$:
.IF NDF LSNDB
	MOV #LSDBUF,B		;IF WE ALLOCATE
.IFF
	JSR PC,LSGDBA		;IF SOMEONE ELSE DOES
.ENDC
	RTS PC

DSKBG1:	JSR PC,LSGETB		;GET THE RIGHT BLOCK NUMBER
	MOV B,LSCRN1(F)		;SET IT IN
	BR DSKBG2		;AND DO REGULAR ROUTINE	
.ENDC				;END OF DISK STUFF

.IFNZ LSPRNT
.IIF NDF CPF,CPF==0
CCLPCP:	JSR PC,GETCPS
	INC LPUSE		;MARK LP AS USED
	LSERRC GT,BAD		;ALREADY USED?
	BIT #40,LPS		;IS IT A DIABLO?
	BEQ 19$			;NOPE
	CLR DIBCAR		;CARRIGE AT ZERO
	BIS #1,DIBCSR		;RESTORE PRINTER
19$:
.IF NZ CPF
	TST LPS			;IS PRINTER TURNED ON?
	BNE 10$			;YUP
	DEC LPUSE		;FREE THE PRINTER
	LSERR DEVE
10$:
.ENDC
	MOV #.LPCAP,LSCPTB(F)	;CREATE THE CAP
	MOV #LSLPBF,A
	JSR PC,LSBFRS		;RESET THE BUFFER
	ADD #4,E
.IFNZ CPF
	MOV #CPSELC,D
	TST LPS			;IS THE PRINTER ALREADY SELECTED?
	BLT 1$			;NOPE, SO IT'S NOT A PRINTRONIX
	CLR D			;EITHER CENTRONIX AND ALREADY SELECTED OR
				;PRINTONIX AND DOESN'T NEED SELECT
1$:
.IFF
	MOV #14,D		;FORMFEED
.ENDC
LPFORM:	CLR LPS
	MOV D,LPB
	CLR LPERRF
	MOV #30,A
1$:	TSTB LPS
	BLT 2$
	SOB B,1$
	SOB A,1$
2$:	RTS PC

LPDELC:	MOV #LSLPBF,A
	TST LSBFCN(A)
	BNE LPDELC		;WAIT FOR EMPTY BARFER
	CLR LSCPTB(C)		;DELETE CAP
	MOV #-1,LPUSE		;FREE THE LP
	ADD #6,E		;FLUSH ARGS
.IFNZ CPF
	MOV #CPDSLC,D
.IFF
	MOV #14,D		;FORMFEED
.ENDC
	CLR LPS
	MOV D,LPB
	RTS PC

LSLBYO:	MOV 2(E),D		;GET CHAR
	JSR PC,LPCOUT		;OUTPUT IT
	ADD #4,E
	RTS PC

LSLBLO:	MOV 4(E),F		;GET PTR TO BYTES TO XFER
	MOV 2(E),C		;GET NEG # OF BYTES TO XFER
	NEG C			;MAKE # POSITIVE
	BEQ 1$
2$:	MOVB (F)+,D
	JSR PC,LPCOUT
	SOB C,2$
1$:	ADD #6,E
	RTS PC

LPCOUT:	CMP #15,D
	BNE 1$
	CLR LPPOS		;BACK TO BEGGINING OF LINE
	INC LPLCNT		;ONE MORE LINE ON THE PAPER
	JSR PC,LPOUTE
	MOV #12,D
	JMP LPOUTE
1$:	INC LPPOS
	CMP LPPOS,LPLEN
	BLT 2$
	SAVE D
	MOV #15,D
	JSR PC,LPCOUT
	REST D
2$:				;FALLS INTO LPOUTE

LPOUTE:	TST LPERRF		;ERROR?
	LSERRC NE,DEVE

LPOUT:	SAVE <A,C>
	MOV #LSLPBF,A
	MOV D,C
1$:	JSR PC,LSBFPT
	BEQ 1$
	REST <C,A>
	BIS #100,LPS
	RTS PC

LPINT:	SAVE <A,C>
	MOV #LSLPBF,A
	TST LPS
	BMI LPINTE
1$:	TSTB LPS
	BGE LPINTR		;NOT READY, GO AWAY
	TST DIBSPA		;DO WE NEED TO SPACE THE DIABLO?
	BNE 2$			;YUP
	JSR PC,LSBFGT
	BEQ LPINTD
	BIT #40,LPS		;IS THIS A DIABLO?
	BNE 3$			;YES
12$:	MOVB C,LPB	
	BR 1$

2$:	MOV DIBSPS,C		;SPACE SIZE
	ADD C,DIBCAR		;CARRIAGE MOVED
	BIS #40000,C		;DO A CARRIAGE MOVE
	CLR DIBSPA		;SPACE IS DONE
15$:	MOV C,DIBBUF
	BR 1$

3$:	CMP #15,C		;CARRIGE RETURN?
	BEQ 10$			;YUP
	CMP #12,C		;LF?
	BEQ 11$			;YUP
	INC DIBSPA		;SPACING CHAR
	CMP #40,C		;SPACE?
	BEQ 1$			;YUP
	BR 12$			;SEND THE CHAR

10$:	MOV DIBCAR,C
	CLR DIBCAR
	BIS #42000,C		;REVERSE CARRIGE BY THIS AMOUNT
	MOV C,DIBBUF
	BR 1$
11$:	MOV DIBLFS,C		;LINE FEED SIZE
	BIS #100000,C
	BR 15$

LPINTE:	JSR PC,LSBFRS
	MOV PC,LPERRF
LPINTD:	CLR LPS
LPINTR:	REST <C,A>
	RTT


.ENDC				;END OF PRINTER STUFF
LSITSE::			;END OF LITTLE SITS
