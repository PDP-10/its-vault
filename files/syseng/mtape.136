
IFG NMTCS,[		;BEGIN MAG TAPE ROUTINES

;RANDOM SYMBOL DEFINITIONS

MAGVRS==.IFNM2	;FNAM2 OF MTAPE FILE
MSCBL==10.	;MAXIMUM # COMMANDS PER TRANSPORT
MGQDLL==20	;LENGTH OF XPT INTERRUPT LEVEL QDL
MTCRH==040200+MTCCHN_3	;NORMAL CONO MTC, RIGHT HALF
; ^ ALSO 40000 (CORE DUMP) IF CONI'S AS 9-TRACK XPT AT .OPEN TIME
MTDFRS==2000		;DEFAULT RECORD SIZE (ALSO MAXIMUM, BUT THAT NOT SYMBOLIC)
TNMTCS==NMTCS		;"TOTAL" # TRANSPORTS (USED TO BE EXTRA FOR .STATUS)
MSMAXB==6		;MAXIMUM NUMBER OF 1K BUFFERS
MGMAXE==6		;MAXIMUM NUMBER OF ERRORS AT INTERRUPT LEVEL BEFORE GIVING UP
MTXP==410300,,	;BYTE POINTER TO TRANSPORT # IN LH(IOCHNM)
MTCHNA==200_<-MTCCHN>
IFNDEF MTCON,	MTCON==UTCON	;CONO PI,MTCON TURNS ON MTCCHN
IFNDEF MTCOFF,	MTCOFF==UTCOFF	;CONO PI,MTCOFF TURNS OFF MTCCHN
IFNDEF MAGLOC,	MAGLOC==40+2*DCCHN
IFE C1MXP,IFNDEF DCCHNA,DCCHNA==200_-DCCHN	;DCCHN PI ACTIVE BIT

;ASSEMBLY SWITCHES OF RELEVANCE (NON-ZERO => INCLUDE FEATURE)
;DSDP => DESELECTION (DSDEVN)
;C1MXP => PI CHANNEL 1 MULTIPLEXOR
IFNDEF MTDBSW,	MTDBSW==1	;NON-ZERO TO INCLUDE DEBUGGING CODING 
			;(VARIOUS ERROR HALTS, PCLT, ETC.)
IFNDEF MGPDSW,	MGPDSW==0	;NON-ZERO => INCLUDE PDL OVERFLOW HALT AT MGXGO

;MEMBLT TABLE FIELDS FOR MAGTAPE BUFFERS:
;ALL BYTE POINTERS USE [FOO,,MEMBLT(AC)]
;MUR ALWAYS CONTAINS MUMGB (MOVEI T,MUMGB?DPB T,[MUR,,MEMBLT(A)]), SAYS THIS IS MAGTAPE BUFFER
;MLO ON READ, BLOCK # OF NEXT OR 0 => THIS LAST SO FAR
MSEOFP==230100		;BYTE POINTER TO EOF BIT IN MEMBLT TABLE (1 => THIS LAST BUFFER IN FILE)
;MSMWC ON READ, WORD COUNT, 0 TO 1024. INCLUSIVE
MSMWC==101300

	;MSERCT FLAGS (IN LH(CONI MTS,))
MGS00==400000	;ERROR OCCURRED DURING ATTEMPED READ
MGS01==440000	;WRITE OR READ/COMPARE
MGS10==500000	;OTHER, NOT WRITING ON TAPE (THIS IS DEFAULT, SET UP AT MGNCMD)
MGS11==540000	;OTHER, WRITING ON TAPE (OR READ/COMPARING WHERE NORMALLY WOULD WRITE)
MGS40==200000	;(WITH ONE OF ABOVE) ERROR INCIDENTAL TO MAIN OPERATION IN PROGRESS
		;(E.G. COULDN'T SELECT XPT OR LOST WHILE SPACING TO RECOVER FROM ERROR)

;APPROXIMATE ORGANIZATION OF THESE ROUTINES:
;.MSPAC
;.CALL MTAPE
;.OPEN, .CLOSE
;READ ROUTINES
;COMMON READ/WRITE ROUTINES
;WRITE ROUTINES, WRITE EOF ROUTINE
;MTIECK (TAKES IO CHANNEL ERROR), .RESET
;MAIN PROGRAM LEVEL SUBROUTINES
;INTERRUPT LEVEL SUBROUTINES
;DATA AREA, DCCHN BREAK (MGDBRK)
;INTERRUPT DISMISS ROUTINES
;INTERFACE TO UTCBRK
;SLOW CLOCK ROUTINE (MSMAGC)

;CODING CONVENTIONS
;SYMBOL NAMES
	;MT => USED MAINLY AT MAIN PGM LEVEL
	;MG => INTERRUPT LEVEL
	;MS => BOTH
;ACCUMULATORS
	;W HAS TRANSPORT NUMBER
	;H DURING READ .IOT HAS SAVED C(P) FOR EOF
	;R AT MAIN PROGRAM LEVEL POINTS TO IOCHNM
	;Q AT INTERRUPT LEVEL HAS PDL POINTER
	;C AT INTERRUPT LEVEL FREQUENTLY HAS CONI MTS,;IF NOT THEN SHOULD BE .GE. 0
	;U AT INTERRUPT LEVEL HAS MSMODE(W)
		; ^ GETS STORED BACK THERE WHENEVER INTERRUPT ROUTINE DISMISSES

;ROUTINES NOT WRITTEN YET

SNDMTC==SNDDEV	;.RCHST
STAMTC==STDSTA	;.STATUS

IFLE NMTCS-1,[	;THIS SHOULD REMAIN NEAR BEGINNING OF MAGTAPE ROUTINES
		;SO IT MAY APPEAR IN PARAMETER ASSIGNMENTS WITHOUT DIFFICULTY

MGCXIG:	SETZM MGHNGD	;ROUTINE TO IGNORE FACT THAT
		;XPT HAS BEEN TAKING TOO LONG TO RESPOND
	POPJ P,		;CALLED [PUSHJ P,@MGHNGD] FROM MAGTAPE SLOW CLOCK ROUTINE
]

	;MODIFICATIONS TO HARDWARE:
;(FOR C1MXP) DATA FLAG ISN'T CLEARED QUITE SO OFTEN AS IN DEC VERSION;
;IN PARTICULAR, IT ISN'T CLEARED BY CONO MTS,1; IT IS STILL CLEARED
;BY ANY CONO MTC,

	;ADDITIONS TO TM10A BLURBAGE:
;ON EOF DURING AN ATTEMPTED READ, A DATA WORD IS TRANSFERRED.

	;UNANSWERED QUESTIONS ABOUT TM10A:

;1)	IT HAS BEEN RUMORED THAT IN READ/COMPARE MODE, AN EXTRA
;	DATA WORD IS REQUIRED. IS THIS TRUE? IF SO, IS THE EXTRA WORD THE
;	FIRST OR THE LAST?

;2)	WHAT ARE THE CONSEQUENCES OF SELECTING A NEW TRANSPORT BEFORE THE
;	CURRENT COMMAND IS DONE? IN PARTICULAR, SAY ONE TRANSPORT IS
;	READING A HORRENDOUSLY LONG RECORD AND THE PROGRAM SELECTS A NEW
;	TRANSPORT, THEN SOMEONE SWITCHES THE FIRST XPT OFF-LINE.  DOES THE
;	TM10A SET XPT HUNG AND INTERRUPT THE PROCESSOR, OR DOES IT JUST
;	FORGET IT AND START THE NEXT XPT? I HOPE THE LATTER.
;MAGTAPE .MSPACE ROUTINE (OBSOLESCENT .OPER)

IFE <3-.TYPE AMSPAC >,AMSPAC=0	;MAKE CODING ASSEMBLE ONLY IF REQUESTED
IFDEF AMSPACE,[
	;.MSPACE ACI,
	;SPACE MT0 ACCORDING TO ACI (INTERPRETED IMMEDIATE)
	;DOES IT AND SKIPS IF PROCEDURE HAS MT0, OTHERWISE DOESN'T SKIP

SPCTBL:	JRST MTRW1	;0 => REWIND
	TROA B,MGSEOT	;1 => SPACE TO LOGICAL EOT
	PUSHJ P,MTWEOF	;2 => WRITE EOF IF APPROPRIATE
	REPEAT SPCTBL+17-.,POPJ P,	;UNASSIGNED VALUES DON'T SKIP
	PUSHJ P,MTWWT	;17 => HANG UNTIL INTERRUPT ROUTINE DIES

AMSPACE=.	;RECLOBBER DEFINITION
	CAME U,MTUSR	;THIS PROCEDURE HAVE MT0?
	POPJ P,		;NO
	MOVE T,MTUCHN'	;GET CHANNEL OPEN
	MOVEM T,UUAC(U)	;SO ERR GOES TO RIGHT CHNL
	SETZB W,B	;WORKING WITH XPT 0
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	XCT SPCTBL(J)	;DO APPROPRIATE THING ON BASIS OF AC
	JRST POPJ1	;THIS FOR MAYBE DISPATCH TO NON-SKIP ROUTINE
	PUSH P,B	;INSTRUCTION SKIPPED, INTERRUPT DISPATCH IN B
	PUSHJ P,MTICL2	;FLUSH READ ROUTINE IF ANY
	PUSHJ P,MTWEFB	;WRITE EOF IF APPROPRIATE
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	POP P,B		;RESTORE ADDRESS OF INTERRUPT ROUTINE TO GO TO
	JRST MTCMD1	;START IT UP, RETURN

]		;END .MSPAC CONDITIONAL

IFNDEF OPNTD7,OPNTD7:
IFE OPNTD7-.,[
OPNTD7:	TRZ D,-4
	ADDI D,(Q)
	HLR C,(D)
	TLNE D,400000
	HRR C,(D)	;OUTPUT
	MOVEM C,(R)
	JRST CLKOJ1
]
;MAGTAPE .CALL MTAPE 1

NMTPN==CPOPJ
		;CALL MTAPE IOCHNM,CMD,SUBCMD,...
		;SKIPS IF "SUCCESSFUL", I.E. IF IT COULD MAKE ANY SENSE OF THE COMMAND AT ALL
			;AND IF IO CHANNEL HAD MAGTAPE OPEN

NMTAPE:	SOJL W,OPNL30	;JUMP IF NO IOCHNM SPECIFIED (TOO FEW ARGS)
	CAIL W,8
	JRST OPNL15	;TOO MANY ARGS
	SKIPL R,A	;GET FIRST ARG
	CAIL R,20	;TOO BIG FOR CHANNEL?
	JRST OPNL14	;BAD CHANNEL NUMBER
	ADDI R,IOCHNM(U)	;CONVERT TO IO CHANNEL POINTER
	HRRZ T,(R)	;GET RH(IOCHNM)
	CAIL T,MTUAIX	;LOWEST MAGTAPE IOTTB ENTRY
	CAILE T,MTBOX	;HIGHEST " "
	JRST OPNL14	;DOESN'T HAVE MAGTAPE OPEN ON THIS CHANNEL
	MOVEM A,UUAC(U)	;STORE CHNM FOR IOC ERRORS
	MOVE H,W		;SAVE NUMBER OF ARGS
	LDB W,[MTXP (R)]	;GET XPT NUMBER
	SOJL H,MTRW1	;JUMP (REWIND) IF NO REAL ARGS
	JUMPL B,NMTPN	;JUMP IF FIRST ARG NEGATIVE
	CAIL B,MTLMTB
	POPJ P,		;COMMAND TOO BIG
	JRST @MTMTB(B)	;DISPATCH ON COMMAND TYPE

		;MAIN COMMAND DISPATCH TABLE FOR NMTAPE

MTMTB:	MTSPAC	;0 => SPACE
	MTSDS	;1 => DO SOMETHING (OTHER THAN SPACE)
	MTSTMD	;2 => SET MODE
MTLMTB==.-MTMTB	;LENGTH OF TABLE

		;.CALL MTAPE 1 => DO SOMETHING

MTSDS:	SOJGE H,.+2	;SKIP IF SUBCOMMAND SUPPLIED
	TDZA A,A	;NO SUBCOMMAND => USE ZERO
	SKIPL A,C	;GET SUBCOMMAND, SKIP IF INVALIDLY SMALL
	CAIL A,LMTSDT	;SKIP IF SUBCOMMAND NOT TOO BIG
	POPJ P,		;SUBCOMMAND OUT OF RANGE
	XCT MTSDT(A)	;DO WHATEVER THE TABLE SAYS
	JRST POPJ1	;DIDN'T JUMP OUT, SKIP-RETURN

MTSDT:	PUSHJ P,MTWEFA	;0 OR NO ARG => WRITE EOF IF APPROPRIATE
	PUSHJ P,MTWEFA	;1 WRITE EOF ANYWAY
	PUSHJ P,MTWEFA	;2 WRITE SINGLE EOF IF APPROPRIATE
	PUSHJ P,MTWEFA	;3 WRITE SINGLE EOF ANYWAY
	PUSHJ P,MTRDST	;4 START READING NOW
	PUSHJ P,MTWWT	;5 HANG UNTIL PI ROUTINE IDLE
	PUSHJ P,MTWT	;6 LIKE 5 BUT DON'T POSITION TAPE
	PUSHJ P,MTRWWT	;7 WAIT EVEN FOR REWINDING TO FINISH
	PUSHJ P,MTIECK	;10 NO-OP, MAYBE TAKE I/O CHANNEL ERROR
	PUSHJ P,MTPBUF	;11 END (WRITE OUT) CURRENT RECORD
	REPEAT 3,POPJ P,	;ROOM FOR PATCHING
LMTSDT==.-MTSDT
;MAGTAPE .CALL MTAPE 2

		;.CALL MTAPE 2 => SET MODE
		;SUBCOMMAND (MAYBE MULTIPLE WORD) 9 BIT BYTES, FIRST 6 BITS THING TO SET,
			;LAST 3 BITS VALUE TO SET IT TO, SEE MTSTMT FOR DESC OF FIRST 6 BITS
		;IF NO SUBCOMMAND, OR IF FIRST WORD OF SUBCOMMAND IS ZERO,
			;SET ALL TO NORMAL

MTSTMD:	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	REPEAT 5,PUSH P,.RPCNT+A+3	;SAVE MODE SPECIFICATION BYTES
	PUSH P,H	;SAVE WORD COUNT REMAINING IN COMMAND
	PUSHJ P,MTRSTP	;TELL READ ROUTINE (IF ANY) TO STOP AFTER CURRENT RECORD
	PUSHJ P,MTPBUF	;TERMINATE RECORD ON WRITE, IF ANY
	POP P,H		;RESTORE CRUFT
	REPEAT 5,POP P,A+7-.RPCNT
	JUMPLE H,MTSTIN	;NO ARG => INITIALIZE
	JUMPE C,MTSTIN	;ALSO INITIALIZE IF FIRST WORD OF BYTES IS ZERO
	IMULI H,4	;CONVERT TO # BYTES
	MOVEI J,0	;CLEAR OUT J TO ACCUMULATE SPEC FOR PI ROUTINES TO WORRY ABOUT
	MOVE R,[440900,,C]
	PUSH P,MTBFS(W)	;SAVE MTBFS, MUST BE ON TOP OF PDL AT MTSTM1 LOOP
MTSTM1:	ILDB A,R
	IDIVI A,10	;A := PARAMETER TO SET
	CAIGE A,LMTSMT	;IGNORE ILLEGAL PARAMETER
	XCT MTSTMT(A)	;OK, SET IT
	SOJG H,MTSTM1	;LOOP FOR ALL BYTES SUPPLIED
	SKIPE A,J	;PICK UP ARG TO INTERRUPT LEVEL, SKIP IF NOTHING TO DO
	PUSHJ P,MTSTM9	;SET INTERRUPT LEVEL MODE
	POP P,MTBFS(W)	;RESTORE (NEW) MTBFS (SURVIVED PCLSR => CAN CLOBBER NOW)
	PUSHJ P,MTRCHK	;MAYBE RESTART READ ROUTINE
	JRST POPJ1

MTSTMT:	JFCL		;0 IGNORED
	PUSHJ P,MTSTRS	;1 SET RECORD SIZE
	PUSHJ P,MTSWMD	;2 WRITE MODE
	PUSHJ P,MTSBPI	;3 DENSITY (BPI)
	PUSHJ P,MTSTP	;4 PARITY (1 => ODD)
	PUSHJ P,MTSTCD	;5 CORE DUMP BIT
LMTSMT==.-MTSTMT

		;SET BUFFER (RECORD) SIZE (GOBBLES NEXT BYTE FOR LOW 9 BITS)

MTSTRS:	SOJGE H,.+2	;IF NO MORE BYTES LEFT,
	TDZA A,A	;THEN USE ZERO
	ILDB A,R	;GET NEXT 9 BITS
	DPB B,[090300,,A]	;STORE HIGH BITS
	JUMPE A,CPOPJ	;IGNORE ZERO
	CAIG A,2000	;ALSO IGNORE OVER 2000
	HRRM A,-1(P)	;PASSES TESTS, STORE NEW RECORD SIZE
	POPJ P,
;MAGTAPE .CALL MTAPE 3

		;NMTAPE SET MODE (CONTINUED)

MTSTP:	JSP T,MTSTSM	;SET PARITY
	170300,,J

MTSTCD:	JSP T,MTSTSM	;CORE DUMP
	140300,,J

MTSBPI:	JSP T,MTSTSM	;BPI
	110300,,J

MTSWMD:	JSP T,MTSTI0	;WRITE MODE
	060300,,J

MTSTI0:	TRNN B,3	;ENTRY TO IGNORE ZERO
	POPJ P,
MTSTSM:	TRO B,4		;GIVE MODE SPECIFICATION TO PI ROUTINE, CALL WITH JSP T,
		;FOLLOW WITH BYTE POINTER TO 3 BIT FIELD IN J, POPJ'S OUT
	DPB B,(T)
	POPJ P,

		;NO SUBCOMMAND TO SET MODE => INITIALIZE ALL
		;ALSO INITIALIZE ALL IF FIRST WORD OF SUBCOMMAND IS ZERO

MTSTIN:	MOVEI A,546600	;PARITY = 1, CORE DUMP = 0, DENSITY = 2 (800 BPI), WRITMD=WRITE
	MOVE T,MSMODE(W)
	TLNE T,10000	;9 TRACK TRANSPORT?
	TRO A,20000	;9 TRACK, SET CORE DUMP
	PUSHJ P,MTSTM9	;SET UP INTERRUPT CONDITIONS
	MOVEI A,MTDFRS	;DEFAULT RECORD SIZE
	HRRM A,MTBFS(W)	;SET RECORD SIZE
	JRST POPJ1

MTSTM9:	JUMPE A,CPOPJ	;IGNORE IF NOTHING TO SET
	JSP B,MTCMDA	;START UP INTERRUPT ROUTINE TO SET MODE
MGSTMD:	MOVEI E,0	;HERE AT INTERRUPT LEVEL, INITIALIZE INDEX
	TRZ B,-1	;CLEAR OUT GARBAGE, JUST INTERESTED IN LEFT HALF
MGMDLP:	JFFO B,.+2	;LOOP POINT: ANY BITS LEFT?
	JRST MGF	;NOTHING MORE TO SET
	LSHC A,3(C)	;FOUND BIT, SHIFT IT AND NEXT TWO INTO B
	IDIVI C,3	;GET # OCTAL DIGITS SHIFTED -1
	ADD E,C		;ADD TO INDEX
	DPB A,MGMTBL(E)	;DEPOSIT CRUD INTO MGCMD
	AOJA E,MGMDLP	;INCREMENT INDEX (REMEMBER THE -1?) AND LOOP

		;TABLE OF BYTE POINTERS TO MGCMD FOR MGSTMD

MGMTBL:	160100,,MGCMD(W)	;PARITY
	150100,,MGCMD(W)	;CORE DUMP
	060200,,MGCMD(W)	;DENSITY
	210200,,U		;WRITE MODE
;MAGTAPE .CALL MTAPE 4

		;REWIND (SKIP-RETURNS)

MTRW1:	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTICL2	;INPUT, FLUSH READ ROUTINE & BUFFERS
	PUSHJ P,MTWEOF	;MAYBE WRITE EOF
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	MOVEI B,MGRW
	PUSHJ P,MTCMDP	;START UP INTERRUPT ROUTINE AT MGRW
	MOVSI A,400000	;GET MAIN PROG EOF BIT
	ANDCAM A,MSMODE(W)	;TURN OFF IN MSMODE
	JRST POPJ1

		;INTERRUPT LEVEL ROUTINE TO REWIND

MGRW:	PUSHJ Q,MGMTCG	;GET MTC
	TRNE C,100000	;CHECK BOT BIT
	JRST MGRW2	;ALREADY AT BEGINNING OF TAPE
	MOVEI C,1000	;REWIND
	PUSHJ Q,MGCMDX	;DO IT
MGRW2:	TLZ U,4		;CLEAR OUT PI EOF BIT
	SETZM MGTPOF(W)	;DON'T HAVE TO SPACE AROUND
	TRNE C,440000	;CHECK XPT HUNG, ILLOP
	MOVEM C,MSERCT(W)	;SOMETHING WRONG, STORE ERROR CONI
	JRST MGF	;RELEASE MTC AND RETURN

		;WAIT FOR REWINDING TO FINISH (NORMAL ROUTINE)

MTRWWT:	MOVEI B,MGRWWT
	PUSHJ P,MTCMDP	;START UP INTERRUPT ROUTINE
	JRST MTWT	;WAIT FOR IDLE, MAYBE TAKE IOC ERROR, RETURN

MGRWWT:	PUSHJ Q,MGALGN	;INTERRUPT LEVEL ROUTINE TO WAIT FOR REWINDING TO FINISH
	PUSHJ P,MGMTCF	;FREE MTC (BLETCH)
	PUSHJ Q,MGGIDL	;GET BACK MTC, WAIT FOR IDLE
	JRST MGF

		;WAIT FOR REWINDING TO FINISH
		;SKIPS EXCEPT ON PCLSR FROM WAITING FOR IDLE; MSRPCL SHOULD INITIALLY BE 0
		;SHOULD BE CALLED ONLY IF ROOM IN COMMAND BUFFER FOR AT LEAST ONE COMMAND

MTRWWU:	MOVEI B,MGRWWU	;SET UP COMMAND
	PUSHJ P,MTCMDN	;START UP INTERRUPT ROUTINE
	PUSHJ P,MTWTP	;WAIT FOR IDLE, SKIP UNLESS PCLSR
	SOSA MSRPCL(W)	;PCLSR, CAUSE QUIT
	AOS (P)		;NO PCLSR, CAUSE RETURN TO SKIP
	POPJ P,

MGRWWU:	MOVEI A,MGRWW2	;INTERRUPT ROUTINE
	PUSHJ P,MGUFST	;TRAP TO MGRWW2 ON ATTEMPTED EXIT
	PUSHJ Q,MGGIDL	;GET MTC, WAIT FOR IDLE
	JRST MGF	;ALL WAITED OUT

MGRWW2:	SKIPGE MSERCT(W)	;HERE ON EXIT, CHECK DEATH FLAG
	SETOM MSERCT(W)	;DEATH; REPLACE POSSIBLE CONI WITH -1 SO WON'T TAKE IOC ERROR
	JRST MGF
;MAGTAPE .CALL MTAPE 5

		;SKIP TO LOGICAL END OF TAPE (SKIP-RETURNS)

MTSEOT:	PUSHJ P,MTIECK	;MAIN PROGRAM ENTRY, MAYBE TAKE IOC ERROR
	JSP B,MTCMD1	;START UP INTERRUPT ROUTINE, SKIP-RETURN
MGSEOT:	TLZ U,4		;CLEAR OUT PI READ EOF BIT
	PUSHJ Q,MGALGN	;CORRECT TAPE POSITION, GOBBLE MTC
MGEOT2:	SETOM MGTMP1(W)
MGEOT4:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGF	;REAL END OF TAPE
	PUSHJ Q,MGMFGT	;MAYBE GIVE UP MTC FOR AWHILE
	MOVEI C,2000	;READ COMMAND, DATA PIA = 0
	PUSHJ Q,MGCMDX	;START READING
	TRNE C,440000	;CHECK XPT HUNG, ILLOP
	JRST MGFC	;ERROR
	TRNN C,10000	;CHECK EOF FLAG
	JRST MGEOT2	;NOT SET, LOOP BACK FOR NEXT
	AOSN MGTMP1(W)	;EOF; IS IT THE FIRST?
	JRST MGEOT4	;NO, BACK FOR MAYBE THE NEXT
	JRST MGEOT3	;SPACE BACK OVER SECOND ONE
;MAGTAPE .CALL MTAPE 6

		;.CALL MTAPE 0 => SPACE

MTSPAC:	PUSHJ P,MTIECK	;MAYBE TAKE I/O CHANNEL ERROR
	SOJL H,MTRW1	;NO SUBCOMMAND => REWIND
	SOJL C,MTRW1	;SUBCOMMAND .LE. 0 => REWIND
	PUSH P,C	;SAVE SUBCOMMAND
	PUSHJ P,MTICL2	;FLUSH READ ROUTINE, IF ANY
	PUSHJ P,MTPBUF	;WRITE OUT CURRENT RECORD, IF ANY
	POP P,A		;GET SUBCOMMAND BACK
	SOJL A,MTSEOT	;ORIGINAL SUBCOMMAND 1 => SKIP TO LOGICAL EOT
	CAILE A,5
	POPJ P,		;TOO BIG
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	AOS (P)		;NORMAL SPACE OF SOME KIND
			;DROPS THROUGH
		;SPACING ROUTINES

MTCMSP:	PUSH P,A	;GENERAL COMMAND, TAKES ARG IN A
	MOVEI B,MGCMSP
	PUSHJ P,MTCMDA	;START UP INTERRUPT ROUTINE AT MGCMSP
	POP P,A
	MOVSI T,400000	;EOF BIT IN MSMODE
	TRNE A,1	;ARG ODD?
	IORM T,MSMODE(W)	;ARG ODD => SET EOF
	TRNN A,1
	ANDCAM T,MSMODE(W)	;ARG EVEN => CLEAR EOF BITS IN MSMODE
	POPJ P,

MGCMSP:	TLZ U,4		;CLEAR OUT PI READ EOF BIT
	HLRZ A,B	;GET ARG
	MOVE B,MGSPCT(A)	;GET TABLE ENTRY THIS ARG
	HRREI A,(B)		;RH AMT TO ADD TO MGTPOF
	HRRI B,MGTPOF(W)	;REST SOMETHING TO DO TO MGTPOF
	MOVEM B,MGTMP1(W)	;STORE REST, AC'S GETTING CLOBBERED IN THE MEANTIME
	MOVE D,MGTPOF(W)	;GET MGTPOF NOW TO LATER SEE IF SHOULD ALIGN
	MOVM E,D		;ALSO GET MAGNITUDE OF OLD
	ADDB A,MGTPOF(W)	;NOW UPDATE
	MOVM B,A	;GET MAGNITUDE OF NEW IN B
	CAML B,E
	PUSHJ Q,MGALGN	;ABS(NEW) .GE. ABS(OLD) => DO IT NOW
	TRNN C,100000	;SKIP ON BOT
MGCMS3:	XCT MGTMP1(W)	;NOW MAYBE MUNG MGTPOF IN THE OPPOSITE DIRECTION
	JRST MGF

		;TABLE FOR SPACING (RH INCR TO MGTPOF NOW, LH INSTR TO MGTPOF LATER)

MGSPCT:	AOS -2	;0 BEG OF PREV FILE
	JFCL -1	;1 END OF PREV
	AOS -1	;2 BEG OF CURRENT
	SOS 1	;3 END OF CURRENT
	JFCL 1	;4 BEG OF NEXT
	SOS 2	;5 END OF NEXT
;MAGTAPE .OPEN/.CLOSE 1

		;MAGTAPE .OPEN

MAGTO:	SKIPL W,I	;GET DEVICE NUMBER INTO W
	CAIL W,NMTCS	;TOO BIG?
	JRST OPNL1	;NO SUCH DEVICE (NUMBER OUT OF RANGE)
	LDB H,[430100,,D]	;GET DIRECTION BIT OF THIS PROPOSED OPEN (STAYS AROUND AWHILE)
	CONO PI,CLKOFF
	SKIPGE MTUSR(W)	;THIS TRANSPORT IN USE?
	MOVEM U,MTUSR(W)	;NO, RESERVE IT
	CONO PI,CLKON
	CAME U,MTUSR(W)	;HAVE TRANSPORT?
	JRST OPNL10	;NO, MUST NOT BE AVAILABLE
	PUSHJ P,STMSET	;SETOM MTUSR ON PCLSR, OPENLOSS, ETC.
	 MTUSR(W)
	SKIPGE MTUSE(W)	;THIS TO BE FIRST .OPEN THIS XPT?
	JRST MTOW1	;YES
MAGTO1:	JFCL		;OR JRST OPNL12, DEPENDING ON WHETHER THIS WORKS
	LDB E,MTOCBP(H)	;GET # TIMES OPEN THIS DIRECTION
	CAIL E,17	;ALREADY OPEN 17 TIMES?
	JRST OPNL12	;OPEN TOO MANY TIMES ("MODE NOT AVAILABLE")
	MOVE T,MTOCHM(H)	;GET CHARACTER MODE BIT THIS DIRECTION
	MOVE TT,MTONCM(H)	;GET NON-CHARACTER MODE BIT THIS DIRECTION
	TLNN C,6	;SKIP UNLESS .OPEN IS FOR CHARACTER MODE
	EXCH T,TT	;CHARACTER MODE
	TDNE T,MSMODE(W)	;SKIP UNLESS ALREADY OPENED IN THE OTHER MODE
	JRST OPNL12	;NOT ALLOWED TO BE OPEN IN CHARACTER AND NON-CHAR MODE
			;SIMULTANEOUSLY IN THE SAME DIRECTION
	PUSHJ P,LSWDEL	;NO PCLSR ALLOWED AFTER HERE, MAY AS WELL FLUSH STMSET
	IORM TT,MSMODE(W)	;DOCUMENT WHICH MODE-TYPE OPENED IN
	AOJ E,		;INCREMENT # TIMES OPEN THIS DIRECTION
	DPB E,MTOCBP(H)	;STORE # TIMES OPEN THIS DIRECTION
	AOS MTUSE(W)	;ANOTHER OPEN THIS TRANSPORT
MTOW:	IFDEF MTUCHN,[MOVE Q,UUAC(U)	;CHNL
	MOVEM Q,MTUCHN	;SAVE FOR .MSPACE
]
	JSP Q,OPNTD7	;SET UP IOCHNM AND SKIP-RETURN
	 MTUAIX,,MTUAOX	;UNIT ASCII (CHARACTER) INPUT,,OUTPUT
	 MTBIX,,MTBOX	;BLOCK (ASCII)
	 MTUIIX,,MTUIOX	;UNIT IMAGE
	 MTBIX,,MTBOX	;BLOCK (IMAGE)
;MAGTAPE .OPEN/.CLOSE 2

MTOW1:	PCLT		;THIS IS FIRST .OPEN THIS XPT
	MOVE T,W
	PUSHJ P,MTWTW	;WAIT FOR PI IDLE THIS XPT
	PUSHJ P,UFLS
IFN DSDP,[CONO PI,MTCOFF
	SKIPL MSUSE	;MTC DEASSIGNED?
	JRST MTOW2	;NO
	CONO MTC,0	;YES, TRY ASSIGNING IT
	CONI MTC,T	;NOW SEE IF WINNAGE
	JUMPL T,MTOW2	;JUMP (WIN) IF ASSIGNED TO PROCESSOR
	CONO PI,MTCON	;LOSE, RE-ENABLE INTERRUPTS
	JRST OPNL25	;DEVICE NOT ASSIGNABLE TO THIS PROCESSOR

MTOW2:	AOS MSUSE	;INCREMENT TOTAL USE COUNT
	CONO PI,MTCON	;TIMING ERROR PROBLEMS GONE, HOPEFULLY
]	AOS MTCUSE	;SURVIVED TESTS SO FAR, SAY ANOTHER XPT ROUTINE OPEN
	AOS MTUSE(W)	;ANOTHER OPEN THIS TRANSPORT
	SETZM MSRPCL(W)	;CLEAR OUT STOP REQUEST
	SETZM MSERCT(W)	;ALSO CLEAR OUT STOP FLAG
	MOVEI A,MTCRH
	DPB A,[1700,,MGCMD(W)]	;JUST TO BE SURE
	PUSHJ P,LSWDEL	;HAVE TO FLUSH STMSET OF MTUSR(W) SO FINSET AT MTRWWU WILL WORK
	PUSHJ P,MTRWWU	;WAIT FOR REWIND TO FINISH
	JRST MTIOL1	;PCLSR'D OUT
	MOVE J,MSSCNI(W)	;GET CONI MTS,
	TRNE J,40	;CHECK XPT IDLE
	TDZA A,A	;SET => OK
	MOVEI A,OPNL7	;DEVICE NOT READY (NOT REALLY THERE)
	JUMPGE D,MTOW2B	;JUMP IF OPEN IS FOR INPUT
	TRNE J,10	;OUTPUT, CHECK WRITE LOCK
	MOVEI A,OPNL26	;DEVICE WRITE-LOCKED
MTOW2B:	JUMPE A,MTOW3	;JUMP IF OPEN SHOULD WIN
	PUSH P,A	;LOSE, SAVE OPNL# AS RETURN
	JRST MTIOL2	;DECREMENT MTCUSE AND RETURN

	;CONTINUATION OF MTAPE .OPEN (J STILL HAS CONI MTS, THIS XPT)

MTOW3:	MOVEI A,MTDFRS	;GET DEFAULT RECORD SIZE
	DPB H,[430100,,A]	;DEPOSIT DIRECTION BIT
	MOVEM A,MTBFS(W)	;STORE MTBFS
	MOVEI A,MTCRH
	TRNN J,4
	TRO A,20000		;9 TRACK TRANSPORT => SET CORE DUMP
	DPB A,[1700,,MGCMD(W)]	;STORE COMMAND TO MTC (HAS DENSITY AND PARITY INDICATION)
	TLNN C,6		;CHECK FOR CHARACTER MODE
	SKIPA A,MTOCHM(H)	;CHARACTER MODE, GET CHAR. MODE BIT
	MOVE A,MTONCM(H)	;NON-CHARACTER MODE, GET BIT
	TLO A,1			;SET WRITE MODE TO WRITE
	TRNN J,4		;SKIP IF 7 CHANNEL XPT
	TLO A,10000		;SIGNAL THIS IS 9 TRACK TRANSPORT
	MOVEM A,MSMODE(W)	;STORE MSMODE
	MOVEI A,1
	DPB A,MTOCBP(H)	;OPEN ONCE THIS DIRECTION
	SETZM MTBUFC(W)	;CLEAR OUT COUNT IN BUFFER
	SETZM MTBUFO(W)	;ALSO INDICATE NO BUFFER
	SETZM MGTPOF(W)
	JRST MTOW
;MAGTAPE .OPEN/.CLOSE 3

		;GET TO MTIOL1 ON PCLSR FROM MTOW1

MTIOL1:	PUSHJ P,FINSET	;FOR DEBUGGING
	 JRST 4,.	;GETTING TO HERE => MTRS4 HUNG; IT WASN'T SUPPOSED TO
	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
	HLRZ A,MGFLL(W)	;GET BLOCKING CONDITION (OR ZERO)
	MOVEI B,MTRS4	;IN CASE .+1 SKIPS
	CAIN A,MGMTCX	;WAITING FOR MTC TO INTERRUPT?
	MOVEI B,MGCXUH	;YES, REPLACE B WITH UNHANG ROUTINE
	PUSHJ P,(B)	;DO THE APPROPRIATE THING TO UNHANG XPT ROUTINE
	CONO PI,MTCON	;RE-ENABLE INTERRUPTS (IN CASE NOT ALREADY DONE)
	PUSHJ P,LSWDEL	;FLUSH DEBUG CHECK FOR HANGING
	JRST MTIOL2	;FALL INTO .CLOSE ROUTINE

		;CLOSE ROUTINES

MTOCLS:	MOVEI H,1	;.CLOSE MAGTAPE OUTPUT
	JSP Q,MTCLSC	;EXECUTE PRELIMINARY COMMON CODING (DOES PUSHJ P,(Q))
	PUSHJ P,MTWEOF	;WRITE EOF IF APPROPRIATE
	JRST MTALGN

MTICLS:	MOVEI H,0	;.CLOSE MAGTAPE INPUT
	JSP Q,MTCLSC	;EXECUTE PRELIMINARY COMMON CODING (DOES PUSHJ P,(Q))
	PUSHJ P,MTICL2	;FLUSH READ BUFFERS AND READ ROUTINE (SETS UP J FOR MTCLSA)
	SKIPGE MTBFS(W)	;SKIP IF BUFFERS WRITE BUFFERS => DON'T DO ANYTHING ELSE SPECIAL
	POPJ P,		;MAIN PROGRAM NOT IN EOF STATE, DON'T BOTHER SKIPPING TO EOF
	JSP B,MTCMDP	;ROUTINE TO MAYBE SPACE FORWARD OVER EOF AT END OF FILE JUST PROCESSED
	TLZE U,4	;CHECK PI EOF BIT
	AOS MGTPOF(W)	;EOF, WANT TO SKIP OVER MARK AGAIN, SINCE BACKSPACED WHEN GOT IT
	JRST MGBLGN
;MAGTAPE .OPEN/.CLOSE 4

MTOCBP:	110400,,MSMODE(W)	;BYTE POINTER TO # TIMES OPEN FOR READ
	150400,,MSMODE(W)	;WRITING
MTOCHM:	40,,		;MSMODE BIT FOR CHARACTER MODE INPUT
	100,,		;OUTPUT
MTONCM:	200,,		;NON-CHARACTER MODE INPUT
	400,,		;OUTPUT

		;COMMON CODING FOR MTAPE .CLOSE
		;CALLED WITH JSP Q,	;USUALLY DOES PUSHJ P,(Q)

MTCLSC:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER
	LDB I,MTOCBP(H)	;GET # TIMES OPEN THIS DIRECTION
	SOJG I,MTICL8	;JUMP IF MORE OPENS THIS DIRECTION
	PUSHJ P,SGNSET	;WANT TO CLEAR SIGN OF MTCLSF ON PCLSR
	 MTCLSF(W)	;NO PROBLEM IF ALREADY POSITIVE; IT'S NOT A SWITCH
	PUSH P,[MTICL9]	;RETURN TO MTICL9
	PUSHJ P,MTLOTT	;SKIP UNLESS NOT ALLOWED TO TAKE IOC ERROR
	 MOVEM P,MTCLSF(W)	;NOT ALLOWED, SET FLAG (& PDL POINTER) TO MTIECK
	PUSH P,Q	;SO MTIEC0 WILL RETURN TO CALLING ROUTINE
	JRST MTIEC0	;MAYBE TAKE IOC ERROR, BUT DO .RESET IF OTHERWISE WOULD RESTART STOPPED ROUTINE

MTICL9:	PUSHJ P,MTWT	;WAIT FOR IDLE (DON'T GO TO MTCMD AT OR AFTER MTICL9)
	SKIPL MSCMDC(W)	;SKIP IF COMMAND BUFFER EMPTY
	JRST MTICL9	;MORE COMMANDS IN COMMAND BUFFER, LOOP UNTIL EMPTY
	PUSHJ P,LSWPOP	;CLEAR OUT SIGN BIT OF MTCLSF
	MOVE T,MTOCHM(H)	;GET CHARACTER MODE BIT
	IOR T,MTONCM(H)		;IOR IN NON-CHAR BIT
	ANDCAM T,MSMODE(W)	;NOT OPEN EITHER IN CHAR MODE OR NON-CHAR MODE THIS DIRECTION
MTICL8:	DPB I,MTOCBP(H)	;STORE NEW # TIMES OPEN THIS DIRECTION
MTIOL2:	CONO PI,MTCOFF
	SOSL MTUSE(W)
	JRST MTCONJ
	SETOM MTUSR(W)
	SOS MTCUSE
IFN DSDP,[SOSGE MSUSE	;SEE ALSO SIMILAR ROUTINE AT MGF
	DATAO DSDEV,[DSMTC]	;DESELECT MAGTAPE CONTROLLER
]	JRST MTCONJ

		;SKIP UNLESS NOT ALLOWED TO TAKE I/O CHANNEL ERROR
		;CLOBBERS ONLY T AND TT

MTLOTT:	MOVE T,USER	;GET CURRENT USER
	MOVE TT,UUOH	;GET PC
	CAME TT,[LOGOPC]	;LOGGING OUT? SKIP IF SO, DON'T TAKE IOCERR
	CAME T,MTUSR(W)	;SKIP UNLESS USER ISN'T MAGTAPE USER THIS XPT
	POPJ P,		;DON'T TAKE IOCERR
	JRST POPJ1	;OK TO TAKE ERROR
;MAGTAPE READ ROUTINES 1

MTIE:	SKIPLE MSNBUF(W)	;ENTRY FROM .IOT ROUTINES
MTICL2:	SKIPGE MTBFS(W)	;SKIP UNLESS BUFFERS ARE WRITE BUFFERS
	POPJ P,		;RETURN IF NO BUFFERS OR IF IN WRITE MODE
	PUSHJ P,MTRDFS	;FLUSH READ ROUTINE (DON'T CLOBBER J AFTER THIS)
	SKIPG MSNBUF(W)	;CHECK NUMBER OF BUFFERS
	POPJ P,		;NO BUFFERS
	SKIPE MGBUFP(W)	;DEBUG CHECK: CHECK TO SEE IF INTERRUPT LEVEL BUFFER
	JRST 4,.-1	;READ ROUTINES (MGREAD) DIDN'T CALL MGRPBK TO "FLUSH" INTERRUPT LEVEL BUFFER
	MOVE T,MTBUFO(W)	;GET ORIGIN OF FIRST BUFFER
	TLC T,(T)	;ONE HFWD INITIALLY ZERO, GET ORIGIN IN LEFT HALF
	LSH T,-<36.-8>	;SHIFT TO BLOCK NUMBER
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT REMAINING IN BUFFER
MTICL5:	SKIPN A,T	;GET BLOCK # IN A
	JRST 4,.	;TRYING TO FREE BLOCK 0 => BUFFER COUNT OUT OF PHASE WITH BUFFERS
	PUSHJ P,MTBUFR	;RETURN BUFFER TO FREE
	JRST MTICL5	;LOOP BACK UNTIL MTBUFR POPJ'S OUT

		;RETURN BUFFER TO FREE STORAGE

MTBUFR:	LDB T,[MUR,,MEMBLT(A)]
	CAIE T,MUMGB
	JRST 4,.	;TRYING TO FREE NON-MAGTAPE-BUFFER
	LDB T,[MLO,,MEMBLT(A)]	;GET LINK TO NEXT, IF ANY (ENTRY TAKING BLOCK #)
	PUSHJ P,MEMR	;NO, RETURN BLOCK
	SOSG MSNBUF(W)	;ONE LESS BUFFER
	POP P,A		;NO MORE BUFFERS
	POPJ P,
;MAGTAPE READ ROUTINES 2

	;MAGTAPE INPUT .IOT ROUTINES

MTUAI:	JSP E,MTREAD	;UNIT ASCII (CHARACTER) INPUT
	 JSP B,CHRKT
	HRROI A,EOFCH	;EOF, SET UP CHARACTER
	XCTR XRW,[MOVEM A,(C)]	;GIVE TO USER
	JRST MTIE	;MAYBE FLUSH BUFFERS, RETURN

MTUII:	JSP E,MTREAD	;UNIT IMAGE INPUT
	 JSP B,WRDKT
	MOVE A,[EOFWRD]	;GET EOF WORD IN A
	XCTR XRW,[MOVEM A,(I)]	;STORE EOF WRD/CHAR FOR USER
	JRST MTIE	;MAYBE FLUSH BUFFERS

MTBI:	JSP E,MTREAD	;BLOCK INPUT
	 JSP B,BLKT
	MOVSI A,4	;SET UP AC FOR ASCII/IMAGE TEST
	TDNN A,(R)	;THIS CHANNEL OPEN IN IMAGE MODE?
	XCTR XR,[SKIPL I,(C)]	;ASCII MODE, PREPARE TO RETURN EOF WORD
	JRST MTIE	;IMAGE MODE, OR POINTER COUNTED OUT
	PUSH P,C	;C AND I MUST NOT GET CLOBBERED, ROUTINES TEND TO LEAVE I ALONE
	PUSHJ P,MTIE	;MAYBE FLUSH READ ROUTINE AND/OR BUFFERS
	POP P,C
	MOVE A,[EOFWRD]	;GIVE HIM EOF
	XCTR XRW,[MOVEM A,(I)]
	MOVE A,[1,,1]	;NOW PREPARE TO UPDATE POINTER
	XCTR XRW,[ADDM A,(C)]	;UPDATE HIS POINTER
	POPJ P,

MTRDST:	JSP E,MTRED2	;DUMMY ".IOT" ROUTINE TO START READING
	 POPJ P,	;FOR .CALL MTAPE 1,4 (THIS IS NORMAL RETURN)
	POPJ P,		;(EOF RETURN) EVENTUALLY WANTS TO ALSO BE ABLE TO TELL PI READ ROUTINES
			;TO CONTINUE PAST EOF
;MAGTAPE READ ROUTINES 3

	;JSP E,MTREAD	;CALL COMMON READ ROUTINE
	; JSP B,BLKT\CHRKT\WRDKT	;WHERE TO GO FOR NORMAL .IOT (NO EOF)
	;RETURNS HERE ON EOF

MTREAD:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER FROM IOCHNM WORD
MTRED2:	PUSHJ P,MTIECK	;TAKE IOC ERROR IF ANY PENDING
	SKIPGE MSMODE(W)	;CHECK FOR EOF
	JRST 1(E)	;EOF, GO BACK AND HANDLE DIFFERENTLY PER MODE
	SKIPGE MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTOIRV	;REVERSE DIRECTION
	PUSHJ P,MTRCHK	;MAYBE START UP ROUTINE
	MOVE H,P	;SAVE P IN CASE OF EOF
	XCT (E)		;JSP B,BLKT\CHRKT\WRDKT
	 MTBUFP(W)	;LOCATION OF NEXT WORD
	 MTBUFC(W)	;COUNT REMAINING
	 MTRBFG		;ROUTINE TO GET NEW BUFFER
	 MTRBFD		;ROUTINE TO DISCARD BUFFER
	 @MTBSIZ(W)	;BUFFER SIZE (IMMEDIATE)
	 PUSHJ P,MTRBFW	;WAIT FOR BUFFER
	 CAIN D,EOFCH	;CHECK FOR END OF FILE (CHRKT ONLY)
	MOVSI A,400000	;EOF RETURN FROM CHRKT
	IORM A,MSMODE(W)	;SET EOF BIT
	JRST MTIE	;RETURN (CHRKT RETURNED -1,,EOFCH)

		;WAIT FOR BUFFER

MTRBFW:	MOVSI TT,30	;SET UP BITS FOR TEST
	SKIPG MSNBUF(T)	;WAIT FOR BUFFER,
	TDNN TT,MSMODE(T)	;OR FOR INTERRUPT ROUTINE TO DIE (INCLUDING MAYBE ERROR)
	AOS (P)		;BUFFER AVAILABLE OR INTERRUPT ROUTINE DEAD
	POPJ P,
;MAGTAPE READ ROUTINES 4

	;MAGTAPE READ ROUTINES, MAIN PROGRAM LEVEL BUFFER HANDLING

	;DISCARD BUFFER

MTRBFD:	PUSHJ P,MTBUFD	;FLUSH BUFFER, SKIP-RETURN WITH MTCCHN OFF
	JRST MOVTWJ	;NONE THERE, MTCCHN ON, RETURN, SETTING UP T FOR FLSINS
	DPB T,[341000,,MTBUFO(W)]	;SAVE LINK
	CONO PI,MTCON
	JUMPN TT,MTRBD2	;JUMP ON EOF
	PUSHJ P,MTRCHK	;MAYBE START UP READ ROUTINE
	JRST MOVTWJ	;SET UP T FOR FLSINS AND RETURN

MTRBD2:	MOVSI A,400000	;EOF BIT IN MSMODE
	IORM A,MSMODE(W)	;SIGNAL EOF
	MOVE P,H	;RESET P
	HRRZ B,(R)	;GET RH(IOCHNM) FOR DISPATCH
	JRST @IOTTB(B)	;DISPATCH BACK TO RELEVANT .IOT ROUTINE

		;FLUSH MAIN PROGRAM BUFFER, SKIP-RETURN WITH MTCCHN OFF
		;IF NO BUFFER THERE, THEN NON-SKIP RETURN WITH MTCCHN ON

MTBUFD:	MOVEI A,@MTBUFO(W)	;GET BLOCK ORIGIN
	JUMPE A,CPOPJ	;RETURN IF NO BLOCK THERE
	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT REMAINING
	SOS MSNBUF(W)	;ONE LESS BUFFER
	LSH A,-10.	;SHIFT TO BLOCK NUMBER
	AOS (P)		;CAUSE RETURN TO SKIP
	LDB T,[MLO,,MEMBLT(A)]	;GET WHAT MAY BE LINK TO NEXT BLOCK
	LDB TT,[MUR,,MEMBLT(A)]	;NOW MAKE SURE THIS IS MAGTAPE BUFFER
	CAIE TT,MUMGB
	JRST 4,.	;BUFFER BEING "FLUSHED" WASN'T MAGTAPE BUFFER TO FLUSH
	LDB TT,[MSEOFP,,MEMBLT(A)]	;GET EOF BIT
	JRST IMEMR	;FREE BLOCK AND RETURN WITH MTCCHN OFF
;MAGTAPE READ ROUTINES 5

	;GET NEW BUFFER (SKIPS IF SUCCESSFUL)

MTRBFG:	PUSHJ P,MTRCHK	;START UP READ ROUTINE IF APPROPRIATE
	MOVSI TT,4
	SKIPLE MSNBUF(W)	;SKIP UNLESS BUFFER AVAILABLE
	JRST MTRBG2	;BUFFER AVAILABLE, USE IT
	TDNE TT,MSMODE(W)	;NOT AVAILABLE, CHECK EOF BIT
	JRST 4,.	;PI EOF BIT SET WITHOUT EOF BUFFER AVAILABLE
	MOVE T,W	;RE-INITIALIZE T FOR FLUSH INSTR AGAIN
	JRST UDELAY	;JUST DROPPED OUT TO RESTART READ ROUTINE

MTRBG2:	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
	LDB A,[341000,,MTBUFO(W)]	;GET LINK TO NEXT BLOCK
	LDB TT,[MUR,,MEMBLT(A)]
	CAIE TT,MUMGB
	JRST 4,.	;PICKED UP NON-MAGTAPE BUFFER FOR READ
	LDB T,[MSMWC,,MEMBLT(A)]	;GET WORD COUNT
	MOVEM T,MTBSIZ(W)	;STORE WORD COUNT AS BUFFER SIZE
	HLRZS TT,MTBUFO(W)	;GET ORIGIN OF NEW BUFFER
	JRST MTCOJ1	;GO READ FROM NEW BUFFER

		;PUSHJ P,MTRCHK (DOESN'T CLOBBER B)
		;IF READ ROUTINE DEAD, START IT UP

MTRCHK:	MOVSI A,34	;GET TEST BITS
	SKIPL MTBFS(W)	;SKIP IF OUTPUT, DON'T DO ANYTHING
	TDNE A,MSMODE(W)	;READ ROUTINE ACTIVE?
	POPJ P,		;ALREADY THERE, DON'T HAVE TO START IT UP
	MOVEI A,MSMAXB	;MAXIMUM # BUFFERS
	CAMGE A,MSNBUF(W)
	POPJ P,		;ALREADY HAVE LOTS OF BUFFERS, DON'T HAVE TO START UP ROUTINE NOW
	PUSHJ P,MTIECK	;MAYBE TAKE IO CHANNEL ERROR
	PUSH P,B
	MOVEI A,@MTBFS(W)	;GET MAXIMUM RECORD SIZE
	MOVEI B,MGREAD
	PUSHJ P,MTCMDA	;START UP INTERRUPT ROUTINE AT MGREAD
	MOVSI A,10	;"READ COMMAND IN COMMAND BUFFER" BIT IN MSMODE
	XORM A,MSMODE(W)	;SET BIT IN MSMODE; BUT IF MGREAD ALREADY ALIVE, CLEAR IT INSTEAD
	JRST POPBJ

		;PUSHJ P,MTRSTP	;TELL READ ROUTINE TO STOP AT END OF CURRENT RECORD

MTRSTP:	CONO PI,MTCOFF
	MOVSI T,30
	SKIPL MTBFS(W)	;SKIP IF WRITING
	TDNN T,MSMODE(W)	;CHECK READ ROUTINE ACTIVE BITS
	JRST MTCONJ	;NO READ ROUTINE
	MOVSI T,20000
	IORM T,MSMODE(W)	;TELL IT TO STOP
	JRST MTCONJ
;MAGTAPE READ ROUTINES 6

		;INTERRUPT LEVEL READ ROUTINE

MGREAD:	MOVEI C,MGS00	;READING
	MOVSM C,MGRSB(W)	;SAVE AS ROUTINE SPECIFICATION BITS FOR MSERCT
	TLZ U,4		;CLEAR OUT PI READ EOF BIT
	HRRI B,1	;SET UP OFFSET FOR BLKI POINTER
	MOVEM B,MGTMP2(W)	;STORE MAXIMUM RECORD SIZE,,1 FOR SETTING UP BLKI POINTERS
	TLC U,30	;SET "READ ROUTINE ACTIVE BIT"; CLEAR "READ COMMAND IN COMMAND BUFFER" BIT;
		; ^ BUT IF 10 BIT NOT YET SET AT MTRCHK, SET IT INSTEAD SO MTRCHK WILL CLEAR IT
	MOVEI A,MGRDDN	;TRAP TO MGRDDN ON ATTEMPTED EXIT
	PUSHJ P,MGUFST
	SKIPE MGBUFP(W)	;HAVE BUFFER?
	JRST 4,MGRD1	;YES, IT WAS SUPPOSED TO BE FLUSHED BY MGRDDN LAST TIME
	PUSHJ P,MMBRQ	;TRY GETTING BUFFER
	JRST MGF	;NO CORE, DIE
	PUSHJ P,MGRSET	;SET UP BUFFER VARIABLES
MGRD1:	PUSHJ Q,MGALGN	;GET MTC, MAYBE POSITION TAPE
	IFE C1MXP,PUSHJ Q,MGDCGB	;GET DC
	DATAI MTC,A	;MAKE SURE DATA FLAG IS OFF
	MOVSI A,(BLKI MTC,)
	PUSHJ P,MGDCST	;SET UP DC
MGRD2:	TRNE C,4000	;LOOP POINT FOR NEXT RECORD, CHECK EOT FLAG
	JRST MGREOT	;END OF TAPE
	TLNE U,20000	;CHECK "NON-PANIC STOP" FLAG
	JRST MGF	;STOP
	MOVE A,MGBUFP(W)	;GET BUFFER POINTER
	SUB A,MGTMP2(W)	;CONVERT TO BLKI POINTER
	MOVEM A,MGDBP	;STORE BLKI POINTER
	MOVEM A,MGIDBP	;ALSO STORE INITIAL BLKI POINTER FOR POSSIBLE UNHANG ROUTINE
	DATAO MTC,	;MAKE SURE DATA FLAG OFF
	IFE C1MXP,CONO PI,PICON+DCCHNA	;ENABLE INTERRUPTS
	MOVEI C,2000+DCCHN		;READ COMMAND (TO MTC)
	PUSHJ Q,MGCMDX			;READ, WAIT FOR INTERRUPT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;MAKE SURE INTERRUPTS DISABLED
	DATAI MTC,A	;MAKE SURE DATA FLAG IS OFF
	TRNN C,440100	;CHECK ALL MTC INTERRUPT FLAGS (EXCEPT DATA, NEXT UNIT)
	JRST 4,.	;THIS ROUTINE GOT RUN WITHOUT MTC INTERRUPT
	TRNE C,470600	;CHECK XPT HUNG, ILLOP, PARITY ERROR, EOF, DATA LATE, BAD TAPE
	JRST MGRER0	;JUMP ON LOSSAGE (INCLUDING EOF)
	AOSL B,MGDBP	;GET NEXT LOCATION TO READ INTO, SKIP IF LESS THAN MAXIMUM REC SIZE READ
	TRNN C,1000	;CHECK RECORD LENGTH INCORRECT FLAG
	JRST MGRD3	;LOOKS OK
	JRST MGFC	;RECORD ON TAPE TOO LARGE
;MAGTAPE READ ROUTINES 7

MGRD3:	HRRZM B,MGBUFP(W)	;STORE NEW POINTER
	TLNE U,20000	;CHECK "STOP WHEN NEXT CONVENIENT" FLAG
	JRST MGF	;STOP
	SUB B,MGBUFO(W)	;GET # WORDS TRANSFERRED
	MOVSI B,-1(B)	;GET ONE LESS THAN # TRANSFERRED,,
	ADD B,MGTMP2(W)	;ADD RECORD SIZE,,
	TLNE B,-2000	;INTO NEXT BLOCK?
	JRST MGRD4	;YES, HAVE TO TRY GETTING NEW BUFFER
	SKIPN MSNBUF(W)	;MAIN PROGRAM HUNG WAITING FOR BUFFER?
	PUSHJ P,MMBRQ	;YES, CORE AVAILABLE?
	 JRST MGRREC	;USE OLD BLOCK: RECYCLE
	PUSHJ P,MGRPBK	;GIVE OLD BLOCK TO MAIN PROGRAM (DOESN'T CLOBBER A)
MGRRC1:	PUSHJ P,MGRSET	;SET UP VARIABLES FOR NEW BUFFER
MGRREC:	PUSHJ P,MGCFRE	;RECYCLE FOR NEXT RECORD, BUT FIRST SEE IF ANYONE WANTS ANYTHING
	JRST MGRD2	;NOBODY WANTS ANYTHING, SKIP ALLOCATION
	JRST MGRD1	;SOMEONE WANTS SOMETHING, START OVER

		;THIS BUFFER FULL

MGRD4:	PUSHJ P,MGRPBK	;GIVE TO MAIN PROGRAM
	MOVE A,MSNBUF(W)	;GET # BUFFERS
	CAIGE A,MSMAXB	;MAXIMUM # ALREADY?
	PUSHJ P,MMBRQ	;NO, TRY GETTING CORE
	JRST MGF	;TOO MANY OR NO CORE
	JRST MGRRC1	;GOT CORE, NOW USE IT

		;ERROR FLAG(S) SET AFTER READ (CONI MTS, IN C)

MGRER0:	TRNE C,470600#10000	;CHECK EVERYTHING EXCEPT EOF
	JRST MGRERR	;REAL READ ERROR
		;THINGS THE MANUAL DOESN'T TELL YOU:
		;ON NORMAL READ EOF, EXACTLY ONE DATA WORD (=170000,,) IS TRANSFERRED
MGREOT:	TLO U,4		;SIGNAL EOF AT INTERRUPT LEVEL
	MOVEI A,1	;EOF BIT
	DPB A,[MSEOFP,,@MGTMP1(W)]	;STORE EOF BIT
	PUSHJ P,MGRPBK	;OUTPUT BUFFER
	SOS MGTPOF(W)	;SIGNAL TO SPACE BACK INTO FILE
	JRST MGF	;ALL DONE, FREE DC, MTC AND RETURN

	;SET UP READ BUFFER VARIABLES (BLOCK # IN A)

MGRSET:	MOVEI TT,MUMGB		;MAGTAPE DESCRIPTOR FOR MEMORY ALLOCATION TABLE
	DPB TT,[MUR,,MEMBLT(A)]	;STORE IN TABLE
	MOVEI TT,0
	DPB TT,[MLO,,MEMBLT(A)]	;THIS LAST ACTIVE BUFFER NOW
	DPB TT,[MSEOFP,,MEMBLT(A)]	;THIS NOT YET EOF BUFFER
	SETZM MGBUFO(W)			;CLEAR OUT ORIGIN
	DPB A,[121000,,MGBUFO(W)]	;STORE NEW ORIGIN
	SETZM MGBUFP(W)			;CLEAR OUT GARBAGE IN POINTER WORD
	DPB A,[121000,,MGBUFP(W)]	;STORE ORIGIN
	ADDI A,MEMBLT		;RELOCATE TO POINT TO MEMBLT TABLE
	MOVEM A,MGTMP1(W)	;STORE FOR USE AS BYTE POINTER ADDRESSES
	POPJ P,
;MAGTAPE READ ROUTINES 8

		;TRAP TO HERE ON ATTEMPTED EXIT FROM READ ROUTINE

MGRDDN:	TLZ U,20020	;CLEAR OUT READ ROUTINE ACTIVE BIT IN MSMODE
	PUSHJ P,MGRPBK	;FLUSH BUFFER (GIVE TO MAIN PROGRAM), IF ANY
	JRST MGF	;RE-EXIT, THIS TIME FOR REAL

		;READ ERROR

MGRERR:	TRNE C,400	;DATA LATE?
	SKIPGE MGDBP	;BLKI POINTER COUNTED OUT?
	JRST .+2	;NOT BOTH
	JRST MGRER3	;BOTH => LOSE NOW
	MOVEI A,MGRER2	;SET UP DISPATCH TO MGRER2 ON ATTEMPTED EXIT
	PUSHJ P,MGUFSP
	PUSHJ Q,MGCERR	;NOT BOTH, SEE IF SHOULD RECYCLE
	POP Q,MGUFNL(W)	;"WIN", RESTORE MGUFNL
	TLNE U,20000	;CHECK STOP-READING FLAG
	JRST MGF	;STOP, NOT GIVING THIS RECORD TO MAIN PROGRAM
	JRST MGRREC	;RECYCLE

MGRER2:	POP Q,MGUFNL(W)	;HERE ON ATTEMPTED EXIT FROM MGRERR, RESTORE OLD MGUFNL
MGRER3:	AOS B,MGDBP	;INCREMENT POINTER
	HRRZM B,MGBUFP(W)
	PUSHJ P,MGRPBK	;GIVE BUFFER TO MAIN PROGRAM EVEN THOUGH ERROR
	JRST MGFC
;MAGTAPE READ ROUTINES 9

		;GIVE BUFFER TO MAIN PROGRAM (DOESN'T CLOBBER A)

MGRPBK:	SKIPN TT,MGBUFP(W)	;GET 1 + LAST TO OUTPUT
	POPJ P,			;NO BUFFER
	SUB TT,MGBUFO(W)	;SUBTRACT ORIGIN, CONVERT TO # TRANSFERRED
	SKIPGE TT
	JRST 4,.	;FEWER THAN 0 DATA WORDS READ
	LDB B,[121000,,MGBUFO(W)]	;GET BLOCK # OF BUFFER BEING OUTPUT
	LDB T,[MUR,,MEMBLT(B)]	;DEBUG CHECK: GET BLOCK TYPE
	CAIE T,MUMGB
	JRST 4,.	;TRYING TO GIVE MAIN PROGRAM BUFFER DON'T REALLY HAVE
	DPB TT,[MSMWC,,MEMBLT(B)]	;STORE WORD COUNT IN MEMBLT ENTRY
	AOS TT,MSNBUF(W)	;ANOTHER BUFFER,
	CAIG TT,1	;THE FIRST?
	JRST MGRPB2	;YES
	LDB TT,[1000,,U]	;GET BLOCK # LAST ON LIST
	DPB B,[MLO,,MEMBLT(TT)]	;STORE LINK, PUTTING NEW BUFFER ON LIST
MGRPBX:	DPB B,[1000,,U]	;THIS NOW LAST BUFFER ON LIST
	SETZM MGBUFP(W)	;NO LONGER HAVE BUFFER AT INTERRUPT LEVEL
	POPJ P,

MGRPB2:	DPB B,[341000,,MTBUFO(W)]	;THIS TO BE ONLY ENTRY ON LIST, STORE AS FIRST ENTRY
	JRST MGRPBX	;DROP BACK IN

		;FLUSH READ ROUTINE (IF ANY)

MTRDFS:	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
	MOVE J,MSMODE(W)	;GET MSMODE WHERE IT CAN BE CHECKED IN ONE INSTRUCTION
	TLNN J,30	;CHECK FOR READ ROUTINE ALIVE
	JRST MTCONJ	;NO READ ROUTINE TO FLUSH (LEAVE EOF BIT SET, IF SET)
	TLNE J,10	;READ COMMAND IN BUFFER?
	JRST MTRDF2	;YES, TURN IT INTO NO-OP
	SKIPN MSRPCL(W)	;READ ROUTINE REALLY THERE, SKIP IF QUIT ALREADY REQUESTED
	SETOM MSRPCL(W)	;REALLY THERE, TELL IT TO STOP
	PUSHJ P,MTRS4	;KILL IT (TURNS MTCCHN ON AND WAITS FOR DEATH)
MTRDF3:	MOVSI T,34	;GET READ BITS
	ANDCAM T,MSMODE(W)	;WIPE OUT SIGNS OF READ ROUTINE HAVING BEEN AROUND
	JRST MTCONJ	;(RE-RE-ENABLE INTERRUPTS BECAUSE MAYBE WENT TO MTRDF3 WITH MTCCHN OFF)

MTRDF2:	MOVEI A,(W)	;HERE TO EXTRACT READ COMMAND FROM COMMAND BUFFER
	IMULI A,MSLCTB	;GET INDEX OF RELEVANT COMMAND BUFFER
	ADD A,[444400,,MSCB0]	;CONVERT TO BYTE POINTER
MTRDF4:	ILDB T,A	;GET COMMAND WORD
	TLZ T,-1	;CLEAR OUT LEFT HALF
	CAIN T,MGRCV	;END OF BUFFER?
	JRST MTRDF3	;END OF BUFER
	CAIE T,MGREAD	;READ COMMAND?
	JRST MTRDF4	;NO, TRY NEXT ONE
	MOVEI T,MGCLCF	;REPLACE WITH NO-OP
	DPB T,A		;DEPOSIT BACK INTO BUFFER
	JRST MTRDF4	;LOOP FOR ENTIRE BUFFER, THIS MAY NOT BE "LIVE" READ COMMAND
;MAGTAPE SHARED READ/WRITE ROUTINES 1

		;DIRECTION REVERSING ROUTINES

		;SWITCH FROM OUTPUT TO INPUT

MTOIRV:	PUSH P,B	;SAVE B
	PUSHJ P,MTPBUF	;WRITE OUT CURRENT RECORD
	PUSHJ P,MTWT	;WAIT FOR IDLE
	SKIPE MSNBUF(W)	;CHECK TO SEE IF ALL BUFFERS GONE
	JRST 4,.	;NO
	MOVSI T,400000	;DIRECTION BIT IN MTBFS
	ANDCAM T,MTBFS(W)	;BUFFERS NOW INPUT BUFFERS
	JRST POPBJ

		;SWITCH FROM INPUT TO OUTPUT

MTIORV:	PUSH P,B	;SAVE B
	PUSHJ P,MTICL2	;FLUSH READ
	AND J,[4,,]	;MASK SAVED MSMODE TO EOF BIT
	IORM J,MSMODE(W)	;IOR IT BACK IN CASE PCLSR FROM .+1
	PUSHJ P,MTWT	;WAIT FOR IDLE
	MOVSI J,400000	;MAIN PROGRAM EOF BIT IN MSMODE
	ANDCAM J,MSMODE(W)
	IORM J,MTBFS(W)	;NOW SET OUTPUT BIT
	MOVSI B,3000	;"WRITING SINCE LAST EOF" BITS
	ANDCAM B,MSMODE(W)
	JRST POPBJ
;MAGTAPE WRITE ROUTINES 1

MTUAO:	JSP B,MTWRIT	;UNIT ASCII (CHARACTER) OUTPUT
	JRST CHRKT

MTUIO:	JSP B,MTWRIT	;UNIT IMAGE (WORD) OUTPUT
	JRST WRDKT

MTBO:	JSP B,MTWRIT	;BLOCK OUTPUT
	JRST BLKT

		;COMMON MAGTAPE WRITE ROUTINE

MTWRIT:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER FROM IOCHNM
	PUSHJ P,MTIECK	;TAKE IOC ERROR IF ANY PENDING
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTIORV	;REVERSE DIRECTION
	JSP B,(B)	;JRST BLKT\CHRKT\WRDKT
	 SETZ MTBUFP(W)	;LOCATION OF NEXT WORD
	 MTBUFC(W)	;COUNT REMAINING
	 MTWBFG		;ROUTINE TO GET NEW BUFFER (SKIPS)
	 MTWBFD		;ROUTINE TO DISCARD (WRITE OUT) BUFFER
	 @MTBFS(W)	;BUFFER SIZE (IMMEDIATE)
	 PUSHJ P,.+1	;WAIT FOR NEW BUFFER
	MOVEI TT,MSMAXB	;SET UP TT FOR COMPARISON
	CAMG TT,MSNBUF(T)	;IF NOT TOO MANY BUFFERS,
	SKIPGE MSERCT(T)	;OR IF TRANSPORT ROUTINE STOPPED,
	AOS (P)		;THEN SKIP OUT OF UFLS
	POPJ P,

		;DISCARD (WRITE OUT) OUTPUT BUFFER

MTWBFD:	PUSHJ P,MTPBUF	;OUTPUT BUFFER
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
MOVTWJ:	MOVE T,W	;INITIALIZE T FOR FLSINS
	POPJ P,
;MAGTAPE WRITE ROUTINES 2

		;WRITE OUT BUFFER (CLOBBERS T AND TT ONLY)
		;I.E. TERMINATE AND WRITE OUT CURRENT RECORD

MTPBUF:	SKIPL MTBFS(W)
	POPJ P,		;BUFFERS ARE READ BUFFERS
	PUSH P,A
	LDB A,[121000,,MTBUFO(W)]	;GET BLOCK NUMBER (IT STAYS IN A FOR AWHILE)
	JUMPE A,POPAJ	;ALREADY WRITTEN OUT (MAYBE GOT PCLSR'ED FROM BLKT)
	PUSH P,B
	SKIPGE B,MTBUFP(W)	;GET POINTER
	JRST MTPBF3		;CHAR MODE WITH BUFFER EMPTY
	MOVE TT,[EOFWRD]	;CHARACTER MODE => MAYBE DEPOSIT GARBAGE IN LAST WORD
	LDB T,[360600,,B]	;GET POSITION FIELD OF BUFFER POINTER
	DPB T,[301400,,B]	;STORE AS SIZE FIELD, SET POSITION FIELD TO ZERO
	TLNE B,7700	;DON'T DO DPB ON 0 SIZE FIELD SINCE MAY GET PAGE FAULT
	DPB TT,B	;STORE APPROPRIATE NUMBER OF BITS (NON-CHAR MODE => NONE)
	TLZE B,-1	;CLEAR OUT BYTE POINTER, IF ANY
	AOJ B,		;YES, INCREMENT TO POINT TO WORD AFTER LAST ACTIVE IN BUFFER
	SUBI B,@MTBUFO(W)	;CONVERT TO # WORDS ACTIVE IN BUFFER
	JUMPLE B,MTPBF3		;JUMP IF NOTHING THERE
	DPB B,[MSMWC,,MEMBLT(A)]	;STORE WORD COUNT
	MOVSI B,1000
	IORM B,MSMODE(W)	;WRITING HAS OCCURRED SINCE LAST EOF WRITTEN (PCLSR OK)
	MOVEI B,MGWRIT	;NOW SET UP POINTER TO INTERRUPT ROUTINE
	PUSHJ P,MTCMDA	;GIVE COMMAND TO INTERRUPT ROUTINE (A HAS BLOCK #)
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN,
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT IN BUFFER
	JRST POPBAJ

MTPBF3:	PUSHJ P,MTBUFD	;WRITING OUT NULL RECORD, JUST DISCARD IT
	JRST POPBAJ	;EXIT FOR NO BUFFER THERE (SHOULDN'T HAPPEN BUT DON'T CARE IF IT DOES)
	CONO PI,MTCON	;EXIT FOR BUFFER REALLY GOT FLUSHED, TURN MTC BACK ON
	JRST POPBAJ

		;MAGTAPE WRITING, GET NEW BUFFER

MTWBFG:	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	PUSHJ P,MTOXCT	;TURN OFF MTCCHN
	PUSHJ P,MMBRQ	;TRY GETTING CORE BLOCK
	 JRST UDELAY	;NO CORE
	DPB A,[121000,,MTBUFO(W)]	;NEW BUFFER ORIGIN
	MOVEI T,MUMGB	;MAGTAPE BUFFER DESCRIPTOR BYTE
	DPB T,[MUR,,MEMBLT(A)]	;TELL WORLD THIS PAGE IS MAGTAPE BUFFER
	MOVE TT,MTBUFO(W)	;GET ORIGIN IN TT FOR CALLING ROUTINE
	AOS MSNBUF(W)	;ANOTHER BUFFER, INCREMENT COUNT
	JRST POPJ1	;SKIP-RETURN
;MAGTAPE WRITE ROUTINES 3

		;WRITING MAGTAPE: INTERRUPT ROUTINE

MGWRIT:	MOVSI C,MGS01	;WRITING
	MOVEM C,MGRSB(W)	;SAVE AS ROUTINE SPECIFICATION BITS FOR MSERCT
	TLZ U,4		;CLEAR OUT PI READ EOF BIT
	HLRZ A,B	;RETRIEVE ARGUMENT (BLOCK # OF BUFFER)
	SKIPE MGBUFP(W)
	JRST 4,.-1	;PI WRITE ROUTINE GOT STARTED UP WHEN PI WRITE BUFFER LEFT OVER FROM LAST TIME
	DPB A,[121000,,MGBUFP(W)]	;SET UP POINTER
	LDB T,[210200,,U]	;GET WRITE COMMAND INDEX
	JUMPE T,[JRST 4,.]	;SHOULDN'T BE WRITING WITHOUT WRITE COMMAND
	MOVE C,MGCMDT(T)	;GET COMMAND TO MTC
	MOVEM C,MGTMP2(W)	;COMMAND TO MTC (FOR MTCMDX) FOR WRITING
	ADDI A,MEMBLT	;RELOCATE TO POINT TO MEMBLT TABLE ENTRY
	MOVEM A,MGTMP1(W)	;MGTMP1 POINTER TO ENTRY IN MEMBLT TABLE
MGW1:	PUSHJ Q,MGALGN	;GOBBLE MTC AND MAYBE POSITION TAPE
	IFE C1MXP,PUSHJ Q,MGDCGB	;GET DC
	MOVSI A,(BLKO MTC,)
	PUSHJ P,MGDCST	;SET UP DC
MGW2:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGFC	;END OF TAPE => QUIT
	TLO U,2000	;SIGNAL WRITING AT INTERRUPT LEVEL SINCE LAST EOF
	LDB A,[MSMWC,,@MGTMP1(W)]	;GET WORD COUNT
	MOVSI A,(A)	;A := WORD COUNT,,0
	SUB A,MGBUFP(W)	;A := WC-1,,-ADR
	SETCAM A,MGDBP	;MGDBP := -WC,,ADR-1	;STORE BLKO POINTER
	SETCAM A,MGIDBP	;ALSO INITIAL BLKO POINTER FOR POSSIBLE UNHANG ON READ/COMPARE
	DATAO MTC,	;MAKE SURE DATA FLAG OFF
	IFE C1MXP,CONO PI,PICON+DCCHNA	;TURN ON DCCHN
	MOVE C,MGTMP2(W)	;GET WRITE COMMAND
	PUSHJ Q,MGCMDX	;DO IT, WAIT FOR INTERRUPT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;MAKE SURE CHANNEL OFF
	TRNN C,440100	;CHECK INTERRUPT FLAGS
	JRST 4,.	;THIS ROUTINE GOT RUN WITHOUT VALID INTERRUPT FROM MTC
	DATAI MTC,A	;MAKE SURE DATA FLAG OFF
	TRNE C,463600	;CHECK XPT HUNG, ILLOP, PARITY ERROR, READ/CMP ERR,
		;,REC LENGTH INCORRECT, DATA LATE, BAD TAPE
	JRST MGWERR	;JUMP ON LOSSAGE
	PUSHJ P,MGWFRB	;FREE BUFFER
	JRST MGF	;ALL DONE, RELEASE DC AND MTC, RETURN
;MAGTAPE WRITE ROUTINES 4

		;FREE WRITE BUFFER, IF ANY (DOESN'T CLOBBER ACS)
		;CALL WITH MTCCHN OFF OR MTCCHN BREAK IN PROGRESS

MGWFRB:	PUSH P,A
	LDB A,[121000,,MGBUFP(W)]	;GET BLOCK #
	JUMPE A,POPAJ	;IGNORE ZERO (=> NO BUFFER)
	PUSH P,B
	LDB B,[MUR,,MEMBLT(A)]
	CAIE B,MUMGB
	JRST 4,.
	PUSHJ P,IMEMR	;FREE BLOCK
	SETZM MGBUFP(W)	;NO LONGER HAVE BLOCK
	SOS MSNBUF(W)	;ONE LESS BUFFER
	JRST POPBAJ

		;TABLE OF "WRITE" COMMANDS WITH FIRST ENTRY EXTRANEOUS

MGCMDT:	2000+DCCHN	;READ
	3000+DCCHN	;READ/COMPARE
	4000+DCCHN	;WRITE
	14000+DCCHN	;WRITE WITH LONG EOR GAP

		;WRITE ERROR

MGWERR:	TRNE C,3000	;CHECK READ/COMPARE ERROR, RECORD LENGTH INCORRECT
	JRST MGFC	;READ/COMPARE LOSSAGE, STORE CONI AND QUIT
	MOVE A,MSERCT(W)	;WANT TO TRY RECYCLING,
	MOVE B,MGCMDT+3	;GET WRITE W/ LONG EOR GAP COMMAND IN  B
	CAIG A,MGMAXE-2	;IF THIS WILL BE AT LEAST THE THIRD TRY,
	TLNN U,1	;AND IF NOT READ/COMPARING,
	JRST .+2
	MOVEM B,MGTMP2(W)	;REPLACE WRITE CMD WITH WRITE W/ LONG EOR GAP
	PUSHJ Q,MGCERR	;DECIPHER ERROR, COUNT DOWN
	PUSHJ P,MGCFRE	;TRY RECYCLING, BUT FIRST MAYBE FREE MTC
	JRST MGW2	;NOBODY WANTED IT, LOOP
	JRST MGW1	;SOMEBODY WANTED IT, GET IT BACK AND LOOP
;MAGTAPE WRITE ROUTINES 5

		;WRITE EOF IF APPROPRIATE EXCEPT 1.1(A) => DO IT ANYWAY
		;1.2(A) => WRITE ONLY ONE MARK
		;2.9(A) => BACKSPACE BACK OVER MARKS WRITTEN
		;CLOBBERS B, SETS J TO 4,, IF EOF WRITTEN, OTHERWISE CLEARS J


MTWEOF:	TDZA A,A	;NORMAL ENTRY TO LEAVE TAPE ALONE AFTER EOF WRITTEN
MTWEFB:	MOVEI A,400000	;ENTRY TO STAY IN CURRENT FILE
MTWEFA:	PUSHJ P,MTIECK	;ENTRY FOR ARG ALREADY IN A, MAYBE TAKE IO CHANNEL ERROR
	MOVEI J,0
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	JRST MTWEF5	;BUFFERS ARE READ BUFFERS
	MOVSI B,1000
	SKIPN T,MTBUFO(W)	;GET MAIN PROG WRITE BUFFER ORIGIN, SKIP UNLESS NONE THESE
	JRST MTWEF4		;NO MAIN PROGRAM BUFFERS
	CAMGE T,MTBUFP(W)	;COMPARE WITH POINTER (THIS EVEN WORKS IN CHAR MODE)
	IORM B,MSMODE(W)	;BUFFER NON-EMPTY
MTWEF4:	TDNN B,MSMODE(W)	;CHECK TO SEE IF ANY OUTPUT SINCE LAST EOF
MTWEF5:	TRNE A,1	;DO IT ANYWAY?
	TLOA J,4	;DO IT
	POPJ P,		;NO WRITING SINCE LAST EOF
	PUSH P,A	;SAVE ARG SET UP AT ENTRY
	PUSHJ P,MTICL2	;FLUSH READ ROUTINE AND BUFFERS, IF ANY
	SKIPE MTBUFO(W)	;SKIP IF NO MAIN PROGRAM BUFFER
	SKIPL MTBFS(W)	;SKIP UNLESS BUFFER IS READ BUFFER
	JRST MTWEF2	;READ BUFFER OR NOT REALLY THERE
MTWEF3:	PUSHJ P,MTPBUF	;WRITE BUFFER REALLY THERE, OUTPUT BUFFER
MTWEF2:	POP P,A		;ARG TO MGWEOF
	MOVEI B,MGWEOF
	PUSHJ P,MTCMDA	;START UP INTERRUPT LEVEL ROUTINE AT MGWEOF
	MOVSI B,1000	;GET OUTPUT SINCE EOF BIT IN B AGAIN
	ANDCAM B,MSMODE(W)	;TURN IT OFF
	POPJ P,		;RETURN
;MAGTAPE WRITE ROUTINES 6

		;INTERRUPT LEVEL ROUTINE TO WRITE EOF
		;TAKES ARG, SET UP BY MTWEOF AND FRIENDS

MGWEOF:	MOVSI A,MGS11	;NON-TRANSACTION OPERATION, WRITING ON TAPE
	MOVEM A,MGRSB(W)	;STORE AS ROUTINE SPECIFICATION BITS
	TLZ U,4		;CLEAR OUT PI READ EOF BIT
	SKIPGE A,MGTPOF(W)	;CHECK POSITION OFFSET
	JRST MGWEF7	;NEGATIVE, MAYBE CAN SAVE TIME
	PUSHJ Q,MGALGN	;NOT NEGATIVE, GOBBLE MTC, MAYBE POSITION TAPE
	TLNN U,1	;CHECK FOR NO WRITING ON TAPE (=> READ/COMPARE MODE)
	JRST MGVEF1	;READ/COMPARE => VERIFY
	PUSHJ Q,MGMTC5	;WRITE EOF MARK
	SKIPGE B,@MGCMBP(W)
	SOS MGTPOF(W)	;WANT TO BACKSPACE BACK TO FILE
	TLNE B,2
	JRST MGWEF2	;WRITING ONLY ONE MARK => DONE
	SKIPLE MSCMDC(W)
	JRST MGWEF5	;MORE COMMANDS IN COMMAND BUFFER
	PUSHJ P,MGMTCF	;GIVE UP MTC
MGWEF1:	SKIPG MSCMDC(W)	;SKIP IF MORE COMMANDS IN COMMAND BUFFER
	PUSHJ Q,MGWTUH	;WAIT AWHILE EXCEPT ALLOW UNHANG AT MTCMD
	JSP D,MGWEF6	;DIDN'T SKIP => UNHUNG AT MTCMD
	PUSHJ Q,MGMTCG	;GET MTC BACK
MGWEF4:	PUSHJ Q,MGMTC5	;WRITE SECOND EOF MARK
MGEOT3:	SOSA MGTPOF(W)	;SIGNAL TO SPACE BACK OVER SECOND ONE
MGMT5A:	POP Q,A		;HERE FROM MGMTC5 ON EOT, POP OFF PC FROM PDL
MGWEF2:	PUSHJ P,MGMTCF	;GIVE UP MTC FOR LAST TIME
MGWEFX:	TLZ U,2000	;NO PI WRITING SINCE LAST EOF
	JRST MGF
;MAGTAPE WRITE ROUTINES 7

MGWEF5:	MOVEI D,MGWEF4	;ENTRY FOR STILL HAVE MTC
MGWEF6:	PUSHJ P,MGPEEK	;LOOK AT NEXT COMMAND IN COMMAND BUFFER
	TLZ B,-1	;NOT INTERESTED IN LEFT HALF
	CAIE B,MGWEOF
	CAIN B,MGWRIT
	JRST MGF	;WRITE COMMAND NEXT => GO SEND IT ON ITS WAY
	JRST (D)	;GO SOMEWHERE

		;MGWEOF WITH MGTPOF NEGATIVE (AND IN A)

MGWEF7:	TLNN B,400000	;IF NOT SUPPOSED TO BACKSPACE,
	AOS MGTPOF(W)	;THEN "SKIP OVER" FIRST ONE THERE
	TLNN U,1
	JRST MGWEFX	;READ COMPARE => DONE
	TLNN B,2	;IF WRITING 2 EOF MARKS,
	AOJE A,MGWEF1	;AND MGTPOF WAS -1 THEN GO WRITE SECOND MARK
	JRST MGWEFX	;SOMETHING ELSE, JUST EXIT

MGVEF1:	TRNE C,4000	;READ/COMPARE EOF
	JRST MGWEF2	;EOT, LET VERIFY WIN
	MOVE C,[MGCXIG,,12000]	;READ ACROSS RECORD BOUNDARIED
	PUSHJ Q,MGMTCT
	TRO C,2000	;SET R/C ERROR IN CASE GOING TO DIE
	TRNN C,10000	;CHECK EOF BIT
	JRST MGFC	;NOT SET => ERROR
	SKIPGE @MGCMBP(W)
	SOS MGTPOF(W)	;"BACKSPACE" OVER EOF MARK
	JRST MGWEF2

		;GIVE RANDOM COMMAND TO MTC, PROCESS ERRORS

MGMTC5:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGMT5A	;SET => FINISH JOB
	MOVEI C,5000	;ENTRY TO WRITE EOF
MGMTCT:	PUSH Q,C	;SAVE COMMAND
MGMTT1:	PUSHJ Q,MGCMDX	;DO IT, WAIT FOR INTERRUPT
	TRNN C,460200	;CHECK XPT HUNG, ILLOP, PARITY ERROR, BAD TAPE
	JRST QPOP1J	;RETURN ON NO LOSSAGE
	PUSHJ Q,MGCERR	;DECIPHER ERROR
	PUSHJ Q,MGMFGT	;MAYBE GIVE UP MTC FOR AWHILE
	MOVE C,(Q)	;GOT IT BACK, NOW RETRIEVE COMMAND
	JRST MGMTT1	;LOOP BACK AND TRY AGAIN
;MAGTAPE MTIECK/.RESET 1

		;PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
		;LEAVES ACS ALONE, UNLESS TAKING IOC ERROR (OF COURSE)
		;OR UNLESS NOT ALLOWED TO TAKE ONE (ONLY HAPPENS ON CLOSE),
			;E.G. WHEN LOGGING OUT.

MTIEC0:	MOVE T,MSERCT(W)	;VERSION TO DO .RESET IF NORMALLY WOULD RESTART ROUTINE
	AOJE T,MTRS1	;(CLOBBERS ACS) JUMP FOR .RESET
MTIECK:	PCLT
	PUSH P,T
	SKIPL T,MSERCT(W)	;SKIP IF INTERRUPT ROUTINE STOPPED
	JRST POPTJ	;NOT STOPPED, RETURN
	SETOM MSERCT(W)	;CLEAR OUT ERROR INDICATION BUT LEAVE ROUTINE STOPPED
	SKIPLE MSRPCL(W)	;CHECK QUIT FLAG
	JRST POPTJ	;DOING .RESET OR SOMETHING; DON'T DO ANYTHING MORE
	AOJN T,MTICK3	;JUMP IF SHOULD TAKE IOC ERROR
	CONO PI,MTCOFF
	SKIPGE MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MGWFRB	;OUTPUT; DISCARD THE ONE ON INTERRUPT LEVEL IF ANY
	SETZM MSERCT(W)	;THIS SECOND TIME HERE, "RESTART" ROUTINE
	SETZM MSRPCL(W)	;KILL QUIT FLAG
	POP P,T		;RESTORE T
	SKIPGE MSCMDC(W)	;IF NO COMMANDS IN COMMAND BUFFER,
	JRST MTCONJ	;THEN JUST RETURN
	JRST MTCMAT	;INCREMENT MSCMDT AND RETURN

MTICK3:	SUBI T,1	;DECREMENT BACK TO ERROR CONI
	MOVEM T,MTERC(W)	;STORE LAST ERROR CONI MAIN PROGRAM LEVEL FOR .STATUS OR SOMETHING
	SKIPGE MTCLSF(W)	;CHECK "NO IOCERR ALLOWED" FLAG (.LOGOUT OR SOMETHING)
	JRST MTRSP	;SET => DO .RESET, RESET PDL POINTER, ERROR RETURN
	TRNE T,440000	;CHECK XPT HUNG, ILLOP
	JRST IOCER1	;ILLEGAL DEVICE OPERATION ATTEMPTED AT INTERRUPT LEVEL
	TRNE T,23600	;CHECK PARITY ERROR, R/C ERR, LENGTH INCORRECT,
		;DATA LATE, BAD TAPE
	JRST IOCER3	;ANY OF THESE => NON-RECOVERABLE DATA ERROR
	SKIPGE MTBFS(W)	;SKIP IF READING
	TRNN T,4000	;CHECK END OF TAPE FLAG
	JRST IOCER3	;CAN'T FIND ANYTHING WRONG, SAY DATA ERROR
	JRST IOCER9	;EOT => DEVICE FULL
;MAGTAPE MTIECK/.RESET 2

		;MAGTAPE .RESET (DOESN'T CLOBBER H OR I)

MTRSP:	SKIPA P,MTCLSF(W)	;ENTRY FROM MTIECK TO RESTORE P FOR ERROR RETURN
MAGTRS:	LDB W,[MTXP (R)]	;MAGTAPE .RESET ROUTINE
MTRS1:	PUSH P,H
	PUSH P,I
	HRRZM P,MSRPCL(W)	;SET QUIT FLAG POSITIVE => STOP AND DON'T RESTART
	PUSHJ P,STMSET	;CAUSE IT TO BE SETOM'ED ON PCLSR (STOP, PROCEED)
	 MSRPCL(W)	;INDEXING OK
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTICL2	;INPUT => KILL READ ROUTINE, FLUSH BUFFERS
	PUSHJ P,MTRS4	;FLUSH INTERRUPT ROUTINE
	SKIPGE MTBFS(W)	;CHECK DIRECTION AGAIN
	PUSHJ P,MTRSO2	;OUTPUT => FREE OUTPUT BUFFERS
	MOVSI T,4	;EOF ON READ BIT
	ANDCAM T,MSMODE(W)
	MOVE B,MGCMBP(W)	;GET INTERRUPT LEVEL POINTER TO COMMAND BUFFER
	SKIPL C,MSCMDC(W)	;GET # COMMANDS IN BUFFER - 1, SKIP IF NONE
	JRST MTRS3	;PROCESS BUFFER (RETURNS TO MTRS5)
MTRS5:	MOVEI A,(W)	;GET XPT NUMBER IN A
	IMULI A,MSLCTB	;CONVERT TO INDEX INTO COMMAND BUFFER/QDL AREA
	SUBM B,A	;GET MSCB0+DISTANCE INTO BUFFER
	HRLI B,-<MSCB0+MSCBL>(A)	;SET UP LEFT HALF OF AOBJN POINTER
	EXCH B,MTCMBP(W)	;STORE NEW POINTER
	SETOM MSCMDC(W)	;RE-INITIALIZE COUNT IN BUFFER
	CAME B,MTCMBP(W)	;CHECK TO SEE IF LOSSAGE JUST FIXED
	JRST 4,.+1	;POINTERS TO MTAPE COMMAND BUFFER (XPT # IN W) WERE OUT OF PHASE
	SETZM MGTPOF(W)	;CLEAR OUT POSITIONING OFFSET
	SETZM MSRPCL(W)	;CLEAR OUT QUIT REQUEST
	PUSHJ P,MTLOTT	;DON'T CLEAR OUT STOP CONDITION IF NOT ALLOWED TO TAKE IOC ERROR
	JRST .+2	;NOT ALLOWED
	SETZM MSERCT(W)	;CLEAR OUT STOP CONDITION
	POP P,I
	POP P,H
	JRST LSWDEL	;FLUSH SETOM MSRPCL(W) ON PCLSR CONDITION AND RETURN
;MAGTAPE MTIECK/.RESET 3

		;.RESET, EMPTY COMMAND BUFFER

MTRS2:	SUBI B,MSCBL+1	;LOOP POINT TO RING BUFFER
MTRS3:	ILDB A,B	;GET COMMAND (ENTRY; DO JRST MTRS4 WHEN DONE)
	HRRZ T,A	;GET RIGHT HALF (DISPATCH) IN T
	CAIN T,MGRCV	;RING BUFFER?
	JRST MTRS2	;YES (DON'T SOJ C,)
	CAIN T,MGWRIT	;WRITE COMMAND?
	JRST MTORS3	;YES, LH HAS BUFFER TO FLUSH
		;^ MAYBE INSERT OTHER CONDITIONS HERE ^
MTRSRT:	SOJGE C,MTRS3	;RETURN POINT FOR CLOBBERAGE CONDITIONS, LOOP IF NOT DONE (DON'T CHANGE TO SOJG)
	MOVEM B,MGCMBP(W)	;STORE BACK UPDATED POINTER
	JRST MTRS5	;RETURN TO MAIN ROUTINE

MTORS3:	LDB A,[221000,,A]	;MGWRIT COMMAND IN BUFFER, GET BLOCK # IN A
	LDB T,[MUR,,MEMBLT(A)]
	CAIE T,MUMGB
	JRST 4,.	;BUFFER POINTER FOR WRITE COMMAND DOESN'T POINT TO MAGTAPE BUFFER
	PUSHJ P,MEMR
	SOS MSNBUF(W)	;ONE LESS BUFFER
	JRST MTRSRT	;GO BACK TO LOOP

MTRSO2:	MOVE T,MSMODE(W)
	TLNN T,2000	;INTERRUPT LEVEL WRITING SINCE LAST EOF?
	TLZE T,1000	;NOT SET, CLEAR CORRESPONDING BIT TO MAIN PROGRAM
	MOVEM T,MSMODE(W)	;STORE NEW MSMODE
	PUSHJ P,MTBUFD	;FLUSH MAIN PROGRAM WRITE BUFFER, IF ANY
	CONO PI,MTCOFF	;DIDN'T SKIP => MTCCHN ON, TURN IT OFF
	SETZM MTBUFC(W)	;CLEAR OUT MAIN PROGRAM BUFFER COUNT
	PUSHJ P,MGWFRB	;FREE INTERRUPT LEVEL WRITE BUFFER IF ANY
	JRST MTCONJ
;MAGTAPE MTIECK/.RESET 4

	;ROUTINE FOR .RESET (FROM MTRS1), MTIOL1,  AND MTRDFS TO FLUSH ACTIVE PI ROUTINE THIS XPT
	;SHOULD BE CALLED WITH MSRPCL(W) NON-ZERO
	;IF IT GETS INTO AN INFINITE LOOP HERE (WITH THE MTCCHN OFF),
	  ;ONE OF THE FOLLOWING SHOULD BE TRUE:
	  ;(1) MTRS4 WAS CALLED FROM A ROUTINE THAT DIDN'T BOTHER MAKING
	  ;    MSRPCL(W) NON-ZERO FIRST; IT SHOULD HAVE; CHECK MSRPCL(W)
	  ;(2) MSRPCL WAS OK, BUT THE TRANSPORT ROUTINE DIDN'T NOTICE IT;
	  ;    THE TRANSPORT ROUTINE WAS SUPPOSED TO CHECK IT AND DIE IF NON-ZERO
	;CHECK MTIOL1 BEFORE PUTTING IN ANYTHING THAT MIGHT HANG (BESIDES MTRS4X)

MTRS4:	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
MTRS4B:	SKIPL MSCMDC(W)	;SKIP IF NO MORE COMMANDS LEFT
	SKIPGE MSERCT(W)	;SKIP UNLESS STOPPED
	JRST MTCONJ	;ALREADY DEAD SOMEHOW
	SKIPN C,MGFLL(W)	;NOT DEAD, PICK UP BLOCKING CONDITION
	JRST 4,.	;PI XPT ROUTINE SEEN AS RUNNABLE FROM MAIN PROGRAM
	MOVSI TT,4000
	ANDCAM TT,MSMODE(W)	;CLEAR OUT "OK TO UNHANG" BIT IN MSMODE
	HLRZ T,C	;GET ADR OF INITIAL LIST ENTRY THIS BLOCKING CONDITION
	CAIN T,MGMTCX
	JRST MTRS4X	;WAITING FOR HARDWARE TO INTERRUPT
		; ^ MAYBE INSERT OTHER SPECIAL CHECKS HERE
	PUSHJ P,MGRLST	;ENTRY DOESN'T LOOK SPECIAL, FORCEFULLY REMOVE IT
	AOSN MSCMDT	;ANOTHER RUNNABLE ROUTINE
	CONO PI,PICIRQ+MTCHNA	;RUN ROUTINE, SHOULD DIE
	JRST MTRS4B	;BACK TO SEE IF IT DID

MTRS4X:	PUSHJ P,MGCXUH	;ROUTINE IS WAITING FOR HARDWARE TO INTERRUPT; SATISY IT
	CONO PI,MTCON	;LET IT INTERRUPT
	PCLT
	MOVE T,W
	PUSHJ P,MTWTW	;WAIT FOR IDLE
	PUSHJ P,UFLS
	POPJ P,
;MAGTAPE MAIN PROGRAM LEVEL SUBROUTINES 1

;PUSHJ P,MTCMD	;GIVE COMMAND TO INTERRUPT ROUTINE
	;RH(W) HAS TRANSPORT NUMBER
	;RH(B) HAS ADR OF INTERRUPT ROUTINE TO GO TO
	;LH(B) WILL BE SAVED IN LH OF COMMAND ENTRY
	;CLOBBERS T, TT, AND MTCMDA => B ONLY
	;DON'T CALL WHEN MSRPCL(W) IS NON-ZERO

MTCMD1:	AOSA (P)	;ENTRY TO SKIP-RETURN
MTCMDA:	HRL B,A		;ENTRY FOR HALFWORD ARG IN RH(A) (CLOBBERS B)
MTCMD:	PCLT
	MOVEI T,MSCBL-1	;GET BUFFER COMMAND CAPACITY
	SKIPGE MSERCT(W)	;SKIP UNLESS STOPPED
	CAMLE T,MSCMDC(W)	;SKIP IF BUFFER FULL
	JRST .+2	;ROOM IN BUFFER OR NOT STOPPED
	JRST 4,.-3	;XPT ROUTINE GOT STOPPED WITHOUT DYING, THAT'S NOT CRICKET
		;OR (MORE LIKELY) CALL TO MTCMD NOT PRECEDED BY CALL TO MTIECK
	CAMG T,MSCMDC(W)	;WAIT FOR ROOM FOR COMMAND
	PUSHJ P,UFLS
MTCMD5:	;SKIPE MSRPCL(W)
	;JRST 4,.-1	;SOMEONE (LOOK AT PDL (ON P, THAT IS)) CALLED MTCMD WITH MSRPCL NON-ZERO
	CONO PI,MTCOFF	;INHIBIT INTERRUPTS
	MOVE T,MTCMBP(W)	;GET POINTER
	AOBJN T,.+2	;INCREMENT POINTER, SKIP UNLESS AT END OF BUFFER
	SUB T,[MSCBL,,MSCBL]	;END OF BUFFER, RING IT
	MOVEM B,(T)	;STORE NEW COMMAND
	MOVEM T,MTCMBP(W)	;STORE BACK UPDATED POINTER
	AOS MSCMDC(W)	;ANOTHER COMMAND
	MOVSI TT,4000
	TDNE TT,MSMODE(W)	;UNHANG ROUTINE WAITING FOR SLOW CLOCK BREAK?
	JRST MTCMD2	;YES
MTCMAT:	SKIPN MSCMDC(W)	;SKIP UNLESS THIS IS FIRST COMMAND
MTCMT2:	SKIPE MGFLL(W)	;FIRST COMMAND, SKIP IF NOT BLOCKED
	JRST MTCONJ	;XPT ROUTINE BLOCKED OR SOMETHING
	SKIPGE MSERCT(W)	;CHECK FOR XPT ROUTINE DEAD
	JRST MTCONJ	;DEAD ON ERROR OR SOMETHING
	AOSN MSCMDT	;ANOTHER RUNNABLE TRANSPORT ROUTINE: THE FIRST?
	CONO PI,PICIRQ+MTCHNA	;YES, ACTIVATE INTERRUPT
	JRST MTCONJ	;THAT'S ALL

MTCMD2:
MTRDF1:	ANDCAM TT,MSMODE(W)	;UNHANG ROUTINE WAITING FOR SLOW CLOCK BREAK
	PUSHJ P,MGRLST	;REMOVE IT FROM ITS BLOCKING CONDITION LIST
	JRST MTCMT2

		;RANDOM MTCCHN HACKING ROUTINES

MTOXCT:	CONO PI,MTCOFF	;EXECUTE .+1 WITH MTCCHN OFF (CALLED WITH PUSHJ P,)
	XCT @(P)	;EXECUTE IT
	JRST MTCOJ1	;DIDN'T SKIP
	AOS (P)		;SKIPPED, INCREMENT OVER ARG
MTCOJ1:	AOS (P)		;TURN ON MTCCHN AND SKIP-RETURN
MTCONJ:	CONO PI,MTCON	;TURN ON MTCCHN AND RETURN
	POPJ P,
;MAGTAPE MAIN PROGRAM LEVEL SUBROUTINES 2

		;LIKE MTCMD BUT DON'T DO IT IF COMMAND BUFFER NON-EMPTY AND LAST COMMAND THERE
		;HAS SAME RH
		;NOTE THAT THIS DOESN'T ACTUALLY PREVENT MULTIPLE CALLING, BUT MERELY
		;PREVENTS THE COMMAND BUFFER FROM FILLING UP WITH IT

MTCMDP:	SKIPGE MSCMDC(W)	;SKIP UNLESS COMMAND BUFFER EMPTY
		; ^ DON'T BOTHER TURNING OFF MTCCHN, THIS IS HEURISTIC AND DOESN'T REALLY CARE
	JRST MTCMD	;EMPTY, JUST PUT NEW COMMAND THERE
	MOVE T,MTCMBP(W)	;GET POINTER TO LAST
	HRRZ T,(T)	;GET RH OF LAST COMMAND
	CAIE T,(D)	;THE SAME?
	JRST MTCMD	;NO, PUT THE NEW ONE THERE
	POPJ P,		;DIFFERENT, THAT'S ALL

		;LIKE MTCMD BUT DON'T PCLT
		;CALL ONLY WHEN THERE'S CERTAIN TO BE ROOM

IFN MTDBSW,[
MTCMDN:	MOVEI T,MSCBL
	CAMG T,MSCMDC(W)
	JRST 4,.-1
	JRST MTCMD5
]IFE MTDBSW,MTCMDN=MTCMD5

		;WAIT FOR INTERRUPT ROUTINE TO BECOME IDLE

MTWWT:	PUSHJ P,MTALGN	;ENTRY TO ALIGN TAPE
MTWT:	PUSHJ P,MTIECK	;MAYBE TAKE I/O CHANNEL ERROR NOW
	MOVE T,W	;GET XPT NUMBER INTO T FOR FLSINS
	PUSHJ P,MTWTW	;FLUSH INSTRUCTION
	PUSHJ P,UFLS
	JRST MTIECK	;MAYBE TAKE IOC ERROR, IF NOT THEN RETURN

		;FLUSH INSTRUCTION FOR ABOVE

MTWTW:	SKIPL MSERCT(T)	;IF STOPPED,
	SKIPGE MSCMDC(T)	;OR IF NO MORE COMMANDS IN BUFFER,
	AOS (P)		;THEN CAUSE RETURN TO SKIP
	POPJ P,

		;LIKE MTWT BUT SKIPS UNLESS PCLSR, DOESN'T TAKE IOC ERROR

MTWTP:	PUSHJ P,FINSET	;SET UP DISPATCH ON PCLSR
	 CPOPJ
	PCLT
	MOVE T,W	;SET UP T FOR FLSINS
	PUSHJ P,MTWTW	;WAIT FOR IDLE
	PUSHJ P,UFLS
	PUSHJ P,LSWDEL	;DELETE PCLSR DISPATCH
	JRST POPJ1	;SKIP-RETURN

		;"MAIN PROGRAM ROUTINE" TO POSITION TAPE UNTIL MGTPOF = 0

MTALGN:	JSP B,MTCMDP	;MAIN PROG ENTRY
MGBLGN:	SKIPE MGTPOF(W)	;DON'T BOTHER WAITING FOR REWIND TO FINISH
	PUSHJ Q,MGALGN
	JRST MGF
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 1

	;CALLED WITH PUSHJ Q, UNLESS OTHERWISE INDICATED
	;MAY EXIT WITHOUT RETURNING EXCEPT AS OTHERWISE INDICATED

		;ROUTINE TO GOBBLE MTC AND POSITION TAPE UNTIL MGTPOF = 0
		;THIS IS THE ROUTINE NORMALLY USED TO GOBBLE THE MTC

MGALGN:	PUSHJ Q,MGMTCG	;"MAIN" ENTRY, GOBBLE MTC AND POSITION TAPE
MGALG2:	SKIPN A,MGTPOF(W)
	POPJ Q,		;NOTHING TO DO
	JUMPL A,MGALRV	;BACKSPACE
	TRNE C,4000	;EOT?
	JRST MGALGT	;EOT
	MOVEI C,16000	;SPACE FORWARD TO EOF
	SOS MGTPOF(W)	;DECREMENT MGTPOF IN ANTICIPATION OF SUCCESS (CHOKE!)
MGALR2:	PUSHJ Q,MGSPAC	;DO THE APPROPRIATE SPACING OPERATION
	PUSHJ Q,MGMFGT	;WIN, MAYBE GIVE UP MTC FOR AWHILE
	JRST MGALG2

MGALRV:	TRNE C,100000	;REVERSE
	JRST MGALGT	;BOT
	MOVEI C,17000	;SPACE REVERSE TO EOF
	AOS MGTPOF(W)
	JRST MGALR2

MGALGT:	SETZM MGTPOF(W)	;TAPE WON'T SPACE ANY FURTHER THAT WAY
	POPJ Q,
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 2

		;GIVE COMMAND (IN C) TO XPORT THEN WAIT FOR INTERRUPT
		;ALLOCATE MTC, IF NOT ALREADY ALLOCATED TO THIS XPT
		;ON RETURN, C HAS CONI MTS,

MGCMDX:	MOVEM C,MSCCNO(W)	;STORE AS LAST CONO TO MTC
	TLNN C,-1	;CHECK LH OF COMMAND
	HRLI C,MGCXUH	;ADR OF ROUTINE TO UNHANG (DURING SLOW CLOCK BREAK)
	CAME W,MGMTCU
	JRST MGCX2	;DON'T HAVE MTC, GET IT
MGCX3:	XCT MGCMD(W)	;NOW EXECUTE THE COMMAND (STILL DON'T CLOBBER C)
	HRRI C,400	;NO-OP, NEXT UNIT ENABLE
	MOVEI A,@MGCMD(W)	;CALCULATE UNBLOCKING CONO
	HRRM A,MGHNGC	;STORE UNBLOCKING CONO FOR UNHANG ROUTINE OR MTRS4
	HLRZM C,MGHNGD	;STORE UNHANG DISPATCH (ADR OF ROUTINE)
MGCX1:	MOVE A,TIME
	MOVEM A,MGXTIM	;STORE TIME OF COMMAND
	MOVEI B,MGMTCX	;SET UP ENTRY IN LIST,
	JRST MGBLST	;AND WAIT FOR COMPLETION

MGCX2:	PUSH Q,C	;DON'T HAVE MTC AT MGCMDX; GET IT
	PUSHJ Q,MGMTCG	;GET IT
	POP Q,C
	JRST MGCX3	;BACK TO EXECUTE COMMAND

		;STANDARD ROUTINE TO UNHANG RECALCITRANT MTC DURING SLOW CLOCK BREAK
		;SEE ALSO MGCIXG NEAR BEGINNING OF MAGTAPE ROUTINES

MGCXUH:	PI2SAF		;HALT IF MTCCHN ENABLED AND NOT PI IN PROGRESS
	XCT MGHNGC	;DO THE APPROPRIATE CONO (NO-OP, NEXT UNIT ENABLE)
	SETOM MGHNGD	;SET FLAG
	POPJ P,
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 3

		;PUSHJ Q,MGMTCG	;GOBBLE MTC AND SELECT XPORT, WAIT FOR IDLE
		;TO FREE MTC, PUSHJ P,MGMTCF
		;BUT NOTE: MTC GOBBLED AUTOMATICALLY MY MGCMDX AND MGALGN
		;MGALGN IS NORMALLY USED INSTEAD OF DIRECT CALL TO MGMTCG

;MGMTCL:	SKIPA A,[MGMLLC]	;POSSIBLE FUTURE LOW PRIORITY VERSION
		;TO SPEED UP DATA TRANSFERS OF SMALL BLOCKS WITH MORE THAN ONE TRANSPORT ACTIVE
MGMTCG:	MOVEI A,MGMALC	;NORMAL ENTRY, MGMALC IS ALLOCATION ROUTINE
	HRLM A,(Q)	;SAVE ALLOCATION ROUTINE ADR ON QDL
	CAMN W,MGMTCU
	POPJ Q,		;ALREADY HAVE MTC, DON'T RE-GET IT
MGMTC3:	SKIPE MSRPCL(W)	;CHECK TO SEE IF MAIN PROGRAM WANTS QUIT
	JRST MGCLCF	;YES
	HLRZ A,(Q)	;GET BACK ADR OF ALLOCATION ROUTINE
	PUSHJ Q,(A)	;ALLOCATE MTC
	HRRZM W,MGMTCU	;NEW TRANSPORT USER
	MOVEI C,400	;NO-OP, NEXT UNIT ENABLE
	PUSHJ Q,MGCMDX	;CONO, WAIT FOR INTERRUPT
	TRNN C,440000	;CHECK XPT HUNG, ILLOP (?)
	SKIPE MSRPCL(W)	;CHECK QUIT FLAG
	JRST MGF4C	;XPT SCREWED OR MAIN PROG WANTS QUIT
	TRNN C,200000	;CHECKING REWIND FLAG
	POPJ Q,		;NOT REWINDING
	PUSHJ P,MGMTCF	;FREE MTC FOR NOW
	MOVEI B,MGCKL1
	PUSHJ Q,MGBLST	;WAIT FOR NEXT SLOW CLOCK TICK
	JRST MGMTC3	;GO TRY AGAIN

		;ALLOCATE MTC

MGMALC:	SKIPN MGMTCW	;SKIP IF WANTED
	CONSZ MTC,70	;SKIP IF FREE
	JRST .+2	;ALREADY WANTED OR NOT FREE, WAIT FOR IT
	POPJ Q,
	MOVEI B,MGMTCW	;MTC ALREADY WANTED OR NOT FREE
	JRST MGALST	;WAIT FOR AVAILABLE THEN RETURN TO MGMTCG
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 4

		;PUSHJ Q,MGGIDL	;GET MTC AND WAIT FOR IDLE

MGGIDL:	MOVEI A,6	;2.5 - 3 SECONDS
	MOVEM A,MGTMP1(W)	;SAVE FOR COUNTDOWN
MGGID2:	PUSHJ Q,MGMTCG	;GET MTC
	SKIPE MSRPCL(W)	;CHECK QUIT FLAG
	JRST MGFD	;MAIN PROGRAM WANTS QUIT
	TRNE C,40	;CHECK IDLE FLAG
	POPJ Q,		;SET => WIN
	PUSHJ P,MGMTCF	;LOSE, FREE MTC
	TRO C,400000	;SET XPT HUNG IN CASE AHOUT TO DIE
	SOSG MGTMP1(W)	;DECREMENT COUNTDOWN
	JRST MGFC	;WAITED TOO LONG, LOSE
	MOVEI B,MGCKL1	;HAVEN'T WAITED TIME OUT YET
	PUSHJ Q,MGBLST	;WAIT A HALF-SECOND
	JRST MGGID2	;BACK TO TRY AGAIN

		;MAYBE FREE MTC FOR AWHILE (SKIPS IF SUCCESSFUL, IF NOT THEN LIKE MGMTCG)

MGMFGT:	SKIPE MSRPCL(W)	;MAIN PROGRAM WANT QUIT?
	JRST MGFD	;MAIN PROGRAM WANTS QUIT; RELEASE MTC AND NON-SKIP RETURN
	SKIPN MGMTCW	;SKIP IF WANTED
	POPJ Q,		;NOBODY WANTS IT
	PUSHJ P,MGMTCF	;WANTED, FREE IT
	JRST MGMTCG	;GET IT BACK

		;PUSHJ P,MGMTCF	;FREE THE MTC
		;(FOR ALLOCATION ROUTINE, SEE MGMTCG)

MGMTCF:	CAME W,MGMTCU	;FREE THE MTC, CALLED WITH PUSHJ P,
	JRST 4,.	;DIDN'T HAVE IT TO FREE
	CONI MTS,MSSCNI(W)	;GET MTS CONI FOR .STATUS AND FRIENDS
	CONO MTC,0	;FREE IT
	SETOM MGMTCU	;NO CURRENT MTC USER ANYMORE
	POPJ P,
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 5

		;IFE C1MXP,PUSHJ Q,MGDCGB
		;GOBBLE DCCHN, RE-CONI MTS,C IF WAITING WAS NECESSARY
		;TO FREE THE DC, DO IFE C1MXP,PUSHJ P,MGDCF
		;CALL ONLY WHEN ALREADY HAVE MTC

IFE C1MXP,[
MGDCGB:	SKIPN MGDCW	;SKIP IF ANOTHER XPORT ROUTINE WANTE IT
	SKIPGE DCWANT	;SKIP UNLESS UTAPE ROUTINES WANT IT
	JRST MGDCG2	;SOMEONE WANTS IT, ADD SELF TO LIST AND WAIT
	AOSE DCFREE	;NOBODY ELSE WANTS IT, TRY GOBBLING IT
	JRST MGDCG2	;NOT FREE, WAIT FOR IT
	;CONO DC,0	;GOT IT, NOW ENSURE THAT SPASTIC UTAPE ROUTINES DON'T GENERATE EXTRANEOUS TRANFER
	POPJ Q,		;WIN, RETURN NOW
MGDCG2:	MOVEI C,0	;NO-OP
	XCT MGCMD(W)	;CAUSE MTC NOT TO INTERRUPT
	MOVEI B,MGDCW	;LOSE, GET POINTER
	JRST MGALST	;ADD SELF TO WAITING LIST AND WAIT
]

		;IFE C1MXP,PUSHJ P,MGDCF	;FREE THE DC

IFE C1MXP,[
MGDCF:	CAME W,MGDCU
	JRST 4,.	;DON'T HAVE IT
	SETOM MGDCU
	SETOM DCFREE	;RELEASE IT
	POPJ P,
]

		;CHECK FOR PEOPLE WANTING DC AND MTC

MGCFRE:	IFE C1MXP,SKIPL DCWANT
	SKIPE MGMTCW
	JRST MGFRE1	;SOMEONE WANTS DC
	SKIPN MGMTCW	;ANYONE WANT MTC?
	SKIPE MSRPCL(W)	;NO, MAIN PROG WANT QUIT?
MGFRE1:	AOSA (P)	;SOMEBODY WANTS SOMETHING, CAUSE RETURN TO SKIP, AND FREE WORLD
	POPJ P,		;NOBODY WANTS ANYTHING
MGFREE:	IFE C1MXP,PUSHJ P,MGDCF	;FREE DC
	JRST MGMTCF	;FREE MTC AND RETURN
;MAGTAPE VARIOUS INTERRUPT LEVEL SUBROUTINES 6

		;INTERRUPT ROUTINE TO WAIT FOR SECOND SLOW CLOCK BREAK BUT ALLOW MTCMD TO UNHANG
		;SKIPS UNLESS MTCMD DID ITS THING

MGWTUH:	MOVEI B,MGCKL2	;INITIAL LIST ENTRY TO UNHANG ON SECOND SLOW CLOCK BREAK
	TLO U,4000	;SIGNAL TO MTCMD THAT IT'S OK TO UNHANG
	PUSHJ Q,MGBLST	;WAIT FOR UNHANGING
	TLZE U,4000	;SKIP IF ABORTED FROM MTCMD, CAUSE RETURN NOT TO SKIP
QPOPJ1:	AOS (Q)		;NOT ABORTED, CAUSE RETURN TO SKIP
QPOPJ:	POPJ Q,

QPOP1J:	SUB Q,[1,,1]
	POPJ Q,

	;PUSHJ P,MGPEEK	;LOOK AT NEXT ENTRY IN COMMAND BUFFER (GET INTO B)

MGPEEK:	SKIPA T,MGCMBP(W)	;LOOK AT NEXT ENTRY IN COMMAND BUFFER, CALL WITH PUSHJ P,
MGPEK1:	SUBI T,MSCBL+1	;LOOP POINT TO RING THE BUFFER
	ILDB B,T	;GET BUFFER ENTRY
	CAIN B,MGRCV	;END OF BUFFER?
	JRST MGPEK1	;END OF BUFFER, LOOP BACK TO BEGINNING
	POPJ P,

	;PUSHJ P,MGUFSP OR MGUFST	;SET UP TRAP ON ATTEMPTED EXIT
	;ROUTINE ADR IN A

MGUFSP:	PUSH Q,MGUFNL(W)	;ENTRY TO SAVE OLD CONDITION
MGUFST:	HRL A,Q		;ENTRY TO IGNORE OLD, SET UP VALUE
	MOVEM A,MGUFNL(W)
	POPJ P,
;MAGTAPE VARIOUS INTERRUPT LEVEL RUBROUTINES 7

		;SPACE (COMMAND IN C)(SHOULD SPECIFY DATA PIA=MTCCHN OR 0)

MGSPAC:	HRLI C,MGCXIG	;DON'T UNHANG IF SEEMS TO BE TAKING TOO LONG
	PUSHJ Q,MGCMDX	;GIVE COMMAND TO MTC, WAIT FOR INTERRUPT
	TRNN C,1	;CHECK DATA RQ
	JRST MGSPC2	;NOT SET, SKIP FOLLOWING
	DATAO MTC,	;FEED IT A RANDOM WORD
	CONO MTS,1	;NOW STOP IT
	CONI MTS,C	;GET CONI TO SEE IF ALREADY STOPPED
	IOR C,MGRSB(W)	;IOR IN ROUTINE SPECIFICATION BITS
	TRNN C,440100	;CHECK XPT HUNG, ILLOP, JOB DONE
	PUSHJ Q,MGCX1	;NOT SET, WAIT AGAIN FOR INTERRUPT
MGSPC2:	TRNE C,440000	;CHECK XPT HUNG, ILLOP
	JRST MGFC	;SET => DIE
	POPJ Q,		;OK

		;CHECK TO SEE IF TOO MANY ERRORS HAVE HAPPENED, OR IF ERROR IS NON-RECOVERABLE
		;CALLED FROM MGWERR AND MGRERR

MGCERR:	TRNE C,440000	;CHECK TRANSPORT HUNG, ILLOP
	JRST MGFC	;FATAL IMMEDIATELY (NO COUNTDOWN)
	AOS MSTERC(W)	;ANOTHER ERROR, INCREMENT TOTAL ERROR COUNT
	TRNE C,200	;CHECK BAD TAPE
	POPJ Q,		;ALLOW ARBITRARY NUMBER OF BAD TAPE ERRORS,
		;EVEN THOUGH MAY FLICK PI IN PROGRESS DOING THEM
		;BUT NOTE: DON'T WANT TO BACKSPACE OVER BAD TAPE ERROR
	SOSG MSERCT(W)	;NON-FATAL AND NOT BAD TAPE, DECREMENT COUNTDOWN
	JRST MGFC	;TOO MANY => FATAL ANYWAY
	TRNE C,100000	;CHECK BOT
	POPJ Q,		;DON'T TRY BACKSPACING FROM BEGINNING OF TAPE
	MOVEI C,7000	;SPACE REVERSE COMMAND
	JRST MGSPAC
;MAGTAPE DATA AREA 1

MGIQDP:	REPEAT TNMTCS,-MGQDLL,,CONC MGQD,\.RPCNT,-1	;INITIAL QDL QOINTER FOR INTERRUPT ROUTINE

EBLK

REPEAT TNMTCS,[
CONC MSCB,\.RPCNT,:	BLOCK MSCBL	;COMMAND BUFFER THIS XPT
	MGRCV		;ENTRY TO RING THE BUFFER

	JRST 4,.	;BOTTOM ENTRY OF QDL, GETTING HERE => OVER-POPJ
		; ^ RESTART AT MGFD AND HOPE FOR THE BEST
CONC MGQD,\.RPCNT,:	MGNCMD		;QDL THIS XPT, THIS ENTRY INITIAL PI PC
		BLOCK MGQDLL-1		;REST OF QDL

IFE .RPCNT,MSLCTB==.-MSCB0	;LENGTH OF EACH TABLE (FOR CALCULATING INDICES)
]

MTCMBP:	REPEAT TNMTCS,-MSCBL-1,,CONC MSCB,\.RPCNT,-1	;INPUT POINTER TO COMMAND BUFFER
MGCMBP:	REPEAT TNMTCS,4400,,CONC MSCB,\.RPCNT,-1	;OUTPUT POINTER FROM " "
MGQDLP:	REPEAT TNMTCS,-MGQDLL+1,,CONC MGQD,\.RPCNT,	;QDL QOINTER FOR INTERRUPT ROUTINE
MSCMDC:	REPEAT TNMTCS,-1	;1 LESS THAN # COMMANDS PUT INTO BUFFER BUT NOT COMPLETED
MSCMDT:	-1		;1 LESS THAN TOTAL # RUNNABLE XPORT ROUTINES
		;AN XPORT ROUTINE IS "RUNNABLE" IF ITS CMD BUF ISN'T EMPTY AND ROUTINE NOT HUNG

	;EACH POSSIBLE BLOCKING CONDITION HAS A LIST OF XPORT ROUTINES HUNG ON THAT CONDITION
	;RH (EACH LIST ENTRY) HAS ADR OF NEXT ENTRY OR 0 => THIS LAST ENTRY
	;LH ADR OF INITIAL ENTRY
	;LIST ENTRIES CLEARED OUT WHEN NOT ACTUALLY ON LIST

IFE C1MXP,MGDCW:	0	;INITIAL LIST ENTRY FOR XPORTS WANTING DC
MGMTCW:	0	;INITIAL LIST ENTRY FOR XPORTS WANTING MTC
MGMTCX:	0	;INITIAL LIST ENTRY XPORT WAITING FOR MTC/MTS TO INTERRUPT
MGCKL1:	0	;UNHANG XPT NEXT SLOW CLOCK BREAK
MGCKL2:	0	;" " SECOND " " "
	;^ ADD OTHER INITIAL LIST ENTRIES HERE ^
	;*NOTE* XPTS ARE REMOVED FROM LISTS AT MTRS4
	  ;SPECIAL EFFECTS FOR MGMTCX
	  ;IF PUTTING IN NEW INITIAL LIST ENTRIES, MAYBE SPECIAL CHECK WANTS TO BE MADE
MGFLL:	REPEAT TNMTCS,0	;TRANSPORT ROUTINE HANG LIST ENTRIES

MSRPCL:	BLOCK NMTCS	;NON-ZERO => MAIN PROG TRYING TO STOP THIS XPT ROUTINE
		; ^ DIFFERENT EFFECTS .GT. 0 VS .LT. 0, SEE MTIECK
MGUFNL:	BLOCK NMTCS	;LIKE UFINAL USED TO BE IN OLD SYSTEMS
		; ^ NON-ZERO => RH ADR OF ROUTINE TO GO TO ON ATTEMPTED EXIT (MGF, ETC.)
		;LH RH OF Q TO SET UP BEFORE DISPATCH
MGRSB:	BLOCK NMTCS	;ROUTINE SPECIFICATION BITS THIS XPT
;MAGTAPE DATA AREA 2

MTUSR:	REPEAT NMTCS,-1	;USER OF THIS MAGTAPE UNIT
MTUSE:	REPEAT NMTCS,-1	;1 LESS THAN # TIMES THIS UNIT OPEN
MTCUSE:	-1		;1 LESS THAN # TRANSPORTS OPEN
IFN DSDP,MSUSE:	-1	;1 LESS THAN SUM OF # XPT ROUTINES ALIVE AND # XPTS OPEN
MTCLSF:	BLOCK NMTCS	;NEGATIVE => SIGNAL TO MTIECK FROM CLOSE ROUTINES
			;THAT I/O CHANNEL ERROR NOT ALLOWED, IN WHICH CASE CONTAINS PDL POINTER TO
			;POPJ ON AFTER DOING .RESET

MGCMD:	REPEAT NMTCS,CONO MTC,MTCRH+.RPCNT_15.(C)	;GIVE COMMAND TO MTC (RH HAS MODE STATUS)
				; ^ EXECUTED AT MGCMDX

MGTPOF:	BLOCK NMTCS	;# EOF CHARS PI ROUTINES SHOULD SPACE FORWARD PAST
		;TO GET TO WHERE TAPE SHOULD BE
		;A PI ROUTINE MAY EXIT WITH MGTPOF NON-ZERO IF THERE ARE
		;NO NON-NULL RECORDS (I.E. THERE ARE ONLY EOF MARKS) BETWEEN ACTUAL
		;AND DESIRED TAPE POSITIONS
MGLTIM:	BLOCK NMTCS	;TIME OF END OF LAST PI COMMAND
MGTMP1:	BLOCK NMTCS	;TEMP FOR INDIVIDUAL COMMAND AT INTERRUPT LEVEL
MGTMP2:	BLOCK NMTCS	;TEMP FOR INDIV. ETC., DATA TRANSFER => (SIGN => WRITE)
	;^ ADD OTHER TEMP VARS HERE ^

MTBUFO:	BLOCK NMTCS	;MAIN PGM ORIGIN OF BUFFER, 4.2-4.9 LINK TO NEXT BLOCK ON READ, 3.1-4.1 0
MTBUFP:	BLOCK NMTCS	;BYTE OR WORD POINTER INTO CURRENT BUFFER
MTBUFC:	BLOCK NMTCS	;COUNT REMAINING IN BUFFER
MTBSIZ:	BLOCK NMTCS	;READ => SIZE OF BUFFER
MSNBUF:	BLOCK NMTCS	;READ => NUMBER OF BUFFERS THIS TRANSPORT FILLED BUT NOT YET DISCARDED
MGBUFO:	BLOCK NMTCS	;INTERRUPT LEVEL ORIGIN OF BUFFER (CURRENTLY USED ONLY FOR READ)
MGBUFP:	BLOCK NMTCS	;INTERRUPT LEVEL POINTER TO BUFFER

MSSCNI:	BLOCK NMTCS	;CONI MTS, LAST TIME XPT ROUTINE RAN (AT MGXGO AND MGMTCF)
MSCCNO:	BLOCK NMTCS	;LAST CONO TO MTC (C(C) AT MGCMDX; DOESN'T INCLUDE MTCRH)
MTERC:	BLOCK NMTCS	;ERROR CONI MTC, OF CURRENT IOC ERROR OR 0
MSERCT:	BLOCK TNMTCS	;ERROR COUNT .LT. 0 => REST OF WORD CONI MTS,
MTBFS:	REPEAT NMTCS,100000,,MTDFRS	;MAIN PROGRAM LEVEL BUFFER STATUS + RANDOM
		;RH BLOCK LENGTH
		;LH 3.1-3.5 MUST BE ZERO
		;4.9 0 => BUFFERS ARE INPUT BUFFERS, 1 => OUTPUT

		;MTC ALLOCATION AND STATUS VARIABLES (SEE ALSO MGMTCW AND MGMTCX)

MGMTCU:	-1		;NON-NEGATIVE => XPT ROUTINE THAT HAS MTC
MGXTIM:	0		;TIME THAT COMMAND WAS LAST GIVEN TO MTC
MGHNGD:	JRST 4,.	;-1 => FORCEFULLY UNHUNG
			;ELSE NON-ZERO => ADR OF UNBLOCKING ROUTINE
			;UNBLOCKING ROUTINE RUNS DURING SLOW CLOCK BREAK
MGHNGC:	CONO MTC,	;(RH SET UP AT MGCMDX) INSTRUCTION TO FORCEFULLY UNHANG MTC
			;AS SEEN FROM SLOW CLOCK BREAK, MTC IS ACTIVE IFF
			;MGMTCX IS NON-ZERO
;MAGTAPE DATA AREA 3

MSMODE:	BLOCK NMTCS
		;ASSORTED SHARED (MAIN PROG/INTERRUPT LEVEL) INFO
		;IN U AT MTCCHN BREAK LEVEL, GETS STORED BACK AT DISMISS TIME
		  ;LOADED AND STORED AT MGXGO
		;1.1-1.8 PAGE # LAST REAL BUFFER ON LIST
		;2.1-2.4 # TIMES OPEN READING, 2.5-2.8 WRITING
		;2.9-3.1 WRITE COMMAND 1 R/C 2 WRITE 3 WRITE WITH LONG EOR GAP
		;3.2 EOT ON INTERRUPT LEVEL READ
		;3.3 EOF ON INTERRUPT LEVEL READ
		  ; ^ SIGNAL TO LAST READ .CLOSE TO SKIP OVER EOF
		;3.4 READ => READ COMMAND IN COMMAND BUFFER
		;3.5 READ => INTERRUPT ROUTINE ALIVE
		;3.6 CHAR. MODE INPUT, 3.7 CHAR. MODE OUTPUT
		;3.8 NON-CHAR MODE INPUT, 3.9 NON CHAR MODE OUTPUT
		;4.1 (MAIN PGM) WRITING HAS OCCURRED SINCE LAST EOF WRITTEN
		;4.2 (INTERRUPT LEVEL) " " "
		;4.3 ROUTINE WAITING FOR SLOW CLOCK BREAK SHOULD BE UNHUNG AT MTCMD
		;4.4 => 9 TRACK XPT, ELSE 7 TRACK (SET UP DURING .OPEN)
		;4.5 READ ROUTINE SHOULD DROP OUT THE NEXT TIME BETWEEN RECORDS
		;4.9 => EOF ON READ (SET AT MAIN PROGRAM LEVEL WHEN BUFFER EOF ENCOUNTERED)

MSXICT:	0		;NUMBER OF EXTRANEOUS MTC INTERRUPTS
MSTERC:	BLOCK NMTCS	;# DATA ERRORS THIS XPT (NOT CLEARED BY .CLOSE)
MSTCTI:	0		;NUMBER OF TIMES MSCMDT WAS WRONG AT MGSBRK (SOFTWARE ERROR)

IFE C1MXP,MGDCU:	-1	;-1 OR XPT # THAT HAS DCCHN

MGIDBP:	0		;DATA TRANSFER => INITIAL BLKO/BLKI POINTER
			;IN GENERAL, INFO FOR XPT-UNHANGING ROUTINE

MGDBP:	0		;BLKO/BLKI POINTER

MGDBK:	0		;MAGLOC+1:	JSR MGDBK
BBLK
	CONO MTS,1	;STOP TRANSPORT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;TURN OFF DC
	JRST 12,@MGDBK	;THAT'S ALL

	;PUSHJ P,MGDCST	;SET UP DATA TRANSFER (DC) VARIABLES

MGDCST:	HRRI A,MGDBP	;COMPLETE SETTING UP BLKO OR BLKI
	MOVEM A,MAGLOC	;STORE AS INTERRUPT INSTRUCTION
	MOVE A,[JSR MGDBK]
	MOVEM A,MAGLOC+1	;STORE INTERRUPT INSTRUCTION # 2
	POPJ P,
;MAGTAPE INTERRUPT DISMISS ROUTINES 1

;(ROUTINES WHICH DO THE ACTUAL PUSHJ Q,MGXSTP TO DISMISS THE INTERRUPT)

;VARIOUS MTAPE INTERRUPT ROUTINE DONE ROUTINES
;DONE WITH THIS INTERRUPT LEVEL COMMAND, MAYBE ALSO DO THINGS
;IF HAVE DCCHN, FREE IT; IF HAVE MTC, FREE IT;
;JRST MGF  => FINISHED, NORMAL EXIT
;JRST MGFD => ERROR EXIT, DIE SOMEHOW
	;IF MSERCT NOT ALREADY NEGATIVE, MAKE IT -1,
	;THUS KEEPING ROUTINES IN COMMAND BUFFER FROM BEING RUN
;JRST MGFC => STORE C IN MSERCT AS ERROR CONI THEN FALL INTO MGFD AND DIE
;JRST MGFE => UNCONDITIONALLY SETOM MSERCT, THUS DYING WITHOUT IOC ERROR

MGCLCF:	MOVEI C,0	;VERSION FOR C DOESN'T HAVE CONI MTS,
	JRST MGF

MGF4C:	TLO C,MGS40	;VERSION OF MGFC TO SET "INCIDENTAL COMMAND" BIT IN CONI
MGFC:	MOVEM C,MSERCT(W)	;CONI EXIT, STORE CONI MTS,
MGFD:	SKIPGE MSERCT(W)	;ERROR EXIT, SEE IF ALREADY DEAD
MGF:	SKIPE MSRPCL(W)	;NORMAL EXIT, CHECK TO SEE IF QUIT DESIRED (IF SO, DON'T TAKE IOC ERROR)
MGFE:	SETOM MSERCT(W)	;<DIE WITHOUT IOCERR> EXIT, DIE
	TLZE W,-1	;CLEAR OUT LH(W)
	JRST 4,.+1	;LH(W) GOT CLOBBERED
		; ^ WRITE DOWN CONTENTS OF Q, AND OF THE QDL (MGQD0 THROUGH NEXT TAG),
		;WRITE DOWN CONTENTS OF WORD ADDRESSED BY MGCMBP(W),
		;THEN PROCEED
IFE C1MXP,[CAMN W,MGDCU	;HAVE DCCHN?
	PUSHJ P,MGDCF	;YES, FREE IT
]	CAMN W,MGMTCU	;HAVE MTC?
	PUSHJ P,MGMTCF	;YES, FREE IT
	JUMPGE C,MGF2	;JUMP IF C DOESN'T HAVE CONI MTS,
	TRNE C,4000	;COPY EOT BIT INTO MSMODE
	TLOA U,2
	TLZ U,2
MGF2:	SKIPE A,MGUFNL(W)	;GET TRAP ROUTINE ADR, IF ANY
	JRST MGF3		;YES, GO TO TRAP HANDLING ROUTINE
	SKIPE MGFLL(W)	;SKIP UNLESS BLOCKED
	JRST 4,.-1	;MAGTAPE PI ROUTINE TRIED TO EXIT WHILE BLOCKED
	MOVE Q,MGIQDP(W)	;RE-INITIALIZE QDL QOINTER
	SOSL MSCMDC(W)		;ANOTHER COMMAND FINISHED THIS TRANSPORT
	SKIPGE MSERCT(W)	;STOP?
	SOSA MSCMDT	;ANOTHER NON-RUNNABLE TRANSPORT
	JRST MGF4
	MOVE A,TIME
	MOVEM A,MGLTIM(W)	;STORE TIME OF LAST OPERATION COMPLETION
MGF4:	IFN DSDP,[SOSGE MSUSE	;DECREMENT PI USE COUNT
	DATAO DSDEV,[DSMTC]	;DESELECT MAGTAPE
]	PUSHJ Q,MGXSTP		;DISMISS, WAIT FOR NEW COMMAND
		;DROPS THROUGH ON NEW COMMAND
;MAGTAPE INTERRUPT DISMISS ROUTINES 2

		;DROPS THROUGH FROM PREVIOUS PAGE ON NEW PI COMMAND

MGNCMD:	MOVEI A,MGMAXE		;(MGNCMD IS INITIAL PC) NOW TO GET NEW COMMAND
	MOVEM A,MSERCT(W)	;INITIALIZE ERROR COUNT FOR ROUTINE
	MOVSI A,MGS10		; => NON-DATA TRANSFER
	MOVEM A,MGRSB(W)	;STORE AS MOST COMMON MGRSB
	MOVEI C,0	;INITIALIZE C FOR ROUTINES THAT DON'T HACK WITH MTC
IFN DSDP,AOS MSUSE	;INCREMENT USE COUNT
MGNCM1:	ILDB B,MGCMBP(W)	;GET COMMAND IN B
	JRST (B)	;DISPATCH ON COMMAND (IF END OF COMMAND BUFFER THEN MGRCV)

MGRCV:	MOVNI A,MSCBL+1	;AT END OF COMMAND BUFFER,
	ADDM A,MGCMBP(W)	;RING THE BUFFER
	JRST MGNCM1	;GO BACK AND TRY AGAIN

MGF3:	SETZM MGUFNL(W)	;MGUFNL WAS NON ZERO, WANT TO TRAP TO ROUTINE
	HLRZ Q,A	;SET UP PDL POINTER FOR ROUTINE
	TLC Q,400000	;ASSUME THERE WON'T BE PDL OVERFLOW TROUBLE
	JRST (A)	;DISPATCH TO ROUTINE
;MAGTAPE INTERRUPT DISMISS ROUTINES 3

	;MOVEI B,<FIRST LIST ENTRY>
	;PUSHJ Q,MGALST	;ADD PRESENT MAGTAPE XPORT TO END OF RELEVANT COMMAND LIST,
		;WAIT FOR UNHANG

MGALST:	TRNE B,-1	;SKIP IF ENTRY BEING ADDED IS ZERO
	SKIPE MGFLL(W)	;SKIP UNLESS ALREADY BLOCKED
	JRST 4,.	;BAD ARGUMENT OR ALREADY BLOCKED
	SOS MSCMDT	;ONE FEWER ACTIVE XPORT ROUTINE
	MOVEI A,MGFLL(W)	;SET UP POINTER TO LIST ENTRY TO ADD
	HRLZM B,(A)	;STORE ADR OF INITIAL LIST ENTRY IN LH
	PUSHJ P,ALIST	;PUT ENTRY ON LIST
	JRST MGXSTP	;DISMISS

		;LIKE MGALST BUT ADD TO BEGINNING OF LIST

MGBLST:	TRNE B,-1
	SKIPE MGFLL(W)	;SKIP UNLESS ALREADY HUNG
	JRST 4,.
	SOS MSCMDT	;ONE FEWER ACTIVE XPORT ROUTINE
	MOVEI A,MGFLL(W)
	HRLZM B,(A)
	EXCH A,(B)
	HRRM A,@(B)
	JRST MGXSTP

	;PUSHJ P,MGRLST	;REMOVE XPT IN W FROM LIST (CALL ONLY IF KNOWN TO BE ON SOME LIST)
		;USUALLY CALLED FROM MAIN PROG, MTCCHN MUST BE OFF

MGRLST:	PUSH P,A	;CLOBBERS T AND TT
	MOVEI A,MGFLL(W)	;ADR OF ENTRY TO REMOVE
	HLRZ T,MGFLL(W)	;GET ADR OF INITIAL ENTRY
	SKIPE T		;SKIP IF NOT BLOCKED
	PUSHJ P,RLIST	;REMOVE IT
	 JRST 4,.	;MGRLST CALLED WHEN XPT BLOCKED, OR LIST STRUCTURE SCREWED
	SETZM MGFLL(W)	;CLEAR OUT ENTRY REMOVED
	POP P,A
	POPJ P,
;MAGTAPE INTERFACE TO UTCBRK 1

	;PUSHJ P,MGUHNG	;UNHANG (UNBLOCK AND RUN) BLOCKED XPORT ROUTINE
		;INITIAL LIST ENTRY ADR IN A
		;CALLED WHEN A POTENTIAL UNBLOCKING CONDITION HAS BEEN NOTICED

MGUHNG:	SKIPN W,(A)
	POPJ P,		;NOBODY HUNG ON THIS CONDITION
	MOVEI W,-MGFLL(W)	;CONVERT TO XPT NUMBER
	MOVEI T,0
	EXCH T,MGFLL(W)	;DESTRUCTIVELY GET XPT BLOCKING CONDITION (CLEARING IT OUT)
	HRRM T,(A)	;UPDATE LIST
	AOS MSCMDT	;ANOTHER ACTIVE XPORT ROUTINE
			;DROPS THROUGH
		;AT INTERRUPT LEVEL GO TO XPORT ROUTINE (# IN W)
		;CALLED WITH PUSHJ P,
		;RETURNS WHEN XPT ROUTINE BECOMES BLOCKED OR STOPPED

MGXGO:	IFN MGPDSW,CONI MGCNCI'	;GET CONI OF PROCESSOR, INTERESTED IN PDL OVERFLOW FLAG
	TLZ W,-1	;CLEAR OUT LH OF W, MUST BE ZERO
	MOVE Q,MGQDLP(W)	;GET QDL QOINTER
	MOVE U,MSMODE(W)	;SET UP MSMODE FOR TRXX AND TLXX INSTRUCTIONS
	PUSH P,MGXOVP	;SAVE OVER-POP TRAP
	POPJ Q,		;RETURN TO ROUTINE

		;WHEN PI ROUTINE WANTS TO DISMISS, IT SHOULD DO PUSHJ Q,MGXSTP
		;IT SHOULD DO IT VIA ONE OF THE INTERRUPT DISMISS ROUTINES

MGXSTP:	POP P,T		;WELL HERE WE ARE, POP OFF TOP ENTRY ON P PDL
	CAME T,MGXOVP	;MAKE SURE IT'S THE ONE PUSHED AT MGXGO
	JRST 4,.	;PI XPT ROUTINE SCREWED UP P PDL, POPJ P, AT .+N WAS ABOUT TO LOSE
	TLZE W,-1	;CHECK LH(W), SHOULD BE ZERO
	JRST 4,.+1	;NON-ZERO, CLEAR OUT LEFT HALVES OF MGMTCU AND (IF IT EXISTS) MGDCU;
		;AND START UP HERE
	CAMN W,MGMTCU	;SKIP UNLESS THIS XPT HAS MTC
	CONI MTS,MSSCNI(W)	;GET CONI MTC, FOR .STATUS AND FRIENDS
	MOVEM U,MSMODE(W)	;STORE BACK UPDATED MSMODE
	MOVEM Q,MGQDLP(W)	;STORE BACK UPDATED POINTER
IFE MGPDSW,POPJ P,
IFN MGPDSW,[MGXGO2:	CONSZ 200000	;CHECK PDL OVERFLOW
	JRST 4,MGXGO3	;PDL OVERFLOW, WRITE DOWN MGQD<C(W)> THROUGH NEXT TAG,
			;WRITE DOWN C(Q), PROCEDE, AND HOPE FOR THE BEST
	HRROI A,A
	MOVE T,MGCNCI	;GET SAVED CONI AT ENTRY TO MGXGO
	TLNE T,200000	;CHECK PDL OVERFLOW
	PUSH A,		;SET PDL OVERFLOW, MAY HAVE BEEN SET IN USER MODE
	POPJ P,

MGXGO3:	CONO 400000+APRCHN	;CLEAR PDL OVERFLOW
	JRST MGXGO2	;LOOP; IF INFINITE LOOP HERE, HARDWARE (PROCESSOR) IS LOSING
]

MGXOVP:	JRST 4,.	;OVER-POPJ P, BY PI ROUTINE
;MAGTAPE INTERFACE TO UTCBRK 2

;ENTRIES FROM UTCBRK: MGHBRK => MTC INTERRUPT, MGDBRK => DC AVAILABLE,
		; MGSBRK => BREAK TO RUN RUNNABLE XPORT ROUTINES

MGHBK2:	AOS MSXICT	;ANOTHER EXTRANEOUS MTC INTERRUPT
	CONO MTC,0	;MTC INTERRUPTING WHEN NOT WANTED, TRY TO FLUSH FLAGS
	CONI MTC,A	;GET CONI
IFN DSDP,JUMPGE A,UTCBK2	;GOT GOBBLED BY OTHER PROCESSOR, DON'T WORRY
	TRNN A,77	;ASSIGNED TO THIS PROCESSOR, SEE IF PIA SUCCESSFULLY FLUSHED
	JRST UTCBK2	;OK NOW, FALL BACK INTO INTERRUPT ROUTINE
	JRST 4,MGHBK2	;MTC INTERRUPTING BUT CAN'T CLEAR INTERRUPT DESPITE CONI OF SIGN BIT

		;MTC DEVICE INTERRUPT

MGHBRK:	SKIPN W,MGMTCX	;IF NOBODY WAS WAITING FOR THIS INTERRUPT,
	JRST MGHBK2	;THEN TRY FLUSHING INTERRUPT FLAG AND GO AWAY MAYBE
	IOR C,MGRSB-MGFLL(W)	;IOR IN ROUTINE SPECIFICATION BITS
	SKIPGE MGHNGD	;SKIP UNLESS JUST UNHUNG BY SLOW CLOCK OR MTRS4
	TRO C,400000	;JUST UNHUNG, SET XPT HUNG FLAG
	MOVEI A,MGMTCX	;POINTER TO XPORT WAITING FOR MTC INTERRUPT
	PUSHJ P,MGUHNG	;RUN HUNG ROUTINE
	CONSO MTC,77	;MTC FREE?
	SKIPN MGMTCW	;MTC WANTED?
	JRST MGRCHK	;NOT FREE OR NOT WANTED
MGMTCR:	MOVEI A,MGMTCW	;MTC WANTED AND FREE,
MGDBK2:	PUSHJ P,MGUHNG	;RUN HUNG ROUTINE
		;CHECK FOR RUNNABLE XPORT ROUTINES
MGRCHK:	SKIPL MSCMDT	;ANY RUNNABLE ROUTINES?
	JRST MGSBRK	;YES, GO RUN SOME, LOOP BACK TO MGRCHK
	CONSO MTC,77	;NO, CHECK MTC; FREE?
	SKIPN MGMTCW	;WANTED?
	IFE C1MXP,JRST MGEX7	;NOT FREE OR NOT WANTED, SO "EXIT"
	IFN C1MXP,JRST MGEX
	JRST MGMTCR	;FREE AND WANTED, GO RUN HUNG ROUTINE
;MAGTAPE INTERFACE TO UTCBRK 3

		;RUN RUNNABLE XPORT ROUTINES THEN GO TO MGRCHK

MGSBRK:	MOVEI W,TNMTCS-1	;INITIALIZE POINTER FOR COUNTDOWN
	MOVNI A,1	;PATCH TO REPLACE MSCMDT WITH THE RIGHT VALUE
MGSBK3:	SKIPL MSCMDC(W)	;PATCH
	SKIPE MGFLL(W)	;PATCH
	JRST MGSBK4	;PATCH
	SKIPL MSERCT(W)	;PATCH
	ADDI A,1	;PATCH, THIS ROUTINE IS RUNNABLE
MGSBK4:	SOJGE W,MGSBK3	;PATCH, LOOP FOR ALL XPTS
	CAME A,MSCMDT	;PATCH, COMPARE CALCULATED WITH MSCMDT
	AOS MSTCTI	;ANOTHER TIME MSCMDT WAS WRONG
	MOVEM A,MSCMDT	;STORE CORRECT MSCMDT
	JUMPL A,MGRCHK	;JUMP IF NOTHING REALLY THERE
	MOVEI W,TNMTCS-1	;END OF MSCMDT CALCULATING PATCH
MGSBK1:	SKIPL MSCMDC(W)	;SKIP IF XPORT INACTIVE
	SKIPE MGFLL(W)	;SKIP UNLESS UNIT HUNG
	JRST MGSBK2	;INACTIVE OR HUNG, TRY NEXT ONE
	SKIPL MSERCT(W)	;SKIP IF STOPPED
	PUSHJ P,MGXGO	;RUNNABLE, RUN IT
MGSBK2:	SOJGE W,MGSBK1	;LOOP FOR ALL UNITS
	JRST MGRCHK	;THAT'S ALL

IFE C1MXP,[
MGEX7:	SKIPGE DCWANT	;UTC ROUTINES WANT DC?
	SKIPL DCFREE	;DC FREE?
	JRST MGMTCK	;NOT WANTED OR NOT FREE
	JRST UTCB0	;WANTED AND FREE, GIVE IT AWAY
]
;MAGTAPE INTERFACE TO UTCBRK 4

		;MACRO (EXECUTED AT UTCBRK) TO CHECK FOR MTC DEVICE INTERRUPT

DEFINE MGBKCM
	CONI MTC,A	;GET MTC CONI FOR ASSIGNMENT, PIA, ETC.
	CONI MTS,C	;GET MTS CONI FOR FLAGS
	TRNN A,400	;IF NEXT UNIT NOT ENABLED,
	TRZ C,2		;THEN TURN OFF NEXT UNIT FLAG
IFE MTCCHN&#DCCHN,[
	TRNE A,7
	TRNN A,DCCHN&#MTCCHN
]	TRNE A,MTCCHN&#DCCHN	;SKIP UNLESS DATA PIA = MTCCHN
	TRNN C,1	;DATA PIA = MTCCHN, DATA FLAG SET?
	TRNE C,440102	;CHECK ALL OTHER FLAGS
IFN DSDP,JUMPL A,MGHBRK	;INTERRUPT FLAG(S) SET, JUMP IF ASSIGNED
IFE DSDP,JRST MGHBRK	;NO ASSIGNMENT, JUMP ALWAYS
TERMIN	;END OF MACRO, EXECUTED DURING UTCBRK

		;DC AVAILABLE

IFE C1MXP,[
MGDBRK:	SKIPE W,MGDCW	;GET XPT # + MGFLL
	AOSE DCFREE	;DC AVAILABLE, GOBBLE IT
	JRST 4,.	;NOT FREE OR NOT WANTED
	MOVEI W,-MGFLL(W)	;CONVERT TO TRANSPORT NUMBER
	HRRZM W,MGDCU	;SAY WHO HAS IT
	;CONO DC,0	;PREVENT EXTRANEOUS INTERRUPT FROM DATA CONTROL
	MOVEI A,MGDCW	;SET UP POINTER TO HUNG ROUTINE
	CONI MTS,C	;ALL DC BREAKS ALREADY HAVE MTC
	IOR C,MGRSB(W)	;IOR IN ROUTINE SPECIFICATION BITS
	JRST MGDBK2	;RUN HUNG ROUTINE, ETC.
]
;MAGTAPE SLOW CLOCK ROUTINE 1

		;SLOW CLOCK ROUTINE (CALLED WITH MTCCHN OFF)

MSMGC2:	AOS MSCMDT	;ANOTHER RUNNABLE XPT ROUTINE
	SKIPA A,B	;GET NEXT LIST ENTRY (LOOP POINT)
MSMAGC:	MOVEI A,MGCKL1	;ENTRY, SET UP POINTER TO INITIAL LIST ENTRY
	MOVE B,(A)	;GET NEXT LIST ENTRY
	SETZB A,(A)	;CLEAR OUT ENTRY
	TRNE B,-1	;SKIP IF LAST ONE
	JRST MSMGC2	;NO, LOOP BACK FOR NEXT
	EXCH A,MGCKL2	;CLEAR OUT AND GET FIRST ENTRY FOR NEXT TICK
	MOVEM A,MGCKL1	;STORE AS NEW INITIAL ENTRY
	JUMPE A,MSMGC3	;JUMP AROUND FOLLOWING IF LIST JUST MOVED WAS EMPTY
	MOVSI T,MGCKL1	;HAVE TO UPDATE LEFT HALVES OF LIST ENTRIES
	HLLM T,(A)	;UPDATE THIS ONE
	HRRZ A,(A)	;GET POINTER TO NEXT
	JUMPN A,.-2	;LOOP FOR THE LIST
MSMGC3:	MOVEI W,NMTCS-1	;NOW TO SEE IF ANY POSITIONING SHOULD BE DONE
MGDEM1:	MOVEI B,0
	SKIPE MGTPOF(W)
	MOVEI B,MGBLGN	;WANT TO SPACE IF EVERYTHING OK
		; ^ MAYBE INSERT OTHER THINGS HERE
	JUMPN B,MGDEM2	;JUMP IF WANT TO DO SOMETHING, RETURNS TO MGDEML
MGDEML:	SOJGE W,MGDEM1	;LOOP FOR ALL TRANSPORTS
	SKIPE MGMTCX	;SKIP IF NOBODY WAITING FOR HARDWARE INTERRUPT
	SKIPG MGHNGD	;SKIP IF UNHANG ROUTINE EXISTS
	JRST MGDEM3	;NO, SKIP FOLLOWING (UNHANG) CODING
	MOVE A,TIME	;GET TIME
	SUB A,MGXTIM	;CONVERT TO TIME SINCE COMMAND TO MTC
	CAIL A,75.	;SKIP UNLESS AT LEAST 2.5 SECONDS
	PUSHJ P,@MGHNGD	;RUN UNHANG ROUTINE (NORMALLY MGCXUH)
MGDEM3:	POPJ P,

MGDEM2:	SKIPL MSERCT(W)
	SKIPL MSCMDC(W)
	JRST MGDEML	;STOPPED OR ACTIVE
	SKIPE MGFLL(W)
	JRST MGDEML	;BLOCKED (THIS SHOULDN'T HAPPEN)
	MOVE A,MGLTIM(W)	;GET TIME OF LAST PI ROUTINE DONE
	ADDI A,30.	;DON'T DO ANYTHING IF LESS THAN A SECOND AGO
	CAMGE A,TIME
	SKIPE MSRPCL(W)
	JRST MGDEML	;LAST OPERATION LESS THAN A SECOND AGO OR MAIN PROGRAM WANTS STOP
		; ^ MAYBE INSERT OTHER THINGS TO KEEP FROM MUNGING ROUTINE
	MOVE T,MTCMBP(W)	;PASSES ALL TESTS, FEED IT COMMAND
	AOBJN T,.+2
	SUB T,[MSCBL,,MSCBL]
	MOVEM B,(T)	;STORE COMMAND IN BUFFER
	MOVEM T,MTCMBP(W)	;STORE BACK UPDATED COMMAND POINTER
	AOSE MSCMDC(W)
	JRST 4,.	;ROUTINE WAS SUPPOSED TO BE INACTIVE
	AOS MSCMDT
	JRST MGDEML

]		;END IFG NMTCS, CONDITIONAL

;PUSHJ P,ALIST
;B:	0,,-> LIST: 0,,-> CRUD,,-> ... LSTITEM: CRUD,,0

;CHANGE TO LSTITEM: CRUD,,C(A)
;IN OTHER WORDS, ADD AN ITEM TO THE END OF A LIST
;INTERRUPTS SHOULD BE SUPRESSED ENOUGH TO INSURE THAT
	;ITEMS ARE NOT SIMULTANEOUSLY BEING ADDED TO AND REMOVED
	;FROM THE LIST
;BUT NOTE: ALIST WINS (OR SHOULD, ANYWAY) IF MORE THAN ONE ITEM IS BEING ADDED TO THE LIST AT ONCE,
	;E.G. AT DIFFERENT INTERRUPT LEVELS

ALIST:	HLLZS (A)	;CLEAR OUT RH OF NEW ENTRY
	JRST ALIST2	;FALL INTO LOOP

ALIST1:	HRRZ B,(B)	;CAUSE B TO POINT TO NEXT ITEM ON LIST
	CAIN B,(A)	;COMPARE WITH A
	JRST 4,.	;TRIED TO PUT ITEM ONTO LIST TWICE
ALIST2:	MOVE TT,(B)	;GET NEXT LIST ENTRY
	TRNE TT,-1	;SKIP IF END OF LIST
	JRST ALIST1	;NOT END OF LIST, TRY AGAIN
		;AT THIS POINT:
		;C(A) - GARBAGE,,ADR OF POINTER TO ADD
		;C(B) = ADR OF WHAT SEEMS TO BE LAST ITEM ON LIST
		;C(TT) = CONTENTS OF WHAT " " "
	HLL A,TT	;SET UP LH OF WHAT WILL REPLACE CURRENT LAST ENTRY
	EXCH A,(B)	;PUT ITEM ON LIST
	CAME A,TT	;COMPARE WHAT IT JUST WAS WITH WHAT IT USED TO BE
	JRST ALIST2	;LIST GREW WHEN NOT LOOKING SO A NOW POINTS
		;TO SOMETHING TAKEN OFF; GO PUT IT BACK ON
	POPJ P,

	;TO ADD TO BEGINNING OF LIST:
IFN 0,[	EXCH A,LIST
	HRRM A,@LIST
]	;NOTE THOUGH THAT THIS ISN'T RE-ENTERABLE LIKE ALIST

;PUSHJ P,RLIST	;REMOVE SPECIFIC ITEM FROM LIST, SKIPS IF FOUND ITEM THERE
;A POINTS TO ENTRY TO REMOVE
;T POINTS TO INITIAL LIST ENTRY, LH MUST BE ZERO

RLIST:	SKIPN TT,T	;COPY ADR OF THIS ENTRY INTO TT
	POPJ P,		;NO MORE ENTRIES => FAILURE
	HRRZ T,(T)	;GET THIS ENTRY'S POINTER TO NEXT
	CAIE T,(A)	;SKIP IF NEXT ENTRY IS THE ONE TO REMOVE
	JRST RLIST	;TRY AGAIN
	MOVE T,(T)	;GET ENTRY BEING REMOVED
	HRRM T,(TT)	;REMOVE IT
	JRST POPJ1
