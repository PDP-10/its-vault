TTYVRS==.IFNM2
IFNDEF TCFFLP,TCFFLP==0

;FIRST FILE NAME MUST BE TTY NUMBER (NOT CHARACTERS)
;IGNORES MODE AND GIVES CHARACTER INPUT

SPYO:	JUMPL A,OPNL11
	CAIL A,NCT
	JRST OPNL11
	MOVE E,TIIP(A)
	MOVEM E,IOCHST-IOCHNM(R)
	MOVEI C,ISPY
	HRL C,A
	MOVEM C,(R)
	JRST POPJ1

;A HAS LH OF IOCHNM =TTY #

SPYI:	MOVE T,IOCHST-IOCHNM(R)	;POINTER TO INPUT BUFFER
	HRRZ B,TIBEP(A)
	CAIL B,(T)
	CAILE B,TIBL(T)
	JRST SPYIL
SPYILL:	CAMN T,TIIP(A)
	PUSHJ P,UFLS
	CAMN T,TIBEP(A)
	SUBI T,TIBL
	HRRM T,IOCHST-IOCHNM(R)
	ILDB B,IOCHST-IOCHNM(R)
	XCTR XW,[MOVEM B,(C)]
	POPJ P,

SPYIL:	MOVE T,TIIP(A)
	MOVEM T,IOCHST-IOCHNM(R)
	JRST SPYILL

;	.CALL FOO
;	RETURN

;FOO:	SETZ
;	SIXBIT /RANGET/
;	402000,,BAR

;BAR:	0		;RETURNS 4.9=1 => DOES NOT HAVE TTY NOW
					;1.1-1.6 CONSOLE TTY #
					;1.7-2.3 USER #


ARANGT:	MOVE A,TTYTBL(U)
	AND A,[400000,,000077]
	MOVE B,U
	IDIVI B,LUBLK
	JUMPN C,[JRST 4,.]
	DPB B,[60600,,A]
	JRST SYSCPT


;STY OPEN

;MODE BITS (LH)
;3.1=0 => INPUT   =1 => OUTPUT  (FROM PROGRAM POINT OF VIEW)
;3.2=0 => UNIT    =1 => BLOCK
;INPUT
;3.3=0 => FULL DUPLEX	=1 => HALF DUPLEX
;3.4=1 => DON'T HANG ON INPUT IOTS, INPUT -1 INSTEAD (IGNORED ON OUTPUT OPEN)

STTYO:	SKIPE I,USTYN(U)
	JRST STTYO3	;JUMP IF STY ALREADY OPEN
	PUSHJ P,SWTL	;LOCK STY OPEN SWITCH
	STYOSW
	MOVE I,[-NSTTYS,,NFSTTY]
	MOVSI TT,%SSUSE
STTYO1:	TDNE TT,STYSTS-NFSTTY(I)	;SKIP ON FREE SLOT
STTYO5:	AOBJN I,STTYO1
	JUMPGE I,OPNL6	;NO SLOTS.  GIVE DEVICE FULL
	SKIPGE TTYSTA(I)	;SKIP IF CONSOLE FREE MSG NOT TYPED.
	SKIPE TTNTO(I)		;SKIP IF NOT OPEN.
	JRST STTYO5
	HRRZM I,USTYN(U)	;STORE TTY NUMBER OF STY
STTYO4:	SETZM STYNTO-NFSTTY(I)
	SETZM STYMSK-NFSTTY(I)
	MOVSI TT,%SSUSE
	MOVEM TT,STYSTS-NFSTTY(I)	;SET IN USE BIT
	PUSH P,C
	PUSHJ P,NCNSSP	;MAKE THE TTY A PRINTING TTY.
	PUSHJ P,STYIR1	;FLUSH TTY'S OUTPUT BUFFER.
	PUSHJ P,LSWPOP	;UNLOCK STY OPEN SWITCH
	POP P,C
	HRRM U,STYSTS-NFSTTY(I)
STTYO3:	JUMPL D,STTYO2	;JUMP IF OPENING FOR OUTPUT
	MOVSI TT,%SSHNG
	TLNE C,10
	IORM TT,STYSTS-NFSTTY(I)
	LDB TT,[240100,,C]
	DPB TT,[400100,,STYSTS-NFSTTY(I)] .SEE %SSHDX
	DPB TT,[$TOHDX,,TTYOPT(I)]
STTYO2:	MOVE J,R
	SUBI J,IOCHNM(U)	;CHANNEL BEING OPENED FOR INPUT ON
	MOVE J,CHNBIT(J)
	SKIPL D	;SKIP IF OUTPUT
	IORM J,STYMSK-NFSTTY(I)
	SKIPGE D	;SKIP IF INPUT
	IORM J,STYOMS-NFSTTY(I)
	AOS STYNTO-NFSTTY(I)
	HRLZ A,I	;LH OF IOCHNM GETS STY NUMBER
	MOVSS C
	JSP Q,OPSLC3
	STYDUI,,STYDUO
	STYDBI,,STYDBO

;ENTRY FOR OPEN OF PSEUDO-TTY AS SNM OR STN
STTYOA:	JUMPL I,OPNL1
	CAIL I,NSTTYS
	JRST OPNL1
	ADDI I,NFSTTY
	PUSHJ P,SWTL
	STYOSW
	MOVE TT,STYSTS-NFSTTY(I)	;SKIP IF IN USE
	TLNN TT,%SSUSE
	JRST STTYO4	;OK TO OPEN IF FREE
	CAIE U,(TT)
	JRST OPNL10	;DIFFERENT USER HAS IT OPEN
	PUSHJ P,LSWPOP
	JRST STTYO3

;PSEUDO-TTY INPUT ROUTINE.  RETURNS CHAR WITHOUT PARITY BIT
STTYI:	MOVE I,A
STTYIA:	SKIPGE TTYOAC(I)	;SKIP IF ANY CHARS AVAIL (MAYBE)
	JRST STTYI1
	SKIPL C
	XCTR XRW,[MOVES (C)]	;TAKE TRAP HERE IF GOING TO TAKE ONE
STTYI4:	PUSH P,C
	PUSH P,E
	CONO PI,TTYOFF
	SETOM STYICH
	PUSHJ P,TYP0B
	POP P,E
	POP P,C
	MOVE U,USER
	SKIPGE TTYOAC(I)
	JRST STTYI2	;REALLY NO CHARS AVAIL
	MOVE A,STYICH
	CONO PI,TTYON
	JUMPL A,STTYI4
	MOVE D,A
	MOVSI R,%SSONT	;FOR TTYO INT TO STYI
	PUSHJ P,STTYIC	;INT CLEAR
	JRST UPUTB2

STTYI2:	CONO PI,TTYON
STTYI1:	SKIPGE STYSTS-NFSTTY(I)
	JRST STTYI3	;DON'T HANG
	SKIPGE TTYOAC(I)
	PUSHJ P,UFLS
	JRST STTYIA

STTYI3:	MOVNI D,1
	TLO E,100000	;UNHANG BLOCK MD IOT IMMEDIATELY.
	JRST UPUTB2	.SEE INBTCH

;PSEUDO-TTY OUTPUT
STTYW:	MOVE I,A
	XCTR XR,[MOVE A,(C)]
BSTTYW:	MOVEI T,TIBS
	CAMG T,TICC(I)
	PUSHJ P,UFLS	;HANG UNTIL ROOM IN INPUT BUFFER
	CONO PI,TTYOFF
	PUSHJ P,NTYI5
	MOVE U,USER
	MOVSI R,%SSINT
STTYIC:	ANDCAM R,STYSTS-NFSTTY(I)	;CALLED BY STTYI ABOVE ALSO
	MOVE R,UUAC(U)
	MOVE R,CHNBIT(R)
	ANDCAM R,IFPIR(U)	;FLUSH ANY OUTPUT INTERRUPT
	CONO PI,TTYON
	POPJ P,

STTBI:	JSP E,INBTCH
	JRST STTYI

STTBO:	JSP E,NBTOCH
	CAIN A,EOFCH
	POPJ P,
	HLRZ I,(R)
	PUSH P,R
	PUSH P,D
	PUSH P,TT
	PUSH P,E
	PUSH P,C
	PUSHJ P,BSTTYW
	POP P,C
	POP P,E
	POP P,TT
	POP P,D
	POP P,R
	POPJ P,

;STY OUTPUT CLOSE.
STYOCL:	SUBI R,IOCHNM(U)
	MOVE B,CHNBIT(R)
	ANDCAM B,STYOMS-NFSTTY(A)
	JRST STYCL

;STY INPUT CLOSE
STYICL:	SUBI R,IOCHNM(U)
	MOVE B,CHNBIT(R)
	ANDCAM B,STYMSK-NFSTTY(A)
STYCL:	SOSE STYNTO-NFSTTY(A)
	POPJ P,
STYCL1:	PUSHJ P,TTYLFC	;LEAVE COM. MODE, PUT TTY # IN I.
	CONO PI,TTYON#200_<-APRCHN> ;LEAVE CLOCK OFF.
	SKIPGE C,TTYSTS(I)
	 JRST STYOC8	;TTY NOT IN USE.
	TLNN C,%TSCNS
	 JRST STYOC9	;OPEN AS DEVICE, NOT AS CONSOLE.
	PUSH P,U
STYOC3:	HRRZ U,C
	SKIPL C,SUPPRO(U)
	JRST STYOC3	;NOT TOP LEVEL
	MOVE C,USER
STYC4A:	HRRZ TT,C
	SKIPL C,SUPPRO(TT)
	JRST STYC4A
	CAMN U,TT	;ARE WE THE CURRENT USER
	JRST [ POP P,U? JRST STYOC5]	;IF THE SAME JUST DO OUTPUT RESET
	PUSH P,I
	AOS STYNTO-NFSTTY(I)	;IN CASE OF PCLSR
	HRRZ A,U
	PUSHJ P,1USTOP	;STOP HIM (TURNS CLOCK ON)
	MOVE T,TTYTBL(U)
	TLNE T,%TBNVR
	JRST STYOC2	;NEVER HAD TTY
	PUSHJ P,SDTTY	;SHOULD NOT GET BACK TO ATTY SINCE TTY COULD NOT
	JRST 4,.	;HAVE BEEN TAKEN AWAY
	PUSHJ P,IODCL	;CAUSE HIS TREE'S RUNTIMES TO BE ADDED TO NCTIM
	MOVE T,UTMPTR(U)
	MOVE T,NCTIM-USRRCE(T)
	ADD T,UTRNTM(U)	;ADD IN TOP LEVEL'S RUNTIME
	ADDM T,TMGUND	;FOR THE TIME BEING, CHARGE TO GUNNED USERS
STYOC2:	PUSH P,UUOH
	PUSHJ P,ALOGOUT	;BYE-BYE
	POP P,UUOH
	POP P,A
	POP P,U
	SOS STYNTO-NFSTTY(A)
	JRST STYCL1	;NOW SEE WHAT TTY IS DOING AND TRY AGAIN TO CLOSE
			;CAN'T LOOP BECAUSE TTY CAN'T BE CONSOLE NOW
			;BECAUSE WE DIDN'T SEND A ^Z DOWN IT.

STYOC5:	PUSHJ P,STYIR1	;FLUSH TTY OUTPUT BUFFER.
STYOC9:	SETZM STYSTS-NFSTTY(I)
	CAMN I,USTYN(U)	;IF HE'S CLOSING HIS STY:, SAY HE HAS NONE.
	SETZM USTYN(U)
	JRST CLKONJ

STYOC8:	SKIPGE TTYSTA(I) ;IN TRANSIENT STATE BETWEEN USAGE AND NOT?
	 JRST STYOC5	;NO, REALLY FREE, SIMPLE.
	CONO PI,CLKON
	AOS STYNTO-NFSTTY(I)
	MOVE T,I
	PUSHJ P,STYOCF
	PUSHJ P,UFLS
	MOVE A,I
	JRST STYCL

STYOCF:	SKIPGE TTYSTS(T)	;IF NOW IN USE
	SKIPGE TTYSTA(T)	;OR COMPLETELY FREE,
	 AOS (P)	;THEN NO LONGER IN TRANSIENT STATE.
	POPJ P,

;STY INPUT RESET.
STYIRS:	HLRZ I,(R)
STYIR1:	CONO PI,TTYOFF
	SETOM TTYOAC(I)	;WE WILL NO LONGER BE LOOKING FOR TTY'S OUTPUT.
	JRST TYORS1

;STY OUTPUT RESET.
STYORS:	HLRZ I,(R)
	CONO PI,TTYOFF
	JRST TYIRS1	;TURNS INTO TTY INPUT RESET.

;STY OUTPUT STATUS - BIT 2.1 => BUFFER FULL, 2.2 => EMPTY.
STASTO:	ANDI A,77
	SKIPN B,TICC(A)
	 IORI D,1_<9+1>	;BUFFER EMPTY.
	CAIL B,TIBS-10.
	 IORI D,1_9	;ALMOST FULL.
	POPJ P,

;STY INPUT STATUS - THE SAME 2 BITS.
STASTI:	ANDI A,77
	SKIPG B,TORM(A)
	 IORI D,1_9	;FULL.
	CAIN B,TOBS
	 IORI D,1_<9+1>	;EMPTY.
	POPJ P,

;	.ATTY USR,		OPER 11

AATTY:	HLRZ A,(R)	;A HAS INFERIOR'S USER INDEX
	HRRZ B,(R)
	SKIPL CLSTB(B)	;SKIP IF USER OPEN ON CHANNEL
	POPJ P,
	CONO PI,CLKOFF
	MOVE I,TTYTBL(U)
	JUMPL I,AATT1	;DOESNT HAVE TTY NOW
	MOVSI TT,4
	TDNE TT,TTYSTS(I)
	JRST AATT5	;LAST CHR WAS ^Z
	HRLI A,%TBNOT
	MOVEM A,TTYTBL(U)	;NO LONGER HAS TTY.  STORE USER INDEX GIVEN TO
	PUSHJ P,AATT6	;A _ IDX OF USER TO RECEIVE TTY,
			;ALSO CHANGE ALL TTYTBL VARS THAT NEED IT.
	EXCH A,U
	PUSHJ P,AGBLT6	;TAKE TTY FROM USER IN A (ME),
			;GIVE TO USER IN U (HIM)
			;CHANGES TTY VARS AND TTSTSV VARS.
			;ALSO SETS CHANNELS-OPEN MASKS.
			;TURNS ON ALLPI CHNLS.
	EXCH A,U
	JRST POPJ1

AATT1:	TLNE I,%TBNVR
	JRST CLKOPJ	;NEVER HAD TTY
	TLZ I,%TBDTY	;SAY OUR INFERIOR HAD IT WHEN TAKEN
	HRRI I,(A)
	MOVEM I,TTYTBL(U)
	PUSHJ P,AATT6	;SET UP HIS VARS
	JRST CKOPJ1

AATT5:	PCLT
	MOVSI T,%TSLCZ
	TDNE T,TTYSTS(I)	;WAIT UNTILL LAST CHR WASNT ^Z
	PUSHJ P,UFLS
	JRST AATTY

;CHANGE TTYTBL VARS OF ALL JOBS DOWN TO THE ONE GETTING THE TTY.
;RETURN IN A, T, TT THE TTYSTS, TTYST1, TTYST2 SETTINGS FOR THAT JOB.
;IF THAT JOB NEVER HAD THE TTY, INIT HIS TTSTSV VARS.
;I HAS TTY #, U HAS RUNNING JOB.
AATT6:	MOVE T,TTSTSV(U) ;IN CASE HE'S NEVER HAD TTY, USE HIS SUPERIOR'S TTYSET.
	MOVE TT,TTSTSV+1(U)

AATT4:	MOVE E,TTYTBL(A)
	TLNN E,%TBNVR
	 JRST AATT2	;TAKEN AWAY
	HRLI A,%TSCNS+%TSATY	;INITIALIZE STATUS, NEVER HAD IT
	MOVE E,TTYOPT(I)
	TLNE E,%TOROL
	 TLO A,%TSROL
	TLNN E,%TOMOR
	 TLO A,%TSMOR
	MOVEM T,TTSTSV(A)
	MOVEM TT,TTSTSV+1(A)
	MOVEM A,TTSTSV+2(A)
	POPJ P,

AATT2:	MOVSI T,%TSATY	;TELL THIS GUY TTY WAS TAKEN FROM HIM & RETURNED.
	IORM T,TTSTSV+2(A)
	TLNE E,%TBDTY	;SKIP IF NOT TAKEN FROM ME
	JRST AATT3	;GUY IT WAS TAKEN FROM (I.E. HE HADN'T GIVEN IT TO SOMEONE ELSE)
	MOVEM E,TTYTBL(A)
	HRRZ A,TTYTBL(A)
	JRST AATT4

AATT3:	HRRZS I		;TTY NUMBER
	HLL A,TTSTSV+2(A)
	TLZ A,%TSFRE+%TSLCZ	;CLEAR TTY NOT OPEN AND ^Z BITS
	MOVEM A,TTSTSV+2(A)	;UPDATE SAVED TTY STATUS
	POPJ P,

;SET UP TYIMSK AND TYOMSK. ARGS: TTY # IN I,
;D -> 1ST IOCHNM WORD OF USER TO SET UP FOR.
;MAKE LAST CHAR IN INPUT BFR AN ACTIVATION CHAR. TURN ON TTYCHN.
AATT8:	SETZM TYOMSK(I)
	SETZM TYIMSK(I)
	CONO PI,TTYOFF
	HRLI D,A	;INDIRECTION POINTER TO INFERIOR'S IO CHANNELS
	MOVSI A,-20	;AOBJN POINTER
AATT9:	MOVE B,@D	;GET IOCHNM IN B
	JUMPGE B,AATT10	;IF CHANNEL HAS CONSOLE BIT SET,
	ANDI B,-1
	MOVE C,CHNBIT(A)	;GET THE BIT WE MIGHT WANT TO SET.
	CAIE B,TYODN
	CAIN B,TYOBN	;IF TTY OUTPUT CHNL,
	 IORM C,TYOMSK(I)	;SET BIT IN OUTPUT MASK.
	CAIE B,TYIDN
	CAIN B,TYIBN	;IF INPUT, SET IN INPUT MASK.
	 IORM C,TYIMSK(I)
AATT10:	AOBJN A,AATT9	;TRY NEXT CHANNEL OR CONTINUE IF DONE
	JRST ATTYS1	;ALL CHRS SO FAR ARE ACTIVATION CHRS

ADTTY:	SKIPN USER
	JRST SDTTY	;AVOID BUG IF GET HERE FROM SYSGUN
	HLRZ A,(R)	;OPER 12
	HRRZ B,(R)
	SKIPL CLSTB(B)	;SKIP IF USER OPEN ON CHANNEL
	POPJ P,
.SEE UBLAM,AUCL2,SYSGUN,STYOCL	;DON'T CLOBBER R.
SDTTY:	CONO PI,CLKOFF
	MOVE A,TTYTBL(U)
	JUMPGE A,CLKOJ1	;I ALREADY HAVE IT
	TLNE A,%TBNVR
	JRST CLKONJ	;I NEVER HAD IT

;LOOK FOR SUBJOB THAT HAS TTY, OR DOESN'T WANT TO GIVE TTY
;AWAY IF IT GETS THE TTY.
AGBLT3:	MOVE I,TTYTBL(A)
	TLNE I,%TBDTY	;REACHED A JOB THAT DIDN'T GIVE TTY AWAY
	 JRST AGBLT1	;THIS IMPLIES OUR SUPERIOR TOOK TTY AWAY.
	JUMPL I,AGBLT2	;IF THIS GUY GAVE IT AWAY THEN TRY THE ONE HE GAVE IT TO
	HRRZS A		;A HAS IDX OF TTY OWNER; TAKE TTY FROM HIM.
	PUSHJ P,RPCLSR
	MOVSI D,%TBNOT+%TBDTY	;TELL HIM HE HASN'T GOT TTY.
	MOVEM D,TTYTBL(A)
	AOS (P)		;THE .DTTY SHOULD SKIP.
	PUSH P,[UPCLSR]	;AFTER RESTARTING THE SUBJOB.
AGBLT6:	MOVEI D,TTSTSV-1(A)	;SAVE CURRENT TTY STATUS IN
	PUSH D,TTYST1(I)	;USER VARS OF USER GIVING AWAY THE TTY.
	PUSH D,TTYST2(I)
	PUSH D,TTYSTS(I)
	MOVE TT,I
	IMULI TT,TPLEN*2
	MOVE D,TPVB+TPLEN(TT)
	SUB D,TCMXV(I)
	MOVNS D
	DPB D,[$TBECL,,TTYTBL(A)]
	LDB H,[$TBECL,,TTYTBL(U)]
	PUSHJ P,ASCML1	;SET # COMMAND LINES
	HRROI D,TTSTSV+2(U)
	POP D,TTYSTS(I)	;RESTORE THE TTY STATUS OF JOB GIVING TTY TO.
	POP D,TTYST2(I)
	POP D,TTYST1(I)
	HRRM U,TTYSTS(I)	;INDICATE THAT IT HAS THE TTY
	HRRZM I,TTYTBL(U)
	MOVEI D,IOCHNM(U)
	PUSH P,A	;GENERATE CHNLS-OPEN MASKS, CREATE AN
	PUSHJ P,AATT8	;ACTIVATION CHAR IF NEC, TURN ON PI.
	JRST POPAJ

AGBLT2:	HRRZ A,TTYTBL(A)
	JRST AGBLT3

AGBLT1:	MOVSI A,%TBDTY	;TTY WAS TAKEN AWAY FROM US,
	IORM A,TTYTBL(U)	;WHEN GIVEN BACK WILL STOP WITH THIS JOB.
	JRST CLKOJ1

;DECODE CHNL # (IF < 400000) OR TTY # (OTHERWISE) IN A.
;IF BAD, POP1J WITH OPNL. IF NOT STY OR TTY, SKIP-RETURN FROM UUO.
;IF CONSOLE & DON'T HAVE IT, WAIT FOR IT. THN POPJ WITH TTY # IN I.
ATTYCK:	TDZE A,[-400000]	;IS IT A TTY NUMBER?
	 JRST ATTYC3	;YES, DECODE THAT.
;DECODE CHNL #, TTY # NOT ALLOWED.
ATTYC2:	TDNE A,[-20]	;CHECK FOR VALID CHNL #.
	 JRST S1NL14	;BAD CHANNEL NUM.
	ADDI A,IOCHNM(U)
	HRRZ T,(A)
	LDB I,[$TTIDX,,(A)] ;FOR EITHER TTY CHNL OR STY CHNL, GET TTY #.
	CAIG T,4	;TTY CHNL => GOOD.
	 JUMPG T,ATTYC4
	CAIL T,STYDUI
	CAILE T,STYDBO
	 JRST URETJ1	;NOT STY => BAD.
	POPJ P,		;STY => GOOD.

ATTYC4:	LDB T,[430100,,(A)]	;GET DEVICE/CONSOLE BIT
	JUMPE T,ATTYC1	;DEVICE
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;HANG UNTIL WE HAVE THE TTY
	HRRZ T,TTYTBL(U)
	CAME T,I
	JRST 4,.	;USER HAS TWO DIFFERENT CONSOLE TTYS
ATTYC1:	HRRZ T,TTYSTS(I)	;USER INDEX THAT HAS THIS TTY
	CAME T,U
	JRST 4,.	;USER HAS TTY BUT TTY DOESN'T HAVE THAT USER
	POPJ P,

ATTYC3:	MOVEI I,(A)
	CAIGE A,NCT	;IS THE ARG THE # OF A REAL TTY?
	 POPJ P,	;YES, OK.
	SUB P,[1,,1]
	JRST OPNL1	;"NO SUCH DEVICE" ERROR.

;SETS TTYST1, TTYST2, TTYSTS, WHEN THE USER HAS THE TTY
;HANGS UNTIL HE GETS IT
ATTYST:	PUSHJ P,ATTYC2	;GET TTY NUMBER IN I
	CONO PI,TTYOFF
	MOVEM B,TTYST1(I)
	MOVEM C,TTYST2(I)
	CAIGE W,4
	 JRST ATTYS0	;NO 4TH ARG => DON'T SET TTYSTS.
	TLNE D,%TSINT	;SETTING "INT ON NEXT CHAR REGARDLESS"?
	 PUSHJ P,ATTYS3	;MAYBE THE "NEXT CHAR" HAS ALREADY BEEN READ.
	HRLOI B,%TSFRE+%TSCNS+%TSLCZ+%TSHDX	;DON'T CHANGE THESE.
	TLZ D,%TSFRE+%TSCNS+%TSLCZ+%TSHDX
	ANDCMI D,-1
	ANDM B,TTYSTS(I)
	IORM D,TTYSTS(I)
ATTYS0:	AOS (P)	;MAKE ALL CHRS IN BUFFER ACTIVATION CHARS
ATTYS1:	SKIPG TICC(I)
	JRST TTYONJ
	LDB E,TIIP(I)	;MAKE LAST CHAR AN ACTIVATION CHAR
	TRON E,4000
	AOS TACC(I)	;IF IT WASN'T ONE, IS ONE MORE ACT CHAR NOW
	DPB E,TIIP(I)
	JRST TTYONJ

ATTYS3:	MOVE B,TINTP(I)
ATTYS4:	CAMN B,TIIP(I)	;ANY MORE CHARS TO CHECK?
	 POPJ P,
	CAMN B,TIBEP(I)
	 SUBI B,TIBL
	ILDB E,B	;YES, CHECK THE NEXT ONE.
	TRNE E,%TXIGN	;IF IT ISN'T REALLY THERE, IT SHOULDN'T
	 JRST ATTYS4	;INTERRUPT.
	TLZ D,%TSINT	;ELSE THIS CHAR IS THE "NEXT CHAR" THAT
	TROE E,%TXINT	;SHOULD INTERRUPT REGARDLESS.
	 POPJ P,
	AOS TINTC(I)	;SO MAKE IT AN INT. CHAR IF IT ISN'T.
	DPB E,B
	JRST AITYI3	;AND GIVE THE INTERRUPT FOR IT.

;GETS TTYST1, TTYST2 AND TTYSTS WHEN THE USER HAS THE TTY
;HANGS UNTIL HE GETS IT
;ALSO RETURNS HIS TTYTYP, TCTYP.
;THE RH OF TTYSTS AS RETURNED IS PRE-DIVIDED BY LUBLK
ATTYGT:	PUSHJ P,ATTYCK	;TTY NUMBER NOW IN I
	MOVE B,TTYST2(I)
	HRRZ C,TTYSTS(I) ;GET IDX OF TTY'S USER,
	CAIE C,-1	;(BUT MAY BE NO USER IF WE HAVE STY)
	 IDIVI C,LUBLK	;RETURN IN EASY-TO-DIGEST FORM.
	HLL C,TTYSTS(I)	;GET THE REST OF TTYSTS TOO.
	MOVE D,TTYOPT(I)
	TLNE D,%TOHDX	;THE %TSHDX BIT REFLECTS THE %TOHDX BIT.
	 TLO C,%TSHDX
	MOVE D,TTYTYP(I)
	MOVE E,TCTYP(I)
	MOVE A,TTYST1(I)
	JRST SYSCPS

;RCPOS SYSTEM CALL. (READ CURSOR POSITION)
;1 ARG - TTY OR STY CHNL.
;1ST VALUE <ECHO VERT POS>,,<ECHO HORIZ POS>
;2ND VALUE <MAIN PRGM VERT POS>,,<MAIN PRGM HORIZ POS>
;1ST VALUE IRRELEVANT IF NO ECHO LINES.
ARCPOS:	PUSHJ P,ATTYCK
	MOVE TT,I
	IMULI TT,TPLEN*2
	HRLZ B,TPVP+TPLEN(TT)
	HRR B,TPHP+TPLEN(TT)
	HRLZ A,TPVP(TT)
	HRR A,TPHP(TT)
	JRST SYSCPS

;SCML SYSTEM CALL. 1ST ARG TTY OR STY CHNL,
;2ND ARG IS DESIRED # COMMAND LINES(FOR ECHOING AT BOTTOM OF SCREEN)
;2ND ARG 0 => NO ECHO REGION.
ASCML:	PUSHJ P,ATTYC2
	PUSH P,[TTYOJ1]
	CONO PI,TTYOFF
	MOVEI H,(B)
;I HAS TTY #, H HAS # CMD LINES, TTY CHANNEL OFF.
ASCML1:	MOVE TT,TCMXV(I)
	CAML H,TT
	SOS H,TT
	SUB H,TCMXV(I)
	MOVNS H		;VPOS OF START OF ECHO AREA.
	MOVE TT,I
	IMULI TT,TPLEN*2
	MOVEM H,TPVB+TPLEN(TT)
	MOVEM H,TPVP+TPLEN(TT)
	HRLM H,TPSP+TPLEN(TT)
	SETZ H,	.SEE TPHB+TPLEN(TT)
	MOVEM H,TPHP+TPLEN(TT)
	JRST NCNSSG

;OBSOLETE "UNMORE" SYSTEM CALL SHOULDN'T CAUSE ILOPR.
NUNMOR:	JRST POPJ1

;CNSGET OR RSSIZE SYSTEM CALL. 1 ARG - TTY OR STY CHNL.
;RETURNS THE SAME VARS THAT CNSSET SETS, IN THE SAME ORDER.
NCNSGET:	;RETURN PERMANENT AND SEMIPERMANENT TTY INFO.
ARSSIZ:	PUSHJ P,ATTYCK
	MOVE TT,TTYTYP(I)
	MOVE E,TTYOPT(I)
	MOVE D,TTYCOM(I)
	MOVE C,TCTYP(I)
	MOVE B,TCMXH(I)	;NOTE TCMXH IS LINEL INCLUDING THE CONTIN. COLUMN,
	MOVE A,TCMXV(I)
	SOJA B,SYSCPS	;USER EXPECTS LINEL NOT INCLUDING THAT COLUMN.

;CNSSET SYSTEM CALL.
;1ST ARG TTY OR STY CHNL. NEXT ARGS SET
;VERT SIZE, HORIZ SIZE, TCTYP, TTYCOM, TTYOPT VARS RESPECTIVELY.
;TCTYP CAN'T BE SET TO A NONSENSE VALUE, SOME TTYCOM BITS CAN'T BE SET.
;IF 2ND (3RD) ARG NEGATIVE, VERT SIZE (HORIZ SIZE) NOT CHANGED.
NCNSSET:	PUSHJ P,ATTYC2
	MOVE H,TT
	CAIGE W,3	;IF TCTYP BEING SET,
	 JRST NCNSS0
	JUMPL D,OPNL33	;CHECK NEW VALUE FOR LEGALITY.
	CAIL D,%TNMAX
	JRST OPNL33
NCNSS0:	CONO PI,TTYOFF
	MOVE T,TTYTYP(I) ;DON'T LET %TPORS BE SET FOR PDP11 TV.
	TRNE T,%TY11T
	 TRZA H,%TPORS+7*%TPPCR
	TRZA H,%TP11T	;%TP11T MUST REFLECT %TY11T.
	 IORI H,%TP11T
	TLNN T,%TTIBM	;IF IT ISN'T A 2741 LINE,
	 ANDCMI H,%TPIBM*3	;DON'T TREAT IT AS ONE.
	MOVE TT,I
	IMULI TT,TPLEN*2	;H HAS IDX OF MAIN PC PPR OF TTY.
	XORI W,-1	;EACH OF THE INSNS AFTER THE JRST SETS ONE PARAMETER.
	CAIL W,#6	;>6 ARGS SAME AS 6 ARGS.
	 JRST NCNSS1+2(W) ;ELSE DON'T SET VARS WE DIDN'T GET ARGS FOR.
	MOVEM H,TTYOPT(I)
	PUSHJ P,[XOR E,TTYCOM(I) ;DON'T CHANGE TTYCOM BITS EXCEPT THESE.
		AND E,[%TCQRY+%TCRFS+ICO+OCO,,]
		XORM E,TTYCOM(I)
		POPJ P,]
	MOVEM D,TCTYP(I)
	PUSHJ P,[JUMPG C,NCNSSH	;SET TCMXH.
		POPJ P,]
	PUSHJ P,[JUMPG B,NCNSSV	;SET TCMXV
		POPJ P,]
NCNSS1:	PUSHJ P,NCNSSG	;SET TTYEPP.
	JRST TTYOJ1

;SET TTY WIDTH (NOT INCLUDING THE SPACE FOR THE "!") TO ARG IN C.
;TTY # IN I, MAIN PC PPR IDX IN TT.
NCNSSH:	ADDI C,1
	MOVEM C,TCMXH(I)
.SEE TPHE	;	MOVEM C,TPHE(TT)
.SEE TPHE	;	MOVEM C,TPHE+TPLEN(TT)
	CAMG C,TPHP(TT)
	 MOVEM C,TPHP(TT)
	CAMG C,TPHP+TPLEN(TT)
	 MOVEM C,TPHP+TPLEN(TT)
	POPJ P,

;SET TTY SCREEN HEIGHT FROM VALUE IN B.
NCNSSV:	MOVEM B,TCMXV(I)
.SEE TPVE	;	MOVEM B,TPVE(TT)
.SEE TPVE	;	MOVEM B,TPVE+TPLEN(TT)
	CAMG B,TPVP(TT)
	 MOVEM B,TPVP(TT)
	MOVEM B,TPVP+TPLEN(TT)
	MOVEM B,TPVB+TPLEN(TT)
	HRLM B,TPSP+TPLEN(TT)
	POPJ P,

;MAKE A TTY INTO AN ORDINARY PRINTING TTY.
;TTY # IN I; CLOBBERS TT,B,C.
NCNSSP:	SETZM TCTYP(I)
	MOVE TT,[%TOMVB+%TOOVR,,%TPORS]
	MOVE B,TTYTYP(I)
	TRNN B,%TYSTY
	 IORI B,%TPPCR
	MOVEM TT,TTYOPT(I)
	MOVE TT,I
	IMULI TT,TPLEN*2
	MOVEM TT,TTYEPP(I)
	MOVEI C,71.
	MOVSI B,(MOVE)
	PUSHJ P,NCNSSH
	JRST NCNSSV

;SET TTYEPP OF TTY # IN I. CLOBBER H,TT.
NCNSSG:	MOVE H,TTYOPT(I)
	TLNE H,%TOMVU	;NOT DISPLAY OR
	TLNN H,%TOERS	;ARDS-LIKE (CAN'T ERASE)
	 JRST NCNSSF	; => CAN'T HAVE ECHO AREA.
	MOVE H,TPLEN+TPVB(TT)
	CAMGE H,TCMXV(I)	;NO ECHO LINES => CAN'T USE ECHO AREA.
	 ADDI TT,TPLEN	;ELSE USE IT.
NCNSSF:	MOVEM TT,TTYEPP(I)
	POPJ P,

AITYIC:	XCTR XR,[MOVE A,(J)]	;OPER 60
	PUSHJ P,TTYNGT
	POPJ P,
	JRST AITYI1

AITYI:	SKIPL A,TTYTBL(U)	;OPER 1
AITYI1:	SKIPG TINTC(A)
	POPJ P,
AITYI2:	MOVE B,TINTP(A)
	CAMN B,TIBEP(A)
	SUBI B,TIBL
	HRRM B,TINTP(A)
	ILDB B,TINTP(A)
	DPB B,TITNP(A)
	LSH C,(D)	;SAYING THE INT. HAS HAPPENED.
	ANDCAM C,@TINTP(A)
	ANDI B,3777
	SOS TINTC(A)
	JRST AOPVS

AITYI3:	MOVE B,TYIMSK(I)
	AND B,MSKST2(U)
	MOVN C,B
	AND B,C
	IORM B,IFPIR(U)
	MOVEI A,1
	TDNE A,MSKST(U)
	IORM A,PIRQC(U)
	POPJ P,

AOPVS:	AOS (P)
AOPERV:	XCTR XW,[MOVEM B,(J)]
	POPJ P,

ALISTEN:	SKIPGE A,TTYTBL(U)
	 JRST ALIS1
	PUSHJ P,TYOW
	SKIPA B,TICC(A)
ALIS1:	 SETZ B,
	MOVE A,PIRQC(U)
	TRNE A,BCNTRZI
	JRST UDELAY
	JRST AOPERV


NLISTE:	PUSHJ P,TTYNGT
	POPJ P,
	PUSHJ P,TYOW
	MOVE A,TICC(A)
	JRST SYSCPS

TTYNGT:	CAIL A,0
	CAIL A,20
	 JRST S1NL14
	ADDI A,IOCHNM(U)
	MOVE B,(A)
	MOVE C,CLSTB(B)
	TLNN C,20000
	POPJ P,
	HLRZ A,B
	TRZ A,377700
	TRZE A,400000
	SKIPL A,TTYTBL(U)
	AOS (P)
	POPJ P,

;LH TTY OPEN
;3.1 0 -> IN 1 -> OUT
;3.2 0 -> UNIT 1 -> BLOCK
;3.3 0 -> ASCII 1 -> IMAGE

;OUTPUT
;3.4 0 -> NORMAL 1 -> ECHO
;3.5 0 -> NORMAL 1 -> DISPLAY
;3.6 0 -> NORMAL 1 -> SUPER-IMAGE OUTPUT.

;INPUT
;3.4 0 -> NORMAL 1 -> "DDT (DON'T ECHO CR, LF, TAB)"
;3.5 0 -> NORMAL 1 -> CONVERT LOWER TO UPPER CASE
;3.6 0 -> WANT 3 LINES IN ECHO AREA.

;BITS 3.4 AND 3.6 ON INPUT, AND BIT 3.3, HAVE EFFECT
;ONLY ON THE FIRST OPEN IN EITHER DIRECTION.
;(THEY ARE OBSOLETED BY THE TTYSET SYSTEM CALL)

;LH OF IOCHNM WD
;(SHOWS UP IN RH OF A ON .IOT, .CLOSE, ETC)

%TICNS==400000	;4.9 1-> CONSOLE 0 -> DEVICE

;OUTPUT:
%TICP1==200000	;^P-CODE ANTICIPATION STATE.
%TICP2==100000	; ".  0=>NORMAL, 1=> CHAR AFTER ^P, 2=> ^PH, 3=>^PV.
%TIECH==40000	;SET => ECHO MODE OUTPUT.-MODE OUTPUT (ALL CHARS OUTPUT THE
		;WAY THEY WOULD BE ECHOED)
%TICTN==20000	;SET => DON'T DO LINE-CONTINUATION.
%TISTP==10000	;SET => THIS CHANNEL IS HUNG IN **MORE**.
%TIDIS==4000	;SET => LOOK FOR ^P CODES.
%TISIO==2000	;SET => SUPERIMAGE OUTPUT, NO PADDING OR CURSOR CTL.
%TIMOR==1000	;SET => DON'T DO **MORE** PROCESSING.
%TIPP2==400	;SET => USE ALTERNATE PC PPR (THE ECHO AREA)
%TIHDE==100	;SET => ACCOUTING FOR CURSOR MOTION DUE TO
		;CHAR ECHOED ON A HALF-DUPLEX TTY.

;INPUT
;3.3 => NO ECHO.
%TIACT==200000	;SET => DON'T WAIT FOR ACTIVATION CHARACTER.
%TIINT==100000	;SET => CAN READ A CHAR EVEN IF IT IS SUPPOSED TO INTERRUPT & HASN'T YET.
%TIECH==40000	;CAN READ EVEN IF CHAR NEEDS PI ECHOING.
%TIPEK==20000	;DON'T REMOVE CHAR FROM BUFFER.
%TICLC==10000	;CONVERT LOWER CASE TO UPPER.

$TIIDX==220600	;3.6-3.1 CONSOLE #, OR 77 FOR A "DISOWNED" CONSOLE TTY CHNL
;IE, ONE THAT CORRESPONDS TO NO REAL TTY. THEY EXIST ONLY IN
;TREES WITH NO TTY, IN JOBS THAT CAM FROM TREES WITH TTYS.
%TINON==77	;"TTY #" FOR A CHANNEL WITH NO REAL TTY.

;ENTRY FOR OPEN OF TTY AS DEVICE TYN OR TNM


IFN TTLPTP,[
LPTO:	MOVE J,TIME
	SUB J,LPTTIME	;"LPT" INPUTS EVERY ONCE IN A WHILE IF IT IS UP
	CAIL J,60.	;2 SECONDS
	JRST OPNL7
	SKIPA I,LPTTTY
]
TTYO:	PUSHJ P,TTYFD	;TEST FOR FILE NAME OF .FILE. (DIR)
	CAIL I,NCT
	JRST OPNL1	;TTY NUM TOO LARGE
	PUSHJ P,SWTL	;LOCK TTY OPEN SWITCH SO TWO PROCEDURES
	TTYOSW		;WON'T OPEN THE TTY AS A DEVICE AT THE SAME TIME
IFN NNVTTS,[
	CAIGE I,NOTYS+NNTYS+NNVTTS
	CAIGE I,NOTYS+NNTYS	;SKIP ON NOVA TTY
	JRST TTYO3A
	SKIPGE NOVATT
	JRST OPNL10	;NOVA LINK NOT ACTIVE
TTYO3A:	CAMN I,NOVATT
	JRST OPNL10	;CANT OPEN TTY USED AS CNHL TO NOVA
]
	MOVEI A,0	;MARK AS A DEVICE
	SKIPGE TT,TTYSTS(I)	;SKIP IF TTY OPEN
	JRST TTYO3B	;OK IF TTY NOT OPEN
	CAIE U,(TT)	;SAME USER THAT HAS IT?
	JRST OPNL10	;TTY ALREADY OPEN
	TLNN TT,1	;OPEN AS CONSOLE?
	JRST TTYO8	;NO, AS DEVICE
	PUSHJ P,LSWPOP	;YES, FREE TTYOSW AND RETRY
	JRST TTYO7	;OPEN, THIS TIME AS CONSOLE.

TTYO3B:	SKIPE USER
	SKIPGE TTYSTA(I)
	 JRST TTYO8
	JRST OPNL10	;CONSOLE FREE MESSAGE NOT TYPED YET

TTYO8:	CONO PI,TTYOFF	;TTY IS AVAIL. TO OPEN AS A DEVICE.
	SKIPN TTNTO(I)	;IF TTY USED TO BE FREE, INIT. IT.
	 PUSHJ P,TTYINI
	JRST TTYO3

TTYFD:	PUSHJ P,FLDRCK	;SKIP IF FILE DIR BEING OPENED
	JRST TTYFD1	;FILE NAMES NOT SPECIAL
	SUB P,[1,,1]
	MOVEI J,6
	JRST LISTF7	;GO GET DIRCTORY

TTYFD1:	JUMPE W,CPOPJ	;0 IS THE ONLY DEFINED MODE FOR ANY TTY OPEN
	SUB P,[1,,1]
	JRST OPNL12

FLDRCK:	CAMN A,[SIXBIT /.FILE./]
	CAME B,[SIXBIT /(DIR)/]
	POPJ P,
	JRST POPJ1

;INIT A TTY WHEN IT CEASES TO BE FREE. (ZFLAG7 FOR TTY, TTYO8 FOR TNM)
TTYINI:	SETZM TTYST1(I)
	SETZM TTYST2(I)
	MOVSI J,400000	;TTY NEEDS A CONSOLE FREE MESSAGE.
	ANDCAM J,TTYSTA(I)
	MOVE J,TTYCOM(I)
	TLZ J,%TCRFS+%TCQRY
	MOVEM J,TTYCOM(I)
	MOVE J,TTYOPT(I)	;INIT SOME TTYOPT BITS.
	TLZ J,%TOCLC+%TOMOR+%TOROL
IFE MCOND DM,[
	TLNE J,%TOMVU	;ON DM, DO **MORE** ON DISPLAYS,
	 TLO J,%TOMOR
	HRR J,TCTYP(I)
	SKIPE TYOLTB(J)	;SCROLL ON TERMINALS THAT CAN.
	 TLO J,%TOROL
]
	HLLM J,TTYOPT(I)
	MOVEI H,-1		;INITIALIZE TTYSTS.
	TLNE J,%TOROL
	 TLO H,%TSROL
	TLNN J,%TOMOR	;NOTE %TOMOR SAYS DO **MORE** PROC,
	 TLO H,%TSMOR	;%TSMOR SAYS INHIBIT **MORE** PROC.
	MOVEM H,TTYSTS(I)
	SETZ H,		;START OUT WITH NO ECHO LINES.
	JRST ASCML1

;TELETYPE OPEN ROUTINES

;ENTRY FOR OPEN OF "TTY" AS A CONSOLE

TTYO1:	PUSHJ P,TTYFD	;TEST FOR FILE NAME OF .FILE. (DIR)
TTYO7:	MOVE I,TTYTBL(U)
	JUMPGE I,TTYO2	;JUMP IF HAS TTY NOW
	TLNN I,%TBDTY	;SKIP IF TTY WAS TAKEN AWAY
	JRST OPNL10	;DOESN'T HAVE TTY NOW AND WASN'T TAKEN AWAY.  LOSE.
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;HANG UNTIL HAS TTY
	MOVE I,TTYTBL(U)
TTYO2:	HRRZS I	;TTY NUMBER
	CAIL I,NCT
	JRST 4,OPNL1	;TTY NUM TOO LARGE
	PUSHJ P,SWTL
	TTYOSW		;LOCK TTY OPEN SW
	MOVSI A,%TICNS	;SAY TTY CHNL WILL BE OPEN AS CONSOLE.
	CONO PI,TTYOFF
TTYO3:	HRLZI J,(D)	;SET IOCHNM BITS (IN A) FROM OPEN MODE.
	LSH J,1
	TLZ J,700077	;BUT DON'T USE PARTS OF OPEN WD USED FOR OTHER THINGS.
	IOR A,J

IFN TTLPTP,[
	CAMN I,LPTTTY	;SKIP IF OT TTY
	HRRZM U,LPTUSR
]
	DPB I,[$TIIDX,,A]	;LH OF A WILL BE STORED IN LH OF IOCHNM WORD
	MOVE TT,UUAC(U)	;TT HAS CHNL # BEING OPENED.
	JUMPGE D,TTYO4	;J IF INPUT OPEN.
	TRNE D,20
	 TLO A,%TISIO	;SUPER IMAGE OUT.
	TRNE D,4
	 TLO A,%TIECH+%TIPP2+%TIMOR	;ECHO OUTPUT
	TRNE D,10
	 TLO A,%TIDIS	;DISPLAY OUTPUT MODE.
	MOVE J,TYOMSK(I)
	IOR J,CHNBIT(TT)	;UPDATE CHANNELS-OPEN MASK
	EXCH J,TYOMSK(I)	;FOR THE NEW OUTPUT CHANNEL.
	JUMPN J,TTYO5	;FOR 1ST OUTPUT OPEN, INIT TTYST1,2.
	MOVE J,[101010,,101010]
	IORM J,TTYST1(I)
	IORM J,TTYST2(I)	;SET ALL THE OUTPUT-IN-IMAGE-MODE BITS.
	TRNN D,2
	 ANDCAM J,TTYST1(I)	;IF NOT IMAGE, CLEAR THEM.
	TRNN D,2
	 ANDCAM J,TTYST2(I)
	JRST TTYO5

TTYO4:	TRNE D,10
	 TLO A,%TICLC
	MOVE J,TYIMSK(I)
	IOR J,CHNBIT(TT)	;UPDATE INPUT-CHNLS-OPEN MASK
	EXCH J,TYIMSK(I)	;FOR NEWLY OPENED INPUT CHANNEL.
	JUMPN J,TTYO5	;THE 1ST INPUT CHNL OPEN, INIT ECHO BITS...
	MOVEI H,0	;INPUT
	TRNE D,20
	 MOVEI H,3	;# COMMAND LINES
	PUSHJ P,ASCML1
	MOVE J,TTYST1(I)
	AND J,[101010,,101010]	;SAVE IMAGE MODE OUTPUT BITS
	TRNN D,2	;SKIP ON IMAGE MODE INPUT
	IOR J,[202020,,202020]	;ASCII MODE INPUT
	IOR J,[030303,,030303]	;ENABLE INTERRUPT AND ACTIVATE ON ANY CHARACTER
	MOVEM J,TTYST1(I)	;STORE BACK
	MOVE J,TTYST2(I)
	AND J,[101010,,101010]	;SAVE IMAGE MODE OUTPUT BITS
	TRNN D,2	;SKIP ON IMAGE MODE INPUT
	IOR J,[202020,,202020]	;ASCII MODE INPUT
	TRNE D,4	;SKIP ON NOT DDT MODE
	ANDCM J,[006000,,606000]	;DDT MODE
	IOR J,[030303,,030303]	;ENABLE INTERRUPT AND ACTIVATE ON ANY CHARACTER
	MOVEM J,TTYST2(I)	;STORE BACK
TTYO5:	HRRM U,TTYSTS(I)
	AOS TTNTO(I)	;INCREMENT NUMBER OF CHNLS THIS TTY OPEN ON.
	CONO PI,TTYON
	PUSHJ P,LSWPOP	;RELEASE LOCK
	MOVSS C
	JSP Q,OPSLC3	;SET UP IO CHNM WORD AND RETURN
	TYIDN,,TYODN
	TYIBN,,TYOBN

TTYRST:	HLRZ I,(R)	;ENTRY FOR .RESET
	ANDI I,%TICNS+77
	TRZN I,%TICNS	;CLEAR AND CHECK CONSOLE/DEVICE BIT
	POPJ P,		;RETURN IF DEVICE
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;WAIT TILL HAS TTY (CANT HAVE TTY IF DISOWNED)
	POPJ P,

TTYCMW:	CONO PI,UTCOFF
IFN TCFFLP,[
	MOVSI A,%TCFFL
	TDNN A,TTYCOM(I)
]
	TDNN T,TTYCOM(I)
	SKIPL TTYCOM(I)
	POPJ P,
	SKIPN USER
	 POPJ P,	;SYS JOB TRYING TO HACK
	HRR T,I	;WAIT UNTIL NOT COM MODE OR IN COM MODE BUT ONE OR MORE BITS IN LH OF T
	PUSHJ P,LWAIT1	;COME ON.  WAIT UNTIL OUT OF COM MODE WITH UTCOFF
	PUSHJ P,TYTSCM
	POPJ P,

TYTSCM:	SKIPL TTYCOM(T)
	JRST POPJ1	;NOT COM MODE
	PUSH P,A
	HLLZ A,TTYCOM(T)
IFN TCFFLP,[
	TLNE A,%TCFFL
	 JRST POPAJ
]
	TDNE A,T
	AOS -1(P)	;MASKED BIT(S) ON
	POP P,A
	POPJ P,


;TTY IOT ROUTINES

;BLOCK MODE INPUT IOT.
TTYBI:	JSP E,INBTCH

;UNIT MODE INPUT IOT.
;R HAS THE ADDRESS OF THE IOCHNM WORD.
;C THE EFFECTIVE ADDRESS OF THE UUO, OR SIGN SET => # OF AC IN SYSTEM.
TYI:	PUSHJ P,TTYRST	;WAIT FOR THE TTY IF ITS A CONSOLE.  TTY NUMBER IN I
	HLRZ R,(R)	;GET IOCHNM WORD FLAGS, MODIFIED BY CTL BITS
	XOR R,CTLBTS(U)	;R HAS CHANNEL FLAGS
	PUSH P,C
	PUSH P,E
	PUSHJ P,TYI0	;GET THE CHAR IN D.
	POP P,E
	POP P,C
	MOVE A,I
	ANDI D,177
	CAIN D,^C
	 TLO E,400000	.SEE INBTCH	;END BLOCK-MODE .IOT.
UPUTB:	ANDI D,177
UPUTB2:	JUMPL C,UPUTB1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

UPUTB1:	TRNE C,777760
	JRST 4,.
	MOVEM D,(C)
	POPJ P,

TYI0:	MOVE D,TTYTYP(I)
	TRNN D,%TYSTY	;SKIP IF TTY IS ALTER EGO OF STY.
	 JRST TYI1B1
	MOVSI D,%SSINT
	TDNE D,STYSTS-NFSTTY(I)
	 JRST TYI1B1	;HAVE ALREADY GIVEN INT
	SKIPE TICC(I)
	 JRST TYI1B1
	IORB D,STYSTS-NFSTTY(I)
	MOVE TT,STYOMS-NFSTTY(I)	;CHANNELS OPEN FOR OUTPUT ON
	AND TT,MSKST2(D)
	IORM TT,IFPIR(D)	;GIVE INT
	JRST TYI1B1

TYI1B1:	TRNE R,%TIACT
	 JRST TYI1B	;GOBBLE NEXT CHR REGARDLESS OF ACTIVATION
	MOVE TT,TTYSTS(I)
	TLNE TT,%TSACT
	 JRST TYI1B
	PCLT
	SKIPG TACC(I)
	PUSHJ P,TYIFLS
TYI1B:	PCLT	;WAIT TILL THERE'S A CHAR TO READ.
	SKIPG TICC(I)
	PUSHJ P,TYIFLS
	SKIPL C
	XCTR XRW,[MOVES (C)]	;TAKE TRAP HERE IF GOING TO TAKE ONE
	MOVE B,TIOP(I)
	MOVE TT,B
	CAMN B,TIBEP(I)
	SUBI B,TIBL
	HRRM B,TIOP(I)
	ILDB D,B
TYI1:	TRNE R,%TIECH	;THIS CHANNEL NEEDN'T WAIT FOR ECHO
	 ANDCMI D,%TXPIE ;=> DON'T.
	SKIPE PICLR(U)	;AT INT LVL IN USER PRGM OR
	TRNE R,%TIINT	;THIS CHNL NEEDN'T WAIT FOR CHAR TO INTERRUPT
	 ANDCMI D,%TXINT ;=> DON'T WAIT FOR THAT.
	MOVEI T,(D)
	ANDI T,%TXINT+%TXPIE ;WAIT FOR THESE BITS TO CLEAR.
	LDB D,[360600,,B]
	LSH T,(D)
	PCLT
	TDNE T,@B
	PUSHJ P,TYIFLS	;HANG UNTIL PI ECHO BIT FOR THIS CHAR IS TURNED OFF
	LDB D,B		;GET CHARACTER
	TRNE D,%TXMPE	;SHOULD THIS CHAR GET M.P. ECHO?
	TRNE R,%TIPEK	;NOT REMOVING CHAR => DON'T MP ECHO.
	 JRST TYI2	;OTHERWISE CHAR WOULD BE ECHOED TWICE.
		;ALSO, TYOEOP CALLS HERE WITH %TIPEK SET AND
		;IF IT TRIIED TO DO OUTPUT IT WOULD SCREW UP.
	JRST TYIMP1

TYIMP1:	PUSH P,R	;DO MAIN-PRGM ECHO IF NECESSARY.
	PUSH P,D
	PUSH P,C
	PUSHJ P,[MOVEI J,1(P)
		ADD P,[3,,3]
		HRRZM P,(P)
		MOVE TT,TTYEPP(I)
		JSP E,TYOSE1
		MOVE A,D
		ANDI A,177
		MOVEI R,%TIECH+%TIMOR
		JRST TYO6]
	POP P,C
	POP P,D
	POP P,R
TYI2:	TRNN D,%TXIGN	;IF CHAR IS TO IGNORE, ALWAYS REMOVE IT.
	TRNN R,%TIPEK	;ELSE DON'T REMOVE IF CHNL SAYS DON'T.
	 PUSHJ P,TYIREM	;FINALLY REMOVE CHAR FROM BUFFER,
	TRNE D,%TXIGN
	 JRST TYI1B1
	MOVSI TT,%TSACT
	ANDCAM TT,TTYSTS(I)
	MOVSI TT,%SSINT	;IF TTY IS STY'S, GIVE STY OUTPUT INTERRUPT.
	MOVE B,TTYTYP(I)
	TRNE B,%TYSTY
	 ANDCAM TT,STYSTS-NFSTTY(I)
	MOVE TT,TTYST1(I)
	TLNE TT,%TGSPC_6
	 JRST TYI3
	TRNN R,%TICLC	;CONVERT LOWER CASE TO UPPER?
	 POPJ P,
TYI3:	LDB A,[700,,D]
	CAIL A,141	;YES, IS THIS CHAR LOWER CASE?
	CAILE A,172
	 POPJ P,
	XORI D,40
	POPJ P,

;REMOVE FROM INPUT BUFFER THE CHAR WE HAVE BEEN EXAMINING.
;TT SHOULD HOLD WHAT TIOPHELD BEFORE WE STARTED LOOKING
;FOR THIS CHARACTER.
TYIREM:	SOSGE TICC(I)
	 JRST 4,.
	CONO PI,TTYOFF
	ILDB D,TIOP(I)
	TRNE D,%TXACT
	 SOS TACC(I)
	TRNE D,%TXPIE	;IF IT NEEDED PI ECHO,
	 SOS ECHOC(I)	;ONE FEWER CHAR AWAITS PI ECHO.
	TRNE D,%TXINT
	 SOS TINTC(I)	;SIMILAR FOR INT. TO PROGM.
	MOVE B,TIOP(I)
	CAMN TT,ECHOP(I) ;IF ECHOP POINTED AT THIS CHAR,
	 MOVEM B,ECHOP(I) ;ADVANCE IT.
	CAMN TT,TINTP(I) ;SIMILAR FOR TINTP
	 MOVEM B,TINTP(I)
	CONO PI,TTYON
	POPJ P,

;COME HERE TO HANG UP FOR INPUT. LIKE UFLS BUT PREVENTS
;A **MORE** THIS TIME AROUND THE SCREEN, ON GROUNDS THAT USER
;HAS COMMANDED THE OUTPUT FOR 1 MORE PAGE AT LEAST.
;CLOBBERS A,D,H.
TYIFLS:	MOVE H,TTYOPT(I)
	TLNE H,%TOMVU	;THIS APPLIES ONLY ON ERASABLE DISPLAYS.
	TLNE H,%TOERS
	SKIPA D,I
	 JRST UFLS
	IMULI D,TPLEN*2
	MOVE A,TTYSTS(I)
	TLNN A,%TSROL
	 JRST TYIFL1
	MOVE H,TCMXV(I)	.SEE TPVE(D)
	MOVE A,TCTYP(I)	;IN SCROLL MODE, **MORE** HAPPENS
	ADD H,TYOLTB(A)	;WHEN THIS LINE GOES OFF SCREEN.
	MOVEM H,TPVM(D)
	JRST UFLS

TYIFL1:	MOVE A,.TCMXV(I)	.SEE TPVE(D)
	SUB A,TPVP(D)	;NOT SCROLL MODE: NEAR BOTTOM OF SCREEN?
	MOVSI D,%TCINP
	CAIGE A,6
	 IORM D,TTYCOM(I) ;YES, SUPPRESS **MORE** THIS TIME.
	JRST UFLS

;THESE PUSHED BY TYOSET, REFERENCED INDEX OF J.
TYOPV0==0	;HOLDS PC PPR VPOS,,PC PPR HPOS FOR RESTORATION ON PCLSR.
TYOPV1==1	;HOLDS -1 => ON PCLSR, ASSOCIATE TTY W/ THIS PC PPR,
		;ELSE TTYLVP,,TTYLHP TO RESTORE ON PCLSR.
TYOPV2==2	;-> IOCHNM WORD OF CHANNEL IOT IS ON.
TYOPV3==3	;PC PPR IDX,,TTY #.


;TO OUTPUT TO A TTY (R -> IOCHNM WD OF TTY CHNL)
;	JSP E,TYOSET	;WAIT TILL JOB HAS TTY AND OUT OF COM MODE,
;			;INIT FOR PCLSRING, PUSH VARS ON STACK.
;	 ...		;OUTPUT 1 OR MORE CHARS TO TTY
;			;MEANWHILE, J -> BLOCK OF 4 STACK VARS.
;	POPJ P,		;RETURNS TO TYOUNS TO FLUSH STACK, ETC.

TYOSET:	MOVEI J,1(P)	;PROVIDE SPACE FOR TEMPS, WHERE FINSET CAN FIND THEM.
	ADD P,[2,,2]
	PUSH P,R	.SEE TYOPV2
	PUSHJ P,TTYRST	;WAIT TILL THIS JOB HAS THE TTY.
	MOVSI T,LFT+OCO
	SKIPGE TTYCOM(I)
	 PUSHJ P,TTYCMW	;WAIT TILL TTY IS NOT IN COM MODE.
	CONO PI,UTCON
	MOVEI A,%TICNS+77 ;DON'T LET THESE IOCHNM BITS BE CHANGED
	ANDCAB A,CTLBTS(U) ;EVEN TEMPORARILY.
	HRLZS A		;ELSE, IF A BIT IS SET IN THE CTL BITS,
	XORB A,(R)	;CHANGE IT (TEMPORARILY) IN IOCHNM WORD.
	MOVE TT,I	;NOW MAKE TT -> APPRO. PC PPR FOR THIS CHNL.
	IMULI TT,TPLEN*2
	TRNE A,%TIPP2
	 MOVE TT,TTYEPP(I)
TYOSE1:	PCLT
	AOSE TYOSW(I)	;SEIZE THIS TTY FOR mP LEVEL.
	 JRST [SKIPL TYOSW(I)
		PUSHJ P,UFLS
		JRST .-1]
	CAMN TT,TTYLPP(I) ;IF TTY IS ASSOCIATED W/ ANOTHER PC PPR,
	 JRST TYOSE2
	PUSH P,TT
	SKIPL TT,TTYLPP(I)
	 PUSHJ P,TYOMVC	;DISASSOCIATE THEM.
	POP P,TT
	SETCAM TT,TTYLPP(I)
TYOSE2:	MOVE B,TPHP(TT)	;NOW INIT THE BACKUP VARIABLES.
	HRL B,TPVP(TT)
	MOVEM B,TYOPV0(J)
	MOVE B,TTYLPS(I)
	MOVEM B,TYOPV1(J)
	PUSHJ P,FINSET
	 [MOVE U,USER
	  MOVE J,AC0S+J(U)
	  HLRZ Q,@TYOPV2(J) ;UNDO TEMPORARY CHANGES IN IOCHNM WORD.
	  XOR Q,CTLBTS(U)
	  HRLM Q,@TYOPV2(J)
	  MOVE I,TYOPV3(J)
	  HLRZ TT,I
	  MOVE Q,TYOPV0(J)
	  HLRZM Q,TPVP(TT)
	  HRRZM Q,TPHP(TT)
	  MOVE Q,TYOPV1(J)
	  MOVEM Q,TTYLPS(I)
	  SKIPL Q
	   SETCAM TT,TTYLPP(I)
	  SKIPGE Q
	   MOVEM TT,TTYLPP(I)
	  SETOM TYOSW(I)
	  SUB P,[3,,3]
	  POPJ P,]
	MOVE Q,TTYCOM(I) ;IF THIS TTY IS A TERMINET & ITS MOTOR IS OFF,
	TLNE Q,%TCMTR
	 PUSHJ P,TTTMTO	;TURN THE MOTOR ON BEFORE OUTPUT.
	PUSH P,I	.SEE TYOPV3
	HRLM TT,(P)
	PUSHJ P,(E)

TYOUNS:	MOVEI A,%TICP1+%TICP2+%TISTP
	ANDCAM A,CTLBTS(U)
	PUSHJ P,TYOUN1
	JRST POP4J

TYOUN1:	HRLZ R,CTLBTS(U) ;UNDO TEMPORARY CHANGES IN IOCHNM WD.
	XORM R,@TYOPV2(J)
	PUSHJ P,LSWDEL
	SKIPGE TTYERQ(I) ;IF ECHOING ISN'T ALREADY REQUESTED,
	SKIPL TTYLPP(I)	;AND THERE IS BUFFERED CURSOR POSITIONING,
	 JRST TYOUN3
	MOVEI J,TTEDMY	;SO TYOFNR WON'T CLOBBER RANDOMNESS.
	SETCM TT,TTYLPP(I) ;TT -> PC PPR TTY WAS DISSOCIATED FROM.
	MOVE A,TORM(I)
	CAIN A,TOBS	;AND IT CAN BE DONE NOW,
	 PUSHJ P,TYOFRC	;FORCE OUT BUFFERED CURSOR MOTION.
TYOUN3:	SETOM TYOSW(I)	;RELEASE TTY.
	POPJ P,

;OUTPUT IOT

;BLOCK MODE.
TTYBO:	JSP E,TYOSET
	JSP E,NBTOCH
TTYBO3:	CAIN A,EOFCH
	 POPJ P,
	PUSH P,TT
	PUSHJ P,TTYBO1
	POP P,TT
	MOVEI E,TTYBO3
	POPJ P,

;UNIT MODE.
TYO:	JSP E,TYOSET
	XCTR XR,[MOVE A,(C)]
	ANDI A,177
;MUSTN'T CLOBBER C OR D.
TTYBO1:	HLRZ R,@TYOPV2(J) ;RH(R) GETS LH(IOCHNM WD)
TTYBO2:	HRRZ I,TYOPV3(J)
	HLRZ TT,TYOPV3(J)
	SKIPGE E,TTYCOM(I);IN COM MODE W/ LOCAL FEED THRU,
	TLNN E,LFT
	 JRST TYO6
	PUSH P,C
	PUSH P,D
	PUSH P,U
	PUSH P,TT	;ECHO CHAR ON ALL TTYS IN LOOP
	PUSH P,R	;THAT HAVE REMOTE-FEED-THRU.
	PUSHJ P,TYCREP	;DO FOLLOWING INSN FOR EACH TTY IN LOOP.
	 PUSHJ P,TYO7	 ;(# OF TTY DOING IT FOR PUT IN I)
	 JFCL		 ;(TYCREP WILL SKIP IF THAT INSN ALWAYS DOES)
	POP P,R
	POP P,TT
	POP P,U
	POP P,D
	POP P,C
	JRST TYO6

TYO7:	MOVE D,TTYCOM(I) ;IF THIS TTY WANTS MY TYPEOUT.
	TLNE D,RFT
	CAMN I,-2(P)	;AND IF IT ISN'T ME,
	 JRST POPJ1
	PUSHJ P,TYCSET	;SET UP ACS Q,W,R,U FOR TTY TO ECHO ON.
	CONO PI,TTYOFF
	PUSH P,A
	PUSHJ P,TTYI13	;ECHO CHAR ON THIS TTY.
	CONO PI,TTYON
	JRST POPAJ1


;A USUALLY HOLDS THE CHAR BEING IOTTED, OR THE CHAR TO BE PUT IN BUFFER.
;B IS A TEMP.
;C IS USUALLY UNUSED, AND MUSTN'T BE CLOBBER BY IOT RTN.
;D "
;E IS A TEMP.
;TT HOLDS THE INDEX OF THE PC PPR BEING USED.
;I HOLDS THE TTY NUMBER.
;H HOLDS THE TTY'S TTYOPT WORD.
;J HOLDS THE INDEX OF A 4-WORD BLOCK USUALLY ON THE STACK
;	INDEX USING TYOPV0, TYOPV1, TYOPV2, TYOPV3.
;T IS A TEMP.
;R'S RH HOLDS THE IOCHNM WORD'S LH.
;Q HOLDS THE BP FOR STORING IN OUTPUT BUFFER.
;	INITTED FROM TOIP, AND STORED BACK IN TOIP WHEN FINALIZED.
;W HAS MINUS # CHARS PUT IN BUFFER SINCE LAST FINALIZATION.
;	USED TO UPDATE TORM WHEN FINALIZED.

TYO6:	MOVE H,TTYOPT(I)
IFN N11TYS,[
	TRNN H,%TP11T	;FOR A PDP11 TV TTY,
	 JRST TYO8
	SKIPL TT11P	;IGNORE IT IF PDP11 ISN'T UP.
	 POPJ P,
	PUSHJ P,TYOWN	;WAIT TILL AT LEAST 30 CHARS SPACE.
]
;A,R,I,TT,H,J SET UP AT THIS POINT.
TYO8:	MOVE Q,TOIP(I)	;GET COPY OF BP TO STORE WITH.
		;WHEN OUTPUTTING CHARS, WILL UPDATE Q INSTEAD TOIP.
		;THEN, WHEN CAN NO LONGER PCLSR, DO TOIP(I)_Q.
	SETZ W,		;-<# CHARS IDPB'D ON Q>.
			;WHEN Q PUT IN TOIP, W IS ADDM'D TO TORM.
	MOVE B,TPFLAG(TT)
TYOIG1:	TRNE B,%TFEOP+%TFIGL	;ANY EXCEPTIONAL CONDITION FOR THIS PC PPR?
	 JRST TYOIGL	;IF SO, HANDLE IT.
TYOEO9:	TRNE R,%TICP1+%TICP2+%TISTP+%TISIO
	 JRST TYOCP1	;HANDLE ANY EXCEPTIONAL CONDITION FOR CHANNEL.
	CAIL A,40
	 JRST TYONRM
	CAIL A,^G
	CAIL A,^Q	;< ^G OR > ^P => NORMAL CTL CHAR,
	 JRST TYOCTL
	JRST @.+1-^G(A) ;ELSE DO WHAT THIS PARTICULAR ONE WANTS.

	TYOBEL		;^G DOESN'T MOVE CURSOR.
	TYOBS		;^H MOVES BACKWARDS.
	TYOTAB		;^I MOVES TO TAB STOP.
	TYOLF		;^J IS LINEFEED.
	TYOCTL		;^K IS NORMAL.
	TYOFF		;^L MAY CAUSE A **MORE**
	TYOCR		;^M IS A CARRET
	TYOCTL		;^N IS NORMAL
	TYOCTL		;^O IS NORMAL
	TYOCTP		;^P MAY SIGNIFY A CURSOR CTL CODE.

;OUTPUT A CHAR WITH NO CURSOR CONTROL.
;ASSUMES ITS POSITION DOESN'T MATTER.
TYOBEL:	PUSHJ P,TYOOUT
	JRST TYOFN2

;COME HERE WHEN ^P IS OUTPUT.
TYOCTP:	TRNN R,%TIDIS	;IS THIS OUTPUT CHNL TREATING ^P SPECIALLY?
	 JRST TYOCTL	;NO, TREAT ^P AS NORMAL CTL CHAR.
	TRO R,%TICP1	;YES, SAY TREAT NEXT CHAR AS CURSOR CODE.
	JRST TYOFNR

;COME HERE FOR ^PP - OUTPUT A ^P.
TYOCPP:	MOVEI A,^P

;COME HERE FOR NORMAL (NON-FORMATTING) CONTROLS.
TYOCTL:	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOASS	;PREPARE TO OUTPUT PRINTING CHARACTERS.
	TLNE H,%TOSAI
	 JUMPN A,TYONR0	;TTY HAS SAIL CHAR SET => CTL CHAR MOVES 1 SPACE.
	CAIN A,33
	 JRST TYOALT	;CHECK FOR ALTMODE.
	TRNE R,%TIECH	;ECHO-MODE OUT => PRINT IN ASCII MODE.
	 JRST TYOCT1
	MOVE B,TTYST1(I)
	TLNE B,%TGIMG_12. ;IF OUTPUTTING CTL CHARS IN IMAGE,
	 JRST TYORU1	;GO DO IT.
TYOCT1:	HRLM A,(P)	;ELSE OUTPUT CTL CHAR IN ASCII MODE,
	MOVEI A,"^	;AS "^" FOLLOWED BY UN-CTL'ED CHAR.
	IORI R,%TICP1	;IF WE PCLSR AFTER THE "^" IS FINALIZED,
		;THE CTL CHAR WILL BE INTERPRETED AS A ^P-CODE.
		;BUT CTL CHARS AFTER ^P COME OUT AS THE UN-CTL'D CHAR.
	PUSHJ P,TYONR1
	HLRZ A,(P)
	ADDI A,100
	ANDCMI R,%TICP1
	JRST TYONR0

;OUTPUT A NORMAL CHARACTER, AND FINALIZE. COME HERE FOR
;NORMAL CHAR ACTUALLY IOTTED.
TYONRM:	CAIN A,177
	 JRST TYORUB	;RUBOUT DOESN'T MOVE THE CURSOR.
	CAME TT,TTYLPP(I) ;ABOUT TO OUTPUT PRINTING CHARS SO
	 PUSHJ P,TYOASS	;FORCE ANY CURSOR MOTION INTO OUTPUT BFR

;CALL HERE TO OUTPUT NORMAL CHAR, IF CURSOR POSITIONING KNOWN
;NOT TO BE NECESSARY.
TYONR0:	PUSH P,[TYOFNA]	;CAUSE FINALIZATION WHEN FINISHED.

;CALL HERE TO OUTPUT NORMAL CHAR AS PART OF TASK OF OUTPUTTING
;SOME LARGER GROUP. DOESN'T FINALIZE, IN CASE WE PCLSR LATER.
TYONR1:	AOS B,TPHP(TT)	;ADVANCE CURSOR OF PC PPR 1 SPACE.
	CAML B,TCMXH(I)	.SEE TPHE(TT)	;NOT YET AT END OF LINE => OUTPUT CHAR.
	TRNE R,%TICTN	;AT END: NO CONTIN => OUTPUT,
	 JRST TYOOUT
	PUSHJ P,TYONR2	;CONTINUE THE LINE (NOTE CURSOR POS FOR
	CAME TT,TTYLPP(I)	;THE "!" WAS ALREADY DONE)
	 PUSHJ P,TYOASS	;TYONR2 DISSOCIATED THE TTY
	JRST TYONR1	;BUT TYONR1 NEEDS IT ASSOCIATED.

;TYPE "!<CR><LF>" TO CONTINUE A LINE.
;THIS FINALIZES THE !CRLF BUT ALSO REMOVES THE CONDITIONS WHICH
;CAUSED IT TO BE CALLED; SO PCLSRING IS NO PROBLEM.
;LEAVES TTY DISSOCIATED FROM PC PPR.
TYOCTN:	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOASS
	AOS TPHP(TT)	;ACCOUNT FOR THE "!".
TYONR2:	PUSH P,A
	MOVEI A,"!	;PUT "!" IN OUTPUT BUFFER,
	PUSHJ P,TYOOUT
	PUSHJ P,TYORCR	;AND GO TO NEXT LINE.
	PUSHJ P,TYOLF
	MOVE B,TPFLAG(TT) ;IF THAT LF TOOK US TO LAST LINE,
	TRNE B,%TFEOP
	 JRST TYOEO5	;DO **MORE** PROCESSING IF NEC.
	JRST POPAJ	;AND RETRY WHATEVER CAUSED CONTINUATION.

;COME HERE TO OUTPUT A LF. FINALIZES. LEAVES TTY DISSOCIATED.
TYOLF:	CAMN TT,TTYLPP(I) ;BEFORE MUNGING PC PPR'S CURSOR POS,
	 PUSHJ P,TYOMVC	;MUST DISASSOCIATE TTY'S POS FROM PC PPR.
	MOVE A,TTYSTS(I)
	AOS B,TPVP(TT)	;MOVE PC PPR'S CURSOR 1 LINE DOWN.
	CAML B,TCMXV(I) .SEE TPVE(TT)	;END OF RANGE => GO TO TOP OR SCROLL.
	 JRST TYOLFE
	TLNE A,%TSMOR	;IF **MORE** DESIRED,
	 JRST TYOLF1
	ADDI B,1	;THEN IF ENTERING LAST LINE OF RANGE,
	TRNN R,%TIMOR	;AND THIS OUTPUT CHNL IS WILLING,
	CAME B,TCMXV(I) .SEE TPVE(TT)
	 JRST TYOLF1
	TLNE A,%TSROL
	 SKIPGE TPVM(TT)
	SKIPA T,[%TFEOP] ;TELL NEXT OUTPUT ATTEMPT TO CAUSE **MORE**.
TYOLF1:	SETZ T,
	TLNN H,%TOERS	;IF TTY HAS SELECTIVE ERASE,
	 JRST TYOLF5
	PUSH P,TPHP(TT)
	PUSHJ P,TYORCR	;GO TO BEGINNING OF LINE
	MOVE A,TCTYP(I)	;ON A DATAPOINT,
	MOVE B,TPVP(TT)
	CAME B,TPVB(TT)	;UNLESS WE'RE WRAPPING AROUND,
	CAIE A,%TNDP	;OUTPUT %TDCRL = %TDMOV AND %TDEOL TOGETHER.
	 SKIPA A,[%TDEOL]
	SKIPA A,[%TDCRL]
	 PUSHJ P,TYOASS	;NORMALLY, OUTPUT MOVE-CURSOR AND %TDEOL.
	PUSHJ P,TYOOUT
	PUSHJ P,TYOMVC
	POP P,TPHP(TT)
TYOLF5:	IORM T,TPFLAG(TT)
	JRST TYOFND

;LINEFEED THAT WRAPS AROUND.
TYOLFE:	TLNN H,%TOMVU	;WRAPAROUND ON PRINTING TTY =>
	 JRST [MOVN A,TCMXV(I)	;PRETEND TO SCROLL ALL THE WAY TO TOP.
		JRST TYOLF6]
	TLNE A,%TSROL	;IN SCROLL MODE?
	SKIPE TPVB(TT)	;CAN'T SCROLL UNLESS PC PPR IS WHOLE SCREEN.
	 JRST TYOLF3
	MOVE A,TCTYP(I)
	SKIPN A,TYOLTB(A)	;ONLY SOME TYPES OF TTYS CAN SCROLL.
	 JRST TYOLF3
TYOLF6:	ADDM A,TPVP(TT)	;SCROLL: CHANGE VERT. POSITIONS.
	ADDM A,TPVM(TT)
	HRLZS A
	ADDM A,TTYLPS(I)
	JRST TYOLF1

TYOLF3:	TLNN H,%TOMVU	;ON DISPLAYS WITHOUT SELECTIVE ERASE,
	 JRST TYOLF4
	TLNN H,%TOERS
	 JRST TYOCLR	;MUST CLEAR SCREEN WHEN WRAP AROUND.
TYOLF4:	MOVE B,TPVB(TT)	;ELSE JUST MOVE TO TOP OF PC PPR
	MOVEM B,TPVP(TT)
	JRST TYOLF1	;AND CLEAR THE TOP LINE.

;INDEX BY TCTYP VALUE; 0 IF TTY CAN'T SCROLL, ELSE -<# LINES/GLITCH>
TYOLTB:	0 ? -1 ? -1 ? -10 ? 0 ? -1 ? 0 ? -1
IF2 IFN .-TYOLTB-%TNMAX,.ERR WRONG LENGTH TABLE.

;HANDLE BACKSPACE.
TYOBS:	MOVE B,TCTYP(I)
	CAIE B,%TNIML	;BACKSPACE ON IMLAC ISN'T SAME AS MOVE BACK.
	 JRST TYOBS1
	MOVE B,TPHP(TT)	;ON IMLAC, FIRST, IF AT LEFT MARGIN,
	SKIPGE B	.SEE TPHB(TT)	;DO NOTHING.
	 JRST TYOFN2
	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOASS	;IF WE SHOULD BACKSPACE,
	SOS TPHP(TT)
	JRST TYORU1	;DO IT BY SENDING A ^H.

TYOBS1:	TLNN H,%TOMVB	;ARE WE ECHOING ^H ON TTY THAT CAN'T BS?
	TRNN R,%TIECH
	 CAIA
	JRST TYOCTL	;ECHO "^H" RATHER THAN CR AND SPACE FWD.
	CAMN TT,TTYLPP(I) ;BS ON TTY THAT ISN'T AN IMLAC.
	 PUSHJ P,TYOMVC	;PREPARE TO DO CURSOR MOTION.
	SOS B,TPHP(TT)	;MOVE BACK 1 POS.
	SKIPGE B	.SEE TPHB(TT)
	 AOS TPHP(TT)	;AT LEFT MARGIN, DO NOTHING.
	JRST TYOFNX

;COME HERE WHEN TAB OUTPUT (AT TOP LEVEL ONLY)
TYOTAB:	TRNE R,%TIECH
	 JRST TYOTA1
	MOVE B,TTYST2(I)	;MAYBE TABS SHOULD BE OUTPUT IN IMAGE MODE.
	TLNE B,%TGIMG_6
	 JRST TYORUB
TYOTA1:	MOVE A,TPHP(TT)
	ADDI A,10
	TRZ A,7		;HPOS OF NEXT TAB STOP.
	MOVE B,TCMXH(I)	.SEE TPHE(TT)
	TRNN R,%TICTN
	 SUBI B,1	;B HAS EFFECTIVE LINEL.
	CAML A,B
	 MOVE A,B	;A HAS PLACE TAB MOVES TO.
TYOTA3:	SUB A,TPHP(TT)	;HOW FAR TO MOVE RIGHT?
	TRNN R,%TICTN
	 JUMPE A,[PUSHJ P,TYOCTN
		  JRST TYOTAB]
	CAMN TT,TTYLPP(I)
	 PUSHJ P,TYOMVC	;PREPARE FOR CURSOR CTL.
	ADDM A,TPHP(TT)	;MOVE CURSOR TO TAB STOP.
	JRST TYOFNX

;HANDLE ^L.
TYOFF:	TRNN R,%TIECH	;ECHOING?
	 JRST TYOFF1
	MOVE B,TTYSTS(I) ;YES; ^L ECHOES ASS "^L"
	TLNE H,%TOMVU	;EXCEPT ON DISPLAYS, UNLESS PRGM HAS DISABLED.
	TLNE B,%TSCLE
	 JRST TYOCTL	;ECHO AS "^L".
	JRST TYOCLR	;ECHO AS CLEAR SCREEN.

TYOFF1:	MOVE B,TTYST1(I) ;OUTPUTTING ^L:
	TLNE B,%TGIMG_12.
	 JRST TYOCTL	;IN IMAGE MODE, SEND A ^L.
	MOVE B,TTYSTS(I)
	TLNE B,%TSMOR	;IF **MORE** DISABLED, OUTPUT UPAROW-L.
	 JRST TYOCTL
	MOVEI B,%TFEOP
	IORM B,TPFLAG(TT) ;NEXT ATTEMPT TO OUTPUT LIKELY TO **MORE**
	JRST TYOFNR

;^M IOTTED - MAYBE DO CR AND LF.
TYOCR:	TRNE R,%TIECH	;IF ECHO MODE OUT, CR DOES CRLF.
	 JRST TYOCRL
	MOVE B,TTYST2(I)
	TRNE B,%TGIMG_12. ;ELSE OUTPUT-CR-IN-IMAGE PREVENTS LF.
	 JRST TYOCR1
	PUSHJ P,TYOCRL	;DO CR AND LF,
	MOVEI B,%TFIGL	;THEN SAY IGNORE NEXT CAHR IF IT'S A LF.
	IORM B,TPFLAG(TT)
	POPJ P,

TYOCRL:	PUSHJ P,TYOLF
TYOCR1:	PUSHJ P,TYORCR
	JRST TYOFND

;ALTMODE IOTTED - SHOULD WE OUTPUT "$"?
TYOALT:	MOVE B,TTYST2(I)
	TRNN R,%TIECH	;ECHO MODE => YES.
	TRNN B,%TGIMG_6	;OUTPUT ALT IN ASCII MODE SAYS YES.
	 JRST [MOVEI A,"$ ? JRST TYONR0]
	JRST TYORU1	;NO, ASSUME ALT TAKES NO SPACE.

;IF ABOUT TO CHANGE PC PPR'S CURSOR POS WITHOUT PUTTING
;ANYTHING IN THE OUTPUT BUFFER THAT WILL CHANGE THE TTY'S
;REAL CURSOR POS THE SAME WAY, MUST DISASSOCIATE TTY'S
;CURSOR POS FROM THIS PC PPR. TTYLHP AND TTYLVP WILL THEN
;SAY WHERE THE TTY'S CURSOR WILL BE AFTER CHARS IN OUTPUT
;BUFFER ARE ALL OUTPUT.
TYOMVC:	HRLZ B,TPVP(TT)
	HRR B,TPHP(TT)
	MOVEM B,TTYLPS(I)
	SETCAM TT,TTYLPP(I) ;TTY NO LONGER ASSOCIATED.
	POPJ P,

;BEFORE PUTTING ANYTHING IN OUTPUT BUFFER USING A PC PPR,
;TTY'S CURSOR MUST BE ASSOCIATED WITH PC PPR (THAT IS,
;THE TTY'S CURSOR MUST BE WHERE THE PC PPR'S CURSOR IS)
;WHEN A TTY IS ASSOCIATED WITH A PC PPR, TTYLHP AND TTYLVP
;ARE NONSENSE, AND IT IS NECESSARY FOR OUPUT RTNS
;TO UPDATE PC PPR'S CURSOR IN ACCORDANCE WITH WHAT
;IS PUT IN THE OUTPUT BUFFER.
;THIS ROUTINE ASSOCIATES TTY IN I WITH PC PPR IN TT.
TYOASS:	TRNE R,%TIHDE
	 POPJ P,
TYOAS1:	PUSH P,A
	HLRZ A,TTYLPS(I)
	CAME A,TPVP(TT) ;IF CURSOR IS WHERE WE WANT IT,
	 JRST TYOAS2
	HRRZ A,TTYLPS(I)
	CAMN A,TPHP(TT)
	 JRST TYOAS3	;JUST SAY WE'RE ASSOCIATED.
TYOAS2:	MOVEI A,%TDMOV	;TELL THE TTY TO PUT ITS CURSOR
	PUSHJ P,TYOOUT	;WHERE THIS PC PPR WANTS IT.
	HLRZ A,TTYLPS(I)
	PUSHJ P,TYOOUT	;GIVING IT ITS OLD POSITION
	HRRZ A,TTYLPS(I)
	PUSHJ P,TYOOUT
	MOVE A,TPVP(TT)
	CAML A,TCMXV(I)
	 JRST 4,.
	PUSHJ P,TYOOUT	;AND THE NEW POSITION.
	MOVE A,TPHP(TT)
	PUSHJ P,TYOOUT
TYOAS3:	MOVEM TT,TTYLPP(I) ;TELL TTY IT IS ASSOCIATED.
	SETOM TTYLPS(I)
	JRST POPAJ

;FORCE OUT BUFFERED CURSOR MOTION.
;CALL ONLY IF TTY DISSOCIATED, FROM M.P. OR CLOCK LEVEL.
TYOFRC:	MOVE Q,TOIP(I)
	SETZ W,
	PUSHJ P,TYOASS
	JRST TYOFN2

;PUT CHAR IN OUTPUT BFR (BUT IT DOESN'T BECOME VISIBLE
;TO INT. LEVEL UNTIL WE FINALIZE - IN CASE WE PCLSR)
TYOOUT:	TRNE R,%TIHDE
	 POPJ P,
	PCLT
	MOVN T,W
	CAML T,TORM(I)	;NO ROOM IN BUFFER =>
	 PUSHJ P,TYOW1	;WAIT TILL THERE IS.
TYOOU1:	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	HRRZI T,(Q)
	CAILE T,@TOBEP(I)
	 JRST 4,.
	IDPB A,Q
	SOJA W,CPOPJ

;FINALIZE, UPDATING TOIP, TORM AND FLAGS.
;ALSO RESET Q, W FOR ANOTHER BUNCH OF OUTPUT.
TYOFNX:	;FINALIZE WHEN TTY DISSOCIATED AND NOTHING PUT IN BFR.
TYOFND:	;SIMILAR, WHEN SOMETHING MIGHT HAVE BEEN PUT IN BFR.
TYOFNA:	;FINALIZE WHEN TTY ASSOCIATED W/ PC PPR.
	MOVE B,TTYLPS(I)
	MOVEM B,TYOPV1(J)
TYOFN1:	MOVE B,TPHP(TT)	;FINALIZE CURSOR POS CHANGES.
	HRL B,TPVP(TT)
	MOVEM B,TYOPV0(J) ;PUT NEW POS WHERE FINSET RTN LOOKS.
TYOFN2:	MOVEM Q,TOIP(I)
IFN N11TYS,TRNN H,%TP11T
	 ADDM W,TORM(I)
	SETZ W,
	AOSN TTYOAC(I)	;START THE TTY.
	 XCT TTYST(I)
	JRST TYOFNR

;ON ORDINARY TTY, CALL WHEN BUFFER FULL.
;WAIT TILL AT LEAST 3/4 EMPTY. T HAS MINIMUM # CHARS NEEDED.
TYOW1:	CAIGE T,TOBS*3/4	;DON'T UNBLOCK TILL BUFFER AT LEAST 3/4 EMPTY.
	 MOVEI T,TOBS*3/4
	MOVEM I,EPDL3(U)	;MAY TRAP OUT ON SYSTEM JOB
	JUMPN U,TYOW4
	JRST TYOW5	;HANG UP SYS JOB FOR MAX OF 5 SEC

	PUSHJ P,TYOW6
TYOW5:	PUSHJ P,UFLS
	MOVE T,TIME
	SUB T,TTLTM(I)
	CAIG T,5*30.
	POPJ P,	;OK ROOM EXISTS
	SUB P,[1,,1]	;TIMED OUT
	POPJ P,

	CAMLE T,TORM(I)
TYOW4:	PUSHJ P,UFLS
	POPJ P,

TYOW6:	MOVE A,AC0S+U(U) ;(IN CASE U DIDN'T EQUAL USER AT TYOW1)
	MOVE A,EPDL3(A)	;IF SYS JOB, FLUSH IF NO CHR PROCESSED FOR 15 SEC
	MOVE Q,TIME
	SUB Q,TTLTM(A)
	CAILE Q,5.*30.
	JRST POPJ1	;TIME OUT (FOR PSEUDO TTYS AND TTYS WITH FRIED DONE FLAGS)
	MOVE Q,TTYTYP(I)	;IF THIS IS A PDP-11 TV,
	TRNE Q,%TY11T	;WE CALLED HERE FOR TYOWN, NOT TYOW1.
	 JRST TYOW7
	CAMG T,TORM(A)
	AOS (P)
	POPJ P,	;NO ROOM

TYOW7:	LDB A,T
	JUMPN A,POPJ1
	POPJ P,

;ON A PDP-11 TV, CALL HERE TO WAIT UNTIL THERE ARE AT LEAST
;20. CHARS OF SPACE IN THE OUTPUT BUFFER.
TYOWN:	PUSHJ P,TYOWN1
	LDB B,T		;IS THE POS. 20. CHARS UP VACANT?
	JUMPN B,CPOPJ	;YES, NO NEED TO WAIT.
	JUMPN U,TYOWN2	;IF SYS JOB, TIME OUT BEFORE TOO LONG.
	MOVEM I,EPDL3(U)
	JRST TYOW5

TYOWN2:	MOVSI B,2	;NOT SYS JOB, ISOLATE IN B THE BIT THAT
	TLNE T,400000	;THE BP IN T WOULD LDB.
	 MOVSI B,400000
	EXCH B,T
	TDNN T,(B)	;WAIT FOR BUFFER CELL TO EMPTY.
	 PUSHJ P,UFLS
	POPJ P,

IFNDEF TYOWNC,TYOWNC==20.

TYOWN1:	MOVE T,TOIP(I)
	ADDI T,TYOWNC/2
	HRRZ B,TOBEP(I)
	CAIGE B,(T)
	 SUB B,TT11OL
	ADD T,[210000-2100,,]
	POPJ P,

;COME HERE WHEN DETECT THAT %TFEOP OR %TFIGL IS SET.
TYOIGL:	TRZN B,%TFIGL	;%TFIGL TAKES PRIORITY.
	 JRST TYOEOP
	MOVEM B,TPFLAG(TT) ;CLEAR IT, AND IGNORE THIS CHAR
	CAIE A,^J
	 JRST TYOIG1
	POPJ P,

;%TFEOP IS SET AND OUTPUT IS DONE: DO **MORE** PROC.
TYOEOP:	PUSH P,[TYOEO9]
	PUSH P,A
TYOEO5:	SKIPE USER
	TRNE R,%TIMOR+%TIECH
	 JRST POPAJ
	MOVSI T,%TCINP	;IF THE USER WAITED FOR INPUT
	TDNE T,TTYCOM(I) ;NEAR BOTTOM OF SCREEN,
	 JRST [	ANDCAM T,TTYCOM(I)
		MOVEI T,%TFEOP	;SUPPRESS 1 **MORE**.
		ANDCAM T,TPFLAG(TT)
		JRST POPAJ]
	MOVE B,TCMXV(I)	.SEE TPVE(TT)
	MOVEM B,TPVM(TT)
	MOVE B,TYOMSK(I) ;HAS USER ENABLED OUTPUT INTERRUPT?
	AND B,MSKST2(U)
	JUMPE B,TYOEO1	;NO, SYSTEM DOES **MORE** PROC.
	MOVN T,B	;YES, JUST GIVE USER INT
	AND T,B
	IORM T,IFPIR(U)	;HE CAN TYPE **MORE** IF HE WANTS TO.
	MOVEI B,%TFEOP
	ANDCAM B,TPFLAG(TT) ;INT. HAS BEEN GIVEN.
	PUSHJ P,TYOUN1	;LSWPOP THE FINSET, ETC.
	JFCL
	PUSHJ P,UFLS	;MAKE HIM TAKE THE INT. RIGHT NOW.

;COME HERE AT END OF PAGE IF PROGRAM ISN'T SMART.
TYOEO1:	PUSH P,TPHP(TT)
	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOASS
	IRPC X,,**MORE**
	MOVEI A,"X
	PUSHJ P,TYONR1
	TERMIN		;OUTPUT THE STRING "**MORE**"
	PUSHJ P,TYOMVC	;PREPARE FOR CURSOR-CONTROL.
	IORI R,%TISTP	;MAKE ALL OUTPUT ON THIS CHNL HANG.
	MOVEI B,%TFEOP	;NO LONGER WANT NEXT CHAR TO DO **MORE**
	ANDCAM B,TPFLAG(TT)
	POP P,TPHP(TT)	;IS PUT ON BOTTOM LINE.
	PUSHJ P,TYOFND	;FINALIZE SO "**MORE**" WILL TYPE OUT;
	 ;PCLSRING NO PROBLEM; SINCE %TISTP IS SET THE IOT
	 ;WILL COME TO TYOEO3.
	TRNE H,%TP11T
	 PUSHJ P,TYOWN
TYOEO3:	PCLT
	MOVEI T,TOBS	;WAIT FOR ALL OF "**MORE**" TO GET OUT.
	CAME T,TORM(I)
	 PUSHJ P,UFLS
	PUSH P,C
	PUSH P,D
	PUSH P,R
	PUSH P,TT
	MOVEI R,%TIPEK+%TIACT+%TIECH
	PUSHJ P,TYI0	;LOOK AHEAD AT NEXT INPUT CHAR.
	MOVSI C,%TCINP
	ANDCAM C,TTYCOM(I)
	EXCH TT,(P)
	EXCH R,-1(P)
	MOVE Q,TOIP(I)
	TRZN R,%TICP1	;UNLESS THIS IS ^PN
	 PUSHJ P,TYOHD1	;HOME UP (BY HOMING DOWN AND LF'ING)
	PUSHJ P,TYOLF	;OTHERWISE (FOR ^PN) JUST LF.
	EXCH TT,(P)
	EXCH R,-1(P)
	ANDI D,177
	CAIN D,40	;IF A SPACE, FLUSH IT FROM INPUT BFR
	 PUSHJ P,TYIREM
	POP P,TT
	POP P,R
	POP P,D
	POP P,C
	ANDCMI R,%TISTP	;RETURN CHANNEL TO NORMAL.
	MOVE Q,TOIP(I)
	PUSHJ P,TYOFNR
	POP P,A		;RESTORE THE CHAR BEING IOTTED
	POPJ P,		;AND TRY AGAIN TO IOT IT.

TYOEO2:	PUSH P,[TYOEO9]
	PUSH P,A	;COME HERE IF PCLSR OUT OF TYOEO3, ETC.
	JRST TYOEO3	;WHEN THE IOT IS RETRIED.

TYOCP1:	TRNE R,%TISTP
	 JRST TYOEO2
;HANDLE CURSOR CONTROL CODES. COME HERE WITH IOTTED CHAR IN A.
;IF WE ARE IN THE MIDDLE OF A ^P CODE.
;OR IF THE CHANNEL IS A SUPERIMAGE OUTPUT CHANNEL.
	TRZE R,%TICP2	;AFTER A ^PV OR ^PH ?
	 JRST TYOCP2
	TRZE R,%TICP1	;NO, NEXT CHAR ISN'T IN THE ^P CODE.
	 JRST TYOBEL	;MUST BE %TISIO THAT WAS SET.
	CAIGE A,40	;CTL CHARS AS ^P CODES COME OUT
	 JRST [	ADDI A,100	;AS THE UN-CONTROLLED CHARS.
		JRST TYONRM]
	CAIL A,"A	;IF ^P CODE IS A LETTER,
	CAILE A,"Z
	 JRST TYOCP3
	XCT TYOCPT-"A(A)	;DISPATCH ON IT.
TYOCPR:	MOVEI B,%TFEOP
	ANDCAM B,TPFLAG(TT)
	JRST TYOFNX

;[
TYOCP3:	CAIN A,"]	;^P CODE NOT CTL CHAR OR MEANINGFUL LETTER.
	 JRST TYOCEL	;EITHER IT IS CLEAR-EOL
	PUSHJ P,TYOUN1	;OR IT'S ILLEGAL.
	JRST IOCR11	;IOC ERROR.

TYOCPV:	IORI R,%TICP1	;HERE FOR ^PV
TYOCPH:	IORI R,%TICP2	;SAME FOR ^PH. SAY NEXT CHAR IS THE CURSOR POS.
TYOFNR:	HRLM R,@TYOPV2(J)
	POPJ P,

TYOCP2:	CAMN TT,TTYLPP(I) ;INTERPRET THE CHAR AFTER ^PH OR ^PV.
	 PUSHJ P,TYOMVC
	TRZN R,%TICP1	;WHICH OF THOSE 2 WAS IT?
	 JRST TYOCH1	;IT WAS ^PH
	ADD A,TPVB(TT)
	SUBI A,10
	CAML A,TCMXV(I) .SEE TPVE(TT)	;DON'T PUT CURSOR PAST END.
	 JRST [	MOVE A,TCMXV(I) .SEE TPVE(TT)
		SOJA A,.+1]
	CAMGE A,TPVB(TT)	;OR BEFORE BEGINNING.
	 MOVE A,TPVB(TT)
	MOVEM A,TPVP(TT)
	JRST TYOFNX

TYOCH1:	.SEE ADD A,TPHB(TT)
	SUBI A,10
	CAML A,TCMXH(I) .SEE TPHE(TT)	;DON'T PUT CURSOR PAST END.
	 JRST [	MOVE A,TCMXH(I) .SEE TPHE(TT)
		SOJA A,.+1]
	SKIPGE A	.SEE TPHB(TT)	;OR BEFORE BEGINNING.
	 SETZ A,	.SEE TPHB(TT)
	MOVEM A,TPHP(TT)
	JRST TYOFNX

;DISPATCH TABLE FOR ^P CODES.
TYOCPT:	JRST TYOCP3	;A - ILLEGAL.
	PUSHJ P,TYOMVB	;B - MOVE BACK.
	JRST TYOCLR	;C - CLEAR SCREEN.
	PUSHJ P,TYOMVD	;D - MOVE DOWN.
	JRST TYOCEF	;E - CLEAR TO END OF SCREEN.
	PUSHJ P,TYOMVF	;F - MOVE FORWARD.
	JRST TYOCP3	;G - ILLEGAL.
	JRST TYOCPH	;H - NEXT CHAR IS DESIRED HPOS.
	JRST TYOCP3	;I - ILLEGAL.
	JRST TYOCP3	;J - ILLEGAL.
	JRST TYODLF	;K - DELETE FORWARD.
	JRST TYOCEL	;L - CLEAR REST OF LINE.
	JRST TYOMOR	;M - DO **MORE**.
	JRST TYOMO1	;N - SIMILAR BUT DON'T HOME UP.
	JRST TYOCP3	;O - ILLEGAL.
	JRST TYOCPP	;P - TYPE "^P".
	JRST TYOCP3	;Q - ILLEGAL.
	PUSHJ P,TYORPS	;R - RESTORE SAVED POS.
	JRST TYOSPS	;S - SAVE POSITION (FOR A ^PR).
	PUSHJ P,TYOHMU	;T - HOME UP.
	PUSHJ P,TYOMVU	;U - MOVE UP.
	JRST TYOCPV	;V - NEXT CHAR IS DESIRED VPOS.
	JRST TYOCP3	;W - ILLEGAL.
	JRST TYODLB	;X - DELETE BACKWARDS.
	JRST TYOCP3	;Y - ILLEGAL.
	PUSHJ P,TYOHMD	;Z - HOME DOWN.

IFN .-26.-TYOCPT,.ERR WRONG LENGTH TABLE.

;RTNS FOR VARIOUS ^P CODES.
;NONE OF THESE FINALIZE ANYTHING.
TYOMVF:	CAMN TT,TTYLPP(I) ;^PF
	 PUSHJ P,TYOMVC	;PREPARE FOR CURSOR MOTION.
	AOS B,TPHP(TT)
	SETZ A,		.SEE TPHB(TT)
	CAML B,TCMXH(I)	.SEE TPHE(TT)	;WRAP AROUND FROM LAST POS. TO FIRST.
	 MOVEM A,TPHP(TT)
	POPJ P,

TYOMVD:	CAMN TT,TTYLPP(I) ;^PD
	 PUSHJ P,TYOMVC	;PREPARE FOR CURSOR MOTION.
	AOS B,TPVP(TT)
	MOVE A,TPVB(TT)
	CAML B,TCMXV(I)	.SEE TPVE(TT)	;WRAP AROUND FROM LAST POS. TO FIRST.
	 MOVEM A,TPVP(TT)
	POPJ P,

TYOMVB:	CAMN TT,TTYLPP(I)	;^PB - MOVE BACK.
	 PUSHJ P,TYOMVC
	SOS B,TPHP(TT)
	MOVE A,TCMXH(I)	.SEE TPHE(TT)	;WRAP AROUND FROM FIRST TO LAST.
	SUBI A,1
	SKIPGE B	.SEE TPHB(TT)
	 MOVEM A,TPHP(TT)
	POPJ P,

TYOMVU:	CAMN TT,TTYLPP(I)	;^PU - MOVE UP.
	 PUSHJ P,TYOMVC
	SOS B,TPVP(TT)
	MOVE A,TCMXV(I)	.SEE TPVE(TT)	;WRAP AROUND FROM FIRST TO LAST.
	SUBI A,1
	CAMGE B,TPVB(TT)
	 MOVEM A,TPVP(TT)
	POPJ P,

TYOSPS:	MOVE B,TPHP(TT)	;^PS - SAVE CURSOR POS.
	HRL B,TPVP(TT)
	MOVEM B,TPSP(TT)
	JRST TYOFNR

TYORPS:	CAMN TT,TTYLPP(I) ;^PR - RESTORE CURSOR POS FROM SAVED.
	 PUSHJ P,TYOMVC
	MOVE B,TPSP(TT)
	HRRZM B,TPHP(TT)
	HLRZM B,TPVP(TT)
	POPJ P,

;^PM AND ^PN DON'T WORK IN PROGRAMS THAT TAKE **MORE**
;INTERRUPTS - OR, PRECISELY, THEY ALWAYS ENTER
;THE STATE OF A CHANNEL THAT HAS JUST TYPED OUT "**MORE**".
TYOMO1:	IORI R,%TICP1	.SEE TYOEO3	;^PN - ENTER **MORE** STATE.
TYOMOR:	IORI R,%TISTP			;^PM.
	JRST TYOFNR

TYOCLR:	TLNN H,%TOMVU	;^PC - CLEAR SCREEN.
	 JRST TYOCRL	;ON PRINTING TTYS, JUST CRLF.
	PUSHJ P,TYOHMU
TYOCEF:	SKIPA A,[%TDEOF] ;^PE CLEAR EOF
TYOCEL:	 MOVEI A,%TDEOL	;[  ^P] - CLEAR EOL.
TYORUB:	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOASS	;MOVE THE REAL CURSOR,
TYORU1:	PUSHJ P,TYOOUT	;FOR A NO-SPACE CHAR WHOSE POSITION MATTERS.
	JRST TYOFNA

TYOHMU:	MOVSI T,%TCINP	;^PT - HOME UP
	ANDCAM T,TTYCOM(I)
	PUSHJ P,TYORCR	;GO TO COLUMN 0,
	MOVE B,TPVB(TT)	;LINE 0.
	MOVEM B,TPVP(TT)
	POPJ P,

TYORCR:	CAMN TT,TTYLPP(I) ;GO TO COLUMN 0 -  CR IN IMAGE MODE.
	 PUSHJ P,TYOMVC
	SETZ B,	.SEE TPHB(TT)
	MOVEM B,TPHP(TT)
	POPJ P,

TYOHMD:	PUSHJ P,TYORCR	;^PZ - HOME DOWN.
TYOHD1:	MOVE B,TCMXV(I)	.SEE TPVE(TT)
	SUBI B,1
	MOVEM B,TPVP(TT)
	POPJ P,

TYODLB:	PUSHJ P,TYOMVB	;^PX - DELETE BACKWARD.
TYODLF:	MOVE B,TPHP(TT)
	CAML B,TCMXH(I)	.SEE TPHE(TT)	;DO NOTHING AT END OF LINE.
	 POPJ P,
	MOVE B,TCTYP(I)
	MOVEI A,%TDDLF	;^PK - ERASE 1 CHARACTER.
	CAIE B,%TNDP
	 JRST TYORUB
	MOVEI A,40
	PUSHJ P,TYONRM
	JRST TYOBS	;(THIS CAN'T PCLSR)

;DEVICE DEP STATUS FOR TTY
;2.4 HAS "TTY"
;2.3 DDT MODE ON INPUT
;(STATYI);2.5 CHRS HAVE BEEN ITYI'ED BUT NOT .IOT'ED (STATYI)
	;2.8 TELETYPE NEXT TO 340 OR 340 SLAVE
	;2.9  TELETYPE IS LOCAL, NOT DIAL IN

STATYO:	ANDI A,77
	CAIN A,%TINON	;IF CHANNEL HAS NO REAL TTY,
	 POPJ P,	;THERE ARE NO SPECIFICS WE CAN SAY.
	SKIPN B,TORM(A)
	TRO D,1_9.	;BUF CAP FULL
	CAIN B,TOBS
	TRO D,1_<9.+1>	;BUFFER CAP EMPTY
STATY1:	SKIPL TTYTBL(U)
	TRO D,1_<9.+3>	;HAS TTY
	IORI D,SNTTY
	MOVE H,TTYOPT(A)
	TLNE H,%TOERS
	 TRC D,SNTTY#SNTDS
	POPJ P,

STATYI:	ANDI A,77
	CAIN A,%TINON	;CATCH "DISOWNED" TTY CHNLS.
	 POPJ P,
	SKIPN B,TICC(A)
	TRO D,1_<9.+1>	;BUF CAP E
	CAIL B,TIBS-10.
	TRO D,1_9.	;BUF CAP NEARLY FULL
	LDB B,[400400,,TTYTYP(A)]	;GET LOCAL AND 340 MDS
	DPB B,[160400,,D]	;DEPOSIT IN STATUS WORD
	CONO PI,TTYOFF
	MOVE TT,TICC(A)
	CAMLE TT,TINTC(A)
	TRO D,20000	;MORE CHRS HAVE BEEN ITYI'ED THAN .IOT'ED
	CONO PI,TTYON
	JRST STATY1


;TTY CLOSE ROUTINES

;INPUT CLOSE

TYICLS:	JSP E,TYCLOS	;IGNORE FOR DISOWNED CONSOLE
	ANDCAM B,TYIMSK(A)	;INDICATE CHANNEL CLOSURE
	JRST TYICL2

TYOW:	ANDI A,77
	SKIPN USER
	POPJ P,
IFN N11TYS,[
	MOVE T,TTYTYP(A)
	TRNE T,%TY11T
	 POPJ P,
]
	MOVEI T,TOBS
	PCLT
	CAME T,TORM(A)
	PUSHJ P,UFLS	;WAIT FOR TYPE OUT TO COMPLETE
	POPJ P,

TYOWC:	MOVEM A,EPDL3(U) ;SAVE TTY # FOR FLUSH INSN.
IFN N11TYS,[
	MOVE T,TTYTYP(A)
	TRNE T,%TY11T
	 POPJ P,
]
	MOVEI T,TOBS	;WAIT TILL OUTPUT BUFFER EMPTY
	MOVE I,A
	PUSHJ P,TYOW5	;BUT DON'T WAIT TOO LONG.
	POPJ P,		;TYOW5 MAY POP1J.

TYCLOS:	LDB I,[210100,,A]
	ANDI A,77	;THROW AWAY TOP BITS OF IOCHNM WD, GET TTY #.
	CAIN A,%TINON	;FOR A CHNL IN A TTYLESS TREE,
	 POPJ P,	;DON'T SOS ANYONE'S TTNTO.
	SKIPGE APRC(U)	;SKIP UNLESS DISOWNED
	JUMPN I,[JRST 4,.] ;DISOWNED JOB HAS REAL CONSOLE TTY?
	SKIPGE TTYTBL(U);IF IT'S A CONSOLE AND THIS JOB DOESN'T
	 JUMPN I,TYICL2	;HAVE TTY, DON'T CHANGE TYIMSK OR TYOMSK.
	MOVE R,UUAC(U)
	MOVE B,CHNBIT(R) ;GET THE BIT TO CLEAR IN TYIMSK OR TYOMSK.
	JRST (E)	;RETURN & CLEAR IT.

;OUTPUT CLOSE

TYOCLS:	JSP E,TYCLOS	;IGNORE FOR DISOWNED CONSOLE
	SKIPE USER
	PUSHJ P,TYOWC	;WAIT A WHILE FOR OUTPUT TO FINISH
	ANDCAM B,TYOMSK(A)	;SET OF OUTPUT CHNLS OPEN.
TYICL2:	SOSLE TTNTO(A)
	POPJ P,		;MORE OPENS ON TTY
	SKIPE TTNTO(A)
	JRST 4,.
	MOVE B,TTYSTS(A)
	TLNE B,%TSCNS
	POPJ P,		;OPEN AS CONSOLE
	JRST TTYLO1

;TTY # IN A - MAKE THE TTY FREE.
TTYLO1:	SETZM TTNTO(A)
	HRLOI B,%TSFRE	
	IORB B,TTYSTS(A) ;SAY TTY FREE (BUT TTYSTA OFF SO CAN'T ^Z)
	SKIPGE TTYSTA(A)
	POPJ P,
	PUSHJ P,TTYLFC	;REMOVE TTY FROM COM MODE AND RESET IN
	PUSHJ P,TYIRS0
IFN TTLPTP,[
	CAMN I,LPTTTY	;IF TTY'S THE LPT, IT'S NOT IN USE.
	SETOM LPTUSR
]
	MOVE T,TTYTYP(I)
	TRNE T,%TYDIL	;DIALUP LINE => MAKE IT PRINTING.
	 PUSHJ P,NCNSSP
	MOVEI B,10000
	IORM B,SUPCOR	;REQUEST A CONSOLE-FREE MESSAGE.
	MOVE A,I	;IN CASE OUR CALLER WANTS TTY # IN A.
	POPJ P,

TTYLFC:	MOVE I,A
	CONO PI,TTYOFF
	SKIPL Q,TTYCOM(A)
	JRST TTYLO3
	PUSH P,I
	PUSH P,U
	PUSHJ P,TYCSET	;SET UP ACS FOR COM MODE RTNS.
	TLZ Q,%TCCBK+%TCTMP+%TCTPN+%TCCBS
	MOVEM Q,TTYCOM(I)	;FLUSH COM MODE TEMP FLAGS.
	HRREI D,(Q)
	PUSHJ P,[AOJE D,TYCI33	;IF NOT LINKED, JUST LEAVE COM MODE.
		 JRST TYCGTM]	;ELSE UNLINK FIRST USING ^_N CODE.
	POP P,U
	POP P,I
TTYLO3:	MOVE A,I
	MOVEI B,TTYI
	MOVEM B,TTYIPC(A)
	POPJ P,

;TELETYPE IO PUSHDOWN ROUTINES

TYOIOP:	TDZA A,A		;OUUTPUT CHNL.
TYIIOP:	MOVEI A,TYIMSK-TYOMSK	;INPUT CHNL, SET TYIMSK INSTEAD TYOMSK.
	CONO PI,CLKOFF	;TO PREVENT TELETYPE (IF CONSOLE) FROM MOVING AROUND
	JUMPGE B,TYIOP1	;JUMP IF OPEN AS DEVICE
	SKIPGE TTYTBL(U)	;IF PROCEDURE DOESN'T HAVE CONSOLE,
	JRST CLKONJ	;THEN THAT'S ALL
TYIOP1:	LDB E,[220600,,B]	;GET TTY NUMBER IN E
	ADDI E,(A)		;IF INPUT, TYOMSK(E) WILL BE TYIMSK VAR.
	MOVE R,UUAC(U)	;GET "AC FIELD" (IO PUSHDOWN ROUTINES RESTORE R)
	MOVE A,CHNBIT(R)	;GET RELEVANT CHANNEL INTERRUPT BIT
	XCT TYIOPT(I)	;IORM OR ANDCAM A TO TYOMSK(E)
	JRST CLKONJ	;RETURN

TYIOPT:	ANDCAM A,TYOMSK(E)	;IOPUSH (PSEUDO-CLOSE)
	IORM A,TYOMSK(E)	;IOPOP (PSEUDO-OPEN)

;TTY RESET ROUTINES

;TTY INPUT RESET

TYIRS:	PUSHJ P,TTYRST
TYIRS0:	MOVSI T,LFT+ICO
	PUSHJ P,TTYCMW
	CONO PI,TTYON#77
TYIRS1:	MOVE B,TIIP(I)	.SEE STYORS
	MOVEM B,TIOP(I)
	MOVEM B,TINTP(I)
	MOVEM B,ECHOP(I)
	SETZM ECHOC(I)
	CLEARM TICC(I)
	CLEARM TACC(I)
	CLEARM TINTC(I)
	JRST TTYONJ

;OUTPUT RESET

TYORS:	PUSHJ P,TTYRST	;HANG UNTIL HAS TTY.  TTY NUMBER IN I.
	MOVSI T,LFT+OCO
	PUSHJ P,TTYCMW	;HANG UNTIL OUT OF COM MODE
	MOVSI B,%TICP1+%TICP2+%TISTP	;IF LAST CHAR THIS CHNL WAS ^P,
	ANDCAM B,(R)	;FORGET IT. ALSO UNHANG CHANNEL FROM **MORE**.
	MOVE TT,I
	IMULI TT,TPLEN*2
	MOVEI B,%TFEOP+%TFIGL ;RESTORE BOTH PCS OF PPR TO NORMAL STATE.
	ANDCAM B,TPFLAG(TT)
	ANDCAM B,TPFLAG+TPLEN(TT)
TYORS1:	MOVE B,TTYOPT(I) ;IS OUTPUT RESET SUPPOSED TO DO SOMETHING?
	TRNN B,%TPORS	;(ON FAST TTYSS IT DOESN'T)
	 JRST UTCONJ
	MOVEI B,TOBS
	MOVEM B,TORM(I)
	MOVE B,TOIP(I)
	MOVEM B,TOOP(I)	;FLUSH STUFF FROM OUTPUT BUFFER,
	SKIPGE TT,TTYLPP(I)
	 SETCMB TT,TTYLPP(I)
	MOVE B,TTYIHP(I)	;AND UNDO MAIN PRGM CURSOR POS MVT
	MOVEM B,TPHP(TT)
	MOVE B,TTYIVP(I)
	MOVEM B,TPVP(TT)
	SETOM TTYLPS(I)
	JRST UTCONJ

IFN N11TYS,[

;CALL HERE FROM CLOCK LEVEL WHEN THERE IS INPUT FROM THE PDP-11.
;TAKE CHARACTERS FROM THE PDP11 AND CALL THE TTY INPUT INT. LVL.
;ROUTINES WITH THEM ONE AT A TIME. MAY CLOBBER ANY ACS.
TT11IN:	LDB TT,[242000,,@TT11HD]
	SETZM @TT11HD	;GET AND RESET CHAIN OF INPUT BUFFERS.
;HANDLE THE NEXT INPUT BUFFERFULL. PDP11 ADDRESS IN TT.
TT11I1:	LSH TT,-1	;CONVERT PDP11 ADDRESS TO PDP10 ADDR.
	ADDI TT,TTPG0*2000+400000
	LDB A,[242000,,(TT)] ;GET -<# CHARS IN BUFFER>
	LDB I,[242000,,2(TT)] ;GET # OF TTY THE CHARS ARE FOR.
	ADDI I,NF11TY
	MOVEI B,2(TT)	;SET UP BP TO DATA AREA OF BUFFER.
	HRLI B,242000	;EACH CHAR IS 16. BITS - A PDP11 WORD.
	PUSH P,TT	;SAVE BUFFER ADDR SO CAN FIND NEXT BFR.
	CONO PI,TTYOFF-1
	JUMPE A,TT11I4
	PUSH P,A
	PUSH P,B
TT11I2:	ILDB A,(P)	;GET NEXT CHAR FROM BFR,
	PUSHJ P,NTYI5	;PRETEND IT CAME FROM A TTY CONTROLLER INT.,
	AOSE -1(P)
	 JRST TT11I2	;MORE CHARS => HANDLE THEM.
	SUB P,[2,,2]
TT11I3:	CONO PI,TTYON-1
	POP P,A		;ADDR. OF BUFFER JUST EMPTIED.
	LDB TT,[042000,,1(A)] ;GET ADDR OF NEXT BUFFER.
	SETZB B,(A)	;THIS BUFFER NOW FREE.
	DPB B,[042000,,1(A)]
	JUMPN TT,TT11I1	;LOOK AT NEXT ONE, IF ANY.
	POPJ P,

TT11I4:	PUSHJ P,TYPEND	;INPUT BUFFER WITH 0 CHARS SAYS OUTPUT BUFFER
	JRST TT11I3	;IS EMPTY, SO MAYBE REQUEST ECHOING.

;FORMAT OF AN INPUT BUFFER: (ALL POINTERS ARE PDP11 ADDRS)
;PDP11 WORD #,	...	  MEANING.
;	0	...	0 => FREE, ELSE -<# DATA CHARS>.
;	1	...	ZERO, ALWAYS.
;	2	...	-> NEXT BUFFER FOR THIS TTY.
;	3	...	-> NEXT ACTIVE BUFFER.
;	4	...	KEYBOARD NUMBER (= <TTY #>-NF11TY)
;	5+	...	DATA CHARS, 1 PER PDP11 WORD.
]

;COME HERE FROM VERY SLOW CLOCK (13.SEC), RUNNING IN SYS JOB.
;TURN OFF MOTORS OF ALL TERMINETS THAT HAVE BEEN IDLE 30. SEC.
;MAY CLOBBER ANY ACS.
TTTMNT:	MOVSI I,-NCT
	MOVE TT,TIME
	SUBI TT,900.	;T=30. SECONDS AGO.
TTTMN0:	LDB T,[$TPPCR,,TTYOPT(I)]
	CONO PI,TTYOFF
	SKIPL SHUTDN
	CAML TT,TTLTM(I) ;IF TTY HAS OUTPUT RECENTLY
	CAIE T,%TPPCT	;OR ISN'T A TERMINET, OR PADDED LIKE ONE
	 JRST TTTMN1	;NOTHING TO DO.
	MOVSI T,%TCMTR
	TDNE T,TTYCOM(I) ;DITTO IF MOTOR ALREADY OFF.
	 JRST TTTMN1
	IORM T,TTYCOM(I)
	MOVE Q,TOIP(I)
	MOVEI A,%TDMTF	;PUT A MOTOR-OFF COMMAND IN OUTPUT BFR
	PUSHJ P,TYOOU1
	MOVEM Q,TOIP(I)
	SOS TORM(I)
	CONO PI,TTYON
	AOSN TTYOAC(I)
	 XCT TTYST(I)	;AND TELL INT. LVL. ABOUT IT.
TTTMN1:	CONO PI,TTYON
	AOBJN I,TTTMN0
	POPJ P,

;CALL HERE WHEN ABOUT TO OUTPUT TO A TERMINET WHOSE MOTOR IS OFF
;TTY # IN I.
TTTMTO:	MOVE Q,TOIP(I)
	MOVEI A,%TDMTN
	PUSHJ P,TYOOU1	;PUT MOTOR-ON CMD IN OUTPUT BFR,
	MOVEM Q,TOIP(I)
	SOS TORM(I)
	MOVSI Q,%TCMTR	;MOTOR NOW ON AS FAR AS MAIN PRGM
	ANDCAB Q,TTYCOM(I) ;IS CONCERNED.
	POPJ P,

;ECHOING - CALLED AT CLOCK LEVEL. MAY CLOBBER ANY AC.
;ECHOES CHARS BY COPYING THEM FROM INPUT BFR TO OUTPUT BFR.
TTECH:	MOVSI I,200000	;GET LIST OF TTYS NEEDING ECHO, AND REINIT IT.
	EXCH I,TTERQS
	MOVEI J,TTEDMY
TTELUP:	AOS NTTELU	;TAKE STATISTICS.
	CAIL I,-1
	 POPJ P,	;NO MORE TTYS NEED ECHOING.
		;I HAS IDX OF A TTY NEEDING ECHOING.
IFN N11TYS,[
	MOVE T,TTYTYP(I)
	TRNE T,%TY11T
	 JRST TTELU3
TTELU4:	]
	MOVEI A,TOBS
	CAME A,TORM(I)	;CAN'T ECHO UNLESS OUTPUT BFR EMPTY.
	 JRST TTEDU4
	SKIPL TYOSW(I)	;OR IF MORE OUTPUT COMING SOON.
	 JRST TTEWAT	;PUT TTY BACK ON LIST.
	MOVE Q,TTYCOM(I)
	TLNE Q,%TCMTR	;IF TTY'S MOTOR IS OFF, TURN IT ON.
	 PUSHJ P,TTTMTO
	MOVEI J,TTEDMY	;PROVIDE IOT RTNS WITH VARIABLE-BLOCK.
	MOVE H,TTYOPT(I)
	SKIPGE TT,TTYLPP(I) ;TT HAS IDX OF MOST RECENTLY USED PC PPR
	 SETCM TT,TTYLPP(I) ;WHETHER NOW ASSOCIATED OR NOT.
TTEDU2:	MOVEI A,^G	;DING ON TTY IF DESIREED.
	TLZE Q,%TCDNG	;SHOULD BELL BE TYPED BECAUSE INPUT BFR FULL?
	 PUSHJ P,[MOVEM Q,TTYCOM(I)
		MOVEI R,%TIECH+%TIMOR
		JRST TYO8]
TTELP1:	SKIPN ECHOC(I)	;ANY CHARS TO BE ECHOED NOW IN INPUT BFR?
	 JRST TTEDUN	;NO, FINISHED ECHOING.
	AOS NTTEL1
	CAMN TT,TTYEPP(I)	;IF TTY ASSOC. W/ PC PPR OTHER THAN ECHO PC PPR
	 JRST TTELU1
	SKIPL TTYLPP(I)
	 PUSHJ P,TYOMVC	;DISASSOCIATE IT.
TTELU1:	MOVE TT,TTYEPP(I) ;MOST RECENT PC PPR NOW ECHOING PC PPR.
TTELU2:	MOVE B,ECHOP(I)
TTELP2:	CAMN B,TIBEP(I)	;LOOK FOR 1ST CHAR NEEDING PI ECHO.
	 SUBI B,TIBL
	ILDB A,B
	TRZN A,%TXPIE
	 JRST TTELP2
	CONO PI,TTYOFF-1
	SOS ECHOC(I)	;FOUND ONE; NOW ECHO IT.
	MOVEM B,ECHOP(I)
	TRNN A,%TXIGN	;IF CHAR IS IN BFR ONLY TO BE ECHOED,
	 JRST TTELP4
	CAMN B,TIOP(I)
	 JRST [	SOS TICC(I) ;DELETE IT.
		MOVEM B,TIOP(I)
		JRST TTELP5]
	CAMN B,TIIP(I)	;IF CHAR IS LAST CHAR IN BFR,
	 JRST TTEBAK	;DELETE IT, & MAYBE OTHERS BEFORE IT.
TTELP4:	DPB A,B		;ELSE JUST MARK IT AS ECHOED.
TTELP5:	CONO PI,TTYON-1
	MOVEI R,%TIECH+%TIMOR
	TLNN H,%TOHDX	;ON HALF-DUPLEX TTYS, EXCEPT FOR
	 JRST TTELP3
	TRNN A,%TXCOM	;CHARS PRODUCED BY COM LINKS,
	 PUSHJ P,[IORI R,%TIHDE
		JRST TYOAS1]	;MOVE CURSOR BUT DON'T REALLY OUTPUT.
		;THUS, CURSOR MOTION DUE TO ECHOING BY TTY
		;IS ACCOUNTED FOR.
TTELP3:	ANDI A,177
	PUSHJ P,TYO8
	TRZE R,%TIHDE
	 PUSHJ P,TYOMVC
	SKIPN ECHOC(I)
	 JRST TTEDUN
	TRNE H,%TP11T
	 JRST [	PUSHJ P,TYOWN1
		LDB B,T
		JUMPE B,TTEDU4 ;LESS THAN 20. FREE SPACES IN BFR => GIVE UP.
		JRST TTELP1]
	MOVE A,TORM(I)
	CAIGE A,TYOWNC	;IS THERE A CHANCE OUTPUT WOULD HANG UP?
	 JRST TTEDU4	;YES, WAIT UNTIL LATER TO ECHO THE REST.
	JRST TTELP1

;COME HERE WHEN CAN'T FINISH ECHOING THIS TTY BECAUSE OUTPUT
;BUFFER IS FULL. JUST GO ON TO NEXT TTY IN LIST; WHEN OUTPUT
;BUFFER IS EMPTY AGAIN ECHOING WILL BE RE-REQUESTED.
.SEE TYPEND
TTEDU4:	CONO PI,TTYOFF-1
	JRST TTEDU3

;COME HERE WHEN ALL ECHOING DESIRED WAS DONE.
TTEDUN:	CONO PI,TTYOFF-1
	MOVE Q,TTYCOM(I)
	TLNN Q,%TCDNG	;HAS ANOTHER REASON TO ECHO ARISEN AFTER WE
	SKIPE ECHOC(I)	;CHECKED (DUE TO TTY INT LVL)?
	 JRST TTEDU1	;YES, GO PROCESS IT.
	CAME TT,TTYLPP(I)
	 PUSHJ P,TYOFRC	;FORCE OUT BUFFERED CURSOR MOTION.
TTEDU3:	SETO A,		;NO, MOVE TO NEXT TTY ON LIST.
	EXCH A,TTYERQ(I)
	CONO PI,TTYON-1
IFN TCFFLP,[
	MOVSI TT,%TCFFL
	ANDCAM TT,TTYCOM(I)
]
	MOVE I,A
	JRST TTELUP

TTEDU1:	CONO PI,TTYON-1
	JRST TTEDU2

;COME HERE WHEN CAN'T ECHO BECAUSE TYOSW IS LOCKED.
TTEWAT:	AOS NTTEWA
	MOVE A,I	;IF WE CAN'T DO ANY.
	CONO PI,TTYOFF-1
	EXCH A,TTERQS	;PUT THIS TTY BACK ON LIST,
	EXCH A,TTYERQ(I) ;SO IT WIL BE REEXAMINED NEXT TICK.
	CONO PI,TTYON-1
	MOVE I,A	;MOVE TO NEXT TTY ON OLD LIST.
	JRST TTELUP

IFN N11TYS,[
TTELU3:	SKIPL TT11P
	 JRST TTEDU4	;DON'T ECHO ON PDP11 TTYS IF PDP11 DOWN.
	LDB A,TOIP(I)	;DEFER ECHOING UNLESS OUTPUT BFR EMPTY.
	JUMPE A,TTELU4
	JRST TTEDU4
]
TTEBAK:	IBP B
	SUBI B,1
	CAMN B,TIBEP-1(I)
	 ADDI B,TIBL
	SOSN TICC(I)
	 JRST TTEBA1
	LDB C,B
	TRNE C,%TXIGN
	 JRST TTEBAK
TTEBA1:	MOVEM B,TIIP(I)
	JRST TTELP5

IF2 IFN TIBS-2*TIBL,.ERR


EBLK

TTYBRK:	0

BBLK

	CONI TTYAPC
	MOVEM A,TTYA
	MOVE A,[B,,TTYACS]
	BLT A,TTYACS+17-B+1-1	;SAVE ALL ACS BUT 0
IFN TK10P,[
	CONSZ NTY,200000
	JRST NTY1	;NEW TELETYPE KLUDGE
]
IFN MTYP,[
	CONSZ MTY,50
	JRST MTY1	;MORTON BOX
]
IFN DPKPP,[
	CONSZ DPK,60
	JRST DPKPE	;PARITY ERROR OR NXM
	CONSZ DPK,10
	JRST DPTI1	;CHAR AVAIL DPK
	CONSZ DPK,400
	JRST DPTO1	;OUTPUT BUFFER FIN DPK
]
	MOVEI I,0
	CONSZ TTY,50
	JRST GOTTY
;	MOVEI J,TTYCHN	;KNIGHT TTY KLUDGE GENERATES SPUR INTS
;	JSP E,SPUR	;SPURIOUS INT
	JRST TTYRT3
TTYRET:
TTYRT1:	MOVEI A,%TYSTY
	TDNE A,TTYTYP(I)
	JRST 4,.	;NOT SUPPOSED TO RETURN HERE FOR PSEUDO-TTY
TTYRT3:	CONI A
	ANDCM A,TTYAPC
	TRNE A,220000	;DID MPV OR PDL OV COME ON DURING THIS INT?
	 JRST 4,.	;PAGE FAULT IN TTY INT HANDLER.
	MOVS A,[B,,TTYACS]
	BLT A,17
	MOVE A,TTYA
	JRST 12,@TTYBRK

IFN TK10P,[
TTYRT2:	CONO NTY,200000+TTYCHN
	JRST TTYRT1
]

IFN DPKPP,[
DPKPE:	AOS NDPKPE
	CONO DPK,60+TTYCHN	;PARITY ERROR OR NXM
	JRST TTYRT3
]
IFN DPKPP,[
DPTO1:	CONI DPK,A
	LDB I,[220400,,A]
	ADDI I,NFDPT
	SKIPL @DPKC-NFDPT(I)
	SETOM @DPKC-NFDPT(I)
	LDB J,[$TTOSP,,TTYTYP(I)] ;GET OUTPUT SPEED CODE.
	MOVE A,DPSPT(J)	;# WDS BUFFER SPACE FOR THAT SPEED.
	MOVEM A,DBBCC
	MOVEM A,DBBCC1
	MOVE A,DBBFP-NFDPT(I)
	MOVEM A,DBBBP	;BP FOR STORING CHARS.
	MOVSM A,@DPKP-NFDPT(I)
	JRST TYP0

DPTI1:	DATAI DPK,A
	LDB I,[220400,,A]
	ADDI I,NFDPT
	JRST NTYI1
]
IFN TK10P,[
NTY1:	CONSZ NTY,400000
	JRST TTYRT3	;SCANNER NOT STOPPED
	CONI NTY,I	;READ IN TTY #
IFN TK10L8,LDB I,[110300,,I]
IFE TK10L8,LDB I,[100400,,I]
	CAIL I,NNTYS
	JRST 4,.
	ADDI I,NOTYS	;CALCULATE CONSOLE #
	CONO NTY,@TTYLT(I)	;SELECT APPROPRIATE TTY
	CONSZ NTY,20
	JRST TYP	;DONE FLAG ON TYPEOUT
	CONSO NTY,40
	JRST TTYRT2	;THIS TTY NOT REALLY UNHAPPY
	DATAI NTY,A
	MOVEI B,%TPIBM*3
	TDNN B,TTYOPT(I)
	JRST NTYI1
	LDB B,[060200,,A]
	DPB B,[050300,,A]	;FLUSH BIT 6
	JRST NTYI1
]

IFN MTYP,[
MTY1:	CONI MTY,I
	LDB I,[140500,,I]	;GET SUBDEVICE
	CAIL I,NMTYS
	JRST MTY2	;NOT A VALID #
	ADDI I,NFMTY
	CONO MTY,@TTYLT(I)
	CONSO MTY,40	;INPUT DONE
	JRST MTY6
	DATAI MTY,A
	JRST NTYI1
MTY6:	CONSO MTY,10	;OUTPUT DONE
	JRST TTYRT1
	MOVEI A,MTYNC
	MOVEM A,DBBCC	;# CHARS CAN GIVE AT ONCE.
	SETZM MTYOW	;SET UP WORD TO FILL WITH OUTPUT CHARS.
	MOVE A,[440700,,MTYOW]
	MOVEM A,DBBBP	;SET UP BP FOR STUFFING THAT WORD.
	JRST TYP

MTY2:	CONSZ MTY,10
	JRST MTY3	;OUTPUT
	CONSZ MTY,40
	DATAI MTY,A	;INPUT
	JRST TTYRT3	;AND IGNORE
MTY3:	LSH I,12.
	CONO MTY,200+TTYCHN(I)	;CLEAR OUTPUT DONE FLAG
	JRST TTYRT3
]

GOTTY:	CONSZ TTY,10
	JRST TYP	;TTO DONE
	CONSO TTY,40
	JRST TTYRET	;NONE
	DATAI TTY,A	;TTI DONE, READ CHR

;DROPS THRU
;DROPS IN

;PROCESS INPUT INTERRUPT WITH CHARACTER IN A, TTY # IN I

NTYI1:
IFN NNVTTS,[
	CAME I,NOVATT	;SKIP IF THIS TTY IS NOVA
	JRST NTYI3
	TRZE A,200	;SKIP IF DATA  AND NOT TTY #
	JRST NTYI2	;SET TTY #
	SKIPGE I,NVIPTT	;CURRENTLY SELECTED  CONSOLE ON INPUT
	JRST TTYRET	;NONE SELECTED
NTYI3:]
IFN TTLPTP,[
	CAMN I,LPTTTY
	JRST INLPT
]
	MOVE P,TTYPDP
NTYI5:	ANDI A,177	;FLUSH POSSIBLE EXTRANEOUS BITS
	MOVEM I,LOCTTY	;TTY CHAR ACTUALLY TYPED ON
	MOVSI U,%TSLCZ
	ANDCAB U,TTYSTS(I)	;CLEAR LAST CHR ^Z BIT
	MOVE Q,TTYCOM(I)
	MOVE R,TTYTYP(I)
	MOVE H,TTYOPT(I)
	TRNE H,%TPIBM*3
	 JRST CVASC
	TLNE H,%TOALT	;IF THIS TTY WANTS IT, MAYBE STANDARDIZE ALTMODES
	 PUSHJ P,TTYSAM
CVASC1:	MOVE D,TTYIPC(I)
	MOVEM D,LOCTPC	;REMEMBER INPUT RTN FOR DEBUGGING
	PUSHJ P,(D)
	MOVE I,LOCTTY
	MOVE R,TTYTYP(I)
	TRNE R,%TYSTY+%TY11T
	POPJ P,	;RETURN FOR PSEUDO-TTY
	JRST TTYRET

IFN NNVTTS,[
NTYI2:	JUMPE A,TTYRET
	ADDI A,NOTYS+NNTYS-1
	CAIGE A,NOTYS+NNTYS+NNVTTS
	MOVEM A,NVIPTT	;SELECT CONSOLE
	JRST TTYRET
]

IFN TTLPTP,[INLPT:	MOVE A,TIME
	MOVEM A,LPTTIME
	JRST TTYRET]

;NORMAL TTY INPUT HANDLER (@TTYIPC(I))
;CLOBBERS A - E, EXPECTS R, U,  I SET UP.
;R HAS TTYTYP, U HAS TTYSTS, I HAS # OF TTY.
TTYI:	CAIN A,^_
	 JRST TTYICB	;CHAR IS ^_, MAYBE ENTER COM MODE.
TTYI2:	CAIN A,^Z	;TEST FOR ^Z
	 JRST ZFLAG	;^Z TYPED
TTYI2A:	JUMPL U,CPOPJ	;IGNORE CHAR. IF NO USER.
TTYI11:	MOVE E,TICC(I)
	CAIL E,TIBS	;SKIP IF ANY ROOM LEFT IN INPUT BUFFER
	JRST DING1
	PUSHJ P,GETGRP	;GET 6 BIT BYTE FOR GROUP THIS CHARACTER IS IN
	MOVE C,TTYOPT(I)
	CAIL A,141	;IF A LOWER CASE CHAR,
	CAILE A,172
	 JRST TTYI15
	TLNE C,%TOCLC	;CONVERT TO UPPER CASE IF WANTED, ELSE
	 XORI A,40

TTYI15:	TLZE U,%TSINT	;IF WANT THIS CHAR TO INT. WHATEVER IT IS,
	 IORI B,%TGINT	;PRETEND IT'S AN INT. CHAR.
	MOVEM U,TTYSTS(I)
	LSH B,14	;PUT %TXACT, %TXPIE, AND %TXMPE IN.
	IORI A,(B)
	ANDCMI A,%TXIGN+%TXINT+%TXCOM
	TRNN B,%TXINT	;TEST INTERRUPT BIT FOR THIS GROUP
	JRST TTYI8	;OFF.  DON'T INTERRUPT
	HRRE B,U	;RH OF B IS USER INDEX
	JUMPL B,[JRST 4,.]	;SHOULDN'T BE NO USER
	HRL B,MSKST(B)	;LH OF B IS USER'S INTERRUPT MASK
	TLNN B,TTYIF	;SKIP IF INTERRUPTS ON TYPE IN ENABLED
	JRST TTYI5	;DISABLED
	MOVEI C,TTYIF
	IORM C,PIRQC(B)	;GENERATE TYPE IN INTERRUPT REQUEST
	TRO A,%TXINT		;INDICATE INTERRUPT
TTYI5:	MOVE C,TYIMSK(I)	;GET TTY CHANNELS OPEN MASK
	AND C,MSKST2(B)	;MASK OFF CHANNELS NOT ENABLED
	JUMPE C,TTYI8	;JUMP IF NO OPEN CHANNELS HAVE INTERRUPTS ENABLED
	MOVN D,C
	AND C,D		;ISOLATE LEAST SIGNIFICANT BIT
	IORM C,IFPIR(B)	;GENERATE SECOND WORD INTERRUPT REQUEST
	IORI A,%TXINT	;INDICATE INTERRUPT
	JRST TTYI8

;LIKE TTYI18 BUT FOR A CHAR THAT WASN'T REALLY TYPED IN.
TTYI13:	IORI A,%TXCOM

;ECHO BUT DON'T USE AS INPUT THE CHAR IN A,
;ASSUMING IT WAS ACTUALLY TYPED IN BY USER. MUST NOT CLOBBER H, TT.
TTYI18:	MOVE C,TICC(I)
	CAIL C,TIBS
	 JRST DING1	;NO ROOM IN INPUT BFR => COMPLAIN.
	IORI A,%TXPIE+%TXIGN	;THIS CHAR WILL ECHO & BE IGNORED.

TTYI8:	TRNE A,%TXACT	;IF ACTIVATION CHAR, COUNT IT.
	 AOS TACC(I)
	MOVE C,TIIP(I)
	TRNE A,%TXPIE	;IF PI ECHO CHAR, COUNT IT.
	 JRST [	AOS D,ECHOC(I)
		CAIN D,1	;IF THE ONLY ONE, SET ECHOP TO IT.
		 MOVEM C,ECHOP(I)
		JRST .+1]
	TRNE A,%TXINT	;SIMILAR FOR TINTC, TINTP IF INT. CHAR.
	 JRST [	AOS D,TINTC(I)
		CAIN D,1
		 MOVEM C,TINTP(I)
		JRST .+1]
	PUSHJ P,TTYISC
	TRNN A,%TXPIE	;IF PI ECHO NEEDED,
	 POPJ P,
TTYI7:	MOVE C,TORM(I)
	CAIL C,TOBS
	SKIPL TTYERQ(I)	;PUT THIS TTY ON LIST OF THOSE NEEDING ECHO
	 POPJ P,	;UNLESS IT'S ALREADY ON.
	TLNE I,-1
	 JRST 4,.
	MOVE C,TTERQS
	MOVEM I,TTERQS
	MOVEM C,TTYERQ(I)
	POPJ P,

DING1:	TLNE R,%TTDDI	;SKIP IF WANT TO DING ON EXCESS INPUT
	POPJ P,
	MOVSI C,%TCDNG
	IORM C,TTYCOM(I)
	JRST TTYI7	;TELL CLOCK LEVEL TO LOOK AT THIS TTY.

TTYISC:	MOVE E,TICC(I)
	CAIGE E,MICBAA
	JRST TTYIS5
	SKIPG TACC(I)	;BUFFER FULL+ NO ACTV CHRS, GEN ONE
	 JRST [	AOS TACC(I)
		IORI A,%TXACT
		JRST TTYIS5]
TTYIS5:	MOVE E,TIIP(I)
	CAMN E,TIBEP(I)	;SKIP IF NOT OFF THE END OF THE CIRCULAR BUFFER
	SUBI E,TIBL	;RESET TIIP
	HRRM E,TIIP(I)	;STORE BACK IN RH
	IDPB A,TIIP(I)	;STORE CHARACTER IN INPUT BUFFER
	AOS TICC(I)
	POPJ P,

CVASC:	JUMPN A,CVASC8
	SKIPL 27TIME(I)
	JRST CVASC9
CVASCD:	MOVE A,TIME
	MOVEM A,27TIME(I)
	MOVEM A,27FTIM(I)
	JRST CVATT
CVASC9:	MOVE A,TIME
	SKIPL 27FTIM(I)
	JRST CVASCC
	MOVE B,A
	SUB B,27TIME(I)
	CAIL B,30.	;ONE SECOND
	JRST CVASCD
	MOVEM A,27TIME(I)
	JRST TTYRET
CVASCC:	MOVEM A,27TIME(I)
	SUB A,27FTIM(I)
	CAIGE A,900.	;HALF MINUTE
	JRST TTYRET
	SETZM 27IGE(I)	;RESET THE WORLD
	SETZM 27CTLF(I)
	SETZM 27LICR(I)
	SETOM 27LIAT(I)
	SETZM 27PMS(I)
	SETZM 27STOU(I)
	SETOM 27FTIM(I)
	JRST TTYRET
CVASC8:	SKIPGE B,27TIME(I)
	JRST CVASCA
	SUB B,TIME
	CAML B,[-7]
	JRST TTYRET
	SETOM 27TIME(I)
CVASCA:	CAIN A,27ATT
	JRST CVATT
	SKIPL 27IGE(I)
	JRST CVASC2
	SETZM 27IGE(I)
	CAIN A,27EOA
	JRST TTYRET	;IGNORE EOA
CVASC2:	CAIN A,27LWR
	JRST CVASC3
	CAIN A,27UPR
	JRST CVASC4
	SKIPGE 27LIAT(I)
	SKIPGE 27CTLF(I)
	JRST CVOBS
CVOBS1:	SETOM 27LIAT(I)
	MOVE B,27CASE(I)
	ANDI A,77
	TRNE H,%TPIBC
	SKIPA A,ASCORS(A)
	MOVE A,ASCTBL(A)
	TRNN B,400
	MOVSS A
	ANDI A,177
	CAIE A,177
	CAIGE A,101	;@@ MEANS @ NOT ^@
	JRST CVASC5
	SKIPGE 27CTLF(I)
	TRZ A,140
CVASC5:	CAIN A,"@
	JRST CVASC6
	CAIN A,33
	SKIPL 27CTLF(I)
	JRST CVASCB
	MOVEI A,177	;@$ IS RUBOUT
CVASCB:	SETZM 27CTLF(I)
CVASC7:	SETZM 27LICR(I)
	CAIE A,15
	JRST CVASC1
	MOVNI B,2
	MOVEM B,27LICR(I)
	JRST CVASC1
CVASC6:	SETCMB B,27CTLF(I)
	JUMPGE B,CVASC7
	SETZM 27LICR(I)
	JRST TTYRET

CVASC4:	SKIPA A,[400]
CVASC3:	MOVEI A,200
	MOVEM A,27CASE(I)
	JRST TTYRET

CVATT:	MOVEI B,200
	MOVEM B,27CASE(I)
	AOSN TTYOAC(I)
	PUSHJ P,27STO
	MOVEI B,1
	MOVEM B,27PMS(I)
	SKIPL 27LICR(I)
	JRST CVATT1
	SETZM 27LICR(I)
	JRST TTYRET
CVATT1:	AOSG 27LIAT(I)
	JRST TTYRET
	MOVEI A,^Z
	JRST CVASC7

CVOBS:	AOSN TTYOAC(I)
	PUSHJ P,27STO
	JRST CVOBS1

27STO:
IFN TK10P,[
	CONO NTY,@TTYLT(I)
	CONO NTY,10+TTYCHN
]
	POPJ P,

TYCLWR:	CAIL A,141	;CONVERT LOWER CASE LTRS TO UPPER
	CAILE A,172
	POPJ P,
	SUBI A,40
	POPJ P,

TTYSAM:			;STANDARDIZE ALT MODE (IF APPRO)
	TLNE U,%TSALT+%TSSII	;SKIP IF ALT MODE NOT TO BE STANDARDIZED
	POPJ P,		;DON'T STANDARDIZE ALT MODE
	CAIE A,176	;ALT MODE CAN BE 176 OR
	CAIN A,175	;175
	MOVEI A,33	;CHANGE EITHER TO 33
	POPJ P,

;GETS BYTE IN B, GROUP NUMBER IN C, BYTE POINTER IN D
GETGRP:	ANDI A,177
	MOVEI B,(A)
	IDIVI B,5
	LDB C,GRPBPT(C)	;GET GROUP BITS
	MOVEI D,TTYST1(I)
	CAIL C,6
	JRST GETGR2
	LDB E,[301400,,SBTBL(C)]	;LOAD LH OF BYTE PTR
GETGR1:	DPB E,[301400,,D]	;MAKE TTYST1 OR TTYST2 APPROPRIATE BYTE POINTER
	LDB B,D
	POPJ P,

GETGR2:	LDB E,[301400,,SBTBL-6(C)]
	MOVEI D,TTYST2(I)
	JRST GETGR1

DEFINE	GGRPTB A,B,C,D,E
A_29.+B_22.+C_15.+D_8+E_1
TERMIN

GRPTBL:	0
	GGRPTB 0,0,6,13,7
	GGRPTB 7,0,0,11,0
	GGRPTB 0,0,0,0,6
	0
	GGRPTB 0,0,10,0,0
	GGRPTB 0,0,13,3,3
	GGRPTB 3,3,3,3,3
	GGRPTB 5,5,4,4,3
	GGRPTB 4,3,4,2,2
	GGRPTB 2,2,2,2,2
	GGRPTB 2,2,2,3,3
	GGRPTB 5,4,5,3,3
	REPEAT 5,GGRPTB 1,1,1,1,1
	GGRPTB 1,5,3,5,4
	GGRPTB 4,3,1,1,1
	REPEAT 4,GGRPTB 1,1,1,1,1
	GGRPTB 1,1,1,5,3
	GGRPTB 10,3,12,0,0

GRPBPT:	350700,,GRPTBL(B)
	260700,,GRPTBL(B)
	170700,,GRPTBL(B)
	100700,,GRPTBL(B)
	010700,,GRPTBL(B)

ZFLAG:	MOVSI U,%TSLCZ	;EVEN IF THIS BIT IN TTYSTS IS OFF, TTY MAY BE FREE
	IORB U,TTYSTS(I)	;GET TTYSTS
	JUMPGE U,ZFLAG2	;(TTY IS IN USE)
	SKIPL TTYSTA(I)	;(CONSOLE FREE MSG COMING OUT OR
	 POPJ P,	;ALREADY TRYING TO ^Z)
	MOVE A,UTTYCT	;SET UP NEW USER
	SKIPL DEDTIM	;SKIP, STOPPING MORE USERS IF SYSTEM DEAD
	CAIL A,MXCZS
	 POPJ P,	;LOSE
	MOVN B,SYSDBG
	SKIPGE SYSDBG	;IF NOT ALLOWING USERS,
	CAMN I,B	;ALLOW ONLY THE SPEC'D TTY (= -C(SYSDBG) )
	 JRST ZFLAG7
	JUMPN I,CPOPJ	;AND TTY 0.
ZFLAG7:	CONO PI,PICOFF\<200_-UTCCHN>	.SEE NUJBST
	AOS UTTYCT
	HRRZM I,@UTTYI
	AOS A,UTTYI
	CAIL A,UTTYS+MXCZS
	MOVEI A,UTTYS
	MOVEM A,UTTYI
	CONO PI,PICON\<200_-UTCCHN>
	JRST TTYINI

ZFLAG2:	TLNE U,%TSSII
	 JRST ZFLAG3	;SUPER IMAGE INPUT MODE
	TLNE U,%TSCNS	;SKIP IF IN USE AS DEVICE
	 JRST ZFLAG5	;JUMP IF IN USE AS A CONSOLE
ZFLAG3:	MOVSI U,%TSLCZ	;CLEAR <LAST CH WAS ^Z> BIT
	ANDCAB U,TTYSTS(I)
	MOVEI A,^Z
	JRST TTYI2A	;TREAT ^Z AS ANY OTHER CHAR.

ZFLAG4:	MOVE U,TTYSTS(I)	;RESTORE U
	MOVEI A,^Z+%TXPIE+%TXACT	;RESTORE A
	MOVE E,TICC(I)
	CAIL E,TIBS
	JRST DING1
	JRST TTYI8

ZFLAG6:	MOVE U,SUPPRO(U)	;GET POINTER TO SUPERIOR
ZFLAG5:	MOVEI A,BCNTRZI
	SKIPG SUPPRO(U)	;SKIP IF NOT TOP LEVEL
	JRST ZFLAG3	;JUMP IF TOP LEVEL, IGNORE ^Z
	TDNE A,PIRQC(U)	;SKIP IF NOT YET INTERRUPTED
	JRST ZFLAG6	;IF BIT PREV. SET, SHOULD RUN THIS GUY
	IORM A,PIRQC(U)	;SET ^Z INTERRUPT BIT
	MOVSI A,BUSRC
	MOVE U,SUPPRO(U)	;GET POINTER TO SUPERIOR
	TDNN A,USTP(U)	;SKIP IF SUPERIOR STOPPED
	JRST ZFLAG4	;NOT STOPPED, WILL FIND OUT ABOUT ^Z, WIN
	JRST ZFLAG5	;SUPERIOR STOPPED, TRY AGAIN ONE LEVEL UP

TTYICB:	TLNE U,%TSSII	;^_ READ IN NORMAL INPUT
	 JUMPGE U,TTYI2
TYCGTN:	JSP D,TYCRDE	;ECHO IT, RETURN WITH NEXT CHAR TYPED.
TYCI:	SETOM COMT1(I)	;CHR AFTER ^_
	CAIE A,^_
	CAIN A,^Z
	JRST TYCI3	;GIVE EITHER CHARACTER TO MAIN PROGRAM
	CAIL A,"0
	CAILE A,"9
	JRST TYCI7	;NOT A NUMBER
	MOVNI B,2	;DIGIT COUNT
	MOVEM B,COMT3(I)	
	MOVEI B,-"0(A)
	MOVEM B,COMT1(I)	;STORE FIRST DIGIT
	JSP D,TYCRDE	;ECHO DIGIT, READ ANOTHR. (TTYIPC LEFT -> TYCI4)
TYCI4:	PUSHJ P,TYCI22	;READ NUM AFTER FIRST DIGIT
	JRST TYCI6	;CHARACTER IS NON-NUMERIC
	PUSHJ P,TTYI18	;ECHO NUMBER
	AOSGE COMT3(I)	;SKIP IF THIS IS THE THIRD CHARACTER
	POPJ P,		;GET NEXT CHARACTER
	MOVE A,COMT1(I)	;A HAS CHAR WITH THE OCTAL VALUE TYPED.
TYCI3:	PUSHJ P,TYCI17	;RESTORE TTYIPC TO NORMAL,
	IORI A,200	;PREVENT CHAR FROM BEING TAKEN AS ^Z OR ^_.
	JRST @TTYIPC(I)	;HANDLE CHAR (BUT QUOTE ^_ AND ^Z)

TYCI22:	CAIL A,"0
	CAILE A,"9
	POPJ P,		;RETURN WITHOUT SKIPPING IF NON-NUMERIC
	MOVE B,COMT1(I)
	LSH B,3
	ADDI B,-"0(A)
	MOVEM B,COMT1(I)	;UPDATE VALUE SO FAR
	JRST POPJ1	;SKIP RETURN

TYCI2:	PUSHJ P,TTYI18	;ECHO CHAR, RESET TTYIPC TO NORMAL.
TYCI17:	MOVEI B,TYCG
	SKIPL TTYCOM(I)
	MOVEI B,TTYI
	MOVEM B,TTYIPC(I)
	TLZ Q,%TCTMP	;ALSO NO LONGER TEMPORARILY REQUIRE COM MODE
	MOVEM Q,TTYCOM(I)
	POPJ P,

TYCI6:	ANDI A,177	;ORIG CHR TYPED
	EXCH A,COMT1(I)	;A NOW HAS CHAR REPRESENTED BY DIGITS
	PUSHJ P,TYCI3	;SIMULATE ITS TYPE IN
	MOVE A,COMT1(I)	;GET LAST CHARACTER TYPED
	JRST @TTYIPC	;PROCESS IT NORMALLY

TYCI7:	PUSHJ P,TYCLWR
	MOVSI C,-NTYIQT
TYCI7C:	CAMN A,TYIQT(C)
	JRST TYCI7B
	AOBJN C,TYCI7C
TYCI7F:	MOVEI A,"?
	PUSHJ P,TTYI13	;ECHO THE CHGAR (EVEN ON HALF-DUPLEX)
	JRST TYCI17

TYCI7B:	MOVE H,TTYOPT(I)
	XCT TYIQTI(C)
	MOVEM H,TTYOPT(I)
TYCI7D:	MOVEM U,TTYSTS(I)
	MOVEM Q,TTYCOM(I)
	JRST TYCI2

TYCAM:	TLZ Q,%TCQRY+%TCRFS
	CAIN A,"A
	JRST TYCI7D
	CAIE A,"R
	TLOA Q,%TCQRY	;"Q QUESTION
	TLO Q,%TCRFS	;REFUSE
	JRST TYCI7D

TYIQT:	"^
	"G
	"M
	"I
	"O
	"S
	"E
	"A
	"Q
	"R
	"U
	"C
	"N
	"K
	"P
NTYIQT==.-TYIQT

TYIQTI:	TLC U,%TSROL	;COMPLEMENT SCROLL MODE.
	TLC U,%TSMOR	;MORE INHIBIT
	TLC U,%TSMOR	;MORE INHIBIT
	TLC Q,ICO	;INPUT COM OVERRIDE
	TLC Q,OCO	;OUTPUT COM OVERRIDE
	JRST TYCS	;LOCAL FEED THROUGH
	JRST TYCRFT	;REMOTE FEED THROUGH
	JRST TYCAM	;HACK MESSAGES
	JRST TYCAM
	JRST TYCAM
	TLC H,%TOCLC	;CONV LOWER CASE TO UPPER
	JRST TYCC	;ENTER COM MODE
	JRST TYCN	;^_N LEAVE COM MODE.
	JRST TYCK	;^_K REMOVE SPEC'D USER FROM COM LINK.
	JRST TYCP	;CAUSE A **MORE**

IFN .-TYIQTI-NTYIQT, .ERR WRONG TABLE LENGTH

TYCP:	MOVE B,I
	IMULI B,TPLEN*2
	MOVEI C,%TFEOP
	IORM C,TPFLAG(B)
	JRST TYCI7D

TYCRFT:	PUSH P,A
	SETZ B,		;COMPLEMENT OUR RFT BIT.
	PUSHJ P,TYCREP	;1ST, COUNT # TTYS IN LOOP.
	 PUSHJ P,[MOVE A,TTYCOM(I)
		  TLNE A,LFT	;IF ANY TTY IN LOOP HAS LFT SET
		   POPJ P,	;THEN IT'S OK FOR OUR RFT TO BE.
		  AOJA B,POPJ1]
	 JRST TYCRF1	;SOME TTY IN LOOP HAS LFT => OK TO SET RFT.
	CAIE B,2	;ONLY 1 OTHER TTY => SET ITS LFT, THEN OUR RFT.
	 JRST TYCI7F	;FAIL TO SET RFT IF CAN'T FIND OTHER WITH LFT.
	MOVE A,TTYCOM(I)
	MOVSI B,LFT
	IORM B,TTYCOM(A)
TYCRF1:	TLC Q,RFT
	POP P,A
	JRST TYCI7D

;COME HERE AFTER READING UNAME FOR ^_S. B HAS IDX OF SPEC'D TTY.
;SET THAT TTY'S LFT, ENSLAVING IT. CLEAR LFT OF ALL OTHER TTYS
;IN THE SAME LOOP AS SPEC'D TTY.
TYCS1:	MOVEM Q,TTYCOM(I)	;CLEAR OUT %TCCBS
	PUSHJ P,TYCREP
	 CAIN B,(I)	;IF SPEC'D TTY NOT IN COM WITH US
	 CAIA
	 JRST TYCI25	;THEN IT'S AN ERROR.
	MOVSI A,LFT
	IORM A,TTYCOM(B) ;SET HIS LFT,
	PUSHJ P,TYCREP
	 PUSHJ P,[CAIE I,(B)	;CLEAR LFTS OF OTHER TTYS
		   ANDCAM A,TTYCOM(I)
		  JRST POPJ1]
	 JFCL
	POPJ P,

;CALL WITH JSP D,  ECHO CHAR IN A, RETURN WITH NEXT CHAR.
TYCRDE:	HRRZM D,TTYIPC(I)
	JRST TTYI18

;T -> ASCIZ STRING, ECHO ON TTY # IN I (MUST HAVE DONE TYCSET)
TYCI40:	HRLI T,440700
TYCI39:	ILDB A,T
	JUMPE A,CPOPJ
	PUSHJ P,TTYI13	;ECHO CHARACTER ON TTY
	JRST TYCI39

;SET UP ACS FOR ECHOING ON TTY # IN I.
TYCSET:	MOVE R,TTYTYP(I)
	MOVE Q,TTYCOM(I)
	MOVE U,TTYSTS(I)
	POPJ P,

;PUT TTY IN COM MODE IF IT ISN'T. TTY # IN I.
TYCI63:	TLO Q,%TCTMP	;SAY MUST BE IN COM MODE EVEN IF NOT LINKED.
	TLON Q,400000
	TLZ Q,LFT+RFT+OCO+ICO
	MOVEM Q,TTYCOM(I)
	POPJ P,

;TTY # IN I, REPEAT OVER THAT TTY AND ALL LINKED TO IT.
;INSN TO BE REPEATED FOLLOWS CALL.
;IF THE INSN DOESN'T SKIP, IMMEDIATELY RERURNS
;SKIPPING ONLY THAT INSN. ELSE RETURNS SKIPPING 2 WHEN ALL TTYS DONE.
TYCREP:	PUSH P,I	;PUSH TTY STARTING WITH.
	PUSH P,I	;PUSH TTY DOING NEXT.
TYCRE0:	XCT @-2(P)	;(THE INSN AFTER THE PUSHJ)
	 JRST TYCRE1	 ;IT DIDN'T SKIP, GIVE UP RIGHT AWAY.
	MOVE I,(P)	;ELSE KEEP GOING,
	SKIPL I,TTYCOM(I)
	 JRST TYCRE2	;LAST TTY DONE NOT LINKED, THRU.
	ANDI I,-1
	CAIE I,-1	;IN COM MD BUT NOT LINKED OR
	CAMN I,-1(P)	;HAVE GONE ALL AROUND CIRCULAR LIST
	 JRST TYCRE2	 ;=> DONE.
	MOVEM I,(P)	;ELSE DO THE NEXT ONE.
	JRST TYCRE0

TYCRE2:	AOS -2(P)	;RETURN SKIPPING 2.
TYCRE1:	SUB P,[1,,1]
	POP P,I
	JRST POPJ1

TYCC:	TLOA Q,%TCTPN	;^_C - WHEN LEAVE COM MODE MUST TYPE ^_N.
TYCK:	TLO Q,%TCCBK	;SAY WE'RE DOING ^_K.
	JRST TYCI19

TYCS:	TLO Q,%TCCBS	;^_S - ENSLAVE SPEC'D TTY.
TYCI19:	PUSHJ P,TYCI63	;PUT TTY IN COM MODE IF ISN'T ALREADY.
	JSP D,TYCRDE	;ECHO, RETURN, COME BACK WITH NEXT CHAR.
	CAIE A,15	;SPACE OR CR IS 1ST CHAR, IGNORE.
	CAIN A,40
	 JRST TTYI18
	MOVEI B,TYCI27
	MOVEM B,TTYIPC(I)
	SETZM COMT3(I)	;INIT. ACCUMULATED #.
	SETZM COMT1(I)	;AND ACCUM UNAME.
	JRST TYCI27	;HANDLECHAR JUST READ,.

;READING CHARS AFTER ^_C (AFTER A NON-SPACE HAS BEEN SEEN)
;COMT1 ACCUMULATES SIXBIT, COMT3 OCTAL NUMBER.
;SIGN OF COMT3 SET => NONDIGIT WAS SEEN, USE THE SIXBIT.
TYCI27:	PUSHJ P,TYCLWR	;CONVERT TO UPPER CASE.
	CAIN A,^_
	JRST TYCI25	;ANOTHER ^_ IS NO GOOD.
	CAIE A,15
	CAIN A,40
	JRST TYCI28	;SPACE DELIMITS UNAME OR NUMBER
	CAIN A,177
	JRST TYCI25	;RUBOUT => TYPE ? AND GIVE UP.
	MOVE B,COMT3(I)	;ACCUM NUMBER IN RH OF COMT3.
	LSH B,3
	ADDI B,-"0(A)
	HRRM B,COMT3(I)
	CAIL A,"0
	CAILE A,"9	;NON-DIGIT SEEN => SET SIGN OF COMT3 SAYING
	 SETOM COMT3(I)	;CERTAINLY NOT NUMBER.
	MOVE B,COMT1(I)
	LSH B,6
	IORI B,-40(A)
	MOVEM B,COMT1(I)	;ADD NEW CHARACTER ONTO THE END OF THE NAME
	JRST TTYI18	;EXIT TO ECHO THE CHARACTER

TYCI28:	PUSHJ P,TYCI2
	SKIPGE B,COMT3(I)
	 JRST TYCI52	;TYPEIN WASN'T NUMBER.
	CAIGE B,NCT	;IS NUMBER THAT OF A TTY THAT EXISTS?
	 JRST TYCI53
TYCI52:	MOVE B,COMT1(I)
TYCI29:	TLNE B,770000	;LEFT ADJUST THE UNAME
	JRST TYCI30
	LSH B,6
	JRST TYCI29

TYCI30:	MOVEI U,LUBLK	;START LOOKING AT USER NUMBER 2
TYCI31:	ADDI U,LUBLK
	CAML U,USRHI
	JRST TYCI25	;OUT OF USERS SO GIVE ? AND RETURN
	CAMN B,UNAME(U)	;SKIP IF NO UNAME MATCHES
	SKIPGE C,TTYTBL(U)	;SKIP IF PROCEDURE HAS THE TTY
	JRST TYCI31	;TRY NEXT PROCEDURE
	HRRZ B,C	;TTY NUMBER
TYCI53:	IFG APL,CAIE B,APL
	CAIN B,SYSCON
	JRST TYCI25	;DON'T SEND MESSAGE TO SYS JOB CONSOLE
	TLZE Q,%TCCBK	;JUMP IF DOING ^_K.
	 JRST TYCK1
	TLZE Q,%TCCBS
	 JRST TYCS1	;ALSO CHECK FOR ^_S.
	PUSHJ P,TYCREP	;NO, IT'S ^_C.
	 CAIN B,(I)	;DON'T LET LINK TO SELF OR SOMEONE ALREADY LINKED TO.
	 JRST TYCI25
	HRRE C,TTYSTS(B)
	AOJN C,TYCI34	;TTY HAS A USER
	MOVEI A,"F	;TTY IS FREE
	PUSHJ P,TTYI13	;TYPE AN F
	MOVEI A,40
	PUSHJ P,TTYI13	;FOLLOWED BY A SPACE
	MOVE B,COMT3(I)	;RESTORE THAT TTY'S NUMBER.
	JRST TYCI32

TYCI34:	MOVE C,TTYSTS(B) ;TTY IN USE: AS A DEVICE?
	TLNN C,%TSCNS
	 JRST TYCI25	;^_C NOT ALLOWED TO TTY OPEN AS DEVICE.
TYCI32:	MOVE C,TTYCOM(B)
	TLNE C,%TCRFS	;GIVE UP IF HE IS REFUSING ^_C'S.
	 JRST TYCI36
	MOVE A,TTYIPC(B) ;HE'S BUSY IF HIS TTYIPC ISN'T NORMAL.
	CAIE A,TTYI	;MUNGING IPC WHILE NOT NORMAL WOULD LEAVE
	CAIN A,TYCG	;WHAT HE'S DOING UNFINISHED - CAUSING BUGS.
	CAIA
	JRST TYCI37

;NOW WE KNOW IT'S OK TO TRY TO ^_C HIM. HIS TTY # IN B, MINE IN I.
TYCI44:	MOVE H,I	;PUT MY TTY # IN H, HIS IN I.
	MOVE I,B
	SETO TT,
	PUSHJ P,TYCSET	;GET HIS TTYCOM IN Q FOR TYCI63
	TLO Q,%TCTPN	;WHEN HE LEAVES COM MODE TYPE ^_N AT HIM.
	PUSHJ P,TYCI63	;PUT HIM IN COM MODE IF HE ISN'T ALREADY.
	PUSHJ P,TYCI64	;TYPE MSG FROM ME ON HIM.
	JFCL
	MOVSI A,%TCQRY
	TDNN A,TTYCOM(I) ;SKIP IF HE MUST BE ASKED
	 JRST TYCI43	 ;ALWAYS ACCEPT
	MOVEI T,[ASCIZ /OK?/]
	PUSHJ P,TYCI40
	MOVEI A,TCIR	;HE SHOULD TYPE INTERROGATION RESPONSE
	MOVEM A,TTYIPC(I)
	MOVEM H,COMT1(I)
	MOVEM I,COMT1(H)
	MOVEI A,TCIRW	;WE DON'T DO ANYTHING TILL HE GIVES IT.
	MOVEM A,TTYIPC(H)
	MOVE I,H
	PUSHJ P,TYCSET
	MOVEI T,[ASCIZ /W /]
	JRST TYCI40

TYCI68:	CAIN TT,(I)	;ENTRY TO DO FOR ALL LINKED TO HIM BUT NOT HIM.
	 JRST POPJ1
TYCI64:	MOVEI T,[ASCIZ /
MESSAGE FROM /]
TYCI71:	PUSHJ P,TYCSET	;SET UP Q,R,U,W FOR HIS TTY (# IN I)
	PUSHJ P,TYCI40	;PRINT MSG <- T ON IT.
	PUSH P,I	;SAVE HIS TTY #,
	MOVE I,H	;GET MINE (ARG TO TYCREP)
	PUSHJ P,TYCREP	;LOOP OVER ME AND ALL ALREADY LINKED TO ME.
	 PUSHJ P,TYCI66
	 JFCL
TYCI41:	POP P,I
	MOVEI A,40
	PUSHJ P,TTYI13
	JRST POPJ1

;TYPE UNAME OF 1 OF MY TTYS ON 1 OF HIS.
TYCI66:	HRRZ C,TTYCOM(H)
	CAIE C,-1
	JRST TYCI72
	CAIN H,(I)	;BUT DON'T TYPE MY NAME ON HIM.
	CAME TT,-4(P)
	CAIA
	 JRST POPJ1
TYCI72:	MOVEI C,(I)	;PUT THIS TTY # IN C,
	MOVE I,-4(P)	;GET HIS BACK IN I SINCE STILL TYPING ON HIM.
	CAMN C,-2(P)	;IF THIS ISN'T MY TTY,
	 JRST TYCI67
	MOVEI T,[ASCIZ/ AND /] ;THEN IT'S SOMEONE LINKED TO ME
	PUSHJ P,TYCI40	;AND MY NAME WAS ALREADY TYPED
	MOVE C,-1(P)
TYCI67:	HRRE C,TTYSTS(C)	;MY USER INDEX
	JUMPL C,TYCI92
	MOVE C,UNAME(C)
	CAMN C,[-1]
	JRST TYCI92
TYCI91:	MOVE T,[440600,,COMT1(I)]
	MOVEM C,COMT1(I)
TYCI42:	ILDB A,T
	JUMPE A,POPJ1
	ADDI A,40	;CONVERT MY UNAME FROM SIXBIT TO ASCII
	PUSHJ P,TTYI13	;ECHO CHARACTER ON HIS TTY
	TLNE T,770000
	JRST TYCI42
	JRST POPJ1


TYCI92:	MOVSI C,(SIXBIT /T/)
	LDB T,[030300,,-1(P)]
	ADDI T,20
	DPB T,[300600,,C]
	LDB T,[000300,,-1(P)]
	ADDI T,20
	DPB T,[220600,,C]
	JRST TYCI91

;ACTUALLY JOIN MY TTY AND HIS IN COM LINK.
TYCI43:	MOVE TT,I	;HIS TTY # IN TT, MINE IN H.
	PUSHJ P,TYCREP	;LOOP OVER TTYS LINKED TO HIM.
	 PUSHJ P,TYCI68	;PRINT OUT MSG FROM ON ALL LINKED TO HIM, NOT HIM.
	 JFCL
	EXCH TT,H	;INTERCHANGE HIS AND MINE.
	MOVE I,TT	;LOOK AT ALL LINKED TO ME.
	PUSHJ P,TYCREP	;ON EACH OF MINE, GIVE NAMES OF HIS.
	 PUSHJ P,TYCI69
	 JFCL
	EXCH TT,H
	MOVE A,TTYCOM(TT)	;SET UP LINK
	MOVE B,TTYCOM(I)	;LINK TTYCOM WORDS
	HRRE E,A
	AOJN E,TYCI45
	HRRM TT,A
TYCI45:	HRRE E,B
	AOJN E,TYCI46
	HRRM I,B
TYCI46:	HRRZ D,A
	HRRZ E,B
	HRRM E,A
	HRRM D,B
	TLZ A,%TCTMP	;HE'S NO LONGER TEMPORARILY IN COM MODE,
	MOVEM A,TTYCOM(TT) ;BUT PERMANENTLY INSTEAD.
	MOVEM B,TTYCOM(I)
	MOVEI A,TYCG
	MOVEM A,TTYIPC(I)
	MOVEM A,TTYIPC(TT)
	POPJ P,

TYCI69:	CAIE I,(TT)	;PRINT MSG ON ONE OF MY TTYS.
	 JRST TYCI70
	SKIPA T,[[ASCIZ/G /]]	;MY TTY, SAY "G".
TYCI70:	MOVEI T,[ASCIZ/
MESSAGE TO /]
	JRST TYCI71	;DUE TO EXCH'S IN TYCI43,
			;EXCHANGE "ME" AND "HIM" IN COMMENTS IN TYCI71.


;TTYIPC FOR RESPONSE TO A QUERY ABOUT A ^_C ATTEMPT.
TCIR:	PUSHJ P,TYCLWR	;CONVERT LOWER DTO UPPER CASE.
	PUSH P,A	;GET RESPONSE CHR
	PUSHJ P,TYCI2	;ECHO CHARACTER AND RESET IPC TO NORMAL.
	POP P,A
	MOVE H,COMT1(I)	;TTY NUMBER I THINK QUERIED ME.
	MOVE B,TTYIPC(H)
	CAIE B,TCIRW	;SKIP IF HE IS WAITING FOR ME
	CAIN B,TCIRW2
	JRST .+2
	 JRST TYCI33	;HE WENT AWAY? IF SO, FORGET HIM.
	CAIN A,"Y
	 JRST TYCI43	;I ACCEPTED, LINK COM WORDS AND GO
TCIR2:	PUSH P,H
	PUSHJ P,TYCI33	;TAKE ME OUT OF COM MODE
TCIR3:	POP P,I		;HIS TTY NUMBER
	PUSHJ P,TYCSET
	MOVEI T,[ASCIZ /N /]
	PUSHJ P,TYCI40
	PUSHJ P,TYCI17	;RESET HIS IPC TO NORMAL (FROM TCIRW OR TCIRW2)
	JRST TYCI33	;TAKE HIM OUT OF COM MODE (MAYBE)

;TTYIPC FOR THE ^_C'ER WAITING FOR ANSWER TO QUERY.
TCIRW:	CAIN A,^G	;^_C'ER MAY USE ^G TO GET ATTENTION.
	 JRST TCIRW4
	CAIE A,^_	;IGNORE ALL TYPEIN EXCEPT ^G AND ^_N.
	 POPJ P,
	JSP D,TYCRDE	;^_, ECHO IT AND GET NEXT CHAR.
TCIRW2:	PUSHJ P,TYCLWR
	CAIN A,"N
	JRST TCIRW3
	MOVEI A,"?	;^_ FOLLOWED BY OTHER THAN N.
	MOVEI B,TCIRW
	MOVEM B,TTYIPC(I)
	JRST TTYI13	;ECHO ? AND GO BACK TO TCIRW

TCIRW3:	PUSHJ P,TYCI2	;^_N, ECHO N AND RESET IPC TO NORMAL.
	MOVE H,COMT1(I)	;GET HIS TTY #.
	JRST TCIR2	;REMOVE US FROM COM MODE IF NEC.

TCIRW4:	PUSHJ P,TTYI18	;^_C'ER TYPED ^G - ECHO ON HIS TTY
	MOVE I,COMT1(I)	;AND ^_C'D TTY.
	PUSHJ P,TYCSET
	JRST TTYI13

;NORMAL COM MODE TTYIPC, ECHO ON ALL TTYS IN LOOP.
TYCG:	CAIN A,^_	;REC CHRS IN COM MODE
	JRST TYCGTN
TYCG21:	PUSH P,TTYCOM(I)	;SAVE COMMUNICATE WORD.
	PUSH P,I	;SAVE MY CONSOLE NUMBER
	PUSH P,A	;SAVE THE CHARACTER
	TLNE Q,ICO	;SKIP IF INPUT COM OVERRIDE OFF
	PUSHJ P,TTYI2	;PROCESS INPUT OVERRIDE
	TLNN Q,ICO
	PUSHJ P,TTYI18	;ECHO CHR ON MY TTY IF ICO NOT SET, OTHERWISE GIVE TO PROGRAM
	MOVE A,(P)	;RESTORE CHARACTER
TYCG5:	HRRE B,TTYCOM(I)	;FIRST TTY IN CHAIN
	JUMPL B,[JRST 4,.]	;I'M NOT COMMUNICATING WITH ANYONE
	CAME B,-1(P)	;SKIP IF I'M COMMUNICATING WITH MYSELF
TYCG3:	SKIPL C,TTYCOM(B)	;SKIP IF HE IS IN COMMUNICATE MODE (THIS POINT IS "COM IN")
	JRST 4,.	;LOSSAGE
	MOVE I,B	;GET HIS TTY NUMBER IN I
	MOVE R,TTYTYP(I)
	MOVE B,-2(P)
	TLNE Q,RFT	;IF MY RFT AND HIS LFT SET,
	TLNN C,LFT
	 JRST TYCG1
	MOVSI U,%TSLCZ	;GIVE CHAR TO HIS PROGM.
	ANDCAB U,TTYSTS(I)
	PUSHJ P,TTYI2	;TREAT CHAR AS INPUT FROM HIS TTY.
	JRST TYCG2	;PROCESS NEXT TTY IN CHAIN

TYCG1:	PUSHJ P,TTYI13	;OUTPUT CHAR ON HIS CONSOLE
TYCG2:	MOVE A,(P)	;RESTORE CHARACTER
	HRRE B,TTYCOM(I)	;NEXT TTY IN CHAIN
	JUMPL B,[JRST 4,.]	;CHAIN ENDS STRANGELY
	CAME B,-1(P)	;SKIP IF DONE
	JRST TYCG3	;PROCESS NEXT TTY
	SUB P,[3,,3]
	POPJ P,

;COME AFTER READING UNAME AFTER ^_K, HIS TTY # IN B.
TYCK1:	MOVEM Q,TTYCOM(I)	;CLEAR %TCCBK BIT.
	PUSHJ P,TYCREP	;NO GOOD IF THAT TTY ISN'T LINKED TO ME.
	 CAIN B,(I)
	CAIN B,(I)	;BUT NO GOOD IF IT IS ME.
	JRST TYCI25	;NO GOOD, COMPLAIN.
	MOVE I,B
	PUSHJ P,TYCSET	;GET HIS TTYCOM IN Q.
	TLO Q,%TCCBK	;SAY WANT A ^_N ECHOED ON HIM.
	JRST TYCGTM	;NOW PRETEND HE DID ^_N (READ "HIM" FOR "ME")

;^_N TYPED IN.
TYCN:	PUSHJ P,TYCI2	;ECHO THE N
	SKIPL TTYCOM(I)
	POPJ P,
TYCGTM:	HRRE B,TTYCOM(I)	.SEE TTYLFC
	JUMPL B,[JRST 4,.]	;WASN'T COMMUNICATING WITH ANYONE
	CAMN B,I
	JRST 4,.	;COMMUNICATING WITH SELF
TYCGT3:	HRRE C,TTYCOM(B)
	JUMPL C,[JRST 4,.]	;LIST NOT CIRCULAR
	CAMN C,I
	JRST TYCGT4	;B HAS TTY NUMBER OF GUY POINTING TO ME
	MOVE B,C
	JRST TYCGT3

TYCGT4:	HRRZ C,TTYCOM(I)
	PUSH P,B
	PUSH P,C
	PUSHJ P,TYCGT6	;TAKE ME OUT OF COM MODE.
	POP P,C
	POP P,B
	EXCH I,B
	PUSHJ P,TYCSET
	CAME C,I	;SKIP IF ONLY 1 IN LOOP BESIDES ME.
	JRST TYCGT5
	HLLOS Q,TTYCOM(I)
	JRST TYCI33	;TAKE HIM OUT OF COM MODE

TYCGT5:	HRRM C,TTYCOM(I)	;TAKE ME OUT OF THE CIRCULAR LIST
	MOVEI H,(B)
	SETO TT,	;FOOL TEST AT TYCI66
	PUSHJ P,TYCREP	;TELL ALL THE OTHERS THAT I'VE LEFT.
	 PUSHJ P,TYCI73
	 JFCL
	POPJ P,

TYCI73:	JSP T,TYCI71	;PRINT MSG AND MY UNAME ON TTY # IN I.
	ASCIZ/
BYE FROM /


TYCGT6:	HLLOS TTYCOM(I)	;I'M NO LONGER LINKED TO ANYONE.
	HRRI Q,-1
	TLZE Q,%TCCBK	.SEE TYCK1 ;IF I'M BEING ^_K'D,
	 JRST TYCI33	;MAKE SURE I SEE ^_N TO KNOW ABOUT IT.
	TLNE Q,%TCTMP	;TEMPORARILY NEEDS COM MODE, DON'T REMOVE.
	 POPJ P,
	TLZ Q,%TCTPN	;I JUST TYPED ^_N SO DON'T TYPE IT OUT
	JRST TYCI33

TYCI37:	SKIPA A,["B]	;TARGET USER BUSY.
TYCI36:	MOVEI A,"N	;TARGET USER REFUSES.
	JRST TYCI57

TYCI25:	MOVEI A,"?	;ATTMEPT TO ESTABLISH LINK FAILS
TYCI57:	PUSHJ P,TYCI2	;ECHO A ?
	TLZ Q,%TCCBK+%TCCBS
TYCI33:	SKIPL Q
	JRST 4,.	;TTY NOT IN COMMUNICATION MODE
	MOVEM Q,TTYCOM(I)
	SETCM A,TTYCOM(I)
	TRNN A,-1	;IF STILL LINKED TO OTHERS
	TLNN A,%TCTMP	;OR TEMPORARILY REQUIRES COM MODE
	 POPJ P,	;DON'T LEAVE COM MODE.
	TLNN Q,%TCTPN	;IF I WAS OR TRIED TO BE LINKED,
	 JRST TYCI50
	MOVEI A,^_	;TYPE ^_N AT ME SAYING I'M NO LONGER SO.
	PUSHJ P,TTYI13
	MOVEI A,"N
	PUSHJ P,TTYI13
TYCI50:	MOVSI D,400000+OCO+RFT+LFT+ICO+%TCTPN
	ANDCAM D,TTYCOM(I)	;LEAVE COMMUNICATION MODE
IFN TCFFLP,[
	HRLOI D,%TCFFL	;FORCE ECHO BFR TO BE EMPTIED BEFORE
	SKIPN ECHOC(I)
]
	MOVEI D,-1
	IORM D,TTYCOM(I)	;DOING ANY OUTPUT.
	MOVE D,TTYIPC(I)	;IF TTY IS IN NORMAL COM MODE INPUT,
	CAIN D,TYCG	;CHANGE TO NORMAL TYPEIN.
	 MOVEI D,TTYI
TYCRED:	MOVEM D,TTYIPC(I)
	POPJ P,		;AND RETURN

TYP:	LDB J,[220300,,TTYTYP(I)] ;GET TTY OUTPUT SPEED.
TYP0:	MOVE P,TTYPDP
TYP0B:	HRRZ W,TCTYP(I)
	MOVE T,TTYTYP(I)
	MOVE H,TTYOPT(I)
	TRNE H,3*%TPIBM
	 JRST [ PUSHJ P,[JSP E,TYP27
			 SUB P,[1,,1]
			 JRST .+1]
		JRST TTYRET]
	MOVE A,TIME
	MOVEM A,TTLTM(I) ;UPDATE TIME OF LAST OUTPUT THIS TTY.
TYP0F:	PUSHJ P,TYPLUP	;OUTPUT AT LEAST 1 CHAR.
	TRNE T,%TYSTY
	POPJ P,	;CALLED FROM STTYI (PSEUDO-TTY)
IFN MTYP\DPKPP,	TRNN T,%TYDPK\%TYMTY
	 JRST TTYRET
IFN DPKPP\MTYP,[
	SKIPGE TTYOAC(I)
	 JRST MTYO1
	SKIPLE DBBCC	;SKIP IF OUT OF ROOM
	 JRST TYP0F	;CONTINUE MESSAGE
MTYO2:
IFN MTYP,[
	CONO MTY,@TTYLT(I)
	DATAO MTY,MTYOW	;SEND CHARS
]
.ELSE [
	MOVE A,DBBCC1	;SIZE OF BUFFER
	SUB A,DBBCC	;MINUS SPACE LEFT
	ADDM A,@DPKC-NFDPT(I) ;GIVES # CHARS STORED.
	XCT TTYST(I)
]
	JRST TTYRET

MTYO1:	SKIPL DBBBP	;SKIP IF NOTHING TO SEND
	 JRST MTYO3	;SEND WHAT THERE IS
	XCT TTYDFF(I)	;CLEAR OUTPUT DONE
	JRST TTYRET

MTYO3:	AOS TTYOAC(I)
	JRST MTYO2
]

IFN NNVTTS,[
TYP0:	AOSE NVTSIP	;CHAR PENDING?
	JRST TYP0A	;NO
	DATAO NTY,NVTSSC	;SEND CHR AFTER SELECT
	JRST TTYRET

TYP0A:	SKIPN A,NVOPTT
	MOVEI A,NOTYS+NNTYS+NNVTTS-1
	MOVEM A,NNVSEC	;SET UP END CHECK
	SKIPN I,NVOPTT
	MOVEI I,NOTYS+NNTYS	;INITIALIZE
	SETOM NNVSFL	;SET FIRST TIME THRU FLAG
	MOVE A,NVTCC
	CAIGE A,10	;SENT TOO MANY CHRS TO THIS CONSOLE W/O LOOKING AT OTHERS?
	JRST TYP0D	;NO, LOOK AT CONSOLE
	SETZM NVOPTT
	SETZM NVTCC	;YES LOOK AT OTHERS
TYP0C:	AOS I
	CAIL I,NOTYS+NNTYS+NNVTTS
	SUBI I,NNVTTS
	AOS NNVSFL
	JRST TYP0D
]
TYP27:	AOSL 27LICR(I)
	AOSGE 27IGE(I)
	JRST TYP27W
	AOSN 27STOU(I)
	JRST TYP5C
	AOSL B,27SE(I)
	JRST TYP27C
	MOVE A,[177,,27EOA]
	JRST TYPDA6
TYP27C:	JUMPN B,TYP27D
	MOVEI B,200
	MOVE A,[177,,27LWR]
	TDNN B,27SAVC(I)
	MOVE A,[177,,27UPR]
	TDNN B,27SAVC(I)
	MOVEI B,400
	MOVEM B,27CASE(I)
	JRST TYPDA6

TYP27D:	SKIPGE 27STOU(I)
	JRST TYP27B
	SKIPGE 27LIAT(I)
	SKIPGE 27CTLF(I)
	JRST TYP27B	;BLOCKED
	SKIPGE A,27SAVC(I)
	JRST (E)
	SKIPGE 27PMS(I)
	AOS 2741E	;27SAVC(I) SHOULD BE -1 WHEN IN PROC MODE
	SETOM 27SAVC(I)
	JRST TYPDA3

TYP27B:	SKIPGE 27PMS(I)
	JRST TYP5C
	SKIPL B,27FLG(I)
	JRST TYP27E
TYP27Y:	MOVNI A,2
	MOVEM A,27STRT(I)
	SETOM 27FCLK
	SETZM 27FLG(I)
	XCT TTYDFF(I)
	POPJ P,
TYP27E:	JUMPN B,[JRST 4,.]
	SETOM 27FLG(I)
	SKIPGE A,27TIME(I)
	JRST TYP27F
	SUB A,TIME
	CAML A,[-7]
	JRST TYP27Y
	SETOM 27TIME(I)
TYP27F:	MOVE A,[177,,27EOT]
	MOVNI B,2
	MOVEM B,27IGE(I)
	SETOM 27PMS(I)
	MOVEI B,200
	MOVEM B,27CASE(I)
	JRST TYPDA6

TYP27W:	MOVNI A,16
	MOVEM A,27STRT(I)
	SETOM 27FCLK
	XCT TTYDFF(I)
	POPJ P,

TYP27S:	SETZM 27FCLK
	MOVSI I,-NCT
	MOVSI TT,%TTIBM
TYP27T:	TDNN TT,TTYTYP(I)
TYP27U:	AOBJN I,TYP27T
	JUMPGE I,CPOPJ
	AOSN 27STRT(I)
	XCT TTYST(I)
	SKIPGE 27STRT(I)
	SETOM 27FCLK
	JRST TYP27U

TYPLUP:	SKIPE B,TTYBYP(I)
	 JSP E,TYPBP
	MOVE Q,TOOP(I)
	CAMN Q,TOIP(I)
	 JRST TYPEND	;NOTHING IN OUTPUT BUFFER.
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB A,Q	;LOOK AHEAD AT NEXT BUFFER CHARACTER.
	TRZE A,%TXDIS	;IF DISPLAY OR CURSOR MOTION, DISPATCH.
	 JRST [	CAIL A,%TDMAX-%TXDIS
		 JRST 4,.	;ILLEGAL CURSOR CONTROL CODE.
		CAIN W,%TNSFW	;"SOFTWARE" TTY GETS THE CODES
		 JRST TYPSIO	;AS THEY APPEAR IN THE BUFFER.
		JRST @TYPDTB(A)]
	TRNE H,%TPORS	;IF MUST RECORD CURSOR POS AT INT LEVEL,
	CAIN A,177	;RUBOUT NEVER MOVES CURSOR.
	 JRST TYPSIO
	CAIE A,^I
	TLNN H,%TOSAI	;CTL CHARS ARE SPACING IFF SAIL CHAR SET;
	CAIL A,40	;NON-CONTROLS ARE SPACING.
	 AOS TTYIHP(I)
;NOTE CONVERSION OF ALTMOD TO $ AND CTRL-FOO TO UPARROW FOO
;ALREADY DONE, AND FORMATTING CONTROLS TURN INTO
;CURSOR MOTION COMMANDS WHICH DON'T GET HERE.
TYPSIO:	MOVEM Q,TOOP(I)	;REMOVE CHAR FROM OUTPUT BUFFER.
	AOS TORM(I)
TYPOU2:
IFN DPKPP\MTYP,[
	TRNN T,%TYDPK\%TYMTY
	 JRST TYPOU1
IFN MTYP,JUMPE A,CPOPJ	;FOR DPK OR MTY, STICK CHAR IN LOW LVL BUFFER.
	IDPB A,DBBBP
	SOSLE DBBCC
	 JRST TYPLUP	;ROOM FOR MORE CHARS.
	SKIPE DBBCC
	JRST 4,.
	POPJ P,
]

;ACTUALLY OUTPUT A CHAR TO THE TTY.
TYPOUT:
IFN DPKPP\MTYP,[
	TRNN T,%TYDPK\%TYMTY
	 JRST TYPOU1
IFN MTYP,JUMPE A,CPOPJ	;FOR DPK OR MTY, STICK CHAR IN LOW LVL BUFFER.
	IDPB A,DBBBP
	SOSGE DBBCC
	JRST 4,.
	POPJ P,
]
TYPOU1:	TRNE H,%TPIBM*3
	 JRST TYPDA
TYPI3A:	TRNE T,%TYSTY
	 JRST [ HRRZM A,STYICH ;WANT 8 BITS OF CHAR FOR STY.
		POPJ P,]
	IMUL A,[2010040201]
	AND A,[21042104377]
	IDIVI A,17_7
	MOVE A,B
TYPDA1:	CAIL I,NFDPT
	 JRST 4,.
	XCT TTYDO(I)	;DATAO XXX,A
	POPJ P,

;IF TTYBYP ISN'T 0, IT IS B.P. TO ASCIZ STRING TO TYPE.
;COME HERE TO OUTPUT THE NEXT CHAR OF THE STRING OR CLEAR TTYBYP.
;CALL WITH JSP E,
TYPBP:	ILDB A,TTYBYP(I)
	JUMPN A,TYPOU2	;NOT END => OUTPUT THE CHAR.
	CLEARM TTYBYP(I) ;END OF ASCIZ STRING.
	JRST (E)

;COME HERE FROM TYPLUP WHEN THERE'S NOTHING TO TYPE OUT.
;CALL ALSO FROM TT11I4 WHEN THE PDP11 SAYS THE OUTPUT BUFFER IS EMPTY.
TYPEND:	SKIPL TYOSW(I)	;IF ECHOING CAN BE DONE NOW,
	 JRST TYPEN1
	MOVE Q,TTYCOM(I)
	TLNN Q,%TCDNG	;IS THERE ECHOING NEEDING TO BE DONE?
	SKIPE ECHOC(I)
	 PUSHJ P,TTYI7	;IF SO, QUEUE IT.
	SKIPGE TTYLPP(I)
	 PUSHJ P,TTYI7	;ALSO FORCE OUT BUFFERED CURSOR MVT.
TYPEN1:	TRNE H,%TPIBM*3
	 JRST TYP27Z
	TRNE T,%TYDPK+%TYSTY+%TYMTY+%TY11T	;SKIP IF NOT DPK, NOT PSEUDO-TTY, AND NOT MORTON TTY
	 JRST TYP5D
IFN NNVTTS,[
	TRNE T,%TYNVA
	 JRST TYP5	;NOVA TTY
]
TYP5C:	XCT TTYDFF(I)	;STOP OUTPUT
TYP5D:	SETOM TTYOAC(I)
	POPJ P,

TYP27Z:	SKIPGE 27PMS(I)
	JRST TYP5C
	MOVNI A,2
	MOVEM A,27STOU(I)
	JRST TYP27Y

IFN NNVTTS,[
TYP5:	CAMN I,NNVSEC	;REACHED END
	AOSG NNVSFL	;AND NOT FIRST TIME
	JRST TYP5B	;LOOK AT OTHER NOVA CONSOLES
	MOVE I,NOVATT
	JRST TYP5C

TYP5B:	SUB P,[1,,1]
	JRST TYP0C
]

;COME HERE TO DO CURSOR MOTION ON PRINTING TTYS.
;TT HAS DESIRED HPOS; D HAS DESIRED VPOS.
;NOTE THAT AFTER EACH VERTICAL MOTION COMMAND ON PRINTING TTY,
;THE VPOS IS ZEROED (HAPPENS SEPARATELY FOR EACH TRANSACTION
;AT MP LEVEL, THEN AGAIN AT INT LVL).
;THIS IS TO PREVENT VERY LARGE VPOS'S FROM BUILDING UP.
TYMPRT:	CAMGE TT,TTYIHP(I) ;BACKWARD MOTION TAKES PRIORITY.
	 JRST TYMPH1
	CAMLE D,TTYIVP(I) ;THEN DOWNWARD MOTION.
	 JRST TYMPV2
	CAMLE TT,TTYIHP(I) ;THEN FORWARD MOION.
	 JRST TYMPHF
	MOVEM D,TTYIVP(I) ;MUST BE UPWARD MOTION
	JRST TYMOV8	;WHICH IS A NO-OP ON PRINTING TTYS.

TYMPV2:	AOS TTYIVP(I)	;MOVING DOWN: DO ONE LF
	MOVEI A,^J
	PUSHJ P,TYPOUT
	PUSHJ P,TYMOVX	;IF REACHED GOAL, SAY FINISHED.
	LDB B,[$TPPLF,,TTYOPT(I)]
	MOVE B,TYMPVT(B)	;# PADDING AFTER LF.
	JRST TYMPAD

TYMPVT:	0	;NORMAL
	1	;2741, MEMOWRECK
	12.	;TERMINET
	0 ? 0 ? 0 ? 0 ? 0	;EXTRA

TYMPHF:	LDB B,[$TPPTB,,TTYOPT(I)] ;FORWARD: CAN WE DO IT WITH TABS?
	JUMPE B,TYMPH6	;TABS NOT ALLOWED ON THIS TTY.
	MOVE A,TTYIHP(I)
	ANDCMI A,7	;SEE WHERE A TAB WOULD BRING US.
	CAIL A,-10(TT)	;BEYOND WHERE WE WANT TO GO?
	 JRST TYMPH6
	SUBI A,-10(B)	;A HAS TAB STOP - <# PADDING>-1
	CAMG A,TTYIHP(I) ;TAB FASTER THAN SPACES (INCLUDING PADDING)?
	 JRST TYMPH6	;NO, USE SPACES.
	ADDI A,(B)	;A HAS TAB STOP.
	MOVEM A,TTYIHP(I)
	MOVEI A,^I
	SOJA B,TYMPT1	;B HAS # PADDING AFTER TAB.

TYMPH6:	AOSA TTYIHP(I)	;FORWARD: OUTPUT 1 SPACE.
TYMPH2:	 SOSA TTYIHP(I)	;BACKWARD: 1 BACKSPACE.
	SKIPA A,[40]
	 MOVEI A,^H
	PUSHJ P,TYPOUT
	JRST TYMOVX

;COME HERE TO MOVE BACKWARDS.
TYMPH1:	TRNN H,%TPIBM*3	;2741 CAN'T CR WITHOUT LF:
	 JRST TYMPH4
	CAMG D,TTYIVP(I) ;SO IF WANT TO DO THAT,
	 JRST TYMPH2	;USE BACKSPACES.
TYMPH4:	MOVE A,TTYIHP(I)
	SUB A,TT	;A HAS # CHARS IF WE BACKSPACE.
	LDB B,[$TPPCR,,TTYOPT(I)]
	JUMPE B,TYMPH5
	MOVE E,B	;E HAS PADDING TYPE OF TTY,
	MOVE B,TTYIHP(I) ;B HAS CURRENT HPOS.
	CAIL E,1_<<$TPPCR_-12.>&77>-TYMPHL
	 JRST @TYMPHT-TYMPHL(E)
	IDIVI B,33.
	LDB C,[$TTOSP,,TTYTYP(I)]
	CAIE C,2
	AOS B		;15 OR 30 CPS LINE
	CAIN C,4
	ADDI B,2(B)	;30 CPS
	IMULI B,(E)
	ADDI B,-1(E)
	MOVE C,D
	SUB C,TTYIVP(I)	;IF WE'RE MOVING DOWN AFTER THE CR, HOW FAR?
	TRNE H,3*%TPIBM
	 SUBI C,1	;ON 2741, THE CR INCLUDES 1 LF.
	JUMPLE C,TYMPH5
	SUB B,C		;EACH LF REDUCES # PADDING NEEDED BY CR.
	CAIGE B,	;BUT CAN'T NEED LESS THAN 0 PADDING.
	 SETZ B,
;B HAS # CHARS PADDING NEEDED AFTER CR, IF WE DECIDE TO CR.
TYMPH5:	TLNN H,%TOMVB	;HOW DO WE MOVE BACKWARD?
	 JRST TYMPH3	;CAN'T BS => MUST CR AND SPACE FWD.
	TRNE H,%TPIBM*3	;ON 2741 CR OBVIATES LF, SAVING TIME.
	 ADDI A,2
	LDB E,[$TPPTB,,TTYOPT(I)]
	JUMPE E,[MOVE C,TT ;CAN'T USE TABS: C _ TIME IF MOVE FWD.
		JRST TYMPT2]
	PUSH P,B	;CAN USE TABS: SEE HOW LONG TO GO FWD
	MOVE B,TT	;USING TABS.
	IDIVI B,10	;NEED C(B) TABS AND C(C) SPACES.
	IMULI B,(E)	;B _ TIME NEEDED FOR TABS & PADDING.
	ADDI C,(B)	;C _ TIME NEEDED TO GO FWD.
	POP P,B
TYMPT2:	ADDI C,1(B)	;ADD IN TIME TO CR, + PADDING.
	CAML C,A
	 JRST TYMPH2	;FASTER TO BACKSPACE.
TYMPH3:	MOVEI A,^M	;OUTPUT A CR (WILL SPACE FORWARD LATER)
	TRNE H,%TPIBM*3
	 AOS TTYIVP(I)
	SETZM TTYIHP(I)	;WHEN WE COME BACK WE'LL SEE WE
TYMPT1:	PUSH P,B	;NEED TO GO FORWARD.
	PUSHJ P,TYPOUT
	POP P,B
	PUSHJ P,TYMOVX
	JRST TYMPAD	;PAD THE TTY (# CHARS PADDING IN B)

	TYMP27
	TYMPMW
	TYMPGE
TYMPHT:	TYMPHL==3

TYMPGE:	MOVEI B,20.
	JRST TYMPH5

TYMP27:	IDIVI B,10.
	CAILE B,14.
	MOVEI B,14.
	AOJA B,TYMPH5

TYMPMW:	JUMPE B,TYMPM1	;NO CHRS
	MOVNS B
	ADDI B,43.
	CAIGE B,2
TYMPM1:	MOVEI B,2
	JRST TYMPH5

;COME HERE TO PAD A PRINTING TERMINAL: # CHARS OF PADDING IN B.
TYMPAD:	SKIPN A,B
	 POPJ P,
	IDIVI A,5
	MOVNS A
	ADD A,TYMPA1(B)	;CREATE A BP TO A STRING WITH THE RIGHT # OF RUBOUTS.
	MOVEM A,TTYBYP(I)
	POPJ P,

;THIS IS AN ASCIZ STRING OF 90. RUBOUTS.
;SOME FINAL SEGMENT OF IT WILL BE TYPED OUT.
TYMPA0:	REPEAT 90./5,  -2
TYMPA2:	0

TYMPA1:	010700,,TYMPA2-1
	100700,,TYMPA2-1
	170700,,TYMPA2-1
	260700,,TYMPA2-1
	350700,,TYMPA2-1

;2741 STUFF.
TYPDA:	HRLZ B,A
	PUSH P,B
	LDB B,[0200,,A]
	LSH A,-2
	MOVEI C,BCDTBL(A)
	TRNE H,%TPIBC
	MOVEI C,CORTBL(A)
	HLL C,9BPTR(B)
	LDB A,C
	TDNN A,27CASE(I)
	JRST TYPDCC	;CASE IS INCORRECT
	POP P,B
	HLL A,B
	JRST TYPDA2

TYPDCC:	POP P,27SAVC(I)
	HRRM A,27SAVC(I)
	MOVE A,[177,,27LWR]
	MOVE B,27CASE(I)
	TRNN B,400	;SKIP IF UPPER CASE
	MOVE A,[177,,27UPR]
	TRC B,600
	MOVEM B,27CASE(I)
TYPDA2:	SKIPL 27PMS(I)	;SKIP IF IN PROC MODE
	JRST TYPDA3
	SKIPGE TTYOAC(I)
	JRST 4,.
	XCT TTYDFF(I)	;CLEAR TTO FLAG
	XCT 27BRK-NF2741(I)	;SEND BREAK
	MOVNI C,30
	MOVEM C,27STRT(I)
	SETOM 27FCLK
TYPDA4:	SETZM 27PMS(I)
	MOVNI C,2
	MOVEM C,27SE(I)	;EOA FLAG
	SKIPGE 27SAVC(I)
	MOVEM A,27SAVC(I)	;FIRST CHAR NOW IN 27SAVC(I)
	POPJ P,

TYPDA3:	SKIPE 27PMS(I)
	JRST TYPDA4	;OUT OF PROC MODE DUE TO ATT
	HRROI B,777177
	AND A,B
TYPDA6:	PUSHJ P,TYPDA1	;SEND CHR
	HLRZS A	;GET BACK ASCII CHR
	POPJ P,

TYPDTB:	OFFSET 200-.	;DISPATCH TABLE FOR CURSOR CONTROL CMDS.
%TDMOV::TYMOV	;MOVE CURSOR
%TDMV1::TYMOV2	;DUMMY COMMAND CREATED BY TYMOV.
		;MAKES IT POSSIBLE FOR TYMOV TO STOP WHEN BUFFER FULL
		;AND BE REENTERED NEXT INTERRUPT.
%TDEOF::TYEEOF	;CLEAR REST OF PAGE
%TDEOL::TYEEOL	;CLEAR REST OF LINE
%TDDLF::TYEDLF	;DELETE FORWARD (FOR IMLACS)
%TDMTF::TYEMTF	;MOTOR OFF (FOR TERMINETS)
%TDMTN::TYEMTN	;MOTOR ON (FOR TERMINETS)
%TDCRL::TYECRL	;CRLF ON DATAPOINTS.
%TDMAX::OFFSET 0

;%TDMOV MOVE CURSOR COMMAND DISPATCHES HERE.
TYMOV:	CAMN Q,TOBEP(I)	;FETCH THE NEXT 2 CHARS WHICH
	 SUBI Q,TOBL	;HOLD THE "OLD" POSITION
	ILDB A,Q
	MOVEM Q,TOOP(I)	;AND FLUSH THE 1ST FROM THE BUFFER.
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB B,Q
	CAIGE W,%TNMAX
	JUMPGE W,@TYMDTB(W) ;ON IMLACS, ARDS, CAN JUST ZAP OUT NEW POS.
	JRST 4,.

TYMDTB:	OFFSET -.
%TNPRT::TYMDP	;PRINTING
%TNDP::	TYMDP	;DATAPOINT
%TNODP::TYMDP
%TNIML::TYMIML	;IMLAC
%TNARD::TYMARD	;ARDS
%TNTV::	[JRST 4,.]
%TNARH::TYMARH	;HORIZONTAL ARDS.
%TNSFW::[JRST 4,.]
%TNMAX::OFFSET 0

;%TDMOV COMMAND ON DATAPOINTS AND PRINTING TERMINALS.
TYMDP:	MOVSI C,%TCPAD	;FOR DATAPOINTS, PADDING WILL BE NECESSARY NOW.
	ANDCAM C,TTYCOM(I)
	MOVEM A,TTYIVP(I) ;DATAPOINTS: MUST OUTPUT A STRING OF
	MOVEM B,TTYIHP(I) ;CURSOR MOTION CHARS. REMEMBER CURRENT POS.
	MOVEI A,%TDMV1	;PUT A NEW COMMAND IN OUTPUT BUFFER
	DPB A,Q
	MOVEI A,2	;WE'RE FLUSHING 1ST 2 CHARS OF THIS ONE.
	ADDM A,TORM(I)
;SINCE IT MAY NOT BE POSSIBLE TO OUTPUT ALL THE NECESSARY CURSOR
;MOTION CHARS THIS TIME AROUND, PUT IN THE OUTPUT BUFFER
;A COMMAND THAT WILL MAKE US PICK UP WHEREVER WE LEFT OFF BY
;REENTERING AT TYMOV2. WHEN WE REACH DESTINATION, THAT CMD WILL
;BE REMOVED FROM THE BUFFER. BUFFER NOW HOLDS:
; %TDMV1 ? NEW VPOS ? NEW HPOS
TYMOV2:	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL	;FETCH DESIRED POS. FROM BUFFER.
	ILDB D,Q
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB TT,Q
	JUMPE W,TYMPRT
;DATAPOINTS ONLY PAST THIS POINT
TYMOV3:	MOVE B,TTYIVP(I)	;CURRENT HARDWARE VERTICAL POSITION
	SUB B,D		;SUBTRACT VERTICAL POSITION OF WHERE WE WANT TO BE
	MOVM C,B	;C IS HOW FAR WE HAVE TO GO UP OR DOWN
	MOVE A,TTYIHP(I) ;COMPUTE NET CHRS TO POSITION
	SUB A,TT
	MOVMS A		;A IS HOW FAR WE HAVE TO GO HORIZONTALLY
	CAMLE A,TT	;SKIP IF NOT SHORTER TO CR FIRST
	 MOVEI A,1(TT)	;# CHARS IF CR FIRST.
	ADD A,C	;A NOW HAS TOTAL NUMBER OF CHARS TO SEND TO GET THERE
	JUMPE A,TYMOV8	;WE'RE THERE
	MOVE C,D
	ADD C,TT	;C HAS NUMBER OF CHARS IT WOULD TAKE IF WE HOMED UP FIRST
	MOVE E,TCMXV(I)
	SUBI E,1
	SUB E,D		;E HAS NUMBER IF HOME DOWN FIRST
	JUMPL E,TYPCPG
	ADD E,TT
	CAMGE C,A
	JRST TYMHU	;HOME UP SHORTER
	CAMGE E,A
	JRST TYMHD	;HOME DOWN SHORTER
TYPCPG:	JUMPN B,TYMDP1	;V POS DIFFERS
TYMDPL:	MOVE B,TTYIHP(I)
	SUB B,TT
	JUMPE B,TYMOV8
	JUMPGE B,TYMDP6	;TOO FAR OUT
;FALLS THROUGH.

;FALLS THROUGH.
	JSP E,TYMDPP	;PAD IF NEC.
	MOVE C,[AOS TTYIHP(I)]
	MOVEI A,%DPFS	;DATAPOINT FWD SPACE.
	JRST TYMDP7

TYMDP6:	CAMG B,TT
	JRST TYMDP8
	MOVEI A,15	;BETTER TO CR FIRST
	CLEARM TTYIHP(I)
	MOVSI C,%TCPAD
	ANDCAM C,TTYCOM(I)
	MOVEI B,1
	MOVSI C,(JFCL)
	JRST TYMDP5

TYMDP8:	JSP E,TYMDPP
	MOVE C,[SOS TTYIHP(I)]	
	MOVEI A,%DPBS	;DATAPOINT BACK-SPACE.
	JRST TYMDP7

TYMDP1:	JUMPGE B,TYMDP2
	JSP E,TYMDPP
	MOVEI A,%DPDN	;DATAPOINT LINEFEED.
	MOVE C,[AOS TTYIVP(I)]
	JRST TYMDP5

TYMDP2:	JSP E,TYMDPP
	MOVEI A,%DPUP	;DATAPOINT LINE STARVE.
	MOVE C,[SOS TTYIVP(I)]
	JRST TYMDP5

TYMHU:	CAMLE C,E
	JRST TYMHD	;HOME DOWN IS BETTER
	CLEARM TTYIVP(I)
	CLEARM TTYIHP(I)
	MOVEI A,%DPHU	;DATAPOINT HOME-UP.
	MOVEI B,1
	MOVSI C,(JFCL)
	JRST TYMDP5

TYMHD:	SETZM TTYIHP(I)
	MOVE C,TCMXV(I)
	SUBI C,1
	MOVEM C,TTYIVP(I)
	MOVE A,CCHDP
	MOVEM A,TTYBYP(I)
	JRST TYPLUP

TYMDP7:	MOVMS B
TYMDP5:
IFN DPKPP\MTYP,[
	TRNN T,%TYDPK\%TYMTY	;SKIP IF CONTROLLER HANDLES >1 CHAR AT A TIME.
	 JRST TYMDP3
	JUMPE A,[JRST 4,.]
TYMDP4:	XCT C
	IDPB A,DBBBP
	SOSG DBBCC
	 JRST TYMOVY
	SOJG B,TYMDP4
	JRST TYMOVC
]
TYMDP3:	XCT C
	PUSHJ P,TYPI3A
;CAN'T OUTPUT ANY MORE: IF REACHED DESIRED POS, FLUSH THE
;%TDMV1; OTHERWISE RETURN LEAVING IT TO COME BACK HERE WHEN
;TTY CAN ACCEPT MORE OUTPUT.
TYMOVY:	SOJG B,TYMOVP
TYMOVX:	CAMN D,TTYIVP(I)
	CAME TT,TTYIHP(I)
	 POPJ P,
;WE USED UP ALL THE SPACE BUT GOT WHERE WE'RE GOING.
TYMOV9:	MOVEM Q,TOOP(I)	;FLUSH THE %TDMV1 COMMAND.
	MOVEI B,3
	ADDM B,TORM(I)
	POPJ P,

;WE FINISHED ONE SET OF OUTPUT CHARS, & HAVE ROOM FOR MORE.
;EITHER CONTINUE MOVING CURSOR, OR LOOK FOR NEXT THING TO DO.
TYMOVC:	CAME D,TTYIVP(I)
	 JRST TYMOV3	;VERT. POS STILL NEEDS CHANGING.
	CAME TT,TTYIHP(I)
	 JRST TYMDPL	;HORIZ POS STILL NEEDS CHANGING.
TYMOV8:	MOVEM Q,TOOP(I)	;FLUSH THE %TDMV1 COMMAND
	MOVEI B,3
	ADDM B,TORM(I)
	JRST TYPLUP	;AND GO GET NEXT THING FROM BUFFER.

;COME HERE TO PAD DATAPOINT IF NECESSARY.
TYMDPP:	MOVSI C,%TCPAD
	TRNN T,%TYSTY
	CAIL J,5	;NOT FAST LINE OR LAST CHAR WAS CURSOR
	TDNE C,TTYCOM(I) ;CTL CHAR => PADDING NOT NEEDED.
	 JRST (E)
	LDB A,[$TPPCR,,TTYOPT(I)]
	JUMPE A,(E)	;RETURN IF THIS TTY NOT PADDED.
	IORM C,TTYCOM(I) ;AFTER WE PAD, PADDING WON'T BE NECESSARY.
	MOVEI A,177
	MOVEI B,4	;4 RUBOUTS AT 2400 BAUD,
	CAIGE J,6
	 MOVEI B,3	;3 AT 1200.
	MOVSI C,(JFCL)
	JRST TYMDP5	;GO OUTPUT THEM.

TYMOVP:	CAIE A,177
	 POPJ P,
	JRST TYMPAD

;HANDLE CURSOR MOTION ON ARDS.
TYMARD:	TDZA E,E
TYMARH:	 MOVEI E,1
	SETZ A,
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB C,Q	;DESIRED VPOS.
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB B,Q	;DESIRED HPOS.
	MOVEI A,34	;OUTPUT A 34 AFTER THAT MESS
	DPB A,Q
	MOVEM B,TTYIHP(I)
	IMUL B,ARDSHL(E)	;MULTIPLY BY # OF VERTICAL POSITION
	IDIV B,TCMXH(I)	;DIVIDE BY # OF LINES  TO GET POS CURS POSITION
	SUB B,ARDSH2(E)
	MOVE Q,TOOP(I)
	PUSHJ P,TYMAR1
	MOVN B,C
	MOVNM B,TTYIVP(I)
	IMUL B,ARDSVL(E)
	IDIV B,TCMXV(I)
	ADD B,ARDSV2(E)
	PUSHJ P,TYMAR1
	MOVEI A,35	;OUTPUT A 35  BEFORE IT.
	JRST TYPOU2

TYMAR1:	LDB A,[430100,,B]
	MOVMS B
	LDB TT,[000500,,B]
	DPB TT,[010500,,A]
	LDB TT,[050500,,B]
	DPB TT,[100500,,A]
	ADDI A,100_7+100
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	IDPB A,Q
	LSH A,-7
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	IDPB A,Q
	POPJ P,

;ARDS COORDINATE STUFF

ARDSVL:	1404.
	1080.

ARDSV2:	702.
	540.

ARDSHL:	1080.
	1404.

ARDSH2:	540.
	702.

TYMIML:	MOVEM Q,TOOP(I)	;FLUSH 1ST 3 CHARS OF %TDMOV CMD,
	MOVEI B,3	;WILL REPLACE LAST 2 WITH POSITIONING CHARS.
	ADDM B,TORM(I)
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB B,Q
	MOVEM B,TTYIVP(I)
	MOVE C,Q
	CAMN Q,TOBEP(I)
	 SUBI Q,TOBL
	ILDB B,Q
	MOVEM B,TTYIHP(I)
	ADDI B,1
	DPB B,C
	MOVE B,TTYIVP(I)
	ADDI B,1
	DPB B,Q
	MOVEI A,16
	JRST TYPOU2


;HANDLE CLEAR-EOL:
TYEEOL:	MOVE A,CCEOLP(W)
	MOVEM A,TTYBYP(I)
	JRST TYEEO1

;HANDLE CLEAR-EOF
TYEEOF:	MOVE A,CCEOFP(W)
TYEEO2:	MOVEM A,TTYBYP(I)
TYEEO1:	AOS TORM(I)	;FLUSH THE CURSOR CTL CMD FROM OUTPUT BFR.
	MOVEM Q,TOOP(I)
	JRST TYPLUP

;HANDLE DELETE FWD. (DELETE FWD ON DATAPOINTS DOESN'T COME HERE)
TYEDLF:	SKIPE A,CCDLFP(W)
	 JRST TYEEO2	;CAN'T DELETE FWD ON THIS TTY.
	JRST TYEEO1

;HANDLE TURN-ON-MOTOR (ASSUME TTY IS 1200 BAUD TERMINET.)
TYEMTN:	MOVE A,[440700,,TYEMT1]
	JRST TYEEO2

TYEMT1:	ASCII/H	;ALTMODE H RUB RUB RUB
REPEAT 12,-2		;10. WDS OF RUBOUTS
	0

;HANDLE TURN-MOTOR-OFF COMMAND.
TYEMTF:	MOVE A,[440700,,[ASCIZ/J/]]
	JRST TYEEO2

;CRLF AND CLEAR EOL ON A DATAPOINT.
TYECRL:	LDB A,[$TPPCR,,TTYOPT(I)]
	HRREI B,-4(J)	;B HAS 1 FOR 1200 BAUD, 2 FOR 2400, ETC.
	CAIE A,		;NON-PADDED LINE OR
	CAIG B,		;SLOW LINE =>
	 SETZ B,	;NO PADDING NEEDED.
	MOVE A,CCCRLP(B)
	JRST TYEEO2

;DATAPOINT CURSOR CONTROL CHARACTERS
%DPFS==30	;FOWARD SPACE
		;31 => (NON-EXISTANT)
%DPUP==32	;32 => MOVE UP
		;33 => (NON-EXISTANT)
%DPHD==34	;34 => HOME DOWN (DOESN'T WORK ON OLD DATAPOINTS ABOVE 300 BAUD)
%DPHU==35	;35 => HOME UP
		;36 => CLEAR EOL
		;37 => CLEAR EOF
%DPBS==10	;BACKSPACE
%DPDN==12	;LINEFEED.

CCHDP:	440700,,CCHD
CCHD:	34_29.+177_22.+177_15.+177_8


CCEOLP:	0
	440700,,CCEOL
	440700,,CCEOL+1
	440700,,CCEOL+2
	0
	440700,,CCEOL+1
	0

CCEOL:	36_29.+177_22.+177_15.+177_8.
	36_29.
	^Q_29.


CCEOFP:	0
	440700,,CCEOF
	440700,,CCEOF1
	440700,,CCEOF2
	0
	440700,,CCEOF
	0

CCEOF:	37_29.
CCEOF1:	37_29.+27_22.+37_15.+37_8+37_1
	0
CCEOF2:	^P_29.

CCDLFP:	0
	0
	0
	440700,,[^X_29.]
	0
	0
	0

CCCRLP:	440700,,[.BYTE 7 ? ^M ? ^J ? 36]
	440700,,[.BYTE 7 ? ^M ? ^J ? 177 ? 177 ? 177 ? 36]
REPEAT 2,440700,,[.BYTE 7 ? ^M ? ^J ? 177 ? 177 ? 177 ? 177 ? 36]

27ATT==174
27EOA==64
27EOT==174
27LWR==37
27UPR==34
27IDLE==75

9BPTR:	331100,,
	221100,,
	111100,,
	001100,,

BCDTBL:	675675,,675675	;^@ ^A ^B ^C
	675675,,675675	;^D ^E ^F ^G
	735657,,656675	;^H ^I ^J ^K
	675755,,675675
	675675,,675675
	675675,,675675
	675675,,675303
	675675,,675675
	700565,,464264
	365550,,303530
	544524,,404503
	366201,,267342
	324240,,220360
	210350,,330270
	204344,,410560
	420440,,470542
	202443,,423563
	413553,,533473
	407547,,541521
	461511,,451431
	571505,,445522
	462512,,452432
	572506,,446566
	467566,,566401	;[	;\ ] ^ _
	402243,,223363
	213353,,333273
	207347,,341321
	261311,,251231
	371305,,245322
	262312,,252232
	372306,,246675
	566675,,675675

ASCTBL:	40,,40	;SPACE
	55,,137	;-,UNDERSCORE(_)
	100,,46	;@,CENT SIGN(&)
	33,,53	;&(ALT MODE),+
	70,,52	;8,*
	161,,121	;Q,Q (LOWER,,UPPER)
	171,,131	;Y,Y
	150,,110	;H,H
	64,,72	;4,:
	155,,115	;M,M
	165,,125	;U,U
	144,,104	;D,D
	177,,177	;PUNCH ON
	177,,177	;RESTORE
	177,,177	;BYPASS
	177,,177	;PUNCH OFF
	62,,74	;2,<
	153,,113	;K,K
	163,,123	;S,S
	142,,102	;B,B
	60,,51	;0,)
	177,,177
	177,,177
	177,,177
	66,,47	;6,'
	157,,117	;O,O
	167,,127	;W,W
	146,,106	;F,F
	177,,177	;UPPER CASE
	10,,10	;BACKSPACE
	177,,177	;EOB
	177,,177	;LOWER CASE
	61,,75	;1,=
	152,,112	;J,J
	57,,77	;/,?
	141,,101	;A,A
	71,,50	;9,(
	162,,122	;R,R
	172,,132	;Z,Z
	151,,111	;I,I
	65,,45	;5,%
	156,,116	;N,N
	166,,126	;V,V
	145,,105	;E,E
	177,,177	;READER STOP
	15,,15	;NEWLINE
	12,,12	;LINE FEED
	11,,11	;TAB
	63,,73	;3,;
	154,,114	;L,L
	164,,124	;T,T
	143,,103	;C,C
	43,,42	;#,"
	44,,41	;$,!
	54,,136	;COMMA,VERTICAL BAR
	56,,134	;.,NOT SIGN(\)
	67,,76	;7,>
	160,,120	;P,P
	170,,130	;X,X
	147,,107	;G,G
	177,,177	;EOT
	177,,177	;IDLE
	177,,177	;PREFIX
	177,,177	;DELETE
ASCORS:	40,,40		;SP SP
	41,,135		;! ]
	164,,124	;T(LOWER UPPER)
	152,,112	;J
	64,,44		;4 $
	157,,117	;O
	154,,114	;L
	57,,77		;/ ?
	
	65,,45		;5 %
	47,,42		;' "
	145,,105	;E
	160,,120	;P
	177,,177
	177,,177
	177,,177
	177,,177
	
	62,,100		;2 @
	56,,76		;. >
	156,,116	;N
	75,,53		;= +
	172,,132	;Z
	177,,177
	177,,177
	177,,177
	
	66,,133		;6 [
	151,,111	;I
	153,,113	;K
	161,,121	;Q
	177,,177
	10,,10		;BACKSPACE
	177,,177
	177,177
	
	61,,46		;1 & (TYPE +-)
	155,,115	;M
	170,,130	;X
	147,,107	;G
	60,,51		;0 )
	163,,123	;S
	150,,110	;H
	171,,131	;Y
	
	67,,33		;7 ESC (TYPE &)
	162,,122	;R
	144,,104	;D
	73,,72		;; :
	177,,177
	15,,15		;NEW LINE
	12,,12		;LF
	11,,11		;TAB
	
	63,,43		;3 #
	166,,126	;V
	165,,125	;U
	146,,106	;F
	71,,50		;9 (
	167,,127	;W
	142,,102	;B
	55,,137		;- _
	
	70,,52		;8 *
	141,,101	;A
	143,,103	;C
	54,,74		;, <
	177,,177
	177,,177
	177,,177
	177,,177
	
CORTBL:	675675,,675675		;^@-^C
	675675,,675675		;^D-^G
	735657,,675675		;^H-^K
	675755,,675675		;^L-^O
	
	675675,,675675		;^P-^S
	675675,,675675		;^T-^W
	675675,,675550		;^X ^Y ^Z ^[(ESC)
	675675,,675675		;^\ ^] ^^ ^_
	
	700201,,511560		;SP ! " #
	404410,,550311		;$ % & '
	464544,,470423		;( ) * +
	673267,,721207		;, - . /
	
	34240,,220360		;0 1 2 3
	204210,,330350		;4 5 6 7
	270264,,553353		;8 9 : ;
	675223,,675407		;< = > ?
	
	420571,,566572		;` - c
	452512,,563443		;d - g
	446431,,503432		;h - k  u
	506541,,522505		;l - 0   p
				;	  p
	413533,,451445		;p - s     e
	402462,,461565		;t - w      r
	542547,,524530		;x y z {
	440401,,440467		;| } ~ _
	
	440371,,366372		;' - c
	252312,,363243		;d - g
	246231,,303232		;h - k  l
	306341,,322305		;l - o   o
				;	  w
	213333,,251245		;p - s     e
	202262,,261365		;t - w      r
	342347,,324675		;x y z lcb
	675675,,675675		;vbar rcb tilde rbo

NOTYS==1	;NUMBER OF TTYS ON DEVICE TTY
;SET IN INITIAL PARAMS SECTION
;NNTYS==16.	;NUMBER OF TTYS ON DEVICE NTY
;NNVTTS==8	;# OF NOVA PSEUDO TTYS
;NDPTYS==16.	;# DATAPOINT PORTS
;NMTYS==0	;# MORTON TTYS
IFNDEF NSTTYS,NSTTYS==6	;# PSEUDO-TTYS.
NCT==NOTYS+NNTYS+NNVTTS+NDPTYS+NMTYS+NSTTYS+N11TYS	;TOTAL NUMBER OF TTYS
	;TOTAL NUMBER OF CONSOLES

NFDPT==NOTYS+NNTYS+NNVTTS	;# OF FIRST DATAPOINT LINE
NFSMTY==NFDPT+NDPTYS	;# OF FIRST MORTON TTY
NFMTY==NFSMTY		;SECOND NAME FOR FIRST MORTON TTY
NFSTTY==NFMTY+NMTYS	;# OF FIRST PSEUDO-TTY
NF11TY==NFSTTY+NSTTYS	;# OF FIRST PDP11-TV TTY.

TTYDO:	REPEAT NOTYS,DATAO TTY,A
	REPEAT NNTYS,DATAO NTY,A
	REPEAT NNVTTS,PUSHJ P,TTNDO

IFN NNVTTS,[
TTNDO:	ANDI A,177
	CAME I,NVOPTT
	JRST TTNDO1
	AOS NVTCC
	DATAO NTY,A
	POPJ P,

TTNDO1:	MOVEM I,NVOPTT	;MUST SELECT NEW CONSOLE
	SETOM NVTSIP	;SIGNAL
	MOVEM A,NVTSSC	;SAVE CHR
	PUSH P,I
	SUBI I,NOTYS+NNTYS-1
	TRO I,200
	DATAO NTY,I
	CLEARM NVTCC
	POP P,I
	POPJ P,
]

TTYDFF:	REPEAT NOTYS,CONO TTY,200+TTYCHN
	REPEAT NNTYS,CONO NTY,20+TTYCHN
	REPEAT NNVTTS,JRST 4,.
	REPEAT NDPTYS,CONO DPK,.RPCNT_12.+400+TTYCHN
	REPEAT NMTYS,CONO MTY,.RPCNT_12.+200+TTYCHN
	REPEAT NSTTYS,JRST 4,.

TTYST:	CONO TTY,10+TTYCHN
	REPEAT NNTYS,PUSHJ P,NTYST
	REPEAT NNVTTS,PUSHJ P,NVTYST
	REPEAT NDPTYS,CONO DPK,.RPCNT_12.+100+TTYCHN
	REPEAT NMTYS,CONO MTY,.RPCNT_12.+10+TTYCHN
	REPEAT NSTTYS,PUSHJ P,TTYPT
	REPEAT N11TYS,JFCL

27BRK:	REPEAT N2741,CONO NTY,100_.RPCNT+40+TTYCHN

TTYLT:	500000+TTYCHN
	REPEAT NNTYS,.RPCNT_12.+400000+TTYCHN
	REPEAT NNVTTS,0
	REPEAT NDPTYS,0
	REPEAT NMTYS,.RPCNT_12.+TTYCHN

IFN TK10P,[
NTYST:	CONO PI,TTYOFF
	CONO NTY,@TTYLT(I)
	CONO NTY,10+TTYCHN
	CONO PI,TTYON
	POPJ P,
]

IFN NNVTTS,[
NVTYST:	PUSH P,I
	SKIPL I,NOVATT
	PUSHJ P,NTYST
	POP P,I
	POPJ P,
]

TTYPT:	PUSH P,B
	PUSH P,C
	MOVE B,STYSTS-NFSTTY(I)	;USER
	MOVE C,STYMSK-NFSTTY(I)	;CHANNELS OPEN MASK
	AND C,MSKST2(B)
	JUMPE C,TTYPT1	;JUMP IF INTS NOT ENABLED
	MOVN B,C
	AND C,B
	MOVE B,STYSTS-NFSTTY(I)
	IORM C,IFPIR(B)
TTYPT1:	POP P,C
	POP P,B
	POPJ P,

EBLK

DEFINE TTYREP WRD
REPEAT NCT,CONC T,\.RPCNT,$!WRD
TERMIN

IFN NNVTTS,[
NOVATT:	-1	;TTY # NOVA CONNECTED TO -1 IF NONE
NVIPTT:	-1	;CURRENT NOVA PSEUDO TTY ON INPUT
NVOPTT:	0	;CURRENT NOVA PSEUDO TTY ON OUTPUT
NVTSIP:	0	;-1 IF NOVA TTY SELECT IN PROGRESS (OUTPUT)
NVTSSC:	0	;CHAR SAVED HERE DURING NVTSIP -1
NVTCC:	0	;# CHARS SENT TO CURRENT TTY SINCE RESCANING OTHER PSEUDO TTYS
NNVSEC:	0	;LAST CONSOLE TO CHECK IN TYP0 SEARCH
NNVSFL:	0	;-1 IF SERVING PREV SELECTED 
		;IE IF IT CRAPS OUT, SEARCH EVEN THO IT = NNVSEC
]

TIBL==41
TOBL==41
TIBS==TIBL*2
TOBS==TOBL*4

MICBAA==60.	;MAXIMUM NUMBER OF INPUT BUFFER CHARACTERS BEFORE AUTOMATIC ACTIVATION

TIB:	BLOCK TIBL*NCT		;TTY INPUT BUFFERS (18 BITS PER CHARACTER)
TOB:	BLOCK TOBL*<NCT-N11TYS>	;TTY OUTPUT BUFFERS (8 BITS PER CHARACTER)

;INPUT BUFFER BITS:
%TXMPE==400000	;MAIN PROGRAM ECHO CHARACTER
%TXPIE==200000	;PI ECHO CHARACTER
%TXCOM==100000	;COM MODE ECHO CHAR; DO PI ECHO EVEN IF HDX TTY.
%TXIGN==40000	;IGNORE THIS CHAR AT .IOT TIME.
%TXACT==20000	;THIS IS AN ACTIVATION CHAR.
%TXINT==10000	;THIS CHAR SHOULD INTERRUPT THE USER.

;OUTPUT BUFFER BITS:
%TXDIS==200	;THIS IS A DISPLAY COMMAND.

TIIP:	REPEAT NCT,  (002200)TIB-1+.RPCNT*TIBL	;INPUT BUFFER INPUT POINTER
TIOP:	REPEAT NCT,  (002200)TIB-1+.RPCNT*TIBL	;INPUT BUFFER OUTPUT POINTER
		     (002200)TIB-1		;SEE TTEBAK
TIBEP:	REPEAT NCT,  (002200)TIB-1+.RPCNT*TIBL+TIBL	;END OF INPUT BUFFER POINTER
TOIP:	REPEAT NCT-N11TYS,(041000)TOB-1+.RPCNT*TOBL	;OUTPUT BUFFER INPUT POINTER
	REPEAT N11TYS,0
TOOP:	REPEAT NCT-N11TYS,(041000)TOB-1+.RPCNT*TOBL	;OUTPUT BUFFER OUTPUT POINTER
	REPEAT N11TYS,0
TOBEP:	REPEAT NCT-N11TYS,(041000)TOB-1+.RPCNT*TOBL+TOBL	;END OF OUTPUT BUFFER POINTER
	REPEAT N11TYS,1
TINTP:	REPEAT NCT,  (002200)TIB-1+.RPCNT*TIBL	;INTERRUPT CHARACTER POINTER
ECHOC:	REPEAT NCT,0	;COUNT OF ECHO BUF CHARS THAT ARE REALLY ECHO CHARS
ECHOP:	REPEAT NCT,0	;POINTER TO INPUT CHARACTER TO BE ECHOED NEXT
TINTC:	REPEAT NCT,0	;COUNT OF CHARACTERS AVAILABLE FOR .ITYIC'ING.
TICC:	REPEAT NCT,0	;TYPE IN CHARACTER COUNT
TACC:	REPEAT NCT,0	;ACTIVATION CHARACTER COUNT
TORM:	REPEAT NCT,TOBS	;# CHARS ROOM LEFT IN OUTPUT BUFFER.

TTYERQ:	REPEAT NCT,-1	;LIST OF TTYS NEEDING ECHO LINKED THRU THESE WDS. (NIL = 200000,,)
			;-1 FOR TTY NOT NEEDING ECHO.
TYOSW:	REPEAT NCT,-1	;AOSE-STYLE SWITCH FOR MP USE OF TTY.
TTNTO:	REPEAT NCT,0	;# CHANNELS TTY IS OPEN ON (IN ALL JOBS.)

TYIMSK:	REPEAT NCT,0	;BIT SET FOR EACH CHANNEL THE TTY IS OPEN FOR
			;INPUT ON IN THE JOB THAT OWNS THE TTY NOW.
TYOMSK:	REPEAT NCT,0	;SIMILAR, BUT FOR OUTPUT CHANNELS.
TTYBYP:	BLOCK NCT	;NOT 0 => B.P. TO ASCIZ STRING TO OUTPUT AT INT. LVL.
TTLTM:	REPEAT NCT,-1000.	;TIME LAST CHRWAS REMOVED FROM OUTPUT BUFFER.
				;MAKE SURE THAT, WHEN TTYMTO IS CALLED
				;AT STARTUP, ALL TERMINENTS SEEM TO HAVE
				;BEEN IDLE FOR A LONG TIME
TTYOAC:	REPEAT NCT,-1	;-1 IF TTY OUTPUT INACTIVE 

TTYIPC:	REPEAT NCT,[
IFG APL,IFE APL-.RPCNT, TTYIS5	;JUST STORE AND EXIT FOR AP LINE.
	.ELSE TTYI	;TTY INPUT PC
]

;2741 VARS.
2741E:	0	;NUMBER OF 2741 ERRORS

;WARNING - I HAVE DETERMINED THAT THESE COMMENTS ARE WRONG,
;BUT I HAVEN'T FIGURED OUT WHAT THESE VARS REALLY MEAN.
	OFFSET -NF2741
27SE:	REPEAT N2741,0	;SEND EOA FLAG (-2 TO SEND, -1 SEND COMPLETE)
27LICR:	REPEAT N2741,0	;-1 IF LAST INPUT WAS CR.
27LIAT:	REPEAT N2741,-1	;-1 IF LAST INPUT WASN'T ATTENTION.
27PMS:	REPEAT N2741,-1	;-1 IF IN PROCEDE MODE.
27FLG:	REPEAT N2741,-1	;0 IF NOT FIRST TIME THROUGH TYP27
27SAVC:	REPEAT N2741,-1	;SAVE CHAR HERE DURING CASE CHANGE AND BREAK. -1 WHEN FREE
27STRT:	REPEAT N2741,0	;WHEN 27FCLK=-1 27STRT IS AOSED EVER 60TH OF A SECOND
			;WHEN IT BECOMES 0 OUTPUT DONE IS SET
27STOU:	REPEAT N2741,0	;-1 TO STOP OUTPUT AND PUT TTY IN PROC MODE
27TIME:	REPEAT N2741,-1	;>0 IF TIME OF LAST ZERO CHAR
27FTIM:	REPEAT N2741,0	;TIME OF FIRST ZERO CHAR
27IGE:	REPEAT N2741,0	;2741 IGNORE EOA FLAG (-1 TO IGNORE)
27CASE:	REPEAT N2741,200 ;400 FOR UPPER 200 FOR LOWER
27CTLF:	REPEAT N2741,0	;-1 IF LAST CHAR IS @
	OFFSET 0

TCMXV:	TTYREP VER	;MAX LINES VERT
TCMXH:	TTYREP HOR	;MAX CHR HORZ (ACTUAL -1)
TTYIHP:	REPEAT NCT,0	;INT LVL HPOS (ONLY IF %TPORS SET)
TTYIVP:	REPEAT NCT,0
TTYLPP:	REPEAT NCT,<TPLEN*2*.RPCNT>#-1
		;IDX OF PC PPR ASSOCIATED WITH TTY,
		;OR NEGATIVE => NONE NOW ASSOCIATED,
		;AND IS 1'S COMP. OF IDX OF PC PPR
		;FORMERLY ASSOCIATED.
TTYEPP:	REPEAT NCT,<TPLEN*2*.RPCNT>	;IDX OF PC PPR TO USE FOR ECHO.
TTYLPS:	REPEAT NCT,5,,5	;IF TTYLPP <0, THIS IS MAIN PRGM VPOS,,HPOS.

TPLEN==6	;LENGTH OF PC PPR VARIABLE BLOCK.
TPHB:	;USE 0		;HPOS OF LEFT MARGIN.
TPVB:	BLOCK 1		;VPOS OF TOP MARGIN (1ST LINE OF PC PPR)
TPHE:	;USE TCMXH	;HPOS OF 1ST COLUMN AFTER RIGHT MARGIN
TPVE:	;USE TCMXV	;VPOS OF 1ST LINE BELOW BOTTOM MARGIN
TPHP:	BLOCK 1		;HORIZONTAL POSITION OF CURSOR
TPVP:	BLOCK 1		;VERTICAL POSITION OF CURSOR
TPVM:	BLOCK 1		;IN SCROLL MODE, COUNTS LINES BETWEEN **MORE**S.
TPSP:	BLOCK 1		;SAVED CURSOR POS (FOR ^PS AND ^PR)
TPFLAG:	BLOCK 1		;HOLDS RANDOM FLAGS.
%TFEOP==1	;1 => HAVE JUST ENTERED LAST LINE OF PC PPR.
		;NEXT ATTEMPT TO OUTPUT SHOULD DO **MORE** PROC.
%TFIGL==2	;1 => LAST CHAR WAS CR NOT IN IMAGE MODE.
		;IF NEXT CHAR IS LF, IGNORE IT.
	.=.-TPLEN
REPEAT 2*NCT,[		;NOW ASSEMBLE INITIAL CONTENTS OF PC PPR VARS.
	0
REPEAT 2,0+IFE .RPCNT&1,5	;TPHP & TPVP: NONZERO FOR MAIN PRGM.
	0 ? 0 ? 0
]
EXPUNG TPHB,TPHE,TPVE

IFN .-TPHB-NCT*TPLEN*2,.ERR

COMT1:	BLOCK NCT	;COM TEMPORARY STORAGE
COMT3:	BLOCK NCT
CHNBIT:	REPEAT 20,1_<.RPCNT>

;DATA POINT CONTROLLER LINE VARIABLES
;THIS ARRAY LOOKED AT BY HARDWARE

IFNDEF LDBFF,LDBFF==10.	;LENGTH OF OUTPUT BUFFER^2 (PER LINE)

IFN DPKPP,[
DPKBAS:	REPEAT NDPTYS,[
	-1	;CHR CNT
	(440701,,DPKFF)	;BYTE PNTR
]
DPKFF:	35_29.+37_22.	;FF AT LEAST ON DATAPOINTS

DBBFP:	REPEAT NDPTYS,	440700,,DBBF+.RPCNT*LDBFF	;PNTRS TO OUTPUT BUFFER
DPKC:	REPEAT NDPTYS,	DPKBAS+2*.RPCNT	;PNTR TO HARDWARE COUNT WORD
DPKP:	REPEAT NDPTYS,	DPKBAS+2*.RPCNT+1	;PNTR TO BUFFER PNTR WD
DBBF:	BLOCK LDBFF*NDPTYS	;OUTPUT BUFFER

DPSPT:	2	;2741
	6	;600
	1	;110
	2	;150
	3	;300
	24.	;1200
	48.	;2400
	48.	;4800

]
DBBCC:	0	;CHRS REMAINING IN CURRENT BLOCK
	;FOR DPK, SET ACC. TO OUTPUT SPEED, TO
	;REPRESENT APPROX. 100MS TYPEOUT TIME.
	;FOR MTY, SET TO 5.

DBBCC1:	0	;INITTED LIKE DBBCC, BUT NOT DECREMENTED.

DBBBP:	0	;BYTE PNTR TO DBBF BUFFER OR MTYOW.

;MORTON BOX LINE VARIABLES
IFN MTYP,[
MTYOW:	0	;UP TO 5 CHARS TO BE OUTPUT PUT IN THIS WD.
MTYNC==5	;NUMBER OF CHARS PACKED IN ABOVE WORD.
]

IFN N11TYS,[
;PDP11-TV COMMUNICATION VARIABLES:

TT11HD:	.+1	;ADDR (IN PDP10 ADDRESS SPACE) OF PDP11 CHANNEL
	0	;HEADER AREA. IF @TT11HD IS NONZERO, THERE
		;IS INPUT TO BE POCESSED.

TT11P:	0	;0 => PDP11-TTYS ARE NOT IN USE
		;1 => SYSTEM SHOULD INITIALIZE THEM.
		;-1 => INITIALIZED AND IN USE.

TT11OL:	0	;# PDP10 WORDS IN A PDP11-TV OUTPUT BUFFER.
]

LOCTTY:	0	;CONSLOE INPUT CHAR READ FROM
LOCTPC:	0	;TTYIPC USED IN LAST INPUT INT (DEBUGGING ONLY)
TTYA:	0
TTYACS:	BLOCK 17-B+1
TTYAPC:	0	;APR CONI AT TTYBRK.
TTYPDP:	-20,,TTYPDL-1
TTYPDL:	BLOCK 20

IFN TTLPTP,[
LPTTTY:	11	;TTY THAT WAS REALLY LPT
LPTTIME:	0	;LAST TIME SYSTEM GOT OUTPUT FROM LPT
]

TTYOSW:	-1	;TTY OPEN SWITCH.  LOCKED BY OPEN ROUTINES
	0

STYOSW:	-1	;PSEUDO TTY OPEN SWITCH
	0

TTERQS:	MOVE	;LIST (THREADED THRU TTYERQ) OF TTYS NEEDING ECHOING.
		;"MOVE" (= 200000,,) IS THE END OF THE LIST.
		;OTHERWISE, A POINTER IS THE NUMBER OF A TTY
		;WHOSE TTYERQ VAR. HOLDS THE NEXT POINTER.

TTEDMY:	0	.SEE TYOPV0	;DUMMY VARIABLE BLOCK
	0	.SEE TYOPV1	;PASSED BY ECHO ROUTINE
	TTEDMY	.SEE TYOPV2	;TO .IOT RTNS.
	0	.SEE TYOPV3,TTELUP

NTTELU:	0	.SEE TTELUP	;ECHOING STATISTICS.
NTTEWA:	0	.SEE TTEWAT
NTTEL1:	0	.SEE TTELP1

STYNTO:	BLOCK NSTTYS	;NUMBER TIMES PSEUDO TTY OPEN
STYMSK:	REPEAT NSTTYS,0	;BIT FOR EACH CHNL STY OPEN FOR INPUT ON
STYOMS:	REPEAT NCT,0	;OUTPUT
STYSTS:	REPEAT NSTTYS,0	;STY STATUS   0 => FREE SLOT
%SSHNG==400000		;4.9=1 => DON'T HANG ON INPUT IOTS
%SSUSE==200000		;4.8=1 => IN USE
%SSINT==100000		;4.7 = 1 => HAVE GIVEN INT ON STY OUTPUT CHNS ALREADY
%SSONT==040000		;4.6 = 1 => DITTO FOR STY INPUT (TTY OUTPUT)
			;RH = USER INDEX THAT HAS IT OPEN
STYICH:	0		;TEMP STORAGE FOR PSEUDO-TTY INPUT CHAR

TCTYP:	TTYREP TCT	;THIS WORD SAYS HOW TO PERFORM
	;CURSOR CTL FUNCTIONS ON TTY.
%TNPRT==0	;PRINTING TTY.
%TNDP==1	;TTY USES DATAPOINT CURSOR CTL CODES.
%TNODP==2	;OBSOLETE.
%TNIML==3	;TTY USES IMLAC CURSOR CODES.
%TNARD==4	;TTY USES ARDS CURSOR CTL CODES.
%TNTV==5	;TTY IS A KNIGHT TV DISPLAY.
%TNARH==6	;TTY IS A HORIZONTAL ARDS.
%TNSFW==7	;"SOFTWARE" TTY THAT WANTS I.T.S. CURSOR-MOTION CODES.
%TNMAX==8


;TTYOPT WORD DESCRIBES CHARACTERISTICS OF THE PARTICULAR
;TERMINAL ATTACHED TO EACH LINE.
TTYOPT:	TTYREP OPT

;LEFT HALF BITS ARE:
%TOALT==200000	;4.8 => STANDARDIZE ALTMODES.
%TOCLC==100000	;4.7 => CONVERT LOWER CASE TO UPPER.
%TOERS==40000	;4.6 => THIS TTY CAN SELECTIVELY ERASE.
%TOHDX==20000	;4.5 => THIS TTY IS HALF-DUPLEX.
$TOHDX==370100
%TOMVB==10000	;4.4 => THIS TTY CAN BACKSPACE.
%TOSAI==4000	;4.3 => THIS TTY HAS SAIL CHAR SET.
		;4.2 UNUSED
%TOOVR==1000	;4.1 => THIS TTY CAN OVERPRINT SUCCESSFULLY.
%TOMVU==400	;3.9 => THIS TTY CAN MOVE CURSOR UP.
%TOMOR==200	;3.8 => DO **MORE** PROCESSING ON THIS TTY
		;(ACTUALLY JUST USED TO INIT %TSMOR FOR NEW JOBS).
%TOROL==100	;3.7 SIMILARLY, INIT %TSROL FOR NEW JOBS.
%TOSII==40	;3.6 => PERMIT SUPERIMAGE INPUT ON THIS TTY.
		;RIGHT NOW THIS BIT HAS NO EFFECT.
		;SUPERIMAGE INPUT IS ALWAYS ALLOWED.
%TOLWR==20	;3.5 => THIS TTY HAS LOWER CASE KEYBOARD.

;RIGHT HALF:
%TPPLF==100000
$TPPLF==170300	;3-BIT FIELD SAYING HOW TO PAD LF.
	;0 - DON'T. 1 - MEMOWRECK, 2741. 2 - TERMINET.
%TPPCR==10000
$TPPCR==140300	;3-BIT FIELD SAYING HOW TO PAD CR.
	;7 - TERMINET. 6 - MEMOWRECK. 5 - 2741.
	;0 - DON'T. 1 - NORMAL. 2 - DOUBLE.
%TPPCT==7	;%TPPCR CODE FOR TERMINET.
%TPPTB==1000
$TPPTB==110300	;3 BIT FIELD SAYING HOW MUCH PADDING NEEDED AFTER TAB.
	;0 => TABS NOT ALLOWED; ELSE 1 +<# PADDING CHARS NEEDED>
%TP11T==20	;1.5 => PDP-11 TV TTY. REFLECTS %TY11T.
		;NOT SETTABLE BY USER.
%TPORS==10	;1.4 => OUTPUT RESET ON THIS TTY SHOULD REALLY DO SOMETHING.
%TPIBC==2	;1.2 => FUNNY 2741-LIKE TTY.
%TPIBM==1	;1.1 => 2741.

TTYST1:	REPEAT NCT,0	;FIRST SIX GROUPT (SIX BITS PER GROUP)
TTYST2:	REPEAT NCT,0	;SECOND SIX GROUPS (SIX BITS PER GROUP)
TTYSTS:	REPEAT NCT,%TSFRE,,-1	;MODE BITS FOR TTY

;GROUP NUMBER		   CHARACTERS
;[	0		^A-^F ^K-^L ^N-^R ^T-^Z ^] ^^ ^_ ^@ ^\
;	1		A-Z   LOWER CASE A-Z
;	2		0-9
;	3		!"#$(DOLLAR)%&',.:;?@\ (ACCENT GRAVE) (VERTICAL BAR) (TILDE)
;	4		*+-/=^_
;	5		<>[]() (LEFT BRACE)
;	6		^G ^S
;	7		LF ^I(TAB)
;	10		$(ALT MODE) (RIGHT BRACE)
;	11		CR
;	12		RUBOUT
;	13		SPACE ^H(BACKSPACE)

;TTYST1 HAS GROUPS 0 THROUGH 5 FROM LEFT TO RIGHT
;TTYST2 HAS 6 THROUGH 13
;EACH GROUP HAS SIX BITS AS FOLLOWS:
%TGINT==1	;N.1 => INTERRUPT ON THIS GROUP
%TGACT==2	;N.2 => ACTIVATE ON THIS GROUP (FOR SWAPPING)
%TGSPC==4	;N.3 => SPECIAL HACKS.  (THIS SET ON GROUP 1 => CONVERT LOWER CASE)
%TGIMG==10	;N.4 => IMAGE MODE OUTPUT (N.4=0  => ASCII MODE)
		;N.6-N.5 => ECHO MODE
		;	00 => NO ECHO
%TGPIE==20	;	01 => PI  ECHO (ECHO CHARACTER WHEN TYPED)
%TGMPE==40	;	10 => MAIN PROGRAM ECHO (ECHO WHEN MAIN PROGRAM RECEIVES CHARACTER)

;TTYSTS HAS RANDOM BITS ASSOCIATED WITH THE TELETYPE
%TSFRE==400000	;4.9 => TTY FREE
%TSCLE==200000	;4.8 => ECHO ^L AS UPARROW-L EVEN ON DISPLAYS
		;(OTHERWISE WOULD ECHO AS CLEAR SCREEN)
%TSHDX==100000	;4.7 REFLECTS %TOHDX BIT.
		;4.6 UNUSED
%TSALT==020000	;4.5 => DON'T STANDARDIZE ALTMODE.
%TSROL==010000	;4.4 => SCROLL MODE.
		;4.3 UNUSED
%TSACT==002000	;4.2 => GOBBLE NEXT CHAR REGARDLESS OF ACTIVATION STATUS
		;4.1 UNUSED
%TSINT==000400	;3.9 => INT ON NEXT CHAR REGARDLESS
%TSMOR==000200	;3.8 => INHIBIT **MORE**.
%TSATY==000100	;3.7 SET BY .ATTY, SAYS TTY WAS TAKEN AWAY & RETURNED.
		;3.6-3.4 UNUSED.
%TSLCZ==000004	;3.3 => LAST CHARACTER TYPED WAS ^Z (NOT PRECEEDED BY ^_)
%TSSII==000002	;3.2 => SUPER IMAGE INPUT MODE
%TSCNS==000001	;3.1 => CONSOLE
$TSCNS==220100
		;RH => USER INDEX
		;	-1 => NO USER

TTYSTA:	REPEAT NCT,0	;NOT SAVED AT ATTY
;4.9 = 0 => NEEDS TO HAVE CONSOLE FREE MSG EVENTUALLY TYPED
;	CLEARED BY OPEN OR USTART WHEN INITIALIZING CONSOLE PROCEDURE
;	SET BY SYS JOB AFTER TYPING CONSOLE FREE MSG

TTYCOM:	REPEAT NCT,0,,-1	;COMMUNICATE WORD
;4.9 => TTY IN COMMUNICATE MODE
LFT==200000	;4.8 => LOCAL FEED THROUGH (SET IF MY PRGM RECIEVING HIS CHRS)
RFT==100000	;4.7 => REMOTE FEED THROUGH (SET IF HIS PRGM RECIEVING MY CHRS)
ICO==40000	;4.6 => INPUT COMMUNICATE OVERRIDE (SET IF MY CONSOLE FEEDING MY PRGM EVEN THO IN COMM MODE)
OCO==20000	;4.5 => OUTPUT COMMUNICATE OVERRIDE (SET IF MY PRGM'S OUTPUT TO APPEAR ON MY CONSOLE ONLY EVEN THO IN COM MODE)
;4.4-4.3 => MESSAGE RECEIPT SWITCH
		;00 => ACCEPT
%TCRFS==10000	;10 => REFUSE
%TCQRY==4000	;01 => INTERROGATE
%TCMTR==2000	;4.2  SET FOR TTY WHOSE MOTOR IS OFF & MUST BE TURNED
;ON BEFORE ANY OTHER OUTPUT IS DONE.
;(ONLY TERMINETS HAVE THEIR MOTORS SHUT OFF BY ITS).
IFN TCFFLP,%TCFFL==1000 ;4.1 => SOME CHARS ECHOED IN COM MODE ARE STILL IN THE INPUT
;BUFFER, EVEN THOUGH COM MODE HAS BEEN LEFT.
%TCINP==400	;3.9 SOMEONE WAITED FOR INPUT SINCE THE LAST TIME A HOME-UP WAS DONE.
%TCDET==200	;3.8 CONSOLE'S TREE DETACHED BY TOP LEVEL INTERRUPT.
	;SET BY NDETAC AS SIGNAL TO SYSCFM (CNSL-FREE-MSG TYPER)
%TCDNG==100	;3.7 => TYPE BELL ON TTY (BECAUSE INPUT BFR FULL).
%TCCBK==40	;3.6 => READING UNAME OR TTY # AFTER ^_K.
%TCCBS==20	;3.5 => READING UNAME OR TTY # AFTER ^_S.
%TCTMP==10	;3.4 TEMPORARILY MUST BE IN COM MODE.
%TCTPN==4	;3.3 TYPE ^_N ON LEAVING COM MODE (UNLESS USER EXPLICITLY TYPES ^_N)
%TCPAD==2	;3.2  0 => PADDING NECESSARY ON DATAPOINT.
;RH => USER INDEX COMMUNICATING WITH (-1 NONE)

BBLK

;TTYTYP TABLE
;THIS TABLE HOLDS BITS THAT DESCRIBE THE LINE
;AND ITS CONTROLLER, RATHER THAN THE TTY ATTACHED TO THE LINE.
;THERE SHOULD BE NO NEED FOR THIS TABLE TO BE CHANGED
;WHILE THE SYSTEM IS RUNNING.

%TTLCL==400000	;BIT 4.9 ONE => LOCAL TTY
%TT340==200000	;BIT 4.8 ONE => CONSOLE NEXT TO 340 OR A 340 SLAVE
%TT3HP==100000	;BIT 4.7 HIGH PRIORITY ON 340
%TTDDI==002000	;BIT 4.2 DONT DING ON EXCESS INPUT
%TTIBM==001000	;BIT 4.1 DATEL LINE
$TTISP==250300	;3.6-3.4 INPUT SPEED CODE
$TTOSP==220300	;3.3-3.1 OUTPUT SPEED CODE
%TYDPK==400000	;BIT 2.9 DATAPOINT KLUDGE TERMINAL
%TYSTY==200000	;BIT 2.8 PSEUDO TTY
%TYNVA==100000	;BIT 2.7 NOVA TTY
%TYMTY==040000	;BIT 2.6 MORTON BOX
%TYDIL==020000	;BIT 2.5 DIAL UP
%TY11T==010000	;BIT 2.4 PDP-11 TV TTY.

;SPEED CODES ARE 2741:0, 600:1, 110:2, 150:3, 300:4, 1200:5, 2400:6, 4800:7

TTYTYP:	TTYREP TYP
	0	;DISOWNED JOBS CANT HAVE LPT
	SETZ	;SYSTEM JOB CAN GET LPT