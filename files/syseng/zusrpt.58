
TITLE ZUSRPT
;COMPLETE REWRITE OF EARLIER PROGRAM OF SAME NAME
;NUMBERING OF THIS VERSION STARTS AT 50
SWRQ==1
IF1,.INSRT JSF;DSK:STNDRD MACROS

	;AC DEFINITIONS

FF=0	;FLAGS
A=1	;A,B,C,D MAY BE ASSUMED CONSECUTIVE
B=2	;A,B TEMP, MAY BE CLOBBERED WITHOUT COMMENT BY MOST ROUTINES
C=3
D=4
E=5
SYM=6	;FREQUENTLY FOR CURRENT UNAME
SYMJ=7	;JNAME
T=10	;T,TT TEMP,CONSECUTIVE, MAY BE CLOBBERED WITHOUT COMMENT BY MOST ROUTINES
TT=11
R=15	;FREQUENTLY INNER JSP AC
Q=16	;FREQUENTLY OUTER JSP AC
P=17	;PDL POINTER (JSP ISN'T ENOUGH)

	;IO CHANNELS

TYIC==1		;TYPEIN
TYOC==2		;TYPEOUT
UTYIC==3	;BINARY FILE IN
UTYOC==4	;BINARY FILE OUT
FDRC==5		;FILE DIRECTORY AND ERR DEVICE IN
PRTOC==6	;ASCII (PRINTING) FILE OUT

	;FF FLAGS

CRF==RHF FF,1_17.	;CHAR READ BY RCHA WAS CR, TERMINATES COMMAND LINE
ALTF==RHF FF,1_16.	;CHAR READ BY RCHA WAS ALTMODE, TERMINATES ARG STRING OR COMMAND
UNRCHA==RHF FF,1_15.	;RCHA TO RE-INPUT LAST CHAR

TMPF1==RHF FF,40000	;TEMPORARY
TMPF2==RHF FF,20000	; "
TMPF3==RHF FF,10000	; "

OPNFIF==RHF FF,4000	;A FILE IS OPEN ON UTYIC
OPNFPF==RHF FF,2000	;OUTPUT FILE IS OPEN ON PRTOC
OPNFOF==RHF FF,1000	;FILE IS OPEN ON UTYOC

GETTY==RHF FF,400	;TTY IS DISPLAY CONSOLE
UNBGBF==RHF FF,200	;(ONLY IF NOAXSW .NE. 0), SEE BGBLK

TMPLOC 41,JSR UUOH	;UUO HANDLER

IFNDEF LPDL,LPDL==100.	;BIG PDL FOR RIGHT-JUSTIFYING PRINT ROUTINES
IFNDEF NWB1,NWB1==15.	;MAXIMUM NUMBER OF WORDS IN BLOCK ONE OF INPUT FILES

IFNDEF NOAXSW,NOAXSW==0	;NON-ZERO TO NOT USE .ACCESS

IFNDEF ICOR,ICOR==3	;NUMBER OF BLOCKS INITIAL CORE

		;TTY ROUTINES

		;GET CHARACTER FROM COMMAND STRING, SET UP ALTF, CRF; USE UNRCHA

RCHA:	TMODF ZE,UNRCHA	;CLEAR AND CHECK RE-INPUT FLAG
	SKIPA A,LIMBOA	;RETRIEVE LAST
	PUSHJ P,RTYI	;GET NEXT
	MOVEM A,LIMBOA'	;STORE AS LAST INPUT
	CLEARF ALTF\CRF	;CLEAR TERMINATOR FLAGS
	CAIN A,^M
	SETF CRF\UNRCHA	;CARRIAGE RETURN, CAUSE INDEFINITE RE-INPUT UNLESS SPECIFICALLY FLUSHED
	CAIN A,33
	SETF ALTF	;ALTMODE
	POPJ P,

		;.INSRT SO CAN MORE EASILY KEEP UP WITH SYS TTY ROUTINES

.INSRT JSF;DSK:STNDRD TTY

SIXTYO:	JUMPE B,CPOPJ	;TYPE OUT SIXBIT WORD IN B
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,TYO
	JRST SIXTYO

		;ASSORTED TYPEOUT ROUTINES

TYOSP2:	PUSH P,CTYO	;TWO SPACES
SPACE:	MOVEI A,40	;SPACE
CTYO:	JRST TYO

TAB:	MOVEI A,^I
	JRST TYO

		;MORE TYPEOUT ROUTINES, PRIMARILY FOR UUO'S

		;ERR [ASCIZ /STRING/]	;LIKE TYPECR [ASCIZ /STRING/] BUT CALLS ERR1, RETURNS TO ERRET
		;TYPECR [ASCIZ /STRING/]	;TYPE OUT STRING, FOLLOWED BY CRLF

AERR:	MOVEI A,ERRET
	HRRM A,UUOH	;CAUSE RETURN TO ERRET
	PUSHJ P,ERR1
ATYPCR:	PUSHJ P,ATYPE	;TYPCR, TYPE STRING THEN CR
	JRST CRLF

		;PUSHJ P,ERR1	;UN-SILENCE TYPEOUT IN PREPARATION FOR TYPEOUT OF ERROR MESSAGE

ERR1:	POPJ P,		;WOW, SOME UNSILENCING ROUTINE

ACTYPE:	MOVE A,B	;CTYPE, TYPE OUT ASCII CHAR IN RH(UUO)
	JRST TYO

		;6TYPE ACI,[SIXBIT /WORD/]	;TYPE OUT WORD, WITH ACI INTERPRETED AS IN 6PRT

A6TYPE:	MOVE B,(B)	;GET ARG, ONE WORD
	PUSHJ P,SIXTYO	;TYPE OUT
	LDB A,[270400,,40]	;GET AC FIELD
	CAIL A,L6PRTB	;TOO BIG?
	.VALUE		;ACI FIELD OF 6TYPE UUO TOO BIG
	CAIN A,3	;WANT CRLF?
	JRST CRLF	;YES, GO DO IT
	XCT 6PRTB(A)	;NOW FIGURE OUT WHAT TO DO NEXT (MAYBE POPJ'S OUT)
	JRST TYO	;WANTS A CHARACTER TYPED OUT, DO IT

		;TYPE OUT DECIMAL NUMBER IN A

DPT:	IDIVI A,10.
	JUMPE A,DPT2
	HRLM B,(P)
	PUSHJ P,DPT
	HLRZ B,(P)
DPT2:	MOVEI A,"0(B)
	JRST TYO

		;DIRTYP OPNBLK	;OPEN OPNBLK (LH SHOULD HAVE DIRMOD) AND TYPE OUT
		;SKIPS IF .OPEN DOES

DIRMOD==0	;MODE THAT OPNBLK FOR DIRTYP SHOULD HAVE

ADIRTY:	.OPEN FDRC,(B)	;TRY OPENING FILE
	POPJ P,		;CAN'T
	MOVNI C,1	;DON'T MATCH ANYTHING (C GETS LAST CHAR TYPED OUT + 1)
ADIRT1:	.IOT FDRC,A	;GET CHAR FROM DIRECTORY OR WHATEVER
	JUMPL A,ADIRTX	;RETURN ON STANDARD EOF (AS OPPOSED TO DIRECTORY EOF)
	CAIE A,^L	;FORM FEED?
	CAIN A,^C	;CONTROL C?
	JRST ADIRTX	;YES, THAT'S ALL
	PUSHJ P,TYO	;MEETS TESTS, TYPE OUT
	MOVEI C,1(A)	;COPY CHAR + 1 INTO C
	CAIE A,^J	;EXTRA HAIR FOR LINE FEED, MAYBE STOP TYPING
	JRST ADIRT1	;BACK INTO LOOP
	.STATUS TYIC,A	;LINE FEED, CHECK TYPEIN
	TRNE A,2000	;WAITING FOR PUSHJ TO TYI?
	JRST ADIRT1	;NO (BUFFER EMPTY), COPY MORE
	.RESET TYOC,	;YES, STOP TYPEOUT
ADIRTX:	CAIE A,^J+1
	PUSHJ P,CRLF	;LAST NOT LINE FEED (OR DID .RESET), TYPE CRLF
	.CLOSE FDRC,	;EXIT, CLOSE CHANNEL
	JRST POPJ1

		;OPNER IOCH,OPNBLK	;.OPEN DIDN'T SKIP, TYPE OUT WHY AND GO TO ERRET

AOPNER:	LDB T,[270400,,40]	;PICK UP AC FIELD
	DPB T,[270400,,.+1]	;DEPOSIT FOR .STATUS, MAY BE FDRC WHICH WOULD GET CLOBBERED BY .OPEN
	.STATUS ERRFN2	;AC FIELD SET AT .-2, GET CHANNEL STATUS
	PUSHJ P,ERR1	;MAKE SURE IT GETS TYPED OUT
	PUSH P,UUOH	;SAVE PC FOR POSSIBLE DEBUGGING
	PUSHJ P,TYPFIL	;TYPE OUT FILE DESCRIPTION (USES UUO'S)
	PUSHJ P,TYOSP2	;SEPARATE WITH TWO SPACES
	DIRTYP ERRO	;TYPE OUT PROBLEM
	 .VALUE		;SHOULD HAVE SKIPPED
	JRST ERRET	;THAT'S ALL

ERRO:	DIRMOD,,(SIXBIT /ERR/)	;OPEN BLOCK FOR OPNER
	3		;=> USE ERRFN2 AS .STATUS WORD
ERRFN2:	0		;.STATUS WORD

		;UUO HANDLER

DEFINE UUOIRP A
IRPS UUO,,[OPNER
6PRT PRT DIRTYP 6TYPE
CTYPE TYPCR TYPE ERR]
A
TERMIN
TERMIN

UUOIRP NUUOS==.IRPCNT+1	;COUNT UUOS

UUOHI==40		;ONE MORE THAN HIGHEST UUO OP CODE USED
UUOMIN==UUOHI-NUUOS	;LOWEST UUO OP CODE USED
UUOIRP UUO=<UUOMIN+.IRPCNT>_33	;DEFINE UUOS

IFN 0,AERR	;ERR [ASCIZ /STRING/]	;TYPE OUT STRING, CRLF, THEN GO TO ERRET
;ATYPE IN TTY FILE	;TYPE [ASCIZ /STRING/]	;TYPE OUT STRING
IFN 0,ATYPCR	;TYPCR [ASCIZ /STRING/]	;TYPE OUT STRING FOLLOWED BY CR
IFN 0,ACTYPE	;CTYPE "CH		;TYPE OUT CHARACTER CH
IFN 0,A6TYPE	;6TYPE ACI,[SIXBIT /WORD/]	;TYPE WORD W/ HAIR LIKE 6PRT (SEE A6PRT)
IFN 0,ADIRTY	;DIRTYP OPNBLK		;OPEN OPNBLK AND TYPE OUT
IFN 0,APRT	;PRT [ASCIZ /STRING/]	;LIKE TYPE BUT GOES TO PRINTING DEVICE
IFN 0,A6PRT	;6PRT ACI,[SIXBIT /WORD/]	;PRINT WORD W/ HAIR AS SPECIFIED BY ACI FIELD
IFN 0,OPNER	;OPNER IOCH,OPNBLK	;TYPE OUT REASON .OPEN ON OPNBLK DIDN'T WORK

UUOH:	0
	INSIRP PUSH P,[A B C]	;UUOS DON'T CLOBBER ANY AC'S, HELP THE UUO DEPENDENT ROUTINES BY SAVING SOME
	LDB A,[331100,,40]	;PICK UP OP CODE
	CAIL A,UUOMIN
	CAILE A,UUOHI
ILUUO:	.VALUE		;ILLEGAL UUO EXECUTED
	HRRZ B,40	;GET EFFECTIVE ADDRESS FOR ROUTINE
	PUSHJ P,@UUODTB-UUOMIN(A)	;DISPATCH ON OP CODE
	JRST .+2
	AOS UUOH	;ROUTINE SKIPPED, INCREMENT RETURN POINT TO MAKE UUO SKIP
	INSIRP POP P,[C B A]	;RESTORE ACS SAVED
	JRST 2,@UUOH

UUODTB:	UUOIRP A!UUO	;UUO DISPATCH TABLE

		;PRINTING ROUTINES

		;OPEN ROUTINE ELSEWHERE (AT PRTOPN)

PRTCLS:	SKIPE LINEPS
	PUSHJ P,PCRLF
	SKIPE LINENR	;CLOSE THE PRINTING FILE: IF NOT AT BEGINNING OF PAGE,
	PUSHJ P,PRTFF	;THEN OUTPUT A FORM FEED
	MOVEI A,^C	;NOW GET EOFCH IN A
	MOVSI B,760000	;SET UP WORD FOR TDNE TO SEE IF WORD FULL
	PUSHJ P,PCH	;DEPOSIT AT LEAST ONE EOF CHARACTER
	TDNE B,PCHBP	;WORD FULL?
	JRST .-2	;NOT YET
	PUSHJ P,PPBUF	;OUTPUT THE BUFFER
	CLEARF OPNFPF	;CLEAR FLAG, INDICATE CHANNEL CLOSED
	.CLOSE PRTOC,
	MOVE A,PAGENR	;GET PAGE NUMBER
	CAIGE A,5
	JRST PRTCL2	;NOT ENOUGH TO WORRY ABOUT
	TYPE [ASCIZ /OUTPUT IS /]
	PUSHJ P,DPT
	TYPCR [ASCIZ / PAGES LONG./]
PRTCL2:	SETZM LINEPS	;CLEAR OUT LINE POSITION
	SETZM LINENR	;ALSO LINE NUMBER
	SETZM PAGENR	;ALSO PAGE NUMBER (# PAGES COMPLETELY OUTPUT SO FAR)
	POPJ P,

PRTFF:	MOVEI A,^L	;PRINT A FORM FEED
	JRST PCH

IFNDEF LPP,LPP==59.		;NUMBER OF LINES PRINTED PER PAGE
IFNDEF CPL,CPL==119.		;# CHARS PER LINE (LEAVE ONE BLANK FOR BADCOL)
IFNDEF PRTBFL,PRTBFL==40	;LENGTH OF PRINTER BUFFER
PRTBUF:	BLOCK PRTBFL		;BUFFER FOR PRINTING DEVICE

		;PRINT CHARACTER IN A

PCH:	CAIGE A,40
	JRST PCHNP	;NOT PRINTING CHARACTER
PCH2:	AOS LINEPS'	;INCREMENT LINE POSITION
PCH1:	IDPB A,PCHBP'	;STORE CHARACTER IN PRINT BUFFER
	SOSLE PRTCC'	;DECREMENT CHARACTER COUNT, SKIP IF EXHAUSTED
	POPJ P,
		;DROPS THROUGH
		;OUTPUT THE BUFFER

PPBUF:	PUSH P,A	;SAVE A
	MOVE A,PCHBP	;GET FINAL POINTER
	HRLOI A,-PRTBUF(A)
	EQVI A,PRTBUF	;CONVERT TO AOBJN POINTER TO BUFFER
	.IOT PRTOC,A	;OUTPUT THE BUFFER
PPBUF2:	MOVE A,[010700,,PRTBUF-1]
	MOVEM A,PCHBP	;INITIALIZE PCHBP
	MOVEI A,5*PRTBFL
	MOVEM A,PRTCC	;INITIALIZE CHARACTER COUNT
	POP P,A
	POPJ P,

		;ROUTINES FOR PROCESSING SPECIAL CHARACTERS AT PCH

PCHNP:	CAIL A,^H	;HERE FROM PCH IF CHAR IS NON-PRINTING (CONTROL CHAR)
	CAILE A,^M
	AOSA LINEPS	;NOT FORMAT EFFECTOR, INCREMENT OVER PRESUMED UPARROW TO BE PRINTED
	JRST @PCHTB-^H(A)	;FORMAT EFFECTOR, DISPATCH ON IT
	CAIE A,33	;NOT FORMAT EFFECTOR; ALTMODE?
	AOS LINEPS	;NOT ALTMODE, INCREMENT AGAIN, CHAR PRINTS AS TWO
	JRST PCH1	;BACK TO PRINT CHAR

PCHTB:	PCHBS	;^H BACKSPACE (JRST@'D FROM PCH)
	PCHTAB	;^I TAB
	PCHLF	;^J LINE FEED
	PCH2	;^K
	PCHFF	;^L FORM FEED
	PCHCR	;^M CARRIAGE RETURN

PCHBS:	SOSGE LINEPS	;BACKSPACE
	SETZM LINEPS	;BEGINNING OF LINE
	JRST PCH1

PCHTAB:	MOVEI A,7	;TAB
	IORM A,LINEPS	;SET TO END OF THIS TAB GROUP
	MOVEI A,^I
	JRST PCH2	;INCREMENT TO TAB STOP AND FALL IN

PCHLF:	PUSHJ P,PCH1	;LINE FEED, PRINT IT
	AOS A,LINENR'	;INCREMENT LINE NUMBER
	CAIL A,LPP
	PUSHJ P,PRTFF	;NEW PAGE, FORM FEED TO IT
	MOVEI A,^J	;CLOBBER A TO LINE FEED AGAIN SO AS TO APPEAR NONDESTRUCTIVE
	POPJ P,

PCHFF:	SETZM LINENR	;FORM FEED
	AOS PAGENR'	;INCREMENT COUNT OF # PAGES PRINTED
	JRST PCH1

PCHCR:	SETZM LINEPS	;CARRIAGE RETURN, CLEAR OUT LINE POSITION
	JRST PCH1

	;RANDOM PRINTING ROUTINES

PCOMMA:	MOVEI A,",	;PRINT A COMMA
	JRST PCH

SPACE6:	PUSH P,CPCH	;6 SPACES
SPACE5:	PUSH P,[SPACE2]	;5 SPACES, NORMAL SPACING TO NON-NULL PART OF LINE
SPACE3:	PUSH P,CPCH	;3 SPACES
SPACE2:	PUSH P,CPCH	;2 SPACES
PSPACE:	MOVEI A,40	;PRINT ONE SPACE
CPCH:	JRST PCH	;CPCH CONTAINA PCH IN RIGHT HALF

PTAB:	MOVEI A,^I	;TAB
	JRST PCH

P4CRLF:	PUSHJ P,.+1	;PRINT FOUR CARRIAGE RETURNS
P2CRLF:	PUSHJ P,.+1	;PRINT TWO CARRIAGE RETURNS
PCRLF:	MOVEI A,^M	;CRLF (BUT SEE ENDLIN, BEGLIN FOR NORMAL ROUTINES CALLED)
	PUSHJ P,PCH
	MOVEI A,^J
	JRST PCH

PDGPTA:	ADDI A,"0	;DIGIT IN A
	JRST PCH

PDGPTC:	MOVEI A,"0(C)	;DIGIT IN C
	JRST PCH

		;MAYBE PRINT FORM FEED

MPRTFF:	SKIPN A,LINENR	;GET CURRENT LINE #
	JRST PCRLF	;AT BEGINNING OF PAGE, JUST START WITH SINGLE CRLF
	CAIGE A,LPP*3/4	;3/4 OF THE WAY THROUGH THE PAGE?
	JRST P4CRLF	;NO, PRINT 4 CRLF'S AND KEEP GOING
	PUSHJ P,PRTFF	;ALMOST DONE WITH THIS PAGE, SKIP TO NEXT
	JRST PCRLF	;BEGIN WITH CRLF

		;PRINT SPACES AND TABS (AT LEAST ONE SPACE)
		;UNTIL LINE POSITION IS AT LEAST C(B)

ALIGN0:	CAMG B,LINEPS	;ENTRY FOR NO MINIMUM NUMBER OF SPACES
	POPJ P,
ALIGN:	MOVE A,LINEPS	;MAIN ENTRY
	TRZ A,7
	SUBM B,A
	IDIVI A,8	;# TABS IN A, # SPACES IN B
	JUMPLE A,ALIGN2	;JUMP IF ZERO OR FEWER TABS
	PUSH P,B	;SAVE NUMBER OF SPACES
	MOVE B,A	;NUMBER OF TABS, PUT WHERE WON'T GET CLOBBERED
	MOVEI A,^I	;TAB
	PUSHJ P,ALIGNX	;PRINT RIGHT NUMBER OF TABS
	POP P,B		;GET BACK NUMBER OF SPACES
ALIGN2:	MOVEI A,40	;NOW FOR SPACES
ALIGNX:	PUSHJ P,PCH	;LITTLE ROUTINE TO PRINT C(A) NUMBER OF TIMES SPECIFIED BY B
	SOJG B,.-1	;PRINTS AT LEAST ONE
	POPJ P,

		;PRINT SIXBIT WORD IN B

SIXPT:	JUMPE B,CPOPJ	;RETURN WHEN DONE (IF WORD IS NULL, DON'T TYPE ANYTHING)
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,PCH
	JRST SIXPT

		;PRINT ASCIZ STRING POINTED TO BY B

APRT:	HRLI B,440700
APRTL:	ILDB A,B
	JUMPE A,CPOPJ
	PUSHJ P,PCH
	JRST APRTL

A6PRT:	MOVE B,(B)	;UUO 6PRT ACI,[SIXBIT /WORD/] FIRST PRINTS WORD
	PUSHJ P,SIXPT
	LDB A,[270400,,40]	;THEN PICKS UP AC FIELD FOR DISPATCH
	CAIL A,L6PRTB
	.VALUE		;(ILLEGAL AC FIELD)
	XCT 6PRTB(A)	;FINALLY DOES SOMETHING ELSE AS SPECIFIED BY AC FIELD
	JRST PCH	;DROPPED THROUGH, PRINT CHAR IN A AND RETURN

6PRTB:	POPJ P,		;ACI 0 => THAT'S ALL
	MOVEI A,40	;1 END WITH SPACE
	MOVEI A,^I	;2 END WITH TAB
	JRST PCRLF	;3 END WITH CRLF
	MOVEI A,":	;4 COLON
	MOVEI A,";	;5 SEMICOLON
L6PRTB==.-6PRTB

		;SQUOZE OUTPUT ROUTINES
		;JSP R,SQPRTR	;CONVERT SQUOZE IN A TO ASCII, CALLING .+1 FOR EACH CHAR
		;POPJS OUT WHEN DONE

SQPRTR:	TLZA A,740000	;CLEAR FLAGS
SQPRR1:	IMULI A,50	;LOOP POINT, MAKE NEXT CHAR LOOK LIKE HIGHEST
	IDIV A,[50*50*50*50*50]	;GET HIGH CHAR IN A
	PUSHJ P,SQCPRT	;PROCESS CHAR
	SKIPE A,B	;GET REMAINDER
	JRST SQPRR1	;MORE CHARS
	POPJ P,		;NO MORE, EXIT

SQCPRT:	CAIGE A,11.	;PROCESS SQUOZE CHAR IN A
	SOJA A,SQCPRD	;DIGIT
	CAIL A,50-3
	SKIPA A,SQCTBL-<50-3>(A)	;SPECIAL, GET FROM TABLE
	MOVEI A,-11.+"A(A)	;LETTER
	JRST (R)	;DO SOMETHING WITH CHAR AND RETURN

SQCPRD:	ADDI A,"0	;DIGIT
	JRST (R)

SQCTBL:	".	;SPECIAL SQUOZE CHARS
	"$
	"%
	"^	;FIRST CHAR CAN BE 50 OR 51 IF SYM NOT REALLY SQUOZE
	"_

		;PRINT SQUOZE NAME IN A

SQPRT:	JSP R,SQPRTR
	JRST PCH

		;TPLOFF COMMAND, DO .SUPSET TO STOP TPLING

TPLOFF:	SKIPG TPLFN1	;CHECK TO SEE IF KNOW WHERE TPL FNAM1 IS IN SYSTEM
	JRST TPLOF3	;AW, SHUCKS
	.SUSET [.RUNAM,,SYM]	;GET UNAME, CLOBBER OWN PRINTING WITHOUT COMMENT
TPLOF1:	HRLZ A,TPLFN1'	;GET LOC IN SYSTEM OF TPL NAME 1 (UNAME)
	HRRI A,B
	.GETLOC A,	;WHO'S BEING TPL'D NOW?
	CAME B,SYM
	JRST TPLOF2	;SOMEBODY ELSE
TPLOF3:	MOVEI A,2	;REALLY WANTS THIS GUY CLOBBERED
	.SUPSET A,	;ZAP!
	POPJ P,

TPLOF4:	PUSHJ P,CRLF
	JRST TPLOF1

TPLOF2:	TYPE [ASCIZ /DO YOU REALLY WANT TO FLUSH /]	;UNAMES DIFFER, ASK USER
	MOVE SYM,B	;IF YES THEN TREAT TPLFN1 LIKE NEW UNAME
	PUSHJ P,SIXTYO	;TYPE OUT UNAME
	TYPE [ASCIZ /'S LISTING?   /]
	PUSHJ P,TYI	;GET ANSWER
	CAIN A,"Y
	JRST TPLOF4	;HE SAYS YES, LOOP WITH THIS UNAME
	TESTF N,ALTF\CRF	;NO, DON'T BOTHER COMMENTING IF AT END OF COMMAND
	TYPE [ASCIZ / TPLON./]
	JRST CRLF	;END WITH CR EITHER WAY

		;RIGHT JUSTIFYING PRINT ROUTINES

		;WORK BY BUILDING STRING UP ON PDL, PADDING WITH SPACES, THEN POPJ'ING
		;SINCE PDL IS BEING HACKED, PUSHJ IS OUT AS A SUBROUTINE CALL
		;INSTEAD, JSP IS USED W/ Q AND R AS JSP AC'S

		;JRST BKWOUT	;STANDARD ROUTINE TO PAD THEN POP

	PUSHJ P,PSPACE
BKWOUT:	SOJGE D,.-1	;CHARACTER COUNT REMAINING IS IN D
	POPJ P,		;BACK IT COMES!

		;ASSORTED "PUT CHARACTER ON PDL" ROUTINES, CALLED WITH JSP R,

BKWPDB:	SKIPA C,B	;PRINT DIGIT IN B
BKWIDV:	IDIVI B,10.	;PRINT LOWEST DECIMAL DIGIT IN B
BKWPDC:	ADDI C,"0	;PRINT DIGIT IN C
BKWPCC:	HRLM C,(P)	;PRINT CHARACTER IN C
BKWPSH:	PUSHJ P,[SOJA D,(R)]	;CHAR ALREADY ON PDL, JUST PUSH AND COUNT
	HLRZ A,(P)	;FINALLY POPJ'D, GET CHARACTER BACK
	JRST PCH	;PRINT IT AND RETURN TO ORIGINAL PUSHJ

BKWPSP:	MOVEI B,40	;PRINT A SPACE
BKWPCB:	HRLM B,(P)	;PRINT CHAR IN B
	JRST BKWPSH

		;MIDDLE ROUTINES, CALLED WITH JSP Q,

PDPTAQ:	IDIVI A,10.	;PRINT DECIMAL NUMBER IN A, DON'T CLOBBER C
	ADDI B,"0
	JSP R,BKWPCB
	JUMPN A,PDPTAQ
	JRST (Q)

PDPTBQ:	JSP R,BKWIDV	;PRINT DECIMAL NUMBER IN B
	JUMPN B,.-1
	JRST (Q)

HMSPR2:	IDIVI A,60.
HMSPR3:	JUMPE A,PDPTBN	;PRINT ONE OR TWO DIGIT NUMBER IF NOTHING LEFT
	JSP R,BKWIDV	;PRINT TWO DIGIT DECIMAL NUMBER IN B, PRECEDED BY COLON
	JSP R,BKWPDB
	MOVEI C,":
	JSP R,BKWPCC
	JRST (Q)

		;OUTER ROUTINES, CALLED WITH PUSHJ P,

PDPT:	MOVEI D,0	;ENTRY NOT TO PAD
PDPTN:	JSP Q,PDPTAQ	;PRINT DECIMAL NUMBER IN A DOESN'T CLOBBER C (ALL OTHERS CLOBBER A,B,C,D)
	JRST BKWOUT

PDPTB:	MOVEI D,0	;PRINT DECIMAL NUMBER IN B, DOESN'T CLOBBER A (ENTRY NOT TO PAD)
PDPTBN:	JSP Q,PDPTBQ
	JRST BKWOUT

P30:	IDIVI A,30.	;ENTRY FOR A HAS TIME IN THIRTIETHS
	MOVEI D,13.	;ENTRY TO RIGHT-JUSTIFY, FILLING AT LEAST 13. POSITIONS
HMSPRT:	JSP Q,HMSPR2	;ROUTINE TO PRINT H:MM:SS, SECS
	JSP Q,HMSPR2	;MINS
	IDIVI A,24.
	JSP Q,HMSPR3	;HOURS
	MOVEI C,"!	;RETURNED => MORE THAN A DAY
	HRLM C,-1(P)	;CLOBBER COLON ON PDL WITH EXCL
	JRST PDPTN	;PRINT DAYS AND RETURN

		;PRINT DECIMAL NUMBER IN A WITH COMMAS EVERY THREE DIGITS

PDPTC:	MOVEI D,0	;ENTRY TO NOT PAD
PDPTCN:	IDIVI A,1000.
	JUMPE A,PDPTBN
	JSP R,BKWIDV
	JSP R,BKWIDV
	JSP R,BKWPDB
	MOVEI C,",
	JSP R,BKWPCC
	JRST PDPTCN	;LOOP UNTIL DONE

		;PRINT NUMBER IN A FOLLOWED BY SLASH

PNRSL:	PUSHJ P,PDPT	;PRINT NUMBER
	MOVEI A,"/
	JRST PCH

;ROUTINE TO DO THE PAINFUL PART OF PRINTING N ENTRIES ON A PAGE, L ON EACH LINE EXCEPT
;POSSIBLY THE LAST, SUCH THAT THE CONCATENATION OF *COLUMNS* IS IN THE TABLE ORDER

		;ASSUME THE TABLE POINTER IS IN C
	;MOVEI A,N	;# ENTRIES TO PRINT THIS PAGE, MUST NOT BE ZERO
	;JSP Q,PGPRT	;DO THE MESSY CALCULATING, CLOBBERS B=A+1
	; L		;# ENTRIES PER LINE
	;MOVE D,A	;SAVE INCREMENT TO NEXT
	;MOVE B,(C)	;OR WHATEVER, GET TABLE ENTRY
	;PUSHJ P,DO SOMETHING	;PRINT ENTRY
	;IMULI D,# WORDS PER ENTRY	;CONVERT TO REAL INCREMENT
	;ADD C,D	;INCREMENT TO NEXT ENTRY
	;JUMPG D,TAB	;IF D .GT. 0 THERE ARE MORE ENTRIES THIS LINE
	;JRST CRLF	;IF .LT. 0 END OF LINE BUT MORE LINES
		;IF ZERO, THIS IS LAST ENTRY ON PAGE (BUT NOT NECESSARILY IN TABLE)

;DERIVATION: LET A AND B BE NON-NEGATIVE INTEGERS SUCH THAT N=A*L+B, B < L.
;THEN OUTPUT WILL CONSIST OF B COLUMNS OF A + 1 ENTRIES EACH PLUS L-B COLUMNS
;OF A ENTRIES EACH.  THE TABLE INCREMENT BETWEEN COLUMNS IN A LINE IS THEN
;EITHER A OR A+1 ENTRIES; THE DECREMENT FROM THE LAST (AS OPPOSED TO THE ONE
;AFTER IT) IN A LINE TO THE FIRST IN THE SAME LINE IS THEN
;B*(A+1)+(L-B-1)*A, OR B+A*L-A, OR N-A. (THE LAST EXPRESSION MAY ALSO BE DERIVED
;BY FAR MORE INTUITIVE REASONING.) THEN THE *INCREMENT* TO THE NEXT LINE
;IS CLEARLY A-N+1.

PGPRT:	MOVEM A,PGPRTC'	;STORE N AS INITIAL COUNTDOWN TO DONE
	IDIV A,(Q)	;GET A AND B IN A AND B (HOW ABOUT THAT)
	MOVEM A,PGPRTA'	;STORE A, NUMBER OF COMPLETE LINES (REMAINS CONSTANT)
	MOVEM B,PGPRTB'	;STORE B, NUMBER OF ENTRIES IN LAST LINE ( " )
	SUB A,PGPRTC	;SUBTRACT N
	MOVEM A,PGPRTI'	;STORE A-N AS INCREMENT TO FIRST ENTRY *THIS* LINE (CONSTANT)
	SETZM PGPRLP'	;CLEAR OUT INTRA-LINE ENTRY COUNT
PGPRT2:		;NOW IS THE LOGICAL TIME TO PRINT THE ENTRY, BUT CALLING
		;CONVENTIONS ARE SIMPLIFIED BY FIRST CALCULATING INCREMENT TO NEXT
	SOSG A,PGPRTC	;DECREMENT TOTAL COUNT REMAINING
	JRST 1(Q)	;JUST ONE MORE TO GO, PRINT IT, CRLF, AND RETURN (A HAS ZERO)
	AOS B,PGPRLP	;INCREMENT LINE POSITION
	CAML B,(Q)	;SKIP UNLESS NEXT TO BE ON NEW LINE
	SKIPA A,PGPRTI	;NEXT TO BE ON NEW LINE, GET INCREMENT TO BEG OF THIS ONE
	SKIPA A,PGPRTA	;SAME LINE, GET A
	SETZB B,PGPRLP	;NEW LINE, CLEAR OUT LINE POS, ALSO BE SO WILL AOJ
	CAMG B,PGPRTB
	AOJ A,		;LAST ROW HAS ENTRY IN THIS COLUMN (OR NEXT ENTRY ON NEW LINE)
	PUSHJ P,1(Q)	;BACK TO CALLING ROUTINE TO PRINT ENTRY AND INCREMENT
	JRST PGPRT2

SPD==24.*3600.	;# SECONDS PER DAY (FITS IN 17. BITS)
DOWBP==320300	;BP TO DAY OF WEEK FIELD IN SECOND WORD .RLPDT
DSTBIT==100000	;SET IN LH SECOND WORD .RLPDT => DAYLIGHT SAVINGS TIME
;SIGN BIT OF SECOND WORD .RLPDT (=.RYEAR) => AFTER FEB 28 OF 365 DAY YEAR

		;PRINT TIME AND DATE

NOWPRT:	.RLPDT A,	;GET TIME AND DATE
	JUMPL A,CPOPJ	;RETURN IF NOT KNOWN
	MOVE E,B	;GET YEAR AND FLAGS IN E
THENPT:	IDIVI A,SPD	;SAPARATE DATE FROM TIME
	PUSH P,A	;SAVE LOCALIZED DAY OF YEAR
	IDIVI B,SPD/2
	PUSH P,[SIXBIT / AM,   PM,/](B)
	MOVE A,C	;# SECS SINCE TWELVE
	CAIGE A,3600.
	ADDI A,SPD/2	;BEFORE ONE, MAKE PRINT TWELVE INSTEAD
	MOVEI D,0	;SIGNAL NOT TO PAD WITH SPACES ON THE LEFT
	PUSHJ P,HMSPRT	;H:MM:SS
	POP P,B		;AM OR PM (IN SIXBIT, WITH LEADING SPACE)
	PUSHJ P,SIXPT
	PUSHJ P,SPACE2	;TWO SPACES TO SEPARATE FROM DATE
	LDB A,[DOWBP,,E]	;GET DAY OF WEEK
	MOVE B,DOWTB(A)	;GET SIXBIT
	PUSHJ P,SIXPT	;PRINT DAY OF WEEK, LESS "DAY"
	MOVEI B,[ASCIZ /DAY, /]
	PUSHJ P,APRT
	POP P,C		;LOCALIZED DAY OF YEAR
	MOVEI B,0
	CAML C,MVALTB+1(B)
	AOJA B,.-1	;SEARCH FOR MONTH
	SUB C,MVALTB(B)	;GET # DAYS SINCE BEGINNING OF MONTH
	MOVE B,MNAMTB(B)	;NAME OF MONTH, IN SIXBIT
	PUSHJ P,SIXPT	;PRINT MONTH
	PUSHJ P,PSPACE
	MOVEI A,1(C)	;DAY OF MONTH
	PUSHJ P,PDPT	;(IN DECIMAL, OF COURSE)
	PUSHJ P,PCOMMA
	MOVEI A,(E)
	JRST PDPT	;PRINT YEAR AND RETURN

		;GET DAY AND MONTH IN C AND A, INITIALLY LOCALIZED DAY OF YEAR ASSUMED TO BE IN A

GDAM:	MOVEI C,1	;INITIALIZE TO JANUARY
	CAML A,MVALTB(C)
	AOJA C,.-1	;SEARCH FOR RIGHT MONTH
	SUB A,MVALTB-1(C)	;GET # DAYS IN MONTH BEFORE TODAY
	EXCH A,C	;GET DAYS IN C, MONTH IN A
	AOJA C,CPOPJ	;INCREMENT DAY (TO STANDARD FORMAT) AND RETURN

		;SIXBIT TABLE OF NAMES OF DAYS OF WEEK, LESS "DAY"

DOWTB:	IRPS D,,[SUN MON TUES
WEDNES THURS FRI SATUR]
	SIXBIT /D/
	TERMIN
IFN .-DOWTB-7,PRINTB DOWTB LOSES.

DEFINE MNIRP A	;DO SPECIFIED FOR EACH MONTH OF YEAR
IRPS M,,[JAN FEB MAR APR
MAY JUN JUL AUG
SEP OCT NOV DEC]L,,[31. 29. 31. 30.
31. 30. 31. 31.
30. 31. 30. 31.]
A
TERMIN
TERMIN

IF1,EXPUNGE APR	;ABOUT TO REDEFINE
FOO==-1
MNIRP [M=FOO
FOO==FOO+L]	;DEFINE MONTHS AS ONE LESS THAN # DAYS IN YEAR BEFORE FIRST OF MONTH


MNAMTB:	MNIRP [SIXBIT /M/]	;SIXBIT TABLE OF NAMES OF MONTHS

MVALTB:	MNIRP [<M 1>]	;TABLE OF NUMBER OF DAYS IN LEAP YEAR BEFORE BEG OF MONTH

		;TYPE OUT DATE (LOC DAY OF YEAR IN A, YEAR IN E) WITH SLASHES

TYPSLD:	PUSHJ P,GDAM	;FIGURE IT ALL OUT
	PUSHJ P,DPT	;MONTH
	CTYPE "/
	MOVE A,C
	PUSHJ P,DPT	;DAY
	CTYPE "/
	MOVEI A,(E)
	IDIVI A,100.
	MOVE A,B
	JRST DPT	;YEAR

;ROUTINES TO PRINT SYSTEM UPTIME IN PERCENTAGES OF DAYS PLUS NUMBER OF COMPLETE DAYS
;CALLED BY ACUSF WHEN PRINTING SUBFILES
;VARIABLES:

UPDATE:	0	;RH LOCALIZED DAY OF YEAR SYSTEM LAST CAME UP OR WENT DOWN
		;LH 4.9 => 365 DAY YEAR AFTER FEB 28, REST MUST BE 0
UPTIME:	0	;AMOUNT OF TIME SYSTEM UP ON UPDATE (IN SECONDS), OR -1 => UNKNOWN
UPDAYL:	0	;LENGTH OF UPDATE (IN SECONDS)
		; ^ FOR PERCENTAGE PRINTOUT OF UP TIME ON 23. AND 25. HOUR DAYS
UPDIF:	0	;NUMBER OF COMPLETE CALENDARR DAYS BETWEEN UPDATE AND PREV, OR -1

	;DIGEST THE DATE/TIME IN 2(C) AND 3(C)
	;GET DAY (IN UPDATE FORMAT) IN E
	;GET TIME OF DAY (NUMBER OF SECS TILL NEXT MIDNIGHT) IN B
	;LENGTH OF DAY (IN SECS) IN T

DIGDAT:	MOVE A,2(C)	;GET FIRST WORD
	MOVE E,3(C)	;SECOND WORD
	IDIVI A,SPD	;SEPARATE DAYS AND SECONDS
	HRR E,A		;STORE DAYS
	MOVEI T,SPD	;ASSUME 24. HOUR DAY
	LDB TT,[DOWBP,,E]	;GET DAY OF WEEK
	JUMPN TT,DIGDTX	;RETURN UNLESS SUNDAY
	CAIG A,JUL
	TDZA TT,TT	;CHECK APRIL
	MOVEI TT,1	;CHECK OCTOBER
	CAML A,GDTTB1(TT)
	JRST DIGDTX	;AFTER THE CRITICAL WEEK
	ADDI A,7
	CAMGE A,GDTTB1(TT)
	JRST DIGDTX
	ADD T,GDTTB2(TT)	;WITHIN CRITICAL WEEK => CRITICAL DAY (SINCE SUNDAY)
	XCT GDTTB3(TT)	;SKIP IF BEFORE SWITCHOVER
	ADD B,GDTTB2(TT)	;AFTER, COMPENSATE
DIGDTX:	SUBM T,B	;CALCULATE # SECS UNTIL MIDNIGHT
	TLZ E,#SIGN	;CLEAR OUT ALL FLAGS EXCEPT SIGN
	POPJ P,

GDTTB1:	MAY 1
	NOV 1

GDTTB2:	-3600.	;APRIL
	+3600.	;OCTOBER

GDTTB3:	TLNE E,DSTBIT	;APRIL
	TLNN E,DSTBIT	;OCTOBER

	;2(C) ADR OF .RLPDT PAIR
	;IF 2(C) DATE DIFFERENT FROM UPDATE, PRINT PERCENTAGE TIME USED ON UPDATE
	;CALCULATE AND STORE UPDIF AS ONE LESS THAN DIFFERENCE BETWEEN UPDATE AND 2(C)
	;REPLACE UPDATE WITH 2(C)'S, AND UPDAYL WITH LENGTH OF 2(C)'S DATE
	;LEAVE LENGTH OF NEW DAY IN T
	;LEAVE TIME BETWEEN NEW TIME AND END OF NEW DAY IN TT
	;SKIP-RETURN IF NEW DATE SAME AS OLD
	;CLOBBERS C

UPRT1:	PUSHJ P,DIGDAT	;DIGEST THE DATE
	MOVE TT,B	;SAVE TIME IN TT, ABOUT TO CLOBBER B
	MOVEI D,5	;NUMBER OF CHARACTERS TO PRINT OR PAD
	SETOM UPDIF	;INITIALIZE DATE DIFFERENCE
	SKIPGE UPTIME	;IN CASE THIS IS FIRST TIME THROUGH OR DATES NOT KNOWN
	AOSA UPTIME	;PRETEND UPDATE HAS TODAY'S DATE AND NO TIME SPENT YET
	CAMN E,UPDATE	;NEW DATE (KNOWN AS "TODAY") SAME AS OLD (UPDATE)?
	AOSA (P)	;YES, CAUSE RETURN TO SKIP
	JSP Q,UPRT2	;DIFFERENT, PRINT PERCENTAGE USED ON OLD; ALSO CALCULATE UPDIF
	MOVEM E,UPDATE	;STORE NEW DATE AS OLD
	MOVEM T,UPDAYL	;REPLACE LENGTH OF DAY WITH NEW ONE
	JRST BKWOUT	;PRINT OUT CRUFT ON PDL AND RETURN

UPRT2:	MOVEI A,(E)	;FIRST TO CALCULATE UPDIF
	SUBI A,@UPDATE	;SUBTRACT DATES
	JUMPL A,UPRT2C	;JUMP IF NEW DATE IS IN NEW YEAR
	SKIPL UPDATE	;SKIP IF OLD DATE AFTER FEB 28 OF 365 DAY YEAR
UPRT2B:	JUMPL E,[SOJA A,.+1]	;JUMP IF PASSED FEB 28 OF 365 DAY YEAR
	ADDM A,UPDIF	;UPDIF INITIALLY -1, STORE 1 LESS THAN DATE DIFFERENCE
	JSP R,BKWPSP	;NOW TO PRINT OLD PERCENTAGE TIME USED, END WITH SPACE
UPRT3:	MOVEI C,"%	;ENTRY FROM ACUSF6 TO PRINT PERCENTAGE TIME USED LAST DAY
	JSP R,BKWPCC	;PRECEDE SPACE WITH PERCENT SIGN
	MOVE A,UPDAYL	;GET LENGTH OF DAY
	IDIVI A,200.	;SAME AS MULTIPLYING NEXT RESULT BY 200.
	MOVE B,UPTIME	;GET TIME UP ON OLD DAY
	IDIV B,A	;CALCULATE TWICE THE PERCENTAGE TIME UP
	AOJ B,		;ROUND
	LSH B,-1	;HALVE, GET PERCENTAGE TIME UP
	JRST PDPTBQ	;BEGIN PRINTING WITH PERCENTAGE OF TIME USED

UPRT2C:	ADDI A,366.	;YEAR INCREMENT
	JRST UPRT2B

		;PRINT NUMBER OF COMPLETE DAYS SYSTEM WAS UP OR DOWN (UPDIF)
		;DOESN'T CLOBBER C

UPRTNR:	MOVEI D,4	;NUMBER OF CHARS TO PRINT/PAD
	JSP R,BKWPSP	;END WITH SPACE
	SKIPLE A,UPDIF	;DON'T PRINT IF ZERO OR NEGATIVE
	JSP Q,PDPTAQ	;PRINT IT
	JRST BKWOUT	;DUMP IT OUT FORWARDS

		;FILE DESCRIPTION READING/OPENING ROUTINES

		;READ DESCRIPTION FOR, AND OPEN, PRINTING FILE

PRTOPN:	PUSHJ P,PRDFIN	;BLT IN DEFAULT
	PUSHJ P,RFD	;GET FILE DESCRIPTION
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	.OPEN PRTOC,DNAM	;TRY OPENING FILE
	OPNER PRTOC,DNAM
	PUSHJ P,PRDFOT	;BLT DNAM BLOCK OUT AS NEW DEFAULT
	SETF OPNFPF	;INDICATE PRINTING CHANNEL OPEN
	PUSHJ P,PRTCL2	;CLOBBER PAGE/LINE POSITION VARIABLES
	PUSHJ P,PPBUF2	;INCREMENT P AND FALL INTO ROUTINE TO RE-INITIALIZE BUFFER VARIABLES

DFPFD:	3,,(SIXBIT /TPL/)	;DEFAULT NAMES (AND MODE) FOR PRTOPN
	SIXBIT /ZUSRPT/
	SIXBIT /WALLP/
DFPSNM:	0		;SET AT BEG TO INITIAL SYSTEM NAME

PRDFIN:	MOVE T,[DFPFD,,DNAM]	;BLT DFPFD INTO DNAM, ETC
	BLT T,SNAM
	POPJ P,

PRDFOT:	MOVS T,[DFPFD,,DNAM]	;BLT DNAM OUT INTO DFPFD
	BLT T,DFPSNM
	POPJ P,

		;OPEN DNAM ETC. FOR BINARY OUTPUT

OPNWR:	MOVEI T,7
	HRLM T,DNAM
	.SUSET [.SSNAM,,SNAM]
	.OPEN UTYOC,DNAM
	OPNER UTYOC,DNAM
	SETF OPNFOF
	POPJ P,

WRCLS:	.CLOSE UTYOC,	;CLOSE OUTPUT
	CLEARF OPNFOF
	POPJ P,

		;READ INPUT FILE DESCRIPTION STRING

RIFDS:	MOVEI A,IFILES	;SET UP POINTERS INTO DESCRIPTION AREA
	MOVEM A,IFILET
	MOVEM A,IFILEB
	PUSHJ P,ZFDFIN	;BLT IN DEFAULT
	MOVEI T,6
	HRLM T,DNAM	;SET MODE FOR .OPEN
RFDIP2:	PUSHJ P,RFDCCM	;GET NEXT DESCRIPTION
	PUSHJ P,DNININ
	ADDI B,4	;INCREMENT TO NEXT ENTRY
	MOVEM B,IFILET	;UPDATE POINTER
	TESTF N,CRF\ALTF	;END OF STRING?
	JRST RFDIP2	;BACK FOR MORE DESCRIPTIONS
	POPJ P,

		;OPEN NEXT INPUT FILE OR DON'T SKIP

OPNRD:	PUSHJ P,OPNAOS	;GET NEXT DESCRIPTION, SET SYSTEM NAME
	 JRST RDCLS	;DIDN'T SKIP => NO MORE
	.OPEN UTYIC,DFZFD
	OPNER UTYIC,DFZFD
IFN NOAXSW,PUSHJ P,AXSET
	SETF OPNFIF	;INDICATE INPUT FILE IS OPEN
	MOVE A,[UTYIC,,RCHSTB]
	.RCHST A,	;GET WHAT THE SYSTEM THINKS IS IMPORTANT ABOUT THIS FILE
	MOVSI A,770000
	TDNE A,RCHSTB
	MOVSS RCHSTB	;LH SIGNIFICANT, USE IT AS DEV NAME TO PRINT
POPJ1:	AOS (P)
	POPJ P,

		;GET NEXT STORED FILE DESCRIPTION INTO DFZFD AND SET SYSTEM NAME
		; ^ OR SDON'T SKIP IF NO MORE DESCRIPTIONS

OPNAOS:	MOVE B,IFILEB'	;GET POINTER TO LOWEST DESCRIPTION NOT PROCESSED
	CAML B,IFILET
	POPJ P,		;NO MORE DESCRIPTIONS
	PUSHJ P,DNINOT
	ADDI B,4
	MOVEM B,IFILEB
	.SUSET [.SSNAM,,DFZSNM]
	JRST POPJ1

RDCLS:	.CLOSE UTYIC,	;CLOSE THE READ CHANNEL
	CLEARF OPNFIF
	POPJ P,

IFNDEF NIFILS,NIFILS==20.	;MAX NUMBER OF FILES SEPARABLE BY COMMAS
IFILES:	BLOCK 4*NIFILS

DFZFD:	6,,(SIXBIT /DSK/)	;DEFAULT INPUT FILE DESCRIPTION, WITH MODE
	SIXBIT /ZUSERS/
	SIXBIT />/
DFZSNM:	SIXBIT /DRAGON/		;SYSTEM NAME

RCHSTB:	BLOCK 10.	;READ INTO BY .RCHST BY OPNRD

ZFDFIN:	MOVE T,[DFZFD,,DNAM]	;BLT DFZFD INTO DNAM, ETC.
	BLT T,SNAM
	POPJ P,

DNINOT:	MOVS A,IFILEB
	HRRI A,DFZFD
	BLT A,DFZSNM
	POPJ P,

DNININ:	MOVE B,IFILET'	;LEAVES IFILET IN B
	MOVSI A,DNAM
	HRR A,B
	BLT A,3(B)
	POPJ P,

		;FDELE COMMAND, DELETE SPECIFIED FILES

FDELE:	PUSHJ P,RIFDS	;READ DESCRIPTIONS
FDELE1:	PUSHJ P,OPNAOS	;GET NEXT DESCRIPTION
	POPJ P,		;DIDN'T SKIP => NO MORE
	MOVEI A,0
	EXCH A,DFZSNM	;FOR DELETE
	.FDELE DFZFD	;TRY DELETING IT
	SETOM DFZSNM	;LOST, SET FLAG
	EXCH A,DFZSNM	;RE-STORE SYSTEM NAME
	JUMPE A,FDELE1	;JUMP IF WON, BACK FOR NEXT
	OPNER DFZFD	;LOST, COMPLAIN ABOUT IT

	;MEMORY ALLOCATION ROUTINES

	;VARIABLES:
	;EACH ENTRY CORRESPONDS TO A TOP JUSTIFIED TABLE
	;CONTENT OF ENTRY:
	;FIRST WORD ADR LOWEST ALLOCATED FOR TABLE
	;OTHER WORDS ASSORTED POINTERS
	;THE FIRST OF THESE USUALLY HAS THE LOWEST ADR IN USE
	;FIRST WORD NEXT MAY BE CHECKED; HAS ADR FIRST ABOVE TABLE

	;IF TABLE EMPTY, ALL WORDS OF ENTRY HAVE SAME ADR
	;DON'T REFERENCE MEMORY ABOVE OR BELOW ALLOCATED CORE;
		;THERE MAY BE NO CORE THERE

HIMEM==SIGN	;FIRST LOCATION NOT ALLOCATED

LOWMEM::	;CONTAINS FIRST ADR THAT'S BEEN ALLOCATED

MEMBOT:	HIMEM	;RESOURCE (SYMBOL) TABLE GROUP
STP:	HIMEM	;POINTS TO BOTTOM OF SYMTAB
STE::		;POINTS TO TOP OF SYMTAB

DLPA:	HIMEM	;DIAL-IN CONSOLE TRACKING GROUP
DLP:	HIMEM	;POINTER TO BOTTOM OF TABLE
DLE::		;POINTER TO TOP OF TABLE

LFILEA:	HIMEM	;FILE/SUBFILE DESCRIPTOR GROUP
LFILEB:	HIMEM	;POINTER TO LOWEST IN USE
LSFILP:	HIMEM	;POINTS TO CURRENT SUB-FILE DESC
LFILEP:	HIMEM	;  "     "    "    FILE DESC
LFILEE::	;  "     " TOP OF TABLE

HIMEMP:	HIMEM	;(CONSTANT) POINTS TO TOP OF HIGHEST TABLE

		;ALLOCATE A NEW BLOCK OF CORE FOR TABLE
		;ADR OF TABLE POINTER GROUP IN C

DWNCOR:	PUSH P,T
	PUSH P,TT
	LDB T,[POINTR 10.,8,LOWMEM]	;GET BLOCK NUMBER LOWEST IN USE
	CAIG T,ICOR
	.VALUE		;DYNAMICALLY ALLOCATED CORE ABOUT TO COLLIDE WITH PROGRAM
	LDB TT,[POINTR 10.,8,(C)]
	SUB TT,T	;NUMBER OF BLOCKS TO MOVE DOWN FIRST
	IMULI T,1001
	ADD T,[400,,SIGN-1000]	;GET PAGE FROM NEXT ONE UP, REQUEST WRITE, ETC.
	JUMPLE TT,DWNCR2	;JUMP IF NO BLOCKS TO MOVE DOWN
	.CBLK T,	;COPY CORE DOWN
	.VALUE		;???
	ADDI T,1001	;INCREMENT TO NEXT PAGE
	SOJG TT,.-3	;LOOP FOR ALL PAGES TO MOVE DOWN
DWNCR2:	HRLI T,4400	;CHANGE REQUEST TO FRESH PAGE
	.CBLK T,	;GET FRESH PAGE
	.VALUE		;NO CORE
	MOVNI T,2000
	ADDM T,(C)	;UPDATE POINTERS
	CAILE C,LOWMEM
	SOJA C,.-2
	POP P,TT
	POP P,T
	POPJ P,

		;FLUSH ALL DYNAMICALLY ALLOCATED CORE

RSTST:	MOVEI T,HIMEM
	EXCH T,LOWMEM
	MOVE TT,[LOWMEM,,LOWMEM+1]
	BLT TT,HIMEMP	;RESET ALL POINTERS
	MOVEI TT,HIMEM
	SUB TT,T	;GET NUMBER OF ALLOCATED WORDS FLUSHED
	JUMPE TT,CPOPJ	;RETURN IF NONE
	LSH T,-1
	LSH TT,-10.
	.CBLK T,	;FLUSH PAGE
	.VALUE		;???
	ADDI T,1000	;INCREMENT TO NEXT PAGE
	SOJG TT,.-3
	POPJ P,

		;FILE DESCRIPTION READING ROUTINES, CLOBBER AC'S

RFD:	MOVEI R,RFDC1	;PUSHJ P,RFD	;READ SINGLE DESCRIPTION INTO DNAM, ETC.
RFDC:	CLEARF TMPF1	;CLEAR OUT "FILE NAME HAS BEEN SPECIFIED" FLAG
	JRST GTSYL	;FALL IN

RFDC1:	CAIN A,":
	JRST RFDCOL	;DEVICE
	CAIN A,";
	JRST RFDSEM	;SYSTEM NAME
	CAILE A,40
	JRST GTSYL2	;USE IT AS PART OF NAME
	CAIN A,^Q
	JRST RFDCQ	;PROBABLY QUOTE NEXT CHARACTER
	TESTF N,ALTF\CRF
	PUSH P,CGTSYL	;NOT TERMINATOR, CAUSE LOOP TO GETSYL
RFDTRM:	JUMPE C,CGTSYL	;JUMP IF NAME IS NULL
	EXCH C,FNAM2	;LOGICAL SPACE
	TMODF OE,TMPF1	;IS THIS FIRST NAME SPECIFIED?
	MOVEM C,FNAM1	;NO, CLOBBER FNAM1 TOO
CGTSYL:	POPJ P,GTSYL

RFDCOL:	TLNE C,-1
	HLRM C,DNAM
	JRST GTSYL

RFDSEM:	JUMPE C,GTSYL
	MOVEM C,SNAM
	JRST GTSYL

RFDCQ:	PUSHJ P,RCHA
	CAIN A,^M
	JRST RFDTRM	;DON'T LET CR BE QUOTED (DON'T CARE ABOUT ALTMODE)
	JRST GTSYL2

RFDCCM:	JSP R,RFDC	;VERSION OF RFD TO STOP ON COMMA TOO
	CAIN A,",
	JRST RFDTRM
	JRST RFDC1

DNAM:	0	;DEVICE NAME
FNAM1:	0	;FILE NAME 1
FNAM2:	0	;FILE NAME 2
SNAM:	0	;SYSTEM NAME

		;TYPE OUT FILE DESCRIPTION POINTED TO BY B

TYPFIL:	HRLZ T,(B)	;GET DEVICE NAME
	JSP A,GFLDEV	;DECIPHER DEVICE (MAYBE EVENTUALLY WANT A PRTFIL TOO)
	 6TYPE 4,(P)	;ARG TO GFLDEV, TYPE OUT DEVICE NAME
	6TYPE 5,3(B)	;(THIS MAY GET SKIPPED OVER) TYPE OUT SYSTEM NAME
	6TYPE 1,1(B)	;FNAM1
	6TYPE 2(B)	;FNAM2
	POPJ P,

PRTFIL:	HRLZ T,(B)	;LIKE TYPFIL BUT PRINT
	JSP A,GFLDEV
	 6PRT 4,(P)
	6PRT 5,3(B)
	6PRT 1,1(B)
	6PRT 2(B)
	POPJ P,

GFLDEV:	CAMN T,[SIXBIT /DSK/]
	JRST 1(A)	;DON'T TYPE OUT DSK
	PUSH P,T	;PUT DEVICE NAME ON PDL WHERE UUO'S CAN GET TO IT
	XCT (A)		;TYPE OUT DEVICE NAME
	POP P,T
	CAME T,[SIXBIT /LPT/]
	CAMN T,[SIXBIT /TPL/]
	JRST 2(A)	;DON'T TYPE OUT SYSTEM NAME OF PRINTER
	SKIPN 3(B)
	JRST 2(A)	;DON'T TYPE OUT NULL SYSTEM NAME
	JRST 1(A)	;TYPE OUT SYSTEM NAME

		;LISTF COMMAND

LISTF:	MOVE A,DFZFD	;GET DEFAULT ZUSERS DEVICE NAME
	HRLI A,DIRMOD	;SET TO DIRMOD
	MOVEM A,DNAM	;STORE AS DEFAULT DNAM
	MOVE A,DFZSNM	;GET ZUSERS SYSTEM NAME
	MOVEM A,SNAM	;STORE AS DEFAULT SYSTEM NAME
	PUSHJ P,RFD	;GET FILE DESCRIPTION
	MOVEI D,DNAM
	PUSH D,[SIXBIT /.FILE./]
	PUSH D,[SIXBIT /(DIR)/]
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	PUSHJ P,FORMF	;CLEAR SCREEN ON DISPLAY CONSOLE
	DIRTYP DNAM	;TYPE IT OUT
	OPNER FDRC,DNAM
	MOVE A,DNAM	;NOW STORE BACK NEW DEFAULT ZUSERS NAMES
	HRRM A,DFZFD
	MOVE A,SNAM
	MOVEM A,DFZSNM
	POPJ P,

		;"MAIN" ROUTINES

VERSION:	.FNAM2

BEG:	MOVEI FF,0	;INITIALIZE FLAGS
	MOVE P,[-LPDL,,PDL]
	.SUSET [.RSNAM,,DFPSNM]	;GET INITIAL SYSTEM NAME
	PUSHJ P,TYINIT
	PUSHJ P,FORMF
	TYPE [ASCIZ /ZUSRPT./]
	MOVE B,VERSION
	PUSHJ P,SIXTYO
	MOVE A,[SQUOZE 0,TPLFN2]	;SET UP FOR TPLOFF
	.EVAL A,
	MOVSI A,SIGN	;NOT DEFINED
	MOVEM A,TPLFN1	;STORE LOCATION OF TPL UNAME IN SYSTEM
	PUSHJ P,CRLF	;END TYPEOUT WITH CRLF NOW, MAYBE ASTERISK LATER
ERRET:	MOVE P,[-LPDL,,PDL]	;RETURN POINT FROM ERRORS, RE-INITIALIZE STUFF
	SETF ALTF\CRF
	SETZM RTYIP
	CLEARF UNRCHA
MNLUP:	TMODF ZE,OPNFIF	;FILES NOT SUPPOSED TO REMAIN OPEN BETWEEN COMMANDS
	.CLOSE UTYIC,
	TESTF E,OPNFPF	;PRINT FILE OPEN?
	PUSHJ P,PRTCLS	;YES, SHOULDN'T REMAIN OPEN BETWEEN COMMANDS
	TMODF ZE,OPNFOF
	.CLOSE UTYOC,
	PUSHJ P,GCMD	;PROCESS COMMAND
	JRST MNLUP	;BACK FOR NEXT

		;KILL COMMAND, WIPE OUT SELF

ALTX:	.LOGOUT		;JUST IN CASE
	.VALUE [ASCIZ /./]
	POPJ P,

		;COMMAND PROCESSOR

		;FOLLOWING MACROS ACCUMULATE STUFF TO DUMP INTO OTHER TABLES

DEFINE CMDNMM A
A
TERMIN

DEFINE CMDSPM A
A
TERMIN

		;CMD MACRO, SPECIFY COMMAND

DEFINE CMD NAME,DSP,BLURB
[ASCIZ /BLURB/]
IFG .LENGTH NAME-6,PRINTB [NAME] COMMAND TOO LONG.
CMDNMM [DEFINE CMDNMM %%A
%%A]SIXBIT /NAME/
TERMIN
CMDSPM [DEFINE CMDSPM %%A
%%A]DSP
TERMIN
TERMIN

		;PLEASE TRY TO KEEP THESE SORTED SO LISTC WILL PRINT
		;THEM OUT THAT WAY

		;BLURB TABLE, ALSO WHERE COMMANDS ARE SPECIFIED

BTB:	CMD ACCUSE,ACCUSE,OUTFIL  LIST RESOURCES ADDED UP.
	CMD COPY,COPY,[INFILS$OUTFIL,SUBFILS  COPY FILES EXTRACTING SUBFILS.]
	CMD DIALIN,DIALIN,OUTFIL  PRINT CONSOLE USAGE (SUBSET OF ACCUSE).
	CMD DOCUMT,DOCUMT,[(OBSOLESCENT COMMAND; USE "HELP" INSTEAD)]
	;CMD DUMP,DUMP,DUMP RESOURCE TOTALS ONTO BINARY FILE.
	CMD FD,LISTF,PRINT FILE DIRECTORY OF DEVICE.
	CMD FDELE,FDELE,FILES  DELETE SPECIFIED FILES.
	CMD HELP,DOCUMT,DOCUMENT SPECIFIED COMMANDS.
	CMD KILL,ALTX,VALRET AN $^X.
	CMD LISTC,LISTC,LIST COMMANDS.
	CMD LISTF,LISTF,PRINT FILE DIRECTORY OF DEVICE.
	CMD LISTSF,LISTSF,FILE(S)  LIST SUBFILES ON FILE(S).
	CMD LOAD,LOAD,READ FILES AND ADD UP RESOURCES USED.
	CMD MERGE,MERGE,LIKE LOAD BUT DON'T WIPE OUT TABLE FIRST.
	CMD TPLOFF,TPLOFF,TELL SYSTEM JOB TO QUIT TPLING (USE CAREFULLY!).
	CMD WALLP,WALLP,[INFILES$OUTFILE  READ AND PRINT FILES, DON'T LOAD.]
NCMDS==.-BTB	;# COMMANDS
	[ASCIZ /IS NOT A COMMAND./]	;FOR HELP ON BAD ARGUMENT

NMTB:	CMDNMM		;TABLE OF COMMAND NAMES (IN SIXBIT)
IFN .-NMTB-NCMDS,PRINTB NMTB LOSES.;	;PROBABLY A COMMAND MORE THAN SIX CHARACTERS LONG

DTB:	CMDSPM		;DISPATCH TABLE
IFN .-DTB-NCMDS,PRINTB DTB LOSES.;	;????

		;JSP R,GTSYL OR SOMETHING SIMILAR
		;ROUTINE IS FOR INSTRUCTIONS RATHER THAN FUNCTION, ALL TAGS ACCESSIBLE TO CALLING ROUTINE
		;BASIC FUNCTION IS TO LOAD C WITH SIXBIT, STOPPING WHENEVER CALLING ROUTINE WANTS TO

GTSYL:	MOVEI C,0	;CLEAR OUT SIXBIT
	MOVE B,[440600,,C]	;SET UP BYTE POINTER TO SIXBIT
GTSYL1:	PUSHJ P,RCHA	;GET CHAR
	CAIL A,140
	SUBI A,40	;CONVERT LOWER CASE TO UPPER
	JRST (R)	;BACK TO CALLING ROUTINE

GTSYL2:	SUBI A,40	;FREQUENTLY HERE FROM CALLING ROUTINE TO USE CHAR AS SIXBIT
	TLNE B,770000	;ROOM?
	IDPB A,B	;YES, DEPOSIT CHAR
	JRST GTSYL1

		;GET SIXBIT NAME OF "COMMAND" USING TERMINATOR CONVENTIONS OF GCMD
		;CALL WITH PUSHJ P,

GETNAM:	JSP R,GTSYL
	CAIL A,"A
	CAILE A,"Z
	JRST .+2
	JRST GTSYL2	;LETTER
	CAIL A,"0
	CAILE A,"9
CPOPJ:	POPJ P,		;NOT ALPHAMERIC
	JRST GTSYL2	;DIGIT

		;GET AND PROCESS COMMAND (CALLED WITH PUSHJ P, FROM MAIN LOOP)

GCMD:	TESTF E,CRF
	PUSHJ P,NUCMDL	;NEW COMMAND LINE
GCMD1:	CLEARF UNRCHA	;DON'T ALLOW RE-INPUT OF CR (SET AT RCHA)
	PUSHJ P,GETNAM	;GET NAME OF COMMAND
	JUMPE C,GCMD1	;KEEP TRYING UNTIL THERE'S SOMETHING THERE
	TESTF E,ALTF	;ALTMODE LAST CHAR?
	SETF UNRCHA	;YES, CAUSE ALTMODE TO BE RE-INPUT TO TERMINATE ARG OR SOMETHING
	MOVSI B,-NCMDS	;SET UP AOBJN POINTER TO COMMAND TABLES
	CAMN C,NMTB(B)
	JRST @DTB(B)	;THIS IS IT
	AOBJN B,.-2	;KEEP TRYING UNTIL TABLE EXHAUSTED
	MOVE B,C
	PUSHJ P,SIXTYO	;TYPE OUT GUILTY COMMAND
	ERR [ASCIZ / NOT A COMMAND./]

NUCMDL:	JRST KERCHK	;NEW COMMAND LINE, FOR NOW JUST GO KERCHINK

		;LISTC, LIST COMMANDS

LISTC:	MOVSI C,-NCMDS	;C AOBJN POINTER TO TABLES
LISTC1:	MOVEI D,6	;COUNT DOWN TO CRLF
LISTC2:	MOVE B,NMTB(C)	;GET NAME
	PUSHJ P,SIXTYO	;TYPE OUT
	SOJLE D,LISTC3	;JUMP IF THIS LAST IN LINE
	AOBJP C,CRLF	;END WITH CRLF IF DONE
	PUSHJ P,TAB	;NOT DONE YET, TYPE TAB
	JRST LISTC2	;BACK FOR NEXT COMMAND

LISTC3:	PUSHJ P,CRLF	;THIS LAST ONE IN LINE, END WITH CRLF
	AOBJN C,LISTC1	;LOOP FOR ALL LINES
	POPJ P,

		;HELP, DOCUMENT SPECIFIED COMMANDS

DOCUMT:	CLEARF TMPF1	;GETS SET ON DESCRIPTION NOT NULL
DOCU1:	PUSHJ P,GETNAM	;GET NAME
	JUMPE C,DOCU2	;JUMP ON NO SYL
	SETF TMPF1	;SET SYL FLAG
	MOVE B,C	;GET NAME IN B
	PUSHJ P,SIXTYO
	PUSHJ P,TAB
	MOVSI B,-NCMDS	;NOW SEARCH TABLE
	CAME C,NMTB(B)
	AOBJN B,.-1
	TYPCR @BTB(B)	;TYPE OUT BLURB
DOCU2:	TESTF N,ALTF\CRF
	JRST DOCU1	;LOOP UNTIL END OF COMMAND
	TESTF N,TMPF1
	TYPCR DOCLOS	;LOSER DIDN'T TYPE IN ANY NAMES
	POPJ P,

DOCLOS:	ASCIZ /HELP DOCUMENTS SPECIFIED COMMANDS, LISTC LISTS ALL COMMANDS./

		;WALLP INFILES$OUTFILE$	;READ FILE AND PRINT ENTRIES

WALLP:	PUSHJ P,RIFDS	;READ INPUT FILE DESCRIPTIONS
	PUSHJ P,PRTOPN	;ALSO READ OUTPUT DESCRIPTIONS, AND OPEN
	MOVEI A,BK2TB
	HRRM A,BK2CAL
WALLP1:	PUSHJ P,OPNRD	;OPEN NEXT INPUT FILE
	JRST PRTCLS	;DIDN'T SKIP, THAT'S ALL, CLOSE PRINT CHANNEL AND RETURN
	SETZM BEOFP	;CLEAR OUT EOF INDICATION
WALLP2:	PUSHJ P,BJNRED	;READ IN BLOCKS 0 AND 1
	INSIRP PUSH P,[C D]	;SAVE ACCESS POINTER, BLOCK NUMBER
	PUSHJ P,MPRTFF	;MAYBE PRINT FORM FEED
	6PRT 2,BLK1+7	;DRAGON'S UNAME
	6PRT 1,BLK1	;FILE IDENTIFIER
	6PRT BLK1+5	;DRAGON'S .FNAM2
	PUSHJ P,SPACE6
	6PRT 1,[SIXBIT /ZUSERS/]
	6PRT BLK1+4	;ZUSERS FILE FNAM2
	PRT [ASCIZ /   FORMAT # /]
	HLRZ A,BLK1+1	;GET DRAGON FORMAT #
	PUSHJ P,PDPT
	PRT [ASCIZ /.      ITS /]
	6PRT BLK1+6	;PRINT .RSYSI THAT SYSTEM
	HRRZ A,BLK1+1	;GET SYSTEM FORMAT #
	PRT [ASCIZ /   FORMAT # /]
	PUSHJ P,PDPT
	MOVEI A,".
	PUSHJ P,PCH
	PUSHJ P,P2CRLF	;END WITH TWO CRLF'S
	INSIRP POP P,[D C]	;RESTORE STUFF PUSHED, WILL USE IT AT BK2RD
	PUSHJ P,BK2RD	;READ IN BLOCK 2
	SKIPE BEOFP	;SKIP IF NO MORE SUB-FILES
	JRST WALLP2	;MORE SUB-FILES, GO GET THEM
	JRST WALLP1	;NO MORE, GET NEXT FILE

		;WALLPAPERING

WLOGIN:	CAIGE B,3	;PRINT LOGIN
	.VALUE		;BLOCK TOO SHORT
	6PRT 2,LIUNAM	;PRINT UNAME
	6PRT 2,LIJNAM	;PRINT JNAME
	6PRT 2,[SIXBIT /LOGIN/]
	CAIL B,4
	6PRT 2,LIDLIN	;DIAL-IN CONSOLE NAME (OR NULL)
	MOVE A,LITIME
TMPTCR:	PUSHJ P,TIMPRT
	JRST PCRLF

TIMPRT:	PRT [ASCIZ /T + /]
	MOVEI D,10.
	IDIVI A,30.
	JRST HMSPRT

WTIME:	CAIGE B,3
	.VALUE
	MOVE A,TMDTIM
	PUSHJ P,TIMPRT
	PRT [ASCIZ / = /]
	MOVE A,TMRTIM	;FIRST WORD .RLPDT
	MOVE E,TMRYR	;SECOND WORD "
	PUSHJ P,THENPT
	JRST PCRLF

WLOGOT:	CAIGE B,4	;LOGOUT
	.VALUE		;BLOCK TOO SHORT
	6PRT 2,LOUNAM	;UNAME
	6PRT 2,LOJNAM	;JNAME
	PRT [ASCIZ /LOGOUT	/]
	MOVE A,LOTIME	;GET .RDTIME OF LOGOUT
	PUSHJ P,TIMPRT	;PRINT TIME OF LOGOUT
	PRT [ASCIZ /	TUSED = /]
	MOVE A,LORNTM	;RUN TIME
	MULI A,4069.
	DIV A,[1000000000.]	;10.**9
	MOVEI D,13.
	PUSHJ P,HMSPRT	;PRINT TIME USED
	PUSHJ P,PTAB
	LDB T,[CNTBP,,HEADER]	;GET SIZE OF BLOCK AGAIN
	CAIGE T,5	;MORE?
	JRST PCRLF	;NO
	PRT [ASCIZ /SWPIRQ = /]
	MOVE A,LOSWRQ
	MOVEI D,13.
	PUSHJ P,PDPTCN
	JRST PCRLF	;END WITH CRLF

WUNDS:	MOVEI C,UNDSBK	;UNDEFINED (NEEDED) SYSTEM SYMBOLS
	MOVEI D,UNDSBK(B)
	JSP Q,PRUNDS
	 0		;# COLUMNS INDENTATION
	POPJ P,

		;LIST SUB-FILES ON FILE(S)

LISTSF:	PUSHJ P,RIFDS	;READ FILE DESCRIPTIONS
	MOVEI A,SBK2TB
	HRRM A,BK2CAL	;STORE LOCATION OF TABLE
LSTSF1:	PUSHJ P,OPNRD	;OPEN NEXT FILE
	 POPJ P,	;THAT'S ALL
	SETOM LSTDAT
	SETZM LASTID
	SETZM BEOFP
	MOVEI B,RCHSTB
	PUSHJ P,TYPFIL	;TYPE OUT FILE DESCRIPTION
	PUSHJ P,CRLF	;END LINE
LSTSF2:	PUSHJ P,SPACE	;LOOP POINT FOR NEXT SUBFILE
	PUSHJ P,BJNRED	;READ BLOCKS 0 AND 1
	CLEARF TMPF3
	CAMN A,LASTID'	;ID SAME AS LAST?
	JRST LSTSF3	;YES, DON'T RE-TYPE
	MOVEM A,LASTID	;STORE AS LAST ID
	PUSHJ P,IDLKUP	;LOOK UP ID
	MOVE B,IDFNTB(E)	;GET FNAM1 CORRESPONDING TO ID
		;THIS SHOULD BE MADE NOT TO ASSUME IT IS A ZUSERS THREE BLOCK FILE
	PUSHJ P,SIXTYO	;TYPE OUT FNAM1
LSTSF3:	PUSHJ P,SPACE
	6TYPE BLK1+4	;FNAM2 OR ______
	PUSHJ P,BK2RD	;PROCESS BLOCK 2, MAYBE TYPING OUT DATE SUBFILE FIRST WRITTEN
	TESTF E,TMPF3
	JRST .+3
	TYPE [ASCIZ \ ?/?/??\]	;DATE UNKNOWN
	SETOM LSTDAT	;MAKE SURE NEXT KNOWN DATE GETS TYPED OUT
	PUSHJ P,CRLF	;END LINE
	SKIPE BEOFP
	JRST LSTSF2	;MORE SUB-FILES THIS FILE
	JRST LSTSF1	;BACK FOR NEXT FILE

LSTSFT:	SKIPL T,TMRTIM
	TMODF OE,TMPF3
	POPJ P,		;UNKNOWE, OR SUB-FILE DATE HAS ALREADY BEEN TYPED
	IDIVI T,SPD
	CAMN T,LSTDAT
	POPJ P,		;THIS DATE SAME AS LAST
	PUSHJ P,SPACE	;PRECEDE WITH SPACE
	MOVE A,T
	MOVEM A,LSTDAT'	;STORE AS LAST DATE TYPED OUT
	MOVE E,TMRYR	;GET YEAR
	JRST TYPSLD

LSTSFU:	MOVEI A,"*	;DRAGON NEEDS SYSTEM SYMS
	JRST TYO

;;COPY COMMAND
;THE COPY COMMAND IS, UNFORTUNATELY, TOO COMPLICATED TO BE FULLY DESCRIBED IN ITS ONE LINE OF DOCUMT
;OUTPUT; IN FACT, I CAN'T THINK OF ANY CLEAN WAY OF EXPLAINING IT AT ALL.
;BUT RATHER THAN LETTING IT GO UNDOCUMENTED, AND THE CODING THUS UNDECIPHERABLE,
;I'LL EXPLAIN IT MESSILY BELOW.

;COPY INFILES$OUTFILE$ WILL COPY ALL SUB-FILES OF THE INFILES ONTO OUTFILE.
;MINOR FORMAT UPDATING MAY BE DONE ON SUB-FILES WHOSE ID'S ARE RECOGNIZED.
;COPY INFILES$OUTFILE,SUBFILES$, OR EQUIVALENTLY, COPY INFILES$OUTFILE,USE: SUBFILES$
;WILL COPY ONLY THE SPECIFIED SUBFILES (FNAM1 FNAM2) ONTO THE OUTPUT FILE IN ORDER.
;IF ANY OF THE SUB-FILES ISN'T FOUND, AN ERROR MESSAGE IS TYPED OUT
;AND THE RESULTING OUTPUT FILE IS GARBAGE.
;COPY INFILES$OUTFILE, DEL: SUBFILES$ WILL COPY ALL SUBFILES EXCEPT THOSE SPECIFIED, IN ORDER.

;USE AND DEL MAY BE ALTERNATED; THE EFFECT OF EACH IS TO DO THE OTHER UNTIL THE SPECIFIED
;SUBFILE IS ENCOUNTERED, TO DO IT TO IT, THEN TO LOOP BACK FOR THE NEXT SUBFILE.
;THE EFFECT OF A USE OR DEL PSEUDODEV WITHOUT NAMES BEING SPECIFIED
;IS TO SET THE CURRENT MODE TO COPY OR DELETE RESPECTIVELY, THEN LOOP BACK
;FOR THE NEXT SUB-FILE DESCRIPTION (PSEUDOFILE).

;ON END OF COMMAND, ALL REMAINING SUBFILES ARE PROCESSED IN THE CURRENT MODE.

;THE EFFECT OF THE EOF PSEUDODEV IS TO SKIP TO EOF THEN LOOP BACK FOR THE NEXT SUBFILE DESCRIPTION, THE DEFAULT
;DEVICE OF WHICH IS USE OR DEL, WHICHEVER WAS LAST USED. IF ALREADY AT EOF VIA A USE OR
;DEL, NO ACTION IS TAKEN, EXCEPT TO INDICATE THAT EOF WAS REACHED VIA THE EOF PSEUDODEV.

;THERE'S SOME HAIR NOT DESCRIBED ABOVE, BUT THIS SHOULD BE ENOUGH FOR ONE TO GET
;STARTED EITHER USING THE COMMAND OR DECIPHERING THE CODING.

		;VARIABLE USAGE:
		;TMPF3 1 => COPY, 0 DELETE (THIS SUB-FILE)
		;TMPF2 1 => PROCESSING MATCH, RETURN FOR NEW PSEUDOFILE AFTER THIS SUB-FILE
		;TMPF1 USED BY RFDC
		;BEOFP AS NORMAL, 0 => EOF, WILL MATCH EOF PSEUDODEV
			;-1 => EOF BUT DON'T MATCH EOF PSEUDODEV

COPY:	MOVEI A,CBK2TB
	HRRM A,BK2CAL	;SET UP BK2CAL DISPATCH ON BLOCK 2 OF DRAGON ID FILES
	PUSHJ P,RIFDS	;GET INPUT FILE DESCRIPTIONS
	PUSHJ P,RFDCCM	;GET OUTPUT FILE DESCRIPTION
	PUSHJ P,DNININ	;COPY DESC ONTO END OF INPUT FILE LIST
	PUSHJ P,OPNWR	;OPEN OUTPUT FILE
	MOVE A,CPYDFN	;GET DEFAULT SUBNAME 1
	MOVEM A,FNAM1
	SETOM BEOFP	;INDICATE EOF, BUT DON'T MATCH EOF PSEUDODEV
	SETF TMPF3	;SET MODE TO COPY
	MOVEI A,(SIXBIT /USE/)	;ORIGINAL DEFAULT PSEUDODEV IS USE
	MOVEM A,CPYLDV
	MOVEM A,DNAM
	SETZM BEOFPP	;CLEAR OUT OUTPUT EOF POINTER TO EOF POINTER
	SETZM OACESP	;CLEAR OUT PSEUDO-ACCESS POINTER FOR WITHIN SUB-FILE
	SETZM O0ACSP	;CLEAR OUT REAL ACCESS POINTER TO BEGINNING OF THIS SUB-FILE ON OUTPUT
COPY1:	SETZM FNAM2	;CLEAR OUT FNAM2 FOR EACH READ
COPY2:	TESTF E,ALTF\CRF
	JRST COPY9	;END OF COMMAND
	PUSH P,C	;SAVE INPUT ACCESS POINTER (BOY, AM I SORRY I PUT IT IN AN AC!)
	PUSHJ P,RFDCCM	;GET NEXT PSEUDOFILE DESCRIPTION
	POP P,C
	MOVE A,FNAM1
	MOVEM A,CPYDFN
COPY2B:	CLEARF TMPF2	;MATCH NOT FOUND YET
	MOVE A,DNAM
	MOVSI E,-CPYLTB
	CAME A,CPYTB1(E)	;LOOK UP PSEUDODEV
	AOBJN E,.-1
	XCT CPYTB2(E)	;DISPATCH ON PSEUDODEV OR NOT FOUND
	MOVEM A,CPYLDV'	;USE OR DEL, SAVE AS LAST SUCH DEV
	SKIPN FNAM2
	JRST COPY2	;FNAM2 NULL
	TMODF C,TMPF3	;WANT TO USE OPPOSITE MODE UNTIL SUB-FILE FOUND
COPY4:	PUSHJ P,RNUSBF	;READ IN BLOCKS 0 AND 1 OF NEW SUB-FILE
	JRST CPYERR	;DIDN'T SKIP, NO MORE INPUT
	MOVE A,BLK1	;GET ID
	PUSHJ P,IDLKUP	;LOOK UP IN TABLES
	SKIPGE E
	MOVE A,IDFNTB(E)	;GET CORRESPONDING FNAM1
	CAME A,FNAM1
	JRST COPY4B	;FNAM1'S DON'T MATCH
	MOVE A,BLK1+4	;GET ORIGINAL FNAM2 OF SUB-FILE
	CAMN A,FNAM2
	TMODF C,TMPF2\TMPF3	;FOUND SUB-FILE
COPY4B:	PUSHJ P,CPYSF	;COPY OR DELETE SUB-FILE
	TESTF N,TMPF2	;WAS THIS MATCHING SUB-FILE?
	JRST COPY4	;NO, GO BACK AND COPY NEXT
	TMODF C,TMPF3	;YES, RE-COMPLEMENT MODE
	JRST COPY1	;BACK FOR NEXT PSEUDOFILE

		;EOF PSEUDODEV SPECIFIED IN COPY COMMAND
		;ENTRY IS CPYEOF
		;THIS SHOULD BE REWRITTEN SOME TIME TO DELETE MORE EFFICIENTLY

CPYEF1:	PUSHJ P,RNUSBF	;READ IN NEW BLOCKS 0 AND 1
	 ERR [ASCIZ /NO MORE FILES FOR EOF./]	;OR SOMETHING
		; ^ RAN OUT OF SOURCE FILES WHILE SEARCHING FOR EOF
	PUSHJ P,CPYSF	;COPY THIS SUB-FILE
CPYEOF:	SKIPE BEOFP	;ENTRY, AT EOF NOW?
	JRST CPYEF1	;NO, SKIP TO THERE
	SETOM BEOFP	;AT EOF BUT DON'T LET IT MATCH ANOTHER EOF PSEUDODEV
	MOVE A,CPYLDV	;GET LAST USE OR DEL DEV
	MOVEM A,DNAM	;STORE AS DEFAULT FOR NEXT
	SKIPE FNAM2	;SUB-FILE SPECIFIED W/ EOF?
	JRST COPY2B	;YES, USE IT W/ LAST USE OR DEL DEV
	JRST COPY2	;NO, READ NEW SUB-FILE SPEC

		;END OF COMMAND, CONTINUE IN CURRENT MODE UNTIL END OF SOURCE FILES

COPY9:	PUSHJ P,RNUSBF	;READ IN BEGINNING OF NEW SUB-FILE
	JRST COPY9B	;NO MORE
	PUSHJ P,CPYSF	;COPY OUT IN CURRENT MODE (THIS SHOULD BE OPTIMIZED TOO)
	JRST COPY9	;LOOP UNTIL DONE

COPY9B:	MOVE A,BEOFPP	;DONE COPYING, NOW GET POINTER TO WHERE EOF POINTER SHOULD GO
	PUSHJ P,ACCESO	;SET TO WRITE AT THAT LOCATION
	HRROI T,O0ACSP	;SET UP BLOCK IOT POINTER TO ACCESS POINTER TO REAL EOF
	PUSHJ P,SBOUT	;WRITE OUT
	PUSHJ P,DNINOT
	JRST WRCLS	;CLOSE WRITE CHANNEL AND RETURN, ALL DONE

		;PSEUDODEV TABLES

CPYTB1:	(SIXBIT /DEL/)
	(SIXBIT /USE/)
	(SIXBIT /EOF/)
CPYLTB==.-CPYTB1	;# OF PSEUDODEVS

CPYTB2:	CLEARF TMPF3	;DEL
	SETF TMPF3	;USE
	JRST CPYEOF	;EOF
IFN .-CPYTB2-CPYLTB,PRINTB CPYTB2 LOSES.
	JRST CPYUND	;UNRECOGNIZED PSEUDODEV

CPYDFN:	SIXBIT /ZUSERS/	;DEFAULT SUB-FILE FNAM1 (VARIABLE)

CPYUND:	PUSHJ P,ERR1	;TRYING TO LOOK UP UNKNOWN PSEUDODEV
	HRLZ B,DNAM
	PUSHJ P,SIXTYO
	ERR [ASCIZ / NOT DEFINED PSEUDODEV./]

		;GET HERE WHEN RUN OUT OF FILES WHILE SEARCHING FOR SUB-FILE

CPYERR:	PUSHJ P,ERR1
	6TYPE 1,FNAM1
	6TYPE 1,FNAM2
	ERR [ASCIZ /NOT FOUND./]

		;ROUTINE TO READ IN BLOCKS 0 AND 1 OF NEW SUB-FILE

RNUSBF:	SKIPLE BEOFP
	JRST RNUSB2	;NOT EOF, DON'T OPEN NEW FILE
	PUSHJ P,OPNRD	;OPEN NEW FILE
	 POPJ P,	;DIDN'T SKIP, DON'T SKIP
RNUSB2:	PUSHJ P,BJNRED	;READ IN BLOCKS 0 AND 1
	JRST POPJ1	;EXIT SKIPPING

		;CPYSF ROUTINE TO COPY DRAGON ID FILE

CPYDRG:	PUSHJ P,BK2RD	;DISPATCH AT BK2CAL ALREADY SET UP
	MOVE A,OACESP
	MOVEM A,OBLK0(D)	;STORE ACCESS POINTER TO END OF BLOCK 2
	POPJ P,

		;COPY OR DELETE SUB-FILE

CPYSF:	TESTF N,TMPF3
	JRST CPYSFD	;DELETE
	MOVE T,RNBLKS
	ADDI T,3
	SKIPG BEOFPP
	MOVEM T,BEOFPP'	;STORE POINTER TO REAL EOF POINTER
	MOVE T,[BLK0,,OBLK0]
	BLT T,OBLK0+NWB0-1	;BLT OUT BLK0, ABOUT TO DE-RELOCATE
	MOVN A,OBLK0
	MOVSI T,-NWB0
	ADDM A,OBLK0(T)
	AOBJN T,.-1
	MOVE A,O0ACSP
	PUSHJ P,ACCESO	;ACCESS TO BEGINNING OF FILE
	SETZB D,OACESP	;INITIALIZE TO BLOCK 0
	MOVEI A,OBLK0
	PUSHJ P,BLKOUT	;DUMP OUT OBLK0 AS BLOCK 0
	MOVEI A,BLK1
	SETZM BLK1+2	;CLEAR OUT REAL EOF POINTER
	PUSHJ P,BLKOUT	;DUMP OUT BLK1
	MOVE A,BLK1	;GET ID
	PUSHJ P,IDLKUP	;LOOK UP ID
	XCT CPCPTB(E)	;COPY KNOWN PART OF SUB-FILE, RETURN NEXT BLOCK # IN D
	CAMLE D,RNBLKS
	.VALUE		;POINTERS ALL SCREWED UP, THOUGH MAYBE OUTPUT FILE NOT CLOBBERED TOO BAD
	MOVE A,RNBLKS	;GET INDEX INTO BLK0 FOR EOF ACCESS POINTER
	MOVE A,BLK0(A)
	SUB A,BLK0(D)
	JUMPLE A,CPYSF3	;JUMP IF NOTHING MORE TO COPY
	ADDM A,OACESP	;UPDATE ACCESS POINTERS WHILE CONVENIENT
	ADD C,A
	IDIVI A,BKBFL
	SKIPN E,A
	JRST CPYBN1	;NO COMPLETE BKBF'S TO COPY
	MOVE T,[-BKBFL,,BKBF]
	PUSHJ P,CPYBLK	;COPY A BLOCK
	SOJG E,.-2	;LOOP FOR RIGHT NUMBER OF BUFFER-FULLS
CPYBN1:	JUMPE B,CPYSF3	;JUMP IF REMAINDER IS ZERO, NO TRUNCATION ERROR
	HRLOI T,-1(B)
	EQVI T,BKBF
	PUSHJ P,CPYBLK
CPYSF3:	MOVE A,O0ACSP	;NOW GET ACCESS POINTER TO BEGINNING OF SUB-FILE
	PUSHJ P,ACCESO	;DO ACCESS TO THERE
	HRLO T,RNBLKS	;1 LESS THAN # WORDS REALLY IN BLOCK 0
	EQVI T,OBLK0	;SET UP BLOCK IOT POINTER TO OBLK0
	PUSHJ P,SBOUT	;OUTPUT ACCURATE BLOCK 0
	MOVE A,OACESP
	ADDM A,O0ACSP'
CPYSFD:	SKIPG BEOFP
	POPJ P,		;EOF ON INPUT FILE
	MOVE D,RNBLKS
	JRST ACCESS	;DO .ACCESS TO BEG OF NEXT SUB-FILE

		;LOAD INFILES$	;INITIALIZE RESOURCE TABLE (SYMTAB) AND READ IN FILE
		;MERGE INFILES$	;LIKE LOAD BUT DOESN'T RE-INITIALIZE TABLE

LOAD:	PUSHJ P,RSTST	;INITIALIZE SYMTAB
MERGE:	PUSHJ P,RIFDS	;READ INPUT FILE DESCRIPTIONS
	MOVEI A,LBK2TB
	HRRM A,BK2CAL
LOAD1:	PUSHJ P,OPNRD	;OPEN NEXT INPUT FILE
	 POPJ P,
	SETZM BEOFP	;CLEAR OUT EOF INDICATION
	MOVE A,LFILEP	;GET POINTER TO FILE DESCRIPTOR AREA
	SUBI A,NWLFIL	;BACK UP TO BEGINNING OF NEW FILE DESC
	MOVE T,A	;NOW TO BLT STUFF IN FROM .RCHST AT OPNRD
	PUSHJ P,LFILCK	;BUT FIRST MAKE SURE THERE'S ROOM
	HRLI T,RCHSTB
	BLT T,3(A)
	MOVEM A,LFILEP	;STORE BACK UPDATED POINTER
LOAD2:	MOVEI T,-NWLSFL(A)	;BACK UP POINTER TO BEGINNING OF THIS SUBFILE DESC
	PUSHJ P,LFILCK	;MAYBE GET SOME CORE
	MOVEM T,LSFILP	;STORE BACK UPDATED POINTER
	MOVEM T,LFILEB	;ALSO STORE AS BOTTOM POINTER
	SETOM 2(T)
	SETZM 6(T)	;CLEAR OUT NEEDED SYM COUNT
	PUSHJ P,BJNRED	;READ IN BLOCKS 0 AND 1
	MOVE T,LFILEB	;GET POINTER TO BEGINNING OF SUBFILE DESC.
	ADDI T,7-1	;CONVERT TO PDL POINTER TO WORD 7
	PUSH T,BLK1+6	;.RSYSI THIS SYSTEM
	PUSH T,BLK1+5	;.FNAM2 OF DRAGON
	PUSHJ P,BK2RD	;READ BLOCK 2
	MOVE B,STP	;NOW TO GO THROUGH SYMTAB
LOAD3A:	CAML B,STE	;END OF TABLE?
	JRST LOAD3X	;YES
	MOVN A,2(B)	;GET NEGATIVE OF .RDTIME LOGGED IN
	JUMPGE A,LOAD3B	;JUMP IF ZERO (=> UNKNOWN, OR HE DIDN'T LOG IN THIS SYSTEM)
	ADD A,LSTTIM	;GET AMT OF REAL TIME USED BEFORE SYSTEM CRASHED
	ADDM A,3(B)	;ADD TO REAL TIME USED SO FAR
	MOVSI A,SIGN
	IORM A,3(B)	;SET INDEFINITE BIT
	SETZM 2(B)	;CLEAR OUT TIME LOGGED IN
LOAD3B:	ADDI B,WPS	;INCREMENT TO NEXT SYMTAB ENTRY
	JRST LOAD3A	;BACK FOR NEXT ENTRY

LOAD3X:	MOVE T,[SIXBIT /ZUSERS/]	;YEAH, WELL
	MOVE TT,BLK1+4	;FNAM2
	MOVE A,LSFILP	;GET POINTER TO SUBFILE DESC
	MOVEM T,(A)
	MOVEM TT,1(A)
	MOVE A,LFILEB	;GET POINTER TO BEGINNING OF STUFF LAST SUBFILE
	SKIPE BEOFP	;SKIP ON EOF
	JRST LOAD2	;MORE SUB-FILES
	SUB A,LFILEP	;GET NUMBER OF WORDS USED FOR SUBFILE DESCS THIS FILE
	HRLM A,@LFILEP	;LINK FORWARD
	ADDB A,LFILEP
	MOVEM A,LFILEB	;INDICATE BEGINNING OF ALLOCATION
	JRST LOAD1	;EOF, GO GET NEXT FILE

		;FILE AND SUB-FILE DESCRIPTOR AREA FOR LOAD/ACCUSE

		;TABLE ENTRIES ARE IN REVERSE ORDER
		;I.E. TABLE IS TOP JUSTIFIED
		;VARIABLES:
		;LFILEA FIRST ADR ALLOCATED TO TABLE
		;LFILEB POINTS TO BOTTOM OF TABLE
		;LFILEP POINTS TO FILE DESCRIPTOR
		;LSFILP POINTS TO SUBFILE DESCRIPTOR
		;LFILEE POINTS TO TOP OF TABLE

NWLFIL==4	;EACH FILE HAS NWLFIL WORDS
	;WRD 0 DEVICE NAME (OR TAPE NAME); LH - # WORDS SUBFILE STORAGE THIS FILE
	;1 FNAM1
	;2 FNAM2
	;3 SYSTEM NAME

NWLSFL==11	;EACH SUB-FILE HAS NWLSFL WORDS PLUS NEEDED SYMS STORED BEFORE WORD 0
	;WRD 0 FNAM1
	;1 FNAM2
	;2 FIRST WRD .RLPDT FIRST TIME BLOCK
	;3 SECOND WRD "
	;4 FIRST WRD .RLPDT LAST TIME BLOCK
	;5 SECOND WRD "
	;6 RH # WORDS NEEDED SYMS (EACH ENTRY 2 WORDS)
	;7 .RSYSI OF SYSTEM
	;10 .FNAM2 OF DRAGON

LTIME:	CAIGE B,3	;PROCESS TIME BLOCK
	.VALUE
	MOVE A,TMRTIM	;GET TIME
	MOVEM A,CURTIM'
	JUMPL A,CPOPJ	;RETURN IF TIME NOT KNOWN
	MOVE B,TMRYR	;YEAR
	MOVEM B,CURYR'
	MOVE D,LSFILP	;POINTER TO SUB-FILE
	SKIPL 2(D)
	JRST .+3	;FIRST TIME ALREADY STORED
	MOVEM A,2(D)	;STORE FIRST TIME
	MOVEM B,3(D)
	MOVEM A,4(D)	;LAST
	MOVEM B,5(D)
	MOVE A,TMDTIM
	MOVEM A,LSTTIM'	;ALSO STORE LAST .RDTIME SYSTEM KNOWN TO BE ALIVE
	POPJ P,

		;T HAS ADR TO MAKE NEW BOTTOM OF LFILE TABLE

LFILCK:	CAML T,LFILEA
	POPJ P,		;ALREADY ALLOCATED
	PUSH P,C
	MOVEI C,LFILEA	;SET UP ARGUMENT
	PUSHJ P,DWNCOR	;ALLOCATE CORE
	POP P,C
	POPJ P,

		;ROUTINES FOR LOAD AND MERGE

LLOGIN:	CAIGE B,3
	.VALUE
	MOVE SYM,LIUNAM	;GET UNAME
	MOVE SYMJ,LIJNAM	;JNAME
	PUSHJ P,LKUP
	CAMN C,D	;ALREADY THERE?
	PUSHJ P,DOWN	;NOT THERE, CREATE
	MOVEM SYM,(C)	;STORE UNAME
	MOVEM SYMJ,1(C)	;STORE JNAME
	MOVE A,LITIME
	MOVEM A,2(C)	;STORE TIME OF LOGIN
	CAIL B,4
	JRST DLCHK	;GO PROCESS DIAL-IN CONSOLE ENTRY AND RETURN
	POPJ P,

LLOGOT:	CAIGE B,4
	.VALUE
	MOVE SYM,LOUNAM
	MOVE SYMJ,LOJNAM
	PUSHJ P,LKUP
	CAMN C,D
	JRST LOGO1	;JOB NOT FOUND
	MOVN A,2(C)	;GET - TIME LOGGED IN
	JUMPE A,LOGO2	;JUMP IF UNKNOWN OR NONEXISTENT
	SETZM 2(C)	;CLEAR OUT .RDTIME LOGGED IN
	ADD A,LOTIME
	ADDM A,3(C)	;UPDATE CONSOLE TIME USED
	JRST LOGO2D

LOGO1:	PUSHJ P,DOWN
	MOVEM SYM,(C)
	MOVEM SYMJ,1(C)
LOGO2:	MOVSI A,SIGN
	IORM A,3(C)	;SET UNKNOWN BIT
LOGO2D:	MOVE A,LORNTM	;GET RUN TIME
	MUL A,[4069.*3]
	DIV A,[100000000.]	;10.**8
	ADDM A,4(C)	;UPDATE RUN TIME IN THIRTIETHS
	LDB T,[CNTBP,,HEADER]
	CAIGE T,5
	TDZA A,A	;SWAPIN REQUESTS UNKNOWN, USE ZERO
	MOVE A,LOSWRQ	;GET # SWAPIN REQUESTS
	ADDM A,5(C)	;UPDATE
	POPJ P,

LUNDS:	JUMPLE B,CPOPJ	;LOAD UNDEFINED SYMS; IGNORE NONE
	MOVE A,LSFILP	;SOME THERE, GET POINTER TO SUB-FILE DESC.
	ADDM B,6(A)	;UPDATE UNDEFILED SYMBOL WORD COUNT
	MOVE T,LFILEB	;NOW GET POINTER TO BEGINNING OF STUFF THIS SUBFILE
	EXCH T,B
	SUBM B,T	;CALCULATE NEW BOTTOM OF TABLE
	PUSHJ P,LFILCK	;MAYBE ALLOCATE CORE
	MOVEM T,LFILEB	;STORE BACK UPDATED POINTER
	HRLI T,UNDSBK	;CONVERT TO BLT POINTER
	BLT T,-1(B)	;BLT IN LIST
	POPJ P,

	;JSP Q,PRUNDS	;PRINT LIST OF NEEDED (UNDEFINED) SYMBOLS THIS SYSTEM
	 ;# CHARS INDENTATION	;C HAS FIRST ADR, D LAST + 1

WPUNDE:	2		;NUMBER OF WORDS PER UNDEFINED SYMBOL ENTRY

PRUNDS:	MOVE B,(Q)	;GET INDENTATION
	PUSHJ P,ALIGN0	;ALIGN TO IT, BUT NO MINIMUM NUMBER OF SPACES
	PRT [ASCIZ /NEEDED SYSTEM SYMBOLS:/]	;22. CHARACTERS LONG
PRUND1:	CAML C,D	;SKIP UNLESS DONE
	JRST PRUND3	;ALL PRINTED
	MOVE A,LINEPS	;NOW TO DECIDE WHETHER TO START NEW LINE
	CAIL A,CPL-15.
	PUSHJ P,PCRLF	;NEW LINE
	MOVE B,(Q)	;GET INDENTATION
	ADDI B,22.	;ADD LENGTH OF MESSAGE
	MOVEI A,^I	;TAB
	PUSHJ P,PCH
	CAML B,LINEPS	;PRINT TABS UNTIL AT PROPER PLACE
	JRST .-2
	MOVE A,(C)	;GET SYM
	PUSHJ P,SQPRT	;PRINT SYM
	ADD C,WPUNDE	;INCREMENT TO NEXT
	JRST PRUND1	;BACK FOR NEXT

PRUND3:	PUSHJ P,PCRLF	;END WITH CRLF
	JRST 1(Q)	;RETURN, SKIPPING OVER ARG

		;ACCUSE COMMAND, PRINT SYM TAB

ACCUSE:	MOVE E,STP	;GET POINTER TO BOTTOM OF SYMTAB
	CAML E,STE
	ERR [ASCIZ /RESOURCE TABLE EMPTY./]
	PUSHJ P,PRTOPN	;READ OUTPUT FILE DESCRIPTION, OPEN OUTPUT FILE
	PUSHJ P,ACUSF	;DOCUMENT FILES ACCUSATION COMING FROM
	PUSHJ P,PRTFF
	PRT ACUSH	;PRINT HEADER
	MOVE E,STP	;GET ST POINTER BACK
	SETZM TOTCT'	;TOTAL CONSOLE TIME
	SETZM TOTRNT'	;TOTAL RUN TIME
	SETZM TOTSW'	;TOTAL SWAP IN REQUESTS
ACUS1:	MOVE B,(E)	;GET UNAME
	PUSHJ P,SIXPT
	PUSHJ P,PTAB
	MOVE B,1(E)	;GET JNAME
	PUSHJ P,SIXPT
	PUSHJ P,PTAB
	MOVE A,3(E)	;CONSOLE TIME USED
	TLZ A,SIGN	;FOR NOW IGNORE INACCURACY PROBLEM
	ADDM A,TOTCT
	PUSHJ P,P30	;PRINT IN REASONABLE SNOWY FORMAT
	PUSHJ P,PTAB
	MOVE A,4(E)	;RUN TIME USED
	ADDM A,TOTRNT
	PUSHJ P,P30	;PRINT RUN TIME
	SKIPN 5(E)	;CHECK FOR NO SWAPIN REQUESTS
	JRST ACUS1B	;NO SWAPIN REQUESTS
	PUSHJ P,PTAB	;SEPARATE WITH TAB
	MOVE A,5(E)	;GET # SWAPIN REQUESTS
	ADDM A,TOTSW
	MOVEI D,13.
	PUSHJ P,PDPTCN
ACUS1B:	PUSHJ P,ACUSCR	;PRINT CR, MAYBE NEW HEADER
	ADDI E,WPS	;INCREMENT TO NEXT ENTRY
	CAMGE E,STE	;ABOVE TABLE?
	JRST ACUS1	;NO, BACK FOR NEXT USER
	MOVE B,[SIXBIT /TOTALS/]
	PUSHJ P,SIXPT
	PUSHJ P,PTAB
	MOVE B,[SIXBIT /TOTALS/]
	PUSHJ P,SIXPT
	PUSHJ P,PTAB
	MOVE A,TOTCT
	PUSHJ P,P30
	PUSHJ P,PTAB
	MOVE A,TOTRNT
	PUSHJ P,P30
	SKIPN TOTSW
	JRST ACUS1C
	PUSHJ P,PTAB
	PUSHJ P,PTAB
	MOVE A,TOTSW
	PUSHJ P,PDPTCN
ACUS1C:	PUSHJ P,ACUSCR
	PUSHJ P,PRTFF	;PUT DIAL-IN CONSOLE USAGE ON SEPARATE PAGE
	PUSHJ P,DLPRT	;PRINT CONSOLE USAGE
	JRST PRTCLS

		;HEADER PRINTED AT TOP OF EACH PAGE OF ACCUSE OUTPUT

ACUSH:	ASCIZ /
UNAME	JNAME	    REAL TIME	     RUN TIME	     SWAPIN RQ

/

ACUSCR:	PUSHJ P,PCRLF	;PRINT CRLF AND MAYBE HEADER FOR NEW PAGE
	MOVE A,LINENR
	CAIL A,LPP-1	;ROOM FOR ANOTHER USER?
ACUSC2:	PUSHJ P,PRTFF	;NO, FORMF NOW
	SKIPN LINENR	;AT BEGINNING OF PAGE NOW?
	PRT ACUSH	;YES, PRINT HEADER
	POPJ P,

		;DOCUMENT FILES FOR ACCUSE

ACUSF:	MOVE A,LFILEE
	MOVEM A,LFILEP	;START AT TOP (BEGINNING) OF TABLE
	SETOM UPTIME	;TIME UP INDEFINITE BEFORE FIRST DATE
ACUSF1:	MOVNI C,NWLFIL
	ADDB C,LFILEP	;BACK UP TO BEGINNING OF FILE SPEC
	CAMGE C,LFILEB	;SKIP UNLESS BELOW BOTTOM OF TABLE
	JRST ACUSF6	;NO MORE FILES
	PUSHJ P,PCRLF	;EXTRA CR FOR EACH FILE
	MOVE B,C	;SET UP ARG FOR PRTFIL
	PUSHJ P,PRTFIL	;PRINT FILE DESCRIPTION
	PUSHJ P,PCRLF
	HLRE A,(C)
	ADDM A,LFILEP	;LINK FORWARD
ACUSF5:	SUBI C,NWLSFL	;BACK UP TO BEGINNING OF SUB-FILE DESCRIPTION
	CAMGE C,LFILEP
	JRST ACUSF1	;BACK FOR NEXT FILE
	MOVEM C,LSFILP	;STORE POINTER TO SUB-FILE
	PUSHJ P,SPACE2	;SPACE SOME SO WILL BE OBVIOUS THIS IS A SUB-FILE
	6PRT 1,(C)	;FNAM1
	6PRT 1(C)	;FNAM2
	SKIPGE 2(C)	;ANY DATE/TIMES?
	JRST ACUSF9	;NO KNOWN DATES OR TIMES
	MOVEI B,2+16.
	PUSHJ P,ALIGN	;LOSSLESS TAB
	PUSHJ P,UPRT1	;DIGEST TIME UP, MAYBE PRINT % TIME UP ON LAST DAY IT CAME DOWN
	SETZM UPTIME	;DIDN'T SKIP => NEW DAY, CLEAR OUT TIME UP SO FAR
	ADDM TT,UPTIME	;EITHER WAY, UPDATE TIME UP ON PRESUMPTION IT WILL REMAIN UP TODAY
	PUSHJ P,UPRTNR	;MAYBE PRINT NUMBER OF COMPLETE CALENDAR DAYS DOWN
	MOVE C,LSFILP	;RESTORE C
	ADDI C,2	;INCREMENT TO DOWN DATE/TIME
	PUSHJ P,UPRT1	;DIGEST DOWN DATE; MAYBE PRINT % TIME UP ON UP DATE
	MOVEM T,UPTIME	;DIDN'T SKIP => ALREADY UP AT BEGINNING OF DOWN DATE
	MOVNS TT
	ADDM TT,UPTIME	;STORE NUMBER OF SECONDS UP SO FAR ON DOWN DATE
	MOVE C,LSFILP	;RESTORE C AGAIN
	MOVE A,2(C)	;FIRST KNOWN TIME
	MOVE E,3(C)	;FIRST KNOWN YEAR
	PUSHJ P,THENPT
	MOVEI B,3+16.+14.+37.
	PUSHJ P,ALIGN	;SUPER-TAB
	PUSHJ P,UPRTNR	;MAYBE PRINT NUMBER OF COMPLETE CALENDAR DAYS UP
	MOVE C,LSFILP	;GET BACK POINTER, CLOBBERED BY THENPT
	MOVE A,4(C)	;LAST KNOWN TIME WITHIN YEAR
	MOVE E,5(C)	;YEAR
	PUSHJ P,THENPT
	SKIPA C,LSFILP	;GET BACK POINTER ONE MORE TIME
ACUSF9:	SETOM UPTIME	;DATES INDEFINITE, CAUSE UP TIME PRINTING ROUTINES NOT TO PRINT GARBAGE
	PUSHJ P,PCRLF	;END SUB-FILE DESCRIPTION WITH CR
	SKIPE D,6(C)	;GET NEEDED SYMBOL WORD COUNT
	PUSHJ P,ACUSUS	;NON-ZERO, PRINT NEEDED SYMBOLS
	JRST ACUSF5

ACUSF6:	MOVEI D,2+16.+4	;ALL DONE PRINTING FILES
	MOVEI Q,BKWOUT
	PUSHJ P,UPRT3	;PRINT PERCENT TIME UP ON LAST DAY
	JRST PCRLF	;END WITH CR

		;PRINT NEEDED (UNDEFINED) SYSTEM (S) SYMBOLS FOR ACCUSE

ACUSUS:	SUBM C,D	;GET ADR BEGINNING OF LIST
	MOVEM D,LSFILP	;STORE AS CURRENT POINTER
	EXCH C,D	;WANT IN OTHER ORDER, LOWER IN C, UPPER IN D
	PUSHJ P,SPACE6	;INDENT
	6PRT 1,7(D)	;.RSYSI OF SYSTEM
	6PRT 10(D)	;DRAGON'S .FNAM2
	JSP Q,PRUNDS	;PRINT THE NEEDED SYMS
	 6+16.		;INDENTATION
	MOVE C,LSFILP	;RESTORE C
	POPJ P,

	;EACH SUB-FILE ID GOES WITH AN FNAM1
	;WHICH MAY BE DIFFERENT FROM THE ID

	;THESE ROUTINES LOOK UP ONE GIVEN THE OTHER, AND LEAVE INDEX INTO
	;TABLES IN E SO CAN DISPATCH ON KIND OF FILE

IDNMTB:	SIXBIT /DRAGON/	;ID TABLE
NIDS==.-IDNMTB	;# ID'S RECOGNIZED

DEFINE IDLCHK TBLNAM
IFN .-<TBLNAM>-NIDS,PRINTB [TBLNAM] LOSES.
TERMIN

IDFNTB:	SIXBIT /ZUSERS/	;TABLE OF FNAM1'S FOR THE ID'S
IDLCHK IDFNTB,

		;SET UP INDEX IN E GIVEN ID IN A

IDLKUP:	MOVSI E,-NIDS
	CAME A,IDNMTB
	AOBJN E,.-1
	POPJ P,

		;SET UP INDEX IN E GIVEN FNAM1 IN A

FNLKUP:	MOVSI E,-NIDS
	CAME A,IDFNTB
	AOBJN E,.-1
	POPJ P,

CPCPTB:	PUSHJ P,CPYDRG	;TABLE FOR COPY
IDLCHK CPCPTB,JFCL	;EXTRA FOR UNKNOWN, COPY BLIND

BK2TB:	BK0H	;BK2TB TABLE FOR WALLP COMMAND
	WLOGIN
	WLOGOT
	WTIME
	WUNDS
REPEAT 5,BKNH	;FOR PATCHING
NTYPES==.-BK2TB
	BKNH

BK0H:	.VALUE
BKNH:	.VALUE

SBK2TB:	CPOPJ	;0	;BK2TB TABLE FOOR LISTSF COMMAND
	CPOPJ	;1 LOGIN
	CPOPJ	;2 LOGOUT
	LSTSFT	;3 TIME
	LSTSFU	;4 UNDEFINED SYMS
REPEAT 5,CPOPJ
IFN .-SBK2TB-NTYPES,PRINTA SBK2TB LOSES.
	CPOPJ

LBK2TB:	BK0H	;BK2TB FOR LOAD, MERGE COMMANDS
	LLOGIN
	LLOGOT
	LTIME
	LUNDS
REPEAT 5,BKNH
IFN .-LBK2TB-NTYPES,PRINTA LBK2TB LOSES.
	BKNH

CBK2TB:	BKBFOT	;BK2TB FOR COPY COMMAND
	BKBFOT	;LOGIN
	BKBFOT	;LOGOUT
	BKBFOT	;TIME
	BKBFOT	;UNDEFINED (NEEDED) SYSTEM SYMS
REPEAT 5,BKBFOT
IFN .-CBK2TB-NTYPES,PRINTA CBK2TB LOSES.
	BKBFOT

IFN NOAXSW,[	;INPUT ROUTINES, WITH SIMULATION OF .ACCESS

IFNDEF QBUFL,QBUFL==100	;LENGTH OF EACH OF THE TWO BUFFERS USED
		; ^ ALSO MAXIMUM AMOUNT PSEUDO-.ACCESS ALLOWED TO DECREMENT BY
;UNBGBF==RHF FF,1_69	;SET BY ACCESS IF QNUBUF NOT TO DO .IOT NEXT TIME THROUGH

		;VARIABLES

QBUFCC:	105	;-# WORDS LEFT TO BE READ FROM CURRENT BUFFER
QACCP:	0	;CURRENT .ACCESS POINTER
QBUFP:	0	;POINTER TO NEXT WORD TO BE READ FROM BUFFER
QBUFO:	QBUF1,,QBUF2	;RH ORIGIN OF THIS, LH OTHER
QLIOTP:	105	;.IOT POINTER AFTER LAST .IOT AT QNUBUF (FOR EOF CHECKING)

;BGBLK:	.IOT UTYIC,T
;	JUMPGE T,CPOPJ
;	.VALUE

BGBLK:	JUMPGE T,CPOPJ	;IGNORE ZERO LENGTH READS
	INSIRP PUSH P,[A B]
BGBLK1:	SKIPL QBUFCC
	PUSHJ P,QNUBUF	;CURRENT BUFFER EMPTY, GET NEW ONE
	HLRO B,T	;GET NEGATIVE OF WORD COUNT
	CAMGE B,QBUFCC	;DOES HE WANT TO TRANSFER MORE THAN IN BUFFER?
	MOVE B,QBUFCC	;YES, FOR NOW JUST GIVE HIM WHAT'S THERE
	MOVNS B		;NOW GET POSITIVE AMOUNT TO TRANSFER THIS TIME THROUGH
	HRLZ A,QBUFP	;GET LH OF BLT POINTER
	HRR A,T		;RH
	ADDM B,QBUFCC	;UPDATE WORD COUNT TO INDICATE WHAT ABOUT TO HAPPEN
	ADDM B,QACCP	;ALSO .ACCESS POINTER,
	ADDM B,QBUFP	;AND POINTER INTO BUFFER
	HRLS B		;COPY RH INTO LH
	ADD T,B		;UPDATE AOBJN POINTER SUPPLIED
	BLT A,-1(T)	;NOW ACTUALLY GIVE HIM THE STUFF
	JUMPL T,BGBLK1	;JUMP IF DIDN'T GIVE HIM ALL HE WANTED, TRY AGAIN
	INSIRP POP P,[B A]
	POPJ P,

		;GET NEW BUFFER
		;CLOBBERS A ONLY

QNUBUF:	SKIPGE QLIOTP
	.VALUE		;LAST .IOT RETURNED EOF INDICATION
	MOVSS A,QBUFO	;GET ORIGIN OF NEW BUFFER
	HRRZM A,QBUFP	;STORE AS INITIAL POINTER INTO BUFFER
	HRLI A,-QBUFL	;SET UP AOBJN POINTER TO BUFFER FOR BLOCK .IOT
	TMODF ZE,UNBGBF	;HAS THIS BUFFER ALREADY BEEN READ INTO?
	SKIPA A,QLIOTP	;YES, RETRIEVE IOT POINTER FROM THAT TIME
	.IOT UTYIC,A	;READ IN BUFFER
	MOVEM A,QLIOTP	;STORE BACK UPDATED BLOCK .IOT POINTER FOR EOF CHECK
	SUB A,QBUFO	;GET # WORDS IN BUFFER IN RH
	TLZ A,-1	;CLEAR OUT LH
	MOVNM A,QBUFCC	;STORE WORD COUNT
	POPJ P,

;ACCESS:	CAME C,BLK0(D)
;	.ACCESS UTYIC,BLK0(D)	;NOT ALLOWED TO BACK UP BY MORE THAN QBUFL
;	MOVE C,BLK0(D)
;	POPJ P,

ACCESS:	CAME C,QACCP	;C HAS USER'S VERSION OF ACCESS POINTER, COMPARE WITH LOCAL VERSION
	.VALUE		;.ACCESS POINTERS OUT OF SYNC
	CAMN C,BLK0(D)
	POPJ P,		;ALREADY WHERE WANTS TO BE, DON'T DO ANYTHING
	PUSH P,A	;SAVE A, THIS DOESN'T WANT TO CLOBBER ANY AC'S EXCEPT C
	SUB C,BLK0(D)	;GET NEGATIVE OF INCREMENT DESIRED
	JUMPGE C,ACCESD	;JUMP IF DECREMENTING
ACESU1:	SKIPL QBUFCC	;INCREMENTING, CHECK BUFFER WORD COUNT
	PUSHJ P,QNUBUF	;BUFFER EMPTY, GET NEW ONE
	CAMLE C,QBUFCC	;SKIP IF C HAS BIGGER MAGNITUDE
	SKIPA A,QBUFCC	;QBUFCC HAS BIGGER MAGNITUDE, USE IT FOR NOW
	MOVE A,C	;C, USE IT
	MOVNS A		;CONVERT TO # WORDS TO SKIP FOR NOW
	ADDM A,QBUFCC	;UPDATE COUNTS
	ADDM A,QBUFP
	ADDM A,C
	JUMPL C,ACESU1	;KEEP TRYING UNTIL COUNTED OUT
ACCESX:	MOVE C,BLK0(D)	;RESTORE C FOR CALLING ROUTINE, NEW .ACCESS POINTER
	MOVEM C,QACCP	;ALSO STORE HERE AS SAME
	POP P,A
	POPJ P,

ACCESD:	CAILE C,QBUFL	;ACCESS FOR DECREMENT, COMPARE WITH MAXIMUM DECREMENT ALLOWABLE
	.VALUE		;TRYING TO BACK UP BY MORE THAN QBUFL
	MOVE A,QBUFCC	;GET NEGATIVE OF # WORDS IN BUFFER, THAT + QBUFL IS # IN BUFFER
	CAIG C,QBUFL(A)
	JRST ACESD1	;DON'T HAVE TO SWITCH BUFFERS
	SUBI C,QBUFL(A)	;HAVE TO SWITCH BUFFERS, BACK UP OUT OF THIS ONE
	MOVSS A,QBUFO
	HRRZM A,QBUFP
	SETF UNBGBF	;SIGNAL QNUBUF NOT TO RELOAD BUFFER
ACESD1:	MOVNS C		;CONVERT DECREMENT TO INCREMENT
	ADDM C,QBUFP	;INCREMENT POINTERS
	ADDM C,QBUFCC
	JRST ACCESX

		;INITIALIZATION ROUTINE, CALLED AT .OPEN TIME

AXSET:	MOVE A,[QBUF1,,QBUF2]
	MOVEM A,QBUFO
	SETZM QACCP	;AT BEGINNING OF FILE
	SETZM QBUFCC	;NO WORDS LEFT IN BUFFER
	SETZM QLIOTP	;CLEAR OUT LAST .IOT POINTER SO WON'T LOOK LIKE EOF
	CLEARF UNBGBF
	POPJ P,

QBUF1:	BLOCK QBUFL
QBUF2:	BLOCK QBUFL
]		;END NOAXSW CONDITIONAL

;ROUTINES FOR READING IN STANDARD JSF FORMAT BINARY FILE

;FORMAT OF FILE: DIVIDED INTO SUB-FILES AS SPECIFIED LATER
;EACH SUB-FILE DIVIDED INTO BLOCKS
	;BLOCK 0 "TABLE OF CONTENTS", TABLE OF .ACCESS POINTERS
		;TO EACH BLOCK, EXTRA WORD POINTER TO EOF (OF SUB-FILE)
		;FIRST WORD ALWAYS ZERO (I.E. ".ACCESS POINTER" ZERO => BEGINNING OF SUB-FILE)
	;BLOCK 1 RANDOM CRUD
		;WORD 0 SIXBIT FILE TYPE IDENTIFIER
		;1 ASCENDING FORMAT NUMBER(S) (NOT USED BY THESE ROUTINES)
		;2 .GT. 0 => REAL .ACCESS POINTER TO REAL EOF
		;3 NOT DEFINED NOW, BUT I'LL THINK OF SOMETHING
		;4 ORIGINAL FNAM2 OF SUB-FILE
		;REST FILE-TYPE DEPENDENT
	;REST OF BLOCKS FILE TYPE DEPENDENT TOO

IFNDEF NWB0,NWB0==4	;MAXIMUM NUMBER OF WORDS IN BLOCK 0 (1 MORE THAN MAX # BLOCKS IN SUB-FILE)
			;ALSO MINIMUM LENGTH OF FILE (DUE TO THE WAY BINRED IS WRITTEN)
IFNDEF NWB1,NWB1==6	;MAXIMUM NUMBER OF WORDS IN BLOCK 1

RNWB1:	0	;SET BY BINRED TO NUMBER OF WORDS ACTUALLY READ INTO BLOCK 1
BEOFP:	0	;SHOULD BE CLEARED AT .OPEN, NON-ZERO ON RETURN FROM BINRED
		;=> MORE SUB-FILES TO FOLLOW, CONTAINS .ACCESS POINTER TO REAL EOF
RNBLKS:	0	;SET BY BINRED TO REAL NUMBER OF BLOCKS IN SUB-FILE
		;(ONE LESS THAN NUMBER OF WORDS IN BLOCK 0)

BLK0:	BLOCK NWB0	;BLOCK 0 AREA READ INTO BY BINRED, TABLE OF .ACCESS POINTERS
			;TO BLOCKS OF SUB-FILE
			;ON READ, BLK0 WORDS ARE ADDED TO REAL .ACCESS POINTER TO BEGINNING
			;OF SUB-FILE

BLK1:	BLOCK NWB1	;BLOCK 1 AREA READ INTO BY BINRED

	;ENTRY AND EXIT CONVENTIONS
	;C CONTAINS CURRENT .ACCESS POINTER
	;D CONTAINS CURRENT BLOCK NUMBER (INDEX INTO BLK0)
	;T, TT CLOBBERED BY BINRED
	;ALL OTHERS (EXCEPT P) NOT TOUCHED
	;ENTRY BINRED, READ IN BLOCKS 0 AND 1
	;ENTRY OR EXIT (DEPENDING ON WHETHER DEFINED) ACCESS
	;ENTRY (OR EXIT) BGBLK, DO .IOT

IF1,IFNDEF BGBLK,BGBLK:
IFE BGBLK-.,[
BGBLK:	.IOT UTYIC,T
	JUMPGE T,CPOPJ
	.VALUE		;EOF WHEN NOT EXPECTED
]
IF1,IFNDEF ACCESS,ACCESS:
IFE ACCESS-.,[
ACCESS:	CAME C,BLK0(D)
	.ACCESS UTYIC,BLK0(D)
	MOVE C,BLK0(D)
	TLNE C,-1
	.VALUE		;ACCESS POINTER IS GARBAGE
	POPJ P,
]

		;PUSHJ P,BINRED	;READ IN BLOCKS 0 AND 1 OF SUB-FILE

BINRED:	SKIPLE BEOFP	;IS THIS FIRST SUB-FILE IN FILE?
	TDZA D,D	;NO, JUST CLEAR OUT BLOCK #
	SETZB C,D	;YES, CLEAR OUT FILE .ACCESS POINTER (C) TOO
	MOVE T,[-NWB0,,BLK0]
	PUSHJ P,BGBLK	;READ IN BLOCK 0, MAYBE PLUS A LITTLE OF BLOCK 1
	MOVSI T,-NWB0
	ADDM C,BLK0(T)
	AOBJN T,.-1	;CONVERT SUB-FILE ACCESS POINTERS TO REAL FILE .ACCESS POINTERS
	ADDI C,NWB0	;NOW UPDATE C TO POINT TO END OF STUFF READ
	MOVE T,BLK0+1
	SUB T,BLK0
	SOJ T,
	MOVEM T,RNBLKS	;STORE NUMBER OF BLOCKS IN SUB-FILE
	PUSHJ P,AOJACC	;DO .ACCESS TO BEGINNING OF BLOCK 1
		;NOW FOR BLOCK 1
	MOVE T,BLK0+1(D)	;GET .ACCESS POINTER TO END OF THIS BLOCK
	SUB T,BLK0(D)	;CONVERT TO LENGTH OF BLOCK
	CAILE T,NWB1
	MOVEI T,NWB1	;NOT ENOUGH ROOM, JUST READ ENOUGH TO FILL AVAILABLE SPACE
	MOVEM T,RNWB1	;STORE # WORDS ACTUALLY ABOUT TO BE READ INTO BLOCK 1
	HRLOI T,-1(T)
	EQVI T,BLK1
	PUSHJ P,BGBLK	;READ BLOCK 1
	ADDI C,-BLK1(T)	;UPDATE CURRENT .ACCESS POINTER
	SKIPLE T,BLK1+2	;CHECK WHAT MAY BE .ACCESS POINTER TO REAL EOF
	MOVEM T,BEOFP	;POSITIVE => YES, STORE AS POINTER TO REAL EOF
	MOVE T,RNBLKS	;GET # BLOCKS IN FILE
	MOVE T,BLK0(T)	;GET .ACCESS POINTER TO END OF SUB-FILE
	CAML T,BEOFP
	SETZM BEOFP	;EOF ENCOUNTERED
AOJACC:	AOJA D,ACCESS

		;VERSION OF BINRED TO BE COMPATIBLE WITH OLD VERSIONS
		;OF DRAGON, WHICH DIDN'T HAVE IDENTIFIERS
		;LEAVES IDENTIFIER IN A

BJNRED:	PUSHJ P,BINRED
	MOVE A,BLK1	;GET WHAT IS SUPPOSED TO BE IDENTIFIER
	TLNN A,770000	;IS THERE A LEADING SIXBIT CHARACTER?
	EXCH A,BLK1+1	;NO, IT MUST REALLY BE FORMAT NUMBERS
	CAMN A,[-1]	;IS RESULTING IDENTIFIER -1?
	MOVE A,[SIXBIT /DRAGON/]	;IF SO, REALLY WANT DRAGON
	MOVEM A,BLK1	;STORE RESULTING IDENTIFIER
	POPJ P,

		;READ IN BLOCK 2
		;USES DISPATCH TABLE AS PER COMMENTS AND DEFINITIONS BELOW

BK2RD:	EXCH D,BLKNR'	;D KNOWN TO HAVE 2, DON'T NEED IT FOR AWHILE
	SETOM BK21F
BK2RD1:	CAML C,BLK0+3	;CHECK TO SEE IF DONE
	JRST BK2RD9	;DONE
	HRROI T,NXTHED
	AOSN BK21F'
	PUSHJ P,BGBLK	;FIRST TIME THROUGH, GET FIRST HEADER
	MOVE T,NXTHED	;GET NEXT HEADER
	MOVEM T,HEADER	;SET UP HEADER FOR THIS (SUB)BLOCK
	LDB T,[CNTBP,,HEADER]	;GET COUNT FIELD
	ADDI C,1(T)	;UPDATE .ACCESS POINTER, EXTRA 1 FOR HEADER NOT IN COUNT
	CAMGE C,BLK0+3
	AOJ T,		;MORE BLOCKS AFTER THIS, CAUSE NEXT HEADER TO BE READ WITH THIS BLOCK
	HRLOI T,-1(T)
	EQVI T,BKBF+1
	PUSHJ P,BGBLK	;GET BLOCK
	CAML C,BLK0+3
	SOJA T,.+3	;NO MORE BLOCKS AFTER THIS, DON'T SET UP NXTHED
	ADDI T,-1	;INCREMENT LEFT HALF TO AVOID PDL OVERFLOW, DECREMENT RIGHT HALF
	POP T,NXTHED'	;SET UP NEXT HEADER
		;AT THIS POINT (IF ANYONE CARES) T HAS 0,,LAST LOC ACTIVE IN BKBF
	EXCH C,CACP'	;C UPDATED, DON'T NEED IT FOR AWHILE
	LDB B,[CNTBP,,HEADER]	;GET COUNT IN B
	LDB A,[TYPBP,,HEADER]	;GET TYPE FIELD
	CAILE A,NTYPES"
	MOVEI A,NTYPES
BK2CAL:	PUSHJ P,@BK2TB"(A)	;CALL ROUTINE FOR THIS SUB-BLOCK (RH HRRMABLE BY CALLING ROUTINE)
	EXCH C,CACP	;GET C BACK, NEED IT AGAIN
	JRST BK2RD1	;BACK FOR NEXT BLOCK

BK2RD9:	EXCH D,BLKNR
	AOJA D,ACCESS

BKBF:	BLOCK 130.
BKBFL==.-BKBF	;SYMBOLIC LENGTH OF BKBF

;BK2TB" ENTRIES, DISPATCH TABLE FOR PUSHJ P,@ THRU INDEXED BY SUB-BLOCK TYPE
;0 NOT RECNIZED BY DRAGON, WHICH JUST COPIED IT FROM SYSTEM
;1 LOGIN
HEADER==BKBF	;LOCATION OF HEADER WORD (ALL SUB-BLOCK TYPES)
	INDXP==600	;BYTE POINTER TO USER INDEX FIELD OF HEADER
	CNTBP==220700	;BP TO COUNT FIELD
	TYPBP==360600	;BP TO TYPE FIELD
LITIME==BKBF+1	;CONTAINS LOGIN .RDTIME
LIUNAM==BKBF+2	;CONTAINS UNAME OF JOB BEING LOGGED IN
LIJNAM==BKBF+3	;JNAME
LIDLIN==BKBF+4	;(DIAL-IN) CONSOLE NAME (IN SIXBIT)
;2 LOGOUT
LOTIME==BKBF+1	;LOGOUT .RDTIME
LOUNAM==BKBF+2	;UNAME
LOJNAM==BKBF+3	;JNAME
LORNTM==BKBF+4	;NCTIM (TIME USED, IN 4.069 USEC UNITS)
LOSWRQ==BKBF+5	;# SWAPIN REQUESTS
;3 TIME (.RDTIME VS .RLPDT)
TMDTIM==BKBF+1	;.RDTIME
TMRTIM==BKBF+2	;1ST WRD .RLPDT
TMRYR==BKBF+3	;2ND WRD .RLPDT
;4 NEEDED SYSTEM SYMS, 2 WORD PAIRS, FIRST SQUOZE, SECOND ADR IN DRAGON OF REQUEST
UNDSBK==BKBF+1	;FIRST ADR
;^ MORE TYPES GET INSERTED,
;NTYPES" LAST TYPE (NUMBER, NOT ADDRESS), UNKNOWN TO DRAGIN

		;BINARY OUTPUT ROUTINES

BLKOUT:	MOVE T,BLK0+1(D)	;OUTPUT STARTING FROM ADR IN A, CALLING IT CURRENT BLOCK
	SUB T,BLK0(D)	;INCREMENTS D WHEN DONE
BKBFO2:	MOVE TT,T
	ADDB TT,OACESP'	;UPDATE OUTPUT .ACCESS POINTERS
	MOVEM TT,OBLK0+1(D)
	HRLOI T,-1(T)
	EQVI T,(A)
SBOUT:	.IOT UTYOC,T
	JUMPGE T,[AOJA D,CPOPJ]
	.VALUE		;????

ACCESO:	TLNE A,-1
	.VALUE		;GARBAGE IN LEFT HALF OF ACCESS POINTER
	.ACCESS UTYOC,A
	POPJ P,

		;DUMP OUT BK2 SUB-BLOCK IN BKBF

BKBFOT:	MOVEI D,2
	MOVEI A,HEADER
	LDB T,[CNTBP,,HEADER]	;GET COUNT
	AOJA T,BKBFO2

CPYBLK:	MOVE TT,T
	PUSHJ P,BGBLK
	MOVE T,TT
	JRST SBOUT

OBLK0:	BLOCK NWB0	;BLOCK 0 TO OUTPUT DURING COPY

	;;SYMTAB
	;"SYMBOL TABLE" MANIPULATION ROUTINES, WORK WITH STUFF LOADED

;EACH ENTRY IN SYMTAB ONE USER
	;WORD 0 UNAME
	;1 JNAME
	;2 .GT. 0 => TIME (.RDTIME) LOGGED IN (THIS SYSTEM), SETOM'D BY LOGOUT OR NEW SYSTEM
	;3 CONSOLE TIME USED, 4.9 => + UNKNOWN AMOUNT
	;4 RUN TIME USED, IN THIRTIETHS
	;5 # SWAPIN REQUESTS

WPS==6	;NUMBER OF WORDS PER ENTRY

NENTRY==<HIMEM-ICOR_10.>/WPS	;MAX # ENTRIES IN SYMTAB

RADIX 2
NCHKS==CONCAT .LENGTH /,\NENTRY-1,/	;NUMBER OF CHECKS WHEN SEARCHING TABLE
RADIX 8

		;PUSHJ P,DOWN	;MAKE ROOM FOR NEW ENTRY AT END OF SLOT POINTED
		;TO BY C AND D (AS SET UP BY LKUP), LEAVE C AND D POINTING
		;TO EXPANDED ENTRY IN THE SAME MANNER

DOWN:	SUBI C,WPS	;BACK UP C TO POINT TO NEW FIRST ENTRY
	MOVNI T,WPS
	ADDB T,STP	;NEW BEGINNING OF TABLE
	CAMGE T,MEMBOT	;BELOW BOTTOM OF CORE?
	JRST DOWN2	;NEED MORE CORE
DOWN3:	HRLI T,WPS(T)
	CAILE D,WPS(T)	;ENTRY AT BEGINNING OF TABLE?
	BLT T,-WPS-1(D)	;DOWN IT GOES
	MOVSI T,-WPS(D)
	HRRI T,-WPS+1(D)
	SETZM -WPS(D)
	BLT T,-1(D)	;CLEAR OUT NEW ENTRY
	POPJ P,

DOWN2:	PUSH P,C
	MOVEI C,MEMBOT
	PUSHJ P,DWNCOR
	POP P,C
	JRST DOWN3

		;PUSHJ P,LKUP
		;UNAME IN SYM, JNAME IN SYMJ
		;LOOK THEM UP IN SYMTAB
		;IF NOT FOUND THEN C AND D BOTH POINT TO SLOT WHERE THEY BELONG
		;IF FOUND, C POINTS TO FIRST ENTRY, D TO ENTRY AFTER LAST
		;SO DO CAMN C,D OR CAME C,D TO CHECK FOR FOUND

LKUP:	MOVE C,STE	;INITIALIZE POINTER TO END OF TABLE
REPEAT NCHKS,[FOO==WPS_<NCHKS-.RPCNT-1>	;DECREMENT TO TRY
	SUBI C,FOO	;TRY DECREMENTING POINTER
	CAML C,STP	;SKIP IF BELOW TABLE
	CAMLE SYM,(C)	;SKIP IF SYM .LE. UNAME IN TABLE, DON'T RE-INCREMENT
	ADDI C,FOO	;RE-INCREMENT
]		;AT THIS POINT, C POINTS TO BEG OF SLOT FOR THIS UNAME
LKUP2=.-1		;NOW SUB-SEARCH BY JNAME (LKUP2 IS JUMPED TO FROM BELOW)
LKUP3:	CAMGE C,STE	;SKIP IF END OF TABLE
	CAME SYM,(C)	;SKIP UNLESS UNAMES DIFFER
	JRST MOVDCJ	;END OF TABLE, OR UNAMES DIFFER, (EMPTY) SLOT FOUND
	CAMLE SYMJ,1(C)	;SKIP IF TABLE ENTRY BIG ENOUGH
	JRST LKUP2	;NOT YET, INCREMENT TO NEXT ENTRY AND TRY AGAIN
	MOVE D,C	;FOUND TABLE JNAME BIG ENOUGH, NOW FIND ONE TOO BIG
LKUP5:	CAMGE D,STE	;SKIP IF END OF TABLE
	CAME SYM,(D)	;SKIP UNLESS UNAMES DIFFER
	POPJ P,		;ALL DONE, D NOW POINTS TO ENTRY TOO BIG
	CAMGE SYMJ,1(D)	;SKIP UNLESS TABLE ENTRY TOO BIG
	POPJ P,		;D NOW POINTS TO NEXT HIGHER SLOT, AS ADVERTIZED
	ADDI D,WPS	;NOT YET, INCREMENT TO NEXT ENTRY
	JRST LKUP5	;TRY AGAIN

MOVDCJ:	MOVE D,C
	POPJ P,

	;DIAL-IN CONSOLE DOCUMENTATION ROUTINES
	;EACH DIAL-IN CONSOLE BELONGING TO THE AI LAB HAS BEEN ASSIGNED
	;A NAME, WHICH THE USER IS SUPPOSED TO TELL DDT WHEN LOGGING IN.
	;THE NAME IS KEPT IN SIXBIT.  THESE ROUTINES ARE TO KEEP TRACK
	;OF THE USAGE OF CONSOLES, IN SOME VAGUE HOPE THAT IT WILL
	;REALLY HELP.

	;INFORMATION IS KEPT IN A TABLE SORTED BY CONSOLE NAME.
	;CONTENT OF EACH ENTRY:

	;WRD 0 CONSOLE NAME
	;    1 UNAME OF USER
	;  2,3 .RLPDT LOGIN
	;  4,5 .RLPDT "LOGOUT"

DLSIZE==6	;NUMBER OF WORDS PER ENTRY

	;INFORMATION IS SUB-SORTED IN REVERSE CHRONOLOGICAL ORDER 
	;(WHERE "CHRONOLOGICAL ORDER" IS THE ORDER THE FILES ARE LOADED IN).
	;IF A USER OF A CONSOLE WAS ALSO THE LAST TO USE IT, THE
	;OLD ENTRY IS USED, WITH THE "LOGOUT" TIMES BEING UPDATED
	;ON LOGINS AFTER THE FIRST.

	;POINTERS INTO THE TABLE ARE AS FOLLOWS (SEE ALSO DWNCOR):

	;DLPA HAS ADR LOWEST ALLOCATED
	;DLP HAS ADR LOWEST IN USE
	;DLE HAS ADR FIRST ABOVE ALLOCATED

		;PUSHJ P,DLKUP
		;DIAL-IN CONSOLE NAME IN SYM
		;RETURN POINTER TO LOWEST ENTRY IN D
		;IF NO ENTRY, D SHOULD POINT TO FIRST ENTRY OF NEXT CONSOLE

DLNENT==<HIMEM-ICOR_10.>/DLSIZE	;MAXIMUM NUMBER OF ENTRIES
RADIX 2
DLNCKS==CONCAT .LENGTH /,\DLNENT-1,/	;NUMBER OF CHECKS WHEN SEARCHING TABLE
RADIX 8

DLKUP:	MOVE D,DLE	;INITIALIZE POINTER TO END OF TABLE
REPEAT DLNCKS,[FOO==DLSIZE_<DLNCKS-.RPCNT-1>	;DECREMENT TO TRY
	SUBI D,FOO	;TRY DECREMENTING POINTER
	CAML D,DLP	;SKIP IF BELOW TABLE
	CAMLE SYM,(D)	;SKIP IF SYM .LE. NAME IN TABLE, DON'T RE-INCREMENT
	ADDI D,FOO	;RE-INCREMENT
]	POPJ P,		;D NOW POINTS TO BEGINNING OF SLOT

		;DLCHK CALLED FROM LLOGIN FOR NEW LOGIN

DLCHK:	SKIPN B,LIDLIN	;GET CONSOLE ID
	POPJ P,		;NULL => THAT'S ALL
	EXCH B,SYM
	PUSHJ P,DLKUP	;LOOK IT UP, LEAVE POINTER IN D
	CAME D,DLE	;SKIP IF TOP OF TABLE (NOT FOUND)
	CAME SYM,(D)	;COMPARE CONSOLE NAMES
	JRST DLCHK2	;CONSOLE NOT FOUND
	CAME B,1(D)	;COMPARE UNAMES
	JRST DLCHK2	;CONSOLE FOUND, BUT CREATE NEW ENTRY ANYWAY
	ADDI D,4-1	;INCREMENT TO LOGOUT ENTRY
	JRST DLCHK4

DLCHK2:	SUBI D,DLSIZE	;BACK UP POINTER FOR NEW ENTRY
	MOVE T,DLP
	SUBI T,DLSIZE
	MOVEI C,DLPA
	CAMGE T,DLPA
	PUSHJ P,DWNCOR	;NEED MORE CORE
	MOVEM T,DLP
	HRLI T,DLSIZE(T)
	CAILE D,(T)	;SKIP IF BEGINNING OF TABLE
	BLT T,-1(D)	;MOVE THE OTHER STUFF DOWN
	MOVEM SYM,(D)	;STORE CONSOLE NAME
	INSIRP PUSH D,[B CURTIM CURYR]	;STORE UNAME, LOGIN TIME, LOGIN YEAR
DLCHK4:	INSIRP PUSH D,[CURTIM CURYR]	;STORE "LOGOUT" TIME AND YEAR
	MOVE SYM,B	;PUT UNAME BACK WHERE IT BELONGS
	POPJ P,

		;DIALIN COMMAND, PRINT THE CONSOLE USAGE WITHOUT THE REST OF THE ACCUSE STUFF

DIALIN:	MOVE A,DLP	;GET POINTER TO BEGINNING OF LIST
	CAMN A,DLE
	ERR [ASCIZ /NO DIAL-IN CONSOLES USED./]
	PUSHJ P,PRTOPN
	PUSHJ P,DLPRT
	JRST PRTCLS

		;PRINT STATUS OF CONSOLES

DLEPL==4	;NUMBER OF USAGE ENTRIES TO PRINT PER LINE

DLPRT:	MOVE E,DLP	;GET POINTER
DLPRT1:	CAML E,DLE
	POPJ P,		;ALL PRINTED
	MOVE SYM,(E)	;GET CONSOLE NAME
	AOJ SYM,	;INCREMENT IT; NOW WANT TO FIND END OF GROUP
	CAMN SYM,[SETZ]
	SKIPA D,DLE	;NAME IS ?_____, HIGHEST POSSIBLE
	PUSHJ P,DLKUP	;LOOK UP NAME+1, RETURN POINTER IN C
	SUBM D,E		;GET LENGTH OF TABLE TO PRINT
	EXCH D,E	;D GETS DIFFERENCE, E HIGH POINTER
	PUSH P,E	;SAVE HIGH POINTER FOR NEXT CONSOLE
	MOVNM E,DLPSV	;ALSO SAVE NEGATIVE OF HIGH POINTER IN CASE OF MULTI-PAGE PRINT
	MOVE T,D	;DON'T WANT .+1 TO CLOBBER E
	IDIVI T,DLSIZE	;GET NUMBER OF ENTRIES TO PRINT
	PUSH P,T	;TOP ENTRY OF PDL HAS NUMBER OF ENTRIES LEFT TO PRINT
	IDIVI T,DLEPL	;NOW TO DECIDE WHETHER TO BEGIN WITH FORM FEED
	JUMPG TT,.+2
	AOJA T,.+2	;ADD ONE FOR EXTRA BLANK LINE
	ADDI T,2	;ADD TWO, EXTRA BLANK LINE AND EXTRA INCOMPLETE LINE
	IDIVI T,LPP-1	;INTERESTED IN REMAINDER = NUMBER OF ENTRIES ON ODD PAGE
	ADD TT,LINENR	;WILL ODD PAGE FIT ON CURRENT PAGE?
	CAIL TT,LPP	;SKIP IF YES
DLPRT2:	PUSHJ P,PRTFF	;SKIP TO NEXT PAGE
	PUSHJ P,PCRLF	;BEGIN EACH PAGE WITH BLANK LINE
	MOVEI C,LPP
	SUB C,LINENR	;NUMBER OF LINES AVAILABLE THIS PAGE
	IMULI C,DLEPL	;NUMBER OF ENTRIES THERE'S ROOM FOR THIS PAGE
	CAML C,(P)
	JRST DLPRT3	;THIS WILL BE LAST PAGE
	MOVN T,C
	ADDM T,(P)	;UPDATE COUNT REMAINING
	PUSHJ P,DLPGPT	;NOT LAST
	JRST DLPRT2	;BACK FOR NEXT

DLPRT3:	POP P,C		;GET NUMBER OF ENTRIES ON THIS, THE LAST PAGE
	SKIPG C
	.VALUE		;ENTRY COUNT GOT DECREMENTED TOO FAR IN PAGE LOOP (BUG IF HERE)
	PUSHJ P,DLPGPT	;PRINT LAST PAGE
	POP P,E		;GET POINTER TO NEXT CONSOLE
	JRST DLPRT1	;BACK FOR NEXT CONSOLE

		;PRINT ONE PAGE OF CONSOLE USAGE ENTRIES FOR ONE CONSOLE

DLPGPT:	SUBI E,DLSIZE	;BACK UP TO BEGINNING OF TOP (EARLIEST) ENTRY
	MOVE B,(E)
	PUSHJ P,SIXPT	;PRINT CONSOLE NAME
	PUSHJ P,PTAB
	MOVE A,C	;GET NUMBER OF ENTRIES
	IMULI C,DLSIZE	;CONVERT TO LENGTH OF TABLE TO PRINT THIS PAGE
	ADDM C,DLPSV'	;UPDATE NEGATIVE OF POINTER TO NEXT PAGE
	JSP Q,PGPRT
DLPGPQ:	 DLEPL		;NUMBER OF ENTRIES PER LINE
	IMULI A,DLSIZE	;HERE ON PUSHJ FROM PGPRT
	PUSH P,A	;SAVE DECREMENT TO NEXT
	MOVE A,LINEPS
	ADDI A,26.	;CALCULATE TARGET LINE POSITION
	PUSH P,A	;SAVE IT (INITIAL LINE POSITION FOR NEXT IF ON THIS LINE)
	PUSHJ P,DLPRDT	;PRINT DATE, ADD 2 TO E
	MOVE B,-1(E)	;GET UNAME
	PUSHJ P,SIXPT
	PUSHJ P,PSPACE
	PUSHJ P,DLPRDT	;DATE AGAIN
	SUBI E,4	;BACK UP TO BEGINNING OF ENTRY AGAIN
	POP P,B		;LINE POSITION NEXT (IF ON THIS LINE)
	POP P,C		;AMOUNT OF DECREMENT TO NEXT
	SUB E,C		;DECREMENT TO NEXT
	MOVEI Q,DLPGPQ	;RESTORE Q, CLOBBERED BY NUMBER PRINTING ROUTINES
	JUMPG C,ALIGN	;JUMP IF NEXT ON SAME LINE, SPACE TO THERE
	PUSHJ P,PCRLF	;LAST ENTRY ON LINE
	JUMPL C,PTAB	;JUMP UNLESS THIS WAS LAST ENTRY ON PAGE
	MOVN E,DLPSV	;SET POINTER TO BEGINNING OF NEXT PAGE
	POPJ P,

		;PRINT DATE FOR DLPGPT

DLPRDT:	ADDI E,2	;INCREMENT POINTER
	SKIPGE A,(E)	;GET DATE AND TIME
	JRST DLPRD2	;UNKNOWN
	IDIVI A,SPD
	PUSHJ P,GDAM	;GET DAY AND MONTH IN C AND A
	PUSHJ P,PNRSL	;PRINT MONTH AND SLASH
	MOVE A,C
	PUSHJ P,PNRSL	;DAY AND SLASH
	HRRZ A,1(E)	;YEAR (WITHOUT FLAGS)
	IDIVI A,100.	;INTERESTED IN LAST 2 DIGITS
	PUSHJ P,PDPTB	;YEAR
	JRST PSPACE	;END WITH SPACE

DLPRD2:	MOVEI B,[ASCIZ "?/??/?? "]
	JRST APRT	;INDICATE DATE UNKNOWN

IFNDEF LPDL,LPDL==40
PDL:	BLOCK LPDL
PATCH:
PAT:	BLOCK 40
PATCHE=.-1

	CONSTA
	VARIAB

IFG .-ICOR_10.,PRINTA [ICOR TOO SMALL, SHOULD BE ]\<.+1777>_-10., .

END BEG
