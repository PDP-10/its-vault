
TITLE DDT

.SYMTAB 4005.

.MLLIT=1	;MULTI-LINE MODE.
NLEVS==7	;LENGTH OF RING BUFFER OF .
LWTLNG==8	;LENGTH OF RING OF $Q
NINFP==8	;MAX NUM INF PROCEDURES
NBP==10		;NUMBER OF BREAK POINTS
SNLLEN==10	;NUMBER OF FILE DIRECTORIES TO REMEMBER
LPDL==200	;MAX LENGTH PUSH DOWN LIST
FTBLNG==60.	;FROB TABLE LENGTH (MUST BE EVEN)
GSCLNG==20.	;$Q*5= MAX # CHARS / FROB.
FDRCL==20	;LENGTH OF FDRC BUFFER.
NARGS==3	;# ARGS OPERATOR CAN HAVE.
4BLKNM==10	;NUM. 4-WD LIST ELEMENTS.
UNDFRS==4	;2* MAX # UNDEF REFS IN EXPRESSION.

VPAGE==200

F=0	;FLAGS
P=1	;PUSH DOWN
A=2	;POINTERS TO TABLES, CORE, ETC.
B=3
C=4	;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
D=5	;TRANSFER DATA
W1=6
W2=7
U=10	;DDT'S USER INDEX FOR CURRENT INF PROCEDURE
W3=11
I1=12
I2=13
I3=14
I4=15
W4=16	;ALWAYS POINTS TO TOP OF FROB STACK.

.XCREF A,B,C,D,P,U

CALL=PUSHJ P,
RET=POPJ P,
SAVE=PUSH P,
REST=POP P,

;LEFT HALF FLAGS

QF==1	;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40	;$  TYPED
LTF==20	;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10	;REGISTER OPEN FLAG
NNULFL==1	;NOT NULL
PNTFL==2	;POINT
NEGEFL==4	;NEGATIVE
NROFL==10	;REGISTER OPEN
LETFL==20	;LETTER
UNRDFL==100	;SET => RE-READ 1 CHAR IN RCH.
RUBFL==200	;RUB OUT
CTLLFL==1000	;SET IF RE-READING CHARS FOR ^L.
DEVFL==2000	;SET IF FILENAME READER READING ONLY DEV & SNAME.
STF==4000	;$$! MODE


;TS SYMBOLS

TYIC==1
TYOC==2
USRI==3
USRO==4
UTIC==5
UTOC==6
LPTC==7
FDRC==10
COMC==11
ERRC==12

ERLOSS=30000,,	;INTERNAL ERROR, TYPE VARIOUS LOCATIONS AND @EFFECTIVE ADDRESS.
7NRTYP=31000,,	;7TYPE THEN GSNLRT
ERSTRT=32000,,	;STRING RETURN ERROR MESSAGE
7TYPE=33000,,
CTYPE=34000,,	;TYPE EFF ADR AS CHAR
STRT=35000,,
OPNER=36000,,
TERR=37000,,

MINUUO==30

DEFINE TSOPEN A,B
IFSN A,FDRC,	.OPEN A,B
IFSE A,FDRC,[	PUSHJ P,FDRCOP
	B]
	OPNER B
	TERMIN

DEFINE TSCALL A
	.CALL A
	ERLOSS
	TERMIN

SYSGE==2
SNFUSER==60	;FOREIGN USER SYSTEM DEVICE CODE

OIPBIT==400     ;ONE INSTRUCTION PROCEED PC BIT

ILOPRB==40	;ILLEGAL OPERATION
SYSDDB==100	;SYSTEM DEAD
VALBIT==200	;VALRET "
BIOC==400	;IO CHANNEL ERROR
ILUADB==1000	;ILL USER ADDRESS
BRKBIT==2000	;BREAK BIT IN PIRQC
OIPINT==4000    ;ONE INSTRUCTION PROCEED INTERRUPT BIT
MPV==20000	;MEMORY PROTECT VIOLATION
BCLI==400000	;CLI BIT IN PIRQC
SYSDBB==2,,	;SYSTEM BEING DEBUGGED
PUR==200,,	;ATTEMPTED WRITE INTO PURE PAGE
ALARMB==200000,,	;REALT ALARM INT

DEFINE INFORM A,B
IF1,[PRINTX \A = B
\]TERMIN

DEFINE STDCAL A,B
.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
	ERLOSS
TERMIN

DEFINE STDCL A,B
.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

;RIGHT HALF FLAGS
OUTPUT==4	;OPDECODER FLAGS

NAF==200	;NEGATIVE ADDRESSES PERMISSABLE
BPLF==2		;BPLOC REF AS ADDR
PRINTF==2	;PRINT FLAG

;FLAGS IN SQUOZE SYMBOL.
GLOBAL==040000	;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000	;IF THESE BITS ARE 0, PROGRAM NAME
DELI==200000	;DELETE INPUT
DELO==400000	;DELETE OUTPUT

;ERROR COMMENTS

;TMJ=TOO MANY JOBS
;INT=RIGHT HALF INTERUPT
;CKS=CHECK SUM ERROR
;BIN=IOC ENCOUNTERED ON LOAD
;CFT=CAN'T FLUSH TTY
;JOB=NO CURRENT JOB
;UNF=UNFLAPPABLE (UDISMOUNT FAILED)
;DSN=DISOWN LOST
;LOGIN=YOU ARE NOT LOGGED IN
;PUR=TRIED TO WRITE IN READ ONLY CORE


LOC 41
	JSR UUOH
	JSR TSINT
	STBDDT	;FOR ^Y WHEN DON'T HAVE SYMS, DO @43$$/ ^Y
;DDT'S USER VARIABLES, USUALLY INDEX OF U.
USRS:
UFUSR:	(SIXBIT /USR/)
UUNAME:	0
UJNAME:	0
INTBIT:	0	;USER INTERRUPT BIT, OR 0 IFF FOREIGN USER.
UINT:	0	;#0 => JOB INT'D DDT, IS WAITING TO RETURN.
UPIRQ:	0	;.PIRQC BITS THAT MADE JOB INT. DDT.
PPC:	0	;PROGRAM COUNTER
XECPC:	0	;PC SAVE ON $X
UINTWD:	0	;-1=>STOP ON RANDOM INT
		;0=> RUNNING
		;17,16 => $X RETURN
		;N<9  => BPT
		;21 => LOADED, NOT YET STARTED
XINTWD:	0	;SAVE UINTWD ON $X
JTIME:	0	;SEE FNJOB
UIND:	0	;SYSTEM INDEX
NBPTB:	0	;-1 ON CONDITIONAL BPT BREAK 0 NORMAL
BPCPC:	0	;PC SAVE ON CONDITIONAL BPT
CBPPS:	0	;RH UINT (SAVE BPT #) LH EFFECTIVE ADDRESS OF INSTRUCTION FOR PROCEED
INCNT:	0	;COUNT FOR LIMITED PROCEED
OIPCHK:	0	;$$^N STOP ADDRESS
USCNT:	0	;# TIMES TO MULTI-STEP, NEG => FOREVER.
USTYPE:	0	;TYPE OF MULTI-STEPPING TO DO IN THIS JOB (BITS USTYPB - USTYPZ)
BTADR:	0	;ADDR OF TEMP. BPT. PAIR (0 => NONE). LH < 20 => IT IS ADDR OF PDL
BTPDL:	0	;IF LH OF BTADR <20, THIS IS CONTENTS TO LOOK FOR IN PDL.
BTINS:	0 ? 0	;THESE HOLD INSNS REPLACED BY THE TEMP BPTS.
BPINFL:	0	;4.9 - BPTS INSERTED, 1.N - AUTO-PROC BPT N.
B1ADR:	0	;ADDRESS OF BPT(RH) LOC TO PRINT OUT (LH)
BPCON:	0	;CONDITIONAL BPT INSTRUCTION
B1CNT:	0	;PROCEED COUNT
B1INS:	0	;INSTRUCTION REPLACED BY .BREAK
BPL==B1INS-B1ADR+1
	BLOCK <NBP-1>*BPL
BPEND:
STARTA:	0	;0, OR JRST TO START ADDR.
PERMIT:	0	;-1 => CAN EXECUTE VALRET STRINGS
PATCHL:	0	;IF PATCHING, PATCHED-FROM,,PATCH-AREA, ELSE 0.
UFNAMD:	0	;LOADED FILE'S DEV, ETC.
UFNAM1:	0
UFNAM2:	0
UFNAMS:	0
UFILE:	0	;$L, $Y, ETC. FILE.
UFILE1:	0
UFILE2:	0
UFLSYS:	0	;SET IF DEV. SHOULD BE CLOBBERED TO DSK BY $Y.
UFILES:	0
UHACK:	0	;.BREAK 12, HACKS
UIACK:	0	;.BREAK 16, HACKS
UCHBUF:	0	;AOBJN -> COMMAND (:JCL) BUFFER. (IN SYM TAB SPACE)
UNDEFL:	0	;AOBJN -> LIST OF UNDEF SYM ENTRIES (IN SYMTAB SPACE)
PRGM:	0	;SYMTAB TAIL -> HEADER OF CURRENT BLOCK.
JOBSYM:	0	;LEAVE JOBSYM LAST
USRLNG==.-USRS

REPEAT NINFP-1,[
	(SIXBIT /USR/)
	BLOCK USRLNG-1]

USREND=<NINFP-1>*USRLNG	;LARGEST USR-IDX ALLOWED IN U.
L==USRLNG		;LIKE ITS
INFORM [STORAGE PER LOSER]\USRLNG
UUOH:	0
	MOVEM P,UUOPDP	;SAVE IT FOR ERLOSS UUO.
	PUSH P,A
	PUSH P,D
		NUUOPH==2	;NUM PUSHES AT UUOH
	LDB D,[331100,,40]
	CAIGE D,40
	CAIGE D,MINUUO
	CAIA		;SKIP IF INVALID UUO.
	JRST UUOH1
	SKIPE DEBUGP	;IN DEBUG MODE, STOP BEFORE CLOBBERING JPC.
	.VALUE
	MOVEI D,40
UUOH1:	SKIPL UUOTAB-MINUUO(D)
	JRST @UUOTAB-MINUUO(D)
UUOH2:	PUSHJ P,ERTTY	;SAVE TTYFLG IF NOT ALREADY SAVED
	JRST @UUOTAB-MINUUO(D)

UERFLN:	SIXBIT /   ERR/
	2
UERFLC:	.

;USED BY OP-CODE CONVERSION RTNS.
PNTR:	INST
CHP:	0
TXT:	BLOCK 2

SAVPDL:	0
BTAB:	FOO=44
REPEAT 4,[(FOO_12.+1100)TBL
	FOO=FOO-11
]

;USED IN --MORE-- PROCESSING.
MORPOS:	24.	;LINE ON SCREEN TO TYPE --MORE--
TYOLSZ:	0	;LINE SIZE.
TYOEOP:	0	;-1 IF AT END OF PAGE.
TYOLNP:	0	;LINE-NUMBER ON SCREEN.
TYOCHP:	0	;POSITION IN LINE.
TYOTCR:	0	;-1 => TYPE CR BEFORE THIS CHARACTER.
MORFLG:	0	;-1=> READ FROM TTY ONLY DESPITE INPTR
MORNFF:	0	;-1 => DON'T CLEAR SCREEN AFTER NEXT --MORE--.
MORNRO:	0	;-1 => RUBOUT WON'T FLUSH AFTER NEXT --MORE--.
MORRET:	0	;PC AT CALL TO MORINI.
MORPRP:	0	;0 IF NO --MORE-- PROC., ELSE P AT CALL TO MORINI.

;LOW-LEVEL INPUT PROC. VARS.
INNCTL:	0	;-1 => IGNORE ^B, ETC. IN FILES & VALRETS.
INPDL:	0	;0, OR -> HEAD OF INPUT SOURCE PDL.
INPTR:	0	;0 => INPUT FROM TTY.
		;<0 => INPUT FROM COMC.
		;>0 => IT IS B.P. TO VALRET STRING, INVAOB IS AOBJN -> WHOLE STRING.
LIMBO:	0	;MOST RECENTLY READ CHARACTER.
INVAOB:	0	;IF INPTR POSITIVE, THIS IS AOBJN -> VALRET STRING.
UNRCHF:	0	;-1 => RE-READ LIMBO.
UNECHF:	0	;IF UNRCHF -1, THIS -1 => RE-ECHO IT, TOO.

INIOPS:	0	;-1 => A CMD FILE HAS BEEN INPUSHED BUT NOT .IOPUSHED.

MSNAM:	0	;SYSTEM NAME FOR NEW JOBS
LSNAM:	0	;DDT'S SUPPOSED SNAME.
SRFLAG:	0	;-1 SAYS RETSTORE REAL SNAME FROM LSNAM.
SFDIR:	-1	;0 => SEARCH SNAME LIST FOR $L, ^K.
INSNAM:	0	;POINTER TO LIST BELOW (TEMP)
SNLIST:	0	;FLOCK PUTS SNAME ACTUALLY FOUND ON IN HERE.
	BLOCK SNLLEN
SNLIS1:	BLOCK SNLLEN+2

MSK:	-1	;MASK FOR $E, $W, $N .
UNPURF:	-1	;NONZERO => AUTOMATIC UNPURIFY ON DEPOSIT IN INFERIOR.
MSTYPE:	USTYPU+USTYPB+USTYPP
		;DEFAULT USTYPE VAR. FOR NEWLY CREATED JOBS.
DOZTIM:	1	;# SECONDS TO WAIT EACH MULTI-STEP IF USTYPZ SET.
TOKTRM:	0	;TOKEN ENDED WITH ^M OR ^J.

IFILE:	SIXBIT/   DSK@     BIN/
	0?0		;ALTERNATE DEFAULT FOR $L.

CU:	-1	;CURRENT JOB'S IDX, OR -1 IF NO CURRENT JOB.
NJ1:	@	;COUNT USED FOR DETERMINING MOST RECENT JOB (SEE FNJOB)
NJ2:	@	;COUNT USED FOR DETERMINING LEAST RECENT JOB (")
UCHNLO:	0	;0 => NO USER OPEN, OR THIS JOB IS SYS.
		;+ => FOREIGN USER (INCLUDING SELF).
		;-1 => INFERIOR
SYSSW:	0	;SET IF JOB IS SYS.
DDTSW:	0	;SET IF THIS JOB IS SELF.
SYSDPS:	0
UNAME:	0	;UNAME, JNAME OF JOB TO OPEN.
JNAME:	0
SYSSTB:	0	;SET IF HAVE SYS SYM TAB ABS PGS.
DEBUGP:	-1	;SET IF DEBUGGING DDT.
RUNFLG:	0	;-1 => DDT HAS BEEN RUN.

$X=34

ALARMV:	0	;ALARM STATUS

IOCX:	.STATUS I4	;AC FIELD WRITTEN AT IOCBRK

PS:	BLOCK LPDL+30	;PDL	;LEAVE ROOM FOR PDL OV RTNS AND HAKKAH.
AC0:	BLOCK 20	;JOB'S ACS PUT HERE FOR ADDRESS CALC. ETC.

;INTERRUPT HANDLER

TSINT:	0
	0
	JRST TSIN0

INTACS:	BLOCK 16.

;:MSGS STUFF
MSGDAT:	0	;DATE S.T. EARLIER MSGS AREN'T TYPED.
MSGLDT:	0	;BEFORE 1ST FILE, -1; ELSE DATE OF LAST FILE STARTED.
MSGFDT:	0
MSGDFL:	0
MSGLOG:	0	;SET AT ENTRY TO AUTOMATIC :MSGS AT LOGIN.
MSGF1:	SIXBIT/  "DSK_MSGS_/
	0		;UNAME PUT HERE BY :MSGS .
MSGF3:	SIXBIT/  "DSK/
	0?0
MSGSNM:	SIXBIT /.MSGS./	;F.D. TO LOOK IN

26SAV:	0	;COND B.P.
	.BREAK 16,110000
	.BREAK 16,310000
31SAV:	0
	JRST
	JRST
34SAV:	0	;$X
	.BREAK 16,500000
	.BREAK 16,700000

INST:	0
TEM:	0
TEM1:	0

N2ACCS:	0	;LAST SYMBOL TYPED BY SPT SAVED HERE FOR $$^C.
SPTS:	JRST TOUT
SATPP:	.+1	;3 WDS USED BY $T MODE OUTPUT
SATPT:	0
SATPC:	0

	0	;THIS HERE TO INVESTIGATE CLOBBERAGE OF AR TO 0.
;CURRENT MODE
SCH:	0	;HLTW,TFLOT,SATP,ITEXO,PIN,FTOC
AR:	0
ODF:	0

SCHM:	 PIN	;PERMANENT MODE
ARM:	 PADR
ODFM:	 10

SCHMM:	TFLOT	;MODE TO RETYP IN
ARMM:	PADR
ODFMM:	10

SARS:	-1	;0 => DDT SLEEPING -1 => DDT RUNNING
DDTTY:	-1	;-1 =>TTY IN DDT
TTYSTL:	0	;-1 => HAVE TTY BUT IT'S STOLEN, SHOULD GIVE IT BACK SOON.
TTYUSR:	0	;USER INDEX GAVE TTY TO LAST
RSTDEL:	0	;DELETE .RESET OF TYI
TEM3:	0
XCRFSW:	0	;-1 => DON'T TYPE CRLF WHEN PROCEDING

HIGH:	0
TOCTEM:	0	;HOLDS RADIX DURING TOC.

CLUFNB:	(SIXBIT /USR/)
CLUFN1:	.
	SIXBIT /HACTRN/

NCTLTA:	0	;ARG TO ^T, ^U PUT HERE.
NCTLTF:	BLOCK 9	;USED FOR FILENAMES BY ^T, ^U.

ERROPN:	2,,(SIXBIT /ERR/)
	3
	0	;STATUS WORD

HOLPPX:	POP D,.(D)	;USED BY HOLE

NLTNWX:	JUMPE\JUMPN I1,NALTN5

NCOMNM:	0	;0, OR NAME OF :-CMD NOW IN PROGRESS.
XRWI:	0	;-1 => SKIP AND RETURN ON MPV, 
	  ;UNPURIFY ON PUR (ONLY IF UNPURF SET), ASSUMES ADDR IN A.


		;THE FOLLOWING MUST BE CONTIGUOUS (THEY ARE BLT'ED ONTO THE PDL)
FDRCTB:	BLOCK FDRCL+1
FDRCIP:	0	;INPUT POINTER
FDRCEP:	350700,,	;END POINTER

UUOPDP:	0	;P SAVED BY UUOH FOR ERLOSS UUO.

TQUITR:	0	;0 OR P AT ENTRY TO NON-QUITTING ROUTINE.

ERRSTP:	0	;RESTORE P ON ERROR UUOS (EXCEPT ^D, ^G, ERLOSS)
ERRSTL:	0	;RESTORE PC.

VPAGCT:	-1	;>= 0 => HAVE FRESH PAGE AT VPAGE.

VPATCH:

INFORM [TOP OF LOW IMPURE]\.-1

.=<.+1777>/2000*2000	;TO PAGE BNDRY
	BLOCK 20*2000		;SYS SYM TAB ABS PGS GO HERE.
SYSSYM==.-2000
SYSAOB==.-2	;DDT-2, AOBJN -> SYS SYM TAB (IN SYS ADDRESS SPACE)

	BLOCK 10*2000	;DDT SYM TAB GOES HERE IN PURE PGS.
STBDE:

STBSPG==./2000	;# OF 1ST OF 2 PAGES FOR USYMS AND CALLS.
	BLOCK 4000

MINPUR==<.+1777>/2000
DDT:	SKIPE RUNFLG
	 JRST DD1B	;NOT FIRST START.
	SETOM RUNFLG	;FIRST, INITIALIZE.
	JRST DDT2

DDTUNM:	MOVE C,UNAME	;INIT. SOME NAMES TO THE UNAME.
	MOVEM C,RUNAME
	MOVEM C,RUNM1
	MOVEM C,RUNM2
DDTMSN:	MOVEM C,MSNAM
IRPS X,,PFILE XFILEF WFILE IFILE
	MOVEM C,X+4
TERMIN
	MOVEM C,LSNAM
	AOSN B,C	;IF NOT ______,
	POPJ P,
	SOJA B,NFDIR1	;PUT IN SNAME SEARCHG LIST.

SSTATB:	SETZ
	SIXBIT /SSTATU/
	2000,,D	;DIETIM
	2000,,A	;SYSDBG
	2000,,TEM	;SUSRS
	2000,,TEM2	;MEM ERRS
	2000,,TEM3	;TIME
	SETZM ITSNAM	;SIXBIT OF AI OR ML.

DDTDBM:	ASCIZ /
ITS BEING DEBUGGED!/

DDTGDM:	7TYPE [ASCIZ /
ITS GOING DOWN IN /]
	IDIVI D,30.
	PUSHJ P,TMPT
	PUSHJ P,FDRCOP
	[SIXBIT /  "SYSDOWN  MAIL/]
	POPJ P,
	PUSHJ P,CRF
	JRST CTLF1

SSTATU:	PUSH P,[NLTL2]
SSTAT1:	TSCALL SSTATB
	SKIPE A
	7TYPE DDTDBM
	JUMPL D,SSTAT2	;NEGATIVE=>FOREVER
	PUSHJ P,DDTGDM
SSTAT2:	PUSHJ P,CRF
	MOVE A,TEM
	MOVE D,RUNAME4
	AOSN D
	AOS A	;YOU'RE NOT LOGGED BUT SHOULD COUNT
	PUSHJ P,G9PNT
	7TYPE [ASCIZ / USERS/]
	SKIPN A,TEM2
	POPJ P,
	TLC A,232000
	FADR A,A
	MOVE D,TEM3
	TLC D,232000
	FADR D,D
	FDVR D,[108000.0]	;GET NUM HOURS SYS UP
	FDVR A,D
	7TYPE [ASCIZ /
MEM ERRS /]
	PUSHJ P,NFLOT
	7TYPE [ASCIZ */HOUR*]
	POPJ P,

VERSIO:	PUSHJ P,CRF
	PUSH P,[NLTL2]
VERSI1:	TSCALL SSTATB	;GET NAME OF SYSTEM (AI OR ML)
	MOVE D,ITSNAM
	PUSHJ P,SIXTYP	;PRINT IT.
	STRT [SIXBIT / ITS./]
	.RSYSI D,
	PUSHJ P,SIXTYP
	7TYPE [ASCIZ /. DDT./]
	MOVE D,[.FNAM2]
	PUSHJ P,SIXTYP
	CTYPE ".
	POPJ P,
; COLON-COMMAND TABLE; ENTRIES LOOK LIKE
;	SIXBIT/COMMAND/
;	[ASCIZ/DESCRIPTION/],,ROUTINE

DEFINE NCTABE A,B,C/
	SIXBIT/A/
	IFSN [C],[[ASCIZ/C/]],,B+IFB B,A
TERMIN

DEFINE NCTABK A,C/
	SIXBIT/A/
	IFSN [C],[[ASCIZ/C/]],,K!A
TERMIN

NCTAB:	NCTABE ALARM,,ALARM CLOCK. FOLLOW BY TIME AS HH:MM
	NCTABK ATTACH,MAKE CURRENT JOB REPLACE HACTRN.
	NCTABE BUG,,FOLLOW BY PROGRAM NAME, DOCUMENT BUG
	NCTABE BUGA,,ADD TO PREVIOUS :BUG NOTE
	NCTABE CLEAR,,CLEAR1,CLEAR SCREEN.
	NCTABE CONTIN,NALTP,CONTINUE GIVING JOB TTY[$P]
	NCTABK COPY,COPY FILE1 AS FILE2.
	NCTABK DDTSYM,RETURN VALUE OF SYM IN DDT SYM TAB.
	NCTABE DELETE,,DELETE FILE[]
	NCTABE DETACH,,DETACH YOUR TREE FROM YOUR TTY.
	NCTABE DISOWN,,DISOWN CURRENT JOB[$$^K]
	NCTABE DUMP,,DUMP FROM JOB[$Y]
	NCTABE ERR,ERRSTS,IOC ERROR STATUS
	NCTABK EXISTS,ZERO IFF FILE EXISTS
	NCTABE FLAP,FFLAP,FLAP DECTAPE[$$^F]
	NCTABE GAG,,CONTROL RECEIPT OF SENDS
	NCTABE GO,AAGO,START INFERIOR[$G]
	NCTABE GZP,,ALT G, CTL Z, CTL P
	NCTABE HELP,NHELP,BASIC INFORMATION
	NCTABK IF,CONDITIONAL.
	NCTABE INFLS,,FLUSH PUSHED INPUT SOURCES.
	NCTABE INPOP,INPOP1,POP OUT OF CURRENT INPUT SOURCE.
	NCTABE INPUSH,INPUS1,INPUT FROM TTY WITHIN VALRET OR XFILE.
	NCTABK INTEST,EXECUTE INIT FILE, ETC.
	NCTABE JCL,JJCL,SET JOB COMMAND STRING
	NCTABE JOB,JJOB,CREATE OR SELECT JOB[$J]
	NCTABE KILL,KILL,KILL CURRENT JOB[$.]
	NCTABE LFILE,,LIST FILE LOADED
	NCTABE LINK,,CREATE LINK
	NCTABE LISTB,,LIST BREAKPOINTS.
	NCTABE LISTF,,LIST FILES[^F]
	NCTABE LISTJ,ULIST,LIST JOBS[$$V]
	NCTABE LISTP,KLSTP,LIST RELOCATABLE PROGRAMS
	NCTABE LISTU,,LIST UNDEF SYM REFS.
	NCTABE LOAD,,LOAD FROM FOLLOWING FILE[$L]
	NCTABE LOGIN,NLOGIN,LOGIN AS FOLLOWING NAME[$U]
	NCTABE LOGOUT,,AUTO-EXPUNGE[$$U]
	NCTABE MAIL,,MAIL A NOTE TO A USER.
	NCTABE MAILA,,ADD TO PREVIOUS MAIL.
	NCTABE MORE,,GIVE USER A CHANCE TO FLUSH
	NCTABE MSG,,FOLLOW BY SUBJECT, WRITES MSGS FILE
	NCTABE MSGS,,PRINTS MESSAGES SINCE LAST GIVEN
	NCTABE NFDIR,,ADD FILE DIRECTORES TO SEARCH LIST
	NCTABE OFDIR,,REMOVE LIST OF FILE DIRECTORIES
	NCTABE PDUMP,,PURE DUMP
	NCTABK PRGM,PRINT CURRENT BLOCK NAME & LEVEL
	NCTABE PRINT,,PRINT FILE
	NCTABE PRMAIL,,PRINT MAIL
	NCTABE PROCED,NCTLP,PROCEDE JOB, LEAVE TTY WITH DDT[^P]
	NCTABE RENAME,,RENAME 1ST FILE AS 2ND
	NCTABE SEND,,SEND MESSAGE
	NCTABE SFDATE,,SET FILE'S DATE
	NCTABE SL,CSMI
	NCTABE SLEEP,,SLEEP N 30'THS OF A SECOND
	NCTABE SLIST,,LIST SYMBOLS
	NCTABE SSTATU,,TYPE SYSTEM STATUS
	NCTABE START,AAGO,START INFERIOR[$G]
	NCTABE SYMLOD,CSMI,LOAD, SYMBOLS ONLY
	NCTABE SYMADD,,ADD SYMS FROM FILE TO SYM. TAB.
	NCTABK SYMTYP,FOLLOW BY SYM, IS 0 IF UNDEF, <0 IF HALF-KILLED, ELSE >0.
	NCTABE TPL,,QUEUE REQUEST TO LIST FILE ON LPT.
	NCTABE UNPURE,,UNPURIFY PAGE CONTAINING SPEC'D ADDR.
	NCTABK V,LIKE ^V BUT NOT INSTANTANEOUS
	NCTABE VERSIO,,TYPES VERSION #'S
	NCTABK VK,:V, THEN GOES KERCHINK
	NCTABK VP,SAME AS $P^V
	NCTABK WALBEG,OPEN WALLPAPER FILE (ALL INPUT & OUTPUT GOES IN IT)
	NCTABK WALEND,CLOSE WALLPAPER FILE
	NCTABE WALLP,,SAME AS WALBEG
	NCTABE XFILE,,EXECUTE FILE AS DDT COMMANDS
	NCTABE ?,QSN,LIST MOST : COMMANDS
NLCOM==.-NCTAB
RRRFLA:	PUSHJ P,GSOT	;TYPE " ", INIT RUB. PROC.

;CALL THESE ONLY AFTER CALLING GSOA, UNLESS IN A COLON-CMD.
;SET GSONUM IFF SHOULDN'T RE-READ PREVIOUS CHAR.
;SET GSDNUM IFF SHOULD CLOBBER ^K-DEFAULTED SYS: TO DSK:
;GSENUM USED AS A FILENAME COUNTER.
;GSFNUM SET WHEN DEVICE IS SPEC'D, TO PREVENT CLOBBERAGE TO DSK BY ";".
;FLAG DEVFL SET IF READING DEV & SNAME ONLY (FOR :LISTF)

RRFLB:	MOVEI C,UFILE(U)	;USE $L FILENAME.
	JUMPL U,QJERR
RRFL1:	TLZA F,DEVFL
RRFL4:	TLO F,DEVFL	;JUST READ IN DEV & SNAME.
	PUSH P,B	;FILENAME ADDRESS IN C.
	PUSHJ P,RFL9
	PUSHJ P,CRF
	CAIN C,NCTLTF	;DON'T SET ^F DIR IN ^T, ^U.
	JRST POPBJ
	MOVE A,(C)
	HRRM A,FFILE	;SET ^F DEV.
	SKIPN A,4(C)	;IF GAVE SNAME, SET DDT'S.
	MOVE A,LSNAM	;ELSE SET SNAME FROM DDT'S.
	MOVEM A,LSNAM
	MOVEM A,4(C)
	.SUSET [.SSNAM,,A]
	CAIA
RRFL3:	PUSH P,B
	MOVSI B,-SNLLEN	;ADD SNAME TO SNLIS1.
	MOVE D,A
RRFL2:	EXCH A,SNLIS1+1(B)
	CAME A,D	;FLUSH EXISTING OCCURRENCE.
	AOBJN B,RRFL2
POPBJ:	POP P,B
	POPJ P,

RFL9:	PUSH P,C
	MOVE A,GSCHRP
	SKIPN GSONUM	;UNLESS CALLER SAID SHOULDN'T,
	CAMN A,[010700,,GSCHRS-1]
	JRST RFL0	;OR NO CHARS READ YET,
	TLO F,UNRDFL	;RE-READ PREV. CHAR. IN CASE $ OR CR.

;DROPS THROUGH.
;DROPS THROUGH.
;READ IN A LINE AND PROCESS IT.
RFL0:	MOVEI B,RFLFN1-1	;SAVE DEFAULT FN1, FN2 FOR ^X, ^Y.
	PUSH B,1(C)
	PUSH B,2(C)
	SETZM GSFNUM	;DEVICE HASN'T BEEN SPEC'D.
	SETZM GSENUM	;NEXT NAME WILL BE FN1.
	MOVE B,GSDNUM
	PUSHJ P,RLINEX	;READ UP TO CR OR ALTMD.
	JUMPE B,RFL1	;IF SHOULD CLOBBER SYS: TO DSK:,
	MOVEI B,'DSK
	SKIPE UFLSYS(U)	;IF SYS: WAS SET BY ^K,
	HRRM B,UFILE(U)	;DO IT.
	SETZM UFLSYS(U)	;CURRENT DEV WASN'T SET BY ^K.
RFL1:	PUSHJ P,RTOKEN	;READ 1 NAME.
	MOVE C,(P)
	PUSHJ P,RFLTN1	;EVERYTHING ELSE STORES PRECEDING NAME NORMALLY.
	CAIE D,^Y
	CAIN D,^X	;^X, ^Y THEN STORE ONE OF THE DEFAULT NAMES.
	JRST RFLCTX
	CAIE D,",
	CAIN D,^M	;THESE END ENTIRE SPEC.
	JRST POPCJ
	CAIN D,33	;ALTMODE - TYPE FILE SPEC'D, ASK FOR MORE.
	JRST RFLALT
	JRST RFL1	;ELSE JUST GET ANOTHER NAME.

;HANDLE THE NAME IN B
RFLTN1:	CAIN D,":
	 JRST RFLNC	;TERMINATED BY : => IT IS DEV NAME.
	CAIN D,";
	 JRST RFLNSC	;BY ; => IT IS SNAME.
RFLTND:	JUMPE B,CPOPJ	;DO NOTHING WITH NULL NAME.
	AOS A,GSENUM	;ELSE STORE ITAS NEXT NAME IN NORMAL SEQUENCE.
	TLNE F,DEVFL	;(BUT IF WE'RE JUST READING A DEV AND SNAME,
	 JRST RFLNSC	;STORE IT AS THE SNAME)
RFLSND:	JUMPE B,CPOPJ	;STORE A NAME AT A SPECIAL PLACE.
	XCT RFLTAB-1(A)	;THE PLACE IDX SHOULD BE IN D.
	CAIE C,UFILE(U)	;IF STOREING INTO $L DEFAULT,
	POPJ P,		;(NOTE RFLTAB MAY SKIP TO HERE)
	MOVEI C,IFILE
	XCT RFLTAB-1(A)	;STORE INTO ALTERNATE ALSO.
	MOVEI C,UFILE(U)
	POPJ P,

RFLTAB:	MOVEM B,1(C)
	MOVEM B,2(C)
	PUSHJ P,[HLRM B,(C) ? SETOM GSFNUM ? SETZM 3(C) ? POPJ P,]
	MOVEM B,4(C)
	SOSA B,GSENUM

RFLCTX:	MOVE B,RFLFN1-^X(D)	;GET DEFAULT FN1 OR FN2.
	PUSHJ P,RFLTND	;STORE IT IN NORMAL SEQUENCE.
	JRST RFL1

;SET THE SNAME, MAYBE DEFAULT DEV. TO DSK.
RFLNSC:	MOVEI A,4	;TELL RFLSND TO STORE SNAME.
	PUSHJ P,RFLSND
	SKIPE GSFNUM	;IF THE DEVICE WASN'T EXPLICITLY SPEC'D,
	POPJ P,
	LDB B,[061400,,(C)]
	CAIE B,(SIXBIT / * /)
	CAIN B,' DK	;AND DOESN'T USE THE SNAME,
	POPJ P,
	CAIE B,' AI
	CAIN B,' ML
	POPJ P,
	CAIE B,' CL
	CAIN B,' PK
	POPJ P,
	MOVSI B,'DSK	;SET THE DEV. TO DSK.

;COLON, SET DEV.
RFLNC:	MOVEI A,3
	JRST RFLSND

RFLALT:	SKIPN B,4(C)
	MOVE B,LSNAM	;GET THE SNAME TO BE USED.
	MOVEI A,(C)
	PUSHJ P,CRF
	PUSH P,C
	PUSHJ P,LFILE0	;PRINT THE FILE SPEC'D.
	POP P,C
	PUSHJ P,LCT
	PUSHJ P,GSOT
	JRST RFL0

RLINEX:	HRROS (P)	;TERMINATE ON ALTMODE.
	CAIA

;FORCE RUBOUT-PROC. TILL END OF LINE
RLINE:	HRRZS (P)	;DON'T STOP ON ALTMODE.
	PUSH P,F	;SAVE UNRDFL.
	PUSHJ P,GSOC
	PUSH P,GSCHRP
	JSP W2,RCH
	CAIN D,^M
	JRST RLINE0	;ALWAYS STOP ON CR.
	SKIPGE -2(P)
	CAIE D,33
	JRST RCH	;MAYBE STOP ON ALTMODE.
RLINE0:	MOVE D,GSCHRP
	MOVEM D,GSCHRQ	;RE-PROCESS CHARS.
	POP P,GSCHRP	;STARTING WHERE WERE AT CALL.
	POP P,D
	TLZE D,UNRDFL
	TLO F,UNRDFL
	TLO F,RUBFL
	JRST GSOD	;UN-GSOC.
;READ 6BIT NAME INTO B, CLEAR A, HANDLING RUBOUTS NORMALLY.
RTOKEN:	PUSHJ P,GSOC	;TEMPORARY FAILURE-POINT FOR RUBOUT.
	CLEARB A,B
	MOVE C,[440600,,B]
RTOK2:	JSP W2,RCH	;READ CHAR, GO TO RTOK2 LOOP.
	CAIE D,^J
	CAIN D,^M	;THESE TERMINATE & SET TOKTRM.
	JRST RTOKX1
	CAIE D,":
	CAIN D,";	;THESE TERMINATE, CLEAR TOKTRM.
	JRST RTOKX2
	CAIE D,^X
	CAIN D,^Y
	JRST RTOKX2
	CAIE D,33
	CAIN D,^I
	JRST RTOKX2
	CAIE D," 
	CAIN D,",
	JRST RTOKX2
	CAIN D,^Q	;^Q QUOTES CHAR.
	JSP W2,RCH
	CAIL D,140
	SUBI D,40	;UPPER CASE _ LOWER CASE.
	SUBI D,40
	TLNE C,770000	;PUT 6BIT CHR IN WD UNLESS WD FULL.
	IDPB D,C
	JRST RTOK2

RTOKX1:	SETOM TOKTRM
	TDZA A,A
RTOKX2:	SETZB A,TOKTRM
	JRST GSOD	;UNDO CALL TO GSOC.


;READ IN AN EXPRESSION, DOING SYLLABLE-RUBOUT.
;SKIPS UNLESS RUB BACK OUT OF RONUM.
RONUM:	SKIPE TOKTRM	;IF ALREADY SAW A ^M, ARRANGE TO
	SETOM UNRCHF	;RETURN NULL BUT WILL SKIP.
	PUSHJ P,GTVAL
	 TLNE C,4	;XCTED BY GTVAL
	POPJ P,		;FAIL IF RUB BACK OUT OF GTVAL.
	MOVE A,ARG1
	MOVE B,ARG1+1
	JRST CPOPJ1

;READ CHAR FROM INPUT, OR REPROCESS CHAR. CALL WITH JSP W2,
RCH:	PUSHJ P,SLRPIN	;GET CHAR
	CAIN D,^D
	JRST NCTLD	;^D - CANCEL ALL.
	CAIN D,^L	;^L - RETYPE CHARS READ SO FAR.
	JRST SLRPCL
	CAIE D,177
	JRST (W2)
SLRPDL:	MOVE A,GSCHRP	;GOT A RUB OUT
	PUSHJ P,DBP
SLRPD0:	CAMN A,GSOCRP	;IF PAST GSOC CALL'S PTR,
	JRST SLRPD1	;FLUSH GSOC, USE GSOA'S FAILURE POINT.
	LDB D,A
	PUSHJ P,TOUT
SLRPD3:	PUSHJ P,DBP
	MOVEM A,GSCHRQ
	TLO F,RUBFL
	PUSHJ P,GSOB	;INIT BUFFER FETCHING.
	JRST SLRPD2	;RETURN TO AFTER CALL TO GSOA OR GSOC.

SLRPD1:	PUSHJ P,GSOD	;UN-GSOC.
	CAME A,[010700,,GSCHRS-1]
	JRST SLRPD0	;NOT AT BUFFER BEG.,RETRY.
	SOS GSOCRT	;ALL RUBBED, RETURN AFTER GSOA NON-SKIPPING.
SLRPD2:	MOVE P,GSOCPP	;RESTORE P AT CALL TO GSOC OR GSOA,
	JRST @GSOCRT	;RETURN (NORMALLY SKIPPING).

SLRPCL:	PUSHJ P,FORMF	;CLEAR SCREEN ON GRAPHICS TTYS.
	MOVE I1,FLDTBP
	ADD I1,[1,,]	;PTR TO NEXT FROB TO TYPE.
SLRPC0:	CAML I1,W4
	JRST SLRPC1	;AFTER ALL THE FROBS, TYPE CHARS IN BUFFER.
	MOVE A,1(I1)	;ELSE RETYPE THE NEXT FROB
	MOVE C,2(I1)	;(IN ORDER TYPED IN)
	ADD I1,[2,,2]
	SUB I1,FLDTBP	;(IN CASE FLD TAB MOVES)
	PUSHJ P,GFROBP
	ADD I1,FLDTBP
	JRST SLRPC0

SLRPC1:REPEAT NARGS,[
	MOVE A,ARG1+2*.RPCNT	;GET THE NEXT ARG, PRINT IT.
	SKIPN C,ARG1+1+2*.RPCNT
	JRST SLRPC2	;NULL ARG => NO MORE ARGS.
IFN .RPCNT,7TYPE [ASCIZ/$, /]
	PUSHJ P,GFROBP
]
SLRPC2:	PUSHJ P,GSOD	;MAKE SURE START FROM VERY BEGINNING.
	MOVE A,GSCHRP	;FLUSH THE ^L FROM THE BUFFER,
	TLO F,CTLLFL
	JRST SLRPD3	;AFTER THAT, GO RE-PROCESS CHARS.

SLRPJN:	CAIE D,^D
	CAIN D,177
	JRST SLRPIQ
	PUSHJ P,TOUT

;READ CHAR OF FROB, LIKE RCH BUT DON'T CHECK FOR ^L, ^D, RUBOUT.
SLRPIN:	TLZE F,UNRDFL	;MAYBE RE-READ PREVIOUS CHAR, DON'T ECHO IF ^L'ING.
	JRST [LDB D,GSCHRP ? POPJ P,]
	TLNE F,RUBFL
	JRST SLRPIM
	SKIPL GTMALT	;IF $< LEFT SOME CHARS, READ THEM.
	JRST SLRPI2
	PUSHJ P,IN
SLRPI4:	MOVE A,GSCHRP
	CAMN A,[010700,,GSCHRS+GSCLNG-1]
	JRST SLRPJN
SLRPIQ:	IDPB D,GSCHRP
	POPJ P,

SLRPIM:	MOVE A,GSCHRP	;COME HERE IF RE-PROCESSING AFTER RUBOUT.
	CAMN A,GSCHRQ
	JRST [TLZ F,RUBFL\CTLLFL ? JRST SLRPIN]
	ILDB D,GSCHRP	;ELSE RE-READ & RETURN NEXT CHAR.
	TLNE F,CTLLFL	;IF RE-READING FOR ^L,
	PUSHJ P,TOUT	;ECHO THE CHAR.
	POPJ P,

SLRPI2:	MOVEI D,33
	SOSL GTMALT
	JRST SLRPI4
	AOS GTMALT
	MOVE A,GTPNTR
	ILDB D,A
	TLNN A,770000
	SETOM GTMALT
	ADDI D,"0
	MOVEM A,GTPNTR
	JRST SLRPI4
;INITIALIZE RUBOUT PROCESSING, SET UP FAILURE-POINT AFTER CALL.
;FAILS BACK SKIPPING AFTER RUBOUT,
;NON-SKIPPING IF RUBOUT WITH NO CHARS IN BUFFER.
GSOA:	SKIPN A,NCOMNM	;IF RUBOUT BUFFER NOW HOLDS NAME
	JRST GSOA1
	MOVEM A,-1(W4)	;OF A :-CMD BEING EXECUTED,
	MOVEI A,NCOMPT	;REPLACE THE : ON THE FROB STACK WITH A FROB
	MOVEM A,(W4)	;THAT WILL RUB OUT AS : AND THE CMD NAME.
	SETZM NCOMNM	;DON'T DO THAT TWICE FOR SAME COMMAND.
GSOA1:	TLZ F,RUBFL+CTLLFL
	AOS (P)		;SKIP ARG (=RET. ON ALL RUBBED.).
	MOVE A,[010700,,GSCHRS-1]
	MOVEM A,GSOCRP
	PUSHJ P,GSOB
	POP P,GSORET	;SAVE RET. ADDR.,
	MOVEM P,GSOPDP	;FOR REST. ON RUBOUT.
	PUSH P,GSORET

;SET UP TEMPORARY FAILURE POINT FOR RUBBING OUT NOT PAST
;WHERE WE WERE AT CALL.
GSOC:	POP P,GSOCRT
	MOVEM P,GSOCPP
	MOVE A,GSCHRP
	MOVEM A,GSOCRP
	JRST @GSOCRT

;INIT. RUBOOUT PROC BUFFER.
GSOB:	SETZM TOKTRM
	MOVE A,GSOCRP
	MOVEM A,GSCHRP
GSOB1:	SETZM GSONUM
	MOVE A,[GSONUM,,GSONUM+1]
	BLT A,GSFNUC
	POPJ P,

;UNDO A CALL TO GSOC.
GSOD:	PUSH P,A
	MOVE A,[010700,,GSCHRS-1]
	MOVEM A,GSOCRP
	MOVE A,GSORET
	MOVEM A,GSOCRT
	MOVE A,GSOPDP
	MOVEM A,GSOCPP
POPAJ:	POP P,A
	POPJ P,

;TYPE " ", THEN GSOA (CANCEL IF RUB BACK.)
GSOT:	POP P,GSOTRT'
	PUSHJ P,TSPC
	PUSHJ P,GSOA
	 JRST NCTLD
	TLNE F,CTLLFL	;ECHO SPACE FOR ^L.
	 PUSHJ P,TSPC
	JRST @GSOTRT
IFN 0,[

FROB FORMAT AS FOLLOWS:
EACH FROB IS 2 WDS.
BOTH 0 => NULL FROB.
1ST WD IS VALUE, 2ND WD DECODED TO GIVE TYPE.
2ND WD:  SIGN BIT ON => OPERATOR, 1ST WD IS INFIX ARG.
	BIT 4.8 (IFXF) => INFIX ARG WAS GIVEN.
	BIT 4.7 (IFXDF) => IT WAS DECIMAL, NOT OCTAL.
	BIT 4.6 (2ALTF) => OP HAD EXACTLY 2 ALTMODES.
	BIT 4.5 (1ALTF) => OP HAD EXACTLY 1 ALTMODE.
	BITS 3.1-3.7 => CHARACTER NAME OF OPERATOR.
	RH => ADDRESS OF WD SAYING WHAT TO DO WITH OPERATOR.
		THIS WORD IS USUALLY IN ONE OF THE DISPATCH TABLES
		 (OPTAB0, OPTAB1, OPTAB2) BUT NEED NOT BE.
		  ITS FORMAT IS DOCUMENTED BEFORE OPTAB0.

SIGN BIT OF 2ND WD OFF => THIS FROB IS SYLLABLE,
  1ST WD USUALLY HAS VALUE (BUT SEE SYMBOL)
BITS 4.6-4.8 GIVE SYLLABLE TYPE (FOR RUBBING IT OUT)
   0  => SPECIAL SYLLABLE, RH HAS RTN TO RETYPE SYLL IF RUBBED.
   1  => OCTAL NUMBER.
   2  => DECIMAL NUMBER.
   3  => FLOATING POINT NUMBER.
   4  => SYMBOL. 3 KINDS:
	BITS 1.1-4.5 OF 2ND WD ALL 0 =>
		UNEVALUATED, 1ST WD HAS SQUOZE.
	BITS 3.1-4.5 ALL 0, RH NOT 0 =>
		EVALUATED FUNNY SYMBOL, RH HAS FUNNYNESS,
		 1ST WD HAS ABSOLUTE PART OF VALUE.
	ELSE BITS 1.1-4.5 HAVE SQUOZE, 1ST WD HAS VALUE.
	SYMBOLS ARE TYPED IN AS UNEVALUATED SYMBOLS,
	BECOME EVALUATED WHEN ANOTHER OP. IS READ UNLESS OP
	 SAYS "INHIBIT EVAL".
	IF AN UNEVALUATED SYMBOL REMAINS UNTIL EFIELD,
	 IT GENERATES AN UNDEF SYM REF.

]

;SYLLABLE TYPES, GO IN LH OF 2ND WD.
SYLOCT==40000
SYLDEC==100000
SYLFLT==140000
SYLSYM==200000

;OPERATOR FLAGS.

1ALTF==10000	;1 ALTMODE OPERATOR.
2ALTF==20000	;2 ALTMODE OPERATOR.
IFXDF==100000	;DECIMAL INFIX NUMBER.
IFXF==200000	;ANY INFIX NUMBER.

DD1:	PUSHJ P,CRF
DD1A:	PUSHJ P,NLTL3
DD1B:	TLZ F,ROF
	MOVE D,[SCHM,,SCH]
	BLT D,ODF
	CAIA
DD2A:	PUSHJ P,LCT
DD2:	MOVE P,[(-LPDL)PS]

GFTEST:	MOVE W4,FLDTBP
	ADD W4,[1,,]	;1ST WD OF FLDTAB UNUSED FOR FLDPUT'S SAKE.
	MOVEM W4,FLDSTR
	SETZM FLDTRM
	SETZM NCOMNM	;NO :-COMMAND IN PROGRESS.
	SETZM RELCP1	;NO SPECIAL PTR IN SYMTAB SPACE TO RELOCATE.
GBFQJ:	MOVEM P,ERRSTP	;SET UP PDL AN PC
	MOVEI B,GFLD1	;TO RESTORE ON ERRORS.
	MOVEM B,ERRSTL
	AND F,[NROFL\STF,,]
	SETZM ABCNT
	SETOM GTMALT
GFLD1:	PUSHJ P,EVARGF	;NO LONGER HAVE ARGS EVALLED.
	SETZM UNDFRP	;NO UNDEF REFS NOT HANDLED.
	PUSHJ P,GTFROB
	TLZ F,NNULFL\PNTFL
	CAIN D,177
	JRST GFRUB
	JUMPE B,GFLD1
	JUMPL B,GFLD3	;JUMP IF OPERATOR
GFLD4:	PUSHJ P,FLDPUT	;PUT AWAY
	JUMPGE B,GFLD1	;NOT AN OPERATOR OR FLUSHED BY FLDPUT
	MOVE W3,C	;OPERATOR
	SETZB C,D	;FOR ADDI A-B HACKS
	TLNN W3,40000
	JRST GFLD2A
	POP W4,B
	POP W4,A
GFLD2A:	TLNE W3,20000
	CAMN W4,FLDSTR	;NOTHING ELSE IN FLDTAB TEST
	JRST GFLD2B
	POP W4,D
	POP W4,C
	TLNN W3,40
	JRST GFLD2B
	PUSHJ P,NBITE	;MAKE SYM SIXBIT
	TLNE W3,20
	PUSHJ P,NGDEV

;DROPS THROUGH.

;DROPS THROUGH.

GFLD2B:	TLNN W3,200
	JRST GFLD2C
	PUSH P,W3
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,EVARGS
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	POP P,W3
GFLD2C:	TLNN W3,100	;MAYBE CHECK FOR INFERIOR OR (INF. OR SELF).
	JRST GFLD2D
	TLNE W3,2
	SKIPN DDTSW
	PUSHJ P,QIJERR
GFLD2D:	TLNE W3,400
	PUSHJ P,PLUNK1	;MAYBE DEPOSIT OPERATOR'S ARGUMENT.
	SKIPE UNDFRP	;IF HAD UNDEF REFS AND DIDN'T CALL PLUNK1,
NUNDER:	ERSTRT [SIXBIT/ILGL UNDEF SYM?/]
	TLNN W3,10000	;SKIP IF EXECUTE BIT ON
	JRST GFLD1
	PUSH W4,A	;PUT OP TO EXECUTE BACK ON STACK
	PUSH W4,B	;SO ^L WITHIN OP. WILL TYPE IT OUT.
	MOVEI W2,[SETZ B, ? JRST GFLDE1]
	MOVEM W2,ERRSTL	;BUT SHOULD REMOVE IT IF ERROR IN OP.
	PUSHJ P,(W3)	;EXECUTE THE OPERATOR,
GFLDE1:	SUB W4,[2,,2]	;THEN REMOVE IT FROM STACK.
	MOVEI W2,GFLD1	;(COMPLICATED INTERACTIONS WITH NCOL)
	MOVEM W2,ERRSTL	;ALREADY GONE, ERRORS SHOULDN'T REMOVE IT.
	SETZM NCOMNM	;NO LONGER HAVE : OF :-CMD ON TOP OF FROB STACK.
	JUMPE B,GFLD1
	PUSHJ P,FLDPUT
	JRST GFLD1

GFLD3:	MOVE C,(B)
	TLNE C,10
	JRST GFLD6
	SKIPE FLDTRM
	SKIPL C
	SKIPA
	JRST GFLD7
	TRNE C,-1
	JRST GFLD4
GFLD5:	7TYPE [ASCII / OP/]

GFLD6:	SKIPL C
	AOS ABCNT	;<
	SKIPGE C
	SOS ABCNT	;>
	SKIPGE ABCNT
	SKIPN FLDTRM
	JRST GFLD4
GFLD7:	PUSHJ P,FLDPUT
	JUMPGE B,GFLD1
	SUB W4,[2,,2]
	POPJ P,

GTVAL:	PUSH P,FLDSTR
	PUSH P,FLDTRM
	PUSH P,ABCNT
	PUSH P,W4
	PUSH P,F
	PUSH P,ERRSTP	;GBFQJ WILL USE THESE.
	PUSH P,ERRSTL
NGVP==.-GTVAL
	MOVN D,FLDTBP	;MAKE SAVED FLDTAB PTRS BE RELATIVE
	ADDM D,-3(P)	;SINCE FLDTAB CAN MOVE AND EXPAND.
	ADDM D,-6(P)
	SETOM FLDTRM
	MOVEM W4,FLDSTR
GTVAL1:	PUSHJ P,GBFQJ
	XCT @-NGVP(P)
	JRST GTVAL2
	CAIN D,177
	JRST GTVAL3
	PUSHJ P,FLDOVF
	PUSHJ P,NXERR
	JRST GTVAL1

GTVAL3:	SOS -NGVP(P)
GTVAL2:	PUSHJ P,EVARGS
	POP P,ERRSTL
	POP P,ERRSTP
	SKIPE UNDFRP	;UNDEF REFS ILLEGAL IN GTVAL.
	JRST NUNDER
	POP P,F
	MOVE W4,FLDTBP
	ADDM W4,(P)
	ADDM W4,-3(P)
	POP P,W4
	POP P,ABCNT
	POP P,FLDTRM
	POP P,FLDSTR
	JRST CPOPJ2

;PUSH FROB IN A,B ONTO FROB TABLE.
;IF OPERATOR, RETURN DISPATCH WORD IN C.
;DOESN'T CLOBBER B.
FLDPUT:	AOBJN W4,FLDPT7	;PUSH A ON FROB STACK,
	MOVEI W1,FLDTBP	;NO ROOM => EXPAND IT.
	SAVE A
	MOVSI A,-FTBLNG
	CALL HOLE0
	HRRI A,-FTBLNG
	ADD W4,A
	ADDM A,FLDSTR	;UPDATE POINTERS IN FROB TABLE.
	REST A
FLDPT7:	MOVEM A,(W4)
	PUSH W4,B
	JUMPGE B,FLDPT0	;UNLESS THIS FROB IS OP. WITH EVAL-INHIBIT,
	MOVE C,(B)
	TLNE C,200000
	POPJ P,	;EVAL INHIBIT
FLDPT0:	LDB A,[400400,,-2(W4)]	;IF PREV. FROB IS UNEVALUATED SYMBOL,
	CAIE A,4
	POPJ P,
	LDB  A,[4000,,-2(W4)]
	JUMPN A,CPOPJ
	MOVE A,-3(W4)
	DPB A,[4000,,-2(W4)]	;EVALUATE IT.
	MOVEM A,SYM
	CAMN A,[SQUOZE 0,.]	;SYMBOL "." IS EVALUATED SPECIALLY.
	JRST FLDPT5
	PUSH P,C
	PUSHJ P,SEVL
	JRST FLDPT2
	HLRZ B,FNYLOC	;GET FUNNYNESS OF SYM, SET BY EVAL.
	JUMPE B,FLDPT1	;IF SYM IS FUNNY,
	DPB B,[4000,,-2(W4)]	;REPLACE NAME BY FUNNYNESS.
FLDPT1:	MOVEM D,-3(W4)
	MOVE B,(W4)	;ALLOW EVAL TO CLOBBER B.
POPCJ:	POP P,C
	POPJ P,

FLDPT4:	7TYPE [ASCIZ /?U/]
	SUB W4,[4,,4]
	MOVEI B,0
	MOVE A,SYM
	CAME A,[SQUOZE 0,HELP]
	JRST POPCJ
	POP P,C
	JRST NHELP

FLDPT5:	MOVE D,[400000+".,,[1000,,FLDPT6]]
	MOVEM D,-2(W4)	;REPLACE "." BY AN OPERATOR WITH SAME NAME
	SETZM -3(W4)	;NO INFIX ARG. OPERATOR WILL JRST FLDPT6
	POPJ P,		;FROM EFIELD.

FLDPT6:	HLLZ D,LLOC	;GET FUNNYNESS OF OPEN LOCATION,
	IORM D,FNYLOC	;STICK IN WITH FUNNYNESS OF OTHER SYMS.
	HRRZ C,LLOC	;GET ACTUAL ADDRESS OPEN,
	JRST EFOCTJ	;RETURN OCTAL NUM. TO EFIELD.

FLDPT2:	PUSHJ P,OPLK2
	JRST FLDPT4
	JRST FLDPT1
	JRST FLDPT1

;RUB OUT PREVIOUS SYLL.
GFRUB:	CAMN W4,FLDSTR
	JRST GFRUB3
	POP W4,C
	POP W4,A
	PUSHJ P,GFROBP
	JRST GFLD1

GFRUB3:	SKIPN FLDTRM	;TRYING TO RUB WHEN NO FROBS BUFFERED,
	JRST NXERR	;AT TOP LEVEL TYPE ??, TRY AGAIN;
	MOVEI C,0
	POPJ P,		;IN GTVAL RETURN NULL SYLL.

;PRINT A FROB IN A,C.
GFROBP:	JUMPGE C,GFRUB1	;JUMP IF NOT OPERATOR
	LDB B,[360200,,C]	;GET NUM OF ALTS
	JUMPE B,GFRUB2
	CTYPE 33	;TYPE ALT
	SOJG B,.-1
GFRUB2:	TLNN C,200000
	JRST GFRUB4
	TLNN C,100000
	PUSHJ P,G8PNT
	TLNE C,100000
	PUSHJ P,G9PNT
GFRUB4:	LDB D,[220700,,C]
	PUSHJ P,TOUT
	TLNE C,40000
	PUSHJ P,TOUT
	POPJ P,

GFRUB1:	MOVE D,A	;PUT VALUE OF SYLL IN D FOR TYPEOUT ROUTINE.
	LDB B,[400300,,C]
	PUSH P,C
	PUSH P,[POPCJ]
	XCT GFRUBT(B)
	MOVEM D,(P)	;DIDN'T JUMP => ILLEGAL FROB TYPE.
	ERLOSS 1(P)

GFRUBT:	JUMPN C,(C)
	JRST G8PNT
	JRST G9PNT
	JRST TFLOT
	JRST GSPNT
REPEAT 3,JFCL

D5PNT:	MOVEI C,0
G5PNT:	CTYPE 33
	PUSH P,D
	LDB A,[400400,,D]
	LSH A,2
	PUSHJ P,G8PNT
	POP P,D
	CTYPE "&
	JRST GSPNT1

GSPNT:	TLNN C,37777
	TRNN C,-1
	JRST GSPNT1
	HRLI D,(C)	;EVALUATED FUNNY SYMBOL.
	JRST PAD

GSPNT1:	MOVE B,CJTOUT
	MOVEM B,SPTS
	TLZ D,PNAME
	TDNN C,[37777,,-1]
	JRST SPT1
	LDB D,[4000,,C]
	JRST SPT1

D7PNT:	MOVE C,D	;$" TYPEOUT MODE RTN.
	7TYPE [ASCIZ/1"/]
G7PNT2:	SETZ D,
	ROTC C,7	;GET NEXT CHAR.
	CAIE D,"^	;UPARROW AND ^Q MUST BE QUOTED.
	CAIN D,^Q
	 JRST [CTYPE ^Q ? JRST G7PNT4]
	CAIGE D,40
	JRST G7PNT3	;CTL CHARS TREATED SPECIALLY.
G7PNT4:	PUSHJ P,TOUT
	JUMPE C,G7PNT1	;OMIT TRAILING ^@'S.
	JRST G7PNT2

G7PNT3:	CTYPE "^
	ADDI D,100
	JRST G7PNT4

D6PNT:	7TYPE [ASCIZ/1'/]	;$' TYPEOUT MODE.
	PUSHJ P,SIXTYP
G7PNT1:	MOVEI D,33
	JRST TOUT

;EVALUATE ARGUMENTS
EVARGS:	PUSH P,ERRSTP	;EFIELD WILL SET THESE UP.
	PUSH P,ERRSTL
	SETZM FNYLOC	;REINIT ACCUMULATION.
	SETZM UNDFRP	;NO UNDEF REFS IN THE ARGS YET.
	PUSHJ P,EVARGF	;FLUSH THE OLD ARGS.
	MOVEI W3,W3
	MOVEM W3,RELCP1	;RELOCATE W3 (IN CASE HAKKAH MOVES FROB TAB)
	MOVE W3,FLDSTR
EVARG1:	PUSHJ P,VEARG
	JUMPE B,EVARG3
	MOVNI C,NARGS*2-2
EVARG2:	SKIPE ARG1+1+NARGS*2-2(C)
	AOJLE C,[AOJA C,EVARG2]
	JUMPG C,EVARG4
	MOVEM A,ARG1+NARGS*2-2(C)
	MOVEM B,ARG1+1+NARGS*2-2(C)
	JRST EVARG1

EVARG4:	MOVE C,[ARG1+2,,ARG1]
	BLT C,ARG1+1+NARGS*2-4
	MOVEM A,ARG1+NARGS*2-2
	MOVEM B,ARG1+1+NARGS*2-2
	JRST EVARG1

EVARG3:	MOVE W4,FLDSTR
	MOVSI A,600000	;CLEAR UNUSED FUNNYNESS BITS.
	ANDM A,FNYLOC
	POP P,ERRSTL
	POP P,ERRSTP
	SETZM RELCP1	;W3 SHOULD NO LONGER BE RELOCATED.
	POPJ P,

EVARGF:	SETZM ARG1
	MOVE A,[ARG1,,ARG1+1]
	BLT A,ARG1+2*NARGS-1
	POPJ P,

;EVALUATE SINGLE ARGUMENT
;SP 1 3
;COMMA 2 4
VEARG:	SETZM VALUE
	SETZB I2,VALUE+1
	SETZM PVALUE
VEARG1:	CAML W3,W4	;IF NO FROBS LEFT, NO ARG.
	JRST GSNLRT
	SKIPL A,2(W3)	;IF 1ST FROB IS OPERATOR,
	JRST VEARG2
	MOVE A,(A)	;IF IT'S A SPACE,
	CAME A,[100000,,1]
	JRST VEARG2
	ADD W3,[2,,2]	;SKIP IT AND TRY AGAIN.
	JRST VEARG1
VEARG2:	MOVEM I2,STATE
	PUSHJ P,EFIELD	;GET FIELD VALUE
	SKIPA D,[100000,,3]
	MOVE D,(D)
	MOVE I2,STATE
	JUMPN I2,VEARG4
	IORM A,VALUE
	PUSHJ P,VERGNM
	MOVEI I2,1
	TRNN D,1
	MOVEI I2,2	;2=>COMMA
VEARG8:	HRRZ B,D
	CAIG B,2
	JRST VEARG2	;FIELD TERM
VERG8A:	MOVE A,PVALUE
	MOVEI B,0
	MOVSS A
	ROTC A,18.
	ADD A,VALUE
	ADD B,VALUE
	HRR A,B
	MOVEM A,VALUE
	SKIPN B,VALUE+1	;WORD TERM
	MOVSI B,SYLOCT
	MOVEM B,VALUE+1
	POPJ P,

VEARG4:	CAIE I2,3
	CAME D,[100000,,2]
	JRST VEARG5
	CAIE I2,1	;SKIP IF "FOO A," FORMAT
	JRST VEARG6
VERG5C:	MOVE I4,VALUE
	TLC I4,700000
	TDNE I4,[777437,,-1]
	JRST VERG5D
	LDB I4,[900,,A]	;IO INST
	ANDI I4,774
	AND A,[077400,,]
	LSH I4,30
	IOR A,I4	;WIN FOR DEVICE CODES
VERG5E:	ADDM A,VALUE
	JRST VERG5A

VERG5D:	ANDI A,17
	LSH A,27
	JRST VERG5E

VEARG5:	CAIN I2,2
	SKIPE B
	JRST VERG5B
	CAMG D,[100000,,2]
	JRST VERG5B
	MOVE A,VALUE	;"FOO," FORMAT
	SETZM VALUE
	JRST VERG5C

VERG5B:	HRRZS A	;ALL OTHER FORMATS
	ADD A,VALUE
	HRRM A,VALUE
VERG5A:	PUSHJ P,VERGNM
VERG6A:	MOVEI I2,3
	JRST VEARG8

VEARG6:	JUMPN B,VEARG5	;"FOO,," FORMAT
	MOVSI A,400000	;SAY ALL UNDEF REFS ARE SWAPPED REFS.
	MOVE B,UNDFRP
	SOJL B,.+3
	IORM A,UNDFRL(B)
	SOJG B,.-2
	HRLZS A,VALUE	;PUT 1ST FIELD INTO LH.
	JRST VERG6A

VERGNM:	PUSH P,D
	MOVE D,VALUE+1
	PUSHJ P,NMODE
	POP P,D
	MOVEM B,VALUE+1
	POPJ P,

;EVALUATE FIELD
;RETURN SKIPPING WITH RESULT IN A & B AND
	;WITH FIELD TERMINATOR IN D
;OR NOT SKIPPING IF HIT END OF FROBS
EFIELD:	PUSH P,[-1]
	TLZ F,NNULFL\PNTFL\LETFL
	JRST EFLD3
	;LETFL=END OF WORLD

EFLD2:	ADD W3,[2,,2]
EFLD3:	MOVEI C,EFLD2	;SET UP ERROR RETURN
	MOVEM C,ERRSTL	;FOR EXECUTE-DURING-EVAL OPERATORS.
	MOVEM P,ERRSTP
	CAML W3,W4
	JRST EFLDEW	;END OF WORLD
	MOVE C,1(W3)
	MOVE D,2(W3)	;GET FROB
EFLD4:	JUMPGE D,EFLDNO	;NOT AN OPERATOR, PUSH ON STACK.
	MOVE I4,(D)
	TLNE I4,1000
	JRST (I4)	;EXECUTE DURING EVAL
	TLNE I4,100000
	JRST EFLDE	;END OF FIELD
	TLO F,NNULFL
	LDB I2,[340200,,I4]	;GET PRIORITY
	SKIPN I2
	ERLOSS 2(P)	;UUOH WILL PUSH A, THEN D.
	SKIPGE (P)
	JRST EFLD8	;THIS IS PREFIX
	MOVE B,-2(P)
	AOJE B,EFLD8	;THIS IS FIRST OPR
EFLDEA:	SOS B
	MOVE I4,(B)
	LDB I3,[340200,,I4]
	SKIPL -3(P)	;IF PREV. OP. WAS PREFIX OR HIGHER PRIOR,
	CAMG I2,I3
	JRST EFLD8Z	;EXECUTE IT, REPLACE BY VALUE.
EFLD8:	PUSH P,D	;PUSH THIS OP IN ANY CASE.
	JRST EFLD2

EFLD8Z:	POP P,D		;POP 2ND ARG.
	POP P,C
	POP P,I2	;OP. TO EXECUTE.
	SKIPGE (P)	;IF PREFIX, DUMMY UP 1ST ARG,
	JRST EFLD8P
	POP P,B		;ELSE POP ACTUAL 1ST ARG.
	POP P,A
EFLD9P:	PUSHJ P,(I4)	;ACUALLY EXECUTE AN OPERATOR
	PUSH P,A	;REPLACE OP. AND ARGS BY VALUE.
	PUSH P,B
	JRST EFLD3

EFLDE:	TLNN F,NNULFL
	CAME I4,[100000,,1]
	JRST EFLDE1
	JRST EFLD2	;LEADING SPACE FLUSHER

EFLD8P:	MOVE A,[0 ? 1 ? -1]-1(I3)
	MOVEI B,1
	TLNN I2,30000	;SKIP IF FLOAT
	JRST EFLD9P
	TLC A,232000
	FADR A,A
	JRST EFLD9P

EFLDNO:	TLO F,NNULFL	;NOT AN OP - FIELD NOT NULL.
	SKIPL (P)	;PREVIOUS WASN'T OP => CONSEC. ARGS, ERROR.
	JRST EFLNOS
	PUSH P,C	;ELSE JUST PUSH THIS ARG.
	PUSH P,D
	CAMN D,[SYLSYM,,]
	JRST EFLDN1	;J IF UNEVALUATED SYMBOL.
	HLRZ I4,D	;CHECK FOR FUNNY SYMBOLS.
	HRLZI D,(D)
	CAIN I4,SYLSYM
	IORM D,FNYLOC	;ACCUMULATE FUNNYNESS OF ALL SYMS IN ARGS.
	JRST EFLD2

EFLDN1:	SETZM -1(P)	;UNEVALUATED SYMBOL HAS VALUE 0,
	MOVEI D,2
	ADD D,UNDFRP
	CAILE D,UNDFRS
	JRST NUNDER	;(TOO MANY UNDEF SYMS IN 1 ARG)
	MOVEM D,UNDFRP	;CREATE AN UNDEF REF FOR THE SYMBOL.
	MOVEM C,UNDFRL-2(D)
	SETZM UNDFRL-1(D)	;SAY NORMAL REF, NOT SWAPPED.
	JRST EFLD2

EFLNOS:	7TYPE [ASCII / NOS/]
	MOVE D,[400000+"+,,OPTAB0+"+-1]	;+
	JRST EFLD4

EFLDEW:	TLO F,LETFL
EFLDE1:	TLNN F,NNULFL
	JRST EFLDE2	;NULL
	MOVNI I2,1	;EFLDEA WILL LOOK AT THIS .
	SKIPL B,(P)
	JRST EFLDE5
	AOJE B,EFLDXX	;NOTHING ON STACK
	PUSH P,[0]
	PUSH P,[1]
EFLDE5:	MOVE B,-2(P)
	AOJE B,EFLDE8
	JRST EFLDEA

EFLDXX:	SKIPN B
EFLDE2:	SETZB A,B
	SUB P,[1,,1]	;FLUSH THE -1 PUSHED AT EFIELD.
	TLNE F,LETFL	;IF RAN OUT OF SYLLS, RETURN.
	POPJ P,
	ADD W3,[2,,2]	;ELSE PASS BY THE FIELD-TERMINATOR.
	JRST CPOPJ1

EFLDE8:	POP P,B
	POP P,A
	JRST EFLDXX

;PARENTHESIS AND ANGEL BRAKET ROUTINES

NLPARN:	SKIPA A,[2]	;(
NLANGB:	MOVEI A,1	;<
	PUSH P,PSTATE
	MOVEM A,PSTATE
	PUSH P,PVALUE
	PUSH P,VALUE
	PUSH P,VALUE+1
	PUSH P,STATE
	PUSH  P,F
	TLZ F,PNTFL\LETFL\NNULFL
	ADD W3,[2,,2]
	PUSHJ P,VEARG	;GET VALUE WITHIN
	MOVE C,VALUE
	MOVE D,VALUE+1
	POP P,F
	POP P,STATE
	POP P,VALUE+1
	POP P,VALUE
	POP P,PVALUE
	SKIPL A,PSTATE
	7TYPE NLCLSE-1(A)	;ERROR IF NO CLOSE SUPPLIED
	POP P,PSTATE
	TRNN A,2
	JRST NLNGB2	;<>
	SKIPGE A,(P)	;()
	AOJN A,NLPOP	;JUMP IF PRECEDED BY ARITH OP
	LSHC B,18.
	ADD C,PVALUE
	HLLM C,PVALUE
	ADD B,PVALUE
	HRRM B,PVALUE
	JRST EFLD3

NLPOP:	MOVSS C
NLNGB2:	SUB W3,[2,,2]
	JRST EFLD4

NLCLSE:	ASCII / >/
	ASCII / )/

NRPARN:	SKIPA A,[2]	;)
NRANGB:	MOVEI A,1	;>
	HRRZ B,PSTATE
	CAME A,B
	7TYPE NRNMTC-1(A)	;ERROR ON UN-MATCHED CLOSE
	HRROM B,PSTATE
	MOVE D,[410000+" -1,,OPTAB1+" -1]	;$SP
	JRST EFLD4

NRNMTC:	ASCII / </
	ASCII / (/
;READ A FROB INTO A,B.
;RETURN LAST CHAR. READ IN D.
;(WILL BE RUBOUT IFF TRYING TO RUB PREVIOUS FROB)
GTFROB:	PUSHJ P,GSOA	;INIT. PROC, SET UP RET. ADDR.
	 JRST GSNLRT	;(RETN HERE IF WHOLE SYLL RUBBED)
	TLZ F,NNULFL\PNTFL\LETFL\NEGEFL
;DETERMINE IF FROB TO BE READ IS SYL OR OP
	JSP W2,RCH
	CAIL D,140
	SUBI D,40	;LOWER CASE TO UPPER.
	CAIL D,"0
	CAILE D,"9
	JRST FRBTY2
	JRST SLRPND

FRBTY2:	CAIL D,"A
	CAILE D,"Z
	JRST FRBTY4
	JRST SLRPND

FRBTY4:	CAIE D,".
	CAIN D,"$
	JRST SLRPND
	CAIN D,"%
	JRST SLRPND
	MOVEI W2,GOPND
	JRST GOPND

GSDECJ:	SKIPA B,[SYLDEC,,]
GSOCTJ:	MOVSI B,SYLOCT
	POPJ P,

GSEVLJ:	TLZA B,-1	;JSP B,GSEVLJ TO RETURN TYPE-0 SYLL.
GSNLRT:	SETZB A,B	;GET SYL NULL RETURN
	POPJ P,

GSFLTJ:
FMODE:	MOVSI B,SYLFLT
	POPJ P,

DBP:	ADD A,[70000,,]	;DECREMENT BYTE POINTER (7 BIT)
	TLNE A,400000
	ADD A,[347777,,-1]
	POPJ P,

;COME HERE WITH 1ST CHAR IF IS SYLLABLE.
SLRPND:	JSP W2,SLRPN2

;PROCESS 1 CHAR OF SYLLABLE.
SLRPN2:	CAIL D,140
	SUBI D,40	;LOWER CASE TO  UPPER.
	CAIL D,"0
	CAILE D,"9
	JRST SLRNNM	;JUMP IF NOT DIGIT
	TLO F,NNULFL	;NOT NULL
	PUSHJ P,GASSOD
	MOVE A,GSFNUM	;ASSEMBLE FLOATING
	MOVEI B,-"0(D)
	TLO B,232000
	FADR B,B
	TLNE F,PNTFL
	JRST SLRFN2	;JUMP IF AFTER POINT
	FMPR A,[10.0]
SLRFN3:	FADR A,B
	MOVEM A,GSFNUM
	SUBI D,"0-1	;CONVERT TO SQUOZE DIGIT
SLRSYM:	PUSHJ P,SYMPUT
	JSP W2,RCH
	JRST SLRPN2

GASSOD:	MOVE A,GSONUM	;ASSEMBLE OCTAL
	LSH A,3
	ADDI A,-"0(D)
	MOVEM A,GSONUM
	MOVE A,GSDNUM	;ASSEMBLE DECIMAL
	IMULI A,10.
	ADDI A,-"0(D)
	MOVEM A,GSDNUM
	POPJ P,

;PUT SQUOZE IN SYM
SYMPUT:	MOVE A,GSSSYM
	CAML A,[1*50*50*50*50*50]
	POPJ P,	;ALREADY A FULL SYMBOL
	IMULI A,50
	ADD A,D
	MOVEM A,GSSSYM
	POPJ P,

;FLOATING AFTER POINT
SLRFN2:	AOS C,GSFNUC
	FDVR B,[10.0]
	SOJG C,.-1
	JRST SLRFN3

;NOT A DIGIT
SLRNNM:	CAIL D,"A
	CAILE D,"Z
	JRST SLRNLT	;JUMP ON NOT LETTER
SLRLET:	TLNE F,LETFL
	JRST SLRLE2
	CAIN D,"E
	JRST SLRPE
SLRLE2:	SUBI D,"A-13
	SKIPA
SLR$%:	ADDI D,46-"$
	TLO F,LETFL\NNULFL
	JRST SLRSYM

;NOT A LETTER
SLRNLT:	CAIE D,"$
	CAIN D,"%
	JRST SLR$%
	CAIN D,".
	JRST SLR.
SLRNNN:	SETOM UNRCHF
	TLNN F,NNULFL\PNTFL
	JRST GSNLRT
	TLNE F,LETFL
	JRST GSYLET
	TLNE F,PNTFL
	JRST GSYDFN
	MOVE A,GSONUM
	JRST GSOCTJ

SLR.:	TLOE F,PNTFL
	TLO F,LETFL	;A LETTER IF NOT ONLY ONE
	TLZ F,NNULFL	;TO TELL IF DEC OR FLOAT
	MOVEI D,45	;SQUOZE
	JRST SLRSYM

GSYLET:	MOVSI B,SYLSYM
	MOVE A,GSSSYM
GSYLE2:	CAML A,[1*50*50*50*50*50]
	POPJ P,
	IMULI A,50
	JRST GSYLE2

GSYDFN:	MOVE C,GSSSYM	;IF WAS JUST ., IS SYM.
	CAIN C,45
	JRST GSYLET
	MOVE A,GSDNUM
	TLNN F,NNULFL	;ELSE MAY BE DECIMAL NUM.
	JRST GSDECJ
	MOVE A,GSFNUM	;OR MAY BE FLOATING.
	JRST GSFLTJ

;E FORMAT
SLRPE:	TLZN F,PNTFL
	JRST SLRLE2
	SUBI D,"A-13
	PUSHJ P,SYMPUT
SLRPEL:	JSP W2,RCH
	CAIL D,140
	SUBI D,40
	CAIN D,"+
	JRST SLRPEM
	CAIN D,"-
	JRST SLRPE1
	CAIL D,"0
	CAILE D,"9
	JRST SLRENN
	TLO F,LETFL
	MOVE A,GSENUM
	IMULI A,10.
	ADDI A,-"0(D)
	MOVEM A,GSENUM
	SUBI D,"0-1
	PUSHJ P,SYMPUT
	JRST SLRPEL

SLRPEM:	TLNE F,LETFL
	JRST SLREM2
	JRST SLRPEL

SLRPE1:	TLNE F,LETFL
	JRST SLREM2
	TLC F,NEGEFL
	JRST SLRPEL

SLRENN:	CAIL D,"A
	CAILE D,"Z
	JRST SLREN2
	TLO F,LETFL
	JRST SLRLET

SLREN2:	CAIE D,"$
	CAIN D,"%
	JRST SLRNLT
	CAIN D,".
	JRST SLRPE.
SLREM2:	SETOM UNRCHF
	MOVE A,GSFNUM
	MOVE C,GSENUM
	ANDI C,77
	TLNE F,NEGEFL
	JRST SLRPE4
SLRPE2:	SOJL C,GSFLTJ
	FMPR A,[10.0]
	JRST SLRPE2

SLRPE4:	SOJL C,GSFLTJ
	FDVR A,[10.0]
	JRST SLRPE4

SLRPE.:	TLOE F,PNTFL
	JRST SLRNLT
	MOVEI D,45
	PUSHJ P,SYMPUT
	JRST SLRPEL
;READ AN OPERATOR, RETURN IT IN A,B 
;W2 CONTAINS GOPND, WHICH PROCESSES 1 CHAR. RCH RETURNS TO IT.
;COME IN WITH THE 1ST CHAR FROM FRBTYP.

GOPND:	CAIN D,33
	JRST GOPALT
	CAIL D,"0
	CAILE D,"9
	JRST GOPNNM
	TLO F,LETFL
	PUSHJ P,GASSOD
	JRST RCH

GOPALT:	AOS A,GSENUM
	CAILE A,2
	SOS GSENUM
	JRST RCH

GOPPNT:	TLNN F,LETFL
	JRST GOPNN2	;$., $$.
	TLC F,PNTFL
	JRST RCH

GOPNNM:	CAIN D,".
	JRST GOPPNT
GOPNN2:	CAIL D,140
	SUBI D,40
	MOVEM D,GSFNUM
	MOVE A,GSONUM
	TLNE F,PNTFL
	MOVE A,GSDNUM
	MOVSI B,400000	;OP
	TLNE F,LETFL
	TLO B,200000	;NUM PRESENT
	TLNE F,PNTFL
	TLO B,100000	;DEC
	MOVE C,GSENUM
	DPB C,[360200,,B]	;ALTS
	MOVE D,GSFNUM
	PUSHJ P,FIXOPC
	HRRI B,@GOPBT1(C)
	MOVE C,GSFNUM
	DPB C,[220700,,B]	;CHAR
	POPJ P,

FIXOPC:	CAIL D,33	;FLUSH IMPOSSIBLE OP CHARS
	SOS D
	CAIL D,"0-1
	SUBI D,"9-"0+1
	POPJ P,

GOPBT1:	OPTAB0(D)
	OPTAB1(D)
	OPTAB2(D)

ATSIGN:	MOVSI A,(@)	;@
	XORM A,VALUE
	MOVSI A,SYLOCT
	SKIPN VALUE+1
	MOVEM A,VALUE+1
	TLO F,NNULFL
	JRST EFLD2

ALTEQ:	MOVSI W3,-<NARGS*2>	;$$=
ALTEQ2:	SKIPN C,ARG1+1(W3)
	JRST NLTL3
	MOVE D,ARG1(W3)
	PUSHJ P,LWTPUP
	PUSHJ P,CRF
	AOBJN W3,.+1
	AOBJN W3,ALTEQ2
	JRST NLTL3

NEQL:	TRC C,FTOC#PIN	;=
NLFTA:	TRC C,PIN#TFLOT	;_
FEQL:	TRC C,TFLOT#D7PNT	;  $=
NDQ:	TRC C,D7PNT#D6PNT	;"
NPRM:	TRC C,D6PNT		;'
	PUSHJ P,GARGDQ	;GET ARG OR $Q.
	PUSHJ P,LWTPUP
LCTGNR:	PUSHJ P,LCT
	JRST GSNLRT

;$< AND $$< SET GTMALT, ETC. AS A SIGNAL TO SLRPIN
;TO READ SOME ALT'S AND THE INFIX ARG (IN OCTAL)
;BEFORE READING ANYTHING FROM THE TTY OR FILE OR VALRET, ETC.
ALTLES:	PUSHJ P,GTVAL
	TLNE C,10
	JRST ALTLE4
	MOVEI D,1	;CAUSE 1 ALTMODE TO BE READ.
	JRST ALTLE2

A2LES:	PUSHJ P,GTVAL
	TLNE C,10
	JRST ALTLE4
	MOVEI D,2	;READ 2 ALTMODES.
ALTLE2:	MOVEM D,GTMALT
	MOVE A,ARG1
	MOVEM A,GTFTEM	;HERE GOES ARG FOR SLRPIN TO READ.
	MOVE A,[440300,,GTFTEM]
	ILDB D,A
	TLNE A,770000
	JUMPE D,.-2
	ADD A,[30000,,]
	MOVEM A,GTPNTR	;SLRPIN GETS OCTAL DIGITS FROM THIS BP.
	POPJ P,

ALTLE4:	7TYPE [ASCIZ /$</]
	POPJ P,

LWTPUT:	MOVSI C,SYLOCT
LWTPU1:	PUSH P,B
	MOVE B,LWTP	;SET $Q FROM D .
	ADDI B,2
	CAIL B,LWTTAB+2*LWTLNG
	MOVEI B,LWTTAB
	MOVEM D,(B)
	MOVEM D,LWT
	MOVEM C,1(B)
	MOVEM C,LWT+1
	MOVEM B,LWTP
	JRST POPBJ

LWTPUP:	PUSHJ P,LWTPU1
	MOVE A,D
	JRST GFROBP

GARGDQ:	MOVE D,LWT	;GET ARG OR $Q IN D.
	SKIPE ARG1+1
	MOVE D,ARG1
	POPJ P,

NCTLXC:	PUSH P,SCH	; ;
	PUSH P,AR
	PUSH P,ODF
	SAVE TTYFLG
	SKIPE TTYFLG
	SOS TTYFLG	;PRINT EVEN IF NOT ECHOING.
	PUSHJ P,NACXC
	REST TTYFLG
	POP P,ODF
	POP P,AR
	POP P,SCH
	JRST LCTGNR

N2ACXC:	MOVE A,[SCHMM,,SCHM]	;$$;
	BLT A,ODFM
NACXC:	MOVE A,[SCHMM,,SCH]	;$;
	BLT A,ODF
	PUSHJ P,GARGDQ
	PUSHJ P,LWTPUT
	PUSHJ P,@SCH
	JRST GSNLRT

NCART:	TLNE B,10000	;CARR RET, $CR
	JRST NCART2
	PUSHJ P,CRF
	TLZ F,STF
	MOVE D,[SCHM,,SCH]
	BLT D,ODF
	JRST GSNLRT

;POP THE . RING BUFFER IF 1ALTF IS SET IN B.
PLUNK2:	TLNN B,1ALTF
	POPJ P,
	MOVE A,PLCR
	MOVE D,LOCBF(A)
	SOSGE A
	MOVEI A,NLEVS-1
	MOVEM A,PLCR
	MOVEM D,LLOC
	POPJ P,

;DEPOSIT THE ARG, IF ANY, IN THE OPEN REGISTER, IF ANY.
;CLOSES THE REGISTER IN ANY CASE.
PLUNK1:	MOVEM F,PLUNKF	;(^] MUST KNOW IF ANY LOC. HAD BEEN OPEN)
	TLZE F,NROFL
	SKIPN ARG1+1
	JRST CPOPJ
	MOVE D,ARG1
	PUSHJ P,LWTPUT	;SET $Q TO VALUE BEING STORED,
	MOVE A,LLOCO
	PUSHJ P,DEPRMV	;UPDATE UNDEF SYM REFS FOR LOCATION,
	MOVE D,LWT	;(DEPRMV CLOBBERED D)
	JRST DEPF	;THEN STORE IN IT.

NTAB3:	PUSHJ P,GARGDQ
	TLNE B,1ALTF
	MOVSS D		;$TAB
	TLNN B,2ALTF	;$$TAB => DO EFFEC. ADDR. CALC.
	JRST NTAB5
	PUSHJ P,EASETU	;AC'S UGH BLETCH
	MOVEI A,D	;NEFECC WANTS IT LIKE THIS
	PUSHJ P,NEFECC	;SOLVE IT
	MOVE D,I1	;GET RESULT
NTAB5:	HLL D,FNYLOC	;LH OF D GETS FUNNYNESS OF LOC. TO OPEN.
	POPJ P,

NCART2:	PUSHJ P,PLUNK2	;$^M, POP . RING BUFFER.
	MOVE D,LLOC
NNL2:	PUSHJ P,CRF
UBRKNL:	PUSHJ P,PLOC	;SET . AND LOCATION OPEN.
	PUSHJ P,PAD
	TLNN F,STF
	CTYPE "/
	TLNE F,STF
	7TYPE [ASCIZ /$$!/]
	JRST NTAB2
NTAB:	PUSHJ P,NTAB3	;DEP ARG, CALC. ADDR TO OPEN.
	JRST NNL2	;GO OPEN IT.

;BEFORE CALLING, DISPATCHER CALLED PLUNK TO STORE ARG.
NNL:	PUSHJ P,PLUNK2	;^J, $^J. IF IS $^J, POP . RING BUFFER.
	MOVE D,LLOC	;GET POINT, INCREM BUT DON'T CHANGE LH.
	HRRI D,1(D)
	JRST NNL1	;GO CR, PRINT ADDR & CONTENTS.

NUPA:	PUSHJ P,PLUNK2
	MOVE D,LLOC	;UPARROW - SIMILAR BUT DECREMENT.
	HRRI D,-1(D)	;NOTE LH HAS FUNNYNESS (.USET OR DDT REF).
NNL1:	MOVEM D,LLOC	;CLOBBER RING BUFFER TOP SO WON'T PUSH.
	JRST NNL2

; \, $\, $$\
NBKSL:	PUSHJ P,NTAB3	;DEP. ARG, CALC. ADDR TO OPEN.
	MOVEM D,LLOCO	;OPEN BUT DON'T SET POINT .
	JRST NTAB2

NLBRAK:	MOVEI D,FTOC-PIN	;[, $[, $$[
NRBRAK:	ADDI D,PIN		;], $], $$]
	PUSH P,SCH
	HRRZM D,SCH
	PUSHJ P,NLRBK2
	POP P,SCH
	POPJ P,

A2XCL:	TLO F,STF	;$$!, SUPPRESS TYPEOUT.
	TLZ B,2ALTF	;(SO NTAB3 WON'T DO EFFEC ADDR CALC.)
	JRST NLRBK2

NSEMIC:	TLZ F,STF	;/, $/, $$/
NLRBK2:	PUSHJ P,NTAB3	;CALC ADDR TO OPEN.
	PUSHJ P,PLOC	;SET . .
;GET, MAYBE PRINT CONTENTS OF LOC. WHOSE ADDR IS IN LLOCO.
NTAB2:	PUSHJ P,LCT
	MOVE A,LLOCO
	TLZ F,NROFL
	PUSHJ P,FETCHF	;FUNNY FETCH SINCE MAY HAVE OPENED USET REF, ETC.
	JRST NXERR
	TLO F,NROFL
	PUSHJ P,LWTPUT
	TLNE F,STF
	JRST GSNLRT	;DON'T PRINT IF TYPEOUT SUPPR.
	PUSHJ P,@SCH
	JRST LCTGNR

;PUSH CONTENTS OF D ONTO . RING BUFFER.
PLOC:	MOVEM D,LLOCO
	CAMN D,LLOC
	POPJ P,
	AOS A,PLCR	;ADVANCE RING POINTER
	CAIL A,NLEVS
	SETZB A,PLCR
	EXCH D,LLOC
	MOVEM D,LOCBF(A)
	MOVE D,LLOC
	POPJ P,

NALTQ:	TLNE D,IFXF	;$Q
	JRST NALTQN	;JUMP IF NUM SUPPLIED
NALT0Q:	MOVE C,LWT
	MOVE D,LWT+1
	JRST EFLDNO

NALTQN:	JUMPE C,NALT0Q
	JUMPL C,NXERR
	CAILE C,10
	JRST NXERR
	MOVE A,LWTP
NLTQN2:	SUBI A,2
	CAIGE A,LWTTAB
	MOVEI A,LWTTAB+2*LWTLNG-2
	SOJG C,NLTQN2
	TLNE D,2ALTF
	MOVEM A,LWTP	;$$
	MOVE D,1(A)
	MOVE C,(A)
	JRST EFLDNO

	CONSTANTS

;$. - JOB'S PC. EXECUTED DURING EVFLD.
NALT.:	PUSHJ P,QJERR
	MOVE A,[-2,,NALT.B]
	SKIPN UINTWD(U)
	.USET USRI,A	;RUNNING
	TLNN C,10000
	SOS C,B		;RUNNING IN EXEC MODE?
	SKIPE UINTWD(U)
	MOVE C,PPC(U)
EFOCTJ:	MOVSI D,SYLOCT
	JRST EFLDNO	;GO PUSH VALUE ON STACK.

NALT.B:	.RUPC,,C
	.RUUOH,,B

ALTGRT:	SKIPE ARG1+1	;$>
	MOVE A,ARG1
	MOVSI B,-5
ALTGR2:	MOVE D,ALTGR3(B)
	AND D,LWT
	TDNN A,ALTGR3(B)
	IOR A,D
	AOBJN B,ALTGR2
	JRST GSOCTJ

ALTGR3:	777000,,;OP CODE.
	0 17,0	;AC FIELD
	@	;INDIRECT BIT
	(17)	;INDEX FIELD
	,,-1	;ADDRESS.

NSIGN:	TDCA A,C		;#
NSTAR:	IMUL A,C	;*
NMODE:	CAME B,D	;COMPUTE DOMINANT MODE.
	JRST APAT5	;MODES DIFFER, DEFAULT TO INSN.
	POPJ P,

NAMAND:	AND A,C		;&
	JRST NMODE

NPLUS:	ADD A,C		;+
	JRST NMODE

NMINUS:	SUB A,C		;-
	JRST NMODE

NSLASH:	PUSH P,B	;!
	IDIV A,C
	POP P,B
	JRST NMODE

FPLUS:	FADR A,C	;$+
	JRST FMODE

FMINUS:	FSBR A,C	;$-
	JRST FMODE

FSLASH:	FDVR A,C	;$!
	JRST FMODE

NSHIFT:	LSH A,(C)	;$_
	JRST NMODE

FSTAR:	FMPR A,C	;$*
	JRST FMODE

NFSC:	FSC A,(C)	;$$_
	JRST FMODE

NALTH:	MOVEI C,HLFW-TFLOT	;$H, $$H
NALTF:	ADDI C,TFLOT-PIN	;$F, $$F
NALTS:	ADDI C,PIN-FTOC		;$S, $$S
NALTC:	ADDI C,FTOC-D5PNT	;$C, $$C
ALTMPN:	ADDI C,D5PNT-D6PNT	;FROM $&, $$&
ALTPMN:	ADDI C,D6PNT-D7PNT	;FROM $', $$'
ALTDQN:	ADDI C,D7PNT-ALTNM0	;FROM $", $$"
ALTNMN:	ADDI C,ALTNM0		;FROM $#, $$#
NSET0:	MOVEI A,0
NSET:	HRRZM C,SCH(A)
	HRRZM C,SCHMM(A)
	TLNN B,20000	;SKIP IF $$
	JRST GSNLRT
	HRRZM C,SCHM(A)
	JRST LCTGNR

NALTD:	ADDI C,2	;$D, $$D
NALTO:	ADDI C,8	;$O, $$O
	MOVEI A,2
	JRST NSET

NALTR:	TLNE B,200000
	JRST NALTR2
	ADDI C,PADR-TOC	;$R, $$R
NALTA:	ADDI C,TOC	;$A, $$A
	MOVEI A,1
	JRST NSET

NALTT:	TLNN B,200000	;$T, $$T
	JRST NALTT2	;JUMP IF NO NUM SUPPLIED
	CAIG A,44
	SKIPG A
	JRST NXERR
	MOVEI C,36.
	DPB A,[300600,,SATPP]
	IDIV C,A
	MOVEM C,SATPC
NALTT2:	MOVEI C,SATP
	JRST NSET0

NALTR2:	SOJLE A,NAERR	;$NR, $$NR
	AOS C,A
	MOVEI A,2
	JRST NSET

ALTDQ:	TLNN B,200000	;$", $N", $$", $$N"
	JRST ALTDQN	;NO NUM
ALTDQ1:	PUSHJ P,GSOA	;INIT RUBOUT PROC. OF ASCII CHARS.
	 JRST ALTDQX	;IF RUB OUT ALL, RETYPE THE OP.
	SETZM GSSSYM
	MOVE C,[440700,,GSSSYM]
ALTDQ2:	PUSHJ P,ALTDQI	;READ CHAR, LET ^ AND ^Q QUOTE.
	JRST ALTDQ3	;RET. HERE IF WAS QUOTED.
	CAIN D,33
	JRST ALTDQR
ALTDQ3:	TLNN C,760000
	JRST ALTDQ4
	IDPB D,C
	JRST ALTDQ2

ALTDQI:	JSP W2,RCH
	CAIN D,^Q	;^Q => READ ANOTHER, DON'T SKIP.
	JRST SLRPIN
	CAIE D,"^	;^ => MAKE A CTRL CHAR.
	JRST CPOPJ1	;ELSE NOT QUOTED.
	JSP W2,RCH
	TRZ D,140
	POPJ P,

ALTPRR:	SKIPA B,[D6PNT]
ALTDQR:	MOVEI B,D7PNT
	MOVE A,GSSSYM
	POPJ P,

ALTDQ4:	TLNN B,20000
	JRST ALTDQ2	;ONLY ONE ALT

ALTDQP:	CTYPE "$
	PUSH P,B
	MOVE A,GSSSYM
	MOVSI B,SYLOCT
	SETOM UNRCHF
	SETOM UNECHF
	MOVEM A,ARG1
	MOVEM B,ARG1+1
	PUSHJ P,PLUNK1
	PUSHJ P,NNL
	PUSHJ P,ALTDQX	;RETYPE $$1" OR $$1' .
	POP P,B
	MOVE A,GSORET	;RETURN TO CALL TO GSOA.
	JRST -2(A)

;COME HERE FROM AN OPERATOR THAT READS STUFF, WHEN GSOA DOESN'T SKIP.
ALTDQX:	MOVE A,-1(W4)	;OP. BEING EXECUTED IS ON TOP OF FROB STACK.
	MOVE C,(W4)
	PUSHJ P,GFROBP
	JRST GSNLRT

ALTPRM:	TLNN B,200000	;$', $N', $$', $$N'
	JRST ALTPMN	;NO NUM
ALTPR1:	PUSHJ P,GSOA	;INIT. RUBOUT PROC. OF 6BIT CHARS.
	 JRST ALTDQX
	SETZM GSSSYM
	MOVE C,[440600,,GSSSYM]
ALTPR2:	JSP W2,RCH
	CAIL D,140	;LOWER CASE TO UPPER.
	SUBI D,40
	SUBI D,40	;STOP ON NON-6BIT CHAR, DON'T REREAD IT.
	JUMPL D,ALTPRR
	TLNN C,770000
	JRST ALTPR4
	IDPB D,C
	JRST ALTPR2

ALTPR4:	TLNN B,20000
	JRST ALTPR2	;ONLY ONE ALT
	JRST ALTDQP	;TWO, STORE THIS WD, RETURN TO ALTPR1.

ALTNM:	TLNN B,IFXF	;$#, $N#, $$#, $$N#.
	JRST ALTNMN	;NO NUMBER => SET TYPE OUT MODE.
	PUSHJ P,GSOA	;INIT RUBOUT PROC
	 JRST ALTDQX	;RETYPE "$1#" IF READ RUBOUT.
	PUSHJ P,ALTDQI	;READ CHAR, LET ^ AND ^Q QUOTE.
	 JFCL
ALTNM1:	MOVEI A,(D)
	JSP B,GSEVLJ	;WILL CALL AT .+1 TO RETYPE IF RUBBED.

;$# TYPEOUT ROUTINE. VALUE OF SYLL IN D.
ALTNM0:	7TYPE [ASCIZ/1#/]
	ANDI D,177
	CAIN D,"^	;UPARROW MUST BE QUOTED.
	JRST [7TYPE [ASCIZ/^Q^/] ? POPJ P,]
	CAIE D,33	;SINGLE CHARACTER TYPEOUT MODE RTN.
	CAIL D," 
	JRST TOUT	;ALTMODE, OR NOT CTL CHAR, JUST TYPE.
	CTYPE "^	;ELSE QUOTE WITH ^.
	ADDI D,100
	JRST TOUT

ALTAMP:	TLNN B,200000	;$&, $N&, $$&
	JRST ALTMPN	;NO NUM
	PUSHJ P,GSOA	;INIT. RUBOUT PROC.
	 JRST ALTDQX
	TLO F,LETFL+NNULFL	;MAKE SURE READ AS SYMBOL,
	TLZ F,PNTFL+NEGEFL
	CALL SLRPND	;READ THE NAME (AS SQUOZE, IN A)
	MOVEI B,D5PNT
	MOVE C,-1(W4)	;GET BACK THE INFIX ARG FOR SQUOZE FLAGS.
	LSH C,-2
	LSH C,32.
	IOR A,C
	POPJ P,

;:IF <COND-NAME> <ARG>
;$( ..... $)
KIF:	CALL RTOKEN	;READ CONDITION NAME.
	JUMPE B,KIF
	MOVSI A,-KIFTBL	;SEARCH TABLE FOR IT.
KIF1:	CAMN B,KIFTB1(A)
	 JRST KIF2	;FOUND.
	AOBJN A,KIF1
	ERSTRT [SIXBIT/CONDITION?/]

KIF2:	MOVEM A,-1(W4)	;ARRANGE TO RETYPE :IF AND CONDITION
	MOVEI A,KIFRB	;ON RUBOUT OR ^L.
	MOVEM A,(W4)	;(CAN ALSO RETRIEVE KIFTB1 IDX FROM -1(W4))
	SETZM NCOMNM	;DON'T LET GSOA CLOBBER WHAT WE JUST DID.
KIF4:	CALL RONUM	;READ ARG.
	JRST ALTDQX	 ;RUBBED BACK OUT OF ARG.
	JUMPE B,KIF4	;READ NOTHING => TRY AGAIN.
	MOVE C,-1(W4)	;GET KIFTB1 IDX OF CONDITION.
	MOVE D,LIMBO
	CAIN D,^M	;IF READ A CR, ECHO IT.
	 CALL CRF
	XCT KIFTB2(C)	;TEST CONDITION, ARG IN A.
	 JRST GSNLRT	;CONDITION TRUE.
	SETZ A,		;A USED AS PAREN COUNTER (CONDITION FALSE)
	SETOM INNCTL	;IGNORE ^V, ETC. IN FALSE CONDIT.
KIF3:	CALL RIN
	 JRST KIF3	;IGNORE RUBOUT.
	CAIN D,"(
	 AOJA A,KIF3	;( => INCREM. COUNT.
	CAIE D,")
	 JRST KIF3
	SOJG A,KIF3	;) => DECREM.
	SETZM INNCTL
	JRST GSNLRT	;THE ) THAT MATCHES THE 1ST (, DONE.

KIFRB:	7TYPE [ASCIZ/:IF /]	;GFROBP CALLS HERE, FROM ALTDQX.
	MOVE D,KIFTB1(D)	;D HAS 1ST WD OF SYL.
	CALL SIXTYP
	JRST TSPC

KIFTB1:
IRPS X,,E N L G LE GE
SIXBIT/X/
TERMIN
KIFTBL==.-KIFTB1

KIFTB2:
IRPS X,,N E GE LE G L
SKIP!X A
TERMIN
IFN .-KIFTB2-KIFTBL,.ERR 
;:DDTSYM FOO      EVALUATES FOO IN DDT SYM TAB.
KDDTSY:	CALL GTFROB	;READ SYMBOL (AS FROB, UNEVALUATED SYMBOL)
	JUMPE B,ALTDQX	;PASS SPACES.
	CAME B,[SYLSYM,,] ;NOT SYMBOL, DON'T EVAL.
	JRST GSDDTJ
	MOVEM A,SYM
	MOVE A,STBDDT
	CALL SLUP
	 2,,SEVLB	;DDT SYM TAB HAS BLOCK STR.
	 7TYPE [ASCIZ/?U/]
	MOVE A,1(A)	;FOUND, RETURN THE VALUE.
GSDDTJ:	MOVE B,[SYLSYM,,4^5]	;RETURN DDT REF.
	RET

;:SYMTYP <SYMBOL>
;VALUE IS 0 IF SYMBOL UNDEFINED, ELSE
;BIT 4.9 => HALF KILLED, BIT 4.8 => INITIAL SYM,
;BIT 4.7 => DEFINED BUT NOT IN CURRENT BLOCK OR CONTAINING BLOCK,
;BIT 4.6 => DDT-REFERENCE, BIT 4.5 => .USET VARIABLE.
;RH HAS ADDR OF STE IN DDT (WON'T BE VALID IF MOVE SYM TAB)
;RH WILL BE 0 FOR AN INSTRUCTION NAME. (4.8 WILL BE ON)
KSYMTY:	CALL GTFROB	;READ SYMBOL NAME.
	JUMPE B,ALTDQX
	CAME B,[SYLSYM,,]
	 RET		;NOT SYMBOL, RETURN.
	MOVEM A,SYM
	CALL SEVL	;TRY TO EVAL.
	 JRST KSYMT3
	ANDI A,-1
	MOVEI B,2	;ASSUME INITIAL, SET WHAT WILL BE BIT 4.8.
	CAIGE A,DDTEND
	CAIGE A,STBSPG*2000
	 TRZ B,2	;NOT INITIAL.
	IOR B,FNYLOC	;FUNNYNESS WILL GO IN BITS 4.5,4.6.
	ROT B,-3
KSYMT4:	MOVE D,(A)	;SEE IF HALF-KILLED.
	TLNE D,DELO
	 TLO B,4^5	;SIGN SET IF YES.
	HLL A,B		;ALSO HAVE ADDR OF STE IN RH.
	JRST GSOCTJ

KSYMT3:	CALL OPLK2	;NOT FOUND IN CURRENT BLOCK, TRY OP CODES AND OTHER BLOCKS.
	 JRST [SETZ A, ? JRST GSOCTJ]  ;NOT DEFINED.
	 JRST [MOVSI B,1^5 ? JRST KSYMT4]  ;FOUND IN OTHER BLOCK.
	MOVSI A,2^5	;OP CODE, SAY IS INITIAL.
	JRST GSOCTJ

NALTM:	SKIPN ARG1+1
	JRST NALTM2
	MOVE D,ARG1
	MOVEM D,MSK
	JRST LCTGNR

NALTM2:	MOVEI A,MSK	;NO ARG - RETURN THE FUNNY LOCATION OF THE MASK (IN DDT)
	JRST GSDDTJ	;RETURN EVALUATED FUNNY SYMBOL.

NALTN:	SKIPA D,[JUMPE I1,]
NALTW:	MOVSI D,(JUMPN I1,)
	HLLM D,NLTNWX
	PUSHJ P,NAENW	;GET "ARGS"
	SETCAM A,WRD'
NALTN2:	PUSHJ P,GCBLKP	;GET BLOCK TO READ
	JRST NLTL2
NALTN4:	MOVE I1,(A)
	EQV I1,WRD
	AND I1,MSK
	XCT NLTNWX	;SKIP UNLESS SATISFIES CONDITION.
	PUSHJ P,ENWPNT	;PRINT VALUE, SET $Q, TEST FOR END OF SCREEN.
NALTN5:	AOBJN A,NALTN4
	PUSHJ P,OUTTST	;SKIP IF OUTPUT IS GOING ANYWHERE.
	JRST NLTL2	;IT ISN'T, QUIT SEARCHING.
	JRST NALTN2

NALTE:	SKIPN SYSSW
	SKIPE DDTSW
	JRST NALTEW
	PUSHJ P,NAENW
	HRRZM A,WRD
	PUSHJ P,EASETU
NALTE2:	PUSHJ P,GCBLKP
	JRST NLTL2
NALTE4:	PUSHJ P,NEFECC
	CAMN I1,WRD
	PUSHJ P,ENWPNT
NALTE5:	TLNE A,177
	AOBJN A,NALTE4
	PUSHJ P,OUTTST	;STOP IF OUTPUT IS BEING THROWN AWAY.
	 JRST NLTL2
	TLNN A,177
	AOBJN A,NALTE4
	JRST NALTE2

GCBLKP:	PUSHJ P,GCBLKR
	POPJ P,
	SUB B,A
	SETCA B,	;NEGATE AND SUBTRACT ONE
	HRL A,B
	JRST CPOPJ1
ENWPNT:	PUSH P,D
	MOVE D,C
	SOS D
	PUSH P,C
	HRRZ C,A
	CAIL C,AC0
	CAILE C,AC0+17
	SKIPA
	SUBI C,AC0	;WIN FOR ACS
	DPB C,[1200,,D]	;GET REAL ADR IN D
	MOVE C,(A)	;GET CONTENTS
	PUSH P,A	;SAVE AOBJN POINTER
	PUSHJ P,CRF
	PUSHJ P,MORFLS
	JRST POP4N2
	ANDI D,-1
	PUSHJ P,PLOC
	PUSH P,C
	PUSHJ P,PAD
	7TYPE [ASCIZ \/   \]
	POP P,D
	PUSHJ P,ENWPAT
	PUSHJ P,LCT
	POP P,A
POPCDJ:	POP P,C
	POP P,D
	POPJ P,

POPAN2:	POP P,A
	JRST NLTL2

POP4N2:	SUB P,[4,,4]
	JRST NLTL2

ENWPAT:	PUSHJ P,LWTPUT
	JRST @SCH

EASETU:	.ACCESS USRI,[0]
	MOVE A,[-20,,AC0]
	.IOT USRI,A
	POPJ P,

NALTEW:	PUSH P,MSK
	MOVEI D,-1
	MOVEM D,MSK
	PUSHJ P,NALTW
	POP P,MSK
	POPJ P,

;COMPUTE EFFECTIVE ADDRESS, CLOBBERS W4
NEFECC:	SAVE D
	SAVE A
	MOVEI I1,14
	MOVEM I1,TEM
	MOVE D,(A)
NEFEC2:	LDB B,[220400,,D]
	JUMPE B,NEFEC3
	MOVE B,AC0(B)
	ADD B,D
	HRR D,B
NEFEC3:	HRRM D,TEM2
	TLNN D,20
	JRST NEFEC6
	HRR A,D
	SOSE TEM
	PUSHJ P,RFETCH
	JRST NEFEC6
	JRST NEFEC2

NEFEC6:	HRRZ I1,TEM2
	JRST POPADJ

NAENW:	JUMPL U,QJERR
	SKIPN SYSSW
	.USET USRI,[.RMEMT,,HIGH]
	MOVEI C,0
	SKIPE ARG1+3
	HRRZ C,ARG1	;GET 1ST ARG IF 2ND EXISTS
	MOVE D,HIGH	;HIGH MAY BE 1,,0
	SOS D
	SKIPE ARG1+5
	HRRZ D,ARG1+2	;GET 2ND ARG IF 3RD EXISTS
	MOVE A,LWT	;GET LWT OR LAST ARG IN A
	SKIPE ARG1+1
	MOVE A,ARG1
	SKIPE ARG1+3
	MOVE A,ARG1+2
	SKIPE ARG1+5
	MOVE A,ARG1+4
	POPJ P,

GCBLKR:	TDZA B,B	;GET BLOCK 
GCBLKW:	MOVSI B,400
	CAMN C,D
	POPJ P,	;TERMINATE FROM GCBLK4
	CAMLE C,D
	JRST NAERR
	SKIPE SYSSW
	JRST GCBLKS
	CAML D,HIGH
	JRST NXERR
	CAIG C,17
	JRST GCBLKA	;ACS
GCBLK1:	LDB A,[121000,,C]
	IOR A,[2000+USRI,,400000+VPAGE_9]
	IOR A,B
GCBLK3:	.CBLK A,
	JRST GCBLK2
	LDB A,[1200,,C]
	TRO A,400000
	TRZ C,1777
	ADDI C,2000
	CAMLE C,D
	JRST GCBLK4
	MOVEI B,401777
	JRST CPOPJ1

GCBLKS:	JUMPN B,NXERR	;SYS
	CAIG D,20
	JRST NXERR
	CAIGE C,20
	MOVEI C,20
	LDB A,[121100,,C]
	IOR A,[1000,,400000+VPAGE_9]
	JRST GCBLK3

GCBLK2:	TRZ C,1777
	ADDI C,2000
	CAMG C,D
	JRST GCBLK1
	POPJ P,

GCBLK4:	LDB B,[1200,,D]
	TRO B,400000
	MOVE C,D	;WILL CAUSE POPJ NEXT TIME
	JRST CPOPJ1

GCBLKA:	PUSHJ P,EASETU	;ACS UGH BLETCH
	MOVEI A,AC0
	ADD A,C
	MOVEI C,20
	MOVE B,D
	CAILE D,17
	MOVEI B,17
	ADDI B,AC0
	CAIGE D,20
	MOVEI D,20
	JRST CPOPJ1

N2ALTZ:	HRRZ C,ARG1	;GET ZERO OR FIRST ARG IF SUPPLIED
	.USET USRI,[.RMEMT,,HIGH]
	MOVE D,HIGH	;HIGH MAY BE 1,,0
	SOS D
	SKIPE ARG1+3
	HRRZ D,ARG1+2
	MOVE I1,ARG1+4	;GET ZERO OR THIRD ARG IF SUPPLIED
N2LTZ2:	PUSHJ P,GCBLKW
	JRST NLTL2
	MOVEM I1,(A)
	HRLS A
	AOS A
	BLT A,(B)
	CAIE C,20
	JRST N2LTZ2
	.ACCES USRO,[0]	;WIN FOR ACS
	MOVE A,[-20,,AC0]
	.IOT USRO,A
	JRST N2LTZ2

NCOL:	JUMPE D,NCOM	;:, $:, $$:. CHECK FOR COLON-COMMAND.
	CAME D,[200000,,]
	JRST NCOL2
	TLNE B,1ALTF+2ALTF	;CHECK FOR $:, $$:.
	JRST NACOL
	JUMPL U,JERR	;DEFINE SYM, MUST HAVE JOB.
	PUSH P,C
	SUB W4,[2,,2]	;POP THE COLON OFF FROB TABLE.
	MOVEI D,GFLD1	;ERRORS SHOULDN'T RE-POP IT.
	MOVEM D,ERRSTL
	PUSHJ P,EVARGS
	POP P,SYM
	HRRZ D,LLOCO
	SKIPE ARG1+1
	MOVE D,ARG1
	PUSHJ P,DEFIN
	PUSHJ P,LCT
	JRST ERR6	;NORMAL RETURN WOULD ASSUME FROB TAB UNCHANGED.

NCOL2:	EXCH C,-1(W4)
	EXCH D,(W4)
	PUSH W4,C
	PUSH W4,D

;HANDLE :-COMMANDS, COME AFTER RFEADING ":".
;CF - WAS $: OR $^K, LOAD SYMS.
;LETFL - DEV OR SNAME SPEC'D - DON'T TRY USUAL DIRS.
;EITHER ONE -> DON'T USE BUILT-IN COMMANDS.
NCOM:	TLZ F,CF+LETFL
	TLNE B,1ALTF
	TLO F,CF
	PUSHJ P,GSOA	;COME BACK HERE ON RUBOUT.
	 JRST ALTDQX	;(IF COLON RUBBED OUT)
	PUSHJ P,NCOMI	;INIT. DEV, SNAME, LETFL.
NCOM1:	PUSHJ P,RTOKEN	;B_COMMAND NAME (6BIT).
	CAIN D,33	;IF NO TOKEN, JUST ALTMODE,
	JUMPE B,NCOMC	;READ COMMENT.
	SKIPL TOKTRM
	JUMPE B,NCOM1	;IF NULL, AND NOT ^M, GET ANOTHER.
	JUMPE B,NLTL2	;NULL COMMAND
	CAIN D,":	;COLON - SET DEV, INHIBIT BUILT-IN COMMANDS.
	JRST [HLRM B,SFILE ? JRST NCOM0]
	CAIN D,";	;SEMICOLON SIMILAR BUT SET SNAME.
	JRST NCOMS
	MOVEM B,NCOMNM	;REMEMBER NAME OF :-COMMAND.
	TLNE F,CF+LETFL	;BUILT IN CMDS INHIBITED -> GO LOAD FILE..
	JRST NCOM3
NCLOOP:	CAMN B,NCTAB(A)
	JRST NCL2	;FOUND IN COMMAND TABLE.
	CAIGE A,NLCOM-2
	AOJA A,[AOJA A,NCLOOP]
NCOM3:	MOVEM B,SYSN2	;DUMMY UP "NAME^K".
	JRST ACTRLK	;TRY ^K'ING IT

NCL2:	HRRZ A,NCTAB+1(A)	;BUILT-IN COMMAND.
	JRST (A)

NCOMS:	MOVEM B,SFILE+4
	PUSHJ P,RLINE
	MOVEM B,LSNAM	;SET CURRENT DDT SNAME.
NCOM0:	TLO F,LETFL
	JRST NCOM1

NCOMPT:	CTYPE ":	;RTN TO RETYPE A :-CMD'S NAME
	PUSHJ P,SIXTYP	;IF THE COMMAND IS RUBBED AS A SYLLABLE
	JRST TSPC	;(EG AFTER THE COMMAND CALLED GSOA,
	   ;WHICH WILL REPLACE THE : ON THE FROB STACK
	   ;WITH A SYLLABLE THAT WILL COME HERE TO BE RETYPED)
NCOMI:	MOVEI D,'DSK
	HRRM D,SFILE
	MOVE D,MSNAM	;DEFAULT IS DSK:<MSNAME>
	MOVEM D,SFILE+4
	TLZ F,LETFL	;BUT CAN TRY SYS; AND SNLIST.
	POPJ P,

NCOMC:	JSP W2,RCH	;COMMENT CONTINUES THRU NEXT ALTMODE.
	CAIN D,^M
	 CALL CRF
	CAIN D,33
	JRST NCOM1
	JRST NCOMC

;:JCL
JJCL:	PUSHJ P,QIJERR	;MUST HAVE INFERIOR OPEN TO RECEIVE .BREAK .
	SKIPN TOKTRM
	PUSHJ P,RLINE	;ELSE READ IN COMMAND,
	PUSH P,[NLTL2]

;RLINE MUST HAVE BEEN CALLED BEFORE CALLING JCL .
;SET JOB'S COMMAND BUFFER.
JCL:	MOVEI W1,UCHBUF(U)

;W1 HAS ADDR OF AOBJN PTR,
;READ A LINE INTO SYMTAB SPACE, PUT AOBJN TO IT THERE.
JCL0:	PUSH P,W1
	PUSHJ P,ELEC0	;FLUSH EXISTING COMMAND BUFFER.
	SKIPE TOKTRM	;IF ":JCL^M", LEAVE IT CLEAR.
	JRST POPW1J
	HRRZ B,GSCHRP	;GET PTR RE-READING FROM,
	HRRZ D,GSCHRQ	;AND PTR TO END,
	SUBI D,-1(B)	;MAX NUM. WDS WILL NEED TO HOLD COMMAND.
	PUSHJ P,ALLOC	;GET THAT MANY IN SYMTAB SPACE,
	MOVEM A,@(P)
	MOVEI B,(A)	;MAKE B.P. INTO OBJECT JUST ALLOCATED.
	HRLI B,440700
JCL2:	PUSHJ P,SLRPIN	;THEN READ CHARS AND STUFF INTO SPACE OBTAINED.
	IDPB D,B
	CAIN D,^M
	JRST POPW1J	;UNTIL CR.
	JRST JCL2

NGDEV:	SKIPN D	;GET DEVICE NAME
	POPJ P,
	CAMN D,[300000,,]
	JRST NGDEV4
	SKIPL C
	CAMLE C,4
	POPJ P,
	MOVE C,NGDTAB(C)
NGDEV4:	HLRZ D,C
	POPJ P,

NGDTAB:	SIXBIT /DSK/
	SIXBIT /UT1/
	SIXBIT /UT2/
	SIXBIT /UT3/
	SIXBIT /UT4/

NBITE:	SKIPGE D
	JRST NBITE2
	CAME D,[200000,,]
	POPJ P,
	MOVEM C,SYM
	MOVEI W2,NBITET
	MOVEI W1,SYM
	MOVE D,[JRST  [TRC D,40
		IDPB D,A
		POPJ P,]]
	SETZM (W2)
	MOVE A,[440600,,(W2)]
	CALL .SPT
	MOVSI D,300000
	MOVE C,NBITET
	POPJ P,

NBITE2:	PUSH W4,C	;OPERATOR, REPUSH
	PUSH W4,D
	SETZB C,D
	POPJ P,

NACS:	JUMPE D,NXERR	;$^S, $$^S, NEED ARG.
	TLNE B,20000
	PUSHJ P,DDTMSN
	MOVEM C,LSNAM
	.SUSET [.SSNAM,,C]
	MOVE A,C
	PUSHJ P,RRFL3	;PUT SNAME IN SNLIS1 .
	JRST NLTL2

NCTLS:	JUMPE D,GSNLRT
	SKIPGE UCHNLO	;DON'T USET UNLESS INFERIOR.
	.USET USRI,[.SSNAM,,C]
	JRST NLTL2

;BREAKPOINT ROUTINES
;(BPLF=>BPT NON VALUE COMMAND)

NALTB:	SKIPE ARG1+1
	JRST NBPS1
	TLNE B,200000
	JRST NBPS2	;$NB, $$NB
	TLNN B,20000
	JRST NBPS6
	SKIPN UINTWD(U)
NRERR:	ERSTRT [SIXBIT/JOB RUNNING?/]
	MOVEI D,B1ADR+1(U)	;$$B
	HRLI D,-1(D)	;FLUSH ALL BPTS
	SETZM B1ADR(U)
	BLT D,BPEND-1(U)
	JRST LCTGNR

NBPS1:	MOVE D,ARG1
	TLNN B,200000
	JRST NBPS3
	JUMPE A,NBPSF	;N$0B	;FLUSH BPT AT N.
	TRO F,BPLF	;N$MB	;ADD BPT M
NBPS2:	CAIL A,1	;ENTER HERE FOR $$NB, FLUSH BPT N
	CAILE A,11	;ALLOW $9B FOR HACKS IN USER AREA
	JRST NAERR
NBPS7:	IMULI A,BPL
	ADDI A,B1ADR-BPL(U)
	TRZN F,BPLF
	JRST GSDDTJ
NBPS5:	SKIPN UINTWD(U)
	JRST NRERR	;DON'T HACK BPTS WHILE RUNNING
	JUMPE D,NBPS9
	PUSH P,A	;INSERTING, CHECK FOR DUPLICATE
	PUSHJ P,NBPS4
	CAIN C,(D)
	MOVEM A,(P)	;USE SAME SLOT
	PUSH P,D
	MOVEI A,(D)	;READ CONTENTS OF PLACE TO PUT BREAKPOINT,
	PUSHJ P,RFETCH
	 JRST NXERR
	PUSHJ P,DEP	;STORE BACK TO UNPURIFY OR TYPE PUR?
	POP P,D		;-> PLACE TO PUT BPT.
	POP P,A		;-> BREAKPOINT SLOT.
NBPS9:	MOVEM D,(A)
	SETZM 1(A)
	SETZM 2(A)
	SUBI A,B1ADR(U)
	PUSH P,B
	IDIVI A,BPL
	POP P,B
	PUSHJ P,BUTOP1
	JRST LCTGNR

NBPS6:	MOVE A,UINTWD(U)	;$B
	CAIL A,1	;FLUSH CURRENT BPT
	CAILE A,10
	JRST NXERR
	MOVEI D,0
	TRO F,BPLF
	JRST NBPS7

NBPS3:	PUSHJ P,NBPS4	;N$B, N$$B
	SKIPN C
	JRST NBPS5
	ERSTRT [SIXBIT/TOO MANY BPTS?/]

NBPS4:	MOVEI A,B1ADR(U)
NBPS4A:	HRRZ C,(A)
	XCT @(P)
	JRST CPOPJ1	;WIN
	ADDI A,BPL
	CAIGE A,BPEND(U)
	JRST NBPS4A
	JRST CPOPJ2	;LOSE

NBPSF:	PUSHJ P,NBPS4	;N$0B, FLUSH BPT AT N (WHICH IS IN D)
	CAIN C,(D)	;THIS INSN XCT'D BY NBPS4.
	CAIA	;FOUND BPT AT N.
	JRST NXERR	;NONE.
	SETZM (A)	;FLUSH THE BPT.
	JRST LCTGNR

LISTB:	PUSH P,U
LISTB0:	MOVE A,(P)	;(P) HAS USR IDX + BPL*<NUM OF NEXT BPT>
	MOVE D,B1ADR(A)
	JUMPE D,LISTB1	;THIS BPT NOT IN USE.
	MOVEM D,LWT
	PUSHJ P,CRF
	SUBI A,(U)
	IDIVI A,BPL	;NUM OF BPT
	CTYPE "1(A)
	7TYPE [ASCIZ/   /]
	PUSHJ P,HLFW 	;PRINT ADDR TO OPEN,,ADDR OF BPT.
	MOVE A,(P)
	MOVE D,BPCON(A)
	MOVEM D,LWT
	CTYPE ^I
	PUSHJ P,PIN	;PRINT CONDITIONAL BREAK INSN.
	MOVE A,(P)
	MOVE D,B1CNT(A)	;PROCEDE COUNT
	CTYPE ^I
	PUSHJ P,FTOC
LISTB1:	MOVEI A,BPL
	ADDB A,(P)	;ADVANCE TO NEXT BPT.
	CAIGE A,NBP*BPL(U)
	JRST LISTB0
	JRST POPAN2	;FLUSH TOP WD OF PDL, JRST NLTL2

NALTI:	HRRZ D,ARG1	;$I
	JUMPE D,NALTI2
	TLO D,3
	TLNE B,200000
	HRL D,A	;USE INFIX NUM ARG
	TLO D,4
	TLNE D,777770
	JRST NAERR
NALTI2:	MOVEM D,MARCON
	.USET USRI,[.SMARA,,MARCON]
	JRST NLTL2
;$$^M - UNPURIFY OPEN LOCATION IF ANY, THEN STORE ARG.
;NOTE THIS OPERATOR CAN'T HAVE ITS ARG EVALUATED AND PLUNK
;CALLED BEFORE DISPATCH IN THE NORMAL WAY SINCE UNPURIFICATION
;WON'T HAVE BEEN DONE, CAN'T HAVE ARGS EVALLED BUT CALL PLUNK
;ITSELF SINCE UNDEF REFS WOULD BE ILLEGAL, SO MUST EVAL ARGS ITSELF.

N2ACM:	TLNN F,NROFL	;DO'NT UNPURIFY IF NO LOCATION OPEN.
	JRST N2ACM1
	MOVE A,LLOCO	;GET ADDR OF OPEN LOCATION, UNPURIFY PAGE.
	PUSHJ P,UNPUR0
N2ACM1:	MOVEI A,GFLD1	;WILL NOW POP THE $$^M OFF FROB STACK
	MOVEM A,ERRSTL	;SO ERRORS SHOULDN'T POP IT.
	SUB W4,[2,,2]
	PUSHJ P,EVARGS	;EVALUATE THE PREVIOUS FROBS.
	PUSHJ P,PLUNK1	;DEPOSIT THE ARG IF ANY.
	PUSHJ P,NLTL2
	JRST ERR6	;CAN'T JUST POPJ SINCE HAVE FIDDLED WITH W4.

UNPURE:	SKIPN DDTSW	;:UNPURE LEGAL ON INFERIOR OR SELF.
	PUSHJ P,QIJERR
	PUSHJ P,RONUM	;READ ADDRESS OF LOC. TO UNPURIFY.
	 JRST ALTDQX	 ;(TO RUB OUT THE :UNPURE)
	JUMPE B,UNPUR2	;NO ARG => UNPURIFY ALL BUT ABS PAGES.
	PUSH P,[NLTL2]

;UNPURIFY THE PAGE THE ADDRESS IN A LIES IN.
UNPUR0:	PUSHJ P,VPAGET	;GET FRESH PAGE TO COPY THAT PAGE INTO.
	ANDI A,-2000	;GET ADDR OF START OF PAGE,
	.ACCES USRI,A
	MOVE B,[-2000,,VPAGAD]
	.IOT USRI,B	;COPY OLD PAGE INTO FRESH PAGE.
	LSH A,-10.
	STDCL CORBLK,[1000,,700000 ? 1000,,USRI ? A
		1000,,-1 ? 1000,,VPAGE]
	JRST ERR	;STICK THE COPY IN PLACE OF OLD PAGE.
	JRST VPAGRT	;LET GO OF THE COPY.T 

UNPUR2:	.USET USRI,[.RMEMT,,D]
	SETZ A,		;A -> 1ST WD OF NEXT PAGE TO HANDLE.
UNPUR3:	CAML A,D
	JRST NLTL2	;ALL PAGES HANDLED.
	PUSHJ P,UNPUR1	;UNPURIFY THIS PAGE IF NEC.
	 JFCL
	ADDI A,2000
	JRST UNPUR3	;GO ON TO CHECK NEXT PAGEOS 

;A HAS ADDR, UNPURIFY PAGE THAT ADDR LIES IN
;IF PAGE IS READ-ONLY OR SHARED, AND IS NOT ABSOLUTE.
;SKIP-RETURNS IF DID NOT UNPURIFY.
UNPUR1:	PUSH P,A
	LDB B,[121000,,A]	;GET PAGE NUM,
	STDCAL CORTYP,[1000,,USRI ? B ? 2000,,B ? 2000,,A ? 2000,,C ? 2000,,C]
	POP P,A
	ANDI C,-1
	JUMPE C,POPJ1	;NO PAGE OR ABS PAGE, DO NOTHING.
	SOJG C,UNPUR0	;SHARED PAGE, UNPURIFY.
	JUMPG B,UNPUR0	;READ-ONLY, UNPURIFY.
	JRST POPJ1

APAT:	PUSHJ P,APATCK	;CHECK WHETHER CAN PATCH THIS JOB.
	MOVE D,[SQUOZE 0,PATCH]
	PUSHJ P,SEVLD
	SKIPA D,[SQUOZE 0,PAT]
	JRST APAT1
	PUSHJ P,SEVLD
	MOVEI D,50
APAT1:	HRRZM D,PATCHL(U)	;LOOK UP PATCH, SET RH OF PATCHL(U).
	MOVE A,LLOCO	;GET LOCATION OPEN NOW
	HRLM A,PATCHL(U)	;SAVE LOC. PATCHED FROM.
	PUSHJ P,FETCH	;GET CONTENTS OF LOC OPEN
	JRST NPERR
	PUSH P,D
	HRRZ D,PATCHL(U)	;GET LOCATION OF START OF PATCH
	PUSHJ P,NNL2
	MOVE D,(P)
	PUSHJ P,ENWPAT	;SET $Q AND PRINT.
	POP P,A
APAT5:	JSP B,GSEVLJ	;RETURN SYLL WHICH WILL RUB
	CTYPE "<	;OUT AS AN INSTRUCTION
	PUSHJ P,PIN
	MOVEI D,">	;BETWEEN ANGLE BRACKETS.
	JRST TOUT

NPERR:	SETZM PATCHL(U)
AEPAT:	SKIPN PATCHL(U)	;^], ERROR IF NO PATCH.
	JRST NXERR
	PUSHJ P,APATCK	;ERROR IF CAN'T WRITE THIS JOB.
	SKIPE ARG1+1	;IF HAVE ARG, PUT 1ST JUMPA BACK IN .+1.
	JRST AEPAT5
	MOVE A,PLUNKF	;IF A LOC. HAD BEEN OPEN, 1ST JUMPA IN IT.
	TLNE A,NROFL	;OTHERWISE 1ST JUMPA IN .+1 .
	SOS LLOC
AEPAT5:	PUSH P,B
	TLZN B,1ALTF	;FOR $^], STORE THE INSN THE PATCH
	JRST AEPAT1
	HLRZ A,PATCHL(U)	;WILL REPLACE,THEN LINEFEED.
	PUSHJ P,FETCH
	JRST NXERR
	PUSHJ P,PDEP
AEPAT1:	PUSHJ P,AEPAT2
	PUSHJ P,AEPAT3	;PUT IN JUMPA'S BACK
	MOVEI D,-3(D)
	EXCH D,LLOC
	AOS D
	EXCH D,PATCHL(U)
	HRLI D,(JUMPA 3,)
	POP P,B
	TLZE B,1ALTF
	HRLI D,(JUMPA 2,)	
	PUSHJ P,PDEP
	MOVE D,[SQUOZE 0,PATCH]
	MOVEM D,SYM
	HRRZ D,PATCHL(U)
	PUSHJ P,DEFIN
	SETZM PATCHL(U)	;NO LONGER PATCHING.
	JRST NLTL2

AEPAT2:	HLRZ D,PATCHL(U)
AEPAT3:	MOVEI D,1(D)
	HRLI D,(JUMPA 1,)
PDEP:	PUSH P,D
	PUSHJ P,NNL	;LINE FEED
	MOVE D,(P)
PDEPU:	PUSHJ P,ENWPAT
	HRRZ A,LLOC
	PUSHJ P,DEPRMV	;UPDATE UNDEF SYM REFS FOR LOCATION,
	REST D
	JRST DEP	;STORE IN IT.

AUPAT:	PUSHJ P,APATCK	;ERROR IF CAN'T PATCH THIS JOB.
	TLNN F,NROFL	;^^
	JRST NXERR
	MOVE A,LLOCO
	PUSHJ P,FETCH
	JRST NXERR
	MOVE A,D
	TLC D,(JUMPA 2,)
	TLNN D,-1
	JRST AUNPA1
AUNPA2:	PUSHJ P,FETCH
	JRST NXERR
	PUSH P,[NLTL2]
	PUSH P,D
	JRST PDEPU

AUNPA1:	MOVEI W1,50.
AUNPA3:	PUSHJ P,FETCH
	JRST NXERR
	TLC D,(JUMPA 1,)
	TLNN D,-1
	SOJA A,AUNPA2
	SOJL W1,NXERR
	AOJA A,AUNPA3

APATCK:	SKIPN DDTSW	;CAN PATCH SELF.
	SKIPG UCHNLO	;SYS AND INFERIORS.
	JUMPGE U,CPOPJ
	JRST QIJERR

KVP:	SETOM XCRFSW	;:VP - SAY SHOULDN'T TYPE CRLF WHEN PROCEDE.
	PUSH P,[PROCDT]	;GO PROCEDE AFTER TURN ON TYPEOUT.
	CAIA
KVK:	PUSH P,[NLTL2]	;:VK - GO CRLF AND MAYBE * AFTER TURN ON.
	CAIA
KV:	PUSH P,[LCTGNR]	;:V
	SKIPE INPTR	;TYPED IN ON TTY, TURN ON TYPEOUT.
	 SOSGE TTYFLG	;ELSE JUST CANCEL 1 ^W
	SETZM TTYFLG
	POPJ P,

QSN:	CALL FORMF
	MOVSI W2,-NLCOM/2 ;AOBJN -> COMMANDS.
QSNLP1:	HLRZ B,NCTAB+1(W2)
	JUMPE B,QSNLP2	;IGNORE CMDS WITHOUT BLURBS.
	CALL MORFLS	;TEST FOR BOTTOM OF SCREEN.
	 JRST NLTL2	 ;(FLUSHED)
	MOVE D,NCTAB(W2)
	CALL SIXTYP	;TYPE NAME OF COMMAND.
	CTYPE ^I
	7TYPE (B)	;TYPE THE BLURB.
	CALL CRF
QSNLP2:	ADDI W2,1
	AOBJN W2,QSNLP1
	JRST NLTL2

SLEEP:	CALL RONUM
	 JRST ALTDQX	;RETYPE ":SLEEP " IF RUB OUT OF RONUM.
	SKIPN B
	MOVEI A,15.
	.SLEEP A,
	JRST NLTL2

GAG:	PUSHJ P,RONUM
	 JRST ALTDQX	;IF RUB BACK OUT OF RONUM, TYPE ":GAG "
	JUMPE B,NXERR
	SKIPE A		;CLI INT ENABLED IFF NOT GAGGED.
	.SUSET [.SIMASK,,[BCLI]]
	SKIPN A
	.SUSET [.SAMASK,,[BCLI]]
	JRST NLTL2
;OP TYPES (IN W1):  MSG = 1	SEND = 0
;MAIL, BUG, MAILA, BUGA,   NEGATIVE, -1 IN RH.
;BIT 3.1 ON => MAIL OR BUG, OFF => MAILA OR BUGA.
;BIT 3.2 ON => MAIL OR MAILA, OFF => BUG OR BUGA.
MAIL:	MOVNI W1,1	;OP. TYPE IS MAIL.
	JRST MAIL0

SEND:	TDZA W1,W1	;OP. TYPE IS SEND.
MAILA:	HRLOI W1,-2	;OP. TYPE IS MAILA.
MAIL0:	PUSHJ P,BUGLOG	;MAYBE SAY (LOGIN?)
	PUSHJ P,RTOKEN	;READ FN1 TO USE.
	JUMPE B,.-1
MAIL1:	MOVEM B,CLUFN1
	PUSHJ P,BUGSND	;CHANGE SEND TO MAIL IF TARGET NOT LOGGED IN.
	PUSHJ P,VPAGET	;GET A FRESH PAGE TO BUFFER THE MESSAGE.
	MOVE C,[010700,,VPAGAD-1]
	JUMPGE W1,BUGNCR
	MOVEI D,^M	;FOR MAIL, PUT CRLF IN BUFFER.
	IDPB D,C
	MOVEI D,^J
	IDPB D,C
BUGNCR:	PUSHJ P,MSGNAM	;PUT THIS USER'S UNAME IN BUFFER.
	SKIPE W1	;EXCEPT FOR SEND, PUT DATE IN BUFFER.
	PUSHJ P,BUGDAT
	PUSHJ P,BUGTIM	;PUT TIME IN BUFFER.
BUGRD:	TLNE F,RUBFL	;IF :BUG, RE-READ "BUG FOO " TO PUT IN MESSAGE.
	 JRST [PUSHJ P,SLRPIN ? JRST BUGRD1]
	PUSHJ P,RIN	;NOW READ IN THE MESSAGE.
	 JRST BUGRUB	;RIN DOESN'T SKIP IFF RUBOUT.
	CAIE D,^_
	CAIN D,^C
	 JRST BUGDON	;^_ OR ^C => END OF MESSAGE.
	CAIN D,^L
	 JRST BUGFF	;^L => RETYPE BUFFER'S CONTENTS.
BUGRD1:	IDPB D,C	;OTHER CHARS GO INTO BUFFER.
	CAIE D,^I
	CAIN D,^J	;SYSTEM DOESN'T ECHO ^I, ^J
	PUSHJ P,TOUT	;SO ECHO THEM NOW.
	CAIE D,^M
	JRST BUGRD
	PUSHJ P,TOUT	;SAME GOES FOR ^M,
	MOVEI D,^J	;BUT IN ADDITION PUT IN A ^J.
	JRST BUGRD1

BUGRUB:	CAMN C,[010700,,VPAGAD-1]
	JRST NXERR	;RUBOUT WHEN BUFFER EMPTY.
	LDB D,C
	PUSHJ P,TOUT	;ELSE TYPE CHAR RUBBED.
	ADD C,[70000,,]	;BACK UP THE BUFFER POINTER.
	JUMPGE C,BUGRD
	SUB C,[430000,,1]
	JRST BUGRD

BUGFF:	MOVE A,[010700,,VPAGAD-1]
	PUSHJ P,FORMF	;CLEAR SCREEN
BUGFF1:	CAMN A,C
	JRST BUGRD	;AFTER RETYPING ALL CHARS READ ANOTHER.
	ILDB D,A
	PUSHJ P,TOUT	;ELSE RETYPE THE NEXT.
	JRST BUGFF1

BUGDON:	PUSH P,[NLTL2]	;WHEN FINISHED, TYPE STAR
	PUSH P,[VPAGRT]	;AFTER FREEING BUFFER PAGE.
	JUMPGE W1,BUGDO2
	TLNN W1,2
	PUSHJ P,BUGSRC	;FOR :BUG, SEARCH COM:SYSTEM PROGMS.
BUGDO2:	PUSHJ P,BUGSND	;(IN CASE HE LOGGED OUT WHILE MSG READ)
	CAMN C,[010700,,VPAGAD-1]
	JUMPLE W1,BUGCLS	;(NULL SENDS WOULD HANG TARGET DDT)
	MOVE B,[1,,UTOC]
	SETZM FDRCIP
	.CALL BUGOPN	;OPEN OUTPUT FILE.
	OPNER BUGOPN
	JUMPGE W1,BUGDO1
	MOVE B,[2,,FDRC] ;FOR MAIL, MAILA, BUG, BUGA
	.CALL BUGOPN	;LOOK FOR OLD FILE.
	JRST BUGDO1	;NO OLD, NOTHING SPECIAL.
	PUSHJ P,FDRCO1	;READ IN 1ST BUFFERFULL.
	TLNN W1,1
	 PUSHJ P,BUGA0	;FOR MAILA, BUGA COPY PART OF OLD FILE FIRST.
BUGDO1:	MOVE A,[010700,,VPAGAD-1]
BUGOUT:	CAMN A,C	;OUTPUT ALL CHARS IN BUFFER IN ORDER.
	JRST BUGCLS
	ILDB D,A
	.IOT UTOC,D
	JRST BUGOUT

BUGCLS:	JUMPGE W1,BUGCL1	;FOR MAIL, MAILA, BUG, BUGA,
	.IOT UTOC,[^_]	;FOLLOW THE MSG BY A ^_
	PUSHJ P,BUGCPY	;COPY OVER REST OF MAIL.
BUGCL1:	.CLOSE UTOC,
	.CLOSE FDRC,
	POPJ P,

BUGCPY:	SKIPN FDRCIP	;COPY OLD FILE IF IT'S OPEN.
	POPJ P,
BUGCP1:	PUSHJ P,FDRCI	;READ 1 CHAR FROM BUFFERED FDRC.
	CAIN D,^L	;IGNORE ^L'S IN OLD FILE.
	 JRST BUGCP1
	CAIN D,^C
	 POPJ P,	;THEN GO OUTPUT NEW STUFF.
	.IOT UTOC,D
	JRST BUGCP1

;OPEN THE DESIRED FILE FOR COMMAND TYPE IN W1,
;B SHOULD HAVE <MODE>,,<CHANNEL>.
BUGOPN:	SETZ ? SIXBIT/OPEN/
	B ? ['COM,, ? 'CLI,, ? 'DSK,,]+1(W1)
	CLUFN1 ? ['MAIL_14 ? 'HACTRN ? '>_36]+1(W1)
	SETZ ['.MSGS.]	;(SNAME USED ONLY IF DEV IS DSK)

;SEARCH COM:SYSTEM PROGMS TO SEE WHO GETS A :BUG
;MAIL TO EACH USER, THEN RETURN (TO BUGDO2, WHICH MAILS TO SYS)
BUGSRC:	7TYPE [ASCIZ/
SENT TO: /]
	SETZB I1,I2
	MOVE D,[440700,,I1]	;CONVERT PROGRAM NAME TO ASCII IN I1, I2.
	MOVE B,CLUFN1
BUGSR1:	SETZ A,
	ROTC A,6	;GET THE NEXT 6BIT CHAR FROM B
	ADDI A,40
	CAIN A,40	;PAD AD THE END WITH COMMAS, NOT SPACES.
	 MOVEI A,",
	IDPB A,D
	CAME D,[010700,,I2]
	 JRST BUGSR1	;PAD WITH COMMAS TILL END OF I2.
	.OPEN FDRC,[SIXBIT/  "COMSYSTEMPROGMS/]
	OPNER @.-1
	STDCAL CORBLK,[1000,,400000 ? 1000,,-1 ? 1000,,201 ? 1000,,400001]
BUGSR6:	MOVE D,[-2000,,402000]	;READ FILE INTO PAGE 201.
	.IOT FDRC,D	;READ UP TO 1 PAGE INTO BUFFER.
	.IOPUSH FDRC,	;(BUGDO2 WILL USE FDRC, THIS FILE MAYBE >1K)
	HRLOI D,-1-402000(D)
	EQVI D,402000	;GET AOBJN -> WHAT WAS ACTUALLY READ.
BUGSR2:	CAMN I1,(D)	;COMPARE 1ST 2 WDS OF ENTRY
	CAME I2,1(D)	;WITH OUR 2 WDS OF ASCII.
	 JRST BUGSR3
	MOVEI B,2(D)	;MATCH, GET ASCII BP -> 2ND 2 WDS.
	HRLI B,440700
	PUSH P,D
	PUSH P,C
	MOVE C,[440600,,CLUFN1]
	SETZM CLUFN1
BUGSR4:	ILDB A,B	;CONVERT THE ASCII IN THEM TO SIXBIT,
	CAIN A,":
	 JRST BUGSR5	;THEY HOLD PROGRAMMER'S NAME, TERMINATED BY COLON.
	SUBI A,40
	IDPB A,C
	JRST BUGSR4

BUGSR5:	MOVE D,CLUFN1	;TYPE NAME OF THE USER WHOSE NAME WAS FOUND.
	PUSHJ P,SIXTYP
	7TYPE [ASCIZ/, /]
	POP P,C		;GET BACK THE BP -> END OF MESSAGE.
	PUSHJ P,BUGDO2	;MAIL MESSAGE TO THAT USER.
	POP P,D
BUGSR3:	ADD D,[4,,4]	;MOVE TO NEXT ENTRY.
	JUMPL D,BUGSR2
	.IOPOP FDRC,	;FINISHED 1K OF SYSTEM PROGMS,
	.SUSET [.RIOC+FDRC,,D]
	JUMPN D,BUGSR6	;STILL OPEN => DO SOME MORE.
	MOVSI D,'SYS	;MAILED TO ALL THE PROGRAMMERS,
	MOVEM D,CLUFN1	;NOW MAIL TO SYS.
	STRT [SIXBIT/SYS./]
	STDCAL CORBLK,[1000,, ? 1000,,-1 ? 1000,,201]
	POPJ P,		;RETURNS TO BUGDO2.
;FOR BUGA, MAILA, READ THRU OLD FILE TILL END OF PREVIOUS NOTE,
;COPYING INTO NEW FILE. DON'T COPY THE ^_ AFTER THE NOTE.
BUGA1:	CAIN B,40	;WAS THIS ENTRY THE RIGHT ONE?
	 POPJ P,	;YES, RETURN.
	.IOT UTOC,[^_]	;NO, COPY THE ^_
BUGA0:	MOVE A,[010700,,VPAGAD-1]	;THE ACTUAL ENTRY POINT.
	SETO B,		;DON'T KNOW WHETHER NEXT NOTE'S THE ONE.
BUGA2:	PUSHJ P,FDRCI
	CAIN D,^_	;NOTE ENDS BEFORE SENDER'S NAME =>
	 JRST BUGA1	 ;PASS IT BY.
	CAIN D,^C
	 JRST [SETZM FDRCIP	;DON'T TRY TO COPY THE REST.
		POPJ P,]	;FILE ENDED => DONE.
	CAIN D,^L
	 JRST BUGA2	;IGNORE ^L IN MAIL FILES.
	.IOT UTOC,D	;ELSE COPY THE CHAR INTO OUTPUT FILE,
	JUMPE B,BUGA2	;THIS NOT THE ONE => JUST COPY IT.
	CAIN B,40
	 JRST BUGA2	;THIS CERTAINLY THE NOTE => COPY IT.
	CAMN A,C	;OUR UNAME SHORTER THAN THEIRS => NOT THE ONE.
	 JRST BUGA2
	ILDB B,A	;ELSE COMPARE THE NEXT CHARS OF EACH.
	CAIE B,(D)
	 SETZ B,	;MISMATCH => THIS ISN'T THE NOTE.
	JRST BUGA2


;:BUG <PROGM> <MESSAGE>^C
BUG:	SKIPA W1,[-3,,-1]	;3.1 ON => AT FRONT, 3.2 OFF => BUG.
BUGA:	HRLOI W1,-4	;3.1 OFF => ADD TO MESSAGE.
	PUSHJ P,BUGLOG	;TYPE (LOGIN?) IF NOT LOGGED IN.
	PUSHJ P,RTOKEN	;READ NAME OF PROGRAM (INTO B)
	JUMPE B,.-1
	MOVE A,GSCHRP	;ARRANGE TO RE-READ THE CHARS "BUG <PROGM> "
	MOVEM A,GSCHRQ
	TLO F,RUBFL	;BUGRD WILL SEE RUBFL, SO WILL KNOW TO USE THEM.
	PUSHJ P,GSOB
	SETOM UNRCHF	;THE LAST CALL TO SLRPIN WILL READ A SPACE (ELSE MIGHT SWALLOW RUBOUT OR ^D)
	JRST MAIL1

;:MSG <TOPIC> <MESSAGE> ^C.
MSG:	.RDATE D,
	AOJE D,NDATER	;MSGS FILE MUST HAVE A DATE.
	MOVEI W1,1	;OP. TYPE IS 1 FOR MSG.
	JRST MAIL0

;CHANGE A SEND TO A MAIL IF TARGET GAGGED OR NOT LOGGED IN.
BUGSND:	JUMPN W1,CPOPJ	;DO NOTHING IF NOT SEND.
	.OPEN FDRC,CLUFNB
	 JRST BUGSN1	;HE HAS NO HACTRN.
	.USET FDRC,[.RMASK,,D]
	TRNE D,BCLI	;SKIP IFF HE'S GAGGED.
	 POPJ P,
BUGSN1:	SETO W1,
	7NRTYP [ASCIZ/(MAIL) /]	;W1 NOW HAS -1 FOR MAIL.

BUGLOG:	MOVE D,RUNAME
	AOJN D,CPOPJ	;J IF USER LOGGED IN.
	7NRTYP [ASCIZ/(LOGIN?) /]

VPAGET:	AOSE VPAGCT	;1 MORE RQ FOR VPAGE.
	POPJ P,
	STDCAL CORBLK,[1000,,700000 ? 1000,,-1
		1000,,VPAGE ? 1000,,400001]
	POPJ P,		;MUST ACTUALLY GET IT FOR 1ST RQ.

VPAGRT:	SOSL VPAGCT	;1 LESS RQ FOR VPAGE.
	POPJ P,
	STDCAL CORBLK,[1000,, ? 1000,,-1 ? 1000,,VPAGE]
	POPJ P,		;FLUSH IT IF NO RQS LEFT.

MSGNAM:	MOVE A,RUNAME	;PUT THIS USER'S UNAME IN BUFFER.
	JSP W3,6TO7
	 IDPB B,C
	JRST BUGSPC

BUGDAT:	.RDATE B,	;PUT DATE IN BUFFER.
	ROT B,12.	;SHIFT TO MONTH,DAY,YEAR
	MOVEI W3,"/	;SEPARATE NUMBERS WITH "/".
	JRST BUGTL2

BUGTIM:	.RTIME B,	;PUT TIME IN BUFFER.
	MOVEI W3,":
BUGTL2:	MOVEI D,0
BUGTL1:	MOVEI A,0
	ROTC A,6
	ADDI A,40
	IDPB A,C
	JUMPE B,BUGSPC
	MOVE A,W3
	TRNE D,1
	IDPB A,C
	AOJA D,BUGTL1

BUGSPC:	MOVEI A,40	;PUT A SPACE IN THE BUFFER.
	IDPB A,C
	POPJ P,

6TO7:	MOVEI B,0
	ROTC A,6
	ADDI B,40
	XCT (W3)
	JUMPN A,6TO7
	JRST 1(W3)

ERRSTS:	PUSHJ P,GARGDQ
	MOVEM D,ERROPN+2
	PUSHJ P,FDRCOP
	ERROPN
	JRST ERR
	JRST CTLF1
;DEFINITIONS FOR MSGS:
VPAGAD=VPAGE_10.
UNFN1==0	;COPIED FROM ITS, NEAR QSKO
UNFN2==1
UNRNDM==2
UNDATE==3
UNLINK==1
UNIGFL==200064	;BITS IN RH OF UNRNDM, SET => FILE INACCESSABLE.
LUNBLK==5	;LENGTH OF NAME-BLOCK.

; :MSGS COMMAND - PRINT MESSAGES SINCE COMMAND LAST GIVEN.
MSGS:	SKIPE	TOKTRM	;TERMINATOR
	JRST	MSG0	;TERMINATED BY C.R.-- JUST DOIT
	PUSHJ	P,RTOKEN	;GET FILE DIRECTORY
	JUMPE	B,MSG0
	MOVEM	B,MSGSNM		;IF SPECIFIED DIR, STORE IT.
	LDB	D,[000600,,B]	;IF LOW CHAR IS ".", CHANGE TO "_".
	CAIN	D,'.
	IORI	B,'_
	LDB	D,[360600,,B]
	CAIN	D,'.		;SAME FOR HIGH CHAR.
	TLO	B,(SIXBIT/_/)
	MOVEM	B,MSGF1+1	;THAT GIVES FIRST NAME OF DATE-FILE.
MSG0:	HRRZS	MSGF1		;INPUT.
	SETOM	SRFLAG
	.SUSET	[.SSNAM,,MSNAM]
	MOVE	C,RUNAME
	MOVEM	C,MSGF1+2
	.OPEN	FDRC,MSGF1	;FILE  _MSGS_ <USER-NAME>.
	JRST	MSGS2		;IF NO SUCH FILE, PRINT ALL MESSAGES.
	TSCALL	MSGC1		;READ DATE LAST PRINTED MESSAGES.
	TLZ	C,776000	;FLUSH ACCESS DATE.
	.RDATE	D,
	TLNN	D,100		;IF CURRENT YEAR EVEN,
	TLC	C,1000		;EVEN DATES ARE LATER.
MSGS8:	CAMN	D,[-1]
	JRST	NDATER
	SETZM	MSGDFL
	TLNE	D,100
	AOS	MSGDFL
	MOVEM	C,MSGDAT
	.SUSET	[.SSNAM,,MSGSNM]
	SETOM	MSGLDT		;NO FILES TYPED YET.
	PUSHJ P,VPAGET	;GET FRESH PAGE AT VPAGE.

;DROPS THROUGH.

;DROPS THROUGH.
	.OPEN	FDRC,MSGF2	;OPEN DIR. IN IMAGE BLOCK MODE.
	CAIA
	JRST	MSGS1		;SUCCESS.
	AOSE	MSGLOG		;FAILURE - JUST RETURN IF LOGGING IN.
	OPNER	MSGF2		;ERROR IF EXPLICIT COMMAND.
	JRST	GSNLRT
MSGS1:	MOVE	D,[-2000,,VPAGAD]
	.IOT	FDRC,D		;READ THE WHOLE DIR.
	.CLOSE	FDRC,
	MOVEI	A,VPAGAD
	ADD	A,VPAGAD+1	;ADDR. OF 1ST NAME-ENTRY.
	MOVEI	B,VPAGAD+2000	;ADDR AFTER LAST.
	MOVSI	C,1000		;DON'T INCLUDE ACCESS DATE IN SORT KEY.
	PUSHJ	P,SORT		;SORT BITS FROM 1000,, DOWN.
	MOVEI	A,VPAGAD-LUNBLK
	ADD	A,VPAGAD+1
MSGSNF:	ADDI	A,LUNBLK	;LOOK AT NEXT FILE.
	CAIL	A,VPAGAD+2000
	JRST	MSGSX		;IF ALL SEEN.
	SKIPN	D,UNFN1(A)
	JRST	MSGSNF		;IGNORE IF FN1 BLANK.
	MOVEM	D,MSGF3+1	;SAVE FN1 FOR OPEN.
	SKIPN	D,UNFN2(A)
	JRST	MSGSNF
	MOVEM	D,MSGF3+2
	LDB	D,[360600,,MSGF3+1]
	CAIN	D,'_		;IGNORE FILE IF FN1 STARTS WITH _.
	JRST	MSGSNF
	MOVE	D,UNRNDM(A)
	TLNE	D,UNLINK\UNIGFL
	JRST	MSGSNF		;IGNORE LINKS AND INACCESSABLE FILES.
	LDB	C,[3400,,UNDATE(A)]
	SKIPN	MSGDFL		;CAUSE BIT 4.1 TO BE SET
	TLC	C,1000		;IFF FILE WAS MADE THIS YEAR.
	CAMG	C,MSGDAT
	JRST	MSGSNF		;IF PRINTED MESSAGES SINCE WAS CREATED, SKIP.
	PUSHJ P,FDRCOP
	MSGF3
	JRST	MSGSNF
	SKIPGE	MSGLDT
	PUSHJ	P,CRF
	SKIPL	MSGLDT	;IF 1ST FILE
	JRST	MSGSAS
	SKIPL	MSGLOG	;AND EXPLICIT COMMAND
	JRST	MSGSA1	;NO NEED FOR --MSGS--
MSGSAS:	SETOM MORNRO	;SO RUBOUT WON'T FLUSH.
	SETZM MORNFF
	7TYPE [ASCIZ/--MSGS--/]
	PUSHJ P,MORFL1	;READ CHAR, MAYBE FLUSH.
	JRST MSGSX1
	JRST MSGSA1
MSGSA1:	LDB D,[3400,,UNDATE(A)]
	MOVEM D,MSGLDT	;THIS FILE'S DATE IS DATE OF LAST STARTED.
	MOVE	D,MSGF3+1	;PRINT THE FILE'S NAME.
	PUSHJ	P,SIXTYP
	CTYPE	" 
	MOVE	D,MSGF3+2
	PUSHJ	P,SIXTYP
	7TYPE	[ASCIZ/:
/]
MSGSA2:	PUSHJ P,FDRCI
	CAIN	D,^J
	JRST	MSGSA9
	CTYPE	(D)
	CAIN	D,^M
	CTYPE	^J
	CAIE	D,^L		;PRINT 1ST LINE, THEN GIVE --MORE--
	CAIN	D,^C		;UNLESS AT EOF.
	JRST	MSGS5
	JRST	MSGSA2

MSGSA9:	PUSHJ 	P,MORINI	;INIT. MORE PROC.
	JRST	MSGSA3		;DO THIS ON FLUSHING.
	SETOM	TYOEOP		;CAUSE "--MORE--" BEFORE NEXT CHAR.
	SETOM  	MORNFF		;BUT DON'T CLEAR SCREEN.
	PUSH	P,A
	PUSHJ	P,CTLF3		;PRINT CONTENTS OF FILE.
	POP	P,A
MSGS5:	SETZM	SILNT
	PUSHJ	P,CRF		;IF FINISHED WHOLE 1ST PAGE.
MSGS4:	SKIPGE GETTY	;(DON'T BLATHER ON PRINTING CONSOLE)
	7TYPE	[ASCIZ/ END MESSAGE
/]
	JRST	MSGSNF		;PRINT ANOTHER.

MSGSA3:	SKIPL	UNRCHF		;IF CHAR WAS RUBOUT,
	JRST	MSGS5		;JUST END THIS FILE.
MSGSX1:	SKIPGE	D,MSGLDT	;IF HAVE SEEN NO MESSAGES,
	JRST	MSGSX3		;DON'T UPDATE DATE.
	JRST	MSGSX5
MSGSX:	MOVNI	D,1		;SAY USE CURRENT DATE.
MSGSX5:	MOVEI	C,1
	HRLM	C,MSGF1
	.SUSET	[.SSNAM,,MSNAM]
	.OPEN	FDRC,MSGF1	;UPDATE DATE OF PRINTING MSGS.
	JRST	MSGSX4
	MOVE	C,[SETZ FDRC]	;SET DATE FILE'S DUMPED-BIT.
	.DMPCH	C,
	SKIPGE	C,D		;IF WENT THRU MSGSX1,
	JRST	MSGSX3
	TSCALL	SFDATB		;SET DATE TO THAT OF LAST FILE PRINTED.
	CAIA
MSGSX4:	7TYPE	[ASCIZ/
CAN'T UPDATE DATE FILE/]
MSGSX3:	.CLOSE	FDRC,
MSGSX2:	PUSHJ P,VPAGRT	;RETURN PAGE USED FOR .MSGS. DIR.
MSGSX6:	SETZM	MSGLOG
	JRST	NLTL2

;PUSH FDRC, ITS BUFFER AND POINTERS. CALL WITH JSP I4, .
SHFDRC:	.IOPUSH FDRC,
	HRLI D,FDRCTB
	HRR D,P
	AOS D
	ADD P,[FDRCL+2,,FDRCL+2]
	SKIPL P
	ERLOSS I4	;PDL OV.
	BLT D,(P)
	JRST (I4)

;UNDO A SHFDRC. CALL WITH JSP I4, .
OPFDRC:	.IOPOP FDRC,
	HRRZ D,P
	SUBI D,FDRCL+1
	HRLS D
	HRRI D,FDRCTB
	BLT D,FDRCTB+FDRCL+1
	SUB P,[FDRCL+2,,FDRCL+2]
	JRST (I4)

;READ A DATE, AS APPEARS IN DIRECTORY, TURN IN TO FILE-FORMAT
;DATE. CALL IS FOLLOWED BY INSN TO PUT CHAR IN D.
RDATE:	SETOM	MSGDFL
RDATE0:	MOVE	I1,@(P)	;ASSUME MSGDFL SET UP. GET FETCH INSN.
	SETZM	MSGFDT
	PUSHJ	P,MSGNUM	;CREATION MONTH.
	DPB	C,[270400,,MSGFDT]
	PUSHJ	P,MSGNUM	;CREATION DAY.
	DPB	C,[220500,,MSGFDT]
	PUSHJ	P,MSGNUM	;CREATION YEAR.
	DPB	C,[330100,,MSGFDT]
	PUSHJ	P,MSGNUM	;HOUR.
	IMULI	C,3600.
	ADDM	C,MSGFDT
	PUSHJ	P,MSGNUM	;MINUTE.
	IMULI	C,60.
	ADDM	C,MSGFDT
	PUSHJ	P,MSGNUM	;SECOND
	ADD	C,MSGFDT
	ADDI	C,(C)		;DOUBLE THE R.H.
	SKIPN	MSGDFL
	TLC	C,1000
	JRST	CPOPJ1	;SKIP FETCH INSN.

;COME HERE IF USER HAS NO DATE FILE YET.
MSGS2:	SKIPGE MSGLOG
	JRST MSGS2B
MSGS2C:	.RDATE	D,		;ELSE PRINT ALL MESSAGES.
	SETZ	C,
	JRST	MSGS8

MSGS2B:	.STATUS FDRC,D
	LDB D,[220600,,D]
	CAIN D,20
	JRST MSGSX6	;IF NON-EX USER EXIT
	JRST MSGS2C

MSGNUM:	SETZ	C,
	CAIN D,^M	;DON'T GO ON PAST CR.
	POPJ P,
MSGNU1:	XCT	I1		;A HOLDS INSN ARG.
	CAIL	D,"0
	CAILE	D,"9		;TERMINATE ON NON-DIGIT.
	POPJ	P,
	IMULI	C,10.
	ADDI	C,-"0(D)
	JRST	MSGNU1

MSGF2:	SIXBIT/  &DSK.FILE.(DIR)/

MSGC1:	SETZ
	SIXBIT/RFDATE/
	[FDRC]
	402000,,C

SWPS==LUNBLK

;SORT THE .MSGS. DIRECTORY
;A POINTS TO FIRST ENTRY
;B POINTS TO LAST ENTRY + 1
;C HAS ONE BIT SET, THAT BIT MOST SIGNIFICANT BIT TO SORT ON

SORT:	HRLM B,(P)	;SAVE UPPER BOUND
	CAIL A,-SWPS(B)
	JRST SORT7	;ONE OR ZERO ENTRIES
	PUSH P,A	;SAVE LOWER BOUND
SORT3:	TDNN C,UNDATE(A)	;BIT SET IN LOWER ENTRY?
	JRST SORT4	;NO, INCREMENT TO NEXT AND MAYBE TRY AGAIN
	SUBI B,SWPS	;YES, NOW BACK UP UPPER POINT	
	TDNE C,UNDATE(B)	;BIT CLEAR IN UPPER ENTRY?
	JRST SORT5	;NO, CHECK FOR END, DECREMENT B, AND TRY AGAIN
REPEAT SWPS,[		;BIT SET IN LOWER ENTRY AND CLEAR IN UPPER => EXCHANGE ENTRIES
	MOVE D,.RPCNT(A)
	EXCH D,.RPCNT(B)
	MOVEM D,.RPCNT(A)
]
SORT4:	ADDI A,SWPS	;INCREMENT LOWER BOUND POINTER TO NEXT ENTRY
SORT5:	CAME A,B	;ANY MORE ENTRIES LEFT?
	JRST SORT3	;YES, GO PROCESS THEM
		;A AND B NOW BOTH POINT TO FIRST ENTRY WITH BIT SET
	ROT C,-1	;ROTATE BIT INDICATOR TO NEXT (LESS SIGNIFICANT) BIT
	POP P,A		;RESTORE LOWER BOUND OF ENTIRE SORT
	JUMPL C,SORT6	;JUMP IF NO MORE KEY TO SORT ON
	PUSHJ P,SORT	;SORT BOTTOM PART OF TABLE
	HLRZ B,(P)	;RESTORE UPPER BOUND (SORT CLOBBERED A TO MIDDLE)
	PUSHJ P,SORT	;SORT TOP PART OF TABLE
SORT6:	ROT C,1		;BACK UP KEY AGAIN SO AS TOO "NOT CLOBBER C"
SORT7:	HLRZ A,(P)	;MAKE A POINT ABOVE TABLE ENTRIES SORTED
	POPJ P,
; :HELP COMMAND
NHELP:	7TYPE	[ASCIZ &
 YOU ARE TYPING AT THE TOP LEVEL COMMAND INTERPRETER/DEBUGGER
OF THE ITS TIME SHARING SYSTEM.
 TYPE CONTROL S TO FLUSH LONG TYPE OUTS.
 MNEMONIC COMMANDS START WITH A COLON AND ARE USUALLY TERMINATED
BY A CARRIAGE RETURN.  TYPE :?  TO LIST MOST OF THEM.
 TYPE :LOGIN NAME  TO LOG IN AS NAME.
 IF THE COMMAND IS NOT RECOGNIZED, IT IS TRIED AS THE NAME OF
A SYSTEM PROGRAM TO LOAD.  :INFO <CR>  LOADS A PROGRAM THAT CAN
PROVIDE FURTHER INFORMATION.
 TYPE CONTROL Z TO RETURN TO THE TOP LEVEL.&]
	JRST NLTL2



;TYPE NAMES OF SYMBOLS.
SLIST:	JUMPL U,JERR
	MOVE W1,SYSAOB	;FOR SYS JOB, GET AOBJN -> SYS SYM TAB
	SUBI W1,772000-SYSSYM ;CHANGE ADDR IN SYSTEM TO ADDR IN DDT
	SKIPN SYSSW
	MOVE W1,JOBSYM(U)
	MOVE I1,TYOLSZ
	IDIVI I1,8	;HOW MANY SYMS FIT ON LINE?
	MOVE I2,I1	;I2 COUNTS NUM. LEFT ON THIS LINE.
SLIST2:	JUMPGE W1,NLTL6      ;DONE?
	MOVE A,(W1)
	TLNE A,PNAME	;BLOCK OR PROGRAM
	 SOJGE I2,SLIST1 ;OR FILLED UP THIS LINE =>
	CALL CRF	;GO TO NEXT LINE.
	CALL MORFLS	;MAYBE TYPE --MORE--,
	 JRST NLTL2	 ;(IF USER FLUSHED)
	MOVEI I2,-1(I1)	;# SYMS THIS LINE AFTER THIS SYM.
SLIST1:	TLNE A,PNAME	;INDENT ALL BUT BLOCK NAMES.
	 CALL TSPC
	PUSHJ P,SPT      ;SQUOZE SYMBOL PRINT
	MOVEI D,^I
	SKIPE I2	;DON'T TAB AFTER LAST SYM ON LINE.
	PUSHJ P,TOUT
	ADD W1,[2,,2]
	JRST SLIST2

MORE:	PUSHJ P,RLINE	;READ (AND ECHO) MESSAGE.
	PUSHJ P,MORFL1	;READ CHAR, MAYB FLUSH.
	JRST [PUSHJ P,INPOP
	     JRST GSNLRT]  ;FLUSHED => END VALRET OR XFILE.
	JRST NLTL5	;ELSE CONTINUE.

CLEAR1:	PUSHJ P,FORMF
	JRST GSNLRT
UUOTAB:	UERLOSS	;ERLOSS. SIGN SET => CALL ERTTY BEFORE DISPATCH.
	U7NRTY
	SETZ UERSTRT	;ERSTRT
	U7TYP
	UCTYPE
	USTRT
	SETZ UOPNER
	SETZ UTERR
	SETZ UUOH3	;ILUUO

UTERR:	HRLZ I1,40	;TERR - DUMMY UP AN ERSTRT.
	IORI I1,'?_14	;PUT IN A ? TO STOP ERSTRT.
	ERSTRT I1

UERLOS:	MOVE D,(P)	;RESTORE THESE ACS IN CASE
	MOVE A,-1(P)	;40 POINTS TO ONE OF THEM.
	SKIPE DEBUGP	;ERLOSS UUO.
	.VALUE
	SKIPA I2,@40	;GET CONTENTS OF LOC. TO TYPE OUT.
UUOH3:	MOVEI I2,0	;ILUUO, @40 MIGHT BE MPV.
	PUSHJ P,ERTTY
	PUSHJ P,CRF
	MOVE I1,UUOPDP	;GET WHAT WAS IN P AT UUO.
	PUSHJ P,COMPLN
	MOVE D,UUOH	;TYPE THE PC,
	MOVE D,40	;THE UUO,
	MOVE D,I2	;AND, FOR ERLOSS, CONTENTS OF ADDRESSED LOCATION.
	MOVE D,F	;THE FLAGS
	MOVE D,I1	;AND THE PDL BEFORE UUO.
	JRST CPOPJ1	;RETURN FROM COMPLN.
	PUSHJ P,CRF
	PUSHJ P,COMPLN
REPEAT 5,MOVE D,-.RPCNT(I1)	;TYPE STUFF ON PDL.
	JRST CPOPJ1
	PUSHJ P,CRF
	PUSHJ P,TQUIT0	;DO .IOPDL, RETURN TO VERY TOP LEVEL.
	ERSTRT [SIXBIT/DDT BUG, REPORT WITH :BUG DDT <INFO> ^C./]
UOPNER:	.SUSET [.RBCHN,,UERFLC]
	.OPEN ERRC,UERFLN
	JRST .-1
UOPNR2:	.IOT ERRC,D
	CAIN D,^M
	JRST UOPNR4
	PUSHJ P,TOUT
	JRST UOPNR2

UOPNR4:	HRRZ A,40
	7TYPE [ASCIZ/ - /]
	.CLOSE ERRC,
	AOSN SRFLAG	;IF ROUTINE WANTED SNAME RESTORED
	.SUSET [.SSNAM,,LSNAM]	;DO IT TO IT
	MOVE D,(A)
	CAMN D,[SETZ]
	JRST UOPNR6
	.SUSET [.RSNAM,,B]
	PUSHJ P,LFILE0
	JRST ERR5

UOPNR6:	MOVE D,1(A)	;OPNER AFTER .CALL, DECODE IT.
	CAMN D,[SIXBIT/OPEN/]
	JRST UOPNRO	;OPEN - PRINT FILENAMES.
	ERLOSS A

UOPNRO:	POP P,D		;D MAY HOLD AN ARG TO OPEN.
	MOVEI A,3(A)	;A-> ARG -> DEV. NAM.
	PUSHJ P,UOPNL	;PRINT 4 (OR 3) ARGS STARTING THERE.
	JRST ERR5

UOPNL:	PUSH P,C
	PUSH P,D
	MOVE D,@(A)	;GET NAME IN 1ST ARG,
	PUSHJ P,SIXTYP
	7TYPE [ASCIZ/: /]	;IT IS DEVICE NAME.
	MOVE D,(P)	;@3(A) MAY USE THESE ACS.
	MOVE C,-1(P)
	SKIPL 2(A)
	SKIPA D,@3(A)	;GET SPEC'D SNAME
	.SUSET [.RSNAM,,D]	;OR DEFAULT IF NONE SPEC'D.
	PUSHJ P,SIXTYP
	7TYPE [ASCIZ/; /]
UOPNL0:	MOVE D,(P)
	MOVE C,-1(P)
	MOVE D,@1(A)
	PUSHJ P,SIXTYP	;PRINT FN1 & FN2.
	PUSHJ P,TSPC
	POP P,D
	POP P,C
	MOVE D,@2(A)
	JRST SIXTYP

ERR:	ERSTRT [SIXBIT/?/]
LOGQ:	ERSTRT [SIXBIT/LOGIN?/]

UERSTR:	MOVEI A,ERR5	;STRING RETURN ERROR
	HRRM A,UUOH	;RETURN TO ERR5
	PUSHJ P,TSPC

USTRT:	PUSH P,UUOH
	MOVE A,40
	HRLI A,440600
UUOH11:	ILDB D,A
	ADDI D,40
	PUSHJ P,TOUT
	CAIN D,"?
	JRST UUOXIT
	CAIE D,".
	JRST UUOH11
UUOXIT:	POP P,UUOH
	POP P,D
	POP P,A
	JRST 2,@UUOH

ERR5:	PUSHJ P,%RESET	;ALL ERRORS COME THRU HERE.
	PUSHJ P,TSPC
ERR6:	MOVE P,ERRSTP	;RESTORE PDL AND PC
	JRST @ERRSTL	;TO THE ERROR-RETURN LOCATION.

%RESET:	SKIPL VPAGCT	;IF HAVE FRESH PAGE IN VPAGE, RETURN IT.
	PUSHJ P,[SETZM VPAGCT ? JRST VPAGRT]
	.CLOSE FDRC,
	.CLOSE ERRC,
	PUSHJ P,INRST	;RESET TTY, PUSH VALRET OR XFILE
	PUSHJ P,CLSU	;CLOSE DECTAPE CHANNELS
IRPS XX,,[MSGLOG SILNT MORPRP HAKIOP VALCOM TQUITR U7TCTN
RSTDEL HAKING INTING INNCTL XRWI]
	SETZM XX
TERMIN
	AOSN SRFLAG
	.SUSET [.SSNAM,,LSNAM]
	.SUSET [.SAMASK,,[1^5,,]]
	.SUSET [.SPICL,,[-1]]
	POPJ P,

U7NRTY:	PUSHJ P,U7TY0
	SUB P,[NUUOPH,,NUUOPH]
	AOSN SRFLAG
	.SUSET [.SSNAM,,LSNAM]
	JRST GSNLRT

U7TYP:	PUSH P,UUOH
	PUSHJ P,U7TY0
	JRST UUOXIT

U7TY0:	MOVE A,40
U7TY2:	PUSH P,LPTFLG	;SUBROUTINE TO TYPE ASCIZ ARG.
	PUSH P,U7TCTN'
	SETZM U7TCTN	;HAVEN'T SEEN ^N IN ARG.
	HRLI A,440700
U7TY1:	ILDB D,A
	JUMPE D,U7TYC
IRPC X,,CENSVDF
	CAIN D,^X
	JRST U7TY!X
TERMIN			;HANDLE SPECIAL CTL CHARS.
	PUSHJ P,TOUT
	JRST U7TY1

U7TYV:	SETZM TTYFLG
	JRST U7TY1

U7TYD:	MOVEI A,ERR6	;^D - LIKE ^F BUT RET. TO ERRSET, NOT CALLER.
	MOVEM A,-2(P)
U7TYF:	MOVEI A,[ASCIZ/? /]	;^F - RESET THINGS LIKE ERSTRT.
	PUSHJ P,U7TY2
	PUSHJ P,%RESET
U7TYC:	SKIPE U7TCTN	;IF WEREN'T UPDATING POSITION, MUST MAKE IT UP TO DATE.
	PUSHJ P,TYOPOS	;READ NEW CURSOR POS.
	POP P,U7TCTN
	POP P,LPTFLG
	POPJ P,

U7TYN:	SETOM U7TCTN
U7TYE:	AOS LPTFLG
	JRST U7TY1

U7TYS:	SETZM SILNT
	JRST U7TY1

UCTYPE:	PUSH P,UUOH
	HRRZ D,40
	SKIPN DDTTY
	 ERLOSS
	PUSHJ P,TOUT
	JRST UUOXIT


FDRCOP:	PUSH P,D	;FDRC OPEN
	MOVE D,@-1(P)
	AOS -1(P)
	MOVEI D,@D
	.OPEN FDRC,(D)
	JRST POPDJ
	AOSA -1(P)
FDRCO1:	PUSH P,D
FDRCPP:	MOVE D,[440700,,FDRCTB]
	MOVEM D,FDRCIP
	MOVE D,[-FDRCL,,FDRCTB]
	.IOT FDRC,D
	HRRM D,FDRCEP
	MOVEI D,^C	;STORE ^C AFTER LAST WD READ.
	DPB D,FDRCEP
	JRST POPDJ

;READ 1 CHAR FROM BLOCK-MODE FDRC.
FDRCI:	MOVE D,FDRCIP	;UNLESS PTR IS AT END OF BUFFER,
	CAME D,[010700,,FDRCTB+FDRCL-1]
	JRST FDRCI1	;GO ILDB NEXT CHAR.
	PUSH P,[FDRCI]
	PUSH P,D	;IF AT END, READ BUFFER & TRY AGAIN.
	JRST FDRCPP

FDRCI1:	ILDB D,FDRCIP
	POPJ P,

QIJERR:	SKIPGE UCHNLO	;ERROR UNLESS INFERIOR OPEN.
QOJERR:	SKIPE DDTSW	;ERROR UNLESS ORDINARY JOB (NOT SYS OR SELF)
	 JRST JERR
QJERR:	SKIPE UCHNLO	;ERR IF NO JOB OR SYS OPEN
	POPJ P,
JERR:	SKIPE UCHNLO
	ERSTRT [SIXBIT/JOB NOT INFERIOR?/]
	MOVE D,RUNAME
	AOJE D,LOGQ	;COMPLAIN ABOUT NOT BEING LOGGED IN BEFORE ABOUT JOB
	TERR (SIXBIT /JOB/)

QRERR:	SKIPE UINTWD(U)	;ERROR IF JOB NOT RUNNING.
	 POPJ P,
	JRST NRERR

NXERR:	7NRTYP [ASCII /?/]

NDATER:	7NRTYP [ASCII/
DATE UNKNOWN, PLEASE DO :PDSET YYMMDD HHMMSS <CR>
/]


NLTL6:	PUSHJ P,CRF
NLTL4:	SKIPL GETTY
NLTL2:	PUSHJ P,CRF
NLTL3:	SKIPGE GETTY
	CTYPE "*
NLTL5:	AOSN SRFLAG	;RESTORE SNAME IF WAS REQUESTED.
	.SUSET [.SSNAM,,LSNAM]
	TLZ F,NROFL
	JRST GSNLRT
RIN:	PUSHJ P,IN
	CAIN D,^D
	JRST NCTLD
	CAIE D,177
	AOS (P)
	POPJ P,

IN4:	SETZM MORFLG
	MOVE D,LIMBO
	AOSN UNECHF	;IF ECHO DESIRED,
	JRST TOUT	;THEN MAYBE ECHO IT
	POPJ P,		;OTHERWISE JUST RETURN


	;1) INPUT CHARACTER
	;2) CHECK FOR , , 
	;3) MAYBE PRINT AND LPT IT
	;4) CHECK FOR , 

LISTN:	PUSH P,D
	PUSHJ P,TYI
	JRST POPDJ
	SETOM UNRCHF	;FOUND A CHAR OTHER THAN ^V, ETC: MUST RE-READ IT.
POPDJ1:	AOS -1(P)
POPDJ:	POP P,D
	POPJ P,

IN3:	PUSHJ P,INPOP	;COME HERE ON END OF VALRET OR CMD FILE.

;READ A CHAR FROM INPUT SOURCE.
IN:	AOSN UNRCHF
	JRST IN4
	SKIPGE HAKRQ	;IF ANY HAKKAH RQS PENDING, PROCESSTHEM.
	PUSHJ P,HAKKAH
	AOSN MORFLG
	JRST IN5
	SKIPE INPTR
	JRST IN2
IN5:	PUSHJ P,TYI3
	JRST IN5	;CHAR WAS ^V, ETC.
	SKIPN MORFLG	;IF READING CHAR AFTER --MORE--,
	 RET		;DON'T LPT IT.
IN6:	PUSHJ P,ECHOT	;IF CHARACTER SHOULD BE ECHOED,
	PUSHJ P,LPTR	;THEN MAYBE LPT IT
	POPJ P,
TYI:	.LISTEN D,
	JUMPE D,CPOPJ
TYI3:	.IOT TYIC,D
	MOVEM D,LIMBO
	CAIN D,^S	;UN-SILENCE WHEN READ ^S.
	SETZM SILNT	;WAS SILENCED AT INT. LEVEL.
	CAIE D,^V	;IGNORE ^V, ^W, ^B, ^E
	CAIN D,^W
	POPJ P,
	CAIE D,^B
	CAIN D,^E
	POPJ P,
	JRST CPOPJ1

;CHECK FOR READING SPECIAL CHARS (^V, ^W, ^B, ^E, ^S)
;PROCESS THEM, FAIL TO SKIP IF ^B, ^E, ^V, ^W
TYI3B:	IRPC X,,BEWV
	CAIN D,^X
	JRST TYI3B!X
TERMIN	JRST CPOPJ1	;SUCCEED IF WASN'T A SPECIAL CHAR.

;^B - MAYBE TURN ON LPT OUTPUT (WON'T OPEN LPT)
TYI3BB:	SOSL LPTFLG	;FROM FILE, SOS LPTFLG UNLESS 0,
	SKIPE INTING
	SETZM LPTFLG	;FROM TTY, SET TO 0.
	RET

;^V - MAYBE TURN ON TTY OUTPUT.
TYI3BV:	SOSL TTYFLG	;FROM FILE OR VALRET, JUST COUNTER ONE ^W.
	SKIPE INTING
	SETZM TTYFLG	;FROM TTY, CANCEL ALL ^W'S.
	POPJ P,

TYI3BE:	AOSA LPTFLG	;^E - TURN OFF OUTPUT TO LPT (BUT DON'T CLOSE)
TYI3BW:	AOS TTYFLG	;^W - TURN OFF OUTPUT TO TTY.
	POPJ P,
INPUS1:	PUSH P,[NLTL2]	;:INPUSH COMMAND.

;SAVE CURRENT INPUT SOURCES, START INPUT FROM TTY.
;CALLED FROM :XFILE AND VALRET CODE.
INPUSH:	PUSHJ P,RTYIC	;POP CURRENT SOURCE IF IT'S AT EOF.
	JFCL
	SKIPN D,4BLKF
	ERSTRT [SIXBIT/INPDL OV?/]
	MOVE A,(D)	;REMOVE 1ST FREE 4BLK FROM FREE LIST.
	MOVEM A,4BLKF
	SKIPGE INPTR	;IF INPUSHING CMD FILE,
	SETOM INIOPS	;DEFER .IOPUSH TILL NEED COMC AGAIN.
	SETZ A,
	AOSN UNRCHF
	TLO A,400000	;COMPRESS LIMBO, UNRCHF, UNECHF INTO 1 WD.
	AOSN UNECHF
	TLO A,200000
	IORM A,LIMBO
	MOVEI A,(D)
	HRLI A,INPDL
	BLT A,3(D)	;SAVE STATUS OF INPUT SOURCE IN THE 4BLK
	MOVEM D,INPDL	;WHICH NOW IS TOP OF INPUT STACK.
	SETZM INPTR	;SET CURRENT SOURCE TO TTY:
	POPJ P,

INFLS:	PUSH P,[NLTL2]	;:INFLS COMMAND.
INFLS1:	PUSHJ P,INPOP	;KEEP POPPING TILL STACK EMPTY.
	SKIPE INPDL
	JRST INFLS1
	JRST INPOP	;& ONCE MORE TO BE SURE.

INPOP1:	SKIPE TOKTRM	;:INPOP^M - POP INPUT RIGHT NOW.
	JRST [PUSHJ P,INPOP ? JRST NLTL2]
	SKIPG INPTR	;IF CURRENT SOURCE ISN'T VALRET,
	SETZM INVAOB	;RANDOMNESS IN INVAOB MIGHT CONFUSE RELOC.
	PUSHJ P,RLINE	;READ IN A LINE, PREPARE TO RE-READ IT.
	MOVEI W1,INVAOB
	PUSHJ P,JCL0	;READ INTO SYMTAB SPACE, INVAOB GETS AOBJN -> IT.
	SETZ D,		;PUT A ZERO AT END.
	IDPB D,B
	HRRZ A,INVAOB
	HRLI A,10700	;SET UP B.P. TO IT, MUST BE POSITIVE.
	SOS A
	MOVEM A,INPTR	;CLOBBER CURRENT SOURCE WITH IT.
	JRST NLTL2	;WILL READ THAT LINE, THEN POP.

;TERMINATE A VALRET OR CMD FILE, POP TO OUTER INPUT SOURCE.
INPOP:	PUSH P,A
	SKIPGE A,INPTR	;IF SOURCE IS CMD FILE, CLOSE IT.
	JRST [.CLOSE COMC, ? JRST INPOP0]
	JUMPE A,INPOP0
	PUSH P,W1	;VALRET STRING: RELEASE STRING'S STORAGE.
	MOVEI W1,INVAOB
	PUSHJ P,ELEC0
	POP P,W1
INPOP0:	SETZM INPTR	;SET SOURCE TO TTY.
	SETZM UNRCHF
	SETZM UNECHF
	SKIPN D,INPDL	;IF NO SOURCE ON PDL, LEAVE IT THAT WAY.
	JRST POPAJ
	MOVEI A,INPDL
	HRLI A,(D)
	BLT A,INVAOB	;SET CURRENT SOURCE FROM SAVED ONE.
	HLLZ A,LIMBO	;UNPACK UNRCHF, UNECHF FROM LIMBO.
	HRRZS LIMBO
	TLNE A,400000
	SETOM UNRCHF
	TLNE A,200000
	SETOM UNECHF
	EXCH D,4BLKF	;AND FREE THE PDL BLOCK.
	EXCH D,@4BLKF
	SKIPL INPTR	;IF POPPING INTO CMD FILE,
	JRST POPAJ
	AOSE INIOPS	;.IOPOP INLESS WAS NEVER PUSHED.
	.IOPOP COMC,
	JRST POPAJ

INRST:	.RESET TYIC,	;RESET THE CURRENT INPUT SOURCE.
	PUSHJ P,ERTTY1	;TURN ON TTY, TYPE ^V IF WAS OFF.
	PUSHJ P,RTYIC	;IF CURRENT SOURCE IS AT EOF,
	 JFCL		;RTYIC WILL POP IT. (SAVE INPDL SPACE).
	SKIPN INPTR	;IF INPUT NOT FROM TTY,
	POPJ P,
	SKIPE 4BLKF	;PUSH INPUT IF ROOM IN INPDL,
	JRST [7TYPE [ASCIZ/:INPUSH /] ? JRST INPUSH]
	PUSHJ P,INFLS1	;ELSE FLUSH ALL INPUT & TELL USER.
	JSP A,U7TY2
	ASCII /INPDL OV/
;SKIP UNLESS CHARACTER SHOULD BE ECHOED
ECHOT:	CAIN D,^I
	JRST POPJ1
	CAIE D,15
	CAIN D,12
	JRST CPOPJ1
	POPJ P,

IN2B:	SKIPG INPTR	;INPTR -1 FOR CMD FILE,
	.IOT COMC,D
	SKIPL INPTR	;FOR VALRET, IS BYTE POINTER
	ILDB D,INPTR
	ANDI D,177	;MASK TO 7 BITS
	EXCH D,LIMBO
	CAIE D,^M	;IF PREV. CHAR WAS ^M,
	JRST IN2C
	MOVE D,LIMBO
	CAIN D,^J	;IGNORE ^J AFTER ^M.
	JRST IN2B
IN2C:	MOVE D,LIMBO
	CAIN D,^L	;IGNORE FORMFEED.
	JRST IN2B
	POPJ P,

IN2:	PUSHJ P,IN2B
	SKIPE D,LIMBO
	CAIN D,3
	JRST IN3	;^@ AND ^C IS END, POP INPUT SOURCE, TRY AGAIN.
	SKIPE INNCTL
	 JRST IN6	;DON'T CHECK FOR ^B ETC IN FALSE CONDIT.
	PUSHJ P,TYI3B	;SET OR CLEAR VARIOUS FLAGS
	 JRST IN2	;CHAR READ WAS ^V, ETC, TRY AGAIN.
	JRST IN6	;MAYBE LPT THE CHAR.

;PEEK AT A CHARACTER FROM THE INPUT FILE OR VALRET STRING AND SKIP,
;OR DON'T SKIP IF GETTING CHARS. FROM TTY

RTYIC:	SKIPN INPTR	;IF GETTING CHARACTERS FROM TTY,
	POPJ P,		;THEN JUST RETURN
	SKIPGE UNRCHF	;IF CHARACTER SAVED,
	JRST RTYIC2	;THEN USE IT (LEAVE UNRCHF ALONE)
	PUSHJ P,IN2B	;ACTUALLY GET THE CHAR.
	CAIE D,3	;IF NOT CONTROL C,
	JUMPN D,RTYIC3	;AND NOT ZERO, THEN USE IT, SET UNRCHF, AND SKIP-RETURN
	JRST INPOP	;END IT, DON'T LOOK AT NEXT ONE.

RTYIC2:	MOVE D,LIMBO	;RECOVER CHARACTER
	JRST CPOPJ1	;SKIP-RETURN

RTYIC3:	SETOM UNRCHF	;TELL INPUT ROUTINE TO USE IT
	SETOM UNECHF	;TELL INPUT ROUTINE TO ECHO IT
	JRST CPOPJ1
TYO1:	SKIPE LPTOPN	;COME IF TTY OUTPUT OFF,
	SKIPE LPTFLG	;IS LPT OUTPUT ON AND LPT OPEN?
	SKIPN MORPRP	;NO, FLUSH IF MORE-PROCCING.
	POPJ P,
	JRST TYOFLS

LPTR:	SKIPE LPTOPN	;OUTPUT CHAR IN D TO LPT IF OPEN & ON.
	SKIPE LPTFLG
	RET
	.IOT LPTC,D
	POPJ P,

LCT:	7TYPE [ASCIZ /   /]
	POPJ P,

CRF:	PUSH P,D
	MOVEI D,^M
	PUSHJ P,TOUT
	MOVEI D,^J
	PUSHJ P,TOUT
	JRST POPDJ

TSPC:	MOVEI D,40	;SPACE
TOUT:	SKIPGE HAKRQ	;DO PENDING RQ'S FOR HAKKAH.
	PUSHJ P,HAKKAH
	PUSHJ P,LPTR
	SKIPN SILNT
	SKIPE TTYFLG
	JRST TYO1	;NO TTY, MAYBE FLUSH.
	SKIPE U7TCTN	;IF ^N IN 7TYPE IS SUPPRESSING HAIR,
	JRST TYOFI1	;JUST GO DO .IOT.
TYO2:	PUSH P,W1
	AOS TYOTCR
TYO3:	CAIL D,40
	JRST TYONRM	;ORD CHARS TAKE 1 POS.
	MOVEI W1,(D)
	ROT W1,-1
	JUMPGE W1,TYO21
	HRRZ W1,TYOTB(W1)
	JRST (W1)	;FOR CTL CHARS, GO TO SPECIAL RTNS.
TYO21:	HLRZ W1,TYOTB(W1)
	JRST (W1)

TYOTB:	.BYTE 18.
REPEAT 8,TYOCTL		;^@ THRU ^G TAKE 2 SPACES.
TYOBS ? TYOTAB ? TYOLF ? TYOCTL ? TYOFF ? TYOCR
REPEAT 13.,TYOCTL	;^N THRU ^Z
	TYONRM		;ALTMODE TAKES 1 POS.
REPEAT 4,TYOCTL
	.BYTE
TYOCT1:	PUSH P,W1
TYONRM:	AOSN TYOEOP	;IF NO ROOM,
	JRST TYOMOR	;TYPE --MORE--
	AOS W1,TYOCHP	;ADVANCE 1 POS.
TYOTA1:	SKIPE MORPRP
	CAMGE W1,TYOLSZ	;IF LINE FULL,
	JRST TYOFIN
	SKIPN GETTY	;MOVE TO NEXT.
TYOTA2:	SETOM TYOTCR	;FORCE OUT CR.
TYOCR1:	SETZM TYOCHP	;START NEW LINE,
TYOLF1:	AOS W1,TYOLNP	;ADVANCE DOWN.
	CAMN W1,MORPOS	;IF AT BOTTOM,
	SETOM TYOEOP	;SAY NO ROOM.
TYOFIN:	POP P,W1
	SKIPN TYOTCR
	7TYPE [ASCIZ/!
/]			;SYSTEM DOES THIS ON GETTYS.
TYOFI1:	.IOT TYOC,D
	POPJ P,

TYOCTL:	PUSH P,D
	MOVEI D,"^
	PUSHJ P,TYOCT1	;1ST OUTPUT "^".
	MOVE D,(P)
	ADDI D,100
	PUSHJ P,TYOCT1	;THEN, THE UN-CTLED CHAR.
	POP P,D
	JRST POPW1J

TYOCR:	SETZM TYOCHP	;CR, WILL BE AT START OF LINE.
	JRST TYOFIN

TYOLF:	AOSN TYOEOP
	JRST TYOMOR
	JRST TYOLF1

TYOBS:	7TYPE [ASCIZ//]	;^H MIGHT OR MIGHT NOT BACKSPACE,
	JRST POPW1J	;7TYPE WILL ASK ITS WHAT HAPPENED.
TYOTAB:	AOSN TYOEOP
	JRST TYOMOR
	MOVE W1,TYOCHP	;TAB - COMPLICATED SPACING.
	ADDI W1,10
	ANDCMI W1,7	;TO NEXT MULT. OF 8.
	MOVEM W1,TYOCHP
	SUB W1,TYOLSZ
	JUMPL W1,TYOTA1	;IF DIDN'T FILL LINE.
	SKIPN GETTY	;ON GETTYS,
	JRST TYOTA2
	MOVEM W1,TYOCHP	;REMEMBER SPACES ON NEXT LINE.
	JRST TYOLF1

TYOMOR:	SKIPN MORPRP	;TIME TO TYPE --MORE--
	JRST TYO3	;BUT DO NOTHING IF NOT MORE PROC'ING.
	PUSHJ P,TYOMO2
	JRST TYOFLS	;IF USER FLUSHED.
	PUSHJ P,TYOPOS	;ELSE GET NEW POSITION.
	JRST TYO3

TYOFLS:	MOVE P,MORPRP
	SETZM MORPRP
	JRST @MORRET

TYOFF:	SKIPN GETTY
	7TYPE [ASCIZ/

/]
	SKIPE GETTY
	SETOM TYOEOP	;ON GE TTYS, NEW SCREENFULL.
POPW1J:	POP P,W1
	POPJ P,

MORINI:	PUSHJ P,TYOPOS	;GET CURSOR POS.
	SETZM MORNFF
	POP P,D		;RET. ADDR.
	MOVEM D,MORRET	;SAVE IN CASE FLUSHED.
	MOVEM P,MORPRP	;RESTORE P, TOO.
	JRST 1(D)	;SKIP IN-CASE-FLUSHED INSN.

TYOPOS:	PUSH P,D
	TSCALL RCPOSB
	HRRZM D,TYOCHP	;SET POSITION TO ACTUAL VAL.
	HLRZM D,TYOLNP
	HLRZS D
	SETZM TYOEOP	;SAY WHETHER AT EOP.
	CAMN D,MORPOS
	SETOM TYOEOP
	JRST POPDJ

FORMF:	PUSHJ P,CRF
RFORMF:	SKIPE GETTY
	7TYPE [ASCIZ /C/]
	POPJ P,

MORFLS:	SKIPN TTYFLG
	SKIPE SILNT
	JRST MORNTY	;J IF NO OUTPUT TO TTY.
	SKIPN GETTY
	JRST CPOPJ1
	PUSHJ P,TYOPOS	;GET REAL CURSOR POS.
	AOSE TYOEOP	;IF AT SCREEN'S END,
	JRST CPOPJ1
	SETZM MORNFF	;DO MORE PROC.
TYOMO2:	7TYPE [ASCIZ /--MORE--/]
MORFL1:	PUSH P,D
	AOS MORNFF
MORFL5:	SETZM SILNT
	SETOM MORFLG	;MAKE SURE READ FROM TTY.
	PUSH P,LIMBO
	PUSHJ P,IN
	POP P,LIMBO
	SKIPN INPTR	;DON'T CLOBBER LIMBO IF INPUT NOT FROM TTY.
	MOVEM D,LIMBO
	CAIN D,^S
	JRST MORFL5	;IGNORE ^S'S.
	AOSN MORNRO	;MAYBE CONTIN. ON RUBOUT.
	CAIE D,177
	CAIN D,40	;CONTIN. ON SPACE.
	JRST MORGO
	SKIPE INPTR	;DON'T TRY TO RE-READ IF COULN'T SET LIMBO.
	JRST .+3
	CAIE D,177	;THROW AWAY IFF RUBOUT.
	SETOM UNRCHF
	7TYPE [ASCIZ /FLUSHED/]
	JRST POPDJ

MORGO:	7TYPE [ASCIZ/
/]			;DON'T CAUSE ANOTHER --MORE--.
	SKIPE MORNFF	;UNLESS SAID NO, CLEAR SCREEN.
	PUSHJ P,RFORMF
	JRST POPDJ1

RCPOSB:	SIXBIT /@     RCPOS/
	1000,,TYOC ? 402000,,D

;SKIP IF OUTPUT IS GOING SOMEWHERE.
OUTTST:	SKIPN TTYFLG
	SKIPE SILNT
	JRST MORNTY
	JRST POPJ1

MORNTY:	SKIPN LPTFLG	;IF NOT TO LPT EITHER,
	SKIPN LPTOPN
	POPJ P,		;STOP GENERATING OUTPUT.
	JRST POPJ1
NLOGIN:	PUSHJ P,RTOKEN
	SKIPA C,B
NALTU:	JUMPE D,NALTU2	;$U
	MOVE A,RUNAME	;LOGGED IN => JUST SET UNAME.
	AOJN A,[MOVEM C,UNAME ? JRST LCTGNR]
	SETZM TRMNAM
	MOVE W1,TYGTYP
	TRNN W1,20000
	JRST NALTUU
	7TYPE [ASCIZ /
TYPE TERMINAL NUM:  /]
	PUSHJ P,GSOA
	 JRST NXERR
	PUSH P,C
	PUSHJ P,RTOKEN
	POP P,C
	MOVEM B,TRMNAM
	.SUSET [.RIOC+TYOC,,TTYLIN]
	HLRZ A,TTYLIN
	ANDI A,77
	CAIE A,13
	JRST NALTUU
	HRRZ A,TRMNAM
	CAIE A,505050
	JRST LOGOUT
	HLLZS TRMNAM
	.SUSET [.SSNAM,,C]
	.OPEN FDRC,FFILE
	JRST LOGOUT
NALTUU:	.CALL LOGINU
	JRST NXERR
	MOVEM C,UNAME
	JRST NALTU1

LOGINU:	SETZ
	SIXBIT /LOGIN/
	C
	400000,,TRMNAM

NALTU2:	PUSHJ P,RIN
	 JRST ALTDQX	;IF RUBOUT, RETYPE THE $U.
	CAIE D,".
	JRST NXERR
	STDCAL RELOAD,[1000,,-1]
	JRST GSNLRT

NALTU1:	PUSHJ P,DDTUNM	;PUT UNAME IN CERTAIN PLACES.
KINTES:	MOVE C,MSNAM	;RESET SNAME FROM MSNAME.
	MOVEM C,LSNAM
	.SUSET [.SSNAM,,C]
	SKIPN INPTR	;STOP INIT FILE LOOP.
	.OPEN FDRC,INITF	;EXECUTE .DDT. (INIT) FILE IF ANY
	JRST NLOGI3
	STRT ['INIT.]
	MOVEI C,INITF
	JRST XFILE1	;GO INPUSH & OPEN INIT FILE.

NLOGI3:	PUSHJ P,FDRCOP
	MAILF	;PRINT OUT MAIL IF ANY
	JRST NLOGI4
	7TYPE [ASCIZ/--MAIL--/]
	PUSHJ P,MORFL1
	JRST NLOGI4
	PUSHJ P,PRML2
NLOGI4:	SETOM MSGLOG
	JRST MSG0

PRMAIL:	PUSH P,[NLTL6]
	SKIPN TOKTRM
	JRST PRML6
PRML3:	PUSHJ P,FDRCOP
	MAILF
	JRST PRML4
PRML2:	TRO F,PRINTF	;PRINT ALL PAGES.
	PUSHJ P,CTLF1
	.FDELE OMAILF
	JFCL
	.FDELE MAILF
	JFCL
	JRST GSNLRT

PRML4:	SKIPE GETTY
	7TYPE [ASCIZ /
NO MAIL/]
	JRST GSNLRT

PRML6:	PUSHJ P,RTOKEN	;OTHER USER'S MAIL
	JUMPE B,PRML3
	MOVEM B,OTMLFL+1
	PUSHJ P,FDRCOP
	OTMLFL
	JRST PRML4
	TRO F,PRINTF
	JRST CTLF1

KATTAC:	CALL QIJERR
	STDCL ATTACH,[1000,,USRI]
	 JRST NTOPERR
	JRST KATTA1

LOGOUT:	.FDELE OMAILF
	JFCL
KATTA1:	.LOGOUT		;GOOD BYE
NTOPER:	ERSTRT [SIXBIT/NOT TOP LEVEL?/]

DETACH:	.CLOSE TYIC,	;FORCE RE-OPEN WHEN NEXT USE TTY.
	.CLOSE TYOC,
	STDCAL DETACH,[1000,,-1]
	JRST NLTL2
OFDIR:	SKIPE TOKTRM
	JRST OFDIR4	;J IF JUST :OFDIR^M.
	PUSHJ P,RLINE
OFDIR0:	SKIPE TOKTRM	;IF MORE NAMES, HANDLE ONE.
	JRST NLTL2
	PUSHJ P,OFDIR1
	JRST OFDIR0

OFDIR1:	PUSHJ P,RTOKEN	;READ NEXT NAME.
	JUMPE B,CPOPJ
OFDIR5:	MOVSI C,-SNLLEN	;PTR FOR FETCHING FROM SNLIST.
	MOVSI A,-SNLLEN	;PTR FOR STORING BACK.
OFDIR2:	MOVE D,SNLIST+1(C)
	CAMN B,D
	JRST OFDIR3
	MOVEM D,SNLIST+1(A)	;NOT THE ONE TO DELETE - RE-STORE IT.
	AOBJP A,CPOPJ
OFDIR3:	AOBJN C,OFDIR2
	SETZM SNLIST+1(C)
	AOBJN C,.-1	;FILL SNLIST WITH 0'S AT END.
	POPJ P,

OFDIR4:	SETOM SFDIR	;TURN OFF SEARCH FEATURE.
	MOVSI A,-SNLLEN
	SETZM SNLIST+1(A)
	AOBJN A,.-1	;CLEAR SNLIST.
	JRST NLTL2

NFDIR:	SETZM SFDIR	;TURN ON SEARCH.
	SKIPE TOKTRM
	JRST NLTL2
	PUSHJ P,RLINE
NFDIR0:	SKIPE TOKTRM
	JRST NLTL2
	CALL RTOKEN	;READ NAME,
	CALL NFDIR1	;PUT IT IN SNLIST.
	JRST NFDIR0

NFDIR1:	JUMPE B,CPOPJ
	CALL OFDIR5	;DELETE FROM SNLIST,
	MOVSI A,1-SNLLEN   ;ADD TO FRONT,
	EXCH B,SNLIST+1(A) ;MOVE REST DOWN.
	AOBJN A,.-1
	RET
FLOCK:	.SUSET [.RSNAM,,SNLIST]
	SETOM SRFLAG
	MOVE A,[.SSNAM,,SNLIST]
	MOVEM A,INSNAM
FLO2:	.SUSET INSNAM	;TRY THIS DIRECTORY
	.OPEN UTIC,(B)
	JRST FLO3
	HRRZ D,INSNAM
	MOVE D,(D)	;REALLY WANTS WHAT POINTS TO
	AOS (P)
	CAMN D,SNLIST
	JRST FLO4
	MOVEM D,LSNAM
	MOVEM D,SNLIST	;IF SKIP RETURN, SNLIST HAS SNAME USED.
	PUSHJ P,SIXTYP	;LOSER CHANGED DIRECTORY, TELL HIM
	CTYPE ";
	PUSHJ P,CRF
	SETZM SRFLAG
	JRST CPOPJ

FLO3:	SKIPE SFDIR	;TRY SEARCH CROCK?
	POPJ P,	;FAILED, NO SKIP
	PUSHJ P,FLOERR	;UNLESS FILE NOT FOUND, REALLY AN ERROR.
	OPNER (B)
	AOS INSNAM
	HRRZ D,INSNAM
	SKIPE (D)	;IF MORE IN THIS TBL, TRY THEM.
	JRST FLO2
	CAIG D,SNLIS1	;IF WERE SEARCHING 1ST, TRY 2ND.
	JRST FLO5
FLO4:	.SUSET [.SSNAM,,LSNAM]
	SETZM SRFLAG
	POPJ P,	;FAIL, NO SKIP

FLO5:	MOVEI D,SNLIS1
	HRRM D,INSNAM
	JRST FLO3

SMFLCK:	MOVEI A,6
	HRLM A,UFILE(U)
	HRRZ A,UFILE(U)
	CAIN A,(SIXBIT /TTY/)
	TERR (SIXBIT /DEV/)
	POPJ P,

FLOERR:	.STATUS UTIC,A
	LDB A,[220600,,A]
	CAIE A,20	;BAD SNAME?
	CAIN A,4	;FILE NOT FOUND?
	JRST CPOPJ1
	POPJ P,		;ALL OTHERS ARE REALLY BAD.

JJOB:	SKIPE TOKTRM
	JRST ALTJ9
	PUSHJ P,RTOKEN
	MOVEM B,JNAME
	JRST NALTJ1

NALTJ:	JUMPE D,ALTJ9	;JUMP IF NO ARG.
	JUMPE C,NAERR
	MOVEM C,JNAME
NALTJ1:	PUSHJ P,OUSR	;N$J
	JRST NLTL2

N2AJ:	JUMPE D,N2AJ1
	PUSHJ P,QIJERR	;N$$J
	CAMN C,[SIXBIT/PDP6/]
	JRST NAERR
	CAME C,[SIXBIT /PDP10/]
	CAMN C,[SIXBIT /SYS/]
	JRST NAERR	;NOT SYS
	MOVE A,[10,,(SIXBIT/USR/)]
	MOVE B,UUNAME(U)	;TRY OPEN NEW NAME AS FOREIGN USR.
	.OPEN FDRC,A
	CAIA
	7NRTYP [ASCII/ JOB ALREADY EXISTS/]
	.USET USRI,[.SJNAME,,C]	;SET NAME
	MOVEM C,UJNAME (U)	;DOCUMENT
	JRST NLTL2

N2AJ1:	JUMPL U,QJERR	;LOSERS THAT TYPE $$J WITH NO JOBS
	PUSHJ P,LCT	;$$J
	PUSHJ P,ULIST4
	JRST NLTL2

OUSR:	MOVE D,RUNAME	;CHECK USER NAME
	AOJE D,LOGQ	;IF RUNAME IS -1, GUY IS NOT LOGGED IN
	SETZ U,		;SET U TO BEGINNING OF USER STORAGE
	MOVE C,UNAME	;PICK UP UNAME
	MOVE D,JNAME	;AND JNAME
	CAMN D,['SYS,,]
	CAMN C,RUNAME
	CAIA
	 JRST OPUSRT	;SYS JOB & NOT OUR UNAME => SET UNAME.
OUSR2:	CAME C,UUNAME(U)	;DO UNAMES AGREE?
	JRST OUSR5	;NO, TRY NEXT
	CAMN D,UJNAME(U)	;HOW ABOUT JNAME?
	JRST OPUSR	;FOUND USER, MAKE HIM CURRENT JOB
OUSR5:	ADDI U,USRLNG	;NOT THIS ONE, BUMP TO NEXT
	CAIGE U,USREND	;ALL CHECKED YET?
	JRST OUSR2	;NO, KEEP TRYING
	SETZ U,		;YES, GO BACK TO BEGINNING TO LOOK FOR FREE SLOT FOR NEW JOB
OUSR3:	SKIPN UJNAME(U)	;IS THIS SLOT FREE?
	JRST OUSR4	;YES, CREATE NEW JOB
	ADDI U,USRLNG	;NO, TRY NEXT
	CAIGE U,USREND	;ALL CHECKED?
	JRST OUSR3	;NO, TRY AGAIN
	SETOB U,CU		;YES, INDICATE NO CURRENT JOB
	SETZM UCHNLO
	TERR (SIXBIT /TMJ/)	;AND TELL USER

OUSR4:	MOVEM C,UUNAME(U)	;SET UP UNAME AND JNAME FOR NEW JOB
	MOVEM D,UJNAME(U)
	MOVEM D,UFILE1(U)
	MOVE D,MSNAM
	MOVEM D,UFILES(U)
	MOVEI D,(SIXBIT/DSK/)
	MOVEM D,UFILE(U)
	MOVEI D,(SIXBIT/BIN/)
	MOVSM D,UFILE2(U)	;SET UP LOADING FILE NAMES.
	CTYPE "!	;INDICATE THAT THIS IS NEW JOB
	SETOM PERMIT(U)	;ALLOW VALRET STRINGS
	MOVE D,MSTYPE	;INIT. THE JOB'S MULTI-STEP BITS.
	MOVEM D,USTYPE(U)
	MOVE D,SYMTOP
	MOVEM D,UNDEFL(U)	;NO UNDEF SYM REFS THIS JOB.
	MOVEM D,JOBSYM(U)	;NO SYMBOLS.
	MOVEM D,PRGM(U)
	SETZM UINT(U)	;CLEAR INT WORD
	PUSHJ P,OPUSR	;OPEN JOB
	SKIPE SYSSW
	 RET		;ALL DONE IF SYS JOB.
	MOVEI D,21
	MOVEM D,UINTWD(U)	;INDICATE JOB NOT YET STARTED
	.USET USRI,[.RUSTP,,D]	;PICK UP STOP WORD
	TLNE D,100000	;SKIP IF JOB RUNNING
	JRST OUSR4B	;JOB STOPPED
	SETZM UINTWD(U)	;INDICATE JOB RUNNING
	JRST OUSR4A

OUSR4B:	.USET USRI,[.RUPC,,D]	;GET JOB'S PC
	CAMN D,[10000,,0]	;TEST TO SEE IF NEW JOB
	JRST OUSR4A		;YES
	MOVEM D,PPC(U)	;DISOWNED JOB.  SIMULATE INTERRUPT IF NOT RUNNING
	SETOM UINTWD(U)
OUSR4A:	SKIPE INTBIT(U)	;IF NOT FOREIGN USER,
	.USET USRO,[.SSNAM,,MSNAM]	;THEN SET SYSTEM NAME APPROPRIATELY
	SKIPN DDTSW
	POPJ P,	;EXIT IF NOT OPENING SELF
	MOVE D,STBDDT	;SELF - SYM TAB IS DDT SYM TAB.
	MOVEM D,JOBSYM(U)
	MOVEM D,PRGM(U)
	RET

OPUSRK:	SETZM SILNT	;INSURE TYPEOUT NOT FLUSHED
	ANDI U,-1
	MOVE D,UUNAME(U)	;SET UNAME TO THIS JOB'S,
	CALL NUTYP	;TYPE IT OUT IF CHANGED.
	PUSHJ P,NJTYP	;TYPE MUMBLEJ
OPUSR:	JUMPL U,JERR	;COMPLAIN IF ILLEGAL JOB
OPUSRN:	SETZM UCHNLO	;(SO TSINT WON'T THINK CU'S USR CHNLS ARE OPEN.)
	AOS D,NJ1	;GET NEXT JTIME VALUE
	MOVEM D,JTIME(U)	;INDICATE THIS JOB MOST RECENT
	ANDI U,-1
	MOVEM U,CU	;AND CURRENT
	MOVE D,UJNAME(U)
	MOVEM D,JNAME	;SET CURRENT JNAME
	SETZM SYSSW	;FLUSH SYS FLAG
	SETZM DDTSW
	CAMN D,[SIXBIT /SYS/]	;IS JNAME SYS?
	JRST OPUSRS	;YES, TAKE SPECIAL ACTION
	MOVEI D,2
	HRLM D,UFUSR(U)	;SET OPEN MODE TO BLOCK INPUT
OPUSRR:	.OPEN USRI,UFUSR(U)	;OPEN JOB
	JRST OPUSR5	;LOSE
	.SUSET [.RUIND,,B]
	.USET USRI,[.RUIND,,D]
	CAMN B,D
	 SETOM DDTSW	;JOB'S USR IDX = OURS => IT IS US.
	MOVEM D,UIND(U)	;REMEMBER ITS IDX.
	MOVEI D,3
	HRLM D,UFUSR(U)	;SET MODE TO BLOCK OUTPUT
OPUSRW:	.OPEN USRO,UFUSR(U)	;OPEN JOB AGAIN
	JRST OPUSR6	;WIN ON INPUT & LOSS ON OUTPUT => FOREIGN USER
	.USET USRI,[.RINTB,,D]	;PICK UP INTERRUPT BIT
	MOVEM D,INTBIT(U)	;AND SAVE
	SETOM UCHNLO	;INDICATE INFERIOR OPEN
OPUSRB:	.USET USRI,[.RMEMT,,HIGH]	;GET MEM BOUND
OPUSRA:	SKIPE D,UINT(U)
	JRST UBRK0	;THIS JOB CAN INTERRUPT IF IT WISHES.
	POPJ P,

OPUSRS:	SETOM SYSSW	;SET SYS JOB FLAG
	MOVEI D,200000
	MOVEM D,HIGH
	.CLOSE USRI,	;DON'T LET MRDR KILL SOME OTHER JOB.
	.CLOSE USRO,
	SETZM UINTWD(U)
	POPJ P,
OPUSR6:	.STATUS USRI,D
	ANDI C,77
	CAIE D,SNFUSER
	JRST OPUSRU
	CTYPE "#
	MOVEI D,-1
	MOVEM D,UCHNLO
	SETZM INTBIT(U)
	JRST OPUSRB

OPUSRU:	7TYPE [ASCIZ/:REOWNED
/]
	MOVE D,RUNAME	;ATTACHING DISOWNED JOB
	MOVEM D,UUNAME(U)
	CALL NUTYP	;TYPE NEW UNAME (OUR OWN)
	.USET USRI,[.RJNAME,,D]
	CAMN D,UJNAME(U)	;NAME MAY BE CHANGED TO PROTECT THE INNOCENT
	JRST OPUSRW
	MOVEM D,UJNAME(U)
	CALL NJTYP	;TYPE NEW JNAME.
	JRST OPUSRW

OPUSR5:	SAVE UUNAME(U)
	CALL MRDR2	;DELETE THE JOB SLOT,
	REST D
	CAME D,RUNAME	;IF HAD STRANGE UNAME TRY USING OUR OWN.
	JRST OPUSRT
	SETOB U,CU
	OPNER [SIXBIT/   USR      /]

OPUSRT:	SAVE [OUSR]	;RETRY OPEN OF JOB AFTER CHANGING UNAME.
NUTYP1:	MOVE D,RUNAME
NUTYP:	CAMN D,UNAME
	 RET
	CTYPE 40	;UNAME HAS CHANGED, SAY SO.
	MOVEM D,UNAME
	PUSHJ P,SIXTYP
	MOVSI D,(SIXBIT /$U/)
	JRST SIXTYP

NACX:	PUSHJ P,RIN	;$^X., $$^X.
	 JRST ALTDQX
	CAIE D,".
	JRST NXERR
	TLNE B,2ALTF
	JRST MASACR	;$$^X. - KILL ALL JOBS.
KILL:	JUMPL U,JERR
	PUSHJ P,MRDR
ALTJ9:	SKIPE UINT(U)	;$J WITH NO ARG.
	JRST UBRK0	;CURRENT JOB CAN INT. IF IT WANTS TO.
	MOVSI U,-NINFP
ALTJ9A:	SKIPE UINT(U)	;ELSE GIVE ALL OTHER JOBS A CHANCE.
	JRST OPUSRK
	ADDI U,USRLNG-1
	AOBJN U,ALTJ9A
	SOS D,NJ2
	SKIPL U,CU	;IF HAD A CURRENT JOB REMEMBER WHEN IT WAS CURRENT.
	MOVEM D,JTIME(U)
FNJOB:	SETZ U,		;FIND NEW JOB
	SETOB A,CU
FNJOB4:	SKIPE UUNAME(U)	;LOOK FOOR SLOT THAT'S IN USE
	CAML A,JTIME(U)	;AND LESS RECENT.
	 JRST FNJOB5
	MOVE A,JTIME(U)
	MOVEM U,TEM1
FNJOB5:	ADDI U,USRLNG
	CAIGE U,USREND
	JRST FNJOB4
	JUMPL A,MASAC4	;NO JOB FOU D.
	MOVE U,TEM1
	CALL OPUSRK	;TYPE NEW JNAME AND OPEN.
	JRST NLTL2

MRDR:	SETOM CU
	.STATUS USRI,D
	SKIPE D		;IF REALLY HAVE A JOB, DELETE IT.
MRDR1:	.UCLOS USRI,
MRDR2:	MOVS I1,UJNAME(U)	;REMEMBER IF JOS IS SYS.
	MOVEI W1,UCHBUF(U)	;FREE THE JOB'S COMMAND BUFFER.
	PUSHJ P,ELEC0
	MOVEI W1,UNDEFL(U)	;FREE THE UNDEF SYM REF LIST.
	PUSHJ P,ELEC0
	SKIPE HAKING	;IF .BREAK 16,20000, DON'T CHANGE
	 JRST MRDR3	;INFO ON CURRENT JOB.
	SETZM SYSSW
	SETZM UCHNLO
	SETZM DDTSW
MRDR3:	SETZM UUNAME(U)
	MOVSI D,UUNAME(U)
	HRRI D,UUNAME+1(U)
	BLT D,JOBSYM-1(U)
	JRST ELECTRON

MASACR:	PUSHJ P,MASAC1
MASAC4:	SETZM HIGH
	SETOB U,CU
	JRST NLTL2

MASAC1:	SETZ U,
MASAC2:	SKIPN D,UJNAME(U)
	JRST MASAC3
	MOVEI A,2
	HRLM A,UFUSR(U)	;MAKE SURE INPUT MODE, WIN FOR FOREIGN USERS
	CAME D,[SIXBIT /SYS/]
	.OPEN USRI,UFUSR(U)
	JFCL
	PUSHJ P,MRDR
MASAC3:	ADDI U,USRLNG
	CAIGE U,USREND
	JRST MASAC2
	POPJ P,

DISOWN:	PUSHJ P,QIJERR	;$$^K OR :DISOWN
	SETZM UCHNLO
	.DISOWN USRI,
	TERR (SIXBIT /DSN/)
	PUSHJ P,MRDR2
	JRST FNJOB

NCTLC:	7NRTYP [ASCIZ /
/]		;^C

NCTLD:	PUSHJ P,TQUIT1	;RETURN TO TOP, NOT ERROR RETURN.
	TERR 'XXX	;(THUS FLUSH BUFFERED SYLLS)

NACR:	SKIPE SYSSW	;$$^R
	SETOM SYSDPS
	JRST GFLD5

;$$V ROUTINE.
ULIST:	PUSHJ P,CRF
	SETZ U,
ULIST2:	SKIPE UUNAME(U)
	SKIPN D,UJNAME(U)
	JRST ULIST1
	MOVEI D," 
	CAMN U,CU
	MOVEI D,"*
	PUSHJ P,TOUT
	PUSHJ P,TSPC
	PUSHJ P,ULIST4
	PUSHJ P,CRF
ULIST1:	ADDI U,USRLNG
	CAIGE U,USREND
	JRST ULIST2
	MOVE U,CU
	JRST NLTL4

ULIST4:	SKIPE INTBIT(U)
	JRST ULIST3
	MOVE D,UUNAME(U)
	PUSHJ P,SIXTYP
	PUSHJ P,TSPC
ULIST3:	MOVE D,UJNAME(U)
	PUSHJ P,SIXTYP
	PUSHJ P,TSPC
	MOVE D,UINTWD(U)
	CAIN D,21
	JRST ULISTM
	JUMPL D,ULISTP
	JUMPE D,ULISTR
	CAIL D,15
	JRST ULISTP	;AFTER .BREAK 16, TYPE P.
	CAILE D,8
	JRST ULSTRT
	PUSHJ P,TOC
	MOVEI D,"B
	PUSHJ P,TOUT
ULSTRT:	PUSHJ P,TSPC
	HRRZ D,UIND(U)
	JRST TOC

ULISTM:	MOVEI D,"-
	JRST ULSTYP

ULISTR:	MOVEI D,"W
	SKIPN UINT(U)
	MOVEI D,"R
	JRST .+2
ULISTP:	MOVEI D,"P
ULSTYP:	PUSHJ P,TOUT
	JRST ULSTRT
LFILE:	PUSHJ P,QJERR	;:LFILE -- MUST HAVE JOB.
	PUSHJ P,TSPC	;TYPE SPACE, THEN NAME OF LOADED FILE.
	SKIPN D,UFNAMD(U)
	7NRTYP [ASCIZ /NO FILE LOADED
/]
	MOVEI A,UFNAMD(U)
	MOVE B,UFNAMS(U)
	PUSH P,[NLTL2]
	CAIA

;PRINT NAME OF FILE IN BLOCK <- A, SNAME IN B.
LFILE0:	HRLZ D,(A)
	PUSHJ P,SIXTYP
	CTYPE ":
	CTYPE " 
	SKIPN D,B
	JRST LFILE2
	PUSHJ P,SIXTYP
	CTYPE ";
	CTYPE " 
LFILE2:	SKIPN D,1(A)
	POPJ P,
	PUSHJ P,SIXTYP
	CTYPE 40
	MOVE D,2(A)
	JRST SIXTYP

NJTYP:	PUSHJ P,TSPC
	MOVE D,UJNAME(U)	;TYPE JNAME OF CUR JOB AND "$J"
	PUSHJ P,SIXTYP
	MOVSI D,(SIXBIT /$J/)
SIXTYP:	MOVE C,D	;PRINT C(D) AS SIXBIT STOPPING WHEN ZERO
SIXTP2:	MOVEI D,0
	ROTC C,6
	CTYPE 40(D)
	JUMPN C,SIXTP2
	POPJ P,
CTLK:	SETOM TOKTRM	;DON'T READ LINE LATER.
	JUMPE D,CTLK1	;^K
	MOVEM C,SYSN2
	TLZ F,CF+LETFL
	TLNE B,10000
	TLO F,CF
	PUSHJ P,NCOMI	;INIT SFILE.
	JRST ACTRLK

CTLK1:	TLNN B,10000	;NO ARGUMENT
	JRST NXERR
	PUSHJ P,QJERR
	MOVEI D,^M	;MAKE LAST CHAR BE ^M TO END
	DPB D,GSCHRP	;THE FILESPEC CSMI WILL READ.
	JRST CSMI	;NOW GO DO ":SL^M"

ACTRLK:	MOVS D,SYSN2
	TLNE F,LETFL	;UNLESS DEV OR SNAME SPEC'D
	JRST CTLH1
	CAIN D,'SYS	;CHECK FOR SPECIAL JNAMES.
	JRST CTLH3
	CAME D,[SIXBIT /TRNHAC/]
	JRST CTLH1	;GO GET JOB&FILE
CTLH3:	MOVSM D,JNAME	;LOOK AT SYSTEM OR DDT
	PUSHJ P,OUSR
	JRST NLTL2

CTLH1:	SETOM SRFLAG
	.SUSET [.SSNAM,,SFILE+4]
	.OPEN UTIC,SFILE
	SKIPA B,[SFILE]	;FAILED - TRY SYS, SNLIST.
	JRST CHWIN	;FOUND ON <MSNAM>; .
	TLNE F,LETFL	;IF DEV OR SNAME SPEC'D, TRY NO OTHER.
	OPNER SFILE
	PUSHJ P,FLOERR	;IF BAD ERROR,
	JRST CTLHER	;DON'T KEEP LOOKING.
	.SUSET [.SSNAM,,[SIXBIT/SYS/]]
	PUSHJ P,FLOCK
	JRST CTLHER
	MOVS B,SNLIST	;IF NOT FOUND IT ON SYS,
	CAIE B,'SYS
	MOVSM B,SFILE+4	;SET DEFAULT SNAME TO ONE FOUND ON.
	CAIN B,'SYS	;FOUND ON SYS, SET DEVICE INSTEAD.
	HRRM B,SFILE
CHWIN:	SKIPN TOKTRM
	PUSHJ P,RLINE	;IF JCL CMD AFTER :FILENAME .
	MOVE D,SYSN2	;GET JNAME FOR JOB
	MOVEM D,JNAME
	CALL NUTYP1	;MAKE SURE HAVE OUR OWN UNAME.
	PUSHJ P,OUSR
	MOVEI B,UFILE(U)	;COPY NAME OF FILE READ INTO $L DEFAULT.
	HRLI B,SFILE
	BLT B,UFILES(U)
	HRRZ B,SFILE	;BUT IF DEFAULTED TO SYS:,
	CAIN B,'SYS
	SETOM UFLSYS(U)	;CHANGE IT TO DSK: BEFORE $Y.
	SKIPGE UCHNLO	;IF INFERIOR OPEN,
	JRST .+3	;THEN ALL RIGHT,
	.CLOSE UTIC,	;INFERIOR NOT OPEN, CLOSE INPUT FILE
	JRST JERR	;COMPLAIN IN ENGLISH
	PUSHJ P,JCL
	MOVEI D,B1ADR+1(U)
	HRLI D,-1(D)
	SETZM B1ADR(U)
	BLT D,BPEND-1(U)
	PUSHJ P,ALOAD
	MOVE D,STARTA(U)
	JRST HGO

CTLHER:	MOVEI D,'SYS	;PRINT SYS: IN ERROR MSGS, NOT DSK.
	HRRM D,SFILE
	OPNER SFILE
NCTLU:	TRZA B,-1	;^U, $^U, $$^U .
NCTLT:	HRRI B,1	;^T, $^T, $$^T .
	MOVE D,RUNAME
	AOJE D,LOGQ	;ILLEGAL UNLESS LOGGED IN.
	MOVEM C,NCTLTA	;SAVE ARG (AIO)
	PUSHJ P,GSOT
	MOVEI C,NCTLTF
	MOVSI D,'*_14	;SET FILENAMES TO *.
	MOVEM D,NCTLTF+1
	MOVEM D,NCTLTF+2
	MOVEM D,NCTLTF+4
	HLRZM D,NCTLTF
	PUSHJ P,RRFL1	;READ 1ST NAME.
	MOVE D,[NCTLTF,,NCTLTF+5]
	BLT D,NCTLTF+7	;COPY TO BLOCK FOR .CALL .
	HRLZS NCTLTF+5	;LEFT-JUST DEV.
	MOVE D,NCTLTF+4
	MOVEM D,NCTLTF+8	;TRANSFER SNAME.
	TRNN B,1	;^U => ONLY ONE NAME TO READ.
	JRST NCTLU1
	PUSHJ P,LINK2
	 7TYPE [ASCIZ/INTO: /]	;PROMPT FOR ANOTHER LINE IF NEC.
	PUSHJ P,RRFL1
	MOVE D,NCTLTF+4
	MOVEM D,NCTLTF+3
	HRLZS NCTLTF	;NOW HAVE 4 CONSEC. LEFT-JUST NAMES.
NCTLU1:	MOVEI A,USRI	;START CONSTRUCTING 1ST ARG.
	TLNE B,1ALTF
	MOVEI A,-1	;$^T => ON SELF.
	TLNE B,1ALTF+2ALTF
	TLO A,200000	;1 OR 2 ALTS => INFERS ALSO.
	MOVE C,[440600,,NCTLTA]
	SKIPN NCTLTA	;NULL ARG => IO.
	TLO A,3
NCTLU2:	ILDB D,C	;LOOK FOR A, I, O IN ARG.
	JUMPE D,NCTLU3
	SETZ W1,
IRPS X,,A J I O,Y,,400000 200000 1 2
	CAIN D,'X
	MOVEI W1,Y
TERMIN		;CHECK FOR MEANINGFUL CHARS.
	JUMPE W1,NAERR
	TLO A,(W1)
	JRST NCTLU2

NCTLU3:	MOVE C,[SIXBIT/TRANDLTRANAD/](B)
	.CALL NCTLUB
	JRST ERR
	JRST NLTL3

NCTLUB:	SETZ?SIXBIT/CALL/
	C	;EITHER TRANDL OR TRANAD
	A	;SAYS WHICH TRANSL LIST TO USE
	[-4,,NCTLTF+5]	;1ST (OR ONLY) NAMES
SETZ	[-4,,NCTLTF]	;2ND SET ( USED ONLY BY TRANAD)

;:LISTF <DIRECTORY-SPEC> <CR>
LISTF:	MOVEI C,FFILE
	PUSHJ P,RRFL4	;READ IN DEV & SNAME ONLY.
	HRRZ D,FFILE
	SETZB B,C

NCTLF:	JUMPE D,NCTLF1
	TRNE C,-1	;IF NAME HAS >3 CHARS, MUST BE SNAME.
	JRST NCTLF3
CTLF0:	HRRM D,FFILE
	TLNE B,1ALTF	;UNLESS WAS $^F,
	JRST NCTLF1
	HRRM D,PFILE	;IF ARG, SET ^O, $L DIRS.
	MOVE C,LSNAM
	MOVEM C,PFILE+4
	JUMPL U,NCTLF1
	MOVEM C,UFILES(U)
	HRRM D,UFILE(U)
	SETZM UFLSYS(U)	;DEV. WASN'T DEFAULTED BY ^K.
NCTLF1:	PUSHJ P,FDRCOP
	FFILE
	JRST NCTLF2
OPRINT:	PUSHJ P,CTLF4
	JRST NLTL2

CTLF4:	PUSHJ P,FORMF
CTLF1:	PUSHJ P,MORINI
	 JRST CTLF2	;ON FLUSHING XCT THIS.
CTLF3:	PUSHJ P,FDRCI
	JUMPL D,CTLF2
	CAIN D,^L
	JRST CTLF6
	CAIN D,^C
	JRST CTLF2
CTLF5:	PUSHJ P,TOUT
	JRST CTLF3

CTLF6:	TRNE F,PRINTF	;IF NOT :PRINT, STOP ON FF.
	JRST CTLF5	;ELSE NORMAL CHAR.

CTLF2:	SETZM MORPRP	;END --MORE-- PROC.
	TRZ F,PRINTF
	.CLOSE FDRC,
	JRST GSNLRT

NCTLF2:	.STATUS FDRC,D
	LDB D,[220600,,D]
	CAIE D,1	;IF NON-EX-DEVICE,
	OPNER FFILE
	HRLZ D,FFILE	;TRY USING AS SNAME.
	CAIA
NCTLF3:	SKIPE D,C
	MOVEM D,LSNAM
	.SUSET [.SSNAM,,LSNAM]
	MOVEI D,(SIXBIT/DSK/)
	JRST CTLF0	;GO SET DEVICE.
LINK:	MOVEI C,PFILE
	PUSHJ P,RRFL1	;READ IN "FROM" FILE.
	.OPEN FDRC,PFILE	;DON'T LET USER DELETE WITH :LINK.
	JRST LINK3
	.CLOSE FDRC,
	7TYPE [ASCIZ/FILE EXISTS - /]
	MOVE B,PFILE+4	;GET SNAME,
	MOVEI A,(C)	;ADDR OF BLOCK,
	PUSHJ P,LFILE0	;PRINT FROM- FILE'S NAME.
	JRST ERR5

LINK3:	PUSH P,FFILE	;SAVE THIS DEV, SNAME.
	PUSH P,LSNAM
	MOVE A,[PFILE,,NCTLTF]	;COPY INTO BLOCK.
	BLT A,NCTLTF+2
	PUSHJ P,LINK2	;WARN IF MUST READ ANOTHER LINE.
	 7TYPE [ASCIZ/TO: /]
	PUSHJ P,RRFL1	;READ TO- FILE.
LINK4:	MOVE A,PFILE+4	;GET SPEC'D SNAME.
	HRRZ B,PFILE
	CAIN B,(SIXBIT/SYS/)
	MOVSI A,(B)	;BUT OVERRIDE FOR PHONY DISK DEVS.
	CAIN B,(SIXBIT/COM/)
	MOVE A,[SIXBIT/COMMON/]
	CAIN B,(SIXBIT/TPL/)
	MOVE A,[SIXBIT/.LPTR./]
	MOVEM A,NCTLTF+5	;PUT SNAME IN BLOCK.
	MOVE A,[PFILE+1,,NCTLTF+3]
	BLT A,NCTLTF+4	;COPY NAMES INTO BLOCK.
	POP P,LSNAM	;RESTORE "FROM"- DEV, SNAME.
	POP P,FFILE
	.SUSET [.SSNAM,,LSNAM]
	MOVEI A,200000
	HRLM A,NCTLTF	;SAY MAKE LINK.
	.OPEN FDRC,NCTLTF
	OPNER NCTLTF
	.CLOSE FDRC,
	JRST NLTL3

LINK2:	SETOM GSONUM	;SAY DON'T RE-READ PREVIOUS CHAR. IN RRFL1.
	SKIPL TOKTRM	;IF USED UP LINE,
	JRST CPOPJ1
	SETZM TOKTRM	;FORCE TO READ ANOTHER.
	POP P,LINKRT'	;CAN'T POP AFTER GSOA.
	XCT @LINKRT	;DO CALLER'S ACTION BEFORE GSOA.
	AOS LINKRT	;(ELSE WOULD HAPPEN AFTER RUBOUT).
	PUSHJ P,GSOA
	 JRST NCTLD
	JRST @LINKRT	;RET. TO CALLER.
FFLAP:	PUSHJ P,RONUM
	 JRST ALTDQX
	MOVE D,A
	JUMPE B,NXERR
	JRST FFLAP1

N2ACF:	SKIPN ARG1+1	;$$^F
	JRST NAERR
	MOVE D,ARG1
FFLAP1:	.UDISMT D,
	ERSTRT [SIXBIT/UNFLAPPABLE?/]
	JRST NLTL2

NCTLO:	PUSHJ P,GSOT	;TYPE " ", INIT RUBOUT PROC.
	CAIA
RENAME:	TLO B,20000	;SET 2-ALTMODE FLAG.
DELETE:	MOVE D,RUNAME
	AOJE D,LOGQ	;MUST BE LOGGED IN.
	MOVEI C,PFILE
	PUSHJ P,RRFL1	;READ 1ST FILE NAME.
	MOVE A,[PFILE+1,,NCTLTF+1]
	BLT A,NCTLTF+2	;COPY FN1, FN2 INTO BLOCK.
	SETZM NCTLTF+3	;IN CASE DELETE, SET NEW FN1.
	TLNN B,20000	;IF RENAME,
	JRST RENAM1
	PUSHJ P,LINK2	;READ 2ND FILE NAME.
	 7TYPE [ASCIZ/TO: /]	;PROMPT IF NO COMMA.
	PUSHJ P,RRFL1
	MOVE A,[PFILE+1,,NCTLTF+3]
	BLT A,NCTLTF+4	;COPY NEW FN1, FN2 INTO BLOCK.
RENAM1:	MOVE A,PFILE	;MOVE DEV INTO BLOCK.
	MOVEM A,NCTLTF
	.FDELE NCTLTF
	 OPNER NCTLTF
	TLNN B,10000
	SKIPL GETTY	;IF GE TTY AND 0 OR 2 ALTMODES,
	JRST NLTL2
	JRST NCTLF1	;PRINT DIR.

TPL:	.OPEN FDRC,[1,,'TPL ? -1]	;HAVE SYS GENSYM A NAME.
	OPNER @.-1
	MOVE A,[FDRC,,NCTLTF]
	.RCHST A,		;FIND OUT WHAT NAME WAS USED.
	MOVEI A,'TPL	;MAKE LINK FROM TPL WITH THAT NAME.
	MOVEM A,NCTLTF
	.CLOSE FDRC,
	MOVEI C,PFILE	;USE :PRINT DEFAULTS.
	PUSHJ P,RRFL1	;READ FILE NAMES.
	PUSH P,FFILE	;SET UP TO ENTER :LINK.
	PUSH P,LSNAM	;WHICH WILL POP THESE & EXIT.
	JRST LINK4

XFILE:	MOVEI C,XFILEF
	PUSHJ P,RRFL1
	.OPEN FDRC,XFILEF	;IF CAN'T OPEN, FAIL NOW
	OPNER PFILE
XFILE1:	.CLOSE FDRC,	;BEFORE CALLING INPUSH.
	PUSHJ P,INPUSH
	AOSN INIOPS	;IF SOURCE PUSHED WAS ALSO CMD FILE...
	.IOPUSH COMC,
	TSOPEN COMC,(C)
	SETOM INPTR	;INDICATE READING CMD FILE.
	JRST NLTL2

PRINT:	MOVEI C,PFILE
	PUSHJ P,RRFL1
	TSOPEN FDRC,PFILE
	TRO F,PRINTF
	JRST OPRINT

; :WALLP - TURNS ON "LINE PRINTER" OUTPUT TO SPECIFIED FILE

KWALBE:			;ALSO :WALBEG.
WALLP:	MOVE A,RUNAME	;GET REAL USER NAME,
	AOJE A,LOGQ	;IF NOT LOGGED IN THEN COMPLAIN
	MOVEI C,WFILE	;GET PNTR TO FILE NAMES
	PUSHJ P,RRFL1	;READ IN FILE DESCRIPTION
	SETZM LPTOPN	;(IN CASE THE OPEN FAILS)
	TSOPEN LPTC,WFILE
	SETOM LPTOPN	;SUCCESS, LPT IS OPEN.
	SETZM LPTFLG	;TURN ON LPT OUTPUT.
	JRST NLTL2

;:WALEND - CLOSE WALLPAPER FILE.
KWALEN:	.CLOSE LPTC,
	SETZM LPTOPN
	JRST NLTL2

;:EXISTS <FILE>     ZERO IFF FILE CAN BE OPENED.
KEXIST:	MOVEI C,PFILE
	CALL RRFL1	;READ FILE NAMES.
	SETZ A,		;ASSUME CAN BE OPENED
	.OPEN FDRC,PFILE
	 SETO A,	;UNLESS IT FAILS.
	.CLOSE FDRC,
	JRST GSOCTJ	;RETURN NUMBER.

;SET FILE'S DATE.
SFDATE:	MOVEI C,PFILE
	PUSHJ P,RRFL1	;READ FILE'S NAME.
	PUSHJ P,LINK2	;PROMPT FOR DATE IF NONE.
	 7TYPE [ASCIZ/DATE: /]
	PUSHJ P,RDATE	;READ IN DATE,
	 JSP W2,RCH	;GET CHARS W/ THIS INSN.
	.OPEN FDRC,PFILE
	OPNER FDRC,PFILE
	TSCALL SFDATB
	JRST SFDAT1

SFDATB:	SETZ ? SIXBIT /SFDATE/
	1000,,FDRC ? SETZ C

KCOPY:	MOVEI C,PFILE	;:COPY <FILE1>,<FILE2>
	PUSHJ P,RRFL1	;READ <FILE1>
	.OPEN FDRC,PFILE
	OPNER PFILE
	CALL LINK2	;IF SAW A CR, PROMPT FOR <FILE2>
	 7TYPE [ASCIZ/TO: /]
	CALL RRFL1	;READ <FILE2>
	HRLZ D,PFILE
	STDCAL OPEN,[[3,,UTOC] ? D ? PFILE+1 ? PFILE+2]
	CALL VPAGET	;OBTAIN A BUFFER.
KCOPY1:	MOVE A,[-2000,,VPAGAD]
	.IOT FDRC,A	;READ IN UP TO 1 K.
	HRLOI B,-1-VPAGAD(A)
	EQVI B,VPAGAD	;AOBJN -> WHAT WAS READ.
	.IOT UTOC,B
	JUMPGE A,KCOPY1	;FILLED UP THE BUFFER => TRY AGAIN.
	CALL VPAGRT	;EOF, RETURN BUFFER.
	.CLOSE UTOC,
SFDAT1:	.CLOSE FDRC,
	JRST NLTL4
;COME HERE FROM TSINT ON INTERRUPT.
TSIN0:	MOVEM 17,INTACS+17
	MOVEI 17,INTACS
	BLT 17,INTACS+16
	PUSH P,UUOH
	PUSH P,40
	SETOM INTING	;NOW WE ARE PI-IN-PROG, CAN'T DO HAKKAH.
	SKIPL I1,TSINT
	JRST OTHERI
	TRZE I1,1_<TYIC>
	PUSHJ P,TSINTT
	TRZE I1,1_<COMC>
	PUSHJ P,TSINTC
	JUMPE I1,UDISMS
	SETZB U,INTIOP	;USR CHNLS NOT PUSHED YET THIS INT.
TSIN2:	TDZE I1,INTBIT(U)
	JRST TSIN3
TSIN22:	ADDI U,USRLNG
	CAIGE U,USREND
	JUMPN I1,TSIN2
	SKIPN INTIOP	;IF USR CHNLS WERE PUSHED, POP THEM.
	JRST TSIN23
	.IOPOP USRO,
	.IOPOP USRI,
TSIN23:	TLNE I1,377777
	ERLOSS I1	;INT FROM UNKNOWN JOB.
	SETZM INTING	;ABOUT TO BE NO LONGER PI-IN-PROG.
	MOVE A,TTYUSR	;CURRENT JOB CAN INTERRUPT RIGHT NOW.
	SKIPN SARS	;IF DDT IS SLEEPING.
	SKIPN UINT(A)
	JRST TSIN24
	MOVEI A,UBREAK
	MOVEM A,TSINT+1
UDISMS:	POP P,40
	POP P,UUOH
UDISM1:	MOVSI 17,INTACS
	BLT 17,17
UDISMX:	.DISMISS TSINT+1

TSIN24:	PUSHJ P,%SAVEI	;RETURN STOLEN TTY UNLESS WITHIN HAKKAH.
	SKIPL HAKRQ
	JRST UDISMS
	MOVE A,@TSINT+1
	TRZ A,-1
	CAMN A,[.IOT TYIC,]
	JRST TSIN25
	SKIPE SARS
	JRST UDISMS
TSIN25:	MOVE A,TSINT+1
	POP P,40
	POP P,UUOH
	PUSH P,A	;HAKKAK WILL RETURN WHERE WE WOULD HAVE.
	MOVEI A,HAKKAH
	MOVEM A,TSINT+1	;WE'LL RETURN TO HAKKAH.
	MOVE A,[1,,1]	;(WE WANT P TO BE CHANGED
	ADDM A,INTACS+P	;BUT P WILL BE RESTORED)
	JRST UDISM1

TSWARN:	JSP I4,%SAVE
	SKIPE GETTY
	.IOT TYOC,["^]
	.IOT TYOC,[^G]
	SKIPE GETTY
	7TYPE BELLS
	JRST %UNSAVE

OTHERI:	TRZE I1,SYSDDB
	PUSHJ P,SYSDED
	TLZE I1,(ALARMB)
	PUSHJ P,ALARMI
	TLZE I1,(SYSDBB)
	PUSHJ P,SYSDBG
	TRZE I1,BCLI	;IF :SEND SEEN, TELL HAKKAH ABOUT IT.
	JRST [SETOM HAKCRQ ? SETOM HAKRQ ? JRST .+1]
	TLZE I1,(PUR)
	 PUSHJ P,PURBR1
	TRZE I1,BIOC
	PUSHJ P,IOCBRK
	TRZE I1,MPV
	PUSHJ P,MPVBRK	;MEM PROT VIOLATION
	SETZM INTING	;NEED NOT PREVENT HAKKAH-ING ANY MORE.
	CAIG I1,1
	 JRST TSIN24	;DISMISS UNLESS UNKNOWN INT.
	PUSH P,I1
	ERLOSS TSINT+1

%SAVE:	PUSH P,TEM
%SAVE1:	SKIPE DDTTY	;IF DON'T HAVE TTY, STEAL IT.
	JRST (I4)
	.DTTY USRI,
	 JFCL
	SETOM DDTTY	;HAVE TTY NOW.
	SETOM TTYSTL	;SAY TTY IS STOLEN.
	JRST (I4)

%SAVEI:	SKIPN HAKING	;AT INT LVL, RETURN STOLEN TTY UNLESS WITHIN HAKKAH.
%SAVEX:	SKIPN TTYSTL	;IN HAKKAH, RETURN TTY IF STOLEN.
	POPJ P,
	SETZM TTYSTL	;TTY NO LONGER STOLEN.
	SETZM DDTTY	;NO LONGER POSESSED.
	.ATTY USRI,
	 JFCL
	POPJ P,

IOCBRK:	AOSN LOADF
	JRST FILENG
IOCBK2:	SOS I2,TSINT+1
	LDB I3,[270400,,(I2)]
	DPB I3,[270400,,IOCX]
	XCT IOCX	;THIS IS A .STATUS
	LDB I4,[330500,,I4]
	CAIN I4,9
	JRST IOCFUL
	CAIN I4,8
	JRST IOCOPN
IOCER2:	OPNER ['IOC ? 0 ? 0]

MPVBRK:	AOSE XRWI	;WAS THIS EXPECTED?
	JRST MPVBR1
	AOS TSINT+1	;YES CAUSE RETURN TO SKIP
	POPJ P,

MPVBR1:	SKIPE DEBUGP
	.VALUE
	PUSHJ P,COMPLN	;NOT EXPECTED, COMPLAIN
	HRRZ D,TSINT+1
	TERR (SIXBIT /MPV/)

PURBR1:	SOS TSINT+1	;WILL PROBABLY WANT TO RETRY INSN.
	SKIPE XRWI	;ARE WE DOING A DEP OR RDEP?
	SKIPN UNPURF	;AUTO-UNPURE WANTED?
	 JRST PURBR2	;ONE OR OTHER WAS NO.
	SKIPGE A,INTACS+A ;LETS UNPURIFY, GET ADDR WERE DEPOSTING IN.
	 JRST PURBR3	;WERE DEPOSITING IN ..DDT+MUMBLE.
	PUSHJ P,UNPUR1	;TRY TO UNPURIFY. (MAY FAIL & SKIP)
	 JRST [JSP I4,%SAVE1	;SUCCEEDED, TELL USER.
		7TYPE [ASCIZ/ :UNPURE /]
		MOVE D,INTACS+A
		PUSHJ P,TOC
		JRST LCTGNR]

PURBR2:	SKIPN DDTSW	;IF HAVE SELF OPEN,
	 JRST PURBR3
	.SUSET [.RMPVA,,A]
	CAIL A,STBDE-10*2000	;WERE WE WRITING IN DDT SYM TAB?
	CAIL A,STBDE
	 JRST PURBR3
	CALL UNPUR1	;YES, UNPURIFY.
	 RET
PURBR3:	PUSHJ P,COMPLN
	HRRZ D,TSINT+1
	TERR (SIXBIT /PUR/)

IOCFUL:	CAIE I3,UTOC
	JRST IOCER2
	MOVEM I3,IOCF+2
	.GENSYM I4,
	MOVEM I4,IOCF+3
	.FDELE IOCF
	JRST ERR
	.CLOSE UTOC,
	MOVE I4,UFILE(U)
	MOVEM I4,IOCF+2
	.FDELE IOCF+2
	JFCL
	ERSTRT [SIXBIT/DEVICE FULL?/]

TSINTT:	SKIPA I3,[TYIC]
TSINTC:	MOVEI I3,COMC
	MOVEI I4,(I3)
	.ITYIC I3,
	POPJ P,
	CAIN I3,^S	;MUST CHECK FOR ^S BEFORE TYI3B DOES.
	JRST SILNCE
	MOVE D,I3
	CAIE I4,COMC	;IF FROM TTY,
	PUSHJ P,TYI3B	;CHECK FOR ^V, ^W, ^B, ^E.
	 JFCL
	CAIE I3,^G
	POPJ P,
	.RESET TYOC,
	SKIPN I3,TQUITR	;CLOBBER NON-QUITTING CODE'S EXIT
	MOVEI I3,TSINT+1	;OR INTERRUPT EXIT IF NOT IN NON-QUITTING CODE.
	MOVEI D,TQUIT
	EXCH D,(I3)	;MAKE IT RETURN TO AN ERROR MESSAGE.
	SKIPE TQUITR	;IF IN NON-QUITTING CODE
	CAIN D,TQUIT	;AND THIS IS 1ST ATTEMPT TO QUIT,
	POPJ P,
	.SUSET [.SRTMR,,[40000]]
	.SUSET [.SIMASK,,[1^5,,]]
	POPJ P,		;CAUSE "DDT BUG" MSG IF RUN 64 MSEC
			 ;WITHOUT QUITTING.

TQUIT:	PUSHJ P,TQUIT0	;MUST RESET COMPLETELY.
	SKIPN UUNAME(U)
	SETZM HIGH
	SKIPN UUNAME(U)
	SETOB U,CU
	ERSTRT [SIXBIT/QUIT?/]

TQUIT0:	PUSHJ P,INFLS1	;RESET LOCAL IOPDL
	.IOPDL		;AND SYSTEM'S.
	SETZM INIOPS
	.CLOSE COMC,
TQUIT1:	MOVEI D,DD2	;RETURN TO ABSOLUTE TOP LEVEL
	MOVEM D,ERRSTL	;RATHER THAN THE ERROR-RETURN.
	POPJ P,

SILNCE:	.RESET TYOC,
	HLRZ I3,@TSINT+1	;IF HUNG AT TYOC IOT,
	CAIN I3,(.IOT TYOC,)
	AOS TSINT+1	;DON'T RETURN TO OUTPUT IOT
	SETOM SILNT
	POPJ P,

SYSDED:	JSP I4,%SAVE
	.DIETIM D,
	JUMPL D,SYSDD2
	MOVE A,D
	JSP I4,SHFDRC
	MOVE D,A
	PUSHJ P,DDTGDM
	JSP I4,OPFDRC
%UNCRF:	PUSHJ P,CRF
%UNSAVE:	POP P,TEM
	POPJ P,

SYSDD2:	7TYPE [ASCIZ /
ITS REVIVED!/]
	JRST %UNCRF

SYSDBG:	JSP I4,%SAVE
	7TYPE DDTDBM
	JRST %UNCRF

IOCOPN:	CAIE I3,TYIC
	CAIN I3,TYOC
	JRST .+2
	JRST IOCER2
IOCOP1:	TSOPEN TYOC,TYOF
	TSOPEN TYIC,TYIF
	TSCALL TTYSBK
	TSCALL RSSIZB
	SOS MORPOS
	TSCALL TTYGYP
	MOVEM I4,TYGTYP
	SKIPE GETTY
	SETOM GETTY
	MOVEI I3,120.
	TLNE I4,5000	;IF MEMOREX OR DATEL,
	MOVEM I3,TYOLSZ	;LARGER LINES.
	POPJ P,

TTYSBK:	SETZ
	SIXBIT /TTYSET/
	[TYOC]
	[232222,,222222]
	[230222,,120222]
	400000,,[200000,,]

RSSIZB:	SIXBIT /@     RSSIZE/
	[TYOC]
	2000,,MORPOS
	402000,,TYOLSZ

TTYGYP:	SETZ
	SIXBIT /TTYGET/
	[TYOC]
REPEAT 4,2000,,I4
	402000,,GETTY

ALARMI:	JSP I4,%SAVE
	MOVEI D,20.*60.
	MOVE I4,[600000,,D]
	.REALT I4,
	SETZM ALARMV
	7TYPE BELLS
	7TYPE ALARMM
	7TYPE [ASCIZ /
TYPE :ALARM<CR> TO CLEAR/]
	7TYPE BELLS
	JRST %UNCRF

BELLS:	ASCIZ //
ALARMM:	ASCIZ /
ALARM /

ALARM:	SKIPE TOKTRM
	 JRST ALARMC	;:ALARM<CR> => CLEAR ALARM.
	MOVE I1,[JSP W2,RCH]	;MSGNUM DOES XCT I1 TO READ A CHAR.
	SETZ A,		;ACCUMULATE TIME OF ALARM IN A.
	MOVE W1,[-3,,[24. ? 60. ? 60.]]
ALARM1:	SAVE A
	PUSHJ P,MSGNUM	;READ 1 DECIMAL NUM (BUT DON'T READ PAST CR).
	REST A
	MOVE B,C	;BRING IT IN RANGE.
	IDIV B,(W1)
	IMULI A,60.
	ADDI A,(C)	;PUT THIS BASE-60 DIGIT IN TIME.
	AOBJN W1,ALARM1
	.RTIME B,
	MOVE W1,[-6,,[0 ? 10. ? 6 ? 10. ? 6 ? 10.]]
	MOVE I1,[440600,,B]	;BP IN CURRENT TIME (SIXBIT)
ALARM2:	ILDB D,I1	;NEXT DIGIT OF CURRENT TIME.
	IMUL C,(W1)	;EACH DIGIT HAS ITS OWN RADIX.
	ADDI C,-'0(D)
	AOBJN W1,ALARM2
	SUB A,C		;# SECONDS FROM NOW ALARM SHOULD RING.
	SKIPG A
	ADDI A,24.*60.*60.
	PUSH P,A
	IMULI A,60.
	MOVE B,[600000,,A]
	.REALT B,
	7TYPE ALARMM
	SKIPE ALARMV
	7TYPE [ASCIZ /RE/]
	7TYPE [ASCIZ /SET FOR .+/]
	MOVEM A,ALARMV
	POP P,D
	PUSHJ P,TMPT
	JRST NLTL2

ALARMC:	MOVSI I4,400000
	.REALT I4,
	SETZM ALARMV
	7TYPE ALARMM
	7TYPE [ASCIZ /CLEARED/]
	JRST NLTL2

TMPT:	MOVEI C,0
	JUMPE D,CPOPJ
	CAMGE D,TMT1(C)
	AOJA C,.-1
TMP3:	IDIV D,TMT1(C)
	CTYPE "0(D)
	MOVE D,W1
	TRNN C,1
	AOJA C,TMP3
	CAIL C,5
	POPJ P,
	CTYPE ":
	AOJA C,TMP3

TMT1:	36000.
	3600.
	600.
	60.
	10.
	1


COMPLN:	PUSHJ P,ERTTY
	MOVEI D,8
	MOVEM D,ODF	;SET CURRENT RADIX TO OCTAL
CMPLN2:	PUSHJ P,TSPC
	XCT @(P)
	PUSHJ P,TOC
	AOS (P)
	MOVEI D,",
	PUSHJ P,TOUT	;DON'T CHANGE TO A UUO, WILL CLOBBER 40, UUOH, ETC.
	JRST CMPLN2

ERTTY:	SETZM TTYSTL	;SHOULDN'T TRY GIVING TTY BACK.
	.DTTY USRI,
	 JFCL
	SETOM DDTTY	;NOW DDT HAS TTY.
ERTTY1:	SETZM MORPRP	;SUPPRESS --MORE-- WHEN TYPE ERROR.
	MOVE A,TTYFLG
	SETZM TTYFLG	;TURN ON TTY OUTPUT.
	JUMPE A,CPOPJ
	PUSH P,D
	MOVEI D,^V	;IF HAD BEEN OFF, TYPE "^V ".
	PUSHJ P,TOUT
	PUSHJ P,TSPC
	JRST POPDJ
TSIN3:	SKIPE INTIOP	;IF WE'VE PUSHED USR CHNLS, MUST RE-OPEN.
	JRST TSIN3B
	SKIPL HAKIOP	;IF HAKKAH PUSHED USR CHNLS
	SKIPL UCHNLO	;OR IF THEY AREN'T OPEN YET, CAN'T USE THEM.
	JRST TSIN3D
	CAMN U,CU	;UNLESS INT FROM CURRENT USER,
	JRST TSIN3C
TSIN3D:	.IOPUSH USRI,	;MUST PUSH AND RE-OPEN.
	.IOPUSH USRO,
	SETOM INTIOP
TSIN3B:	MOVE I3,UUNAME(U)
	MOVEM I3,TUNAME
	MOVE I3,UJNAME(U)
	MOVEM I3,TJNAME
	MOVEI I3,2
	HRLM I3,TSUSRF
	.OPEN USRI,TSUSRF
	JRST TSIN22
	MOVEI I3,3
	HRLM I3,TSUSRF
	.OPEN USRO,TSUSRF
	JRST TSIN22
TSIN3C:	MOVE A,[-3,,RPIMS]
	.USET USRI,A
	SKIPGE W2	;UNLESS HE'S PI IN PROGRESS,
	ANDCM I3,W3	;IGNORE WHAT HE'S ENABLED.
	AND I3,IMSKB	;AND WITH BAD BITS
	MOVEM I3,UPIRQ(U)	;INTS FOR DDT TO NOTICE INTO UPIRQ.
	MOVE A,[-3,,PIPC40]
	.USET USRI,A
	TLZ I3,OIPBIT
	MOVEM I3,IPC
	MOVEM I3,PPC(U)	;USER PC => PPC
	MOVE I3,UPIRQ(U)
	TDNE I3,[-1-BRKBIT-VALBIT-OIPINT]
	JRST TSIN4	;ANYTHING BUT THOSE => MUST STOP HIM.
	TRNN I3,BRKBIT
	JRST TSIN44	;NOT A .BREAK
TSIN3A:	LDB I3,[270400,,I40]
	SETZM NBPTB(U)
	JRST @TSDISP(I3)	;DISPATCH ON AC FIELD OF .BREAK

RPIMS:	.RPIRQC,,I3
	.RMASK,,W3
	.RPICL,,W2

PIPC40:	.SAPIRQC,,I3
	.RUPC,,I3
	.RSV40,,I40

TSIN44:	TRNN I3,VALBIT
	JRST 1PROC
	MOVE I3,I40
	TRNN I3,-1	;IF .VALUE 0, GENERATE "VALU0" INTERRUPT.
	JRST [MOVE I3,[SETZ VALBIT] ? XORM I3,UPIRQ(U) ? JRST PROCX]
	CAMN U,TTYUSR	;ELSE IF NOT FROM CURRENT JOB
	SKIPE DDTTY	;OR DDT HAS TTY,
	JRST PROCX	;VALUE INTERRUPT WILL SOS PC, RETRY .VALUE.
	SKIPL PERMIT(U)
	JRST PROCX	;SIMILAR IF JOB CAN'T DO VALRETS.
	HRRZM I3,VALCOM
	SETOM RSTDEL	;CAN DO .VALUE NOW, DON'T .RESET TYIC,.
PROCX:
TSIN4:	SETOM I3
TSIN5:	MOVEM I3,UINT(U)
TSIN6:	SETOM DDINT
	SKIPN DDTTY
	CAME U,TTYUSR
	PUSHJ P,TSWARN
	JRST TSIN22	;LOOP BACK FOR MORE LOSERS

1PROC:	TRC I3,OIPINT	;STOP JOB UNLESS 1-PROC INT, NO OTHERS.
	JUMPN I3,TSIN4
	SKIPN INCNT(U)
	JRST GO		;IF DIDN'T ^N.
	MOVNI I3,2	;IF WE STOP IT WILL BE WITH CODE "STEPPING-RETRN"
	HRRZ C,PPC(U)
	CAIE C,32	;DON'T STOP BEFORE
	CAIN C,33	;INVISIBLE INSNS.
	JRST 1PROC2
	SKIPN B,OIPCHK(U)
	JRST 1PROC1
	CAIE C,(B)	;$$^N -- CHECK PC.
	CAIN C,1(B)
	CAIA
	JRST 1PROC2
1PROC1:	SOSN INCNT(U)
	JRST TSIN5	;INTERRUPT IF RAN OUT.
1PROC2:	MOVSI D,OIPBIT	;ELSE 1-PROC 1 MORE.
	IORM D,IPC
	JRST GO

;COME HERE WHEN TEMP. BPT. HIT.
TSBT:	MOVEI A,BRKBIT	;CLEAR OUT THE .BREAK BIT SO THAT UBRK3
	ANDCAM A,UPIRQ(U)	;WON'T RE-SOS PPC AFTER UBRKT DOES.
	HLRZ A,BTADR(U)
	CAIGE A,20	;ARE THE TEMP BPTS WATCHING A PDL?
	PUSHJ P,RFETCH	;YES, SEE WHERE POINTS NOW.
	 JRST TSIN5	 ;NO, INT. DDT, PUT 15 OR 17 IN UINT.
	CAMN D,BTPDL(U)
	 JRST TSIN5	;PDL BACK TO SAME DEPTH AS WHEN BPTS SET.
	MOVE W3,BTINS(U)
	CAIN I3,17	;NOT SAME DEPTH, PROCEDE THRU BPT.
	MOVE W3,BTINS+1(U)
	JRST TSBT1

TSDISP:	TSIN4	;RANDOM INST., INTERRUPT DDT
	REPEAT NBP,TSIN9	;REGULAR BPT
	REPEAT 11-NBP,TSIN4	;RANDOM
	TSHACK
	TSIN4
	TSIN4
	TSBT		;TEMP. BPT. IN INSN+1
	TSINXX		;$X RETURN, COND BPT RETURN, USER RQ.
	TSBT		;TEMP. BPT. IN INSN+2

TSIN9:	MOVEM I3,UINT(U)
	IMULI I3,BPL
	ADDI I3,-BPL(U)
	SOSG B1CNT(I3)
	JRST TSIN6	;COUNT RAN OUT,BREAK TO DDT
	SKIPE D,BPCON(I3)
	JRST TSBPC
	MOVE W3,B1INS(I3)
TSBT1:	HRR W3,I40
	TLZ W3,37
	JRST PROC	;PROCEED AND INTERPRET BPT INS

TSBPC:	HRRZ I3,UINT(U)
	MOVEM I3,CBPPS(U)
	MOVE A,I40
	HRLM A,CBPPS(U)
	MOVEM D,26SAV
	.ACCESS USRO,[26]
	MOVE D,[-3,,26SAV]
	.IOT USRO,D
	MOVEI D,CBPB
	MOVEM D,PPC(U)
	EXCH D,IPC
	MOVEM D,BPCPC(U)
	JRST GO

;.BREAK 12, COMES HERE.
TSHACK:	MOVE I3,I40
	HRROM I3,UHACK(U)	;SAVE ITS EFFECTIVE ADDR. FOR HAKKAH.
	SETOM HAKRQ
	JRST TSIN22

;.BREAK 16, COMES HERE.
;2.9=$X RETURN, 2.8=EXTRA CR, 2.7=DON'T .RESET TYIC,
;2.6=:KILL, 2.5=DIE SILENTLY IF NOT CURRENT JOB.
;2.4 => COND. BPT RETURN.
TSINXX:	MOVE I3,I40
	TRNE I3,10000
	 JRST TSBPC2	;IF COND. BPT. RETURN.
	SKIPGE UCHNLO
	CAME U,CU	;IF FROM CURRENT JOB,
	JRST TSINX1
	SKIPE DDTTY	;IF DDT HAS TTY,
	JRST TSINX2	;LEAVE IT TILL $J OR $P.
	TRNE I3,100000	;ELSE CAN HANDLE NOW,
	SETOM RSTDEL	;MAYBE SUPPRESS .RESET OF TYIC,.
	TRZE I3,20000	;IF WANTS TO DIE AT HAKKAH LEVEL,
	TRO I3,40000	;KILL IT IMMEDIATELY INSTEAD.
TSINX2:	HRROM I3,UIACK(U)
	MOVEI I3,16	;INDICATE WAS .BREAK 16,.
	MOVEM I3,UINT(U)
	JRST TSIN6

TSINX1:	MOVE I3,I40	;NOT CURRENT JOB.
	TRNE I3,640000	;CAN NOW HANDLE ONLY RETURNING,
	JRST TSINX2	;ELSE WAIT TILL THIS JOB BECOMES CURRENT.
	TRNE I1,20000	;KILL JOB IMMEDIATELY =>
	 JRST [SETOM HAKRQ	;TELL HAKKAH TO RUN,
		MOVEM I3,UIACK(U)	;SAY JOB WANTS TO DIE,
		JRST TSIN22]	;DON'T SET UINT.
	SETOM UINT(U)	;JUST WANTS TO RETURN,
	PUSHJ P,UBRKR	;REMOVE BPTS, ETC.
	JRST TSIN22	;DON'T REQUEST TO INTERRUPT DDT.

TSBPC1:	MOVE D,BPCPC(U)
	MOVEM D,IPC
	MOVEM D,PPC(U)
	HRRZ D,CBPPS(U)
	IMULI D,BPL
	ADDI D,-BPL(U)
	MOVE W3,B1INS(D)
	HLR W3,CBPPS(U)
	TLZ W3,37
	JRST PROC

TSBPC2:	TRNN I3,200000	;COND BPT RETURN: DID IT SKIP?
	 JRST TSBPC1	;J IF NOT.
	MOVE D,BPCPC(U)
	MOVEM D,IPC
	MOVEM D,PPC(U)
	HRRZ I3,CBPPS(U)
	SETOM NBPTB(U)
	JRST TSIN5
BPBLK=31
CBPB==26

;COME HERE IF HIT BPT BUT SHOULDN'T STOP (COUNT NOT OUT, ETC)
;HAVE INSN TO SIMULATE IN W3, WITH ADDRESS CALC. ALREADY DONE.
PROC:	MOVEI B,100
PROC1:	SOJLE B,PROCX
	LDB W2,[270400,,W3]
	LDB D,[331100,,W3]
	CAIN D,260
	JRST IPUSHJ
	CAIN D,264
	JRST IJSR
	CAIN D,265
	JRST IJSP
	CAIN D,266
	JRST IJSA
	CAIN D,256
	JRST IXCT
	TRNN D,700
	JRST IUUO
PROCR:	MOVEM W3,31SAV	;PUT INS IN 31,JRST INS+1 IN 32,JRST INS+2 IN 33
	MOVE D,IPC
	MOVEI A,BPBLK
	HRRM A,IPC
	HRRM D,31SAV+1
	AOS D
	HRRM D,31SAV+2
	.ACCESS USRO,[31]
	MOVE D,[-3,,31SAV]
	.IOT USRO,D
	MOVSI D,OIPBIT
	SKIPLE INCNT(U)
	IORM D,IPC
GO:	PUSHJ P,INSRTB
	MOVE A,[-2,,PCSTP0]	;START LOSER BACK UP
	.USET USRI,A
	SETZM UINT(U)
	JRST TSIN22	;BACK FOR MORE LOSERS

PCSTP0:	.SUPC,,IPC
	.SUSTP,,[0]

IJSP:	TLCA W3,(MOVE#JSP)
IPUSHJ:	TLC W3,(PUSH#PUSHJ)
	MOVE D,IPC	;?
	HRRM W3,IPC
	HRRI W3,BPBLK-1
	MOVEI A,BPBLK-1
	PUSHJ P,RDEP
	 JRST PROCX
	JRST PROCR
IJSR:	MOVE D,IPC
	HRRZ A,W3
IJSR1:	PUSHJ P,RDEP
	 JRST PROCX
	HRLI W3,(JRST)
	AOJA W3,PROCR

IJSA:	HRRZ A,W2
	PUSHJ P,RFETCH
	JRST PROCX
	HRRZ A,W3
	PUSHJ P,RDEP
	 JRST PROCX
	HRRZ A,W2
	HRR D,IPC
	HRL D,W3
	JRST IJSR1

IXCT:	HRRZ A,W3
IXCT1:	PUSHJ P,RFETCH
	JRST PROCX
	MOVE W3,D
	MOVEI A,100
	MOVEM A,TEM2
IXCT3:	LDB A,[220400,,D]
	JUMPE A,IXCT2
	PUSHJ P,RFETCH
	JRST PROCX
	ADDI W3,(D)
IXCT2:	TLNE W3,20
	JRST IXCTIN
	TLZ W3,37
	JRST PROC1

IXCTIN:	SOSGE TEM2
	JRST PROCX
	HRRZ A,W3
	PUSHJ P,RFETCH
	JRST PROCX
	DPB D,[2700,,W3]
	MOVE D,W3
	JRST IXCT3

IUUO:	CAIN D,45
	JRST IBPT
	CAIGE D,50
	CAIGE D,40
	JRST .+2	;USER UUO
	JRST PROCR
	MOVE D,W3
	MOVEI A,40
	PUSHJ P,RDEP
	 JRST PROCX
	MOVEI A,41
	JRST IXCT1
IBPT:	MOVEM W3,I40
	JRST TSIN3A

;MAIN PROGRAM LEVEL CODE TO HANDLE .BREAK 12, REQUESTS, CLI INTS.
;MAY BE EXECUTED WHENEVER DDT IS READING INPUT, TYPING OR SLEEPING.
;INTERRUPT LEVEL SETOM'S HAKRQ TO SAY HAKKAH SHOULD BE CALLED.
;THE UHACK USER VARIABLE IF NONZERO SAYS THAT JOB WANTS SERVICE,
; RH HAS EFFECTIVE ADDRESS OF THE .BREAK 12, .
;UIACK USER VAR BIT 2.5 SAYS KILL THE JOB.
;HAKCRQ IF -1 SAYS A CLI INT IS TO BE HANDLED.
HAKKAH:	SKIPN HAKING	;DON'T ALLOW RECURSIVE HAKKAH.
	SKIPE INTING	;DON'T DO HAKKAH PI-IN-PROG.
	POPJ P,		;(HAKRQ STILL -1 SO WILL CALL HERE AGAIN.)
	PUSH P,F	;SAVE ALL ACS.
	MOVEI F,1(P)
	HRLI F,1	;NOTE THAT THE SAVED P WILL HAVE
	ADD P,[15.,,15.]
	SKIPL P		;P'S VALUE AFTER THE PUSHING.
	ERLOSS
	BLT F,(P)
	SETZ F,
	PUSH P,SARS
	SETOM SARS
	SETZM HAKRQ
	SETOM HAKING	;NOW WITHIN HAKKAH (IN CASE CALL HAKKAH)
	AOSN HAKCRQ	;PROCESS :SEND RECEIVED IF ANY.
	PUSHJ P,CLIPRT
	SETZ U,		;PROCESS ANY PENDING .BREAK 12,'S.
HAKHA2:	MOVE A,UIACK(U)
	TRNN A,20000	;IF JOB WANTS TO DIE,
	SKIPE UHACK(U)	;OR DID A .BREAK 12,
	PUSHJ P,HAKHAL	;HANDLE THIS JOB.
	ADDI U,USRLNG
	CAIGE U,USREND
	JRST HAKHA2
	SKIPL HAKIOP	;IF PUSHED USR CHNLS, POP THEM.
	JRST HAKHA3
	.IOPOP USRO,
	.IOPOP USRI,
HAKHA3:	SETZM HAKIOP
	SETZM HAKING	;FROM NOW ON TSINT MAY UNSTEAL TTY.
	PUSHJ P,%SAVEX	;UNSTEAL STOLEN TTY.
	POP P,SARS
	HRLZI 17,-15.(P)
	BLT 17,17
	SUB P,[16.,,16.]
	SKIPN SARS	;IF WERE SLEEPING,
	SKIPN UINT(U)	;AND CURRENT JOB INTERRUPTED DURING HAKKAH,
	CAIA
	JRST UBREAK	;LET IT RETURN.
	SKIPL HAKRQ	;ELSE IF MIGHT BE NEW HAKKAH RQ'S,
	POPJ P,
	JRST HAKKAH	;PROCESS THEM.

HAKHAL:	SKIPE UINTWD(U)
	 RET		;DON'T DO .BREAK 12, ON STOPPED JOB.
	SKIPGE HAKIOP	;IF WE'VE PUSHED USR CHNLS, RE-OPEN.
	JRST HAKHA4
	SKIPL UCHNLO	;USR CHNLS NOT OPEN => CAN'T USE THEM.
	 JRST HAKHA7
	CAMN U,CU	;ELSE IF NOT FOR CURRENT USR,
	JRST HAKHA5
HAKHA7:	SETOM HAKIOP	;PUSH AND RE-OPEN.
	.IOPUSH USRI,
	.IOPUSH USRO,
HAKHA4:	MOVEI A,2
	HRLM A,UFUSR(U)
	TSOPEN USRI,UFUSR(U)
	MOVEI A,3
	HRLM A,UFUSR(U)
	TSOPEN USRO,UFUSR(U)
HAKHA5:	MOVE A,UIACK(U)
	TRNN A,20000	;KILL THE JOB IF THAT'S WHAT IT WANTS.
	 JRST HAKHA6
	CAME U,CU	;(BUT DON'T KILL CURRENT JOB HERE)
	PUSHJ P,MRDR1	;THIS ALSO CLEARS USER VARS, SYMS ETC.
	POPJ P,

HAKHA6:	HRRZ A,UHACK(U)
	MOVEI C,0
	PUSHJ P,RFETCH
	JRST HAKERC
	TLNN D,200000
	JRST HAKONE
	TLNN D,400000
	JRST HAKERC
	MOVE C,D
HAKNXT:	HRRZ A,C
	PUSHJ P,RFETCH
	JRST HAKERC
HAKONE:	SAVE C
	HLRZ A,D
	TRZ A,400000
	JUMPE A,HAKERR
	CAILE A,HAKDLG
	JRST HAKERR
	MOVE B,HAKDSP-1(A)
	SKIPGE D
	MOVSS B
	TRNN B,-1
	JRST HAKERR
	MOVEI A,(D)
	JRST (B)

HAKDSP:	WSTRT,,RSTRT
	RLFILE
	RSYML
	WSYMV,,RSYMV
	WSTR,,RSTR
	HAWFIL,,HARFIL
HAKDLG==.-HAKDSP

HALERR:	SUB P,[1,,1]
HAKERR:	REST C
HAKERC:	JUMPGE C,HAKERS
	MOVE D,C
	HRRZ A,UHACK(U)
	PUSHJ P,RDEP
	JFCL
HAKERS:	SETZM UHACK(U)
	SETOM UINT(U)
	SETOM DDINT
	JRST TSWARN

RSTRT:	SKIPA D,STARTA(U)
RSYML:	MOVE D,JOBSYM(U)
	PUSHJ P,RDEP
	JRST HAKERR
HAKWIN:	REST C
	JUMPE C,HAKXIW
	AOBJN C,HAKNXT
	MOVE D,C
	HRRZ A,UHACK(U)
	PUSHJ P,RDEP
	JRST HAKERR
HAKXIW:	PUSHJ P,INSRTB	;PUT BPTS IN UNLESS ALREADY IN.
	SETZM UHACK(U)
	SKIPE INCNT(U)
	SKIPA A,[-3,,HAKBLK]
	MOVE A,[-2,,HAKBLK+1]
	MOVE B,PPC(U)
	.USET USRI,A
	POPJ P,

HAKBLK:	.SIPIR,,[OIPINT]
	.SUPC,,B
	.SUSTP,,[0]

RLFILE:	MOVE D,UFNAMD(U)
	PUSHJ P,DEPNXT
	MOVE D,UFNAMS(U)
	PUSHJ P,DEPNXT
	MOVE D,UFNAM1(U)
	PUSHJ P,DEPNXT
	MOVE D,UFNAM2(U)
	PUSHJ P,DEPNXT
	JRST HAKWIN

DEPNXT:	PUSHJ P,RDEP
	JRST HALERR
	AOJA A,CPOPJ

HARFIL:	HRLZ D,PFILE
	PUSHJ P,DEPNXT
IRPS X,,4 1 2
	MOVE D,PFILE+X
	PUSHJ P,DEPNXT
TERMIN
	JRST HAKWIN

HAWFIL:	SKIPN PERMIT(U)
	 JRST HAKERR
	PUSHJ P,FETDH
	HLRM D,PFILE
IRPS X,,4 1 2
	AOS A
	PUSHJ P,FETDH
	MOVEM D,PFILE+X
TERMIN
	JRST HAKWIN

FETDH:	PUSHJ P,RFETCH
	JRST HALERR
	POPJ P,

WSTRT:	PUSHJ P,FETDH
	MOVEM D,STARTA(U)
	JRST HAKWIN

RSYMV:	JSP I4,%SYM
	PUSH P,A
	PUSHJ P,OPLK2
	JRST SYMLOP
	JFCL
	POP P,A
	PUSHJ P,RDEP
	JRST SYMLOS
	JRST SYMWIN

WSYMV:	SKIPN PERMIT(U)
	JRST HAKERR
	JSP I4,%SYM
	PUSHJ P,RFETCH
	JRST SYMLOS
	PUSHJ P,DEFIN
SYMWIN:	POP P,SYM
	JRST HAKWIN

SYMLOP:	POP P,A
SYMLOS:	SOS A
	POP P,SYM
	MOVEI D,0
	PUSHJ P,RDEP
	JRST HAKERR
	JRST HAKWIN

%SYM:	PUSHJ P,FETDH
	AOS A
	PUSH P,SYM
	MOVEM D,SYM
	JRST (I4)

RSTR:	SKIPL I3,UCHBUF(U)	;GET AOBJN -> CMD BUFFER,
	MOVEI I3,[0]	;OR -> 0 IF NONE.
RSTR2:	MOVE D,(I3)
	PUSHJ P,DEPNXT	;STORE THE NEXT WORD.
	JUMPE D,HAKWIN	;STOP AFTER STORING A 0.
	PUSHJ P,FETDH
	JUMPN D,HAKWIN	;STOP BEFORE CLOBBERING A NON-0.
	AOBJN I3,RSTR2
	JRST HAKWIN

WSTR:	MOVEI W1,UCHBUF(U)
	PUSHJ P,ELEC0	;FLUSH THE CMD BUFFER.
	JRST HAKWIN
CLIPRT:	JSP I4,SHFDRC	;PUSH FDRC AND FDRC BUFFER.
	JSP I4,%SAVE1	;STEAL TTY IF NEC.
	PUSHJ P,FDRCOP
	 [2,,'CLA]		;READ THE :SEND FILE.
	 JRST CLIPRX	;IGNORE IF NONE.
	7TYPE [ASCIZ/
MESSAGE FROM /]
	MOVE D,FDRCTB
	PUSHJ P,SIXTYP	;PRINT SENDER'S UNAME & JNAME.
	PUSHJ P,TSPC
	MOVE D,FDRCTB+1
	PUSHJ P,SIXTYP
	PUSHJ P,CRF
	MOVEI D,2
	ADDM D,FDRCIP	;DON'T TREAT SENDER'S NAMES AS ASCII.
CLIPR1:	PUSHJ P,FDRCI
	CAIN D,^C	;^C => END OF MESSAGE.
	 JRST [PUSHJ P,CRF ? JRST CLIPRX]
	PUSHJ P,TOUT	;PRINT THE MESSAGE ON THE TTY.
	JRST CLIPR1

CLIPRF:	PUSHJ P,FDRCI	;READ AND IGNORE THE MESSAGE.
	CAIE D,^C
	JRST CLIPRF
CLIPRX:	JSP I4,OPFDRC	;POP FDRC & BUFFER.
	POPJ P,

;SNARF A VALRET STRING FROM JOB THAT'S INTERRUPTING.
UBRKV:	PUSHJ P,INPUSH	; PUSH INPUT SOURCE
	.ACCESS USRI,VALCOM
	SETZM VALCOM
	HRRZ W1,SYMTOP	;READ VALRET STRING ABOVE SYM TABS.
UBRK2C:	HRRZI D,(W1)
	ADDI D,1777
	ANDI D,-2000
	CAIE D,(W1)	;IF NO SPACE THERE,
	JRST UBRK2
	ADDI D,2000
	PUSHJ P,RELC	;GET ANOTHER K.
	SKIPA D,[-2000]	;SAY HAVE 1 K SPACE.
UBRK2:	SUBM W1,D	;D HAS SPACE FOR READING IN.
	HRLI D,(W1)
	MOVS D,D	;D HAS AOBJN -> SPACE.
	SETOM XRWI
	PUSH P,D
	.IOT USRI,D
	JRST UBRK2A	;NO MPV DURING .IOT.
	SETZM (D)	;WAS MPV, PRETEND STRING ENDED NORMALLY WITH 0.
UBRK2A:	POP P,D		;GET BACK PTR -> ENTIRE SPACE.
UBRK2B:	MOVE A,(D)	;LOOK FOR A WORD ENDING WITH A ^@.
	TRNE A,376
	AOBJN D,UBRK2B	;ALSO STOP AFTER WHAT WAS READ IN.
	JUMPGE D,[MOVEI W1,(D) ? JRST UBRK2C]
	SETZM XRWI	;STRING WAS TERMINATED.
	ADDI D,1
	ANDI D,-1
	SUB D,SYMTOP	;GET # WDS READ IN.
	PUSHJ P,ALLOC	;OFFICIALLY ALLOCATE THOSE WDS,
	MOVEM A,INVAOB	;SAVE PTR SO CAN FREE THEM LATER.
	HRLI A,010700
	SOS A
	MOVEM A,INPTR	;SAVE B.P. (MUST BE POSITIVE)
	JRST DD1B
UBREAK:	PUSHJ P,TTYRET	;CURRENT JOB INTERRUPTED WHEN IT HAD TTY.
	SKIPN VALCOM
UBRK0:	PUSHJ P,CRF
UBRK1:	SETOM SARS	;DDT NOW ACTIVE.
	MOVE P,[-LPDL,,PS]
	PUSHJ P,UBRKR	;REMOVE BREAKPOINTS, OTHER ESSENTIALS.
	SKIPE VALCOM	;IF JOB DID A HANDLEABLE .VALUE,
	JRST UBRKV	;GO SNARF THE STRING.
	MOVE D,UINTWD(U)
	AOJE D,UBRK3	;RANDOM INT LOSSAGE (MPV ETC)
	JUMPL D,UBRKS	;RETURN FROM 1-PROC.
	CAIE D,16	;.BREAK 15, AND 17,  TEMP BPTS.
	CAIN D,20
	 JRST UBRKT
	SETZM USCNT(U)	;STOP MULTI-STEPPING ON NON-STEPPING RETURN.
	CAIG D,16	
	JRST UBRK4	;JOB HIT BPT, GO PRINT STUFF.
	MOVE D,UIACK(U)	;HERE IF JOB DID .BREAK 16,.
	TRNN D,400000
	JRST UBRK1A
	MOVE A,XECPC(U)
	MOVEM A,PPC(U)
	MOVE A,XINTWD(U)
	MOVEM A,UINTWD(U)
UBRK1A:	TRNE D,200000
	PUSHJ P,CRF
	SKIPGE PERMIT(U)
	TRNN D,60000
	JRST DD1A
	7TYPE [ASCIZ /:KILL /]
	JRST KILL

UBRKR:	SKIPN OIPCHK(U)	;DO THE ESSENTIAL THINGS TO RETURN CURRENT JOB TO DDT.
	SETZM INCNT(U)
	SETZB F,F
	MOVEI D,0
	EXCH D,UINT(U)
	MOVEM D,UINTWD(U)
	JRST REMOVB

;VARIOUS MASKS FOR INTERUPT

IMSKB:	341,,267666	;CLASS 1,2 OR PDL OVFLOW
IMSKS1:	300,,23644	;THESE WANT TO BACK UP THE PC.

UBRK3:	SETZM USCNT(U)	;STOP STEPPING ON RANDOM ERROR.
	PUSHJ P,PCPNT
	HRRZ A,TEM3
	PUSHJ P,RFETCH
	JRST ERR
	PUSHJ P,PIN	;PRINT NEXT INSTRUCTION (MAYBE PREV.)
	MOVE D,UPIRQ(U)
	TRNE D,40000
	.USET USRI,[.SMARA,,MARCON]
	JRST DD2A

;COME HERE IF JOB WAS STOPPED BY A BREAKPOINT.
UBRK4:	.RDTIME C,
	SAVE C		;(FOR DOZING DOZTIM SECONDS)
	IMULI D,BPL	;BREAK POINT (D IS UINT+1)
	ADDI D,B1ADR-2*BPL(U)
	HRLI D,400000	;INDICATE ADDR. IS FUNNY (A DDT-REF)
	PUSH P,D
	PUSHJ P,PAD	;PRINT $<N>B WHERE <N> IS BPT. NUM.
	PUSHJ P,PCPNT3
	SOS D,PPC(U)	;MAKE RESTART PC -> BPT'ED LOCATION.
	ANDI D,-1
	PUSHJ P,PAD	;AND PRINT ADDRESS OF THAT INSN.
	POP P,A
	HLRZ D,(A)
	JUMPE D,UBRK5
	PUSHJ P,LCT	;IF THIS BPT IS SET TO OPEN SOME LOC.,
	HLRZ D,(A)
	PUSHJ P,UBRKNL	;TYPE THE ADDRESS AND OPEN IT.
UBRK5:	REST C		;GET TIME STARTED TYPING.
	MOVE A,UINTWD(U)
	MOVEI B,1
	LSH B,-1(A)
	TDNN B,BPINFL(U)	;AUTO-PROC BPT? ($$P)
	JRST DD2A
	PUSHJ P,UBRK6	;SLEEP A WHILE, SEE IF USER TYPED ANYTHING.
	JRST PROCD1
	ANDCAM B,BPINFL(U)	;TURN OFF AUTO-PROC AND STOP.
	JRST DD2A

UBRK6:	MOVE D,DOZTIM	;# SECS TO SLEEP.
	MOVNS C		;GET -<TIME STARTED PRINTING>
UBRK7:	CALL LISTN	;TYPED ANYTHING YET?
	 CAIA
	JRST POPJ1	;YES, STOP SLEEPING.
	SOJL D,CPOPJ	;WAITED LONG ENOUGH => GO ON.
	MOVNI A,30.
	ADDB A,C
	.SLEEP A,	;WAIT 1 MORE SEC.
	JRST UBRK7

PCPNT:	MOVE D,UPIRQ(U)
	TLNE D,400000
	7TYPE [ASCIZ /.VALUE 0./]
	TLNE D,200
	STRT [SIXBIT /PURPG./]
	TLNE D,100
	STRT [SIXBIT /PURINS./]	;INS FETCH FROM IMPURE CORE W/PURE BIT ON
	TLNE D,40
	STRT [SIXBIT /SYSUUO./]	;SYS UUO IN TRAP MODE
	TLNE D,1
	STRT [SIXBIT /RESTR./]	;RESTRICTION VIOLATION
	TRNE D,200000
	STRT [SIXBIT /PDLOV./]
	TRNE D,40000
	STRT [SIXBIT /MAR./]
	TRNE D,20000
	STRT [SIXBIT /MPV./]
	TRNE D,1000
	STRT [SIXBIT /ILUAD./]
	TRNE D,400
	STRT [SIXBIT /IOC./]
	TRNE D,40
	STRT [SIXBIT /ILOPR./]
	TRNE D,20
	STRT [SIXBIT /DPY./]
	TRNE D,4
	STRT [SIXBIT /BADPI./]
	TDNE D,[400341,,261464]
	CTYPE 40	;FOLLOW MESSAGE WITH SPACE.
	MOVE A,PPC(U)
	TRNE D,40000	;FOR MAR, PRINT PREVIOUS INSN.
	.USET USRI,[.ROPC,,A]	;BUT DON'T BACK PC.
PCPNT9:	TDNE D,IMSKS1	;ANY RANDOM ERROR => BACK UP THE PC.
	SOS A,PPC(U)
	MOVEI D,(A)
	PUSHJ P,PCPNT5
PCPNT1:	MOVEM D,TEM3
	PUSHJ P,PADR
PCPNT3:	MOVEI D,2
	TDNE D,UPIRQ(U)
	JRST PCPNT2
	MOVEI D,">
	SKIPL NBPTB(U)
	PUSHJ P,TOUT
	JRST TOUT

PCPNT2:	MOVEI D,")
	PUSHJ P,TOUT
	JRST LCT

PCPNT5:	CAIE D,31
	POPJ P,
	MOVEI A,32
	PUSHJ P,RFETCH
	POPJ P,
	MOVEI D,-1(D)
	POPJ P,

;COME HERE ON RETURNING JOB THAT HIT TEMP. BPT.
UBRKT:	SETZM BTADR(U)	;GET RID OF TEMP BPTS WHEN HIT.
	SOS PPC(U)	;POINT PC TO THE BPT'D INSN, NOT AFTER IT.

;COME HERE ON RETURN FROM 1-PROCEDE.
UBRKS:	MOVE I1,USTYPE(U)
UBRKS9:	SETZM UPIRQ(U)	;DON'T SOS THE PC FOR 0^^.
	SKIPN USCNT(U)
	 JRST UBRK3	;NO MORE STEPPING TO DO, JUST RETURN.
	SKIPLE USCNT(U)
	 SOS USCNT(U)	;DECREMENT THE STEP COUNT UNLESS INDEFINITE.
	HRRZ D,PPC(U)
	PUSHJ P,PCPNT5	;GET ADDR OF NEXT INSN TO DO.
	MOVEI A,(D)
	PUSHJ P,NACN2	;GET IT, HANDLE XCT'S, PUT LH IN C, INSN IN B.
	 JRST UBRK3	;CAN'T FETCH THE INSN.
	TRZ C,37
	CAIN C,(.VALUE)
	 TLO I1,USTYP0	;SHOULD ALWAYS USE TEMP BPTS OVER .VALUE.
	CAIE B,(PUSHJ)
	CAIN B,(JSR)
	 JRST UBRKSC	;CHECK FOR SUBROUTINE CALLS.
	CAIE B,(JSP)
	CAIN B,(JSA)
	 JRST UBRKSC
	CAIL B,4^4	;CHECK FOR MONITOR CALLS.
	CAIL B,5^4
	CAIA
	 JRST [TLNN I1,USTYP1	;UNLESS JUST STARTING TO STEP,
		TRNN I1,USTYPM	;STOP ON MONITOR CALLS IF M FLAG.
		 JRST UBRKS1
		JRST UBRK3]
	CAIE B,(POPJ)
	CAIN B,(JRA)
	 JRST [TLNN I1,USTYP1	;UNLESS JUST STARTING TO STEP,
		TRNN I1,USTYPR	;R FLAG => STOP BEFORE RETURNS.
		 JRST UBRKS1
		JRST UBRK3]
	TLNN I1,USTYP1
	TRNN I1,USTYPJ	;IF SHOULD STOP BEFORE JUMPS,
	 JRST UBRKS0
	CAIN B,(JFFO)	;CHECK FOR JUMPS.
	 JRST UBRK3
	CAIG B,(SOJG)	;ELIMINATE MOST OF THE NON-JUMPS.
	CAIGE B,(AOBJP)
	 JRST UBRKS0
	CAIN C,(JFCL)	;NO-OP ISN'T A JUMP.
	 JRST UBRKS1
	CAILE B,(JFCL)
	CAIL B,(JUMPL)
	CAILE B,(JUMPG)
	CAIL B,(AOJL)
	CAILE B,(AOJG)
	CAIL B,(SOJL)
	 JRST UBRK3	;A JUMP.
	JRST UBRKS1	;NOT A JUMP.

UBRKSC:	TRNE I1,USTYPB	;MAYBE BPT SUBR CALLS.
	 TLO I1,USTYP0
	TLNN I1,USTYP1	;UNLESS THIS WILL BE 1ST STEP,
	TRNN I1,USTYPC	;MAYBE STOP BEFORE THEM.
	 JRST UBRKS1
	JRST UBRK3

UBRKS0:	CAIL B,1^5	;CHECK FOR UUOS.
	 JRST UBRKS1
	TRNE I1,USTYPV	;MAYBE SHOULD BPT THEM,
	 TLO I1,USTYP0
	TRNE I1,USTYPU	;MAYBE SHOULD TREAT THEM AS SUBR CALLS.
	 JRST UBRKSC
	TLNE I1,USTYP1	;UNLESS ABOUT TO DO 1ST STEP,
	 JRST UBRKS2
	TRNE I1,USTYPW	;MAYBE SHOULD STOP ON THEM.
	 JRST UBRK3
UBRKS1:	TRNE I1,USTYPP	;IF NOT PRINTING
	TLNE I1,USTYP1	;OR JUST STARTING TO STEP,
	 JRST UBRKS2	;JUST GO PROCEDE.
	SKIPE DOZTIM	;IF SHOULD DOZE, GET TIME STARTED TO PRINT.
	 .RDTIME C,
	PUSH P,I1
	PUSH P,C
	PUSH P,D	;SAVE NEXT INSN.
	MOVE D,A
	PUSHJ P,PCPNT1	;PRINT ADDR AND >>
	POP P,D
	PUSHJ P,PIN	;PRINT NEXT INSN.
	POP P,C
	POP P,I1
	CALL UBRK6	;WAIT A WHILE, SKIP IF CHAR TYPED IN.
	 JRST UBRKS2
	SETZM USCNT(U)
	JRST DD2A	;STOP STEPPING.

UBRKS2:	SETZB A,ARG1+1	;MAKE SURE GO ONLY 1 STEP.
	JUMPL I1,NACN	;UBRKS SET 4^5 TO SAY USE BPTS.
	JRST NCTLN	;ELSE USE 1-PROC.

;<LETTERS>$^^ OR <ARG> <LETTERS>$^^
;SET STEPPING-TYPE FROM LETTERS AND START STEPPING.
NACUPA:	MOVE I1,USTYPE(U)
	PUSHJ P,NACUP0	;HANDLE THE LETTERS, CHANGING I1.
	HRRZM I1,USTYPE(U)

;^^ - BEGIN MULTI-STEPPING.
NCUPA:	SKIPN UINTWD(U)
	 JRST NRERR	;CAN'T START STEPPING RUNNING PROGRAM.
	MOVE I1,USTYPE(U)
	TLO I1,USTYP1	;DON'T PRINT 1ST INSN TO BE DONE.
	SETOM USCNT(U)	;ASSUME NO ARG,INDEFINITE STEPPING.
	MOVE A,ARG1
	SKIPE ARG1+1	;IF ARG, IT IS # TIMES TO STEP.
NCUPA1:	MOVEM A,USCNT(U)
	SKIPE USCNT(U)	;IF WILL PRINT AN INSN BEFORE ANY STEPPING,
	TLNN I1,USTYP1
	PUSHJ P,CRF	;PRINT IT ON NEXT LINE.
	JRST UBRKS9	;PRETEND JUST DID A STEP, GO DO ANOTHER.

;<LETTERS>$$^^ - CHANGE NEW-JOB-DEFAULT STEPPING TYPE.
;<LETTERS>$$0^^  - SET THIS JOB'S DEFAULT TO CHANGED NEW-JOB-DEFAULT.
N2ACUP:	TLNE B,IFXF
	PUSHJ P,QIJERR	;$$0^^ NEEDS JOB.
	MOVE I1,MSTYPE	;GET THE NEW-JOB-DEFAULT.
	PUSHJ P,NACUP0	;CHANGE ACC. TO LETTERS.
	MOVE D,(W4)	;GET THE $$^^ OPERATOR'S BITS BACK.
	TLNE D,IFXF	;$$0^^ - SET THIS JOB'S DEFAULT.
	HRRZM I1,USTYPE(U)
	TLNN D,IFXF	;$$^^ - SET THE NEW-JOB-DEFAULT.
	HRRZM I1,MSTYPE
	JRST LCTGNR

;ROUTINE TO HANDLE LETTERS (AS SIXBIT IN C)
;AND UPDATE THE STEPPING-TYPE BITS IN RH OF I1.
NACUP0:	MOVE B,[440600,,C]
NACUP1:	SETZ D,		;IF BP INCR'S INTO D, ILDB WILL FETCH 0.
	ILDB D,B	;GET NEXT LETTER.
	JUMPE D,CPOPJ	;DONE WHEN FINISH ALL LETTERS.
	MOVSI A,1-NACUPL	;AOBJN -> TABLE
NACUP2:	CAME D,NACUPT(A)	;SEARCH FOR THIS LETTER.
	AOBJN A,[AOBJN A,NACUP2]
	JUMPGE A,NACUP1	;LETTER NOT FOUND, IGNORE IT.
	TDZ I1,NACUPT+1(A)
	TSO I1,NACUPT+1(A)
	JRST NACUP1	;GET NEXT LETTER.


IRPC X,,BCJMPRUVW
USTYP!X==1_.IRPCN
TERMIN		;DEFINE RH. FLAGS.

USTYP0==4^5	;TELLS UBRKS2 TO USE TEMP BPTS RATHER THAN 1-PROC.
USTYP1==2^5	;SET AT UBRKS9 SAYS THIS IS 1ST STEP, DON'T STOP BEFORE INSN.


NACUPT:	;LETTER ? BITS TO SET,,BITS TO CLEAR
	'B ? USTYPB,,USTYPC		;USE BPTS OVER SUBR CALLS.
	'C ? USTYPC,,USTYPB		;STOP BEFORE SUBR CALLS.
	'D ? USTYPB+USTYPC		;STEP THRU SUBR CALLS.
	'J ? USTYPJ,,			;STOP BEFORE ALL JUMPS.
	'K ? USTYPJ			;DON'T.
	'M ? USTYPM,,			;STOP BEFORE SYSTEM CALLS.
	'N ? USTYPM			;STEP THRU SYSTEM CALLS.
	'P ? USTYPP,,			;PRINT EACH INSN.
	'Q ? USTYPP			;PRINT ONLY INSN STOP BEFORE.
	'R ? USTYPR,,			;STOP BEFORE SUBROUTINE RETURNS.
	'S ? USTYPR			;STEP SUBR RETURNS.
	'U ? USTYPU,,USTYPV+USTYPW	;TREAT UUOS AS SUBR CALLS.
	'V ? USTYPV,,USTYPU+USTYPW	;USE BPTS OVER UUOS.
	'W ? USTYPW,,USTYPU+USTYPV	;STOP BEFORE UUOS.
	'X ? USTYPU+USTYPV+USTYPW	;STEP THRU UUOS (INTO UUOH)
NACUPL==.-NACUPT

;$^N - PROCEDE WITH TEMP. BPTS AFTER NEXT INSN.
NACN:	HRRZ D,PPC(U)	;DEFAULT IS TEMP BPTS START AT $.+1
	AOS D
	SKIPE ARG1+1
	MOVE D,ARG1	;IF HAVE ARG, START THEM THERE INSTEAD.
	ADD A,D	;INFIX ARG SAYS PUT BPTS THAT MANY WDS LATER.
	HRROM A,BTADR(U)
	HRRZ A,PPC(U)	;PUT -1 IN LH TO ASSUME NO PDL TO CHECK.
	PUSHJ P,NACN2	;GET WHAT WILL BE NEXT INSN.
	 JRST PROCDT	;CAN'T GET IT, DON'T BOTHER WITH PDL STUFF.
	LDB A,[270400,,D]
	CAIE B,(PUSHJ)
	 JRST PROCDT	;NOT PUSHJ, ORDINARY.
	HRLM A,BTADR(U)	;REMEMBER ADDR OF PDL PTR,
	PUSHJ P,RFETCH
	 ERLOSS
	MOVEM D,BTPDL(U)	;REMEMBER WHAT IT NOW PTS TO.
	JRST PROCDT

NACN2:	PUSHJ P,RFETCH	;ASSUME A HAS ADDR OF INSN, FETCH IT.
	 POPJ P,		;FAIL IF CAN'T FETCH.
	HLRZ C,D	;PUT LH OF INSN IN C.
	MOVEI B,(C)
	ANDI B,777000	;IN B'S RH, PUT JUST THE OP-CODE.
	CAIE B,(XCT)	;REPLACE XCT'S BY XCT'D INSNS.
	 JRST POPJ1
	PUSHJ P,EASETU	;GET ACS FOR EFFECTIVE ADDR CALC.
	PUSH P,I1
	MOVE A,D	;GIVE INSN AS ARG,
	PUSHJ P,NEFECC	;GET ADDR OF XCT'D INSN,
	MOVEI A,(I1)	;USE IT AS ADDR OF INSN,
	POP P,I1
	JRST NACN2	;TRY AGAIN.

;$$^N.
N2ACN:	SETZM INCNT(U)
	AOS INCNT(U)	;MAKE SURE >0 SO WILL 1-PROC.
	MOVE D,PPC(U)
	AOJ D,		;USE PC+1, OR ARG.
	SKIPE ARG1+1
	MOVE D,ARG1
	MOVEM D,OIPCHK(U)	;GO TILL GET THERE OR 1 AFTER.
	JRST PROCDT

;^N
NCTLN:	SETZM OIPCHK(U)	;^N, $^N - LEAVE $$^N MODE.
	PUSHJ P,GARGD1	;GET ARG OR 1.
	MOVEM D,INCNT(U)	;NUM. INSNS TO DO.
	JRST PROCDT

NCTLP:	TLOA F,LTF	;^P
NALTP:	TLZ F,LTF	;$P, $$P
	SKIPE UINT(U)
	JRST ALTJ9	;PENDING VALRET?
	MOVE A,UINTWD(U)
	SOS A
	PUSHJ P,BUTOP1
	PUSHJ P,GARGD1
	JRST PROCDN

GARGD1:	SKIPLE D,ARG1
	SKIPN ARG1+1
	MOVEI D,1
	POPJ P,

BUTOP1:	MOVEI W2,1	;SET OR CLR AUTO-PROC, BPT NUM IN A .
	LSH W2,(A)
	ANDCAM W2,BPINFL(U)
	TLNE B,20000
	IORM W2,BPINFL(U)	;$$
	POPJ P,

NALTG:	MOVE D,ARG1	;$G, $$G
	HRLI D,(JRST)
	SKIPN ARG1+1
	MOVE D,STARTA(U)
	TLNE B,2ALTF
	MOVEM D,STARTA(U)	;$$
	SKIPN UINTWD(U)
	 JRST NRERR	;CAN'T START RUNNING PROGRAM.
	HRRM D,PPC(U)	;SET PROCEDE-PC TO START ADDR,
	SETOM UINTWD(U)	;MAKE SURE IT'S OK TO PROCEDE THE JOB,
	MOVE I1,USTYPE(U)
	TLNE B,IFXF
	 JRST NCUPA1	;$<N>G, GO MULTI-STEP.
	JRST PROCDT	;ELSE JUST PROCEDE.

AAGO:	TLZA F,LTF	;:GO, :START.
GZP:	TLO F,LTF	;:GZP.	IDENTICAL BUT DOESN'T GIVE TTY.
	PUSHJ P,QIJERR
	PUSHJ P,QRERR
	PUSHJ P,RONUM
	 JRST ALTDQX	;(IF RUB PAST START OF RONUM)
	SKIPN B
	HRR A,STARTA(U)
	HRRM A,PPC(U)
	SETOM UINTWD(U)
	JRST PROCD1

NALTX:	SKIPN ARG1+1	;$X
NAERR:	7NRTYP [ASCII / ARG/]	;ARG ERROR
	SKIPL FNYLOC	;ARG FUNNY => XCT IN DDT.
	SKIPE DDTSW
	JRST NALTX1	;CURRENT JOB SELF, JUST XCT.
	MOVE D,ARG1
	JRST HGO

NALTX1:	PUSHJ P,CRF
	XCT ARG1
	CAIA
	PUSHJ P,CRF	;IF SKIPS, SHOW IT.
	JRST NLTL2

HGO:	MOVEM D,34SAV
	MOVEI A,0
	EXCH A,UINTWD(U)
	JUMPE A,NRERR	;PROG RUNNING
	MOVEM A,XINTWD(U)
	TLZ F,LTF
	MOVE D,PPC(U)
	MOVEM D,XECPC(U)
	AOS XCRFSW
	MOVEI D,34
	HRRM D,PPC(U)
	.ACCES USRO,[34]	;MOVE 34SAV ETC. INTO INFERIOR.
	MOVE D,[-3,,34SAV]
	.IOT USRO,D
XEC1A:	PUSH P,UINTWD(U)	;IN CASE OF PUR?
	MOVEM A,UINTWD(U)
	PUSHJ P,INSRTB
	POP P,UINTWD(U)
XEC1B:	AOS D,XCRFSW
	CAIE D,1	;IF SWITCH WASN'T SET,
	PUSHJ P,CRF	;THEN TYPE CRLF
	MOVE D,PPC(U)
	.USET USRI,[.SUPC,,D]
	TLNE F,LTF
	JRST PROCE2	;^P
PRUN1:	PUSHJ P,TTYLEV
SLP:	PUSHJ P,RTYIC	;GET CHAR FROM VALRET OR FILE
	JRST SLP2	;NONE AVAILABLE
	CAIE D,^V	;IF NEXT CHARACTER CONTROL V,
	JRST SLP2	;...
	SETZM UNRCHF	;FLUSH THE ^V,
	SETZM UNECHF
	SOSGE TTYFLG	;PERFORM ACTION OF ^V.
	SETZM TTYFLG
SLP2:	SETZM SARS
	.USET USRI,[.SUSTP,,[0]]
	SKIPGE HAKRQ
	PUSHJ P,HAKKAH	;HANDLE PENDING .BREAK 12,'S.
	SKIP
	.HANG

PROCE2:	.USET USRI,[.SUSTP,,[0]]
	JRST NLTL2

PROCDT:	TLZ F,LTF
PROCD1:	MOVEI D,1
PROCDN:	AOS XCRFSW	;INCREMENT CRF SWITCH IN CASE OF ERROR
	PUSHJ P,QIJERR
	MOVE A,UINTWD(U)
	TLNE F,LTF
	JUMPE A,NRERR	;^P ON RUNNING PROGRAM
	JUMPE A,PRUN	;RUNNING, GIVE IT TTY
	CAIN A,21
	JRST NXERR	;CAN'T $P IF NEVER STARTED.
	SETZM UINTWD(U)	;NOW RUNNING.
	MOVSI B,OIPBIT
	SKIPLE INCNT(U)
	IORM B,PPC(U)
	JUMPL A,XEC1A	;STOPPED BY RANDOM INT, START IT BACK UP
	CAIL A,15		;SIMILAR AFTER .BREAK 16,
	JRST XEC1A
	IORM B,PPC(U)	;BPT - GO 1 INSN W/O BPTS, THEN INSERT.
	IMULI A,BPL
	ADDI A,-BPL(U)
	MOVEM D,B1CNT(A)
	JRST XEC1B

PRUN:	PUSHJ P,CRF
	JRST PRUN1

NCTLX:	SKIPE UINT(U)	; ^X -- JOB WAITING => LET IT RETURN.
	 JRST UBRK0
	SKIPE UINTWD(U)
	JRST NXERR
	MOVE A,[-2,,[ .SUSTP,,[-1] ? .SIPIRQ,,[2] ]]
	.USET USRI,A
	PUSHJ P,TTYLEV
	JRST SLP2

TTYRET:	SETZM TTYSTL	;TTY ISN'T STOLEN, SHOULDN'T RETURN IT.
	SKIPN DDTTY	;RETURN TTY TO DDT
	.DTTY USRI,
	POPJ P,
	SETOM DDTTY
	AOSN RSTDEL	;UNLESS .BREAK 16, SAID NO, FLUSH INPUT.
	POPJ P,
	JRST INRST

TTYLEV:	MOVEM U,TTYUSR	;TTY LEAVES DDT
	.ATTY USRI,
	TERR (SIXBIT /CFT/)
	SETZM DDTTY
	POPJ P,
;INSERT BREAKPOINTS

INSRTB:	SKIPGE BPINFL(U)
	POPJ P,		;DON'T INSERT IF ALREADY IN.
	HRROS BPINFL(U)
	MOVEI B,B1ADR(U)
	MOVEI W1,(.BREAK 1,)
INSRT1:	PUSHJ P,INSRT0	;INSERT 1 ORDINARY BPT.
	MOVEM C,B1INS-B1ADR(B)
	ADDI W1,(0 1,)
	ADDI B,BPL
	CAIE B,BPEND(U)
	JRST INSRT1
	MOVEI B,BTADR(U)
	MOVEI W1,(.BREAK 15,)
	PUSHJ P,INSRT0	;INSERT 1ST TEMP BPT
	MOVEM C,BTINS(U)
	MOVEI W1,(.BREAK 17,)
	PUSHJ P,INSRT2	;INSERT THE SECOND.
	MOVEM C,BTINS+1(U)
	POPJ P,

;REMOVE BREAKPOINTS

REMOVB:	SKIPL BPINFL(U)
	POPJ P,		;DON'T REMOVE UNLESS IN.
	HRRZS BPINFL(U)
	MOVEI B,BTADR(U)
	HLRZ W1,BTINS(U)
	PUSHJ P,INSRT0	;REMOVE 1ST TEMP BPT.
	HLRZ W1,BTINS+1(U)
	PUSHJ P,INSRT2	;REMOVE THE SECOND.
	MOVEI B,B1ADR(U)
REMOV1:	MOVS W1,B1INS-B1ADR(B)
	PUSHJ P,INSRT0
	ADDI B,BPL
	CAIE B,BPEND(U)
	JRST REMOV1
	POPJ P,

INSRT2:	AOSA A		;INSERT OR REMOVE AT WD AFTER PREV. BPT.
INSRT0:	MOVE A,(B)	;DO IT AT ADDR IN WD <- B.
	SKIPE (B)
	PUSHJ P,RFETCH	;GET WHAT'S THERE NOW.
	 POPJ P,	;CAN'T FETCH OR BPT NOT SET.
	MOVE C,D	;REMEMBER WHAT WAS THERE IN CASE INSERTING.
	TLZ D,777740	;CLEAR OUT OP CODE, AC FIELD,
	TLO D,(W1)	;REPLACE WITH SAME FIELDS OF ARG.
	PUSHJ P,RDEPCA
	 JFCL
	POPJ P,
DEPF:	TLNE A,200000	;A HAS ADDR, LH HAS FUNNYNESS.
	JRST DEP2	;DEP. INTO USET VARIABLE.
	TLNE A,400000
	JRST DEP4	;DEP INTO DDT LOCATION.
DEPCLA:	TLZ A,-1	;DEP REQUIRES 0 IN LH OF A.
DEP:	SKIPE SYSSW
	JRST DEP0	;IF JOB IS SYS.
	SKIPE DDTSW
	JRST DEP4	;IF JOB IS SELF.
DEP9:	PUSHJ P,QIJERR	;ELSE IF ISN'T INFERIOR, CAN'T DEPOSIT.
	PUSHJ P,RDEP
	JRST NXERR
	POPJ P,

DEP0:	SKIPL SYSDPS
	JRST ERR
	PUSH P,C
	MOVSI C,D
	HRR C,A
	.SETLOC C,
	JRST POPCJ

DEP4:	SETOM XRWI	;TELL PURBR1 TO UNPURIFY.
	MOVEM D,(A)
	CAIA		;SUCCESS.
	 JRST NXERR	;WAS MPV.
	SETZM XRWI
	POPJ P,

DEP2:	SKIPE DDTSW	;IF DEPOSITING IN OWN .USET VAR,
	TLOA A,400000	;MUST DO .SUSET, NOT .USET.
	PUSHJ P,QIJERR
	PUSH P,C
	MOVEI C,(A)
	CAMLE C,MAXUSET
	JRST ERR
	MOVE C,[SETZ D]	;SET VAR FROM D.
	JRST FETCH7

RDEPCA:	TLZ A,-1
RDEP:	PUSH P,C
	PUSH P,XRWI
	SETOM XRWI
	.ACCESS USRO,A
	HRROI C,D
	.IOT USRO,C
RDEP2:	AOS -2(P)
RDEP4:	POP P,XRWI
	JRST POPCJ

;FETCH FROM A POSSIBLY FUNNY LOCATION, FUNNYNESS IN LH OF A.
FETCHF:	TLNE A,200000
	JRST FETCH3	;FETCH FROM USET VAR.
	TLNE A,400000
	JRST FETCHB	;FETCH FROM LOC. IN DDT.

;FETCH FROM ORDINARY (NON-FUNNY) LOCATION.
FETCH:	SKIPE SYSSW
	JRST FETCHA	;FETCH FROM SYS JOB.
	SKIPE DDTSW
	JRST FETCHB	;FETCH FROM SELF
	PUSHJ P,QJERR

;FETCH FROM CURRENT JOB'S CORE.
RFETCH:	PUSH P,C
	PUSH P,XRWI
	HRRZ C,A
	.ACCESS USRI,C
	HRROI C,D
	SETOM XRWI	;SKIP ON MPV
	.IOT USRI,C
	JRST RDEP2	;POP XRWI, C, SKIP.
	JRST RDEP4	;WAS NXM, DON'T SKIP.

FETCH3:	PUSH P,C
	MOVEI C,(A)
	CAIL C,100
	CAILE C,157
	CAMG C,MAXUSET
	JRST FETCH6
	CAIL C,200	;PAGE MAP VARS OK TO READ.
	CAILE C,577
	JRST POPCJ
FETCH6:	SKIPN UCHNLO
	JUMPGE A,POPCJ	;CAN'T DO USET REFS ON SYS.
	AOS -1(P)
	MOVEI C,D	;READ INTO D.
FETCH7:	TLO C,(A)	;SAY WHICH VAR TO READ OR SET.
	SKIPGE A
	.SUSET C
	SKIPL A
	.USET USRI,C
	JRST POPCJ

FETCHA:	HRLZI D,(A)
	HRRI D,D
	.GETLOC D,
	JRST CPOPJ1

FETCHB:	SETOM XRWI
	MOVE D,(A)
	AOS (P)
	SETZM XRWI	;DON'T SKIP-RETURN IF MPV.
	POPJ P,
PDUMP:	PUSHJ P,QIJERR	;SYSTEM WON'T DUMP FOREIGN JOBS!
	SETOM GSDNUM	;TELL RRFLB TO CLOBBER SYS: TO DSK:
	PUSHJ P,RRFLB
	MOVEI A,3
	HRLM A,UFILE(U)
	TSOPEN UTOC,UFILE(U)
	SETZM NCVARB'
	TSCALL PDUMPB
	PUSHJ P,NDMPS
	.CLOSE UTOC,
	JRST NLTL6

PDUMPB:	SETZ		;USED FOR PURE DUMP
	SIXBIT /PDUMP/
	[USRI]
	[UTOC]
	400000,,NCVARB

NDMPS:	TLZE F,CF	;DUMPINGAS IMAGE => NO SYMS.
	 RET
	PUSHJ P,DJBLK
	MOVE A,SYSAOB	;IF SYS JOB, GET SYS SYMTAB PTR,
	SUBI A,772000-SYSSYM
	SKIPN SYSSW
	 MOVE A,JOBSYM(U) ;ELSE GET JOB'S SYMTAB PTR.
	JUMPGE A,DJBLK	;MAYBE HAVE NO SYMS.
	HLLZS A
	PUSHJ P,NDMPA	;OUTPUT -<BLOCK SIZE>,,
	MOVE C,A	;START OFF CHECKSUM WITH THE AOBJN WD.
	MOVE B,JOBSYM(U)
	PUSHJ P,ALDRD1	;CKSUM IN C
	.IOT UTOC,B
	MOVE A,C
	PUSHJ P,NDMPA	;OUTPUT CHECKSUM.
DJBLK:	MOVE A,STARTA(U)
	HRLI A,(JUMPA)
	JRST NDMPA

NALTY:	PUSHJ P,GSOT
DUMP:	SETOM GSDNUM
	PUSHJ P,RRFLB	;:DUMP COMMAND.
	TLNE B,2ALTF
	JRST NALTY1
	MOVSI D,UFILE(U)
	HRRI D,NCTLTF	;COPY NAMES INTO NCTLTF
	BLT D,NCTLTF+2
	SETZM NCTLTF+3	;0 TO DELETE.
	.FDELE NCTLTF
	JFCL
NALTY1:	MOVEI A,3
	HRLM A,UFILE(U)
	TSOPEN UTOC,UFILE(U)
	TLZ F,CF
	TLNE B,IFXF	;$0Y => DUMP AS IMAGE.
	 TLO F,CF
	PUSHJ P,NDMP
	.CLOSE UTOC,
	JRST NLTL6
NDMP:	.USET USRI,[.RMEMT,,HIGH]
	MOVE A,[JRST 1]
	TLNN F,CF	;NO JRST 1 IF DUMPING AS IMAGE.
	PUSHJ P,NDMPA
	SKIPE C,ARG1+1
	MOVE C,ARG1	;FIRST ARG OR ZERO
	MOVE D,HIGH
	SOS D
	SKIPE ARG1+3	;HIGH OR SECOND ARG
	MOVE D,ARG1+2
NDMP2:	PUSHJ P,GCBLKP
	JRST NDMPS
	TLNE F,CF	;AS IMAGE => DUMP ALL INTO FILE.
	 JRST [.IOT UTOC,A ? JRST NDMP2]
	SKIPN (A)	;LOOK FOR NON-ZERO
NDMP3:	AOBJN A,.-1
	JUMPGE A,NDMP2	;GET NEXT BLOCK
	HRRZM A,W1	;SAVE START
	SKIPE (A)	;LOOK FOR ZERO
NDMP4:	AOBJN A,.-1
	JUMPGE A,NDMP5	;END, MAKE DUMP BLOCK
	AOBJP A,NDMP7	;NEXT WRD IS END
	SKIPE (A)	;SEE IF ONLY ONE ZERO
	JRST NDMP4
NDMP7:	SUB A,[1,,1]
NDMP5:	SUB A,[1,,1]
	MOVEM A,W2	;SAVE END
	MOVE A,C
	SOS A
	HRRZ B,W1
	CAIL B,AC0
	CAILE B,AC0+17
	SKIPA
	SUBI B,AC0
	DPB B,[1200,,A]	;GET TRUE ADDRESS
	HRRZ B,W2
	SUB B,W1
	SETCA B,
	HRL A,B
	PUSHJ P,NDMPA
	MOVE B,A
	HRR A,W1
	.IOT UTOC,A
	MOVE A,B
	HRR B,W1
NDMP6:	ROT A,1
	ADD A,(B)
	AOBJN B,NDMP6
	PUSHJ P,NDMPA
	MOVE A,W2
	JRST NDMP3

NDMPA:	HRROI B,A
	.IOT UTOC,B
	POPJ P,
NALTL:	TLNE B,2ALTF
	CALL QRERR	;CAN'T $$L IF RUNNING.
	CALL GSOT	;INIT READIN, TYPE SPACE.
LOAD:	PUSHJ P,QIJERR
	PUSHJ P,RRFLB	;GET FILE DIR.
NALTL2:	TLO F,CF+QF+4^5	;CAUSE LOADING OF SYMS.
	TLNN B,2ALTF
	 TLZ F,4^5	;SIGN ON => $$L (DON'T RESET)
	TLNN B,IFXF
	 TLZ F,QF	;QF ON => $0L.
	PUSHJ P,SMFLCK
	MOVEI B,UFILE(U)
	PUSHJ P,FLOCK
	JRST NALTL3	;TRY ALTERNATE DEFAULT.
NALTL5:	MOVE D,SNLIST
	MOVEM D,UFILES(U)
NALTL6:	PUSHJ P,ALOAD1
	JRST NLTL4

NALTL3:	MOVEI B,6
	HRLM B,IFILE
	.SUSET [.SSNAM,,IFILE+4]
	MOVEI B,IFILE
	PUSHJ P,FLOCK
	JRST NALTL4	;ALTERNATE FAILED, GO GIVE ERROR.
	MOVEI A,IFILE
	MOVE B,IFILE+4
	CAME B,SNLIST	;DON'T PRINT SNAME IF FLOCK DID.
	SETZ B,
	PUSHJ P,LFILE0	;PRINT ALTERNATE DEFAULT.
	PUSHJ P,CRF
	MOVE D,SNLIST	;GET SNAME ACTUALLY USED.
	MOVEM D,IFILE+4
	MOVEM D,LSNAM
	MOVEI A,UFILE(U)
	HRLI A,IFILE	;COPY IT INTO NORMAL DEFAULT.
	BLT A,UFILE+4(U)
	JRST NALTL6

NALTL4:	.SUSET [.SSNAM,,LSNAM]
	.OPEN UTIC,UFILE(U)
	OPNER UFILE(U)
	JRST NALTL6	;ORIGINAL NAME GOT CREATED.
ALD:	TLNE F,QF	;QF => LOAD AS IMAGE.
	 JRST ALDIM
	.STATUS UTIC,W1
	ANDI W1,77
	CAIE W1,43		;SKIP IF LOADING FROM A DISK
	JRST ALDND
	MOVEI W1,0	
	PUSHJ P,GTWD
	CAME B,[JRST 1]
	MOVEI W1,1
	.ACCESS UTIC,[0]
	SETOM LOADF		;FOR LOAD FAILURE DETECTION
	STDCAL LOAD,[1000,,USRI ? 1000,,UTIC]
	SETZM LOADF
	PUSHJ P,GTWD
ALDJ:	JUMPL A,ALDJ1	;FOR :SL, DON'T SET START ADDR.
	HRRZM B,PPC(U)
	MOVEM B,STARTA(U)
ALDJ1:	TLNN F,CF
	POPJ P,
	JUMPN W1,ALDS
	TLC B,(JUMPA)
	TLNN B,777000
	JRST ALDS
	POPJ P,
ALDND:	MOVEI W1,0		;LOADING BINARY FILES ($L) BUT NOT FROM A DISK
ALD0:	PUSHJ P,GTWD
	CAME B,[JRST 1]
	AOJA W1,ALD0
	PUSH P,[,,-1]	;SAY DON'T HAVE ANY PAGE OF JOB IN VPAGE.
ALD1:	PUSHJ P,GTWD	;GET HEADER OF NEXT SBLK.
	JUMPGE B,[POP P,A ? JRST ALDJ] ;>0 => START ADDR.
	MOVE C,B
ALD2:	LDB D,[121000,,B] ;WHAT PAGE LOADING INTO?
	SKIPL (P)	;MAYBE WE ARE SKIPPING THRU FOR :SYMLOD
	CAMN D,(P)
	 JRST ALD3	 ;OR ALREADY HAVE THAT PAGE IN VPAGE.
	MOVEI A,(B)	;ELSE MAKE SURE PAGE EXISTS,
	PUSHJ P,DEP
	STDCAL CORBLK,[1000,,7^5 ? 1000,,-1 ? 1000,,VPAGE ? 1000,,USRI ? D]
	MOVEM D,(P)	;SAY NOW HAVE THAT PAGE.
ALD3:	MOVE D,B	;SAVE REAL AOBJN,
	TRZ B,-2000	;MAKE B -> VPAGE, NOT ADDR IN INFERIOR.
	IORI B,VPAGAD
	MOVSI A,-VPAGAD-2000(B)
	CAML A,B
	HLL B,A		;DON'T GO BEYOND END OF THAT VPAGE.
	PUSHJ P,ALDRD
	HLRS B
	HRLI B,-1(B)
	SUBM D,B
	JUMPL B,ALD2
	PUSHJ P,GTWD
	CAME C,B
CKSERR:	ERSTRT [SIXBIT/CHECKSUM?/]
	JRST ALD1

FILENG:	TERR (SIXBIT/BIN/)

GTWD:	HRROI A,B
GTWD1:	.IOT UTIC,A
	JUMPL A,FILENG
	POPJ P,

ALDS:	PUSH P,JOBSYM(U) ;(WILL WANT TO SEE IF SYMTAB WAS EMPTY)
	SETO W2,	;ABOUT TO CALL SLOD0 THE 1ST TIME.
ALDS0:	PUSHJ P,GTWD	;NOW LOAD 1 SBLK -
	SKIPL A,B	;GET -LENGTH,, AS ARG.
	 JRST ALDS2	;NO MORE SYMS.
	MOVEI B,GTWD1
	PUSHJ P,SLOD0	;READ IN THOSE SYMS.
	MOVE A,C	;GET AOBJN -> SPACE FILLED WITH SYMS READ.
	HLLZS C		;PUT HEADER OF SBLK INTO CKSUM.
	PUSHJ P,ALDRD2	;CALCULATE CKSUM.
	PUSHJ P,GTWD	;READ CHECKSUM.
	CAME C,B
	 JRST CKSERR
	JRST ALDS0	;GET SOME MORE SYMS.

ALDS2:	POP P,A
	JUMPL A,SSRT	;IF MERGED FILE'S SYMS WITH OTHERS, MUST SORT.
	JUMPGE W3,SSRT	;IF FILE DIDN'T HAVE SORTED SYMS, SORT.
	JRST SGLOB	;ELSE SET PRGM -> GLOBAL BLOCK, DON'T SORT.

ALDRD:	MOVE A,B
	PUSHJ P,GTWD1
ALDRD1:	MOVE A,B
ALDRD2:	ROT C,1
	ADD C,(A)
	AOBJN A,.-2
	POPJ P,

ALOAD:	TLZ F,QF	;FROM ^K, NOT IMAGE LOAD.
ALOAD1:	MOVE A,[UTIC,,A]
	.RCHST A,
	HRLZM A,UFNAMD(U)
	MOVEM B,UFNAM1(U)
	MOVEM C,UFNAM2(U)
	MOVEM D,UFNAMS(U)
	JUMPL F,ALOAD2
	TLZ F,NROFL
	SETZM PATCHL(U)
	.RESET USRI,
	.USET USRO,[.SSNAM,,MSNAM]	;SET SYSTEM NAME TO MASTER SYSTEM NAME
	HRRZS BPINFL(U)	;BPTS AREN'T IN NOW.
	SETZM BTADR(U)	;NO TEMP BPT.
	MOVEI D,21
	MOVEM D,UINTWD(U)
	PUSHJ P,ELECTRON
	MOVEI W1,UNDEFL(U)
	PUSHJ P,ELEC0
ALOAD2:	PUSHJ P,ALD
	.USET USRI,[.RMEMT,,HIGH]
CLSU:	.CLOSE UTOC,
	.CLOSE UTIC,
	POPJ P,

ALDIM:	CALL VPAGET	;IMAGE LOAD, GET BUFFER.
	.ACCESS USRO,ARG1	;START AT 1ST ARG.
ALDIM1:	MOVE A,[-2000,,VPAGAD]
	.IOT UTIC,A	;READ UP TO 1 PAGE.
	HRLOI B,-1-VPAGAD(A)
	EQVI B,VPAGAD	;AOBJN -> WHAT WAS READ.
	JUMPGE B,VPAGRT	;NOTHING WAS READ, DONE.
	.IOT USRO,B	;WRITE INTO INFERIOR.
	JUMPGE A,ALDIM1	;NO EOF => TRY FOR MORE.
	JRST VPAGRT

SYMADD:	TDZA B,B	;DON'T FLUSH CURRENT SYMS.

CSMI:	MOVNI B,1
	PUSHJ P,QOJERR	;CAN'T :SL IN SYS JOB OR SELF.
	PUSHJ P,RRFLB
	PUSHJ P,SMFLCK
	SKIPE B
	PUSHJ P,ELECTRON
	TSOPEN UTIC,UFILE(U)
CSMI1:	PUSHJ P,VPAGET
	PUSHJ P,GTWD
	JUMPN B,CSMI4	;SBLK  (FIRST WORD 0=> FILE PLOADED)
	MOVE B,[UTIC,,VPAGAD]
	.RCHST B,
	SKIPGE VPAGAD+4	;ACCESS POINTER
	ERSTRT [SIXBIT /PURE FILE NOT ON DISK?/]
	MOVE B,[-400,,VPAGAD] ;READ THE PAGE DESCRIPTOR WDS.
	.IOT UTIC,B
	MOVSI B,-400
	MOVEI W1,1	;THE DESCRIPTORS TAKE 1 PAGE OF FILE.
CSMI5:	SKIPLE VPAGAD(B)	;SOME DESCRIPTORS HAVE PAGES IN FILE.
	 AOJ W1,
	AOBJN B,CSMI5
	LSH W1,12	;CONVERT # PAGES TO ACCESS POINTER
	.ACCESS UTIC,W1	;SKIP TO END OF PROGRAM
	JRST CSMI3	;NOW LOAD SYMBOLS (1ST WORD >0)
CSMI4:	TDZA W1,W1	;CLEAR COUNT
	PUSHJ P,GTWD
	CAME B,[JRST 1]
	AOJA W1,.-2
CSMI3:	PUSH P,[NLTL2]	;GO KERCHINK
	PUSH P,[VPAGRT]	;AFTER RETURNING PAGE, AFTER LOADING SYMS.
	PUSH P,[-1]	;SO ALD1 WON'T PUT PAGE OF JOB IN VPAGE.
	TLO F,CF	;TELL ALD1 TO LOAD SYMS.
	JRST ALD1	;GO LOAD FILE (BUT FAKE IT OUT NOT TO CLOBBER CORE)

;<ARG>^Y - ARG IS AOBJN -> SYMS TO LOAD. $^Y FLUSHES EXISTING SYMS FIRST.
NCTLY:	CALL QOJERR
	TLNE B,1ALTF
	PUSHJ P,ELECTRON
	CALL GARGDQ	;GET ARG OR $Q IN D.
	JUMPGE D,NLTL2	;DO NOTHING IF ADDING 0 SYMS.
	HRRZ B,D	;GET ADDRESS OF BEGINNING OF AREA
	.ACCESS USRI,B
	MOVE A,D	;GIVE AOBJN TO SLOD.
	PUSH P,[NLTL2]
	SAVE JOBSYM(U)	;ALDS2 WILL LOOK AT & POP THIS.
	PUSH P,[ALDS2]	;MAYBE SORT SYM TAB AFTER LOADING.
	JSP B,SLOD
	.IOT USRI,A
	POPJ P,

N2ACY:	SKIPN ARG1+1	;$$^Y
	JRST NXERR
	MOVE A,ARG1
	PUSHJ P,FETCH	;READ AOBJN POINTER.
	 JRST NXERR
	HLRE A,D	;GET LEFT HALF
	MOVMS A		;LENGTH OF EXISTING TABLE.
	ADDI A,(D)	;ADDR OF WD AFTER END OF TABLE.
	HLRE D,JOBSYM(U)
	ADD A,D	;START OF NEW SYM TAB.
	JUMPLE A,NXERR	;NO ROOM?
	.ACCESS USRO,A
	MOVE D,JOBSYM(U)
	.IOT USRO,D	;TRANSFER IT.
	MOVE D,A
	HLL D,JOBSYM(U)	;NEW AOBJN POINTER.
	MOVE A,ARG1
	PUSHJ P,DEP
	JRST NLTL2

;LOAD SYMS FROM ARBITRARY SOURCE.
;B HOLDS ADDR OF ROUTINE TO TAKE AOBJN IN A AND READ IN SYMS.
;LH OF A IS -<SIZE OF TABLE>
;CLOBBERS A,B,C,D,W1,W2,W3
SLOD:	SETO W2,	;ABOUT TO CALL SLOD0 THE 1ST TIME.
SLOD0:	JUMPGE A,CPOPJ	;NOTHING TO ADD.
	ANDCMI A,-1	;MAKE SURE RH, CLEAR.
	SAVE [0]
	PUSH P,A
	JUMPE W2,SLOD1	;NOT 1ST TIME => DON'T INITIALIZE.
	SKIPL JOBSYM(U)
	 PUSHJ P,SINIT	;CREATE GLOBAL BLOCK IF NONE.
	HRRZ D,JOBSYM(U)
	HLRE A,JOBSYM(U)
	SUBM D,A	;GET ADDR OF WD AFTER SYMTAB.
	MOVEM A,PRGM(U)
	HRROI A,W2	;READ 1ST 2 WDS OF SYM TAB.
	PUSHJ P,(B)
	HRROI A,W3
	PUSHJ P,(B)
	MOVE A,(P)	;GET -<SPACE NEEDED>,,
	TLNE W2,LOCAL	;1ST SYM LOCAL => NO BLOCK STR, PUT AT END.
	 JRST SLOD1
SLOD2:	PUSHJ P,SGLOB	;BLOCK STRUCTURED, LOAD BEFORE GLOBAL BLOCK.
	HRRZS PRGM(U)
	JUMPGE W3,SLOD1
	TLNN W2,PNAME	;IF WE WEREN'T FORCED HERE BY :RLOAD,
	ADD A,[2,,]	;SORTED, OVERWRITE EXISTING GLOBAL HEADER
			;TO MERGE OUR GLOBAL BLOCK WITH FILE'S.
	MOVSI D,-2
	MOVEM D,-1(P)	;ARRANGE TO UPDATE PRGM AS IF GLOBAL HEADER HADN'T EXISTED.
SLOD1:	PUSH P,B
	MOVEI W1,PRGM(U)
	ADDM A,JOBSYM(U)
	PUSH P,JOBSYM(U)
	PUSHJ P,HOLE0	;GET ROOM FOR SYMS.
	POP P,JOBSYM(U)
	POP P,B		;SYMBOL READIN RTN ADDR.
	POP P,A		;-<# WDS OF SYMS>,,
	REST D		;EITHER 0 OR -2,, (LATTER IFLOADING SORTED SYMS)
	ADDM D,PRGM(U)
	HLL C,A		;AOBJN -> SPACE FOR THEM, LEAVE IN C FOR ALDS TO CALC. CKSUM.
	MOVE A,C
	JUMPE W2,(B)	;2ND TIME AND AFTER, JUST READ THEM.
	MOVEM W2,(A)	;1ST TIME, STORE THE 1ST 2 WDS.
	MOVEM W3,1(A)
	TLNE W2,PNAME	;NOT BLOCK STRUCTURED =>
	 SETZ W3,	;TELL ALDS2 MUST SORT IN ANY CASE.
	SETZ W2,	;NEXT TIME, DON'T INITIALIZE.
	AOBJP A,.+1
	AOBJN A,(B)
	POPJ P,	;THOSE 1ST 2 WDS WERE ALL!
;SORT THE SYM TAB.
SSRT:	SETZM PRGM(U)	;SAY HAVEN'T YET SEEN GLOBAL BLOCK.
	PUSHJ P,SSBG	;BUBBLE ALL GLOBALS TO END.
SSRT9:	MOVE A,JOBSYM(U)
SSRTB:	JUMPGE A,SSRT2
	MOVE D,(A)
	TLNE D,PNAME	;IF NO BLOCK NAME,
	 JRST SSRT2	;PUT GLOBAL BLOCK HERE.
	HLRE C,1(A)	;DON'T SORT BLOCKS ALREADY SORTED,
	CAMN D,[SQUOZE 0,GLOBAL]	;ALWAYS SORT GLOBAL BLOCK.
	 JRST [MOVEM A,PRGM(U) ? JRST SSRT3]
	JUMPL C,[HRLI C,-1(C) ? SUB A,C ? JRST SSRTB]
	JRST SSRT3

SSRT2:	SKIPE PRGM(U)	;AT END: IF NO GLOBAL BLOCK, MAKE ONE.
	POPJ P,
	PUSHJ P,SSRTG
SSRT3:	SKIPE PRGM(U)
	SKIPA D,[PNAME,,] ;ONLY GLOBAL BLOCK CAN HAVE GLOBAL SYMS.
	MOVSI D,LOCAL	;OTHER BLOCKS CAN'T.
	MOVE B,A
SSRT0:	ADD B,[2,,2]
	JUMPGE B,SSRT1	;MOVE B UP AFTER END OF THIS BLOCK.
	TDNE D,(B)
	JRST SSRT0

SSRT1:	MOVSI W2,4^5		;SORT 1ST ON TOP BIT.
	MOVE W1,[TDNE W2,1(A)]	;SORT ON BIT IN 2ND WD,
	MOVE C,[TDNN W2,1(B)]	;PUT STE'S WITH BIT ON FIRST.
	MOVEI W3,[HRLI W1,(TDNN W2,(A))
		HRLI C,(TDNE W2,(B))
		MOVEI W3,SSRTX	;REVERSE THAT LAST, ON THE REST OF THE BITS.
		JRST SSRTX]
	PUSH P,B	;SAVE NEXT BLOCK'S START ADDR.
	ANDI A,-1
	SKIPGE 1(A)	;IF THIS IS GLOBAL BLK BEING SORTED ANYWAY,
	 JRST SSRT4	;DON'T CLOBBER ITS LEVEL.
	AOS D,1(A)
	CAIL D,-1	;THIS IS PROGM NAME -> MAKE LEVEL 1,
	SETZM 1(A)
	AOS 1(A)	;ELSE 2+LEVEL OF BLOCK.
SSRT4:	SUBM A,B
	HRLM B,1(A)	;STORE -<SIZE OF BLOCK'S ENTRY>
	HRRZ B,(P)
	ADDI A,2	;DON'T INCLUDE BLOCK NAME IN SORT.
	PUSHJ P,SSRTX
	POP P,A
	JRST SSRTB	;SORT NEXT BLOCK.

;CREATE A GLOBAL BLOCK HEADER WHERE A POINTS,
;MAKE PRGM POINT THERE.
SSRTG:	HRRZM A,PRGM(U)	;PLACE TO PUT IT.
	PUSH P,A
	MOVEI W1,PRGM(U)
	MOVSI A,-2
	ADDM A,JOBSYM(U)
	PUSH P,JOBSYM(U)
	PUSHJ P,HOLE0	;MAKE SPACE.
	POP P,JOBSYM(U)
	POP P,A
	SUB A,[2,,]	;SYMTAB TAIL -> GLOBAL BLOCK HEADER.
	MOVEM A,PRGM(U)
	MOVE D,[SQUOZE 0,GLOBAL]
	MOVEM D,(A)	;PUT THE STUFF IN.
	MOVSI D,-2
	MOVEM D,1(A)
	POPJ P,

SSRTX:	HRLM B,(P)	;DO ONE PASS OF RADIX-EXCHANGE. SAVE END.
	CAIL A,-2(B)	;ONLY 1 ENTRY, NOTHING TO DO.
	 JRST SSRTX7
	PUSH P,A	;SAVE START.
SSRTX3:	XCT W1
	 JRST SSRTX4	;MOVE UP TO 1ST WITH BIT ON.
	SUBI B,2
	XCT C		;MOVE DOWN TO LAST WITH BIT OFF.
	 JRST SSRTX5
REPEAT 2,[
	MOVE D,.RPCNT(A)	;EXCHANGE THEM,
	EXCH D,.RPCNT(B)
	MOVEM D,.RPCNT(A)]
SSRTX4:	ADDI A,2
SSRTX5:	CAME A,B	;ALL DONE => DO NEXT BIT.
	 JRST SSRTX3	;MORE IN THIS PASS.
	ROT W2,-1	;NEXT BIT DOWN.
	POP P,A		;A -> START, B -> END OF 1ST HALF.
	JUMPL W2,SSRTX6	;ALL BITS IN WD DONE, STOP.
	PUSHJ P,(W3)	;DO NEXT BIT ON 1ST HALF.
	HLRZ B,(P)	;A -> END OF 1ST HALF, B -> END OF ALL.
	PUSHJ P,(W3)	;DO SECOND HALF.
SSRTX6:	ROT W2,1	;LEAVE W2 AS FOUND IT.
SSRTX7:	HLRZ A,(P)	;LEAVE A -> END OF AREA SORTED.
	POPJ P,

;BUBBLE ALL GLOBAL SYMS TO END OF SYM TAB.
;WON'T CHANGE ORDER OF NON-GLOBAL SYMS, MAY MESS UP ORDER OF GLOBALS.
SSBG:	MOVE A,JOBSYM(U)	;A -> 1ST OFF BUBBLE OF GLOBALS.
	MOVE B,JOBSYM(U)	;B -> 1ST SYM AFTER BUBBLE.
SSBG0:	JUMPGE B,CPOPJ	;ALL DONE IF BUBBLE AT END.
	MOVE C,(B)	;ELS IS NEXT SYM GLOBAL?
	TLNE C,GLOBAL
	 JRST SSBG1	;YES => INCLUDE IT IN BUBBLE.
	EXCH C,(A)	;NO => EXCHANGE WITH 1ST IN BUBBLE,
	MOVEM C,(B)	;MOVING WHOLE BUBBLE UP 1 STE.
	MOVE C,1(B)
	EXCH C,1(A)
	MOVEM C,1(B)
	ADD A,[2,,2]	;BEGINNING AND END BOTH MOVE UP.
SSBG1:	ADD B,[2,,2]
	JRST SSBG0

;SET D AND PRGM(U) -> GLOBAL BLOCK'S HEADER.
SGLOB:	PUSH P,A
	MOVE D,JOBSYM(U)
SGLOB0:	MOVE A,(D)
	CAMN A,[SQUOZE 0,GLOBAL]
	 JRST SGLOB1	;FOUND.
	ADD D,[2,,2]
	JRST SGLOB0

SGLOB1:	MOVEM D,PRGM(U)
	JRST POPAJ

;INITIALIZE SYM TAB WITH A GLOBAL BLOCK WITH NO SYMS.
SINIT:	SKIPGE JOBSYM(U)
	 ERLOSS JOBSYM(U)
	PUSH P,A
	MOVE A,JOBSYM(U)
	PUSHJ P,SSRTG
	JRST POPAJ

;:PRGM, PRINT CURRENT PROGRAM NAME.
KPRGM:	PUSHJ P,QJERR	;MUST HAVE JOB.
	SKIPE TOKTRM	;IF READ A CR, TYPE A SPACE (IE DON'T TYPE ONE IF READ SPACE)
	PUSHJ P,TSPC
	SKIPL W1,PRGM(U)
	 7NRTYP [ASCIZ/NO SYMS   /]
	PUSHJ P,SPT	;PRINT BLOCK'S NAME.
	HRRZ D,1(W1)	;GET LEVEL.
	SOJL D,LCTGNR	;IF BLOCK IS GLOBAL BLOCK.
	SOJL D,[7NRTYP [ASCIZ/, PROGRAM   /]]
	7TYPE [ASCIZ/, LEVEL /]	;A BLOCK IN PROGRAM.
	PUSHJ P,TOC
	JRST LCTGNR

;:LISTP - LIST STRUCTURE OF SYM. TAB.
KLSTP:	PUSHJ P,QJERR
	HLRE W1,JOBSYM(U)	;GET -LENGTH OF SYMTAB
	JUMPGE W1,NLTL2	;IF NO SYMS.
	MOVNS W1
	ADD W1,JOBSYM(U)
	ANDI W1,-1	;ADDR OF WD AFTER SYMTAB.
KLSTP1:	CAMN W1,JOBSYM(U)
	 JRST NLTL2	;GOT TO START OF SYMTAB, DONE.
	SUB W1,[2,,2]	;MOVE BACK 1 SYM AT A TIME.
	MOVE D,(W1)
	TLNE D,PNAME
	 JRST KLSTP1	;NOT BLOCK, KEEP GOING.
	MOVE A,1(W1)
	CAMN A,[-2,,1]
	 JRST KLSTP1	;IGNORE PROGRAM NAMES WITH NO SYMS.
	PUSHJ P,CRF	;EACH NAME ON SEPARATE LINE.
	PUSHJ P,MORFLS	;TYPE --MORE-- AT SCREEN BOTTOM.
	 JRST NLTL2
	TRNE A,-2	;FOR BLOCKS, USE <LEVEL>-1.
	 SUBI A,1	;SO OUTERMOST BLOCK GETS 1 SPACE LIKE PROGRAM.
	TLZA A,-1	;GET <LEVEL> IN RH ALONE.
KLSTP2:	PUSHJ P,TSPC	;TYPE LEVEL SPACES.
	SOJGE A,KLSTP2
	PUSHJ P,SPT	;THEN TYPE NAME OF BLOCK OR PROGRAM.
	JRST KLSTP1

NACOL:	PUSHJ P,QJERR
	SKIPL A,JOBSYM(U) ;<BLOCK>$:, <BLOCK>$$:
	 JRST NACOLE
	HLRE D,A
	SUB A,D
	ANDI A,-1	;ADDR OF WD AFTER SYM TAB.
	SETZ D,		;ASSUME IT'S $: AND AREN'T CHECKING LEVEL.
	TLNN B,2ALTF
	 JRST NACOL8
	MOVE A,PRGM(U)	;REALLY IT'S $$:, LOOK FOR CURRENT BLOCK'S INFER.
	MOVE D,1(A)
	AOS D,
NACOL8:	CAMN A,JOBSYM(U)	;CAN'T MOVE BACK PAST START.
NACOLE:	 ERSTRT [SIXBIT / U?/]
	SUB A,[2,,2]
	CAME C,(A)
	 JRST NACOL8	;HAVEN'T FOUND THE BLOCK, WRONG NAME OR NOT BLOCK.
	JUMPE D,NACOL6	;RIGHT NAME, TESTING LEVEL?
	HLL D,1(A)	;COMPARE ONLY THE RH'S.
	CAME D,1(A)
	 JRST NACOL8	;WE ARE AND IT DOESN'T MATCH.
NACOL6:	MOVEM A,PRGM(U)
	JRST LCTGNR

;FLUSH THE CURRENT JOB'S SYMBOLS.
ELECTRON:	HRRZ W1,JOBSYM(U)
	CAIG W1,DDT	;DO NOTHING IF SELF OR SYSTEM.
	 RET
	HRRZ D,SYMTOP
	MOVEM D,PRGM(U)
	MOVEI W1,JOBSYM(U)

;FLUSH AN OBJECT IN SYMTAB SPACE.
;W1 POINTS TO AOBJN PTR OBJECT, PTR CLOBBERED TO SYMTOP.
ELEC0:	HLLZ D,(W1)	;-<CURRENT SIZE>,,
	JUMPE D,CPOPJ	;NOTHING TO DO IF ALREADY 0 SIZE.
	HRRZS A,(W1)	;CURRENT START.
	SAVE SYMTOP	;OBJECT NOW EMPTY, MAKE -> TOP.
	REST (W1)
	HRLI A,(A)
	SUB A,D		;END,,START
	HLRES D
	ADD D,SYMTOP	;NEW SYMTOP.
	BLT A,-1(D)
	HRRZ A,SYMTOP
	EXCH A,(W1)	;GET OLD START.
	SUB D,SYMTOP	;GET -<OLD SIZE>.

;RELOCATE ALL POINTERS INTO SYMTAB SPACE
;WHEN PART OF IT IS SHIFTED.
;A HAS OLD START OF OBJECT THAT CHANGED SIZE,
;D HAS AMOUNT OF CHANGE.
RELOC:	MOVSI W1,-NINFP
	PUSH P,B
	PUSH P,C
REL0:	MOVEI B,JOBSYM(W1)
	PUSHJ P,REL3	;RELOCATE THE JOBSYM, PRGM AND UCHBUF OF EACH JOB.
	MOVEI B,PRGM(W1)
	PUSHJ P,REL3
	MOVEI B,UCHBUF(W1)
	PUSHJ P,REL3
	MOVEI B,UNDEFL(W1)
	CALL REL3	;RELOCATE UNDEF SYM REF LIST PTR.
	ADDI W1,USRLNG-1
	AOBJN W1,REL0
	MOVEI B,INPDL	;NOW RELOCATE VALRET STRING & ANY PUSHED VALRET STRINGS.
REL1:	MOVEI B,1(B)
	PUSHJ P,REL3
	MOVEI B,2(B)
	PUSHJ P,REL3
	SKIPE B,-3(B)
	JRST REL1
IRPS X,,FLDTBP FLDSTR W4
	MOVEI B,X
	CALL REL3
TERMIN
	SKIPE B,RELCP1	;RELOC. SOME SPECIAL PTR (IF ANY)
	 CALL REL3
	ADDM D,SYMTOP
	HRRZS D,SYMTOP	;RELOCATE SYMTOP.
	PUSHJ P,RELC	;RELOCATE MEMT.
POPCBJ:	POP P,C
	JRST POPBJ

REL3:	HRRZ C,(B)	;B HAS ADDR OF 1 PTR TO RELOCATE.
	CAIGE C,(A)	;RELOC IT ONLY IF AFTER OBJECT THAT CHANGED SIZE.
	POPJ P,
	ADDI C,(D)
	HRRM C,(B)
	POPJ P,

HOLE0:	PUSH P,W1	;SAVE ADDR OF AOBJN PTR TO EXPAND.
	HLRE C,(W1)
	MOVNS C		;CURRENT SIZE.
	ADD C,(W1)	;RH HAS 1+CURRENT LAST WD.
	PUSH P,A
	HLRES A
	MOVNS A		;NUM. WDS TO EXPAND.
	HRRZ D,SYMTOP
	ADD D,A
	PUSHJ P,RELC	;GET CORE BEFORE MOVE UP.
	HLLZ W1,(P)
	ADDM W1,@-1(P)
HOLE1:	HRRZ D,SYMTOP
	SOS D
	HRRM A,HOLPPX	;+#REGS NEW
	MOVEI W1,(SETZ D)	;400000+SYMTOP-1 (AVOID PDL OV)
	SUB W1,C
	HRL D,W1	;400000+#REGS TO MOVE-1,,SYMTOP-1
	SKIPGE D
HOLPOP:	XCT HOLPPX	;MOVE TOP OF SYM TAB UP BY LH(A)
	JUMPL D,.-1
	MOVEI D,(A)
	POP P,A		;GET -<NUM WDS INCREASE> IN LH,
	HRR A,@(P)	;ADDR OF CURRENT START IN RH.
	PUSH P,@(P)	;SAVE THE UPDATED AOBJN PTR
	PUSHJ P,RELOC	;SINCE RELOC WILL WRECK IT.
	POP P,@-1(P)
	JRST POPW1J

RELC:	SOS D
	LDB D,[121000,,D]
	CAIGE D,VPAGE-1
	.CORE 1(D)
	ERSTRT [SIXBIT/CORE?/]
	POPJ P,

;ALLOCATE AN OBJECT AT TOP OF SYMTAB SPACE; #WDS IN D.
;RETURN AOBJN PTR TO OBJECT IN A.
ALLOC:	MOVNI A,(D)
	MOVSI A,(A)
	HRR A,SYMTOP	;CONSTRUCT THE AOBJN
	JRST RELOC	;WHICH IS JUST WHAT RELOC WANTS, TOO.

;DEFINE SYMBOL, SQUOZE IN SYM (FLAGS CLEAR) VALUE IN D.
;SETS GLOBAL BIT IN SYM. CLOBBERS A,C,D,W1.
DEFIN:	JUMPL U,JERR    
	PUSHJ P,DEFUND	;HANDLE UNDEF REFS TO SYM.
	SKIPE SYSSW
	JRST DEFINS
	PUSH P,B
	PUSH P,D
	SKIPL JOBSYM(U)
	 PUSHJ P,SINIT	;CREATE GLOBAL BLOCK IF NONE.
	MOVE B,PRGM(U)
	HLL B,1(B)	;GET AOBJN -> THIS BLOCK'S SYMS.
	ADD B,[2,,2]
	PUSH P,B	;HOLE0 NEEDS THIS.
	PUSHJ P,SEVLB1	;LOOK FOR DEF. IN THIS BLOCK.
	JRST DEF1
	JRST DEF2	;REDEFINE
DEF1:	SKIPE DDTSW
	 JRST DEFIND	;CAN'T CALL HLOE0 ON DDT SYM TAB.
	MOVSI A,-2
	MOVEI W1,(P)	;MAKE SPACE AFTER THIS BLOCK'S SYMS.
	ADDM A,JOBSYM(U)	;SYM TAB & BLOCK BOTH LONGER.
	ADDM A,PRGM(U)
	MOVE B,PRGM(U)
	ADDM A,1(B)
	PUSHJ P,HOLE0
	MOVEI A,(C)	;GET ADDR OF SPACE JUST MADE.
DEF2:	POP P,W1
	POP P,1(A)	;PUT VALUE IN DEF.
	MOVSI D,LOCAL
	IOR D,SYM
	MOVEM D,(A)	;PUT NAME IN, IN CASE NEW SYMBOL.
	PUSHJ P,SBUBL	;DO BUBBLE SORT OF THIS BLOCK.
	JRST POPBJ

DEFIND:	MOVE A,[-2,,-2]	;DEFINE SYM IN SELF.
	ADDM A,JOBSYM(U)
	ADDM A,STBDDT	;EXTEND DDT SYM TAB DOWNWARD.
	ADDB A,PRGM(U)
	MOVE B,2(A)	;MOVE THE GLOBAL HEADER DOWN 1 STE.
	MOVEM B,(A)
	MOVE B,3(A)
	ADD B,[-2,,]	;1 MORE SYM IN THE GLOBAL BLOCK.
	MOVEM B,1(A)
	MOVEI A,2(A)	;PUT NEW SYM WHERE HEADER WAS.
	JRST DEF2

DEFINS:	SKIPN SYSDPS
	JRST QIJERR
	MOVEM D,SYM1
	MOVSI D,GLOBAL
	IORM D,SYM
	MOVEI D,SYM
	.REDEF D,
	JRST NXERR
	POPJ P,

;DO BUBBLE SORT OF PORTION OF SYMTAB THAT W1 POINTS TO.
;DO ONE PASS UP, ONE DOWN; ASSUME ONLY ONE ENTRY OUT OF ORDER.
;CLOBBER A-D AND W1.
SBUBL:	MOVE B,[2,,2]	;INCREMENT FOR UPWARD PASS.
	MOVE C,[JUMPL A,SBUBL1]
	SUBI W1,2	;(WILL INCREMENT BEFORE ACTING)
	MOVE A,W1
	PUSHJ P,SBUBL2
	MOVNS B	;DECREMENT FOR DOWNWARD PASS.
	MOVE C,[CAMN A,W1]
	JRST SBUBL2

SBUBL1:	MOVE D,1(A)	;CHECK NEXT PAIR OF ENTRIES.
	CAMG D,3(A)
	 JRST SBUBL2	;IN CORRECT ORDER.
	EXCH D,3(A)
	MOVEM D,1(A)	;WRONG ORDER, EXCHANGE.
	MOVE D,(A)
	EXCH D,2(A)
	MOVEM D,(A)
SBUBL2:	ADD A,B		;MOVE TO NEXT ENTRY.
	XCT C		;TEST IF FINISHED.
	 POPJ P,
	JRST SBUBL1	;(NOT FINISHED)

NALTK:	CAME D,[200000,,]	;$K, $$K
	JRST NALTK2
N2ACC1:	MOVEM B,(W4)
	MOVEM C,SYM
	PUSHJ P,SEVL
	7NRTYP [ASCII / U/]
	MOVE B,(W4)	;SEVL CLOBBERED B.
	MOVEI D,DELO_-16.
	TLNE B,2ALTF
	MOVEI D,DELI_-16.
	DPB D,[420200,,(A)]
	JRST LCTGNR

NALTK2:	JUMPN D,NAERR
	TLNN B,2ALTF
	JRST NXERR
	PUSHJ P,ELECTRON
	JRST NLTL2

N2ACC:	MOVE C,N2ACCS	;$$^C,GET NAME OF LAST SYM TYPED OUT.
	TLZ C,PNAME
	TLZ B,2ALTF	;TELL N2ACC1 SHOULD ONLY SEMI-KILL.
	SKIPE N2ACC1
	CALL N2ACC1
	MOVE D,LWT
	PUSHJ P,@SCH
	JRST LCTGNR
;LIST ALL UNDEF REFS IN CURRENT JOB.
LISTU:	JUMPL U,JERR
	MOVE B,CJTOUT
	MOVEM B,SPTS	;SPT1 WILL CALL TOUT WITH EACH CHAR.
	SKIPL B,UNDEFL(U)
	JRST NLTL2	;IF NO UNDEF REFS.
LISTU0:	PUSHJ P,CRF	;HANDLE NEXT ONE,
	PUSHJ P,MORFLS
	 JRST NLTL2
	MOVE D,(B)
	PUSHJ P,SPT1	;PRINT SYMBOL NAME,
	PUSHJ P,LCT
	SKIPGE D,1(B)
	7TYPE [ASCIZ/S /]	;SAY SO IF SWAPPED REF.
	ANDI D,-1
	PUSH P,B
	PUSHJ P,PAD	;TYPE LOCATION REF IS FOR.
	POP P,B
	AOBJN B,.+1
	AOBJN B,LISTU0
	JRST NLTL2

;WHEN DEFINING SYMBOL (SQUOZE IN SYM W/ FLAGS CLEAR, VALUE IN D)
;SATISFY ITS UNDEF REFS. CLOBBRS W1.
DEFUND:	PUSH P,B
	SKIPL B,UNDEFL(U)
	JRST POPBJ	;NO UNDEF REFS IN JOB.
	PUSH P,A
	PUSH P,D
DEFU0:	MOVE A,(B)	;IS THIS UNDEF REF
	CAME A,SYM	;A REF FOR THIS SYMBOL?
	JRST DEFU2	;NO, LOOK AT NEXT.
	HRRZ A,1(B)	;GET ADDR. REF IS FOR.
	PUSHJ P,FETCH
	 JRST DEFU1	;CAN'T READ THAT LOC., FLUSH THE UNDEF REF.
	SKIPGE 1(B)	;IF SWAPPED REF, SWAP THE SYMBOL.
	MOVSS (P)
	ADD D,(P)	;ADD SYM TO LOC'S CONTENTS,
	SKIPGE 1(B)
	MOVSS (P)
	PUSHJ P,DEP	;STORE THE SUM BACK.
DEFU1:	PUSHJ P,REMUN	;FLUSH THE SATISFIED UNDEF REF.
DEFU2:	AOBJN B,.+1
	AOBJN B,DEFU0
	POP P,D
POPABJ:	POP P,A
	JRST POPBJ
;REMOVE THE UNDEFINED-SYMBOL ENTRY THAT B POINTS TO.
;LEAVE B POINTING TO THE ENTRY BEFORE THE ONE DELETED.
REMUN:	PUSH P,B
	HRRZ W1,SYMTOP	;IF IT'S THE LAST THING IN SYMTAB SPACE,
	CAIN W1,2(B)
	JRST REMUN1	;THERE'S NOTHING ABOVE IT TO BLT DOWN.
	HRLI B,2(B)	;ELSE BLT ALL ABOVE IT DOWN BY 2.
	BLT B,-2(W1)
REMUN1:	POP P,B
	SUBI B,2
	PUSH P,A
	MOVE A,UNDEFL(U)
	ADD A,[2,,]	;UNDEFL STARTS IN SAME PLACE BUT 1 LESS ENTRY.
	MOVNI D,2	;CHANGE IN SIZE IS -2.
	PUSHJ P,RELOC	;RELOCATE ALL OBJECTS THAT WERE BLTED.
	SKIPL A		;IF UNDEFL IS NOW EMPTY,
	HRRZ A,SYMTOP	;MAKE IT BE AT TOP OF SPACE.
	MOVEM A,UNDEFL(U)
	JRST POPAJ

;UPDATE UNDEFINED SYMBOL REFS WHEN DEPOSITING IN LOCATION
;WHOSE ADDRESS IS IN A. CLOBBERS C,D,W1.
DEPRMV:	PUSH P,B
	SKIPL B,UNDEFL(U)
	JRST DEPRM1	;J IF NO UNDEF SYM REFS.
DEPRM0:	CAIE A,@1(B)	;ELSE REMOVE EACH UNDEF REF
	JRST DEPRM1	;FOR THE WORD BEING DEPOSITED IN.
	PUSHJ P,REMUN
DEPRM1:	AOBJN B,.+1
	AOBJN B,DEPRM0
DEPRM2:	SKIPN B,UNDFRP	;ANY UNDEFS IN QTY BEING DEPOSITED?
	JRST POPBJ	;J IF NONE.
	PUSH P,A
	MOVSI A,-2	;ELSE GET ROOM FOR 1 UNDEF REF.
	MOVEI W1,UNDEFL(U)
	PUSHJ P,HOLE0
	MOVE A,(P)	;GET BACK THE ADDRSS STORING IN.
	MOVE B,UNDFRP
	HLL A,UNDFRL-1(B)
	MOVEM A,1(C)	;STORE TYPE AND ADDRESS OF UNDEF.
	MOVE A,UNDFRL-2(B)
	MOVEM A,(C)	;STORE SYMBOLN NAME.
	POP P,A
	SUBI B,2	;REMOVE THE UNDEF SYM JUST HANDLED.
	MOVEM B,UNDFRP
	JRST DEPRM2	;LOOK FOR ANY MORE UNDEF SYMS.

OPLK2:	MOVE D,OPLK1
	MOVEI W1,SYM
	MOVE A,[(440700)TXT]
	PUSHJ P,.SPT
OPLK1:	IDPB D,A

;OPDECODER

OPEVAL:	MOVEM P,SAVPDL
	TRZA F,OUTPUT
OPTYPE:	TRO F,OUTPUT
	LSH D,-27.
	MOVEM D,INST
	MOVE D,[(440700)TXT]
	MOVEM D,CHP
	SETZB A,W1
	MOVE W2,BTAB
DC1:	ILDB D,W2
	CAILE D,40
	CAIL D,73
	SOJGE A,DC1
	JUMPG A,DC1
	SUBI D,40
	JUMPE D,DECX
	JUMPG D,DC2
	DPB D,[(340500)PNTR]
	TRZ D,-4
	AOS D
	DPB D,[(300600)PNTR]
	TRNN F,OUTPUT
	JRST DC6
	LDB A,PNTR
	JRST DC1
DC2:	HRREI D,-33(D)
	JUMPL D,DECT
	MOVE W1,D
	IDIVI W1,4
	MOVE W2,BTAB(W2)
	ADDI W2,(W1)
	JRST DC1

DECT:	TRNE F,OUTPUT
	JRST O1CZ
	ILDB W1,CHP
	CAIE W1,133(D)
	JRST LOSE
	JRST DC1

DECX:	TRNE F,OUTPUT
	POPJ P,
	ILDB W1,CHP
	JUMPE W1,DC7
LOSE:	POP P,A
	POP P,W2
	POP P,PNTR
	POP P,CHP
LOSE1:	AOS A
	DPB A,PNTR
	LDB A,PNTR
	JUMPN A,DC6AA
	CAME P,SAVPDL
	JRST LOSE
	JUMPL U,CPOPJ
	SKIPE SYSSW
	 POPJ P,
	MOVE A,JOBSYM(U)
	PUSHJ P,SLUP	;SEARCH EVERY BLOCK.
	 2,,SEVLB
	 POPJ P,	;NOT FOUND.
	MOVE D,1(A)	;GET THE VALUE.
	SETZM FNYLOC
	SKIPE HAKING	;OMIT THE REST IN .BREAK 12, .
	JRST CPOPJ1
	PUSH P,A
	PUSH P,D
	EXCH A,B
	PUSHJ P,[PUSH P,[SLUPR] ? JRST SEVLB2]
	 2,,SEVLB	;KEEP ON SEARCHING.
	JRST LOSE3	;UNIQUE.
	CTYPE ""
LOSE2:	MOVE A,-1(P)
LOSE5:	SUB A,[2,,2]	;SYM WAS FOUND IN.
	MOVE W1,(A)
	TLNE W1,PNAME
	JRST LOSE5
	MOVEM A,PRGM(U)	;BLOCK THAT SYM WAS FOUND IN.
	MOVE W1,A
	PUSHJ P,SPT	;PRINT PRGM OR BLOCK'S NAME.
	7TYPE [ASCIZ/$:/]
POPDA1:	POP P,D
POPAJ1:	POP P,A
CPOPJ1: POPJ1: AOS (P)
CPOPJ:	POPJ P,

LOSE3:	CTYPE "'
	JRST LOSE2

DC6:	MOVEI A,0
	DPB A,PNTR
DC6AA:	CAMN P,SAVPDL
	JRST DC6BB
	LDB D,-2(P)
	CAME D,(P)
	JRST LOSE1
DC6BB:	PUSH P,CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,A
	JRST DC1

DC7:	MOVE P,SAVPDL
	MOVE D,INST
	LSH D,27.
POPJ2:
CPOPJ2:	AOS (P)
	JRST CPOPJ1

O1CZ:	MOVEI D,133(D)
	PUSHJ P,TOUT
	JRST DC1

;********************************************************

TBL:
.BYTE 9

DEFINE HACK A
IRPS B,D,[A]
Z="D
IFE Z-":,Y!B==.BYTC
IFE Z-"/, Y!B+73
IFE Z-"^, <B&70>_-1+B&7-1
IFE <Z-40>*<Z-15>,[
IRPC Q,,B
Z="Q
IFE Z-".,Z=100
Z-40
TERMIN
]
TERMIN
TERMIN


;INITIAL DISPATCH
	HACK [63^. FLO/ HAK/ ACCP/ BOOLE/ H HWT/ T ACBM/ . ]

;BYTE AND FLOATING INST
	HACK [FLO: 33^ ... BYTE/ FAD A/ FSB A/ FMP A/ FDV A:
	21^ LMB/ R 02^ LMB/ I/ LMB/ LMB: 02^ . L:L. M:M. B:B. BYTE: 03^ UF PA/ DF N/ 
	FS C/ IB P: P. I LD/ LD: LD B/ I DP/ DP: DP B/]

;FWT, FIXED POINT ARITH, MISC.
	HACK [HAK: 33^ MV/ MV: MOV MO/ ML/ DV/ SH/ H1/ JP/
	21^ ADD IMB/ SU BIMB: B IMB: 02^ . I:I. M/ B/ MO: 22^
	EIMS: E IMS/ S IMS/ N IMS/ M IMS: 02^ . I/ M/ S: S. 
	ML: 21^ I ML1/ ML1: MUL IMB/ DV: 21^ I DV1/ DV1:
	DI DV2: V IMB/ H1: 03^ EXC S3/ BL T: T. AO/ AO: AOBJ
	AOB/ JRS T/ JFC L/ XC T/ . AOB: 01^ P/ N/
	JP: 03^ PU/ PU: PUSH PUS/ PO/ PO: POP POP/ JSR. 
	JS P/ JS PA: A. JR PA/ PUS: 01^  J: J.. POP:
	01^ . J/  SH: 02^ A S2/ ROT S1/ L S2: S S3: H S1/ 21^ JFFO. CIR C/ 
	S1: 21^ . C: C. ]

;ARITH COMP, SKIP, JUMP
	HACK [ACCP: 42^ CA CA1/ SJ/ A JS/ S JS: O 31^
	J COMP/ S COMP/ CA1: 31^ I COMP/ M COMP/
	 SJ: 31^ JUM PSJ/ SKI PSJ: P COMP:
	03^ . L/ E: E. L E/ PA/ G E/ N: N. G. ]

;BOOLEAN
	HACK [BOOLE: 24^ ST/ AN: AND B2/ AN/ ST/ AN/ ST/
	X OR: OR B2/ I OR/ AN/ EQ DV2/ ST/ OR/ ST/ OR/ OR/
	ST: SET B2: 24^ Z IMB/ IMB/ CA: C TA/ TM: M IMB/
	CM: C TM/ TA: A IMB/ IMB/ IMB/ CB: C BIMB/ IMB/ CA/
	CA/ CM/ CM/ CB/ O IMB/ ]

;HALF WORDS
	HACK [HWT: 51^ HW1/ 21^ R HW2/ L HW2: R HW3/ HW1:
	21^ L HW4/ R HW4: L HW3: 32^ IMS/ Z IMS/ O IMS/
	EIMS/ ]

;TEST INST
	HACK [ACBM: 31^ AC1/ 01^ D AC2/ S AC2/ AC1: 01^ R AC2/ L 
	AC2: 42^ N EAN/ Z EAN/ C EAN/ O EAN: 12^ . E/ PA/ N/ ]

.BYTE


;EVAL SYM WITH NAME IN D.
;RETURN ADDR OF STE IN A, VALUE IN D.
;CLOBBERS LOTS OF ACS.
SEVLD:	MOVEM D,SYM
SEVL:	JUMPL U,SEVL1	;NO JOB => JUST INITIAL SYM TABS.
	SKIPE SYSSW
	 JRST SEVLS	;SYS JOB SPECIAL.
	MOVE A,PRGM(U)
	PUSHJ P,SLUP	;SEARCH CURRENT BLOCK AND CONTAINING.
	 0,,SEVLB
SEVL1:	SKIPA B,[-STBIOL,,STBIO]	;NOT FOUND, TRY ORDINARY INITIAL SYMS.
	 JRST SEVLW	;FOUND, SLUP SKIPPED 2.
	PUSHJ P,SEVLB1
	 SKIPA B,STBSO	;TRY SYSTEM DEFAULT ORDINARY SYMS.
	JRST SEVLW	;FOUND IN ORDINARY INITAIL SYMS.
	PUSHJ P,SEVLB1
	 SKIPA B,[-STBIFL,,STBIF] ;TRY INITIAL FUNNY SYMS.
	JRST SEVLW
	PUSHJ P,SEVLB1
	 SKIPA B,STBSF	;TRY SYSTEM DEFAULT FUNNY SYMS.
	JRST SEVLF
	PUSHJ P,SEVLB1
	 POPJ P,	;FOUND NOWHERE.
SEVLF:	MOVE D,1(A)	;GET VALUE (FUNNINESS IN LH)
	TLNN D,7^5	;ALL BITS OFF => 4.8 IS DEFAULT.
	 TLO D,2^5
	TLNE D,1^5	;4.7 => REL. TO U.
	 JUMPL U,CPOPJ
	TLZE D,1^5
	 ADDI D,(U)
	MOVEM D,FNYLOC	;REMEMBER FUNNYNESS,
	ANDI D,-1	;BUT REMOVE FROM VALUE.
	JRST POPJ1

SEVLS:	MOVE B,SYSAOB	;GET AOBJN -> SYS SYMA.
	SUBI B,772000-SYSSYM
	PUSHJ P,SEVLB1	;SYS SYM TAB JUST SYMS, NO BLOCKS.
	 JRST SEVL1
SEVLW:	MOVE D,1(A)	;FOUND ORDINARY SYMBOL.
	SETZM FNYLOC
	JRST POPJ1

;SEARCH ONE BLOCK.
SEVLB:	MOVE B,A
	HLL B,1(B)
SEVLB2:	ADD B,[2,,2]
SEVLB1:	JUMPGE B,CPOPJ
	MOVE D,(B)
	TLZ D,PNAME
	CAME D,SYM
	 JRST SEVLB2
	MOVE D,(B)
	TLNE D,DELI	;IGNORE IF DELETED.
	 JRST SEVLB2
	EXCH A,B
	JRST POPJ1
;PUSHJ P,SLUP ? FLAG,,RTN     WITH SYMTAB TAIL -> BLOCK HEADER IN A.
;FLAG=0 => CALL FOR EACH GOOD BLOCK, =1 => FOR EACH BAD BLOCK,
;=2 => FOR EACH BLOCK.
;THE GOOD BLOCKS ARE THE CURRENT BLOCK AND ALL CONTAINING BLOCKS.
;AN AOBJN -> TAIL OF SYMTAB STARTING AT BLOCK HEADER WILL BE
;IN B WHEN RTN IS CALLED (WITH A PUSHJ).
;IF RTN SKIPS, SLUP WILL GIVE UP AND SKIP 2.
;OTHERWISE, SLUP WILL RETURN SKIPPING 1 AT END OF SYMTAB.

SLUP0:	HRRZ C,@(P)	;GET ADR OF RTN, CALL IT.
	PUSHJ P,(C)
SLUPR:	CAIA
	JRST POPJ2	;IF RTN SKIPPED, SO DO WE.
SLUP1:	HLRE B,1(A)
	MOVNI B,(B)
	HRLI B,(B)	;THIS PUTS IN A AN AOBJN ->
	ADD A,B		;SYMTAB TAIL -> NEXT BLOCK.
SLUP3:	JUMPGE A,POPJ1	;NO MORE BLOCKS.
	HLRZ C,@(P)	;GET FLAG (0, 1, OR 2)
	HRRZ B,1(A)	;NEXT BLOCK'S LEVEL.
	CAMN A,PRGM(U)
	 JRST SLUP2	;CURRENT BLOCK ALWAYS GOOD.
	CAIN B,1	;OTHER PROGRAMS & INNER BLOCKS NEVER GOOD.
	 JRST [MOVEI W2,1 ? JRST @SLUPF(C)]
	CAIN B,2	;OUTERMOST BLOCK OF GOOD PROGRAM IS GOOD.
	 JUMPL W2,SLUP2
	CAIL B,(W2)	;SOMETHING AT LOWER LEVEL IS GOOD.
	 JRST @SLUPF(C)
SLUP2:	MOVEI W2,(B)	;W2 HAS LEVEL OF LAST GOOD BLOCK.
	CAIN W2,1	;IF THIS IS PROGRAM NAME,
	JRST [HLRZ B,1(A)	;IF NO SYMBOLS IN IT,
		CAIE B,-2
		 JRST .+1
		HRRZ B,3(A)	;IF THAT'S DUE TO BLOCK STRUCTURE,
		CAIL B,2
		SETO W2,	;NEXT GOOD BLOCK IS OUTERMOST IN PROGRAM.
		JRST .+1]
	JRST @SLUPT(C)	;THIS IS A GOOD BLOCK.

SLUPT:	SLUP0
SLUPF:	SLUP1
	SLUP0
	SLUP0

SLUP:	MOVEI W2,1
	JRST SLUP3

;LOOK FOR VALUE IN D. LEAVES D UNCHANGED.
;IF FIND SYMBOL WITH THAT VALUE, TYPE NAME & DON'T SKIP, W1 -> STE.
;ELSE SKIP, WITH STE ADDR OF BEST FOUND IN W1. (OR 0 IN W1 IF NONE FOUND)
;CLOBBERS A,B,C,I1
SLUK:	SETZ W1,	;NO BEST SO FAR YET.
	JUMPL U,POPJ1	;NO JOB => FAIL TO FIND IT.
	SKIPE SYSSW
	 JRST SLUKS	;SYS SYM TAB SPECIAL SINCE NOT SORTED.
	MOVE A,PRGM(U)	;LOOK AT "GOOD" BLOCKS.
	PUSHJ P,SLUP
	 0,,SLUKB9	;BINARY-SEARCH EACH BLOCK.
	 SKIPA A,JOBSYM(U)
	JRST SPT	;EXACT MATCH, TYPE NAME, RETURN.
	PUSH P,W1	;SAVE BEST OF GOOD BLOCKS.
	PUSHJ P,SLUP	;LOOK THRU BAD BLOCKS.
	 1,,SLUKB9
	 JRST PW1J1
	JRST SPTPA	;EXACT MATCH, TYPE IT (FLUSH W1 FROM STACK, TOO)
PW1J1:	POP P,W1	;DON'T USE SYM FROM BAD BLOCK UNLESS EXACT.
	JRST POPJ1

SLUKS:	MOVE B,SYSAOB	;GET SYS SYM TAB PTR.
	SUBI B,772000-SYSSYM
SLUKS1:	MOVSI C,4^5	;VALUE OF BEST SO FAR IS SMALLEST NUMBER.
SLUKS4:	CAML D,1(B)	;IF THIS SYM'S VALUE TOO HIGH
	CAMLE C,1(B)	;OR WORSE THAN BEST SO FAR, MOVE ON.
	 AOBJN B,SLUKS2	 ;(WILL ALWAYS JUMP SINCE LENGTH IS EVEN)
	MOVE A,(B)	;ELSE GET ITS NAME,
	TLNE A,PNAME
	TLNE A,DELO+DELI
	 AOBJN B,SLUKS2	;IGNORE DELETED SYMS & BLOCK HEADERS.
	PUSHJ P,SLUKS3	;UPDATE BEST SO FAR, SKIP IF EXACT.
	 AOBJN B,SLUKS2	;NOT EXACT, KEEP GOING (SLUKS3 SET C)
	JRST SPT
SLUKS2:	AOBJN B,SLUKS4
	JRST POPJ1

SLUKB9:	MOVE B,A	;A HAS SYMTAB TAIL,
	HLL B,1(A)	;PUT AOBJN -> BLOCK'S SYMS IN B.
	ADD B,[2,,2]

;BINARY SEARCH IN AREA <- AOBJN IN B
;FOR VALUE IN D.
SLUKB:	AOJGE B,CPOPJ	;QUIT IF EMPTY; B -> 2ND WD OF STE.
	HLRE C,B
	HRLI B,C	;B IS INDEX OF C.
	MOVNS I1,C
;B -> INSIDE AREA, IDX OF C.
;C = SIZE OF LAST STEP.
;I1 = # WDS LEFT IN PART OF AREA AFTER B.
SLUKB0:	CAILE C,(I1)	;C_MAX(LAST STEP,SPACE LEFT)
	 MOVEI C,(I1)
	CAIN C,2	;ONLY 1 ENTRY TO SEARCH THRU => DONE.
	 SOJA B,SLUKB1	 ;(UNDO EFFECT OF AOJGE AT SLUKB)
	LSH C,-1	;STEP = .5* SIZE OF STUFF TO SEARCH.
	TRZE C,1	;ROUND UP TO EVEN NUMBER.
	 ADDI C,2
	CAMGE D,@B	;E.A. IS RH(B)+STEP.
	 JRST SLUKB0	 ;THAT'S TOO FAR, DON'T MOVE B.
	HRRI B,@B	;NOT TOO FAR, SET PTR THERE.
	SUBI I1,(C)	;WE'RE CLOSER TO END NOW.
	JRST SLUKB0

SLUKB2:	SUBI B,2
SLUKB1:	MOVE C,(B)	;FOUND THAT VALUE,
	TLNE C,DELI+DELO
	 JRST SLUKB2	;MOVE BACK TILL SYM THAT'S OK TO USE.
	CAML D,1(B)	;(MAYBE ALL SYMS IN BLOCK ARE TOO LARGE)
	TLNN C,PNAME
	 POPJ P,	;REACHED HEADER => NO SYM THIS BLOCK.
SLUKS3:	MOVE C,1(B)	;GET THAT SYM'S VALUE.
	CAIE W1,	;NO PREVIOUS BEST OR
	CAMLE C,1(W1)	;BETTER THAN PREVIOUS BEST =>
	 MOVEI W1,(B)	 ;IT IS BEST.
	CAMN C,D
	 AOS (P)	;EXACT MATCH, STOP SEARCHING.
	POPJ P,

;TYPE ARG IN D SYMBOLICALLY. ($$S MODE)
;CLOBBERS JUST ABOUT ALL ACS.
PIN:	TLNN D,-1	;JUST AN ADDRESS =>
	 JRST PAD	 ;PRINT AS SUCH.
	PUSH P,D
	TLC D,7^5
	TLCN D,7^5
	 JRST PINIO	;I-O INSN (MAYBE)
	SKIPE SYSSW
	 JRST PININI	;AVOID EXCESS SEARCHING OF SYS SYM TAB.
	PUSHJ P,SLUK
	 JRST POPDJ	;FOUND SYMBOL WITH EXACTLY RIGHT VALUE.
	TLNN D,777^3
	 JRST HLFWPD	;(OP CODE IS 0)
	MOVSI I2,-3	;TRY LOOKING FOR USER-DEF OP CODES.
PIN0:	JUMPE W1,PININI	;(CAN GIVE UP FAST)
	MOVE D,(P)
	AND D,PINTB0(I2) ;LOOK FOR SOME PART OF VALUE.
	CAMLE D,1(W1)	;IF LARGEST < PREV. SEARCHED (WHICH WAS
	 JRST PIN1	 ;LARGER) IS TOO SMALL, WON'T FIND THIS.
	CAMN D,1(W1)	;MAYBE LAST TIME'S BEST IS WHAT WE WANT.
	 JRST PINUUO
	PUSHJ P,SLUK
	 JRST PINUU1	;FOUND USER INSN NAME.
PIN1:	AOBJN I2,PIN0
PININI:	MOVSI D,777000
	AND D,(P)	;GET OP-CODE FIELD ONLY.
	HLRZ A,D
	CAIL A,4^4
	CAIL A,5^4
	CAIA
	 JRST PINMON	;THIS IS A SYSTEM CALL.
	SKIPN SYSSW
	 JRST PIN4
	CAIN A,102000
	 JRST PINLPM
	CAIN A,103000	;IF SYS, CHECK FOR LPM, XCTR.
	 JRST PINXCR
PIN4:	CAIE A,257000
	CAIGE A,(UFA)
	 JRST HLFWPD	;NOT AN INSTRUCTION.
	PUSHJ P,OPTYPE	;PRINT THE INSN NAME.
	JRST PININS	;GO PRINT THE REST.

PINTB0:	777740,,	;FIRST TRY OPCODE & AC FIELD.
	777037,,-1	;THEN OPCODE & ADDRESS STUFF.
	777000,,	;THEN JUST OPCODE.

;VALUE IS A SYSTEM CALL.
PINMON:	CAIN A,(.CALL)	;IF A .CALL, INCLUDE AC FIELD.
	 JRST [MOVSI D,777740 ? JRST PINCAL]
	CAIE A,(.OPER)	;IF .OPER, INCLUDE ADDRESSING STUFF.
	 JRST PINMO1	 ;OTHER SYSTEM CALLS, D HAS JUST OPCODE
	HRLOI D,777037
PINCAL:	AND D,(P)
PINMO1:	SETZ W1,
	MOVE B,STBSO	;SEARCH SYSTEM ORDINARY SYMS
	PUSHJ P,SLUKB	;FOR NAME OF SYSTEM CALL.
	 CAIA
	JRST PINUUO	 ;FOUND, TYPE IT AND THE REST.
	MOVSI D,777000	;.CALL OR .OPER WITH NO SPECIAL NAME,
	JRST PINCAL	;PRINT AS ".OPER ETC" OR ".CALL ETC".

PINLPM:	SKIPA W1,[[SQUOZE 0,LPM ? 102000,,]]
PINXCR:	MOVEI W1,[SQUOZE 0,XCTR ? 103000,,]
PINUUO:	PUSHJ P,SPT	;PRINT INSN'S NAME.
PINUU1:	SKIPA A,1(W1)	;A_ THOSE BITS THAT INSN TOOK CARE OF.
PININS:	MOVSI A,777000	;(ASSUME THEY WERE OPCODE FIELD)
	ANDCA A,(P)	;GET WHAT'S LEFT TO HANDLE.
	JUMPE A,POPDJ
	PUSH P,A
	PUSHJ P,TSPC	;SPACE AFTER INSN NAME.
	LDB D,[270400,,A]
	JUMPE D,PIN2
	PUSHJ P,PAD	;AC FIELD >0, PRINT IT AND COMMA.
PINIO1:	CTYPE ",
PIN2:	MOVE D,(P)
	TLZ D,777757	;HAVE IND. BIT AND ADDR FIELD.
	TLZE D,(@)
	 CTYPE "@	;TYPE @ IF INDIRECT.
	JUMPE D,PIN3	;PRINT ADDR IF NOT 0.
	TRO F,NAF	;ADDR FIELD MAY BE NEGATIVE.
	LDB A,[331100,,-1(P)]
	PUSHJ P,[CAIN A,JFFO_-33
		JRST PAD	;PRINT ADDR IN CURRENT MODE
		CAIL A,240
		CAILE A,247	;BUT IF SHIFT INSN,
		JRST PAD
		JRST PADA0]	;PRINT NUMERICALLY.
	TRZ F,NAF
PIN3:	LDB D,[220400,,(P)]
	JUMPE D,POPADJ	;PRINT INDEX FIELD IF NOT 0.
	CTYPE "(
	SAVE N2ACCS	;$$^C SHOULDN'T SEE SYMS IN INDEX FIELD.
	PUSHJ P,PAD
	REST N2ACCS
	CTYPE ")
POPADJ:	POP P,A		;(NOTE THIS ISN'T WHAT A HAD AT CALL)
	JRST POPDJ

;PRINT WHAT MIGHT BE AN IO INSTRUCTION.
PINIO:	JUMPL U,PINIO4	;NO JOB => SIMPLE TEST.
	SKIPGE JOBSYM(U) ;SAME IF NO SYMS OR SYS JOB.
	SKIPE SYSSW
	 JRST PINIO4
	MOVE D,UJNAME(U)
	CAME D,[SIXBIT/PDP10/]
	CAMN D,[SIXBIT/PDP6/]
	 JRST PINIO4	;PDP6 => IO INSNS OK.
	LDB D,[360300,,(P)]
	ADDI D,1	;1ST DIGIT OF DEV NAME, AS SQUOZE.
	IMULI D,50
	LDB A,[330300,,(P)]
	ADDI D,1(A)	;PUT IN 2ND DIGIT.
	IMULI D,50
	LDB A,[320100,,(P)]
	LSH A,2		;GET THE LOW DIGIT.
	ADDI D,1(A)
	ADD D,[SQUOZE 0,..D] ;HAVE SQUOZE 0,..D!DEV
	PUSHJ P,SEVLD
	 JRST PINNEG	;NOT DEF, DON'T PRINT AS IO INSN.
PINIO3:	LDB D,[270300,,(P)]
	LSH D,1		;WHICH IO INSN IS IT?
	MOVEI W1,PINIO9(D)
	PUSHJ P,SPT	;PRINT INSN NAME.
	PUSHJ P,TSPC
	MOVSI D,77400
	AND D,(P)	;GET DEVICE CODE.
	JUMPE D,PINIO5	;DEVICE 0, DON'T PRINT SYMBOLICALLY.
	PUSHJ P,SLUK
	 JRST PINIO2	;HAVE SYMBOL FOR IT.
	MOVE B,[-STBIOL,,STBIO]
	PUSHJ P,SLUKS1	;LOOK FOR TTY,PTR,PI,DIS ETC.
	 JRST PINIO2	;FOUND ONE.
PINIO5:	LSH D,-30
	PUSHJ P,TOC	;ELSE TYPE IN OCTAL.
PINIO2:	PUSH P,(P)
	JRST PINIO1

PINIO4:	CAMGE D,[BLKI 740,] ;OLD SIMPLE TEST, PRINT AS IO INSN
	 JRST PINIO3	 ;UNLESS LH IS SMALL NEGATIVE NUMBER.
PINNEG:	HLRZ D,(P)	;NOT TO PRINT AS IO INSN; HALFWORD OR NEG. NUMBER.
	CAIE D,-1
	 JRST HLFWPD	;TOO LARGE FOR SMALL NEG NUM.
	POP P,D
	ANDI D,-1
	JRST PADA1	;GO TYPE "-", NEGATE AND PRINT RH.

;PRINT ARG (IN D) IN HALFWORD MODE.
HLFW:	PUSH P,D
HLFWPD:	TRO F,NAF
	HLRZ D,(P)
	PUSHJ P,PAD
	7TYPE [ASCIZ /,,/]
	TRO F,NAF
	REST D
	ANDI D,-1	;NOW PRINT THE RH.
	JRST PAD
;PRINT AN ADDRESS IN CURRENT MODE.
;NAF ON => IF NUMERIC, OK TO PRINT WITH MINUS SIGN.  ALWAYS TURNS NAF OFF.
PAD:	MOVE I2,F	;SAVE NAF AND TURN IT OFF.
	TRZ F,NAF
	TLNE D,-1
	 JRST PADF	;ADDR. IS FUNNY.
PAD1:	SKIPE AR
	JRST @AR	;PADR OR TOC
	MOVEI A,PADR
	MOVEM A,AR ? ERLOSS

PADR:	JUMPE D,TOC2FK	;$R ADDRESS TYPEOUT RTN.
	PUSHJ P,SLUK
	 POPJ P,	;EXACT MATCH FOUND.
	JUMPE W1,PADA	;NOTHING FOUND => NUMERICALLY.
	MOVE B,1(W1)	;VALUE OF BEST.
	CAIGE D,100(B)	;TOO FAR AWAY OR
	CAIGE B,60	;SYM'S VALUE SMALL => DON'T USE.
	 JRST PADA
PADR1:	SUB D,1(W1)	;ADDR-<BEST FOUND>
	PUSH P,D
	PUSHJ P,SPT	;PRINT BEST SYM FOUND.
	POP P,D
	CTYPE "+
	JRST TOC

PADA:	TRNE I2,NAF	;USUALLY TYPE IN OCTAL,
PADA0:	CAIGE D,-4000	;UNLESS NAF WAS SET AND VALUE IS SMALL NEGATIVE NUM.
	 JRST TOC
PADA1:	CTYPE "-	;IN THAT CASE, PRINT A NEGATIVE NUMBER.
	XORI D,-1	;NEGATE D'S RH.
	AOJA D,TOC

PADF:	TLNE D,177777	;ADDR. IS FUNNY, ONLY TOP 2 FUNNYNESS BITS OK.
	 ERLOSS D	;(WILL PUSH A, THEN D)
	TLNN D,200000	;IF .USET NUMBER,
	 JRST PADF1
PADF0:	TLZE D,400000	;IF DDT-REF, HANDLE THAT SIMPLY.
	 7TYPE [ASCIZ/..DDT+/]
	TLNN D,-1
	 JRST PADA	;IF THAT WAS ONLY FUNNYNESS, THE REST IS NORMAL ADDR.
PADF1:	SETZ W1,	;SLUKB WILL NEED THIS.
	TLZE D,200000
	 JRST PADU	;.USET REF => SEARCH SYSTEM FUNNY SYMS.
	MOVE B,[-STBIFL,,STBIF] ;ELSE INITIAL FUNNY SYMSFOR DDT REF.
	MOVEI A,(D)
	JUMPL U,PADD1	;NO JOB => CAN'T PRINT AS U-REL SYM.
	CAIG A,JOBSYM(U)	;ELSE SEE IF IN RANGE FOR U-REL SYM.
	CAIGE A,USRS(U)
	 JRST PADD1
	SUBI D,(U)	;YES, GET OFFSET.
	TLOA D,100000	;LOOK FOR A SYM WITH U-REL SET.
PADU:	MOVE B,STBSF
	PUSHJ P,SLUKB
	 JRST PADR1	;NOT EXACT => PRINT AS SYM+OFFSET.
	JRST SPT

PADD1:	PUSHJ P,SLUKB	;LOOK FOR NON-U-REL DDT REF.
	 JRST PADF0	;NOT EXACT => PRINT AS ..DDT+ADDR.
	JRST SPT
SATP:	MOVEI C,44
	DPB C,[360600,,SATPP]
	MOVE C,SATPC
	MOVEM D,SATPT
SATPL:	ILDB D,SATPP
	PUSHJ P,TOC
	PUSHJ P,TSPC
	SOJG C,SATPL
	POPJ P,

;FLOATING POINT OUTPUT

TFLOT:	MOVE A,D
NFLOT:	JUMPG A,TFL1
	JUMPE A,FP1A
	MOVNS A
	CTYPE "-
	TLZE A,400000
	JRST FP1A

TFL1:	MOVEI B,0
	TLNN A,400
	CTYPE "#	;NOT NORMALIZED
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:
FP3:	SETZB C,TEM1	;CLEAR DIGIT CNTR, C TO RECEIVE FRACTION
	MULI A,400
	ASHC B,-243(A)
	MOVE A,B
	PUSHJ P,FP7
	CTYPE ".
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE D,W1
	MULI D,12
	PUSHJ P,FP7B
	SKIPE W1
	AOJL A,FP3A
	POPJ P,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ADDI W2,1(W2)
	XCT FCP(B)
	SOSA W2
	FMPR A,@FCP+1(B)
	AOJN C,FP4A
	PUSH P,EXPSGN(B)
	PUSHJ P,FP3
	MOVEI D,"E
	PUSHJ P,TOUT
	POP P,D
	PUSHJ P,TOUT
	MOVE A,W2

FP7:	SKIPE A	;AVOID AOSING TEM1, NOT SIGNIFICANT DIGIT
	AOS TEM1
	IDIVI A,12
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7

FP7A1:	HLRZ D,(P)
FP7B:	ADDI D,"0
	JRST TOUT

	1.0^32.
	1.0^16.
FT8:	1.0^8
	1.0^4
	1.0^2
	1.0^1
FT:	1.0^0
	1.0^-32.
	1.0^-16.
	1.0^-8
	1.0^-4
	1.0^-2
FT01:	1.0^-1
FT0=FT01+1

FCP:	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	0, FT0(C)

EXPSGN:	"-
	"+

G9PNT:	SKIPA W1,[10.]	;DECIMAL TYPEOUT.
G8PNT:	MOVEI W1,8	;OCTAL.
	CAIA

FTOC:		;CURRENT RADIX TYPEOUT.
TOC:	HRRZ W1,ODF
	MOVEM W1,TOCTEM
	CAIN W1,12
	JRST TOC4
TOCA:	LSHC D,-43
	LSH W1,-1	;W1=D+1
TOC1:	DIVI D,@TOCTEM
	HRLM W1,0(P)
	JUMPE D,TOC2
	PUSHJ P,TOCA
TOC2:	HLRZ D,0(P)
TOC2FK:	ADDI D,"0
CJTOUT:	JRST TOUT	;DOES POPJ TO TOC2 OR EXIT

TOC4:	MOVM W1,D
	JUMPGE D,TOC5
	CTYPE "-
TOC5:	MOVEI D,0
	PUSHJ P,TOC1
	MOVEI D,".
	JRST TOUT

SPTPA:	POP P,A
SPT:	MOVE D,CJTOUT
	SAVE (W1)	;LEAVE NAME OF SYMBOL FOR $$^C.
	REST N2ACCS
.SPT:	MOVEM D,SPTS
	MOVE D,0(W1)	;SYMBOL PRINT
	TLZ D,740000
SPT1:	SAVE W1
SPT3:	IDIV D,[50*50*50*50*50]
	PUSHJ P,SPT2
	MOVE D,W1
	IMULI D,50
	JUMPN D,SPT3
	JRST POPW1J

SPT2:	ADDI D,260-1
	CAILE D,271
	ADDI D,301-272
	CAILE D,332
	SUBI D,334-244
	CAIN D,243
	MOVEI D,256
	XCT SPTS
	POPJ P,

PURIFY:	SKIPE SYSSTB
	 .VALUE		;HAS BEEN RUN OR IS PURE.
	JRST PURIF1

INITF:	SIXBIT /   DSK/
	SIXBIT /.DDT./
	SIXBIT /(INIT)/

TYIF:	(SIXBIT /TTY/)

TYOF:	1,,(SIXBIT /TTY/)

CONSTANTS

;4.9=>TERMINATE GET VAL
;4.8=>INHIBITE EVAL
;4.7=>FIELD TERM.
;4.6=>POP INTO A,B
;4.5=>POP INTO C,D
;4.4=>EXECUTE
;4.2-3=>PRECEDENCE=>NUMERIC OPER
;4.1=>EXECUTE DURING EVAL
;3.9=>CALL PLUNK1
;3.8=>EVARGS
;3.7=>ERROR IF INFERIOR PROCEDURE NOT OPEN (SEE 3.2)
;3.6=>IF 4.5 ON CALL NBITE
;3.5=>IF 4,5&3.6 ON CALL NGDEV
;3.4=>  < OR >
;3.3=>NORMAL GET VAL TERMINATE
;3.2 IF 3.7, HACTRN^K OK TOO.
;1.1-2.9=ROUTINE

;ZERO ALT MODES
OPTAB0:	0	;^@
	0
	250000,,GSNLRT	;^B
	250000,,NCTLC
	210000,,NCTLD
	250000,,GSNLRT	;^E
	270060,,NCTLF
	250000,,NXERR	;^G?
	270040,,CTLK	;^H
	450600,,NTAB
	450600,,NNL
	270040,,CTLK
	0		;^L
	450604,,NCART
	50300,,NCTLN
	250000,,NCTLO
	250100,,NCTLP
	450600,,NUPA	;^Q
	0	;^R
	270040,,NCTLS
	270142,,NCTLT
	270142,,NCTLU
	250000,,GSNLRT	;^V
	250000,,GSNLRT	;^W
	250100,,NCTLX
	50200,,NCTLY
	250000,,NXERR	;^Z?
	450600,,APAT	;^\
	450600,,AEPAT	;^]
	50300,,NCUPA	;^^
	0	;^_
	100000,,1	;SP
	4000,,NSLASH	;!
	50200,,NDQ
	6000,,NSIGN
	REPEAT 2,0	;$, %
	6000,,NAMAND
	50200,,NPRM
	1000,,NLPARN
	1000,,NRPARN
	4000,,NSTAR
	2000,,NPLUS
	100000,,2	;,
	2000,,NMINUS
	0		;.
	450200,,NSEMIC	;/
	270000,,NCOL
	50200,,NCTLXC
	1010,,NLANGB
	50200,,NEQL
	401014,,NRANGB
	201000,,EFLD2	;?
	1000,,ATSIGN
	REPEAT 26.,0	;A, B, ..., Z
	450200,,NLBRAK
	450600,,NBKSL
	450200,,NRBRAK
	450600,,NUPA
	50200,,NLFTA

;ONE ALT MODE
OPTAB1:	0	;$^@
	0
	250000,,GSNLRT	;$^B
	0
	210000,,NCTLD
	250000,,GSNLRT	;$^E
	270060,,NCTLF	;$^F
	250000,,NXERR	;$^G?
	0	;$^H
	450600,,NTAB
	450600,,NNL
	270040,,CTLK
	0	;$^L
	450600,,NCART
	50300,,NACN	;$^N
	270000,,NCTLO
	0	;$^P
	450600,,NUPA	;$^Q
	0	;$^R
	270040,,NACS
	270040,,NCTLT
	270040,,NCTLU
	250000,,GSNLRT	;$^V
	250000,,GSNLRT	;$^W
	50000,,NACX
	50200,,NCTLY
	250000,,NXERR	;$^Z?
	0	;$^\
	450600,,AEPAT	;$^]
	270340,,NACUPA	;$^^
	0		;$^_
	100000,,3	;$SP
	4000,,FSLASH	;$!
	50000,,ALTDQ
	50000,,ALTNM	;$#
	REPEAT 2,0	;$$, $%
	50000,,ALTAMP
	50000,,ALTPRM
REPEAT 2,250000,,GSNLRT;$(, $)
	4000,,FSTAR
	2000,,FPLUS
	100000,,4	;$,
	2000,,FMINUS
	1000,,NALT.
	450200,,NSEMIC	;$/
	270000,,NCOL
	50200,,NACXC
	250000,,ALTLES
	50200,,FEQL	;$=
	50200,,ALTGRT
	REPEAT 2,0	;$?, $@
	250000,,NALTA
	50300,,NALTB
	250000,,NALTC
	250000,,NALTD
	50200,,NALTE
	250000,,NALTF
	450300,,NALTG
	250000,,NALTH
	50300,,NALTI
	270040,,NALTJ
	270102,,NALTK
	270160,,NALTL
	50200,,NALTM
	50200,,NALTN
	250000,,NALTO
	450300,,NALTP
	1000,,NALTQ
	250000,,NALTR
	250000,,NALTS
	250000,,NALTT
	670040,,NALTU
	0	;$V
	50200,,NALTW
	50200,,NALTX
	50200,,NALTY
	0	;$Z
	450200,,NLBRAK
	450600,,NBKSL
	450200,,NRBRAK
	450600,,NUPA
	6000,,NSHIFT	;$_

;TWO ALT MODES
OPTAB2:	0 ? 0
	250000,,GSNLRT	;$$^B
	250000,,N2ACC
	210000,,NCTLD
	250000,,GSNLRT	;$$^E
	50200,,N2ACF
	250000,,NXERR	;$$^G?
	0
	450600,,NTAB	;$$TAB
	0
	50100,,DISOWN	;$$^K
	0
	50102,,N2ACM	;$$^M
	50300,,N2ACN
	270000,,NCTLO
	REPEAT 2,0
	50200,,NACR
	270040,,NACS
	270142,,NCTLT
	270142,,NCTLU
	250000,,GSNLRT	;$$^V
	250000,,GSNLRT	;$$^W
	50000,,NACX
	50300,,N2ACY
	250000,,NXERR	;$$^Z?
	0
	650000,,AUPAT	;$$^]
	270040,,N2ACUP	;$$^^
	0		;$$^_
	0
	450200,,A2XCL
	50000,,ALTDQ
	50000,,ALTNM
	REPEAT 2,0
	50000,,ALTAMP
	50000,,ALTPRM
	REPEAT 7,0
	450200,,NSEMIC	;$$/
	270000,,NCOL	;$$:
	50200,,N2ACXC
	650000,,A2LES
	50200,,ALTEQ
	REPEAT 3,0
	250000,,NALTA
	50300,,NALTB
	250000,,NALTC
	250000,,NALTD
	0
	250000,,NALTF
	450300,,NALTG
	250000,,NALTH
	0
	270040,,N2AJ
	270102,,NALTK
	270160,,NALTL
	0 ? 0
	250000,,NALTO
	450300,,NALTP
	1000,,NALTQ
	250000,,NALTR
	250000,,NALTS
	250000,,NALTT
	450000,,LOGOUT	;$$U
	50000,,ULIST	;$$V
	0 ? 0
	50200,,NALTY
	50300,,N2ALTZ
	450200,,NLBRAK	;$$[
	450600,,NBKSL	;$$\
	450200,,NRBRAK	;$$]
	0	;$$^
	6000,,NFSC	;$$_

;ORDINIARY INITIAL SYMS.
STBIO:
   PINIO9==STBIO+10	;USED BY PINIO TO FIND NAMES OF IO INSNS
IRP A,,[CLEAR,CLEARI,CLEARM,CLEARB,BLKI,DATAI,BLKO,DATAO,CONO,CONI,CONSZ,CONSO,$X]
	SQUOZE 44,A
	A
TERMIN
IRP A,,[TTY,DIS,LPT,PI,PTP,PTR]
	SQUOZE 4,A
	A_<8*3>
TERMIN
STBIOL==.-STBIO

;INITIAL FUNNY SYMS.
STBIF:	SQUOZE 4,..DDT
	400000,,
	SQUOZE 4,..LINE
	SETZ TYOLSZ
	SQUOZE 4,$M
	SETZ MSK

;THESE LOCATIONS MUST BE IN ASCENDING ORDER IN DDT
;OR TYPEOUT WILL FAIL!
	FOO==MSK
IRPS X,,UNPURF MSTYPE DOZTIM LPTFLG TTYFLG
IF2 IFL X-FOO,.ERR FUNNY SYMS OUT OF ORDER
IF2 FOO==X
	SQUOZE 4,..!X
	SETZ X
TERMIN
		;U-RELATIVE INITIAL SYMS. (NUMERICAL ORDER)
	UIWD==UINTWD
IRP X,,[UFUSR,UUNAME,UJNAME,INTBIT,UINT,UPIRQ,PPC,XECPC,UIWD
XINTWD,JTIME,UIND,NBPTB,BPCPC,CBPPS,INCNT,OIPCHK
USCNT,USTYPE,BTADR,BTPDL,BTINS,BPINFL]
	SQUOZE 4,..!X
	500000,,X
TERMIN

IRPC X,,12345678
	$!X!B=B1ADR+BPL*.IRPCN
	SQUOZE 4,$!X!B
	500000,,$!X!B
TERMIN

IRP X,,[STARTA,PERMIT,PATCHL,UFNAMD,UFILE,UHACK
UIACK,UCHBUF,UNDEFL,PRGM,JOBSYM]
	SQUOZE 4,..!X
	500000,,X
TERMIN
STBIFL==.-STBIF

PAT: PATCH: BLOCK 100

INFORM [TOP OF PURE]\.-1
.=<.+1777>/2000*2000
NPUR==<.+1>/2000	;PURE PAGE HACK

;^B, :WALLP FILE.
WFILE:	1,,(SIXBIT /LPT/)
	SIXBIT /WALL  PAPER/
	0?0		;SNAME GOES HERE

;:XFILE FILE.
XFILEF:	SIXBIT/   DSK.DDT. (INIT)/
	0?0

;^K FILE.
SFILE:	6,,(SIXBIT/DSK/)
	SIXBIT/TS/
SYSN2:	0?0?0

;:PRMAIL FILES.
MAILF:	SIXBIT /  "COM/
RUNAME:	-1		;REAL USER NAME
	SIXBIT /MAIL/
RUNM1:	-1
	SIXBIT /OMAIL/

OMAILF:	SIXBIT /   COM/
RUNM2:	-1
	SIXBIT /OMAIL/
	0

OTMLFL:	SIXBIT /  "COM/
	0
	SIXBIT /MAIL/

;^F, :LISTF FILE.
FFILE:	2,,(SIXBIT/DSK/)
	SIXBIT /.FILE.(DIR)/
	0?0

;:PRINT FILE.
PFILE:	SIXBIT /  "DSK/
PFILE1:	-1
	SIXBIT /MAIL/
	0?0

GETTY:	0	;NONZERO IF GRAPHICS TTY.
TYGTYP:	0
TRMNAM:	0	;TERMINAL NAME(SIXBIT), READ AT LOGIN IF REMOTE TTY.
TTYLIN:	0	;TTY NUMBER, IF DIAL-UP LINE.
ITSNAM:	0	;NAME OF THIS MACHINE (AI OR ML)
SILNT:	0	;-1 IF TYPEOUT SUPPRESSED BY ^S.
LPTOPN:	0	;NONZERO IFF WALLPAPER FILE IS OPEN.
LPTFLG:	0	;0 IF WALLPAPER FILE OUTPUT ON,
		;AOS'D BY ^E, SOS'D OR ZEROED BY ^E,
		;IRRELEVANT IF LPTFLG HOLDS 0.
TTYFLG:	0	;0 IF TTY ON (SOS'D OR ZEROED BY ^V, AOS'D BY ^W)

LOADF:	0		;-1 AT IOC ERROR ==> ERROR ON LOADING
IOCF:	0
	0
	0
	.
	SIXBIT /FOOBAZ/
	0


I40:	0	;TSINT USER'S SYS UUO.
IPC:	0	;TSINT USER'S PC.
INTING:	0	;-1 IF AT INT LEVEL.
INTIOP:	0	;-1 IF TSIN3 HAS PUSHED USR CHNLS.
HAKIOP:	0	;-1 IF HAKKAH HAS PUSHED USR CHNLS.
TSUSRF:	'USR	;USED TO OPEN USR CHNLS IF THEY'VE BEEN PUSHED.
TUNAME:	0
TJNAME:	0
DDINT:	0	;-1 IF SOME USER WANTS TO RETURN TO DDT.
HAKRQ:	0	;-1 => THERE IS WORK FOR HAKKAH TO DO (.BREAK 12'S OR CLI INT)
HAKING:	0	;-1 => HAKKAH IN PROGRESS, PREVENTS RECURSIVE HAKKAH.
HAKCRQ:	0	;-1 => A CLI INT AWAITS PROCESSING.
VALCOM:	0	;IF NOT 0, HAS ADDR OF VALRET STRING WHICH CAN BE HANDLED IMMEDIATELY.

MARCON:	0	;3.3 3.1 => STOP ON +,-,WRITE ONLY

MAXUSET:	0	;MAX USET ALLOWED, SET AT INITIALIZATION
STBSO:	0	;AOBJN -> SYSTEM ORDINARY DEFAULT SYMS (IN STBSPG)
STBSF:	0	;AOBJN -> SYSTEM FUNNY DEFAULT SYMS
SYMTOP:	DDTEND	;-> AFTER ALL SYMBOLS.
STBDDT:	STBDE	;PURIF3 MAKES THIS -> DDT SYMBOL TABLE.
RELCP1:	0	;NONZERO => ADDR OF PTR INTO SYMTAB SPACE (TO RELOCATE IF NEC)
TEM2:	0
FNYLOC:	0	;FUNNYNESS OF SYMS EVALLED ACCUMULATES HERE,
UNDFRP:	0	;INDEX OF LAST USED IN UNDFRL.
UNDFRL:	BLOCK UNDFRS	;HOLDS 2 UNDEF SYM REFS IN ARGS EVALLD.

4BLK:	0	;1ST WD OF 1ST 4BLK.
REPEAT 4BLKNM,[
	0?0?0	;LAST 3 WDS OF 4BLK.
	.-4	;START OF NEXT 4BLK (LAST TIME THROUGH, FREE LIST PTR)
]
4BLKF=.-1	;FREE 4BLK LIST PTR.

GTPNTR:	0	;THESE 3 WDS USED BY $<
GTFTEM:	0
GTMALT:	0
	;FIRST 4 MUST BE IN ORDER
;USED FOR READING SYLS, CLEARED ON RUBOUT.
GSONUM:	0	;OCTAL NUMBER
GSDNUM:	0	;DECIMAL NUMBER
GSFNUM:	0	;FLOATING
GSSSYM:	0	;SQUOZE
GSENUM:	0	;NUMBER OF ALTMODES
GSFNUC:	0

RFLFN1:	0	;DEFAULT FN1, FN2 SAVED FOR ^X, ^Y BY RFL.
RFLFN2:	0

GSOCRT:	0	;GO THERE ON READING RUBOUT.
GSOCPP:	0	;RESTORE P ON RUBOUT.
GSOCRP:	0	;RESTORE GSCHRP ON RUBOUT.
GSOPDP:	0	;RESTORE GSOCRT, GSOCPP FROM THESE 2 WDS
GSORET:	0	;IF RUB BACK PAST GSOCRP .
GSCHRP:	010700,,GSCHRS-1
GSCHRQ:	0
GSCHRS:	BLOCK GSCLNG+1	;+1 FOR RUB OUT HACK

SYM:	0	;ARGUMENT TO EVAL
SYM1:	0
FLDSTR:	0
FLDTBP:	DDTEND	;AOBJN -> FROB TABLE (IN SYMTAB SPACE)

ARG1:	BLOCK NARGS*2	;ARGS PUT HERE BY EVARGS, 2 WDS PER.
VALUE:	BLOCK 2
PVALUE:	0
ABCNT:	0
FLDTRM:	0
STATE:	0	;WORD ASSEMBLY FROM FIELDS STATE
PSTATE:	0	;PAREN/ANG BRAKET STATE
NBITET:	0

LWT:	BLOCK 2		;$Q KEPT HERE (A SYLLABLE)
LWTP:	LWTTAB		;$Q RING BUFFER POINTER
LWTTAB:	BLOCK 2*LWTLNG	;$Q RING BUFFER, EACH ELT. IS A 2-WD SYLLABLE.
LLOC:	0		;VALUE OF POINT. LH HAS FUNNYNESS.
LLOCO:	0		;LAST LOCATION OPENED.   "   .
PLCR:	0		;POINT RING BUFFER POINTER (IDX IN LOCBF)
LOCBF:	BLOCK NLEVS	;POINT RING BUFFER, LH OF EACH WD A FUNNYNESS.

PLUNKF:	0	;PLUNK1 SAVES F HERE FOR AEPAT.

	VARIAB

DDTEND:	INFORM [HIGHEST USED]\.-1
DDT2:	MOVE P,[(-LPDL)PS] ;DDT STARTS HERE..
	.CLOSE 3,	;CHANNEL USED BY RANDOM LOADER
	SETZB F,UCHNLO	;INDICATE NO USER CHANNEL OPEN
	MOVE U,CU	;NO JOB.
	SKIPN SYSSTB	;IF DON'D HAVE SYS SYM TAB,
	JSP W1,PURIF3	;GET IT.
	SKIPE DEBUGP	;IF DEBUGGING, DON'T CATCH ILLOPR, IOCERR.
	SKIPA A,[200202,,727106]
	MOVE A,[200202,,727766]
	HRROI B,1_<TYIC>+1_<COMC>
	.SETM2 A,	;SET INTERRUPT MASKS
	MOVNI D,1
	.UPISET D,	;ENABLE INTERRUPTS
	PUSHJ P,IOCOP1	;OPEN TTY.
	PUSHJ P,%RESET
	.SUSET [.RUNAME,,UNAME]	;GET UNAME AND SALT AWAY
	PUSHJ P,DDTUNM
	PUSHJ P,FORMF	;CLEAR SCREEN IF GE CONSOLE

	MOVSI I1,-2	;DO WHAT FOLLOWS FOR STBSO, THEN STBSF.
DDT1:	MOVE D,[SQUOZE 0,SYSYMB ? SQUOZE 0,SYSUSB](I1)
	.EVAL D,	;GET ABS. ADDR OF START OF TABLE,
	 ERLOSS
	MOVE C,[SQUOZE 0,SYSYME ? SQUOZE 0,SYSUSE](I1)
	.EVAL C,	;GET ADDR OF LAST WD.
	 ERLOSS
	SUBM D,C	;1-LENGTH OF TABLE.
	HRLI D,-1(C)	;AOBJN -> TABLE.
	MOVEM D,STBSO(I1)
	AOBJN I1,DDT1
	MOVE A,STBSO	;THE ORDINARY SYMS COME FIRST.
	LDB D,[121000,,A] ;GET # OF ABS PAGE THE START IN.
	MOVE C,[-2,,STBSPG] ;GET THAT PAGE & NEXT INTO STBSPG AND NEXT.
	STDCAL CORBLK,[1000,,2^5 ? 1000,,-1 ? C ? 1000,,4^5 ? D]
	MOVEI D,STBSPG
	DPB D,[121000,,A] ;A HAS ADDR IN DDT'S ADDR. SPACE.
	SUBM A,STBSO	;STBSO HAS AMT TO RELOCATE BY.
	EXCH A,STBSO
	ADDB A,STBSF	;RELOCATE STBSF AS WELL.
	HLRE B,A
	SUB A,B		;A -> AFTER LAST SYSTEM FUNNY SYM.
DDT0:	MOVE B,-1(A)
	CAIL B,100	;MOVE BACK TO LAST ONE WITH VALUE < 100 .
	 SOJA A,[SOJA A,DDT0]
	MOVEM B,MAXUSET	;SAY ALL CODES BETWEEN THAT AND 100 ILLEGAL.
	PUSHJ P,VERSI1	;PRINT VERSION NOS., THEN SYSTEM STATUS.
	PUSHJ P,SSTAT1
	PUSHJ P,CRF
	PUSHJ P,FDRCOP
	[SIXBIT /  "SYSSYSTEMMAIL/]	;SEE IF THERE IS ANY SYSTEM MAIL
	 CAIA
	PUSHJ P,CTLF1	;YES, TYPE IT OUT
	MOVE A,TYGTYP
	TRNE A,2^5	;NOT PSEUDO-TTY =>
	 JRST DD1B
	PUSHJ P,FDRCOP	;PRINT LOCAL MAIL ALSO.
	[SIXBIT /  "SYSLOCAL MAIL/]
	 CAIA
	PUSHJ P,CTLF1
	JRST DD1B

PURIF1:	.VALUE [ASCIZ \B ..BTAD/0
P\]
	MOVEI A,MINPUR+MINPUR_9+400000
PURIF2:	.CBLK A,	;PURIFY DDR
	.VALUE
	ADDI A,1001
	CAIE A,400000+NPUR_9+NPUR
	JRST PURIF2
	JSP W1,PURIF3	;GET SYS SYM TAB ABS PGS.
	SETZM DEBUGP
	MOVEI 1,STBDDT
	.VALUE [ASCIZ \K1/QSTBDDT::PURIFIED
\]
	JRST DDT

PURIF3:	MOVE A,[1000,,400375+SYSSYM_-1]
PURIF4:	.CBLK A,	;INSERT SYS SYM TAB AS ABS PGS
	.VALUE
	LDB B,[1000,,A]
	SUBI A,1001
	LDB C,[121000,,SYSSYM+1776]
	CAMGE B,C
	TRZ A,400000	;DELETE THOSE PGS NOT NEEDED.
	TRNE A,377000	;DON'T DELETE PAGE 0.
	JRST PURIF4
	.VALUE [ASCIZ /STBDDT  P/]	;STORE SYMTAB IN DDT.
	LDB A,[121000,,STBDDT]	;SEE WHAT PAGE SYMS START IN.
	HRLOI B,7-STBDE/2000(A)
	EQVI B,STBDE/2000-10	;AOBJN -> PAGES NOT USED.
	STDCL CORBLK,[1000,, ? 1000,,-1 ? B]
	 .VALUE
	HRLI A,-STBDE/2000(A)
	STDCL CORBLK,[1000,,2^5 ? 1000,,-1 ? A]
	 .VALUE		; ^ PURIFY THE ONES USED.
	SETOM SYSSTB
	JRST (W1)

CONSTA
INFORM [TOP OF PURIFY]\.-1

END DDT
