
NETDEB==1	;NETWORK DEBUG SWITCH
BBNTB==1	;1 => BBN STILL HASN'T FIXED TIP BUG
IMPVRS==.IFNM2

;CONI BITS
		;1.1-1.3 => PIA
IMPID==10	;INPUT DONE
IMPI32==20	;INPUT IN 32 BIT MODE
IMPIB==40	;INPUT BUSY
IMPOD==100	;OUTPUT DONE
IMPO32==200	;OUTPUT IN 32 BIT MODE
IMPOB==400	;OUTPUT BUSY
IMPERR==1000	;IMP ERROR
IMPR==2000	;IMP READY
IMPIC==4000	;IMP INTERRUPT CONDITION (0 = ERROR, 1= READY)
IMPHER==10000	;HOST ERROR
IMPHR==20000	;HOST READY
IMPIHE==40000	;INTERRUPT INHIBITED ON HOST ERROR
IMPLW==100000	;LAST IMP WORD

;CONO BITS
		;1.1=1.3 => PIA
IMPIDC==10	;CLEAR INPUT DONE
IMI32S==20	;SET INPUT TO 32 BIT MODE
IMI32C==40	;CLEAR INPUT IN 32 BIT MODE
IMPODC==100	;CLEAR OUTPUT DONE
IMO32S==200	;SET OUTPUT TO 32 BIT MODE
IMO32C==400	;CLEAR OUTPUT IN 32 BIT MODE
IMPODS==1000	;SET OUTPUT DONE
IMPIR==4000	;ENABLE INTERRUPT ON IMP READY
IMPHEC==10000	;CLEAR HOST ERROR
IMIIHE==40000	;INHIBIT INTERRUPT ON HOST ERROR
IMPLHW==200000	;SET LAST HOST WORD

;RESERVED SOCKET NUMBERS (196. - 225.)

;196.-199.	ML AND AI DEVICES
;224.-225.	MAGTAPE HACK

NETOJ1==UTCOJ1
IMPSTL==NNETCH	;SOCKET TABLE LENGTH (MUST BE .LE. 70)

EBLK

IMPI:	0	;-1 => IMPCHN INPUT INTERRUPT OCCURRED
IMPO:	0	;-1 => IMPCHN OUTPUT INTERRUPT OCCURRED
IMPB:	0	;-1 => IMPCHN FLAG INTERRUPT OCCURRED
IMPIH:	0	;-1 => INPUT WANTS PIA = IMPCHN
IMPOH:	0	;-1 => OUTPUT WANTS PIA = IMPCHN
IMPIS:	0	;INPUT STATE
		;0 => NOT EXPECTING INPUT
		;1 => IGNORE INPUT UNTIL END OF CURRENT MESSAGE
		;2 => EXPECTING SECOND WORD OF MESSAGE HEADER
		;3 => END OF CONTROL MESSAGE
IMPOS:	0	;OUTPUT STATE
		;0 => NOT EXPECTING OUTPUT DONE
		;1 => OUTPUT SECOND WORD OF HEADER
		;2 => OUTPUT TEXT OF CONTROL MESSAGE
		;3 => OUTPUT LAST WORD OF CONTROL MESSAGE
		;4, 5, 6 => SAME AS ABOVE THREE EXCEPT FOR MAIN PROGRAM
IMPHI:	0	;-1 TO HOLD UP INPUT
		;-2 INPUT IS SUCCESSFULLY HELD UP
IMPHST:	BLOCK 22.	;STATUS OF ALL HOSTS.  3 BITS PER ENTRY
		;0 => NO INFORMATION (DOWN)
		;1 => RST SENT
		;2 => UP
IMHSRF:	BLOCK 8	;RFNM STATUS OF HOSTS CONTROL LINKS
		;0 => LINK OPEN
		;1 => RFNM WAIT
IMHSRT:	BLOCK 100	;TIME LAST CONTROL LINK MESSAGE SENT FOR EACH HOST
IMRFTT:	331100,,IMHSRT(B)
	221100,,IMHSRT(B)
	111100,,IMHSRT(B)
	001100,,IMHSRT(B)
IMNCS:	0	;NUMBER OF CHANNELS BEING CLOSED
LIMPN==.-1
IMHSBT:	REPEAT 12.,<410300,,IMPHST(TT)>-<3*.RPCNT>_30.
IMPUP:	-1	;0 => IMP UP  ;-1 => DOWN  ;1 => DOWN FOR GOOD
IMPPIA:	0	;CURRENT IMP PIA
IMPCNI:	0	;CONI INTO HERE AT SLOW CLOCK LEVEL
IMNOPC:	0	;< 0 => SEND NOPS
IMPA:	0		;TEMP
IMPIGE:	0	;-1 TO IGNORE NEXT ERROR FROM IMP
IMPOAC:	-1	;-1 => OUTPUT INACTIVE
IMPNN:	0	;NUMBER OF INPUT NOPS
IMPNUN:	0	;NUMBER OF MESSAGE WITH UNASSIGNED MESSAGE TYPE
IMPNPE:	0	;NUMBER OF PROTOCOL ERRORS
IMPER1:	0	;NUMBER OF MESSAGES OF TYPE 1
IMPER2:	0	;NUMBER OF MESSAGES OF TYPE 8
IMPIWD:	0	;WORD TO DATAI INTO
IMPINB:	BLOCK 30.+5	;30. WORDS @ 32 BITS/WD = 120. 8 BIT BYTES
			;+5 WORDS FOR GOOD MEASURE

IFN NETDEB,[
IMDINB:	BLOCK 200	;DEBUGGING INPUT BUFFER
IMDINP:	IMDINB
]

IMTBP:	340400,,IMPIWD	;BYTE POINTER FOR MESSAGE FIELD
IMSBP:	241000,,IMPIWD	;BYTE POINTER FOR SOURCE FIELD
IMLNBP:	141000,,IMPIWD	;BYTE POINTER FOR LINK NUMBER FIELD
IMPCSH:	0	;CURRENT SOURCE HOST
IMPCLN:	0	;CURRENT LINK NUMBER
IMCBBP:	301000,,IMPIWD	;BYTE POINTER FOR CONNECTION BYTE SIZE FIELD
IMBCBP:	102000,,IMPIWD	;BYTE POINTER FOR BYTE COUNT FIELD
IMPCBS:	0	;CURRENT BYTE SIZE
IMPCBC:	0	;CURRENT BYTE COUNT
IMPNIW:	0	;NUMBER OF INPUT WORDS EXPECTED
IMNWSI:	0	;NUMBER OF WORDS TO READ ON SECOND INPUT
IMPTMP:	0	;TEMP DURING DATA INPUT
IMPSVI:	0	;SAVED I DURING INPUT
IMPSVO:	0	;SAVED I DURING OUTPUT
IMBLKI:	0	;PLACE TO STORE BLKI POINTER
IMBLKO:	0	;PLACE TO STORE BLKO POINTER
IMNOSH:	0	;# OF SHUFFLES OF NET OUTPUT BUFFERS
IMNISH:	0	;# OF SHUFFLES OF NET IMPUT BUFFERS
IMPNEA:	0	;NUMBER OF ECOS IN COMMAND MESSAGE THAT HAVE BEEN ANSWERED
IMPNRA:	0	;NUMBER OF RSTS ANSWERED
IMPNEI:	0	;NUMBER OF ERPS NOT SENT
IMPNRI:	0	;NUMBER OF RRPS NOT SENT
IMNRFC:	0	;NUMBER OF RFCS CLSED
IMNRFI:	0	;NUMBER OF RFCS IGNORED
IMNCLI:	0	;NUMBER OF CLS IGNORED
IMNALI:	0	;NUMBER OF ALLS IGNORED
IMNPIL:	0	;NUMBER OF TIMES PI CONTROL QUEUE EXCEEDED
IMNCNS:	0	;NUMBER OF CLS NOT SENT
IMNANS:	0	;NUMBER OF ALLS NOT SENT
IMNMNC:	0	;NUMBER OF REGULAR MESSAGES FOR NON-EXISTANT CONNECTIONS
IMNSRF:	0	;NUMBER OF SPURIOUS RFNMS ON REG CONNECTIONS
IMNSRC:	0	;NUMBER OF SPURIOUS RFNMS ON CONTROL LINK
IMNBLL:	0	;NUMBER OF BLOCKED LINK MESSAGES
IMNRFN:	0	;NUMBER OF RFNMS NOT SENT
IMNMAE:	0	;NUMBER OF TIMES MSG ALL EXCEEDED
IMNMSS:	0	;NUMBER OF TIMES MSG SHORT
IMNBAE:	0	;NUMBER OF TIMES BIT ALL EXCEEDED
IMSTAS:	0	;STATUS OF INPUT AT TIME HELD UP
IMPNIH:	0	;NUMBER OF TIMES INPUT SUCCESSFULLY HELD UP
IMPRTO==30.*60.	;RESET TIME OUT
IMPCTO==10.*30.	;CLS TIME OUT
IMRFTO==5*30.	;RFNM WAIT TIME OUT
IMPBTO==30.*30.	;BUFFER TIME OUT
IMCT1:	0	;# TIMES AT IMPBKZ
IMCT2:	0	;# TIMES AT IMPIBZ
IMCT3:	0	;# TIMES AT IMPOBZ
IMPTOT:	NETRTO	;TIME OUT TABLE.  LIST OF TIME OUT ROUTINES
	NTRTO1
IMPTOL==.-IMPTOT

IMPMQS==12.	;MESSAGE QUEUE SIZE
;MAIN PROGRAM CONTROL MESSAGE VARIABLES
IMPMPU:	-1	;-1 => FREE
	0
IMPMPL:	-1	;LINK WORD FOR CONTROL LINK QUEUE
IMPMPC:	BLOCK IMPMQS	;FIRST WORD HAS LENGTH OF TEXT

;PI CONTROL MESSAGE VARIABLES
IMNPIC==4	;NUMBER OF BLOCKS IN PI CONTROL QUEUE
IMPCQ:	REPEAT IMNPIC-1,[
	.+IMPMQS+1	;POINTER TO NEXT FREE OR NEXT IN QUEUE
	BLOCK IMPMQS	;FIRST WORD HAS LENGTH OF TEXT
]
	-1
	BLOCK IMPMQS
IMPNCQ:	-1	;NEXT ENTRY TO BE SENT.  -1 IF NONE
IMPLCQ:	-1	;POINTER TO LAST ENTRY IN CONTROL QUEUE
IMFFCQ:	IMPCQ	;POINTER TO FIRST FREE.  -1 IF NONE
IMFCQL:	IMNPIC	;NUMBER FREE CONTROL QUEUE ENTRIES LEFT

;PENDING RFC QUEUE
IMNPQ==40	;NUMBER OF PENDING QUEUE ENTRIES
;(0)	POINTER TO NEXT IN CHAIN OR NEXT FREE.  -1 IF NONE
;(1)	LOCAL SOCKET NUMBER
;(2)	FOREIGN SOCKET NUMBER
;(3)	4.9 = 1 => RTS  = 0 => STR
;	1.1-1.8 = LINK NUMBER OR BYTE SIZE
;	1.9-2.7 = FOREIGN HOST NUMBER
IMPPQ:	REPEAT IMNPQ-1,[
	.+4
	BLOCK 3
]
	-1
	BLOCK 3
IMPBPQ:	-1	;BEGINNING OF PENDING QUEUE.  -1 IF EMPTY
IMPEPQ:	-1	;END OF PENDING QUEUE.  -1 IF EMPTY
IMFFPQ:	IMPPQ	;FIRST FREE PENDING QUEUE ENTRY.  -1 IF NONE

;CLOCK QUEUE
IMNCLQ==20	;NUMBER OF CLOCK QUEUE ENTRIES
IMPCLQ:	REPEAT IMNCLQ-1,[
	0
	.+3
	JRST 4,.
	0	;HOST NUMBER
]
	0
	-1
	JRST 4,.
	0
IMFCLQ:	IMPCLQ	;FIRST FREE CLOCK QUEUE ENTRY.  -1 IF NONE

IMMEST==28.	;SHIFT FOR MESSAGE TYPE FIELD (LEFT ADJ IN 36 BIT WORD)
IMDEST==20.	;SHIFT FOR DESTINATION FIELD

IMTNOP==4	;NOP IS MESSAGE TYPE 4
IMPNOP:	IMTNOP_IMMEST

;SOCKET TABLE

IMSOC1:	REPEAT IMPSTL,0		;0 => FREE
				;4.9 = 1 => SOCKET IN USE
				;4.8 = 1 => CHNL TRYING TO BE CLOSED
				;4.7 = 1 => HAVE BEGUN BUF NOT EMPTY TIME OUT
				;4.6 = 1 => HAVE BEGUN RRRFNM TIME OUT
				;3.1-3.4 => CHANNEL OPEN ON
				;RH = USER INDEX
IMSOC2:	BLOCK IMPSTL		;1.1-4.5 = LOCAL SOCKET NUMBER
				;4.6-4.9  0 (MAKES COMPARISONS EASIER)
IMSOC3:	BLOCK IMPSTL		;1.1-4.5 = FOREIGN SOCKET NUMBER
				;4.6-4.9 = 0
IMSOC4:	BLOCK IMPSTL		;RH = SOCKET STATE
				;3.1-3.8 = LINK NUMBER
				;3.9-4.7 = FOREIGN HOST NUMBER
				;4.9 = SEND THIS BUFFER NOW
IMSOC5:	BLOCK IMPSTL		;1.1-1.8 = CONNECTION BYTE SIZE
				;3.1-3.8 = USER BYTE SIZE
				;3.9 => ASCII MODE - 7 BIT
				;4.1 => ASCII MODE - 8 BIT
				;4.2 => 1 BIT BYTES
				;4.9 => TRANSFER IN 32 BIT MODE
IMSOC6:	BLOCK IMPSTL		;RH => BUFFER ADDRESS
				;4.9 => LOCKED BY CORE JOB
				;4.8 => ACTIVE AT PI LEVEL
				;4.7 => INPUT OCCURRED WHILE BUFFER LOCKED
				;3.1-3.8 => IOBFT INDEX
IMSOC7:	BLOCK IMPSTL		;BIT ALLOCATION IF SEND SOCKET
IMSOC8:	BLOCK IMPSTL		;MESSAGE ALLOCATION IF SEND SOCKET
IMSC7I:	BLOCK IMPSTL		;AMOUNT TO INCREASE BIT ALLOCATION BY
IMSC8I:	BLOCK IMPSTL		;AMOUNT TO INCREASE MESSAGE ALLOCATION BY
IMSCIP:	BLOCK IMPSTL		;INPUT BYTE POINTER OR LAST MESSAGE IN OUTPUT CHAIN
IMSCLS:	BLOCK IMPSTL		;CLS REASON
IMSOCT:	BLOCK IMPSTL		;TIME WHEN FIRST MESS PUT INTO BUF
		 ;(DURING INPUT HAS NUMBER OF BITS AVAIL)

;SOCKET STATES
; 0	CLS RECEIVED.  CONNECTION CLOSED (IMSCLS GIVES REASON)
; 1	LISTENING FOR RFC
; 2	RFC RECEIVED WHILE IN LISTENING STATE
; 3	CLS RECEIVED WHILE IN RFC RECEIVED STATE
; 4	RFC SENT
; 5	CONNECTION OPEN
; 6	RFNM WAIT ON WRITE LINK
; 7	CLS SENT.  WAITING FOR MATCHING CLS
;10	CLS RECEIVED BUT INPUT STILL AVAILABLE
;11	INPUT AVAILABLE

;CLS REASONS (IN IMSCLS)
; 0	NEVER OPENED
; 1	CLSED BY USER
; 2	CLSED BY FOREIGN HOST
; 3	RST
; 4	HOST DEAD
; 5	INCOMPLETE TRANSMISSION
; 6	BYTE SIZE MISMATCH.

BBLK

IMSCLN:	221000,,IMSOC4(I)	;RTS => LINK NUMBER
IMSCBS:	001000,,IMSOC5(I)	;STR => BYTE SIZE
IMSCUB:	221000,,IMSOC5(I)	;USER BYTE SIZE
IMSCFH:	321000,,IMSOC4(I)	;FOREIGN HOST
IMSCHD:	222000,,IMSOC4(I)	;FOREIGN HOST AND LINK NUMBER

SPSCTB:	1	;TABLE OF SPECIAL SOCKET NUMBERS
	3
	197.
NSPSOC==.-SPSCTB

SPSCT1:	NTSTBL
	NTFTPL
	NTMLBL
IFN .-SPSCT1-NSPSOC,PRINTX /BARF AT SPSCT1/

NTSTBL:	SIXBIT /STELNT/
EBLK
	0
BBLK
NTFTPL:	SIXBIT /FTP/
EBLK
	0
BBLK
NTMLBL:	SIXBIT /MLSLV/
EBLK
	0

NETUSW:	0	;-1 => ONLY ALLOW OURSELVES TO LOAD TELNETS
NETSRS==1000	;SMALLEST USER RECEIVE SOCKET NUMBER
NRSOC:	NETSRS	;NUMBER OF NEXT RECEIVE SOCKET TO BE GENERATED
NETOSW:	-1	;SWITCH LOCKED AT NET OPEN
	0
NETHSW:	-1	;SWITCH LOCKED IF HACKING HOST TABLE
	0
NETLST:	0	;LIST OF USERS IN NETWORK OPEN CODE

;INPUT BUFFER (RINGS BACK TO WD1)
;WD0	RH = NEXT MESSAGE IN (PI LEVEL)
;	LH = NEXT MESSAGE OUT (-1 IF NONE)
;WD1	MESSAGE 1 POINTER
;	LH = - # BITS REMAINING
;	RH = NEXT BIT # (0 => LEFTMOST BIT)
;MESSAGE 1

;OUTPUT BUFFER (RINGS BACK TO WD 1)
;WD0	RH = NEXT MESSAGE IN (MP LEVEL)
;	LH = NEXT MESSAGE OUT (-1 => NONE)
;WD1	MESSAGE 1 POINTER TO NEXT MESSAGE,,# WORDS (INCL. HEADER)
;MESSAGE 1

BBLK

IMPINI:	CONO IMP,IMI32C
	DATAI IMP,A
	CONO IMP,IMPODC	;CLEAR OUTPUT DONE AND PIA
	CONSZ IMP,IMPOD+7	;CHECK OUTPUT DONE, PIA, CAUSE HOST READY
	JRST 4,.	;CONO DIDN'T CLEAR SOME BITS
	CONO IMP,IMPIR+IMPHEC	;CLEAR HOST ERR, ENABLE INT ON IMP READY
	MOVE T,TIME
	ADDI T,15.
	CAMLE T,TIME
	PUSHJ P,UFLS	;WAIT FOR HALF SECOND
	CONO IMP,0	;CLEAR "ENABLE IMP READY" INT (TURNS OFF IMP ERROR)
	MOVEI A,NETCHN	;IDLE PIA
	MOVEM A,IMPPIA
	MOVE A,[JSR IMPIBK]
	MOVEM A,IMPILC
	MOVE A,[JSR IMPOBK]
	MOVEM A,IMPOLC
	MOVSI I,-IMPSTL
IMPINA:	SETZM IMSOC1(I)
	SETZM IMSOC6(I)
	AOBJN I,IMPINA
	SETZM IMPILC+1
	SETZM IMPOLC+1
	SETOM IMPOAC
	SETOM IMPIGE	;IGNORE NEXT ERROR FROM IMP
	SETOM IMPMPU
	SETOM IMPUP
	SETOM IMPMPL
	SETOM IMPNCQ
	SETOM IMPLCQ
	MOVEI I,IMNPIC
	MOVEM I,IMFCQL
	MOVEI A,IMPCQ
	MOVEM A,IMFFCQ
	JRST IMPIN1

IMPIN2:	ADDI A,IMPMQS+1
	MOVEM A,-IMPMQS-1(A)
IMPIN1:	SOJG I,IMPIN2
	SETOM (A)
	SETOM IMPBPQ
	SETOM IMPEPQ
	MOVEI A,IMPPQ
	MOVEM A,IMFFPQ
	MOVEI I,IMNPQ
	JRST IMPIN4

IMPIN3:	ADDI A,4
	MOVEM A,-4(A)
IMPIN4:	SOJG I,IMPIN3
	SETOM (A)
	MOVEI A,IMPCLQ
	MOVEM A,IMFCLQ
	MOVEI I,IMNCLQ
	MOVE T,[JRST 4,.]
IMPIN5:	ADDI A,4
	MOVEM A,-3(A)
	SETZM -4(A)
	MOVEM T,-2(A)
	SETZM -1(A)
	SOJG I,IMPIN5
	SETOM -3(A)
	MOVEI A,NETSRS
	MOVEM A,NRSOC
	MOVE A,[IMPI,,IMPO]
	SETZM IMPI
	BLT A,LIMPN
	SETOM IMPIS
	CONO IMP,NETCHN
	MOVE T,TIME
	ADDI T,15.
	CAMLE T,TIME
	PUSHJ P,UFLS
	SETZM IMPIS
	MOVNI A,4
	MOVEM A,IMNOPC	;SEND 4 NOPS
IMPOST:	CONO PI,NETOFF
	MOVE TT,IMPPIA	;MAIN PROGRAM OUTPUT START
	AOSN IMPOAC	;SKIP IF OUTPUT ALREADY ACTIVE
	CONO IMP,IMPODS(TT)	;GENERATE OUTPUT INTERRUPT
	JRST NETONJ

IMPIOS:	AOSE IMPOAC	;PI LEVEL OUTPUT START
	POPJ P,
	PUSH P,TT
	CONO PI,400	;TURN PI OFF, IMP MAY HAVE PIA = 1
	MOVE TT,IMPPIA
	CONO IMP,IMPODS(TT)
	CONO PI,200
	POP P,TT
	POPJ P,

NETRCH:	HRRE I,A
	JUMPL I,NETRC1
	MOVE A,IMSOC2(I)
	XCTR XW,[MOVEM A,1(J)]	;LOCAL SOCKET NUMBER
	MOVE A,IMSOC3(I)
	XCTR XW,[MOVEM A,2(J)]	;FOREIGN SOCKET NUMBER
	LDB A,IMSCFH
	XCTR XW,[MOVEM A,3(J)]	;FOREIGN HOST NUMBER
	HRRZ A,IMSOC4(I)
	XCTR XW,[MOVEM A,4(J)]	;STATE
	MOVE B,IMSCLS(I)
	XCTR XW,[MOVEM B,5(J)]	;CLS REASON OR BITS AVAIL
	MOVE A,IMSOCT(I)
	XCTR XW,[MOVEM A,6(J)]	;BITS AVAIL DURING INPUT
	JRST ARCHX

NETRC1:	XCTR XRW,[SETOM 4(J)]	;STATE = -1 => NET HAS GONE DOWN
	JRST ARCHX

;NETWORK OPEN

;	.OPEN CH,BLK
;	ERROR RETURN
;	NORMAL RETURN

;BLK:	MODE BITS,,(SIXBIT /NET/)
;	LOCAL SOCKET NUMBER (1.1-4.5)
;	FOREIGN SOCKET NUMBER (1.1-4.5)
;	FOREIGN HOST NUMBER (1.1-1.8)

;BLK:	3.1-3.3 => STANDARD ASCII/IMAGE, UNIT/BLOCK, INPUT/OUTPUT
;	3.4 = 1 => GENERATE UNIQUE LOCAL RECEIVE (SEND) SOCKET NUMBER
;	3.4 = 0 => USE LOCAL SOCKET NUMBER SPECIFIED IN BLK+1
;	3.5 => OPEN SOCKET IN LISTEN MODE
;	3.6 => IF IMAGE MODE, USE BYTE SIZE IN 4.1-4.6
;	       IF ASCII MODE, USE 8 BIT BYTES RATHER THAN 7
;	4.1-4.6 = BYTE SIZE IN IMAGE MODE

NETO:	SKIPN IMPUP
	JRST NETOUP
	SKIPL IMPUP
	JRST OPNL7	;DEVICE NOT READY
	MOVEI I,100000
	IORM I,SUPCOR	;HAVE SYS JOB BRING UP THE NETWORK
	PCLT
	SKIPE IMPUP
	PUSHJ P,UFLS	;WAIT FOR IMP TO BE UP
NETOUP:	TLZ A,740000
	TLZ B,740000
	MOVEI E,377
	ANDM E,SRN3(U)
	PUSHJ P,LSTSET
	NETLST
	TLNN C,20	;SKIP IF LISTEN
	JRST NETOR	;DO RESET STUFF
NETORT:	PUSHJ P,SWTL
	NETOSW
	TLNN C,20
	PUSHJ P,NETOW	;GOBBLE MP CONTROL LINK BLOCK
NETO10:	TLNN C,10
	JRST NETO1	;USE SOCKET NUMBER GIVEN IN WORD 2
	MOVE A,NRSOC	;UNIQUE RECEIVE SOCKET NUMBER
	SKIPGE D	;SKIP IF OPEN IS FOR READ (RECEIVE)
	IORI A,1	;MAKE INTO SEND SOCKET
	MOVSI I,-IMPSTL	;LOOK FOR FREE SOCKET TABLE SLOT
NETOZ:	SKIPE IMSOC1(I)	;SKIP IF FREE
	AOBJN I,NETOZ
	JUMPG I,OPNL6	;DEVICE FULL
	MOVEI E,10
	ADDM E,NRSOC
NETO6:	TLNN C,4	;SKIP IF IMAGE MODE
	JRST NETOC	;ASCII MODE
	MOVEI H,36.
	TLNN C,40	;SKIP IF BYTE SIZE SUPPLIED
	JRST NETOB
	LDB W,[330600,,C]	;USE USER SUPPLIED BYTE SIZE
	IDIVI W,36.	;H GETS BYTE SIZE MOD 36.
	JUMPN H,NETOB
	MOVEI H,36.	;36 BITS ANYWAY
NETOB:	CAIE H,32.
	CAIN H,8
	TLO H,402000	;SET 32 BIT TRANSFER MODE
	CAIN H,36.
	TLO H,2000
	TLC H,2000
NETOA:	DPB H,[222200,,IMSOC5(I)]
	MOVEM A,IMSOC2(I)	;LOCAL SOCKET NUMBER
	MOVEM B,IMSOC3(I)	;FOREIGN SOCKET NUMBER
NETREE:	SETZM IMSCLS(I)
	SETZM IMSOCT(I)	;# BITS AVAIL FOR INPUT
	MOVE W,SRN3(U)
	LSH W,26.	;FOREIGN HOST NUMBER
	HRRI W,4	;RFC SENT
	TLNE C,20	;3.5
	MOVEI W,1	;LISTENING
	MOVEM W,IMSOC4(I)
	SKIPE W,IMSOC6(I)
	JRST NETOE3
	PUSH P,A
	PUSH P,B
	PUSH P,D
	MOVEI D,NFNETC(I)
NETOE1:	PUSHJ P,TCALL	;LAST PLACE TO PCLSR (REALLY NETMW)
	JRST IUTCO1
	JRST NETMW	;NO MEM AVAIL
	LDB W,[IOSA,,IOBFT(A)]
	LSH W,6	;STARTING ADDRESS
	HRL W,A	;IOBFT INDEX
	MOVEM W,IMSOC6(I)
	POP P,D
	POP P,B
	POP P,A
NETOE3:	MOVE T,C	;GET 3.5 BIT OF C INTO
	LSH T,13.	;4.9 OF T
	HRROI Q,1
	MOVEM Q,(W)	;SET POINTER WORD TO -1,,1
	JUMPL D,NETOE5	;JUMP IF SENDER
	MOVSI Q,440100
	LDB H,IMSCUB
	MOVE E,IMSOC5(I)
	TLNN E,2000	;SKIP IF ONE BIT BYTES
	DPB H,[300600,,Q]
	HRRI Q,2(W)
	MOVEM Q,IMSCIP(I)
	MOVEI H,20.
	MOVEM H,IMSOC8(I)
	MOVEI H,2944.
	MOVEM H,IMSOC7(I)	;OUR VERSION OF HIS ALLOCATIONS
	SETZM IMSC8I(I)
	SETZM IMSC7I(I)
	MOVEI Q,2(I)	;LINK #
	DPB Q,IMSCLN	;STORE IN LINK # FIELD
NETOE6:	MOVE E,SRN3(U)	;FOREIGN HOST NUMBER
NETOE2:	PUSHJ P,IMPSPQ	;SEARCH PENDING QUEUE (LEAVES UTCOFF)
	JRST NETOG	;NOTHING THERE
	JUMPGE T,NETOH	;JUMP IF NOT LISTENING STATE
	MOVE W,2(Q)	;FOREIGN SOCKET NUMBER
	MOVEM W,IMSOC3(I)
	LDB W,[101000,,3(Q)]	;FOREIGN HOST NUMBER
	DPB W,IMSCFH
	MOVEI W,2
	HRRM W,IMSOC4(I)	;RFC RECEIVED STATE
NETOH2:	JUMPGE D,NETOD1	;JUMP IF RECEIVER
	SKIPL W,3(Q)	;SKIP IF RTS, GET LINK #
	JRST 4,.	;HE SENT STR
	DPB W,IMSCLN	;STORE LINK NUMBER
NETOD:	MOVE Q,UUAC(U)	;CHANNEL OPEN ON
	PUSHJ P,IMPUIM	;INTERRUPT SELF
NETOG:	MOVE W,U
	HRL W,UUAC(U)	;CHANNEL OPEN ON
	TLO W,400000	;IN USE
	MOVEM W,IMSOC1(I)
	CONO PI,UTCON
	TLNN C,20	;SKIP IF LISTENING TYPE SOCKET
	PUSHJ P,NETOS	;SEND RFC
	PUSHJ P,LSWPOP
	SKIPE (R)
	POPJ P,
	HRLZ A,I	;LEFT HALF OF IOCHNM GETS SOCKET INDEX
	HLRZS C
	PUSHJ P,LSWPOP	;REMOVE FROM LIST OF NETWORK OPENS IN PROGRESS
	JSP Q,OPSLC7
	NETDUI,,NETDUO
	NETDBI,,NETDBO
	NETDUI,,NETDUO
	NETDBI,,NETDBO

NETOR:	PUSHJ P,SWTL
	NETHSW
	MOVE TT,SRN3(U)	;FOREIGN HOST
	IDIVI TT,12.
	LDB J,IMHSBT(I)	;GET STATUS
	SOJG J,NETORS	;-1 => DOWN, 0 => RST SENT, 1 => UP
	MOVE T,IMHSBT(I)
	ADDI T,(TT)
	TLZ T,77
	PUSH P,T
	JUMPE J,NETOR1	;WAIT FOR REPLY
	PUSHJ P,NETOW	;WAIT FOR IMPMPC TO BE FREE
	MOVEI J,1
	DPB J,IMHSBT(I)	;MARK AS SENT
	MOVE W,SRN3(U)	;HOST
	LSH W,IMDEST	;LINK # = 0, MESSAGE TYPE = 0
	MOVEM W,IMPMPC+1
	MOVE W,[8_24.+1_8]	;BYTE SIZE = 8, BYTE COUNT = 1
	MOVEM W,IMPMPC+2
	MOVE W,[12._28.]	;RST
	MOVEM W,IMPMPC+3
	MOVEI W,1
	MOVEM W,IMPMPC	;MESSAGE LENGTH
	PUSHJ P,IMPMPQ	;SEND IT OUT
	PUSHJ P,LSWDEL	;IMPMPU WILL BE UNLOCKED ON THE PI LEVEL
NETOR1:	PUSHJ P,LSWPOP
	MOVE H,SRN3(U)	;FOREIGN HOST
	MOVEI T,NETRTO	;RESET TIME OUT
	CONO PI,CLKOFF	;SEARCH CLOCK QUEUE FOR THIS HOST
	PUSHJ P,NTSCL
	JRST NETOR3	;NOT THERE
NETOR4:	CONO PI,CLKON
	PCLT
	SKIPA T,(P)	;ALWAYS GO TO UFLS
	PUSHJ P,NETORW	;WAIT FOR RRP OR TIME OUT
	PUSHJ P,UFLS
	POP P,T
	LDB J,T	;GET STATUS
	SOJL J,OPNL20
	JUMPE J,NETOR	;TRY ALL THIS AGAIN
	JRST NETORT	;HOST UP

NETOR3:	PUSHJ P,NETGCL	;GET CLOCK QUEUE ENTRY IN J.  RET WITH CLKOFF
	MOVE T,SRN3(U)	;FOREIGN HOST
	MOVEM T,3(J)
	MOVE T,[JRST NETRTO]
	MOVEM T,2(J)
	MOVEI T,IMPRTO
	PUSHJ P,CLQADD	;TURNS CLKON
	(J)
	JRST NETOR4

NETORS:	PUSHJ P,LSWPOP
	JRST NETORT

NETOW:	CONO PI,CLKON
	PCLT
	SKIPL IMPMPU
	PUSHJ P,UFLS
	CONO PI,CLKOFF
	AOSE IMPMPU
	JRST NETOW
	SETOM IMPMPU	;CLKOFF, SO NO ONE CAN GOBBLE
	PUSHJ P,SWTL
	IMPMPU
	POPJ P,

NETO1:	MOVE J,A
	ROT J,-1	;J 4.9: 0 => RECEIVE  1 => SEND
	EQV J,D		;D 4.9: 0 => READ  1 => WRITE
	JUMPGE J,OPNL2	;WRONG DIRECTION
	CAIGE A,NETSRS	;SKIP IF NOT SPECIAL SOCKET
	JRST NETO7
	MOVE J,A
	TRZ J,7
NETO8:	MOVSI Q,-IMPSTL
	MOVEI E,0
	MOVNI I,1
NETO2:	SKIPN W,IMSOC1(Q)
	JRST NETO5	;NOT IN USE
	CAMN A,IMSOC2(Q)
	JRST NETO2A	;DUPLICATE LOCAL SOC #
	MOVE H,IMSOC2(Q)
	TRZ H,7
	CAMN J,H
	JRST NETO4	;JUMP IF PART OF SOCKET GROUP
NETO3:	AOBJN Q,NETO2
	JUMPL J,NETO9
	JUMPE E,OPNL11	;FOUND NEITHER
NETO9:	JUMPL I,OPNL6
	JRST NETO6

NETO2A:	TLNN W,200000	;SKIP IF BEING CLOSED
	JRST OPNL13	;NO, GIVE ERROR
	TLNN C,20
	PUSHJ P,LSWPOP
	PUSHJ P,LSWPOP
	MOVSI T,200000
	PCLT
	TDNE T,IMSOC1(Q)
	PUSHJ P,UFLS	;WAIT TILL CLOSED
	JRST NETORT

NETO4:	CAIE U,(W)
	JRST OPNL11	;SOMEONE ELSE HAS IT
	MOVNI E,1	;OK IF NO OTHER CONFLICTS
	JRST NETO3

NETO7:	MOVNI J,1
	JRST NETO8

NETO5:	HRRZ I,Q
	JRST NETO3

NETOC:	MOVEI H,400410	;7 BIT
	TLNE C,40
	MOVEI H,401010	;8 BIT
	JRST NETOA

NETMW:	PCLT
	PUSHJ P,NETMWT
	PUSHJ P,UFLS
	JRST NETOE1

NETMWT:	MOVE T,LMEMFR
	CAILE T,3
	AOS (P)
	POPJ P,

NETOE5:	LDB W,IMSCUB
	DPB W,IMSCBS	;SET CONNECTION BYTE SIZE
	SETZM IMSCIP(I)	;LAST MESSAGE IN PI CHAIN
	SETZM IMSOC7(I)	;INITIALIZE SENDER'S ALLOCATIONS
	SETZM IMSOC8(I)
	JRST NETOE6

NETOH:	AOS IMSOC4(I)	;PUT IN STATE 5 - OPEN
	JRST NETOH2

NETOD1:	SKIPGE H,3(Q)	;SKIP IF STR, GET BYTE SIZE
	JRST 4,.	;HE SENT RTS
	ANDI H,377
	DPB H,IMSCBS	;STORE CONNECTION BYTE SIZE
	PUSHJ P,IMCMBS	;LOSE IF BYTE SIZES DIFFER.
	 JRST OPNL22
	JRST NETOD

IMCMBS:	PUSH P,A
	PUSH P,B
	LDB A,IMSCBS
	LDB B,IMSCUB
	CAMN A,B
	AOS -2(P)	;BYTE SIZES ARE EQUAL.
	JRST POPBAJ

NETOS:	PUSHJ P,LSWDEL	;WILL BE UNLOCKED AT PI LEVEL
	MOVE J,SRN3(U)	;FOREIGN HOST NUMBER
	LSH J,IMDEST
	MOVEM J,IMPMPC+1	;LINK # 0, MESSAGE TYPE 0
	MOVE J,[8_24.+13._8]	;BYTE SIZE = 8, BYTE COUNT = 13.
	MOVEM J,IMPMPC+2
	MOVEI J,1_4	;3 NOPS + RTS
	SKIPGE D	;SKIP IF INPUT
	MOVEI J,2_4	;3 NOPS + STR
	MOVEM J,IMPMPC+3
	LSH A,4		;LOCAL SOCKET NUMBER
	MOVEM A,IMPMPC+4
	LSH B,4		;FOREIGN SOCKET NUMBER
	MOVEM B,IMPMPC+5
	MOVEI H,2(I)	;LINK NUMBER FOR RECEIVE SOCKET
	SKIPGE D
	LDB H,IMSCBS	;BYTE SIZE FOR SEND SOCKET
	LSH H,28.
	HRRZ J,IMSOC4(I)
	CAIE J,2
	CAIN J,5	;SKIP IF CONNECTION NOT YET OPEN
	JUMPGE D,NETOS2	;JUMP IF CONNECTION OPEN AND READ
	MOVEM H,IMPMPC+6
	MOVEI H,4	;TEXT LENGTH
NETOS3:	MOVEM H,IMPMPC
	JRST IMPMPQ

NETOS2:	MOVEI J,<4_8>+2(I)	;NOP + ALL + LINK #
	LSH J,4
	IOR H,J
	MOVEM H,IMPMPC+6
	MOVSI H,20._2
	MOVEM H,IMPMPC+7	;MESSAGE ALLOC = 20.
	MOVSI H,2944._2	;BIT ALLOC = 2944.
	MOVEM H,IMPMPC+10
	MOVE H,[8_24.+22._8]	;BYTE COUNT = 22.
	MOVEM H,IMPMPC+2
	MOVEI H,6	;MESSAGE LENGTH
	JRST NETOS3

;GET FREE CLOCK QUEUE ENTRY
NETGCL:	CONO PI,CLKOFF
	SKIPL J,IMFCLQ	;SKIP IF NO FREE CLOCK QUEUE SLOTS
	JRST NTGCL1
	CONO PI,CLKON
	PCLT
	SKIPG IMFCLQ
	PUSHJ P,UFLS
	CONO PI,CLKOFF
	JRST NETGCL

NTGCL1:	MOVE Q,1(J)
	MOVEM Q,IMFCLQ	;REMOVE FROM FREE LIST
	SETZM (J)
	SETOM 1(J)
	POPJ P,

NETORW:	LDB T,T
	CAIE T,1
	AOS (P)
	POPJ P,

;CLOCK QUEUE ENTRY TIMED OUT (U HAS ADDRESS OF BLOCK)
NETRTO:	MOVE TT,3(U)	;FOREIGN HOST NUMBER
	IDIVI TT,12.
	LDB J,IMHSBT(I)
	MOVEI T,0
	CAIN J,1
	DPB T,IMHSBT(I)	;TIME OUT AND NO RRP,  MARK AS DOWN
NTRTO1:	MOVE A,IMFCLQ
	MOVEM A,1(U)
	MOVEM U,IMFCLQ	;ADD TO FREE LIST
	MOVE A,[JRST 4,.]
	MOVEM A,2(U)
	JRST CLQRET

;.NETAC CH,	;ACCEPT CONNECTION
;ERROR RETURN
;NORMAL RETURN

ANETAC:	JSP T,NETCHK
	HRRZ T,IMSOC4(I)	;SOCKET STATE
	CAIE T,2
	POPJ P,	;NOT IN RFC RECEIVED STATE
	PUSHJ P,NETOW	;GET IMPMPC
	LDB H,IMSCFH
	MOVEM H,SRN3(U)	;FOREIGN HOST NUMBER
	MOVE A,IMSOC2(I)	;LOCAL SOCKET NUMBER
	MOVE B,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	MOVE D,A
	ROT D,-1
	PUSHJ P,NETOS	;SEND RFC (AND MAYBE ALL)
	CONO PI,NETOFF
	HRRZ T,IMSOC4(I)
	MOVEI TT,5
	CAIN T,2
	HRRM TT,IMSOC4(I)	;CONNECTION OPEN
	JRST UTCOJ1

NETCHK:	SKIPGE (R)
	JRST IOCER1
	HRRZ A,(R)
	CAIL A,NETDUI
	CAILE A,NETDBO
	JRST ILUUO	;NOT A NETWORK CHANNEL
	HLRZ I,(R)	;SOCKET TABLE INDEX
	JRST (T)

;.NETS CH,	;SEND BUFFER NOW
;RETURN

ANETS:	JSP T,NETCHK
	MOVE T,IMSOC2(I)
	TRNN T,1
	JRST ILUUO	;NOT SEND SOCKET
	CONO PI,NETOFF
	MOVE T,IMSOC6(I)
	HRRZ Q,(T)
	CAIN Q,-1
	JRST NETONJ	;BUF EMPTY
	MOVSI Q,400000
	IORM Q,IMSOC4(I)
	JRST IMPOST	;TURNS NETON

;NETWORK UNIT INPUT
NETI:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,IOCER1
	XCTR XRW,[MOVES (C)]	;TAKE FAULT HERE IF GOING TO TAKE ONE
NETIB:	HRRZ Q,IMSOC6(I)	;BUFFER ADDRESS
	MOVE T,Q
	HRL T,I
	PCLT
	PUSHJ P,NETIWT	;WAIT FOR MESSAGE TO APPEAR OR INPUT CLS
	PUSHJ P,UFLS
	HRRZ A,IMSOC4(I)
	JUMPE A,NETIB1	;CHANNEL CLOSED
	HLRZ B,(Q)
	ADD B,Q	;ADDRESS OF POINTER WORD
	SKIPL (B)	;SKIP IF ANY BYTES REMAINING
	JRST 4,.
	MOVE J,IMSCIP(I)
	MOVE H,IMSOC5(I)
	TLNN H,2000	;SKIP IF ONE BIT BYTES
	JRST NETI2
	LDB E,IMSCUB	;USER BYTE SIZE
	MOVSI TT,770000
	MOVEI D,0
NETI1:	TDNE TT,J
	JRST NETI1A
	HRRZ A,J
	CAIN A,177(Q)
	HRRM Q,J
NETI1A:	ILDB A,J	;GET NEXT BIT
	LSH D,1
	IORI D,(A)
	SOJG E,NETI1
NETI3:	TLNE H,400
	ANDI D,177	;7 BIT ASCII
	LDB TT,IMSCUB
	CONO PI,NETOFF
	CAMLE TT,IMSOCT(I)
	MOVE TT,IMSOCT(I)
	PUSH P,TT
	CONO PI,NETON
	HRLS TT
	ADD TT,(B)	;ADVANCE COPY OF POINTER
	JUMPL TT,NETI8	;MORE STUFF LEFT
	TLNE TT,-1
	JRST 4,.
	PUSH P,TT
	PUSH P,B
	PUSH P,D
	PUSH P,J
	CONO PI,NETOFF
	MOVE A,IMSC8I(I)
	ADDI A,1	;INCREASE IN MESSAGE ALLOCATION
	CAIL A,8	;SEND ALL IF MESS REALL OF 8 OR MORE
	JRST NETI6
	MOVE A,TT	;INCREASE IN IMSC7I
	ADD A,IMSC7I(I)
	CAIL A,1000.	;OR BIT REALL OF 1000. OR MORE
	JRST NETI6
	AOS IMSC8I(I)
	ADDM TT,IMSC7I(I)
	CONO PI,NETON
NETI7:	POP P,J
	HRRZ D,J	;ADDRESS OF LAST WORD OF MESSAGE
	ADDI D,1	;(MAYBE) ADDRESS OF NEXT HEADER
	CAIL D,177(Q)
	SUBI D,177
	HRRM D,J	;SET UP NEW IMSCIP TO POINT TO WORD BEFORE 1ST WD OF NXT MSG
	TLZ J,770000
	SUBI D,(Q)
	SKIPN D	;IF D WAS Q+177 THEN IT GOT SET TO 0
	MOVEI D,177	;PUT BACK TO 177 (= ADDR OF NEXT POINTER)
	CONO PI,NETOFF
	HRRZ TT,(Q)	;NEXT IN AT PI LEVEL
	CAIN D,(TT)	;SKIP IF BUFFER NOT EMPTY
	MOVEI D,-1
	HRLM D,(Q)	;STORE NEXT OUT AT MP LEVEL
	MOVNI E,1
	HRRZ A,IMSOC4(I)
	CAIN A,10
	MOVEI E,0	;CLSED
	CAIN A,11
	MOVEI E,5	;NO INPUT AVAILABLE
	JUMPL E,[JRST 4,.]
	CAIN D,-1
	HRRM E,IMSOC4(I)
NETI7B:	CONO PI,NETON
	POP P,D
	POP P,B
	POP P,TT
NETI8:	MOVEM TT,(B)
	POP P,TT
	MOVNS TT
	ADDB TT,IMSOCT(I)
	JUMPL TT,[JRST 4,.]
	MOVEM J,IMSCIP(I)
	JUMPL C,NETI8A
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETI8A:	HRRZ E,IMSOC4(I)
	MOVEM D,(C)
	JUMPN E,CPOPJ
	HRLI E,(SETZ)
	POPJ P,

NETICL:	MOVE R,UUAC(U)
	ADDI R,IOCHNM(U)
	JRST ACLOSE

NETIB1:	JUMPGE C,NETIB2
	PUSHJ P,NETICL
	HRLI E,600000
	POPJ P,

NETIB2:	PUSH P,IMSOC5(I)
	PUSH P,C
	PUSHJ P,NETICL
	POP P,C
	POP P,TT
	TLNN TT,1400	;SKIP IF ASCII MODE
	JRST IOCR10
	HRROI D,EOFCH
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETI6:	CONO PI,NETON
	PUSHJ P,NETOW	;GOBBLE MAIN PROG CONTROL LINK BLOCK
	CONO PI,NETOFF
	AOS A,IMSC8I(I)
	ADDB TT,IMSC7I(I)
	CAIGE A,8
	CAIL TT,1000.
	JRST NETI6E	;STILL WANT TO DO IT
	CONO PI,NETON
	PUSHJ P,LSWPOP	;RELEASE IMPMPU
	JRST NETI7
NETI6E:	MOVEI J,2(I)	;LINK #
NETI6A:	IORI J,<4_8>	;SEND ALLOC
NETI6C:	LSH J,16.
	ADD J,A
	LSH J,4
	MOVEM J,IMPMPC+3
	MOVE J,TT
	LSH J,4
	MOVEM J,IMPMPC+4
	LDB J,IMSCFH
	LSH J,IMDEST
	MOVEM J,IMPMPC+1
	MOVE J,[8_24.+8_8]
	MOVEM J,IMPMPC+2
	MOVEI J,2
	MOVEM J,IMPMPC	;TEXT LENGTH
NETI6D:	SETZM IMSC8I(I)
	SETZM IMSC7I(I)
	ADDM A,IMSOC8(I)
	ADDM TT,IMSOC7(I)
	PUSH P,Q
	PUSHJ P,IMPMPQ	;TURNS NETON
	POP P,Q
	PUSHJ P,LSWDEL	;WILL BE UNLOCKED AT PI LEVEL
	JRST NETI7

NETIWT:	CONO PI,NETOFF
	HLRZ A,T
	SKIPL (T)
	JRST NTIWT1	;INPUT AVAILABLE
	HRRZ A,IMSOC4(A)
	JUMPE A,NETOJ1	;CONNECTION CLOSED
	CAIE A,11
	CAIN A,10
	JRST 4,.	;NO INPUT BUT IN INPUT AVAILABLE STATE
	JRST NETONJ

NTIWT1:	HRRZ B,IMSOC4(A)
	CAIN B,10
	JRST NETOJ1
	CAIE B,11
	JRST 4,.
	PUSH P,I
	MOVE I,A
	LDB B,IMSCUB
	POP P,I
	CAMG B,IMSOCT(A)
	AOS (P)	;AT LEAST AS MANY BITS NEEDED AS USER BYTE SIZE
	JRST NETONJ

NETI2:	IBP J
	HRRZ A,J
	CAIN A,200(Q)
	SUBI A,177
	HRRM A,J
	LDB D,J
	JRST NETI3

;UNIT MODE NETWORK OUTPUT (DOESN'T CLOBBER C)
NETW:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,IOCER1
	XCTR XR,[MOVE A,(C)]
NETWB:	HRRZ B,IMSOC4(I)
	CAIE B,5
	CAIN B,6
	JRST .+2
	JRST IOCER8
NETW3:	CONO PI,NETOFF
	MOVE D,IMSOC6(I)
	SKIPN TT,IMSCIP(I)	;LAST OUT
	JRST NETWL1	;MUST MAKE NEW MESSAGE
	HLRZ E,(D)	;NEXT OUT AT PI LEVEL
	TLNE D,200000	;SKIP IF NOT ACTIVE AT PI LEVEL
	CAME E,TT	;SKIP IF PI LEVEL PROCESSING LAST MESSAGE
	JRST NETW1
	JRST NETWL
NETW1:	LDB T,IMSCUB	;BYTE SIZE
	CAMLE T,IMSOC7(I)	;SKIP IF ENOUGH BIT ALLOC
	JRST NETW2
	MOVE TT,IMSCIP(I)	;LAST MESSAGE
	ADDI TT,(D)	;ADDRESS OF ITS POINTER WORD
	MOVEI B,2(TT)
	LDB Q,[102000,,(B)]	;BYTE COUNT
	IMUL Q,T	;BIT COUNT
	MOVEI E,32.
	SKIPL IMSOC5(I)	;SKIP IF 32 BIT TRANSFER MODE
	MOVEI E,36.
	IDIVI Q,(E)	;J GETS REMAINDER
	ADDI TT,3(Q)	;POINTER TO LAST WORD
	JUMPE J,NETW5A	;OLD STUFF EXACTLY FITS
	SUB E,J	;# BITS REMAINING IN LAST WORD
	SUB E,T	;# BITS AFTER THIS BYTE IS WRITTEN
	JUMPL E,NETW5	;HAVE TO USE ANOTHER WORD
	SKIPGE IMSOC5(I)
	ADDI E,4	;COMP FOR 32 BIT MODE
	ROT E,-6	;SHIFT TO POSITION FIELD
	DPB T,[300600,,E]	;BYTE SIZE
	HRR E,TT	;ADDRESS
	DPB A,E	;STORE AWAY CHAR
NETW7A:	LDB A,[102000,,(B)]
	ADDI A,1
	DPB A,[102000,,(B)]	;INCREMENT BYTE COUNT
	MOVN J,T
	ADDB J,IMSOC7(I)
	JUMPL J,[JRST 4,.]
	JRST NETONJ

NETW5A:	SKIPA E,T	;TT POINTS TO WORD AFTER END OF MSG
NETW5:	ADDI TT,1	;ADDR OF WORD WE WANT
	SUBI TT,(D)	;INDEX
	HLRZ W,(D)	;NEXT OUT AT PI LEVEL
	CAIE TT,(W)
	CAIL TT,200
	JRST NETWL	;OFF END OF BUFFER OR BUFFER FULL
	HRRZ W,(D)	;NEXT IN
	CAIE TT,(W)
	JRST NETW6
	ADDI W,1
	CAILE W,200-4
	MOVEI W,1
	HRRM W,(D)	;UPDATE NEXT IN
NETW6:	ADDI TT,(D)	;ADDRESS OF NEW WORD
	AOSL -2(B)	;INCR WORD COUNT IN POINTER WORD
	JRST 4,.	;THIS WASN'T THE LAST MESSAGE
	SETZM (TT)
	JUMPGE E,NETW7	;ENTIRE BYTE GOES IN NEW WORD
	MOVN W,E
	MOVE H,E
	ADDI H,(T)	;# BITS THAT GO IN PREVIOUS WORD
	ROT W,-6	;POSITION FIELD
	DPB H,[300600,,W]
	HRRI W,A
	LDB TT,W	;GET BITS THAT GO IN PREVIOUS WORD
	MOVEI D,4
	SKIPL IMSOC5(I)	;SKIP IF 32 BIT TRANSFER MODE
	MOVEI D,0
	DPB D,[360600,,W]
	HRRI W,-1(TT)
	DPB TT,W	;PUT BITS IN PREV WORD
	MOVNS E	;# BITS LEFT TO STORE AWAY
NETW7:	ROT E,-12.
	HRRI E,-1(TT)
	IDPB A,E	;STORE REMAINING BITS
	JRST NETW7A

NETW2:	PUSHJ P,NTBFST	;START UP THIS OUTPUT BUFFER
	CONO PI,NETON
	PCLT
	HRL T,I
	PUSHJ P,NTW2WT
	PUSHJ P,UFLS
	JRST NETWB

;FIRST MESSAGE
NETWL1:	MOVE T,TIME
	MOVEM T,IMSOCT(I)
NETWL:	CONO PI,NETON
	SKIPLE IMSOC8(I)
	JRST NETWL4
	PUSHJ P,NTBFST	;START UP OUTPUT BUFFER
	PCLT
	HRLZ T,I
	PUSHJ P,NTWLW1	;WAIT FOR MESSAGE ALLOCATION
	PUSHJ P,UFLS
NETWL4:	HRRZ T,IMSOC4(I)
	JUMPE T,IOCER8
	LDB T,IMSCUB	;NUMBER OF BITS TO SEND
	MOVE D,T	;BYTE SIZE
	CAMG D,IMSOC7(I)
	JRST NETWL2
	PUSHJ P,NTBFST	;START UP OUTPUT BUFFER
	PCLT
	HRL T,I
	PUSHJ P,NTW2WT	;WAIT FOR BIT ALLOCATION
	PUSHJ P,UFLS
NETWL2:	HRRZ T,IMSOC4(I)
	JUMPE T,IOCER8
	HRRZ Q,IMSOC6(I)	;BUFFER ADDRESS
	MOVE T,Q
	HRL T,I
	PUSHJ P,NETWWT
	JRST .+2
	JRST NETWL3
	PUSHJ P,NTBFST	;START UP OUTPUT BUFFER
	PCLT
	PUSHJ P,NETWWT
	PUSHJ P,UFLS	;WAIT FOR ROOM IN THE BUFFER
NETWL3:	HRRZ E,IMSOC4(I)
	JUMPE E,IOCER8
	MOVE E,IMSOC5(I)
	TLNE E,400
	ANDI A,177	;7 BIT ASCII
	HRRZ B,(Q)	;NEXT IN
	MOVE W,B
	ADD B,Q
	LDB H,IMSCHD
	LSH H,12.
	MOVEM H,1(B)	;HEADER
	MOVE J,D
	LSH D,24.	;BYTE SIZE
	IORI D,1_8	;BYTE COUNT = 1
	MOVEM D,2(B)
	MOVSI D,440000
	DPB J,[300600,,D]
	HRRI D,3(B)
	SETZM 3(B)
	IDPB A,D
	CONO PI,NETOFF
	HRRZ A,IMSCIP(I)
	CAIG W,200-4	;NEXT IN IS OUT OF RANGE
	CAILE A,200-4	;INSCIP IS OUT OF RANGE
	JRST 4,.
	ADD A,Q
	HRLM W,(A)
	MOVEM W,IMSCIP(I)
	HRROI D,3
	MOVEM D,(B)
	ADDI W,4
	CAILE W,200-4
	MOVEI W,1
	HRRM W,(Q)
	CONO PI,NETON
	SOSGE IMSOC8(I)
	JRST 4,.	;NEGATIVE MESSAGE ALLOC
	MOVNS J
	ADDB J,IMSOC7(I)
	JUMPL J,[JRST 4,.]	;NEGATIVE BIT ALLOC
	POPJ P,

NETWWT:	HLRZ E,T
	HRRZ E,IMSOC4(E)
	JUMPE E,POPJ1
	HLRE E,(T)	;OUT
	HRRZ B,(T)	;IN
	HRREI H,-4(E)	;OK TO SKIP IF IN .LE. OUT - 4
	CAMLE B,H	;OR IF IN .GT. OUT
	CAMGE E,B
	AOS (P)
	POPJ P,

NTW2WT:	HLRZ E,T
	HRRZ B,IMSOC4(E)
	JUMPE B,POPJ1
	HRRZ B,T
	CAMG B,IMSOC7(E)
	AOS (P)
	POPJ P,

NTWLW1:	HLRZ E,T
	HRRZ B,IMSOC4(E)
	JUMPE B,POPJ1
	SKIPLE IMSOC8(E)
	AOS (P)
	POPJ P,

NTBFST:	MOVSI TT,400000	;TURN ON SEND BUFFER BIT
	IORM TT,IMSOC4(I)
	JRST IMPOST	;START UP PI ROUTINES

NETBO:	HRRE I,A
	JUMPL I,IOCER1
	XCTR XRW,[MOVES D,(C)]	;TAKE TRAP GETTING POINTER IF SWAPPED OUT
	MOVE E,IMSOC5(I)
	TLNE E,1400	;SKIP IF IMAGE MODE
	JRST NETBOA	;ASCII MODE
NETBO1:	XCTR XW,[MOVEM D,(C)]
	XCTR XR,[MOVE A,(D)]
	PUSHJ P,NETWB
	XCTR XR,[MOVE D,(C)]
	AOBJN D,NETBO1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETBOA:	TLNN E,400	;SKIP IF 7 BIT
	JRST NETBA8
	MOVEI E,NETBOR
	JRST NBTOCH

NETBOR:	PUSH P,D
	PUSH P,TT
	PUSHJ P,NETWB
	POP P,TT
	POP P,D
	MOVEI E,NETBOR
	POPJ P,

NETBA8:	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]
	CAIGE TT,4	;ONLY 4 BYTES PER WORD (3 < CNT < 8)
	POPJ P,
	SKIPA TT,NETCHT-4(TT)
NTBA8A:	XCTR XW,[MOVEM D,(C)]
	XCTR XR,[MOVE W,(D)]
	ILDB A,TT
	PUSH P,TT
	PUSHJ P,NETWB
	POP P,TT
	XCTR XR,[MOVE D,(C)]
	ADD D,[700000,,]	;ADVANCE CHAR CNT
	JUMPL D,NTBA8A	;GO TO NEXT CHAR
	MOVE TT,NETCHT+3
	ADD D,[400001,,1]	;INCR TO NEXT WORD
	JUMPL D,NTBA8A
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETCHT:	REPEAT 4,<44-<3-.RPCNT>*10>_12.+1000,,W

NETBI:	HRRE I,A
	JUMPL I,IOCER1
	XCTR XRW,[MOVES D,(C)]
	MOVE E,IMSOC5(I)
	TLNE E,1400	;SKIP IF IMAGE MODE
	JRST NETBIA	;ASCII MODE
NETBI1:	XCTR XW,[MOVEM D,(C)]
	XCTR XRW,[MOVES (D)]
	PUSH P,C
	MOVE C,[SETZ W]
	PUSHJ P,NETIB	;GET NEXT BYTE
	POP P,C
	TLNE E,200000
	POPJ P,	;SOCKET CLOSED
	XCTR XR,[MOVE D,(C)]
	XCTR XW,[MOVEM W,(D)]
	JUMPL E,NETBI2
	AOBJN D,NETBI1
NETBI3:	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NETBI2:	ADD D,[1,,1]
	JRST NETBI3

NETBIA:	TLNN E,400	;SKIP IF 7 BIT ASCII
	JRST NTBIA8
	MOVEI E,NETBIR
	JRST INBTCH

NETBIR:	MOVE I,A
	PUSHJ P,NETIB
	HRRI E,NETBIR
	POPJ P,

NTBIA8:	HRRZS E
	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]
	CAIGE TT,4
	POPJ P,
	SKIPA TT,NETCHT-4(TT)
NTBI8A:	XCTR XW,[MOVEM D,(C)]
	XCTR XRW,[MOVES (D)]
	JUMPL E,NTBI8B
	PUSH P,C
	PUSH P,TT
	MOVE C,[SETZ H]
	PUSHJ P,NETIB
	POP P,TT
	POP P,C
	XCTR XR,[MOVE D,(C)]
	LDB W,[410300,,D]
	CAIN W,7
	TLNN E,200000
	JRST NTBI8C
	POPJ P,
NTBI8C:	XCTR XR,[MOVE W,(D)]
	IDPB H,TT
	XCTR XW,[MOVEM W,(D)]
	ADD D,[700000,,]
	JUMPL D,NTBI8A
	MOVE TT,NETCHT+3
	ADD D,[400001,,1]
	SKIPL E
	JUMPL D,NTBI8A
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

NTBI8B:	MOVEI H,EOFCH
	XCTR XR,[MOVE D,(C)]
	JRST NTBI8C

NETCLS:	HRRE I,A	;SOCKET TABLE INDEX
	JUMPL I,CPOPJ
	MOVE T,IMSOC2(I)
	TRNN T,1	;SKIP IF SEND SOCKET
	JRST NETCL2
	MOVSI T,400000
	IORM T,IMSOC4(I)	;CAUSE BUFFER TO BE SENT
	PUSHJ P,IMPOST
NETCL2:	MOVSI B,200000
	CONO PI,CLKOFF
	IORM B,IMSOC1(I)	;MARK CHANNEL TO BE CLOSED
	AOS IMNCS
	MOVE R,UUAC(U)
	MOVE A,CHNBIT(R)
	ANDCAM A,IFPIR(U)
	JRST CLKONJ

IMRTCQ:	MOVE H,IMFCLQ
	MOVEM H,1(J)
	MOVEM J,IMFCLQ
	MOVE H,[JRST 4,.]
	MOVEM H,2(J)
	POPJ P,

;SEARCH CLOCK QUEUE FOR ENTRY WITH H IN 3RD WORD
;AND T IN RH OF 2ND WORD.  CALL WITH CLKOFF.
;SKIPS IF FINDS IT.  RET ADDR IN J AND PREV ADDR IN Q
NTSCL:	ANDI H,377
	SKIPA Q,[CLROOT-1]
NTSCL1:	MOVE Q,J
	SKIPN J,1(Q)
	POPJ P,	;NOT THERE
	HRRZ W,2(J)
	CAMN H,3(J)	;SKIP IF WRONG 3RD WORD
	CAIE W,(T)	;SKIP IF RIGHT 2ND WORD
	JRST NTSCL1	;TRY NEXT
	JRST POPJ1	;FOUND IT

;SEARCH PENDING QUEUE FOR LOCAL SOCKET NUMBER IN A,
;T 4.9 = 1 => LISTENING, 4.9 => 0 => ALSO CHECK
;FOREIGN SOCKET NUMBER IN B AND FOREIGN HOST NUMBER IN E
;SKIPS IF ENTRY IS FOUND.  RETURNS ENTRY TO FREE LIST.
;Q GETS ADDRESS OF ENTRY BLOCK.  RETURN WITH UTCOFF

IMPSPQ:	CONO PI,UTCOFF
IMSPQP:	SKIPGE Q,IMPBPQ	;BEGINNING OF QUEUE
	POPJ P,	;QUEUE EMPTY
	MOVNI J,1	;PREVIOUS ENTRY
IMSPQL:	CAME A,1(Q)	;SKIP IF SAME LOCAL SOCKET NUMBER
	JRST IMSPQ1	;TRY NEXT
	JUMPL T,IMSPQW	;WIN IF LISTENING SOCKET
	LDB W,[101000,,3(Q)]	;FOREIGN HOST NUMBER
	CAMN W,E	;SKIP IF WRONG FOREIGN HOST
	CAME B,2(Q)	;SKIP IF FOREIGN SOCKET NUMBER AGREES
	JRST IMSPQ1	;TRY NEXT
IMSPQW:	SKIPGE W,(Q)	;FOUND IT
	MOVEM J,IMPEPQ	;PATCH OUT OF THE QUEUE
	SKIPGE J
	MOVEI J,IMPBPQ
	MOVEM W,(J)
	MOVE W,IMFFPQ	;ADD TO FREE LIST
	MOVEM W,(Q)
	MOVEM Q,IMFFPQ
	JRST POPJ1
IMSPQ1:	MOVE J,Q	;PREVIOUS ENTRY
	SKIPL Q,(Q)	;NEXT ENTRY
	JRST IMSPQL	;LOOP
	POPJ P,		;NOT FOUND

IMRSTO:	MOVSI T,-8	;CALLED AT 15 SEC CLK LEVEL TO UNHANG RFNM WAITS
	SKIPN IMHSRF(T)
IMRS4:	AOBJN T,.-1
	JUMPGE T,CPOPJ
	CONO PI,NETOFF
	SKIPE A,IMHSRF(T)
IMRS3:	JFFO A,IMRS2
	JRST IMRS1
IMRS2:	MOVEI C,35.
	SUB C,B
	MOVEI D,1
	LSH D,(C)
	TDZ A,D
	HRRZ B,T
	IMULI B,36.
	ADD B,C		;HOST NUMBER
	IDIVI B,4
	LDB E,IMRFTT(C)
	LDB TT,[001100,,TIME]
	CAMLE E,TT
	ADD TT,1_9
	SUB TT,E
	CAIGE TT,10.*30.
	JRST IMRS5
	ANDCAM D,IMHSRF(T)
	AOS IMNRFN
	JRST IMRS3

IMRS1:	CONO PI,NETON
	JRST IMRS4

IMRS5:	MOVE TT,TIME
	DPB TT,IMRFTT(C)	;GUARRANTEE WIN NEXT 15 SEC BREAK
	JRST IMRS3

;CLOSE NETWORK CHANNELS (CALLED AT HALF SEC CLOCK)
IMPCCL:	MOVSI I,-IMPSTL
IMPCCZ:	MOVSI T,200000
	TDNN T,IMSOC1(I)
IMPCCR:	AOBJN I,IMPCCZ
	JUMPL I,IMPCCA
	POPJ P,

IMPCCS:	CONO PI,NETON
	JRST IMPCCR

IMPCCA:	CONO PI,NETOFF
	MOVE B,IMSOC6(I)
	TLNE B,600000	;ACTIVE AT PI LEVEL OR LOCKED BY CORE JOB
	JRST IMPCCS
	HRRZ B,IMSOC4(I)
	JRST @IMPCCT(B)

IMPCCT:	IMPCC1	;0
	IMPCC1	;1
	IMPCC2	;2
	IMPCC1	;3
	IMPCC2	;4
	IMPCC5	;5
	IMPCC6	;6
	IMPCC7	;7
	IMPCC1	;10
	IMPCC2	;11

IMPCC1:	SKIPN IMSOC6(I)
	JRST 4,.
	LDB A,[221000,,IMSOC6(I)]
	PUSHJ P,IBRTN	;RETURN BUFFER
	SETZM IMSOC6(I)
	SETZM IMSOC1(I)
IMPCCQ:	CONO PI,NETON
	SOS IMNCS
	JRST IMPCCR

IMPCC2:	SKIPN IMSOC6(I)
	JRST IMPC2A
	LDB A,[221000,,IMSOC6(I)]
	PUSHJ P,IBRTN
	SETZM IMSOC6(I)
IMPC2A:	SKIPG IMFCQL
	JRST IMPCCS	;NO PI CONTROL QUEUE BLOCKS AVAIL
	PUSH P,IMPCSH
	LDB T,IMSCFH
	MOVEM T,IMPCSH
	JSP T,IMSTCM
	12.,,3	;12. BYTES, 3 WORDS
	JRST 4,.	;NO SLOTS AVAIL.  CHECKED BEFORE
	MOVEI H,3_4	;3 NOPS + CLS
	MOVEM H,4(Q)
	MOVE H,IMSOC2(I)	;LOCAL SOCKET
	LSH H,4		;MOVE INTO 32 BIT FIELD
	MOVEM H,5(Q)
	MOVE H,IMSOC3(I)	;FOREIGN SOCKET
	LSH H,4
	MOVEM H,6(Q)
	PUSHJ P,IMWCQ	;SEND CLS
	POP P,IMPCSH
	MOVEI H,7
	HRRM H,IMSOC4(I)
	MOVE H,TIME
	MOVEM H,IMSOCT(I)	;TIME CLS SENT
	JRST IMPCCS

IMPCC5:	MOVE H,IMSOC2(I)
	TRNN H,1	;SKIP IF SEND SOCKET
	JRST IMPC5B	;RECEIVE SOCKET
	MOVE Q,IMSOC6(I)
	SKIPGE (Q)
	JRST IMPC5B	;BUFFER NOW EMPTY
	MOVSI H,100000
	TDNN H,IMSOC1(I)	;SKIP IF TIME OUT STARTED
	JRST IMPC5A
	MOVE H,TIME
	SUB H,IMSOCT(I)
	CAIG H,IMPBTO	;SKIP IF TIMES OUT
	JRST IMPCCS	;NOT YET
IMPC5B:	MOVEI H,4
	HRRM H,IMSOC4(I)
	JRST @IMPCCT(H)

IMPC5A:	IORM H,IMSOC1(I)
	MOVE H,TIME
	MOVEM H,IMSOCT(I)
	JRST IMPCCS

IMPCC6:	MOVSI H,40000
	TDNN H,IMSOC1(I)	;SKIP IF TIME OUT STARTED
	JRST IMPC5A
	MOVE H,TIME
	SUB H,IMSOCT(I)
	CAIG H,IMRFTO	;SKIP IF TIMED OUT
	JRST IMPCCS	;NOT YET
	JRST IMPC5B	;GIVE UP

IMPCC7:	MOVE H,TIME
	SUB H,IMSOCT(I)
	CAIG H,IMPCTO	;SKIP IF TIMED OUT
	JRST IMPCCS	;NOT YET
	SETZM IMSOC1(I)
	JRST IMPCCQ

IMPINT:	AOSN IMPB
	JRST IMPBKZ
	AOSN IMPI
	JRST IMPIBZ
	AOSN IMPO
	JRST IMPOBZ
	TRNE TT,IMPLW+IMPHER+IMPERR
	JRST IMPBKZ
	TRNE TT,IMPID
	JRST IMPIBZ
	TRNE TT,IMPOD
	JRST IMPOBZ
	JRST 4,.

EBLK

IMPBRK:	0

BBLK
	CONSO IMP,IMPLW+IMPHER+IMPERR
IFE NEWDTP,JRST RC1INT
IFN NEWDTP,JRST IMPBR1
	SETOM IMPB
	CONO IMP,NETCHN
	JRST 12,@IMPBRK

IFN NEWDTP,[
IMPBR1:	CONSZ DTC,70
	JRST 12,@IMPBRK
]

RC1INT:	MOVEM 17,R1NTAC+17
	MOVEI 17,R1NTAC
	BLT 17,R1NTAC+16
	MOVEI J,1
	JSP E,SPUR
	MOVSI 17,R1NTAC
	BLT 17,17
	JRST 12,@IMPBRK

IMPRET:	CONO IMP,@IMPPIA
	JRST IMPEX

;GET HERE PI IN PROG ON NETCHN
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPBKZ:	AOS IMCT1
	TRNE TT,IMPHER
	JRST IMPBHE	;HOST ERROR
	TRNE TT,IMPERR
	JRST IMPBER	;IMP ERROR
	MOVE B,IMPHI
	AOJN B,IMPBKX	;JUMP IF INPUT NOT TO BE HELD UP
IMPBKW:	CONO IMP,IMPIDC	;CLEAR INPUT DONE
	SOS IMPHI	;INDICATE SUCCESSFULLY HELD UP
	MOVEM TT,IMSTAS	;SAVE STATUS
	AOS IMPNIH
	JRST IMPRET

IMPBKX:	CONO IMP,IMI32C	;PUT BACK IN 36 BIT MODE
	DATAI IMP,IMPIWD	
	SKIPGE IMPIS
	JRST IMPRET
IMPBKV:	MOVE B,IMPIS
	JRST @IMSDT2(B)

IMSDT2:	IMBNOR	;NORMAL INPUT (0)
	IMPBK2	;IGNORE (1)
	IMPRM2	;SECOND WORD OF MESSAGE HEADER (2)
	IMPBK3	;END OF CONTROL MESSAGE (3)
	IMPRMB	;END OF DATA INPUT (4)
	IMPRMB	;END OF DATA INPUT (5)

IMBNOR:	LDB A,IMSBP
	MOVEM A,IMPCSH
	LDB A,IMLNBP
	MOVEM A,IMPCLN
	LDB A,IMTBP	;GET MESSAGE TYPE IN A
	JRST @IMTDT(A)	;DISPATCH

IMTDT:	IMPPRE	;REGULAR MESSAGE (TOO SMALL)	 (0)
	IMPBE1	;ERROR W/O MESSAGE ID		 (1)
	IMPGD	;IMP GOING DOWN			 (2)
	IMPBLL	;BLOCKED LINK			 (3)
	IMPIN	;NOP				 (4)
	IMPRFN	;RFNM				 (5)
	IMPLTF	;LINK TABLE FULL		 (6)
	IMPDHD	;DESTINATION HOST DEAD		 (7)
	IMPBE2	;ERROR W/ MESSAGE ID		 (8)
	IMPINC	;INCOMPLETE TRANSMISSION	 (9)
	IMPUN	;UNASSIGNED			(10)
	IMPUN	;UNASSIGNED			(11)
	IMPUN	;UNASSIGNED			(12)
	IMPUN	;UNASSIGNED			(13)
	IMPUN	;UNASSIGNED			(14)
	IMPUN	;UNASSIGNED			(15)

IMPLTF:	JRST 4,.

IMPBHE:
IMPBER:
IMPGD:
	MOVSI J,20
	IORM J,SUPCOR
	SETZM IMPPIA
	CONO IMP,0
	SETOM IMPUP	;IMP IS DOWN
	JRST IMPRET

IMPBLL:	AOS IMNBLL
	SKIPE IMPCLN
	JRST 4,.
	PUSHJ P,IMPRSR	;SIMULATE RECEIPT OF RST
	JRST IMPRET

IMPIN:	AOS IMPNN	;ONE MORE NOP
	JRST IMPIRT

IMPUN:	AOS IMPNUN
	JRST IMPIRT

IMPBE1:	AOSE IMPIGE	;MAYBE IGNORE THIS ERROR
	AOS IMPER1
	JRST IMPIRU

IMPBE2:	AOSE IMPIGE
	AOS IMPER2
	JRST IMPIRU

IMPPRE:	AOS IMPNPE	;ONE MORE PROTOCOL ERROR
	JRST IMPIRT

IMPBK2:	SETZM IMPIS	;RESET STATE
	JRST IMPRET

IMPIRT:	MOVEI A,1
	TRNN TT,IMPLW
	MOVEM A,IMPIS
	JRST IMPRET

IMPRFN:	SKIPE IMPCLN	;LINK NUMBER
	JRST IMRFN1	;DATA LINK
IMPRF6:	MOVE B,IMPCSH
	IDIVI B,36.
	MOVEI D,1
	LSH D,(C)
	TDNN D,IMHSRF(B)
	AOS IMNSRC
	ANDCAM D,IMHSRF(B)	;SET RFNM RECEIVED
	PUSHJ P,IMPIOS	;START OUTPUT
	JRST IMPIRT

IMRFN1:	MOVE A,IMPCSH
	LSH A,8
	IOR A,IMPCLN	;HEADER
	MOVSI I,-IMPSTL
	MOVEI W,1
IMRFN2:	LDB D,IMSCHD	;HEADER
	SKIPE IMSOC1(I)	;SKIP IF SLOT NOT IN USE
	CAME A,D	;SKIP IF HEADER AGREES
	JRST IMRFN3
	HRRZ J,IMSOC4(I)	;STATE
	CAIN J,6
	SOJA J,IMRFN4	;RFNM WAIT
IMRFN3:	AOBJN I,IMRFN2
	AOS IMNSRF
	JRST IMPRET
IMRFN4:	HRRM J,IMSOC4(I)	;CONNECTION OPEN
	MOVSI J,40000
	ANDCAM J,IMSOC1(I)	;STOP POSSIBLE RFNM TIME OUT
	PUSHJ P,IMPIOS	;START OUTPUT
	JRST IMPIRT

IMPINC:	SKIPA E,[5]
IMPDHD:	MOVEI E,4
	PUSH P,TT
	MOVE TT,IMPCSH
	IDIVI TT,12.
	MOVEI C,0
	DPB C,IMHSBT(I)	;MARK HIM DOWN
	MOVE TT,IMPCSH
	IDIVI TT,36.
	MOVEI H,1
	LSH H,(I)
	ANDCAM H,IMHSRF(TT)	;CLEAR RFNM WAIT
	POP P,TT
	MOVSI I,-IMPSTL
IMDHD1:	LDB H,IMSCFH
	SKIPE C,IMSOC1(I)	;SKIP IF NOT IN USE
	CAME H,IMPCSH
	JRST IMDHDA
	HRRZ H,IMSOC4(I)
	TLNN C,200000	;THIS GUY IS CLOSING ANYWAY
	CAIG H,1
	JRST IMDHDA	;THIS SOCKET'S HOST NUMBER FIELD IS MEANINGLESS
	HLLZS IMSOC4(I)	;CLS STATE
	MOVEM E,IMSCLS(I)	;CLS REASON
	PUSHJ P,IMPUIN
IMDHDA:	AOBJN I,IMDHD1
	MOVE H,IMPCSH
	PUSHJ P,NTCLQD
IMPIRU:	SKIPE IMPCLN	;SKIP IF CONTROL LINK
	JRST IMPIRT
	JRST IMPRF6

;DEFUSE ALL CLOCK QUEUE ENTRIES FOR HOST IN H
;H < 0 => ALL HOSTS (FROM SYS JOB)
NTCLQD:	SKIPA Q,[CLROOT-1]
NTCLQ1:	MOVE Q,J
	SKIPN J,1(Q)
	POPJ P,
NTCLQ4:	HRRZ W,2(J)
	MOVSI I,-IMPTOL
NTCLQ2:	CAME W,IMPTOT(I)
	AOBJN I,NTCLQ2
	JUMPGE I,NTCLQ6
	JUMPL H,NTCLQ5
	CAME H,3(J)
	JRST NTCLQ1
	MOVE W,[JRST NTRTO1]
	MOVEM W,2(J)
	JRST NTCLQ1

NTCLQ5:	MOVE W,1(J)
	MOVEM W,1(Q)
	MOVE I,(J)
	ADDM I,(W)
	PUSH P,H
	PUSHJ P,IMRTCQ
	POP P,H
	MOVE J,W
	JUMPN J,NTCLQ4
	POPJ P,

NTCLQ6:	CAIL J,IMPCLQ
	CAIL J,IMPCLQ+IMNCLQ*4
	JRST NTCLQ1
	JRST 4,.

EBLK

IMPIBK:	0

BBLK
	SETOM IMPI
	CONO IMP,NETCHN
	JRST 12,@IMPIBK

;GET HERE PI IN PROG ON NETCHN
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPIBZ:	AOS IMCT2
	MOVE B,IMPHI
	AOJE B,IMPBKW	;INPUT TO BE HELD UP
	MOVE B,IMPIS
	CAIE B,2
	JRST IMPIBU
	SKIPE IMPCLN	;SKIP ON CONTROL LINK
	JRST IMPRM1	;DATA LINK
	CONO IMP,IMI32S	;SET 32 BIT INPUT
IMPIBU:	DATAI IMP,IMPIWD
	SKIPGE IMPIS
	JRST IMPRET
IMPIBV:	JRST @IMPSDT(B)

IMPSDT:	IMPNOR	;NORMAL INPUT (0)
	IMPRET	;IGNORE (1)
	IMPRM2	;SECOND WORD OF MESSAGE HEADER (2)
	IMPSOS	;END OF CONTROL MESSAGE (3)
	IMPRMC	;FIRST WORD OF SECOND HALF OF DATA (4)
	IMPRMH	;END OF DATA (5)

IMPSOS:	SOS IMPILC+1	;INITIALLY 0
	JRST IMPRET

IMPNOR:	TRNE TT,IMPI32
	JRST 4,.	;INPUT WAS IN 32 BIT MODE
	LDB A,IMTBP	;MESSAGE TYPE
	JUMPE A,IMPRM
	MOVEI B,1	;IGNORE REMAINDER OF THIS MESSAGE
	MOVEM B,IMPIS
	JRST IMBNOR

IMPRM:	LDB A,IMSBP
	MOVEM A,IMPCSH	;SOURCE HOST
	LDB B,IMLNBP
	MOVEM B,IMPCLN	;LINK NUMBER
	MOVEI C,2
	MOVEM C,IMPIS	;STATE TO WAIT FOR NEXT WORD OF MESSAGE HEADER
	JRST IMPRET

IMPRM2:	TRNE TT,IMPI32
	JRST 4,.	;INPUT WAS IN 32 BIT MODE
	LDB A,IMCBBP
	MOVEM A,IMPCBS	;BYTE SIZE
	LDB B,IMBCBP
	MOVEM B,IMPCBC	;BYTE COUNT
	SKIPE C,IMPCLN	;SKIP IF LINK 0
	JRST 4,.	;NOT CONTROL MESSAGE
	CAIN A,8	;BYTE SIZE SHOULD BE 8
	CAILE B,120.	;BYTE COUNT SHOULDN'T BE > 120.
	JRST IMPPRE
	TRNE TT,IMPLW
	JRST IMPRM3
	LSH B,-2
	ADDI B,1	;NUMBER OF WORDS NECESSARY
	MOVEM B,IMPNIW	;NUMBER OF INPUT WORDS EXPECTED
	MOVNS B
	HRLZ B,B
	HRRI B,IMPINB-1	;BLKI POINTER
	MOVEI C,3
IMPRM9:	MOVEM C,IMPIS
IMPRMD:	MOVEM B,IMBLKI
	MOVE B,[BLKI IMP,IMBLKI]
	MOVEM B,IMPILC
	MOVE B,[JSR IMPRM4]
	MOVEM B,IMPILC+1
	SETOM IMPIH
	MOVEI B,IMPCHN
	MOVEM B,IMPPIA
	JRST IMPRET

IMPRM3:	JUMPE B,IMPBK2
	AOS IMPNPE	;NO TEXT BUT BYTE COUNT NOT ZERO
	JRST IMPBK2

EBLK

IMPRM4:	0

BBLK
;BLKI HAS RUN OUT BUT HAVE NOT YET GOTTEN
;LAST IMP WORD.  IGNORE MORE INPUT UNTIL IT COMES IF IMPIS = 3
	MOVEM A,IMPA	;INPUT DONE IS NOW CLEAR.  IMPIS =3 CAUSES
	MOVE A,[JSR IMPIBK]	;IMPIBK TO IGNORE MORE INPUT
	MOVEM A,IMPILC
	SETZM IMPILC+1	;FLAG TO INDICATE BLKI HAS RUN OUT
	SETZM IMPIH
	MOVEI A,NETCHN
	SKIPL IMPOH
	MOVEM A,IMPPIA
	CONO IMP,@IMPPIA
	MOVE A,IMPA
	JRST 12,@IMPRM4

;GET HERE PI IN PROG ON NETCHN
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPBK3:	MOVNI E,1	;FLAG: -1 => DON'T LOOK FOR IMP PADDING BIT
	SKIPG IMPILC+1	;SKIP IF BLKI HASN'T RUN OUT(JSR IN IMPILC+1)
	JRST IMPB4A
	MOVE A,IMPIWD
	AOS B,IMBLKI
	MOVEM A,(B)
	MOVE A,[JSR IMPIBK]
	MOVEM A,IMPILC
	SETZB E,IMPIH
	MOVEI A,NETCHN
	SKIPL IMPOH
	MOVEM A,IMPPIA
IMPBK4:	SETZM IMPILC+1
	SETZM IMPIS	;NORMAL INPUT STATE
	HRRZ C,IMBLKI	;LAST WORD READ INTO
	MOVE D,C
	SUBI C,IMPINB-1	;C HAS NUMBER OF WORDS READ
	CAMGE C,IMPNIW
	JRST 4,.	;MESSAGE IS SHORT
IFN BBNTB,JRST IMPBK5
	JUMPL E,IMPBK5
	SKIPE (D)	;REMOVE PADDING AND MARKER BIT
	JRST IMPBK6	;LAST WORD CONTAINS MARKER BIT
	SOS D,IMBLKI	;THIS WORD BETTER HAVE IT
	SKIPN (D)
	JRST 4,.	;NO MARKER BIT IN LAST 64 BITS
IMPBK6:	MOVN C,(D)
	ANDCAM C,(D)	;TURN OFF THE MARKER BIT
IMPBK5:	MOVE A,IMPCBC	;NUMBER OF BYTES
	MOVE B,[441000,,IMPINB]	;8 BIT BYTE POINTER TO MESSAGE
	SETZM IMPNEA
	SETZM IMPNRA
IMPBKL:	SOJL A,IMPRET
	ILDB C,B
	CAILE C,13.
	JRST IMPPRE	;ILLEGAL OPCODE
	JRST @IMPCDT(C)	;DISPATCH ON OPCODE

IMPB4A:	SKIPN IMPIWD	;CHECK FOR SCREW CASE
	SKIPE IMPILC+1
	JRST IMPBK4
	MOVEI E,0	;BLKI RAN OUT, VERY NEXT WORD WAS LAST IMP WORD
	JRST IMPBK4	;AND THAT WORD WAS 0.  => PADDING BIT WAS IN PREV WORD

IMPCDT:	IMPBKL	;NOP	( 0)
	IMPRFC	;RTS	( 1)
	IMPRFC	;STR	( 2)
	IMPCLS	;CLS	( 3)
	IMPALL	;ALL	( 4)
	IMPIRT	;	[JRST 4,.]	;GVB	( 5)
	IMPIRT	;	[JRST 4,.]	;RET	( 6)
	IMPIRT	;	[JRST 4,.]	;INR	( 7)
	IMPIRT	;	[JRST 4,.]	;INS	(10)
	IMPECO	;ECO	(11)
	IMPIRT	;	[JRST 4,.]	;ERP	(12)
	IMPIRT	;	[JRST 4,.]	;ERR	(13)
	IMPRST	;RST	(14)
	IMPRRP	;RRP	(15)

;RFC RECEIVED  C HAS OPCODE
IMPRFC:	CAIGE A,9	;MUST BE AT LEAST 9 MORE BYTES
	JRST IMPPRE	;MESSAGE IS SHORT
	ILDB D,B	;D GETS 32 BIT FOREIGN SOCKET NUMBER
REPEAT 3,[
	LSH D,8
	ILDB T,B
	IORI D,(T)
]
	ILDB E,B	;E GETS 32 BIT LOCAL SOCKET NUMBER
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	ILDB R,B	;LINK NUMBER OR BYTE SIZE
	SUBI A,9
	MOVE Q,E
	EQVI Q,(C)	;Q 1.1 = 1 IF E 1.1 = C 1.1
	ANDI Q,1
	JUMPE Q,IMPPRE	;WRONG DIRECTION RFC
	CAIE C,2	;SKIP IF STR
	JRST IMPRF5
	CAILE R,36.	;SKIP IF STR AND BYTE SIZE < 37
	JRST IMREFU	;REFUSE CONNECTION
IMPRF5:	PUSHJ P,IMPLLS	;LOOK FOR LOCAL SOCKET (RET INDEX IN I)
	JRST IMPRFQ	;NO SUCH SOCKET.  QUEUE IT
	HRRZ W,IMSOC4(I)	;SOCKET STATE
	CAIE W,1	;SKIP IF LISTENING
	JRST IMPRF4
	MOVEM D,IMSOC3(I)	;STORE FOREIGN SOCKET NUMBER
	MOVE Q,IMPCSH	;FOREIGN HOST NUMBER
	DPB Q,IMSCFH
	MOVEI Q,2
	HRRM Q,IMSOC4(I)	;RFC RECEIVED STATE
	CAIN C,2	;SKIP IF NOT STR
	 JRST IMRF5A	;GO SET CONNECTION BYTE SIZE.
	CAIN C,1	;SKIP IF NOT RTS
	DPB R,IMSCLN	;STORE LINK #
IMRF5B:	PUSHJ P,IMPUIN	;INTERRUPT USER
IMRFCX:	MOVE TT,IMPCSH
	IDIVI TT,12.
	MOVEI Q,2
	DPB Q,IMHSBT(I)	;MARK HOST UP
	JRST IMPBKL

IMRF5A:	DPB R,IMSCBS	;SET CONNECTION BYTE SIZE,
	PUSHJ P,IMCMBS	;LOSE IF BYTE SIZES DIFFER.
	 JRST IMCLDA
	JRST IMRF5B

IMPRF4:	CAIE W,4	;SKIP IF IN RFC SENT STATE
	JRST IMPRFQ	;QUEUE IT
	AOS IMSOC4(I)	;PUT INTO STATE 5 - OPEN
	CAIE C,1	;SKIP IF RTS
	JRST IMPRF2	;STR
	DPB R,IMSCLN	;STORE LINK #
IMPRF1:	PUSHJ P,IMPUIN	;INTERRUPT USER
	JRST IMPBKL

IMPRF3:	AOS IMNANS
	JRST IMPRF1

IMPRF2:	DPB R,IMSCBS	;SET CONNECTION BYTE SIZE
	PUSHJ P,IMCMBS	;SWITCH TO 1-BIT BYTES IF BYTE SIZES DIFFER.
	 JRST IMCLDA
	JSP T,IMSTCM
	8,,2	;TEXT: 8 BYTES, 2 WORDS
	JRST IMPRF3
	MOVEI H,2(I)
	LSH H,20.	;LINK #
	IORI H,20._4	;MESSAGE ALLOCATION = 20.
	IOR H,[4_28.]	;ALL
	MOVEM H,4(Q)
	MOVEI H,2944._4
	MOVEM H,5(Q)	;BIT ALLOCATION = 2944.
	PUSHJ P,IMWCQ	;SEND IT OUT
	JRST IMPRF1

IMPRFQ:	MOVSI Q,-NSPSOC
	CAME E,SPSCTB(Q)
	AOBJN Q,.-1
	JUMPGE Q,IMRFQ5
	MOVE T,IMPCSH
	CAIE T,IMPUS
	SKIPL NETUSW
	JRST IMRFQ8
	JRST IMREFU	;REFUSE CONNECTION

IMRFQ8:	HRRO T,SPSCT1(Q)
	PUSHJ P,NUJBST	;LOAD SERVER TELNET
	JRST IMREFU	;RING BUFFER FULL
IMRFQ5:	SKIPGE Q,IMFFPQ	;SKIP IF ANY FREE SLOTS
	JRST IMRFQ1	;CLS OLDEST
	MOVE W,(Q)
	MOVEM W,IMFFPQ	;NEW FIRST FREE
IMRFQ9:	SETOM (Q)	;END OF QUEUE
	MOVEM E,1(Q)	;LOCAL SOCKET NUMBER
	MOVEM D,2(Q)	;FOREIGN SOCKET NUMBER
	CAIE C,2	;SKIP IF STR
	TLO R,400000	;MARK AS RTS
	MOVEM R,3(Q)	;LINK NUMBER OR BYTE SIZE
	MOVE W,IMPCSH
	DPB W,[101000,,3(Q)]	;FOREIGN HOST NUMBER
	SKIPGE W,IMPEPQ	;END OF QUEUE
	JRST IMRFQ2	;QUEUE EMPTY
	MOVEM Q,(W)	;PUT IN AT END OF QUEUE
	MOVEM Q,IMPEPQ	;NEW END OF QUEUE
	JRST IMRFCX

IMRFQ2:	MOVEM Q,IMPEPQ	;END OF QUEUE
	MOVEM Q,IMPBPQ	;AND BEGINNING OF QUEUE
	JRST IMRFCX

IMRFQ1:	PUSHJ P,IMGCQS	;GET PI CONTROL QUEUE SLOT IN Q
	JRST IMRFQ3	;NONE AVAILABLE
	MOVE J,IMPBPQ	;BEGINNING OF PENDING QUEUE
	LDB H,[101000,,3(J)]
	LSH H,IMDEST	;FOREIGN HOST NUMBER
	MOVEM H,2(Q)	;MESSAGE TYPE = 0  LINK # = 0
	MOVE H,[8_24.+12._8]	;BYTE SIZE = 8, BYTE COUNT = 12.
	MOVEM H,3(Q)
	MOVEI H,3_4	;3 NOPS + CLS
	MOVEM H,4(Q)
	MOVE H,1(J)
	LSH H,4
	MOVEM H,5(Q)	;LOCAL SOCKET NUMBER
	MOVE H,2(J)
	LSH H,4
	MOVEM H,6(Q)	;FOREIGN SOCKET NUMBER
	MOVEI H,3
	MOVEM H,1(Q)	;TEXT LENGTH
	PUSHJ P,IMWCQ	;SEND CLS
	AOSA IMNRFC	;# RFCS CLOSED
IMRFQ3:	AOS IMNRFI	;# RFCS IGNORED
	MOVE Q,IMPBPQ	;FLUSH FIRST ENTRY ON PENDING QUEUE
	MOVE W,(Q)
	MOVEM W,IMPBPQ
	JRST IMRFQ9

IMREFU:	PUSHJ P,IMPSCL	;SEND CLS
	AOS IMNCNS
	AOS IMNRFI
	JRST IMPBKL


IMPCLS:	CAIGE A,8	;MUST BE AT LEAST 8 MORE BYTES
	JRST IMPPRE	;MESSAGE IS SHORT
	ILDB D,B	;D GETS 32 BIT FOREIGN SOCKET NUMBER
REPEAT 3,[
	LSH D,8
	ILDB T,B
	IORI D,(T)
]
	ILDB E,B	;E GETS 32 BIT LOCAL SOCKET NUMBER
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	SUBI A,8
	MOVE H,IMPCSH
	PUSHJ P,IMPLC	;LOOK FOR CONNECTION
	JRST IMCLSQ	;LOOK IN QUEUE
	HRRZ W,IMSOC4(I)	;STATE
	JRST @IMCLDT(W)

IMCLDT:	IMPCLI	; 0
	IMPCLI	; 1
	IM2CLS	; 2
	IMPCLI	; 3
	IM4CLS	; 4
	IM4CLS	; 5
	IM4CLS	; 6
	IM7CLS	; 7
	IMPCLI	;10
	IMECLS	;11

IMECLS:	MOVEI W,10
	JRST IMCCLS

IMCLDA:	HLLZS IMSOC4(I)
	MOVEI W,6	;BYTE MISMATCH
	JRST IMCLDB

IM4CLS:	TDZA W,W
IM2CLS:	MOVEI W,3
IMCCLS:	HRRM W,IMSOC4(I)	;CHANGE STATE
	MOVEI W,2
IMCLDB:	MOVEM W,IMSCLS(I)	;CLS REASON
	PUSHJ P,IMPUIN	;INTERRUPT USER
IMCLQ2:	PUSHJ P,IMPSCL	;SEND CLS
	AOS IMNCNS
	JRST IMPBKL

IMPSCL:	JSP T,IMSTCM	;SEND A CLS TO LOCAL SOCKET IN E AND FOREIGN SOCKET IN D (CLOBBERS D AND E)
	12.,,3	;TEXT: 12 BYTES, 3 WORDS
	POPJ P,
	MOVEI H,3_4	;3 NOPS + CLS
	MOVEM H,4(Q)
	LSH E,4
	MOVEM E,5(Q)	;LOCAL SOCKET NUMBER
	LSH D,4
	MOVEM D,6(Q)	;FOREIGN SOCKET NUMBER
	PUSHJ P,IMWCQ	;SEND CLS
	JRST POPJ1

IMPCLI:	AOS IMNCLI
	JRST IMPBKL

IM7CLS:	SETZM IMSOC1(I)	;FLUSH SOCKET
	SOS IMNCS
	JRST IMPBKL

IMCLSQ:	PUSH P,A
	PUSH P,B
	MOVE A,E	;LOCAL SOCKET NUMBER
	MOVEI T,0
	MOVE B,D	;FOREIGN SOCKET NUMBER
	PUSHJ P,IMSPQP	;SEARCH PENDING QUEUE
	JRST IMCLQ1	;NOT THERE
	MOVE E,A
	POP P,B
	POP P,A
	JRST IMCLQ2	;SEND HIM A CLS

IMCLQ1:	POP P,B
	POP P,A
	JRST IMPCLI	;CAN'T FIND HIM.  IGNORE

IMPALL:	CAIGE A,7	;MUST BE AT LEAST 7 MORE BYTES
	JRST IMPPRE	;MESSAGE IS SHORT
IMDAL2:	ILDB R,B	;LINK #
	ILDB D,B
	LSH D,8
	ILDB T,B
	IORI D,(T)	;D GETS MESSAGE ALLOCATION
	ILDB E,B	;E GETS BIT ALLOCATION
REPEAT 3,[
	LSH E,8
	ILDB T,B
	IORI E,(T)
]
	SUBI A,7
IMDAL1:	MOVE T,IMPCSH	;FOREIGN HOST
	LSH T,8
	IOR R,T	;HEADER (HOST AND LINK #)
	MOVEI W,1	;TO TEST DIRECTION OF SOCKET
	MOVSI I,-IMPSTL
IMPAL2:	LDB T,IMSCHD	;FOREIGN HOST AND LINK NUMBER
	SKIPE IMSOC1(I)	;SKIP IF SLOT NOT IN USE
	CAME T,R	;SKIP IF HEADER AGREES
	JRST IMPAL1
	TDNE W,IMSOC2(I)	;SKIP IF NOT SEND
	JRST IMPAL3
IMPAL1:	AOBJN I,IMPAL2
IMBALI:	AOS IMNALI
	JRST IMPBKL	;IGNORE

IMPAL3:	JUMPL D,IMBALI
	JUMPL E,IMBALI
	SKIPL IMSOC8(I)
	SKIPGE IMSOC7(I)
	JRST 4,.
	ADDB D,IMSOC8(I)	;INCREASE ALLOCATIONS
	ADDB E,IMSOC7(I)
	MOVSI T,1
	SKIPGE IMSOC7(I)
	MOVEM T,IMSOC7(I)
	MOVEI T,100000
	SKIPGE IMSOC8(I)
	MOVEM T,IMSOC8(I)
IFN NETDEB,[
	MOVE T,IMPCSH
	CAIE T,IMPUS
	JRST IMPBKL
	CAIG D,20.
	CAILE E,2944.
	JRST 4,.	;ALLOCS SCREWED UP COMMUNICATING WITH OURSELVES
]
	JRST IMPBKL

IMPLLS:	MOVSI I,-IMPSTL	;LOOK FOR SOCKET IN E
	MOVSI W,200000
IMPLL2:	TDNN W,IMSOC1(I)
	SKIPN IMSOC1(I)	;NOT IN USE
	JRST IMPLL1
	CAME E,IMSOC2(I)	;SKIP IF RIGHT LOCAL SOCKET NUMBER
IMPLL1:	AOBJN I,IMPLL2
	JUMPL I,POPJ1	;RETURN SOCKET TABLE INDEX IN RH OF I
	POPJ P,		;NOT FOUND

IMPUIN:
IMPUIF:	MOVSI U,200000
	TDNE U,IMSOC1(I)
	POPJ P,	;CHNL BEING CLOSED
	HRRZ U,IMSOC1(I)	;USER INDEX
	LDB Q,[220400,,IMSOC1(I)]	;CHANNEL OPEN ON
IMPUIM:	MOVE Q,CHNBIT(Q)
	TDNE Q,MSKST2(U)	;SKIP IF NOT ENABLED
	IORM Q,IFPIR(U)	;GEN SECOND WORD INTERRUPT
	POPJ P,

;LOOK FOR CONNECTION: LOCAL SOCKET IN E, FOREIGN SOCKET IN D, FOREIGN HOST IN H
IMPLC:	MOVSI I,-IMPSTL
IMPLC2:	SKIPE IMSOC1(I)	;NOT IN USE
	CAME E,IMSOC2(I)	;LOCAL SOCKET NUMBER
	JRST IMPLC1
	LDB T,IMSCFH
	CAMN D,IMSOC3(I)	;FOREIGN SOCKET NUMBER
	CAME H,T
IMPLC1:	AOBJN I,IMPLC2
	JUMPL I,POPJ1
	POPJ P,

IMPECI:	AOS IMPNEI	;WILL EVENTUALLY GIVE JOB TO MAIN PROG
	JRST IMPBKL

IMPECO:	ILDB D,B	;GET 8 BIT DATA TO ECHO
	SUBI A,1
	SKIPE IMPNEA
	JRST IMPECI
	JSP T,IMSTCM
	2,,1	;TEXT: 2 BYTES, 1 WORD
	JRST IMPECI
	LSH D,20.	;DATA TO BE ECHOED
	IOR D,[10._28.]	;ERP
	MOVEM D,4(Q)
	PUSHJ P,IMWCQ	;SEND IT OUT
	AOS IMPNEA
	JRST IMPBKL

IMPRSI:	AOS IMPNRI	;WILL EVENTUALLY GIVE JOB TO MAIN PROG
	JRST IMPBKL

IMPRST:	MOVE I,IMPCSH
	CAIE I,IMPUS	;RST FROM OURSELVES.  JUST SEND RRP
	PUSHJ P,IMPRSR
IMPRS3:	SKIPE IMPNRA
	JRST IMPRSI
	JSP T,IMSTCM
	1,,1	;TEXT: 1 BYTE, 1 WORD
	JRST IMPRSI
	MOVE D,[13._28.]	;RRP
	MOVEM D,4(Q)
	PUSHJ P,IMWCQ	;SEND IT OUT
	PUSHJ P,IMPIOS
	AOS IMPNRA
	JRST IMPBKL

IMPRSR:	MOVSI I,-IMPSTL	;LOOK FOR USERS OF THIS HOST
	MOVSI TT,200000
IMPRS2:	TDNN TT,IMSOC1(I)	;GUY GOING AWAY ANYHOW
	SKIPN IMSOC1(I)
	JRST IMPRS1
	LDB C,IMSCFH	;FOREIGN HOST
	CAME C,IMPCSH
	JRST IMPRS1	;WRONG HOST
	HRRZ C,IMSOC4(I)
	MOVEI D,0
	CAIN C,11
	MOVEI D,10	;INPUT STILL AVAILABLE
	HRRM D,IMSOC4(I)
	MOVEI D,3
	MOVEM D,IMSCLS(I)	;CLS REASON IS RST
	PUSHJ P,IMPUIN	;INTERRUPT USER
IMPRS1:	AOBJN I,IMPRS2
	MOVE TT,IMPCSH
	IDIVI TT,12.
	MOVEI C,0
	DPB C,IMHSBT(I)	;MARK HIM DOWN
	POPJ P,

IMPRRP:	MOVE TT,IMPCSH
	IDIVI TT,12.
	LDB J,IMHSBT(I)
	SOJL J,IMPPRE
	JUMPG J,IMPBKL
	MOVEI J,2
	DPB J,IMHSBT(I)	;MARK HIM UP
	JRST IMPBKL

;GET CONTROL QUEUE SLOT
IMGCQS:	SKIPG IMFCQL	;SKIP IF ANY LEFT
	JRST IMGCQL	;NONE
	SKIPG Q,IMFFCQ	;POINTER TO SLOT
	JRST 4,.
	MOVE W,(Q)
	MOVEM W,IMFFCQ	;PATCH OUT OF FREE LIST
	SETOM (Q)
	SOS W,IMFCQL	;NUMBER FREE LEFT
	CAIN W,1	;SKIP IF MORE THAN ONE LEFT
	SETOM IMPHI	;SET FLAG TO HOLD UP INPUT
	JRST POPJ1

IMGCQL:	AOS IMNPIL
	POPJ P,

IMWCQ:	PUSHJ P,IMWPCQ
	JRST IMPIOS	;START OUTPUT

;ADD BLOCK IN Q TO OUTPUT CONTROL QUEUE
IMWPCQ:
	SETOM (Q)
	SKIPGE H,IMPLCQ
	JRST IMWCQ1	;CONTROL QUEUE EMPTY
	AOSE (H)
	JRST 4,.	;END OF QUEUE DIDN'T POINT TO -1
	MOVEM Q,(H)
	MOVEM Q,IMPLCQ
	POPJ P,

IMWCQ1:	MOVEM Q,IMPLCQ
	MOVEM Q,IMPNCQ
	POPJ P,

;ADD MAIN PROGRAM BLOCK TO PI QUEUE (CALL AT MP LEVEL)
IMPMPQ:	CONO PI,NETOFF
	MOVEI Q,IMPMPL
	PUSHJ P,IMWPCQ
	CONO PI,NETON
	JRST IMPOST

;CALL BY JSP T,IMSTCM
;SET UP STANDARD PI CONTROL MESSAGE
;BYTE COUNT,,TEXT LENGTH
;ERROR RETURN

IMSTCM:	PUSHJ P,IMGCQS	;GET CONTROL QUEUE SLOT IN Q
	JRST 1(T)	;NONE AVAILABLE
	MOVE H,IMPCSH	;FIRST WORD OF HEADER
	LSH H,IMDEST	;MESSAGE TYPE = 0, LINK # = 0
	MOVEM H,2(Q)
	HLRZ H,(T)	;BYTE COUNT
	LSH H,8
	IOR H,[8_24.]	;BYTE SIZE = 8
	MOVEM H,3(Q)
	HRRZ H,(T)
	MOVEM H,1(Q)	;TEXT LENGTH
	JRST 2(T)	;NORMAL RETURN

IMPRM7:	AOS IMNMNC
	TRNE TT,IMPLW
	JRST IMPBK2
	MOVEI B,1
	MOVEM B,IMPIS
	JRST IMPRET

IMPRM1:	MOVE D,IMPCSH
	LSH D,8
	MOVE I,IMPCLN
	IOR D,I	;HEADER
	SUBI I,2	;SOCKET TABLE INDEX
	JUMPL I,IMPRM7	;BAD LINK #
	SKIPN IMSOC1(I)
	JRST IMPRM7	;SOCKET DOESNT EXIST
	MOVEI A,1
	CAIGE I,IMPSTL
	TDNE A,IMSOC2(I)	;SKIP IF RECEIVER
	JRST IMPRM7	;BAD LINK # OR MESSAGE FOR A SENDER
	LDB C,IMSCHD	;HEADER
	CAME D,C	;SEE IF HEADERS AGREE
	JRST IMPRM7	;NOPE
	HRRZ D,IMSOC4(I)
	CAIE D,5
	CAIN D,11
	JRST IMPRMA
	JRST IMPRM7
IMPRMA:	SKIPL IMSOC5(I)	;SKIP IF 32 BIT TRANSFER
	CONO IMP,IMI32C	;SET 36 BIT INPUT
	SKIPGE IMSOC5(I)	;SKIP IF NOT 32 BIT TRANSFER
	CONO IMP,IMI32S	;SET  32 BIT INPUT
	SKIPGE IMSOC6(I)	;SKIP IF NOT LOCKED BY CORE JOB
	JRST IMPRMP	;LOCKED, COME BACK LATER
	DATAI IMP,IMPIWD
	LDB A,IMCBBP
	MOVEM A,IMPCBS
	LDB B,IMBCBP
	MOVEM B,IMPCBC
	SOSGE IMSOC8(I)
	JRST IMRMAF	;MESSAGE ALLOCATION EXCEEDED
	IMUL B,A	;BIT COUNT
	MOVN A,B
	ADDM A,IMSOC7(I)	;REMAINING BIT ALLOCATION
	SKIPGE IMSOC7(I)
	JRST IMRMAH	;BIT ALLOCATION EXCEEDED
	JUMPE A,IMPRMG	;ZERO LENGTH MESSAGE
	TRNE TT,IMPLW
	JRST IMRMAG	;MESSAGE IS SHORT
	MOVSI D,200000
	IORM D,IMSOC6(I)	;ACTIVE AT PI LEVEL
	MOVEI D,36.
	SKIPGE IMSOC5(I)
	MOVEI D,32.
	IDIVI B,(D)
	SKIPE C
	ADDI B,1	;NUMBER OF WORDS MESSAGE WILL TAKE
	HRRZ Q,IMSOC6(I)	;BUFFER ADDRESS
	HRRZ C,(Q)	;NEXT MESSAGE IN
	ADD Q,C
	HRLZM A,(Q)	;STORE MESSAGE POINTER
	MOVNS A
	ADDM A,IMSOCT(I)
	SUB Q,C
	CAIE C,177
	AOJA C,.+2
	MOVEI C,1
	MOVE D,C
	ADD D,B	;ONE WORD AFTER MESSAGE
	CAIL D,200
	SUBI D,177
	MOVEM D,IMPTMP	;STORE IN POINTER AT END OF TRANS.
	SETZM IMNWSI
	CAIE D,1	;MESSAGE FITS EXACTLY
	CAML D,C	;SKIP IF NECESSARY TO RING
	JRST IMPRM8	;MESSAGE FITS
	MOVEI D,200
	SUB D,C		;NUMBER OF WORDS TO READ
	SUB B,D		;NUMBER TO READ SECOND TIME THROUGH
	EXCH B,D
	MOVEM D,IMNWSI
	JUMPLE D,[JRST 4,.]
IMPRM8:	MOVE D,B
	MOVNS B
	HRLZS B
	HRRI B,-1(C)
	ADD B,Q		;BLKI POINTER
	HRRZ E,B
	ADD E,D
	MOVEM E,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	MOVEM I,IMPSVI
	MOVEI C,4
	JRST IMPRM9	;START READING

IMPRMP:	MOVSI D,100000
	IORM D,IMSOC6(I)
	MOVE D,IMPPIA
	MOVEM D,IMPSVI
	SETZM IMPPIA	;TURN OFF NETWORK FOR A WHILE
	JRST IMPRET

IMRMAF:	AOS IMNMAE
IMRMAX:	MOVEI A,1
	TRNE TT,IMPLW
	MOVEI A,0
	MOVEM A,IMPIS	;FLUSH REMAINDER OF MSG
	JRST IMPRET

IMRMAG:	AOS IMNMSS
	JRST IMRMAX

IMRMAH:	AOS IMNBAE
	JRST IMRMAX

;BLKI HAS RUN OUT, ANOTHER WORD WAS AVAILABLE
;BUT IT WASN'T THE LAST IMP WORD
IMPRMC:	SKIPN IMNWSI
	JRST IMPRME
	MOVE I,IMPSVI
	HRRZ Q,IMSOC6(I)	;PLACE -1 TO READ INTO
	MOVE A,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	CAIE A,177(Q)
	JRST 4,.
	HRRZ A,IMBLKI	;ACTUAL LAST BLKI ADDRESS
	CAIE A,177(Q)
	JRST 4,.
	MOVE C,IMPIWD
	MOVEM C,1(Q)
	SOSG A,IMNWSI	;SKIP IF MORE TO READ
	JRST IMPRMN
	MOVEI B,176
	CAMGE A,B
	MOVE B,A	;NUMBER OF WORDS TO READ
	SUB A,B
	MOVEM A,IMNWSI
	MOVE D,B
	MOVNS B
	HRLZS B
	HRRI B,1(Q)
	HRRZ E,B
	ADD E,D
	MOVEM E,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	JRST IMPRMD	;CONTINUE READING

IMPRMN:	MOVEI C,1(Q)
	MOVEM C,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	MOVEM C,IMBLKI	;ACTUAL LAST BLKI ADDRESS
IMPRME:	MOVEI C,5
	MOVEM C,IMPIS	;IGNORE INPUT UNTIL LAST IMP WORD
IMPRMH:	SOS IMPILC+1
	JRST IMPRET

;GOT LAST IMP WORD
IMPRMB:	MOVE I,IMPSVI
	HRRZ Q,IMSOC6(I)
	MOVNI E,1
	SKIPG IMPILC+1	;SKIP IF BLKI HASN'T RUN OUT
	JRST IMPRMJ
	MOVE A,IMPIWD
	AOS B,IMBLKI
	MOVEM A,(B)
	MOVE A,[JSR IMPIBK]
	MOVEM A,IMPILC
	SETZB E,IMPIH
	MOVEI A,NETCHN
	SKIPL IMPOH
	MOVEM A,IMPPIA
IMPRMF:	SETZM IMPILC+1
	MOVE C,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	HRRZ B,IMBLKI
	SKIPN IMNWSI
	CAIGE C,(B)
	JRST 4,.	;MESSAGE SHORT
IFN BBNTB,JRST IMPRML
	JUMPL E,IMPRML
	SKIPE (B)
	JRST IMPRMK
	SUBI B,1
	CAIN Q,(B)
	MOVEI B,177(Q)
	SKIPN (B)
	JRST 4,.
IMPRMK:	MOVN E,(B)
	ANDCAM E,(B)
IMPRML:	MOVEI E,11
	HRRM E,IMSOC4(I)	;INPUT AVAILABLE
	MOVE D,IMPTMP
	HRRZ A,(Q)
	HRRM D,(Q)
	SKIPGE (Q)
	HRLM A,(Q)
	PUSHJ P,IMPUIF
IMPRMG:	MOVSI D,200000
	ANDCAM D,IMSOC6(I)
	SETZM IMPIS
	JRST IMPRET

IMPRMJ:	MOVE A,IMNWSI	;CHECK FOR SCREW CASE:
	CAIE A,1	;ONE EXTRA WORD TO READ AFTER BLKI RUNS OUT
	JRST IMPRMM
	SETZM IMNWSI
	MOVE A,IMPNIW
	CAIE A,177(Q)
	JRST 4,.
	HRRZ A,IMBLKI
	CAIE A,177(Q)
	JRST 4,.
	MOVE C,IMPIWD
	MOVEM C,1(Q)
	MOVEI C,1(Q)
	MOVEM C,IMPNIW	;EXPECTED LAST BLKI ADDRESS
	MOVEM C,IMBLKI	;ACTUAL LAST BLKI ADDRESS
IMPRMM:	SKIPN IMPIWD
	SKIPE IMPILC+1
	JRST IMPRMF
	MOVEI E,0
	JRST IMPRMF

EBLK

IMPOBK:	0

BBLK
	SETOM IMPO
	CONO IMP,NETCHN
	JRST 12,@IMPOBK

;GET HERE PI IN PROG ON NETCHN
;IMP HAS NETCHN PIA, TT HAS CONI WORD
IMPOBZ:	AOS IMCT3
	SKIPL B,IMPOS
	CAILE B,6
	JRST 4,.
	JRST @IMPODT(B)

IMPODT:	IMPOB1	;NOT EXPECTING OUTPUT DONE	(0)
	IMPOB3	;OUTPUT SECOND WORD OF HEADER	(1)
	IMPOB4	;OUTPUT TEXT OF CONTROL MESSAGE	(2)
	IMPOB6	;OUTPUT LAST WORD OF TEXT	(3)
	IMPOBE	;OUTPUT SECOND WORD OF DATA HEADER (4)
	IMPOBF	;OUTPUT TEXT OF DATA (5)
	IMPOBG	;OUTPUT LAST WORD OF DATA TEXT (6)

;LOOK FOR OUTPUT
IMPOB1:	AOSG IMNOPC
	JRST IMONOP	;OUTPUT A NOP
	SETZM IMPUP	;IMP IS UP

;CHECK OUTPUT QUEUES
	MOVEI T,IMPNCQ
IMPOBV:	SKIPGE A,(T)
	JRST IMPOBW
	LDB B,[241000,,2(A)]	;HOST #
	IDIVI B,36.
	MOVEI D,1
	LSH D,(C)
	TDNN D,IMHSRF(B)	;SKIP IF WAITING FOR RFNM
	JRST IMPOB2
	MOVE T,A
	JRST IMPOBV

IMPOBW:	MOVSI I,-IMPSTL
	MOVEI W,1
IMPOBB:	SKIPE IMSOC1(I)	;SKIP IF NOT IN USE
	TDNN W,IMSOC2(I)	;SKIP IF SEND
	JRST IMPOBA
	HRRZ Q,IMSOC6(I)	;OUTPUT BUFFER
	SKIPGE IMSOC6(I)
	JRST IMPOBA	;LOCKED BY CORE JOB
	HRRZ A,IMSOC4(I)
	SKIPL (Q)	;SKIP IF IDLE
	CAIE A,5
IMPOBA:	AOBJN I,IMPOBB
	JUMPL I,IMPOBD
	SETOM IMPOAC	;NO MORE OUTPUT
	CONO IMP,IMPODC	;CLEAR OUTPUT DONE
	JRST IMPRET

IMONOP:	CONO IMP,IMPLHW+IMO32S	;SET OUTPUT TO 32 BIT MODE
	DATAO IMP,IMPNOP
	JRST IMPRET

IMPOB2:	HRL A,T
	MOVEM A,IMPSVO	;SAVE
	SKIPG 1(A)	;TEXT LENGTH
	JRST 4,.
	CONO IMP,IMO32C	;SET OUTPUT TO 36 BIT MODE
	DATAO IMP,2(A)	;SEND FIRST 36 BITS OF HEADER
	AOS IMPOS
	JRST IMPRET

IMPOB3:	MOVE A,IMPSVO
	DATAO IMP,3(A)	;OUTPUT SECOND WORD
	AOS IMPOS	;STATE TO OUTPUT REMAINDER OF MESSAGE
	JRST IMPRET

IMPOB4:	MOVE A,IMPSVO
	MOVE B,1(A)	;LENGTH OF TEXT
	CAIN B,1
	JRST IMPOB7
	MOVEI I,3
	MOVE C,[JSR IMPOB5]
	CONO IMP,IMO32S	;PUT OUTPUT IN 32 BIT MODE
IMPOM4:	MOVEM I,IMPOS
	MOVNI B,-1(B)	;OUTPUT ONE WORD LESS
	HRLZ B,B
	HRRI B,3(A)	;BLKO POINTER
	JUMPGE B,[JRST 4,.]	;BAD BLKO POINTER
	MOVEM B,IMBLKO
IMPOBC:	MOVEM C,IMPOLC+1
	MOVE C,[BLKO IMP,IMBLKO]
	MOVEM C,IMPOLC
	SETOM IMPOH
	MOVEI A,IMPCHN
	MOVEM A,IMPPIA
	JRST IMPRET

EBLK

IMPOB5:	0

BBLK
;BLKO HAS RUN OUT.  IMPOS = 3 OR 6
;WON'T INTERRUPT BACK UNTIL NEXT OUTPUT DONE
	MOVEM A,IMPA
	MOVE A,[JSR IMPOBK]
	MOVEM A,IMPOLC
	SETZM IMPOH
	MOVEI A,NETCHN
	SKIPL IMPIH
	MOVEM A,IMPPIA
	CONO IMP,@IMPPIA
	MOVE A,IMPA
	JRST 12,@IMPOB5

IMPOB6:	MOVE A,IMPSVO
	MOVE B,1(A)
	SETZM IMPOLC+1
IMPOB7:	CONO IMP,IMPLHW	;LAST HOST WORD
	ADDI B,3(A)
	DATAO IMP,(B)
	SETZM IMPOS
	LDB B,[241000,,2(A)]	;HOST #
	IDIVI B,36.
	MOVEI D,1
	LSH D,(C)
	IORM D,IMHSRF(B)	;SET RFNM WAIT
	LDB B,[241000,,2(A)]	;HOST #
	IDIVI B,4
	LDB D,[1100,,TIME]
	DPB D,IMRFTT(C)
	HLRZ T,A
	HRRZS A
	MOVE B,(A)
	MOVEM B,(T)
	JUMPGE B,IMOB7A
	CAME A,IMPLCQ
	JRST 4,.	;IMPLCQ GAVE WRONG LAST MESS NO.
	MOVEM T,IMPLCQ
	CAIN T,IMPNCQ
	SETOM IMPLCQ
IMOB7A:	CAIN A,IMPMPL	;SKIP IF NOT MAIN PROG BLOCK
	JRST IMPOM1
	MOVE B,IMFFCQ
	CAIN B,(A)
	JRST 4,.	;MAKING INFINITE LOOP
	MOVEM B,(A)
	MOVEM A,IMFFCQ
	AOS A,IMFCQL
	SKIPGE B,IMPHI	;RETURN IF INPUT NOT HELD UP
	CAIG A,1	;SKIP IF INPUT HELD UP AND NOW ENOUGH FREE
	JRST IMPRET
	SETZM IMPHI
	AOJE B,IMPRET	;INPUT WAS NOT YET SUCCESSFULLY HELD UP
	AOJN B,[JRST 4,.]	;IMPHI SHOULD HAVE BEEN -2
	DATAI IMP,IMPIWD
	MOVE TT,IMSTAS	;GET OLD CONI
	TRNE TT,IMPLW	;RESUME INPUT
	JRST IMPBKV
	JRST IMPIBV

IMPOM1:	SETOM IMPMPU
	JRST IMPRET

;OUTPUT A MESSAGE.  BUF ADDRESS IN Q
IMPOBD:	MOVE T,TIME
	SUB T,IMSOCT(I)
	SKIPL IMSOC4(I)	;SKIP IF WANT TO SEND THIS BUFFER
	CAIL T,15.	;SKIP IF BUFFER FIRST WRITTEN LESS THAN HALF SEC AGO
	JRST IMOBD1
	JRST IMPOBA
IMOBD1:	MOVSI T,200000
	IORB T,IMSOC6(I)	;ACTIVE AT PI LEVEL
	HLRZ A,(Q)	;NEXT MESSAGE OUT
	ADD A,Q	;ADDRESS OF POINTER WORD
	XOR T,A
	TRNE T,777600
	JRST 4,.	;IMSOC6 AND THIS PNTR SHOULD PNT AT SAME 200 WD BUF
	HRL I,A
	MOVEM I,IMPSVO
	HRRZ B,(A)	;# WORDS
	CAIE B,3
	SKIPL IMSOC5(I)	;SKIP IF 32 BIT TRANSFER
	JRST IMPOBJ	;SEND ALL AT ONCE
	CONO IMP,IMO32C	;SET 36 BIT MODE OUTPUT
	DATAO IMP,1(A)	;FIRST WORD OF HEADER
	MOVEI I,4
	MOVEM I,IMPOS
	JRST IMPRET

IMPOBE:	HLRZ A,IMPSVO
	DATAO IMP,2(A)	;SECOND WORD OF HEADER
	AOS IMPOS
	JRST IMPRET

IMPOBF:	MOVE I,IMPSVO
	HLRZ A,I
	SKIPL IMSOC5(I)
	JRST 4,.
	CONO IMP,IMO32S
	HRRZ B,(A)	;# WORDS (2 FOR HEADER)
	CAIG B,3
	JRST 4,.
	SUBI B,2
IMPOBI:	MOVEI I,6
	MOVE C,[JSR IMPOB5]
	SOJA A,IMPOM4

IMPOBG:	MOVE I,IMPSVO
	HLRZ A,I
	SETZM IMPOLC+1
	CONO IMP,IMPLHW	;LAST HOST WORD
	HRRZ B,(A)	;# WORDS
	ADDI B,(A)
	DATAO IMP,(B)
	HRRZ Q,IMSOC4(I)
	CAIN Q,5
	AOS IMSOC4(I)	;RFMN WAIT STATE
	SETZM IMPOS
	MOVSI Q,200000
	ANDCAB Q,IMSOC6(I)
	HLRE B,(A)
	HRLM B,(Q)
	JUMPGE B,IMPRET
	SETZM IMSCIP(I)
	MOVSI T,400000
	ANDCAM T,IMSOC4(I)	;TURN OF "SEND ME" BIT
	JRST IMPRET

IMPOBJ:	CONO IMP,IMO32C	;SEND IN 36 BIT MODE
	HRRZ B,(A)	;# WORDS (2 FOR HEADER)
	SUBI A,2
	JRST IMPOBI
