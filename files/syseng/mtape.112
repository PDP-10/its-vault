
IFG NMTCS,[		;BEGIN MAG TAPE ROUTINES

;RANDOM SYMBOL DEFINITIONS

MAGVRS==.IFNM2	;FILE NAME 2 OF MAGTAPE ROUTINES
MSCBL==10.	;MAXIMUM # COMMANDS PER TRANSPORT
MGQDLL==4	;LENGTH OF XPT INTERRUPT LEVEL QDL
MTCRH==040200+MTCCHN_3	;NORMAL CONO MTC, RIGHT HALF
MTDFRS==2000		;DEFAULT RECORD SIZE (ALSO MAXIMUM, BUT THAT NOT SYMBOLIC)
TNMTCS==NMTCS+1		;"TOTAL" # TRANSPORTS, EXTRA FOR .STATUS, ETC.
MSMAXB==6		;MAXIMUM NUMBER OF 1K BUFFERS
MGMAXE==6		;MAXIMUM NUMBER OF ERRORS AT INTERRUPT LEVEL BEFORE GIVING UP
MTXP==410300,,	;BYTE POINTER TO TRANSPORT # IN LH(IOCHNM)
MTCHNA==200_<-MTCCHN>

	;MEMBLT TABLE FIELDS FOR MAGTAPE BUFFERS
;MLO (8 BITS) LINK TO NEXT BUFFER, OR 0=> NONE
MSMWC==101300	;BYTE POINTER TO WORD COUNT FIELD
MSEOFP==230100		;BYTE POINTER TO EOF BIT IN MEMBLT TABLE (1 => THIS LAST BUFFER IN FILE)
;MUR CONTAINS MUMGB, TELLS CORE JOB PAGE IS MAGTAPE BUFFER

	;MSERCT FLAGS (IN LH(CONI MTS,))
MGS00==400000	;ERROR OCCURRED DURING ATTEMPED READ
MGS01==440000	;WRITE OR READ/COMPARE
MGS10==500000	;OTHER, NOT WRITING ON TAPE
MGS11==540000	;OTHER, WRITING ON TAPE
MGS40==200000	;(WITH ONE OF ABOVE) ERROR INCIDENTAL TO MAIN OPERATION IN PROGRESS
		;(E.G. COULDN'T SELECT XPT OR LOST WHILE SPACING TO RECOVER FROM ERROR)

;CODING CONVENTIONS
;SYMBOL NAMES
	;MT => USED MAINLY AT MAIN PGM LEVEL
	;MG => INTERRUPT LEVEL
	;MS => BOTH
;ACCUMULATORS
	;W HAS GARBAGE,,TRANSPORT NUMBER
	;H DURING READ .IOT HAS SAVED C(P) FOR EOF
	;R AT MAIN PROGRAM LEVEL POINTS TO IOCHNM
	;Q AT INTERRUPT LEVEL HAS PDL POINTER
	;C AT INTERRUPT LEVEL FREQUENTLY HAS CONI MTS,;IF NOT THEN SHOULD BE .GE. 0

;ROUTINES NOT WRITTEN YET

SNDMTC==SNDDEV	;.RCHST
STAMTC==STDSTA	;.STATUS
NMTAPE==CPOPJ	;CALL MTAPE (FOR NOW, ALWAYS FAILS)

DEFINE MGBKCM
	CONI MTC,A	;GET MTC CONI FOR ASSIGNMENT, PIA, ETC.
	CONI MTS,C	;GET MTS CONI FOR FLAGS
	TRNN A,400	;IF NEXT UNIT NOT ENABLED,
	TRZ C,2		;THEN TURN OFF NEXT UNIT FLAG
	TRNE A,MTCCHN&#DCCHN	;SKIP UNLESS DATA PIA = MTCCHN
	TRNN C,1	;DATA PIA = MTCCHN, DATA FLAG SET?
	TRNE C,440102	;CHECK ALL OTHER FLAGS
IFN DSDP,	JUMPL A,MGHBRK	;INTERRUPT FLAG(S) SET, JUMP IF ASSIGNED
IFE DSDP,	JRST MGHBRK
TERMIN	;END OF MACRO, EXECUTED DURING UTCBRK

IFE <3-.TYPE AMSPAC >,AMSPAC=0
IFDEF AMSPACE,[
	;.MSPACE ACI,
	;SPACE MT0 ACCORDING TO ACI (INTERPRETED IMMEDIATE)
	;DOES IT AND SKIPS IF PROCEDURE HAS MT0, OTHERWISE DOESN'T SKIP

SPCTBL:	JRST MTRW1	;0 => REWIND
	TROA B,MGSEOT	;1 => SPACE TO LOGICAL EOT
	PUSHJ P,MTWEOF	;2 => WRITE EOF IF APPROPRIATE
	REPEAT SPCTBL+17-.,POPJ P,	;UNASSIGNED VALUES DON'T SKIP
	PUSHJ P,MTWT	;17 => HANG UNTIL INTERRUPT ROUTINE DIES

AMSPACE=.	;RECLOBBER DEFINITION
	CAME U,MTUSR	;THIS PROCEDURE HAVE MT0?
	POPJ P,		;NO
	MOVE T,MTUCHN'	;GET CHANNEL OPEN
	MOVEM T,UUAC(U)	;SO ERR GOES TO RIGHT CHNL
	SETZB W,B	;WORKING WITH XPT 0
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	XCT SPCTBL(J)	;DO APPROPRIATE THING ON BASIS OF AC
	JRST POPJ1	;THIS FOR MAYBE DISPATCH TO NON-SKIP ROUTINE
	PUSH P,B	;INSTRUCTION SKIPPED, INTERRUPT DISPATCH IN B
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTICL2	;FLUSH READ ROUTINE IF ANY
	PUSHJ P,MTWEOF	;WRITE EOF IF APPROPRIATE
	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	POP P,B		;RESTORE ADDRESS OF INTERRUPT ROUTINE TO GO TO
	JRST MTCMD1	;START IT UP, RETURN

]		;END .MSPAC CONDITIONAL

IFNDEF OPNTD7,OPNTD7:
IFE OPNTD7-.,[
OPNTD7:	TRZ D,-4
	ADDI D,(Q)
	HLR C,(D)
	TLNE D,400000
	HRR C,(D)	;OUTPUT
	MOVEM C,(R)
	JRST CLKOJ1
]

		;REWIND

MTRW1:	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTICL2	;INPUT, FLUSH READ ROUTINE & BUFFERS
	PUSHJ P,MTWEOF	;MAYBE WRITE EOF
	PUSHJ P,MTIECK	;VERSION TO MAYBE TAKE IOC ERROR
	PUSHJ P,MTRMWT	;NORMAL ENTRY (SKIP-RETURNS)
	MOVSI A,400004	;GET MASK OF EOF BITS
	ANDCAM A,MSMODE(W)	;TURN OFF EOF BITS IN MSMODE
	JSP B,MTCMD1	;START UP INTERRUPT ROUTINE AT .+1, SKIP-RETURN

MGRW:	MOVSI A,MGS10	;GET HERE AT INTERRUPT LEVEL
	MOVEM A,MGRSB(W)	;STORE ROUTINE SPECIFICATION BITS
	PUSHJ Q,MGMTCG	;GET MTC
	JRST MGFD
	MOVEI C,1000	;REWIND
	PUSHJ Q,MGCMDX	;DO IT
	TRNE C,440000	;CHECK XPT HUNG, ILLOP
	MOVEM C,MSERCT(W)	;SOMETHING WRONG, STORE ERROR CONI
	JRST MGFM	;RELEASE MTC AND RETURN

		;WAIT FOR REWINDING TO FINISH
		;SKIPS EXCEPT ON PCLSR FROM WAITING FOR IDLE; MSRPCL SHOULD INITIALLY BE 0

MTRWWT:	MOVEI B,MGRWWT	;SET UP COMMAND
	PUSHJ P,MTCMD	;START UP INTERRUPT ROUTINE
	PUSHJ P,MTWTP	;WAIT FOR IDLE, SKIP UNLESS PCLSR
	SOSA MSRPCL(W)	;PCLSR, CAUSE QUIT
	AOS (P)		;NO PCLSR, CAUSE RETURN TO SKIP
	POPJ P,

MGRWWT:	PUSHJ Q,MGMALC	;INTERRUPT ROUTINE: GET MTC
	MOVEI C,400	;NO-OP, NEXT UNIT ENABLE
	PUSHJ Q,MGCMDX	;DO IT, WAIT FOR INTERRUPT
	CONO MTC,0	;FREE MTC
	TRNE C,40	;CHECK IDLE FLAG
	JRST MGF	;IDLE => DONE
	TRNN C,200000	;SKIP IF REWINDING
	SOSLE MSERCT(W)	;NOT IDLE BUT NOT REWINDING, DECREMENT COUNTDOWN TO LOSSAGE
	SKIPE MSRPCL(W)	;SKIP IF MAIN PROGRAM DOESN'T WANT QUIT
	JRST MGFD	;QUIT
	MOVEI B,MGCKL2
	PUSHJ Q,MGBLST	;WAIT TWO SLOW CLOCK TICKS
	JRST MGRWWT	;TRY AGAIN

		;SKIP TO LOGICAL END OF TAPE

MGSEOT:	MOVSI A,MGS10	;GET HERE AT INTERRUPT LEVEL
	MOVEM A,MGRSB(W)	;STORE ROUTINE SPECIFICATION BITS
	PUSHJ Q,MGMTCG	;GOBBLE MTC
	JRST MGFD	;LOSE
MGEOT2:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGFM	;REAL END OF TAPE
	MOVEI C,16000	;SPACE FORWARD TO EOF
	PUSHJ Q,MGSPAC	;DO IT, PROCESS ERROR CONDITIONS
	JRST MGFMC	;ERROR
	PUSHJ Q,MGMFGT	;MAYBE GIVE UP MTC FOR AWHILE
	 JRST MGFD
	MOVEI C,12000	;READ ACROSS RECORD BOUNDARIES
	PUSHJ Q,MGCMDX	;START READING
	TRNE C,440000	;CHECK XPT HUNG, ILLOP
	JRST MGFMC	;ERROR
	TRNE C,400	;CHECK DATA LATE
	JRST MGEOT2	;SET, LOOP BACK FOR NEXT FILE
	TRNN C,10000	;CHECK EOF FLAG
	JRST MGFMC	;NOT SET
	JRST MGWEF2	;SPACE BACK OVER SECOND ONE
		;MAGTAPE .OPEN

MAGTO:	SKIPL W,I	;GET DEVICE NUMBER INTO W
	CAIL W,NMTCS	;TOO BIG?
	JRST OPNL1	;NO SUCH DEVICE (NUMBER OUT OF RANGE)
	LDB H,[430100,,D]	;GET DIRECTION BIT OF THIS PROPOSED OPEN (STAYS AROUND AWHILE)
	CONO PI,CLKOFF
	SKIPGE MTUSR(W)	;THIS TRANSPORT IN USE?
	MOVEM U,MTUSR(W)	;NO, RESERVE IT
	CAME U,MTUSR(W)	;HAVE TRANSPORT?
	JRST OPNL10	;NO, MUST NOT BE AVAILABLE
	SKIPGE MTUSE(W)	;THIS TO BE FIRST .OPEN THIS XPT?
	JRST MTOW1	;YES
MAGTO1:	JRST OPNL12	;NO (EVENTUALLY FLUSH)
	LDB E,MTOCBP(H)	;GET # TIMES OPEN THIS DIRECTION
	CAIL E,17	;ALREADY OPEN 17 TIMES?
	JRST OPNL12	;OPEN TOO MANY TIMES ("MODE NOT AVAILABLE")
	MOVE T,MTOCHM(H)	;GET CHARACTER MODE BIT THIS DIRECTION
	MOVE TT,MTONCM(H)	;GET NON-CHARACTER MODE BIT THIS DIRECTION
	TLNN C,6	;SKIP UNLESS .OPEN IS FOR CHARACTER MODE
	EXCH T,TT	;CHARACTER MODE
	TDNE T,MSMODE(W)	;SKIP UNLESS ALREADY OPENED IN THE OTHER MODE
	JRST OPNL12	;NOT ALLOWED TO OPEN IN CHARACTER AND NON-CHAR MODE SIMULTANEOUSLY IN THE SAME DIRECTION
	IORM TT,MSMODE(W)	;DOCUMENT WHICH MODE-TYPE OPENED IN
	AOJ E,		;INCREMENT # TIMES OPEN THIS DIRECTION
	DPB E,MTOCBP(H)	;STORE # TIMES OPEN THIS DIRECTION
	AOS MTUSE(W)	;ANOTHER OPEN THIS TRANSPORT
MTOW:	IFDEF MTUCHN,[MOVE Q,UUAC(U)	;CHNL
	MOVEM Q,MTUCHN	;SAVE FOR .MSPACE
]	JSP Q,OPNTD7	;SET UP IOCHNM AND SKIP-RETURN
	 MTUAIX,,MTUAOX	;UNIT ASCII (CHARACTER) INPUT,,OUTPUT
	 MTBIX,,MTBOX	;BLOCK (ASCII)
	 MTUIIX,,MTUIOX	;UNIT IMAGE
	 MTBIX,,MTBOX	;BLOCK (IMAGE)

MTOW1:
IFN DSDP,[
	SKIPL MTCUSE	;THIS FIRST .OPEN THIS XPT; FIRST OPEN ANY XPT?
	JRST MTOW2	;NO
	CONO MTC,0	;YES, MTC PROBABLY NOT ASSIGNED, TRY ASSIGNING IT
	CONI MTC,T	;NOW SEE IF WINNAGE
	JUMPL T,MTOW2	;JUMP (WIN) IF ASSIGNED TO PROCESSOR
	SETOM MTUSR(W)	;LOSE, RELEASE THIS TRANSPORT
	JRST OPNL25	;DEVICE NOT ASSIGNABLE TO THIS PROCESSOR
]
MTOW2:	AOS MTCUSE	;SURVIVED TESTS SO FAR, SAY ANOTHER XPT ROUTINE OPEN
	AOS MTUSE(W)	;ANOTHER OPEN THIS TRANSPORT
	CONO PI,CLKON	;NO LONGER NEED TO INHIBIT INTERRUPTS
	SETZM MSRPCL(W)	;CLEAR OUT STOP REQUEST
	SETZM MSERCT(W)	;CLEAR OUT STOP FLAG
	PUSHJ P,MTRWWT	;WAIT FOR REWIND TO FINISH
	JRST MTIOL1	;PCLSR
	PUSHJ P,MTSTAT	;GET MTC AND MTS CONI'S INTO I AND J
	JRST MTIOL1	;PCLSRED OUT
	TRNE J,200040	;CHECK REWINDING, XPT IDLE
	TDZA A,A	;AT LEAST ONE SET => OK
	MOVEI A,OPNL7	;DEVICE NOT READY (NOT REALLY THERE)
	JUMPGE D,MTOW2B	;JUMP IF OPEN IS FOR INPUT
	TRNE J,10	;OUTPUT, CHECK WRITE LOCK
	MOVEI A,OPNL26	;DEVICE WRITE-LOCKED
MTOW2B:	JUMPE A,MTOW3	;JUMP IF OPEN SHOULD WIN
	PUSH P,A	;LOSE, SAVE OPNL# AS RETURN
	JRST MTIOL1	;DECREMENT MTCUSE AND RETURN

	;CONTINUATION OF MTAPE .OPEN

MTOW3:	MOVE A,[100000,,MTDFRS]
	DPB H,[430100,,A]	;DEPOSIT DIRECTION BIT
	MOVEM A,MTBFS(W)	;STORE MTBFS
	MOVEI A,MTCRH
	DPB A,[1700,,MGCMD(W)]	;STORE COMMAND TO MTC (HAS DENSITY AND PARITY INDICATION)
	TLNN C,6	;CHECK FOR CHARACTER MODE
	SKIPA A,MTOCHM(H)	;CHARACTER MODE, GET CHAR. MODE BIT
	MOVE A,MTONCM(H)	;NON-CHARACTER MODE, GET BIT
	MOVEM A,MSMODE(W)	;STORE MSMODE
	MOVEI A,1
	DPB A,MTOCBP(H)	;OPEN ONCE THIS DIRECTION
	SETZM MTBUFC(W)	;CLEAR OUT COUNT IN BUFFER
	SETZM MTBUFO(W)	;ALSO INDICATE NO BUFFER
	JRST MTOW

		;THESE (CLOSE) ROUTINES GET TO BE COMPLETELY REWRITTEN EVENTUALLY

MTOCLS:	MOVEI H,1	;OUTPUT
	PUSHJ P,MTCLSC	;EXECUTE PRELIMINARY COMMON CODING
	PUSHJ P,MTWEOF	;WRITE EOF IF APPROPRIATE
MTICL9:	PUSHJ P,MTWT	;WAIT FOR IDLE (MAYBE TAKE IOC ERROR)
	JUMPG I,MTICL8	;JUMP IF MORE OPENS THIS DIRECTION
	MOVE T,MTOCHM(H)	;GET CHARACTER MODE BIT
	IOR T,MTONCM(H)		;IOR IN NON-CHAR BIT
	ANDCAM T,MSMODE(W)	;NOT OPEN EITHER IN CHAR MODE OR NON-CHAR MODE THIS DIRECTION
MTICL8:	DPB I,MTOCBP(H)	;STORE NEW # TIMES OPEN THIS DIRECTION
MTIOL1:	CONO PI,CLKOFF
	SOSL MTUSE(W)
	JRST CLKONJ
	SETOM MTUSR(W)
IFN DSDP,[
	SOSGE MTCUSE
	DATAO DSDEV,[DSMTC]
]
IFE DSDP,	SOS MTCUSE
	JRST CLKONJ

MTICLS:	MOVEI H,0	;INPUT
	PUSHJ P,MTCLSC	;EXECUTE PRELIMINARY COMMON CODING
	JUMPG I,MTICL9	;SKIP FOLLOWING IF MORE .OPENS FOR READ
	PUSHJ P,MTICL2	;FLUSH READ BUFFERS AND READ ROUTINE
	JRST MTICL9	;NOW FINISH .CLOSE

		;COMMON CODING FOR MTAPE .CLOSE

MTCLSC:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER
	LDB I,MTOCBP(H)	;GET # TIMES OPEN THIS DIRECTION
	SOJA I,MTIEC0	;DECREMENT, MAYBE TAKE IOC ERROR, BUT DO .RESET IF OTHERWISE
		;WOULD RESTART STOPPED ROUTINE

MTOCBP:	110400,,MSMODE(W)	;BYTE POINTER TO # TIMES OPEN FOR READ
	150400,,MSMODE(W)	;WRITING
MTOCHM:	40,,		;MSMODE BIT FOR CHARACTER MODE INPUT
	100,,		;OUTPUT
MTONCM:	200,,		;NON-CHARACTER MODE INPUT
	400,,		;OUTPUT

		;DIRECTION REVERSING ROUTINES

		;SWITCH FROM OUTPUT TO INPUT

MTOIRV:	PUSH P,B	;SAVE B
	PUSHJ P,MTWEOF	;WRITE EOF
	PUSHJ P,MTWT	;WAIT FOR IDLE
	SKIPE MSNBUF(W)	;CHECK TO SEE IF ALL BUFFERS GONE
	JRST 4,.	;NO
	MOVSI T,400000	;DIRECTION BIT IN MTBFS
	ANDCAM T,MTBFS	;BUFFERS NOW INPUT BUFFERS
	JRST POPBJ	;LEAVE EOF BITS SET

		;SWITCH FROM INPUT TO OUTPUT

MTIORV:	PUSH P,B	;SAVE B
	PUSHJ P,MTICL2	;FLUSH READ
	AND J,[4,,]	;MASK SAVED MSMODE TO EOF BIT
	IORM J,MSMODE(W)	;IOR IT BACK IN CASE PCLSR FROM .+1
	PUSHJ P,MTWT	;WAIT FOR IDLE
	TLNN J,4	;CHECK EOF BIT
	PUSHJ P,MTSEOF	;SKIP TO EOF
	PUSHJ P,MTWT	;WAIT AGAIN FOR IDLE
	MOVSI J,400000
	IORM J,MSMODE(W)	;SET MAIN PROG EOF BIT
	IORM J,MTBFS(W)	;NOW SET OUTPUT BIT
	JRST POPBJ

		;SKIP TO EOF

MTSEOF:	JSP B,MTCMD
MGSEOF:	MOVSI A,MGS10
	MOVEM A,MGRSB(W)
MGSEF2:	PUSHJ Q,MGMTCG	;GET MTC
	JRST MGFMD	;LOSE
	MOVEI C,16000	;SKIP TO EOF
	PUSHJ Q,MGSPAC	;DO IT, PROCESS ERRORS
	JRST MGFMC	;DIE
	JRST MGDEOF	;SET EOF BIT IN MSMODE AND RETURN

MTIE:	SKIPG MSNBUF(W)	;ENTRY FROM .IOT ROUTINES
	POPJ P,		;RETURN IF NO BUFFERS
MTICL2:	PUSHJ P,MTRDFS	;FLUSH READ ROUTINE (DON'T CLOBBER J AFTER THIS)
	SKIPG MSNBUF(W)	;CHECK NUMBER OF BUFFERS
	POPJ P,		;NO BUFFERS
	SKIPN A,MGBUFO(W)
	JRST MTICL4	;NO INTERRUPT LEVEL BUFFER
	SETZM MGBUFP(W)
	PUSHJ P,MTBFRL	;RETURN BUFFER TO SYSTEM
MTICL4:	MOVE T,MTBUFO(W)	;GET ORIGIN OF FIRST BUFFER
	TLC T,(T)	;ONE HFWD INITIALLY ZERO, GET ORIGIN IN LEFT HALF
	LSH T,-<36.-8>	;SHIFT TO BLOCK NUMBER
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT REMAINING IN BUFFER
MTICL5:	SKIPN A,T	;GET BLOCK # IN A
	JRST 4,.	;TRYING TO FREE BLOCK 0 => BUFFER COUNT OUT OF PHASE WITH BUFFERS
	PUSHJ P,MTBUFR	;RETURN BUFFER TO FREE
	JRST MTICL5	;LOOP BACK UNTIL MTBUFR POPJ'S OUT

		;RETURN BUFFER TO FREE STORAGE

MTBFRL:	LSH A,-10.	;ENTRY TAKING ADDRESS IN A
MTBUFR:	LDB T,[MLO,,MEMBLT(A)]	;GET LINK TO NEXT, IF ANY (ENTRY TAKING BLOCK #)
	PUSHJ P,MGMEMR	;NO, RETURN BLOCK
	SOSG MSNBUF(W)	;ONE LESS BUFFER
	POP P,A		;NO MORE BUFFERS
	POPJ P,

		;WRITE EOF IF APPROPRIATE

MTWEOF:	MOVSI B,1000
	TDNN B,MSMODE(W)	;CHECK TO SEE IF ANY OUTPUT SINCE LAST EOF
	POPJ P,		;NO WRITING SINCE LAST EOF
	SKIPLE MTBUFC(W)	;SKIP IF (PRESUMED WRITE) BUFFER EXHAUSTED (=> NOT REALLY THERE)
	SKIPL MTBFS(W)	;SKIP UNLESS BUFFER IS READ BUFFER
	JRST MTWEF2	;READ BUFFER OR NOT REALLY THERE
	MOVEI T,EOFCH	;SET UP T FOR IDPB
	LDB TT,MTBUFP(W)	;GET LAST CHARACTER IN BUFFER OR NOT CHAR MODE => 0
	CAIE TT,EOFCH	;COMPARE WITH EOFCH
	IDPB T,MTBUFP(W)	;DIFFERENT, STORE NEW CHARACTER OR NOT CHARACTER MODE => NOTHING
	PUSHJ P,MTPBUF	;WRITE BUFFER REALLY THERE, OUTPUT BUFFER
MTWEF2:	PUSHJ P,MTRMWT	;WAIT FOR ROOM IN BUFFER
	MOVSI B,1000	;GET OUTPUT SINCE EOF BIT IN B AGAIN
	ANDCAM B,MSMODE(W)	;IN ANTICIPATION OF UPCOMING EVENTS, SAY AN EOF "HAS BEEN WRITTEN"
	JSP B,MTCMD	;NOW CAUSE IT TO HAPPEN (AND RETURN TO CALLING ROUTINE)
		;GET HERE DURING UTCBRK
MGWEOF:	MOVSI A,MGS11	;NON-DATA XFER INVOLVING WRITING ON TAPE
	MOVEM A,MGRSB(W)	;SAVE AS ROUTINE SPECIFICATION BITS
	PUSHJ Q,MGMTCG	;GET MTC
	 JRST MGFD	;CAN'T
	PUSHJ Q,MGMTC5	;WRITE EOF MARK
	 JRST MGFD	;LOSE
	PUSHJ Q,MGMTC5	;AGAIN
	 JRST MGFD	;LOSE
MGWEF2:	MOVEI C,17000	;SPACE REVERSE TO EOF
	PUSHJ Q,MGSPAC	;DO IT
	 JRST MGFD	;LOSE
MGWEF3:	MOVSI A,2000	;GET OUTPUT SINCE LAST EOF BIT
	ANDCAM A,MSMODE(W)	;TURN IT OFF IN MSMODE
MGDEOF:	MOVSI A,4
	IORM A,MSMODE(W)	;SET EOF ON PI LEVEL BIT IN MSMODE
	JRST MGFM	;ALL DONE
MGMT5A:	POP Q,A		;RETURNING FROM MGMTC5 ON EOT, BACK UP PDL POINTER
	JRST MGWEF3	;DONE, RETURN

		;GIVE RANDOM COMMAND TO MTC, PROCESS ERRORS
		;SKIPS IF SUCCESSFUL, IF NOT THEN ERROR CONDITIONS STORED, MTC RELEASED

MGMTC5:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGMT5A	;SET => FINISH JOB
	MOVEI C,5000	;ENTRY TO WRITE EOF
MGMTCT:	HRLM C,(Q)	;SAVE COMMAND
MGMTT1:	PUSHJ Q,MGCMDX	;DO IT, WAIT FOR INTERRUPT
	TRNN C,460200	;CHECK XPT HUNG, ILLOP, PARITY ERROR, BAD TAPE
	JRST QPOPJ1	;SKIP-RETURN ON NO LOSSAGE
	PUSHJ Q,MGCERR	;DECIPHER ERROR
	JRST MGFMCJ	;LOSE, STORE ERROR CONI AND RETURN
	PUSHJ Q,MGMFGT	;MAYBE GIVE UP MTC FOR AWHILE
	POPJ Q,		;QUIT
	HLRZ C,(Q)	;GOT IT BACK, NOW RETRIEVE COMMAND
	JRST MGMTT1	;LOOP BACK AND TRY AGAIN

		;GET CONI MTC, AND CONI MTS, IN I AND J RESPECTIVELY
		;SKIPS EXCEPT ON PCLSR

MTSTAT:	CONO PI,CLKOFF
	AOSE MSSRCT(W)	;ANOTHER DOING .STATUS
	JRST MTSTA2	;NOT THE FIRST
	SETZM MSCCNI(W)	;FIRST ONE, CLEAR MTC CONI ("DONE FLAG")
	CONO PI,CLKON
	PUSHJ P,FINSET	;SET UP DISPATCH TO MTSTA3 ON PCLSR
	 MTSTA3		;GO TO MTSTA3 ON PCLSR
	MOVE A,W	;GET XPT # FOR ARGUMENT TO INTERRUPT ROUTINE
	MOVEI W,NMTCS	;DUMMY XPT # FOR .STATUS AT INTERRUPT LEVEL
	MOVEI B,MGSTAT	;SET UP DISPATCH TO INTERRUPT LEVEL ROUTINE
	MOVEI T,MSCBL
	PUSHJ P,CWAIT	;WAIT FOR ROOM IN COMMAND BUFFER (AND TURN CLOCK OFF)
	 CAMG T,MSCMDC(W)	;THIS BECAUSE MTSTAT HAS ONLY MULTIPLE-USER XPT
	PUSHJ P,MTCMDA	;START UP INTERRUPT ROUTINE (TURN CLOCK BACK ON)
	SKIPA W,A	;GET BACK XPT #
MTSTA2:	CONO PI,CLKON	;HERE FROM MTSTAT, RE-ENABLE INTERRUPTS
	SKIPN MSCCNI(W)	;WAIT FOR INTERRUPT ROUTINE TO DO CONI MTC,
	PUSHJ P,UFLS
	PUSHJ P,LSWDEL	;NO LONGER NEED WORRY ABOUT PCLSR
	MOVE I,MSCCNI(W)	;GET CONI MTC,
	MOVE J,MSSCNI(W)	;GET CONI MTS,
	AOS (P)		;CAUSE RETURN TO SKIP
MTSTA3:	SOS MSSRCT(W)	;DECREMENT USAGE COUNT
	POPJ P,

		;INTERRUPT LEVEL ROUTINE TO DO CONI MTC, AND MTS,

MGSTAT:	HLRZ A,B	;GET TRANSPORT NUMER
	MOVEM A,MSERCT(W)	;STORE FOR LATER REFERENCE
	SKIPGE MSSRCT(A)	;CHECK NUMBER OF USERS WAITING FOR RESULT
	JRST MGRFIN	;NOBODY WANTS RESULT ANYMORE
	MOVEI B,MGMTCW	;NOW TO ALLOCATE MTC
	SKIPN MGMTCW	;SKIP UNLESS WANTED
	CONSZ MTC,70	;SKIP IF FREE
	PUSHJ Q,MGBLST	;WAIT FOR IT (HIGH PRIORITY)
	MOVE A,MSERCT(W)	;RETRIEVE TRANSPORT NUMBER
	SKIPGE MSSRCT(A)	;CHECK AGAIN FOR PEOPLE WAITING FOR ANSWER
	JRST MGRFM	;NOBODY WANTS IT ANYMORE, RELEASE MTC AND RETURN
	LSH A,15.	;SHIFT XPT # TO CONO MTC, XPT FIELD
	CONO MTC,MTCRH+400(A)	;SELECT UNIT (NO-OP), NEXT UNIT ENABLE
	CONI MTS,C	;GET CONI (MAYBE SELECTED RIGHT AWAY)
	TRNN C,2	;CHECK NEXT UNIT BIT OF CONI
	PUSHJ Q,MGCX1	;NOT SET YET, WAIT FOR IT
	MOVE A,MSERCT(W)	;GET TRANSPORT NUMBER ONE MORE TIME
	MOVEM C,MSSCNI(A)	;SET MTC, CONI THIS XPT
	SKIPL MSSRCT(A)		;ONE MORE TIME, SEE IF ANYBODY STILL WANTS IT
	CONI MTC,MSCCNI(A)	;MAKE MSCCNI THIS XPT NON-ZERO BY GETTING CONI
MGRFM:	CONO MTC,0	;FREE MTC
	JRST MGRFIN	;RETURN (MSRPCL IRRELEVANT)

	;MAGTAPE READ

MTUAI:	JSP E,MTREAD	;UNIT ASCII (CHARACTER) INPUT
	 JSP B,CHRKT
	HRROI A,EOFCH	;EOF, SET UP CHARACTER
	XCTR XW,[MOVEM A,(C)]	;GIVE TO USER
	JRST MTIE	;MAYBE FLUSH BUFFERS, RETURN

MTUII:	JSP E,MTREAD	;UNIT IMAGE INPUT
	 JSP B,WRDKT
	MOVE A,[EOFWRD]	;EOF, GET EOF WORD IN A
	XCTR XW,[MOVEM A,(I)]	;STORE EOF WORD FOR USER
	JRST MTIE	;MAYBE FLUSH BUFFERS

MTBI:	JSP E,MTREAD	;BLOCK INPUT
	 JSP B,BLKT
	MOVSI A,4	;SET UP AC FOR ASCII/IMAGE TEST
	TDNE A,(R)	;THIS CHANNEL OPEN IN IMAGE MODE?
	JRST MTIE	;IMAGE MODE, FLUSH BUFFERS AND RETURN
	XCTR XR,[SKIPL I,(C)]	;ASCII MODE, PREPARE TO RETURN EOF WORD
	JRST MTIE	;RETURN IF HE DOESN'T REALLY WANT TO TRANSFER ANYTHING
	MOVE A,[EOFWRD]	;GET EOF WORD
	XCTR XRW,[MOVEM A,(I)]	;STORE EOF WORD FOR USER
	MOVE A,[1,,1]	;NOW PREPARE TO UPDATE POINTER
	XCTR XRW,[ADDM A,(C)]	;UPDATE HIS POINTER
	JRST MTIE	;MAYBE FLUSH BUFFERS, RETURN

	;JSP E,MTREAD	;CALL COMMON READ ROUTINE
	; JSP B,BLKT\CHRKT\WRDKT	;WHERE TO GO FOR NORMAL .IOT (NO EOF)
	;RETURNS HERE ON EOF

MTREAD:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER FROM IOCHNM WORD
	PUSHJ P,MTIECK	;TAKE IOC ERROR IF ANY PENDING
	SKIPGE MSMODE(W)	;CHECK FOR EOF
	JRST 1(E)	;EOF, GO BACK AND HANDLE DIFFERENTLY PER MODE
	SKIPGE MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTOIRV	;REVERSE DIRECTION
	PUSHJ P,MTRCHK	;MAYBE START UP ROUTINE
	MOVE H,P	;SAVE P IN CASE OF EOF
	XCT (E)		;JSP B,BLKT\CHRKT\WRDKT
	 MTBUFP(W)	;LOCATION OF NEXT WORD
	 MTBUFC(W)	;COUNT REMAINING
	 MTRBFG		;ROUTINE TO GET NEW BUFFER
	 MTRBFD		;ROUTINE TO DISCARD BUFFER
	 @MTBSIZ(W)	;BUFFER SIZE (IMMEDIATE)
	 PUSHJ P,MTRBFW	;WAIT FOR BUFFER
	 CAIN A,EOFCH	;CHECK FOR END OF FILE (CHRKT ONLY)
	MOVSI A,400000	;EOF RETURN FROM CHRKT
	IORM A,MSMODE(W)	;SET EOF BIT
	JRST MTIE	;RETURN (CHRKT RETURNED -1,,EOFCH)

		;WAIT FOR BUFFER

MTRBFW:	MOVSI TT,30	;SET UP BITS FOR TEST
	SKIPG MSNBUF(T)	;WAIT FOR BUFFER,
	TDNN TT,MSMODE(T)	;OR FOR INTERRUPT ROUTINE TO DIE (INCLUDING MAYBE ERROR)
	AOS (P)		;BUFFER AVAILABLE OR INTERRUPT ROUTINE DEAD
	POPJ P,

	;MAGTAPE READ ROUTINES, MAIN PROGRAM LEVEL BUFFER HANDLING

	;DISCARD BUFFER

MTRBFD:	PUSHJ P,MTBUFD	;FLUSH BUFFER, SKIP-RETURN WITH UTC OFF
	JRST MOVTWJ	;NONE THERE, UTC ON, RETURN, SETTING UP T FOR FLSINS
	DPB T,[341000,,MTBUFO(W)]	;SAVE LINK
	CONO PI,UTCON
	JUMPN TT,MTRBD2	;JUMP ON EOF
	PUSH P,B	;SAVE RETURN POINT
	PUSHJ P,MTRCHK	;MAYBE START UP READ ROUTINE
	JRST PPBTWJ	;POP B, SET UP T FOR FLSINS, AND RETURN

	;GET NEW BUFFER (SKIPS IF SUCCESSFUL)

MTRBFG:	PUSHJ P,MTIECK	;TAKE IOC ERROR IF ANY
	PUSH P,B	;PROTECT B FROM .+1
	PUSHJ P,MTRCHK	;START UP READ ROUTINE IF APPROPRIATE
	POP P,B
	MOVE T,W	;RE-INITIALIZE T FOR FLSINS IN CASE .+1 DOESN'T SKIP
	MOVSI TT,4
	SKIPG MSNBUF(W)	;ANY FULL BUFFERS?
	TDNE TT,MSMODE(W)
	JRST .+2
	JRST UDELAY	;NO, DROPPED OUT OF FLSINS JUST TO RESTART INTERRUPT ROUTINE
	CONO PI,UTCOFF	;INHIBIT INTERRUPTS
	LDB A,[341000,,MTBUFO(W)]	;GET LINK TO NEXT BLOCK
	LDB TT,[MSEOFP,,MEMBLT(A)]	;GET EOF BIT
	LDB T,[MSMWC,,MEMBLT(A)]	;GET WORD COUNT
	MOVEM T,MTBSIZ(W)	;STORE WORD COUNT AS BUFFER SIZE
	HLRZS TT,MTBUFO(W)	;GET ORIGIN OF NEW BUFFER
	JRST UTCOJ1	;GO READ FROM NEW BUFFER

MTRBD2:	CONO PI,UTCON	;LINK NOT TO VALID BUFFER
	MOVSI A,400000	;EOF BIT IN MSMODE
	IORM A,MSMODE(W)	;SIGNAL EOF
	MOVE P,H	;RESET P
	HRRZ B,(R)	;GET RH(IOCHNM) FOR DISPATCH
	JRST @IOTTB(B)	;DISPATCH BACK TO RELEVANT .IOT ROUTINE

		;FLUSH MAIN PROGRAM BUFFER, SKIP-RETURN WITH UTC OFF
		;IF NO BUFFER THERE, THEN NON-SKIP RETURN WITH UTC ON

MTBUFD:	MOVEI A,@MTBUFO(W)	;GET BLOCK ORIGIN
	JUMPE A,CPOPJ	;RETURN IF NO BLOCK THERE
	CONO PI,UTCOFF	;INHIBIT INTERRUPTS
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT REMAINING
	SOS MSNBUF(W)	;ONE LESS BUFFER
	LSH A,-10.	;SHIFT TO BLOCK NUMBER
	AOS (P)		;CAUSE RETURN TO SKIP
	LDB T,[MUR,,MEMBLT(A)]
	CAIE T,MUMGB
	JRST 4,.
	LDB T,[MLO,,MEMBLT(A)]	;GET WHAT MAY BE LINK TO NEXT BLOCK
	LDB TT,[MSEOFP,,MEMBLT(A)]	;GET EOF BIT
	JRST IMEMR	;FREE BLOCK AND RETURN WITH UTC OFF

		;PUSHJ P,MTRCHK
		;IF READ ROUTINE DEAD, START IT UP

MTRCHK:	MOVSI A,36	;GET TEST BITS
	TDNE A,MSMODE(W)	;READ ROUTINE ACTIVE?
	POPJ P,		;ALREADY THERE, DON'T HAVE TO START IT UP
	MOVEI A,MSMAXB	;MAXIMUM # BUFFERS
	CAMGE A,MSNBUF(W)
	POPJ P,		;ALREADY HAVE LOTS OF BUFFERS, DON'T HAVE TO START UP ROUTINE NOW
	PUSHJ P,MTRMWT	;WAIT FOR ROOM (TO AVOID TIMING ERROR)
	MOVSI A,10	;GET BIT,
	IORM A,MSMODE(W)	;SIGNAL READ COMMAND IN COMMAND BUFFER
	MOVEI A,@MTBFS(W)	;GET RECORD SIZE
	JSP B,MTCMDA	;GIVE COMMAND TO INTERRUPT ROUTINE, RETURN TO PUSHJ
		;GET HERE AT INTERRUPT LEVEL DURING UTCBRK
MGREAD:	MOVEI C,MGS00	;READING
	MOVSM C,MGRSB(W)	;SAVE AS ROUTINE SPECIFICATION BITS FOR MSERCT
	HLLZ A,B	;GET MAX RECORD SIZE,,
	HRRI A,1	;SET UP OFFSET FOR BLKI POINTER
	MOVEM A,MGTMP2(W)	;STORE RECORD SIZE,,1 FOR SETTING UP BLKI POINTERS
	MOVSI A,30	;GET READ ROUTINE STATUS BITS MASK
	XORM A,MSMODE(W)	;BE BRAVE AND ASSUME BITS IN MSMODE SET CORRECTLY
	SKIPE MGBUFP(W)	;HAVE BUFFER?
	JRST MGRD1	;YES, SKIP FOLLOWING
	PUSHJ P,MMBRQ	;TRY GETTING BUFFER
	JRST MGF	;NO CORE, DIE
	PUSHJ P,MGRSET	;SET UP BUFFER VARIABLES
MGRD1:	PUSHJ Q,MGMTCG	;GET MTC
	JRST MGFD	;LOST, QUIT
	PUSHJ Q,MGDCGB	;GET DC
	MOVSI A,(BLKI MTC,)
	PUSHJ P,MGDCST	;SET UP DC
MGRD2:	TRNE C,4000	;LOOP POINT FOR NEXT RECORD, CHECK EOT FLAG
	JRST MGREOT	;END OF TAPE
	MOVE A,MGBUFP(W)	;GET BUFFER POINTER
	SUB A,MGTMP2(W)	;CONVERT TO BLKI POINTER
	MOVEM A,MGDBP	;STORE BLKI POINTER
	IFE C1MXP,CONO PI,PICON+DCCHNA	;ENABLE INTERRUPTS
	MOVEI C,2000+DCCHN	;READ COMMAND (TO MTC)
	PUSHJ Q,MGCMDX	;READ, WAIT FOR INTERRUPT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;MAKE SURE INTERRUPTS DISABLED
	TRNN C,440100	;CHECK ALL MTC INTERRUPT FLAGS (EXCEPT DATA, NEXT UNIT)
	JRST 4,.	;THIS ROUTINE GOT RUN WITHOUT MTC INTERRUPT
	TRNE C,470600	;CHECK XPT HUNG, ILLOP, PARITY ERROR, EOF, DATA LATE, BAD TAPE
	JRST MGRER0	;JUMP ON LOSSAGE (INCLUDING EOF)
	AOSL B,MGDBP	;GET NEXT LOCATION TO READ INTO, SKIP IF LESS THAN MAXIMUM REC SIZE READ
	TRNN C,1000	;CHECK RECORD LENGTH INCORRECT FLAG
	JRST MGRD3	;LOOKS OK
	JRST MGFDMC	;RECORD ON TAPE TOO LARGE

MGRD3:	HRRZM B,MGBUFP(W)	;STORE NEW POINTER
	SOJ B,		;BACK UP AGAIN TO LAST WORD INPUT
	ANDI B,1777	;GET ONE LESS THAN # WORDS IN BUFFER
	MOVSI B,(B)	;GET 1 LESS THAN # WORDS IN BUFFER,,
	ADD B,MGTMP2(W)	;ADD RECORD SIZE,,
	TLNE B,-2000	;INTO NEXT BLOCK?
	JRST MGRD4	;YES, HAVE TO TRY GETTING NEW BUFFER
	SKIPN MSNBUF(W)	;MAIN PROGRAM HUNG WAITING FOR BUFFER?
	PUSHJ P,MMBRQ	;YES, CORE AVAILABLE?
	 JRST MGRREC	;USE OLD BLOCK: RECYCLE
	PUSHJ P,MGRPBK	;GIVE OLD BLOCK TO MAIN PROGRAM (DOESN'T CLOBBER A)
MGRRC1:	PUSHJ P,MGRSET	;SET UP VARIABLES FOR NEW BUFFER
MGRREC:	PUSHJ P,MGCFRE	;RECYCLE FOR NEXT RECORD, BUT FIRST SEE IF ANYONE WANTS ANYTHING
	JRST MGRD2	;NOBODY WANTS ANYTHING, SKIP ALLOCATION
	JRST MGRD1	;SOMEONE WANTS SOMETHING, START OVER

		;THIS BUFFER FULL

MGRD4:	PUSHJ P,MGRPBK	;GIVE TO MAIN PROGRAM
	MOVE A,MSNBUF(W)	;GET # BUFFERS
	CAIGE A,MSMAXB	;MAXIMUM # ALREADY?
	PUSHJ P,MMBRQ	;NO, TRY GETTING CORE
	JRST MGFDM	;TOO MANY OR NO CORE
	JRST MGRRC1	;GOT CORE, NOW USE IT

		;ERROR FLAG(S) SET AFTER READ (CONI MTS, IN C)

MGRER0:	TRNE C,470600#10000	;CHECK EVERYTHING EXCEPT EOF
	JRST MGRERR	;REAL READ ERROR
		;THINGS THE MANUAL DOESN'T TELL YOU:
		;ON NORMAL READ EOF, EXACTLY ONE DATA WORD (=170000,,) IS TRANSFERRED
MGREOT:	MOVSI A,4	;EOF AT INTERRUPT LEVEL BIT
	IORM A,MSMODE(W)	;SIGNAL EOF AT INTERRUPT LEVEL
	MOVEI A,1		;EOF BIT
	DPB A,[MSEOFP,,@MGTMP1(W)]	;STORE EOF BIT
	PUSHJ P,MGRPBK	;OUTPUT BUFFER
	JRST MGFDM	;ALL DONE, FREE DC, MTC AND RETURN

	;SET UP READ BUFFER VARIABLES (BLOCK # IN A)

MGRSET:	MOVEI TT,MUMGB	;MAGTAPE DESCRIPTOR FOR MEMORY ALLOCATION TABLE
	DPB TT,[MUR,,MEMBLT(A)]	;STORE IN TABLE
	MOVEI TT,0
	DPB TT,[MLO,,MEMBLT(A)]	;THIS LAST ACTIVE BUFFER NOW
	DPB TT,[MSEOFP,,MEMBLT(A)]	;THIS NOT YET EOF BUFFER
	SETZM MGBUFO(W)	;CLEAR OUT ORIGIN
	DPB A,[121000,,MGBUFO(W)]	;STORE ORIGIN
	SETZM MGBUFP(W)	;CLEAR OUT GARBAGE IN POINTER WORD
	DPB A,[121000,,MGBUFP(W)]	;STORE ORIGIN
	ADDI A,MEMBLT	;RELOCATE TO POINT TO MEMBLT TABLE
	MOVEM A,MGTMP1(W)	;STORE FOR USE AS BYTE POINTER ADDRESSES
	POPJ P,

		;GIVE BUFFER TO MAIN PROGRAM (DOESN'T CLOBBER A)

MGRPBK:	SKIPN TT,MGBUFP(W)	;GET 1 + LAST TO OUTPUT
	POPJ P,			;NO BUFFER
	SUB TT,MGBUFO(W)	;SUBTRACT ORIGIN, CONVERT TO # TRANSFERRED
	SKIPGE TT
	JRST 4,.	;FEWER THAN 0 DATA WORDS READ
	LDB B,[121000,,MGBUFO(W)]	;GET BLOCK # BUFFER BEING OUTPUT
	LDB T,[MUR,,MEMBLT(B)]	;DEBUG CHECK: GET BLOCK TYPE
	CAIE T,MUMGB
	JRST 4,.	;TRYING TO GIVE MAIN PROGRAM BUFFER DON'T REALLY HAVE
	DPB TT,[MSMWC,,MEMBLT(B)]	;STORE WORD COUNT IN MEMBLT ENTRY
	AOS TT,MSNBUF(W)	;ANOTHER BUFFER,
	CAIG TT,1	;THE FIRST?
	JRST MGRPB2	;YES
	LDB TT,[1000,,MSMODE(W)]	;GET BLOCK # LAST ON LIST
	DPB B,[MLO,,MEMBLT(TT)]	;STORE LINK, PUTTING NEW BUFFER ON LIST
MGRPBX:	DPB B,[1000,,MSMODE(W)]	;THIS NOW LAST BUFFER ON LIST
	SETZM MGBUFP(W)	;NO LONGER HAVE BUFFER AT INTERRUPT LEVEL
	POPJ P,

MGRPB2:	DPB B,[341000,,MTBUFO(W)]	;THIS TO BE ONLY ENTRY ON LIST, STORE AS FIRST ENTRY
	JRST MGRPBX	;DROP BACK IN

		;FLUSH READ ROUTINE (IF ANY)

MTRDFS:	CONO PI,UTCOFF	;INHIBIT INTERRUPTS
	MOVE J,MSMODE(W)	;GET MSMODE WHERE IT CAN BE CHECKED IN ONE INSTRUCTION
	TLNN J,30	;CHECK FOR READ ROUTINE ALIVE
	JRST UTCONJ	;NO READ ROUTINE TO FLUSH
	TLNE J,10	;READ COMMAND IN BUFFER?
	JRST MTRDF2	;YES, TURN IT INTO NO-OP
	SETOM MSRPCL(W)	;REALLY THERE, TELL IT TO STOP
	CONO PI,UTCON	;RE-ENABLE INTERRUPTS
	PUSHJ P,MTWT	;WAIT FOR DEATH (MAYBE IOCERR'S OUT)
MTRDF3:	MOVE J,MSMODE(W)	;RETURN OLD MSMODE IN J
	MOVSI T,34	;GET READ BITS
	ANDCAM T,MSMODE(W)	;WIPE OUT SIGNS OF READ ROUTINE HAVING BEEN AROUND
	JRST UTCONJ	;(RE-RE-ENABLE INTERRUPTS BECAUSE MAYBE WENT TO MTRDF3 WITH UTC OFF)

MTRDF2:	MOVEI A,(W)	;HERE TO EXTRACT READ COMMAND FROM COMMAND BUFFER
	IMULI A,MSLCTB	;GET INDEX OF RELEVANT COMMAND BUFFER
	ADD A,[444400,,MSCB0]	;CONVERT TO BYTE POINTER
MTRDF4:	ILDB T,A	;GET COMMAND WORD
	TLZ T,-1	;CLEAR OUT LEFT HALF
	CAIN T,MGRCV	;END OF BUFFER?
	JRST MTRDF3	;END OF BUFER
	CAIE T,MGREAD	;READ COMMAND?
	JRST MTRDF4	;NO, TRY NEXT ONE
	MOVEI T,MGCLCF	;REPLACE WITH NO-OP
	DPB T,A		;DEPOSIT BACK INTO BUFFER
	JRST MTRDF4	;LOOP FOR ENTIRE BUFFER, THIS MAY NOT BE "LIVE" READ COMMAND

		;MAYBE TAKE IOC ERROR (DOESN'T CLOBBER B)

MTIEC0:	MOVE T,MSERCT(W)	;VERSION TO DO .RESET IF NORMALLY WOULD RESTART ROUTINE
	AOJE T,MTRS1	;JUMP FOR .RESET
MTIECK:	SKIPL T,MSERCT(W)	;SKIP IF INTERRUPT ROUTINE STOPPED
	POPJ P,		;NOT STOPPED, RETURN
	SETOM MSERCT(W)	;CLEAR OUT ERROR INDICATION BUT LEAVE ROUTINE STOPPED
	AOJN T,MTICK3	;JUMP IF SHOULD TAKE IOC ERROR
	SKIPLE MSRPCL(W)
	POPJ P,		;DOING .RESET OR SOMETHING => DON'T RESTART
	CONO PI,UTCOFF
	SKIPGE MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MGWFRB	;OUTPUT; DISCARD THE ONE ON INTERRUPT LEVEL IF ANY
	SETZM MSERCT(W)	;THIS SECOND TIME HERE, "RESTART" ROUTINE
	SETZM MSRPCL(W)	;KILL QUIT FLAG
	SKIPGE MSCMDC(W)	;IF NO COMMANDS IN COMMAND BUFFER,
	JRST UTCONJ	;THEN JUST RETURN
	AOS MSCMDT	;COMMANDS IN COMMAND BUFFER, INCREMENT COUNT OF RUNNABLE ROUTINES
	CONO PI,PICIRQ+MTCHNA	;RUN INTERRUPT ROUTINE
	JRST UTCONJ

MTICK3:	MOVEM T,MTERC(W)	;STORE LAST ERROR CONI MAIN PROGRAM LEVEL FOR .STATUS OR SOMETHING
	TRNE T,440000	;CHECK XPT HUNG, ILLOP
	JRST IOCER1	;ILLEGAL DEVICE OPERATION ATTEMPTED AT INTERRUPT LEVEL
	TRNE T,23600	;CHECK PARITY ERROR, R/C ERR, LENGTH INCORRECT,
		;DATA LATE, BAD TAPE
	JRST IOCER3	;ANY OF THESE => NON-RECOVERABLE DATA ERROR
	TRNE T,4000	;CHECK END OF TAPE FLAG
	JRST IOCER9	;EOT => DEVICE FULL
	JRST IOCER3	;CAN'T FIND ANYTHING WRONG, SAY DATA ERROR

		;MAGTAPE .RESET (DOESN'T CLOBBER I)

MAGTRS:	LDB W,[MTXP (R)]	;MAGTAPE .RESET ROUTINE
MTRS1:	HRRZM P,MSRPCL(W)	;SET QUIT FLAG POSITIVE => STOP AND DON'T RESTART
	PUSHJ P,STMSET	;CAUSE IT TO BE SETOM'ED ON PCLSR (STOP, PROCEED)
	 MSRPCL(W)	;INDEXING OK
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTICL2	;INPUT => KILL READ ROUTINE, FLUSH BUFFERS
	PUSHJ P,MTWT	;WAIT FOR INTERRUPT ROUTINE TO DIE
	SKIPGE MTBFS(W)	;CHECK DIRECTION AGAIN
	PUSHJ P,MTRSO2	;OUTPUT => FREE OUTPUT BUFFERS
	MOVE B,MGCMBP(W)	;GET INTERRUPT LEVEL POINTER TO COMMAND BUFFER
	SKIPL C,MSCMDC(W)	;GET # COMMANDS IN BUFFER - 1, SKIP IF NONE
	JRST MTRS3	;PROCESS BUFFER (RETURNS TO MTRS4)
MTRS4:	MOVEI A,(W)	;GET XPT NUMBER IN A
	IMULI A,MSLCTB	;CONVERT TO INDEX INTO COMMAND BUFFER/QDL AREA
	SUBM B,A	;GET MSCB0+DISTANCE INTO BUFFER
	HRLI B,-<MSCB0+MSCBL>(A)	;SET UP LEFT HALF OF AOBJN POINTER
	EXCH B,MTCMBP(W)	;STORE NEW POINTER
	SETOM MSCMDC(W)	;RE-INITIALIZE COUNT IN BUFFER
	CAME B,MTCMBP(W)	;CHECK TO SEE IF LOSSAGE JUST FIXED
	JRST 4,.+1	;POINTERS TO MTAPE COMMAND BUFFER (XPT # IN W) WERE OUT OF PHASE
	SETZM MSRPCL(W)	;CLEAR OUT QUIT REQUEST
	SETZM MSERCT(W)	;CLEAR OUT STOP CONDITION
	JRST LSWDEL	;FLUSH SETOM MSRPCL(W) ON PCLSR CONDITION AND RETURN

		;.RESET, EMPTY COMMAND BUFFER

MTRS2:	SUBI B,MSCBL+1	;LOOP POINT TO RING BUFFER
MTRS3:	ILDB A,B	;GET COMMAND (ENTRY; DO JRST MTRS4 WHEN DONE)
	HRRZ T,A	;GET RIGHT HALF (DISPATCH) IN T
	CAIN T,MGRCV	;RING BUFFER?
	JRST MTRS2	;YES (DON'T SOJ C,)
	CAIN T,MGWRIT	;WRITE COMMAND?
	JRST MTORS3	;YES, LH HAS BUFFER TO FLUSH
		;^ MAYBE INSERT OTHER CONDITIONS HERE ^
MTRSRT:	SOJGE C,MTRS3	;RETURN POINT FOR CLOBBERAGE CONDITIONS, LOOP IF NOT DONE (DON'T CHANGE TO SOJG)
	MOVEM B,MGCMBP(W)	;STORE BACK UPDATED POINTER
	JRST MTRS4	;RETURN TO MAIN ROUTINE

MTORS3:	LDB A,[221000,,A]	;MGWRIT COMMAND IN BUFFER, GET BLOCK # IN A
	PUSHJ P,MGMEMR	;FREE BLOCK
	SOS MSNBUF(W)	;ONE LESS BUFFER
	JRST MTRSRT	;GO BACK TO LOOP

MTRSO2:	MOVE T,MSMODE(W)
	;TLNN T,2000	;CHECK WRITING SINCE LAST EOF BIT
	TLZE T,1000	;NOT SET, CLEAR CORRESPONDING BIT TO MAIN PROGRAM
	MOVEM T,MSMODE(W)	;STORE NEW MSMODE
	PUSHJ P,MTBUFD	;FLUSH MAIN PROGRAM WRITE BUFFER, IF ANY
	CONO PI,UTCOFF	;DIDN'T SKIP => UTC ON, TURN IT OFF
	SETZM MTBUFC(W)	;CLEAR OUT MAIN PROGRAM BUFFER COUNT
	PUSHJ P,MGWFRB	;FREE INTERRUPT LEVEL WRITE BUFFER IF ANY
	JRST UTCONJ

	;MAGTAPE WRITE ROUTINES

MTUAO:	JSP B,MTWRIT	;UNIT ASCII (CHARACTER) OUTPUT
	JRST CHRKT

MTUIO:	JSP B,MTWRIT	;UNIT IMAGE (WORD) OUTPUT
	JRST WRDKT

MTBO:	JSP B,MTWRIT	;BLOCK OUTPUT
	JRST BLKT

		;COMMON MAGTAPE WRITE ROUTINE

MTWRIT:	LDB W,[MTXP (R)]	;GET TRANSPORT NUMBER FROM IOCHNM
	PUSHJ P,MTIECK	;TAKE IOC ERROR IF ANY PENDING
	SKIPL MTBFS(W)	;CHECK DIRECTION OF BUFFERS
	PUSHJ P,MTIORV	;REVERSE DIRECTION
	JSP B,(B)	;JRST BLKT\CHRKT\WRDKT
	 SETZ MTBUFP(W)	;LOCATION OF NEXT WORD
	 MTBUFC(W)	;COUNT REMAINING
	 MTWBFG		;ROUTINE TO GET NEW BUFFER (SKIPS)
	 MTWBFD		;ROUTINE TO DISCARD (WRITE OUT) BUFFER
	 @MTBFS(W)	;BUFFER SIZE (IMMEDIATE)
	 PUSHJ P,.+1	;WAIT FOR NEW BUFFER
	MOVEI TT,MSMAXB	;SET UP TT FOR COMPARISON
	CAMG TT,MSNBUF(T)	;IF NOT TOO MANY BUFFERS,
	SKIPGE MSERCT(T)	;OR IF TRANSPORT ROUTINE STOPPED,
	AOS (P)		;THEN SKIP OUT OF UFLS
	POPJ P,

		;DISCARD (WRITE OUT) OUTPUT BUFFER

MTWBFD:	PUSH P,B	;SAVE B
	PUSHJ P,MTPBUF	;OUTPUT BUFFER
PPBTWJ:	POP P,B		;RESTORE B
MOVTWJ:	MOVE T,W	;INITIALIZE T FOR FLSINS
	POPJ P,

		;WRITE OUT BUFFER (MTBUFC NOT ASSUMED CORRECT)

MTPBUF:	LDB A,[121000,,MTBUFO(W)]	;GET BLOCK NUMBER (IT STAYS IN A FOR AWHILE)
	JUMPE A,MTIECK	;ALREADY WRITTEN OUT (MAYBE GOT PCLSR'ED FROM BLKT)
	MOVE B,MTBUFP(W)	;GET POINTER
	MOVE TT,[EOFWRD]	;CHARACTER MODE => MAYBE DEPOSIT GARBAGE IN LAST WORD
	LDB T,[360600,,B]	;GET POSITION FIELD OF BUFFER POINTER
	DPB T,[301400,,B]	;STORE AS SIZE FIELD, SET POSITION FIELD TO ZERO
	TLNE B,7700	;DON'T DO DPB ON 0 SIZE FIELD SINCE MAY GET PAGE FAULT
	DPB TT,B		;STORE APPROPRIATE NUMBER OF BITS (NON-CHAR MODE => NONE)
	TLZE B,-1	;CLEAR OUT BYTE POINTER, IF ANY
	AOJ B,		;YES, INCREMENT TO POINT TO WORD AFTER LAST ACTIVE IN BUFFER
	SUBI B,@MTBUFO(W)	;CONVERT TO 1 LESS THAN # WORDS ACTIVE IN BUFFER
	JUMPL B,MTIECK	;JUMP IF NOTHING THERE
	DPB B,[MSMWC,,MEMBLT(A)]	;STORE WORD COUNT
	LDB T,[400200,,MTBFS(W)]	;GET WRITE COMMAND
	DPB T,[100200,,A]	;STORE AS ARG
	MOVEI B,MGWRIT	;NOW SET UP POINTER TO INTERRUPT ROUTINE
	PUSHJ P,MTCMDA	;GIVE COMMAND TO INTERRUPT ROUTINE (A HAS BLOCK #)
	SETZM MTBUFO(W)	;CLEAR OUT ORIGIN,
	SETZM MTBUFC(W)	;ALSO CLEAR OUT COUNT IN BUFFER
	JRST MTIECK

		;MAGTAPE WRITING, GET NEW BUFFER

MTWBFG:	PUSHJ P,MTIECK	;MAYBE TAKE IOC ERROR
	PUSHJ P,TCALL	;TURN OFF UTC(MTC)
	JRST MMBRQ	;TRY GETTING CORE BLOCK
	 JRST UDELAY	;NO CORE
	DPB A,[121000,,MTBUFO(W)]	;NEW BUFFER ORIGIN
	MOVEI T,MUMGB	;MAGTAPE BUFFER DESCRIPTOR BYTE
	DPB T,[MUR,,MEMBLT(A)]	;TELL WORLD THIS PAGE IS MAGTAPE BUFFER
	MOVE TT,MTBUFO(W)	;GET ORIGIN IN TT FOR CALLING ROUTINE
	AOS MSNBUF(W)	;ANOTHER BUFFER, INCREMENT COUNT
	MOVSI T,1000
	IORM T,MSMODE(W)	;WRITING HAS OCCURRED SINCE LAST EOF WRITTEN
	JRST POPJ1	;SKIP-RETURN

		;WRITING MAGTAPE: INTERRUPT ROUTINE

MGWRIT:	MOVSI C,MGS01	;WRITING
	MOVEM C,MGRSB(W)	;SAVE AS ROUTINE SPECIFICATION BITS FOR MSERCT
	HLRZ A,B	;RETRIEVE ARGUMENT (BLOCK # OF BUFFER)
	DPB A,[121000,,MGBUFP(W)]	;SET UP POINTER
	ROT A,-8	;NOW RIGHT-JUSTIFY COMMAND INDEX
	MOVE C,MGCMDT(A)	;GET COMMAND TO MTC
	MOVEM C,MGTMP2(W)	;COMMAND TO MTC (FOR MTCMDX) FOR WRITING
	LSH A,-<36.-8>	;GET BACK BLOCK NUMBER
	ADDI A,MEMBLT	;RELOCATE TO POINT TO MEMBLT TABLE ENTRY
	MOVEM A,MGTMP1(W)	;MGTMP1 POINTER TO ENTRY IN MEMBLT TABLE
MGW1:	PUSHJ Q,MGMTCG	;GOBBLE MTC
	JRST MGFD	;LOSE, QUIT
	PUSHJ Q,MGDCGB	;GET DC
	MOVSI A,(BLKO MTC,)
	PUSHJ P,MGDCST	;SET UP DC
MGW2:	TRNE C,4000	;CHECK EOT FLAG
	JRST MGFDMC	;END OF TAPE => QUIT
	MOVSI A,2000	;GET BIT...
	IORM A,MSMODE	;SIGNAL WRITING AT INTERRUPT LEVEL SINCE LAST EOF
	LDB A,[MSMWC,,@MGTMP1(W)]	;GET WORD COUNT -1
	MOVSI A,(A)	;A := WORD COUNT,,0
	SUB A,MGBUFP(W)	;A := WC-1,,-ADR
	SETCAM A,MGDBP	;MGDBP := -WC,,ADR-1	;STORE BLKO POINTER
	IFE C1MXP,CONO PI,PICON+DCCHNA	;TURN ON DCCHN
	MOVE C,MGTMP2(W)	;GET WRITE COMMAND
	PUSHJ Q,MGCMDX	;DO IT, WAIT FOR INTERRUPT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;MAKE SURE CHANNEL OFF
	TRNN C,440100	;CHECK INTERRUPT FLAGS
	JRST 4,.	;THIS ROUTINE GOT RUN WITHOUT VALID INTERRUPT FROM MTC
	TRNE C,463600	;CHECK XPT HUNG, ILLOP, PARITY ERROR, READ/CMP ERR,
		;,REC LENGTH INCORRECT, DATA LATE, BAD TAPE
	JRST MGWERR	;JUMP ON LOSSAGE
MGWERT:	PUSHJ P,MGWFRB	;FREE BUFFER
	JRST MGFDM	;ALL DONE, RELEASE DC AND MTC, RETURN

		;ERROR ROUTINES (DATA TRANSACTIONS AT INTERRUPT LEVEL)

		;WRITE

MGWERR:	TRNE C,3000	;CHECK READ/COMPARE ERROR, RECORD LENGTH INCORRECT
	JRST MGFDMC	;READ/COMPARE LOSSAGE, STORE CONI AND QUIT
	PUSHJ Q,MGCERR	;DECIPHER ERROR, COUNT DOWN
	JRST MGFDMC	;DIE
	MOVE A,MSERCT(W)	;WANT TO TRY RECYCLING, GET ERROR COUNTDOWN
	MOVE B,MGTMP2(W)	;GET WRITE COMMAND
	CAIG A,MGMAXE-2	;IF THIS WILL BE AT LEAST THIRD TIME THROUGH,
	CAMN B,MGCMDT+1	;AND IF NOT READ/COMPARING,
	JRST .+3
	MOVE A,MGCMDT+3	;THEN REPLACE WRITE COMMAND WITH WRITE W/ LONG EOR GAP
	MOVEM A,MGTMP2(W)
	PUSHJ P,MGCFRE	;TRY RECYCLING, BUT FIRST MAYBE FREE MTC
	JRST MGW2	;NOBODY WANTED IT, LOOP
	JRST MGW1	;SOMEBODY WANTED IT, GET IT BACK AND LOOP

		;READ

MGRERR:	TRNE C,400	;DATA LATE?
	SKIPGE MGDBP	;BLKI POINTER COUNTED OUT?
	PUSHJ Q,MGCERR	;NOT BOTH, SEE IF SHOULD RECYCLE
	JRST .+2	;LOSE SOMEHOW
	JRST MGRREC	;RECYCLE
	AOS B,MGDBP
	HRRZM B,MGBUFP(W)
	PUSHJ P,MGRPBK
	JRST MGFDMC

		;CODING COMMON TO BOTH (CALLING ROUTINE RESPONSIBLE FOR SAVING C ON ERROR)

MGCERR:	TRNN C,440000	;CHECK TRANSPORT HUNG, ILLOP
	SOSG MSERCT(W)	;NOT SET, DECREMENT ERROR COUNT TO SEE IF TOO MANY
	POPJ Q,		;NON-RECOVERABLE
		;MAYBE RECOVERABLE, TRY RECYCLING
	AOS MSTERC	;ANOTHER DATA ERROR
IFN 1,[	TRNE C,100000	;CHECK BOT FLAG
	JRST QPOPJ1	;BEGINNING OF TAPE, DON'T BACKSPACE
	MOVEI C,7000	;SPACE REVERSE COMMAND (INTERRUPT ON MTCCHN FOR DATA)
	PUSHJ Q,MGSPAC	;DO IT
	TLOA C,MGS40	;LOSE
	AOS (Q)		;NO ERROR, CAUSE RETURN TO SKIP
]	POPJ Q,

		;FREE WRITE BUFFER, IF ANY (DOESN'T CLOBBER B)
		;CALL WITH UTC OFF OR UTCBRK IN PROGRESS

MGWFRB:	LDB A,[121000,,MGBUFP(W)]	;GET BLOCK #
	JUMPE A,CPOPJ	;IGNORE ZERO (=> NO BUFFER)
	PUSH P,B
	LDB B,[MUR,,MEMBLT(A)]
	CAIE B,MUMGB
	JRST 4,.
	POP P,B
	PUSHJ P,IMEMR	;FREE BLOCK
	SETZM MGBUFP(W)	;NO LONGER HAVE BLOCK
	SOS MSNBUF(W)	;ONE LESS BUFFER
	POPJ P,

;PUSHJ P,MTCMD	;GIVE COMMAND TO INTERRUPT ROUTINE
	;RH(W) HAS TRANSPORT NUMBER
	;RH(B) HAS ADR OF INTERRUPT ROUTINE TO GO TO
	;LH(B) WILL BE SAVED IN LH OF COMMAND ENTRY
	;DOES NOT CLOBBER A, B, OR W
	;MAY BE CALLED W/ INTERRUPTS DISABLED IF C(MSCMDC(W)) .LE. MSCBL

MTCMD1:	AOSA (P)	;ENTRY TO SKIP-RETURN
MTCMDA:	HRL B,A		;ENTRY FOR HALFWORD ARG IN RH(A) (CLOBBERS B)
MTCMD:	MOVEI T,MSCBL	;GET BUFFER COMMAND CAPACITY
	SKIPGE MSERCT(W)	;SKIP UNLESS STOPPED
	CAMLE T,MSCMDC(W)	;SKIP IF BUFFER FULL
	JRST .+2	;ROOM IN BUFFER OR NOT STOPPED
	JRST 4,.-3	;XPT ROUTINE GOT STOPPED WITHOUT DYING, THAT'S NOT CRICKET
	CAMG T,MSCMDC(W)	;WAIT FOR ROOM FOR COMMAND
	PUSHJ P,UFLS
	MOVE T,MTCMBP(W)	;GET POINTER
	AOBJN T,.+2	;INCREMENT POINTER, SKIP UNLESS AT END OF BUFFER
	SUB T,[MSCBL,,MSCBL]	;END OF BUFFER, RING IT
	MOVEM B,(T)	;STORE NEW COMMAND
	MOVEM T,MTCMBP(W)	;STORE BACK UPDATED POINTER
	CONO PI,UTCOFF
	AOSN MSCMDC(W)	;ANOTHER COMMAND FOR THIS TRANSPORT, SKIP IF NOT THE FIRST
	SKIPGE MSERCT(W)	;SKIP UNLESS STOPPED
	JRST UTCONJ	;XPT STOPPED OR THIS NOT 1ST COMMAND, LET THAT BE ALL
	AOSN MSCMDT	;ANOTHER RUNNABLE XPT ROUTINE: THE FIRST?
	CONO PI,PICIRQ+MTCHNA	;YES, ACTIVATE INTERRUPT
	JRST UTCONJ	;THAT'S ALL

		;WAIT FOR ROOM IN COMMAND BUFFER FOR ONE COMMAND

MTRMWT:	MOVEI T,MSCBL	;GET BUFFER LENGTH
	CAMG T,MSCMDC(W)	;SKIP IF ROOM
	PUSHJ P,UFLS	;WAIT IF NECESSARY
	JRST MTIECK	;MAYBE TAKE IOC ERROR, IF NOT THEN RETURN

		;WAIT FOR INTERRUPT ROUTINE TO BECOME IDLE

MTWT:	MOVE T,W	;GET XPT NUMBER INTO T FOR FLSINS
	PUSHJ P,MTWTW	;FLUSH INSTRUCTION
	PUSHJ P,UFLS
	JRST MTIECK	;MAYBE TAKE IOC ERROR, IF NOT THEN RETURN

		;FLUSH INSTRUCTION FOR ABOVE

MTWTW:	SKIPL MSERCT(T)	;IF STOPPED,
	SKIPGE MSCMDC(T)	;OR IF NO MORE COMMANDS IN BUFFER,
	AOS (P)		;THEN CAUSE RETURN TO SKIP
	POPJ P,

		;LIKE MTWT BUT SKIPS UNLESS PCLSR, DOESN'T TAKE IOC ERROR

MTWTP:	PUSHJ P,FINSET	;SET UP DISPATCH ON PCLSR
	 CPOPJ
	MOVE T,W	;SET UP T FOR FLSINS
	PUSHJ P,MTWTW	;WAIT FOR IDLE
	PUSHJ P,UFLS
	PUSHJ P,LSWDEL	;DELETE PCLSR DISPATCH
	JRST POPJ1	;SKIP-RETURN

;VARIOUS MTAPE INTERRUPT ROUTINE DONE ROUTINES
;DONE WITH THIS INTERRUPT LEVEL COMMAND, MAYBE ALSO DO THINGS
;JRST MGF(DM,M,-)(D,C,-)
;(DM,M,-) => FREE DC&MTC, FREE MTC, -
;(C,D,-) => STORE ERROR CONI, DIE (STOP SELF), JUST EXIT

MGFDMD:	IFE C1MXP,SETOM DCFREE	;RELEASE DC
MGFMD:	CONO MTC,0	;RELEASE MTC
	JRST MGFD	;DIE (STOP SELF)

MGFDMC:	IFE C1MXP,SETOM DCFREE	;RELEASE DC
MGFMC:	CONO MTC,0	;RELEASE MTC
MGFC:	MOVEM C,MSERCT(W)	;STORE ERROR CONI
MGFD:	SKIPL MSERCT(W)	;DIE (STOP SELF): ALREADY STOPPED?
	SETOM MSERCT(W)	;NO, DO SO
	JRST MGF1	;ALL DONE

MGFDM:	IFE C1MXP,SETOM DCFREE	;RELEASE DC
MGFM:	CONO MTC,0	;RELEASE MTC
MGF:	SKIPE MSRPCL(W)	;MAIN PROGRAM WANT QUIT?
	JRST MGFD	;YES, DIE
MGF1:	MOVSI A,20	;NOW GET READ ROUTINE ACTIVE BIT
	MOVE T,MSMODE(W)	;GET COPY OF OLD MSMODE
	ANDCAM A,MSMODE(W)	;TURN OFF IN MSMODE
	TLNE T,20	;SEE IF BIT WAS ON
	PUSHJ P,MGRPBK	;WAS ON, FLUSH BUFFER, IF ANY
	JUMPGE C,MGRFIN	;JUMP IF C DOESN'T HAVE CONI MTS,
	LDB A,[130100,,C]	;IT DOES, GET EOT BIT
	DPB A,[230100,,MSMODE(W)]	;STORE EOT BIT IN MSMODE
MGRFIN:	SOSL MSCMDC(W)		;ANOTHER COMMAND FINISHED THIS TRANSPORT
	SKIPGE MSERCT(W)	;STOP?
	SOS MSCMDT	;ANOTHER NON-RUNNABLE TRANSPORT
	POPJ P,

MGFCJ:	MOVEM C,MSERCT(W)	;STORE C AND RETURN
	POPJ Q,

MGFMCJ:	MOVEM C,MSERCT(W)	;STORE C
MGFMJ:	CONO MTC,0	;FREE MTC
	POPJ Q,		;RETURN (WHAT ELSE?)

		;PUSHJ Q,MGDCGB
		;GOBBLE DCCHN, RE-CONI MTS,C IF WAITING WAS NECESSARY
		;TO FREE THE DC, DO IFE C1MXP,SETOM DCFREE

MGDCGB:	IFN C1MXP,POPJ Q,	;ALWAYS HAVE IT NOW
IFE C1MXP,[SKIPN MGDCW	;SKIP IF ANOTHER XPORT ROUTINE WANTE IT
	SKIPGE DCWANT	;SKIP UNLESS UTAPE ROUTINES WANT IT
	JRST MGDCG2	;SOMEONE WANTS IT, ADD SELF TO LIST AND WANT
	AOSE DCFREE	;NOBODY ELSE WANTS IT, TRY GOBBLING IT
	JRST MGDCG2	;NOT FREE, WAIT FOR IT
	;CONO DC,0	;GOT IT, NOW ENSURE THAT SPASTIC UTAPE ROUTINES DON'T GENERATE EXTRANEOUS TRANFER
	POPJ Q,		;WIN, RETURN NOW
MGDCG2:	MOVEI C,0	;NO-OP
	XCT MGCMD(W)	;CAUSE MTC NOT TO INTERRUPT
	MOVEI B,MGDCW	;LOSE, GET POINTER
	JRST MGALST	;ADD SELF TO WAITING LIST AND WAIT
]
		;PUSHJ Q,MGMTCG	;GOBBLE MTC AND SELECT XPORT, WAIT FOR IDLE
		;TO FREE MTC, JUST DO CONO MTC,0
		;SKIPS IF SUCCESSFUL, IF UNSUCCESSFUL, CALLING ROUTINE SHOULD DIE

MGMTCG:	SKIPE MSRPCL(W)	;CHECK TO SEE IF MAIN PROGRAM WANTS QUIT
	JRST QCLCJ	;YES
MGMTC3:	PUSHJ Q,MGMALC	;ALLOCATE MTC
	MOVEI C,10000	;NO-OP, WAIT FOR IDLE
	PUSHJ Q,MGCMDY	;DO IT, SIMULATE XPT HUNG IF NECESSARY
	TRNE C,40	;CHECK XPT IDLE
	JRST QPOPJ1	;IDLE => SKIP-RETURN
	CONO MTC,0	;XPT NOT IDLE, FREE MTC
	TRNE C,200000	;CHECK FOR REWINDING
	SKIPE MSRPCL(W)	;CHECK QUIT FLAG
	JRST MGFCJ	;NOT REWINDING, OR MAIN PROGRAM WANTS QUIT
	MOVEI B,MGCKL1
	PUSHJ Q,MGBLST	;WAIT TILL NEXT SLOW CLOCK TICK
	JRST MGMTC3	;REWINDING, TRY AGAIN

MGMTC2:	MOVEI B,MGMTCW	;MTC ALREADY WANTED OR NOT FREE
	JRST MGALST	;WAIT FOR AVAILABLE THEN RETURN TO MGMTCG

		;ALLOCATE MTC

MGMALC:	SKIPN MGMTCW	;SKIP IF WANTED
	CONSZ MTC,70	;SKIP IF FREE
	JRST MGMTC2	;ALREADY WANTED OR NOT FREE, WAIT FOR IT
	POPJ Q,

		;CHECK FOR PEOPLE WANTING DC AND MTC

MGCFRE:	IFE C1MXP,SKIPL DCWANT
	SKIPE MGMTCW
	JRST MGFRE1	;SOMEONE WANTS DC
	SKIPN MGMTCW	;ANYONE WANT MTC?
	SKIPE MSRPCL(W)	;NO, MAIN PROG WANT QUIT?
MGFRE1:	AOSA (P)	;SOMEBODY WANTS SOMETHING, CAUSE RETURN TO SKIP, AND FREE WORLD
	POPJ P,		;NOBODY WANTS ANYTHING
MGFREE:	IFE C1MXP,SETOM DCFREE	;FREE DC
	CONO MTC,0	;FREE MTC
	POPJ P,

		;RANDOM INTERRUPT LEVEL ROUTINES

		;SPACE (COMMAND IN C)(SHOULD SPECIFY DATA PIA=MTCCHN)
		;SKIPS IF NO ERROR, IF ERROR THEN CALLING ROUTINE SHOULD SAVE C, FREE MTC

MGSPAC:	PUSHJ Q,MGCMDX	;GIVE COMMAND TO MTC, WAIT FOR INTERRUPT
	TRNN C,1	;CHECK DATA RQ
	JRST MGSPC2	;NOT SET, SKIP FOLLOWING
	DATAO MTC,	;FEED IT A RANDOM WORD
	CONO MTS,1	;NOW STOP IT
	CONI MTS,C	;GET CONI TO SEE IF ALREADY STOPPED
	IOR C,MGRSB(W)	;IOR IN ROUTINE SPECIFICATION BITS
	TRNN C,440100	;CHECK XPT HUNG, ILLOP, JOB DONE
	PUSHJ Q,MGCX1	;NOT SET, WAIT AGAIN FOR INTERRUPT
MGSPC2:	TRNN C,440000	;CHECK XPT HUNG, ILLOP
QPOPJ1:	AOS (Q)		;NOT SET, CAUSE RETURN TO SKIP
QPOPJ:	POPJ Q,

		;GIVE COMMAND (IN C) TO XPORT THEN WAIT FOR INTERRUPT
		;ON RETURN, C HAS CONI MTS,

MGCMDX:	XCT MGCMD(W)	;GIVE COMMAND TO MTC
MGCX1:	MOVEI B,MGMTCX	;SET UP ENTRY IN LIST,
	JRST MGALST	;AND WAIT FOR COMPLETION

		;LIKE MGCMDX, BUT ALSO USES SLOW CLOCK SIMULATION OF XPT HUNG

MGCMDY:	XCT MGCMD(W)	;DO THE CONO
	MOVEI C,400	;NO-OP, NEXT UNIT ENABLE
	MOVEI C,@MGCMD(W)	;CALCULATE UNBLOCKING CONO
	MOVEM C,MGHNGC	;STORE UNBLOCKING CONO FOR POSSIBLE USE BY SLOW CLOCK
	MOVNI A,6	;WAIT 2.5-3 SECONDS
	MOVEM A,MGHCNT	;STORE HANG COUNT TO SLOW CLOCK ROUTINE
	JRST MGCX1	;WAIT FOR COMPLETION

		;TABLE OF "WRITE" COMMANDS (FIRST ENTRY REALLY EXTRANEOUS, BUT...)

MGCMDT:	2000+DCCHN	;READ
	SETZ 3000+DCCHN	;READ/COMPARE
	SETZ 4000+DCCHN	;WRITE
	SETZ 14000+DCCHN	;WRITE WITH LONG EOR GAP

		;MAYBE FREE MTC FOR AWHILE (SKIPS IF SUCCESSFUL, IF NOT THEN LIKE MGMTCG)

MGMFGT:	SKIPE MSRPCL(W)	;MAIN PROGRAM WANT QUIT?
	JRST MGFMJ	;MAIN PROGRAM WANTS QUIT; RELEASE MTC AND NON-SKIP RETURN
	SKIPN MGMTCW	;SKIP IF WANTED
	JRST QPOPJ1	;NOBODY WANTS IT
	CONO MTC,0	;WAITED, FREE IT
	JRST MGMTCG	;GET IT BACK

QCLCJ:	MOVEI C,0
	POPJ Q,

MGCLCF:	MOVEI C,0
	JRST MGF

;MAGTAPE STORAGE AREA

EBLK

REPEAT TNMTCS,[
CONC MSCB,\.RPCNT,:	BLOCK MSCBL	;COMMAND BUFFER THIS XPT
	MGRCV		;ENTRY TO RING THE BUFFER
	MGNCMD		;BOTTOM ENTRY OF QDL, TO GET NEW COMMAND
CONC MGQD,\.RPCNT,:	BLOCK MGQDLL	;QDL THIS XPT
IFE .RPCNT,MSLCTB==.-MSCB0	;LENGTH OF EACH TABLE (FOR CALCULATING INDICES)
]

MTCMBP:	REPEAT TNMTCS,-MSCBL-1,,CONC MSCB,\.RPCNT,-1	;INPUT POINTER TO COMMAND BUFFER
MGCMBP:	REPEAT TNMTCS,4400,,CONC MSCB,\.RPCNT,-1	;OUTPUT POINTER FROM " "
MGQDLP:	REPEAT TNMTCS,-MGQDLL,,CONC MGQD,\.RPCNT,-1	;QDL QOINTER FOR INTERRUPT ROUTINE
MSCMDC:	REPEAT TNMTCS,-1	;1 LESS THAN # COMMANDS PUT INTO BUFFER BUT NOT COMPLETED
MSCMDT:	-1		;1 LESS THAN TOTAL # RUNNABLE XPORT ROUTINES
		;AN XPORT ROUTINE IS "RUNNABLE" IF ITS CMD BUF ISN'T EMPTY AND ROUTINE NOT HUNG

	;EACH POSSIBLE BLOCKING CONDITION HAS A LIST OF XPORT ROUTINES HUNG ON THAT CONDITION
	;RH (EACH LIST ENTRY) HAS ADR OF NEXT ENTRY OR 0 => THIS LAST ENTRY
	;LH XPORT #
	;LIST ENTRIES CLEARED OUT WHEN NOT ACTUALLY ON LIST
IFE C1MXP,MGDCW:	0	;INITIAL LIST ENTRY FOR XPORTS WANTING DC
MGMTCW:	0	;INITIAL LIST ENTRY FOR XPORTS WANTING MTC
MGMTCX:	0	;INITIAL LIST ENTRY XPORT WAITING FOR MTC/MTS TO INTERRUPT
MGCKL1:	0		;UNHANG XPT NEXT SLOW CLOCK BREAK
MGCKL2:	0		;" " SECOND " " "
	;^ ADD OTHER INITIAL LIST ENTRIES HERE ^
MGFLL:	REPEAT TNMTCS,0	;TRANSPORT ROUTINE HANG LIST ENTRIES
MSRPCL:	BLOCK NMTCS	;-1 => MAIN PROG TRYING TO STOP THIS XPT ROUTINE
MGRSB:	BLOCK NMTCS	;ROUTINE SPECIFICATION BITS THIS XPT

MTUSR:	REPEAT NMTCS,-1	;USER OF THIS MAGTAPE UNIT
MTUSE:	REPEAT NMTCS,-1	;1 LESS THAN # TIMES THIS UNIT OPEN
MTCUSE:	-1		;1 LESS THAN # TRANSPORTS OPEN (FOR DESELECTION)

MGCMD:	REPEAT NMTCS,CONO MTC,MTCRH+.RPCNT_15.(C)	;GIVE COMMAND TO MTC (RH HAS MODE STATUS)

MGHCNT:	105		;AOSN'D BY SLOW CLOCK
MGHNGC:	0		;CONO TO MTC TO UNHANG

;MORE MTAPE STORAGE AREA

MSSRCT:	REPEAT NMTCS,-1	;1 LESS THAN # ROUTINES DOING .STATUS THIS TRANSPORT
MSCCNI:	BLOCK NMTCS	;CONI MTC, FOR .STATUS
MSSCNI:	BLOCK NMTCS	;CONI MTS, FOR .STATUS
MGTMP1:	BLOCK NMTCS	;TEMP FOR INDIVIDUAL COMMAND AT INTERRUPT LEVEL
MGTMP2:	BLOCK NMTCS	;TEMP FOR INDIV. ETC., DATA TRANSFER => (SIGN => WRITE)
	;^ ADD OTHER TEMP VARS HERE ^

MTBUFO:	BLOCK NMTCS	;MAIN PGM ORIGIN OF BUFFER, 4.2-4.9 LINK TO NEXT BLOCK ON READ, 3.1-4.1 0
MTBUFP:	BLOCK NMTCS	;BYTE OR WORD POINTER INTO CURRENT BUFFER
MTBUFC:	BLOCK NMTCS	;COUNT REMAINING IN BUFFER
MTBSIZ:	BLOCK NMTCS	;READ => SIZE OF BUFFER
MSNBUF:	BLOCK NMTCS	;READ => NUMBER OF BUFFERS THIS TRANSPORT FILLED BUT NOT YET DISCARDED
MGBUFO:	BLOCK NMTCS	;INTERRUPT LEVEL ORIGIN OF BUFFER (CURRENTLY USED ONLY FOR READ)
MGBUFP:	BLOCK NMTCS	;INTERRUPT LEVEL POINTER TO BUFFER

MTERC:	BLOCK NMTCS	;ERROR CONI OF CURRENT IOC ERROR OR 0
MSERCT:	BLOCK TNMTCS	;ERROR COUNT .LT. 0 => REST OF WORD CONI MTS,; .STATUS => .GT. 0, HOLDS XPT #
MTBFS:	REPEAT NMTCS,100000,,MTDFRS	;MAIN PROGRAM LEVEL BUFFER STATUS + RANDOM
		;RH BLOCK LENGTH
		;LH 3.1-3.5 MUST BE ZERO
		;4.9 0 => BUFFERS ARE INPUT BUFFERS, 1 => OUTPUT
		;4.7, 4.6 WRITE COMMAND 0 => READ, 1 => READ/COMP, 2=> WRITE, 3=> WRITE W/ LONG EOR

MSMODE:	BLOCK NMTCS
		;1.1-1.8 PAGE # LAST REAL BUFFER ON LIST
		;2.1-2.4 # TIMES OPEN READING, 2.5-2.8 WRITING
		;3.2 EOT ON INTERRUPT LEVEL READ
		;3.3 EOF ON INTERRUPT LEVEL READ
		;3.4 READ => READ COMMAND IN COMMAND BUFFER
		;3.5 READ => INTERRUPT ROUTINE ALIVE OR ENCOUNTERED EOF
		;3.6 CHAR. MODE INPUT, 3.7 CHAR. MODE OUTPUT
		;3.8 NON-CHAR MODE INPUT, 3.9 NON CHAR MODE OUTPUT
		;4.1 (MAIN PGM) WRITING HAS OCCURRED SINCE LAST EOF WRITTEN
		;4.2 (INTERRUPT LEVEL) " " "
			;^ USED BY .RESET TO DECIDE WHETHER TO CLEAR 4.1
		;4.9 => EOF ON READ (SET AT MAIN PROGRAM LEVEL WHEN BUFFER EOF ENCOUNTERED)
MSXICT:	0		;NUMBER OF EXTRANEOUS MTC INTERRUPTS
MSTERC:	0		;NUMBER OF DATA ERRORS TOTAL LESS THOSE GIVEN TO USERS

MGDBP:	0		;BLKO/BLKI POINTER

MGDBK:	0		;MAGLOC+1:	JSR MGDBK
BBLK
	CONO MTS,1	;STOP TRANSPORT
	IFE C1MXP,CONO PI,PICOFF+DCCHNA	;TURN OFF DC
	JRST 12,@MGDBK	;THAT'S ALL

	;SET UP DATA TRANSFER (DC) VARIABLES

MGDCST:	HRRI A,MGDBP	;COMPLETE SETTING UP BLKO OR BLKI
	MOVEM A,MAGLOC	;STORE AS INTERRUPT INSTRUCTION
	MOVE A,[JSR MGDBK]
	MOVEM A,MAGLOC+1	;STORE INTERRUPT INSTRUCTION # 2
	POPJ P,

	;MOVEI B,<FIRST LIST ENTRY>
	;PUSHJ P,MGALST	;ADD PRESENT MAGTAPE XPORT TO END OF RELEVANT COMMAND LIST

MGALST:	SKIPE MGFLL(W)	;SKIP UNLESS ALREADY BLOCKED
	JRST 4,.	;ARGUMENT OR ALREADY BLOCKED
	SOS MSCMDT	;ONE FEWER ACTIVE XPORT ROUTINE
	MOVEI A,MGFLL(W)	;SET UP POINTER TO LIST ENTRY TO ADD
	MOVSM W,(A)	;STORE TRANSPORT NUMBER
	JRST ALIST	;GO DO IT

		;LIKE MGALST BUT ADD TO BEGINNING OF LIST

MGBLST:	SKIPE MGFLL(W)	;SKIP UNLESS ALREADY HUNG
	JRST 4,.
	SOS MSCMDT	;ONE FEWER ACTIVE XPORT ROUTINE
	MOVEI A,MGFLL(W)
	MOVSM W,(A)
	EXCH A,(B)
	HRRM A,@(B)
	POPJ P,

		;UNHANG XPORT ROUTINE (INITIAL LIST ENTRY ADR IN A)

MGUHNG:	SKIPN W,(A)
	POPJ P,		;NOBODY HUNG ON THIS CONDITION
	MOVS W,(W)	;GET DISPATCH AND POINTER TO NEXT ENTRY
	HLRZM W,(A)	;UPDATE LIST
	SETZM MGFLL(W)	;CLEAR OUT BLOCKING CONDITION
	AOS MSCMDT	;ANOTHER ACTIVE XPORT ROUTINE
			;DROPS THROUGH
		;AT INTERRUPT LEVEL GO TO XPORT ROUTINE (# IN W)

MGXGO:	MOVE Q,MGQDLP(W)	;GET QDL QOINTER
	PUSHJ P,QPOPJ	;CALL ROUTINE (SHOULD FINISH WITH POPJ P, OR PUSHJ Q,CPOPJ)
	MOVEM Q,MGQDLP(W)	;STORE BACK UPDATED POINTER
	POPJ P,

MGRCV:	MOVNI A,MSCBL+1		;AT END OF COMMAND BUFFER,
	ADDM A,MGCMBP(W)	;RING THE BUFFER, AND TRY AGAIN
MGNCM1:	ILDB B,MGCMBP(W)	;HERE FROM MGNCMD, GET NEW COMMAND
	JRST (B)		;GO DO IT (I END OF BUFFER THEN MGRCV)

MGNCMD:	MOVEI A,MGMAXE	;AT BOTTOM OF QDL, GET NEW COMMAND:
	MOVEM A,MSERCT(W)	;INITIALIZE ERROR COUNT FOR ROUTINE
	MOVEI C,0	;INITIALIZE C FOR ROUTINES THAT DON'T HACK WITH MTC
	AOBJN Q,MGNCM1	;SIMULATE PUSHJ
	JRST 4,.	;QDL QOINTER CLOBBERED

;MTAPE INTERRUPT ROUTINE INTERFACE WITH UTCBRK
;ENTRIES FROM UTCBRK: MGHBRK => MTC INTERRUPT, MGDBRK => DC AVAILABLE,
		; MGSBRK => BREAK TO RUN RUNNABLE XPORT ROUTINES

MGHBK2:	AOS MSXICT	;ANOTHER EXTRANEOUS MTC INTERRUPT
	CONO MTC,0	;MTC INTERRUPTING WHEN NOT WANTED, TRY TO FLUSH FLAGS
	CONI MTC,A	;GET CONI
IFN DSDP,	JUMPGE A,UTCBK2	;GOT GOBBLED BY OTHER PROCESSOR, DON'T WORRY
	TRNN A,77	;ASSIGNED TO THIS PROCESSOR, SEE IF PIA SUCCESSFULLY FLUSHED
	JRST UTCBK2	;OK NOW, FALL BACK INTO INTERRUPT ROUTINE
	JRST 4,MGHBK2	;MTC INTERRUPTING BUT CAN'T CLEAR INTERRUPT DESPITE CONI OF SIGN BIT

		;MTC DEVICE INTERRUPT

MGHBRK:	SKIPN W,MGMTCX	;IF NOBODY WAS WAITING FOR THIS INTERRUPT,
	JRST MGHBK2	;THEN TRY FLUSHING INTERRUPT FLAG AND GO AWAY MAYBE
	IOR C,MGRSB-MGFLL(W)	;IOR IN ROUTINE SPECIFICATION BITS
	SKIPN MGHCNT	;SKIP UNLESS JUST UNHUNG BY SLOW CLOCK
	TRO C,400000	;JUST UNHUNG, SET XPT HUNG FLAG
	HRRZM P,MGHCNT
	MOVEI A,MGMTCX	;POINTER TO XPORT WAITING FOR MTC INTERRUPT
	PUSHJ P,MGUHNG	;RUN HUNG ROUTINE
	CONSO MTC,77	;MTC FREE?
	SKIPN MGMTCW	;MTC WANTED?
	JRST MGRCHK	;NOT FREE OR NOT WANTED
MGMTCR:	MOVEI A,MGMTCW	;MTC WANTED AND FREE,
MGDBK2:	PUSHJ P,MGUHNG	;RUN HUNG ROUTINE
		;CHECK FOR RUNNABLE XPORT ROUTINES
MGRCHK:	SKIPL MSCMDT	;ANY RUNNABLE ROUTINES?
	JRST MGSBRK	;YES, GO RUN SOME, LOOP BACK TO MGRCHK
	CONSO MTC,77	;NO, CHECK MTC; FREE?
	SKIPN MGMTCW	;WANTED?
	IFE C1MXP,JRST MGEX7	;NOT FREE OR NOT WANTED, SO "EXIT"
	IFN C1MXP,JRST MGEX
	JRST MGMTCR	;FREE AND WANTED, GO RUN HUNG ROUTINE

		;RUN RUNNABLE XPORT ROUTINES THEN GO TO MGRCHK

MGSBRK:	MOVEI W,TNMTCS-1	;INITIALIZE POINTER FOR COUNTDOWN
MGSBK1:	SKIPL MSCMDC(W)	;SKIP IF XPORT INACTIVE
	SKIPE MGFLL(W)	;SKIP UNLESS UNIT HUNG
	JRST MGSBK2	;INACTIVE OR HUNG, TRY NEXT ONE
	SKIPL MSERCT(W)	;SKIP IF STOPPED
	PUSHJ P,MGXGO	;RUNNABLE, RUN IT
MGSBK2:	TRNE W,-1	;WAS THIS TRANSPORT ZERO?
	SOJA W,MGSBK1	;NO, GO CHECK MORE UNITS
	JRST MGRCHK	;THAT'S ALL

IFE C1MXP,[
MGEX7:	SKIPGE DCWANT	;UTC ROUTINES WANT DC?
	SKIPL DCFREE	;DC FREE?
	JRST MGMTCK	;NOT WANTED OR NOT FREE
	JRST UTCB0	;WANTED AND FREE, GIVE IT AWAY
]

		;DC AVAILABLE

MGDBRK:	IFN C1MXP,JRST 4,.	;GOT TO HERE FROM JUST BEFORE MGEX;
		; ^ FLUSH TRANSFER TO HERE AND RESTART AT MGEX
IFE C1MXP,[SKIPE W,MGDCW	;GET XPT # + MGFLL
	AOSE DCFREE	;DC AVAILABLE, GOBBLE IT
	JRST 4,.	;NOT FREE OR NOT WANTED
	CONO DC,0	;PREVENT EXTRANEOUS INTERRUPT FROM DATA CONTROL
	MOVEI A,MGDCW	;SET UP POINTER TO HUNG ROUTINE
	CONI MTS,C	;ALL DC BREAKS ALREADY HAVE MTC
	IOR C,MGRSB-MGFLL(W)	;IOR IN ROUTINE SPECIFICATION BITS
	JRST MGDBK2	;RUN HUNG ROUTINE, ETC.
]

		;SLOW CLOCK ROUTINE (CALLED WITH UTC OFF)

MSMGC2:	AOS MSCMDT	;ANOTHER RUNNABLE XPT ROUTINE
	SKIPA A,B	;GET NEXT LIST ENTRY (LOOP POINT)
MSMAGC:	MOVEI A,MGCKL1	;ENTRY, SET UP POINTER TO INITIAL LIST ENTRY
	MOVE B,(A)	;GET NEXT LIST ENTRY
	SETZB A,(A)	;CLEAR OUT ENTRY
	TRNE B,-1	;SKIP IF LAST ONE
	JRST MSMGC2	;NO, LOOP BACK FOR NEXT
	EXCH A,MGCKL2	;CLEAR OUT AND GET FIRST ENTRY FOR NEXT TICK
	MOVEM A,MGCKL1	;STORE AS NEW INITIAL ENTRY
	AOSN MGHCNT	;NOW CHECK FOR XPT HUNG
	CONO MTC,@MGHNGC	;XPT HUNG, UNHANG IT
	POPJ P,

]		;END CONDITIONAL

;PUSHJ P,ALIST
;B:	0,,-> LIST: 0,,-> CRUD,,-> ... LSTITEM: CRUD,,0

;CHANGE TO LSTITEM: CRUD,,C(A)
;IN OTHER WORDS, ADD AN ITEM TO THE END OF A LIST
;INTERRUPTS SHOULD BE SUPRESSED ENOUGH TO INSURE THAT
	;ITEMS ARE NOT SIMULTANEOUSLY BEING ADDED TO AND REMOVED
	;FROM THE LIST
;BUT NOTE: ALIST WINS (OR SHOULD, ANYWAY) IF MORE THAN ONE ITEM IS BEING ADDED TO THE LIST AT ONCE,
	;E.G. AT DIFFERENT INTERRUPT LEVELS

ALIST:	HLLZS (A)	;CLEAR OUT LH OF NEW ENTRY
	JRST ALIST2	;FALL INTO LOOP

ALIST1:	MOVEI TT,(B)	;CAUSE B TO POINT TO NEXT ITEM ON LIST
	CAIN B,(A)	;COMPARE WITH A
	JRST 4,.	;TRIED TO PUT ITEM ONTO LIST TWICE
ALIST2:	MOVE TT,(B)	;GET NEXT LIST ENTRY
	TRNE TT,-1	;SKIP IF END OF LIST
	JRST ALIST1	;NOT END OF LIST, TRY AGAIN
		;AT THIS POINT:
		;C(A) - GARBAGE,,ADR OF POINTER TO ADD
		;C(B) = ADR OF WHAT SEEMS TO BE LAST ITEM ON LIST
		;C(TT) = CONTENTS OF WHAT " " "
	HLL A,TT	;SET UP LH OF WHAT WILL REPLACE CURRENT LAST ENTRY
	EXCH A,(B)	;PUT ITEM ON LIST
	CAME A,TT	;COMPARE WHAT IT JUST WAS WITH WHAT IT USED TO BE
	JRST ALIST2	;LIST GREW WHEN NOT LOOKING SO A NOW POINTS
		;TO SOMETHING TAKEN OFF; GO PUT IT BACK ON
	POPJ P,

	;TO ADD TO BEGINNING OF LIST:
IFN 0,[	EXCH A,LIST
	HRRM A,@LIST
]	;NOTE THOUGH THAT THIS ISN'T RE-ENTERABLE LIKE ALIST
