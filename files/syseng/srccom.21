TITLE SRCCOM
;MORE THOROUGHLY ADAPTED TO ITS BY RMS, APRIL '72.
;*****(C)COPYRIGHT 1969 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.,USA*****
;CONVERTED FROM DEC'S VERSION 16 OF SRCCOM


TTI==0	;I/O CHANNEL ASSIGNMENTS
IN1==1
IN2==2
MRG==3	;/M OUTPUT DEVICE FOR MERGE FILE
TTO==4	;ITS NEEDS TYO CHANNEL
ERRC==5		;FOR ERR DEVICE.

	;MAIN AC DEFINITIONS

W1=1
W2=2
W3=3
FIL=4	;FILE # (0 IS FILE 1; 1 IS FILE 2)
F1=5	;LINE POINTER FILE 1 (CONTAINS INTEGER)
F2=F1+1	;DITTO FILE 2
FR=7	;FLAG REGISTER (LH) AND FILE #(0 OR 1)(RH)
C=10	;CONTAINS 1 CHAR FOR PROCESSING
T=11	;TEMPORARY AC
TT=12	;TEMP AC
BP=13
CS=14
P=17	;PUSH DOWN POINTER
LPDL==20	;LENGTH OF PUSH DOWN LIST

	;ASCII CHARACTERS

TAB==11
LF==12
FF==14
CR==15
VT==13	;VERTICAL TAB
ALTM==33	;/M ALT-MODE TO END TTY INPUT FOR MERGE(/M)

ITSEOF==3		;ITS USES ^C AS EOF

CALL=PUSHJ P,
RET=POPJ P,
SAVE=PUSH P,
REST=POP P,
;FLAGS - LH OF AC FR:

NOFORM==1		;DON'T OUTPUT FORM FEED
PAGSW==2
ENDSW==4	;END SWITCH (SUPPRESS FORM-FEED  IF FILES IDENTICAL)
SSWBIT==100	;/S SWITCH - IGNORE SPACING
CSWBIT==200	;/C SWITCH - IGNORE COMMENTS
ALLSW==400	;/B OR /M SWITCH (ALLOWS COMPARING BLANK LINES)
		; CL,LF,VT,FF STORED LIKE DATA AND COMPARED
EOF1SW==1000		;EOF SEEN ON FILE 1
EOF2SW==2000		;EOF SEEN ON FILE 2
IOTTY==4000		;OUTPUT TO TTY OR LPT
CTYPF==10000		;1 IF ANY CHARS TYPED FOR A COMMAND
EOLF==20000	;/M EOL CHAR (LF,VT,FF) SEEN BY G CHAR ROUTINE -/T SWITCH
MERGEF==40000	;/M SWITCH-MERGE 2 FILES INTO ONE CONVERSATIONALLY

MATCH==3		;# LINES TO BE MATCHED
WPL==100./5+1	;MEMORY WORDS/LINE
LPP==52.	;LINES/PAGE
COLINT==70.	;/M INITIAL SETTING FOR MAX. COLUMN TYPED OUT ON /M DIALOG

;/M THIS SRCCOM ALSO PERFORMS A MERGE FUNCTION IF /M IS TYPED
;/M DESTINATION FILE BECOMES MERGE OR 2 SOURCE FILES
;/M DIFFERENCES ARE TYPED ON TTY, USER SELECTS WHICH HE WANTS
;/M AND IN WHAT ORDER BY TYPING IN 1 LINE COMMAND AFTER EACH PAIR
;/M OF DIFFERENCES IS TYPED OUT.
;/M HE MAY TYPE 1, 2, AND/OR T IN ANY ORDER FOLLOWED BY CR
;/M OR HE MAY CHANGE THE LAST COLUMN TYPED OUT TO ### BY TYPING
;/M C### FOLLOWED BY CR AS A SEPARATE COMMAND AFTER ANY PAIR OF DIFFERENCES
;/M TYPED OUT.  SRCCOM WILL RESPOND WITH ANOTHER *, SO THE USER CAN TYPE
;/M ANOTHER COMMAND TO SELECT WHICH DIFFERENCES HE WANTS. INITIALLY THE
;/M MAX. COLUMN IS SET TO 72 WHENEVER SRCCOM IS RESTARTED WITH START COMMAND
;/M IT IS NOT RESET AFTER EACH FILE COMPARED.
BEG:	.OPEN	TTI,[SIXBIT/   TTY/]
	.VALUE
	.OPEN	TTO,[SIXBIT/  !TTY/]
	.VALUE
	MOVEI	W1,COLINT	;INIT. MAX COLUMNS.
	MOVEM	W1,COLMAX
	.SUSET	[.RSNAM,,MSNAME]	;GET DEFAULT SNAME.
	MOVE	P,[-LPDL,,PPSET-1]	;SET UP PDL.
	.BREAK	12,[5,,TTIBUF]	;IF NO DDT CMD STRING,
	SKIPE	TTIBUF
	JRST	RESTRT
	MOVE	0,[SIXBIT/SRCCOM/]
	CALL	TTOSIX		;IDENTIFY SELF TO USER.
	.IOT	TTO,[" ]
	MOVE	0,[.FNAM2]	;PRINT VERSION NUMBER.
	CALL	TTOSIX

;COME HERE FOR A NEW COMMAND, AFTER FINISHED OR ERROR.
RESTRT:	.OPEN	TTO,[SIXBIT/  !TTY/]
	.VALUE			;SINCE TTO WAS USED FOR OUTPUT.
	MOVEI 0,ENDP
	MOVEM 0,JOBFF		;SET JOBFF AFTER VARIABLE AREA

	MOVE P,[-LPDL,,PPSET-1]	;SET UP PUSH DOWN LIST
	.SUSET	[.RMEMT,,0]
	SUBI	0,1
	MOVEM	0,JOBREL	;LAST LEGAL MEM. ADDR.
	SETZM	PPSET		;THIS IS THE ZERO WHICH WILL
				;BE "BLT"ED TO CLEAR CORE
	MOVE	0,[PPSET,,PPSET+1]	;ITS
	BLT	ENDP-1	;ZEROED

	MOVEI 0,MATCH-1
	MOVEM 0,NUMLIN		;MATCH IS NORMALLY 3 LINES (N-1)

	AOS PAGNUM+0		;ZEROED BY BLT ABOVE-1ST PAGE IS 1
	AOS PAGNUM+1		;DITTO FOR SECOND FILE


	MOVSI FR,PAGSW+NOFORM	;INIT FR FOR NEW PAGE HEADING
	.BREAK	12,[5,,TTIBUF]
	SKIPN	TTIBUF		;IF DDT HAS CMD FOR US,
	JRST	CMD2
	MOVE	W1,[440700,,TTIBUF]
	MOVEM	W1,TTIPNT	;SET UP TO READ FROM IT.
	SETZ	CS,
CMD1:	ILDB	C,W1		;COUNT CHARS. IN IT.
	CAIE	C,^M
	AOJA	CS,CMD1
	MOVEM	CS,TTICNT	;SAVE NUM. CHARS TO READ.
	.BREAK	12,[400005,,[0]]	;MAKE SURE DON'T USE CMD AGAIN.
	SETOM	CTLCF		;SAY RETURN AFTER JUST THIS CMD.
	CAIA
CMD2:	CALL	TTILIN		;NO DDT CMD, READ TTY LINE.
	MOVEI	C,(SIXBIT/TTY/)	;DEFAULT, IF NO OUTPUT FILE SPEC.
	MOVEM	C,LSTDEV
	CALL	RFILES		;READ FILE NAME, DEFAULT DEV & SNM.
	CAIE	C,"_		;IF FOLLOWED BY "_", IS OUTPUT SPEC,
	JRST	CMD3
	MOVE	C,[INDEV,,LSTDEV]
	BLT	C,LSTSNM	;SO USE AS LST FILE NAMES.
	CALL	RFILED		;RE-DEFAULT DEV TO DSK.

;NOW HAVE READ WHAT IS CERTAINLY THE 1ST INPUT SPEC.
CMD3:	MOVEI	W1,IN1
	CALL	INOPEN		;NOW OPEN CHANNEL IN1.
	CALL	RFILE		;READ NAMES OF & OPEN 2ND INPUT.
	MOVEI	W1,IN2
	CALL	INOPEN

;NOW OPEN THE OUTPUT FILE.
CMD4:	MOVE	W2,[SIXBIT/COMPAR/]	;NORMAL DEFAULT OUTPUT FN2.
	MOVE	W1,[.OPEN TTO,LSTDEV]	;OPEN ON NORMAL OUTPUT CHNL.
	TLNN	FR,MERGEF	;BUT IF /M, CHANGE THEM.
	JRST	CMD5
	HRLI	W1,(.OPEN MRG,)
	MOVSI	W2,(SIXBIT/>/)
CMD5:	SKIPN	LSTFN2		;DEFAULT THE FN2 IF NEC.
	MOVEM	W2,LSTFN2
	MOVEI	W2,1
	HRLM	W2,LSTDEV	;(ASCII UNIT OUTPUT MODE)
	.SUSET	[.SSNAM,,LSTSNM]
	XCT	W1		;NOW OPEN IT.
	CALL	OPENLL		;ERROR RTN, IN CASE FAILED.
;FIND OUT HOW MUCH CORE IS AVAILABLE AND SET POINTERS AND LIMITS

BACKD:	AOS	W1,JOBFF
	HRRZM W1,LBUFP1		;SET 1ST ADDRESS FILE 0
	SETZM 1(W1)		;FORCE NULLS INTO BUFFER
	HRRZM	W1,LBUFP2		;DITTO FILE 2
	MOVE	W1,JOBREL
	SUB	W1,JOBFF		;COMPUTE SPACE AVAILABLE
	HRRZS	W1
	LSH	W1,-1		;AVAILABLE SPACE/2
	ADDB	W1,LBUFP2	;INPUT POINTER FILE 2 STARTS HALF WAY THROUGH BUFFER
	SETZM 1(W1)		;FORCE NULLS INTO BUFFER

	HRLOI 0,377777
	MOVEM 0,OLDNUM+0	;ANY LINE # IS SMALLER THAN
	MOVEM 0,OLDNUM+1	;  THIS ONE

	SETOB	F1,TOP1		;INITIALIZE TOP OF EACH FILE
	SETOB	F2,TOP2		;THE TOP IS THE HIGHEST LINE THAT WE HAVE EXAMINED
	JRST	MAINST		;START COMPARE WITH 1ST LINES
;THE FOLLOWING CODE IS THE GUTS OF THE PROGRAM.
;WHEN THE LOOP AROUND MAIN DETECTS THAT TWO LINES ARE NOT A MATCH
;CONTROL GOES OFF TO DETERMINE THE EXTENT OF THESE DIFFERENCES.
;THE TOTAL DIFFERENCES ARE DETERMINED AS FOLLOWS.  FIRST GET TWO 
;MORE LINES. DOES THE ORGINAL LINE IN FILE 1 WHICH DID NOT MATCH
;MATCH THE NEW LINE FROM FILE TWO. IF SO THEN THE ORGINAL LINE
;IN FILE 2 WAS AN INSERTION. (OR A DELETION).  IF NO MATCH THIS 
;WAY TRY IT THE OTHER WAY. IF STILL NO MATCH GET TWO MORE LINES
;TAKE THE NEW LINE FROM FILE 1 AND TRY TO MATCH IT AGAINST ALL THE
;LINES WE HAVE BEEN EXAMINING IN FILE TWO; THEN DO IT THE OTHER
;WAY AROUND. EOF'S ARE DETECTED BY "GETTWO"  WITH NO RETURN SKIP

MAIN:	TRZ	FR,-1		;THIS FOR FILE ONE
	SETZM	MRGOUT(FR)	;/M MAKE SURE FILE ONE NOT OUTPUT IN MOVEUP
	PUSHJ	P,MOVEUP	;MOVE UP THE BOTTOM, BECAUSE WE ARE FINISHED
				;WITH TWO LINES
	HRRI	FR,1		;NOW FOR FILE TWO
	TLNE	FR,MERGEF	;/M IN EFFECT?
	SETOM	MRGOUT(FR)	;/M YES, OUTPUT FILE TWO(CONTAIN MATCH LINES ONLY)
				;/M IN MOVEUP ROUTINE
	PUSHJ	P,MOVEUP	;UP GOES THE BOTTOM POINTER
MAINST:	SETOB	F1,F2		;INITIALIZE LINE POINTERS
	PUSHJ	P,GETTWO	;GET TWO LINES
	  JRST	MAIN15		;ONE FILE SHORT
	PUSHJ	P,COMPL	;COMPARE THESE TWO LINES
	  JRST	MAIN		;THEY MATCH--LOOK AT NEXT TWO

;WHEN WE GET HERE WE HAVE DETECTD A DIFFERENCE
;NOW THE PROGRAM WILL LOOK AHEAD TO TRY AND FIND THE NEXT TWO
;MATCHING LINES

MAIN10:	PUSHJ	P,GETTWO	;GET THE NEXT TWO LINES
	  JRST	MAIN15		;ONE FILE SHORT
	SETZ	F1,		;RESET POINTER FOR FIRST FILE TO
				;THE LINE IN WHICH THE DIFFERENCE WAS FOUND


MAIN12:	PUSHJ	P,COMPL	;NOW SEE IF WE CAN MATCH THAT LINE
	  JSP W1,MULTI		;FOUND 1 LINE MATCH- LOOK FOR MULTIPLE
	CAME	F1,F2		;HAVE WE LOOKED FROM THE MISMATCHED LINE
				;TO THE CURRENT LINE?
	AOJA	F1,MAIN12	;NO--UP LINE POINTER AND TRY AGAIN
	SETZ	F2,		;HAVEN'T FOUND A MATCH THIS TIME
				;NOW TRY IT THE OTHER WAY

MAIN14:	CAML	F2,F1		;LOOKED FAR ENOUGH? (THIS VERSION HAS
				;THE INEFFICIENCY MENTIONED IN THE LIBRARY
				;WRITE UP REMOVED- TWE)
	JRST	MAIN10		;YES
	PUSHJ	P,COMPL
	  JSP W1,MULTI		;LOOK FOR MULTI LINE MATCH
	AOJA	F2,MAIN14	;INDEX AND LOOK SOME MORE

;THE MAIN15 CODE HANDLES THE CASE OF EITHER (OR BOTH) FILES
;HAVING NO LINES TO COMPARE. IF BOTH FILES HAVE NO LINES, "FINISH"
;PRINTS OUT ALL LINES IN BOTH FILES (IF ANY) AS DIFFERENCES.
;IF EITHER FILE HAS A NEW LINE, THE SHORTER FILE IS
;SEARCHED FOR A MATCH FOR THAT LINE. THIS CONTINUES (READING A NEW LINE
;FROM THE LONGER FILE) UNTIL NEITHER FILE HAS ANY LINES OR UNTIL A
;MATCH IS FOUND.

MAIN15:	SKIPGE W1,GETFIL	;DOES EITHER FILE HAVE A LINE?
	JRST FINISH		;NO
	HRRZM W1,FIL		;SAVE FILE # THAT HAS LINES
	HRR FR,W1		;SETUP FR FOR MAIN18
	JUMPL F1,MAIN18		;TRA IF FILE 1 HAS NO LINES
	JUMPL F2,MAIN18		;DITTO FILE 2
	TRC FIL,1		;CHANGE 1 TO 0 (OR VICE VERSA)
	SETOM F1(FIL)		;LOOK THRU SHORT FILE FOR MATCH
MAIN17:	MOVE W1,F1(FIL)
	CAML W1,TOP1(FIL)	;SEARCHED THRU SHORT FILE?
	JRST MAIN10		;YES, AND NO MATCH
	AOS F1(FIL)		;INDEX LINE
	PUSHJ P,COMPL		;LOOK FOR A MATCHING LINE
	  JSP W1,MULTI		;FOUND A MATCH, NOW LOOK FOR MULTIPLE MATCH
	JRST MAIN17		;NO MULTI LINE MATCH

MAIN18:	PUSHJ P,PNTTXT		;ALL LINES ARE GONE FROM 1 FILE,
				;OUTPUT THE OTHER WITHOUT USING CORE
	PUSHJ	P,TRYMRG	;/M CHECK TO SEE IF THIS IS A MERGE AND OUTPUT IF YES
	  JRST	MAIN		;/M YES
	JRST	MAIN		;/M NO

;AT THIS POINT NEITHER FILE HAS ANY MORE LINES TO BE READ.
;PRINT AS DIFFERENCES ANY LINES REMAINING FOR EITHER FILE.

FINISH:	JUMPGE F1,FIN1		;PRINT DIFFERENCES IF EITHER BUFFER
	JUMPL F2,FIN2		;  HAS ANY LINES IN IT
FIN1:	PUSHJ P,PNTBTH		;PRINT ANY LINES
	MOVEI C,14
	PUSHJ P,TYO		;RELEASE PAGE ON PRINTER
FIN2:	MOVEI T,[ASCIZ /NO DIFFERENCES ENCOUNTERED/]
	SKIPN ERRCNT		;ANY DIFFERENCES?
	PUSHJ P,TYPMSG		;NO, PRINT MESSAGE
	SKIPE	ERRCNT		;/M ANY DIFFERENCES?
	TLNN	FR,MERGEF	;/M YES, MERGE IN PROGRESS?
	JRST	RELDEV		;/M NO, END OF SOURCE COMPARE
	MOVEI	T,[ASCIZ /END OF MERGE/]
	PUSHJ	P,TYPMSG	;/M YES, PRINT END OF MERGE
	JRST RELDEV		;END OF SOURCE COMPARE

;THIS SECTION LOOKS FOR MULTI LINE MATCH

MULTI:	SKIPG NUMLIN		;MULTIPLE LINE TEST?
	JRST MULT8		;NO
	HRRZM W1,RTNTMP		;YES, SAVE RETURN ADDRESS
	SETZM NUMTMP		;INIT MULTI-LINE COUNTER
	MOVEM F1,TEMPF1		;SAVE CURRENT POINTERS
	MOVEM F2,TEMPF2
MULT2:	PUSHJ P,GETTWO		;GET NEXT TWO LINES
	  JRST MULT4		;ONE FILE DOESN'T HAVE A LINE
	PUSHJ P,COMPL		;COMPARE THEM
	  JRST MULT6		;MATCH, TEST MULTI COUNTER
MULT4:	MOVE F1,TEMPF1		;NO MATCH, RESET REGS
	MOVE F2,TEMPF2
	JRST @RTNTMP		;RETURN TO WHERE WE GOT TO MULTI FROM

MULT6:	AOS W1,NUMTMP		;INDEX MULTI-LINE COUNTER
	CAMGE W1,NUMLIN		;TEST FOR END
	JRST MULT2		;TEST NEXT TWO
	SUB F1,W1		;RESET TO 1ST COMPARISON
	SUB F2,W1
MULT8:	PUSHJ P,PNTBTH		;PRINT DIFFERENCES

;THE TEXT OF DIFFERENCES HAS BEEN PRINTED--PUT IN ******
;AND A CARRIAGE RETURN-LINE FEED AND GO BACK AND START COMPARING
;WHEN WE START COMPARING AGAIN THE LINE POINTERA WILL
;BE POINTING TO THE FIRST TWO LINES AFTER THE MATCHING LINES

	PUSHJ	P,TRYMRG	;/M CHECK IF /M IN EFFECT, ASK FOR COMMAND
				;/M AND OUTPUT IF YES
	  JRST	MULT10		;/M IN EFFECT
	MOVE W1,[440700,,[ASCIZ /***************/]]
	PUSHJ P,PRINT
	PUSHJ P,PCRLF		;PRINT CARRIAGE RETURN-LINE FEED
MULT10:	ADD F1,NUMLIN		;CAUSE MOVEUP TO FLUSH ALL THE
	ADD F2,NUMLIN		;  LINES THAT WERE JUST MATCHED
	JRST MAIN		;DIFFERENCES PRINTED- LOOK FOR MORE

;/M ROUTINE TO TEST IF MERGE IN EFFECT AND IF YES
;/M ACCPT COMMAND AND PASS TO MERGE OUTPUT FILE
;/M COMMANDS ARE ANY COMBINATION OF 1,2, AND/OR T (WITH NO COMMAS)
;/M ALL OTHER CHARACTERS ARE ILLEGAL
;/M CALL:	PUSHJ P,TRYMRG
;		  MERGER DONE RETURN
;		/M NOT IN EFFECT RETURN

TRYMRG:	TLNN	FR,MERGEF	;/M  /M SWITCH IN EFFECT?
	JRST	CPOPJ1		;/M NO, SKIP RETURN
	SUBI	F1,1		;/M REDUCE COUNT BY 1 SO NOT COUNTING THE FIRST
				;/M MATCH LINE PRINTED
	SUBI	F2,1		;/M REDUCE COUNT BY 1 SO NOT COUNTING THE FIRST
				;/M MATCH LINE PRINTED
	PUSHJ	P,GETMRG	;/M TYPE *,GET ALL OF MERGE COMMAND(CHECK SYNTAX)
LISTEN:	PUSHJ	P,MRGIN	;/M GET NEXT MERGE COMMAND INPUT CHAR
	HRRI	FR,0		;/M ASSUME USER TYPE "1" (FILE 0)
	CAIN	C,"1		;/M DID HE?
	JRST	MRG2		;/M YES, COPY JUST DIFFERRENCES OF FILE 1
				;/M INTO MERGE OUTPUT FILE
	HRRI	FR,1		;/M NO, ASSUME USER TYPED "2" (FILE 1)
	CAIE	C,"2		;/M DID HE?
	JRST	MRG3		;/M NO, CHECK CR, LF, ALTM
MRG2:	SETOM	MRGOUT(FR)	;/M YES, SET FLAG SO MOVEUP WILL OUTPUT
	PUSHJ	P,MOVEUP	;/M MOVE BUFFER UP OVER DIFFERENCES USER WANTS
	SETOM	F1(FR)		;/M NOW FLAG BUFFER AS BEING EMPTY(LINE COUNT=-1)
				;/M (EVEN THOUGH MATCH LINES STILL LEFT)
	JRST	LISTEN		;/M GO GET ANOTHER CHARACTER

MRG3:	CAIE	C,"T		;/M "T" TYPED?
	JRST	MRG4		;/M NO, CHECK FOR END OF COMMAND
MRG3B:	CALL	TTILIN
MRG3A:	PUSHJ	P,TTICHR	;GET TTY INPUT CHAR.
	CAIN	C,ALTM		;/M ALT-MODE?
	JRST	LISTEN		;/M YES, END OF INSERT FROM TTY
	PUSHJ	P,MRGO		;/M NO, OUTPUT CHAR TO MERGE FILE
	CAIE	C,^M		;CR -> SPECIAL.
	JRST	MRG3A		;ELSE GET MORE
	MOVEI	C,^J		;PUT IN ^J AFTER ^M.
	CALL	MRGO
	JRST	MRG3B		;GET NEXT TTY LINE.

MRG4:	CAIE	C,0		;/M MUST BE NULL(END OF COMMAND)
	.VALUE			;/M NO SOME THING IS VERY WRONG
	HRRI	FR,0		;/M FLUSH DIFFERENCES IN FILE ONE IF NOT ALREADY
	SETZM	MRGOUT(FR)	;/M BUT DO NOT OUTPUT ON MERGE FILE
	SKIPL	F1(FR)	;/M ALREADY OUTPUT ON MERGE FILE?
	PUSHJ	P,MOVEUP	;/M NO, OUTPUT DIFFERENCES AND FLUSH
	HRRI	FR,1		;/M FLUSH DIFFERENCES IN FILE TWO IF NOT ALREADY
	SETZM	MRGOUT(FR)	;BUT DO NOT OUTPUT ON MERGE FILE
	SKIPL	F1(FR)		;/M ALREADY OUTPUT ON MERGE FILE?
	PUSHJ	P,MOVEUP	;/M NO, OUTPUT DIFFERENCES AND FLUSH
	ADDI	F1,1		;/M ADD BACK MATCH LINE
	ADDI	F2,1		;/M ADD BACK MATCH LINE
	POPJ	P,		;/M RETURN, LEAVING MATCH LINES STILL IN BUFFER
				;/M AND F1 AND F2 AT -1
;THIS ROUTINE SETS UP THE POINTERS TO THE TEXT

;MEMORY STORAGE AREA LOOKS LIKE THIS:
;1) BUFFER SPACE FOR FILE # 0 (POINTED TO BY LBUFP1)
;	A) XWD (PAGE #),(WORD COUNT FOR LINE (INCLUDING THIS WORD))
;	   TEXT FOR LINE 0
;	    MORE TEXT FOR LINE 0
;	     & MORE, ENDED WITH A NULL
;	B) MORE LINES (EACH WITH PAGE #,WORD COUNT, AND TEXT
;2) BUFFER SPACE FOR FILE 1 (POINTED TO BY LBUFP2)
;	A) AS ABOVE

SETP:	HRRI FR,1		;SET UP POINTER FILE 1
	PUSHJ P,SETONE
	HRRI FR,0		;DITTO FILE 0

SETONE:	MOVE W3,F1(FR)		;GET LINE #
SETON1:	MOVE TT,OLDNUM(FR)	;GET LAST # COMPUTED FOR
	MOVEM W3,OLDNUM(FR)	;SAVE NEW # AS OLD
	CAML W3,TT		;IS NEW LARGER THAN OLD?
	SKIPA T,OLDPNT(FR)	;YES, START FROM OLD BYTE POINTER
	SKIPA T,LBUFP1(FR)	;NO, START FROM BEGINNING
	SUB W3,TT		;LOOP ONLY FROM OLD POINTER
	MOVSI TT,(ADD T,(T))	;(SET UP IN AC)
	MOVE TT+2,[JRST SETON2]	;SET UP AC
	MOVE TT+1,.+1		;SET UP AC
	SOJGE W3,TT
			;TT/	ADD T,(T)	;ADD IN WORD COUNT FOR LINE
			;TT+1/	SOJGE W3,.-1	;MORE LINES LEFT?
			;TT+2/	JRST SETON2	;NO

SETON2:	HRRZM T,OLDPNT(FR)		;SAVE POINTER TO THIS LINE
	HRLI T,700	;NO, CHANGE TO BYTE POINTER
	MOVEM T,W1(FR)
	POPJ P,



;MOVE UP THE POINTERS WHICH POINT TO THE LINES FROM WHICH WE
;ARE EXAMINING.  THIS IS DONE EVERYTIME A MATCH IS FOUND

MOVEUP:	SKIPE	MRGOUT(FR)	;/M SHOULD TEXT ABOUT TO BE OVERWRITTEN
				;/M BE OUTPUT TO MERGE OUTPUT FILE? (CAN BE
				;/M MATCHED OR UNMATCHED LINES-CAN BE
				;/M ON ONLY IF /M
	SKIPGE	W3,F1(FR)	;/M YES, DOES THIS FILE HAVE ANY LINES?
	JRST	MOVUP4		;/M NO, JUST OVERLAY THESE LINES
	CAMLE	W3,TOP(FR)	;/M IS F1(FR) BIGGER THAN NO. OF LINES-1 LEFT?
	MOVE	W3,TOP(FR)	;/M YES, ONLY OUTPUT THE ONES IN THE BUFFER
	HRRZ	T,LBUFP1(FR)	;/M YES, GET ABSOLUTE ADR OF FIRST LINE
MOVUP0:	MOVEI	W1,1(T)		;/M FORM ADDRESS OF FIRST WORD OF TEXT
	HRLI	W1,440700	;/M MAKE ASCII BYTE POINTER TO PICKUP
				;/M FIRST CHARACTER

MOVUP1:	ILDB	C,W1		;/M GET NEXT CHAR FROM LINE
	JUMPE	C,MOVUP2	;/M NULL FLAGS END OF FILE
	PUSHJ	P,MRGO		;/M OUTPUT CHAR TO MERGE FILE
	JRST	MOVUP1		;/M AND LOOK FOR MORE

MOVUP2:	ADD	T,(T)		;/M ADD WORD LENGTH OF LINE JUST OUTPUT TO
				;/M ADDRESS OF HEADER WORD
	SOJGE	W3,MOVUP0	;/M DECREASE LINE COUNT, FINISHED?
MOVUP4:	MOVE W3,F1(FR)		;GET LINE # FOR THIS FILE
	CAML W3,TOP(FR)		;GETTING RID OF ALL LINES?
	JRST MOVEX		;YES, DON'T MOVE MEMORY
	AOS W3,F1(FR)		;GET LINE # OF LINE TO SAVE
	PUSHJ P,SETON1		;GET ADR OF 1ST LINE TO SAVE
	HRL T,LBUFP1(FR)	;SET UP BLT AC (REVERSED)
	PUSH P,T		;SAVE
	AOS W3,TOP(FR)		;GET 1ST NON-EXISTANT LINE #
	PUSHJ P,SETON1		;GET CORRESPONDING 1ST ADR
	POP P,W1
	SUB T,W1		;CALCULATE WORD COUNT OF TRANSFER
	ADD T,LBUFP1(FR)	;CALCULATE "E" OF BLT AC,E
	MOVSS W1		;SWITCH AC TO XWD FROM,TO
	BLT W1,(T)		;AND AWAY WE GO

MOVEX:	SETCM	W2,F1(FR)	;W2_-<(F1)+1>
	ADDM	W2,TOP(FR)	;CHANGE TOP TO ACCOUNT FOR DEAR DEPARTED LINES
	HRLOI	0,377777
	MOVEM	0,OLDNUM(FR)	;FORCE SETON1 TO RECALCULATE
	POPJ	P,
;CODE FOR GETTING TWO LINES
;CALLING SEQUENCE IS:
;	PUSHJ P,GETTWO
;	   RETURN 1 IF EITHER FILE HAS NO MORE LINES
;	   RETURN 2 IF ONE LINE READ FROM EACH FILE
; C(GETFIL)=THE # OF FILE FOR WHICH A LINE WAS READ (OR -1 IF NONE)

GETTWO:	SETOM	GETCNT		;INIT # LINESOBTAINED
	SETOM GETFIL		;INIT FILE # LINE CAME FROM
	TRZ	FR,-1		;ZERO RIGHT HALF OF "FR"--SET FOR FIRST FILE
	PUSHJ	P,GLINE	;GET A LINE FROM FIRST FILE
	HRRI	FR,1		;NOW DO FOR SECOND FILE
	PUSHJ	P,GLINE
	SKIPLE	GETCNT		;GETCNT .G. 0 IF TWO LINES WERE GOT
	AOS	(P)		;SKIP IF 2 LINES WERE AVAILABLE
	POPJ	P,

GLINE:	TLZ	FR,EOLF		;/M CLEAR EOLF(LF,VT,FF) SEEN FLAGS TESTED
				;/M BY GCHAR ROUTINE
	AOS	W1,F1(FR)	;BUMP THE LINE POINTERS
	CAMG	W1,TOP(FR)	;HAVE WE GONE OVER THE TOP
	JRST	GLEXIT		;NO, LINE WAS AVAILABLE
	SOS	F1(FR)		;NOT CLEAR YET THAT A NEW LINE EXISTS
GLINE1:	HRLS	PAGNUM(FR)	;SAVE PAGE # AT BEGINNING OF LINE
	PUSHJ	P,GCHAR	;GET A CHARACTER
	TLNE	FR,@EOFTBL(FR)	;END OF FILE?
	POPJ	P,		;YES, NO LINE
	TLNN FR,ALLSW		;SKIP IF COMPARING BLANK LINES
	JUMPE	C,GLINE1	;NULLS INDICATE BLANK LINES
	AOS W1,F1(FR)		;THERE ARE CHARS FOR A NEW LINE
	MOVEM W1,TOP(FR)		;THIS LINE IS THE TOP LINE
	PUSHJ P,SETONE		;CALCULATE BYTE POINTER
	MOVE W1,W1(FR)		;GET BYTE POINTER IN W1
	MOVEM W1,WCADR		;SAVE ADR OF LINE WORD COUNT
	MOVE W2,PAGNUM(FR)	;PICKUP PAGE # AT BEGINNING OF LINE
	HLLZM W2,(W1)		;SAVE WITH THIS LINE
	JRST GLINE3

GLINE2:	PUSHJ	P,GCHAR	;GET NEXT CHAR FOR LINE
GLINE3:	TLNN W1,760000		;WILL NEXT IDPB GO INTO NEXT WORD?
	JRST	MLLIT	;ITS
MLLITR:	IDPB	C,W1		;STORE CHARS IN LINE BUFFER
	JUMPN	C,GLINE2	;NULL CHARACTER IS END OF LINE
	MOVE W3,WCADR		;GET BACK ADR OF WORD COUNT
	SUBI W1,-1(W3)		;CALCULATE WORD COUNT
	HRRM W1,(W3)		;SAVE WORD COUNT IN BUFFER
GLEXIT:	AOS	GETCNT		;INDEX # LINES FOUND
	HRRZM	FR,GETFIL	;SAVE # OF THIS FILE
	POPJ	P,

GLTBL:	LBUFP2		;POINTS TO TOP ADR FILE 0
	JOBREL		;POINTS TO TOP ADR FILE 1
MLLIT:	HRRZ W3,@GLTBL(FR);YES,GET HIGHEST ADR FOR THIS BUFFER
		CAIG W3,3(W1)	;CHECK ADR. (LEAVE 1 WORD FOR WORD
				;COUNT FOR NEXT LINE PLUS 1 WORD
				;SLOP TO BE SAFE
		JRST NOROOM	;NO ROOM IN THE INN
		HLRZM C,1(W1)	;PUT BIT17 INTO BIT35 (FOR SEQUENCE #)
	JRST MLLITR	;RETURN
;IF A "CORE" UUO IS INSTALLED HERE, IT MUST ADJUST THE FOLLOWING
;LIST OF LOCATIONS (ALL BY THE AMOUNT THE SECOND BUFFER AREA
;IS MOVED, IF ANY):
;1) BYTE POINTER ADDRESS IN: W1
;2) BUFFER POINTER IN: LBUFP2
;3) 1ST ADDRESS FOR LINE IN: 0(P) ON PUSH DOWN LIST
;THEN RETURN TO THE IDPB NEAR GLINE2+6


NOROOM:	PUSH P,W1	;SAVE BYTE POINTER
	TRC FR,1	;CHANGE 1 TO 0 (OR VICE VERSA)
	MOVE W3,TOP(FR)	;GET TOP LINE # FOR "OTHER" FILE
	ADDI W3,1	;FIND 1ST ADR OF THE NEXT LINE ABOVE TOP
	PUSHJ P,SETON1	;GET ADR
	HRRZM T,HIGH	;SAVE 1ST FREE ADR OF NON-FULL FILE
	HRRZ T,@GLTBL(FR);GET HIGHEST ADR AVAILABLE TO NON-FULL FILE
	SUB T,HIGH	;GET SPACE AVAILABLE
	SUBI T,2	;LEAVE 1 WRD FOR NEXT LINE WORD COUNT
			;PLUS 1 WORD SLOP TO BE SAFE
	TRC FR,1	;CHANGE FILE # BACK TO THE WAY IT WAS
	MOVEM T,ROOM	;SAVE ROOM AVAILABLE
	CAIL T,400.	;COMPARE WITH 400. (NO MAGIC SIGNIFICANCE)
	JRST NOR2	;PLENTY ROOM AVAILABLE- DON'T GET MORE CORE

	HRRZ T,JOBREL
	MOVEM T,W1	;SAVE THIS JOBREL AS "OLD" JOBREL
	LSH T,-12	;ITS. CONVERT TO BLOCKS
	ADDI T,2	;REQUEST CORE SIZE CONTAINING THIS ADDRESS
NOR1:	.CORE 0(T)	;ITS GET CORE
	.VALUE
	JRST NOR3	;SUCCESS

NOR3:		MOVE T,[.RMEMT,,T]	;ITS GET TOP OF CORE
	.SUSET T	;ITS
	SUBI T,1	;ITS LAST LEGAL ADDR
	MOVEM T,JOBREL	;ITS SAVE JOBREL
HRRZ T,JOBREL	;CORE UUO SUCCESFUL- GET "NEW" JOBREL
	SUB T,W1	;FIND OUT HOW MUCH WAS ADDED
	ADDB T,ROOM	;UPDATE TOTAL ROOM AVAILABLE
NOR33:	TRNE FR,1	;WHICH FILE NEEDED ROOM?
	JRST NOR98	;FILE #1, IT JUST GOT IT
			;FILE #0, SHUFFLE CORE
NOR2:	ASH T,-1	;DIVIDE AVAILABLE SPACE BETWEEN FILES
NOR4:	MOVEM T,ROOM	;FILE #1 GETS MOVED THIS AMOUNT
	TRNN FR,1	;WHICH FILE NEEDED ROOOM?
	JRST NOR5	;FILE #0. MOVE #1 TOWARD 777777
			;FILE #1. MOVE #1 TOWARD 0
NOR6:	MOVNS T,ROOM	;FILE IS MOVING IN NEGATIVE DIRECTION
	ADDM T,WCADR	;WORD COUNT ADR FOR FILE# 1 IS MOVED DOWN
	ADDM T,(P)	;SAME WITH BYTE POINTER
	MOVE W1,(P)	;GET LAST ADR TO MOVE FROM BYTE POINTER
	ADD T,LBUFP2	;GET "TO" ADR. [(LBUFP2)-D OF M]
	HRL T,LBUFP2	;GET "FROM" ADR
	BLT T,(W1)	;BLT T,"E" (T/  XWD "FROM","TO")
	JRST NOR90

NOR5:	MOVE W1,T	;GET D OF M
	HRLI W1,(POP T,(T))	;SETUP- POP T,<D OF M>(T) INTO W1
	MOVE W2,HIGH	;GET HIGH(+1) ADR OF FILE #1
	SUB W2,LBUFP2	;GET LENGTH OF FILE #1
	SOS T,HIGH	;GET LAST ADR IN FILE #1
	HRLI T,400000(W2);PUT WORD COUNT(+400000) IN LEFT HALF
			;400000 AVOIDS PDL OVERFLOW PROBLEM IN AC LOOP
	MOVE W3,[JRST NOR90]
	MOVE W2,.+1
	JUMPL T,W1	;W1/	POP T,<DISTANCE OF MOVE>(T)
			;W2/	JUMPL T,W1
			;W3/	JRST NOR90
;THE ABOVE INSTRUCTIONS ARE A REVERSE BLT AND ARE IN THE AC'S FOR SPEED

NOR90:	MOVE T,ROOM	;GET DISTANCE FILE #1 WAS MOVED
	ADDM T,LBUFP2	;MODIFY STARTING ADR OF FILE #1
	HRLOI 0,377777
	MOVEM 0,OLDNUM+1	;FORCE "SETONE" TO RECALCULATE BYTE POINTER
NOR98:	POP P,W1
NOR99:	JRST GLINE3	;CHECK COMPUTATIONS ON RETURNING

;THIS PAGE CONTAINS ROUTINE FOR COMPARING TWO LINES
;IT HAS TWO RETURNS--CALLING ADR.+1 IF LINES MATCH OR
;CALLING ADR+2 IF NO MATCH

COMPL:	PUSHJ	P,SETP		;CALCULATE POINTERS TO TEXT
	MOVEM	W1,P1		;P1=TEMP POINTER TO TEXT FOR FIRST FILE
	MOVEM	W2,P2		;P2 FOR SECOND FILE
COMPL1:	ILDB	W1,P1		;GET A CHARACTER FROM LINE FROM FIRST FILE
COMPL2:	ILDB	W2,P2		;AND ONE FROM SECOND FILE
COMPL0:	CAME	W1,W2	;THIS IS THE BIG TEST--ARE THEY EQUAL
	JRST	COMPL4		;NO
COMPL7:	CAIN	W1,";		;YES, COMMENT?
	TLNN	FR,CSWBIT	;YES, SUPPRESS COMMENTS?
	JUMPN	W1,COMPL1	;NO,NO. TEST FOR END OF LINE
	POPJ	P,		;LINES MATCH, RETURN

COMPL3:	ILDB	W1,P1		;GET NEW CHAR FOR FILE 1
COMPL4:	CAIE	W1,40		;SPACE?
	CAIN	W1,TAB		;OR TAB?
	TLNN	FR,SSWBIT	;AND IS SPACING BEING IGNORED?
	SKIPA			;NO
	JRST	COMPL3		;FLUSH SPACE OR TAB FOR FILE 1

	CAIE	W2,40		;SPACE?
	CAIN	W2,TAB		;OR TAB?
	TLNN	FR,SSWBIT	;AND IS SPACING BEING IGNORED?
	SKIPA			;NO
	JRST	COMPL2		;YES, FLUSH A SPACE OR TAB FOR FILE 2

	CAMN	W1,W2		;ARE THE CHARACTERS NOW THE SAME?
	JRST	COMPL7		;YES, TEST FOR END OF LINES

	CAIE	W1,";		;COMMENT IN FILE 1?
	CAIN	W2,";		;OR IN FILE 2?
	TLNN	FR,CSWBIT	;AND ARE COMMENTS BEING IGNORED?
	JRST	CPOPJ1		;NO, FILES DON'T MATCH, SKIP RETURN
	JUMPE	W1,CPOPJ	;YES, OTHER CHAR MUST BE NULL OR ELSE ONE
	JUMPE	W2,CPOPJ	;  LINE IS LONGER THAN OTHER AND FILES DIFFER
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,
;WHEN WE GET TO THIS POINT WE HAVE FOUND 
;THE EXTENT OF THE DIFFERENCES AND WE ARE READY TO PRINT
;THESE DIFFERENCES OUT

PNTBTH:	TRZ FR,-1		;OUTPUT FILE 1
	PUSHJ P,PNTTXT		;PRINT FILE 1 DIFFERENCES
	MOVE W1,[440700,,[ASCIZ /****/]]
	PUSHJ P,PRINT
	PUSHJ P,PCRLF
	HRRI FR,1		;THEN PRINT FILE 2 DIFFERENCES

;THIS SUBROUTINE PRINTS ALL THE TEXT IN THE
;BUFFER SPECIFIED BY C(FR)R. I. E. FILE 1 OR FILE 2

PNTTXT:	SETOM TEMP	;START POINTER AT -1
	SETOM PAGEN		;GUARANTEE PAGE # MISMATCH- THEREFORE PRINT IT
PNTTX1:	AOS W1,TEMP	;INDEX LINE COUNTER
	CAMLE W1,F1(FR)	;PRINTED ALL LINES?
	POPJ P,	;YES, RETURN
	AOS ERRCNT	;MAKE ERRCNT NON-ZERO
	PUSH P,F1	;NO, SAVE LINE POINTERS
	PUSH P,F2
	SETZB F1,F2	;F1=F2=0
	MOVEM W1,F1(FR)	;SET UP EITHER FOR F1 OR F2
	PUSHJ P,SETONE	;CALCULATE BYTE POINTERS TO TEXT
	MOVE W1,W1(FR)	;UNNECESSARY FOR FILE 1- MOVES BYTE PNT FILE 2
	PUSHJ P,PLINEN	;PRINT: 1)	TEXT
	TLNN	FR,ALLSW	;/M OR /B IN EFFECT? IF YES, CR-LF WAS IN BUFFER
				;/M INSTEAD OF BEING SUBSTITUTED WITH NULL
				;/M AND SO WHER PRINTED
	PUSHJ P,PCRLF
	POP P,F2
	POP P,F1	;RESTORE REGS
	JRST PNTTX1	;FINISH OUT ALL LINES

;THE FOLLOWING CODE IS USED TO OUTPUT A LINE OF TEXT

PLINEN:	MOVEI C,"1(FR)
	PUSHJ P,PCHART		;PRINT 1 OR 2
	MOVEI C,")
	PUSHJ P,PCHART		;PRINT )
	HLRZ C,(W1)		;GET PAGE NUMBER FOR THIS LINE
	CAME C,PAGEN		;IS IT THE SAME AS PREVIOUS LINE?
	PUSHJ P,PGNUM		;PRINT NEW PAGE NUMBER
	MOVEI C,11	;PRINT TAB
	PUSHJ P,PCHART

PRINT:	ILDB C,W1		;GET CHARACTER
	JUMPN C,.-2		;LOOP UNTIL A NULL SHOWS UP
	POPJ P,


PCRLF:		;THIS CODE OUTPUTS A CARRAIGE RETURN-LINE
			;FEED AND DECREMENTS THE LINE COUNT

	PUSHJ	P,CRLF
	SETZM	COLCNT		;/M RESET COLUMN COUNT IN CASE /M IN EFFECT
	TLNE	FR,MERGEF	;/M IN EFFECT?
	POPJ	P,		;/M YES, DO NOT DECREMENT LINE COUNT, SO NO
				;/M NEW HEADING AFTER FIRST ONE
	SOSN	LINCNT	;DECREMENT THE LINES/PAGE COUNT
	TLO	FR,PAGSW	;THIS MEANS WE GET A NEW HEADING
	POPJ	P,

PGNUM:	MOVEM C,PAGEN		;SAVE NEW PAGE # AS OLD
PGNUM1:	IDIVI C,12		;STANDARD DECIMAL PRINT ROUTINE
	HRLM C+1,(P)
	SKIPE C
	PUSHJ P,PGNUM1
	HLRZ C,(P)
	ADDI C,"0
	JRST PCHART
;	THIS PAGE CONTAINS ROUTINES FOR CHARACTER OUTPUT

;CHARACTERS OUTPUTED AS A STRING OF TEXT COME THROUGH HERE

PCHART:	JUMPE C,CPOPJ		;ZERO MEANS A CARRIAGE RETURN
				;IF SO WE ARE THROUGH WITH LINE
	AOS	T,COLCNT	;/M INCREASE COLUMN COUNT IN CASE /M
	CAIGE	C,40		;PRINTING CHARACTER?
	JRST PCT1		;NO
PCT0:	TLNE	FR,MERGEF	;/M YES, /N IN EFFECT?
	CAMG	T,COLMAX	;/M YES, EXCEEDED MAX TTY COLUMN?
	JRST	PCHAR		;NO, PRINT
	POPJ	P,		;/M YES, DO NOT PRINT

PCT1:	SKIPG	COLMAX		;/M HAS USER SET MAX COLUMN TO 0?
	POPJ	P,		;/M YES, DO NOT PRINT ANYTHING
	CAIE	C,TAB		;/M TAB?
	JRST	PCT2		;/M NO
	IORI	T,7		;/M YES, ADVANCE TO NEXT POSITION
	MOVEM	T,COLCNT	;/M AND STORE
	JRST	PCT0		;/M GO TREAT AS PRINTING CHAR

PCT2:	CAIE	C,CR		;/M CR?
	JRST PCT3		;/M NO
	SETZM	COLCNT		;/M YES RESET COLUMN COUNT
	JRST PCHAR		;/M AND ALWAYS PRINT

PCT3:	CAIE	C,LF		;/M LF?
	JRST	PCT4		;/M NO
	SOS	COLCNT		;/M YES, DECREMENT COUNT
	JRST	PCHAR		;/M AND ALWAYS PRINT

PCT4:	CAIE	C,^[		;CTL CHARS EXCEPT ALTMODE
	AOS	T,COLCNT	;TAKE UP 2 POSITIONS (1 FOR "^").
	JRST	PCT0
;ROUTINE TO PRINT ON CHARACTER AND PRINT NEW HEADING IF NEEDED

PCHAR:	TLZN	FR,PAGSW	;DO WE NEED A NEW HEADING
	JRST	TYO	;NO--SIMPLE CHARACTER OUTPUT
	SETOM	LINCNT	;YES
;THIS CODE OUTPUTS A HEADING COMPRISES OF THE TITLE OF
;EACH FILE AFTER "FILE 1)" AND "FILE 2)"

	MOVEM	16,SAVEXS+16	;SAVE ACCUMULATORS WHILE OUTPUTING HEADING
	MOVEI	16,SAVEXS
	BLT	16,SAVEXS+15	;ACCUMULATORS ARE NOW SAVED
	TLNE FR,ENDSW		;DON'T BOTHER IF NO ERRORS DETECTED
	JRST PCHAR1
	MOVEI C,FF		;FOR NEW PAGE, ISSUE FORM FEED
	TLNN FR,NOFORM		;IF 1, SUPPRESS FORM FEED
	PUSHJ P,TYO
	MOVE W1,[440700,,[ASCIZ /FILE 1)	/]]
	PUSHJ P,PRINT
	MOVE W1,[440700,,HBUF1]
	PUSHJ P,PRINT		;PRINT FILE 1 NAME
	PUSHJ P,PCRLF		;PRINT CRLF(EXTRA CRLF IF /B OR /M IN EFFECT
				; ON PURPOSE SO CAN TELL FROM LISTING WHETHER
				; /B TYPED BY USER OR NOT

	MOVE W1,[440700,,[ASCIZ /FILE 2)	/]]
	PUSHJ P,PRINT
	MOVE W1,[440700,,HBUF2]
	PUSHJ P,PRINT		;PRINT FILE 2 NAME
PCHAR1:	PUSHJ	P,PCRLF	;FOLLOWED BY TWO CARRIAGE RETURN FINE FEEDS
	PUSHJ	P,PCRLF
	MOVEI	LPP	;RESET LINES/PAGE COUNT
	MOVEM	LINCNT
	MOVSI	16,SAVEXS	;AND RESTORE ACS
	BLT	16,15
	MOVE	16,SAVEXS+16
	TLZ	FR,NOFORM	;CLEAR SUPPRESS FF FLAG AFTER RESTORING AC'S
	JRST	TYO	;DON'T FORGET ABOUT THAT ORGINAL CHARACTER



;/M ROUTINE TO OUPUT 1 CHAR ON MERGE OUTPUT FILE

MRGO:	.IOT MRG,C	;ITS
	POPJ	P,

;/M ROUTINE TO GET INPUT FOR MERGE COMMAND
;/M STORES ENTIRE COMMAND IN SPECIAL BUFFER
;/M IN CASE USER TYPES T COMMAND AS ONE OF COMMANDS
;/M WHICH WILL SLAO REQUIRE TTY INPUT
;/M CHECK SYSTAX, DO NOT RTURN UNTIL GOOD COMMAND LINE TYPED IN

GTMRG0:	MOVEM	W1,COLMAX	;/M SET NEW MAX COLUMN TO TYPE OUT ON /M
GETMRG:	CALL	TTILIN		;READ TTY LINE.
	MOVE	W1,[440700,,MRGCOM]	;/M SET UP BYTE POINTER TO MERGE
				;/M COMMAND BUFFER
GTMRG1:	MOVEI	C,0		;/M IN CASE TOO LONG COMMAND
	CAIE	W1,[350700,,MRGCOM+MRGLEN-1]
	PUSHJ	P,TTICHR
	CAIGE	C,40		;/M ALTM,LF?
	MOVEI	C,0		;/M YES, FLAG END OF MERGE COMAND WITH NULL
	IDPB	C,W1		;/M STORE CHAR
	CAIE	C,"1		;/M IS IT "1"?
	CAIN	C,"2		;/M OR "2"?
	JRST	GTMRG1		;/M YES, GET ANOTHER
	CAIN	C,"T		;/M NO, IS IT "T"?
	JRST	GTMRG1		;/M YES, GET ANOTHER
	CAIE	C,"C		;/M C?
	JRST	GTMRG3		;/M NO
	MOVEI	W1,0		;/M YES, SET NEW MAX COLUMN TO 0
GTMRG2:	PUSHJ	P,TTICHR	;/M GE CHAR
	CAIGE	C,40		;/M END OFLINE CHAR?
	JRST	GTMRG0		;/M YES STORE NEW MAX. COLUMN TY TYPE OUT
	CAIL	C,"0		;/M NO, A DECIMAL  DIGIT?
	CAILE	C,"9		;/M
	JRST GTMRG4		;/M NO, PRINT ERROR
	IMULI	W1,12		;/M YES CONVERT TO BINARY
	ADDI	W1,-"0(C)	;/M ADD IN THIS DIGIT
	JRST	GTMRG2		;/M GO GET NEXT DIGIT

GTMRG3:	MOVE W1,[440700,,MRGCOM]	;/M ASSUME IT IS END OF LINE
	MOVEM	W1,MRGBYT	;/M AND STORE BYTE POINTER TO SCANNED STRING
	JUMPE	C,CPOPJ		;/M IS IT?
GTMRG4:	MOVE	W1,[440700,,[ASCIZ "?ONLY 1, 2, AND/OR T ARE LEGAL IN MERGE COMMANDS
OR C### TO SET MAX. COL.
"]]
	PUSHJ	P,PRINT	;/M PRINT ERROR
	JRST	GETMRG		;/M AND ASK FOR COMMAND OVER AGAIN

;/M ROUTINE TO GET NEXT CHAR FROM MERGE COMMAND BUFFER
;/M CALL:	PUSHJ	P,MRGIN
;/M		RETURN	WITH CHAR IN C

MRGIN:	ILDB	C,MRGBYT	;/M GET NEXT CHAR
	POPJ	P,
;ROUTINES FOR OUTPUTING ERROR MESSAGES

TYPMSG:	.LOGOUT			;CAN'T PRINT MSG WITHOUT TTY.
	.OPEN	TTO,[SIXBIT/  !TTY/]
	.VALUE			;SINCE TTO WAS USED FOR OUTPUT.
	PUSHJ	P,CRLF		;OUTPUT A CARRIAGE RETURN
TYPMS0:	HRLI	T,440700	;THIS IS POINTER FOR ERROR MESSAGE
	SKIPA
	PUSHJ P,TYO
TYPMS1:	ILDB	C,T		;LOAD A CHAR. FROM ERROR MESSAGE
	JUMPN	C,.-2		;ALL ERROR MESSAGES END WITH A ZERO
	POPJ	P,	;THROUGH WITH ERROR MESSAGE

CARR:	PUSHJ	P,CRLF	;COMMON EXIT FOR ERROR MESSAGES
RELDEV:	PUSHJ	P,CRLF
	.CLOSE IN1,	;ITS
	.CLOSE IN2,	;ITS
	.CLOSE MRG,	;ITS
	.CLOSE	TTO,		;(OUTPUT)
	.LOGOUT			;CAN'T GET ANOTHER CMD IF DISOWNED.
	SKIPE	CTLCF		;EXIT IF USER GAVE ^C.
	.BREAK	16,140000
	JRST	RESTRT		;ELSE, GET NEW CMD.
;ROUTINE TO GET A LEGIMATE CHARACTER (IN C)
;SET EOLF IF CHAR IS LINE TERMINATOR
;RETURN NULL ON END OF LINE


GCHAR0:	TLNE	FR, ALLSW	;/M IS /M OR /B SWITCH IN FORCE?
	POPJ	P,		;/M YES, RETURN CR AS DATA
				;/M NO, FLUSH CR AND GET NEXT CHAR
GCHAR:	TLZN	FR,EOLF		;/M HAS AN EOL(LF,VT,FF) BEEN SEEN ON THIS LINE?
				;/M IF /M SWITCH USED, PREVIOUS CALL RETURNED
				;/M IT AS IF AN ORDINARY CHAR FOR COMPARISON.
	TLNE FR,@EOFTBL(FR)	;EOF SEEN?
	JRST NULLCH		;YES, RETURN NULL
	PUSHJ P,@GCHARTB(FR)	;ITS GET CHARACTER
	JUMPE C,GCHAR		;GET RID OF NULLS
	CAIE C,LF		;LINE FEED?
	CAIN C,VT		;NO-VERTICAL TAB?
	JRST EOL		;YES, RETURN NULL-UNLESS /M OR /B SWITCH
	CAIN C,CR		;CARRIAGE RETURN?
	JRST GCHAR0		;YES, FLUSH UNLESS /M SWITCH
	CAIN C,FF		;IS IT A FORM FEED?
	JRST FORM		;YES
	CAIN C,ITSEOF	;ITS END OF FILE?
	JRST EOF	;ITS YES.
	POPJ P,		;NO, RETURN WITH CHAR

FORM:	AOS PAGNUM(FR)		;INDEX PAGE NUMBER
EOL:	TLO FR,EOLF		;/M FLAG EOL(LF,VT,FF) SEEN ON THIS CHAR
				;/M SO NEXT CALL TO GCHAR WILL RETURN NULL IF /T
	TLNE FR,ALLSW		;/M /M OR /B SWITCH?
	POPJ P,		;/M YES, RETURN FF,VT,LF AS REAL CHAR FOR COMPARISON
	JRST NULLCH		;/M NO, RETURN NULL SO FF TREATED SAME AS, LF, VT

EOF:	TLO FR,@EOFTBL(FR)	;SET EOF FLAG
NULLCH:	MOVEI C,0		;EOF IS A NULL
	POPJ P,


GCHARTB:	GCHAR1
		GCHAR2
GCHAR1:	MOVE C,FILPT1
	CAMN C,[10700,,FILBE1]
	JRST GC1FIL		;FILL INPUT BUFFER
	ILDB C,FILPT1		;GET A CHARACTER
	JUMPE C,GCHAR1		;DONT WANT NULLS
	CAMN C,EOFC1		;EOF FOR FILE 1?
	JRST EOF		;YES
	POPJ P,		;NO.

GC1FIL:	MOVE C,[-100,,FILBF1]
	.IOT IN1,C
	CAMN C,[-100,,FILBF1]
	JRST EOF
	MOVE C,[10700,,FILBF1-1]
	MOVEM C,FILPT1		;START POINTER OVER
	JRST GCHAR1

GCHAR2:	MOVE C,FILPT2		;CHECK FOR EMPTY BUFFER
	CAMN C,[10700,,FILBE2]
	JRST GC2FIL		;EMPTY GET MORE
	ILDB C,FILPT2		;GET A CHAR
	JUMPE C,GCHAR2		;FLUSH NULLS
	CAMN C,EOFC2		;END OF FILE?
	JRST EOF		;YES
	POPJ P,		;NO. RETURN CHAR

GC2FIL:	MOVE C,[-100,,FILBF2]
	.IOT IN2,C
	CAMN C,[-100,,FILBF2]
	JRST EOF
	MOVE C,[10700,,FILBF2-1]
	MOVEM C,FILPT2		;RESET POINTER TO ST RT
	JRST GCHAR2

EOFTBL:	EOF1SW		;EOF FLAG FOR FILE 1
	EOF2SW		;EOF FLAG FOR FILE 2
;OPEN INPUT FILE ON CHNL IN W1.
INOPEN:	MOVSI	W2,(SIXBIT/>/)
	SKIPN	INFN2		;DEFAULT THE FN2 TO ">".
	MOVEM	W2,INFN2
	MOVEI	W2,2		;(ASCII BLOCK INPUT)
	HRLM	W2,INDEV
	.SUSET	[.SSNAM,,INSNM]
	MOVE	W2,[.OPEN INDEV]
	DPB	W1,[270400,,W2]	;PUT CHNL NUM INTO OPEN
	XCT	W2		;AND DO IT.
	CALL	OPENL
	MOVE	W2,INOPT3-IN1(W1)	;GET EOFC-WD ADDR,
	.EOFC	W1,
	MOVEM	W1,(W2)		;PUT FILE'S EOFC IN IT.
	MOVEI	W1,FILBE1-EOFC1(W2)
	HRLI	W1,10700	;MAKE B.P. TO END OF BUFFER,
	MOVEM	W1,FILPT1-EOFC1(W2)
	HRRI	FR,		;PUT NUMBER OF FILE INTO FR.
	CAIE	W2,EOFC1
	HRRI	FR,1
	JRST	RCHST		;SET UP FILE'S HEADER.

INOPT3:	EOFC1 ? EOFC2
;PUT FILE DESCRIPTION IN ASCII INTO HBUF FOR THIS FILE
RCHST:	MOVE T,RCHSTA(FR)	;GET .RCHST ARG FOR THIS FILE
	.RCHST T,		;GET THE INFO FROM ITS INTO RCHSTB
	MOVE W2,RCHSTP(FR)	;NOW SET UP BYTE POINTER TO HEADER AREA TO READ INTO
	MOVSI T,770000
	TDNE T,RCHSTB	;CHECK FIRST CHAR IN LH(DEVICE NAME)
	MOVSS RCHSTB	;DEVICE NAME HAS STUFF IN LH, USE IT AS REAL NAME
	HRLZ T,RCHSTB	;GET THE CHOSEN DEVICE NAME
	JSP W1,RCHST6	;DEVICE NAME
	 ":		;END WITH COLON
	MOVE T,RCHSTB+3
	JSP W1,RCHST6	;SYSTEM NAME
	 ";		;TERMINATED BY SEMICOLON
	SKIPN T,RCHSTB+1
	MOVE	T,INFN1		;IF REALLY NONE, USE SPEC'D.
	SKIPN	LSTFN1		;DEFAULT OUTPUT FN1 TO INPUT.
	MOVEM	T,LSTFN1
	JSP W1,RCHST6	;FNAM1
	 40		;TERMINATED (ITS CONVENTION) BY SPACE
	SKIPN T,RCHSTB+2
	MOVE	T,INFN2
	JSP W1,RCHST6	;FNAM2
	 0		;DON'T PRINT TERMINATING CHAR
	MOVEI C,0
	IDPB C,W2	;MARK END OF STRING
	POPJ P,

RCHSTA:	IN1,,RCHSTB	;.RCHST ARGS
	IN2,,RCHSTB

RCHSTP:	440700,,HBUF1	;BYTE POINTERS TO HEADER TABLES
	440700,,HBUF2

		;JSP W1,RCHST6	;PRINT (IDPB ASCII VIA W2) SIXBIT WORD IN T
		; "<TERMINATING CHAR OR 0>	;FOLLOW WITH TERMINATING CHAR UNLESS SIXBIT IS NULL
			; ^ DOESN'T PRINT TRAILING SPACES

RCHST6:	JUMPE T,1(W1)	;RETURN ON NULL ARG
RCHS6A:	MOVEI C,0	;CLEAR OUT C TO RECEIVE CHAR
	LSHC C,6	;SHIFT IN NEXT CHAR
	ADDI C,40	;CONVERT TO ASCII
	IDPB C,W2	;DEPOSIT WHEREVER IT'S GOING
	JUMPN T,RCHS6A	;LOOP UNTIL WORD EMPTY
	SKIPE C,(W1)	;NOW GET TERMINATOR
	IDPB C,W2	;NOT NULL, USE IT
	JRST 1(W1)
;READ IN A COMMAND, PROCESSING RUBOUTS, PROMPTING WITH "*".
TTILIN:	CALL	CRLF

;COME HERE AFTER NULL LINE.
TTILI2:	SETZM	TTICNT		;NO CHARS READ YET.
	.IOT	TTO,["*]
	MOVE	C ,[440700,,TTIBUF]
	MOVEM	C ,TTIPNT
TTILUP:	.IOT	TTI,C 		;READ A CHAR.
	CAIN	C ,^M
	JRST	TTICR		;^M MEANS ALL READ.
	CAIN	C,^U
	JRST	TTILIN		;^U CANCELS CMD.
	CAIN	C ,177
	JRST	TTIRUB
	CAIN	C,^C
	JRST	TTICTC		;^C MEANS DO CMD, THEN VALRET :KILL.
	IDPB	C ,TTIPNT	;NORMAL CHAR.
	AOS	TTICNT
	JRST	TTILUP

TTICTC:	.IOT	TTO,[^M]	;INDICATE TERMINATING RUBOUT PROC.
	TLNN	FR,MERGEF	;^C DOES NOTHING IF INPUT TO MERGE.
	SETOM	CTLCF		;REMEMBER TO VALRET WHEN CMD DONE.

TTICR:	TLNE	FR,MERGEF
	JRST	TTICR1
	SKIPN	TTICNT		;IF NULL COMMAND LINE, RETRY.
	JRST	TTILI3
TTICR1:	MOVE	C ,[440700,,TTIBUF]
	MOVEM	C ,TTIPNT	;SET UP FOR REMOVAL OF CHARS.
	RET

TTILI3:	SKIPE	CTLCF		;NULL LINE:
	.BREAK	16,140000	;...IF ^C ENDED LINE.
	JRST	TTILI2

TTIRUB:	SOSGE	TTICNT		;IF NO CHAR TO RUB, RETRY.
	JRST	TTILIN
	LDB	C ,TTIPNT
	.IOT	TTO,C 		;PRINT RUBBED CHAR.
	MOVSI	C ,070000
	ADD	C ,TTIPNT
	JUMPGE	C ,TTIRU1	;IF STILL IN SAME WD.
	MOVEI	C ,-1(C )	;ELSE, MOVE TO END OF PREV. WD.
	HRLI	C ,010700
TTIRU1:	MOVEM	C ,TTIPNT
	JRST	TTILUP
;READ FILE SPEC, DEFAULTING SNAME AND DEV.
RFILES:	MOVE	CS,MSNAME
	MOVEM	CS,INSNM

;JUST DEFAULT DEV.
RFILED:	MOVEI	CS,(SIXBIT/DSK/)
	MOVEM	CS,INDEV

RFILE:	SETZM	INFN2		;DEFAULT FN2 UP TO CALLER.
	SETZ	CS,
RFNAME:	MOVE	BP,[440600,,0]
	MOVEI	0,6		;SET UP TO READ IN A FILENAME.
	MOVEM	0,RFILC
	SETZ	0,
RFLOOP:	CALL	TTICHR		;READ A CHAR.
	CAIN	C,^Q
	JRST	RFCTQ		;^Q QUOTES NEXT CHAR.
	CAIE	C,",
	CAIN	C,^M
	JRST	RFSPAC		;", , ^M TERMINATE SPEC.
	CAIE	C,"_
	CAIN	C," 
	JRST	RFSPAC		;THESE ALSO.
	CAIN	C,":
	JRST	RFCOL		;COLON SETS DEV.
	CAIN	C,";
	JRST	RFSEM		;SEMI SETS SNAME.
	CAIN	C,"/
	JRST	RFSPAC		;SLASH ENDS NAME.
	JRST	RFNORM		;ALL OTHER CHARS.

RFCTQ:	CALL	TTICHR
RFNORM:	MOVEI	C,-40(C)	;CONV. TO SIXBIT.
	SOSL	RFILC		;PUT IN NAME IF ROOM LEFT.
	IDPB	C,BP
	JRST	RFLOOP

RFXCTB:	MOVEM	0,INFN1
	MOVEM	0,INFN2
	HLRM	0,INDEV
	MOVEM	0,INSNM
	SKIPA
;FOR SWITCH "A, SET OR CLEAR BIT D ACCORDING TO B.
DEFINE	SWITCH	A,B,D
	CAIN	C,"A
	HRR!B!I	BP,D
TERMIN

RFCOL:	SKIPE	0
	HLRM	0,INDEV		;SET DEVICE FIELD.
	JRST	RFNAME

RFSEM:	SKIPE	0
	MOVEM	0,INSNM
	JRST	RFNAME

RFSPAC:	JUMPE	0,RFSPA0	;IF NAME WAS READ,
	XCT	RFXCTB(CS)	;STORE IT,
	AOJ	CS,		;INCR. STORING POS.
RFSPA0:	CAIN	C ,40
	JRST	RFNAME		;SPACE -- GET ANOTHER NAME.
	CAIE	C ,"/
	RET			;NOT SLASH, RETURN.
	CALL	TTICHR		;ELSE READ A SWITCH.
	SETZ	BP,
	SWITCH	B,O,ALLSW	;/B - DON'T IGNORE BLANK LINES.
	SWITCH	C,O,CSWBIT	;/C - IGNORE COMMENTS.
	CAIN	C,"D
	JRST	RFSWD		;/D - DISOWN SELF.
	SWITCH	M,O,ALLSW+MERGEF	;/M - MERGE FILES.
	SWITCH	S,O,SSWBIT	;/S - IGNORE SPACES.
	CAIL	C,"1		;DIGIT - SET NUMLIN.
	CAILE	C,"9
	CAIA
	JRST	RFSWNL
	JUMPE	BP,ERRSW	;ERROR UNLESS ONE OF ABOVE SWITCHES.
	TLO	FR,(BP)		;SET THE FLG.
	JRST	RFNAME		;SWITCH DONE, READ ANOTHER NAME.

RFSWD:	.OPEN	TTI,[SIXBIT/   NUL/]
	.VALUE
	.OPEN	TTO,[SIXBIT/  !NUL/]
	.VALUE
	.VALUE	[ASCIZ/:DISOWN :VK /]	;GIVE BACK TTY.
	JRST	RFNAME

RFSWNL:	MOVEI	C,-"1(C)	;SET NUM. EXTRA LINES TO MATCH
	MOVEM	C,NUMLIN	;TO THE DIGIT, -1.
	JRST	RFNAME
	
;READ A CHAR OF TTY INPUT (OR ^M IF NONE LEFT).
TTICHR:	SOSGE	TTICNT		;IF NO CHARS LEFT,
	SKIPA	C,[^M]		;SAY EOL.
	ILDB	C,TTIPNT	;ELSE GET NEXT CHAR FROM BUFFER.
	RET
;OUTPUT 6BIT WD IN 0 TO TTY.
TTOSIX:	MOVE	BP,0
TTOSI0:	SETZ	CS,
	ROTC	BP,6		;GET NEXT CHAR.
	JUMPE	CS,CPOPJ
	MOVEI	CS," (CS)	;CONV. 6BIT TO ASCII.
	.IOT	TTO,CS
	JRST	TTOSI0

TYO:	.IOT	TTO,C
	RET

CRLF:	.IOT	TTO,[^M]
	.IOT	TTO,[^J]
	RET

ERRSW:	JSP	T,ERRMSG
	ASCIZ /ILLEGAL SWITCH/

ERRCM:	JSP	T,ERRMSG
	ASCIZ /COMMAND ERROR/


ERRMSG:	CALL	TYPMSG			;FOR SIMPLE ERROR MESSAGES

ERRFIN:	.RESET	TTI,
	SETZM	CTLCF
	CALL	CRLF
	JRST	RESTRT		;START CREF OVER
;COME HERE ON FAILING LST FILE OPEN.
OPENLL:	MOVE	C,[LSTDEV,,INDEV]
	BLT	C,INSNM		;MOVE LST FILE NAMES FOR OPENL.

;COME HERE AFTER FAILING INPUT OPEN.
OPENL:	.LOGOUT
	.OPEN	TTO,[SIXBIT/  !TTYY/]
	.VALUE
	CALL	LSTFIL		;PRINT NAME OF LOSING FILE.
	.IOT	TTO,[^I]
	.OPEN	ERRC,ERRFIL
	.VALUE
OPENL0:	.IOT	ERRC,C
	CAIN	C,^M
	JRST	ERRFIN
	.IOT	TTO,C
	JRST	OPENL0

ERRFIL:	SIXBIT/   ERR/
	1?0

;PRINT NAME OF CURRENT FILE ON LST IOR TTY.
LSTFIL:	HRLZ	0,INDEV
	CAMN	0,[SIXBIT/DSK/]
	JRST	LSTFI1
	CALL	TTOSIX		;PRINT DEV IF NOT DSK.
	.IOT	TTO,[":]
	JRST	LSTFI2

LSTFI1:	MOVE	0,INSNM		;IS DSK - PRINT SNAME
	CAMN	0,MSNAME	;IF DIFFERENT FROM USER'S.
	JRST	LSTFI2
	CALL	TTOSIX
	.IOT	TTO,[";]

LSTFI2:	MOVE	0,INFN1
	CALL	TTOSIX		;PRINT 1ST NAME.
	.IOT	TTO,[" ]
	MOVE	0,INFN2
	JRST	TTOSIX		;, 2ND NAME.


PATCH:	BLOCK 100

CONSTA				;ITS

COLMAX:	BLOCK	1		;/M MAX COLUMN TYPED OUT ON /M DIALOG
				;/M INITIALLY COLINT. CHANGED BY C COMMAND
JOBREL:	BLOCK 1		;ITS
JOBFF:	BLOCK 1		;ITS
MSNAME:	0		;INITIAL (DEFAULT) SNAME.
PPSET:	BLOCK	LPDL		;PUSH DOWN LIST STORAGE

ERRCNT:	BLOCK	1		;DIFFERENCES COUNTER (0 MEANS NO DIFFERENCES)

TOP:		;CONTAINS # LINES ACTUALLY STORED IN BUFFER FOR:
TOP1:	BLOCK	1	;FILE #1
TOP2:	BLOCK	1	;FILE #2

LBUFP:
LBUFP1:	BLOCK	1	;POINTER TO BEGINNING OF LINE STORAGE FOR FILE #1
LBUFP2:	BLOCK	1	;DITTO FILE #2

P1:	BLOCK	1	;BYTE POINTERS USED BY "COMPL" SUBROUTINE
P2:	BLOCK	1

HBUF1:	BLOCK	WPL	;HOLDS TITLE FROM FIRST FILE
HBUF2:	BLOCK	WPL	;FROM SECOND FILE
RCHSTB:	BLOCK 10.	;BLOCK WRITTEN INTO BY .RCHST
		;WORD 0 RH DEV NAME, LH IF NON-ZERO THEN DEVICE NAME TO PRINT
		;WRD 1 FNAM1
		;WRD 2 FNAM2
		;WRD 3 SYSTEM NAME
		;WRD 4 NON-NEGATIVE => .ACCESS POINTER
		;REST ROOM FOR EXPANSION OF SYSTEM CALL
PAGNUM:	BLOCK 2		;PAGE NUMBERS FOR THE TWO FILES
			;  LH(# AT BEGIN OF LINE), RH(# AFTER LAST CHAR)
PAGEN:	BLOCK 1		;TEMPORARY FOR PAGE #'S IN PLINEN SUBROUTINE
OLDNUM:	BLOCK 2		;LAST LINE # USED IN "SETONE"
OLDPNT:	BLOCK 2		;LAST BYTE POINTER CALCULATED BY "SETONE"
MRGOUT:	BLOCK	2		;/M NON-ZERO MEANS OUTPUT TO MERGE FILE ALL
			;/M LINES BEFORE WIPING OUT IN "MOVEUP" ROUTINE
			;/M ALWAYS 0 IF /M NOT TYPED
MRGLEN==2		;/M LEAVE ROOM FOR 2 WORDS (10 CHAR) OF MERGE COMMAND.
MRGCOM:	BLOCK	MRGLEN	;/M BUFFER FOR MERGE COMMAND
	BLOCK	1		;/M GUARANTEE A NULL TERMINATION
MRGBYT:	BLOCK	1		;/M BYTE POINTER TO MERGE COMMAND STRING
SAVEXS:	BLOCK	17	;STORAGE FOR AC'S WHEN PRINTING PAGE HEADERS

TEMP:	BLOCK	1
LINCNT:	BLOCK	1
COLCNT:	BLOCK	1		;/M COLUMN COUNT, STARTS AT 0, /M ONLY
RTNTMP:	BLOCK	1	;RETURN ADDRESS FOR "MULTI" SUBROUTINE
WCADR:	BLOCK 1		;TEMP IN GLINE SUBROUTINE
HIGH:	BLOCK	1	;USED BY NOROOM
ROOM:	BLOCK	1	;USED BY "NOROOM"
GETCNT:	BLOCK	1	;# LINES (-1) "GETTWO" GOT
GETFIL:	BLOCK	1	;# OF FILE FROM WHICH "GETTWO" GOT LINE (.L. 0 IF NONE)
NUMLIN:	BLOCK	1		;# LINES FOR A MATCH
NUMTMP:	BLOCK	1		;TEMP FOR NUMLIN
TEMPF1:	BLOCK	1		;TEMP FOR F1
TEMPF2:	BLOCK	1		;TEMP FOR F2
RFILC:	0		;TEMP. FOR RFILE.

CTLCF:	0		;IF NOT 0, .BREAK AFTER FINISHED.
TTIBUF:	BLOCK	20	;COMMAND BUFFER.
TTIPNT:	0		;POINTER INTO TTIBUF.
TTICNT:	0		;NUM. UNUSED CHARS IN TTIBUF.

INDEV:	0		;RFILE PUTS DEVICE NAME HERE.
INFN1:	0		;FN1, FN2, SNM IN THESE 3 WDS.
INFN2:	0
INSNM:	0

LSTDEV:	0		;OUTPUT DEV PUT HERE, ETC.
LSTFN1:	0
LSTFN2:	0
LSTSNM:	0

EOFC1:	BLOCK 1		;END OF FILE CHAR FILE 1
FILBF1:	BLOCK	100	;FILE 1 BUFFER.
FILBE1=.-1
FILPT1:	0		;FILE 1 BUFFER PTR.

EOFC2:	BLOCK 1		;EOF CHAR FILE 2
FILBF2:	BLOCK	100	;FILE 2 BUFFER,
FILBE2=.-1
FILPT2:	0		;FILE 2 BUFFER PTR.

CONSTANTS
VARIABLES

ENDP:

END BEG
