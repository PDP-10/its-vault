
.SYMTAB 4001.		;SHOULD BE PLENTY

TITLE TECO

TS==1
IFNDEF RMSSW,RMSSW==1
IFNDEF ATSFLG,ATSFLG=0

GLITCH==177
ALTMOD==33
EOFCHR==3

IRPS AC,,FF P A AA B E C D F T TT TT1 IN OUT CH Q
AC=.IRPCNT
TERMIN

SYM==OUT
SYM2==IN	;MUST BE < SYM! (SEE SYMLPT)

A0==TT		;ACS FOR .I PSEUDO.
A1==TT1

.XCREF FF,P,A,AA,B,IN,OUT,CH,T

IFN 0,[		;I HOPE THAT EVERYTHING THAT DEPENDS ON ORDER OF ACS
MUL: MULI: DIV: DIVI: IDIV: IDIVI:	;WILL X-REF TO ONE OF THESE.
ROTC: ASHC: LSHC: CIRC:
BLT: JFFO:
.OPEN: .RDATIM:
]

;RIGHT HALF FLAGS

ALTF==1
ARG2==2
ARG==4
ITERF==10
SLSL==20
OPFLG==40	;SET WHEN ARITH OP NEEDS A RIGHT ARG.
COLONF==100
SYLF==200
FINDR==2000
QMFLG==4000
NOTF==10000
REVSF==NOTF	;SEARCH IN REVERSE (ARGUMENT NEGATIVE)
TRACEF==20000
LET==40000
LSTCRF==200000	;IN @, SET WHEN CR READ FROM FILE.

;LEFT HALF FLAGS

NEGF==1		;DPT-ING A NEGATIVE NUMBER
UREAD==200	;INPUT FILE OPEN.
UWRITE==400	;OUTPUT FILE OPEN
GLOF==2000	;CTRL O GLOB FLG
VARF==4000	;CTRL O VAR FLG
DEFF==10000	;CTRL O DEFINE FLAG
FIRSTF==20000	;CTRL O FIRST-SYLLABLE-ON-LINE FLAG
CTLUF==100000	;DO AN ^U AT END IF VIEWF OFF
LPRF==400000	;CTRL O LEFT PAREN FLAG

TYPR4=37000,,
NUUOS==1

CALL=PUSHJ P,
SAVE=PUSH P,
REST=POP P,
RET=POPJ P,
HALT==.VALUE

.XCREF CALL,REST,SAVE,RET

BP==440700

OPNLBP==220600	;B.,P. TO OPEN LOSS CODE IN CHANNEL STATUS.
OPLFNF==4	;CODE FOR "FILE NOT FOUND"
OPLNSU==20	;CODE FOR "NO DIR FOR THAT SNAME"

;BITS IN NEW TV CHARACTERS
CONTRL==200
META==400
SHIFT==1000
SHIFTL==2000
TOP==4000

IFNDEF NQSETS,NQSETS==3
NQREG==<"Z-"A+1+"9-"0+1>*NQSETS
.QCRSR==10.		;..A HOLDS CURSOR.
.QBFDS==.QCRSR+1	;..B HOLDS MACRO EXECUTED AT END OF CMD STRING IF BUFFER DISPLAY WANTED (CTLUF IS OFF)
.QCPRT==.QBFDS+1	;..C HOLDS COPYRIGHT MESSAGE FOR @ LISTINGS.
.QDLIM==.QCPRT+1	;..D HOLDS DISPATCH FOR FW, "B, "C, ^B IN SEARCHES.
.QBASE==.QDLIM+1	;..E HOLDS OUTPUT RADIX FOR = AND \. (INITIALY 10.)
.QCRMC==.QBASE+1	;..F HOLDS ^R MODE SECRETARY MACRO.
.QFDDS==.QCRMC+1	;..G HOLDS MACRO EXECUTED AFTER COMMAND STRING TO DISPLAY FILE DIRECTORY.
.QVWFL==.QFDDS+1	;..H IS NONZERO IF THERE HAS BEEN TYPEOUT BY PRGM (SUPPRESS BUFFER DISPLAY)
.QPT1==.QVWFL+1		;..I HOLDS WHAT . HAD AT START OF CMD STRING.
.QMODE==.QPT1+1		;..J HOLDS "MODE" STRING, DISPLAYED ON THE --MORE-- LINE.
.QRRBF==.QMODE+1	;..K HAS WHAT WAS KILLED IN ^R MODE.
.QRSTR==.QRRBF+1	;..L HOLDS MACRO EXECUTED WHEN TECO IS $G'D.
.Q340C==.QRSTR+1	;..M USED TO HOLD 340 DISPLAY CURSOR.
.QUNWN==.Q340C+1	;..N HOLDS STRING MACROED BEFORE QREG UNWOUND.
.QBUFR==.QUNWN+1	;..O HOLDS CURRENT BUFFER.
.QERRH==.QBUFR+1	;..P HOLDS ERROR-HANDLER MACRO.
.QSYMT==.QERRH+1	;..Q HOLDS SYMBOL TABLE FOR Q<NAME> CONTRUCTION.
.Q..Z==10.+"Z-"A	;..Z HOLDS SAME AS ..O, INITIALLY.

.QKS==0	;..0, ..1, ..2 USED BY ^P SORT.
.QKE==1
.QDL==2
.Q..0==0	;OTHER NAMES FOR ..0, ..1, ..2
.Q..1==.Q..0+1
.Q..2==.Q..1+1
.Q..3==.Q..2+1

IF2 [
$QCRSR==QTAB+36.*2+.QCRSR
$QUNWN==QTAB+36.*2+.QUNWN
$QBUFR==QTAB+36.*2+.QBUFR
$Q..0==QTAB+36.*2+.Q..0
$QMODE==QTAB+36.*2+.QMODE
$QERRH==QTAB+36.*2+.QERRH
]

IFNDEF LIOPDL,LIOPDL==8	;IO PDL SIZE (MUST BE < ITS'S)
IFNDEF FDRBFL,FDRBFL==40	;SIZE OF FILE DIR READING BUFFER.
IFNDEF LPDL,LPDL==140		;SIZE OF REGULAR PDL.
IFNDEF MFNUM,MFNUM==60.		;[ ;# OF FRAMES FOR MACRO OR ^] CALLS, OR ITERATIONS.
IFNDEF GCTBL,GCTBL==100
IFNDEF SLPQWR,SLPQWR==20000	;# WDS TO EXPAND QREG SPACE BY.
IFNDEF SLPWRD,SLPWRD==400	;# WDS TO EXPAND BUFFER GAP BY.
IFNDEF GCOFTN,GCOFTN==5*2000	;# CHARS OF QREGS WRITTEN TO CAUSE A GC.
IFNDEF LPF,LPF==400		;QREG PDL # WDS (2 WDS/ENTRY)
IFNDEF STBLSZ,STBLSZ==300	;SEARCH TABLE SIZE.
IFNDEF CBUFSZ,CBUFSZ==10.	;INITIAL # WDS IN CMD BUFFER.
IFNDEF MACPSZ,MACPSZ==<2*MFNUM+8>/9	;# WDS IN MACRO PDL (4-BIT BYTES)
IFNDEF DISBFL,DISBFL==40	;LENGTH OF TTY IOT BUFFER.
IFNDEF FSPSPL,FSPSPL==20	;LENGTH OF RING BUFFER OF POINT.
IFNDEF UTBSZ,UTBSZ==40		;LENGTH OF I-O BUFFERS.
IFNDEF LHIMAX,LHIMAX==400	;1ST PAGE NOT AVAIL FOR :EJ
IFNDEF LHIMIN,LHIMIN==340	;LOWEST PAGE AVAIL.
IFNDEF MXMEMT,MXMEMT==300	;1ST PAGE NOT AVAIL FOR BUFFER SPACE.

SPD==60.*60.*24.	;NUMBER OF SECONDS IN A DAY (FITS IN A HALFWORD)

DEFINE DBP7 A
	ADD A,[70000,,]
	SKIPGE A
	SUB A,[430000,,1]
TERMIN

DEFINE INSIRP A,B
	IRPS ZZZ,,[B]
	A,ZZZ
TERMIN TERMIN

DEFINE CONC CONC1,CONC2
CONC1!CONC2!TERMIN

;ERROR MACRO: TYPRE [ERRCODE]
DEFINE TYPRE A
	TYPR4 ER$!A
TERMIN

IF2 ISKER1==TYPRE [ISK]
DEFINE ISKERR
	SKIPE PSSAVP
	 TYPRE [ISK]
TERMIN

DEFINE SKNTOP X
	SKIPE A,X
	CAMN A,[-1]
TERMIN

;SUPPY AN ARITH OP WITHOUT A RIGHT ARG WITH 1 AS AN ARG.
;OPTIONALLY (IF FOO IS Z, O OR N) DEFAULT NO ARG TO AN ARG OF 1,
;PERHAPS SETTING OR CLEARING THE ARGUMENT FLAG (IF FOO IS O OR Z)
DEFINE ARGDFL FOO	;FOO SHOULD BE "O", "Z", "N" OR NULL.
IFNB FOO,TR!FOO!E FF,ARG
	TRZE FF,OPFLG
	 CALL ARGDF0
TERMIN

IFN TS,[
;TS SYMBOLS

DEFINE TSOPEN A,B
	.OPEN A,B
	 .LOSE 1000
	TERMIN

DEFINE SYSCAL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

DEFINE UTFARG
UTF ? UTF1 ? UTF2 ? UTSNM TERMIN

DEFINE TTYACT
	CALL TTYAC1
TERMIN

DEFINE INFORM A,B
IF1,[PRINTX \A = B
\]TERMIN

TYIC==1
	;CHANNEL 2 UNUSED.
UTYIC==3
UTYOC==4
FDRC==6		;FOR READING FILE DIRECTORIES
DCHN==7
BDCHN==10
ERRC==11
ECHOC==12	;ECHO-MODE OUTPUT FOR RUBOUT.
ECDISC==13	;FOR FS ECHO DISPLAY$ ONLY.
SIOC==14	;SUPER IMAGE OUTPUT.
TYOC==15	;NORMAL TYPEOUT.

TYPIN==1_<TYIC>
TSMSK==%PJATY\%PJWRO,,%PIPDL+%PIMPV
TSMSK1==TYPIN
]

LOC 41
JSR UUOH
IFN TS,	JSR TSINT
LOC 100

RGETTY:	0	;TCTYP VARIABLE OF TTY.
NVLNS:	0	;# VERTICAL LINES ON CONSOLE
NHLNS:	0	;# HORIZONTAL POSITIONS ON CONSOLE
USZ:	0	;# VERTICAL LINES USABLE FOR DISPLAY. MUST FOLLOW NHLNS.
IFN USZ-NHLNS-1,.ERR
NELNS:	0	;# ECHO LINES (NVLNS-USZ). USUALLY 3, SET BY FS ECHO $
MXNVLS==100.
TOPLIN:	0	;# OF 1ST LINE OF SCREEN TO USE FOR BUFFER DISPLAY.
NLINES:	0	;# LINES OF BUFFER TO DISPLAY, 0 => DEFAULT
		; (2 ON TTYS, AS MANY AS WILL FIT ON DISPLAYS)
VSIZE:	0	;# OF LINES FOR VBD TO USE (SAME AS NLINES, OR THE DEFAULT # OF LINES).
BOTLIN:	0	;# OF 1ST LINE BELOW WINDOW.
RRTOPM:	0	;BOTTOM OF "TOP MARGIN" WHERE CURSOR SHOULDNT GO (SET BY %TOP)
RRBOTM:	0	;TOP OF "BOTTOM MARGIN" WHERE CURSOR SHOULDNT GO (SET BY %BOTTOM)
DISTRN:	0	;-1 =>0TRUNCATE LINES, 0 => CONTINUE EXCEPT ON 340, 1 => ALWAYS CONTINUE.
DISPCR:	0	;STRAY CR REALLY DOES A CR, -1 => ALWAYS, 0 => 340 ONLY, 1 => NEVER.
		;IF NOT OUTPUT AS CR, IT IS OUTPUT AS UPARROW-M.
		;ALSO SIMILARLY CONTROLS WHETHER STRAY LF'S ARE OUTPUT AS LF OR ^-J.
DISPBS:	0	;^H OUTPUT AS BS, -1 => ALWAYS, 0 => 340 ONLY, 1 => NEVER.
		;IF IT ISN'T OUTPUT AS BS, IT IS OUTPUT AS UPARROW-H.
DISSAI:	0	;ASSUME CTL CHARS ARE 1-POSITION GRAPHICS INSTEAD OF PRINTING AS ^-MUMBLE.
	.BYTE 8	;STRINGS TO OUTPUT IN SUPERIMAGE OUTPUT MODE:
EXPUNG DISCPV DISCPA DISCPH DISC1V DISC1H DISC2V DISC2H MORECV MORECH MORMCV
DISCMV=,.	;SET CURSOR AND CLEAR LINE.
	%TDNOP ? %TDMV0 ? DISCPV: 0 ? 0 ? %TDEOL ? %TDMV0 ? DISCPA: 0 ? DISCPH: 0
DISCM1=,.	;SET CURSOR, DON'T CLEAR LINE.
	%TDNOP ? %TDNOP ? %TDNOP ? %TDNOP ? %TDNOP ? %TDMV0 ? DISC1V: 0 ? DISC1H: 0
DISCM2=,.	;SET CURSOR TO LINE BELOW CURRENT POS, AND CLEAR LINE.
	%TDNOP ? %TDNOP ? %TDNOP ? %TDNOP ? %TDCRL ? %TDMV0 ? DISC2V: 0 ? DISC2H: 0
	.BYTE 7
MORECL=,.
	^P ? "V ? MORECV: 0 ? ^P ? "H ? MORECH: 0 ? ^P ? "L ? ^C ? ^C
MORMCL=,.
	^P ? "V ? MORMCV: 0 ? ^M ? ^P ? "L ? ^C ? ^C ? ^C ? ^C
	.BYTE
IFN 700000&(DISCPH),[	;IF MIDAS DEFINED ALL THE TAGS 1 BYTE TO SMALL, FIX THEM UP.
IRPS XX,,DISCPV DISCPA DISCPH DISC1V DISC1H DISC2V DISC2H MORECV MORECH MORMCV
.AOP IBP,0,XX
EXPUNG XX
XX=.AVAL2
TERMIN ]
DISVP:	-1	;VERT POS. OF LAST LINE GIVEN TO DISLIN, REGARDLESS OF
		;WHETHER THE LINE ACTUALLY HAD TO BE IOTTED.
		;(-1 ==> JUST WENT TO TOP OF SCREEN)
		;IF DISLIN SEES IT IS HACKING SAME LINE AS PREVIOUS
		;CALL TO DISLIN, IT DOESN'T CLEAR THE LINE.
DISVP1:	0	;VERT. POS. OF MAIN PRGM AREA TTY CURSOR.
		;TO MOVE TO LINE <C(DISVP1)+1>, DO AN LF INSTEAD OF
		;THE USUAL ^PV.
DISFLF:	0	;-1 ==> FORCE DISLIN TO SET CURSOR POS.
CHCTBP:	0	;BP. FOR CHCT TO STUFF CHARS.
CHCTVS:	0	;LAST +1 LINE FOR CHCT TO USE (= BOTLIN EXCEPT DURING TYPEOUT ON PRINTING TTY)
CHCTHP:	0	;POSITION IN TYPED LINE (FOR CONTINUATION AND TABS)
CHCTCF:	0	;-1 ==> LAST CHAR GIVEN TO CHCT WAS ^M.
CHCIGN:	0	;-1 => OUTPUTTING TRUNCATED PORTION OF LINE.
CHCTAD:	0	;CHCT PUSHJ'S @. WITH EACH LINE.
CHCTVP:	0	;VERT. POS. OF THAT LINE.
CHCTHC:	0	;HASH CODE OF THAT LINE.
CHCTBL:	0	;WHEN @CHCTAD CALLED, THIS HOLDS CHAR ADDR 1ST CHAR
		;IN THE LINE BEING DISPLAYED. (ASSUMING THAT
		;DISAD WAS CALLED WITH IN HOLDING ADDR
		;OF THE CHAR AFTER THE ONE BEING OUTPUT.)
CHCTNL:	0	;WHEN @CHCTAD CALLED, THIS WD >0 => CHAR ADDR
	;1ST CHAR TO APPEAR ON NEXT SCREEN LINE (IF ANY)
	;-1 => NEXT CALL TO @CHCTAD WILL BE ON SAME SCREEN LINE.
ORESET:	0	;OUTPUT STOPPED BY QUIT NOW IN PROGRESS
MORFLF:	0	;USER HAS FLUSHED TYPEOUT (1 => WITH RUBOUT, -1 => WITH OTHER CHAR)
MORESW:	0	;0 => MORE-LINE CLEAR, 1 => --MORE--, -1 => -FLUSHED.
TYOFLG:	-1	;>= 0 ==> TYPEOUT INITTED.
RUBENC:	0	;NONZERO => IS CHAR OR STRING TO TYPE BEFORE TYPING ANYTHING ELSE
		;(EG, \, AFTER A RUBOUT IN ^R IN SCANNING MODE).  FS XPROMPT$.
DISADP:	0	;WHEN DISAD IS CALLED, THIS SHOULD HOLD C(PT)+1.
		;USED BY DISAD TO DECIDE WHEN TO OUTPUT CURSOR.

DISBF1:	BLOCK 2	;HOLDS STUFF TO SET CURSOR POS FOR THE LINE IN DISBUF.
		;DISBF1 AND DISBUF IOTTED AT ONCE.
		;CURSOR MOTION NOT NEEDED => DISBF1 WILL HOLD ^C'S.
DISBUF:	BLOCK DISBFL	;BUFFER FOR TEXT TO BE IOTTED TO TTY.
DISBFC:	0	;# CHARS SPACE LEFT IN DISBUF.

DISPRR:	0	;NON0 => PDL LEVEL AT RRDISP.
		;CAUSES CRSR POS AT PT TO BY REMEMBERED, ETC.
GEA:	0	;-1, OR OLD ADDR (REL TO BEG) OF 1ST CHAR OF BUFFER DISPLAYED.
%TOP:	10.	;PERCENT OF SCREEN CURSOR SHOULDN'T ENTER AT TOP.
%BOTTO:	10.	;SIMILAR, FOR BOTTOM.
%CENTE:	40.	;PERCENT FROM TOP CURSOR SHOULD GO WHEN WINDOW CHANGES.
%END:	30.	;WHEN WINDOW MOVED, CURSOR MUST BE >= THIS MUCH FROM BOTTOM.
CLRMOD:	-1	;-1 => CLEAR SCREEN IN DISTOP IF TTY
		;HAD BEEN TAKEN AWAY AND RETURNED BY TECO'S SUPERIOR.
		;0 => DON'T DO THAT.
		;1 => DISABLE ALL SCREEN-CLEARING, EWVEN BY ^L AND F+
PJATY:	-1	;-1 => WE JUST GOT A %PJATY INT, SO SHOULD REDISPLAY WHOLE SCREEN SOON.
REFRSH:	0	;NONZERO => MACRO IT WHEN WANT TO CLEAR SCREEN DUE TO PJATY
		;(INSTEAD OF MACROING FS ^R DISPLAY$).
VIEWBF:	0		;1 DURING AUTOMATIC BUFFER DISPLAY. ELSE, 0.
VREMEM:	0	;NON0 WHEN DISPLAYING STUFF THAT'S IN BUFFER.
TTMODE:	0	;NON-0 => DISPLAY BUFFER AFTER CMD STRINGS EVEN IF PRINTING TTY.
HCDS:	BLOCK MXNVLS	;HASH CODES OF LINES ON SCREEN
HCDSE:	0

LINBEG:	BLOCK MXNVLS	;1 WD / LINE ON SCREEN, SET BY VBD AS FOLLOWS:
	 ;BITS 3.9 - 1.1 -- CHAR ADDR OF 1ST CHAR ON THE LINE
	 ;BITS 4.9 - 4.1 -- HPOS THAT CHARACTER STARTED IN.
DISOMD:	-1	;WHAT $QMODE HAD WHEN LAST DISPLAYED.
		;IF $QMODE NE DISOMD, MUST REDISPLAY THE MODE.
IFN TS,[
TIME:	0		;TIME IN SIXBIT
DATE:	0		;DATE IN SIXBIT
PDTIME:	0		;# SECONDS SINCE BEGINNING OF YEAR
LPDTIM:	0		;LOCALIZED "
YEAR:	0		;YEAR AND FLAGS
CDATE:	SIXBIT/ 00,19/

INTJPC:	0	;PLACE THAT JUMPED TO WHERE YOU
			 ;WERE INTERRUPTED FROM

TSINT:	0
	0
	.SUSET [.RJPC,,INTJPC]
	MOVEM 17,INTACS+17	;SAVE ALL ACS.
	MOVEI 17,INTACS
	BLT 17,INTACS+16
	MOVE B,TSINT
TSIL:	JUMPL B,TSIN2	;INT IN SECOND WORD
	TLZE B,%PJATY
	 JRST [	SKIPGE CLRMOD	;IF SCREEN WAS JUST GIVEN BACK TO TECO,
		 SETOM PJATY	;UNLESS CLRMOD HAS BEEN DISABLED, REQUEST THAT
		JRST TSIL]	;WE CLEAR SCREEN AND REDISPLAY FULLY.
	TLZE B,%PJWRO
	 TYPRE [PUR]
	TRZE B,%PIMPV		;MPV => CREATE THE NONEXISTENT CORE AND RETRY.
	 JRST TSINT4
	TRZE B,%PIPDL
	 TYPRE [PCE]
TSIN2A:	MOVSI 17,INTACS
	BLT 17,17
	.SUSET [.SJPC,,INTJPC]
	.DISMI TSINT+1

INTACS:	BLOCK	20

DISFB:	SIXBIT /  #DIS>/
EIDEV:	-1	;RH IS LAST DEV. EW'D
EISNM:	0	;LAST SNAME WRITTEN
ERDEV:	-1	;LIKE EIDEV BUT FOR DEV BEING READ.
ERSNM:	0	;AND SNAME BEING READ.
TTYTYP:	0	;TTYTYP VARIABLE OF TERMINAL.
TTYOPT:	0	;TTYOPT VARIABLE OF TERMINAL.
TTYST1:	322020,,202020	;ACTIVATE ON ^C (AND OTHER RANDOM CTL CHARS)
			;OUTPUT CTL CHARS IN IMAGE MODE.
TTYST2:	332033,,300220	;ACT. ON ^G (^S), RUB, ALT; INT. ON ^G (^S) ,ALTMODE; OUTPUT CR IN IMAGE.
TTYSTS:	0	;3RD ARG FOR TTYSET.
UTF:	'DSK,,	;UTF1 MUST BE NEXT WORD.
]
UTF1:	SIXBIT /@/
UTF2:	SIXBIT />/
UTSNM:	0	;CURRENT SNAME.
RUTF1:	0	;REAL FILE NAMES
RUTF2:	0	;ON READ

MSNAME:	0	;MSNAME AS GIVEN TO TECO ON STARTUP.

PAGENU:	0	;PAGE # IN INPUT FILE.
LASTPA:	-1	;0 IF HAVE YANKED LAST PAGE OF INPUT FILE.

OUTFLG:	0	;-1 => OUTPUT TO EW'D FILE DISABLED.
FILEPA:	^C	;CHAR TO PAD LAST WORD OF OUTPUT FILES WITH.

UUOJPC:	0
UUOQ:	0
UUOH:	0
	MOVEM Q,UUOQ
	LDB Q,[331100,,40]
	CAIN Q,TYPR4_-33
	 JRST ETYP2A
	.SUSET [.RJPC,,UUOJPC]
	MOVE Q,UUOQ
	.VALUE
	TYPRE [DSI]

SKRCH:	SKIPG COMCNT
	 TYPRE [UEC]
RCH:	SOSGE COMCNT
	 JRST RCH2	;NOTE RCH2 LOOKS AT OUR RETURN ADDRESS.
	ILDB CH,CPTR
	XCT RCHDTB(CH)	;DO SPECIAL STUFF OR JFCL..
TRACS:	 POPJ P,TYOS	;OR JRST TYOS IN TRACE MODE.
	SKIPN MACPTR	;RCHDTB ENTRY SKIPS IF SHOULD CHANGE CHAR'S CASE.
	 XORI CH,40	;BUT NEVER CHANGE CASE OF CHARS IN MACROS.
	JRST TRACS

;[[[[
RCHDTB:	REPEAT 33,JFCL
RCHALT:	JFCL ENDARG	;OR JRST IF SHOULD END A ^]^X
	REPEAT ^]-34,JFCL
RCHBRC:	JRST CTLBRC	;^]
	REPEAT "?-^],JFCL
	SKIPL RCHSFF		;@
	REPEAT 26.,SKIPL CASE	;UPPER CASE LETTERS
	REPEAT 5,SKIPL RCHSFF	;[\]^_
	JFCL			;`
	REPEAT 26.,SKIPG CASE	;LOWER CASE LETTERS.
	REPEAT 5,JFCL		;{|}~<RUBOUT>
IFN .-200-RCHDTB, .ERR RCHDTB WRONG SIZE.

SQUOTP:	0	;;SIGN => READING SUPER-QUOTED MACRO.
		;4.8 => READING DELIMITER-PROTECTED MACRO.
DLMF2:	0	;INTERNAL FLAG FOR CTLBRC INDICATES THAT 4.8 OF SQUOTP SHOULD BE SET
SQUOF2:	0	;    "      "   "     "        "      "  SIGN OF SQUOTP    "    "  " 
BRC1CF:	0	;INTERNAL FLAG FOR CTLBRC INDICATES THAT ONLY ONE CHARACTER SHOULD BE GOBBLED
BRCUAV:	0	;INTERNAL FLAG FOR CTLBRC INDICATES THE Q-REGISTER
		 ;SHOULD BE USED AS A NUMERIC VALUE (IE. ASCII VALUE)

BRC1:	0	;[ ZERO => HANDLE ^] NORMALLY
		;[[[[[; -1 => DO-NOT EXPAND MACROS, BUT HANDLE ^]^],^]$,^]^V<Q-REG>,AND ^]^Q NORMALLY
BRCFLG:	0	;[ ;SET TO -1 BY ^]'S THAT INSERT UNPREDICTABLE STUFF.
		;[ ;SET IT TO 0 AND TEST IT LATER TO SEE IF ANY ^]'S HAVE HAPPENED.
		;[ ;ALSO, ^]^V LEAVES THE CHARACTER HERE ON RETURN, AS IT WAS
		;BEFORE BEING TRUNCATED TO 7 BITS.

CASE:	0	;DESIRED INPUT CASE.
		;0 => LEAVE CASE OF CHARS ALONE,
		;<0 => WANT CHARS IN LOWER CASE,
		;>0 => WANT CHARS IN UPPER CASE.
		;NEGATED BY CASE-SHIFT AND CASE-LOCK CHARS.
CASNRM:	0	;NORMAL CASE - REINIT. CASE AT START OF CMD STRING.
		;THIS IS WHAT FSCASE SETS.
CASDIS:	0	;NONZERO => PUT CASESHIFTS IN OUTPUT.
CASSFT:	-1	;CASE-SHIFT CHAR, OR -1 IF NONE.
CASLOK:	-1	;CASE-LOCK CHAR, OR -1 IF NONE.
RCHSFD:	0	;SAVED NORMAL CONTENTS OF RCHDTB ENTRY FOR
		;CASE-:SHIFT CHAR (RCHDTB ENTRY NOW IS <CALL RCHSFT>)
RCHLOD:	0	;SAVED NORMAL RCHDTB ENTRY FOR CASE-LOCK CHAR.
RCHSFF:	0	;-1 => LAST CHAR WAS A CASE-SHIFT.
		;USED TO CAUSE A CASE SHIFT TO QUOTE ITSELF.

;;; TECO ADDRESS SPACE ORGANIZATION:

;;; THE 1ST 2 PAGES ARE THE "LOW IMPURE", CONTAINING SPECIAL-PURPOSE VARIABLES.
;;; THEN COMES THE PURE CODE, FROM "INIT" TO "HUSED".
;;; THEN COMES THE HIGH IMPURE, STARTING WITH A FEW SPECIAL-PURPOSE VARIABLES,
;;; FOLLOWED BY THE ^R COMMAND DISPATCH TABLE.

;;; THEN COME THE DYNAMICALY ALLOCATED AREAS:
; THE COMMAND BUFFER IS USED FOR OLD-FASHIONED (NON-^R) TECO TOP-LEVEL COMMAND READIN.
CBUFLO:	10740,,CBUF	;SET TO BP -> BOTTOM OF COMMAND BUFFER.
CBUFH:	CBUF+CBUFSZ-1	;-> LAST WD OF COMMAND BUFFER

; IMPURE STRING SPACE CONTAINS STRINGS AND BUFFERS' POINTER-STRINGS.
; BOTH START WITH A FLAG CHARACTER (QRSTR OR QRBFR, RESPECTIVELY), FOLLOWED
; BY 3 CHARACTERS HOLDING A NUMBER.  IN A STRING, THAT NUMBER IS THE LENGTH,
; INCLUDING THE FOUR HEADER CHARACTERS, AND THE DATA FOLLOWS THE NUMBER.
; IN A BUFFER POINTER-STRING, THE NUMBER IS THE ADDRESS OF THE BUFFER'S FRAME.
; EITHER KIND OF OBJECT IS REPRESENTED IN QREGS, AS VALUES, ETC. BY A NUMBER
; WHICH IS THE CHARACTER ADDRESS RELATIVE TO THE START OF THE SPACE, PLUS SETZ.
QRBUF:	INIQRB		;CHAR ADDR START OF IMPURE STRING SPACE
QRWRT:	INIQRW		;CHAR ADDR 1ST CHAR ABOVE IMPURE STRING SPACE.
QRSTR==177	;PREFIX CHAR FOR QREG STRING (FOLLOWED BY 3 CHARS HOLDING
		;21-BIT SIZE OF QREG INCLUDING 4 HEADER BYTES, FOLLOWED BY TEXT).
QRBFR==176	;PREFIX CHAR FOR BUFFER POINTER (FOLLOWED BY 3 CHARS
		;HOLDING ADDR OF POINTER-BLOCK (IN MACRO-FRAME SPACE)).

; THEN COMES A GAP, CONTAINING  NON-EXISTENT MEMORY, FOLLOWED BY BUFFER SPACE.
; EVERY BUFFER'S DATA AREA IS A SUBSET OF BUFFER SPACE, AND BUFFER SPACE
; IS USED FOR NO OTHER PURPOSE.
; BUFFER SPACE STARTS AND ENDS ON WORD BOUNDARIES, BUT BUFFERS NEED NOT START ON THEM.
; EACH BUFFER ENDS ON A WORD BOUNDARY, AND IS FOLLOWED BY ONE UNUSED WORD,
; WHICH IS INCLUDED IN BUFFER SPACE.  ASIDE FORM THOSE UNUSED WORDS, EVERY WORD
; IN BUFFER SPACE CONTAINS PART OF AT LEAST ONE BUFFER.
; BUFFER DATA IS POINTED TO BY BUFFER FRAMES (SEE MFBFR),
.SEE BEG ; OR, FOR THE CURRENT BUFFER, BY BEG, ETC.
BFRBOT:	INIBUF	;CHAR ADDR BOTTOM OF BUFFER SPACE (= BEG OF LOWERMOST BUFFER)
BFRTOP:	INITOP	;CHAR ADDR TOP OF BUFFER SPACE (> Z OF UPPERMOST BUFFER)

; THE MEMORY ABOVE BUFFER SPACE CAN CONTAIN ^P-SORT TABLES. IT CAN
; ALSO CONTAIN RANDOM DATA USED ENTIRELY WITHIN A SINGLE COMMAND.
MEMT:	<-2000>&<1777+INITOP/5>	;ADDRESS OF 1ST WORD OF NXM ABOVE BUFFER SPACE.

; ABOVE THE RANDM DATA THERE IS A GAP, RUNNING TO THE TOP OF MEMORY OR TO THE
; BEGINNING OF PURE STRING SPACE, WHICH STRETCHES DOWN FROM THE TOP OF MEMORY.
; OBJECTS IN PURE STRING SPACE LOOK LIKE OBJECTS IN IMPURE STRING SPACE, AND
; ARE POINTED TO BY NUMBERS WHICH ARE SETZ PLUS THE ABSOLUTE CHARACTER ADDRESS.
LHIPAG:	LHIMAX	;LOWEST PAGE IN USE BY PURE STRING SPACE.

INSINP:	0		;WHILE INSERTING, PDL LEVEL AT INSLUP, ELSE 0.
INSLEN:	0		;LENGTH OF THE LAST STRING INSERTED OR SEARCHED FOR.
TOTALC:	0		;# CHARS AT END OF GAP NOT YET USED BY INSERT.
INSRCH:	0		;INSN FOR INSERT TO XCT TO GET A CHAR.
INSDLM:	0		;THE DELIMITER FOR THIS INSERT
INSBP:	-1		;NORMALLY -1 => NO ACTION.
			;INSERT AND FCECMD SET IT TO 0, SIGNALLING RCH
			;THAT F SHOULD BE SAVED IN INSBP IF THERE IS A CHANCE
			;THAT A GC WILL OCCUR (EG IF PUSMAC IS CALLED).
			;BFRRLC WILL THEN RELOCATE INSBP AS A BYTE POINTER
			;EVENTUALLY RCH WILL COPY INSBP BACK TO F AND ZERO INSBP.

;VARIABLES DESCRIBING THE CURRENTLY SELECTED BUFFER.
BFRSTR:	SETZ INI..O-INIQRB	;INTERNAL VERSION OF $QBUFR;
		;-> POINTER-STRING OF CURRENT BUFFER.
BFRPTR:	MFBUF1	;-> BUFFER FRAME FOR CURRENT BUFFER (IN MACRO-FRAME SPACE).
BEG:	INIBEG		;CHARACTER ADDRESS OF BEGINNING OF BUFFER
BEGV:	INIBEG		;CHAR ADDR BEGINNING OF AREA BEING EDITED.
PT:	INIBEG		;CHARACTER ADDRESS OF "POINTER"
GPT:	INIBEG		;CHARACTER ADDRESS OF THE BEGINNING OF THE GAP
ZV:	INIBEG		;CHAR ADDR 1ST CHAR AFTER AREA BEING EDITED.
Z:	INIBEG		;CHARACTER ADDRESS OF FIRST CHARACTER AFTER BUFFER
EXTRAC:	0		;SIZE OF GAP (# CHARS)
	JRST SUPCMD	;START TECO HERE TO REQUEST SPACE IN BUFFER, ETC.
SUPARG:	0		;HOW MUCH SPACE IS WANTED.     RETURNS WITH .BREAK 16,100000

;VARS ASSOCIATED WITH COMPUTATION OF NUMERIC ARGUMENTS.
LEV:	0	;DEPTH IN PARENTHESES.
NUM:	0
SARG:	0	;ARG BEFORE COMMA FOUND HERE IF ARG2 FLAG SET.
DLIM:	ADD B,SYL	;THIS INSN SET BY ARITH OPS.
SYL:	0
OSYL:	0
SYLOV:	0	;-1 => COMPILING A NUMBER CAUSED OVERFLOW IN THE IBASE RADIX
OSYLOV:	0	;-1 => OVERFLOW WHEN USING THE I.BASE RADIX.
IBASE:	10.	;INPUT RADIX FOR NUMBERS NOT FOLLOWED BY "."
I.BASE:	8	;INPUT RADIX FOR NUMBERS FOLLOWED BY ".".

;VARS USED BY TYPEIN, AND LIS.
ECHOFL:	0	;NONZERO => SYSTEM ECHOING IS TURNED ON.
LTYICH:	0	;LAST CHAR READ FROM TTY, FOR DETECTING $$.
UNRCHC:	-1	;-1, OR CHARACTER TO BE RE-READ.
PROMCH:	"&	;THE PROMPT-CHARACTER; FS PROMPT $. 0 => NO PROMPTING.
CMFLFL:	0	;-1 READ COMMAND OR (INIT) FILE
CTLBRF:	0	;-1 IF CHARACTER BEING READ IN IS SUPER-QUOTED
SAVCMX:	1	;COMAX OF MOST RECENT CMD STRING > 3 WORDS LONG.
SAVCW1:	0	;AND 1ST 3 WDS OF THAT CMD STRING.
SAVCW2:	0	;THESE VARS COPIED BACK INTO COMAX, CMD BUFFER,
SAVCW3:	0	;AND CPTR BY LISCY (^Y AS FIRST CHAR TYPED)
SAVCPT:	0	;(SAVED CPTR) SO IT CAN RESTORE LAST LONG COMMAND.

FSPSPB:	BLOCK FSPSPL	;RING BUFFER OF PT.
FSPSPP:	4400,,FSPSPB-1	;RING BUFFER POINTER, -> LAST USED ENTRY.

LISTF5:	CALL .		;XCT THIS TO OUTPUT A CHARACTER.
DPT5:	MOVEI CH,40	;RH HAS CHARTO PAD A PRINTED NUMBER WITH.

;MACRO AND ITERATION HANDLING LIST STRUCTURE:
;EACH CELL HAS MFBLEN WORDS.
;LISTS ARE LINKED THRU THE LAST WORD.
;THE FIRST 2 WORDS ARE RELOCATED BY GC.
;POINTERS TO NON-FREE BLOCKS ACTUALLY POINT TO THE
;LAST WORD OF THE BLOCK.

MFBLEN==7	;# WORDS PER CELL.

;[ ;MACRO OR ^]<Q-REG> INVOKATION LIST...
;(POINTED TO BY MACPTR)
MFCMAX==0	;COMAX
MFCPTR==1	;CPTR
MFCCNT==2	;COMCNT
MFARG1==3	;MARG1
MFARG2==4	;MARG2
MFPF==5		;MACSPF
MFLINK==6	;MACPTR <POINTER TO PREVIOUS MACRO CELL.>
		;LH HAS SAVED LH(MACBTS).

;[[[ ;^]^X READ CELL.  ^]^X IS A SPECIAL KLUDGE TO ALLOW STRING ARGUMENTS
 ;TO BE READ FROM THE PREVIOUS COMMAND STRING LEVEL.  IT TRIES TO BE
 ;CLEVER ABOUT WHAT IT DOES WHEN OTHER ^] STRINGS ARE ENCOUNTERED WHILE
 ;SCANNING FOR THE END OF THE ARGUMENT, DEFINED BY THE FIRST <ALTMODE>
 ;ENCOUNTERED THAT ISN'T PROTECTED AGAINST TRIPPING THE CATCH (IE., BY QUOTING IT)>
;THESE CELLS FORM A LIST POINTED TO BY CTXPTR.
	;COMAX
	;CPTR
	;COMCNT
	;MARG1
	;MARG2
	;UNUSED.
;[	;CTXPTR <POINTER TO THE PREVIOUS ^]^X CELL IN FS: SPACE>

;ITERATION  OR ERRSET (:<  --  >)CELL
;THESE FORM A LIST POINTED TO BY ITRPTR.
		;COMAX
		;CPTR
		;COMCNT
MFICNT==3	;ITERCT <NUMBER OF ITERATIONS LEFT ON THE PREVIOUS ITERATION LEVEL>
MFMACP==4	;MACPDP <FOR POPPING ON ERROR IN ERRSET>
MFPF==5		;LH OF THIS WORD HAS RH OF P, RH HAS RH OF PF.
		   ;AS THEY WERE WHEN THE < WAS EXECUTED.
		;ITRPTR <PREV. ERRSET CELL,,PREV ITER CELL.>

;BUFFER FRAME - DISTINGUISHED BY NEGATIVE 1ST WORD OF BLOCK.
MFBBTS==740000	;THESE ARE ALL THE BITS IN MFBEG WORDS.
MFBFR==400000	;1 => THIS IS A BUFFER FRAME.
MFMARK==200000	;GC MARK BIT FOR BUFFER FRAME.
MFQVEC==100000	;BIT INDICATING MARK THRU THE WORDS OF THIS BUFFER
MFSTAB==040000	;1 => THIS BUFFER IS A COMPILED SEARCH TABLE.

MFBEG==0	;HOLDS WHAT WOULD BE IN BEG IF THIS BUFFER WERE SELECTED.
		;AS WELL AS MFBFR AND MFMARK IN THE LH.
MFBEGV==1	;SIMILAR, BUT FOR BEGV, AND NO MFBFR OR MFMARK.
MFPT==2		;SIMILAR, FOR PT.
MFGPT==3	;SIMILAR, FOR GPT.
MFZV==4		;SIMILAR, FOR ZV.
MFZ==5		;SIMILAR, FOR Z.
MFEXTR==6	;SIMILAR, FOR EXTRAC.

;THE FREE STORAGE LIST OF CELLS IS POINTED TO BY MFFREE,
;AND LINKED THROUGH THE LAST (MFLINK) WORD OF THE CELL,
;AND TERMINATED WITH A 0.
;THE MFCPTR OF A FREE CELL CONTAINS 0.
;POINTERS TO FREE CELLS ACTUALLY POINT TO THE WORD
;BEFORE THE FIRST WORD OF THE CELL.
;IF THE 1ST WORD OF A CELL IS NEGATIVE (MFBFR IS SET) THE CELL IS A BUFFER FRAME.

MFFREE:	.
MFSTRT:	REPEAT MFNUM-1, REPEAT MFBLEN-1,[ 0 ?] .
	REPEAT MFBLEN, 0
MFBUF1:	MFBFR,,INIBEG	;BUFFER FRAME FOR INITIALLY SELECTED BUFFER.
	REPEAT MFBLEN-2,INIBEG
	0
MFSBUF:	MFBFR+MFSTAB,,INISRB	;THIS BUFFER HOLDS THE COMPILED SEARCH STRING.
	REPEAT 4,INISRB
	INISRE
	0
MFEND::


COMAX:	0	;NUMBER OF CHARACTERS IN THE CURRENT COMMAND STRING
CPTR:	0	;BYTE POINTER TO COMMAND STRING (CURRENT LEVEL)
COMCNT:	0	;NUMBER OF CHARACTERS LEFT IN CURRENT LEVEL OF COMMAND STRING
MARG1:	0	;FIRST NUMERIC MACRO ARGUMENT (GOTTEN BY ^X INSIDE MACRO)
MARG2:	0	;SECOND NUMERIC MACRO ARGUMENT (FETCHED BY ^Y)
MACSPF:	0	;PF COPIED INTO THIS WORD WHEN MACRO IS CALLED.

MACPTR:	0	;POINTER TO THE LAST CELL IN THE MACRO INVOKATION AND
;[		    ;^]<Q-REGISTER> INVOKATION LIST
CTXPTR:	0	;[ ;POINTER TO LAST CELL IN THE ^]^X INVOKATION LIST

MACBTS:	0	;BITS IN LH SAYING HOW MANY ARGS GIVEN TO CURRENT MACRO.
MFBA1==400000	;1 => 2 ARGS WERE GIVEN.
MFBA2==200000	;1 => AN ARG WAS GIVEN.


ITRPTR:	0	;RH PTR TO INNERMOST ITERATION OR ERRSET CELL
		;LH PTR TO INNERMOST ERRSET CELL (OR 0)
ITERCT:	0	;# PASSES LEFT IN INNERMOST ITERATION.

;[[[[[ ;THE MACRO PDL CONSISTS OF 4-BIT BYTES, ONE PER MACRO CALL
;OR ^]-CALL (INCLUDING ^]^X).
;MACRO PDL OVERFLOW IS IMPOSSIBLE BECAUSE THE RATIO OF MACRO-PDL
;TO MACRO CELL SPACE INSURES THAT THE LATTER WILL RUN OUT FIRST.
;ONE ENTRY PUSHED FOR EACH ^] CALL (INCLUDING ^]^X) OR M COMMAND.
;0 => MACRO CALL THAT DIDN'T SUPERQUOTE OR DELIMITER-PROTECT.
;1 - 7  => MACRO CALL. 4 BIT => HAD BEEN LOOKING FOR $ AT RCHALT.
;     1 AND 2 BITS: SUBTRACT 1, THEN GET OLD 4.8, 4.9 OF SQUOTP.
;10 => NULL ENTRY, IGNORE WHEN POPPING.
;11 THRU 17 => ^]^X CALL, LOW 3 BUTS SAME AS FOR 1 - 7.

MACPDP:	400,,MACPDL-1	;MACRO PDL PTR, -> HIGHEST USED BYTE.
MACPDL:	BLOCK MACPSZ
MACXP:	0	;P IN LAST CALL TO MACXCT OR MACXQ.

GCPTR:	0
GCNRLC:	0	;-1 => GC SHOULDN'T RELOCATE STRINGS, JUST FLUSH UNNEEDED BUFFERS.
STOPF:	0	;(FS QUIT) NEGATIVE == QUIT DESIRED (FS QUIT)
		;^G AT INT LVL SETS STOPF; SETTING STOPF CAUSES
		;QUITTING ACTION UNDER CONTROL OF NOQUIT.
NOQUIT:	0	;(FS NOQUIT) 0 => ^G QUITS TO TECO'S TOP LEVEL.
		;POSITIVE => ^G JUST SETS STOPF FOR PROGRAM TO TEST.
		;NEGATIVE => ^G CAUSES "QIT" ERROR (ERRSETABLE).
RUNFLG:	0	;-1 ==> TECO HAS BEEN RUN
UPXOCT:	0	;COUNT OF CHARS IN QREG TO BE APPENDED TO IN X
UPXOPT:	0	;START LOCATION OF   "   "  "     "     "  " "
QRGCMX:	INIQRB+GCOFTN	;GC QREGS WHEN QRWRT GETS THIS LARGE.
LASTER:	0	;MOST RECENT ERROR MESSAGE (A STRING POINTER).
ERRFLG:	0	;SET TO -1 WHEN ERROR DETECTED;
		;CLEARED WHEN TECO FINISHES EITHER EXITING
		;FROM THE ERRSET IF ANY, OR DISPLAYING THE BUFFER
		;OR DIR IF THERE WAS NO ERRSET.
		;(PREVENTS BUF DISP. FROM OVERWRITING ERR MSG)
ERRFL1:	0	;FS ERRFLG - COPIED FROM ERRFLG AT END OF CMD STRING FOR Q..B'S USE.
VERBOS:	0	;IF NON-ZERO, DISPLAY WHOLE ERROR MESSAGE
		 ;STRING IMMEDITAELY
ERR1:	0
ERR2:	0

PTLFCD:	0	;PTLAB FILE CREATION DATE

STABP:			;THIS IS THE CACHE FOR JUMPS ("O" COMMAND)
SYMS:	BLOCK 20	;THESE HOLD THE CPTRS AT SOME JUMPS;
VALS:	BLOCK 20	;THESE, THE CPTRS OF TAGS JUMPED TO;
CNTS:	BLOCK 20	;THESE, THE COMCNTS AT THOSE TAGS.
SYMEND:			;ENTRIES ARE IN PAIRS. EACH JUMP CPTR SELECTS A PAIR
			;THE ENTRIES IN A PAIR ARE USED FIFO BY NEW JUMPS.

PF:	-LPF-1,,PFL-1	;Q REGISTER PDL POINTER
PFL:	BLOCK LPF
;QREG PDL ENTRIES ARE 2 WORDS EACH.
;THE FIRST WORD CONTAINS THE DATA PUSHED.
;THE SECOND CONTAINS INFO ON WHERE PUSHED FROM:
;  EITHER THE CORE LOCATION PUSHED FROM,
;  OR THE INDEX IN FLAGD OF THE FS FALG THAT WAS PUSHED.
;  THESE ARE DISTINGUISHED BY WHETHER THE NUMBER IS < FLAGSL.

PDL:	BLOCK LPDL
BAKTAB:			;"\" COMMAND WITH ARG "PRINTS" INTO THESE WORDS.
LTABS==100.
STAB:			;WITHIN "O" COMMAND SEARCH, HOLDS THE TAG NAME.
LBF:			;OUTPUT BUFFER FOR "@" AND "^O" COMMANDS.
GCTAB:	BLOCK GCTBL
IFG LTABS-GCTBL,BLOCK LTABS-GCTBL
	;USES OF GCTAB:
	;JCL READ INTO IT. USED AS BUFFER BY E_. USED BY ALINK
	;TO HOLD SOME TEMPS.

QRB:	QTAB		;POINTER TO BLOCK OF QREGS WITH NO "."'S IN NAME.
QRB.:	QTAB+36.	;POINTER TO BLOCK OF ONE-"." QREGS.
QRB..:	QTAB+36.*2	;POINTER TO BLOCK OF ".." QREGS.
QTAB:	BLOCK NQREG

;^P SORT VARIABLES:
PSMEM:	0	;WD ADDR 1ST WD OF ^P SORT TABLE
		;(WHICH LIVES ABOVE THE BUFFER)
PSMEMT:	0	;WD ADDR 1ST WD OF LAST ENTRY OF TABLE
		;ENTRIES ARE ADDED AT THE END, AND ARE 4 WDS LONG.
PSMXMT:	0	;LARGEST VALUE PSMEMT CAN REASONABLY
		;HAVE. IF IT GETS THIS BIG, AN ERROR RESULTS.
		;THAT CATCHES VARIOUS LOOPING SORT COMMANDS.
PSSAVP:	0	;P SAVED INSIDE ^P, OR 0. USED TO TELL WHETHER A SORT IS IN PROGRESS.
		;ALSO USED TO DETECT UNWINDING OUT OF A SORT.
PSZF:	0	;SET TO -1 TO INDICATE LAST RECORD HAS BEEN FOUND.
PSCASE:	0	;NONZERO => ^P-SEARCH IGNORES CASE. (FS ^PCASE)

LPSDBK==4	;SORT TABLE ENTRIES ARE 4 WDS LONG:
	;0TH WD	CHAR ADDR START OF KEY, RELATIVE TO BEG.
		;LATER REPLACED BY BP TO ILDB KEY.
	;1ST WD	-<# CHARS IN RECORD>,,-<# CHARS IN KEY>
	;2ND WD	CHAR ADDR START OF RECORD, RELATIVE TO BEG.
	;3RD WD	POINTER (RELATIVE TO PSMEM) TO NEXT ENTRY,
		;OR -1 FOR LAST ENTRY. TABLE IS SORTED
		;BY CHANGING THESE POINTERS.

;SEARCH VARIABLES:
PNCHFG:	0	;0 => S OR _, -1 => S OR N, 1 => FB
SEARG:	0	;# TIMES TO SEARCH. 1 FOR FB;
		;= ABS VAL. OF NUMERIC ARG FOR S, _, N.
SRCERR:	0	;-1 => FAILING SEARCHES SHOULD BE ERRORS EVEN INSIDE ITERATIONS.
BBP:	0	;BP. TO 1ST CHAR IN RANGE TO BE SEARCHED.
ZBP:	0	;BP TO CHAR AFTER LAST CHAR IN RANGE TO BE SEARCHED.
BBP1:	0	;IN FWD SEARCH, SAME AS BBP.
		;BACKWARD, IF SEARCH RANGE ENTIRELY BELOW GAP,
		;SAME AS BBP; ELSE, BP TO 1ST CHAR OF RANGE
		;OR 1ST CHAR AFTER GAP, WHICHEVER IS HIGHER
		;(THAT IS, WHICHEVER WILL BE ENCOUNTERED FIRST)
		;WHEN BACKWARD SEARCH CROSSES GAP, BBP1 SET FROM BBP.
ZBP1:	0	;IF GAP IS WITHIN RANGE OF SEARCH,
		;BP TO 1ST CHAR POS WITHIN THE GAP.
		;ELSE BP TO 1ST CHAR POS ABOVE THE RANGE (LIKE ZBP)
		;WHEN FWD SEARCH CROSSES THE GAP, ZBP1 SET FROM ZBP
SLP4N:	0	;WHEN BACKWARD SEARCH WHICH HAS CROSSED GAP
SLP4N1:	0	;TEMPORARILY MOVES  FWD OVER IT AGAIN WHILE
		;CHECKING ONE ALTERNATIVE STRING,
		;SLP4 AND SLP4+1 ARE SAVED IN THESE 2 WDS.
		;THEY ARE RESTORED WHEN SEARCH STARTS MOVING
		;BACKWARD AGAIN.
LOSED:	JRST .	;LOSE2\LOSE1 +S OR -<ANYTHING> => JRST LOSE2
		;+N OR +_ => JRST LOSE1
WIND:	JRST .	;SLP1J\WINNUL GO INTO LOOP
SLP1P:	JRA AA,.	;SLP1D\SLP1I INSTRUCTION EXECUTED WHEN TIME TO READ ANOTHER CHARACTER
TEM1:	0		;TEMP
TEM2:	0		;"

SFINDF:	0	;VALUE OF THE LAST SEARCH (WHETHER :-SEARCH OR NOT)

SBFRS:	SETZ INISRS-INIQRB	;QREG-STRING THAT PRESERVES SEARCH-BUFFER.
SBFRP:	MFSBUF			;-> SEARCH BUFFER HEADER.
STBLP:	INISRB/5		;ADDRESS OF SEARCH BUFFER BODY.
STBLPX:	INISRB/5,,SLP1P		;ALWAYS THE SAME FUNCTION OF STBLP.

SFXOR:	0	;ASCII /QQQQQ/, IF 1ST CHAR OF SEARCH STRING IS Q, INSIDE SFAST.
SFASAD:	SFAFN0,SFAFC0	;ADDRESS TO ENTER APPROPRIATE MAIN LOOP OF SFAST.
			;DEPENDS ON WHETHER CASE BEING IGNORED FOR 1ST CHAR OF STRING.

IFN TS,[
CTLCF:	0		;SET BY ^C, SAYS EXIT AFTER COMMAND DONE.
CTIME:	SIXBIT /  :  :  /
0
UTIBUF:	BLOCK UTBSZ
UTIBE:	0	;CURRENT EOF
UTRLDT:	350700,,

UTOBUF:	BLOCK UTBSZ
UTOBE:
UTYIP:	010700,,0
UTYOP:	010700,,0
UTYOCT:	0
FDRBUF:	BLOCK FDRBFL
FDRBFE:	<EOFCHR>_29.
FDRP:	0	;BYTE POINTER TO FDRBUF

ERRF:	'ERR
	3
ERRF2:	0

IMQUIT:	0	;-1 SAYS ^G SHOULD QUIT IMMEDIATELY.
		;SET EG. DURING SEARCHES, WHICH DON'T NEED TO CLEAN UP.
		;1 => GOX1 SHOULD JUST OMIT PUSHING STUFF.
		;SET TO 1 ONLY AT TECO STARTUP AND WITHIN LIS.

GOXFLS:	0	;ZEROED BY GO. -1 => GO SHOULD POP ALL THE WAY TO THE TOP LEVEL.
		;1 => GOX1 SHOULD JUST OMIT PUSHING STUFF.

TSA:	0	;TEMPORARY DURING TSINT
TSCH:	0	;"
TSINAL:	0	;-1 => LAST INT. CHAR. WAS ALTMODE. (FOR FINDING $$ AT INT LVL)
TSALTC:	0	;# OF $$'S ITYIC'D BUT NOT IOT'D.

CHPOPX:	TRNE\TRNN T,1	;SEE IF THIS PUSHED IOCHNL IS THE RIGHT DIRECTION
GCHN2:	CAIN C,.	;DON'T USE CHNL AS TEMP
			;IF ITS THE ONE WE WANT TO POP INTO.

IOP:	-LIOPDL,,IOPDL-1	;POINTER TO LOCAL IO PDL
IOPDL:	BLOCK LIOPDL	;LOCAL IO PDL

EXITV:	ASCII \:M  \	;OR /:M /
	ASCII /(E)  /
EXITV0:	BLOCK 6		;FILENAME PUT HERE IN ASCII.
	ASCII /   î /	;OR /(C)î /
EXITV1:	ASCII /     /	;OR /:CREF/
	ASCII /     /
EXITV2:	ASCII /     /	;OR FN1 OF FILE, FOR CREF.
	ASCII /     /
	ASCII /    î/	;IN CASE CREFFING.
	ASCII /DEBUGJBL   /
EXITV3:	BLOCK 2		;FN1 OF FILE, FOR $L.
	ASCIZ /î:VK /
EXITVF:	0		;-1 => .VALUE EXITV AFTER 1ST PASS OF @.
]

RDMNMS:	3.14	;USED BY RANDOM # GENERATOR. VALUE OF FS RANDOM
DOWNF:	0	;-1 => DOING AN FLD
SEXPFL:	0	;-1 => FL IS LOOKING FOR S-EXP, NOT LIST.
		;S-EXP MEANS EITHER WORD OR LIST, WHICHEVER STARTS FIRST.
FFRRCT:	0	;IN FILENAME READER = <# OF FILENAMES> -1
FNAMSY:	0	;0 => IF ONLY 1 FILENAME IN STRING, IT IS FN2.
		;NOT 0 => IT IS FN1 (LIKE ALL OTHER PROGRAMS). (FS FNAMSYNTAX)
ADLINE:	60.	;SIXTY CHARACTERS PER LINE OF ADJUSTED TEXT (FA)
NOOPAL:	-1	;IGNORE ALTMODES IF NEGATIVE.
		;STRAY ALTMODES ARE ERRORS IF THIS IS 0. THEY ARE LIKE ^_ IF >0.
NLAROW:	0	;0 => "_" LEGAL. 1 => ILLEGAL. -1 => "_" TREATED AS "-".
YDISAB:	0	;0 => Y IS LEGAL. 1 => ILLEGAL. -1 => Y TREATED AS ^ Y.
TABMOD:	0	;0 => TAB INSERTS, 1 => TAB ILLEGAL, -1 => TAB IGNORED.
FFMODE:	0	;NON0 => ^L'S READ FROM FILE GO IN BFR.
		;0 => ^L AT END OF PAGE Y'D OR FILE ^Y'D
		;IS THROWN AWAY, AND PW GENERATES A ^L.
UNWINF:	0	;0 => UNWIND QREG PDL AFTER EACH COMMAND STRING.
BOTHCA:	0	;NONZERO => SEARCH DOESN'T DISTINGUISH UPPER AND LOWER CASE.
SKNBPT:	0	;B.P. TO LDB 1ST CHAR OF THE STRING IN .QDLIM.
		;HAS A IN INDEX FIELD.
KILMOD:	-1	;0 => FS BKILL SHOULDN'T REALLY KILL.
SLPNCR:	0	;-1 => SLPN00 SHOULDN'T CLEAR LOW BITS.
YANKMT:	0	;0 EXCEPT INSIDE YANK, HAS WHAT MEMT HAD AT START OF YANK.
		;USED TO ELIMINATE EXCESS LOW-BIT CLEARING.
TRCOUT:	0	;NONZERO WHILE OUTPUTTING TRACE OUTPUT.
		;USED TO PREVENT TRACE OUTPUT FROM CLOBBERING TOP LINE OF SCREEN.
PUREFL:	0	;-1 => TECO HAS BEEN PURIFIED.
INITF1:	0	;SET TO -1 BY STARTUP CODE SO THAT ..L WILL BE MACROED
		;NEXT TIME THROUGH THE LOOP AT GO.
INITFL:	0	;TECO WAS STARTED AT INIT+2, SAYING IT IS UNDER A LISP.
STEPFL:	0	;-1 => TECO MACRO LINE-STEPPING FEATURE ENABLED:
		;CR AS A COMMAND DOES ^VW AND THEN QUITS IF CHAR IS ^G,
		;ENTERS ^R IF CHAR IS ^R, SETS STEPFL TO 0 IF CHAR IS ^P.
SETPP:	0	;OLD CONTENTS OF P BEFORE MOST RECENT CALL TO SETPP.
SUPHND:	0	;FS SUPERIOR$ - MACRO TO HANDLE REQUESTS FROM SUPERIOR.

BOOTSN:	'.TECO.	;SNAME OF TECO PDUMP FILE FOR EJ FILES TO BOOT TECO FROM
BOOTF2:	.FNAM2	;FN2 IS TECO VERSION #.

IF2 PURP1==INIT/2000		;# OF 1ST PURE CODE PAGE
IF2 PURPL==<HUSED+1777>/2000	;# OF 1ST PAGE ABOVE PURE CODE.

BOOT:	JRST BOOT1	;THIS IS THE START ADDRESS WRITTEN INTO EJ FILES.
	.VALUE
	SETOM INITFL	;START AT START + 2 => SET FS LISPT.
BOOT1:	SKIPE LIMPUR	;WERE WE JUST LOADED, OR WERE WE RESTARTED?
	 JRST INIT	 ;RESTARTED => PURE CODE ALREADY PRESENT, SO DO NORMAL RESTART.
	SYSCAL OPEN,[[.UII,,UTYIC] ? ['DSK,,] ? ['TECPUR] ? BOOTF2 ? BOOTSN]
	 .LOSE 1400	;TECO PURE FILE NOT FOUND.
	.IOT UTYIC,A
	SKIPE A
	 .LOSE		;NOT A PDUMP FILE??
	.ACCESS UTYIC,[INIT+2000]	;GOBBLE TECO'S PURE PAGES OUT OF THE PDUMP FILE.
	MOVE A,[PURP1-PURPL,,PURP1]
	SYSCAL CORBLK,[MOVEI %CBNDR ? MOVEI %JSELF ? A ? MOVEI UTYIC]
	 .LOSE 1000
	.CLOSE UTYIC,
	SETOM PJATY
	MOVEI TT,LHIMAX
	MOVEM TT,LHIPAG
	JRST INIT

CONSTA			;WITHOUT THIS, OUR LITERALS WOULD BE IN THE PURE CODE.

IFN RMSSW, RRVARX: IF2 IFNDEF RRVARB, RRVARB:: BLOCK RRVARL

IF2 VPAT: VPATCH:

IFN TS,[
INFORM [END OF LOW IMPURE]\.-1
LOC .\1777		;MOVE TO LAST WORD OF PAGE
LIMPUR:: -1		;THIS WORD NOT DUMPED BY ^ EJ, SO BOOT SEES 0; INIT SETS TO -1.
]

IFN RMSSW,[	;^R REAL TIME EDIT MODE.

RRVARL==45.	;IN ORDER TO DECIDE AT END OF PASS 1 WHERE
		;TO PUT THE ^R VARIABLES, MUST KNOW WHETHER
		;THEY WILL FIT IN LOW IMPURE. THUS, NEED
		;TO KNOW HOW MANY THERE ARE.

IF2 [	;BY THE TIME WE GET HERE ON PASS 2, RRVARB WILL
	;HAVE THE DESIRED LOCATION OF THE ^R VARIABLES BLOCK.
RRTMPV==.  ?  LOC RRVARB

RRHPOS:	0	;CURRENT CURSOR HPOS & VPOS: REFLECT
RRVPOS:	0	;CURRENT VALUE OF PT, EVEN IF SCREEN HASN'T CAUGHT UP.
RROHPO:	-1	;WHAT RRHPOS HELD LAST TIME CURSOR ACTUALLY WAS MOVED.
RROVPO:	-1	;IF THESE DIFFER FROM CURRENT POS, MUST MOVE CURSOR.
RRCMMT:	-1	;0 IF IN COMMENT MODE.
RRCCOL:	0	;COLUMN IN WHICH THE COMMENTS SHOULD START.
RRMNVP:	0	;THE VPOS OF UPPERMOST LINE THAT NEEDS REDISPLAY,
		;OR -1 => WINDOW MUST BE TESTED FIRST.
RRMNHP:	0	;LEFTMOST COLUMN ON THAT LINE THAT NEEDS REDISPLAY.
RRMAXP:	0	;NON0 => LARGEST VALUE OF PT AT WHICH BUFFER WAS CHANGED.
RRRPCT:	0	;NUMERIC ARG SPEC'D WITH ^V OR CTL-DIGITS.
RRARGP:	0	;NONZERO => RRRPCT HAS BEEN SET (ELSE IT DEFAULTS TO 1).
RR4TCT:	0	;# OF OCCURRENCES OF ^U.
		;THE NUMERIC ARG TO A COMMAND IS:
		; C(RRRPCT) * (4 ^ C(RR4TCT))
RUBCRL:	0	;-1 => ^D AND RUBOUT DELETE A WHOLE CRLF AT ONE BLOW.
RRLAST:	0	;MOST RECENT ^R-MODE CHAR THAT WASN'T AN ARGUMENT-SETTING COMMAND
RRPRVC:	0	;WHAT WAS IN RRLAST BEFORE ITS CURRENT CONTENTS.
RRRPLC:	0	;-1 => NORMAL CHARS REPLACE (X = DIX$)
		;1 => THAT, AND META-CHARS INSERT (LIKE ETV)
RRMCCT:	0	;FS CRMDLY -- # CHARS TO HANDLE BETWEEN
		;INVOCATIONS OF SECRETARY MACRO.
RRMCC1:	0	;THIS IS USED TO COUNT THAT MANY CHARS.
RRNCCR:	0	;SET TO -1 DURING REDISPLAY IF THE PTR
		;COMES AFTER A CR. THAT MEANS RRHPOS IS WRONG
		;AND SHOULD BE COMPUTED BY CALLING RRBTCR.
RRCCHP:	0	;TEMP. IN CHCT; SAVES HPOS AT START OF EACH CHAR.
RRERFL:	0	;TEMP. THAT SAVES ERRFL1 OVER CALL TO VBD.
RROLDZ:	0	;VALUE OF Z, AT TIME OF LAST REDISPLAY
		;THAT WASN'T INTERRUPTED BY TYPEIN.
RRMVH:	ASCIC/H /	;IOT THIS TO MOVE CURSOR HORIZONTALLY.
RRMVV:	ASCIC/V /	;USE THIS TO MOVE IT VERTICALLY.
			;(REPLACING THE ^@ WITH 8 PLUS DESIRED POSITION)

RRUNQT:	-1	;-1 => TEMPORARILY REENABLE BUILTIN COMMANDS.
RRALQT:	-1	;NONNEG => DISABLE BUILTIN COMMANDS, BUT
		;THIS WD'S CONTENTS ARE CHAR THAT REENABLES THEM TEMPORARILY.
RRCMQT:	0	;-1 => ALL CONTROL-META-LETTERS,ETC. ARE SELF-INSERTING (FOR EDITING MACROS).
RREZ:	INIBEG	;WHEN ^R MODE IS EXITED, Z, BEG AND PT
RREBEG:	INIBEG	;ARE SAVED IN THESE 3 VARS. IF ^R IS REENTERED
RREPT:	INIBEG	;WITH ARGS, THEY ARE COMPARED WITH THESE VALUES.
		;RREBEG IS 0 WHILE ^R IS ACTUALLY IN CONTROL.
		;NOT 0 DURING NORMAL COMMAND EXECUTION, INCLUDING MACROS CALLED FROM ^R.
		;0 PREVENTS ^G FROM QUITTING AT INT LVL.
RREVPS:	0	;REMEMBER RRVPOS AND RRHPOS AT EXIT, IN CASE WE REENTER
RREHPS:	0	;WITH ONE ARGUMENT.
RRMKPT:	-1	;THE MARK USED BY ^T, ^X, ^W.
RRSCAN:	0	;NONZERO => VARIOUS COMMANDS PRINT WHAT THEY STEP OVER/INSERT/DELETE.
RRECHO:	0	;-1 => ECHO THE ^R COMMANDS EXECUTED. 0 => ECHO ONLY ON PRINTING TTY
RRMORF:	0	;NONZERO => SUPPRESS THE PRINTING OF --MORE-- WHEN IN ^R MODE.
RRXINV:	0	;THIS IS THE REAL DEFINITION OF "SELF-INSERTING CHARS", 0 => SELF-INSERT
RRENTM:	0	;FS ^R ENTER$, NONZERO => MACRO IT WHEN ENTER ^R.
RRLEVM:	0	;FS ^R LEAVE$, NONZERO => MACRO IT WHEN LEAVE ^R.
RRDISM:	0	;FS ^R DISPLAY$, NONZERO => MACRO WHEN ABOUT TO DO NONTRIVIAL REDISPLAY.

;DEBUGGING VARIABLES:
RRDHPS:	0	;REMEMBERS RRHPOS BEFORE LAST REDISPLAY.
RRDVPS:	0	;SAME FOR RRVPOS
RRDMHP:	0	;SAME FOR RRMNHP
RRDMVP:	0	;SAME FOR RRMNVP
RRDPT:	0	;REMEMBER 1ST CHAR DISPLAYED IN LAST REDISPLAY.
IFN .-RRVARB-RRVARL, .ERR RRVARL ISN'T SET RIGHT.

LOC RRTMPV
]

INIT:	JRST INIT2
	.VALUE
	SETOM INITFL
INIT2:	SETOM LIMPUR	;MAKE SURE A SECOND $G WON'T MAKE BOOT REBOOT.
	SKIPE RUNFLG	;RESTARTING => DON'T CLOBBER BUFFER, Q-REGS.
	 JRST GOZ
	MOVEI A,10.
	MOVE CH,QRB..
	MOVEM A,.QBASE(CH)	;INIT. OUTPUT RADIX.
	CLEARB FF,SFINDF
	MOVE P,[-LPDL,,PDL-1]
GOZ:	MOVE C,[-7,,[.SMASK,,[TSMSK] ? .SMSK2,,[TSMSK1]	;SET MASKS,
		    .SPICL,,[-1]
		    .RSNAM,,Q
		    .RIOS+TYIC,,TT
		    .RIOS+UTYIC,,A ? .RIOS+UTYOC,,B]]
	.SUSET C
	SKIPN TT	;IF STARTED FOR 1ST TIME AFTER BEING LOADED,
	 MOVEM Q,MSNAME	;THEN OUR .SNAME IS THE MSNAME.
	SKIPN TT
	 MOVEM Q,UTSNM	;AND ALSO SHOULD BE OUR DEFAULT SNAME.
	JUMPN A,GOZ4	;ALSO SEE IF DISK CHNLS REALLY STILL OPEN.  IF THEY AREN'T,
	CALL UICLS	;TECO SHOULDN'T THINK THEY ARE.
GOZ4:	JUMPN B,GOZ5
	TLZ FF,UWRITE
GOZ5:	CALL INITTY	;INITIALIZE TTY AND FLAGS ABOUT WHAT KIND AND HOW TO TREAT IT.
	MOVEI A,[ASCIZ *-!-*] ;USE -!- FOR CURSOR ON PRINTING TTYS.
	SKIPE B,RGETTY
	 MOVEI A,[ASCIZ */\*] ;USE /\ ON DISPLAYS.
	CAIN B,3
	 MOVEI A,[ASCIZ //] ;BUT USE "I-BEAM" ON IMLACS.
	HRLI A,BP
	MOVE CH,QRB..
	ADDI CH,.QCRSR
	CALL INSASC	;INSERT ASCII STRING IN Q-REG ..A.
	SETOM INITF1	;CAUSE ..L TO BE RUN.
	JRST GOZ3

GOZ3:	SKIPE RUNFLG
	 JRST GOZ6

;STUFF TO DO WHEN STARTED UP THE 1ST TIME ONLY.
	MOVE CH,QRB..
	MOVE A,[SETZ 1+INIDLM*5-INIQRB]
	MOVEM A,.QDLIM(CH)
	HRRI A,INI..O-INIQRB
	MOVEM A,.QBUFR(CH)
	MOVEM A,.Q..Z(CH)
	MOVE IN,BEG	;MAKE SURE THE BOTTOM PAGE OF BUFFER EXISTS
	CALL GET	;TO PREVENT CONFUSING THE CODE AT FLSCOR
	SETOM RUNFLG	;SAY TECO HAS BEEN RUN.
	MOVEI A,[ASCIZ/ 5FSQVECTOU..Q 2U:..Q(0)/]
	CALL MACXCW	;PUT AN EMPTY SYMBOL TABLE IN ..Q.
	MOVEI A,TYOA
	HRRM A,LISTF5	;CAUSE OUTPUT ROUTINES TO TYPE ON TTY.
IFN TS,[
	MOVEI A,[ASCIZ/IMPURE /]
	SKIPN PUREFL
	 CALL ASCIND
]
	MOVE A,[.FNAM1]
	MOVEI B,".
	CALL SIXINT
	MOVE A,[.FNAM2]
	CALL SIXIN1
$%.==<.FNAM2_<-36>>&17*100.+<.FNAM2_<-30>>&17*10.+<.FNAM2_<-22>>&17
IFN TS,[
	.SUSET [.RXUNAM,,B]
	.CALL GOZO1	;OPEN C(B);.TECO. (INIT).
	 CAIA
	  JRST GOZ7
	CAIE A,OPLNSU	;DON'T LOOK ON (INIT) UNLESS USER HAS NO DIRECTORY.
	 JRST GOZ9
	.CALL GOZO2	;ELSE OPEN (INIT);C(B) .TECO.
	 CAIA
	 JRST GOZ7
GOZ9:	MOVSI B,(SIXBIT/*/)
	.CALL GOZO2	;LAST RESORT IS (INIT);* .TECO.
	 CAIA
GOZ7:	  SETOM CMFLFL	;BUT IF (INIT) FILE EXISTS, USE IT,
]
GOZ6:	JRST CTLW	;DROP INTO MAIN LOOP AS IF AFTER ^G.

GOZO1:	SETZ ? SIXBIT/OPEN/ ? [.BAI,,UTYIC]
	  ['DSK,,] ? ['.TECO.] ? [SIXBIT/(INIT)/] ? B ? 403000,,A

GOZO2:	SETZ ? SIXBIT /OPEN/ ? [.BAI,,UTYIC]
	  ['DSK,,] ? B ? ['.TECO.] ? SETZ [SIXBIT/(INIT)/]

;OPEN THE TTY CHANNELS AND SET VARIOUS VARS ACCORDING TO TYPE OF TTY.
FSTTYI:
INITTY:	TSOPEN TYIC,[[%TIFUL+40,,'TTY]]	;INITIALIZE TTY.
	TSOPEN DCHN,[[%TJCTN+%TJDIS+.BAO,,'TTY]]	;BLOCK OUTPUT FOR DISIOT.
	TSOPEN ECHOC,[[%TJECH+%TJPP2+.UAO,,'TTY]]	;ECHO MODE OUTPUT.
	TSOPEN ECDISC,[[%TJECH+%TJPP2+%TJCTN+%TJDIS+.UAO,,'TTY]] ;FOR FS ECHO DISPLAY$.
	TSOPEN SIOC,[[%TJSIO+%TJCTN+.UAO,,'TTY]]	;SUPER-IMAGE OUTPUT.
	TSOPEN TYOC,[[%TJCTN+.UAO,,'TTY]]		;NORMAL TYPE OUT.
	SETZM DISSAI	;DEFAULT IS DON'T PRINT SAIL CHARACTERS.
	PUSHJ P,SETTTM	;SET UP RGETTY, STTYS.
	MOVEM CH,RGETTY
	.CALL RSSB	;SET NVLNS, NHLNS, TTYOPT.
	 .VALUE
	SETCM A,TTYOPT
	TLNE A,%TOOVR	;TTY CAN'T OVERPRINT =>
	 SETZM DISPCR	;DON'T LET STRAY CR'S TRY TO DO SO.
	TLNE A,%TOOVR+%TOMVB	;CAN BACKSPACE ALSO =>
	 SETZM DISPBS	;LET BS OVERPRINT.
	TLNN A,%TOSA1	;:TCTYP SAIL => WE SHOULD USE SAIL CHAR SET.
	 SETOM DISSAI
	MOVE B,RGETTY
	MOVEM B,VERBOS	;LONG ERR MSGS DEFAULT ON IFF DISPLAY TTY.
	MOVE A,TTYOPT	;CAN'T ERASE SELECTIVELY => CAN'T USE DISPLAY FEATURES.
	TLNN A,%TOERS
	 CALL [MOVSI B,377777	;WE SHOULD NEVER DO --MORE--,
		MOVEM B,NVLNS
		MOVSI B,%TSMOR	;SYSTEM SHOULD DO **MORE** PROCESSING.
		ANDCAM B,TTYSTS
		SETZB B,RGETTY	;ALSO PRETEND TO BE PRINTING TTY.
		RET]
	SETZM CHCTVP
	SETZM CHCTCF
	MOVE B,NVLNS
	IDIVI B,6	;COMPUTE # ECHO LINES.
	CAIGE B,3
	 MOVEI B,3
	SKIPN RGETTY	;NO ECHO LINES ON PRINTING TTERMINALS.
	 SETZ B,
	CALL FSECL1	;AND SET THAT MANY.
	MOVEI CH,^M
	SKIPE RGETTY
	 CALL FSECO1
	RET

IFN TS,[
;REINITIALIZE TTYSTS, TTYST1, TTYST2 AND SET ECHOFL TO INDICATE
;THAT WAS DONE.
SETTTM:	.CALL RTTYS1
	.VALUE
	MOVE TT,TTYST1
	MOVE TT1,TTYST2
	ANDCM TT,[202020,,202020]	;HAVE ECHOING ON IFF
	ANDCM TT1,[202020,,202020]	;FS ECHOLINES $ IS >=0.
	SKIPL NELNS
	 IOR TT,[202020,,202020]
	SKIPL NELNS
	 IOR TT1,[202020,,200020]
	TLO Q,%TSCLE+%TSACT+%TSMOR
	.CALL STTYS1
	 .VALUE
	SETOM ECHOFL
	TLZ Q,%TSINT+%TSSAI
	MOVEM Q,TTYSTS
	RET

TTYAC2:	HRROS (P)
	CAIA
TTYAC1:	HRRZS (P)
TTYAC4:	SAVE Q
	SAVE TT
	SAVE TT1
	SAVE CH
	.CALL RTTYS1
	 .LOSE 1400
	TLZ Q,#%TSSAI
	IOR Q,TTYSTS
	SKIPGE CH,-4(P)
	 TLO Q,%TSINT
	.CALL STTYS1
	 .LOSE 1400
	REST CH
	REST TT1
	REST TT
POPQJ:	REST Q
	POPJ P,

RSSB:	SETZ
	SIXBIT /CNSGET/
	1000,,DCHN
	2000,,NVLNS
	2000,,NHLNS
	2000,,TT	;TCTYP
	2000,,TT	;TTYCOM
	402000,,TTYOPT

RTTYS1:	SETZ
	SIXBIT \TTYGET\
	1000,,TYIC
	2000,,TT
	2000,,TT1
	2000,,Q
	2000,,TTYTYP
	SETZM CH	;READ GRAPHICS VS PRINTING CODE.
STTYS1:	SETZ
	SIXBIT \TTYSET\
	1000,,TYIC
	TT
	TT1
	SETZ Q

TYI:	SKIPL CH,UNRCHC
	JRST UNRCH
	SKIPGE STOPF
	 CALL QUIT1
TYIW:	.IOT TYIC,CH
	ANDI CH,777+TOP
	CAIN CH,33	;DETECT ALTMODE-ALTMODE.
	 CAME CH,LTYICH
	  JRST TYI2
	SOSGE TSALTC	;FOUND ONE! DECREMENT COUNT OF PAIRS REMAINING TO BE READ.
	 AOS TSALTC
	HRROS LTYICH	;MAKE SURE 2ND ALTMODE OF PAIR CAN'T COUNT AS FIRST OF ANOTHER.
	CAIA
TYI2:	 MOVEM CH,LTYICH
	SKIPE DISPRR	;AVOID SCREWING UP PHASE WHEN ^R READS AN ALTMODE.
	 HRROS LTYICH
	HRLM CH,(P)
	ANDCMI CH,META+CONTRL
	CAIL CH,^H
	 CAILE CH,^J
	   CAIN CH,33
	    JRST TYI3
	CAIN CH,^M
	 JRST TYI3
	HLRZ CH,(P)
	TRNN CH,TOP+140	;TURN VT INTO ^K, CR INTO ^M, ETC.
	 IORI CH,CONTRL+100
	ANDCMI CH,TOP
	RET

TYI3:	HLRZ CH,(P)
TYI1:	CAIN CH,CONTRL+^M
	 JRST TYI4
	CAIE CH,^M	;WHEN READING A CR OR CONTROL-CR.
	 RET
TYI4:	XORI CH,^M#^J
	MOVEM CH,UNRCHC	;PUT A LF OR CONTROL-LF IN FS REREAD$.
	XORI CH,^M#^J
	RET

UNRCH:	SETOM UNRCHC
	JRST TYI1

;CONVERT CHAR. IN CH FROM TV CHAR SET TO ASCII.
TYINRM:	TRNE CH,140	;CONTROL-^-MUMBLE JUST BECOMES ^-MUMBLE.
	 TRZN CH,CONTRL
	  JRST TYINR1
	CAIE CH,META+177
	 CAIN CH,177
	  JRST TYINR1	;CONTROL-RUBOUT SHOULD BE RUBOUT, NOT "?".
	TRCE CH,100	;NOTE TV CHAR SET HAS CONTROL-LOWERCASE LETTERS!
	 ANDCMI CH,40	;THEY SHOULD CONVERT JUST LIKE CONTROL-UPPERCASE LETTERS.
TYINR1:	ANDI CH,177
	RET

;DUMPIT$G TO DO $Y<CR> THEN PURIFY, WITH THE BONUS THAT IT REFUSES
;TO WORK ON A TECO THAT HAS BEEN RUN.
DUMPIT:	SKIPE RUNFLG
	 .VALUE
	.VALUE [ASCIZ /Y
P/]

;PURIFY$G TO MAKE PURE THE PAGES THAT ARE SUPPOSED TO BE PURE.
PURIFY:	SKIPE RUNFLG
	 .VALUE
	.VALUE [ASCIZ /B P/]
	MOVEI P,PDL
	MOVE A,[PURP1-PURPL,,PURP1]
	SYSCAL CORBLK,[MOVEI %CBRED ? MOVEI %JSELF ? A]
	 .LOSE 1000
	SETOM PUREFL
	MOVE A,[.FNAM2]
	.VALUE [ASCIZ \
A/ ..UFILE+2/ 1Q
..UFILE+3/ 1'.TECO.
..UFILE+1/ 1'TECPUR
:Purified

:PDUMP\]
	JRST INIT
]


;COME HERE ON TRYING TO READ PAST THE END OF A COMMAND STRING LEVEL.
RCH2:	SAVE A		;POP OFF MACRO FRAME
	SKIPN A,MACPTR	;0 MEANS TRIED TO POP OUT OF TOP-LEVEL
	 JRST INSCHK
RCH2A:	CALL ERSTST	;REFUSE TO POP OUT OF MACRO CONTAINING UNTERMINATED "<" OR ":<".
	LDB CH,MACPDP	;TRY TO POP MACPDL ENTRY FOR THE MACRO-CALL.
	TRNE CH,10
	 JRST RCH2B	;TOP OF MACPDL ISN'T A MACRO-CALL ENTRY!
	HRRE A,(A)
	JUMPGE A,RCH2D	;ARE WE POPPING OUT OF A MACXQ (MIDAS TO TECO CALL)?
	HRRZ A,-1(P)	;YES, ONLY ALLOWED FROM COMMAND LOOP.
	CAIE A,CDRCH
	 JRST INSCHK	;INSIDE A COMMAND => ERROR.
RCH2D:	MOVE A,MACPTR
	CALL DECDCH	;IT IS ONE, RESTORE RCHALT AND SQUOTP AS IT SAYS.
	CALL POPMAC	;POP THE MACRO-STRING-FRAME.
	CALL POPMP	;ACTUALLY DEECREMENT MACPDP.
RCH2C:	REST A
	SKIPL MACPTR	;ARE WE POPPING OUT OF A MACXQ?
	 JRST RCH	;NO, TRY AGAIN, READ FROM WHAT WE POPPED INTO.
	MOVE CH,MACXP	;YES, RESTORE PDL LEVEL TO THAT AT
	POP CH,MACXP	;CALL TO MACXQ, AND PREPARE TO RETURN.
	POP CH,MACPTR
	JRST SETP1	;SET P FROM CH AND ADJUST LEV.

RCH2B:	CAIN CH,10	;A NULL ENTRY? FLUSH IT AND TRY AGAIN.
	 JRST [CALL POPMP ? JRST RCH2A]
	MOVEI CH,4	;[ ;CAN'T POP SINCE ^]^X'D INTO,
	MOVEM CH,COMCNT	;[ ;INSTEAD ^]^X UP ANOTHER LEVEL.
	MOVEM CH,COMAX
	MOVE CH,[BP,,[ASCIZ//]]
	MOVEM CH,CPTR
	SKIPGE MACPTR	;I THINK TECO LOSES IF IT USES UP
	 .VALUE		;[ ;ALL OF A MACXQ'D STRING WITH A ^]^X.
	JRST RCH2C

;THE RCHDTB ENTRY FOR THE CASE SHIFT CHAR IS <CALL RCHSFT>
RCHSFT:	SKIPN MACPTR	;IN MACRO, CASE SHIFT ISN'T SPECIAL.
RCHSF1:	SKIPE RCHSFF	;IF PREV. CHAR WAS SHIFT, THIS ONE IS QUOTED.
	 POPJ P,	;PRETEND NOT TO BE A CASE-SHIFT.
	MOVNS CASE	;ELSE ASK TO READ NEXT CHAR IN THE OTHER CASE,
	MOVE CH,-1(P)	;GET RET. ADDR OF READ RTN,
	SETOM RCHSFF	;QUOTE NEXT CHAR IF CASE-SHIFT OR LOCK.
	XCT -1(CH)	;RE-CALL THE READ RTN. (TRACES IF NEC)
	MOVNS CASE	;RESTORE CASE TO WHAT IT HAD BEEN.
	SETZM RCHSFF
POP1J:	SUB P,[1,,1]	;RETURN FROM THE CALL TO RCH
	POPJ P,		;SINCE CHAR WAS ALREADY TRACED.

RCHLOK:	SKIPN MACPTR	;RCHDTB ENTRY FOR CASE-LOCK CALLS HERE..
	SKIPE RCHSFF	;IF IN MACRO OR QUOTED BY A CASESHIFT,
	 POPJ P,	;DO NOTHING SPECIAL.
	MOVNS CASE	;ELSE SWITCH THE CASE WE WANT CHARS IN,
RCHTRY:	SUB P,[1,,1]
	REST CH
	JRST -1(CH)	;AND GO READ THE NEXT CHAR.

;FREE UP A CELL OF MACRO CALL SPACE.
;A -> 1ST WD OF CELL, MINUS 1.
FLSFRM:	SETZM MFCPTR+1(A)
	EXCH CH,MFFREE
	MOVEM CH,MFLINK+1(A)
	MOVE CH,MFFREE
	HRRZM A,MFFREE
	POPJ P,

;OBTAIN A FREE CELL OF MACRO CALL CELL SPACE.
;RETURN POINTER TO WD BEFORE 1ST WD OF CELL, IN A.
GETFRM:	SKIPG A,MFFREE
	 JRST [	CALL GCNRL	;GC, PERHAPS FREEING FRAMES USED BY BUFFERS.
		SKIPE MFFREE
		 JRST GETFRM	;ONE WAS FREED.
		TYPRE [TMN]]
	CAIGE A,MFEND
	 CAIGE A,MFFREE
	  .VALUE
	MOVE A,MFLINK+1(A)
	EXCH A,MFFREE
	POPJ P,

;OUTPUT CHARACTER IN CH WHOSE EXECUTION IS TRACED.
.SEE TRACS ;TRACS CONTAINS JRST TYOS WHEN TRACING IS ON.
;CLOBBERS NO ACS.
TYOS:	SKIPE BRC1
         RET  
	SAVE Q
	SAVE CH
	SETOM TRCOUT
	PUSHJ P,TYO
	MOVE CH,(P)
	CAIE CH,^M	;DON'T MAKE CR COME OUT AS ^M.
	PUSHJ P,DISFLS
	SETZM TRCOUT
	REST CH
	JRST POPQJ

;COME HERE IF POP OUT OF MACXQ'D OR TOP-LEVEL STRING IN THE MIDDLE OF A COMMAND.
INSCHK:	SKIPN INSINP	;IF WITHIN AN INSERT, WE COULD JUST ERR OUT
	 TYPRE [PTM]
	MOVE P,INSINP	;BUT THAT WOULD LOSE THE STUFF INSERTED SO FAR.
	SETZM INSINP	;SO TELL INSDUN TO DO THE PTM ERROR
	JRST INSDUN	;AND CAUSE INSERT TO FINISH UP.

;[ ;THE RCHDTB ENTRY FOR ^] IS <CALL CTLBRC>
CTLBRC:	JUMPL CH,TRACS
	SKIPGE SQUOTP
	 JRST TRACS
	CALL TRACS
	SETZM BRC1CF
	SETZM BRCUAV
	SETOM DLMF2
	SETZM SQUOF2
BRCREC:	SOSGE COMCNT
	TYPRE [UEC]
	ILDB CH,CPTR
	CALL TRACS
BRCRC2:	INSIRP PUSH P,A AA TT TT1 F	;F MUST BE LAST - SEE EXPMAC.
	SETZ A,
	PUSHJ P,QNMGE2
	 JRST QLET
	SKIPE BRC1
	 JRST BRCRT5
	CALL QLGET
	 JRST BRCNVL
	JRST EXPMAC
QLET:	SKIPE A
	 TYPRE [IQN]
INSIRP POP P,F TT1 TT AA A	;[
	CAIE CH,^]
	 CAIN CH,ALTMOD
	  JRST BRCPRT
	CAIN CH,"$
	 JRST RET33
	CAIN CH,^Q
	 JRST BRCCTQ
	CAIN CH,^T
	 JRST BRCCTT
	CAIN CH,^S
	 JRST BRCCTS
	CAIN CH,^A
	 JRST BRC1CH
	CAIN CH,^V
	 JRST BRCCTV
	CAIN CH,^B
	 JRST [	HRRM P,BRC1CF
		JRST BRCREC]
	SKIPE BRC1
	 JRST BRCRC3
	CAIN CH,"@
	 JRST BRCIND
	CAIN CH,^X
	 JRST BRCCTX
	CAIN CH,^Y
	 JRST BRCCTY
	TYPRE [ICB]

BRCRC3:	CAIN CH,"@
	 JRST BRCREC
	CAIE CH,^X
	 CAIN CH,^Y
	  JRST BRCRT
	TYPRE [ICB]

BRCCTS:	SETOM SQUOF2
	SETOM DLMF2
	JRST BRCREC

BRCCTT:	SETZM DLMF2
	JRST BRCREC

BRC1CH:	SETOM BRC1CF
	JRST BRCREC

BRCIND:	PUSHJ P,BRCREC
	JRST BRCRC2

BRCCTV:	SETOM BRCUAV
	JRST BRCREC

BRCNVL:	SKIPN BRCUAV
	 TYPRE [QNS]
	SETOM BRCFLG
	INSIRP POP P,F TT1 TT AA
	MOVE CH,A
	HRROM A,BRCUAV	;LEAVE UNTRUNCATED VALUE FOR QNMGET.
	ANDI CH,177
	CALL TRACS
	SKIPE SQUOF2
	 HRLI CH,-1
	JRST POPAJ

BRCCTQ:	CALL SKRCH
BRCPRT:	HRLI CH,-1	;RETURN THE CHARACTER SUPERQUOTED.
	POPJ P,

;SET SQUOTP ACC TO SQUOF2, DLMF2 AND TURN OFF RCHALT.
;ALSO SAVE OLD STATE OF THOSE VARS AS BITS IN CH FOR PUSHING ON MACPDP
FLGENC:	SETZ CH,
	SKIPE DLMF2	;SET SQUOTP ACC. TO SQUOF2, DLMF2
	 TLO CH,2^5
	SKIPE SQUOF2
	 TLO CH,4^5	;AND SET CH ACC TO PREVIOUS SQUOTP AND RCHALT
	EXCH CH,SQUOTP
	IORM CH,SQUOTP
	ROT CH,2	.SEE MACPDP	;SET UP CH AS A MACPDL ENTRY
	ADDI CH,1
	HLRZ A,RCHALT
	CAIN A,(CALL)
	 ADDI CH,4
	MOVEI A,(JFCL)	;ALSO TURN OFF RCHALT.
	HRLM A,RCHALT
	POPJ P,

DECDCH:	TRNN CH,3	
	 POPJ P,	;THIS ENTRY DIDN'T PUSH SQUOTP, RCHALT.
	SUBI CH,1
	DPB CH,[420200,,SQUOTP]
	TRNN CH,4
	SKIPA CH,[(JFCL)]
	MOVEI CH,(CALL)
	HRLM CH,RCHALT
	POPJ P,

;NOTE TOP OF PDL HAS VALUE THAT WAS IN F WHEN RCH WAS CALLED.
EXPMAC:	SKIPE BRCUAV
	 TYPRE [QNN]
	SETOM BRCFLG
	EXCH F,(P)	;SAVE F, AND GET OUR CALLER'S F.
	CALL PUSMA0	;PUSH MACRO PDL, RELOCATING F IF BUFFERS MOVE.
	EXCH F,(P)	;GIVE CALLER'S F BACK TO HIM, RELOCATED IF NEC.
	SKIPE BRC1CF
	 MOVEI TT,1
	MOVEM F,CPTR
	SKIPLE BRC1CF
	 JRST EXPMAQ
EXPMA1:	SKIPE BRC1CF	;IF WANT WHOLE QREG,
	CAMLE TT,AA	;OR IF WANT MORE CHARS THAN QREG HAS,
	 MOVE TT,AA	;USE QREG LENGTH RATHER THAN DESIRED # CHARS.
	MOVEM TT,COMCNT
	MOVEM TT,COMAX
	MOVE AA,PF
	MOVEM AA,MACSPF
	SETZM MACBTS	;[ ;THERE ARE NO ARGS IN A ^] CALL.
	SETZ CH,	;IF NOT SETTING ANY FLAGS, PUSH 0 ON MACPDL.
	SKIPN SQUOF2
	SKIPE DLMF2
	 CALL FLGENC	;ELSE COMPUTE WHAT TO PUSH.
	IDPB CH,MACPDP
BRCRT5:	INSIRP POP P,F TT1 TT AA
BRCRT4:	REST A
BRCRT:	REST CH
	JRST -1(CH)	;RETRY THE RCH.

RET33:	MOVEI CH,ALTMOD
	POPJ P,

EXPMAQ:	ILDB CH,F	;SUBSTITUTING QREG NAME FROM QREG; SEE HOW MANY CHARS
	CAIN CH,".	;THERE ARE TO BE SUBSTITUTED (ALL UP TO 1ST NON-".").
	 AOJA TT,EXPMAQ
	JRST EXPMA1

BRCCTX:	SKIPE BRC1CF
	 JRST BRCCTY
	SETOM BRCFLG
	PUSH P,A
	HRRZ A,-2(P)
	CAIE A,BCYRCH+1
	 JRST BRCCX2
	HRLZI A,(JFCL)
	HLLM A,RCHALT
	PUSHJ P,BRCCTY
	POP P,RCHALT
	CAIN CH,ALTMOD
	 JRST BRCRT4
	MOVE A,CPTR
	PUSH P,CH
BRCCX1:	DBP7 A
	AOS COMCNT
	LDB CH,A	;[
	CAIE CH,^]
	 JRST BRCCX1
	DBP7 A
	AOS COMCNT
	MOVEM A,CPTR
	POP P,CH
	JRST POPAJ

BRCCX2:	PUSHJ P,PUSCX0
	SKNTOP MACPTR
	 TYPRE [NIM]
	PUSHJ P,POPMAC
	CALL FLGENC	;SET SQUOTP, GET OLD STATE IN CH.
	ADDI CH,10	;[ ;INDICATE PUSHED BY ^]^X, NOT MACRO CALL.
	IDPB CH,MACPDP
	MOVEI A,(CALL)
	HRLM A,RCHALT	;[ ;START LOOKING FOR AN $ TO END ^]^X.
	SKIPGE MACPTR	;[ ;TRYING TO ^]^X OUT OF A MACXQ => PHONY UP NULL ARG.
	 CALL ENDAR2
	JRST BRCRT4

ENDARG:	MOVEM A,(P)
	CALL ENDAR2
	JRST BRCRT4

ENDAR2:	CALL ERSTST
	LDB CH,MACPDP
	TRNN CH,10
	 JRST ENDAR1	;[ ;POPPING ^]^X BUT MACPDP SAYS MACRO CALL.
	CAIN CH,10	;NULL ENTRY ON MACPDP? FLUSH IT.
	 JRST [CALL POPMP ? JRST ENDAR2]
ENDAR5:	CALL DECDCH	;[ ;A ^]^X ENTRY, UNBIND SQUOTP AND RCHALT.
	CALL POPMP	;AND REMOVE THE ENTRY FROM THE STACK.
	JRST ENDAR4

ENDAR1:	SAVE MACPDP
ENDAR3:	CALL POPMP
	CALL ERSTST
	LDB CH,MACPDP	;[ ;LOOK DOWN MACPDP FOR A ^]^X ENTRY.
	CAIG CH,10
	 JRST ENDAR3	;THE ENTRIES ABOVE MUST BE 0 OR 10 .
	CALL DECDCH	;FOUND THE ENTRY, RESTORE SQUOTP.
	MOVEI CH,10	;REPLACE THE ENTRY WITH A NULL.
	DPB CH,MACPDP
	REST MACPDP
ENDAR4:	CALL PUSMA0
	JRST POPCTX

BRCCTY:	SETOM BRCFLG
	PUSH P,A	;HANDLE ^Y OR ^F^X.
	PUSHJ P,PUSCX0
	SKNTOP MACPTR
	TYPRE [NIM]
	PUSHJ P,POPMAC
	CALL FLGENC
	ADDI CH,10
	IDPB CH,MACPDP
	SKIPGE MACPTR	;IF OUR CALLER WAS MACHINE-LANGUAGE TECO,
	 SKIPA CH,[ALTMOD]	;DON'T TRY TO POP INTO IT; PHONY UP AN ALTMODE.
BCYRCH:	PUSHJ P,RCH
	SKIPGE SQUOTP
	 HRLI CH,-1
	SAVE CH
	CALL ENDAR2
	REST CH
	REST A
	RET

PUSMA0:	SKIPE INSBP	;SHOULD F BE RELOCATED?
	 JRST PUSMAC
	EXCH F,INSBP	;YES; PUT IT WHERE GC LOOKS.
	CALL PUSMAC
	EXCH F,INSBP
	RET
	
PUSMAC:	PUSHJ P,GETFRM
IRP ...,,[COMAX,CPTR,COMCNT,MARG1,MARG2,MACSPF,MACPTR]
	PUSH A,...
TERMIN	MOVEM A,MACPTR
	HLL A,MACBTS
	HLLM A,(A)
	POPJ P,

POPMAC:	SKNTOP MACPTR
	TYPRE [PTM]
POPMA1:IRP ...,,[MACPTR,MACSPF,MARG2,MARG1,COMCNT,CPTR,COMAX]
	POP A,...
TERMIN
	CALL FLSFRM
	MOVE A,MACPTR
	HRLS MACPTR
	HLLZM A,MACBTS
	RET

PUSCX0:	SKIPE INSBP	;SHOULD F BE RELOCATED?
	 JRST PUSCTX
	EXCH F,INSBP	;YES; PUT IT WHERE GC LOOKS.
	CALL PUSCTX
	EXCH F,INSBP
	RET

PUSCTX:	PUSHJ P,GETFRM
IRP ...,,[COMAX,CPTR,COMCNT,MARG1,MARG2,MACSPF,CTXPTR]
	PUSH A,...
TERMIN	MOVEM A,CTXPTR
	HLL A,MACBTS
	HLLM A,(A)
	POPJ P,

POPCTX:	SKNTOP CTXPTR
	 JRST [.VALUE ? JRST GO]
IRP ...,,[CTXPTR,MACSPF,MARG2,MARG1,COMCNT,CPTR,COMAX]
	POP A,...
TERMIN
	CALL FLSFRM
	MOVE A,CTXPTR
	HRLS CTXPTR
	HLLZM A,MACBTS
	RET

;DECREMENT MACPDP.
POPMP:	MOVE CH,MACPDP
	ADD CH,[40000,,]
	JUMPGE CH,POPMP1
	CAML CH,[440000,,]
	 SUB CH,[440000,,1]
POPMP1:	MOVEM CH,MACPDP
	POPJ P,

;IF ABOUT TO POP MACPDP, MAKE SURE NOT POPPING
;OUT OF A LEVEL CONTAINING AN UNTERMINATED ERRSET OR ITERATION.
ERSTST:	HRRZ CH,ITRPTR	;ADDR OF BLOCK FOR INNERMOST ERRSET OR ITERATION.
	JUMPE CH,CPOPJ	;THERE IS NONE IN PROGRESS.
	MOVE CH,MFMACP-MFBLEN+1(CH)	;GET THE MACPDP VALUE AT TIME IT WAS ENTERED.
	CAME CH,MACPDP	;ARE WE POPPING THAT LEVEL?
	 RET
	TSC CH,ITRPTR	;YES. WHICH IS IT - AN ERRSET OR AN ITERATION?
	TRNN CH,-1
	 TYPRE [ERP]	;AN ERRSET.
	TYPRE [UTI]	;AN ITERATION.

;COME HERE ON INITIALIZATION, QUIT, AND ^W COMMAND.
CTLW:	SETOM GOXFLS	;POP TO TOP LEVEL; DON'T INVOKE ERROR HANDLER OR MAKE BREAK LOOP

;COME HERE ON ERROR.
;IMQUIT IS POSITIVE IF WE QUIT OUT OF LIS (TECO COMMAND READER). IT MEANS DON'T
  ;WE SHOULD STAY IN THE COMMAND LEVEL THAT WAS CALLING LIS.
;OTHERWISE, IF $QERRH (Q..P) IS NONZERO, IT IS THE ERROR HANDLER MACRO TO CALL.
;OTHERWISE, IF UNWINF (FS*RSET$) IS NONZERO, CREATE A BREAK LOOP.
GOX1:	SKIPN CH,LEV	;COMPUTE THE PDL LEVEL AT THE INNERMOST
	 MOVE CH,[-LPDL,,PDL-1]
	SKIPN Q,MACXP	;INVOCATION OF THE COMMAND LOOP OR ^R.
	 MOVE Q,[-LPDL,,PDL-1]
	CAMGE CH,Q	;NAMELY, MUST BE INSIDE ALL OPEN-PARENS,
	 MOVE CH,Q	;INSIDE ALL MACXQ'S, ABOVE BOTTOM OF STACK,
	SKIPN Q,DISPRR	;AND ABOVE DISPRR.
	 MOVE Q,[-LPDL,,PDL-1]
	CAMGE CH,Q
	 MOVE CH,Q
	SKIPGE GOXFLS	;MAYBE WE HAVE BEEN RQ'D TO POP ALL THE WAY TO TOP.
	 MOVE CH,[-LPDL,,PDL-1]
	CAME P,CH	;MUSTN'T PUSHJ CH, IF CH=P, SINCE RET. ADDR WOULD BE UNPROTECTED
	 PUSHJ CH,SETP	;SET P FROM CH, UNWINDING SOME STUFF; THEN POPJ P,
	SKIPL TYOFLG		;IF TYPEOUT IN PROGRESS, FORCE IT OUT.
	 CALL DISFLS
	MOVE B,IMQUIT
	SETZM IMQUIT
	MOVE TT,BEG
	SKIPN C,RREBEG	;MUSTN'T RUN OUTSIDE ^R WITH RREBEG ZERO.
	 MOVEM TT,RREBEG
	SKIPE CPTR
	 CALL ERRP2		;MARK THE CURRENT PC FOR "?" TO DISPLAY.
	SKIPN ERRFLG
	 SETZM LASTER		;IF NO ERROR, MAKE SURE FS ERROR IS 0.
	SETZM ERRFLG		;ERROR PROCESSING NOW FINISHED.
	SETZM ERRFL1		;AS YET, NO ERROR MESSAGE PRINTED (THOUGH MAY CHANGE)
	SKIPN GOXFLS	;IF WE'RE POPPING TO TOP, DON'T PUSH NOW.
	 SKIPLE B	;IF THIS IS TECO STARTUP, OR QUIT OUT OF COMMAND READER,
	  JRST GOX4	;THERE'S REALLY NOTHING TO PUSH NOW.
	SKIPN UNWINF	;ENTER BREAK LOOP?
	 SKIPE $QERRH	;OR HAVE AN ERROR HANDLER?
	  CAIA
	   JRST GOX4	;NEITHER; NO NEED TO PUSH.
	JUMPN C,GOX5	;IF ERROR OCCURRED ACTUALLY INSIDE ^R (NOT WITHIN A MACRO)
	SAVE [	MOVE P,DISPRR
		REST A
		JRST RRLP]	;THEN SIMULATE A MACXQ CALL WHICH, WHEN RETURNED FROM, WILL
	SAVE MACPTR		;RETURN TO ^R.
	SAVE MACXP
	SETOM MACPTR
	MOVEM P,MACXP
GOX5:	JSP T,OPEN1	;NOW PUSH VALUES
	CALL PUSMAC	;AND THE CURRENT MACRO (THAT ERRED).
	CALL FLGENC	;ENCODE AND SAVE SQUOTP AND RCHALT
	IDPB CH,MACPDP
	SETZM SQUOTP
	CALL GOCPY	;IF CBUF IS ON MACRO PDL, COPY IT TO A STRING
			 ;SINCE CBUF IS LIKELY TO BE OVERWRITTEN NOW.
	SKIPE A,$QERRH	;IF THE USER HAS AN ERROR HANDLER, GO TO IT.
	 JRST GOX3
GOX4:	TRO FF,ARG\COLONF\SLSL
	SKIPGE GOXFLS	;GOXFLS AND ERRFLG IMPLY THIS IS "ERROR ENTERING ERROR HANDLER"
	 TRZ FF,COLONF	;SO DON'T OVERWRITE THAT LINE WITH THE ERROR MSG.
	SKIPE B,LASTER	;NO USER ERROR-HANDLER, SO IF RESPONDING TO AN ERROR,
	 CALL FGCMD	;PRINT STANDARD ERROR MESSAGE, FLUSH TYPEAHEAD, AND TYPE A BELL.
	SETOM TYOFLG	;FORCE TYPEOUT TO RE-INIT.
	SKIPN RGETTY
	 CALL CRR
	SKIPN UNWINF	;NOW NORMALLY ENTER A COMMAND LOOP, BUT
	 SKIPN A,DISPRR
	  JRST GO
	SKIPE MACXP
	 CAML A,MACXP	;IF DON'T WANT A BREAK LOOP AND INSIDE A ^R, RETURN TO THAT ^R.
	  JRST [SETZM RREBEG
		JRST RRTHRW]	;HOW TO DO IT DEPENDS ON WHETHER WE CALLED ANY MACROS FROM IT.
	JRST FSCRTH

GOX3:	TRO FF,COLONF	;WE ALREADY PUSHED THE ERRING MACRO; NO NEED TO PUSH AGAIN.
	JRST MAC5	;NOW RUN THE ERROR HANDLER.

;ALTMODE AS COMMAND.
ALTCMD:	SKIPGE NOOPAL	;FS NOOPALT NEGATIVE => IGNORE ALTMODE.
	 JRST CD5
	SKIPN NOOPAL	;POSITIVE => ALTMODE IS LIKE ^_.
	 TYPRE [ALT]	;ERROR IN MACROS, IGNORE AT TOP LEVEL.
LGOGO:
IFN TS,[		;COME HERE WHEN EXECUTE ^_, PERHAPS ALTMODE.
	CALL FLSOUT	;EMPTY OUTPUT BUFFER INTO OUTPUT FILE.
	.SUSET [.RJNAM,,A]
	CAME A,['HACTRN]
	 .LOGOUT
	AOSN CTLCF	;IF READ ^C,
	 CALL FSEXI1	;RETURN TO DDT.
]
	HRRZM P,ERRFL1
GO:	MOVE A,GOXFLS	;IF WE'RE REQUESTED TO POP ALL THE WAY
	SETZM GOXFLS
	SKIPE UNWINF	;OR NOT IN *RSET MODE,
	 JUMPGE A,GO2
	MOVE CH,[-LPDL,,PDL-1]
	CAME CH,P
	 PUSHJ CH,SETP	;SET P FROM CH, UNWINDING OUT OF ^R OR SORT OR PARENS.
	SETZM MACXP
	SETZM NOQUIT
	SETZM MACPTR
	SETZM CTXPTR
	SETZM ITRPTR
	MOVE A,[400,,MACPDL-1]
	MOVEM A,MACPDP
	MOVEI A,MFFREE	;NOW PUT ALL CELLS ON THE FREE LIST.
	SETZM MFFREE
GO1:	SKIPL MFBEG+1(A) .SEE MFBFR	;FREE ALL MACRO FRAMES, EXCEPT THOSE OF BUFFERS.
	 CALL FLSFRM	;FREE IT.
	ADDI A,MFBLEN
	CAIGE A,MFEND-1
	 JRST GO1
	MOVE B,PFINI	;UNWIND QREG PDL.
	CALL FSQPU0
GO2:	MOVEI A,(JFCL)
	HRLM A,RCHALT
	SETZM SQUOTP
	SETZM MACBTS	;THERE ARE NO MACRO ARGS IN TOP-LEVEL CMD STRING.
	CALL FLSCM1	;FLUSH SOME CORE, AND FORCE OUT OUTPUT BUFFER.
	SKIPL TYOFLG	;FORCE ALL TYPEOUT TO BE PRINTED.
	 CALL DISFLS
	SETZM IMQUIT
	SKIPN ECHOFL
	 CALL SETTTM	;TURN ECHOING BACK ON IF NECESSARY.
	SKIPE MORFLF	;IF PREVIOUS COMMAND FLUSHED,
	 SETOM TYOFLG	;NEXT TYPEOUT WILL REINIT AND UN-FLUSH.
	MOVE B,QRB..
	MOVE B,.QPT1(B)	;GET WHAT . WAS WHEN LAST CMD STRING STARTED.
	CALL FSPSPT	;PUSH ON . RING BUFFER.
	MOVE CH,QRB..	;MACRO ..L IF THAT'S APPROPRIATE.
	MOVE A,.QRSTR(CH)
	AOSN INITF1
	 JUMPN A,GOXX
	CALL VIEW2	;NOW GO TRY TO DISPLAY DIR. OR BUFFER.
	JRST LIS

GOXX:	CALL MACXQ
	JRST GO

;FIND THE MACRO FRAME THAT IS EXECUTING OUT OF CBUF, COPY THE CONTENTS
;OF CBUF INTO A STRING, AND MAKE THE MACRO FRAME POINT TO THAT STRING INSTEAD.
;THE GOAL IS TO FREE UP CBUF FOR RE-USE WHEN COMMAND READER IS ENTERED
;IN A BREAK LOOP.
;DOESN'T PROMISE TO RPESERVE ANY ACS.
GOCPY:	MOVEI A,MFSTRT
GOCPY1:	SKIPGE MFBEG(A)	.SEE MFBFR	;DONT CONSIDER BUFFER FRAMES.
	 JRST GOCPY2
	HRRZ B,MFCPTR(A)	;WHERE DOES B.P. OF MACRO FRAME POINT?
	JUMPE B,GOCPY2		;IGNORE FREE CELLS; THERE MAY BE SOME -> CBUF.
	CAIL B,@CBUFLO
	 CAIL B,@CBUFH
	  JRST GOCPY2
	JRST GOCPY3		;CPTR OF THIS FRAME POINTS WITHIN CBUF!

GOCPY2:	ADDI A,MFBLEN
	CAIGE A,MFEND		;SCAN ALL FRAMES.
	 JRST GOCPY1
	RET			;NO FRAME POINTS IN CBUF - NO COPYING NEED BE DONE.

GOCPY3:	HRRZ C,MFCMAX(A)	;HOW LONG IS USED PART OF CBUF?
	MOVEI B,4(C)		;GET THAT MUCH SPACE, PLUS SOME FOR STRING HEADER
	CALL SLPQGT
	MOVEI AA,QRSTR
	MOVEI B,4(C)
	CALL QHDRW1		;WRITE HEADER OF STRING; B.P. RETURNED IN F TO IDPB TEXT.
	MOVE B,C
	MOVE IN,CBUFLO		;AND GET B.P. TO ILDB TEXT TO COPY.
GOCPY4:	ILDB CH,IN
	IDPB CH,F
	SOJG B,GOCPY4
	MOVEI F,4(C)
	ADDB F,QRWRT		;CLOSE THE FINISHED STRING; ET CHAR ADDR 1 + LAST CHAR.
	SUB F,MFCCNT(A)		;GET NEW CHAR ADDR OF CHAR CPTR SHOULD ILDB NEXT
	CALL GETIBP		;AND SET UP CPTR -> SAME CHARACTER IN ITS NEW HOME.
	MOVEM F,MFCPTR(A)
	RET

;F? COMMAND - MBOX CONTROL.
;ARGUMENT IS BIT-DECODED. NO ARG, OR ARG=0, IMPLIES ARG=30 .
;BIT 1.1 - CLOSE GAP. MAY BE NEEDED FOR COMMUNICATION WITH OTHER PROGRAMS
;		THAT DON'T UNDERSTAND THE GAP.
;BIT 1.2 - GC STRING SPACE. USEFUL BEFORE DUMPING OUT OR IF IT IS SUSPECTED
;		MANY STRINGS HAVE RECENTLY BEEN DISCARDED.
;BIT 1.3 - SWEEP THE JUMP CACHE. NECESSARY IF A STRING'S CONTENTS HAVE BEEN
;		ALTERED BY THE F^E COMMAND, AND IT IS A MACRO THAT MIGHT
;		HAVE CONTAINED "O" COMMANDS.
;BIT 1.4 - FLUSH UNOCCUPIED CORE. GOOD TO DO EVERY SO OFTEN, OR IF IT IS
;		LIKELY THE BUFFER HAS JUST SHRUNK.
;BIT 1.5 - CLOSE THE GAP, IF IT IS > 5000 CHARACTERS. GOOD TO DO EVERY SO
;		OFTEN, IN CASE USER DELETES LARGE AMOUNTS OF TEXT; SAY,
;		WHENEVER EXCESS CORE IS FLUSHED.
FLSCMD:	SKIPE B
	 TRNN FF,ARG	;NO ARG SAME AS ARG OF 30.
FLSCM1:	  MOVEI B,30
	HRLM B,(P)
	CALL FLSOUT	;FIRST, FORCE OUT OUTPOUT BUFFER.
	HLRZ B,(P)
	MOVE A,EXTRAC
	TRNE B,20
	CAIG A,5000	;"20" BIT MEANS CLOSE GAP IF VERY LARGE.
	 TRNE B,1	;"1" BIT MEANS CLOSE GAP IN ANY CASE.
	  CALL SLPSHT
	TRNE B,2	;IF "2" BIT IS SET IN ARG, DO A GC,
	 JRST GCC	;THAT INCLUDES FLUSHING CORE AND SWEEPING CACHE.
	TRNN B,4	;"4" BIT MEANS SWEEP JUMP CACHE.
	 JRST FLSCM2
	CLEARM SYMS
	MOVE T,[SYMS,,SYMS+1]
	BLT T,SYMEND-1
FLSCM2:	TRNN B,10	;"10" BIT MEANS FLUSH UNUSED CORE.
	 RET
FLSCOR:
IFN TS,[MOVE A,BFRTOP	;OTHERWISE JUST FLUSH CORE.
	CAMN A,BFRBOT	;DON'T FLUSH ALL PAGES, ELSE THE
	 ADDI A,1	;GAP BETWEEN QREGS AND BUFFER WOULD FILL UP.
	ADDI A,2000*5-1
	IDIVI A,5*2000	;A_ # PAGES WE'RE REALLY USING.
	MOVE B,MEMT
	LSH B,-10.	;B_ # OF LAST PAGE WE HAVE.
	SUBM A,B	;B HAS -<# PAGES TO FLUSH>
	JUMPE B,CPOPJ
	MOVE D,A
	HRLM B,A	;A HAS AOBJN -> PAGES TO BE FLUSHED.
	SKIPGE A	;WE'RE TRYING TO CORE UP???
	 SYSCAL CORBLK,[MOVEI 0 ? MOVEI -1 ? MOVE A]
	  .VALUE
	LSH D,10.	;D GETS 1ST WD ABOVE NEW HIGHEST PAGE
	MOVEM D,MEMT
]
	RET

LISCRF:	IFN TS,.IOT ECHOC,[^M]
LIS:	HRRZM P,IMQUIT	;^G DURING TYPEIN QUITS IMMEDIATELY.
	SETZM NOQUIT
	SKIPGE STOPF	;PERFORM ANY PENDING QUIT.
	 CALL QUIT0
	SKIPN ECHOFL
	 CALL SETTTM	;MAKE SURE ECHOING IS ON.
	SETZM RCHSFF
	.I CASE=CASNRM	;REINIT THE INPUT CASE.
	TTYACT		;TO SET "ACTIVATE ON NEXT CHAR REGARDLESS" AGAIN
	CALL VBDACU
	 JFCL
	SETZM CTLBRF
	MOVE B,QRB..
	SETZM .QVWFL(B)
	MOVE AA,CBUFLO	;BP TO BEFORE CMD BUFF.
	MOVE TT,COMAX	;WAS THE PREVIOUS CMD STRING A LONG ONE?
	CAIGE TT,10.
	 JRST LISSRT	;NO, IT WAS SHORT.
	MOVEM TT,SAVCMX	;YES, THIS IS CMD STRING FOR ^Y TO INSERT.
	MOVEI TT,SAVCW1-1 ;SO SAVE INFO ON IT SO SHORT CMDS
	PUSH TT,1(AA)	;WON'T CLOBBER THE BEGINNING OF IT.
	PUSH TT,2(AA)
	PUSH TT,3(AA)
	.I SAVCPT=CPTR
LISSRT:	SETZM COMAX	;COMAX COUNTS CHARS IN CMD STRING BEING READ IN
	SETZM COMCNT
	MOVEM AA,CPTR	;INIT CPTR FOR EXECUTION OF THE CMD STRING
	MOVE B,CBUFH
IFN TS,[		;HANDLE ":TECO FOO BAR" FROM DDT
	SKIPGE CMFLFL	;READING FROM INIT FILE => GO YANK AND XCT IT.
	 JRST LISINI
;	SKIPGE CMDDDT	;IF JUST STARTED FOR FIRST TIME & NO INIT FILE,
;	 JRST LISDDT	;GO PROCESS DDT'S JCL COMMAND.
]
LI1:	;	SETZM CMDDDT
	SKIPE RGETTY	;IF NO DISPLAY,
	 JRST LILUP
	SKIPE CH,PROMCH	;PROMPT UNLESS PROMPTING DISABLED.
	 CALL TYANOW
;FALLS THROUGH TO READ THE FIRST CHARACTER.

;FALLS THROUGH.
;LOOP AFTER HANDLING A CHAR OTHER THAN ALTMODE.
LILUP:	TRZ FF,ALTF	;SAY THE PRECEDING CHAR WASN'T ALTMODE.
LI2:	CAILE B,(AA)	;LOOP BACK HERE AFTER ALTMODE, WITH ALTF SET.
	 JRST LI3
	ADDI B,100	;IF WE'VE FILLED THE COMMAND BUFFER,
	SAVE B
	MOVEI B,500	;MAKE SURE WHEN QREG SPACE IS MOVED UP
	CALL SLPQGT	;IT WON'T REACH THE BUFFER.
	REST B
	MOVE C,QRWRT	;LAST WD TO MOVE UP IS LAST IN QREG SPACE.
	IDIVI C,5
	MOVE D,QRBUF
	IDIVI D,5
	SUBM C,D
	MOVE CH,(C)
	MOVEM CH,100(C)
	SOS C
	SOJGE D,.-3
	MOVEI T,500
	ADDM T,QRBUF
	ADDM T,QRWRT
LI3:	MOVEM B,CBUFH
IFN TS,	SETZM CTLCF
	CALL TYI
	CALL TYINRM
IFN TS,[
	SKIPL CTLBRF	;[ ;LET ^]^Q QUOTE A ^C
	 CAIE CH,^C
	  JRST LI3Z
	SETOM CTLCF	;BACK TO DDT IF FINISH OK.
	JRST LISEOF	;TERMINATE COMMAND STRING

LI3Z:	]
	CAME AA,CBUFLO	;IF THIS IS 1ST CHAR, SOME CHARS ARE SPECIAL.
	 JRST LI3D1	;NO, NORMAL.
	JRST LISFST

;COME HERE AFTER READING A CHAR, WHEN THE CMD BUFFER IS EMPTY.
LISFST:
IFN TS,[IFN RMSSW,[CAIN CH,^R
		   JRST RRIMMD]
  	CAIN CH,^T
	JRST EDIT
]
	CAIN CH,^U	;^U => DISPLAY FILE DIR USING USER'S MACRO.
	 JRST [	MOVE CH,QRB..
		SETZM .QVWFL(CH)
		TLO FF,CTLUF
		SETZM IMQUIT
		JRST GO]
	CAIN CH,^V
	 JRST [ MOVE CH,QRB..
		SETZM .QVWFL(CH)	;ALLOW BUFFER DISPLAY.
		CALL POPPT		;POP . RING BUFFER.
		 JFCL
		MOVE CH,QRB..
		MOVEM A,.QPT1(CH)	;PREVENT AUTOMATIC RE-PUSH.
		JRST GO]
	CAIN CH,^X
	 SKIPN LASTER
	  CAIA
	   JRST [CALL FECMD8 ? JRST GO]
	CAIN CH,^Y
	 JRST LISCY
	TRNN FF,QMFLG
	 JRST LI3D1
	CAIN CH,"?
	 JRST ERRTYP
LI3D1:	PUSHJ P,CKCH
	 JRST LISCRF	;RUBOUT ON AN EMPTY BUFFER.
	 JRST [SETZM CTLBRF ? JRST LILUP]	;A CHAR WAS RUBBED.
LISTOR:	AOS COMAX
	IDPB CH,AA
	AOSE CTLBRF	;[[ ;WAS THIS CHAR PRECEDED BY ^] OR ^]^Q?
	 JRST LISBR1	 ;NO.
	CAIN CH,^Q	;YES, ^Q=> NEXT CHAR ALSO QUOTED.
LISBRC:	 SETOM CTLBRF
	JRST LILUP	;[ ;QUOTED ^] AND ALTMODE AREN'T SPECIAL.

		;[[ BRACKETS MUST BALANCE FOR CONDITIONALS.
LISBR1:	CAIN CH,^]	;NOT QUOTED, ^] QUOTES NEXT CHAR.
	 JRST LISBRC
	CAIE CH,ALTMOD	;ALTMODE => CHECK FOR ALT-ALT, MAYBE END STRING.
	 JRST LILUP
	TRON FF,ALTF	;SAY JUST SAW AN ALTMODE,
	 JRST LI2
	JRST LISDUN	;PREV. CHAR ALSO ALTMODE => END STRING.

CKCH:	CAIE CH,177
	JRST POPJ2	;OK CHAR - RETURN, SKIPPING TWO
	CAMN AA,CBUFLO
	POPJ P,		;RUBBED TO BEGINNING - NO SKIP
	LDB CH,AA
	PUSHJ P,FSECO1
	DBP7 AA
	SOS COMAX
	JRST POPJ1	;RUBBED ONE CHAR -  RETURN, SKIPPING ONE

;COME HERE ON ^C ON TTY.
LISEOF:	MOVEI CH,ALTMOD	;DUMMY UP TWO ALTMODES.
	IDPB CH,AA
	AOS COMAX
	IDPB CH,AA
	AOS COMAX

;COME HERE AFTER HANDLING AND STORING ALTMODE-ALTMODE
LISDUN:	MOVEI CH,^_	;^_ TO STOP EXECUTION OF CMD STRING.
	IDPB CH,AA
	AOS TT,COMAX
	MOVEM TT,COMCNT

;INITIALIZE RANDOM STUFF FOR ANOTHER CMD STRING.
	SETZM IMQUIT
	SETZM ERRFLG	;DON'T IGNORE 1ST LINE OF NEXT V-COMMAND.
IFN TS,[
	SKIPN RGETTY
]
	PUSHJ P,CRR
	TRZ FF,#TRACEF
	MOVE A,PT	;Q..I _ . .
	SUB A,BEG
	MOVE CH,QRB..
	SETZM .QVWFL(CH)	;ALLOW BUFFER DISPLAY.
	MOVEM A,.QPT1(CH)	;PUT . INTO Q..I.
	JRST CD

POPJ2:	AOS (P)
CPOPJ1: POPJ1:
	AOS (P)
	POPJ P,

LISINI:	CALL RRED1	;INIT FILE OPEN ON UTYIC; PREPARE TO YANK IT.
	MOVE CH,QRB..
	SETZM .QVWFL(CH)	;ALLOW A BUFFER DISPLAY TO SHOW RESULTS.
	MOVEI A,[ASCIZ /^ YJI0UA HFXA :MA/]
	SETZM CMFLFL	;COMMAND FILE HAS BEEN HANDLED (ALMOST)
	SETZM IMQUIT
	CALL MACXCW	;XCT THAT STRING, TO YANK AND XCT THE INIT FILE.
	JRST GO

;CONTROL-Y WAS 1ST CHAR TYPED --
; INSERT LAST COMMAND STRING INTO BUFFER, THEN REDISPLAY.
LISCY:	MOVE CH,QRB..
	SETZM .QVWFL(CH)	;ALLOW A BUFFER DISPLAY TO SHOW RESULTS OF ^Y.
	SETOM SQUOTP	;[ ;DON'T LET ^] EXPAND WHEN WE REREAD CMD STRING.
	SETOM BRC1
	.I COMAX=COMCNT=SAVCMX
	HRROI TT,SAVCW3	;RESTORE THE LAST LONG (>7 CHARS) CMD STRING
	POP TT,3(AA)	;.I <3RD WD OF CMD BUFFER>=SAVCW3
	POP TT,2(AA)
	POP TT,1(AA)
	MOVE AA,SAVCPT
	SETO OUT,

LISCY1:	CALL SKRCH	;READ CHAR FROM CMD STRING, DON'T TRACE.
	MOVE B,COMCNT	;IF WE'VE REACHED THE $$^_ AT THE END,
	CAIGE B,3	;DON'T PUT THE $ IN THE BUFFER.
	 JRST [JUMPL OUT,GO	;IF CMD STRING WASN'T ALL READ,
		MOVEM OUT,PT	;PUT PT AFTER LAST CHAR THAT WAS.
		JRST GO]
	CALL TYOMGS	;INSERT NEXT CHAR OF CMD STRING INTO BUFFER.
	CAMN AA,CPTR	;THE PTR SHOULD END UP AT THE POINT
	 MOVE OUT,PT	;COMMAND STRING READING STOPPED.
	JRST LISCY1

;? WAS 1ST CHAR TYPED AFTER ERR MSG, RETYPE LAST FEW CHARS.
ERRTYP:	HRRZM P,ERRFL1	;DON'T LET ERRFL1 PREVENT OUR TYPEOUT FROM APPEARING.
	MOVE AA,ERR2
	MOVEI B,8*5
	SUBI AA,8
	ILDB CH,AA
	CAMG B,ERR1
	PUSHJ P,TYO
	CAME AA,ERR2
	SOJA B,.-4
	JRST GO

;GET LENGTH CODE OF CHAR IN CH INTO A.
;SKIP IF NOT A CTL CHAR. NOTE THAT CALLING DISAD6 MAY BE
;EQUIVALENT TO DOING  CALL .+1  .
DEFINE	RRCHRG
	SKIPE CASDIS	;IN -1F$ MODE, HANDLE SLASHIFICATION.
	 CALL DISAD6
	MOVEI A,(CH)
	IDIVI A,6
	LDB A,RRCHBP(AA)
	CAIN CH,177	;RUBOUT PRINTS AS ^?, SO TREAT IT AS
	 SKIPA A,[6]	;2-POSITION CTL CHAR.
	CAIGE CH,40
TERMIN

;ENTRY FOR ^R 1ST CHAR TYPED IN CMD STRING.
RRIMMD:	SAVE [GO]
	MOVE TT,QRB..
	SETZM .QVWFL(TT)	;ALLOW A BUFFER DISPLAY TO SHOW RESULTS OF ^Y.
	SETZM IMQUIT

;^R EXECUTED AS A COMMAND.
RRENTR:	.I CASE=CASNRM
	TROA FF,NOTF	;SAY INPUT IS ACCEPTIBLE.
;"^ V" COMMAND WITHIN A MACRO CALLED FROM ^R MODE COMES HERE.
RRNOIN:	ANDCMI FF,NOTF	;ENTRY TO DISPLAY ONCE AND RETURN, PROCESSING NO INPUT.
	CALL RREARG	;PROCESS ARGS IF ANY, DECIDE WHAT REDISPLAY NEEDED.
		;ALSO MAKE SURE RRHPOS AND RRVPOS ARE REASONABLE.
	LDB A,[.BP NOTF,FF]
	SAVE A		;REMEMBER WHETHER THIS IS ^R OR ^ V, FOR RREAR0.
	SAVE PF
	SAVE DISPRR
	CALL [MOVEM P,DISPRR	;SET UP PDL RESTORATION POINT
		RET]		;FOR ERRORS CAUGHT BY ^R.
	TRNN FF,NOTF		;IF ^R (NOT ^ V) THEN CALL FS ^R ENTER$.
	 JRST RRNOI2
	SKIPE A,RRENTM
	 CALL RRMACR
RRNOI2::
;DROPS THROUGH.

;DROPS THROUGH.

;MAIN LOOP OF RR EDIT: ROUTINES DISPATCHED TO WILL POPJ TO HERE.
RRLP:	CALL RRARGF	;NORMALLY, FLUSH NUMERIC ARG ONCE USED.
	SETZM STOPF
	SKIPLE RRMCCT	;IF FS ^RMDLY ISN'T 0,
	TRNN FF,NOTF	;AND THIS IS ^R AS OPPOSED TO ^V
	 JRST RRLP6
	MOVE CH,QRB..
	SKIPE A,.QCRMC(CH)	;IF THERE'S A SECRETARY MACRO,
	SOSLE RRMCC1	;AND IT'S TIME TO INVOKE IT,
	 JRST RRLP6
	CALL RRMACR	;DO SO.
	MOVE A,RRMCCT	;AND REINIT # CHARS TO EXECUTE BEFORE
	MOVEM A,RRMCC1	;NEXT INVOKATION.
RRLP6:	.LISTEN TT,
	SKIPGE UNRCHC
	SKIPE TT	;ANY BUFFERED INPUT TO PROCESS?
	 JRST RRLP1
	SKIPGE GEA	;^L OR F+ HAS CLEARED THE SCREEN => REDISPLAY
	 JRST RRLP4B	; EVEN ON PRINTING TTY'S.
	SKIPL PJATY	;SCREEN GOT CLOBBERED, OR LOTS OF CHANGES HAPPENED, =>
	SKIPGE RRMNVP	;MUST CHECK THE WINDOW BEFORE DISPLAYING ANYTHING.
	 JRST RRLP4
	MOVE A,RRVPOS	;NO INPUT, DISPLAY NOW:
	SKIPN GEA
	 JRST RRLP2
	CAMGE A,RRTOPM	;CURSOR TOO NEAR TOP => NEW WINDOW.
	 JRST RRLP4A
RRLP2:	SKIPN MORESW	;IF THERE'S STUFF PAST THE SCREEN BOTTOM,
	 JRST RRLP2A	;WE DON'T WANT CURSOR TOO NEAR BOTTOM.
	CAML A,RRBOTM
	 JRST RRLP4A
RRLP2A:	CAML A,BOTLIN	;IF CURSOR'S BELOW BOTTOM, WE MUST SHIFT THE WINDOW.
	 JRST [	MOVE IN,PT	;BUT CURSOR AT FRONT OF --MORE-- LINE
		CAMG  A,BOTLIN	;AT END OF BUFFER AFTER A CRLF,
		 CAME IN,ZV	;IS CONSIDERED AT THE END, RATHER THAN BELOW IT.
		  JRST RRLP4A
		SUBI IN,2
		CALL RREOLT	;CHECK FOR THE CRLF.
		 JRST .+1
		JRST RRLP4A]
	SKIPN RGETTY	;ON PRINTING TTY'S, DISPLAY ONLY IF CHOSING NEW WINDOW (INCLUDING ^L COMMAND)
	 JRST RRLP1
	SKIPN RRMAXP	;ANY REDISPLAY REQUIRED?
	 JRST RRLP3	;NO, JUST MOVE CURSOR IF NEC.
	SKIPN A,RRDISM	;ABOUT TO DISPLAY;  FIRST CALL USER'S MACRO.
	 JRST RRLP2F
	CALL RRMACR
	TRNN FF,ARG2	;IF 0 OR 2 VALUES, RECONSIDER WHAT DISPLAY TO DO
	 TRNN FF,ARG
	  JRST RRLP6
	SKIPN RRMAXP	;IF 1 VALUE, AND NOW APARENTLY NO REDISPLAY NEEDED,
	 JRST RRLP6	;DON'T DO ANY.
RRLP2F:	CALL CHCTI0	;INIT. FOR CALLING DISAD.
	SETZM CHCTBP
	AOS CHCTBP	;(MUSTN'T BE 0, OR CHCTHC WOULDN'T BE SET)
	HLLOS DISBFC
	MOVEI TT,CPOPJ
	MOVEM TT,CHCTAD	;MAKE SURE DISLIN NOT CALLED, IN CASE STRAY CR OR BS.
	.I RRDHPS=RRHPOS	;SAVE INFO FOR DEBUGGING.
	.I RRDVPS=RRVPOS
	.I RRDMHP=RRMNHP
	.I RRDMVP=RRMNVP
	SAVE PT
	SAVE RRHPOS
	SAVE RRVPOS
	MOVE A,RRMNVP	;FIND THE 1ST CHAR IN THE 1ST LINE
	MOVEM A,RRVPOS
	LDB TT,[3300,,LINBEG(A)]	;WHICH WAS ALTERED,
	MOVEM TT,PT
	MOVE TT,LINBEG(A)
	ASH TT,-33
	MOVEM TT,RRHPOS	;AND WHAT COLUMN IT WAS TYPED IN.
	MOVEM TT,CHCTHP	;IN CASE LINE DOESN'T START AT LEFT MARGIN
			;(DUE PERHAPS TO LF WITHOUT CR)
	CALL CHCTL4	;INIT CHCTHC WITH SPACES.
RRLP2B:	MOVE TT,RRHPOS	;MOVE FORWARD TILL WE FIND 1ST CHAR
	CAML TT,RRMNHP	;THAT FALLS IN THE 1ST ALTERED COLUMN.
	 JRST RRLP2C
	MOVE TT,PT
	CAML TT,ZV
	 JRST RRLP2C
	CALL RRFORW
	MOVE TT,RRVPOS
	CAME TT,RRMNVP	;BUT DON'T LET US MOVE PAST THE END OF
	 JRST RRLP2D	;THE LINE WE'RE SUPPOSED TO START ON.
	CALL DISAD2	;THESE CHARS NEEDN'T BE OUTPUT BUT MUST
			;STILL GO IN LINE'S HASH CODE.
	JRST RRLP2B

RRLP2D:	CALL RRBACK
RRLP2C:	MOVE IN,PT	;CHAR ADDR 1ST CHAR TO BE OUTPUT.
	MOVEM IN,RRDPT	;REMEMBER WHERE OUTPUT STARTD, FOR DEBUGGING.
	.I DISVP1=CHCTVP=RRVPOS=RRMNVP
	CALL DISLI6
	CALL RRMVC	;PUT CURSOR AT 1ST CHANGED POSITION,
	SETOM DISVP	;NORMALLY, MUST CLEAR 1ST LINE IF WRITE IT.
	SKIPN RRHPOS	;BUT IF WE'RE STARTING IN MID-LINE, DISLIN'S ALTERNATIVE
	 JRST RRLP2E	;OF CLEARING WHOLE LINE IS NO GOOD,
	MOVE TT,RRVPOS
	MOVEM TT,DISVP	;SO MAKE SURE DISLIN WON'T CLEAR THE WHOLE LINE,
	CAMN TT,BOTLIN	;AND UNLESS IT'S THE --MORE-- LINE,
	 JRST RRLP2E
	HRROI Q,[ASCIC/L/]
	CALL DISIOT	;CLEAR THE PART WE WANT TO CLEAR
	SETOM HCDS(TT)	;AND MAKE SURE DISLIN OUTPUTS WHAT WE CLEARED
RRLP2E:	REST RRVPOS
	REST RRHPOS
	REST PT
	MOVEI TT,DISLIN
	MOVEM TT,CHCTAD
	SETOM RROVPO	;WHEN WE STOP DISPLAYING, MUST REPOSITION PHYSICAL CURSOR.
	CALL VBDOK3	;DO THE DISPLAYING,
	CALL RRDIS2	;INDICATE NOW REDISPLAY NOT NEEDED.
	JRST RRLP5

RRLP4A:	SKIPE RGETTY
	 SETOM GEA	;DON'T EVEN BOTHER CONSIDERING PREVIOUS WINDOW.
RRLP4:	SKIPN RGETTY
	 JRST RRLP1
RRLP4B:	SKIPGE PJATY	;ABOUT TO DISPLAY => CALL FS ^R DISPLAY$.
	 SKIPN A,REFRSH	;IF GOING TO CLEAR ENTIRE SCREEN, FS REFRESH$ OVERRIDES.
	  MOVE A,RRDISM
	JUMPE A,RRLP5A
	CALL RRMACR
	SKIPL GEA	;ON RETURN, IS REDISPLAY STILL NEEDED OR WAS IT ALREADY DONE?
	 SKIPGE RRMAXP
	  JRST RRLP5A
	SKIPGE PJATY	;IF SEEMS TO HAVE BEEN DONE, MAYBE WE SHOULDN'T DO IT.
	 JRST RRLP6
RRLP5A:	SETOM RROVPO	;WHEN WE STOP DISPLAYING, MUST REPOSITION PHYSICAL CURSOR.
	.I RRERFL=ERRFL1
	CALL RRDISP	;NORMAL (VBD) DISPLAY, MAYBE CHANGING WINDOW.
	CALL RRDIS2	;REDISPLAY NOW NOT NEEDED,   (NOTE RRDISP PUTS ERRFL1 INTO A)
	SKIPGE RRERFL	;UNLESS THIS REDISPLAY DIDN'T DISPLAY THE TOP LINE
	 SETOM RRMNVP	;(PRESERVING AN ERR MSG) IN WHICH CASE REDISPLAY AFTER NEXT CMD.
RRLP5:	.I RROLDZ=Z
	AOSN RRNCCR	;IF CHAR BEFORE PT WAS A CR, RRHPOS WASN'T SET
		;(DUE TO THE FACT THAT A CR ISN'T OUTPUT UNTIL THE
		;NEXT CHAR IS SEEN)
	 CALL [	SOS PT	;HPOS AND VPOS ARE CORRECT FOR BEFORE
		JRST RRFORW]	;THE CR, SO SPACE OVER IT.
	MOVE A,RRHPOS	;DON'T LET THE CURSOR BE OVER THE "!"
	CALL RRFOR3	;OF A CONTINUATION.
RRLP3:	CALL DISMD	;REDISPLAY Q..J IF IT HAS CHANGED.
	SKIPE RGETTY
	 CALL RRMVC	;PUT THE HARDWARE CURSOR AT THE POINTER.
	JRST RRLP1

;COME HERE TO HANDLE INPUT (NO DISPLAY NEEDED OR INPUT KNOWN TO BE WAITING).
RRLP1:	TRNN FF,NOTF	;IF WE'RE DOING AN "^ V", RETURN
	 CALL RREXIT	;(DOESN'T COME BACK) AFTER DISPLAYING ONCE.
	SKIPGE CH,UNRCHC	;IF THERE'S A CHAR TO REREAD, DO SO.
	 CALL TYIW	;ELSE READ A NEW.
	MOVEM CH,$Q..0	;PUT CHAR WHERE USER MACRO DEFINITION CAN FIND IT.
	MOVEM CH,RRLAST	;ALSO PUT IT IN FS ^R LAST$.
	SKIPN RGETTY
	 SKIPE RRECHO	;DECIDE WHETHER TO ECHO ^R INPUT.
	  SKIPGE RRECHO
	   CALL [CALL TYINRM	;MUST NORMALIZE CHARACTER BEFORE OUTPUTTING,
		 CAIN CH,177	;AND DON'T ECHO RUBOUT ON PRINTING TTYS
		  SKIPE RGETTY
		   JRST FSECO1
		 RET]
	MOVE CH,$Q..0		;(IN CASE WE CALLED TYINRM).
	SETOM UNRCHC
	SAVE [RRLP]
RRLP7:	.I RREPT=PT
	CAMN CH,CASSFT	;F$ CASE CTL CHRS DON'T HAVE FIXED VALUES.
	 JRST RRSFT
	CAMN CH,CASLOK	;SO THE DISPATCH TABLE CAN'T CHECK FOR THEM.
	 JRST RRLOK
	CALL RRCASC	;IF IN F$ MODE, DO CASE CONVERSION.
	TRNN CH,META
	 JRST RRLP7I
	TRNE CH,CONTRL	;META NON-CONTROL CHARACTERS ALL SELF-INSERT
	 JRST RRLP7J
	SKIPLE RRRPLC	;IF IN FS ^R REPLACE$ > 0 MODE.
	 JRST RRXINS
RRLP7J:	TRNE CH,CONTRL	;CONTROL-META LETTERS SELF INSERT IF FS CTLMTA$ NEGATIVE.
	 TRNN CH,100
	  JRST RRLP7I
	SKIPGE RRCMQT
	 JRST RRXINS
RRLP7I:
;"INDIRECT" (RRINDR) DEFINITIONS LOOP BACK HERE.
RRIND1:	MOVE C,RRMACT(CH)	;GET CURRENT DEFINITION OF CHARACTER.
	SKIPL RRALQT	;UNLESS DEFINITIONS ARE SUPPRESSED,
	SKIPGE RRUNQT
	 JRST RRLP7D	;USE THE DEFINITION
	CAME CH,RRALQT	;ELSE IF THIS IS NOT THE UNQUOTING CHAR,
	 JRST RRLP7B	;MAKE IT SELF-INSERTING.
	SETOM RRUNQT	;IF IT IS, REENABLE DEFINITIONS FOR 1 COMMAND.
	JRST POPJ1

;HANDLE A CHARACTER IN SUPPRESS MODE.
RRLP7B:	JUMPL C,RRLP7E	;IF ITS DEF. IS A MACRO, SEE WHETHER IT STARTS WITH "W".
	MOVEI A,(C)
	CAIE A,RRINDR
	CAIN CH,177
	 JRST RRLP7D	;RUBOUT WORKS EVEN IN SUPPRESS MODE.
RRLP7F:	CAIN CH,CONTRL+"M ;OTHER CHARS BECOME SELF-INSERTING.
	 SKIPA C,[RRCRLF,,RRREPT]
RRXINS:	  SKIP C,RRXINV
	SKIPN C
	 MOVE C,[RRDINS,,RRREPT]
RRLP7D:	SKIPGE A,C	;COME HERE TO USE WHATEVER DEFINITION IS IN C.
	 JRST RRMAC0	;EITHER A MACRO,
RRLP7H:	MOVE A,(C)	;OR A SUBROUTINE WITHIN TECO.
	CAMN A,[CALL RRARGD]	;BUT MAKE SURE WE AREN'T CALLING RANDOMNESS.
	 JRST (C)	;SUBROUTINES MUST START WITH EITHER CALL RRARGD
	LDB A,[331100,,A] ;OR A "SKIP" (THAT DOESN'T SKIP EVER).
	CAIE A,.BREAK_-33 ;DON'T BE CONFUSED BY BREAKPOINTS.
	 CAIN A,SKIP_-33
	  JRST (C)
	TYPRE [M%R]

RRLP7E:	MOVE A,C	;MACRO-CHAR. TYPED IN SUPPRESS MODE.
	CALL QLGET1
	 JRST RRLP7F
	ILDB TT,F	;WHAT IS ITS 1ST CHARACTER?
	CAIE TT,"W+40
	 CAIN TT,"W	;IF IT DOESN'T START WITH A "W"
	  CAIGE AA,1	; (DON'T LOSE ON STRINGE 0 CHARS LONG)
	   JRST RRLP7F	;THEN THE DEFINITION IS SUPPRESSED.
	JRST RRLP7D	;IF IT STARTS WITH "W", THEN EXECUTE DEFINITION EVEN IN SUPPRESS MODE.

;COME HERE FOR ^G.
RRQUIT:	SKIP TT,CASNRM	;NOTE: THIS RTN IS CALLABLE BY RRLP7H, SO NEED "SKIP"
	MOVEM TT,CASE	;IN F$ MODE, UNDO ANY CASE-LOCKAGE.
	SETOM RRMKPT	;ELIMINATE THE MARK.
	SKIPE NELNS
	 .IOT ECHOC,[^M] ;GO TO NEW LINE IN ECHO REGION
	SETOM RROVPO	;FORCE CURSOR REPOSITIONING

;ERROR DETECTED BY RR EDIT:
RRERR:	SKIP
	SKIPE RREBEG	;IF NOT INSIDE ^R, GIVE A TECO ERROR.
	 TYPRE [BEL]
	MOVE P,DISPRR
	JRST TYPBEL	;TYPE A BELL AND REENTER MAIN LOOP.

RRDISX:	MOVEI T,RRLP1	;COME HERE TO QUIT DISPLAYING BECAUSE INPUT WAITING.
	MOVE CH,DISPRR
	MOVEM T,(CH)	;PREVENT RRARGF FROM BEING CALLED.
;COME HERE IF STOP DISPLAYING SINCE KNOW NO MORE DISPLAY NEEDED.
RRDISF:	MOVE P,DISPRR
	MOVE T,Z
	SUB T,RROLDZ	;WON'T CALL DISLIN ANY MORE,
	ADDM T,RROLDZ
RRDISG:	ADDM T,LINBEG+1(F) ;BUT SOMEONE BETTER UPDATE LINBEG WDS
	CAMGE F,BOTLIN	;OF THE REST OF THE LINES ON THE SCREEN.
	 AOJA F,RRDISG
	CAME F,BOTLIN
	 .VALUE
	POPJ P,

RRDISP:	.I RRMNVP=TOPLIN ;IF DISPLAYING IS INTERRUPTED, MAKE
	SETZM RRMNHP	;WE RESTART THE RIGHT WAY.
	HRLOI TT,377777
	MOVEM TT,RRMAXP	;DISPLAY UNTIL PT EQUALS INFINITY.
	CALL VBDRR
	SKIPE RRSCAN	;IN SCAN MODE, PRINT THIS LINE UP TO CURSOR SO THAT
	 SKIPE RGETTY	;CURSOR-MOTION COMMANDS WILL LOOK GOOD.
	  RET
	MOVEI A,[ASCIZ /0T/]
	JRST MACXCT

RRDIS1:	MOVE CH,CHCTHP	;CALL HERE WHEN CURSOR IS OUTPUT,
	MOVEM CH,RRHPOS	;OR AT END OF BUFFER IF PT IS THERE.
	MOVE CH,CHCTCF	;IF THE LAST CHAR WAS CR,
	MOVEM CH,RRNCCR	;SAY WE DON'T KNOW CORRECT HPOS.
	MOVE CH,CHCTVP
	MOVEM CH,RRVPOS	;REMEMBER SCREEN POS. OF CURSOR.
	POPJ P,

RRDIS2:	SETZM RRMAXP
	HRLOI TT,377777
	MOVEM TT,RRMNVP
	MOVEM TT,RRMNHP
	POPJ P,

RRMVC:	;PUT THE CURSOR AT THE PLACE SPEC'D BY RRHPOS, RRVPOS.
;ASSUMES THAT RROHPO, RROVPO HOLD OLD CURSOR POS, OR -1
;IF OLD POSITION NOT KNOWN. CLOBBERS Q.
	MOVE Q,RRHPOS
	CAME Q,RROHPO	;IF NEITHER COORD NEEDS TO BE CHANGED,
	 JRST RRMVC1
	MOVE Q,RRVPOS
	CAMN Q,RROVPO
	 RET		;DON'T BOTHER TO DO ANYTHING.
RRMVC1:
IRPC XX,,HV
	MOVE Q,RR!XX!POS	;COMPILE SOME ^P CODES TO PUT THE TTY'S
	MOVEM Q,RRO!XX!POS	;POSITION AT TECO'S CURSOR.
	ADDI Q,10
	DPB Q,[170700,,RRMV!XX]
	HRROI Q,RRMV!XX
	CALL DISIOT		;OUTPUT THE ^P CODES.
TERMIN					;DO THAT FOR EACH COORDINATE.
	POPJ P,

;^B - MOVE BACKWARDS ONE CHARACTER.
;UPDATES RRHPOS AND RRVPOS.  LEAVES THE CHAR MOVED OVER IN CH.
;EAVES PT IN IN. CLOBBERS OUT, TT, TT1, A, AA.
RRBACK:	MOVE IN,BEGV	;ERROR IF AT BEGINNING OF BUFFER.
	CAML IN,PT
	 JRST RRERR
RRBAC4:	SOS IN,PT	;GET THE CHAR BEFORE THE PTR
	CALL GET
RRBAC0:	RRCHRG		;GET CHAR'S DISPATCH TYPE CODE IN A.
	XCT RRBACT(A)
RRBAC1:	 SOS A,RRHPOS
	JUMPGE A,CPOPJ
RRBAC3:	ADD A,NHLNS	;MOVED OVER LINE-CONTINUATION.
	MOVEM A,RRHPOS	;GO BACK TO PREV. LINE'S END.
RRBACV:	SOS RRVPOS
	POPJ P,

RRBACT:	SOSA A,RRHPOS	;ORD. CHAR., BACK 1 POS.
	JRST RRBACC	;NON-FORMATTING CONTROL CHARS.
	JRST RRBACH	;^H, CHECK ^HPRINT FLAG.
	JRST RRBACR	;^M, SPECIAL.
	JRST RRBACL	;^J, UP 1 LINE.
	SAVE [RRBTCR]	;TAB, COMPUTE RRHPOS BY MOVING FWD
			;FROM PREVIOUS CR.
	JRST RRBAC2	;2-POS CTL CHARS NO AFFECTED BY FS SAIL (^P AND ^C).

RRBACR:	ADDI IN,1	;CR: IS IT FOLLOWED BY LF?
	CALL GET
	MOVEI A,(CH)
	MOVEI CH,^M
	CAMGE IN,ZV
	CAIE A,^J	;IF THIS CR REALLY CAME OUT AS CR,
	SKIPGE DISPCR
	 JRST RRBTCR	;COMPUTE HPOS THE HARD WAY.
	SUBI IN,1
RRBAC2:	SOS RRHPOS	;IF IT CAME OUT AS UPARROW-M,
	JRST RRBAC1	;TREAT AS 2-POS CTL CHAR.

RRBACL:	SUBI IN,1	;LF: SEE IF PREV. CHAR IS CR.
	CALL GETINC
	MOVEI A,(CH)
	MOVEI CH,^J
	CAML IN,BEGV
	 CAIE A,^M	;BASED ON THAT AND ON DISPCR, DECIDE HOW LF WAS PRINTED OUT.
	  SKIPGE DISPCR
	   JRST RRBACV
	JRST RRBAC2

RRBACH:	SKIPL DISPBS	;MOVE BACK OVER ^H - IF IT CAME OUT AS
	 JRST RRBAC2	;UPARROW-H, TREAT AS 2-SPACE CTL CHAR.
	JRST RRBTCR	;ELSECAN'T UPDATE HPOS, MUST RECOMPUTE.

;NON-FORMATTING CONTROL CHARS, CHECK SAIL FLAG.
RRBACC:	SKIPN DISSAI
	 JRST RRBAC2	;NORMALLY, MOVE BACK 2 POS.
	JRST RRBAC1	;IN SAIL MODE, MOVE 1 POS.

;^F -- MOVE FWD 1 CHAR.  SEE THE COMMENTS BEFORE RRBACK.
RRFORW:	MOVE IN,PT	;ERROR IF AT END OF BUFFER.
	CAML IN,ZV
	 JRST RRERR
	CALL GETINC
RRFOR0:	AOS PT
	RRCHRG
	XCT RRFORT(A)	;DISPATCH ON TYPE OF CHAR.
RRFOR1:	 AOS A,RRHPOS
RRFOR3:	CAMGE A,NHLNS	;HAVE WE MOVED PAST RIGHT MARGIN?
	 POPJ P,
	CAMN A,NHLNS	;CHECK FOR JUST REACHING THE RIGHT MARGIN.
	 JRST [	SAVE CH	;IF REACH RIGHT MARGIN, MUST
		MOVE IN,PT	;CONTINUE PROVIDED WE'RE NOT AT
		CALL RREOLT	;THE END OF THE LINE.
		 JRST POPCHJ	;AT END OF LINE, NOTHING TO DO.
		REST CH		;NOT AT EOL, CONTINUE.
		MOVE A,RRHPOS
		JRST .+1]
	SUB A,NHLNS
	MOVEM A,RRHPOS
RRFORV:	AOS RRVPOS
	POPJ P,

RRFORT:	AOSA A,RRHPOS	;ORDINARY CHAR, MOVE FWD 1 POS.
	JRST RRFORC	;NON-FORMATTING CONTROLS.
	JRST RRFORH	;MOVE FWD OVER ^H - CHECK ^HPRINT FLAG.
	JRST RRFWCR	;^M, SPECIAL.
	JRST RRFORL	;^J, DOWN 1 LINE.
	JRST RRFOTB	;^I
	JRST RRFOR2	;2-POS CTL CHRS NOT AFFECTED BY FS SAIL (^P AND ^C).

RRFOTB:	MOVE TT,RRHPOS
	MOVEI A,10(TT)
	ANDCMI A,7	;A HAS NEXT TAB STOP'S POSITION.
	CAMLE A,NHLNS	;BUT IF THAT'S OFF THE SCREEN, TAB STOP IS RIGHT MARGIN,
	 CAMN TT,NHLNS	;UNLESS WE'RE ALREADY AT THE MARGIN, IN WHICH CASE
	  CAIA		;WE CAN TAB 8 SPACES INTO NEXT LINE VIA CONTINUATION.
	   MOVE A,NHLNS
	MOVEM A,RRHPOS
	JRST RRFOR3

RRFWCR:	SKIPGE DISPCR
	 JRST RRFWC1
	CALL GET	;CR - SEE IF NEXT CHAR IS LF.
	MOVEI A,(CH)
	MOVEI CH,^M	;MAKE SURE WE RETURN CHAR BEING PASSED IN CH.
	CAMGE IN,ZV
	CAIE A,^J
	 JRST RRFOR2	;NO, CR CAME OUT AS UPARROW-M
RRFWC1:	SETOM RRHPOS	;(RRHPOS WILL BE AOS'D TO 0)
	JRST RRFOR1

RRFORL:	SKIPGE DISPCR	;LF: BASED ON WHETHER A CR PRECEDES IT AND ON DISPCR,
	 JRST RRFORV
	SUBI IN,2
	CALL GET	;DECIDE HOW THE LF CAME OUT AND THEREFORE
	MOVEI A,(CH)
	MOVEI CH,^J
	MOVE TT,IN
	ADDI IN,2
	CAML TT,BEGV
	 CAIE A,^M	;HOW TO MOVE OVER IT.
	  JRST RRFOR2
	JRST RRFORV

RRFORH:	SKIPGE DISPBS	;MOVING FWD OVER ^H -IF CAME OUT AS
	SKIPN RRHPOS
	 JRST RRFOR2
	 JRST RRBAC1	;REAL ^H, MOVE BACK 1 POS

;NON-FORMATTING CONTROLS, CHECK FS SAIL FLAG.
RRFORC:	SKIPE DISSAI	;IN SAILL MODE, THEY'RE 1-POS GRAPHICS.
	 JRST RRFOR1
RRFOR2:	AOS RRHPOS	;ELSE TREAT AS 2-POS CTL CHAR.
	JRST RRFOR1

;MAKE SURE RRHPOS IS CORRECT BY MOVING BACK TO THE LAST CR THAT
;REALLY CAME OUT AS A CR, AND MOVING FORWARD AGAIN. PT IS UNCHANGED.
;THE LARGEST HPOS THAT OCCURS ON THE LINE UP TO PT IS RETURNED IN OUT.
;PT IS RETURNED IN IN.  CLOBBERS TT, TT1.
;A CONTAINS ADDR OF THE CR WE WENT BACK TO (+1), AND AA HAS VPOS DIFFERENCE FROM THERE.
RRBTCR:	SAVE CH
	SAVE RRVPOS	;VPOS WILL BE ALTERED WHILE WE MOVE FWD
			;BUT WE REALLY DON'T WANT IT CHANGED.
	SAVE PT		;REMEMBER WHERE TO STOP WHEN MOVE FWD AGAIN.
	MOVE A,GEA	;1ST, FIGURE OUT WHERE TO STOP MOVING BACKWARD
	ADD A,BEGV	;IF WE DON'T FIND A CR. 1ST CHAR ON SCREEN
			;IS ONE PLACE. BEGINNING OF BFR IS ANOTHER.
	SKIPL GEA
	CAMLE A,PT	;(AT BOTH PLACES, HPOS MUST BE 0)
	 MOVE A,BEGV	;USE WHICHEVER WE'LL REACH SOONER.
	SETZ OUT,	;ON 1ST PASS OUT=-1 => AN LF HAS BEEN PASSED GOING BACKWARDS.
RRBTC0:	MOVE IN,PT
	CAMG IN,A
	 JRST RRBTC1	;WE MOVED BACK TO WHERE WE CAN STOP.
	SOS IN,PT
	CALL GETINC	;ELSE, KEEP GOING BACK.
	CAIN CH,^J
	 SETO OUT,	;REACHED LF => SAY NOT ON LINE WE STARTED ON.
	CAIE CH,^M	;REACHED CR => SEE WHETHER IT CAME OUT AS ONE.
	 JRST RRBTC0
	JUMPE OUT,RRBTC0 ;BUT DON'T STOP AT ANY CR IF WE HAVEN'T GONE UP AT LEAST ONE LINE.
	SKIPGE DISPCR
	 JRST RRBTC4
	CALL GET
	CAIE CH,^J
	 JRST RRBTC0
	AOS PT		;START AFTER THE CR AND THE LF.
RRBTC4:	AOS PT		;START AFTER THE CR.
RRBTC1:	SETZB OUT,RRHPOS ;AT THE CR, KNOW HPOS IS 0.
	SAVE PT		;REMEMBER WHERE WE WENT BACK TO, TO RETURN IT IN A.
	SAVE RRVPOS
RRBTC2:	MOVE IN,PT	;REACHED WHERE WE STARTED?
	CAMN IN,-2(P)
	 JRST RRBTC3	;YES, FLUSH STACK & EXIT.
	CALL RRFORW	;MOVE FWD TILL GET THERE.
	MOVE A,RRVPOS	;IF WE'VE MOVED TO ANOTHER LINE,
	CAME A,(P)
	 JRST [	MOVEM A,(P)	;THEN THE CHARS SEEN SO FAR ARE NOT ON THE SAME
		SETZ OUT,	;LINE RRBTCR STARTED ON, SO THEY DON'T COUNT
		JRST RRBTC2]	;IN OUT'S VALUE.
	CAML OUT,RRHPOS	;IF CURRENT HPOS IS > LARGEST SO FAR,
	 JRST RRBTC2
	MOVE OUT,RRHPOS	;UPDATE MAXIMUM-HPOS-ON-CURRENT-LINE.
	JRST RRBTC2

RRBTC3:	REST AA		;RETURN IN AA THE VPOS DIFFERENCE WE MOVED OVER.
	REST A		;RETURN IN A THE ADDR OF WHERE WE WENT BACK TO.
	SUB P,[1,,1]
	REST RRVPOS
	SUB AA,RRVPOS
	JRST POPCHJ

;HANDLE ARGUMENT READ-IN AND REPETITION.

;^U - MULTIPLY REPEAT COUNT OR WHATEVER BY 4.
RR4TIM:	SKIP
	AOS RR4TCT
	MOVEI TT,1
	JRST RRNXI2	;SET RRARGP TO SAY NON-NULL ARG.

;^V - READ IN A NUMERIC ARGUMENT.
;THE CHARS OF THE ARG ARE ECHOED IN THE ECHO AREA.
;^G CANCELS THE ARG. ANY OTHER NON-DIGIT IS TREATED AS A COMMAND
;WHICH USES THE ARG (THIS INCLUDES RUBOUT). THE ARG IS LEFT IN RRRPCT.
RRARG:	SKIP B,[0]	;WE'LL COMPUTE ARG'S VALUE IN B.
	CALL RRECSP	;TYPE A SPACE AT BOTTOM OF SCREEN.
RRARG0:	CALL TYIW	;READ CHAR: EITHER PART OF ARG, OR NEXT COMMAND.
	MOVEM CH,$Q..0	;IF THE LATTER, IT WILL EXPECT TO BE IN Q..0.
	CAIN CH,"-
	 JUMPE B,[SAVE [RRARGN]	;1ST CHAR IS "-" => NEGATE ARG.
		  JRST RRARG1]
	CAIL CH,"0
	CAILE CH,"9
	 JRST RRARGX	;NON-DIGIT: TERMINATE ARG.
	IMUL B,IBASE	;DIGIT: PUT IT IN ARG.
	ADDI B,-"0(CH)
RRARG1:	CALL FSECO1	;AND PRINT IT IN THE ECHO AREA.
	JRST RRARG0

RRARGX:	MOVEM B,RRRPCT	;SAVE AWAY THE ARG WE READ.
	MOVEM CH,UNRCHC	;REPROCESS THE ARG-TERMINATING CHAR AS A COMMAND WITH THAT ARG
	JRST RRNXIT	;SAY THERE'S AN ARG IN RRRPCT.

RRARGN:	MOVNS RRRPCT
	RET

RRCDGT:	SKIP TT,RRRPCT		;CONTROL-DIGITS:  ACCUMULATE AN ARGUMENT.
	IMUL TT,IBASE
	ADDI TT,-260(CH)
	MOVEM TT,RRRPCT
RRNXIT:	MOVEI TT,3
RRNXI2:	IORM TT,RRARGP
	SETZM RRLAST	;SAY THIS IS AN ARG-SETTING COMMAND;
	RET		;DON'T FLUSH ARG OR CLOBBER FS ^R PREV$.

;COMMANDS THAT WANT TO BE REPEATED A NUMBER OF TIMES EQUAL
;TO THE NUMERIC ARG DISPATCH THRU HERE.
;(THAT IS, THE DISPATCH WD HOLDS <CMD-RTN>,,RRREPT )
RRREPT:	SKIP		;TELL RRLP7H ERROR-CHECK WE'RE GOOD GUYS.
	HLRZS C		;PUT <CMD-RTN> IN RH.
RRREP0:	CALL RRARGD	;DECODE RRRPCT AND RR4TCT TO GET THE ARG.
RRREP1:	JUMPLE B,CPOPJ	;B HAS <VALUE OF ARG>-<# TIMES ALREADY DONE>
	SAVE C
	HRLM CH,(P)	;SAVE CMD RTN ADDR AND THE CHAR.
	SAVE B		;AND # TIMES REMAINING.
	CALL (C)	;DO IT ONCE
	REST B
	REST C
	HLRZ CH,C
	SOJA B,RRREP1

;COMPUTE THE ARGUMENT FROM THE EXPLICIT ARGUMENT AND
;THE POWER-OF-4. RETURN IN B.
RRARGD:	MOVE B,RRARGP	;GET THE EXPLICIT ARG, OR 1 IF NONE SPEC'D.
	TRNE B,2
	 SKIPA B,RRRPCT
	  MOVEI B,1
	MOVE TT,RR4TCT	;THEN MULTIPLY BY 4 FOR EACH ^U.
	SOJGE TT,[LSH B,2 ? JRST .]
	RET

;AFTER A COMMAND, IF IT DIDN'T IDENTIFY ITSELF AS AN ARGUMENT-SETTING COMMAND
;(BY CLEARING RRLAST), FLUSH THE ARGUMENT THAT THE COMMAND USED.
RRARGF:	SKIPN TT,RRLAST	;IF THE LAST COMMAND DIDN'T PRESERVE OR MAKE AN ARG,
	 RET
	MOVEM TT,RRPRVC	;REMEMBER IT AS "PREVIOUS COMMAND" FOR NEXT COMMAND,
	SETZM RRARGP	;SAY TO GIVE NEXT COMMAND THE DEFAULT ARG (1)
	SETZM RR4TCT	;AND CLEAR ARG ACCUMULATION VARIABLES.
	SETZM RRRPCT
	SETZM RRUNQT
	RET

;ALTMODE - LEAVE ^R MODE.
RREXIT:	SKIP A,RREBEG
	JUMPN A,FSCREX	;IF COMING FROM M.^R$, DO A FS^REXIT$.
RREXI0:	TRNN FF,NOTF
	 JRST RREXI2
	SKIPE A,RRLEVM
	 CALL RRMACR
RREXI2:	MOVE P,DISPRR
	SUB P,[1,,1]	;POP OFF RET ADDR AT RRLP
	REST DISPRR
	SKIPN DISPRR	;IF EXITING OUTERMOST ^R,
	 CALL SETTTM	;RETURN TO NORMAL TTYSET.
	CALL RRLEAV	;SET UP "RRE" VARIABLES.
	ANDCMI FF,ARG+ARG2
	SKIPE DISPRR	;IF EXITING THE OUTERMOST LEVEL OF ^R,
	 JRST RREXI1
	SKIPE A,.QCRMC(CH) ;EXECUTE THE SECRETARY MACRO IF ANY.
	 CALL MACXQ
RREXI1:	REST B		;POP QREG PDL PTR SAVED AT ENTRY TO ^R
	CALL FSQPU0	;UNWIND PDL DOWN TO THAT LEVEL.
	JRST POP1J

RRTHRW:	MOVE P,DISPRR	;RETURN TO ^R MAIN LOOP.
	JRST RREAR0	;WE'RE COMING FROM OUTSIDE ^R, SO MUST OFFICIALLY RE-ENTER.

RRLEAV:	SKIPG NOQUIT
	 SETZM STOPF
	.I RREZ=Z
	.I RREBEG=BEG
RRLEA1:	.I RREPT=PT
	.I RREHPS=RRHPOS
	.I RREVPS=RRVPOS
	MOVE CH,QRB..
	SETZM .QVWFL(CH)
	RET

;EXPECT CHAR ADDR IN "IN", SKIP UNLESS IT POINTS TO THE END
;OF THE BUFFER OR THE END OF A LINE. CLOBBERS TT, TT1
RREOLT:	CAMN IN,ZV
	 POPJ P,	;AT EOF.
	SAVE CH
	CALL GETINC
	CAIN CH,^M
	CAMN IN,ZV
	 SOJA IN,POPCH1 ;BEFORE A CR THAT'S THE LAST CHAR.
	CALL GET
	SUBI IN,1
	CAIE CH,^J
POPCH1:	 AOS -1(P)	;BEFORE A STRAY CR => NOT AT EOL.
	JRST POPCHJ	;BEFORE A CRLF => EOL.

;IF A CHARACTER <C>'S DEFINITION IS <N>,,RRINDR, IT IS AN INDIRECT PTR
;TO THE DEFINITION OF THE CHARACTER <C>-<N>. USED TO HANDLE
;THE LOWER CASE CONTROL CHARACTERS SUCH AS 341 = CTL-LOWERCASE-A.
;ALSO USED TO MAKE CONTROL-H EQUIVALENT TO BACKSPACE; SIMILAR FOR TAB & LF.
RRINDR:	SKIP
	HLRZS C		;GET <N>
	SUB CH,C
	JRST RRIND1	;GO USE DEF'N OF <C>-<N>.

RRDLNB:	MOVNS B		;HERE FOR DELETE BACKWARD WITH NEGATIVE ARG.
	JRST RRCTD1

;^D -- DELETE FORWARD. (D)
RRCTLD:	CALL RRARGD	;CHECK FOR NEGATIVE ARG.
	JUMPGE B,RRCTD1
	MOVNM B,RRRPCT		;IF NEGATIVE ARG, SET ITS NEGATION UP AS ARG
	.I RRARGP=3
	SETZM RR4TCT
	MOVEI CH,177		;AND TURN INTO RUBOUT.
	JRST RRIND1

RRCTD1:	JSP C,RRREP1
	MOVEI CH,"#
	JSP C,RRTYPP	;ON PRINTING TTY, MAYBE TYPE A "#".
	 CALL TYOS
	MOVE IN,PT
	SKIPN RUBCRL	;IF FS RUBCRLF$ NONZERO,
	 JRST RRDLF
	CALL RREOLT	;IF BEFORE A CRLF, DELETE BOTH CHARS.
	 PUSHJ P,.+1

RRDLF:	CALL RRFORW	;MOVE OVER THE CHAR, THEN DELETE IT BACKWARD.

;INTERNAL ROUTINE TO DELETE BACKWARD (-D).  DELETED CHAR LEFT IN CH.
;CLOBBERS A,AA,IN,OUT,TT,TT1,Q, T, F
RRDLB:	SETOM RRMKPT
	MOVE IN,PT	;ERROR AT BEGINNING OF BUFFER.
	CAMG IN,BEGV
	 JRST RRERR
	SAVE RRVPOS	;REMEMBER VPOS TO RIGHT OF CHARACTER.
	CALL RRBACK	;ACCOUNT FOR CURSOR POS CHANGE DUE TO DELETION.
	CALL GAPSLP
	CALL RRCRDI
	 	CALL DEL1F	;DELETE FORWARD FROM BUFFER, NO CURSOR HACKERY.
	CAIE CH,^H	;DELETING CHARS THAT MOVE LEFT IS HARD.
	CAIN CH,^M
	 JRST RRDLB4
	CALL RRICHK	;SEE WHETHER IT'S EASY TO UPDATE SCREEN.
	REST A
	CAMN A,F	;IF EFFECTS OF CHANGE REACH PREV. LINE,
	SKIPE RRMAXP	;OR IF REDISPLAY WILL BE DONE ANYWAY.
	 JRST RRDLB1	;DON'T BOTHER TO DO IT HERE.
	CALL RRMVC	;UPDATE THE SCREEN NOW:
	MOVNI T,1	;UPDATE LINBEG WORDS OF ALL LINES
	CALL RRINS3	;BELOW THIS ONE.
	HRROI Q,[ASCIC/L/]
	JRST DISIOT

RRDLB4:	SUB P,[1,,1]	;FLUSH SAVED VPOS. FROM STACK.
	SETZ T,		;DELETING A CR => MUST REDISPLAY WHOLE LINE
			;TO GET RID OF OVERSTRUCK CHAR IN POSITION 0.
RRDLB1:	MOVNI A,1	;1 CHAR DELETED AT VPOS, HPOS IN F,T.
	JRST RRFXM1

FSRRRU:	ARGDFL Z	;FS ^R RUBOUT$
	SAVE [RRLEA1]	;AFTERWARDS SET RREPT, RREHPS, RREVPS.
	JSP C,RRRUBR
	JRST RRDLB	;RUB OUT SPEC'D # OF CHARS WITH NO TAB OR CRLF HACKS.

RRRUB:	CALL RRARGD	;BUILT-IN DEFINITION OF RUBOUT: DECODE ARGUMENT.
	JUMPL B,RRDLNB	;NEGATIVE ARG => REALLY DELETE FORWARD.
	JSP C,RRRUBR	;REPEAT ARG TIMES WHAT FOLLOWS (BUT FIRST OTHER STUFF)
RRRUBD:	CALL RRDLB	;DELETE ONE CHAR BACKWARD
	JSP C,RRTYPP	;ON PRINTING TTY, IF SCANNING, TYPE THE RUBBED CHARACTER.
	 CALL TYOS
	SKIPE RUBCRL	;AND THEN IF FS RUBCRLF$ NONZERO, AFTER RUBBING OUT A ^J
	 CAIE CH,^J
	  RET
	MOVE IN,PT	;FLUSH A CR BEFORE IT, TOO.
	CALL [SOJA IN,GET]
	CAIN CH,^M
	 CAMGE IN,BEGV
	  RET
	JRST RRDLB

;JSP C,RRRUBR TO REPEAT WHAT FOLLOWS C(B) TIMES, BUT FIRST IF C(B) IS BIG
;MAKE SURE TO SUPPRESS UPDATING IN FAVOR OF REDISPLAY.
RRRUBR:	MOVE TT,PT
	CAMN TT,BEGV	;CAN'T RUB PAST BEG OF BUFFER.
	 JRST RRERR
	CAIL B,4
	 SKIPE RRMAXP	;IF RUBBING < 4 CHARS, AND NO REDISPLAY NEEDED YET,
	  CAIA		;TRY TO DO UPDATING.
	   AOS RRMAXP	;OTHERWISE, INHIBIT UPDATING - REDISPLAY WILL BE USED.
	JRST RRREP1

;CTL-RUBOUT:  LIKE RUBOUT, BUT CONVERTS TABS INTO SPACES FIRST.
RRCRUB:	CALL RRARGD
	JUMPL B,RRDLNB	;NEGATIVE ARG => REALLY DELETE FORWARD.
	JSP C,RRRUBR	;REPEAT THE FOLLOWING ARG TIMES:
	SAVE RRHPOS
	CALL RRBACK	;WE NEED HPOS BOTH BEFORE AND AFTER CHAR TO BE FLUSHED,
	REST C		;IF IT'S A TAB.
	CAIE CH,^I
	 JRST [	CALL RRFORW	;NOT TAB => UNDO THE RRBACK
		JRST RRRUBD]	;AND DO A NORMAL RUBOUT.
	CALL GAPSLP
	SAVE PT
	AOS (P)
	CALL DEL1F	;ELSE FLUSH THE TAB AND PUT IN APPRO. # OF SPACES
	SUB C,RRHPOS
RRCRU1:	MOVEI CH,40
	CALL TYOM
	SOS PT
	CALL RRFORW	;MOVING FORWARD OVER THEM
	SOJG C,RRCRU1	;LEAVING US IN INITIAL STATE EXCEPT TAB REPLACED BY SPACES.
	REST T
	SUB T,PT
	MOVNS T		;T HAS CHANGE IN PT DUE TO OUR INSERTION.
	MOVE F,RRVPOS
	CALL RRINS3	;RELOCATE LINBEG TABLE FOR WHAT WE HAVE DONE.
	JRST RRRUBD	;THEN DELETE THE LAST SPACE.

;^O - INSERT CRLF, THEN BACK UP OVER IT.
RRCTLO:	CALL RRCRL1	;INSERT CRLF
	CALL RRBACK	;THEN BACK OVER IT.
	JRST RRBACK

;^M - INSERT ^M AND ^J.
RRCRLF:	CALL RRCMRU	;REMOVE TAB-SEMI'S FROM LINE WE'RE ON.
	JSP C,RRTYPP
	 SKIPG RRECHO
	  CAIA
	   CALL CRR	;IF SCANNING, ECHO EVEN IF RRECHO IS OFF.
RRCRL1:	MOVEI CH,^M
	CALL RRINS	;INSERT THE ^M.
	MOVEI CH,^J
	JRST RRINS	;INSERT THE ^J.

RRTYEC:	JSP C,RRTYPP
	 SKIPG RRECHO
	  RET
	JRST TYOS

;^Q -- READ NEXT CHAR AND INSERT IT.
RRQUOT:	CALL RRARGD
	SAVE B
	CALL RRECO1	;FINISH DISPLAYING, MAYBE PROMPT WITH A "^Q".
	CALL TYI	;READ THE CHAR TO BE QUOTED.
	CALL TYINRM
	REST B
	JSP C,RRREP1	;NOTE ^Q MUST DO ITS OWN REPETITION.
	JRST RRINS	;OTHERWISE ^V5^Q WOULD READ AND INSERT 5 CHARS.
			;INSTEAD OF READING 1 CHAR AND INSERTING
			;IT 5 TIMES.

;THIS IS THE DEFAULT DEFINITION OF "SELF-INSERTING" CHARACTERS:
;NORMALLY, JUST INSERT.  META-CHARS INSERT.  IF FS ^R REPLACE$ NONZERO,
;NON-META CHARS REPLACE INSTEAD (BUT AT END OF LINE, THEY INSERT).
RRDINS:	MOVE CH,$Q..0
	TRNN CH,META
	 SKIPN RRRPLC
	  JRST RRINSC
	MOVE IN,PT
	CAML IN,ZV	;AT END OF BUFFER, JUST INSERT.
	 JRST RRINSC
	CALL GET	;HERE IF SUPPOSED TO TRY TO REPLACE.
	CAIE CH,^M	;AT END OF LINE?
	 CAIN CH,^J
	  JRST RRINSC	;YES => INSERT, DON'T REPLACE.
	CAIE CH,^H
	 CAIN CH,^L
	  JRST RRINSC
	CAIN CH,^I
	 JRST RRDINT
	CALL RRDLF
RRINSC:	MOVE CH,$Q..0
	CALL RRTYEC
	JRST RRINS

RRDINT:	.I RRHPOS+1	;BEFORE A TAB => INSERT UNLESS TAB NOW TAKING ONLY 1 SPACE.
	TRNN TT,7
	 CALL RRDLF
	JRST RRDINI

FSRRINS:MOVE CH,B	;USER-INTERFACE TO RRINS: FS ^R INSERT$

;INSERT CHAR IN CH.
;CLOBBERS A, AA, IN, OUT, TT, TT1, CH, Q, T, F
RRINS:	CALL TYINRM	;CONVERT CHARACTER TO ASCII.
	SETOM RRMKPT
	SKIPN RRMAXP
	CAIN CH,^I	;INSERTING ANY CTL CHAR BUT TAB
	 JRST RRINS2	;IS HARD. SO IS RUBOUT.
	CAIE CH,177
	CAIGE CH,40
	 AOSA RRMAXP
RRINS2:	CALL RRICHK	;SEE IF OBVIOUSLY CAN'T UPDATE SCREEN NOW.
	CALL RRCRDI
	 CALL [	CALL TYOMGS ;INSERT CHAR AFTER PT.
		SOS PT
		POPJ P,]
	MOVE Q,RRHPOS
	CALL RRFORW	;THEN MOVE FORWARD OVER IT.
	MOVEI A,1	;(FOR RRFXM1) 1 CHAR INSERTED.
	CAMN F,RRVPOS	;CHAR MOVED TO NEXT LINE => MUST REDISPLAY
	SKIPE RRMAXP	;IF NOT PLANNING TO REDISPLAY,
	 JRST RRFXM1
	MOVE T,Q
	EXCH T,RRHPOS	;POSITION CURSOR AT HPOS BEFORE THE CHARACTER.
	CALL RRMVC	;UPDATE THE SCREEN BY OUTPUTTING THE
	MOVEM T,RRHPOS
	MOVEM T,RROHPO
	MOVEI T,1	;UPDATE LINBEG WDS OF ALL LINES
	CALL RRINS3	;BELOW THIS LINE.
RRDLB5:	CAIN CH,33
	 JRST [	HRROI Q,[ASCIZ //]
		JRST DISIOT]
	SKIPE CASDIS	;CHARACTER, WITH CASE-SHIFT IF ANY.
	 CALL DISAD6
	JRST TYOINV

RRINS3:	SETOM HCDS(F)	;AFTER A LINE IS UPDATED ITS HASH CODE IS WRONG
	ADDM T,RROLDZ
	JRST RRDISG

;CHECK FOR SOME OF THE THINGS THAT WOULD RULE OUT UPDATING THE
;SCREEN IMMEDIATELY FOR AN INSERT OR DELETE. IF ANY IS
;FOUND, LEAVE RRMAXP NONZERO (THIS WON'T CONFUSE RRLP BECAUSE
;WE'LL SET RRMAXP ANYWAY IN ORDER TO CAUSE REDISPLAY)
;REDISPLAY WILL ALWAYS WORK, BUT UPDATING IS FASTER.
;CLOBBERS A, AA, IN, OUT, TT, TT1
RRICHK:	SKIPE RRMAXP	;REDISPLAY NECESSARY ANYWAY =>
	 POPJ P,	;IT WILL FIX SCREEN; WE NEEDN'T.
	SAVE CH
	SKIPN RGETTY
	 JRST RRICH1	;CAN'T UPDATE IF THERE'S A CURSOR STRING.
	MOVE CH,RRVPOS	;IF CURSOR IS OFF SCREEN,
	CAML CH,TOPLIN
	CAML CH,BOTLIN	;DON'T UPDATE, REDISPLAY IS NEEDED.
	 JRST RRICH1
	MOVE IN,PT
	CALL RREOLT	;UPDATING POSSIBLE ONLY AT END OF LINE.
	 CAIA
	JRST RRICH1
	.LISTEN A,	;MANY UPDATES DON'T BEAT 1 REDISPLAY.
	CAIL A,5
	 JRST RRICH1
	SKIPL DISPCR	;IF THERE ARE NO REAL BS'S OR STRAY CR'S
	SKIPGE DISPBS
	CAIA
	 JRST POPCHJ	;NO NEED FOR THE NEXT TEST.
	CALL RRBTCR	;PERHAPS, DUE TO BACKSPACES, SOMETHING
	CAMLE OUT,RRHPOS ;EARLIER IN THE LINE APPEARS FARTHER
			;RIGHT ON THE SCREEN (EG ABC<BS>/\)
RRICH1:	AOS RRMAXP	;CAUSE CALLER NOT TO TRY UPDATING.
	JRST POPCHJ

;CONVERT LOWER CASE TO UPPER OR VICE VERSA, ACC. TO FS CASE $
;FOR SHIFT OR LOCK CHARS, RCHSFT AND RCHLOK MIGHT GET CALLED!
RRCASC:	TRNE CH,CONTRL+META
	 RET
	CAIL CH,100	;[ ;XCTING WOULD LOSE ON ALTMODE, ^].
	 XCT RCHDTB(CH)	;SKIPS FOR CHARS WHOSE CASE IS WRONG.
	CAIA
	XORI CH,40	;CHANGE TO THE OTHER CASE.
	AOSN RCHSFF
	 MOVNS CASE	;IF PREV. CHAR WAS CASE SHIFT, UN-COMPLIMENT CASE.
	POPJ P,

;COME HERE WHEN CASE-SHIFT IS READ.
RRSFT:	MOVNS CASE	;READ NEXT CHAR IN ABNORMAL CASE.
	AOSE RCHSFF
	 SETOM RCHSFF	;RESTORE TO NORMAL AFTER NEXT CHAR.

;TYPE THE CHAR IN Q..0 AS A PROMPT, IF THERE IS NO INPUT AVAILABLE.
RRECO1:	SKIPN RGETTY
	 SKIPE RRECHO
	  SKIPGE RRECHO	;ON DISPLAY TTY, IF NOT ECHOING THE COMMAND,
	   RET
	MOVEI A,[ASCIZ /0^V^:FT..00 /]
	JRST RRMACR

;COME HERE FOR CASE-LOCK AS A COMMAND.
RRLOK:	MOVNS CASE
	POPJ P,

;TAKE CARE OF THE POSSIBILITY THAT CHANGING THE BUFFER AFTER PT MAY
;CHANGE WHAT APPEARS ON THE SCREEN BEFORE PT. (FOR EXAMPLE,
;INSERTING OR DELETING A LF AFTER A CR.)
;FOLLOW A CALL TO RRCRDI WITH AN INSN THAT CHANGES THE BUFFER
;AFTER PT, BUT DOESN'T CHANGE PT, AND DOESN'T CLOBBER F OR T.
;ON RETURN, PT IS UNCHANGED, RRHPOS AND RRVPOS
;ARE CORRECT, AND F,T CONTAIN THE V AND HPOS OF A PLACE ON THE SCREEN
;BEFORE WHICH NOTHING NEEDS TO CHANGE.
;CLOBBERS A,AA,TT,TT1,IN,OUT
RRCRDI:	SAVE CH
	SAVE PT
	CALL RRCRDB	;MOVE BACK TO BEFORE ALL BEFORE-EFFECTS.
	MOVE IN,PT
	CAMN IN,(P)	;IF WE DIDN'T MOVE BACK AT ALL, NO PROBLEM.
	 JRST RRCRDX
	SUB IN,BEG	;ELSE REMEMBER HOW FAR BACK WE MOVED,
	EXCH IN,(P)	;RELATIVE TO BEG IN CASE BUFFER MOVES.
	MOVEM IN,PT	;GIVE PT THE RIGHT VALUE FOR USER'S RTN,
	MOVE CH,-1(P)	;AND CH.
	MOVE T,RRHPOS	;GET HPOS AND VPOS OF PLACE WE MOVED BACK TO,
	MOVE F,RRVPOS	;TO RETURN TO OUR CALLER.
	XCT @-2(P)	;DO WHAT CALLER WANTED DONE.
	MOVE IN,(P)	;SET PT TO WHERE WE MOVED BACK TO
	ADD IN,BEG
	EXCH IN,PT	;BUT REMEMBER ITS REAL VALUE.
	MOVEM IN,(P)
RRCRD1:	CALL RRFORW	;THEN MOVE FWD OVER WHAT WE MOVED
	CAME IN,(P)	;BACK OVER.
	 JRST RRCRD1
	SUB P,[1,,1]
	JRST POPCH1

RRCRDX:	MOVE T,RRHPOS	;NO PROBLEM OF BEFORE-EFFECTS, JUST
	MOVE F,RRVPOS	;RETURN THE HPOS AND VPOS, AND EXIT
	SUB P,[1,,1]	;TO THE USER'S BUFFER-MUNGING INSN.
	JRST POPCHJ

RRCRDB:	MOVE IN,PT
	SUBI IN,1	;ARE WE AFTER A CR? IF SO, IT MAY CHANGE FORM.
	CAMGE IN,BEGV
	 POPJ P,	;AT BEGINNING OF BUFFER, NO PROBLEM.
	CALL GET	;ARE WE AFTER A CR?
	CAIN CH,^M	;IF SO, IT MIGHT CHANGE FORM.
	 CALL [	SKIPL DISPCR	;IF IT CAN COME OUT AS "^M"
		 JRST RRBACK	;THEN IT CAN PROPAGATE BEFORE-EFFECTS.
		JRST POP1J]	;ELSE, IT GUARANTEES NO BEFORE-EFFECTS.
	MOVE IN,PT
	SUBI IN,2	;IF IN HORIZ. POS. 0, AND
	SKIPG RRHPOS
	CAMGE IN,BEGV	;NOT NEAR THE BEGINNING OF BUFFER,
	 POPJ P,
	CALL GET	;AND NOT SHORTLY AFTER A CR (NOTE THIS
	CAIE CH,^M	;CATCHES A PRECEDING CRLF) PERHAPS "!"
	 CALL RRBACK	;MUST BE WRITTEN OR ERASED AT END OF PREVIOUS LINE.
	POPJ P,

;[ ;HANDLE THE ^] COMMAND IN ^R MODE.
;CLOBBERS ALL ACS. SKIPS.
RRBRC:	SKIP
	MOVEI A,[ASCIZ /[0[1MU0:I1
<^V^:FT0 FIU0 :I110 Q0-."N0;'>
F:M(Q1(]1]0))/]

RRMAC0:	CALL RRARGD	;SUPPLY ^R-STYLE NUMERIC ARG AS ARG TO MACRO.
	MOVEM B,NUM	;SUPPLY THE COMMAND'S ARG, OR 1 (THE DEFAULT), TO THE MACRO,
	TRZ FF,ARG
	SKIPE RRARGP
RRMAC6:	 IORI FF,ARG	;AND TELL IT IT HAS AN ARG IF THE ARG IS NON-DEFAULTED.
	JRST RRMAC5

;CALL THE MACRO IN A WITH NO ARG., AND LOOK AT ITS RETURNED VALUES TO DECIDE
;HOW TO UPDATE THE ^R-MODE VARIABLES.
RRMACR:	ANDCMI FF,ARG
	SETZM NUM
RRMAC5:	ANDCMI FF,ARG2\COLONF\SYLF\OPFLG	;IN ANY CASE THE MACRO DOESN7T HAVE 2 ARGS.
	SETZM SARG
	CALL RRLEAV	;SET UP THE "RRE" VARIABLES.
	CALL MACXQW	;EXECUTE THE MACRO.
	JRST RREAR0

RREAR0:	TRZ FF,NOTF	;EXECUTING COMMANDS CLOBBERS NOTF, SO RESTORE IT
	MOVE A,DISPRR
	SKIPE -3(A)
	 IORI FF,NOTF	;TO SAY WHETHER THIS IS ^R OR ^ V.
RREARG:	SKIPN ECHOFL
	 JRST RREAR1
	SYSCAL TTYSET,[1000,,TYIC
		[121212,,121212]
		[130212,,121212] ]
	 .LOSE 1400
	SETZM ECHOFL
RREAR1:	CALL VBDACU	;MAKE SURE FS ALTCOUNT IS IN PHASE WITH REALITY
	 JFCL
	MOVE B,NLINES
	CALL WINSET	;COMPUTE SIZE AND POS OF WINDOW, SET RRTOPM. RRBOTM, BOTLIN, VSIZE.
	MOVMS DISTRN	;TRUNCATION SCREWS ^R-MODE.
	.I RRHPOS=RREHPS
	.I RRVPOS=RREVPS
	MOVE A,BEG	;RELOCATE ALL ^R-MODE POINTERS INTO BUFFER.
	SUB A,RREBEG
	SETZM RREBEG	;DECLARE ^R IN CONTROL; PREVENT ^G INT LVL QUIT.
	CALL RRFXRL
	SKIPG NOQUIT	;NOW THATNEW QUITS ARE INHIBITED BY RREBEG, FLUSH OLD ONES,
	 SETZM STOPF	;UNLESS WE'RE IGNORING THEM NOW ANYWAY.
	CALL RRTTYE	;ON TTY IN SCAN MODE, ECHO COMAND UNLESS IT TYPED SOMETHING (UNLESS 1 VALUE).
	MOVE B,QRB..
	SKIPE MORFLF	;IF OUR MACRO RAN INTO A --MORE--FLUSHED,
	 SETOM TYOFLG	;DON'T LET IT STAY AROUND TO PLAGUE NEXT COMMAND,
	SKIPE MORFLF
	 SETZM .QVWFL(B)	;AND WE CAN ALSO REDISPLAY RIGHT NOW.
	SETZM MORFLF
	SKIPN .QVWFL(B) ;IF ANYTHING HAS BEEN TYPED OUT, WE MUST AT THE VERY LEAST
	 JRST RREAR2
	SETOM RROVPO	;REPOSITION THE TERMINAL'S CURSOR.
	CALL TYI	;AND WAIT TILL USER TYPES A CHARACTER SAYING
	CAIE CH,40
	 MOVEM CH,UNRCHC ;HE HAS READ THE STUFF (DON'T FLUSH THE CHARACTER).
	.I RRMNVP=TOPLIN ;NOW MAKE SURE THAT AFTER PROCESSING THIS CHARACTER
	SETZM RRMNHP	;THE BUFFER IS REDISPLAYED OVER THE TYPEOUT.
	HRLOI TT,377777
	MOVEM TT,RRMAXP
RREAR2:	MOVE B,NUM	;GETARG WANTS 2ND VALUE IN B.
	MOVE C,SARG	;AND 1ST VALUE IN C.
	TRNN FF,ARG	;MACRO RETURNED NO ARG =>
	 JRST RRMAC1	;DON'T ASSUME ANYTHING.
	TRNN FF,ARG2	;1 ARG => ONLY PT HAS CHANGED.
	 JRST RRMAC3
	ADDM A,RREPT	;RELOCATE OUR SAVED PT AND Z
	ADDM A,RREZ	;TO CANCEL EFFECTS OF BUFFER MOTION.
	CAML C,B
	 EXCH B,C	;DO F^@ - PREVENT 2<1 ERROR BY ORDERING THE ARGS PROPERLY.
	CALL GETARG	;TURN MACRO'S VALUES INTO CHAR ADDRS.
	 CALL CHK1
	MOVE TT,GEA
	ADD TT,BEGV
	MOVE F,TOPLIN
	SOS F
	SKIPL GEA	;FIND VPOS OF EARLIEST PLACE CHANGED.
	 MOVEM TT,LINBEG+1(F)
	SETZ A,
RRMAC2:	CAMN F,BOTLIN
	 JRST RRMAC3	;ALL CHANGES ARE OFF END OF SCREEN.
	CAML F,RRMNVP
	 JRST RRMAC4
	LDB TT,[3300,,LINBEG+1(F)]
	CAMGE TT,C
	 AOJA F,RRMAC2	;ALL CHANGES WERE AFTER THIS LINE.
RRMAC4:	CAMGE F,TOPLIN
	 JRST RRMAC1	;IF CHANGES REACH PAST TOP, NO SIMPLE ANSWER.
	MOVE TT,Z
	SUBM TT,RREZ	;RREZ _ CHANGE IN # CHARS IN BUFFER.
	SAVE PT
	MOVEM F,RRVPOS	;SET PT, RRVPOS AND RRHPOS TO VALUES
	LDB TT,[3300,,LINBEG(F)]
	MOVEM TT,PT	;AT START OF LINE ON WHICH 1ST CHANGE LIES.
	MOVE TT,LINBEG(F)
	ASH TT,-33
	MOVEM TT,RRHPOS
	CALL RRMOV	;SET THEM TO VALUES AT 1ST CHANGED PLACE
	CALL RRCRDB	;MOVE BACK TO ELIMINATE BEFORE-EFFECTS.
	MOVE T,RRHPOS	;WE ARE JUST BEFORE 1ST PLACE ON SCREEN
	MOVE F,RRVPOS	;THAT WAS CHANGED. MARK THIS AS PLACE
			;THAT REDISPLAY MUST START BEFORE.
	REST C		;GET BACK CORRECT PT, MOVE FWD TO THERE
	CALL RRMOV	;RRHPOS AND RRVPOS NOW CORRECT.
	MOVE C,B
	SKIPA A,RREZ
RRFXM1:	 MOVE C,PT
	CALL RRDLB2
;UPDATE RRMAXP. SIGNED # CHARS INSERTED OR DELETED IN A,
;PLACE INSERTED OR DELETED IN C.
RRFXMX:	MOVE T,RRMAXP	;NOTE RRMAXP MAY HAVE THE SPECIAL VALUE INFINITY (LARGEST POS NUMBER)
	AOS T
	CAILE T,1	;IN WHICH CASE IT SHOULDN'T BE RELOCATED.
	 ADDM A,RRMAXP	;RELOCATE OLD VALUE IN CASE IT'S ABOVE WHERE CHANGE HAPPENED.
	CAML C,RRMAXP
	 MOVEM C,RRMAXP	;MAKE SURE RRMAXP IS ABOVE PLACE CHANGE HAPPENED.
	POPJ P,

;UPDATE THE "MINIMUM SCREEN POSITION THAT CHANGED"
;USING DICTIONARY ORDER ON RRVPOS, RRHPOS.
RRDLB2:	CAMLE F,RRMNVP
	 POPJ P,
	EXCH F,RRMNVP
	CAMG F,RRMNVP
	CAMG T,RRMNHP
	 MOVEM T,RRMNHP
	POPJ P,

RRCTLL:	SKIP		;^L COMMAND.
	SKIPE RRARGP	;^L WITH ARG PRINTS SPEC'D # OF LINES (FOR PRINTING TTY'S).
	 JRST RRDISL
	CALL CTLL
RRMAC1:	SETOM RRMNVP	;CAUSE WINDOW TO BE TESTED,
	HRLOI TT,377777
	MOVEM TT,RRMAXP	;AND THE WHOLE BUFFER TO BE REDISPLAYED.
	JRST RRBTCR	;IN CASE THAT DOESN'T HAPPEN FOR A WHILE
			;MAKE SURE WE HAVE A REASONABLE RRHPOS.

RRDISL:	CALL CRR	;HERE FOR <N>^L;  DISPLAY <N> LINES OF BUFFER.
	CALL RRARGD
	CALL WINSET	;SET WINDOW SIZE TO <N> LINES.
	CALL RRDISP	;DO THE DISPLAY.
	MOVE B,NLINES	;RESTORE NORMAL WINDOW SIZE.
	JRST WINSET

RRMAC3:	ADDB A,RREPT	;RELOCATE OLD PT FOR BUFFER MOTION.
	CAML A,BEGV	;OLD CURSOR-LOCATION NO LONGER INSIDE BUFFER =>
	 CAMLE A,ZV	;CAN'T MOVE FROM THERE, MUST REDISPLAY SLOW WAY.
	  JRST RRMAC1
	EXCH A,PT	;THAT IS WHERE RRHPOS AND RRVPOS ARE
	MOVE C,A	;RIGHT FOR. SO MOVE FROM THERE TO NEW PT
	CALL RRMOV
RRTTY:	SKIPN RGETTY		;ON PRINTING TERMINAL IN SCAN MODE,
	 SKIPN RRSCAN
	  RET
	MOVE A,RRVPOS		;SHOW THE USER THE CURSOR MOTION IN SOME NICE WAY.
	SUB A,RREVPS		;UNLESS WE'RE ON THE SAME LINE, OR THE NEXT ONE,
	SKIPE A
	 SOJN A,RRTTY1		;LET USER DECIDE WHETHER TO REDISPLAY THE BUFFER.
	MOVE B,PT
	MOVE C,RREPT		;FORWARD HORIZONTAL MOTION => TYPE CHARS MOVED OVER.
	MOVEI D,TYO
	CAMGE C,B
	 JRST TYPE1
	CALL RRMVC		;BUT IF BACKWARD MOTION, JUST MOVE BACK TO HPOS, BUT
	MOVEI A,^J
	MOVEM A,RUBENC		;MAKE SURE WE TYPE A LF BEFORE TYPING ANYTHING ON THIS LINE.
	RET

RRTTYE:	TRNN FF,ARG2	;HERE FROM RREARG - HANDLE ALL BUT SINGLE-VALUE COMMANDS.
	 TRNN FF,ARG	;THEY ARE HANDLED SPECIALLY BY RRMAC3.
	  SKIPN RRSCAN
	   RET
RRTTY1:	MOVE B,QRB..	;NOW, IF IN SCAN MODE AND THIS COMMAND DIDN'T TYPE ANYTHING,
	SKIPN .QVWFL(B)
	 SKIPGE RROVPO
	  SKIPE RGETTY
	   RET
	SKIPE CH,RRLAST	;THEN ECHO IT.  NOTICE THAT ARG-SETTING COMMANDS LOSE.
	 CALL FSECO1
	RET

RUBEND:	SAVE CH		;AND IF THERE'S ANYTHING TO TYPE (SUCH AS LF AFTER
	SKIPE CH,RUBENC	;BACKWARD MOTION IN ^R MODE), TYPE IT.
	 CALL FSECO1
	SETZM RUBENC
	JRST POPCHJ

RRERST:	SAVE Q
RRERS1:	CAML CH,DISPRR	;POPPING OUT OF A MACXQ: POPPING OUT OF A ^R-INVOCATION?
	 JRST POPQJ
	SOS Q,DISPRR	;IF SO, RESTORE DISPRR'S VALUE OUTSIDE THAT INVOCATION.
	POP Q,DISPRR
	SKIPE DISPRR	;IF THIS ^R WAS THE OUTERMOST,
	 JRST RRERS1
	SAVE TT
	SAVE TT1
	SAVE CH
	CALL SETTTM	;RESTORE NORMAL TTYSET.
	REST CH
	REST TT1
	REST TT
	JRST POPQJ

;<CHAR>FS ^R INIT$ RETURNS THE INITIAL SETTING OF <CHAR>FS ^R CMAC$.
;THE UPARROW FLAG HAS THE SAME MEANING AS FOR FS ^R CMAC$.
FSCRIN:	TRZN FF,ARG
	 TYPRE [WNA]
	CALL TYIABN		;IF DON'T HAVE UPARROW FLAG, CONVERT ASCII ARG TO 9-BIT.
	MOVEI CH,(B)
	TRZN CH,META
	 TRNN B,CONTRL
	  SKIPA A,[RRXINS]	;META OR NON-CONTROL CHARS ARE SELF-INSERTING (EXCEPT RUBOUT)
	   MOVEI A,RRERR	;MOST CONTROLS ARE ERRORS.
	LDB Q,[.BP 177,CH]
	CAIL Q,40+"A
	 CAILE Q,40+"Z
	  CAIA			;IF THE ASCII PART IS LOWER CASE,
	   MOVE A,[40,,RRINDR]	;IT IS A "RRINDR" CHAR (INDIRECT).
	CAIN CH,CONTRL+33	;CONTROL-ALTMODE GOES INDIRECT THROUGH ALTMODE.
	 MOVE A,[200,,RRINDR]	;AND SIMILAR FOR CONTROL-META-ALTMODE.
	CAIL CH,CONTRL+^H	;SIMILAR FOR CONTROL-BS, CONTROL-TAB, CONTROL-LF,
	 CAILE CH,CONTRL+^J	;CONTROL-CR, AND META EQUIVALENTS.
	  CAIN CH,CONTRL+^M
	   MOVE A,[200,,RRINDR]
	CAIL CH,CONTRL+"H
	 CAILE CH,CONTRL+"J
	  JRST FSCRI1
	MOVE A,[300,,RRINDR]
	JRST POPJ1

FSCRI1:	CAIN B,33		;ALTMODE ON TV IS NOT SAME AS CTL-[  ;]
	 MOVEI A,RREXIT
	CAIN B,^M		;SIMILARLY, HANDLE CR (WHICH IS NOT CTL-M)
	 MOVE A,[RRCRLF,,RRREPT]
	CAIL B,^H
	 CAILE B,^J
	  CAIA
	   MOVE A,[RRINSC,,RRREPT]
	CAIL B,CONTRL+"0	;CONTROL-DIGITS ALL ADD TO ARGUMENT TO NEXT CMD.
	 CAILE B,CONTRL+"9
	  CAIA
	   MOVEI A,RRCDGT
	CAIN B,177		;RUBOUT IS A RUBOUT.
	 MOVEI A,RRRUB
	CAIN B,CONTRL+177	;CTL-RUBOUT IS TAB-HACKING RUBOUT.
	 MOVEI A,RRCRUB
	CAIL B,CONTRL+"@
	 CAILE B,CONTRL+"_
	  JRST POPJ1
	SUBI B,CONTRL+"@	;AS A LAST RESORT, LOOK CHAR UP IN RRITAB.
	ROT B,-1
	HRRZ A,RRITAB(B)	;INDEX TO HALFWORD OF INITIAL VALUE TABLE.
	SKIPL B
	 HLRZ A,RRITAB(B)
	TRZN A,400000		;400000 BIT => DEFINITION GOES THROUGH RRREPT.
	 JRST POPJ1
	HRLZS A
	HRRI A,RRREPT
	JRST POPJ1


;TABLE OF INITIAL ^R-MODE DEFINITIONS OF CONTROL CHARACTERS.
.SEE RRMACT	;CHANGE RRMACT WHEN YOU CHANGE THIS.
.BYTE 22
RRITAB:	RRERR		;^@
	RRBEG		;^A
	RRCTLB		;^B
	RRCMSW		;^C
	RRCTLD		;^D
	RREND		;^E
	RRCTLF		;^F
	RRQUIT		;^G
	RRINDR		;CONTROL-H (THIS ENTRY NOT ACTUALLY USED)
	RRINDR		;CONTROL-I    "
	RRINDR		;CONTROL-J    "
	RRKILL		;^K
	RRCTLL		;^L
	400000+RRINSC	;CONTROL M
	RRNEXT		;^N
	400000+RRCTLO	;^O
	RRPREV		;^P
	RRQUOT		;^Q
	RRCMCS		;^R
	RRSRCH		;^S
	RRMARK		;^T
	RR4TIM		;^U
	RRARG		;^V
	RRFX		;^W
	RREXCH		;^X
	RRERR		;^Y
	RRERR		;^Z
	RRERR		;CONTROL-[  ;]
	RRERR		;^\
	RRBRC		;[ ;^]
	RRERR		;^^
	RRERR		;^_
.BYTE

;GET OR SET THE MACRO ASSOCIATED WITH A CHARACTER
;(IF A CHAR HAS AN ASSOCIATED MACRO, WHEN THAT CHAR IS READ IN
;^R-MODE, THE MACRO IS CALLED INSTEAD OF THE USUAL ACTION FOR
;THAT CHARACTER.)
;^^<CHAR>FS^RCMAC$ GETS, Q<QREG>,^^<CHAR>FS^RCMAC$ SETS.
;CHARACTER IS ASSUMED TO BE ASCII. IF UPARROW FLAG IS ON,
;THE CHARACTER IS TREATED AS 9-BIT INSTEAD.
;DEPOSITS IN -1(P)! ASSUEMS THE CALLER WAS THE FS COMMAND DISPATCH!
FSCRMA:	TRZN FF,ARG
	 TYPRE [WNA]
	TRZE FF,ARG2
	 IORI FF,ARG	;2 ARGS => SETTING, ELSE GETTING.
	CALL TYIABN	;IF SLSL OFF, CONVERT ASCII ARG TO 9-BIT.
	MOVE C,B
	MOVE B,SARG
	CAIGE C,RRMACL	;LAST ARG OUT OF RANGE => ERROR.
	SKIPGE C
	 TYPRE [AOR]
	ADDI C,RRMACT	;C -> WORD TO BE SET OR GOTTEN.
	HRLM C,-1(P)	.SEE FSCALL
	JRST FSNOR1

TYIABN:	TRZN FF,SLSL	;IF SLSL IS OFF, CONVERT ASCII CHAR IN B TO 9-BIT.
	 CAIL B,40
	  RET
	CAIE B,33
	 CAIN B,^M
	  RET
	CAIL B,^H
	 CAILE B,^J
	  ADDI B,300
	RET

;<M>,<N>FM - MOVE DOWN TO HPOS <N>, <M> LINES DOWN.
;<M>,<N>^ FM - MOVE UP TO HPOS <N>, -<M> LINES UP.
;NORMALLY, EXACT VALUE OF HPOS IS NEEDED TO STOP SCAN.
;BUT COLON MODIFYER => ANY LARGER HPOS IS ALSO OK.
;IF SCAN DOESN'T FIND AN ACCEPTABLE HPOS ON THE DESIRED LINE
;THEN EITHER A NIB ERROR OR A NHP ERROR WILL RESULT.
;FM TRIES TO AVOID STOPPING BETWEEN A CR AND ITS LF.
FMCMD:	TRNE FF,ARG2
	 TRNN FF,ARG
	  TYPRE [WNA]
	CALL RRBTCR	;MAKE SURE RRHPOS IS CORRECT FOR CURRENT BUFFER AND PT.
	ADD C,RRVPOS	;C IS DESTINATION VPOS.
	MOVE IN,PT
	TRNE FF,SLSL
	 JRST FMBACK	;NOW FORWARD AND BACKWARD MOTION DIVERGE.
FMFWD:	CAMGE C,RRVPOS	;IF WENT PAST TARGET LINE, WITHOUT STOPPING ON IT, BARF.
	 JRST [ CALL RRBCRL	;MOVE BACK TO END OF DESIRED LINE.
		TYPRE [NHP]]
	CAME C,RRVPOS	;IF HAVE REACHED TARGET VPOS,
	 JRST FMFWD1
	TRNE FF,COLONF
	 CAML B,RRHPOS	;AND HAVE REACHED TARGET HPOS,
	  CAMN B,RRHPOS
	   RET
FMFWD1:	CAML IN,ZV
	 TYPRE [NIB]	;AT END OF BUFFER WITHOUT REACHING TARGET => BARF.
	CALL RRFORW
	JRST FMFWD

FMBACK:	CAMLE C,RRVPOS	;WENT PAST TARGET VPOS WITHOUT FINDING TARGET HPOS => BARF.
	 JRST [	CALL RRFCRL	;RETURN TO DESIRED LINE BEFORE COMPLAINING.
		TYPRE [NHP]]
	CAME C,RRVPOS	;REACHED TARGET VPOS
	 JRST FMBAC1
	TRNE FF,COLONF
	 CAML B,RRHPOS
	  CAMN B,RRHPOS
	   RET
FMBAC1:	CAMG IN,BEGV
	 TYPRE [NIB]
	CALL RRBCRL
	JRST FMBACK

;MOVE FORWARD OVER EITHER A SINGLE CHAR OR A CRLF.
RRFCRL:	CALL RRFORW
	CAIE CH,^M
	 RET
	CALL GET
	CAIE CH,^J
	 RET
	JRST RRFORW

;MOVE BACKWARD OVER EITHER A SINGLE CHAR OR A CR-LF PAIR.
RRBCRL:	CALL RRBACK	;MOVE BACK 1 CHAR,
	CAIE CH,^J	;AND IF THAT LEAVES US BETWEEN A CR AND ITS LF,
	 RET		;MOVE BACK 1 MORE.
	SOS IN
	CALL GETINC
	CAIE CH,^M
	 RET
	JRST RRBACK

;RTNS TO HANDLE THE MARK.

;SET THE MARK AT PT.
RRMARK:	SKIP
	SKIPE RR4TCT	;^U^T EXCHANGES MARK WITH PT.
	 JRST RREXCH
RRMRK1:	.I RRMKPT=PT-BEG
	POPJ P,

;EXCHANGE THE MARK AND PT.
RREXCH:	SKIP
	SKIPGE C,RRMKPT
	 JRST RRERR	;NO MARK => CAN'T EXCHANGE.
	ADD C,BEG	;TURN INTO CHAR ADDR.
	SAVE PT		;REMEMBER NEW VALUE OF MARK.
	CALL RRMOV	;MOVE PT TO OLD MARK.
	REST TT		;SET MARK TO OLD PT.
	SUB TT,BEG
	MOVEM TT,RRMKPT
	JRST RRTTY		;ON PRINTING TERMINAL, GO SHOW CURSOR MOTION.

;SET PT TO VALUE IN C, UPDATING CURSOR POS.
;CLOBBERS A,AA,TT,TT1,IN,OUT
RRMOV:	CAMN C,PT	;PT SAME AS MARK => DO NOTHING.
	 POPJ P,
	CAML C,PT
	 JRST RRMOVF	;PT BEFORE DESIRED PT => GO FWD.
RRMOVB:	CALL RRBACK
	CAMN C,IN	;REACHED THE DESIRED PT YET?
	 RET
	SKIPL RRVPOS	;GONE ABOVE TOP OF SCREEN?
	 JRST RRMOVB
RRMOVL:	MOVEM C,PT	;IT'S PROBABLY FASTER TO REQUEST COMPLETE RECOMPUTATION.
	JRST RRMAC1

RRMOVF:	CALL RRFORW
	CAMN C,IN
	 RET
	MOVE TT,RRVPOS
	CAMG TT,BOTLIN	;GONE BELOW BOTTOM OF SCREEN?
	 JRST RRMOVF
	JRST RRMOVL

;DO FX..K ON EVERYTHING FROM PT TO THE MARK.
RRFX:	SKIP
	SKIPGE A,RRMKPT
	 JRST RRERR
	ADD A,BEG
	CAMN A,PT	;DELETING NO CHARS =>
	 JRST RRFXXT	;DON'T CLOBBER QREG ..K.
	CAMG A,PT
	 CALL RREXCH	;MAKE SURE PT IS BEFORE MARK.
	MOVE C,PT
	MOVE A,RRMKPT
	ADD A,BEG
	MOVE B,A
	SUBM C,A
	CALL RRFXMX	;SET RRMAXP
	CALL RRCRDI	;WORRY ABOUT BEFORE-EFFECTS.
	 CALL [	CALL RRDLB2	;SET RRMNVP, RRMNHP FROM T,F.
		MOVE CH,QRB..
		ADDI CH,.QRRBF
		CALL FXCMD2	;DO THE FX. E _ AMOUNT BEG CHANGED.
		MOVE A,E
		JRST RRFXRL]	;RELOCATE VARIOUS PTRS THAT MUCH
RRFXXT:	SETOM RRMKPT	;ELIMINATE THE MARK.
	POPJ P,

;RELOCATE RR MODE'S VARIOUS PTR THAT ARE KEPT AS CHAR ADDRS,
;BY THE AMOUNT IN A. (IN CASE THE BUFFER WAS MOVED)
;CLOBBERS TT
RRFXRL:	MOVE TT,RRMAXP	;NOTE THAT IF RRMAXP IS INFINITY IT SHOULDN'T BE CHANGED.
	AOS TT
	CAILE TT,1	;ALSO IF IT IS ZERO.
	 ADDM A,RRMAXP
	ADDM A,RROLDZ
	SETZ TT,
RRFXR1:	ADDM A,LINBEG(TT)
	CAME TT,USZ
	 CAIN TT,MXNVLS
	  RET
	AOJA TT,RRFXR1

;KILL <ARG> LINES STARTING AT PT, AND PUT IN QREG ..K.
RRKILL:	CALL RRARGD
	CALL RRMRK1
	CALL RRNEX1
	JRST RRFX

;^S -- READ CHAR, AND SEARCH FOR THAT CHAR.
RRSRCH:	CALL RRARGD
	SAVE B
	CALL RRECO1	;MAYBE PROMPT WITH A ^S.
	REST NUM
	MOVEI A,[ASCIZ/FIU..0 :S..0 /]
	JRST RRMAC6

RRCTLB:	CALL RRARGD		;^B MOVES BACKWARD - IT IS -^F.
	MOVNS B
	CAIA
RRCTLF:	 CALL RRARGD		;^F MOVES FORWARD, BUT ON PRINTING TTY IT ECHOES.
	SAVE [RRTTY]
	JUMPL B,RRCB1		;WORK FOR NEGATIVE ARGS.
	JSP C,RRREP1
	JRST RRFORW

RRCB1:	MOVNS B
	JSP C,RRREP1
	JRST RRBACK

;JSP C,RRTYPP  SKIPS UNLESS WE ARE SCANNING (SHOULD PRINT SCANNED CHARACTERS).
RRTYPP:	SKIPN RGETTY
	 SKIPN RRSCAN
	  JRST 1(C)
	JRST (C)

;^P -- WITH ARGUMENT <N>, DOES -<N>L.
RRPREV:	CALL RRARGD	;CALCULATE <N>,
	MOVNS B
	JRST RRNEX2	;<N> IS -<N>.

;^A -- MOVE TO BEGINNING OF LINE.
;WITH ARGUMENT <N>, DOES <N>-1L.
RRBEG:	CALL RRARGD
	SOJA B,RRNEX3

;^E -- MOVE TO END OF LINE (:L).  WITH ARGUMENT <N>, DO :<N>L.
RREND:	SKIP
	CALL RRARGD
RREND1:	TRO FF,COLONF
	JRST RRNEX3

;^N -- MOVE TO BEGINNING OF NEXT LINE. (L)
;WITH ARGUMENT <N>, DOES <N>L.
RRNEXT:	CALL RRARGD	;^N MUST DO ITS OWN ARG HACKING
RRNEX2:	SAVE [RRCMIN]	;DO COMMENT-MODE STUFF AT START AND FINISH OF MOTION.
	CALL RRCMRU
RRNEX3:	SAVE [RRTTY]
	MOVE IN,PT
	CALL GETAG4	;COMPUTE WHERE WE'RE GOING TO.
	 JFCL
	ADD C,B		;THE WAY THE L COMMAND DOES.
	SUB C,PT
	JRST RRMOV	;THEN GO THERE.

;CALL HERE WHEN LEAVING A LINE.
;IN COMMENT MODE, TAB-SEMI'S ARE REMOVED BY THIS RTN.
RRCMRU:	SKIPGE RRCMMT
	 POPJ P,	;DO NOTHING IF NOT COMMENT MODE.
RRCMR1:	SAVE B
	MOVEI B,1
	CALL RREND1
	REST B
	MOVE IN,PT
	CAMG IN,BEGV
	 POPJ P,	;DO NOTHING AT BEGINNING OF BUFFER.
	SOS IN
	CALL GET	;IF CHAR BEFORE PT IS A SEMI,
	CAIE CH,";
	 POPJ P,
RRCMR0:	CALL RRDLB	;DELETE IT, AND ANY TABS BEFORE IT.
	MOVE IN,PT
	CAMG IN,BEGV
	 POPJ P,
	SOS IN
	CALL GET
	CAIE CH,^I
	CAIN CH,40
	 JRST RRCMR0
	POPJ P,

RRCMS1:	SETZ B,
	CALL RRNEX1

;CALL HERE WHEN ENTER A LINE.
;IN COMMENT MODE, TAB-SEMI WILL BE INSERTED.
RRCMIN:	SKIPGE RRCMMT
	 RET		;NOT COMMENT MODE.
RRCMI0:	MOVE IN,PT	;MOVE UP TO EXISTING COMMENT
	CALL RREOLT	;OR END OF LINE.
	 JRST RRCMI1	;REACHED END, INSERT TAB-SEMI.
	CALL GET
	CAIN CH,";
	 JRST RRFORW	;REACHED SEMI, STOP AFTER IT.
	CALL RRFORW
	JRST RRCMI0	;ELSE KEEP LOOKING.

RRCMI1:	MOVEI CH,^I	;INSERT TABS TILL REACH COMMENT COLUMN
	CALL RRINS
	MOVE A,RRHPOS
	CAMGE A,RRCCOL	;REACHED THE COMMENT COLUMN?
	 JRST RRCMI1	;NO, MORE TABS TO INSERT.
	MOVEI CH,";	;YES, INSERT THE SEMI.
	JRST RRINS

;^C -- COMPLEMENT COMMENT MODE.
RRCMSW:	CALL RRARGD	;IF NUMERIC ARG, IT IS SETTING OF COMMENT COLUMN.
	CAIE B,1
	 MOVEM B,RRCCOL
	AOSE A,RRCMMT	;IF WAS -1, MAKE IT 0.
	 SETOB A,RRCMMT	;WAS >=0, MAKE IT -1.
	CALL RRECSP	;THEN INDICATE WHICH MODE WE'RE IN.
	MOVE CH,(A)1+[ "T ? "C ]
	CALL FSECO1
	XCT (A)1+[CALL RRCMR1	;LEAVING COMMENT MODE, REMOVE SEMI.
		CALL RRCMS1]	;WHEN ENTER COMMENT MD, INSERT SEMI.
;TYPE A SPACE IN THE ECHO REGION, MAKING SURE CURSOR WILL
;BE REPOSITIONED IN THE DISPLAY REGION. PRESERVE ALL ACS.
RRECSP:	SAVE CH
	MOVEI CH,40
	CALL FSECO1
	JRST POPCHJ

;^R -- SET COMMENT COLUMN FROM CURRENT HPOS.
RRCMCS:	SKIP A,RRHPOS
	SKIPGE RRCMMT	;NO EFFECT UNLESS IN COMMENT MODE.
	 POPJ P,
	MOVEM A,RRCCOL
	POPJ P,

;TABLES USED BY RRCHRG. THE ENTRY FOR EACH
;CHARACTER IS AN INDEX INTO RRFORT OR RRBACT.

RRCHBP:	REPEAT 6,<360600-<6*.RPCNT>_12.>,,RRCHTB(A)

;CODES IN RRCHTB ARE:
 ;0 - 1-POSITION CHARACTER.
 ;1 - ORDINARY CTL CHAR - USUALLY 2-POSITION, BUT 1-POSITION IN SAIL MODE.
 ;2 - BACKSPACE.
 ;3 - CR
 ;4 - LF
 ;5 - TAB.
 ;6 - SPECIAL CTL CHARACTER - 2-POSITION EVEN IN SAIL MODE.

RRCHTB:	.BYTE 6
	6		;^@
	1		;^A
	1		;^B
	1		;^C
	1		;^D
	1		;^E
	1		;^F
	6		;^G
	2		;^H
	5		;^I
	4		;^J
	1		;^K
	1		;^L
	3		;^M
	1		;^N
	1		;^O
	1		;^P
	1		;^Q
	1		;^R
	1		;^S
	1		;^T
	1		;^U
	1		;^V
	1		;^W
	1		;^X
	1		;^Y
	1		;^Z
	0		;ALTMODE, 1 POSITION.
	1		;[ ;^]
	1		;^\
	1		;^^
	1		;^_
	.BYTE

] ;END IFN RMSSW,

IFN TS,[
EDIT:	CALL GAPSLP
	SKIPN ECHOFL
	 JRST EDIT9
	SYSCAL TTYSET,[1000,,TYIC
		[121212,,121212]
		[130212,,121212] ]
	 .LOSE 1400
	SETZM ECHOFL
EDIT9:	TRZ FF,ARG+ARG2+SLSL	;ARG ON = INSERT MODE, OFF = OVERWRITE MODE
				;ARG2 ON = IN IS POINTING TO CR
				;SLSL ON = BACKWARDS RUB MODE
	SETZM COMCNT
	MOVE AA,CBUFLO
	SKIPA IN,PT
ED0.0:	POP P,A		;PURGE EXTRA PUSHJ P,
ED0:	PUSHJ P,CRR
	TRZ FF,SLSL	;TURN OFF "\" FLAG
ED1:	IFN TS,PUSHJ P,DISFLS
	PUSHJ P,TYI
	CALL TYINRM
	MOVE A,CH
	MOVEI CH,"\
	CAIL A,40
	JRST EDLIS
	SKIPL B,EDDPTB(A)	;IS IT A RUBBACK COMMAND
	JRST ED11		;NO
	TRON FF,SLSL	;TURN ON "\" FLAG
ED12:	PUSHJ P,TYOA	;AND IF WAS OFF, TYPE "\"
ED13:	MOVE CH,A
	PUSHJ P,@B
	PUSHJ P,TYO
	JRST ED1

ED11:	TRZE FF,SLSL	;TURN OFF "\" FLAG
	JRST ED12	;IF IT WAS ON, PRINT "\"
	JRST ED13
BELL:	MOVEI CH,7
	PUSHJ P,TYOINV
	JRST CPOPJ1

EDLIS:	CAIE A,177
	JRST EDLIS1
	TRON FF,SLSL
	PUSHJ P,TYOA
	JRST .+3
EDLIS1:	TRZE FF,SLSL
	PUSHJ P,TYOA
	MOVE CH,A
	PUSHJ P,CKCH
	JRST ED0
	JRST ED1
	PUSHJ P,EDOV
	JUMPL CH,ED1
	PUSHJ P,TYO
	JRST ED1

ED%:	MOVEI CH,"#
	PUSHJ P,TYO
	PUSH P,IN
	PUSH P,FF
ED%1:	PUSHJ P,CGETIN
	JUMPL CH,ED%2	;END OF LINE OR BUFFER
	PUSHJ P,TYO
	JRST ED%1
ED%2:	POP P,FF
	POP P,IN
	PUSHJ P,CRR
	MOVE A,COMCNT
	JUMPLE A,CPOPJ1
	MOVE AA,CBUFLO
	ILDB CH,AA
	PUSHJ P,TYO
	SOJG A,.-2
	JRST CPOPJ1
EDOV:	MOVE A,CH
	TRNN FF,ARG	;IN INSERT MODE
	PUSHJ P,CGETIN	;NO
	SKIPA CH,A
EDCPY:	PUSHJ P,CGETIN
	JUMPL CH,CPOPJ
EDCPY1:	IDPB CH,AA
	AOS COMCNT
	POPJ P,
CGETIN:	MOVNI CH,1
	TRNE FF,ARG2
	POPJ P,
	CAML IN,ZV	;AT END OF BUFFER
	JRST CGETI1
	PUSHJ P,GET
	CAIN CH,15
CGETI1:	TROA FF,ARG2
	AOJA IN,CPOPJ
	MOVNI CH,1
	POPJ P,

EDCR:	PUSHJ P,CRR
EDCR2:	TRNE FF,ARG2
	JRST EDCR1
	PUSHJ P,CGETIN
	JRST EDCR2
EDCR1:	MOVE B,IN	;GET ADDR AFTER END OF OLD LINE,
	MOVE C,PT	;GET ADDR OF START OF IT,
	CALL DELET1	;TURN THAT INTO GAP.
	MOVE B,COMCNT	;NOW INSERT SPACE FOR NEW LINE,
	CALL SLPGET	;F GETS BP TO IDPB INTO SPACE.
	MOVE A,COMCNT
	JUMPE A,EDCR3
	MOVE AA,CBUFLO
	ILDB CH,AA
	IDPB CH,F
	SOJG A,.-2
EDCR3:	TRZ FF,ARG+SLSL+ARG2
	SETZM COMCNT
	SETOM UNRCHC
	TSOPEN TYIC,[['@TTY]]
	PUSHJ P,SETTTM
	JRST GO

RTYI:	PUSHJ P,TYI
	CALL TYINRM
	CAIE CH,177
	POPJ P,
	MOVEI CH,"\
	TRON FF,SLSL
	PUSHJ P,TYOA
	MOVE CH,A
	SUB P,[1,,1]
	POPJ P,

EDD:	PUSHJ P,CGETIN	;DELETE NEXT CHAR
	JUMPL CH,BELL	;BELL IF NONE
	MOVEI CH,"%
	POPJ P,
EDP:	MOVEI CH,"<	;COMPLEMENT STATE OF INSERT/OVERWRITE MODE
	TRCE FF,ARG
	MOVEI CH,">
	POPJ P,

EDS:	PUSHJ P,RTYI	;COPY THRU "T"
	MOVE A,CH
	PUSH P,IN
	PUSH P,FF
EDS1:	PUSHJ P,CGETIN
	TRNE FF,ARG2
	JRST EDS2	;AT EOL AND NOT FOUND
	CAME CH,A
	JRST EDS1	;KEEP LOOKING
	POP P,FF
	POP P,IN
	JRST EDN1
EDN:	PUSHJ P,EDCPY	;COPY THRU 1ST SPACE AFTER 1ST NON-SPACE OR TO EOL
	JUMPL CH,CPOPJ1
	PUSHJ P,TYO
	CAIN CH," 
	JRST EDN
	MOVEI A," 
EDN1:	PUSHJ P,EDCPY
	JUMPL CH,CPOPJ1
	PUSHJ P,TYO
	CAME CH,A
	JRST EDN1
	JRST CPOPJ1

EDS2:	POP P,FF
	POP P,IN
	JRST BELL

EDQ:	PUSHJ P,RTYI	;QUOTE NEXT CHAR
	JRST EDOV

EDT:	PUSHJ P,RTYI	;DELETE THRU "T"
	MOVE A,CH
	PUSH P,IN
	PUSH P,FF
EDT1:	PUSHJ P,CGETIN
	TRNE FF,ARG2
	JRST EDS2	;AT EOL AND NOT FOUND
	CAME CH,A
	JRST EDT1
	POP P,FF
	POP P,IN
	JRST EDO1
EDO:	PUSHJ P,CGETIN	;DELETE THRU NEXT SPACE AFTER 1ST NON-SPACE OR TO EOL
	JUMPL CH,CPOPJ1
	MOVE A,CH
	MOVEI CH,"%
	PUSHJ P,TYO
	CAIN A," 
	JRST EDO
	MOVEI A," 
EDO1:	PUSHJ P,CGETIN
	JUMPL CH,CPOPJ1
	CAMN CH,A
	SETOM A
	MOVEI CH,"%
	PUSHJ P,TYO
	JUMPL A,CPOPJ1
	JRST EDO1

EDR:	TROA FF,ARG+SLSL	;ARG ON = ECHO
EDL:	TRZ FF,ARG+SLSL	;SLSL ON = DONT END EDIT
EDL1:	TRNE FF,ARG2
	JRST EDL2
	PUSHJ P,EDCPY
	JUMPL CH,EDL2
	TRNE FF,ARG
	PUSHJ P,TYO
	JRST EDL1
EDL2:	TRZ FF,ARG
	TRZE FF,SLSL
	JRST CPOPJ1	;DON'T END EDIT
	PUSHJ P,CRR	;CR-LF THEN END EDIT
	JRST EDCR1

EDW:	LDB CH,AA	;RUBBACK TO 1ST NON-SPACE, THEN BACK TO 1ST SPACE
	CAIE CH," 
	JRST EDW1
	MOVEI CH,177
	PUSHJ P,CKCH
	JRST ED0.0
	JRST EDW
EDW1:	LDB CH,AA
	CAIN CH," 
	JRST CPOPJ1	;FOUND SPACE, QUIT
	MOVEI CH,177	;TO TELL CKCH TO RUBBACK
	PUSHJ P,CKCH
	JRST ED0.0		;NOTHING TO RUB
	JRST EDW1
	.VALUE	;SHOULD NEVER GET HERE

EDALT:	TRO FF,ARG	;COPY REST W/ ECHO AND END EDIT
	TRZ FF,SLSL
	JRST EDL1
]			;END OF IFN TS CONDITIONAL

1INS:	SKIPL DTB(CH)	;NEGATIVE INSTRUCTIONS DO NOT RETURN VALUE
	 JRST VALRET	;POSITIVE ONES RETURN VALUE

CD:	SETZM NUM	;FLUSH ANY ARGUMENT, OR : OR ^.
	TRZA FF,ARG+ARG2+OPFLG+SLSL+COLONF+SYLF
CD2B:	 TROA FF,OPFLG+ARG ;COME HERE FROM ARITH OPS, NEED 2ND ARG.
CD2A:	MOVSI A,(ADD B,);SET UP DLIM FOR THE DEFAULT
			 ;CONDITION OF ADDING THE OLD VALUE
			  ;WITH ANY NEW NUMBER ENTERED
	SETZM SYLOV	;RESET THE NUMERIC OVERFLOW FLAGS
	SETZM OSYLOV
	HLLM A,DLIM	;PUT THE APPROPRIATE OPERATOR AWAY
	CLEARM SYL	;CLEAR THE NEW NUMBER ENTERED
	CLEARM OSYL	;ALSO CLEAR ITS OCTAL INTERPRETATION
CD5:	MOVE A,QRWRT	;IF QREG SPACE HAS INCREASED BY
	CAML A,QRGCMX	;GCOFTN CHARS SINCE PREVIOUS GC,
	 PUSHJ P,GC	;GC THE QREGS.
CD5A:	SKIPGE STOPF	;IF THE USER HAS ^G'ED, TRY TO QUIT,
	 CALL QUIT0	;TRY TO QUIT (CHECK NOQUIT).
	MOVE AA,PT
	CAML AA,BEGV
	 CAMLE AA,ZV
	  .VALUE
	MOVE AA,BEG
	CAMGE AA,BFRBOT
	 .VALUE
	SKIPL @BFRPTR	;DETECT CLOBBERAGE OF MFBFR BIT OF SELECTED BUFFER.
	 .VALUE
	CALL RCH	;GET THE NEXT COMMAND CHARACTER
CDRCH:	TRNE CH,100	;CONVERT LOWER CASE TO UPPER.
	 ANDCMI CH,40
	SETZB AA,SQUOTP
	TRZ FF,NOTF ;RESET MORE FLAGS
	XCT DTB(CH)	;EXECUTE THE ENTRY FROM THE DISPATCH TABLE
CD5B:	TLZ FF,CTLUF	;RESET THE "DISPLAY THE FILE DIRECTORY BIT", THIS INSURES
			;THAT AN E COMMAND WILL ONLY DISPLAY THEBUFFER IF IT IS THE LAST COMMAND
	SKIPE SYLOV
	 TYPRE [%OV]	;#OV
	MOVE B,NUM	;GET THE OLD VALUE
	TRZN FF,SYLF
	 JRST CD5C
	JFCL 10,.+1	;CLEAR OVERFLOW FLAG
	XCT DLIM	;THEN PERFORM THE SAVED OPERATION
	JFCL 10,[TYPRE [%OV]]
	MOVEM B,NUM	;AND MAKE IT THE NEW OLD VALUE
CD5C:	MOVE C,SARG	;GET THE SECOND ARGUMENT TO THE COMMAND (IF ANY)
	JUMPE AA,1INS	;IF AA NOT CHANGED, THIS IS ONE INST. SUBR.
	JUMPGE AA,(AA)	;IF AA POSITIVE, THEN JUMP TO IT.
	PUSHJ P,(AA)	;IF AA NEGATIVE, PUSHJ
	 JRST CD	;NON-SKIP RETURNING COMMANDS DON'T RETURN VALUE
VALREC:	TROE FF,ARG	;IF HAVE ARG FROM BEFORE, NOT GOBBLED,
	 JRST VALRET	;DO ARITH. WITH IT & THIS CMD'S VALUE.
	MOVEM A,NUM	;IF NO ARG OR THIS CMD USED IT, ITS
	TRZ FF,OPFLG	;VALUE IS ALL THE ARG WE HAVE.
	JRST CD2A

CDNUM:	JFCL 10,.+1
	MOVE A,OSYL	;ASSEMBLE THIS DIGIT INTO A NUMBER
	IMUL A,I.BASE	;(USUALLY OCTAL)
	ADDI A,-60(CH)
	JFCL 10,CDNUM1
CDNUM3:	MOVEM A,OSYL
	MOVE A,SYL
	IMUL A,IBASE	;AND IN DECIMAL (USUALLY)
	ADDI A,-60(CH)
	JFCL 10,CDNUM4
CDNUM6:
VALRET:	MOVEM A,SYL	;SAVE IT AS A VALUE
	TRZ FF,OPFLG	;DON'T HAVE ARITH OP WAITING FOR 2ND ARG
CD7:	TRO FF,ARG+SYLF ;DECLARE THAT THERE IS AN ARGUMENT AND A CURRENT VALUE
	JRST CD5	;AND RETURN

CDNUM1:	TLC A,400000	;OVERFLOWING IMUL LEAVES RESULT POS IF ARGS WERE POS.
	MOVE B,I.BASE	;OVERFLOW HAPPENED USING I.BASE.
	JFFO B,CDNUM2	;UNLESS I.BASE IS A POWER OF 2,
	 .VALUE
CDNUM2:	LSH B,(E)
	CAME B,[SETZ]
	 SETOM OSYLOV	;SET THE "OVERFLOW USING I.BASE" FLAG.
	JRST CDNUM3	;IF THIS VALUE IS EVENTUALLY USED, "#OV" WILL RESULT.

CDNUM4:	TLC A,400000	;OVERFLOWING IMUL LEAVES ANSWER POS IF ARGS WERE POS.
	MOVE B,IBASE	;OVERFLOW HAPPENED USING IBASE.
	JFFO B,CDNUM5	;UNLESS IBASE IS A POWER OF 2,
	 .VALUE
CDNUM5:	LSH B,(E)
	CAME B,[SETZ]
	 SETOM SYLOV	;SET THE "OVERFLOW USING IBASE" FLAG.
	JRST CDNUM6	;IF THIS VALUE IS EVENTUALLY USED, "#OV" WILL RESULT.


;ARGDFL MACRO CALLS HERE IF OPFLG WAS SET, AFTER CLEARING IT.
;ARGDFL IS USED TO DEFAULT "-" TO "-1", ETC.
ARGDF0:	SETZM SYL	;PRETEND A "1" HAD PRECEDED THIS CMD,
	AOS SYL		;AFTER THE OPERATOR THAT NEEDS 2ND ARG,
	XCT DLIM	;DO THE ARITHMETIC,
	POPJ P,

PNT:	MOVE A,OSYL
	TRNE FF,SYLF
	JRST [	SETZM SYLOV
		SKIPE OSYLOV
		SETOM SYLOV
		JRST VALRET]
	MOVE A,PT
	SUB A,BEG
	JRST VALRET

CNTRAT:	ARGDFL Z,	;^@ - TAKES 1 ARG, RETURNS .,.+ARG OR .+ARG,.  .
	TRZE FF,ARG2
	 JRST [	MOVE A,B	;2 ARGS => RETURN THE DIFFERENCE.
		SUB A,C
		JRST POPJ1]
	MOVE AA,PT
	ADD B,PT
	MOVE A,B
	CAMG A,AA	;MAKE SURE ARGS ARE IN RIGHT ORDER.
	 EXCH A,AA
	JRST HOLE0

HOLE:	MOVE AA,BEGV
	MOVE A,ZV
HOLE0:	SUB AA,BEG	;RETURN 2 CHAR ADDRS AS VALUES.
	SUB A,BEG	;CHANGE THEM TO CHARACTER NUMBERS (REL TO BEG, THAT IS)
2VALS:	MOVEM AA,SARG	;RETURN 2 VALUES IN AA, A.
	TRO FF,ARG2
	JRST POPJ1

END1:	SKIPA A,ZV
BCMD:	MOVE A,BEGV
FSROC1:	SUB A,BEG
	JRST POPJ1

;F^X COMMAND - WITHIN MACRO, RETURN THE MACRO ARGS
;(AS MANY AS IT WAS CALLED WITH).
FCTLX:	TRZ FF,ARG+ARG2+OPFLG+SYLF
	SETZM NUM	;FLUSH ALL TRACES OF ARGUMENTS.
	SUB P,[1,,1]	;THROW AWAY RET ADDR (VALREC-1); WE WILL JUMP INTO COMMAND LOOP.
	MOVE A,MARG2	;GET THE VALUES THE MACRO'S ARGS HAVE IF THEY EXIST.
	MOVE AA,MARG1
	MOVE B,MACBTS	;GET THE BITS THAT SAY WHETHER THEY DO.
	TLNN B,MFBA1	;IF THERE'S A 1ST ARG,
	 JRST FCTLX1
	MOVEM AA,SARG	;PUT IT AWAY
	TRO FF,ARG2	;AND SAY THERE IS ONE.
FCTLX1:	TLNE B,MFBA2
	 JRST VALREC	;IF THERE'S A 2ND ARG, SET IT UP AS CURRENT VALUE.
	JRST CD2A	;IF THERE ISN'T, SET UP NO CURRENT VALUE BUT DON'T CLEAR ARG2.

;F^Y COMMAND - TAKES 0,1 OR 2 ARGS, AND RETURNS 0 IF NO ARGS, 1 IF ONLY A 2ND ARG,
;2 IF ONLY A 1ST ARG (EG 1,F), 3 IF TWO ARGS (EG 1,2F).
FCTLY:	SETZ A,
	TRZE FF,ARG2
	 ADDI A,2
	TRZE FF,ARG
	 AOJA A,POPJ1
	JRST POPJ1

CTLM:	SKIPN STEPFL	;^M - FLUSH CURRENT VALUE
	 JRST CD
	MOVE A,QRB..
	SKIPE .QVWFL(A)
	 JRST CTLM1
	TRZ FF,ARG+ARG2+COLONF
	TRO FF,SLSL	;IN LINE-STEPPING MODE (SEE FS STEP$),
	CALL VIEW1B	;DO ^VW, AND DECODE VALUE OF CHARACTER READ
CTLM1:	MOVE A,QRB..
	SETZM .QVWFL(A)	;AND ALLOW BUFFER DISPLAY AFTER COMMAND.
	TRZ FF,SLSL+COLONF
	CALL FTYI
	 JFCL
	CAIN A,^F
	 JRST [	SETZM NOQUIT	;^F QUITS EVEN WHEN QUITTING NOT ALLOWED.
		SETOM STOPF
		JRST CD]
	CAIN A,^R
	 JRST [	CALL RRENTR	; ENTER ^R MODE
		JRST CTLM1]	;THEN DECODE ANOTHER CHARACTER.
	CAIE A,^P
	 JRST CD
	SETZM STEPFL	;OR TURN OFF STEPPING
	JRST CD

CAND:	MOVSI A,(AND B,)
	JRST CD2B
COR:	MOVSI A,(IOR B,)
	JRST CD2B
BAKARR:	HRROI AA,SERCHA	;_ IS EITHER SEARCH-AND-YANK OR SAME AS -.
	SKIPLE NLAROW	;FS _DISABLE POSITIVE => "_" IS ERROR.
	 TYPRE [DCD]	;"DISABLED COMMAND"
	SKIPN NLAROW	;FS _DISABLE IS NEGATIVE => "_" IS TREATED AS "-".
	 JRST CD5B	;FS _DISABLE IS 0 => "_" IS SEARCH-AND-YANK.
MINUS:	MOVSI A,(SUB B,)
	JRST CD2B
TIMES:	MOVSI A,(IMUL B,)
	JRST CD2B
SLASH:	MOVSI A,(IDIV B,)
	JRST CD2B
CXOR:	MOVSI A,(XOR B,)
	JRST CD2B
PLUS:	MOVSI A,(ADD B,)
	JRST CD2B

COMMA:	TRZN FF,ARG
	 JRST COMMA1
	MOVEM B,SARG
	TROE FF,ARG2
	 TYPRE [WNA]
COMMA1:	SETZM NUM	;NO ACCUMULATED 1ST ARG ANYMORE,
	JRST CD2A	;INIT. FOR NEW ARG, DON'T CLEAR COLONF.

ASLSL:	TROA FF,SLSL	;TURN ON THE UPARROW FLAG
ACOLON:	TRO FF,COLONF	;TURN ON THE COLON FLAG
	JRST CD5A	;AND GO BACK FOR MORE

;HANDLE (, ), F(, F)

FOPEN:	SUB P,[1,,1]	;F( - PUSH VALUES BUT DON'T FLUSH THEM.
	SKIPA T,[CD5A]
OPEN:	 MOVEI T,CD	;( - PUSH AND FLUSH VALUES.
OPEN1:	SAVE NUM
	HLLZ CH,DLIM
	HRR CH,FF	;REMEMBER CURRENT COLONF, SLSL, ARG2.
	TRNE FF,ARG2
	 SAVE SARG	;SAVE 2ND ARG IF THEE IS ONE.
	SAVE CH
	SAVE LEV
	MOVEM P,LEV
	JRST (T)

FCLOSE:	SUB P,[1,,1]	;F) - POP AND THROW AWAY VALUES. CALLED WITH PUSHJ.
	SKIPA T,[CD5A]
CLOSE:	 HRROI T,CD5A	;) - POP AND RETURN VALUES. RH(T) IS RET. ADDR., SIGN=0 => THROW AWAY.
CLOSE2:	CAME P,LEV
	 TYPRE [UMC]	;NOT ALLOWED IF TOP OF STACK DOESN'T HAVE SOME PUSHED VALS.
	SKIPN Q,ITRPTR
	 JRST CLOSE1
	HLRZ Q,-1(Q)
	CAIN Q,(P)
	 TYPRE [UMC]	;DON'T ALLOW SEQUENCE "(<)" - WOULD SCREW UP ">".
CLOSE1:	REST LEV
	REST CH
	TRZE CH,NOTF	;IF THE ( BEING MATCHED WAS INSIDE A QREG NAME,
	 MOVEI T,QREGXR	;WE SHOULD RETURN TO QREGX
	ANDCMI CH,#ARG2#COLONF#SLSL#OPFLG#ARG
	TRNE CH,ARG2
	 REST AA
	REST A
	JUMPGE T,(T)	;FOR F), DO NOTHING WITH THE POPPED STUFF.
	TRNE FF,ARG
	 TRZ CH,OPFLG
	TRNE FF,ARG	;ELSE, SET THE VALUE INSIDE THE PARENS UP AS A
	 IORI FF,SYLF	;SYLLABLE TO DO ARITHMETIC ON
	EXCH A,NUM	;WITH THE VALUE SAVED BY THE OPEN
	MOVEM A,SYL
	HLLM CH,DLIM	;AND THE ARITH OP BEFORE THE OPEN.
	TRNE CH,ARG2
	 MOVEM AA,SARG
	IORI FF,(CH)
	JRST (T)

;SET P FROM CH, AND FORGET ABOUT ALL ('S
;THAT WERE IN THE PART OF THE STACK THAT HAS BEEN FLUSHED.
;ALSO PERFORM APPROPRIATE ACTIONS IN CASE POPPING PAST A ^R OR A SORT.
;THEN EXIT WITH POPJ P, (NOTE P HAS CHANGED, SO CALL WITH PUSHJ CH,
;BUT DON'T DARE DO THAT IF P=CH, SINCETHAT WOULD LEAVE THE RETURN
;POINTER ON STACK ABOVE P, CAUSING TIMING ERROR WITH INT. LEVEL).
SETP:	MOVEM P,SETPP
	CAMLE CH,P
	 .VALUE		;MOVING PDL POINTER UPWARDS??
IFN RMSSW,[
	SKIPE DISPRR	;IF POPPING OUT OF A ^R,
	 CALL RRERST	;UNBIND SOME STUFF.
]
	CAMGE CH,PSSAVP
	 SETZM PSSAVP	;DETECT ERRING OUT THROUGH A ^P, AND RELEASE SORT TABLES.
;HERE IF KNOWN NOT TO BE EXITING A ^R OR ^P.
SETP1:	SKIPE LEV	;IF THERE IS AN (,
	 CAML CH,LEV	;AND IT'S NO LONGER BENEATH P,
	  JRST [ MOVE P,CH ? RET]
	HRRZ P,LEV
	CAIL P,PDL
	 CAIL P,PDL+LPDL
	  .VALUE
	MOVE P,LEV	;FLUSH THE INNERMOST "("
	REST LEV
	JRST SETP1	;AND EXAMINE THE NEXT ONE.

CHK:	CAMG B,ZV
	 CAMGE B,BEGV
	  TYPRE [NIB]
	RET

CHK1:	CAMG C,BEGV
	 MOVE C,BEGV
	CAML B,ZV
	 MOVE B,ZV
	CAMLE C,B
	 TYPRE [2%1]	;2<1
	RET

CHK1A:	CAMG C,BEG
	 MOVE C,BEG
	CAML B,Z
	 MOVE B,Z
	CAMLE C,B
	 TYPRE [2%1]	;2<1
	RET

GETIBI:	SKIPA F,IN
GETIB.:	 MOVE F,PT
GETIBV:	CAML F,GPT
	 ADD F,EXTRAC
GETIBP:	SOJ F,
GETBP:	MOVE TT,F
	IDIVI TT,5
	MOVE F,BTAB(TT1)
	HRRI F,(TT)
	TLZ F,17
	POPJ P,

;CONVERT THE BYTE POINTER IN F TO A CHARACTER ADDRESS
GETCA:	LDB TT,[360600,,F]	;GET POSITION FIELD IN TT
	MOVEI F,1(F)	;CLEAR OUT LH OF BYTE POINTER
	IMULI F,5
	IDIVI TT,7
	SUBI F,1(TT)
	POPJ P,

GETINC:	MOVE TT,IN
	AOSA IN
GET:	 MOVE TT,IN
	CAML TT,GPT
	 ADD TT,EXTRAC
	IDIVI TT,5
	LDB CH,BTAB(TT1)
	POPJ P,

PUTINC:	MOVE TT,OUT
	AOSA OUT
PUT:	 MOVE TT,OUT
	CAML TT,GPT
	 ADD TT,EXTRAC
	IDIVI TT,5
	DPB CH,BTAB(TT1)
	POPJ P,

	440700+TT,,	;FOR SORT
BTAB:	350700+TT,,
	260700+TT,,
	170700+TT,,
	100700+TT,,
	10700+TT,,


;CALL GETARG TO DECODE 0,1 OR 2 ARGS AS "T", "K", "X", ETC. DO.
;RETURNS IN C,B THE CHAR ADDRS OF BEGINNING AND END OF RANGE.
;SKIPS IF THERE WERE 0 OR 1 ARG; DOESN'T SKIP IF WERE 2.
;THE CALL TO GETARG SHOULD BE FOLLOWED BY A CALL TO CHK1
;OR CHK1A, TO MAKE SURE THE ARGS ARE IN RANGE IF THERE ARE 2.
GETARG:	TRNE FF,ARG2
	 JRST GETAG6
	ARGDFL O
GETAG7:	MOVE IN,PT
GETAG4:	SAVE CH
	SAVE AA
	JUMPLE B,GETAG2
	MOVE F,IN
	CAML F,GPT
	 ADD F,EXTRAC
	CALL GETIBP
GETAR1:	CAMN IN,ZV
	 JRST GETAG5
	CAMN IN,GPT	;REACHING THE GAP => MOVE OVER IT.
	 CALL FEQGAP
	ILDB CH,F
	CAIE CH,^J
	 AOJA IN,GETAR1
	AOJ IN,
	SOJG B,GETAR1

GETAG1:	TRZE FF,COLONF
	 CALL GETAG8
	CAMG IN,BEGV
	 MOVE IN,BEGV
GETAG5:	REST AA
	REST CH
	MOVE C,PT
	MOVE B,IN
	TRZ FF,COLONF	;TURN IT OFF IF NOT ALREADY DONE
	TLZE FF,NEGF
	 EXCH B,C
	AOS (P)
	RET

GETAG8:	SUBI IN,2
	PUSHJ P,GET
	CAIE CH,15
	 AOJA IN,GETAG9
	POPJ P,

GETAG9:	PUSHJ P,GET
	CAIE CH,12
	 AOJ IN,
	POPJ P,

GETAG6:	ADD B,BEG
	ADD C,BEG
	TRZ FF,COLONF
	POPJ P,

GETAG2:	SOS IN
GETAG0:	CAMGE IN,BEGV
	 AOJA IN,GETAG3
	PUSHJ P,GET
	CAIE CH,12
	 SOJA IN,GETAG0
	AOJLE B,GETAG2
	AOJ IN,
GETAG3:	TLO FF,NEGF
	JRST GETAG1

APPEND:	ARGDFL
	TRZE FF,COLONF
	 JRST APPNDL
	TRZN FF,ARG
	 JRST YANK2
	ADD B,PT
	SOS IN,B
	CAMGE IN,ZV
	CAMGE IN,BEGV
	 JRST APPND2	;J IF OUT OF RANGE OF BUFFER.
	ANDCMI FF,ARG2
	PUSHJ P,GET
	MOVE A,CH
	JRST POPJ1

APPND2:	TRZN FF,ARG2	;IF ONLY ARG, OUT OF RANGE IS ERROR.
	 TYPRE [NIB]
	MOVE A,C	;2 ARGS => RETURN 1ST ARG.
	JRST POPJ1

APPNDL:	TRNN FF,ARG	;<N>:A - APPEND <N> LINES, OR TO ^L,
	 MOVEI B,1	;WHICHEVER COMES FIRST.
	TLNN FF,UREAD
	 RET
	SAVE PT
	MOVE OUT,ZV	;TEMPORARILY PUT PT AT END SO
	MOVEM OUT,PT	;TYOM WILL INSERT AT END.
	CALL GAPSLP
APPNL2:	PUSHJ P,UTYI
	SKIPN FFMODE
	 CAIE CH,^L
	  SKIPL LASTPA	;AT EOF => UTYI WAS RETURNING DUMMY CHARS; IGNORE THEM.
	   JRST APPNL1
	PUSHJ P,TYOM
	CAIN CH,^L
	 JRST APPNL1
	CAIE CH,^J	;END OF LINE
	 JRST APPNL2
	SOJG B,APPNL2
APPNL1:	REST PT
	CAIE CH,^L
	 RET
	AOS PAGENU
;CLOSE THE INPUT FILE IF IT IS EMPTY EXCEPT FOR PADDING.
APPNL4:	CALL UTYI	;READ AHEAD 1 CHAR TO SEE IF ANYTHING
	SKIPL LASTPA	;IS LEFT IN THE FILE.
	 RET		;NO => LEAVE FILE MARKED "EOF".
	MOVE A,UTYIP	;ELSE ARRANGE TO RE-READ THAT CHAR.
	DBP7 A
	MOVEM A,UTYIP
	POPJ P,

;Y => READ ONE PAGE FROM THE OPEN INPUT FILE,
;DESTROYING PREVIOUS CONTENTS OF BUFFER.
;IF NO FILE OPEN, JUST EMPTY THE BUFFER.
;THE FS YDISABLE$ FLAG MAY TURN Y INTO AN ERROR.
;^ Y READS IN ALL THE REST OF THE FILE.
YANK:	SKIPGE YDISAB
	 IORI FF,SLSL	;YDISAB NEGATIVE => Y IS ^Y.
	SKIPLE YDISAB
	 TYPRE [DCD]	;FS YDISABLE POSITIVE => "Y" IS ILLEGAL.
YANKEE:	CLEARM GEA
	MOVE C,BEGV
	MOVE B,ZV	;FIRST, KILL CURRENT CONTENTS.
	CALL DELET1
YANK2:	TLNN FF,UREAD
	 JRST UTLSTP	;NO FILE OPEN => INSERT NOTHING.
	TRNE FF,SLSL
	 JRST YANKAL	;"^ Y" IS HANDELD SEPARATELY.
	.I YANKMT=MEMT	;PREVENT EXCESS CLEARING OF LOW BITS IN SLPSAV
	MOVE F,ZV	;GET PLACE TO INSERT AT.
	EXCH F,PT	;GET GAP THERE.
	CALL GAPSLP
	MOVEM F,PT
	MOVE F,BEG
	CAME F,Z	;IF BUFFER IS EMPTY NOW,
	 JRST YANK3
	MOVE F,BEG	;ADJUST VALUE OF BEG SO THAT
	IDIVI F,5	;THE BUFFER STARTS IN THE SAME PART OF A WORD
			;AS THE EMPTY PART OF UTOBUF FOR ORDINARY Y.
	HLL F,UTYOP	;(MAKES IT MORE LIKELY THAT PW CAN GO FAST)
	TLNN F,760000	;MAKE SURE WE DON'T MOVE BEG TO
	 SUBI F,1	;A DIFFERENT WORD.
	CALL GETCA	;TURN INTO CHAR ADDR OF LAST CHAR BEFORE BUFFER
	SUB F,BEG
	AOS TT,F	;TURN INTO DISPLACEMENT OF NEW BEG FROM OLD
	ADDB TT,BEG	;UPDATE BEG.
	CAMGE TT,BFRBOT	;NEW BEG ISN'T SUPPOSED TO BE OUTSIDE BUFFER SPACE.
	 .VALUE
	ADDM F,BEGV	;SHIFT ALL THE OTHER BUFFER POINTERS JUST LIKE BEG
	ADDM F,PT
	ADDM F,GPT
	ADDM F,Z
	ADDM F,ZV
	MOVNS F
	ADDM F,EXTRAC
YANK3:	MOVE F,ZV
IFN TS,[
	AOS PAGENU
	SAVE E
	PUSHJ P,GETIBP
	MOVE OUT,F
	MOVE IN,[YPG,,A]
	BLT IN,F
	MOVE IN,UTYIP
	SKIPN Q,EXTRAC
	 JRST YPGNRM
	JRST A

YPG:	ILDB CH,IN	;A
	CAIE CH,EOFCHR	;AA
	CAIN CH,14	;B
	JRST YPG1	;E
	IDPB CH,OUT	;C
	SOJG Q,A	;D
	JRST YPGNRM	;F

YPG1:	MOVEM IN,UTYIP	;WE JUST ILDB'D ^C OR ^L.
	HRRZ TT,IN
	CAIN TT,UTIBE
	 JRST YPG2	;JUST END OF UTIBUF - RELOAD IT.
	CAIE CH,EOFCHR
	 JRST YPG3	;IT WAS A ^L - GO INSERT IT AND RETURN.
	CAME IN,UTRLDT
	 JRST C		;^C INSIDE THE FILE - INSERT IT AND KEEP GOING.
	CALL UTLSTP	;EOF - MARK FILE AS AT EOF.
YPG1A:	MOVE F,OUT
	CALL GETCA
	AOS F
	MOVE C,ZV	;GET PLACE WHERE INSERTED FILE STARTS, FOR YANKX'S USE.
	CALL YPG1B	;UPDATE BUFFER BLOCK FOR CHARS WE HAVE READ IN.
	REST E
	JRST YANKX	;NOW MAYBE DELETE PADDING OR A TRAILING ^L.

YPG1B:	SETZM YANKMT
	MOVEM F,GPT
	SUB F,ZV	;# CHARS YANKED.
	ADDM F,Z
	ADDM F,ZV
	MOVNS F
	ADDM F,EXTRAC
	POPJ P,

YPG3:	IDPB CH,OUT	;ENCOUNTERED A ^L - INSERT IT,
	CALL APPNL4	;MARK THE FILE CLOSED IF THERE'S NOTHING LEFT IN IT
	JRST YPG1A	;THEN FINISH UP AS IF REACHED EOF.

YPG2:	CALL UTRLD2	;EOB AND CAN'T GO FAST, RELOAD UTIBUF.
	MOVE IN,UTYIP
	JRST A		;TRY AGAIN TO READ A CHARACTER.

YPGNRM:	SAVE B		;COME HERE WHEN RUN OUT OF GAP TO YANK INTO.
	MOVE B,EXTRAC
	ADDI B,5*<UTIBE-UTIBUF>	;B <- AMOUNT OF GAP WE WANT.
	MOVN Q,EXTRAC
	CALL SLPSAV
	REST B
	ADD Q,EXTRAC
	JRST A

]	;END IFN TS,

;HANDLE "^ Y" AND "^ A" - READ IN ALL OF INPUTR FILE, THEN
;REMOVE PADDING FROM END, AND MAYBE REMOVE A TRAILING ^L.
YANKAL:	MOVE B,ZV
	SAVE B		;MOVE POINT TO ZV, SAVING ZV AND OLD POINT.
	EXCH B,PT
	SAVE B
	CALL FYCMDA	;THEN INSERT THE WHOLE FILE THERE.
	CALL GAPSLP	;AND MOVE THE GAP TO THE END OF WHAT WAS INSERTED.
	REST PT		;POINT IS NOW SAME AS AT ENTRY, BUT GPT = ZV.
	REST C		;THIS IS OLD VALUE OF ZV - WHERE THE FILE STARTS.
	CALL UICLS
;DELETE BACKWARDS FROM GPT ALL CONSECUTIVE ^C'S AND ^@'S;
;THEN, IF FS ^LINSERT$ IS 0, DELETE A FORMFEED IF ANY.
;REFUSES TO DELETE BACK PAST WHERE C POINTS.
YANKX:	MOVE IN,GPT
YANKX1:	MOVEI B,1
	CAMN C,IN
	 RET
	SOS IN
	CALL GET
	CAIE CH,^C
	 JUMPN CH,YANKX2
	SOS GPT
	CALL DELETB	;DELETE 1 CHAR AFTER GPT (SINCE B HAS 1).
	JRST YANKX1

YANKX2:	CAIN CH,^L	;GOT ALL ^C'S AND ^@'S - NOW MAYBE TAKE A ^L.
	 SKIPE FFMODE
	  RET
	SOS GPT
	JRST DELETB

;INSERT ALL OF THE OPEN INPUT FILE BEFORE POINT.
;FY WITH NO ARGUMENT USES THIS, AS DOES "^ Y".
FYCMDA:	CALL FSIFLEN	;HOW MUCH SPACE DO WE NEED?
	 JFCL
	.I YANKMT=MEMT	;IN CASE MUST MAKE SEVERAL TRIES, PREVENT EXCESS LOW-BIT CLEARING.
	SKIPGE B,A	;IF KNOW HOW MUCH SPACE, READ WHOLE FILE AT ONCE.
FYCMD7:	 MOVEI B,2000.*5 ;ELSE GET 1K AT A TIME.
	CALL FYCMD6	;READ THAT MUCH.
	SKIPE LASTPA	;IS THERE ANY MORE IN THE FILE?
	 JRST FYCMD7	;YES, SO GET MORE.
	SETZM YANKMT
	RET

;<N>FY - READ <N> CHARACTERS FROM THE INPUT FILE, OR UNTIL EOF,
;AND INSERT THEM IN THE BUFFER BEFORE POINT. NO PADDING CHARACTERS ARE
;FLUSHED, SO ALL IS UNDER PROGRAMMER CONTROL. IF THE TRANSFER GOES TO A WORD
;BOUNDARY, AND STARTS AT A WORD BOUNDARY IN THE FILE, THEN IT IS
;SUITABLE FOR READING IN BINARY DATA.
FYCMD:	TLNN FF,UREAD
	 TYPRE [NFI]
	TRNN FF,ARG
	 JRST FYCMDA	;NO ARG => READ THE WHOLE FILE.
	JUMPL B,TYPAOR	;NEGATIVE ARG NOT ALLOWED.
FYCMD6:	SAVE B
	MOVE F,UTYIP	;FOR SPEED, LEAVE ENOUGH SPACE BEFORE INSERTING THE FILE
	CALL GETCA	;TO ENABLE TRANSFER TO GO WORDWISE.
	MOVEI F,1(F)
	SUB F,PT
	IDIVI F,5
	SKIPE F,T
	 ADDI F,5
	SAVE F
	ADD B,F		;THAT MUCH, PLUS # CHARS BEING READ, IS AMT OF SPACE WE NEED.
	CALL GAPSLP	;GET GAP TO POINT.
	CALL SLPSAV	;MAKE SURE THERE'S ENOUGH SPACE.
	MOVE B,-1(P)
	MOVE F,PT
	ADD F,(P)	;LEAVE THE FEW CHARS OF SPACE TO REACH PROPER ALIGNMENT.
	CALL GETIBP	;CREATE B.P. FOR IDPB'ING INTO THE GAP.
FYCMD0:	JUMPE B,FYCMDE
	MOVE A,UTYIP	;AND LOOK AT B.P. WE'LL ILDB FROM.
	HRRZ AA,UTRLDT
	ADD AA,[(010700)-1]
	JRST FYCMDW

FYCMDS:	CAMN A,AA
	 JRST FYCMDR	;IF UTIBUF EXHAUSTED, MUST RELOAD IT.
	ILDB CH,A	;OTHERWISE, TRANSFER ONE MORE CHARACTER
	IDPB CH,F
	SOJG B,FYCMDS
FYCMD5:	MOVEM A,UTYIP
FYCMDE:	CALL UTEOF	;IF THERE'S NOTHING LEFT IN THE INPUT FILE, MARK IT "AT EOF".
	MOVE C,-1(P)
	SUB C,B		;# CHARS ACTUALLY READ IN
	ADD C,(P)	;PLUS # CHARS OF SPACE LEFT AT FRONT.
	ADDM C,GPT	;"INSERT" THE DATA AND THE SPACE AT FRONT.
	ADDM C,ZV	;BUT DON'T CHANGE POINT, YET.
	ADDM C,Z
	SUBM C,EXTRAC
	MOVNS EXTRAC
	REST B		;B HAS # CHARS OF SPACE THAT'S NOW IN THE BUFFER
	SUB P,[1,,1]
	JUMPE B,FYCMD8
	SUB C,B		;C HAS # CHARS OF REAL DATA NOW INSERTED.
	CALL GAPSLP	;GET GAP TO POINT, WHICH STILL POINTS VBEFORE THE SPACE
	CALL DELETB	;AND DELETE THE SPACE.
FYCMD8:	ADDM C,PT	;NOW MAKE POINT GO AFTER THE INSERTED DATA.
	RET

FYCMDR:	CAME A,[010700,,UTIBE-1]
	 JRST FYCMDE	;IF LAST INPUT BUFFER WASN'T FULL, THIS IS EOF.
	CALL UTRLD2	;ELSE, READ ANOTHER INPUT BUFFER AND CONTINUE TRANSFERING.
	JRST FYCMD0

;HERE WE HANDLE WORD-AT-A-TIME FY READING.
FYCMDW:	TLNN A,760000	;WE WILL REACH A WORD BOUNDARY SOON, SO TRANSFER CHAR
	 JRST FYCMD1	;AT A TIME, WATCHING FOR THE BOUNDARY.
	ILDB CH,A
	IDPB CH,F
	SOJG B,FYCMDW
	JRST FYCMD5	;IT'S POSSIBLE TRANSFER WILL END BEFORE REACHING IT.

FYCMD1:	MOVEM A,UTYIP
	CAIGE B,5	;DON'T BOTHER TRYING TO GO FAST IF < 1 WHOLE WORD LEFT.
	 JRST FYCMDS
	IDIVI B,5	.SEE E
	IBP F
	SUB AA,A	;IF THEER'S ANYTHING LEFT IN UTIBUF, MUST USE IT FIRST.
	JUMPE AA,FYCMDI	;LH'S CANCEL SINCE BOTH ARE 010700.
	IBP A
	HRL F,A
	CAMLE AA,B	;# WORDS TO TRANSFER RIGHT NOW =
	 MOVE AA,B	;MIN (<WORDS LEFT IN UTIBUF>, <WORDS WANTED>).
	ADDM AA,UTYIP	;REMOVE THAT MANY WORDS FROM THE BUFFER.
	SUB B,AA	;# WORDS THAT WILL BE LEFT EMPTY AFTER USING UP UTIBUF?
	ADD AA,F
	BLT F,-1(AA)	;TRANSFER WHAT'S LEFT OF UTIBUF.
	IMULI B,5
	HRRZ F,AA
	JRST FYCMD2

;GOING WORD AT A TIME, AND UTIBUF IS EMPTY, SO GET DIRECTLY FROM FILE.
FYCMDI:	CAIGE B,100000	;DON'T TRY TO IOT MORE THAN 32K AT A TIME.
	 JRST FYCMD4
	IMULI B,5
	ADD E,B		;SO PUT TOTAL # CHARS TO GET, MINUS 32K OF CHARS, IN E,
	SUBI E,5*100000
	MOVEI B,100000	;AND GET ONLY 32K RIGHT NOW.
FYCMD4:	MOVNS B
	HRL F,B		;AOBJN -> BUFFER WORDS TO TRANSFER INTO.
	.IOT UTYIC,F
	HLRE B,F
	IMUL B,[-5]
FYCMD2:	ADD B,E		;# CHARS WE WERE SUPPOSED TO TRANSFER BUT HAVEN'T YET.
	JUMPL F,FYCMD3	;EOF => WE WILL NEVER GET THEM, SO INSERT WHAT WE HAVE GOT.
	ADD F,[(010700)-1]	;GET BACK B.P. TO IDPB THE REST OF THE DATA
	JRST FYCMD0	;RELOAD BUFFER TO XFER LAST FEW CHARS 1 AT A TIME.

FYCMD3:	CALL UTLSTP
	JRST FYCMDE

;READ NEXT CHARACTER FROM OPEN INPUT FILE, AND RETURN IT IN CH.
;UP TO A WORD OF ^C'S OR ^@'S BEFORE THE END OF THE FILE WILL BE IGNORED.
;IF TRY TO READ PAST EOF, FS LASTPAGE$ WILL BE SET TO 0, AND ^L WILL BE RETURNED.
UTYI:	ILDB CH,UTYIP
	CAILE CH,EOFCHR
	 RET
	CAIE CH,EOFCHR
	 JUMPN CH,CPOPJ
	HRRZ CH,UTYIP
	CAIN CH,UTIBE
	 JRST UTYIR	;EXHAUSTED BUFFER => REALOD IT AND TRY AGAIN.
UTYI4:	MOVE CH,UTYIP
	CAMN CH,UTRLDT
	 JRST UTYIE	;READ PAST EOF => CLOSE FILE AND RETURN A ^L.
;^C OR ^@ INSIDE THE FILE - IS IT PADDING BEFORE EOF?
	HRLI CH,010700
	IBP CH
	CAME CH,UTRLDT	;MORE THAN 1 WORD FROM THE END => IT ISN'T PADDING.
	 JRST UTYI5
	ANDI CH,-1
	CAIE CH,UTIBE	;THIS LAST WORD OF INPUT BUFFER => WE DON'T KNOW WHETHER
	 JRST UTYI1	;THERE ARE MORE WORDS IN THE FILE,
	MOVE CH,UTIBE-1	;SO FIND OUT BY PUTTING THIS WORD AT BEGINNING OF BUFFER
	MOVEM CH,UTIBUF	;AND FILLING UP THE REST IF POSSIBLE.
	MOVE CH,UTIBE
	MOVEM CH,UTIBUF+1
	MOVNI CH,UTIBE-UTIBUF-1
	ADDM CH,UTYIP
	ADDM CH,UTRLDT
	MOVE CH,[UTIBUF+1-UTIBE,,UTIBUF+1]
	CALL UTRLD3	;NOW TRY FILLING REST OF INPUT BUFFER.
	JRST UTYI4	;WE NOW HAVE ENOUGH INFO TO ANSWER OUR QUESTION.

;COME HERE WHEN A ^C OR ^@ IS FOUND IN THE LAST WORD OF THE FILE, TO LOOK
;AHEAD AND SEE IF REST OF THE CHARS IN LAST WORD ARE ALL ^C OR ^@.
UTYI1:	SAVE UTYIP
UTYI3:	ILDB CH,UTYIP
	CAIE CH,^C
	 JUMPN CH,UTYI2
	MOVE CH,UTYIP
	CAME CH,UTRLDT
	 JRST UTYI3
	SUB P,[1,,1]	;ALL ARE ^C OR ^@ => RETURN CLOSING FILE.
UTYIE:	CALL UTLSTP
	MOVEI CH,^L
	RET

UTYI2:	REST UTYIP	;NOT ALL PADDING => THIS ^C OR ^@ IS REALLY DATA, AND SO ARE THE REST.
UTYI5:	LDB CH,UTYIP
	RET

UTYIR:	CALL UTRLD2
	JRST UTYI	;GO BACK AND TRY AGAIN

;"EC" COMMAND -- CLOSE THE INPUT FILE AND MARK IT CLOSED.
UICLS:	CALL UTLSTP	;FIRST, SET "AT EOF" SO ATTEMPTS TO READ WILL GET ^C'S.
	.CLOSE UTYIC,
	TLZ FF,UREAD
	RET

;REFILL THE INPUT BUFFER.
UTRLD2:	MOVE CH,[10700,,UTIBUF-1]
	MOVEM CH,UTYIP
	MOVE CH,[UTIBUF-UTIBE,,UTIBUF]
UTRLD3:	.IOT UTYIC,CH
	HRRM CH,UTRLDT	;FIRST ADR. NOT LOADED BY SYS
	JUMPGE CH,CPOPJ
	MOVEI CH,EOFCHR
	DPB CH,UTRLDT	;STORE EOF THERE
	POPJ P,

;SEE IF THE INPUT FILE IS AT EOF.  IF SO, SET FS LASTPA, ETC.
;TO TELL THE USER THAT IT IS.
UTEOF:	SKIPL LASTPA
	 RET		;ALREADY AT EOF => NO CHANGE.
	MOVE CH,UTYIP
	IBP CH
	CAME CH,UTRLDT	;MORE LEFT IN INPUT BUFFER => NOT EOF
	 RET
	ANDI CH,-1
	CAIE CH,UTIBE	;NONE LEFT IN INPUT BUFFER, AND BUFFER WASN'T A FULL ONE,
	 JRST UTLSTP	;=> CLEARLY AT EOF.
	CALL UTRLD2	;AT END OF BUFFER => TRY READING SOME MORE TO SEE
	JRST UTEOF	;IF AT EOF.

;INDICATE THAT THE INPUT FILE IS AT EOF. ALL ATTEMPTS TO READ MORE
;WILL JUST ENCOUNTER ANOTHER EOF.
UTLSTP:	SETZM LASTPA	;SAY "EOF" TO ANYONE WHO ASKS.
	MOVE CH,[010700,,[ASCIC//]-1]
	MOVEM CH,UTYIP	;SET UP BUFFER TO APPEAR TO BE JUST BEFORE AN EOF
	IBP CH		;SO THAT ANY ATTEMPT TO READ A CHARACTER WILL SEE EOF
	MOVEM CH,UTRLDT	;AND COME RIGHT BACK HERE.
	RET

;FS IF LENGTH$ - READ LENGTH OF OPEN INPUT FILE.
FSIFLEN:TLNN FF,UREAD
	 TYPRE [NFI]
	MOVEI A,UTYIC
FSIFL1:	SYSCAL FILLEN,[A ? MOVEM A]
	 SKIPA A,[-1]
	  IMULI A,5
	JRST POPJ1

FSOFLEN:TLNN FF,UWRITE
	 TYPRE [NDO]
	MOVEI A,UTYOC
	JRST FSIFL1

;SET INPUT FILE ACCESS POINTER TO CHAR # IN B.
FSIFAC:	TLNN FF,UREAD
	 TYPRE [NFI]
	MOVEI A,UTYIC
	.CALL RFACCB
	 TYPRE [NRA]	;NOT RANDOM ACCESS FILE.
	IDIVI B,5	;CHANGE ARG TO WORD #.
	.ACCES UTYIC,B	;FIND THAT WORD.
	SETOM LASTPA	;EVEN IF FILE WAS AT EOF, IT WON'T BE ANY MORE.
	CALL UTRLD2	;FILL UP THE INPUT BUFFER
	HRRZ CH,UTRLDT
	CAIN CH,UTIBUF	;DID WE GET ANYTHING?
	 JRST UTLSTP	;NO, .ACCESS WENT TO EOF.
	JUMPE E,CPOPJ	;YES, ADVANCE IN WORD TO SPEC'D CHARACTER IF IT ISN'T THE 1ST.
	IBP UTYIP
	SOJG E,.-1
	RET

REVERS:	TRNE FF,ARG2
	 JRST LINE	;MAKE FLR MOVE RIGHT OVER A LIST.
	ARGDFL Z
	MOVNS B
	JRST REVER1

CHARAC:	ARGDFL Z
REVER1:	ADD B,PT
JMP1:	CAML B,BEGV	;IS THE SPEC'D POS. WITHIN BFR'S LIMITS?
	CAMLE B,ZV
	 JRST [TRZE FF,COLONF	;NO, FOR :C, ETC.
		 JRST NRET0	;RETURN FAILURE.
		TYPRE [NIB]]	;NO :, THIS IS ERROR.
	MOVEM B,PT
	TRZE FF,COLONF
	 JRST NRETM1	;FOR :C, ETC. SAY SUCCESSFUL.
	POPJ P,

JMP:	TRZN FF,ARG
	 SKIPA B,BEGV
	ADD B,BEG
	JRST JMP1

LINE:	CALL GETARG	;GET PT AND DESIRED PT IN B,C
	 CALL CHK1	;MAKE SURE ARGS ARE WITHIN VIRT. BUFFER.
	ADD B,C
	SUB B,PT	;IF EITHER ARG EQUALED PT, PT IS NOW THE OTHER ONE.
	JRST JMP1

KILL:	PUSHJ P,GETARG
	 PUSHJ P,CHK1
	JRST DELET1

DELETE:	ARGDFL Z
DELET0:	JUMPE B,CPOPJ	;DELETING 0 CHARS.
	MOVE C,PT
	ADD B,PT	;B,C HAVE 2 ENDS OF RANGE TO DELETE.
	CALL CHK	;MAKE SURE B IS IN THE BUFFER.

;MAIN DELETE RTN. B,C VIRTUAL CHAR ADDRS -> ENDS OF STUFF TO DELETE
;SETS PT TO PLACE DELETED FROM, LEAVES GAP THERE TOO.
.SEE FXCMD	;MUSTN'T CLOBBER A OR E.
DELET1:	CAMG B,C	;GET UPPER END IN B, LOWER IN C.
	 EXCH B,C
	MOVEM C,PT	;TELL GAPSLP WHERE TO PUT GAP (IF CALL IT)
	CAML B,GPT	;IF THE GAP IS IN OR NEXT TO
	CAMLE C,GPT	;THE AREA BEING DELETED, OK.
	 CALL GAPSLP	;ELSE MOVE IT TO BE SO.
	MOVEM C,GPT	;NOW TURN THE AREA INTO GAP.
	SUB B,C
DELETB:	ADDM B,EXTRAC
	MOVNS B
	ADDM B,ZV
	ADDM B,Z
	POPJ P,

DEL1B:	SOS PT		;DELETE 1 CHARACTER BACKWARDS FROM PT.
	SOS GPT
DEL1F:	SOS ZV		;DELETE 1 FORWARDS FROM PT.
	SOS Z
	AOS EXTRAC
	RET

;<N>F^E<STRING>$ - REPLACE STRING INTO BUFFER STARTING AT POSITION <N>.
;<N>:F^E<Q><STRING>$ - REPLACE IN QREG <Q> (EITHER STRING OR BUFFER WORKS).
;REPLACING IS LIKE INSERTING AND THEN DELETING AS MANY CHARS AS WERE INSERTED.
FCECMD:	ARGDFL
	TRZN FF,COLONF
	 JRST FCE1	;INSERT IN BUFFER?
	TRZN FF,ARG
	 TYPRE [WNA]
	CALL QREGX	;NO, QREG. WHICH ONE?
	CALL QLGET0	;LENGTHH IN AA, B.P. TO ILDB IN F.
	 TYPRE [QNS]
	SKIPL B
	 CAMLE B,AA	;MAKE SURE ARG IS IN RANGE
	  TYPRE [AOR]
	CALL GETCA
	ADD F,B		;ADJUST B.P. TO PLACE TO START REPLACING AT.
	CALL GETBP
	SETZ A,		;THERE'S NO GAP TO WORRY ABOUT.
	JRST FCE2

FCE1:	TRZE FF,ARG	;NO ARG, AND REPLACING IN BUFFER => USE ".".
	 JRST FCE5
	MOVE B,PT
	SUB B,BEG
FCE5:	MOVE F,GPT	;REPLACE IN BUFFER.
	CALL GETIBP	;MAKE B.P. TO START OF GAP SO WE CAN TELL WHEN WE REACH GAP.
	MOVE A,F
	MOVE F,BEG
	ADD F,B		;GET VIRT. CHAR ADDR OF WHERE TO START REPLACING
	CAML F,BEGV
	 CAMLE F,ZV
	  TYPRE [AOR]
	CALL GETIBV	;TURN INTO REAL CHAR ADDR, THEN BP.
	ADD B,BEG	;TURN STOP ADRD IN B INTO ADDR REL. TO VIRTUAL BEG,
	SUB B,BEGV	;SINCE MUST BE COMPARED WITH VIRTUAL SIZE.
	MOVE AA,ZV
	SUB AA,BEGV	;GET LENGTH OF BUFFER.
FCE2:	SUB AA,B	;B HAS CHARS FROM PLACE WE START TO END OF BUFFER OR QREG.
	MOVEI CH,ALTMOD
	TRZE FF,SLSL	;FIND OUT WHAT STRING ARG DELIMITER WE'RE USING.
	 CALL RCH
	MOVEM CH,INSDLM
	SETZM INSBP	;MAKE SURE F IS RELOCATED IF BUFFER MOVES.
FCE3:	CALL RCH	;THIS IS THE INNER LOOP OF FCE
	SKIPE SQUOTP
	 JRST FCE4
	CAMN CH,INSDLM	;CHECK CHAR FOR DELIMITERNESS UNLESS SUPERQUOTED, ETC.
	 JRST FCEEND
FCE4:	SOJL AA,[TYPRE [STL]]	;CHECK FOR END OF BUFFER OR QREG.
	CAMN A,F
	 CALL FEQGAP		;CHECK FOR GAP - MOVE B.P. IN F OVER IT.
	IDPB CH,F
	JRST FCE3

FCEEND:	SETOM INSBP
	RET

;INSERT ASCIZ STRING <- BP IN A, INTO Q-REG IN CH.
INSASC:	TRO FF,COLONF	;SAY INSERT IN Q-REG.
	SAVE CH
	SETZM INSDLM	;DELIMITER IS THE ^@ ENDING THE ASCIZ.
	MOVE CH,[ILDB CH,A]
	MOVEM CH,INSRCH	;GET CHARS BY ILDB-ING BP.
	JRST INSAS1

FNCMD:	MOVE CH,[CALL RCH] ;FN = [..N:I..N BUT PREVENTS QUIT IN BETWEEN. ;]
	MOVEM CH,INSRCH
	MOVE CH,QRB..
	ADDI CH,.QUNWN
	CALL OPENB2
	JRST PSI

CNTRLF:	MOVN B,INSLEN	;^F -- SAME AS "FKDI".
	CALL DELET0
	TRZ FF,ARG	;MAKE SURE <N>^F DOESN'T INSERT ASCII(N).
	JRST INSERT

TAB:	HRROI AA,TAB0	;HERE FOR TAB.  DECIDE WHETHER IT'S
	SKIPLE TABMOD
	 TYPRE [DCD]	;DISABLED,
	SKIPN TABMOD
	 JRST CD5B	;ENABLED (IN WHICH CASE COME BACK TO TAB0),
	JRST CD2A	;OR IGNORED.

TAB0:	PUSHJ P,TYOMGS	;USED FOR ENTRY FROM SELF-INSERTING CHARACTERS
	ANDCMI FF,COLONF\SLSL\ARG\ARG2
INSERT:	TRNE FF,ARG	;IF GIVEN AN ARG,
	 JRST INS1C	;THEN JUST INSERT THAT CHARACTER
	MOVE OUT,[CALL RCH]	;SAY TO USE RCH TO GET CHARACTERS TO INSERT
	MOVEM OUT,INSRCH
	TRNN FF,COLONF	;IF NOT GOING TO A Q REG
	 JRST INS1	;THEN SKIP THIS STUFF
	PUSHJ P,QREGVS	;OTHERWISE GET THE Q-REG NAME
	JUMPE AA,PSI		;IS THE QREG SUBSCRIPTED? (:I:Q(IDX))
	JSP TT,QREGVA		;IF SO, EXTRA HAIR IN CASE OUR CONSING
				;MOVES THE Q-VECTOR CONTAINING THE Q-REG.
				;CALLS PSI, THEN RETURNS TO INSERT'S CALLER.
PSI:	TRO FF,COLONF
			;(PSI IS USED AS AN ENTRY POINT
			;FOR SORT.  THE NAME OF THE PSEUDO
			;Q-REG IS LEFT SET UP IN CH, THE COLON
			;FLAG IS TURNED ON TO MAKE CERTAIN I
			;KNOW I AM Q-REGGING.
	SAVE CH		;REMEMBER WHICH QREG TO STORE IN.
	CAIA
INS1:	 PUSHJ P,GAPSLP	;GET THE GAP AROUND THE HOME COUNTRY
	MOVEI CH,ALTMOD	;GET THE TEMPORARY APROX-
			;IMATION TO THE DELIMITER
	TRZE FF,SLSL	;IF IT ISN'T RIGHT (THE UPARROW
			;INDICATOR IS TURNED ON)
	 PUSHJ P,RCH	;THEN GET THE RIGHT ONE
	MOVEM CH,INSDLM	;AND SAVE IT AS THE ONE TO USE
	TRNN FF,COLONF	;IF NOT INTO A Q-REG, THEN JUMP
	 JRST INS2	;FORWARD
INSAS1:	MOVE B,BFRBOT	;GET # CHARS UNUSED AFTER QREG SPACE,
	SUB B,QRWRT
	SUBI B,4	;WE'LL CERTAINLY NEED 4 FOR HEADER OF NEW QREG.
			;INS5 WILL PUT THAT IN TOTALC, # CHARS FREE TO USE.
	MOVE F,QRWRT	;START QREG AT START OF FREE SPACE,
	ADDI F,4	;BEGIN THE TEXT AFTER WHERE HEADER'LL GO.
	JRST INS5

INS2:	MOVE F,PT	;NEXT, GET THE POINTER ADDRESS
	MOVE B,EXTRAC	;# CHARS FREE TO STORE IN IS GAP SIZE.
INS5:	MOVEM B,TOTALC
	CALL GETIBP	;GET BP FOR IDPB INTO GAP.
	MOVEM P,INSINP	.SEE INSCHK	;GO TO INSDUN ON PTM ERROR, TO CLEAN UP.
	SETZM INSBP	;MAKE SURE F IS RELOCATED IF BUFFER MOVES.

;HERE IS THE LOOP THAT GETS CHARACTERS AND PUTS THEM IN THE BUFFER
INSLUP:	XCT INSRCH	;GET A CHARACTER (RCH AUTOMATICALLY
			;[ ;TAKES CARE OF ALL ^] CALLS AND MACRO
			;RETURNS)
INSDCK:	SKIPE SQUOTP	;UNLESS WITHIN QUOTED MACRO,
	 JRST INSDIR
	CAMN CH,INSDLM	;THEN SEE IF IT IS THE DELIMITER
	 JRST INSDUN	;IF SO, YOU'RE ALMOST DONE
INSDIR:	SOSGE TOTALC
	CALL INSSL1
	IDPB CH,F
	JRST INSLUP
 
INSSL1:	SETOM INSBP	.SEE BFRRL3 ;FAKE OUT THE ERROR CHECK AT BFRRL3+EPSILON
	CALL INSSLP
	SETZM INSBP
	RET

INSSLP:	MOVN B,TOTALC	;HOW MANY CHARS ALREADY KNOWN NEEDED.?
	TRNE FF,COLONF
	 JRST SLPQRG	;:I, MOVE UP BUFFER AT LEAST THAT MUCH.
	ADD B,EXTRAC
	JRST SLPSAV	;ELSE MAKE GAP > THAT MUCH BIGGER.

INSDUN:	SETOM INSBP
	CALL GETCA
	AOS OUT,F	;CHAR ADDR 1ST PLACE NOT STORED IN.
	TRNN FF,COLONF	;IF YOU'RE NOT USING A Q-REG
	JRST INS4	;THEN EVERYTHING IS MUCH SIMPLER
	SKIPGE TOTALC	;IF INSERTING 0 CHARS, MAKE SURE SPACE FOR HEADER.
	 CALL INSSL1
INSDU1:	MOVE B,F	;GET END OF QREG,
	MOVE F,QRWRT	;AND PLACE START OF HEADER SHOULD BE.
	SUB B,F	;# CHARS WE USED (TEXT SIZE +4)
	MOVEI AA,QRSTR	;THIS IS THE CHAR TO START THE HEADER
	CALL QHDRW0	;WRITE A QREG HEADER AT <- CHAR ADDR IN F.
INS3:	REST CH		;GET BACK ADDR OF QREG TO STORE IN.
	CALL QCLOSE	;STORE IN IT; OUT HAS CHAR ADDR END OF QREG.
			;QRWRT HAS CHAR ADDR OF BEINNING. UPDATES ALL PTRS.
	JRST INSRT1

INS4:	MOVEM F,PT
	MOVEM F,GPT
	MOVE CH,TOTALC	;# CHARS OF GAP WE DIDN'T USE.
	EXCH CH,EXTRAC	;IS WHAT'S LEFT OF THE GAP.
	SUB CH,EXTRAC	;AMOUNT WE DID USE
	MOVEM CH,INSLEN	;IS # CHARS INSERTED.
	ADDM CH,Z	;THAT MANY MORE CHARS NOW.
	ADDM CH,ZV
INSRT1:	SKIPN INSINP	;0 => WAS CLEARED BY INSCHK, WAS PTM ERROR.
	 TYPRE [PTM]
	SETZM INSINP	;NO LONGER IN MIDDLE OF INSERT.
	TRZ FF,COLONF+SLSL	;IF THIS IS :I*, WE ARE RETURNING VALUE SO MUST CLEAR THESE
	RET			;BY HAND.

INS1C:	ARGDFL
	TRNN FF,ARG2	;<N>,<CH>I - INSERT <CH> <N> TIMES.
	 MOVEI C,1
	SKIPGE C
TYPAOR:	 TYPRE [AOR]
	TRZE FF,COLONF
	 JRST INS1CQ	;INTO QREG?
	MOVE CH,NUM	;INTO BUFFER.
	ANDCMI FF,COLONF
	PUSHJ P,GAPSLP
	SKIPA B,C
TAB4:	 MOVEI B,1
	CALL SLPGET	;GET C(B) CHARS SPACE, AND B.P. IN F.
	IDPB CH,F
	SOJG B,.-1
	POPJ P,

TYOMGS:	CALL GAPSLP
TYOM:	SAVE B
	PUSH P,TT
	PUSH P,TT1
	SAVE F
	PUSHJ P,TAB4
	REST F
	POP P,TT1
	POP P,TT
POPBJ:	REST B
	RET

;<CH>:I<Q>  --  INSERT 1 CHAR IN QREG.
;<N>,<CH>:I<Q>  --  INSERT <N> COPIES OF CHARACTER.
;<CH>:I*  --  RETURNS A STRING CONTAINING THE CHARACTER <CH>.
INS1CQ:	CALL QREGVS	;GET QTAB IDX OF QREG IN CH.
	TRZ FF,ARG\ARG2\COLONF\SLSL
		;FLUSH ARG IN CASE :I* - OTHERWISE WOULD ADD ARG TO VALUE.
	JUMPE AA,INS1CR		;IS THE QREG SUBSCRIPTED? (:I:Q(IDX))
	JSP TT,QREGVA		;IF SO, EXTRA HAIR IN CASE OUR CONSING
				;MOVES THE Q-VECTOR CONTAINING THE Q-REG.
				;CALLS INS1CR, THEN RETURNS TO INSERT'S CALLER.
INS1CR:	MOVEI B,4(C)	;NEED 4 CHARS FOR HEADER, + CONTENTS.
	CALL SLPQGT	;MOVE BUFFER UP IF NEC.
	MOVEI AA,QRSTR	;1ST CHARACTER, FOR HEADER.
	MOVEI B,4(C)	;LENGTH, FOR HEADER.
	CALL QHDRW1	;WRITE THE QREG HEADER, LEAVE BP IN F.
	MOVE B,C
	MOVE A,NUM
	IDPB A,F
	SOJG B,.-1
	MOVEI OUT,4(C)	;GET ADDR 1ST CHAR THIS NEW STRING DOESN'T USE.
	ADD OUT,QRWRT
	JRST QCLOSE	;UPDATE QRWRT; STORE STRING IN QREG <- CH.

IFNDEF SLPAMT,SLPAMT==SLPWRD*5	;MAKE GAP IN UNITS OF THIS MANY CHARS.
IFNDEF SLPQAM,SLPQAM==SLPQWR*5	;MOVE BUFFER UP IN UNITS OF THIS MANY.

;MAKE SOME SPACE BY MOVING A SEGMENT OF MEMORY UPWARD.
;REAL CHARACTER ADDR. OF BOTTOM CHAR. OF SEGMENT TO MOVE IN F
;REAL CHAR ADDR OF SEGMENT IN TT.
;MINIMUM AMOUNT OF SPACE (# OF CHRS) IN B.
;SPACE IS MADE ONLY IN MULTIPLES OF A WORD.
SLPN00:	ADDI B,SLPAMT-1	;ASSUME ARG GIVEN IN B.
	IDIVI B,SLPAMT	;GET # UNIT INCREMENTS.
	IMULI B,SLPWRD	;# WORDS TO MOVE STUFF UP.
SLPN0Q:	IDIVI F,5
	ADDI TT,4
	IDIVI TT,5
	MOVEI C,(TT)
	ADDI C,(B)	;ADDR OF LAST WD TO MOVE INTO, + 1.
	SKIPE PSSAVP	;IF SORTING,
	 CAMGE C,PSMEM	;IF WE'D BE CLOBBERING SORT TABLES, MOVE THEM TOO.
	  JRST SLPN01
	MOVE TT,PSMEMT	;LAST WD TO MOVE UP IS LAST WD OF SORT TABLES,
	ADDI TT,3
	ADDM B,PSMEM	;RELOCATE POINTERS TO SORT TABLES.
	ADDM B,PSMEMT
	ADDM B,PSMXMT
SLPN01:	SUBM TT,F	;F _ # WDS TO MOVE.
	HRLI TT,-1	;TT HAS -1,,LAST WD + 1.
	SUB TT,[1,,1]	;MAKE -> LAST WD (1ST POP WILL MOVE IT)
	MOVEI E,(B)
	HRLI E,(POP TT,(TT))
	MOVE C,[SOJGE F,E]
	MOVE D,[JRST SLPN02]
	JRST C
SLPN02:	MOVE C,B	;GET BACK # WDS ADDED,
	IMULI C,5
	ADDM C,TOTALC
	POPJ P,

;MAKE SURE GAP AT LEAST SOME MINIMUM SIZE
;(# CHARS IN B)
SLPSAV:	CAMG B,EXTRAC
	 RET
	CALL SAVACS
	SUB B,EXTRAC	;HOW MANY MORE CHARS NEEDED?
	MOVE F,GPT	;GET ACTUAL ADDR OF END OF GAP.
	ADD F,EXTRAC
	MOVE TT,BFRTOP	;GET ACTUAL ADDR OF END OF BUFFER.
	SAVE Z
	SAVE MEMT
	PUSHJ P,SLPN00
	MOVEI E,@E	;GET ADDR LAST WD OF NEWLY MADE GAP.
	REST F		;DON'T NEED TO CLEAR NEWLY OBTAINED CORE.
	SKIPE YANKMT
	 MOVE F,YANKMT
	CAML E,F
	 SOS E,F
	MOVEI F,1	;PREPARE TO CLEAR LOW BITS OF WDS THAT NEED IT.
	REST A		;ANY WD PREVIOUSLY PART OF THIS BUFFER DOESN'T NEED IT.
	IDIVI A,5
SLPSA2:	CAMGE E,A
	 JRST SLPSA1
	ANDCAM F,(E)
	SOJA E,SLPSA2

SLPSA1:	ADDM C,EXTRAC
	MOVE T,C
	MOVE TT,Z
	CALL BFRRLC
	JRST RSTACS

;INSERT C(B) CHARS AT PT, MAKING SPACE IF NEC.
;PUTS PT AFTER THEM. ASSUMES GAP IS AT PT.
;DON'T ACTUALLY PUT ANYTHING IN THOSE CHARS,
;RATHER RETURN IN F A BP. TO IDPB INTO THEM.
;CLOBBERS TT, TT1.
SLPGET:	CAMLE B,EXTRAC	;HAVE ENOUGH ROOM FOR THE CHARS?
	 CALL SLPSAV	;NO, STRETCH GAP.
	MOVE F,PT
	ADDM B,PT	;UPDATE VARS FOR INSERTION OF THOSE CHARS.
	ADDM B,Z
	ADDM B,ZV
	ADDM B,GPT
	SUBM B,EXTRAC	;THE GAP IS NOW THAT MUCH SMALLER.
	MOVNS EXTRAC
	JRST GETIBP	;MAKE REMEMBERED PT (IN F) INTO BP.

;MAKE SURE UNUSED SPACE AFTER QREG SPACE AT LEAST C(B) CHARS.
;MAY MOVE BUFFER, IN WHICH CASE ALL BUFFER POINTERS WILL
;BE UPDATED AS NECESSARY.
SLPQGT:	ADD B,QRWRT	;CHAR ADDR LAST CHAR WE'LL NEED.
	SUB B,BFRBOT	;THAT CHAR IN BUFFER?
	JUMPL B,CPOPJ	;NO, HVE ENOUGH ROOM.

;GET AT LEAST C(B) MORE UNUSED SPACE FOR QREGS.
;WILL MOVE BUFFER AND UPDATE ALL BUFFER POINTERS.
SLPQRG:	CALL SAVACS
	MOVE F,BFRBOT	;MOVE ENTIRE BUFFER.
	MOVE TT,BFRTOP	;GET REAL ADDR. END OF BUFFER.
	ADDI B,SLPQAM-1
	IDIVI B,SLPQAM	;# OF UNIT INCREMENTS WE NEED.
	IMULI B,SLPQWR	;# OF WDS TO MOVE THE BUFFER.
	CALL SLPN0Q	;MOVE IT.
	MOVE T,C
	CALL BFRMOV	;RELOCATE ALL PTRS TO BUFFER.
	JRST RSTACS

;CLOSE UP THE GAP, AND SAY IT IS AT PT.
SLPSHT:	SKIPN EXTRAC	;NOTHING TO DO IF NO GAP.
	 JRST GAPSLN
	SAVE Q
SLPSH1:	MOVE Q,Z
	CAMN Q,GPT
	 JRST SLPSH2
	EXCH Q,PT
	SAVE Q
	CALL GAPSLP	;THEN MOVE THE GAP TO PT.
	REST PT
SLPSH2:	REST Q
	CALL GAPKIL	;NOW GAP IS AT END, JUST FORGET ABOUT IT.
GAPSLN:	SAVE PT		;GAP LENGTH IS 0, MAKES NO DIFFERENCE WHERE
	REST GPT		;WE SAY THE GAP IS LOCATED.
	RET

;ASSUMING THAT THE GAP IS AT THE END OF THE CURRENT BUFFER,
;CLOSE IT UP. CLOBBERS NO ACS. RELOCATES ALL NECESSARY POINTERS
;IN BUFFER FRAMES (AND BFRTOP).
GAPKIL:	SAVE A
	SAVE B
	SAVE AA
	MOVE A,Z
	ADD A,EXTRAC
	IDIVI A,5	;WHAT WORD DOES THE THING AFTER THE BUFFER
	MOVE B,A	;ACTUALLY START IN?
	IMULI A,5
	ADDI A,5
	CAML A,BFRTOP	;IF THERE'S NOTHING AFTER THE BUFFER, JUST CHANGE A FEW POINTERS
	 JRST [	MOVE A,Z	;IN PARTICULAR BFRTOP POINTED AFTER GAP,
		IDIVI A,5
		IMULI A,5	;MAKE IT -> CHAR ADDR OF WORD BNDRY
		ADDI A,5	;AFTER THE END OF THE BUFFER.
		MOVEM A,BFRTOP
		JRST GAPKI1]
	SAVE B		;THERE'S ANOTHER BUFFER AFTER THIS ONE.
	MOVE A,Z
	IDIVI A,5	;WHAT WORD SHOULD IT START IN (ACTUALLY 1 LESS THAN)
	HRL A,(P)	;AND -1+<WHERE IT DOES START>
	HRRZ B,A
	SUB B,(P)	;B HAS -<HOW FAR DOWN IT'S MOVING>
	ADD A,[1,,1]	;<WHERE IT STARTS>,,<WHERE IT SHOULD>
	MOVEM A,(P)
	SAVE B
	MOVE A,BFRTOP
	IDIVI A,5	;WORD FOR BLT TO STOP MOVING OUT OF (PLUS 1)
	REST B
	ADDI A,-1(B)
	EXCH B,(P)
	BLT B,(A)
	EXCH T,(P)	;GET # WORDS THINGS MOVED BY.
	IMULI T,5
	SAVE TT
	MOVE TT,Z
	ADD TT,EXTRAC
	CALL BFRRLC	;RELOCATE PTRS TO BUFFERS WE MOVED.
	REST TT
	REST T
GAPKI1:	SETZM EXTRAC
	REST AA
POPBAJ:	REST B
	REST A
	RET

;MOVE THE GAP DOWN (IE MOVE CHARS FROM PT TO GPT UP)
GAPDN:	MOVE Q,PT
	ADD Q,BFRTOP	;COMPUTE AVERAGE OF PT AND BFRTOP, THEN COMPARE WITH GPT
	LSH Q,-1
	CAMG Q,GPT	;IS GPT CLOSER TO PT, OR TO BFRTOP?
	 JRST SLPSH1	;CLOSER TO BFRTOP; FASTER TO CLOSE GAP AND REGENERATE IF DESIRED
	REST Q		;GPT CLOSER TO PT; FASTER TO MOVE GAP DIRECTLY TO POINT.
	CALL SAVACS
GAPDN3:	MOVE F,GPT	;MOVE THE 1ST FEW CHARS UP,
	CAMN F,PT	;(FOR GETTING HERE 2ND TIME WITH
	 JRST RSTACS	 ;TO BE MOVED)
	CALL GETBP	;GET PTR FOR FETCHING CHARS BELOW GAP,
	MOVE TT,GPT
	ADD TT,EXTRAC	;GET PTR FOR STORING ABOVE GAP.
	IDIVI TT,5
	MOVE A,GPT	;GET TOTAL # CHARS MUST MOVE UP.
	SUB A,PT
	SOJL TT1,GAPDN2 ;ALREADY MOVING TO WD BNDRY.
GAPDN1:	DBP7 F		;GET PTR -> LAST CHAR BELOW GAP.
	LDB CH,F
	DPB CH,BTAB(TT1) ;MOVE IT BELOW TOP OF GAP.
	SOS GPT		;GAP HAS MOVED DOWN 1 CHAR.
	SOJLE A,RSTACS	;GAP HAS REACHED PT => DONE.
	SOJGE TT1,GAPDN1 ;EFFECTIVELY DBP7 THE OUTPUT BP.
GAPDN2:	CAIGE A,5	;TOP OF GAP NOW ON WD BNDRY
GAPDN5:	 SOJA TT,[ADDI TT1,5	;< 1 WD LEFT, KEEP
		JRST GAPDN1]	;CHAR AT A TIME.
	MOVE 14,EXTRAC	;MOVE AS MUCH AS CAN, WD AT A TIME.
	IDIVI 14,5
	IMULI 15,7
	MOVN 12,15
	MOVEI 15,-43(15)
	MOVE AA,PT
	ADDI AA,4
	IDIVI AA,5
	MOVE 16,GPT
	IDIVI 16,5
	MOVEI B,(16)
	SUB B,AA
	JUMPE B,[MOVE TT,GPT	;IF CAN'T MOVE ANYTHING WORD-WISE AFTER ALL,
		 ADD TT,EXTRAC	;REENTER CHAR-AT-A-TIME LOOP
		 IDIVI TT,5
		 SOJA TT1,GAPDN5]
	MOVE 10,AA
	MOVN 16,B	;MAKE GPT REFLECT THE MOTION OF GAP
	IMULI 16,5	;THAT IS NOW ABOUT TO BE DONE.
	ADDM 16,GPT
	JUMPE 12,GAPDN4	;(TRANSLATING BY INTEGRAL # OF WDS.)
	ADDI 14,1(10)
	HRLI 10,(MOVE A,(B))
	HRLOI 11,(ROT A,)
	HRLI 12,(ROTC A,)
	MOVE 13,[ANDCMI AA,1]
	HRLI 14,(MOVEM AA,(B))
	HRLI 15,(ROTC A,)
	MOVE 17,[JRST GAPDN3]
	MOVE AA,@10
	MOVE 16,.+1
	SOJGE B,10

GAPDN4:	HRLI 14,(POP 10,(10))	;EXTRAC = 0 MOD 5, NEED NOT ROTATE
	ADDI 10,-1(B)		;-> HIGHEST WD TO MOVE FROM
	HRLI 10,-1		;PREVENT PDL OV.
	MOVE 16,[JRST GAPDN3] ;INSN THAT EXITS LOOP.
	MOVE 15,.+1
	SOJGE B,14	;B HAS # WDS TO MOVE.

;MOVE THE GAP TO PT.
GAPSLP:	SKIPN EXTRAC	;NO GAP REALLY =>
	 JRST GAPSLN	 ;JUST SAY IT'S AT PT, REALLY DOESN'T MATTER.
	SAVE Q
	MOVE Q,PT
	CAMN Q,GPT	;GAP ALREADY AT PT => NOTHING TO DO.
	 JRST POPQJ
	CAMG Q,GPT	;MOVING GAP DOWN => DIFFERENT.
	 JRST GAPDN
	REST Q
	CALL SAVACS
GAPUP3:	MOVE F,GPT	;MOVE 1ST FEW CHARS 1 AT A TIME.
	CAMN F,PT	;(WHEN GET HERE 2ND TIME,
	 JRST RSTACS	 ;MIGHT BE NOTHING TO MOVE)
	ADD F,EXTRAC	;GET FETCHING PTR -> ABOVE GAP.
	CALL GETIBP
	MOVE TT,GPT
	IDIVI TT,5	;GET STORING PTR -> BELOW GAP.
	MOVE A,PT
	SUB A,GPT	;GET TOTAL # CHARS TO BE MOVED.
	JUMPE TT1,[SOJA TT,GAPUP2]
GAPUP0:	SUBI TT1,5	;(WILL INCREM. TO 0 WHEN REACH WD BNDRY)
GAPUP1:	ILDB IN,F	;GET A CHAR FROM ABOVE GAP,
	DPB IN,BTAB+5(TT1) ;PUT IT BELOW GAP,
	AOS GPT		;SAY GAP HAS MOVED UP 1 CHAR.
	SOJLE A,RSTACS	;GAP HAS REACHED PT => DONE.
	AOJN TT1,GAPUP1	;EFFECTIVELY IBP THE STORING PTR.
GAPUP2:	CAIGE A,5	;BOTTOM OF GAP NOW ON WD BNDRY,
	 AOJA TT,GAPUP0	;< 1 WDS LEFT => KEEP GOING CHAR BY CHAR.
	MOVEI B,1(TT)	;GET ADDR 1ST WD TO MOVE DOWN INTO.
	MOVE 11,PT
	ADD 11,EXTRAC	;REAL ADDR 1ST CHAR NOT TO MOVE DOWN.
	SUBI 11,5	;DON'T MOVE THE LAST 5 CHARS WITH FAST LOOP (CAN GARBAGE).
	IDIVI 11,5	;11 -> HIGHEST WD TO MOVE DOWN FROM.  NOTE 11 = TT.
	MOVN 13,EXTRAC
	IDIVI 13,5
	JUMPE 14,[	;HERE IF CAN USE BLT (ALL ON WORD BNDRYS).
		SUBM B,13	;13 GETS 1ST ADDR TO MOVE FROM.
		MOVEI 12,1(11)	;NOTE IF BLT'ING IT'S SAFE TO MOVE THE LAST WORD.
		SUB 12,13	;# WDS TO SHIFT.
		IMULI 12,5
		ADDM 12,GPT	;UPDATE GPT FOR WHAT WE'RE DOING HERE.
		HRLI B,(13)
		BLT B,(11)
		JRST GAPUP3]
	ADDI 13,-1(11)	;13 -> HIGHEST WD TO MOVE DOWN INTO.
	MOVNM 14,12
	IMULI 12,7
	MOVNI 15,-43(12)
	SUBI B,1(13)	;B HAS MINUS # WDS TO MOVE
	JUMPE B,[AOS TT,13	;WOULD MOVE 0 WORDS (CAN HAPPEN) => DO REST BY CHARS.
		 SETZ TT1,
		 JRST GAPUP0]
	MOVN 16,B	;UPDATE GPT FOR THE WDS WE'RE MOVING.
	IMULI 16,5
	ADDM 16,GPT
	HRLI 11,(MOVE AA,(B))
	HRLI 12,(ROTC A,)
	HRLI 13,(MOVEM A,(B))
	MOVE 14,[ADDM A,@13]
	HRLI 15,(ROTC A,)
	MOVE 17,[JRST GAPUP3]
	MOVE A,@11
	ROT A,-1
	MOVE 16,.+1
	AOJLE B,11

GCNRL:	SETOM GCNRLC	;GC TO RECLAIM MACRO FRAMES. DON'T MOVE QREGS.
	CAIA		;(THEREFORE, CAN BE CALLED IN MID-COMMAND)
GC:
GCC:	SETZM GCNRLC
	CALL SAVACS
	CALL MEMTOP	;A -> 1ST UNUSED WORD ABOVE BFR & SORT TABLES.
	HRLI A,4400
	MOVEM A,GCPTR	;GCPTR HAS B.P. TO IDPB INTO HIGH CORE.
	PUSH P,A	;REMEMBER WHAT ITS STARTING VALUE WAS.
	MOVE B,BFRPTR	;COPY BEG, ETC. INTO CURRENT BUFFER'S
	CALL NEWBFR	;FRAME, SO THE LATTER IS UP TO DATE.
	CLEARM SYMS
	MOVE T,[SYMS,,SYMS+1]
	BLT T,SYMEND-1	;CLEAR THE JUMP CACHE, SINCE IT WILL NOW BECOME INVALID.
	MOVEI T,CPTR	;MARK CPTR
	PUSHJ P,GCMA
GCC1:	MOVEI T,MFSTRT+MFCPTR	;MARK ALL MACRO FRAMES' STRINGS.
GCC2:	SKIPGE MFBEG-MFCPTR(T)	;DON'T MARK BUFFER FRAMES THIS WAY.
	 JRST GCC4
	ADDI T,MFARG1-MFCPTR
	CALL GCM	;MARK MACRO ARG 1 (MAY BE A STRING POINTER)
	ADDI T,MFARG2-MFARG1
	CALL GCM	;MARK MACRO ARG 2
	SUBI T,MFARG2-MFCPTR	;POINT TO CPTR AGAIN
	SKIPE (T)
	 PUSHJ P,GCMA
GCC4:	ADDI T,MFBLEN
	CAIGE T,MFEND
	 JRST GCC2
GCC3:	HRRZ T,PF	;MARK THE QREG PDL.
	CAIL T,PFL	;MARK BOTH VALUES AND ADDRS, SINCE "ADDR" MIGHT BE A NAME-STRING.
GCC5:	 CALL GCM
	CAILE T,PFL
	 SOJA T,GCC5
	HRRZ T,LEV	;NOW MARK ALL SAVED VALUES
GCC7:	SKIPN A,T	;OF ALL PAREN'S.
	 JRST GCC8	;WE'VE REACHED THE OUTERMOST; WE'RE DONE.
	SUBI T,2	;GET ADDR OF LAST SAVED VALUE.
	CALL GCM
	SUBI T,1	;GET ADDR OF 1ST (IF THERE ARE 2)
	MOVE TT,2(T)	;GET THE WORD WHICH SAYS HOW MANY.
	TRNE TT,ARG2	;IF THERE ARE 2, MARK THE 1ST.
	 CALL GCM
	MOVE T,(A)	;NOW HANDLE NEXT PAREN OUT.
	JRST GCC7

GCC8:	MOVE T,[-NQREG,,QTAB]
	CALL GCM
	AOBJN T,.-1
	MOVE T,[-RRMACL,,RRMACT]
	CALL GCM
	AOBJN T,.-1
IRPS XX,,DISOMD SBFRS BFRSTR MARG1 MARG2 SARG NUM SYL RRXINV RRENTM RRLEVM RRDISM LASTER
	MOVEI T,XX
	CALL GCM
TERMIN
	POP P,A
	MOVE T,A	;STARTING GCPTR MINUS CURRENT
	SUB T,GCPTR	;GIVES -<# WDS IDPB'D>
	HRLM T,A	;AOBJN -> TABLE OF POINTERS.
	ADDI A,1
	MOVEM A,GCPTR
	JUMPGE A,GCE	;NO ENTRIES => NO QREGS TO GC.
	SKIPE GCNRLC	;IF SHOULDN'T MOVE QREGS, SKIP THAT PART.
	 JRST GCE5
;FALLS THROOUGH.

;FALLS THROUGH.

GCS:	MOVE IN,QRBUF
	ADDI IN,EREND*5-INIQRB	;DON'T SWEEP THE ERROR MESSAGES;  THEY ARE ALWAYS NEEDED.
GCS1A:	MOVSI TT,1*5
	MOVE OUT,GCPTR
GCS1:	MOVE A,(OUT)	;FIND LOWEST PNTR (HIGHER OR = TO C(IN) IN TT
	ADD A,QRBUF
	CAMGE A,IN
	 JRST GCS2
	CAMGE A,TT
	 MOVE TT,A
GCS2:	AOBJN OUT,.+1
	AOBJN OUT,GCS1
	TRNN TT,-1
	 JRST GCE1
	MOVE F,TT
	IDIVI IN,5
	IDIVI F,5
	ADDI IN,1
	MOVS OUT,F
	MOVE T,F
	SUB T,IN
	JUMPLE T,GCS4A
	HRR OUT,IN
	MOVE B,QRWRT
	IDIVI B,5
	SUBI B,(T)
	BLT OUT,(B)
	MOVNS OUT,T
	IMULI T,5
	MOVE CH,GCPTR
GCS3:	MOVE A,(CH)
	ADD A,QRBUF
	CAMGE A,TT
	 JRST GCS4
	ADDM T,(CH)
	MOVE A,1(CH)
	SKIPL (A)
	 ADDM OUT,(A)
	SKIPGE (A)
	 ADDM T,(A)
GCS4:	AOBJN CH,.+1
	AOBJN CH,GCS3
	ADD TT,T
GCS4A:	MOVE IN,TT	;CHAR ADDR START OF QREG.
	MOVE F,TT
	CALL GETBP	;GET QREG LENGTH IN AA, BP TO TEXT IN F.
	LDB CH,F	;TO DO THAT, FIRST FIND OUT WHAT TYPE OBJECT THIS IS.
	CAIN CH,QRBFR	;IT'S A BUFFER,
	 JRST [	ADDI IN,4	;IT OCCUPIES 4 CHARS OF STRING SPACE.
		JRST GCS1A]
	CALL QLGET3	;IT'S A STRING; FIGURE ITS LENGTH
GCERR:	 .VALUE
	CALL GETCA	;CHAR ADDR START OF TEXT
	ADD F,AA	;PLUS TEXT LENGTH
	AOS IN,F	;GIVES CHAR ADDR 1ST CHAR AFTER QREG.
	JRST GCS1A

GCM:	MOVE IN,(T)
	TLZE IN,400000
	 CAML IN,[LHIMIN*5*2000]
	  RET
	CAIGE IN,EREND*5-INIQRB
	 RET			;NO NEED TO MARK BUILT-IN ERROR MESSAGES SINCE NOT SWEPT.
	ADD IN,QRBUF
GCM3:	CAML IN,BFRBOT
	 RET
	CALL GET
	CAIN CH,QRBFR
	 JRST GCMB
	CAIE CH,QRSTR
	 RET
GCM2:	SUB IN,QRBUF
	JUMPL IN,CPOPJ
	IDPB IN,GCPTR
	IDPB T,GCPTR
	POPJ P,

GCMA:	LDB TT,[(221400+T)]	;PTR IN T
	CAIE TT,700
	POPJ P,	;40,, BIT NOT SET (NOT PNTR TO STRING STG) OR NOT BYTE PNTR AT ALL
	MOVE IN,-1(T)	;GET COMAX
	SUB IN,1(T)	;SUB COMCNT
	LDB TT,[(360600+T)]
	IDIVI TT,7
	HRRZ TT1,(T)
	IMULI TT1,5
	SUBI TT1,(TT)
	ADDI TT1,1
	SUBM TT1,IN
	JRST GCM3

;FOUND A POINTER TO A BUFFER.
GCMB:	MOVE F,IN
	CALL GCM2	;MARK THE 4-CHAR STRING THAT WE GO INDIRECT THROUGH,
	CALL GETBP	;GO INDIRECT THROUGH IT TO GET FRAME ADDRESS
	CALL QLGET4	;RETURNS <FRAME ADDR>-4
	JUMPL AA,CPOPJ	;DEAD BUFFER HAS NO BUFFER FRAME.
	MOVSI IN,MFMARK	;AND MARK THE BUFFER FRAME AS LIVING.
	IOR IN,4(AA)
	EXCH IN,4(AA)
	TLNN IN,MFMARK	;IF THE FRAME WASN'T ALREADY MARKED,
	 TLNN IN,MFQVEC	;AND MUST BE MARKED THROUGH, DO SO.
	  RET
	SAVE T
	MOVE T,MFBEG+4(AA)
	TLZ T,MFBBTS
	IDIVI T,5	;FIRST, MARK BELOW THE GAP.
	MOVE TT,MFGPT+4(AA)
	CALL GCMBR
	MOVE T,MFGPT+4(AA)
	ADD T,MFEXTR+4(AA)
	IDIVI T,5	;THEN MARK ABOVE GAP (GPT+EXTRAC TO Z+EXTRAC)
	MOVE TT,MFZ+4(AA)
	ADD TT,MFEXTR+4(AA)
	CALL GCMBR
POPTJ:	REST T
	RET

GCMBR:	SAVE AA		;T HAS WORD ADDR, TT CHAR ADDR.
	IDIVI TT,5	;MARK ALL TEH WORDS FROM T TO TT.
	SUBM T,TT
	HRL T,TT
	SKIPGE T
	 CALL GCM
	AOBJN T,.-1
	REST AA
	RET

GCE5:	SKIPA IN,QRWRT
GCE:	 MOVE IN,QRBUF
GCE1:	MOVE CH,IN	;GC AGAIN AFTER GCOFTN CHARS
	ADDI CH,GCOFTN	;OF QREG ARE CREATED.
	SKIPL GCNRLC
	 MOVEM CH,QRGCMX
	MOVEM IN,QRWRT		;CHAR ADDR ABOVE END OF STRING SPACE.
	ADDI IN,SLPQAM*2	;LEAVE 2*SLPQAM CHARS SPACE TO WRITE MORE STRINGS INTO,
	CAML IN,BFRBOT		;AND IF BUFFER STARTS ABOVE THAT POINT,
	 MOVE IN,BFRBOT		;MOVE IT DOWN TO THAT POINT.  ELSE DON'T MOVE IT.
	IDIVI IN,5
IFN TS,[
	MOVE CH,QRWRT
	ADDI CH,2000*5-1	;COMPUTE 1ST PAGE QREGS DON'T NEED.
	IDIVI CH,2000*5
	LDB Q,[121000,,IN]	;AND 1ST PAGE BUFFER NEEDS.
	SUBM CH,Q		;-<# PAGES WE CAN FLUSH>
	JUMPE Q,GCE2
	HRLI CH,(Q)		;AOBJN -> PAGES TO FLUSH.
	SYSCAL CORBLK,[1000,,0 ? 1000,,-1 ? CH]
	 JFCL
GCE2:
]
	MOVEI A,MFSTRT		;LOOK AT ALL BUFFER FRAMES,
GCE3:	MOVE T,MFBEG(A)	;AND RELEASE ALL THE DEAD ONES.
	TLNN T,MFBFR
	 JRST GCE4		;THIS IS A MACRO CALL, NOT A BUFFER.
	TLZN T,MFMARK
	 JRST [	CALL KILBFR	;THIS ONE IS DEAD.
		JRST GCE4]
	MOVEM T,MFBEG(A)	;CLEAR THE MARK-BIT.
GCE4:	ADDI A,MFBLEN
	CAIGE A,MFEND
	 JRST GCE3
	MOVE T,BFRBOT		;C(IN) IS THE PLACE BUFFER SPACE
	IDIVI T,5		;SHOULD START; MOVE IT DOWN IF NEC.
	CAMG T,IN
	 JRST RSTACS
	SUBM IN,T
	HRLS IN
	SUB IN,T
	MOVSS IN
	MOVE B,BFRTOP
	IDIVI B,5
	ADDI B,(T)
	BLT IN,(B)
	CALL BFRMVW
	CALL FLSCOR
	JRST RSTACS

;PUSHJ HERE, AND IT RETURNS WITH ACS 2-17 SAVED.
SAVLNG==16	;NUM LOCATIONS PUSHED
SAVACS:	EXCH	2,(P)		;SAVE REG. 1.
	PUSH	P,3
	MOVEI	3,1(P)		;SET UP BLT POINTER.
	HRLI	3,4
	ADD	P,[14,,14]	;POINT TO LAST PLACE TO PUSH TO.
	BLT	3,(P)
	JRST	(2)

RSTACS:	HRLZI	17,-SAVLNG+1(P)	;SET UP BLT POINTER.
	HRRI	17,2
	BLT	17,17
	SUB	P,[SAVLNG,,SAVLNG]	;POINT TO BEFORE SAVED REGS.
	RET

;A -> BUFFER FRAME; FREE THE FRAME AND THE SPACE IT POINTS TO.
;CLOBBERS B,C,T,TT.
KILBFR:	MOVEI B,(A)
	SAVE BFRPTR
	CALL NEWBFR	;SELECT THAT BUFFER FRAME AS CURRENT.
	MOVE B,Z
	MOVE C,BEG
	CALL DELET1	;DELETE ALL THE TEXT IN IT.
	MOVEI B,5	;FAKE GAPKIL INTO CLOSING UP THE 1-WORD INTER-BUFFER
	ADDM B,EXTRAC	;GAP, AS WELL AS THE ACTUAL SPACE OCCUPIED BY THIS BFR.
	MOVNI B,5
	ADDM B,Z
	CALL GAPKIL	;FLUSH ALL SPACE IN BUFFER AREA USED BY THIS BUFFER.
	SETZM MFBEG(A)	;FREE THE BUFFER FRAME BY CLEARING MFBFR BIT
	SAVE A
	SOJ A,
	CALL FLSFRM	;AND PUTTING ON FREELIST (WHOSE POINTERS -> FRAME-1)
	REST A
	REST B		;NOW RESELECT THE BUFFER THAT WAS CURRENT AT CALL.
			;WITH OUT DESELECTING THE NOW-DEAD BUFFER
	JRST NEWBF1	;(THE IDEA IS TO AVOID SETTING ITS MFBFR BIT).

;B -> BUFFER FRAME; SELECT IT AS CURRENT. SETS UP BEG, ETC.
;CLOBBERS B,T,TT.
NEWBFR:	MOVE T,BFRPTR	;COPY BEG, ETC. BACK INTO THE FRAME
	MOVE TT,T	;THEY CAME FROM.
	HRLI T,BEG	;(THAT IS, THE ONE CEASING TO BE CURRENT)
	SAVE MFBEG(TT)	;DON'T CLOBBER THE MFBFR AND MFMARK BITS.
	BLT T,MFEXTR(TT)
	REST T
	AND T,[MFBBTS,,]
	IORM T,MFBEG(TT)
NEWBF1:	MOVEM B,BFRPTR	;REMEMBER WHICH FRAME NOW CURRENT.
	SKIPL (B)	;SELECTING A FRAME WHICH ISN7T A BUFFER?
	 .VALUE
	MOVSS B
	HRRI B,BEG
	BLT B,EXTRAC	;SET UP VARS FOR IT.
	MOVSI T,MFBBTS	;BUFFER FLAG BITS SHOULD BE IN MFBEG BUT NOT BEG.
	ANDCAM T,BEG
	RET

;<N>FSWORD$ RETURNS WORD OF BUFFER CONTAINING CHARACTER AFTER <N>
;<W>,<N>FSWORD$ ALSO SETS THAT WORD TO <W>. NOTE THAT NO WORD EVER
;CONTAINS PART OF 2 DIFFERENT BUFFERS, BECAUSE OF FSBCREATE$'S ALLOCATION POLICY.
FSWORD:	TRZN FF,ARG
	 TYPRE [WNA]
	TRZE FF,ARG2
	 IORI FF,ARG	;2 ARGS => WRITING; ELSE READING.
	ADD B,BEG	;GET VIRT CHAR ADDRESS OF A CHAR IN DESIRED WORD.
	CALL CHK	;"NIB" IF OUTSIDE BUFFER BOUNDS.
	CAMLE B,GPT	;CONVERT VIRTUAL ADDRESS TO REAL ADDRESS.
	 ADD B,EXTRAC
	IDIVI B,5	;GET ADDRESS OF WORD CONTAINING CHAR AFTER SPEC'D CHAR ADDR.
	MOVE C,B	;PUT ADDRESS OF FLAG-WORD IN C FOR FSNORM
	MOVE B,SARG	;AND VALUE TO STORE (IF ANY) IN B, THE ARGUMENT TO FSNORM.
	JRST FSNOR1	;NOW READ AND MAYBE WRITE THE BUFFER WORD.

BFRMVW:		IMULI T,5
BFRMOV:	MOVE TT,BFRBOT
	ADDM T,BFRBOT
	ADDM T,BEG
	ADDM T,BEGV
	ADDM T,PT
	ADDM T,GPT
	ADDM T,ZV
	ADDM T,Z
	JRST BFRRLC

;RELOCATE POINTERS INTO BUFFER SPACE WHEN PART OF IT MOVES.
;ALL POINTERS IN ALL BUFFER FRAMES ARE CHANGED IF THEY ARE
;LARGER THAN C(TT) WHICH IS PRESUMABLY THE CHAR ADDR AT WHICH
;SOMETHING GREW OR SHRANK. C(T) IS THE AMOUNT TO ADD TO EACH
;POINTER. DOES NOT RELOCATE BEG, BEGV, PT, GPT, ZV OR Z.
;BYTE POINTERS IN MACRO FRAMES, AND CPTR AND INSBP, ARE ALSO RELOCATED.
;CLOBBERS A,B. RELOCATES BFRTOP PROPERLY.
BFRRLC:	SKIPL @BFRPTR	;CURRENT BUFFER HEADER ISN'T A BUFFER HEADER?
	 .VALUE
	SAVE F
	MOVE A,BFRTOP	;TO SAVE TIME, IF WE CAN FIGURE OUT THAT THE CHANGE
	SUBI A,5	;TOOK PLACE IN THE UPPERMOST BUFFER, THEN WE KNOW NO
	CAMLE TT,A	;BUFFER HAS TO BE RELOCATED.
	 JRST BFRRL3	;SO WE DON'T HAVE TO TEST THEM ALL.
	MOVEI A,MFSTRT	;SCAN ALL BUFFER FRAMES.
BFRRL1:	SKIPL B,MFBEG(A)	.SEE MFBFR
	 JRST BFRRL4	;THIS FRAME ISN'T A BUFFER FRAME.
	TLZ B,MFBBTS	;IT IS A BUFFER FRAME.
	CAME A,BFRPTR
	 CAMGE B,TT	;IS IT HIGH ENOUGH IN MEMORY TO BE RELOCATED?
	  JRST BFRRL2
INSIRP ADDM T(A),MFBEG MFBEGV MFPT MFGPT MFZV MFZ
	ADD B,T
	CAMGE B,BFRBOT	;BUFFER RELOCATED TO BELOW BUFFER SPACE?
	 .VALUE
BFRRL2:	ADDI A,MFBLEN
	CAIGE A,MFEND
	 JRST BFRRL1
BFRRL3:	MOVE F,CPTR	;RELOCATE CPTR - MAYBE WE'RE EXECUTING OUT OF A BUFFER NOW.
	CALL BFRRL5
	 MOVEM F,CPTR
	SKIPE INSINP
	 SKIPE INSBP
	  CAIA
	   .VALUE	;IN INSERT, AND INSBP ISN'T SAVING IT??
	MOVE F,INSBP
	CALL BFRRL5
	 MOVEM F,INSBP
	ADDM T,BFRTOP
	SKIPL @BFRPTR
	 .VALUE
POPFJ:	REST F
	RET

BFRRL4:	MOVE F,MFCPTR(A) ;MACRO FRAME FOUND: IF THE CPTR POINTS AT A BUFFER,
	CALL BFRRL5	;RELOCATE IT IF THAT BUFFER IS MOVING.
	 MOVEM F,MFCPTR(A)
	JRST BFRRL2

BFRRL5:	SAVE TT		;F HAS A B.P.  EITHER RELOCATE IT, OR SKIP IF IT'S UNCHANGED.
	CALL GETCA
	REST TT
	CAMGE F,[LHIMIN*5*2000]
	 CAMGE F,TT
	  JRST POPJ1	;IF WE SKIP, F IS CLOBBERED, BUT CALLER SHOULD ASSUME UNCHANGED.
	ADD F,T		;RELOCATE THE POINTER IF NEC.
	SAVE TT
	CALL GETBP
	REST TT
	RET

;WRITE A STRING HEADER. AA HAS INITIAL CHARACTER (QRSTR OR QRBFR),
;B HAS CONTENTS (LENGTH OR BUFFER FRAME ADDRESS).
;F IS LEFT WITH A B.P. TO LAST CHAR. OF HEADER.
;CLOBBERS B,T,TT.
QHDRW1:	MOVE F,QRWRT	;WRITE HEADER IN FIRST FREE SPOT.
QHDRW0:	CALL GETBP	;ASSUME F HAS CHAR ADDR OF PLACE TO WRITE.
	DPB AA,F
	IDPB B,F
	LSH B,-7
	IDPB B,F
	LSH B,-7
	IDPB B,F
	RET

;ASSUME A STRING HAS BEEN STORED IN THE AREA ABOVE QRWRT,
;UPDATE QRWRT AND STORE STRING PTR IN QREG.
QCLOSP:	REST CH		;QREG ADDR IS ON STACK.
QCLOSE:	EXCH OUT,QRWRT	;QREG ADDR IN CH.
	SUB OUT,QRBUF
	TLO OUT,400000
	MOVEM OUT,(CH)
	RET

BFRSE2:	MOVEM AA,PF	;SPECIAL ENTRY FROM FSQPUN
			;STORE BACK QREG PDL PTR; OTHERWISE ERROR QNB WOULD
			;CAUSE A LOOP DUE TO AUTOMATIC UNWIND.

;ASSUME QREG IN CH HAS A STRING PTR TO A BUFFER'S POINTER STRING;
;MAKE THAT BUFFER CURRENT. CLOBBERS F,T,TT.
BFRSE1:	SAVE B
	SAVE [POPBJ]
	MOVE B,(CH)
;ASSUME B B HAS STRING PTR. CLOBBERS B,F,T,TT.
BFRSET:	SAVE AA
	SAVE B
	CALL QBGET
	SKIPN B,AA
	 TYPRE [QNB]	;SELECTING A KILLED BUFFER?
	REST BFRSTR
	REST AA
	JRST NEWBFR

;B HAS STRING PTR TO PTR STRING OF BUFFER.
;RETURN IN AA THE ADDR OF THE FRAME.
;RETURN IN CH A BP TO 1ST CHAR OF POINTER STRING.
;CLOBBERS F,T,TT.
QBGET:	MOVE F,B
QBGET1:	ADD F,QRBUF
	TLZE F,400000
	 CAML F,QRWRT
	  TYPRE [QNB]
	CALL GETBP
	LDB CH,F
	CAIE CH,QRBFR
	 TYPRE [QNB]
	MOVE CH,F
	CALL QLGET4	;FORM NEXT 3 CHARS INTO NUMBER IN AA
	ADDI AA,4	;QLGET4 SUBTRACTS 4; WE MUST COMPENSATE.
	RET

;FS BCREATE$ -- CREATE A NEW BUFFER, AND MAKE IT CURRENT.
FSCRBF:	CALL FSCRB1
	MOVEI CH,$QBUFR	;ADDR OF QREG TO STORE IN.
	CALL QCLOSE
	MOVEM OUT,BFRSTR ;SET INTERNAL Q..O AS WELL.
	MOVE B,A
	JRST NEWBFR	;SET PREDIGESTED Q..O (BFRPTR) AS WELL.

;FS BCONS$ -- RETURNS A NEWLY CREATED BUFFER.
FSBCON:	CALL FSCRB1
FSBCO1:	MOVEI CH,A
	CALL QCLOSE
	JRST POPJ1

;FS QVECTOR$ -- RETURNS A QREG VECTOR BUFFER.
FSQVEC:	CALL FSCRB1
	MOVSI T,MFQVEC
	IORM T,(A)	;NOTE A -> BUFFER FRAME.
	JRST FSBCO1

FSCRB1:	TRZN FF,ARG
	 SETZ B,	;B HAS # OF CHARS OF SPACE TO MAKE IN THE BUFFER.
	SAVE B		;(SPACE IS NOT INITIALIZED).
	CALL GETFRM	;OBTAIN FRAME FOR BUFFER; ADDR IN A.
	MOVEI A,1(A)	;GETFRM ACTUALLY GIVES ADDR OF FRAME MINUS 1.
	MOVEI B,4
	CALL SLPQGT	;GET SPACE FOR POINTER-STRING.
			;NOW THE BUFFERS WON'T MOVE, SO WE CAN SET
			;UP THE POINTERS IN THE FRAME.
	SETZM MFEXTR(A)
	MOVE B,BFRTOP	;PUT THIS NEW BUFFER AT TOP OF MEM.
INSIRP MOVEM B(A),MFBEGV MFPT MFGPT MFZV MFZ
	TLO B,MFBFR	;MARK THIS FRAME AS A BUFFER FRAME
	MOVEM B,MFBEG(A)
	TLZ B,MFBFR
	IDIVI B,5	;FIND WHICH WORD WE START IN
	HRLZ TT,B	;MAKE A BLT POINTER TO ZERO STARTING FROM THERE.
	HRRI TT,1(B)
	REST B		;HOW MUCH SPACE DO WE WANT?
	ADDM B,MFZV(A)	;INCLUDE IT IN THE BUFFER BY SETTING Z AND ZV.
	ADDB B,MFZ(A)
	IDIVI B,5	;WHICH WORD DO WE END IN?
	SETZM -1(TT)	;ZERO ALL THE SPACE, INCLUDING THAT WORD.
	CAIE B,-1(TT)
	 BLT TT,(B)
	IMULI B,5	;FIND THE NEXT WORD BOUNDARY, FOR NEW TOP OF BUFFER SPACE.
	ADDI B,5
	MOVEM B,BFRTOP	;EACH BUFFER GETS A WORD OF SPACE SO THEY'RE SEPARATED.
	MOVEI AA,QRBFR	;NOW CREATE THE POINTER STRING IN SPACE ALREADY RESERVED.
	MOVE B,A	;IT SHOULD CONTAIN THE ADDR OF THE BUFFER FRAME.
	CALL QHDRW1
	MOVEI OUT,4
	ADD OUT,QRWRT
	RET

;FS BKILL$ -- TAKES ARG = STRING POINTER TO PTR STRING OF BUFFER,
;AND KILLS THAT BUFFER. THAT IS, THE BUFFER FRAME AND TEXT ARE FREED,
;AND THE PTR STRING IS CHANGED TO BE A DEAD BUFFER. IF NO ARG,
;[ ;DO " Q..O(]..O[A)UA QA-Q..O"NFSBKILL$' ]A ".
FSKILB:	TRZE FF,ARG	;IF THERE'S AN ARG, USE IT.
	 JRST FSKIL1
	SAVE $QBUFR	;OTHERWISE, POP QREG PDL INTO Q..O,
	MOVEI CH,$QBUFR
	CALL CLOSB2
	REST B		;AND IF POPPED VALUE DIFFERS FROM PREV. CONTENTS,
	CAMN B,$QBUFR	;KILL THE PREVIOUS CONTENTS.
	 RET
FSKIL1:	SKIPN KILMOD
	 RET		;ALLOW THIS TO BE DISABLED FOR DEBUGGING.
	CALL QBGET	;GET ADDR OF FRAME IN AA.
	CAMN AA,BFRPTR
	 TYPRE [KCB]	;KILL A BUFFER WHILE IT'S SELECTED?
	SKIPN A,AA
	 RET		;KILLING A DEAD BUFFER.
	SETZ Q,
	IDPB Q,CH	;STORE 0'S IN BUFFER-FRAME-ADDR IN PTR STRING.
	IDPB Q,CH
	IDPB Q,CH
	JRST KILBFR	;FREE FRAME AND TEXT.

;F[B BIND$ -- PUSH THE CURRENT BUFFER.  F]B BIND$ -- POP IT.
FSBBIN:	TRZN FF,ARG
	 JRST FSBBI3	;NO ARG => MUST BE PUSHING.
	SAVE BFRSTR	;ARG => POPPING.  REMEMBER THE INNER BINDING BEING FLUSHED.
	MOVEM B,$QBUFR
	CALL BFRSET	;SELECT THE OLD BINDING (IN B)
	REST B		;KILL THE INNER BINDING AFTER THAT SUCCEEDS.
	JRST FSKIL1

FSBBI3:	CALL FSBCONS	;PUSHING THE SEARCH TABLE:  MAKE A NEW ONE,
	 JFCL
	SAVE BFRSTR	;SAVE THE OLD ONE TO RETURN, AND SELECT NEW ONE.
	MOVE B,A
	CALL BFRSET
	MOVEM A,$QBUFR
POPAJ1:	REST A		;THEN RETURN THE OLD ONE (TO GO ON QREG PDL).
	JRST POPJ1

;GET ARGUMENTS TO SEARCH
GSARG:	TRZ FF,REVSF	;CLEAR SOME FLAGS
	ARGDFL Z,	;GET ARGUMENT OR OPERATOR CONVERTED TO VALUE
	MOVMM B,SEARG	;STORE # OCCURRENCES TO LOOK FOR.
	JUMPL B,GSARGN	;J IF SEARCHING BACKWARDS.
	MOVE C,PT	;ELSE RANGE TO SEARCH IS PT TO ZV.
	MOVE B,ZV
GSARG2:	MOVEI AA,SLP1I	;GET-CHAR RTN FOR MOVING FWD.
GSARG1:	HRRM A,LOSED	;STORE LOSE AND WIN DISPATCHES
	HLRM A,WIND	;(A SET UP BEFORE CALL GSARG)
	HRRM AA,SLP1P	;STORE GET CHAR RTN ADDR.
GSAPCH:	MOVE F,C	;CHAR ADDR BOTTOM OF RANGE.
	CAML C,GPT	;IF CHAR ADDRESSED IS ABOVY RANGE, PT TO IT.
	 ADD F,EXTRAC
	CALL GETBP
	MOVEM F,BBP	;SAVE BP'S TO BOTTOM OF RANGE.
	MOVEM F,BBP1
	MOVE F,B	;MAKE PTR TO TOP OF RANGE:
	CAMG B,GPT	;IF IT IS BEYOND GAP,
	CAML C,GPT	;OR BOTTOM IS AT GAP,
	 ADD F,EXTRAC	;RELOCATE TO PT ABOVE GAP,
	CALL GETBP
	MOVEM F,ZBP
	MOVEM F,ZBP1
	CAMGE C,GPT	;IS THE GAP WITHIN RANGE OF SEARCH?
	CAMG B,GPT
	 POPJ P,
	TRNN FF,REVSF
	 JRST GSARG4
	MOVE F,GPT	;IN BACKWARD SEARCH, MUST STOP AT GAP
	ADD F,EXTRAC	;TO MOVE OVER IT.
	CALL GETBP
	MOVEM F,BBP1
GSARG4:	MOVE F,GPT	;FOR MOVING FWD OVER GAP,
	CALL GETBP
	MOVEM F,ZBP1	;NEED BP TO START OF GAP.
	POPJ P,

GSARGN:	MOVE C,BEGV	;BACKWARDS, RANGE IS BEGV TO PT.
	MOVE B,PT
GSARG6:	TRO FF,REVSF
	MOVEI AA,SLP1D	;RTN TO GET CHARS BACKWARDS.
	MOVE A,[WINNUL,,LOSE2]	;NEVER READ FROM FILE IF BACKWARDS.
	JRST GSARG1

GSARGB:	TRZ FF,REVSF	;BOUNDED SEARCH.
	MOVEI D,1	;GO ONLY ONCE.
	MOVEM D,SEARG
	TRNE FF,ARG2
	CAMG C,B	;IF FB HAS 2 ARGS, IN REVERSE ORDER,
	 JRST GSARG5
	EXCH B,C	;THEN DO BACKWARDS BOUNDED SEARCH.
	CALL GETARG
	 CALL CHK1
	JRST GSARG6

GSARG5:	CALL GETARG	;GET RANGE IN B,C.
	 CALL CHK1
	JRST GSARG2

		;SEARCH COMMANDS

SERCHA:	SETZM PNCHFG	;_ COMMAND, SEARCH AND YANK.
	CAIA
SERCHP:	SETOM PNCHFG	;N COMMAND - SEARCH AND P.
	SKIPA A,[SLP1J,,LOSE1]
SERCH:	MOVE A,[SLP1J,,LOSE2]	;S (SEARCH)
	CALL GSARG	;HANDLE ARG, SET UP DISPATCHES.
	JRST SERCH1

;FB -- BOUNDED SEARCH. ARGS LIKE K,T. (:FB IS LIKE :S, NOT :K).
FBCMD:	MOVE A,[SLP1J,,LOSE2]	;DON'T READ FILE FOR FB.
	SAVE FF		;SAVE COLONF.
	ANDCMI FF,COLONF
	CALL GSARGB	;GET RANGE OF BUFFER, SET UP DISPATCHES.
	REST A
	ANDI A,COLONF	;RESTORE : FLAG SO IT WILL SAY WHETHER TO RETURN A VALUE.
	IORI FF,(A)
SERCH1:	MOVEI CH,ALTMOD	;NOW TO CHOOSE A TEXT TERMINATOR, DEFAULT IS ALTMODE
	TRNE FF,SLSL	;UPARROW TYPED?
	CALL RCH	;YES, GET NEXT CHARACTER INSTEAD
	HRRM CH,INSDLM	;STORE AS DELIMITER
	MOVE C,SBFRP	;ADDRESS OF SEARCH BUFFER HEADER BLOCK.
	MOVE TT,MFZ(C)
	MOVE C,MFBEGV(C) ;CHAR ADDRS OF BEGINNING AND END OF SEARCH BUFFER.
	IDIVI C,5
	AOS C
	MOVEM C,STBLP	;WORD ADDRESS OF SEARCH BUFFER BODY, + 1 (START OF DATA)
	HRLM C,STBLPX
	IDIVI TT,5
	SUBM C,TT	;-<LENGTH OF SEARCH BUFFER, IN WORDS>
	HRLI C,-1(TT)	;AOBJN -> SEARCH BUFFER
	SETO E,		;SAY THERE ISN'T A CHAR TO BE REREAD.
	TRZE FF,SLSL
	 JRST SERCH2
	CALL RCH	;IF NOT AN ^-TYPE ARG, CHECK FOR NULL ARG
	SKIPE SQUOTP
	 JRST SERCH3	;DON'T BE CONFUSED BY SUPERQUOTED ALTMODES.
	CAIN CH,ALTMOD	;WHICH MEANS REPEAT PREVIOUS SEARCH.
	 JRST SRLC
SERCH3:	MOVE E,CH	;ELSE CAUSE THE CHAR TO BE REREAD.
	TLZ E,4^5	;DON'T LET IT BE NEGATIVE.
	JRST SERCH2

;REPEAT THE PREVIOUS SEARCH. THE SEARCH BUFFER CONTAINS POINTERS INTO ITSELF.
;ALL THOSE POINTERS MUST BE RELOCATED IF THE SEAECH BUFFER HAS MOVED SINCE THE LAST
;TIME IT WAS USED. C -> BUFFER BODY BOTTOM. CLOBBERS C,E,TT.
SRLC:	SKIPN -1(C)	;DOES BUFFER SAY IT IS VALID?
	 TYPRE [SNR]
	HRRZ TT,(C)	;RH OF 1ST WORD OF TABLE SHOULD POINT TO 2ND.
	SUBI TT,1(C)	;SUBTRACT REAL ADDR OF 2ND, GIVES AMOUNT BUFFER HAS MOVED.
	MOVNS TT
	HRLZ TT1,TT	;WE MAY WANT TO RELOCATE LH'S AS WELL AS RH'S.
	JUMPE TT,SRN3	;DON'T BOTHER RELOCATING IF RLOC. AMOUNT IS 0.
SRLC1:	ADDM TT1,(C)	;LH OF EACH SUBSTRING HEADER IS A POINTER.
	HRRZ E,(C)
	CAIN E,SLP1P	;REACHED END OF TABLE?
	 JRST SRN3
	ADDM TT,(C)	;NO; RH IS ALSO A POINTER.
	HLRZ C,(C)	;FIND NEXT SUBSTRING.
	JRST SRLC1

;NOW COMPILE SEARCH TABLE 
SERCH2:	SETZM -1(C)	;WHILE WE SET UP STBL IT IS INVALID.
SCPL:	HRRZ B,C	;SAVE LOCATION OF BEGINNING OF BLOCK (LOOP POINT FOR CONTROL O)
	MOVEI CH,1(C)	;GET RIGHT HALF OF UPCOMING HEADER
	PUSHJ P,SDEP	;DEPOSIT IN TABLE
SCPL1:	TDZA A,A	;CLEAR INDEX AND FALL INTO LOOP
SCNOT:	TRC A,1		;CONTROL N, COMPLEMENT 1 BIT INDEX
	SKIPGE CH,E	;IF THERE'S A CHAR TO REREAD, USE IT.
	 CALL RCH	;ELSE GET NEXT CHARACTER.
	SETO E,		;FLUSH THE SAVED CHAR IF ANY.
	SKIPGE SQUOTP
	 JRST SCNSP	;SUPERQUOTED CHAR.
	SKIPE SQUOTP
	 JRST SCNDL	;DELIM-PROTECTED CHAR.
	CAMN CH,INSDLM	;IF TEXT TERMINATOR (RH MODIFIED),
	 JRST SCPX	;THEN DONE COMPILING, GO DO IT
SCNDL:	CAILE CH,^X
	 JRST SCNSP
	CAIN CH,^X	;IF CONTROL X (FOR "ANY CHARACTER"),
	 ADDI A,XSER	;THEN SET INDEX
	CAIN CH,^B	;IF CONTROL B (FOR BREAK CHARACTER)
	 ADDI A,BSER	;THEN SET INDEX
	CAIN CH,^N	;IF CONTROL N (FOR "NOT")
	 JRST SCNOT	;THEN CLOBBER INDEX AND GET NEXT CHARACTER
	CAIN CH,^O	;IF CONTROL O ("OR"),
	 JRST SCPOR	;THEN GENERATE NEW HEADER
	CAIN CH,^Q	;IF CONTROL Q (QUOTES THE NEXT CHARACTER),
	 CALL RCH	;THEN REALLY USE NEXT CHARACTER, SKIPPING ABOVE TESTS
SCNSP:	SKIPE BOTHCA	;BOTHCASE=0 => CASES ARE DISTINCT.
	 TRNN CH,100	;BOTHCASE=1 => CASE IGNORED FOR LETTERS ONLY.
	  JRST SCNSP1	;BOTHCASE=-1 => CASE IGNORED FOR ALL CHARS > 100 .
	ANDI CH,-1	;SUPERQUOTED CHARS STIL GET CONVERTED.
	CAIL CH,"A+40	;IF IGNORING CASE FOR A CHARACTER, CONVERT IT TO
	 CAILE CH,"Z+40	;UPPER CASE HERE, ND ALSO WHIE SEARCHING THE BUFFER.
	  SKIPG BOTHCA
	   ANDCMI CH,40
SCNSP1:	TRNE A,-2	;IF INDEX CLOBBERED,
	SKIPA CH,(A)	;THEN GET TABLE ENTRY
	HLL CH,CHSER(A)	;INDEX NOT CLOBBERED OUT OF EXISTENCE, TURN INTO CAIE OR CAIN
	PUSHJ P,SDEP	;DEPOSIT TABLE ENTRY
	JRST SCPL1	;LOOP

SDEP:	MOVEM CH,(C)	;ADD AN ENTRY TO THE SEARCH TABLE
	AOBJN C,CPOPJ	;RETURN IF TABLE NOT FULL
	TYPRE [STL]

SCPX:	TDZA AA,AA	;TEXT TERMINATOR ENCOUNTERED
SCPOR:	MOVEI AA,SCPL	;CONTROL O
	MOVE CH,[JRST WIN]	;SET FINAL TABLE ENTRY (EXECUTED => THIS STRING FOUND)
	CAIN B,-1(C)
	 HRRI CH,WINNL1	;BUT FOR NULL STRINGS, USE WINNL1 INSTEAD WIN.
	PUSHJ P,SDEP	;DEPOSIT
	HRLM C,(B)	;STORE POINTER TO THIS HEADER IN LH(LAST HEADER)
	JUMPN AA,(AA)	;JUMP IF NOT TEXT TERMINATOR
	MOVS A,STBLPX	;GET LIST CIRCULIZER/POINTER TO ROUTINE TO READ NEXT CHAR.
	MOVSM A,(C)	;STORE IN TABLE (THIS LAST ENTRY, DON'T INCREMENT C OR CHECK FOR OVERFLOW)
	SETOM -1(A)	;SEARCH TABLE NOW COMPILED.
	MOVEI C,1(C)
	IMULI C,5
	MOVE A,SBFRP
	MOVEM C,MFZV(A)	;ZV OF SEARCH BUFER POINTS TO END OF REGION BEING USED.
	JRST SRN3

		;TABLES FOR COMPILING SEARCH TABLE

XSER:	JFCL		;CONTROL X
	CAIA		;NOT CONTROL X

BSER:	PUSHJ P,SKNBRK	;CONTROL B
	PUSHJ P,SKBRK	;NOT CONTROL B

CHSER:	CAIN A,		;NORMAL CHARACTERS (HLL'ED WITH CHAR. IN RIGHT HALF)
	CAIE A,		;NOT CHAR.

;SEARCH TABLE FORMAT

;FOLLOWING IS COMPILATION OF "SFOO SP)"
 ;EVERY WORD ASSEMBLED WITH ",," IS A SUBSTRING HEADER.

;STBLP POINTS HERE:
;TEM:	.+5,,.+1	;HEADER, LH POINTS TO NEXT COMPARISON STRING
		;RH POINTS TO TABLE THIS COMPARISON STRING
;	CAIN A,"F	;IF THE TEST IS TO SUCCEED THEN THE INSTRUCTION SHOULD NOT SKIP
;	CAIE A,"O	;THE CHARACTERS ARE IN A
;	CAIN A,"O
;	JRST WIN	;DOES JRST WIN IF ENTIRE STRING HAS BEEN FOUND
;	.+10,,.+1	;THIS LAST COMPARISON STRING BUT LH STILL POINTS SOMEWHERE
;	CAIN A,40
;	CAIE A,"S
;	CAIN A,"P
;	PUSHJ P,SKBRK	;SKBRK => , SKNBRK => 
;	JFCL
;	CAIN A,")
;	JRST WIN
;	.+2,,.+1
;	JRST WINNL1
;	TEM,,SLP1P	;FINAL HEADER, LH POINTS TO FIRST HEADER MAKING LIST CIRCULAR
		;RH POINTS TO A JRA AA,<ROUTINE TO GET NEXT CHARACTER>

;FALLS THROUGH.
;ASSUMING THE SEARCH TABLE IS SET UP, DO THE SEARCHING.
SRN3:	TRZ FF,ARG+ARG2
	SETOM SFINDF	;A NULL SEARCH OR SEARCHING 0 TIMES SHOULD STATE THAT IT WON.
	SKIPN SEARG	;IF ARGUMENT ZERO, (ENTRY FOR "AGAIN" COMMAND)
	 POPJ P,	;THEN WIN, DON'T BOTHER ACTUALLY SEARCHING
SRN2:	CALL SKNBCP	;SET UP SKNBPT FROM Q..D, FOR SKNBRK'S SAKE.
	SETZM TEM2	;NO WINNING SEARCHES FOR SRCV TO DOCUMENT
	MOVE B,BBP	;GET PLACE TO START; NORMALLY LOW END
	TRNE FF,REVSF
	 MOVE B,ZBP	;BUT HIGH END IF REVERSE.
	MOVE C,B	;INIT. BP TO END OF STRING IN CASE FIND NULL STRING.
	MOVS 17,[SLP2,,SLP2LC]	;GET POINTER FOR BLTING IN MAIN LOOP
	BLT 17,17	;BLT IN MAIN LOOP
	SKIPGE BOTHCA	;IN BOTH-CASES MODE,
	 MOVE SLP2,[JRST SLPLO1]
	SKIPGE BOTHCA	;IGNORE THE CASE OF THE CHARS SEARCHING.
	 MOVE SLP3,[JRST SLPLOW]
	SKIPLE BOTHCA	;BOTHCA POSITIVE => IGNORE CASE OF LETTERS ONLY.
	 MOVE SLP2,[JRST SLPLO3]
	SKIPLE BOTHCA
	 MOVE SLP3,[JRST SLPLO2]
	CALL IMMQIT	;IT'S OK TO QUIT OUT OF MIDDLE OF SEARCH.
	MOVE AA,ZBP
	TRNN FF,REVSF	;IF GAP IS IN THE RANGE
	CAMN AA,ZBP1	;AND WE'RE STARTING BEFORE IT,
	 JRST SRN1
	MOVE SLP4,[JRST SLP1Z]	;TEMP. PTR ADVANCE
	HRRI SLP4-1,ZBP1	;WILL ENCOUNTER GAP BEFORE END.
	MOVEM SLP4,SLP4N
	MOVEM SLP4-1,SLP4N1
SRN1:	MOVE AA,@STBLP	;INITIALIZE LIST POINTER
	HLRZ A,AA
	HRRZ A,(A)	;IF THERE IS ONLY ONE ALTERNATIVE IN THE SEARCH STRING
	CAIE A,SLP1P
	 XCT WIND
	HLRZ A,(AA)
	TRNN FF,REVSF	;AND WE ARE GOING FORWARD, AND THE 1ST CHAR OF SEARCH STRING
	 CAIE A,(CAIN A,)	;IS NOT A SPECIAL SEARCH CHARACTER,
	  XCT WIND
	MOVEI A,SFAST	;THEN WE CAN GO FAST
	HRRM A,SLP1P	;USE THE GET-NEXT-CHAR ROUTINE THAT CAN SKIP FAST
	HRRZ A,(AA)	;OVER UNINTERESTING REGIONS.
	MOVEI E,SFAFN0	;WHICH MAIN LOOP SHOULD WE USE?
	SKIPE BOTHCA	;SFAFC0 IGNORES THE 40 BIT; SFAFN0 DOESN'T.
	 CAIGE A,100	;IS THE 1ST CHAR ONE WHOSE CASE WE WANT TO IGNORE?
	  JRST SRN4	;NO.
	CAIL A,"A
	 CAILE A,"Z
	  SKIPG BOTHCA
	   MOVEI E,SFAFC0 ;YES.
SRN4:	MOVEM E,SFASAD	;TELL SFAST WHERE TO GO.
REPEAT 4,[ROT A,7	;GENERATE AN ASCII CONSTANT WITH 1ST CHAR OF SEARCH
	TRO A,@(AA)	;REPEATED 5 TIMES.
]
	LSH A,1
	MOVEM A,SFXOR
	XCT WIND		;SLP1J\WINNUL GO INTO LOOP

		;MAIN SEARCH LOOP

SLP2LC:	OFFSET 20-9-.
SLP2==.
	LDB A,B		;GET CHARACTER
	XCT (AA)	;COMPARE WITH FIRST CHARACTER THIS COMPARISON STRING
		;SKIP => THIS CHARACTER LOSES, TRY NEXT COMPARISON STRING
		;NO SKIP => THIS CHARACTER WINS, TRY NEXT ONE
		;WIN ON STRING => JRST WIN
		;THIS CHARACTER TOTALLY LOSES ON ALL COMPARISON STRINGS => EXECUTE SLP1P
			;^ => AA := FIRST HEADER IN SEARCH TABLE
	SKIPA C,B	;WIN THIS CHARACTER, GET POINTER FOR CHECKING FUTURE CHARACTERS
	JRA AA,.-2	;LOSE THIS COMPARISON STRING, TRY NEXT
SLP3==.
	ILDB A,C	;GET NEXT CHARACTER
	XCT 1(AA)	;EXECUTE NEXT TABLE ENTRY
	CAMN C,ZBP	;IT CLAIMS TO HAVE WON; WAS IT AT END OF BUFFER?
SLP4::	JRA AA,SLP2	;LOSE, TRY NEXT COMPARISON STRING
	AOJA AA,SLP3	;WIN THIS CHARACTER, TRY NEXT

IFN .-20,.ERR SLP2 WRONG TABLE LENGTH

	OFFSET 0

;ROUTINE TO GET NEXT CHARACTER GOING FORWARD UNDER SPECIAL CIRCUMSTANCES.
;MAY SKIP FAST OVER MANY CHARACTERS BEFORE FINALLY STOPPING WITH A CHARACTER IT CAN'T
;QUICKLY RULE OUT.
SFAST:	TLNE B,760000
	 JRST SLP1I	;GO SLOW IF NOT STARTING NEW WORD.
	HRRZ A,ZBP1
	CAIN A,(B)	;OR IF NEAR GAP OR END OF RANGE
	 JRST SLP1I
	SUBM B,A
	HRL B,A		;AOBJN -> RANGE OF WORDS WE CAN SCAN FAST.
	JRST @SFASAD	;TO SFAFN0 OR SFAFC0.

;THIS IS THE SFAST MAIN LOOP THAT DOESN'T IGNORE THE 40 BIT OF THE CHARACTER.
SFAFNL:	MOVE A,(B)
	XOR A,SFXOR	;XOR NEXT WORD WITH ASCII/QQQQQ/ WHERE Q IS CHAR WE'RE LOOKING FOR.
	TLNN A,(177_35)	;IS 1ST CHAR OF WORD THE ONE WE WANT?
	 JRST SFAF1
	TLNN A,(177_26)	;OR THE 2ND?
	 JRST SFAF2
	TDNN A,[177_17]
	 JRST SFAF3
	TRNN A,177_10
	 JRST SFAF4
	TRNN A,177_1
	 JRST SFAF5
SFAFN0:	AOBJN B,SFAFNL	;NO NEED TO STOP IN THIS WORD; LOOK AT NEXT.
	HRLI B,350700	;APPROACHING GAP OR END OF RANGE; SLOW DOWN.
	JRST SLP1K	;ONLY THE SLOW ROUTINE KNOWS HOW TO HANDLE THEM.

;MAIN LOOP THAT IGNORES THE 40 BIT.
SFAFCL:	MOVE A,(B)
	XOR A,SFXOR
	TLNN A,(137_35)	;ONLY DIFFERENCE IS THAT EACH MASK OMITS THE 40 BIT.
	 JRST SFAF1
	TLNN A,(137_26)
	 JRST SFAF2
	TDNN A,[137_17]
	 JRST SFAF3
	TRNN A,137_10
	 JRST SFAF4
	TRNN A,137_1
	 JRST SFAF5
SFAFC0:	AOBJN B,SFAFCL	;NO NEED TO STOP IN THIS WORD; LOOK AT NEXT.
	HRLI B,350700	;APPROACHING GAP OR END OF RANGE; SLOW DOWN.
	JRST SLP1K	;ONLY THE SLOW ROUTINE KNOWS HOW TO HANDLE THEM.

SFAF1:	HRLI B,350700	;MUST EXAMINE 1ST CHAR THIS WORD - SO DROP INTO
	JRST SLP2+2	;MAIN SEARCH LOOP.

SFAF2:	HRLI B,260700
	JRST SLP2+2

SFAF3:	HRLI B,170700
	JRST SLP2+2

SFAF4:	HRLI B,100700
	JRST SLP2+2

SFAF5:	HRLI B,010700
	JRST SLP2+2

		;SEARCHING BACKWARDS, GET NEXT CHARACTER

SLP1E:	MOVEM B,ZBP	;INITIALIZATION, SET CEILING FOR SEARCH
SLP1D:	CAMN B,BBP1	;AT BEGINNING OF BUFFER OR END OF GAP?
	JRST SLP1F	;YES, FIGURE OUT WHICH.
	ADD B,[70000,,]	;NO, DECREMENT B,
	JUMPGE B,SLP2	;AND GO BACK INTO LOOP
	SUB B,[430000,,1]
	JRST SLP2

SLP1F:	CAMN B,BBP
	 JRST LOSE	;REALLY AT START OF RANGE, SEARCH FAILED.
	JRST SLP1G	;MOVED BACK TO GAP, GO OVER IT.

		;SEARCHING FORWARDS

SLP1J:	CAMN C,ZBP	;IF AT END OF BUFFER,
	JRST WINNUL	;THEN WIN ONLY FOR NULL COMPARISON STRING
	SKIPA B,C	;INITIALIZATION, START SEARCHING AT END OF LAST FOUND STRING
SLP1I:	IBP B		;INCREMENT TO NEXT CHARACTER
SLP1K:	CAME B,ZBP1	;AT START OF GAP OR END OF RANGE?
	JRST SLP2	;NO, KEEP GOING
	CAMN B,ZBP	;WHICH ONE IS IT?
	 JRST LOSE	;IT'S END OF RANGE.
SLP1G:	INSIRP PUSH P,F TT TT1
	MOVE F,GPT	;COMPUTE A B.P. TO OTHER SIDE OF GAP.
	TRNE FF,REVSF
	 AOSA F		;BACKWARD => 1ST CHAR OF GAP,
	ADD F,EXTRAC	;FWD => LAST CHAR OF GAP.
	CALL GETIBP
	MOVE B,F
	MOVE F,BBP	;ALREADY PASSED GAP SOLOOK FOR BNDRYS
	MOVEM F,BBP1	;OF RANGE INSTEAD.
	MOVE F,ZBP
	TRNN FF,REVSF
	 MOVEM F,ZBP1
	XORI SLP4-1,ZBP#ZBP1
	MOVEM SLP4-1,SLP4N1
	XOR SLP4,[<JRA AA,SLP2>#<JRST SLP1Z>]
	MOVEM SLP4,SLP4N
INSIRP POP P,TT1 TT F
	HRRZ A,SLP1P	;NOW WE'RE ACROSS GAP SO RETRY FETCHING NEXT CHAR.
	JRST (A)

SLP1Z:	XCT SLP4-1
	 CAIA
	JRA AA,SLP2
	MOVE SLP4-1,[CAMN C,ZBP]
	MOVE SLP4,[JRA AA,SLP1Z1]
	INSIRP PUSH P,F TT TT1
	MOVE F,GPT
	ADD F,EXTRAC
	CALL GETIBP
	MOVE C,F
INSIRP POP P,TT1 TT F
	JRST SLP3

SLP1Z1:	MOVE SLP4-1,SLP4N1
	MOVE SLP4,SLP4N
	JRST SLP2

SLPLOW:	ILDB A,C	;COME HERE FROM SLP3 IN BOTHCASES MODE.
	CAIL A,140
	 SUBI A,40
	JRST SLP3+1

SLPLO1:	LDB A,B		;SIMILAR, FOR SLP2.
	CAIL A,140
	 SUBI A,40
	JRST SLP2+1

SLPLO2:	ILDB A,C	;COME HERE FROM SLP3 WHEN IGNORING CASE FOR LETTERS ONLY.
	CAIL A,"A+40
	 CAILE A,"Z+40
	  JRST SLP3+1
	 SUBI A,40
	JRST SLP3+1

SLPLO3:	LDB A,B		;SIMILAR, FOR SLP2.
	CAIL A,"A+40
	 CAILE A,"Z+40
	  JRST SLP2+1
	 SUBI A,40
	JRST SLP2+1

LOSE:	SETZM SFINDF	;SEARCH LOST, CLEAR FLAG FOR SEMICOLON
	XCT LOSED	;LOSE2\LOSE1 +S OR -<ANYTHING> => JRST LOSE2
		;+N OR +_ => JRST LOSE1

		;SEARCH LOST

LOSE2:	PUSHJ P,SRCV	;SET PT
	TRZE FF,COLONF	;IF COLON TYPED FOR SEARCH,
	 JRST NRET0	;THEN RETURN 0 AS VALUE
	MOVE TT,ITRPTR	;ARE WE WITHIN AN ITERATION?
	TSC TT,ITRPTR	;(BUT ERRSETS DON'T COUNT).
	TRNN TT,-1
	 SKIPE PSSAVP	;OR ARE WE WITHIN A ^P-SORT?
	  SKIPE SRCERR	;YES. IF SRCERR IS 0, INHIBIT THE ERROR.
	   TYPRE [SFL]
	RET

		;MULTIPLE PAGE SEARCH LOST THIS BUFFER, MAYBE READ NEW BUFFER

LOSE1:	SKIPL LASTPA
	 JRST LOSE2	;YES, SEARCH LOSES FOR REAL
	MOVEI B,1	;MAYBE PUNCH ONCE
	SETZM IMQUIT	;DON'T QUIT OUT OF I-O - MIGHT GARBLE FILE.
	TRZ FF,ARG
	SKIPE PNCHFG	;PUNCH?
	 PUSHJ P,PUNCHA	;YES
	SKIPN PNCHFG	;YANK?
	 PUSHJ P,YANK	;YES
	MOVE C,BEGV	;GET RANGE TO SEARCH = WHOLE BUFFER,
	MOVE B,ZV
	CALL GSAPCH	;SET BBP, ZBP.
	JRST SRN2	;SEARCH NEW BUFFER

WINNL1:	MOVE C,B	;NULL SEARCH STRING FOUND.
;THIS SEARCH WINS, MAYBE DO SOME MORE
WIN:	MOVEM B,TEM1	;SAVE B, (BYTE POINTER TO FIRST CHARACTER IN FOUND STRING)
	MOVEM C,TEM2	;AND C, ( " TO LAST CHARACTER IN FOUND STRING)
	SOSLE SEARG	;THIS LAST SEARCH?
	 JRST SRN1	;NO, KEEP GOING
WIN1:	PUSHJ P,SRCV	;PICK UP THE PIECES (ENTRY FOR FOUND NULL STRING AT END OF BUFFER)
	TRZ AA,-1	;YES, CHASE DOWN LIST LOOKING FOR THIS LIST POINTER
	MOVE B,@STBLP	;GET INITIAL POINTER
	MOVNI A,1	;INITIALIZE COUNT
WIN2:	TRZ B,-1	;CLEAR OUT RIGHT HALF OF THIS LIST ENTRY
	CAME B,AA	;IS THIS THE ONE?
	 JRA B,[SOJA A,WIN2]	;NO, TRY NEXT
	MOVEM A,SFINDF	;STORE FS SVALUE$
	TRZE FF,COLONF	;RETURN SFINDF AS VALUE IFF IT'S A ":S".
	 AOS (P)
	RET

;SEARCHING STARTING AT END OF BUFFER, DON'T WIN FOR FORWARD NON-NULL SEARCH

WINNUL:	MOVE A,[JRST WINNL1]	;SET UP A AS CONSTANT FOR COMPARISON AGAINST MEMORY
WINNL2:	CAMN A,(AA)	;IF AGREEMENT,
	JRST WINNL1	;THEN NULL COMPARISON STRING, WIN, KIND OF
	CAME AA,STBLPX	;IF THIS ISN'T LAST ENTRY IN TABLE,
	JRA AA,WINNL2	;THEN TRY NEXT ONE
	TRNN FF,REVSF	;NO NON-NULL COMPARISON STRINGS, IF SEARCHING FORWARD,
	JRST LOSE	;THEN LOSE
	JRA AA,SLP1E	;SEARCHING BACKWARDS => RE-INITIALIZE LIST POINTER, FALL IN

;PICK UP PIECES FROM SEARCH; COMPUTE NEW VALUE OF PT.

SRCV:	SETZM IMQUIT
	SKIPN F,TEM2	;GET POINTER TO LAST CHARACTER IN FOUND STRING
	JRST SRCVX	;NO WINNERS THIS BUFFER
	MOVE B,TEM1	;GET POINTER TO FIRST CHARACTER IN FOUND STRING
	TRNE FF,REVSF	;IF SEARCH WAS BACKWARDS,
	EXCH B,F	;THEN REALLY WANT THEM INTERCHANGED
		;F NOW HAS TECO'S . IN BYTE POINTER FORM
		;B HAS BYTE POINTER TO OTHER END OF STRING FOUND
	PUSHJ P,GETCA	;CONVERT F TO CHARACTER ADDRESS
	EXCH F,B	;GET OTHER BYTE POINTER IN F
	PUSHJ P,GETCA	;CONVERT TO CHARACTER ADDRESS
	CAMLE B,GPT	;CONVERT CHAR ADDR OF END TO VIRTUAL,
	 SUB B,EXTRAC
	CAMLE F,GPT	;CONVERT CHAR ADDR OF END TO VIRTUAL.
	 SUB F,EXTRAC
	SUB F,B		;DIFFERENCE = LENGTH OF LAST SEARCH STRING FOUND.
	MOVEM B,PT	;GO THERE.
SRCVX:	MOVNM F,INSLEN	;STORE SIGNED LENGTH OF LAST SEARCH STRING FOUND
		;SIGN OF LLSSF IS OPPOSITE THAT OF ARG TO SEARCH FROM WHICH IT WAS SET
	POPJ P,

FKCMD:	MOVN A,INSLEN	;"FK" -<LENGTH OF LAST STRING FOUND OR INSERTED>
	JRST POPJ1

;FS S STRING$ - READ OR SET THE DEFAULT SEARCH STRING.
FSSSTR:	CALL FSSSTV	;FIRST, CONS UP A STRING CONTAINING THE OLD VALUE.
	TRZE FF,ARG	;THEN, IF WE HAVE AN ARG, SET THE DEFAULT FROM IT:
	 CAMN B,[-1]	;ARG OF -1 MEANS "INVALID SEARCH STRING";  JUST DON'T SET.
	  JRST POPJ1
	MOVEI C,[ASCIZ /[0 U0 0S0 ]0/]
	JRST MACXCC	;SET IT BY PASSING ARG TO AN S COMMAND.

;RETURN IN A A STRING CONTAINING THE CURRENT DEFAULT SEARCH STRING.  PRESERVE B.
FSSSTV:	MOVE C,SBFRP
	MOVE CH,MFZV(C)
	MOVE C,MFBEGV(C)
	IDIVI C,5	;GET WORD ADDR'S OF START AND END OF SEARCH TABLE.
	IDIVI CH,5
	AOS C		;SKIP OVER THE VALID-WORD AT THE START.
	SETO A,
	SKIPN -1(C)	;BUT IF THE TABLE'S CONTENTS AREN'T VALID, RETURN -1.
	 POPJ P,
	SAVE B		;ELSE WE'LL RETURN A STRING.  WHAT'S A BOUND ON LENGTH WE NEED?
	MOVE B,CH
	SUB B,C		;TWICE LENGTH OF SEARCH TABLE IS ENOUGH.
	LSH B,1
	CALL QOPEN	;ALLOCATE THAT SPACE, SET UP LISTF5 TO STORE INTO STRING.
	AOS C		;SKIP THE FIRST POINTER-PAIR IN THE SEARCH TABLE.
FSSSTL:	SETZ B,
	HLRZ TT,(C)	;GET LH AND RH OF NEXT SEARCH TABLE WORD.
	HRRZ TT1,(C)
	CAIN TT1,SLP1P	;SLP1P IN RH IDENTIFIES END OF SEARCH TABLE
	 JRST QCLOSV	;SO FINISH UP THE STRING'S HEADER AND RETURN IT.
	CAIL TT1,HUSED	;AN RH THAT'S AN ADDRESS IN BUFFER SPACE
	 JRST [	MOVEI CH,^O	;INDICATES A DIVISION BETWEEN ALTERNATIVE STRINGS,
		JRST FSSST2]	;SO WE NEED A ^O FOR IT.
	CAIN TT,(JRST)	;JRST INSN MUST BE JRST WIN OR WINNUL, WHICH IS AT THE END OF
	 AOJA C,FSSSTL	;EVERY ALTERNATIVE.  IT CORRESPONDS TO NO CHAR IN USER'S ARG.
	CAIN TT,(JFCL)
	 MOVSI B,(ASCII //)	;JFCL IS GENERATED BY A ^X.
	CAIN TT,(CAIA)
	 MOVSI B,(ASCII //)	;CAIA COMES FROM A ^N^X.
	CAIN TT1,SKNBRK
	 MOVSI B,(ASCII //)	;CALL SKNBRK COMES FROM ^B.
	CAIN TT1,SKBRK
	 MOVSI B,(ASCII //)	;CALL SKNBRK COMES FROM ^N^B.
	JUMPE B,FSSST1		;ANYTHING ELSE MUST BE ORDINARY, OR A ^N.
	MOVEI A,B
	CALL ASCIND		;IF ^X, ^B OR ^N OF ONE, STORE IN STRING THE STUFF IN B.
	AOJA C,FSSSTL

FSSST1:	MOVEI CH,^N
	CAIN TT,(CAIE A,)	;DECIDE BETWEEN ORDINARY CHAR AND ^N'D CHARACTER.
	 XCT LISTF5
	MOVEI CH,^Q	;IF CHAR IS ONE THAT WOULD BE SPECIAL, MUST QUOTE IT.
	CAIE TT1,^B
	 CAIN TT1,^X
	  XCT LISTF5
	CAIE TT1,^Q
	 CAIN TT1,^O
	  XCT LISTF5
	CAIN TT1,^N
	 XCT LISTF5
	MOVE CH,TT1	;[
	CAIN CH,^]
	 XCT LISTF5	;[   ;^] HAS ITS OWN WAY TO BE QUOTED.
FSSST2:	XCT LISTF5
	AOJA C,FSSSTL

;SKNBRK SKIPS UNLESS THE CHARACTER IN A IS A DELIMITER CHARACTER.
;THE SET OF DELIMITERS IS DEFINED BY THE CONTENTS OF QREG ..D,
;WHICH SHOULD BE A STRING CONTAINING 5*128. CHARACTERS, FORMING A
;DISPATCH TABLE. EACH ASCII CHAR HAS A 5-CHAR DISPATCH ENTRY WHOSE
;FIRST TWO CHARACTERS ONLY ARE SIGNIFICANT.
;THE FIRST CHARACTER IS THE MOST GENERAL: IF IT IS NOT A SPACE, THEN
;THE CHARACTER WHOSE ENTRY IT IS IS NOT A DELIMITER.
;INITIALLY ALL NON-SQUOZE CHARACTERS ARE DELIMITERS.
;THE SECOND CHARACTER SAYS HOW LISP HANDLES THE CHAR BEING HANDLED.
;THE POSSIBLE DISPATCH CHARS ARE "(", ")", "/", "|", "A" AND " ".
;SKNBRK ASSUMES THAT SKNBPT HAS BEEN SET UP BY SKNBCP ALREADY.
;CLOBBERS E.
SKNBRK:	LDB E,SKNBPT
	CAIN E,"A
	 AOS (P)
	RET

DQT3:	CALL SKNBCP	;SKIP IF CHAR IN B IS DELIMITER; RECOMPUTES SKNBPT.
	MOVE A,B
SKBRK:	LDB E,SKNBPT	;SKIP IF CHAR IN A IS DELIM. SKNBCP SHOULD HAVE BEEN CALLED.
	CAIE E,"A
	 AOS (P)
	RET

;LOOK AT QREG ..D, AND SET UP SKNBPT FOR USE BY SKNBRK.
SKNBCP:	MOVE CH,QRB..
	ADDI CH,.QDLIM
	CALL QLGET	;F _ BP TO TEXT.
	 TYPRE [QNS]
	CAIGE AA,5*200	;NOT LONG ENOUGH => ERROR.
	 TYPRE [STS]
	IBP F		;F HAS BP TO LDB 1ST CHAR.
	TLO F,A		;LDB F TO GET DISPATCH OF CHAR IN A.
	MOVEM F,SKNBPT
	RET

TYPE:	MOVEI D,TYO	;T COMMAND
	TRZE FF,SLSL
	 MOVEI D,FSECO2	;^ T TYPES IN ECHO AREA.
	PUSHJ P,GETARG
	 CALL CHK1
TYPE1:
TYPE1A:	MOVE IN,C
TYPE3:
IFN TS,[
	TRNN IN,37
	JRST TYPE7	;EVERY 32. CHAR CHECK FOR QUIT
TYPE7R:]
	CAML IN,B
	JRST TYPE5
	PUSHJ P,GETINC
	PUSHJ P,(D)
	JRST TYPE3

TYPE5:
	CAIN D,TYO
	PUSHJ P,DISFLS	;FORCE THE TYPEOUT OUT.
	POPJ P,

IFN TS,[
TYPE7:	CAIE D,DISAD	;HERE EVERY 32. CHARS
	CAIN D,TYO	;IF TYPEING OUT THEN CHECK FOR QUIT OR "FLUSHED"
TYPE7A:	SKIPL MORFLF
	 SKIPE STOPF
	  RET
	JRST TYPE7R
]

;F-COMMAND SUBDISPATCH.
FCMD:	PUSHJ P,LRCH
	XCT FDTB(CH)
	 POPJ P,
	JRST POPJ1

;FS COMMAND.
FSET:	MOVE AA,[440600,,E]
	MOVE C,[440600,,D]
	SETO F,
	SETZB E,D
;E GETS THE SPEC'D NAME; D GETS MASK TO THOSE CHARS IN THE WORD WHICH WERE SPEC'D.
FSLUP:	CALL RCH
	ANDI CH,-1
	TRNE CH,100
	 ANDCMI CH,40	;CONVERT TO LOWER CASE.
	CAILE CH,40
	 JRST FSCHAR	;NON-CONTROLS ARE FOR REAL.
	CAIN CH,ALTMOD
	 SKIPGE SQUOTP	;ALTMODE ENDS NAME UNLESS SUPERQUOTED.
	  JRST FSLUP	;OTHERWISE, CONTROL CHARS ARE IGNORED.
	JRST FSLKUP

FSCHAR:	HRREI CH,-40(CH) ;GET SIXBIT, IGNORING LH SINCE MIGHT BE -1
			;[ ;IF THE CHAR WAS QUOTED WITH ^]^Q
	TLNE AA,770000
	 IDPB CH,AA
	TLNE C,770000
	 IDPB F,C
	JRST FSLUP

FSLKUP:	MOVE AA,[-FLAGSL*2,,FLAGS]

;BINARY SEARCH IN VECTOR OF FLAGS <- AOBJN IN AA
;FOR VALUE IN E.  CLOBBERS AA,C,TT.
FSLUKB:	HLRE C,AA
	HRLI AA,C	;AA IS INDEX OF C.
	MOVNS TT,C
;AA -> INSIDE AREA, IDX OF C.
;C = SIZE OF LAST STEP.
;TT = # WDS LEFT IN PART OF AREA AFTER AA.
;LEAVES AA POINTING TO LAST FLAG WHOSE NAME IS < DESIRED NAME
;(NOTE: IF ALL FLAGS ARE >= DESIRED NAME, AA -> 1ST FLAG).
;THEN GOES TO FSLUK1.
FSLUK0:	CAILE C,(TT)	;C_MAX(LAST STEP,SPACE LEFT)
	 MOVEI C,(TT)
	CAIN C,2	;ONLY 1 ENTRY TO SEARCH THRU => DONE.
	 JRST FSLUK1
	LSH C,-1	;STEP = .5* SIZE OF STUFF TO SEARCH.
	TRZE C,1	;ROUND UP TO EVEN NUMBER.
	 ADDI C,2
	CAMG E,@AA	;E.A. IS RH(AA)+STEP.
	 JRST FSLUK0	 ;THAT'S TOO FAR, DON'T MOVE AA.
	HRRI AA,@AA	;NOT TOO FAR, SET PTR THERE.
	SUBI TT,(C)	;WE'RE CLOSER TO END NOW.
	JRST FSLUK0

FSLUK1:	CAMLE E,(AA)	;(THIS PREVENTS LOSSAGE IF SUPPOSED TO FIND 1ST FLAG IN TABLE)
	 ADDI AA,2
	MOVEI AA,-FLAGS(AA)	;POINT TO 1ST FLAG GREATER THAN OR EQUAL TO DESIRED.
	MOVE C,FLAGS(AA)
	AND C,D		;IF THIS FLAG DOESN'T MATCH SPEC'D NAME, NONE DOES.
	CAME E,C
	 TYPRE [IFN]
	CAMN E,FLAGS(AA) ;EXACT MATCH IS NEVER CONSIDERED AMBIGUOUS.
	 JRST FSFND
	MOVE C,FLAGS+2(AA) ;ELSE, DOES THE NEXT FLAG AFTER THE ONE FOUND
	AND C,D		;ALSO MATCH THE SPECIFIED NAME?
	CAMN E,C
	 TYPRE [AFN]	;YES - SPEC'D NAME IS AMBIGUOUS.
FSFND:	MOVS C,FLAGD(AA)
	HRLM AA,(P)
FSCALL:	CALL (C)	;SOME ROUTINES WILL DEPOSIT IN -1(P)! THEY ALL CREF FSCALL.
	 RET		;(THEIR GOAL IS TO FAKE OUT FPUSH VIA THE INSN AT .+1)
	HLRZ C,(P)	;FOR FLAGS THAT RETURN VALUE, MAKE SURE INDEX OF FLAG IS
	JRST POPJ1	;IN C, FOR FPUSH TO WORK.

;[   ;F]<FLAGNAME>$ POPS QREG PDL INTO THAT FLAG.
;[   ;<CH>F]^RCMAC$ WORKS, ETC.
FPOP:	MOVEI CH,C	;CH HAS ADDR TO POP INTO.
	CALL CLOSB2
	TRON FF,ARG
	 SKIPA B,C	;MAKE POPPED VALUE COME BEFORE ANY SPEC'D ARG.
	  TRO FF,ARG2
	CALL FSET	;SET THE FLAG, RETURNING THE OLD VALUE OF THE FLAG.
	 JFCL
	RET		;RETURN NO VALUE.

;F[<FLAGNAME>$ PUSHES THAT FLAG ONTO THE QREG PDL.
;<CH>F[^RCMAC$, ETC., WORK.		;]]
FPUSH:	MOVE AA,PF	;IF WE ARE ABOUT TO OVERFLOW QREG PDL, DETECT THAT
	CAMN AA,PFTOP	;BEFORE SETTING THE FLAG.
	 JRST OPENB1
	CALL FSET	;DO FS<FLAG>$, WHICH LEAVES INDEX IN FLAGD IN C.
	 TYPRE [WNA]	;FLAG HAS NO VALUE, AND YOU WANT TO PUSH IT??
	TRNE FF,ARG2	;BARF IF TRY TO PUSH FS BOUNDARIES$, SINCE IT DOESN'T WIN.
	 TYPRE [WNA]
	MOVEI CH,A
	CALL OPENB2	;PUSH THE VALUE FROM A, WHERE FSET LEFT IT,
	MOVEM C,(AA)	;THEN SET "WHERE PUSHED FROM" FIELD TO THE INDEX OF THIS
			;FLAG IN THE FLAGS TABLE,
			;THUS TELLING AUTO-UNWIND TO POP THE FLAG BY DOING FPOP.
	RET

;HERE ARE THE COMMONLY USED FS FLAG ROUTINES.

FSNORM:	HLRZS C		;HERE TO READ/SET NORMAL FLAG;  C -> WORD HOLDING VALUE.
FSNOR1:	MOVE A,(C)
	ARGDFL
	TRZN FF,ARG
	 JRST POPJ1
	MOVEM B,(C)
	CAIE C,CASNRM	;IF SET CASNRM, ALSO SET CASDIS.
	 JRST POPJ1
	ANDI B,1
	MOVEM B,CASDIS
	JRST POPJ1

FSVAL:	HLRZ A,C	;HERE TO RETURN CONSTANT VALUE (AS FOR FS VERSIO$)
	JRST POPJ1

FSRSYS:	HRRI C,A	;HERE TO READ A PARTICULAR .SUSET VAR (AS FOR FS OPTION$)
	.SUSET C
	JRST POPJ1

FSRNLY:	MOVE A,C	;READ-ONLY FLAG'S ADDR IN LH(C)
	JRA A,POPJ1

FSROCA:	MOVE A,C	;READ ONLY CHAR. ADDR, RETURN RELATIVE TO BEG.
	JRA A,FSROC1

FSBIT:	TRZA C,-1	;LEAVE BIT IN LH(C) TO TEST LH BIT.
FSRBIT:	 HLRZS C	;GET BIT INTO RH(C) TO TEST R.H. BIT.
	SKIPA B,FF
FSTTOL:	 HLLZ B,TTYOPT	;TEST BIT IN LH(C) AGAINST LH(TTYOPT).
	TDNN B,C
NRET0:	 TDZA A,A	;VALUE IS 0 IF BIT CLEAR,
NRETM1:	  SETO A,	;-1 IF SET.
	JRST POPJ1

;ALTCOUNT FLAG, # COMMAND STRINGS TYPED AHEAD BY USER.
FSALTC:	CALL VBDACU	;DO LISTEN TO UPDATE TSALTC,
	 JFCL
	JRST FSNORM	;THEN DO NORMAL FS ON TSALTC.

;FS MACHINE$ - READ MACHINE NAME
FSMACH:	SYSCAL SSTATU,[REPEAT 6,[? MOVEM A]]
	 .LOSE 1000
	JRST POPJ1

;READ OR SET # OF COMMAND LINES.
FSECLS:	MOVE A,NELNS	;GET CURRENT # OF CMD LINES,
	ARGDFL
	TRZE FF,ARG
	 CALL FSECL1	;AND SET IT IF NEC.
	JRST POPJ1

;DESIRED # ECHO LINES IN B. (OR -<N> => NO ECHO, BUT <N>-1 ECHO LINES)
FSECL1:	SKIPGE C,B	;GET ARG IF POSITIVE,
	 SETCA C,	;OR -1-ARG IF NEGATIVE.
	CAML C,NVLNS	;VALUE TOO LARGE => WOULD CRASH TECO.
	 TYPRE [AOR]
	MOVEM B,NELNS
	MOVE B,NVLNS	;TOTAL # LINES - # ECHO LINES
	SUB B,C
	SUBI B,1	;DEDUCT 1 LINE FOR THE --MORE--
	MOVEM B,USZ	;= # LINES FOR BUFFER DISPLAY.
	ADDI B,10
	DPB B,[MORECV]
	DPB B,[MORMCV]
	SETOM MORESW	;A DIFFERENT LINE IS NOW THE --MORE-- LINE.
	SETOM DISOMD	;INDICATE DISPLAYED "MODE" (Q..J) IS OUT OF DATE.
IFN TS,[
	SYSCAL SCML,[1000,,TYIC ? C]
	 HALT
	SKIPE ECHOFL	;IF ECHOING NOMINALLY "ON" (THAT IS, NOT OFF DUE TO ^R OR ^T)
	 CALL SETTTM	;THEN MAYBE CHANGING THIS FLAG TURNS IT OFF OR ON.
]
	SETOM TYOFLG	;USZ HAS CHANGED, SO MAKE SURE TYPEOUT KNOWS ABOUT IT.
	RET

IFN TS,[
FSRUNT:	.SUSET [.RRUNT,,A]
	MULI A,4069.	;CONVERT TO NANOSEC.,
	DIV A,[1.^6]	;THEN TO MILLISEC.
	JRST POPJ1
]

FSUPTI:	.RDTIME A,	;RETURN THE SYSTEM UP TIME - FS UPTIME $
	JRST POPJ1

FSSWIT:	.RDSW A, ? JRST POPJ1	;RETURN PDP10 CONSOLE SWITCHES.

;F6 COMMAND.
FSIXB:	TRZN FF,ARG
	 JRST FSIXR	;NO ARG => READ IN STRING AND CONVERT TO SIXBIT. 
	TRZE FF,SLSL	;^ F6 RETURNS STRING CONTAINING THE CHARS OF THE SIXBIT. 
	 JRST FSIXST
	MOVE C,B	;TREAT ARG AS WD OF SIXBIT AND INSERT IN BUFFER. 
	MOVEI A,TYOM
	HRRM A,LISTF5
	CALL GAPSLP
	JRST SIXNTY	;GO INSERT THE SIXBIT. 

;READ IN A STRING , AND RETURN CONVERTED TO SIXBIT IN A.  IGNORE CONTROL CHARS.  SKIPS. 
FSIXR:	MOVE OUT,[440600,,A]
	SETZ A,
FSIXRL:	CALL LRCH
	CAIN CH,ALTMOD
	 JRST POPJ1
	CAIL CH,40
	 TLNN OUT,770000
	  JRST FSIXRL
	SUBI CH,40
	IDPB CH,OUT
	JRST FSIXRL

FSIXST:	AOS (P)		;HERE TO CONVERT SIXBIT TO STRING. 
	SAVE B
	MOVEI B,12.	;WE WILL NEED AT MOST 12 CHARS - MAKE SURE SPACE IS THERE. 
	CALL QOPEN
	MOVE C,(P)	;NOW OUTPUT THE SIXBIT INTO STRING SPACE (LISTF5 AND F
	CALL SIXNTY		;SET UP BY QOPEN). 
	JRST QCLOSV	;WRITE THE HEADER, REST B, AND RETURN THE STRING POINTER. 

FSDATE:	SYSCAL RQDATE,MOVEM A
	 .LOSE 1000
	JRST POPJ1

FSFDAT:	HLRZS C		;CREATION DATE OF FILE ON CHNL IN LH(C)
	ARGDFL
	SYSCAL RFDATE,[C ? 2000,,A]
	 JRST OPNER1
	TRZN FF,ARG
	 JRST POPJ1
	SYSCAL SFDATE,[C ? B]
	 JRST OPNER1
	JRST POPJ1

;"FS FDCONV $" IS LIKE "\" BUT HANDLES FILE DATES INSTEAD NUMBERS.
FSDCNV:	TRNE FF,ARG
	 JRST FSDCN2	;ARG => GO TURN IT INTO STRING IN BUFFER
	SAVE [0]	;PUSH WORD TO ACCUM. THE DATE IN.
FSDCN0:	MOVE OUT,[-6,, [40,,	;MONTH
			1,,	;DAY
			1000,,	;YEAR
			3600.*2	;HOUR (IN TERMS OF 1/2 SEC)
			60.*2	;MINUTE
			2]]	;SECOND
	JRST FSDCN4

FSDCN3:	MOVE IN,PT
	CAMN IN,ZV	;AT END OF BUFFER => RETURN WHAT WE HAVE
	 JRST FSDCN1
	CALL GETINC
	CAIN CH,^M	;STOP BEFORE A CR.
	 JRST FSDCN1
	AOS PT		;ELSE MOVE OVER DELINITER
FSDCN4:	SETZM SYL
	SAVE OUT
	CALL BAKSL	;READ THE NEXT NUMBER
	 JFCL
	REST OUT
	JUMPE A,FSDCN1	;NO NUMBER => FINISHED.
	IMUL A,(OUT)	;ELSE PUT THIS # IN RIGHT PLACE
	ADDM A,(P)	;IN THE DATE BEING ACCUMULATED.
	AOBJN OUT,FSDCN3 ;HAVEN'T READ ALL 6 YET => KEEP GOING.
FSDCN1:	REST A		;A HAS DATE TO RETURN.
	CAMN OUT,@FSDCN0 ;IF DATE IN BUFFER WAS NULL,
	 SETO A,	;RETURN -1
	JRST POPJ1

FSDCN2:	MOVEI TT,TYOM
	HRRM TT,LISTF5	;PRINT THE DATE INTO MEMORY.
	CALL GAPSLP
	MOVEM B,PTLFCD
	SKIPL B		;DATE IS -1 => JUST CR.
	 CALL PTLAB9
	JRST CRR1

;RETURN THE HORIZ POS. OF THE CURRENT POINTER SETTING,
;ASSUMING THAT BACKSPACES AND STRAY CR'S COME OUT AS SUCH.
; ^HPRINT AND ^MPRINT FLAGS ARE NOT LOOKED AT.
FSHPOS:	MOVE F,BEGV
	SOS B,F
	SETZ A,
	MOVE F,PT
	CAMN F,BEGV
	JRST POPJ1
	MOVE IN,F
	SOS F
FSHPOL:	SOS IN
	CALL GET
	CAIE CH,^M
	 CAMN B,IN
	  JRST FSHPOT
	JRST FSHPOL

FSHPOD:	AOS IN
	CALL GET
	CAIE CH,^J
	 CAIN CH,GLITCH
	  JRST FSHPOT
	CAIN CH,^I
	 JRST [	ADDI A,10
		TRZ A,7
		JRST FSHPOT]
	CAIN CH,ALTMOD
	 AOJA A,FSHPOT
	CAIN CH,^H
	 SOJA A,FSHPOT
	CAIGE CH," 
	 AOJ A,
	AOJ A,
FSHPOT:	CAME IN,F
	 JRST FSHPOD
	JRST POPJ1

;READ OR SET THE VIRTUAL BUFFER BOUNDARIES - THE RANGE OF
;BUFFER THAT ALL OTHER COMMANDS ARE ALLOWED TO TOUCH.
FSBOUN:	TRNN FF,ARG
	 JRST HOLE	;NO ARG => RETURN BOUNDS, LIKE H COMMAND
	MOVE C,SARG
	CALL GETARG	;ELSE CALCULATE NEW BOUNDS,
	 CALL CHK1A
	CALL HOLE	;SET UP THE VALUES TO BE RETURNED,
	 JFCL
FSBOU1:	CALL CHK1A	;MAKE SURE BEG<B<C<Z, IN CASE COMING FROM FSVB OR FSVZ.
	MOVEM B,ZV	;STORE NEW BOUNDS (HOLE LOOKED AT OLD ONES)
	MOVEM C,BEGV
	CAMG B,PT	;MOVE PT INTO THE RANGE NOW
	 MOVEM B,PT	;BEING EDITED, IN CASE IT IS OUTSIDE IT.
	CAML C,PT
	 MOVEM C,PT
VALRTA:	TRZ FF,ARG	;RETURN VALUE, FLUSHING ARGUMENTS.
	JRST POPJ1

FSVB:	MOVE A,BEGV	;GET B AS REL. CHAR ADDR.
	SUB A,BEG
	TRZN FF,ARG	;IF NO ARG, JUST RETURN THAT.
	 JRST POPJ1
	ADD B,BEG	;ELSE TURN ARG INTO ABS CHAR ADDR, TO SET BEGV.
	MOVE C,B	;GET IN B NEW VALUE OF ZV (SAME AS OLD
	CAMG B,ZV	;UNLESS THAT WOUL DBE LESS THAN NEW BEGV).
	 MOVE B,ZV
	JRST FSBOU1	;GO SET THEM BOTH (AND MAYBE PT).

FSVZ:	MOVE A,Z	;GET Z-ZV TO RETURN.
	SUB A,ZV
	TRZN FF,ARG	;IF ARG, IT IS DESIRED Z-ZV
	 JRST POPJ1
	MOVE C,Z
	SUBB C,B	;SO SOMPUTE DESIRED ZV FROM IT
	CAML C,BEGV
	 MOVE C,BEGV	;AND IF NECESSARY CHANGE BEGV AS WELL.
	JRST FSBOU1

;FA COMMAND (TEXT JUSTIFICATION). ARGS SPEC RANGE OF BUFFER.
;THE LINE SIZE IS KEPT IN ADLINE (FS ADLINE).
;A CRLF FOLLOWED BY A CRLF OR SPACE CAUSES A BREAK.
;OTHERWISE, CRLFS ARE REPLACED BY SPACES, UNLESS THEY END BLANK LINES.
;EXCESS SPACES (OR CRLFS TURNED INTO SPACES) ARE NOT REMOVED.
;IF THEY FOLLOW A CRLF INSERTED BY FILLING, THEY ARE MOVED IN BEFORE
;THAT CRLF TO AVOID EITHER CHANGING THE NUMBER OF EXTRA SPACES OR
;CREATING A BREAK WHERE NONE EXISTED.
;SPACES AT THE BEGINNING OF A LINE ARE TREATED AS PART OF
;THE FIRST WORD OF THE LINE FOR JUSTIFICATION PURPOSES,
;TO PREVENT INDENTATION OF PARAGRAPHS FROM CHANGING.
;THE LAST PART-LINE OF STUFF TO BE JUSTIFIED
;IS CONSIDERED TO HAVE A BREAK AFTER IT.
;SPACE-BACKSPACE-SPACE ACTS LIKE A SINGLE ORDINARY CHAR.
;THIS MAKES IT POSSIBLE TO PUT A SPACE INTO A WORD.
;^FA IS LIKE FA BUT ONLY FILLS - IT DOESN'T JUSTIFY.

;ALTF => IF NEXT CHAR IS SPACE OR CR, IT SHOULD BREAK.
;NOTF => NO NON-SPACE HAS BEEN SEEN YET ON THIS LINE
	;(SO SPACES SHOULD BE LIKE ORDINARY CHARS)
;FINDR => PREVIOUS CHAR WAS ^H SO SPACE IS ORDINARY.
;LSTCRF => PREV. CHAR WAS SPACE, SO SPACE SHOULD BE ORDINARY AFTER IT
ADJUST:	PUSHJ P,GETARG
	 PUSHJ P,CHK1
	EXCH B,C	;THROUGHOUT THE CMD, C -> 1ST CHAR AFTER RANGE TO JUSTIFY.
	MOVEM B,PT
	CALL GAPSLP
	SAVE [0]	;THIS WD HAS STARTING HPOS OF LINE.

;COME HERE TO PRODUCE 1 MORE LINE OF JUSTIFIED TEXT.
ADJLP0:	ANDCMI FF,ALTF
	MOVE IN,PT
	MOVE E,IN	;E -> 1ST CHAR THAT MIGHT NOT FIT (DON'T KNOW YET)
	ANDCMI FF,FINDR+LSTCRF	;PREV. CHAR WASN'T ^H. OR SPACE.
	TRO FF,NOTF	;NO NON-SPACE HAS BEEN SEEN SO FAR.
	MOVE D,(P)	;D HAS HPOS IN OUTPUT LINE,
	SETZ OUT,	;OUT IS # WDS FOUND SO FAR.
	SETZ Q,		;Q IS 0 IF WE HAVEN'T PASSED A CRLF, OR CHAR ADDR AFTER LAST CRLF.
	SETZ B,		;B HAS # WDS AS OF LAST CRLF WE PASSED.
	SAVE D		;(P) HAS WHAT D HAD WHEN IN HAD WHAT E HAS.
	MOVE F,IN
	ADD F,EXTRAC
	CALL GETIBP	;WE WILL FETCH CHARS VIA F.
ADJLP1:	CAML IN,C
	 JRST ADJBRK	;PRETEND THERE'S A SPACE AFTER RANGE TO WORK ON.
	ILDB CH,F
	AOJ IN,
	CAIG CH,40
	 JRST ADJCTL
ADJNRM:	ANDCMI FF,ALTF\NOTF\FINDR\LSTCRF	;NORMAL CHAR ON PASS 1 OF FA.
	AOJA D,ADJLP1

ADJCTL:	CAIN CH,40
	 JRST ADJSPC	;SPACE ENDS A WORD.
	CAIN CH,^M
	 JRST ADJCR	;CR ENDS A WORD.
	CAIN CH,^I
	 JRST ADJTAB
	CAIN CH,^L
	 JRST ADJSKP
	CAIE CH,^H
	 JRST ADJNRM
	TRZ FF,ALTF\NOTF\LSTCRF
	IORI FF,FINDR
	SOJGE D,ADJLP1
	AOJA D,ADJLP1

ADJTAB:	TRNE FF,ALTF	;COME HERE FOR TAB
	 SOJA IN,ADJBRK	;TAB AT START OF LINE BREAKS.
	IORI D,7	;ELSE ADVANCE HPOS TO TAB STOP
	ADDI D,1
	MOVEM D,-1(P)	;SAY NEXT OUTPUT LINE STARTS AT THAT STOP
	JUMPE Q,ADJSK1	;IF WE HAVEN'T PASSED A CRLF THIS TIME, SKIP PAST ALL BEFORE TAB.
	MOVE IN,Q	;ELSE BACK UP TO THE CRLF AND FILL UP TO IT.
	MOVE OUT,B	;THEN NEXT TIME WE'LL SKIP ALL FROM CRLF TO THE TAB.
	JRST ADJBRK

;COME HERE ON SPACE
ADJSPC:	TRNN FF,ALTF	;IF 1ST CHAR ON LINE, OR IF THIS SPACE FOLLOWS
	 TRNN FF,FINDR\LSTCRF\NOTF	;A WORD,
	  SKIPA AA,F	;THEN UNLESS
	   JRST ADJNSP
	ILDB AA,AA	;IT IS FOLLOWED BY A BACKSPACE, WE END A WORD.
	CAIE AA,^H
	 JRST ADJSP1
ADJNSP:	TRZ FF,FINDR\ALTF
	AOJA D,ADJLP1

ADJCR:	TRZE FF,FINDR	;COME HERE ON CR.
	 AOJA IN,ADJBRK	;CR PRECEDED BY ^H CAUSES BREAK.
	TRNE FF,ALTF	;THIS CR ENDS NULL LINE => BREAK
	 SOJA IN,ADJBRK	;BEFORE IT.
			;THE PARAGRAPH WILL BE ENDED, AND WE'LL
			;COME BACK HERE WITH ALTF CLEAR,
			;AND DO THE JUMPE D, BELOW.
	IBP F		;SKIP THE LF ASSUMED TO FOLLOW THE CR.
	AOS IN
	MOVE Q,IN	;REMEMBER CHAR ADDR AND # WDS AS OF MOST RECENT CRLF.
	MOVE B,OUT
	JUMPE D,ADJSKP	;NULL LINE AT BEGINNING => PASS OVER IT.
ADJSP1:	TRNE FF,ALTF	;SPACE AFTER CRLF; BREAK BEFORE THE SPACE
	 SOJA IN,ADJBRK	;SO SPACE WILL BE REPROCESSED FOR NEXT LINE.
	JUMPE OUT,ADJSP2 ;PREVENT LOSSAGE FROM SUPERLONG WORD.
	CAMLE D,ADLINE
	 JRST ADJGO	;WORD JUST ENDED WON'T FIT =>JUSTIFY THE OTHERS & NEW LINE.
ADJSP2:	MOVEM D,(P)	;REMEMBER HOW FAR WE GOT IN BUFFER AND LINE.
	MOVE E,IN
	AOS D		;IF NEXT WD FITS, WILL NEED 1 POS FOR SPACE.
	CAIN CH,^M
	TROA FF,ALTF	;AFTER ^M, ANOTHER SPACE BREAKS.
	 IORI FF,LSTCRF
	AOJA OUT,ADJLP1

ADJSKP:	SETZM -1(P)
ADJSK1:	MOVEM IN,PT	;PASS OVER SOME TEXT, NOT FILLING.
	SUB P,[1,,1]
	CALL GAPSLP
	JRST ADJBR3

ADJBRK:	SETZM (P)	;FILL THE LINE BEFORE A BREAK BUT NOJUST.
	MOVE E,IN
	TRO FF,ALTF	;INDICATE WE STOPPED AT A BREAK.
	JRST ADJBR1

;COME HERE AFTER DELIMITING WHAT WILL BECOME ONE LINE, TO JUSTIFY IT.
ADJGO:	MOVN D,(P)
	ADD D,ADLINE
	TRNE FF,SLSL	;JUST FILLING => INSERT NO SPACES.
	 SETZ D,
	MOVEM D,(P)	;# SPACES MUST SCATTER THRU LINE.

;(P) HAS # OF SPACES WE MUST INSERT TO JUSTIFY
 ;(0 IF STOPPED AT A BREAK, IN WHICH CASE ALTF SET)
;OUT HAS # OF WORD-BREAKS IN THE LINE.
;E HAS CHAR ADDR OF 1ST CHAR NOT TO BE INCLUDED.
;-1(P) STILL HAS HPOS TO START NEXT LINE AT.
;C STILL HAS 1ST CHAR NOT TO BE PROCESSED BY THE FA COMMAND.
ADJBR1:	SETZ D,
	SOSG OUT
	 MOVEI OUT,1
	ANDCMI FF,FINDR+LSTCRF
	TRO FF,NOTF	;NO NON-SPACE CHAR SEEN YET.
	MOVE IN,PT	;IN IS CHAR ADDR FOR TAKING FROM ABOVE GAP,
	MOVE F,PT
	CALL GETIBP	;F IS BP FOR IDPBNG INTO BOTTOM OF GAP.
ADJGL:	CAML IN,C
	 JRST ADJEND
	CALL GETINC
	CAIN CH,^M
	 JRST ADJGCR
	CAIN CH,40
	 JRST ADJGS
ADJGS4:	CAMLE IN,E	;AT END OF THIS OUTPUT LINE & PAST ALL TRAILING SPACES
	 JRST ADJDUN	;=> INSERT THE CRLF AND HACK NEXT LINE.
	ANDCMI FF,NOTF+LSTCRF	;NON-SPACE SEEN.
	CAIN CH,^H
	 TROA FF,FINDR
ADJGS1:	ANDCMI FF,FINDR
	IDPB CH,F	;ORD. CHR., JUST COPY TO BELOW THE GAP.
	AOS GPT
	AOS PT
	JRST ADJGL

ADJGS:	TRNE FF,NOTF+FINDR+LSTCRF
	 JRST ADJGS1	;SPACE AFTER BS OR BEFORE 1ST WD.
	CALL GETINC	;ELSE SEE IF FOLLOWED BY BS.
	CAIE CH,^H
	 SOJA IN,ADJCR1	;NO, IT IS A WORD DELIMITER.
	MOVEI CH,40
	SOJA IN,ADJGS4	;YES, IT IS ORDINARY.

ADJGCR:	ANDCMI FF,FINDR	;CR: DELETE FOLLOWING LF IF ANY.
	CALL GET
	CAIN CH,^J
	 CALL ADJDLC
ADJCR1:	MOVEI CH,40	;ALSO REPLACE THE CR WITH A SPACE.
	IORI FF,LSTCRF
	CAML IN,E	;DON'T PASS FOLLOWING SPACES/CRLFS INTO THIS LINE
	 TRNN FF,ALTF	;IF IT WAS TERMINATED BY A BREAK.
	  CAIA
	   JRST [CALL ADJDLC
		 JRST ADJDU1]
	CAMGE IN,E
	 ADD D,(P)
ADJGS2:	CAMGE D,OUT
	 JRST ADJGS1
	IBP F		;TIME TO GENERATE A SPACE.
	SUB D,OUT
	AOS C
	AOS E		;RELOC OUR PTRS TO BUFFER SINCE INSERTING CHAR.
	AOS IN
	CALL TYOM
	JRST ADJGS2	;SEE IF SHOULD INSERT ANOTHER SPACE.

ADJEND:	LDB CH,F
	CAIN CH,40
ADJDUN:	 CALL ADJDLB
ADJDU1:	REST D
	MOVEI CH,^M	;PRODUCED A LINE, PUT CRLF AFTER IT, REPLACING THE SPACE THERE.
	CALL TYOM
	MOVEI CH,^J
	CALL TYOM
	ADDI C,2	;RELOCATE PTR TO BUFFER ABOVE PLACE INSERTED IN.
	SETZM (P)	;NEXT LINE STARTS IN COLUMN 0.
ADJBR3:	CAMLE C,PT	;MORE CHARS TO HANDLE =>
	 JRST ADJLP0	;DO ANOTHER LINE.
	JRST POP1J

ADJDLB:	SOS PT
	SOS GPT
ADJDLC:	AOS EXTRAC	;DELETE THE CHAR AT PT.
	SOS Z
	SOS C
	SOS ZV
	SOJA E,CPOPJ

;"F^A" SCAN THROUGH THE BUFFER, DISPATCHING THROUGH A
;USER-SUPPLIED TABLE ON EACH CHARACTER.
;"^ F^A" SCANS BACKWARDS.
FCACMD:	CALL QREGX	;GET DISPATCH TABLE IN A.
	CALL GETARG
	 CALL CHK1	;C,B HAVE RANGE TO SCAN.
	TRNE FF,SLSL
	 EXCH B,C	;C HAS PLACE TO START; B HAS PLACE TO STOP.
	MOVEM C,PT
	MOVEI TT,FCA1	;LOOP POINT IF FCA1 FOR FORWARD SCAN.
	TRZE FF,SLSL
	 MOVEI TT,FCA3	;FCA3 FOR BACKWARD SCAN.
	SAVE TT
	MOVE OUT,QRB..	;SAVE NAME OF CHAR CONTAINING DISPATCH TABLE IN .Q..3
	MOVEM CH,.Q..3(OUT)
FCA0:	MOVE A,(CH)
	CALL QLGET1	;GET LENGTH IN AA, BP IN F.
	 TYPRE [QNS]
	CAIGE AA,128.*5
	 TYPRE [STS]	;STRING TOO SHORT.
	JRST @(P)	;FCA1 OR FCA3

;LOOP POINT FOR FORWARD SCAN.
;F HAS BP TO ILDB TABLE;
;B HAS CHAR ADDR OF LAST CHAR TO SCAN + 1.
FCA1:	MOVE IN,PT
	CAML IN,B
	 JRST POP1J	;FINISHED SCAN => RETURN.
	CALL GETINC
	MOVEM IN,PT
FCA4:	TRNE FF,TRACEF
	 CALL FCATRC	;PRINT PRETTY INFO IF TRACING.
	MOVEM CH,.Q..0(OUT) ;SAVE CHAR IN CASE MACRO WANTS IT.
	ADD CH,F	;FIND THE 5 CHARS OF TABLE FOR THIS CHR.
	ILDB A,CH	;IS THE FIRST A SPACE?
	CAIE A,40
	 JRST FCA2	;NO, MACRO THE 5 CHARS.
	ILDB A,CH	;YES, THE NEXT CHAR HOLDS THE WIDTH
	SUBI A,100
	ADDM A,.Q..1(OUT) ;OF THIS CHAR, PLUS 100 .
	ILDB A,CH	;GET THE 3RD CHAR OF THE FIVE.
	CAIN A,40	;"(" AND ")" ARE SPECIAL, " " IS NORMAL.
	 JRST @(P)	;FCA1 OR FCA3
	HRRZ CH,(P)	;IT'S SPECIAL. WHICH DIRECTION ARE WE SCANNING?
	CAIE A,")	;IF CODE IS ")",
	 JRST FCAOPN
	SKIPGE .Q..1(OUT) ;STOP IF COUNT < 0 AND GOING FORWARD.
	 CAIE CH,FCA1
	  JRST (CH)
	JRST POP1J

FCAOPN:	SKIPLE .Q..1(OUT) ;CODE IS "("; STOP IF COUNT > 0 AND GOING BACKWARD.
	 CAIE CH,FCA3
	  JRST (CH)
	JRST POP1J

FCA3:	MOVE IN,PT	;LOOP POINT FOR SCANNING BACKWARDS
	CAMG IN,B
	 JRST POP1J
	SOS IN,PT
	CALL GET
	JRST FCA4

;IN TRACE MODE, CALL HERE TO PRINT !<CHAR>! FOR EACH CHAR WE PASS.
FCATRC:	SAVE CH
	MOVEI CH,"!
	CALL TYOS
	MOVE CH,(P)
	CALL TYOS
	MOVEI CH,"!
	CALL TYOS
	JRST POPCHJ

;HERE FOR A CHAR WHICH REQUIRES THAT WE ACTUALLY MACRO SOME STUFF.
FCA2:	SUB B,BEG	;TURN END OF RANGE INTO CHAR NUMBER
	MOVEM B,.Q..2(OUT) ;PUT IT WHERE USER CAN UPDATE IT
	MOVN TT,(P)
	ADDI TT,FCA1	;TT IS POS. IFF SCANNING FORWARD.
IFL FCA3-FCA1,.ERR
	ASH TT,-43	;-1 IFF BACKWARD, 0 IFF FORWARD.
	IORI TT,1	;-1 IFF BACKWARD, 1 IFF FORWARD.
	MOVEM TT,INSLEN	;MAKE "^F" REPLACE THE CHAR SCANNED.
	MOVE AA,.Q..0(OUT)
	ADD F,AA
	IMULI AA,5
	ADDI AA,5
	MOVEI C,5	;MACRO A STRING THAT IS AN INITIAL
		;SEGMENT OF THE DISPATCH TABLE, ENDING AFTER THE
		;FIFTH OF THE CHARS FOR THE CHAR JUST SCANNED.
		;WANT TO SET COMCNT TO 5, AND COMAX TO THE #
		;OF CHARS UP TO AND INCLUDING THOSE 5.
	CALL MACXC3	;EXECUTE THEM.
	MOVE OUT,QRB..
	MOVE B,.Q..2(OUT)
	ADD B,BEG	;SEE HOW THE MACRO HAS CHANGED END OF RANGE.
	CAMLE B,ZV
	MOVE B,ZV
	MOVE CH,.Q..3(OUT)
	JRST FCA0

POP2J:	SUB P,[2,,2]
	POPJ P,

;<CH>F^B<STRING>$ - RETURNS -1 IF <CH> DOES NOT OCCUR
;IN <STRING>; OTHERWISE RETURNS THE POSITION OF THE FIRST
;OCCURRENCE (0 IF <CH> IS THE FIRST CHARACTER OF <STRING>).
;AT CALL, <CH> IS IN B. THIS COULD BE SMARTER:
;IF <CH> IS FOUND IN THE MIDDLE OF A SUBSTITUTED QREG
;WITHIN <STRING>, WE COULD JUST POP OUT OF IT RATHER THAN
;READING THROUGH IT.
FMEMQ:	TRZN FF,ARG
	 TYPRE [WNA]
	MOVE AA,MACPDP
	SETZ A,		;A COUNTS THE CHARS WHICH AREN'T <CH>.
FMEMQ1:	CALL RCH
	SKIPN SQUOTP	;NO; REACHED END OF STRING?
	 CAIE CH,ALTMOD
	  CAIA		;NO, SEE IF REACHED DESIRED CHARACTER (OUR NUMERIC ARG)
	   JRST NRETM1	;YES, RETURN -1
	CAIE B,(CH)
	 AOJA A,FMEMQ1	;DIDN'T REACH CHAR BEING SEARCHED FOR.
	CALL FNOOP	;FOUND <CH>. NOW IGNORE REST OF STRING.
	JRST POPJ1	;AND RETURN THE VALUE, ALREADY IN A.

FWCMD:	MOVEI F,WORDSP
	JRST .+2
FLCMD:	MOVEI F,LISTSP
FLCMD1:	ARGDFL Z
	SAVE PT
	SETZM SEXPFL
	CALL (F)
	MOVE C,PT
	REST B
	MOVEM B,PT
	CAMGE B,C
	 EXCH B,C
	SUB B,BEG
	SUB C,BEG
	MOVEM C,SARG
	MOVE A,B
	TRZ FF,SLSL
	TRO FF,ARG2
	JRST POPJ1

FUCMD:	JSP F,FLCMD1
	SETZM DOWNF
	MOVM E,B
	MOVNS E
FUCMD1:	JUMPE E,CPOPJ
	HLRES B
	JRST LISTSQ

FDCMD:	JSP F,FLCMD1
	SETOM DOWNF
	MOVM E,B
	JRST FUCMD1

;THIS ROUTINTE TAKES ARG IN B, AND DOES <ARG>FWL.
;FS INSLEN IS SET TO LENGTH OF LAST WORD OR INTER-WORD-SPACE SEEN
;(NOTE IF YOU START WITHIN A WORD, FS INSLEN$ MIGHT NOT BE WHAT YOU WANT).
;IF SEXPFL IS SET, ASSUMES WAS REACHED FROM ^ FL, AND GOES BACK THERE
;AFTER FINDING ONE WORD.
;THE UPARROW FLAG CAUSES SCANNING TO BE FOR LISP ATOMS INSTEAD OF WORDS.
WORDSP:	CALL SKNBCP	;INITIALIZE SO WE CAN CALL SKNBRK.
	TRNE FF,SLSL
	 IBP SKNBPT	;FOR LISP, USE 2ND CHAR OF DISPATCH ENTRY RATHER THAN 1ST.
	JUMPL B,WBACK
	JUMPE B,CPOPJ
	CALL LFINIT	;SET UP C, IN, F.
WFVBA1:	SKIPE SEXPFL	;HERE TO START WORD-GAP, TREATING LAST CHAR SEEN AS PART OF PREV. WORD.
	 JRST LFLOOP
	MOVE AA,C	;SAVE C IN AA EVERY SO OFTEN. C-AA WILL BE VALUE OF INSLEN.
	SOSA AA
WFSBEG:	 MOVE AA,C	;LIKE WFVBA1, BUT COUNT LAST TERMINATOR AS PART OF THIS GAP.
	SKIPE SEXPFL
	 JRST LFDSP
WFSLUP:	SOJLE C,WFSEOB
	CAMN C,IN	;IF WE'VE REACHED THE GAP,
	 CALL FEQGAP	;MAKE F POINT ABOVE IT.
	ILDB A,F
	LDB A,SKNBPT
	CAIN A,"A
	 JRST WFSEND
	CAIE A,"/
	 CAIN A,"|
	  JRST WFSEND
	JRST WFSLUP

WFSEND:	TRNE FF,COLONF
WFVBA2:	 SOJLE B,WFDONE
	MOVE AA,C
	CAIN A,"|
	 JRST WFVBAR	;WIN IN CASES LIKE |FOO||BAR|
	JRST WFWDSP	;NOW PROCESS CHAR THAT STARTS THE WORD AS IF FOUND IT INSIDE WORD

WFWLUP:	SOJLE C,WFWEOB
	CAMN C,IN	;IF WE'VE REACHED THE GAP,
	 CALL FEQGAP	;MAKE F POINT ABOVE IT.
	ILDB A,F
	LDB A,SKNBPT
WFWDSP:	CAIN A,"A
	 JRST WFWLUP
	CAIN A,"'	;' CHARS CAN CONTINUE A WORD, BUT NOT START ONE.
	 JRST WFWLUP
	CAIN A,"/
	 JRST WFSLSH
	CAIN A,"|	;| INSIDE WORD IS CASE OF FOO|BAR|, WHICH IS 2 WORDS,
	 JRST [	TRNE FF,COLONF	;SO END THIS WORD AND IMMEDIATELY START ANOTHER.
		 MOVE AA,C
		JRST WFVBA2]
WFWEND:	TRNE FF,COLONF
	 JRST WFSBEG
	SOJG B,WFSBEG
WFDONE:	SUB AA,C
	SUB C,ZV
	MOVNS C
	JRST WORD12

WFSEOB:	TRC FF,COLONF	;WENT FWD PAST Z, BETWEEN WORDS.
WFWEOB:	SOJG B,TYPNIB	;WENT FWD PAST Z, IN MIDDLE OF WORD.
	TRNE FF,COLONF
	 JRST TYPNIB
	JRST WFDONE

WFSLSH:	CALL LFSLSH	;HANDLE A SLASH-CHARACTER GOING FORWARD.
	JRST WFWLUP

WFVBAR:	CALL LFVBAR	;VERTICAL BAR:  SKIP TO MATCHING ONE.
	TRNN FF,COLONF	;IF TIME TO STOP MOVING, MAKE SURE CLOSING VBAR
	 SOJLE B,[SOJA C,WFDONE] ;COUNTS AS PART OF WORD, NOT PART OF GAP.
			;IF MUST KEEP GOING, DO SO, BUT DON'T COUNT
	JRST WFVBA1	;THE VBAR AS PART OF THE GAP THAT'S STARTING.

;MOVE BACKWARDS OVER WORDS.

WBACK:	MOVMS B
	CALL LBINIT	;SET UP F, C, IN.
WBVBA1:	SKIPE SEXPFL
	 JRST LBLOOP
	MOVE AA,C
	SOSA AA
WBSBEG:	 MOVE AA,C
	SKIPE SEXPFL
	 JRST LBDSP
WBSLUP:	SOJL C,WBSEOB
	CAMN C,IN	;IF WE'VE REACHED THE GAP,
	 CALL DWNGAP	;MAKE F POINT BELOW IT.
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
	CAIE A,"A
	 CAIN A,"|
	  JRST WBSEND
	CAIE A,"/
	 JRST WBSLUP
WBSLSH:	SAVE C		;FOUND A SLASH GOING BACKWARD.
	SAVE F		;IF IT'S SLASHED, IT ENDS A WORD; ELSE FOLLOWING CHAR
	CALL REALP	;IS SLASHED AND ENDS THE WORD.
	 JFCL		;BIT 1.1 OF CH IS 1 IF SLASH IS SLASHED.
	REST F
	REST C
	TRNE CH,1
	 JRST WBSEND
	IBP F
	AOJ C,
WBSEND:	TRNE FF,COLONF
WBVBA2:	 SOJLE B,WBDONE
	MOVE AA,C
	CAIN A,"|
	 JRST WBVBAR
	JRST WBWDSP

WBWLUP:	SOJL C,WBWEOB
	CAMN C,IN	;IF WE'VE REACHED THE GAP,
	 CALL DWNGAP	;MAKE F POINT BELOW IT.
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
WBWDSP:	CAIN A,"A
	 JRST WBWLUP
	CAIN A,"|
	 JRST [	TRNE FF,COLONF
		 MOVE AA,C
		JRST WBVBA2]
	CAIE A,"'
	CAIN A,"/
	 JRST WBWLUP
	SAVE F
	SAVE C
	CALL REALP
	 JFCL
	REST C
	REST F
	TRNE CH,1
	 JRST WBWLUP
WBWEND:	TRNE FF,COLONF
	 JRST WBSBEG
	SOJG B,WBSBEG
WBDONE:	SUBM C,AA
	AOJ C,
	ADD C,BEGV
WORD12:	MOVEM C,PT
	MOVEM AA,INSLEN
	TRZ FF,COLONF+SLSL
	RET

WBSEOB:	TRC FF,COLONF
WBWEOB:	SOJG B,TYPNIB
	TRNE FF,COLONF
	 JRST TYPNIB
	JRST WBDONE

WBVBAR:	CALL LBVBAR	;MOVE BACK OVER A VERTICAL BAR GROUPING.
WBVBA4:	JUMPE C,WBVBA3	;THEN BACK OVER ALL ' CHARACTERS BEFORE IT.
	SAVE C
	SAVE F
	SOJ C,
	CAMN C,IN	;IF WE'VE REACHED THE GAP,
	 CALL DWNGAP	;MAKE F POINT BELOW IT.
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
	CAIN A,"'
	 JRST [	SUB P,[2,,2]
		JRST WBVBA4]
	REST F
	REST C
WBVBA3:	TRNN FF,COLONF	;IF IT'S TIME TO STOP MOVING, SAY WE STOPPED AFTER PASSING THE
	 SOJLE B,[SOJA C,WBDONE] ;VBAR, INSTEAD OF BEFORE, AS WE WOULD STOP AT A SPACE.
	JRST WBVBA1	;IF KEEP MOVING, DON'T INCLUDE THE VBAR IN THE NEW GAP.

LISTSP:	TRNE FF,SLSL
	 SETOM SEXPFL
	SETZB E,DOWNF
	JUMPE B,CPOPJ
LISTSQ:	CALL SKNBCP	;SET UP SKNBPT FROM ..D
	IBP SKNBPT
	JUMPL B,LBACK
	CALL LFINIT	;SET UP F, C, IN.
LFLOOP:	SOJLE C,LFEOB	;AFTER THIS INSN C HAS # CHARS LEFT TO SCAN.
	CAMN C,IN	;IF WE'RE ABOUT TO ILDB INTO THE GAP, CROSS IT:
	 CALL FEQGAP	;(F <- BP TO ILDB 1ST CHAR AFTER GAP).
	ILDB A,F
	LDB A,SKNBPT	;GET DISPATCH ENTRY OF THIS CHARACTER.
LFDSP:	CAIN A,"/
	 JRST [	TRNE FF,SLSL	;FOR ^ FL, REMEMBER SLASH STARTS AN ATOM.
		 JUMPE E,WFSEND
		CALL LFSLSH
		JRST LFLOOP]
	CAIN A,"|
	 JRST [	TRNE FF,SLSL
	 	 JUMPE E,WFSEND
		CALL LFVBAR
		JRST LFLOOP]
	TRNE FF,SLSL
	 CAIE A,"A
	  JRST LFFOO1
	JUMPE E,WFSEND
LFFOO1:	CAIN A,"(
	 JRST LFLPAR
	CAIE A,")
	 JRST LFLOOP
	SKIPE DOWNF
	AOJA E,LFLOOP
	AOJL E,LFLOOP
	SETZ E,		;MAKE SURE 2FLL SAME AS FLL FLL.
	SOJG B,LFLOOP
LFDONE:	SUB C,ZV
	TRC FF,COLONF
	JRST LISTX

LFEOB:	JUMPL E,[TYPRE [UBP]]	;UNBALANCED PARENTHESES
TYPNIB:	TYPRE [NIB]

LFSLSH:	SOJLE C,TYPUEB	;HANDLE "/" GOING FORWARD.
	CAMN C,IN	;IF WE'VE REACHED THE GAP, MAKE F CROSS IT.
	 CALL FEQGAP
	IBP F
	RET

TYPUEB:	TYPRE [UEB]

LFLPAR:	TRNE FF,COLONF
	 JUMPE E,[SOJE B,LFDONE
		  AOJA B,.+1]
	SKIPN DOWNF
	 SOJA E,LFLOOP
	SOJG E,LFLOOP
	JRST LFDONE

LFVBAR:	SOJLE C,TYPUEB	;HANDLE "|" GOING FORWARD.
	CAMN C,IN
	 CALL FEQGAP	;WHEN REACH GAP, MOVE OVER IT.
	ILDB A,F
	LDB A,SKNBPT	;DECODE NEXT CHARACTER.
	CAIN A,"/
	 JRST [	CALL LFSLSH	;SLASH => DON'T CHECK NEXT CHAR FOR BEING A "|".
		JRST LFVBAR]
	CAIE A,"|
	 JRST LFVBAR	;FIRST UNSLASHIFIED "|" ENDS THE STRING.
	RET

;MOVE BACKWARD OVER LISTS.

LBACK:	MOVMS B
	CALL LBINIT	;SET UP F, C, IN.
LBLOOP:	SOJL C,LFEOB
	CAMN C,IN	;IF ABOUT TO DLDB INTO LAST CHAR OF GAP,
	 CALL DWNGAP	;MAKE F -> LOWEST CHAR. OF GAP.
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
LBDSP:	CAIN A,"|
	 JRST [	TRNE FF,SLSL
		 JUMPE E,WBSEND
		CALL LBVBAR
		JRST LBLOOP]
	TRNN FF,SLSL	;IF ^ FL, NOTE THAT LETTERS AND SLASH START ATOMS
	 JRST LBFOO1
	CAIN A,"A
	 JUMPE E,WBSEND
	CAIN A,"/	;FOR SLASH, THE CHAR AFTER IT (ALREADY SCANNED)
	 JUMPE E,WBSLSH	;IS ALSO PART OF THE ATOM.
LBFOO1:	CAIN A,")
	 JRST LBRPAR
	CAIE A,"(
	 JRST LBLOOP
	CALL REALP
	 JRST LBQOTD
	SKIPE DOWNF
	 AOJA E,LBLOOP
	AOJL E,LBLOOP
	SETZ E,
	SOJG B,LBLOOP
	TRNN FF,SLSL	;FOUND MATCHING OPENPAREN.  NOW, IF PASSING SEXPS,
	 JRST LBDONE
LBQOT1:	MOVE AA,C	;SKIP OVER ANY NO-SLASHIFIED '-LIKE CHARACTERS
	SOJL C,LBQOT2	;THAT PRECEDE THE OPENPAREN.
	CAMN C,IN
	 CALL DWNGAP
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
	CAIN A,"'
	 CALL REALP
LBQOT2:	  SKIPA C,AA
	   JRST LBQOT1
LBDONE:	ADD C,BEGV
LISTX:	MOVMM C,PT
	TRZE FF,COLONF
	 AOS PT
	POPJ P,

LBVBAR:	CALL REALP	;HANDLE "|" GOING BACKWARDS.
	 RET
LBVBLP:	SOJL C,TYPUEB
	CAMN C,IN
	 CALL DWNGAP
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
	CAIN A,"|
	 CALL REALP
	  JRST LBVBLP
	RET

LBRPAR:	CALL REALP	;HANDLE ")", MOVING BACKWARD.
	 JRST LBQOTD
	TRNE FF,COLONF
	 JUMPE E,[SOJE B,LBDONE
		AOJA B,.+1]
	SKIPN DOWNF
	 SOJA E,LBLOOP
	SOJG E,LBLOOP
	JRST LBDONE

LBQOTD:	TRNE FF,SLSL	;SLASHIFIED PAREN STARTS AN ATOM!
	 JUMPE E,WBSEND
	JRST LBLOOP

;INITIALIZATION AND AUXILIARY ROUTINES FOR FW AND FL.

;SET UP F, C, IN  FOR GOING FORWARD.
LFINIT:	MOVE F,PT
	CAML F,GPT
	 ADD F,EXTRAC	;GET REAL CHAR ADDR OF CHAR AFTER PT.
	CALL GETIBP
	MOVE IN,ZV
	SUB IN,GPT	;THIS IS WHAT C WILL HAVE WHEN GAP IS REACHED.
	MOVE C,ZV
	SUB C,PT
	AOJA C,CPOPJ

;F GETS A B.P. TO THE 1ST CHARACTER OF THE GAP, TO DLDB INTO THE REGION
;BELOW THE GAP.
DWNGAP:	MOVE F,GPT
	JRST GETBP

;SET UP F, C, IN  FOR GOING BACKWARD.
LBINIT:	MOVE F,PT
	CAMLE F,GPT	;F GETS REAL CHAR ADDR +1 OF CHAR BEFORE PT.
	 ADD F,EXTRAC	
	CALL GETBP	;F SET UP FOR DLDB.
	MOVE C,PT
	SUB C,BEGV
	MOVE IN,GPT	;IN USED FOR DETECTING THAT GAP IS REACHED.
	SUB IN,BEGV	;CHECK: IF PT = GPT NOW, C WILL = IN THE FIRST TIME THRU.
	SOJA IN,CPOPJ

;DURING BACKWARD SCAN, CHECK WHETHER THE CHAR JUST REACHED WAS SLASHIFIED.
;MOVES F AND C BACK OVER THE SLASHES, LEAVES THEM AS IF 1ST OF THE SLASHES
;WAS JUST GOBBLED. IF # SLASHES IS EVEN (CHAR IS NOT SLASHIFIED),
;BIT 1.1 OF CH WILL BE 0, AND REALP WILL SKIP.
REALP:	SETZI CH,
REALP3:	SOJL C,REALP1
	CAMN IN,C
	 CALL DWNGAP
	DBP7 F
	LDB A,F
	LDB A,SKNBPT
	CAIN A,"/
	 AOJA CH,REALP3
	IBP F
REALP1:	AOJ C,
	TRNN CH,1
	 AOS (P)
	POPJ P,

;FX<Q> - PUT TEXT INTO <Q> AND DELETE IT.  FX* RETURNS THE TEXT.
;AC E HAS # CHARS BUFFER WAS MOVED (BY CRATION OF THE QREG)
FXCMD:	CALL QREGVS	;THIS CAN MAKE US SKIP!
	CALL GETARG	;TAKES ARGS LIKE X, K, ETC.
	 CALL CHK1
	SKIPA
FXCMD2:  SETO AA,		;HERE WITH CH POINTING AT QREG, ASSUMED NOT IN A QVECTOR.
	SAVE B
	SAVE C		;REMEMBER BOTH ON PDL.
	SAVE BEG	;X10 MAY MOVE BUFFER, MUST KNOW HOW MUCH.
	CALL X12	;GO PUT IN QREG (WHICH MIGHT BE AC A - SEE QREGVS)
	REST E
	SUB E,BEG	;-<# CHARS BUFFER MOVED UP>
	REST C
	REST B		;GET THE ENDS BACK,
	MOVNS E
	ADD C,E		;RELOCATE REMEMBERED PTRS.
	ADD B,E
	MOVEM B,PT
	JRST DELET1

FTYI:	CALL DISMDI	;UPDATE MODE DISPLAY (Q..J) IF NEC.
	TTYACT
	CALL TYI
	TRZE FF,COLONF	;:FI READS CHAR AND DOESN'T GOBBLE.
	 MOVEM CH,UNRCHC
	TRZN FF,SLSL	;^ FI RETURNS UNNORMALIZED CHARACTER.
	 CALL TYINRM	;NORMAL FI RETURNS NORMAILZED CHARACTER.
	MOVE A,CH
IFE TS,	CONO DIS,0
	JRST POPJ1

CNTRUP:	CALL RCH	;^^ - RETURN ASCII FOR NEXT CHAR IN CMD STRING.
	MOVEI A,(CH)
	JRST POPJ1

QUESTN:	MOVSI A,(JRST)	;? COMMAND, COMPLEMENT TRACE MODE.
	TRNE FF,COLONF
	 TRZA FF,TRACEF
	  TRCE FF,TRACEF
	   MOVSI A,(POPJ P,)
	HLLM A,TRACS
	POPJ P,

FCTLAT:	CALL GETARG	;F^@ - TAKES RANGE OF BUFFER,
	 JFCL
	CAMG B,C	;RETURNS 2 ARGS DELIMITING THAT RANGE
	 EXCH B,C	;IN NUMERIC ORDER.  2,1F^@ GIVES 1,2.
	MOVE AA,C
	MOVE A,B
	ANDCMI FF,ARG+ARG2
	JRST HOLE0

FSEXI1:	TLZ FF,CTLUF	;COME HERE TO HANDLE ^C TYPED AT TECO COMMAND READER.
	MOVEI B,100000
FSEXIT:	MOVEI A,BEG	.SEE CIRC
	.BREAK 16,(B)	;FS EXIT
	RET

SUPCMD:	MOVE B,SUPARG	;JUMP HERE IF SUPERIOR STARTS TECO AT BFR BLOCK + 8.
	SKIPE A,SUPHND	;IF TECO MACRO HANDLER SUPPLIED, RUN IT GIVING IT
	 JRST MAC5	;THE ARG OUR SUPERIOR GAVE.
	CALL GAPSLP
	SKIPLE B	;OTHERWISE, IF ARG IS POSITIVE INSURE AT LEAST THAT MUCH GAP.
	 CALL SLPGET
	MOVEI B,500000	;DO AN $X RETURN IN CASE $X'ING FROM DDT.
	JRST FSEXIT

;^K<STRING>$ -- VALRET <STRING>.
DECDMP:	CALL MEMTOP	;GET ADDR OF 1ST WD ABOVE BFR IN A.
	AOS OUT,A
	IMULI OUT,5	;GET CHAR ADDR 1ST CHAR IN THAT WD.
	SUB OUT,EXTRAC	;SINCE PUTINC WILL ADD EXTRAC.
	JSP AA,RDALTC
	 JRST DECDM1
	CALL PUTINC	;STUFF CHARS THERE, ABOVE BUFFER.
	JRST RDALTC

DECDM1:	SETZ CH,	;AFTER STRING, PUT ^@
	CALL PUTINC	;TO TELL DDT IT'S THE END.
	SETZM 1(TT)	;ZERO NEXT WD SO DDT WILL STOP FETCHING.
	HRRZ B,A
	MOVEI A,BEG	.SEE CIRC
	SKIPGE PJATY	;MAKE SURE WE DON'T CLEAR PJATY IF IT WAS ALREADY ON.
	 TRZ FF,SLSL
	.VALUE (B)	;TECO'S SUPERIOR MAY EXPECT A TO POINT TO BEG RIGHT NOW.
	TRZE FF,SLSL
	 SETZM PJATY	;^ FLAG => SUPPRESS AUTOMATIC REDISPLAY.
	POPJ P,

;FJ  --  INSERT THE CMD STRING FROM DDT IN THE BUFFER.
;IF NO STRING, INSERTS NOTHING. STRING WILL USUALLY END WITH CRLF.
FJCL:	PUSHJ P,FJCLRD	;READ IN THE COMMAND STRING,
	SKIPN GCTAB
	 POPJ P,	;NOTHING TO DO IF STRING NULL.
	MOVE A,[BP,,GCTAB]
 	MOVEI B,	;COUNT THE CHARS IN C.
FJCL1:	ILDB CH,A
	JUMPE CH,FJCL2
	CAIE CH,^M	;^M AND ^@ END THE STRING.
	AOJA B,FJCL1
	ADDI B,2	;^M COUNTS AS 2 CHARS, ^@ AS NONE.
FJCL2:	CALL GAPSLP	;GET GAP TO PT.
	CALL SLPGET	;INSERT C(B) CHARS, BP IN F FOR IDPB.
	MOVE A,[BP,,GCTAB]
FJCL3:	ILDB CH,A	;COPY THE CHARS INTO THE SPACE.
	JUMPE A,CPOPJ	;STOP BEFORE A ^@.
	IDPB CH,F
	CAIE CH,^M	;AFTER ^M, STORE ^J ANDF DONE.
	JRST FJCL3
	MOVEI CH,^J
	IDPB CH,F
	POPJ P,

;READ THE CMD STRING FROM DDT INTO GCTAB.
FJCLRD:	SETZM GCTAB	;ZERO THE GCTAB (EXCEPT LAST WD)
	.SUSET [.ROPTIO,,A]
	TLNN A,OPTCMD	;HAS SUPERIOR SAID IT HAS CMD STRING?
	 POPJ P,	;NO, RETURN AS IF READ 0 FROM IT.
	MOVE A,[GCTAB,,GCTAB+1]
	BLT A,GCTAB+GCTBL-2
	MOVEM A,GCTAB+GCTBL-1	;LAST WD NOT 0 TO STOP STORING.
	.BREAK 12,[5,,GCTAB]
	POPJ P,

;F=<QREG><STRING>$ OR <BUFFER-RANGE>F=<STRING>$
;COMPARES THE STRINGS AND RETURNS A NUMBER WHOSE SIGN IS NEGATIVE
;IF QREG OR BUFFER RANGE IS LESS;  POSITIVE, IF GREATER;  0, IF THE
;TWO STRINGS ARE EQUAL.
;IF THE VALUE IS NONZERO, ITS ABS VALUE IS 1 + THE POSITION OF THE FIRST
;DIFFERENCE; I.E., 1 IF THE FIRST CHARACTERS DIFFER.
;A STRING IS GREATER THAN ANY INITIAL SEGMENT OF IT.
;F~ (OR F^) COMPARES SIMILARLY BUT IGNORES CASE DIFFERENCES.
FAPPRX:	TRO FF,NOTF
FEQ:	TRNE FF,ARG\COLONF
	 JRST FEQ0	;NUMERIC ARG => USE BUFFER RANGE.
	CALL QREGX	;ELSE READ NAME OF QREG.
	CALL QLGET	;GET LENGTH IN AA, BP TO ILDB IN F.
	 TYPRE [QNS]
	SETZ E,		;THERE'S NO GAP TO SKIP OVER.
	JRST FEQ1

FEQ0:	CALL GETARG	;DECODE 1 OR 2 ARGS AS FOR K, T, X ETC.
	 CALL CHK1
	MOVE F,GPT
	CALL GETIBP	;E GETS BP TO LAST CHAR BEFORE GAP.
	MOVE E,F
	MOVE AA,B	;AA GETS # CHARS,
	SUB AA,C
	MOVE F,C
	CAML C,GPT
	 ADD F,EXTRAC	;IN CASE RANGE STARTS AFTER GAP.
	CALL GETIBP	;F GETS BP TO ILDB 1ST CHAR.
FEQ1:	SETZ A,		;ORDER OF STRINGS NOT KNOWN YET.
	  ;WHEN ORDER IS DETERMINED, A WILL GET 1 OR -1.
	MOVE C,AA	;REMEMBER INITIAL VALUE OF AA.
	MOVEI CH,ALTMOD
	TRZE FF,SLSL	;UPARROW SAYS USE DELIMITER OTHER THAN ALTMD.
	 CALL RCH
	MOVEM CH,INSDLM	;REMEMBER THE DELIMITER.
	TRZ FF,ARG+COLONF+ARG2
;GET THE NEXT CHAR FROM THE STRING ARG.
FEQLUP:	CALL RCH	;READ IT.
	SKIPE SQUOTP	;IF NOT QUOTED OR DELIM-PROTECTED,
	 JRST FEQLU1
	CAMN CH,INSDLM	;SEE IF IT IS THE DELIMITER.
	 JRST FEQEND
FEQLU1:	JUMPN A,FEQLUP	;INEQUALITY SEEN => JUST SKIPPING TO END OF STRING ARG NOW.
	SOJL AA,FEQEN1	;END OF QREG BUT NOT END OF STRING ARG
		;=> QREG IS LESS.
	CAMN E,F	;ELSE GET NEXT CHAR OF QREG OR BUFFER.
	 CALL FEQGAP	;SKIP OVER GAP IF HAVE REACHED IT.
	ILDB B,F
	CAIN B,(CH)	;CHARS EQUAL => NO DECISION YET,
	 JRST FEQLUP	;KEEP LOOKING.
	TRNN FF,NOTF	;NO MATCH => IF F^, TRY IGNORING CASE.
	 JRST FEQNE
	CAIL B,"A+40
	 CAILE B,"Z+40
	  CAIA
	   SUBI B,40
	CAIL CH,"A+40
	 CAILE CH,"Z+40
	  CAIA
	   SUBI CH,40
	CAMN B,CH
	 JRST FEQLUP
FEQNE:	CAIL B,(CH)	;QREG OR BUFFER GREATER =>
	 AOJA A,FEQLUP	;RETURN POSITIVE; ELSE NEGATIVE.
FEQEN1:	SOJA A,FEQLUP	;EITHER WAY, SKIP OVER REST OF STRING ARG.

FEQEND:	JUMPN A,FEQEN2	;END OF STRING ARG: RETURN ANSWER IF KNOWN.
	SOJL AA,POPJ1	;ELSE QREG ENDING NOW TOO => EQUAL.
	AOJ A,		;STRING ARG FINISHED, OTHER NOT =>
		;STRING ARG IS SMALLER.
FEQEN2:	SUB C,AA	;INITIAL VALUE OF AA - CURRENT
	IMUL A,C	;GIVES 1+POSITION OF 1ST DIFFERENCE.
	JRST POPJ1

FEQGAP:	MOVE F,GPT 	; F GETS BP TO ILDB 1ST CHAR AFTER GAP.
	ADD F,EXTRAC
	JRST GETIBP

;F*<STRING>$ -- NO-OP.
;[ ;MAINLY USEFUL FOR F*^]^X$
FNOOP:	JSP AA,RDALTC
	 POPJ P,
	JRST FNOOP

;FV<STRING>$  --  DISPLAY <STRING>
FVIEW:	TROE FF,COLONF	;:FV DOESN'T START AT TOP OF SCREEN.
	 JRST FVIEW1	;AND IT DOES TYPEOUT INSTEAD OF DISPLAY.
	CALL DISINI
	MOVEI F,CHCT
	JRST FTYLUP

;FT<STRING>$  --  TYPE <STRING>
FTYPE:	TRNE FF,SLSL	;^ FT TYPES STRING IN ECHO AREA.
	 JRST [	TRNN FF,COLONF	;^:FT DOES DOES SO ONLY IF NO INPUT AVAILABLE.
		 JRST FTYECH
		SKIPGE A,UNRCHC
		 .LISTEN A,
		JUMPN A,FNOOP	;THERE'S INPUT; IGNORE STRING INSTEAD TYPING IT.
		JRST FTYECH]
	TRZE FF,COLONF	;:FT STARTS AT TOP OF SCREEN.
	 CALL DISTOT
FVIEW1:	MOVEI F,TYOA
FTYLUP:	CALL RCH
	SKIPN SQUOTP
	 CAIE CH,33
	  CAIA
	   JRST FTEND
FTYCHR:	ANDI CH,177
	CALL (F)
	JRST FTYLUP

FTEND:	TRNE FF,COLONF
	 JRST DISCLG
	JRST DISFLS

FTYEC1:	CALL FSECO2
FTYECH:	CALL RCH
	SKIPN SQUOTP
	 CAIE CH,33
	  JRST FTYEC1
	RET

;FS LISTEN$ - RETURN NONZERO IFF INPUT IS AVAILABLE.
;IF NONZERO ARG, THEN IF NO INPUT AVAILABLE PRINT IT AS ASCII CHAR IN ECHO AREA.
FSLISN:	SKIPGE A,UNRCHC
	 .LISTEN A,
	JUMPN A,VALRTA	;RETURN NONZERO IF INPUT IS AVAILABLE.
	TRZE FF,ARG	;OTHERWISE, IF THERE'S AN ARG,
	 SKIPN RGETTY
	  JRST POPJ1
	CALL FSECOT	;TYPE IT IN ECHO MODE (ON DISPLAYS ONLY)
	MOVE TT,TTYOPT	;AND ON DATAPOINTS, BS OVER IT.
	TLNE TT,%TOOVR
	 JRST POPJ1
	MOVEI B,^H
	AOS (P)

;FS ECHO DISPLAY$ - OUTPUT 1 CHAR IN DISPLAY MODE (^P IS SPECIAL) TO THE ECHO AREA.
;ARG IN B; CLOBBERS CH.
FSECDS:	SKIPGE CH,NELNS
	 SETCM CH,NELNS
	JUMPE CH,CPOPJ	;DO NOTHING IF THERE'S NO ECHO AREA.
	.IOT ECDISC,B
	JRST FSECO5

FSIMAG:	.IOT SIOC,B	;FS IMAGE OUT$ - SUPERIMAGE OUTPUT OF 1 CHAR.
	JRST FSECO5

;OUTPUT CHAR TO ECHO AREA;  ^M COMES OUT AS STRAY CR.
FSECO2:	SKIPE RUBENC	;IF PREVIOUS COMMAND WANTED A CHAR TYPED BY US, TYPE IT.
	 CALL RUBEND
	SYSCAL IOT,[MOVEI ECHOC ? CH ? 5000,,%TJECH]
	 .LOSE 1400
	JRST FSECO5

;FS ECHO OUT - OUTPUT ARG IN ECHO MODE (WRITE-ONLY)
FSECOT:	MOVE CH,B	;OUTPUT CHAR TO ECHO AREA;  ^M COMES OUT AS CRLF.
FSECO1:	SKIPE RUBENC	;IF PREVIOUS COMMAND WANTED A CHAR TYPED BY US, TYPE IT.
	 CALL RUBEND
	.IOT ECHOC,CH	;ARG IS CHAR IN CH; OUTPUT IN ECHO MODE.
FSECO5:	SETOM RROVPO	;IN CASE IN ^R MODE,
	SETOM RROHPO	;MAKE SURE CURSOR GETS REPOSITIONED.
	RET

;READ 1 CHAR OF STRING ARG, TURNING UNQUOTED DOLLARSIGNS TO ALTMODES.
;AT END OF ARG, FAIL TO SKIP.
RDALTC:	PUSHJ P,RCH
	SKIPE SQUOTP
	 JRST 1(AA)
	CAIN CH,ALTMOD
	JRST (AA)
	CAIN CH,"$
	MOVEI CH,ALTMOD
	JRST 1(AA)

;^V WITH ARG -- PUSH ARGUMENT ON RING BUFFER OF PT. RETURNS NO VALUE.
;NORMALLY, DOESN'T PUSH IF ARG SAME AS CURRENT TOP. :^V PUSHES IN ANY CASE.
FSPSPT:	MOVE C,FSPSPP	;GET RING BUFFER POINTER.
	LDB CH,C	;GET LAST VALUE PUSHED.
	TRZE FF,COLONF	;UNLESS THIS IS :^V,
	 JRST FSPSP1
	CAMN B,CH
	 RET		;DON'T PUSH THE SAME THING TWICE IN A ROW.
FSPSP1:	CAMN C,[4400,,FSPSPB+FSPSPL-1]
	 SUBI C,FSPSPL	;AT END, RING AROUND TO BEGINNING.
	IDPB B,C
	MOVEM C,FSPSPP
	RET

;^V COMMAND -- WITHOUT ARG, POP TOP OF RING BUFFER OF PT INTO PT;
;THEN RETURN WHAT REMAINS ON TOP OF RING BUFFER (IF THAT VALUE IS
;PUT IN Q..I, THE TOP-LEVEL WILL AVOID PUSHING WHEN IT IS NEXT ENTERED).
;:^V RETURNS VALUE ON TOP OF RING BUFFER.
;^V WITH ARG PUSHES - SEE ABOVE.
CTLV:	TRNE FF,ARG
	 JRST FSPSPT
POPPT:	MOVE C,FSPSPP
	MOVE A,(C)	;GET LAST THING PUSHED.
	TRZE FF,COLONF
	 JRST POPJ1	;:^V JUST RETURNS VALUE ON TOP OF RING BUFFER.
	ADD A,BEG	;PREPARE TO SET PT FROM IT.
	SUBI C,1	;DECREMENT THE RING BUFFER POINTER.
	CAMN C,[4400,,FSPSPB-1]
	 ADDI C,FSPSPL
	MOVEM C,FSPSPP
	MOVE B,A	;TAKE THE VALUE JUST POPPED.
	CALL CHK	;ERR OUT IF IT ISN'T INSIDE THE BUFFER.
	MOVEM A,PT	;JUMP THERE IF IT IS.
	MOVE A,(C)	;RETURN WHAT IS NOW AT THE TOP.
	JRST POPJ1

;<N>^Z -- INSERT <N> RANDOM LETTERS BEFORE PT.
;^Z WITHOUT ARG -- RETURN A RANDOM NUMBER.
RANDOM:	ARGDFL
	JUMPE B,RNDNUM
	JUMPLE B,CPOPJ
	PUSHJ P,GAPSLP
	CALL SLPGET	;INSERT C(B) CHARS, RET. BP. IN F.
RNDLUP:	MOVSI A,123467
	FMPB A,RDMNMS
	IDIVI A,26.
	MOVEI CH,"A(AA)
	IDPB CH,F
	SOJG B,RNDLUP
	POPJ P,

RNDNUM:	MOVSI A,132476
	FMPB A,RDMNMS
	TLZ A,400000
	JRST POPJ1

;FC - TAKES ARGS LIKE K, CONVERTS AREA OF BUFFER TO LOWER CASE
;PT GOES BEFORE THE SAME CHARACTER BEFORE AND AFTER.
;^ FC CONVERTS TO UPPER CASE.
LOWCON:	SAVE FF		;DON'T LET GETARG USE OR CLOBBER COLONF.
	ANDCMI FF,COLONF
	PUSHJ P,GETARG
	 CALL CHK1
	REST A
	ANDI A,COLONF
	IORI FF,(A)
	MOVE IN,C
	SUB B,IN
	MOVE D,PT
	MOVEM IN,PT	;WANT GAP THERE SO PUT PT THERE
	CALL GAPSLP	;AND PUT GAP AT PT.
	MOVE F,IN
	CALL GETIBP	;GET BP FOR IDPB INTO GAP.
LOWCO1:	SOJL B,LOWCO4
	PUSHJ P,GETINC
	TRNE FF,SLSL
	 JRST LOWCO5
	CAIG CH,"Z
	CAIGE CH,"A
	 JRST LOWCO2
LOWCO6:	XORI CH,40
LOWCO2:	IDPB CH,F	;PUT CHAR INTO FRONT OF GAP,
	MOVEM IN,GPT	;ADVANCE THE GAP.
	JRST LOWCO1

LOWCO5:	CAIG CH,40+"Z	;CONVERTING TO UPPER CASE:
	CAIGE CH,40+"A
	 JRST LOWCO2
	JRST LOWCO6	;LOWER CASE CHARS GET SHIFTED,

LOWCO4:	MOVEM D,PT
	POPJ P,

NEWAS:	ARGDFL		;DOLLARSIGN COMMAND.
	CALL FSCASF	;UNLESS IN -1$, NO CASE SHIFT OR LOCK.
	SKIPGE B
	MOVEI IN,"/	;-1$, USE / AS THE CASE-SHIFT, NO CASE-LOCK.
	JRST FSCAS1

FSCASV:	MOVE A,CASNRM	;COMPUTE VALUE FOR FS CASE TO RETURN.
	SKIPL CH,CASSFT	;IF THERE'S A CASE-SHIFT, PUT IT IN BUFFER..
	 CALL TYOMGS
	SKIPL CH,CASLOK	;SAME FOR CASE-LOCK.
	 CALL TYOM
	JRST POPJ1

FSCASE:	TRNN FF,ARG	;FS CASE -- NO ARG => RETURN STATUS INFO.
	 JRST FSCASV
	ARGDFL
	CALL FSCASF	;READ THE STRING ARG WITH NO CASE SHIFT OR CASE LOCK.
	CALL RCH	;READ WHAT MIGHT BE THE CASE-SHIFT.
	CAIN CH,ALTMOD	;NULL STRING ARG => NEITHER.
	 JRST FSCAS1	;(NOTE IN, OUT HOLD -1)
	MOVEI IN,(CH)	;ELSE 1ST CHAR OF ARG IS CASE-:SHIFT.
	CALL RCH	;AND THERE MAY BE A CASE-LOCK.
	CAIN CH,ALTMOD
	 JRST FSCAS1	;NO MORE CHARS IN ARG => NO CASE-LOCK.
	MOVEI OUT,(CH)
FSCAS0:	JSP AA,RDALTC	;IGNORE REST OF STRING ARG.
	 CAIA
	JRST FSCAS0
FSCAS1:	CAMN IN,OUT	;TRYING TO MAKE SAME CHAR SHIFT & LOCK?
	 SETO IN,	;JUST USE IT AS LOCK.
	MOVEM B,CASNRM	;SIGN OF ARG IS NORMAL INPUT CASE.
	MOVEM B,CASE	;SET CURRENT CASE TO NEW NORMAL.
	ANDI B,1
	MOVEM B,CASDIS	;ARG ODD => FLAG ON OUTPUT.
	MOVEM IN,CASSFT	;THEN STORE AWAY NEW SHIFT AND LOCK CHARS,
	MOVEM OUT,CASLOK
	MOVE TT,[CALL RCHSFT]	;ACTUALLY MAKE THE NEW CASE-SHIFT
	SKIPL IN		;(IF ANY)
	 EXCH TT,RCHDTB(IN)	;ACT LIKE ONE.
	MOVEM TT,RCHSFD		;MAKE SURE CAN UNDO THAT EXCH.
	MOVE TT,[CALL RCHLOK]
	SKIPL OUT		;SIMILAR FOR THE NEW CASE-LOCK.
	 EXCH TT,RCHDTB(OUT)
	MOVEM TT,RCHLOD
	POPJ P,

;CAUSE THE CASE-SHIFT AND CASE-LOCK, IF ANY, TO BECOME NORMAL.
;CHARACTERS AGAIN, WITH NO CASE-SHIFT OR -LOCK IN EXISTENCE.
;SETOM'S IN, OUT. CLOBBERS TT, TT1.
FSCASF:	MOVE TT,RCHLOD	;FIRST TURN THE OLD SHIFT AND LOCK CHARS
	SKIPL TT1,CASLOK ;INTO NORMAL CHARS.
	 MOVEM TT,RCHDTB(TT1)
	MOVE TT,RCHSFD
	SKIPL TT1,CASSFT
	 MOVEM TT,RCHDTB(TT1)
	SETOB IN,CASSFT	;THEN SAY THERE ARE NONE.
	SETOB OUT,CASLOK
	POPJ P,

;FQ<Q> - RETURN LENGTH OF TEXT IN <Q>, OR -1 IF NOT TEXT.
QLEN:	PUSHJ P,QREGX
	PUSHJ P,QLGET0
RETM1A:	SKIPA A,[-1]
	MOVE A,AA
	JRST POPJ1

;Q<Q> - RETURN CONTENTS OF QREG <Q> AS A NUMBER.
QREG:	AOS (P)
	JRST QREGX

;%<Q> - INCREMENT <Q>, RETURN NEW VALUE.
PCNT:	CALL QREGS	;READ QREG NAME, GET IDX IN CH.
	AOS A,(CH)
	JRST POPJ1

;U<Q> - PUT NUMERIC ARG IN <Q>. 2 ARGS => USE 2ND, RETURN 1ST.
USE:	TRZN FF,ARG
	 TYPRE [WNA]
	ARGDFL
	CALL QREGS
USE1:	MOVEM B,(CH)
	CAIN CH,$QBUFR
	 CALL BFRSET
	TRZN FF,ARG2
	 POPJ P,
	MOVE A,C
	JRST POPJ1

;<ARG>FP RETURNS AN INDICATION OF <ARG>'S DATA TYPE:
;-4 => NUMBER (NOT IN RANGE FOR PURE OR IMPURE STRING SPACE)
;-3 => PURE OBJECT WITH MEANINGLESS HEADER
;-2 => IMPURE OBJECT WITH MEANINGLESS HEADER
;-1 => DEAD BUFFER
;0 => LIVING BUFFER
;1 => Q-VECTOR.
;100 => PURE STRING
;101 => IMPURE STRING
FDATTY:	MOVNI A,4
	TRZN FF,ARG
	 TYPRE [WNA]
	TLZN B,400000	;MUST BE CLOSE TO 400000,, TO BE ANYTHING BUT A NUMBER.
	 JRST POPJ1
	MOVE F,B
	CAML B,BFRBOT	;IS IT IN RANGE FOR IMURE SPACE?
	 JRST [	CAMGE B,[LHIMAX*5*2000]	;NO, WHAT ABOUT PURE SPACE?
		 CAMGE B,[LHIMIN*5*2000]
		  JRST POPJ1		;NO, ORDINARY NUMBER
		AOJA A,FDATT2]		;YES, SEE WHAT KIND OBJECT (A _ -3)
	ADD F,QRBUF	;ADDR'S IN IMPURE SPACE ARE REL. TO QRBUF.
	MOVNI A,2
;A HAS -2 FOR IMPURE SPACE, -3 FOR PURE SPACE.
;SEE IF OBJECT IS STRING, BUFFER OR NOTHING.
FDATT2:	CALL GETIBP
	ILDB AA,F
	CAIN AA,QRSTR	;STRING => RETURN 100. OR 101.
	 JRST [	ADDI A,103.
		JRST POPJ1]
	CAIE AA,QRBFR
	 JRST POPJ1	;NOTHING => RETURN -3 OR -2.
	CALL QLGET4	;BUFFER: IS IT STILL ALIVE?
	ADDI AA,4	;AA GETS BUFFER BLOCK ADDR, OR 0 IF DEAD BUFFER.
	JUMPE AA,RETM1A	;RETURN -1 IF DEAD.
	MOVEI A,0
	MOVE B,(AA)
	TLNE B,MFQVEC
	 AOS A		;IF Q-VECTOR, RETURN 1, ELSE 0.
	JRST POPJ1

QGET3:	TRZ FF,ARG2\ARG2
	JRST QGET4

;G<Q> COMMAND -- INSERT QREG <Q> IN BUFFER BEFORE PT.
;<M>,<N>G<Q> -- GET RANGE OF CHARS <M>,<N> FROM QREG.
;FS INSLEN$ IS SET TO # CHARS INSERTED.
QGET:	CALL QREGX
QGET4:	CALL QLGET0
	 JRST [	MOVE B,A ? JRST BAKSL1]
	TRNN FF,ARG2	;(IF NO ARGS, B AND C MAY BE RANDOM. PREVENT 2<1 ERROR).
	 SETZB B,C
	CAMLE B,AA	;MAKE SURE ARGS, IF ANY, ARE WITHIN RANGE
	 MOVE B,AA	;[0 , <LENGTH OF STRING>]
	SKIPGE C
	 SETZ C,
	CAMLE C,B	;MAKE SURE ARGS ARE IN INCREASING ORDER.
	 TYPRE [2%1]
	TRNN FF,ARG2
	 SKIPA B,AA	;IF NO ARGS, # CHARS TO INSERT IS LENGTH OF QREG.
	  SUB B,C	;IF ARGS, IT IS DIFFERENCE BETWEEN ARGS.
	MOVEM B,INSLEN
QGETI:	SAVE A
	CALL GAPSLP
	CALL SLPGET	;INSERT SPACE, LEAVE BP. IN F.
	MOVE IN,F
	REST A
	CALL QLGET0	;IN CASE QREG IS BUFFER AND WAS MOVED BY SLPGET,
	 .VALUE		;RECOMPUTE THE BYTE PTR TO IT.
	JUMPE C,QGET1	;IF NOT STARTING AT BEGINNING OF STRING,
	CALL GETCA	;MAKE B.P. -> ARG1'TH CHAR OF QREG.
	ADD F,C
	CALL GETBP
QGET1:	JUMPE B,CPOPJ
	HLRZ CH,F
	HLRZ E,IN
	CAIN CH,010700
	 CAIE E,010700	;IF WE'RE AT A WORD BOUNDARY IN BOTH QREG AND BUFFER,
	  JRST QGET2
	CAIGE B,5	;AND TRANSFERING AT LEAST 1 WORD,
	 JRST QGET2
	IDIVI B,5	;DO A BLT TO AVOID LOSING LOW BITS.
	MOVEI CH,1(IN)
	HRLI CH,1(F)
	ADD F,B		;AND UPDATE BOTH B.P.'S TO POINT AFTER WHAT WE'RE BLT'ING.
	ADD IN,B
	BLT CH,(IN)
	MOVE B,E	;# CHARS NOT TRANSFERED BY THE BLT.
QGET2:	ILDB CH,F
	IDPB CH,IN
	SOJG B,QGET2
	POPJ P,

;ROUTINES TO READ IN SUFFIX QREG ARGS:

;THERE ARE SEVERAL TYPES OF SUFFIX QREGS, AND VARIOUS ROUTINES ALLOW CERTAIN SUBSETS.
;A LETTER (OR DOTS AND A LETTER, OR A ^R OR ^^ NAME) NAMES A FIXED LOCATION IN TECO.
;AN EXPRESSION IN PARENTHESES IS A READ-ONLY QREG "CONTAINING" THE VALUE OF THE EXP.
;A * IS A WRITE-ONLY QREG AND WHAT IS WRITTEN IN IT IS THE COMMAND'S VALUE.
;:<Q>(<IDX>) WHERE <Q> IS A QREG CONTAINING A Q-VECTOR, IS A SUBSCRIPTING EXPRESSION.
;   IN THIS CASE, THE QREG IS ONE WORD IN THE QVECTOR.
;<NAME> IS A LONG-NAME QREG.  THE NAME IS LOOKED UP IN THE SYMBOL TABLE
;   (A QVECTOR IN ..Q) WITH FO TO FIND THE WORD IN THAT QVECTOR HOLDING THE VALUE.

;THE REASON THERE ARE SEVERAL ROUTINES IS THAT ONLY READING-ONLY COMMANDS
;ALLOW (-) QREGS, AND ONLY WRITING-ONLY COMMANDS ALLOW *.
;QREGS IS THE BASIC ROUTINE (NEITHER * NOR PARENS), QREGX ALLOWS PARENS,
;AND QREGVS ALLOWS *.

;THE ROUTINES HAVE SIMILAR VALUE CONVENTIONS:
;A CONTAINS THE CONTENTS OF THE QREG,
;CH CONTAINS ITS ADDRESS (BAKTAB, FOR PAREN-QREGS WHICH CAN'T BE WRITTEN)
;AA CONTAINS AN INDICATION OF WHICH TYPE OF NAME WAS READ.
 ;NORMALLY, IT IS ZERO.  FOR :<Q>(<IDX>), IT IS POSITIVE;  FOR NAME, IT IS NEGATIVE.
   ;IN EITHER OF THOSE TWO CASES, THE RH POINTS AT THE BUFFER BLOCK OF THE QVECTOR
   ;CONTAINING THE SLOT.  THAT IS SO THAT COMMANDS LIKE :I CAN TELL IF THAT QVECTOR
   ;IS RELOCATED AND CORRECT ACCORDINGLY (SEE QREGVA).
;IN, FOR A NAME QREG (AA IS NEGATIVE), CONTAINS A TECO STRING POINTER TO THE
;INTERNED NAME OF THE QREG AS FOUND IN THE SYMBOL TABLE.

;READ EITHER A QREG NAME OR AN EXPRESSION IN PARENS, WHOSE VALUE
;IS USED AS THE "CONTENTS" OF THE QREG.  CONTENTS RETURNED IN A.  CLOBBERS ALL ACS
;EXCEPT B,C.  ALSO ALLOWS SUBSCRIPTED QVECTORS, LIKE QREGS.
QREGX:	CALL SKRCH
	CAIE CH,"(
	 JRST QREGS0
	TRO FF,NOTF	;MARK THIS ( AS BEING FROM QREGX.
	JRST OPEN	;SAVE ARGS, ETC;  WILL COME BACK WHEN ")" IS SEEN

QREGXR:	MOVE B,A	;TO HERE.
	EXCH A,NUM	;A GETS VALUE WITHIN THE PARENS.  RESTORE SAVED ARG.
	TRNE CH,ARG2
	 MOVEM AA,SARG	;AND SAVES "SECOND" ARG, IF ANY.
	MOVE C,SARG
	TRZ FF,ARG\ARG2\COLONF\SLSL
	IORI FF,(CH)
	SETZ AA,		;RETURN AA AS 0 TO SHOW THIS WASN'T A SUBSCTRIPTED QREG.
	MOVEI CH,BAKTAB		;MAKE SURE, IF CALLER TRIES TO WRITE OUR QREG, NO HARM DONE.
	RET

;HERE TAKE CARE OF "SIMPLE" (..A OR ...^RX) TYPE QREG NAMES.
QREGXX:	SETZB A,AA
	CALL QNMGE2	;HERE FROM QREGX OR QREGS IF IT'S AN ORDINARY QREG NAME AFTER ALL.
	 TYPRE [IQN]
QREGA1:	MOVE A,(CH)
	POPJ P,

;HERE TO READ EITHER QREG NAME OR "*" MEANING RETURN AS VALUE INSTEAD OF SETTING QREG.
;ASSUMES -1(P) IS CALLER'S RETURN ADDRESS, AND AOS'S IT SO CALLER RETURNS THE VALUE.
QREGVS:	CALL SKRCH		;HERE TO ALLOW EITHER * OR SUBSCRIPTING.
	CAIE CH,"*
	 JRST QREGS0
	MOVEI CH,A		;SUPPLY AC A AS ADDR OF "QREG".
	SETZB A,AA		;SAY ITS VALUE IS 0 (FOR THINGS LIKE ^ X).
	AOS -1(P)		;MAKE OUR CALLER SKIP-RETURN
	RET

;READ IN A QREG NAME, ALLOWING SUBSCRIPTING (AS IN Q:.Q(10) = 10TH ELT OF Q-VECTOR IN .Q)
;ON RETURN FROM THIS OR ANY OTHER QREG-READING ROUTINE, IF AA IS NONZERO
;THEN THE QREG WAS SUBSTRIPTED, AND AA POINTS AT THE BUFFER BLOCK OF THE Q-VECTOR.
;WE ALSO HANDLE "LONG QREG NAMES" AS IN QFOO, SINCE THAT IS IMPLEMENTED
;BY MEANS OF INDEXING (INTO THE SYMBOL TABLE QVECTOR).
QREGS:	CALL SKRCH
QREGS0:	CAIN CH,ALTMOD
	 JRST QREGN		;CHECK FOR Q$FOO$ CONSTRUCT.
	CAIE CH,":
	 JRST QREGXX
	CALL QREGX		;FIRST, READ THE QREG WHICH IS THE Q-VECTOR TO SUBSCRIPT.
	SAVE A			;SAVE IT AS IF IN A (.
	SAVE [0]
	SAVE LEV
	MOVEM P,LEV
	CALL QREGX		;THEN READ THE VALUE OF THE INDEX.
	MOVE IN,A
	MOVEI T,.+2
	JRST CLOSE2		;POP STUFF OFF, LEAVING Q-VECTOR IN A.
	MOVE F,A
	CALL QBGET1		;GET BUFFER-BLOCK ADDR IN AA.
	SKIPN AA
	 TYPRE [QNB]
	IMULI IN,5		;GET VIRTUAL CHAR ADDR INSIDE Q-VECTOR OF DESIRED WORD.
	ADD IN,MFBEG(AA)
	TLZ IN,MFBBTS
	CAML IN,MFBEGV(AA)	;COMPLAIN IF NOT INSIDE VIRTUAL BOUNDS.
	 CAML IN,MFZV(AA)
	  TYPRE [NIB]
	CAML IN,MFGPT(AA)
	 ADD IN,MFEXTR(AA)	;TURN INTO REAL ADDRESS.
	IDIVI IN,5
	MOVE A,(IN)		;FETCH CONTENTS OF WORD,
	MOVE CH,IN		;AND ALSO RETURN ITS ADDRESS, FOR "U", ETC.
	RET

;COMMANDS THAT DO CONSING, AFTER CALLING QREGVS, SHOULD, IF AA IS NONZERO,
;DO A JSP TT,QREGVA TO WORRY ABOUT CHANCE THAT CONSING WILL MOVE THE Q-VECTOR.
;QREGVA SAVES STUFF, CALLS BACK TO DO THE WORK, THEN FIXES UP AND RETURNS TO COMMAND'S CALLER.
QREGVA:	SUB CH,MFBEGV(AA)	;IF SO SPECIAL HAIR NEEDED, SINCE OUR STRING CONSING
	SAVE AA			;COULD SHIFT THE QVECTOR AND INVALIDATE CH.
	SAVE CH			;SO REMEMBER QVECTOR, AND OFFSET IN IT;
	MOVEI CH,A		;DO THE CONSING PUTTING VALUE IN A.
	CALL (TT)		;CALL THE MAIN BODY OF OUR CALLER.
	REST CH			;FIND OUT WHERE THE SELECTED WORD IS NOW LOCATED
	REST AA
	ADD CH,MFBEGV(AA)
	MOVEM A,(CH)		;AND STORE VALUE IN IT.
	RET

;HERE AFTER SEEING A QREG NAME STARTS WITH AN ALTMODE, AS IN QFOO.
QREGN:	SAVE B
	SAVE C			;FO CLOBBERS ALL ACS
	SAVE FF
	MOVE A,QRB..
	MOVE A,.QSYMT(A)	;GET THE PTR TO THE QVECTOR USED AS SYMBOL TABLE.
	MOVE F,A
	CALL QBGET1
	SAVE AA
	TRZ FF,COLONF\ARG\ARG2\SLSL
	CALL FOCMD0		;DO FO TO READ IN THE "FOO" AND SEARCH SYMBOL TABLE.
	 JFCL			;PUTS VAL IN A AND ADDR OF S.T.E. IN IN.
	MOVEI CH,1(IN)		;CH GETS ADDR OF SLOT IN QVECTOR HOLDING THE VALUE.
	MOVE IN,(IN)		;IN GETS THE STRING WHICH IS THE FULL NAME.
	REST AA			;RETURN IN AA THE BUFFER BLOCK OF THE QVECTOR
	TLO AA,400000
	REST FF			;(FOR RELOCATION HACKERY IN QREGVA FOR :I AND X).
	REST C
	JRST POPBJ

;SKIP IF CHAR IN CH IS A LETTER OR A DIGIT. ALSO, CONVERT LOWER
;CASE LETETRS TO UPPER CASE.
QRVTST:	CAIL CH,"0
	CAILE CH,"9
	CAIA
	JRST POPJ1
	CAIL CH,"A
	CAILE CH,"Z
	CAIA
	JRST POPJ1
	CAIL CH,"A+40
	CAILE CH,"Z+40
	POPJ P,
	SUBI CH,40
	JRST POPJ1

;READ IN A QREG NAME, AND RETURN IN CH THE ADDRESS OF THE QREG.
;CLOBBERS A AND CH.
QNMGET:	SETZI A,
	CALL SKRCH
QNMGE2:	CAIN CH,".
	 AOJA A,QNMGET+1
	CAIN CH,^R
	 JRST QNMGE3
	CAIN CH,^^
	 JRST QNMGE4
	CALL QRVTST
	 RET
	CAILE A,NQSETS-1
	 RET
	AOS (P)
QNMGE1:	MOVEI CH,-"0(CH)
	CAILE CH,9
	 SUBI CH,"A-"9-1
	ADD CH,QRB(A)
	RET

QNMGE3:	LSH A,7		;HANDLE QREG NAME CONTAINING "^R":
QNMGE5:	SETZM BRCUAV	;[ ;IF A ^]^V IS DONE, BRCUAV WILL BECOME NEGATIVE.
	CALL SKRCH	;READ IN NAME OF ^R-MODE CHARACTER
	SKIPGE BRCUAV	;[ ;THE POINT OF THIS IS THAT ^]^V TRUNCATES TO 7 BITS,
	 HRRZ CH,BRCUAV	;BUT WE HAVE TO GET BACK THE 9-BIT VALUE.
	XOR CH,A	;GET THE SPECIFIED CHAR. IN TV CHAR SET.
	ANDI CH,777
	ADDI CH,RRMACT	;THE "QREG" IS THE RRMACT ENTRY FOR THE CHARACTER.
	JRST POPJ1

QNMGE4:	LSH A,7		;HANDLE A QREG NAME STARTING WITH "^^":
	XORI A,100	;JUST LIKE "^R", BUT COMPLEMENT THE 100 BIT.
	JRST QNMGE5	;SO Q^^X=Q^R^X, AND Q^^J=Q^R<LF> (BUT Q^^J DOESN'T END A LINE).

;CH HAS QREG IDX; DON'T SKIP IF QREG NOT STRING.
;ELSE SKIP WITH AA HOLDING # CHARS OF TEXT IN STRING (NOT INCLUDING HEADER),
;F HOLDING A B.P. TO ILDB THE TEXT.
QLGET:	MOVE A,(CH)
QLGET0:	CAML A,[SETZ+LHIMAX*5*2000]
	 RET		;CAN'T  BE EITHER PURE OR IMPURE SPACE.
QLGET1:	MOVE F,A
	TLZ F,400000	;FLUSH THE SIGN BIT (SET IN ALL POINTERS)
	CAMGE F,[LHIMIN*5*2000]	;IF IT'S IMPURE SPACE,
	 ADD F,QRBUF	;POINTER IS RELATIVE TO START OF IMPURE SPACE.
QLGET2:	PUSHJ P,GETBP
QLGET3:	LDB AA,F
	CAIN AA,QRBFR
	 JRST QLGET5
	CAIE AA,QRSTR
	 RET
	AOS (P)
QLGET4:	ILDB AA,F
	ILDB TT,F
	ROT TT,7
	IOR AA,TT
	ILDB TT,F
	LSH TT,14.
	IOR AA,TT
	SUBI AA,4
	RET

;HANDLE THE CASE IN WHICH QLGET IS CALLED ON QREG HOLDING A BUFFER.
QLGET5:	CALL QLGET4	;GET ADDR OF HEADER, MINUS 4, IN AA.
	ADDI AA,4
	JUMPE AA,CPOPJ	;GIVE 0 AS LENGTH OF DEAD BUFFER
	SAVE T
	SAVE B
	MOVEI B,(AA)	;IF THIS BUFFER IS CURRENT, THE VALUES IN ITS HEADER
	CAMN B,BFRPTR	;MAY BE  OUT OF DATE. UPDATE THEM BY RESELECTING.
	 CALL NEWBFR
	MOVE F,MFGPT(AA)
	CAMG F,MFBEGV(AA)
	 JRST QLGET6
	CAMGE F,MFZV(AA) ;IF THE GAP IS WHERE IT WILL DO HARM, THEN MOVE IT TO WHERE IT WON'T.
	 JRST [	SAVE BFRPTR	;PUSH CURRENT BUFFER,
		MOVEI B,(AA)	;SELECT THE ONE BEING QLGET'ED
		CALL NEWBFR
		SAVE PT
		MOVE F,ZV
		MOVEM F,PT	;PUT PT WHERE WE WANT THE GAP TO BE
		CALL GAPSLP	;AND MOVE THE GAP THERE.
		REST PT
		REST B		;POP THE SELECTED BUFFER.
		CALL NEWBFR
		JRST QLGET6]
QLGET6:	REST B
	MOVE F,MFBEGV(AA)	;GET VIRT ADDR OF BEGINNING OF BUFFER
	MOVE T,MFZV(AA)
	SUB T,F			;GET LENGTH OF BUFFER.
	CAML F,MFGPT(AA)
	 ADD F,MFEXTR(AA)	;CONVERT VIRT ADDR TO REAL ADDR.
	MOVE AA,T
	REST T
	AOS (P)
	JRST GETIBP		;RETURN IN F, B.P. TO ILDB BUFFER.

;[<Q> - PUSH <Q> ONTO QREG PDL.
OPENB:	CALL QREGX		;READ THE QREG VALUE IN A AND ADDR IN CH.
	SAVE CH
	SKIPLE AA		;IF THIS QREG IS REALLY AN ELT OF A QVECTOR,
	 TYPRE [IQN]		;AUTO-UNWIND WOULD LOSE, SO COMPLAIN.
	SKIPGE AA
	 MOVE CH,IN		;FOR NAME QREGS, PUSH INTERNED NAME-STRING AS QREG ADDR.
	MOVE AA,PF
	CAMN AA,PFTOP		;CHECK FOR OVERFLOW BEFORE WRITING ANYTHING.
	 TYPRE [QRP]
	PUSH AA,A		;THEN PUSH OLD CONTENTS
	CALL OPENB3		;GO PUSH ADDR OF QREG (FOR UNWINDING) AND RETURN.
	REST CH			;GET BACK ACTUAL LOCATION OF QREG
	TRNN FF,ARG		;AND IF WE HAVE ARG, STORE ARG INTO IT.
	 RET
	JRST USE1		;DO IT VIA USE SO THAT STORING INTO ..O WORKS.

OPENB2:	MOVE AA,PF
	CAMN AA,PFTOP
	 JRST OPENB1		;DETECT OVERPUSH BEFORE A PDLOV INT HAPPENS.
	PUSH AA,(CH)
OPENB3:	PUSH AA,CH
	MOVEM AA,PF
	POPJ P,

;]<Q> - POP FROM QREG PDL INTO <Q>.  ]* POPS AND RETURNS AS VALUE.
CLOSEB:	CALL QREGVS		;CAN MAKE US SKIP!
CLOSB2:	MOVE AA,PF
	CAMN AA,PFINI
OPENB1:	TYPRE [QRP]
	POP AA,(AA)
	POP AA,(CH)
	CAIN CH,$QBUFR	;POPPING INTO Q..O => NEW BUFFER IS SELECTED.
	 CALL BFRSE1
FSQPU2:	MOVEM AA,PF
	POPJ P,

;FS QPPTR $ -- GET OR SET QREG PDL POINTER.
;TAKES AND RETURNS # ENTRIES ON STACK.
FSQPPT:	HRRZ A,PF
	SUBI A,PFL-1	;GET 2*<# ENTRIES NOW ON STACK>
	LSH A,-1	;A HAS VALUE TO RETURN.
	TRZN FF,ARG
	 JRST POPJ1	;NO ARG => JUST RETURN THE VALUE.
	CALL FSQPRG	;CONVERT ARG TO NEW PDL PTR.
	MOVEM B,PF	;STORE NEW CONTENTS.
	JRST POPJ1

;HANDLE ARGUMENT DECODING FOR FS QP SLOT, FS QP PTR, AND FS QP UNWIND.
FSQPRG:	ARGDFL
	JUMPL B,FSQPR1
	LSH B,1		;ARG -> PTR TRANSFORMATION IS INVERSE OF
	HRLI B,(B)	;PTR -> VALUE TRANSFORMATION DONE ABOVE.
	ADD B,PFINI
	CAMLE B,PF
	 JRST OPENB1	;DON'T ALLOW REF. TO CELLS ABOVE CURRENT POINTER POS.
	RET

FSQPR1:	LSH B,1		;NEGATIVE ARG IS RELATIVE TO CURRENT POINTER.
	HRLI B,-1(B)
	ADD B,PF
	CAMGE B,PFINI	;DON'T ALLOW REF BELOW BOTTOM OF QREG PDL.
	 JRST OPENB1
	RET

PFINI:	-LPF-1,,PFL-1
PFTOP:	-1,,PFL+LPF-1

;<N> FS QPSLOT $ -- RETURNS CONTENTS OF SLOT <N>.
;<M>,<N>FS QPSLOT $ ALSO SETS THE SLOT TO <M>.
FSQPSL:	MOVE C,SARG
	TRZN FF,ARG	;MUST HAVE ARG TO KNOW WHICH SLOT.
	 TYPRE [WNA]
	TRZE FF,ARG2	;IF 1 ARG, IT'S SLOT #, IN B.
	 TRO FF,ARG	;IF 2, SLOT #'S IN B, NEW VALUE IN C.
	CALL FSQPRG	;FIND ADDRESS OF DESIRED SLOT IN B.
	EXCH B,C
	AOJA C,FSNOR1	;WORD TO GET OR SET IS 2ND WORD OF SLOT.

;<N> FS QPUNWIND $ -- UNWINDS QREG PDL TO LEVEL <N>.
;THAT IS, POPS EACH ENTRY BACK INTO THE QREG IT WAS PUSHED FROM.
FSQPUN:	TRZN FF,ARG	;NO ARG => ASSUME 0.
	 SETZ B,
	PUSHJ P,FSQPRG	;COMPUTE LEVEL TO UNWIND TO FROM ARG.
FSQPU0:	MOVE AA,PF
FSQPU1:	CAMG AA,B	;DOWN TO DESIRED LEVEL?
	 JRST FSQPU2	 ;JUST SET PF & EXIT
	POP AA,CH	;POP 1 ENTRY
	JUMPL CH,FSQPU5	;JUMP IF "QREG ADDR" IS A STRING - MEANS IT IS QREG NAME, A LA QFOO.
IF2 IFG FLAGSL*2-QTAB,.ERR QRP CAN'T TELL [ FROM F[
			;]]
	CAIGE CH,FLAGSL*2	;IF ENTRY WAS MADE BY AN F[, POP INTO FLAG.  ;]
	 JRST FSQPU4
	CAIN CH,$QUNWN	;IF UNWINDING Q..N,
	 JRST [	MOVE A,(CH)
		POP AA,(CH) ;POP IT, STORING OR SAVING ALL TEMPS,
		JRST FSQPU3];AND GO MACRO IT.
	POP AA,(CH)
	CAIN CH,$QBUFR	;IF UNWINDING Q..O, WE'RE SELECTING A NEW BUFFER.
	 CALL BFRSE2
	JRST FSQPU1

FSQPU4:	SAVE B		;HANDLE UNWINDING AN FS FLAG.
	POP AA,B	;GET OLD FLAG VALUE, AS ARG.
	MOVS C,FLAGD(CH)
	SAVE FF
	IORI FF,ARG	;SAY THERE'S AN ARG.
	MOVEM AA,PF
	CALL (C)	;SET THE FLAG.
	 JFCL
	REST FF		;DON'T LET THE ROUTINE CLOBBER THE VALUES.
	REST B
	JRST FSQPU0

FSQPU3:	JUMPE A,FSQPU0
	JSP T,OPEN1	;HANDLE UNWINDING Q..N; MUST PRESERVE TEMPS.
FSQPU6:	SAVE B
	MOVEM AA,PF
	CALL MACXQW	;EXECUTE THE INNER BINDING OF ..N (WHICH IS IN A).
	REST B
	HRROI T,FSQPU0
	TRZ FF,ARG+ARG2+SYLF+OPFLG
	JRST CLOSE2	;POP WHAT OPEN PUSHED, AND GO TO FSQPU0

FSQPU5:	MOVE A,CH	;POP INTO LONG-NAMES QREG WHOSE NAME IS IN CH.
	JSP T,OPEN1
	MOVEM A,SARG
	TRO FF,ARG\ARG2
	TRZ FF,COLONF\SLSL\SYLF\OPFLG
	POP AA,NUM
	MOVEI A,[ASCIZ /[0 U0/]
	JRST FSQPU6

;M<Q> SAVES CURRENT EXECUTION POINTERS AND THEN EXECUTES CONTENTS OF <Q>.
 ;<Q> MAY CONTAIN TEXT OR THE ADDRESS OF A BUILT-IN FUNCTION.
;:M<Q> JUMPS INTO THE STRING IN <Q> AND DOESN'T RETURN - BUILT-IN FUNCTIONS NOT ALLOWED.
MAC:	CALL QREGX	;GET A NAME AND PUT ITS ENTRY IN A
	CAIL CH,RRMACT	;FOR M^R ETC, PUT THE CHARACTER WHOSE DEFINITION IS BEING RUN
	 CAIL CH,RRMACT+1000
	  JRST MAC5
	SUBI CH,RRMACT	;IN Q..0.
	MOVEM CH,$Q..0
MAC5:	CALL QLGET0	;REALLY TEXT? IF SO, LENGTH IN AA, BP TO ILDB TEXT IN F.
	 JRST MACN	;NOT REALLY TEXT; USE AS BUILT-IN FUNCTION ADDRESS.
	MOVE C,AA
	TRNE FF,COLONF	;IF YOU ARE DOING A :M, DON'T PUSH THE CALLING STRING
	 JRST MAC3
MAC2:	CALL PUSMAC	;ELSE PUSH THE STRING CONTAINING THE "M" BEFORE JUMPING.
	MOVEI CH,0
	IDPB CH,MACPDP	;PUSH A 0 (MACRO CALL) ENTRY.
MAC3:	SETZ TT,	;PUT IN MACBTS INDICATIONS OF HOW MANY ARGS THERE ARE.
	TRNE FF,ARG
	 TLO TT,MFBA2
	TRNE FF,ARG2
	 TLO TT,MFBA1
	MOVEM TT,MACBTS
	MOVEI B,1
	TRZE FF,SLSL	;GET THE FIRST MACRO ARGUMENT (OR, IF NONE,
	 TRNN FF,ARG	;EITHER 0 OR (IF SLSL) 1).
	  MOVE B,NUM
	ARGDFL
	MOVEM B,MARG2	;SAVE IT AS THE THING ^Y GETS
	MOVE B,SARG	;TRY FOR A SECOND ARGUMENT
	TRNN FF,ARG2
	MOVEI B,0	;IF NONE, THEN 0
	MOVEM B,MARG1	;SIGH
	MOVEM C,COMCNT	;STORE LENGTH OF TEXT AS LENGTH OF MACRO.
	MOVEM AA,COMAX
	MOVE TT,PF
	TRZN FF,COLONF
	 MOVEM TT,MACSPF
	MOVEM F,CPTR	;GIVE RCH THE BP TO THE TEXT.
	JRST CD		;RETURN, CLEARING ANY OTHER ARGUMENT STATUS REMAINING

;A IS ADDR 1ST WD ASCIZ STRING, EXECUTE STRING AS MACRO.
MACXCW:	HRLI A,BP
MACXCT:	SETO AA,	;A IS BP -> STRING.
	MOVE F,A	;MUST COUNT # CHARS IN STRING.
MACXC1:	ILDB CH,A
	AOJ AA,
	JUMPN CH,MACXC1
	JRST MACXC2

MACXQW:	JUMPGE A,MACXCW	;EXECUTE EITHER A QREG OR AN ASSEMBLED-IN ASCII STRING.
			;DISTINGUISH THEM SINCE STRING QREGS ARE NEGATIVE.

;A HAS CONTENTS OF A QREG; EXECUTE IT AS A MACRO.
MACXQ:	CALL QLGET0	;GET LENGTH AND STARTING BP OF QREG.
	 JRST MACN1	;(QREG CONTAINS A NUMBER)
MACXC2:	MOVE C,AA
MACXC3:	SAVE MACPTR
	SAVE MACXP
	MOVEM P,MACXP	.SEE RCH2
	SETOM MACPTR	;-1 SAYS CALLED FROM MACXP.
	JRST MAC2

MACN:	TRNE FF,COLONF
	 TYPRE [QNS]	;:M TO A BUILT-IN FUNCTION??
	SAVE [CD]
MACN1:	ARGDFL Z	;MACROING A QREG CONTAINING A NUMBER.
	MOVEM B,RRRPCT
	SETZM RR4TCT	;STUFF OUR ARG INTO THE ^R-ARG VARS SO BUILT-IN CMD WILL SEE.
	.I RRARGP=3
	MOVE CH,$Q..0	;CH GETS "THIS CHARACTER" IN CASE COMMAND CARES.
	MOVE C,A
	JRST RRLP7H

;<N>FSBAKTRACE$ - INSERT IN THE BUFFER THE TEXT OF THE MACRO
FSBAKT:	MOVE AA,MACXP
	HRRE A,MACPTR
FSBAK0:	JUMPGE A,FSBAK2
	HRRE A,-1(AA)	;WHENEVER A MACXQ CALL IS FOUND, GO BACK THROUGH IT.
	MOVE AA,(AA)
	JRST FSBAK0

FSBAK2:	JUMPE A,TYPAOR
	JUMPE B,FSBAK1
	HRRE A,(A)
	SOJA B,FSBAK0

FSBAK1:	MOVE F,MFCPTR-MFLINK(A)
	CALL GETCA
	ADD F,MFCCNT-MFLINK(A)
	SUB F,MFCMAX-MFLINK(A)
	CALL GETBP
	SAVE F
	MOVE B,MFCMAX-MFLINK(A)
	MOVEM B,INSLEN
	CALL GAPSLP
	CALL SLPGET
	MOVN A,MFCCNT-MFLINK(A)
	ADDM A,PT
	MOVE IN,F
	REST F
	JRST QGET1

X:	CALL QREGVS
	CALL GETARG	;X COMMAND, GET ENDS OF AREA IN B,C.
	 CALL CHK1
X12:	TRZ FF,ARG\ARG2	;FLUSH ARG;  AVOIDS LOSSAGE FOR X* WHICH RETURNS VALUE.
	JUMPE AA,X10		;IS THE QREG SUBSCRIPTED? (X:Q(IDX))
	JSP TT,QREGVA		;IF SO, EXTRA HAIR IN CASE OUR CONSING
				;MOVES THE Q-VECTOR CONTAINING THE Q-REG.
				;CALLS X10, THEN RETURNS TO INSERT'S CALLER.

X10:	PUSH P,CH	;CALL HERE FROM THINGC, ASSUME B,C SET UP.
	SETZM UPXOCT
	TRZE FF,SLSL
	PUSHJ P,X5	;APPENDING TO QREG-GET PREVIOUS LENGTH/LOCATION
	PUSHJ P,CHK1
	SUB B,C		;B HAS # CHARS TO X AWAY
	ADDI B,4	;THEN INCLUDE 4 CHARS FOR HEADER.
	ADD B,UPXOCT	;CHECK IF Q-REG WILL BE OVER-STUFFED
	SAVE B
	MOVN D,BEG
	CALL SLPQGT	;MAKE SURE HAVE ENOUGH SPACE BEFORE BEG.
	ADD D,BEG	;CHANGE IN BEG = AMOUNT BUFFER MOVED.
	ADD C,D		;RELOCATE ADDR OF START OF AREA.
	MOVE B,(P)	;GET LENGTH INCL. HEADER.
	MOVEI AA,QRSTR	;AND 1ST CHAR FOR HEADER.
	CALL QHDRW1	;WRITE THE HEADER IN BOTTOM OF FREE AREA.
	REST B
	SUBI B,4	;B HAS LENGTH NOT INCL. HEADER.
	SKIPN D,UPXOCT	;ANY CHARS TO APPEND TO?
	 JRST X8
	SUB B,D	;YES, COUNT OFF THAT MANY AS INSERTED,
	MOVE OUT,UPXOPT	;GET BP TO ILDB OLD TEXT TO APPEND TO,
X7:	ILDB CH,OUT	;AND COPY INTO NEW STRING.
	IDPB CH,F
	SOJG D,X7
X8:	MOVE IN,C
X1:	SOJL B,X2	;MAYBE INSERTED ALL THE CHARS.
	CALL GETINC	;IF NOT, INSERT THE NEXT.
	IDPB CH,F
	JRST X1

X2:	CALL GETCA
	AOS OUT,F	;GET CHAR ADDR OF LAST+1.
	TRZ FF,COLONF\SLSL
	JRST QCLOSP	;POP QREG ADDR AND STORE STRING IN IT.

X5:	CALL QLGET0	;CALCULATE LENGTH.
	 RET		;NOT A STRING OR BUFFER => IGNORE.
	MOVEM F,UPXOPT	;SAVE BP TO ILDB TEXT OF OLD STRING.
	MOVEM AA,UPXOCT	;SAVE LENGTH OF OLD VALUE.
	POPJ P,

;P COMMAND WITH 2 ARGS.
PUNCHB:	CALL GETARG
	 CALL CHK1A
PUNCHF:		;PUNCH OUT RANGE SPEC'D BY B,C.
	MOVE IN,C
	SKIPL OUTFLG	;IF NO FILE OPEN O;R FILE TURNED OFF BY ^V,
	TLNN FF,UWRITE
	 JRST TYPE3	;DO IT THE SLOW WAY.
	CAML IN,B	;OR NO CHARS TO OUTPUT,
	 JRST TYPE3	;ALSO THE SLOW WAY.
	MOVE F,IN
	SUBM B,IN	;IN GETS CHAR COUNT
	PUSHJ P,GETIBP
	PUSH P,E
	MOVE C,[PPG,,A]
	BLT C,C
PCHF1:	MOVE TT,UTYOP
	HLRZ OUT,F
	CAMN TT,[010700,,UTOBUF-1] ;UTOBUF EMPTY AND
	CAIE OUT,010700	;NEXT CHR IN BUFFER IS 1ST IN A WD =>
	 JRST PCHF2
PCHF3:	CAIGE IN,300	;TRY .IOTING OUT OF BUFFER.
	 JRST PCHF2	 ;(TOO FEW CHARS TO BE WORTH IT)
	ADDI F,1
	MOVE CH,IN	;GET # WDS FULL IN BUFFER AFTER WHERE WE ARE.
	IDIVI CH,5
	CAIL CH,2000
	 MOVEI CH,2000	;DON'T OUTPUT MORE THAN A K AT ONCE.
	MOVNS CH
	HRLI F,(CH)	;F HAS AOBJN -> WDS IN BUFFER.
	.IOT UTYOC,F
	IMULI CH,5	;# CHARS JUST OUTPUT.
	ADD IN,CH	;THAT MANY FEWER LEFT.
	SUBI F,1	;CHANGE F BACK TO BP TO NEXT CHAR.
	HRLI F,010700
	JRST PCHF3	;HANDLE REMAINING CHARS.

PCHF2:	MOVN OUT,UTYOCT	;GETS POS COUNT
	CAMLE OUT,IN
	MOVE OUT,IN
	PUSH P,OUT
	JUMPE OUT,PPG1
	JRST A

PPG:	ILDB CH,F	;A
	IDPB CH,TT	;AA
	SOJG OUT,A	;B
	JRST PPG1	;E

PPG1:	POP P,OUT
	MOVEM TT,UTYOP
	ADDM OUT,UTYOCT
	SKIPL UTYOCT
	PUSHJ P,UTYOA
	SUB IN,OUT
	JUMPG IN,PCHF1
POPEJ:	POP P,E
	POPJ P,

PUNCH:
PUNCHA:	CALL SLPSHT
IFN TS,[
	TLNN FF,UWRITE
	 TYPRE [NDO]
]
	MOVEI D,PPA
	TRNE FF,ARG2
	 JRST PUNCHB
	MOVE E,B
	MOVE B,CPTR
	LDB T,B
	CAIE T,"P	;IF COMMAND IS P
	CAIN T,"P+40
	ILDB T,B	;THEN GET NEXT CHAR, IF W THEN DON'T YANK INTO BUFFER
	JUMPL E,CPOPJ
PUN1:	PUSHJ P,PUNCHR
	TRZ FF,ARG
	CAIE T,"W
	CAIN T,"W+40
	SKIPN COMCNT
	PUSHJ P,YANKEE
	MOVE C,ZV
	CAMN C,BEGV
	SKIPE LASTPA
	SOJG E,PUN1
CPOPJ:	POPJ P,VIEW1
PUNCHR:	SKIPGE STOPF	;IN BETWEEN PAGES,
	 CALL QUIT0	;TRY TO QUIT IF DESIRED (CHECKS NOQUIT).
	MOVE C,BEGV
	MOVE B,ZV
	MOVEI D,PPA
	SKIPE FFMODE	;IN FFMODE, ANY ^L DESIRED IS ALREADY IN BFR.
	 JRST PUNCHF
	CALL PUNCHF	;IF ^L'S READ GET THROWN AWAY,
	MOVEI CH,^L	;MUST REGENERATE THEM ON OUTPUT.
	JRST PPA

IFN TS,[
;FORCE OUT CONTENTS OF OUTPUT BUFFER. CLOBBERS A, AA, B.
FLSOUT:	TLNN FF,UWRITE
	 RET		;NO OUTPUT FILE.
	MOVE AA,UTYOP
	IBP AA		;-> WD NEXT OUTPUT CHAR WILL GO IN.
	MOVEI A,@AA
	MOVNI B,-UTOBUF(A) ;# WDS FILLED UP IN FRONT END OF BFR.
	JUMPE B,CPOPJ
	HRLZI A,(B)
	HRRI A,UTOBUF	;AOBJN -> FILLED PART.
	.IOT UTYOC,A
	MOVE A,(AA)	;GET THE PARTIALLY FILLED WORD.
	MOVEM A,UTOBUF	;PUT IT IN 1ST WD OF BUFFER,
	ADDM B,UTYOP	;BACK THE BP UP THE RIGHT # WDS.
	IMULI B,5
	ADDM B,UTYOCT	;MORE SPACE IN OUTPUT BUFFER NOW.
	POPJ P,
]

PPA:
PPA2:	SKIPGE OUTFLG
	 POPJ P,
	TLNE FF,UWRITE
	JRST UTYO
	POPJ P,

IFN TS,[UTYO:	IDPB CH,UTYOP
	AOSGE UTYOCT
	POPJ P,
UTYOA:	MOVEM CH,UTYOP
	MOVNI CH,<UTOBE-UTOBUF>*5
	MOVEM CH,UTYOCT
	MOVE CH,[UTOBUF-UTOBE,,UTOBUF]
	.IOT UTYOC,CH
	MOVE CH,[10700,,UTOBUF-1]
	EXCH CH,UTYOP
]
	POPJ P,

;SET ACCESS POINTER OF OUTPUT FILE TO CHAR # IN B,
;WHICH MUST BE A MULTIPLE OF 5. ERROR IF ANY CHARS IN OUTPUT
;BUFFER ARE LOST (WHICH WILL BE THE CASE UNLESS OUTPUT STOPPED
;ON A WORD BOUNDARY).
FSOFAC:	TLNN FF,UWRITE
	 TYPRE [NDO]
	MOVEI A,UTYOC
	.CALL RFACCB
	 TYPRE [NRA]
	SAVE B
	CALL FLSOUT	;FORCE OUT THE OUTPUT BUFFER.
	REST B
	MOVN A,UTYOCT	;ANYTHING NOT FORCED OUT??
	CAIE A,UTBSZ*5
	 TYPRE [WLO]
	IDIVI B,5	;GET WORD # IN FILE OF DESIRED POSITION.
	SKIPE E
	 TYPRE [ARG]	;ARG NOT MULTIPLE OF 5??
	.ACCES UTYOC,B
	RET

;COME HERE FOR DPT OF NEGATIVE NUMBER.
DPT2:	CAMN B,[SETZ]	;CAN'T NEGATE THIS! MUST WORK SPECIALLY
	 JRST DPTMNF
	MOVNS B		;OTHERWISE PRINT THE MAGNITUDE, PRECEDED BY A "-".
	TLO FF,NEGF
RDPT:	SOJA TT,DPT6

DPT:	TDZA TT,TT	;DECIMAL PRINT, NO LEADING ZEROS.
SLDPT:	MOVEI TT,2	;DECIMAL PRINT, WITH AT LEAST 3 POSITIONS USED.
DPT1:	JUMPL B,DPT2
DPT6:	MOVE E,QRB..
	MOVM CH,.QBASE(E)
	SOJLE CH,[
		MOVEI B,10.	;IF ..E HOLDS 0, 1 OR -1, REPLACE BY 10.
		MOVEM B,.QBASE(E)
		TYPRE [..E]]
	IDIV B,.QBASE(E)
DPT8:	HRLM E,(P)
	JUMPGE E,DPT7		;HANDLE NEGATIVE REMAINDER (IMPLIES NEG. RADIX).
	MOVE E,QRB..
	HRLZ E,.QBASE(E)	
	MOVNS E
	ADDM E,(P)
	AOS B
DPT7:	SKIPE B
	 CALL RDPT
	TLZE FF,NEGF
	 SAVE ["--"0,,DPT3]
DPT3:	JUMPLE TT,DPT4
	XCT DPT5
	PUSHJ P,@LISTF5
	SOJG TT,.-1
DPT4:	HLRE CH,(P)
DGPT:	ADDI CH,"0
	CAILE CH,"9	;FOR "DIGITS" ABOVE 9, USE LETTERS.
	 ADDI CH,"A-"9-1
	JRST @LISTF5

DPTMNF:	MOVE E,QRB..	;HANDLE PRINTING OF 400000,,
	MOVE E,.QBASE(E)
	CAIE E,8	;PRINT IT WITH A "-" SIGN, EXCEPT IN OCTAL.
	 TLO FF,NEGF
	SAVE E
	LSHC B,-35.	;NOTE LOW BIT OF C IS 0, SINCE QRB.. ISN'T TOO BIG.
	DIV B,(P)
	SUB P,[1,,1]
	JRST DPT8

;<ARG>= PRINTS <ARG><CR>.
;<ARG>,= PRINTS <ARG>,<CR>.
;<ARG>,<ARG1>= PRINTS <ARG>,<ARG1><CR>.
;^ => PRINT IN ECHO AREA.  : => OMIT THE <CR>.
PRNT:	TRNN FF,ARG+ARG2
	 TYPRE [WNA]
	TRNN FF,ARG2
	 JRST PRNT2
	EXCH B,C	;= WITH 2 ARGS:
	CALL PRNT3	;PRINT THE 1ST ARG,
	MOVEI CH,",
	CALL @LISTF5	;A COMMA,
	EXCH B,C	;AND THE SECOND ARG.
	TRNE FF,ARG
PRNT2:	 PUSHJ P,PRNT3
	TRNE FF,COLONF
	 RET
	TRNE FF,SLSL
	 JRST CRR1
	JRST CRR

PRNT3:	MOVEI A,TYO
	TRNE FF,SLSL
	 MOVEI A,FSECO2
	HRRM A,LISTF5
	JRST DPT

FDQUOT:	SUB P,[1,,1]	;F" LIKE " BUT ARGUMENT REMAINS AS WELL AS BEING TESTED.
	SKIPA A,[CD2A]
DQUOTE:	 MOVEI A,CD
	CALL LRCH	;READ THE CONDITION NAME (B, C, G, L, E, N, #)
	CAIN CH,"#	;IS THIS AN "ELSE"?
	 JRST [	CALL NOGO	;YES, FAIL: SKIP TO THE ',
		JRST CD2A]	;RETURN WITHOUT FLUSHING VALUE.
	TRNN FF,ARG
	 TYPRE [WNA]	;THIS IS A NUMERIC CONDITIONAL: SNARF THE ARG.
	SAVE A
	MOVSI A,0
	IRPC Z,,[GLNE]
	CAIN CH,"Z
	MOVSI A,(JUMP!Z B,)
	TERMIN
	CAIN CH,"C
	JRST DQT1
	CAIN CH,"B
	 JRST [CALL DQT3
		JRST NOGO ;SQUOZE CHAR, CONDITION FAILS.
		POPJ P,]
	JUMPE A,[TYPRE [W%A]]	;W"A; WRONG TYPE OF ARGUMENT TO "
	HRRI A,CPOPJ
	XCT A
NOGO:	MOVEI A,0
	SETOM BRC1
NOGO1:	CALL [	SKIPG COMCNT	;SEARCHH FOR THE MATCHING SINGLEQUOTE.
		 TYPRE [UTC]
		JRST RCH]
	CAIN CH,""
	 AOJA A,NOGO1
	CAIE CH,"'
	 JRST NOGO1
	SOJGE A,NOGO1
	SETZM BRC1
	CALL TRACS	;MANTION THE ' IN THE TRACE.
	MOVE A,COMCNT
	MOVE F,CPTR
NOGO2:	SOJL A,CPOPJ	;AFTER THE MATCHING ', CHECK FOR AN ELSE ("#)
	ILDB CH,F	;IS THE NEXT CHAR A DOUBLEQUOTE?
	CAIE CH,^M
	 CAIN CH,^J	;ALLOW CRLFS TO INTERVENE BEFORE THE DOUBLEQUOTE.
	  JRST NOGO2	;JUST PASS THEM BY.
	SKIPGE TABMOD
	 CAIE CH,^I
	  CAIN CH,40
	   JRST NOGO2	;ALSO ALLOW SPACES BETWEEN.
	CAIN CH,"!	;ALSO ALLOW TAGS BETWEEN.
	 JRST NOGO3
	CAIE CH,""
	 RET		;NO - THERE IS NO "ELSE"
	SOJL A,CPOPJ	;MAKE SURE A "#" FOLLOWS THE """".
	ILDB AA,F
	CAIE AA,"#
	 RET
	CALL TRACS	;THERE IS AN ELSE - TRACE THE " AND #.
	MOVEI CH,"#
	CALL TRACS
	MOVEM F,CPTR	;RESUME EXECUTION INSIDE THE ELSE CLAUSE.
	MOVEM A,COMCNT
	RET

NOGO3:	SOJL A,CPOPJ
	ILDB CH,F	;SKIP UNTIL THE NEXT "!", THEN CONTINUE LOOKING FOR '"#'.
	CAIE CH,"!
	 JRST NOGO3
	JRST NOGO2

EXCLAM:	SETOM BRC1	;HANDLE "!" AS A COMMAND.
	CALL SKRCH	;SKIP UNTIL THE NEXT "!".
	CAIE CH,"!
	 JRST .-2
	SETZM BRC1
	CALL TRACS	;IN TRACE MODE, TRACE A SECOND "!" TO MINIMIZE USER CONFUSION.
	JRST CD5A

LRCH:	PUSHJ P,RCH
	TRNE CH,100
	 ANDCMI CH,40
	POPJ P,

DQT1:	PUSHJ P,DQT3
	POPJ P,
	JRST NOGO

;HANDLE THE "O" COMMAND: O<TAG>$ JUMPS TO !<TAG>!. ":O" DOES NOT ERR IF TAG UNFOUND.
OG:	MOVE A,CPTR	;FIRST, LOOK IN THE JUMP CACHE FOR ADDR OF "O" CMD.
	MOVE B,A
	ANDI B,16	;GET INDEX IN CACHE OF ENTRY PAIR THAT'S APPRO.
	CAMN A,SYMS(B)	;IS FIRST ENTRY FOR THIS "O"?
	 JRST OGFND
	CAMN A,SYMS+1(B) ;IS THE SECOND?
	 AOJA B,OGFND	;IF FOUND, GET PLACE TO JUMP TO FROM CACHE ENTRY.
;THIS JUMP NOT IN CACHE; MUST ACTUALLY SEARCH.
	SAVE CPTR	;PUSH INFO ON WHERE TO STORE INTO CACHE WHEN FIND TAG.
	SAVE B		;THESE 2 WORDS ARE NOT USED FOR ANY OTHER PURPOSE.
	CALL OARG	;READ IN THE STRING ARG.
	SAVE COMCNT
	SAVE CPTR
	MOVE F,CPTR
	CALL GETCA
	ADD F,COMCNT	;CHAR ADDR END OF MACRO.
	SUB F,COMAX	;CHAR ADDR BEGINNING OF MACRO.
	CAMGE F,[LHIMIN*5*2000]
	 CAMGE F,QRWRT	;ARE WE IN A STRING? OR IN A BUFFER OR CBUF?
	  CAMGE F,QRBUF
	   SETOM BRCFLG	;JUMPS IN BUFFERS AND CBUF AREN'T CACHED,
		;SINCE THE DATA AT A GIVEN LOCATION IS LIKELY TO CHANGE.
	CALL GETBP	;B.P. TO START OF MACRO.

;NOW SEARCH FOR THE DESIRED LABEL.
	MOVE AA,COMAX
	MOVEM F,CPTR
	MOVEM AA,COMCNT
	TRNE FF,SLSL
	 SOS D
OG4:	MOVEI E,STAB
	SETOM BRC1
OG5:	CAIN E,1(D)
	 JRST OG3
	CALL [	SKIPG COMCNT
		 JRST OGUGT	;UNSEEN GO-TAG.
		JRST ORCH]
	CAMN CH,(E)
	 AOJA E,OG5
	MOVE F,CPTR
	TLNE F,760000	;AT WORD BOUNDARY => TRY TO SKIP WORDS FAST.
	 JRST OG4
	MOVE AA,COMCNT
OG6:	SUBI AA,5
	JUMPL AA,OG7	;NOT A WHOLE WORD LEFT TO SCAN => CAN'T GO FAST.
	MOVE E,1(F)	;ELSE GET THE NEXT WORD
	XOR E,[ASCII /!!!!!/]	;AND SEE IF THERE ARE ANY !'S IN IT.
	TLNE E,(177_35)
	 TLNN E,(177_26)
	  JRST OG7
	TRNE E,177_1
	 TRNN E,177_10
	  JRST OG7
	TDNN E,[177_17]
	 JRST OG7
	AOJA F,OG6	;THERE ARE NONE, SO WKIP THIS WORD.

OG7:	ADDI AA,5	;FOUND AN !, SO SCAN SLOWLY TO LOCALIZE IT.
	MOVEM AA,COMCNT
	MOVEM F,CPTR
	JRST OG4

;COME HERE WHEN WE HAVE FOUND THE TAG BY SEARCHING.
OG3:	SUB P,[2,,2]	;FLUSH SAVED INFO NEEDED IN CASE OF UNSEEN GO TAG.
	REST A		;REMEMBER IDX OF CACHE ENTRY TO STORE IN.
	REST AA		;REMEMBER CPTR OF "O" TO PUT IN CACHE
	SETZM BRC1
	SKIPE BRCFLG
	 JRST OGXIT	;BUT MAYBE CACHE IS INHIBITED FOR THIS JUMP.
	EXCH AA,SYMS(A)	;STORE THIS JUMP IN 1ST ENTRY OF PAIR, AND MOVE
	MOVEM AA,SYMS+1(A) 	;OLD CONTENTS OF 1ST ENTRY INTO 2ND.
	MOVE AA,COMCNT
	EXCH AA,CNTS(A)		;CACHE ENTRY CONTAINS CPTR OF "O",
	MOVEM AA,CNTS+1(A)	;CPTR OF TAG, AND COMCNT OF TAG.
	MOVE F,CPTR
	EXCH F,VALS(A)
	MOVEM F,VALS+1(A)
	JRST OGXIT

OGFND:	TRNE FF,TRACEF
	 CALL OARG	;IF TRACING, READ IN ARGUMENT SO IT WILL SHOW IN TRACE.
	MOVE A,VALS(B)	;COME HERE WHEN THE JUMP IS FOUND IN THE CACHE.
	MOVEM A,CPTR
	MOVE A,CNTS(B)
	MOVEM A,COMCNT
OGXIT:	TRZN FF,SLSL
	 JRST CD
	MOVEI CH,"!
	CALL TRACS
	JRST EXCLAM	;^ O => WE'RE INSIDE A LABEL, SO WE MUST SKIP TO THE END.

OGUGT:	SETZM BRC1
	TRZN FF,COLONF
	 TYPRE [UGT]
	SUB P,[1,,1]
	REST CPTR
	REST COMCNT
	SUB P,[2,,2]
	JRST CD

;READ IN A STRING ARG, AND SAVE IT 1 CHAR PER WORD
;IN STAB, WITH AN ! BEFORE AND AFTER. LEAVE D -> LAST
;WORD USED IN STAB. USED BY "O" AND "F;".
;BRCFLG LEFT NONZERO IFF SOME UNPREDICTABLE ^] CALLS TOOK PLACE.
;CLOBBERS A, CH.
OARG:	MOVEI D,STAB+1
	MOVEI A,41
	MOVEM A,-1(D)
	SETZM BRCFLG	;[ ;ANY ^] CALLS WE WORRY ABOUT WILL SET BRCFLG.
OGNF1:	CAIN D,STAB+LTABS
	 TYPRE [STL]
	CALL ORCH
	HRRZM CH,(D)
	SKIPN SQUOTP
	 CAIE CH,ALTMOD
	  AOJA D,OGNF1
	MOVEM A,(D)
	RET

ORCH:	CALL RCH	;READ CHAR AND CONVERT L.C. LETTERS (ONLY) TO U.C.
	CAIL CH,"A+40
	 CAILE CH,"Z+40
	  RET
	SUBI CH,40
	RET

;FO COMMAND - BINARY SEARCH A TABLE FOR A GIVEN STRING.
;FOLLOW BY QREG WHICH POINTS TO A STRING OR BUFFER CONTAINING THE TABLE
;(MUST BE ON A WORD BOUNDARY, SO USELESS WITH IMPURE STRINGS).
;AFTER THE QREG NAME COMES THE STRING TO SEARCH FOR.
;THE FIRST WORD OF THE TABLE MUST CONTAIN THE SIZE (IN WORDS) OF
;ALL THE ENTRIES;  AFTER IT COME THE ENTRIES.  THE FIRST WORD OF EACH ENTRY
;IS ASSUMED TO BE THE POINTER TO THE NAME-STRING TO SEARCH FOR.
;IF THE TABLE IS A PURE STRING, THAT PONTER IS RELATIVE TO THE TABLE ITSELF.
;PLAIN FO GETS AN ERROR (UVN OR AVN) IF THE TARGET NAME IS MISSING OR AMBIGUOUS;
;OTHERWISE, IT RETURNS THE VALUE IN THE SECOND WORD OF THE ENTRY.
;:FO RETURNS THE OFFSET OF THE ENTRY FOUND;  IF THE TARGET IS NOT FOUND
;OR AMBIGUOUS, MINUS THE OFFSET OF THE ENTRY TO INSERT BEFORE IS RETURNED.
;<ARG>FO RETURNS THE VALUE OF THE VARIABLE IF IT IS DEFINED,
;<ARG> IF IT IS UNDEFINED, AND ERRS IF THE VARIABLE IS AMBIGUOUS.
FOCMD:	CALL QREGX		;READ THE QREG NAME.
FOCMD0:	MOVEI D,STAB-1		;THEN ACCUMULATE STRING TO SEARCH FOR IN STAB.
	MOVEI AA,40		;AA HOLDS PREVIOUS CHARACTER, FOR COMPRESSING SPACES.
	TRZ FF,NOTF
FOCMD1:	CALL ORCH		;READ CHAR, CONVERT LETTERS TO U.C.
	CAIN CH,ALTMOD
	 JRST FOCMD2
	CAIN CH,^I
	 MOVEI CH,40		;CONVERT ALL TABS TO SPACES.
	CAIN CH,40		;CHECK FOR MULTIPLE OR LEADING WHITESPACE.
	 CAIE AA,40		;IF THIS CHAR AND PREVIOUS BOTH SPACING, IGNORE THIS ONE.
	  CAIA
	   JRST FOCMD1
	MOVE AA,CH		;REMEMBER THIS CHAR AS PREVIOUS FOR NEXT.
	HRRZS CH
	PUSH D,CH		;REMEMBER CHAR IN STAB.
	JRST FOCMD1

FOCMD2:	CAIN AA,40		;FLUSH TRAILING SPACES.
	 SOS D
	HRRZS D			;D POINTS AT END OF STUFF IN STAB.
	CAIGE D,STAB
	 TYPRE [UVN]		;ARG NULL AFTER HACKING IT => NO GOOD.
	CALL QLGET0		;GET TABLE LENGTH IN CHARS IN AA, B.P. TO ILDB IN F.
	 TYPRE [QNS]
	IBP F
	HLRZ A,F
	CAIE A,350700		;TABLE MUST START ON WORD BOUNDARY.
	 TYPRE [ARG]
	MOVE B,(F)		;B GETS ENTRY SIZE IN WORDS, FROM 1ST WORD OF TABLE.
	MOVE OUT,AA
	IDIVI OUT,5		;SIZE MUST BE INTEGRAL # OF WORDS.
	SKIPE OUT+1 .SEE CH
	 TYPRE [ARG]
	SOS CH,OUT		;OUT GETS TABLE SIZE, NOT COUNTING 1ST WORD (SIZE PER ENTRY).
	IDIV CH,B
	SKIPE CH+1 .SEE Q
	 TYPRE [ARG]		;TABLE MUST BE INTEGRAL NUMBER OF ENTRIES.
	MOVEI IN,1(F)		;IN -> 1ST WORD (NOT COUNTING ENTRY-SIZE WORD AT FRONT).
	ADD OUT,IN		;OUT -> LAST WORD + 1
	HRRZ C,F
	IMULI C,5		;C GETS CHAR ADDR OF START OF TABLE (INCLUDING DOPE WORD).
	CAML C,BFRTOP		;IF TABLE IS A PURE STRING, SET NOTF, INDICATING
	 TRO FF,NOTF		;NAME POINTERS ARE RELATIVE TO BOTTOM OF STRING (NEED C ADDED).
	SUBI C,4
	TLO C,400000
	MOVE T,OUT		;SAVE BOUNDS OF WHOLE TABLE AS [C,T)
	JRST FOCMDN

;NOW TRY TO NARROW THE RANGE [IN,OUT) WHICH THE OBJECT MIGHT BE IN.
;C HAS CHAR ADDR START OF TABLE MINUS 4 (WITH SIGN SET),
;T -> WORD AFTER END, B HAS ENTRY SIZE IN WORDS,
;D POINTS TO LAST USED WORD IN STAB.
FOCMDN:	MOVE CH,OUT
	SUB CH,IN
	CAMG CH,B
	 JRST FOCMDF		;NARROWED TO ONE ENTRY => IT'S THAT OR NOTHING.
	IDIV CH,B		;HOW MANY ENTRIES THEN?
	MOVE E,CH
	LSH E,-1		;BINARY SEARCH STEP IS HALF THAT MANY.
	IMUL E,B
	ADD E,IN		;GET PTR TO MIDDLE OF RANGE; COMPARE THAT POINT WITH TARGET.
	CALL FOCMP
	 JRST [	MOVE OUT,E	;TARGET IS LESS => NARROW TO BOTTOM HALF-RANGE.
		JRST FOCMDN]
	 JRST [ MOVE IN,E	;TARGET IS MORE => NARROW TO TOP HALF-RANGE.
		JRST FOCMDN]
	MOVE IN,E
	JRST FOCMDW		;TARGET IS EQUAL => WE CERTAINLY WIN.

;NARROWED TO JUST ONE ENTRY;  IS IT GOOD?
FOCMDF:	CAML IN,T
	 JRST FOCMDU
	MOVE E,IN		;FIRST OF ALL, THIS ENTRY IS THAT LAST ONE L.E. TARGET.
	CALL FOCMP		;SO ADVANCE TO THE FIRST ONE G.E. THE TARGET
	 CAIA
	 ADD IN,B		;SINCE THE TARGET MIGHT BE ABBREVIATION FOR THAT ONE.
	CAML IN,T		;DETECT CASE THAT TARGET IS GREATER THAN ALL SYMBOLS
	 JRST FOCMDU
	MOVE OUT,IN
	ADD OUT,B
	MOVE A,(IN)
	CALL FOCMDA		;DOES TARGET ABBREVIATE ENTRY'S NAME?
	 JRST FOCMDU		;NO => TARGET NOT FOUND, RETURN 0.
	JUMPE AA,FOCMDW		;YES, MAY BE GOOD.  IF EXACT MATCH, CERTAINLY GOOD.
	CAMN OUT,T
	 JRST FOCMDW		;NO FOLLOWING ENTRY => NAME CAN'T BE AMGIBUOUS.
	MOVE A,(OUT)		;DOES FOLLOWING ENTRY ALSO WIN?
	CALL FOCMDA
	 JRST FOCMDW		;NO => THIS ENTRY WINS!
	TRZN FF,COLONF		;AMBIGUOUS NAME - MAYBE GIVE ERROR,
	 TYPRE [AVN]
FOCMDL:	MOVEI A,-1(IN)		;MAYBE RETURN MINUS THE PLACE TO PUT THE NAME.
	TRZ FF,ARG
	TLZ C,400000
	IDIVI C,5		;C GETS WORD BEFORE THE WORD TABLE STARTS IN.
	SUBM C,A
	JRST POPJ1

FOCMDU:	TRZE FF,ARG		;HERE IF NAME IS UNDEFINED;  IN -> PLACE TO INSERT IT.
	 JRST [	TRZ FF,COLONF
		MOVE A,NUM
		JRST POPJ1]
	TRZN FF,COLONF
	 TYPRE [UVN]
	JRST FOCMDL

FOCMDW:	MOVE A,1(IN)		;FOUND THE TARGET.  RETURN EITHER 2ND WORD OF ENTRY
	TRZ FF,ARG
	TLZ C,400000
	TRZN FF,COLONF
	 JRST POPJ1
	MOVEI A,-1(IN)
	IDIVI C,5
	SUB A,C
	JRST POPJ1		;OR THE INDEX OF THE ENTRY.

;SKIP IF THE STRING IN STAB IS AN ABBREVIATION FOR THE STRING A POINTS TO
;(A HOLDS TECO STRING POINTER).
FOCMDA:	TRNE FF,NOTF		;IF TABLE IS PURE STRING, "NAME POINTERS" ARE
	 ADD A,C		;ACTUALLY RELATIVE.
	CALL QLGET0		;SKIP IF TARGET ABBREVIATES THE STRING A POINTS TO.
	 TYPRE [QNS]
	MOVEI Q,STAB
FOCMDG:	CAMLE Q,D
	 JRST POPJ1		;JUMP IF TARGET ABBREVIATES ENTRY'S NAME.
	JUMPE AA,CPOPJ		;TARGET DOESN'T ABBREVIATE ENTRY'S NAME => TARGET NOT FOUND.
	ILDB CH,F
	CAIL CH,"A+40
	 CAILE CH,"Z+40
	  CAIA
	   SUBI CH,40
	CAME CH,(Q)
	 RET
	SOS AA
	AOJA Q,FOCMDG

;COMPARE STRING IN STAB  (TARGET) WITH STRING THAT @(E) POINTS TO.  SKIP ONCE
;IF TARGET BIGGER, SKIP TWICE IF EQUAL.
FOCMP:	MOVE A,(E)		;GET THIS ENTRY'S NAME.
	TRNE FF,NOTF		;IF TABLE IS PURE STRING, "NAME POINTERS" ARE
	 ADD A,C		;ACTUALLY RELATIVE.
	CALL QLGET0		;DECODE AS STRING.
	 TYPRE [QNS]
	MOVEI Q,STAB		;Q SCANS TARGET, F SCANS THIS ENTRY'S NAME.
FOCMPL:	JUMPE AA,[CAMLE Q,D
		   JRST POPJ2	;IF BOTH STRINGS EXHAUSTED, THEUY ARE EQUAL.
		  JRST POPJ1]	;TARGET HAS MORE => IT IS BIGGER.
	CAMLE Q,D
	 RET			;TARGET EMPTY, BUT THIS ENTRY NAME HAS MORE => TARGET LESS.
	ILDB CH,F
	CAIL CH,"A+40
	 CAILE CH,"Z+40
	  CAIA
	   SUBI CH,40
	CAMGE CH,(Q)
	 JRST POPJ1		;TARGET IS BIGGER.
	CAMLE CH,(Q)
	 RET			;TARGET SMALLER.
	SOS AA
	AOJA Q,FOCMPL		;EQUAL SO FAR, KEEP LOOKING.

;V COMMAND, AND ALL VARIATIONS THEREOF. EXIT WITH JRST RET.
VIEW:	TRZE FF,SLSL
	 JRST [	CALL VIEW1B	;"^ V" - DO APPRO. KIND OF DISPLAY
		JRST VIEW1A]	;THEN CHECK FOR FOLLOWING W.
	SKIPN RGETTY
	 JRST VIEW1A
	PUSHJ P,DISINI
	SETOM VREMEM	;TRY TO DISPLAY BFR AT SAME PLACE
	PUSHJ P,GETARG
	 CALL CHK1A
	MOVE A,C
	SUB A,BEGV
	SKIPGE A
	 SETO A,
	MOVEM A,GEA
	.I DISADP=PT+1	;TELL DISAD WHERE TO PUT CURSOR.
	MOVEI D,DISAD
	PUSHJ P,TYPE1A
VIEW1:	PUSHJ P,DISCLG
VIEW1A:	MOVE T,CPTR
	ILDB B,T
	CAIE B,"W
	CAIN B,"W+40
	SKIPN COMCNT
	 POPJ P,
	CALL RCH	;FLUSH THE "W" OF "VW".
	TRZ FF,ARG2+ARG+COLONF
	JRST FTYI	;READ IN CHAR, RETURN AS NUMBER.

VIEW1B:	SKIPE DISPRR	;"^ V": IN ^R MODE, DO A ^R-STYLE DISPLAY
	 JRST RRNOIN
	JRST VIEW3A	;ELSE DO STANDARD DISPLAY.

EUHACK:	CALL FFRDEV	;E^U -- READ FILENAME, THEN DO
	JRST CNTRU0	;WHATEVER DIR DISPLAY THE USER WANTS.

CNTRLU:	CALL GDEV	;^U -- SIMILAR BUT PREFIX ARG INSTEAD STRING.
	JRST CNTRU0

;COME HERE FROM GO, AFTER THE END OF A COMMAND STRING
;(WHETHER IT ENDED SUCCESSFULLY OR NOT)
;DECIDE WHETHER AND HOW TO DISPLAY.
VIEW2:	ANDCMI FF,COLONF
	TLZE FF,CTLUF	;COLONF _ CTLUF
CNTRU0:	 IORI FF,COLONF
	MOVE CH,QRB..
	TRNN FF,COLONF
	SKIPA A,.QBFDS(CH)	;CTLUF WAS OFF, WE WANT BUFFER DISPLAY.
	 MOVE A,.QFDDS(CH)	;IT WAS ON, WE WANT DIR DISPLAY.
	JUMPE A,VIEW3B	;USER HASN'T SUPPLIED MACRO: DO ^V OR :^V.
	JRST MACXQ	;DO THE MACRO.

;COME HERE AFTER EACH CMD STRING,
;IF USER HAS NOT SUPPLIED A MACRO TO BE INVOKED.
VIEW3B:	TRZ FF,ARG
	MOVE TT,QRB..
	SKIPE .QVWFL(TT)
	 POPJ P,	;DON'T DISPLAY IF CMDS IN STRING INHIBITED IT.
	SKIPE RGETTY	;SHOULD WE EVER DISPLAY ON THIS TERMINAL
	 JRST VIEW3A
	TRNN FF,COLONF	;ELSE, DEFAULT IS NO DISPLAY OF DIRS,
	 SKIPN TTMODE	;BUFFER DISPLAYED ONLY IN :^N MODE.
	  RET
VIEW3A:	TRZE FF,COLONF
	 JRST CNTRU1
	CALL VBDACU	;UPDATE TSALTC, SKIP IF OK TO DISPLAY.
	 POPJ P,
VBD:	CALL DISINI	;SET UP DISPLAY OUTPUT.
	MOVE B,NLINES
	CALL WINSET
VBDRR:	HRRM P,VIEWBF	;INDICATE AUTOMATIC BFR DISPLAY.
	.I CHCTVS=BOTLIN	;FOR SAKE OF PRINTING TTYS, RESTRICT TYPEOUT TO WINDOW SIZE.
	SAVE IMQUIT
	SETOM IMQUIT
	SETZB B,CHCTBP	;TELL CHCT TO THROW AWAY CHARS.
	HLLOM B,DISBFC	;IT WILL NEVER FILL UP ITS INFINITE SINK.
	SKIPE RGETTY	;NOT DATAPOINT => NO DESIRE TO DISPLAY FROM SAME PLACE.
	 SKIPGE IN,GEA	;OR NO OLD PLACE TO START FROM =>
	  JRST VBDNEW	;START FROM SCRATCH.
	ADD IN,BEGV	;TRY THE OLD START.
	CAMLE IN,PT	;NO GOOD TO START AFTER POINTER.
	 JRST VBDNEW
	JRST VBDTRY	;ELSE SEE IF OLD WINDOW STILL GOOD.

;SET THE VARIABLES THAT DESCRIBE THE SIZE AND POSITION OF THE WINDOW
;AND THE MARGINS (REGIONS WHERE WE DON'T WANT THE POINTER TO BE); NAMELY,
;RRTOPM, RRBOTM, BOTLIN, AND VSIZE.
;B SHOULD CONTAIN NLINES (OR SOMETHING TO USE INSTEAD).
WINSET:	SAVE E
	SKIPGE B
	 SETZ B,	;NEGATIVE # LINES NOT ALLOWED.
	SAVE D
	SKIPL D,TOPLIN
	 CAML D,USZ
	  SETZM TOPLIN	;IF FS TOP LINE$ IS INVALID, SET IT TO 0 INSTEAD.
	REST D
	SKIPE B
	 ADD B,TOPLIN	;B HAS DESIRED LAST LINE (+1) TO USE, OR 0 FOR WHOLE SCREEN.
	CAML B,USZ
	 SETZ B,	;CAN'T USE MORE LINES THAN WE HAVE.
	SKIPN B
	 MOVE B,USZ	;NO SPECIFICATION, OR BAD SPEC, => USE TILL SCREEN BOTTOM.
	CAIL B,MXNVLS	;IF THAT'S INFINITELY MANY LINES, USE 2 LINES.
	 MOVEI B,2
	MOVEM B,BOTLIN	;STORE DESIRED LAST LINE (+1) IN BOTLIN.
	SUB B,TOPLIN
	MOVEM B,VSIZE
	IMUL B,%TOP	;COMPUTE MARGINS THAT CURSOR MUSN'T GO OUTSIDE.
	IDIVI B,100.
	ADD B,TOPLIN
	MOVEM B,RRTOPM
	MOVE B,VSIZE
	IMUL B,%BOTTO
	IDIVI B,100.
	SUB B,BOTLIN
	MOVNM B,RRBOTM
POPEJ:	REST E
	RET

;COME HERE TO SEE IF THE PREVIOUS WINDOW (ADDR IN IN) CAN BE REUSED (GEA > -1).
;IN THIS CASE, CAN GO TO VBDNEW IF THE WINDOW IS BAD, OR CAN GO TO VBDOK.
;COME HERE FROM VBDNEW WITH A TENTATIVE WINDOW ADDRESS IN IN (WHICH MAY BE TOO
;CLOSE TO BEG) TO FIND A MORE PRECISE WINDOW (GEA = -1).
;IN THIS CASE, B HOLDS -<DESIRED # LINES ABOVE CURSOR>, AND WE ALWAY EXITS TO VBDOK.
VBDTRY:	CALL CHCTI0	;INIT VARIOUS TEMPS FOR TYPEOUT.
	SETZ T,		;INITIAL HPOS IS 0 (VBDL UPDATES)
	SETZM MORFLF	;THIS MIGHT HAVE STOPPED LAST VBDTRY.
	MOVE A,IN	;A _ THE START WE'RE TRYING NOW.
	CALL GETIBI	;BP IN F TO FETCH CHARS TO TYPE, STARTING AT IN.
	MOVEI TT,VBDL	;CALL VBDL TO "OUTPUT" A LINE.
	MOVEM TT,CHCTAD
	MOVE TT,TOPLIN	;START "PRINTING" WHERE WE WILL LATER REALLY START PRINTING.
	MOVEM TT,CHCTVP
	MOVEM IN,LINBEG(TT)
VBD0:	CAMN IN,PT	;REACHED PT =>
	 JRST VBDPT	;CHECK WHETHER THIS WINDOW IS OK.
VBDPT2:	CAMN IN,ZV	;(COMES BACK IF CAN'T TELL YET,
			;NEAR END OF SCREEN BUT OK IF END OF BUFFER FITS)
	 JRST VBD3	;AT END, SEE IF MADE IT ON TO SCREEN.
	CAMN IN,GPT	;IF AT GAP, MOVE BP OVER IT.
	 CALL FEQGAP
	ILDB CH,F
	ADDI IN,1
	CALL DISAD2	;OUTPUT NEXT CHAR.
	SKIPL MORFLF
	 JRST VBD0
	JRST VBDNEW	;OFF END OF SCREEN AND PT TOO LOW.

VBD3:	MOVE TT,CHCTVP	;REACHED ZV BEFORE FLUSHING,
	CAMN TT,BOTLIN	;WINDOW OK IF ZV IS ON SCREEN ABOVE --MORE-- LINE
	CAMN T,CHCTHP	;OR IF ZV IS ON IT BUT NO CHARS TYPED ON IT
	CAIA
	 JRST VBDNEW

;REACHED PT DURING VBD0 LOOP.
VBDPT:	SKIPGE GEA	;STARTED FROM SCRATCH LAST TIME =>
	 JRST VBDDWN	;ZERO IN ON BEST WINDOW.
	CAMN A,BEGV	;UNLESS WE STARTED AT START OF BUFFER,
	 JRST VBDPT1
	MOVE TT,RRTOPM
	CAMLE TT,CHCTVP	;SHOULDN'T HAVE PT < %TOP PERCENT OF SCREEN FROM TOP.
	 JRST VBDNEW
VBDPT1:	MOVE AA,CHCTVP	;MIGHT BE OK, REMRMBER # OF LINE WITH PT.
	CAMN AA,BOTLIN	;IF WE'RE ON THE --MORE-- LINE
	CAMN T,CHCTHP	;WE'RE REALLY OFF BOTTOM, BAD WINDOW.
	CAIA
	 JRST VBDNEW
	CAML AA,RRBOTM	;NOT IN LAST %BOTTOM PERCENT OF SCREEN OR
	CAMN IN,ZV	;ALREADY AT BUFFER END =>
	 JRST VBDOK	;CAN'T BE TO NEAR BOTTOM.
	CALL DISBAR
	JRST VBDPT2	;ELSE SEE IF END OF BUFFER FITS ON SCREEN.

;CHCT CALLS HERE WITH EACH LINE DURING VBDTRY.
;SETS UP THE LINBEG ENTRY FOR THE LINE.
;LEAVES HORIZ POS. START OF NEXT LINE IN T.
VBDL:	MOVE Q,CHCTVP
	CAIL Q,MXNVLS	;DETECT FAILURE TO TERMINATE LOOP
	 .VALUE
	MOVE T,CHCTNL
	MOVEM T,LINBEG+1(Q)
	MOVE T,CHCTHP	;REMEMBER H.P. AFTER LINE.
	DPB T,[331100,,LINBEG+1(Q)]
	MOVE TT1,GEA	;IF GOING TO GO TO VDBDWN,
	AOJE TT1,CPOPJ	;MAKE SURE ALL THE LINE'S STARTS ARE STORED.
	CAMN Q,BOTLIN	;AT BOTTOM OF SCREEN =>
	 SETOM MORFLF	;STOP THE LOOP AT VBDTRY.
	POPJ P,

;START FROM SCRATCH, FIGURING OUT A NEW WINDOW.
VBDNEW:	SETOM GEA	;SO NEXT TIME REACH VBDPT WON'T COME HERE AGAIN.
	SKIPGE DISTRN
	 JRST VIEW2A	;IN TRUNCATE MODE, EVERYTHING EASIER.
	CALL CHCTI0
	MOVE A,VSIZE	;PRETEND WE'RE STARTING AT MIDDLE OF SCREEN.
	IMUL A,%CENTER
	IDIVI A,100.
	SKIPGE A
	 SETZ A,
	MOVE T,VSIZE
	CAMG T,A
	 MOVEI A,-1(T)
	ADD A,TOPLIN
	MOVEM A,CHCTVP
	SETZB T,MORFLF
	MOVE F,PT
	CAMN F,BEGV	;IF PT = BEGV, WINDOW MUST START AT BEGV.
	 JRST [	MOVE A,F
		JRST VBDOK]
	MOVEI B,CPOPJ	;TELL DISAD NOT TO DO ANYTHING WITH THE LINES IT CONSTRUCTS.
	MOVEM B,CHCTAD
	MOVE TT,VSIZE
	IMUL TT,%END
	IDIVI TT,100.
	SAVE CHCTVP	;SAVE TOPLINE+#CENTER.
	SAVE TT		;REMEMBER #END (TOTAL*%END/100)
	IMUL TT,NHLNS	;ARE WE WITHIN #END*WIDTH*2 CHARS OF END OF BUFFER?
	LSH TT,1
	ADD TT,F
	CAMGE TT,ZV	;IF SO, DON'T LEAVE MORE THAN #END BLANK LINES AT BOTTOM.
	 JRST VBDN4	 ;IF NOT, ASSUME WE WON'T LEAVE THEM & DON'T WASTE TIME.
	CAMN F,ZV	;WE'RE AT END OF BUFFER =>
	 JRST [SOS IN,F	   ;NEED FULL SCREEN ABOVE PT.
		CALL GET   ;IF LAST CHAR ISN'T LF,
		CAIE CH,^J ;MAKE SURE THE LAST UNTERMINATED LINE
		 AOS CHCTVP ;DOESN'T END UP OFF SCREEN BOTTOM.
		JRST VBDN2]
	CAMLE F,GPT
	 ADD F,EXTRAC
	CALL GETIBP	;SEE HOW MANY LINESOF TEXT THERE ARE BETWEEN PT AND BUFFER END.
	MOVE IN,PT
	CALL DISBAR	;STARTING AT THE PTR SO MAKE CURSOR.
	MOVE C,BOTLIN	;IF WE GET DOWN TO VPOS = TOTAL-#END, WE CAN PUT CURSOR
	SUB C,(P)	;AT THE USUAL PLACE (#CENTER), SO STOP COUNTING LINES.
VBDN1:	CAMN IN,ZV
	 JRST VBDN2	;ALL USED UP, SEE HOW MANY LINES THAT MADE.
	CAMG C,CHCTVP
	 JRST VBDN4
	CAMN IN,GPT	;WHEN AT GAP, MOVE BP OVER GAP.
	 CALL FEQGAP
	ILDB CH,F
	ADDI IN,1
	CALL DISAD2
	JRST VBDN1

VBDN2:	MOVE B,CHCTVP	;REACHED END OF BFR WITHOUT REACHING VPOS = TOTAL-#END.
	CAME T,CHCTHP	;MAYBE WE STARTED ANOTHER LINE NOT COUNTED IN VPOS. COUNT IT TOO
	 JRST [	CAME B,BOTLIN ;UNLESS IT'S REALLY OFF
		 AOS B		;BOTTOM OF SCREEN.
		JRST .+1]
	SUB B,A		;# LINES WE PRINTED IN VBDN1 LOOP.
	ADD B,(P)	;PLUS MAX # BLANK LINES TO LEAVE BELOW THEM,
	MOVNS B		;GIVES MAX # LINES WE CAN ALLOW BELOW PT.
	ADD B,BOTLIN	;SUBTRACT FROM WINDOW BOTTOM TO GIVE MIN VPOS FOR PT.
	MOVEM B,-1(P)	;(SMALLER THAN AND INSTEAD OF TOPLIN+#CENTER WHICH WE SAVED).
VBDN4:	SUB P,[1,,1]	;NO LONGER NEED #END.
	MOVNS B,(P)	;GET BACK #CENTER OR CORRECTED # OF LINES WE WANT ABOVE PT.
	ADD B,TOPLIN	;-<# LINES NEEDED ABOVE PT>
	SAVE B
	CALL GETAG7	;MOVE UP THAT MANY LINES FROM PT.
	 JFCL
	REST B
	SOJ B,		;(IN CASE B IS 0)
	IMUL B,NHLNS	;# CHARS TO MAKE THAT MANY CONTINUATION LINES.
	ADD B,PT
	CAMGE C,B	;START AT WHICHEVER PLACE COMES LATER.
	 MOVE C,B
	MOVE IN,C	;(WE MIGHT HAVE GONE UP MORE LINES THAN WE WANTD TO)
	REST B		;- MINIMUM VPOS WE WANT PT TO APPEAR AT.
	JRST VBDTRY

VBDDWN:
IFN RMSSW,[
	MOVE TT,CHCTVP
	SKIPE DISPRR
	 MOVEM TT,RRVPOS
]
	ADD B,CHCTVP	;(B STILL HAD - # LINES WANTED ABOVE PTR)
	JUMPLE B,VBDOK	;NOT MORE THAN MAX, OK.
	LDB A,[3300,,LINBEG(B)]
	JRST VBDOK	;ELSE FIND 1ST CHAR ON THE LINE WE SHOULD START WITH.

;COME HERE WHEN WE HAVE A WINDOW WE KNOW IS OK, TO DO THE ACTUAL DISPLAY.
;A HAS THE CHAR ADDR OF 1ST CHAR OF WINDOW.
VBDOK:	CALL DELQIT	;CLEAR IMQUIT, QUITTING IF REQUESTED.
	REST IMQUIT
	SAVE BOTLIN
	CALL DISINI	;THIS WINDOW IS OK!
	REST BOTLIN	;DISINI RESETS BOTLIN.
	SETOM VREMEM
	MOVE IN,A
	MOVE TT,TOPLIN
	MOVEM TT,CHCTVP
	MOVEM A,LINBEG(TT)
	.I GEA=A-BEGV
VBDOK3:	MOVEM IN,CHCTBL	;REMEMBER CHAR ADDR START OF 1ST LINE
			;(DISAD WILL SET CHCTBL FOR LATER LINES)
	CALL GETIBI
VBDOK1:	SKIPN MORFLF
	 SKIPGE ORESET	;STOP IF FLUSHED OR QUITTING.
	  JRST DISCLG
	CAMN IN,ZV	;STOP IF NO MORE CHARS.
	 JRST DISCLG
	CAMN IN,PT	;OUTPUT THE CURSOR IF BEFORE PT.
	 CALL DISBAR
	CAMN IN,GPT	;IF AT GAP, MOVE B.P. IN F OVER IT.
	 CALL FEQGAP
	MOVE TT,CHCTHP
	CAME TT,NHLNS	;IF ABOUT TO CONTINUE A LINE
	 SKIPN DISBFC	 ;OR IF THE BUFFER IS FULL,
	  JRST VBDSLO	;OUTPUT 1 CHARACTER SLOWLY TO CONTINUE OR EMPTY THE BUFFER.
	SKIPGE DISTRN
	 JRST VBDSLO
	SKIPE CASDIS	;IF WE NEED CASE-FLAGGING, OR
	 JRST VBDSLO
	SKIPL CHCTCF	;IF WE HAVE AN UNPROCESSED CR,
	 JRST VBDFAS	;MUST GO THRU DISAD SINCE ONLY DISAD KNOWS HOW TO HACK ONE.
VBDSLO:	ILDB CH,F
	AOS IN
VBDSL1:	.I RRCCHP=CHCTHP
	CALL DISAD2	;OUTPUT THE CHAR.
	JRST VBDOK1

;IF WE GET HERE, WE KNOW WE CAN GO AT LEAST 1 CHAR BEFORE REACHING PT, GPT, ZV,
;THE RIGHT MARGIN, OR THE END OF DISBUF.
VBDFAS:	MOVE OUT,F
	MOVE F,ZV	;CONSIDER PT, GPT AND ZV;  F GETS WHICHEVER IS SMALLEST
	CAMGE IN,GPT
	 CAMG F,GPT
	  CAIA
	   MOVE F,GPT	;YET BEYOND WHERE IN IS NOW.
	CAMGE IN,PT
	 CAMG F,PT
	  CAIA
	   MOVE F,PT
	SOS F		;CONVERT CHAR ADDR IN F TO THE B.P. TO LDB THE PREVIOUS CHAR.
	CALL GETIBV
	IBP F		;(GETIBV FOLLOWED BY IBP = GETBV).
	EXCH OUT,F
	MOVE A,NHLNS
	SUB A,CHCTHP	;A GETS # COLUMNS LEFT ON THIS LINE.
	MOVE C,CHCTHC	;C IS WHERE WE ACCUMULATE THE CHECKSUM.
VBDFLP:	ILDB CH,F
	XCT VBDTBL(CH)	;FOR FUNNY CHARS, GO SOMEPLACE ELSE.
VBDNRM:	ROT C,7
	ADDI C,(CH)	;UPDATE THE HASH CODE OF THE LINE.
	IDPB CH,CHCTBP	;STORE CHAR INTO OUTPUT.
VBDTRT:	CAME F,OUT	;STOP IF REACH PT, GPT OR ZV.
	 SOJG A,VBDFLP	 ;STOP IF REACH RIGHT MARGIN.
	SKIPE A		;IF THE CAM SKIPPED, DO THE SOJ ANYWAY.
	 SOS A
;HERE EITHER IN = PT,GPT OR ZV, OR ELSE WE ARE ABOUT TO CONTINUE A LINE.
;SO VBDOK1 IS GUARANTEED TO DO 1 CHAR THE SLOW WAY BEFORE VBDFAS IS REACHED.
VBDOUT:	CALL VBDSTO	;STORE BACK CHCTHC, CHCTHP, AND IN
	JRST VBDOK1

VBDTBL:	JRST VBDLOS	;^@
REPEAT 6,JRST VBDCTL	;^A THRU ^F
	JRST VBDLOS	;^G - ALWAYS 2-POS
	JRST VBDBS	;^H
	JRST VBDTAB	;^I
	JRST VBDLF	;^J
REPEAT 2,JRST VBDCTL	;^K, ^L
	JRST VBDCR	;^M
REPEAT 13.,JRST VBDCTL	;^N THRU ^Z
	JRST VBDALT	;ALTMODE
REPEAT 4,JRST VBDCTL	;^\ THRU ^_
REPEAT 137,JFCL		;NORMAL GRAPHICS CHARACTERS
	JRST VBDLOS	;RUBOUT COMES OUT AS ^?.
IFN .-VBDTBL-200,.ERR WRONG TABLE LENGTH

VBDSTO:	MOVNS A
	ADD A,NHLNS	;A GETS UPDATED CHCTHP
	EXCH A,CHCTHP
	SUB A,CHCTHP	;OLD CHCTHP MINUS NEW CHCTHP (A NEGATIVE NUMBER)
	ADDM A,DISBFC	;IS ALSO - <# OF CHARS IDPB'D>.
	MOVEM C,CHCTHC
	SAVE F
	CALL GETCA
	AOS IN,F
	CAMLE IN,GPT
	 SUB IN,EXTRAC
	REST F
	RET

VBDCR:	SETOM CHCTCF	;CR => SET FLAG FOR NEXT CHAR AND HANDLE IT WITH DISAD.
	JRST VBDOUT

VBDCTL:	SKIPE DISSAI	;MOST CONTROL CHARS ARE NORMAL IN SAIL MODE, LOSING OTHERWISE.
	 JRST VBDNRM
VBDBS:: VBDLF::
VBDLOS:	CALL VBDSTO	;HERE FOR A CHAR THAT MUST BE HANDLED WITH DISAD.
	JRST VBDSL1	;WE KNOW THAT IN DOESN'T = PT, GPT, OR ZV, OR WE WOULN'T HAVE
		;GOT EVEN THIS FAR, SO IT'S SAFE TO GO STRAIGHT TO VBDSLO.

VBDALT:	MOVE TT,TTYOPT
	TLNN TT,%TOSAI
	 MOVEI CH,"$
	JRST VBDNRM

VBDTAB:	.I NHLNS-A	;COMPUTE CURRENT CHCTHP IN TT
	MOVEI CH,40	;OUTPUT SPACES
VBDTA1:	IDPB CH,CHCTBP
	ROT C,7
	ADDI C,(CH)
	AOS TT		;INCREMENTING THE HPOS
	TRNE TT,7	;TILL WE REACH A TAB STOP.
	 CAMN TT,NHLNS
	  CAIA
	   JRST VBDTA1
	MOVE A,NHLNS
	SUB A,TT
	AOJA A,VBDTRT	;RE-ENTER NORMAL LOOP, EXIT IF REACHED OBSTACLE.

VBDACU:	SKIPN TSALTC	;UPDATE TSALTC (IN CASE DDT HAS FLUSHED
	 SKIPE TSINAL	;THE $$'S THAT INT'D US) (SKIP IF ENDS UP 0)
	  CAIA
	   JRST POPJ1
	SYSCAL LISTEN,[1000,,TYIC ? 2000,,CH]
	 POPJ P,
	JUMPN CH,CPOPJ
	SETZM TSALTC	;NO INPUT CHARS WAITING => NO $$'S.
	SETZM TSINAL	;AND NO STRAY $.
	HRROS LTYICH
	JRST POPJ1

VIEW2A:	MOVE B,VSIZE
	ADDI B,1	;(IF B ODD, WANT LINE WITH PT CENTERED)
	LSH B,-1
	PUSHJ P,GETAG7	;GET 1 + LAST CHAR ADR TO PRINT IN C
	 JFCL
	MOVN B,VSIZE
	CAMN IN,BEGV	;IF BUFFER NOT EMPTY,
	 JRST VIEW2B
	SOS IN
	CALL GETINC	;LOOK AT LAST CHAR, NOT CHANGING IN.
	CAIE CH,^J	;IF NOT LF, IT COUNTS AS A LINE.
	 AOS B
VIEW2B:	PUSHJ P,GETAG4	;THEN MOVE 2*N BACKWARD FROM THERE, GET 1ST TO DISPLAY.
	 JFCL
	MOVE A,C	;DISPLAY AS MUCH AS WILL FIT.
	HRRM P,VIEWBF
	JRST VBDOK

BAKSL:	TRZE FF,ARG
	JRST BAKS1A
	MOVE IN,PT
	PUSHJ P,GETINC
	CAIE CH,"-
	JRST BAKSL7
	TRO FF,ARG
BAKSLA:	PUSHJ P,GETINC
BAKSL7:	CAMLE IN,ZV
	JRST BAKSL3
BAKSL6:	CAIN CH,".
	JRST BAKSL5
	CAIG CH,"9
	CAIGE CH,"0
	SOJA IN,BAKSL2
	JFCL 10,.+1
	MOVE A,SYL
	IMUL A,IBASE
	ADDI A,-60(CH)
	MOVEM A,SYL
	JFCL 10,[SETOM SYLOV  ?  JRST .+1]
	MOVE A,OSYL
	IMUL A,I.BASE
	ADDI A,-60(CH)
	MOVEM A,OSYL
	JFCL 10,[SETOM OSYLOV  ?  JRST .+1]
	JRST BAKSLA
BAKSL5:	MOVE A,OSYL
	MOVEM A,SYL
	MOVE CH,OSYLOV
	MOVEM CH,SYLOV
	JRST BAKSL2
BAKSL3:	MOVE IN,ZV
BAKSL2:	TRZE FF,ARG
	 MOVNS SYL
	MOVE A,SYL
	MOVEM IN,PT
	JRST POPJ1

BAKS1A:	MOVEI TT,40
	HRRM TT,DPT5
	SOS TT,C
	TRZE FF,ARG2
	 SKIPA F,[DPT1]
BAKSL1:	MOVEI F,DPT
	PUSHJ P,GAPSLP
	MOVE T,[(700)BAKTAB-1]
	MOVEI C,0
	MOVEI CH,[IDPB CH,T ? AOJA C,CPOPJ]
	HRRM CH,LISTF5
	PUSHJ P,(F)
	MOVEM C,INSLEN
	MOVEI B,(C)	;# CHARS FOR SLPGET TO INSERT.
	CALL SLPGET	;INSERT THEM, GET BP IN F.
	MOVE T,[440700,,BAKTAB]
BAKSLL:	ILDB B,T	;COPY THE PRINTED STUFF INTO INSERTED SPACE.
	IDPB B,F
	SOJG C,BAKSLL
	POPJ P,

;SEMICOLON AND ITERATIONS.

SEMICL:	SKIPN ITRPTR
	 TYPRE [SNI]
	TRNN FF,ARG
	MOVE B,SFINDF
	TRNE FF,COLONF
	 SETCA B,
	JUMPL B,CD
INCMA0:	MOVEI CH,">	;"TRACE" A ">" TO HELP USER UNDERSTAND.
	CALL TRACS
	MOVEI A,0
INCMA1:	SETOM BRC1
	SKIPG COMCNT
	 JRST [	HRRO A,ITRPTR
		CALL ITRPOP
		TYPRE [UTI]]
	CALL SKRCH
	CAIN CH,"<
	 AOJA A,INCMA1
	CAIE CH,">
	 JRST INCMA1
	SOJGE A,INCMA1
	SETZM BRC1

;HERE THE CODE FOR ">", ";", "F;", AND ERRORS INSIDE ERRSETS,
;MERGES INTO ONE.
INCMA2:	HRRO A,ITRPTR	;PTR TO INNERMOST ITER OR ERRSET.
	HLRZ TT,ITRPTR	;TO INNERMOST ERRSET.
	MOVEI C,(A)
	CALL FSEMIP	;SKIP IF THIS ITERATION WAS A CATCH.
	 CAIN TT,(A)	;SKIP UNLESS IT WAS AN ERRSET.
	  SKIPA TT,[-1]	;TT HAS -1 IF CATCH OR ERRSET,
	   SETZ TT,	;0 FOR ORDINARY ITERATION.
	CALL ITRPOP	;POP THE ITERATION FRAME.
	JUMPE TT,CD	;FOR ORDINARY ITER'S, THAT'S ALL.
;EXITING A CATCH OR ERRSET: 1ST, WE MAY HAVE JUST UNWOUND
;AND NEED TO RESET PDLS. 2ND, WE MUST RETURN A VALUE SAYING
;WHETHER WE EXITED NORMALLY.
	TRZ FF,ARG+ARG2+OPFLG+SYLF+COLONF+SLSL
	AOS A,ERRFLG	;EXITING ERRSET, WAS THERE ERROR?
	JUMPN A,[SETZ A, ? JRST VALREC] ;RETURN 0 IF NO ERROR.
	HLRZ CH,B
	HRLI CH,1-PDL-LPDL(CH)
	CAME P,CH	;IF CH=P, SETP IS NOT NEEDED, AND RET. ADDR WOULD BE ABOVE P!
	 PUSHJ CH,SETP	;MOVE P,CH , CHECK FOR UNWINDING PARENS, SORT OR ^R, THEN POPJ P,
	HRLI B,1-PFL-LPF(B)
	CALL FSQPU0	;ON ERROR IN ERRSET, UNWIND QREG PDL
	MOVE A,LASTER
	JRST VALREC

;A CONTAINS ITRPTR'S RH; POP OFF AN ITERATION.
ITRPOP:	POP A,ITRPTR
	POP A,B
	POP A,(A)
	POP A,ITERCT
	MOVEI A,-MFICNT(A)
	JRST FLSFRM

GRTH:	SKNTOP ITRPTR
	TYPRE [UMC]
	SOSN ITERCT
	JRST INCMA2
	HRRO A,ITRPTR
	SUBI A,MFBLEN-MFCCNT-1
	POP A,COMCNT
	POP A,CPTR
	MOVEI CH,^M
	CALL TRACS
	MOVEI CH,^J
	CALL TRACS
	MOVEI CH,"<
	CALL TRACS
	JRST CD

FLSSTH:	SUB P,[1,,1]
LSSTH:	PUSHJ P,GETFRM
	MOVE TT,PF
	HRLI TT,(P)
INSIRP PUSH A,COMAX CPTR COMCNT ITERCT MACPDP TT ITRPTR
	HRRM A,ITRPTR	;STORE PTR TO INNERMOST ITER OR ERRSET.
	TRZE FF,COLONF	;IF THIS IS ERRSET, SET PTR TO
	 HRLM A,ITRPTR	;INNERMOST ERRSET.
	TRZE FF,ARG
	JRST LSSTH2
	SETOM ITERCT
	JRST CD
LSSTH2:	JUMPLE B,INCMA0
	MOVEM B,ITERCT
	JRST CD

CNTRLN:	SETOM GEA
	TRNE FF,ARG
	 MOVEM B,NLINES
	TRZN FF,COLONF
	POPJ P,
	AOSE TTMODE
	SETOM TTMODE
	POPJ P,

;<ARG>F;<TAG>$ - THROW TO <TAG>, RETURNING 1 (OR F;'S ARG, IF ANY) FROM THE F<...>.
FSEMIC:	TRZN FF,ARG
	 MOVEI B,1
	SAVE B
	CALL OARG	;READ <TAG> INTO STAB, WITH "!"'S.
;NOW LOOK AT ALL ITERATIONS, INNERMOST FIRST, FOR ONE WHICH
;IS A CATCH WITH THE APPROPRIATE TAG.
	HRRZ C,ITRPTR
FSEMI1:	JUMPE C,[TYPRE [UCT]]	;UNSEEN CATCH TAG.
	CALL FSEMIP	;IS THIS ITERATION A CATCH?
	 JRST FSEMI2	;NO, LOOK AT NEXT ONE OUT.
	IBP F
	MOVEI E,STAB	;YES, COMPARE ITS TAB WITH <TAG>.
	MOVE A,MFCCNT-MFBLEN+1(C)
FSEMI3:	SOJL A,FSEMI2	;F< TAG ENDED TOO SOON - MISMATCH.
	ILDB TT,F
	CAIL TT,"A+40	;CONVERT L.C. LETTERS TO U.C.
	 CAILE TT,"Z+40
	  CAIA
	   SUBI TT,40
	CAME TT,(E)
	 JRST FSEMI2	;THE CHARS DIFFER.
	ADDI E,1	;ADVANCE TO NEXT CHAR IN <TAG>
	CAME E,D
	 JRST FSEMI3
;WE'VE FOUND A CATCH WITH OUR TAG!
	REST LASTER	;VALUE TO BE RETURNED FROM F<...>, WHERE ERRP3 WANTS IT.
	SETOM ERRFLG	;FAKE INCMA2 INTO RETURNING NEGATIVE.
FSEMI4:	HRRO A,ITRPTR	;POP OFF ALL ITERATIONS INSIDE THE
	CAIN C,(A)	;CATCH WE'RE POPPING TO.
	 JRST [	HRLM C,ITRPTR	;THEN PRETEND THIS CATCH WAS AN ERRSET
		JRST ERRP3]	;AND ERR OUT OF IT.
	CALL ITRPOP
	JRST FSEMI4

;COME HERE IF ITERATION ISN'T A CATCH, OR HAS WRONG TAG.
FSEMI2:	HRRZ C,MFLINK-MFBLEN+1(C)
	JRST FSEMI1

;C -> AN ITERATION FRAME. SKIP IF THAT ITERATION IS REALLUY A
;CATCH. IN THAT CASE, RETURN IN F B.P. TO ILDB THE "<".
FSEMIP:	MOVE F,MFCMAX-MFBLEN+1(C)
	SUB F,MFCCNT-MFBLEN+1(C)
	CAIGE F,2	;DON'T LOOK WHERE THERE ARE NO CHARS.
	 RET
	MOVE F,MFCPTR-MFBLEN+1(C)
	SUBI F,1	;BACK UP F BY 2 CHARS.
REPEAT 3,IBP F
	ILDB B,F	;FETCH THE CHAR BEFORE THE "<"
	CAIE B,"F+40
	 CAIN B,"F	;IF IT'S "F", THIS ITERATION'S A CATCH.
	  AOS (P)
	RET

;^P SORT.
PSORT:	ISKERR		;CAN'T SORT WITHIN SORT.
	SAVE FF		;REMEMBER COLONF (PSI SETS IT)
	MOVE CH,[JRST [
	 CALL RCH	;READ CHAR,
	 SKIPGE SQUOTP	;SUPERQUOTED =>
	  JRST INSDIR	;JUST INSERT.
	 CAIE CH,"$	;ELSE REPLACE $ BY ALTMODE
	  JRST INSDCK
	 MOVEI CH,ALTMOD
	 JRST INSDIR]]	;AND CHECK FOR DELIMITER UNLESS DELIM PROTECTED.
	MOVEM CH,INSRCH
	MOVE CH,QRB..
	ADDI CH,.QKS	;GET ARGS
	CALL PSI	;IN PSEUDO Q-REGS
	MOVE CH,QRB..
	ADDI CH,.QKE
	CALL PSI
	MOVE CH,QRB..
	ADDI CH,.QDL
	CALL PSI
	CALL MEMTOP
	MOVEM P,PSSAVP	;INDICATE A SORT IS IN PROGRESS.
	MOVEM A,PSMEM
	MOVEM A,PSMEMT
	MOVE T,A
	SETZM PSZF
	MOVE TT,ZV
	SUB TT,BEGV	;# CHARS IN RANGE BEING EDITED.
	JUMPE TT,PSXIT	;SORTING NO CHARS IS NOOP.
	IMULI TT,LPSDBK	;MAX # WDS IN PTR TBL
	ADD TT,T	;MAX ADDR OF PTR
	MOVEM TT,PSMXMT
	MOVE B,BEGV	;START FROM BEGINNING
	MOVEM B,PT
;DROPS THROUGH.

;DROPS THROUGH.
;LOOP HERE TO DELIMIT THE NEXT RECORD AND ITS KEY.
PS4:	CAML T,PSMXMT
	 TYPRE [TMR]
	SUB B,BEG	;KEEP ALL ADDRS RELATIVE TO BEG IN CASE QREGS MOVE BUFFER.
	MOVEM B,2(T)	;3RD WORD OF POINTER: CHAR ADDR OF RECORD.
	PUSH P,B
	MOVE A,QRB..
	MOVE A,.QKS(A)	;FIND BEGINNING OF KEY
	CALL MACXQ
	MOVE T,PSMEMT
	MOVE B,PT
	SUB B,BEG	;FOR NOW, KEEP CHAR ADDR REL BUFFER, WILL CHANGE TO BP LATER.
	PUSH P,B
	MOVEM B,(T)	;IS 1ST POINTER WORD
	MOVE A,QRB..
	MOVE A,.QKE(A)	;FIND END OF KEY
	PUSHJ P,PS2
	MOVEM B,1(T)	;-#CHARS IN KEY FOR RH(2ND WORD OF TABLE ENTRY)
	MOVE A,QRB..
	MOVE A,.QDL(A)	;FIND NEXT RECORD
	PUSHJ P,PS1
PS7:	MOVNS B
	HRLM B,1(T)	;-LENGTH OF RECORD FOR AOBJN
	ADDI T,LPSDBK	;NEXT POINTER
	MOVEM T,PSMEMT
	MOVE B,PT
	SKIPL PSZF	;DID WE RUN OUT
	 JRST PS4	;NO
	MOVE A,ZV
	MOVEM A,PT
	CALL GAPSLP
	MOVEI B,20.	;MAKE SURE THERE'S A GAP AFTER RANGE BEING
	CALL SLPSAV	;SORTED, SO BLT OF SORTED STUFF WON'T CLOBBER A FEW CHARS.
	MOVE A,PSMEM	;LOWER BOUND
	MOVE AA,PSMEMT	;UPPER BOUND.
PS7A:	CAMN A,AA	;NOW CONVERT ADDRS REL. TO BEG TO WHAT WE REALLY WANT.
	 JRST PS7B	;ALL RECORDS HANDLED.
	MOVE C,(A)	;GET ADDR START OF KEY,
	ADD C,BEG
	IDIVI C,5	;CONVERT TO BP. TO 1ST BIT.
	ADD C,BTAB-1(D)
	TLZ C,17
	MOVEM C,(A)
	ADDI A,LPSDBK
	MOVE C,A
	SUB C,PSMEM
	MOVEM C,-1(A)	;MAKE ENTRY'S 3RD WD POINT TO NEXT ENTRY.
	JRST PS7A	;DO NEXT RECORD.

PS1:	SKIPGE PSZF	;ALREADY AT END => NOOP INSTEAD OF USER'S MACRO.
	 JRST PS2A
PS2:	SETOM SFINDF
	CALL MACXQ
PS2A:	MOVE T,PSMEMT
	POP P,D	;RETURN POINT
	POP P,C	;OLD PT-BEG
	ADD C,BEG
	MOVE B,PT
	SKIPL SFINDF	;IF SEARCH FAILED
	SKIPA B,ZV	;WE'RE AT THE END
	CAML B,ZV	;OTHERWISE CHECK
	SETOM PSZF	;DONE, SET FLAG
	SUB B,C	;# CHARS IN B
	JRST (D)

;RETURN IN A A PTR TO THE 1ST UNUSED WORD OF HIGH MEM.
MEMTOP:	MOVE A,BFRTOP
	IDIVI A,5
	SUBI  A,3
	SKIPE PSSAVP
	 MOVE A,PSMEMT
	ADDI A,4
	POPJ P,

PS7B:	SETOM -1(A)	;LAST ENTRY'S LINK WORD IS NIL.
	MOVE A,(P)	;RESTORE COLONF AS IT WAS AT CALL TO PSORT.
	TRNE A,COLONF
	 IORI FF,COLONF
	HRRZ D,PSMEMT	;DYNAMICALLY ALLOCATED PDL
	PUSHJ D,PS3	;SORT POINTERS
	MOVE T,BEGV	;SET UP FOR LATER BLT
	IDIVI T,5
	HRRM T,D	;DESTINATION = WORD CONTAINING BEGV
	MOVE CH,(T)	;MUST HAVE CHARS BEFORE BEGV IN WD
	HLL B,BTAB-1(TT)	;GET BPT TO NEW BUFFER AREA
	TLZ B,77
	HRR B,PSMEMT	;WHICH OVERWRITES SORT PDL
	HRLM B,D	;SOURCE FOR BLT
	MOVEM CH,(B)	;SAVE CHARS
PS6:	ADD A,PSMEM	;CHANGE REL PTR TO ABS, -> NEXT TAB ENTRY.
	HLRE C,1(A)	;- # CHARS IN RECORD.
	JUMPE C,PS5
	MOVE F,2(A)	;CHAR ADDR START OF RECORD.
	ADD F,BEG
	CALL GETIBP
PS6A:	ILDB CH,F	;MOVE THE RECORD.
	IDPB CH,B
	AOJL C,PS6A
PS5:	MOVE A,3(A)	;GET PTR TO NEXT RECORD'S ENTRY.
	JUMPGE A,PS6	;IF THERE IS ANOTHER, LOOP BACK.
	MOVE A,ZV
	IDIVI A,5
	BLT D,1(A)	;DONE, MOVE IT DOWN
	CALL FLSCOR
PSXIT:	SETZM PSSAVP	;TURN OFF SORT FLAG.
	MOVE A,BEGV
	MOVEM A,PT
	JRST POP1J
;ACTUALLY SORT THE LIST OF SORT TABLE ENTRIES,
;BY REARRANGING THE LINK WORDS SO THAT THEY ARE LINKED
;IN SORTED ORDER.
PS3:	SETZ C,		;POINT TO THE HEAD OF THE LIST O SORT.
	MOVE B,PSMEMT	;B _ LENGTH(C)
	SUB B,PSMEM
	LSH B,-2

;(DEFUN NSORT (N) (COND ((= N 1) (CHOP1))
;		(T (MERGE (NSORT (/ N 2)) (NSORT (- N (/ N 2)))))))
;C HOLDS L, B HOLDS N, D USED AS PDL PTR, VALUE RETURNED IN A.
PS3NSORT:	CAIN B,1
	 JRST PS3NS1
	PUSH D,B
	LSH B,-1		;THIS IS N/2
	PUSHJ D,PS3NSORT ;(NSORT (/ N 2))
	POP D,B
	PUSH D,A
	AOJ B,
	LSH B,-1	;(- N (/ N 2))
	PUSHJ D,PS3NSORT ;(NSORT (- N (/ N 2)))
	POP D,B		;A, B HAVE ARGS TO MERGE.
	MOVEI AA,E	;AA -> TAIL OF ACCUMULATED MERGED LIST,
			;E WILL EVENTUALLY POINT TO ITS HEAD.
PS3MRG:	JUMPL B,PS3TK1	;1ST ARG EMPTY => TAKE FROM 2ND.
	JUMPL A,PS3TKB	;2ND EXHAUSTED => TAKE FROM FIRST.
	MOVE TT,PSMEM	;ELSE GET PTRS TO AND SIZES OF THE KEYS
	MOVE TT1,PSMEM
	ADD TT,A	;BELONGING TO THE HEADS OF 1ST AND 2ND ARG.
	ADD TT1,B
	TRNE FF,COLONF	;^ ^P - SORT IN REVERSE ORDER.
	 EXCH TT,TT1
	MOVE CH,(TT)	;CH IS BP TO ILDB KEY OF 2ND,
	MOVE Q,(TT1)	;Q, FOR 1ST.
	HRRE TT,1(TT)	;# CHARS IN KEY OF 2ND,
	HRRE TT1,1(TT1)	;SAME FOR 1ST.
;COMPARE THE KEYS, GO TO PS3TKA IF 2ND KEY IS LESS, ELSE PS3TKB.
PS3CMP:	SOJL TT1,PS3TKB	;FIRST KEY ENDED, IT IS .LE., SO USE IT.
	SOJL TT,PS3TKA	;2ND KEY ENDED, IT IS .L., TAKE 2ND.
	ILDB T,CH	;ELSE LOOK AT NEXT CHAR OF EACH.
	ILDB F,Q
	SKIPN PSCASE	;IF WE SHOULD IGNORE CASE,
	 JRST PS3CM1
	CAIGE T,"A+40
	 JRST PS3CM2
	CAIG T,"Z+40
	 SUBI T,40
PS3CM2:	CAIGE F,"A+40
	 JRST PS3CM1
	CAIG F,"Z+40
	 SUBI F,40
PS3CM1:	CAIN T,(F)
	 JRST PS3CMP	;CHARS EQUAL => KEEP LOOKING.
	CAIG T,(F)
	 JRST PS3TKA	;CHAR FROM 2ND IS LESS, TAKE 2ND.
PS3TKB:	MOVEM B,(AA)	;"TAKE 1ST"; ENTRY AT HEAD OF 1ST ARG
	ADD B,PSMEM	;IS LESS THAN THAT AT HEAD OF 2ND, SO
	MOVEI AA,3(B)	;TRANSFER IT TO TAIL OF MERGED LIST
	MOVE B,(AA)	;AND ADVANCE DOWN THE 1ST ARG.
	JRST PS3MRG

PS3TKA:	MOVEM A,(AA)	;"TAKE 2ND"; LIKE "TAKE 1ST" BUT FOR 2ND ARG.
	ADD A,PSMEM
	MOVEI AA,3(A)
	MOVE A,(AA)
	JRST PS3MRG

PS3TK1:	JUMPGE A,PS3TKA	;1ST EXHAUSTED; 2ND ISN'T => TAKE 2ND.
	SETOM (AA)	;BOTH ARGS EXHAUSTED => MERGE FINISHED, TERMINATE LIST.
	MOVE A,E	;RETURN VALUE IN A.
	POPJ D,

PS3NS1:	MOVEI A,(C)	;(NSORT 1) COMES HERE.
	ADD C,PSMEM	;RETURN THE HEAD OF LIST TO BE SORTED,
	MOVE T,C
	MOVE C,3(T)	;REPLACING THAT LIST WITH ITS CDR,
	SETOM 3(T)	;AND MAKING THE HEAD'S CDR NIL.
	POPJ D,

ECMD:
IFN TS,	TLO FF,CTLUF
	PUSHJ P,LRCH
	CAIN CH,^U
	 JRST EUHACK
	CAIGE CH,"?	;IF CHARACTER BEYOND "?, DISPATCH ON IT.
	 TYPRE [IEC]
	XCT ETAB-"?(CH)

IFN TS,[

ASLEEP:	CALL IMMQIT
	TRZE FF,COLONF
	 JRST ASLEE1
	TRZE FF,ARG
	 .SLEEP B,
	JRST DELQIT

ASLEE1:	AOS (P)		;<DUR>:^S 1) RETURNS RESULT OF FS LISTEN$
ASLEE4:	TRZ FF,ARG	;         2) SLEEPS ONLY AS LONG AS THERE IS NO INPUT AVAIL.
	SKIPL UNRCHC
	 SKIPA A,[1]
	  .LISTEN A,
	JUMPN A,DELQIT
	JUMPE B,DELQIT
	CALL TTYAC2
ASLEE2:	.SLEEP B,
	JRST ASLEE4

EASSIGN:	CALL GDEV
	LDB B,[220300,,UTF]
	.ASSIGN B,
	 TYPRE [UNA]
	RET

EDESINE:	CALL GDEV
	LDB B,[220300,,UTF]
	.DESIGN B,
	 TYPRE [UNA]
	RET

MTNAM:	CALL GDEV
	MOVE OUT,[440600,,IN]
	HLRZ IN,UTF
	MOVEI IN,-(SIXBIT /UT0/)(IN)
MTN1:	CALL LRCH
	SKIPE SQUOTP
	 JRST MTN3
	CAIN CH,ALTMOD
	 JRST MTN2
MTN3:	SUBI CH,40
	JUMPE CH,MTN1
	TLNN OUT,550000
	 JRST MTN2
	IDPB CH,OUT
	JRST MTN1

MTN2:	.UTNAM IN,
	 TYPRE [UTL]
	POPJ P,

EQMRK:	CALL FFRRDD	;E?<FILE>$ 0 IF FILE EXISTS, ELSE ERROR CODE.
	MOVE A,[.BAI,,FDRC]
	CALL IMMQIT
	.CALL RREDB	;TRY TO OPEN;  A GETS 0 OR I.T.S. ERROR CODE
	 EQVI A,1000	;TURN ITS ERROR CODE INTO TECO ERROR CODE (-(1000+ITS CODE))
	SETZM IMQUIT
	.CLOSE FDRC,
	JRST POPJ1

EGET:	PUSH P,LISTF5
	MOVEI A,TYOM
	HRRM A,LISTF5
	CALL GAPSLP
	TLZ FF,CTLUF	;EGET TO INSERT IN THE BUFFER
	PUSHJ P,GDATIM
	JFCL
	PUSHJ P,GLPDTM
	SKIPG C,DATE	;THE DATE
	 SETZ C,	;IF SYSTEM DOESN'T KNOW DATE, USE 6 SPACES.
	CALL TYPR
	CALL CRR1
	SKIPG C,TIME
	 SETZ C,
	CALL TYPR	;INSERT TIME FROM SIXBIT WORD,
	CALL CRR1
	MOVE A,UTSNM	;THE CURRENT SYSTEM NAME
	PUSHJ P,SIXINS
	CALL LFILE	;INSERT CURRENT DEFAULT FILE NAMES.
	CALL CRR1
	TLNN FF,UREAD	;THE NAMES OF THE FILE OPEN FOR READING (IF ANY)
	JRST EGET2	;(NONE, LEAVE BLANK LINE - EVENTUALLY REPLACE THIS CRUFT WITH .RCHST)
	MOVE A,ERSNM
	MOVEI B,";
	PUSHJ P,SIXINT
	MOVE A,ERDEV
	MOVEI B,":
	PUSHJ P,SIXINT
	MOVE A,RUTF1
	MOVEI B,40
	PUSHJ P,SIXINT
	SKIPA A,RUTF2
EGET2:	SETZI A,
	PUSHJ P,SIXINS
	SKIPL TIME
	PUSHJ P,SYMDAT	;THE DATE IN STANDARD SYMBOLIC FORM
	PUSHJ P,CRR1
	LDB CH,[320300,,YEAR]	;A THREE DIGIT NUMBER
	PUSHJ P,DGPT	;FIRST DIGIT DAY OF WEEK (0 => SUNDAY)
	LDB CH,[270300,,YEAR]	;SECOND DIGIT DAY OF WEEK OF BEGINNING OF YEAR
	PUSHJ P,DGPT
	LDB CH,[410300,,YEAR]	;THIRD DIGIT 3 BITS
		;4 BIT 1 => NORMAL YEAR AFTER 2/28
		;2 BIT 1 => LEAP YEAR
		;1 BIT 1 => DAYLIGHT SAVINGS TIME IN EFFECT
	PUSHJ P,DGPT
	PUSHJ P,CRR1
	PUSHJ P,POM	;THE PHASE OF THE MOON
	PUSHJ P,CRR1
	POP P,LISTF5
	POPJ P,

		;VARIOUS TIME GETTING ROUTINES

GDATIM:	.RDATIM A,	;GET TIME IN A, DATE IN AA
	MOVEM A,TIME	;STORE SIXBIT TIME
	MOVEM AA,DATE	;STORE SIXBIT DATE
	JUMPGE A,POPJ1	;IF TIME AVAILABLE THEN SKIP-RETURN
	POPJ P,		;NOT AVAILABLE, DON'T SKIP (BUT LEAVE TIME AND DATE NEGATIVE)

GLPDTM:	.RLPDT A,	;GET VARIOUS TIMES IN BINARY
	MOVEM AA,YEAR	;SAVE YEAR AND FLAGS
	MOVEM A,LPDTIM	;SAVE LOCALIZED # SECONDS SINCE BEGINNING OF YEAR
	TLNE AA,400000	;IF NORMAL YEAR AFTER FEB 28,
	SUBI A,SPD	;THEN BACK UP A DAY
	TLNE AA,100000	;IF DAYLIGHT SAVINGS TIME IN EFFECT,
	SUBI A,3600.	;THEN BACK UP AN HOUR
	MOVEM A,PDTIME	;SAVE # SECONDS SINCE BEGINNING OF YEAR
	POPJ P,

		;TYPE OUT (THROUGH LISTF5) THE DATE IN ENGLISH

SYMDAT:	PUSHJ P,DOW	;TYPE DAY OF WEEK
	REPEAT 2,PUSHJ P,SPSP	;TYPE TWO SPACES
	MOVE C,DATE	;GET DATE
	DPB C,[221400,,CDATE]	;DEPOSIT SIXBIT FOR DAY OF MONTH
	LDB CH,[220100,,DATE]	;GET FIRST DIGIT OF MONTH
	LDB C,[140400,,DATE]	;GET SECOND DIGIT OF MONTH
	IMULI CH,10.	;MULTIPLY THE FIRST DIGIT TO ITS PROPER WEIGHTING
	ADD C,CH	;ADD TOGETHER TO GET MONTH
	MOVE C,MONTHS-1(C)	;GET MONTH IN SIXBIT
	PUSHJ P,SIXNTY	;TYPE OUT MONTH
	MOVE C,CDATE	;GET FIRST PART OF DATE
	PUSHJ P,TYPR	;TYPE OUT
	MOVE C,DATE	;GET DATE
	MOVEI IN,2	;LIMIT TYPEOUT TO TWO CHARACTERS
	JRST TYPR3	;TYPE OUT LAST TWO DIGITS OF YEAR AND RETURN

MONTHS:	IRPS S,,[JAN FEB MARCH APRIL
MAY JUNE JULY AUG SEPT OCT NOV DEC]
	SIXBIT /S/
TERMIN

		;TYPE OUT DAY OF WEEK

DOW:	LDB A,[320300,,YEAR]	;GET DAY OF WEEK (0 => SUNDAY)
	MOVE A,DOWTBL(A)	;GET SIXBIT FOR DAY (EXCEPT FOR THE "DAY")
	PUSHJ P,SIXIN1	;TYPE OUT
	MOVSI A,(SIXBIT /DAY/)	;NOW FOR THE "DAY"
	JRST SIXIN1	;TYPE IT OUT AND RETURN

DOWTBL:	IRPS DAY,,[SUN MON TUES WEDNES THURS FRI SATUR]
	SIXBIT /DAY/
	TERMIN

		;TYPE OUT THE PHASE OF THE MOON

POM:	PUSHJ P,GNDS0	;GET NUMBER OF DAYS SINCE 1/1/0000
	MULI A,SPD	;CONVERT TO SECONDS IN A AND AA
	JFCL 17,.+1	;CLEAR FLAGS FOR FOLLOWING
	ADD AA,PDTIME	;# SECONDS SINCE BEGINNING OF YEAR
	ADD AA,SYNOFS	;THE MOON DOESN'T QUITE BELIEVE IN THE GREGORIAN CALENDAR SYSTEM
	JFCL 4,[AOJA A,.+1]	;CRY1
	ASHC A,2	;CONVERT TO QUARTER SECONDS
	DIV A,SYNP	;DIVIDE BY NUMBER OF SECONDS IN A PERIOD TO GET NUMBER OF QUARTERS SINCE THEN
	ASH AA,-2	;CONVERT REMAINDER TO SECONDS (# SECONDS INTO THIS QUARTER)
	PUSH P,AA	;SAVE REMAINDER
	IDIVI A,4	;GET QUARTER IN AA
	MOVE A,[SIXBIT /NM+   FQ+   FM+   LQ+/](AA)	;GET SIXBIT CRUFT IN A (I REFUSE TO CHANGE THE 1Q!!!)
	PUSHJ P,SIXIN1	;TYPE IT OUT
	POP P,AA	;RESTORE # SECONDS INTO THIS PERIOD
TDHMS:	MOVEI C,TDHMST	;SET POINTER TO TABLE
TDHMS1:	IDIVI AA,@(C)
	JUMPE AA,TDHMS2
	HRLM B,(P)
	PUSHJ P,[AOJA C,TDHMS1]	;INCREMENT INDEX WHILE RECURSING
	HLRZ B,(P)
TDHMS2:	PUSHJ P,DPT	;TYPE OUT IN DECIMAL
	HLLZ A,(C)	;GET SIXBIT CRUFT
	SOJA C,SIXIN1	;BACK UP INDEX, TYPE OUT, AND RETURN

TDHMST:	SIXBIT /S./+60.	;SECONDS
	SIXBIT /M./+60.	;MINUTES
	SIXBIT /H./+24.	;HOURS
	SIXBIT /D./+<,-1>	;DAYS

SYNP:	2551443.
SYNOFS:	690882.

		;GET NUMBER OF DAYS SINCE 1/1/0000 (AS OF 1/1/CURRENT YEAR) IN A

GNDS0:	MOVEI B,@YEAR	;GET YEAR
	MOVEI A,-1(B)	;ALSO GET YEAR-1 IN A
	IMULI B,365.	;FIRST APPROXIMATION
	IDIVI A,4
	ADD B,A		;ADD NUMBER OF YEARS DIVISIBLE BY 4
	IDIVI A,25.
	SUB B,A		;SUBTRACT NUMBER OF YEARS DIVISIBLE BY 100
	IDIVI A,4
	ADD A,B	;ADD CRUD ALREADY CALCULATED TO NUMBER OF YEARS DIVISIBLE BY 400
	AOJA A,CPOPJ

;FILE COPY
FCOPY:	PUSHJ P,FFRRDD
	MOVE A,[.BAI,,FDRC]
	CALL IMMQIT
	.CALL RREDB	;OPEN FOR INPUT, NAMES IN UTF ETC.
	 JRST OPNER1
	PUSHJ P,FFRRDD
	SYSCAL OPEN,[[.BAO,,ERRC] ? UTF ? [SIXBIT/_TECO_/] ? [SIXBIT/_COPY_/] ? UTSNM]
	 JRST OPNER1
FCOPY2:	MOVE T,[-GCTBL,,GCTAB]
	.IOT FDRC,T
	JUMPL T,FCOPY4
	MOVE T,[-GCTBL,,GCTAB]
	.IOT ERRC,T
	JRST FCOPY2

FCOPY4:	.CLOSE FDRC,
	MOVSI T,-GCTAB-1(T)
	EQVI T,-1#GCTAB
	.IOT ERRC,T
	SYSCAL RENMWO,[1000,,ERRC ? UTF1 ? UTF2]
	 .VALUE
	.CLOSE ERRC,
	JRST DELQIT
]

BPNTRD:	PUSHJ P,.OPNRD
	TRZ FF,ARG
	JRST .FNPNT

IFN TS,[
.OPNRD:	MOVSI TT,'DSK
	TRZE FF,ARG	;MAKE 0ER GIVE DSK:
	 MOVEM TT,UTF
	PUSHJ P,FFRRDD
RRED:	TLZ FF,UREAD	;IN CASE FAILS
	CALL UTLSTP
	MOVE A,[2,,UTYIC]
	CALL IMMQIT
	.CALL RREDB	;OPEN NAMES IN UTF ETC, MODE,,CHNL IN A.
	 JRST OPNER1	;FAILURE.
	SETZM IMQUIT
	SETZM PAGENU	;HAVE READ 0 PAGES SO FAR.
	SETOM LASTPA	;NOT ON LAST PAGE AS FAR AS TECO KNOWS.
	CALL RREDGN	;DO .RCHST, SET UP ERDEV, ERSNM, RUTF1, RUTF2.
;COME HERE TO START "OFFICIALLY" READING A FILE ALREADY OPEN.
RRED1:	TLO FF,UREAD
	MOVEI CH,^C
	DPB CH,[350700,,UTIBE]
	MOVE CH,[010700,,UTIBE-1]
	MOVEM CH,UTYIP
	AOS CH
	HRRM CH,UTRLDT
	POPJ P,
]

RREDB:	SETZ ? SIXBIT/OPEN/ ? A ? UTFARG ? 403000,,A

RREDGN:	MOVE A,UTSNM
	SYSCAL RFNAME,[MOVEI UTYIC ? MOVEM ERDEV ? MOVEM RUTF1 ? MOVEM RUTF2
			MOVEM ERSNM]
	 .VALUE
	SKIPN ERSNM
	 MOVEM A,ERSNM
	RET

IFN TS,[	;IO PUSH-DOWN COMMANDS

;E[ => PUSH INPUT CHANNEL
PSHIC:	TLZ FF,CTLUF	;DON'T TRY TO CONTROL U
	TLNN FF,UREAD	;IF FILE NOT OPEN,
	 JRST PSHIC2
	MOVEI CH,UTYIC	;SET ARG TO FOLLOWING
	PUSHJ P,PSHCK	;C := WORD ADR OR DIE BECAUSE NOT RANDOM ACCESS
	MOVE A,UTYIP	;GET BYTE POINTER
	IBP A		;MAKE SURE IT POINTS *TO* THE WORD TO GET THE NEXT BYTE FROM
	MOVEI T,(A)
	SUB T,UTRLDT
	HRREI T,(T)	;GET -<# WORDS TO GO TO END OF BUFFER>
	JUMPE T,PSHIC2	;JUMP IF AT END OF BUFFER, DON'T NEED TO DO .ACCESS
	ADD C,T		;CALCULATE DESIRED WORD ADDRESS
	.ACCESS UTYIC,C	;CLOBBER TO DESIRED
PSHIC2:	MOVE C,PAGENU	;SAVE PAGENU AND LASTPA.
	LSH C,1
	SUB C,LASTPA	;LASTPA HOLDS 0 OR -1.
	LSH C,2
	TLNE FF,UREAD	;SAVE STATE OF UREAD TOO.
	 ADDI C,2
	HRRI A,1(C)	;LOW BIT SET SAYS INPUT CHNL.
	PUSHJ P,CHPSH	;DO THE PUSH
	JRST UICLS	;CLOBBER POINTERS AND RETURN

		;E] => POP INTO INPUT CHANNEL

POPIC:	TLZ FF,CTLUF	;DON'T DISPLAY DIRECTORY.
	PUSHJ P,UICLS	;CLOBBER POINTERS FIRST
	MOVE CH,[TRNN T,UTYIC]	;TRNN SKIPS IF THIS RIGHT KIND OF PDL ENTRY, UTYIC CHANNEL TO POP INTO
	PUSHJ P,CHPOP	;POP INTO THE CHANNEL
	LDB CH,[020100,,A]
	MOVNM CH,LASTPA
	LDB CH,[031700,,A]
	MOVEM CH,PAGENU
	.STATUS UTYIC,CH	;GET CHANNEL STATUS
	TRNE CH,77	;IF NO DEVICE OPEN NOW
	 TRNN A,2	;OR NONE WAS OPEN THEN,
	  JRST UTLSTP	;SAY WE'RE AT END OF FILE (MUST ALWAYS SAY THAT IF UREAD OFF)
	TLO FF,UREAD	;OTHERWISE, SAY A FILE IS OPEN
	CALL UTRLD2	;RE-FILL INPUT BUFFER.
	HRRI A,UTIBUF	;CONVERT BACK TO BYTE POINTER
	DBP7 A		;DECREMENT TO GET RELOCATED ORIGINAL POINTER.
	MOVEM A,UTYIP	;STORE AS POINTER
	JRST RREDGN	;DO RFNAME; SET UP ERDEV, ERSNM, RUTF1, RUTF2.

		;CHECK THE VALIDITY OF THE INPUT FILE OPEN ON CHANNEL SPECIFIED BY CH

PSHCK:	HRRZ A,CH	;GET CHANNEL
	.CALL RFACCB
	 TYPRE [NRA]
	RET

RFACCB:	SETZ ? 'RFPNTR ? A ? MOVEM C ((SETZ))

		;E\ => PUSH OUTPUT CHANNEL

PSHOC:	TLZ FF,CTLUF	;DON'T TRY TO CONTROL U
	CALL FLSOUT	;FORCE OUT BUFFER, EXCEPT 1 WD (LEFT IN 1ST WD OF BUFFER)
	MOVE AA,UTYOP	;GET B.P. TO SHIFT POS. FIELD INTO A.
	IBP AA		;GET BP TO PLACE NEXT CHAR GOES (RH = UTOBUF).
	LDB A,[73500,,UTOBUF]	;GET 1ST 4 CHRS FROM THAT WD
		;(5TH CAN'T BE USED, SINCE FLSOUT WOULD HAVE OUTPUT THE WD)
	LSHC A,7	;LEFT-JUSTIFY CHARACTERS AND SHIFT MEAT OF BYTE POINTER IN, LEAVE BIT 1.1 BLANK (=> OUTPUT)
	MOVEI CH,UTYOC	;PUT CHANNEL SPECIFICATION IN CH
	PUSHJ P,CHPSH	;PUSH THE CHANNEL (ALSO PUSH A ONTO LOCAL PDL)
	JRST .FILE2	;CLOBBER BUFFER POINTERS AND RETURN

		;E^ => POP INTO OUTPUT CHANNEL

POPOC:	TLZ FF,CTLUF	;DON'T TRY TO CONTROL U
	PUSHJ P,.FILE2	;CLOBBER BUFFER POINTERS
	MOVE CH,[TRNE T,UTYOC]	;GET CHANNEL AND TEST INSTRUCTION IN T (INSTRUCTION SKIPS IF THIS RIGHT PDL ENTRY)
	PUSHJ P,CHPOP	;POP INTO THE CHANNEL
	.STATUS UTYOC,B
	TRNN B,77
	 POPJ P,	;POPPED AN UNOPENED CHANNEL.
	MOVEM A,UTOBUF	;STORE BACK PARTIALLY FILLED WORD
	MOVE B,[700,,UTOBUF]	;GET BYTE POINTER LESS POSITION FIELD IN B
	DPB A,[350700,,B]	;DEPOSIT POS FIELD + EXTRA LOW BIT
	DBP7 B
	MOVEM B,UTYOP	;STORE BACK NEW POINTER
	ANDI A,177	;MASK A TO POSITION FIELD_1
	IDIVI A,7_1	;GET # CHARACTERS STILL TO BE PROCESSED THIS WORD - 1 IN A
	ADDI A,<UTOBE-UTOBUF>*5-4	;CONVERT TO NUMBER OF CHARACTERS YET TO OUTPUT
	MOVNM A,UTYOCT	;STORE AS COUNT REMAINING
	TLO FF,UWRITE	;FILE OPEN
	SYSCAL RFNAME,[MOVEI UTYOC ? MOVEM EIDEV ? MOVEM EISNM ? MOVEM EISNM ? MOVEM EISNM]
	 .VALUE
	RET

		;PUSH THE IO CHANNEL SPECIFIED BY CH

CHPSH:	MOVE B,IOP	;GET IO PDL POINTER
	PUSHJ P,CHPSH1	;DO THE PUSH
	MOVEM B,IOP	;STORE BACK UPDATED POINTER
	POPJ P,

CHPSH1:	PUSH B,A
	MOVE Q,[.IOPUS]
	DPB CH,[270400,,Q]
	XCT Q
	POPJ P,

CHPOP2:	MOVE Q,[.IOPOP]
	DPB C,[270400,,Q]
	XCT Q
	RET

		;IO POP INTO THE CHANNEL SPECIFIED BY CH

CHPOP:	HLLM CH,CHPOPX	;STORE VALIDITY CHECKING INSTRUCTION
	HRRM CH,GCHN2	;STORE CHANNEL IN CHANNEL SEARCH ROUTINE (MAKE IT SKIP OVER IT)
	MOVEI C,17	;SET FIRST CHANEL FOR GCHN TO TRY
	MOVE B,IOP	;GET IO PDL POINTER
	HRRZ A,B	;GET RH IN A
	MOVE AA,[TYPRE [NOP]
]			;NOT ON PDL: EXECUTED IF SPECIFIED TYPE OF CHANNEL HASN'T BEEN PUSHED
	PUSHJ P,CHPOP1	;DO THE POP
	XCT AA		;LOST, DO THE APPROPRIATE THING
	MOVEM B,IOP	;STORE BACK UPDATED POINTER
	MOVE A,AA	;PUT RETURN LOCAL PDL WORD IN A FOR ROUTINE THAT CALLED THIS ONE
	MOVE CH,C	;RESTORE CH FOR CALLING ROUTINE
	POPJ P,

		;ENTRY ON TOP OF PDL WRONG TYPE, POP IT SOMEWHERE ELSE, RECURSE, THEN PUSH IT BACK

CHPOP3:	PUSH P,T	;SAVE LOCAL DESCRIPTOR WORD ON MAIN PDL
	PUSHJ P,GCHN	;GET A FREE CHANNEL TO POP INTO
	JRST POPAJ	;NO CHANNELS AVAILABLE
	PUSHJ P,CHPOP2	;POP INTO CHANNEL
	HRLM C,-1(P)	;SAVE CHANNEL NUMBER POPPED INTO
	PUSHJ P,[SOJA A,CHPOP1]	;TRY AGAIN ON ORIGINAL TASK
	SOS -1(P)	;LOSE, CAUSE RETURN NOT TO SKIP
	HLRZ CH,-1(P)	;RESTORE CHANNEL NUMBER, THIS TIME IN CH FOR PUSH BACK
	POP P,A		;RESTORE LOCAL PDL ENTRY, BUT IN A
	AOS (P)		;CAUSE RETURN TO SKIP
	JRST CHPSH1	;PUSH BACK CHANNEL AND RETURN


CHPOP1:	CAIGE A,IOPDL	;IF A DOESN'T POINT INTO PDL,
	POPJ P,		;THEN NOT ON PDL , UNSCREW PDL AND DO TYPRE [NOP]
	POP B,T		;POP LOCAL PDL ENTRY INTO T
	XCT CHPOPX	;SKIP IF THIS THE RIGHT KIND OF PDL ENTRY
	 JRST CHPOP3	;WRONG KIND OF ENTRY, POP IT SOMEWHERE ELSE, RECURSE, THEN PUSH IT BACK
	MOVE C,CH	;RIGHT KIND OF ENTRY, SAVE ORIGINAL CHANNEL SPECIFICATION IN C
	MOVE AA,T	;WIN, SAVE LOCAL PDL ENTRY FOR TOP LEVEL
	AOS (P)		;CAUSE RETURN TO SKIP
	JRST CHPOP2

		;FIND A FREE CHANNEL TO POP INTO

GCHN:			;GCHN NAME OF ENTRY TRANSFERED TO, GCHN2 NAME OF INSTRUCTION TO ADDRESS MODIFY
	XCT GCHN2		;RH MODIFIED, CHANNEL REALLY TRYING TO POP INTO SO LEAVE IT ALONE
	JRST GCHN3	;DON'T POP INTO THIS CHANNEL
	MOVE T,[.STATUS T]
	DPB C,[270400,,T]
	XCT T		;GET STATUS OF CHNL CONSIDERING POPPING INTO.
	TRNN T,77	;DEVICE OPEN ON CHANNEL?
	JRST POPJ1	;NO, RETURN WINNING
GCHN3:	SOJGE C,GCHN	;LOSE, TRY NEXT CHANNEL
	MOVE AA,[TYPRE [NFC]
]			;NO FREE CHANNELS TO POP INTO
	POPJ P,		;NON-SKIP RETURN

]		;END IFN TS, CONDITIONAL

EXITE:	HRLOI B,377777	;INFINITY
	TRZ FF,ARG
	TRO FF,ARG
	MOVE C,BEGV	;PUNCH OUT IF BUFFER NONEMPTY
	CAMN C,ZV
	 SKIPE LASTPA	;OR AN INPUT FILE IS OPEN
	  PUSHJ P,PUNCHA
	CALL UICLS
	JRST .FILE

IFN TS,[
EXITX:	TLNN FF,UWRITE
	PUSHJ P,FFRRDD
	TLNE FF,UWRITE
	PUSHJ P,EXITE
	.SUSET [.RSNAM,,E]
	MOVE B,UTF
	MOVE A,UTF1
	MOVE AA,UTF2
	MOVE C,[ASCII/     /]
	MOVEM C,EXITV0	;FILL AREA FOR FILENAME WITH SPACES.
	MOVE C,[EXITV0,,EXITV0+1]
	BLT C,EXITV2+1	;ALSO, THE AREA FOR THE OPTIONAL :CREF CMD.
	MOVE C,[ASCII /   î /]	;RESTORE THE ^M AFTER THE :M.
	MOVEM C,EXITV1-1
	MOVE C,[440700,,EXITV0]
	MOVE D,[440600,,A]	;NOW PUT THE ASCII FILENAME IN CMD.
EXIT3:	ILDB CH,D
	SKIPN (D)	;IF NAME NOW HANDLING IS JUST SPACES,
	JRST EXIT5	;THIS SPACE IS TRAILING, IGNORE.
	ADDI CH,40
	IDPB CH,C
	MOVEI CH,0	;REPLACE CHAR JUST HANDLED BY 0.
	DPB CH,D	;SO AC WILL BE 0 IF ONLY TRAILING SPACES.
EXIT5:	TLNE D,770000
	JRST EXIT3
	IBP C
	JRST .+1-A(D)	;DISPATCH ACC. TO WHICH NAME JUST FINISHED.
	JRST EXITF1	;AFTER FN1, COPY INTO $L.
	JRST EXIT3	;AFTER FN2, NOTHING SPECIAL.
	JRST EXITDV	;AFTER DEVICE, PUT COLON IN STRING.
	MOVEI CH,";
	DPB CH,C	;AFTER SNAME, PUT SEMICOLON, ALL DONE.
	JRST EXIT1

EXITF1:	MOVE CH,[EXITV0,,EXITV3]
	BLT CH,EXITV3+1
	JRST EXIT3	;GO HANDLE DEVICE.

EXITDV:	MOVEI CH,":
	DPB CH,C
	JRST EXIT3

EXIT1:	MOVE A,[ASCII/:M  /]
	TRNE FF,COLONF
	MOVE A,[ASCII/:M /]
	MOVEM A,EXITV
	MOVE C,[[ASCII/(C)î :CREF/],,EXITV1-1]
	TRNE FF,COLONF	;FOR :EX, GIVE MIDAS (C) SWITCH
	BLT C,EXITV1	;AND DO THE :CREF.
	MOVE C,[EXITV3,,EXITV2]
	TRNE FF,COLONF	;ALSO SUPPLY FN1 TO CREF.
	BLT C,EXITV2+1
	TLZ FF,CTLUF
IFN ATSFLG,[
	TRZE FF,COLONF	;:EX => START LISTING, DO VALRET
	 JRST [SETOM EXITVF	;AFTER BIGPRINTING FILENAMES.
		TRZ FF,ARG
		JRST SYMLPT]
]
	.VALUE EXITV	;TELL DDT TO GO.
	POPJ P,

;NOTE STILL IFN TS,

UCLOSE:	MOVE A,[SIXBIT/_TECO_/]
	SKIPA AA,[SIXBIT /FLAP/]
.FILE:	PUSHJ P,FRD
.FILE1:	MOVEM A,UTF1
	MOVEM AA,UTF2
	TLNN FF,UWRITE
	TYPRE [NDO]
	MOVE CH,EIDEV
	MOVEM CH,UTF
	MOVE CH,EISNM
	MOVEM CH,UTSNM
	TDZA E,E
.FILEX:	MOVEI E,1	;DON'T RENAME
	CAIA
.FILEA:	 CALL UTYO
.FILEB:	MOVE CH,UTYOP
	HRR CH,FILEPAD
	TLNE CH,760000
	 JRST .FILEA
	CALL FLSOUT
	JUMPN E,.FILE2
.FILE3:	SYSCAL RENMWO,[1000,,UTYOC ? UTF1 ? UTF2]
	 JRST OPNER1
.FILE2:	PUSH P,0
	MOVE 0,[ASCIC//]	;DISGUST
	.CLOSE UTYOC,
	POP P,0
	TLZ FF,UWRITE
	POPJ P,

;EJ - OPEN FILE FOR READING AND LOAD IMPURE AREAS AS DUMPED IN FILE.
;TAKES A FILENAME ARGUMENT. DOES NOT ALTER THE DEFAULT SNAME.
;AFTER LOADING, TECO IS RESTARTED, WHICH MEANS M..L WILL BE DONE.
;^ EJ - WRITE ALL IMPURE AREAS INTO A FILE OPEN FOR WRITING, AND
;FILE IT AWAY AS SPEC'D NAMES.

;FORMAT OF FILE:
;1ST WORD: SIXBIT/TECO/+1  (FOR ERROR CHECKING)
;2ND WORD: .FNAM2 OF TECO DOING THE DUMPING.
   ;PREVENTS TECOS FROM LOADING DUMP FILES OF OTHER VERSIONS.
;3RD WORD: JRST 1, AS REQUIRED TO MARK THE BEGINNING OF SBLK DATA IN A BIN FILE
;THEN COME SBLK DATA BLOCKS SPECIFYING RANGES OF CORE TO LOAD,
;AND THEN TWO COPIES OF THE START ADDRESS (BOOT).

;: EJ - OPEN FILE FOR READING AND MAP IT INTO CORE JUST UNDER LHIPAG.
;LHIPAG IS SET TO POINT AT THE BEGINNING OF THE FILE, AND A PURE
;STRING POINTER TO THE START OF THE FILE IS RETURNED. THIS COMMAND
;DOES NOT USE THE FILE FORMAT USED BY PLAIN EJ AND ^ EJ; IN FACT,
;THE FILE IS JUST A CORE IMAGE.

EJCMD:	TRZN FF,SLSL
	 JRST EJCMDR
	TLNN FF,UWRITE	;^ EJ.
	 TYPRE [NDO]
	MOVE A,[-3,,[SIXBIT /TECO/+1
		     .FNAM2
		     JRST 1]]
	.IOT UTYOC,A	;SAY THIS IS A TECO DUMP FILE, AND WHAT
			;TECO VERSION DUMPED IT.
	HRROI A,P
	JSP T,EJWBLK
	MOVE A,[20-HCDS,,20]
	JSP T,EJWBLK	;DUMP LOW IMPURE.
	MOVE A,[HCDSE-LIMPUR,,HCDSE]
	JSP T,EJWBLK	;EXCEPT FOR THE SCREEN-LINE HASH CODES.
	MOVE A,QRWRT
	ADDI A,4
	IDIVI A,5	;ADDR LAST WORD OF QREG SPACE.
	SUBI A,HIMPUR	;LENGTH OF HIGH IMPURE.
	MOVNS A
	HRLZS A
	HRRI A,HIMPUR
	JSP T,EJWBLK	;DUMP OUT HIGH IMPURE.
	MOVE A,BFRBOT
	IDIVI A,5
	MOVE B,BFRTOP
	IDIVI B,5
	SUBM A,B	;-<LENGTH OF BUFFER SPACE>
	HRL A,B		;AOBJN TO BUFFER SPACE.
	JSP T,EJWBLK	;DUMP OUT BUFFER SPACE.
	HRROI A,[JRST BOOT]
	.IOT UTYOC,A	;OUTPUT THE STARTING ADDRESS
	HRROI A,[JRST BOOT]
	.IOT UTYOC,A	;AND THEN ANOTHER COPY, THUS MARKING OFF A NULL SYMBOL TABLE.
	JRST .FILE	;RENAME AND CLOSE FILE.

;A HAS AOBJN POINTER TO RANGE OF DATA;  WRITE AN SBLK DESCRIBING IT.
EJWBLK:	HRROI B,A	;FIRST WE NEED TO WRITE THE AOBJN ITSELF.
	.IOT UTYOC,B
	MOVE TT,A
	.IOT UTYOC,A	;THEN WRITE THE DATA IN THAT RANGE.
	MOVE TT1,TT	;THEN COMPUTE THE CHECKSUM IN TT, INCLUDING THE AOBJN WORD
	ROT TT,1
	ADD TT,(TT1)	;AND THEN THE DATA WORDS.
	AOBJN TT1,.-2
	HRROI B,TT
	.IOT UTYOC,B	;OUTPUT THE CHECKSUM.
	JRST (T)

;EJ AND :EJ COMMANDS (THE INPUT VERSIONS OF EJ).
EJCMDR:	CALL .OPNRD	;READ FILE SPEC & OPEN FILE
	TRZN FF,COLONF	;:EJ?
	 JRST EJCMD2
	SYSCAL FILLEN,[MOVEI UTYIC ? MOVEM A]
	 JRST OPNER1
	ADDI A,1777	;HOW MANY PAGES LONG IS THE FILE?
	LSH A,-10.
	MOVNS B,A
	ADD B,LHIPAG	;IF IT WILL END JUST BELOW LHIPAG, WHERE SHOULD IT START?
	CAIGE B,LHIMIN
	 TYPRE [URK]	;REFUSE TO GOBBLE TOO MANY PAGES.
	HRL B,A
	SYSCAL CORBLK,[MOVEI 200000 ? MOVEI -1 ? B ? MOVEI UTYIC]
	 JRST OPNER1
	CALL UICLS	;ALL PAGES MAPPED; DON'T NEED THE FILE NOW.
	ADDB A,LHIPAG	;ADJUST LHIPAG FOR PAGES WE HAVE GOBBLED.
	IMULI A,5*2000
	TLO A,400000	;RETURN A STRING POINTER TO BOTTOM OF FILE.
	JRST POPJ1

EJCMD2:	MOVE A,[-3,,B]	;CHECK FIRST 3 WORDS OF FILE.
	.IOT UTYIC,A	.SEE IDIVI	;CONSECUTIVE AC'S USED HERE.
	CAMN B,[SIXBIT/TECO/+1]
	 CAME E,[.FNAM2] ;DUMPED BY DIFFERENT TECO VERSION,
	  TYPRE [AOR]	;OR NOT A TECO DUMP FILE.
	CAME C,[JRST 1]
	 TYPRE [AOR]
	.SUSET [.SMSK2,,[0]] ;INTERRUPT MIGHT DO TTYSET FROM NEWLY CLOBBERED VARS.
	MOVE C,LHIPAG	;SINCE WE AREN'T OVERWRITING PURE STRING SPACE
			;MUSTN'T FORGET WHERE IT STARTS.
	MOVE E,MSNAME	;ALSO DON'T CLOBBER MSNAME.
EJCMD1:	HRROI A,B
	.IOT UTYIC,A	;READ NEXT BLOCK HEADER
	JUMPGE B,EJCMD3	;POSITIVE => END OF BLOCK DATA;  RESTART TECO, RUNNING Q..L.
	.IOT UTYIC,B	;LOAD DATA OF BLOCK,
	HRROI A,B
	.IOT UTYIC,A	;SKIP THE CHECKSUM.
	JRST EJCMD1	;READ NEXT BLOCK.

EJCMD3:	MOVEM C,LHIPAG
	INSIRP MOVEM E,MSNAME UTSNM
	.I SAVCMX=COMAX=1
	.CLOSE UTYIC,
	JRST INIT

RENAM:	PUSHJ P,FFRRDD
	PUSHJ P,FRD
	CALL IMMQIT
	SYSCAL RENAME,[UTFARG ? A ? AA]
	 JRST OPNER1
	MOVEM A,UTF1
	MOVEM AA,UTF2
	JRST DELQIT

ALINK:	PUSHJ P,FFRRDD	;GET LINK NAME
	CALL ALINK2	;ERROR IF DEVICE NOT DSK.
	CAME A,[SIXBIT/>/]
	CAMN AA,[SIXBIT/>/]
	 JRST ALINK1	;MAKING LINK FROM FOO > WON'T DELETE ANYTHING.
	MOVEI A,FDRC
	CALL IMMQIT
	.CALL RREDB	;ELSE SEE IF ANY FILE WITH THAT NAME.
	 JRST ALINK1
	SKIPA A,[#1013]	;GET ERROR CODE FOR "FILE ALREADY EXISTS",
ALINK3:	 HRROI A,#1034	;"WRONG TYPE DEVICE" - NOT DSK:
	MOVEM A,LASTER	;PRETEND IT CAME FROM THE SYSTEM
	JRST DISTOE	;GO SIGNAL THE ERROR.

ALINK1:	SETZM IMQUIT
	MOVE A,[UTF,,GCTAB]
	BLT A,GCTAB+3	;SAVE THE LINK NAMES,
	CALL FFRRDD	;READ NAMES LINKED TO.
	CALL ALINK2	;ERROR IF NOT DSK, GET CORRECT SNAME IN B.
	MOVE T,[GCTAB,,UTF]
	BLT T,UTSNM	;BRING BACK LINK NAMES,
	CALL IMMQIT
	SYSCAL MLINK,[UTFARG ? A ? AA ? B]
	 JRST OPNER1
	JRST DELQIT

ALINK2:	SETZ B,
	MOVS T,UTF	;CONVERT COM: TO COMMON;, ETC.
	CAIN T,'DSK
	 MOVE B,UTSNM
	CAIN T,'COM
	 MOVE B,['COMMON]
	CAIN T,'SYS
	 MOVSI B,'SYS
	CAIN T,'TPL
	 MOVE B,['.LPTR.]
	JUMPE B,ALINK3	;NOT DSK => WRONG TYPE DEVICE.
	POPJ P,

ADMPC:	PUSHJ P,FFRRDD
	MOVEI A,FDRC
	CALL IMMQIT
	.CALL RREDB	;OPEN SPEC'D FILE FOR INPUT ON FDRC.
	 JRST OPNER1
	SYSCAL SDMPBT,[MOVEI FDRC ? MOVEI 1]
	 JRST OPNER1
	.CLOSE FDRC,
	JRST DELQIT

EICMD:	CALL GDEV
	JRST WINIT

WWINIT:	TRNN FF,COLONF
	 CALL FFRDEV	;SET DEFAULT DEV AND SNAME
	TRNE FF,COLONF
	 CALL FFRRDD	;OR SET DEFAULT DEV, SNAME AND FILENAMES.
WINIT:	MOVE A,UTF1
	MOVE AA,UTF2
	TRZE FF,COLONF	;:EW, :EI USE SPEC'D NAMES TO OPEN AS,
	 JRST WINIT1
	MOVE A,[SIXBIT/_TECO_/]	;WITHOUT COLON, OPEN AS _TECO_ OUTPUT.
	MOVE AA,['OUTPUT]
WINIT1:	TLZ FF,UWRITE
	CALL IMMQIT
	MOVEI T,100000	;^ EW OPENS IN WRITE-OVER MODE.
	TRZN FF,SLSL
WINIT2:	 MOVEI T,0	;OTHERWISE, USE NORMAL WRITE.
	SYSCAL OPEN,[[3,,UTYOC] ? UTF ? A ? AA ? UTSNM ? 4000,,T]
	 JRST WINIT3
	SETZM IMQUIT
	MOVE T,UTF
	MOVEM T,EIDEV	;REMEMBER DEV AND SNAME LAST WRITTEN IN.
	MOVE T,UTSNM
	MOVEM T,EISNM
	JSP T,FHAK	;INIT. BUFFER POINTERS.
	TLO FF,UWRITE
	POPJ P,

WINIT3:	.STATUS UTYOC,E	;IF WRITE-OVER OPEN FAILS FOR "FILE NOT FOUND"
	LDB E,[220600,,E]
	CAIN E,OPLFNF	
	 JUMPN T,WINIT2
	JRST OPNER1

FHAK:	TLO FF,UWRITE
	MOVE CH,[10700,,UTOBUF-1]
	MOVEM CH,UTYOP
	MOVNI CH,<UTOBE-UTOBUF>*5
	MOVEM CH,UTYOCT
	JRST 1(T)
]

IFN TS,[TAPKIL:	SAVE UTF
	CALL GDEV
	MOVE A,UTF
	CAMN A,ERDEV
	PUSHJ P,UICLS
	TLNN FF,UWRITE
	 JRST TAPKI1
	CAMN A,EIDEV
	PUSHJ P,UCLOSE
TAPKI1:	LDB B,[220400,,UTF]
	TLZ FF,CTLUF
	REST UTF	;RESTORE OLD DEFAULT DEVICE NAME
	.UDISMN B,
	 TYPRE [UNF]
	POPJ P,

GDEV:	TRNN FF,ARG
	POPJ P,
	MOVMS B
	IDIVI B,NDEVS
	MOVE B,DEVNAM(E)
	MOVEM B,UTF
	POPJ P,

DEVNAM:	IRPS XX,,DSK UT1 UT2 UT3 UT4
	SIXBIT \XX\
TERMIN
NDEVS==.-DEVNAM

DELE:	PUSHJ P,FFRRDD
	SYSCAL DELETE,[UTFARG]
	 JRST OPNER1
	POPJ P,
]

;OUTPUT ROUTINES. OUTPUT CHAR IN CH AS DESCRIBED, CLOBBERING ONLY Q.

;"DISPLAY" - OUTPUT CURSOR, DO CASE-FLAGGING.
DISAD:
IFN RMSSW,[
	MOVE Q,CHCTHP
	MOVEM Q,RRCCHP
]
	CAMN IN,DISADP	;IF THIS CHAR COMES AFTER POINTER,
	CALL DISBAR	;OUTPUT CURSOR.

;DON'T OUTPUT CURSOR, DO CASE-FLAGGING.
DISAD2:	SKIPN CASDIS	;IF IN -1F$ MODE
	 JRST CHCT
	SAVE .-1	;DO CASE-FLAGGING: ROUTINE FOR 1 CHAR IS CHCT.

;CALL DISAD6 ? OUTPUT 1 CHAR ? POPJ P, ;TO OUTPUT A CASESHIFT IF NEC.
DISAD6:	SKIPGE CASSFT	;DON'T TRY OUTPUTTING CASESHIFT
	 POPJ P,	;IF THERE ISN'T ANY.
	CAME CH,CASSFT	;PUT CASE-SHIFTS BEFORE
	CAMN CH,CASLOK	;CASE-SHIFTS AND CASE-:LOCKS.
	 JRST DISAD3
	CAILE CH,"Z+40	;LOWER CASE SPECIAL CHARACTERS ALWAYS NEED CASESHIFTS.
	 CAIN CH,177
	  CAIN CH,"@+40
	   JRST DISAD3
	CAIL CH,"A+40	;LOWER CASE LETTERS NEED THEM IS NORMAL CASE IS UPPER.
	 CAILE CH,"Z+40
	  JRST DISAD4
	SKIPG CASNRM
	 RET
	JRST DISAD3	;PUT SLASHES BEFORE LOWER.

DISAD4:	SKIPL CASNRM	;IF NORMAL CASE IS LOWER,
	 RET
	CAIL CH,"A	;PUT CASE-SHIFTS BEFORE UPPER CASE.
	 CAILE CH,"Z
	  RET
DISAD3:	SAVE [DISAD5]	;CASESHIFT NEEDED; ARRANGE TO OUTPUT IT,
	SAVE -1(P)	;THEN POPJ TO OUTPUT ORIGINAL CHAR.
	HRLM CH,-2(P)
	MOVE CH,CASSFT
	POPJ P,		;PDL HAS 1-CHAR-RTN ? DISAD5 ? CHAR,,1-CHAR-RTN.

;OUTPUT A CURSOR.
DISBAR:	PUSH P,CH
IFN RMSSW,[
	SKIPE RREBEG
	 JRST DISBA1
	CALL RRDIS1
	SKIPE RGETTY
	 JRST POPCHJ
DISBA1:
]
INSIRP PUSH P,TT TT1 F A AA
	MOVE CH,QRB..	;GET ADDR OF EITHER NORMAL CURSOR QREG
	ADDI CH,.QCRSR
	CALL QLGET
	 JRST DISBA2	;NOT TEXT, NO CURSOR.
	AOSN CHCTCF	;FORCE OUT ANY BUFFERED CR BEFORE THE CURSOR.
	 CALL CHCT5
	MOVE A,F
DISBA3:	SOJL AA,DISBA2	;LENGTH OF TEXT WAS IN AA,
	ILDB CH,A	;GET AND OUTPUT CHARS OF CURSOR.
	CALL [	CAIN CH,^H
		 JRST DISBBS	;OUTPUT BS AS REAL BACKSPACE.
		CAIL CH,40	;OUTPUT CTL CHARS OTHER THAN ^H IN IMAGE MODE.
		 JRST CHCT
		  JRST CHCT4]
	JRST DISBA3

DISBA2:	INSIRP POP P,AA A F TT1 TT
POPCHJ:	POP P,CH
	POPJ P,

;TTY AND DISPLAY ROUTINES.
;"TYPEOUT" - DON'T TYPE CURSOR, DO NOTICE CASDIS.
TYO:	PUSHJ P,DISINT	;INIT. TYPEOUT.
	JRST DISAD2

6TYO:	ADDI CH,40	;TYPE SIXBIT CHAR.
TYOA:	PUSHJ P,DISINT	;"TYPEOUT"

;NO CURSOR, DON'T DO CASE FLAGGING.
CHCT:	SKIPN ORESET
	SKIPE MORFLF	;DON'T OUTPUT AFTER -FLUSHED.
	 POPJ P,
	CAIN CH,^J
	 JRST CHCTLF	;LF => OUTPUT LINE.
	AOSN CHCTCF	;ELSE FORCE OUT SAVED UP CR.
	 CALL CHCT5
	CAIN CH,177
	 JRST CHCT0A	;RUBOUT COMES OUT AS ^? .
	CAIL CH,40	;NON-CTL CHARS. ONE POSITION.
	 JRST CHCT1A
	CAIN CH,^I	;TAB => OUTPUT SEVERAL SPACES.
	 JRST CHCTTB
	CAIN CH,^H
	 JRST CHCTBS
	CAIN CH,^M	;REMEMBER A CR, NEXT CHAR WILL DECIDE.
	 JRST [SETOM CHCTCF ? POPJ P,]
	CAIN CH,33	;ALTMODE  => OUTPUT; SYSTEM MAY TURN IT INTO DOLLARSIGN.
	 JRST [	MOVE Q,TTYOPT
		TLNN Q,%TOSAI	;ON PDP-11 TV'S, SEND ALTMODE AS ALTMODE.
		 MOVEI CH,"$	;OTHERWISE SEND DOLLARSIGN.
		CALL CHCT1A
		JRST RET33]	;IN EITHER CASE DON'T CLOBBER CH.
	SKIPE DISSAI	;IN SAIL MODE, CTL CHARS OUTPUT AS THEMSELVES
	 JUMPN CH,CHCTS1 ;AND ASSUMED TO TAKE 1 POS. ON SCREEN.
CHCT0A:	HRLM CH,(P)
	MOVEI CH,"^	;OTHER CTL CHARS => OUTPUT "^"
	MOVE Q,TTYOPT
	TLNE Q,%TOSAI	
	 MOVEI CH,13	;(OR UPARROW, ON TTY'S WITH SAIL CHAR SET)
	PUSHJ P,CHCT1A
	HLRZ CH,(P)
	XORI CH,100	;AND UN-CTLED CHAR.
	CALL CHCT1A
DISAD5:	HLRZ CH,(P)
	POPJ P,

CHCTS1:	CAIN CH,^G	;SAIL MODE: A FEW CTL HARS GIVE
	 JRST CHCT0A
	JRST CHCT1A

;OUTPUT AN ORDINARY PRINTING CHARACTER.
;WHEN A FULL LINE HAS BEEN ACCUMULATED, CALL @CHCTAD
;WITH HASH CODE IN CHCTHC, VERT. POS. IN CHCTVP,
;HORIZ. POS. AFTER LINE IN CHCTHP.
CHCT1A:	MOVE Q,CHCTHP
	CAMGE Q,NHLNS	;IF FILLED LINE, CONTINUE IT.
	 JRST CHCT2
	PUSH P,CH
	SKIPGE DISTRN	;TRUNCATING MEANS IGNORING CHARS TILL NEXT CR.
	 JRST [	MOVEI CH,"!	;IF WE'VE JUST BEGUN TO TRUNCATE,
		SKIPL CHCIGN	;PUT IN AN EXCL.
		 CALL CHCT4
		SETOM CHCIGN	;START IGNORING MOST CHARS.
		JRST CHCT1B]
	MOVEI CH,"!
	CALL CHCT4	;PUT A ! AT END OF LINE.
	MOVEM IN,CHCTNL
	SOS CHCTNL	;ADDR OF 1ST CHAR OF LINE AFTER THIS ONE.
	CALL CHCTL0	;NOW DO A CRLF.
CHCT1B:	POP P,CH
CHCT2:	SKIPL CHCTHP
	 CALL CHCT4	;OUTPUT THE CHAR IF NECESSARY,
	AOS CHCTHP
	RET

;PUT THE CHAR IN CH INTO THE BUFFER AND THE HASH-CODE.
;IF THE BUFFER (<- CHCTBP) IS FULL, OUTPUT IT FIRST.
CHCT4:	SKIPL CHCIGN
	SKIPN CHCTBP
	 POPJ P,
	SOSG DISBFC	;IF BUFFER FULL,FLUSH IT
	JRST [	PUSH P,CH
		SETOM CHCTNL
		PUSHJ P,@CHCTAD
		POP P,CH
		JRST .+1]
	IDPB CH,CHCTBP	;STORE CHAR IN CALLER'S BUFFER.

CHCTH:	MOVE Q,CHCTHC	;MERGE CHAR. IN CH INTO HASH CODE FOR LINE.
	ROT Q,7
	ADDI Q,(CH)
	MOVEM Q,CHCTHC
	POPJ P,

CHCTTB:	MOVEI CH,40	;TAB: OUTPUT A SPACE.
	PUSHJ P,CHCT1A
	MOVE CH,CHCTHP	;NOT AT TAB STOP =>
	SKIPN MORFLF	;GO OUTPUT ANOTHER UNLESS FLUSHED
	TRNN CH,7
	 JRST CHCTT1
	CAME CH,NHLNS
	 JRST CHCTTB
CHCTT1:	MOVEI CH,11
	RET

;INIT. FOR CHCT.
CHCTI0:	SETZM CHCTCF	;NO PENDING ^M.
	SETZM CHCTHP
	SETZM CHCIGN	;NOT BEYOND RIGHT MARGIN.
CHCTI1:	AOS CHCTVP
	SETZM CHCTHC	;INIT. ACCUMULATION OF HASH CODE.
	POPJ P,

CHCT5:	PUSH P,CH	;FORCE OUT CR FOLLOWED BY OTHER THAN LF.
	SKIPL DISPCR	;-1 => DO REAL CR.
	 JRST CHCT5A
	SETZM CHCTHP	;REAL CR: ZERO HORIZ POSITION,
	SETZM CHCIGN	;NO LONGER PAST RIGHT MARGIN.
	SETOM CHCTNL	;OUTPUT THE BUFFER, AND START NEXT ONE
	CALL @CHCTAD	;AT HPOS=0.
	MOVEI CH,^M
	CALL CHCTIM	;ON PRINTING TTY, OUTPUT A REAL CR.
	JRST POPCHJ

CHCT5A:	MOVEI CH,"^	;SHOULDN'T OVERPRINT, PRINT AS ^M.
	MOVE Q,TTYOPT
	TLNE Q,%TOSAI	
	 MOVEI CH,13	;(OR UPARROW, ON TTY'S WITH SAIL CHAR SET)
	CALL CHCT1A
	MOVEI CH,"M
	CALL CHCT1A
	JRST POPCHJ

CHCTBS:	SKIPL DISPBS	;DISPBS < 0 => PRINT AS BS.
	 JRST CHCT0A
DISBBS:	SKIPN CHCTHP	;CAN'T DO ANYTHING AT LEFT MARGIN.
	 JRST CHCT0A	;^H AT COLUMN 0 => TYPE ^H.
	MOVE Q,CHCTHC
	ROT Q,-7	;REAL BS: BACK UP 1 POS. IN HASH CODE.
	MOVEM Q,CHCTHC
	SOS CHCTHP
	SETOM CHCTNL
	CALL @CHCTAD	;SEND WHAT WE HAVE SO FAR.
	MOVEI CH,^H	;IF WE'RE REALLY PRINTING, IF PRINTING TTY, OUTPUT REAL ^H.
CHCTIM:	SAVE CH		;(ON DISPLAY TTY, SEND NOTHING, SINCE CURSOR MOTION
	MOVE CH,CHCTAD	;FOR NEXT DISLIN WILL DO IT ALL).
	CAIE CH,DISLIN	;ALSO, DON'T SEND THE ^H OR ^M IF WE'RE NOT REALLY TYPING.
	 JRST POPCHJ
	REST CH
	SKIPE RGETTY
	 RET
	JRST TYOINV

;COME HERE TO OUTPUT A LF. CALLED BY THE ROUTINE TO OUTPUT STRAY CR.
;CLOBBERS ONLY Q. LEAVES A ^J IN CH.
CHCTLF:	MOVEM IN,CHCTNL
	AOSE CHCTCF	;IF HAVE UNPROCESSED CR, OUTPUT IT.
	JRST [	SKIPL DISPCR ;NO CR; WHAT DO WE DO FOR STRAY LF?
		 JRST CHCT0A	;MAYBE OUTPUT AS ^ AND J.
		JRST CHCTL1]
CHCTL0:	SETZM CHCIGN	;STOP IGNORING CHARS IF HAD TRUNCATED LINE.
IFN RMSSW,SETZM RRCCHP
	SETZM CHCTHP	;REFLECT IT IN HORIZ. POS.
CHCTL1:	PUSHJ P,@CHCTAD	;LF ENDS LINE, TELL CALLER ABOUT IT.
	MOVEI CH,^M	;ON NON-DISPLAY, MUST ACTUALLY DO THE CR IF WANTED.
	SKIPN CHCTCF
	 CALL CHCTIM
	PUSHJ P,CHCTI1	;INIT NEW LINE.
	SKIPL CH,CHCTNL
	 MOVEM CH,CHCTBL
CHCTL4:	SKIPG CH,CHCTHP
	 JRST CHCTL3
	MOVE Q,CHCTHC	;PUT SPACES IN HASH CODE.
CHCTL2:	ROT Q,7	;FOR THE INDENT IN LINE WE'RE STARTING WITH.
	ADDI Q,40
	SOJG CH,CHCTL2
	MOVEM Q,CHCTHC
CHCTL3:	MOVEI CH,^J
	POPJ P,

;CALL HERE TO FORCE OUT BUFFERED OUTPUT. CALLING HERE IS ALWAYS SAFE.
DISFLS:	AOSN CHCTCF
	 CALL CHCT5	;FORCE OUT ANY UNPROCESSED CR.
	SETOM CHCTNL
	SETOM DISFLF	;FORCE DISLIN TO MOVE CURSOR
	PUSHJ P,DISLIN	;.IOT IT.
	SETZM DISFLF
	POPJ P,

;OUTPUT THE BUFFER.
DISLIN:	SKIPE TSALTC	;IF A CMD STRING IS WAITING TO BE READ,
	 SETOM MORFLF	;GIVE UP TYPEING OUT.
	SKIPN ORESET
	SKIPE MORFLF
	 RET
	SAVE T
	SAVE F
DISLI7:	SKIPN F,CHCTVP	;IF ABOUT TO WRITE ON TOP LINE
	 JRST [	SKIPN TRCOUT	;BECAUSE OF TRACE MODE,
		 JRST .+1
		MOVE Q,[ASCIC//]
		CALL DISIOT	;CLEAR 1ST LINE AND USE SECOND INSTEAD.
		AOS F,CHCTVP
		SETZM HCDS
		JRST .+1]
	MOVE CH,CHCTHC
	MOVE Q,[.BYTE 8 ? %TDNOP ? %TDNOP ? %TDNOP ? %TDNOP]
	MOVEM Q,DISBF1	;INITIALLY ASSUME NO POSITIONING NEEDED
	MOVEM Q,DISBF1+1	;BEFORE THE LINE TO BE OUTPUT.
	SKIPN RGETTY
	 JRST DISLI0	;MUST OUTPUT EVERY LINE.
	CAML F,CHCTVS	;IF WE'RE WITHIN THE SCREEN AREA,
	 JRST DISLN5
	CAME F,DISVP	;IF ERRFL1 (FS ERRFLG$) IS <0, IT IS - # LINE OF ERROR MSGS ON SCREEN,
	 AOS ERRFL1		;SO COUNT OFF THAT MANY LINES BEFORE OUTPUTTING.
	CAMN CH,HCDS(F)	;OUTPUT ONLY IF HASH CODE DIFFERS,
	 SKIPE DISFLF	;OR IF INSIST ON OUTPUTTING
	  JRST DISLI4
	JRST DISLI3

DISLN5:	MOVEM F,DISVP	;WE'RE AT BOTTOM OF SCREEN; MUST OUTPUT, SO THAT
	MOVEM F,DISVP1	;WE WILL CALL DISMOR IF NECESSARY, BUT ARRANGE NOT TO CLEAR
DISLI4:	SKIPG ERRFL1		;DON'T OUTPUT IF WOULD OVERWRITE RECENT ERROR MESSAGE.
	 JRST DISLI3
	DPB F,[DISCPV]	;PREPARE TO SET VERT. POS.
	DPB F,[DISCPA]
	DPB F,[DISC1V]
	DPB F,[DISC2V]
	MOVE Q,[DISCMV,,DISBF1]
	CAMN F,DISVP	;BUT IF SAME AS LAST TIME,
	 HRLI Q,DISCM1	;JUST SET IT, DON'T CLEAR LINE.
   JRST DISLN3		;WITH SUPERIMAGE OUT, SHOULD WE BOTHER TO %TDCRL? IF SO, WHEN?
	JUMPE F,DISLN3
	MOVEI T,-1(F)	;IF MOVING DOWN 1 LINE,
	CAMN T,DISVP1	;DO A LINEFEED INSTEAD OF ^PV.
	 HRLI Q,DISCM2	;(USES LESS SPACE IN SYSTEM OUTPUT BUFFER).
DISLN3:	BLT Q,DISBF1+1	;SET UP THE POSITIONING TO BE DONE.
	MOVEM F,DISVP1	;REMEMBER WHAT LINE THE CURSOR IS ON.
	JRST DISLI1	;GO OUTPUT POSITIONING & LINE.

DISLI0:	SKIPL DISVP	;ON PRINTING TTY,
	 CAMN F,DISVP	;IF NOT SAME LINE AS BEFORE, LINEFEED.
	  JRST DISLI1
	HRROI Q,[ASCIC//]
	CALL DISIOT
DISLI1:	SKIPGE Q,CHCTBP	;GET THE STUFFING B.P. AND MAKE NORMALIZE IT
	 SUB Q,[400000,,1]	;BY CONVERTING 441000,,FOO TO 041000,,FOO-1
	CAMG F,CHCTVS			;IF BELOW END OF SCREEN, OR
	 CAME Q,[041000,,DISBUF-1]	;IF NON-NULL LINE AT END OF SCREEN,
	  CAMGE F,CHCTVS
	   JRST DISLN4
	JRST DISMOR	;GO PRINT --MORE--, COME BACK.

DISLN4:	CAMGE F,USZ	;HERE WHEN WE KNOW WE MUST OUTPUT THE LINE.  STORE NEW HASHCODE.
	 SKIPN RGETTY
	  CAIA
	   MOVEM CH,HCDS(F)
	SETZ T,		;COUNT THE NUMBER OF UNUSED BYTES IN THE LAST WORD
DISLI2:	TLNE Q,700000	;OF THE OUTPUT BUFFER.
	 AOJA T,[IBP Q ? JRST DISLI2]
	MOVEI Q,1-DISBF1(Q)
	LSH Q,2
	SUBM Q,T	;# OF CHARS TO BE OUTPUT.
	CALL DISSIOT	;OUTPUT THAT MANY CHARS STARTING AT DISBF1
DISLI3:	MOVEM F,DISVP	;INDICATE WHERE WE HAVE PUT THE CURSOR.
	SKIPN RGETTY	;ON A DISPLAY, CONSIDER STOPPING OUTPUT BECAUSE OF INPUT AVAIL.
	 JRST DISLN1
			;IF JUST PUTTING CURSOR ON --MORE-- LINE (AT Z),
	CAML F,CHCTVS	;DON'T CONSIDER STOPPING FOR INPUT OR RROLDZ,
	 JRST DISLN1	;SINCE A) NO TIME TO SAVE, AND B) CAUSES BUGS.
	SKIPL CHCTNL	;IF AFTER THIS BUFFERFULL STARTS A NEW LINE,
	 JRST DISLN2
;SET UP LINBEG WORD FOR LINE AFTER THIS ONE, IN CASE WE DECIDE TO STOP DISPLAYING NOW.
;IF WE DO, THE LINBEG WORD FOR THE NEXT LINE IS NECESSARY FOR STARTING UP AGAIN.
	MOVE T,RRCCHP	;STARTING HPOS IS CURRENT HPOS UNLESS
	CAME T,CHCTHP	;WE ARE CONTINUINMG IN MIDDLE OF A CHAR,
	 SUB T,NHLNS	;IN WHICH CASE IT IS MINUS THE NUMBER
		;OF POSITIONS USED ON PREV. LINE BY THIS CHAR.
	LSH T,33	;PUT STARTING HPOS IN TOP 9 BITS.
	ADD T,CHCTNL	;PUT STARTING PT OF LINE IN LOW 33 BITS.
	EXCH T,LINBEG+1(F)
	SETZM DISFLF	;IN CASE WE EXIT, MAKE SURE DISFLF DOESN'T STAY SET.
	ADD T,Z		;TAKE INTO ACCOUNT INSERTIONS & DELETIONS.
	SUB T,RROLDZ
	SKIPN RREBEG	;IN ^R MODE, IF SAME LINE STARTED
	CAME T,LINBEG+1(F) ;WITH SAME CHARACTER IN SAME COLUMN
	 JRST DISLN2
	TLZ T,777000	;AND ALL THE CHANGED AREAS ARE PAST
	CAMLE T,RRMAXP
	 AOJA F,RRDISF	;NO NEED TO KEEP THINKING.
DISLN2:	SKIPE RREBEG
	 JRST DISLN1
	MOVEM F,RRMNVP	;NO NEED TO REDISPLAY THIS LINE
	SKIPL CHCTNL	;START WITH NEXT LINE IF ITS LINBEG IS
	 AOS F,RRMNVP	;SET UP; ELSE START FROM THIS LINE.
	SETZM RRMNHP	;THUS MAKE SURE REDISPLAY STARTS THIS FAR UP AT LEAST.
	.STATUS TYIC,T	;ARE CHARS AVAILABLE FOR ^R TO PROCESS.
	TRNN T,2000	;IF SO, STOP DISPLAYING AND PROCESS THEM.
	 JRST [	MOVE T,CHCTNL	;MAKE SURE NEXT REDISPLAY DOESN'T
		CAMLE T,RRMAXP	;STOP BEFORE REACHING THIS FAR DOWN.
		 MOVEM T,RRMAXP	;WITHOUT THIS, <CR> <RUB> <RUB>
		JRST RRDISX]	;LOSES IF TYPED QUICKLY.
DISLN1:	REST F
	REST T
DISLI6:	MOVE Q,[441000,,DISBUF]
	MOVEM Q,CHCTBP	;RE-INIT BUFFERING.
	MOVE Q,CHCTHP	;REMEMBER STARTING HORIZ POS. OF NEXT LINE.
	DPB Q,[DISCPH]
	DPB Q,[DISC1H]
	DPB Q,[DISC2H]
	MOVEI Q,4*DISBFC-6
	MOVEM Q,DISBFC
	POPJ P,

;OUTPUT C(T) CHARS STARTING AT DISBF1, WITH SUPER-IMAGE SIOT.
DISSIOT:MOVE Q,[441000,,DISBF1]
DISLI5:	ILDB CH,Q	;SKIP ALL %TDNOP'S AT THE BEGINNING.
	CAIN CH,%TDNOP
	 SOJG T,DISLI5
	JUMPE T,CPOPJ	;NO CHARS REALLY NEED TO BE SENT => RETURN.
	ADD Q,[100000,,]
	MOVEI CH,SIOC
	SKIPN RGETTY	;ON PRINTING TTYS, DON'T USE SUPER-IMAGE MODE.
	 MOVEI CH,TYOC
	SYSCAL SIOT,[CH ? Q ? T]
	 .LOSE 1400
	SKIPN RGETTY
	 RET
	MOVE Q,CHCTHP
	JUMPN Q,DISSI1
	SKIPGE DISFLF
	 AOS Q
DISSI1:	SYSCAL SCPOS,[CH ? F ? Q]
	 .LOSE 1400
	RET

;PRINT --MORE--, GO BACK TO DISLI3 IF FLUSHED, ELSE TO DISLI7.
;IN ^R MODE, EXIT RESTORING P FROM DISPRR.
DISMOR:	SKIPGE ERRFLG
	 JRST DISLN1
	SKIPN RREBEG
	 JRST [	MOVE P,DISPRR	;IN ^R MODE: WE WANT TO POP BACK TO ^R PDL LEVEL.
		SKIPN RGETTY	;^R MODE ON PRINTING TTY:  WE'RE ALREADY IN POSITION.
		 RET
		SKIPG MORESW	;^R ON DISPLAY: IF --MORE-- IS NOT ALREADY ON SCREEN,
		 SETOM DISOMD	;PRETEND THAT ..J HAS CHANGED SO IT WILL BE WRITTEN.
		JRST DISMD]	;UPDATE --MORE-- LINE AND RETURN TO ^R.
	SETOM DISOMD
	SKIPN RGETTY
	 JRST DISMO3	;ON PRINTING TTY, JUST ASSUME FLUSHED.
	MOVEI T,8	;ON DISPLAY, MUST DO THE POSITIONING THAT DISLIN DIDN'T DO.
	CAMG F,USZ
	 CALL DISSIOT
	SKIPN ORESET
	 SKIPE MORFLF
	  JRST DISLI3	;ALREADY FLUSHED.
	CALL DISMD	;UPDATE THE "MODE" DISPLAYED ON --MORE-- LINE, FROM Q..J.
	MOVE Q,[-2,,MORECL]
	SKIPE RGETTY	;MAKE SURE --MORE-- STARTS IN COLUMN 0.
	 CALL DISIOT
	MOVE Q,[-2,,[ASCIC/--MORE--/]]
	PUSHJ P,DISIOT
	SKIPGE CTLCF	;^C IMPLIES FLUSH IT.
	 JRST DISMO2
	HRRZM P,MORESW	;--MORE-- LINE HOLDS --MORE BUT NO --FLUSHED (OR, IT WILL).
	TTYACT
	PUSHJ P,TYI
	CAIN CH,40	;READ A SPACE =>
	 JRST [	PUSHJ P,DISTOP	;TOP OF SCREEN, THEN TRY AGAIN.
		SKIPL VREMEM	;IF DISPLAYING STUFF THAT'S IN BUFFER,
		 JRST DISLI7
		MOVE Q,CHCTBL	;REMEMBER WHERE THIS SCREENFULL STARTED,
		SUB Q,BEGV	;NEXT BUFFER DISPLAY WILL TRY TO START AT SAME PLACE.
		MOVEM Q,GEA
		JRST DISLI7]
	CAIE CH,177	;ELSE RE-READ UNLESS RUBOUT.
	 MOVEM CH,UNRCHC
	HRRZM P,MORFLF
	CAIE CH,177	;SET MORFLF (FS FLUSHED$) TO NONZERO, POSITIVE IFF RUBOUT.
DISMO2:	 SETOM MORFLF
	MOVE Q,[-2,,[ASCIC/-FLUSHED/]]
	PUSHJ P,DISIOT
	SETOM MORESW	;SAY --MORE-- LINE HAS -FLUSHED ON IT.
	JRST DISLI3

DISMO3:	SETOM MORFLF
	JRST DISLI3

;INIT FOR DISPLAY OUTPUT.
DISINI:	SETOM TYOFLG	;"TYPEOUT" NO LONGER INITTED.
	MOVE Q,QRB..
	SETOM .QVWFL(Q)
DISIN0:	PUSHJ P,CHCTI0	;INIT FOR CHCT.
	MOVEI Q,DISLIN	;TELL IT TO CALL DISLIN EACH LINE.
	MOVEM Q,CHCTAD
	PUSHJ P,DISLI6	;INIT. BUFFERING.

;MOVE TO TOP OF SCREEN.
DISTOP:	SETZM MORFLF	;UNDO A FLUSHED.
	SETOM DISVP
	SETZM DISVP1
	MOVE Q,USZ
	MOVEM Q,CHCTVS
	CALL RUBEND	;MAYBE TYPE SOMETHING ARRANGED IN ADVANCE (EG, LF AFTER ^B IN ^R MODE).
	HRROI Q,[ASCIC /A/]
	SKIPN RGETTY
	 JRST DISIOT	;ON PRINTING TTY'S, MOVE TO A CLEAN LINE.
	SAVE B
	MOVE B,NLINES	;SET UP WINDOW SIZE FROM USER-SETTABLE FLAGS (LINES AND TOPLINE).
	CALL WINSET
	REST B
	MOVE Q,TOPLIN
	MOVEM Q,CHCTVP
	MOVE Q,BOTLIN
	MOVEM Q,CHCTVS
	SKIPGE ERRFL1
	 RET
IFN TS,[
	AOSN PJATY	;RESPOND TO %PJATY INTERRUPT BY CLEARING SCREEN
	 CALL CTLL1
]
	HRROI Q,[ASCIC/T/]
	JRST DISIOT

;START "TYPEOUT" AT TOP OF SCREEN.
DISTOT:	SETOM TYOFLG	;FORCE RE-INIT.

;INIT FOR TYPEOUT, PREVENT BUFFER DISPLAY.
;ALL TYPEOUT ROUTINES MUST COME HERE.
DISINT:	MOVE Q,QRB..
	SETOM .QVWFL(Q)
	AOSE TYOFLG	;IF NO PREVIOUS TYPEOUT,
	 RET
	JRST DISIN0

IFN TS,[
CTLL:	SKIPLE CLRMOD	;SCREEN-CLEARING MAY BE DISABLED.
	 RET
	SKIPE RGETTY	;ON DISPLAYS, EFFECTIVELY CLEAR ECHO AREA WITH A CR.
	 .IOT ECHOC,[^M]
	MOVE Q,QRB..
	SETZM .QVWFL(Q)	;ALLOW BUFFER DISPLAY.
	SETOM TYOFLG	;NEXT TYPEOUT WILL START AT TOP OF SCREEN.
	SETOM GEA	;ALLOW NEW TEXT WINDOW TO BE CHOSEN.
	SKIPN TOPLIN
	 SKIPE NLINES	;IF NOT USING WHOLE SCREEN FOR WINDOW NOW,
	  JRST CTLL2	;CLEAR JUST WHAT'S IN THE WINDOW.
CTLL1:	SETZM PJATY	;HERE TO CLEAR WHOLE SCREEN.
	SETZM MORESW	;BE AWARE THAT --MORE-- IS BEING ERASED.
	HRROI Q,[ASCIC/C/]
	.IOT DCHN,Q
	SETOM DISOMD	;REDISPLAY THE "MODE" ON THE --MORE-- LINE.
	SETZM HCDS	;SET HASH CODES TO 0
	MOVE Q,[HCDS,,HCDS+1]
	BLT Q,HCDSE-1	;SINCE 0 IS CODE FOR A NULL LINE
	RET

CTLL2:	CALL DISINI	;CLEAR WINDOW AREA BY DOING A "BUFFER DISPLAY" OF NO CHARACTERS.
	JRST DISCLG	;NOW REST OF SCREEN, MEANING ALL OF WINDOW.
]

DISCLG:
IFN RMSSW,[	CAME IN,PT
	 JRST DISCL3
	SKIPN RREBEG
	 CALL RRDIS1]
DISCL3:	SETZM VREMEM
	SETZM VIEWBF
	SETOM TYOFLG	;FORCE NEXT TYPEOUT TO CALL DISINT
	CALL DISFLS	;FORCE OUT ANY INCOMPLETE LINE.
	SKIPN ORESET
	SKIPE MORFLF	;IF WE WERE FLUSHED AT A --MORE--, JUST UN-FLUSH.
	 JRST DISCLH
	SKIPN RGETTY	;ELSE, ON DISPLAY TTY, CLEAR REST OF SCREEN
	 JRST DISCLJ
DISCL2:	MOVE F,CHCTVP
	CAML F,CHCTVS	;BY LINEFEEDING UNTIL GET TO BOTTOM.
	 JRST DISCLJ
	MOVEI CH,^J
	SETOM CHCTCF	;MAKE SURE THE ^J WILL CRLF, RATHER THAN UPARROW-J.
	CALL CHCTLF
	SKIPN ORESET
	SKIPL MORFLF	;MUST CHECK MORFLF, SINCE, IF IT'S SET, CHCTVP
	 JRST DISCL2	;WILL NOT BE INCREMENTED.
;MAKE SURE THE --MORE-- LINE DOESN'T SAY "--MORE--", AND HAS THE
;CORRECT MODE DISPLAYED ON IT.
DISCLJ:	MOVE Q,$QMODE
	CAME Q,DISOMD
	 CALL [	SETZM MORESW ? JRST DISMD9]
	MOVE Q,[-2,,MORECL] ;THERE ISN'T ANY MORE, SO MAKE SURE SCREEN
	SKIPE MORESW
	 CALL DISIOT	;DOESN'T SAY --MORE--.
	SETZM MORESW
DISCLH:	SETZM MORFLF
	POPJ P,

IFN TS,[
DISIOT:	.IOT DCHN,Q
	RET
]


IFN TS,[
;IMMEDIATE TYPEOUT, NO HASH-CODING.
TYOINV:	HRROI T,CH
	ROT CH,-7
	IOR CH,[ASCIC/ /]
	.IOT DCHN,T
	POPJ P,
]

TYANOW:	PUSHJ P,TYOA	;TYPEOUT, NO CURSOR, NO SLASH.
	JRST DISFLS	;FORCE IT OUT IMMEDIATELY.

DISMDI:	MOVE Q,$QMODE	;UPDATE MODE DISPLAY IF IT IS NECESSARY
	SKIPE RGETTY
	 CAMN Q,DISOMD
	  RET
	SKIPGE Q,UNRCHC	;AND THERE IS NO INPUT AVAILABLE.
	 .LISTEN Q,
	JUMPN Q,CPOPJ
	HRROI Q,[ASCIC/S/]	;AVOID CLOBBERING CURSOR POSITION.
	CALL DISIOT
	CALL DISMD9	;NO INPUT: DISPLAY THE NEW "MODE"
	HRROI Q,[ASCIC/R/]
	JRST DISIOT

;UPDATE, IF NECESSARY, THE "MODE" DISPLAYED ON THE --MORE-- LINE.
;THE "MODE" IS A TEXT STRING STORED IN Q..J. THE CONTENTS OF THAT QREG ARE
;ALWAYS VISIBLE ON THE --MORE-- LINE. THE IDEA IS FOR THE USER TO BE
;ABLE TO TELL IMMEDIATELY WHAT MODE HE IS IN (WHERE THE MODES ARE DEFINED
;BY HIS MACROS PACKAGE).
DISMD:	MOVE Q,$QMODE	;WHAT IS THE DESIRED STRING?
	CAMN Q,DISOMD	;IS THAT THE SAME AS WHAT WAS DISPLAYED LAST?
	 RET
DISMD9:	SKIPN RGETTY	;NO MODE IS SHOWN ON PRINTING TTY'S.
	 RET
	MOVE Q,$QMODE
	MOVEM Q,DISOMD
INSIRP PUSH P,A AA TT TT1 F CH
	MOVE A,Q
	MOVE Q,[-2,,MORMCL]	;CLEAR THE WHOLE --MORE-- LINE.
	CALL DISIOT
	SETOM RROHPO	;REMEMBER THAT I.T.S. CURSOR POS. IS BEING CLOBBERED.
	SETOM RROVPO
	CALL QLGET0
	 JRST DISMD1	;MODE STRING IS NULL?
	SAVE AA
DISMD3:	SOJL AA,DISMD2
	ILDB CH,F	;NO, DISPLAY IT.
	CALL TYOINV
	JRST DISMD3

DISMD1:	TDZA AA,AA
DISMD2:	 REST AA	;ASSUMING EACH CHAR OF MODE IS 1 WIDE, AA HAS HPOS AFTER MODE.
	ADDI AA,10
	DPB AA,[MORECH]
INSIRP POP P,CH F TT1 TT AA A
	SKIPN RREBEG
	 SKIPN RRMORF
	  SKIPN MORESW	;IF THERE WAS A --MORE-- THAT WE ERASED, WRITE ONE BACK.
	   RET
	MOVE Q,[-2,,[ASCIC/--MORE--/]]
	JRST DISIOT

IFN TS,[

TSIN2:	TRZN B,TYPIN
	JRST TSIN2A
TSINT1:	MOVEI A,TYIC
	.ITYIC A,
	 JRST TSIL
	HRRZ CH,TSINT+1
	CAIN CH,ASLEE2	;IF M.P. IS INSIDE A :^S, WAKE IT UP
	 AOS TSINT+1	;(IT HAS ARRANGED FOR ALL CHARS TO INTERRUPT)
	TRZ A,SHIFT+SHIFTL
	TRNE A,CONTRL
	 ANDCMI A,CONTRL+140
	CAIN A,33	;ALTMODE => CHECK FOR TWO TOGETHER.
	 JRST TSINT6
	SETZM TSINAL	;ELSE PREV. CHAR. WASN'T ONE.
	CAIE A,^G
	 JRST TSIL
	SETOM STOPF
	SKIPE RREBEG	;^G'S QUITTING ACTION SUPPRESSED INSIDE ^R PROPER (NOT MACROS).
	SKIPLE NOQUIT
	 JRST TSIL
	HRRZ A,TSINT+1
	SKIPE NOQUIT	;IF QUITTING DOES AN ORDINARY ERROR,
	 JRST TSINT5	;AVOID RESETTING I-O.
	HLRZ CH,(A)
	ANDI CH,777740
	CAIN CH,(.IOT DCHN,)	;DON'T RETURN TO HUNG OUTPUT .IOT
	 SKIPE RGETTY	;EXCEPT TO DATAPOINT.
	  CAIN CH,(.IOT BDCHN,)
	   AOS A,TSINT+1
	SKIPN RGETTY
	 .RESET DCHN,
	.RESET TYIC,
	SETOM ORESET	;SIGNAL TYPEOUT ROUTINES TO STOP TYPING
TSINT5:	CAIE A,TYIW
	SKIPE IMQUIT
	 CALL QUIT0	;QUIT, ERR, OR DO NOTHING ACCORDING TO NOQUIT.
	JRST TSIL

TSINT4:	SOS TSINT+1	;COME HERE FOR MPV INT.
	HRRZ A,TSINT+1	;CATCH JUMPS TO RANDOMNESS.
	CAIL A,CBUF
	 .VALUE
	.SUSET [.RMPVA,,A]	;GET ADR START OF MISSING PAGE.
	LSH A,-12
	CAIL A,MXMEMT	;DON'T GRAB INFINITE CORE.
	 TYPRE [URK]
	SYSCAL CORBLK,[1000,,400000 ? 1000,,-1 ? A ? 1000,,400001]
	 .VALUE
	LSH A,12
	ADDI A,2000	;ADDR OF WORD ABOVE THE PAGE WE JUST GOT.
	CAMLE A,MEMT	;IF THIS PAGE IS ABOVE ALL OTHERS, ADJUST MEMT.
	 MOVEM A,MEMT
	JRST TSIL

TSINT6:	SKIPE DISPRR	;HANDLE INTERRUPT FROM ALTMODE
	 JRST TSIL	;DO NOTHING IF INSIDE ^R.
	SETCMM TSINAL	;REMEMBER PARITY OF ALTMODES,
	SKIPN TSINAL	;IF SECOND, STOP DISPLAYING BUFFER.
	JRST [	AOS TSALTC	;COUNT # $$'S SEEN.
		JRST TSIL]
	CALL TTYAC2
	JRST TSIL
]

IFN TS,[
FFRDEV:	TROA FF,NOTF
]
FRD:	TRZ FF,NOTF
	TROA FF,ALTF
FFRRDD:	 TRZ FF,ALTF+NOTF
	MOVE A,UTF1
	MOVE AA,UTF2
	SETOM FFRRCT
	TRO FF,FINDR
F1:	MOVEI C,0
	MOVE B,[440600,,C]
F2:	PUSHJ P,LRCH
	SKIPGE SQUOTP
	 JRST F3
	SKIPN SQUOTP
	 CAIE CH,ALTMOD
	  CAIN CH,40
	   JRST SFN
	CAIN CH,^I
	 JRST SFN
	CAIN CH,^A	;^A REFERS TO DEFAULT FIRST FILENAME.
	 JRST F6A
	CAIN CH,^B	; REFERENCES SECOND DEFAULT FILE NAME
	 JRST F6
IFN TS,[CAIN CH,";
	JRST SYSN
	CAIN CH,":
	JRST DEVN
]
	CAIL CH,40	;OTHER NON-CTL CHARS  GO IN NAME.
	 JRST F3
	CAIE CH,^Q	;CTL CHARS EXCEPT ^Q IGNORED.
	 JRST F2
	PUSHJ P,LRCH	;^Q QUOTES NEXT CHAR.
F3:	SUBI CH,40
	TLNE B,770000
	IDPB CH,B
	JRST F2

IFN TS,[
SYSN:	SKIPE C
	 MOVEM C,UTSNM
	.SUSET [.SSNAM,,C]
	TRNN FF,FINDR
	 JRST F1	;DEVICE HAS BEEN SPECIFIED
	LDB B,[301400,,UTF]
	CAIE B,' ML
	CAIN B,' AI
	JRST F1
	CAIE B,(SIXBIT \ DS\)
	CAIN B,(SIXBIT \ DK\)
	JRST F1
	CAIE B,(SIXBIT \ CL\)
	CAIN B,(SIXBIT \ PK\)
	JRST F1
	MOVSI B,(SIXBIT \DSK\)
	MOVEM B,UTF
	JRST F1

DEVN:	TRZ FF,FINDR
	MOVEM C,UTF
	CAIN CH,ALTMOD
	 JRST SFN2
	JRST F1
]
F6A:	MOVE C,UTF1
	JRST SFN0

F6:	SKIPA C,UTF2
SFN:	JUMPL B,SFN1
SFN0:	TRNE FF,NOTF	;COME HERE WITH NEXT FILENAME IN C.
	 JRST DEVN	;JUST READING DEV AND SNAME => THIS IS DEV
	AOSE FFRRCT
	 MOVE A,AA
	MOVE AA,C
SFN1:	CAIE CH,ALTMOD
	 JRST F1
SFN2:	SKIPL FNAMSY
	 SKIPA C,UTF2
	  MOVSI C,'>_14
	SKIPE FNAMSY	;NONZERO FNAMSY SAYS
	 SKIPE FFRRCT	;IF ONLY ONE FILENAME
	  CAIA
	   JRST SFN0	;USE ">" OR PREVIOUS DEFAULT AS SECOND.
	TRZE FF,ALTF
	 RET
	MOVEM A,UTF1
	MOVEM AA,UTF2
	RET

;FS DFILE$ -- THE DEFAULT FILE NAMES, AS A STRING.  CAN BE READ OR SET.
FSDFILE:CALL FSDFRD
	TRZN FF,ARG
	 JRST POPJ1 
	MOVEI C,[ASCIZ /[0 U0 ET0 ]0/]
;HERE TO MACRO QREG OR ASCIZ IN C, WITH ARG IN B, SAVING LOTS OF STUFF.
MACXCC:	SAVE A			;PRESERVE WHAT WE ARE ABOUT TO RETURN, AND EVERYTHING ELSE.
	JSP T,OPEN1
	MOVEM B,NUM
	MOVE A,C
	CALL MACXCW
	HRROI T,POPAJ1
	TRZ FF,ARG\ARG2\COLONF\SLSL\OPFLG\SYLF
	JRST CLOSE2

FSDFRD:	SAVE B
	MOVEI B,14.*4
	CALL QOPEN	;MAKE SURE ENOUGH SPACE, SET UP F AND LISTF5 TO STORE INTO STRING.
	MOVE A,UTSNM	;WRITE THE DATA THROUGH THAT BYTE POINTER.
	MOVEI B,";
	CALL SIXINT	;FIRST SNAME AND ";" AND A TAB
	MOVEI CH,^I
	IDPB CH,F
	MOVE A,UTF
	MOVEI B,":	;THEN DEVICE NAME, ":", AND A TAB
	CALL SIXINT
	MOVEI CH,^I
	IDPB CH,F
	MOVE A,UTF1	;THEN FN1 AND A TAB
	MOVEI B,^I
	CALL SIXINT
	MOVE A,UTF2	;AND THE FN2.
	CALL SIXIN1
QCLOSV:	CALL GETCA	;WHERE DID WE STOP IDPB'ING?
	AOS F
	MOVE B,F
	MOVE F,QRWRT	;F GETS PLACE TO WRITE HEADER.
	MOVE OUT,B	;OUT GETS NEW VALUE FOR QRWRT.
	SUB B,F		;B GETS LENGTH OF WHAT WE JUST WROTE (INCL HEADER)
	MOVEI AA,QRSTR
	CALL QHDRW0	;WRITE THE HEADER
	REST B
	MOVEI CH,A
	JRST QCLOSE

;MAKE SURE THERE IS SPACE I IMPURE STRING SPACE FOR C(B) CHARS,
;THEN SET UP LISTF5 TO IDPB THRU F INTO IMPURE STRING SPACE.
QOPEN:	CALL SLPQGT	;MAKE SURE EXISTS ENOUGH SPACE (14 PER FILENAME >> ENOUGH).
	MOVE F,QRWRT	;START WRITING INTO UNUSED IMPURE STRING SPACE
	ADDI F,4	;SKIPPING ROOM FOR THE NEW STRING'S HEADER-TO-BE.
	CALL GETIBP
	MOVEI A,[IDPB CH,F ? RET]
	HRRM A,LISTF5
	POPJ P,

IFN TS,[
LISTF:	CALL FFRDEV	;EY COMMAND - READ DEV NAME.
CNTRU1:	CALL VBDACU	;IF THERE'S A CMD STRING PENDING,
	 RET		;DON'T BOTHER OPENING THE DIR.
	SETZ CH,
	CALL DISINI
	SKIPA OUT,[CHCT]
LISTFM:	 MOVEI OUT,TYOM	;EZ AND EM COMMANDS.
LSTF1:	TRNE CH,20
	 CALL FFRDEV
LSTF2:	TLZ FF,CTLUF
	HRRM OUT,LISTF5
	CALL AOFDIR
LISTF2:	HRRZ OUT,LISTF5
	CALL GFDBLK
	CAIN OUT,TYOM	;IF DUMPING CRUD INTO BUFFER,
	 JRST LSTF3	;THEN DO IT FAST
LISTF6:	ILDB CH,FDRP
	CAIE CH,EOFCHR
	 CAIN CH,14
	  JRST LISTF%
	CALL @LISTF5
	JRST LISTF6

LSTF3:	ANDI CH,-1
	CAIE CH,FDRBUF	;DONT ALLOW TO BACK UP BEFORE BEGINNING
	 SUBI CH,1	;BACK UP TO LAST WORD .IOT'ED INTO
	CAIE CH,FDRBUF	;IF NOT POINTING TO BEGINNING OF BUFFER,
	 SUBI CH,1	;THEN BACK UP A WORD FOR "FORM FEED AT END OF LAST WORD" SCREW
	MOVEI C,-FDRBUF(CH)	;GET INDEX INTO BUFFER IN C
	IMULI C,5	;CONVERT C TO NUMBER OF CHARACTERS UP TO THIS WORD
	HRLI CH,440700	;CONVERT TO BYTE POINTER TO WORD
LSTF4:	ILDB A,CH	;GET CHARACTER FROM LAST WORD (DOES THIS LOOK BACKWARDS TO YOU?)
	CAIE A,14	;IF FORM FEED,
	 CAIN A,EOFCHR	;OR IF EOF CHARACTER,
	  JRST .+2	;THEN FOUND END
	   AOJA C,LSTF4	;HAVEN'T FOUND END YET, LOOP BACK
	JUMPE C,CPOPJ	;IF NO CHARACTERS THEN THAT'S ALL FOR THIS ROUTINE
	CALL GAPSLP
	MOVEI B,(C)
	CALL SLPGET	;INSERT THAT MANY CHARS, GET IDPB BP IN F.
	ILDB CH,FDRP	;NOW GET CHARACTER TO COPY
	IDPB CH,F	;COPY IT
	SOJG C,.-2	;DO IT THE APPROPRIATE NUMBER OF TIMES
	IBP FDRP	;INCREMENT FDRP TO MAKE IT APPEAR THAT THE ACTUAL EOF CHARACTER WAS ENCOUNTERED

		;PROCESS THE NEXT BLOCK OF THE FILE DIRECTORY BEING LISTED

LISTF%:	SKIPL MORFLF
	 JRST LSTF%2
	HRRZ A,LISTF5	;USER HAS "FLUSHED", SEE IF TYPING OUT
	CAIN A,CHCT
	 JRST LSTF%3	;TYPING OUT, STOP NOW
LSTF%2:	HRRZ CH,FDRP
	CAIN CH,FDRBFE
	 JRST LISTF2	;MORE TO COME
LSTF%3:	.CLOSE FDRC,
	HRRZ A,LISTF5
	CAIN A,CHCT
	 JRST DISCLG
	POPJ P,
]

CRR:	MOVEI CH,TYO
	HRRM CH,LISTF5
IFN TS,[PUSHJ P,CRR1
	JRST DISFLS]
CRR1:	MOVEI CH,15
	PUSHJ P,@LISTF5
	MOVEI CH,12
	JRST @LISTF5

CTLQM:	SKIPA CH,[^Q]
SPSP:	MOVEI CH,40
	JRST @LISTF5

FORMF:	MOVEI CH,^M
	CALL @LISTF5
	MOVEI CH,^L
	JRST @LISTF5

LFILE:	MOVE A,UTSNM
	MOVEI B,";
	PUSHJ P,SIXINT
	MOVE A,UTF
	MOVEI B,":
	PUSHJ P,SIXINT
	MOVE A,UTF1
	MOVEI B,40
	PUSHJ P,SIXINT
	MOVE A,UTF2
;OUTPUT A WORD OF SIXBIT, WITH ^Q'S AS NEC. SO TECO CAN READ BACK IN AS FILENAME.
SIXIN1:	JUMPE A,CPOPJ
	MOVEI AA,0
	ROTC A,6
	JUMPE AA,SIXIN2
	CAIE AA,':
	CAIN AA,';
SIXIN2:	PUSHJ P,CTLQM
	MOVEI CH,40(AA)
	PUSHJ P,@LISTF5
	JRST SIXIN1

SIXINT:	PUSHJ P,SIXIN1	;INSERT IN THE BUFFER THE SIXBIT WORD IN A
	MOVE CH,B	;AND THE ASCII CHAR IN B
	JRST @LISTF5

SIXINS:	PUSHJ P,SIXIN1
	JRST CRR1	;END WITH CRLF

;OUTPUT ASCIZ STRING <- A, THRU LISTF5.
ASCIND:	HRLI A,BP	;GET BP TO STRING.
ASCIN1:	ILDB CH,A
	JUMPE CH,CPOPJ
	XCT LISTF5
	JRST ASCIN1

SIXNTY:	PUSH P,OUT
	MOVE OUT,C
SIXNT1:	SETZ CH,
	ROTC OUT,6
	ADDI CH,40
	CALL @LISTF5
	JUMPN OUT,SIXNT1
	REST OUT
	POPJ P,

TYPR:	MOVEI IN,6
TYPR3:	MOVE OUT,[(600)C-1]
	ILDB CH,OUT
	ADDI CH,40
	XCT LISTF5
	SOJG IN,.-3
TYPR2A:	POPJ P,LISTF4

SLTAB:  LISTF4:
	MOVEI CH,^I
	JRST @LISTF5

;FE -- INSERT A "TECO ERROR" FILE IN THE BUFFER BEFORE PT.
;:FE -- INSERT A LIST OF NAMES OF FS FLAGS.
;<N>FE -- INSERT IN BUFFER THE 3-LETTER CODE
 ;AND MESSAGE ASSOCIATED WITH ERROR CODE <N>
;^ FE<CHARS>$ -- RETURNS THE ERROR CODE ASSOCIATED WITH THE 3-CHAR
 ;MESSAGE <CHARS>.
FECMD:	TRZE FF,SLSL
	 JRST FECMU
	MOVSI T,-LERTAB
	MOVEI A,TYOM	;TYPEOUT INTO BUFFER AT PT.
	HRRM A,LISTF5
	CALL GAPSLP
	TRNE FF,COLONF	;:FE - INSERT LIST OF FS FLAGS.
	 JRST FECMD3
	TRZN FF,ARG
	 JRST FECMD2	;NO ARG, INSERT A LINE FOR EACH ERROR.
	MOVE A,B	;AN ARG (ERROR CODE) IS JUST A STRING, SO GET IT.
FECMD6:	CALL QGET3
	JRST CRR1

FECMD2:	SAVE PT			;SAVE CURRENT PT SO CAN SET UP INSLEN.
FECMD5:	MOVE A,ERRTAB(T)
	HRLI A,400000		;MAKE STRING PTR TO NEXT ERROR MESSAGE.
	SAVE T
	CALL FECMD6		;INSERT EACH ERROR MESSAGE IN THE BUFFER.
	REST T
	AOBJN T,FECMD5
	REST B			;B GETS OLD PT.
	SUB B,PT
	MOVNM B,INSLEN		;FKD WILL DELETE THE WHOLE TABLE.
	RET

FECMD3:	MOVSI T,-FLAGSL
FECMD4:	MOVE C,FLAGS(T)	;GET THE NEXT FLAG'S NAME
	CALL TYPR	;AND TYPE IT OUT INTO BUFFER.
	CALL CRR1	;EACH NAME GOES ON A LINE.
	AOBJP T,CPOPJ	;WHEN THRU, UNBIND LISTF5 AND DONE.
	AOJA T,FECMD4	;HANDLE NEXT FLAG NAME.

;HANDLE ^ FE.
FECMU:	MOVE AA,[220600,,B]	;ACCUMULATE 3 6BIT CHARS IN A.
	MOVEI B,404040
FECMU1:	CALL LRCH
	CAIN CH,ALTMOD
	 JRST FECMU3
	IDPB CH,AA
	CAME AA,[000600,,B]
	 JRST FECMU1
	CALL FNOOP
FECMU3:	XORI B,404040		;GOT 3; FINISH TURNING INTO 6BIT.
	MOVSI A,-LERTAB		;NOW SEARCH ERROR TABLE FOR THIS ERROR.
FECMU2:	HLRZ TT,ERRTAB(A)
	CAIE TT,(B)
	 AOBJN A,FECMU2		;STOP WHEN FIND IT, OR AT END OF ERRTAB.
	CAIN A,LERTAB		;IS IT THE END?
	 JRST NRET0		;YES, NO SUCH ERROR MESSAGE, RETURN 0.
	HRRZ A,ERRTAB(A)
	HRLI A,400000		;ELSE RETURN POINTER TO THE ERROR STRING.
	JRST POPJ1

;ROUTINE FOR FS ERROR$.
FSERR:	MOVE A,LASTER
	TRNN FF,ARG
	 JRST POPJ1	;READING ONLY - RETURN LAST EROR'S CODE.
	MOVEM B,LASTER
	JRST DISTOE

;FG -- MAKE A STANDARD ERROR REPORT (USEFUL IN ERROR HANDLER MACROS).
;IF ARG, PRINT STANDARD ERROR MESSAGE FOR THAT ERROR CODE.
  ;AND IF ":", DO IT AT TOP OF SCREEN.
  ;Q..H IS NOT CHANGED BY FG EVEN IF IT DOES TYPEOUT.
;IF "^", THROW AWAY TYPE AHEAD.
;IN ANY CASE, TYPE A BELL.
FGCMD:	MOVE A,QRB..
	SAVE .QVWFL(A)
	TRZE FF,ARG
	 CALL FGCMDP
	MOVE A,QRB..
	REST .QVWFL(A)
	TRZN FF,SLSL
	 JRST TYPBEL
	.RESET TYIC,
	SETZM TSINAL
	SETZM TSALTC
TYPBEL:	.IOT ECHOC,[^G]
	JRST FSECO5

FGCMDP:	JUMPE B,CPOPJ		;THERE WS NO ERROR => DON'T PRINT ERROR MESSAGE.
	TRZE FF,COLONF
	 CALL DISTOT
	MOVE E,VERBOS
FGCMD3:	HRRZM P,ERRFL1		;DON'T LET FS ERRFLG$ STOP THIS FROM PRINTING.
	MOVEI A,TYOA
	HRRM A,LISTF5
	CALL FGCMD1
	MOVEI CH,"?
	CALL TYO
	CALL DISFLS
	MOVE C,TOPLIN
	SUB C,CHCTVP		;HOW MANY LINES WERE USED?
	SOS C
	MOVEM C,ERRFL1		;MAKE SURE THOSE LINES AREN'T ERASED BY REDISPLAY.
	RET

FGCMD1:	MOVE A,B	;PRINT CONTENTS OF STRING IN B.
	CALL QLGET0
	 RET
FGCMD2:	ILDB CH,F
	CAIN CH,^I	;IF E IS ZERO, STOP AT FIRST TAB.
	 JUMPE E,CPOPJ
	XCT LISTF5
	SOJG AA,FGCMD2
	RET

;HANDLE TOP-LEVEL ^X COMMAND:  PRINT THE FULL EROR MESSAGE FOR THE LAST ERROR.
FECMD8:	MOVE B,LASTER
	SETO E,
	JRST FGCMD3

;MARK THE CURRENT MACRO PC FOR THE TOP-LEVEL "?" COMMAND.
ERRP2:	TRO FF,QMFLG
	MOVE A,COMAX
	SUB A,COMCNT
	MOVEM A,ERR1
	MOVE A,CPTR
	MOVEM A,ERR2
	RET

;COME HERE TO REPORT SYSTEM CALL ERROR, ASSUMING THE FILE NAMES ARE IN UTF, ETC.
OPNER1:	MOVEI B,70.	;WRITE A STRING CONTAINING FILENAMES AND I.T.S. ERROR MESSAGE.
	CALL QOPEN	;MAKE SURE ENOUGH SPACE, SET UP F AND LISTF5 TO STORE INTO STRING.
	.SUSET [.RBCHN,,CH]	;GET # OF CHANNEL IN ERROR,
	LSH CH,27
	IOR CH,[.STATUS CH]
	XCT CH		;READ THE ERROR CODE,
	LDB CH,[220600,,CH]
	HRLZM CH,ERRF2
	MOVSI C,'OPN
	CALL SIXNTY	;FIRST IN THE STRING GOES "OPN" FOLLOWED BY 3-DIGIT ERROR CODE.
	LDB CH,[.BP (700),ERRF2]
	CALL DGPT
	LDB CH,[.BP (70),ERRF2]
	CALL DGPT
	LDB CH,[.BP (7),ERRF2]
	CALL DGPT
	MOVEI CH,40
   REPEAT 2,XCT LISTF5	;THEN 2 SPACES.
	CALL LFILE	;THEN THE FILENAMES.
	MOVEI CH,40
   REPEAT 3,XCT LISTF5	;3 SPACES.
	.OPEN ERRC,ERRF	;GET ERROR MESSAGE FROM I.T.S.
	 JRST .-1
OPNER2:	.IOT ERRC,CH	;COPY INTO STRING, STOPPING AT CRLF OR FF.
	CAIE CH,^M
	 CAIN CH,^L
	  JRST OPNER3
	XCT LISTF5
	JRST OPNER2

OPNER3:	.CLOSE ERRC,
	CALL [	SAVE B	;NOW FINISH THE STRING'S HEADER, AND RETURN POINTER IN A.
		JRST QCLOSV]
	MOVEM A,LASTER	;REMEMBER IT AS THE MOST RECENT ERROR'S CODE.
	JRST DISTOE	;NOW GET CAUGHT BY ERRSET INVOKE ERROR HANDLER.


;TYPR4 UUO (TYPRE MACRO) COMES HERE.
ETYP2A:	HRRZ CH,@40	;ERROR, AND IT CAN BE HANDLED NORMALLY; GET THE ERROR CODE.
	HRLI CH,400000
	MOVEM CH,LASTER	;REMEMBER AS CODE OF MOST RECENT ERROR.
	JRST DISTOE	;GET CAUGHT BY ERRSET OR POP.

IMMQIT:	SETOM IMQUIT	;ALLOW QUITS TO HAPPEN AT ANY TIME,
	SKIPL STOPF	;AND QUIT IF ALREADY PENDING.
	 RET
QUIT0:	;CALL HERE IF STOPF IS SET, WHEN IT IS ACCEPTABLE TO QUIT.
QUIT1:	SETZM ORESET	;RE-ALLOW TYPEOUT NOW THAT WE GOT THRU WITH THE COMMAND
	SKIPLE NOQUIT
	 SKIPLE IMQUIT
	  CAIA		;NOQUIT POSITIVE => NO QUITTING AT ALL (UNLESS IMQUIT OVERRIDES)
	   RET
	SETZM STOPF	;ELSE QUIT, AND CLEAR FLAG SAYING WE NEED TO QUIT.
	SKIPG IMQUIT	;IMQUIT POSITIVE ONLY AT STARTUP AND IN COMMAND READER
	 SKIPN NOQUIT	;IF QUITTING SHOULD GO TO TOP LEVEL, DO SO.
	  CAIA
	   TYPRE [QIT]	;NOQUIT NEGATIVE WANTS TO SIGNAL AN ERROR.
	.SUSET [.SPICL,,[-1]]
	SETOM RROVPO
	CALL TYPBEL
	.IOT ECHOC,["^]
	.IOT ECHOC,["G]
	JRST GOX1

DELQIT:	SETZM IMQUIT	;STOP ALLOWING QUITS INSIDE COMMANDS, AND EXIT.
	RET

;CALL HERE TO SIGNAL AN ERROR, AFTER SETTING LASTER.
;DISTOE RETURNS TO AN ERRSET IF THERE IS ONE;  OTHERWISE, IT GOES TO
;GOX1 TO ENTER A BREAK LOOP, INVOKE THE ERROR HANDLER, OR POP TO ^R OR TOP LVL.
DISTOE:	MOVE Q,PT	;ERROR CHECK: IS PT OUT OF BUFFER BOUNDS?
	CAMG Q,ZV
	 CAMGE Q,BEGV
	  .VALUE
	TRNN P,-1
	 .VALUE
	.SUSET [.SPICL,,[-1]]
	SKIPL ERRFLG	;WERE WE ALREADY INVOLVED IN STARTING TO HANDLE AN ERROR?
	 JRST DISTOW
	MOVE CH,[-LPDL,,PDL-1]
	CAME CH,P	;YES; GIVE UP TRYING TO RECOVER AND POP ALL THE WAY UP,
	 PUSHJ CH,SETP	;SINCE TRYING TO HANDLE THIS ERROR NORMALLY WILL PROBABLY
			;CAUSE ANOTHER ERROR.
	SETZM ERRFL1	;PREVENT TYPEOUT OF THE MESSAGE FROM BEING SUPPRESSED.
	CALL DISTOT
	MOVEI CH,TYOA
	HRRM CH,LISTF5	;NOT CAUGHT BY ERRSET, PREPARE FOR TYPEOUT.
	MOVEI A,[ASCIZ/ERROR WHILE ENTERING ERROR HANDLER! POPPING TO TOP LEVEL.
/]
	CALL ASCIND
	JRST CTLW

DISTOW:	SETCM Q,LASTER
	CAIGE Q,1000	;ERRORS OTHER THAN OPEN-FAILURES INHIBIT
	 TLZ FF,CTLUF	;DIRECTORY DISPLAY (AS OPPOSED TO BUFFER DISPLAY)
	SETOM ERRFLG
	CALL ERESET
	HLRZ Q,ITRPTR
	JUMPN Q,ERRP3	;WITHIN AN ERRSET.
	JRST GOX1

;COME WHEN ERROR IS CAUGHT BY ERRSET.
ERRP3:	CALL UNWIND	;POP SOME STUFF OF MACRO PDL, ETC.
	 JRST ERRP4	;DOESN'T SKIP IF HAVE FINISHED UNWINDING; CH = RH(ITRPTR)
	 JRST ERRP3	;SKIPS 1 AFTER POPPING MACRO CALLED BY "M" CMD.
	MOVE CH,MACXP
	POP CH,MACXP
	POP CH,MACPTR
	PUSHJ CH,SETP1	;SKIPS 2 AFTER POPPING A MACXQ OR MACXCW.
	REST MACXP
	REST MACPTR
	JRST ERRP3

ERRP4:	HRROI Q,MFCCNT-MFBLEN+1(CH)
	POP Q,COMCNT	;POSITION AT THE FRONT OF THE ERRSET
	POP Q,CPTR
	POP Q,COMAX
	JRST INCMA0	;THEN SEARCH FOR THE >.

;CLEAN UP WHEN ERROR OR QUIT HAPPENS, IN CASE VARIABLES WERE SCREWED.
;THIS STUFF DONE REGARDLESS OF WHETHER ERROR WAS CAUGHT BY ERRSET.
ERESET:	SETOM INSBP
	SETZM DISFLF
	SETZM IMQUIT
	SETZM INSINP
	SETZM INSBP
	SETZM TRCOUT
	SETZM BRC1
	SETZM VIEWBF
	SETZM EXITVF
	SETZM SLPNCR
	SETZM YANKMT
	.CLOSE FDRC,	;IN CASE WE QUIT OUT OF READING FILE DIR.
	RET

;TRY TO UNWIND MACRO PDL AND ITERATIONS UNTIL REACH INNERMOST ERRSET.
;DON'T SKIP IF REACH THERE. SKIP 1 IF POP AN ORDINARY MACR (IN WHICH CASE
;UNWINDING ISN'T FINISHED). SKIP 2 AFTER POPPING A MACRO CALLED
;BY A MACXQ.
UNWIND:	HRRO A,ITRPTR	;FIND INNERMOST ERRSET OR ITERATION,
	SKIPN ITRPTR	;[ ;IF NO ITERATION, POP ANY MACRO OR ^]^X.
	 SKIPA CH,[400,,MACPDL-1]
	 MOVE CH,MFMACP-MFBLEN+1(A)
	CAMN CH,MACPDP	;[ ;ANY MACRO OR ^]^X CALLS INSIDE IT => POP THEM.
	 JRST UNWINI	;ELSE HANDLE THE ERRSET OR ITERATION.
UNWINM:	LDB CH,MACPDP	;[ ;IS IT A MACRO? OR A ^]^X?
	CAIN CH,10
	 JRST UNWIN2	;IT'S A NULL, THROW IT AWAY.
	TRNE CH,10
	 JRST UNWIN1	;[ ;IT'S A ^]^X.
	SKIPN MACPTR
	 .VALUE		;MACPDP AND MACPTR OUT OF PHASE??
	CALL DECDCH	;IT'S A MACRO CALL, RESTORE SQUOTP, ETC.
	CALL POPMAC	;POP STRING PTR, ETC.
	AOS (P)		;SKIP 1 OR 2 DEPENDING.
	SKIPGE MACPTR
	 AOS (P)
	JRST POPMP

UNWIN1:	CALL DECDCH	;[ ;POP A ^]^X.
	CALL POPCTX
	CALL PUSMAC
UNWIN2:	CALL POPMP
	JRST UNWIND

UNWINI:	SKIPN ITRPTR	;TRYING TO UNWIND WHEN NO ITERATION OR MACRO =>
	 .VALUE		;UNWIND'S CALLER'S END TEST FAILED.
	HLRZ CH,ITRPTR	;IS THIS AN ERRSET OR AN ITERATION?
	CAIN CH,(A)
	 RET		;REACHED AN ERRSET.
	CALL ITRPOP	;AN ITERATION - POP IT
	JRST UNWIND	;AND LOOK AT THE NEXT ONE OUT.

;FS ^R EXIT - WITHIN A MACRO CALLED FROM ^R, RETURN FROM THE ^R.
;FS ^R THROW - WITHIN A MACRO CALLED FROM ^R, RETURN TO ^R.
FSCREX:	SKIPA Q,[FSCRE1,,MEXIT1]
FSCRTH:	 MOVE Q,[FSCRT1,,MEXIT1]
	SKIPN DISPRR	;NOT INSIDE ^R => ERROR.
	 TYPRE [N%R]
	JRST MEXIT1

;^\ - IN A MACRO, RETURN FROM IT, POPPING QREGS AND ITERATIONS.
;:^\ DOESN'T POP QREGS.
MEXIT:	SKIPN MACPTR
	 TYPRE [NIM]	;"EXIT MACRO" IF NOT INSIDE ONE?
	MOVE Q,[CPOPJ,,CD5A]
;RH(Q) HAS WHERE TO GO AFTER POPPING A MACRO CALLED BY "M".
;LH(Q) HAS WHERE TO GO AFTER POPPING A MACXQ.
MEXIT1:	MOVE B,MACSPF	;PLACE TO POP TO.
	TRZN FF,COLONF	;POP THE QREG PDL UNLESS :^\.
	 JRST [	SAVE Q
		CALL FSQPU0
		REST Q
		JRST .+1]
	CALL UNWIND	;POP A MACRO OR ITERATION.
	 TYPRE [ERP]	;AN ERRSET IS REACHED BEFORE WE'RE THRU.
	  JRST (Q)	;POPPED AN ORDINARY MACRO.
	MOVE CH,MACXP	;POPPED A MACRO CALLED BY A MACXQ.
	POP CH,MACXP
	POP CH,MACPTR
	PUSHJ CH,SETP1	;SET P FROM CH, UNWIND STUFF, THEN POPJ P,
	HLRZ CH,Q
	JRST (CH)

FSCRE1:	SKIPA B,[RREXI0]
FSCRT1:	 MOVEI B,RRTHRW
	SUB P,[1,,1]	;COME HERE FOR FS ^REXIT POPPING MACXQ.
	CAME P,DISPRR	;IS THE INNERMOST ^R WITHIN INNERMOST MACRO?
	 JRST MEXIT1	;NO, POP THE INNERMOST MACRO AGAIN.
	JRST (B)	;YES, POP OUT OF THE ^R.

IFE ATSFLG,[
SYMLST:	JRST BEAST
]

IFN ATSFLG,[
IFN TS,[
LSPLST:	SETOB D,ATSLSP	;F@ COMMAND
	SETOM ATSLON
	TRZ FF,COLONF
	JRST .+2
SYMLPT:	SETZ D,			;@ COMMAND
	LDB A,[260100,,FF]	;LPTF
	TLZ FF,LPTF
	DPB A,[400100,,LPTSAV]
	AOSA SYMLF
]
SYMLST:	SETZB D,SYMLF	;CONTROL O
	JUMPN D,SYML0
	MOVE D,ATSLS1
	MOVEM D,ATSLSP
	MOVE D,ATSLO1
	MOVEM D,ATSLON
SYML0:	SKIPE ATSLSP
	SKIPA D,[HLRZ TT,GSTBL-40(CH)]	;FOR LISP
	MOVE D,[HRRZ TT,GSTBL-40(CH)]	;FOR MIDAS
	MOVEM D,GSGADR
	TRZ FF,LSTCRF
	TRNE FF,ARG
	JRST BEAST	;NUMERIC ARG TYPED, IF <OR=0 THEN BIGPRINT & RETURN
	SETOM SLN	;OTHERWISE SET SLN TO ARG AND RETURN TO SYML1
SYML1:	MOVE CH,QRB..
	ADDI CH,.QBASE
	CALL OPENB2	;PUSH QREG ..E (OUTPUT RADIX)
	MOVEI A,10.
	MOVEM A,(CH)	;AND SET IT TO DECIMAL.
	CALL MEMTOP	;GET ADDR OF 1ST FREE WORD AFTER BUFFER.
	ADDI A,3
	TRZ A,3		;MOVE UP TO MULTIPLE OF 4.
	MOVEM A,STPNR
	MOVEM A,STB
	CLEARM PASS
	MOVEI CH,60
	HRRM CH,DPT5	;PRINT LEADING ZEROS
	TRNE FF,COLONF	;COLON FLAG => DO PASS 2 ONLY
	JRST PASS2
	PUSHJ P,RRED
;FALLS THROUGH.

;FALLS THROUGH. START NEXT PASS (1 OR 2, ACCORDING TO CONTENTS OF "PASS").
NPASS:	MOVEM A,STM	;NO EFFECT ON PASS 1
	MOVSI T,1	;T HOLDS: <PAGE #>,,<LINE # -1>
	TRZ FF,ALTF
MNLP2:	MOVE B,[440700,,LBF]
	MOVEM B,LBFIP
	SETOM SLCHS
	CLEARM LSYL
	TRNE FF,COLONF
	JRST GSSEMI	;SUPER-FAST SCAN FOR PASS 2 ONLY LISTING
	TLZ FF,DEFF+VARF+GLOF+LPRF+NEGF+FIRSTF
MNLP:	MOVE B,[440600,,SYM]
	SETZB SYM,SYM2
	SKIPN ATSLSP
	TLZ FF,GLOF+VARF
	TRZ FF,LET
GSNOOP:	PUSHJ P,SLRCH
	CAIGE CH,40
	JRST GSCTL
	CAILE CH,137
	TRZ CH,777640	;JUST TO MAKE SURE...
	XCT GSGADR
	JRST (TT)

GSLASH:	PUSHJ P,SLRCH
	CAIGE CH,40
	JRST GSCTL
	CAILE CH,137
	TRZ CH,40
GSALF:	TRO FF,LET
GSNUM:	TLNE FF,GLOF	;<BLOCK>"<LETTER>, GO HANDLE BLOCK NAME.
	 JRST MNLP4
	TRC CH,40
	TLNN B,770000
	JRST GSNUM2
GSNUM1:	IDPB CH,B
	JRST GSNOOP

GSNUM2:	SKIPE ATSLON
	TRNN B,SYM&<17#SYM2>	;NOTE: SYM>SYM2
	JRST GSNOOP
	HRRI B,SYM2-1
	JRST GSNUM1

GSGLO:	TLOA FF,GLOF
GSVAR:	TLO FF,VARF
	TRNE FF,LET
	JRST GSNOOP
	PUSHJ P,SLRCH
	JRST MNLP

GSMCLN:	TRNE FF,LET
	SKIPE PASS
	JRST MNLP
	JRST DEFSMX

GSLCLN:	TRNE FF,LET
	SKIPE PASS
	JRST MNLP
	JRST DEFSM2

GSSEMI:	TRNE FF,LET	;SEMICOLON: DOES IT TERMINATE A SYMBOL?
	 JRST GSBRK1	;YES, HANDLE THE SYMBOL, THEN COME BACK.
GSSEM1:	PUSHJ P,SLRCH	;SUPER-FAST SCAN FOR END OF LINE.
	CAILE CH,^L	;ALSO USED FOR '"' IN LISP LISTINGS - CHEAP HACK.
	JRST GSSEM1
	CAIN CH,^J
	JRST SLLF
	CAIN CH,^L
	JRST SLFF
	JRST GSSEM1

GSCTL:	SKIPGE IFE TS,[BRKFLG] IFN TS,[STOPF]
	 JRST [	SKIPE NOQUIT
		 JRST .+1
		JRST SLEND4]
	TRNN FF,LET
	JRST MNLP1
	JRST GSBRK1

GSLPAR:	TLOA FF,LPRF
GSLQUO:	 TLO FF,FIRSTF
GSBRK:	TRNN FF,LET
	 JRST MNLP
GSBRK1:	TLNE FF,DEFF+VARF	;MUST TEST FLAGS IN THIS ORDER
	 JRST DEFSM
	TLNE FF,NEGF
	 JRST DEFCNV
	TLZE FF,GLOF
	 JRST DEFGLO
	SKIPE ATSLSP
	 JRST MNLP6	;MAYBE DO PARSING FOR LISP?
	CAME SYM,[SIXBIT \.BEGIN\]
	CAMN SYM,[SIXBIT \DEFINE\]
MNLP7:	TLOA FF,DEFF
	JRST MNLP4

LOGES6:	TLZE FF,GLOF
	 JRST [SETZB SYM,SYM2
		MOVE B,[440600,,SYM]
		TRZ FF,LET
		JRST GSNUM]
MNLP1:	CAIN CH,";
	 JRST GSSEM1
	CAILE CH,^L	;DO IT THIS WAY FOR SPEED
	JRST MNLP
	CAIE CH,13
	CAIN CH,12
	JRST SLLF
	CAIN CH,14
	JRST SLFF
	JRST MNLP

MNLP1X:	TLZ FF,DEFF+VARF+GLOF+NEGF
	JRST MNLP1

MNLP6:	TLOE FF,FIRSTF
	JRST MNLP4	;NOT FIRST SYL ON LINE - IGNORE
	TLZN FF,LPRF
	JRST LAPTAG	;NOT PRECEDED BY PAREN - MAYBE A LAP TAG?
	CAMN SYM,[SIXBIT \DEFINE\]	;CHECK OUT LISP STUFF
	JUMPE SYM2,MNLP9
	CAMN SYM,[SIXBIT \DEFUN\]
	JUMPE SYM2,MNLP7
	CAME SYM,[SIXBIT \DEFPRO\]
	JRST MNLP8
	CAME SYM2,[SIXBIT \P\]
	JRST MNLP4
	TLOA FF,GLOF
MNLP9:	TLO FF,DEFF+VARF+GLOF	;DEFINE PRETENDS TO BE (DEFUN MACRO...
	JRST MNLP1

MNLP8:	CAMN SYM,[SIXBIT \CDEFUN\]
	 JUMPE SYM2,MNLP8C
	CAMN SYM,[SIXBIT \CDEFGE\]
	CAME SYM2,[SIXBIT \N\]
	 JRST MNLP8D
	TLOA FF,NEGF+GLOF
MNLP8C:	 TLO FF,NEGF
	JRST MNLP1

MNLP8D:	JUMPN SYM2,MNLP4
	CAME SYM,[SIXBIT \ARRAY\]
	JRST MNLP8A
	TLO FF,DEFF+NEGF+GLOF
	JRST MNLP1
MNLP8A:	TRNE FF,ALTF	;ENTRY ONLY VALID IF ALREADY WITHIN LAP
	CAME SYM,[SIXBIT \ENTRY\]	;ENTRY IS JUST LIKE LAP
	CAMN SYM,[SIXBIT \LAP\]
	TDOA FF,[DEFF+NEGF,,ALTF]	;ALTF => BE IN LAP MODE
	JRST MNLP4
	JRST MNLP1

MNLP4:	SKIPN PASS
	JRST LOGES6
LOGES:	MOVEI D,0
	MOVE A,STB
	MOVE B,STPNR
	SKIPL SYM
	SKIPA B,STM	;LOOK IN LOWER HALF
	MOVE A,STM	;LOOK IN UPPER HALF
LOGES1:	MOVE C,A
	ADD C,B
	LSH C,-1
	TRZ C,3
	CAMN SYM,(C)
	JRST LOGES4	;FOUND
	CAIL A,-4(B)
	JRST LOGES6	;NOT FOUND
	CAML SYM,(C)
	SKIPA A,C	;LOOK HIGHER
	MOVE B,C	;LOOK LOWER
	JRST LOGES1

LOGES2:	MOVMS D,2(C)
	SKIPN ATSLSP	;FOR LISP/LAP, A PAREN IS OKAY
	CAIE CH,")
	MOVEM D,LSYL
	JRST LOGES6

LOGES4:	SKIPE ATSLSP	;DON'T COMPARE SYMBOLS TO 12 CHARS FOR MIDAS
	SKIPN ATSLON	; NOR WHEN IN SHORT MODE
	JRST LOGES2
LOGES5:	CAMN SYM2,1(C)
	JRST LOGES2
	CAIL A,-4(B)
	JRST LOGES6
	CAML SYM2,1(C)
	SKIPA A,C
	MOVE B,C
	JRST LOGES1


;SLRCH MUST BE CALLED ONLY FROM THE PDL LEVEL AT ENTRY TO SYMLPT.
;READ A CHARACTER FROM THE INPUT FILE INTO CH. ON PASS 2, ALSO OUTPUT IT.
;MAY JUMP TO NP1 AT EOF.
SLRCH:	PUSHJ P,UTYI
	SKIPL LASTPA
	 JRST NP1	;END PASS IF EOF.
	SKIPN PASS	;ON P1 DON'T LIST THE CHARACTER.
	 POPJ P,
	TRZE FF,LSTCRF	;IF LAST CHAR WAS CR,
	PUSHJ P,SLRCH2	;THEN MAYBE TYPE ^M
	CAIN CH,^M	;IF THIS IS A CR, SET FLAG FOR NEXT CHAR.
	JRST [TRO FF,LSTCRF ? POPJ P,]
	CAIE CH,177
	 CAIGE CH,40	;NON-CTL CHARS, JUST OUTPUT.
	  SKIPN ATSCTL	;SAME FOR CTL CHARS UNLESS ATSCTL SET.
	   JRST SLRCH4
	CAIL CH,^I	;^@ THRU ^H,
	 CAIL CH,^M	;^M THRU ^_,
	  JRST SLRCHK	;SHOULD BE OUTPUT AS UPARROW-WHATEVER.
	CAIN CH,^K
	 JRST SLRCHK	;^K, TOO.
SLRCH4:	CAIN CH,^H
	 JRST SLRCHH
SLRCH3:	EXCH CH,LBFIP
	CAMN CH,[10700,,LBF+LTABS]
	 JRST SLRCH1
	EXCH CH,LBFIP
	IDPB CH,LBFIP
	AOS SLCHS
	POPJ P,

SLRCH2:	CAIN CH,^J	;PREVIOUS CHAR WAS CR.
	 POPJ P,
	HRLM CH,(P)
	MOVEI CH,"^
	CALL SLRCH3
	MOVEI CH,"M
	CALL SLRCH3
	JRST SLRCHM

SLRCHH:	SKIPE ATSCTH
	 JRST SLRCH3
SLRCHK:	HRLM CH,(P)	;SAVE THIS CHAR,
	MOVEI CH,"^
	CALL SLRCH3	;AND OUTPUT AN ^.
	HLRZ CH,(P)
	XORI CH,100	;THEN OUTPUT THE UN-CONTROLLED CHAR.
	CALL SLRCH3
SLRCHM:	HLRZ CH,(P)	;RETURN THE REAL CHAR.
	POPJ P,

SLRCH1:	EXCH CH,LBFIP
	POPJ P,

SLFF:	SKIPN SLCHS
	TRZA FF,ARG
	PUSHJ P,SLLF4
	SKIPN PASS
	 JRST SLFF8
	MOVE CH,QRB..
	SKIPE .QCPRT(CH)	;ANY COPYRIGHT MSG?
	 CALL COPYR		;YES, PRINT IT.
	PUSHJ P,FORMF
SLFF8:	HLLOS T
	AOJA T,MNLP2

SLLF:	PUSHJ P,SLLF4
	TRO FF,ARG
	AOJA T,MNLP2

NP1:	TRZ FF,LSTCRF
	SUB P,[1,,1]
	SKIPE PASS
	JRST SYME
PASS2:	PUSHJ P,RRED
	TRZ FF,ARG
IFN TS,[
	SKIPN PASS
	SKIPN SYMLF
	JRST LPTW4	; COMMAND
LPTW2:	SKIPE ATSLPT
	 .OPEN UTYOC,['#LPT]
	 JRST LPTW1
LPTW3:	JSP T,FHAK	;INITIALIZE UTAPE BUFFER POINTERS
	JFCL
]
LPTW4:	SETOM PASS
	PUSHJ P,.FNPNT
	AOSN EXITVF	;IF CAME FROM :EX,
	 .VALUE EXITV	;START MIDAS NOW THAT TECO SLOWING DOWN.
	CLEARM SLCHS
	MOVE A,STB
	MOVE B,STPNR
	PUSHJ P,SORT
	MOVE A,STB
PASS21:	CAMGE A,STPNR	;FIND MIDDLE OF SYMBOL TABLE
	SKIPGE (A)
	JRST NPASS
	ADDI A,4
	JRST PASS21

IFN TS,[
LPTW1:	.OPEN UTYOC,[SIXBIT \  #TPL\]
	JRST LPTW1A
	JRST LPTW3
LPTW1A:	SKIPGE STOPF
	 CALL QUIT0	;TRY QUITTING IF DESIRED (CHECKS NOQUIT).
	MOVEI A,30.
	.SLEEP A,
	JRST LPTW2
]
SLLF4:	SKIPN PASS	;PRINT BUFFER
	POPJ P,
	TLZ FF,NEGF
	MOVE CH,QRB..
	SKIPN .QCPRT(CH)
	 JRST SLLF8
	MOVEI B,(T)	;PRINT THE CPYRIGHT MSG
	MOVE E,ATSPAG	;GET # TEXT LINES ON PAGE.
	SUBI E,2	;REMEMBER THAT THE COPYRIGHT MSG NEEDS 2.
	IDIV B,E
	JUMPE B,SLLF8
	JUMPN E,SLLF8
	CALL COPYR
SLLF8:	TRZE FF,ARG
	PUSHJ P,CRR1
	MOVEI B,1(T)	;LINE #
	CALL SPSP	;ONE SPACE AT FRONT OF LINE.
	CAIGE B,1000.	;MAKE SURE USE UP 4 SPACES FOR LINENO.
	 CALL SPSP
	PUSHJ P,SLDPT
SLLF1C:	HLLZS SYLCPS
	MOVE D,LSYL
	JUMPE D,SLLF1
	CALL SPSP	;THERE'S A CROSS REF FOR THS LINE.
	CALL SPSP
	HLRZ B,D
	PUSHJ P,SLDPT
	PUSHJ P,SPSP
	MOVEI B,1(D)
	PUSHJ P,SLDPT
	CAIA

;SKIPS THRU.
SLLF1:	PUSHJ P,SLTAB
	TRNN FF,COLONF
	CALL SLTAB
	SOSGE SLCHS
	JRST SLLF2
	MOVE B,[440700,,LBF]
	MOVEM B,LBFIP
SLLF1B:	ILDB CH,LBFIP
	PUSHJ P,PPA
	AOS AA,SYLCPS
	CAIE CH,11
	JRST SLLF1A
	ADDI AA,7
	TRZ AA,7
	HRRM AA,SYLCPS
SLLF1A:	SOSL SLCHS
	JRST SLLF1B
SLLF2:	HRRZ B,T	;LINE #
	MOVE CH,ATSPAG	;CH GETS # OF TEXT LINES ON PAGE.
	MOVE C,QRB..
	SKIPE .QCPRT(C)
	 SUBI CH,2	;IF THERE'S A CPYRT MSG, IT TAKES 2.
	IDIV B,CH
	JUMPN E,CPOPJ
	PUSH P,B
	MOVEI AA,69.
	XCT SYLCPS
	PUSHJ P,SPSP
	SOJG AA,.-1
	MOVE C,[SIXBIT \ PAGE \]
	PUSHJ P,TYPR
	HLRZ B,T	;PAGE #
	PUSHJ P,DPT
	POP P,B
	JUMPE B,CPOPJ
	MOVEI CH,".
	PUSHJ P,PPA
	JRST DPT

;PRINT THE COPYRIGHT MSG.
COPYR:	CALL CRR1
	CALL CRR1
	MOVE CH,QRB..
	ADDI CH,.QCPRT
	CALL QLGET	;GET LENGTH OF MSG IN AA.
	 POPJ P,
COPYR1:	SOJL AA,CPOPJ
	ILDB CH,F
	CALL @LISTF5
	JRST COPYR1

DEFSM:	SKIPE PASS
	JRST MNLP1X
	SKIPE ATSLSP
	JRST DEFSM2
DEFSMX:	PUSHJ P,ES	;LEAVES D NON-ZERO IF ALREADY DEFINED
	JUMPN D,[TLZ FF,DEFF+VARF+GLOF ? JRST MNLP4]
	MOVNM T,2(F)
	MOVSI D,(SIXBIT \ V \)
	TLNE FF,DEFF
	MOVSI D,(SIXBIT \ M \)
	TLZE FF,VARF+DEFF
	MOVEM D,3(F)
	TLZN FF,GLOF
	JRST MNLP1
DEFGLO:	SKIPE PASS
	JRST MNLP1
	SKIPE ATSLSP
	JRST DEFSM8
	PUSHJ P,ES
	MOVSI D,(SIXBIT \ G \)
	MOVEM D,3(F)
	JRST MNLP

;;; FOR LISP STUFF, THE FLAGS MEAN THE FOLLOWING (??? = CURRENT SYMBOL)
;;;	DEFF	NEGF	VARF	GLOF	SITUATION
;;;	0	0	0	0	???:
;;;	0	0	0	1	(DEFPROP ???
;;;	0	0	1	0	(DEFUN FOO ???
;;;	0	0	1	1	(DEFUN FOO EXPR ???
;;;					OR (DEFUN EXPR FOO ???
;;;	0	1	0	0	(CDEFUN ???
;;;	0	1	0	1	(CDEFGEN ???
;;;	1	0	0	0	(DEFUN ???
;;;	1	0	0	1	(DEFUN EXPR ???
;;;	1	0	1	0	(DEFUN FEXPR ???
;;;	1	0	1	1	(DEFUN MACRO ???
;;;	1	1	0	0	(LAP ???
;;;	1	1	0	1	(ARRAY ???
;;;	1	1	1	0	(LAP FOO ???

DEFSM2:	TLZN FF,DEFF
	JRST DEFSM6
	TLZE FF,NEGF
	JRST DEFLAP
	TLNE FF,VARF+GLOF
	JRST DEFSM3
	JUMPN SYM2,DEFSM5	;(DEFUN ???
	CAMN SYM,[SIXBIT \EXPR\]
	TLO FF,GLOF
	CAMN SYM,[SIXBIT \FEXPR\]
	TLO FF,VARF
	CAMN SYM,[SIXBIT \MACRO\]
	TLO FF,VARF+GLOF
	TLNN FF,VARF+GLOF	;FIND ANYTHING?
	JRST DEFSM5
	TLO FF,DEFF		;YES, LEAVE FLAGS SET FOR NEXT TIME
	JRST MNLP1

DEFSM3:	PUSHJ P,ES	;(DEFUN EXPR/FEXPR/MACRO ???
	JUMPN D,DEFSM4	;ALREADY DEFINED
	MOVNM T,2(F)
	TLCE FF,VARF
	TLNE FF,GLOF
	JRST DEFS3A
	MOVE D,[SIXBIT \ EXPR\]
	TLO FF,VARF+GLOF
	JRST DEFS3B
DEFS3A:	TLCE FF,GLOF
	MOVE D,[SIXBIT \ FEXPR\]
	TLZN FF,VARF+GLOF
	MOVE D,[SIXBIT \ MACRO\]
DEFS3B:	MOVEM D,3(F)	;PUT FLAG IN TABLE ENTRY
	JRST MNLP1

DEFSM4:	TLZ FF,VARF+GLOF
	JRST MNLP1

DEFSM5:	PUSHJ P,ES	;(DEFUN ???	(??? NOT EXPR/FEXPR/MACRO)
	JUMPN D,MNLP4		;ALREADY DEFINED
	MOVNM T,2(F)
	MOVEM F,TEM1		;SAVE TABLE POINTER FOR LATER
	TLO FF,VARF	;SET FLAG SO WE KNOW WHAT'S HAPPENING
	TLZ FF,LPRF
	JRST MNLP1

DEFSM6:	TLZN FF,VARF
	JRST DEFSM9
	TLZE FF,GLOF
	JRST DEFS6A
	MOVE F,TEM1
	MOVE D,[SIXBIT \ EXPR\]	;(DEFUN FOO ???
	TLZE FF,LPRF
	JRST DEFSM7		;IT'S REALLY (DEFUN FOO (???
	JUMPN SYM2,DEFS6B	;DEFAULT TYPE IS EXPR
	CAMN SYM,[SIXBIT \NIL\]	;(DEFUN FOO NIL		IS EXPR, NOT LEXPR
	JRST DEFSM7
	CAMN SYM,[SIXBIT \EXPR\]
	TLOA FF,VARF+GLOF	;WANT TO KNOW IF REALLY LEXPR
	MOVE D,[SIXBIT \ LEXPR\]	;ALREADY KNOW IT'S A LEXPR, MAYBE
	CAMN SYM,[SIXBIT \FEXPR\]
	MOVE D,[SIXBIT \ FEXPR\]	;UNLESS IT'S A FEXPR
	CAMN SYM,[SIXBIT \MACRO\]
	MOVE D,[SIXBIT \ MACRO\]	;OR A MACRO
DEFSM7:	MOVEM D,3(F)
	JRST MNLP1

DEFS6A:	MOVE F,TEM1	;(DEFUN FOO EXPR ??? 	(OR WHATEVER)
DEFS6B:	MOVE D,[SIXBIT \ LEXPR\]
	TLZE FF,LPRF
	MOVEM D,3(F)
	JRST MNLP1

DEFSM8:	TLZ FF,GLOF	;(DEFPROP ???
DEFSM9:	PUSHJ P,ES	;???:
	JUMPN D,MNLP1	;ALREADY DEFINED
	MOVNM T,2(F)
	JRST MNLP1

DEFLAP:	TLZN FF,GLOF
	JRST DEFLA3
	PUSHJ P,ES	;(ARRAY ???
	JUMPN D,MNLP1	;ALREADY DEFINED
	MOVNM T,2(F)
	MOVE D,[SIXBIT \ ARRAY\]
	MOVEM D,3(F)
	JRST MNLP1

DEFLA3:	TLZE FF,VARF
	JRST DEFLA5
	TRO FF,ALTF	;BE IN LAP MODE ALREADY
	PUSHJ P,ES	;(LAP ???
	JUMPN D,MNLP1	;ALREADY DEFINED
	MOVNM T,2(F)
	MOVEM F,TEM1
	TLO FF,DEFF+NEGF+VARF	;WANT TO KNOW WHAT TYPE
	JRST MNLP1

DEFLA5:	MOVE F,TEM1	;(LAP FOO ???
	MOVE D,SYM
	LSH D,-6
	MOVEM D,3(F)
	JRST MNLP1

LAPTAG:	SKIPN PASS
	TRNN FF,ALTF
	JRST MNLP1
	CAMN SYM,[SIXBIT \NIL\]
	JUMPE SYM2,LAPTA2
	PUSHJ P,ES
	JUMPN D,MNLP1
	MOVNM T,2(F)
	MOVE D,[SIXBIT \  TAG \]
	MOVEM D,3(F)
	JRST MNLP1
LAPTA2:	TRZ FF,ALTF	;LEAVE LAP TAG DETECTION MODE
	JRST MNLP1

DEFCNV:	SKIPE PASS	;COME HERE FOR (CDEFUN ?? AND (CDEFGEN ???
	 JRST MNLP1X
	CALL ES
	JUMPN D,MNLP1
	MOVNM T,2(F)
	TLZN FF,GLOF
	 SKIPA D,[SIXBIT \ CEXPR\]
	 MOVE D,[SIXBIT \ GENER\]
	JRST DEFSM7

ES:	PUSH P,T
	PUSH P,TT
	MOVE C,STPNR
	MOVEM SYM,(C)
	MOVEM SYM2,1(C)
	SKIPE ATSLSP	;DON'T COMPARE SYMBOLS TO 12 CHARS FOR MIDAS
	SKIPN ATSLON	; NOR WHEN IN SHORT MODE
	JRST AES4
	MOVE TT1,[AES6,,C]
	BLT TT1,TT1
	HRR C,STB
	JRST C

AES4:	MOVE TT,[AES2,,D]
	BLT TT,TT
	HRR D,STB
	JRST D

AES6:	CAME SYM,.	;C
	JRST TT		;D
	CAMN SYM2,1(C)	;F
	JRST AES1B	;T
	ADDI C,4	;TT
	JRST C		;TT1

AES2:	CAMN SYM,.	;D
	JRST AES1	;F
	ADDI D,4	;T
	JRST D	;TT

AES1B:	HRRZ D,C
AES1:	POP P,TT
	POP P,T
	HRRZ F,D
	CAME F,STPNR
	JRST AES1A
	CLEARB D,2(F)
	CLEARM 3(F)
	ADDI F,4
	EXCH F,STPNR
	POPJ P,
AES1A:	MOVMS D,2(F)
	POPJ P,

;;; FORMAT OF SYMBOL TABLE ENTRIES:
;;;	FIRST WORD OF SYMBOL IN SIXBIT
;;;	SECOND WORD, IF ATSLON NON-ZERO
;;;	<PAGE #>,,<LINE #>	;WHERE DEFINED (0 FOR UNDEF GLOBAL)
;;;	SIXBIT \ XXXXX\		;XXXXX IS 1 OR 5 CHARS TO PRINT
;;; SIGN BIT OF LAST WORD IS USED BELOW TO DETECT END OF TABLE.

;THIS RTN LISTS THE SYMBOL TABLE (IF DESIRED) IN @ AND ^O LISTINGS.
;COME HERE AT END OF PASS 2, FOR ALL KIND OF LISTINGS.
;EXITS BY JUMPING TO SLEND. CLOBBERS ALL ACS.

SYME:	TRNE T,-1
	PUSHJ P,FORMF	;START AT TOP OF PAGE IF NOT THERE ALREADY
SYME1:	TRNE FF,COLONF
	JRST SYMFOO
;COMPUTE # SYMS PER LINE.
	MOVE CH,ATSLIN
	ADDI CH,3	;MAKE UP FOR THE SPACES FOLLOWING EACH SYM BUT THE LAST ON EACH LINE
	MOVEI A,19.	;# POSITIONS/SYM
	SKIPE ATSLON
	 ADDI A,6	;LONG SYMS TAKE 6 POSITIONS MORE.
	SKIPE ATSLSP
	 ADDI A,4	;LISP LISTINGS TAKE 4 POSITIONS MORE (FOR FUNCTION TYPE).
	IDIV CH,A
	MOVEM CH,ATSSPL	;# SYMS/LINE
	TLZ FF,NEGF
	MOVE A,STB
	MOVE B,STPNR
	CAMN A,B
	JRST SLEND
SLPP:	MOVE B,STPNR
	SUBI B,-4(A)
	MOVE CH,ATSPAG
	LSH CH,2	;4 WDS/SYM
	IMUL CH,ATSSPL
	CAIL B,4(CH)
	 MOVEI B,(CH)
	LSH B,-2	;# SYMS FOR THIS PAGE.
	IDIV B,ATSSPL	;# SYMS SHORTEST COLUMNS THIS PAGE.
SLPP2:	MOVEI AA,(B)	;AA GETS
	HRLI AA,-1(E)	;<# LONG COLS>,,<# SYMS IN SHORT COLS>
	MOVE F,ATSPAG
	MOVEM A,SLCHS
;COME HERE TO PRINT NEXT LINE.
SLPL:	HLRE T,AA	;COUNT THE LONG COLUMNS IN T.
	MOVE D,ATSSPL	;COUNT SYMS ON THIS LINE IN D.
SLPL1:	SKIPL 3(A)
	CAML A,STPNR
	JRST SLEND
	MOVE C,(A)
	PUSHJ P,TYPR
	MOVE C,1(A)
	SKIPE ATSLON
	PUSHJ P,TYPR
	PUSHJ P,SPSP
	MOVE C,3(A)
	LSH C,6
	MOVEI IN,2
	SKIPE ATSLSP
	MOVEI IN,6
	PUSHJ P,TYPR3
	MOVSI IN,(SETZ)
	IORM IN,3(A)
	SKIPN 2(A)
	JRST SLPL2
	SKIPG 2(A)
	TRO FF,SYLF
	MOVMS C,2(A)
	HLRZ B,C
	PUSHJ P,SLDPT
	MOVEI CH,40
	TRZE FF,SYLF
	MOVEI CH,"*
	PUSHJ P,PPA
	MOVEI B,1(C)
	PUSHJ P,SLDPT
SLPL3:	SOJE D,SLPL3A
	ANDI C,-1
	CAIGE C,999.
	REPEAT 3, PUSHJ P,SPSP
	MOVEI B,(AA)	;GET # SYMS THS COL
	SOSL T
	 AOJ B,
	LSH B,2	;WHICH = # SYMS IN SYM TAB BEFORE NEXT SYM THIS LINE.
	ADD A,B
	JRST SLPL1
SLPL3A:	MOVE A,SLCHS
	ADDI A,4
	MOVEM A,SLCHS
	MOVEI CH,^M	;NORMALLY OUTPUT CRLF.
	CALL @LISTF5
	MOVEI CH,^J
	SOJG F,[CALL @LISTF5 ? JRST SLPL]
	MOVEI CH,^L
	CALL @LISTF5	;AT END OF PAGE, OUTPUT CR-FF INSTEAD.
	MOVE CH,ATSSPL
	SUBI CH,1
	LSH CH,2
	IMUL CH,ATSPAG
	ADDI A,(CH)	;ADVANCE TO 1ST SYM TO GO ON NEXT PAGE.
	JRST SLPP

SLPL2:	MOVE C,[SIXBIT \ UNDEF\]
	PUSHJ P,TYPR
	PUSHJ P,SPSP
	SETZ C,
	JRST SLPL3	;DONE LISTING SYMBOLS

SYMFOO:	MOVE B,[440700,,[ASCIZ \$*#END#*$\]]
SYMFO1:	MOVEI CH,^M
	CALL @LISTF5
	MOVEI CH,^J
	CALL @LISTF5
	ILDB CH,B
	JUMPE CH,SLEND
	MOVE A,ATSLIN
SYMFO2:	LDB CH,B
	CALL PPA
	SOJG A,SYMFO2
	JRST SYMFO1

;COME HERE AFTER LISTING SYMBOL TABLE, AT END OF @ LISTING.
;IF SEVERAL COPIES DESIRED, REINIT "REFERENCED" BITS OF SYMBOLS
;AND LOOP BACK TO REPEAT PASS 2. OTHERWISE, CLOSE FILE (ONLY @)
;AND RETURN FROM @ OR ^O COMMAND.
SLEND:	PUSHJ P,FORMF
	SKIPGE STOPF
	 JRST [	SKIPE NOQUIT
		 JRST .+1
		JRST SLEND4]
	SOSG SLN
	JRST SLEND4
	HRRZ A,STB
	MOVSI B,(SETZ)
SLEND3:	CAML A,STPNR
	JRST PASS2
	ANDCAM B,3(A)
	ADDI A,4
	JRST SLEND3

SLEND4:	MOVE CH,QRB..
	ADDI CH,.QBASE
	CALL CLOSB2	;POP QREG ..E (OUTPUT RADIX) OFF QREG PDL.
IFN TS,[
	SKIPN SYMLF
	 POPJ P,	;^O, JUST RETURN.
	XCT LPTSAV	;@, CLOSE FILE.
	JRST .FILEX
]

SORT:	MOVSI C,400000	;PART 1 OF MOBY SYMBOL SORT
SORT1:	HRLM B,(P)
	CAIL A,-4(B)
	JRST SORT7
	PUSH P,A
SORT3:	TDNN C,(A)
	JRST SORT4
	SUBI B,4
	TDNE C,(B)
	JRST SORT2
	MOVE D,(A)
	EXCH D,(B)
	MOVEM D,(A)
	MOVE D,1(A)
	EXCH D,1(B)
	MOVEM D,1(A)
	MOVE D,2(A)
	EXCH D,2(B)
	MOVEM D,2(A)
	MOVE D,3(A)
	EXCH D,3(B)
	MOVEM D,3(A)
SORT4:	ADDI A,4
SORT2:	CAME A,B
	JRST SORT3
	ROT C,-1
	POP P,A
	JUMPL C,SORT6
	PUSHJ P,SORT1
	HLRZ B,(P)
	PUSHJ P,SORT1
	JRST SORT6A
SORT6:	SKIPE ATSLON
	JRST SORT8
SORT6A:	ROT C,1
SORT7:	HLRZ A,(P)
	POPJ P,

SORTL1:	HRLM B,(P)	;DUPLICATED CODE FOR SPEED.
	CAIL A,-4(B)	;SORTS ON SECOND WORD OF SYMBOL
	JRST SORT7
	PUSH P,A
SORTL3:	TDNN C,1(A)
	JRST SORTL4
	SUBI B,4
	TDNE C,1(B)
	JRST SORTL2
	MOVE D,(A)
	EXCH D,(B)
	MOVEM D,(A)
	MOVE D,1(A)
	EXCH D,1(B)
	MOVEM D,1(A)
	MOVE D,2(A)
	EXCH D,2(B)
	MOVEM D,2(A)
	MOVE D,3(A)
	EXCH D,3(B)
	MOVEM D,3(A)
SORTL4:	ADDI A,4
SORTL2:	CAME A,B
	JRST SORTL3
	ROT C,-1
	POP P,A
	JUMPL C,SORT6A
SORT8:	PUSHJ P,SORTL1
	HLRZ B,(P)
	PUSHJ P,SORTL1
	JRST SORT6A
];END IFN ATSFLG

.FNPNT:	SYSCAL RFDATE,[1000,,UTYIC ? 2000,,PTLFCD]
	 SETOM PTLFCD
	MOVEI A,PPA
	HRRM A,LISTF5
	PUSHJ P,.+1
IFE TS,[MOVE A,LFRED1
	PUSHJ P,.FNPT2
	MOVE A,LFRED2
]
IFN TS,[MOVE A,RUTF1
	PUSHJ P,.FNPT2
	MOVE A,RUTF2
]
	PUSHJ P,.FNPT2
	JRST FORMF

.FNPT2:	PUSH P,A
	TRNN FF,ARG
	 PUSHJ P,PTLAB
.FN3:	MOVE A,(P)
	MOVEI B,4
	PUSHJ P,CRR1
	SOJN B,.-1
	MOVEI TT1,7
.FN239:	MOVEI D,3
.FN249:	SETZM AA
	ROTC A,6
	MOVEI T,3
.FN259:	XCT LDBT1-1(T)
	IMULI AA,10101
	SETZM C
	TRNE TT,2
	HRLM AA,C
	CAIG T,1
	JRST .FN269
	TRNE TT,1
	HRRM AA,C
.FN269:	PUSHJ P,[JUMPN A,TYPR
		CAIE T,1	;DON'T PRINT TRAILING SPACES.
		 JRST TYPR
		JRST SIXNTY]
	IDIVI AA,10101
	SOJN T,.FN259
	JUMPE A,.FN279
	MOVEI CH,40
	REPEAT 3,PUSHJ P,PPA
	JRST .FN249
.FN279:	MOVE A,(P)
	PUSHJ P,CRR1
	SOJN D,.FN249
	SOJN TT1,.FN239
POPAJ:	POP P,A
	POPJ P,

PTLAB:	PUSHJ P,CRR1
IFE TS,[
	MOVE C,UFPNTR
	MOVE C,177(C)
	CAMN C,[-1]
	JRST CRR1
	LSH C,18.
	PUSHJ P,TYPR
	JRST CRR1
]
IFN TS,[
	SYSCAL RFNAME,[MOVEI UTYIC ? MOVEM C ? MOVEM D ? MOVEM D ? MOVEM D]
	 .VALUE
	CALL SIXNTY	;OUTPUT DEVICE NAME
	CALL LISTF4	;AND A TAB
	CALL SIXNTY	;AND THE SNAME
	CALL LISTF4
	.SUSET [.RUNAM,,C]
	PUSHJ P,TYPR
	PUSHJ P,LISTF4
	PUSHJ P,GDATIM	;GET DATE AND TIME
	POPJ P,		;SYSTEM DOESN'T HAVE THEM, QUIT HERE
	PUSHJ P,GLPDTM	;WIN, ALSO GET CRUD FOR PHASE OF MOON
	MOVE C,TIME	;GET TIME FOR PRINTING OUT
	DPB C,[301400,,CTIME+1]
	LSH C,-14
	DPB C,[61400,,CTIME]
	LSH C,-14
	DPB C,[301400,,CTIME]
	MOVE C,CTIME
	PUSHJ P,TYPR
	MOVE C,CTIME+1
	PUSHJ P,SIXNTY
	PUSHJ P,LISTF4
	PUSHJ P,SYMDAT	;TYPE OUT DATE
	PUSHJ P,LISTF4	;TYPE ANOTHER TAB
	PUSHJ P,POM		;PUSH OUT PHASE OF MOON
	SKIPG PTLFCD
	POPJ P,
	PUSHJ P,LISTF4
	MOVEI A,[ASCIZ \CREATED \]
	PUSHJ P,ASCIND
PTLAB9:	MOVEI A,"0
	HRRM A,DPT5
	TLZ FF,NEGF
IRPS Q,R,[270400/220500/330700]
	LDB B,[Q,,PTLFCD]
	MOVEI TT,1
	PUSHJ P,DPT1
IFSE R,/,[	MOVEI CH,"/
	PUSHJ P,@LISTF5
]
TERMIN
	CALL SPSP
	HRRZ A,PTLFCD
	LSH A,-1
IRPS Q,R,[6:6:0]
	IDIVI A,12
	PUSH P,AA
IFN Q,[	IDIVI A,Q
	PUSH P,AA
	PUSH P,["R-"0]
]
.ELSE	PUSH P,A
TERMIN
	MOVEI IN,10
PTLAB3:	POP P,CH
	ADDI CH,"0
	PUSHJ P,@LISTF5
	SOJG IN,PTLAB3
	POPJ P,
]

IFN TS,[
AOFDIR:	SYSCAL OPEN,[[2,,FDRC] ? UTF ? ['.FILE.] ? [SIXBIT/(DIR)/] ? UTSNM]
	JRST OPNER1
	POPJ P,

GFDBLK:	MOVE CH,[440700,,FDRBUF]
	MOVEM CH,FDRP
	HRLI CH,-FDRBFL
	SKIPN NOQUIT
	 SKIPL STOPF	;CHECK FOR QUIT; IF SO, PLAY LIKE EOF
	 .IOT FDRC,CH
	HRLI CH,EOFCHR_<18.-7>
	HLLZM CH,(CH)
	POPJ P,
]

BEAST:
IFN ATSFLG,[
	MOVEM B,SLN
	JUMPG B,SYML1
]
	MOVEI CH,PPA
	HRRM CH,LISTF5
	PUSHJ P,FRD
	PUSH P,AA
	SETZM PTLFCD
	PUSHJ P,.FNPT2
	POP P,A
	PUSHJ P,.FNPT2
	JRST FORMF

LDBT1:	REPEAT 3,LDB TT,LDBT2-1+.RPCNT*7(TT1)

LDBT2:	REPEAT 21.,[%T1==.RPCNT/7
		%T2==.RPCNT-%T1*7
		CH5.7T(AA+200+<2*%T1+5*%T2>_12.)
		]

CH5.7T:	0	;SP
DEFINE .. A,B,C,D,E,F,G,H
	IFSN H,,[PRINTC /CH5.7T LOSE!
/]
	A_31.+B_26.+C_21.+D_16.+E_11.+F_6+G_1
TERMIN

	.. 4,4,4,4,4,0,4,,	;!
	.. 12,12,12,0,0,0,0,,	;"
	.. 12,12,37,12,37,12,12,,	;#
	.. 4,17,24,16,5,36,4,,	;$
	.. 36,31,2,4,10,23,3,,	;%
	.. 4,12,4,10,25,22,15,,	;&
	.. 4,4,4,0,0,0,0,,	;'
	.. 2,4,10,10,10,4,2,,	;(
	.. 10,4,2,2,2,4,10,,	;)
	.. 0,25,16,33,16,25,0,,	;*
	.. 0,0,4,33,4,0,0,,	;+
	.. 0,0,0,0,14,4,10,,	;,
	.. 0,0,0,16,0,0,0,,	;-
	.. 0,0,0,0,0,14,14,,	;.
	.. 0,1,2,4,10,20,0,,	;/

	.. 16,21,23,25,31,21,16,,	;0
	.. 4,14,4,4,4,4,16,,	;1
	.. 16,21,1,2,4,10,37,,	;2
	.. 16,21,1,6,1,21,16,,	;3
	.. 2,6,12,37,2,2,2,,	;4 . . . OK, BEELER?
	.. 37,20,36,1,1,21,16,,	;5
	.. 16,21,20,36,21,21,16,,	;6
	.. 37,1,2,4,10,20,20,,	;7
	.. 16,21,16,21,21,21,16,,	;8
	.. 16,21,21,17,1,21,16,,	;9
	.. 0,14,14,0,14,14,0,,	;:
	.. 0,14,14,0,14,4,10,,	; ;
	.. 0,2,4,10,4,2,0,,	;<
	.. 0,0,37,0,37,0,0,,	;=
	.. 0,10,4,2,4,10,0,,	;>
	.. 16,21,2,4,4,0,4,,	;?
	.. 16,21,27,25,27,20,17,,	;@
	.. 16,21,21,37,21,21,21,,	;A
	.. 36,21,21,36,21,21,36,,	;B
	.. 16,21,20,20,20,21,16,,	;C
	.. 36,21,21,21,21,21,36,,	;D
	.. 37,20,20,36,20,20,37,,	;E
	.. 37,20,20,36,20,20,20,,	;F
	.. 16,21,20,20,23,21,16,,	;G
	.. 21,21,21,37,21,21,21,,	;H
	.. 16,4,4,4,4,4,16,,	;I
	.. 7,1,1,1,1,21,16,,	;J
	.. 21,22,24,34,22,21,21,,	;K
	.. 20,20,20,20,20,20,37,,	;L
	.. 21,33,25,21,21,21,21,,	;M
	.. 21,21,31,25,23,21,21,,	;N
	.. 16,21,21,21,21,21,16,,	;O
	.. 36,21,21,36,20,20,20,,	;P
	.. 16,21,21,21,25,22,15,,	;Q
	.. 36,21,21,36,21,21,21,,	;R
	.. 16,21,20,16,1,21,16,,	;S
	.. 37,4,4,4,4,4,4,,	;T
	.. 21,21,21,21,21,21,16,,	;U
	.. 21,21,21,21,21,12,4,,	;V
	.. 21,21,21,21,21,25,12,,	;W
	.. 21,21,12,4,12,21,21,,	;X
	.. 21,21,12,4,4,4,4,,	;Y
	.. 37,2,4,16,4,10,37,,	;Z
	.. 6,4,4,4,4,4,6,,	;[
	.. 0,20,10,4,2,1,0,,	;\
	.. 14,4,4,4,4,4,14,,	;]
	.. 4,16,25,4,4,4,4,,	;^
	.. 0,4,10,37,10,4,0,,	;_

	IFN .-CH5.7T-64.,.. ,,,,,,,69


; EDIT DISPATCH TABLE
EDDPTB:
REPEAT 3.,	BELL	;^@ - ^B
	EDCPY	;^C COPY NEXT CHAR
	EDD	;^D DELETE NEXT CHAR
	BELL	;^E
	ED%	;^F HELP TYPE REST OF THIS LINE, CR-LF, WHAT'S BEEN DONE SO FAR
	BELL	;^G QUIT (NEVER GETS HERE)
	BELL	;^H
	EDOV	;^I TAB, TAKE AS CHAR
	EDOV	;^J LINEFEED TAKE AS CHAR
	BELL	;^K
	EDL	;^L COPY REST OF LINE W/O ECHO AND END EDIT
	EDCR	;^M CR - END EDIT
	EDN	;^N COPY THRU NEXT SPACE OR EOL
	EDO	;^O DELETE THRU NEXT SPACE
	EDP	;^P ENTER/LEAVE PUT(INSERT) MODE
	EDQ	;^Q TAKE "T" AS CHAR ("T" IS CHAR FOLLOWING ^P IN TYPIN STRING)
	EDR	;^R COPY REST OF LINE
	EDS	;^S COPY TO CHAR "T"
	EDT	;^T DELETE TO CHAR "T"
REPEAT 2,BELL	;^U - ^V
	400000,,EDW	;^W DELETE TO LAST SPACE
REPEAT 3,	BELL	;^X - ^Z
	EDALT	;^[ (ALTMODE) COPY REST WITH ECHO AND END EDIT ;]
REPEAT 4,	BELL	; ^[, ^\, ^], ^^ AND ^_

;THE ERROR TABLE: EACH WORD HAS THE 3-CHAR MESSAGE IN LH,
;POINTER TO ASCIZ STRING IN RH.
;THE TABLE IS SORTED WITH THE 3-CHAR MESSAGE AS THE KEY.
;THE FIRST ARG TO ERRDEF IS THE 3-CHAR MESSAGE. IT MUST
;CONSIST OF 3 SIXBIT CHARACTERS.
;THE SECOND ARG TO ERRDEF IS WHAT SHOULD BE GIVEN AS THE ARG
;TO THE TYPRE MACRO. IT MUST CONSIST OF 3 SQUOZE CHARS.
;IN TECO LISTINGS, CROSS-REFS GO UNDER THE NAME WHICH
;IS THE ARG TO ERRDEF. IN CREFS, THEY ARE UNDER THE LABEL ACTUALLY
;USED, WHICH HAS AN "ER$" CONCATENATED ON TO THE FRONT.
;OF TYPRE TO CHECK FOR THEM.

IF1 [
ERTOTL==0	;ON PASS 1, ERTOTL ACCUMULATES AMOUNT OF STRING SPACE NEEDED FOR MESSAGES.
		;ALSO DEFINE THE LABELS FOR THE WORDS IN THIS TABLE.
DEFINE ERRDEF A,B,C/
ER$!B	ERTOTL==ERTOTL+<5+4+.LENGTH \C\+4>/5
	BLOCK 1
TERMIN
]

IF2 [
ERNEXT==ERSTRT	;ON PASS 2, PUT THE STRINGS WHERE THEY BELONG, AND THE 3-CHAR NAMES HERE.

DEFINE ERRDEF A,B,C/
ER$!B	SIXBIT /A/ ERNEXT*5-INIQRB+1
ERTMP==.
.=ERNEXT
	.BYTE 7
	0
	QRSTR
	ERLEN==<4+4+.LENGTH \C\>
	ERLEN&177
	<ERLEN/200>&177
	0
	.BYTE
	ASCII \A	C\
ERNEXT==.
.=ERTMP
TERMIN
]

ERRTAB:	ERRDEF	[#OV]%OV:,NUMERIC OVERFLOW
	ERRDEF	[..E]..E:,BAD VALUE IN QREG ..E (OUTPUT RADIX)
	ERRDEF	[2<1]2%1:,THE SECOND ARGUMENT WAS LESS THAN THE FIRST
	ERRDEF	[AFN]AFN:,AMBIGUOUS FS FLAG NAME
	ERRDEF	[ALT]ALT:,STRAY ALTMODE WHEN FS NOOPAL$ = 0
	ERRDEF	[AOR]AOR:,ARGUMENT OUT OF RANGE
	ERRDEF	[ARG]ARG:,BAD ARGUMENT
	ERRDEF	[AVN]AVN:,AMBIGUOUS VARIABLE OR MACRO NAME.
	ERRDEF	[BEL]BEL:,A BUILT-IN ^R COMMAND CALLED FROM MACRO SIGNALED AN ERROR
	ERRDEF	[CMD]CMD:,A CHAR THAT ISN'T A TECO COMMAND WAS EXECUTED
	ERRDEF	[DCD]DCD:,A DISABLED COMMAND WAS EXECUTED
	ERRDEF	[DSI]DSI:,DAMNED SCREW INFINITELY
	ERRDEF	[ERP]ERP:,EXITING MACRO CONTAINING UNTERMINATED ERRSET
;[
	ERRDEF	[ICB]ICB:,ILLEGAL ^] COMMAND
	ERRDEF	[IEC]IEC:,ILLEGAL "E" COMMAND
	ERRDEF	[IFC]IFC:,ILLEGAL "F" COMMAND
	ERRDEF	[IFN]IFN:,ILLEGAL FS FLAG NAME
	ERRDEF	[IQN]IQN:,INVALID Q-REGISTER NAME
	ERRDEF	[ISK]ISK:,INVALID SORT KEY - "^P" COMMAND
	ERRDEF	[KCB]KCB:,KILL CURRENTLY SELECTED BUFFER
	ERRDEF	[M^R]M%R:,ATTEMPTED TO MACRO A MEANINGLESS NUMBER
	ERRDEF	[NDO]NDO:,NO DEVICE OPEN FOR OUTPUT - TRY "EW"
	ERRDEF	[NFC]NFC:,NO FREE CHANNELS TO POP INTO
	ERRDEF	[NFI]NFI:,NO FILE OPEN FOR INPUT - TRY DOING "ER"
	ERRDEF	[NHP]NHP:,NONEXISTENT HORIZONTAL POSITION
	ERRDEF	[NIB]NIB:,YOU HAVE ADDRESSED A CHARACTER NOT IN THE BUFFER
	ERRDEF	[NIM]NIM:,NOT IN MACRO
	ERRDEF	[NOP]NOP:,SPECIFIED TYPE OF IO CHANNEL HASN'T BEEN PUSHED
	ERRDEF	[NRA]NRA:,FILE NOT RANDOM ACCESS
	ERRDEF	[N^R]N%R:,FS ^R EXIT$ - NOT IN ^R
	ERRDEF	[PCE]PCE:,PUSHDOWN CAPACITY EXCEEDED
	ERRDEF	[PTM]PTM:,COMMAND-READING POPPED OUT OF MACRO INTO TECO'S MIDAS CODE
	ERRDEF	[PUR]PUR:,ATTEMPTED WRITE IN PURE PAGE
	ERRDEF	[QIT]QIT:,^G TYPED ON TTY AND FS NOQUIT$ WAS NEGATIVE
	ERRDEF	[QNB]QNB:,Q-REGISTER NOT BUFFER
	ERRDEF	[QNN]QNN:,Q-REGISTER NOT NUMERIC
	ERRDEF	[QNS]QNS:,Q-REGISTER NOT STRING
	ERRDEF	[QRF]QRF:,Q-REGS FAILED, PROBABLY TECO BUG
	ERRDEF	[QRP]QRP:,Q-REGISTER PDL OVERFLOW OR UNDERFLOW
	ERRDEF	[SFL]SFL:,SEARCH FAILED
	ERRDEF	[SNI]SNI:,SEMICOLON NOT IN ITERATION
	ERRDEF	[SNR]SNR:,THERE IS NO VALID SEARCH STRING TO REPEAT
	ERRDEF	[STL]STL:,STRING ARGUMENT TOO LONG
	ERRDEF	[STS]STS:,DISPATCH STRING TOO SHORT
;[[[
	ERRDEF	[TMN]TMN:,TOO MANY MACRO, ^]Q-REGISTER, ^]^X, OR ^]^Y NESTINGS
	ERRDEF	[TMR]TMR:,MORE SORT RECORDS THAN CHARS IN BUFFER
	ERRDEF	[UBP]UBP:,UNBALANCED PARENTHESES FOUND WITH AN FL-TYPE COMMAND
	ERRDEF	[UCT]UCT:,UNSEEN CATCH TAG
	ERRDEF	[UEB]UEB:,BUFFER ENDED UNEXPECTEDLY DURING AN FL-TYPE COMMAND
	ERRDEF	[UEC]UEC:,UNEXPECTED END OF COMMAND
	ERRDEF	[UGT]UGT:,UNSEEN GO-TAG
	ERRDEF	[UMC]UMC:,UNMATCHED ")" OR ">" AS A COMMAND
	ERRDEF	[UNA]UNA:,UTAPE NOT ASSIGNED
	ERRDEF	[UNF]UNF:,UTAPE NOT FLAPPABLE
	ERRDEF	[URK]URK:,TECO GRABBING INFINITE CORE
	ERRDEF	[UTC]UTC:,UNTERMINATED CONDITIONAL
	ERRDEF	[UTI]UTI:,UNTERMINATED ITERATION OR ERRSET (MISSING ">"?)
	ERRDEF	[UTL]UTL:,UTAPE NAMEING FAILED (ES COMMAND)
	ERRDEF	[UVN]UVN:,UNDEFINED VARIABLE OR MACRO NAME
	ERRDEF	[W"A]W%A:,WRONG ARG TO " -- SHOULD BE G,L,N,E,B OR C
	ERRDEF	[WLO]WLO:,FS OFACCP$ WHEN OLD ACCESS POINTER WASN'T MULTIPLE OF 5
	ERRDEF	[WNA]WNA:,WRONG NUMBER OF ARGUMENTS

LERTAB==.-ERRTAB

IF2 IFN ERNEXT-EREND,.ERR LOSSAGE IN ERRTAB.
;	E COMMANDS DISPATCH TABLES

ETAB:	JRST EQMRK		;?
	TYPRE [IEC]		;@
	JRST EASSIGN		;A
	TYPRE [IEC]		;B
	JRST UICLS		;C
	JRST DELE		;D
	JRST EXITE		;E
	JRST .FILE		;F
	JRST EGET		;G
	TYPRE [IEC]		;H
	JRST EICMD		;I
	JRST EJCMD		;J
	JRST TAPKIL		;K
	JRST CNTRU1		;L
	JRST LISTFM		;M
	JRST RENAM		;N
	JRST ADMPC		;O
	JRST BPNTRD		;P
	JRST ALINK		;Q
	JRST .OPNRD		;R
	JRST MTNAM		;S
	JRST FFRRDD		;T
IFN TS,[JRST EDESINE		;U
	TYPRE [IEC]		;V
	JRST WWINIT		;W
	JRST EXITX		;X
	JRST LISTF		;Y
	JRST LISTFM		;Z
	JRST PSHIC		;[
	JRST PSHOC		;\
	JRST POPIC		;]
	JRST POPOC		;^
	JRST FCOPY		;_
]
LETAB==.-ETAB

IFN ATSFLG,[
;	@-LISTING CHAR DISPATCH TABLE
;		LEFT HALF OF EACH ENTRY FOR LISP
;		RIGHT HALF OF EACH ENTRY FOR MIDAS

GSTBL:	GSBRK,,GSBRK	;SPACE
	GSALF,,GSNOOP	;!
	GSSEMI,,GSGLO	;"
	GSALF,,GSBRK	;#
	GSALF,,GSALF	;$
	GSALF,,GSALF	;%
	GSALF,,GSBRK	;&
	GSLQUO,,GSVAR	;'
	GSLPAR,,GSBRK	;(
	GSBRK,,GSBRK	;)
	GSALF,,GSBRK	;*
	GSNUM,,GSBRK	;+
	GSBRK,,GSBRK	;,
	GSNUM,,GSBRK	;-
	GSBRK,,GSALF	;.
	GSLASH,,GSBRK	;/
REPEAT 12, GSNUM,,GSNUM	;0-9
	GSLCLN,,GSMCLN	;:
	GSSEMI,,GSSEMI	;;
	GSALF,,GSBRK	;<
	GSALF,,GSMCLN	;=
	GSALF,,GSBRK	;>
	GSALF,,GSBRK	;?
	GSALF,,GSNOOP	;@
REPEAT 32, GSALF,,GSALF	;A-Z
	GSALF,,GSBRK	;[
	GSALF,,GSBRK	;\
	GSALF,,GSBRK	;]
	GSNUM,,GSBRK	;^
	GSNUM,,GSBRK	;_

IFN .-GSTBL-100,.ERR WRONG TABLE LENGTH
];END IFN ATSFLG

;MUST BE SORTED BY FLAG NAME

DEFINE FLG A,B,C
	.1STWD SIXBIT/A/
IFB C,[FSNORM,,]IFNB C,[C,,]B+IFB B,A
TERMIN

FLAGS:
IFN ATSFLG,[
	FLG @CONTR,ATSCTL	;NONZERO => CONVERT CTL CHARS TO UPARROW-CHR IN @ (BUT FOR ^H, SEE @^HLIST).
	FLG @LINEL,ATSLIN	;LINE LENGTH FOR @ LISTINGS.
	FLG @LISP,ATSLS1	;TELL @ TO DO LISP FILES
	FLG @LONG,ATSLO1	;TELL @ TO USE 12-CHAR SYMBOLS
	FLG @LPT,ATSLPT		;NONZERO => OK FOR @ TO TRY LPT:
	FLG @PAGEL,ATSPAG	;# LINES/PAGE FOR @ (DEFAULT 60.)
	FLG @^HLIS,ATSCTH	;NOT 0 => ^H LISTS AS BS IN @ LISTINGS.
]
	FLG ADLINE,		;SIZE OF LINE ADJUST FILLS (FA)
	FLG ALTCOU,TSALTC,FSALTC ;# CMD STRINGS WAITING TO BE READ.
	FLG BACKTR,0,FSBAKT	;TRACES BACK THE MACRO PDL.
	FLG BBIND,0,FSBBIND	;PUSH OR POP CURRENT BUFFER CONVENIENTLY.
	FLG BCONS,0,FSBCON	;RETURN A NEW BUFFER.
	FLG BCREAT,0,FSCRBF	;CREATE NEW BUFFER (AND SELECT IT).
	FLG BKILL,0,FSKILB	;ARG = VALUE OF QREG HOLDING BUFFER TO KILL.
	FLG BOTHCA,		;NONZERO => SEARCHES IGNORE CASE DISTINCTIONS.
	FLG BOUNDA,0,FSBOUN	;BOUNDARIES OF PART OF BUFFER BEING EDITED.
	FLG CASE,CASNRM		;SET CASE-SHIFTING MODE.
	FLG CASENO,CASE		;SET CURRENT CASE-LOCK STATE.
	FLG CTLMTA,RRCMQT	;NEGATIVE => CONTROL-META-LETTER SSELF INSERTING.
	FLG DATASW,0,FSSWIT	;PDP10 CONSOLE SWITCHES.
	FLG DATE,0,FSDATE	;RETURN CURRENT DATE IN DISK FORMAT.
	FLG DDEVICE,UTF		;DEFAULT DEVICE AND FILENAMES.
	FLG DFILE,0,FSDFILE	;DEFAULT FILE'S NAMES, AS STRING.
	FLG DFN1,UTF1
	FLG DFN2,UTF2
	FLG DSNAME,UTSNM
	FLG ECHODI,0,FSECDS	;(WRITE-ONLY) ECHO-MODE DISPLAY-MODE OUTPUT OF ARG.
	FLG ECHOLI,0,FSECLS	;# OF COMMAND LINES.
	FLG ECHOOU,0,FSECOT	;(WRITE-ONLY) ECHO-MODE OUTPUT OF ARGUMENT.
	FLG ERR,LASTER,FSERR	;SIGNAL AN ARBITRARY ERROR.
	FLG ERRFLG,ERRFL1	;WHEN ..B OR ..G MACROED, THIS
				;HAS 0 OR ERROR CODE OF CMD STRING JUST ENDED.
	FLG ERROR,LASTER,	;ERROR CODE OF MOST RECENT ERROR.
	FLG EXIT,0,FSEXIT	;DO .BREAK 16, TO INTERUPT SUPERIOR.
	FLG FDCONV,0,FSDCNV	;CONVERT NUMERIC TO ASCII FILE DATES.
	FLG FILEPA,		;CHAR TO PAD LAST WD OF OUTPUT FILE WITH.
	FLG FLUSHED,MORFLF	;0 => NOT AFTER --FLUSHED, 1 => RUBOUT, -1 => OTHER FLUSHAGE.
	FLG FNAMSY,		;0 => IF ONLY ONE FILENAME, IT IS FN2.
				;> 0 => ONLY ONE FILENAME IS FN1.
				;< 0 => ONLY ONE FNAME IS FN1, AND FN2 IS ">".
	FLG GAPLEN,EXTRAC,FSRNLY ;SIZE OF GAP.
	FLG GAPLOC,GPT,FSROCA	;CHAR ADDR OF GAP.
	FLG HEIGHT,NVLNS,FSRNLY	;NUMBER OF LINES TO DISPLAY
	FLG HPOSIT,0,FSHPOS	;PHYSICAL POSITION OF A 2741 TYPEBALL IF IT TYPED FROM THE PREVOUS CARRET
	FLG I.BASE,		;INPUT RADIX FOR #S FOLLOWED BY ".".
	FLG IBASE,		;ORDINARY INPUT RADIX.
	FLG IFACCE,0,FSIFAC	;(WRITE-ONLY) SET INPUT FILE ACCESS PTR
	FLG IFCDAT,UTYIC,FSFDAT	;NUMERIC CREATION DATE OF INPUT FILE.
	FLG IFLENG,0,FSIFLEN	;(R-O) LENGTH OF INPUT FILE.
	FLG IMAGEO,0,FSIMAG	;(WRITE-ONLY) IMAGE MODE OUTPUT OF ARG
	FLG INSLEN,INSLEN	;LENGTH OF THE LAST INSERT STRING
	FLG JNAME,.RJNAM,FSRSYS	;GET TECO'S JNAME.
	FLG LASTPA,,FSRNLY	;SET BY TECO TO 0 AFTER READING LAST PAGE OF IPUT FILE.
	FLG LINES,NLINES	;NUMBER OF LINES TO DISPLAY
	FLG LISPT,INITFL	;NONZERO => TECO WAS STARTED AT ALTERNATE ENTRY
				;POINT SIGNIFYING THAT SUPERIOR IS A LISP.
	FLG LISTEN,0,FSLISN	;DO .LISTEN, MAYBE PROMPT VIA FS ECHOT.
	FLG MACHIN,0,FSMACH	;READ MACHINE NAME
	FLG MSNAME		;READ WORKING DIRECTORY NAME
	FLG NLAROW,		;<>0=> DON'T ALLOW _ COMMAND
	FLG NOOPAL,		;SAY WHAT TO TO WITH ALTMODES AS COMMANDS.
				;0 => ERROR, -1 => IGNORE, 1 => LIKE ^_.
	FLG NOQUIT,		;0 => ^G QUITS NORMALLY.
				;POS => ^G JUST SETS STOPF; NO QUITTING.
				;NEG => ^G CAUSES ERRSETABLE "QIT" ERROR.
	FLG OFACCE,0,FSOFAC	;(WRITE-ONLY) SET OUTPUT FILE ACCESS POINTER
	FLG OFCDAT,UTYOC,FSFDAT	;DATE OF OUTPUT FILE (NUMERIC)
	FLG OFLENG,0,FSOFLEN	;LENGTH OF OUTPUT FILE.
	FLG OUTPUT,OUTFLG	;-1 => OUTPUT TO FILE DISABLED.
	FLG PAGENU,		;PAGE # IN CURRENT INPUT FILE.
	FLG PROMPT,PROMCH	;0, OR ASCII VALUE OF PROMPT CHAR.
	FLG PUSHPT,0,FSPSPT	;DO <ARG>^V
	FLG QPPTR,0,FSQPPT	;QREG PDL PTR
	FLG QPSLOT,0,FSQPSL	;QREG PDL SLOT (ARG SAYS WHICH ONE)
	FLG QPUNWI,0,FSQPUN	;UNWIND QREG PDL.
	FLG QUIT,STOPF		;NEGATIVE => A ^G-QUIT HAS BEEN REQUESTED.
	FLG QVECTO,0,FSQVEC	;RETURN A NEW QREG VECTOR BUFFER.
	FLG RANDOM,RDMNMS	;RANDOM # GENERATOR'S SEED.
	FLG REALAD,BEG,FSRNLY	;PHYS CHAR ADDR OF BEGINNING OF BUFFER.
	FLG REFRES,REFRSH	;MACRO TO REDISPLAY WHOLE SCREEN.
	FLG REREAD,UNRCHC	;-1, OR TTY CHARACTER TO RE-READ.
	FLG RGETTY,,FSRNLY	;NON-0=> DISPLAY TERMINAL
	FLG RUBCRL		;NON-0 => RUBOUT AND ^D DELETE A WHOLE CRLF AT ONCE.
IFN TS,	FLG RUNTIM,0,FSRUNT	;NUMBER OF MICROSECONDS OF CPU TIME USED
	FLG SAIL,DISSAI		;NON0 => TTY ASSUMED TO PRINT SAIL CHAR SET.
	FLG SEARCH,SFINDF	;VALUE RETURNED BY THE LAST SEARCH
	FLG SERROR,SRCERR	;NONZERO => FAILING SERACHES ARE ERRORS EVEN IN ITERATIONS.
	FLG SSTRING,0,FSSSTR	;CURRENT SEARCH STRING, AS A STRING.
	FLG STEP,STEPFL		;NONZERO => SINGLE STEP MACROS, LINE AT A TIME.
	FLG SUPERI,SUPHND	;MACRO TO HANDLE REQUESTS FROM SUPERIOR.
	FLG SVALUE,SFINDF	;VALUE RETURNED BY LAST SEARCH.
	FLG TOPLIN		;1ST LINE TO USE FOR BUFFER DISPLAY.
	FLG TRACE,TRACEF,FSRBIT	;(READ-ONLY) -1 IFF IN TRACE MODE.
	FLG TRUNCA,DISTRN	;CONTROLS TRUNCATION VS. CONTINUATION OF TYPED LINES.
				;NEGATIVE => TRUNCATE, ELSE CONTINUE.
	FLG TTMODE,TTMODE
	FLG TTYINI,0,FSTTYI	;RE-INIT THE VARS RELATING TO TYPE OF TTY.
	FLG TTYOPT,,FSRNLY	;TTY'S TTYOPT VARIABLE.
	FLG TYOHPO,CHCTVP,FSRNLY ;HPOS OF TYPEOUT, AT THE MOMENT.
	FLG TYPEOU,TYOFLG	;-1 => NEXT TYPEOUT GOES AT SCREEN TOP.
				;ELSE TYPEOUT HAS BEEN DONE AND MORE TYPEOUT FOLLOWS IT.
	FLG UNAME,.RUNAME,FSRSYS ;GET TECO'S UNAME.
	FLG UPTIME,0,FSUPTI	;SYSTEM UP TIME IN 60'TH'S.
	FLG UREAD,,FSBIT	;-1 IF INPUT FILE, ELSE 0.
	FLG UWRITE,,FSBIT	;-1 IFF OUTPUT FILE OPEN, ELSE 0.
	FLG VB,0,FSVB		;BEGV, BUT CAN BE PUSHED/POPPED.
	FLG VERBOS,VERBOS	;<>0=> DISPLAY MOBY ERROR MESSAGES
	FLG VERSIO,$%.,FSVAL	;VERSION NUMBER OF THIS TECO
	FLG VZ,0,FSVZ		;Z-ZV, BUT CAN BE PUSHED/POPPED.
	FLG WIDTH,NHLNS		;SIZE OF THE TYPED\DISPLAYED LINE
	FLG WINDOW,GEA		;CHAR ADDR (REL BEGV) OF 1ST CHAR IN WINDOW
	FLG WORD,0,FSWORD	;GET OR SET SOME WORD IN THE CURRNET BUFFER.
	FLG XJNAME,.RXJNA,FSRSYS ;INSERT .XJNAME IN BUFFER
	FLG XPROMP,RUBENC	;0, OR CHAR TO TYPE NEXT TIME DISINI DONE.
	FLG XUNAME,.RXUNA,FSRSYS ;INSERT .XUNAME IN BUFFER
	FLG YDISAB,		;DISABLES Y COMMAND IN VARIOUS WAYS
	FLG Z,Z,FSROCA		;# CHARS IN BUFFER (Z COMMAND IS 1 + # OF LAST CHAR IN RANGE BEING EDITED.)
	FLG ^HPRIN,DISPBS	;PRINT BS AS BS?  NEGATIVE => YES.
	FLG ^IDISA,TABMOD	;0 => TABS INSERT  1 => ERROR  -1 => IGNORE.
	FLG ^LINSE,FFMODE	;NON0 => ^L'S READ FROM FILE GO IN BUFFER.
	FLG ^MPRIN,DISPCR	;STRAY CR CAN COME OUT AS CR?  NEGATIVE => YES.
	FLG ^PCASE,PSCASE	;NONZERO => ^P SORT IGNORES CASE.
IFN RMSSW,[
	FLG ^RARG,RRRPCT	;BASIC ^R-MODE ARGUMENT (SET BY ^V)
	FLG ^RARGP,RRARGP	;0 => USE 1 INSTEAD OF FS ^RARG$.
	FLG ^RCCOL,RRCCOL	;COMMENT COLUMN FOR ^R MODE.
	FLG ^RCMAC,0,FSCRMA	;MACROS ASSOCIATED WITH CHARS.
	FLG ^RDISP,RRDISM	;MACRO TO RUN WHEN ABOUT TO DO NONTRIVIAL REDISPLAY.
	FLG ^RECHO,RRECHO	;CONTROLS ECHOING OF CHARACTERS READ IN BY ^R.
	FLG ^RENTER,RRENTM	;MACROED WHEN ^R IS ENTERED.
	FLG ^REXIT,0,FSCREX	;EXIT FROM ^R WHEN EXECUTED.
	FLG ^REXPT,RR4TCT	;EXPONENT-OF-4, INCREMENTED BY ^U.
	FLG ^RHPOS,RRHPOS	;HPOS OF CURSOR IN ^R MODE.
	FLG ^RINIT,0,FSCRIN	;INITIAL VALUE OF FS ^R CMACRO$
	FLG ^RINSE,0,FSRRINS	;INTERNAL ^R 1-CHAR INSERT ROUTINE.
	FLG ^RLAST,RRLAST	;MOST RECENT ^R-MODE CHAR (EXCEPT ARG-SETTING CHARS)
	FLG ^RLEAVE,RRLEVM	;MACROED WHEN ^R EXITS (BUT NOT IF ERR'D OR THROWN THRU)
	FLG ^RMARK,RRMKPT	;THE ^R-MODE MARK, SET BY ^T. -1 => NO MARK NOW.
	FLG ^RMCNT,RRMCC1	;THE COUNTER USED TO TELL WHEN TO CALL SEC'Y MACRO.
				;INITTED FROM FS ^RMDLY, COUNTED DOWN TO 0.
	FLG ^RMDLY,RRMCCT	;# OF ^R CMDS TO DO BETWEEN INVOCATIONS OF SEC'Y MACRO.
]
	FLG ^RMODE,DISPRR,FSRNLY ;NONZERO IN ^R MODE.
IFN RMSSW,[
	FLG ^RMORE,RRMORF	;NONZERO INHIBITS --MORE-- IN ^R MODE.
	FLG ^RNORM,RRXINV	;THIS IS THE REAL DEFINITION OF ANY ^R-MD CHAR
				;DEFINED TO BE "SELF-INSERTING". INITIALLY
				;IS AN INTERNAL ENTRY TO FS ^RINS$.
	FLG ^RPREV,RRPRVC	;THE ^R-MODE COMMAND CHAR BEFORE THE ONE IN ^R LAST.
	FLG ^RREPL,RRRPLC	;CONTROLS INSERTION VS REPLACEMENT BY NORMAL CHARS.
	FLG ^RRUBO,0,FSRRRUB	;INTERNAL ^R RUBOUT ROUTINE.
	FLG ^RSCAN,RRSCAN	;NONZERO => ^R ON PRINTING TTY PRINTS CHARS MOVED OVER.
	FLG ^RSUPP,RRALQT	;NONZERO SUPPRESSES BUILTIN COMMANDS
	FLG ^RTHRO,0,FSCRTH	;THROW TO INNERMOST ^R INVOCATION.
	FLG ^RUNSU,RRUNQT
	FLG ^RVPOS,RRVPOS	;VPOS OF CURSOR IN ^R MODE.
]
	FLG _DISAB,NLAROW
	FLG %BOTTO,		;PERCENT AT BOTTOM BARRED TO CURSOR.
	FLG %CENTE,		;PERCENT FROM TOP TO PREFERRED LOCATION FOR CURSOR (WHEN WINDOW CHOSEN)
	FLG %END,		;PERCENT AT BOTTOM BARRED TO CURSOR WHEN WINDOW CHOSEN.
	FLG %TOFCI,,FSTTOL	;VALUE OF TTY'S %TOFCI BIT.
	FLG %TOHDX,,FSTTOL	;VALUE OF TTY'S %TOHDX BIT.
	FLG %TOLWR,,FSTTOL	;VALUE OF TTY'S %TOLWR BIT.
	FLG %TOMOR,,FSTTOL	;VALUE OF TTY'S %TOMOR BIT.
	FLG %TOOVR,,FSTTOL	;VALUE OF TTY'S %TOOVR BIT.
	FLG %TOP,		;PERCENT OF SCREEN AT TOP BARRED TO CURSOR.
	FLG %TOROL,,FSTTOL	;VALUE OF TTY'S %TOROL BIT.
	FLG %TOSAI,,FSTTOL	;VALUE OF TTY'S %TOSAI BIT.
	FLG *RSET,UNWINF	;NONZERO PREVENTS AUTOMATIC QRP UNWINDING.
	FLG .CLRMO,CLRMOD	;NONZERO => CLEAR SCREEN WHEN TTY GIVEN BACK BY SUPERIOR.
	FLG .KILMO,KILMOD	;(NORMALLY NON-0) 0 MAKES FSBKILL$ A NOOP.
	FLG :EJPAG,LHIPAG	;# OF LOWEST PAGE IN USE BY PURE STRING SPACE
FLAGSL==<.-FLAGS>/2

FLAGD==FLAGS+1

	<-1>_-1		;THIS TERMINATES THE AMBIGUITY TEST AT FSFND.
	BLOCK 4		;FOR PATCHING (HARD BUT POSSIBLE)
IFCERR==TYPRE [IFC]

FDTB:	JRST FCTLAT	;^@
	JRST FCACMD	;^A
	JRST FMEMQ	;^B
TYPIFC:	IFCERR		;^C
	IFCERR		;^D
	JRST FCECMD	;^E
	REPEAT 22,IFCERR	;^F-^W
	JRST FCTLX	;^X
	JRST FCTLY	;^Y
	REPEAT 10,IFCERR	;^Z - !
	JRST FDQUOT	;"
	IFCERR		;#
	JRST FSCASE	;$
	REPEAT 3,IFCERR	;%-'
	JRST FOPEN	;(
	JRST FCLOSE	;)
	JRST FNOOP	;*
	JRST CTLL	;+
	REPEAT "6-"+-1,IFCERR
	JRST FSIXB	;6
	REPEAT ";-"6-1,IFCERR
	JRST FSEMIC	;;
	JRST FLSSTH	;<
	JRST FEQ	;=
	IFCERR		;>
	JRST FLSCMD	;?
IFE ATSFLG,IFCERR	;@
.ELSE	JRST LSPLST	;@
	JRST ADJUST	;A
	JRST FBCMD	;B
	JRST LOWCON	;C
	JRST FDCMD	;D
	JRST FECMD	;E
	IFCERR		;F
	JRST FGCMD	;G
	IFCERR		;H
	JRST FTYI	;I
	JRST FJCL	;J
	JRST FKCMD	;K
	JRST FLCMD	;L
IFE RMSSW,IFCERR	;M
.ELSE	JRST FMCMD	;M
	JRST FNCMD	;N
	JRST FOCMD	;O
	JRST FDATTY	;P
	JRST QLEN	;Q
	JRST DISMDI	;R
	JRST FSET	;S
	JRST FTYPE	;T
	JRST FUCMD	;U
	JRST FVIEW	;V
	JRST FWCMD	;W
	JRST FXCMD	;X
	JRST FYCMD	;Y
	IFCERR		;Z
	JRST FPUSH	;[
	IFCERR		;\
	JRST FPOP	;]
	JRST FAPPRX	;^
	JRST SERCHA	;_, LIKE NORMAL _ CMD.
IFN .-FDTB-140,[PRINTX \FDTB LOSS
\]


DTB:	HRROI AA,CNTRAT	;^@
	MOVEI AA,COR	;^A
	TYPRE [CMD]	;^B
	TYPRE [CMD]	;^C
	TYPRE [CMD]	;^D
	TYPRE [CMD]	;^E
	HRROI AA,CNTRLF	;^F
	TYPRE [CMD]	;^G - TS QUIT
	TYPRE [CMD]	;^H - BACKSPACE
	JRST TAB	;^I - TAB
	MOVEI AA,CD	;^J - LINE FEED
	HRROI AA,DECDMP	;^K - VALRET SOMETHING
	HRROI AA,CTLL	;^L - FORM FEED
	MOVEI AA,CTLM	;^M - CARR RET
	HRROI AA,CNTRLN	;^N
	HRROI AA,SYMLST	;^O
	HRROI AA,PSORT	;^P
	TYPRE [CMD]	;^Q
IFE RMSSW,TYPRE [CMD]	;^R
IFN RMSSW,HRROI AA,RRENTR	;^R
	HRROI AA,ASLEEP	;^S
	HRROI AA,EDIT	;^T - EDIT
	HRROI AA,CNTRLU	;^U
	HRROI AA,CTLV	;^V
	JRST CTLW	;^W
	MOVE A,MARG1	;^X
	MOVE A,MARG2	;^Y
	HRROI AA,RANDOM	;^Z
	JRST ALTCMD	;ALTMODE IN TIME SHARING, MAYBE TRY TO LOG OUT
	MOVEI AA,MEXIT	;^\
	TYPRE [CMD]	;[ ;^]
	HRROI AA,CNTRUP	;^^
	JRST LGOGO	;^_

	MOVEI AA,CD2A	;
	MOVEI AA,EXCLAM	;!
	MOVEI AA,DQUOTE	;"
	MOVEI AA,CXOR	;#
	HRROI AA,NEWAS	;$
	HRROI AA,PCNT	;%
	MOVEI AA,CAND	;&
	JRST CD5A	;'
	MOVEI AA,OPEN	;(
	MOVEI AA,CLOSE	;)
	MOVEI AA,TIMES	;*
	MOVEI AA,PLUS	;+
	MOVEI AA,COMMA	;,
	MOVEI AA,MINUS	;-
	JRST PNT	;.
	MOVEI AA,SLASH	;/
REPEAT 12,JRST CDNUM	;DIGITS 0 - 9.
	JRST ACOLON	;:
	MOVEI AA,SEMICL	; ;
	MOVEI AA,LSSTH	;<
	HRROI AA,PRNT	;=
	JRST GRTH	;>
	HRROI AA,QUESTN	;?
IFE ATSFLG,JRST ASLSL	;@
.ELSE	HRROI AA,SYMLPT	;@
	HRROI AA,APPEND	;A
	HRROI AA,BCMD	;B
	HRROI AA,CHARAC	;C
	HRROI AA,DELETE	;D
	HRROI AA,ECMD	;E
	HRROI AA,FCMD	;F
	HRROI AA,QGET	;G
	HRROI AA,HOLE	;H
	HRROI AA,INSERT	;I
	HRROI AA,JMP	;J
	HRROI AA,KILL	;K
	HRROI AA,LINE	;L
	MOVEI AA,MAC	;M
	HRROI AA,SERCHP	;N
	MOVEI AA,OG	;O
	HRROI AA,PUNCH	;P
	HRROI AA,QREG	;Q
	HRROI AA,REVERS	;R
	HRROI AA,SERCH	;S
	HRROI AA,TYPE	;T
	HRROI AA,USE	;U
	HRROI AA,VIEW	;V
	MOVEI AA,CD	;W
	HRROI AA,X	;X
	HRROI AA,YANK	;Y
	HRROI AA,END1	;Z
	HRROI AA,OPENB	;[
	HRROI AA,BAKSL	;\
	HRROI AA,CLOSEB	;]
	JRST ASLSL	;^
	JRST BAKARR	;_
IFN .-DTB-140,.ERR DTB WRONG # ENTRIES.
CONSTANTS

PAT:
PATCH":	BLOCK 200
PATCHE":	0

HUSED:	INFORM [TOP OF PURE]\.-1

LOC <.+1777>&776000
VARIABLES
IFN .&1777, .ERR VARIABLES!

HIMPUR::

;IF ^R VARIABLES DON'T FIT IN LOW IMPURE, PUT THEM HERE.
IFN RMSSW,IFG <RRVARX&1777>+RRVARL-1777, RRVARB:: BLOCK RRVARL

;^R-MODE COMMAND DISPATCH TABLE. POSITIVE => BUILTIN COMMAND;
;RH IS DISP. ADDR, LH IS EXTRA INFO (SECONDARY DISP. ADDR).
;NEGATIVE => IT IS QREG STRING POINTER TO MACRO.
RRMACT:
;NON-CONTROL, NON-META CHARACTERS:
REPEAT ^H,RRXINS	;^@ - ^G
REPEAT 3,RRINSC,,RRREPT	;^H, ^I, ^J NEVER REPLACE, REGARDLESS OF FS ^R REPLACE$
	RRXINS		;^K
	RRXINS		;^L
	RRCRLF,,RRREPT	;^M
REPEAT 33-^M-1,RRXINS	;^N - ^Z
	RREXIT		;ALTMODE
REPEAT "A+40-ALTMOD-1,RRXINS ;^\ - `
REPEAT 26.,40,,RRINDR	;LOWERCASE LETTERS.
REPEAT 4,RRXINS		;LOWERCASE SPECIAL CHARACTERS.
	RRRUB

.SEE RRITAB	;MUST BE CHANGED WHEN THE ENTRIES BELOW ARE CHANGED.
;CONTROL, NON-META CHARACTERS:
REPEAT ^H,RRERR		;CONTROL-^@ TO CONTROL-^G
REPEAT 3,200,,RRINDR	;CONTROL-BS TO CONTROL-LF.
REPEAT 2,RRERR		;CONTROL-^K AND CONTROL-^L.
	200,,RRINDR	;CONTROL-CR
REPEAT 33-^M-1,RRERR	;CONTROL-^N THROUGH CONTROL-^Z.
	200,,RRINDR	;CONTROL-ALTMODE.
REPEAT "0-33-1,RRERR	;CONTROL-^\ TO CONTROL-/
REPEAT 10.,RRCDGT	;CONTROL-0 THRU CONTROL-9
REPEAT 100-"9-1,RRERR	;CONTROL-: TO CONTROL-?
	RRERR		;^@
	RRBEG		;^A
	RRCTLB		;^B
	RRCMSW		;^C
	RRCTLD		;^D
	RREND		;^E
	RRCTLF		;^F
	RRQUIT		;^G
	300,,RRINDR	;^H
	300,,RRINDR	;^I
	300,,RRINDR	;^J
	RRKILL		;^K
	RRCTLL		;^L
	RRINSC,,RRREPT	;^M
	RRNEXT		;^N
	RRCTLO,,RRREPT	;^O
	RRPREV		;^P
	RRQUOT		;^Q
	RRCMCS		;^R
	RRSRCH		;^S
	RRMARK		;^T
	RR4TIM		;^U
	RRARG		;^V
	RRFX		;^W
	RREXCH		;^X
	RRERR		;^Y
	RRERR		;^Z
	RRERR		;^[
	RRERR		;^\
	RRBRC		;^]
	RRERR		;^^
	RRERR		;^_
	RRERR		;^`
REPEAT 32,40,,RRINDR	;^<LOWERCASE LETTERS>
REPEAT 4,RRERR		;^{ ^| ^} ^~
	RRCRUB		;CONTROL-RUBOUT.
IFN .-RRMACT-400,,.ERR

;META CHARS:
REPEAT "A+40,RRXINS
REPEAT 26.,40,,RRINDR	;LOWERCASE LETTERS INDIRECT THRU UPPERCASE.
REPEAT 5,RRXINS

;CONTROL-META CHARS: MOSTLY SELF-INSERTING, BUT SOME ARE INDIRECT THROUGH OTHERS.
REPEAT ^H,RRXINS	;^@ THRU ^G
REPEAT 3,200,,RRINDR	;^H THRU ^J
REPEAT 2,RRXINS		;^K, ^L
	200,,RRINDR	;^M
REPEAT 33-^M-1,RRXINS	;^N TO ^Z
	200,,RRINDR	;ALTMODE
REPEAT "G-33,RRXINS	;^\ TO G
REPEAT 3,300,,RRINDR	;H, I, J
REPEAT "`-"J,RRXINS	;K TO `
REPEAT 32,40,,RRINDR	;a to z
REPEAT 200-172-1,RRXINS	;{ TO RUBOUT.

IFN .-RRMACT-1000,.ERR

RRMACL==1000	;LENGTH OF RRMACT

CBUF:	BLOCK CBUFSZ	;COMMAND BUFFER FOR NON-^R MAIN LOOP.

;INITIAL CONTENTS OF STRING SPACE:

INIQRB==5*.
ERSTRT:	BLOCK ERTOTL		;STRINGS FOR ERROR MESSAGES GO HERE.
EREND::
INIDLM::
	<.BYTE 7 ? 177 ? QRSTR ? 4 ? 5 ? 0>
	REPEAT 33,	ASCII /     /
			ASCII / A   /	;ALTMODE
	REPEAT 40-33,	ASCII /     /	;34 THRU SPACE
			ASCII / A   /	;!
			ASCII / A   /	;"
			ASCII / A   /	;#
	REPEAT "%-"$+1,	ASCII /AA   /	;$, %.
			ASCII / A   /	;&
			ASCII / '   /	;'
			ASCII / (   /	;(
			ASCII / )   /	;)
			ASCII / A   /	;*
			ASCII / A   /	;+
			ASCII /     /	;,
			ASCII / A   /	;-
			ASCII /AA   /	;.
			ASCII . /   .	;/
	REPEAT "0-"/-1,	ASCII / A   /
	REPEAT "9-"0+1,	ASCII /AA   /
	REPEAT "A-"9-1,	ASCII / A   /
	REPEAT "Z-"A+1,	ASCII /AA   /
	REPEAT "a-"Z-1,	ASCII / A   /
	REPEAT "z-"a+1,	ASCII /AA   /
	REPEAT "|-"z-1,	ASCII / A   /
			ASCII / |   /
	REPEAT 176-"|,	ASCII / A   /
			ASCII /     /
IFN .-INIDLM-201,.ERR WRONG TABLE LENGTH
INI..O==5*.
	<.BYTE 7 ? QRBFR ? MFBUF1&177 ? MFBUF1_<-7>&177
		MFBUF1_<-14.>&177>
INISRS==5*.
	<.BYTE 7 ? QRBFR ? MFSBUF&177 ? MFSBUF_<-7>&177 ? MFSBUF_<-16>&177>
INIQRW==5*.

;INITIAL CONTENTS OF BUFFER SPACE.

INIBUF==5*<<INIQRB/5+SLPQWR>&<-2000>>
INISRB==INIBUF
INISRE==INISRB+5*<1+STBLSZ>
INIBEG==INISRE+5
INITOP==INIBEG+5

END INIT
