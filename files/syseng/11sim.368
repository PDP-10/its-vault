
TITLE 11SIM

.MLLIT=1
.SYMTAB 3000.

CPRI=0
A=1
B=2
C=3
D=4
E=5
T=6
TT=7

MB=10	;MEMORY BUFFER
MA=11	;MEMORY ADDRESS
X=12
PC=13	;PROGRAM COUNTER
PS=14	;PROCESSOR STATUS
	PRI==50300	;PRIORITY (BYTE POINTER)
	TF==20
	NF==10
	ZF==4
	VF==2
	CF==1
TIME=15	;TIME (IN TETHS OF MICROSECONDS)
I=16	;INSTRUCTION
P=17

.XCREF A,B,C,D,E,I,MA,MB,P,PC,PS,T,TIME,TT

ETC==0
TYIC==1
TYOC==2
LOADCH==3
LPTC==4
UTIC==5
DMPCH==6
ERRC==7
DYCH==10	;FIRST DYNAMICLY ALLOCATED CHANNEL
DYCHN==10	;NUM DYNAMICLY ALLOCATED CHS
DYCMSK==377_10			;USED BY DC AND DM

SYMTYP=1000,,
ADRTYP=2000,,
OPENL=3000,,
6TYPE=4000,,
BLKFLS=5000,,
TTOI=6000,,
TTOA=7000,,
ERROR=10000,,
UUOMAX==10
ARGERR=ERROR [ASCIZ/ARG/]
CALL=PUSHJ P,
RETURN==POPJ P,
RET=RETURN
SAVE=PUSH P,
REST=POP P,
CRF=TTOA [ASCIZ /
/]

.XCREF CALL,RET,RETURN

TRPPTL==100	;-1)*4=MAX TRAP FOR TRAP PRINT VECTOR
PDLSIZ==200	;PDL SIZE

IF1 EXPUNGE APR


;MEMORY ALLOCATION

;0	START OF SIMULATOR, ENDS WITH SYM TAB THAT EXPANDS UPWARD
;RKBUF=NGBLK-6000*RKNBUF	;RK BUFFERS, 3K PER.
NGBLK=274000	;NG DIS
PDP11=300000	;SIMULATED PDP11 MEMORY 1 WORD/WORD
.XCREF PDP11
   ;(372000	;I-O BLOCK USED ONLY BY TKDIS)
   ;(374000	;I-O BLOCK USED ONLY BY PROGRAMMABLE CLOCK)
   ;(376000	;MAIN PDP11 I-O REGS BLOCK)
;400000 TO 777777	;RF11/RS11 DISK STORAGE 2 WORDS/WORD


;I-O ROUTINE SYMBOL CONVENTIONS

;A!DEV:	ATTACH ROUTINE
;D!DEV:	DETACH ROUTINE
;W!DEV:	FLAG, 0 IF DETACHED, -1 IF ATTACHED
;Z!DEV:	"RESET" ROUTINE IF DIFFERENT FROM A!DEV
;REG!(HAK,HK,K):	DEVICE REGISTER REG ROUTINE
;DEV!TIM: TIME CONSTANT FOR OPERATION OF DEVICE

;OTHER SYMBOL CONVENTIONS

;I!INSN:	ROUTINE FOR SIMULATION OF INSTRUCTION INSN
;C!COM:	ROUTINE FOR : COMMAND COM
;CS!COM:	ROUTINE FOR ; COMMAND COM

ABEG:	LOC 41
	JSR UUOH
	JSR TSINT

DEFINE CONC A,B
A!B!TERMIN

DEFINE TSOPEN A,B
	.OPEN A,B
	OPENL B
	TERMIN

DEFINE SYSCAL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
	.VALUE
TERMIN

DEFINE SYSCL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

DEFINE INSIRP A,B
IRPS INSIR1,,[B]
A,INSIR1
TERMIN TERMIN

;PERFORM APPROPRIATE ADJUSTMENTS IF A
;NEW QUANTITY HAS BEEN LOADED IN PS
DEFINE NEWPS
	ANDI PS,377
	LDB CPRI,[PRI,,PS]
	MOVE A,[LDB T,[061200,,I]]
	TRNE PS,TF
	MOVE A,[JRST TTRPIB]
	MOVEM A,TRPMOD
	TERMIN

;DON'T USE XXWAIT UNLESS THE PRIORITY IS REALLY 6,,
DEFINE XXWAIT X
	JSP A,MTRNEW
	6,,
	-1
	IFSN X,,PUSHJ P,X
	IFSE X,,PUSHJ P,.+1
	TERMIN

IOCNUM==0	;GET CONTROL ON IOC ERRORS
DEFINE IOCGET X
	IF2 [IOCLOC==.
LOC IOCTAB+IOCNUM
	IOCLOC
	X
LOC IOCLOC]
	IOCNUM==IOCNUM+2
	TERMIN

DEFINE	CSLWRD	A
	JSP D,	CSLR!A
TERMIN			;LOAD 1 WORD FROM LOADCH INTO A (T2, T3, T5).

LOC ABEG

BEG:	SETZM RUN	;RUN=0 MEANS STOP SOON (LOOKED AT BY DIRECT TO MEM DEVICES)
	SETZM DDTPDP	;DDTPDP=0 MEANS NORMAL NOT IN DDT
			;DDTPDP>0 NOT IN DDT BUT FAKE OUT MTRAP ETC.
			;DDTPDP<0 IN DDT (SAVE PDL PNT HAS NEG COUNT IN LH)
	SETOM DINITF	;WILL BE 1ST CALL TO DDT SOON.
	MOVE P,[(-PDLSIZ)PDL]
	SETZB PC,PS
	NEWPS
	.SUSET [.RUNAME,,RUNAME]
	SETZM LPTFLG
	PUSHJ P,MERRV
	.OPEN TYOC,TYOF
	.VALUE		;IF NO TYPEOUT.
	MOVE A, [-BSUSL,,BSUST]
	.SUSET A	;SET UP INTERRUPTS
	.OPEN TYIC,TYIF
	TTOA [ASCIZ /
TYPE IN FAILS/]
	.STATUS TYIC,A
	ANDI A,77
	CAIN A,2
	SETOM GETTY		;SET GETTY TO -1 IF GRAPHICS TTY.
	.CALL TTYGT
	.VALUE
	TLZ A,2000
	MOVEM A,TTYM1A		;SET UP ORDINARY TTYSET,
	TLO A,2000
	MOVEM A,TTYMAA		;ACTIVATE-ON-NEXT-CHAR TTYSET.
	6TYPE [SIXBIT /11SIM./]
	6TYPE [.FNAM2]
	PUSHJ P,BLKGET		;GET PDP-11 I-O BLOCK
	600000,,PDP11+76000	;SET TO NXM
	PUSHJ P,CZTIME		;MUST FOLLOW SETUP OF NXM INTERRUPTS & LOCATIONS
	CRF
	PUSHJ P,WRDINS	;SET UP STATUS, PC, SWITCH REG
	600000+NPS,,RPS
	600000+NSWR,,RSWR
	REPEAT 3,600000+NCSX,,RCSX+.RPCNT+1
	0,,RCSX
	0
	PUSHJ P,XRESET	;INITIALIZE AND ATTACH VARIOUS DEVICES
	.OPEN UTIC,INITFI
	JRST BEG2
	TTOA [ASCIZ /INIT
!/]
	SETOM FILINF
	JRST DIEDIE

BEG2:	MOVEI T5,8
	SKIPN KCOUNT	;IF NO CORE YET,
	PUSHJ P,CCORE1	;GET 8 K.
	TTOI "!
	JRST DIEDIE

INITFI:	SIXBIT /   DSK.PDP11(INIT)/
FILINF:	0

;NOTE THAT IF DDTPDP IS NEG, THE SIMULATED TIME WILL BE IN RTIME NOT TIME

;INTERRUPT HANDLER
TSINT:	0
	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40
	PUSH P,UUOH
	SETZM INTINS
	SKIPGE DEBUGP
	.SUSET [.RJPC,,INTJPC]
	SKIPL A,TSINT
	JRST OTHERI	;FIRST WORD INT
	TRNN A,1_TYIC+DYCMSK
	JRST BADINT	;SECOND WORD BUT NOT VALID CHANNEL
	TRNN A,1_TYIC
	JRST DYCINT	;NOT TYI
	MOVEI A,TYIC
	.ITYIC A,
	JRST DYCINT
	AOSN ICTLQF
	JRST TSINT2
	CAIN A,^Q
	JRST TSINTQ
	CAIE A,^W
	CAIN A,^S
	JRST TSILNT
	CAIN A,^V
	SETOM TYOFLG
	CAIN A,^B
	JRST TSINTB
	CAIN A,^E
	JRST TSINTE
	CAIN A,^G
	JRST TSQUIT
TSINT2:	SKIPGE DDTPDP
	JRST DYCINT
	CALL TSINNS	;STOP SLEEPING, PC INTO A.
	SKIPN TKBUSY	;IF WON'T LOOK FOR ANOTHER CHAR,
	CALL TKB224	;LOOK FOR IT NOW.
	JRST DYCINT

TSINNS:	HRRZ A,TSINT+1
	CAIN A,IWAITS	;DON'T RETURN TO .SLEEP .
	AOS TSINT+1
	RETURN

TSQUIT:	SKIPGE DDTPDP		;IF INSIDE DDT,
	.DISMI [DERR]		;RETURN TO MAIN LOOP RIGHT AWAY.
	AOS A,QUITF
	CAIL A,2
	.DISMI [QUIT]		;3 ^G'S - STOP IMMEDIATELY.
	TTOA [ASCIZ/
^G   /]
	PUSHJ P,CLRRUN		;STOP AFTER INSN.
	CAIE A,1
	JRST DYCINT
TSILNT:	SETZM TYOFLG
	PUSHJ P,TRESET
	JRST DYCINT

TSINTQ:	SETOM ICTLQF
DYCINT:	MOVE A,TSINT
	TRNN A,DYCMSK
	JRST TSINTX
	MOVE C,[-DYCHN,,DYCH]
DYCIN2:	TDNE A,DYCBIT-DYCH(C)
	PUSHJ P,DYCINR
	AOBJN C,DYCIN2
	JRST TSINTX

DYCINR:	HRRZ B,C	;INTERRUPT ON DYNAMICALLY ALLOCATED CHANNEL
	SKIPE DYCTYP-DYCH(C)	;SKIP IF TTY
	JRST DYCINS
	.ITYIC B,	;MUST ITYIC IF TTY
	POPJ P,
DYCINS:	PUSH P,A
	CALL TSINNS	;STOP A WAIT INSN.
DYCILY:	MOVE A,DYCBPT-DYCH(C)
	SKIPL 1(A)	;IF MAIN PROGM NOT LOOKING AT THIS CHNL,
	JRST POPAJ
	SAVE C
	MOVE C,TIME
	SKIPGE DDTPDP
	MOVE C,RTIME
	SKIPN QFLAG
	PUSHJ P,CTRDES	;TELL IT TO LOOK SOON.
	SKIPE QFLAG
	PUSHJ P,MTRDES
	REST C
POPAJ:	POP P,A
	POPJ P,

TRESET:	.RESET TYOC,
	SKIPE LPTFLG
	.RESET LPTC,
	RETURN

QUIT:	SAVE TSINT+1		;DDT WILL RETURN TO INTERRUPTED SIMULATION.
	SAVE [DDT]		;RSTALL WILL RETURN TO DDT.
	PUSHJ P,SAVALL
	PUSHJ P,MERRV
	TTOA [ASCIZ/
^GSUPER-QUIT!   /]
	MOVEI A,TRUNBK
	PUSHJ P,QDEL
	JRST RSTALL		;RESTORE ACS, RETURN(TO DDT).

QUITF:	-1
ICTLQF:	0

OTHERI:	TRNE A,200000
	TTOA [ASCIZ /
PDL OVERFLOW/]
	TRNE A,400
	JRST OTHIOC	;IOC INT
	TRNN A,20000
	JRST BADINT
	MOVSI A,600000	;NON-EX MEM
	MOVEM A,NXMCLB
	HRRZ A,TSINT+1
	CAIL A,SYMTAB
	TTOA [ASCIZ/
NXM OUTSIDE PROGRAM AREA/]
	SKIPA A,-1(A)
NXMX2:	MOVE A,(A)
	HRRI A,@A
;	TRNN A,400000	;THIS TEST FOULS UP ON BYTE INSNS.
;	TRNN A,300000
;	TTOA [ASCIZ/
;NXM OUTSIDE VIRT. MEM/]
	AND A,[777740,,-1]
	TLC A,(XCT)
	TLNN A,777000
	JRST NXMX2	;XCT, GO DOWN CHAIN
	TLC A,(XCT)
	HRRI A,NXMCLB
	JRST NXMXIT

OTHIO4:	MOVE A,1(A)
NXMXIT:	MOVEM A,INTINS
TSINTX:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	SKIPN INTINS
	.DISMI TSINT+1
	AOS TSINT+1		;TAKE CARE OF SKIPPING INSNS.
	XCT INTINS
	SOS TSINT+1
	.DISMI TSINT+1

OTHIOC:	HRRZ C,TSINT+1
	MOVEI A,IOCTAB
OTHIO2:	CAMN C,(A)
	JRST OTHIO4
	ADDI A,2
	CAIE A,IOCEND
	JRST OTHIO2
	TTOA [ASCIZ /
IOC ERROR IN /]
	SOS TSINT+1		;RETURN TO THE .IOT .
	JRST BADINU

NXMCLB:	0	;MAY BE CLOBBERED
INTJPC:	0
INTINS:	0

BSUST:	.SMASK,,[220400]
	.SPICL,,[-1]
	.SMSK2,,[1_TYIC+DYCMSK]
BSUSL==3

RUNTB:	0	;RUN TIME BASE
TYIF:	4,,SIXBIT /   TTY/
TYOF:	21,,SIXBIT /   TTY/
RUNAME:	0

BADINT:	PUSHJ P,MERRV
	TTOA [ASCIZ /
BAD INTERRUPT IN 
INT:   /]
	MOVE B,TSINT
	PUSHJ P,FOCTP
BADINU:	REST UUOH		;RESTORE EVERYTHING SAVED.
	REST 40
	REST C
	REST B
	REST A
	.VALUE [ASCIZ*INTJPC/        *]
	.DISMI TSINT+1		;STOP BEFORE NEXT INSN.

LPTFIL:	1,,SIXBIT /   LPT/
	SIXBIT /WALL  PAPER/

;UUO HANDLER
UUOH:	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40	;4O MUST BE NEXT TO LAST PUSHED
	PUSH P,UUOH	;UUOH MUST BE LAST PUSHED
	HRRZ A,40
	LDB C,[331100,,40]
	SKIPE C		;JUMP WILL CLOBBER JPC
	CAILE C,UUOMAX
	SKIPA
	JRST @UUODIS-1(C)
	.SUSET [.RJPC,,20]
	PUSHJ P,MERRV
	TTOA [ASCIZ /
ILLEGAL UUO IN 
.JPC/]
	REST UUOH
	REST 40
	REST C
	REST B
	REST A
	SOS UUOH		;POINT TO UUO.
	.VALUE [ASCIZ*20/	    *]
	JRST @UUOH		;STOP BEFORE THE UUO.

UUODIS:	XSYMTY
	XADRTY
	UOPENL
	U6TYPE
	UBLKFL
	UTTOI
	UTTOA
	UERROR

UTTOA:	LDB B,[270400,,40]	;SKIP BY C(AC FIELD)
	ADDM B,(P)
	HRLI A,440700
	SAVE MCTLVF
MES2:	ILDB B,A
	CAIG B,^F
	XCT MESTAB(B)
	CAIN B,^K
	JRST MCTLK	;DECP
	CAIN B,^V
	JRST MCTLV
	TTOI (B)
	JRST MES2

MCTLV:	SETOM MCTLVF
	JRST MES2

MESTAB:	JRST MESXIT	;^@
	JRST MFOCTP	;^A
	JRST OPPNT	;^B
	JFCL		;^C
	JRST MCTLD	;SYMTYP
	JRST MCTLE
	JRST MCTLF	;ADRTYP

MERRV:	SETOM TYOFLG
	SETZM DISOUT
	RETURN

MCTLVF:	0	;FORCE TTY OUTPUT FOR ERROR MESSAGES

MESXIT:	REST MCTLVF
	JRST UUOXIT

MFOCTP:	PUSHJ P,UGQUAN
	PUSHJ P,FOCTP
	JRST MES2

FOCTP:	LSHC B,-43	;FULL WORD OCTAL PRINT
	LSH C,-1
	DIVI B,8
	HRLM C,(P)
	SKIPE B
	PUSHJ P,FOCTP
	HLRZ C,(P)
	TTOI "0(C)
	RETURN

UGQUAN:	ILDB B,A	;GET QUANTITY
	CAIL B,"8
	JRST UGQUA2
	HRRZ B,R0-"0(B)
	RETURN

UGQUA2:	CAIE B,"A
	SKIPA B,QT
	MOVE B,QA
	RETURN

OPPNT:	PUSH P,[MES2]
	PUSHJ P,SAVALL
	SKIPL DDTPDP
	AOS DDTPDP
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	SKIPGE DL,OPC
	JRST OPPNT1
	LSH DL,1
	PUSHJ P,DPINSN
	SKIPA
OPPNT1:	TTOA [ASCIZ/--DDT--/]
	SKIPL DDTPDP
	SOS DDTPDP
	JRST RSTALL

MCTLF:	SKIPA C,[ADRTYP QD]
MCTLD:	MOVE C,[SYMTYP QD]
	PUSHJ P,UGQUAN
	MOVEM B,QD
	PUSH P,[MES2]
	PUSHJ P,SAVALL
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	XCT C
	JRST RSTALL

MCTLE:	.VALUE		;FATAL ERROR
	SKIPGE DDTPDP
	.DISMI [DERR]
	.DISMI [BEG]

MCTLK:	PUSHJ P,UGQUAN
	PUSHJ P,DECP
	JRST MES2

OCTP:	SKIPA C,[8]
DECP:	MOVEI C,10.
	HRRM C,ANYP
ANYP:	IDIVI B,.
	HRLM C,(P)
	SKIPE B
	PUSHJ P,ANYP
	HLRZ B,(P)
	TTOI "0(B)
CPOPJ:	RETURN

UBLKFL:	HRRZ B,(P)	;FLUSH QUEUE BLOCKS
	ADD B,[<222200,,>-1]
UBLKF2:	ILDB A,B
	TLNE B,770000
	AOS (P)
	JUMPE A,UUOXIT
	PUSH P,B
	PUSHJ P,QDEL
	POP P,B
	JRST UBLKF2

UTTOI:	SKIPE MCTLVF
	JRST UTTOI1
	SKIPE DISOUT
	JRST UDISCH
	SKIPE TYOFLG
UTTOI1:	.IOT TYOC,A	;THE ONLY TYPE OUT IOT
	SKIPE LPTFLG
	.IOT LPTC,A
	JRST UUOXIT

UDISCH:	PUSHJ P,DISCH
UUOXIT:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	JRST 2,@UUOH

U6TYPE:	MOVE B,@40
	MOVE A,[440600,,B]
U6TYP2:	ILDB C,A
	JUMPE C,UUOXIT
	TTOI 40(C)
	JRST U6TYP2

UOPENL:	.SUSET [.RBCHN,,C]	;OPENL UUO, GET # OF CHANNEL.
	CAIE C,LPTC
	JRST UOPNL1
	SETZM LPTCNT
	SETZM LPTFLG
UOPNL1:	DPB C,[270400,,OPNLX1]
	DPB C,[270400,,OPNLX2]
OPNLX1:	.STATUS .,OPLERR
	HLR C,(A)
	CAIE C,4^5	;NEW SYSTEM CALL OPEN, DON'T GET DEV NAME.
	TRNE C,1
	JRST UOPNL3	;OUTPUT LOST
	.SUSET [.RSNAME,,LSNAME]
	.SUSET [.SSNAME,,[SIXBIT /PDP11/]]
OPNLX2:	.OPEN .,(A)
	JRST UOPNL2
	.SUSET [.SSNAME,,LSNAME]
	JRST UUOXIT

UOPNL2:	.SUSET [.SSNAME,,LSNAME]
UOPNL3:	.OPEN ERRC,ERRFIL
	JRST .-1
	PUSHJ P,MERRV
UOPNL4:	.IOT ERRC,B
	CAIE B,14
	CAIN B,3
	JRST UOPNL6
	TTOI (B)
	JRST UOPNL4

UOPNL6:	CAIN C,4^5
	 JRST DERR
	HRLZ B,(A)
	6TYPE B
	JRST DERR

ERRFIL:	(SIXBIT /ERR/)
	3
OPLERR:	.

LSNAME:	0	;LAST SYSTEM NAME

WRDINS:	PUSH P,A	;WORD INSERT
	PUSH P,B
	PUSH P,C
	MOVE A,-3(P)
WRDIN2:	SKIPN B,(A)
	JRST WRDIN4
	LDB C,[MARPOS,,(B)]
	SKIPE C
	TLO B,400000
	HLLZM B,(B)
	DPB C,[MARPOS,,(B)]
	AOS A,-3(P)
	JRST WRDIN2

WRDIN4:	POP P,C
	POP P,B
	POP P,A
	JRST POPJ1

;IN DDT,  PRINTS MESSAGE & CAUSES ERROR, DOESN'T RETURN.
;OUTSIDE DDT, PRINTS MESSAGE, CAUSES DDT TO BE CALLED, RETURNS.
UERROR:	PUSHJ P,MERRV	;TURN ON TTY FOR ERROR MSG.
	SKIPN DEBUGP
	JRST UERRO1
	TTOA [ASCIZ/
10PC: /]
	MOVE B,(P)	;IF DEBUGGING,
	PUSHJ P,FOCTP	;PRINT ADDR AFTER ERROR UUO.
	CRF
UERRO1:	SKIPGE DDTPDP
	TTOA [ASCIZ/   /]
	TTOA (A)
	SKIPGE DDTPDP
	JRST DERR
	PUSHJ P,CLRRUN
	LDB B,[270400+P,,-1]
	JUMPE B,UUOXIT		;AC FIELD 0 - NO POPJS.
	MOVNI B,-POP14J(B)
	HRRM B,(P)		;EXIT TO RTN TO POPJ SEVERAL TIMES.
	JRST UUOXIT

REPEAT 14.,REST POP14J
	RETURN
POP14J:	0		;EXCESS WDS ON PDL THROWN AWAY HERE.

TYI1:	.IOT TYIC,MB
	CAIN MB,^Q
	JRST TYI4
	CAIE MB,177
	CAIGE MB,140
	SKIPA
	SUBI MB,40
	CAIE MB,^E
	CAIN MB,^V
	JRST TYI1
	CAIE MB,^B
	CAIN MB,^W
	JRST TYI1
	CAIE MB,^S
	RETURN
	SETOM TYOFLG
	JRST TYI1

TYI4:	.IOT TYIC,MB
	RETURN

TSINTB:	SAVE [DYCINT]
DGLNCB:	SKIPN LPTFLG
	PUSHJ P,OPNLPT
	SETOM LPTFLG
	RETURN

TSINTE:	SAVE [DYCINT]
DGLNCE:	SKIPN LPTFLG
	RETURN
	SETZM LPTFLG
	JRST CLSLPT

CWALLP:	MOVEI A,LPTFIL	;^B TO FILE
	PUSHJ P,DGFIL
	PUSHJ P,OPNLPU
	SKIPE LPTFLG
	RETURN
	SETOM LPTFLG
	AOS LPTCNT
	RETURN

OPNLPT:	AOS C,LPTCNT
	SOJN C,CPOPJ
OPNLPU:	.OPEN LPTC,LPTFIL
	JRST .+2
	RETURN
	TSOPEN LPTC,TPLFIL
	TTOA [ASCIZ /USING TPL/]
	RETURN

TPLFIL:	SIXBIT /  !TPLWALL  PAPER/

ACORE:	HRRZ A,KCOUNT	;ATTACH CORE
	SKIPN T5
	JRST ACORE4
	CAIL A,28.
	JRST ACORE2
	LSH A,10.
	PUSHJ P,BLKGET
	PDP11(A)
	AOS KCOUNT
	SOJA T5,ACORE

ACORE2:	TTOI "?
ACORE4:	MOVEM A,QT
	LSH A,11.
	HRRM A,%CORE
	TTOA [ASCIZ /CORE = T.K
/]
	RETURN

DCORE:	HRRZ A,KCOUNT	;DETACH CORE
	SKIPN T5
	JRST ACORE4
	JUMPE A,ACORE2
	LSH A,10.
	PUSHJ P,BLKZAP
	PDP11-2000(A)
	SOS KCOUNT
	SOJA T5,DCORE

KCOUNT:	0

BLKGET:	PUSH P,MA	;GET CORE BLOCK
	PUSH P,MB
	MOVE MA,@-2(P)
	MOVEI MA,@MA
	LSH MA,-1
	TRZ MA,777
	IOR MA,[4000,,400000]
	MOVEM MA,QA
	.CBLK MA,
	TTOA [ASCIZ /
BLKGET CBLK FAILED
A/]
	HLLZ MB,@-2(P)
	JUMPGE MB,POMBA1	;ALLOW NEG FROBS TO SET TO NXM
	LSH MA,1
	MOVEM MB,(MA)
	HRLS MA
	AOS MA
	HLRZ MB,MA
	BLT MA,1777(MB)
POMBA1:	POP P,MB
POMAJ1:	POP P,MA
	AOS (P)
	RETURN

BLKZAP:	PUSH P,MA	;FLUSH CORE BLOCK
	MOVE MA,@-1(P)
	MOVEI MA,@MA
	LSH MA,-1
	ANDI MA,377000
	MOVEM MA,QA
	.CBLK MA,
	TTOA [ASCIZ /
BLKZAP CBLK FAILED
A/]
	JRST POMAJ1
;
;******************************************************************
;        THE SIMULATOR
;
INEZCF:	TROA PS,ZF\CF
INENEG:	TRO PS,NF

INEND:		;INSTRUCTION END
	CAMGE CPRI,@TRINF+1	;CHECK TRAP QUEUE
	JRST QTRZAP
	CAML TIME,@CLINF+1	;CHECK CLOCK QUEUE
	JRST QCLZAP
INBEG:	SKIPGE I,PDP11(PC)	;FETCH INSTRUCTION WORD
	JSP D,MTRAPI
	HRRZM PC,OPC
TRPMOD:	LDB T,[061200,,I]\JRST TTRPIB	;SEE NEWPS
	AOJA PC,@I1TAB(T)

TTRPIB:	CALL TTRPBJ
	LDB T,[061200,,I]
	AOJA PC,@I1TAB(T)

I1TAB:	I0000
	IJMP
	IRTS	;+IOPR
	ISWAB
	REPEAT 4,IBR
	REPEAT 4,IBNE
	REPEAT 4,IBEQ
	REPEAT 4,IBGE
	REPEAT 4,IBLT
	REPEAT 4,IBGT
	REPEAT 4,IBLE
	REPEAT 8,IJSR
	ICLR
	ICOM
	IINC
	IDEC
	INEG
	IADC
	ISBC
	ITST
	IROR
	IROL
	IASR
	IASL
	ISXT	;I45
	IMARK	;I45
	REPEAT 2,I1ILL
	REPEAT 8,I1ILL
	REPEAT 64.,IMOV
	REPEAT 64.,ICMP
	REPEAT 64.,IBIT
	REPEAT 64.,IBIC
	REPEAT 64.,IBIS
	REPEAT 64.,IADD
	REPEAT 8,IXOR	;I45
	REPEAT 8,I1ILL
	REPEAT 8,IIMUL	;I45
	REPEAT 8,IIDIV	;I45
	REPEAT 8,IASH	;I45
	REPEAT 8,IASHC	;I45
	REPEAT 8,I1ILL
	REPEAT 8,ISOB	;I45
	REPEAT 4,IBPL
	REPEAT 4,IBMI
	REPEAT 4,IBHI
	REPEAT 4,IBLOS
	REPEAT 4,IBVC
	REPEAT 4,IBVS
	REPEAT 4,IBCC
	REPEAT 4,IBCS
	REPEAT 4,IEMT
	REPEAT 4,ITRAP
	ICLRB
	ICOMB
	IINCB
	IDECB
	INEGB
	IADCB
	ISBCB
	ITSTB
	IRORB
	IROLB
	IASRB
	IASLB
	REPEAT 4,I1ILL
	REPEAT 8,I1ILL
	REPEAT 64.,IMOVB
	REPEAT 64.,ICMPB
	REPEAT 64.,IBITB
	REPEAT 64.,IBICB
	REPEAT 64.,IBISB
	REPEAT 64.,ISUB
	REPEAT 64.,I1ILL

I1ILL:	ADDI TIME,15.
	JSP A,IILL

DBNDE:	SKIPL DBNDBK+1	;DELAYED BOUND ERROR
	JRST (D)
	MOVEM D,DBNDE.
	MOVEI A,DBNDBK
	MOVSI C,5
	CALL MTRDES
	JRST (D)

DBNDBK:	0
	-1
	JRST DBNDTR
DBNDE.:	0

DBNDTR:	MOVE A,DBNDE.
	SETOM ODDPC
	JRST BOUNDE

QTRZAP:	MOVE B,TRINF+1	;DO QUEUE'ED TRAP REQUEST
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,TRINF+1
	XCT 2(B)
	JRST INEND

QCLZAP:	MOVE B,CLINF+1	;DO QUEUE'ED CLOCK REQUEST
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,CLINF+1
	XCT 2(B)
	JRST INEND

TTRPBJ:	JSP A,MTRNEW
TTRPBK:	4,,
	-1
	JRST TTRAP

CLRRUN:	SETZM RUN
	JSP A,MTRNEW
TRUNBK:	2,,
	-1
	PUSHJ P,CLRRN2

CLRRN2:	PUSH P,[DDTXIT]
	SETOM DDONXT		; ;N WILL DO NEXT INSN.
	JRST DDT1


CNTINS:	SOSG INSCNT	;IF DID THAT MANY INSNS, STOP.
	JRST CNTIN2
	CAIN PC,@%CSN	;IF RETURNED FROM ;N, STOP.
	JRST CNTIN1
	SKIPGE I,PDP11(PC)
	JSP D,MTRAPI
	JRST INBEG+2

CNTIN1:	HLLOS %CSN	;LEAVE ;N MODE.
CNTIN2:	TTOA [ASCIZ/
COUNT:  /]
	CALL CLRRN2
	JRST INBEG

;OPEN CODED BRANCH
DEFINE OBRANC
	ADDI TIME,11.
	ANDI I,377
	ADD PC,BRAT(I)
	ANDI PC,77777
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	JRST INEND
	TERMIN

DEFINE IZNEND
	TRZ PS,16
	TRNE MB,100000
	JRST INENEG
	TRNN MB,177777
	TRO PS,ZF
	JRST INEND
	TERMIN

DEFINE IZMEND
	TRNE MB,100000
	JRST INENEG
	TRNN MB,177777
	TRO PS,ZF
	JRST INEND
	TERMIN

IBR:	ADDI TIME,26.
	ANDI I,377
	ADD PC,BRAT(I)
	ANDI PC,77777
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	JRST INEND

BRAT:	REPEAT 200,,.RPCNT
	REPEAT 200,,.RPCNT-200

IBNE:	ADDI TIME,15.
	TRNE PS,ZF
	JRST INEND
BRANCH:	OBRANC

IBEQ:	ADDI TIME,15.
	TRNN PS,ZF
	JRST INEND
	OBRANC

IBGE:	ADDI TIME,15.
IBGT2:	TRNN PS,NF\VF
	JRST BRANCH	;BOTH OFF
	TRNE PS,NF
	TRNN PS,VF
	JRST INEND
	OBRANC	;BOTH ON

IBLT:	ADDI TIME,15.
IBLE2:	TRNN PS,NF
	TRNN PS,VF
	JRST IBLT2
	OBRANC

IBLT2:	TRNE PS,NF
	TRNE PS,VF
	JRST INEND
	OBRANC

IBGT:	ADDI TIME,15.
	TRNE PS,ZF
	JRST INEND
	JRST IBGT2

IBLE:	ADDI TIME,15.
	TRNN PS,ZF
	JRST IBLE2
	OBRANC

IJSR:	ADDI TIME,44.
	ANDI I,77
	XCT JD2CWT(I)
	LSH PC,1
	XCT IJSRT-40(T)
	HRRM PC,R0-40(T)
	HRRZ PC,MA
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	MOVE MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	JRST INEND

IJSRT:	REPEAT 7,MOVE MB,R0+.RPCNT
	SKIPA MB,PC

I0000:	JRST @I0000T(I)

I0000T:	IHALT
	IWAIT
	IRTI
	I00003
	IIOT
	IRESET
	IRTT	;I45
	REPEAT 64.-7,I2ILL

I2ILL:	ADDI TIME,15.
	JSP A,IILL

IJMP:	ADDI TIME,12.
	ANDI I,77
	XCT JD2CWT(I)
	MOVE PC,MA
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	JRST INEND

IMARK:	SKIPL WI45
	JSP A,IILL
	ANDI I,77
	LSH I,1
	ADD I,R6
	ANDI I,177777
	HRRM I,R6
	MOVEI I,205	;DUMMY UP AN RTS %5
IRTS:	TRNE I,70
	JRST IOPR
	ADDI TIME,35.
	HRRZ MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	XCT IRTST-200(I)
	HRRM MB,R0-200(I)
	TRNE PC,1
	JSP A,BOUNDE
	LSH PC,-1
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	AOS MA
	LSH MA,1
	HRRM MA,R6
	JRST INEND

IRTST:	REPEAT 7,HRRZ PC,R0+.RPCNT
	SKIPA PC,MB

IOPR:	ADDI TIME,15.
	XCT OPRT-200(I)
	JRST INEND

OPRT:	REPEAT 24.,JSP A,IILL
	REPEAT 8,JRST ISPL	;I45
	JRST INEND
	REPEAT 15.,TRZ PS,.RPCNT+1
	JRST INEND
	REPEAT 15.,TRO PS,.RPCNT+1

ISPL:	SKIPL WI45
	JSP A,IILL
	DPB I,[PRI,,PS]
	NEWPS
	JRST INEND

ISWAB:	ADDI TIME,23.
	XCT ODACWT-300(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	LDB T,[1000,,MB]
	LSH MB,-8
	TRZ PS,17
	XCT BYTRPS(MB)
	DPB T,[101000,,MB]
	HRRM MB,PDP11(MA)
	JRST INEND


IHALT:	ADDI TIME,18.
	TTOA [ASCIZ *
HALT:	*]
	JRST DIEDIE

WAITTS==80000.	;WAIT TOO SHORT TIME
IWAIT:	SETOM WAITFL
	ADDI TIME,18.
	AOS INSCNT		;SINCE WILL RE-EXECUTE WAIT.
IWAIT0:	CAMGE CPRI,@TRINF+1
	SOJA PC,INEND	;PENDING TRAP
	MOVE MB,@CLINF+1
	SUB MB,TIME
	CAIGE MB,WAITTS
	SOJA PC,IWAITX	;TOO SHORT
	CAILE MB,200000.
	MOVEI MB,200000.	;WAS TOO LONG
	ADD TIME,MB
	IDIVI MB,20000.
IWAITS:	.SLEEP MB,
	JRST IWAIT0

IWAITX:	MOVE TIME,@CLINF+1
	JRST INEND

WAITFL:	0

IRTT:	SKIPL WI45
	JSP A,IILL
	SKIPGE TTRPBK+1
	JRST IRTI
	MOVEI A,TTRPBK
	PUSHJ P,QDEL
IRTI:	ADDI TIME,48.
	HRRZ MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
	SKIPGE PC,PDP11(MA)
	JSP D,MTRAPR
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	AOS MA
	ANDI MA,77777
	SKIPGE PS,PDP11(MA)
	JSP D,MTRAPR
	NEWPS
	AOS MA
	ANDI MA,77777
	LSH MA,1
	HRRM MA,R6
	JRST INEND

IRESET:	ADDI TIME,200000.
	PUSHJ P,XRESET
	JRST INEND

XRESET:	PUSHJ P,ZLK
	PUSHJ P,ZPK
	SKIPE WTK
	PUSHJ P,ZTK
	SKIPE WTP
	PUSHJ P,ZTP
	SKIPE WPR
	PUSHJ P,ZPR
	SKIPE WPP
	PUSHJ P,ZPP
	SKIPE WEAE
	PUSHJ P,AEAE
	SKIPE WI45
	PUSHJ P,AI45
	SKIPE WNGDIS
	PUSHJ P,ANGDIS
	SKIPE WET
	PUSHJ P,ZET
	SKIPE DMCNT
	PUSHJ P,ZDM
	SKIPE WRK
	CALL ZRK
	JRST ZDF
ICLR:	ADDI TIME,23.
	XCT ODACWT-5000(I)
	TRZ PS,13
	TRO PS,ZF
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HLLZS PDP11(MA)
	JRST INEND

ICOM:	ADDI TIME,23.
	XCT ODACWT-5100(I)
	TRO PS,CF
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRC MB,177777
	HRRM MB,PDP11(MA)
	IZNEND

IINC:	ADDI TIME,23.
	XCT ODACWT-5200(I)
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	AOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,100000	;CORRECT
	JRST IINC2
	IZMEND

IINC2:	TRO PS,VF\NF
	JRST INEND

IDEC:	ADDI TIME,23.
	XCT ODACWT-5300(I)
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	SOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,77777
	JRST IDEC2
	IZMEND

IDEC2:	TRO PS,VF
	JRST INEND

INEG:	ADDI TIME,23.
	XCT ODACWT-5400(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVNS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	TRZ PS,17
	SKIPE MB
	TRO PS,CF
	CAIN MB,100000
	JRST INEG2
	IZMEND

INEG2:	TRO PS,VF\NF
	JRST INEND

ITST:	ADDI TIME,23.
	XCT ODACWT-5700(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	TRZ PS,17
	IZMEND

IADC:	ADDI TIME,23.
	XCT ODACWT-5500(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRNE PS,CF
	JRST IADC2
	IZNEND

IADC2:	TRZ PS,17
	AOS MB
	TRZ MB,200000
	HRRM MB,PDP11(MA)
	JUMPE MB,INEZCF
	CAIN MB,100000
	JRST IADC5
	IZMEND

IADC5:	TRO PS,VF\NF
	JRST INEND

ISBC:	ADDI TIME,23.
	XCT ODACWT-5600(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRNE PS,CF
	JRST ISBC2
	TRZ PS,17
	TRO PS,CF
	IZMEND

ISBC2:	TRZ PS,16
	SOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,77777
	JRST ISBC4
	SKIPN MB
	TRZ PS,CF
	IZMEND

ISBC4:	TRO PS,VF\CF
	JRST INEND

IROR:	ADDI TIME,23.
	XCT ODACWT-6000(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVE T,PS
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE T,CF
	TRO MB,100000
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	XCT ROTPST(PS)
	JRST INEND

IROL:	ADDI TIME,23.
	XCT ODACWT-6100(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVE T,PS
	TRZ PS,17
	TRZE MB,100000
	TRO PS,CF
	LSH MB,1
	TRNE T,CF
	TRO MB,1
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	XCT ROTPST(PS)
	JRST INEND

IASR:	ADDI TIME,23.
	XCT ODACWT-6200(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE MB,40000
	TRO MB,100000
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	XCT ROTPST(PS)
	JRST INEND

IASL:	ADDI TIME,23.
	XCT ODACWT-6300(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRZ PS,17
	TRZE MB,100000
	TRO PS,CF
	LSH MB,1
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	XCT ROTPST(PS)
	JRST INEND

ISXT:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,22.	;EST
	XCT ODACWT-6400(I)
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	TRNE PS,NF
	JRST ISXT2
	TRO PS,ZF
	HLLZM PDP11(MA)
	JRST INEND

ISXT2:	TRZ PS,ZF
	MOVEI MB,177777
	HRRM MB,PDP11(MA)
	JRST INEND

IMOV:	ADDI TIME,23.
	XCT OSACWT-100(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	IZNEND

ICMP:	ADDI TIME,22.	;TIME APPROX
	XCT OSACWT-200(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	LSH TT,20.
ICMPB2:	SETCMM MB
	JFCL 17,.+1
	ADD MB,TT
	SETCMM MB
	TRZ PS,17
	JFCL 10,ICMP2
	JFCL 4,ICMP4
	JUMPG MB,INEND
	JUMPL MB,INENEG
	TRO PS,ZF
	JRST INEND

ICMP2:	TROA PS,VF
ICMP4:	TROA PS,CF
	JFCL 4,.-1
	JUMPG MB,INEND
	JUMPL MB,INENEG
	TRO PS,ZF
	JRST INEND

IBIT:	ADDI TIME,28.	;TIME APPROX
	XCT OSACWT-300(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	AND MB,TT
	IZNEND

IBIC:	ADDI TIME,29.
	XCT OSACWT-400(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	ANDCA MB,TT
	HRRM MB,PDP11(MA)
	IZNEND

IXOR:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,23.	;EST
	MOVE MB,R0-700(T)
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	XOR MB,TT
	HRRM MB,PDP11(MA)
	IZNEND

IIMUL:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,80.	;EST
	HRRZ MB,R0-720(T)
	TRNE MB,100000
	ORCMI MB,177777
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	TRNE TT,100000
	ORCMI TT,177777
	TRZ PS,17
	IMUL MB,TT
	SKIPN MB
	TRO PS,ZF
	ROT MB,-20
	DPB MB,[2000,,R0-720(T)]
	TRO T,1
	ROT MB,20
	DPB MB,[2000,,R0-720(T)]
	JUMPE MB,INEND
	CAME MB,[-1]
	TRO PS,CF
	JRST INEND

IIDIV:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,160.	;EST
	TRZ PS,17
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	TRNN T,177777
	JRST IIDIV2
	TRNE TT,100000
	ORCMI TT,177777
	HRRZ MB,R0-730(T)
	TRNE MB,100000
	ORCMI MB,177777
	TRO T,1
	HRRZ MA,R0-730(T)
	ASH MB,20
	IOR MB,MA
	IDIV MB,TT
	CAML MB,[-1,,600000]
	CAIL MB,100000
	JRST IIDIV4
	LDB T,[60300,,PDP11-1(PC)]
	DPB MB,[2000,,R0(T)]
	TRO T,1
	DPB MA,[2000,,R0(T)]
	IZNEND

IIDIV2:	SUBI TIME,120.	;DIVIDE BY ZERO
	TRO PS,VF\CF
	JRST INEND

IIDIV4:	SUBI TIME,80.	;OVERFLOW
	TRO PS,VF
	JRST INEND

ISOB:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,23.	;EST
	HRRZ MB,R0-770(T)
	SOJLE MB,ISOB2
	HRRM MB,R0-770(T)
	ANDI I,77
	SUB PC,I
	ANDI PC,77777
	JRST INEND

ISOB2:	ANDI MB,177777
	HRRM MB,R0-770(T)
	JRST INEND

IASH:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,24.	;EST
	HRRZ MB,R0-740(T)
	LSH MB,2
	TRNE MB,400000
	TLO MB,-1
	ANDI I,77
	TRNE I,40
	JRST IASH2
	HLRZ TT,MB
	ASH MB,(I)
	TRZ PS,17
	XORI TT,(MB)
	TLNE MB,1
	TRO PS,CF
	TRNE TT,400000
	TRO PS,VF
IASH4:	LSH MB,-2
	HRRM MB,R0-740(T)
	IZMEND

IASH2:	TRO I,777700
	ASH MB,(I)
	TRZ PS,17
	TRNE MB,2
	TRO PS,CF
	JRST IASH4

IASHC:	SKIPL WI45
	JSP A,IILL
	ADDI TIME,30.	;EST
	HRL TT,R0-750(T)
	TRO T,1
	HRRZ MB,R0-750(T)
	ASH MB,2
	HLL MB,TT
	LSH MB,2
	ANDI I,77
	TRNE I,40
	JRST IASHC2
	ASH MB,-2(I)
	TRZ PS,17
	TLNE MB,200000
	TRO PS,CF
	XOR TT,MB
	TLNE MB,100000
	TRO PS,VF
IASHC4:	SKIPN MB
	TRO PS,ZF
	LDB T,[60300,,PDP11-1(PC)]
	LSH MB,-2
	DPB MB,[2000,,R0(T)]
	LSH MB,-20
	TRO T,1
	DPB MB,[2000,,R0(T)]
	TLNE MB,100000
	JRST INENEG
	JRST INEND

IASHC2:	TRO I,777700
	ASH MB,-2(I)
	TRZ PS,17
	TRNE MB,2
	TRO PS,CF
	JRST IASHC4

IADD:	ADDI TIME,23.
	XCT OSACWT-600(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	LSH TT,20.
	JFCL 17,.+1
	ADD MB,TT
	LSH MB,-2
	HLRM MB,PDP11(MA)
	TRZ PS,17
	JFCL 10,IADD2
	JFCL 4,IADD4
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

IADD2:	TROA PS,VF
IADD4:	TROA PS,CF
	JFCL 4,.-1
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

ISUB:	ADDI TIME,23.
	XCT OSACWT-1600(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	LSH TT,20.
	SETCMM TT
	JFCL 17,.+1
	ADD MB,TT
	SETCMM MB
	LSH MB,-2
	HLRM MB,PDP11(MA)
	TRZ PS,17
	JFCL 10,IADD2
	JFCL 4,IADD4
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

IBIS:	ADDI TIME,23.
	XCT OSACWT-500(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE PDP11(MA)
	JSP D,MTRPW
	IORB MB,PDP11(MA)
	IZNEND

IBPL:	ADDI TIME,15.
	TRNE PS,NF
	JRST INEND
	OBRANC

IBMI:	ADDI TIME,15.
	TRNN PS,NF
	JRST INEND
	OBRANC

IBHI:	ADDI TIME,15.
	TRNE PS,CF\ZF
	JRST INEND
	OBRANC

IBLOS:	ADDI TIME,15.
	TRNN PS,CF\ZF
	JRST INEND
	OBRANC

IBVC:	ADDI TIME,15.
	TRNE PS,VF
	JRST INEND
	OBRANC

IBVS:	ADDI TIME,15.
	TRNN PS,VF
	JRST INEND
	OBRANC

IBCC:	ADDI TIME,15.
	TRNE PS,CF
	JRST INEND
	OBRANC

IBCS:	ADDI TIME,15.
	TRNN PS,CF
	JRST INEND
	OBRANC

	TRO PS,NF	;-1
BYTEPS:	TRO PS,ZF
	REPEAT 177,JRST INEND
	REPEAT 200,TRO PS,NF
	TRO PS,ZF	;400

	TRO PS,NF
BYTVPS:	TRO PS,ZF
	REPEAT 177,JFCL
	REPEAT 177,TRO PS,NF
	TRO PS,NF\VF
	TRO PS,ZF

BYTRPS:	TRO PS,ZF
	REPEAT 177,JFCL
	REPEAT 200,TRO PS,NF

ICLRB:	ADDI TIME,23.
	XCT ODACBT-105000(I)
	MOVEI X,0
	TRZ PS,13
	TRO PS,4
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	MOVEI MB,0
	DPB MB,11BYTE(X)
	JRST INEND

ICOMB:	ADDI TIME,23.
	XCT ODACBT-105100(I)
	MOVEI X,0
	TRZ PS,16
	TRO PS,CF
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRC MB,377
	DPB MB,11BYTE(X)
	XCT BYTEPS(MB)
	JRST INEND

IINCB:	ADDI TIME,23.
	XCT ODACBT-105200(I)
	MOVEI X,0
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	AOS MB
	DPB MB,11BYTE(X)
	XCT BYTVPS(MB)
	JRST INEND

IDECB:	ADDI TIME,23.
	XCT ODACBT-105300(I)
	MOVEI X,0
	TRZ PS,15
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	SOS MB
	DPB MB,11BYTE(X)
	CAIN MB,177
	JRST IDECB2
	XCT BYTEPS(MB)
	JRST INEND

IDECB2:	TRO PS,VF
	JRST INEND

INEGB:	ADDI TIME,23.
	XCT ODACBT-105400(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVNS MB
	DPB MB,11BYTE(X)
	ANDI MB,377
	TRZ PS,17
	JUMPE MB,INEZCF
	XCT BYTVPS(MB)
	JRST INEND

ITSTB:	ADDI TIME,23.
	XCT ODACBT-105700(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	XCT 11BFIX(X)
	TRZ PS,17
	XCT BYTEPS(MB)
	JRST INEND

IADCB:	ADDI TIME,23.
	XCT ODACBT-105500(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRNE PS,CF
	JRST IADCB2
	TRZ PS,17
	XCT BYTEPS(MB)
	JRST INEND

IADCB2:	TRZ PS,17
	AOS MB
	DPB MB,11BYTE(X)
	CAIN MB,400
	JRST INEZCF
	XCT BYTVPS(MB)
	JRST INEND

ISBCB:	ADDI TIME,23.
	XCT ODACBT-105600(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRNE PS,CF
	JRST ISBCB2
	TRZ PS,17
	XCT BYTVPS(MB)
	JRST INEND

ISBCB2:	TRZ PS,17
	SOS MB
	DPB MB,11BYTE(X)
	JUMPE MB,INEZCF
	XCT BYTEPS(MB)
	JRST INEND

IRORB:	ADDI TIME,23.
	XCT ODACBT-106000(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVE T,PS
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE T,CF
	TRO MB,200
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	XCT ROTPST(PS)
	JRST INEND

IROLB:	ADDI TIME,23.
	XCT ODACBT-106100(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVE T,PS
	TRZ PS,17
	TRZE MB,200
	TRO PS,CF
	LSH MB,1
	TRNE T,CF
	TRO MB,1
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	XCT ROTPST(PS)
	JRST INEND

IASRB:	ADDI TIME,23.
	XCT ODACBT-106200(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE MB,100
	TRO MB,200
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	XCT ROTPST(PS)
	JRST INEND

IASLB:	ADDI TIME,23.
	XCT ODACBT-106300(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRZ PS,17
	TRZE MB,200
	TRO PS,CF
	LSH MB,1
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	XCT ROTPST(PS)
	JRST INEND

ROTPST:	REPEAT 16.,[REPEAT 4,[JRST INEND
	TRO PS,VF
]
	REPEAT 4,[TRO PS,VF
	JRST INEND
]]

DEFINE IZZBND
	TRZ PS,16
	ANDI MB,377
	XCT BYTEPS(MB)
	JRST INEND
	TERMIN

IMOVB:	ADDI TIME,23.
	XCT OSACBT-1100(T)
	ANDI I,77
	XCT OD2CBT(I)
	JRST IMOVBR	;REGISTER DESTINATION
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	DPB MB,11BYTE(X)
	IZZBND

IMOVBR:	ANDI MB,377
	TRNE MB,200
	TRO MB,177400
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	IZZBND

ICMPB:	ADDI TIME,22.	;APPROX
	XCT OSACBT-1200(T)
	LSH MB,28.
	ANDI I,77
	XCT OD2CBT(I)
	MOVEI X,0
	SKIPGE PDP11(MA)
	JSP D,MTRAPR
	LDB TT,11BYTE(X)
	LSH TT,28.
	JRST ICMPB2

IBITB:	ADDI TIME,28.
	XCT OSACBT-1300(T)
	ANDI I,77
	XCT OD2CBT(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	SKIPE X
	LSH TT,-8
	AND MB,TT
	IZZBND

IBICB:	ADDI TIME,29.
	XCT OSACBT-1400(T)
	ANDI I,77
	XCT OD2CBT(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	SKIPE X
	LSH TT,-8
	ANDCA MB,TT
	DPB MB,11BYTE(X)
	IZZBND

IBISB:	ADDI TIME,23.
	XCT OSACBT-1500(T)
	ANDI I,77
	XCT OD2CBT(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	SKIPE X
	LSH TT,-8
	IOR MB,TT
	DPB MB,11BYTE(X)
	IZZBND

11BYTE:	1000,,PDP11(MA)
	101000,,PDP11(MA)

11BFIX:	ANDI MB,377
	LSH MB,-8

OSACBT:	REPEAT 7,HRRZ MB,R0+.RPCNT
	JSP E,SABPC
	REPEAT 7,JSP E,SABRD
	JSP E,SABRD7
	REPEAT 6,JSP E,SACBI
	JSP E,SACBI6
	JSP E,SACBI7
	REPEAT 7,JSP E,SABID
	JSP E,SABID7
	REPEAT 6,JSP E,SACBD
	JSP E,SACBD6
	JSP E,SACBD7
	REPEAT 6,JSP E,SABDD
	JSP E,SABDD6
	JSP E,SABDD7
	REPEAT 7,JSP E,SACBX
	JSP E,SACBX7
	REPEAT 7,JSP E,SABXD
	JSP E,SABXD7

DEFINE SACBXX
	LSHC MA,-1
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JUMPGE X,(E)
	ADDI TIME,6
	LSH MB,-8
	JRST (E)
	TERMIN

SABPC:	HRRZ MB,PC
	LSH MB,1
	JRST (E)

SABRD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-10(T)
	SACBXX

SABRD7:	ADDI TIME,15.
	SKIPGE MB,PDP11(PC)
	JSP D,MTRAPR
	JRST (E)

SACBI:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-20(T)
	MOVEI TT,1(MA)
	ANDI TT,177777
	HRRM TT,R0-20(T)
	SACBXX

SACBI6:	ADDI TIME,15.
	HRRZ MA,R6
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R6
	SACBXX

SACBI7:	ADDI TIME,15.
	SKIPGE MB,PDP11(PC)
	JSP D,MTRAPR
	AOJA PC,(E)

SABID:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-30(T)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

SABID7:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	SACBXX

SACBD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-40(T)
	SOJGE MA,.+2
	MOVEI MA,177777
	HRRM MA,R0-40(T)
	SACBXX

SACBD6:	ADDI TIME,15.
	HRRZ MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	SACBXX

SACBD7:	ADDI TIME,15.
	SOSGE MA,PC
	JRST SABD72
SABD74:	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JRST(E)

SABD72:	MOVEI MA,77777
	MOVEI PC,77777
	JRST SABD74

SABDD:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-50(T)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
SBDD72:	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

SABDD6:	ADDI TIME,27.
	HRRZ TT,R6
	SUBI TT,2
	CAIGE TT,400
	JSP D,HPDLOV
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

SABDD7:	ADDI TIME,27.
	SOSL TT,PC
	JRST SBDD72
	MOVEI PC,77777
	MOVEI TT,77777
	JRST SBDD72

SACBX:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	ANDI T,77
	ADD MA,R0-60(T)
	TRZ MA,200000
	SACBXX

SACBX7:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP C,MTRAPR
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JUMPGE X,(E)
	ADDI TIME,6
	LSH MB,-8
	JRST (E)

SABXD:	ADDI TIME,39.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	ANDI T,77
	ADD TT,R0-70(T)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

SABXD7:	ADDI TIME,39.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

ODACBT:	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,DABRD
	JSP E,DABRD7
	REPEAT 6,JSP E,DACBI
	JSP E,DACBI6
	JSP E,DACBI7
	REPEAT 7,JSP E,DABID
	JSP E,DABID7
	REPEAT 6,JSP E,DACBD
	JSP E,DACBD6
	JSP E,DACBD7
	REPEAT 6,JSP E,DABDD
	JSP E,DABDD6
	JSP E,DABDD7
	REPEAT 7,JSP E,DACBX
	JSP E,DACBX7
	REPEAT 7,JSP E,DABXD
	JSP E,DABXD7

OD2CBT:	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,D2BRD
	JSP E,DABRD7
	REPEAT 6,JSP E,D2CBI
	JSP E,DACBI6
	JSP E,DACBI7
	REPEAT 7,JSP E,D2BID
	JSP E,DABID7
	REPEAT 6,JSP E,D2CBD
	JSP E,DACBD6
	JSP E,DACBD7
	REPEAT 6,JSP E,D2BDD
	JSP E,DABDD6
	JSP E,DABDD7
	REPEAT 7,JSP E,D2CBX
	JSP E,DACBX7
	REPEAT 7,JSP E,D2BXD
	JSP E,DABXD7

DEFINE DACBXX
	IDIVI MA,2
	JUMPE X,1(E)
	ADDI TIME,6
	JRST 1(E)
	TERMIN

DABRD:	ANDI I,77
D2BRD:	ADDI TIME,14.
	MOVE MA,R0-10(I)
	DACBXX

DABRD7:	ADD TIME,14.
	HRRZ MA,PC
	JRST (E)

DACBI:	ANDI I,77
D2CBI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
	MOVEI TT,1(MA)
	ANDI TT,177777
	HRRM TT,R0-20(I)
	DACBXX

DACBI6:	ADDI TIME,14.
	HRRZ MA,R6
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R6
	DACBXX

DACBI7:	ADDI TIME,14.
	MOVE MA,PC
	AOJA PC,(E)

DABID:	ANDI I,77
D2BID:	ADDI TIME,26.
	MOVE TT,R0-30(I)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DABID7:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	DACBXX

DACBD:	ANDI I,77
D2CBD:	ADDI TIME,14.
	MOVE MA,R0-40(I)
	SOJGE MA,.+2
	MOVEI MA,177777
	HRRM MA,R0-40(I)
	DACBXX

DACBD6:	ADDI TIME,14.
	HRRZ MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	DACBXX

DACBD7:	ADDI TIME,14.
	SOSL MA,PC
	JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	JRST (E)
	
DABDD:	ANDI I,77
D2BDD:	ADDI TIME,26.
	MOVE TT,R0-50(I)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
DBDD72:	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DABDD6:	ADDI TIME,26.
	HRRZ TT,R6
	SUBI TT,2
	CAIGE TT,400
	JSP D,HPDLOV
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DABDD7:	ADDI TIME,26.
	SOSL TT,PC
	JRST DBDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST DBDD72

DACBX:	ANDI I,77
D2CBX:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	ADD MA,R0-60(I)
	TRZ MA,200000
	DACBXX

DACBX7:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	IDIVI MA,2
	ADD MA,PC
	TRZ MA,100000
	JUMPE X,1(E)
	ADDI TIME,6
	JRST 1(E)

DABXD:	ANDI I,77
D2BXD:	ADDI TIME,38.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	ADD TT,R0-70(I)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DABXD7:	ADDI TIME,38.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DEFINE DACWXX
	LSHC MA,-1
	JUMPGE X,(E)
	JSP A,BOUNDE
	TERMIN

ODACWT:	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,DAWRD
	JSP E,DAWRD7
	REPEAT 7,JSP E,DACWI
	JSP E,DACWI7
	REPEAT 7,JSP E,DAWID
	JSP E,DAWID7
	REPEAT 6,JSP E,DACWD
	JSP E,DACWD6
	JSP E,DACWD7
	REPEAT 6,JSP E,DAWDD
	JSP E,DAWDD6
	JSP E,DAWDD7
	REPEAT 7,JSP E,DACWX
	JSP E,DACWX7
	REPEAT 7,JSP E,DAWXD
	JSP E,DAWXD7

OD2CWT:	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,D2WRD
	JSP E,DAWRD7
	REPEAT 7,JSP E,D2CWI
	JSP E,DACWI7
	REPEAT 7,JSP E,D2WID
	JSP E,DAWID7
	REPEAT 6,JSP E,D2CWD
	JSP E,DACWD6
	JSP E,DACWD7
	REPEAT 6,JSP E,D2WDD
	JSP E,DAWDD6
	JSP E,DAWDD7
	REPEAT 7,JSP E,D2CWX
	JSP E,DACWX7
	REPEAT 7,JSP E,D2WXD
	JSP E,DAWXD7

DAWRD:	ANDI I,77
D2WRD:	ADDI TIME,14.
	MOVE MA,R0-10(I)
	DACWXX

DAWRD7:	ADDI TIME,14.
	MOVE MA,PC
	JRST (E)

DACWI:	ANDI I,77
D2CWI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
	MOVEI TT,2(MA)
	ANDI 177777
	HRRM TT,R0-20(I)
	DACWXX

DACWI7:	ADDI TIME,14.
	MOVE MA,PC
	AOJA PC,(E)

DAWID:	ANDI I,77
D2WID:	ADDI TIME,26.
	MOVE TT,R0-30(I)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

DAWID7:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	DACWXX

DACWD:	ANDI I,77
D2CWD:	ADDI TIME,14.
	MOVE MA,R0-40(I)
	SUBI MA,2
	ANDI MA,177777
	HRRM MA,R0-40(I)
	DACWXX

DACWD6:	ADDI TIME,14.
	HRRZ MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	DACWXX

DACWD7:	ADDI TIME,14.
	SOSL MA,PC
	JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	JRST (E)

DAWDD:	ANDI I,77
D2WDD:	ADDI TIME,26.
	MOVE TT,R0-50(I)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
DWDD72:	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

DAWDD6:	ADDI TIME,14.
	HRRZ TT,R6
	SUBI TT,2
	CAIGE TT,400
	JSP D,HPDLOV
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

DAWDD7:	ADDI TIME,26.
	SOSL TT,PC
	JRST DWDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST DWDD72

DACWX:	ANDI I,77
D2CWX:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	ADD MA,R0-60(I)
	TRZ MA,200000
	DACWXX

DACWX7:	ADDI TIME,26.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	JUMPGE X,(E)
	JSP A,BOUNDE

DAWXD:	ANDI I,77
D2WXD:	ADDI TIME,38.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	ADD TT,R0-70(I)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

DAWXD7:	ADDI TIME,38.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

JD2CWT:	REPEAT 8,JSP A,ILLINS
	REPEAT 7,JSP E,D2WRD
	JSP E,DAWRD7
	REPEAT 7,JSP E,J2CWI
	JSP E,JACWI7
	REPEAT 7,JSP E,D2WID
	JSP E,DAWID7
	REPEAT 6,JSP E,D2CWD
	JSP E,DACWD6
	JSP E,DACWD7
	REPEAT 6,JSP E,D2WDD
	JSP E,DAWDD6
	JSP E,DAWDD7
	REPEAT 7,JSP E,D2CWX
	JSP E,DACWX7
	REPEAT 7,JSP E,D2WXD
	JSP E,DAWXD7

J2CWI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
	ADDI MA,2
	TRZ MA,200000
	HRRM MA,R0-20(I)
	DACWXX

JACWI7:	ADDI TIME,14.
	AOS MA,PC
	JRST (E)

DEFINE SACWXX
	LSHC MA,-1
	JUMPGE X,(E)
	JSP A,BOUNDE
	TERMIN

OSACWT:	REPEAT 7,MOVEI MA,R0-PDP11+.RPCNT
	JSP E,SAWPC
	REPEAT 7,JSP E,SAWRD
	JSP E,SAWRD7
	REPEAT 7,JSP E,SACWI
	JSP E,SACWI7
	REPEAT 7,JSP E,SAWID
	JSP E,SAWID7
	REPEAT 6,JSP E,SACWD
	JSP E,SACWD6
	JSP E,SACWD7
	REPEAT 6,JSP E,SAWDD
	JSP E,SAWDD6
	JSP E,SAWDD7
	REPEAT 7,JSP E,SACWX
	JSP E,SACWX7
	REPEAT 7,JSP E,SAWXD
	JSP E,SAWXD7

SAWPC:	HRRZ MB,PC
	LSH MB,1
	JRST 2(E)

SAWRD:	ANDI T,77
	ADDI TIME,15.
	MOVE MA,R0-10(T)
	SACWXX

SAWRD7:	ADDI TIME,15.
	MOVE MA,PC
	JRST (E)

SACWI:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-20(T)
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R0-20(T)
	SACWXX

SACWI7:	ADDI TIME,15.
	SKIPGE MB,PDP11(PC)
	JSP D,MTRAPR
	AOJA PC,2(E)

SAWID:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-30(T)
	MOVEI MA,2(TT)
	ANDI MA,177777
	TRZ MA,200000
	HRRM MA,R0-30(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACWXX

SAWID7:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	SACWXX

SACWD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-40(T)
	SUBI MA,2
	ANDI MA,177777
	HRRM MA,R0-40(T)
	SACWXX

SACWD6:	ADDI TIME,15.
	HRRZ MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	SACWXX

SACWD7:	ADDI TIME,15.
	SOSL MA,PC
	JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	JRST (E)

SAWDD:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-50(T)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
SWDD72:	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACWXX

SAWDD6:	ADDI TIME,27.
	HRRZ TT,R6
	SUBI TT,2
	CAIGE TT,400
	JSP D,HPDLOV
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACWXX

SAWDD7:	ADDI TIME,27.
	SOSL TT,PC
	JRST SWDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST SWDD72

SACWX:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	ANDI T,77
	ADD MA,R0-60(T)
	TRZ MA,200000
	SACWXX

SACWX7:	ADDI TIME,27.
	AOS TT,PC
	SKIPGE MA,PDP11-1(TT)
	JSP D,MTRAPR
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	JUMPGE X,(E)
	JSP A,BOUNDE

SAWXD:	ADDI TIME,39.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	ANDI T,77
	ADD TT,R0-70(T)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACWXX

SAWXD7:	ADDI TIME,39.
	AOS MA,PC
	SKIPGE TT,PDP11-1(MA)
	JSP D,MTRAPR
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACWXX

IIOT:	ADDI TIME,21.
	MOVEI T,4
	JSP A,TRPINS

I00003:	ADDI TIME,21.	;NAMELESS
	MOVEI T,3
	JSP A,TRPINS

IEMT:	ADDI TIME,21.
	MOVEI T,6
	JSP A,TRPINS

ITRAP:	ADDI TIME,21.
	MOVEI T,7
	JSP A,TRPINS

TTRAP:	MOVEI T,3	;TRACE TRAP
	JSP A,TVTRAP

LBUSER:	MOVE MA,[LBUSET-4,,LBUSET-8]
	BLT MA,LBUSET-1
	MOVE MA,OPC
	MOVEM MA,LBUSEP
	MOVE MA,@(P)
	MOVEM MA,LBUSEM
	MOVEM TIME,LBUSET
	MOVEM A,LBUSES
	JRST POPJ1

	BLOCK 8	;PREVIOUS ERRORS
LBUSET:	BLOCK 1
LBUSEP:	BLOCK 1
LBUSES:	BLOCK 1
LBUSEM:	BLOCK 1	;CLEARED AT CZTIME

CBUSS:	PUSH P,PC
	PUSH P,OPC
	MOVEI T,0
	PUSHJ P,CBUSSP
	JRST CBUNOE
	TTOA [ASCIZ /LAST/]
	MOVEI T,-4
	PUSHJ P,CBUSSP
	JRST CBUSSX
	TTOA [ASCIZ /PREVIOUS/]
	MOVEI T,-8
	PUSHJ P,CBUSSP
	JRST CBUSSX
	TTOA [ASCIZ /EARLIER/]
CBUSSX:	POP P,OPC
	TTOA [ASCIZ /CURRENT TIME: /]
	PUSHJ P,CTIME
	POP P,PC
	RETURN

CBUSSP:	SKIPN LBUSEM(T)
	RETURN
	AOS (P)
	XCT @(P)
	AOS (P)
	MOVE T2,LBUSEP(T)
	MOVEM T2,OPC
	TTOA [ASCIZ / BUSS ERR AT 
/]
	SKIPN DEBUGP
	JRST CBUSP2
	MOVE T2,LBUSES(T)
	MOVEM T2,QA
	TTOA [ASCIZ /SIM. PC. = A
/]
CBUSP2:	TTOA @LBUSEM(T)
	TTOA [ASCIZ /   TIME: /]
	MOVE T2,LBUSET(T)
	JRST CBUSS2

CBUNOE:	TTOA [ASCIZ /NO BUSS ERRORS
/]
	JRST CBUSSX

NXMNXM:	SUB P,[1,,1]		;NXM - THROW AWAY RET ADDR IN MTRAP.
	PUSHJ P,LBUSER
	[ASCIZ /TIME OUT/]
	JRST BUSSE

ILLINS:	PUSHJ P,LBUSER
	[ASCIZ /ILLEGAL INSTRUCTION/]
	JRST BUSSE	;ILLEGAL INSTRUCTION (JMP (JSR) %X)

BOUNDE:	PUSHJ P,LBUSER
	[ASCIZ /BOUNDARY ERROR/]
BUSSE:	SKIPE INVTRP
	JRST TRPBDE
	SKIPA T,[600000,,1]	;BUS ERROR (SETZ FOR HPDLOV TEST)
IILL:	MOVEI T,2	;RESERVED INSTRUCTION
TRPINS:	PUSHJ P,TTPDFL
	JRST VTRAP

TVTRAP:	PUSHJ P,PDLFLS
VTRAP:	SKIPE WAITFL
	AOJA PC,VTRAPW	;FINSH A WAIT INSN.
VTRAP0:	SKIPE B,TRPPNT(T)
	PUSHJ P,VTRPPT
	SETOM INVTRP
	ADDI TIME,72.
	HRRZ MA,R6
	SUBI MA,2
	CAIGE MA,400
	JSP D,HPDLOV
	ANDI MA,177777
	LSHC MA,-1
	JUMPL X,BOUNDE
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM PS,PDP11(MA)
	SOS MA
	CAIGE MA,200
	JSP D,HPDLOV
	ANDI MA,77777
	LSH MA,1
	HRRM MA,R6
	LSH MA,-1
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM PC,PDP11(MA)
	ADDM PC,PDP11(MA)
	AOSN ODDPC
	AOS PDP11(MA)
	LSH T,1
	SKIPGE PDP11(T)
	JSP D,MTRAPR
	MOVE PC,PDP11(T)
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
	AOS T
	SKIPGE PS,PDP11(T)
	JSP D,MTRAPR
	NEWPS
	SETZM INVTRP
	SETZM DDONXT		;STOP IGNORING MTRAPI.
VTRAP4:	MOVSI T,1
	CAML T,@TRINF+1
	JRST INBEG	;ALWAYS EXECUTE FIRST INST OF TRAP ROUTINE
	MOVE B,TRINF+1
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,TRINF+1
	XCT 2(B)
	JRST VTRAP4

VTRAPW:	SETZM WAITFL
	SOS INSCNT
	JRST VTRAP0

VTRPPT:	SOJE B,VTRPP3
	CRF
VTRPP1:	HRRZM A,QT
	LSH T,2
	MOVEM T,QA
	LSH T,-2
	TTOA [ASCIZ /TRAP THROUGH A FROM 
/]
	SKIPE DEBUGP
	TTOA [ASCIZ/SIM. PC. =T
/]
VTRPP2:	CAIL B,2
	JRST CLRRUN
	RETURN

BRPNT:	SOJE B,VTRPP3
	MOVEM PC,QA
	ADDM PC,QA
	TTOA [ASCIZ /
BRANCH:   -->  A
/]
	JRST VTRPP2

VTRPP3:	MOVE B,OPC		;MODE 1 -- JUST SAVE ADDR OF TRAP.
	LSH B,1
	HRRM B,%JPC
	RETURN

CDEBUG:	SETCMB A,DEBUGP
	SKIPL A
	TTOA 1,[ASCIZ/OFF
/]
	TTOA [ASCIZ/ON
/]
	RETURN

DEBUGP:	0

;BUS ERROR IN PROCESSING TRAP
TRPBDE:	TTOA	[ASCIZ/
BUSS ERROR IN /]
	MOVEI B,2
	PUSHJ P,VTRPP1
	SETZM INVTRP
	PUSHJ P,TTPDFL
DIEDIE:	PUSHJ P,CLRRUN
	JRST INEND

HPDLOV:	SKIPL PDLTRB+1
	JRST (D)	;ALREADY SPRUNG
	SKIPE INVTRP
	CAIE T,1
	JRST .+2
	JRST (D)	;ALREADY TRAPPED
	MOVEM D,PDLOV.
	MOVEI A,PDLTRB
	MOVSI C,3
	PUSH P,T
	PUSHJ P,TRQADD
	POP P,T
	JRST (D)

PDLTRB:	0
	-1
	JRST .+1
	MOVE A,PDLOV.
	PUSHJ P,LBUSER
	[ASCIZ /STACK OVERFLOW/]
	MOVEI T,1
	JRST VTRAP


PDLOV.:	0
ODDPC:	0
	
TTPDFL:	SKIPL TTRPBK+1	;FLUSH TRACE TRAP IF PENDING
	JRST TTPD2
PDLFLS:	SKIPL PDLTRB+1	;FLUSH PDL OV IF PENDING
	JRST PDLFL2
	RETURN

TTPD2:	BLKFLS TTRPBK
	PDLTRB,,0
	RETURN

PDLFL2:	BLKFLS PDLTRB
	0
	RETURN

;WORD IN MEM
;4.9=0 => NO HACKS
;4.9=1
 ;4.8=0 BREAK ONLY
 ;4.7=0,1 DO, DON'T  STOP AFTER MESS
  ;4.1=1 TRAP ON FETCH & TURN THIS BIT OFF.
  ;4.2=1 TRAP ON DIRECT TO MEM DEV WRITE
  ;4.3=1 TRAP ON DIRECT TO MEM DEV READ
  ;4.4=1 TRAP ON INST REF
  ;4.5=1 TRAP ON WRITE
  ;4.6=1 TRAP ON READ (BUT NOT INST)
 ;4.8=1 I/O DEV + POSSIBLE BREAK
;3.1-3.9 DEVICE INDEX

DEVPOS=221100
MARPOS=340600

MTRAPI:	HRLZI B,11000	;INSTRUCTION
	JRST MTRAP

MTRPW:	HRLZI B,60000	;READ-PAUSE-WRITE
	JRST MTRAP

MTDMRW:	SKIPA	B,[6000,,1]
NGMTRW:	MOVE	B,[6000,,2]
	JRST	MTRAP

MTRPDF:	MOVE	B,[4000,,3]
	SKIPN	MODDSK		;IF WRITING,
	TLC	B,6000		;SAY WRITE INSTEAD OF READ.
	JRST	MTRAP

MTRRKR:	SKIPA B,[4000,,5]
MTRRKW:	MOVE B,[2000,,5]
	JRST MTRAP

MTDMRD:	SKIPA	B,[4000,,1]
MTDMWR:	MOVE	B,[2000,,1]
	JRST	MTRAP

MTETRD:	SKIPA	B,[4000,,4]
MTETWR:	MOVE	B,[2000,,4]
	PUSH	P,D		;RSTALL WILL POPJ THIS.
	CALL	SAVALL
	MOVE	A,ETDRIV	;SAVE B'S REAL CONTENTS
	MOVEM	A,B-SAVLNG(P)
	JSP	D,MTRAP
	JRST	RSTALL		;MTRAP WILL COME BACK HERE.

MTRDVT:	SIXBIT/DM/
	SIXBIT/NGDIS/
	SIXBIT/DF/
	SIXBIT/DT/
	SIXBIT /RK/
MTDVTL==.-MTRDVT

MTRAPW:	SKIPA B,[20000,,]	;WRITE
MTRAPR:	HRLZI B,40000	;READ
MTRAP:	MOVE A,@-2(D)
	TLNE A,200000
	JRST MTRDEV
MTRAP1:	SKIPN DDTPDP
	TLNN A,77000
	JRST MTRAPX
	HLR A,A		;SEE IF THIS REFERENCE SHOULD BREAK.
	TLNN B,(A)
	JRST MTRAPX		;IF NOT.
	TLNE B,1000		;IF TRIPPING AN AUTOFLUSH, STOP BEFORE INSN.
	JRST MTRIPT
	TLNE A,100000		;IF STOPPING BREAKPOINT,
	JRST MTRAP6
	TLNE B,10000		;IF INSN FETCH, STOP BEFORE INSN.
	JRST MTRIPT
MTRAP2:	PUSHJ P,CLRRUN		;ELSE STOP AFTER INSN.
MTRAP6:	SKIPE TYOFLG		;DON'T TAKE LOTS OF TIME IF TYPEOUT OFF.
	PUSHJ P,MTRPNT		;TYPE BREAKPOINT MESSAGE.
MTRAPX:	MOVE A,@-2(D)
	LDB B,[270400,,-2(D)]
	SKIPE B
	HRRZM A,(B)
	JRST (D)

MTRIPT:	SKIPN WAITFL
	SKIPE DDONXT		;DO NOTHING IF JUST LEFT DDT.
	JRST MTRAPX
	TLNN A,10000		;IF ONLY WAS AUTOFLUSH,
	TTOA 1,[ASCIZ/
BREAK(F):  /]			;SAY BREAK IS REMOVED.
	TTOA [ASCIZ/
BREAK:  /]			;ELSE NORMAL MSG.
	TLZ A,1000		;CLEAR ANY AUTOFLUSH BREAK.
	TLNN A,377000		;IF THAT WAS ONLY HACK,
	TLZ A,400000		;INDICATE NO HACKS.
	HLLM A,@-2(D)
	MOVEI A,(PC)
	LSH A,1
	HRRM A,%B
	PUSHJ P,CLRRN2		;CALL DDT RIGHT AWAY,
	JRST INBEG		;START INSN OVER.

MTRDEV:	LDB C,[DEVPOS,,A]	;DEVICE
	CAIL C,MAXDEV
	.VALUE		;?
	PUSHJ P,@MDEVTB(C)	;CALL DEVICE
	MOVE A,@-2(D)
	JRST MTRAP1

NXMHAK:	TRNE B,-1
	JRST NXMTKD	;SOME DIRECT TO MEM DEVICE
	SKIPN DDTPDP
	JSP A,NXMNXM
	TLNN B,20000	;DON'T TYPE ON WRITING.
	TTOA [ASCIZ /NXM? /]
	RETURN

NXMTKD:	XCT NXMDVT-1(B)
	JRST MTRAP1

NXMDVT:	JRST NXMDML	;DM
	JRST NGRNXM	;NGDIS
	JRST NEMLOS	;DSK NXM
	JRST ETNXM0
	JRST RKNXM0
IFN .-NXMDVT-MTDVTL,[PRINTX /NXMDVT .NE. MTRDVT
/]
MTRPNT:	TTOA	[ASCIZ /
BREAK: /]
	PUSHJ	P,SAVALL
	SKIPL	DDTPDP
	AOS	DDTPDP
	HRLZ	SF,%TMODE
	MOVE	B,B-SAVLNG(P)
	MOVEI	DO,@-2(D)	;ADDR. OF BREAKPOINT.
	TRNE	B,-1		;IF REFERENCE WAS BY A DEVICE,
	6TYPE	MTRDVT-1(B)	;PRINT ITS NAME.
	TRNE	B,-1
	TTOI	" 
MTRPN3:	TLNE	B,10000
	JRST	MTRPN4		;SPECIAL ACTION FOR FETCH BREAK.
	TLNE	B,44000
	TTOI	"R
	TLNE	B,22000
	TTOI	"W
	TTOA	[ASCIZ /  /]
	MOVEI	DL,-PDP11(DO)
	LSH	DL,1		;VIRT. ADDR. OF BREAKPOINT.
	ADRTYP	DL
	HRRM	DL,%B		;STORE AS ADDR OF LAST BREAKPOINT.
	TTOA	[ASCIZ ./ .]
	HRRZ	DL,(DO)		;GET WORD'S CONTENTS, CLEAR FLAGS.
	SYMTYP	DL		;PRINT CONTENTS OF WORD WITH BKPT.
	TTOA	[ASCIZ/
FROM: 
/]
MTRPN2:	SKIPL	DDTPDP
	SOS	DDTPDP
	JRST	RSTALL

MTRPN4:	TTOA	[ASCIZ/I  %OPC]
FROM: /]
	MOVEI	DL,(PC)
	LSH	DL,1		;ADDR. OF BREAKPOINT.
	HRRM	DL,%B
	CALL	DPINSN		;PRINT BREAKING INSN.
	CRF
	JRST	MTRPN2

MDEVTB:	IRP X,,[NXM,CSX,CPAT]	;THE POSITION OF THESE ENTRIES
	N!X==.-MDEVTB
	X!HAK
TERMIN		;MUST NOT BE CHANGED, SINCE THEY ARE IN DUMP FILES.

IRP X,,[PS,PC,SWR,PIR,LKS,TKS,TKB,TPS,TPB
PRS,PRB,PPS,PPB,DIV,MQ,MUL,NOR,LGS,ARS
DCS,CMA,DAE,ADS,PKC,CSR,BAR,BCR,TBR,LPS,LPB]
	N!X==.-MDEVTB
	X!HAK
TERMIN

IRP X,,[SCSR,RCSR,RBUF,TSCR,TBUF,TCCM,TCST
RKDS,RKER,RKCS,RKBA]
	N!X==.-MDEVTB
	X!HK
TERMIN
IRP X,,[PKCSR,PKCSB,NGCSR]
	N!X==.-MDEVTB
	X!K
TERMIN

MAXDEV==.-MDEVTB

;PROCESSOR STATUS REGISTER
PSHAK:	SKIPE DDTPDP
	RETURN		;DO NOTHING IN DDT.
	ANDI PC,77777
	HRRM PS,RPS
	TLNN B,20000
	RETURN
	JSP A,MTRNEW
	10,,
	-1
	PUSHJ P,PSHTRP

MTRNEW:	SKIPL 1(A)
	RETURN
	PUSH P,T
	PUSH P,B
	PUSHJ P,TRQQA
	POP P,B
	POP P,T
	RETURN

MTRDES:	PUSH P,T
	PUSH P,B
	PUSHJ P,TRQADD
	POP P,B
	POP P,T
	RETURN

PSHTRP:	HRRZ PS,RPS
	NEWPS
	RETURN

;PROGRAM COUNTER REGISTER
PCHAK:	SKIPE DDTPDP
	RETURN
	TLNN  B,50000
	JRST PCHAKW
	HRRM PC,R7
	ADDM PC,R7
PCHAKW:	TLNN B,20000
	RETURN
	JSP A,MTRNEW
	7,,
	-1
	JRST PCTRP

PCTRP:	HRRZ PC,R7
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
	SKIPE B,TRPPNT
	PUSHJ P,BRPNT
	JRST INEND

;LINE FREQUENCY CLOCK
LKSHAK:	TLNN B,54000
	RETURN
	ANDI A,100
	AOSN CLOCK
	TRO A,200
	HRRM A,RLKS
	RETURN

CLOCK:	0
WLK:	-1
LKTIM:	166667.

CLKSBK:	0
	-1
	PUSHJ P,.+1
	.SUSET [.RRUNT,,A]
	SUB A,RUNTB
	MOVE B,TIME
	IDIVI B,40.
	IDIV A,B
	HRRM A,RATE
	JRST CLKTR2

ALK:	JUMPE T5,ZLK2	;ATTACH LINE CLOCK
	MOVE A,[10000000.]	;ARG=CYCLES/SEC
	IDIV A,T5
	MOVEM A,LKTIM
ZLK2:	SKIPE WLK
	PUSHJ P,DLK
	PUSHJ P,WRDINS
	600000+NLKS,,RLKS
	0
	SETOM WLK
	SKIPA C,TIME
CLKTR2:	MOVE C,CLKSBK
	ADD C,LKTIM
	MOVEI A,CLKSBK
	PUSHJ P,CTRDES
	SETOM CLOCK
	LDB A,[60100,,RLKS]
	JUMPE A,CPOPJ
	JSP A,MTRNEW
LKSBK2:	6
	-1
	JRST .+1
	MOVEI T,20
	JSP A,VTRAP

DLK:	BLKFLS CLKSBK	;DETACH LINE CLOCK
	LKSBK2,,0
	SETZM WLK
	PUSHJ P,WRDZAP
	RLKS,,RLKS
	RETURN

ZLK:	SKIPN WLK
	RETURN
	JRST ZLK2

ATK:	JUMPE T5,ZTK	;ATTACH TELETYPE KEYBOARD
	MOVE A,[1000000.]
	IDIV A,T5
	MOVEM A,TKTIM
ZTK:	SKIPE WTK
	PUSHJ P,DTK
	PUSHJ P,WRDINS
	600000+NTKS,,RTKS
	600000+NTKB,,RTKB
	0
	SETOM WTK
	SETZM TKDONE
	SETZM TKBUSY
	RETURN

DTK:	BLKFLS CTKSBK	;DETACH TELETYPE KEYBOARD
	TKSBK2,,0
	SETZM WTK
	PUSHJ P,WRDZAP
	RTKS,,RTKB
	RETURN

TKSHAK:	TLNN B,54000
	JRST TKSWRT
	ANDI A,100
	SKIPE TKDONE
	IORI A,200
TKSHA4:	SKIPE TKBUSY
	TRO A,4000
	HRRM A,RTKS
TKSWRT:	TLNN B,22000
	RETURN
	 XXWAIT TKSINT

TKBHAK:	SKIPE TKDONE
	TLNN B,54000
	RETURN
	SETZM TKDONE
	RETURN

TKB224:	SETOM TKBUSY
	MOVEI A,CTKSBK
	MOVE C,TIME
	ADD C,TKTIM
	MOVEM C,CTKSBK
	SKIPN QFLAG
	JRST CTRDES
	 XXWAIT TKB224
	;FROM INTERRUPT OUT OF HACKING CLOCK QUEQUE

CTKTRP:	SETZM TKBUSY
	.STATUS TYIC,A	;REALLY HAVE A CHAR?
	TRNE A,2000
	JRST TKSINT
	PUSH P,MB
	PUSHJ P,TYI1	;YES, READ IT.
	HRRM MB,RTKB
	POP P,MB
	SETOM TKDONE
	PUSHJ P,TKB224	;CHECK FOR ANOTHER.
TKSINT:	MOVEI A,TKSBK2
	SKIPN TKDONE
	JRST QDEL
	LDB B,[60100,,RTKS]
	JUMPE B,QDEL
	JRST MTRNEW

TKSBK2:	4
	-1
	JRST .+1
	MOVEI T,14
	JSP A,VTRAP

TKTIM:	1000.
TKDONE:	0
TKBUSY:	0
WTK:	-1

CTKSBK:	0
	-1
	PUSHJ P,CTKTRP

ATP:	JUMPE T5,ZTP	;ATTACH TELETYPE PRINTER
	MOVE A,[1000000.]
	IDIV A,T5
	MOVEM A,TPTIM
ZTP:	SKIPE WTP
	PUSHJ P,DTP
	PUSHJ P,WRDINS
	600000+NTPS,,RTPS
	600000+NTPB,,RTPB
	0
	SETOM WTP
	SETOM TPREDY
	RETURN

DTP:	BLKFLS CTPBBK	;DETACH TELETYPE PRINTER
	TPSBK2,,0
	SETZM WTP
	PUSHJ P,WRDZAP
	RTPS,,RTPB
	RETURN

TPSHAK:	TLNN B,54000
	JRST TPSHK2
	ANDI A,104
	SKIPE TPREDY
	TRO A,200
	HRRM A,RTPS
TPSHK2:	TLNN B,22000
	RETURN
	 XXWAIT
CTPTR2:	MOVEI A,TPSBK2
	SKIPN TPREDY
	JRST QDEL
	LDB C,[60100,,RTPS]
	JUMPE C,QDEL
	JRST MTRNEW

TPSBK2:	4
	-1
	JRST .+1
	MOVEI T,15
	JSP A,VTRAP

TPBHAK:	HLLZS RTPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPN TPREDY
	RETURN	;DATA LOST
	SETZM TPREDY
	HRRZ C,RTPB
	TTOI (C)
	MOVE C,TIME
	ADD C,TPTIM
	MOVEI A,CTPBBK
CTRDES:	PUSH P,T
	PUSH P,B
	PUSHJ P,CLQADD
	POP P,B
	POP P,T
	RETURN

CTPBBK:	0
	-1
	PUSHJ P,CTPTRP

CTPTRP:	SETOM TPREDY
	JRST CTPTR2

TPTIM:	900.
TPREDY:	-1
WTP:	-1

APRA:	TDZA T5,T5
APRI:	MOVEI T5,4
	HRLM T5,PTRFIL
	MOVEI A,PTRFIL	;ATTACH PAPER TAPE READER
	PUSHJ P,DGFIL
	SKIPE WPR
	PUSHJ P,DPR
	MOVEI A,PTRFIL
APR1:	CALL GETCHP	;GET CHANNEL & OPEN.
	HRRZM C,PRCHAN	;REMEMBER WHAT CHANNEL.
ZPR:	PUSHJ P,WRDINS
	600000+NPRS,,RPRS
	600000+NPRB,,RPRB
	0
	BLKFLS PRCQB
	PRSBK2,,
	SETZM PRDONE
	SETZM PRERR
	SETZM PRBUSY
	SETZM PRCHAR
	SETOM WPR
	RETURN

PTRFIL:	SIXBIT/   DSKPTR   INPUT/

APR:	SKIPE WPR
	PUSHJ P,DPR
	MOVEI A,[SIXBIT/  (PTRPTR   INPUT/]
	JRST APR1

DPRI:DPRA:
DPR:	BLKFLS PRCQB	;DETACH PAPER TAPE READER
	PRSBK2,,0
	PUSHJ P,WRDZAP
	RPRS,,RPRB
	SETZM WPR
DPR1:	SKIPGE C,PRCHAN
	 RET		;CHANNEL ALREADY FREED.
	SETOM PRCHAN
	JRST CLOSEC	;ELSE FREE IT.

PRSHAK:	TLNN B,54000
	JRST PRSWRT
	ANDI A,100
	SKIPE PRDONE
	TRO A,200
	SKIPE PRBUSY
	TRO A,4000
	SKIPE PRERR
	TRO A,100000
	HRRM A,RPRS
PRSWRT:	TLNN B,22000
	RETURN
	XXWAIT
	SKIPE PRERR
	JRST 
	LDB C,[100,,RPRS]
	JUMPE C,PRTRAP
	SETZM PRCHAR
	SETOM PRBUSY
	MOVEI A,PRCQB
	MOVE C,TIME
	ADD C,PRTIM
	PUSHJ P,CTRDES
PRTRAP:	MOVEI A,PRSBK2
	SKIPN PRERR
	SKIPE PRDONE
	SKIPA
	JRST QDEL
	LDB C,[60100,,RPRS]
	JUMPE C,QDEL
	JRST MTRNEW
PRSBK2:	4
	-1
	JRST .+1
	MOVEI T,16
	JSP A,VTRAP

PRBHAK:	MOVE A,PRCHAR
	HRRM A,RPRB
	TLNE B,54000
	SETZM PRDONE
	RETURN

PRCQB::	0
	-1
	PUSHJ P,PRCTRP

PRCTRP:	SETZM PRBUSY
	SETOM PRDONE
	SYSCL IOT,[PRCHAN ? C]
	IOCGET JFCL
	 CAIA
	JUMPGE C,PRCTR1
	CALL DPR1	;DON'T REALLY NEED CHANNEL ANY MORE.
	SETOM PRERR	;END OF TAPE
PRCTR1:	HRRM C,PRCHAR
	JRST PRTRAP

WPR:	0
PRDONE:	0
PRBUSY:	0
PRERR:	0
PRCHAR:	0
PRCHAN:	-1	;PR CHANNEL OR -1 IF NONE ALLOC'D.
PRTIM:	60.

APP:	SKIPE WPP	;DETACH FIRST IF ALREADY ATTACHED.
	CALL DPP
	MOVEI A,[SIXBIT/  )PTPPTP   OUTPUT/]
	JRST APP1

APPA:	SKIPA T5,[1]	;ASCII TAPE PUNCH, MODE 1.
APPI:	MOVEI T5,5	;IMAGE TAPE PUNCH, MODE 5.
	HRLM T5,PTPFIL
	MOVEI A,PTPFIL	;ATTACH PAPTER TAPE PUNCH
	PUSHJ P,DGFIL
	SKIPE WPP
	PUSHJ P,DPP
	MOVEI A,PTPFIL
APP1:	CALL GETCHP	;GET CHANNEL & OPEN ON IT.
	HRRZM C,PPCHAN
ZPP:	PUSHJ P,WRDINS
	600000+NPPS,,RPPS
	600000+NPPB,,RPPB
	0
	BLKFLS PPCQB
	PPSBK2,,0
	SETOM PPDONE
	SETZM PPERR
	SETOM WPP
	RETURN

PTPFIL:	SIXBIT /   DSK/
	SIXBIT/PTP   OUTPUT/

DPPA:DPPI:
DPP:	BLKFLS PPCQB	;DETACH PAPER TAPE PUNCH
	PPSBK2,,0
	PUSHJ P,WRDZAP
	RPPS,,RPPB
	SETZM WPP
	SKIPGE C,PPCHAN
	 RET		;NO CHANNEL ALLOCATED.
	SETOM PPCHAN	;ELSE FREE IT.
	JRST CLOSEC

PPSHAK:	TLNN B,54000
	JRST PPSWRT
	ANDI A,100
	SKIPE PPDONE
	TRO A,200
	SKIPE PPERR
	TRO A,100000
	HRRM A,RPPS
PPSWRT:	TLNN B,22000
	RETURN
	 XXWAIT PPSTRP

WPP:	0
PPDONE:	0
PPERR:	0
PPTIM:	300.
PPCHAN:	-1	;-1, OR CHANNEL BEING USED BY PP.

PPCTRP:	SETOM PPDONE
PPSTRP:	MOVEI A,PPSBK2
	SKIPN PPDONE
	SKIPE PPERR
	JRST .+2
	JRST QDEL
	LDB C,[60100,,RPPS]
	JUMPE C,QDEL
	JRST MTRNEW
PPSBK2:	4
	-1
	JRST .+1
	MOVEI T,17
	JSP A,VTRAP

PPBHAK:	HLLZS RPPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SETZM PPDONE
	PUSHJ P,PPSTRP
	SYSCL IOT,[PPCHAN ? RPPB]
	 IOCGET JFCL
	 SETOM PPERR
	ADD C,PPTIM
	JSP A,CTRDES
PPCQB:	0
	-1
	PUSHJ P,PPCTRP

ZLP:	SKIPN WLP
	POPJ P,
ALP:	SKIPE WLP	;ATTACH LINE PRINTER
	PUSHJ P,DLP
	MOVEI A,LPTFIL
	PUSHJ P,DGFIL
	PUSHJ P,OPNLPT
	PUSHJ P,WRDINS
	600000+NLPS,,RLPS
	600000+NLPB,,RLPB
	0
	SETOM WLP
	SETOM LPDONE
	SETZM LPERR
	RETURN

DLP:	PUSHJ P,WRDZAP	;DETACH LINE PRINTER
	RLPS,,RLPB
	BLKFLS LPBTIM
	LPSBRK,,0
	SETZM WLP
CLSLPT:	SOSG LPTCNT
	.CLOSE LPTC,
	RETURN

LPBHAK:	HLLZS RLPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPN LPDONE
	RETURN
	SETZM LPDONE
	PUSHJ P,LPSINT
	.IOT LPTC,A
	 IOCGET SETOM LPERR
	HRRM A,RLPB
	MOVE C,TIME
	ADD C,LPTIM
	JSP A,CTRDES
LPBTIM:	.
	-1
	PUSHJ P,.+1
	SETOM LPDONE
	JRST LPSINT

LPSHAK:	TLNN B,54000
	JRST LPSWRT
	ADDI A,100
	SKIPE LPDONE
	TRO A,200
	SKIPE A,LPERR
	TRO A,100000
	HRRM A,RLPS
	TLNN B,22000
	RETURN
LPSWRT:	 XXWAIT
LPSINT:	MOVEI A,LPSBRK
	SKIPN LPDONE
	JRST QDEL
	LDB B,[60100,,RLPS]
	JUMPE B,QDEL
	JRST MTRNEW

LPSBRK:	4
	-1
	JRST .+1
	MOVEI T,40
	JSP A,VTRAP

WLP:	0
LPDONE:	0
LPERR:	0
LPTIM:	60.

;CONSOLE DATA SWITCHES REGISTER
SWRHAK:	SKIPN DDTPDP
	TLNN B,20000
	RETURN
	MOVE A,RSWR
	MOVEM A,SWR
	 XXWAIT
	MOVE A,SWR
	HRRM A,RSWR
	RETURN

SWR:	0

;SOME PDP11/45 FEATURES
WI45:	0

DI45:	BLKFLS PIRBLK
	0
	PUSHJ P,WRDZAP
	RPIR,,RPIR
	SETZM WI45
	RETURN

AI45:	PUSHJ P,DI45
	PUSHJ P,WRDINS
	600000+NPIR,,RPIR
	0
	SETOM WI45
	RETURN

PIRHAK:	TLNN B,22000	;PROGRAMMED INTERRUPT
	RETURN
	 XXWAIT
	MOVEI A,PIRBLK
	PUSHJ P,QDEL
	HRRZ B,RPIR
	TRZ B,777
	HRRM B,RPIR
	JFFO B,.+2
	RETURN
	SUBI C,27.	;GET NEG OF PRIORITY
	MOVNS C
	DPB C,[10300,,RPIR]
	DPB C,[50300,,RPIR]
	JSP A,MTRDES
PIRBLK:	0
	-1
	JRST .+1
	MOVEI A,PIRBLK
	PUSHJ P,MTRNEW
	MOVEI T,50
	JSP A,VTRAP

;   THE EAE
AEAE:	PUSHJ P,WRDINS
	IRPS X,,[DIV,MQ,MUL,SCSR,NOR,LGS,ARS]
	600000+N!X,,R!X
	TERMIN
	0,,RAC
	0
	SETOM WEAE
	RETURN

DEAE:	PUSHJ P,WRDZAP
	RDIV,,RARS
	SETZM WEAE
	RETURN

;SET WORD IN RANGE TO NXM
;	PUSHJ P,WRDZAP
;	FROM,,TO	;INCLUSIVE
;
WRDZAP:	HLRZ A,@(P)	;SET WORDS TO NXM
	HRRZ B,@(P)
	SUBM A,B
	SOS B
	HRL A,B
	MOVSI B,600000
WRDZP2:	LDB C,[MARPOS,,(A)]
	MOVEM B,(A)
	DPB C,[MARPOS,,(A)]
	AOBJN A,WRDZP2
POPJ1:	AOS (P)
	RETURN

DIVHAK:	HLLZS RDIV
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RMQ
	LSH A,2
	HRL A,RAC
	TLNE A,100000
	TLO A,600000
	HRRZ C,RDIV
	LSH C,2
	TRNE C,400000
	TLO C,-1
	JFCL 17,.+1
	IDIV A,C
	ASH B,-2
	MOVEI C,3
	SKIPL A
	MOVEI C,0
	DPB C,[160200,,SCSR]
	DPB A,[2000,,RMQ]
	DPB B,[2000,,RAC]
	JFCL 10,DIVOVF
	MOVMS A
	CAIGE A,20000
	RETURN
DIVOVF:	TRC C,2
	DPB C,[160200,,SCSR]
	RETURN

MQHAK:	TLNN B,22000
	RETURN
	 XXWAIT
	MOVE A,RMQ	;EXTEND SIGN INTO AC
	TRNN A,100000
	JRST MQTRP2
	MOVEI A,177777
	HRRM A,RAC
	RETURN

MQTRP2:	HLLZS RAC
	RETURN

MULHAK:	HLLZS RMUL
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RMQ
	LSH A,2
	TRNE A,400000
	TLO A,-1
	HRRZ C,RMUL
	LSH C,2
	TRNE C,400000
	TLO C,-1
	IMUL A,C
	MOVEI C,3
	SKIPL A
	MOVEI C,0
	DPB C,[160200,,SCSR]
	LSH A,-2
	HLRM A,RAC
	LSH A,-2
	DPB A,[2000,,RMQ]
	RETURN

SCSRHK:	TLNN B,54000
	JRST SCSRH2
	HRRZ C,SCSR
	TRZ C,37000
	HRRZ A,RMQ
	TRNN A,177777
	TRO C,6000	;MQ=0 (ALSO SET AC=MQ=0)
	HRRZ B,RAC
	TRCN B,177777
	TRO C,10000	;AC=0
	TRNN B,177777
	TRO C,20000	;AC=-1
	TRNN C,10000
	TRZ C,2000	;TURN OFF AC=MQ=0
	TRNN A,100000
	TRNN C,10000
	SKIPA
	TRO C,1000	;SINGLE PRECISION
	TRNE A,100000
	TRNN C,20000
	SKIPA
	TRO C,1000	;"
	HRRM C,RSCSR
SCSRH2:	TLNN B,22000
	RETURN
	 XXWAIT
	MOVE A,RSCSR
	ANDI A,140477
	HRRM A,SCSR
	RETURN

SCSR:	0
WEAE:	-1

LGSHAK:	HLLZS RLGS
	TLNN B,22000
	RETURN
	 XXWAIT LGSTRP

ARSHAK:	HLLZS RARS
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPA C,RARS
LGSTRP:	HRRZ C,RLGS
	TRNE C,100000
	TRO C,600000
	HRRZ B,RMQ
	LSH B,2
	HRL B,RAC
	LSH B,2
	AND C,[400000,,77]
	TRNE C,40
	TRO C,777700
	SKIPGE C
	SKIPL B
	TDZA A,A
	MOVNI A,1
	JFCL 17,.+1
	SKIPL C
	LSHC A,(C)
	SKIPGE C
	ASHC A,(C)
	TRNE C,400000
	LDB A,[30100,,B]
	TRNN C,400000
	ANDI A,1
	DPB A,[80100,,SCSR]	;LAST BIT SHIFTED OUT
	MOVEI A,1
	SKIPL B
	SOJA A,ARLGPS
	DPB A,[160100,,SCSR]
	JFCL 10,[SOJA A,.+1]
	DPB A,[170100,,SCSR]
ARLGPT:	LSH B,-2
	HLRM B,RAC
	LSH B,-2
	DPB B,[2000,,RMQ]
	MOVE A,SCSR
	TRZ A,77
	HRRM A,SCSR
	RETURN

ARLGPS:	DPB A,[160100,,SCSR]
	JFCL 10,[AOJA A,.+1]
	DPB A,[170100,,SCSR]
	JRST ARLGPT

NORHAK:	MOVE A,SCSR
	ANDI A,77
	HRRM A,RNOR
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ B,RMQ
	LSH B,2
	HRL B,RAC
	LSH B,2
	JUMPE B,NORZRO
	CAMN B,[-1,,777760]
	JRST NORMON
	CAMN B,[777774,,]
	JRST NORHLF
	TDZA C,C
NORLUP:	LSHC A,1
	TLNN B,400000
	JRST NORTR2
	TLNE B,200000
	AOJA C,NORLUP
NORTR4:	MOVE I,SCSR
	TRZ I,77
	TRO I,(C)
	HRRM I,SCSR
	ANDI A,1
	DPB A,[80100,,SCSR]
	MOVEI A,3
	SKIPL B
	MOVEI A,0
	DPB A,[160200,,SCSR]
	LSH B,-2
	HLRM B,RAC
	LSH B,-2
	DPB B,[2000,,RMQ]
	RETURN

NORTR2:	TLNN B,200000
	AOJA C,NORLUP
	JRST NORTR4

NORZRO:	MOVEI C,31.
	MOVEI A,0
	JRST NORTR4

NORMON:	SKIPA C,[30.]
NORHLF:	MOVEI C,30.-16.
	MOVSI A,600000
	JRST NORTR4

ANULDI:	PUSHJ P,DNGDIS
	PUSHJ P,BLKGET
	600000,,RNGCSR
	PUSHJ P,WRDINS
	0,,RNGCSR
	0,,RNGREL
	0
	POPJ P,

DNULDI:	PUSHJ P,BLKZAP
	RNGCSR
	POPJ P,


;NG DISPLAY

ANGDIS:	SKIPE WNGDIS
	PUSHJ P,DNGDIS
	.DSTART NULDIS
	JRST DISLOS
	PUSHJ P,BLKGET
	600000,,RNGCSR
	PUSHJ P,BLKGET
	NGBLK
	PUSHJ P,BLKGET
	NGBLK+2000
	PUSHJ P,WRDINS
	600000+NNGCSR,,RNGCSR
	0,,RNGREL
	0
	SETOM WNGDIS
	SETZM NGSTOP
	SETZM NGLNXM
	MOVE A,[-5,,NGDATA]
	HRRM A,NGMBE-NGDATA(A)
	SETZM (A)
	AOBJN A,.-2
	MOVE B,[20154,,221000]
	MOVEM B,(A)
	MOVE B,[120000,,600001]
	MOVEM B,1(A)
	MOVE B,[20000,,220000]
	MOVEM B,2(A)
	MOVE B,[121000,,600400]
	MOVEM B,3(A)
	MOVEI B,3000
	MOVEM B,4(A)
	MOVEM B,5(A)
	ADDI A,6
	MOVEM A,NGMBE+5
	JRST NGSIMD

NGDMOD==136
WNGDIS:	0
DISOUT:	0
NGCURC:	-1	;CURRENT "CONSOLE" #

NGMBE=NGBLK
NGSTOP=NGMBE+6	;-1=CONSOLE STROP INTERRUPT REQ
NGLNXM=NGSTOP+1
NGCURP=NGLNXM+1	;CURRENT CONSOLE POINTER
NGPCPC=NGCURP+1	;CURRENT CONSOLE #
NGXCO=NGPCPC+3
NGYCO=NGXCO+3
NGDATA=NGYCO+3

DNGDIS:	.DCLOSE
	PUSHJ P,BLKZAP
	RNGCSR
	PUSHJ P,BLKZAP
	NGBLK
	BLKFLS NGSIMB
	NGINTB,,NGCNS0
	NGCNS1,,NGCNS2
	0
	SETZM WNGDIS
	SETZM DISOUT
	RETURN

NGSIMD:	SKIPL NGCURC
	RETURN
	MOVEM TIME,RTIME
	MOVEI I,3
	PUSHJ P,NGOPEN
	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,220777
	PUSHJ P,DISINS
	MOVEI X,1000
	PUSHJ P,DISINS
	SETZM NGCMOD
	SETOM DISOUT
	PUSHJ P,CREGS
	PUSHJ P,CBUSS
	SETZM DISOUT
	PUSHJ P,NGSTRT
	MOVE C,TIME
	ADDI C,2*WAITTS
	JSP A,CTRDES
NGSIMB:	0
	-1
	PUSHJ P,NGSIMD

NGFRZ:	BLKFLS NGCNS0
	NGCNS1,,NGCNS2
	0
NGCINT:	JSP A,MTRDES
NGINTB:	5
	-1
	JRST .+1
	SETZM NGSTOP
	MOVEI T,56
	JSP A,VTRAP


NGCSRK:	TLNN B,54000
	JRST NGCSRW
	ANDI A,170407
	IOR A,NGLNXM
	HRRM A,RNGCSR
	TLNN B,22000
	RETURN
NGCSRW:	 XXWAIT
	HRRZ B,RNGCSR
	MOVEI I,0
	PUSHJ P,NGGOGO
	MOVEI I,1
	PUSHJ P,NGGOGO
	MOVEI I,2
	PUSHJ P,NGGOGO
	TRNE B,60000
	TROA B,100000	;NXM FROM EXTENSION BITS
	TRNE B,100000
	TRNN B,10000
	SKIPA
	JRST NGFRZ
	TRNE B,400
	AOSE NGSTOP
	RETURN
	JRST NGCINT

NGINFO:	1,,NGCNS0
	2,,NGCNS1
	4,,NGCNS2

IRPC X,,[012]
NGCNS!X:	6,,
	-1
	PUSHJ P,NGCNR!X
	TERMIN

NGGOGO:	HRRZ A,NGINFO(I)
	HLRZ C,NGINFO(I)
	TRNN B,(C)
	JRST QDEL
	SKIPL 1(A)
	RETURN
	PUSHJ P,MTRNEW
	MOVE A,I
	MOVEM A,NGPCPC(I)
	SETZM NGXCO(I)
	SETZM NGYCO(I)
	RETURN

NGCNR0:	TDZA I,I
NGCNR1:	MOVEI I,1
	SKIPA
NGCNR2:	MOVEI I,2
	PUSHJ P,NGOPEN
	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,220000
	ADD X,NGYOF(I)
	ADDI X,400
	PUSHJ P,DISINR
	MOVEI X,0
	ADD X,NGXOF(I)
	ADDI X,400
	PUSHJ P,DISINR
	SETZM NGCMOD
	MOVE MA,NGPCPC(I)
NGMLUP:	ANDI MA,77777
	MOVE TT,MA
	PUSHJ P,NGGETL
	MOVE MB,T
	TRNN MB,140000
	AOJA MA,NGMLUP
	TRNN MB,100000
	JRST NGMLP0
	TRNN MB,40000
	JRST NGMLPJ
	TRNE MB,20000
	AOJA MA,NGMLUP
	TRNN MB,14000
	JRST NGMLCN
	TRNN MB,10000	;POINT MODE
	JRST NGMXYY
	LDB X,[800,,MB]
	ADDB X,NGXCO(I)
	ADDI X,200
	ANDI X,377
	LSH X,1
	ADD X,NGXOF(I)
	PUSHJ P,NGXYIN
NGMXYY:	TRNN MB,4000
	AOJA MA,NGMLUP
	LDB X,[800,,MB]
	ADDB X,NGYCO(I)
	ADDI X,200
	ANDI X,377
	LSH X,1
	ADD X,NGYOF(I)
	TRO X,200000
	PUSHJ P,NGXYIN
	AOJA MA,NGMLUP

NGXOF:	0
	1000
	0
NGYOF:	1000
	1000
	0

NGPOP:	MOVEI TT,8(I)
	PUSHJ P,NGGETL
	ADDI T,2
	ANDI T,177777
	HRRM T,PDP11(TT)
	LSH T,-1
	SOS TT,T
	ANDI TT,77777
NGGETL:	MOVE T,RNGREL
	LSH T,-1
	ADD TT,T
	TRNE TT,700000
	JRST NGTNXM
	SKIPGE T,PDP11(TT)
	JSP D,NGMTRW
	RETURN

NGRNXM:	SUB P,[1,,1]
NGTNXM:	SUB P,[1,,1]
	.VALUE

NGXYIN:	TRNE MB,2000
	TRO X,2000	;INTENSIFY
	PUSH P,X
	MOVEI X,1
	PUSHJ P,NGSMOD
	POP P,X
	SETZM NGCMOD
DISINR:	HRRZ T,NGCURP
	ADDI T,2
	CAML T,NGMBE+1(I)
	JRST DISERR
	IDPB X,NGCURP
	RETURN

DISERR:	HRRZM I,QT
	TTOA [ASCIZ /
OVERFLOW DIS CONSOLE T/]
	SUB P,[1,,1]
	JRST NGMSTP

NGMLPJ:	EXCH MA,MB	;PUSHJ
	AOS MB
	ANDI MB,77777
	LSH MB,1
	MOVEI TT,8(I)
	PUSHJ P,NGGETL
	SUBI T,2
	ANDI T,177777
	HRRM T,PDP11(TT)
	MOVE TT,T
	LSH TT,-1
	PUSHJ P,NGGETL
	HRRM MB,PDP11(TT)
	JRST NGMLUP

NGMLP0:	MOVEI X,6	;INCREMENT
	PUSHJ P,NGSMOD
	LDB E,[130300,,MB]	;DIRECTION
	LDB TT,[100300,,MB]	;COUNT
	SKIPN TT
	MOVEI TT,8
	MOVNM TT,NGTEM
	MOVE T,[100,,MB]
	DPB TT,[360600,,T]
	MOVE TT,T
NGMLPZ:	ILDB T,TT
	LDB T,NGLDB(E)
	XCT NGXINC(T)
	XCT NGYINC(T)
	LSH T,@NGCMD2
	LDB X,NGCURP
	IOR X,T
	DPB X,NGCURP
	MOVNI X,4
	ADDB X,NGCMD2
	SKIPGE X
	PUSHJ P,NGSTIN
	AOSGE NGTEM
	JRST NGMLPZ
	AOJA MA,NGMLUP

NGTEM:	0
NGLDB:	REPEAT 8,40000*.RPCNT+400,,NGLDC(T)
NGLDC:	05460634202
	35677735652

NGXINC:	REPEAT 8,JFCL
	REPEAT 4,AOS NGXCO(I)
	REPEAT 4,SOS NGXCO(I)
NGYINC:	REPEAT 4,[JFCL
	JFCL
	AOS NGYCO(I)
	SOS NGYCO(I)
]

NGMLCN:	TRNE MB,2000	;CONTROL COMMAND
	SETZM NGXCO(I)	;RESET X
	TRNE MB,1000
	SETZM NGYCO(I)	;RESET Y
	TRNE MB,200
	PUSHJ P,NGPOP
	TRNE MB,400
	JRST NGMSTP
	TRNN MB,100
	AOJA MA,NGMLUP
	PUSHJ P,NGPOP
	LSH T,-1
	HRRZ MA,T
	JRST NGMLUP

NGMSTP:	HLRZ A,NGINFO(I)
	ANDCAM A,RNGCSR
	SETOM NGSTOP
	JRST NGSTRT

;OPEN SPACE TO PUT IN DISPLAY COMMANDS
NGOPEN:	SKIPL NGCURC
NGOPNF:	TTOA [ASCIZ /
DISPLAY PHASE ERROR/]
	MOVEM I,NGCURC
	.DSTOP
	MOVE MA,NGMBE+5
	CAILE MA,NGBLK+4000
NGOPNE:	TTOA [ASCIZ /
DISPLAY POINTERS ERROR/]
	CAIL MA,NGBLK+4000
	JRST NGOPE4
	MOVEI MB,NGBLK+4000
	MOVEM MB,NGMBE+5
	MOVEI X,4
NGOPE2:	SOS MA
	SOS MB
	MOVE T,(MA)
	MOVEM T,(MB)
	CAMLE MA,NGMBE(X)
	JRST NGOPE2
	CAME MA,NGMBE(X)
	JRST NGOPNE
	HRRM MB,NGMBE(X)
	CAIGE I,-1(X)
	SOJA X,NGOPE2
	CAIE I,-1(X)
	JRST NGOPNE
NGOPE4:	MOVE X,NGMBE(I)
	TLO X,442200
	MOVEM X,NGCURP
	MOVEI X,NGDMOD
	IDPB X,NGCURP
	SETZM NGCMOD
	RETURN

;LIST PROCESS GENERAL REGISTERS AND CONTENTS
CREGS:	MOVSI T6,REGBIT
	PUSH P,SF
	SKIPL DDTPDP		;IF NOT IN DDT,
	HRLZ SF,%TMODE		;GET TEMP. MODES.
CREGS2:	MOVE T,R0(T6)
	MOVEM T,QT
	CRF
	ADRTYP T6
	TTOA [ASCIZ &/   T&]
	AOS T6
	TRNN T6,10
	JRST CREGS2
	POP P,SF
	JRST CRPOPJ

DISINS:	HRRZ T,NGCURP	;DISPLAY INSERT
	CAMGE T,NGMBE+1(I)
	IDPB X,NGCURP
	RETURN

DISIN0:	PUSH P,X
	MOVEI X,0
	PUSHJ P,DISINS
	POP P,X
	RETURN

NGSMOD:	CAMN X,NGCMOD	;SET MODE
	RETURN
	HRRZ T,NGCMOD
	JRST .+1(T)
	JRST NGSTRM
	JRST NGSTRM
	.VALUE
	JRST NGCHEX
	JRST NGVIEX
	JRST NGVIEX
	JRST NGVIEX
	.VALUE

NGSTRM:	LDB T,NGCURP
	DPB X,[150300,,T]
	DPB T,NGCURP
	MOVEM X,NGCMOD
	JRST .+1(X)
	RETURN
	RETURN
	.VALUE
	JRST NGSTCH
	RETURN
	RETURN
	JRST NGSTIN
	.VALUE

NGCHEX:	PUSH P,[NGVIEY]
	PUSH P,I
	PUSH P,X
	PUSH P,T
	PUSH P,A
	MOVEI A,37
	JRST DISCHH

NGVIEX:	LDB T,NGCURP
	TRO T,400000
	DPB T,NGCURP
NGVIEY:	SETZM NGCMOD
	PUSHJ P,DISIN0
	JRST NGSMOD

NGSTCH:	PUSHJ P,DISIN0
NGST14:	MOVEI T,14
	MOVEM T,NGCMD2
	RETURN

NGSTIN:	PUSH P,X
	MOVEI X,200000
	PUSHJ P,DISINS
	POP P,X
	JRST NGST14

NGCMOD:	0	;CURRENT HWD MODE
NGCMD2:	0	;IF CUR MODE IS CHAR OR INC, HAS P OF NEXT FREE FIELD


DISCH:	PUSH P,I
	MOVEI I,3
	PUSH P,X
	PUSH P,T
	PUSH P,A
	MOVEI X,3
	PUSHJ P,NGSMOD
	ANDI A,177
	CAIN A,12
	JRST DISLF
	CAIN A,15
	JRST DISCR
	CAIL A,140
	SUBI A,40
	SUBI A,40
	SKIPGE A
	TTOA [ASCIZ /
BAD DISPLAY CHAR/]
	XORI A,40
	ANDI A,77
DISCHH:	LSH A,@NGCMD2
	LDB X,NGCURP
	IOR X,A
	DPB X,NGCURP
	MOVNI X,6
	ADDB X,NGCMD2
	SKIPGE X
	PUSHJ P,NGSTCH
DCHRET:	POP P,A
	POP P,T
	POP P,X
	POP P,I
	RETURN

DISLF:	MOVEI A,33
	JRST DISCHH

DISCR:	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,1016
	PUSHJ P,DISINS
	MOVEI X,3
	PUSHJ P,NGSMOD
	JRST DCHRET

;CLOSE UP DISPLAY LIST AND START
NGSTRT:	SKIPGE I,NGCURC
	JRST NGOPNF
	MOVEI X,0
	PUSHJ P,NGSMOD
	MOVE MA,NGCURP
	TLNE MA,770000
	PUSHJ P,DISIN0
	MOVEI MA,1(MA)
	CAMLE MA,NGMBE+1(I)
	JRST NGOPNE
	CAML MA,NGMBE+1(I)
	JRST NGSTR4
	MOVE X,NGMBE+1(I)
	HRL MB,X
	HRR MB,MA
	SUBB MA,X
	ADD MA,NGMBE+5
	BLT MB,-1(MA)
NGSTR2:	ADDM X,NGMBE+1(I)
	AOS I
	CAIGE I,5
	JRST NGSTR2
NGSTR4:	SETOM NGCURC
	.DSTART [-4000+NGDATA-NGBLK,,NGDATA-1]
	JRST DISLOS
	RETURN

AMASTE:	TLOA A,-1
DMASTE:	TLZ A,-1
	.MASTER A,
	JRST MSTLOS
	RETURN

MSTLOS:	TTOA 1,[ASCIZ /
MASTER MODE/]
DISLOS:	TTOA [ASCIZ /
DISPLAY/]
	TTOA [ASCIZ / NOT AVAILABLE/]
	RETURN

NULDIS:	-3,,.	;NULL DISPLAY LIST
	3000
	3000

;THE RF11/RS11 DSK
ADF:	SKIPE WDF
	PUSHJ P,ADF2
	PUSHJ P,LODFL.
	SKIPE FILFLG
	PUSHJ P,ADFFIL
LODADF:	PUSHJ P,WRDINS
	IRPS X,,[DCS,CMA,DAE,ADS]
	600000+N!X,,R!X
	TERMIN
	0,,RWC
	0,,RDAR
	0
	SETOM WDF
	JRST ZDF

DDF:	SKIPN WDF	;DETACH DISK
	ERROR [ASCIZ/DF NOT ATTACHED/]
	PUSHJ P,DMPFL.
	TLO SF,D1CHAR
	SKIPE FILFLG
	PUSHJ P,CDMPDF
ADF2:	PUSHJ P,CZERDF		;ELIMINATE ALL DISK PAGES.
	PUSHJ P,ZDF
	SETZM WDF
	PUSHJ P,WRDZAP
	RDCS,,RADS
	POPJ P,


; :ZERDF -- ZERO OUT THE DISK.
CZERDF:	MOVSI T5,-200
	SKIPN T6,DSKDIR(T5)
	JRST CZERD2
	SETZM DSKDIR(T5)
	HRRZS T6
	PUSHJ P,BLKZAP
	(T6)
CZERD2:	AOBJN T5,CZERDF+1
	POPJ P,

CMAHAK:	TRZ A,1
	HRRM A,RCMA
	POPJ P,

ADSHAK:	MOVE A,TIME	;COMPUTE "POSITION" OF DISK
	IDIV A,DFTIM
	ANDI A,3777
	HRRM A,RADS
	POPJ P,

ZDF:	SKIPN WDF
	POPJ P,
	SETZM DSKNEM	;DISK POWER CLEAR
	SETZM DSKDAO
	SETOM DSKRDY
	SETZM DSKNED
	SETZM DSKWCE
	HLLZS RDAE
	HLLZS RWC
	HLLZS RDAR
	HLLZS RCMA
	HLLZS RDCS
	BLKFLS DSKCLB
	DFPZBK,,0
DKINTF:	MOVEI A,DSKINT
	JRST QDEL

DSKNEM:	0	;NXM
DSKDAO:	0	;DISK ADR OVFL
DSKRDY:	-1	;READY
DSKNED:	0	;NON-EXISTANT DISK
DSKWCE:	0	;WRITE CHECK ERROR
WDF:	0
DFTIM:	165.	;BASIC DSK TIME QUANTUM.

CTDSK:	HRRZM DL,DFTIM	;SET DFTIM TO ARG.
	RETURN

DCSHAK:	TLNN B,54000
	JRST DCSWRT
	PUSHJ P,DCSCMP	;READ CYCLE
	HRRM A,RDCS
	TLNN B,22000
	POPJ P,
DCSWRT:	 XXWAIT
	MOVE T,RDCS
	TRNE T,400
	JRST ZDF	;POWER CLEAR BIT ON, DO NOTHING ELSE
	TRNN T,1	;GO
	JRST DSKINQ
	HRRZ A,RDCS
	TRNE A,40000
	JRST DCSTR2
	TRZ A,176000
	SETZM DSKWCE
	SETZM DSKNED
	MOVEI B,0
	DPB B,[020400,,RDAE]
	HRRM A,RDCS
DCSTR2:	TRNN A,6
	RETURN		;NO OP
	LSH A,-1
	ANDI A,3
	SUBI A,2
	MOVEM A,MODDSK
	MOVE A,MODTAB+1(A)
	MOVEM A,MODINS
	LDB B,[040200,,RDCS]
	JUMPE B,DCSTR4
	CAIE B,3
	JRST DCSNXM
	LDB B,[160200,,RCMA]
	CAIE B,3
	JRST DCSNXM
DCSTR4:	MOVE D,TIME	;BEGIN SET UP FOR MAIN LOOP
	IDIV D,DFTIM
	LDB D,[1200,,RDAR]
	SUB D,E
	SKIPG D
	ADDI D,2000
	MOVEM D,TIMDSK	;INITIAL POSITIONING TIME
DFRSTR:	HRLZ B,RDAR	;RESTART POINT IF TRANSFER SUSPENDED
	LDB A,[200,,RDAE]
	LSH B,2
	LSHC A,5
	LSHC B,-18.-5-2-1
	LSH C,-35.
	HRRZ E,RCMA
	LSH E,-1
	LDB D,[100100,,RDAE]
	MOVE TT,[AOS E]
	SKIPE D
	MOVSI TT,(JFCL)	;CMA INC INHIBITED
	MOVEM TT,CMAINC
	HRRZ TT,RWC
	ORCMI TT,177777
	SETZM DSKRDY
	BLKFLS DSKCLB
	DFPZBK,,0
	SETZM DFNZRW		;NO NONZERO WORD.
DCSLUP:	SKIPN RUN
	JRST DFPAUZ
	SKIPN T,DSKDIR(A)	;MAIN DISK TRANSFER LOOP
	JSP D,DSKGET
	SKIPN C
	TLO T,220000
	ADD T,B
	LDB MB,T
	SKIPGE X,PDP11(E)
	PUSHJ P,MTRDSK
MODINS:	.	;MODIFIED TO MODE INSTRUCTION
	JRST WCELOS
	DPB MB,T
	HRRM X,PDP11(E)
	IORM X,DFNZRW		;IF NONZERO, SAY WAS NONZERO WORD.
	AOS TIMDSK
CMAINC:	.	;JFCL OR AOS E
	TRCE C,1
	AOS B
	TRZE B,2000
	JRST DSKZAP	;TRACK END
DCSLU9:	AOJN TT,DCSLUP		;XFER TILL WC OVERFLOWS.
	SOJA TT,DSKZAP		;TEST FOR INCOMPLETELY WRITTEN TRK=0.

DCSNXM:	SETOM DSKNEM
	JRST DSKINQ

MODTAB:	SKIPA MB,X
	SKIPA X,MB
	CAIE MB,(X)

MODDSK:	0
TIMDSK:	0

DSKZAP:	AOS A	;ON TO NEXT TRACK
	SKIPE DFNZRW		;DON'T BOTHER CHECKING IF SAW
	JRST DSKZA1		;NONZERO WORD.
	MOVE T,DSKDIR-1(A)
	HRLI T,-2000
	SKIPN (T)
	AOBJN T,.-1
	JUMPL T,DSKZA1
	MOVE T,DSKDIR-1(A)	;PREV TRACK NOW ALL ZERO
	PUSHJ P,BLKZAP
	(T)
	SETZM DSKDIR-1(A)
DSKZA1:	SETZM DFNZRW		;NEW TRK, NO NONZERO WD YET.
	AOJN TT,DCSLUP		;IF MORE WDS, XFER THEM.
	JRST DSKEND		;ELSE DONE.

DFNZRW:	0		;0 IF ALL WDS XFERED IN THIS TRACK WERE 0.

DFPAUZ:	PUSHJ P,DFSTOR
	MOVE C,TIME
	JSP A,CTRDES
DFPZBK:	0
	-1
	PUSHJ P,DFRSTR

MTRDSK:	PUSH P,A
	PUSH P,B
	PUSH P,C
	SKIPGE X,PDP11(E)
	JSP D,MTRPDF
	POP P,C
	POP P,B
	POP P,A
	RETURN

NEMLOS:	SUB P,[1,,1]
	POP P,C
	POP P,B
	POP P,A
	SUB P,[1,,1]
	SETOM DSKNEM
	JRST DSKGE7

WCELOS:	SETOM DSKWCE
DSKGE7:	TRZ TT,600000
DSKEND:	PUSHJ P,DFSTOR
	MOVE C,TIMDSK
	IMUL C,DFTIM
	ADD C,TIME
	JSP A,CTRDES
DSKCLB:	0
	-1
	PUSHJ P,DSKINR

DFSTOR:	HRRM TT,RWC
	LSH E,1
	HRRM E,RCMA
	LSH C,35.
	LSHC B,18.+5+2+1
	LSHC A,-5
	DPB A,[200,,RDAE]
	LSH B,-2
	HLRM B,RDAR
	RETURN

DCSCMP:	MOVE A,RDCS	;DCS COMPUTE
	ANDI A,166
	SKIPE DSKRDY
	TRO A,200
	SKIPE DSKNED
	TRO A,4000
	SKIPE DSKWCE
	TRO A,200000
	SKIPE DSKNEM
	TRO A,40000	;FRZ
	TRNE A,77000
	TRO A,100000	;ERR
	RETURN

DSKGET:	CAIN A,200
	JRST DSKGE6
	MOVE T,A
	LSH T,10.
	PUSHJ P,BLKGET
	400000(T)
	ADD T,[2200,,400000]
	MOVEM T,DSKDIR(A)
	JRST -2(D)

DSKGE6:	MOVEI T,1
	DPB T,[20100,,RDAE]
	SETOM DSKNED
	JRST DSKGE7

DSKINR:	SETOM DSKRDY
DSKINQ:	MOVE T,RDCS
	MOVEI A,DSKINT
	TRNN T,100
	JRST QDEL
	SKIPE DSKRDY
	JRST MTRNEW
	PUSHJ P,DCSCMP
	TRNN A,100000
	JRST DKINTF
	JSP A,MTRNEW
DSKINT:	5	;TRAP PRIORITY 5 TO LOCATION 204
	-1
	JRST .+1
	MOVEI T,41
	JSP A,VTRAP

DAEHAK:	TLNN B,54000	;DAE
	JRST DACWRT
	ANDI A,637
	SKIPE DSKNEM
	TRO A,2000
	SKIPE DSKDAO
	TRO A,40
	HRRM A,RDAE
	TLNN B,22000
	RETURN
DACWRT:	 XXWAIT
	SETZM DSKNED
	SETZM DSKNEM
	MOVE A,RDAE
	TRNE A,2000
	SETOM DSKNEM	;SET TO NEM BIT IN DAE.
	TRNE A,74	;IF ADDRESS EXTENSION NOT 0,
	SETOM DSKNED	;ADDR ISN'T NOT ON DISK 0.
	JRST DSKINQ

DSKDIR:	BLOCK 200+1

;THE RK11 DISK

;FUNCTIONS: RKF!FNC
IRPS Y,,CRS WRT RED WCH SEK RCH DRS WLK
RKF!Y==.IRPCN
TERMIN

;BITS IN RKDS REGISTER
;KEPT IN RKDDSR WORDS UNLESS SAYS OTHERWISE IN PARENS.

RKBSOK==400	;SECTOR COUNT VALID (COMPUTED FROM TIME WHEN RKDS READ)
RKBDRY==200	;DRIVE READY (IE ATTACHED)
RKBARDY==100	;ACCESS READY, NOT DOING A SEEK.
RKBWPS==40	;WRITE-LOCKED.
RKBSCA==20	;SELECTED SECTOR UNDER HEADS NOW (COMPUTED FROM TIME)

;BITS IN RKER REGISTER (ALL ACTUALLY KEPT IN RRKER1)
RKBDRE==100000	;RKBDRY WASN'T ON WHEN USED DRIVE.
RKBOVR==40000	;OVERFLOWED OUT OF LAST CYL.
RKBWLO==20000	;WROTE ON WRITE LOCKED PACK.
RKBSKE==10000	;SEEK ERROR.
RKBPGE==4000	;"PROGRAMMING ERROR"
RKBNXM==2000	;RK REFERENCED NON EX MEM.
RKBDLT==1000	;ACCOMPANIES RKBNXM, "DATA LATE".
RKBNXD==200	;TRIED TO USE NON EX DRIVE.
RKBNXC==100	;NON EX CYL.
RKBNXS==40	;NON EX SECTOR (>12.)
RKBWCE==1	;WRITE-CHECK ERROR (SOFT ERROR)

;BITS IN RKCS REGISTER (KEPT THERE UNLESS SAYS NOT)

RKBERR==100000	;ERROR (READ AS 1 IF RRKER1 NOT 0)
RKBHE== 40000	;HARD ERROR (READ AS 1 IF RRKER1 NOT 0 OR 1)
RKBSCP==20000	;SEARCH COMPLETE
RKBINH==10000	;INHIBIT MA INCR.
RKBFMT==4000	;"FORMAT" (IGNORED)
RKBRWA==2000	;READ-WRITE ALL (IGNORED)
RKBSSE==400	;STOP ON SOFT ERROR.
RKBRDY==200	;CONTROL READY (READ AS 1 IF RKRDY NOT 0)
RKBIDE==100	;INTERRUPT ENABLE.
RKBGO== 1	;GO.

RKNSEC==12.	;# SECTORS/TRACK.
RKNCYL==313	;# CYLS/DRIVE.

RKNDRV==2	;2 DRIVES.
RKNBUF==4	;4 BUFFERS.

RKBUF=NGBLK-6000*RKNBUF	;START OF 1ST BUFFER.

RKDRIV:	0	;RKDTAB IDX OF CURRENTLY SELECTED DRIVE.

RKDTAB:
REPEAT RKNDRV,[
	0 ? -1
	CALL RKDWA1	;CLOCK QUEUE BLOCK FOR DRIVE.
	0		;PC TO RESTART AT CLOCK QUEUE.
	.RPCNT_15+RKBSOK ;DSR FOR DRIVE (DRIVE NUM. IN ID FIELD)
	0		;SELECTED CYL AND SECTOR NUM.
	'DSK		;FILENAME BLOCK.
	'RK11_14
	'DRIVE0+.RPCNT
	0		;SNAME.
	'DSK,,		;LEFT-JUST DEV NAME FOR .CALL OPEN.
	0		;CURRENT FUNCTION, -1 => WANTS SEARCH COMPLETE INT.
	RKDIR+.RPCNT*RKNCYL*2(D)
]
RKDTBL==<.-RKDTAB>/RKNDRV	;LENGTH OF ENTRY.

IF1 [
IRPS YY,,QBL UNUS UNUS PC DSR ADR FIL FN1 FN2 SNM DEV FNC DIR
RKD!YY=.IRPCNT+RKDTAB
DEFINE RKC!YY
RKD!YY(B)TERMIN
TERMIN
] ;END IF1.


RKDIR: REPEAT RKNDRV,BLOCK 2*RKNCYL

;BUFFER TABLES, INDEX BY BUFFER NUM.
RKBFT0:	REPEAT RKNBUF,0	;POSITIVE => BUFFER HAS BEEN WRITTEN IN.
RKBFT1:	REPEAT RKNBUF,-1	;-1 IF FREE, ELSE DRIVE IDX,,ADDR OF RKDIR ENTRY FOR CYL.
RKBFT2:	REPEAT RKNBUF,-1	;-1 IF FREE, ELSE NUMBER OF LAST TRANSACTION.
RKBFT3:	REPEAT RKNBUF, -6000,,RKBUF+6000*.RPCNT	;AOBJN -> BUFFER.

RKCNT:	0	;INCREMENTED FOR EACH TRANSACTION, PUT IN RKBFT2 ENTRY
		 ;(FOR SWAPPING OUT LEAST RECENTLY USED)

RKCHAN:	-1	;CHANNEL NUMBER ALLOCATED TO RK11, OR -1 IF NONE.

RKDOPN:	0	;NONNEG => RKDTAB IDX OF DRIVE OPEN FOR INPUT ON RKCHAN,
		; NEG => 1'S COMPLEMENT OF IDX OF DRIVE OPEN FOR WRITING.

WRK:	0	;-1 IFF RK ATTACHED.
RKDCNT:	0	;# DRIVES ATTACHED.
RKRDY:	-1	;READY
RRKER1:	0	;ERROR BITS KEPT HERE.
RKSERC:	0	;-1 IFF SOME DRIVE(S) WAITING FOR SEARCH-COMPLETE INT.
RKINSD:	0	;DRIVE THAT HAS BEEN ALLOWED TO INT SEARCH-COMPLETE.
RKLOCP:	0	;BP. IN BUFFER, FOR TRANSFERS.
RKSCWC:	0	;# WDS LEFT THIS SECTOR.
RKWIOR:	0	;ON WRITE, IOR OF ALL WORDS WRITTEN.
RKTIM:	32500.	;SECTOR ROTATION TIME
RKCTIM:	3350.	;CYLINDER SEEK TIME =
RKXTIM:	100000.		;N*CYLTIM+CYL2TIM
RKCSHK:	TLNN B,54000	;CTRL, STATUS REG.
	JRST RKCSWR
	MOVE A,RRKCS	;GET ACTUAL VALUE,
	ANDCMI A,RKBRDY+RKBERR+RKBHE+RKBGO	;BITS NOT REALLY KEPT THERE.
	SKIPE RKRDY
	 IORI A,RKBRDY	;TURN ON READY BIT IF NEC.,
	SKIPE C,RRKER1
	 IORI A,RKBERR	;ERROR BIT IF ERROR REG NONXERO,
	TRNE C,177774
	 IORI A,RKBHE	;HARD ERROR IF NEC.
	HRRM A,RRKCS
	TLNN B,22000
	POPJ P,
RKCSWR:	XXWAIT
	MOVE A,RRKCS	;GET VALUE WRITTEN,
	ANDCMI A,RKBRDY+RKBERR+RKBHE+RKBGO	;FLUSH BITS KEPT ELSEWHERE.
	EXCH A,RRKCS	;GET BACK THE RKBGO THAT WAS WRITTEN.
	TRNN A,RKBGO
	RETURN
	MOVEI A,RKBWCE
	ANDCAM A,RRKER1	;NEW FUNCTION, CLEAR SOFT ERRORS.
	LDB A,[010300,,RRKCS]
	JUMPE A,RKGOCR	;CONTROL RESET DOESN'T SEKLECT A DRIVE.
	LDB B,[150300,,RRKDA]
	MOVEI C,RKBNXD
	CAIL B,RKNDRV
	 JRST RKERR	;ELSE ERROR IF DRIVE NUM. TOO LARGE.
	IMULI B,RKDTBL	;COMPUTE RKDTAB IDX OF DRIVE.
	MOVEM B,RKDRIV	;THIS DRIVE NOW SELECTED.
	MOVEI C,RKBDRE
	MOVE T,RKCDSR	;GET DRIVE'S STATUS,
	TRNN T,RKBDRY
	 JRST RKERR	;NOT ATTACHED => DRIVE ERROR.
	JRST @.(A)	;ELSE DISPATCH TO FUNCTION.
	REPEAT 5,RKGOSK	;SEEK AND ALL TRANSFER OPERATIONS.
	RKGODR
	RKGOWL
;SEEK, READ, WRITE ETC. COME HERE TO ACCESS.
RKGOSK:	MOVEI C,RKBSKE	;SEEK ERROR IF HEADS MOVING.
	TRNN T,RKBARDY
	 JRST RKERR
	TRNE T,RKBWPS
	CAIE A,RKFWRT	;WRITING AND WRITE LOCKED => ERROR.
	 JRST RKGOS0
	MOVEI C,RKBWLO
	JRST RKERR

RKGOS0:	SETZB C,RKRDY
	LDB T,[400,,RRKDA]
	CAIL T,RKNSEC
	 IORI C,RKBNXS	;SECTOR NUM. TOO LARGE.
	LDB T,[051000,,RRKDA]
	CAIL T,RKNCYL
	 IORI C,RKBNXC	;CYL NUM. TOO LARGE.
	JUMPN C,RKERR	;ANY OF THOSE ERRORS => SAY SO.
	MOVEM A,RKCFNC	;ELSE REMEMBER WHAT FUNCTION THIS DRIVE DOING,
	CAIN A,RKFSEK
	 CALL RKINTR	;IF SEEK, CONTROLLER READY NOW, MAYBE INTERRUPT.
	MOVEI C,RKBARDY
	ANDCAM C,RKCDSR	;THIS DRIVE'S HEADS MOVING.
	LDB C,[1500,,RRKDA]
	EXCH C,RKCADR	;REMEMBER WHAT CYL AND SECT SELECTED.
	LDB C,[051000,,C]
	SUB C,T		;# CYLS MUST MOVE THE HEADS.
	MOVMS C
	JUMPE C,RKGOS3	;TAKES NO TIME IF SAME CYL.
	IMUL C,RKCTIM
	ADD C,RKXTIM	;TIME THAT WILL TAKE.
	JSP A,RKDWAT	;QUEUE UP DRIVE TAT LONG FROM NOW, RETURN.
RKGOS3:	MOVEI C,RKBARDY
	IORM C,RKCDSR	;SAY HEADS NO LONGER MOVING.
	MOVE A,RKCFNC
	CAIE A,RKFSEK
	 JRST RKGOS2	;NOT SEEK => FIND THE RIGHT SECTOR.
	SETOM RKCFNC	;SAY WANT A SEARCH-COMPLETE INTERRUPT.
	SETOM RKSERC	;SAY THAT SOME DRIVE WANTS ONE.
	JRST RKINSC	;SEE IF CAN INTERRUPT NOW; RETURN.

;COME FOR READ, WRITE, ETC AFTER REACHED SELECTED CYL.
;REACHED FROM CLOCK QUEUE.
RKGOS2:	CALL RKSECT	;PUT CURRENT SECTOR NUM. IN A.
	LDB C,[400,,RKCADR]
	SUB C,A		;SELECTED-CURRENT.
	CAIGE C,
	 ADDI C,RKNSEC	;SUBTRACT MOD 12.
	IMUL C,RKTIM
	JSP A,RKDWAT	;WAIT TILL SHOULD START TRANSFER.
	MOVEI C,RKWCHK	;GET ADDR. OF RTN FOR THIS OPERATION.
	CAIN A,RKFWRT
	MOVEI C,RKWRIT
	CAIN A,RKFRED
	MOVEI C,RKREAD
	CAIN A,RKFRCH
	MOVEI C,RKRCHK
	LDB A,[130100,,RRKCS]
	HRLI C,(JRST)	;INH BAR INC
	SKIPN A
	HRLI C,(AOJA MA,)
	MOVEM C,RKLOOP	;SAVE INSN TO INCR MA (MAYBE) AND DO NEXT WD.
	LDB D,[051000,,RRKDA]
	SKIPN A,@RKCDIR	;A_RKDIR ENTRY FOR THIS CYL.
	 JRST [MOVE A,RKCFNC	;CYL NOT IN FILE,
		CAIN A,RKFWRT
		 JRST RKNEW1	;WRITING, SEE IF WRITING ZEROS.
		JRST RKGOT4]	;NOT WRITING, FAKE BP TO READ 0'S.
	JUMPL A,RKGOT2	;ALREADY IN CORE?
	CALL RKGET	;OBTAIN BUFFER TO READ INTO, IDX IN T.
	CALL RKINO	;OPEN DRIVE FOR INPUT.
RKGET5:	HRRZ C,@RKCDIR
	CALL RKXFER	;READ CYL FROM FILE INTO BUFFER.
RKNEW4:	SETCM C,T
	HRLM C,@RKCDIR	;PUT -1#<BUFFER NUM> INTO LH OF RKDIR ENTRY.
	SETZM RKBFT0(T)	;BUFFER NOT WRITTEN IN YET.
	MOVEI C,@RKCDIR
	HRLI C,(B)	;REMEMBER DRIVE,,RKDIR-ADDR FOR BUFFER.
	MOVEM C,RKBFT1(T)
	JRST RKGOT1

RKGOT2:	HLRO T,A	;CYL ALREADY IN CORE,
	SETCA T,	;GET BUFFER NUMBER.
RKGOT1:	AOS C,RKCNT	;GET NUMBER OF THIS TRANSFER,
	MOVEM C,RKBFT2(T) ;REMEMBER SO CAN SWAP OUT LEAST RECENTLY USED.
	HRRZ C,RKLOOP
	CAIE C,RKWRTN
	CAIN C,RKWRIT	;WRITING => SAY BUFER WRITTEN IN.
	 AOS RKBFT0(T)
	CAIE C,RKWRTN	;CREATING A CYL => RKLOCP ALREADY SET UP
	 JRST RKGOT7
	HRRZ C,RKBFT3(T) ;EXCEPT FOR THE ADDR OF START OF BUFFER.
	ADDM C,RKLOCP
	MOVEI C,RKWRIT	;CHANGE TO ORDINARY WRITE NOW THAT CYL EXISTS.
	HRRM C,RKLOOP
	JRST @RKLOOP

RKNEW1:	MOVEI C,RKWRTN	;SPECIAL RTN FOR WRITING IN NON-EX-CYL.
	HRRM C,RKLOOP
	TDZA C,C
RKGOT7:	HRRZ C,RKBFT3(T)
	HRLI C,442200
	MOVEM C,RKLOCP	;STORE BP -> BEFORE 1ST HWD OF BUFFER.
	CAIA
RKGOT4:	SETZM RKLOCP	;READING EMPTY CYL => FETCH ZERO-BYTES.
	LDB D,[0500,,RRKDA] ;GET SECTOR NUM,
	TRZE D,20
	ADDI D,14	;CHANGE TO # OF SECTOR WITHIN CYL,
	MOVEI C,(D)
	IMULI C,200	;FIND THAT SECTOR'S OFFSET IN BUFFER,
	ADDM C,RKLOCP	;MAKE BP -> THAT SECTOR.
	SETZM RKWIOR	;(INIT. SO CAN TELL IF WROTE A NONZERO WORD)
RKGOT6:	MOVE C,RKTIM	;COMEE HERE TO HANDLE NEXT SECTOR IN CYL.
	JSP A,RKDWAT	;WAIT TILL TRANSFER SHOULD BE OVER BEFORE DOING IT.
	LDB D,[0500,,RRKDA]
	TRZE D,20
	 ADDI D,14	;CALC. SECTOR NUMBER AGAIN.
	LDB MA,[011700,,RRKBA]
	MOVEI C,400
	MOVEM C,RKSCWC	;INIT. COUNT OF WDS IN SECTOR.
	ADDI D,1	;INCREMENT SECTOR ADDR,
	CAIG D,13
	 JRST RKGOT3
	SUBI D,14	;SECOND SURFACE MAYBE (IE CHANGE TO SURFACE NUM AND SECT NUM)
	TRO D,20
	CAIN D,34	;MAYBE OVERFLOWED TO NEXT CYL.
	 MOVEI D,60
RKGOT3:	DPB D,[0500,,RRKDA]
	ANDI D,40
	ADDM D,RRKDA	;HANDLE OVERFLOW TO NEXT CYL.
	JRST @RKLOOP	;HANDLE 1ST WORD.

RKGET:	MOVSI TT,-RKNBUF	;NO, FIND BUFFER TO READ INTO.
	MOVSI C,200000	;LARGE POS. NUM FOR HOW-GOOD-IS-BEST-SO-FAR.
RKGET2:	CAMG C,RKBFT2(TT)
	 JRST RKGET3	;THIS BUFFER NOT BETTER.
	MOVE C,RKBFT2(TT)	;IT IS BETTER, REPLACE BEST SO FAR.
	MOVEI T,(TT)
RKGET3:	AOBJN TT,RKGET2
	JUMPL C,CPOPJ	;DONE IF BUFFER FREE.
	SKIPG RKBFT0(T)	;NO, WRITTEN IN?
	 RET
	SAVE B		;YES, MUST SWAP OUT.
	HLRZ B,RKBFT1(T)	;WHICH DRIVE'S IS IT?
	CALL RKOUTO	;OPEN THAT DRIVE FOR OUTPUT.
	REST B
RKGET6:	HRRZ C,RKBFT1(T) ;GET ADDR OF RKDIR ENTRY,
	HRRZS C,(C)	;GET BLOCK NUM IN FILE, ALSO SAY CYL NOT IN CORE.
	JRST RKXFER	;WRITE THE BUFFER OUT.

RKWRTN:	SKIPGE MB,PDP11(MA)	;WRITE IN CYL WHICH IS EMPTY.
	 JSP D,MTRRKR
	JUMPE MB,[IBP RKLOCP ? JRST RKINCR]
	LDB D,[051000,,RRKDA]
	CALL RKGET	;GET BUFFER (IDX IN T)
RKNEW3:	MOVE C,RKBFT3(T)	;CREATING A CYL, GOT THE BUFFER..
	SETZM (C)
	AOBJN C,.-1	;CLEAR IT OUT.
	SAVE D		;REMEMBER CYL NUM.
	MOVEI D,RKNCYL	;LOOK FOR FREE SLOT IN FILE.
	SKIPE @RKCDIR
	 AOJA D,.-1
	REST C
	SETCAM C,@RKCDIR ;SAY THIS CYL USING THE SLOT.
	EXCH C,D
	SUBI C,RKNCYL-1	;GET # OF SLOT, (1ST SLOT # 1)
	MOVEM C,@RKCDIR	;SAY THIS CYL HAS IT.
	JRST RKNEW4

RKWRIT:	SKIPGE MB,PDP11(MA)
	JSP D,MTRRKR
	IDPB MB,RKLOCP
	IORM MB,RKWIOR
	JRST RKINCR

RKREAD:	SKIPGE PDP11(MA)
	JSP D,MTRRKW
	ILDB MB,RKLOCP
	HRRM MB,PDP11(MA)
	JRST RKINCR

RKWCHK:	SKIPGE MB,PDP11(MA)
	JSP D,MTRRKR
	ILDB TT,RKLOCP
	CAIN TT,(MB)
	JRST RKINCR
	MOVEI C,RKBWCE	;WRITE-CHECK ERROR.
	JRST RKERR

RKRCHK:	IBP RKLOCP
RKINCR:	AOS T,RRKWC	;INCR. WORD COUNT.
	TRNN T,177777
	 JRST RKINC1	;XFER COMPLETE.
	SOSLE RKSCWC	;STILL SAME SECTOR =>
RKLOOP:	0		;INCR. MA AND DO NEXT WD.
RKINC1:	DPB T,[2000,,RRKWC] ;DON'T LET RRKWC GET TO BE 200000 .
	HLRZ D,RKLOOP	;INCR. MA OVER LAST WD XFERED IF NEC.
	CAIN D,(AOJA MA,)
	 AOJ MA,
	DPB MA,[011700,,RRKBA] ;PRETEND HAD BEEN INCR'ING THIS INSTEAD MA.
	TRNN T,177777
	 JRST [HRRZ A,RKLOOP	;TRANSFER FINISHED -
	 	CAIE A,RKWRIT
		 JRST RKINTR
		JRST RKWRT0]	;WRITING, ZERO REST OF SECTOR.
	MOVE B,RKDRIV	;MTRRKR AND MTRRKW CLOBBER B.
	LDB D,[0500,,RRKDA]
	TRNE D,37
	 JRST RKGOT6	;SAME CYL, JUST REINIT RKSCWC AND INCR SECTOR NUM.
	LDB D,[051000,,RRKDA] ;CYL. NUM.
	MOVEI C,RKBOVR
	CAIL D,RKNCYL
	 JRST RKERR	;PAST END OF DISK, ERROR.
	MOVE A,RKCFNC
	JRST RKGOS0	;SEEK TO THAT CYL AND KEEP GOING.

RKWRT0:	SETZ A,
RKWRT1:	SOSGE RKSCWC	;COUNT WDS LEFT IN SECTOR,
	 JRST RKINTR
	IDPB A,RKLOCP	;STORE 0 IN EACH.
	JRST RKWRT1

RKNXM0:	DPB MA,[011700,,RRKBA] ;SAVE THE UPDATED VALUE.
	SUB P,[1,,1]	;FLUSH RET ADDR IN MTRAP.
	MOVEI C,RKBNXM

;CALL HERE TO RECORD AN ERROR (BIT IN C) AND MAYBE INTERRUPT.
RKERR:	IORB C,RRKER1
	TRNE C,177774
	 JRST RKINTR	;HARD ERROR, TRY TO INTERRUPT.
	MOVE C,RRKCS	;IT'S SOFT,
	TRNN C,RKBSSE	;MAYBE INTERRUPT.
	 RET
RKINTR:	SETOM RKRDY	;CONTROLLER READY, MAYBE INTERRUPT.
	MOVE C,RRKCS
	TRNN C,RKBIDE
	 JRST RKINSC	;NOT ENABLED, GO FLUSH RQS FOR SEARCH-COMPLETE INT.
	JSP A,MTRNEW	;ENABLED, INTERRUPT.
RKINTB:	5
	-1
	JRST .+1
	MOVEI A,RKBSCP
	ANDCAM A,RRKCS
	JRST RKINT1

;CHECK FOR ANY DRIVES THAT WANT SEARCH-COMPLETE INTS.
;IF INTS DISABLED, FLUSH RQS.
;IF ENABLED, PICK ONE AND ARRANGE FOR IT TO INTERRUPT.
RKINSC:	SKIPE RKRDY	;CONTROLLER NOT READY OR NOONE WANTS ONE => DONE.
	SKIPL RKSERC
	 RET
	SKIPL RKINTB+1	;CAN'T GIVE 2 INTS AT ONCE.
	 RET
	MOVSI B,-RKNDRV	;ELSE CHECK EACH DRIVE.
RKINS1:	SKIPL RKCFNC
	 JRST RKINS2	;THIS DRIVE DOESN'T WANT ONE.
	MOVE A,RRKCS
	TRNN A,RKBIDE
	 JRST RKINS4	;INTS NOT ENABLED - FLUSH THE RQ.
	MOVEM B,RKINSD	;ELSE LET THIS DRIVE INT.
	JSP A,MTRNEW
RKINSB:	5
	-1
	JRST RKINS3

RKINS4:	SETZM RKCFNC	;THIS DRIVE NO LONGER WANTS ONE.
RKINS2:	ADDI B,RKDTBL-1
	AOBJN B,RKINS1
	SETZM RKSERC	;NO DRIVE WANTS ONE NOW.
	RET

RKINS3:	MOVE B,RKINSD	;TAKE A SEARCH-COMPLETE INT. HERE.
	SETZM RKCFNC	;THIS DRIVE GOT ONE, SO DOESN'T WANT ONE.
	MOVEM B,RKDRIV	;IT IS NOW SELECTED SO ITS DSR IS IN RKDS.
	MOVEI B,RKBSCP
	IORM B,RRKCS	;SAY THIS IS SEARCH-COMPLETE INT.
RKINT1:	CALL RKINSC	;MAYBE ANOTHER DRIVE WANTS ONE TOO.
	MOVEI T,44
	JRST VTRAP	;TRAP THRU VECTOR 220.

;ACCESS 6000-WORD BLOCK WHOSE NUMBER IS IN C.
RKACC:	IMULI C,6000
	SUBI C,4000	;GET ADDR IN FILE.
RKACC1:	.CALL [SETZ ? 'ACCESS ? RKCHAN ? SETZ C]
	 .VALUE
	RET

;TRANSFER BLOCK W/ NUM IN C INTO BUFFER (NUM. IN T)
RKXFER:	CALL RKACC
	MOVE C,RKBFT3(T)	;GET AOBJN -> BUFFER,
RKIOT:	.CALL [SETZ ? 'IOT,,? RKCHAN ? SETZ C]
	 .VALUE
	JUMPL C,.-1
	RET

RKOPNB:	SETZ
	SIXBIT/OPEN/
	RKCHAN
	RKCDEV
	RKCFN1
	RKCFN2
	RKCSNM
	404000,,C	;OPEN-MODE IN C.

RKSECT:	SAVE B
	MOVE A,TIME	;COMPUTE CURRENT SECTOR NUM, LEAVE IN A.
	IDIV A,RKTIM	;A HAS # SECTORS TOTAL.
	IDIVI A,12.	;B HAS SECTOR NOW AT.
	MOVE A,B
POPBJ:	REST B
	RET

;CALL WITH C=TIME TO WAIT, B=DRIVE.
;USE THE CLOCK QUEUE BLOCK IN RKDTAB ENTRY.
RKDWAT:	HRLI A,(CALL)	;A -> PLACE TO RETURN TO.
	MOVEM A,RKCPC
	MOVEI A,RKCQBL
	ADD C,TIME
	JRST CLQADD

;CLOCK QUEUE CALLS HERE WHEN TIME COMES.
RKDWA1:	SUBI B,RKDTAB	;SET UP DRIVE IDX.
	MOVE A,RKCFNC	;LEAVE FUNCTION CODE IN A.
	JRST @RKCPC	;RESTART AFTER JSP TO RKDWAT.

RKERHK:	TLNN B,54000	;ERROR REGISTER.
	POPJ P,		;WRITE
	MOVE A,RRKER1	;GET REAL ERROR REGISTER,
	MOVEM A,RRKER	;SUPPLY TO USER.
	RET

RKBAHK:	TRZ A,1	;RKBA - DON'T LET LOW BIT BE READ AS 1.
	HRRM A,RRKBA
	RET

RKDSHK:	TLNN B,54000	;RKDS - READ ONLY REGISTER.
	 RET		;NOT READING, DO NOTHING.
	MOVE B,RKDRIV	;GET SELECTED DRIVE'S IDX,
	CALL RKSECT	;PUT CURRENT SECTOR  NUM. IN A,
	IOR A,RKCDSR	;MERGE WITH SELECTED DRIVE'S STATUS,
	HRRM A,RRKDS	;LEAVE THAT TO BE READ.
	RET

;WRITE-LOCK FUNCTION.
RKGOWL:	MOVEI A,RKBWPS
	IORM A,RKCDSR	;SET DRIVE'S WRITE-LOCKED BIT.
	JRST RKINTR

;DRIVE RESET FUNCTION.
RKGODR:	MOVEI A,(B)
	CALL QDEL	;STOP THE DRIVE FROM ACTING.
	MOVE B,RKDRIV
	SETOM RKCFNC	;DRIVE WANTS SEARCH-COMPLETE INT.
	SETOM RKSERC
	MOVEI A,RKBWPS
	ANDCAM A,RKCDSR	;DRIVE NOT WRITE-LOCKED,
	MOVEI A,RKBARDY
	IORM A,RKCDSR	;HEADS NOT MOVING.
	JRST RKINTR	;GIVE THE 1ST INT - SUCCESSFULLY INITTED.

;ATTACH RK-11 DRIVE.
ARK:	SKIPN WRK
	 CALL ARK0	;CREATE REGS, BUFFERS, ETC. IF NONEXISTENT.
	TLNN SF,NUMFND
	 RET		;NO DRIVE NUM. GIVEN => THAT'S ALL.
	MOVEI B,(DL)
	IMULI B,RKDTBL	;IDX OF DRIVE TO ATTACH.
	MOVE C,RKCDSR
	TRNE C,RKBDRY
	 CALL RKSWP	;ALREADY ATTACHED => WRITE OUT PAGES AND DIR.
	.SUSET [.RSNAM,,OSNAM] ;ARRANGE TO RESTORE SNAME ON ERROR.
	MOVE A,RKCSNM
	.SUSET [.SSNAM,,A]
	MOVEI A,RKCFIL
	CALL DGFIL	;READ NEW FILE NAMES TO USE.
	CALL OSNAMR	;RESTORE SNAME UNLESS SPEC'D, GET NEW IN A.
	MOVE A,NSNAM	;GET DEFAULT OR SPEC'D SNAME.
	MOVEM A,RKCSNM	;SAVE SNAME OF FILE FOR DRIVE.
	HRRZ A,RKCFIL
	HRLZM A,RKCDEV	;SAVE LEFT-JUST DEV FOR .CALL OPEN.
	MOVE C,RKCDSR
	TRO C,RKBARDY	;HEADS NOT MOVING.
	TRON C,RKBDRY	;IF HADN'T BEEN ATTACHED,
	 AOS RKDCNT	 ;1 MORE DRIVE ATTACHED NOW.
	MOVEM C,RKCDSR
ARK1:	MOVEI C,6	;TRY TO OPEN FOR READING.
	.CALL RKOPNB
	 JRST ARKCR	;FAIL => NEW FILE.
	CALL RKDXFR	;READ IN THE DIRECTORY.
	MOVEM B,RKDOPN	;THIS DRIVE OPEN FOR READING.
	RET

ARKCR:	MOVSI C,-RKNCYL*2
	HRR C,RKCDIR
	MOVE A,C
	SETZM (C)	;NEW FILE, ZERO THE DIRECTORY,
	AOBJN C,.-1
	HRROS RKDOPN	;NO DRIVE OPEN.
	MOVEI C,7	;CREATE THE FILE.
	.CALL RKOPNB
	 OPENL RKOPNB
	SETCAM B,RKDOPN	;THIS DRIVE NOW OPEN FOR WRITING.
	MOVE C,A
REPEAT 1000/RKNCYL,[	;MAKE SURE WRITE OUT 1 WHOLE K.
	CALL RKIOT
	MOVE C,A]	;WRITE OUT ALMOST 1K, IN RKNCYL-SIZED CHUNKS,
	HRLI C,1000/RKNCYL*RKNCYL*2-2000
	JRST RKIOT	;WRITE OUT THE REMAINDER.

;CREATE THE RK11 CONTROLLER.
ARK0:	CALL WRDINS	;CREATE THE REGISTERS.
IRPS X,,RKDS RKER RKCS RKBA
	TRN (N!X)R!X
TERMIN
	RRKWC ? RRKDA ? 0
	MOVEI A,['NUL]	;ALLOCATE A CHANNEL,
	CALL GETCHP	;USE NUL: SO OPEN CAN'T FAIL.
	HRRZM C,RKCHAN
	MOVSI T,-3*RKNBUF
ARK2:	CALL BLKGET	;GET CORE FOR BUFFERS.
	 RKBUF(T)
	ADDI T,1777
	AOBJN T,ARK2
	SETOM WRK
ZRK:	MOVSI B,-RKNDRV	;SWAP OUT EVERYTHING.
ZRK0:	CALL RKSWP	;SWAP OUT ONE DRIVE.
	ADDI B,RKDTBL-1
	AOBJN B,ZRK0
RKGOCR:	SETZM RRKDA
	SETOM RKRDY
	SETZM RRKER1	;CLEAR ERROR BITS.
ARK3:	BLKFLS RKINTB
	.BYTE 18.
REPEAT RKNDRV,RKDTAB+.RPCNT*RKDTBL
	RKINSB ? 0
	.BYTE
	RET

;OPEN DRIVE <- B FOR OUTPUT UNLESS ALREADY OPEN.
RKOUTO:	SETCM C,B
	CAMN C,RKDOPN
	 RET		;ALREADY OPEN.
RKOUTP:	SETCAM B,RKDOPN	;WILL BE OPEN NOW.
	MOVEI C,100007
	.CALL RKOPNB
	 .VALUE
	RET

RKINO:	CAMN B,RKDOPN
	 RET		;ALREADY OPEN.
	MOVEM B,RKDOPN
	.CALL RKOPNB
	 .VALUE
	RET

;DETACH THE RK OR 1 DRIVE.
DRK:	SKIPN WRK
	 RET		;NOT ATTACHED.
	TLNE SF, NUMFND
	 JRST DRK1	;DETACH 1 DRIVE.
	SETZ B,		;DETACH ALL DRIVES.
DRK0:	CALL DRK2	;DETACH THE NEXT DRIVE,
	ADDI B,RKDTBL
	CAIGE B,RKDTBL*RKNDRV
	 JRST DRK0	;DO THAT TO EACH DRIVE.
	CALL ZRK	;GET RID OF QUEUE BLOCKS.
	CALL WRDZAP	;GET RID OF DEVICE REGS.
	RRKDS,,RRKBA
	SERZM WRK
	MOVSI T,-3*RKNBUF
DRK3:	CALL BLKZAP	;FREE BUFFER PAGES.
	 RKBUF(T)
	ADDI T,1777
	AOBJN T,DRK3
	MOVE C,RKCHAN
	SETOM RKCHAN
	JRST CLOSEC	;FREE THE CHANNEL.

DRK1:	MOVEI B,(DL)
	IMULI B,RKDTBL	;IDX OF DRIVE TO DETACH.
DRK2:	MOVE C,RKCDSR
	TRNN C,RKBDRY	;NOT ATTACHED => DONE.
	 RET
	CALL RKSWP	;WRITE OUT DIR AND BUFFERS.
	SYSCAL CLOSE,RKCHAN
	HRROS RKDOPN	;SAY NOTHING OPEN IN EITHER DIRECTION.
	MOVEI A,RKBDRY+RKBWPS
	ANDCAM A,RKCDSR
	SOS RKDCNT	;1 LESS DRIVE IN USE.
	RET

RKSWP:	MOVE C,RKCDSR
	TRNN C,RKBDRY
	 RET		;DO NOTHING IF THIS DRIVE NOT ATTACHED.
	CALL RKOUTO	;OPEN THIS DRIVE FOR OUTPUT.
	MOVSI T,-RKNBUF	;LOOK AT ALL BUFFERS.
RKSWP0:	HLRZ A,RKBFT1(T) ;WHICH DRIVE THIS BUFFER?
	CAIE A,(B)
	 JRST RKSWP1	;SOME OTHER DRIVE.
	HRRZ A,RKBFT1(T)
	HRRZS C,(A)	;THIS DRIVE, SAY CYL NOT IN CORE,
	CALL RKXFER	;WRITE IT OUT.
	SETOM RKBFT1(T)	;BUFFER FREE.
	SETZM RKBFT0(T)
	SETOM RKBFT2(T)
RKSWP1:	AOBJN T,RKSWP0
RKDXFR:	SETZ C,		;TRANSFER THE DIRECTORY.
	CALL RKACC1
	HRRZ C,RKCDIR
	HRLI C,-2*RKNCYL
	JRST RKIOT

;THE KW11-P PROGRAMMABLE CLOCK
APK:	JUMPE T5,ZPK2
	MOVE A,[10000000.]	;ARG=CYCLES/SEC
	IDIV A,T5
	MOVEM A,PKTIM
ZPK2:	SKIPE WPK
	PUSHJ P,DPK
	PUSHJ P,BLKGET
	600000,,RPKCSR
	PUSHJ P,WRDINS
	600000+NPKCSR,,RPKCSR	;CONTROL & STATUS REGISTER
	600000+NPKCSB,,RPKCSB	;COUNTER SET BUFFER
	600000+NPKC,,RPKC	;COUNTER
	0
	SETOM WPK
	SETOM PKERR
	SETZM PKCBUF
	SETZM PKCNT
	MOVEM TIME,ORGTIM
	RETURN

DPK:	BLKFLS PKINTB	;DETACH PROGRAMMABLE CLOCK
	PKCLKB,,0
	PUSHJ P,BLKZAP
	RPKCSR
	SETZM WPK
	RETURN

ZPK:	SKIPE WPK
	JRST ZPK2
	RETURN

PKCHAK:	TLNN B,54000
	RETURN
UPDATE:	MOVE C,RPKCSR
	TRNN C,1
	JRST UPDAT2	;RUN OFF
	SKIPL PKERR
	TRNE C,10	;MODE BIT
	JRST .+2
	JRST UPDAT2	;STOPPED BY OVERFLOW
	LSH C,-1
	ANDI C,3
	MOVE A,TIME
	SUB A,ORGTIM
	XCT TIMTAB(C)
UPDAT4:	ADDB A,PKCNT
	HRRM A,RPKC
	SUBM TIME,B
	MOVEM B,ORGTIM
	RETURN

PKCNT:	0
PKERR:	-1	;O="DONE"	;+="DONE" & ERR
PKCBUF:	0
ORGTIM:	0
WPK:	0
PKTIM:	166667.

TIMTAB:	IDIVI A,100.
	IDIVI A,1000.
	IDIV A,PKTIM
UPDAT2:	SETZB A,B
	JRST UPDAT4

PKCSRK:	TLNN B,54000
	JRST PKCSRW
	ANDI A,177
	SKIPL PKERR
	TRO A,200
	SKIPLE PKERR
	TRO A,10000
	HRRM A,RPKCSR
	TLNN B,22000
	RETURN
PKCSRW:	PUSHJ P,UPDATE
	 XXWAIT
	MOVE A,RPKCSR
	TRNN A,200
	SETOM PKERR
	TRNN A,40	;FIX
	JRST PKCSR2
	TRNN A,20	;UP/DN
	JRST PKCSR4
	AOS C,PKCNT
	ANDI C,177777
	MOVEM C,PKCNT
PKCSR2:	PUSHJ P,PKINTQ
	JRST PKSTUP

PKCSR4:	SOSL C,PKCNT
	JRST PKCSR2
	TRNN A,10
	SETZM PKCBUF
	MOVE C,PKCBUF
	MOVEM C,PKCNT
	AOS PKERR
	JRST PKCSR2

PKINTQ:	MOVEI A,PKINTB
	SKIPGE PKERR
	JRST QDEL
	LDB B,[60100,,RPKCSR]
	JUMPE B,QDEL
	JRST MTRNEW

PKINTB:	6
	-1
	JRST .+1
	SETOM PKERR
	MOVEI T,21
	JSP A,VTRAP

PKCSBK:	HLLZS RPKCSB
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RPKCSB
	HRRM A,PKCNT
	HRRM A,PKCBUF
PKSTUP:	PUSHJ P,PKCLKF
	HRRZ B,RPKCSR
	TRNE B,1
	TRNE B,20	;UP/DN
	RETURN
	HRRZ C,PKCNT
	LSH B,-1
	ANDI B,3
	XCT TABTIM(B)
	ADD C,TIME
	MOVEI A,PKCLKB
	JRST CTRDES

TABTIM:	IMULI C,100.
	IMULI C,1000.
	IMUL C,PKTIM
	RETURN

PKCLKF:	JSP A,QDEL
PKCLKB:	0
	-1
	PUSHJ P,.+1
	AOS PKERR
	PUSHJ P,PKINTQ
	MOVE A,RPKCSR
	HRRZ B,PKCBUF
	TRNN A,10
	MOVEI B,0
	HRRM B,PKCBUF
	HRRM B,PKCNT
	TRNN A,10
	RETURN
	JRST PKSTUP

;DC ASYNCHRONOUS LINE INTERFACE

ADC:	PUSHJ P,ADCR	;ATTACH SAME FILE DC TRANSMIT & RECEIVE
	TLO SF,D1CHAR
ADCT:	SKIPE WDCT	;ATTACH DC TRANSMIT
	PUSHJ P,DDCT
	MOVEI A,DCFIL
	PUSHJ P,DGFIL
	MOVEI T6,1
	HRLM T6,DCFIL
	PUSHJ P,GETCHO
	DPB C,[270400,,DCTCX1]
	HRRM C,DCTCX2
	DPB C,[270400,,DCTCX3]
	SETOM WDCT
	SETOM DCREDY
	SKIPE WDCR
	RETURN
DCINS:	PUSHJ P,WRDINS
	600000+NTSCR,,RTSCR	;TRANSMITTER STATUS REGISTER
	600000+NTBUF,,RTBUF	;TRANMSITTER BUFFER
	600000+NRCSR,,RRCSR	;R STATUS
	600000+NRBUF,,RRBUF	;R BUFFER
	0
	RETURN

DDC:	PUSHJ P,DDCR
DDCT:	SKIPN WDCT
	RETURN
DCTCX2:	MOVEI C,.
	PUSHJ P,CLOSEC	;DETACH DC TRANSMIT
	SETZM DCREDY
	SETZM WDCT
	BLKFLS TSCRB2
	TBUFB1,,0
	SKIPE WDCR
	RETURN
DCZAP:	PUSHJ P,WRDZAP
	RRCSR,,RTBUF
	RETURN

ADCR:	SKIPE WDCR	;ATTACH DC RECEIVE
	PUSHJ P,DDCR
	MOVEI A,DCFIL
	PUSHJ P,DGFIL
	HRRZS DCFIL
	PUSHJ P,GETCHO
	MOVEI B,RBUFB1
	MOVEM B,DYCBPT-DYCH(C)
	HRRZM C,DCRCH.
	DPB C,[270400,,DCRCX2]
	DPB C,[270400,,DCRCX4]	;PUT CHNL NUM IN .OPER'S.
	SKIPE DYCTYP-DYCH(C)
	JRST ADCR2
ADCRTT:	.CALL ADMRTS		;IF TTY, INT. ON ALL CHARS.
	.VALUE
ADCR2:	SKIPGE DYCTYP-DYCH(C)	;IF NOT INT. DEV.,
	 CALL RBUFB2		;ALREADY GOT 1 CHAR.
	SETOM DCCRTR
	SETOM WDCR
	SKIPN WDCT
	JRST DCINS
	RETURN

DDCR:	SKIPN WDCR
	RETURN
	MOVE C,DCRCH.	;DETACH DC RECEIVE
	PUSHJ P,CLOSEC
	SETZM DCDONE
	SETZM WDCR
	SETOM DCCRTR
	BLKFLS RCSRB2
	RBUFB1,,0
	SKIPN WDCT
	JRST DCZAP
	RETURN

DCFIL:	BLOCK 3

WDCR:	0
WDCT:	0
DCDONE:	0
DCREDY:	0
DCCRTR:	0	;CARRIER TRANSITION
DCRCH.:	0
DCRTIM:	0	;TIMING, OR 0 => READ CHARS WHEN RQ'D.
DCTTIM:	500.

RCSRHK:	TLNN B,54000
	JRST RCSRWR
	ANDI A,3533
	SKIPE DCDONE
	TRO A,200
	SKIPE WDCR
	TRO A,4
	SKIPE DCCRTR
	TRO A,140000
	SETZM DCCRTR
	HRRM A,RRCSR
	TLNN B,22000
	RETURN
RCSRWR:	 XXWAIT
	HRRZ A,RRCSR
	TRNE A,2
DCTCX1:	.IOT .,[0]	;"BREAK"
	 IOCGET [CALL DDCT]
	POPJ P,

RCSRI:	MOVEI A,RCSRB2
	SKIPN DCDONE
	JRST QDEL
	LDB B,[60100,,RRCSR]
	JUMPE B,QDEL
	JRST MTRNEW

RCSRB2:	5
	-1
	JRST .+1
	MOVEI T,60
	JSP A,VTRAP

TSCRHK:	TLNN B,54000
	POPJ P,
	ANDI A,531
	SKIPE DCREDY
	TRO A,200
	SKIPE WDCT
	TRO A,2
	HRRM A,RTSCR
	RETURN

TSCRI:	MOVEI A,TSCRB2
	SKIPN DCREDY
	JRST QDEL
	LDB B,[60100,,RTSCR]
	JUMPE B,QDEL
	JRST MTRNEW

TSCRB2:	5
	-1
	JRST .+1
	MOVEI T,61
	JSP A,VTRAP

TBUFHK:	HLLZS RTBUF
	SKIPE DCREDY
	TLNN B,22000
	RETURN
	 XXWAIT
	SETZM DCREDY
DCTCX3:	.IOT .,RTBUF
	 IOCGET [CALL DDCT]
	PUSHJ P,TSCRI
	MOVE C,TIME
	ADD C,DCTTIM
	JSP A,CTRDES
TBUFB1:	0
	-1
	PUSHJ P,.+1
	SETOM DCREDY
	JRST TSCRI

RBUFHK:	TLNE B,54000
	SKIPN DCDONE
	RETURN
	SETZM DCDONE
	SKIPGE RBUFB1+1	;IF NOT GOING TO READ ANOTYER CHAR,
	SKIPE DCRTIM	;AND TIMING IS 0,
	CAIA
	 CALL RBUFB2	;READ ANOTHER SINCE WE'RE THRU WITH LAST ONE.
	JRST RCSRI	;MAYBE STOP VTRAP RQ.

RBUFB2:	MOVE C,TIME	;EVERY 100 VUSEC LOOK FOR NEXT CHAR.
	ADD C,DCRTIM
	MOVEM C,RBUFB1
	JSP A,CTRDES
RBUFB1:	0
	-1
	PUSHJ P,.+1
	SKIPN DCRTIM	;IN READ-WHEN-REQUESTED MODE,
	SKIPN DCDONE
	CAIA
	 RET		;DON'T READ ANOTHER TILL USE PREVIOUS.
	MOVE C,DCRCH.	;DCR CHNLNUM.
	SKIPE DYCTYP-DYCH(C)
	JRST DCRCX2
DCRCX4:	.STATUS .,A	;IF A TTY, SEE IF ANYTHING IN BUFFER.
	TRNE A,2000
	JRST RCSRI	;NOTHING, STOP CLOCK-TRAPPING.
DCRCX2:	.IOT .,A
	 IOCGET [CALL DDCR]
	JUMPL A,CPOPJ	;IF STY HAS NO CHARS
	HRRM A,RRBUF
	SETOM DCDONE
	CALL RCSRI	;MAYBE REQUEST INTERRUPT.
	JRST RBUFB2

;DYNAMICLY ALLOCATED I-O CHANNEL ROUTINES

;CALL WITH C(A) POINTING TO FILE BLOCK
;IF SUCCESSFUL RETURNS WITH CHANNEL NUMBER AS C(C)
GETCHO:	MOVSI C,10
	ANDCAM C,(A)	;WANT 10 BIT FOR STY'S ONLY.
GETCHP:	HRRZ C,(A)
	CAIN C,(SIXBIT /TTY/)
	JRST GCHTTY
	CAIN C,(SIXBIT /LPT/)
	JRST GCHLPT
	MOVE C,[-DYCHN,,DYCH]
	SKIPL DYCTAB(C)
	AOBJN C,.-1
	JUMPGE C,[ERROR [ASCIZ /
NO I-O CHANNELS LEFT/]]
	HRRZS C
	DPB C,[270400,,GETCH1]
	DPB C,[270400,,GETCH1+1]
GETCH1:	TSOPEN .,(A)		;BOTH INSNS ARE IMPURE.
	AOS DYCTAB(C)		;INDICATE CHANNEL IN USE.
	PUSH P,A
	DPB C,[270400,,.+1]
	.STATUS .,A
	ANDI A,77
	CAIE A,1
	CAIN A,2
	SETZM DYCTYP-DYCH(C)	;A TTY - SAY SO.
	HRLI A,1
	CAME A,[1,,25]
	JRST POPAJ
	HLRZM A,DYCTYP(C)	;A STY - SAY SO,
	REST A
	SAVE C
	MOVSI C,10
	IORM C,(A)
	REST C
	XCT GETCH1	;REOPEN WITH BIT 10 SET.
	XCT GETCH1+1
	RETURN

DYCTAB==.-DYCH
	REPEAT DYCHN,-1
DYCBPT:	BLOCK DYCHN	;RECEIVE INT BLOCK POINTERS
DYCBIT:	REPEAT DYCHN,1_<DYCH+.RPCNT>
DYCTYP:	REPEAT DYCHN,-1	;-1 FOR FILE, 0 FOR TTY, +1 FOR PSEDO-TTY

GCHTTY:	HLRZ C,(A)
	TRNN C,1
	SKIPA C,[TYIC]
	MOVEI C,TYOC
GCHLPU:	SETOM DYCTYP	;DON'T SCREW UP CONSOLE TTY
	RETURN

GCHLPT:	HLRZ C,(A)
	TLNN C,1
	ERROR [ASCIZ /INPUT FROM LPT/]
	PUSHJ P,OPNLPT
	MOVEI C,LPTC
	JRST GCHLPU

CLOSEC:	HRRZS C
	CAIN C,LPTC
	JRST CLSLPT	;MAYBE CLOSE LPTC
	CAIL C,DYCH
	CAIL C,DYCH+DYCHN
	RETURN		;IGNORE TYIC, TYOC
	DPB C,[270400,,.+1]
	.CLOSE .,
	SETOM DYCTAB(C)
	SETZM DYCBPT-DYCH(C)
	SETOM DYCTYP-DYCH(C)
	POPJ P,

;DM ASYNCHRONOUS 16-LINE SINGLE SPEED INTERFACE

ADM:		;ATTACH
	PUSHJ P,ADMT
	TLO SF,D1CHAR
ADMR:	TDZA B,B	;ATTACH RECEIVE ONLY
ADMT:	MOVEI B,1	;ATTACH TRANSMIT ONLY
	TLNN SF,NUMFND
	JRST DMSTAT
	CAIL DL,16.
DMTSLN:	ERROR [ASCIZ/NON-EX. LINE/]
	MOVEI A,DMFIL
	PUSHJ P,DGFIL
	HRRZ C,DMFIL
	HRLM B,DMFIL
	PUSHJ P,GETCHO
	PUSH P,C
	JUMPE B,ADM2
	SKIPN C,DMTTAB(DL)
	AOSA A,DMOCNT
	PUSHJ P,CLOSEC
	POP P,DMTTAB(DL)
	JRST ADM3

ADM2:	SKIPGE DYCTYP-DYCH(C)
	JRST ADMR2
	HRROS (P)
	.CALL ADMRTS
	.VALUE
	MOVE A,DL
	IMULI A,DMRLNG
	ADDI A,DMRBLK
	HRRM A,DYCBPT-DYCH(C)
ADMR2:	SKIPN C,DMRTAB(DL)
	AOSA A,DMOCNT
	PUSHJ P,CLOSEC
	POP P,DMRTAB(DL)
	SKIPGE DMRTAB(DL)
	JRST ADM3	;JUMP IF TTY OR STY
	MOVE T5,DL
	IMULI T5,DMRLNG
	MOVEI A,DMRBLK(T5)
	LDB B,[100,,RCSR]
	SKIPE B
	PUSHJ P,CTR100
ADM3:	EXCH A,DMCNT
	JUMPN A,CPOPJ
ADM4:	PUSHJ P,WRDINS	;FIRST ATTACH
	600000+NCSR,,RCSR
	600000+NBAR,,RBAR
	600000+NBCR,,RBCR
	600000+NTBR,,RTBR
	0
	SETZM DMNXM
	SETZM DCRFLG
	SETZM DCRTTP
	SETZM DMRFLG
	RETURN

ADMRTS:	SETZ
	SIXBIT /TTYSET/
	C
	[131313,,131313]
	[131313,,131313]
	SETZ [0]

ZDM:	PUSH P,RTBR
	PUSHJ P,ADM4
	POP P,RTBR
	BLKFLS DCRBLK
	REPEAT 16.,DMRBLK+DMRLNG*.RPCNT,,DMTBLK+DMTLNG*.RPCNT
	DCTBLK,,
	POPJ P,

DDM:		;DETACH
	PUSHJ P,DDMT
	TLO SF,D1CHAR
DDMR:	TDZA B,B	;DETACH RECEIVE ONLY
DDMT:	MOVEI B,1	;DETACH TRANSMIT ONLY
	TLNN SF,NUMFND
	JRST DMSTAT
	CAIL DL,16.
	JRST DMTSLN
	MOVE A,DL
	JUMPE B,DDM2
	SKIPN C,DMTTAB(DL)
	JRST DMTLNA
	SETZM DMTTAB(DL)
BCRDDM:	IMULI A,DMTLNG
	ADDI A,DMTBLK
	JRST DDM3

DDM2:	SKIPN C,DMRTAB(DL)
	JRST DMTLNA
	SETZM DMRTAB(DL)
DMRDDM:	IMULI A,DMRLNG
	ADDI A,DMRBLK
DDM3:	PUSHJ P,QDEL
	PUSHJ P,CLOSEC
	SOS A,DMOCNT
	MOVEM A,DMCNT
	JUMPN A,CPOPJ
	PUSHJ P,WRDZAP	;LAST DETACH
	RCSR,,RTBR
	RETURN

NXMDML:	SUB P,[1,,1]	;NON-EX MEMORY REFERENCE
	SETOM DMNXM
	JRST CSRINT

DMTLNA:	TTOA [ASCIZ /UNATTACHED LINE
/]
DMSTAT:	JUMPN B,DMSTA2	;IF DMT, PRINT TRANSMIT LINES.
	TTOA [ASCIZ /RECEIVE LINES ACTIVE: /]	;IF DMR,...
	MOVE E,[-16.,,]
	SKIPN DMRTAB(E)
DMSTA1:	AOBJN E,.-1
	JUMPGE E,CRPOPJ
	HRRZM E,QT
	TTOA [ASCIZ / T./]
	JRST DMSTA1

;PRINT TRANSMIT LINE STATUS.
DMSTA2:	TTOA [ASCIZ /TRANSMIT LINES ACTIVE:/]
	MOVE E,[-16.,,]
	SKIPN DMTTAB(E)
DMSTA3:	AOBJN E,.-1
	JUMPGE E,CRPOPJ
	HRRZM E,QT
	TTOA [ASCIZ / T./]
	JRST DMSTA3

CRPOPJ:	CRF
	RETURN

DMTTAB:	BLOCK 16.	;TRANSMIT LINE CHNL NUM. OR 0 IF UNATTACHED.
DMRTAB:	BLOCK 16.	;RECEIVE LINE CHNL NUM., OR 0. (LH=-1 IF TTY)
DMOCNT:	0
DMCNT:	0		;COUNT OF ACTIVE LINES
DMFIL:	BLOCK 3
DMNXM:	0
DCRFLG:	0	;CHAR RECEIVED & NOT YET RECEIVE INTERRUPT
DCRTTP:	-1	;TUMBLE TABLE POINTER
DMRFLG:	0	;PREVIOUS RECEIVER ENABLE FLAG
DMTIM:	30000.

TBRHAK:	ANDI A,177400	;TABLE BASE REGISTER
	HRRM A,RTBR
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RTBR
	ANDI A,177400
	HRRM A,RTBR
	RETURN

BCRHAK:	TLNN B,22000	;BREAK CONTROL REGISTER
	RETURN
	 XXWAIT
	HRLZ A,RBCR
	MOVSI E,-16.
	LSH A,-1
	TRNN A,400000
BCRHK2:	AOBJN E,.-2
	JUMPGE E,CPOPJ
	SKIPN C,DMTTAB(E)
	JRST BCRHK2
	DPB C,[270400,,.+1]
	.IOT .,[0]	;"BREAK"
	 IOCGET [CALL BCRLOS]
	JRST BCRHK2

BCRLOS:	MOVE A,E
	JRST BCRDDM

CSRHAK:	TLNN B,54000	;CONTROL AND STATUS REGISTER
	JRST CSRWRT
	ANDI A,110363
	SKIPE DMNXM
	TRO A,40000
	HRRM A,RCSR
	TLNN B,22000
	RETURN
CSRWRT:	 XXWAIT
	LDB B,[100,,RCSR]
	EXCH B,DMRFLG
	XOR B,DMRFLG
	SKIPE B
	JRST CSRREN
CSRINT:	HRRZ B,RCSR
	PUSHJ P,DCRINT
DCTINT:	MOVEI A,DCTBLK
	TRNN B,10000
	JRST QDEL
	SKIPE DMNXM
	JRST MTRNEW
	TRNN B,100000
	JRST QDEL
	JRST MTRNEW

DCRINT:	MOVEI A,DCRBLK
	TRNE B,100
	SKIPN DCRFLG
	JRST QDEL
	JRST MTRNEW

DCRBLK:	5	;RECEIVE INTERRUPT
	-1
	JRST .+1
	SETZM DCRFLG
	MOVEI T,62
	JSP A,VTRAP

DCTBLK:	5	;TRANSMIT INTERRUPT
	-1
	JRST .+1
	MOVEI T,63
	JSP A,VTRAP

CSRREN:	SETOM DCRTTP
	MOVSI E,-16.	;CHANGE IN STATE OF RECEIVE ENABLE (CSR)
	SKIPA A,[DMRBLK]
CSRREM:	ADDI A,DMRLNG
	SKIPN C,DMRTAB(E)
	JRST CSRREL
	SKIPN DMRFLG
	PUSHJ P,QDEL
	SKIPL DYCTYP-DYCH(C)
	JRST CSRREL
	SKIPE DMRFLG
	PUSHJ P,CTR100
CSRREL:	AOBJN E,CSRREM
	JRST CSRINT

DMRBLK:	REPEAT 16.,[0
	-1
	PUSHJ P,.+1
	MOVEI I,.RPCNT
	JRST DMRBRK
]	DMRLNG==5

DMTBLK:	REPEAT 16.,[0
	-1
	PUSHJ P,.+1
	MOVEI I,.RPCNT
	JRST DMTBRK
]	DMTLNG==5

BARHAK:	TLNN B,22000	;BUFFER ACTIVE REGISTER
	RETURN
	 XXWAIT
	MOVSI E,-16.
	HRRZ B,RBAR
	MOVEI A,DMTBLK
BARHK2:	SKIPN DMTTAB(E)
	JRST BARHK4
	TRNE B,1
	PUSHJ P,CTR0
	TRNN B,1
BARHK4:	PUSHJ P,QDEL
	ADDI A,DMTLNG
	LSH B,-1
	AOBJN E,BARHK2
	RETURN

DMTBRK:	SKIPN DMTTAB(I)
	JRST BARFLB
	HRRZ MB,RTBR
	LSH MB,-1
	DPB I,[400,,MB]
	SKIPGE T,PDP11+20(MB)
	JSP D,MTDMRW
	AOS T
	ANDI T,177777
	HRRM T,PDP11+20(MB)
	MOVE A,I
	JUMPE T,DMTBR2
	IMULI A,DMTLNG
	ADDI A,DMTBLK
	PUSHJ P,CTR100
	SKIPGE T,PDP11(MB)
	JSP D,MTDMRW
	AOS T
	ANDI T,177777
	HRRM T,PDP11(MB)
	SOS T
	ANDI T,177777
DMTBR4:	ROT T,-1
	SKIPGE TT,PDP11(T)
	JSP D,MTDMRD
	SKIPGE T
	LSH TT,-8
	ANDI TT,177
	MOVE C,DMTTAB(I)
	DPB C,[270400,,.+1]
	.IOT .,TT
	 IOCGET SKIPA
	RETURN
	SETZM DMTTAB(I)
	MOVE A,I
	JRST BCRDDM

DMTBR2:	PUSHJ P,BARFLB
	SKIPGE T,PDP11(MB)
	JSP D,MTDMRW
	JRST DMTBR4	;DON'T INCREMENT LAST TIME

BARFLB:	MOVEI C,1	;TRANSMIT COMPLETE
	LSH C,(I)
	ANDCAM C,RBAR	;FLUSH BIT IN BAR
	MOVEI C,1
	DPB C,[170100,,RCSR]
	JRST CSRINT

DMRBRK:	LDB T,[100,,RCSR]
	JUMPE T,CPOPJ	;RECEIVER NOT ENABLED
	SKIPN C,DMRTAB(I)
	POPJ P,
	SKIPN DYCTYP-DYCH(C)	;IF TTY, GO SEE IF ANY CHARS.
	JRST DMRTRK
DMRTR0:	DPB C,[270400,,.+1]
	.IOT .,MB
	 IOCGET SKIPA	;DO NOT CHANGE TO JRST
	CAIA
	JRST DMRLOS
	JUMPL MB,CPOPJ	;GIVE UP IF STY HAS NO CHARS.
DMRTRL:	AOS MA,DCRTTP
	ANDI MA,77
	HRRM MA,DCRTTP
	MOVE T,RTBR
	LSH T,-8
	DPB T,[70800,,MA]
	SKIPGE PDP11+100(MA)
	JSP D,MTDMWR
	TRO MB,120000	;ODD PARITY CHAR
	DPB I,[90400,,MB]	;CONSOLE #
	HRRM MB,PDP11+100(MA)
	SKIPGE DMRTAB(I)
	JRST DMRBRL
	MOVE A,I
	IMULI A,DMRLNG
	ADDI A,DMRBLK
	PUSHJ P,CTR100
DMRBRL:	AOS DCRFLG
	JRST CSRINT

CTR100:	MOVE C,TIME
	ADD C,DMTIM
	MOVEM C,(A)
	JRST CTRDES

DMRLOS:	SETZM DMRTAB(I)
	MOVE A,I
	JRST DMRDDM

CTR0:	MOVE C,TIME
	ADDI C,300.
	JRST CTRDES

DMRTRK:	DPB C,[270400,,.+1]
	.STATUS .,A
	TRNE A,2000
	RET		;IF BUFFER EMPTY.
	JRST DMRTR0	;ELSE GO READ CHAR.
;ET ERROR BITS:

ETENDZ==100000	;SEL. DRIVE IN END ZONE.
ETILO==10000	;ILL. OPERATION.
ETSELE==4000	;FAILED TO SELECT UNIQUE DRIVE.
ETBLKM==2000	;WAITED TOO LONG AFTER READING BLOCK NUMBER.
ETNEX==400	;ET GOT A NXM.

;GENERAL ET STATUS:

ETNFIN:	0	;SET IF DT COMMANDS WERE GIVEN BUT NOT FINALIZED.
WET:	0	;SET IF DT IS ATTACHED.
ETUNIT:	-1	;NUMBER OF SELECTED ET UNIT, OR -1 IF NONE.
ETDRIV:	0	;PTR TO INFO ON CURRENTLY SELECTED DRIVE, OR <= 0 IF NONE.
ETDOPN:	0	;-> DRIVE WHOSE FILE IS OPEN, OR 0.
ETDDIC:	0	;-> DRIVE WHOSE DIR IS IN ETBTAB, OR 0.
ETERRO:	0	;ERROR BITS IN TCST.
ETREDY:	0	;ET IS READY IF THIS # 0.

ETBTIM=20000.		;TIME TO READ BLOCK.
ETSTIM=100000.		;TIME TO STOP OR START.

;DRIVE-SPECIFIC INFO:
ETNDRV==10		;NUMBER OF DECTAPE DRIVES.
ETDTAB:
REPEAT ETNDRV,[
	0		;TIME TO REACH NEXT BLOCK.
	-1
	CALL	ETTRP	;ET MOTION RTN.
	-1		;ETDUNI -- UNIT SWITCHES.
	0		;ETDUPS -- -1 IF UP TO SPEED.
	0		;ETDPOS -- CURRENT BLOCK NUM.
	0		;ETDDIR -- DIRECTION (1 - FWD, -1 - BACK).
	0?0?0		;ETDFIL -- FILENAME.
	0		;ETDSNM -- SNAME.
	0		;ETDENA -- NOT 0 IFF DRIVE WRITE-ENABLED.
	0		;ETDIOP -- NOT 0 IFF RDATA, WDATA OK.
]

ETCLEN==3
IRP A,,[UNI,UPS,POS,DIR,FIL,JUNK,JUNK,SNM,ENA,IOP]
ETD!A==ETCLEN
DEFINE ETC!A
ETD!A(B)!TERMIN
ETCLEN==ETCLEN+1
TERMIN

;UNIT-SPECIFIC INFO - -1 IF NO CORRESPONDING DRIVE,
;			0 IF >1 DRIVE,
;			--> ENTRY IN ETDTAB FOR DRIVE IF EXACTLY 1.
ETUTAB:	REPEAT	10,-1		;INITIALLY NO UNIT HAS DRIVE.

ETBTAB:	BLOCK	578.	;ADDR IN FILE OF VIRT BLOCK.
	BLOCK	578.	;VIRT. NUM. OF REAL BLOCK, OR 0.
;ET MOTION TRAPS CALL HERE TO MOVE TAPE 1 POSITION,
;ALSO, FOR SELECTED DRIVE, PROCESS COMMANDS.
ETTRP:	HRRE	A,ETCDIR	;GET CURRENT DIR.
	CAME	A,ETCDIR	;IF LH. WAS CHANGED,
	JRST	ETREV		;MUST REVERSE TAPE.
	MOVEM	A,ETCUPS	;INDICATE UP TO SPEED.
	ADDB	A,ETCPOS	;INDICATE TAPE'S MOVED 1 BLOCK.
	CAML	A,[-20.]
	CAIL	A,600.		;IF POS. OUT OF RANGE,
	JRST	ETREW		;TAPE'S RUN OFF REEL.
	CAMN	B,ETDRIV
	JRST	ETSEL		;SPECIAL PROCESSING FOR SELECTED UNIT.
ETTRPX:	SETZM	ETCIOP		;RDATA NOT OK (BLOCK MISSED)
ETTRPY:	MOVEI	C,ETBTIM	;TIME TO MOVE 1 BLK.
ETREV1:	ADD	C,(B)		;TRAP AGAIN WHEN GET TO NEXT BLOCK.
	MOVEI	A,(B)
	CALL	CTRDES
	JRST	ETINT		;DECIDE WHETHER WANT VIRT TRAP.

ETREV:	MOVNM	A,ETCDIR	;CHANGE DIRECTION.
	SETZM	ETCUPS		;NO LONGER UP TO SPEED.
	MOVEI	C,2*ETSTIM	;TIME TO STOP, START.
	JRST	ETREV1

ETREW:	SETZM	ETCDIR		;STOP TAPE.
	SETZM	ETCUPS
	MOVEI	T,-ETDTAB(B)
	IDIVI	T,ETCLEN	;COMPUTE NUMBER OF DRIVE.
	MOVEM	T,QT
	TTOA	[ASCIZ/
DT DRIVE T RAN OFF /]
	SKIPL	A
	TTOA	1,[ASCIZ/LEFT/]
	TTOA	[ASCIZ/RIGHT/]
	ERROR	[ASCIZ/ REEL
/]
	JRST	ETINT

;COME HERE WITH ERROR BIT IN A.
ETERR:	IORM	A,ETERRO	;INDICATE THE ERROR.

;DECIDE WHETHER VIRT TRAP DESIRED.
;ALL RTNS WHICH CHANGE ETERRO, ETREDY OR INT-ENB MUST COME HERE.
ETINT:	MOVEI	A,ETINTB
	SKIPE	ETERRO		;IF ERROR THEN SET READY.
	SETOM	ETREDY
	MOVE	B,RTCCM
	TRNE	B,100		;IF READY&INT-ENB THEN INTERRUPT
	SKIPN	ETREDY
	JRST	QDEL		;ELSE WITHDRAW REQUEST.
	JRST	MTRNEW

ETINTB:	6			;PRIORITY.
	-1
	JRST	.+1
	MOVEI	T,214/4		;ADDR OF VECTOR.
	JRST	VTRAP		;CAUSE TRAP.
;COME HERE WHEN SELECTED DRIVE MOVES 1 BLK.
ETSEL:	CAIL	A,579.
	SKIPG	ETCDIR		;IF GOING FWD PAST END,
	JRST	.+2
	JRST	ETEND		;SET ENDZ ERROR.
	CAMG	A,[-2]
	SKIPL	ETCDIR		;ALSO IF GOING BACK PAST BEGINNING.
	JRST	.+2
	JRST	ETEND

	SKIPE	ETREDY		;IF READY SET,
	JRST	ETTRPX		;NO COMMAND TO PROCESS.

	LDB	T,[010300,,RTCCM]
	XCT	ETCMDT(T)	;PROCESS THE FUNCTION SPECIFIED.

ETCMDT:	.VALUE		;SAT FN SHOULDN'T COME HERE.
	JRST	ETRNUM
	JRST	ETRDAT
	JRST	ETRALL
	JRST	ETSST		;STOP SELECTED TAPE.
	JRST	ETWRTM		;WRTM FN ALWAYS ILLEGAL.
	JRST	ETWDAT		;WDATA FN.
	JRST	ETWALL		;WALL FN.

;READ BLOCK NUMBER FN. - (PUT IT IN TCDT).
ETRNUM:	JUMPL	A,ETTRPX	;IF POS. OUT OF RANGE,
	CAILE	A,577.
	JRST	ETTRPX		;WE'RE NOT COMING TO A BLOCK.
	HRRM	A,RTCDT		;STORE BLK. NUM.
	SETOM	ETREDY		;FN IS COMPLETED.
	SETOM	ETCIOP		;RDATA NOW OK.
	JRST	ETTRPY

;END ZONE - INDICATE ERROR AND STOP TAPE.
ETEND:	MOVEI	A,ETENDZ
	IORM	A,ETERRO

;STOP SELECTED TAPE FN.
ETSST:	SETZM	ETCUPS
	SETZM	ETCDIR
	SETOM	ETREDY
	JRST	ETINT

;ILLEGAL FNS COME HERE TO CAUSE ILO ERROR.
ETWRTM:		;WILL ALWAYS BE ILLEGAL.
ETWALL:		;MAY SOMEDAY BE LEGAL.
ETRALL:		;DITTO.
ETWDAT:		;SOON BE LEGAL.
	MOVEI	A,ETILO
	JRST	ETERR
ETRDAT:	SKIPN	ETCIOP		;IF NOT AFTER RDATA OR RNUM,
	JRST	ETBLM		;BLKM ERROR.
	CAME	B,ETDDIC	;IF THIS DRIVE'S DIR NOT IN BTAB,
	CALL	ETGBTB		;READ IT IN.
	MOVE	A,ETCFIL
	TLZN	A,1		;MAKE SURE THIS DRV READING ON ETC.
	CAME	B,ETDOPN
	CALL	ETOPEN
	MOVE	A,ETCPOS	;FIND ADDR. OF CURRENT BLOCK.
	SKIPE	A,ETBTAB(A)
	.ACCES	ETC,A		;IF REAL, -> IT.
	HRRZ	MA,RTCBA	;PDP11 ADDR TO STORE INTO.
	MOVNI	X,400		;DON'T READ >1 BLOCK.
	HRRZ	TT,RTCWC	;OR MORE THAN WANTED.
	ORCMI	TT,-200000
ETRDA0:	SKIPE	E,A		;USE REAL CONTENTS OR 0.
	.IOT	ETC,E
	SKIPGE	PDP11(MA)
	JSP	D,MTETWR	;MAYBE TRAP STORING.
	HRRM	E,PDP11(MA)
	ADDI	MA,2		;ADVANCE 1 WD.
	DPB	MA,[2000,,RTCBA]
	AOJ	TT,
	DPB	TT,[2000,,RTCWC]
	JUMPGE	TT,ETRDA1	;IF DID ALL REQUESTED, STOP.
	AOJL	X,ETRDA0	;AFTER WHOLE BLK, STOP.
ETRDA1:	SKIPL	TT
	SETOM	ETREDY		;UNLESS MORE BLKS TO GO.
	JRST	ETTRPY		;KEEP MOVING.

;READ IN DIR. OF CURRENT DRIVE.
ETGBTB:	MOVE	A,ETCFIL
	TLZN	A,1		;GET DRIVE OPEN FOR READING.
	CAME	B,ETDOPN
	CALL	ETOPEN
	.ACCES	ETC,[0]		;DIR. AT FRONT OF FILE.
	MOVSI	A,-2*578.
	.IOT	ETC,ETBTAB(A)
	AOBJN	A,.-1		;READ IN THE DIR.
	MOVEM	B,ETDDIC	;SAY HAVE THIS DRIVE'S DIR.
	RETURN

;OPEN CURRENT DRIVE, DIRECTION IN A.
ETOPEN:	MOVEM	A,ETCFIL
ETOPE1:	MOVE	A,ETCSNM
	.SUSET	[.SSNAM,,A]
	.OPEN	ETC,ETCFIL
	JRST	ETOPNL
	MOVEM	B,ETDOPN	;SAY THIS DRIVE IS OPEN.
	RETURN

ETOPNL:	TTOA	[ASCIZ/
DT FILE NOT FOUND, SUPERQUIT
SET FILE AND PROCEDE /]
	CALL	DDT
	JRST	ETOPE1
;DECTAPE COMMAND REGISTER.
TCCMHK:	TLNN	B,54000
	JRST	TCCMWR
	CALL	ETCCM		;IF READING, COMPUTE TCCM.
TCCMWR:	TLNN	B,22000
	RETURN
	XXWAIT
	HRRZ	A,RTCCM		;IF WRITING, SEE NEW VALUE.
	SKIPE	ETERRO
	TRNE	A,100000	;IF ERROR BIT WAS LOADED W/ 0,
	JRST	TCCM1
	MOVEI	T,ETENDZ+ETNEX+ETBLKM
	ANDCAM	T,ETERRO	;CLEAR SOME ERRORS.

TCCM1:	TRNN	A,1		;IF DO WASN'T SET, EXIT.
	JRST	ETINT
	MOVEI	T,ETSELE+ETILO
	ANDCAM	T,ETERRO	;CLEAR SOME ERRORS SINCE NEW FN.
	SETZM	ETREDY
	TRNN	A,16		;IF FN IS 0,
	JRST	ETSAT		;STOP ALL TAPES RIGHT NOW.
	LDB	B,[100300,,A]	;GET SELECTED UNIT'S NUM.
	MOVEM	B,ETUNIT	;STORE NUM. OF SELECTED UNIT.
	MOVE	B,ETUTAB(B)	;GET PTR--> INFO ON COR. DRIVE.
	MOVEM	B,ETDRIV	;SAY IT'S SELECTED DRIVE.
	JUMPLE	B,ETESEL	;IF DIDN'T SELECT UNIQUE DRIVE, SELE ERROR.
	SKIPN	ETCDIR		;IF DRIVE MOVING,
	JRST	ETSTRT
	HRRZS	ETCDIR		;SET L.H. TO NEW DIRECTION.
	TRNE	A,4000		;(TAPE WILL REVERSE ITSELF IF NEC.).
	HRROS	ETCDIR
	JRST	ETINT

;COME HERE IF TAPE NOT MOVING.
ETSTRT:	TRNN	A,4000
	AOSA	C,ETCDIR	;DIR _ IF FWD THEN 1 ELSE -1.
	SOS	C,ETCDIR
	ADDM	C,ETCPOS	;STARTING TAKES 2 BLKS.
	SETZM	ETCIOP		;RDATA NOT OK.
	MOVEI	A,(B)
	MOVE	C,TIME
	ADDI	C,ETSTIM	;GIVES TIME ET'LL HAVE STARTED.
	CALL	CTRDES
	JRST	ETINT

;COMPUTE TCCM.
ETCCM:	HRRZ	A,RTCCM		;INT-ENB KEPT IN RTCCM.
	ANDCMI	A,160201
	SKIPE	ETERRO
	IORI	A,100000	;GET ERROR BIT.
	SKIPE	ETREDY
	IORI	A,200		;GET READY BIT.
	HRRM	A,RTCCM
	RETURN
;DECTAPE STATUS REGISTER.
TCSTHK:	TLNN	B,54000
	RETURN			;WRITING HAS NO EFFECT.
	HRRZ	A,RTCST
	ANDI	A,3		;DATA EXTENSION BITS KEPT IN RTCST.
	IOR	A,ETERRO	;GET ERROR BITS.
	MOVE	B,ETDRIV
	JUMPLE	B,TCST0		;IF NO SELECTED DRIVE.
	SKIPE	ETCUPS
	IORI	A,200		;INDICATE IF SEL. DRIVE UP TO SPEED.
TCST0:	HRRM	A,RTCST
	RETURN

;RESET DECTAPE.
ZET:	SKIPN	WET
	RETURN			;...IF NOT ATTACHED.
	HLLZS	RTCWC		;ZERO THE REGS.
	HLLZS	RTCBA
	HLLZS	RTCDT
	HLLZS	RTCST
	HLLZS	RTCCM
	SETZM	ETERRO

;STOP ALL TAPES.
ETSAT:	MOVE	B,[-10,,ETDTAB]
ETSAT1:	HRRE	A,ETCDIR
	ADDM	A,ETCPOS	;STOPPING TAKES 1 BLK.
	SETZM	ETCDIR
	SETZM	ETCUPS
	SAVE	B
	MOVEI	A,(B)
	CALL	QDEL		;STOP THE CLOCK TRAPS FOR MOTION.
	REST	B
	ADDI	B,ETCLEN-1
	AOBJN	B,ETSAT1
	SETOM	ETREDY
	JRST	ETINT

;DETACH.
DET:	CALL	ZET
	SETZM	WET
	CALL	WRDZAP		;FLUSH THE REGS TO NXM.
	RTCST,,RTCDT
	RETURN

ETNXM0:	MOVEI	D,.+3		;RETURN AFTER JRST.
	MOVEM	D,-SAVLNG(P)
	JRST	RSTALL
	MOVEI	A,ETNEX
	IORM	A,ETERRO	;SET NXM ERROR.
	JRST	ETTRPX

;ATTACH DECTAPE.
CDT:
AET:	SKIPE	WET		;IF REGS NOT SET UP,
	JRST	AET0
	CALL	WRDINS		;SET THEM UP.
	RTCCM	(NTCCM+600000)
	RTCST	(NTCST+600000)
	RTCWC
	RTCBA
	RTCDT
	0
	SETOM	WET		;INDICATE THEY'RE SET UP.
	CALL	ZET		;INITIALIZE THEM.
AET0:	MOVEI	T3,(DL)		;IF WAS ARG, SELECT THAT DRIVE.
	TLNN	SF,NUMFND
	SETO	T3,		;ELSE NO DRIVE SELECTED.
	SETZM	AETCRP
	SETZM	AETLFL
	CALL	GPASST		;IF NO CMDS ON THIS LINE
	CAIE	T0,^M
	JRST	AET2
	SETOM	AETLFL		;READ SEVERAL.
AET1:	CALL	GPASST
	CAIE	T0,^M
	SETZM	AETCRP		;CLEAR AFTER NON-CR.
	CAIN	T0,^M
	JRST	AETCR
AET2:	CAIN	T0,",
	JRST	AET1		;IGNORE SPACE, COMMA, CR.
	CALL	DGSYM		;READ NAME OF OPTION.
	HLLZS	T2		;TRUNCATE TO 3 CHARS.
	JUMPE	T2,ETOERR	;ERROR IF NO SYMBOL.
	MOVSI	T5,-ETONUM	;AOBJN PTR -> OPTION.
	AOJ	T5,
	CAME	T2,ETOTAB-1(T5)
	AOBJN	T5,.-2		;SEARCH TABLE FOR SYMBOL READ.
	JUMPGE	T5,ETOERR	;ERROR IF CAN'T FIND SYMBOL.
	CALL	@ETOTAB(T5)	;CALL RTN FOR OPTION.
	CALL	ETOFIN		;RECOMPUTE DRIVE ASSIGNMENTS.
	TLO	SF,D1CHAR	;WILL MAKE GPASST ACT LIKE PASSPS.
	JRST	AET1

ETOTAB:		;LIST OF DT OPTIONS.
IRP X,,[BLOCK,DONE,DRIVE,DSTAT,ENABLE,FILE,LIST,LOCK
NEW,OFF,RESET,RO,STATUS,STOP,SUNIT,UNIT,WE,WL]
	(SIXBIT/   X/)	;USE 1ST 3 CHARS ONLY.
	ETO!X
TERMIN
ETONUM=<.-ETOTAB>/2

ETOERR:	ERROR	[ASCIZ/BAD OPTION/]

AETCR:	SKIPN	AETLFL		;IF END OF 1ST LINE,
	SKIPE	AETCRP		;OR 2ND CR IN ROW,
	RETURN
	SETOM	AETCRP		;ELSE GOT 1ST CR.
	JRST	AET1

AETLFL:	0
AETCRP:	0
; STATUS OPTION -- GIVES STATUS OF ALL DRIVES.
ETOSTA:	CRF
	TTOA	ETSMSG
	SAVE	T3
	SETZ	T3,
	CALL	ETODS1		;PRINT STATUS OF EACH DRIVE
	CAIGE	T3,ETNDRV-1
	AOJA	T3,.-2		;UNTIL ALL DONE.
	REST	T3
	CRF
	RETURN

; DSTAT OPTION -- STATUS OF CHOSEN DRIVE. FINISHES.
ETODST:	TTOA	ETSMSG
ETODS1:	CALL	ETOGDV		;SET UP FOR SELECTED DRIVE.
	SAVE	SF
	TLO	SF,DNUMM
	TTOA	[ASCIZ/  /]
	SYMTYP	T3		;PRINT DRIVE NUM.
	TTOI	^I
	SKIPGE	T5,ETCUNI	;PRINT CORR. UNIT NUM.
	TTOA	2,[ASCIZ/ OFF/]
	TTOA	[ASCIZ/  /]
	SYMTYP	T5
	CAMN	B,ETDRIV
	TTOA	[ASCIZ/ */]	;IF SELECTED, SAY SO.
	TTOI	^I
	HRRZ	T5,ETCPOS	;PRINT TAPE POSITION.
	TTOA	[ASCIZ/  /]
	SYMTYP	T5
	TTOI	^I
	SKIPN	ETCENA		;SAY WHETHER WRITE-ENABLED.
	TTOA	1,[ASCIZ/WL /]
	TTOA	[ASCIZ/WE /]
	SKIPN	ETCDIR
	TTOA	3,[ASCIZ/STOP	/]	;IF DRIVE NOT MOVING.
	SKIPL	ETCDIR
	TTOA	1,[ASCIZ/FWD	/]	;IF FORWARD.
	TTOA	[ASCIZ/BACK	/]	;IF BACKWARD.
	HRLZ	T5,ETCFIL	;GET DEV. NAME.
	6TYPE	T5		;PRINT DEV. NAME,
	TTOI	":
	6TYPE	ETCSNM		;SNAME.
	SKIPE	ETCSNM
	TTOI	";
	6TYPE	1+ETCFIL	;FILENAMES.
	TTOI	" 
	6TYPE	2+ETCFIL
	CRF
POPSFJ:	REST	SF
	RETURN

ETSMSG:	ASCIZ/DRIVE	UNIT	POS.	W? DIR	FILE
/
; BLOCK OPTION - MOVE DECTAPE TO SPECIFIED POSITION.
ETOBLO:	CALL	ETOARG
	-20.,,600.		;LIMITS ON RANGE OF VALID ARGS.
	CALL	ETOGDV		;MAKE SURE DRIVE CHOSEN.
	MOVEM	T2,ETCPOS	;SET THAT DRIVE'S POSITION.
	SETZM	ETCDIR
	JRST	ETOST1		;STOP THE DRIVE (WAS PUT ON LOCAL).

; DRIVE OPTION -- CHOSE A SPECIFIC DRIVE.
ETODRI:	CALL	ETOARG		;READ ARG.
	0,,ETNDRV
	MOVEI	T3,(T2)		;SET DRIVE NUM.
	RETURN

; ENABLE OPTION (ALSO WE) -- ENABLE WRITING.
ETOENA:
ETOWE:	CALL	ETOGDV
	SETOM	ETCENA		;WRITE-ENABLE.
	RETURN

; LOCK OPTION (ALSO RO, WL) -- LOCK OUT WRITING.
ETOLOC:
ETORO:
ETOWL:	CALL	ETOGDV
	SETZM	ETCENA
	RETURN

; FILE OPTION -- SET FILE ASSOCIATED WITH DRIVE. STOPS DRIVE.
ETOFIL:	CALL	ETOGDV
	MOVEI	A,ETCFIL
	SAVE	B
	SAVE	T3
	CALL	DGFIL		;READ FILE NAME.
	REST	T3
	REST	B
	.SUSET	[.RSNAM,,A]
	MOVEM	A,ETCSNM	;SET SNAME TOO.
	CAMN	B,ETDDIC	;IF THIS DRIVE'S DIR WAS IN,
	SETZM	ETDDIC		;NO LONGER.
	CAME	B,ETDOPN
	RETURN
	SETZM	ETDOPN
	.CLOSE	ETC,
	RETURN

; OFF OPTION -- SET OFFLINE (NOT ASSIGNED TO ANY UNIT).
ETOOFF:	CALL	ETOGDV
	SETOM	ETCUNI
	SETOM	ETNFIN		;HAVE CHANGED UNIT ASSIGNMENTS.
	RETURN

; STOP OPTION -- STOP DRIVE.
ETOSTO:	CALL	ETOGDV
ETOST1:	HRRE	A,ETCDIR	;STOPPING TAKES 1 BLOCK.
	ADDM	A,ETCPOS
	SETOM	ETNFIN		;INDICATE FINISHING NEEDED.
	SETZM	ETCDIR		;SAY ISN'T MOVING.
	SETZM	ETCUPS
	MOVEI	A,(B)
	JRST	QDEL		;STOP TRAPS FOR ITS MOTION.
; SUNIT OPTION -- SET UNIT ASSIGNMENT.
ETOSUN:	CALL	ETOARG
	0,,7
	CALL	ETOGDV		;SET UP CHOSEN DRIVE.
	HRRZM	T2,ETCUNI	;SET UNIT NUM. WORD.
	SETOM	ETNFIN		;MUST RECOMPUTE UNIT-ASSIGNMENTS.
	RETURN

; UNIT OPTION -- CHOSE DRIVE WITH SPECIFIED UNIT NUM. MUST FINISH.
ETOUNI:	CALL	ETOFIN		;SO CAN KNOW WHICH DRIVE GOES WITH UNIT.
	CALL	ETOARG
	0,,7
	SKIPN	T2,ETUTAB(T2)	;GET -> INFO FOR CORRSP. DRIVE.
	ERROR	[ASCIZ/DRIVE NOT UNIQUE/]
	SKIPG	T2
	ERROR	[ASCIZ/UNIT HAS NO DRIVE/]
	SUBI	T2,ETDTAB	;COMPUTE DRIVE NUM. FROM PTR.
	IDIVI	T2,ETCLEN
	MOVEI	T3,(T2)
	RETURN

; RESET OPTION -- STOP ALL TAPES, ETC.
ETORES==ZET

; LIST OPTION -- LIST NAMES OF OPTIONS.
ETOLIS:	MOVE	T1,[-ETONUM,,ETOTAB]
	JRST	CLCOMS

; NEW OPTION -- UN-CHOSE THE CHOSEN DRIVE, CAUSE NEW DRIVE
;  TO BE CHOSEN NEXT TIME ONE'S NEEDED.
ETONEW:	SETO	T3,
	RETURN

;READ IN AN ARG, SAVING T3. ERROR IF NO ARG OR REGISTER.
;	CALL	ETOARG
;	LOW,,	HIGH		;RANGE OF ADMISSIBLE VALUES.
ETOARG:	SAVE	T3
	CALL	DGVPSP		;TRY READING VALUE.
	REST	T3
	SKIPN	DGVALP
	ERROR	[ASCIZ/NO ARG/]
	TLNE	T2,REGBIT
	ERROR	[ASCIZ/ACCUM./]
	HRREI	T2,(T2)		;EXTEND ARG TO FULL WORD.
	HLRE	T5,@(P)		;LOW END OF RANGE,
	HRRE	T6,@(P)		;HIGH END.
	CAML	T2,T5
	CAILE	T2,(T6)
	ERROR	[ASCIZ/ARG OUT OF RANGE/]
	AOS	(P)
	RETURN
; FINISH OPTION -- RECOMPUTE CORRESPONDENCE BETWEEN DRIVES AND UNITS.
;IF THE SELECTED DRIVE'S UNIT HAS CHANGED, OR IT HAS BEEN STOPPED,
;AND READY IS OFF, A SELECTION ERROR IS CAUSED.
;EXITS TO ETINT ALWAYS SINCE MIGHT HAVE CHANGED READY OR ERROR.
ETOFIN:	SKIPN	ETNFIN
	RETURN			;IF NOTHING TO DO. ELSE,
	SETZM	ETNFIN		;INDICATE HAVE FINISHED.
	MOVSI	T5,-10
	SETOM	ETUTAB(T5)	;SO FAR, EACH UNIT HAS NO DRIVES.
	AOBJN	T5,.-1
	MOVE	B,[-ETNDRV,,ETDTAB]
ETOX0:	SKIPGE	T5,ETCUNI	;IF DRIVE OFFLINE, SKIP IT.
	JRST	ETOX1
	SKIPL	ETUTAB(T5)	;IF ITS UNIT HAS A DRIVE ALREADY,
	SETZM	ETUTAB(T5)	;IT NOW HAS >1, NOT SELECTABLE.
	SKIPGE	ETUTAB(T5)	;OTHERWISE IT HAS 1 DRIVE (THIS ONE).
	HRRZM	B,ETUTAB(T5)
ETOX1:	ADDI	B,ETCLEN-1
	AOBJN	B,ETOX0
	SKIPGE	T5,ETUNIT	;IF A UNIT IS SELECTED,
	JRST	ETINT
	MOVE	B,ETUTAB(T5)
	EXCH	B,ETDRIV	;UPDATE SELECTED DRIVE.
	CAMN	B,ETDRIV	;IF IT HAS CHANGED,
	JRST	ETOX2
ETOX3:	SKIPE	ETREDY		;IF WERE IN MIDDLE OF DT OPERATION,
	JRST	ETINT
	SETOM	ETUNIT		;INDICVATE NONE SELECTED,
	SETOM	ETDRIV
	TTOA	[ASCIZ/CAUSED SELE ERROR
/]
ETESEL:	MOVEI	A,ETSELE	;CAUSE ERROR.
	JRST	ETERR

ETOX2:	SKIPE	ETCDIR		;IF DRIVE STILL SAME, BUT HAS BEEN STOPPED,
	JRST	ETINT
	JRST	ETOX3		;MAY ALSO CAUSE SELE ERROR.

;MAKE SURE A DRIVE HAS BEEN CHOSEN. IF NOT, CHOSE AN OFFLINE DRIVE.
;SET B UP -> INFO ON DRIVE.
ETOGDV:	JUMPGE	T3,ETOGD2	;IF DRIVE ALREADY CHOSEN.
	MOVSI	T3,-ETNDRV
	MOVEI	B,ETDTAB	;ELSE SEARCH THRU ETDTAB
ETOGD0:	SKIPGE	ETCUNI		;FOR A DRIVE THAT'S OFFLINE.
	JRST	ETOGD1		;IF FOUND.
	ADDI	B,ETCLEN	;ELSE TRY NEXT ONE.
	AOBJN	T3,ETOGD0
	ERROR	[ASCIZ/WHAT DRIVE/]	;IF ALL ONLINE.

ETOGD1:	MOVEI	T3,(T3)		;T3, B BOTH SET UP NOW.
	RETURN

ETOGD2:	MOVEI	B,(T3)		;COMPUTE B FROM T3.
	IMULI	B,ETCLEN
	ADDI	B,ETDTAB
	RETURN

;BLOCK FORMAT
;WD1 TIME OR PRIORITY
;WD2 -1=IDLE, ELSE LINK
;WD3 INST TO XCT

;10 PS
;7 PC
;6 OTHER
;5 MEM TRAP
;4 TT
;3 PDLOV
;2 STOP
TRQADD:	SKIPL 1(A)	;TRAP QUEUE ADD
	RETURN	;ALREADY IN QUEQUE
	MOVEM C,(A)
TRQQA:	MOVEI B,TRINF
	TLZ A,-1
QADD:	MOVE C,B
	MOVE B,1(C)
	MOVE T,(B)
	CAML T,(A)
	JRST QADD
	MOVEM A,1(C)
	MOVEM B,1(A)
	RETURN

CLQADD:	SKIPL 1(A)	;CLOCK QUEUE ADD
	RETURN	;ALREADY IN QUEQUE
	MOVEI B,CLINF
	MOVEM C,(A)
	TLZ A,-1
QADD2:	SETOM QFLAG
	MOVE C,B
	MOVE B,1(C)
	MOVE T,(B)
	CAMGE T,(A)
	JRST QADD2
	MOVEM A,1(C)	;MAKE PREV POINT TO NEW
	MOVEM B,1(A)	;MAKE NEW POINT TO NEXT
	SETZM QFLAG
	RETURN

QDEL:	SKIPGE 1(A)	;QUEUE ITEM DELETE
	RETURN	;ALREADY IDLE
	MOVE B,A
QDEL2:	MOVE C,B
	MOVE B,1(C)
	CAIN B,CLINF
	SETOM QFLAG
	CAME B,A
	JRST QDEL2
	MOVE B,1(A)
	SETOM 1(A)
	MOVEM B,1(C)
	SETZM QFLAG
	RETURN

TRINF:	-1	;ROOT OF TRAP QUEUE
	TRINF
	.VALUE

CLINF:	377777,,	;ROOT OF CLOCK QUEUE
	CLINF
	TTOA [ASCIZ /
THIS PROGRAM HAS REACHED THE AGE OF MANDATORY RETIRMENT/]

PDL:	BLOCK PDLSIZ
	BLOCK 20	;SO PDL OVERFLOW DOESN'T CLOBBER THINGS
PAT:
PATCH:	BLOCK 100

TYOFLG:	-1	;OUTPUT TO TTY
LPTFLG:	0	;OUTPUT TO LPT
LPTCNT:	0	;NUM TIMES LPT OPEN
QFLAG:	0	;IN CLQADD OR QDEL FOR CLQUEUE
RUN:	0
TRPPNT:	1	;TPV
	BLOCK TRPPTL-1
INVTRP:	0	;IN VTRAP
QA:	0
QD:	0
QT:	0
RTIME:	0
CONSTANTS

RNGCSR=PDP11+72020	;NG DIS
RNGREL=PDP11+72021

RPKCSR=PDP11+75260	;KW11 PROGRAMMABLE CLOCK
RPKCSB=PDP11+75261
RPKC=PDP11+75262

RRCSR=PDP11+76000	;DC11 ASYNCHRONOUS LINE INTERFACE
RRBUF=PDP11+76001
RTSCR=PDP11+76002
RTBUF=PDP11+76003

RCSR=PDP11+76400	;DM11 ASYNCHRONOUS 16-LINE SINGLE SPEED INTERFACE
RBAR=PDP11+76401
RBCR=PDP11+76402
RTBR=PDP11+76403

RDIV=PDP11+77540	;EAE
RAC=PDP11+77541
RMQ=PDP11+77542
RMUL=PDP11+77543
RSCSR=PDP11+77544
RNOR=PDP11+77545
RLGS=PDP11+77546
RARS=PDP11+77547

RTCST=PDP11+77560	;777340		DECTAPE
RTCCM=PDP11+77561	;777342
RTCWC=PDP11+77562	;777344
RTCBA=PDP11+77563	;777346
RTCDT=PDP11+77564	;777350

RRKDS=PDP11+77600	;RK11 DSK
RRKER=PDP11+77601
RRKCS=PDP11+77602
RRKWC=PDP11+77603
RRKBA=PDP11+77604
RRKDA=PDP11+77605
RRKMR=PDP11+77606
RRKDB=PDP11+77607

RDCS=PDP11+77630	;RF11/RS11 DSK
RWC=PDP11+77631
RCMA=PDP11+77632
RDAR=PDP11+77633
RDAE=PDP11+77634
RDBR=PDP11+77635
RMA=PDP11+77636
RADS=PDP11+77637

RLPS=PDP11+77646
RLPB=PDP11+77647
RLKS=PDP11+77663
RPRS=PDP11+77664
RPRB=PDP11+77665
RPPS=PDP11+77666
RPPB=PDP11+77667
RTKS=PDP11+77670
RTKB=PDP11+77671
RTPS=PDP11+77672
RTPB=PDP11+77673
RSWR=PDP11+77674

RCSX=PDP11+77750	;& NEXT TWO WORDS

RATE=PDP11+77774
RPIR=PDP11+77775	;11/45
;77776 = 11/45 STACK LIMIT NOT IMPLEMENTED
RPS=PDP11+77777
;DEFINE  ACCUMULATORS
	I1=4
	SF=5
	DO=6		;IF POSITIVE, VIRT. ADDRESS OF OPEN LOC.
	DL=7		;HOLDS %Q OR ARG.
	T0=10		;HOLDS LAST CHAR, EXCEPT IN INSN PRINTING.
	T1=11		;TEMP FOR INST HANDLERS
	T2=12		;USED BY ADDRESS COMPUTATION RTNS.
	T3=13
	DLEN=14		;HOLDS LENGTH OF %Q OR ARG IN WORDS.
	T5=15		;EXTREMELY TEMPORARY.
	T6=16		;  "    "    "    " .

.XCREF SF,DL,T0,T1,T2,T3,T5,T6

;FLAGS IN SFLAGS, LEFT HAND SIDE

DBYTM==200000	;REGISTER OPEN IN BYTE MODE.
DEXCM==100000	;IN DON'T PRINT CONTENTS MODE.
DINSM==40000	;PRINT AS INSTRUCTION.
DSYMM==20000	;PRINT NUMBERS, ADDRESSES SYMBOLICALLY.
DASCM==10000	;PRINT NUMBERS AS ASCII.
DNUMM==4000	;PRINT NUMBERS NUMERICALLY. ABOVE DSYMM.
DDECM==2000	;WHEN PRINTING NUMERICALLY, USE BASE 10. .
DREGM==1000	;PRINT REGISTER NUMS NUMERICALLY.
DDSKM==400	;OPEN NEXT LOC AS DISK ADDR.
NUMFND==200	;SET AT ENTRY TO COMMAND IF HAS ARG.
DSEMFL==100	;IF SET, RUBBING-OUT SHOULD BE STOPPED BY NON-DIGITS.
CSSFLG==40	;SET DURING ;S -- CAUSES INPUT FROM LOADCH.
D1CHAR==20	;RE-READ THE CHAR IN T0, IN NEXT GETCHR.
BYTOPN==10	;CURRENTLY OPEN LOC. IS BYTE.
DSKOPN==4	;CURRENTLY OPEN LOC. IS IN DISK.

DMODES==DBYTM+DEXCM+DINSM+DSYMM+DASCM+DNUMM+DDECM+DREGM+DDSKM

	JRSTF==JRST	2,0
	IF2 CDDT==CALL DDT	;USED FROM HACTRN WITH $X.
	IF2 GETCHR==CALL DGCHR	;NEXT INPUT CHAR, IN DDT.

;FLAG IN AC CONTAINING ADDRESS (IN DDT)
REGBIT==1	;INDICATES ADDR. IS REGISTER NUM.
.5KBIT==400000	;INDICATES .5KILLED SYMBOL .
XREGTY:	TLNE	SF,DREGM
	JRST	XREGT1
	SKIPN	XSYMTA
	TLNN	SF,DNUMM
	TLNN	SF,DSYMM
	JRST	XREGT1		;IF SHOULDN'T PRINT SYMBOL.
	HRLI	B,1		;TYPE-CODE FOR REG. SYM.
	HRRZ	A,SYMEND
XREGT0:	CAME	B,1(A)		;IF THIS STE'S VALUE IS REG. TO TYPE,
	JRST	XREGT5
	6TYPE	(A)		;PRINT NAME OF SYMBOL.
	JRST	UUOXIT
XREGT5:	SUBI	A,2
	CAIE	A,SYMDRG	;NO NEED TO CHECK INSNS AND %1...%7 .
	JRST	XREGT0
XREGT1:	SKIPN	XREGTF		;NO SYMBOL, PRINT NUMERICALLY.
	TTOI	"%		;INDICATE IS REG. UNLESS TOLD NO NEED TO.

XNUMTY:	ANDI	B,-1
	MOVEI	C,DECP
	TLNN	SF,DDECM	;IF DECIMAL, CALL DECP,
	MOVEI	C,OCTP
	PUSHJ	P,(C)		;CALL PRINT RTN.
	TLNE	SF,DDECM	;IN DECIMAL MODE, PRINT ".".
	TTOI	".
	JRST	UUOXIT

XASCTY:	CAILE	B,377		;1 CHAR?
	JRST	XASCT1		;NO, 2.
	TTOI	"'		;1.
	TTOI	(B)		;PRINT IT.
	JRST	UUOXIT
XASCT1:	TTOI	""		;2 CHARS.
	TTOI	(B)		;PRINT 1ST (LOW) CHAR.
	LSH	B,-10
	JRST	XASCT1-2

XREGTF:	0		;IF #0, OK TO OMIT % WHEN PRINTING REG. VAL.
XSYMTA:	0
;PRINT AN ADDRESS SYMBOLICALLY:
XADRTY:	SETOM	XSYMTA		;INDICATE ADRTYP.
	JRST	.+2

;PRINT NUMBER IN CURRENT MODE.
XSYMTY:	SETZM	XSYMTA
	MOVE	B,(A)		;WORD TO PRINT.
	TRZ	B,600000
	TLNE	B,REGBIT	;IF REGISTER NUM, SPECIAL HANDLING
	JRST	XREGTY
	SKIPE	XSYMTA		;IF NOT PRINTING ADDRESS TO OPEN,
	JRST	XSYMT3
	TLNE	SF,DNUMM	;CHECK FOR NUMERIC AND ASCII MODES.
	JRST	XNUMTY
	TLNE	SF,DASCM
	JRST	XASCTY
XSYMT3:	TLNN	SF,DSYMM	;IF NOT IN SYMBOLIC MODE,
	JRST	XNUMTY		;PRINT NUMERICALLY.
	ANDI	B,-1
	PUSH	P,T
	PUSH	P,D		;NAME OF BEST SYMBOL SO FAR.
	PUSH	P,E		;VALUE OF BEST SYMBOL SO FAR.
	SETZ	D,		;NO SYMBOL FOUND.
	SETO	E,		;BEST SYMBOL'S VALUE IS -1.
	HRRZ	C,SYMEND
XSYMT0:	SKIPL	T,1(C)		;ONLY NON-.5KILLED NORMAL SYMBOLS O.K.
	TLNE	T,-1
	JRST	XSYMT1
	CAIG	T,(B)		;ACCEPTABLE ONLY IF <= NUM. TO BE PRINTED.
	CAIL	E,(T)		;CLOSER THAN BEST SO FAR?
	JRST	XSYMT1
	MOVE	D,(C)		;YES, REPLACE BEST SO FAR'S NAME, VALUE.
	MOVEI	E,(T)
XSYMT1:	SUBI	C,2		;SEARCH TABLE BACKWARDS TO GET USER
	CAIL	C,SYMDRG	;SYMBOLS BEFORE PREDEFINED ONES.
	JRST	XSYMT0
	JUMPE	D,XSYMT2	;IF NO SUITABLE SYMBOL, PRINT NUMERICALLY.
	CAIL	B,200(E)	;IF >200 BEYOND SYMBOL, DITTO.
	JRST	XSYMT2
	SUB	B,E		;OFFSET FROM SYMBOL.
	6TYPE	D
	JUMPE	B,XSYMT4	;IFF OFFSET, --
	TTOI	"+
XSYMT2:	TLO	B,200000	;NO SYMBOL- MAKE SURE TYPE ADDR. EVEN IF 0.
XSYMT4:	POP	P,E
	POP	P,D
	POP	P,T
	JUMPE	B,UUOXIT
	JRST	XNUMTY		;PRINT OFFSET IF ANY.

;GET NEXT INPUT CHAR. OUT OF LINE BUFER.
;IF BUFFER EMPTY, READ+ECHO UNTIL BREAK CHAR.
DGCHR1:	PUSHJ	P,DGLIN		;READ & ECHO LINE.
DGCHR:	TLZE	SF,D1CHAR	;IF SET, REREAD CHAR. IN T0.
	RETURN
	SETZM	DGLCQF
DGCHR0:	SKIPE	FILINF		;IF :XFILING,
	JRST	DGCHRF		;READ FROM UTIC.
	SOSGE	DGLCNT		;COUNT CHARS. IN BUFFER.
	JRST	DGCHR1		;IF NONE LEFT, GET NEW LINE.
	ILDB	T0,DGLPTR	;GET NEXT CHAR.
DGCHR2:	CAIN	T0,^Q		;IF CHAR IS ^Q,
	SKIPE	DGLCQF		;NOTQQUOTED BY PREV. ^Q,
	RETURN
	SETOM	DGLCQF		;INDICATE NEXT CHAR IS QUOTED,
	JRST	DGCHR0		;READ IT.

DGCHCS:
DGCHRF:	.IOT	UTIC,T0
	MOVEI	T0,(T0)
	TTOI	(T0)		;ECHO.
	CAIE	T0,^J
	JRST	.+3
	SKIPE	DGCHRC		;FLUSH LF'S AFTER CR'S IN FILES.
	JRST	DGCHRF
	SETZM	DGCHRC
	CAIN	T0,^M
	SETOM	DGCHRC		;INDICATE HAD CR AS LAST CHAR.
	CAIN	T0,^C		;IF EOF, GO BACK TO TTY.
	JRST	DGCHCC
	SKIPE	DGLCQF		;IF CHAR NOT ^Q-QUOTED,
	JRST	DGCHR2
IRPC CHAR,,BEWVS
	CAIN	T0,^CHAR	;CHECK FOR IO CTL CHARS
	JRST	DGCHC!CHAR
TERMIN
	JRST	DGCHR2

DGCHCB:	CALL	DGLNCB		;OPEN LPT.
	JRST	DGCHCS
DGCHCE:	CALL	DGLNCE		;END OUTPUT TO LPT.
	JRST	DGCHCS
DGCHCV:	SETOM	TYOFLG		;TURN ON TTY OUTPUT.
	JRST	DGCHCS
DGCHCW:	SETZM	TYOFLG		;TURN IT OFF.
	CALL	TRESET
	JRST	DGCHCS
DGCHCC:	.CLOSE	UTIC,		;ON EOF, CLOSE FILE,
	SETZM	FILINF
	JRST	DGCHR		;AND GO BACK TO TTY.

ETODON:
POP1J:	SUB	P,[1,,1]
	RETURN
;READ FROM TTY UP TILL ACTIVATION NECESSARY,
;PROCESSING RUBOUTS UNTIL THEN.
;WHEN DONE, RETURN WITH DGLCNT=NUM CHARS,
;DGLPTR=B.P. TO CHARS.
DGLIN:	PUSH	P,T1
	SETZM	DGLRCT
	MOVE	T1,[440700,,DGLBUF]	;INITIAL B.P.
	MOVEM	T1,DGLPTR	;USED TO STORE CHARS.
	MOVE	T1,DGLINF
	MOVEM	T1,DGLINS
DGLRB0:	SETZM	DGLCNT		;RE-INIT. AFTER RUBOUT, THEN RE-READ.
	SETZM	DGLNQC
	SETZM	DGLCQF		;1ST CHAR NOT ^Q'D.
	TLZ	SF,DSEMFL
	SETZM	DGLALF
	.CALL	TTYM1
	.VALUE

DGLIN1:	SETZM	DGLCQF		;NORMALLY, CHAR NOT ^Q-QUOTED.
DGLIN0:	SKIPN	DGLRCT		;IF CHARS LEFT BEFORE RUBOUT,
	JRST	DGLIN2
	ILDB	T0,DGLRBP	;RE-READ THEM.
	SOSG	DGLRCT		;IF THE LAST CHAR LEFT
	SKIPE	DGLCQF		;IS AN UN-^Q-QUOTED ^Q,
	JRST	DGLIN3
	CAIE	T0,^Q		;IT HAD QUOTED THE CHAR RUBBED OUT,
	JRST	DGLIN3
	TTOI	^Q		;SO RUB OUT THE ^Q, TOO.

DGLIN2:	TLNE	SF,DSEMFL	;IF AFTER A ';',
	.CALL	TTYMA		;ACTIVATE ON EACH CHARACTER.
	JFCL
	.IOT	TYIC,T0		;ELSE, READ NEW CHAR.

;NOW DECIDE WHAT TO DO WITH THE CHAR. JUST READ.
DGLIN3:	SKIPE	DGLCQF		;UNLESS CHAR WAS ^Q-QUOTED,
	JRST	DGLIT5
	CAIN	T0,^Q		;PROCESS ^Q,
	JRST	DGLCTQ
	CAIN	T0,177		;RUBOUT SPECIALLY.
	JRST	DGLRUB
DGLIT5:	SKIPE	DGLNQC		;NEXT THREE TESTED EVEN IF ^Q-QUOTED:
	JRST	DGLQTD		;IF QUOTED BY ' OR ".
	SKIPE	DGLALF
	JRST	DGLAL1		;IF AFFECTED BY PREV. ALTMODE.
	TLNE	SF,DSEMFL
	JRST	DGLSM1		;IF AFTER UNQUOTED ";".
	CAILE	T0,"Z
	JRST	DGLIT6
	SKIPN	DGLCQF
	CAIL	T0,"A		;ELSE DON'T BOTHER TESTING
	JRST	DGLREG		;ALPHABETIC CHARS, ^Q-QUOTED CHARS.
DGLIT6:	SKIPE	DGLINF
	JRST	DGLIT2		;IN LINE MODE ^M IS ONLY BREAK CHAR.
;NORMAL BREAK CHARS:
	CAIE	T0,"[
	CAIN	T0,"]
	JRST	DGLBK
	CAIN	T0,^]
	JRST	DGLBK
IRP C1,,[^L,^N,"/,"=,"_]C2,,[^\,^P,^I,^J,"^]
	CAIE	T0,C1
	CAIN	T0,C2
	JRST	DGLBK
TERMIN
	CAIN	T0,"'
	JRST	DGLQUO		;QUOTES NEXT CHAR.
	CAIN	T0,""
	JRST	DGL2Q		;QUOTES 2 CHARS.
	CAIN	T0,":
	JRST	DGLCOL		;ENTERS LINE MODE TO READ COMMAND.
	CAMN	T0,SEMICL
	JRST	DGLSEM		;READS NUMBER, THEN LETTER.
	CAMN	T0,ALTMOD
	JRST	DGLALT		;QUOTES ALL CHARS EXCEPT ALTMODE.
DGLIT2:	CAIN	T0,^M
	JRST	DGLBK

;THESE CHARS ARE TESTED FOR IN ALL STATES
;EXCEPT WHEN ^Q-QUOTED.
DGLIT3:	SKIPN	DGLCQF
	JRST	DGLIT4		;IGNORE IF ^Q QUOTED.
	CAIN	T0,^S
	JRST	DGLCTS		;^S TURNS OUTPUT BACK ON WHEN READ.
	CAIE	T0,^B
	CAIN	T0,^E
	JRST	DGLIN1		;^B, ^E, ^W, ^V SIGNIF. ONLY AT
	CAIE	T0,^V		;INTERRUPT LEVEL,
	CAIN	T0,^W		;IGNORED HERE.
	JRST	DGLIN1
DGLIT4:	TLNE	SF,DSEMFL	;AFTER A ";", ALL NORMAL CHARS
	JRST	DGLBK		;ARE BREAK CHARS.
	SETZM	DGLALF
	JRST	DGLREG
;ROUTINES TO HANDLE VARIOUS TYPES OF CHARS.

DGL2Q:	AOS	DGLNQC		;INSERT, QUOTE NEXT 2 CHARS.
DGLQUO:	AOSA	DGLNQC		;QUOTE ONLY 1 CHAR.
DGLQTD:	SOS	DGLNQC		;THIS CHAR IS QUOTED.
DGLREG:	SETZM	DGLCQF		;TURN OFF AFTER OTHER THAN ^Q.
	SKIPA
DGLCTQ:	SETOM	DGLCQF		;^Q - INDICATE NEXT CHAR ^Q-QUOTED.
	AOS	DGLCNT
	IDPB	T0,DGLPTR
	JRST	DGLIN0

; ^S - TURN ON TYPOUT, PASS IT BY.
DGLCTS:	SETOM	TYOFLG
	JRST	DGLIN1

;BREAK CHAR - INSERT AND EXIT.
DGLBK:	AOS	DGLCNT
	IDPB	T0,DGLPTR
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLPTR	;SET UP PTR FOR UNPACKING.
	SETZM	DGLINF
DGLINX:	POP	P,T1
	RETURN

; ";" - ALL EXCEPT DIGITS, " ", "." ARE BREAK CHARS.
DGLSEM:	TLO	SF,DSEMFL
	JRST	DGLREG		;INSERT THE ";".


DGLSM1:	CAIN	T0,"-
	JRST	DGLREG
	CAIE	T0," 
	CAIN	T0,".
	JRST	DGLREG
	CAIL	T0,"0
	CAILE	T0,"9
	JRST	DGLIT3	;NON-DIGIT, IGNORE OR BREAK.
	JRST	DGLREG

DGLCOL:	SETOM	DGLINF		;":" - READ UNTIL CR.
	JRST	DGLREG
;COME HERE IF CHAR AFFECTED BY PREVIOUS ALTMODE.
DGLAL1:	CAIN	T0,"-
	JRST	DGLALT		;- SIGN DOESN'T END TYPEOUT MODE CMD.
	CAME	T0,ALTMOD
	JRST	DGLIT3
DGLALT:	SETOM	DGLALF
	JRST	DGLREG

;COME HERE TO HANDLE RUBOUT.
DGLRUB:	SOSGE	T1,DGLCNT	;NUM. CHARS NOT RUBBED.
	JRST	DERR		;IF NO CHAR TO RUB.
	MOVEM	T1,DGLRCT	;RE-READ THOSE CHARS.
	LDB	T0,DGLPTR
	TTOI	(T0)		;ECHO RUBBED CHAR.
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLRBP	;PTR FOR RE-READING.
	MOVEM	T1,DGLPTR
	MOVE	T1,DGLINS	;RESTORE INITIAL DGLINF.
	MOVEM	T1,DGLINF
	JRST	DGLRB0

DGLNQC:	0		;NUM. OF NEXT CHARS TO QUOTE.
DGLRBP:	0		;B.P. FOR RE-READING AFTER RUBOUT.
DGLRCT:	0		;NUM. CHARS TO RE-READ.
DGLCNT:	0		;NUM. CHARS READ.
DGLPTR:	0		;B.P. FOR STORING CHARS READ.
DGLINF:	0		;IF SET, READ UNTIL CR.
DGLINS:	0		;SAVES INITIAL VALUE OF DGLINF.
DGLALF:	0		;SET AFTER ALTMODE.
DGCHRC:	0		;NONZERO IF FILINF AND LAST CHAR WAS CR.
DGLCQF:	0		;CONTROL Q FLAG

DGLBUF:	BLOCK	60	;RUBOUT PROCESSING AND I-O BUFFER.
;DDT ENTRY-SAVES ACS 1-16.
DDT:	POP	P,QA
	PUSH	P,QA
	SKIPE	DEBUGP
	.VALUE	[ASCIZ*:SIM. PC.
QA/	       :VP *]
	PUSH	P,[DDTXIT]	;RTN TO CHANGE ACS AFTER RESTORATION.
	SETZM	DDONXT		; ;N STOPS AFTER THIS INSN.
DDT1:	SKIPE	WNGDIS
	PUSHJ	P,NGSIMD
	PUSHJ	P,MERRV		;TURN ON TTY OUTPUT.
	PUSHJ	P,SAVALL
	SETZM	RUN
	MOVEM	P,DDTPDP	;SAVE P FOR RESTORATION ON ERROR.
	LSH	PC,1
	HRRM	PC,R7
	HRRM	PC,%PC
	HRRZ	DL,OPC
	LSH	DL,1
	SKIPL	DL
	HRRM	DL,%OPC		;SET UNLESS HAVE JUST LEFT DDT.
	HRRM	PS,RPS
	MOVEM	TIME,RTIME
	HRLZ	SF,%TMODE
	SKIPE	DINITF
	JRST	DDT3		;DON'T PRINT INSN ON STARTING PDP11.
	HRRZ	DL,R7
	TLO	SF,NUMFND	;CAUSE . TO BE SET BY DARG.
	CALL	DPINSN		;PRINT DL AND INSN THERE.
	HRRM	DLEN,%IL	;SAVE LENGTH, FOR ;N'S SAKE.
	HRROI	DO,(DO)		;DON'T ALLOW ACCIDENTAL CHANGES.
	TTOA	[ASCIZ/   /]
DDT2:	SETZM	FILINF
	.CLOSE	UTIC,
DDT3:	SETZM	DINITF		;THAT FLAG SET 1ST TIME ONLY.
	.RESET	TYIC,
	SETOM	DGVLVL
	SETOM	QUITF
	JRST	DLOOP

;PUSHJ HERE, AND IT RETURNS WITH ACS 1-16 SAVED.
SAVLNG==16	;NUM LOCATIONS PUSHED
SAVALL:	EXCH	A,(P)		;SAVE REG. 1.
	PUSH	P,B
	MOVEI	B,1(P)		;SET UP BLT POINTER.
	HRLI	B,C
	ADD	P,[14,,14]	;POINT TO LAST PLACE TO PUSH TO.
	BLT	B,(P)
	JRST	(A)

;PASS SPACES.
GPASST:	GETCHR
PASSPS:	CAIN	T0," 
	JRST	GPASST
	RETURN
;COME HERE FOR NEXT COMMAND.
DLOOP:	TLZ	SF,DMODES	;RESTORE TEMPORARY MODES.
	TLO	SF,@%TMODE
DLOOP1:	MOVE	T6,DL
	TLO	T6,.5KBIT
	MOVEM	T6,%Q		;SET %Q FROM DL, .5KILLED.
	HRRM	DLEN,%L		;SAVE LENGTH IN CASE ERROR.
DLOOP2:	CALL	DGVAL		;TRY TO GET A NUMERIC VALUE.
	SKIPN	DGVALP		;IF HAD ARG,
	JRST	DLOOP3
	SETZM	S%OLFL		;STOP UPDATING LENGTH OF WHAT'S OPEN
	TLO	SF,NUMFND	;TELL COMMAND ABOUT ARG
	SKIPA	DL,T2		;SET %Q TO ARG.
DLOOP3:	HRRZ	DLEN,%L		;ELSE RESTORE LENGTH.
	JSP	T1,DDECOD	;JUMP ACCORDING TO FIRST CHAR. AFTER NUM.
	"/,,CSLASH
	"[,,CLB
	"],,CRB
	^I,,CTAB
	^J,,CLF
	^K,,CCTLK
	^M,,CCR
	"^,,CUPAR
	"=,,CEQ
	";,,CSEM
	",,CALT
	"_,,CBACK
	">,,CGT
	":,,CCOL
	^N,,CCN
	^P,,CSP
	^L,,CFORMF
	^\,,CCBSL
	^],,CCRB
	" ,,DLOOP1
	DERR		;IF NOT FOUND.

;LOOK IN TABLE AT (T1) FOR ENTRY WITH LH=(T0),
;THEN JRST TO @RH OF ENTRY.
DDECOD:	HLRZ	T5,(T1)		;LH, FOR COMPARISON.
	HRRZ	T6,(T1)		;RH FOR JUMP.
	CAIN	T0,(T5)		;FOUND ENTRY?
	JRST	(T6)		;YES, GO THERE.
	JUMPE	T5,(T6)		;IF LH IS 0, GO THERE ANYWAY(END OF TABLE).
	AOJA	T1,DDECOD	;TRY NEXT ENTRY.
;READ A CHAR, PASS SPACES, READ A VALUE.
DGVGCH:	GETCHR

;PASS SPACES AND READ IN A VALUE.
DGVPSP:	PUSHJ	P,PASSPS

;READ IN A VALUE WHOSE 1ST CHAR HAS BEEN READ ALREADY.
DGV1CH:	TLO	SF,D1CHAR

;GET A VALUE, AND PUT IT IN T2. SET NUMFND IF VALUE AVAILABLE.
;T0 CONTAINS CHAR. FOLLOWING VALUE, OR 1ST CHAR, AT EXIT.
;SETS T1 .
DGVAL:	SETZ	T1,		;START ON LEVEL 0.
	AOSE	DGVLVL		;IF OUTERMOST CALL TO DGVAL,
	JRST	.+4
	MOVE	T5,[004400,,DRNEXT]
	MOVEM	T5,DRNEXT	;SET UP B.P. FOR EXTRA WDS,
	MOVEI	DLEN,2		;INITIALIZE LENGTH.

	PUSH	P,DGVRGP	
	SETZM	DGVRGP		;AS YET, THIS VALUE ISN'T A REGISTER NUM.
	PUSH	P,[DGVXIT]
DGVAL0:	HLRZ	T1,T1		;PUT LEVEL IN RH.
	SETZM	DGVALP
	PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	SKIPN	DGVALP		;IF CAN'T, RETURN NO VALUE.
	RETURN
DGVAL1:	HRRZ	T5,DGVT2(T1)	;ADDR. OF OP TABLE FOR THIS LEVEL.
	HRRZ	T6,(T5)		;SEARCH FOR ENTRY WITH RH=NEXT CHAR.
	CAIN	T0,(T6)
	JRST	DGVAL2		;FOUND.
	SKIPE	(T5)		;0 MARKS END OF TABLE.
	AOJA	T5,.-4		;TRY NEXT ENTRY.
	RETURN

DGVAL2:	HLL	T2,(T5)		;SAVE OPERATION TYPE NO.
	PUSH	P,T2		;AND LAST VALUE.
	PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	REST	T5		;GET 1ST ARG, OP. NUM.
	HLRZ	T6,T5		;GET OP. NUM.
	SKIPE	DGVALP		;IF NO 2ND ARG,
	JRST	DGVAL3
	JUMPG	T6,DERR		;ERROR UNLESS OP. IS " ",
	HRRZ	T2,T5		;IN WHICH CASE RETURN 1ST ARG.
	RETURN
DGVAL3:	HRREI	T2,(T2)		;GOT 2ND ARG - EXTEND SIGNS OF ARGS,
	HRREI	T5,(T5)
	XCT	DGVT3(T6)	;PERFORM OPERATION.
	JRST	DGVAL1		;LOOK FOR ANOTHER OP.

DGVCAL:	PUSH	P,T1		;SAVE LEVEL NO.
	MOVE	T1,DGVT1(T1)	;GET NEXT LEVEL NO., ADDR. TO CALL.
	PUSHJ	P,(T1)		;GET VALUE ON NEXT LEVEL.
	POP	P,T1		;RESTORE LEVEL NO.
	RETURN
DGVT1:	1,,DGVAL0	;FROM LEVEL 0, CALL SELF ON LEVEL 1.
	2,,DGVAL0
	3,,DGVAL0
	4,,DGTRM
	DGVAL		;DGTRM CALLS BACK ON LEVEL 3.

DGVT2:	DGVL0T		;LEVEL 0 OP. TABLE.
	DGVL1T		;LEVEL 1 OP. TABLE.
	DGVL2T
	DGVL3T
	DGVL4T

DGVL0T:	0,," 	;SPACE - LOW PRIOR. ADDITION.
	0
DGVL1T:	5,,"&	;LOGICAL OPS. LOWEST IN PRIOR.
	6,,"\
	8,,"#
	0
DGVL2T:	3,,"+
	4,,"-
	0
DGVL3T:	1,,"*	;MULT., DIV. SEPARATE TERMS.
	2,,"!
	0
DGVL4T:	7,,",	;ANGLE-BRACKETS CONTAIN ORDINARY EXPRESSIONS
	0	;SEPARATED BY COMMAS.

DGVT3:	ADDM	T5,T2		;SPACE - MUST HAVE CODE 0.
	IMULI	T2,(T5)		;1ST INSNS OF OPERATIONS.
	IDIVM	T5,T2
	ADD	T2,T5
	SUBM	T5,T2
	ANDM	T5,T2
	IORM	T5,T2
	PUSHJ	P,DGVCOM
	XORM	T5,T2

DGVCOM:	SKIPE	DGVLVL		;IF WITHIN INNER BRACKETS,
	JRST	DGVCO2		;THROW AWAY EXTRA WORD.
	CAILE	DLEN,10.	;CAN'T HAVE MORE THAN 5 EXTRA WDS.
	ERROR	[ASCIZ/> 6 WORDS/]
	IDPB	T2,DRNEXT	;2ND VALUE IS EXTRA WORD.
	MOVE	T2,T5
	AOJ	DLEN,
	AOJA	DLEN,CPOPJ

DGVCO2:	MOVE	T2,T5
	RETURN

DGVXIT:	SOS	DGVLVL
	HRLI	T2,.5KBIT	;SINCE MUST .5KILL %P.
	SKIPE	DGVRGP		;IF THIS IS TO BE A REGISTER NUM.,
	TLO	T2,REGBIT	;SAY SO IN THE VALUE.
	MOVEM	T2,%P
	POP	P,DGVRGP
	POPJ	P,		;NOT AN OP. FOR THIS LEVEL, RETURN.
;GET A TERM, INTO T2. CLEAR NUMFND IF CAN'T GET ONE, SET IF CAN.
DGTRM:	PUSHJ	P,DGNUM		;TRY TO GET NUMBER.
	SKIPE	DGVALP		;IF FOUND, RETURN IT.
	RETURN
	PUSHJ	P,DGSYM		;OTHERWISE, TRY TO GET SYMBOL.
	JUMPE	T2,DGTRM1	;IF NO SYMBOL, TRY OTHER THINGS.
	PUSHJ	P,DLKSYM	;LOOK UP SYMBOL.
	JUMPE	T5,[ERROR [ASCIZ/U/]]	;UNDEFINED.
	LDB	T2,[220400+T5,,1]
	JRST	@.+1(T2)	;INDEX ON SYMBOL TYPE.

	DGTRM2		;ORDINARY SYMBOL.
	DGVREG		;REGISTER SYMBOL.
	DR2AR		;2-OP INSN.
	DR2AR		;1-OP INSN.
	DRJSR		;JSR.
	DRJSR		;RTS.
	DRDBR		;BRANCH INSN.
	DREMT
	DRSFL
	DGTSER
	[ERROR [ASCIZ/U/]]
	DRSPEC		;SOB, MARK, SPL.
	REPEAT 4,DGTSER

;JRST THRU STE TO HERE TO GET VALUE OF REGISTER SYMBOL.
DGVREG:	SETOM	DGVRGP

;JRST HERE FOR NORMMAL SYMBOL.
DGTRM2:	AOS	DGVALP
	HRRE	T2,1(T5)
	RETURN

DGTSER:	CRF
	6TYPE	(T5)
	MOVE	T5,1(T5)
	MOVEM	T5,QA
	ERROR	[ASCIZ/ HAS IMPOSSIBLE STE! - A/]
;COME HERE TO CHECK FOR UNARY +,-.
DGTRM1:	CAIE	T0,"-		;FOR MINUS SIGN,
	JRST	DGTRM3
	PUSHJ	P,DGTRM		;GET A TERM AND NEGATE IT.
	MOVN	T2,T2
	RETURN
DGTRM3:	CAIN	T0,"+		;FOR + SIGN, START OVER.
	JRST	DGTRM
	CAIE	T0,"'		;'''' MEANS ASCII CHAR INPUT.
	JRST	DGTRM4
	GETCHR
	MOVEI	T2,(T0)
DGTRM6:	GETCHR			;GET CHAR AFTER TERM.
DGVRET:	AOS	DGVALP
	RETURN

DGTRM4:	CAIE	T0,""		;2 ASCII CHARS INPUT.
	JRST	DGTRM5
	GETCHR
	MOVEI	T2,(T0)
	GETCHR
	LSH	T0,10		;2ND CCHAR INTO HIGH BYTE
	ADD	T2,T0
	JRST	DGTRM6
DGTRM5:	CAIE	T0,"<		;OPEN BRACKET?
	POPJ	P,		;NO, R ETURN NO TERM.
	PUSHJ	P,DGVAL0	;TRY TO GET VALUE.
	CAIE	T0,">		;IF NOT CLOSED BY >, ERROR.
	ERROR	[ASCIZ/UNBAL/]
	GETCHR			;PASS BY >.
	RETURN

;CONVERT ARG TO RANGE OF ADDRS AND NUMBER.
;DEFAULTS ARE RANGE (AOBJN PTR IN T0): 0 - %CORE, NUMBER (IN T2): 0.
;IF 1 WD. IN ARG, IT SPECIFIES NUMBER.
;IF 2, THEY ARE RANGE,
;IF 3, 1ST 2 ARE RANGE, 3RD IS NUMBER.
DGRAN:	SETZB	T0,T2		;PUT IN DEFAULTS.
	HRRZ	T1,%CORE
	MOVEI	T1,-2(T1)
	TLNN	SF,NUMFND
	JRST	DGRAN1		;USE THEM IF NO ARG.
	CAIN	DLEN,2
	JRST	DGRAN2		;1 ARG ==> SET LOCATIONS TO IT.
	MOVEI	T0,(DL)		;>= 2 ARGS ==> FIRST 2 ARE RANGE.
	HRRZ	T1,DRNEXT+1
	CAIN	DLEN,6		;3RD ARG IS NUMBER TO STORE, IF PRESENT.
	HRRZ	T2,DRNEXT+2
	JRST	DGRAN1

DGRAN2:	MOVEI	T2,(DL)
DGRAN1:	ANDI	T0,177777
	LSH	T0,-1		;CHANGE ADDRS TO WORD NOS.
	LSH	T1,-1
	SUBM	T0,T1
	HRLI	T0,-1(T1)	;AOBJN PTR -> BLOCK TO STORE IN.
	TLO	T0,700000
	ANDI	T2,177777
	RETURN

;READ A NUMBER INTO T2, PUT NEXT CHAR INTO T0.
;AT EXIT, NUMFND INDICATES NUMBER WAS THERE.
DGNUM:	SETZB	T2,DGVALP
	SETZ	T3,		;T2 ACCUMULATES OCTAL; T3, DECIMAL.
DGNUM1:	GETCHR
	SKIPN	DGLCQF		;^Q-QTD CHARS NOT DIGITS.
	CAIGE	T0,"0		;A DIGIT?
	JRST	DGNUM2		;IF NOT, CHECK FOR ".".
	CAILE	T0,"9
	JRST	DGNUM2
	AOS	DGVALP		;FOUND A NUMBER.
	LSH	T2,3		;PUT THIS DIGIT IN.
	ADDI	T2,-"0(T0)
	IMULI	T3,10.		;PUT IT IN DECIMAL NUM, TOO.
	ADDI	T3,-"0(T0)
	JRST	DGNUM1		;TRY FOR ANOTHER DIGIT.

DGNUM2:	SKIPE	DGVALP		;IF HAD A NUMBER,
	CAIE	T0,".		;FOLLOWED BY ".",
	JRST	DGNUM3
	MOVEI	T2,(T3)		;USE DEC NUM, NOT OCT NUM.
	GETCHR
DGNUM3:	HRREI	T2,(T2)
	RETURN

;OPEN REGISTER WHOSE ADDR. IS IN DL.
DARG:	MOVE	DO,DL
	TLZ	DO,.5KBIT	;INSURE DO POSITIVE SINCE HAVE OPEN LOC.
	MOVE	T6,DO
	TLO	T6,.5KBIT
	MOVEM	T6,DOPEN	;SET SYMBOL %.  .
	TLZE	SF,NUMFND	;IF ADDR WAS ARG,
	MOVEM	T6,DPNT		;ALSO SET SYMBOL .  .
	TLNE	SF,DDSKM
	JRST	DARGD		;LOCATION IS IN DISK
	PUSHJ	P,DCLOS0	;T3 _ CORE ADDR OF LOC., -PDP11.
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPR
	HRRZ	DL,PDP11(T3)	;GET WORD FROM OPEN REG.
	MOVEI	DLEN,2		;LENGTH OF OBJECT TENTATIVELY 2.
	TLZ	SF,BYTOPN+DSKOPN
	TLNE	DO,REGBIT	;REGISTERS NEVER BYTES.
	RETURN
	TRNN	DO,1		;IF ADDR ODD,
	TLNE	SF,DBYTM	;OR IN BYTE MODE,
	TLOA	SF,BYTOPN	;OPEN AS A BYTE,
	RETURN
	TRNE	DO,1
	LSH	DL,-10
	ANDI	DL,377		;RETURN ONLY THE DESIRED BYTE.
	RETURN

DARGD:	SKIPN	WDF
	ERROR	[ASCIZ /DF NOT ATTACHED/]
	TLZ	SF,BYTOPN
	TLO	SF,DSKOPN
	LDB	T6,[130700,,DO]
	SKIPN	DSKDIR(T6)
	ERROR	[ASCIZ /NO BLOCK /]
	LDB	T3,[11200,,DO]
	ADD	T3,DSKDIR(T6)
	SUBI	T3,PDP11
	HRRZ	DL,PDP11(T3)
	TRNN	DO,1
	HLRZ	DL,PDP11(T3)
	RET

;COME HERE ON ERROR.
DERR:	CALL OSNAMR	;RESTORE OLD SNAME IF DESIRED.
	SETOM	DGVLVL		;IN CASE ERRED WITHIN DGVAL.
	CALL	MERRV		;TURN ON TTY OUTPUT.
	.CLOSE	UTIC,
	SETZM	FILINF
	.CLOSE	LOADCH,
	TTOA	[ASCIZ/ ?  /]
	MOVE	P,DDTPDP	;RESET STACK.
	.RESET	TYIC,
	SETZM	XREGTF
	SETZM	DGLINF
	SETZM	DGLCNT
	HRRZ	DL,%Q		;DON'T CLOBBER DL WITH ERROR.
	HRRZ	DLEN,%L
	TLZ	SF,D1CHAR+NUMFND+CSSFLG+DSEMFL
	JRST	DLOOP1
;READ A FILESPEC, PUT NAMES IN OPEN BLOCK <- A.
DGFIL:	SETZM	FILFLG
	SETZ	T3,
	SETOM	DGLINF		;INDICATE READING FILENAME.
DGFIL0:	SETZ	T2,
	MOVE	D,[440600,,T2]
DGFIL1:	GETCHR
	SKIPE	DGLCQF		;^Q-QUOTED CHARS TREATED AS ORDINARY.
	JRST	DGFIL2
	JSP	T1,DDECOD
	";,,DGFILS
	":,,DGFILC
	" ,,DGFILN
	^M,,DGFILN
	",,,DGFILN
	  ,,DGFIL2		;ORDINARY CHAR.

DGFIL2:	MOVEI	T0,-40(T0)	;CONV. TO SIXBIT.
	TRNN	D,1		;UNLESS HAVE OVERFLOWED INTO T3,
	IDPB	T0,D		;STORE NEXT CHAR.
	JRST	DGFIL1

;COME HERE WHEN SPACE OR CR TERMINATES NAME.
DGFILN:	JUMPE	T2,DGFILM	;DO NOTHING IF NO NAME.
	XCT	DGFILT(T3)	;STORE NAME PROPERLY.
	AOJ	T3,		;SUCCESSIVE NAMES ARE FN1, FN2, DEV, SNAME.
DGFILX:	SETOM	FILFLG
DGFILM:	CAIE	T0,^M
	CAIN	T0,",		;^M AND ", TERMINATE FILSPC.
	SKIPA
	JRST	DGFIL0		;AFTER SPACE, TRY AGAIN.
	SETZM	DGLINF
OSNAMR:	.SUSET [.RSNAM,,NSNAM] ;SAVE DEFAULT SNAME OR SPEC'D.
	.SUSET [.SSNAM,,OSNAM] ;IF NOT SPEC'D, RESTORE CURRENT.
	SETZM OSNAM	;NO LONGER NEED TO RESTORE.
	RET

DGFILT:	MOVEM	T2,1(A)		;STORE FN1.
	MOVEM	T2,2(A)		;FN2.
	HLRM	T2,(A)		;STORE DEV.
DGFILS:	CALL [	.SUSET	[.SSNAM,,T2]	;STORE SNAME.(DOES NOTHING IF T2 ZERO)
		SETZM OSNAM	;DON'T RESTORE SNAME LATER.
		RET]
	JRST	DGFILX

DGFILC:	JUMPE	T2,DGFILX
	HLRM	T2,(A)		;COLON: ALWAYS STORE AS DEVICE.
	JRST	DGFILX

FILFLG:	0	;SETOM'ED IF A "FILSPEC" ACTUALLY TYPED
	;(DESIGNED SO CAN BE FAKED OUT BY : OR ; WITHOUT NAME)
OSNAM:	0	;NONZERO => RESTORE SNAME ON ERROR OR RETURN FROM DGFIL.
NSNAM:	0	;SNAME BEFORE RETURN FROM DGFIL AND RESTORE OSNAM.
;READ IN A SYMBOL, IF POSSIBLE.
;T2 GETS NAME IN SIXBIT IF SYMBOL, 0 OTHERWISE.
;ASSUMES 1ST CHAR IN T0. LEAVES FOLLOWING CHAR THERE.
DGSYM:	TDZA	T2,T2		;NO CHARS YET. DON'T READ 1ST CHAR.
	GETCHR
	SKIPE	DGLCQF		;IF ^Q-QUOTED,
	MOVEI	T5,-40(T0)	;ALWAYS USE IT.
	SKIPN	DGLCQF		;ELSE USE ONLY SQUOZE CHARS.
	CALL	D7TO6
DGSYM1:	TLNE	T2,770000	;IF NOT FULL,
	JRST	DGSYM2
	LSH	T2,6		;PUT IN THIS CHAR(OR BLANK).
	ADDI	T2,(T5)
	JUMPE	T2,CPOPJ	;IF NO SYMBOL, RETURN.
	JUMPE	T5,DGSYM1	;IF NOT SYMBOL CHAR, LEFT-JUSTIFY.
DGSYM2:	JUMPN	T5,DGSYM+1	;KEEP READING CHARS PAST END OF SYMBOL.
	RETURN

;LOOK UP THE SYMBOL WHOSE SIXBIT IS IN T2.
;RETURNS IN T5 PTR TO STE (0 IF NONE).
DLKSYM:	MOVE	T6,SYMEND
	MOVNI	T5,2-SYMTAB(T6)	;2*NUMBER OF SYMBOLS.
DLKSY0:	LSH	T5,17.		;LH_ - NUM.SYMS.
	HRRI	T5,3(T6)	;RH _ LAST SYM + 3.
	MOVSI	C,DLKSY1
	BLT	C,C		;PUT LOOP IN ACS 0-3.
	CALL
	CAME	T2,(T5)		;IF NOT FOUND, RETURN 0.
	SETZ	T5,
	RETURN

DLKSY1:	SUBI	T5,3		;MOVE TO PREV. STE.
	CAME	T2,(T5)		;IF NOT FOUND & MORE STE'S
	AOBJN	T5,		;GO LOOK AT THEM.
	RETURN

;CONVERT AN ASCII CHAR TO SIXBIT, IF IT CAN GO IN A SYMBOL.
;IF IT CAN'T GO IN ONE, RETURN 0 (IN T5). ARG IN T0.
D7TO6:	SETZ	T5,
	CAILE	T0,"Z
	RETURN
	CAIL	T0,"A
	JRST	D7TO6X		;ALPHABETIC CHARS O.K.
	CAILE	T0,"9
	RETURN
	CAIGE	T0,"0
	CAIN	T0,".		;DIGITS AND ".", TOO.
	JRST	D7TO6X
	CAIL	T0,"&
	RETURN
	CAIL	T0,"$		;ALSO "%", "$".
D7TO6X:	MOVEI	T5,-40(T0)
	RETURN
;DEFINE THE FOLLOWING SYMBOL
CGT:	TLZ	SF,NUMFND
	CALL	GPASST
	PUSHJ	P,DGSYM		;TRY GETTING SYMBOL, ERROR IF NONE.
	JUMPE	T2,DERR
	MOVEI	T6,SYMDMP
	MOVNI	T5,2-SYMTAB(T6)	;SEARCH UNSETTABLES, SYMTAB THRU SYMDMP-2 .
	CALL	DLKSY0
	SKIPE	T5
	ERROR	[ASCIZ/UNSETTABLE SYMBOL/]	;IF FOUND THERE.
	CALL	DEFSYM		;GET OLD STE OR MAKE NEW ONE.
	CALL	PASSPS		;GET 1ST NONBLANK CHAR.
	TLZ	DL,.5KBIT
	CAIE	T0,^K
	TLOA	SF,D1CHAR	;IF NOT ^K, REREAD IT.
	TLO	DL,.5KBIT	;IF ^K, .5KILL THE SYMBOL.
	MOVEM	DL,1(T5)	;STORE VALUE, FLAGS.
	JRST	DLOOP

; ^K COMMAND - COMPLEMENT .5KILL BIT FOR FOLLOWING SYMBOL.
CCTLK:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DNOARG
	PUSHJ	P,DLKSYM
	JUMPE	T5,DLOOP	;IF UNDEFINED, NO-OP.
	MOVSI	T6,400000	;COMPLEMENT HALF-KILL FLAG.
	XORM	T6,1(T5)
	TLZ	SF,NUMFND
	TLO	SF,D1CHAR
	JRST	DLOOP

;COME HERE TO LOOK FOR OLD STE, MAKE NEW ONE & STORE NAME IF NOT FOUND.
;NAME TAKEN IN T2, STE ADDR RET. IN T5.
DEFSYM:	MOVE	T6,SYMEND	;SEARCH SETTABLE SYMBOLS,
	MOVNI	T5,2-SYMDMP(T6)	;SYMDMP AND UPWARD.
	CALL	DLKSY0
	JUMPN	T5,CPOPJ	;IF DEFINED, RETURN OLD STE.

;COME HERE IF UNDEFINED.
DEFSY0:	HRRZ	T5,SYMEND
	MOVEI	T5,2(T5)	;ADDR OF NEXT STE,
	TRNE	T5,1777		;IF OVERFLOW TO NEW PAGE
	JRST	DEFSY1
	PUSHJ	P,BLKGET	;ADD A PAGE
	(T5)
DEFSY1:	HRRZM	T5,SYMEND	;IT'S NOW LAST STE.
	MOVEM	T2,(T5)		;PUT IN NAME.
	RETURN

;DEFINE SYMBOL DURING LOADING.
DEFSY2:	SKIPN	CSLFLG		;IF NOT DOING ;L,
	JRST	DEFSYM		;MAYBE WAS DEFINED BEFORE THIS CMD.
REPEAT	5,[
	CAMN	T2,SYMDMP+2*.RPCNT
	JSP	T5,DEFSY3	;TEST FOR PREDEFINED SETTABLE SYM.
]
	JRST	DEFSY0		;NOT PREDEF, MUST BE UNDEF.

DEFSY3:	MOVEI	T5,SYMDMP-DEFSY2-4(T5)
	RETURN			;T5 HAS ADDR OF PREDEF STE.
;READ IN A GENERALIZED OPERAND ADDRESS.
;PUT 6-BIT ADDRESS MODE IN T2.
;RETURN NEW VALUE OF %S OR %D IN T3 .
;IF INDEXED, RELATIVE OR IMMEDIATE, UPDATE DLEN, STORE EXTRA WORD.
DRADDR:	PUSHJ	P,PASSPS
	PUSH	P,DRINDP
	SETZM	DRINDP
	CAIE	T0,"@		;INDIRECT MODE?
	JRST	.+3
	AOS	DRINDP		;YES, REMEMBER IT AND PASS @ SIGN.
	GETCHR
	JSP	T1,DDECOD	;DECODE 1ST CHAR.
	"#,,DRIMM		;IMMEDIATE MODE.
	"-,,DRDEC		;AUTODECREMENT OR UNARY -.
	"(,,DRPAR		;REGISTER INDIRECT OR AUTOINCREMENT.
	DRADD			;REGISTER, RELATIVE OR INDEXED.

DRADD:	PUSHJ	P,DGV1CH	;GET ADDRESS, 1ST CHAR READ ALREADY.
	SKIPN	DGVALP		;IF NONE, BAD FORMAT
	JRST	DERR
DRADD0:	MOVE	T3,T2
	CAIN	T0,"(		;INDEXED?
	JRST	DRNDX		;YES.
	TLZE	T2,REGBIT	;ADDR. IS A REGISTER?
	JRST	DRREG		;YES.
	SUBI	T2,(DO)		;CALCULATE DISPLACEMENT.
	SUBI	T2,2(DLEN)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,67		;RELATIVE ADDRESS, MODE 67.
DRXIT:	SKIPE	DRINDP		;IF READ "@",
	IORI	T2,10		;CHANGE MODE TO INDIRECT.
	TLO	T3,.5KBIT	;%S, %D SHOULD ALWAYS BE .5KILLED.
	POP	P,DRINDP
	RETURN

DRNDX:	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	PUSH	P,T3		;SET %D TO DISPL., NOT REG.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	POP	P,T3
	ADDI	T2,60		;MODE 6N, N=REGISTER NUM.
	JRST	DRXIT

DRREG:	ANDI	T2,7		;REGISTER ADDRESS, MODE 0N, N=REGISTER NO.
	JRST	DRXIT
;IMMEDIATE MODE - COME HERE IF FIND #.
DRIMM:	PUSHJ	P,DGVGCH	;GET IMMED. OPERAND.
	SKIPN	DGVALP		;MUST BE ONE.
	JRST	DERR
	MOVEI	T3,(T2)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,27		;RETURN (PC)+ MODE.
	JRST	DRXIT

;COME HERE IF READ ( - MUST BE (REG) OR (REG)+.
DRPAR:	PUSHJ	P,DRPAR1	;GET REG. NO.
	CAIE	T0,"+		;CLOSE-PAR. FOLLOWED BY +?
	JRST	DRPAR2		;NO, (R) OR @(R) .
	GETCHR			;YES, SKIP PAST +.
	ADDI	T2,20		;AUTOINCREMENT IS MODE 2.
	JRST	DRXIT

;COME HERE IF (R) OR @(R), AFTER READING ALL.
DRPAR2:	ADDI	T2,10		;SET UP IN CASE MODE 1.
	SKIPN	DRINDP
	JRST	DRXIT		;IF MODE 1.
	MOVEI	T5,60(T2)	;ELSE MODE 7,
	SETZ	T2,
	PUSHJ	P,DGVCOM	;STORE ZERO AS EXTRA WD.
	JRST	DRXIT		;DGVCOM DID T2_T5.

;AFTER READING A (, READ IN REGISTER NO., CHECK VALIDITY,
;CHECK FOR ), AND SKIP OVER IT.
DRPAR1:	PUSHJ	P,DGVGCH	;READ THE NO.
	CAIN	T0,")		;IF NOT FOLLOWED BY ), ERROR.
	SKIPN	DGVALP		;IF NO NUMBER, ERROR.
	JRST	DERR
	MOVEI	T3,(T2)
	TLO	T3,REGBIT
	MOVEI	T2,(T2)		;REMOVE REGISTER VS. CORE INDICATOR.
	CAILE	T2,7		;IF NOT <= 7,
	JRST	DERR		;NOT REGISTER NUMBER, ERROR.
	GETCHR			;READ PAST ).
	RETURN

;COME HERE AFTER READING - SIGN -- MIGHT BE AUTODECREMENT,
;MIGHT BE UNARY MINUS ON ADDRESS.
DRDEC:	TLO	SF,D1CHAR	;TELL DGVAL 1ST CHAR ALREADY READ.
	PUSHJ	P,DGVAL		;IT WILL USE THE - AS A UNARY, IF IT CAN.
	SKIPE	DGVALP		;IF IT CAN'T,
	JRST	DRADD0		;TREAT AS IF GOT ADDR RIGHT AWAY.
	CAIE	T0,"(		;OTHERWISE, SEE IF VALID AUTODECREMENT.
	JRST	DERR		;IF NO (.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	ADDI	T2,40		;MODE 4.
	JRST	DRXIT

DRNEXT:	0?0?0?0?0?0
DRINDP:	0		;IF NONZERO, THIS ADDR WAS PRECEDED BY "@".
;READ IN A STANDARD 1 OR 2 OPERAND INSN.
;COME HERE WITH T5-> STE, WHOSE 2ND WORD HAS OP CODE.
;BIT 17 OF 1(T5) IS ZERO IF 2-OPERAND INSN, 1 IF 1 OPERAND.
DR2AR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRADDR	;GET 1ST ADDRESS.
DR2AR0:	LSH	I1,6		;PUT IN WITH OP CODE.
DR2AR2:	JUMPL	I1,DR2AR1	;IF 1 OPERAND INSN.
	MOVEM	T3,%S		;SINCE MUST BE 2-OP, SET %S.
	ADDI	I1,(T2)
	CAIN	T0,",		;SKIP OVER A COMMA.
	GETCHR
	PUSHJ	P,DRADDR	;GET DESTINATION ADDRESS.
	LSH	I1,6		;PUT IN INSN.
DR2AR1:	MOVEM	T3,%D
	ADDI	T2,(I1)
	POP	P,I1
	AOS	DGVALP
	JRST	DGNUM3		;EXTEND SIGN.

;READ IN THE ADDR OF A BRANCH, MAKE THE INSN.
DRDBR:	PUSHJ	P,DRINSP	;SAVE REGS, ETC.
	SETOM	DRDBRF		;INDICATE BRANCH INSN. RATHER THAN SOB .
DRDBR1:	PUSHJ	P,DGVPSP	;PASS SPACES, READ IN NUMBER.
	MOVEI	T3,(T2)		;PREPARE TO SET %D .
	SKIPN	DGVALP
	ERROR	[ASCIZ/WHITHER/]	;IF NO ADDR.
	TLNE	T2,REGBIT	;CAN'T BRANCH INTO REGISTER.
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	T2,1		;ERROR IF ODD ADDR.
	ERROR	[ASCIZ/ODD ADDR/]
	SUBI	T2,2(DO)	;COMPUTE OFFSET.
	LSH	T2,-1		;AS NUMBER OF WORDS.
	SKIPN	DRDBRF		;ONLY 6 BITS FOR SOB.
	LSH	T2,2
	TRCN	T2,377600	;SEE IF IN RANGE.
	JRST	DRDBR9
	TRNE	T2,377600
	ERROR	[ASCIZ/ADDR. OUT OF RANGE/]
DRDBR9:	XORI	T2,377600	;SET TOP BITS TO WHAT THEY WERE.
DRDBR2:	SKIPN	DRDBRF
	LSH	T2,-2
	ANDI	T2,377		;GET LOW BYTE.
DREMT2:	TLO	T3,.5KBIT
	JRST	DR2AR1
;HANDLE JSR, RTS.
DRJSR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRJSR1	;READ REG. NUM.
	JRST	DR2AR2

DRJSR1:	PUSHJ	P,DGVPSP	;GET REGISTER NO.
	MOVEI	T2,(T2)
	SKIPE	DGVALP		;IF NO NUMBER,
	CAILE	T2,7		;OR OUT OF RANGE,
	JRST	DERR		;(>7), ERROR.
	LSH	I1,3		;MAKE ROOM FOR REG. NUM.
	MOVEI	T3,(T2)		;PREPARE TO SET %S OR %D
	TLO	T3,REGBIT+.5KBIT	;TO A REG. NUM.
	RETURN

DRSPEC:	PUSHJ	P,DRINSP
	JRST	@.+1(I1)	;OP-CODE SAYS TYPE OF INSN.
	DRSOB
	DRMARK
	DRSPL

DRSOB:	PUSHJ	P,DRJSR1	;READ REG. NUM.
	MOVEI	I1,770(T2)	;SET UP OP-CODE FOR FUNNY BRANCH.
	LSH	I1,6
	CAIN	T0,",
	GETCHR
	SETZM	DRDBRF		;INDICATE ONLY 6 BITS FOR OFFSET.
	JRST	DRDBR1

DRMARK:	MOVEI	I1,6500
	PUSHJ	P,DGVPSP
	CAIL	T2,100
	JRST	DERR		;WON'T FIT IN 6 BITS.
	JRST	DREMT1

DRSPL:	PUSHJ	P,DGVPSP
	MOVEI	I1,230		;OP-CODE.
	CAILE	T2,7
	JRST	DERR		;IF NOT NUM. OF REG.
	TLZ	T2,REGBIT
	JRST	DREMT1
;READ IN THE CODE FOR EMT OR TRAP, MAKE INSN.
DREMT:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;GET EMT OR TRAP CODE.
DREMT1:	TLNN	T2,REGBIT	;IF REGISTER NO.,
	SKIPN	DGVALP		;OR NO NO.,
	JRST	DERR		;ERROR.
	CAILE	T2,400		;MUST FIT IN BYTE.
	JRST	DERR
	JRST	DREMT2

;READ IN A CFL OR SFL INSN.
DRSFL:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;TRY TO GET NUMBER.
	SKIPN	DGVALP
	JRST	DRSFL1		;IF CAN'T, MIGHT BE SPECIAL FMT.
	TLNN	T2,REGBIT	;IF REGISTER NO.,
	CAILE	T2,17		;OR OUT OF RANGE, ERROR.
	JRST	DERR
	JRST	DR2AR1		;COMBINE NO. AND OP-CODE.
DRSFL1:	CAIE	T0,"@		;SPECIAL FMT. STARTED BY @.
	JRST	DERR
	SETZ	T2,		;INITIALLY, NO FLAGS TO BE SET OR CLEARED.
DRSFL0:	GETCHR
	SETZ	T6,
IRPC X,,ZNVC
	CAIN	T0,"X
	MOVEI	T6,X!F
TERMIN
	JUMPE	T6,DR2AR1	;IF NOT PART OF INSN, FINISH.
	IORI	T2,(T6)		;INSN WILL SET SPECIFIED FLAG.
	JRST	DRSFL0

;INITIALIZATION FOR INSN READIN RTNS.
DRINSP:	EXCH	I1,(P)
	PUSH	P,I1
	MOVE	I1,1(T5)
	TLO	I1,777776	;MAKE LH. SAME AS BIT 17.
	TLNN	I1,1
	TLZ	I1,-1
	RETURN
;CLOSE THE OPEN REGISTER, IF ANY, STORING CHANGES, IF ANY.
DCLOSE:	JUMPL	DO,CPOPJ	;NOTHING OPEN.
	TLZN	SF,NUMFND	;CHANGES MADE?
	RETURN
	HRRM	DLEN,%OL	;LENGTH OF OPENED STUFF_LENGTH OF NEW STUFF.
	SETZM	S%OLFL
	TLNE	SF,DSKOPN
	JRST	DCLOD
	PUSHJ	P,DCLOS0	;T3_CORE ADDR. OF LOC., -PDP11 .
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	TLNE	SF,BYTOPN	;IF WAS OPENED AS BYTE,
	JRST	DCLOS1		;STORE A BYTE.
	DPB	DL,[2000+T3,,PDP11]	;OTHERWISE STORE WORD.
	HRRZ	T6,DLEN
	LSH	T6,-1
	MOVE	T1,[004400,,DRNEXT]	;BP TO EXTRA WORDS.
DCLOSA:	SOJLE	T6,CPOPJ	;IF NO MORE.
	ILDB	T5,T1		;GET NEXT WORD.
	AOJ	T3,
	CAIN	T3,100000	;RAP AROUND IN MEMORY.
	SETZ	T3,		;(NOT IN ACCUMS).
	ANDI	T5,177777
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	HRRM	T5,PDP11(T3)
	JRST	DCLOSA

DCLOD:	SKIPN	WDF
	ERROR	[ASCIZ /DF NOT ATTACHED/]
	SAVE	DO
	LDB	A,[130700,,DO]
	SKIPN	T3,DSKDIR(A)
	JSP	D,DSKGET
	REST	DO
	LDB	T6,[11200,,DO]
	ADDI	T3,(T6)
	TRNE	DO,1
	HRRM	DL,(T3)
	TRNN	DO,1
	HRLM	DL,(T3)
	RET

;COME HERE TO STORE CHANGES IN A BYTE.
DCLOS1:	TRNN	DO,1
	DPB	DL,[001000+T3,,PDP11]	;IF EVEN BYTE.
	TRNE	DO,1
	DPB	DL,[101000+T3,,PDP11]	;IF ODD BYTE.
	RETURN

DCLOS0:	LDB	T3,[11700,,DO]	;GET ADDR, SHIFT RIGHT 1.
	TLNE	DO,REGBIT	;BUT IF ACCUM, SPECIAL.
	MOVEI	T3,R0-PDP11(DO)
	RETURN
;LEFT BRACKET - PRINT AS NUMBER (POSSIBLY SYMBOLIC, ETC.)
CLB:	TLZ	SF,DEXCM+DINSM	;PRINT AS SYMBOL.
	JRST	CSLASH

;BACKARROW - REOPEN IN CURRENT MODE.
CBACK:	TLZ	SF,NUMFND
	MOVE	DL,DO

;SLASH
CSLASH:	CALL	DPRINT
	JRST	DLOOPT

;SUBROUTINE TO PRINT AS INSN.
DPINSN:	ADRTYP	DL		;PRINT ADDR BEING OPENED,
	TTOI	"/
	TLO	SF,DINSM
	TLZ	SF,DEXCM+DBYTM+DDSKM

;SUBROUTINE, OPEN DL AND PRINT IN CURRENT MODE.
DPRINT:	CALL	DARG		;OPEN LOC ADDRESSED BY DL. SET UP NEW DL, T3.
	HRRM	DLEN,%OL	;INIT LENGTH OF OPENED STUFF.
	SETOM	S%OLFL
	TLNE	SF,DEXCM
	RETURN			;DON'T PRINT IF ! MODE.
	TTOA	[ASCIZ/  /]
	TLNN	DO,REGBIT	;CONTENTS OF REGISTER NOT AN INSN.
	TLNE	SF,BYTOPN+DSKOPN	;CAN'T CONSIDER A BYTE AN INSN.
	JRST	DLB1
	LDB	I1,[221100+T3,,PDP11]
	CAIE	I1,NCPAT		;IF LOC. IS A PATCH DEVICE,
	JRST	DLB0
	ADRTYP	DL		;PRINT DEST. OF PATCH.
	HRLI	DL,.5KBIT
	MOVEM	DL,%D		;SET %D.
	RETURN

DLB0:	TLNE	SF,DINSM
	JRST	DRB		;IF I MODE, PRINT AS INSN.
DLB1:	SYMTYP	DL		;ELSE PRINT CONTENTS AS QTY.
	RETURN

DRB:	HRRZ	T1,PDP11(T3)	;1ST WORD OF INSN.
	LSHC	T1,-14		;PREPARE TO DECODE.
	SKIPL	DRB2T(T1)	;IF >0, JRST TO THAT ADDR. (NOT 2-OP. INSN)
	JRST	@DRB2T(T1)
	TTOA	DRB2T(T1)	;IF 2-OP, TYPE ITS NAME.
	TTOI	" 
	PUSHJ	P,DPADDR	;DECODE AND PRINT SOURCE ADDR.
DPDEST:	MOVE	T6,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T6,%S
	TTOI	",
	JRST	DPADDR		;  "     "    "   DEST. ADDR.
DRB2T:	DRB00
	ASCIZ/MOV/
	ASCIZ/CMP/
	ASCIZ/BIT/
	ASCIZ/BIC/
	ASCIZ/BIS/
	ASCIZ/ADD/
	DRB07
	DRB10
	ASCIZ/MOVB/
	ASCIZ/CMPB/
	ASCIZ/BITB/
	ASCIZ/BICB/
	ASCIZ/BISB/
	ASCIZ/SUB/
	DLB1

;INSNS STARTING WITH 0000.
DRB00:	JUMPL	T2,DRB1	;1-OPER. WORD INSN.
	LSHC	T1,4
	JUMPE	T1,DRBS		;NOT A BRANCH.
	TTOA	DRB00T-1(T1)
DRBBR:	TTOI	" 
DRBBR1:	HLRE	T6,T2		;GET OFFSET.
	ASH	T6,-9		;AS NO. OF WORDS.
	ANDCMI	T6,1
	ADDI	T6,2(DO)	;DESTINATION ADDR OF BRANCH.
	ADRTYP	T6
	HRLI	T6,.5KBIT
	MOVEM	T6,%D
	RETURN

DRB00T:	ASCIZ/BR/
	ASCIZ/BNE/
	ASCIZ/BEQ/
	ASCIZ/BGE/
	ASCIZ/BLT/
	ASCIZ/BGT/
	ASCIZ/BLE/

DRB10:	JUMPL	T2,DRB1B
	LSHC	T1,4
	TTOA	DRB10T-200(T1)	;PRINT NAME OF BRANCH.
	JRST	DRBBR

DRB10T:	ASCIZ/BPL/
	ASCIZ/BMI/
	ASCIZ/BHI/
	ASCIZ/BLOS/
	ASCIZ/BVC/
	ASCIZ/BVS/
	ASCIZ/BHIS/
	ASCIZ/BLO/
DRB07:	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	JRST	DLB1		;UNLESS THEY'RE ATTACHED.
	LSHC	T1,3
	CAIE	T1,71
	CAIN	T1,76
	JRST	DLB1		;THOSE 2 OP-CODES NOT USED.
	TTOA	DRB07T-70(T1)
	LDB	T5,[410300,,T2]	;REG. NUM. FROM INSN.
	PUSHJ	P,REGTYP	;PRINT REGISTER NUMBER, % NOT NEEDED.
	LSH	T2,3
	TTOI	",
	MOVE	T5,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T5,%S
	CAIE	T1,77
	JRST	DPADDR		;PRINT DEST ADDR FOR ALL BUT SOB.
	ASH	T2,-2		;PRETEND SOB'S 6-BIT OFFSET WAS 8-BITS.
	JRST	DRBBR1

DRB07T:	ASCIZ/XOR /
	0		;71 NOT USED.
	ASCIZ/MUL /
	ASCIZ/DIV /
	ASCIZ/ASH /
	ASCIZ/ASHC /	;2 WORDS -- DOESN'T MATTER SINCE 76 UNUSED.
	ASCIZ/SOB /	;77.
DRB1:	LSHC	T1,6
	CAIGE	T1,50		;JSR?
	JRST	DRBJSR		;YES.
	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	CAIGE	T1,64		;UNLESS THEY'RE ENABLED.
	CAIL	T1,66
	JRST	DLB1		;NOT INSN.
	TTOA	DRB1T-50(T1)	;PRINT OP-CODE.
	CAIN	T1,65
	JRST	DRBMRK		;MARK INSN SPECIAL.
DRB1X:	TTOI	" 
	JRST	DPADDR		;DEST. ADDRESS.

DRB1T:	ASCIZ/CLR/
	ASCIZ/COM/
	ASCIZ/INC/
	ASCIZ/DEC/
	ASCIZ/NEG/
	ASCIZ/ADC/
	ASCIZ/SBC/
	ASCIZ/TST/
	ASCIZ/ROR/
	ASCIZ/ROL/
	ASCIZ/ASR/
	ASCIZ/ASL/
	ASCIZ/STX/
	ASCIZ/MARK /

DRB1B:	LSHC	T1,6
	CAIGE	T1,1050	;TRAP? EMT?
	JRST	DRBTE		;YES.
	CAIL	T1,1064
	JRST	DLB1		;NOT INSN.
	TTOA	DRB1T-1050(T1)
	TTOI	"B
	JRST	DRB1X

;INSNS WITH 1ST 10 BITS =0.
DRBS:	LSHC	T1,2		;DECODE NEXT 2 BITS.
	JUMPG	T1,DRBS1
	LSHC	T1,6		;ALL BUT LAST 2 OCTITS =0. DECODE THEM.
	SKIPN	WI45
	CAIE	T1,6		;RTT IS AN 11-45 INSN.
	CAILE	T1,6
	JRST	DLB1		;NOT INSN.
	TTOA	DRBST1(T1)	;PRINT OP-CODE
	RETURN

DRBST1:	ASCIZ/HALT/
	ASCIZ/WAIT/
	ASCIZ/RTI/
	ASCIZ/BPT/
	ASCIZ/IOT/
	ASCIZ/RESET/
	ASCIZ/RTT/
DRBS1:	CAIN	T1,2
	JRST	DCORTS		;CONDITION CODE OP OR RTS.
	LSH	T1,-1		;WAS 1 OR 3, NOW IS 0 OR 1.
	TTOA	DRBS1T(T1)	;OP CODE.
	JRST	DRB1X

DRBS1T:	ASCIZ/JMP/
	ASCIZ/SWAB/

DCORTS:	LSHC	T1,6		;LAST 2 OCTITS.
	CAIL	T1,240		;RTS?
	JRST	DCCOP
	CAIL	T1,230
	JRST	DRBSPL
	CAIL	T1,210
	JRST	DLB1
	TTOA	[ASCIZ/RTS /]	;YES.
	MOVEI	T5,-200(T1)	;REG. NUM.
	JRST	REGTYP	;PRINT WITHOUT "%".

DRBSPL:	SKIPN	WI45
	JRST	DLB1
	TTOA	[ASCIZ/SPL /]
	TTOI	60-230(T1)	;PRIORITY VALUE.
	RETURN

DCCOP:	TRNE	T1,20		;SET OR CLEAR?
	TTOI	"S		;SET.
	TRNN	T1,20
	TTOI	"C		;CLEAR
	TTOA	[ASCIZ/FL @/]
IRPC X,,NZVC
	TRNE	T1,X!F
	TTOI	"X
TERMIN
	RETURN

DRBJSR:	TTOA	[ASCIZ/JSR /]
	MOVEI	T5,-40(T1)	;NUMBER OF REGISTER.
	PUSHJ	P,REGTYP
	JRST	DPDEST		;PRINT DEST. ADDR.

DRBTE:	TRNE	T1,4		;EMT OR TRAP?
	TTOA	[ASCIZ/TRAP /]
	TRZN	T1,4
	TTOA	[ASCIZ/EMT /]
DRBTE1:	LSHC	T1,6
	LDB	T5,[1000,,T1]	;GET 8 LOW BITS.
	JRST	DPADX2		;GO SYMTYP, SET %D.

DRBMRK:	SETZ	T1,		;CODE IS ONLY 6 BITS.
	JRST	DRBTE1
;DECODE AND PRINT ADDRESS.
DPADDR:	SETZ	T1,
	LSHC	T1,2
	LDB	T5,[400300,,T2]	;GET REGISTER NUMBER.
	ROT	T2,4		;SHIFT NEXT ADDR TO TOP.
	TRNN	T2,10		;IF THIS ONE'S INDIRECT, PRINT @.
	JRST	@DPATAB(T1)
	JUMPE	T1,DPADD1	;REGISTER INDIRECT MODE IS SPECIAL.
	TTOI	"@		;OTHER INDIRECT MODE.
	JRST	@DPATAB(T1)	;BRANCH ON MODE.

DPATAB:	DPAREG
	DPADIM
	DPADDM
	DPADXM

DPADIM:	CAIN	T5,7		;IMMEDIATE?
	JRST	DPADI1		;YES.
	PUSHJ	P,DPADD1	;PRINT "("!!REGNO!!")".
	TTOI	"+
	RETURN
DPADI1:	PUSHJ	P,DPADT0	;INCR. FETCHING LOC.
	TTOI	"#
DPADI2:	HRRZ	T5,PDP11(T3)
	JRST	DPADX2

DPADDM:	CAIN	T5,7		;DECREMENT ON PC???
	MOVEI	T3,-1(T3)
	CAIN	T5,7
	MOVEI	DLEN,-2(DLEN)	;INSN 1 WORD SHORTER.
	TTOI	"-		;NO, '-(R)'.
	ANDI	T3,77777
DPADD1:	TTOI	"(
	PUSHJ	P,REGTYP	;PRINT REG SYM, OR NUM. WITHOUT "%".
	TTOI	")
	RETURN
DPADXM:	PUSHJ	P,DPADT0
	CAIN	T5,7		;RELATIVE ADDRESSING?
	JRST	DPADX1		;YES.
	PUSH	P,T5
	PUSHJ	P,DPADI2	;TYPE DISPLACEMENT.
	POP	P,T5
	JRST	DPADD1		;PRINT '(R)'.
DPADX1:	MOVEI	T5,1(T3)	;TURN T3 BACK INTO PDP11 WORD.
	ROT	T5,1
	ADD	T5,PDP11(T3)	;COMBINE WITH DISPLACEMENT.
DPADX2:	TRNE	T5,100000	;EXTEND VIRT. SIGN.
	IORI	T5,600000
	ANDI	T5,-1
	SYMTYP	T5
	HRLI	T5,.5KBIT
	MOVEM	T5,%D
	RETURN

DPADT0:	MOVEI	T3,1(T3)	;SET UP TO GET NEXT WD OF INSN.
	MOVEI	DLEN,2(DLEN)
	HRRM	DLEN,%OL
	ANDI	T3,77777
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPR
	RETURN

;PRINT THE REGISTER NUMBER IN T5, EITHER SYMBOLICALLY OR NUMERICALLY,
;ACCORDING TO CURRENT MODE.
;IF NUMERICALLY, DON'T PRINT "%".
;SAVE REGISTER NUM. AS VALUE OF %D .
REGTYP:	SETOM	XREGTF		;INDICATE "%" NOT NEEDED.

;COME HERE INSTEAD IF "%" IS NEEDED.
DPAREG:	HRLI	T5,REGBIT
	ADRTYP	T5
	SETZM	XREGTF
	TLO	T5,.5KBIT
	MOVEM	T5,%D		;STORE REG. NUM. AS DEST ADDR, .5KILLED.
	RETURN
CTAB:	PUSHJ	P,DCLOSE	;STORE CHANGES.
CTAB1:	TLO	SF,NUMFND	;CHANGE . .
	TTOA	[ASCIZ/
/]
	TLNE	SF,DDSKM	;IF WILL OPEN DISK, PRINT "$Q "
	TTOI	@ALTMOD
	TLNE	SF,DDSKM
	TTOA	[ASCIZ /Q /]
	ADRTYP	DL		;PRINT LOCATION OPENED.
	TTOI	"/
	JRST	CSLASH

CUPAR:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,-1(DL)
	TLNE	SF,BYTOPN	;IF BYTE, OPEN NEXT AS BYTE.
	JRST	CLF2
	TLNE	SF,DSKOPN
	JRST	CLF3
	TLNN	DL,REGBIT	;UNLESS REGISTER NUM,
	HRRI	DL,-1(DL)	;MOVE BACK 1 WORD.
	JRST	CTAB1

CCR:	PUSHJ	P,DCLOSE	;MAKE CHANGES.
	MOVE	T5,%PMODE	;RESET TEMPORARY MODES.
	MOVEM	T5,%TMODE	;TO PERMANENT ONES.
	SETO	DO,		;NO LOCATION OPEN.
	TTOI	"!
	JRST	DLOOP

CLF:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,1(DL)
	TLNN	DL,REGBIT	;IF NOT REGISTER OR BYTE,
	TLNE	SF,BYTOPN
	JRST	CLF2
	TLNE	SF,DSKOPN
	JRST	CLF3
	ADDI	DL,@%OL		;MOVE DOWN BY LENGTH OF QTY.
	SUBI	DL,1
	JRST	CTAB1
CLF2:	TLO	SF,DBYTM	;OPEN NEXT LOC. AS BYTE, TOO.
	JRST	CTAB1

CLF3:	TLO	SF,DDSKM
	JRST	CTAB1

; = - RETYPE AS NUMBER.
CEQ:	TLO	SF,DNUMM

; ]  - TYPE IN CURRENT MODE.
CRB:	TLZ	SF,NUMFND	;ELIMINATE ARG.
	SYMTYP	DL
	MOVEI	DLEN,2		;NOW A 1-WORD OBJECT, IF NOT BYTE.
	SKIPE	S%OLFL		;IF RETYPING WHAT WAS OPENED,
	HRRM	DLEN,%OL	;UPDATE LENGTH OF WHAT'S OPENED.
DLOOPT:	TTOA	[ASCIZ/    /]
	JRST	DLOOP
;ACTUAL CHARACTER ALTMODE.
CALT:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CSEM0		;TREAT $ AS ; .
CALT0:	SETZB	T2,T3
CALT1:	GETCHR			;DECODE NEXT CHAR.
	CAMN	T0,ALTMOD
	AOJA	T2,CALT1	;COUNT ALTMODES.
	CAIN	T0,"-
	JRST	CALTM		;INDICATE GOT '-'.
	CAIN	T0,"I
	MOVEI	T3,DINSM
	CAIN	T0,"S
	MOVEI	T3,DSYMM
	CAIN	T0,"D
	MOVEI	T3,DDECM
	CAIN	T0,"!
	MOVEI	T3,DEXCM
	CAIN	T0,"B
	MOVEI	T3,DBYTM
	CAIN	T0,"'
	MOVEI	T3,DBYTM+DASCM
	CAIN	T0,""
	MOVEI	T3,DASCM
	CAIN	T0,"N
	MOVEI	T3,DNUMM
	CAIN	T0,"Q
	MOVEI	T3,DDSKM
	CAIN	T0,"R
	MOVEI	T3,DREGM
	JUMPE	T3,[ERROR [ASCIZ/MODE/]]

CALTX:	TLZ	SF,(T3)		;CLEAR FLAG FOR 1 TIME.
	JUMPL	T2,.+2		;IF NO - SIGN,
	TLO	SF,(T3)		;SET AGAIN.
	MOVEI	T1,%TMODE	;IF >1 ALTMODE, CHANGE TEMP. MODE SAME WAY.
	PUSHJ	P,CALTX2
	MOVEI	T1,%PMODE	;IF >2 ALTMODES, CHANGE PERM. MODE.
	PUSHJ	P,CALTX2
	JRST	DLOOP1		;EXIT WITHOUT CLOBBERING TEMPORARY MODES.

CALTX2:	TRNE	T2,-1		;IF ENOUGH ALTMODES, CONTINUE.
	JRST	CALTX3
	POP	P,T5		;SCRATCH RETURN ADDR.
	JRST	DLOOP1		;FINISH.
CALTX3:	MOVE	T5,(T1)		;GET WORD TO BE CHANGED.
	ANDCMI	T5,(T3)		;INITIALLY TURN OFF.
	JUMPL	T2,.+2		;IF SETTING, TURN BACK ON.
	IORI	T5,(T3)
	MOVEM	T5,(T1)		;STORE BACK.
	SOJA	T2,CPOPJ	;1 ALTMODE HANDLED.

CALTM:	TLC	T2,-1		;COMPLEMENT MINUS INDICATOR.
	JRST	CALT1
; COLON - DECODE FOLLOWING SYMBOL AS SPECIAL COMMAND.
CCOL:	MOVE	T1,[-NUMCOM,,COMTAB]
	JSP	T3,CCOL1	;SEARCH COMTAB
	JRST	(T2)		;CCOL1 PUSHJ'S BACK

COMTAB:
IRP CMD,,[LCOMS,ADUMP,ALTSEM,BUSS,CDMP,CORE,DEBUG,DEVTIM,DMP,DMPCOR
DMPDF,DMPSYM,DMPTPV,DT,FLSYMS,LOAD,LODCOR,LODPTR,LOOKUP,LBRKS,LSYMS
ODMP,PAT,REGS,RESET,S%CSX,TDSK,TIME,WALLP,XFILE,ZERDF,ZTIME]
	SIXBIT/CMD/
	C!CMD
TERMIN
NUMCOM==<.-COMTAB>/2
	ASCIZ/CMD/		;MESSAGE IF NOT FOUND.

; :LSYMS  - LIST DEFINITIONS OF ALL NON-SPECIAL SYMBOLS.
CLSYMS:	MOVEI	T5,SYMLST
	PUSH	P,SF
	TLO	SF,DNUMM	;DON'T WANT "XXXY=XXXY" TO PRINT.
CLSYM0:	6TYPE	(T5)		;PRINT SYMBOL NAME.
	SKIPGE	T6,1(T5)
	TTOI	"=		;INDICATE IF .5KILLED.
	TTOI	"=
	SYMTYP	T6		;PRINT VALUE.
	CRF
CLSYM1:	ADDI	T5,2
	CAMG	T5,SYMEND
	JRST	CLSYM0
	POP	P,SF
	RETURN

; :FLSYMS -- FLUSH USER SYMBOLS.
CFLSYM:	SETZM	LASTST+2
	MOVE	T5,[LASTST+2,,LASTST+3]
	MOVE	T6,SYMEND	;ZERO ALL USER SYMBOLS' STES.
	BLT	T5,1(T6)
	MOVEI	T5,LASTST
	MOVEM	T5,SYMEND
	RETURN

; :TIME - PRINTS SIMULATED RUN TIME.
CTIME:	MOVE	T2,RTIME
CBUSS2:	JUMPGE	T2,CTIME1
	TTOI	"-
	MOVM	T2,T2		;IF TIME IS <0.
CTIME1:	IDIVI	T2,10.
	MOVEM	T2,QA
	MOVEM	T3,QT
	TTOA	[ASCIZ/A.T
/]
	RETURN
;SEMICOLON - READ IN NUMBER (NOT EXPRESSION), AND LETTER.
CSEM:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CALT0		;TREAT ; AS $.
CSEM0:	PUSHJ	P,GPASST	;SKIP SPACES,
	TLO	SF,D1CHAR	;RE-READ 1ST NON-SPACE.
	PUSHJ	P,DGNUM
	PUSHJ	P,PASSPS
CSEM2:	JSP	T1,DDECOD
IRPC CMD,,ABDFGILNPRTUWYZX
	"CMD,,CS!CMD
TERMIN
	"-,,CSEM1
	[ERROR [ASCIZ/COMMAND/]]

CSEM1:	HRROS	T2		;INDICATE GOT - .
	PUSHJ	P,GPASST	;SKIP TO NEXT NONBLANK.
	JRST	CSEM2		;DECODE IT AS COMMAND.

;PROCEED ARG (OR 1) INSNS.
CCN:	HLLOS	%CSN		;LEAVE ;N MODE.
	MOVEI	T0,1
	TLNE	SF,NUMFND	;IF NO ARG, DO 1 INSN.
	MOVEI	T0,(DL)
	SUB	T0,DDONXT
	MOVEM	T0,INSCNT
	JRST	CSN1		;SET UP SINGLE-STEP AND PROCEED.

; ;Z -- READS STANDARD RANGE & NUMBER, SETS EACH WORD IN RANGE TO NUMBER.
CSZ:	PUSHJ	P,DGRAN
	SKIPGE	PDP11(T0)
	JSP	D,MTRAPW
	HRRM	T2,PDP11(T0)
	AOBJN	T0,.-3
	JRST	CCRLF

; ;I -- RESET DEVICES, PS, TIME.
CSI:	PUSHJ	P,XRESET
	PUSHJ	P,CZTIME
	HLLZS	RPS
	SETOM	PC-SAVLNG(P)	;WILL ALWAYS SEEM PC WAS CHANGED.
	SETZM	LBUSEM		;FORGET OLD BUSS ERRORS.
CCRLF:	CRF
	JRST	CCR

; ;T -- TURN TRAP PRINTING ON OR OFF.
CST:	TLZN	SF,NUMFND	;IF ARG,
	JRST	CST1
	MOVEI	T1,(DL)		;SET PRINTING FOR THAT TRAP.
	LSH	T1,-2
	CAIL	T1,TRPPTL
	ERROR	[ASCIZ/TRAP THROUGH THERE/]
	MOVEM	T2,TRPPNT(T1)
	JRST	DLOOPT

CST1:	MOVEM	T2,TRPPNT+1	;NO ARG - SET FOR ALL TRAPS.
	MOVE	T2,[TRPPNT+1,,TRPPNT+2]
	BLT	T2,TRPPNT+TRPPTL-1
	JRST	DLOOPT
; ;U  --  SAME AS ;B, BUT IF NO 2ND ARG, REMOVE A BREAKPOINT.
CSU:	AOS	DGVALP		;PRETEND 0 IN T2 IS 2ND ARG.

; ;B -- SET BREAKPOINT OF TYPE (2ND ARG) AT LOCATION (1ST ARG).
;IF SECOND ARG MISSING, USE 7 (ALWAYS BREAK AND STOP).
;IF 1ST ARG HAS 2 WORDS, IT IS RANGE OF LOCATIONS TO PUT BREAKPOINTS AT.
;IF 1ST ARG MISSING, PUT BREAKPOINTS AT ALL LOCATIONS.
CSB:	SKIPN	DGVALP		;IF NO 2ND ARG, REPLACE BY 7.
	MOVEI	T2,7
CSB0:	LSH	T2,35		;POSITION FOR STORAGE.
	TLZE	T2,400000	;TOP BIT -> 4.1 (AUTOFLUSH)
	TLO	T2,400
	TLOE	T2,200000	;NEXT 2 BITS GO TO 4.3, 4.2 .
	TLO	T2,2000
	TLZE	T2,100000
	TLO	T2,1000
	LSH	T2,1		;FINISH POSITIONING.
	TLNN	SF,NUMFND	;IF NO 1ST ARG,,
	JRST	CSB1		;GO MAKE AOBJN PTR->ALL LOCS.
	MOVEI	T1,(DL)
	TLNE	DL,REGBIT	;CAN'T PUT BREAKPOINTS IN REGISTERS.
	ERROR	[ASCIZ/BKPT ON ACCUM./]
	LSH	T1,-1		;GET WORD NUM.
	CAIN	DLEN,2		;IF 2ND WORD,
	JRST	CSB2
	HRRZ	T3,DRNEXT+1	;SET LH OF AOBJN PTR.
	LSH	T3,-1
	SUBM	T1,T3		;TO NUM. WORDS IN RANGE.
	HRLI	T1,-1(T3)
	TLO	T1,700000	
	TLZ	SF,NUMFND	;INDICATE SETTING AT MANY PLACES.
	JRST	CSB2

CSB1:	MOVN	T1,KCOUNT	;GET NUM. LOCATIONS EXISTING.
	LSH	T1,28.
CSB2:	MOVE	T3,PDP11(T1)
	TLZ	T3,177000	;TURN OFF BREAKPOINT BITS.
	IOR	T3,T2		;SET THEM.
	TLNN	T3,377000	;IF THIS LOC. NOW NORMAL MEM.,
	MOVEI	T3,(T3)		;TURN OFF SIGN.
	MOVEM	T3,PDP11(T1)
CSB4:	AOBJN	T1,CSB2
	TLZ	SF,NUMFND
	JRST	DLOOPT

; ;F - IF NO NUMBER, ASSUME 1.
CSF:	SKIPN	DGVALP
	MOVEI	T2,1
	JRST	CSB0

; ;W, ;R -- LIKE ;F, BUT ASSUME 2, 4.
CSW:	SKIPN	DGVALP
	MOVEI	T2,2
	JRST	CSB0

CSR:	SKIPN	DGVALP
	MOVEI	T2,4
	JRST	CSB0

; :LBRKS - PRINT A SEQUENCE OF ;B COMMANDS THAT WOULD CREATE THE
;BREAKPOINTS THAT NOW EXIST.
CLBRKS:	PUSHJ	P,DGRAN
	MOVSI	T2,177000
CLBRK0:	JUMPGE	T0,CPOPJ
	TDNN	T2,PDP11(T0)
	AOBJN	T0,.-1
	JUMPGE	T0,CPOPJ
	MOVEI	T3,(T0)
	LSH	T3,1
	HLLZ	T1,PDP11(T0)
	AND	T1,T2
CLBRK1:	MOVE	T5,PDP11(T0)
	AND	T5,T2
	CAMN	T1,T5
	AOBJN	T0,CLBRK1
	MOVEI	T5,-1(T0)
	LSH	T5,1
	CAIE	T5,(T3)
	JRST	CLBRK2
	ADRTYP	T5
	JRST	CLBRK3

CLBRK2:	TTOA	[ASCIZ /< /]
	ADRTYP	T3
	TTOA	[ASCIZ /, /]
	ADRTYP	T5
	TTOA	[ASCIZ / >/]
CLBRK3:	TTOA	[ASCIZ / $ /]
	TLZE	T1,1000
	IORI	T1,1
	TLZE	T1,2000
	TLO	T1,200000
	TLZE	T1,4000
	TLO	T1,400000
	ROT	T1,6
	TLO	SF,DNUMM
	SYMTYP	T1
	TTOA	[ASCIZ / B
/]
	JRST	CLBRK0
IFN 0,[
; ;S COMMAND -- LOAD SYMBOLS FROM PALX11 LISTING.
CSS:	TTOI	" 
	MOVEI	A,CSSDEV
	PUSHJ	P,DGFIL
	TSOPEN	LOADCH,CSSDEV	;OPEN LISTING FILE.
	TLO	SF,CSSFLG	;INPUT COMES FROM IT.
CSSFF:	GETCHR			;NEW PAGE ... SKIP 2 LINES.
	CAIE	T0,^J
	JRST	CSSFF
CSSNXT:	GETCHR			;GO TO END OF LINE.
	CAIE	T0,^J
	JRST	CSSNXT
CSSLI1:	GETCHR
	CAIN	T0,^L
	JRST	CSSFF
	CAIE	T0,^I		;ELIM. SPECIAL MESSAGES.
	JRST	CSSNXT
CSSLIN:	GETCHR			;SKIP FORMAT CHARS.
	CAIE	T0,^I
	CAIN	T0," 
	JRST	CSSLIN
	CAIE	T0,^J
	CAIN	T0,^M
	JRST	CSSNXT

	CAIL	T0,"0		;DON'T LET SYMBOLS START WITH DIGITS.
	CAILE	T0,"9
	JRST	.+2
	JRST	CSSNXT
	PUSHJ	P,DGSYM		;READ IN THE SYMBOL.
	JUMPE	T2,CSSNXT	;IF LINE DOESN'T START WITH SYMBOL, SKIP IT.
	MOVEM	T2,CSSA		;SAVE NAME.
	PUSHJ	P,DGNUM		;READ ITS VALUE.
	EXCH	T2,CSSA
	PUSHJ	P,DEFSYM	;DEFINE THE SYMBOL,
	HRRZ	T2,CSSA
	JUMPN	T2,.+2
	MOVSI	T2,400000	;IF VALUE IS 0, HALF-KILL.
	CAIE	T0,"R		;IF REG. SYM.,
	JRST	.+3
	HRLI	T2,400001	;ADJUST DEF,
	GETCHR			;PASS THE "R".
	CAIE	T0,"H		;HALF-KILL IF SPECIFIED.
	JRST	.+3
	GETCHR
	TLO	T2,400000
	MOVEM	T2,1(T5)	;AND STORE THE VALUE.
	JRST	CSSLI1		;LOOK FOR ANOTHER SYMBOL ON THIS LINE.

CSSA:	0
CSSDEV:	2,,(SIXBIT/DSK/)
	0?SIXBIT/BIN/
]	;END IFN 0.
; ;A -- ATTACH DEV.
CSA:	SETOM	CSAF
	JRST	.+2

; ;D -- DETACH DEV.
CSD:	SETZM	CSAF
	MOVE	T1,[-NUMDEV,,DEVTAB]
	TTOI	" 
	SETOM	DGLINF
	JSP	T3,CCOL1	;FIND DEVICE
	SKIPE	CSAF	;CCOL1 PUSHJ'S HERE
	HLRZS	T2	;LH FOR ;A RH FOR ;D
	JRST	(T2)

CCOL1:	PUSH	P,[CCR]
CCOL2:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM		;GET DEV. NAME.
	SETZM	DGLINF
	TLNN	SF,NUMFND
	TDZA	T5,T5
	MOVEI	T5,(DL)		;T5_ARG OR 0 IF NONE.
	JUMPE	T2,CSA2
CSA0:	CAME	T2,(T1)
	AOJA	T1,CSA1
	MOVE	T2,1(T1)	;FOUND - GET DISPATCH WORD
	TLO	SF,D1CHAR	;RE-READ CHAR FOLLOWING DEV. NAME.
	PUSHJ	P,(T3)		;CALL OUR CALLER BACK
CSA4:	TLZ	SF,NUMFND+D1CHAR	;SO CCR WON'T STORE CHANGES.
	SETZM	DGLCNT
	POPJ	P,

CSA1:	AOBJN	T1,CSA0
	ERROR	(T1)	;PRINT MESSAGE AFTER PARTICULAR TABLE

DEVTAB:IRPS X,,[MASTER,CORE,DC,DCR,DCT,DF,DM,DMR,DMT,EAE
I45,LK,LP,NGDIS,NULDIS,PK,PP,PPA,PPI,PR,PRA,PRI,RK,TK,TP]
	SIXBIT/X/
	A!X,,D!X
TERMIN
	SIXBIT/DT/
	AET,,DET
NUMDEV==<.-DEVTAB>/2
	ASCIZ/DEVICE/

CSA2:	PUSH	P,[CSA4]
	ADD	T1,[1,,2]
CLCOMS:	6TYPE	(T1)
	CRF
	AOBJP	T1,CPOPJ
	AOJA	T1,CLCOMS

CSAF:	0

;SET A DEVICE'S BASIC TIME UNIT. ARG IN VIRT. 10^-7 SEC.
CDEVTI:	MOVE	T1,[-CRESTL,,CRESTB]
	JSP	T3,CCOL2	;WILL PUSHJ TO .+1 .
	TLNE	SF,NUMFND
	MOVEM	T5,(T2)
	MOVE	T2,(T2)
	JRST	CBUSS2

;RESET A DEVICE.
CRESET:	MOVE T1,[-CRESTL,,CRESTB]
	JSP T3,CCOL2
	HLRZS T2
	JRST (T2)

CRESTB:	0?0
	IRPS X,,DCR DCT DF DM LK LP PK PP PR RK RKC RKX TK TP
	IF2 IFNDEF Z!X,Z!X==CRESE1
	SIXBIT /X/
	Z!X,,X!TIM
	TERMIN
CRESTL==<.-CRESTB>/2
	ASCIZ /DEVICE/
CRESE1:	ERROR [ASCIZ /NO RESET ROUTINE/]
; ;L COMMAND - LOAD FROM FILE, ZEROING CORE AND SYMBOLS.
CSL:	SETOM	CSLFLG		;INDICATE ;L VERSUS :LOAD.
	PUSH	P,[CCR]
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD THE "L".
	JRST	.+2

; :LOAD COMMAND.
CLOAD:	SETZM	CSLFLG
	MOVEI	T5,CSLTAB	;NORMAL LOAD-TABLE.
CLOAD1:	HRRM	T5,CLOADT
	PUSHJ	P,LODFL.
	SETOM	CSLBFL		;USING BLOCK-MODE.
	SETZM	CSLBCT		;NO WORDS IN BUFFER YET.
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,DSLDEV
	SKIPN	CSLFLG		;IF WAS ;L, ZERO CORE AND SYMBOLS.
	JRST	CSL0
	SETZM	LBUSEM		;FORGET OLD BUSS ERRORS.
	SETOM	PC-SAVLNG(P)	;WILL ALWAYS SEEM PC WAS CHANGED IN DDT.
	PUSHJ	P,XRESET
	PUSHJ	P,CZTIME
	PUSHJ	P,CS%CSX	;RESET %CSX ADDR.
	HLLZS	RPS
	PUSHJ	P,CFLSYM
	MOVE	T5,[.5KBIT,,1]
	MOVEM	T5,%PATCH	;ELIMINATE PATCH AREA ADDR.
	HRRZ	T5,KCOUNT
	LSH	T5,10.		;NUM. WDS. CORE.
	MOVE	T6,[PDP11,,PDP11+1]
	SETZM	PDP11
	SKIPE	KCOUNT
	BLT	T6,PDP11-1(T5)	;ZERO ALL CORE.

CSL0:	PUSH	P,%CSX
CSL1:	CSLWRD	T3		;READ 1 WD. =BLOCK TYPE.
	JUMPL	T3,DSLDEE
	CAIL	T3,CSLMAX	;IF BAD FORMAT,
	ERROR	[ASCIZ/BINARY FILE/]
	PUSHJ	P,@CLOADT
	JRST	CSL1
CSL2:	.CLOSE	LOADCH,
	POP	P,T2	;IF %CSX WAS LOADED, MOVE CSX DEVS
	EXCH	T2,%CSX
	JRST	CS%CS0

CSLTAB:	OFFSET	-.
	CPOPJ			;0 DOESN'T START A BLOCK.
LDABS::	DSLABS			;ABSOLUTE LOADER BLOCK.
LDSYMS::DSLASY			;ENTIRE SYMBOL-TABLE.
LDCOR::	DSLCOR			;LOAD BLOCK OF CORE.
LDDSK::	DSLCOR			;LOAD BLOCK OF DISK.
LDSTE::	DSLSYM			;DEFINE SYMBOL.
LDEND::	POPJ1			;NO MORE BLOCKS.
LDCORZ::DSLZER			;BLOCK OF ZEROS.
LDTRK::	CSLDSK			;MAKE SURE DISK BLOCK EXISTS.
LDAK::	CSLAK			;INSURE MINIMUM AMOUNT OF CORE.
LDTPV::	CSLTPV			;LOAD TRAP-ACTION-TABLE.
LDDSKZ::DSLZER			;ZERO SOME DSK.
	OFFSET	0
CSLMAX==.-CSLTAB
; :LODPTR - READ FROM PTR IN 8-BIT MODE.
CLODPT:	SETZM	CSLBFL		;USE UNIT MODE.
	MOVEI	T5,CSLTAB
	HRRM	T5,CLOADT
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,[10,,(SIXBIT/PTR/)]
	JRST	CSL0

; :LODCOR -- LOAD, BUT IGNORE NON-CORE ITEMS.
CLODCO:	SETZM	CSLFLG
	JSP	T5,CLOAD1	;SPECIAL TABLE TO LOAD CORE ONLY.
	CPOPJ?DSLABS?DSLASY?DSLCOR?CSKIPC?DSLABW?POPJ1
	DSLZER?DSLABB?CSLAK?CSKIPT?DSLABB

ADFFIL:	SETZM	CSLFLG		;DON'T ZERO THINGS.
	JSP	T5,CLOAD1	;LOAD ONLY DSK. OTHER BLOCKS ARE ERROR.
	CPOPJ?ADFERR?ADFERR?ADFERR?DSLCOR?DSLABW?POPJ1
	ADFERR?CSLDSK?ADFERR?CSKIPT?DSLZER

ADFERR:	ERROR	[ASCIZ/NON-DISK FILE/]

IRPC X,,235
CSLRT!X:	SOSGE	CSLBCT
	CALL	CSLRBF
	ILDB	T!X,CSLBBP
	JRST	(D)
TERMIN

CSLRBF:	SKIPN	CSLBFL
	JRST	CSLRD1

	MOVE	T5,[-100,,CSLBUF]	;AOBJN PTR->BUFFER.
	.IOT	LOADCH,T5
	CAMN	T5,[-100,,CSLBUF]	;ERROR IF EOF.
	ERROR	[ASCIZ/BINARY FILE/]
	HLRZ	T5,T5
	MOVEI	T5,77(T5)		;NUM. WDS. READ.
	MOVEM	T5,CSLBCT
CSLRD2:	MOVE	T5,[444400,,CSLBUF]
	MOVEM	T5,CSLBBP
	RETURN

CSLRD1:	SETZM	CSLBCT
	.IOT	LOADCH,CSLBUF	;IF USING UNIT MODE.
	IOCGET	SKIPA
	JRST	CSLRD2
	ERROR	[ASCIZ/BINARY FILE/]

CADMPB:	1?0?0?0?0?0
CSLBUF:	BLOCK	100
CSLBCT:	0
CSLBBP:	0
CSLBFL:	0		;NONZERO IF BLOCK MODE.
CLOADT:	@(T3)		;R.H. WILL HAVE ADDR. OF CMD TABLE.
CSKIPT:	SKIPA	T3,[-TRPPTL,,]	;SKIP TPV BLOCK.

CSKIPC:	CSLWRD	T3		;SKIP CORE-BLOCK.
	CSLWRD	T2
	AOBJN	T3,.-1
	RETURN

DSLDEE:	CSLWRD	T2		;EACH WD FILLS 2 PDP11 WDS.
	HLRM	T2,PDP11(T3)
	AOBJP	T3,.+3
	HRRM	T2,PDP11(T3)
	AOBJN	T3,DSLDEE
	CSLWRD	T3		;NEXT BLOCK.
	JUMPL	T3,DSLDEE
	JRST	CSL2		;POSITIVE MEANS DONE.

DSLABS:	CSLWRD	T5		;FLUSH 1 WD.
	PUSHJ	P,DSLABW	;READ BLOCK LENGTH.
	MOVEI	T6,-6(T1)	;GET DATA LENGTH.
	PUSHJ	P,DSLABW	;READ ORIGIN.
	MOVEI	T5,(T1)
	ADDI	T5,3777(T6)	;LAST ADDR TO LOAD INTO +1K.
	ROT	T1,-1		;INDEXING POSITION.
	JUMPE	T6,DSLABJ	;IF JUMP-BLOCK (NO DATA).
	LSH	T5,-11.		;MIN. K NEEDED.
	TLC	T1,700000	
	TLCE	T1,700000	;UNLESS LOADING INTO DEVICE REGS,
	PUSHJ	P,CSLAK1	;INSURE THAT MUCH.
DSLAB1:	CSLWRD	T2		;NEXT WORD (=NEXT DATA BYTE).
	JUMPGE	T1,.+3		;IF STORING INTO LOW BYTE.
	DPB	T2,[101000+T1,,PDP11]	;STORE INTO HIGH BYTE,
	AOJA	T1,.+2		;GO TO NEXT WORD.
	DPB	T2,[001000+T1,,PDP11]	;STORE INTO LOW BYTE.
	TLC	T1,400000	;COMPLEMENT ADDRESS LOW BIT.
	SOJG	T6,DSLAB1	;LOOP COUNTER FOR DATA WORDS.
	CSLWRD	T5		;READ & THROW AWAY CHECKSUM.
	RETURN

DSLABJ:	JUMPL	T1,.+3		;IF ADDRESS EVEN,
	ROT	T1,1		;PUT IN 11-WORD FMT,
	HRRM	T1,%GO		;SET STARTING ADDRESS.
	CSLWRD	T5		;THROW AWAY CHECKSUM.
	CSLWRD	T5		;GET SYM. TAB. TYPE
	CAIE	T5,2
	JRST	POPJ1		;2 IS ONLY TYPE NOW.
	AOS	(P)		;EXIT AFTER READING SYMBOLS.
DSLASY:	CSLWRD	T2		;GET NEXT SYMBOL'S NAME.
	JUMPE	T2,CPOPJ	;BLOCK TERMINATED BY 0.
	CSLWRD	T3		;VALUE, FLAGS.
	TLNE	T3,10000
	JRST	DSLASY		;SKIP SYMBOL IF UNDEF.
	TLZ	T3,353760	;CONVERT PALX11 TYPE BITS TO 11SIM'S.
	TLZE	T3,4000
	TLOA	T3,1		;MOVE REGISTER FLAG. ELSE,
	TRNE	T3,-1		;IF VALUE IS 0, .5KILL .
	TLZE	T3,20000
	TLO	T3,400000	;MOVE .5KILL FLAG.
	PUSHJ	P,DEFSY2
	MOVEM	T3,1(T5)
	JRST	DSLASY
DSLABW:	CSLWRD	T2		;READ 2 BYTES,
	MOVE	T1,T2
DSLABB:	CSLWRD	T2	
	LSH	T2,10		;COMBINE INTO WORD.
	ADDI	T1,(T2)
	RETURN

DSLCOR:	CSLWRD	T3		;AOBJN PTR->BLOCK.
	HRRI	T3,1(T3)	;VIRT. ADDR. TO LOAD 1ST WORD.
	CSLWRD	T5
	MOVEM	T5,PDP11(T3)	;READ IN NEXT WD.
	AOBJN	T3,.-2
	RETURN

DSLZER:	CSLWRD	T3		;AOBJN PTR ->BLOCK TO BE ZEROED.
	HRRI	T3,1(T3)	;VIRT. ADDR. OF 1ST WD. TO ZERO.
	SETZM 	PDP11(T3)
	AOBJN	T3,.-1
	RETURN

DSLSYM:	CSLWRD	T2		;READ SYMBOL NAME.
	PUSHJ	P,DEFSY2	;DEFINE IT, GET STE.
	MOVEI	T3,(T5)
	CSLWRD	T2
	MOVEM	T2,1(T3)	;READ SYMBOL TYPE, VALUE INTO STE.
	RETURN

CSLDSK:	SKIPE	WDF
	JRST	.+3
	TTOA	[ASCIZ /ATTACHING DISK
/]
	PUSHJ	P,LODADF
	CSLWRD	T5
	MOVE	A,T5
	SKIPN	DSKDIR(A)
	JSP	D,DSKGET	;CREATE BLOCK IF NONEXISTENT.
	RETURN

CSLAK:	CSLWRD	T5		;CORE MINIMUM.
CSLAK1:	SUB	T5,KCOUNT
	JUMPLE	T5,CPOPJ		;IF ALREADY ENOUGH.
	JRST	ACORE

CSLTPV:	MOVSI	T3,-TRPPTL
	CSLWRD	T5
	MOVEM	T5,TRPPNT(T3)
	AOBJN	T3,.-2
	RETURN
; :XFILE COMMAND -- EXECUTE COMMAND FILE.
CXFILE:	MOVEI	A,CXFILN
	TLO	SF,D1CHAR	;IN CASE CMD WAS FOLLOWED BY CR.
	PUSHJ	P,DGFIL
	TSOPEN	UTIC,CXFILN
	SETOM	FILINF
	RETURN

CXFILN:	SIXBIT/   DSK      XCT/

; :CORE COMMAND -- SET TOTAL AMOUNT OF CORE TO ARG.
CCORE:	TLNN	SF,NUMFND
	SKIPA	T5,KCOUNT	;IF NO ARG, JUST PRINT NUM. K.
	MOVEI	T5,(DL)
CCORE1:	SUB	T5,KCOUNT	;AMOUNT OF K TO GO OR COME.
	JUMPGE	T5,ACORE	;IF >0, ATTACH. IF=0, JUST PRINT NUM. K.
	MOVM	T5,T5
	JRST	DCORE		;ELSE GO DETACH.

; ^L ROUTINE.
CFORMF:	SKIPE	GETTY
	TTOA	[ASCIZ/C/]	;CLEAR SCREEN.
	JRST	DLOOP1

; :LOOKUP -- FIND ADDR OF STE OF FOLLOWING SYMBOL.
CLOOKU:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DERR
	PUSHJ	P,DLKSYM	;SEARCH FOR STE.
	MOVEI	DL,(T5)
	.VALUE	[ASCIZ \T5/	'\]
	RETURN

; :ZTIME -- SET CUMULATIVE RUN TIME TO 0.
CZTIME:	MOVN	B,RTIME		;-THE TIME.
	MOVEI	A,CLINF		;WILL SHIFT ALL REMEMBERED TIMES SAME AMOUNT.
CZTIM0:	MOVE	A,1(A)		;ADDR OF NEXT BLOCK.
	CAIN	A,CLINF
	JRST	CZTIM1		;ALL DONE WHEN GET BACK TO CLINF.
	ADDM	B,(A)		;ELSE ADJUST THE TIME,
	JRST	CZTIM0		;DO NEXT BLOCK.
CZTIM1:	ADDM	B,ORGTIM	;ADJUST PK'S BASE TIME.
	ADDM	B,LBUSET	;ADJUST REMEMBERED TIMES OF BUSS ERRORS.
	ADDM	B,LBUSET-4
	ADDM	B,LBUSET-8
	SETZM	RTIME		;FINALLY ZERO TIME.
	HLLZS	RATE
	.SUSET	[.RRUNT,,RUNTB]
	RETURN
DCKSUM:	0

CADUMP:	PUSHJ P,DMPFL.	;GET THE DUMP FILE NAME
	TSOPEN DMPCH,DSLDEV
	PUSHJ P,DGRAN	;GET ARG TO COMMAND
	MOVN A,T1	;LAST ADDRESS TO DUMP
	ANDI T0,77777
	MOVE T1,T0	;FIRST ADDRESS TO DUMP
	ADD A,T0
	LSH T1,1	;T0 IS A POINTER INTO CORE, T1 IS THE ASSOCIATED PDP11 ADDRESS
	LSH A,1	;MAKE INTO PDP11 ADDRESS
	MOVEI T2,177777	;16 BITS
CADMP1:	SETZM DCKSUM
	MOVNI T3,2	;RELATIVE ADDRESS OF START ADDRESS IN BUFFER
	TDNE T2,PDP11(T0)	;SEARCH FOR A NON-ZERO WORD
	JRST CADMP2	;FOUND ONE
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAMGE T1,A	;ARE WE OVER THE TOP OF WHAT WE SHOULD DUMP?
	AOJA T0,CADMP1	;NO, INCREMENT PDP10 ADDRESS AND CONTINUE LOOKING
	JRST CADMP3	;CORE IS ALL ZERO, GO DUMP SYMBOLS
CADMP2:	MOVE T6,T1	;OUTPUT START ADDRESS
	PUSHJ P,CADOUT
CADMP4:	MOVE T6,PDP11(T0)	;GET A WORD TO DUMP
	PUSHJ P,CADOUT	;DUMP THE WORD
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAIGE T3,70	;IS THE BUFFER FULL?
	CAML T1,A	;OR ARE WE AT THE TOP OF THE SPACE TO BE DUMPED?
	JRST CADMP5	;YES, DUMP THE BLOCK
	MOVEI T6,10(T1)
	CAML T6,A	;ARE WE NEAR THE TOP OF THE SPACE TO BE DUMPED?
	AOJA T0,CADMP4	;YES, INC PDP10 ADDRESS AND DUMP RIGHT UP TO THE TOP
	TDNE T2,PDP11+1(T0)	;IF THERE ARE NOT 3 CONSECUTIVE ZEROS
	AOJA T0,CADMP4	;INC THE PDP10 ADDRESS AND KEEP DUMPING
	TDNE T2,PDP11+2(T0)
	AOJA T0,CADMP4
	TDNE T2,PDP11+3(T0)
	AOJA T0,CADMP4
CADMP5:	MOVEI T6,6(T3)	;DUMP THE CURRENT BLOCK
	MOVNI T3,4	;PLACE TO PUT THE BYTE COUNT
	PUSHJ P,CADOUT	;OUTPUT THE COUNT
	MOVN T3,DCKSUM	;GET CHECKSUM
	SUBI T3,1	;THE 1 AT THE BEGINING OF THE BLOCK WAS NOT ADDED BEFORE
	ANDI T3,377	;MASK TO 8 BITS
	MOVEM T3,CADMPB(T6)	;STORE CHECKSUM
	MOVNI T6,1(T6)	;NEGATIVE COUNT OF BYTES (1 ADDED TO COUNT CHECKSUM)
	HRLZS T6	;MAKE AOBJN POINTER
	HRRI T6,CADMPB
	.IOT DMPCH,T6	;OUTPUT BLOCK TO DISK
	AOJA T0,CADMP1	;INC PDP10 ADDRESS AND SEARCH FOR NON-ZERO CORE

CADMP3:	MOVEI T0,6	;GET READY TO OUTPUT START (JUMP) BLOCK
	MOVEM T0,DCKSUM	;INIT CHECKSUM
	MOVEM T0,CADMPB+2	;SET BYTE COUNT
	MOVNI T3,2	;PLACE FOR ADDRESS
	MOVE T6,%GO	;STARTING ADDRESS
	PUSHJ P,CADOUT	;OUTPUT TO BUFFER
	MOVN T0,DCKSUM	;GET CHECKSUM
	SUBI T0,1	;CORRECT IT
	ANDI T0,377	;MASK TO 8 BITS
	MOVEM T0,CSLBUF	;THIS IS WHERE IT BLONGS
	MOVE T0,[-7,,CADMPB]	;JUMP BLOCK IS ALWAYS THIS LONG
	.IOT DMPCH,T0
	HRROI T0,[LDSYMS]	;START OF SYMBOLS
	.IOT DMPCH,T0
	;THE FOLLOWING CHANGES 11SIM TYPE FLAGS TO PALX11 TYPE FLAGS
	MOVEI T0,SYMDMP+1
	MOVSI T1,1
	MOVSI T2,4000
	MOVSI T3,20000
	MOVSI T5,24000
CADMP6:	TDZ T5,(T0)
	TDNE T1,(T0)
	TDO T2,(T0)
	SKIPGE (T0)
	TDO T3,(T0)
	ADDI T0,2
	CAMG T0,SYMEND
	JRST CADMP6
	MOVEI T0,SYMDMP	;NOW MAKE UP AN AOBJN POINTER
	SUB T0,SYMEND	;WHICH WE CAN USE
	HRLZS T0	;TO OUTPUT THE SYMBOL TABLE
	HRRI T0,SYMDMP
	.IOT DMPCH,T0	;ALL AT ONCE
	MOVE T0,[-1,,[0]]
	.IOT DMPCH,T0	;OUTPUT A ZERO FOR THE END TEST
	.CLOSE DMPCH,
	RETURN

CADOUT:	PUSH P,T6	;BREAK A PDP11 WORD INTO BYTES AND OUTPUT IT TO THE BUFFER
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	MOVE T6,(P)
	LSH T6,-10
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	POP P,T6
	RETURN
DEFINE	DMPOW	A
	HRROI	T6,A
	.IOT	DMPCH,T6
TERMIN

;OPEN A TEMPORARY DUMP FILE FOR CURRENT COMMAND ONLY.
CODMP1:	SKIPE	DDUMPF
	POPJ	P,		;IF PERMANENT DUMP FILE, USE IT.
	JRST	CODMP2		;ELSE, OPEN A FILE.

; :ODMP -- OPEN A FILE FOR SEVERAL DUMP COMMANDS.
CODMP:	SKIPE	DDUMPF
	ERROR	[ASCIZ/WITHOUT CLOSING THE OTHER ONE/]
	PUSHJ	P,CODMP2	;OPEN PERM. FILE.
	SETOM	DDUMPF		;IF SUCCEED, INDICATE ONE IS OPEN.
	RETURN

CODMP2:	PUSHJ	P,DMPFL.
	TSOPEN	DMPCH,DSLDEV
	RETURN

; ;Y -- ALMOST SAME AS :DMP
CSY:	PUSH	P,[CCR]
	SKIPE	DDUMPF
	CRF			;IF PERM FILE, NEED NO ARG.
	SKIPN	DDUMPF
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD "Y".

; :DMP -- DUMP RANGE OF CORE, AND SYMBOLS.
CDMP:	PUSHJ	P,CODMP1	;OPEN TEMP. FILE IF NECESSARY.
	PUSHJ	P,CSD0		;DUMP RANGE OF CORE.
	PUSHJ	P,DMPTPV	;DUMP TRAP ACTION CODES.
CDMP2:	PUSHJ	P,DMPSYM	;DUMP SYMBOLS.
	JRST	CDUMPX		;CLOSE FILE IF TEMPORARY.

; :DMPCOR -- DUMP SPECIFIED RANGE OF CORE, ONLY.
CDMPCO:	PUSHJ	P,CODMP1
	PUSHJ	P,CSD0
CDUMPX:	SKIPE	DDUMPF		;IF DUMP FILE TEMPORARY, CLOSE IT.
	RETURN
	DMPOW	[[LDEND]]	;OUTPUT AN END BLOCK,
	.CLOSE	DMPCH,
	RETURN

; :DMPSYM -- DUMP SYMBOLS ONLY.
CDMPSY:	PUSHJ	P,CODMP1
	JRST	CDMP2

;READ A FILENAME INTO DSLDEV FOR LOADING, DUMPING RESP.
LODFL.:	SKIPA	A,[6,,]
DMPFL.:	MOVSI	A,7
	HLLM	A,DSLDEV
	MOVEI	A,DSLDEV
	TLO	SF,D1CHAR
	JRST	DGFIL
; :DMPTPV - DUMP TRAP-ACTION-CODES.
CDMPTP:	PUSHJ	P,CODMP1
	PUSHJ	P,DMPTPV
	JRST	CDUMPX

DMPTPV:	DMPOW	[[LDTPV]]
	MOVE	T6,[-TRPPTL,,TRPPNT]
	.IOT	DMPCH,T6
	RETURN

; :DMPDF -- DUMP DISK ONLY.
CDMPDF:	PUSHJ	P,CODMP1
	PUSHJ	P,DMPDSK
	JRST	CDUMPX

; :CDMP -- CLOSE PERMANENT DUMP FILE.
CCDMP:	SETZM	DDUMPF
	JRST	CDUMPX

DMPSYM:	DMPOW	[[LDSYMS]]
	MOVN	T6,SYMEND
	HRLZI	T6,SYMDMP-2(T6)
	HRRI	T6,SYMDMP
	.IOT	DMPCH,T6
	DMPOW	[[0]]
	RETURN

DMPDSK:	SETOM	CSDTYP		;CORE VS. DSK FLAG FOR BLOCK TYPES.
	SETZB	T2,DMPTRK	;TRACK 0.
DMPDS1:	SKIPN	T5,DSKDIR(T2)
	JRST	DMPDS2		;SKIP TRACK IF NONEXISTENT.
	DMPOW	[[LDTRK]]		;TRACK EXISTS -
	DMPOW	T2		;OUTPUT "MAKE SURE IT EXISTS" BLOCK.
	HRLI	T5,-2000	;AOBJN PTR->TRACK.
	PUSHJ	P,DSD1		;DUMP THE TRACK.
DMPDS2:	AOS	T2,DMPTRK
	CAIL	A,200
	POPJ	P,		;ALL TRACKS DONE HERE.
	JRST	DMPDS1

DMPTRK:	0
DSLDEV:	SIXBIT/   DSK      BIN/
CSDTYP:	0		;OUTPUT BLOCK TYPES 3,7 IF 0, TYPES 4, 13 IF -1.
		;TYPES 3,7 ARE FOR CORE; TYPES 4, 13 FOR DISK.
;INTERPRET ARG AS RANGE OF CORE TO DUMP.
CSD0:	PUSHJ	P,DGRAN
	MOVE	T5,T0
	SETZM	CSDTYP		;DUMPING CORE.

;DUMP OUT ALL CORE, AS BLOCK TYPES COR AND ZER.
DSD1:	DMPOW	[[LDAK]]	;BLOCK TO INSURE ENOUGH CORE
	HLRO	T2,T5
	MOVN	T2,T2		;NUM. WDS. BEING DUMPED.
	ADDI	T2,1777(T5)
	LSH	T2,-10.	;NUM. OF THE K CONTAINING LAST WD DUMPED.
	DMPOW	T2
	SKIPE	PDP11(T5)	;WHICH TYPE BLOCK FIRST?
	JRST	CSDCOR		;IF NONZERO, COR BLOCK FIRST.
CSDZER:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDZE0:	SKIPN	PDP11(T5)
	AOBJN	T5,CSDZE0	;MOVE TILL NONZERO WD OR END OF RANGE.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVN	T1,CSDTYP	;BLOCK TYPE 7 OR 13  .
	LSH	T1,2
	ADDI	T1,7
	DMPOW	T1
	DMPOW	T2
	JUMPGE	T5,CPOPJ	;IF EXHAUSTED RANGE TO DUMP.

CSDCOR:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDCO1:	SKIPN	PDP11(T5)
	SKIPE	PDP11+1(T5)
	AOBJN	T5,CSDCO1	;ADVANCE TILL END, OR 2 ZEROS.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVEI	T1,3
	SUB	T1,CSDTYP	;COMPUTE BLOCK TYPE, DSK VS. COR.
	MOVE	T6,[-2,,T1]
	.IOT	DMPCH,T6
	HRRI	T2,1+PDP11(T2)	;AOBJN PTR FROM IOWD.
	.IOT	DMPCH,T2
	JUMPL	T5,CSDZER	;IF NOT AT END.
	RETURN
; ;X - EXECUTE THE FOLLOWING INSN.
CSX:	TTOI	" 
	SETOM	CSXR1
	MOVE	T5,R1
	TLNE	SF,NUMFND	;IF HAD ARG,
	HRRZM	T5,CSXR1	;SAVE R1,
	TLZE	SF,NUMFND
	HRRM	DL,R1		;PUT ARG II IT.
	HRRZ	DO,%CSX		;ADDR. TO STORE INSN IN.
	ANDCMI	DO,1
	SETOM	DGVLVL
	PUSHJ	P,DGVAL		;READ THE INSN.
	TLO	SF,NUMFND
	MOVEI	DL,(T2)
	SKIPE	DGVALP		;IF GOT ONE, STORE IT.
	PUSHJ	P,DCLOSE
	HRRO	T5,R7
	MOVEM	T5,CSXPC	;SAVE PC WHILE SIMULATING INSN.
	MOVE	T5,PC-SAVLNG(P)	;GET SAVED OLD PC.
	MOVEM	T5,CSXSPC	;REMEMBER IT.
	HRRM	DO,R7
	MOVE	T5,DDONXT
	MOVEM	T5,CSXDNX
	MOVE	T5,%IL
	MOVEM	T5,CSXIL	;SAVE LENGTH OF NEXT INSN.
	MOVE	T5,%CSN
	MOVEM	T5,CSXCSN	;SAVE ;N MODE, LEAVE IT.
	HLLOS	%CSN
	MOVE	T5,-17(P)	;SAVE DDT'S CURRENT RETADDR.
	MOVEM	T5,CSXRET
	JRST	CSP

CSXPC:	0
CSXR1:	0
CSXDNX:	0
CSXRET:	0
CSXSPC:	0
CSXIL:	0
CSXCSN:	0
CSXHAK:	SKIPL	DDTPDP
	TLNN	B,10000		;ATTEMPTED TO FETCH INSN AFTER
	RETURN			; ;X'ED INSN:
	SKIPN	CSXPC		;RETURN TO DDT.
	RETURN
	REST	B
	HRRZ	PC,CSXPC
	HRRM	PC,R7
	HRRM	PC,%PC
	MOVE	PC,CSXSPC	;RESTORE SAVED ENTRY PC.
	SAVE	CSXRET		;  RETURN ADDR,
	SAVE	[DDTXIT]
	SETZM	CSXPC
	CALL	SAVALL
	SETZM	RUN
	MOVEM	P,DDTPDP	;ENTER DDT WITHOUT PRINTING INSN.
	MOVEM	TIME,RTIME
	HRRM	PS,RPS
	MOVE	T5,CSXDNX
	MOVEM	T5,DDONXT
	MOVE	T5,CSXCSN
	MOVEM	T5,%CSN
	MOVE	T5,CSXIL
	MOVEM	T5,%IL
	SKIPL	T5,CSXR1	;RESTORE R1 IF WAS SAVED.
	HRRM	T5,R1
	PUSHJ	P,MERRV		;TURN ON TTY.
	TTOI	"!
	JRST	DDT2

; :S%CSX - SET %CSX AND STORE CSX DEVICES.
CS%CSX:	MOVEI	T2,177720	;NORMAL VAL. OF %CSX IS DEFAULT.
	TLNE	SF,NUMFND
	MOVE	T2,DL
CS%CS0:	TLNE	T2,REGBIT
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	T2,1
	ERROR	[ASCIZ/ODD ADDRESS/]
	HRRZ	T5,%CSX		;OLD ADDR.
	LSH	T5,-1
	HRLI	T5,-3		;REMOVE THE 3 OLD CSX DEVICES:
CS%CS2:	MOVE	T6,PDP11+1(T5)
	TLZ	T6,777		;REMOVE THE DEVICE CODE.
	TLNN	T6,177000	;UNLESS BKPT THERE,
	TLZ	T6,400000	;TURN OFF SPECIAL BIT.
	MOVEM	T6,PDP11+1(T5)
	AOBJN	T5,CS%CS2
	HRRM	T2,%CSX		;STORE NEW ADDR.
	ROT	T2,-1
	ANDI	T2,77777
	HRLI	T2,-3
CS%CS1:	MOVE	T5,PDP11+1(T2)	;STORE CSX DEVS THERE+1 THRU THERE+3 .
	TLZ	T5,777
	TLO	T5,600000+NCSX
	MOVEM	T5,PDP11+1(T2)
	AOBJN	T2,CS%CS1
	RET
; ^\ COMMAND - ALMOST AS IN HACTRN.
CCBSL:	MOVE	DL,%PATCH	;PATCH WILL -> PATCH AREA.
	PUSHJ	P,CPAT0		;STORE THE PATCH.
	JRST	CTAB		;OPEN LOC. ADDRESSED BY PATCH.

; ^] COMMAND
CCRB:	JUMPL	DO,CPATNO	;IF NO LOC. OPEN.
	TLNN	SF,NUMFND	;IF HAVE ARG,
	JRST	CCRB1
	CALL	DCLOSE		;STORE IT,
	ADDI	DO,(DLEN)	;PATCH AFTER IT.
CCRB1:	HRRZ	DL,%PATR	;PATCH BACK INTO SEQUENCE.
	SETOM	CPATTY
	CALL	CPAT3		;STORE THE PATCH.
	ADDI	DO,2
	HRRM	DO,%PATCH	;UPDATE PATCH AREA ADDR.
	HRRM	DL,DPNT		;SET . TO PLACE PATCH WAS FROM (%PATR).
	JRST	CCRLF

; :PAT - PUT IN THE OPEN LOC., A PATCH DEVICE -> ARG.
CPAT:	CALL	DGVPSP		;READ ADDR. OF PATCH.
	MOVE	DL,T2
	SKIPE	DGVALP		;REQUIRES AN ARG.
	CAIE	DLEN,2		;MUST HAVE ARG OF LENGTH 2.
	ERROR	[ASCIZ/WHITHER/]
CPAT0:	JUMPL	DO,CPATNO	;IF NO LOC. OPEN.
	SETZM	CPATTY
CPAT3:	TLNE	SF,BYTOPN
	ERROR	[ASCIZ/PATCH BYTE/]
	TLNE	DO,REGBIT
	ERROR	[ASCIZ/PATCH ACCUM./]
	TLNE	DL,REGBIT
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	DL,1
	ERROR	[ASCIZ/TO ODD ADDRESS/]
	TLZ	SF,NUMFND	;ENSURE ADDR. IS STORED.
	PUSHJ	P,DCLOS0	;SET UP ADDR IN T3.
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	DPB	DL,[2000+T3,,PDP11]
	MOVEI	T5,600000+NCPAT
	HRLM	T5,PDP11(T3)	;TURN LOC. INTO A PATCH.
	SKIPE	CPATTY		;IF NOT ^],
	RET
	ADDI	DO,@%OL		;FIND END OF INSN REPLACED,
	HRRM	DO,%PATR	;^] WILL PATCH BACK THERE.
	RET
;COME HERE ON ACCESSING A PATCH-DEVICE.
CPATHA:	SKIPE	DDTPDP
	JRST	CPAT1
	POP	P,(P)		;DELETE RET. ADDR. IN MTRAP.
	TLNE	B,66000
	JRST	MTRAP2		;IF RRAD OR WROTE, TREAT AS BKPT.

CPAT2:	MOVEI	PC,(A)		;IF FETCHING, 
	LSH	PC,-1		;BRANCH TO ADDRESSED LOC.
	SKIPE	B,TRPPNT
	PUSHJ	P,BRPNT
	JRST	INEND

;COME HERE IF ACCESSED BY DDT.
CPAT1:	TLNE	B,20000
	SETZM	@-2(D)		;IF WRITING, FLUSH THE PATCH.
	TLNN	B,20000		;IF READING,
	TLNE	SF,DEXCM	;IF NOT ! MODE,
	RETURN
	TTOA	[ASCIZ/  :PAT/]	;ANNOUNCE THE PATCH.
	RETURN

CPATNO:	ERROR	[ASCIZ/WHENCE/]

; :ALTSEM -- EXCHANGE FUNCTIONS OF ; AND $ IN COMMANDS.
CALTSE:	SETCMM	CALTSF
	MOVEI	T5,"
	MOVEI	T6,";
	SKIPN	CALTSF		;IF NOW SWITCHED STATE,
	JRST	CALTS0
	MOVEM	T5,SEMICL	;$ TREATED AS ;,
	MOVEM	T6,ALTMOD	;; TREATED AS $.
	TTOA	[ASCIZ/SWITCHED
/]
	RETURN

CALTS0:	MOVEM	T5,ALTMOD	;NORMAL STATE, $ TREATED AS $,
	MOVEM	T6,SEMICL	;; TREATED AS ;.
	TTOA	[ASCIZ/NORMAL
/]
	RETURN

; ;N - LIKE $$^N IN 10-DDT.
CSN:	TLNE	SF,NUMFND	;IF NO ARG,
	JRST	CSN2
	HRRZ	DL,%PC		;USE ADDR AFTER END OF NEXT INSN.
	ADDI	DL,@%IL
CSN2:	LSH	DL,-1		;WILL COMPARE WITH PC.
	ANDI	DL,77777
	HRRM	DL,%CSN		;RUN TILL GET THERE.
	HRLOI	T5,277777
	MOVEM	T5,INSCNT
	JRST	CSN1
;GO TO ADDRESS ARG.
CSG:	TLNN	SF,NUMFND
	HRRZ	DL,%GO		;IF NO ARG, USE STARTING ADDR.
	ANDI	DL,177777
	HRRM	DL,R7		;IF HAD ARG, GO TO THAT ADDR.
	SETOM	PC-SAVLNG(P)	;INDICATE TERMINATE INSN.
	AOJ	T2,
	MOVEM	T2,INSCNT	; ;G WITH INNER ARG MEANS STEP
	SKIPE	DGVALP		;THAT MANY INSNS.
	JRST	CSN1
CSP:	MOVE	T5,%CSN		;IF IN ;N MODE
	CAME	T5,[.5KBIT,,-1]
CSN1:	SKIPA	T2,[JRST CNTINS]
	MOVE	T2,[SKIPGE I,PDP11(PC)]
CSP1:	MOVEM	T2,INBEG
	SKIPE	ETNFIN		;IF DT WAS CHANGED, NOT FINISHED,
	CALL	ETOFIN		;FINISH IT NOW.
	HRRZ	T5,R7
	TRNE	T5,1		;TRAP IF NEW PC ODD.
	JSP	D,DBNDE
	MOVE	C,RTIME		;TURN OFF DDONXT AFTER 1 INSN AT MOST.
	AOS	C
	MOVEI	A,DDTXTP
	PUSHJ	P,CLQADD
RSTALL:	HRLZI	T6,-SAVLNG+1(P)	;SET UP BLT POINTER.
	HRRI	T6,A
	BLT	T6,T6
	SUB	P,[SAVLNG,,SAVLNG]	;POINT TO BEFORE SAVED REGS.
	POP	P,RSTPC		;RESTORE FLAGS.
	JRSTF	@RSTPC

DDTXIT:	HRRZ	TIME,R7
	ROT	TIME,-1
	CAMN	TIME,PC		;IF PC CHANGED,
	JRST	DDTXI1
	SETZM	DDONXT		;FETCH BREAKPOINTS CAN HAPPEN.
	SETZM	WAITFL
	SETZM	(P)		;START AT BEGINNING OF INSN.
	MOVEI	PC,(TIME)
DDTXI1:	MOVE	TIME,RTIME
	.RESET	TYIC,
	CRF
	.CALL	TTYM2
	.VALUE
	SETZM	DDTPDP
	SETOM	RUN
	HRRZ	PS,RPS		;IN CASE CHANGED IN DDT.
	NEWPS
	SETOM	OPC		;INDICATE JUST LEFT DDT.
	POP	P,RSTPC
	SKIPE	RSTPC
	JRSTF	@RSTPC
	MOVE	P,[-PDLSIZ,,PDL]
	JRST	INEND		;RET. ADDR. 0 MEANS RESTART.

DDTXTP:	0
	-1
	SETZM	DDONXT
TTYGT:	SETZ
	SIXBIT/TTYGET/
	[TYIC]
	2000,,T0
	2000,,T0
	402000,,A

;NORMAL DDT TTYSET.
TTYM1:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,222222]
	400000,,TTYM1A

;NORMAL SIMULATOR TTYSET.
TTYM2:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[131313,,131313]
	[131313,,131313]
	400000,,TTYM1A

;DDT TTYSET TO ACTIVATE ON NEXT CHAR.
TTYMA:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,222222]
	400000,,TTYMAA

TTYM1A:	0		;SET UP AFTER TTYGT AFTER $G'D.
TTYMAA:	0
IOCTAB:	BLOCK IOCNUM
IOCEND:

ALTMOD:	"	;CHAR TREATED AS $ (EITHER $ OR ;).
SEMICL:	";	;CHAR TREATED AS ; (EITHER $ OR ;, NOT=ALTMOD).
CALTSF:	0	;NOT 0 IFF $ AND ; ARE SWITCHED.
OPC:	0	;ADDR OF CURRENT OR PREVIOUS INSN.
GETTY:	0	;SET IFF GRAPHICS TTY.
INSCNT:	0	;NUM. INSNS TO EXECUTE IN SNGL-STEP MD.
CPATTY:	0	;LOCAL TO CPAT, CCRB, CCBSL.
RSTPC:	0
DDTPDP:	0
DDONXT:	0
CSLFLG:	0
DRDBRF:	0
DINITF:	0
DGVLVL:	-1		;LEVEL OF RECURSION AT DGVAL.
DGVRGP:	0		;NONZERO IF THIS VALUE IS REGISTER NUM.
DGVALP:	0		;NONZERO IF DGVAL, DGNUM ETC. FINDS A VALUE.
S%OLFL:	0	;SET WHILE %Q REMAINS WHAT WAS OPENED.
DDUMPF:	0	;SET IF PERMANENT DUMP FILE OPEN.

DNOARG:	ERROR	[ASCIZ/ARG/]

IRP REGNUM,,[0,1,2,3,4,5,6]
R!REGNUM:	0
TERMIN			;PDP11 REGISTERS HERE.
R7:	600000+NPC,,0

CONSTANTS	;DON'T WANT CONSTANTS AT END SO SYM TAB CAN VARY IN LENGTH
SYMEND:	LASTST		;ALWAYS -> LAST STE IN USE.

;INITIAL SYMBOL TABLE

;FORMAT OF STE:
;	WORD 1:	NAME OF SYMBOL, IN SIXBIT.
;	WORD 2:	SIGN BIT: IF SET, SYMBOL IS HALF-KILLED.
;		REST OF LH: SYMBOL TYPE.
;		RH:  VALUE.

	DEFINE	.5KILL	A,B,C
	SIXBIT/A/
	IFSN C,,C:
	IFSE C,,A:
	.5KBIT,,IFSN B,,B
	TERMIN

	.=.+<.&1>		;GO TO EVEN ADDR.
SYMTAB:	REPEAT	10,[
	<'%_36>+<<'0+.RPCNT>_30>
	1,,.RPCNT
	]		;DEFINE %0 ... %7 .

;INSN. SPECIAL SYMBOLS.

	INSNUM==0
IRP INSN,,[MOV,CMP,BIT,BIC,BIS]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	2,,INSNUM
	SIXBIT/INSN!B/	;BYTE INSN DEF.
	2,,10+INSNUM
TERMIN
	SIXBIT/ADD/	;2 EXCEPTIONS.
	2,,6
	SIXBIT/SUB/
	2,,16

;SINGLE OPERAND INSN SYMBOLS.
	INSNUM==0
IRP INSN,,[CLR,COM,INC,DEC,NEG,ADC,SBC,TST,ROR,ROL,ASR,ASL]
	SIXBIT/INSN/
	3,,INSNUM+50	;WORD INSN.
	SIXBIT/INSN!B/
	3,,INSNUM+1050	;BYTE INSN.
	INSNUM==INSNUM+1
TERMIN

	SIXBIT/JMP/
	3,,1
	SIXBIT/SWAB/
	3,,3
	SIXBIT/SXT/
	3,,64
;BRANCH INSN SYMBOLS:
	INSNUM==0
IRP INSN,,[BR,BNE,BEQ,BGE,BLT,BGT,BLE]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	6,,INSNUM*400
TERMIN

	INSNUM==100000
IRP INSN,,[BPL,BMI,BHI,BLOS,BVC,BVS,BCC,BCS]
	SIXBIT/INSN/
	6,,INSNUM
	INSNUM==INSNUM+400
TERMIN

	SIXBIT/BHIS/
	6,,103000
	SIXBIT/BLO/
	6,,103400

	SIXBIT/JSR/
	4,,4
	SIXBIT/RTS/
	5,,20

	SIXBIT/TRAP/
	7,,104400
	SIXBIT/EMT/
	7,,104000

	SIXBIT/SFL/
	10,,260
	SIXBIT/CFL/
	10,,240

	SIXBIT/SOB/
	13,,0
	SIXBIT/MARK/
	13,,1
	SIXBIT/SPL/
	13,,2

	INSNUM==70
IRP INSN,,[XOR,,MUL,DIV,ASH,ASHC]
	SIXBIT/INSN/
	4,,INSNUM
	INSNUM==INSNUM+1
TERMIN

	INSNUM==0
IRP INSN,,[HALT,WAIT,RTI,BPT,IOT,RESET,RTT]
	SIXBIT/INSN/
	INSNUM
	INSNUM==INSNUM+1
TERMIN
;DEVICE REGISTERS:

SYMDRG:
IRP REG,,[DIV,MUL,AC,MQ,NOR,LGS,ARS,SCSR,PS,PRS,PRB,PPS,PPB
TKS,TKB,TPS,TPB,LKS,SWR,NGCSR,NGREL,DCS,WC,CMA,DAR,DAE,ADS
PKCSR,PKCSB,PKC,RCSR,RBUF,TSCR,TBUF,LPS,LPB,PIR
CSR,BAR,BCR,TBR,TCCM,TCST,TCWC,TCBA,TCDT,RKDS,RKER
RKCS,RKWC,RKBA,RKDA]
	SIXBIT/%!REG/
	<R!REG-PDP11>*2
TERMIN

	SIXBIT/%SR/
	<RSCSR-PDP11>*2
	SIXBIT/%SC/
	<RSCSR-PDP11>*2+1

SYMLST:	.5KILL	.,0,DPNT,	;SYMBOL . .
	.5KILL	%Q,0		;LAST QTY IN OR OUT.
	.5KILL	%P,0		;LAST PART OF MULTI-WORD EXP.
	.5KILL	%D,0		;LAST DEST. ADDR.
	.5KILL	%S,0		;LAST SRC. ADDR.
	.5KILL	%L,0		;LENGTH OF LAST QTY IN OR OUT.
	.5KILL	%OL,0		;LENGTH OF WHAT WAS LAST OPENED.
	.5KILL	%IL,0		;LENGTH OF INSN %PC POINTS TO.
	.5KILL	%CSN,-1		;RH IS -1 OR HALF PC TO STOP AT (;N).
	.5KILL	%.,0,DOPEN,	;LOCATION OPEN.
	.5KILL	%OPC,0		;PC OF CURRENT OR LAST INS.
	.5KILL	%B,0		;ADDR OF LAST BREAKPOINT.
	.5KILL	%CORE,0		;NUM. BYTES CORE.
	.5KILL	%,0,%PC,	;PC AT ENTRY TO DDT.
	.5KILL	%JPC,0		;SOMETIMES, ADDR OF LAST PC CHANGE.
	.5KILL	%PATR,0		;ADDR AFTER PLACE PATCH WAS PUT.
	OMODE==DINSM+DSYMM
SYMDMP:	.5KILL	%CSX,2*<RCSX-PDP11>	;ADDR FOR ;X .
	.5KILL	PATCH,1,%PATCH,	;PATCH AREA FOR ^\, ^].
	.5KILL	%PMODE,OMODE	;PERMANENT MODE.
	.5KILL	%TMODE,OMODE	;TEMPORARY MODE.
	.5KILL	%GO,0		;STARTING ADDRESS FOR ;G.

LASTST=.-2

	END	BEG
