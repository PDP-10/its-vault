;UFD INFO
;USER DIR IN TRACK NUMBERED SAME AS INDEX IN MFD (SEE QFL2)

IF1 [PRINTX \DIRECTORY TYPE = \
.TTYMAC A
DEFINE DIRTYP X
<IFSN X,A,[1]>,TERMIN
TERMIN ]

NUDSL==200.	;# UFDS SPACE RESERVED
UFDBYT==6	;SIZE OF BYTES
UFDBPW==36./UFDBYT	;NUMBER OF BYTES PER WORD
	;RANDOM INFO

IFE DIRTYP ARC,[
	ARCTYP==0	;-1=>NEW ARCHIVE, OTHERWISE OLD FORMAT
	UDESCP==1	;FS PNTR TO DESC AREA
	UDNAMP==2	;PNTR TO ORG OF NAME AREA
	GCTAG==3	;DATE/TIME OF LAST GARBAGE COLLECT
]

IFE DIRTYP DSK,[

	UDESCP==0
	UDNAMP==1
	UDNAME==2
]

	UDDESC==11.	;FIRST LOC AVAIL FOR DESC

	;UFD DESCRIPTORS
	;0 => FREE  1-UDTKMX => TAKE NEXT N
	;UDTKMX+1 THRU UDWPH-1 => SKIP N-UDTKMX AND TAKE ONE
	;40 BIT SET => LOAD ADDRESS.  LOWER 5 BITS PLUS NEXT TWO CHARS (17 BITS IN ALL)

	;IF LINK DESCR
	;6 CHAR OR UNTIL ; = SYS NAME.  MUST HAVE NO CHAR = 0 IN THIS OR NEXT 2 NAMES
	;NEXT CHAR QUOTED BY : (FOR NAMES WITH : OR ;)
	;NEXT CHAR N1
	;NEXT CHAR N2
	;END BY 0

	UDTKMX==12.	;HIGHEST "TAKE N" CODE
	UDWPH==31.	;PLACE HOLDER ON WRITE (OR NULL FILE)
;	NXLBYT==2	;# ADDITIONAL BYTES FOR LOAD ADDR
			;ACTUAL PARAMETER ASSIGN MUST BE AT FRONT OF FILE

	;NAME AREA DATA

	LUNBLK==5	;WDS/NAME BLK
	UNFN1==0	;FIRST FN
	UNFN2==1	;SECOND FN
	UNRNDM==2	;ALL KINDS OF RANDOM INFO
		UNDSCP==1500,,	;PNTR TO DESC

		UNPKN==150500,,	;PACK #
		UNBOJN==150500,,	;BOJ # ON LAST WRITE

		UNLINK==1	;LINK BIT
		UNLNKB==220100,,
		UNWRIT==4	;OPEN FOR WRITING
		UNMARK==10	;GC MARK BIT
		UNCDEL==20	;DEL WHEN CLOSED
		UNPDEL==40	;DEL FROM UNMOUNTED PACK
		UNDS1==100000	;HAS BEEN HALF DELETED AND HAS 1 STRIKE
		UNHD==200000	;HAS BEEN HALF DELETED
		DELBTS==UNCDEL+UNPDEL+UNHD	;DELETED -- IGNORE
		UNIGFL==DELBTS+UNWRIT	;BITS TO IGNORE FILE
		UNWRDC==301200,,	; WORD COUNT OF LAST BLOCK MOD 2000
		UNDUMP==400000	;HAS BEEN DUMPED
	UNDATE==3	;DATE ETC.
		UNTIM==2200,,	;COMPACTED TIME OF CREATION
		UNYMD==222000,,	;Y,M,D OF CREATION
		UNMON==270400,,	;MONTH
		UNDAY==220500,,	;DAY
		UNYRB==330700,,
	UNREF==4	; REFERENCE DATE SAME AS LEFT HALF OF UNDATE

QFNG:	SKIPA C,[SETZ]	;GENERATE FILE NAME TO REPLACE < OR > ON WRITE
QLOOK:	MOVEI C,0
	PUSH P,J	;Q_FILE #
	MOVEI J,ARCDIR	;GET POINTER TO SHARED COPY OF DIRECTOYR
	MOVEI Q,2000-LUNBLK(J)
	ADD J,UDNAMP(J)
	CAMN A,[SIXBIT />/]
	TLOA J,400000
	CAMN A,[SIXBIT /</]
	JRST QLOOKA	;4.9 BIT OF J SET IF >
	CAMN B,[SIXBIT />/]
	TLOA J,400000
	CAMN B,[SIXBIT /</]
	AOJA C,QLOOK1
	PUSHJ P,QLGLK
	JRST POPJJ	;FNF
	TRNN J,1777
	JRST POPJJ	;J IS OFF THE END OF THE BLOCK
	PUSH P,C
	EXCH Q,J
QLK1:	CAMN A,UNFN1(Q)
	CAME B,UNFN2(Q)
	JRST QLK3	;FNF
	MOVE C,UNRNDM(Q)
	TLNN C,UNIGFL	;BEING WRITTEN OR DELETED
	JRST QLK2	;FOUND IT
	SUBI Q,LUNBLK	;SEARCH THROUGH * FILES
	CAML Q,J
	JRST QLK1
QLK3:	POP P,C
POPJJ:	POP P,J
	POPJ P,

QLK2:	AOS -2(P)
	JRST QLK3


QLOOKA:	CAME B,[SIXBIT /</]
	CAMN B,[SIXBIT />/]
	JRST POPJJ	;MUST BE READ RETN FILE NOT FOUND
QLOOK1:	PUSH P,D
	PUSH P,TT
	PUSH P,I
	PUSH P,[-1]	;BEST INDEX
	PUSH P,[SETZ]	;BEST "NUMERIC" PART
	PUSH P,[SETZ]	;BEST ALPHA PART
QLOOK4:	CAIGE Q,(J)
	JRST QLOOK2
	MOVE D,UNRNDM(Q)
	TLNE D,UNIGFL
	JUMPGE C,QLOOK3	;IF CONJURING NAME FOR WRITE, CONSIDER ALL
	XCT QLKI1(C)
	JRST QLOOK3
	SKIPE TT,@QLKI1+1(C)
QLOOK6:	TRNE TT,77	;RIGHT ADJ
	JRST QLOOK5
	LSH TT,-6
	JRST QLOOK6
QLOOK5:	MOVEI I,0
QLOOK8:	LDB D,[600,,TT]
	CAIL D,'0
	CAILE D,'9
	JRST QLOOK7	;NOT A DIGIT
QLOK5B:	TRNE I,77	;RIGHT ADJ LOW NON NUM PART
	JRST QLOK5A
	LSH I,-6
	JUMPN I,QLOK5B
QLOK5A:	TLC TT,400000	;AVOID CAM LOSSAGE
	TLC I,400000
	SKIPGE -2(P)
	JRST QLOK5D	;FIRST MATCH
	JUMPGE J,QLOK5E	;GET LEAST
	CAMGE TT,-1(P)	;GET GREATEST
	JRST QLOOK3
	CAME TT,-1(P)
	JRST QLOK5D
	CAMGE I,(P)
	JRST QLOOK3	;NOT AS GOOD
QLOK5D:	HRRZM Q,-2(P)
	MOVEM TT,-1(P)
	MOVEM I,(P)
QLOOK3:	SUBI Q,LUNBLK
	JRST QLOOK4


QLOK5E:	CAMLE TT,-1(P)
	JRST QLOOK3
	CAME TT,-1(P)
	JRST QLOK5D
	CAMLE I,(P)
	JRST QLOOK3
	JRST QLOK5D

QLOOK7:	LSHC TT,-6	;LOW DIGIT NOT NUMERIC
	JUMPN TT,QLOOK8	;NO NUMERIC DIGITS AT ALL ("BIN", MAYBE?)
	JUMPL J,QLOK5B	;IF LOOKING FOR GREATEST, LET THIS BE LEAST
	MOVNI TT,1	;GREATEST IF LOOKING FOR LEAST
	JRST QLOK5B

QLOOK2:	JUMPL C,QFNG1	;REALLY WANT TO MAKE F.N.'S FOR WRITE
	SUB P,[1,,1]
	POP P,C	;BEST "NUMERIC" PART
	POP P,Q	;ADR
	POP P,I
	POP P,TT
	POP P,D
	JUMPL Q,POPJJ
	MOVE A,UNFN1(Q)	;ACTUAL MATCHED FILE NAMES
	MOVE B,UNFN2(Q)
	POP P,J
	AOS (P)
	POPJ P,


QFNG1:	SKIPGE -2(P)
	JRST QFNG2	;NOT FOUND START W/ 1
	MOVE TT,-1(P)
	TLC TT,400000
	MOVE I,[600,,TT]
QFNG3:	LDB D,I
	CAIL D,'0
	CAILE D,'9
	JRST QFNG4	;REACH END OF NUMERIC FIELD
	AOS D
	CAILE D,'9
	JRST QFNG5
	DPB D,I
QFNG5A:	TLNE TT,770000
	JRST QFNG3A
	LSH TT,6
	JRST QFNG5A

QFNG2:	MOVSI TT,(SIXBIT /1/)
QFNG3A:	MOVEM TT,A(C)	;STORE INTO A OR B AS APPRO
	SUB P,[3,,3]
	POP P,I
	POP P,TT
	POP P,D
	JRST POPJJ


QFNG5:	MOVEI D,'0
	DPB D,I
	ADD I,[60000,,]
	JUMPL I,QFNG5A
	JRST QFNG3

QFNG4:	TLNN TT,770000	;SKIP ON ALREADY 6 CHAR NAME
	LSH TT,6
	MOVEI D,'1
	DPB D,I
	MOVEI D,'0
QFNG4B:	TLNN I,770000
	JRST QFNG5A
	IDPB D,I
	JRST QFNG4B

QLKI1:	CAME B,UNFN2(Q)
	CAME A,UNFN1(Q)
	UNFN2(Q)


;ROUTINE TO FIND PLACE IN DIRECTORY WHERE A B WOULD GO
;SKIPS ONL IF DIRECTORY CONTAINS AT LEAST ONE FILE
;FOR INSERTION, FILE GOES BEFORE PNTR RETURNED IN J
;RETURNS PNTR IN Q TO BEGINNING OF NAME AREA
;(ONLY WORKS FOR LUNBLK = 5)

QLGLKB:	MOVEI J,BLOCK3		; DO LOOKUP IN SCRATCH BLOCK
	SKIPA
QLGLK:	MOVEI J,ARCDIR
	HRRZ Q,UDNAMP(J)
	ADDI Q,(J)
	CAIL Q,2000(J)
	POPJ P,	;DIRECTORY EMPTY
	TLC A,(SETZ)
	TLC B,(SETZ)
	PUSH P,D
	PUSH P,E
	ADDI J,600
REPEAT 7,[
	CAMGE J,Q
	JRST .+6
	MOVE D,UNFN1(J)
	TLC D,(SETZ)
	CAMN A,D
	JSP E,QLGLE
	CAML A,D
	ADDI J,<1_<7-.RPCNT>>*LUNBLK
	SUBI J,<1_<6-.RPCNT>>*LUNBLK
]
	CAMGE J,Q
	ADDI J,LUNBLK
	CAMGE J,Q
	JRST 4,.
	MOVE D,UNFN1(J)
	TLC D,(SETZ)
	CAME A,D
	JRST QLGL1
	MOVE D,UNFN2(J)
	TLC D,(SETZ)
	CAMLE B,D
QLGL2:	ADDI J,LUNBLK
QLGL3:	TLC A,(SETZ)
	TLC B,(SETZ)
	POP P,E
	POP P,D
POPJ1:	AOS (P)
	POPJ P,

QLGL1:	CAML A,D
	JRST QLGL2
	JRST QLGL3

;CALL BY JSP E,QLGLE
QLGLE:	MOVE D,UNFN2(J)
	TLC D,(SETZ)
	CAMN B,D
	JRST QLGL3
	CAML B,D
	JRST 1(E)
	JRST 2(E)
QBTBLI:	440600,,	;IF GOING TO ILDB
	360600,,
	300600,,
	220600,,
	140600,,
	060600,,
	000600,,

; GCDIR - directory garbage collector - written especially
; for archiver - does not have all the features needed by
; the system's garbage collector.

; GCDIR the directory is already in core started at the location
; whose lable is ARCDIR.  It will also assume that can use a 2000 word
; block beginning at BLOCK3.  It clobbers ACs A,B,C,D,E,TT.

; ARG in A - instruction to execute with address of directory
; name area in A.  Instruction should skip if entry should be
; retained.  Files with first name of zero are always flushed.

GCDIR:	PUSH	P,A		; SAVE RETAIN INSRUCTION
	PUSHJ	P,HLOCK		; LOCK THE DIRECTORY
	MOVE	A,[ARCDIR,,BLOCK3]
	BLT	A,BLOCK3+UDDESC-1	; COPY THE DIRECTORY HEADER
	MOVE	A,(P)
	PUSHJ	P,GCDIR1	; CALL REAL GARBAGE COLLECTOR
	PUSHJ	P,INTOFF	; BLT BACK MUST BE DONE WITH INTS OFF
	MOVE	A,[BLOCK3,,ARCDIR]	; BLT BACK
	BLT	A,ARCDIR+1777
	PUSHJ	P,INTON		; RENABLE INTERRUPTS
	PUSHJ	P,HULOCK	; UNLOCK FILE
	POP	P,A
	POPJ	P,

; GCDIR1 CAN BE CALLED DIRECTLY WITH THE DIRECTORY ALREADY IN BLOCK3.
; GCDIR1 WILL LEAVE IT THERE.  GCDIR1 DOES NO FILE OR INTERRUPT LOCKING.

GCDIR1:	PUSH	P,A		; SAVE RETAIN INSTRUCTION
	MOVEI	E,1		; INDEX OF NEXT AVAILABLE DESC BYTE
	MOVE	D,[360600,,BLOCK3+UDDESC]	; BYTE POINTER TO NEXT DESC
	MOVEI	TT,BLOCK3+2000
	MOVEI	C,2000-LUNBLK
	CAMGE	C,ARCDIR+UDNAMP	; ANYTHING THERE?
	JRST	GCOVER		; DONE

GCLOOP:	SKIPN	ARCDIR(C)		; IS ENTRY NAME ZERO?
	JRST	GCNEXT		; YES - FLUSH IT
	HRRZI	A,ARCDIR(C)
	XCT	(P)		; KEEP IT?
	JRST	GCNEXT		; NO
	HRLS	A		; YES - COPY IT
	SUBI	TT,LUNBLK
	HRR	A,TT		; MAKE BLT POINTER
	BLT	A,4(TT)
	LDB	A,[UNDSCP+UNRNDM+ARCDIR(C)] ; GET INDEX OF DESC AREA
	DPB	E,[UNDSCP+UNRNDM(TT)] ; SET NEW INDEX
	IDIVI	A,UFDBPW	; GET WORD NUMBER
	ADDI	A,ARCDIR+UDDESC	; GET WORD ADDRESS
	HLL	A,QBTBLI(B)	; GET BYTE POINTER
GCDCPY:	ILDB	B,A		; TRANSFER THE DESCRIPTOR AREA
	IDPB	B,D
	AOS	E		; UPDATE INDEX OF NEXT ONE
	TRNE	B,40		; IS THIS START OF AN ADDRESS?
	JRST	GCDADR		; YES - JUMP
	JUMPN	B,GCDCPY	; GO UNTIL ZERO IS COPIED
	JRST	GCNEXT

GCDADR:	ILDB	B,A		; DISK ADR - COPY NEXT TWO BYTES
	IDPB	B,D		;    WITHOUT LOOKING
	ILDB	B,A
	IDPB	B,D
	ADDI	E,2
	JRST	GCDCPY

GCNEXT:	SUBI	C,LUNBLK	; GO NEXT ENTRY
	CAML	C,ARCDIR+UDNAMP	; DONE?
	JRST	GCLOOP		; NO
				; YES
GCOVER:	MOVEM	E,BLOCK3+UDESCP	; SAVE INDEX OF AVAILABLE BYTE
	SUBI	TT,BLOCK3
	MOVEM	TT,BLOCK3+UDNAMP	; SAVE INDEX OF	FIRST NAME AREA
	HRRI	E,1(D)		; ZERO IN BETWEEN SPACE
	HRLI	E,2(D)
	SETZM	1(D)
	HRRZ	A,BLOCK3+UDNAMP	; FROM END OF DESCRIPTORS TO NAME AREA
	ADDI	A,BLOCK3-1	; GET ADDRESS OF 1-ADR OF NAME AREA
	CAILE	A,(E)		; ANY ROOM TO ZERO?
	BLT	E,(A)		; YES - ZERO IT

IFE DIRTYP ARC,[
	.CALL	GETTAG
	SETZM	A
	MOVEM	A,ARCDIR+GCTAG
]
	POP	P,A		; RESTORE INSTRUCTION
	POPJ	P,		; DONE

GETTAG:	SETZ
	SIXBIT/RQDATE/
	SETZM A


; FLEN - GET FILE LENGTH - INPUT A/ POINTER TO NAME AREA
;	OUTPUT A/ FILE LENGTH

; DESCRIPTOR BYTE MEANINGS
	;0 => FREE  1-UDTKMX => TAKE NEXT N
	;UDTKMX+1 THRU UDWPH-1 => SKIP N-UDTKMX AND TAKE ONE
	;40 BIT SET => LOAD ADDRESS.  LOWER 5 BITS PLUS NEXT TWO CHARS (17 BITS IN ALL)

FLEN:	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,A
	MOVE	B,UNRNDM(A)
	TLNE	B,UNLINK
	JRST	FLENLK
	LDB	A,[UNDSCP UNRNDM(A)]
	IDIVI	A,6
	ADDI	A,UDDESC
	HRLS	A
	ADDI	A,DIRBUF
	MOVE	D,A
	HRLI	D,440600
	JUMPE	B,BLKLUP
	ILDB	0,D
	SOJG	B,.-1

BLKLUP:	ILDB	0,D
	JUMPE	0,LSTBYT
	CAIL	0,UDTKMX
	JRST	ADDTHEM
	ADD	B,0
	JRST	BLKLUP

ADDTHE:	CAIN	0,UDWPH
	JRST	BLKLUP
	AOS	B
	CAIG	0,UDWPH
	JRST	BLKLUP
	ILDB	0,D
	ILDB	0,D
	JRST	BLKLUP

LSTBYT:	POP	P,A
	JUMPE	B,FLENXT
	SOS	B
	IMULI	B,1024.
	LDB	A,[UNWRDC UNRNDM(A)]
	ADD	B,A
FLENXT:	MOVE	A,B
	POP	P,D
	POP	P,C
	POP	P,B
	POPJ	P,

FLENLK:	MOVE	B,[377777,,-1]
	POP	P,A
	JRST	FLENXT
