;HANDLE UNASSIGNED FLAGS BY TURNING THEM OFF

IRPS V,,[ FLEFLG ARRALL MARARR DISALL LIBRAR MATROT 
 OUTALL INPALL STMPIT TVCROT COMMND CNTRLX CNTRLA 
 STEREO MOVFLG GPHFLG SRTFLG FFTFLG COMMUN]
IFNDEF V,[V==0]
TERMIN

IRPS V,,[ UUOFLG INTFLG]
IFNDEF V,[V==1]
TERMIN

; FLEFLG	;FILE NAME INPUT
; ARRALL	;ARRAY ALLOCATOR
; MARARR	;MARGIN GENERATOR
; DISALL	;DISPLAY ROUTINES
; LIBRAR	;LIBRARY ROUTINES
; MATROT	;MATRIX AND VECTOR ROUTINES
; OUTALL	;FIXED AND FLOATING OUTPUT 
; INPALL	;FIXED AND FLOATING INPUT
; STMPIT	;NAME AND DATE STAMPING
; TVCROT	;TVC ROUTINES
; COMMND	;COMMAND INTERPRETOR
; COMMUN	;INTERPROGRAM COMMUNICATION
; CNTRLX	;FOR CONTROL CHARACTER HANDLING
; CNTRLA	;FOR CNTRLA INTERUPT HACK
; STEREO	;FOR STEREOSCOPIC PROJECTION
; MOVFLG	;FOR MOVIE MOTOR OUTPUT
; GPHFLG	;GRAPH GENERATOR
; FFTFLG	;FAST FOURIER TRANSFORM ROUTINE
; SRTFLG	;RADIX EXCHANGE SORT
; UUOFLG	;UUOS FOR PRINTING OUT STUFF
; INTFLG	;INTERUPT HANDLING

IFN GPHFLG+STEREO,[DISALL==1]

IFN DISALL+MARARR,[ARRALL==1]

IFN FFTFLG,[	LIBRAR==1
		ARRALL==1]

IFN COMMND+COMMUN,[	INPALL==1
		OUTALL==1]

IFN CNTRLX,[	INTFLG==1]

IFN OUTALL,[	UUOFLG==1]
;MACROS

DEFINE FIX AX,AY
	MULI AX,400
	TSC AX,AX
	ASH <AX+1>,AY-243(AX)
TERMIN

DEFINE ROUND AX
	FAD AX,[0.5]
	FIX AX,0
TERMIN

DEFINE FLOAT AX,AY
	TLC AX,232000+1000*AY
	FADR AX,AX
TERMIN

;OUTPUT TO CURRENTLY SELECTED OUTPUT DEVICES
DEFINE PRINT ARG
	TYPE [SIXBIT \ARG!!\]
TERMIN

;OUTPUT TO TTY ONLY
DEFINE STRIKE ARG
	TYP3 [SIXBIT \ARG!!\]
TERMIN

;OUTPUT AND THEN QUIT
DEFINE STOP ARG
	FATAL [SIXBIT \_ARG!!\]
TERMIN

DEFINE CONC A,B
	A!B!TERMIN
;PUSH AC'S ON PDL
DEFINE SAVE AC
REPEAT AC-A+1,PUSH P,A+.RPCNT
TERMIN


DEFINE GET LIST/
	TYP3 [SIXBIT \_!\]
IRP XA,,[LIST]
	TYP3 [SIXBIT \XA!=!\]
	PUSHJ P,RDNUM
	MOVEM A,XA
TERMIN
TERMIN

;SKIP IF ANSWER TO QUERY IS YES
DEFINE QUERY XA/
	TYP3 [SIXBIT \ XA! ? !\]
	PUSHJ P,SKPYES
TERMIN

;CLEAR ARRAY XA OF LENGTH (L)
DEFINE WIPE XA,L
	SETZM XA
	MOVE A,[XA,,XA+1]
	MOVE B,L
	BLT A,XA-1(B)
TERMIN

;COPY ARRAY XB TO XA OF LENGTH (L)
DEFINE COPY XA,XB,L
	MOVE A,[XB,,XA]
	MOVE B,L
	BLT A,XA-1(B)
TERMIN

;INCREMENT AC, IF < (LM) GO TO AD
DEFINE LOOP AC,LM,AD
	AOS AC
	CAMGE AC,LM
	JRST AD
TERMIN

;GO TO XL,XE,XG IF A IS < ,=,> ZERO
DEFINE IF XL,XE,XG
	JUMPL A,XL
	JUMPE A,XE
	JRST XG
TERMIN

;THIS PAGE IS NOT WITHIN THE SCOPE OF ANY IFN.


IFNDEF PDLL,[PDLL==200]

PDL:	BLOCK PDLL


ZR=0	;FLAG AC

A=1	
B=2	
C=3	
D=4	
E=5	
F=6	
G=7	

T=10	
U=11	
V=12	
W=13	
X=14	
Y=15	
Z=16	

P=17	;PUSH DOWN POINTER

FSP:	FS		;MUST BE LAST PLACE PLUS ONE IN PROG
CORTOP:	CORSIZ*2000	;MUST BE SIZE NEEDED IN 2000 BLOCKS
CRSZ:	CORSIZ		;NUMBER OF PAGES PROGRAM HAS
CRLM:	CORSIZ		;BLOCKS ACTUALLY RETAINED

;  SEE IF HAVE TO INSERT OTHER SUPPRT ROUTINES TOO

IFN ARRALL+MOVFLG,[

.INSRT ROUT >

]
IFN LIBRAR,[

;'LIBRARY ROUTINES' - MAY BE REENTRANT BY NOW AND 'SAFE' (I.E. NO ARITH OVERFL FOR VALID DATA)

COSD:	FADR A,[90.0]
SIND:	FDV A,[57.295779]	;180.0/PI
	JRST .+2	;SKIPA
COS:	FADR A,[1.57079632]	;PI/2
SIN:	PUSH P,B
	PUSH P,C
	MOVE C,A	;SAVE A
	MOVMS A
	CAMG A,[0.019]
	JRST SNSN3	;SMALL ENOUGH, SO SIN(X)=X
	CAML A,[1.0^8 ]
	STOP _ARGUMENT TOO LARGE-COS-SIN
	FDV A,[1.57079632]	;PI/2
	CAMG A,[1.0]
	JRST SNSN2	;SMALL ENOUGH NOT TO REQUIRE ARGUMENT REDUCTION
	MULI A,400	;FIX IT
	LSH B,-202(A)
	MOVEI A,200
	ROT B,3
	LSHC A,33
	FAD A,[0]	;FLOAT IT
	JUMPE B,SNSN2
	TLCE B,1000
	FSB A,[1.0]	;01,11
	TLCE B,3000
	TLNN B,3000
	MOVNS A		;01,10
SNSN2:	SKIPGE C
	MOVNS A
	MOVEM A,C
	FMPR A,A
	MOVE B,[0.00015148419]	;0
	FMP B,A
	FAD B,[-0.00467376557]	;-0.004362476
	FMP B,A
	FAD B,[0.07968967928]	;0.079487663
	FMP B,A
	FAD B,[-0.64596371106]	;-0.645920978
	FMP A,B
	FAD A,[1.57079632]	;PI/2
	FMPR A,C
SINX:	POP P,C
	POP P,B
	POPJ P,
	
SNSN3:	MOVE A,C
	JRST SINX


;FLOATING POINT SQUARE ROOT FUNCTION

SQRT:	SKIPGE A
	STOP _NEGATIVE SQRT
	SKIPN A
	POPJ P,
	PUSH P,B
	PUSH P,C
	ASHC A,-33
	SUBI A,201
	ROT A,-1
	HRRZ C,A
	PUSH P,C	;SQ1
	LSH A,-43
	ASH B,-10
	FSC B,177(A)
	MOVE C,B
	FMP B,SQRT1(A)
	FAD B,SQRT2(A)	;LINEAR APPROXIMATION
	MOVE A,C	;THEN TWO ITERATIONS OF NEWTON-RAPHSON
	FDV A,B
	FAD B,A
	FSC B,-1
	MOVE A,C
	FDV A,B
	FADR A,B
	POP P,B		;SQ1
	FSC A,(B)
	POP P,C
	POP P,B
	POPJ P,

SQRT1:	0.8125
	0.578125
SQRT2:	0.302734
	0.421875

ATAN:	PUSH P,B
	PUSH P,C
	MOVM B,A
	CAMG B,[0.4^-8 ]
	JRST TANDON	;SMALL ENOUGH SO THAT ATAN(X)=X
	PUSH P,A
	CAML B,[7.0^7 ]
	JRST ATANS4	;LARGE ENOUGH SO ATAN(X)=PI/2
	MOVN C,[1.0]
	CAMLE B,[1.0]	;1.0
	FDVM C,B
	PUSH P,B
	FMPR B,B
	MOVE C,[1.44863154]
	FADR C,B
	MOVE A,[-0.264768620]
	FDVM A,C
	FADR C,B
	FADR C,[3.31633543]
	MOVE A,[-7.10676005]
	FDVM A,C
	FADR C,B
	FADR C,[6.76213924]
	MOVE A,[3.70925626]
	FDVR A,C
	FADR A,[0.174655439]
	POP P,B
	FMPR A,B
	JUMPG B,ATANS5
	FADR A,[1.57079632]	;PI/2
	JRST .+2	;SKIPA
ATANS4:	MOVE A,[1.57079632]
ATANS5:	POP P,B
	SKIPGE B
	MOVNS A
TANDON:	POP P,C
	POP P,B
	POPJ P,

LOG:	SKIPG A
	STOP _NON-POSITIVE LOG
	PUSH P,B
	PUSH P,C
	PUSH P,D
	LDB D,[331100,,A]	;GRAB EXPONENT
	SUBI D,201
	TLZ A,777000
	TLO A,201000
	MOVE B,A
	FSBR A,[1.41421356]
	FADR B,[1.41421356]
	FDVB A,B
	FMPR B,B
	MOVE C,[0.434259751]
	FMPR C,B
	FADR C,[0.576584342]
	FMPR C,B
	FADR C,[0.961800762]
	FMPR C,B
	FADR C,[2.88539007]
	FMPR C,A
	FADR C,[0.5]
	MOVE A,D
	FLOAT A
	FADR A,C
	FMPR A,[0.69314718]	;LOG E OF 2.0
	POP P,D
	POP P,C
	POP P,B
	POPJ P,

IF1 EXPUNGE EXP

EXP:	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	SETZM B
	PUSH P,A
	MOVMS A
	FMPR A,[0.43429448]
	MOVE D,[1.0]
	CAMG A,D
	JRST RATEX
	MULI A,400
	ASHC B,-243(A)
	CAILE B,43
	STOP _ARGUMENT TOO LARGE-EXP
	CAILE B,7
	JRST EXPR2
EXPR1:	FMPR D,FLOAP1(B)
	LDB A,[103300,,C]
	SKIPE A
	TLO A,177000
	FADR A,A
RATEX:	MOVEI B,7
	SETZM C
RATEY:	FADR C,COEF2-1(B)
	FMPR C,A
	SOJN B,RATEY

	FADR C,[1.0]
	FMPR C,C
	FMPR D,C
	MOVE A,[1.0]
	POP P,B
	SKIPL B
	SKIPN A,D
	FDVR A,D
	POP P,E
	POP P,D
	POP P,C
	POP P,B
	POPJ P,

EXPR2:	LDB E,[030300,,B]
	ANDI B,7
	MOVE D,FLOAP1(E)
	FMPR D,D	;TO THE 8'TH POWER
	FMPR D,D
	FMPR D,D
	JRST EXPR1

COEF2:	1.15129278
	0.662730884
	0.254393575
	0.0729517367
	0.0174211199
	2.55491796^-3
	9.3264267^-4

FLOAP1:	1.0?1.0^1 ?1.0^2 ?1.0^3 ?1.0^4 ?1.0^5 ?1.0^6 ?1.0^7


INTEG:	PUSH P,B	;INTEGER PART
	FIX A
	FLOAT B
	MOVE A,B
	POP P,B
	POPJ P,

FRACT:	PUSH P,B	;FRACTIONAL PART
	PUSH P,A
	FIX A
	FLOAT B
	POP P,A
	FSBR A,B
	POP P,B
	POPJ P,

MOD:	PUSH P,A	;FLOATING MODULUS
	FDVR A,B
	PUSH P,B
	FIX A
	FLOAT B
	FMPR B,(P)	;SAVED B
	MOVE A,-1(P)	;SAVED A
	FSBR A,B
	POP P,B
	SUB P,[1,,1]
	POPJ P,

STARTX:	171622221402
IMPTX:	3125.
PRIMEL:	377777,,777741

RANDOM:	PUSH P,B	;UNIFORM 0.0 - 1.0
	MOVE A,STARTX
	MUL A,IMPTX
	DIV A,PRIMEL
	MOVEM B,STARTX
	MOVE A,B
	LSH A,-8.
	FLOAT A,-33
	POP P,B
	POPJ P,

GCD:	PUSH P,C	;FIX ARGS IN A,B
	CAMGE A,B
	EXCH A,B
	JRST GCDNP

GCDLP:	MOVE C,B
	IDIV A,C
	MOVE A,C
GCDNP:	JUMPN B,GCDLP
	POP P,C
	POPJ P,

EXPLOG:	JUMPG A,POSEXP	;A^B
	JUMPE A,ZREXP
	PUSH P,A
	MOVE A,B
	PUSHJ P,FRACT
	SKIPE A
	STOP _NEGATIVE NUMBER TO NON-INTEGER POWER
	MOVM A,(P)
	PUSHJ P,POSEXP
	MOVEM A,(P)
	MOVM A,B
	FIX A
	TRNE B,1
	MOVNS (P)	;ODD POWER
	JRST POPAJ

POSEXP:	PUSHJ P,LOG
	FMPR A,B
	JRST EXP

ZREXP:	SKIPG B
	STOP _ZERO TO NON-POSITIVE POWER
	POPJ P,

CLAMP:	CAML B,C
	MOVE B,C
	CAMG B,A
	MOVE B,A
	MOVE A,B
	POPJ P,

;END OF 'LIBRARY' ROUTINES
]

;THIS PAGE NOT WITHIN THE SCOPE OF ANY IFN'S

ABS:	MOVMS A
	POPJ P,

MAX:	CAMG A,B
	MOVE A,B
	POPJ P,

MIN:	CAML A,B
	MOVE A,B
	POPJ P,

FFIX:	PUSH P,B
	FIX A
	MOVE A,B
	POP P,B
	POPJ P,

FFLOAT:	FLOAT A
	POPJ P,

HFIX:	PUSH P,B
	FIX A,18.
	MOVE A,B
	POP P,B
	POPJ P,

HFLOAT:	FLOAT A,-18.
	POPJ P,

IFN MATROT,[
		;MATRIX AND VECTOR ROUTINES

MATVCT:	;MULTIPLY MATRIX BY VECTOR
;ANSWER,MATRIX,VECTOR,N,M  N-ROWS
	CAMN A,C
	STOP _INLINE-MATVCT
	PUSH P,A
	MOVNS E
	HRL C,E
	PUSH P,C
CLLOSP:	MOVE C,(P)
	SETZM (A)
RWLOSP:	MOVE E,(B)
	FMPR E,(C)
	FADRM E,(A)
	AOS B
	AOBJN C,RWLOSP
	AOS A
	SOJG D,CLLOSP
	SUB P,[1,,1]
	JRST POPAJ

VCTSCL:	;MULTIPLY VECTOR OR MATRIX BY SCALAR
;ANSWER,VECTOR,SCALAR,N
	PUSH P,A
	MOVNS D
	HRL B,D
SCLMPT:	MOVE D,(B)
	FMPR D,C
	MOVEM D,(A)
	AOS A
	AOBJN B,SCLMPT
	JRST POPAJ

VCTADD:	;ADD TWO VECTORS OR MATRICES
;ANSWER,VECTOR1, VECTOR2,N
	PUSH P,A
	MOVNS D
	HRL C,D
VCTAPT:	MOVE D,(B)
	FADR D,(C)
	MOVEM D,(A)
	AOS A
	AOS B
	AOBJN C,VCTAPT
	JRST POPAJ

VCTSUB:	;SUB TWO VECTORS OR MATRICES
;ANSWER,VECTOR1, VECTOR2,N
	PUSH P,A
	MOVNS D
	HRL C,D
VCTSPT:	MOVE D,(B)
	FSBR D,(C)
	MOVEM D,(A)
	AOS A
	AOS B
	AOBJN C,VCTSPT
	JRST POPAJ

VCTCPY:	;COPY A VECTOR OR MATRIX
;NEW,OLD,N
	PUSH P,A
	ADD C,A
	HRL A,B
	BLT A,-1(C)
	JRST POPAJ

DOTPRT:	;DOTPRODUCT OF TWO VECTORS, ANSWER IN A
;VECTOR1,VECTOR2,N
	MOVNS C
	HRL B,C	
	SETZM C
	PUSH P,D
DOTELT:	MOVE D,(A)
	FMPR D,(B)
	FADR C,D
	AOS A
	AOBJN B,DOTELT
	MOVE A,C
	POP P,D
	POPJ P,


SUMVEC:	;SUM FROM B TO C-1 OF ARRAY A
	CAMLE B,C
	EXCH B,C
	ADD A,B
	SUB B,C
	MOVNS B
VCTTRC:	;SUM OF ALL TERMS IN A VECTOR, ANSWER IN A ;VECTOR,N
	JUMPE B,VCTLP1
	MOVNS B
	HRL A,B
	SETZM B
VCTLPZ:	FADR B,(A)
	AOBJN A,VCTLPZ
VCTLP1:	MOVE A,B
	POPJ P,

TRNSPS:	;TRANSPOSE A MATRIX
;ANSWER,MATRIX,N,M
	PUSH P,E
	PUSH P,C
	PUSH P,A
	CAMN A,B
	JRST TRANST	;INLINE TRANSPOSE
	MOVNS D
CLLMA:	HRL B,D
	MOVE A,(P)
RWLMA:	MOVE E,(B)
	MOVEM E,(A)
	ADD A,-1(P)
	AOBJN B,RWLMA
	AOS (P)
	SOJG C,CLLMA

CMTRND:	POP P,A
	SUB P,[1,,1]
	POP P,E
	POPJ P,

TRANST:	CAME C,D
	STOP _INLINE NONSQUARE-TRNSPS
	MOVNS D
CLAMA:	HRL B,D
	MOVE A,(P)
RWAMA:	HRR G,B
	CAML A,G
	JRST NDRWLP
	MOVE E,(A)
	EXCH E,(B)
	MOVEM E,(A)
NDRWLP:	ADD A,-1(P)
	AOBJN B,RWAMA
	AOS (P)
	SOJG C,CLAMA
	JRST CMTRND

MATMUL:	;MATRIX MULTIPLY
;ANSWER,MATRIX1,MATRIX2,N,M,L
	CAME A,B
	CAMN A,C
	STOP _INLINE-MATMUL
	PUSH P,A
	PUSH P,G
	PUSH P,T

	PUSH P,B
	PUSH P,C
	MOVE G,C
	MOVNS E
	MOVNS F
IRWIST:	MOVE C,G
	MOVEM C,(P)
	HRL A,F
ARWIST:	MOVE C,(P)
	MOVE B,-1(P)
	SETZM (A)
	HRL B,Eî
ADRWM:	MOVE T,(B)
	FMPR T,(C)
	FADRM T,(A)
	SUB C,F
	AOBJN B,ADRWM
	AOS (P)
	AOBJN A,ARWIST
	MOVEM B,-1(P)
	SOJG D,IRWIST
	SUB P,[2,,2]
	POP P,T
	POP P,G
	JRST POPAJ
;	VECTOR HANDLING

CRSPRT:	;CROSS PRODUCT OF TWO 3-TUPLES
	PUSH P,E
	PUSH P,F
	PUSH P,G

	MOVE E,A
	MOVE F,B
	MOVE G,C

.F ZR(E)=A(F)*B(G)-B(F)*A(G)
.F A(E)=B(F)*ZR(G)-ZR(F)*B(G)
.F B(E)=ZR(F)*A(G)-A(F)*ZR(G)

	POP P,G
	POP P,F
	MOVE A,E
	POP P,E
	POPJ P,

IFN LIBRAR,[
UNIFY:	PUSH P,A	;UNIFY A VECTOR, NEW,OLD,N
	PUSH P,B
	PUSH P,C
	MOVE A,B
	PUSHJ P,DOTPRT
	PUSHJ P,SQRT

	MOVE C,[1.0]
	FDVR C,A
	POP P,D
	POP P,B
	POP P,A
	JRST VCTSCL

]

VCELPR:	;ELEMENT BY ELEMENT VECTOR PRODUCT
;ANSWER,VECTOR1,VECTOR2,N
	PUSH P,A
	PUSH P,E
	MOVNS D
	HRL C,D
VCARSH:	MOVE E,(B)
	FMPR E,(C)
	MOVEM E,(A)
	AOS A
	AOS B
	AOBJN C,VCARSH
	POP P,E
	JRST POPAJ


AM:	BLOCK 9	;INTERMEDIATE RESULTS TO ALLOW INLINE MAT3IN

MAT3IN:	;INVERSE OF 3 BY 3 MATRIX
;ANSWER,MATRIX
.F QQA=
	MOVE F,B
.F AM(0)=ZR(F+4)*ZR(F+8)-ZR(F+5)*ZR(F+7)
.F AM(3)=ZR(F+5)*ZR(F+6)-ZR(F+3)*ZR(F+8)
.F AM(6)=ZR(F+3)*ZR(F+7)-ZR(F+4)*ZR(F+6)
.F DELT'=ZR(F+0)*AM(0)+ZR(F+1)*AM(3)+ZR(F+2)*AM(6)
	SKIPN DELT
	STOP _ZERO DETERMINANT-MAT3IN
.F AM(0)=AM(0)/DELT
.F AM(3)=AM(3)/DELT
.F AM(6)=AM(6)/DELT
.F AM(1)=(ZR(F+2)*ZR(F+7)-ZR(F+1)*ZR(F+8))/DELT
.F AM(4)=(ZR(F+0)*ZR(F+8)-ZR(F+2)*ZR(F+6))/DELT
.F AM(7)=(ZR(F+1)*ZR(F+6)-ZR(F+0)*ZR(F+7))/DELT
.F AM(2)=(ZR(F+1)*ZR(F+5)-ZR(F+2)*ZR(F+4))/DELT
.F AM(5)=(ZR(F+2)*ZR(F+3)-ZR(F+0)*ZR(F+5))/DELT
.F AM(8)=(ZR(F+0)*ZR(F+4)-ZR(F+1)*ZR(F+3))/DELT

.I VCTCPY<QQA,#AM,9>
	POPJ P,

MATPNT:	;PRINT A MATRIX
;ADDRESS,N,M
	PUSH P,A
	MOVNS C
	PUSH P,D
	PRINT _
PNOTLP:	PRINT _
	HRL A,C
PNINLP:	MOVE D,(A)
	PRINT %4E3
	AOBJN A,PNINLP
	SOJG B,PNOTLP
	PRINT _
	POP P,D
	JRST POPAJ

QQA:	0
QQB:	0
QQC:	0

MATINV:	;MATRIX INVERSE - KEEPS OLD AND NEW MATRICES IN SAME PLACE  
;ANSWER,MATRIX,N
	CAIN C,3
	JRST MAT3IN
.F QQA=,,QQC=-QQB=
	CAME A,B
	PUSHJ P,COPMAT	;COPY MATRIX ACROSS
.F DELT=1.0
	SETZM E
	MOVE F,QQA	;ADDRESS
LOPD1:	MOVE G,F
	ADD G,E		;DIAGONAL ELEMENT
	SKIPN (G)
	STOP _ZERO TERM-MATINV
	MOVE B,[1.0]
	MOVE A,B
	FDVR B,(G)	;COM=1.0/A(I,I)
	MOVEM A,(G)	;A(I,I)=1.0

;	FMPRM B,DELT	;UPDATE DETERMINANT - CAUSES OVERFLOWS OFTEN

	MOVE G,F
	HRL G,QQC
LOPD2:	FMPRM B,(G)	;A(I,J)=A(I,J)*COM
	AOBJN G,LOPD2

	SETZM U
	MOVE V,QQA	;ADDRESS
LOPD3:	CAMN E,U
	JRST NDLP3
	MOVE G,F
	MOVE W,V
	ADD W,E
	MOVN B,(W)	;COP=-A(I,L)
	SETZM (W)	;A(I,L)=COP
	MOVE W,V
	HRL W,QQC
LOPD5:	MOVE A,(G)
	FMPR A,B
	FADRM A,(W)	;A(I,J)=A(I,J)+A(L,J)*COP
	AOS G
	AOBJN W,LOPD5

NDLP3:	ADD V,QQB
	LOOP U,QQB,LOPD3

	ADD F,QQB
	LOOP E,QQB,LOPD1

	SKIPN DELT
	STOP _ZERO DELT-MATINV
.F QQA,DELT=/DELT
	POPJ P,

COPMAT:	HRL B,B	;COPY THE MATRIX ACROSS
	HRR B,A
	IMUL C,C
	ADD A,C
	BLT B,-1(A)
	POPJ P,

REVRS:	;REVERSE A MATRIX
;ANSWER,MATRIX,N,M
	PUSH P,A
	IMUL C,D
	CAMN A,B
	JRST RASBS
	ADD A,C
	SOS A
	MOVNS C
	HRL B,C
REVLOP:	MOVE C,(B)
	MOVEM C,(A)
	SOS A
	AOBJN B,REVLOP
	JRST POPAJ

RASBS:	ADD A,C	;INLINE REVERSE
	SOS A
	LSH C,-1
	MOVNS C
	HRL B,C
RAVLOP:	MOVE C,(B)
	EXCH C,(A)
	MOVEM C,(B)
	SOS A
	AOBJN B,RAVLOP
	JRST POPAJ

MARGIN:	;SET UP MARGIN ARRAY
;MARGIN,ARRAY,N,M,AC
	PUSH P,A
	MOVNS D
	HRL B,E
	HRL A,D
MRGPLC:	MOVEM B,(A)
	ADD B,C
	AOBJN A,MRGPLC
	JRST POPAJ
PEEL:	PUSH P,A
	PUSH P,V
	MOVE V,A	;PEELS LAST COLUMN OFF ARRAY
	HRL A,B	;NEWARRAY, OLDARRAY, COLUMN, N, M	N-NUMBER OF ROWS
	MOVE B,A
	MOVNS D
	HRL C,D
	ADD V,E	;LENGTH OF ROW
	SUBI V,2
PELLP:	MOVE A,B
	BLT A,(V)
	ADD B,E
	SOS B	;NEW ROW PLACE
	ADD V,E
	SOS V
	MOVSS B	;LOOK AT LEFT FOR A CHANGE
	ADD B,E
	MOVE D,-1(B)
	MOVEM D,(C)
	MOVSS B
	AOBJN C,PELLP
	POP P,V
	JRST POPAJ

CLOTHE:	;OPPOSITE OF PEEL - ADDS ONE COLUMN
;ANSWER,ARRAY,COLUMN,N,M
	CAMN A,B
	STOP CLOTHE INLINE
	PUSH P,A
	MOVNS D
	HRL C,D
	HRL A,B
	HRRZ B,A
	SOS B
CLOTLP:	ADD B,E
	MOVE D,A
	BLT D,(B)
	MOVE D,(C)
	AOS B
	MOVEM D,(B)
	ADD A,E
	AOS A
	MOVSS A
	ADD A,E
	MOVSS A
	AOBJN C,CLOTLP
	JRST POPAJ


ROTVCT:	;ROTATE A VECTOR
;VECTOR,WORK,POINTER OF ITEM TO COME TO ZERO POSITION,N
	SKIPN C
	POPJ P,	;NOTHING TO DO
	PUSH P,A
	PUSH P,E
	PUSH P,F
	HRL E,A
	HRR E,B
	MOVE F,B
	ADD F,C
	SOS F
	BLT E,(F)
	HRR E,A
	HRL E,A
	ADD E,C
	MOVSS E	;VECTOR,,VECTOR+PNT
	MOVE F,A
	ADD F,D
	SUB F,C	;VECTOR+SZE-PNT
	BLT E,(F)
	HRR E,A
	HRL E,B
	ADD E,D
	SUB E,C	;WORK,,VECTOR+SZE-PNT
	MOVE F,A
	ADD F,D
	SOS F	;VECTOR+SZE-1
	BLT E,(F)
	POP P,F
	POP P,E
	JRST POPAJ

]
OLD:	0
BATCON:	0

CFL:	3	;DEFAULT IS CFL=3
DCL:	1	;DEFAULT IS DCL=1

IFN TVCROT,[

TVCOP:
.I BATCON=CFL+4*DCL+340*OLD	;OPEN TVC
	MOVE B,BATCON
	DPB B,[251700,,TVCOV]
	DPB B,[251700,,TVCIV]
	.OPEN TVCI,TVCOV
TVCOL1:	STOP _BAT NOT AVAILABLE-TVCOP
	.OPEN TVCO,TVCIV
	JRST TVCOL1
	POPJ P,

TVCCLS:	.CLOSE TVCI,	;CLOSE TVC
	.CLOSE TVCO,
	POPJ P,

TVCOV:	6,,(SIXBIT /TVC/)
	0
	0

TVCIV:	7,,(SIXBIT /TVC/)
	0
	0

TVCBUF==300	;SYSTEMS TVC BUFFER SIZE

QAT:	0
QBT:	0
QCT:	0

TVCLRG:	SKIPN A		;READ ANY BUFFER LENGTH OF TVC DATA
	STOP _TVCLRG HAS BUM ADDRESS
.I QAT=,QBT=,QCT=
TVCREC:	CAILE C,TVCBUF
	MOVEI C,TVCBUF
	MOVNS C
	HRL B,C
	.IOT TVCO,B
	HRL A,C
	.IOT TVCI,A
	MOVE A,QAT
	MOVE A,(A)
	CAMGE A,[4096.0]
	CAMG A,[0.5]
	JRST TVCBIT
.I QAT+#TVCBUF,QBT+#TVCBUF,QCT-#TVCBUF
	JUMPG C,TVCLRG
	POPJ P,

TVCBIT:	STRIKE _TVC BITES-TVCBIT
.F QAT,QBT,QCT
	JRST TVCREC


VIDOT:	PUSH P,A	;FIRST ADR - READ AND INVERT VIDISECTOR
	PUSH P,B	;COUNT TO READIN
	MOVE C,B
	MOVE B,A
	PUSHJ P,TVCLRG
	POP P,B
	POP P,A

	SKIPN A
	STOP _VIDOT BITES
	MOVE C,[1024.0]

VIDAL:	MOVNS B	;ARRAY,SIZE,PIVOT
	HRL A,B
	FDVRM C,(A)
	AOBJN A,.-1
	POPJ P,


SCNTVC:	;XORG,YORG,XWDTH,YWDTH,XN,YN,ARRAY
	HRRM G,AOBARR
	HRLM E,RESOL
	HRRM F,RESOL
	IMUL E,F
	MOVNS E
	HRLM E,AOBARR
	HRLZM C,MATR1
	SETZM MATR2
	SETZM MATR3
	HRLZM D,MATR4
	SETZM MATP1
	SETZM MATP2
	HRLZM A,MATC1
	HRLZM B,MATC2
	.VSCAN PTBLE
	POPJ P,
]

PTBLE:	0	;CONO BITS GO HERE (OLD*340+DCL*4+CFL)
AOBARR:	0	;AOBJN POINTER TO ARRAY
RESOL:	0	;XN,,YN
MATR1:	0
MATR2:	0
MATC1:	0	;XORG
MATR3:	0
MATR4:	0
MATC2:	0	;YORG
MATP1:	0
MATP2:	0
;THIS PAGE ISNOT WITHIN THE SCOPE OF ANY IFN'S

A0==1	;AC NAMES FOR ALGEBRAIC STATMENTS
A1==2
A2==3
A3==4
A4==5
A5==6
A6==7
A7==10
A8==11
A9==12

;IO CHANNELS

TYIC==1	;TTY IN
TYOC==2	;TTY OUT
LPTC==3	;LPT OR TPL OUT
TVCI==4	;TVC IN
TVCO==5	;TVC OUT
DSIC==6	;DISK IN
DSOC==7	;DISK OUT
IMPC==10;A/D MULTIPLEXOR IN
OMPC==11;D/A MULTIPLEXOR OUT
ERRC==12;ERROR DEVICE
IPLC==13;PLOTTER DEVICE
CLOC==14;CORE LINK OUTPUT
CLUC==15;CORE LINK INPUT

;INTERRUPT BITS

TTYINT==1	;CHARACTER TYPED
AROVFL==10	;ARITHMETIC OVERFLOW
SLWINT==10000	;1/2 SECOND CLOCK
MPVINT==20000	;MEMORY PROTECTION VIOLATION
PDOINT==200000	;PDL OVERFLOW
CLINT==400000	;CORE LINK INTERRUPT


;INTERUPT ROUTINES AND UUO HANDLER FOLLOW

TTOFLG==1	;TTY OUT ON
LPTFLG==2	;LPT OR TPL OUT ON
DISFLG==4	;DISPLAY ON
DISCHR==10	;DISPLAY IN PRINT MODE
DSIFLG==20	;DISK IN ON
DSOFLG==40	;DISK OUT ON
CLOFLG==100	;CORE LINK OUT
CLUFLG==200	;CORE LINK IN


POPDJ:	POP P,D
POPCJ:	POP P,C
POPBJ:	POP P,B
POPAJ:	POP P,A
POPJP:	POPJ P,
CPOPJ==POPJP

IFN UUOFLG+INTFLG,[
QUIT:	0		;JSR'ED TO BY STOP AND CNTRL G
	.RESET TYOC,
GOGO:	MOVEM P,QUITP
	MOVE P,[-PDLL,,PDL-1]
	.SUSET [.SMASK,,[PDOINT+TTYINT+AROVFL]]	;FLUSH NON-STANDARD ENABLED INTERUPTS
	SKIPG A,QITADR
	JRST NOENQT
	SETZM QITADR
	PUSHJ P,(A)	;CALL HIS CLEAN-UP ROUTINE
NOENQT:	SKIPE RSTART	;DOES THERE EXCIST A RESTART ADDRESS
	.DISMIS RSTART
	MOVE P,QUITP
	.VALUE
	.DISMIS NTRUPT+1

INIT:	0		;INITIALISE PDL ETC. , TO BE JSR'ED TO AT BEGINNING
	MOVE P,[-PDLL,,PDL-1]	;SET PDL UP
	MOVE A,[JSR UUOS]
	MOVEM A,41
	MOVE A,[JSR NTRUPT]
	MOVEM A,42
IFN DISALL,[
	PUSHJ P,FLSNDS	;INITIALLY SET DSPARY'S TO -1
]
	.CORE @CRSZ
	.VALUE			;NO CORE
	.SUSET [.SMASK,,[PDOINT+TTYINT+AROVFL]]	;INTERUPTS ENABLED
	JFCL 17,.+1		;CLEAR FLAGS
	.SUSET [.SPICL,,[-1]]	;ENABLE INTERUPTS
	.OPEN TYOC,TTOOP	;OPEN TTY OUT
	.VALUE
	.OPEN TYIC,TTIOP	;OPEN TTY IN
	.VALUE
	MOVEI ZR,TTOFLG+DISFLG		;OUTPUT TO TTY ONLY INITIALLY
	JRST @INIT
]

;IO DEVICE OPENS

;   INPUT:  ASCII:   UNIT:   
;   INPUT:  ASCII:  BLOCK:  "
;   INPUT:  IMAGE:   UNIT:  $
;   INPUT:  IMAGE:  BLOCK:  &
;  OUTPUT:  ASCII:   UNIT:  !
;  OUTPUT:  ASCII:  BLOCK:  #
;  OUTPUT:  IMAGE:   UNIT:  %
;  OUTPUT:  IMAGE:  BLOCK:  '


TTOOP:	SIXBIT /  !TTYTTY   OUT/
LPTOP:	SIXBIT /  !LPTLPT   OUT/
TPLOP:	SIXBIT /  !TPLTPL   OUT/
TTIOP:	SIXBIT /  (TTYTTY   IN/

TYPED:	0	;SET ON TTY INTERUPT
QUITP:	0	;PDL POINTER SAVED AFTER QUIT
TTYONL:	TTOFLG	;USED TO DISABLE ALL BUT TTY ON GET AND STRIKE
RSTART:	0	;PLACE TO PUT RESTART ADDRESS
QITADR:	0	;CALLED ON QUIT
INTADR:	0	;ROUTINE JUMPED TO FOR STRANGE INTERUPTS

IFNDEF DISLL,[DISLL==10]

DISLIS:
REPEAT DISLL-1, .+1
	0

INTACS:	0	;SAVED ACS IN INTERUPT

IFN UUOFLG,[

FATAL=(1000)	
TYP3=(2000)
TYPE=(4000)	

UUOS:	0		;RETURN ADDRESS AND FLAGS
	PUSH P,UUOS
	PUSH P,A	;A MUST BE LAST PUSHED FOR STRING
	HLRZ A,40
	ANDI A,777000	;WHICH UUO WAS IT
	CAIN A,(TYPE)
	JRST TYPEU
	CAIN A,(FATAL)
	JRST QUITU
	CAIN A,(TYP3)
	JRST STRK
ILLUUO:	POP P,A
	POP P,UUOS
	.VALUE		;ILLEGAL UUO AND ARG ADDRESS IN 40
	MOVE A,UUOS
	MOVEM A,NTRUPT+1
	JSR QUIT

NDUUO:	POP P,A		;RETURN FROM UU0
	POP P,UUOS
	JRST 2,@UUOS


STRK:	HRRZ A,40	;STRIKE - LIKE PRINT EXCEPT ALWAYS GOES TO TTY
	EXCH ZR,TTYONL
	PUSHJ P,STRING
	EXCH ZR,TTYONL
	JRST NDUUO

TYPEU:	TRNN ZR,TTOFLG+LPTFLG+DISCHR+DSOFLG
	JRST NDUUO	;NO OUTPUT FLAGS ON
	HRRZ A,40	;PRINT GET ARG ADDRESS
	PUSHJ P,STRING
	JRST NDUUO
QUITU:	MOVE A,UUOS	;COPY RETURN ADDRESS
	MOVEM A,NTRUPT+1
	HRRZ A,40	;STOP
	EXCH ZR,TTYONL
	PUSHJ P,STRING
	EXCH ZR,TTYONL
	POP P,A
	POP P,UUOS
	JRST GOGO
]

IFN INTFLG,[

NTRUPT:	0		;INTERUPT BITS
	0		;RETURN ADDRESS
	MOVEM A,INTACS	;SAVE A
	MOVE A,NTRUPT	;SEE WHAT KIND OF AN INTERUPT
	TRNE A,TTYINT	;IF KEY HIT,
	JRST TTYHND
	TRNE A,AROVFL
	JRST ARRFLW
	TRNE A,PDOINT
	JRST PDLOV
	TRNE A,CLINT
	JRST CORINT
	SKIPE INTADR
	JRST INTADR@
	PUSH P,OBASE
	MOVEI B,10
	MOVEM B,OBASE
	PRINT  _#1 STRANGE INTERUPT
	POP P,OBASE
	STOP _

CORINT:	SKIPN CRLNKI	;IS THERE SOMEWHERE TO GO?
	STOP _NO PLACE TO GO - CORINT
	JRST @CRLNKI	;GO THERE
CRLNKI:	0

PDLOV:	MOVE A,INTACS
	.VALUE		;PDL OVERFLOW
	MOVE P,[-PDLL,,PDL-1]
	SKIPE RSTART
	.DISMIS RSTART
	.VALUE

ARRFLW:	MOVE A,INTACS
	.VALUE		;ARITHMETIC OVERFLOW
	.DISMIS NTRUPT+1

TTYHND:	MOVE A,INTACS
	.ITYI A,
	.DISMIS NTRUPT+1
	CAIN A,15	;CAR RET
	JRST ECHCR
	CAIGE A,40
	JRST CNTCHR	;CONTROL CHARACTER
	MOVEM A,TYPED	;TAKE NOTE CHARACTER HAS BEEN TYPED
	JRST DANT

DANT:	MOVE A,INTACS
	.DISMIS NTRUPT+1
]

ECHCR:	.IOT TYOC,A
	MOVEI A,12	;LINE FEED
	.IOT TYOC,A
	JRST DANT
CNTCHR:

IFN CNTRLX,[
	CAIE A,^P
	CAIN A,^G
	JRST CNTRLG
	CAIN A,^A
	JRST CATRLA
	CAIN A,^U
	JRST CNTRLU
	CAIN A,^B
	PUSHJ P,CNTRLB
	CAIN A,^T
	PUSHJ P,CNTRLT
	CAIN A,^E
	PUSHJ P,CLOLPT
	CAIN A,^V
	TRO ZR,TTOFLG
	CAIN A,^W
	TRZ ZR,TTOFLG
	CAIN A,^F
	PUSHJ P,CNTRLF
	CAIN A,^Y
	PUSHJ P,CNTRLY
	CAIN A,^R
	PUSHJ P,CNTRLR
	CAIN A,^S
	PUSHJ P,CNTRLS
	CAIN A,^L
	PUSHJ P,TOPPGE
	CAIN A,^X
	.VALUE [ASCIZ /:KILL /]
	JRST DANT

CATRLA:
IFN CNTRLA,[
	SKIPN RSTART
	.VALUE		;NO RESTART ADDRESS
	MOVE A,INTACS

	PUSH P,TYPED
	PUSH P,NTRUPT
	PUSH P,NTRUPT+1

;ACS
IRPC XA,,ABCDEFGTUVWXYZ
	PUSH P,XA
TERMIN

IFN COMMND,[
;COMMAND INTERPRETOR
IRP XA,,[RAILW,STRANG,DOTFUN,SQCT]
	PUSH P,XA
TERMIN
]

IFN OUTALL,[
;OUTPUT FORMATTING ROUTINES
IRP XA,,[FRCNPT,SINPT,LNTFLD,NOPNT,LDZRO,CARNUM,LATFLD,SNFLG,EXPCNT,IBASE,OBASE]
	PUSH P,XA
TERMIN
]
IFN INPALL,[
;RDNUM ROUTINES
IRP XA,,[SGNREG,OCTNUM,DECNUM,FLOGBE,FRSPRT]
	PUSH P,XA
TERMIN
]

	PUSH P,[123456,,654321]	;SPECIAL MARKER
	.DISMIS RSTART

LMSSUC:	STOP _CNTRL U LOST $!
	JSR QUIT

]
	.DISMIS NTRUPT+1

CNTRLU:
IFN CNTRLA,[
	POP P,A		;ASSUME WE ARE BACK AT COMMAND LEVEL
	POP P,A
	CAME A,[123456,,654321]
	JRST LMSSUC

IFN INPALL,[
;RDNUM ROUTINES
IRP XA,,[FRSPRT,FLOGBE,DECNUM,OCTNUM,SGNREG]
	POP P,XA
TERMIN
]

IFN OUTALL,[
;OUTPUT FORMATTING ROUTINES
IRP XA,,[OBASE,IBASE,EXPCNT,SNFLG,LATFLD,CARNUM,LDZRO,NOPNT,LNTFLD,SINPT,FRCNPT]
	POP P,XA
TERMIN
]

IFN COMMND,[
;COMMAND INTERPRETOR
IRP XA,,[SQCT,DOTFUN,STRANG,RAILW]
	POP P,XA
TERMIN
]

IRPC XA,,ZYXWVUTGFEDCBA
	POP P,XA
TERMIN

	POP P,NTRUPT+1
	POP P,NTRUPT

	POP P,TYPED
	STRIKE _$!
]
	.DISMIS NTRUPT+1


CNTRLS:	SKIPA A,[1]
CNTRLR:	MOVNI A,1
	.MASTER A,
	STRIKE SLAVE
	POPJ P,

CNTRLG:	MOVE A,INTACS
	.DISMIS [QUIT+1]
CNTRLB:	PUSHJ P,OPNLPT
	POPJ P,
	POPJ P,

CNTRLT:	PUSHJ P,OPNTPL
	POPJ P,
	POPJ P,

CNTRLF:	TRO ZR,DISFLG
	PUSHJ P,OPNDIS
	POPJ P,
	POPJ P,

]
	JRST DANT

CNTRLY:	TRZ ZR,DISFLG
CLODIS:	.DCLOSE
	POPJ P,

OPNDIS:	TRNN ZR,DISFLG
	POPJ P,
	.DSTART DISLIS
	JRST NODSP
	AOS (P)
	POPJ P,

NODSP:	TRZ ZR,DISFLG
	STRIKE _ DISPLAY BUSY  
	POPJ P,

IFN COMMND+COMMUN,[
;THESE TWO LOCATIONS MUST BE SUCCESSIVE
STRANG:	0	;SQUOZE FOR SYMBOL
RAILW:	0	;ADDRES GOT FROM DDT
SQCT:	0	;COUNT OF SQUOZE CHARACTERS
NARGS:	0	;NUMBER OF ARGUMENTS IN FUNCTION CALL

STRINT:	SETZM STRANG
	SETZM RAILW
	MOVEI A,6.
	MOVEM A,SQCT
	POPJ P,

SQUEEZE:	SKIPN SQCT
	POPJ P,	;NO MORE THAN SIX CHARACTERS
	MOVE B,STRANG
	IMULI B,50
	CAILE A,71	;CONVERT TO SQUOZE
	SUBI A,7
	SUBI A,57
	ADD A,B
	MOVEM A,STRANG
	SOS SQCT
	POPJ P,

]

IFN COMMND,[
DOTFUN:	0	;INDICATES IF ANY CHRS TYPED YET

ACCEP1:	STRIKE  ?
	JRST ACCEP2
ACCAPT:ACCEPT:	PUSH P,A
ACCEP2:	STRIKE _$#
	PUSHJ P,STRINT
	SETZM DOTFUN	;NO TEXT READ YET
REMAC:	.IOT TYIC,A
	CAIE A,12
	CAIN A,15	;SAME AS SPACE
	JRST COMMAR
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST REMAC
	CAIN A,177	;RUB-OUT
	JRST ACCEP1
	CAIN A,"-
	PUSHJ P,CNTSUB
	CAIE A,"+
	CAIN A,"(
	PUSHJ P,CNTADD
	CAIN A,")	;IGNORE RIGHT )
	JRST REMAC
	CAIN A," 
	JRST COMMAR	;INTERPRET COMMAND
	CAIN A,"=
	JRST SETVAX	;SET A VALUE
	CAIN A,"#
	JRST SPEAKX	;SPEAK A FIXED POINT VALUE
	CAIN A,"?
	JRST SPEAKF	;SPEAK A FLOATING VALUE
	CAIN A,"<
	JRST LFCART	;ARGUMENTS TO FUNCTION
	SETOM DOTFUN	;AHA, SOME TEXT

	PUSHJ P,SQUEEZE

	JRST REMACî

;ROUTINE TO TIME A FUNCTION

TIME:	MOVE A,[JRST %TIME]
	MOVEM A,COMM1
	POPJ P,

%TIME:	PUSH P,A
	.SUSET [.RRUNT,,A]
	MOVEM A,%RUNTI1
	.RDTIME A,
	MOVEM A,%RELTI1
	POP P,A
	PUSHJ P,@RAILW	;DO FUNCTION
	JFCL
	.SUSET [.RRUNT,,A]
	SUB A,%RUNTI1
	FLOAT A
	FDVR A,[4069000.0]
	.RDTIME B,
	SUB B,%RELTI1
	FLOAT B
	FDVR B,[30.0]
	STRIKE __TIME:  %1F4.3 SEC IN %2F4.3 SEC
	MOVE A,[PUSHJ P,@RAILW]
	MOVEM A,COMM1
	JRST ACCEPT

%RELTI1:	0
%RUNTI1:	0

CNTSUB:	PUSHJ P,RDNUM	;GET OFFSET VALUE
	MOVNS A
	MOVEM A,RAILW	;OFFSET SYMBOL VALUE
	MOVE A,TYPIN
	POPJ P,

CNTADD:	PUSHJ P,RDNUM	;GET OFFSET VALUE
	MOVEM A,RAILW
	MOVE A,TYPIN
	POPJ P,

LFCART:	PUSHJ P,GETENT	;GET ADDRESS
	SETZM ACPNTR'
	POP P,A
LFC1:	AOS ACPNTR
	MOVE A,@ACPNTR
	PUSHJ P,RDNUM	;GET AN ARGUMENT
	PUSH P,A	;PUSH ONTO ARGUMENT STACK
	MOVE A,TYPIN
	CAIE A,">	;WAS IT THE LAST?
	JRST LFC1	;NOPE, GET SOME MORE

	MOVE A,ACPNTR
	MOVEM A,NARGS	;TELL HIM HOW MANY ARGUMENTS THERE WERE
	POP P,@ACPNTR	;PUT ARGS INTO ACS
	SOSE ACPNTR
	JRST .-2
	JRST COMM1

COMMAR:	PUSHJ P,GETENT
	MOVE A,RAILW
	TLZN A,-1
	CAIG A,17
	JRST EXTACC	;TRYING TO EXCECUTE IN ACS OR GARBAGE
	POP P,A
COMM1:	PUSHJ P,@RAILW
	JFCL
	JRST ACCEPT

EXTACC:	STRIKE  BARF ?
	JRST ACCEP2

SETVAX:	PUSHJ P,GETENT
	PUSHJ P,RDNUM
	EXCH A,(P)
	POP P,@RAILW
	JRST ACCEPT

SPEAKX:	PUSHJ P,GETENT
	POP P,A
	SKIPE HLFFXF
	JRST COMOST
	MOVE A,@RAILW
SPUFT:	STRIKE  #1 
	JRST ACCEPT

SPEAKF:	PUSHJ P,GETENT
	POP P,A
	SKIPE HLFFXF
	JRST COMOST
SPAST:	MOVE A,@RAILW
	MOVMS A
	CAMG A,[1.0^-3 ]
	JUMPN A,SPAKF
	MOVE A,@RAILW
	STRIKE %1F4.4
	JRST ACCEPT

SPAKF:	MOVE A,@RAILW
	STRIKE %1E8
	JRST ACCEPT

HLFFXF:	1	;TO CHECK IF FIXED OR FLOATING IS REASONABLE

COMOST:	MOVE A,RAILW@
	TLNN A,777000	;WHETHER  FIXED OR FLOATING
	JRST SPUFT	;PROBABLY FIXED
	MOVNS A
	TLNE A,777000
	JRST SPAST	;PROBABLY FLOATING
	MOVNS A
	JRST SPUFT	;PROBABLY FIXED NEGATIVE

GETENT:	SKIPN DOTFUN
	POPJ P,		;NO NAME TYPED - USE PREVIOUS VALUE
	SKIPA A,STRANG
	IMULI A,50
	SOSL SQCT
	JRST .-2	;LEFT JUSTIFY SQUOZE CODE
	MOVEM A,STRANG
	PUSH P,RAILW	;SAVE A POSSIBLE OFFSET
	.BREAK 12,[4,,STRANG]	;GET SYMBOL VALUE FROM DDT
	SKIPE RAILW
	JRST GETE1
	STRIKE  MUMBLE ?
	SUB P,[1,,1]
	JRST ACCEP2

GETE1:	POP P,A	;GET POSSIBLE OFFSET
	ADDM A,RAILW
	POPJ P,

]
IFN COMMUN,[

;ROUTINE TO ALLOW MACHINE LANGUAGE PROGRAMS TO INTERACT WITH OTHER
;  PROGRAMS VIA DISK OR CORE LINK DEVICES
;	CALLING SEQUENCE
;		PUSHJ P,LISTEN
;		SIXBIT /INDOTD/	;IND=INPUT DEVICE, OTD=OUTPUT DEVICE
;		SIXBIT /FILNM1/
;		SIXBIT /USR/
;		;RETURN

CINBLK:	0	;INPUT DEVICE NAME GOES HERE
	0	;FILE NAME GOES HERE
	SIXBIT /CALL/
	0

COTBLK:	1,,0	;OUTPUT DEVICE NAME GOES IN RIGHT HALF
	0	;FILE NAME (SAME AS CINBLK+1)
	SIXBIT /RETURN/
	0

LISTEN:	MOVE A,@(P)	;GET FIRST WORD
	HLRZM A,CINBLK
	HRRM A,COTBLK
	AOS (P)
	MOVE A,@(P)
	MOVEM A,CINBLK+1	;GET FILE NAME
	MOVEM A,COTBLK+1
	AOS (P)
	MOVE A,@(P)	;GET USR NAME
	.SUSET [.SSNAME,,A]

	.OPEN DSIC,CINBLK	;OPEN CALLING FILE
	PUSHJ P,HANGLN	;WAIT AND TRY AGAIN
	.OPEN DSOC,COTBLK
	STOP _RETURN FILE WON'T OPEN - LISTEN

	PUSH P,ZR
	MOVEI ZR,DSIFLG	;DEFAULT ID DISK
	SKIPE ZOMSPK
	ADDI ZR,TTOFLG
	PRINT _

	SETZM PARCTR
	SETZM NARGS

ZOOM1:	PUSHJ P,TYI	;READ A CHARACTER
	CAIN A,3
	STOP _EOF - LISTEN
	CAIE A,"(	;COMMANDS MUST START WITH A (
	JRST ZOOM1	;KEEP TRYING
	SETOM UNRCHF

ZOMSTR:	PUSHJ P,STRINT	;START HERE AFTER EVALUATING A VARIABLE
ZOOM3:	PUSHJ P,TYI
	CAIN A,3
	STOP _EOF - LISTEN
	CAIN A,"(
	JRST LPAR
	CAIN A,")
	JRST RPAR
	PUSHJ P,TYO
	CAIN A,15	;IS IS CR
	JRST ZOOM3	;IGNORE
	CAIN A,12	;IS IT LF
	JRST ZOOM3	;ALSO IGNORE
	CAIN A,40	;SPACE?
	JRST ZOOM3

ZOOM4:	PUSHJ P,SQUEEZE

	PUSHJ P,TYI
	PUSHJ P,TYO
	CAIN A,40
	JRST ZOOM4B	;SYMBOL TERMINATORS ARE SPACE, CR,LF
	CAIN A,12	;CR
	JRST ZOOM4B
	CAIN A,15	;LF
	JRST ZOOM4B
	CAIE A,")	;LEFT PAREN => FUNCTION WITH NO ARGS
	JRST ZOOM4
	SETOM UNRCHF	;READ RIGHT PAREN AGAIN

ZOOM4B:	SKIPA A,STRANG
	IMULI A,50
	SOSL SQCT
	JRST .-2
	MOVEM A,STRANG
	.BREAK 12,[4,,STRANG]
	SKIPA
ZOOM4C:	PUSHJ P,TYO
	PUSHJ P,TYI
	CAIN A,40
	JRST ZOOM4C	;IGNORE SPACES
	CAIN A,"#
	JRST GETFIX
	CAIN A,"?
	JRST GETFLO
	CAIN A,"=
	JRST ZEQ
	CAIN A,12
	JRST ZOOM4C
	CAIN A,15
	JRST ZOOM4C

;MUST BE AN ARGUMENT
	SETOM UNRCHF
ZOOM4A:	PUSHJ P,TYI	;GET FIRST CHARACTER OF ARGUMENT
	CAIGE A,"A
	JRST .+3
	CAIG A,"Z	;IS IT A LETTER?
	JRST ZOOM6	;YES, READ IN A WORD ARGUMENT
	SETOM UNRCHF
	PUSHJ P,RDNUM	;NO, READ A NUMBER ARGUMENT
	SKIPN NONEMP
	JRST ZOOM5
	PUSH P,A
	PUSHJ P,NUMOUT	;PRINT THE NUMBER
ZOOM7:	AOS NARGS	;COUNT ARGUMENTS
ZOOM5:	MOVEI A,40
	CAMN A,TYPIN	;IF LAST WASN'T A SPACE, WE MUST BE DONE
	JRST ZOOM4A	;GET MORE NUMBERS

	SKIPN Z,NARGS
	JRST ZD2	;NO ARGUMENTS
ZD1:	POP P,@Z	;PUT ARGS INPROPER ACS
	SOSLE Z
	JRST ZD1
ZD2:	SETOM UNRCHF	;REREAD LAST CHAR
	PRINT  )_ => (
	ADDI ZR,DSOFLG	;TTY AND OUTPUT
	PUSH P,TYPIN	;SAVE IO STUFF
	PUSH P,UNRCHF
	SKIPE ZOMSPK
	STRIKE  )_( 
	SKIPE RAILW	;RAILW=0 => BAD SYMBOLIC NAME
	PUSHJ P,@RAILW	;DO THE DESIRED FUNCTION
	SKIPN RAILW
FERR:	PRINT FUNCTION-ERROR
	POP P,UNRCHF
	POP P,TYPIN
	SUBI ZR,DSOFLG	;TURN OFF OUTPUT
	SETZM NARGS	;RESET ARG COUNTER
	JRST ZOMSTR

ZOOM6:	SETZM FWORD
	SETOM UNRCHF
	MOVE D,[600,,FWORD-1]
	MOVEI G,6.	;LOOK AT FIRST 6 CHARACTERS ONLY
	PUSHJ P,TYI
	PUSHJ P,TYO	;SHOW WHAT IS BEING READ
	CAIN A," 	;IGNORE LEADING SPACES
	JRST .-3
RW1:	ADDI A,40	;CONVERT TO SIXBIT
	SOSL G	;SKIP THE DEPOSIT AFTER 6
	IDPB A,D
	PUSHJ P,TYI
	CAIN A,")	;RIGHT PAREN IS A TERMINATOR
	JRST RW2
	PUSHJ P,TYO
	CAIE A," 	;TRAILING SPACE IS A TERMINATOR
	JRST RW1
RW2:	PUSH P,FWORD	;PUT WORD ON ARG STACK
	JRST ZOOM7	;GET MORE

FWORD:	0

ZEQ:	PUSHJ P,TYO
	PUSHJ P,RDNUM
	ADDI ZR,DSOFLG	;TURN ON OUTPUT
	SKIPN RAILW
	JRST FERR
	PUSHJ P,NUMOUT	;PRINT THE NUMBER
	SUBI ZR,DSOFLG	;TURN OFF OUTPUT
	MOVEM A,@RAILW	;SET THE VALUE
	PRINT  ) => (
	PUSHJ P,NUMOUT	;PRINT IT AGAIN, SAM
	SETOM UNRCHF
	JRST ZOMSTR

GETFLO:	PUSHJ P,TYO
	PRINT  ) => (
	ADDI ZR,DSOFLG
	SKIPN RAILW
	JRST FERR
	MOVE A,@RAILW
	MOVMS
	CAMG A,[1.0^-3.]
	JUMPN A,GETBIG
	MOVE A,@RAILW
	PRINT  %1F4.4  
	SUBI ZR,DSOFLG
	JRST ZOMSTR
GETBIG:	MOVE A,@RAILW
	PRINT  %1E8  
	SUBI ZR,DSOFLG
	JRST ZOMSTR

GETFIX:	PUSHJ P,TYO
	PRINT  ) => (
	ADDI ZR,DSOFLG
	SKIPN RAILW
	JRST FERR
	MOVE A,@RAILW
	PRINT  %1I8  
	SUBI ZR,DSOFLG
	JRST ZOMSTR

LPAR:	AOS PARCTR
	ADDI ZR,DSOFLG
	PRINT _
LP1:	PUSHJ P,TYO	;PRINT ON TTY AND OUTPUT
	SUBI ZR,DSOFLG
	JRST ZOOM3	;READ ANOTHER CHARACTER

RPAR:	ADDI ZR,DSOFLG
	SOSE PARCTR
	JRST LP1
	PUSHJ P,TYO	;TYPE LAST )

CLORET:	.CLOSE DSOC,
	.CLOSE DSIC,
	.FDELE CINBLK	;DELETE CALLER
	JFCL
	POP P,ZR
	AOS (P)
	POPJ P,	;RETURN

NUMOUT:	SKIPLE FLOGBE	;PRINT THE NUMBER IN 'A'
	PRINT %1F6.4 
	SKIPG FLOGBE
	PRINT %1I6 
	POPJ P,

HANGLN:	PUSH P,A
	MOVEI A,100
	.SLEEP A,
	POP P,A
	SOS (P)
	SOS (P)
	POPJ P,	;DO IT AGAIN

OUTDEV:	0	;NAME OF OUTPUT DEVICE
ZOMSPK:	-1	;0=> DON'T OUTPUT TO TTY, -1=> DO
PARCTR:	0	;COUNT OF PAIRED PARENS
]

IFN OUTALL,[

STRING:	PUSH P,E
	PUSH P,V
	PUSH P,W
	PUSH P,X
	PUSH P,A
	HRLI A,440600	;MAKE A BYTE PT
	MOVEM A,SINPT
	PUSHJ P,NXCHAR
	POP P,A
	POP P,X
	POP P,W
	POP P,V
	POP P,E
	POPJ P,

TACIT:	ILDB V,SINPT	;EASY FIXED POINT OUTPUT
	SETZM LNTFLD	;INDICATE FREE FORMAT
	SETZM NOPNT	;INDICATE DECPNT REQ
	SETZM LDZRO	;INDICATE NO LEADING ZEROS
	MOVE A,-7(P)	;RESTORE A (ASSUME PUSHED)
	MOVE A,A-'1(V)	;GET DESIRED VALUE
	PUSHJ P,DIGIT	;TYPE IT
NXCHAR:	ILDB A,SINPT
	CAIN A,'_	;TYPE AS CR.
	MOVNI A,40-15
	CAIN A,'!	;TERMINATION
	POPJ P,
	CAIN A,'^	;TYPE NEXT AS CONTROL CHAR.
	JRST TYPCNT
	CAIN A,'#	;TYPE C(NEXT AC) AS NUMBER
	JRST TACIT
	CAIN A,'%	;TYPE NEXT IN FIXED FORMAT
	JRST FXFRM
	CAIN A,'&	;FILL UP
	JRST FLLUPT
	CAIN A,'$	;TYPE NEXT UNCONDITIONALLY
	ILDB A,SINPT
	JRST ACNVRT

FLLUPT:	PUSH P,B
	MOVEI B,0
FLLUP1:	ILDB A,SINPT
	CAIE A,' 	;SPACE
	CAIN A,'.
	JRST FLLUP2
	SUBI A,'0
	IMULI B,10.
	ADD B,A
	JRST FLLUP1

FLLUP2:	PUSHJ P,COLUMN
	POP P,B
	JRST NXCHAR

TYPCNT:	ILDB A,SINPT	;HANDLE CONTROL CHARCT OUT
	SUBI A,100
ACNVRT:	ADDI A,40	;CONVERT TO ASCII
	PUSHJ P,TYPA	;TYPE CHARACTER
	JRST NXCHAR

TYPA:	AOS CARNUM
	CAIN A,15	;CAR. RET.
	JRST ECHLF
TYO:
IFN DISALL,[
	TRNE ZR,DISCHR	;TYPE OUT SUBROUTINE
	JRST DTYOA	;OUTPUT TO DISPLAY ONLY HACKS E,W,X
]
	SKIPE MURDER
	POPJ P,		;ALL OUTPUT MURDERED
	TRNE ZR,TTOFLG
	.IOT TYOC,A	;OUTPUT TO TTY
	TRNE ZR,LPTFLG
	.IOT LPTC,A	;OUTPUT TO LPT
	TRNE ZR,DSOFLG
	.IOT DSOC,A	;OUTPUT TO DISK
	TRNE ZR,CLOFLG
	.IOT CLOC,A	;OUTPUT TO CORE LINK
	POPJ P,

MURDER:	0	;NON-ZERO TO KILL ALL BUT DISPLAY OUTPUT
ECHLF:	SETZM CARNUM	;ECHO LINE FEED
	PUSHJ P,TYO
	MOVEI A,12
	PUSHJ P,TYO
	MOVEI A,15
	POPJ P,
FXFRM:	SETZM NOPNT	;INDICATE DECPNT REQ
	SETZM LDZRO	;INDICATE NO LEADING ZEROS
	ILDB V,SINPT
	MOVE A,-7(P)	;RESTORE A (ASSUME PUSHED)
	MOVE A,A-'1(V)
	ILDB V,SINPT
	CAIN V,'I	;FIXED POINT
	JRST IFORM
	CAIN V,'F	;FLOATING F FORM
	JRST FFORM
	CAIN V,'E	;FLOATING E FORM
	JRST EFORM
	CAIN V,'A	;ASCII  FORMAT
	JRST AFORM
	STOP _WEIRD FORMAT SPECIFICATION

IFORM:	ILDB V,SINPT
	MOVEI V,0-'0(V)
	MOVEM V,LNTFLD
	PUSHJ P,DIGIT
	JRST NXCHAR

AFORM:	MOVE V,A	;GET ADDR OF STRING
	HRLI V,440700
	ILDB A,V
	JUMPE A,NXCHAR	;QUIT IF ZERO
	PUSHJ P,TYPA
	JRST .-3

FFORM:	SETOM NOPNT
	ILDB V,SINPT	;FLOATING POINT OUT
	MOVEI V,0-'0(V)
	MOVEM V,LNTFLD
	PUSH P,OBASE	;SET OBASE TO 10. TEMP
	MOVEI V,10.
	MOVEM V,OBASE
	SAVE B
	ILDB V,SINPT	;IGNORE COMMA
	ILDB V,SINPT
	MOVEI V,0-'0(V)
	MOVEM V,LATFLD
	MOVE B,[0.5]
	FMPR B,[0.1]	;GENERATE ROUNDING QUANTITY
	SOJG V,.-1
	SETZM SNFLG
	JUMPGE A,POSFL
	MOVNS A
	SETOM SNFLG
	SOS LNTFLD
POSFL:	CAML A,[1.0^6]
	JRST TOOLRF
	FADR A,B	;ADD IN ROUNDING QUANTITY
	MOVEM A,-1(P)	;UPDATE SAVED VALUE
	FIX A
	MOVE A,B
	SKIPG LNTFLD
	JRST ZSOFLT
	PUSHJ P,DIGITS	;OUTPUT INTEGER PART
PSZRFT:	PUSH P,A
	MOVEI A,".
	PUSHJ P,TYPA	;DECIMAL POINT
	POP P,A
	MOVE V,LATFLD	;RESTORE SECOND FIELD LENGTH
	JUMPE V,PNDXDC
	MOVEM V,LNTFLD
	SETOM LDZRO
	FLOAT A
	MOVNS A
	FADR A,-1(P)
GROWMN:	FMPR A,[10.0]
	SOJG V,GROWMN
	FIX A
	MOVE A,B
	PUSHJ P,DIGIT
PNDXDC:	POP P,B
	POP P,A
	POP P,OBASE
	JRST NXCHAR

ZSOFLT:	PUSH P,A
	MOVEI A,"-	;MAY SCREW ALIGNMENT BUT ...
	SKIPE SNFLG
	PUSHJ P,TYPA
	POP P,A
	JRST PSZRFT

TOOLRF:	MOVEM A,-1(P)
	SKIPE SNFLG;	TOO LARGE FOR F FORM
	AOS LNTFLD
	SETOM LDZRO
	SETZM EXPCNT
	JRST RDCMRP


NOTFRE:	SKIPE LDZRO	;LEADING SPACE OR ZERO GENERATOR
	SKIPA A,["0]
	MOVEI A," 	;SPACE
	JRST .+2
	PUSHJ P,TYPA
	SOJGE C,.-1
	POPJ P,
EFORM:	PUSH P,OBASE	;SET OBASE TO 10. TEMP
	SAVE B
	MOVEI V,10.
	MOVEM V,OBASE
	SETOM NOPNT
	SETOM LDZRO
	SETZM EXPCNT
	SETZM SNFLG
	JUMPGE A,BLBIL
	MOVNS A
	SETOM SNFLG
BLBIL:	ILDB V,SINPT
	MOVEI V,0-'0(V)
	MOVEM V,LNTFLD	;ROUNDING CLUDGE GOES HERE
	JUMPE A,WORRYO
	CAMGE A,[1.0]
	JRST ZRXPN
RDCMRP:	FMPR A,[0.1]
	AOS EXPCNT
	CAML A,[1.0]
	JRST RDCMRP
BANDG:	MOVE B,LNTFLD
BANDAG:	FMPR A,[10.0]
	SOJG B,BANDAG
	FIX A
SGNEFR:	MOVEI A," 	;SPACE
	SKIPE SNFLG
	MOVEI A,"-
	PUSHJ P,TYPA
	MOVEI A,".
	PUSHJ P,TYPA
	MOVE A,B
	PUSHJ P,DIGIT	;MANTISSA
	MOVEI A,"E
	PUSHJ P,TYPA
	MOVEI A,"+
	SKIPGE EXPCNT	;EXPONENT
	MOVEI A,"-
	PUSHJ P,TYPA
	MOVM A,EXPCNT
	IDIVI A,10.
	ADDI A,260
	ADDI B,260
	PUSHJ P,TYPA
	MOVE A,B
	PUSHJ P,TYPA
	POP P,B
	POP P,A
	POP P,OBASE
	JRST NXCHAR

NEGXPE:	FMPR A,[10.0]
ZRXPN:	SOS EXPCNT
	CAMGE A,[0.1]
	JRST NEGXPE
	AOS EXPCNT
	JRST BANDG

WORRYO:	SETZM B
	JRST SGNEFR
DIGIT:	SETZM SNFLG
DIGITS:	SAVE C
	PUSHJ P,DIGDOG
	MOVE A,OBASE
	CAIE A,10.
	JRST DIGEND
	SKIPN FRCNPT
	SKIPE NOPNT
	JRST DIGEND
	MOVEI A,".
	PUSHJ P,TYPA
DIGEND:	JRST POPCJ

DIGDOG:	MOVE C,LNTFLD
	JUMPGE A,PSHDIG
	SETOM SNFLG
	SOS C
	MOVNS A		;

PSHDIG:	IDIV A,OBASE	;ASSEMBLE NUMBER IN OUTPUT FORM
	CAILE B,9.	;CHECK FOR OBASE > 10. POSSIBILITY
	ADDI B,7	;USE A, B, C,  ETC.
	ADDI B,260
	HRLM B,(P)	;STORE ONE DIGIT
	SOS C
	JUMPE A,FOOEAY
	PUSHJ P,PSHDIG	;MORE TO COME
POPDIQ:	HLRZ A,(P)	;SPEW ONE OF PDL
	JRST TYPA

FOOEAY:	SKIPE LNTFLD
	PUSHJ P,NOTFRE	;LEADING BLANKS OR ZEROS
	SKIPE SNFLG
	PUSHJ P,PTMNS	;MINUS SIGN
	JRST POPDIQ

PTMNS:	MOVEI A,"-
	JRST TYPA

FRCNPT:	0	;1 TO FORCE NO DECIMAL POINT
SINPT:	0
LNTFLD:	0
NOPNT:	0
LDZRO:	0
CARNUM:	0
LATFLD:	0
SNFLG:	0
EXPCNT:	0

]
;THIS PAGE IS NOT WITHIN THE SCOPE OF ANY IFN.

IBASE:	8.	;BASE 8 UNLESS THERE IS A DECIMAL POINT
OBASE:	10.	;OUTPUT ALWAYS BASE 10.

TOPPGE:	MOVEI A,14	;CONTROL L
	JRST TYO

;FILL OUT UP TO B CHARACTERS
COLUMN:	PUSH P,A
	PUSH P,B
	MOVEI A," 	;SPACE
MORSPC:	CAMG B,CARNUM
	JRST POPBJ
	PUSHJ P,TYPA
	JRST MORSPC

;OPEN LPT (SKIPS UNLESS BUSY)
OPNLPT:	.OPEN LPTC,LPTOP	;OPEN LINE PRINTER
	JRST LPTBUS
OPNSOK:	TRO ZR,LPTFLG
	AOS (P)
	POPJ P,
LPTBUS:	STRIKE _CHANGED TO TPL 
OPNTPL:	.OPEN LPTC,TPLOP
	JRST .+2	;SKIPA
	JRST OPNSOK
	STRIKE _SORRY TPL LOSES  
	POPJ P,

CLOLPT:	.CLOSE LPTC,	;CLOSE LINE PRINTER
	TRZ ZR,LPTFLG
	POPJ P,
REREAD:	MOVE A,TYPIN	;REREAD LAST CHARACTER
	POPJ P,

TYI:	AOSN UNRCHF
	JRST REREAD
	TRNE ZR,DSIFLG
	JRST TYIDSK
	TRNE ZR,CLUFLG
	JRST TYICLU
	.IOT TYIC,A
FXLW:	SKIPN FXLWCS
	JRST NOFXLW
	CAIL A,140
	SUBI A,40	;CHANGE LOWER CASE TO UPPER CASE
NOFXLW:	MOVEM A,TYPIN
	POPJ P,

TYIDSK:	.IOT DSIC,A	;INPUT FROM DISK ETC.
	JRST FXLW
TYICLU:	.IOT CLUC,A
	JRST FXLW


UNRCHF:	0	;-1 TO REREAD LAST CHARACTER
FXLWCS:	0	;CHANGE LOWER CASE TO UPPER CASE
TYPIN:	0	;LAST CHARACTER READ IN
IFN INPALL,[

RDNUMA:	STRIKE  ? 
	SKIPA
RDNUM:	PUSH P,A	;SAVE OLD VALUE
	SETZM NONEMP'
	SETZM SGNREG	;READ A NUMBER ROUTINE
	SETZM OCTNUM
	SETZM DECNUM
	SETZM FLOGBE	;DIGITS PAST DECIMAL POINT
RDLP1:	PUSHJ P,TYI
	CAIG A,40	;SPACE OR CONTROL CHARACTERS
	JRST RDLP1
	SKIPA
RDLP:	PUSHJ P,TYI
	CAIE A,15
	CAIN A,12
	JRST GOTNUM	;END OF NUMBER
	CAIGE A,40
	JRST RDLP	;IGNORE CONTROL CHAR
	CAIN A,"-
	JRST MSGN
	CAIN A,".
	JRST DECPT
	CAIN A,"+
	JRST RDLP
	CAIN A,"E
	JRST GOTANE
	CAIN A,177	;RUBOUT
	JRST RDNUMA	;START ALL OVER

	CAIL A,"0	;IS IT A DIGIT
	CAILE A,"9
	JRST .+2
	JRST OKNUMB	;YES
	CAIL A,"A	;IS IT A LETTER
	CAILE A,"Z	
	JRST GOTNUM	;NO - SO MUST BE END OF NUMBER
OKNUMB:
	SUBI A,"0
	CAIL A,10.
	SUBI A,7	;FOR IBASE>10. WE USE A,B,C ETC
	CAIL A,IBASE
	JRST GOTNUM	;IF TOO LARGE FOR IBASE
	SETOM NONEMP	;INDICATE WE GOT SOME DIGIT
	PUSH P,A
	EXCH A,OCTNUM	;ACCUMULATE NUMBER IN IBASE
	IMUL A,IBASE
	ADDM A,OCTNUM
	POP P,A
	EXCH A,DECNUM	;ACCUMULATE NUMBER IN DECIMAL
	IMULI A,10.
	ADDM A,DECNUM
	SKIPLE FLOGBE
	AOS FLOGBE	;UPDATE COUNT
	SKIPL FLOGBE
	JRST RDLP
	MOVEI A,1
	MOVEM A,FLOGBE
	JRST RDLP

MSGN:	SETOM SGNREG	;MINUS SIGN ENCOUNTERED
	JRST RDLP
DECPT:	MOVE A,DECNUM
	MOVEM A,OCTNUM
	SETOM FLOGBE	;INDICATE POSSIBLE FLOATING
	JRST RDLP

GOTNUM:	POP P,A
	SKIPN NONEMP
	POPJ P,		;NOTHING WORTHWHILE WAS TYPED, SO RETURN OLD VALUE
	SKIPLE FLOGBE
	JRST FLONGN
	MOVE A,OCTNUM
GOTITL:	SKIPE SGNREG
	MOVNS A
	POPJ P,

FLONGN:	PUSH P,FLOGBE	;SAVE FLOGBE
	MOVE A,[1.0]
FLNMGN:	FMPR A,[0.1]
	SOSE FLOGBE
	JRST FLNMGN
	POP P,FLOGBE	;RESTORE FLOGBE VALUE
	EXCH A,DECNUM
	FLOAT A
	FMPR A,DECNUM
	JRST GOTITL

GOTANE:	SKIPLE FLOGBE
	JRST FLOCLL	;WE DID HAVE A .
	MOVEI A,10.	;SIMULATE ZERO AFTER .
	IMULM A,DECNUM
	MOVEI A,1
	MOVEM A,FLOGBE
FLOCLL:	PUSHJ P,FLONGN
	MOVEM A,FRSPRT	;STORE FIRST COMPONENT
	PUSH P,FLOGBE	;SAVE FLOGBE
	PUSHJ P,RDNUM	;NOW READ EXPONENT AND HOPE TO HELL A SECOND E DOES NOT REAR ITS UGLY HEAD
	POP P,FLOGBE
	MOVE A,DECNUM
	EXCH A,FRSPRT
	SKIPN FRSPRT
	POPJ P,
	SKIPE SGNREG
	JRST SCLDWN
SCLUPE:	FMPR A,[10.0]
	SOSE FRSPRT
	JRST SCLUPE
	JRST SPOPJ

SCLDWN:	FMPR A,[0.1]
	SOSE FRSPRT
	JRST SCLDWN
SPOPJ:	SUB P,[1,,1]
	POPJ P,

SKPYES:	PUSH P,A	;AWAIT YES OR NO ANSWER
SKPYS:	PUSHJ P,TYI
	CAIN A,"Y
	JRST GOTY
	CAIN A,"N
	JRST GOTN
	JRST SKPYS
GOTY:	STRIKE ES
	AOS -1(P)
	JRST POPAJ

GOTN:	STRIKE O
	JRST POPAJ

SGNREG:	0
OCTNUM:	0
DECNUM:	0
FLOGBE:	0
FRSPRT:	0
]

HEADIN:	0
IFN STMPIT,[

;GENERATES TIME AND DATE STAMP

MYNAME:	.FNAM1?SIXBIT/      /?.FNAM2?SIXBIT/      /

STAMP:	SAVE D
	MOVE C,[440600,,MYNAME]
	PUSHJ P,LPDAT
	MOVE C,[440600,,MYNAME+2]
	PUSHJ P,LPDAT
	.RDATE D,
	PUSHJ P,SPLASH
	.RTIME D,
	PUSHJ P,SPLASH
	JRST POPDJ

SPLASH:	MOVE C,[440600,,D]
	PUSHJ P,CLSPS1
	PUSHJ P,CLSPSP
	PUSHJ P,.+1
	MOVEI A," 
	JRST TYPA

CLSPSP:	PUSHJ P,.+1
	MOVEI A,":
	PUSHJ P,TYPA
	JRST CLSPS1

LPDAT:	PUSHJ P,.+1
	PUSHJ P,.+1
CLSPS1:	PUSHJ P,.+1
	ILDB A,C
	CAIE A,"?
	ADDI A," 
	JRST TYPA

BARF:	PRINT _
	PUSHJ P,STAMP
	SKIPE HEADIN
	PUSHJ P,@HEADIN
	PRINT _
	POPJ P,

]
IFN FLEFLG,[

NAMEP:	PUSH P,A	;OUTPUT CURRENT FILE-NAME
	PUSH P,B
	MOVE B,[440600,,INOP+1]
	ADD B,FRMTSW
	PUSHJ P,NAMEL
	PUSHJ P,NAMEL
	JRST POPBJ

NAMEL:	ILDB A,B
	ADDI A,40
	PUSHJ P,TYO
	TLNE B,770000
	JRST NAMEL
	MOVEI A,40
	JRST TYO

OPINFL:	PUSH P,A
	.OPEN ERRC,ERROP
	.VALUE
ERRLOP:	.IOT ERRC,A
	CAIN A,14
	JRST CLORIN
	.IOT TYOC,A
	JRST ERRLOP

CLORIN:	.CLOSE ERRC,
	JRST POPAJ

ERROP:	0,,(SIXBIT/ERR/)
	1
	0

INOP:	0,,(SIXBIT/DSK/)
	0
	SIXBIT />/

FRMSNM:	0		;SNAME

ONOP:	0,,(SIXBIT /DSK/)
	0
	SIXBIT />/

FRMSOM:	0	;SNAME

NMSWT:	0	;NON-ZERO ON FNAM2
FRMTSW:	0	;NON-ZERO FOR OUTPUT

VPLC:	BLOCK 6

TTINR:	MOVEI C,0
	JRST .+2
TTINW:	MOVEI C,ONOP-INOP
	MOVEM C,FRMTSW
TTINT:	SETZM NMSWT	;ACCEPT FILE NAME
	MOVE D,[10700,,VPLC-1]
AGAST:	.IOT TYIC,A
	CAIE A,177
	JRST NOOUT
	CAMN D,[10700,,VPLC-1]
	JRST KILLIT
	LDB A,D
	CAML D,[350700,,0]
	JRST WRDBND
	ADD D,[70000,,]	;DECREMENT BYTE-POINTER
AGAST1:	.IOT TYOC,A
	JRST AGAST

WRDBND:	SUB D,[340000,,1]
	JRST AGAST1

NOOUT:	IDPB A,D
	CAIE A,15
	CAIN A,"_
	JRST .+2
	JRST AGAST
	.IOT TYOC,[15]
	.IOT TYOC,[12]
	MOVE D,[10700,,VPLC-1]
AGAIN:	MOVEI B,0
RLOP:	ILDB A,D	;GET A CHARACTER
	CAIN A," 	;SPACE
	JRST SPAE
	CAIN A,":
	JRST COLON
	CAIE A,"_
	CAIN A,15	;CAR RET
	JRST RETCR
	CAIN A,";
	JRST SMCLN
	SUBI A," 	;SPACE
	TLNE B,770000
	JRST RLOP	;IGNORE PAST 6 CHRS
	LSH B,6
	IOR B,A
	JRST RLOP

LFTJST:	SKIPE B		;LEFT ADJUST
	TLNE B,770000
	POPJ P,
	LSH B,6
	JRST LFTJST

SPAE:	PUSHJ P,SPCOUT
	JRST AGAIN

RETCR:
SPCOUT:	PUSHJ P,LFTJST
	SKIPN B
	POPJ P,
	SKIPE NMSWT	;FIRST FILE NAME
	JRST NAM2
	MOVEM B,INOP+1(C)
	SETOM NMSWT
	POPJ P,

NAM2:	MOVEM B,INOP+2(C)
	POPJ P,

COLON:	PUSHJ P,LFTJST
	HLRM B,INOP(C)
	JRST AGAIN

SMCLN:	PUSHJ P,LFTJST
	MOVEM B,FRMSNM(C)
	JRST AGAIN

KILLIT:	MOVEI A,40
	.IOT TYOC,A
	MOVEI A,"?
	.IOT TYOC,A
	JRST TTINT

OPNDI:	SKIPE FRMSNM
	.SUSET [.SSNAME,,FRMSNM]
	.OPEN DSIC,INOP
	JRST OPINFL		;FAILED
	TRO ZR,DSIFLG
	AOS (P)
	POPJ P,

OPNDO:	SKIPE FRMSOM
	.SUSET [.SSNAME,,FRMSOM]
	.OPEN DSOC,ONOP
	JRST OPINFL
	TRO ZR,DSOFLG
	AOS (P)
	POPJ P,

CLONDI:	.CLOSE DSIC,
	TRZ ZR,DSIFLG
	POPJ P,

CLONDO:	.CLOSE DSOC,
	TRZ ZR,DSOFLG
	POPJ P,

DSKONL:	DSOFLG+DSIFLG

]

IFN SRTFLG,[

;NELSON'S RADIX EXCHANGE SORT, SORTS TABLE OF WORDS STARTING AT (A) AND OF LENGTH (B)
;EACH ENTRY CONSISTS OF TWO WORDS, THE FIRST OF WHICH IS SORTED ON
;C CONTAINS THE INITIAL MASK BIT, SORTING IS DONE ON IT AND ALL BITS TO THE RIGHT
;SO TO SORT ON THE RIGHT-HALF OF THE WORD C SHOULD BE 400000
;AND TO SORT ON THE WHOLE WORD IT WOULD BE 400000,,0

SORT:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	ADD B,A		;GET FINAL ADDRESS+1
	PUSHJ P,SORT1	;GO SORT IT
	JRST POPDJ	;RESTORE ACS

SORT1:	HRLM B,(P)	;STUFF *TOP* ON LEFT HALF OF PDL
	CAIL A,-2(B)	;SORT FINISHED IF AT CENTER
	JRST SORT7
	PUSH P,A	;PUSH *BOTTOM* ON PDL
SORT3:	TDNN C,(A)	;LOWER BIT ON?
	JRST SORT4
	SUBI B,2	;FIND BOTTOM ENTRY
	TDNE C,(B)      ;IS THIS IT?
	JRST SORT2

	MOVE D,(A)      ;YES SWAP WORDS SORTED ON
	EXCH D,(B)
	MOVEM D,(A)
	MOVE D,1(A)	;AND NOW SWAP THE SECOND WORDS
	EXCH D,1(B)
	MOVEM D,1(A)

SORT4:	ADDI A,2        ;FIND TOP ENTRY
SORT2:	CAME A,B        ;HAVEN'T WE MET SOMEWHERE?
	JRST SORT3
	ROT C,-1        ;NEXT LEVEL
	POP P,A		;RETORE OLD *BOTTOM*, B IS ALREADY SET UP TO HALF-WAY UP
	JUMPL C,SORT6   ;CROCK -ROTATED AROUND, SO DONE
	PUSHJ P,SORT1   ;CALL SELF ONCE - BOTTOM HALF
	HLRZ B,(P)	;GRAB OLD *TOP* OF LEFT-HALF OF PDL, MAKE NEW *TOP*, A IS ALREADY SET HALF-WAY UP
	PUSHJ P,SORT1   ;CALL SELF TWICE - TOP HALF
SORT6:	ROT C,1		;RESTOR FOR NEXT HIGHER LEVEL
SORT7:	HLRZ A,(P)	;GRAB OLD *TOP* MAKE NEW *BOTTOM*
	POPJ P,

]

IFN FFTFLG,[

;FUNCTIONS TO PERFORM FAST FOURIER TRANSFORM
;AVAILABLE FUNCTIONS:
;	ITINIT => INITIALIZE TABLES FOR INVERSE TRANSFORM
;	FTINIT => INITIALIZE TABLES FOR FORWARD TRANSFORM
;  THE ABOVE FUNCTIONS NEED ONLY BE CALLED WHEN THE NUMBER
;  OF POINTS TO BE TRANSFORMED IS CHANGED.
;	REVBS => BIT REVERSE THE INPUT VECTORS
;	TRANS => PERFORM THE TRANSFORM
;	SEPER => SEPARATE TWO REAL VECTORS THAT WERE TRANSFORMED
;  SIMULTANEOUSLY
;	ABSVS => TAKE MAGNITUDE OF TRANSFORM (WHICH IS COMPLEX)
;	FFTKIL => DELETE ALL TABLES CREATED BY FFT ROUTINES
;  THIS ERASES ANY STORAGE ARRAYS THAT THE FFT CREATES, AND
;  AN INITIALIZING FUNCTION MUST BE CALLED BEFORE 'TRANS' OR
;  'REVBS' CAN BE CALLED.
; 	THE TRANSFORM WILL REPLACE THE INPUT.




;FUNCTION TO INITIALIZE FOR FFT
;	A=NUMBER OF ENTRIES IN INPUT VECTOR

;ENTER HERE FOR INVERSE TRANSFORM
ITINIT:	MOVE D,[MOVN B,@SINPTR]
	MOVEM D,TRNSWT
	JRST FINIT


;ENTER HERE FOR FORWARD TRANSFORM
FTINIT:	MOVE D,[MOVE B,@SINPTR]
	MOVEM D,TRNSWT
FINIT:	MOVEM A,NN	;NN=NUMBER OF POINTS IN VECTOR

	SETZM E	;INITIALISE FFT TABLES
LOGNLP: AOS E
	ASH A,-1
	JUMPN A,LOGNLP	;FIND LOG<N>
	SOS E

	MOVEM E,LN;     GET LN
	MOVEI A,1
	ASH A,(E);     N=2**LN
	CAME A,NN	;CHECK FOR POWER OF TWO
	STRIKE _NOT A POWER OF TWO - INITS

	FLOAT A
	MOVEM A,FLT	;FLOAT<NN>

.I  COSINX=ARYALS<COSINX,NN>	;COSINE TABLE
	MOVE A,(A)ARYORG
	HRLI A,U
	MOVEM A,COSPTR

.I  SININX=ARYALS<SININX,NN>	;SINE TABLE
	MOVE A,(A)ARYORG
	HRLI A,U
	MOVEM A,SINPTR

.I  BRVINX=ARYALS<BRVINX,NN>	;BIT REVERSE TABLE
	MOVE F,(A)ARYORG
	HRRZM F,BRVPTR
	MOVE G,F
	HRLI F,C
	HRLI G,E

;GENERATE BIT-REVERSE TABLE
	MOVEI B,1
OUTER:	CLEAR C,
	MOVE E,B

LOOPX:	MOVE D,F@
	ASH D,1
	MOVEM D,F@
	AOS D
	MOVEM D,G@
	AOS E
	AOS C
	CAMGE C,B
	JRST LOOPX

	ASH B,1
	CAMGE B,NN
	JRST OUTER

;GENERATE COS AND SIN TABLES (NEED ONLY 0-PI)
.F TPN=TWPI/FLT

	SETZM U

	MOVE D,NN
	ASH D,-2	;NN/4
	AOS D	;NN/4 +1
	MOVEI C,0

;DO FIRST QUADRANT
QUAD1:
	MOVE A,C
	PUSHJ P,COS
	MOVEM A,@COSPTR
	MOVE A,C
	PUSHJ P,SIN
	MOVEM A,@SINPTR
	FAD C,TPN
	AOS U
	SOJG D,QUAD1

	MOVE D,NN
	ASH D,-2	;NN/4
	HRRZ B,COSPTR
	HRRZ C,SINPTR
QUAD2:	AOS B
	AOS C
	MOVE A,(B)
	MOVEM A,@SINPTR
	MOVE A,(C)
	MOVNM A,@COSPTR
	AOS U
	SOJG D,QUAD2

	POPJ P,

TWPI:	6.283185307
NN:	0	;NUMBER OF POINTS TO TRANSFORM
LN:	0	;LOG BASE 2 OF NN
FLT:	8.0
TPN:	0
COSINX:	-1	;INDEX FOR COSINE ARRAY
SININX:	-1	;INDEX FOR SINE ARRAY
BRVINX:	-1	;INDEX FOR BIT REVERSE TABLE
SINPTR:	0
COSPTR:	0
BRVPTR:	0
;FFT TO TRANSFORM A ONE-DIMENSIONAL COMPLEX VECTOR
;NUMBER OF POINTS MUST BE A POWER OF TWO
;COSPTR:	(U)COSTBL
;SINPTR:	(U)SINTBL
;XPRT2:	(T)REAL PART OF INPUT
;XPRT3:	(T)IMAGINARY PART
;XPRT4:	(V)REAL PART
;XPRT5:	(V)IMAGINARY PART
;BRVPTR:	BIT REVERSE TABLE
;	A=ADDRESS OF REAL PART
;	B=ADDRESS OF IMAGINARY PART
;DATA IS ASSUMED TO BE UN-BIT REVERSED (IE REVBS IS CALLED)

TRANS:	HRLI A,T
	MOVEM A,XPRT2
	HRLI A,V
	MOVEM A,XPRT4
	HRLI B,T
	MOVEM B,XPRT3
	HRLI B,V
	MOVEM B,XPRT5

	MOVE A,COSINX	;IN CASE THE ARRAYS WERE REALLOCATED
	MOVE A,ARYORG(A)
	HRLI A,U
	MOVEM A,COSPTR
	MOVE B,SININX
	HRR A,ARYORG(B)
	MOVEM A,SINPTR
	MOVE A,BRVINX
	MOVE A,ARYORG(A)
	MOVEM A,BRVPTR

	PUSHJ P,REVBS	;BIT REVERSE INPUT DATA

.I  CYCLES=1
.I  FPERC=NN/2
.I  ICS=2
	MOVE W,LN	;LOG NN
TRANS1:	PUSHJ P,RANK	;DO A RANK OF FFT
	MOVE C,CYCLES
	ASH C,1
	MOVEM C,CYCLES	;2*CYCLES
	MOVE C,ICS
	ASH C,1
	MOVEM C,ICS	;2*ICS
	MOVE C,FPERC
	ASH C,-1
	MOVEM C,FPERC	;FPERC/2
	SOJG W,TRANS1	;DO LN RANKS

	MOVE C,NN	;NORMALIZE TRANSFORM
	FLOAT C
	MOVN T,NN
	HRLZS T	;T=AOBJN PNTR
TRANS2:	MOVE A,@XPRT2
	FDVR A,C
	MOVEM A,@XPRT2
	MOVE A,@XPRT3
	FDVR A,C
	MOVEM A,@XPRT3
	AOBJN T,TRANS2

	POPJ P,
FPERC:	0
CYCLES:	0
ICS:	0
;XPRT2 POINTS TO REAL PART OF TRANSFORM
;XPRT3 POINTS TO IMAGINARY PART
;COMPUTE A RANK OF THE FFT
;	CYCLES=# OF CYCLES PER RANK
;	FPERC=# OF BUTTERFLIES PER CYCLE
;	ICS=SPACING BETWEEN SUBSEQUENT ENTRIES

RANK:	SETZM T	;TOP OF DATA
	MOVE V,CYCLES	;BOTTOM OF FIRST B'FLY
	MOVEM T,TOPSTR	;SAVE TOP
	SETZM U	;TOP OF SIN-COS
	MOVE Y,CYCLES	;COUNT CYCLES

RANK1:	MOVE X,FPERC	;COUNT B'FLIES
	MOVE A,@COSPTR	;GET COSINE
TRNSWT:	MOVE B,@SINPTR	;GET SINE(MAKE MOVN FOR INVERSE FFT)
RANK2:	PUSHJ P,BTRFLY
	ADD T,ICS	;DO NEXT
	ADD V,ICS
	SOJG X,RANK2

	ADD U,FPERC	;DO NEXT CYCLES
	MOVEI V,1
	ADDB V,TOPSTR	;START OF NEXT CYCLE
	MOVE T,V
	ADD V,CYCLES	;BOTTOM
	SOJG Y,RANK1

	POPJ P,
TOPSTR:	0
;BUTTERFLY COMPUTATION (COMPLEX)
;	A=COSINE
;	B=SINE
;	CLOBBERS C,D,E,F

BTRFLY:	MOVE C,@XPRT4
	FMPR C,A	;REAL*COSINE
	MOVE D,@XPRT5
	FMPR D,B	;IMAG*SINE
	FSBR C,D	;C=REAL PART

	MOVE D,@XPRT4
	FMPR D,B	;REAL*SINE
	MOVE E,@XPRT5
	FMPR E,A	;IMAG*COSINE
	FADR D,E	;D=IMAG PART

	MOVNM C,@XPRT4
	MOVNM D,@XPRT5

	EXCH C,@XPRT2
	EXCH D,@XPRT3

	FADRM C,@XPRT2
	FADRM D,@XPRT3	;TOP OF B'FLY

	FADRM C,@XPRT4
	FADRM D,@XPRT5	;BOTTOM OF B'FLY

	POPJ P,
;               COMPLEX VECTOR ABS VALUE
;	A=0 => NO SQUARE ROOT; A=-1 => SQUARE ROOT

ABSVS:	MOVE E,A	;A=0 => NO SQRT
	MOVE T,NN	;SAVE SQRT SWITCH
	SOS T
ABSET:	MOVE A,@XPRT2
	FMPR A,A
	MOVE B,@XPRT3
	FMPR B,B
	FADR A,B
	JUMPE E,NOSQR
	PUSHJ P,SQRT

NOSQR:	MOVEM A,XPRT2@
	SOJGE T,ABSET

	POPJ P,

;RESULT IS POINTED TO BY XPRT2

;DO COMPLETE DOUBLE FUNCTION TRANSFORM
DTRAN:	PUSHJ P,TRANS
	PUSHJ P,SEPER
	SETZM A	;NO SQUARE ROOT
	JRST ABSVS

XPRT2:	0
XPRT3:	0
XPRT4:	0
XPRT5:	0
;BIT REVERSE COMPLEX VECTOR

REVBS:	MOVE T,NN
	SOS T
	HRLI G,T
	HRR G,BRVPTR
REVB:	MOVE V,G@
	CAML V,T
	JRST CONT
	MOVE C,XPRT2@
	EXCH C,XPRT4@
	MOVEM C,XPRT2@
	MOVE C,XPRT3@
	EXCH C,XPRT5@
	MOVEM C,XPRT3@
CONT:	SOJGE T,REVB

	POPJ P,


;SEPARATE TRANSFORMS OF TWO REAL FUNCTIONS
;  THAT WERE TRANSFORMED AS A SINGLE COMPLEX FUNCTION
;SINCE DFT OF A REAL FUNCTION IS SYMMETRIC ABOUT
;  N/2, ONLY N/2 POINTS OF EACH TRANSFORM ARE RETAINED
;REAL PARTS ARE POINTED TO BY XPRT2, IMAGNARY BY PRT3
;  FIRST N/2 POINTS ARE FIRST FUNCTION, SECOND N/2
;  POINTS ARE SECOND FUNCTION

SEPER:	MOVE T,NN
	ASH T,-1
	MOVE V,T
	SOS T
SSPRS:	AOS V
	MOVE F,XPRT2@
	MOVE G,XPRT4@
	FAD F,G
	FSB G,XPRT2@
	FSC F,-1
	FSC G,-1

	MOVE E,XPRT3@
	MOVE C,XPRT5@
	FAD C,E
	FSB E,XPRT5@
	FSC C,-1
	FSC E,-1

	MOVEM F,XPRT2@	;(XR(I)+XR(N-I))/2 => XR(I)
	SOS V
	MOVEM G,XPRT5@	;(-XR(I)+XR(N-I))/2 => XI(N-I-1)
	MOVEM C,XPRT4@	;(XI(I)+XI(N-I))/2 => XR(N-I-1)
	AOS V
	MOVEM E,XPRT3@	;(XI(I)-XI(N-I))/2 => XI(I)

	SOJG T,SSPRS

	CLEARM XPRT5@	;XI(N-1)=0
	MOVE C,XPRT3@
	MOVEM C,XPRT4@	;XR(N-1)=XI(0)
	CLEARM XPRT3@	;XI(0)=0

	POPJ P,
;XPRT2 POINTS TO ONE PART, XPRT3 POINTS TO THE OTHER
;ROUTINE TO ERASE ARRAYS CREATED BY FFT
FFTKIL:
.I  ARYDEL<COSINX>
.I  ARYDEL<SININX>
.I  ARYDEL<BRVINX>
	SETOM COSINX
	SETOM SININX
	SETOM BRVINX
	POPJ P,

] 

CONSTANTS
VARIABLES

Q==PUSHJ P,
R==POPJ P,
M==MOVE
MI==MOVEI
MM==MOVEM
J==JRST
SZ==SETZM
SO==SETOM
SG==SOJGE
AB==AOBJN
