;;; -*-LISP-*-

(declare (load '|eak;lmacs|))
(include |eak;sincl >|)

(defun distances (x)
    (declare (flonum x d))
    (let ((output-file (open "eak;dists bin" '(out fixnum)))
	  (d .0))
	 (do i 0 (1+ i) (= i nstar)
	     (do j (1+ i) (1+ j) (or (= j nstar)
				     (> (-$ (phi j) (phi i)) x))
		 (setq d (distance (theta i) (phi i) (theta j) (phi j)))
		 (cond ((not (> d x))
			(out output-file (lsh d 0))
			(out output-file i)
			(out output-file j) ))))
	 (close output-file) ))


(defun ddump ()
    (let ((output-file (open "eak;dists bin" '(out fixnum))))
	 (do i 0 (1+ i) (= i ndist)
	     (out output-file (lsh (distd i) 0))
	     (out output-file (disti i))
	     (out output-file (distj i)) )
	 (close output-file) ))

(defun dload ()
    (let ((input-file (open "eak;dists bin" '(in fixnum))))
	 (setq ndist (// (lengthf input-file) 3))
	 (*array 'distd 'flonum ndist)
	 (*array 'disti 'fixnum ndist)
	 (*array 'distj 'fixnum ndist)
	 (do i 0 (1+ i) (= i ndist)
	     (store (distd i) (fsc (in input-file) 0))
	     (store (disti i) (in input-file))
	     (store (distj i) (in input-file)) )
	 (close input-file) ))


(defun dfind (x)
    (do ((l 0)
	 (u (1- ndist))
	 (i (// ndist 2) (// (+ l u) 2)))
	((< u l) l)
	(cond ((< x (distd i))
	       (setq u (1- i)))
	      ((> x (distd i))
	       (setq l (1+ i)))
	      (t (return i)) )))


(defun neighbors (i x)
       (do ((j 0 (1+ j))
	    (d)
	    (n 0))
	   ((= j nstar) n)
	   (setq d (distance (theta i) (phi i) (theta j) (phi j)))
	   (cond ((> d x))
		 (t (print (list j d)))) ))


(defun where (a b c theta1 phi1 theta2 phi2)
       (prog (s1 k1 s2 k2 AA AB AD AE phi1c phi2c na1 na2 theta phi)
	     (setq phi1c (-$ pi2 phi1))
	     (setq phi2c (-$ pi2 phi2))
	     (setq s1 (*$ (+$ a b c) .5))
	     (setq k1 (sqrt (//$ (*$ (sin (-$ s1 a))
				     (sin (-$ s1 b))
				     (sin (-$ s1 c)))
				 (sin s1))))
	     (setq AA (*$ 2.0 (atan k1 (sin (-$ s1 a)))))
;	     (setq AB (*$ 2.0 (atan k1 (sin (-$ s1 b)))))
	     (setq s2 (*$ (+$ phi1c phi2c c) .5))
	     (setq k2 (sqrt (//$ (*$ (sin (-$ s2 phi1c))
				     (sin (-$ s2 phi2c))
				     (sin (-$ s2 c)))
				 (sin s2))))
;	     (setq AD (*$ 2.0 (atan k2 (sin (-$ s2 phi1c)))))
	     (setq AE (*$ 2.0 (atan k2 (sin (-$ s2 phi2c)))))
	     (print AA) (print AE)
	     (setq na1 (atan (cos (*$ (-$ phi1c b) .5))
			     (*$ (cos (*$ (+$ phi1c b) .5))
				 (tan (*$ (+$ AE AA) .5)))))
	     (setq na2 (atan (sin (*$ (-$ phi1c b) .5))
			     (*$ (sin (*$ (+$ phi1c b) .5))
				 (tan (*$ (+$ AE AA) .5)))))
	     (setq theta (-$ theta1 (-$ na1 na2)))
	     (setq phi (-$ (asin (//$ (*$ (sin b) (sin (+$ AE AA)))
				      (sin (-$ na1 na2))))
			   pi2))
	     (return (list theta phi))))

; Change coordinates, given three attitude parameters a, b, c
; new origin 0,0 will be at RA = a, DEC = b, and rotated c about view

(defun spinnify (a b c) 
       (prog (tmp)
	     (do i 0. (1+ i) (= i nstar)
		 (setq tmp (spin (theta i) (phi i) a b c))
		 (store (theta i) (car tmp))
		 (store (phi i) (cadr tmp)))))

(defun spin (the0 phi0 a b c)
       (prog (sinb cosb sinc cosc the1 phi1 the2 phi2 sint cost sinp cosp)
	     (setq sinb (sin b) 
		   cosb (cos b) 
		   sinc (sin c) 
		   cosc (cos c))
	     (setq the1 (modtpi (-$ the0 a))
		   phi1 phi0)
	     (setq sint (sin the1) 
		   cost (cos the1) 
		   sinp (sin phi1) 
		   cosp (cos phi1))
	     (setq the2 (atan (*$ sint cosp)
			      (+$ (*$ sinb sinp)
				  (*$ cosb cost cosp))) 
		   phi2 (asin (-$ (*$ cosb sinp)
				  (*$ sinb cosp cost))))
	     (setq sint (sin the2) 
		   cost (cos the2) 
		   sinp (sin phi2) 
		   cosp (cos phi2))
	     (return (list (atan (+$ (*$ cosc sint cosp)
				     (*$ sinc sinp))
				 (*$ cost cosp))
			   (asin (-$ (*$ cosc sinp)
				     (*$ sinc sint cosp)))))))

(defun image-list () 
    (declare (flonum thed phid limt limp))
    (prog (thed phid limt limp l)
    (setq limt (atan (float image-radius) focal-length)
	  limp (atan (float image-radius) focal-length))
    (setq l nil)
    (do i 0 (1+ i) (= i nstar)
	(setq thed (theta i) phid (phi i))
	(cond ((> (abs phid) limp))
	      ((> (min (-$ tpi thed) thed) limt))
	      (t (push (list (- (round (*$ focal-length (tan thed))))
			     (round (*$ focal-length
					(//$ (tan phid) (cos thed))))
			     (maghgh i)
			     i)
		       l)) ))
    (return l)))


; Put up image, given field size -- optical axis points at 0,0

(defun picture () 
    (clear)
    (let ((p1 (- 575 image-radius))
	  (p2 (- 453 image-radius)))
	 (do l (image-list) (cdr l) (null l)
	     (make-spot (+ p1 (caar l))
			(+ p2 (cadar l))
			(caddar l)) )
	 (circle p1 p2 image-radius)
	 (setq p1 (- 575 image-radius image-radius)
	       p2 (- 453 image-radius image-radius))
	 (line p1 p2 p1 453)
	 (line p1 453 575 453)
	 (line 575 453 575 p2)
	 (line 575 p2 p1 p2)
	 (question) ))


; Calculate distance between two stars given image coordinates

(defun separation (x1 y1 x2 y2)
    (acos (//$ (+$ (float (* x1 x2))
		   (float (* y1 y2))
		   (*$ focal-length focal-length))
	       (sqrt (*$ (+$ (float (* x1 x1))
			     (float (* y1 y1))
			     (*$ focal-length focal-length))
			 (+$ (float (* x2 x2))
			     (float (* y2 y2))
			     (*$ focal-length focal-length)))))))


; Make spot on screen whose size depends on magnitude

(defun make-spot (i j m) 
       (cond ((< m 4.8) (point i j)))
       (cond ((< m 4.5) (point (1+ i) j)))
       (cond ((< m 4.2) (point i (1+ j))))
       (cond ((< m 3.9) (point (1- i) j)))
       (cond ((< m 3.6) (point i (1- j))))
       (cond ((< m 3.3) (point (1+ i) (1- j))))
       (cond ((< m 3.0) (point (1+ i) (1+ j))))
       (cond ((< m 2.7) (point (1- i) (1+ j))))
       (cond ((< m 2.4) (point (1- i) (1- j))))
       (cond ((< m 2.1) (point (+ i 2.) j)))
       (cond ((< m 1.8) (point i (+ j 2.))))
       (cond ((< m 1.5) (point (- i 2.) j)))
       (cond ((< m 1.2) (point i (- j 2.))))
       (cond ((< m 0.9) (point (+ i 2.) (1+ j))))
       (cond ((< m 0.6) (point (1- i) (+ j 2.))))
       (cond ((< m 0.3) (point (- i 2.) (1- j))))
       (cond ((< m 0.0) (point (1+ i) (- j 2.))))
       (cond ((< m -0.3) (point (+ i 2.) (1- j))))
       (cond ((< m -0.6) (point (1+ i) (+ j 2.))))
       (cond ((< m -0.9) (point (- i 2.) (1+ j))))
       (cond ((< m -1.2) (point (1- i) (- j 2.))))) 


(defun where-am-i? ()
    (prog ()
    (setq l (image-list))
    (cond ((< (length l) 3) (terpri) (princ "You're lost") (return nil)))
    (setq l (sort l (function (lambda (x y)
				      (< (caddr x) (caddr y))))))
    (setq s1 (car l)
	  s2 (cadr l)
	  s3 (caddr l) )
    (setq x1 (car s1) y1 (cadr s1) m1 (caddr s1)
	  x2 (car s2) y2 (cadr s2) m2 (caddr s2)
	  x3 (car s3) y3 (cadr s3) m3 (caddr s3) )
    (setq x (cond ((< x1 x2) 1)
		  ((> x1 x2) -1)
		  (t 0))
	  y (cond ((< y1 y2) 1)
		  ((> y1 y2) -1)
		  (t 0)) )
    (setq dmin (separation (+ x1 x) (+ y1 y) (- x2 x) (- y2 y))
	  dmax (separation (- x1 x) (- y1 y) (+ x2 x) (+ y2 y)) )
    (setq a (dfind dmin)
	  b (dfind dmax) )
    (setq l1 nil)
    (do i a (1+ i) (= i b)
	(cond ((and (= (maghgh (disti i)) m1)
		    (= (maghgh (distj i)) m2))
	       (push (list (disti i) (distj i)) l1) )
	      ((and (= (maghgh (distj i)) m1)
		    (= (maghgh (disti i)) m2))
	       (push (list (distj i) (disti i)) l1) )))
    (setq l1 (sortcar l1 (function <)))
    (setq x (cond ((< x1 x3) 1)
		  ((> x1 x3) -1)
		  (t 0))
	  y (cond ((< y1 y3) 1)
		  ((> y1 y3) -1)
		  (t 0)) )
    (setq dmin (separation (+ x1 x) (+ y1 y) (- x3 x) (- y3 y))
	  dmax (separation (- x1 x) (- y1 y) (+ x3 x) (+ y3 y)) )
    (setq a (dfind dmin)
	  b (dfind dmax) )
    (setq l2 nil)
    (do i a (1+ i) (= i b)
	(cond ((and (= (maghgh (disti i)) m1)
		    (= (maghgh (distj i)) m3))
	       (push (list (disti i) (distj i)) l2) )
	      ((and (= (maghgh (distj i)) m1)
		    (= (maghgh (disti i)) m3))
	       (push (list (distj i) (disti i)) l2) )
	      ))
a   (cond ((or (null l1) (null l2)) (return nil))
	  ((< (caar l1) (caar l2))
	   (setq l1 (cdr l1)))
	  ((> (caar l1) (caar l2))
	   (setq l2 (cdr l2)))
	  (t (print (car l1))
	     (setq a (caar l1) b (cadar l1))
	     (print a) (print b)
	     (setq p (where (separation 0 0 x2 y2)
			    (separation 0 0 x1 y1)
			    (separation x1 y1 x2 y2)
			    (theta a) (phi a) (theta b) (phi b)))
	     (print p)
	     (setq l1 (cdr l1)
		   l2 (cdr l2))))
    (go a)
    ))
