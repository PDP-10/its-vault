EPSDIS:	0

VLINA0:	SETZM EPSDIS
	.DSTOP
	SKIPA
VLINA:	SETOM EPSDIS
	PUSHJ P,TIME
.I RUNTI2=,RELTI2=,RUNDI3=RELDI3=0
.I LINFLN=VRTFLN=0
.I SWIPE<#MULTIR,#MULTRL>
	PUSHJ P,SETPP	;SETUP PARAMETERS

	HEAD SEGMENTING
	SKIPE EPSDIS
	PUSHJ P,EPTSUM	;DISPLAY EDGES LEFT INTACT			$$$
	PUSHJ P,REFREL	;GC LINES
	PUSHJ P,REFREV	;REFRESH VERTICES, CAUSE THEIR PLACE IS USED
.I VSMAP<#SEGMEN>	;SEGMENTATION, LINE FIT, DISPLAY BREAKS		$$$
	PUSHJ P,TDISGO
			; - EDGE CHAIN DATA NOT USED LATER
	SKIPE GCTEDG
	PUSHJ P,GCEDGS	;CAN GCEDGS HERE - DONT IF WISH TO RESTART AT VLINA
	HEAD FLUSH SHORT 1
.I DOITR<#FLSSHA>
	PUSHJ P,UNMARK	;IN CASE

VLINA1:	HEAD COMBINING LINES
.I DOITR<#VLINSA>

			; - LINE FIT DATA NOT USED LATER
VLINB:	HEAD FLUSH SHORT 2
.I DOITR<#FLSSHB>

	HEAD VERTEX FINDING
.I DOITR<#TVRTEX>

	PUSHJ P,CLNUP	;FLUSH EQUAL LINES (AND INACTIVE ONES)
	PUSHJ P,DETERG
	SETZM NKJN	;# OF K-JOINTS
VLINB0:	HEAD K-JOINTING
.I DOITR<#KJOHN>

	PUSHJ P,CLNUP	;FLUSH EQUAL LINES (AND INACTIVE ONES)
	PUSHJ P,DETERG
	SETZM NTJN	;# OF T-JOINTS
VLINB1:	HEAD T-JOINTING
.I DOITR<#TJOING>

	PUSHJ P,CLNUP	;FLUSH EQUAL LINES (AND INACTIVE ONES)
	PUSHJ P,DETERG
	SETZM NXJN	;# OF X-JOINTS
VLINC1:	HEAD X-JOINTING
.I DOITR<#XJOINS>

VLINC2:	HEAD EXTENDING
.I DOITR<#EXTEND>

	PUSHJ P,CLNUP	;FLUSH EQUAL LINES (AND INACTIVE ONES)
VLINC3:	HEAD FLUSH UNATTACHED
.I DOITR<#FLSNON>

	PUSHJ P,DETERG
VLINC4:	HEAD L-STRAIGHTENING
.I DOITR<#STRAIG>

	PUSHJ P,DETERG
VLINC5:	HEAD VERTEX COMBINING
.I DOITR<#GLUMV>

	PUSHJ P,CLNUP	;FLUSH EQUAL LINES (AND INACTIVE ONES)
	PUSHJ P,DETERG

	PUSHJ P,QKVRTX	;REGEN VERTICES IN CASE WE BIT THE BAG

	HEAD EASY PLOT
	PUSHJ P,ESYPLT

	HEAD FINAL VERSION
	PUSHJ P,WAITP
	PUSHJ P,SEGDIS

	SKIPE ASKFLS
	PUSHJ P,VLIND0

	PUSHJ P,TIME
.I RUNTI5=,RELTI5=
.I (RUNTI5-RUNTI2-RUNDI3)/1000.,(RELTI5-RELTI2-RELDI3)/1000.,RUNDI3/1000.,RELDI3/1000.
	PRINT _COMPUTE #1 SEC IN #2 SEC
	JRST GCMULT

	PRINT _DISPLAY #3 SEC IN #4 SEC_
	JRST GCMULT

;VLINA IS A GOOD PLACE TO RESTART WITHOUT RESCANNING
;VLINB IS A GOOD PLACE TO START AFTER READING IN LINES

ASKFLS:	-1	;-1 TO ASK IF WANT TO FLUSH UNATTACHED LINES

VLIND0:	PRINT _FLUSH ? 
	PUSHJ P,TYI
	CAIGE A,40
	JRST .-2	;FLUSH CONTROL CHARACTERS
	CAIE A,"Y
	POPJ P,
VLIND:	PUSHJ P,FLSNUN	;FLUSH UNATTACHED LINES
	PUSHJ P,STRAIG
	PUSHJ P,CLNUP
	PUSHJ P,DETERG
	PUSHJ P,ESYPLT
	JRST SEGDIS

CLARIFY:	PUSHJ P,KJOHN
	PUSHJ P,TJOING
	PUSHJ P,XJOINS
	PUSHJ P,STRAIG
	PUSHJ P,GLUMV
	PUSHJ P,STRAIG
	PUSHJ P,CLNUP
	JRST SEGDIS
GCLLST:	0	;LISTS TO BE GC LATER
GLMFLL:	0	
GLMFLG:	0	;TELLS WHETHER ANY EDGES HAVE BEEN COMBINED THIS TIME ROUND

VLINCA:	0	;PTR TO CURRENT LINE OUTER MAPC
VLINCB:	0	;PTR TO CURRENT LINE INNER MAPC
VLINCC:	0	;VERTEX CURRENTLY BEING HACKED

INTVAL:	600.0	;INTERVAL USED IN MULTI-ENTRY FOR REDUNDANCY
INTBRD:	600.0	;MAX GAP BRIDGED IN COLINEAR LINES
INTFL1:	200.0	;FLUSHED LINE LENGTH
INTFL2:	400.0	;FLUSHED LINE LENGTH
INTVET:	500.0	;EPSILON FOR GLUMMING OF POINTS INTO VERTICES
INTKJN:	400.0	;K-JOINTING INTERVAL
INTTJN:	600.0	;T-JOINTING INTERVAL
INTXJN:	400.0	;X-JOINING INTERVAL
INTESY:	400.0	;INTERVAL FOR QKVRTX
INTSTR:	200.0	;STRAIGHTENING INTERVAL
INTGLM:	200.0	;INTERVAL FOR FINAL GLUMMING OF VERTICES

INTEND:	300.0	;DISTANCE TO ENDPOINTS ALLOWED IN T- AND K-JOINTING
INTCOS:	200.0	;MAX SIDEWAYS IN VERTEXING
INTCRS:	200.0	;MAX SIDEWAYS IN REDUNDANCY REDUCTION FOR OVERLAPS
INTBRS:	150.0	;MAX SIDEWAYS IN CASE OF BRIDGING
INTEXT:	200.0	;MAX SIDEWAYS IN EXTEND
INTCAL:	200.0	;MAX PERMISSIBLE RMS IN REDUNDANCY REDUCTION

INTERV:	500.0	;SMALLEST REASONABLE INTERVAL FOR MULTY-ENTRY
MAXCEL:	20.	;MAXIMUM NUMBER OF CELLS DESIRED IN MUTLI-ENTRY CODING

PARALL:	0.25	;15 DEGREES
COLINE:	10.0	;MAX ACCEPTABLE RATIO OF RMSES
EXTRT:	0.25	;MAX EXTENSION IN T-JOINTS FOR UNATTACHED LINES
	0.5	;FOR ATTACHED LINES
EXTENS:	0.5	;MAX EXTENSION IN EXTEND FOR UNATTACHED LINES
	1.0	;SAME FOR ATTACHED LINES
VETENS:	0.5	;BACKWARD VERTEXING FACTOR

NSEGL:	1.4	;SEGMENTATION LIMIT 

NTVAL:	7.0
NTBRD:	3.5
NTFL1:	3.0
NTFL2:	4.0
NTVET:	5.5
NTKJN:	3.0
NTTJN:	7.0
NTXJN:	3.0
NTESY:	1.0
NTSTR:	2.5
NTGLM:	2.5

NTEND:	2.0
NTCOS:	2.0
NTCRS:	2.0
NTBRS:	1.5
NTEXT:	2.0
NTCAL:	2.0

EPSFAC:	1.25	;EPSILON FACTOR

SETPP:		;SET UP PARAMETERS USED IN 'UN-SH.TTING' THE BRICKS !	
.F LNST=FFLOAT<TVD(1)>*EPSFAC
.F SEGLIM=LNST*NSEGL
.F INTVAL=LNST*NTVAL,INTBRD=LNST*NTBRD,INTVET=LNST*NTVET,INTFL1=LNST*NTFL1
.F INTFL2=LNST*NTFL2,INTSTR=LNST*NTSTR,INTGLM=LNST*NTGLM
.F INTKJN=LNST*NTKJN,INTTJN=LNST*NTTJN,INTXJN=LNST*NTXJN,INTESY=LNST*NTESY
.F INTEND=LNST*NTEND,INTCRS=LNST*NTCRS,INTBRS=LNST*NTBRS
.F INTCAL=LNST*NTCAL,INTCOS=LNST*NTCOS,INTEXT=LNST*NTEXT
SETOP:
.I TVL(0)-EXTRA,TVL(1)-EXTRA,TVU(0)+EXTRA,TVU(1)+EXTRA
	FLOAT A
	FLOAT B
	FLOAT C
	FLOAT D
.F FTVL(0)=,FTVL(1)=,FTVU(0)=,FTVU(1)=
.F INTERV=MAX<FTVU(0)-FTVL(0),FTVU(1)-FTVL(1)>/FFLOAT<MAXCEL>
	POPJ P,

MASSET:	CAMGE A,INTERV	;MAX OF GIVEN SIZE AND INTERV
	MOVE A,INTERV
	MOVE B,A
.F MULTIQ(0)=MULTIQ(1)=/B
.I FTVL(0),FTVL(1),FTVU(0),FTVU(1)
	JRST MULTIZ	;INITIALISE MULTI-ENTRY

FTVL:	0
	0

FTVU:	0
	0

LNST:	0	;'DISTANCE BETWEEN SCAN LINES'
LINFLN:	0	;NUMBER OF LINES KILLED BUT NOT YET VAPOURISED
VRTFLN:	0	;NUMBER OF VERTICES KILLED BUT NOT YET VAPOURISED
CHKFLG:	0	;-1 TO CHECK VERTICES FREQUENTLY

DETERG:	SKIPN LINFLN	;SEE IF DATA BASES NEED CLEANING UP
	SKIPE VRTFLN
	SKIPA		;YES - CALL APPROPRIATE SCAVENGING ROUTINES
	POPJ P,
	SKIPE LINFLN
	PUSHJ P,CLNLIN
	SKIPE VRTFLN
	PUSHJ P,CLNVRT
	JRST DETERG

DOITR:	PUSH P,A	;DO IT ITERATIVELY
DOITR1:	PUSHJ P,WAITP
	PUSHJ P,SEGDAS
	SETZM GLMFLG
	PUSHJ P,@(P)
	PUSHJ P,TDISGO
	SKIPE GLMFLG
	JRST DOITR1
	POP P,A
	SKIPN CHKFLG
	POPJ P,
	PUSHJ P,WAITP
	JRST VRTCHK	;CHECK VERTICES

ENTLIN:	PUSHJ P,MASSET	;ENTER ALL LINES
	SETZM NLIN
.I MULTVF=#MULTIS	;SET FUNCTION CALLED AT EACH STEP TO STORE AWAY
.I VMAP<#VLINEB,LINES>	;MAP ALONG ALL EDGES
	POPJ P,

VLINEB:	SKIPG A
	.VALUE
	SKIPE LFTDA(A)	;ENTER ALL LINES AND INTERPOLATED POINTS
	POPJ P,
	AOS NLIN	;? CHECK IF ALL USES OF THIS FUNCTION REALLY WANT THIS ?
VISTAB:
.F ,LFTX1(A),LFTY1(A),LFTX2(A),LFTY2(A)
	JRST MULTIV


ENTVRT:	PUSHJ P,MASSET	;ENTER ALL END-POINTS OF LINES
	SETZM NLIN
.I VMAP<#TVRTX1,LINES>	;STORE ALL 'VERTICES'
	POPJ P,

TVRTX1:	SKIPG A
	.VALUE
	SKIPE LFTDA(A)
	POPJ P,
	AOS NLIN
	MOVEM A,VLINCA
.F ,LFTX1(A),LFTY1(A)	;FIRST END INSERT
	PUSHJ P,MULTIS
	MOVE A,VLINCA
.F ,LFTX2(A),LFTY2(A)	;SECOND END INSERT (NEGATIVE)
	MOVNS A
	JRST MULTIS

REVLIN:		;REVERSE A LIST OF LINES
.I REVRS<#LINES>
	POPJ P,

RVREDG:	SKIPLE A
	SKIPE LFTDA(A)		;REVERSE EDGE
	.VALUE
	PUSHJ P,VRWHT	;FIX UP VERTEX INFORMATION
.F ,LFTX1(A),LFTY1(A),LFTLL(A)
	EXCH B,LFTX2(A)
	EXCH C,LFTY2(A)
	EXCH D,LFTRR(A)
.F ,LFTX1(A)=,LFTY1(A)=,LFTLL(A)=
	POPJ P,

VRWHT:	PUSH P,A
	MOVE B,A
	MOVN C,A
	SKIPN A,LFTLL(A)
	JRST VRWHT1
.I REPLAC<VTR(A)>
	.VALUE		;VERTEX DOESNT AGREE ITS CONNECTED TO THIS LINE
VRWHT1:	MOVE A,(P)
	MOVN B,A
	MOVE C,A
	SKIPN A,LFTRR(A)
	JRST POPAJ
.I REPLAC<VTR(A)>
	.VALUE		;VERTEX DOESNT AGREE ITS CONNECTED TO THIS LINE
	JRST POPAJ

ENTVEX:	PUSHJ P,MASSET	;ENTER ALL VERTICES
	SETZM NVRT
.I VMAP<#VLINEQ,VERTEX>
	POPJ P,

VLINEQ:	SKIPG A
	.VALUE
	SKIPG NSM(A)
	POPJ P,
	AOS NVRT
.F ,XSM(A),YSM(A)
	JRST MULTIS

ANGCOM:
.F ,,\(LFTSA(A)*LFTCA(B)-LFTCA(A)*LFTSA(B))	;ABS OF SIN OF DIFFERENCE IN ANGLES
	POPJ P,

ACLMLT:	MOVEM B,GCLLST	;MAP ALONG LIST IN B, THEN GC IT
	PUSHJ P,VMAP
.I GCL<GCLLST>
	SETZM GCLLST
	POPJ P,

COMBIN:	MOVE T,A	;COMBINE VERTEX A AND VERTEX B, FLUSH LATTER (IE USE X AND Y OF FIRST)
	MOVE U,B
	SKIPG NSM(U)
	POPJ P,		;NOTHING ON SECOND VERTEX
	SKIPG NSM(T)
	.VALUE		;FIRST ONE A LOSER
	MOVE X,XSM(T)
	MOVE Y,YSM(T)
.I VMAP<#COMBI4,VTR(T)>	;ALTER LINES ATTACHED TO FIRST VERTEX
	EXCH T,U
.I VMAP<#COMBI4,VTR(T)>	;ALTER LINES ATTACHED TO SECOND VERTEX
	EXCH T,U
.I NSM(T)=NSM(T)+NSM(U)
.I VMAP<#COMBXI,VTR(U)>
	MOVEI A,VTR(T)
	MOVEI B,VTR(U)
	PUSHJ P,APPEND
	SETZM NSM(U)
	AOS VRTFLN
	POPJ P,

COMBXI:	SKIPLE A
	MOVEM T,LFTLL(A)
	MOVNS A
	SKIPLE A
	MOVEM T,LFTRR(A)
	POPJ P,

COMBI4:	SKIPG A
	JRST COMBI5
	SKIPE LFTDA(A)
	.VALUE		;VERTEX POINTS TO INACTIVE LINE
	CAME T,LFTLL(A)
	.VALUE		;LINE CLAIMS IT ISNT ATTACHED TO THIS VERTEX
	MOVEM X,LFTX1(A)	;MUNG X1
	MOVEM Y,LFTY1(A)	;MUNG Y1
	JRST ANGET1

COMBI5:	MOVNS A
	SKIPE LFTDA(A)
	.VALUE		;VERTEX POINTS TO INACTIVE LINE
	CAME T,LFTRR(A)
	.VALUE		;LINE CLAIMS IT ISNT ATTACHED TO THIS VERTEX
	MOVEM X,LFTX2(A)	;MUNG X2
	MOVEM Y,LFTY2(A)	;MUNG Y2
	JRST ANGET1


;FUNCTION FOR REMOVING CRUFT FROM THE TWO DATA BASES

FLSED:	0	;HOW MANY LOST
FLSLST:	0	;PLACE TO HANG LOSERS
FLSPRD:	0	;PREDICATE APPLIED TO EACH ELEMENT IN LIST (SKIPS IF TO BE RETAINED)
FLSFIX:	0	;ERASING THEOREM

FLUSHX:	SETZM FLSLST	;PREDICATE, LIST (IMMEDIATE),FIXING FUNCTION
	SETZM FLSED
.I FLSPRD=,,FLSFIX=
	SKIPN C,B	;FLUSH ELEMENT IF PREDICATE DOES NOT SKIP
	JRST FLUSH3
FLUSH1:	HRRZ B,(C)
	JUMPE B,FLUSH3
	HLRE A,(B)
	JUMPE A,FLUSH4
	PUSH P,C
	PUSHJ P,@FLSPRD	;APPLY PREDICATE
	JRST FLUSH2	;LOST
	POP P,C
FLUSH4:	HRRZ C,(C)
	JRST FLUSH1

FLUSH2:	SKIPE FLSFIX
	PUSHJ P,@FLSFIX	;ITEM IN A (WE HOPE)
	POP P,C
	HRRZ B,(C)
	HRRZ A,(B)	;WHAT WORD POINTS TO
	HRRM A,(C)	;WHAT POINTED TO IT - REMOVE FROM LIST

	HRRZ A,FLSLST
	HRRM A,(B)
	HRRZM B,FLSLST	;PUT BACK ON LIST OF FREE BLOCKS

	AOS FLSED
	JRST FLUSH1

FLUSH3:	MOVE A,FLSLST
	POPJ P,

UNMARK:	SETZM NLIN
.I VMAP<#UNMRLL,LINES>
	POPJ P,

UNMRLL:	AOS NLIN
	SETZM LFTDA(A)
	SETZM LFTLL(A)	;RESET MARKERS FOR VLINSA AND TVERTEX
	SETZM LFTRR(A)
	POPJ P,

UNMAK:	SETZM NLIN	
.I VMAP<#UNMAK1,LINES>
	POPJ P,

UNMAK1:	AOS NLIN
	SETZM LFTDA(A)	;RESET LFTDA FOR ESYPLT
	POPJ P,

FLUSHR:			;FLUSH LINES
.I FLUSHX<,#LINES,#FIXLIN>
.I APPEND<#VLFREE,#FLSLST>
	SETZM FLSLST
.I NLIN=NLIN-FLSED
	SETZM LINFLN
	POPJ P,

CLNLIN:			;FLUSH ALL INACTIVE LINES
.I FLUSHR<#USUPL>
	POPJ P,

USUPL:	SKIPN LFTDA(A)	;FLUSH INACTIVE LINES
	AOS (P)
	POPJ P,


FIXLIN:	MOVEM A,FIXLUN
	PUSH P,A	;FIX WORLD WHEN FLUSHING A LINE
	SKIPG B,LFTLL(A)
	JRST FIXLI1
	SETZM LFTLL(A)
	PUSHJ P,FIXLI2
	MOVE A,FIXLUN
FIXLI1:	SKIPG B,LFTRR(A)
	JRST POPAJ
	SETZM LFTRR(A)
	MOVNS A
	PUSHJ P,FIXLI2
	JRST POPAJ

FIXLI2:	SOSGE NSM(B)
	POPJ P,		;VERTEX ALREADY GONE
	SKIPN NSM(B)
	AOS VRTFLN	;INDICATE WE CREATED A DEAD VERTEX
	MOVEI B,VTR(B)
	SKIPN (B)
	POPJ P,		;VERTEX ALREADY GC'ED
	EXCH A,B
	PUSHJ P,REMOVE	;REMOVE LINE FROM VERTEX
	.VALUE		;DIDN'T FIND IT
	POPJ P,

FIXLUN:	0		;LINE BEING 'FIXED'

FLUSHV:			;FLUSH VERTICES
.I FLUSHX<,#VERTEX,#FIXVRT>
.I APPEND<#VXFREE,#FLSLST>
	SETZM FLSLST
.I NVRT=NVRT-FLSED
	SETZM VRTFLN
	POPJ P,

CLNVRT:			;FLUSH ALL INACTIVE VERTICES
.I FLUSHV<#USUPV>
	POPJ P,

USUPV:	SKIPLE NSM(A)	;FLUSH INACTIVE VERTICES
	AOS (P)
	POPJ P,


FIXVRT:	MOVEM A,FIXVEX
	SKIPG NSM(A)	;FIX WORLD WHEN FLUSHING A VERTEX
	POPJ P,		;VERTEX ALREADY DEAD
	PUSH P,A	;VERTEX MAY STILL BE ATTACHED TO SOME LINES !
.I VMAP<#FIXVR1,VTR(A)>
	MOVE A,FIXVEX
.I GCL<VTR(A)>
	POP P,A
	SETZM NSM(A)
	SETZM VTR(A)	;INDICATE LIST HAS BEEN GC'ED
	POPJ P,

FIXVR1:	SKIPG A
	JRST FIXVR2
	SKIPE LFTDA(A)	;LEFT END OF LINE
	POPJ P,		;ITS PROBABLY DEAD ALREADY
	SETOM LFTDA(A)
	AOS LINFLN
	SKIPN B,LFTLL(A)
	POPJ P,		;DOESNT POINT ANYWHERE
	CAME B,FIXVEX
	.VALUE		;LINE DOESNT AGREE ITS ATTACHED TO THIS VERTEX
	SETZM LFTLL(A)
	POPJ P,

FIXVR2:	MOVNS A
	SKIPE LFTDA(A)	;RIGHT END OF LINE
	POPJ P,		;ITS PROBABLY DEAD ALREADY
	SETOM LFTDA(A)
	AOS LINFLN
	SKIPN B,LFTRR(A)
	POPJ P,		;DOENST POINT ANYWHERE
	CAME B,FIXVEX
	.VALUE		;LINE DOESNT AGREE ITS ATTACHED TO THIS VERTEX
	SETZM LFTRR(A)
	POPJ P,

FIXVEX:	0		;VERTEX BEING 'FIXED'

		;MAY WANT TO SAVE UP FOR LATER
FLSSHB:	SKIPA A,INTFL2	;FLUSH SHORT LINES - DO BEFORE VERTEXING - PERHAPS NOT QUITE A WINNER
FLSSHA:	MOVE A,INTFL1	;FLUSH VERY SHORT LINES - DO BEFORE REDUNDANCY REDUCTION
	MOVEM A,INTFLS
FLSSHC:
.I FLUSHR<#FLSSH1>
	POPJ P,

FLSSH1:	SKIPE LFTDA(A)
	POPJ P,
	MOVE B,LFTLN(A)
	CAML B,INTFLS
	AOS (P)		;DONT FLUSH
	POPJ P,		;

INTFLS:	0		;TEMP IN FLUSHING

FLSNUN:	MOVEI A,2	;FLUSH LINES ATTACHED AT ONE END ONLY - LOSS !
	PUSHJ P,FLSNO2
	SKIPN FLSED
	POPJ P,
	JRST FLSNUN

FLSNON:	MOVEI A,1	;FLUSH LINES ATTACHED AT NEITHER END - DO AFTER VERTEXING
FLSNO2:	MOVEM A,INTFLS
.I FLUSHR<#FLSNO1>
	POPJ P,

FLSNO1:	SKIPE LFTDA(A)
	POPJ P,
	PUSHJ P,ATTACH
	CAML T,INTFLS
	AOS (P)		;DONT FLUSH IT
	POPJ P,		;


ATTACH:	SETZM T		;SEE WHERE WE ARE ATTACHED
	PUSHJ P,ATTACR

ATTACL:	SKIPGE G,LFTLL(A)
	AOS T
	JUMPLE G,TPOPJ
	MOVE G,NSM(G)
	CAIL G,2
	AOS T		;ATTACHED TO SOME OTHER LINE ON LEFT END
	POPJ P,

ATTACR:	SKIPGE G,LFTRR(A)
	AOS T
	JUMPLE G,TPOPJ
	MOVE G,NSM(G)
	CAIL G,2
	AOS T		;ATTACHED TO SOME OTHER LINE ON RIGHT END
	POPJ P,

CLNUP:		;CLEAN UP DATA - FLUSH EQUAL LINES
.I ENTVRT<INTESY>	;VERTEX AGAINST VERTEX  ***
.I VMAP<#CLNUP2,LINES>
CLNAP:		;FLUSH INACTIVE LINES AND THOSE WITH EQUAL ENDS (IE POINTS)
.I FLUSHR<#CLNUP1>
	JRST GCMULT


CLNUP2:	SKIPE LFTDA(A)
	POPJ P,
	MOVEM A,VLINCA	;SEARCH FOR EQUAL LINES
.F ,LFTX1(A),LFTY1(A)
	PUSHJ P,MULTIF
	SKIPN B,A
	POPJ P,		;WELL...
.I ACLMLT<#CLNU2A>
	POPJ P,

CLNU2A:
.I VLINCB=,VLINCA
	SKIPG A
	JRST CLNU2B
.F ,,LFTX1(A),LFTY1(A),LFTX2(A),LFTY2(A)
CLNU2C:	SKIPE LFTDA(A)
	POPJ P,
	CAMN C,LFTX1(B)
	CAME D,LFTY1(B)
	POPJ P,
	CAMN E,LFTX2(B)
	CAME F,LFTY2(B)
	POPJ P,
	SETOM LFTDA(A)
;	PUSHJ P,FIXLIN	;FLUSH VERTICES INFORMATION TOO
	AOS LINFLN
	POPJ P,

CLNU2B:	MOVNS A
	CAMN A,B
	POPJ P,
.F ,,LFTX2(A),LFTY2(A),LFTX1(A),LFTY1(A)
	JRST CLNU2C

CLNUP1:	SKIPE LFTDA(A)
	POPJ P,
	MOVE B,LFTX1(A)
	CAME B,LFTX2(A)
	JRST APOPJ
	MOVE C,LFTY1(A)
	CAME C,LFTY2(A)
	AOS (P)
	POPJ P,


	;REDUNDANCY FLUSHING	-LINES VERSUS LINES-	***
VLINSA:	SETZM GLMFLG	;RESET GLOBAL CHANGE FLAG
.I ENTLIN<INTVAL>
.I MULTVF=#VLINER	;SET FUNCTION CALLED AT EACH STEP TO  PROCESS ASSOCIATIONS FOUND
.I VMAP<#VLINEC,LINES>	;FIND RELATIONS AMONG LINES
	JRST GCMULT	;RESET MULTIR

VLINEC:	SKIPE LFTDA(A)	;ALREADY USED ?
	POPJ P,		;YES
	MOVEM A,VLINCA
	MOVEM A,MULTIP
	PUSHJ P,GCMULT
VLINEX:
.F VLINCA,LFTX1(A),LFTY1(A),LFTX2(A),LFTY2(A)
	SETZB A,GLMFLL	;RESET LOCAL CHANGE FLAG
	JRST MULTIV

VLINER:	PUSHJ P,MLTIFZ	;SO CAN PROCESS ASSOCIATIONS AS THEY ARE FOUND
	SKIPN B,A
	POPJ P,
.I ACLMLT<#VLINED>
	SKIPE IMDVLN
	SKIPN GLMFLL	;DID ANYTHING HAPPEN LOCALLY
	POPJ P,		;NO
	SUB P,[MVLNN+1,,MVLNN+1]	;YES, POP UP PAST MULTIV
	JRST VLINEX	;START AGAIN ON THIS WITHOUT RESETTING MULTIR,MULTIP

IMDVLN:	0		;-1 TO RESTART LINE WHEN COMBINED IN VLINSA

;IF ANGLES OF TWO LINES ARE NEARLY ALIKE, FIT A COMMON STRAIGHT LINE
	;THEN TEST RATIO OF DEVIATIONS TOGETHER
	;IF LARGE, THE TWO MAY BE QUASI PARALLEL BUT NOT COLINEAR

VLINED:
.I VLINCB=,VLINCA
ONEND2:	SKIPE C,LFTDA(A)	;HAS THIS ONE BEEN COMBINED ALREADY ?
	JRST ONEND1
	CAMN A,B
	POPJ P,		;DONT COMBINE WITH ITSELF - SHOULDNT REALLY HAPPEN
	PUSHJ P,ANGCOM	;COMPARE ANGLES
	CAML C,PARALL
	POPJ P,		;NON-'PARALLEL'
	PUSHJ P,VLINET	;FIT COMMON LINE
			;COULD COMPARE DIRECTION OF INTENSITY STEP AS WELL
.F ,,LFITSQ/LFITNN-INTCAL^2
	JUMPG C,TPOPJ	;RMS TOO LARGE
.F VLINCB,VLINCA,LFITSQ/(LFTSQ(A)+LFTSQ(B))-COLINE^2
	JUMPG C,TPOPJ	;RATIO OF RMSES TOO LARGE (LOSING TEST ?)
	PUSHJ P,VENDP	;FIND NEW END-POINTS
	POPJ P,		;GAP WAS TOO LARGE OR POINTS TOO FAR OFF LINE
	MOVE B,VLINCB
.I LFTDA(B)=VLINCA	;SET UP LINK POINTER
	AOS LINFLN
.I SLURP<VLINCA,#LFITB,#LFTLNT>	;STORE ON TOP OF FORMER
			;MAKE SURE ALL LFITLL AND LFITRR ARE 0 HERE
	AOS GLMFLG	;INCREMENT GLOBAL CHANGE FLAG
	AOS GLMFLL	;INCREMENT LOCAL CHANGE FLAG
	POPJ P,

ONEND1:	SKIPG A,C	;TRACE ALONG CHAIN
	POPJ P,
	JRST ONEND2

VLINET:	PUSHJ P,LFITET	;SUM ALL THE SUMS
	PUSHJ P,LFIT3	;CALC ANGLES ETC
	PUSHJ P,LFITQQ	;CALC SUM OF SQ  ETC
	MOVEM A,LFITSQ	;COULD USE CHEAPER LINE-FIT HERE
	POPJ P,

	;COMBINE SUMS FROM TWO LINES
LFITET:
.F ,,LFITNN=LFTNN(A)+LFTNN(B)		;?
.F ,,LFITSX=LFTSX(A)+LFTSX(B)
.F ,,LFITSY=LFTSY(A)+LFTSY(B)
.F ,,LFITXX=LFTXX(A)+LFTXX(B)
.F ,,LFITXY=LFTXY(A)+LFTXY(B)
.F ,,LFITYY=LFTYY(A)+LFTYY(B)
	POPJ P,


VENDP:	SETZM MXSWSH	;MAX DEVIATION
	MOVEI C,LFTX1(A)	;CALC NEW ENDPOINTS OF COMBINED LINES
	PUSHJ P,LFITPM	
	MOVEM D,T	;SAVE S11
	MOVEI C,LFTX2(A)
	PUSHJ P,LFITPM
	MOVEM D,U	;SAVE S12
	MOVEI C,LFTX1(B)
	PUSHJ P,LFITPM
	MOVEM D,V	;SAVE S21
	MOVEI C,LFTX2(B)
	PUSHJ P,LFITPM
	MOVEM D,W	;SAVE S22
	CAMLE T,U
	EXCH T,U	;ORDER FIRST LINE
	CAMLE V,W
	EXCH V,W	;ORDER SECOND LINE
	CAMLE T,V
	PUSHJ P,SWAPEM	;ORDER BEGINNING OF THE TWO LINES
	CAMLE U,V
	JRST OVRLAP	;OK, THEY OVERLAP
.F ,,\(U-V)		;SEE IF ALLOWED TO BRIDGE
	CAML C,INTBRD
	POPJ P,		;NO - GAP TOO LARGE
	MOVE C,MXSWSH
	CAML C,INTBRS
	POPJ P,		;SIDEWAY WOBBLE TOO FAR FOR BRIDGING
GLMTHM:		;GET NEW END-POINTS
.F ,,LFITX1=-LFITC3*LFITSA+LFITCA*T,LFITY1=LFITC3*LFITCA+LFITSA*T
.F ,,LFITX2=-LFITC3*LFITSA+LFITCA*W,LFITY2=LFITC3*LFITCA+LFITSA*W
.F ,,LFITLN=\(T-W)	;LENGTH OF LINE
	AOS (P)		;INDICATE WE WON
	POPJ P,

SWAPEM:	EXCH T,V
	EXCH U,W
	POPJ P,

OVRLAP:	MOVE C,MXSWSH
	CAML C,INTCRS
	POPJ P,		;SIDEWAY WOBBLE TOO FAR FOR OVERLAPPING
	CAMLE U,W
	EXCH U,W
	JRST GLMTHM

LFITPM:		;CALCULATE DISTANCE PARAM ALONG LINE AND ABSOLUTE OF ACROSS
.F ,,,ZR(C)*LFITCA+ZR(C+1)*LFITSA,\(ZR(C)*LFITSA-ZR(C+1)*LFITCA+LFITC3)
	CAMLE E,MXSWSH
	MOVEM E,MXSWSH	;MAX CROSS DISTANCE SO FAR
	POPJ P,

MXSWSH:	0

;VERTEX FINDING FUNCTIONS - RESET SIN2SM ETC. THEN
;VETSUM FOR EACH LINE - FINALLY DO INTLOT TO GET COORDINATES
;OF POINT WITH LEAST SUM OF SQUARES OF PERPENDICULAR DISTANCE

WEIGHT:	0	;

SINS2M:	0
SINCOS:	0
COSS2M:	0
SINC3S:	0
COSC3S:	0
INTNCS:	0
SINLL==.-SINS2M

VETSUM:	MOVEM B,WEIGHT
.F ,LFTSA(A)^2 *WEIGHT,LFTSA(A)*LFTCA(A)*WEIGHT,LFTCA(A)^2 *WEIGHT,$
.F LFTSA(A)*LFTC3(A)*WEIGHT,LFTCA(A)*LFTC3(A)*WEIGHT
	FADRM B,SINS2M
	FADRM C,SINCOS
	FADRM D,COSS2M
	FADRM E,SINC3S
	FADRM F,COSC3S
	AOS INTNCS
	POPJ P,

INTLOT:	MOVE A,INTNCS	;FIND POINT 'CLOSEST' TO THESE LINES
	CAIG A,1
	POPJ P,		;STOP _TOO FEW LINES AT VERTEX
.F DELTS=SINS2M*COSS2M-SINCOS^2
	SKIPN A
	POPJ P,		;STOP _PARALLEL LINES DONT INTERSECT - INTLOT
.F (-COSS2M*SINC3S+SINCOS*COSC3S)/DELTS,(-SINCOS*SINC3S+SINS2M*COSC3S)/DELTS
	AOS (P)
	POPJ P,

DELTS:	0

;DATA FOR EACH VERTEX

XSUM:	0	;CURRENT GUESS AT X
YSUM:	0	;CURRENT GUESS AT Y
NSUM:	0	;NUMBER OF LINES IMPINGING
VPTR:	0	;LIST OF POINTERS TO ALL LINES IMPINGING (NEGATIVE IF SECOND END)
VBLL==.-XSUM

XSM==0
YSM==1
NSM==2
VTR==3


XLOK:	0	;POINT FOR MULTIF
YLOK:	0

XLUK:	0	;OTHER END OF LINE
YLUK:	0

VRTDIS:	SKIPN DSPLAY
	POPJ P,
	HEAD VERTICES
	PUSHJ P,SEGDAS
	PUSHJ P,TIMED1
.I VMAP<#VRTDT1,VERTEX>	;THEN DISPLAY VERTICES AS CROSSES
	PUSHJ P,TIMED2
	JRST DISGO

VRTDT1:	SKIPG NSM(A)
	POPJ P,
	MOVE C,A
.F XSM(C),YSM(C)
CRSMIS:	SKIPN DSPLAY
	POPJ P,
	FIX B,-4
	FIX A,-4
	JRST DCROSS	;DISPLAY A CROSS HERE (AT VERTEX)


	;VERTEX PRINT FUNCTION
VRTOUT:	PRINT _
	SETZM VRTNUM
.I VMAP<#VRTOU1,VERTEX>
	POPJ P,

VRTOU1:	MOVE G,A	;PRINTS LOSERS TOO
.F XSM(G),YSM(G),NSM(G)
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	AOS E,VRTNUM
	TLNN C,777000	;SEE IF FLOATING ALREADY
	FSC C,233
	PRINT %5I3 X=%1F4.0 Y=%2F4.0 N=%3F2.0_
	POPJ P,

VRTNUM:	0

VRTMRK:	HEAD VERTEX LABELS
	PUSHJ P,SEGDAS
	SETZM VRTNUM
.I VMAP<#VRTMR1,VERTEX>
	JRST DISGO

VRTMR1:	MOVE E,A
	SKIPG NSM(A)
	JRST VRTCH2
.F XLOK=XSM(E),YLOK=YSM(E)
.F XSUM=YSUM=NSUM=0
.I VMAP<#VRTMR3,VTR(E)>
.F XSUM=XSUM/NSUM,YSUM=YSUM/NSUM
.F DISVRT'=SQRT<(XSUM-XLOK)^2 +(YSUM-YLOK)^2 >,1.0
	SKIPN A
	MOVEM B,DISVRT'
.F XSUM=XLOK-(XSUM-XLOK)/DISVRT*OFVRDS,YSUM=YLOK-(YSUM-YLOK)/DISVRT*OFVRDS
	FIX B,-4
	FIX A,-4
	SUBI B,6
	SUBI C,6
	PUSH P,FRCNPT
	SETOM FRCNPT
	MOVEI A,VRTMR2
	PUSHJ P,TALK
	POP P,FRCNPT
	POPJ P,

OFVRDS:	200.0

VRTMR2:	AOS A,VRTNUM
	PRINT #1
	POPJ P,

VRTMR3:	SKIPG A
	JRST VRTMR4
.F ,XSUM=XSUM+LFTX2(A),YSUM=YSUM+LFTY2(A),NSUM=NSUM+1.0
	POPJ P,

VRTMR4:	MOVNS A
.F ,XSUM=XSUM+LFTX1(A),YSUM=YSUM+LFTY1(A),NSUM=NSUM+1.0
	POPJ P,

NVRTCH:	0

VRTCHK:			;HEAD VERTEX CHECKING
	PUSHJ P,SEGDAS	;CHECK VERTEX DATA BASE
.I VMAP<#VRTCH1,VERTEX>
	JRST TDISGO

VRTCH1:	MOVE E,A
	SKIPG D,NSM(A)
	JRST VRTCH2
	SKIPG B,VTR(A)
	.VALUE		;NO LIST
	SETZM NVRTCH
.I VMAP<#VRTCH3>	;CHECK ATTACHED LINES
	CAME D,NVRTCH
	.VALUE		;NUMBER OF ATTACHED LINES WRONG
	SKIPN DSPLAY
	POPJ P,
.I XSM(E),YSM(E)
	FIX B,-4
	FIX A,-4
	PUSH P,B
	PUSH P,C
	ADDI B,6	;MOVE AWAY A LITLLE
	ADDI C,6
	PUSH P,FRCNPT
	SETOM FRCNPT	;FORCE NO DECIMAL POINT
	MOVEI A,VRTCH5
	PUSHJ P,TALK	;OUTPUT NUMBER OF ATTACHED LINES
	POP P,FRCNPT
	POP P,C
	POP P,B
	JRST DCROSS

VRTCH5:	MOVE A,NVRTCH
	PRINT #1
	POPJ P,

VRTCH2:	SKIPE B,VTR(A)
	.VALUE		;NOT GC'ED
	POPJ P,

VRTCH3:	SKIPG A
	JRST VRTCH4
	SKIPE LFTDA(A)
	.VALUE		;DEAD LINE
	CAME E,LFTLL(A)
	.VALUE		;BAD VERTEX POINTER
	AOS NVRTCH
	POPJ P,

VRTCH4:	MOVNS A
	SKIPE LFTDA(A)
	.VALUE		;DEAD LINE
	CAME E,LFTRR(A)
	.VALUE		;BAD VERTEX POINTER
	AOS NVRTCH
	POPJ P,


TVRTEX:	PUSHJ P,REFREV	;VERTEX FINDING - POINTS VERSUS POINTS - ***
	PUSHJ P,UNMARK
.I ENTVRT<INTVET>
.I VMAP<#TVRTX2,LINES>	;NOW MULTI-SEARCH
.I VMAP<#TVRTX3,LINES>	;GEN SINGLE LINE VERTICES
	PUSHJ P,VRTINT	;INSERT VERTEX COORDINATES
	JRST GCMULT	;


TVRTX3:	SKIPE LFTDA(A)
	POPJ P,
	MOVEM A,VLINCA	;SINGLE LINE VERTICES
	SKIPE LFTRR(A)
	JRST TVRTU5
	MOVE D,VXFREE
	HLRE D,(D)
	MOVEM D,LFTRR(A)
	SETZM VPTR
	MOVN C,A
	CONSV C,D,E,VPTR
.F ,LFTX2(A),LFTY2(A)
	MOVNS A
	PUSHJ P,TVRTU6
TVRTU5:	MOVE A,VLINCA
	SKIPE LFTLL(A)
	POPJ P,
	MOVE D,VXFREE
	HLRE D,(D)
	MOVEM D,LFTLL(A)
	SETZM VPTR
	MOVE C,A
	CONSV C,D,E,VPTR
.F ,LFTX1(A),LFTY1(A)

TVRTU6:
.F ,XSUM=,YSUM=,NSUM=1
	JRST GENVRT	;NOT REALLY WORTH DISPLAYING

TVRTX2:	SKIPE LFTDA(A)
	POPJ P,
	MOVEM A,VLINCA
	SKIPE LFTLL(A)	;ALREADY USED ?
	JRST TVRTX9	;YES, TRY OTHER END
.F ,LFTX1(A),LFTY1(A)
	SETZM ENDTWO
	PUSHJ P,TRYNBL	;TRY FIRST VERTEX
	MOVE A,VLINCA
TVRTX9:	SKIPE LFTRR(A)	;ALREADY USED ?
	POPJ P,		;YES, GIVE UP
.F ,LFTX2(A),LFTY2(A)
	SETOM ENDTWO
	MOVNS A

TRYNBL:
.I ,XLOK=,YLOK=
	PUSH P,A
.I SWIPE<#XSUM,#VBLL>	;RESET SUMS
	POP P,A
.F ,XLOK,YLOK
	PUSHJ P,MULTIF	;FIND NEIGHBOURS
	SKIPN B,A
	POPJ P,		;NONE NEAR
.I ACLMLT<#TRYNL0>
	SKIPG NSUM
	POPJ P,		;ONLY ONE END-POINT
.F SWIPE<#SINS2M,#SINLL>	;RESET SUMS
.F 0,XLOK=XSUM,YLOK=YSUM	;NEW GUESS AT WHERE VERTEX IS
	PUSHJ P,CHKMTT
	POPJ P,		;OUTSIDE
	PUSHJ P,MULTIF	;ONCE MORE
	MOVE B,A
.I ACLMLT<#TRYNL1>
	MOVE A,INTNCS
	CAIG A,1
	JRST GCVPTR	;LOST - UNLIKELY
	MOVEM A,NSUM	;NOW FIXED
	PUSHJ P,INTLOT	;FIT IT - PERHAPS A BIT SLOW FOR 2-LINE VERTICES
	JRST GENVAT	;EXACTLY PARALLEL
	PUSHJ P,CHKMUT
	JRST GENVAT	;USE LAST GUESS RATHER (WAS INSIDE AT LEAST)
.F ,,(A-XSUM)^2 +(B-YSUM)^2 -INTVET^2
	JUMPG C,GENVAT	;WE HAD ONLY NEAR PARALLEL ONES
.F XSUM=,YSUM=
GENVAT:	PUSHJ P,GENVRT	;GENERATE VERTEX
	JRST VRTDT1	;DISPLAY THIS VERTEX

GCVPTR:		;RESET WORLD AFTER A VERTEX LOST
.I VMAP<#GCVPT1,VPTR>
.I GCL<VPTR>
.I SWIPE<#XSUM,#VBLL>	;IN CASE
	POPJ P,

GCVPT1:	SKIPL A
	SETZM LFTLL(A)
	MOVNS A
	SKIPL A
	SETZM LFTRR(A)
	POPJ P,

TRYNL0:		;FIRST LOOK
.I VLINCB=,VLINCA
	SKIPG A
	JRST TOPEL0	;OTHER END
	SKIPE LFTDA(A)
	POPJ P,
	CAME A,B	;UNLIKELY
	SKIPE LFTLL(A)
	POPJ P,		;ALREADY USED
.I ,,LFTX1(A),LFTY1(A)
TRYCOM:
.I ,,XTMP=,YTMP=
	PUSHJ P,ANGCOM
	CAMG C,PARALL
	JRST INCECT	;TOO PARALLEL
	PUSHJ P,INTSEC	;INTERSECT THEM
	PUSHJ P,CHKMUT
	JRST INCECT
.F XTMP=,YTMP=
INCECT:
.F XSUM=(XSUM*NSUM+XTMP)/(NSUM+1.0),YSUM=(YSUM*NSUM+YTMP)/(NSUM+1.0),NSUM=NSUM+1.0
	POPJ P,

TOPEL0:	MOVNS A
	SKIPN LFTDA(A)
	CAME A,B	;UNLIKELY
	SKIPE LFTRR(A)
	POPJ P,		;ALREADY USED
.I ,,LFTX2(A),LFTY2(A)
	JRST TRYCOM

INTSEC:		;INTERSECT TWO LINES
	CAMN A,B
	.VALUE		;STOP _A LINE DOES NOT INTERSECT ITSELF
.F ,,DELTS=LFTSA(B)*LFTCA(A)-LFTCA(B)*LFTSA(A)
	SKIPN C
	.VALUE		;STOP _PARALLEL LINES DONT INTERSECT - INTSEC
.F ,,(LFTCA(B)*LFTC3(A)-LFTC3(B)*LFTCA(A))/DELTS,(LFTSA(B)*LFTC3(A)-LFTC3(B)*LFTSA(A))/DELTS
	MOVE A,C
	MOVE B,D
	POPJ P,

XTMP:	0
YTMP:	0

TRYNL1:
.I VLINCB=,VLINCA
	SKIPG A		;FIRST END ?
	JRST TRYNL2	;NO
	SKIPE LFTDA(A)
	POPJ P,
	SKIPE ENDTWO	;?
	CAME A,B	;FIRST TEST FOR EQUAL END LOSSAGE
	SKIPE LFTLL(A)	;#
	POPJ P,		;ALREADY USED
	MOVEI T,LFTRR(A)	;PLACE TO CHECK
	MOVEI U,LFTLL(A)	;PLACE TO PUT POINTER
.F ,LFTX1(A),LFTY1(A),LFTX2(A),LFTY2(A)
TRYNL3:	MOVEI F,1(Z)
	CAMN F,(T)
	POPJ P,		;BOTH ENDS ON SAME VERTEX (THIRD TEST)
.F ,,,,,\(CROSDS=((DELXV=(B-XLOK))*LFTCA(A)+(DELYV=(C-YLOK))*LFTSA(A))),$
.F \(CROSDD=((DELXW=(D-XLOK))*LFTCA(A)+(DELYW=(E-YLOK))*LFTSA(A)))
	CAMG G,F
	POPJ P,		;OTHER END CLOSER (SECOND TEST)
.F ,(CROSDS/INTVET)^2 +((DELXV*LFTSA(A)-DELYV*LFTCA(A))/INTCRS)^2
.F ,,CROSDS*CROSDD
	JUMPG C,TRYNL4	;PROPOSED VERTEX NOT NEXT TO LINE
	CAML B,VETENS
	POPJ P,		;BACKWARD VERTEX TOO FAR
TRYNL4:	CAML B,[1.0]
	POPJ P,		;TOO FAR
	MOVM A,VLINCB
	PUSHJ P,VATIC	;ENTER INTO LINE SUMS
	MOVE D,VXFREE
	HLRE D,(D)
	MOVEM D,(U)	;STORE POINTER TO VERTEX INFORMATION
	MOVE C,VLINCB	;CONS ONTO LIST OF LINES FOR THIS VERTEX
	CONSV C,D,E,VPTR
	POPJ P,

TRYNL2:	MOVNS A
	SKIPE LFTDA(A)
	POPJ P,
	SKIPN ENDTWO	;?
	CAME A,B	;TEST FOR EQUAL END LOSSAGE
	SKIPE LFTRR(A)
	POPJ P,		;ALREADY USED
	MOVEI T,LFTLL(A)	;PLACE TO CHECK
	MOVEI U,LFTRR(A)	;PLACE TO PUT POINTER
.F ,LFTX2(A),LFTY2(A),LFTX1(A),LFTY1(A)
	JRST TRYNL3

CROSDS:	0	;DISTANCE ALONG LINE FROM END 1
DELXV:	0	;DELTA X FROM END 1
DELYV:	0	;DELTA Y FROM END 1

CROSDD:	0	;DISTANCE ALONG LINE FROM END 2
DELXW:	0	;DELTA X FROM END 2
DELYW:	0	;DELTA Y FROM END 2

VRTINT:		;INSERT VERTEX LOCATION IN LINES -
.I VMAP<#VRTIN1,LINES>
	POPJ P,

VRTIN1:	SKIPE LFTDA(A)
	POPJ P,
	SKIPG B,LFTLL(A)
	JRST VRTIN2
	SKIPG NSM(B)
	.VALUE		;THIS VERTEX CLAIMS ITS NOT HOOKED UP
.F ,,LFTX1(A)=XSM(B),LFTY1(A)=YSM(B)
VRTIN2:	SKIPG B,LFTRR(A)
	JRST ANGET1
	SKIPG NSM(A)
	.VALUE		;THIS VERTEX CLAIMS ITS NOT HOOKED UP
.F ,,LFTX2(A)=XSM(B),LFTY2(A)=YSM(B)

ANGET1:	SKIPE LFTDA(A)
	POPJ P,
.F ,LFTCA(A)=LFTX2(A)-LFTX1(A),LFTSA(A)=LFTY2(A)-LFTY1(A)
.F ,SQRT<LFTCA(A)^2 +LFTSA(A)^2 >
	JUMPE B,ANGET2
ANGET3:	MOVEM B,LFTLN(A)
.F ,LFTCA(A)=LFTCA(A)/LFTLN(A),LFTSA(A)=LFTSA(A)/LFTLN(A)
.F ,LFTC3(A)=-(LFTX1(A)*LFTSA(A)-LFTY1(A)*LFTCA(A))
	POPJ P,

ANGET2:	PUSH P,A
	PUSHJ P,FIXLIN	;DANGER !! MODIFIES VERTEX DATA BASE !!
	POP P,A
	SETOM LFTDA(A)	;MARK THIS TRULY WORTH-LESS LINE - DANGER !! MAY WELL BE POINTED TO
.F ,LFTX1(A)=LFTX2(A),LFTY1(A)=LFTY2(A)
	MOVE B,[1.0]
	AOS LINFLN
	JRST ANGET3

ANGET:		;REGENERATE SIN, COS, C3 AND LENGTH FOR ALL LINES
.I VMAP<#ANGET1,LINES>
	POPJ P,

KJOHN:	SETZM GLMFLG	;K-JOINTS  LINES VERSUS VERTICES	***
.I ENTLIN<INTVAL>
.I VMAP<#KJOHN1,VERTEX>
	SETZM GLMFLG	;?
	JRST GCMULT

KJOHN1:	SKIPLE D,NSM(A)
	CAIG D,1
	POPJ P,		;T-JOINTS GET HACKED LATER
	MOVEM A,VLINCC	;VERTEX POINTER ! ;NOTE
.I ,XLOK=XSM(A),YLOK=YSM(A)
	SETZM A
	PUSHJ P,MULTIF	;FIND NEARBY
	MOVE B,A
	SETZM VJOINM
.I VJOMIN=INTKJN
.I ACLMLT<#KJOHN2>
	SKIPN VJOINM	;FOUND ANY
	POPJ P,		;NO

	MOVE C,VLINCC
.F XSM(C)=VXINT,YSM(C)=VYINT	;MOVE VERTEX ONTO LINE
	SKIPE NOSPLT
	JRST TKJKLJ	;NOT SPLIT - THINGS WILL BE FIXED WHEN VERTICES ARE COMBINED
	MOVE X,VXINT
	MOVE Y,VYINT
	MOVE T,VLINCC
.I VMAP<#COMBI4,VTR(T)>	;TELL ALL LINES ON IT ABOUT THIS -
	AOS NKJN
TKJKLJ:
.F CRSMIS<VXINT,VYINT>	;USED BY T-JOINING TOO
	SKIPGE NOSPLT
	JRST RGHPLT	;NO SPLIT - JOIN ON RIGHT
	SKIPLE NOSPLT
	JRST LFTPLT	;NO SPLIT - JOIN ON LEFT
TKLUD:			;LINE IS GOING TO BE SPLIT - ALSO USED BY X-JOINING
.I VJOINM,,,VLINCC	;?
	PUSHJ P,ENDEVR	;SPLIT THE LINE - AOSES NLIN
	JRST ENTNLN	;ENTER NEW LINE INTO MULTI-ENTRY

RGHPLT:	AOS GLMFLG	;NOT SPLIT, BUT ATTACHED ON RIGHT
	MOVE A,VJOINM
.I COMBIN<LFTRR(A),VLINCC>	;COMBINE THE TWO VERTICES
	POPJ P,

LFTPLT:	AOS GLMFLG	;NOT SPLIT, BUT ATTACHED ON LEFT
	MOVE A,VJOINM
.I COMBIN<LFTLL(A),VLINCC>	;COMBINE THE TWO VERTICES
	POPJ P,

SEEONL:		;SEE IF POINT (A,B) IS ON LINE IN C
.F ,,,BAR1=(A-LFTX1(C))*LFTCA(C)+(B-LFTY1(C))*LFTSA(C)
.F ,,,BAR2=(A-LFTX2(C))*LFTCA(C)+(B-LFTY2(C))*LFTSA(C)
SEEON1:
.F ,,,BAR1*BAR2
	SKIPGE D
	AOS (P)		;THEY HAD OPPOSITE SIGNS 
	POPJ P,

SEEUNL:
.F ,,,BAR1=(XLOK-LFITX1)*LFITCA+(YLOK-LFITY1)*LFITSA
.F ,,,BAR2=(XLOK-LFITX2)*LFITCA+(YLOK-LFITY2)*LFITSA
	JRST SEEON1

KJOHN2:	SKIPE LFTDA(A)
	POPJ P,
.I VLINCB=,VLINCC	;VLINCC => VERTEX, VLINCB => NEARBY LINE
	CAME B,LFTLL(A)
	CAMN B,LFTRR(A)
	POPJ P,		;ATTACHED TO THIS VERTEX
	PUSHJ P,SAMEQ	;ENDS MATCH ? NOT REALLY NEEDED
	POPJ P,		;YES
.F ,\(XLOK*LFTSA(A)-YLOK*LFTCA(A)+LFTC3(A))	;VERTICAL DISTANCE
	CAML B,VJOMIN	;BEST SO FAR ?
	POPJ P,
	MOVEM B,CHTMP
.F ,XLOK*LFTCA(A)+YLOK*LFTSA(A)		;DISTANCE PARM ALONG LINE
.F ,,XINTS=-LFTC3(A)*LFTSA(A)+LFTCA(A)*B,YINTS=LFTC3(A)*LFTCA(A)+LFTSA(A)*B
			;PERPENDICULAR PROJECTION ON LINES
THATCH:			;USED BY T-JOINING TOO
.I XINTS,YINTS,VLINCB	;??
	SETZM MATFLL
	PUSHJ P,SEEONL	;SEE IF ON LINE
	SETOM MATFLL	;MIXED !!
	PUSHJ P,ENDTST	;SEE IF NEAR END-POINTS
	SKIPN NOSPLT
	SKIPN MATFLL
	SKIPA
	POPJ P,		;NOT NOT SPLIT (IE NOT NEAR END POINTS) AND NOT ON LINE
.I VXINT=XINTS,VYINT=YINTS,VJOINM=VLINCB,VJOMIN=CHTMP
	POPJ P,

ENDTST:	SETZM NOSPLT	;TEST IF POINT IS NEAR ENDS (ASSUMING CALLED SEEONL/SEEUNL)
.I ,,\BAR1,\BAR2
	CAMGE C,INTEND
	JRST ENDTS1
	CAML D,INTEND
	POPJ P,		;NOT NEAR END-POINTS
.I NOSPLT=-1		;NEAR END TWO
.F VLINCB,LFTX2(A),LFTY2(A)

ENDTCH:
.F ,XINTS=,YINTS=
	POPJ P,

ENDTS1:
.I NOSPLT=1		;NEAR END ONE
.F VLINCB,LFTX1(A),LFTY1(A)
	JRST ENDTCH

BAR1:	0	;DISTANCE FROM LEFT END
BAR2:	0	;DISTANCE FROM RIGHT END
MATFLL:	0	;0 IF PERPENDICLUAR CLOSEST POINT ON LINE, -1 IF NOT
NOSPLT:	0	;1,-1 IF LINE IS NOT TO BE SPLIT (LEFT, RIGHT), 0 IF WILL BE SPLIT
XINTS:	0	;X OF PERPENDICULAR PROJECTION ON LINE
YINTS:	0	;Y

ENDEVR:		;SPLIT A LINE (VJOINM), NEW POINT IS VXINT, VYINT, VERTEX VLINCC
.I SLURP<#LFITB,VJOINM,#LFTLNT>	;COPY DOWN
.F VJOINM,LFITX2=LFTX1(A)=VXINT,LFITY2=LFTY1(A)=VYINT,LFITRR=VLINCC,VRTXIY=LFTLL(A)
	MOVEM D,LFTLL(A)
	AOS NSM(D)
	PUSH P,A
	CONSV A,B,C,VTR(D)
	POP P,A
	PUSHJ P,GENVLT	;GENERATE NEW EDGE - RETURNS ADR INA AND AOSES NLIN
	MOVEM A,VJOIYN	;NEW LINE
	MOVE D,VLINCC
	AOS NSM(D)
	PUSH P,A
	MOVNS A
	CONSV A,B,C,VTR(D)
	POP P,A
	AOS GLMFLG
	PUSH P,A
	MOVE A,VRTXIY	;ON THIS VERTEX REPLACE (LEFT) LINE VJOINM BY (LEFT) VJOIYN
.I REPLAC<VTR(A),VJOINM,VJOIYN>
	.VALUE
.I ANGET1<VJOINM>
.I ANGET1<VJOIYN>
	POP P,A		;RETURN ADDRESS OF NEW LINE
	POPJ P,


VJOIYN:	0	;NEW EDGE NUMBER
VRTXIY:	0	;VERTEX REQUIRING HACKAGE

ENTNLN:	SKIPG A
	.VALUE
	SKIPE LFTDA(A)
	POPJ P,
	PUSH P,A	;ENTER NEW LINE INTO MULTI-ENTRY
	PUSH P,MULTVF
.I ,MULTVF=#MULTIS
	PUSHJ P,VISTAB
	POP P,MULTVF
	JRST POPAJ
 
TJOING:	SETZM GLMFLG	;T-JOINTS	-LINES VERSUS VERTICES-	***
.I ENTLIN<INTVAL>
.I VMAP<#TJOIN1,LINES>	;SEARCH END-POINTS
	SETZM GLMFLG	;?
	JRST GCMULT

TJOIN1:	SKIPE LFTDA(A)
	POPJ P,
	SETZM GLMFLL
	MOVEM A,VLINCA
	SKIPG B,LFTLL(A)
	JRST TJOIN2
	MOVEM B,VLINCC
	MOVE B,NSM(B)
	CAIE B,1
	JRST TJOIN2
	SETZM ENDTWO
.F ,XLOK=LFTX1(A),YLOK=LFTY1(A)
	PUSHJ P,TJOYX
	MOVE A,VLINCA
TJOIN2:	SKIPG B,LFTRR(A)
	POPJ P,
	MOVEM B,VLINCC
	MOVE B,NSM(B)
	CAIE B,1
	POPJ P,
	SETOM ENDTWO
.F ,XLOK=LFTX2(A),YLOK=LFTY2(A)
	PUSHJ P,TJOYX
	SOSE GLMFLL
	POPJ P,
	MOVE A,VLINCA
	JRST TJOIN1	;ONCE MORE

TJOYX:	PUSHJ P,MULTIF	;MULTI-FIND
	SKIPN B,A
	POPJ P,		;NOTHING !
	SETZM VJOINM
.I VJOMIN=9.0^9
.F VLINCA,,CHTUP=LFTLN(A)^2		;LENGTH OF LINE SQUARED
.I ACLMLT<#TCHJK1>
	SKIPN VJOINM	;FOUND ANY ?
	POPJ P,		;NO

;WE NOW HAVE T-INTERSECTION VXINT, VYINT ON LINE VJOINM  FROM EXTENDED LINE VLINCA
.F VLINCA,VXINT,VYINT
	SKIPN ENDTWO
	JRST ENJTON
.F ,LFTX2(A)=,LFTY2(A)=	;MUNG ON TOP OF
TXJOM:	MOVE D,VLINCC
.I ,XSM(D)=,YSM(D)=	;FIX UP VERTEX THERE
	PUSHJ P,ANGET1	;FIX UP ANGLES ETC OF LINE EXTENDED
	SKIPE LFTDA(A)
	POPJ P,
	AOS GLMFLL
	JRST TKJKLJ

ENJTON:
.F ,LFTX1(A)=,LFTY1(A)=
	JRST TXJOM

ENDTWO:	0	;0 FOR LEFT END OF LINE WITH LOOSE END (VLINCA), -1 FOR RIGHT
EOFTWO:	0	;0 FOR LEFT END OF LINE NEARBY (VLINCB), -1 FOR RIGHT
CHTUP:	0	;LENGTH OF LINE SQUARED


VJOINM:	0	;BEST LINE SO FAR
VJOMIN:	0	;MINIMUM DISTANCE TO ANY LINE
VXINT:	0	;INTERSECT X
VYINT:	0	;INTERSECT Y


TCHJK1:	SKIPE LFTDA(A)	;TEST A LINE (VLINCB) NEAR AN END OF ANOTHER (VLINCA)
	POPJ P,
.F VLINCB=,VLINCA
	PUSHJ P,ANGCOM	;COMPARE ANGLES
	CAMGE C,PARALL
	POPJ P,		;TOO NEAR PARALLEL
	PUSHJ P,INTSEC	;INTERSECT THE LINES
	PUSHJ P,CHKMUT
	POPJ P,
.F XINTS=,YINTS=	;SAVE INTERSECTION
.F ,,(CHTMP=(A-XLOK)^2 +(B-YLOK)^2 )-INTTJN^2
	JUMPG C,TPOPJ
	MOVE A,CHTMP
	CAML A,VJOMIN
	POPJ P,		;WORSE THAN BEST SO FAR
	MOVE A,VLINCA
	PUSHJ P,ATTACH	;SEE IF ATTACHED
	CAIL T,2
	MOVEI T,1
.F CHTMP/CHTUP-EXTRT(T)^2	;SEE IF EXTENSION TOO LONG
	JUMPG A,TPOPJ	;TOO LONG
	JRST THATCH	;OK SEE IF ON LINE, NEED TO SPLIT ETC (MAY STILL LOSE THERE)

SAMEP:
.F ,,XLOK=,YLOK=
SAMEQ:	MOVE C,LFTX1(A)		;DOESN'T SKIP IF EQUAL TO ONE OR THE OTHER
	CAME C,XLOK
	JRST SAMEQL
	MOVE D,LFTY1(A)
	CAMN D,YLOK
	POPJ P,
SAMEQL:	MOVE C,LFTX2(A)
	CAME C,XLOK
	JRST APOPJ
	MOVE D,LFTY2(A)
	CAME D,YLOK
APOPJ:	AOS (P)
	POPJ P,

XJOINS:		;GET CROSSED LINES FIXED UP - LINES VERSUS LINES - 	***
	SETZM GLMFLG
.I ENTLIN<INTVAL>
.I MULTVF=#XJOINR
.I VMAP<#VLINEC,LINES>
	SETZM GLMFLG	;?
	JRST GCMULT

XJOINR:	PUSHJ P,MLTIFZ	;ASSOCIATIONS GET PROCESSED AS THEY HAPPEN
	SKIPN B,A
	POPJ P,		;NOTHING !
.I ACLMLT<#VXINED>
	POPJ P,

VXINED:	SKIPE LFTDA(A)	;CALLED FOR EACH PAIR OF LINES NEAR EACH OTHER
	POPJ P,
.I VLINCB=,VLINCA,LFTLL(A),LFTRR(A)
	CAME C,LFTLL(B)
	CAMN C,LFTRR(B)
	POPJ P,		;VERTEX IN COMMON
	CAME D,LFTLL(B)
	CAMN D,LFTRR(B)
	POPJ P,		;VERTEX IN COMMON
;.F ,,LFTX1(B),LFTY1(B)
;	PUSHJ P,SAMEP	;SEE IF MATCH ? NOT REALLY NEEDED
;	POPJ P,		;MATCHED
;.F ,,LFTX2(B),LFTY2(B)
;	PUSHJ P,SAMEP	;SEE IF MATCH ? NOT REALLY NEEDED
;	POPJ P,		;MATCHED
	PUSHJ P,ANGCOM
	CAMGE C,PARALL
	POPJ P,		;TOO NEAR PARALLEL
	PUSHJ P,INTSEC	;INTERSECT THE TWO LINES
	PUSHJ P,CHKMUT
	POPJ P,
.I VXINT=,VYINT=
	MOVE C,VLINCA
	PUSHJ P,SEEONL
	POPJ P,		;NOT ON LINES ONE
	MOVE C,VLINCB
	PUSHJ P,SEEONL	
	POPJ P,		;NOT ON LINE TWO
.F 0,VXINT,VYINT
	PUSHJ P,MULTIF	;THUS LOSING MULTIR
	SKIPN B,A
	JRST FXUPXO
	MOVEM B,GCLLOS
.I SWIPE<#SINS2M,#SINLL>	;DONE ONE AT A TIME, NOT LIKE VERTICES
	SETZM NEWLOS
.I VMAP<#VATICA,GCLLOS>	;ENTER INTO LINE-SUMS
.I GCL<GCLLOS>
	SETZM GCLLOS
	MOVE A,INTNCS
	CAIG A,1
	JRST FXUPXN	;LOSS ONLY ONE LINE
	PUSHJ P,INTLOT	;FIT IT
	JRST FXUPXN	;EXACTLY PARALLEL
	PUSHJ P,CHKMUT
	JRST FXUPXN	;MUST HAVE BEEN NEAR PARALLEL

.F XLOK=XSUM=,YLOK=YSUM=,NSUM=0,VPTR=0
.F ,,(A-VXINT)^2 +(B-VYINT)^2 -INTXJN^2
	JUMPG C,FXUPXN	;ARGH
.F CRSMIS<VXINT=XLOK,VYINT=YLOK>
	PUSHJ P,GENVRT	;GENERATE VERTEX
	MOVEM A,VLINCC
.I VMAP<#VXTEN2,NEWLOS>	;CUT UP ALL CROSSERS
	AOS NXJN
	SUB P,[3,,3]	;UP PAST VMAP 

FXUPXN:
.I GCL<NEWLOS>
	SETZM NEWLOS
FXUPXO:	MOVE A,VLINCB
	MOVEM A,MULTIP
	POPJ P,

VXTEN2:
.I VJOINM=
	JRST TKLUD	;?? SPLIT LINE, ADD STUFF TO VERTEX, PATCH UP OLD VERTEX

VATICA:
.F ,\(LFTSA(A)*VXINT-LFTCA(A)*VYINT+LFTC3(A))
	CAML B,INTXJN
	POPJ P,		;TOO FAR AWAY
	MOVE C,A
.F VXINT,VYINT
	PUSHJ P,SEEONL
	POPJ P,		;NOT ON LINE
	MOVE A,C
	PUSH P,A
	CONSV A,B,C,NEWLOS
	POP P,A
VATIC:	MOVE B,LFTNN(A)	;WEIGHT
	JRST VETSUM

GCLLOS:	0	;PLACE TO HANG LIST TO BE GC'ED LATER
NEWLOS:	0	;LIST OF REALLY WINNING LINES FOR THIS X

EXTEND:	;EXTEND INCOMPLETE LINES TO VERTICES - LINES VERSUS 'LINES' - 	***
	SETZM GLMFLG
.I ENTLIN<INTVAL>
.I MULTVF=#EXTNIA
.I VMAP<#EXTN1,LINES>
	SETZM GLMFLG	;?
	JRST GCMULT

EXTN1:	SKIPE LFTDA(A)
	POPJ P,
	SETZM GLMFLL
	MOVEM A,VLINCA
	SKIPG B,LFTRR(A)
	JRST EXTN2
	MOVE C,NSM(B)
	CAIE C,1
	JRST EXTN2	;TRY OTHER END
	MOVEM B,VLINCC
	SETOM ENDTWO
.F ,LFTX2(A),LFTY2(A),LFTX1(A),LFTY1(A)
	PUSHJ P,EXTNIZ
	MOVE A,VLINCA

EXTN2:	SKIPG B,LFTLL(A)
	POPJ P,
	MOVE C,NSM(B)
	CAIE C,1
	POPJ P,		;CHOMP ITS OK
	MOVEM B,VLINCC
	SETZM ENDTWO
.F ,LFTX1(A),LFTY1(A),LFTX2(A),LFTY2(A)
	PUSHJ P,EXTNIZ
	SOS GLMFLL
	POPJ P,
	MOVE A,VLINCA
	JRST EXTN1

EXTNIZ:	PUSHJ P,ATTACH	;SEE IF ATTACHED (AT OTHER END THAT IS)
	CAILE T,1
	MOVEI T,1
.F ,XLOK=,YLOK=,XLUK=,YLUK=,CHTMP=(DELXV=(B-D)*EXTENS(T))^2 +(DELYV=(C-E)*EXTENS(T))^2 
.F ,,,DELXV+B,DELYV+C
	JRST MULTIV

EXTNIA:	PUSHJ P,CHKMTT
	POPJ P,		;OUTSIDE !
	PUSHJ P,MULTIF
	SKIPN B,A
	POPJ P,		;NOTHING
.I ACLMLT<#EXTNIB>
	SUB P,[MVLNN+1,,MVLNN+1]	;TRY ONLY ONCE - UP PAST MULTIV
	POPJ P,

CHTMP:	0	;(LENGTH OF LINE TIMES ALLOWED EXTENSION) SQUARED

;THIS MAY ALSO FLUSH SHORT LINES ATTACHED AT ONE END ONLY - OK I GUESS ...

;ENDTWO REFERS TO VLINCA (LINE TO BE EXTENDED) --- EOFTWO REFERS TO VLINCB (LINE MET)

EXTNIB:	CAME A,VLINCA	;SAME LINE ?
	SKIPE LFTDA(A)
	POPJ P,
.I VLINCB=,VLINCA
	PUSHJ P,EXTAT	;TRY END 1 OF LINES MET
.I VLINCB,VLINCA
	PUSHJ P,EXTOT	;TRY END 2 OF LINE MET --- DONT CHANGE TO JRST
	POPJ P,

EXTAT:	PUSHJ P,DISGU1	;CALCULATE CROSS DISTANCE
	CAML C,INTEXT
	POPJ P,
	SETZM EOFTWO
;COULD CHECK XLUK=LFTX1(A), YLUK=LFTY1(A) HERE
	SKIPG G,LFTLL(A)
	JRST EXTHIS
	MOVE G,NSM(G)
	CAIN G,1
	JRST INTSUC	;INTERSECT THEM RATHER
EXTHIS:
.F ,,LFTX1(A),LFTY1(A)
EXTHIB:
.F ,,,,(C-XLOK)*LFTCA(B)+(D-YLOK)*LFTSA(B),(C-XLUK)*LFTCA(B)+(D-YLUK)*LFTSA(B),E*F
	JUMPLE G,CPOPJ	;CROSSES LINE TO BE EXTENDED
	MOVMS E
	MOVMS F
	CAML E,F
	POPJ P,		;NEAR OTHER END
	FMPR E,E
	CAML E,CHTMP
	POPJ P,		;TOO FAR
	SKIPE ENDTWO
	JRST EXTHIC
.F ,,LFTX1(B)=,LFTY1(B)=
EXTHID:	AOS GLMFLG
	AOS GLMFLL
.I ,,XLOK=,YLOK=
.I VLINCB,VLINCA
	MOVE C,LFTLL(A)
	SKIPE EOFTWO
	MOVE C,LFTRR(A)
	MOVE D,LFTLL(B)
	SKIPE ENDTWO
	MOVE D,LFTRR(B)
.I XSM(C)=XLOK,YSM(C)=YLOK
.I COMBIN<C,D>		;COMBINE VERTICES
.F CRSMIS<XLOK,YLOK>
.I ANGET1<VLINCA>
.I ANGET1<VLINCB>
	SUB P,[4,,4]	;UP PAST VMAP ?
	POPJ P,

EXTOT:	PUSHJ P,DISGU2	;CALCULATE CROSS DISTANCE
	CAML C,INTEXT
	POPJ P,
	SETOM EOFTWO
;COULD CHECK XLUK=LFTX2(A), YLUK=LFTY2(A) HERE
	SKIPG G,LFTRR(A)
	JRST EXTHIT
	MOVE G,NSM(G)
	CAIN G,1
	JRST INTSUC	;INTERSECT THEM RATHER - END IS FREE
EXTHIT:
.F ,,LFTX2(A),LFTY2(A)
	JRST EXTHIB

EXTHIC:
.F ,,LFTX2(B)=,LFTY2(B)=
	JRST EXTHID

DISGU1:	;CALCULATION OF CROSS-DISTANCE TO END-POINTS OF LINE-MET
.F ,,\(LFTSA(B)*LFTX1(A)-LFTCA(B)*LFTY1(A)+LFTC3(B))
	POPJ P,

DISGU2:
.F ,,\(LFTSA(B)*LFTX2(A)-LFTCA(B)*LFTY2(A)+LFTC3(B))
	POPJ P,


INTSUC:
.I VLINCB,VLINCA
	PUSHJ P,INTSEC	;INTERSECT THEM
	PUSHJ P,CHKMUT
	POPJ P,
.I XTMP=,YTMP=
.F ,,(A-XLOK)^2 +(B-YLOK)^2
	CAML C,CHTMP
	POPJ P,		;TOO FAR
.I VLINCB,VLINCA,XTMP,YTMP
	SKIPE ENDTWO
	JRST ENEXT2
.F ,,LFTX1(B)=,LFTY1(B)=
ENEXT3:	SKIPE EOFTWO
	JRST ENEXT4
.F ,,LFTX1(A)=,LFTY1(A)=
ENEXT5:	JRST EXTHID


ENEXT2:
.F ,,LFTX2(B)=,LFTY2(B)=
	JRST ENEXT3

ENEXT4:
.F ,,LFTX2(A)=,LFTY2(A)=
	JRST ENEXT5

STRAIG:	SETZM GLMFLG	;STRAIGHTEN OUT SIMPLE L'S	***
.I VMAP<#STRAI1,VERTEX>
	SETZM GLMFLG	;?
	JRST GCMULT

STRNT1:	SETOM LFTDA(A)
	AOS LINFLN
	POPJ P,

STRAI1:	SKIPLE B,NSM(A)	;HOW MANY LINES MEET HERE ?
	CAIE B,2
	POPJ P,		;NOT AN L
	MOVEM A,VLINCC	;VERTEX NUMBER
	MOVE B,VTR(A)
	MOVE B,(B)
	MOVE A,(B)
	HLRES B		;ONE LINE
	HLRES A		;OTHER LINE
STRMT2:
.I VLINCA=,VLINCB=
	MOVMS A
	MOVMS B
	CAMN A,B
	JRST STRNT1	;BARF !!
	SKIPE LFTDA(A)
	JRST STRMT3
	SKIPE LFTDA(B)
	JRST STRMT4
	PUSHJ P,ANGCOM
	CAML C,PARALL
	POPJ P,
	SKIPL VLINCA	;WE WANT END TWO OF THIS LINE
	PUSHJ P,RVREDG	;SO WILL NEED TO REVERSE IT
	MOVN A,VLINCB
	SKIPG VLINCB	;WE WANT END ONE OF THIS LINE
	PUSHJ P,RVREDG	;SO WILL NEED TO REVERSE IT

.F VLINCA=\VLINCA,VLINCB=\VLINCB
.F ,,LFITX1=LFTX1(A),LFITY1=LFTY1(A),XLOK=LFTX2(A),YLOK=LFTY2(A),LFITX2=LFTX2(B),LFITY2=LFTY2(B)
.F ,,LFITLN=SQRT<(LFITCA=LFITX2-LFITX1)^2 +(LFITSA=LFITY2-LFITY1)^2 >
	SKIPN C
	.VALUE		;LFITN=0 ??
.F ,,LFITCA=LFITCA/LFITLN,LFITSA=LFITSA/LFITLN
.F ,,LFITC3=-(LFITX1*LFITSA-LFITY1*LFITCA)
.F ,,\(XLOK*LFITSA-YLOK*LFITCA+LFITC3)
	CAML C,INTSTR
	POPJ P,		;TOO FAR OF HYPHOTHETICAL NEW LINE
	PUSHJ P,SEEUNL
	POPJ P,		;A LOSER MOST LIKELY (NOT ON LINE)
	MOVEM A,LFTDA(B)	;MARK THE LINE TO BE FLUSHED
	AOS LINFLN
.F ,,LFTCA(A)=LFITCA,LFTSA(A)=LFITSA,LFTC3(A)=LFITC3,LFTLN(A)=LFITLN,LFTNN(A)=LFTNN(A)+LFTNN(B)
.F ,,LFTX1(A)=LFITX1,LFTY1(A)=LFITY1,LFTX2(A)=LFITX2,LFTY2(A)=LFITY2
	MOVE D,LFTRR(A)
	CAMN D,VLINCC
	CAME D,LFTLL(B)
	.VALUE		;NOW WE'RE IN TROUBLE - THE  LINES CLAIM THEY ARE NOT ATTACHED TO SAME VERTEX
	SOSGE NSM(D)
	.VALUE		;VERTEX ALREADY DEAD !
	MOVEI A,VTR(D)
.I REMOVE<,-VLINCA>	;VERTEX GETS FLUSHED EVENTUALLY
	.VALUE		;NOT FOUND !!
	MOVE D,VLINCC
	SOSE NSM(D)
	.VALUE		;DIDN'T COUNT OUT TO ZERO
	MOVEI A,VTR(D)
.I REMOVE<,VLINCB>
	.VALUE		;NOT FOUND !!
.F VLINCA,VLINCB,LFTRR(A)=LFTRR(B)
	AOS LINFLN
	MOVE A,LFTRR(A)
	SETZM LFTLL(B)
	SETZM LFTRR(B)
	MOVEI A,VTR(A)
.I REPLAC<,-VLINCB,-VLINCA>	;FIX UP RIGHT HAND VERTEX
	.VALUE
.I CRSMIS<XLOK,YLOK>
	AOS GLMFLG
	POPJ P,


STRMT3:	MOVE A,LFTDA(A)	;VERY UNLIKELY
	JRST STRMT2

STRMT4:	MOVE B,LFTDA(B)	;VERY UNLIKELY
	JRST STRMT2

GLUMV:	SETZM GLMFLG	;COMBINE VERTICES THAT ARE CLOSE TOGETHER ***
.I ENTVEX<INTGLM>	;ENTER -  REAL VERTICES AGAINST REAL VERTICES
.I VMAP<#GLUMV1,VERTEX>
	SETZM GLMFLG	;?
	JRST GCMULT

GLUMV1:	SKIPG NSM(A)	;STILL ACTIVE ?
	POPJ P,
	MOVEM A,VLINCC
.F ,XSUM=XSM(A),YSUM=YSM(A),NNNN=NSUM=NSM(A)
	PUSHJ P,MULTIF
	SKIPN B,A
	POPJ P,		;NO NEIGHBOURS
.I ACLMLT<#GLUMV2>
	MOVE A,NSUM
	CAMG A,NNNN
	POPJ P,		;NO REAL FRIENDS
.I 0,XSUM,YSUM
	PUSHJ P,MULTIF
	MOVE B,A
	SETOM NNNN	;? COUNTER
.I ACLMLT<#GLUMV3>
.F CRSMIS<XSUM,YSUM>	;DISPLAY CROSS THERE
	AOS GLMFLG
	POPJ P,

GLUMV2:	SKIPG NSM(A)
	POPJ P,
.F ,(XSM(A)-XSUM)^2 +(YSM(A)-YSUM)^2 -INTGLM^2
	JUMPG B,TPOPJ
.F ,NSUM,NSM(A)
	FLOAT B
	FLOAT C
.F ,NFSUM=,NFSMA=
	FADR B,C
	MOVEM B,NFADS
.F ,XSUM=(XSUM*NFSUM+XSM(A)*NFSMA)/NFADS,YSUM=(YSUM*NFSUM+YSM(A)*NFSMA)/NFADS
.I ,NSUM=NSUM+NSM(A)
	POPJ P,

GLUMV3:	SKIPG NSM(A)
	POPJ P,
	MOVEM A,VLINCD
.F ,(XSM(A)-XSUM)^2 +(YSM(A)-YSUM)^2 -INTGLM^2
	JUMPG B,TPOPJ
	AOSG NNNN
	JRST FISTFL	;FIRST VERTEX FOR THIS CLUMP
	MOVE B,A
.I COMBIN<VXRNDS>	;COMBINE WITH FIRST VERTEX
	POPJ P,

FISTFL:	MOVEM A,VXRNDS
.I ,XSM(A)=XSUM,YSM(A)=YSUM
	POPJ P,
NFSUM:	0
NFSMA:	0
NFADS:	0
NNNN:	0	;COUNT OF LINES FOR FIRST VERTEX ALSO COUNTER OF HOW MANY TIMES THROUGH
VXRNDS:	0	;FIRST VERTEX
VLINCD:	0	;CURRENT VERTEX
NLINS:	0	;NEW LIST OF LINES

BSTDIS:	0	;BEST DISTANCE EVEN
	0	;BEST DISTANCE ODD
BSTLIN:	0	;BEST LINE EVEN
	0	;BEST LINE ODD
BSTRVR:	0	;DOES BEST EVEN LINE NEED TO BE REVERSED
	0	;DOES BEST  ODD INE HAVE TO BE REVERSED

ESYPLT:	SETZM NLINS	;REARRANGE LINES FOR EASY PLOTTING	***
	PUSHJ P,ESYPL6
.I GCL<LINES>
.I LINES=NLINS,NLINS=0	;?
	PUSHJ P,REVLIN	;REVERSE LINES LIST
	PUSHJ P,UNMAK	;UNMARK LINES
	PUSHJ P,VEXFIX	;FIX UP VERTICES
	SETZM GLMFLG	;?
	JRST GCMULT

VEXFIX:
.I VMAP<#VEXFI1,VERTEX>
	POPJ P,

VEXFI1:	MOVE E,A	;RESET NUMBER OF LINES ATTACHED TO THIS VERTEX
.I NSM(E)=LENGTH<VTR(E)>
	POPJ P,

ESYPL6:
.F ,XLOK=1024.0*16.0,YLOK=0
	JRST ESYNOT

ESYPLA:	SKIPE LFTDA(A)
	.VALUE
	SKIPE BSTRVR(T)
	PUSHJ P,RVREDG
ESYPL4:	PUSHJ P,MARKT
.F ,XLOK=LFTX2(A),YLOK=LFTY2(A),LFTRR(A)
	SETZM BSTLIN
.I VMAP<#ESYPL1,VTR(D)>	;TRY TO FIND EXACT MATCH
	SKIPE A,BSTLIN
	JRST DEDLOS	;WELL AT LEAST A CUL-DE-SAC EXACT MATCH EXISTS

ESYNOT:	PUSHJ P,INIBST
.I VMAP<#ESYPL5,LINES>
	MOVEI T,1	;ODD VERTICES
	PUSHJ P,ESYNUT
	MOVEI T,0	;EVEN VERTICES
ESYNUT:	SKIPE A,BSTLIN(T)
	JRST ESYPLA
	POPJ P,		;NO MORE LINES TO FOUND

INIBST:
.I ,,BSTLIN(0)=BSTLIN(1)=0,BSTDIS(0)=BSTDIS(1)=9.0^9
	POPJ P,

ESYPL5:	SKIPE LFTDA(A)
	POPJ P,
	SETZM ENDTWO
.F ,LFTX1(A),LFTY1(A),LFTLL(A)
	PUSHJ P,NOTEQT
	SETOM ENDTWO
.F ,LFTX2(A),LFTY2(A),LFTRR(A)

NOTEQT:	SKIPG T,NSM(D)
	.VALUE		;FEWER THAN 1 LINE GOES INTO VERTEX
	ANDI T,1	;ODD/EVEN BIT	
.F ,\(&-XLOK),\(&-YLOK)
	CAMGE B,C
	MOVE B,C
	CAML B,BSTDIS(T)
	POPJ P,
.I BSTLIN(T)=,BSTDIS(T)=,BSTRVR(T)=ENDTWO
	POPJ P,

DEDLOS:	SKIPE BSTRVR
	PUSHJ P,RVREDG
	JRST ESYPL4

ESYPL1:	HRRES A
	SKIPG A
	JRST ESYPL2
	SKIPE LFTDA(A)
	POPJ P,
	SETZM ENDTWO
	MOVE D,LFTRR(A)
ESYPL3:	MOVE T,NSM(D)	;EVEN AT OTHER END ?
	CAIG T,1
	JRST DEDEND
	SUB P,[3,,3]	;PAST VMAP AND ACLMLT
ESYPL7:	SKIPE ENDTWO
	PUSHJ P,RVREDG
	JRST ESYPL4	;??

DEDEND:	
.I BSTLIN=,BSTRVR=ENDTWO
	POPJ P,

ESYPL2:	MOVNS A
	SKIPE LFTDA(A)
	POPJ P,
	SETOM ENDTWO
	MOVE D,LFTLL(A)
	JRST ESYPL3

MARKT:	SKIPE LFTDA(A)
	.VALUE		;LINE ALREADY MARKED
	SETOM LFTDA(A)	;MARK LINE AND PUT ON LIST
	SKIPLE B,LFTLL(A)
	SKIPG C,LFTRR(A)
	.VALUE		;NO POINTERS
	SOSGE NSM(B)
	.VALUE		;VERTEX DEAD ALREADY
	SKIPN NSM(B)
	AOS VRTFLN
	SOSGE NSM(C)
	.VALUE		;VERTEX DEAD ALREADY
	SKIPN NSM(C)
	AOS VRTFLN
	PUSH P,A
	CONSV A,B,C,NLINS
	JRST POPAJ

QKVRTX:	PUSHJ P,REFREV	;GET VERTICES FAST (ASSUMING THEY EXIST)
.I ENTVRT<INTESY>		;VERTICES VERSUS VERTICES ***
	PUSHJ P,UNMARK
.I VMAP<#QKRTX2,LINES>
	SETZM GLMFLG	;?
	JRST GCMULT

QKRTX2:	MOVEM A,VLINCA
	SKIPE LFTLL(A)	;ALREADY USED
	JRST QKRTX3
.F ,LFTX1(A),LFTY1(A)
	PUSHJ P,QKYNBL
	MOVE A,VLINCA
QKRTX3:	SKIPE LFTRR(A)	;ALREADY USED ?
	POPJ P,
.F ,LFTX2(A),LFTY2(A)

QKYNBL:	SETZM NSUM
	SETZM VPTR
.F 0,XLOK=XSUM=,YLOK=YSUM=
	PUSHJ P,MULTIF
	MOVE B,A
.I ACLMLT<#QKYNL0>
	JRST GENVRT	;GENERATE VERTEX FOR THIS LOT


QKYNL0:	MOVEM A,VLINCB
	SKIPG A
	JRST QKYNL1
	SKIPE LFTLL(A)
	POPJ P,
	MOVEI U,LFTLL(A)
.F ,LFTX1(A),LFTY1(A)
QKYNL3:	CAMN B,XLOK
	CAME C,YLOK
	POPJ P,
	MOVE D,VXFREE
	HLRE D,(D)
	MOVEM D,(U)	;STORE POINTER TO VERTEX
	MOVE C,VLINCB	;PUT ON VERTEX LIST
	CONSV C,D,E,VPTR
	AOS NSUM
	POPJ P,

QKYNL1:	MOVNS A
	SKIPE LFTRR(A)
	POPJ P,
	MOVEI U,LFTRR(A)
.F ,LFTX2(A),LFTY2(A)
	JRST QKYNL3
;NEXT IS USED FOR SINGLE OBJECT OUTLINE HACK --

SINTLM:	0.1	;ANGLE LIMIT

XOTH:	BLOCK 3	;DELTA X
YOTH:	BLOCK 3	;DELTA Y
COTH:	BLOCK 3	;COSINES
SOTH:	BLOCK 3	;SINES
CRTH:	BLOCK 3	;ALL +, IF FORK, ONE + CENTRE ARM OF ARROW, ONE 0 CENTRE ARM OF T
LOTH:	BLOCK 3	;LINE ADDRESSES
SAGN:	0	;ZERO FOR T

FORK:		;IS VERTEX A FORK, SKIPS IF SO
	MOVE E,A
	MOVE D,NSM(E)
	CAIE D,3
	POPJ P,
.F XLOK=XSM(E),YLOK=YSM(E)
	SETZM T
.I VMAP<#FORK1,VTR(E)>
.F CRTH(0)=XOTH(1)*YOTH(2)-XOTH(2)*YOTH(1)
.F CRTH(1)=XOTH(2)*YOTH(0)-XOTH(0)*YOTH(2)
.F CRTH(2)=XOTH(0)*YOTH(1)-XOTH(1)*YOTH(0)

.F \(COTH(1)*SOTH(2)-COTH(2)*SOTH(1))
	CAMG A,SINTLM
	SETZM CRTH+0

.F \(COTH(2)*SOTH(0)-COTH(0)*SOTH(2))
	CAMG A,SINTLM
	SETZM CRTH+1

.F \(COTH(0)*SOTH(1)-COTH(1)*SOTH(0))
	CAMG A,SINTLM
	SETZM CRTH+2

.F SAGN=CRTH(0)*CRTH(1)*CRTH(2)

.F CRTH(0)=CRTH(0)*SAGN
.F CRTH(1)=CRTH(1)*SAGN
.F CRTH(2)=CRTH(2)*SAGN
	SKIPG CRTH
	POPJ P,
	SKIPG CRTH+1
	POPJ P,
	SKIPLE CRTH+2
	AOS (P)
	POPJ P,

FORK1:	SKIPGE A
	JRST FORK2
.F ,XOTH(T)=LFTX2(A)-XLOK,YOTH(T)=LFTY2(A)-YLOK
FORK3:
.F ,COTH(T)=LFTCA(A),SOTH(T)=LFTSA(A)
	MOVEM A,LOTH(T)
	AOS T
	POPJ P,

FORK2:	MOVNS A
.F ,XOTH(T)=LFTX1(A)-XLOK,YOTH(T)=LFTY1(A)-YLOK
	JRST FORK3

FLSCRM:		;FLUSH CENTRE ARM OF ARROWS
.I VMAP<#FLSAR1,VERTEX>
	JRST DETERG		;GO CLEAN UP

FLSAR1:	MOVE D,NSM(A)
	CAIE D,3
	POPJ P,
	PUSHJ P,FORK	;IS IT A FORK ?
	SKIPN SAGN	;IS IT A T ?
	POPJ P,		;ITS A FORK OR A T
	MOVEI T,2
	SKIPLE CRTH(T)	;FIND THE CENTRE ARM
	JRST BDARMF
	SOJGE T,.-2
	.VALUE

BDARMF:	MOVE A,LOTH(T)
	SETOM LFTDA(A)	;MARK IT FOR DELETION
	AOS LINFLN
	POPJ P,

BRKHCK:	PUSHJ P,FLSNUN	;SINGLE OBJECT OUTLINE HACK
	PUSHJ P,FLSCRM
	PUSHJ P,STRAIG
	PUSHJ P,SEGDIS
	PUSHJ P,FLSNUN
	PUSHJ P,FLSCRM
	PUSHJ P,STRAIG
	PUSHJ P,DETERG
	PUSHJ P,ESYPLT
	PUSHJ P,SEGDIS
	MOVE A,NVRT
	CAIE A,6
	JRST BRKLS1
	MOVE A,NLIN
	CAIE A,6
	JRST BRKLS2
	AOS (P)
	POPJ P,

BRKLS1:	PRINT _#1 VERTICES_
	POPJ P,

BRKLS2:	PRINT _#1 LINES_
	POPJ P,

XBRTP:	0	;X OF TOP
YBRTP:	0	;Y OF TOP
VBRTP:	0	;TOP VERTEX
LBRLS:	0	;LAST LINE TRACED

BRKTRC:
.F XBRTP=YBRTP=VBRTP=0
.I VMAP<#BRKHC1,VERTEX>	;FIND TOP VERTEX
.F XBRTP,YBRTP
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	PRINT _(_(%1F4.0 %2F4.0 
	PUSHJ P,RGHTRC	;FIND LINE GOING TO RIGHT
	MOVE E,VBRTP
	JRST BRKMR3

BRKMR1:
.F XSM(E),YSM(E)
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	PRINT %1F4.0 %2F4.0 )_(%1F4.0 %2F4.0 
BRKMR3:	PUSHJ P,TRACC	;TRACE ALONG TO NEXT LINE
	MOVEM F,LBRLS	;LAST LINE, SO WONT USE AGAIN
	CAME E,VBRTP	;COMPLETED CIRCUIT ?
	JRST BRKMR1	;NO
.F XBRTP,YBRTP
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	PRINT %1F4.0 %2F4.0 )_)
	POPJ P,

BRKHC1:	MOVE B,XSM(A)
	MOVE C,YSM(A)
	CAMG C,YBRTP
	POPJ P,
	MOVEM B,XBRTP
	MOVEM C,YBRTP
	MOVEM A,VBRTP
	POPJ P,

RGHTRC:	MOVE E,VBRTP
.I VMAP<#RGHTR1,VTR(E)>
	POPJ P,

RGHTR1:	SKIPGE A
	JRST RGHTR2
	MOVE B,LFTX2(A)	;OTHER ENDS X
	CAMGE B,XBRTP
	MOVEM A,LBRLS	;MARK AS NOT TO BE USED
	POPJ P,

RGHTR2:	MOVNS A
	MOVE B,LFTX1(A)
	CAMGE B,XBRTP
	MOVNM A,LBRLS
	POPJ P,

TRACC:	MOVE G,E
.I VMAP<#TRAC1,VTR(G)>
	POPJ P,

TRAC1:	CAMN A,LBRLS	;LAST LINE USED ?
	POPJ P,		;YES
	SKIPGE A
	JRST TRAC2
	MOVE E,LFTRR(A)
	MOVN F,A
	POPJ P,

TRAC2:	MOVNS A
	MOVE E,LFTLL(A)
	MOVE F,A
	POPJ P,


READV:	PUSHJ P,TTINR	;SETUP READING VSCAN DATA FROM DISK
	SETOM DSKINF
	POPJ P,

READL:	PUSHJ P,TTINR	;INPUT ASCII LINE SEGMENTS
READM:	MOVEI A,0
	HRLM A,INOP
	PUSHJ P,OPNDI
	POPJ P,
	PUSH P,ZR
	MOVE ZR,DSKONI
.I QITADR=#READ1
	PUSHJ P,EAT
READ1:	SETZM QITADR
	POP P,ZR
	JRST CLONDI

WRITEV:	PUSHJ P,TTINW	;SETUP WRITING OF VSCAN DATA TO DSK
	SETOM DSKOUF
	POPJ P,

WRITEL:	PUSHJ P,TTINW
WRITEM:	MOVEI A,1	;OUTPUT ASCII LINE SEGMENTS
	HRLM A,ONOP
	PUSHJ P,OPNDO
	POPJ P,
	PUSH P,ZR
	MOVE ZR,DSKONO
.I QITADR=#WRITL1
	PUSHJ P,SEGOUT
WRITL1:	SETZM QITADR
	POP P,ZR
	JRST CLONDO

DSKONI:	DSIFLG+TTOFLG+DISFLG	;DSK INPUT (AND TTY OUT FOR ERROR MESSAGES)
DSKONO:	DSOFLG+DISFLG		;DSK OUTPUT
;COMMUNICATION WITH OTHER PROGRAMS

ZOMWAT:	MOVEI A,60.	;READ COMMAND FILE AND EXECUTE
	.SLEEP A,
	SKIPA
ZOOM:	.SUSET [.SSNAME,,CLUUSR]
	.OPEN DSIC,CLOPEN
	JRST ZOMWAT
ZIIM:	SKIPE ZOMSPK
	PRINT _SCAN_
	.CLOSE DSIC,
	.FDELE CLOPEN
	JFCL

	MOVE A,[SIXBIT /HORN/]
	SKIPE BRCKFL
	MOVE A,[SIXBIT /BRICK/]
	MOVEM A,ONOP+1
	MOVE A,[SIXBIT /LINES/]
	MOVEM A,ONOP+2
	MOVE A,[SIXBIT /VIS/]
	MOVEM A,FRMSNM
	MOVEM A,FRMSOM
ZOPEL:	SKIPE LOKTOO
	PUSHJ P,LOOK	;QUICK SCAN TO FIND AREA OF INTEREST
	PUSH P,HANGON
	SETZM HANGON
	PUSHJ P,SCAN1	;NOW DO FULL SCAN AND ANALYSIS
	POP P,HANGON

	SKIPE ZOMSPK
	PRINT _O.K. ? 
	MOVEI A,"Y
	SKIPE ZOMSPK
	PUSHJ P,TYI
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST .-2
	CAIE A,"Y
	JRST ACCEPT
ZOMRET:	PUSHJ P,PRERET
	JRST ZOOM

GETCHR:	.IOT DSIC,A
	SKIPE ZOMSPK
	PUSHJ P,TYO
	POPJ P,

CLUUSR:	SIXBIT /VIS   /
CLOPEN:	0,,(SIXBIT/DSK/)	;CLU
	SIXBIT /SCAN/
	SIXBIT /CALL/
	0

PRERET:	.FDELE CLOPEN	;DELETE GIVEN FILE
	JFCL		;GONE ALREADY ?
	SKIPE BRCKFL
	JRST PRERE1	;SINGLE OBJECT OUTLINE HACK
	PUSHJ P,WRITEM
PRERE2:	SKIPE ZOMSPK
	PRINT _DONE_
	POPJ P,


PRERE1:	PUSHJ P,BRICK	;OUTPUT BRICK
	SKIPA		;LOST
	JRST PRERE2
	SUB P,[1,,1]
	JRST ZOPEL	;AH WELL, START AGAIN

LOKTOO:	-1	;TO CAUSE LOOK TO HAPPEN FIRST
BRCKFL:	0	;TO OUTPUT BRICKS
ZOMSPK:	-1	;OUTPUT COMMANDS AS THEY ARE EXECUTED


BRICK:	PUSHJ P,BRKHCK
	POPJ P,		;LOST
	.SUSET [.SSNAME,,BRKUSR]
	.OPEN DSOC,BRKOUT
	STOP _OPEN LOST_
	PUSH P,ZR
	MOVEI ZR,DSOFLG
	PUSHJ P,BRKTRC
	POP P,ZR
	.CLOSE DSOC,
	AOS (P)
	POPJ P,

BRKUSR:	SIXBIT /VIS/
BRKOUT:	1,,(SIXBIT/DSK/)
	SIXBIT /BRICK/
	SIXBIT /LINES/

EAT:	HEAD READ IN
	SKIPN VFREE		;SLURP DOWN A LIST OF QUADRUPLES
	PUSHJ P,FSTINT
	PUSHJ P,RESETL
	PUSHJ P,REFREL
	PUSHJ P,ADISON
	SETZM LFITLL
	SETZM LFITRR
	SETZM LFITDA
.I LFITNN=1.0
	SETZM NECH
	SETZM NLIN
	SETZM NVRT
	SETZM NKJN
	SETZM NTJN
	SETZM NXJN
	MOVE T,[17000.0]
	MOVE U,T	;X-MIN IN T, Y-MIN IN V
	SETZB V,W	;X-MAX IN U, Y-MAX IN W
	PUSHJ P,TYI
	CAIE A,"(
	JRST .-2
	PUSHJ P,EAT1
	JRST .-1
	JRST EATEND

EAT1:	PUSHJ P,TYI
	SKIPL A
	CAIN A,")
	JRST APOPJ
	CAIE A,"(
	JRST EAT1
.I GASPX<>,GASPY<>
	SKIPE DISFLX
	PUSHJ P,UNVDST
.I LFITX2=,LFITY2=
.I GASPX<>,GASPY<>
	SKIPE DISFLX
	PUSHJ P,UNVDST
.I LFITX1=,LFITY1=
	PUSHJ P,GENVLT	;STORE AWAY LINE
	PUSHJ P,TYI
	CAIE A,")
	JRST .-2
	POPJ P,

GASP:	PUSHJ P,RDNUM
	SKIPGE A
	.VALUE		;NEGATIVE NUMBER ON INPUT
	TLNN A,777000
	FSC A,233
	CAML A,[1024.0]
	.VALUE		;TOO LARGE NUMBER ON INPUT
	FMPR A,SCALFT
	SETOM UNRCHF
	POPJ P,

GASPX:	PUSHJ P,GASP
	FADR A,INXORG
	FSC A,4
	CAMLE A,V
	MOVE V,A 
	CAMGE A,T
	MOVE T,A 
	POPJ P,

GASPY:	PUSHJ P,GASP
	FADR A,INYORG
	FSC A,4
	CAMLE A,W
	MOVE W,A 
	CAMGE A,U
	MOVE U,A 
	POPJ P,


EATEND:	FIX W
	FIX V
	FIX U
	FIX T
.I TVL(0)=U,TVL(1)=V,TVU(0)=W,TVU(1)=X
	PUSHJ P,SETOP	;TO SET UP MULTI-ENTRY LIMITS
	JRST SEGDIS


;REGENERATE INTERNAL DATA AFTER READ-IN

REGEN:	PUSHJ P,ANGET	;GET ALL ANGLES, SIN, COS AND C3 ETC - REGENERATE DATA BASES
	PUSHJ P,DETERG	;CLEAN UP DATA -CREATE DATA BASE FOR STUFF READ IN
	PUSHJ P,QKVRTX	;GET VERTEX DATA BASE
	PUSHJ P,ESYPLT	;REARRANGE FOR EASY PLOTTING
	HEAD REJUVENATED
	JRST SEGDIS	;DISPLAY THE LINE-SEGMENTS

EXTRA:	32.

SCALFT:	1.0	;SCALE FACTOR
INXORG:	0	;X OFFSET ADD TO INPUT
INYORG:	0	;Y OFFSET ADD TO INPUT

DISFLX:	-1	;NON-ZERO TO HACK DISTORTION

ROOT3:	1.7320508

;VIDISECTOR DISTORTION HANDLING

;	UNDISTORTING DATA -COMES FROM DISK VIA REDDAT

DSDTSZ==256.

XCORD:	BLOCK DSDTSZ	;X COORDINATES OF GRID
YCORD:	BLOCK DSDTSZ	;Y COORDINATES OF GRID
BSCRD:	BLOCK DSDTSZ	;SENSITIVITY AT GRID POINTS

SCLX:	194.0	;VIDI UNITS PER XD MM
SCLXY:	0.0
CNTX:	8192.0	;HORIZ CENTRE OF VIDI
SCLYX:	0.0
SCLY:	-216.0	;VIDI UNITS PER YD MM
CNTY:	8192.0	;VERTIC CENTRE OF VIDI
DELD:	1.0	;SCLX*SCLY-SCLXY*SCLYX 

DELX:	5.5037190	;HORIZONTAL SPACING OF GRID IN MM'S
DELY:	5.5037190	;VERTICAL SPACING OF GRID IN MM'S

XNT:	-24.767063	;CORNER X COORDINATE OF GRID
YNT:	-24.767063	;CORNER Y COORDINATE OF GRID

NNX:	10.	;NUMBER OF POINTS HORIZONTALLY IN GRID
NNY:	10.	;NUMBER OF POINTS VERTICALLY IN GRID
NARSZ:	0	;NNX*NNY

DATIOB:	XCORD-.,,XCORD	;IO POINTER

;		UNDISTORTION AND OTHER COORDINATE HANDLING CRUFT

LIMCRD:	SKIPGE A
	SETZM A
	CAMLE A,[16383.0]
	MOVE A,[16383.0]
	SKIPGE B
	SETZM B
	CAMLE B,[16383.0]
	MOVE B,[16383.0]
	POPJ P,

QAL:	0
QBL:	0

LINMTV:	;LINEAR COORDINATE GETTER INPUT IN MM'S
;		OUTPUT IN FLOAT VIDI COORDS
	PUSH P,C
.F QAL=,QBL=
.F QAL*SCLX+QBL*SCLXY+CNTX,$
.F QAL*SCLYX+QBL*SCLY+CNTY
	PUSHJ P,LIMCRD
	POP P,C
	POPJ P,

LINVTM:	;INVERSE OF LINMTV INPUT IN FLOAT VIDI COORDS
;		OUTPUT IN MM'S
	PUSH P,C
	PUSHJ P,LIMCRD
.F QAL=,QBL=
.F QAL=QAL-CNTX,QBL=QBL-CNTY
.F (QAL*SCLY-QBL*SCLXY)/DELD,$
.F -(QAL*SCLYX-QBL*SCLX)/DELD
	POP P,C
	POPJ P,
DISMTV:	PUSH P,A	;INTERPOLATE - X,Y	- SKIPS IF IN VIEW
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,F
	FSBR A,XNT
	FSBR B,YNT
	FDVR A,DELX
	FDVR B,DELY	;I
	FMPR A,ROOT3
	FSBR A,B
	FSC A,-1	;K
	MOVE E,A
	MOVE D,B
	FIX E
	SKIPL F		;FIXED K IN F
	CAML F,NNY
	JRST OUTRAN
	FIX D
	SKIPL E		;FIXED I IN E
	CAML E,NNY
	JRST OUTRAN
	MOVE D,E
	MOVE C,F
	FLOAT C
	FLOAT D
	FSBRM A,C	;DELTA K
	FSBRM B,D	;DELTA I
	IMUL E,NNY	;?
	ADD E,F		;DOUBLE SUBSCRIPTING F,K
	MOVE F,E
	ADD F,NNY	;I+1,K
	SKIPE XCORD(E)
	SKIPN XCORD(F)
	JRST OUTRAN
	SKIPN XCORD+1(E)
	JRST OUTRAN
;.F (1.0-C-D)*BSCRD(E)+BSCRD(F)*D+BSCRD(E+1)*C
;	PUSH P,A
.F (1.0-C-D)*YCORD(E)+YCORD(F)*D+YCORD(E+1)*C
	PUSH P,A
.F (1.0-C-D)*XCORD(E)+XCORD(F)*D+XCORD(E+1)*C
;	POP P,C
	POP P,B
	POP P,F
	POP P,E
	POP P,D
	POP P,C
	SUB P,[2,,2]
	AOS (P)
	POPJ P,

OUTRAN:	POP P,F
	POP P,E
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	JRST LINMTV
UNVDST:	;DISTORT (USE PRE SCAN) FLOAT VIDI IN, FLOAT VIDI OUT
	PUSHJ P,LINVTM	;CONVERT TO MM'S
	PUSHJ P,DISMTV	;CONVERT BACK
	JFCL
	POPJ P,

DAMP:	0.8	;DAMPING FACTOR IN ITERATION LOOP

ITRVRM:	PUSHJ P,UNVDST	;GO FORWARD ONCE
	FSBR A,XNOT	;FORM ERROR
	FSBR B,YNOT
	MOVNS A
	MOVNS B
	FMPR A,DAMP
	FMPR B,DAMP
	FADRB A,XNAT	;UPDATE GUESSES - THIS COULD BE DONE MORE CLEVERLY
	FADRB B,YNAT
	POPJ P,


DISVTM:	;INVERSE INTERPOLATOR FLOAT VIDI IN, MM'S OUT
	PUSHJ P,UNMDST
	JRST LINVTM

UNMDST:	;UNDISTORT (USE POST SCAN) FLOAT VIDI IN FLOAT VIDI OUT
;	SLOW AND MAY NOT BE ACCURATE, COULD BE IMPROVED NO DOUBT
.F XNOT'=XNAT'=,YNOT'=YNAT'=
	PUSHJ P,ITRVRM
	PUSHJ P,ITRVRM
	JRST ITRVRM	;3 ITERATIONS ARE PROBABLY ENOUGH


;	GETTING DISTORTION DATA OFF THE DISK

DATCHN==6

DATIPN:	2,,(SIXBIT/DSK/)
	SIXBIT/DISTORCOORDS/

REDDAT:	.OPEN DATCHN,DATIPN
	STOP _DSKC WONT OPEN-REDDAT
	MOVE A,DATIOB
	.IOT DATCHN,A
	.CLOSE DATCHN,
	POPJ P,
;REGENERATE INTERNAL DATA AFTER READ-IN

REGEN:	PUSHJ P,ANGET	;GET ALL ANGLES, SIN, COS AND C3 ETC - REGENERATE DATA BASES
	PUSHJ P,DETERG	;CLEAN UP DATA -CREATE DATA BASE FOR STUFF READ IN
	PUSHJ P,QKVRTX	;GET VERTEX DATA BASE
	PUSHJ P,ESYPLT	;REARRANGE FOR EASY PLOTTING
	HEAD REJUVENATED
	JRST SEGDIS	;DISPLAY THE LINE-SEGMENTS

EXTRA:	32.

SCALFT:	1.0	;SCALE FACTOR
INXORG:	0	;X OFFSET ADD TO INPUT
INYORG:	0	;Y OFFSET ADD TO INPUT

DISFLX:	-1	;NON-ZERO TO HACK DISTORTION

ROOT3:	1.7320508

;VIDISECTOR DISTORTION HANDLING

;	UNDISTORTING DATA -COMES FROM DISK VIA REDDAT

DSDTSZ==256.

XCORD:	BLOCK DSDTSZ	;X COORDINATES OF GRID
YCORD:	BLOCK DSDTSZ	;Y COORDINATES OF GRID
BSCRD:	BLOCK DSDTSZ	;SENSITIVITY AT GRID POINTS

SCLX:	194.0	;VIDI UNITS PER XD MM
SCLXY:	0.0
CNTX:	8192.0	;HORIZ CENTRE OF VIDI
SCLYX:	0.0
SCLY:	-216.0	;VIDI UNITS PER YD MM
CNTY:	8192.0	;VERTIC CENTRE OF VIDI
DELD:	1.0	;SCLX*SCLY-SCLXY*SCLYX 

DELX:	5.5037190	;HORIZONTAL SPACING OF GRID IN MM'S
DELY:	5.5037190	;VERTICAL SPACING OF GRID IN MM'S

XNT:	-24.767063	;CORNER X COORDINATE OF GRID
YNT:	-24.767063	;CORNER Y COORDINATE OF GRID

NNX:	10.	;NUMBER OF POINTS HORIZONTALLY IN GRID
NNY:	10.	;NUMBER OF POINTS VERTICALLY IN GRID
NARSZ:	0	;NNX*NNY

DATIOB:	XCORD-.,,XCORD	;IO POINTER

;		UNDISTORTION AND OTHER COORDINATE HANDLING CRUFT

LIMCRD:	SKIPGE A
	SETZM A
	CAMLE A,[16383.0]
	MOVE A,[16383.0]
	SKIPGE B
	SETZM B
	CAMLE B,[16383.0]
	MOVE B,[16383.0]
	POPJ P,

QAL:	0
QBL:	0

LINMTV:	;LINEAR COORDINATE GETTER INPUT IN MM'S
;		OUTPUT IN FLOAT VIDI COORDS
	PUSH P,C
.F QAL=,QBL=
.F QAL*SCLX+QBL*SCLXY+CNTX,$
.F QAL*SCLYX+QBL*SCLY+CNTY
	PUSHJ P,LIMCRD
	POP P,C
	POPJ P,

LINVTM:	;INVERSE OF LINMTV INPUT IN FLOAT VIDI COORDS
;		OUTPUT IN MM'S
	PUSH P,C
	PUSHJ P,LIMCRD
.F QAL=,QBL=
.F QAL=QAL-CNTX,QBL=QBL-CNTY
.F (QAL*SCLY-QBL*SCLXY)/DELD,$
.F -(QAL*SCLYX-QBL*SCLX)/DELD
	POP P,C
	POPJ P,
DISMTV:	PUSH P,A	;INTERPOLATE - X,Y	- SKIPS IF IN VIEW
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,F
	FSBR A,XNT
	FSBR B,YNT
	FDVR A,DELX
	FDVR B,DELY	;I
	FMPR A,ROOT3
	FSBR A,B
	FSC A,-1	;K
	MOVE E,A
	MOVE D,B
	FIX E
	SKIPL F		;FIXED K IN F
	CAML F,NNY
	JRST OUTRAN
	FIX D
	SKIPL E		;FIXED I IN E
	CAML E,NNY
	JRST OUTRAN
	MOVE D,E
	MOVE C,F
	FLOAT C
	FLOAT D
	FSBRM A,C	;DELTA K
	FSBRM B,D	;DELTA I
	IMUL E,NNY	;?
	ADD E,F		;DOUBLE SUBSCRIPTING F,K
	MOVE F,E
	ADD F,NNY	;I+1,K
	SKIPE XCORD(E)
	SKIPN XCORD(F)
	JRST OUTRAN
	SKIPN XCORD+1(E)
	JRST OUTRAN
;.F1.0-C-D)*BSCRD(E)+BSCRD(F)*D+BSCRD(E+1)*C
;	PUSH P,A
.F (1.0-C-D)*YCORD(E)+YCORD(F)*D+YCORD(E+1)*C
	PUSH P,A
.F (1.0-C-D)*XCORD(E)+XCORD(F)*D+XCORD(E+1)*C
;	POP P,C
	POP P,B
	POP P,F
	POP P,E
	POP P,D
	POP P,C
	SUB P,[2,,2]
	AOS (P)
	POPJ P,

OUTRAN:	POP P,F
	POP P,E
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	JRST LINMTV
UNVDST:	;DISTORT (USE PRE SCAN) FLOAT VIDI IN, FLOAT VIDI OUT
	PUSHJ P,LINVTM	;CONVERT TO MM'S
	PUSHJ P,DISMTV	;CONVERT BACK
	JFCL
	POPJ P,

DAMP:	0.8	;DAMPING FACTOR IN ITERATION LOOP

ITRVRM:	PUSHJ P,UNVDST	;GO FORWARD ONCE
	FSBR A,XNOT	;FORM ERROR
	FSBR B,YNOT
	MOVNS A
	MOVNS B
	FMPR A,DAMP
	FMPR B,DAMP
	FADRB A,XNAT	;UPDATE GUESSES - THIS COULD BE DONE MORE CLEVERLY
	FADRB B,YNAT
	POPJ P,


DISVTM:	;INVERSE INTERPOLATOR FLOAT VIDI IN, MM'S OUT
	PUSHJ P,UNMDST
	JRST LINVTM

UNMDST:	;UNDISTORT (USE POST SCAN) FLOAT VIDI IN FLOAT VIDI OUT
;	SLOW AND MAY NOT BE ACCURATE, COULD BE IMPROVED NO DOUBT
.F XNOT'=XNAT'=,YNOT'=YNAT'=
	PUSHJ P,ITRVRM
	PUSHJ P,ITRVRM
	PUSHJ P,ITRVRM	;3 ITERATIONS ARE PROBABLY ENOUGH
	POPJ P,		;TO MM'S


;	GETTING DISTORTION DATA OFF THE DISK

DATCHN==6

DATIPN:	2,,(SIXBIT/DSK/)
	SIXBIT/DISTORCOORDS/

REDDAT:	.OPEN DATCHN,DATIPN
	STOP _DSKC WONT OPEN-REDDAT
	MOVE A,DATIOB
	.IOT DATCHN,A
	.CLOSE DATCHN,
	POPJ P,
PUSHJ P,RESETL
	PUSHJ P,REFREL
	PUSHJ P,ADISON
	SETZM LFITLL
	SETZM LFITRR
	SETZM LFITDA
.I LFITNN=1.0
	SETZM NECH
	SETZM NLIN
	SETZM NVRT
	SETZM NKJN
	SETZM NTJN
	SETZM NXJN
	MOVE T,[17000.0]
	MOVE U,T	;X-MIN IN T, 