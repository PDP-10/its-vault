
TITLE TOB'S LINE FINDER

DISALL==1	;DISPLAY ROUTINES => ARRAY ALLOCATOR
LIBRAR==1	;LIBRARY ROUTINES
COMMND==1	;COMMAND INTERPRETOR => INPUT AND OUTPUT ROUTINES
CNTRLX==1	;CONTROL CHARACTER HANDLING
FLEFLG==1	;FILE NAME READING
STMPIT==1	;TIME AND DATE STAMPING
CNTRLA==1	;ABILITY TO REVERT TO TOP-LEVEL AND RESUME

.INSRT SUPPRT >

;BLOCK ASSIGNMENTS

PATCHL==100	;LENGTH PATCH
TVLONG==1000	;LENGTH BIG BUFFER - PDL FOR INHOMOGENEOUS POINTS
VSPDLL==5*400	;LENGTH SEGMENT BLOCK - 256. SEGMENTS
TVROWL==2000	;LENGTH ROW FOR SCAN - 1024. POINTS
PROJLL==777	;LENGTH PROJ HASH-CODE BLOCK


VEXTVF==0	;EXTRA CRUFT NOT USED YET
PROJFL==0	;PROJECTION


SWIPE:	SETZM (A)	;WIPE ARRAY (A) OF LENGTH (B)
	ADD B,A
	HRL A,A
	AOS A
	BLT A,-1(B)
	POPJ P,

SLURP:	HRL B,A		;COPY ARRAY (B) INTO ARRAY (A) OF LENGTH (C)
	MOVSS B
	ADD A,C
	BLT B,-1(A)
	POPJ P,

DSPLAY:	-1	;NON-ZERO TO GENERATE DISPLAY WHILE PROCESSING
HANGON:	-1	;TO WAIT BETWEEN MAYOR STEPS FOR CHARACTER TYPED

TIME:	.SUSET [.RRUNT,,A]	;GET RUN TIME IN A, REAL TIME IN B
	MULI A,4096.
	DIV A,[1000000.]
	.RDTIME B,
	MULI B,1000.
	DIVI B,30.
	POPJ P,

DEFINE HEAD ARG
	MOVEI A,[SIXBIT \ ARG!!\]
	MOVEM A,VERSE
TERMIN

FREARY:	-1	;FREE STORAGE ARRAY - MUST BE FIRST

AVCONS=PRT0	;PROTECTED POINTER TO BEGINNING OF FS (MUST BE AFTER FS:)

;VIDISECTOR IN LOG MODE
;X4 ATTENUATION SWITCH IN
;PHOTOCATHODE REFERENCE (NOT CRITICAL)
;REFERENCE GAIN 4.0 (NOT CRITICAL)
;400 CPS POWER FOR SUN-GUNS (NOT CRITICAL)


START:	JSR INIT
.I RSTART=#ACCEPT,INTADR=#CLKINT,CROSSZ=20
.I FREARY=ARYALS<FREARY,FREINC>	;TO MAKE SURE ITS FIRST
.I AVCONS=ARYORG(A)
	MOVE A,[SIXBIT /SCENE/]	;SETUP INITIAL FILE NAMES
	MOVEM A,INOP+1
	MOVEM A,ONOP+1
	MOVE A,[SIXBIT />/]
	MOVEM A,INOP+2
	MOVEM A,ONOP+2
	MOVE A,[SIXBIT /VIS/]
	MOVEM A,FRMSNM
	MOVEM A,FRMSOM
	SKIPE SIXRUN
	PUSHJ P,OPNSIX
	.SUSET [.SSNAME,,FRMSNM]
	.SUSET [.RMASK,,INTENA]	;GET CURRENTLY ENABLED INTERUPTS
	PUSHJ P,REDDAT	;READ DISTORTION DATA
	JRST ACCEPT


WAITP:	SKIPE DSPLAY
	SKIPN HANGON
	POPJ P,
	STRIKE $&
	PUSHJ P,TYI
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST .-2
	CAIN A,"?
	SETZM DSPLAY
	CAIN A,177	;RESET ON RUBOUT
	SETZM HANGON
	POPJ P,

;VARIOUS MACROS FOR SIMPLE LIST OPERATIONS

;POINTERS IN A AND B GET PUT INTO NEW WORD, POINTED TO BY C WHEN DONE.
DEFINE	CONS A,B,C
	SKIPN C,VFREE
	PUSHJ P,FSUSUP
	HRL C,(C)
	HLRZM C,VFREE
	HRLM A,(C)
	HRRM B,(C)
TERMIN


;WORD IN A IS PUT BACK ON FS LIST
DEFINE	UNCONS A,C
	HRRZ C,VFREE
	HRRZM C,(A)
	HRRZM A,VFREE
TERMIN


;ADD (A) ONTO FRONT OF LIST POINTED TO BY VAR
DEFINE	CONSV A,B,C,VAR
	HRRZ B,VAR
	CONS A,B,C
	HRRM C,VAR	;?
TERMIN


;TAKE POINTER OFF LIST (PUT IN C) POINTED TO BY VAR - DIE IF NONE LEFT
DEFINE	CDRV C,VAR,ERRR
	SKIPN C,VAR
	JRST ERRR
	HRL C,(C)
	HLRZM C,VAR
TERMIN


;TAKE NEXT ELEMENT OFF LIST (PUT IN B) POINTED TO BY VAR - POPJ IF NONE LEFT
DEFINE NEXT VAR,C,B
	SKIPN C,VAR
	POPJ P,
	HRL C,(C)
	HLRZM C,VAR
	HLRZ B,(C)
TERMIN


;CONS WITH NIL
DEFINE NCONS A,C,
	SKIPN C,VFREE
	PUSHJ P,FSUSUP
	HRL C,(C)
	HLRZM C,VFREE	;?
	HRLZM A,(C)
TERMIN

;SEVERAL FUNCTIONS FOR HANDLING EDGE-FRAGMENT CHAIN HEADERS

EDGFR:	PUSHJ P,GCEDG	;GENERATE FREE EDGE FRAGMENT CHAIN BLOCKS
EDGFR1:
.I FREGEN<#TVSPDL,#EDGLL,#TVSPDL+#VSPDLL>
	HRRZM A,VSFREE	;FREE SEGMENT LIST POINTER
	SETZM NECH
	SETZM VEDGES
	SETZM XEDGES
	SETZM YEDGES
	POPJ P,

GCTEDG:	0	;CAUSES GC OF EDGES WHEN THEY HAVE BEEN USED

GCEDG:		;GC EDGE CHAINS
.I VSMAP<#GCOED>
.I GCLI<#XEDGES>
.I GCLI<#YEDGES>
.I GCLI<#VSFREE>
	POPJ P,

GCOED:	JUMPE A,TPOPJ
	HRRZS (B)	;FLUSH POINTER 
	JRST GCL

GCEDGS:	SKIPN XEDGES	;REVIVE FREE EDGE LIST
	SKIPE YEDGES
	SKIPA
	POPJ P,
.I VSMAP<#GCOED>
.I APPEND<#VSFREE,#XEDGES>
	SETZM XEDGES
.I APPEND<#VSFREE,#YEDGES>
	SETZM YEDGES
.I APPEND<#VSFREE,#VEDGES>
	SETZM VEDGES
	SETZM NECH
	POPJ P,

;FUNCTION TO GENERATE A NEW EDGE-FRAGMENT HEADER CAN BE FOUND AT VLINKB

REFREE:	SKIPE VSFREE	;REFRESH CHAIN HEADER BLOCK LIST
	PUSHJ P,GCEDGS	;JUST GC THINGS
	SKIPN VSFREE
	PUSHJ P,EDGFR	;GENERATE NEW ONES
	POPJ P,

;SEVERAL FUNCTIONS TO HANDLE LINE BLOCKS

LINFR:	PUSHJ P,GCLIN	;SET UP FREE LINE BLOCKS
LINFR1:
.I FREGEN<#SEGLO,#LFTLNT,#SEGHI>
	HRRZM A,VLFREE
	SETZM NLIN
	SETZM LINES
	POPJ P,

GCLIN:		;GC LINES AND FREE LINES
.I GCLI<#LINES>
.I GCLI<#VLFREE>
	POPJ P,

GCLINS:	SKIPN LINES	;REVIVE FREE LINES LIST
	POPJ P,
.I APPEND<#VLFREE,#LINES>
	SETZM NLIN
	SETZM LINES
	POPJ P,

ERRLT:	STOP _NO MORE SPACE FOR LINES

GENVLT:	CDRV A,VLFREE,ERRLT
	MOVE B,LINES	;GENERATE A NEW LINE
	HRRM B,(A)
	HRRZM A,LINES
	HLRZ A,(A)
	PUSH P,A
.I SLURP<,#LFITB,#LFTLNT>
	POP P,A
	AOS NLIN
	POPJ P,

REFREL:	SKIPE VLFREE	;REFRESH LINE BLOCKS
	PUSHJ P,GCLINS	;JUST GC THINGS
	SKIPN VLFREE
	PUSHJ P,LINFR	;GENERATE NEW ONES
	POPJ P,

;SEVERAL FUNCTIONS TO HANDLE VERTEX BLOCKS

VRTFR:	PUSHJ P,GCVRT	;SET UP FREE VERTEX BLOCKS
VRTFR1:
.I FREGEN<#VRTBEG,#VBLL,#VRTEND>
	HRRZM A,VXFREE
	SETZM NVRT
	SETZM VERTEX
	POPJ P,

GCVRT:		;GC VERTICES
.I VMAP<#VRTGC1,VERTEX>
.I GCLI<#VERTEX>
.I GCLI<#VXFREE>
	POPJ P,

VRTGC1:	MOVE B,VTR(A)
	SETZM VTR(A)
	TLNN B,-1	;GARBAGE WORD ?
	SKIPN A,B
	POPJ P,
	JRST GCL

GCVRTS:	SKIPN VERTEX	;REVIVE FREE VERTEX LIST
	POPJ P,
.I VMAP<#VRTGC1,VERTEX>
.I APPEND<#VXFREE,#VERTEX>
	SETZM NVRT
	SETZM VERTEX
	POPJ P,

ERRVT:	STOP _NO MORE SPACE FOR VERTICES

GENVRT:	CDRV A,VXFREE,ERRVT
	MOVE B,VERTEX	;GENERATE A NEW VERTEX
	HRRM B,(A)
	HRRZM A,VERTEX
	HLRZ A,(A)
	PUSH P,A
.I SLURP<,#XSUM,#VBLL>
	POP P,A
	AOS NVRT
	POPJ P,

REFREV:	SKIPE VXFREE	;REFRESH VERTEX BLOCKS
	PUSHJ P,GCVRTS	;JUST GC THINGS
	SKIPN VXFREE
	PUSHJ P,VRTFR	;GENERATE NEW ONES
	POPJ P,

FREGEN:	MOVEI D,0	;GENERATE LIST OF FREE BLOCKS (START AT A,SIZE IN B,FINISH AT C)
	SUB C,B
GOALN:	CONS A,D,E
	MOVE D,E
	ADD A,B
	CAMGE A,C
	JRST GOALN
	HRRZ A,D	;RETURN LIST POINTER
	POPJ P,

REFRES:	PUSHJ P,REFREL
	PUSHJ P,REFREV
	JRST REFREE

REFRAS:	PUSHJ P,EDGFR1
	PUSHJ P,LINFR1
	JRST VRTFR1

XEDGES:	0	;EDGE LIST FOR X SCAN
YEDGES:	0	;EDGE LIST FOR Y SCAN
VEDGES:	0	;CURRENT EDGE LIST
VSFREE:	0	;LIST OF FREE SEGMENT BLOCKS, INIT IN EDGFR

LINES:	0	;SEGMENTED EDGES (LINES)
VLFREE:	0	;LIST OF FREE LINE BLOCKS, INIT IN LINFR

VERTEX:	0	;VERTICES
VXFREE:	0	;LIST OF FREE VERTICES, INIT IN VRTFR

VFREE:	0	;FREE STORAGE LIST, INIT IN TVINIT, GROWN IN FSUSUP

NLIN:	0	;NUMBER OF LINES
NVRT:	0	;NUMBER OF VERTICES
NECH:	0	;NUMBER OF EDGE CHAIN HEADERS IN USE

NKJN:	0	;NUMBER OF K-JOINTS
NTJN:	0	;NUMBER OF T-JOINTS
NXJN:	0	;NUMBER OF X-JOINTS

;SEVERAL FUNCTIONS TO HANDLE THE FREE STORAGE LIST

FSTINT:	MOVE C,FREARY
.I FREPRP<(VFREE=(ARYORG(C)+ARYL(C)-FREINC)),FREINC>	;SET UP FREE STORAGE LIST
	POPJ P,

FREPRP:	ADD B,A		;PREPARE FS ADR IN A ,LENGTH IN B
	AOS A
FREPR1:	MOVEM A,-1(A)
	CAMGE A,B
	AOJA A,FREPR1
	SETZM -1(A)	;TERMINATE IT
	POPJ P,

FSUSUP:	PUSH P,A	;RAN OUT OF FREE STORAGE
	PUSH P,B
	PUSH P,C
.I FREARY=ARYALS<FREARY,ARYL(A)+FREINC>	;EXPAND ARRAY
	MOVE C,FREARY
	MOVE A,ARYL(C)
	LSH A,-12
	SKIPE TLLFRE
	STRIKE _FS #1 
	PUSHJ P,FSTINT
	POP P,C
	POP P,B
	POP P,A
	SOS (P)
	SOS (P)
	POPJ P,		;TRY AGAIN

TLLFRE:	0	;-1 TO TELL IF FS GROWS
FREINC:	2000	;INCREMENT TO GROW FS IN

;VARIOUS LIST PROCESSING FUNCTIONS

GCLI:	SKIPN B,A	;GC AND RESET A LIST POINTER	- IMMEDIATE	
	POPJ P,
	MOVE A,(B)
	SETZM (B)

GCL:	SKIPN B,A	;GARBAGE COLLECT LIST 		- NOT IMMEDIATE
	POPJ P,
	PUSHJ P,LAST2	;SEARCH TO LAST
	EXCH A,VFREE	;TACK ON TO FREE STORAGE
	HRRM A,(B)
	POPJ P,

	;FIND LAST IN LIST (A)	;RETURN POINTER IN B	- NOT IMMEDIATE (EITHER)
LAST:	SKIPN B,A
	POPJ P,
LAST2:	MOVEI C,777777
LAST1:	TDNN C,(B)	;SEE IF RIGHT-HAND OF WORD POINTED TO IS NIL
	POPJ P,
	HRRZ B,(B)
	JRST LAST1

APPEND:	SKIPE D,B
	SKIPN A		;APPEND LIST IN B TO ONE IN A	- IMMEDIATE
	POPJ P,
	PUSHJ P,LAST
	MOVE A,(D)
	HRRM A,(B)	;APPEND
	SETZM (D)	;FLUSH OLD POINTER
	POPJ P,

	;MAPC ON LIST	- FUNARG IN A, LIST IN B 	- NOT IMMEDIATE
VMAP:	PUSH P,A	;FUNARG
VMAP1:	HRRZI B,(B)	;CLEAN UP PTR
	JUMPE B,POP1J
	HLRE A,(B)
	PUSH P,(B)
	PUSHJ P,@-1(P)	;CALL FUNARG - ELEMENT IN A, CURRENT + REST OF LIST IN B
	POP P,B
	JRST VMAP1

VSMAP:	PUSH P,A	;MAP FUNARG OVER XEDGES AND YEDGES
	SETZM YFLAG
.I VMAP<,XEDGES>	;MAP OVER X EDGES
	SETOM YFLAG
	POP P,A
.I VMAP<,YEDGES>	;MAP OVER Y EDGES
	POPJ P,

REVRS:	SKIPE A		;REVERSE LIST IN A		- IMMEDIATE
	SKIPN B,(A)
	POPJ P,
	SETZM C
REVRS1:	HRRZ D,(B)
	HRRM C,(B)
	MOVE C,B
	SKIPE B,D
	JRST REVRS1
	HRRZM C,(A)
	POPJ P,

REPLAC:	SKIPN E,A	;IN LIST A, REPLACE B BY C 	- NOT IMMEDIATE (EITHER)
	POPJ P,
REPLA2:	HRRZ D,(E)
	HLRE F,(E)
	CAMN B,F
	JRST REPLA1
	SKIPE E,D
	JRST REPLA2
	POPJ P,		;NOT FOUND

REPLA1:	HRLM C,(E)
	AOS (P)
	POPJ P,		;OK WIN

REMOVE:	SKIPN D,A	;IN LIST A, REMOVE B		-IMMEDIATE
	POPJ P,
REMOV2:	HRRZ C,(D)
	HLRE E,(C)
	CAMN B,E
	JRST REMOV1
	SKIPE D,C
	JRST REMOV2
	POPJ P,

REMOV1:	HRRZ B,(C)
	HRRM B,(D)
	UNCONS C,B
	AOS (P)		;OK WIN
	POPJ P,

LENGTH:	MOVE B,A
	SETZM A
LENGT1:	JUMPE B,TPOPJ	;FIND LENGTH OF LIST
	HRRZ B,(B)
	AOJA A,LENGT1

NBHD==4		;SIZE OF NBHD - SHOULD BE = TVRXY I GUESS
NLINES==3	;LINES LOOKED AT AT ONCE

NBHD4==NBHD*4

TVINIT:		;CALCULATE VARIOUS 'USEFUL' PARAMETERS
.F RSIZEA=/FFLOAT<#SIZEA>
.F TVTOLA=SQRT<FSPORT=FFLOAT<#SUPPOR>>*NDEVA*TVCERR
.F TVTOLC=FSPORT*NDEVC*TVCERR^2
.F TVTOLD=(FNLINE=FFLOAT<#NLINES>)*NDEVD
.F TVTOLE=FFLOAT<#NBHD4>*NDEVE*TVCERR^2
.F CORR1N=/FFLOAT<#CORRNV>
	POPJ P,


RESETL:	SETZM VEDGES	;RESET LIST POINTER SO WONT ATTEMPT TO LOOSE ON GC
	SETZM XEDGES
	SETZM YEDGES
	SETZM LINES
	SETZM VERTEX
	SETZM VSFREE
	SETZM VLFREE
	SETZM VXFREE
	SETZM VLINKN	
	SETZM VLNKL1
.I SWIPE<#VLINKA,#TVROWL>
.I SWIPE<#MULTIR,#MULTRL>
	POPJ P,

SCAN:	SETOM HANGON	;NORMAL USE OF LINE FINDER
SCAN1:	PUSHJ P,TIME	;GET RUN AND REAL TIME
.I RUNTI1=,RELTI1=,RUNDI3=RELDI3=0
.I TVD(0)=VSTEP1	;STEP SIZE ALONG LINES
	PUSHJ P,SCAN2	;DO THE TWO SCANS
	PUSHJ P,TIME
.I RUNTI2=,RELTI2=,RUNDI3=RELDI3=0
.I (RUNTI2-RUNTI1)/1000.,(RELTI2-RELTI1)/1000.
	PRINT _#1 SEC IN #2 SEC_
	PUSHJ P,WAITP	;	---
	SKIPE NOTPRC
	POPJ P,
	JRST VLINA	;NOW GENERATE AND CLEAN UP LINES USING EDGE-FRAGMENT CHAINS FOUND


SCAN2:	SKIPE SIXRUN
	PUSHJ P,OPNSIX
.I FREARY=ARYALS<FREARY,2000>
.I AVCONS=ARYORG(A)
.I TVD(1)=TVD(0)*#TVRXY	;STEP SIZE BETWEEN LINES
	PUSHJ P,TVOPEN	;OPEN VIDI AND POSSIBLE DSK I/O
	PUSHJ P,TVINIT	;INIT PARAMS
	PUSHJ P,RESETL	;RESET VARIOUS LIST-POINTERS SO WONT ATTEMPT TO GC THEM
	PUSHJ P,FSTINT	;SET UP FS
	PUSHJ P,EDGFR	;FREE EDGE SEGMENT BLOCKS

	HEAD SCANNING
	PUSHJ P,TVDINI	;INIT DISPLAY
	PUSHJ P,ADISON	;START DISPLAY
	PUSHJ P,TVH	;HORIZONTAL SCAN
.I XEDGES=VEDGES,VEDGES=0
	PUSHJ P,TVV	;VERTICAL SCAN
.I YEDGES=VEDGES,VEDGES=0
	SKIPE DSKOUF
	PUSHJ P,CLONDO	;CLOSE DISK OUTPUT
	SKIPE DSKINF
	PUSHJ P,CLONDI	;CLOSE DISK INPUT
	SETZM DSKOUF
	SETZM DSKINF
.I VSMAP<#VCEP>		;FUNARG TO CONS END PTS
	JRST TDISGO

RUNTI1:	0	;RUN TIME AT START OF SCAN
RELTI1:	0	;REAL TIME AT START OF SCAN
RUNTI2:	0	;RUN TIME AT END OF SCAN
RELTI2:	0	;REAL TIME AT END OF SCAN
RUNDI3:	0	;RUN TIME SPENT DISPLAYING
RELDI3:	0	;REAL TIME SPEND DISPLAYING
RUNTI5:	0	;RUN TIME AT END OF LINE-CLEANING
RELTI5:	0	;REAL TIME AT END OF LINE-CLEANING

LOOK:	SETZM DSKINF		;QUICK LOOK FEATURE
	SETZM DSKOUF
	SETOM DSPLAY
.I SLURP<#TVL,#LOOKR,6>
	PUSHJ P,SCAN2
	JRST EXTRES	;SET UP GRID WITH POTS

LOOKR:		;SCAN RASTER FOR LOOK - BLT TO TVX
	1000	;TVL
	1000
	36777	;TVU
	36777
	100	;TVD	;256. POINTS
	400		;64. LINES

FAIL:	TDZA A,A
WIN:	MOVEI A,WIN
	POPJ P,

POP2J:	SUB P,[1,,1]
POP1J:	SUB P,[1,,1]
TPOPJ:	POPJ P,


TVRXY==4	;RATIO OF STEP SIZES
SIZEA==15.	;FULL WIDTH OF LOCAL AVERAGE-MAKE ODD NO.

SUPPOR==NLINES*2*NBHD	;NUMBER PTS IN SUPPORT
ANGLES==2*TVRXY+3	;NUMBER OF ANGLES,ODD NUMBER

;	* * * * * * * *		;NEW LINE OF DATA
;	. . . . . . . .
;	. . . . . . . .
;	. . . . . . . .
;	- - - -+- - - -		;CENTER LINE OF DATA
;	. . . . . . . .
;	. . . . . . . .
;	. . . . . . . .
;	* * * * * * * *		;OLD LINE OF DATA


VSTEP1:	16.	;STEP SIZE ALONG LINE - GOES TO TVD

RSIZEA:	0	;RECIPROCAL SIZEA
FNLINE:	3.0	;FL PT VALUE NLINES
FSPORT:	24.0	;FL PT VALUE SUPPORT

TVTOLA:	20.0	;CUTOFF(GL-GR)>TVTOLA
;		;VALUE NDEVA*TVCERR*SQRT(SUPPORT)
NDEVA:	3.0	;NUMB STD DEV TVTOLA

TVTOLB:	1.0	;CUTOFF(IL-IR)/(GL-GR)>TVTOLB

TVTOLC:	54.0	;CUTOFF EQUALITY OF SIGNAL ON LINES
;		;SQUARED DEVIATION (L-R)
;		;VALUE NDEVC*SUPPORT*TVCERR*TVCERR
NDEVC:	2.0	;NUMBER OF STD DEV FOR TVTOLC

TVTOLD:	0.27	;ALTERNATIVE TEST TO TVTOLC FOR LARGE SIGNALS
;		;CUTOFF RATIO NLINES*SQ DEV(L-R))/SQ(L-R)
NDEVD:	0.09	;MULTIPLE OF NLINES IN TVTOLD

TVTOLE:	200.0	;CUTOFF IN SIMILARITY TEST
;		;FOR EQUAL (L-R)SIGNAL (VLINKU)
;		;VALUE NDEVE*2*NBHD*2*TVCERR*TVCERR
NDEVE:	6.0	;STD DEV FOR SIMILARITY TEST FOR CHAINS

TVTOLF:	0.15	;ALTERN TO TVTOLE, RATIO

TVTOLZ:	1.0	;SAME SIGN TEST ON LEFT-RIGHT

NOTPRC:	0	;-1 TO NOT PROCESS DATA, JUST OUTPUT IT
;DEFINITION OF SCAN FIELD

;	***	GOES AS DISK HEADER FOR DATA

TVL:	10000	;START PT X
	10000	;START PT Y

TVU:	27770	;UPPER LIMIT X
	27770	;UPPER LIMIT Y

TVD:	20	;STEP X	1024. POINTS MAX
	100	;STEP Y	 256. LINES MAX

TVNX1:	0	;INNER LOOP COUNT X - GOES INTO TVN1 ON X-SCAN
TVNX2:	0	;OUTER LOOP COUNT X
TVBLKX:	0	;BLKO PTR FOR X

TVNY1:	0	;INNER LOOP COUNT Y - GOES INTO TVN1 ON Y-SCAN
TVNY2:	0	;OUTER LOOP COUNT Y
TVBLKY:	0	;BLKO PTR FOR Y

TVDIMC:	1	;DIM CUTOFF 0-7, 0 MOST PATIENT
TVCONF:	3	;CONFIDENCE 0-3, 3 MOST ACCURATE
TVDEV:	0	;DEVICE 0=NEW,NON-ZERO=OLD
TVHEND:		;END OF HEADER BLOCK

;	***	UP TO HERE

TVN1:	0	;CURRENT INNER LOOP COUNTER
TVN2:	0	;CURRENT OUTER LOOP COUNTER
TVBLKO:	0	;CURRENT BLKO PTR

TVN2Z:	0	;AUXILIARY OUTER LOOP COUNT - 1 FOR FIRST ROW

TVDL:	0	;(TVNX1-1)*TVD - CALCULATED X WIDTH
	0	;(TVNY1-1)*TVD - CALCULATED Y WIDTH

TVH:	SETZM YFLAG	;HORIZONTAL SCAN
	MOVE A,[TVNX1,,TVN1]
TVH1:	BLT A,TVN1+2
	SETZM TVN2Z
	PUSHJ P,VSCANR	;GENERATE .VSCAN RASTER
	PUSHJ P,FLUSHA	;FLUSH OUT VARIOUS ARRAYS
	PUSHJ P,TVH3	;SET UP COUNTERS
	PUSHJ P,@INPUT	;GOBBLE A LINE
TVH2:	AOS A,TVN2Z
	CAMLE A,TVN2
	JRST VLINK3	;DONE - GC VLINKA ETC. 
	PUSHJ P,@TVTEST	;WAIT FOR LAST READ TO FINISH
	HLLZ A,TVINCR
	ADDM A,MATC1	;INCREMENT X ORG
	HRLZ A,TVINCR
	ADDM A,MATC2	;INCREMENT Y ORG
	MOVE A,TVN2Z
	CAME A,TVN2	;DON'T START A READ LAST TIME ROUND 
	PUSHJ P,@INPUT	;GOBBLE NEXT LINE
	PUSHJ P,@DMPDAT	;DUMP LAST LINE IF REQUESTED
	SKIPN NOTPRC
	PUSHJ P,@TVPRED	;MEANTIME APPLY PREDICATE TO LAST LINE
	JRST TVH2

TVV:	SETOM YFLAG	;VERTICAL SCAN
	MOVE A,[TVNY1,,TVN1]
	JRST TVH1

VSCANR:			;SET UP .VSCAN BLOCK
.I SWIPE<#MATR1,8.>	;WIPE IT CLEAN
	MOVE A,[-TVROWL,,TVROWB]
	MOVEM A,AOBARR
	MOVEI A,1
	HRL A,TVN1
	MOVEM A,RESOL	;1,,N1
	HRR A,TVL+1
	HRLZM A,MATC2	;Y ORG
	HRR A,TVL
	HRLZM A,MATC1	;X ORG
	SKIPE YFLAG
	JRST TVCR1
	MOVE A,TVDL	;N1*D1
	HRLZM A,MATR1	;X STEP
	HRRZ A,TVD+1
TVCR2:	MOVEM A,TVINCR
	POPJ P,

TVCR1:	MOVE A,TVDL+1
	HRLZM A,MATR3	;Y STEP
	HRLZ A,TVD+1
	JRST TVCR2

SIZEA1==SIZEA+NBHD-2
SIZEA2==ANGLES/2*2+NBHD

;TVN1	NUMBER OF POINTS IN ONE LINE
;TVN11	TVN1-1
;TVN12	TVN1+1-SIZEA-NBHD
;TVN13	TVN1+1-SIZEA-NBHD*2
;TVN14	TVN1+1-SIZEA-NBHD*3-ANGLES/2*2

TVH3:		;SET UP COUNTERS
.I ,,TVN14=(TVN13=(TVN12=(TVN11=TVN1-1)-#SIZEA1)-#NBHD)-#SIZEA2
.I PFLAG=-2	;GATE FOR PRED ON THIRD PASS
.I TVN141=(TVN1-1)/4+1
	POPJ P,


TVINCR:0	;INCREMENT THE .VSCAN ORIGIN

PFLAG:	0	;GATE FOR PRED TEST DONT LOOK AT FIRST TWO LINES
YFLAG:	0	;FLAG ON FOR Y SCAN

FLUSHA:
.I SWIPE<#ROWALR,#TVROWL>	;?
.I SWIPE<#ROWAAV,#TVROWL>
.I SWIPE<#ROWBLR,#TVROWL>
.I SWIPE<#ROWBAV,#TVROWL>
.I SWIPE<#ROWCLR,#TVROWL>
.I SWIPE<#ROWCAV,#TVROWL>
.I SWIPE<#VLINKA,#TVROWL>
	POPJ P,

TVDUM1:	IDIV C,TVD+1
	AOS C		;DELTAX/STEPX+1
	IDIV A,TVD
	AOS A		;DELTAY/STEPY+1
	CAILE A,TVROWL
	MOVEI A,TVROWL	;LIMIT TO LENGTH OF ARRAYS
	MOVEI B,-1(A)
	IMUL B,TVD	;CALCULATE WIDTH (N-1)*INTERVAL
	POPJ P,


TVDIM:
.I TVDUM1<TVU(0)-TVL(0),,TVU(1)-TVL(1)>
.I TVNX1=,TVDL(0)=,TVNX2=	;POINTS PER LINE X,TOTAL WIDTH,LINES Y
.I TVDUM1<TVU(1)-TVL(1),,TVU(0)-TVL(0)>
.I TVNY1=,TVDL(1)=,TVNY2=	;POINTS PER LINE Y,TOTAL WIDTH,LINES X
	POPJ P,

TVCERR:	1.5	;1.2 VIDI INTENSITY (RMS NOISE)/(PEAK SIGNAL)

TVN11:	0	;TVN1-1
TVN12:	0	;TVN1-CORRNV+CORRNV/2-CORRN+1
TVN13:	0	;TVN1-CORRN+1
TVN14:	0	;TVN13-CORRNA-4+1
TVN141:	0	;(TVN1-1)/4+1

;CORRN==4	;SAME A TVRXY I GUESS;CORRN	HALF WIDTH CORRELATION

CORRNB==5		;5. -	HALF WIDTH ANGLE INTERVAL

CORRNA==2*CORRNB+1	;11. -	FULL WIDTH ANGLE INTERVAL

CORRNV==2*6+1		;13. - FULL WIDTH AVERAGING INTERVAL

OFFX:	17.	;	2+CORRNA+CORRN+CORRN/2+1+CORRNV/2	;2+11+4+2+1+7=27
OFFY:	-1

CORR1N:	0	;1/CORRNV

TVPRED:	VPRED1		;PREDICATE APPLIED TO LINE

VPRED1:	PUSHJ P,CORRA0	;DONE TO ALL ROWS - (INT-AVG ETC.)
	AOSG PFLAG	;SKIP AFTER FIRST TWO ROWS
	JRST TVBLT	;IN THIS CASE, ONLY MOVE THINGS UP
	PUSHJ P,CORRL8	;CORRELATION AND INHOMOGENEOUS POINT FINDING
	PUSHJ P,VCAND	;EXAMINE STUFF ON INHOMOGENEOUS POINT PDL
	PUSHJ P,VLINK8	;GC VLINKA
	PUSHJ P,VLINK1	;WEAK LINKS INSERT IN GC
	PUSHJ P,VLINK9	;INSERT  LINKS (IN VLINKA)
TVBLT:
.I SLURP<#ROWALR,#ROWBLR,TVN1>	;COPY B TO A
.I SLURP<#ROWAAV,#ROWBAV,TVN1>

.I SLURP<#ROWBLR,#ROWCLR,TVN1>	;COPY C TO B
.I SLURP<#ROWBAV,#ROWCAV,TVN1>
	POPJ P,

;INTEGRAL GAUSSIAN PROBABILITIES
;RESULTS 0-31.

DEFINE VPROB Q1,Q,R,N,ERROR
	FDVR Q1,ERROR
	MOVM Q,Q1
	MOVEI R,0

	REPEAT N,[
	CAML Q,VPROBA+1_<N-1-.RPCNT>(R)
	MOVEI R,1_<N-1-.RPCNT>(R)
]
	SKIPG Q1
	MOVNI R,(R)
TERMIN

VPROBA:	0

	0.039
	0.0786
	0.1175
	0.1575

	0.1967
	0.2375
	0.2775
	0.3188

	0.3600
	0.4022
	0.4450
	0.4889

	0.5333
	0.5800
	0.6261
	0.6744

	0.7245
	0.7755
	0.8303
	0.8871

	0.9470
	1.010
	1.0780
	1.1505

	1.2295
	1.3175
	1.4180
	1.5341

	1.676
	1.863
	2.155
IFN VEXTVF,[

;FLOATING GAUSSIAN PROBABILITIES
;RESULTS 0-1.0

DEFINE VPROB1 Q1,Q,R,N,ERROR
	FDVR Q1,ERROR
	MOVM Q,Q1
	MOVEI R,0

	REPEAT N,[
	CAML Q,VPROBA+1_<N-1-.RPCNT>(R)
	MOVEI R,1_<N-1-.RPCNT>(R)
]
	MOVE R,VPROBB(R)
	SKIPG Q1
	MOVN R,R
TERMIN  

VPROBB:	0

	0.03125
	0.0625
	0.09375
	0.125

	0.15625
	0.1875
	0.21875
	0.25
	
	0.28125
	0.3125
	0.34375
	0.375

	0.40625
	0.4375
	0.46875
	0.50

	0.53125
	0.5625
	0.59375
	0.625

	0.65625
	0.6875
	0.71875
	0.7500

	0.78125
	0.8125
	0.84375
	0.875

	0.90625
	0.9375
	0.96875
]
CORRA0:	SKIPE SIXRUN	;COMPUTE G=I-IBAR
	SKIPN PRCVID
	SKIPA
	POPJ P,		;ALREADY PROCESSED BY PDP6
	MOVE A,TVN11	;COUNT-1 ... FIRST THING CALLED IN VPRED1
	HRLI T,233000
	MOVEI B,0
	MOVEI D,SIZEA-1	;WIDTH LOCAL AVG
CORRA1:	HLLM T,ROWC(A)	;CONVERT FIXED LEFT PART TO UNNORM FLT PT
	FADR B,ROWC(A)	;COLLECT MOVING AVG
	SOS A
	SOJG D,CORRA1	;GO UNTIL HAVE COLLECTED ONE FULL MOVING AVG

CORRA2:	HLLM T,ROWC(A)	;LOOP
	FADR B,ROWC(A)	;ADD NEW ELEMENT TO AVG
	MOVN C,B
	FMPR C,RSIZEA	;RECIPROCAL SIZEA
	FADR C,ROWC+SIZEA/2(A)	;CENTER ELEMENT
	MOVEM C,ROWCG(A)	;ROWCG(A)=ROWC(A+SIZEA/2)-S(ROWC(A)-ROWC(A+SIZEA))
	FSBR B,ROWC+SIZEA-1(A)	;FLUSH OLD ELEMENT FROM AVG
	SOJGE A,CORRA2

;COMPUTE SUM ON L-R AND INTENSITY
	SETZB B,C	;?
	MOVE A,TVN12
	ADDI A,NBHD-1	;?
	HRLI T,233000
	MOVEI D,NBHD-1
CORRA3:	FADR B,ROWCG(A)
	HRR T,ROWC+SIZEA/2(A)
	FADR C,T
	SOS A
	SOJG D,CORRA3

CORRA4:	FADR B,ROWCG(A)		;ADD TO HEAD
	MOVEM B,ROWCS+NBHD(A)	;ROWCS(A+NBHD)=S(ROWCG(A)-ROWCG(A+NBHD))
	FSBR B,ROWCG+NBHD-1(A)
	HRR T,ROWC+SIZEA/2(A)
	FADR C,T
	HLLM C,ROWCI+NBHD(A)	;L.ROWCI(A+NBHD)=S(ROWC(A+SIZEA/2)-ROWC(A+SIZEA/2+NBHD))
	HRR T,ROWC+NBHD-1+SIZEA/2(A)
	FSBR C,T
	SOJGE A,CORRA4

;COMPUTE L-R
	MOVE A,TVN13	;COUNT
CORRA5:	MOVE B,ROWCS+NBHD(A)
	FSBR B,ROWCS+NBHD*2(A)
	MOVEM B,ROWCS+NBHD*2(A)	;ROWCS(A+NBHD*2)=ROWCS(A+NBHD)-ROWCS(A+NBHD*2)
	MOVE C,ROWCI+NBHD(A)
	FSBR C,ROWCI+NBHD*2(A)
	MOVEM C,ROWCI+NBHD*2(A)	;ROWCI(A+NBHD*2)=ROWCI(A+NBHD)-ROWCI(A+NBHD*2)
	SOJGE A,CORRA5

	POPJ P,

;ROWCI IS NOW (LOCAL AVG [NBHD] LEFT)-(LOCAL AVG [NBHD] RIGHT) OF INTENSITY
;ROWCS IS NOW (LOCAL AVG [NBHD] LEFT)-(LOCAL AVG [NBHD] RIGHT) OF INTENSITY - (LOCAL AVG [SIZEA] OF INTENSITY)
;ENTRIES ORIGINALLY RAN FROM 0 TO TVN1-1
;NOW RUN FROM NBHD*2 TO TVN1+1-SIZEA
OFF1==NBHD*2+2+ANGLES/2

DEFINE CORM1 N
	XQJ==N-3-ANGLES/2
	MOVE E,ROWALR+OFF1+XQJ(A)
	FADR E,ROWBLR+OFF1(A)
	FADR E,ROWCLR+OFF1-XQJ(A)
	MOVM F,E
	CAML F,D	;ABOVE CUTOFF AND A MAXIMUM
	JRST CONC CORP,\N,	;TEST
CONC CORL,\N+1,:
TERMIN

DEFINE CORM4 N
	XQJ==N-3-ANGLES/2
CONC CORP,\N,:
	MOVE G,ROWAI+OFF1+XQJ(A)	;(IL-IR)/(GL-GR)>VTOLB
	FADR G,ROWBI+OFF1(A)
	FADR G,ROWCI+OFF1-XQJ(A)
	FDVR G,E
	CAMG G,TVTOLB
	JRST CONC CORL,\N+1,
	JUMPG E,CONC CORQ,\N,	;SAME SIGN (L-R)
	MOVN T,TVTOLZ
	CAML T,ROWALR+OFF1+XQJ(A)
	CAMG T,ROWBLR+OFF1(A)
	JRST CONC CORL,\N+1
	CAMG T,ROWCLR+OFF1-XQJ(A)
	JRST CONC CORL,\N+1
CONC CORZ,\N,:
	MOVE G,ROWALR+OFF1+XQJ(A)	;EQUAL SIGNAL TEST
	FMPR G,G
	MOVE T,ROWBLR+OFF1(A)
	FMPR T,T
	FADR G,T
	MOVE T,ROWCLR+OFF1-XQJ(A)
	FMPR T,T
	FADR G,T
	FMPR F,F
	FMPRL F,<<0.3333333>_-18.>
	FSBR G,F
	CAMG G,TVTOLC
	JRST CONC CORA,\N,
	FDVR G,F
	CAML G,TVTOLD
	JRST CONC CORL,\N+1,
CONC CORA,\N,:
	MOVEI B,N
	MOVE C,E
	MOVM D,E
	JRST CONC CORL,\N+1,
CONC CORQ,\N,:
	MOVE T,TVTOLZ
	CAMG T,ROWALR+OFF1+XQJ(A)
	CAML T,ROWBLR+OFF1(A)
	JRST CONC CORL,\N+1
	CAML T,ROWCLR+OFF1-XQJ(A)
	JRST CONC CORL,\N+1
	JRST CONC CORZ,\N,
TERMIN

CORRLP:	0	;LAST POINTER FOR POINT PDL

;A	INDEX IN ROW
;B	ANGLE INDEX
;C	VALUE OF L-R IF ANY
;D	ABS(L-R)

;THIS SECTION CALCULATES L-R AT EACH POINT ALONG EACH DIRECTION

CORRL8:	MOVE A,TVN14	;SECOND FUNCTION CALLED IN VPRED1
	MOVE W,[-TVLONG,,TVPDLB-1]	;SET UP INHOMOGENEOUS POINT PDL
	SKIPE SIXRUN
	SKIPN PRCVID
	JRST CORRLA
	SKIPN NONDIM	;SPEED UP ...
	POPJ P,		;NOTHING TO PROCESS, WAS ALL DIM-CUT-OFF

CORRLA:	MOVEI B,0	;ANGLES
CORRLB:	MOVM D,TVTOLA	;CUTOFF VALUE
	SKIPN ROWBLR+OFF1(A)	;SPEED UP, ...
	JRST CORRLC

	REPEAT ANGLES,CORM1 3+.RPCNT

	JUMPN B,CORRT	;IF WON FOR SOME ANGLE
CORRLC:	SOJGE A,CORRLB	;CORRLJ-TRY NEXT POINT
	POPJ P,		;LOOKED AT ALL POINTS



	REPEAT ANGLES+4,CORM4 1+.RPCNT

CORRT:	CAIE B,3
	JRST CORRT1	;ANGLE WAS NOT 3

	REPEAT 2,CORM1 1+.RPCNT,

	JRST CORRT2


CORRT1:	CAIE B,ANGLES+2
	JRST CORRT2	;ANGLE WAS NOT ANGLES+2 EITHER

	REPEAT 2,CORM1	ANGLES+3+.RPCNT,

CORRT2:	CAMN W,[-TVLONG,,TVPDLB-1]

	JRST CORRTA	;NOTHING ON LIST YET
	HLRZ E,-1(W)	;COMPARE WITH LAST ONE
	SUBI E,(B)
	MOVM E,E	;ABS DIFFERENCE IN ANGLES
	ADDI E,6(A)
	HRRZ F,-1(W)
	CAIGE E,(F)
	JRST CORRTA
	MOVE U,(W)
	JUMPL U,CORRT3
	CAMLE C,U
	JRST CORRT4	;THIS ONE HAS HIGHER L-R, SO OVERLAY LAST ONE
	JUMPG C,CORRTJ
	JRST CORRTA

CORRT4:	HRRM A,-1(W)	;REPLACE THE LAST POINT
	HRLM B,-1(W)
	MOVEM C,(W)
	JRST CORRTJ

CORRT3:	CAMGE C,U
	JRST CORRT4
	JUMPL C,CORRTJ
CORRTA:	PUSH W,A	;PUSH NEW INHOMOGENEOUS POINT [ANGLE-INDEX,,INDEX IN ROW]
	HRLM B,(W)
	PUSH W,C	;PUSH [VALUE OF L-R]
CORRTJ:	SOJGE A,CORRLA
	POPJ P,		;ALL POINTS HAVE BEEN LOOKED AT

	;GET HERE WHEN STUFFED ALL POINTS ON INHOMOGENEOUS POINT PDL
VCAND:	MOVE U,[-TVLONG,,TVPDLB-1]	;LAST POINTER TO POINT PDL
	MOVEM U,CORRLP

VCAND0:	MOVE U,CORRLP
	CAMN W,U	;VCAND1
	POPJ P,		;DONE - HAVE LOOKED AT ALL POINTS IN PDL
	ADD U,[2,,2]	;NEXT POINT
	MOVEM U,CORRLP
	HLRZ B,-1(U)	;FETCH ANGLE
	CAIL B,3
	CAIL B,CORRNA+3
	JRST VCAND0	;OUT OF INTERESTING RANGE

	HRRZ A,-1(U)	;FETCH X INDEX
	CAML A,TVN13
	JRST VCAND0	;OUT OF INTERESTING RANGE ( <0 OR >TVN13 )

	JUMPE A,VCAND0
	MOVE C,A
	SUBI A,2
	MOVM D,(U)	;L-R VALUE OF THIS ONE
	PUSHJ P,VCNDLM	;LOCAL MAX?
	HRRZ A,-1(U)	;AGAIN FETCH X-INDEX
	CAIE A,(C)	;SAME ?
	JRST VCAND0	;NO, NOT LOCAL MAX

	MOVE D,TVN2Z	;Y VALUE +1 - NOW CONVINCED THIS IS A WINNING EDGE FRAGMENT
	SOS D		;PLACE TO HACK-UP D
	PUSHJ P,VPTDIS	;DISPLAY SHORT LINE -FRAGMENT
	HRRZ C,-1(U)
	HLRZ D,-1(U)
	MOVE E,(U)
	MOVEM E,VCANDV
	PUSHJ P,VCANDC	;STORE IT (?)
	JRST VCAND0

;DISPLAY AN EDGE FRAGMENT

;FIRST CALC CORRDS IN VIDI - XCRD,ANGLE,,YCRD
;EXTRAPOLATE FIRST CORRD (C GETS WHATS IN A (X-CRD) + OFFSET DUE TO ANGLE IN B)

VPTDIS:	SKIPN DSPLAY
	POPJ P,
;	SKIPL B
;	CAIL B,CORRNA+4		;15.
;	.VALUE			;BAD ANGLE
	MOVEI C,@VCORP(B)	;C=8.-B(A)
	CAIL C,TVROWL
	HRRES C		;<0 OR TOO LARGE
	PUSH P,W
	PUSH P,X
	SKIPE PNTSOL
	JRST VPTDIT	;DISPLAY A POINT ONLY
	PUSH P,B	;SAVE ANGLE
	HRRE A,C
.I VIDSCH<,D+1>	;BECAUSE WE PROJECTED ONE ROW FORWARD
.I XPNO=,YPNO=
	POP P,B		;RESTORE ANGLE
	HRREI B,-TVRXY*2(B)	;B=B-8
.I ,&*TVD(0),-TVD(1)	;PROJECT BACKWARD
	SKIPE YFLAG
	EXCH B,C
.I ,XPVO=,YPVO=
	ASH B,-1
	ASH C,-1
.I ,&+XPNO,&+YPNO
	ASH B,-4
	ASH C,-4
;	PUSHJ P,CHKDIS
;	.VALUE		;OUTSIDE SCOPE FACE
	PUSHJ P,DSPPNI	;POINT
.I ,XPVO,YPVO
	ASH B,-4
	ASH C,-4
	PUSHJ P,DSPVEC	;GO DISPLAY A VECTOR SPANNING ONE ROW
VPTDI1:	POP P,X
	POP P,W
	POPJ P,

PNTSOL:	0	;NON-ZERO GIVES POINTS, NOT LINE SEGMENTS

VPTDIT:
.I VIDSCH<,D>		;X IS ALREADY IN A
	MOVE C,B
	MOVE B,A
	ASH B,-4
	ASH C,-4
;	PUSHJ P,CHKDIS
;	.VALUE		;OUTSIDE SCOPE FACE
	PUSHJ P,DSPPNI
	JRST VPTDI1

XPNO:	0
YPNO:	0
XPVO:	0
YPVO:	0

CHKDIS:	SKIPL B		;SEE IF POINT ON SCOPE FACE
	CAIL B,2000
	POPJ P,
	SKIPL C
	CAIL C,2000
	POPJ P,
	AOS (P)
	POPJ P,


;TRANSFORMS FROM LINE SCAN COORDS TO VIDI COORDS
	;A:X
	;B:Y
	;C:ANGLE

VIDIXY:	PUSHJ P,VIDSCH
	SKIPN YFLAG
	ADDI C,TVRXY*2	;FIX UP ANGLE
	POPJ P,

VIDSCH:	SKIPN CHKVSS
	JRST VIDSC1
	SKIPL A
	CAIL A,TVROWL
	.VALUE		;BAD FIRST INDEX
	SKIPL B
	CAIL B,TVROWL/4
	.VALUE		;BAD SECOND INDEX
VIDSC1:
.I ((&+OFFX)*2+1)*TVD(0),(&+OFFY)*TVD(1)
	ASH A,-1
	SKIPE YFLAG
	EXCH A,B
	ADD A,TVL+0	;ORIGIN
	ADD B,TVL+1
	POPJ P,

CHKVSS:	0	;-1 TO CHECK CALLS TO VIDSCH

THETAT:	90.?76.?63.?53.?45.?37.?27.?14.
	0?-14.?-27.?-37.?-45.?-53.?-63.?-76.

THETAD:	CAIL C,16.
	SUBI C,16.
	MOVE C,THETAT(C)	;CALCULATE ANGLE IN DEGREES (COUNTER-CLOCKWISE FROM EAST)
	POPJ P,

VCNDLM:	MOVEI E,5	;IS PRESENT POINT A LOCAL MAX? OVER+=2
VCDLM2:	SKIPL A
	CAML A,TVN14
	AOJA A,VCDCM3
	MOVE F,@VCOR1(B)	;ONE ROW BACK
	FADR F,ROWBLR+OFF1(A)	;CURRENT ROW
	FADR F,@VCOR3(B)	;ONE ROW FORWARD
	MOVM F,F
	CAMLE F,D
	JRST VCDLM1
	AOS A
VCDCM3:	SOJG E,VCDLM2
	POPJ P,

VCDLM1:	MOVEI C,-1	;NOT A LOCAL MAXIMUM
	POPJ P,


VLSUM:	-5
	17
	45
	74
	135
	163
	211
	246

VLSUMN:	5
	-17
	-45
	-74
	-135
	-163
	-211
	-246



	22
VSUMGT:	41
	41
	75
	120
	140
	162
	173
	211
	246


;VCHI:	200.0	;3*2*8*DFSQ
;	30.0

;LOOK UP TABLE FOR ANGLE EFFECTS - EXTRAPOLATION FORWARD

VCORP:	REPEAT CORRNA+4,,CORRNB+3-.RPCNT(A)

;GET ELEMENT AT APPROPRIATE ANGLE FROM BACKWARD ROW

VCOR1:	REPEAT CORRNA+4,,ROWALR+OFF1-CORRNB-3+.RPCNT(A)

;GET ELEMENT AT APPROPRIATE ANGLE FROM FORWARD ROW

VCOR3:	REPEAT CORRNA+4,,ROWCLR+OFF1+CORRNB+3-.RPCNT(A)


;A:LOCATION X2
;B:ANGLE
;C:LOCATION MAX F2
;D:ANGLE MAX F2
;E:MAX SUM F2
;F:TEMP SUM F2
;G:
;T:
;U:PTR TO SEG BLOCK OF 5 WDS
;V:LIST OF CHAINS
;W:



;VLINKA:	LINK ARRAY
;VLINKB:	FUN TO BEGIN LINK
;VLINKC:	FUN TO CONTINUE LINK
;VLINKD:	MACRO DELETE FROM VLINKA
;VLINKE:	MACRO TEST EXTENDABLE
;VLINKF:	MACRO SET LINKED FLAG
;VLINKG:	FUN TO GARBAGE COLLECT LINKS
;VLINKI:	FUN INSERT LINK IN VLINKL,VLINKA
;VLINKL:	LINK LIST
;VLINKM:	FUN CALC LINK MAX
;VLINKN:	LIST NEW LINKS
;VLINKP:	FUN CALC LINK PROB
;VLINKQ:	LINK QUERY LIST(VLINKL)
;VLINKR:	MACRO RESET LINKED FLAG
;VLINKS:	FUN FOR STRONG LINKS
;VLINKT:	FUN TEST LINK SIMILAR
;VLINKU:	FUN TEST LINK SIMILAR
;VLINKV:	FUN LINK VALUE
;VLINKW:	FUN FOR WEAK LINKS
;VLINKX:	MACRO EXTRAP POSITION
;VLINKY:	FUN TO COALESCE Y'S


;VLINKH,VLINKJ,VLINKK,VLINKO,

;EACH CHAIN STARTS OFF WITH ONE OF THESE

;XN,,PTR			X,,P
;N,,ANGLE			N,,A
;GLOBAL SUM,,Y PTR 		G,,B
;F2(0),,F1(0)			2,,1
;PROB(N-1),,PROB(N-2)		U,,V

;XN,,PTR			X,,P
;N,,ANGLE			N,,A
;GLOBAL SUM,,Y COORD		G,,Y
;F2(0),,F1(0)			2,,1
;F2(N),,F1(N)			4,,3

;STUFF POINTED TO BY PTR IS OF FORM ANGLE_13.+XN,,PTR

EDGLL==5	;EDGE FRAGMENT CHAIN HEADER LENGTH

;FIL=THREAD:	INDEX REG FOR LINK HEADER

;FILU	 	MOVE PROB(N-1)
;FILUM	 	MOVEM PROB(N-1)
;FILUW		SYM LOC PROB(N-1),INDEX FIL

;FILV	 	MOVE PROB(N-2)
;FILVM	 	MOVEM PROB(N-2)
;FILVW		SYM LOC PROB(N-2),INDEX FIL

;FILG A,	MOVE GLOBAL PROB
;FILGM A,	MOVEM GLOBAL SUM PROB
;FILGW		SYM LOC GLOB PROB (FIL)

;FILX A,	MOVE XN
;FILXM A,	MOVEM XN
;FILXW		SYM LOC XN (FIL)

;FILP A,	MOVE PTR
;FILPM A,	MOVEM PTR
;FILPW		SYM LOC PTR (FIL)

;FILS A,	MOVE SIM TEST
;FILSM A,	MOVEM SIM TEST
;FILSW		SYM LOC SIM TEST (FIL)

;FILN A,	MOVE N
;FILNM A,	MOVEM N
;FILNW		SYM LOC N (FIL)

;FILA A,	MOVE ANGLE
;FILAM A,	MOVEM ANGLE
;FILAW		SYM LOC ANGLE (FIL)

;FILB		MOVE PTR TO OTHER BLOCKS
;FILBM		MOVEM PTR TO OTHER BLOCKS
;FILBW		SYM LOC (FIL)

FIL==U

FILUW==4
FILU==HLRE
FILUM==HRLM

FILVW==4
FILV==HRRE
FILVM==HRRM

FILGW==2
FILG==HLRE
FILGM==HRLM

FILXW==0
FILX==HLRZ
FILXM==HRLM

FILPW==0
FILP==HRRZ
FILPM==HRRM

FILSW==2
;FILS==HRLZ
FILSM==HLRM


FILNW==1
FILN==HLRZ
FILNM==HRLM

FILAW==1
FILA==HRRZ
FILAM==HRRM

FIL2W==3
;FIL2==HLLZ
FIL2M==HLLM

;FIL1W==3
;FIL1==HRLZ
;FIL1M==HLRM

FIL4W==4
;FIL4==HLLZ
FIL4M==HLLM

;FIL3W==4
;FIL3==HRLZ
;FIL3M==HLRM

FILYW==2
FILY==HRRZ
FILYM==HRRM

FILBW==2
;FILB==HRRZ
FILBM==HRRM


;VARIOUS MACROS USED IN MANIPULATING CHAINS OF EDGE FRAGMENTS

	;DELETE ENTRY ON VLINKA LIST
DEFINE VLINKD
	HRRZ A,VLINKA(T)
	CAML A,AVCONS	;PTR?
	PUSHJ P,GCL	;YES,GC LIST
	SETZM VLINKA(T)
TERMIN

	;SET LINKED FLAG
DEFINE VLINKF
	MOVNS 1(FIL)
TERMIN

	;TEST LINKED
DEFINE VLINKE
	SKIPG 1(FIL)
TERMIN

	;RESET LINKED FLAG
DEFINE VLINKR
	MOVMS 1(FIL)
TERMIN


	;EXTRAPOLATED POINT
DEFINE VLINKX C
	FILX A,FILXW(FIL)
	FILA B,FILAW(FIL)
	MOVEI C,@VCORP(B)
TERMIN

	;EXTRAPOLATED POINT FROM LAST PT
DEFINE VLNKXB C
	FILP A,FILPW(FIL)
	HLRZ A,(A)
	LDB B,[150500,,A]
	TRZ A,760000
	MOVEI C,@VCORP(B)
TERMIN

;LINK MAXIMUM

DEFINE	VLNKM1
	MOVE F,@VCOR1(B)
	FADR F,ROWBLR+OFF1(A)
	FADR F,@VCOR3(B)
	XCT VCMAXT
	JRST .+4
	MOVEI C,(A)
	MOVEI D,(B)
	MOVE E,F
TERMIN


DEFINE VLNKM2
	VLNKM1
	CAIGE B,13.
	AOS B
	VLNKM1
	CAIGE B,13.
	AOS B
	VLNKM1
TERMIN

VCMAXT:	0	.	;PROGR MOD TEST

VLINKM:		;MAX +-1 POS,+-1 ANGLE
	MOVE G,[CAMG F,E]	;CALCULATES LINK MAXIMUM
	SKIPG E
	MOVE G,[CAML F,E]
	MOVEM G,VCMAXT
	MOVEI D,(B)	;USE LOTS OF MACROS
	MOVEI C,(A)
	SOSGE A
	SETZM A		;???
	CAILE B,1
	CAILE B,13.
	JRST TPOPJ	;LESS THAN 2 OR GREATER THAN 13
	SOSGE B
	AOS B

	VLNKM2

	AOS A

	VLNKM1

	SOSLE B
	SOS B

	VLNKM1

	AOS A

	VLNKM2

	POPJ P,

	;(STORE ?) EDGE CANDIDATES
VCANDC:	MOVEI A,-3(C)
	CAMLE A,TVN13
	MOVEI A,0
	MOVEM A,VCANDA
	SETZM VLNKSV

VCANDL:	AOS A,VCANDA	;LOOK NEARBY IN ARRAY (TWO BACK - TWO FORWARD)
	CAMG A,TVN13	;SHOULDN'T HAPPEN, BUT ...
	CAILE A,2(C)
	JRST VCNDM1	;BEGIN LINK (UNLESS VLNKSV NON-ZERO)
	SKIPN V,VLINKA(A)	;ANYTHING THERE
	JRST VCANDL

VCANDM:	TLNE V,-1	;LEFT HALF
	JRST VCNDMA
	CAMGE V,AVCONS	;LIST?
	JRST VCANDZ
	HLRZ U,(V)	;PTR TO BLOCK
	HRRZ V,(V)
VCNDMB:	MOVEM V,VCNDPT
	PUSHJ P,VLINKS	;STRONG LINK
	MOVE A,VCANDA
	JUMPN V,VCANDM	;CONTINUE DOWN LIST
	JRST VCANDL


VCNDM1:	SKIPN VLNKSV
	JRST VLINKB	;BEGIN LINK
	POPJ P,		;FOUND SOME NEARBY


VCANDZ:	HLRZM V,VCNDPT
	HRRZI U,(V)
	SKIPE U
	PUSHJ P,VLINKS	;STRONG LINK
	SKIPE U,VCNDPT
	PUSHJ P,VLINKS	;STRONG LINK
	JRST VCANDL


VCNDMA:	HLRZ U,V
	HRRZI V,(V)
	JRST VCNDMB

VCANDA:	0	;SAVE ARRAY INDEX FOR VCANDL LOOP

VCANDV:	0	;SAVE VALUE OF MAX SUM F2

VCNDPT:	0	;SAVE LIST PTR

CORRVV:	3.6	;EXPECTED ERROR L-R

ERRET:	STOP _ NO MORE SPACE FOR EDGE FRAGMENTS

;LINK BEGIN

VLINKB:	CDRV V,VSFREE,ERRET
	MOVE T,VLINKN	;GET NEW SEG BLOCK
	HRRM T,(V)
	HRRZM V,VLINKN	;CONS ONTO NEW LINKS
	HLRZ U,(V)	;POINTER TO THIS BLOCK
	AOS NECH

	FILXM C,FILXW(FIL)	;POSITION TO MEM

	FILAM D,FILAW(FIL)	;ANGLE TO MEM

	MOVEI F,1
	FILNM F,FILNW(FIL)	;NUMBER TO MEM

	MOVEI F,0
	FILBM F,FILBW(FIL)	;ZERO SIM TEST
	FILPM F,FILPW(FIL)	;ZERO PTR

	MOVEI F,1
	SKIPG VCANDV
	MOVNI F,1
	FILGM F,FILGW(FIL)	;ZERO GLOBAL SUM
	MOVEI A,(C)

	MOVE F,ROWBLR+OFF1(A)
	PUSHJ  P,VLINKP
	FILVM T,FILVW(FIL)	;PROB(N-2) TO MEM

	MOVE F,@VCOR3(D)
	PUSHJ P,VLINKP
	FILUM T,FILUW(FIL)	;PROB(N-1) TO MEM

	MOVE G,ROWBLR+OFF1(C)
	FIL2M G,FIL2W(FIL)	;F2(0) FOR SIM TEST

	POPJ P,


VLINKP:	VPROB F,G,T,5,CORRVV
	POPJ  P,

	;STRONG LINK
VLINKS:	VLINKE		;SKIPS IF SUCCESS
	POPJ P,		;ALREADY EXTENDED
	FILA B,FILAW(FIL)	;TEST ANGLE
	CAIL B,-2(D)
	CAILE B,2(D)
	POPJ P,
	PUSHJ P,VLNKUA	;UNLINK? SKIPS IF OK
	POPJ P,
	PUSHJ P,VLINKV	;VALUE? SKIPS IF SIGNAL OK
	POPJ P,
	MOVE A,VCANDA
	MOVEM A,VLNKSV	;SAVE STRONG LINK VALUE
	PUSHJ P,VLINKC	;CONTINUE LINK
	VLINKF		;SET LINKED FLAG
	POPJ P,

VLNKSV:	0	;STRONG LINK VALUE

;EXAMINE LINKS ON LINK LIST,VLINKL

	;GC VLINKA ARRAY - FOURTH FUNCTION CALLED BY VPRED1
VLINK8:	HRRZ A,VLNKL1
	HRRZM A,VLINKQ

VLNK8A:	NEXT VLINKQ,V,U

	JUMPE U,VLNK8B
	VLINKE		;EXTENDED?
	JRST VLNK8C	;YES
	VLINKX T,	;EXTRAP POS
VLNK8B:	CAMLE T,TVN13
	JRST VLNK8A	;RAN OFF END
	VLINKD		;GC VLINKA(T)
	JRST VLNK8A

VLNK8C:	VLNKXB T,	;EXTRAP FROM PREV PT
	JRST VLNK8B


VLINK1:	HRRZ V,VLINKL	;FIFTH FUNCTION VALLED IN VPRED1
	HRRZM V,VLINKQ
VLNK1Z:	SETZM VLNKDF
VLNK1A:	HRRZ V,@VLINKQ
	CAMGE V,AVCONS	;
	POPJ P,		;NOT LIST POINTER
	JUMPE V,TPOPJ 
	HLRZ U,(V)
	JUMPE U,VLNK1B
	VLINKE		;STRONG LINK?
	JRST VLNK1C
	PUSHJ P,VLINKW	;WEAK LINK?
	SKIPE VLNKDF
	JRST VLNK1Z
VLNK1B:	HRRZ V,@VLINKQ
	HRRZM V,VLINKQ
	JUMPN V,VLNK1A
	POPJ P,


VLNK1C:	VLINKR		;RESET LINK FLAG
	PUSHJ P,VLINKI	;INSERT LINK IN VLINKA
	JRST VLNK1B

VLINK9:	HRRZ V,VLINKN	;INSERT LINKS - SIXTH FUNCTION CALLED IN VPRED1
	HRRZM V,VLINKQ	;PUT ON QUERY LIST
	PUSHJ P,VLNK9A
	SKIPN A,VLINKN
	POPJ P,
	PUSHJ P,LAST	;NCONC
	EXCH A,VLNKL1
	HRRM A,(B)	;APPEND LIST (VLINKN) TO THE END OF LIST (VLNKL1)
	SETZM VLINKN
	POPJ P,

VLNK9A:	NEXT VLINKQ,V,U

	PUSHJ P,VLINKI	;LINK INSERT IN VLINKA
	JRST VLNK9A

VLINKL:	VLNKL1	;LINK LIST
VLNKL1:	0	;VLINKN GETS STUFFED HERE AT TIMES

VLINKQ:	0	;QUERY LINK LIST
VLINKN:	0	;NEW LINKS - ADDED TO IN VLINKB

VLNKLD:	SETOM VLNKDF
	HRRZ G,@VLINKQ	;CDDR
	HRRZ F,(G)
	HRRM F,@VLINKQ
	CAMGE G,AVCONS	;PTR
	POPJ P,
	UNCONS G,F
	POPJ P,

VLNKDF:	0	;FLAG FOR DELETE


VLINK3:		;GC VLNKL1 LIST (DO AFTER ONE COMPLETE SCAN)
.I SWIPE<#VLINKA,#TVROWL>
	HRRZ A,VLNKL1
	HRRZM A,VLINKQ
	PUSHJ P,VLNK3A
	HRRZ A,VLNKL1
	SETZM VLNKL1
	JRST GCL

VLNK3A:	NEXT VLINKQ,V,U

	PUSHJ P,VLINKO	;GC
	JRST VLNK3A

;WEAK LINKS

VLINKW:	VLINKX A,	;EXTRAP POS AND ANGLE A,B
	CAMG A,TVN13
	PUSHJ  P,VLINKV	;VALUE?SIGNAL OK SKIPS
	JRST VLINKG	;FAILS,GC,DO WE KEEP?
	PUSHJ P,VLINKM	;LOCAL  MAX
	PUSHJ P,VLINKU	;UNLINK?SIM TEST OK SKIPS
	JRST VLINKG	;FAILS,GC,DO WE KEEP?
	PUSHJ P,VLINKC	;CONTINUE LINK
	PUSHJ P,VLINKI	;INSERT IN VLINKA,VLINKL
	POPJ P,


;LINK DELETE FROM LINK ARRAY VLINKA

	;DELETE ELEMENT FROM VLINKA
DELETE:	JUMPE B,FAIL
	PUSH P,B
	PUSH P,A
	PUSH P,B
	HLRZ A,(B)	;SPECIAL CASE CAR
	PUSHJ P,@-1(P)
	JUMPE A,DEL2
	HRRZ A,@(P)
	HRRM A,-2(P)	;RETURN CDR
	JRST DEL4

DEL1:	JUMPE B,DEL3
	HRRM B,(P)
	HRRZ B,(B)
	HLRZ A,(B)
	PUSHJ P,@-1(P)
DEL2:	HRRZ B,@(P)
	JUMPE A,DEL1
	HRRZ A,(B)
	HRRM A,@(P)	;RPLACD CDR CDDR
DEL4:	UNCONS B,A
DEL3:	MOVE A,-2(P)
	SUB P,[3,,3]
	POPJ P,

	;LINK INSERT IN LINK ARRAY VLINKA
VLINKI:	VLINKX A,	;EXTRAP POS ANGLE
	CAMLE A,TVN13
	POPJ P,
	SKIPE V,VLINKA(A)	;INSERT IN VLINKA
	JRST VLNKIA
	HRRM U,VLINKA(A)	;FILL RIGHT HALF FIRST
	POPJ P,
VLNKIA:	MOVEI C,0
	CAML V,AVCONS	;PTR?
	JRST VLNKIZ
	HRRZI T,(V)	;CDR?
	PUSHJ P,VLINKY	;POSSIBLE Y - CODE DOESN'T WIN YET
	JUMPE C,VLNKIB
	HRRM U,VLINKA(A)	;RPLACD
	JRST VLNKID	;DELETE FROM VLINKL

VLNKIB:	MOVEI V,VLINKA(A)
VLNKIC:	HLRZ T,(V)
	PUSHJ P,VLINKY
	JUMPN C,VLNKIE
	HRRZ V,(V)
	CAML V,AVCONS
	JRST VLNKIC
VLNKIL:	MOVE F,VLINKA(A)	;NO Y,ADD TO ARRAY
	TLZN F,777777	;LEFT HALF OPEN?
	JRST VLNKIM
	CAMGE F,AVCONS	;PTR?
	PUSHJ P,VLNKIS	;START LIST
	CONS U,F,G,
	HRRM G,VLINKA(A)
	POPJ P,

VLNKIS:	NCONS F,G,
	HRRZI F,(G)
	POPJ P,
VLNKIM:	HRLM U,VLINKA(A)
	POPJ P,

VLNKIE:	HRLM U,(V)	;RPLACA IN VLINKA
VLNKID:	MOVEI A,VLNKIF	;FUNARG
	MOVE B,VLINKL
	PUSHJ P,DELETE
	HRRZM A,VLINKL
	POPJ P,
VLNKIF:	CAIE A,(U)
	MOVEI A,0
	POPJ P,

VLNKIZ:	HLRZ T,VLINKA(A)
	JUMPE T,VLNKIM
	PUSHJ P,VLINKY
	JUMPN C,VLNKIE
	JRST VLNKIL

;DO WE HAVE A Y,I.E. TWO BRANCHES COALESCE
	;TWO CONSECUTIVE IDENTICAL POINTS


VLINKY:	POPJ P,



;VALUE OF LINK

VLINKV:	MOVE F,@VCOR3(B)	;SIGNAL AT PROJ PT
	VPROB F,G,T,5,CORRVV,	;CALC PROB
	FILUM T,VLNKVU		;SAVE FOR NEXT TIME
	FILU G,FILUW(FIL)	;PROB(N-1)
	FILV F,FILVW(FIL)	;PROB(N-2)
	ADD G,F
	ADD G,T
	FILG F,FILGW(FIL)	;GLOBAL SUM
	FILN E,FILNW(FIL)	;NUMBER PTS
	JUMPL F,VLNKVN	;NEGATIVE?
	CAMG G,VLSUM+2
	POPJ P,
	ADD F,T
	CAIL E,10
	JRST VLNKVX
	CAMG F,VLSUM-1(E)
	POPJ P,
VLNKVX:
	MOVEM F,VLNKVG	;SAVE GLOBAL SUM
	AOS (P)
	POPJ P,

VLNKVN:	CAML G,VLSUMN+2
	POPJ P,
	ADD F,T
	CAIL E,10
	JRST VLNKVX
	CAML F,VLSUMN-1(E)
	POPJ P,
	JRST VLNKVX


VLNKVU:	0	;SAVE FILU FOR NEXT TIME
VLNKVG:	0	;SAVE GLOBAL SUM
;LINK GARBAGE COLLECT (IF CHAIN WAS A LOSER GC IT, ELSE ADD TO VEDGES)

	;GC VLINKQ,TEST
VLINKG:	PUSHJ P,VLNKLD		;DELETE FROM VLINKL
VLINKO:	FILG F,FILGW(FIL)	;SIGNAL
	FILN G,FILNW(FIL)	;NUMBER
	CAIG G,2
	JRST VLNKGB
	FILU A,FILUW(FIL)	;BACK IF LAST PT LOW SIGNAL
	PUSHJ P,VLNKGA
	JRST VLNKGB		;SKIPS IF FLUSHES
	FILV A,FILVW(FIL)
	PUSHJ P,VLNKGA
	JFCL
VLNKGB:	MOVM F,F
	CAIL G,10
	JRST VLNKZN
	CAMG F,VSUMGT-1(G)
	JRST VLNKGC		;GARBAGE COLLECT
VLNKZ1:
	MOVE F,TVN2Z
	FILYM F,FILYW(FIL)	;END Y POS
	FILX A,FILXW(FIL)	;LOC
	HLLZ F,ROWALR(A)
	FIL4M F,FIL4W(FIL)	;F2(N) TO MEM
	CONSV U,G,T,VEDGES,
	POPJ P,			;PUT ON LIST OF WINNING CHAINS !!!

VLNKZN:	IDIVI F,-1(G)
	CAMLE F,VSUMGT-1
	JRST VLNKZ1
VLNKGC:	HRRZ G,(U)	;GARBAGE COLLECT LINK
VLNKG3:	JUMPE G,VLNKG2
	HRRZI F,(G)
	HRRZ G,(G)
	UNCONS F,T,
	JRST VLNKG3	;PUT CHAIN BACK ON FS LIST


VLNKG2:	CONSV U,G,T,VSFREE
	SOS NECH
	POPJ P,		;PUT CHAIN HEADER BACK ON FREE LIST

VLNKGA:	MOVM B,A	;IF LAST PT WEAK,BACKUP
	CAILE B,10
	POPJ P,
	SUB F,A		;REMOVE FROM GLOBAL SIGNAL
	SOS G
	FILP C,FILPW(FIL)	;PTR TO LIST
	CAMG C,AVCONS	;IS IT PTR?
	POPJ P,
	HLRZ A,(C)	
	LDB B,[150500,,A]	;ANGLE
	TRZ A,760000
	FILXM A,FILXW(FIL)	;STORE ANGLE
	FILAM B,FILAW(FIL)	;STORE POSITION
	HRRZ A,(C)	;CDR OF PTR TO MEMORY
	FILPM A,FILPW(FIL)
	UNCONS C,A,	;GARBAGE COLLECT PTR WORD
	AOS (P)
	POPJ P,


;UNLINK

;LINK LOCAL SIMILARITY TEST

VLINKU:
VLNKUA:	SKIPL C
	CAMLE C,TVN13
	.VALUE
	MOVE F,ROWBLR+OFF1(A)
	MOVEI A,(C)
	MOVE G,F
	FSBR F,@VCOR3(D)
	FMPR F,F
	CAMG F,TVTOLE
	JRST VLNKUB
	FADR G,@VCOR3(D)
	FMPR G,G
	FDVR F,G	;TRY THE RATIO THEN FOR LARGE SIGNALS
	CAMG F,TVTOLF
VLNKUB:	AOS (P)
	POPJ P,


VSIMV:	0	;SAVE SIMILARITY

;VCHI1:	.10

;LINK CONTINUE

	;ASSUMES C:NEW POSITION,D:NEW ANGLE
VLINKC:	SKIPL C
	CAMLE C,TVN13
	.VALUE			;X OUT OF RANGE
	FILA F,FILAW(FIL)	;ANGLE
	FILX G,FILXW(FIL)	;POSITION
	DPB F,[150500,,G]	;ANGLE AND POSITION IN HALFWORD
	CONSV G,F,T,(U),
	MOVE F,VLNKVG		;GLOBAL SIGNAL
	FILGM F,FILGW(FIL)	;GLOBAL SIGNAL TO MEM
	MOVE F,VSIMV		;SIMILARITY SUM
	FILSM F,FILSW(FIL)
	FILU F,VLNKVU
	FILU G,FILUW(FIL)
	FILUM F,FILUW(FIL)	;STORE PROB(N-1)
	FILVM G,FILVW(FIL)	;STORE PROB(N-2)
	FILN E,FILNW(FIL)	;NUMBER OF PTS
	AOS E
	FILNM E,FILNW(FIL)	;AOS NUMBER
	FILXM C,FILXW(FIL)	;NEW POSITION
	FILAM D,FILAW(FIL)	;NEW ANGLE
	POPJ P,


VCEP:	MOVEI FIL,(A)	;DONE JUST BEFORE SEGMENTATION
	FILA A,FILAW(FIL)
	FILX B,FILXW(FIL)
	DPB A,[150500,,B]
	CONSV B,A,C,(FIL),
	POPJ P,		;CONS END PT ON LIST


SEGLIM:	90.0	;LIMIT FOR COLINEAR PERPENDICULAR DISTANCE
SEGY:	0	;Y COORD
SEGNAM:	0	;NAME OF SEGMENT HEADER BLOCK
SEGN:	0	;COUNT OF PTS
SEGE1:	0	;BEGIN CURRENT SET OF ENDPTS (USED BY REPEAT)
SEGP:	0	;CURRENT PT - FROM U START (LATER T)


		;SEGMENT OPEN CURVES BY SUCCESSIVELY BREAKING THEM 
		;AT THE PLACE OF MAX NORMAL DISTANCE.
		;THE REPEAT PHASE REPEATS THE SEGMENTATION
		;WITH SEGMENTS HAVING MORE THAN 1 INTERNAL
		;POINT, SO THAT AT THE END, HOPEFULLY, EACH SEGMENTATION
		;WILL HAVE BEEN DONE WITH END PTS NEAR THE FINAL 
		;END PTS


SEGMEN:	JUMPE A,TPOPJ	;??
	MOVEM A,SEGNAM	;SAVE PTR TO SEG HEADER - CALLED FOR EACH CHAIN
	SKIPE PNTXY2
	PRINT _
	FILN B,FILNW(A)
	MOVEM B,SEGN	;NUMBER OF ELEMENTS IN CHAIN
	PUSHJ P,SEGPUS	;MOVE FROM LIST INTO ARRAY
	MOVE T,[-TVLONG,,TVPDLB-1]	;END POINT BLOCK (CORNERS)
	MOVEM T,SEGE1	;USED BY THE REPEAT ROUTINE

	HRRZ C,SEGP	;ADDRESS X-COMP FIRST PT
	MOVEI D,-1(U)	;ADDRESS X-COMP LAST PT

	MOVE E,SEGN	;COUNT
	CAIG E,2
	JRST SEGPZ	;SUPER SHORT SEGMENT

	PUSH T,C	;FIRST ENDPT
	PUSHJ P,SEGB2	;DO THE SEGMENTING (IT CALLS ITSELF RECURSIVLY - BUILDS UP CORNERS ON T)
	MOVEI A,-1(U)
	PUSH T,A	;LAST ENDPT

	PUSHJ P,SEGR	;REPEAT TO IMPROVE
	PUSHJ P,SEGR
			;OUTPUT ENDPTS
SEGPO:			;ENTRY FOR 2 PT SEGMENTS
	HRRZS SEGE1
	HRRZM T,SEGP	;SAVE UP T NOW
	SKIPE DSPLAY
	PUSHJ P,DISBRK	;DISPLAY THE BREAKS

SEGPO1:	SOS T,SEGP
	CAMG T,SEGE1
	POPJ  P,
	MOVE B,1(T)	;END POINTS OF DATA TO FIT
	MOVE A,(T)
	PUSHJ P,LFIT	;GO LINE-FIT
	PUSHJ P,GENVLT	;STORE AWAY RESULTS OF LINE-FIT
	JRST SEGPO1


SEGPZ:	PUSH T,C	;FIRST
	PUSH T,D	;LAST
	JRST SEGPO

DISBRK:	MOVE T,SEGP	;DISPLAY BREAKS WHERE WE DECIDED TO SEGMENT THINGS
	SOS T
	MOVE U,SEGE1
	AOS U
DISBR1:	CAMG T,U
	POPJ P,
	MOVE C,(T)
.F ZR(C),ZR(C+1)
	FIX B,-4
	FIX A,-4
	PUSHJ P,CHKDIS
	.VALUE		;NOT ON SCOPE FACE
	PUSHJ P,DCROSS
	SOJA T,DISBR1

	;REPEAT WITH ALTERNATE CORNERS - SOME NEW ONES MAY APPEAR - SOME OLD ONES MAY GO AWAY
SEGR:	HRRZ C,SEGE1	;BEGINNING
	CAIL C,-3(T)	;MORE THAN 3 CORNER PTS? IN THIS SEGMENTATION
	POPJ P,
	MOVEM T,SEGE1	;END SET (NEW START)
	AOS C
	PUSH P,C
	MOVEI D,(T)	;BEGINNING SAVED
	PUSH P,D	;END SAVED
	PUSH T,(C)
SEGR1:	AOS D,-1(P)
	CAML D,(P)
	JRST SEGRX
	HRRZ C,-1(D)
	HRRZ D,1(D)
	PUSHJ P,SEGB2	;SEGMENT AGAIN WHAT USED TO BE TWO SEGEMENTS
	JRST SEGR1

SEGRX:	PUSH T,(D)
	JRST POP2J

;CORNERS ARE STORED BETWEEN SEGE1 AND T
;EACH CALL TO THIS FUNCTION MOVES TO FRESH AREA ON T PDL

	;U NEEDS TO STORE 2* # ELEMENTS IN CHAIN
	;TRANSFORM INPUT LIST TO PDL (ON U)
SEGPUS:	MOVE U,[-TVLONG,,TVPDLC]
	MOVEI B,1(U)
	MOVEM B,SEGP
	FILY D,FILYW(A)	;GET Y LOC
	SOS D		;SO THEY COME OUT AS THEY ARE ON THE CHAIN
	MOVEM D,SEGY
	FILP B,FILPW(A)	;GET LIST PTR
.I VMAP<#SEGPU1>	;LIST POINTER ALREADY IN B
	POPJ P,


SEGPU1:	HLRZ A,(B)	;FETCH WORD
	LDB C,[150500,,A]	;EXTRACT ANGLE
	TRZ A,760000	;PURIFY X
	SOS B,SEGY
	PUSHJ P,VIDIXY	;CONVERT TO VIDI COORDS
	FLOAT A
	FLOAT B
	PUSH U,A	;PUSH FLOAT<X>
	PUSH U,B	;PUSH FLOAT<Y>
	SKIPN CHKSEG
	POPJ P,
	PUSHJ P,CHKMUT
	SKIPA
	POPJ P,
	.VALUE
	SUB U,[2,,2]
	POPJ P,

CHKSEG:	0	;-1 TO CHECK SEGPUS VALUES

	;CALC LINE BETWEEN END PTS
	;GET MAX NORMAL DISTANCE
	;RECURSE ON EACH HALF
		;A:LIST OF CORNERS,DOTTED PAIR FLOAT
		;C:	ADDRESS X-COMP FIRST PT
		;D:	ADDRESS X-COMP LAST PT

	;SEGMENT PDL (ON P)

SEGPMA==0	;PT WITH MAX NORM DISTANCE
SEGP2==-1	;ADDRESS X COMP LAST PT
SEGP1==-2	;ADDRESS X COMP FIRST PT
SEGS0==-3	;SAVE T

SEGNP==4	;LENGTH OF PDL

SEGMAX:	0	;MAX NORMAL DISTANCE
SEGSIN:	0	;SINE OF VECTOR P2-P1
SEGCOS:	0	;COSINE OF VECTOR P2-P1
SEGCC3:	0	;NORMAL DISTANCE OF LINE
SEGLNT:	0	;TEMP FOR SQUARE

;MIGHT BE MORE OF A WIN IF WE USED PROJECTED POINTS ONTO LINE-FIT STUFF INSTEAD OF ACTUAL POINTS FROM DATA


SEGB2:	CAIL C,(D)	;2 OR MORE POINTS ?
	POPJ P,
	PUSH P,U	;C,D POINT AT BEGINNING AND END RESP
	PUSH P,T
	PUSH P,C
	PUSH P,D
	PUSH P,[0]
.F SEGCOS=ZR(D)-ZR(C),SEGSIN=ZR(D+1)-ZR(C+1)	;DEL X, DEL Y
.F SEGLNT=SQRT<SEGCOS^2 +SEGSIN^2 >
.F SEGCOS=SEGCOS/SEGLNT,SEGSIN=SEGSIN/SEGLNT	;COS AND SIN
	HRRZ U,SEGP1(P)
.F SEGMAX=SEGLIM
.F SEGCC3=-(ZR(U)*SEGSIN-ZR(U+1)*SEGCOS)	;OFFSET FOR NORMAL DISTANCE (C3)

SEGB3:	ADDI U,2
.F \(ZR(U)*SEGSIN-ZR(U+1)*SEGCOS+SEGCC3)	;NORMAL DISTANCE
	CAMG A,SEGMAX	;NEW MAX NORMAL DIST?
	JRST SEGB4
	MOVEM A,SEGMAX	;RECORD THIS RECORD
	MOVEM U,SEGPMA(P)
SEGB4:	CAMGE U,SEGP2(P)	;TEST AND INCREMENT
	JRST SEGB3

	MOVE T,SEGS0(P)	;RESTORE T
	MOVE D,SEGPMA(P)
	JUMPE D,SEGB20	;NO REASON TO BREAK - SO POP UP ONE LEVEL

.I SEGB2<,,SEGP1(P),SEGPMA(P)>	;RECURSE ONCE

	PUSH T,SEGPMA(P)	;STORE CENTRAL PEAK POINT

.I SEGB2<,,SEGPMA(P),SEGP2(P)>	;RECURSE SECOND

SEGB20:	SUB P,[SEGNP,,SEGNP]	;FLUSH OFF VARIABLES
	POP P,U
	POPJ P,

LFITB:		;BEGIN LINE FIT DATA BLOCK
LFITX1:	0	;X PT1
LFITY1:	0	;Y PT1
LFITX2:	0	;X PT2
LFITY2:	0	;Y PT2
LFITSA:	0	;SIN ALPHA
LFITCA:	0	;COS ALPHA
LFITC3:	0	;C1*X+C2*Y+C3=0
LFITLL:	0	;		 PTR TO FIRST VERTEX
LFITRR:	0	;		 PTR TO SECOND VERTEX
LFITNN:	0	;NUMBER OF PTS
LFITSX:	0	;SUM X
LFITSY:	0	;SUM Y
LFITXX:	0	;SUM X*X
LFITXY:	0	;SUM X*Y
LFITYY:	0	;SUM Y*Y

LFITSQ:	0	;SUM SQUARED DEVIATIONS
LFITDA:	0	;MARKER OFTEN POINTS TO OTHER LINES IF THIS ONE INACTIVE
LFITLN:	0	;LENGTH
LFTLNT==.-LFITB

LFITL1:	0	;FIRST POINT LOC
LFITL2:	0	;LAST POINT LOC
LFITA:	0	;ANGLE OF LINE

;SYMBOLIC RELATIVE LOCATIONS DATA BLOCK

	LFTX1==0
	LFTY1==1
	LFTX2==2
	LFTY2==3

	LFTSA==4
	LFTCA==5
	LFTC3==6
	LFTLL==7
	LFTRR==10
	LFTNN==11
	LFTSX==12
	LFTSY==13
	LFTXX==14
	LFTXY==15
	LFTYY==16
	LFTSQ==17
	LFTDA==20
	LFTLN==21

;PERHAPS HAVE OPTION TO OMIT FIRST AND LAST POINT HERE

	;A:	PTR TO START OF PT PDL FOR LINE
	;B:	PTR TO END OF PT PDL

LFIT:	MOVEI F,(A)
	MOVEI G,(B)
	MOVEM A,LFITL1	;POINTER TO FIRST
	MOVEM B,LFITL2	;POINTER TO SECOND
.I SWIPE<#LFITB,#LFTLNT>	;ZERO OUT SUM-ACCUMULATORS
LFIT1:	CAMLE F,G
	JRST LFIT2	;GOT ALL OFF PDL
	MOVE A,(F)	;X COORD
	MOVE B,1(F)	;Y COORD
	PUSHJ P,LFITP	;ADD A PT TO LINE SUMS
	ADDI F,2	;GO TO NEXT POINT
	JRST LFIT1	;GO TO NEXT ONE

	;ADD A PT TO LINE SUMS
LFITP:	AOS LFITNN
	FADRM A,LFITSX	;SIGMA X
	FADRM B,LFITSY	;SIGMA Y
	MOVE C,A
	FMPR C,A
	FADRM C,LFITXX	;SIGMA X^2
	MOVE C,B
	FMPR C,C
	FADRM C,LFITYY	;SIGMA Y^2
	FMPR A,B
	FADRM A,LFITXY	;SIGMA X*Y
	POPJ P,

LFIT2:
.F LFITNN=FFLOAT<LFITNN>

	;SINA*X-COSA*Y+C3=0
;SOLVES FOR ANGLE AND INTERCEPT OF GENERAL LINEAR FORM
	PUSHJ P,LFIT3
.F LFITPR<LFITL1>	;PROJECT END PTS ON LINE
.F LFITX1=,LFITY1=
	PUSHJ P,CHKMUT
	.VALUE
.F LFITLN=\((LFITX2-LFITX1)*LFITCA+(LFITY2-LFITY1)*LFITSA)
.F LFITPR<LFITL2>
.F LFITX2=,LFITY2=	;AT THIS STAGE WE HAVE (LFITX1 LFITY1 LFITX2 LFITY2)
	PUSHJ P,CHKMUT
	.VALUE
.F LFITLN=\((LFITX2-LFITX1)*LFITCA+(LFITY2-LFITY1)*LFITSA)
.F LFITSQ=LFITQQ<>
	SKIPN PNTXY2
	POPJ P,
.F LFITX1/16.0,LFITY1/16.0,LFITX2/16.0,LFITY2/16.0
	PRINT _(%1F4.0 %2F4.0 %3F4.0 %4F4.0) 
.F SQRT<LFITSQ/LFITNN>/16.0
	PRINT RMS=%1F2.2
	POPJ P,

CHKMTT:	CAML B,FTVL	;SEE IF INSIDE REGION
	CAMLE B,FTVU
	POPJ P,
	CAML C,FTVL+1
	CAMLE C,FTVU+1
	POPJ P,
	AOS (P)
	POPJ P,

CHKMUT:	CAML A,FTVL	;SEE IF INSIDE REGION
	CAMLE A,FTVU
	POPJ P,
	CAML B,FTVL+1
	CAMLE B,FTVU+1
	POPJ P,
	AOS (P)
	POPJ P,


PNTXY2:	0	;NON-ZERO TO OUTPUT ENDPOINTS AS THEY ARE FOUND

LFIT3:
.F LFITA=ATAN2<(LFITXY-LFITSX*LFITSY/LFITNN)*2.0,LFITXX-LFITYY-$
.F (LFITSX^2 -LFITSY^2 )/LFITNN>/2.0
.F LFITSA=SIN<LFITA>
.F LFITCA=COS<LFITA>
.F LFITC3=(LFITSY*LFITCA-LFITSX*LFITSA)/LFITNN	;CALC DISTANCE FROM ORIGIN
	POPJ P,


;PROJECT A PT ON A LINE
	;CALC X COORD ALONG LINE X=COS*U+SIN*V
	;CALC CORRESP X ON LINE Y=C3
	;ROTATE BACK INTO ORIGINAL FRAME

LFITPR:
.F ,,ZR(A)*LFITCA+ZR(A+1)*LFITSA	;X' OF POINT ,Y' IS C3
.F LFITCA*C-LFITC3*LFITSA,LFITSA*C+LFITC3*LFITCA	;ROTATE BACK
	POPJ P,


;AVERAGE OF SQUARED DEVIATIONS FOR THE THREE
;PARAM FORM FOR STRAIGHT LINE
;SUM SQUARES OF (SIN*X-COS*Y+C3)
	;SIN*SIN*SXX-2*SIN*COS*SXY+COS*COS*SYY
	;-2*C3*COS*SY+2*C3*SIN*SX+C3*C3*N
;WHERE SXX IS SUM ON X*X AND SX IS SUM ON X

LFITQQ:	PUSH P,B
	PUSH P,C
.F LFITXX*LFITSA^2 -LFITXY*LFITCA*LFITSA*2.0+LFITYY*LFITCA^2 +$
.F (LFITSX*LFITSA-LFITSY*LFITCA)*LFITC3*2.0+LFITNN*LFITC3^2
	POP P,C
	POP P,B
	SKIPGE A
	MOVEI A,0
	POPJ P,

;;MULTI-ENTRY CODING
;FIRST INDEX IS THE FASTER MOVING INDEX
	;I.E.  LOC=Y*M+X

MULTIA:	MULTAA	;LOCATION OF ARRAY
MULTIL:	777	;HALF-LENGTH OF ARRAY  LIKE 777 < TVROWL/2
MULTIM:	0	;X DIMENSION OF IMAGE
MULTIN:	0	;Y DIMENSION OF IMAGE

IFG 777*2-TVROWL,[
	PRINTC MULTIL TOO LONG
]

	;ONLY A'S 14-17 SAVED

;MULTIA	ARRAY M*N*4 HALF WORDS
	;IF IMAGE LARGER THAN ARRAY,HASH-CODE
	;OR IF HASH-CODE 2*MULTIL
;MULTIF	FIND FUNCTION
;MULTII	INITIALIZE FUNCTION
;MULTIL	LENGTH ARRAY M*N*2
;MULTIM	X DIMENSION OF IMAGE
;MULTIN Y DIMENSION
;MULTIO	ORIGIN
;MULTIQ	SCALE FACTOR
;MULTIR	REFERENCE ARRAY TO AVOID REPEATS
;MULTIS	STORE FUNCTION
;MULTIU UNIT STEP SIZE
;MULTIX	CALC INDICES
	;MULTXC DIRECT INDEX CALC
	;MULTXH HASH-CODE INDEX CALC
;MULTIV MAPS FUNARG MULTI-ENTRY ON VECTOR
	;MULTVF FUNARG
;MULTIZ INITIALIZATION GIVEN SCALE FACTORS


MULTIO:	0	;X ORIGIN
	0	;Y	

MULTIQ:	0	;X SCALE FACTOR - (NUMBER OF INTERVALS / SPAN) - I.E. 1/STEPSIZE
	0	;Y 

MULTIU:	0	;X UNIT STEP SIZE
	0	;Y 

MULTRL==17	;LENGTH MULTIR BLOCK ? USED TO BE 7

MULTIP:	0	;SAVE GIVEN PTR (IN MULTI-FIND)

MULTIR:	BLOCK MULTRL	;SHORT BLOCK TO AVOID REPEATS

MULTM1:	0	;MULTIA(D)	LEFT	 MARGIN TABLES PTR INDEXED
MULTM2:	0	;MULTIA(E)	RIGHT
MULTM3:	0	;MULTIA+MULTIL(F)	LEFT
MULTM4:	0	;MULTIA+MULTIL(G)	RIGHT

MULCRX:	0	;X WHEN ENTERING MULTIX
MULCRY:	0	;Y
MULTNM:	0
;INITIALIZATION FUNCTION FOR MULTI-ENTRY
	;ZERO ARRAY
	;CALC SCALING, SET UP SCALE FUNCTION
		;IF IMAGE ARRAY LARGER THAN GIVEN ARRAY
		;HASH-CODE ENTRIES,OTHERWISE CALC
		;INDICES DIRECTLY

	;A: XLO FLOAT PT
	;B: YLO FLOAT PT
	;C: XHI FLOAT PT
	;D: YHI FLOAT PT
;MULTIA(ARRAY) AND MULTIL (LENGTH)
;MULTIM,MULTIN (DIMENSIONS OF IMAGE)
;MULTPD CONS PDL

MULTII:	MOVEM A,MULTIO	;ENTRY GIVEN SIZE OF ARRAY N,M
	MOVEM B,MULTIO+1
	FSBR C,A	;CAL SCALE FACTOR
	FSBR D,B
.F MULTIQ(0)=(FFLOAT<MULTIM>-1.0)/C
.F MULTIQ(1)=(FFLOAT<MULTIN>-1.0)/D
		;CONS PDL IS USED FOR POINTERS OUT OF ARRAY NOT FOR ANSWER LISTS
MULTZ:	MOVE V,[MULTP-EMULTP,,MULTP-1]	;CONS PDL	;OPTION OF FREE STORAGE OR PDL FORM OF CONS
.I MULTNM=MIN<MULTIL,MULTIM*MULTIN>
.I SWIPE<MULTIA,MULTNM*2>	;WIPE ARRAY BLANK - NO NEED TO GC THIS
	MOVE E,MULTIM	;DOES ARRAY FIT?
	IMUL E,MULTIN
	MOVEI F,MULTXC
	CAMLE E,MULTIL	;CALC OR HASH-CODE INDEX?
	MOVEI F,MULTXH
	MOVEM F,MULTXF
.F MULTIU(0)=0.95/MULTIQ(0),MULTIU(1)=0.95/MULTIQ(1)
	HRR A,MULTIA

	HRLI A,D	;INDEX FIELD
	MOVEM A,MULTM1

	HRLI A,E
	MOVEM A,MULTM2

	HRLI A,F
	ADD A,MULTNM

	MOVEM A,MULTM3
	HRLI A,G

	MOVEM A,MULTM4
.I SWIPE<#MULTIR,#MULTRL>
	POPJ P,

MULTIZ:	MOVEM A,MULTIO	;ENTRY GIVEN SCALE FACTORS
	MOVEM B,MULTIO+1
.F ,,(C-MULTIO(0))*MULTIQ(0),(D-MULTIO(1))*MULTIQ(1)
	FIX D
	FIX C
	ADDI D,2
	ADDI E,2
	MOVEM D,MULTIM	;X DIMENSION
	MOVEM E,MULTIN	;Y DIMENSION
	JRST MULTZ

IFN VEXTVF,[

MULTBG:			;TEST FUNCTION - FOR MULTI-ENTRY
.I MULTIM=20,MULTIN=5
.I TVL(0),TVL(1),TVU(0),TVU(1)
	FLOAT A,
	FLOAT B,
	FLOAT C,
	FLOAT D,
	PRINT _XL=%1F5.0 YL=%2F5.0 XH=%3F5.0 YH=%4F5.0
 
	PUSHJ P,MULTII	;INITIALISE
	POPJ P,

MULTBI:	PRINT _PTR=
	PUSHJ P,RDNUM
	PUSH P,A
	PRINT X=
	PUSHJ P,RDNUM
	PUSH P,A
	PRINT Y=
	PUSHJ P,RDNUM
	MOVE C,A
	POP P,B
	POP P,A
	PUSHJ P,MULTIS
	POPJ P,

MULTBF:	PRINT _PTR=
	PUSHJ P,RDNUM
	PUSH P,A
	PRINT X=
	PUSHJ P,RDNUM
	PUSH P,A
	PRINT Y=
	PUSHJ P,RDNUM
	MOVE C,A
	POP P,B
	POP P,A
	PUSHJ P,MULTIF
	MOVE B,A
.I VMAP<#PNTUS>
	POPJ P,

PNTUS:	PRINT _#1
	POPJ P,
]
CHKMLT:	0	;CHECK MULTI-ENTRY ARRAY INDECES

	;INDEX CALCULATION
	;INDICES IN 4,5,6,7

MULTXF:	MULTXC	; OR MULTXH - PTR TO FUN TO CALC INDEX

;CALC INDICES FOR MULTIA
MULTIX:
.F ,MULCRX=,MULCRY=	;SAVE SO CAN LOOK AT IF GET TO LATER
.F ,(&-MULTIO(0))*MULTIQ(0),(&-MULTIO(1))*MULTIQ(1),0.5+B,0.5+C

	FIX E
	FIX D
	FIX C
	FIX B
	SKIPN CHKMLT
	JRST @MULTXF	;CALCULATE INDEX (LEFT IN D,E,F,G)

	SKIPL C		;CHECK OUT
	CAML C,MULTIM
	.VALUE
	SKIPL D
	CAML D,MULTIN
	.VALUE
	SKIPL E
	CAML E,MULTIM
	.VALUE
	SKIPL F
	CAML F,MULTIN
	.VALUE
	JRST @MULTXF

MULTXC:	IMUL D,MULTIM	;CALC INDICES
	IMUL F,MULTIM
	MOVEI G,(F)
	ADDI G,(E)	;X',,Y'
	ADDI F,(C)	;X,,Y'
	ADDI E,(D)	;X',,Y
	ADDI D,(C)	;X,,Y
	POPJ P,

;C	D	E	F
;X	Y	X+.5	Y+.5

MULTXH:	HRL F,E		;X',,Y'
	HRL E,D		;Y,,X'
	HRL D,C		;X,,Y
	HRL C,F		;Y',,X
	IDIV F,MULTIL	;HASH CODE
	IDIV E,MULTIL
	IDIV D,MULTIL
	IDIV C,MULTIL
	POPJ P,
;FIND ASSOCS IN MULTI-ENTRY ARRAY

MULTIF:		;FETCH ALL NEAR TO (B,C) NOT EQUAL TO POINTER IN A
	MOVEM A,MULTIP	;SAVE UP POINTER
	PUSH P,B
	PUSH P,C
	PUSHJ P,GCMULT	;GC MULTIR
	POP P,C
	POP P,B
	SETZM A		;INITIALISE LIST TO BE RETURNED

MLTIFZ:			;ENTER HERE IF WANT TO KEEP MULTIR AND LIST SETUP (A SHOULD BE 0 OR CURRENT LIST)
	PUSHJ P,MULTIX	;CALC INDICES FOR STUFF IN B,C
	HLRZ B,@MULTM1	;THROUGH MARGIN TABLES
	HRRZ C,@MULTM2
	HLRZ D,@MULTM3
	HRRZ E,@MULTM4
MLTIFA:	JUMPE B,MLTIFL
	HLRE F,(B)
	CAMN F,MULTIP	;DISTINCT FROM INITIAL PTR
	JRST MLTIFN	;NO, IGNORE
	MOVEI T,(F)
	IDIVI T,MULTRL	;HASH CODE UNIQUE CHECK
	SKIPN G,MULTIR(U)
	JRST MLTIFC	;DISTINCT,GO CONS

MLTIFB:	HLRZ T,(G)	;MEMQ F LIST?
	CAIN F,(T)
	JRST MLTIFN	;YES, IGNORE
	HRRZ G,(G)
	JUMPN G,MLTIFB	;CONTINUE TO END OF LIST

MLTIFC:	CONS F,A,G,	;CONS ONTO LIST TO BE RETURNED
	HRRZI A,(G)
	CONSV F,G,T,MULTIR(U)	;PUT IN FOUND TABLE - T IS POINTER/MULTRL
MLTIFN:	HRRZ B,(B)	;NEXT ELEMENT
	JRST MLTIFA

MLTIFL:	SKIPN B,C	;NOW GET LIST IN C
	JRST MLTIF4
	SETZM C
	JRST MLTIFA

MLTIF4:	SKIPN B,D	;NOW GET LIST IN D
	JRST MLTIF5
	SETZM D
	JRST MLTIFA

MLTIF5:	SKIPN B,E	;NOW GET LIST IN E
	POPJ P,		;DONE WITH ALL FOUR
	SETZM E
	JRST MLTIFA

GCMULT:	MOVEI D,MULTRL-1	;USES A,B,C,D ;GCES MULTIR POINTERS
	SKIPE A,MULTIR(D)
	PUSHJ P,GCL
	SETZM MULTIR(D)
	SOJGE D,.-3
	POPJ P,

;VARIOUS MACROS TO HANDLE PDL FLAVOUR FREE-STORAGE USED IN MULTI-ENTRY 

IFN VEXTVF,[

DEFINE CONS0 C
	SKIPN C,VFREE
	PUSHJ P,FSUSUP
	HRL C,(C)
	HLRZM C,VFREE
TERMIN

DEFINE CONSA A,B
	HRL B,A
	CONS0 A
	MOVEM B,(A)
TERMIN
]

;CONSES ONTO LEFT HALF
DEFINE CONSVL A,B,SP,VAR
	HLR B,VAR
	HRL B,A
	PUSH SP,B
	HRLM SP,VAR
TERMIN


;CONSES ONTO RIGHT HALF
DEFINE CONSVR A,B,SP,VAR
	HRR B,VAR
	HRL B,A
	PUSH SP,B
	HRRM SP,VAR
TERMIN



;STORE IN MULTI ARRAY
	;A: PTR  B:X  C: Y
	;RETURNS PTRS BEFORE CONS IN B,C,D,E


MULTIS:	PUSHJ P,MULTIX	;CALC INDICES IN C-F DOESNT FLUSH DUPLICATES
	CONSVL A,B,V,@MULTM1
	CONSVR A,C,V,@MULTM2
	CONSVL A,D,V,@MULTM3
	CONSVR A,E,V,@MULTM4
	POPJ P,
;NO NEED TO GC THESE AS THEY ARE ON THE PDL WHICH GETS RESET WHEN INITIALISED
;MAPS FUNARG FOR MULTI-ENTRY ALONG A VECTOR
	;FUNARG IN MULTVF
;INTERPOLATE PTS ALONG VECTORS
	;A: PTR
	;B: X1
	;C: Y1
	;D: X2
	;E: Y2


MULTIV:	;MULTI-ENTER OR SEARCH A VECTOR
	PUSH P,A	;MPNTR
	PUSH P,[0]	;MXSTP
	PUSH P,[0]	;MYSTP
	PUSH P,B	;MXORG
	PUSH P,C	;MYORG
	PUSH P,D	;MXTOP
	PUSH P,E	;MYTOP
	PUSH P,[0]	;MNSTP
.F ,(MXTOP(P)-MXORG(P))/MULTIU(0),(MYTOP(P)-MYORG(P))/MULTIU(1)
	MOVMS B
	MOVMS C
	CAMGE B,C	;SEE WHICH IS GREATER
	MOVE B,C
	FIX B
	AOS C
	FLOAT C
	MOVEM C,MNSTP(P)
.F ,MXSTP(P)=(MXTOP(P)-MXORG(P))/MNSTP(P),MYSTP(P)=(MYTOP(P)-MYORG(P))/MNSTP(P)
.F MPNTR(P),MXORG(P),MYORG(P)
MULTV1:	PUSHJ P,@MULTVF
.F MPNTR(P),MXSTP(P),MYSTP(P),-1.0
	FADRB B,MXORG(P)
	FADRB C,MYORG(P)
	FADRB D,MNSTP(P)
	CAML D,[0.01]
	JRST MULTV1
.F MPNTR(P),MXTOP(P),MYTOP(P)
	PUSHJ P,@MULTVF
	MOVE A,MPNTR(P)
	SUB P,[MVLNN,,MVLNN]
	POPJ P,

MULTVF:	MULTIS	;FUNARG FOR MULTI-ENTRY (PUSH IF USED RECURSIVELY)

MPNTR==-7
MXSTP==-6
MYSTP==-5
MXORG==-4
MYORG==-3
MXTOP==-2
MYTOP==-1
MNSTP==0

MVLNN==8

;		########### FURTHER PROCESSING FUNCTIONS
.INSRT FOOD >
;		###########

IFN PROJFL,[

PROJP:	0	;FREE STORAGE PDL
PROJPA:	0	;AUX CONS PDL
PROJD:	10.	;STEP BETWEEN PROJ DEGREES
PROJDF:	0	;FL PT STEP RADIANS
PROJP1:	0	;PTR TO START OF PROJP
PROJQ:	0	;CURRENT LINES


PIOV2:	0	
RADIAN:	0	;180.0/PI

PROJLO:	0	;LOWER LEFT CORNER DOMAIN
	0
PROJHI:	0	;UPPER RIGHT CORNER DOMAIN
	0

PROJAL:	PROJLL	;LENGTH PROJ ARRAY
PROJRL:	PROJLL	;LENGTH PRO REFERENCE ARRAY TO CHECK UNIQUE

DEFINE ROTATE A,B,C,D
	MOVE C,A
	MOVE D,B
	FMPR A,PROJCA
	FMPR D,PROJSA
	FADR B,D
	FMPR B,PROJCA
	FMPR C,PROJSA
	FSBR C,B
TERMIN


;PROJ SEGMENTS PARALLEL TO PROJECTION ANGLE


PROJAA:	0	;ANGLE FOR PROJECTION
PROJSA:	0	;SIN ANGLE PROJ
PROJCA:	0	;COS ANGLE PROJ

PROJ1A:	0	;INDEX SAVED 


PROJ1:			;ENTRY
.I SWIPE<#PROJR,#PROJRL>
.I MULTVF=#PROJ3,MULTIA=#PROJA,MULTIL=#PROJAL
	MOVE V,PROJP	;CONS PDL
	HRRZM V,PROJP1
	MOVEI D,180.	;CALC # INTERVALS
	IDIV D,PROJD
	HRLI D,(D)
	HRRI C,1(V)
	ADD V,D		;FIRST LOCS ON PDL USED
			;FOR LISTS LINES EACH ANGLE
	SETZM -1(C)	;ZERO LISTS OF LINES
	HRLI C,-1(C)
	BLT C,(V)	;?

.F RADIAN=180.0/3.14159265
.F PROJDF=FFLOAT<PROJD>/RADIAN
.I VMAP<#PROJ12,LINES>
	MOVE V,PROJPA

;GO THROUGH ANGLES
	SETOM PROJ1A
PROJ14:	AOS C,PROJ1A	;LOOP OVER ANGLES
	MOVE V,PROJPA
	MOVEI A,(C)
.F PROJSA=SIN<PROJAA=FFLOAT<>*PROJDF-PIOV2>
.F PROJCA=COS<PROJAA>
;SET UP LIMITS IN ROTATED FRAME
.I PROJ15<TVL(0),TVL(1)>
.I PROJ16<TVL(0),TVU(1)>
.I PROJ16<TVU(0),TVL(1)>
.I PROJ16<TVU(0),TVU(1)>

.I MULTIZ<PROJLO(0),PROJLO(1),PROJHI(0),PROJHI(1)>	;INITALIISE MULTI-ENTRY

	MOVE B,PROJ1A	;INDEX
	ADD B,PROJP1
	MOVE B,(B)
.I VMAP<#PROJ2>
	JRST PROJ14

PROJ15:	SETZM PROJLO
	MOVE C,[PROJLO,,PROJLO+1]
	BLT C,PROJLO+3	;

PROJ16:	ROTATE A,B,C,D,
	CAMGE A,PROJLO
	MOVEM A,PROJLO
	CAMLE A,PROJHI
	MOVEM A,PROJHI
	CAMGE B,PROJLO+1
	MOVEM B,PROJLO+1
	CAMLE B,PROJHI+1
	MOVEM B,PROJHI+1
	POPJ P,

;THESE ARE MISSING FUNCTIONS

PROJCT:	STOP FUNCTION PROJCT DOES NOT EXIST
PROJ13:	STOP FUNCTION PROJ13 DOES NOT EXIST
COLINE:	0	;
QLINEA:	0	;

TVXBAR:	0	;MIDPOINT
	0


;CONS PTR INTO BINS FOR PROJ ANGLES
	;LENIENT TEST


;LFTDA WOULD NEED TO BE REINSTATED FOR THIS

PROJ12:
.F ,,2.5/(LFTNN(A)-1.0)
	FDVR C,B
	CAMLE C,[0.5]
	MOVE C,[0.5]
	MOVE C,[0.15]	;?
.F ,D=LFTDA(A)-C+PIOV2,&LFTA(A)+PIOV2
	SKIPGE E,D
	FADR E,PI
	CAMLE E,PI
	FSBR E,PI
	FSBR E,PI
	FDVR E,PROJDF	;FL PT INTERVAL
	FIX E
	ADD E,PROJP1
	CONSVR A,B,V,(E),
	FADR D,PROJDF
	CAMLE D,C	;LOOP TEST
	POPJ P,
	JRST PROJ13


PROJ2:	MOVEM A,PROJQ	;SAVE PTR
	JRST VISTAB
;ROTATES AND MAPS DOWN ASSOCIATIONS

PROJ3:	FSBR B,TVXBAR	;COORDS ABOUT XBAR,YBAR
	FSBR C,TVXBAR+1
	MOVE D,B
	MOVE E,C
	FMPR B,PROJSA	;ROTATE
	FMPR E,PROJCA
	FADR B,E
	FMPR C,PROJCA
	FMPR D,PROJSA
	FSBR C,D
	PUSHJ P,MULTIS	;RETURNS LISTS IN B,C,D,E
	PUSH P,E
	PUSH P,D
	PUSH P,C
	PUSHJ P,PROJ31
	POP P,B
	PUSHJ P,PROJ31
	POP P,B
	PUSHJ P,PROJ31
	POPJ P,


PROJ31:	MOVEI A,PROJ4
	TRNE B,777777
	JRST VMAP
	POPJ P,

;UNIQUE ASSOCIATIONS

PROJ4:	MOVEM A,PROJ4A	;SAVE PTR
	MOVE B,PROJQ
	MOVEI C,(A)	;HAVE WE SEEN PAIR BEFORE?
	HRLI C,(B)
	CAMG A,B
	MOVS C,C
	MOVE D,C
	IDIVI D,PROJRL	;HASH-CODE
	SKIPN D,PROJR(E)
	JRST PROJ4A
PROJ41:	HLRZ E,(D)	;MEMBER LIST?
	CAMN C,(F)	;SEEN BEFORE?
	POPJ P,	;IGNORE
	HRRZ D,(D)
	JUMPN D,PROJ41
PROJ4A:	CONS		;THIS MUST SURVIVE
			;MUST BE REAL CONS

	PUSHJ P,LFITET	;??? COMBINED FIT
	PUSHJ P,PROJCT	;COLINEAR?
	JUMPE A,PROJ43
	HRRZI C,COLINE
	JRST PROJLR	;MAKE RECOMMENDATION
PROJ43:	HRRZI C,QLINEA
PROJLR:	CONS B,D
	CONS A,B,D,
	CONS C,      
	POPJ P,
]

;SOME NAIVE DISPLAYS OF CHAINS OF EDGE FRAGMENTS

EPTS:	SKIPN DSPLAY
	POPJ P,
	HEAD FRAGMENTS
	PUSHJ P,TVDINO
	PUSHJ P,EPTSU1
	JRST DISGO

EPTSUM:	SKIPN DSPLAY
	POPJ P,
	PUSHJ P,TVDINI
EPTSU1:	PUSHJ P,TIMED1
.I VSMAP<#EPTSA1>	;DISPLAY NAIVELY
	JRST TIMED2

EPTSA1:	JUMPE A,TPOPJ
	MOVEM A,EPTSA	;SAVE POINTER TO ONE CHAIN
	FILY D,FILYW(A)	;HRRZ D,2(A)
	SOS D		;SO ITS IN PHASE FIRST TIME
	MOVEM D,EPTSY	;SAVE Y COORDINATE
	FILP B,FILPW(A)
.I VMAP<#EPTS2>
	POPJ P,

EPTS2:	SOS D,EPTSY
	LDB B,[150500,,A]
	TRZ A,760000
	TRNE A,10000	;??
	AND A,[-1,,760000]
	JRST VPTDIS	;OUTPUT LATER EDGES

EPTSA:	0	;LIST PTR
EPTSY:	0	;SAVE Y


PNTS:	SETZM YFLAG	;PRINT NAIVELY	
	SETZM EDCNT
	PRINT _
	PUSHJ P,TVSTMP
	PRINT __X - EDGES__
.I VMAP<#PNTEPX,#XEDGES>
	MOVE A,EDCNT
	PRINT __#1 X-CHAINS FOUND__
	SETZM EDCNT
	SETOM YFLAG
	PRINT __Y - EDGES__
.I VMAP<#PNTEPX,#YEDGES>
	MOVE A,EDCNT
	PRINT __#1 Y-CHAINS FOUND__
	POPJ P,

PNTEPX:	JUMPE A,TPOPJ
	AOS B,EDCNT
	PRINT __EDGE %2I2   
	MOVEM A,EPTSA
	FILY D,FILYW(A)	;HRRZ D,2(A)
	SOS D		;TO BE IN PHASE
	MOVEM D,EPTSY
	MOVE A,EPTSA
	FILN C,FILNW(A)	;N
	FILG E,FILGW(A)	;GLB SUM
	PRINT N=%3I3 G=%5I5 
	HLLZ B,3(A)
	HRRE C,3(A)
	HLLZ D,4(A)
	HRRE E,4(A)
	PRINT F10=%3I3 F1N=%5I3 F20=%2F4.1 F2N=%4F4.1_
	FILP B,FILPW(A)
.I VMAP<#PNTE1X>
	POPJ P,

PNTE1X:	SOS D,EPTSY
	LDB B,[150500,,A]
	TRZ A,760000
	TRNE A,10000	;??
	AND A,[-1,,760000]
	PRINT _X=%1I4 Y=%4I3 A=%2I3 
	MOVE C,B	;ANGLE
	MOVE B,D
	PUSHJ P,VIDIXY	;GET VIDI X AND Y
	LSH A,-4
	LSH B,-4
	PRINT XV=%1I4 YV=%2I4 AR=%3I2 
	PUSHJ P,THETAD	;CONVERT TO DEGREES
	PRINT AN=%3I3
	POPJ P,

EDCNT:	0

EXTEDG:	50.
EXTCHR:	0

EXTRES:		;FIND LOWER AND UPPER LIMITS IN FIELD
.I XLDS=YLDS=1023.,XHGS=YHGS=0
.I VSMAP<#EXTRE1>
.I XLDS=MAX<0,XLDS-EXTEDG>
.I YLDS=MAX<0,YLDS-EXTEDG>
.I XHGS=MIN<1023.,XHGS+EXTEDG>
.I YHGS=MIN<1023.,YHGS+EXTEDG>
	PUSH P,DSPARY
	SETOM DSPARY
	PUSHJ P,RIDLS	;DISPLAY RECTANGLE
	PRINT _O.K. ? 
	PUSHJ P,TYI
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST .-2
	MOVEM A,EXTCHR
	PUSHJ P,DARYF	;FLUSH DISPLAY ARRAY
	POP P,DSPARY
	MOVE A,EXTCHR
	CAIN A,"Y
	POPJ P,
	SETZM TYPED
	JRST GRID	;OH WELL, USE POT CONTROL

EXTRE1:	JUMPE A,TPOPJ
	FILY D,FILYW(A)
	SOS D
	MOVEM D,EPTSY
	FILP B,FILPW(A)
.I VMAP<#EXTRE2>
	POPJ P,

EXTRE2:	SOS D,EPTSY
	LDB B,[150500,,A]
	TRZ A,760000
	MOVE C,B
	MOVE B,D
	PUSHJ P,VIDIXY
	LSH A,-4
	LSH B,-4
	CAMGE A,XLDS
	MOVEM A,XLDS
	CAMGE B,YLDS
	MOVEM B,YLDS
	CAMLE A,XHGS
	MOVEM A,XHGS
	CAMLE B,YHGS
	MOVEM B,YHGS
	POPJ P,

EYE:	PUSHJ P,LOOK
	PUSHJ P,SCAN
	POPJ P,

SEGDIS:	SKIPN DSPLAY	;DISPLAY OF LINE-SEGMENTS
	POPJ P,
	PUSHJ P,TVDINO
	PUSHJ P,SEGDA1
	JRST DISGO

SEGDAS:	SKIPN DSPLAY
	POPJ P,
	PUSHJ P,TVDINI
SEGDA1:	PUSHJ P,TIMED1
.I VMAP<#SEFOU1,LINES>
	JRST TIMED2

SEFOU1:	SKIPE LFTDA(A)
	POPJ P,
	MOVE V,A
.F LFTX1(V),LFTY1(V)
	FIX B,-4
	FIX A,-4
	PUSHJ P,DSPPNI	;DISPLAY POINT
.F LFTX2(V),LFTY2(V)
	FIX B,-4
	FIX A,-4
	JRST DSPVCA	;CONNECT WITH VECTOR

TIMED1:	PUSHJ P,TIME
	SUB A,RUNDI3
	MOVNM A,RUNDI3
	SUB B,RELDI3
	MOVNM B,RELDI3
	POPJ P,

TIMED2:	PUSHJ P,TIME
	ADDM A,RUNDI3
	ADDM B,RELDI3
	POPJ P,

NUMBRL:	0
OFEDDS:	150.0	;EDGE LABLE DISTANCE

FOOD:	SETOM NUMBRL	;NUMBER THE SEGMENTS ON OUTPUT
	SKIPA
SEGOUT:	SETZM NUMBRL	;OUTPUT QUADRUPLES
	HEAD WRITE OUT
	PRINT_(_
	SETZM VRTNUM
.I VMAP<#SEGOU1,LINES>	;PRINT LINES SEGMENTS
	PRINT )_
	POPJ P,

SEGOU1:	MOVE V,A
	AOS E,VRTNUM
	SKIPE NUMBRL
	PRINT %5I3 
.F LFTX1(V),LFTY1(V)
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	PRINT (%1F4.0 %2F4.0 
.F LFTX2(V),LFTY2(V)
	SKIPE DISFLX
	PUSHJ P,UNMDST
	FSC A,-4
	FSC B,-4
	PRINT %1F4.0 %2F4.0)_
	POPJ P,

EDGMRK:	HEAD EDGE LABLES
	PUSHJ P,SEGDAS
	SETZM VRTNUM
.I VMAP<#EDGMR1,LINES>
	JRST DISGO

EDGMR1:	MOVE E,A
;TEST
.F (LFTX1(E)+LFTX2(E))/2.0+OFEDDS*LFTSA(E)*SIGN<LFTSA(E)>$
.F ,(LFTY1(E)+LFTY2(E))/2.0-OFEDDS*LFTCA(E)*SIGN<LFTSA(E)>
	FIX B,-4
	FIX A,-4
	SUBI B,2
	SUBI C,6
	PUSH P,FRCNPT
	SETOM FRCNPT
	MOVEI A,EDGMR2
	PUSHJ P,TALK
	POP P,FRCNPT
	POPJ P,

SIGN:	JUMPGE A,SIGNPL
	MOVN A,[1.0]
	POPJ P,

SIGNPL:	MOVE A,[1.0]
	POPJ P,

EDGMR2:	AOS A,VRTNUM
	PRINT #1
	POPJ P,

TVDINI:	SKIPN DSPLAY
	POPJ P,
	SKIPL DSPARY
	PUSHJ P,TVDIN2
	PUSHJ P,TVDIN3
.I DISAAD<DSPARY>
	POPJ P,

TVDIN2:
.I DISAFL<DSPARY>
.I ARYCLR<DSPARY,ESCSTP>
	JRST ADISON

TVDINO:	SKIPN DSPLAY
	POPJ P,
TVDIN3:	PUSHJ P,DISINS
	PUSHJ P,LFTFRM
.I TALK<#TVSTMP,0,1740>

RGHFRM:
.I DSPPNI<,1777-DLTCRN,1777>
.I DSPVCA<,1777,1777>
.I DSPVCA<,1777,1777-DLTCRN>
.I DSPPNI<,1777,DLTCRN>
.I DSPVCA<,1777,0>
.I DSPVCA<,1777-DLTCRN,0>
	POPJ P,

LFTFRM:
.I DSPPNI<,DLTCRN,0>
.I DSPVCA<,0,0>
.I DSPVCA<,0,DLTCRN>
.I DSPPNI<,0,1777-DLTCRN>
.I DSPVCA<,0,1777>
.I DSPVCA<,DLTCRN,1777>
	POPJ P,

DLTCRN:	20.

TVSTMP:	PRINT  
	PUSHJ P,STAMP
	PUSHJ P,NAMEP
	SKIPE VERSE
	TYPE VERSE@
	POPJ P,

VERSE:	0	;ADDRESS OF ASCII TEXT

TDISGO:	SKIPE DSPLAY
	JRST DISGO
	POPJ P,

;NEXT FEW PAGES IS CODE FOR HACKING PROGRAM RUNNING SIMULTANEOUSLY IN PDP6

P6=200000	;PLACE WHERE PAGE 0 OF PDP6 WILL APPEAR
MXTB=260+P6	;OLD POT BOX GETS READ IN HERE
TYPOUT=113+P6	;PSEUDO-CHARACTER PLACE

STARTA:	0	;START ADDRESS

USRO==15	;CHANNEL NUMBER ON WHICH PDP6 IS OPEN	
SYSI==16	;CHANNEL ON WHICH BINARY FILE IS READ

BUFLNG==200

UBUF:	BLOCK BUFLNG

SETUUO:	MOVEI B,41
	.ACCESS USRO,B
	HRROI B,A
	.IOT USRO,B
	POPJ P,

SLVUSR:	SIXBIT /BKPH  /
SLVFIL:	6,,(SIXBIT /DSK/)
	SIXBIT /SLAVE /
	SIXBIT /BIN   /

SLVEXT:	PRINT _RUNS_
	POPJ P,

SLVLOD:	PUSHJ P,OPNSIX
	SKIPL TYPOUT
	JRST SLVEXN
	MOVEI A,^Z
	MOVEM A,TYPOUT
	.IPDP USRO,	;INTERRUPT PDP6
	MOVEI A,10
	.SLEEP A,
	SKIPGE TYPOUT	;SEE IF HE ATE IT !
	JRST SLVEXT	;YES 

SLVEXN:	.OPEN USRO,PDP6IP	;DOES NOT LOAD SYMBOLS ON PDP6'S DDT
	STOP _PDP6 NOT AVAILABLE_
	.SUSET [.SSNAME,,SLVUSR]
	.OPEN SYSI,SLVFIL
	STOP _SLAVE DOESNT EXIST_
ALD:	MOVEI A,0
	PUSHJ P,SETUUO
ALDO:	PUSHJ P,GTWD	;READ BEGIN FILE
	SKIPN B
	STOP _PURE PROCEDURE_
	CAME B,[JRST 1]	;CHECK FOR END OF LOADER
	JRST ALDO

ALD1:	PUSHJ P,GTWD	;GET CTL WD
	JUMPGE B,ALDJ	;JRST OR CTL
	MOVE C,B	;-N,,ADR
ALD2:	MOVE D,B
	CAMGE B,[-BUFLNG,,]	;CHECK FIT IN BUFF
	HRLI B,-BUFLNG	;USE OWN SIZE
	HRRI B,UBUF	;IN BUFFER
	PUSHJ P,ALDRD	;GET BLOCK
	MOVEI A,(D)
	CAIE A,41	;DONT OVERLAY 41
	.ACCESS USRO,A	;BEGIN OUTPUT AT LD ADR
	MOVE A,B
	.IOT USRO,A	;MOVE BLOCK THERE
	SUB B,[-1,,]
	SUB B,D		;CHECK IF MORE IN LD BLK
	JUMPL B,ALD2	;GET ANOTHR BUFF
	PUSHJ P,GTWD	;END BLOCK, GET SUM
	CAMN C,B	;CHECK
	JRST ALD1	;LOAD NEXT BLK
	STOP CKS

EOF:	STOP EOF

ALDJ:	.CLOSE SYSI,
	MOVEM B,STARTA	;START IN FILE
	MOVE A,B
	PUSHJ P,SETUUO
	POPJ P,		;RETURN

ALDRD:	MOVE A,B
	PUSHJ P,GTWD1	;READ BUFF
	MOVE A,B
	ROT C,1		;ACCUM CHECK SUM
	ADD C,(A)
	AOBJN A,.-2	;FOR WHOLE BUFF
	POPJ P,

GTWD:	HRROI A,B	;SINGLE WORD TO B
GTWD1:	.IOT SYSI,A	;BLOCK IN
	JUMPL A,EOF	;UNABLE TO READ DESIRED CT
	POPJ P,

PDP6IP:	7,,(SIXBIT /USR/)
	0
	SIXBIT /PDP6  /

OPNSIX:	PUSH P,A
	.OPEN USRO,PDP6IP	;OPEN SIX AND APPEND FIRST 3 PAGES
	STOP _PDP6 NOT AVAILABLE_
	MOVE A,[002415,,500000]	;200000
	.CBLK A,
	STOP _PAGE APPEND FAILED_
	MOVE A,[002415,,501001]	;201000
	.CBLK A,
	STOP _PAGE APPEND FAILED_
	MOVE A,[002415,,502002]	;202000
	.CBLK A,
	STOP _PAGE APPEND FAILED_
.I ARYROT=#OPNSIX
	POP P,A
	POPJ P,

CLSSIX:	PUSH P,A
	MOVE A,[002015,,100000]	;FLUSH PAGES FROM MY PAGE TABLE
	.CBLK A,
	.VALUE
	MOVE A,[002015,,101001]
	.CBLK A,
	.VALUE
	MOVE A,[002015,,102002]
	.CBLK A,
	.VALUE
	.UCLOSE USRO,
	POP P,A
	POPJ P,

ORDER:	SKIPL TYPOUT	;SEND LETTER TO SLAVE PROGRAM IN PDP6
	JRST .-1
	PRINT $!
	PUSHJ P,TYI
	CAIN A,^C
	POPJ P,
	MOVEM A,TYPOUT
	.IPDP USRO,	;INTERRUPT PDP6
	JRST ORDER

FREE:	MOVSI A,400000	;CAUSE PDP10 TO RELEASE DEVICES
	.IOTLSR A,
	DATAO 20,[-1]	;ALL !!!! UN@TIL KNIGHT COMPLETES 24
	JRST FREEOV

	DATAO 24,[620]	;VIDISECTOR
	DATAO 24,[514]	;ROBOT CONSOLE
	DATAO 24,[570]	;OUTPUT MULTIPLEXOR
	DATAO 24,[574]	;INPUT MULTIPLEXOR
;	DATAO 24,[420]	;COLOR SCOPE
;	DATAO 24,[130]	;DISPLAY
;	DATAO 24,[340]	;MAG TAPE
FREEOV:	MOVEI A,0
	.IOTLSR A,
	POPJ P,


SIXRUN:	-1	;-1 IF PROGRAM IN PDP6 IS RUNNING READING POTS
PTSDWN:	0	;-1 IF POTS ARE OUT OF IT

GRID:	SETZM TYPED	;POT CONTROLLED BOX	*** LIBR STUFF
	SKIPE SIXRUN
	JRST GRID6
	.OPEN IMPC,[2,,(SIXBIT /IMX/)]
	STOP POTS WONT OPEN
	SKIPA
GRID6:	PUSHJ P,OPNSIX
	PUSH P,DSPARY
	SETOM DSPARY
GRID1:	SKIPE PTSDWN
	JRST REDPOO	;POTS ARE DOWN
	PUSHJ P,TVPOTS	;READ POTS
.I TVPOTB(4),TVPOTB(6),TVPOTB(5),TVPOTB(7)
	CAMGE B,A
	MOVE B,A
	CAMGE D,C
	MOVE D,C
.I XLDS=,XHGS=,YLDS=,YHGS=

REDPOL:	PUSHJ P,RIDLS
	JRST REDPUK

RIDLS:	PUSHJ P,DISINS	;DISIN2 ?
	PUSHJ P,DISAFL
.I DSPPNI<,XLDS,YLDS>
.I DSPVCA<,XHGS,YLDS>
.I DSPVCA<,XHGS,YHGS>
.I DSPVCA<,XLDS,YHGS>
.I DSPVCA<,XLDS,YLDS>
.I TVL(0)=XLDS*20,TVL(1)=YLDS*20,TVU(0)=XHGS*20,TVU(1)=YHGS*20
	JRST DISGO

REDPUK:	MOVEI A,10.	;1/3 SECOND
	.SLEEP A,
	SKIPN TYPED
	JRST GRID1
	SKIPN SIXRUN
	.CLOSE IMPC,
	PUSHJ P,DARYF	;FLUSH DSPLAY ARR
	POP P,DSPARY
	POPJ P,

XLDS:	0
XHGS:	0
YLDS:	0
YHGS:	0

TVPOTB:	BLOCK 10

TVPOTC:	70?71?72?73?74?75?76?77

TVPOTF:	TPOPJ?TVPOTA?TVPOTA?TVPOTA?TVPOTA?TVPOTA?TVPOTA?TVPOTA
		;SCALE FUNCTION

REDPOO:	PUSHJ P,TYI
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST .-2
	CAIN A,177
	JRST REDPOL
	PRINT _XL=
	PUSHJ P,RDNUM
	MOVEM A,XLDS
	PRINT  YL=
	PUSHJ P,RDNUM
	MOVEM A,YLDS
	PRINT  XH=
	PUSHJ P,RDNUM
	MOVEM A,XHGS
	PRINT  YH=
	PUSHJ P,RDNUM
	MOVEM A,YHGS
	PUSHJ P,TYI
	CAIGE A,40	;IGNORE CONTROL CHARACTERS
	JRST .-2
	SETZM TYPED
	JRST REDPOL

TVPOTS:	SKIPE SIXRUN
	JRST TVPTSX

	MOVEI B,100	;READ POTS
	MOVEI A,7
	SOS B
	MOVEM B,TVPOTC(A)
	SOJGE A,.-2
	MOVE A,[-4,,TVPOTC+4]	;[-10,,TVPOTC]
	.IOT IMPC,A

COMPOT:	MOVEI A,7	;SCALE POT VALUES
	MOVE B,TVPOTC(A)
	PUSHJ P,@TVPOTF(A)
	MOVEM B,TVPOTB(A)
	SOJGE A,.-3
	POPJ P,

TVPTSX:	MOVE A,[MXTB,,TVPOTC]
	BLT A,TVPOTC+7
	JRST COMPOT

TVPOTA:	SUBI B,100	;POT TO SCOPE COORDS
	FLOAT B
	FMP B,[0.60]
	FIX B
	CAILE C,1777
	MOVEI C,1777
	SKIPGE B,C
	MOVEI B,0
	POPJ P,
;THIS IS THE SECTION FOR VIDISECTOR INPUT

DSKINF:	0	;NON-ZERO FOR DISK INPUT
DEVICE:	TVC	;CHOICE OF DEVICE .VSCAN,TVLOAD,NOISE
INPUT:	0	;INPUT FUNCTION
TVTEST:	TVTST	;TEST FUNCTION
DSKOUF:	0	;DUMP FLAG,
DMPDAT:	0	;OUTPUT FUNCTION


TVOPEN:	MOVEI A,TVC	;SET UP INPUT AND OUTPUT FUNCTIONS
	SKIPE DSKINF
	MOVEI A,TVLOAD
	MOVEM A,DEVICE
.I DMPDAT=#TPOPJ
	PUSHJ P,@DEVICE	;SET UP INPUT
	SKIPN DSKINF	;IF INPUT FROM DISK, FORGET OUTPUT TO DISK
	SKIPN DSKOUF
	POPJ P,		;NO OUTPUT FUNCTION
.I DMPDAT=#TVDSOC
	PUSHJ P,TVBLKA	;CALCULATE BLKO POINTERS
	MOVEI A,7
	HRLM A,ONOP
	PUSHJ P,OPNDO	;OPEN OUTPUT FILE
	STOP $!$!
	TRZ ZR,DSOFLG
	MOVE A,[TVL-TVHEND,,TVL]
	.IOT DSOC,A	;OUTPUT HEADER
	POPJ P,


TVC:	PUSHJ P,TVDIM	;SET UP INPUT FILE FOR VIDI
	PUSHJ P,TVCOND
	SKIPE SIXRUN
	SETZM DSKGEN
	SKIPE SIXRUN
	JRST TVC6
.I #VSCAN,#TVTST
TVCOP1:	MOVEM A,INPUT	;SET INPUT FUNCTION
	MOVEM B,TVTEST	;SET TEST FUNCTION
	POPJ P,

TVC6:
.I ARYROT=#OPNSIX
.I #VSCAN6,#TVTST6
	SETOM PRCVID
	SKIPE DSKOUF
	SETOM DSKGEN	;LET PDP6 ASSEMBLE PACKED DISK DATA
	JRST TVCOP1

TVCOND:	MOVEI A,0	;SETUP BAT CONO BITS
	SKIPE TVDEV	;WHICH VIDISECTOR?
	TLO A,3200	;OLD  ,BITS 9,10,11 LEFT
	MOVE B,TVDIMC	;DIM CUTOFF,BITS 6,7,8 LEFT
	DPB B,[240300,,A]
	MOVE B,TVCONF	;CONFIDENCE LEVEL,BITS 4,5 LEFT
	DPB B,[220200,,A]
	HLRM A,PTBLE
	POPJ P,

TVLOAD:	MOVEI A,6
	HRLM A,INOP
	PUSHJ P,OPNDI	;SET UP DISK INPUT
	STOP $!$!
	TRZ ZR,DSIFLG
	MOVE A,[TVL-TVHEND,,TVL]
	.IOT DSIC,A	;BLOCK OF 16 WORDS HEADER
	PUSHJ P,TVDIM	;CALCULATE PICTURE PARAMETERS
	HRRI A,TVBI
	HRRM A,TVBLKX
	HRRM A,TVBLKY
.I #TPOPJ,#TVDSIC
	SKIPE SIXRUN
	SETZM PRCVID
	JRST TVCOP1

TVBLKA:			;CALC BLKO PTRS
.I TVBLKX=TVBLKC<TVNX1>
.I TVBLKY=TVBLKC<TVNY1>
	POPJ P,


TVBLKC:	SOS A
	LSH A,-2
	AOS A		;FOUR PER WORD, ROUND TO NEAREST WORD
	MOVNS A
	HRLS A
	HRRI A,TVBI	;-N,,ADR
	POPJ P,

TVDSIC:			;DSK INPUT FUNCTION
	MOVE A,TVBLKO	;BLKO PTR
	.IOT DSIC,A
	MOVEI A,0
	MOVE B,[1100,,TVBI-1]	;PT BYTER
TVDI2:	CAML A,TVN1
	POPJ P,
	ILDB C,B
	ADDI C,201	;MAKE UP FROM 9 BITS
	MOVEM C,ROWC(A)
	AOJA A,TVDI2


TVDSOC:	SKIPE SIXRUN
	SKIPN DSKGEN
	SKIPA
	JRST TVDO3
	MOVEI A,0
	MOVE B,[1100,,TVBI-1]	;PT BYTER
TVDO2:	CAML A,TVN1
	JRST TVDO3
	HRRZ C,ROWC(A)
	SUBI C,201	;9 BITS
	IDPB C,B
	AOJA A,TVDO2

TVDO3:	MOVE A,TVBLKO	;BLKO PTR
	.IOT DSOC,A
	POPJ P,
IOCINT==400	;IOC INTERRUPT BIT

TVSWT=P6+760
VIDCON=TVSWT+1
TXORG=TVSWT+2
TYORG=TVSWT+3
TXINC=TVSWT+4
TYINC=TVSWT+5
TCNT=TVSWT+6
PRCVID=TVSWT+7
TVCFLV=TVSWT+10
NONDIM=TVSWT+11
DSKGEN=TVSWT+12

VIDOUT=P6+1000
VIDPRC=P6+3000
DSKSTF=P6+5000

VSCAN6:	SKIPL TVSWT
	JRST .-1
	HLRZ A,RESOL
	MOVEM A,TCNT
	MOVE A,PTBLE
	HRRZM A,VIDCON

	MOVE A,MATC1
	MOVEM A,TXORG
	MOVE A,MATC2
	MOVEM A,TYORG

	MOVE A,MATR1
	IDIV A,TCNT
	MOVEM A,TXINC
	LSH A,-1
	ADDM A,TXORG
	MOVE A,MATR3
	IDIV A,TCNT
	MOVEM A,TYINC
	LSH A,-1
	ADDM A,TYORG

	SETZM TVCFLV
	SETZM TVSWT
	POPJ P,

TVTST5:	PUSHJ P,TVTSTW
TVTST6:	SKIPL TVSWT
	JRST TVTST5
	SKIPN DSKGEN
	PUSHJ P,DSDMOV
.I SLURP<#ROWC,#VIDOUT,TVN1>
	SKIPN PRCVID
	POPJ P,
.I SLURP<#ROWCG,#VIDPRC,TVN1>
	POPJ P,

DSDMOV:
.I SLURP<#TVBI,#DSKSTF,TVN141>
	POPJ P,

TVTSTW:
.I INTADR=#PDPON
	MOVE A,INTENA
	IORI A,IOCINT
	MOVNI B,1
	.SETM2 A,
	MOVEI A,30.*10.
WSLEEP:	.SLEEP A,
	POPJ P,

PDPON:	SKIPL NTRUPT	;BETTER BE RIGHT FLAVOUR INTERRUPT
	.VALUE
	HRRZ A,NTRUPT+1
	CAIN A,WSLEEP
	.DISMIS [TVTSTD]
	MOVE A,INTACS
	.DISMIS NTRUPT+1

TVTSTD:	MOVE A,INTENA
	MOVEI B,0
	.SETM2 A,
	POPJ P,

VSCAN:	.VSCAN PTBLE	;VIDI INPUT FUNCTION
	POPJ P,

TVTST:	PUSHJ P,VWAIT
.I SLURP<#ROWC,#TVROWB,TVN1>	;GET OUT OF WAY OF READ-IN
	POPJ P,

VWAIT:	MOVNI A,60.	;30 SECONDS
	MOVEM A,SLWCNT
	MOVE A,INTENA
	IORI A,SLWINT
	.SUSET [.SMASK,,A]
	MOVEI A,1
	.VSTST A,	;WAIT FOR IT TO COMPLETE
	SETZM SLWCNT
	.SUSET [.SMASK,,INTENA]
	POPJ P,

CLKINT:	CAIN A,SLWINT
	AOSE SLWCNT
	JRST DANT
	MOVNI A,1
	.VSTST A,	;FLUSH CURRENT SCAN
	.VSCAN PTBLE
	STRIKE VIDISECTOR BYTES $!$!$!_
	.DISMISS [VWAIT]	;TRY AGAIN


IFN VEXTVF,[
	;NO SIGNAL,RANDOM NOISE - TEST FUNCTION, GENREATES NOISE ONLY INPUT
NOISE:
.I #NOISEA,#TPOPJ
	JRST TVCOP1

NOISE9:	400.0	;MEAN VALUE
NOISE0:	0	;LOOP COUNT

NOISEA:	MOVE A,TVN1
	MOVEM A,NOISE0
NOISE2:	PUSHJ P,GAUSSR	;'GAUSSIAN' RANDOM NUMBER
	FMPR A,TVCERR	;STD DEV OF DEVICE
	FADR A,NOISE9	;MEAN VALUE
	FIX A
	SOSG A,NOISE0
	POPJ P,
	MOVEM B,TVROWB(A)
	JRST NOISE2



GAU1:	0	;TEMP STORAGE FOR GAUSSR

GAUSSR:			;RANDOM 0-1.0
.F GAU1=SQRT<LOG<RANDOM<>>*(-2.0)>
.F SIN<RANDOM<>*6.283185307>*GAU1
	POPJ P,
]
INTENA:	0
SLWCNT:	0

ATAN2:	PUSH P,C	;ARGUMENTS IN A AND B
	PUSH P,D
	PUSH P,E
	MOVE D,A
	MOVE E,B
	MOVMS A
   	MOVMS B
   	MOVE C,A
   	FSBR C,B
   	FADR A,B
   	FDVRB C,A
   	FMPR C,C
   	SETZM B
   	MOVEI F,10
   	FMPR B,C
   	FADR B,COEF-1(F)
   	SOJN F,.-2

   	FMPR B,A
   	FADR B,[0.785398163]
   	MOVN A,B
   	FADR A,[3.141592653]
	SKIPL E
   	EXCH B,A
   	FADR B,B
	SKIPGE D
   	FADR A,B
	POP P,E
	POP P,D
	POP P,C
   	POPJ P,

COEF:	 0.999999333 ; CNSTS FOR ATAN
     	 -0.333298561
     	 0.199465360
     	 -0.139085335
     	 0.0964200441
     	 -0.0559098861
     	 0.0218612288
     	 -4.054058^-3

;CRUFTIES FOR GENERATING INTENSTY MODULATED DISPLAYS

PRCNT:	0.10	;STEPS IN PERCENT/100.0
LOWF:	0	;USED TO CONVERT TO INTENSITY ON SCOPE
RATF:	2.0	;

VECSCL:	2
XINC:	2
YINC:	2
POINTS:	0

XNS:	64.	;SIZE OF INTERVALS
YNS:	64.

BUF1:	-1	;BUFFER ARRAYS
BUF2:	-1

BUFSLT:	0	;WHICH BUFFER CURRENTLY USED

XLDW:	0	;SCOPE WINDOW
YLDW:	0
XHDH:	1024.
YHDH:	1024.

XLVW:	0	;VIDI WINDOW
YLVW:	0
XHVH:	1024.
YHVH:	1024.

XWDD:	1024.	;SIZE OF SCOPE WINDOW
YWDD:	1024.

XWVD:	1024.	;SIZE OF VIDI WINDOW
YWVD:	1024.

ONHE:	1024.0

STDSIN:	.DSTOP
	PUSHJ P,DISINS
.I ARYCLR<DSPARY,ESCSTP>
	PUSHJ P,DISINS
	PUSHJ P,DISAAD
	JRST ADISON

COPPAR:
.I XLDW=XLDS,YLDW=YLDS,XHDH=XHGS,YHDH=YHGS
	JRST SETPA1

SETPAR:	GET XLDW,YLDW,XHDH,YHDH
SETPA1:
.I XLVW=XLDW,YLVW=YLDW,XHVH=XHDH,YHVH=YHDH
.I XWDD=XHDH-XLDW,YWDD=YHDH-YLDW
.I XWVD=XHVH-XLVW,YWVD=YHVH-YLVW
.I XINC=YINC=VECSCL
	R

;FIRST NEED TO GET MAXIMUM BY DOING IT ONCE !!!
LOOKH:	SZ OUTNOW
	SZ MAXB
	SO DSPLAY
	Q STUPPH
.I PTBLE=DCL*4+CFL
	PUSHJ P,SCANHH
	SO OUTNOW
	PUSHJ P,ARBITR
SCANHH:	M G,YNS
.I REDVIH<YLVW+YINC*(G-1)>	;READ TOP ROW
	Q SWTBUF	;SWITCH BUFFERS
	SOS G
LOPLOH:
.I REDVIH<YLVW+YINC*(G-1)>	;READ A LINE
	Q SWTBUF	;SWITCH BUFFERS
.I DISREH<YLDW+YINC*G>	;DISPLAY IT
	Q VWAIT		;WAIT FOR LAST ONE TO COME IN
LOPLOS:	SOJG G,LOPLOH

	Q SWTBUF
.I DISREH<YLDW+YINC*G>	;OUTPUT LAST LINE
	SKIPN OUTNOW	;FLUSH BUFFERS ONLY ON SECOND PASS
	R
	Q DISGO
.I ARYDEL<BUF1>		;FLUSH BUFFERS
	SO BUF1
.I ARYDEL<BUF2>
	SO BUF2
	SETOM DSPARY	;TO AVOID FLUSHING IT EASILY
	R

REDVIH:	LSH A,4		;READ A LINE
	HRLM A,MATC2	;NEW Y START
	Q GTBUF		;GET A BUFFER
	HRRM A,AOBARR	;BUFFER ADDRESS
	.VSCAN PTBLE	;SCAN
	R

ARBSTR:;	Q DCLEAR	;SET UP SCOPE AND BUFFER ARRAYS
.I BUF1=ARYALS<BUF1,XNS>
.I BUF2=ARYALS<BUF2,XNS>
	R

ARBITR:	Q STDSIN	;SETUP DISPLAY ROUTS
.F LOWF=MAXB*(1.0-7.0*PRCNT),RATF=MAXB*PRCNT
	M B,VECSCL
	J DSIZA

STUPPH:			;SETUP HORIZONTAL VSCAN
.I XNS=XWVD/XINC, YNS=YWVD/YINC
.I SWIPE<#MATR1,8.>
	Q ARBSTR
	MI A,1
	HRL A,XNS
	MM A,RESOL
	MOVN A,XNS
	HRLM A,AOBARR
	M A,XLVW
	LSH A,4
	MOVE B,XINC
	LSH B,3		;HALF AN INCREMENT
	SUB A,B
	HRLM A,MATC1
	M A,XWVD
	LSH A,4
	HRLM A,MATR1
	SETZM MATR4
	R

DISREH:	MM A,YLFT	;DISPLAY ONE INPUT LINE
	SKIPN OUTNOW
	JRST DISTRS
.I DSPPNZ<,XLDW-XINC,YLFT>
DISTRS:	SZ CRNINT
	Q GTBUF
	M V,A
	SZ U
DISLOH:	M A,(V)		;GET AN INTENSITY
	Q SELLEV	;GET LEVEL
	SKIPN OUTNOW
	JRST DIPLPH	;NOT OUTPUT PASS
	SKIPE POINTS
	J DIPYPH	;POINTS REQUESTED 
	CAME A,CRNINT
	Q CHNCRH
DIPLPH:	AOS U
	CAME U,XNS
	AOJA V,DISLOH
	SOS U
	SKIPE OUTNOW
	SKIPE POINTS
	R
DISTAH:	M W,CRNINT
	Q DSPBRT
.I DSPVCA<,(XLDW+XINC*U),YLFT>
	R

DIPYPH:	JUMPE A,DIPLPH
	CAME A,CRNINT
	Q CHPNIN
.I DSPPNI<,XLDW+XINC*U,YLFT>
	J DIPLPH

CHPNIN:	MM A,CRNINT
	M W,A
	J DSPBRT

CHNCRH:	PUSH P,A
	Q DISTAH
	POP P,CRNINT
	R


SELLEV:	TLNE A,3	;IS IT DC OR OF
	JRST FLOPVD
	M B,ONHE
	FDVR B,A
	CAMLE B,MAXB
	MOVEM B,MAXB
	SKIPN OUTNOW
	POPJ P,
	FSBR B,LOWF
	SKIPGE B
	SZ B
	FDVR B,RATF
	FIX B
	CAILE C,7
	MI C,7
	M A,C
	R

FLOPVD:	MI A,0	;DC OR OF
	R

GTBUF:	M A,BUFSLT	;GET BUFFER ADR
	M A,BUF1(A)
	M A,ARYORG(A)
	R

SWTBUF:		;SWITCH BUFFERS	
.I BUFSLT=1-BUFSLT
	R

OUTNOW:	0
MAXB:	0

YLFT:	0
CRNINT:	0
;ROWBA	H(X) INTENSITY-LOCAL AVG ROW B
;ROWC	INTENSITIES ROW C
;ROWCA	INTENSITY-LOCAL AVG ROW C
;ROWCC	CUTOFF VALUES
;ROWP	PRODUCTS
;H(X)=F(X)-<F(X)>	WHERE <F> IS LOCAL AVG CENTERED AT X

CONST:	CONSTANTS
VARIA:	VARIABLES


PAT:	
PATCH:	BLOCK PATCHL

VRTBEG:		;VERTEX BEGINNING			+++

TVPDLB:	BLOCK TVLONG	;PDL FOR INHMOGENEOUS POINTS AND LATER FOR CORNERS IN SEGMEN
TVPDLC:	BLOCK TVLONG	;PDL FOR COORDINATES IN SEGPUS

VRTEND:		;VERTEX END				+++

TVSPDL:	BLOCK VSPDLL	;SEGMENT BLOCKS (EDGE FRAGMENT CHAIN HEADER)

SEGLO:			;LOWER LIMIT OF SEGMENT DATA	---

TVROWB:	BLOCK TVROWL	;RAW VIDI BLOCK - BEING READ INTO ASYNCHRONOUSLY

;		***		A OLDEST

ROWALR:	BLOCK TVROWL

ROWAI:
ROWAAV:	BLOCK TVROWL

;		***		B

ROWBLR:	BLOCK TVROWL

ROWBI:
ROWBAV:	BLOCK TVROWL	

SEGHI:			;UPPER LIMIT OF SEGMENT DATA	---

;		***		C NEWEST

MULTP:		;MULTI-ENTRY CONS PDL BEGINNING 	$$$

ROWCS:
ROWCG:		;INTENSITY-LOCAL AVG
ROWCLR:	BLOCK TVROWL

ROWC:
ROWCI:		;INTENSITY
ROWCAV:	BLOCK TVROWL	

TVBI:		;USED TEMPORARILY IN DSK I/O
	BLOCK TVROWL

EMULTP:		;END OF MULTI-ENTRY CONS PDL		$$$

MULTAA:			;BLOCK FOR MULTI-ENTRY ARRAY
VLINKA:	BLOCK TVROWL	;ARRAY FOR LINKS -WIPED IN TVH & VLINK3 & RESETL

IFN PROJFL,[

PROJR:	BLOCK PROJLL
PROJA:	BLOCK 2*PROJLL

]

FS:
CORSIZ==<.+1777>_-10.

	END START

	FMPR B,A
   	FADR B,[0.785398163]
   	MOVN A,B
   	FADR A,[3.141592653]
	SKIPL E
   	EXCH B,A
   	FADR B,B
	SKIPGE D
   	FADR A,B
	POP P,E
	POP P,D
	POP P,C
   	POPJ P,

COEF:	 0.999999333 ; CNSTS FOR ATAN
     	 -0.333298561
     	 0.199465360
     	 -0.139085335
     	 0.0964200441
     	 -0.0559098861
     	 0.0218612288
     	 -4.054058^-3

;CRUFTIES FOR GENERATING INTENSTY MODULATED DISPLAYS

PRCNT:	0.10	;STEPS IN PERCENT/100.0
LOWF:	0	;USED TO CONVERT TO INTENSITY ON SCOPE
RATF:	2.0	;

VECSCL:	2
XINC:	2
YINC:	2
POINTS:	0

XNS:	64.	;SIZE OF INTERVALS
YNS:	64.

BUF1:	-1	;BUFFER ARRAYS
BUF2:	-1

BUFSLT:	0	;WHICH BUFFER CURRENTLY USED

XLDW:	0	;SCOPE WINDOW
YLDW:	0
XHDH:	1024.
YHDH:	1024.

XLVW:	0	;VIDI WINDOW
YLVW:	0
XHVH:	1024.
YHVH:	1024.

XWDD:	1024.	;SIZE OF SCOPE WINDOW
YWDD:	1024.

XWVD:	1024.	;SIZE OF VIDI WINDOW
YWVD:	1024.

ONHE:	1024.0

STDSIN:	.DSTOP
	PUSHJ P,DISINS
.I ARYCLR<DSPARY,ESCSTP>
	PUSHJ P,DISINS
	PUSHJ P,DISAAD
	JRST ADISON

COPPAR:
.I XLDW=XLDS,YLDW=YLDS,XHDH=XHGS,YHDH=YHGS
	JRST SETPA1

SETPAR:	GET XLDW,YLDW,XHDH,YHDH
SETPA1:
.I XLVW=XLDW,YLVW=YLDW,XHVH=XHDH,YHVH=YHDH
.I XWDD=XHDH-XLDW,YWDD=YHDH-YLDW
.I XWVD=XHVH-XLVW,YWVD=YHVH-YLVW
.I XINC=YINC=VECSCL
	R

;FIRST NEED TO GET MAXIMUM BY DOING IT ONCE !!!
LOOKH:	SZ OUTNOW
	SZ MAXB
	SO DSPLAY
	Q STUPPH
.I PTBLE=DCL*4+CFL
	PUSHJ P,SCANHH
	SO OUTNOW
	PUSHJ P,ARBITR
SCANHH:	M G,YNS
.I REDVIH<YLVW+YINC*(G-1)>	;READ TOP ROW
	Q SWTBUF	;SWITCH BUFFERS
	SOS G
LOPLOH:
.I REDVIH<YLVW+YINC*(G-1)>	;READ A LINE
	Q SWTBUF	;SWITCH BUFFERS
.I DISREH<YLDW+YINC*G>	;DISPLAY IT
	Q VWAIT		;WA