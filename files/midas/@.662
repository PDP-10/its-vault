; -*-MIDAS-*-

.SYMTAB 8001.,2000.

ITSFLG==:1			;POSSIBLE VALUES OF "SITE". MUST PRECEDE
CMU10FLG==:2			;"TITLE" SO THAT USER CAN DEFINE "SITE"
SAIFLG==:4			;EXPLICITLY USING (T) SWITCH.
T10FLG==:10			;TOPS-10
TNXFLG==:20			;THIS DOESN'T WORK YET!!  -- MRC
CMU20FLG==:40			;THIS PROBABLY WORKS -- JMN
T20FLG==:100			;TOPS-20, SORT OF

TITLE ATSIGN

SUBTTL	AC'S, SITE INFO, AND VERSION

IFNDEF VERSION,[
    VERSION==.FVERS
    IFE VERSION-635.,SUBVER==1	;SET SUBVERSION IF WE EDITED AWAY FROM MIT
    IFL VERSION,[		; if .FNAM2 not numeric
      PRINTX "What is @'s version number? "
      .TTYMAC VRS
	VERSION==VRS
      TERMIN
    ];IFL VERSION
];IFNDEF VERSION
IFNDEF SUBVER,SUBVER==0

IF2,[; This exists for compiling @ with CCL-type MIDAS
  NOITS,[
    NOCMU,[
      PRINTX/... is halfway
/
    ];NOCMU
  ];NOITS
];IF2

;;; ***** ACCUMULATORS *****

F=:0	;FLAGS
A=:1	;TEMPORARY
B=:2	;TEMPORARY
C=:3	;TEMPORARY
D=:4	;TEMPORARY
L=:5	;NOT SO TEMPORARY
R=:6	;NOT SO TEMPORARY
H=:7	;USED FOR JSP'S
N=:10	;<PAGE #>,,<LINE # -1>
CP=:11	;CHAR POINTER, E.G. FOR SYLBUF
CH=:12	;CURRENT CHAR
CC=:13	;CHARACTER COUNT (PASS 2)
IP=:14	;INPUT CHAR POINTER
DP=:15	;DATA POINTER
SP=:16	;SYMBOL TABLE POINTER/SLBUF POINTER
P=:17	;PDL POINTER

;;; CP, CH, CC, IP MUST BE CONSECUTIVE - SEE SORT

.XCREF F A B C D L R H CH P

;;; This was added to help track down a phase error

basedot=.
define outdot X,Y
	printx /Y: .=X
/
termin
define here X
	outdot \.-basedot,X
termin


SUBTTL	BUREAUCRACY: WHO DID WHAT TO @ WHEN

;;; ***** PEOPLE WHO HAVE HACKED THE PROGRAM *****
;;; GLS		Guy L. Steele Jr.   (GLS@MIT-MC)
;;; RMS		Richard M. Stallman (RMS@MIT-AI)
;;; RHG/RG02	Richard H. Gumpertz (Gumpertz@CMU-10A)
;;; MRC		Mark Crispin        (MRC@SU-AI)
;;; MOON	David A. Moon       (MOON@MIT-MC)
;;; EAK		Earl A. Killian     (EAK@MIT-MC)
;;; MT		Michael Travers	    (MT@MIT-XX)
;;; JMN		Joseph M. Newcomer  (Newcomer@CMU-10A)

;;; THE AUTHORITATIVE SOURCE FOR @ IS [MIT-AI]QUUX;@ >

;; WARNING: RMS, MRC, AND GLS DON'T TAKE THIS BUREAUCRACY VERY SERIOUSLY.

;;; ***** Modification History *****
;;;   Date	Who	Description
;;;	-	-	Modifications prior to 28 Mar 76 went unrecorded
;;; 28 Mar 76	RHG	Redid line number checking
;;;	"	"	Fixed bug in /-T caused by line number hacking
;;;	"	"	Added PDL overflow handling for BOTS
;;;	"	"	Added "extended LOOKUP" code under BOTS
;;;	"	"	Added creation date printing to PTLAB for BOTS
;;; 29 Mar 76	"	Added DROPTHRUTO macro
;;; 30 Mar 76	RMS	Clean up problems in ITS version introduced by above.
;;; 01 Apr 76	RMS	Added /L[PL/I]
;;; 01 Apr 76	RMS	Displays info on progress of listing in the .WHO variables.
;;;	"	"	/nS sets symbol space to <n> symbols.
;;; 03 Apr 76	"	PTLAB made more subroutinized, and more uniform across versions.
;;;	"	"	1st line of continuation pages is never used for text.
;;;	"	"	Date appears on sym tab, CREF, SUBTTL table of contents, ...
;;;	"	"	Infamous excess almost-blank page bug fixed.
;;; 06 Apr 76	RHG	Added /K switch support, redid CKLNM (again -- sigh)
;;;	"	"	Suppressed checksumming of line numbers, except under /K switch
;;; 07 Apr 76	"	Fixed bug in last changes to checksumming, CKLNM
;;; 	"	"	Simplified PTLO hacking for TWOSEG
;;;	"	"	Fixed date setting for BOTS copyrights
;;;	"	"	Added SITNAM stuff
;;;	"	"	Fixed /nS printout on title page
;;;	"	"	Fixed bug causing last page to always be printed under BOTS
;;; 26 Apr 76	MRC	Fixed PPN printout lossage under BOTS
;;; 15 Jun 76	Moon	Added /L[UCONS]
;;; 05 Sep 76	MRC	Fixed assembly error in BOTS
;;; 05 Sep 76	RMS	OBARRAY assembled without literals
;;;     "	"	LISPSW conditional to save space in DEC version
;;; 07 Sep 76	"	SAIL PPN's, font files and XGP commands
;;;	"	"	/X[QUEUE]
;;; 19 Sep 76	MRC	Fixed SAIL PPN's, and pretty cases
;;;			Installed(and debugged) RMS' written in patches
;;; 02 Oct 76	RMS	Made SAIL version work.  Understand ETV directories & padding.
;;;			/L[TEXT]
;;; 18 Oct 76	RHG	Made PGNSPC include space for PPN, in CMU version
;;;		RMS	Made automatic queueing work in SAIL version
;;;			Understand that a narrow font 0 means more room for text
;;;			 (But doesn't work yet - see comment in FNTCPT)
;;;			On DEC system, "FOO" specifies either null extension or default.
;;;			Except on ITS, don't use top line of page for text.
;;; 24 Dec 76	RMS	/Y means always print real page #, not virtual.
;;;			Output file names don't default stickily;  defaulted at
;;;			open time directly to the /O[...] names.
;;; 26 Dec 76	RHG	Added defs of CMUDEC and DECCMU so can assemble on ITS
;;;	"	"	Added prompt for VERSION if .FNAM2 is MID
;;;	"	"	Added printing of .FNAM1 and VERSION in non JCL mode
;;; 24 Jan 77	"	Changed PDLCHK etc. to fix LRCEND if it changes
;;;	"	"	Made LRCLEN not be referenced until SYMINI
;;;			so that can be changed by a (yet to be added)
;;;			switch in the LREC file.  Until SYMINI, the LRC
;;;			area can grow since it is at the top of core.
;;;	"	"	Changed LRCLEN, SYMLEN, and PDLLEN to be positive
;;;	"	"	Added DFLANG to indicate the default language
;;;  3 Mar 77	"	Eliminated quoting NULLs for the CMU XGP
;;; 18 Mar 77	"	Moved some SUBTTLs and definitions around
;;;	"	"	Added DEFVG, but no switch to set it
;;;	"	"	Changed 1INSRT to DIE if try to INSERT too many files
;;;			If anyone doesn't like this, at least make it
;;;			ask the user before continuing, thereby possibly
;;;			deleting files from the LRC file
;;; 23 Mar 77	RHG	Changed /1G to not only not generate
;;;			but also to get rid of gaps and slashified pages
;;;	"	"	Changed /Y to refer to old pages by the printed number,
;;;			not the "real" page number.
;;;	"	"	Made .LRC files on DSK go on the same structure
;;;			as the existing .LRC file, if extended LOOKUPs work
;;; 24 Mar 77	"	Made the protection bits be preserved when entering
;;;			a .LRC file, if there previously was a .LRC file.
;;;	"	"	Made /Y not print as "renumbered" those pages
;;;			which really haven't changed at all.
;;;  1 Apr 77	RMS	Added /L[TECO]
;;; 19 Apr 77	MRC	Fix Twenex system names clobbering SUBTLS.
;;; 29 Apr 77	RMS	Flushed DEFVG, which was compensating for bugs in
;;;			something better which RHG didn't know existed
;;;			(sorting definitions by type), which I caused to work.
;;;     "	"	Made /L[TEXT] not use SLURP or OUTLIN, copy input right thru to output.
;;;			Also, it understands the format of ITS XGP files and
;;;			is not confused by ^L's that are really XGP commands.
;;;  7 Sep 77	RMS	Made .INSRT on non-ITS allow a null FN2 to stand for itself
;;;			as well as for the default.
;;;	"	"	Added GLPTR spooling and renamed NOQUEUE to QUEUE.
;;;	"	"	Made CREFs start with a key of what the funny symbols mean.
;;;	"	"	Made the language default from the FN2 when possible.
;;;  7 Sep 77	MRC	Added TNXFLG value for .SITE.  Does not do much at all
;;;			right now; any volunteers to JSYSify it?
;;;	"	"	Made it .INSRT CMUDFS or SAIDFS instead of DECDFS for the
;;;			CMU and SAIL versions; flushed @'s definition of SAIL and
;;;			CMU UUO's.
;;;	"	"	Flushed setting DSKFUL on non-CMU DEC; this should be up
;;;			to the user and not randomly done by a program, but CMU
;;;			hackers like things doing this (so Rick claims).
;;; 21 Sep 77	RHG	Added back the version number hacking for
;;;			source edited away from MIT.  Changed CMU's
;;;			prompt back to "@".
;;;	"	"	Fixed a bug in 2LOOP7.  Some loser indexed off
;;;			A when it had been clobbered by calls on TITLES.
;;;			Also suppressed page map, etc. if ALL pages
;;;			are going to be listed.  This assumes that if
;;;			all pages have NEWPAG set, then all logical
;;;			page numbers will match their physical
;;;			page numbers.  As far as I can tell, CPR does
;;;			guarantee this.
;;; 22 Sep 77	"	Fixed 1INSRT to default null FN2's properly on ITS
;;;			Made files in the LREC file which are not found
;;;			call FLOSE to let the user have a chance to recover.
;;; 28 Sep 77	MRC	Made  an alias for _ so that underscore and backarrow
;;;			will both win at SAIL and ITS.
;;;	"	"	Flushed GETTAB's getting executed at SAIL.
;;;	"	"	Fixed 1.IPPN -- nobody ever wrote SAIL code for it!  Foo.
;;;	"	"	Flushed extended LOOKUP code under SAIL -- there's no
;;;			such garbage at SAIL and it was extra disk overhead.
;;;	"	"	Other SAIL bug fixes hither and yon.
;;;	"	"	A few more half-hearted Tenex code things.  *SIGH*
;;;  6 Oct 77	RHG	Fixed a bug I introduced accidentally in ENDUND.
;;;  7 Oct 77	"	Made FISORF default on for CODRND and CODTXT
;;;			where the order really doesn't matter anyway.
;;;  4 Apr 78   RMS	Page numbers in table of contents go at left margin.
;;;	"	"	/Z/L[Random] takes the first nonblank line on each
;;;			page to be the subtitle.
;;;	"	"	XGP line-space commands are treated like LF's
;;;			by the checksummer.  Random 012's inside commands
;;;			are not treated as LF's.
;;;	"	"	In DEC version, when the language is learned from the FN2
;;;			the default switches for that language are set.
;;;	"	"	.LIBFIL in an assembler-language file means
;;;			ignore the file completely, if it isn't being listed.
;;; 10 Apr 78	RMS	Merge in JDS's MUDDLE hackery.
;;;	"	"	Flush STYPE.  All types are ASCIZ now.  Create SYMOUT.
;;;  9 May 78	MRC	Fixed assembly errors when making a SAIL version.
;;;			Damnit, when you hack it, make sure it will at least
;;;			compile for the other versions!
;;; 17 Jun 78	RHG	Commented out the CMU stuff for the extra ^J
;;;			in 2PAGE.  Also upped CMU default for NFILES.
;;;	"	"	Suppressed the blank page which was printed
;;;			if /Z but no Table of Contents to print.
;;;	"	"	Upped LSYLBUF for CMU, since people like
;;;			to type a lot, sometimes.
;;;	"	"	Upped NBFRS at CMU to 7, because the CMU-10A
;;;			KL-10 is disk bound
;;; 30 Jun 78	EAK	Created new language DAPX16 (PDP10 cross assembler
;;;			for Honeywell 516/316)
;;; 10 Jul 78	MRC	Added support for the @ monitor command at SAIL
;;;			Fixed undefined symbol lossage introduced by DAPX16 edit.
;;; 28 Jul 78	RMS	Added F.CRDT - file creation dates appear in LREC files.
;;;	"	"	Make @DEFINEd definers with with forms like (MYDEFUN (FUNCTION ...
;;;	"	"	Make /_/O[FOO DLREC] work.
;;; 15 Sep 78	RMS	Make /nA print symbol table truncating symbols to n chars.
;;;	"	"	Quote special characters in commands to XQUEUE.
;;;	"	"	FPDLNG has second priority to CODTYP remembered in LREC file.
;;;	"	"	Ignore nonexistent input files if /L[Text]/X.
;;;	"	"	Anything starting with DEF gets @DEFINEd automatically if used.
;;; 19 Sep 78	RHG	Fixed BOTS version of PTLAB to pass argument to
;;;			PTQDAT in R, not A.
;;;	"	"	Changed NOITS version of FPRCHS to use the
;;;			extended LOOKUP info, if available.
;;;	"	"	Made processing of NONE: more complete
;;;	"	"	Made 1CKLNM work even with /L[TEXT] by changing
;;;			it to a PUSHJ type subroutine.
;;;	"	"	Changed DATOUT to also print a time
;;;	"	"	Changed title pages to include creation date
;;;			of comparison file (F.OCRD), if available.
;;; 20 Sep 78	"	Got rid of some unreferenced symbols -- not
;;;			really necessary but I was feeling perverse.
;;;			Similarly, lined up some comments vertically (sigh).
;;;	"	"	Added more in preparation for /L[TEXT]/X at CMU.
;;; 21 Sep 78	"	Finished adding /L[TEXT]/X for CMU
;;;	"	"	Generalized the hack RMS installed on 15 Sep 78
;;;			to be controlled by /! switch.
;;;	"	"	Added the macroes XGP, NOXGP, ITSXGP, NOITSXGP,
;;;			CMUXGP, and NOCMUXGP to make things easier to read.
;;;	"	"	Changed OKMISS to have three values. 0 means
;;;			ignore missing files, +1 means ignore only after
;;;			asking a question and getting no substitute file.
;;;			This allows deletion via NONE: hack.
;;;			-1 (the default) means do nothing special.
;;;			Also renamed OKMISS to NXFDSP for Non-eXistent File DiSPosition
;;;	"	"	Fixed FPFILE to understand <null>.EXT under BOTS
;;;	"	"	Made BOTS version clobber .JBSA since we can't
;;;			be restarted anyway.
;;;	"	"	Fixed DLRPS to handle unknown PSW words
;;; 22 Sep 78	"	Fixed XSLUR1 label to be in the right place
;;; 24 Sep 78	RMS	Packed NXFDSP into word 11 of LR.PSW
;;; 27 Sep 78	RMS	Changed sense of NXFDSP.
;;;	"	"	Created SWPRSN - print switch showing sign of argument.
;;;	"	"	Fixed lossage of low bits set in SYLBUF.
;;;  2 Oct 78	RHG	Fixed GO2 to not call FPDLNG if ECODTY set
;;;	"	"	Fixed FPRCHS (NOITS/NOSAI version) to
;;;			Get the date BEFORE clobbering CH.
;;;	"	"	Fixed BOTS version of TITLES to allow
;;;			for longer file names (including DEVn:)
;;;  3 Oct 78	MRC	Add /XGP switch to XSPOOL command since
;;;			.ATC extension loses otherwise.
;;; 12 Oct 78	RHG	Made /L[TEXT] and /L[RANDOM] compare the file
;;;			creation dates.  If equal, assume file unchanged.
;;;			Also fixed DEVICE defaulting after parsing NONE: in
;;;			FPDEF to assume DSK unless explicitly set to NONE: again
;;;	"	"	Fixed 1LOOP/1DONE1 to avoid a page table for skipped files
;;; 19 Oct 78	RHG	Renamed 1INSRO to 1INSOP to avoid potential confusion with 1INSR0
;;; 20 Oct 78	RHG	Changed 2OCLSQ to type the number of pages in a file.
;;; 22 Nov 78	MT	Added .DEFMAC and .RDEFMAC hacks for assembly langs.
;;;  6 Feb 79	JLK	Changes to Gould spooler commands.
;;; 18 Feb 79	RMS	Made ITS version get /L from -*-language-*-
;;;			Made ITS left margin 128 again.
;;;			No tab before subtitles in /# mode.
;;; 13 May 79	MT	Let XGP header-page stuff be included for ITSXGP, NOITS sites.
;;; 16 May 79	MT	Treat tab as space in FAIL.
;;;  8 Jul 79	RHG	Changed 1RSUBT to recall CKLNM when LF is encountered.
;;;  5 Sep 79	RHG	Changed TTIL to ignore naked LFs.
;;;			Added TEXTP and positive FAILP settings
;;;			Added /> and /= switches
;;;  7 Sep 79	"	Added /M[<left>,<right>,<top>,<bottom>] to
;;;			set the margins (where arguments are in mils).
;;;			Note that at CMU the <right> and <bottom> are
;;;			effectively ignored because we do no FONT hackery.
;;;			Also added 000XCR as combo for 000X and CRLOUT.
;;;  8 Sep 79	"	Fixed SUBOUT to not truncate the longest SUBTITLE.
;;;			Note that SUBLEN is now unused and maybe should not be computed.
;;;			Added some more NONE: hacking to FPDEF and FPSFND.
;;;			Also, got a bit ANAL and lined up many comments.
;;;  9 Sep 79	"	Changed WLRWX to suppress LR.CPY subentry if FLQPYM off.
;;; 10 Sep 79	"	Changed default margins for CMU and fixed a few typos.
;;;  4 Oct 79	"	Moved up the FMT=1 in CMU style .XGO files
;;;			Also fixed a typo that caused /Y to turn on magically.
;;;  5 Oct 79	"	Changed TAB in PALX11 to act like SPACE, for FOO<sp>: etc.
;;; 18 Oct 79	MT	Added ITSOUT to print ITS filenames on non-ITS systems
;;;			Make .DEFMAC work under MIDAS, FAIL, and DAPX modes.
;;; 19 Oct 79	RHG	Upped NFILES at CMU to 200.
;;; 22 Oct 79	EAK	Changed assembly conditionals, flags, etc.  VERSION
;;;			now determined by .FVERS, SITE by .OSMIDAS.  .DECSAV
;;;			is used instead of .DECREL.  .DECTWO still used on
;;;			two-seg systems.
;;; 18 Nov 79	RHG	Changed RLRRX to check EMARGIN before clobbering the margins.
;;;			Changed CAIN CH,^J to CAIE CH,^J in 2TEXGP on the suspicion
;;;			that the former was a typo.  Forgive me if I erred.
;;;			Changed TABHED to use FNAMCW instead of 24.
;;;			Fixed FPSMNP to use H instead of A as the JSP register when calling FPSNUM
;;;			Added DEVICE, etc. as a replacement for FLXGP and QUEUE, but
;;;			haven't made them do anything yet.  The intention is to
;;;			add DOVER PRESS file output.  For now, however,
;;;			device DOVER will look much like device LPT.
;;;			Temporarily, /0X will indicate DOVER output, but this is VERY TEMPORARY.
;;; 20 Nov 79	"	Added SUBVER hacking
;;;			Changed ITSOUT to FNTOUT and made it OK for SAIL which
;;;			has ITS-like XGP code.
;;;			Deleted some unreferenced labels.
;;; 10 Dec 79	"	Got rid of /0X kludge and added /D[device].
;;;			Split DEVDOV into DEVPDO, DEVLDO, and DEVTDO.
;;;			Added /" to hack per-page headings
;;;			Fixed SLTBL to put entry for "/" in the right place.
;;;			Fixed SLALT to clear FRLTAB
;;;			Fixed FPSNUM so it could be called more than once for the same number.
;;;			Added 2PUTIT to 2PATCH and 2PUTCH for DOVER hacking
;;;			Changed FNTEXP to hold KSTID for new CMU style fonts.
;;;			Made /F[...] work at CMU.
;;; 11 Dec 79	"	Made 1LOOP look at NORENUM in addition to FSLRNM.
;;; 12 Dec 79	"	Changed default PAGEL and LINEL for Dover to conform
;;;			to 1cm margins instead of 1/2".
;;; 3 JAN  80	RMS	PRESS file output.
;;;			LNLDOT and PGLDOT are now per-device tables.
;;;			QU.GLD is flushed.  QUEUE now says either yes or no.
;;;			DEVGLP is flushed -- only one device code is needed for the Gould.
;;;			TEXGPP is set for /L[TEXT]/X mode.
;;;			/X now means "treat as graphics device, and default to XGP".
;;;			It takes no other args.  Queueing is turned off by /-D.
;;;			Totally rearranged pass 2.
;;;			Output page formatting and syntactic processing
;;;			are now coroutines.
;;; 17 JAN 80	RMS	Month and day names abbreviated to fit in field on dover.
;;;			2PUTIT flushed.  2TAB exists for outputting a tab in tables.
;;;			SWPRIN now doesn't output some switches when they are
;;;			on by default.
;;; 19 Jan 80	RHG	Got rid of duplicate definition of PTQDAT under BOTS.
;;;			Defined .BAI, .BAO, .BII, .BIO appropriately for BOTS.
;;;			Added PRESS, NOPRESS, XGPRES, NOXGPRES macroes.
;;;			Got rid of some undefined symbols in NOPRESS mode.
;;;			Made all calls on 2INOPN and 2OUTOP use .Bxx to specify mode.
;;;	"	"	Turned on PRESS mode at CMU
;;; 20 Jan 80	"	Replaced .OUTPT with OUTWDS and merged in some fixes from RMS.
;;; 21 Jan 80	"	Merged calls on 2OUTFNT and PRSINI into a single dispatch table.
;;;			Started getting rid of assembly-time testing of
;;;			DEVIXGP vs DEVCXGP in favor of run-time tests.
;;;			XGPP is used to do this magic.
;;;			Fixed a bug in SLLF3 -- it wasn't incrementing CC.
;;;			Made things call SPCOUT and other small optimizations.
;;; 22 Jan 80	RMS	Allowed spaces at places in press font names.
;;;			Width always obtained from FONTS WIDTHS even if font is defaulted.
;;;			Made SYN in Macro and Fail take args in right order (old, new).
;;;			Made "sym ;" in Fail cref properly.
;;;			Made /M[...] switch actually do something.
;;; 22 Jan 80	RHG	Changed FWIDTH to use 16-bit bytes.
;;;			Allowed spaces in more places in DOVER font names.
;;;			Moved FWIDFL to impure so FLOSE can fix it on error.
;;;			Got rid of setting NFNTS=2 at CMU -- that is handled in FNTSWT now.
;;;			Delayed calling SYMINI until after FNTCPT so that
;;;			FWIDTH (which is called by FNTCPT) can still grow LRCPTR.
;;;	"	"	Fixed /M[...] again -- the IBP had no argument!
;;;	"	"	Changed PRESSP to be >0 for LANDSCAPE and TWOUP.
;;;			Although now probably not necessary, added code to obey NFNTS.
;;;	"	"	Changed FWIDTH to check the ROTATION.
;;; 23 Jan 80	"	Changed BEGUND to work even if PRESSX is zero.
;;;			Changed PRESS COVER SHEET to give out-file name, not in-file
;;;			Got rid of some bogus I's (as in IDIVI and MOVEI) which
;;;			were screwing up margins and tabs slightly.
;;;			Changed all default margins to 1/2".   If any of
;;;			the funny old values were fudged due to screwed up
;;;			devices, then that fudging really belongs in the
;;;			device-dependent output code, not the margin values.
;;;	"	"	Changed FWIDTH to not add the baseline to the HEIGHT.
;;;			It is already included!  Changed VSP interpretation
;;;			for PRESS files to compensate, roughly, for
;;;			different dot size from XGP:  kludge = multiply by 13!
;;;			Changed default margins at CMU to get /120w in SAIL 8.
;;;			Changed default PRESS font to SAIL 8 at CMU.
;;;			Made BOTS 2OUTOP remember the PPN of the output file.
;;;			Added CRLOU0 calls to keep PRSTA2 from getting confused.
;;;			Switched PRSTAB to using fancy tabbing.
;;;			Upped ENTCNT to allow for more ENTITY commands that produces.
;;;			Changed FNTCPT to work for DOVER font names less than 13 characters long.
;;; 24 Jan 80	RMS	Made /D[Dover] not queue for XGP printing.
;;;			Flushed default linel and pagel for Dover - always computed afresh.
;;;			Flushed RANDF.  Flushed /?.  Made /: make a file auxiliary.
;;; 24 Jan 80	RHG	Changed DFLMAR to 1 inch to allow for hole punching.
;;;			Deleted DOVER TWOUP -- no reasonable way to pair
;;;			the pages when running in comparison mode.
;;;			Reassigned DEVLDO since no one should have used it yet anyway.
;;;			Added code for DEVLDO.
;;;			Changed PRSPIN to account for FNTBAS when initializing PRESSY.
;;;			Rechanged FNTCPT check of font names.
;;;			Made SYMINI truncate LRCLEN if too long, except on ITS
;;;			Added ENTDLN and DIRDLN.
;;;			Made DLRPS print decimal too.
;;;			where I am not sure exactly what to do.
;;; 25 Jan 80	"	Made PRSDIR use F.RDEV on cover sheet if appropriate.
;;;			Changed date printing format to not use abbreviations.
;;;			Got rid of the CMU tiny margin hack for /120W
;;;			Added SP000X, equivalent to SPCOUT and then 000X.
;;;			Similarly SL000X, except it prints a "/".
;;;			Similarly CM000X, except it prints a ",".
;;;			Similarly CH000X, except it prints an arbitrary character.
;;;			Changed PRESS cover sheets to not include seconds under BOTS.
;;;			Made 2LOOP work right when /> is on.
;;;			Made FNTCPT recompute PAGEL and LINEL if DEVICE changes
;;; 26 Jan 80	RHG	Made SAILA 8 the default at CMU instead of SAIL 8.
;;;			SAILA 8 has ASCII placement of characters.
;;;			Changed PMSTIM to update CC even if not printing seconds.
;;; 28 Jan 80	"	Yet another change to 2LOOP to get /1> to work.
;;; 28 JAN 80	RMS	Changing devices sets linel and pagel overriding lrec file.
;;;			Flushed nonworking hack to make Dover cover sheets use GACHA12.
;;;			Fixed FNTCPT to check SNM and FN1 of font files for nonzero.
;;;			Cover sheet can't use input file name if there isn't one (@CREF files).
;;;			Reabbreviated day and month names for ITS version.
;;; 31 Jan 80	RMS	Fixed premature truncation of qpyrt msg.
;;;  6 Feb 80	MT	Fixed up Press file support for DEC version
;;;			Fixed bug in FILOUT where CC wasn't getting incremented
;;; 10 Feb 80	RMS	Made ;;;;, if next char is not ;, start a subtitle in Lisp mode.
;;;			Made subtitles ended by a ^L not cause lossage.
;;;			Made a single ^L just before EOF not count as a blank page.
;;;			Output the bottom margin for ITS XGP files.
;;; 5 Mar 80	RMS	Made very narrow Dover fonts win (more than 256 printing chars
;;;			in a row may be output)
;;;			Put in a warning for use of a variable width Dover font,
;;;			but patched it out because LPT8 is variable width!
;;; 10 Mar 80	RMS	Fixed excess push when scanning a non-listed file on p2 for cref data.
;;; 26 Mar 80	RMS	Fixed PDL screwup at SLBS for press files.
;;; 29 May 80	RHG	Changed FWIDTH to only use a scaleable font
;;;			entry if there is no exact match for size.
;;;			Changed /M[...] to have a fifth margin -- the
;;;			"hole" margin as in the CMU PDP-10 "DOVER" program.
;;;			It is added to either the LEFT or TOP margin
;;;			as appropriate.
;;;			Added DFMARG and made it 1cm (instead of 0.5") at CMU.
;;;			Fixed DLRDUN to properly update C after finding D non-zero.
;;;			Made PRESS files always have FN2 PRESS (not PRT).
;;;			Deleted some unreferenced labels.
;;; 13-Jul-80   JMN	Added device ANADEX
;;;			Also, modified conditionals so that TNXFLG and
;;;			CMUFLG are now independent variables, not
;;;			mutually exclusive variables.  Producing a version
;;;			which will run, except for a small number of
;;;			JSYS calls, under the compatibility package.
;;;			BOTS/NOBOTS are now conditioned on TNXFLG, if
;;;			TNXFLG is 0, BOTS can be true, if TNXFLG is 1,
;;;			BOTS is false (NOBOTS true)
;;;			Note that NOBOTS is *NOT* equivalent to ITS
;;; 13 Jul 80	RHG	Fixed 1SUBT0 to skip spaces, not everything else.
;;;			Also fixed 1RSUBT to not double the first character of the line.
;;; 13 Jul 80   RHG/JMN Switching to device LPT or ANADEX from a raster
;;;			device now sets the correct margin values base
;;;			on the default values
;;; 13-Jul-80	JMN	Never output tabs to a device which does not
;;;			support them (routine 2TAB/2TAB2)
;;; 14-Jul-80	JMN	Device ANADEX now outputs XON code for
;;;			each page
;;; 19-Jul-80	JMN	EXTENSIVE rehacking of all BOTS/NOITS conditionals
;;;			It looked like NOITS=BOTS, and NOBOTS=ITS.  This is
;;;			NO LONGER TRUE!!!
;;;			CMU20/NOCMU20 conditionals represent another point
;;;			in the set of conditionals.  With a little hacking,
;;;			CMU20 might turn into the TNX/NOTNX conditional
;;;			Current status is that CMU20 compiles semi-JSYS code
;;;			and will accept and print out tops-20 directory names.
;;;			-NO- changes in the format of LRC files has been made
;;;			to accomodate longer names; current 6/3 format is
;;;			retained.  Some enJSYSing of the code, but mostly this
;;;			runs using PA1050 to fake it.  It looks like it would
;;;			be easy to do, but I haven't time for at least a month.
;;;			Until this code is certified for ITS, ITS users should
;;;			probably consider the reorganization of the conditionals
;;;			as representing undebugged code.
;;; 7 Aug 80	RMS	Renamed old DOS conditional to BOTS,
;;;			created another named DOS which includes CMU20FLG
;;;			whereas BOTS excludes it.  Merged duplicate
;;;			BOTS and CMU20FLG conditionals into single DOS ones.
;;; 7 Aug 80	RMS	Fixed bug in 1MIDAS processing '"' at end of line.
;;; 23 Oct 80	MRC	Fixed SAIFLG, added T20FLG, renamed DECFLG to T10FLG.
;;;			Fixed lots of bugs in the TOPS-20 code while I was
;;;			at it!
;;; 12 Feb 81	RMS	Made PRSCHS preserve CH.
;;; 19 Feb 81	RMS	Fixed bug finding subtitles when files are printed in sorted order.

SUBTTL	SYSTEM-DEPENDENT DEFINITIONS

;;; ***** DETERMINE WHERE WE ARE *****

IFNDEF SITE,[
 IFE .OSMIDAS-SIXBIT/ITS/,	SITE==:ITSFLG
 IFE .OSMIDAS-SIXBIT/DEC/,	SITE==:T10FLG
 IFE .OSMIDAS-SIXBIT/CMU/,	SITE==:CMU10FLG
 IFE .OSMIDAS-SIXBIT/SAIL/,	SITE==:SAIFLG
 IFE .OSMIDAS-SIXBIT/TENEX/,	SITE==:T10FLG
 IFE .OSMIDAS-SIXBIT/TWENEX/,	SITE==:T20FLG
];IFNDEF SITE

IFNDEF SITE,[
	PRINTX /Site = ITS, SAI, CMU10, CMU20, T10, T20, or TNX? /
	.TTYMAC X
	SITE==:X!FLG
	TERMIN
];IFNDEF SITE
IFNDEF SITE, .FATAL SITE NOT SPECIFIED.

IFNDEF SITNAM,[
 IFE SITE-ITSFLG,SITNAM==:SIXBIT/ITS/
 IFE SITE-CMU10FLG,SITNAM==:SIXBIT/CMU/
 IFE SITE-CMU20FLG,SITNAM==:SIXBIT/CMU/
 IFE SITE-SAIFLG,SITNAM==:SIXBIT/SAIL/
 IFE SITE-T10FLG,SITNAM==:SIXBIT/TOPS10/
 IFE SITE-TNXFLG,SITNAM==:SIXBIT/TENEX/
 IFE SITE-T20FLG,SITNAM==:SIXBIT/TOPS20/
];IFNDEF SITNAM

IFNDEF LISPSW,LISPSW==SITE#T10FLG	;>0 => HANDLE LISP AND UCONS CODE.
IFNDEF MUDLSW,MUDLSW==SITE&ITSFLG	;>0 => HANDLE MUDDLE CODE.

IRPS X,,ITS:CMU10:CMU20:SAI:T10:TNX:,Y,,NOITS:NOCMU10:NOCMU20:NOSAI:NOT10:NOTNX:
	DEFINE Y
IFN SITE-X!FLG!TERMIN
	DEFINE X
IFE SITE-X!FLG!TERMIN
TERMIN
	DEFINE T20
IFN <CMU20FLG+T20FLG>&SITE!TERMIN
	DEFINE NOT20
IFE <CMU20FLG+T20FLG>&SITE!TERMIN

	DEFINE CMU
IFN <CMU10FLG+CMU20FLG>&SITE!TERMIN

	DEFINE NOCMU
IFE <CMU10FLG+CMU20FLG>&SITE!TERMIN

	DEFINE BOTS			;TOPS-10 LIKE OPERATING SYSTEM
IFN <T10FLG+SAIFLG+CMU10FLG>&SITE!TERMIN
	DEFINE NOBOTS
IFE <T10FLG+SAIFLG+CMU10FLG>&SITE!TERMIN

	DEFINE DOS
IFN <T10FLG+T20FLG+SAIFLG+CMU10FLG+CMU20FLG>&SITE!TERMIN
	DEFINE NODOS
IFE <T10FLG+T20FLG+SAIFLG+CMU10FLG+CMU20FLG>&SITE!TERMIN


BOTS,[	IFNDEF OUTSTR,[
		SAI,.INSRT SYS:SAIDFS
		CMU,.INSRT SYS:CMUDFS
		T10,.INSRT SYS:DECDFS
		.DECDF
	];IFNDEF OPEN
];BOTS
ITS,[	IFNDEF .OPEN,[.INSRT SYS:ITSDFS
		   .ITSDF
	];IFNDEF .OPEN
];ITS
TNX,[	IFNDEF GTJFN,[.INSRT SYS:TNXDFS
		   .TNXDF
	];IFNDEF GTJFN
];TNX
T20,[
	.INSRT DECDFS		;TOPS-10 UUO'S FOR PA1050 (SIGH)
	.DECDF
	IFNDEF GTJFN,[.INSRT SYS:TNXDFS
		   .TNXDF
	];IFNDEF GTJFN
];T20
CMU20,[
	.INSRT CMUDFS			; TOPS-10 names for compat. pkg.
	.DECDF
	.INSRT TNXDFS
	.TNXDF
	STPPN=: 104000,,556
	PPNST=: 104000,,557
]; CMU20

TNX,[	PRINTX/If you think you are going to get a working @ on Tenex by
using TNXFLG are you ever going to lose.
/
	.ERR SITE=TNXFLG doesn't work yet 
];TNX

IFNDEF XGPFMT,[			;WHAT SORT OF XGP COMMANDS DO WE WANT TO OUTPUT?
	CMU,XGPFMT==:CMU10FLG	;CMU HAS ONE FORMAT.
	IFE SITE-SAIFLG,XGPFMT==:ITSFLG	;ITS AND SAIL HAVE ONE.
	IFE SITE-ITSFLG,XGPFMT==:ITSFLG
	IFNDEF XGPFMT,	XGPFMT==:0	;/X AND /F NOT ALLOWED IF 0.
];IFNDEF XGPFMT
IFNDEF ANAFLG,[		; Support Anadex 9500/9501?
	CMU,ANAFLG==:1	; yes, at CMU
	IFNDEF ANAFLG,	ANAFLG==:0
];IFNDEF ANAFLG

IFNDEF PRSFLG,PRSFLG==:SITE&<ITSFLG\SAIFLG\CMU10FLG\CMU20FLG\T20FLG>;NONZERO TO ALLOW PRESS FILE OUTPUT.

IRPS X,,ITS,Y,,ITSXGP:,Z,,NOITSXGP:
	DEFINE Y
IFE XGPFMT-X!FLG!TERMIN
	DEFINE Z
IFN XGPFMT-X!FLG!TERMIN
TERMIN
	DEFINE CMUXGP
IFN XGPFMT&<CMU10FLG+CMU20FLG>!TERMIN
	DEFINE NOCMUXGP
IFE XGPFMT&<CMU10FLG+CMU20FLG>!TERMIN

	DEFINE XGP
IFN XGPFMT!TERMIN
	DEFINE NOXGP
IFE XGPFMT!TERMIN

	DEFINE PRESS
IFN PRSFLG!TERMIN
	DEFINE NOPRESS
IFE PRSFLG!TERMIN

	DEFINE ANADEX
IFN ANAFLG!TERMIN

	DEFINE NOANADEX
IFE ANAFLG!TERMIN

	DEFINE XGPRES
IFN PRSFLG\XGPFMT!TERMIN
	DEFINE NOXGPRES
IFE PRSFLG\XGPFMT!TERMIN

XGP,[IFNDEF FNTDSN,[		;WHAT IS DEFAULT DIRECTORY FOR FONT FILES?
	IFE SITE-ITSFLG,FNTDSN=:SIXBIT/FONTS/
	IFE SITE-CMU10FLG,FNTDSN=:1343,,303360	;A730KS00
	IFE SITE-CMU20FLG,[
	    FNTDSN==:0
	];IFE SITE-CMU20FLG
	IFE SITE-SAIFLG,FNTDSN=:SIXBIT/XGPSYS/
	IFE SITE-T10FLG,[
	  PRINTX /Default PPN for font files = /
	  .TTYMAC X
	    FNTDSN==:X
	  TERMIN
	];IFE SITE-T10FLG
	IFE SITE-TNXFLG,[
	  PRINTX /Default directory number for font files = /
	  .TTYMAC X
	    FNTDSN==:X
	  TERMIN
	];IFE SITE-TNXFLG
	IFE SITE-T20FLG,[
	  PRINTX /Default directory number for font files = /
	  .TTYMAC X
	    FNTDSN==:X
	  TERMIN
	];IFE SITE-T20FLG
];IFNDEF FNTDSN
];XGP

IFNDEF FNTDSN,	FNTDSN==:0

;;; ***** I/O CHANNELS *****

ERRC==:0			;ERROR MESSAGES
UTIC==:1			;FILE INPUT
UTOC==:2			;LISTING OUTPUT
INSC==:3			;INSERT CHANNEL (FOR VERIFYING EXISTENCE)
DOS,	RNMC==:4		;CHANNEL FOR RENAMING
DOS,	DELC==:5		;CHANNEL FOR DELETING
ITS,	TYIC==:4		;TTY INPUT
ITS,	TYOC==:5		;TTY OUTPUT

;;; ***** UUO DEFINITIONS *****

NODOS,	STRT=:1000,,		;ASCIZ STRING TYPEOUT
DOS,	STRT=:OUTSTR		;BOTS ALREADY HAS A MONITOR UUO TO DO THIS, SO USE IT
6TYP=:2000,,			;SINGLE SIXBIT WORD TYPEOUT
FLOSE=:3000,,			;I/O LOSSAGE MSG, FROM SYSTEM CALL FAILURE-RETURN.
FLOSEI=:4000,,			;I/O LOSSAGE MESSAGE - INTERNALLY DETECTED ERROR.
TYPNUM=:5000,,			;NUMERIC TYPEOUT, AC = RADIX
UUOMAX==:5

;;; ***** MIDAS CONTROL SWITCHES *****

ITS,		TWOSEG==:0	;RIDICULOUS ON A RANDOMLY PAGED SYSTEM
TNX,		TWOSEG==:0	;YOU CAN SAY THAT AGAIN
T20,		TWOSEG==:0
SAI,		TWOSEG==:0	;TWOSEG LESS EFFICIENT AT SAIL.
IFNDEF TWOSEG,	TWOSEG==:1

;;; ***** OP CODES, ETC. *****

DEFINE DROPTHRUTO X
IF2, IFN .-X, .ERR THIS DROPTHRUTO SHOULD BE A JRST
TERMIN

ITS,[	TYO=:.IOT TYOC,
	TYI=:.IOT TYIC,
DEFINE OUTWDS REG<ADDRWD,COUNT
	HRRO REG,ADDRWD
	TLC REG,<-1>+COUNT
	.IOT UTOC,REG
TERMIN
DEFINE SYSCAL NAME,ARGS
	.CALL [SETZ ? SIXBIT /NAME/ ? ARGS ((SETZ))]
TERMIN
];ITS

TNX,[
IF1, EXPUNGE .VALUE,.CLOSE,.DISMISS
	TYO=:PBOUT
	TYI=:PBIN
IF2,	.VALUE=:JSYS [LOSE,,LOSE0]
DEFINE OUTWDS REG<ADDRWD,COUNT
	IRPS X,,[A B C]
	    IFN REG-X,	PUSH P,X
	TERMIN
	MOVNI C,COUNT
	HRRZ B,ADDRWD
	HRLI B,444400
	MOVE A,JUTIC
	SOUT
	IRPS X,,[C B A]
	    IFN REG-X,	POP P,X
	TERMIN
TERMIN
];TNX
DOS,[	TYO=:OUTCHR
	TYI=:INCHWL
IF1, EXPUNGE .VALUE,.CLOSE,.DISMISS,.BAI,.BAO,.BII,.BIO	;IN CASE WE ARE ASSEMBLING ON ITS
IF2,	.VALUE==:JSR LOSE		;IF2 BECAUSE LOSE ISN'T DEFINED YET IN PASS 1
	.CLOSE==:RELEASE		;CLOSE ENOUGH APPROXIMATION
	.DISMISS==:JRST 2,@0		;AGAIN, A CLOSE APPROXIMATION (FOR RETURNING FROM PDL OVERFLOWS)
	.BAI==:0			;ASCII INPUT MODE
	.BAO==:0			;ASCII OUTPUT MODE
	.BII==:14			;IMAGE INPUT MODE
	.BIO==:14			;IMAGE OUTPUT MODE

DEFINE OUTWDS REG<ADDRWD,COUNT\OLOOP	;THIS MIGHT WANT TO BE A SUBROUTINE
IFE N-REG, .ERR REGISTER N ILLEGAL AS AN ARG TO OUTWDS
	PUSH P,N
	MOVEI N,COUNT
	SKIPA REG,ADDRWD
OLOOP:	 POP P,N
	SUB N,OUTHED+2
	JUMPG N,[PUSH P,N
		SKIPGE N,OUTHED+1
		 .VALUE			;DON'T HANDLE BYTE POINTERS WITH P=36.
		ADD N,OUTHED+2
		EXCH N,OUTHED+1
		HRLI N,(REG)
		HRRI N,1(N)
		BLT N,@OUTHED+1
		ADD REG,OUTHED+2
		SETZM OUTHED+2
		OUT UTOC,
		 JRST OLOOP		;Loop if successful
		GETSTS UTOC,N
		.VALUE
		TRZ N,740000
		SETSTS UTOC,(N)
		JRST OLOOP ]
	MOVN N,N
	EXCH N,OUTHED+2
	SUB N,OUTHED+2
	SKIPGE OUTHED+1
	 .VALUE				;DON'T HANDLE BYTE POINTERS WITH P=36.
	ADD N,OUTHED+1
	EXCH N,OUTHED+1
	HRLI N,(REG)
	HRRI N,1(N)
	BLT N,@OUTHED+1
	POP P,N
IF2,	EXPUNGE OLOOP
TERMIN
];DOS

SUBTTL	DEFAULT ASSEMBLY PARAMETERS

IFNDEF VSPNRM,VSPNRM==:4	;DEFAULT VSP
CMU10,IFNDEF PGNSPC,PGNSPC==:.LENGTH \DEVx:FILNAM.EXT[X999XX99]  PAGE MAJ/MIN.CNT\
T20,IFNDEF PGNSPC,PGNSPC==:.LENGTH \PS:FILNAM.EXT[LONGNAME.SUBDIRECTORY]  PAGE MAJ/MIN.CNT\
TNX,IFNDEF PGNSPC,PGNSPC==:7+40.+40.+12.+.LENGTH\PAGE MAJ/MIN.CNT\
IFNDEF PGNSPC,PGNSPC==:.LENGTH \DIRNAM;FILNAM FILNM2  PAGE MAJ/MIN.CNT\
T10,IFNDEF NFILES,NFILES==:32.	;DON'T WASTE TOO MUCH SPACE ON FILES
CMU,IFNDEF NFILES,NFILES==:200.	;BUT CMU OFTEN WANTS MORE
T20,IFNDEF NFILES,NFILES==:200.	;SO DOES T20
IFNDEF NFILES,NFILES==:64.	;MAX # FILES ALLOWED
DOS,XGP,IFNDEF LINBFR,LINBFR==:400	;MUST HAVE ROOM FOR ENOUGH OF FNT FILES.
DOS,IFNDEF LINBFR,LINBFR==:200	;NO POINT IN TRYING TO READ TOO MUCH AT A TIME
IFNDEF LINBFR,LINBFR==:1000	;LENGTH OF INPUT BUFFER
IFNDEF LSLBUF,LSLBUF==:1000	;LENGTH OF OUTPUT BUFFER
CMU,IFNDEF LSYLBUF,LSYLBUF==:400.;CMU SOMETIMES NEEDS LONG JCL
T20,IFNDEF LSYLBUF,LSYLBUF==:400.;SO DOES T20
IFNDEF LSYLBUF,LSYLBUF==:100	;LENGTH OF SYLLABLE/JCL BUFFER
IFNDEF NFNTS,NFNTS==:3		;# FONTS ALLOWED.
IFNDEF MINPGL,MINPGL==:45.	;SMALLEST ALLOWED PAGEL.
IFNDEF MINLNL,MINLNL==:50.	;SMALLEST ALLOWED LINEL.
IFNDEF MAXVSP,MAXVSP==:20.	;LARGEST VSP THAT CAN BE SPEC'D WITH A POSITIVE ARG TO /V.
BOTS,IFNDEF FNAMCW,FNAMCW==29.	;BOTS OFTEN PRINTS DEVx:
IFNDEF FNAMCW,FNAMCW==24.	;THIS IS THE COLUMN WIDTH WHEN LISTING FILES IN TITLES

IFN SITE&<ITSFLG\TNXFLG>,[	;THESE WILL BE ROUNDED UP TO MULTIPLES OF 1K IN PDLIN1.
IFNDEF PDLDLN,PDLDLN==:400	;SIZE OF PDL SPACE
IFNDEF LRCILN,LRCILN==:2000	;INITIAL SIZE OF LRC AREA (IT CAN GROW, AT FIRST)
IFNDEF LRCDLN,LRCDLN==:40.*2000	;DEFAULT SIZE OF INPUT LREC INFO SPACE (40K)
IFNDEF SYMDLN,SYMDLN==:40.*2000	;DEFAULT SIZE OF SYMTAB SPACE (40K)
IFNDEF DATILN,DATILN==:2000	;INITIAL SIZE OF DATA AREA (IT CAN GROW)
IF2 IFG .JBFF1+PDLDLN+LRCDLN+SYMDLN+DATILN-776000, .ERR DEFAULT SPACE ALLOCATIONS TOO BIG
];ITS OR TNX

DOS,[
IFNDEF PDLDLN,PDLDLN==:200	;SIZE OF PDL
IFNDEF LRCILN,LRCILN==:1	;INITIAL SIZE OF LRC AREA (IT CAN GROW, AT FIRST)
T10,IFNDEF LRCDLN,LRCDLN==:2000	;I GUESS DEC IS TIGHT FOR CORE  --RHG
IFNDEF LRCDLN,LRCDLN==:10000	;DEFAULT SIZE OF INPUT LREC INFO SPACE.
IFNDEF SYMDLN,SYMDLN==:20000	;DEFAULT SIZE OF SYMTAB SPACE.
IFNDEF DATILN,DATILN==:1	;INITIAL SIZE OF DATA AREA (IT CAN GROW)
];DOS

IFNDEF ENTDLN,ENTDLN==:10000	;DEFAULT ENTBUF SIZE IN 8-BIT BYTES
IFNDEF DIRDLN,DIRDLN==:2000	;DEFAULT DIRBUF SIZE IN 18-BIT BYTES

CMU,IFNDEF DFMARG,DFMARG==:394.	;AT CMU, USE 1CM MARGINS
IFNDEF DFMARG,DFMARG==:500.	;DEFAULT MARGIN (IN MILS)
IFNDEF DFLMAR,DFLMAR==:DFMARG	;LEFT MARGIN
IFNDEF DFRMAR,DFRMAR==:DFMARG	;RIGHT MARGIN
IFNDEF DFTMAR,DFTMAR==:DFMARG	;OUTPUT TOP MARGIN
IFNDEF DFBMAR,DFBMAR==:DFMARG	;BOTTOM MARGIN
IFNDEF DFHMAR,DFHMAR==:DFMARG	;HOLE MARGIN -- NORMALLY ADDED TO DFLMAR

IF2 [				;PASS 2, SINCE CODTYP VALUES NOT DEFINED YET IN PASS 1
ITS,IFNDEF DFLANG,DFLANG==:CODMID
CMU,IFNDEF DFLANG,DFLANG==:CODRND
SAI,IFNDEF DFLANG,DFLANG==:CODFAI
TNX,IFNDEF DFLANG,DFLANG==:CODMID
T20,IFNDEF DFLANG,DFLANG==:CODMID
IFNDEF DFLANG,DFLANG==:CODMID	;DEFAULT LANGUAGE
];IF2

SAI,IFNDEF QUEBFL,QUEBFL==100	;LENGTH OF BUFFER FOR XSPOOL COMMAND.

SUBTTL	FLAG DEFINITIONS

;;; FLAGS IN LH OF ACCUMULATOR F
FL==:1,,525252		;BIT TYPEOUT MASK

FLREFS==:400000		;REFERENCE STUFF
FLSHRT==:100000		;SHORT MULTI-FILE NAMES
FLINSRT==:40000		;LIST ALL INSERTED FILES
FLXGP==:20000		;XGP HACKERY
FLCREF==:10000		;CREF FOR ALL FILES WANTED
FLBS==:4000		;CTRL/H REALLY GOES OUT AS CTRL/H
FLSCR==:2000		;STRAY CR'S REALLY OVERSTRIKE
			; (ALSO CONTROLS STRAY LINEFEEDS)
FLCTL==:1000		;CTRL CHARS GO OUT AS THEMSELVES
FLARB==:400		;ARBITRARILY LONG SYMBOLS
FLFNT2==:200		;TEXT IS DIFFERENT FONT FROM CRUFT
FLFNT3==:100		;COMMENTS ARE DIFFERENT FONT FROM TEXT
FL2REF==:40		;TWO REFS PER LINE (PDP-11 CODE)
FLASCI==:20		;SYMBOLS ARE IN ASCII (ELSE SIXBIT)
			; (NOBODY USES THIS PRESENTLY)
FLDATE==:10		;WANT DATE IN HEADINGS
FLNOLN==:4		;NO STUFF AT ALL ON LEFT
FLQPYM==:2		;COPYRIGHT MESSAGE
FLSUBT==:1		;SUBTITLES TABLE OF CONTENTS

;;; FLAGS IN RH OF F.SWIT OF EACH FILE-BLOCK.
;;; SOME (THOSE IN TEMPF) ARE KEPT IN F FOR FILE BEING PROCESSED.
;;; NOTE THAT DURING SWITCH PROCESSING MOST OF THESE LIVE IN F,
;;; AND MOST OF THE FR FLAGS AREN'T IN USE YET.  EXCEPTION IS FR1SW.
FS==:525252		;BIT TYPEOUT MASK

FSNCHG==:4000		;SET IF FILE IS DISCOVERED TO BE UNCHANGED SINCE PREVIOUS
			;LISTING WAS MADE. VALUE CALCULATED BY CPRU.
			;UNCHANGED FILE ARE NOT LISTED.
FSLRNM==:2000		;DON'T CAUSE ANY PAGE TO HAVE A SLASHIFIED PAGE NUMBER,
			;EVEN IF THAT REQUIRES RELISTING LOTS OF PAGES (/1J).
FSLALL==:1000		;RELIST ALL OF THIS FILE (/-J).
FSGET==:400		;THIS IS AN LREC FILE, AND .INSRT ALL FILES MENTIONED IN IT.
FSNSMT==:200		;NO SYMBOL TABLE PRINTOUT FOR THIS FILE
FSNOIN==:100		;IGNORE FILE EVEN ON PASS 1. USED TO SUPPRESS PASS 1
			;FOR .INSRT'ED FILES THAT AREN'T REALLY RELEVANT.
FSLREC==: 40		;THIS FILE IS A LISTING RECORD FILE
FSQUOT==:20		;THIS FILE WAS SPEC'D WITH A SINGLE-QUOTE.
FSARW==:10		;THIS FILE'S SPEC HAD A "_".
FSMAIN==:4		;THIS FILE IS THE ONE WHOSE FN2 SHOULD BE USED FOR THE LREC FILE.
FSSUBT==:2		;THIS FILE HAS AT LEAST ONE SUBTITLE SPECIFIED, SO RESERVE
			;THE FIRST LINE OF EACH PHYSICAL PAGE FOR A SUBTITLE.
 .SEE FR1SW
FSAUX==:1		;THIS FILE CONTAINS A ".AUXIL", SO IT IS AN AUXILIARY FILE.
			;SYMBOLS THAT APPEAR ONLY AUXILIARY FILES WHICH ARE NOT
			;BEING LISTED ARE NOT MENTIONED IN CREFS.
TEMPF==:FSLREC+FSARW+FSQUOT+FSNOIN+FSNCHG
;THESE FLAGS ARE MOVED FROM F.SWIT INTO AC F FOR EACH FILE DURING PASS1 AND PASS2.

;;; FLAGS IN RH OF ACCUMULATOR F
FR==:525252		;BIT TYPEOUT MASK

FRSYL1==:400000		;FIRST SYLLABLE OF LINE ALREADY SEEN
FRVSL1==:200000		;VIRTUAL FIRST SYLLABLE SEEN
FRIF==:100000		;SOME KIND OF IF SEEN
FRLET==:40000		;LETTER SEEN (OR . OR $ OR %)
FRSQZ==:20000		;SQUOZE CHAR SEEN
FRNCHG==:FSNCHG		;THIS FLAG SET IN F FROM F.SWIT OF CURRENT FILE.
FRNOIN==:FSNOIN		;THESE 4 FLAGS SET IN F FROM F.SWIT OF CURRENT FILE.
FRLREC==:FSLREC ? FRQUOT==:FSQUOT ? FRARW==:FSARW
FR1SW==:2		;SET BY "/", CLEARED BY "(" - CAUSES RETURN TO FILENAME
			;READER AFTER PROCESSING ONE SWITCH.
FRAUX==:FSAUX
;USED ONLY IN PASS 2
FRFNT3==:4		;BUSY OUTPUTTING IN FONT 3
FRLCR==:2		;LAST CHAR WAS CR (FOR SLURP)
FRLTAB==:1		;LAST CHAR WAS TAB, SPACE, LF, FF
;USED ONLY IN MOBY.
FRPSHRT==:2		;IN MOBY, INDICATES PAGE IS SHORT, SO SHRINK LETTERS VERTICALLY
FRLSHRT==:1		;IN MOBY, INDICATES LINES ARE SHORT, SO SHRINK LETTERS HORIZONTALLY.

SUBTTL	FORMAT OF SYMBOL TABLE

;;; THE SYMBOL TABLE GROWS UPWARD, INITIALLY FROM LOCATION SYMBOT.
;;; THE CURRENT LOW ADDRESS OF THE SYMBOL TABLE IS IN SYMLO.
;;; DURING PASS 1, SP CONTAINS A PDL POINTER TO THE SYMBOL TABLE
;;; WHICH IS USED TO PUSH NEW ENTRIES. AT THE END OF PASS 1,
;;; THE HIGHEST ADDRESS USED +1 IS DEPOSITED IN LOCATION SYMHI.
;;; THE SYMBOL TABLE IS THEN SORTED (SEE SORT), SO THAT PASS 2
;;; MAY USE A BINARY SEARCH LOOKUP TECHNIQUE.
;;; EACH ENTRY IN THE SYMBOL TABLE IS FOUR WORDS LONG. (THE
;;; ROUTINES SORT, LOOK, AND NLOOK DEPEND ON THIS FACT!)
;;; THE FORMAT OF EACH ENTRY IS AS FOLLOWS:

S.==:,-1		;MASK FOR BIT TYPEOUT MODE.
C.==:,-1

S.NAME==:0		;NAME OF SYMBOL. IF SINGLE WORD SYMBOLS ARE
			; BEING USED (THE FLAG FLARB IS OFF), THEN THIS
			; WORD CONTAINS THE SINGLE WORD OF THE NAME.
			; OTHERWISE IT CONTAINS AN AOBJN POINTER TO THE
			; NAME, WHICH IS IN CONSECUTIVE WORDS IN THE
			; DATA AREA.
S.FILE==:1		;THE LEFT HALF CONTAINS A POINTER TO THE FILE
			; BLOCK (SEE FILES) FOR THE FILE IN WHICH THE
			; DEFINITION WAS FOUND.
S.TYPE==:1		;THE RIGHT HALF CONTAINS THE ADDRESS OF DATA
			; DESCRIBING THE TYPE OF SYMBOL DEFINITION
  .SEE ATYPE		; (E.G. MACRO, ==, .GLOBAL).  TYPES ARE DEFINED BY ATYPE.
S.PAGE==:2		;THE LEFT HALF CONTAINS THE PAGE NUMBER FOR
			; THE DEFINITION.
S.LINE==:2		;THE RIGHT HALF CONTAINS THE LINE NUMBER -1.
S.BITS==:3		;THE LEFT HALF CONTAINS VARIOUS BITS PERTAINING
			; TO THE SYMBOL DEFINED. THESE ARE:
%S==1,,525252
	%SDUPL==:400000	;THIS ENTRY IS PRECEDED BY ONE
			; WITH THE SAME NAME. %SDUPL
			; MUST BE THE SIGN BIT - SEE NLOOK8
	%SXCRF==:200000	;THIS SYMBOL WAS SEEN IN A
			; .XCREF - DO NOT CREF
	%SREFD==:100000	;THIS SYMBOL WAS REFERENCED ON
			; PASS 2 - USED TO PUT *'S IN
			; THE SYMBOL TABLE (NOT FULLY
			; WINNING IF NOT ALL FILES
			; WERE SEEN ON PASS 2)
	%SXSYM==:40000	;DO NOT PRINT THIS SYMBOL IN THE
			; SYMBOL TABLE - IT IS PRESENT FOR
			; CREF PURPOSES ONLY
S.CREF==:3		;THE RIGHT HALF IS A POINTER TO A LINKED CHAIN
			; OF CREF DATA FOR THIS SYMBOL. ONLY THE FIRST
			; ENTRY OF SEVERAL WITH THE SAME NAME WILL HAVE
			; CREF DATA. CREF DATA BLOCKS ARE THREE WORDS
			; LONG, AND ARE EXACTLY LIKE THE LAST THREE
			; WORDS OF A SYMBOL TABLE ENTRY. A POINTER TO A
			; CREF ENTRY POINTS TO THE WORD BEFORE THE
			; THREE-WORD BLOCK. THE S.NAME WORD IN A CREF
			; DATA BLOCK IS NOT MEANINGFUL. THE S.CREF WORD
			; IS USED TO CHAIN CREF DATA INTO A LINKED LIST.
LSENT==:4		;LENGTH OF SYMBOL TABLE ENTRY
C.FILE==:S.FILE
C.TYPE==:S.TYPE
C.PAGE==:S.PAGE
C.LINE==:S.LINE
C.CREF==:S.CREF

SUBTTL	FORMAT OF AN LREC FILE

;THE FIRST WORD OF AN LREC FILE SHOULD NOW BE SIXBIT/LREC/+1.
;ATTEMPTS TO USE FILES WHICH DO NOT SATISFY THAT CRITERION
;CAUSE ERROR MESSAGES.
;THE REST OF FILE IS COMPOSED OF ENTRIES, ONE AFTER THE OTHER.
;EACH ENTRY DESCRIBES HOW ONE FILE WAS TREATED IN THE LISTING
;THAT THE LREC FILE DESCRIBES. THERE IS AN ENTRY FOR ALL FILES EXCEPT
;LREC FILES AND BACKARROW-SINGLEQUOTE FILES.
;AN ENTRY BEGINS WITH 4 WORDS GIVING THE SNAME, DEV, FN1 AND FN2 OF THE FILE.
;THEN COME 0 OR MORE SUBENTRIES, FOLLOWED BY A -1 SIGNIFYING THE END
;OF THE ENTRY.
;A SUBENTRY CONSISTS OF A WORD HOLDING THE SUBENTRY TYPE,
;A WORD WHOSE LH HAS MINUS THE NUMBER OF DATA WORDS IN THE SUBENTRY,
;FOLLOWED BY DATA WORDS WHOSE SIGNIFICANCE DEPENDS ON THE SUBENTRY TYPE.
;THE SUBENTRY TYPES THAT NOW EXIST ARE:

LR.==:,-1	;MASK FOR BIT TYPEOUT MODE.

LR.PAG==:1	;THE DATA WORDS ARE THE PAGE TABLE OF THE FILE.
LR.SYM==:2	;THE DATA WORDS ARE THE SYMBOL TABLE OF THE FILE.
		;THAT IS, THE SYMBOL TABLE OF THE LISTING BUT LIMITED
		;TO SYMBOLS DEFINED IN THIS FILE.  CURRENTLY, THIS SUBENTRY
		;IS IGNORED ON INPUT, AND NEVER WRITTEN.
LR.SWT==:3	;THERE IS 1 DATA WORD, THE F.SWIT VALUE FOR THE FILE.
LR.PSW==:4	;HOLDS INFO ON SETTINGS ON NON-PER-FILE SWITCHES
		;IF ONE ENTRY IN THE FILE HAS AN LR.PSW
		;SUBENTRY, ALL ENTRIES SHOULD HAVE THEM, AND
		;THEY SHOULD ALL HAVE THE SAME CONTENTS.
		;THE SETTINGS RECORDED IN THIS SUBENTRY ARE USED
		;WHEN /G IS SPEC'D AS THE DEFAULTS FOR ALL THE
		;SWITCHES. THERE ARE 12. WORDS OF DATA:
		;WD 1  THE VALUE OF F
		;WD 2  THE VALUE OF LINEL
		;WD 3  THE VALUE OF PAGEL
		;WD 4  THE VALUE OF UNIVCT
		;WD 5  THE VALUE OF CODTYP
		;WD 6  THE VALUE OF TRUNCP
		;WD 7  THE VALUE OF SINGLE
		;WD 8  THE VALUE OF PRLSN
		;WD 9  THE VALUE OF SYMLEN
		;WD 10 THE VALUE OF QUEUE
		;WD 11 BIT-DECODED:  BIT 1.1 = 1 IFF NOTITLE IS NONZERO.
		;		     BIT 1.2 = 1 IFF REALPG IS NONZERO.
		;		     BITS 1.3, 1.4 = VALUE OF NXFDSP (TO BE SIGN-EXTENDED)
		;WD 12 THE VALUE OF SYMTRN
LR.FNT==:5	;HOLDS INFO ON SPEC'D FONTS. PRESENT ONLY IF FONTS HAVE
		;BEEN SPECIFIED. CONTAINS AN IMAGE OF FNTF0 THROUGH FNTFE-1,
		;AS THEY WERE WHEN LREC FILE WAS MADE. THUS, THERE ARE
		;FNTFL WORDS PER FONT, AND NFNTS FONTS. @ WILL NOT COMPLAIN
		;IF HANDED A LONGER LR.FNT BLOCK BUT WILL IGNORE THE EXTRA FONTS.
LR.XGP==:6	;HOLDS PARAMETERS RELEVANT TO FONTS. RIGHT NOW THERE ARE
		;FIVE, THE VSP (FROM FNTVSP) AND THE FOUR MARGINS.
LR.CRF==:7	;CONTAINS INFO ON THE OUTPUT FILE FOR CREF TABLES AND
		;UNIVERSAL SYMBOL TABLES. THERE ARE 5 DATA WORDS, WHICH ARE
		;CRFSNM, CRFDEV, CRFFN1, CRFFN2, CRFOFL
		;THE ABSENCE OF THIS SUBENTRY IS EQUIVALENT TO THE PRESENCE
		;OF ONE WITH CRFOFL CONTAINING 0.
LR.CPY==:10	;THE COPYRIGHT MESSAGE, FROM CPYMSG.
LR.OUT==:11	;4 WORDS:  THE SNAME, DEV, FN1, FN2 DEFAULTS FOR OUTPUT FILES
		;0 => NOT SPECIFIED, SO USE @'S STANDARD DEFAULT EACH TIME.
		;I.E. 0 AS SNAME MEANS USE MSNAME OF USER RUNNING @.
LR.DAT==:12	;CREATION DATE OF THE SOURCE FILE.

SUBTTL	GENERALLY USEFUL MACROS.

DEFINE INSIRP A,B
IRPS X,,B
A,X
TERMIN TERMIN

DEFINE DBP7 X
	ADD X,[070000,,]
	SKIPGE X
	 SUB X,[430000,,1]
TERMIN

DEFINE CONC A,B
A!B!TERMIN

;;; USEFUL NREVERSE MACRO.  QUICKLY REVERSES A LINKED LIST.
;;; FIRST ARG IS AC CONTAINING LIST, NEXT TWO ARE SCRATCH AC'S.
;;; FOURTH IS OFFSET OF CDR POINTER (MUST BE IN RH OF WORD).
;;; FIFTH IS CODE TO EXECUTE ON EACH LOOP, REFERRING TO
;;; AC POINTING AT CURRENT NODE AS X.  REVERSED LIST IS LEFT
;;; IN AC WHERE LIST WAS SUPPLIED.

DEFINE NREVERSE AC1,AC2,AC3,Z,CODE\TAG1,TAG2,TAG3,MAC1
DEFINE MAC1 X
CODE
TERMIN
	JUMPE AC1,TAG3
	SETZ AC2,
TAG1:	HRRZ AC3,Z(AC1)
	HRRM AC2,Z(AC1)
	MAC1 AC1
	JUMPE AC3,TAG3
	HRRZ AC2,Z(AC3)
	HRRM AC1,Z(AC3)
	MAC1 AC3
	JUMPE AC2,TAG2
	HRRZ AC1,Z(AC2)
	HRRM AC3,Z(AC2)
	MAC1 AC2
	JUMPN AC1,TAG1
	SKIPA AC1,AC2
TAG2:	 MOVEI AC1,(AC3)
TAG3:
EXPUNGE MAC1
TERMIN

SUBTTL	UUO AND INTERRUPT HANDLERS

IFN TWOSEG,	.DECTWO
IFE TWOSEG,[
  ITS,		.SBLK ? LOC 100
  NOITS,[
   NOSAI,.DECSAV
   SAI,.DECREL
   T20,LOC 140
  ];NOITS
];IFE TWOSEG
RL0::				;RELOCATABLE 0 -- MUST BE DEFINED BEFORE ANY ASSEMBLED CODE

ZZZ==. ? LOC 41
	JSR UUOH
ITS,	JSR .JBCNI
DOS,	LOC .JBAPR ? TSINT0
LOC ZZZ ? EXPUNGE ZZZ

UUOH:	0			;UUO HANDLER
ITS,[	SKIPE DEBUG
	 .SUSET [.RJPC,,UUOJPC]
];ITS
	JRST UUOH0

ITS,[
IF1 EXPUNGE .JBCNI,.JBTPC	;IN CASE ASSEMBLING ON DEC SYSTEM (BUT FOR USE ON ITS).

TSINT:
.JBCNI::0			;INTERRUPT HANDLER
.JBTPC:	0
	SKIPE DEBUG
	 .SUSET [.RJPC,,INTJPC]
	JRST TSINT0

CORLUZ:	0			;FOR FAILING .CBLK'S
	JRST CORLZ0
];ITS

DOS,[
LOSE:	0			;.VALUE IS REALLY JSR LOSE
NOTNX,	JRST LOSE0
LOSEDD:	0			;RH OF .JBDDT PUT HERE TO JRST @.
];DOS

UUOASV:	0			;UUO HANDLER SAVES A HERE
UUOBSV:	0			;UUO HANDLER SAVES B HERE

INTASV:	0			;INTERRUPT HANDLER SAVES A HERE
INTBSV:	0			;INTERRUPT HANDLER SAVES B HERE
ITS,[
UUOJPC:	0			;JPC AT UUOH, AFTER UUOS THAT GO THRU SYSTEM (ONLY IN DEBUG MODE).
INTJPC:	0			;JPC WHEN INTERRUPT HAPPENED (ONLY IN DEBUG MODE).
IF1 EXPUNGE .JBFF		;IN CASE ASSEMBLING ON DEC SYSTEM (BUT FOR USE ON ITS).
.JBFF:	.JBFF1
];ITS

SUBTTL	VARIABLES PERTAINING TO COMMAND SWITCHES

DEVICE:	DEVLPT	;TYPE OF PRINTING DEVICE FOR WHICH WE ARE PREPARING OUTPUT
DEV==:,-1	;BIT TYPEOUT MASK
DEVLPT==:0	;LINE PRINTER
DEVIXGP==:1	;ITS XGP
DEVCXGP==:2	;CMU XGP
ITSXGP,DEVXGP==:DEVIXGP
CMUXGP,DEVXGP==:DEVCXGP
DEVGLD==:3	;GOULD LPT
DEVLDO==:4	;Xerox Dover printer, landscape orientation
DEVPDO==:5	;Xerox Dover printer, portrait orientation
DEVMAX==:7	;1 + <LARGEST LEGAL DEVICE VALUE>

XGPP:	0	;0 => DEVICE DOESN'T CONTAIN XGP, -1 => DEVIXG, +1 => DEVCXG

CODTYP:	DFLANG	;TYPE OF INPUT EXPECTED (WHAT LANGUAGE IT'S IN)
COD==:,-1	;BIT TYPEOUT MASK
CODMID==:0	;MIDAS CODE (THE DEFAULT)
CODRND==:1	;RANDOM TEXT (NO SYMBOLS)
CODFAI==:2	;FAIL CODE
CODP11==:3	;PALX-11 CODE
CODLSP==:4	;LISP CODE
CODM10==:5	;MACRO-10 CODE
CODUCO==:6	;UCONS CODE
CODTXT==:7	;TEXT FOR XGP
CODMDL==:10	;MUDDLE CODE
CODH16==:11	;H316 CODE
CODMAX==:12	;1 + <LARGEST LEGAL CODTYP VALUE>

FAILP:	0	;NEGATIVE IFF CODTYP HOLDS CODFAI (FAIL CODE); POSITIVE IF CODM10 (MACRO-10 CODE).
PALX11:	0	;NONZERO IFF CODTYP HOLDS CODP11 (PALX-11 CODE).
DAPXP:	0	;NONZERO IFF CODTYP HOLDS CODDAP (DAPX16 CODE).
TEXTP:	0	;NEGATIVE IFF CODTYP CONTAINS CODTXT; POSITIVE IFF CODRND
TEXGPP:	0	;NONZERO FOR /L[TEXT] /D[XGP]

LINEL:	0	;OUTPUT LINE LENGTH
PAGEL:	0	;OUTPUT PAGE LENGTH, AS SPECIFIED.
TLINEL:	0	;LINEL-<WIDTH OF REF MESS>, I.E. TEXT LINEL
PLINEL:	0	;MIN(TLINEL-30., 69.)
PAGEL1:	0	;OUTPUT PAGE LENGTH MINUS 2 LINES FOR QOPYRT MSG IF THERE IS ONE.

TRUNCP:	-1	;POS => TRUNCATE OUTPUT LINES AT RIGHT MARGIN.
		;NEG => CONTINUE THEM.
		;0 => NEITHER (LET THEM RUN ON).

SINGLE:	0	;NON-ZERO => ONLY ONE OUTPUT FILE (/S)
PRLSN:	0	;NON-ZERO => PRINT DEC LSN'S AS PART OF TEXT (/K)
NORFNM:	0	;NON-ZERO => DON'T RECORD REAL FILE NAME IN LREC FILE -- USE THAT SPEC'ED BY USER
UNIVCT:	0	;# OF UNIV SYMBOL TABLES (-1 => AFTER EACH FILE)

QUEUE:	0	;WHETHER AND HOW TO QUEUE FILES FOR OUTPUT.
QU.NO==-1	;-1 => DON'T QUEUE FILE FOR PRINTING.
QU.YES==0	;0 => QUEUE FOR PRINTING ON SPECIFIED PRINTING DEVICE.
QU.GLD==1	;1 => QUEUE FOR GOULD LPT.  OBSOLETE.  CHANGED TO DEVICE/ DEVGLD AND QU.YES.
QU.BAD==2	.SEE FPSXGP ;2 - ILLEGAL VALUE FOR QUEUE TO HAVE.

NOTITL:	0	;NONZERO => NO TITLE PAGE, NO PAGE MAP AND DELETED&PRINTED PAGES LIST.
HEDING:	0	;NEGATIVE => NO HEADING; POSITIVE => LEAVE THAT MANY LINES WITH NO TEXT, JUST HEADING (/")
REALPG:	0	;NONZERO => ALWAYS PRINT REAL, NOT VIRTUAL, PAGE #S (/Y).
NXFDSP:	0	;POSITIVE => FORGET ABOUT NONEXISTENT FILES FROM LREC FILE, AFTER ASKING USER.
		;NEGATIVE => DON'T ASK USER, JUST KEEP THE FILES.
		;ZERO => ASK USER, AND IF HE SAYS "GO AHEAD" KEEP THE FILE.
NOCOMP:	0	;NONZERO => PRINT FULL LISTINGS INSTEAD OF COMPARISON LISTINGS (/-G).
NORENUM:0	;NONZERO => DON'T GENERATE ANY /'D PAGE NUMBERS OR PAGE NUMBER GAPS (/1G).
SYMTRN:	0	;NONZERO => IN SYMBOL TABLE, TRUNCATE SYMBOL NAMES TO THIS MANY CHARACTERS.
OLDFL:	0	;0 => NORMAL LISTING.
		;-1 => NORMAL, BUT NO LISTING OUTPUT FILES - JUST LREC OUTPUT.
		;1 => LREC FILE EDIT MODE.
		;VALUE SET BY /O SWITCH.
DLRFL:	0	;-1 => CALL DLREC TO WRITE READABLE DESCRIPTION OF INPUT LREC INFO.
FISORF:	0	;NON-ZERO => SORT FILENAMES ON TITLE PAGE
		;POSITIVE => SORT THEM WHEN DOING PASS 2 AS WELL

;THESE WORDS EXIST SO THAT WHEN DEFAULT SWITCH VALUES ARE SEEN
;IN AN INPUT LREC FILE, THOSE SWITCHES SPEC'D BY USER (WHICH
;ARE ALL DECODED ALREADY) ARE NOT OVERRIDDEN BY THE SETTINGS
;IN THE LREC FILE.
ETRUNCP:0	;NONZERO => TRUNCP WAS EXPLICITLY SPEC'D WITH
		;A /T SWITCH. 0 => TRUNCP WAS DEFAULTED.
ELINEL:	0	;NONZERO => LINEL WAS EXPLICITLY SPEC'D (/W)
EPAGEL:	0	;NONZERO => PAGEL WAS EXPLICITLY SPEC'D (/V)
ECODTYP:0	;NONZERO => CODTYP WAS EXPLICITLY SPEC'D (/? OR /L)
			;AFTER RLREC, NONZERO IF EITHER EXPLICITLY SPEC'D OR SET BY RLREC.
EDEVICE:0	;NONZERO => DEVICE WAS EXPLICITLY SPEC'D (/something)
EUNIVCT:0	;NONZERO => UNIVCT WAS EXPLICITLY SPEC'D (/U)
ESINGLE:0	;NONZERO => SINGLE WAS EXPLICITLY SPEC'S (/S)
EPRLSN:	0	;NONZERO => PRLSN WAS EXPLICITLY SPEC'D (/K)
ENORFNM:0	;NONZERO => NORFNM WAS EXPLICITLY SPEC'D (/=)
ESYMLEN:0	;NONZERO => SYMLEN WAS EXPLICITLY SPEC'D (/<N>S)
EFNTVSP:0	;NONZERO IF FNTVSP WAS EXPLICITLY SPEC'D (/V)
EMARGIN:0	;NONZERO IF MARGINS WERE EXPLICITLY SPEC'D (/M[...])
EFNTF:	0	;NONZERO IF FONT FILES WERE EXPLICITLY SPEC'D (/F[])
EMSWT:	0	;NONZERO => /M OR /-M WAS SPEC'D FOR SOME FILE.
ECRFF:	0	;NONZERO => THE NAME OF THE CREF OUTPUT FILE,
		;OR WHETHER THERE OUGHT TO BE ONE, WAS EXPLICITLY SPEC'D (/C[]).
EOUTFIL:0	;NONZERO => OUTPUT FILE EXPLICITLY SPEC'D (/O[]).
EQUEUE:	0	;NONZERO => QUEUE WAS EXPLICITLY SPEC'D (/X[NOQUEUE], ETC.).
EREALPG:0	;NONZERO => REALPG WAS EXPLICITLY SPEC'D (/Y)
ENOTITL:0	;NONZERO => NOTITL WAS EXPLICITLY SPEC'D (/&).
EHEDING:0	;NONZERO => HEDING WAS EXPLICITLY SPEC'D (/").
ENXFDSP:0	;NONZERO => NXFDSP WAS EXPLICITLY SPEC'D (/!).
ESYMTRN:0	;NONZERO => SYMTRN WAS EXPLICITLY SPEC'D (/<N>A)
EFISORF:0	;NONZERO => FISORF WAS EXPLICITLY SPEC'D (/>)

EF:	0	;THOSE BITS IN F SPEC'D EXPLICITLY BY SWITCHES
		;ARE 1 IN EF.

REALF:	0	;WHAT F HOLDS AFTER RLREC IS CALLED. THIS IS WHAT GETS
		;WRITTEN IN THE LREC OUTPUT FILE AS THE VALUE OF F.
		;IN FACT, F GETS MODIFIED AFTER THAT POINT TO REFLECT
		;OTHER SWITCHES WHICH ARE REALLY REMEMBERED ELSEWHERE.

SUBTTL DATA AREA BOUNDARIES, SYMTAB INFO.

PDLLEN:	PDLDLN		;DESIRED LENGTH OF PDL SPACE
LRCLEN:	LRCDLN		;DESIRED LENGTH OF LRC INFO SPACE
SYMLEN:	SYMDLN		;DESIRED LENGTH OF SYMTAB SPACE
			;THESE VARS ARE USED TO DIVIDE MEMORY UP INTO SPACES.
			;ON ITS, CORE IS ALLOCATED FROM BOTTOM OF SPACE UP.
			;ON DEC SYS, ALL OF SPACE IS ALLOCATED AS REAL CORE INITIALLY.
PDLEND:	0		;ADDRESS OF LAST WORD OF PDL SPACE.
LRCEND:	0
SYMEND:	0

SYMLO:	0		;ADDRESS OF FIRST SYMBOL TABLE ENTRY
SYMHI:	0		;ADDRESS OF LAST ENTRY (NOT LAST +1 !!!)
SYMAOB:	0		;AOBJN POINTER FOR SYMBOL TABLE
LRCPTR:	0		;PDL POINTER FOR LREC DATA (EXCH WITH DP FOR USE)
SYM%LN:	0		;SYMS/LINE FOR SYMBOL TABLE LISTING
SYM%PG:	0		;SYMS/PAGE
SYMSIZ:	0		;NUMBER OF CHARS PER SYMBOL
TYPSIZ:	0		;NUMBER OF CHARS FOR TYPE
SYMCNT:	0		;COUNTER FOR SYMBOLS

CHS%WD:	0		;CHARS/WORD (5 FOR ASCII, 6 FOR SIXBIT)
MAXSSZ:	0		;MAX SYMBOL SIZE (SEE DEFSYM)
MAXTSZ:	0		;MAX TYPE SIZE

COLAOB:	0,,COLTAB	;AOBJN POINTER FOR SYMBOL TABLE COLUMNS
COLTAB:	BLOCK 10	;TABLE OF POINTERS FOR COLUMNS

DEBUG:	SITE&ITSFLG	;NONZERO IF DEBUGGING. SET TO 0 BY PURIFY.
			;WHEN NONZERO, SOME THINGS SAVE INFO, AND
			;SOME INCONVENIENT VALRETS ARE SUPPRESSED.

OLRECA:	0		;AOBJN POINTER TO CONCATENATED INPUT LISTING RECORD FILES.
			;SET UP BY RLREC, WHICH READS IN THE FILES.
			;THE DATUM POINTED TO IS IN DATA SPACE.

PRESS,[

SUBTTL	PRESS FILE OUTPUT VARIABLES

PRESSP:	0		;NONZERO IF WE ARE WRITING A PRESS FILE.
			; <0 => PORTRAIT, >0 => LANDSCAPE

;PRESS FILE OUTPUT REQUIRES BUFFERING UP LOTS OF GARBAGE.
;THIS BUFFER IS USED FOR ACCUMULATING ENTITY COMMANDS
;AS THE DATA IS PUT INTO SLBUF.
ENTBUF:	0		;AOBJN POINTER TO ENTITY BUFFER FOR PRESS FILE OUTPUT.
ENTBPT:	0		;8-BIT BYTE POINTER FOR FILLING BUFFER.
ENTCNT:	ENTDLN		;NUMBER OF BYTES LEFT IN BUFFER.  INITIAL VALUE IS DESIRED SIZE.

;THIS BUFFER IS USED FOR ACCUMULATING THE PART DIRECTORY OF THE FILE.
;IT CONTAINS AN 18-BIT BYTE FOR EACH PART -- THE NUMBER OF PDP-10 WORDS USED FOR THAT PART.
DIRBUF:	0		;AOBJN POINTER TO BUFFER FOR PART DIRECTORY.
DIRBPT:	0		;9-BIT BYTE POINTER FOR FILLING BUFFER.
DIRCNT:	DIRDLN		;COUNT OF BYTES LEFT IN BUFFER.  INITIAL VALUE IS DESIRED SIZE.

PRTCBP:	0		;B.P. TO START OF THIS RUN OF PRINTING CHARACTERS IN SLBUF.
			;FOR COMPUTING ENTITY COMMANDS TO OUTPUT THEM.
			;ZERO AFTER A CR, LF, ETC.

PAGWDS:	0		;NUMBER OF PDP-10 WORDS OUTPUT TO FILE FOR THIS PAGE SO FAR.
			;THIS COUNTER DOES NOT INCLUDE THE DATA STILL IN SLBUF.

PRESSF:	0		;FONT NUMBER (ORIGIN 0) OF THE CURRENT FONT
PRESSX:	0		;XPOS OF CURSOR POSITION ON PAGE.
PRESSY:	0		;YPOS OF BASELINE OF CURRENT LINE.
PRESSW:	0		;WIDTH OF PAGE IN DOTS EXCL. MARGINS.
PRESSH:	0		;HEIGHT OF PAGE IN DOTS EXCL. MARGINS.

PRSXY:	0		;"SET X",,"SET Y" COMMANDS (SET IN PRSINI)

ITS,[
FWIDFL:	SIXBIT /FONTS/		;FILENAME OF FILE CONTAINING FONT WIDTHS.
	SIXBIT /DSK/
	SIXBIT /FONTS/
	SIXBIT /WIDTHS/
];ITS
SAI,[
FWIDFL:	0
	SIXBIT /SYS/
	SIXBIT /FONTS/
	SIXBIT /WID/
];SAI
CMU10,[
FWIDFL:	XWD 43441,105470	;[S200DV00]
	SIXBIT /SSL/		;on "Standard Search List"
	SIXBIT /FONTS/
	SIXBIT /WID/
];CMU10
CMU20,[
FWIDFL:	XWD 0,0
	SIXBIT /FON/		;on FON:
	SIXBIT /FONTS/
	SIXBIT /WID/
];CMU20
T20,[
NOCMU20,[
FWIDFL:	0
	SIXBIT /SYS/
	SIXBIT /FONTS/
	SIXBIT /WID/
];NOCMU20
];T20
T10,[
FWIDFL:	0			; Requires def of FON: for -10 or -20
	SIXBIT /FON/
	SIXBIT /FONTS/
	SIXBIT /WID/
];T10
];PRESS

SUBTTL	PASS 1 VARIABLES

COMC:	";	;COMMENT CHARACTER

NSYMSF:	0	;ON PASS 1, THIS VAR COUNTS SYMS DEFINED IN EACH FILE.
		;AFTER FINISHING A FILE, THIS VAR IS COPIED INTO F.NSYM
		;OF THE FILE, AND THEN ZEROED. THIS IS DONE FOR WLREC'S SAKE.

COMPAR:	0	;USED BY SORT

LISPP:	0	;PDL POINTER SAVED FROM P AT START OF LISP LOOP.
		;^L FORCES A THROW BACK TO THE TOP LEVEL
		;SO THAT THE HEURISTIC READER NEVER SCREWS
		;FOR MORE THAN A PAGE'S WORTH (ASSUMES NO
		;S-EXP IS BROKEN ACROSS A PAGE BOUNDARY).

1CKSFL:	0	;EITHER AN INPUT LREC FILE OR AN OUTPUT LREC FILE WAS SPEC'D.
		;IF SET, IT IS NECESSARY TO CHECKSUM THE INPUT FILES, EITHER TO
		;WRITE THE CHECKSUMS IN THE OUTPUT LREC FILE, OR TO
		;COMPARE WITH THE INPUT LREC FILE.

;THESE 3 WORDS REMEMBER INFO ON STATUS OF THE CHECKSUMMING PROCESS AT THE
;END OF A BUFFERFUL OF INPUT; USED TO INITIALIZE 1CKS FOR THE NEXT BUFFERFULL.
1CKSUM:	0	;ON PASS 1, IF 1CKSFL IS SET, THE CHECKSUMS OF THE PAGES OF
		;THE INPUT FILES ARE COMPUTED IN THIS WORD.
1CKSIF:	0	;-1 => IGNORING 1ST NON-NULL LINE OF A PAGE, FOR /L[TEXT]
1CKSNN:	0	 ;-1 => HAVEN'T YET FOUND A NON-NULL LINE WHILE IGNORING
1CKSCF:	0	;-1 => LAST BUFFERFUL ENDED WITH A CR, SO CHECK FIRST
		;CHARACTER OF NEXT ONE FOR BEING A LF.
1CKSNF:	0	;-1 => LAST BUFFERFUL ENDED LOOKING FOR A LINE NUMBER
		;SO START UP IN THAT MODE ON NEXT BUFFER CHECKSUMMED.
1CKSLN:	0	;NUMBER OF LINES SO FAR ON PAGE, IN THE CHECKSUMMER.
1CKXAD:	0	;RETURN ADDRESS IN 1CKXGP OF CALL TO 1CKXGT THAT RAN INTO END OF BUFFER.
1CKXA:	0	;VALUE OF A SAVED TILL RETURN FROM THAT CALL.

1FCNT:	0	;COUNT OF FILES DURING PASS 1 (USED FOR SETTING MULTI)

PSAVE:	0	;P AS OF ENTRY TO SOME CODE ANALYZER (WHICH MIGHT
		; GET RUDELY INTERRUPTED AT EOF)

1MRDFM:	0	;-1 IF WE ARE IN A .RDEFMAC (AS OPPOSED TO 0 IF .DEFMAC)

1UCOLC:	-1,,.	;CURRENT LOCALITY IN UCONS CODE

	0	;FOR USE BY CKLNM, WHEN IT WRAPS AROUND THE BUFFER
		;MUST IMMEDIATELY PRECEDE INBFR!!
INBFR:	BLOCK LINBFR+1	;INPUT BUFFER
LASTIP:	0
ITS, INBFRW:	0	;EXTRA BUFFERED INPUT WORD; WE MUST READ AHEAD OF INBFR
			;SO WE CAN TELL WHETHER THE STUFF AT THE END OF INBFR
			;IS AT THE END OF THE FILE.

SYLBUF:	BLOCK LSYLBUF	;SYLLABLE BUFFER - ALSO USED FOR JCL

MDLFLG:	0	; NON-ZERO IF THIS IS A MUDDLE PROGRAM.
MDLCMT:	0	; -1 IF WE'RE INSIDE A MUDDLE COMMENT.

SUBTTL	PASS 2 VARIABLES

SLBUF:	BLOCK LSLBUF		;OUTPUT ("SLURP") BUFFER
XSLBUF==:SLBUF+LSLBUF-200	;POINT BEYOND WHICH TO OUTPUT
IFLE LSLBUF-200, .ERR LSLBUF must be greater than 200 for XSLBUF
;STRATEGY FOR OUTPUTTING THE MAIN BODY OF A LISTING IS TO LEAVE NTABS*8 CHARS OF SPACE
;AT THE FRONT OF EVERY LINE;  WHEN THE LINE IS DONE, OUTRFS FILLS UP THAT SPACE
;WITH DIGITS OR WITH BLANKS.  2OUTBF/2OUTPJ MUST NOT BE DONE IN THE INTERVAL BETWEEN
;THOSE TWO ACTIONS, OR SPACE MIGHT BE OUTPUT FULL OF GARBAGE.

LASTSP:	0			;WHEN SPACE HAS BEEN LEFT FOR REFS, LASTSP POINTS AT START OF THAT SPACE.
THISSP:	0			;POINTS AT END OF SPACE LEFT FOR REFS (START OF LINE'S TEXT)

OUTVP:	0			;ON PASS 2, NUMBER OF OUTPUT LINES IN CURRENT PAGE.
				;OUTVP INCLUDES CONTINUATION LINES, WHILE RH(N) DOES NOT.
				;THE SUBPAGE NUMBER IS OUTVP/PAGEL.
				;(FOR EXAMPLE, WE'RE ON A CONTINUATION PAGE IF OUTVP > PAGEL).
OUTPAG:	0			;NUMBER OF FORM FEEDS IN THE CURRENT OUTPUT FILE
2MCCOL:	-1			;DURING PASS 2, -1 IF NOT PROCESSING COMMENT.
				;WITHIN COMMENT, HOLDS THE HPOS AFTER THE ";" THAT BEGAN COMMENT.
				;USED TO CONTROL LINE-CONTINUATION.
CONTIN:	0			;-1 WHILE HANDLING A CONTINUATION LINE.
				;SERVES TO SUPPRESS THE LINE NUMBER ON IT

SYNCH:	0			;SAVED CONTENTS OF CH FOR SYNTACTIC PARSING COROUTINE.
SYNCP:	0			;SAVED CONTENTS OF CH FOR SYNTACTIC PARSING COROUTINE.
SYNACS:	BLOCK H-A+1		;SAVED CONTENTS OF A THRU H FOR SYNTACTIC PARSING COROUTINE.
SYNP:	0			;SAVED CONTENTS OF P FOR SYNTACTIC PARSING COROUTINE.
IFNDEF SYNPLN,SYNPLN==40
SYNPDL:	BLOCK SYNPLN		;PDL FOR SYNTACTIC PARSING COROUTINE.
MAINP:	0			;SAVED NORMAL STACK POINTER WHILE INSIDE COROUTINE.

UNDRLN:	0			;NONZERO IF IN MIDDLE OF AN UNDERLINE.
				;FOR PRESS FILES, WILL CONTAIN -1,,HPOS OF START OF UNDERLINE.
FFSUPR:	0			;-1 => INHIBIT ^L BEFORE NEXT PAGE (SET BEFORE 1ST PAGE IF NO TITLE PAGE)
TXTIGN:	0			;-1 => 2TEXT READING AN XGP COMMAND, SO ^L'S DON'T COUNT AS PAGE BREAKS.
LFNBEG:	0			;CONTENTS OF N AT START OF LAST TOP-LEVEL SEXP, FOR LISP AND UCONS.
OUTFLG:	0			;NONZERO WHILE IN SYNTACTIC COROUTINE
				;IF THIS PAGE IS BEING PRINTED.

LSYL:	0			;SYMBOL TABLE ENTRY OF LAST REF ON LINE.
LSYL2:	0			;OTHER LAST REFERENCE (FOR PDP-11 CODE)
LSYL1P:	0			;DURING OUTLIN, -1 WHILE OUTPUTTING THE FIRST REF
				;WHEN THERE ARE TWO PER LINE.

2PUTX:	0			;JFCL  FOR TRUNCP 0;  CAIGE CC,<TLINEL>  FOR TRUNCP NOT 0
2PUTNX:	0			;CAIA  FOR TRUNCP 0;  CAIL CC,<TLINEL>   FOR TRUNCP NOT 0
2PUTTC:	.VALUE			;CAIA IF TRUNCATING; PUSHJ P,2PUTNL IF CONTINUING.
NTABS:	0			;NUMBER OF TABS IT WOULD TAKE TO EQUAL WIDTH OF REFS AT FRONT OF LINE.
LOOKIT:	0 .SEE LOOK,NLOOK	;ADDRESS OF SYMBOL-LOOKUP ROUTINE.

SLURPY:	0 .SEE SLURP,XSLURP	;PASS 2 CHAR INPUT ROUTINE.  RETURNS CHAR IN CH.
;SLURPY IS THE ROUTINE USED BY 2GETCH
;TO GET A CHARACTER FOR PASS 2 SYNTACTIC PROCESSING.
;THIS CAN BE XSLURP, WHICH DOES NOT LIST THE CHARACTER,
;SLURP, WHICH DOES LIST IT, OR SLURPG, WHICH LISTS BUT SCANS XGP CODES
;FOR DETECTING END OF LINE AND END OF PAGE.
;THE SETTING DEPENDS ON THE LANGUAGE, WHETHER THE FILE IS BEING LISTED,
;AND WHETHER THE CURRENT INPUT PAGE IS BEING LISTED.

PAGTPT:	0			;ON PASS 2, POINTS TO PAGE TABLE OF CURRENT FILE.
				;POINTER IS 0 TO LIST EACH PAGE WITH ITS REAL NUMBER.
				;A PAGE TABLE CONSISTS OF TWO-WORD ENTRIES, ONE
				;FOR EACH PAGE OF THE FILE. THE FIRST IS A
				;CHECKSUM FOR THE PAGE. THE SECOND WORD'S LH
				;HOLDS THE LINE-NUMBER OFFSET (THE "NUMBER"
				;FOR LISTING PURPOSES OF THE FIRST LINE ON THE
				;PAGE) AFTER CPRL, OR IN OLD PAGE TABLES;
				;BEFORE CPRL, IT HOLDS THE NUMBER OF LINES ON
				;THE PAGE. THE RH HAS THE FOLLOWING:
NEWPAG==:400000			;2.9 => THIS PAGE NEEDS RELISTING (CPR
				;SETS THESE BITS)
MAJPAG==:071200			;B.P. TO MAJOR PAGE # FIELD.
MINPAG==:000700			;B.P. TO MINOR PAGE # FIELD.

PAGMIN:	0			;ON PASS 2, HOLDS CURRENT FILE'S F.MINP = LOWEST # PAGE
				;THAT SHOULD BE PRINTED. USED FOR RESTARTING A PARTIALLY
				;PRINTED LISTING (SEE "P" SWITCH).

LNDFIL:	0			;NON-ZERO IF CURRENT INPUT FILE HAS SOS LINE NUMBER
ETVFIL:	0			;NON-ZERO IF FILE HAS ETV DIRECTORY.

$DAY:	0			; FOR PTDATE
$MONTH:	0
$YEAR:	0

FQUOTF:	0			;NONZERO TO ENABLE QUOTING OF SPECIAL CHARACTERS IN FILOUT.

SUBTTL	DEC VERSION I-O BUFFERS, HEADERS, OPEN AND LOOKUP BLOCKS, ETC.

DOS,[
INHED:	BLOCK 3
OUTHED:	BLOCK 3

CMU10,IFNDEF NBFRS,NBFRS==:7	;The KL-10 at CMU-10A is disk bound
IFNDEF NBFRS,NBFRS==:2
BFRLEN==:203			;magic size for disk buffers
INBFR2:	BLOCK BFRLEN*NBFRS
OUTBFR:	BLOCK BFRLEN*NBFRS

INCHN:	BLOCK 3-1
	INHED
OUTCHN:	BLOCK 3-1
	OUTHED,,0
INSCHN:	BLOCK 3
RNMCHN:	BLOCK 3
DELCHN:	BLOCK 3

.RBPPN==:1		;POSITION OF PPN IN EXTENDED LOOKUP TABLE
.RBNAM==:2		;POSITION OF NAME 1 IN EXTENDED LOOKUP TABLE
.RBEXT==:3		;POSITION OF NAME 2 IN EXTENDED LOOKUP TABLE
.RBERR==:3		;POSITION OF ERROR CODE (IN RIGHT HALF)
.RBPRV==:4		;PROTECTION, MODE, CREATION TIME AND DATE
.RBSIZ==:5		;POSITION OF FILE LENGTH IN EXTENDED LOOKUP TABLE
.RBDEV==:16		;POSITION OF DEVICE IN EXTENDED LOOKUP TABLE

EXTLEN==:20
IFG .RBDEV-EXTLEN+1,	.ERR EXTLEN IS TOO SMALL

INFIL:	.RBDEV		;ENOUGH TO GET THE DEVICE!
	BLOCK EXTLEN-1
OUFIL:	.RBDEV
	BLOCK EXTLEN-1
INSFIL:	.RBDEV
	BLOCK EXTLEN-1
RNMFIL:	.RBDEV
	BLOCK EXTLEN-1
DELFIL:	.RBEXT		;WE ONLY NEED THE FILE NAME SPEC
	BLOCK EXTLEN-1

IFN OUFIL-INFIL-<EXTLEN*<UTOC-UTIC>>,	.ERR OUFIL PLACED WRONG FOR FLOSE
IFN INSFIL-INFIL-<EXTLEN*<INSC-UTIC>>,	.ERR INSFIL PLACED WRONG FOR FLOSE

NOSAI,[
.DCNAM==:0		;POSITION OF DEV NAME FOR DSKCHR
.DCSNM==:4		;POSITION OF STRUCTURE NAME FOR DSKCHR

STRINF:	BLOCK 1+.DCSNM
];NOSAI

];DOS

SAI,[	;IF /X[QUEUE], WE ACCUMULATE AN XSPOOL COMMAND IN THIS BUFFER
QUEBUF:	BLOCK QUEBFL	;AND PTYLOAD IT ALL AT ONCE WHEN WE EXIT.
QUEBFE:	BLOCK 10
QUEBFP:	440700,,QUEBUF	;POINTER TO STUFF QUEBUF.

QUEARG:	0		;PTYLOAD ARGUMENT BLOCK.
	QUEBUF
];SAI

SUBTTL	FORMAT OF EACH FILE BLOCK

F.==:,-1		;MASK FOR BIT TYPEOUT MODE.

F.ISNM==:0		;INPUT SNAME
F.IDEV==:1		;INPUT DEVICE
F.IFN1==:2		;INPUT FILE NAME 1
F.IFN2==:3		;INPUT FILE NAME 2.  IF DEC SYSTEM, ONLY LH IS MEANINGFUL, BUT
			;A NULL EXTENSION SETS RH TO 1 TO INHIBIT DEFAULTING.
			;FPDEF SETS THE RH BACK TO 0 AGAIN.
F.OSNM==:4		;OUTPUT SNAME - ZERO IF FILE NOT TO BE PRINTED
F.ODEV==:5		;OUTPUT DEVICE
F.OFN1==:6		;OUTPUT FILE NAME 1
F.OFN2==:7		;OUTPUT FILE NAME 2
F.RSNM==:10		;.RCHST'D INPUT SNAME			;USE THESE
F.RDEV==:11		;.RCHST'D INPUT DEVICE			; NAMES WHEN
F.RFN1==:12		;.RCHST'D INPUT FILE NAME 1		; PRINTING OUT
F.RFN2==:13		;.RCHST'D INPUT FILE NAME 2		; FILE ID'S
F.PAGT==:14		;AOBJN PTR TO PAGE TABLE (IN LREC DATA AREA)
F.SWIT==:15		;SWITCH WORD FOR FILE (COPY INTO F WHEN HACK THE FILE)
F.OLRC==:16		;POINTER TO LISTING RECORD INPUT INFO FOR
			; THIS FILE. 0 IF NO SUCH INPUT (SET BY MLREC)
F.NPGS==:17		;NUMBER OF PAGES IN THIS FILE (SET ON PASS 1)
F.NSYM==:20		;# SYMBOLS IN FILE (SET ON PASS 1)
F.MINP==:21		;# OF 1ST PAGE THAT SHOULD BE PRINTED - USED FOR
			; RESTARTING PARTIALLY PRINTED LISTINGS. SET BY P SWITCH.
F.OPGT==:22		;AOBJN POINTER TO OLD PAGE TABLE  (IN DATA AREA).
			;(PART OF WHAT F.OLRC POINTS TO).
			;SET UP BY CPRFF, USED BY CPRA, ETC.
			;NOTE:  CPRFP CLOBBERS 2ND WORDS OF UNREPLACED OLD PAGES
			;TO <0 or NEW PAGE TABLE ENTRY ADDR>,,<OLD PAGE NUMBER>.  THIS SCREWS DLREC.
F.OSMT==:23		;AOBJN TO OLD SYM TABLE (IN DATA AREA)
			;(AGAIN, A SUBENTRY OF WHAT F.OLRC POINTS TO).
F.CRDT==:24		;FILE CREATION DATE, IN SYSTEM-DEPENDENT FORMAT.
			;ON ITS, IT USES RQDATE FORMAT.  ON BOTS-10,
			;THE LH IS THE DATE, AND THE RH IS THE TIME IN MINUTES PAST MIDNIGHT.
F.OCRD==:25		;SIMILAR CREATION DATE FOR COMPARISON FILE

LFBLOK==:26

LFILE:	0		;LENGTH OF CURRENT INPUT FILE, OR 377777,,-1 IF UNKNOWN.
			;SET TO -1 WHEN EOF REACHED.
LFILES:	0		;TOTAL LENGTH OF ALL FILES
SFILE:	0		;POINTS TO AFTER LAST SPECIFIED FILE
CFILE:	0		;POINTS TO CURRENT FILE BLOCK
OFILE:	0		;ON PASS 2, 0 => NO FILE OPEN,
			;ELSE -> FILEBLOCK HOLDING NAMES OF OPEN OUTPUT FILE.
MULTI:	0		;-1 => MORE THAN ONE INPUT FILE BEING PROCESSED (NOT NECESSARILY LISTED)

T20,[
NAMSIZ==:40.		; big buffer for accumulating filenames
NAMBLK:	BLOCK NAMSIZ	;  here it is
JFNBLK:	BLOCK	17	; for longform JFN
];T20

FILES:	BLOCK LFBLOK	;BLOCKS OF FILE SPECS (SHOULD BE ENOUGH)
REPEAT NFILES-1, CONC FIL,\.RPCNT+1,:	BLOCK LFBLOK
EFILES:	0

FILSRT:	BLOCK NFILES+1	;ADDRESSES OF ALL INPUT FILES (ALPHABETICAL BY FILENAMES IF FISORF NONZERO)

DLRECF:	BLOCK 2		;FILE NAMES FOR /_ SWITCH OUTPUT (DLREC).
ITS,	SIXBIT /DLREC >/
DOS,	SIXBIT /DLREC LST/

DLRDEV:	0		;VALUE OF "DEVICE" FOUND IN LREC FILE WE ARE DLREC'ING.

SUBTTL	FILE VARIABLES AND OTHERS

WLRECP:	0		;NON-ZERO => POINTER TO FILE BLOCK FOR LREC OUTPUT
RLRECP:	0		;NON-ZERO => POINTER TO AN LREC FILE THAT WAS READ IN

OTFSNM:	0
OTFDEV:	0
OTFFN1:	SIXBIT \_@_\
OTFFN2:	SIXBIT \OUTPUT\

INSSNM:	0		;INSERTED FILE'S SNAME
INSDEV:	0		;DEVICE
INSFN1:	0		;FILE NAME 1
INSFN2:	0		;FILE NAME 2
INSSWT:	0		;DESIRED F.SWIT SETTING.

FNTSPC:	0		;-1 IF FONTS HAVE BEEN SPEC'D (EXPLICITLY OR THROUGH /G).
FNTVSP:	VSPNRM		;THE VERTICAL SPACING FOR THE XGP TO USE (SCRIMP'S VSP PARAMETER).
FNTWID:	0		;THE WIDTH OF THE WIDEST FONT
FNTWDN:	0		;WIDTH OF FONT 1
FNTHGT:	0		;THE HEIGHT OF THE HIGHEST FONT
FNTBAS:	0		;BASELINE OF THE FONT WHOSE BASELINE IS LARGEST.

MARGIN:			;THE FIVE MARGINS (IN MILS)
MARG.L:	DFLMAR
MARG.T:	DFTMAR
MARG.R:	DFRMAR
MARG.B:	DFBMAR
MARG.H:	DFHMAR

;NOTE: FONT NFNTS+1 IS USED IN PRESS FILES FOR THE TITLE PAGE.  SEE PRSFDR.
FNTF0:	OFFSET -.	;TABLE OF FONT FILES. DON'T ADD ANY WORDS - SEE LR.FNT.
FNTSNM::0		;FILENAMES OF FONT ...
FNTDEV::0		;FOR DOVER, FAMILY NAME IS IN FNTSNM - FNTFN1 AS SIXBIT.
FNTFN1::0		;FNTFN2 IS FACE CODE,,SIZE CODE.
FNTFN2::0
FNTSIZ::0		;<BASELINE>*512.+<HEIGHT>,,<WIDTH> OF FONT.
FNTID::	0		;NON-ZERO => FONT EXPLICITLY SPEC'D.  THIS ALSO HOLDS THE KSTID IF THERE IS ONE
FNTFL::	OFFSET 0
	IFN FNTFL-6,	.ERR YOU SHOULDN'T CHANGE FNTFL OR YOU WILL LOSE WHEN GIVEN OLD LREC FILES
	BLOCK FNTFL*<NFNTS-1>
FNTFE:	BLOCK FNTFL	;EXTRA SPACE CLOBBERED BY FPSFND WHEN USER GIVES TOO MANY FONTS.

CRFFIL::		;THESE 4 WORDS ARE THE NAMES OF THE FILE FOR CREF AND UNIV SYM
CRFSNM:	0		;OUTPUT, IF THERE IS ONE.
CRFDEV:	0		;THE NAMES IN THESE WORDS ARE AS SPEC'D OR READ FROM LREC FILE;
CRFFN1:	0		;NOT YET DEFAULTED.
CRFFN2:	0
CRFOFL:	0		;-1 => CREF & UNIV SYM TABS GO IN A SEPARATE FILE
			;(WHOSE NAMES ARE IN THE ABOVE 4 WORDS).

CRRFIL::
CRRSNM:	0		;THESE 4 WORDS HOLD THE FULLY DEFAULTED CREF OUTPUT FILE NAMES.
CRRDEV:	0
CRRFN1:	0
CRRFN2:	0

OUTFIL::		;OUTPUT FILE SPEC FROM JCL OR LREC FILE (/O)
OUTSNM:	0
OUTDEV:	0
OUTFN1:	0
OUTFN2:	0

ODEFSW:	0		;REMEMBERS FSNSMT SETTING AT END OF COMMAND STRING
			;(= DEFAULT SETTING FOR .INSRT'ED FILES)

MACHINE: SITNAM		;SIXBIT NAME OF SITE
MSNAME:	0		;ULTIMATE DEFAULT SNAME.

CHSTAT:	BLOCK 6		;FOR .RCHST

FPNTBP:	0		;FILENAME COUNTER IN FILENAME READER (SORT OF)
FPSSBP:	0		;DURING PROCESING OF A COMMAND SWITCH, THIS HOLDS B.P. TO
			;BEGINNING OF SWITCH, FOR USE IN ERROR MESSAGE PRINTOUTS.
DOS, FPPNBP: 0		;SIMILAR DURING PARSING OF PPNS

BOTS, SYSBUF: BLOCK 10	;Buffer for printing system name
T20,	SYSBSZ==:12
T20, SYSBUF: BLOCK SYSBSZ	; buffer for printing system name
CMU10, PPNBUF=:SYSBUF	;Buffer for converting special CMU PPNs
T20,[
PPNSIZ==:20.		; buffer size for PPN
PPNBUF: BLOCK PPNSIZ	; Buffer for converting TWENEX PPNs to <directory> names
STRBUF:	ASCII/PS:/	;BUFFER FOR STRUCTURE NAME
	0		;(IN CASE STRUCTURE NAME IS 6 CHARACTERS)
];T20

SUBTTL SUBTTL AND QOPYRIGHT MESSAGE VARIABLES

;;; LINKED LIST OF SUBTITLE INFORMATION.
;;; SUBTITLES ARE ACCUMULATED ON PASS 1 AS A LINKED LIST IN REVERSE
;;; ORDER OF APPEARANCE.  SBSORT USES THE NREVERSE MACRO TO
;;; PUT THE LIST IN FORWARD ORDER FOR OUTLEP AND SUBOUT ON PASS 2.
;;; EACH SUBTITLE NODE LOOKS LIKE THIS:
;;;		<KWIC POINTER>,,<ALPHA POINTER>		;OPTIONAL
;;;	NODE:	-<# CHARS>,,<NEXT POINTER>
;;;		<PAGE NUMBER>,,<FILE BLOCK>
;;;		... WORDS OF ASCII ...

SUBTLS:	0	;LINKED LIST OF SUBTITLES
SUBLEN:	0	;POSITIVE MAX OVER LENGTHS OF ALL SUBTITLES
SUBPTR:	0	;POINTER INTO SUBTLS FOR OUTLEP


;;; LINKED LIST OF @DEFINE'D SYMBOLS FOR LISP CODE OR .DEFMAC'D SYMBOLS
;;; FOR MIDAS CODE.
;;; FORMAT OF LIST FOR LISP CODE:
;;;		NODE:	<UNUSED>,,<NEXT POINTER>
;;;			<SYMBOL>,,<TYPE>
;;; WHERE SOMEWHERE IN THE DATA AREA ARE:
;;;	SYMBOL:	-<# CHARS>,,<POINTER TO CHARS>
;;; AND SIMILARLY FOR TYPE.
;;;
;;; MIDAS HAS SAME FORMAT, BUT <TYPE> IS <FLAGS> (SEE BELOWO) AND SYMBOL
;;; HAS USUAL MIDAS FORM.

ADEFLS:	0	;LINKED LIST OF @DEFINE CRUD

;;; FLAGS IN <TYPE>

%ASRDF==1	;APPEARED IN .RDEFMAC

;;; COPYRIGHT MESSAGE - PRINTED AT BOTTOM OF EACH PAGE IF Q SWITCH SPECIFIED.
;;; NULLS (^@ = ASCII 0) IN THE STRING ARE IGNORED.

CPYMSG:	ASCII \

(\
	ASCII \c) Co\
	ASCII \pyrig\
	ASCII \ht 19\
CPYDAT:	ASCII \xx   \
ITS,	ASCII \ Massachusetts Institute of Technology\

SAI,	ASCII \ Leland Stanford Jr. University\
IFDEF STANSW,IFN STANSW,ASCII \ Leland Stanford Jr. University\

CMU,	ASCII \ Carnegie-Mellon University\

	ASCII \.  All rights reserved.\
REPEAT CPYMSG+30-., 0
LCPYMS==:.-CPYMSG
CPYBP==:440700,,CPYDAT	;BYTE POINTER FOR SETTING DATE IN MSG

PTLO==.				;SOME IMPURE CODE COMES LATER ON IN THE PROGRAM
IFE TWOSEG,	BLOCK 50	;UNLESS WE HAVE A SEPARATE HI SEGMENT, MAKE
				; SURE WE LEAVE SOME ROOM FOR IT
IF2 IFGE IMPTOP-PURBOT, .ERR NOT ENOUGH ROOM LEFT FOR REST OF IMPURE CODE

;NOW SWITCH TO THE PURE CODE AREA
NOSAI,[
IFE TWOSEG,	LOC <.+1777>&776000
];NOSAI
IFN TWOSEG,	LOC RL0+400000
PURBOT::

SUBTTL VARIOUS DEFAULT 2ND FILENAMES AND OTHER MAGIC TABLES.

ITS,[
IPTFN2:	SIXBIT/>/
LRCFN2:	SIXBIT/LREC/
ALRFN2:	SIXBIT/>/
OLRFN2:	SIXBIT/OLREC/
FNDFN2:	SIXBIT/KST/
CRDFN2:	SIXBIT/@CREF/
];ITS

DOS,[
IPTFN2:	OFFSET -.
CODMID:: SIXBIT /MID/
CODRND:: 0
CODFAI:: SIXBIT /FAI/
CODP11:: NOSAI,SIXBIT /M11/
	 SAI,SIXBIT /PAL/
CODLSP:: SIXBIT /LSP/
CODM10:: SIXBIT /MAC/
CODUCO:: 0
SAI,CODTXT::SIXBIT /XGP/
CMU,CODTXT::SIXBIT /XGO/
T10,CODTXT::0
TNX,CODTXT::0
T20,CODTXT::0
CODMDL:: SIXBIT/MDL/
CODH16:: SIXBIT/H16/
CODMAX:: OFFSET 0

LRCFN2:	SIXBIT/LRC/
ALRFN2:	0
OLRFN2:	SIXBIT/OLR/
CRDFN2:	SIXBIT/ATC/
T10,FNDFN2:	SIXBIT/KST/
T20,FNDFN2:	SIXBIT/KST/
CMU,FNDFN2:	SIXBIT/KST/
SAI,FNDFN2:	SIXBIT/FNT/

];DOS

OPTFN2:	OFFSET -.
    DEVLPT::
	ITS,	SIXBIT/@/
	DOS,	SIXBIT/LST/
    DEVIXG::
	ITS,	SIXBIT/@XGP/
	DOS,	SIXBIT/XGP/
    DEVCXG::	SIXBIT/XGO/
    DEVGLD::
	ITS,	SIXBIT/@XGP/
	DOS,	SIXBIT/GLD/
    DEVLDO::	SIXBIT/PRESS/
    DEVPDO::	SIXBIT/PRESS/
    DEVANA::	SIXBIT/ANA/
    DEVMAX::OFFSET 0

SUBTTL LINE AND PAGE LENGTH BY DEVICE

;DEFAULT LINE LENGTH IN CHARS, IF NO FONTS SPECIFIED.
;ZERO FOR A DEVICE FOR WHICH FONTS ARE ALWAYS THOUGHT ABOUT.
LNL:	OFFSET -.
DEVLPT::	120.
DEVIXG::	84.
DEVCXG::	120.
DEVGLD::	132.
DEVLDO::	0
DEVPDO::	0
DEVANA::	132.
DEVMAX::OFFSET 0

;DEFAULT PAGE LENGTH IN LINES, IF NO FONTS SPECIFIED.
;ZERO FOR A DEVICE FOR WHICH FONTS ARE ALWAYS THOUGHT ABOUT.
PGL:	OFFSET -.
DEVLPT::	SAI,[54.] .ELSE 60.
DEVIXG::	60.
DEVCXG::	77.
DEVGLD::	62.
DEVLDO::	0
DEVPDO::	0
DEVANA::	60.
DEVMAX::OFFSET 0

;DOTS PER INCH HORIZONTALLY, OR 0 FOR A NON-GRAPHIC DEVICE.
;FOR PRESS FILE OUTPUT, THESE ARE ACTUALLY MICAS, NOT DOTS.
DOTPIH:	OFFSET -.
DEVLPT::	0
DEVIXG::	200.
DEVCXG::	183.
DEVGLD::	200.
DEVLDO::	2540.
DEVPDO::	2540.
DEVANA::	0
DEVMAX::OFFSET 0

;DOTS PER INCH VERTICALLY, OR 0 FOR A NON-GRAPHIC DEVICE.
;FOR PRESS FILE OUTPUT, THESE ARE ACTUALLY MICAS, NOT DOTS.
DOTPIV:	OFFSET -.
DEVLPT::	0
DEVIXG::	SAI,[199] .ELSE 192.
DEVCXG::	183.
DEVGLD::	189.
DEVLDO::	2540.
DEVPDO::	2540.
DEVANA::	0
DEVMAX::OFFSET 0

;LINE LENGTH IN DOTS, OR 0 FOR A NON-GRAPHIC DEVICE.
;FOR PRESS FILE OUTPUT, THESE ARE ACTUALLY MICAS, NOT DOTS.
LNLDOT:	OFFSET -.
DEVLPT::	0
DEVIXG::	20.*85.
DEVCXG::	1539.
DEVGLD::	20.*85.
DEVLDO::	2540.*11.
DEVPDO::	254.*85.
DEVANA::	0
DEVMAX::OFFSET 0

;PAGE HEIGHT IN DOTS, OR 0 FOR A NON GRAPHICS DEVICE.
;FOR PRESS FILE OUTPUT, THESE ARE ACTUALLY MICAS, NOT DOTS.
PGLDOT:	OFFSET -.
DEVLPT::	0
DEVIXG::	SAI,[2194.] .ELSE 192.*11.
DEVCXG::	183.*11.
DEVGLD::	2080.
DEVLDO::	254.*85.
DEVPDO::	2540.*11.
DEVANA::	0
DEVMAX::OFFSET 0

;NONZERO FOR DEVICE THAT FORCES /X.
;NEGATIVE FOR A DEVICE THAT WANTS PRESS FILES.
;THE RIGHT HALF ENCODES STUFF FOR PRESSP OR XGPP
;NOTE: A DEVICE ALLOWS /X IF ITS PGLDOT (OR, LNLDOT) IS NONZERO.
FRCXGP:	OFFSET -.
DEVLPT::	0
DEVIXG::	0,,-1
DEVCXG::	1
DEVGLD::	0
DEVLDO::	-1,,1
DEVPDO::	-1
DEVANA::	0
DEVMAX::OFFSET 0

SUBTTL	UUO HANDLER

UUOH0:	MOVEM A,UUOASV
	MOVEM B,UUOBSV
	LDB A,[331100,,40]
	CAIG A,UUOMAX
	JUMPN A,@UUOTBL-1(A)
BADUUO:	.VALUE
	JRST BADUUO

UUOTBL:	STRT0
	6TYP0
	FLOSE0
	FLOSE0
	TYPNM0
IFN .-UUOTBL-UUOMAX,	.ERR WRONG NUMBER OF UUO'S DEFINED

6TYP0:	MOVE B,@40
6TYP1:	SETZ A,
	LSHC A,6
	ADDI A,40
	TYO A
	JUMPN B,6TYP1
UUORET:	MOVE B,UUOBSV
	MOVE A,UUOASV
	JRST 2,@UUOH

STRT0:	HRRZ B,40
	HRLI B,440700
STRT1:	ILDB A,B
	JUMPE A,UUORET
	TYO A
	JRST STRT1

TYPNM0:	EXCH C,40
	MOVE A,(C)		;GET NUMBER TO TYPE
	LSH C,-27		;GET RADIX
	ANDI C,17
	PUSHJ P,TYPNM1
	MOVE C,40
	JRST UUORET

TYPNM1:	IDIVI A,(C)
	HRLM B,(P)
	CAIE A,0
	 PUSHJ P,TYPNM1
	HLRZ A,(P)
	ADDI A,"0
	TYO A
	POPJ P,

;FLOSE AND FLOSEI UUOS.
FLOSE0:	INSIRP PUSH P,UUOASV UUOBSV CC CH CP L IP
ITS,	PUSH P,UUOJPC
	PUSH P,UUOH		;MUST END UP AT -1(P)
	PUSH P,40		;MUST END UP AT (P)
	HRRZ A,@-1(P)		;GET ERROR RETURN ADDRESS.
ITS,	.SUSET [.RAPRC,,B]	;IF WE HAVE BEEN DISOWNED,
ITS,	JUMPL B,FLOSE6		;ACT AS IF USER HAD FORCED NO RETRY.
	HRRZ A,40
	TYO [^M]
	TYO [^J]
T20,[
	SKIPN B,(A)		; get PPN
	 JRST FLOSET		; none present
	PUSH P,A		; save A for later
	HRROI A,PPNBUF
	; PPN is already in B
	HRROI C,STRBUF
	PPNST
	OUTSTR PPNBUF		; print PS:<directory>
	POP P,A
FLOSET:
];T20
NOT20,[
	6TYP 1(A)		;PRINT NAME OF FILE WE WERE TRYING TO OPEN.
	TYO [":]
];NOT20
ITS,	6TYP (A)
ITS,	TYO [";]
	6TYP 2(A)
ITS,	TYO [" ]
DOS,	TYO [".]
	6TYP 3(A)
BOTS,[	SKIPN B,(A)
	 JRST FLOSE7
	TYO ["[]	;]
SAI,[	PUSH P,B		;SAIL PPN'S ARE TWO HALFWORDS OF RIGHT-JUSTIFIED 6BIT.
	ANDCMI B,-1
	PUSHJ P,FLOSES
	TYO [",]
	POP P,B
	HRLZS B
	PUSHJ P,FLOSES
	JRST FLOSRB

FLOSES:				;PRINT RIGHT-JUSTIFIED SIXBIT, SANS LEADING SPACES.
	JUMPE B,CPOPJ
	SETZ A,
	LSHC A,6
	JUMPE A,.-1
	ADDI A,40
	OUTCHR A
	JRST FLOSES
];SAI
NOSAI,[
	JUMPL B,[6TYP (A)	;DEC OR CMU => NEGATIVE => PRINT AS SIXBIT.
		JRST FLOSRB]
CMU10,[	MOVE A,[B,,PPNBUF]	;CMU => POSITIVE => FUNNY CMU PPN.
	DECCMU A,
	 JRST FLOSOC
	OUTSTR PPNBUF
	JRST FLOSRB
FLOSOC:
];CMU10
	HLRZ L,B		;DEC => POSITIVE => PRINT HALFORDS NUMERICALLY.
	TYPNUM 8.,L
	TYO [",]
	HRRZI L,(B)
	TYPNUM 8.,L
];NOSAI     ;[
FLOSRB:	TYO ["]]
];BOTS
FLOSE7:	TYO [" ]
	DROPTHRUTO FLOS10

;DROPS THROUGH
;PRINT MESSAGE DESCRIBING TYPE OF ERROR.
;IF OPCODE IS FLOSEI, AC FIELD IS INTERNAL ERROR CODE.
;OTHERWISE, IT IS CHANNEL NUMBER;
;USE THE ERROR CODE RETURNED BY SYSTEM CALL.
FLOS10:	LDB A,[331100,,(P)]	;GET THE OPCODE.
	CAIE A,FLOSEI_-33
	 JRST FLOSE8		;IT'S FLOSE.
	LDB A,[270400,,(P)]	;IT'S FLOSEI - GET AC FIELD.
	JUMPE A,FLOSE3		;ZERO IS SPECIAL -- JUST PRINT FILENAME
	CAIGE A,FLOSSL
	 SKIPN FLOSST-1(A)	;NON-EXISTENT INTERNAL ERROR CODE?
	  .VALUE
	STRT @FLOSST-1(A)	;TYPE THE ERROR MESSAGE.
	JRST FLOSE9

FLOSST:	OFFSET 1-.
FLSNLR::[ASCIZ /Not an LREC file/]
FLSFNT::[ASCIZ /Font file not in known format (KST or FNT)/]
FLSOIN::[ASCIZ /Input file is an @ output file/]
FLOSSL::OFFSET 0


FLOSE8:
ITS,[	.OPEN ERRC,[SIXBIT \   ERR     !      \]
	.VALUE
FLOSE1:	.IOT ERRC,A
	CAIE A,^M
	 CAIN A,^L
	  JRST FLOSE2
	TYO A
	JRST FLOSE1
FLOSE2:	.CLOSE ERRC,
];ITS
DOS,[	LGEXTL==:.TZ EXTLEN	;LOG EXTLEN
IFN <1_LGEXTL>-EXTLEN,	.ERR LGEXTL NOT = LOG(EXTLEN)
IFG LGEXTL-5,		.ERR LGEXTL TOO BIG FOR THE LDB HACK USED HERE
	LDB A,[<<4+LGEXTL>_6>+<<27-LGEXTL>_14>,,(P)]	;GET EXTLEN*AC FROM 40
	HRRE A,INFIL-<EXTLEN*UTIC>+.RBERR(A)
	AOJE A,FLOSE2
	STRT [ASCIZ/Error /]
	HRRZI L,-1(A)
	TYPNUM 8.,L
	TYO [":]
	TYO [" ]
	CAIL A,0
	 CAILE A,MAXERR
	  SETO A,
FLOSE2:	STRT @ERRMSG(A)
];DOS
TNX,	.ERR This code needs work
;COME HERE AFTER PRINTING ERROR MESSAGE.
FLOSE9:	STRT [ASCIZ/
Use what filename instead? /]
	PUSHJ P,TTIL		;READ A LINE OF TYPE-IN.
	HRRZ L,(P)
	MOVE IP,[440700,,SYLBUF] ;PREPARE TO READ THAT INPUT.
	LDB CH,[350700,,SYLBUF]
	CAIN CH,^M		;IF THE LINE IS NULL, TRY TO DO WITHOUT THE FILE.
	 JRST FLOSE5
	PUSHJ P,FPFILE		;OTHERWISE PARSE AS FILESPEC.
REPEAT 2, SOS -1(P)		;AND BACK UP THE PC TO 1 BEFORE THE FLOSE
	JRST FLOSE3

FLOSE5:	HRRZ A,@-1(P)
	CAIE A,ERRDIE
	 JRST FLOSE6
	STRT [ASCIZ/Can't do without this file./]
	JRST FLOSE9

FLOSE6:	HRRM A,-1(P)		;CHANGE THE OLD PC
FLOSE3:	POP P,40
	POP P,UUOH
ITS,	POP P,UUOJPC
	INSIRP POP P,IP L CP CH CC UUOBSV UUOASV
	JRST UUORET

DOS,[	[ASCIZ/(Unknown error code)/]
ERRMSG:	[ASCIZ/OPEN failed -- bad device specified?/]
	[ASCIZ/File not found/]
	[ASCIZ/No UFD for the specified PPN/]
	[ASCIZ/Protection failure or DECtape directory full/]
	[ASCIZ/File currently being modified/]
	[ASCIZ/File already exists/]
	BADERR
	[ASCIZ/UFD transmission error/]
REPEAT 13-7+1,	BADERR
	[ASCIZ/Structure full or quota exceeded/]
	[ASCIZ/Write lock error/]
	[ASCIZ/Not enough monitor table space/]
	[ASCIZ/Partial allocation only/]
	[ASCIZ/Block not free on allocated position/]
	[ASCIZ/Cannot supersede an existing directory/]
	[ASCIZ/Cannot delete a non-empty directory/]
	[ASCIZ/Sub-directory not found/]
	[ASCIZ/Empty search list/]
	BADERR
	[ASCIZ/Can't find a DSK to write/]
	BADERR
MAXERR==:.-ERRMSG-2
BADERR:	ASCIZ/"Impossible" error (you shouldn't be seeing this message)/

LOSE0:	OUTSTR [ASCIZ/Unexpected error at location /]
	PUSH P,LOSE
	SOS LOSE
	HRRZS LOSE
	TYPNUM 8.,LOSE
	POP P,LOSE
	OUTSTR [ASCIZ/
/]
LOSE3:	SKIPE .JBDDT
	 SKIPN DEBUG
	  JRST LOSE1
	OUTSTR [ASCIZ /Entering DDT!
/]
	EXCH A,LOSE
	MOVEM A,.JBOPC
	HRRZ A,.JBDDT
	MOVEM A,LOSEDD
	MOVE A,LOSE
	JRST @LOSEDD

LOSE1:	EXIT 1,
	JRST 2,@LOSE

G:	JRST @.JBOPC	;FOR RESTARTING FROM DDT
];DOS

SUBTTL	GOBBLE ONE LINE FROM TTY

TTILA:
ITS,		TYO ["@]		;PROMPT AND READ A LINE.
BOTS,CMU,	TYO ["@]
BOTS,NOCMU,	TYO ["*]	;USE * SINCE IT IS CONVENTIONAL AND @ IS A SCREW ON TENEX!
TNX,		TYO ["*]
CMU20,		STRT [ASCIZ /AT>/]
T20,NOCMU20,	STRT [ASCIZ /ATSIGN>/]

;READ A LINE FROM THE TTY, DOING RUBOUT PROCESSING.
;DO A RETURN BACK TO THE CALLING PUSHJ IF THE WHOLE LINE IS RUBBED OUT.
;THE LINE GOES IN SYLBUF, TERMINATED BY A CR.
TTIL:	MOVE CP,[440700,,SYLBUF] ;BP -> START OF BUFFER.
	SETZM IP		;0 CHARS READ SO FAR.
TTIL1:	TYI CH			;READ NEXT CHAR.
DOS,[
	CAIN CH,^M		;IGNORE CR'S
	 JRST TTIL1
	CAIN CH,^J		;AND CONVERT LF'S TO CR'S
	 MOVEI CH,^M
];DOS
NODOS,[
	CAIN CH,^U		;CHECK FOR SPECIAL RUBOUT-PROC. CHARS.
	 JRST TTILX		;^U => CANCEL WHOLE LINE.
	CAIN CH,177
	 JRST TTILRB		;RUBOUT => CANCEL LAST CHAR.
	CAIE CH,^J
	 CAIN CH,^L
	  JRST [TYO [^M]
		JRST TTIL1 ]
];NODOS
NOT20,[
	CAIE CH,^C		;^C AND ^Z TURN INTO CR.
	 CAIN CH,^Z
	  JRST [TYO [^M]
		TYO [^J]
		MOVEI CH,^M	;LINE WAS TERMINATED, PUT ^M AT END OF BUFFER.
		IDPB CH,CP
		POPJ P,]
];NOT20
	IDPB CH,CP		;ELSE PUT CHAR IN BUFFER.
	AOS IP
	CAIE CH,^M		;THEY AND CR TERMINATE THE LINE.
	 JRST TTIL1		;OTHER CHARS => KEEP READING.
	POPJ P,

TTILRB:	SKIPN IP		;RUBOUT IF NO CHARS TO RUB
	 JRST TTILX		; IS SAME AS ^U (IE SHOULD RE-PROMPT)
	SOS IP			;ONE CHAR NOW GONE.
	LDB CH,CP
	TYO CH			;TYPE THE CANCELED CHARACTER.
	DBP7 CP
	JRST TTIL1		;GO ON READING.

TTILX:	TYO [^M]		;COME HERE FOR ^U, OR RUBOUT WITH EMPTY BUFFER.
	TYO [^J]
	SOS (P)			;RETURN TO THE PUSHJ WHICH CALLED TTIL OR TTILA.
	POPJ P,

SUBTTL	PDL OVERFLOW INTERRUPT HANDLER

TSINT0:	MOVEM A,INTASV
	MOVEM B,INTBSV
	SKIPL A,.JBCNI
	 TRNN A,200000		;ONLY INTERESTED IN PDL OVERFLOW
	  .VALUE
	HRRZ A,.JBTPC
	LDB A,[270400,,-1(A)]
PDLCHK:	HRRZ B,(A)
	CAIE A,P
	 CAIN A,SP
	  JRST PDLNPG
	CAIE A,DP
	 .VALUE			;WHAT THE HELL?
	AOJ B,
	CAME B,.JBFF		;TRYING TO EXTEND CORE?
	 SOJA B,PDLNPG
IFN TWOSEG, CAILE B,377777
IFE TWOSEG, CAILE B,777777
	 SOJA B,PDLFUL
ITS,[	TLO B,11001
	LSH B,-1
	.CBLK B,
	 JSR CORLUZ
	MOVEI B,2000
];ITS
DOS,[	CORE B,
	 JRST [	STRT [ASCIZ/Unable to get more core.
Type CONTINUE to try again.
/]
		EXIT 1,
		JRST PDLCHK ]
	HRRZ B,.JBREL		;TAKE ALL THE CORE THAT WE HAVE
	SUB B,(A)
];DOS
	CAMN DP,LRCEND		;IF WE OVERFLOWED THE LRC AREA
	 ADDM B,LRCEND		;THEN NOTE THAT FACT
	ADDM B,.JBFF
	MOVNI B,(B)
TSINTF:	HRLM B,(A)
TSINTX:	MOVE B,INTBSV
	MOVE A,INTASV
	.DISMISS .JBTPC

;COME HERE FOR PDL OVERFLOW NOT AT TOP OF USED CORE.
PDLNPG:	CAME B,PDLEND		;ARE WE TRYING TO EXPAND A SPACE PAST ITS TOP?
	 CAMN B,SYMEND
	  JRST PDLFUL		;IF SO, ABORT THE LISTING.
	CAMN B,LRCEND
	 JRST PDLFUL
	CAIN B,SYNPDL+SYNPLN
	 JRST PDLFUL
DOS,	.VALUE
ITS,[	ADDI B,1		;ON I.T.S., SPACES DON'T HAVE ALL THEIR CORE
	TLO B,11001		;SO MAYBE A SPACE JUST WANTS ANOTHER PAGE.
	LSH B,-1
	.CBLK B,
	 JSR CORLUZ
	MOVEI B,-2000
	JRST TSINTF
];ITS

PDLFUL:	CAMN B,PDLEND
	 STRT [ASCIZ/PDL /]
	CAMN B,LRCEND
	 JRST [	STRT [ASCIZ/LREC /]
		JRST PDLFU2]
	CAMN B,SYMEND
	 STRT [ASCIZ/Symbol /]
PDLFU2:	STRT [ASCIZ/data area is full.  Try again with different space allocations./]
ITS,	.VALUE
TNX,	HALTF
DOS,	EXIT 0,	;CAN'T USE .VALUE BECAUSE IT MIGHT BE P THAT OVERFLOWED

SUBTTL ITS CORLUZ AND PURIFY

ITS,[
CORLZ0:	.VALUE [ASCIZ \: Can't get core - type $P to retry 
\]
REPEAT 2, SOS CORLUZ
	JRST 2,@CORLUZ


PURIFY:	MOVE A,[-<<PURTOP+1777-PURBOT>_-12>,,PURBOT_-12]
	SYSCAL CORBLK,[1000,,%CBNDR ? 1000,,%JSELF ? A]
	 .LOSE %LSSYS
	SETZM DEBUG
	.VALUE [ASCIZ ":PDUMP DSK:SYS;TS @"]
];ITS

SUBTTL	INPUT AND OUTPUT MACROS AND SUBROUTINES

;GET CHARACTER INTO CH, DURING PASS 1.
DEFINE 1GETCH
	ILDB CH,IP
TERMIN

;GET CHARACTER INTO CH, DURING PASS 2.
DEFINE 2GETCH
	JSP H,@SLURPY
TERMIN

;DO  1GETCH ? CAIE CH,^C ? PUSHJ P,1MORE1  ON PASS 1
;TO CHECK WHETHER THE ^C MEANT END OF BUFFER OR FILE,
;AND MAYBE REFILL BUFFER AND RETURN TO THE 1GETCH.
1MORE1:	SOS (P)

;DO 1GETCH ? XCT TABLE(CH) WHERE THE ^C ENTRY DOES PUSHJ P,1MORE.
1MORE:	SOS (P)
1MORE0:	MOVEI CH,(IP)
	CAME CH,LASTIP		;IS THIS ^C THE ONE PAST THE END OF THE BUFFER?
	 JRST 1MORE2		;NO, IT IS DATA.  RETURN A ^B TO THE PROGRAM,
				;RETURNING TO AFTER THE 1GETCH.  CAN'T RETURN A ^C
				;SINCE THAT WOULD JUST COME BACK HERE!
	PUSHJ P,DOINPT		;IT IS THE END OF THE BUFFER.  TRY TO REFILL THE BUFFER.
	 JRST 1DONE		;CAN'T GET ANYTHING => THIS FILE IS DONE.
	SKIPE 1CKSFL
	 PUSHJ P,1CKS		;DO CHECKSUMMING ON CHARS JUST READ.
	ILDB CH,IP
	POPJ P,

1MORE2:	MOVEI CH,^B		;YES, CTRL/B, NOT CTRL/C!!!
	POPJ P,			;THIS WINS PROVIDED ^B AND ^C ARE SYNTACTICALLY EQUIVALENT.


;REFILL THE INPUT BUFFER, PASS 1 OR PASS 2.
;SKIPS UNLESS NO MORE INPUT WAS AVAILABLE BECAUSE EOF HAD ALREADY BEEN REACHED.
;SETS LASTIP. PUTS SOME ^C'S IN INPUT BUFFER AT END OF WHAT WAS READ IN.
;RESETS IP TO POINT AT BEGINNING OF BUFFER.
DOINPT:	MOVE IP,LASTIP		;DID WE FAIL TO FILL THE BUFFER LAST TIME HERE?
	SKIPG LFILE
	 JRST [	HRLI IP,440700	;IF SO, SURELY AT END NOW -- MAKE SURE
		POPJ P, ]	;WE SEE MORE ^C'S (ELSE ^M<EOF> LOSES)
	PUSHJ P,DOINP0		;CALL SYSTEM-DEPENDENT INPUT ROUTINE,
				;WHICH SHOULD CLEAR LFILE IF IT REACHES EOF,
				;AND LEAVE IP POINTING AT FIRST WORD OF INBFR NOT FILLED.
	HRLI IP,(.BYTE 7 ? ^C ? ^C)
	HLLOM IP,(IP)		;STICK 2 ^C'S IN THE WORD AFTER THE END OF THE DATA READ.
	HRRZM IP,LASTIP		;MAKE LASTIP POINT AT THAT WORD.
	MOVE IP,[440700,,INBFR]
	JRST POPJ1

ITS,[
DOINP0:	MOVE IP,[-LINBFR,,INBFR-1]
	PUSH IP,INBFRW		;THE FIRST WORD TO "READ" IS THE BUFFERED-BACK WORD.
	ADDI IP,1		;TURN IOWD BACK TO AOBJN POINTER.
	.IOT UTIC,IP
	JUMPL IP,DOINP1		;JUMP IF REACH EOF
	SUB IP,[1,,1]		;SAVE LAST WORD FOR NEXT DOINPT.
	POP IP,INBFRW		;THAT IF LFILE HASN'T BEEN ZEROED, THERE IS MORE
	ADD IP,[1,,1]		;STUFF AFTER WHAT'S IN INBFR (AT LEAST 1 WORD MORE).
	POPJ P,

DOINP1:	SETZM LFILE		;IF WE DON'T FILL THE BUFFER, IT'S EOF.
	POPJ P,

];ITS

DOS,[
DOINP0:	PUSH P,A
	PUSH P,B
	PUSH P,N
	MOVEI N,LINBFR
	MOVEI IP,INBFR
DOINP1:	SOSGE A,INHED+2
	 JRST DOINP2
	LDB B,[300600,,INHED+1]
	CAIE B,44
	 IDIVI A,5		;# WORDS AVAILABLE IN DEC SYSTEM INPUT BUFFER (MINUS 1)
	IBP INHED+1
	HRLZ B,INHED+1		;ADDR OF 1ST ONE.
	HRRI B,(IP)
	SUBI N,1(A)		;DEDUCT # WE'RE XFERING FROM # WANTED.
	JUMPL N,DOINP3		;IF WE DON'T WANT THEM ALL, THEN SPECIAL HACKERY.
	ADDI IP,1(A)
	BLT B,-1(IP)
DOINP2:	PUSHJ P,INSOME		;XFERRED ALL OF SYSTEM BUFFER;  REFILL IT
	 JUMPG N,DOINP1		;GOT SOME STUFF => XFER MORE IF WE WANT MORE.
	JUMPE N,DOINP4
	 SETZM LFILE		;IF WE HAVE NOT FILLED INBFR, THIS MUST BE EOF.
	JRST DOINP4

DOINP3:	ADD A,N			;NOT XFERRING ALL OF SYSTEM BFR => SET UP
	LDB B,[300600,,INHED+1]	;BUFFER COUNTS AND POINTERS FROM WHAT WE ARE TAKING.
	CAIE B,44
	 IMULI N,5
	MOVNM N,INHED+2
	ADDM A,INHED+1
	ADDI IP,1(A)
	BLT B,-1(IP)
DOINP4:	POP P,N
	POP P,B
	POP P,A
	POPJ P,

INSOME:	IN UTIC,
	 POPJ P,
	PUSH P,N
	GETSTS UTIC,N
	TRNN N,740000
	 JRST [	TRNN N,20000	;EOF?
		JRST 4,INSOM2	;NO -- THAT'S VERY FUNNY -- BUT TRY AGAIN
		SETZM INHED+2	;THE MONITOR REALLY SHOULD DO THIS
		SETZM LFILE	;LET EVERYONE KNOW WE HIT EOF, IF THEY CARE
		POP P,N
		JRST POPJ1 ]
	.VALUE
	TRZ N,740000
	SETSTS UTIC,(N)
INSOM2:	POP P,N
	SKIPG INHED+2		;DID WE READ SOME ANYHOW?
	 JRST INSOME		;NO, READ SOME MORE
	POPJ P,			;YES, PROCESS IT FIRST
];DOS

TNX,	.ERR This code loses

;OUTPUT A CHARACTER, TRUNCATING OR CONTINUING IF NECESSARY.
;DOES NOT TAKE CARE OF UPDATING CC.
DEFINE 2PUTCH X
IFSN [X],	MOVEI CH,X
	XCT 2PUTNX	;SKIP IF NOT PAST RIGHT MARGIN.
	 XCT 2PUTTC	;MAYBE CONTINUE, OR SKIP IF TRUNCATING.
	  IDPB CH,SP
TERMIN

;OUTPUT A CHARACTER. DOES NOT CONSIDER TRUNCATING OR CONTINUING.
DEFINE 2PATCH X
IFSN [X],	MOVEI CH,X
	IDPB CH,SP
TERMIN

;OUTPUTS A PAGE-SEPARATOR.
DEFINE 2PAGE
	PUSHJ P,2PAGE1
TERMIN

;IF THE OUTPUT BUFFER IS APPROACHING FULLNESS,
;OUTPUT MOST OF IT, SO THERE WILL BE LOTS OF ROOM.
;IF EVER TOO MANY CHARACTERS GET OUTPUT BETWEEN CALLS TO THIS MACRO,
;@ IS IN DANGER OF LOSING SOME OUTPUT.
DEFINE 2OUTBF
	MOVEI A,(SP)
	CAIL A,SLBUF+LSLBUF
	 .VALUE
	CAIL A,XSLBUF
	 PUSHJ P,2OUTB1
TERMIN

SUBTTL	TABLE OF TYPES USED FOR SYMBOL TABLE PRINTOUT

;;; THE TYPE OF A SYMBOL LIVES IN THE S.TYPE FIELD OF THE SYMTAB ENTRY.
;;; ORDER OF TYPES IS USED IN SORTING ENTRIES.

DEFINE ATYPE STR
	.LENGTH \STR\,,[ASCIZ \STR\]
TERMIN

;;; TYPES FOR MIDAS SYMBOLS (ALSO TYPE CHARS FOR CREF)
;;; ORDER THEM BY DECREASING PREFERENCE FOR BEING USED AS THE
;;; REFERENCE ON A LINE (SINCE THE SYMTAB SORTER SORTS ON THEM).
;;;  -- THE WORD FOLLOWING THE STRING ADDRESS IS THE CHAR THAT
;;;	WILL BE PUT IN A CREF REFERENCE FOR THAT TYPE THING,
;;;	UNLESS BIT T%1WRD IS SET WITH THE STRING ADDRESS.
;;;	BIT T%NREF IN THE LEFT HALF OF THE FIRST WORD IS EFFECTIVE
;;;	JUST AS IN THE SECOND WORD, FOR TYPES WHICH HAVE NO SECOND WORD.

M%CLN:	ATYPE [ ]  ?  ":	;LABEL.
M%VAR:	ATYPE [V]  ?  "'	;MIDAS VARIABLE.
F%VAR:	ATYPE [V]  ?  "#	;FAIL VARIABLE
M%EQL:	ATYPE [=]  ?  "=	;SYM DEFINED WITH "="
F%BAKA:	ATYPE [_]  ?  "_	;SYM DEFINED WITH "_" (IN FAIL).
M%ADEF:	ATYPE [D]  ?  "~	;DEFINED BY A .DEFMAC'D MACRO
F%OPDF:	ATYPE [O]  ?  "=	;FAIL OPDEF.
M%MAC:	ATYPE [M]  ?  "+	;MACRO
M%BLOK:	ATYPE [B]  ?  "*	;BLOCK NAME.
F%SYN:	ATYPE [S]  ?  "=	;MACRO-10 "SYN", MIDAS "EQUALS".
P%CSEC:	ATYPE [C]  ?  "*	;CSECT NAME.
P%NARG:	ATYPE [?]  ?  "?	;SYM DEFINED IN .NARG, .NTYPE OR .NCHR.
M%GLO:	ATYPE [G]  ?  ""	;MIDAS GLOBAL.
F%GLO:	ATYPE [G]  ?  "^	;FAIL GLOBAL SYM.
M%AMAC:	ATYPE [D]  ?  T%NREF,,"~ ;MACRO APPEARING IN .DEFMAC PSEUDO
M%.SEE:	ATYPE [ ]  ?  "!	;.SEE REFERENCE TO A SYMBOL (IN CREFS ONLY)

;;; TYPES FOR LISP CODE (AND CONNIVER)
;;; BITS IN LH OF SECOND WORD:
;;; T%BIND,, MEANS USE THIS TYPE OF DEFINITION ONLY IF THE DEFINITION IS
;;; BETWEEN THE LAST FUNCTION-BEGINNING SEEN AND THE CURRENT LOCATION.
;;; T%TAG,, MEANS USE THIS TYPE OF DEFINITION ONLY IF ON THIS PAGE.
;;; T%NREF,, MEANS DO NOT USE THIS TYPE OF DEFINITION FOR REFS.
;;; T%NPRT,, MEANS DO NOT PRINT THIS DEFINITION IN THE CREF.

T%BIND==1
T%TAG==2
T%NPRT==4
T%NREF==200000
T%1WRD==400000	;NO SECOND WORD FOLLOWS.
T%FLGS==600000	;FLAGS ALLOWED IN LH OF FIRST WORD.

L%EXPR:		ATYPE [EXPR]  ?  "f
L%FEXPR:	ATYPE [FEXPR] ?  "f
L%LEXPR:	ATYPE [LEXPR] ?  "f
L%MACRO:	ATYPE [MACRO] ?  "m
L%SETQ:		ATYPE [SETQ]  ?  "=
L%ARRAY:	ATYPE [ARRAY] ?  "a
L%LABEL:	ATYPE [LABEL]	   ?  T%BIND,,"b
L%LVAR:		ATYPE [LAMBDA VAR] ?  T%BIND,,"b
L%PVAR:		ATYPE [PROG VAR]   ?  T%BIND,,"b
L%DVAR:		ATYPE [DO VAR]     ?  T%BIND,,"b
L%CTAG:		ATYPE [CATCH TAG]  ?  T%BIND,,"c
L%PTAG:		ATYPE [PROG TAG]   ?  T%TAG ,,"t
L%LTAG:		ATYPE [LAP TAG]    ?  T%TAG ,,":
L%ADEF:		ATYPE [@DEFINE]    ?  T%NREF,,"@
L%PROP:		ATYPE [PROPERTY]   ?  T%NREF,,"p
L%UNKN:		ATYPE [????]	   ?  "?   ;IF TYPE IS 0, IT IS TREATED AS L%UNKN.

SUBTTL	PDL AND DATA AREA INITIALIZATION

;THE CONTROL PDL AND LREC DATA AREAS ARE ALLOCATED AS THE FIRST THING DONE (PDLINI).
;WE NEED THE FORMER TO DO ANYTHING AT ALL, AND THE LATTER TO READ THE LREC INPUT FILE.
;THE SYMBOL AND DATA AREAS ARE ALLOCATED LATER, AFTER LREC INPUT PROCESSING,
;SO THAT WE KNOW HOW BIG TO MAKE THE SYMBOL AREA FROM THE /S SWITCH (SYMINI).

;ALLOCATE THE CONTROL PDL AND THE LREC DATA AREA.
;CALL WITH JSP H, (P ISN'T SET UP YET!).
PDLINI:	MOVN C,PDLLEN
	JSP L,PDLIN1
	MOVEM B,PDLEND
	MOVE P,A
	MOVNI C,LRCILN
	JSP L,PDLIN1
	MOVEM B,LRCEND
	MOVEM A,LRCPTR
ITS,	.SUSET [.SMASK,,[%PIPDL]]	;PDL OVERFLOW
TNX,	.ERR This code loses
DOS,	MOVEI A,600000 ? APRENB A,	;PDL OVERFLOW, AUTO REENABLE
	JRST (H)

;Initialize the symbol and data spaces.
;We may also make the LREC data area longer if,
;based on the input LREC file, that seems necessary.
SYMINI:	HRRZ C,LRCPTR		;Since we don't yet have a switch to set LRCLEN
	SUB C,PDLEND		;Fake it by doubling what we have used so far
	ADDI C,1000(C)		;and adding 1000 more
	CAMG C,LRCLEN		;and if that's more than the default
	 SKIPA C,LRCLEN
	  MOVEM C,LRCLEN	;Use it instead
	ADD C,PDLEND		;See where LRCEND should be
	SUB C,LRCEND
DOS,	JUMPE C,SYMIN1		;Jump if lrec area already as long as it needs to be.
ITS,	JUMPLE C,SYMIN1		;On ITS, we don't truncate it.
	ADDM C,LRCEND		;otherwise fix LRCEND
	ADDM C,.JBFF		;initializing DP below will take care of the .CORE UUO, if needed
DOS,[	MOVNI C,(C)		;if not ITS, we must fix LH(LRCPTR)
	HRLZI C,(C)
	ADDM C,LRCPTR
];DOS
SYMIN1:	SKIPE TEXTP		;IF THIS LISTING ISN'T USING SYMBOLS, WE DON'T
	 TDZA C,C		;NEED TO ALLOCATE ANY SYM SPACE.
	  MOVN C,SYMLEN
	JSP L,PDLIN1
	MOVEM B,SYMEND
	MOVE SP,A
	HRRZM SP,SYMLO
	AOS SYMLO
	MOVNI C,DATILN
	JSP L,PDLIN1
	MOVE DP,A
	POPJ P,

;JSP L,PDLIN1 TO ALLOCATE A STORAGE SPACE, WITH DESIRED SIZE IN C.
;RETURNS PDL POINTER TO SPACE IN A, AND ADDR OF 1ST WORD FOLLOWING IN B.
PDLIN1:	HRRZ B,.JBFF
	SUBI B,1
ITS,[	TRO B,1777		;MAKE SURE ON PAGE BOUNDARY
	TRZ C,1777		;AND THAT ASKING FOR AN INTEGRAL NUMBER OF PAGES
	MOVEI A,1(B)
	TLO A,11001
	LSH A,-1
	.CBLK A,		;ALLOCATE THE BOTTOM PAGE.  PDLOV HANDLER WILL GET MORE AS NEEDED.
	 JSR CORLUZ
];ITS
DOS,	TRO B,3	      .SEE SORT	;WHICH ASSUMES THAT SYMTAB ENTRIES START
	MOVEI A,(B)		;ON 4-WORD BOUNDARIES.
ITS,	HRLI A,-2000
DOS,	HRL A,C
	SUB B,C
IFE TWOSEG,	CAILE B,777777	;TOO MUCH CORE??
IFN TWOSEG,	CAILE B,377777	;TOO MUCH CORE??
	 .VALUE
	HRRZM B,.JBFF
	AOS .JBFF
DOS,[	MOVE C,B
	CORE C,
	 .VALUE
];DOS
	JRST (L)

SYSINI:
ITS,[	SYSCAL OPEN,[1000,,TYIC ? 5000,,.UAI ? ['TTY,,]]
	 .LOSE %LSFIL
	SYSCAL OPEN,[1000,,TYOC ? 5000,,.UAO ? ['TTY,,]]
	 .LOSE %LSFIL
	SYSCAL SSTATU,[	;READ NAME OF MACHINE ("AI", "MC", "ML", OR "DM")
		REPEAT 6,[ ? %CLOUT,,MACHINE ]]
	 .LOSE %LSSYS
];ITS
CMU10,[	MOVE B,[1,,11]		;GET SECOND WORD OF "CMU10X ..."
	GETTAB B,
	 POPJ P,		;OH WELL, LEAVE MACHINE WITH "CMU"
	LSH B,1			;MAKE IT SIXBIT
	TLZ B,7777
	TLCN B,400000		;BUT DON'T STORE IT IF OBVIOUSLY NOT A CAPITAL LETTER (E.G. "A", "B", or "D")
	 HLRM B,MACHINE
];CMU10
T20,[ 
	; Actually, we want to use JSYS GETTAB for table 13 here
	; except wedged code wants to store system name in SIXBIT
	; in one word.  Since the flag is [CMU20], we will base
	; this test on the serial number of the processors, of
	; which the only one it knows of is the serial number
	; of CMU20
	MOVEI 1,34		; APR SERIAL NUMBER
	GETAB
	 SETZ 1,		; SERIAL ZERO
	MOVE B,MACHINE		; IN CASE NOBODY MATCHES, LEAVE AS TOPS-20
	CAIN 1,4667		; CMU TOPS-20 SERIAL NO.
	 MOVE B,[SIXBIT /CMU-PI/]
	CAIN 1,2351.		;STANFORD SCORE
	 MOVE B,[SIXBIT /SCORE/]
	MOVEM B,MACHINE		; STORE IT
];T20
	POPJ P,

;READ IN THE DATE AND INITIALIZE THE YEAR IN THE QOPYRIGHT MESSAGE.
DATINI:
ITS,[	.RDATE B,
	MOVE C,[CPYBP]
REPEAT 2,[
	SETZ A,
	LSHC A,6
	ADDI A,40
	IDPB A,C
];REPEAT 2
];ITS
DOS,[	DATE A,
	IDIVI A,31.*12.		;GET YEAR NUMBER MINUS 1964.
	MOVE C,[CPYBP]
	ADDI A,64.+<10.*"0>
	IDIVI A,10.
	IDPB A,C
	ADDI B,"0
	IDPB B,C
];DOS
TNX,	.ERR This code loses
	POPJ P,

JCLGET:
ITS,[	.BREAK 12,[5,,SYLBUF]	;GET JCL FROM DDT
	SKIPE SYLBUF		;AND IF WE GOT SOME, DON'T ASK FOR MORE
	 POPJ P,
];ITS
SAI,[	RESCAN B		;LOOK AT MONITOR COMMAND WHICH RAN ME
	JUMPE B,POPJ1
	INCHRW B		;READ THE FIRST CHARACTER
	CAIN B,"@		;IF @
	 JRST [ MOVSI B,(SIXBIT/@/)
		SETNAM B,
		SNEAKW B,	;THEN PEEK AT SECOND CHAR.
		CAIN B,^M	;IF IT ENDS A LINE, THE COMMAND WAS NULL, SO
		 JRST GOSCEL	;WE HAVE NO COMMAND STRING.
		CAIE B,^J
		 CAIN B,175
		  JRST GOSCEL
		JRST TTIL]	;ELSE, WE HAVE ONE, SO READ IT IN
GOSCEL:	CAIE B,^J		;THE LINE IS NOT A COMMAND STRING FOR US,
	 CAIN B,175		;SO SKIP IT AND THROW IT AWAY.
	  JRST POPJ1
	INCHRW B
	JRST GOSCEL
];SAI
T20,[	RESCAN 1		;LOOK AT MONITOR COMMAND WHICH RAN ME
	 CAIA
	  JRST POPJ1
	INCHRW B		;READ THE FIRST CHARACTER
	CAIE B,"a
	 CAIN B,"A		;IF "A" FOR "ATSIGN"
	  JRST RSCAN1
GOSCEL:	CAIN B,^J		;THE LINE IS NOT A COMMAND STRING FOR US
	 JRST POPJ1
	INCHRW B
	JRST GOSCEL

RSCAN1:	INCHRW B		;SEARCH FOR SPACE
	CAIN B,^J
	 JRST POPJ1
	CAIE B,<" >
	 JRST RSCAN1
	JRST TTIL		;ELSE, WE HAVE ONE, SO READ IT IN
];T20
NOSAI,NOT20,JRST POPJ1

SUBTTL	TOP LEVEL

GO:
DOS,[	 JFCL			;We don't care wether we get run with a CCL linkage or not
	RESET			;AREN'T WE NICE AND PROPER
IFN TWOSEG,	HLLZS .JBSA	;CLOBBER .JBSA SINCE WE CAN'T BE RESTARTED ANYWAY
IFE TWOSEG,[	;Why the hell is this here?  The monitor should do this on RESET UUO -RHG
	HLRE A,.JBSYM		;Get the symbol table length
	MOVN A,A
	ADDI A,.JBFF1		;add in the top of the low segment
	HRLZM A,.JBSA		;and set the low segment length
	MOVEM A,.JBFF
];IFE TWOSEG
];DOS
TNX,	RESET
	JSP H,PDLINI		;ALLOCATE PDL SPACES, SET UP PDL POINTERS, GET CORE.
	PUSHJ P,SYSINI		;INITIALIZE I/O CHANNELS, OTHER SYSTEM-DEPENDENT RANDOMNESS.
	PUSHJ P,DATINI		;GET DATE AND INITIALIZE THE QOPYRIGHT MESSAGE.
	PUSHJ P,JCLGET		;GET COMMAND LINE FROM SUPERIOR; SKIP IF NONE.
	 JRST GO2
	6TYP [.FNAM1]
	TYO [".]
	TYPNUM 10.,[VERSION]
IFN SUBVER,[
	TYO [".]
	TYPNUM 10.,[SUBVER]
];IFN SUBVER
	TYO [^M]
	TYO [^J]
	PUSHJ P,TTILA		;READ COMMAND FROM TTY, PROMPTING WITH "@".
GO2:
	PUSHJ P,FPARSE		;INTERPRET COMMAND STRING.
	PUSHJ P,FPDEF		;DEFAULT MOST FILENAMES
	PUSHJ P,RLREC		;READ IN LISTING RECORD INPUT FILES.
	PUSHJ P,FPDLNG		;FIGURE LANG. OUT FROM INPUT FILES & SET DECODED FLAGS.
	PUSHJ P,FPDDED		;DEDUCE SOME THINGS FROM THE SWITCH SETTINGS.
	SKIPE DLRFL		;IF /_ SWITCH, DUMP ASCII VERSION OF OUR LREC INFO.
	 JRST [	PUSHJ P,DLREC
		JRST DEATH ]
	PUSHJ P,WLRDF		;DEFAULT THE FN2 OF THE LREC OUTPUT FILE, IF ANY.
	MOVEM F,REALF		;SAVE VALUE OF F TO BE PUT IN LREC OUTPUT FILE.
	SKIPE B,FNTSPC		.SEE DEVLPT	; see note below
	 MOVE	B,DEVICE			; see note below
	SKIPE	DOTPIH(B)	; only RHG understands these three instructions -jmn
	 PUSHJ P,FNTCPT		;COMPUTE DEFAULT PAGEL, LINEL FROM FONTS.
	PUSHJ P,SYMINI		;ALLOCATE SYMBOL SPACE AND DATA SPACE.
ITS,[	MOVE B,DEVICE
	CAIN B,DEVGLD		;BARF FOR /X /D[GOULD]
	 TLNN F,FLXGP
	  JRST GO7
	SKIPN FNTSPC		;WITH NO /F[FONTS]
	 JRST [	STRT [ASCIZ \/X[GOULD] requires specified fonts!\]
		JRST ERRDIE ]
GO7: ];ITS
	SKIPLE OLDFL		;LREC FILE EDIT MODE?
	 JRST GO5		;YES, OMIT CERTAIN PASSES.
	SKIPE TEXTP		;If the languge is [RANDOM] or [TEXT]
	 JRST GO6		; THEN RUN MLREC EARLY
	PUSHJ P,1START		;LOOK AT FILES TO FIND SYMBOL DEFINITIONS.
				;ALSO CREATE PAGE TABLES.
	PUSHJ P,1END		;SORT SYMBOL TABLE.
	PUSHJ P,DUPL		;LINK TOGETHER DUPLICATE ENTRIES.
	PUSHJ P,SBSORT		;REVERSE AND SORT OUT SUBTITLES LIST
	PUSHJ P,FISORT		;SORT FILES BY NAME (ACTUALLY MAKE SORTED POINTER-TABLE TO THEM)
	PUSHJ P,MLREC		;MATCH INPUT LREC ENTRIES WITH FILES BEING LISTED.
GO4:	SKIPE 1CKSFL
	 PUSHJ P,CPR		;PRODUCE PAGE TABLES OF FILES BEING LISTED.
	SKIPN OLDFL		;UNLESS SHOULDN'T ACTUALLY LIST,
	 PUSHJ P,2START		;LIST THE FILES.
	PUSHJ P,WLREC		;WRITE OUTPUT LREC IF THAT IS REQUESTED.
SAI,	PUSHJ P,PTYLD		;REQUEST QUEUEING OF OUTPUT FILES (DONE BY 2OCLSQ IN ITS VERSION)
	JRST DEATH

GO6:	PUSHJ P,MLREC		;RUN MLREC EARLY FOR /L[TEXT] and /L[RANDOM]
	PUSHJ P,1START		;SO 1LOOP CAN COMPARE CREATION DATES
	PUSHJ P,SBSORT
	PUSHJ P,FISORT
	JRST GO4

;OPERATING IN LREC FILE EDIT MODE (/1O WAS SPECIFIED).
GO5:	PUSHJ P,MLREC0		;ASSOCIATE OLD LREC INFO WITH FILES.
	PUSHJ P,XLREC		;ALTER NAMES OF FILES IF NECESSARY.
	PUSHJ P,2START
	PUSHJ P,WLREC		;WRITE OUT EDITED LREC FILE.
	JRST DEATH

SUBTTL	FILE NAME PARSER

FPARSE:	MOVEI L,FILES
	MOVE A,[FILES,,FILES+1]
	SETZM FILES
	BLT A,EFILES
	MOVE IP,[440700,,SYLBUF]
	MOVSI D,0		;D = SWITCHES DEFAULTED ON (PERHAPS BY OTHER SWITCHES).
	MOVSI R,0		;R = SWITCHES DEFAULTED OFF.
	SETZB F,N		;F = SWITCHES SPECIFICALLY ON; N = SPECIFICALLY OFF.

;COME HERE AFTER COMMA. START NEW FILE-BLOCK.
FPNEXF:	TRZ F,TEMPF+FSMAIN+FSGET+FSAUX	;RE-INIT NO-STICK PER-FILE FLAGS.
FPNLUP:	PUSHJ P,FPFILE
	CAIE CH,"		;WIN WITH EITHER  OR _ ON BOTH SAIL AND ITS
	 CAIN CH,"_
	  JRST FPARO
	PUSHJ P,FPENDF
	CAIN CH,",
	 JRST FPCOMA
FPEJCL:	MOVEM L,SFILE		;REMEMBER ADDR OF 1ST UNUSED FILEBLOCK
	SETZM (L)
	IORM F,EF		;IN EF, A BIT SHOULD BE SET
	IORM N,EF		;IF THE BIT IN F WAS EITHER
	IORM D,EF		;EXPLICITLY SPEC'D OR IMPLIED.
	IORM R,EF
	TLO D,FLREFS+FLDATE	;THESE 2 DEFAULT ON, BUT DON'T THEREBY COUNT AS EXPLICIT
SAI,	TLO D,FLCTL		;ON SAIL, SHOULD USE SAIL CHAR SET.
	ANDCM R,F		;COMPUTE FINAL SETTINGS OF SWITCHES, IN F.
	ANDCM D,N
	ANDCM D,R
	IOR F,D
NOXGPRES,TLZ F,FLXGP\FLFNT2\FLFNT3
	MOVEM F,ODEFSW
	SKIPL B,DEVICE		;DEFAULT THE PAGEL AND LINEL, ASSUMING THAT FONTS WERE NOT
	 CAIL B,DEVMAX		;SPECIFIED.  IF THEY WERE SPECIFIED, FNTCPT WILL OVERRIDE THIS
	  .VALUE
	MOVE A,LNL(B)
	SKIPN LINEL
	 MOVEM A,LINEL
	MOVE A,PGL(B)
	SKIPN PAGEL
	 MOVEM A,PAGEL
	POPJ P,


FPENDF:	TRZ F,FSSUBT		;THIS CAN BE GARBAGE, HERE.  IT SHOULD BE ZERO.
	MOVEM F,F.SWIT(L)	;SAVE PER-FILE SWITCHES FOR LAST FILE
	TRNN F,FSLREC
	 JRST FPEND2
	TRNN F,FSARW
	 TRNN F,FSQUOT
	  MOVEM L,WLRECP
FPEND2:	ADDI L,LFBLOK
	POPJ P,

;COME HERE WHEN COMMA ENCOUNTERED.
FPCOMA:	CAIE L,EFILES
	JRST FPNEXF
	STRT [ASCIZ \Too many files!\]
	JRST ERRDIE

;COME HERE TO HANDLE BACKARROW.
FPARO:	IORI F,FSARW
	HRLI A,(L)
	HRRI A,4(L)
	BLT A,7(L)
REPEAT 4,	SETZM .RPCNT(L)
	JRST FPNLUP

NOT20,[
;READ IN A FILESPEC, WITH FILEBLOCK ADDRESS IN RH(L).
;IF L IS NEGATIVE, ASSUME WE ARE READING A SUBORDINATE FILE'S NAME
;(SUCH AS FOR /F OR /C), AND DON'T RECOGNIZE (, /, _; DO RECOGNIZE CLOSEBRACKET.

FPFILE:	MOVEI CC,FPNTAB		;SET UP FILENAME COUNTER
FPFIL2:	MOVEM CC,FPNTBP
FPNAME:	MOVE CP,[440600,,CC]
	SETZ CC,
FPLOOP:	ILDB CH,IP
	CAIE CH,",
	 CAIN CH,40
	  JRST FPSPC
BOTS,[	CAIN CH,".
	 JRST FPDOT
	CAIN CH,"[	;]
	 JRST FPSPC
];BOTS
	JUMPGE L,FPLOO1	;[	;IF READING A FONT FILENAME OR CREF OUTPUT FILENAME,
	CAIN CH,"]		;CLOSEBRACKET ENDS THE SPEC,
	 JRST FPSPC
	JRST FPLOO2		;AND SWITCHES ARE NOT ALLOWED (WE'RE ALREADY INSIDE A SWITCH)

FPLOO1:	CAIE CH,"(
	 CAIN CH,"_
	  JRST FPSPC
	CAIE CH,"
	 CAIN CH,"/
	  JRST FPSPC
	CAIN CH,"'
	 JRST	FPQUOT
FPLOO2:	CAIN CH,":
	 JRST FPCLN
ITS,	CAIN CH,";
ITS,	 JRST FPSEMI
	CAIN CH,^Q
	 ILDB CH,IP
	CAIE CH,^M
	 CAIN CH,^I
	  JRST FPSPC
	CAIL CH,140
	 SUBI CH,40
	SUBI CH,40
	JUMPL CH,FPLOOP
	TLNE CP,770000
	 IDPB CH,CP
	JRST FPLOOP

FPNTAB:	MOVEM CC,2(L)		;STORE FN1
	MOVEM CC,3(L)		;STORE FN2
	MOVEM CC,1(L)		;STORE DEVICE
	MOVEM CC,(L)		;STORE SNAME
	SKIPA			;IGNORE ALL EXTRA NAMES.

BOTS,[
FPDOT:	AOS 3(L)		;"." IMPLIES FN2 SHOULD NOT BE DEFAULTED, EVEN IF NULL.
];BOTS
FPSPC:	JUMPE CC,FPSPC5
	XCT @FPNTBP
	 AOS FPNTBP
FPSPC5:	CAIE CH,^M
	 CAIN CH,",
	  POPJ P,	;[
	CAIE CH,"]
	 CAIN CH,"_
	  POPJ P,
	CAIN CH,"
	 POPJ P,
	CAIN CH,"(
	 JRST FPSWS
	CAIN CH,"/
	 JRST FP1SW
BOTS,[	CAIN CH,"[	;]
	 JRST FPPPN
	CAIE CH,".
	 JRST FPNAME
	MOVEI CC,FPNTAB+1
	JRST FPFIL2
];BOTS
ITS,	JRST FPNAME

FPCLN:	JUMPE CC,FPNAME
	MOVEM CC,1(L)
	JRST FPNAME

FPSEMI:	JUMPE CC,FPNAME
	MOVEM CC,(L)
	JRST FPNAME

FPQUOT:	TROE F,FSQUOT		;1 QUOTE => DON'T OUTPUT THIS FILE.
	 IORI F,FSNOIN		;2 QUOTES => DON'T INPUT IT EITHER.
	JRST FPLOOP

BOTS,[
FPPPN:	MOVEM IP,FPPNBP		;IN CASE THERE IS AN ERROR
	SETZB CC,CP
	ILDB CH,IP	;[	;GET A CHARACTER
	CAIN CH,"]
	 JRST [	SAI,	SETZ CC, ? DSKPPN CC,	;[] MEANS CURRENT PPN
		.ELSE	GETPPN CC,
		 JFCL
		JRST FPSEMI ]
SAI,[
	PUSHJ P,FPPPN5		;READ THE PROJECT NAME.
	CAIE CH,",		;IT MUST END WITH A COMMA AND NOT BE NULL.
	 JRST FPPPN4
	JUMPE CC,FPPPN4
	PUSH P,CC
	SETZ CC,		;READ THE PROGRAMMER NAME
	PUSHJ P,FPPPN7
	JUMPE CC,FPPPN4		;IT MUST NOT BE NULL.
	CAIN CH,",		;IT MUSTN'T END WITH COMMA.
	 JRST FPPPN4
	HRL CC,(P)		;MERGE THE TWO.
	SUB P,[1,,1]
	JRST FPSEMI

FPPPN5:	CAIL CH,140		;CONVERT LOWER CASE TO UPPER
	 SUBI CH,40
	LSH CC,6
	ADDI CC,-40(CH)		;AND MERGE INTO SIXBIT.
FPPPN7:	ILDB CH,IP
	CAIL CH,40	;[	;PPN STOPS WITH A CR OR A CLOSEBRACKET.
	 CAIN CH,"]
	  POPJ P,
	CAIN CH,",
	 POPJ P,
	JRST FPPPN5
];SAI
NOSAI,	DROPTHRUTO FPPPN3

;DROPS THROUGH
NOSAI,[
FPPPN3:	CAIL CH,"0
	 CAILE CH,"7
	  JRST FPPPN2
	LSH CP,3
	TRO CP,-"0(CH)
	ILDB CH,IP
	CAIE CH,",
	 JRST FPPPN3
FPPPN6:	ILDB CH,IP
	CAIL CH,"0
	 CAILE CH,"7
	  JRST FPPPN8
	LSH CC,3
	TRO CC,-"0(CH)
	JRST FPPPN6
FPPPN8:	HRLI CC,(CP)	;[
	CAIN CH,"]
	 JRST FPSEMI
FPPPN2:
T10,[
	JUMPN CP,FPPPN4		;NOT AN OCTAL PPN.  IS IT A SIXBIT PPN? MUST BE <0,
	CAIGE CH,100		;IMPLYING THIS CHAR MUST BE > 100 AND NO DIGITS BEFORE IT.
	 JRST FPPPN4
FPPPN5:	CAIL CH,140		;CONVERT LOWER CASE TO UPPER
	 SUBI CH,40
	LSH CC,6
	ADDI CC,-40(CH)		;AND MERGE INTO SIXBIT.
	ILDB CH,IP
	CAIL CH,40	;[	;PPN STOPS WITH A CR OR A CLOSEBRACKET.
	 CAIN CH,"]
	  CAIA
	   JRST FPPPN5
	JUMPE CC,FPPPN4
FPPPN7:	TLNE CC,770000	;NOW THAT WE HAVE THE SIXBIT, LEFT-JUSTIFY IT.
	 JRST FPSEMI
	LSH CC,6
	JRST FPPPN7
];DEC

CMU10,[	JUMPN CC,FPPPN4		;BAD RIGHT OFF IF ALREADY SAW OCTAL
REPEAT 4, SETZM PPNBUF+.RPCNT
	MOVE CP,[440700,,PPNBUF]
FPPPN5:	CAIE CH,^M		;DON'T LOOK TOO FAR
	 SKIPE PPNBUF+3
	  JRST FPPPN4
	IDPB CH,CP
	ILDB CH,IP	;[
	CAIE CH,"]		;LOOP TILL WE FIND A CLOSE BRACKET
	 JRST FPPPN5
	MOVE CP,[CC,,PPNBUF]
	CMUDEC CP,
	 JRST FPPPN4
	JRST FPSEMI
];CMU10
];NOSAI

FPPPN4:	STRT [ASCIZ/Bad PPN: [/]	;]
	MOVE A,FPPNBP
	JRST FPSBD3
];BOTS
]; NOT20


T20,[
;;;	Read a filename up to a comma or line terminator
;;;	Parse it using JFN calls, and then pack up the bitsies
;;;	into SIXBIT cells
FPFILE:
	MOVE	CP,[440700,,NAMBLK]
	SETZ	CC,
FPLOOP:	ILDB	CH,IP			; get a character
	CAIN	CH,",			; interesting delimiter?
	 JRST	 FPSPC			; yes
	JUMPGE	L,FPLOO1		; [scanning spec in switch?
	 CAIN	CH,"]			; yes, close bkt can terminate it
	  JRST	 FPSPC
	JRST	FPLOO2			; not bkt; don't accept switches etc.
FPLOO1:	CAIE	CH,"(			; any delimiters of interest?
	 CAIN	 CH,"_
	  JRST	FPSPC			; yes
	CAIE	CH,"^X
	 CAIN	 CH,"/
	  JRST	  FPSPC			; likewise
	CAIN	CH,"'			; quote
	 JRST	 [TROE F,FSQUOT		.SEE FPQUOT
		 IORI  F,FSNOIN
		 JRST FPLOOP]

FPLOO2:	CAIN	CH,"^Q			; quoting char?
	 ILDB	 CH,IP			; yes, get next
	CAIE	CH,^M			; line end?
	 CAIN	 CH,^I			; or tab?
	  JRST	  FPSPC			; yes, terminator
	CAIL	CH,140			; do casefold
	 SUBI	 CH,40
	IDPB	CH,CP			; stuff it away
	JRST	FPLOOP			; get more

FPSPC:	SETZ	A,			; delimit string we've accumulated
	IDPB	A,CP			; so it is ASCIZ for GTJFN

;;; Now, set up the longform GTJFN arguments that are not already
;;; set up by the GTJFN routine

	MOVE	B,[.NULIO,,.NULIO]
	MOVEM	B,JFNBLK+.GJSRC
	SETZM	JFNBLK+.GJDEV
	SETZM	JFNBLK+.GJDIR
	SETZM	JFNBLK+.GJNAM
	SETZM	JFNBLK+.GJEXT
	SETZM	JFNBLK+.GJPRO
	SETZM	JFNBLK+.GJACT
	SETZM	JFNBLK+.GJJFN
	MOVE	B,[G1%NLN,,0]		; no long names, no other extended args
	MOVEM	B,JFNBLK+.GJF2		; first (and only) extended arg
	
;;;	Now call the GTJFN routine
	MOVE	A,[GJ%OFG+GJ%XTN+JFNBLK]	; flags,,block
	HRROI	B,NAMBLK
	PUSH	P,CH
	PUSHJ	P,CVJFN
	 JRST	FILBOG			; bogus filespec
	PUSHJ	P,UNJFN
	POP	P,CH			; restore CH
FPSWL:
	CAIE	CH,^M			; terminator of interest
	 CAIN	 CH,",
	  POPJ	  P,
	CAIE	CH,^X
	 CAIN	 CH,"_
	  POPJ	 P,
	CAIN	CH,"(
	  JRST	 FPSWS
	CAIN	CH,"/
	  JRST	 FP1SW
	POPJ	P,
FPNAME:				; switch routines return here (gah!)
	ILDB	CH,IP		; pick up next character after switch
	JRST	FPSWL		; and go decode it

FILBOG:	MOVEI	A,.PRIOU
	MOVE	B,[.FHSLF,,-1]
	SETZ	C,
	ERSTR
	JFCL
	JFCL	
	POP	P,CH
	POPJ	P,			; nonskip return
	
;;;	Now, we UNPARSE the filename and pack each string into a
;;;	SIXBIT word

UNJFN:
	PUSH	P,A			; save JFN

	HRROI	A,NAMBLK		; where to write string
	HRRZ	B,(P)			; get JFN back
	MOVE	C,[100000,,0]		; device, unless system default
	SETZ	D,			; zero
	JFNS				; get device
	PUSHJ	P,JFN6			; convert to sixbit, return in A
	MOVEM	A,1(L)
; Convert dev:<directory> to PPN
	HRROI	A,NAMBLK
	HRRZ	B,(P)
	MOVE	C,[200000,,1]		; device and punctuation
	SETZ	D,
	JFNS
	PUSH	P,A			; save string pointer
	PUSHJ	P,JFN6			; check for nullness
	JUMPN	A,JFNNZD		; non-null
	MOVE	A,[ASCII /PS:/]		; dummy device
	MOVEM	A,NAMBLK
	MOVE	A,[170700,,NAMBLK]	; pointer to just past it
	MOVEM	A,(P)
JFNNZD:	DMOVE	A,NAMBLK		;PRESERVE STRUCTURE NAME
	DMOVEM	A,STRBUF		;FOR PPNST JSYS
	MOVE	A,(P)			; where to write directory name
	HRRZ	B,-1(P)			; get JFN back
	MOVE	C,[20000,,1]		; <directory>
	JFNS			; convert to string
	POP	P,A			; pointer to where it should be
	ILDB	B,A			; anything?
	SKIPN	B
         JRST	 FILZPP
	HRROI	A,NAMBLK	
	STPPN
FILZPP:	MOVEM	B,(L)
; get filename (FN1)
	HRROI	A,NAMBLK
	HRRZ	B,(P)
	MOVE	C,[002000,,0]
	JFNS
	PUSHJ	P,JFN6
	MOVEM	A,2(L)
; get extension/filetype (FN2)
	HRROI	A,NAMBLK
	HRRZ	B,(P)
	MOVE	C,[000200,,0]
	JFNS
	PUSHJ	P,JFN6
	MOVEM	A,3(L)
	POP	P,A		; pop off JFN
	POPJ	P,

;;; convert string in NAMBLK to SIXBIT and leave in A
JFN6:	
	MOVE	B,[440600,,A]
	MOVE	C,[440700,,NAMBLK]
	SETZ	A,
JFN6A:
	ILDB	CH,C
	SKIPN	CH
	POPJ	P,
	SUBI	CH,40
	TLNN	B,770000
	 POPJ	P,
	IDPB	CH,B
	JRST	 JFN6A

;;; Convert the JFNBLK spec to a JFN
;;; LH of A is flags, RH of A is pointer to JFN block
;;; B points to file descriptor string, or 0

CVJFN:	HLLZM	A,JFNBLK+.GJGEN		; store flags
	HRLI	A,0			; clear left half
	GTJFN
	POPJ	P,			; error
	AOS	(P)
	POPJ	P,			; skip return
];T20

SUBTTL	COMMAND LINE SWITCH PARSER

FP1SW:	TRO F,FR1SW		;JUST ONE SWITCH
	JRST FPSW0

FPSCL2:	PUSHJ P,FPSCLS
FPSWS:	TRZE F,FR1SW
	 JRST FPNAME
FPSW0:	SETZB A,B
FPSW1:	MOVEM IP,FPSSBP
	ILDB CH,IP
	CAIN CH,^M
	 POPJ P,
	CAIN CH,"
	 MOVEI CH,"_
	CAIL CH,140
	 SUBI CH,40
	CAIG CH,40
	 JRST FPSWS
	JRST @FPSTBL-"!(CH)

FPSDIG:	IMULI A,10.
	ADDI A,-"0(CH)
	AOJA B,FPSW1

FPSNEG:	TLO B,400000
	JRST FPSW1

;JSP H,FPSNUM IN A SWITCH ROUTINE TO DECODE NUMERIC PREFIX ARGUMENT.
;VALUE RETURNED IN A, SKIPPING IF ARG IS NON-NULL.
FPSNUM:	MOVM A,A
	JUMPE B,(H)
	JUMPG B,1(H)
	MOVN A,A
	JUMPN A,1(H)
	MOVNI A,1
	JRST 1(H)

FPSBAD:	STRT [ASCIZ \Illegal switch: \]
FPSBD1:	MOVE A,FPSSBP		;GET BP TO ILDB 1ST CHAR OF SWITCH
FPSBD3:	ILDB CH,A		;PRINT OUT AS FAR AS WE READ BEFORE DETECTING ERROR.
	TYO CH
	CAME A,IP
	 JRST FPSBD3
FPSBD2:	TYO [^M]
	TYO [^J]
	JRST ERRDIE

FPSVAL:	STRT [ASCIZ \Bad value for switch: \]
	JRST FPSBD1

FPSCNF:	STRT [ASCIZ \Conflicting switch: \]
	JRST FPSBD1

SUBTTL MACROS FOR SWITCH DEFINITIONS

;INSIST OF TURNING THE FLAGS IN "ON" ON AND THOSE IN "OFF" OFF.
;ALSO DEFAULT THOSE IN PLSON AND PLSOFF.
;ALL 4 ARGS SHOULD BE SWAPPED (WHICH MEANS R.H. FLAGS SHOULD BE IN PARENS).
DEFINE SW ON,OFF,PLSON,PLSOFF
IFN OFF,	TDNN F,[(OFF)]
IFN ON\OFF,	 TDNE N,[(ON)]
IFN ON\OFF,	  JRST FPSCNF
IFN ON,		IOR F,[(ON)]
IFN OFF,	IOR N,[(OFF)]
IFN PLSON,	IOR D,[(PLSON)]
IFN PLSOFF,	IOR R,[(PLSOFF)]
IFN ON\PLSON,	ANDCM R,[(ON\PLSON)]
IFN OFF\PLSOFF,	ANDCM D,[(OFF\PLSOFF)]
TERMIN

;SET FLAGS ONE WAY IF THERE'S NO MINUS SIGN; ANOTHER WAY IF THERE IS ONE.
;THE TWO ACTIONS WILL GENERALLY BE APPROXIMATELY OPPOSITE.
;NOTE THAT THE LAST 4 ARGS HAVE THEIR INTERPRETATIONS REVERSED
;SO, FOR EXAMPLE, THE 5TH ARG SHOULD GENERALLY RESEMBLE THE 1ST, NOT THE 2ND.
DEFINE SWSW ON,OFF,PLSON,PLSOFF,MOFF,MON,MPLSOFF,MPLSON\FOO,BAR
	JUMPL B,FOO
	SW [ON][OFF][PLSON][PLSOFF]
	JRST BAR
FOO:	SW [MON][MOFF][MPLSON][MPLSOFF]
BAR:
IF2,	EXPUNGE FOO BAR
TERMIN

;SET CODTYP TO TYP, CHECKING FOR CONFLICTS.
DEFINE SWCOD TYP
	MOVEI A,TYP
	PUSHJ P,SWCOD1
TERMIN

SWCOD1:	SKIPE ECODTY
	 CAMN A,CODTYP
	  CAIA
	   JRST FPSCNF
	MOVEM A,CODTYP
	SETOM ECODTY
	POPJ P,

SUBTTL	MISC. SWITCHES

FPSNLN:	SWSW FLNOLN,,,,FLNOLN
	JRST FPSWS

FPSNST:	TRO F,FSNSMT		;/$ MEANS NO SYM TAB - SET FSNSMT OF THIS FILE.
	SKIPGE B
	 TRZ F,FSNSMT		;/-$ MEANS CLEAR FSNSMT - WE DO WANT SYM TAB.
	JRST FPSWS

FPSDAT:	SWSW FLDATE,,,,FLDATE	;DATE IN HEADING
	JRST FPSWS

FPSARB:	JUMPL B,FPSAR1
	TLNE N,FLARB		;/A AND /<N>A TURN ON FLARB
	 JRST FPSCNF
	TLO F,FLARB
	JUMPE B,FPSWS
	MOVEM A,SYMTRN		;/<N>A ALSO SETS SYMTRN.
	SETOM ESYMTRN
	JRST FPSWS

FPSAR1:	TLNE F,FLARB		;/-A TURNS OFF FLARB AND ZEROS SYMTRN.
	 JRST FPSCNF
	TLO N,FLARB
	SETOM ESYMTRN
	SETZM SYMTRN
	JRST FPSWS

FPSOLD:	MOVE CH,IP
	ILDB CH,CH
	CAIN CH,"[	;]
	 JRST FPSOUT		;/O[FOO] SETS OUTPUT FILE NAME
	JSP H,FPSNUM
	 SETO A,		;"/O" SAME AS "/-O".
	MOVEM A,OLDFL
	JRST FPSWS

FPSDLR:	SETOM DLRFL		;/_ IMPLIES CALL DLREC TO WRITE ASCIFIED VERSION OF INPUT LREC FILE.
	TRO F,FSQUOT+FSLREC	;ALSO IMPLIES THIS IS LREC FILE AND SHOULDN'T REWRITE IT.
	JRST FPSWS

FPSCRF:	SWSW FLCREF,,,,FLCREF
	MOVE CH,IP
	ILDB CH,CH
FPSCR2:	CAIE CH,"[	;]	;IS THERE A FILENAME SPEC FOLLOWING THE /C OR /U?
	 JRST FPSWS		;NO.
	HRROI A,CRFFIL
	PUSHJ P,FPSFIL
	SETOM CRFOFL		;SAY THAT A SEPARATE CREF OUTPUT FILE IS WANTED.
	SETOM ECRFF		;AND SAY THAT THIS WAS EXPLICITLY SPEC'D.
	MOVE A,CRFDEV		;EXCEPT THAT IF USER SPEC'D DEVICE AS "NONE"
	CAMN A,[SIXBIT/NONE/]
	 SETZM CRFOFL		;THEN WHAT HE WAS SAYING WAS THAT THERE SHOULDN'T BE A SEPARATE FILE.
	CAMN A,[SIXBIT/NONE/]
	 SETZM CRFDEV
	CAIN CH,^M
	 POPJ P,
	JRST FPSWS

FPSDBL:	SWSW FLSHRT,,FLREFS,,FLSHRT
	JRST FPSWS

FPSOUT:	HRROI A,OUTFIL
	PUSHJ P,FPSFIL
	SETOM EOUTFIL
	CAIN CH,^M
	 POPJ P,
	JRST FPSWS

FPSFIL:	INSIRP PUSH P,CC CP L R D F FPNTBP
	IBP IP
	MOVE L,A
	PUSHJ P,FPFILE
	INSIRP POP P,FPNTBP F D R L CC CP
	POPJ P,

FPSBS:	SWSW FLBS,,,,FLBS
	JRST FPSWS

FPSINS:	SWSW FLINSRT,,,,FLINSRT
	JRST FPSWS

FPSMAI:	MOVE CH,IP
	ILDB CH,CH
	CAIN CH,"[	;]
	 JRST FPSMAR		;/M[<left>,<right>,<top>,<bottom>] sets the margins
	SWSW (FSMAIN),,,,(FSMAIN)
	SETOM EMSWT
	JRST FPSWS

FPSAUX:	SWSW (FSAUX),,,,(FSAUX)	;MAKE FILE BE AUXILIARY (LIKE .AUXIL), OR MAKE IT NOT BE.
	JRST FPSWS

FPSNBG:	SETOM NOTITL		;/& SAYS NO TITLE PAGE, ETC.
	SKIPGE B		;BUT /-& CANCELS /&.
	 SETZM NOTITL
	SETOM ENOTITL		;EITHER WAY, OVERRIDE THE LREC FILE.
	JRST FPSWS

FPSHED:	JSP H,FPSNUM		;/-" => NO PER-PAGE HEADING; /n" => LEAVE n LINE WITH NO TEXT, JUST HEADING
	 MOVEI A,1
	MOVEM A,HEDING
	SETOM EHEDING
	JRST FPSWS

FPSSOR:	JSP H,FPSNUM		;/0> = > NO SORT; /-> => SORT FILES ON TITLE PAGE; /> => SORT PASS 2 TOO
	 MOVEI A,1
	MOVEM A,FISORF
	SETOM EFISORF
	JRST FPSWS

FPSNOR:	SETOM ENORFNM		;/= => STORE USER SPEC'D FILE NAME (INSTEAD OF REAL) IN LREC FILE
	SETZM NORFNM
	TLNN B,400000
	 SETOM NORFNM
	JRST FPSWS

FPSNRF:	SWSW ,FLREFS,,,,FLREFS
	JRST FPSWS

FPSUSF:	SKIPGE B		;/G LIKE /@, BUT ALSO USE REMEMBERED SWITCHES & FILE NAMES.
	 SETOM NOCOMP		;/-G SAYS MAKE FULL LISTINGS, NOT COMPARISON LISTINGS.
	SKIPLE B		;/1G MEANS RELIST PAGES RATHER THAN
	 SETOM NORENUM		;CREATE /'D PAGE #S OR GAPS IN PAGE #S.
	IORI F,FSGET		;G SWITCH => .INSRT FILES MENTIONED BY LREC FILE.
FPSLRC:	IORI F,FSLREC		;(@) SWITCH => THIS IS LISTING RECORD FILE.
	SETOM 1CKSFL		;SAY THERE IS AN LREC FILE SPEC'D.
	JRST FPSWS

FPSCPY:	SWSW FLQPYM,,,,FLQPYM
	MOVE CH,IP		;CHECK FOR EXPLICIT COPYRIGHT MESSAGE
	ILDB CH,CH		; SPECIFIED IN BRACKETS
	CAIE CH,"[	;]
	 JRST FPSWS
	IBP IP
	SETZB B,CPYMSG+1	;B HOLDS BRACKETS COUNT
	MOVE C,[CPYMSG+1,,CPYMSG+2]
	BLT C,CPYMSG+LCPYMSG-1
	DPB B,[010700,,CPYMSG]	;THIS HAIR ZEROS ALL OF MSG EXCEPT 1ST 4 CHARS (2 CRLFS)
	MOVEI C,LCPYMSG*5-4	;PREPARE TO STICK IN USER'S ARG AFTER THOSE CRLFS.
	MOVE A,[100700,,CPYMSG]
FPSCP1:	ILDB CH,IP
	CAIN CH,"[	;]
	 AOJA B,FPSCP2	;[
	CAIN CH,"]
	 JRST FPSCP3
	CAIN CH,^Q		;^Q QUOTES, BUT CANNOT QUOTE A ^M
	 ILDB CH,IP
	CAIN CH,^M		;^M TERMINATES, ALWAYS!
	 JRST FPSWS
FPSCP2:	SOSL C
	 IDPB CH,A
	JRST FPSCP1

FPSCP3:	SOJGE B,FPSCP2		;MATCHING CLOSE BRACKET TERMINATES
	JRST FPSWS

FPSCR:	SWSW FLSCR,,,,FLSCR
	JRST FPSWS

FPSLNM:	SETOM EPRLSN		;/K => PRINT DEC LSN'S AS PART OF TEXT.
	SETZM PRLSN
	TLNN B,400000
	 SETOM PRLSN
	JRST FPSWS

FPSSNG:	JUMPN A,FPSSYM		;/nS SAYS # SYMBOLS IN SYMTAB SPACE.
	SETOM ESINGL		;/S AND /-S SAY WHETHER SINGLE OUTPUT FILE.
	SETZM SINGLE
	TLNN B,400000
	 SETOM SINGLE
	JRST FPSWS

FPSSYM:	IMULI A,LSENT
	MOVEM A,SYMLEN
	SETOM ESYMLEN
	JRST FPSWS

FPSTRN:	JSP H,FPSNUM		;/-T => CONTINUE. /1T => TRUNCATE. /0T => NEITHER.
	 MOVEI A,1		;JUST /T SAME AS /1T.
	MOVEM A,TRUNCP
	SETOM ETRUNC		;INDICATE /T SWITCH WAS SEEN
	JRST FPSWS

FPSUNV:	MOVE CH,IP		;/U: FIRST LOOK AHEAD AT NEXT CHARACTER - MAYBE IT IS OPENBRACKET.
	ILDB CH,CH
	JSP H,FPSNUM
	 JRST [	SETO A,		;NO NUMBER SPEC'D - IF OPENBRACKET DOESN'T FOLLOW,
		CAIN CH,"[ ;]	;ASSUME -1 AS NUMERIC ARG.
		 JRST FPSCR2	;IF BRACKET FOLLOWS, DON'T SET UNIVCT IF NO NUMERIC ARG.
		JRST .+1]
	MOVEM A,UNIVCT
	SETOM EUNIVC		;INDICATE UNIVCT WAS EXPLICITLY SPEC'D.
	JRST FPSCR2		;THERE MAY STILL BE A BRACKET FOLLOWING - HANDLE IT IF SO.

FPSREL:	SETOM REALPG
	SKIPGE B		;/Y - SET (/-Y CLEAR) REALPG "PRINT REAL PAGE #S, NOT VIRTUAL".
	 SETZM REALPG
	SETOM EREALPG
	JRST FPSWS

FPSOKM:	JSP H,FPSNUM		;/-! => KEEP MISSING FILES. /1! => LOSE THEM.  /0! => KEEP AFTER ASKING
	 MOVEI A,1		;/! = /1!
	MOVEM A,NXFDSP
	SETOM ENXFDSP
	JRST FPSWS

FPSRLS:	TRZ F,FSLALL\FSLRNM
	SKIPGE B		;/-J CAUSES A FULL LISTING OF THIS FILE AND SUCCESSIVE FILES.
	 TRO F,FSLALL		; (PER-FILE /-G).
	SKIPLE B		;/1J CAUSES NO /'D PAGE #S OR GAPS IN PAGE #S TO BE CREATED.
	 IORI F,FSLRNM		; (PER-FILE /1G).
	JRST FPSWS

FPSPGL:	JSP H,FPSNUM		;"V" - SET PAGEL OR FNTVSP TO ARGUMENT.
	 JRST FPSVAL
	CAIL A,MAXVSP		;NUMBERS LESS THAN MAXVSP ARE VSP'S.
	 JRST FPSPG1
	MOVMS A			;NEGATIVE NUMBERS SPECIFY LARGER VSP'S.
	MOVEM A,FNTVSP
	SETOM EFNTVSP
	JRST FPSWS

FPSPG1:	CAIGE A,MINPGL		;#S LARGER THAN MAXVSP TRY TO SET PAGEL
	 JRST FPSVAL		;BUT TOO SMALL WILL SCREW @.
	MOVEM A,PAGEL
	SETOM EPAGEL		;INDICATE EXPLICIT /V WAS SEEN.
	JRST FPSWS

FPSLNL:	JSP H,FPSNUM		;"W" - SET LINEL TO ARGUMENT.
	JRST FPSVAL
	CAIGE A,MINLNL
	 JRST FPSVAL
	MOVEM A,LINEL
	SETOM ELINEL		;INDICATE EXPLICIT /W WAS SEEN.
	JRST FPSWS

FPSMNP:	JSP H,FPSNUM		;"P" - SET PAGE TO START LISTING AT.
	 JRST FPSVAL
	MOVEM A,F.MINP(L)
	JRST FPSWS

FPSSBT:	SWSW FLSUBT,,,,FLSUBT
	JRST FPSWS

FPSCTL:	SWSW FLCTL,,,,FLCTL
	JRST FPSWS

SUBTTL	SWITCHES HAVING TO DO WITH SPECIFYING THE LANGUAGE.

FPSRND:	SW ,FLREFS			;RANDOM
	SWCOD CODRND
	JRST FPSWS

FPSFAI:	SW ,,FLREFS+FLCTL,FLARB		;FAIL
	SWCOD CODFAI
	JRST FPSWS

FPSMID:	SW ,,FLREFS,FLARB		;MIDAS
	SWCOD CODMID
	JRST FPSWS

FPSLSP:
IFE LISPSW,STRT [ASCIZ \/L[LISP] not supported in this version of @\]
	SW FLARB+FLASCI,,FLREFS
	SWCOD CODLSP
	JRST FPSWS

FPSUCO:
IFE LISPSW,STRT [ASCIZ \/L[UCONS] not supported in this version of @\]
	SW FLARB+FLASCI,,FLREFS		;UCONS -- VERY SIMILAR TO LISP
	SWCOD CODUCO
	JRST FPSWS

FPSM10:	SW ,,FLREFS,FLARB		;MACRO-10
	SWCOD CODM10
	JRST FPSWS

FPS11:	SW ,,FLREFS+FL2REF,FLARB	;PALX11
	SWCOD CODP11
	JRST FPSWS

FPSTXT:	SW FLNOLN,FLREFS,FLCTL+FLBS+FLSCR ;TEXT (TJ6, PUB, SCRIBE, or TEX output, etc).
	SWCOD CODTXT
	SETZM TRUNCP			;DON'T TRUNCATE OR CONTINUE LINES.
	SKIPN ENXFDSP			;AND DEFAULT /-!
	 SETOM NXFDSP
	JRST FPSWS

FPSMDL:
IFE MUDLSW,STRT [ASCIZ \/L[MUDDLE] not supported in this version of @\]
	SW FLARB+FLASCI,,FLREFS		;MUDDLE
	SWCOD CODMDL
	JRST FPSWS

FPSDAP:	SW ,,FLREFS,FLARB		;DAPX16
	SWCOD CODDAP
	JRST FPSWS

FPSLNG:	ILDB CH,IP
	CAIE CH,"[	;]	;DO WE HAVE BRACKETED NAMES?
	 JRST FPSLN5		;/L WITH NO NAME?
	PUSHJ P,FPSPSP		;PASS SPACES.
	PUSHJ P,FPS6BT		;READ SIXBIT WORD INTO B
	PUSHJ P,FPSCLS		;THROW AWAY ALL UP TO CR OR CLOSEBRACKET.
	LDB A,[360600,,B]	;1ST CHAR IN A.
	CAIN A,'D
	 JRST FPSDAP		;"D" => DAPX16
	CAIN A,'L
	 JRST FPSLSP		;"L" => LISP.
	CAIN A,'U
	 JRST FPSUCO		;"U" => UCONS
	CAIN A,'P
	 JRST FPS11		;"P" => PALX11
	CAIN A,'F
	 JRST FPSFAI		;"F" => FAIL
	CAIN A,'R
	 JRST FPSRND		;"R" => RANDOM (NO SYMBOLS AT ALL).
	CAIN A,'T
	 JRST FPSTXT		;"T" => TEXT (OUTPUT FROM TEXT-JUSTIFIER).
	CAIN A,'M
	 JRST [	LDB A,[300600,,B] ;"M" => MIGHT BE "MIDAS" OR "MACRO-10" OR "MUDDLE".
		CAIN A,'I	;SO LOOK AT THE FOLLOWING CHARACTER.
		 JRST FPSMID
		CAIN A,'A
		 JRST FPSM10
		CAIN A,'U
		 JRST FPSMDL
		JRST FPSLN5]
FPSLN5:	STRT [ASCIZ/Bad language name: /]
	JRST FPSBD1

FPSPSP:	ILDB CH,IP		;ILDB FROM IP TILL NEXT NON-SPACE
	CAIN CH,40
	 JRST FPSPSP
	POPJ P,

FPS6BT:	SETZ B,			;READ 6BIT WORD INTO B OFF OF IP,
	SKIPA A,[440600,,B]	;ASSUMING 1ST CHAR OF IT ALREADY IN CH.
FPS6B1:	 ILDB CH,IP
	CAILE CH,40	;[
	 CAIN CH,"]
	  POPJ P,
	CAIL CH,140
	 SUBI CH,40
	SUBI CH,40
	TLNE A,770000
	 IDPB CH,A
	JRST FPS6B1

FPSCLS:	CAIE CH,^M	;[	;DISCARD UP TO END OF BRACKETED SWITCH.
	 CAIN CH,"]
	  POPJ P,
	ILDB CH,IP
	JRST FPSCLS

SUBTTL	XGP RELATED SWITCHES

NOXGPRES,[
FPSXGP:	FPSFNT:
	STRT [ASCIZ \This @ doesn't support the XGP.  /X and /F not allowed.\]
	JRST FPSBD2
];NOXGPRES

XGPRES,[
FPSXGP:	SWSW FLXGP,,,,FLXGP+FLFNT2+FLFNT3
	JRST FPSWS

FPSFNT:	MOVE CH,IP		;F SWITCH - LOOK AHEAD AT NEXT CHARACTER
	ILDB CH,CH
	JSP H,FPSNUM
	 JRST [	CAIN CH,"[	;]
		 JRST FPSFN0	;FONT NAMES FOLLOW, AND NO #, SO DON'T ASSUME ONE.
		MOVEI A,2	;JUST "F", WITH NO NUMBER AND NO FONT NAMES
		JRST .+1]	;IS THE SAME AS "2F".
	JUMPL A,[SETZM FNTSPC	;/-F turns off FNTSPC
		JRST FPSXGP ]
	JUMPE A,FPSVAL
	CAILE A,3
	 JRST FPSVAL
	TLNE N,FLXGP
	 JRST FPSCNF
	TLZ F,FLFNT2+FLFNT3
	CAIL A,2
	 TLO F,FLFNT2
	CAIL A,3
	 TLO F,FLFNT3
FPSFN0:	CAIE CH,"[	;]	;DO FONT NAMES FOLLOW?
	 JRST FPSXGP
	IBP IP			;YES; SKIP THE BRACKET.
FPSFN3:	INSIRP PUSH P,CC CP FPNTBP L R D F
FPSFNP==:.-FPSFN3
	HRROI L,FNTF0
FPSFN1:	PUSHJ P,FPSFND		;READ, DEFAULT AND LOOK AT ONE FONT.
	CAIN CH,^M		;CR ENDED FONT NAME =>
	 JRST [	SUB P,[FPSFNP,,FPSFNP]
		POPJ P, ]	;ENTIRE COMMAND STRING IS BEING ENDED.
	CAME L,[-1,,FNTFE]	;WHEN TOO MANY FONTS SPEC'D, GARBAGE BLOCK AT FNTFE IS CLOBBERED.
	 ADDI L,FNTFL		;PROCESS NEXT FONT.   ;[
	CAIE CH,"]		;BUT CLOSEBRACKET ENDS THE /F.
	 JRST FPSFN1
	INSIRP POP P,F D R L FPNTBP CP CC
	JRST FPSXGP
];XGPRES

FPSMAR:	SETOM EMARGIN		;M[<left>,<right>,<top>,<bottom>,<hole>] - set margins (in mils)
	IBP IP			;SKIP THE OPENBRACKET.
	HRLZI B,-5
FPSMA2:	PUSHJ P,FPSGNM
	 CAIA
	  MOVEM A,MARGIN(B)
	CAIE CH,",
	 CAIN CH,40
	  AOBJN B,FPSMA2
	JRST FPSCL2

FPSGNM:	PUSHJ P,FPSPSP		;GET A NUMBER
	CAIL CH,"0
	 CAILE CH,"9
	  POPJ P,		;SORRY -- NONE THERE
	MOVEI A,-"0(CH)
FPSGN2:	ILDB CH,IP
	CAIL CH,"0
	 CAILE CH,"9
	  JRST POPJ1
	IMULI A,10.
	ADDI A,-"0(CH)
	JRST FPSGN2

SUBTTL	PRINTING-DEVICE RELATED SWITCHES

FPSDEV:	SKIPN B			;IF THERE IS ANY NUMERIC ARGUMENT,
	 JUMPE A,FPSDE1
	SETZM QUEUE		;SET QUEUE TO EITHER YES
	SKIPE B
	 SETOM QUEUE		;OR NO.
FPSDE1:	MOVE CH,IP		;IS THERE A DEVICE NAME ARGUMENT?
	ILDB CH,CH
	CAIE CH,"[	;]
	 JRST FPSWS
	IBP IP			;GOBBLE THE OPEN BRACKET
	PUSHJ P,FPSPSP		;PASS SPACES
	PUSHJ P,FPS6BT		;READ SIXBIT WORD INTO B
	LDB A,[360600,,B]	;1ST CHAR IN A.
	CAIN A,'L
	 JRST FPSLPT		;"L" => LPT
XGP,[	CAIN A,'X
	 JRST [	MOVEI A,DEVXGP	;"X" => XGP
		JRST FPSDV3]
];XGP
ANADEX,[CAIN A,'A		; A => ANADEX
	 JRST [	MOVEI A,DEVANA
	 	JRST FPSDV4]
];ANADEX
PRESS,[	CAIE A,'D
	 JRST FPSDV2
	CAIE CH,40		;"D" => DOVER
	 CAIN CH,",
	  PUSHJ P,FPSPSP
	CAIE CH,^M	;[	;IS THERE AN ORIENTATION SPEC'D?
	 CAIN CH,"]
	  JRST FPSPDO		;NO, ASSUME PORTRAIT
	PUSHJ P,FPS6BT		;READ SIXBIT WORD INTO B
	LDB A,[360600,,B]	;1ST CHAR IN A.
	CAIE A,'P
	 CAIN A,'V
	  JRST FPSPDO		;"V" (for vertical) and "P" => PORTRAIT
	CAIE A,'L
	 CAIN A,'H
	  JRST [MOVEI A,DEVLDO	;"H" (for horizontal) and "L" => LANDSCAPE
		JRST FPSDV3 ]
];PRESS
FPSDV2:	STRT [ASCIZ/Bad printing-device specification: /]
	JRST FPSBD1

FPSLPT:	MOVEI A,DEVLPT
	JRST FPSDV4

FPSPDO:	MOVEI A,DEVPDO
FPSDV3:	SW FLXGP
FPSDV4:	MOVEM A,DEVICE		;SET PRINTING-DEVICE TYPE
	SETOM EDEVICE
	MOVE B,LNL(A)		;AND ALSO SET LINEL AND PAGEL,
	SKIPN ELINEL		;UNLESS THEY WERE PREVIOUSLY SET EXPLICITLY BY SWITCHES.
	 MOVEM B,LINEL
	MOVE B,PGL(A)
	SKIPN EPAGEL
	 MOVEM B,PAGEL
	JRST FPSCL2

SUBTTL	GOBBLE SIZE INFO FROM FONT FILES

XGPRES,[
;READ IN ONE FONT FILE NAME, DEFAULT IT, AND GOBBLE SIZE INFO FROM THE FONT FILE.
FPSFND:	SETOM FNTSPC		;SAY THAT @ IS SUPPOSED TO HACK FONTS.
PRESS,[	MOVE A,DEVICE		;FONT NAMES FOR THE DOVER ARE NOT FILENAMES.
	SKIPGE FRCXGP(A)	;THERE IS A DIFFERENT WAY OF READING THEM.
	 JRST FPSDF
];PRESS
NOXGP,	POPJ P,
XGP,[	PUSHJ P,FPFILE		;READ IN NEXT FONT'S NAME.
	SKIPE FNTDEV(L)
	 JRST FPSFN4
	SKIPN FNTFN1(L)		;WAS IT REALLY SPEC'D, OR NULL?
	 POPJ P,
FPSFN4:	SETOM FNTID(L)		;SAY THIS FONT WAS EXPLICITLY SPEC'D.
	SETOM EFNTF		;SAY AT LEAST ONE FONT WAS EXPLICITLY SPEC'D.
	MOVE CC,FNTDEV(L)
	CAMN CC,[SIXBIT/NONE/]	;THE WAY TO UN-SPECIFY A FONT IS TO
	 JRST FNTNON		;SPECIFY IT AS DEVICE "NONE:"
	MOVSI CC,'DSK
	SKIPN FNTDEV(L)		;DEFAULT THE OTHER NAMES.
	 MOVEM CC,FNTDEV(L)
	MOVE CC,[FNTDSN]
	SKIPN FNTSNM(L)
	 MOVEM CC,FNTSNM(L)
	MOVE CC,FNDFN2
	SKIPN FNTFN2(L)
	 MOVEM CC,FNTFN2(L)
	MOVEI R,.BII
	MOVEI A,(L)		;OPEN THE FONT FILE, IN IMAGE MODE.
	PUSHJ P,2INOPN
	 JRST 1+[JRST FPSFN4
		FLOSE UTIC,FNTSNM(L)
		JFCL CPOPJ ]
	PUSH P,IP		;READ IN A LARGE AMOUNT OF IT.
	PUSHJ P,2RDAHD
	PUSHJ P,DOINPT
	 JRST POPIPJ
	POP P,IP
	MOVS CC,FNTFN2(L)
	CAIN CC,'FNT
	 JRST FPSFN6
	CAIN CC,'KST		;ERROR IF FONT NOT A KST OR FNT FILE.
	 JRST FPSFN5
	CAIA
	 JRST FPSFN4		;IF USER GIVES A NEW FILENAME, GO TO FPSFN4.
FPSFNE:	FLOSEI FLSFNT,FNTSNM(L)
	 JFCL CPOPJ		;IF HE DOESN'T, RETURN.

FPSFN5:	MOVE CC,INBFR+2		;KST FILE: ITS OR CMU?
	TRNE CC,1
	 JRST FPSFN9
	CAIE CC,2		;MAKE SURE IT IS REALLY NEW CMU
	 JRST FPSFNE
	SKIPLE CC,INBFR
	 MOVEM CC,FNTID(L)
	SKIPA A,[177]		;SEARCH FOR CHAR WITH MAX INCR
FPSFN8:	 CAMGE R,INBFR+10.(A)
	  MOVE R,INBFR+10.(A)
	SOJGE A,FPSFN8
	HLRZ R,R		;USE MAX INCR AS WIDTH OF FONT
	MOVE CC,INBFR+1		;GET FONT HEIGHT
	MOVE A,INBFR+2		;GET FONT BASELINE
	JRST FPSFN7

FPSFN9:	HRRZ CC,INBFR+1		;ITS KST FILE: GET FONT HEIGHT
	HLRZ A,INBFR+1		;GET BASELINE
	ANDI A,777
	HRRZ R,INBFR+4		;GET WIDTH
	JRST FPSFN7		;STORE THEM IN FNTSIZ(L).

FPSFN6:
IFL LINBFR-204,.ERR BAD LINBFR FOR PARSING FNT FILES
	MOVE CC,INBFR+201	;FNT FILE: GET HEIGHT, BASELINE AND WIDTH.
	MOVE A,INBFR+203
	MOVE R,INBFR+202
FPSFN7:	HRLZM CC,FNTSIZ(L)	;STORE FONT HEIGHT.
	DPB A,[331100,,FNTSIZ(L)] ;AND BASELINE
	HRRM R,FNTSIZ(L)	;STORE FONT WIDTH.
	.CLOSE UTIC,		;THAT IS ALL FOLKS
	POPJ P,

POPIPJ:	POP P,IP
	POPJ P,
];XGP

FNTNON:	SETZM FNTSNM(L)		;HE SAID "NONE" -- CLEAR THE FONT
	SETZM FNTDEV(L)
	SETZM FNTFN1(L)
	SETZM FNTFN2(L)
	SETZM FNTSIZ(L)
	SETOM FNTID(L)
	POPJ P,
];XGPRES

PRESS,[

;READ IN A FONT NAME FOR PRESS FILE USE.
;THESE FONT NAMES ARE NOT FILE NAMES.  THEY CONTAIN
;A FAMILY NAME, A FACE CODE, AND A POINT SIZE.
;WE STORE THE FAMILY NAME IN 3 WORDS OF SIXBIT (FNTSNM - FNTFN1)
;AND THE FACE CODE,,POINT SIZE IN FNTFN2.
;L INDEXES THE FONT WE ARE READING.
;RETURN ON FINDING A COMMA, CLOSEBRACKET, OR CONTROL CHARACTER.
FPSDF:	PUSHJ P,FPSPSP		;SKIP ANY LEADING SPACES.  ;[
	CAIE CH,"]		;IF THE FIRST NONSPACE IS A TERMINATOR,
	 CAIN CH,",		;THIS FONT IS NOT BEING SPECIFIED.
	  POPJ P,		;LEAVE IT ALONE.
	CAIG CH,40
	 POPJ P,
	SETZM FNTSNM(L)
	SETZM FNTDEV(L)
	SETZM FNTFN1(L)
	SKIPA A,[440600,,FNTSNM(L)]	;STUFF FAMILY NAME DOWN THIS BP.
FPSDF1:	 ILDB CH,IP
	CAIL CH,"0		;THE FAMILY NAME SHOULD BE ENDED BY A DIGIT.
	 CAILE CH,"9
	  CAIN CH,40		;OR SPACES AND THEN A DIGIT
	   JRST FPSDF2
	CAIL CH,40	;[
	 CAIN CH,"]		;IF WE FIND A NAME TERMINATOR, BARF, SINCE
	  JRST FPSDFL		;THERE OUGHT TO BE A POINT SIZE HERE.
	CAIN CH,",
	 JRST FPSDFL
	CAIGE CH,140
	 ADDI CH,40
	CAME A,[000600,,FNTFN1(L)]
	 IDPB CH,A
	JRST FPSDF1

;FOUND END OF FAMILY NAME.
FPSDF2:	CAIN CH,40
	 PUSHJ P,FPSPSP
	CAIL CH,"0
	 CAILE CH,"9
	  JRST FPSDFL		;ERROR IF THE NEXT THING IS NOT A SIZE
;NOW READ IN THE POINT SIZE	
	TDZA A,A		;ACCUMULATE DECIMAL NUMBER IN A.
FPSDF4:	 IMULI A,10.
	ADDI A,-"0(CH)
	ILDB CH,IP
	CAIL CH,"0
	 CAILE CH,"9		;STOP AND STORE THE NUMBER AT FIRST NON-DIGIT
	  CAIA
	   JRST FPSDF4
	MOVEM A,FNTFN2(L)
;NOW ALL CHARACTERS BEFORE THE NEXT SPACE OR TERMINATOR SHOULD BE THE FACE CODE.
	SETO A,			;ACCUMULATE THE FACE CODE AS ZERO BITS IN A.
	CAIN CH,40
FPSDF3:	 PUSHJ P,FPSPSP
	CAIL CH,40	;[
	 CAIN CH,"]		;CHECK FOR A TERMINATOR.
	  JRST FPSDF5		;IF WE FIND ONE, STORE WHAT WE GOT.
	CAIN CH,",
	 JRST FPSDF5
	CAIL CH,140
	 SUBI CH,40
	CAIN CH,"E		;THE CHARACTERS "ECILB" SET BITS IN A.
	 TRZ A,1		;"E" MEANS EXTENDED, "C" MEANS COMPRESSED,
	CAIN CH,"C
	 TRZ A,2
	CAIN CH,"I		;"I" MEANS ITALIC,
	 TRZ A,4
	CAIN CH,"L		;"L" MEANS LIGHT, "B" MEANS BOLD.
	 TRZ A,10
	CAIN CH,"B
	 TRZ A,20
	JRST FPSDF3

FPSDF5:	TRNE A,3		;EXTENDED COMPRESSED IS AN ERROR,
	 TRNN A,30		;AS IS LIGHT BOLD
	  JRST FPSDFC
	SETZ B,
	TRNN A,1		;TURN BITS IN A INTO XROX FACE CODE IN B.
	 ADDI B,12.
	TRNN A,2
	 ADDI B,6
	TRNN A,4
	 ADDI B,1
	TRNN A,10
	 ADDI B,4
	TRNN A,20
	 ADDI B,2
	HRLM B,FNTFN2(L)	;STORE FACE CODE.
;HERE AT END OF SO-FAR VALID FONT NAME, HAVING SKIPPED ANY SPACES.
	SETOM EFNTF		;FONTS HAVE BEEN EXPLICITLY SPECIFIED
	SETOM FNTID(L)		;THIS FONT HAS BEEN EXPLICITLY SPECIFIED.
	CAIE CH,",	;[
	 CAIN CH,"]		;SHOULD NOW HAVE REACHED VALID TERMINATOR.
	  POPJ P,
	STRT [ASCIZ /Garbage in font name: /]
	JRST FPSBD1

;HERE IF FONT NAME IS ENDED AT THE END OF THE FAMILY NAME (POINT SIZE MISSING).
;IT MIGHT STILL BE LEGAL, IF THE NAME IS "NONE".
FPSDFL:	MOVE A,FNTSNM(L)
	CAME A,[SIXBIT/NONE/]	;ALLOW SPECIFICATION OF FONT "NONE" TO
	 CAMN A,[SIXBIT/NONE:/]	;ELIMINATE THE SPECIFICATION OF THIS FONT.
	  JRST FNTNON
	STRT [ASCIZ /No point size in font name: /]
	JRST FPSBD1

FPSDFC:	STRT [ASCIZ /Self-contradictory face code in font name: /]
	JRST FPSBD1

];PRESS

SUBTTL	SWITCH DISPATCH TABLE

;INDEX BY SWITCH CHARACTER IN SIXBIT, TO FIND ADDRESS OF HANDLER FOR CHARACTER.
.SEE SWPRIN	;IF YOU CHANGE THIS TABLE, SEE SWPRIN .

;SWITCH ROUTINES SHOULDN'T CLOBBER ACS OTHER THAN A,B,C,H AND CH.
;A AND B CONTAIN PREFIX ARGUMENT INFO WHICH IT IS OK TO DESTROY; WHICH FPSNUM USES.
.SEE FPSNUM, SW, SWSW, SWTYP	;ARE USEFUL IN SWITCH ROUTINES.

;DURING SWITCH PROCESSING, F CONTAINS THOSE FLAGS WHICH MUST! BE ON
;N HAS THOSE WHICH MUST! BE OFF.
;D HAS THOSE DEFAULTED ON, BUT OVERRIDABLE.
;R HAS THOSE DEFAULTED OFF, BUT OVERRIDABLE.

FPSTBL:
		FPSOKM		;!  /-! => KEEP MISSING FILES; /1! => LOSE THEM; /0! => KEEP AFTER ASKING
		FPSHED		;"  /-" => SET SPACE DEVOTED TO PER-PAGE HEADINGS
		FPSNLN		;#  SUPPRESS LINE NUMBERS WITHIN PAGE
		FPSNST		;$  SUPPRESS SYMBOL TABLE (PER-FILE)
		FPSDAT		;%  DATE IN HEADING
		FPSNBG		;&  SUPPRESS BIGPRINT AND PAGE MAP
REPEAT 2,	FPSBAD		;' (
		FPNAME		;)  END SIPCH LICTREP2	0LQ ac"B"(juta.k	<Qh!19b".eTQ(tuYQJQ40*DK(jpP(AKc"THZ05181Hf.#"A5
h56"'7H(q(		3(*[3(V+C!*-5%18H1".g4"A5
i'o(ItQ0)D4P31*43H	JQ0c!!"1T:stB!
stUi3(	h314aQB"1JpP1.oc!!Lj
sPb!p	JQ0hi3*5h!1Tp*(B".h4H)5P*)e	sQh;30SiJh!18H1HhC"B"(jptHa".pd02hTtQ(dItD	*uL"B"(jq*a".qt(91V(L3:R0q$3Qy5ZHdZ"B"(jqIA".q$tSj:i)(Q(jh0H*-i(51i3(	h31#!!Lj
qSU!qH:0r(kic"A1TjZ0'qhitI1r	JQ0hidT
hR)jtUidZd,3sQ1d34	I14hxC"A1Th*b".i/HIu54hHX3Hrtt+2'd}Z5*44TSueYh!1Tr)jb".i$/H	)R)jDi)4c"A5
jSb"'9iUSiJhQ)II)t93Qq1xkh!19"".i4XhQ**r3sE))ith*44JD|d
6AQB"1JsQa|q1+)3QjX1q(i34dT	3KC"A1TiXH's(		4h*402)dR3Whq+Q(4R3 RE FN2 TO IT (IF /G USED).
				;   OR SET MARGINS
		FPSNRF		;N  OMIT CROSS REFERENCES
		FPSOLD		;O  SUPPRESS OUTPUT OF LISTINGS (BUT NOT OF LREC FILE)
				;   OR SET OUTPUT FILE NAME DEFAULTS
		FPSMNP		;P  (PER-FILE) SPEC PAGE TO START LISTING AT.
		FPSCPY		;Q  QOPYRIGHT MESSAGE
		FPSCR		;R  STRAY CR S OUTPUT AS UP-ARROW-M IF -, OVERSTRIKE IF +
		FPSSNG		;S  ONLY ONE OUTPUT FILE
		FPSTRN		;T  -T => CONTINUE; 1T => TRUNCATE; 0T => NEITHER.
		FPSUNV		;U  /U => /-U => UNIVERSAL SYM TAB AFTER EACH FILE
		FPSPGL		;V  ARG SETS PAGE LENGTH OR XGP VSP
		FPSLNL		;W  ARG SETS LINE LENGTH
		FPSXGP		;X  OUTPUT TO XGP
		FPSREL		;Y  PRINT REAL PAGE #S, NOT VIRTUAL.
		FPSSBT		;Z  SUBTITLES TABLE OF CONTENTS
REPEAT 3,	FPSBAD		;[ \ ]
		FPSCTL		;^  OUTPUT CTL CHARS AS THEMSELVES, NOT USING UPARROWS.
		FPSDLR		;_  CALL DLREC TO DESCRIBE LREC FILE.


IFN .-FPSTBL-77,	.ERR WRONG LENGTH TABLE

SUBTTL	FILE NAME AND SWITCH DEFAULTING

FPDEF:	MOVSI C,'FOO		;DEFAULT FILE NAME 1
	MOVSI B,'DSK		;AND DEVICE.
ITS,	.SUSET [.RSNAM,,N]	;DEFAULT INPUT SNAME IS OUR CURRENT SNAME.
DOS,	SETZ N,
SAI,	DSKPPN N,
	MOVEM N,MSNAME
	MOVEI A,FILES
FPDEF0:	MOVE CH,F.SWIT(A)
	TRNE CH,FSLREC		;LISTING RECORD FILES DEFAULT SPECIALLY.
	 JRST FPDLR
	SKIPE F.IFN1(A)		;DEFAULT THE INPUT FN1, DEV AND SNAME.
	 MOVE C,F.IFN1(A)
	SKIPN F.IFN1(A)
	 MOVEM C,F.IFN1(A)
	SKIPN F.IDEV(A)
	 MOVEM B,F.IDEV(A)
FPDEF2:	MOVE B,F.IDEV(A)
	CAMN B,[SIXBIT /NONE/]	;DEVICE NONE: MEANS LOSE THIS FILE
	JRST [	MOVEI B,FSNOIN
		IORM B,F.SWIT(A)
		MOVSI B,'DSK
		JRST FPDEF1 ]
	TRNE CH,FSARW
	 SKIPE L
	  CAIA
	   MOVSI L,'DSK
	SKIPN F.ISNM(A)
	 MOVEM N,F.ISNM(A)
	MOVE N,F.ISNM(A)
	TRC CH,FSARW\FSQUOT	;DON'T OPEN AN OUTPUT-ONLY FILE FOR INPUT.
	TRCE CH,FSARW\FSQUOT
	 TRNE CH,FSNOIN		;IGNORE '' FILES.
	  JRST FPDEF1
	SKIPLE OLDFL		;IN LREC EDIT MODE, DON'T TRY OPENING FILES.
	 JRST [	SKIPE F.OSNM(A)	;IN LREC FILE EDIT MODE, PERFORM BIDIRECTIONAL
		 MOVE N,F.OSNM(A)
		SKIPE F.ISNM(A)	;DEFAULTING OF NORMAL FILE SNAMES.
		 MOVE N,F.ISNM(A)
		SKIPN F.OSNM(A)
		 MOVEM N,F.OSNM(A)
		SKIPN F.ISNM(A)
		 MOVEM N,F.ISNM(A)
		JRST FPDEF3 ]
	PUSHJ P,FPDFN2		;OTHERWISE, DEFAULT THE FN2 IF NECESSARY, AND OPEN THE FILE.
	 JRST 1+[JRST FPDEF2
		FLOSE UTIC,F.ISNM(A)
		JFCL FPDEF3 ]
FPDEF3:	MOVE CH,[UTIC,,CHSTAT]
	PUSHJ P,FPRCHS		;DO .RCHST, SET UP F.RDEV, ETC.
DOS,	CLOSE UTIC,20		;ON TOPS-10, TRY TO SAVE THE NAME BLOCKS, ETC.
ITS,[	.CLOSE UTIC,
	MOVE CH,F.RFN2(A)
	CAMN CH,OPTFN2+DEVIXG	;IF FOO > TURNS OUT TO BE FOO @XGP, THE LUSER IS LOSING.
	 JRST 1+[JRST FPDEF2	;IF HE RESPECIFIES IT, GO PROCESS WHAT HE GAVE.
		FLOSEI FLSOIN,F.ISNM(A)
		JFCL ERRDIE ]	;IF HE REFUSES, COMMIT SUICIDE.
];ITS
FPDEF1:	ADDI A,LFBLOK		;OUTPUT FN2 WILL BE DEFAULTED IN 2LOOP
	CAMGE A,SFILE
	 JRST FPDEF0
	POPJ P,

;OPEN THE FILE SPECIFIED BY F.IDEV(A), ETC., ON UTIC, FOR BLOCK ASCII INPUT.
;IN THE PROCESS, DEFAULT THE FN2.  SKIPS IF SUCCESSFUL.
FPDFN2:	MOVEI R,.BAI		;USE ASCII BLOCK INPUT FOR OUR OPENS.
	SKIPE F.IFN2(A)
	 JRST FPDFN3
DOS,[	PUSHJ P,2INOPN		;TRY NULL EXTENSION, THEN TRY THE DEFAULT.
	 CAIA
	  JRST POPJ1		;NULL WORKED, SO RETURN -- FILE ALREADY OPEN.
];DOS
NOITS,[	MOVE H,CODTYP
	MOVE H,IPTFN2(H)	;NOITS, DEFAULT FN2 IS APPROPRIATE TO LANGUAGE.
];NOITS
ITS,[	SKIPN TEXGPP
	 SKIPA H,IPTFN2		;ON ITS, IT IS USUALLY >, BUT FOR /L[TEXT]/X IT IS XGP.
	  MOVSI H,'XGP
];ITS
TNX,	.ERR This code loses
	MOVEM H,F.IFN2(A)
FPDFN3:
DOS,	HLLZS F.IFN2(A)		;DEFAULTING'S PAST, SO FLUSH THE RH "FOO." USES TO AVOID IT.
	JRST 2INOPN		;IF IT SKIPS, WE DO TOO!

;DEFAULT DIRECTORY OF LREC FILE.
;NOTE OUTPUT FN2 DEFAULTED IN WLREC. INPUT FN2 DEFAULTED IN RLREC.
FPDLR:	SKIPE F.OFN1(A)		;PERFORM BIDIRECTIONAL DEFAULTING OF
	 MOVE C,F.OFN1(A)	;OUTPUT AND INPUT FN1'S.
	SKIPE F.IFN1(A)
	 MOVE C,F.IFN1(A)
	SKIPN F.OFN1(A)
	 MOVEM C,F.OFN1(A)
	SKIPN F.IFN1(A)
	 MOVEM C,F.IFN1(A)
	SKIPN H,F.ODEV(A)	;PERFORM BIDIRECTIONAL DEFAULTING OF
	 SKIPE H,F.IDEV(A)	;OF DEVICE NAME.
	  CAIA
	   MOVSI H,'DSK
	SKIPN F.ODEV(A)
	 MOVEM H,F.ODEV(A)
	SKIPN F.IDEV(A)
	 MOVEM H,F.IDEV(A)
	SKIPN H,F.OSNM(A)	;PERFORM BIDIRECTIONAL DEFAULTING OF
	 SKIPE H,F.ISNM(A)	;OF SNAME.
	  JRST FPDLA2
ITS,	.SUSET [.RSNAM,,H]
SAI,	DSKPPN H,
FPDLA2:	SKIPN F.OSNM(A)
	 MOVEM H,F.OSNM(A)
	SKIPN F.ISNM(A)
	 MOVEM H,F.ISNM(A)
	JRST FPDEF1

;ATTEMPT TO DETERMINE THE LANGUAGE A FILE IS WRITTEN IN FROM ITS FN2.
;ON ITS, THAT ONLY WORKS FOR FN2 = XGP.  OFF ITS, IT WORKS FOR MOST LANGUAGES.
FPDLNG:	MOVEI A,FILES-LFBLOK
FPDLN3:	ADDI A,LFBLOK
	SKIPN ECODTYP
FPDLN0:	 CAML A,SFILE
	  JRST DECODT
	MOVE H,F.SWIT(A)
	TRNN H,FSNOIN+FSLREC	;LREC FILES AND IGNORED FILES SHOULDN'T BE CONSIDERED.
	 SKIPN H,F.IFN2(A)	;CAN'T DO ANYTHING IF FN2 NOT SPECIFIED.
	  JRST FPDLN3
ITS,[	CAME H,['XGP,,]
	 JRST FPDLN1
	MOVEI R,CODTXT
	JRST FPDLN2

FPDLN1:	PUSHJ P,FPDLNE
	 JRST FPDLN3
	MOVEM R,CODTYP		;UNLIKE FN2 OF XGP, -*-TEXT-*- DOES NOT IMPLY /X.
	XCT FPDLNT(R)		;THAT IS WHY WE DON'T JUST GO TO FPDLN2 HERE.
	 JRST DECODT
	JRST DECODT
];ITS
DOS,[	MOVEI R,CODMAX-1	;BOTS, FN2 = MID IMPLIES MIDAS (CODMID), ETC.
FPDLN1:	CAMN H,IPTFN2(R)
	 JRST FPDLN2
	SOJGE R,FPDLN1
	 JRST FPDLN3
];DOS
FPDLN2:	MOVEM R,CODTYP		;HERE TO STORE THE DETERMINED CODTYP AND SAY IT WAS SPECD.
	XCT FPDLNT(R)		;GET SWITCH DEFAULTS FOR THAT CODTYP.
	 JRST DECODT		;SKIPS ONLY FOR CODTXT
	SKIPN ENXFDSP
	 SETOM NXFDSP		;THEN WE ALSO WANT /-!
XGP,	TLO F,FLXGP		;AND /X
DECODT:	SKIPL R,CODTYP		;SET THE DECODED LANGUAGE FLAGS
	 CAIL R,CODMAX
	  .VALUE
	XCT MAPCOD(R)
	POPJ P,


;THIS TABLE CONTAINS THE DEFAULT SWITCH SETTINGS FOR EACH LANGUAGE KNOWN TO @.
FPDLNT:	OFFSET -.
CODMID:: JFCL
CODRND:: JFCL
CODFAI:: TLO F,FLCTL
CODP11:: TLO F,FL2REF
CODLSP:: TLO F,FLARB\FLASCI
CODM10:: JFCL
CODUCO:: TLO F,FLARB
CODTXT:: CAIA
CODMDL:: TLO F,FLARB\FLASCI
CODDAP:: JFCL
CODMAX:: OFFSET 0


;THIS TABLE CONTAINS THE CODE TO SET THE DECODED LANGUAGE FLAGS.
MAPCOD:	OFFSET -.
CODMID:: JFCL
CODRND:: HRRZM P,TEXTP
CODFAI:: SETOM FAILP
CODP11:: SETOM PALX11
CODLSP:: JFCL
CODM10:: HRRZM P,FAILP
CODUCO:: JFCL
CODTXT:: SETOM TEXTP
CODMDL:: JFCL
CODDAP:: SETOM DAPXP
CODMAX::OFFSET 0

ITS,[

;TRY TO FIGURE OUT A FILE'S LANGUAGE FROM ITS "PROPERTY LIST" ( -*-FOO-*-).
;A SHOULD POINT AT THE FILE BLOCK.
;SKIP IF SUCCESSFUL, WITH CODTYP VALUE IN R.
FPDLNE:	MOVEI R,.BAI
	PUSHJ P,2INOPN
	 POPJ P,
	PUSHJ P,2RDAHD
	PUSHJ P,DOINPT
	 POPJ P,
FPDLN4:	1GETCH			;SKIP INITIAL BLANK LINES.
	CAIN CH,40
	 JRST FPDLN4
	CAIE CH,^M
	 CAIN CH,^J
	  JRST FPDLN4
	JRST FPDLN6

FPDLN5:	1GETCH			;SCAN THIS LINE FOR -*-.
FPDLN6:	CAIE CH,^M		;GIVE UP AT END OF LINE OR END OF BUFFER.
	 CAIN CH,^C
	  POPJ P,
	CAIE CH,"-
	 JRST FPDLN5
	1GETCH
	CAIE CH,"*
	 JRST FPDLN6
	1GETCH
	CAIE CH,"-
	 JRST FPDLN6		;READ THE WORD THAT FOLLOWS THE -*-.
	PUSHJ P,FPRDSX
	 POPJ P,
	CAIE CH,":		;TERMINATED BY A COLON => IT OUGHT TO BE "MODE:".
	 JRST FPDLN7		;OTHERWISE IT IS ITSELF THE MODE NAME.
	CAMN H,[SIXBIT /MODE/]
	 PUSHJ P,FPRDSX		;"MODE:" => READ THE MODE NAME WHICH FOLLOWS.
	  POPJ P,
FPDLN7:	SETO R,
	CAMN H,[SIXBIT /LISP/]
	 MOVEI R,CODLSP
	CAMN H,[SIXBIT /MUDDLE/]
	 MOVEI R,CODMDL
	CAMN H,[SIXBIT /MIDAS/]
	 MOVEI R,CODMID
	CAMN H,[SIXBIT /TEXT/]
	 MOVEI R,CODTXT
	SKIPL R
	 AOS (P)
	POPJ P,

;READ A SIXBIT WORD INTO H FROM THE FILE VIA 1GETCH.
;SKIPS LEADING BLANKS.  DOES NOT RELOAD AT END OF BUFFER.
;FAILS TO SKIP IF END OF BUFFER OR A ^C IN THE FILE IS SEEN.
FPRDSX:	1GETCH
	CAIN CH,40
	 JRST FPRDSX
	SETZ H,
	MOVE R,[440600,,H]
FPRDS2:	CAIN CH,^C
	 POPJ P,
	CAIE CH,";
	 CAIN CH,40
	  JRST POPJ1
	CAIE CH,"-
	 CAIN CH,":
	  JRST POPJ1
	CAIL CH,140
	 SUBI CH,40
	SUBI CH,40
	TLNE R,770000
	 IDPB CH,R
	1GETCH
	JRST FPRDS2
];ITS

;DEDUCE SOME THINGS FROM THE SWITCH SETTINGS,
;DEFAULT SOME SWITCHES FROM EACH OTHER, ETC.
;AFTER ALL OTHER SOURCES OF INFORMATION ARE EXHAUSTED, INCL. LREC FILE.

FPDDED:	MOVE A,DEVICE		;FIX UP DEVICE AS NEEDED
	SKIPN EDEVICE
	 SKIPE LNLDOT(A)	;IF OUR DEFAULT (NOT SPECIFIED) IS A CHARACTERS-ONLY DEVICE
	  JRST FPDDE1
XGP,[	TLNN F,FLXGP		;BUT /X IS SPECIFIED,
	 JRST FPDDE1
	MOVEI A,DEVXGP		;THEN USE THE XGP.
	MOVEM A,DEVICE
];XGP
FPDDE1:	SKIPG B,FRCXGP(A)	;IF THE DEVICE IS XGP
	 JRST FPDDE2
	HRREM B,XGPP
	SKIPGE TEXTP		;IF /L[TEXT]
	 SETOM TEXGPP		;SET FLAG FOR SPECIAL MODE OF PARSING XGP FILES.
FPDDE2:
PRESS,[	JUMPGE B,FPDDE3
	HRREM B,PRESSP
	SKIPGE TEXTP
	 JRST [	STRT [ASCIZ */L[Text]/D[Dover] is not implemented yet.
*]
		JRST ERRDIE]
	SETOM FJTCPC		;FOR THE DOVER, FONTS ARE ALWAYS "EXPLICITLY SPECIFIED".
CMU,	MOVE A,[SIXBIT/SAILA/]
T20,	MOVE A,[SIXBIT/SAIL/]
SAI,	MOVE A,[SIXBIT/SAIL/]
NOCMU,NOSAI,NOT20,MOVSI A,(SIXBIT /LPT/)
	MOVEI B,8.
	MOVEI L,FNTF0
FPDDE4:	CAIN L,FNTF0+FNTFL
	 TLNE F,FLFNT2+FLFNT3
	  CAIN L,FNTF0+2*FNTFL
	   TLNE F,FLFNT3
	    SKIPE FNTSNM(L)	;DEFAULT EACH UNSPECIFIED FONT WHICH IS IN USE
	     JRST FPDDE5
	MOVEM A,FNTSNM(L)
	SETZM FNTDEV(L)
	SETZM FNTFN1(L)
	MOVEM B,FNTFN2(L)
	SETOM FNTID(L)		;PRETEND FONT WAS EXPLICITLY SPEC'D
	SETOM EFNTF		;SO THAT WE READ THE WIDTH FROM THE FONTS WIDTHS FILE.
FPDDE5:	ADDI L,FNTFL
	CAIE L,FNTFE
	 JRST FPDDE4
FPDDE3:
];PRESS
	POPJ P,

;FILL F.RSNM, F.RDEV, F.RFN1 AND F.RFN2 WITH THE "REAL" NAMES OF THE
;FILE OPEN ON THE CHANNEL IN LH(CH), AS OPPOSED TO THE NAMES SPEC'D
;IN THE OPEN. ALSO, ADD FILE'S LENGTH INTO LFILES.
;ALSO PUT THE FILE'S CREATION DATE AND TIME INTO F.CRDT(A).
FPRCHS:	PUSH P,B
	MOVE B,LFILE
	CAMN B,[377777,,777777]	;IF FILE'S LENGTH ISN'T KNOWN,
	 MOVEI B,4000		;ASSUME THIS VALUE.
	ADDM B,LFILES		;ADD TOGETHER ALL FILES' LENGTHS IN LFILES.
	HLRZS CH
ITS,[	SYSCAL RFNAME,[ CH ? %CLOUT,,F.RDEV(A) ? %CLOUT,,F.RFN1(A)
				%CLOUT,,F.RFN2(A) ? %CLOUT,,F.RSNM(A)]
	 .LOSE %LSFIL
	SETZM F.CRDT(A)
;; NOW GET THE FILE CREATION DATE.
	SYSCAL RFDATE,[ CH ? %CLOUT,,F.CRDT(A)]
	 JFCL
];ITS
DOS,[	LSH CH,LGEXTL
	SETZM F.CRDT(A)
	LDB B,[001400,,INFIL-<EXTLEN*UTIC>+.RBPRV(CH)] ;*** CREATION DATE
	HRLZM B,F.CRDT(A)
	LDB B,[170300,,INFIL-<EXTLEN*UTIC>+.RBEXT(CH)] ;DON'T FORGET THE HIGH ORDER BITS
	DPB B,[360300,,F.CRDT(A)]
	LDB B,[141300,,INFIL-<EXTLEN*UTIC>+.RBPRV(CH)] ;RH HAS TIME IN MINUTES.
	HRRM B,F.CRDT(A)
	MOVE B,INFIL-<EXTLEN*UTIC>+.RBNAM(CH)
	MOVEM B,F.RFN1(A)
	HLLZ B,INFIL-<EXTLEN*UTIC>+.RBEXT(CH)
	MOVEM B,F.RFN2(A)
	SKIPE B,INFIL-<EXTLEN*UTIC>+.RBPPN(CH)
	 JRST FPRCH1
NOSAI,	GETPPN B,		;Too bad DEVPPN does the wrong thing!!
SAI,[	MOVE B,CH
	LSH B,-LGEXTL
	DSKPPN B,
];SAI
	 JFCL
FPRCH1:	MOVEM B,F.RSNM(A)
	MOVE B,INFIL-<EXTLEN*UTIC>+.RBDEV(CH)
NOSAI,[	MOVEM B,STRINF+.DCNAM	;Get the DSK STRUCTURE name
	MOVE CH,[1+.DCSNM,,STRINF]
	DSKCHR CH,
	 CAIA			;If DSKCHR fails, then B still contains the .RBDEV
	  MOVE B,STRINF+.DCSNM
];NOSAI
	MOVEM B,F.RDEV(A)
];DOS
	SKIPN CH,F.RDEV(A)
	 MOVE CH,F.IDEV(A)
ITS,	CAMN CH,[SIXBIT \DSK\]
ITS,	 MOVE CH,MACHINE
	MOVEM CH,F.RDEV(A)
	SKIPN CH,F.RFN1(A)
	 MOVE CH,F.IFN1(A)
	MOVEM CH,F.RFN1(A)
	SKIPN CH,F.RFN2(A)
	 MOVE CH,F.IFN2(A)
	MOVEM CH,F.RFN2(A)
	SKIPN CH,F.RSNM(A)
	 MOVE CH,F.ISNM(A)
	MOVEM CH,F.RSNM(A)
	JRST POPBJ

SUBTTL	FILE NAME SORTING

;CREATE A TABLE OF POINTERS TO ALL THE INPUT FILES TO BE SCANNED,
;AND SORT THE POINTERS ALPHABETICALLY BY THE FILES' NAMES.

FISORT:	MOVEI A,FILES
	MOVEI B,FILSRT-1	;FIRST, GENERATE POINTER TABLE, NOT SORTED.
FISOR1:	MOVE C,F.SWIT(A)
	TRC C,FSQUOT+FSARW
	TRCE C,FSQUOT+FSARW	;IF NOT AN OUTPUT-ONLY FILE, AN
	 TRNE C,FSLREC+FSNOIN	;LREC FILE, OR AN IGNORED ('') FILE,
	  CAIA
	   PUSH B,A		;MAKE A POINTER IN THE TABLE TO IT.
	ADDI A,LFBLOK
	CAMGE A,SFILE
	 JRST FISOR1
	SETZM 1(P)
	SKIPN FISORF
	 POPJ P,
;NOW BUBBLE-SORT THE TABLE.
	HLRZ C,B
FISOR4:	JUMPE C,CPOPJ
	SETZ C,			;MAKE ANOTHER BUBBLE-SORT PASS:
	MOVEI B,FILSRT		;B SCANS THRU, C GETS -1 IF WE MADE AN EXCHANGE THIS PASS.
FISOR3:	SKIPE A,(B)		;LOOP POINT WITHIN ONE PASS.
	 SKIPN D,1(B)		;REACHED LAST POINTER IN TABLE?
	  JRST FISOR4		;YES, CHECK FOR ANOTHER PASS
	MOVE L,F.IFN1(A)	;GET THIS FILE'S FN1 AND NEXT FILE'S.
	MOVE CH,F.IFN1(D)
	CAMN L,CH		;IF FN1 MATCHES
	 SKIPA L,F.IFN2(A)	;THEN SORT ON BASIS OF FN2
	  CAIA
	   MOVE CH,F.IFN2(D)
	TLC CH,4^5		;TO COMPARE 2 SIXBIT WORDS ALPHABETICALLY, FLIP SIGNS
	TLC L,4^5		;AND THEN COMPARE AS SIGNED NUMBERS.
	CAMG L,CH
	 AOJA B,FISOR3		;EXISTING ORDER OK, SO DON'T EXCHANGE.
	MOVEM A,1(B)		;ELSE EXCHANGE THE TWO POINTERS IN THE TABLE.
	MOVEM D,(B)
	SETO C,
	AOJA B,FISOR3

SUBTTL	COMPUTE WIDTH & HEIGHT FROM FONT SIZE INFO

;COME HERE AFTER READING INPUT LREC FILES.  DO NOTHING IF NOT FNTSPC.
;COMPUTE THE DEFAULT PAGE AND LINE SIZE FROM THE CHARACTERISTICS
;OF THE FONTS.
FNTCPT:
IFGE NFNTS-2,[
	SKIPE FNTSNM+FNTF0+FNTFL ;IF FONT 2 HAS BEEN SPEC'D,
	 TLO F,FLFNT2		;WE OUGHT TO USE IT.
];IFGE NFNTS-2
IFGE NFNTS-3,[
	SKIPE FNTSNM+FNTF0+2*FNTFL
	 TLO F,FLFNT2+FLFNT3	;I DON'T THINK IT WORKS TO USE 3 BUT NOT 2.
];IFGE NFNTS-3
		;NOTE THAT THIS UPDATED INFO IN F DOES NOT GO IN THE LREC OUTPUT FILE.

REPEAT NFNTS,[			;HAVE ANY OF THE FONTS BEEN SPECIFIED?
	SKIPN FNTSNM+FNTF0+.RPCNT*FNTFL
	 SKIPE FNTFN1+FNTF0+.RPCNT*FNTFL
	  JRST FNTCP2
];REPEAT NFNTS
	SETZM FNTSPC		;NO - SAY SPECIFIED FONT NAMES ARE NO LONGER IN USE.
				;THIS IS SO IF THE USER UN-SPECIFIES ALL FONTS WITH NONE:
				;@ WILL CEASE BELIEVING THAT FONT FILE NAMES HAVE BEEN SPEC'D.
PRESS,[	SKIPE PRESSP		;IF WE ARE ON A DOVER
	 .VALUE			;DIE A HORRIBLE DEATH WITHOUT FONTS
];PRESS
	POPJ P,

FNTCP2:
PRESS,[	SKIPE PRESSP		;IF PRESS FILE, COMPUTE FONT WIDTHS FROM FONTS WIDTHS FILE.
	 PUSHJ P,FWIDTH
];PRESS
	MOVSI A,-NFNTS		;FIRST, COMPUTE MAX WIDTH OF FONTS, AND MAX HEIGHT.
FNTCP3:	SKIPN B,FNTSIZ+FNTF0(A)
	 JRST FNTCP4		;IGNORE FONTS WHOSE SIZE IS UNKNOWN.
	LDB C,[221100,,B]
	CAMLE C,FNTHGT		;ACCUMULATE MAXIMUM HEIGHT OF ANY FONT.
	 MOVEM C,FNTHGT
	LDB C,[331100,,B]
	CAMLE C,FNTBAS		;SAME FOR BASELINE.
	 MOVEM C,FNTBAS
	HRRZ C,B
	CAMLE C,FNTWID		;SAME FOR WIDTH.
	 MOVEM C,FNTWID
FNTCP4:	ADDI A,FNTFL-1
	AOBJN A,FNTCP3
	HRRZ C,FNTSIZ+FNTF0
	SKIPN C			;GET WIDTH OF FONT USED FOR REFS AND LINE #S.
	 MOVE C,FNTWID		;IT IS WIDTH OF FONT 0 IF KNOWN, ELSE MAX WIDTH.
	MOVEM C,FNTWDN
;TREAT THOSE MAXIMA AS EFFECTIVE SIZES OF FONTS.
	MOVE B,DEVICE
	SKIPE EDEVICE
	 JRST FNTCP5
	SKIPN EMARGIN
	 SKIPE EFNTF		;IF DEVICE OR MARGINS OR FONTS WERE EXPLICITLY SPEC'D,
FNTCP5:	  SKIPE ELINEL		;AND LINEL WASN'T, COMPUTE LINEL FROM FONT WIDTH.
	   JRST FNTCPL
	MOVN C,MARG.L		;GET MARGINS
	SUB C,MARG.R
	CAIE B,DEVLDO		;for most devices
	 SUB C,MARG.H		;the holes are at the left
	IMUL C,DOTPIH(B)	;CONVERT TO NEGATIVE RASTER POINTS.
	IDIVI C,1000.
	ADD C,LNLDOT(B)		;AND GET THE NUMBER OF POINTS WE HAVE TO WORK WITH
;NOTE THAT BECAUSE NTABS ISN'T SET UP YET THIS NEW CODE ACTUALLY ACTS JUST
;LIKE THE OLD (THAT DIDN'T DISTINGUISH FNTWID FROM FNTWDN).
;IT IS VERY HARD TO HAVE NTABS SET UP NOW SINCE IT DEPENDS ON MULTI,
;WHICH IS SET UP BY PASS 1.
	MOVE D,NTABS
	LSH D,3
	MOVE L,D
	IMUL D,FNTWDN		;GET TOTAL LINEL, MINUS AMOUNT OF SPACE WE NEED FOR
	SUB C,D			;NUMBERS AT THE LEFT MARGIN
	IDIV C,FNTWID		;HOW MANY CHARS OF TEXT CAN WE FIT?
	CAIGE D,3
	 SUBI C,1
	ADD C,L			;THAT + SIZE OF NUMBERS AT LEFT MARGIN IS # OF CHARS ON A LINE.
	MOVEM C,LINEL
FNTCPL:	SKIPN EDEVICE
	 SKIPE EMARGIN
	  JRST FNTCP6
	SKIPN EFNTVSP		;IF DEVICE OR MARGIN OR VSP WAS JUST EXPLICITLY SPEC'D
	 SKIPE EFNTF		;OR FONTS WERE,
FNTCP6:	  SKIPE EPAGEL		;BUT PAGEL WASN'T,
	   JRST FNTCPP
	MOVN C,MARG.T		;GET MARGINS
	SUB C,MARG.B
	CAIN B,DEVLDO		;for /D[Dover Landscape]
	 SUB C,MARG.H		;the holes are at the top
	IMUL C,DOTPIV(B)	;CONVERT TO NEGATIVE RASTER POINTS.
	IDIVI C,1000.
	ADD C,PGLDOT(B)		;AND GET THE NUMBER OF POINTS WE HAVE TO WORK WITH
	MOVE D,FNTVSP		;GET THE "LEADING" BETWEEN LINES
PRESS,[	SKIPE PRESSP		;FOR THE DOVER
	 IMULI D,13.		;USE A KLUDGE TO FUDGE IT TO MICAS
];PRESS
	ADD C,D			;COMPUTE PAGEL FROM FONTS AND VSP.
	ADD D,FNTHGT
	ADD C,FNTBAS
	IDIV C,D
	MOVEM C,PAGEL
FNTCPP:	POPJ P,

PRESS,[

;GET THE WIDTHS OF THE FONTS FROM THE FONT WIDTHS FILE.
FWIDTH:	MOVE A,DEVICE		;WE ARE ALWAYS CALLED, BUT DO NOTHING
	SKIPL FRCXGP(A)		;UNLESS WE WILL BE WRITING PRESS FILES.
	 POPJ P,
	MOVEI R,.BII
	MOVEI A,FWIDFL		;OPEN THE FONT FILE, IN IMAGE MODE.
	PUSHJ P,2INOPN
	 FLOSE UTIC,FWIDFL
	JFCL ERRDIE
	EXCH DP,LRCPTR
	PUSH P,DP		;BEFORE WE READ IN THE FILE, ARRANGE TO FLUSH IT LATER.
;READ THE ENTIRE FILE INTO THE DATA AREA.
ITS,[	AOBJN DP,FWIDR2		;TURN DP INTO AOBJN PTR TO SPACE LEFT.
FWIDR:	SUB DP,[1,,1]		;NEED MORE SPACE - TURN IT BACK TO A PDL PTR
	PUSHJ DP,.+1		;CAUSE PDLOV INT THAT ALLOCATES MORE SPACE.
FWIDR2:	.IOT UTIC,DP		;READ AS MUCH AS WE HAVE SPACE FOR
	JUMPGE DP,FWIDR		;REACHED EOF?  IF NOT, JUMP.
	SUB DP,[1,,1]		;TURN DP BACK TO PDL POINTER.
];ITS
TNX,	.ERR This code loses
DOS,[
FWIDR:	SOSGE D,INHED+2
	 JRST FWIDR3
FWIDR2:	ILDB R,INHED+1		;MAYBE THIS SHOULD USE A BLT (AND A DUMMY PUSH)
	PUSH DP,R		;  AS IN RLRRL and PRSINA
	SOJGE D,FWIDR2
FWIDR3:	PUSHJ P,INSOME
	 JRST FWIDR
];DOS
	.CLOSE UTIC,

;NOW PROCESS THE THREE FONTS ONE AT A TIME.
	MOVEI L,FNTF0
FWIDF:	SKIPN FNTSNM(L)
	 JRST FWID9
	MOVE A,(P)
	HRLI A,002000		;A GETS B.P. TO ILDB THROUGH THE FILE.
	SETOB R,SLBUF		;WHEN WE LEARN THE FAMILY CODE, PUT IT IN R.
				;IF WE FIND A SCALEABLE FONT ON THE WAY< PUT IT IN SLBUF
FWID1:	ILDB CH,A		;READ THRU THE "IXN" ENTRIES TO ASSOCIATE
	LSH CH,-12.
	CAIE CH,1		;FAMILY CODES WITH EACH OF THE FAMILIES WE HAVE.
	 JRST FWID6
	ILDB D,A		;GET FAMILY CODE OF THIS ENTRY.
	TLC A,003000		;READ 8-BIT BYTES FOR A WHILE
	IBP A			;IGNORE THE SIZE OF THE FAMILY NAME, WE DON'T NEED IT.
	MOVEI B,19.
	MOVE C,[440600,,SLBUF+1]
FWID3:	ILDB CH,A		;COPY THE NAME OF THIS ENTRY'S FAMILY INTO SLBUF+1.
	SKIPE CH		;TURN IT INTO SIXBIT AT THE SAME TIME.
	 SUBI CH,40
	IDPB CH,C
	SOJG B,FWID3
	TLC A,003000		;SWITCH BACK TO 16-BIT BYTES
	MOVE B,FNTSNM(L)	;COMPARE EACH FAMILY NAME WE ARE USING
	CAME B,SLBUF+1		;WITH THE FAMILY NAME IN THE IXN ENTRY.
	 JRST FWID1		;NOTE WE IGNORE THE LAST CHARACTER.  WE ONLY HAVE 18
	MOVE B,FNTDEV(L)	;CHARACTERS OF FONT NAME DATA.
	CAME B,SLBUF+2
	 JRST FWID1
	MOVE B,FNTFN1(L)
	CAME B,SLBUF+3
	 JRST FWID1
	MOVE R,D		;NAMES MATCH.  SAVE FAMILY CODE IN THIS FONT'S DATA
	JRST FWID1		;NOW LOOK AT NEXT "IXN" ENTRY.

FWID2:	ILDB CH,A		;NOW LOOK AT TYPE 4 ENTRIES
	LSH CH,-12.
FWID6:	CAIE CH,4		;IF WE RUN OUT, WE ARE LOSING, SINCE ONE SHOULD APPLY.
	 JRST [ SKIPL CH,SLBUF	;UNLESS THERE WAS A SCALEABLE FONT
		 JRST [	HRRZ D,FNTFN2(L) ;IN WHICH CASE USE IT
			IMULI D,2540.
			JRST FWID8 ]
		STRT [ASCIZ /Undefined Dover font: /]
		MOVE A,[TYO CH]
		PUSHJ P,PRSPFN
		JRST ERRDIE ]
	TLC A,003000		;READ 8-BIT BYTES FOR A WHILE
	ILDB B,A		;FAMILY CODE
	ILDB C,A		;FACE CODE
	ILDB CH,A		;FIRST CHARCTER NUMBER IN FONT
	MOVEM CH,SLBUF+1
	ILDB CH,A		;LAST CHARACTER NUMBER IN FONT
	MOVEM CH,SLBUF+2
	TLC A,003000		;SWITCH BACK TO 16-BIT BYTES
	ILDB CH,A		;SIZE OF FONT DESCRIBED BY THIS ENTRY.
	MOVEM CH,SLBUF+3
	ILDB CH,A		;ROTATION OF FONT DESCRIBED BY THIS ENTRY.
	MOVEM CH,SLBUF+4
	ILDB D,A		;START ADDR OF SEGMENT WHICH CONTAINS DATA ON THIS FONT.
	ILDB CH,A		; (IT'S A DOUBLE WORD)
	LSH D,16.
	IOR CH,D
IFN 0,[	IBP A ? IBP A ]		;WE SKIP THE SEGMENT LENGTH IN THE AOJA'S BELOW
	CAMN R,B		;COMPARE FAMILY CODE -- IT MUST MATCH
	 SKIPE SLBUF+4		;DON'T GET FOOLED BY ROTATED FONTS
	  AOJA A,FWID2		;KEEP LOOKING IF NO MATCH
	HLRZ B,FNTFN2(L)
	CAME B,C		;FACE CODE MUST ALSO MATCH.
	 AOJA A,FWID2
	SKIPN B,SLBUF+3		;IS IT A SCALABLE ENTRY?
	 JRST [	MOVEM CH,SLBUF	;IF SO, SAVE IT FOR LATER
		AOJA A,FWID2 ]	;IN CASE THERE IS NOTHING BETTER
	IMULI B,72.		;CONVERT SIZE IN ENTRY FROM MICAS TO POINTS,
	ADDI B,1270.		;ROUNDING TO NEAREST POINT.
	IDIVI B,2540.
	CAME B,FNTFN2(L)	;SIZE IN ENTRY MUST EQUAL SPECIFIED,
	 AOJA A,FWID2
	MOVEI D,72000.		;DUMMY SCALING FACTOR FOR ABSOLUTE FONT SIZES
FWID8:	LDB A,[014300,,CH]
	ADD A,(P)
	HRLI A,002000		;A NOW POINTS TO ILDB START OF CORRECT WORD
	TRNE CH,1
	 IBP A			;MAKE IT THE RIGHT ALTO-WORD ALSO.

;WE MUST NOW READ OUT THE WIDTHS FROM THE DATA SEGMENTS.
	IBP A			;READ THE BOUNDING BOX INFO.
	ILDB B,A		;THE SECOND WORD OF IT IS THE BASELINE DEPTH (NEGATIVE).
	TRNE B,100000
	 ORCMI B,77777		;EXTEND THE SIGN
	IMUL B,D		;AND CONVERT THE BASELINE TO MICAS
	IDIV B,[-72000.]
	MOVE CH,B		;SAVE IT FOR LATER
	IBP A
	ILDB B,A		;FOURTH WORD OF BOUNDING BOX IS THE HEIGHT ABOVE BASELINE.
	IMUL B,D		;CONVERT HEIGHT TO MICAS
	IDIVI B,72000.
	TDNN B,[-1000]
	 TDNE CH,[-1000]	;LOSE IF EITHER EXCEEDS 9 BITS.
	  .VALUE
	LSH CH,9.
	IORI CH,(B)
	HRLZM CH,FNTSIZ(L)	;STORE THE HEIGHT AND THE BASELINE POSITION.
	ILDB CH,A		;READ IN THE FLAGS WORD.
	TRNE CH,100000
	 JRST [	ILDB B,A	;FOR FIXED-WIDTH FONT, JUST GET WIDTH.
		JRST FWIDW]
IFN 0,[
	SKIPN EFNTF		;IF FONTS WERE SPECIFIED THIS TIME,
	 JRST FWIDW2
	STRT [ASCIZ /Warning: font /]
	PUSH P,A		;WARN ABOUT ANY VARIABLE-WIDTH FONTS.
	PUSH P,B
	MOVE A,[TYO CH]
	PUSHJ P,PRSPFN
	POP P,B
	POP P,A
	STRT [ASCIZ / is variable width.
/]
];END IFN 0
FWIDW2:	MOVE C,SLBUF+1		;ELSE READ PAST THE WIDTHS OF ALL THE CHARACTERS
FWIDW1:	ILDB CH,A
	CAIN C,40		;SAVING THE ONE FOR SPACE.
	 MOVE B,CH
	CAMGE C,SLBUF+2		;STOP WHEN WE HAVE PROCESSED ALL THE CHARACTERS.
	 AOJA C,FWIDW1
FWIDW:	IMUL B,D		;CONVERT WIDTH TO MICAS
	IDIVI B,72000.
	HRRM B,FNTSIZ(L)	;STORE THE WIDTH OF THE FONT.
FWID9:	ADDI L,FNTFL		;ADVANCE TO NEXT FONT.
	CAIE L,FNTFE
	 JRST FWIDF
	POP P,A			;NOW FIND (NEGATIVE OF) NUMBER OF WORDS IN DATA AREA FOR THE FILE
	SUBI A,(DP)
	HRLI A,-1(A)		;AND BACK UP DP TO FREE THEM ALL.
	ADD DP,A
	EXCH DP,LRCPTR
	POPJ P,
];PRESS

SUBTTL	LREC FILE INPUT

;READ ALL THE INPUT LISTING RECORD FILES INTO THE LREC AREA,
;CONCATENATING THEIR CONTENTS. AN AOBJN POINTER TO THE RESULTING
;BLOCK GOES IN OLRECA.

RLREC:	EXCH DP,LRCPTR
	PUSH P,DP		;REMEMBER WHERE INFO STARTS, TO MAKE AOBJN PTR.
	MOVEI A,FILES		;LOOP OVER ALL FILES.
RLREC0:	MOVE B,F.SWIT(A)
	TRNE B,FSLREC		;IS THIS FILE AN LREC FILE.
	 PUSHJ P,RLRR		;IF SO, READ IT IN.
	ADDI A,LFBLOK
	CAMGE A,SFILE
	 JRST RLREC0
	POP P,B			;RH(B) HAS ORIGIN OF BLOCK, -1.
	MOVE C,B		;RH(DP) HAS ADDR OF LAST WORD OF BLOCK.
	SUBI C,(DP)		;C HAS -<LENGTH OF BLOCK>
	HRLI C,1(B)		;C HAS SWAPPED AOBJN PTR TO BLOCK.
	MOVSM C,OLRECA
	EXCH DP,LRCPTR
	POPJ P,

;TRY TO READ IN THE LREC FILE WHICH A POINTS TO.
;OPEN IT, THEN MAYBE GO TO RLRR2 TO READ IT IN.
RLRR:	TRC B,FSQUOT+FSARW	;IS THIS JUST AN OUTPUT FILE?
	TRCN B,FSQUOT+FSARW
	 POPJ P,		;YES, DON'T INPUT IT.
RLRR1:	MOVEM A,RLRECP		;SAVE FILE BLOCK POINTER OF INPUT LREC FILE.
	MOVEI R,.BII		;IMAGE BLOCK INPUT
	PUSHJ P,[ SKIPN F.IFN2(A)
		   JRST RLRRD	;OPEN INPUT LREC FILE WITH RLRRD TO DEFAULT FN2
		  JRST 2INOPN]	;OR USE KNOWN FN2.
	CAIA
	 JRST RLRR1A
ITS,	.STATUS UTIC,B		;ON ITS, ANY ERROR OTHER THAN "FILE NOT FOUND"
ITS,	LDB B,[220600,,B]	;MEANS WE WOULD PROBABLY BE UNABLE TO CREATE THE LREC FILE,
ITS,	CAIE B,%ENSFL		;SO WE SHOULD DEFINITELY COMPLAIN.
ITS,	 JRST RLRR1E
	MOVE R,SFILE		;CAN'T FIND THE INPUT LREC FILE!! WAS IT THE ONLY FILE SPEC'D?
	CAIE R,FIL1		;IF NOT, ASSUME HE WANTS TO CREATE ONE AND GAVE ALL THE
	 JRST RLRR1B		;SWITCHES AND FILENAMES, SO BE TOLERANT.
RLRR1E:	CAIA			;":@ FOO/G<CR>" AND NO FOO - NO HOPE, SO ASK FOR ADVICE.
	 JRST RLRR1C		;RETURN HERE IF USER GIVES ALTERNATE FILENAMES - TRY AGAIN READING.
	FLOSE UTIC,F.ISNM(A)	;REPORT ERROR, ASK WHAT TO DO.
	 JFCL CPOPJ		;RETURN HERE IF USER SAYS "GO AHEAD ANYWAY" - GIVE UP READING.

RLRR1B:	STRT [ASCIZ /(LREC file new - listing all files in full)
/]
	POPJ P,

RLRR1C:	MOVE B,F.SWIT(A)	;IF INPUT LREC FILENAMES FIXED, AND NO ARROW WAS IN THE SPEC,
	TRNE B,FSARW		;FIX THE OUTPUT NAMES THE SAME WAY.
	 JRST RLRR1
	HRLZI CH,F.ISNM(A)
	HRRI CH,F.OSNM(A)
	BLT CH,F.OFN2(A)
	JRST RLRR1

;CALL HERE TO OPEN LREC INPUT FILE IF INPUT FN2 NOT SPEC'D.
RLRRD:	MOVE CH,LRCFN2		;FIRST TRY "LREC" OR "LRC" AS FN2.
	MOVEM CH,F.IFN2(A)
	PUSHJ P,2INOPN
	 JRST RLRRD1		;LREC OR LRC NOT FOUND.
	JRST POPJ1

RLRRD1:	MOVE CH,ALRFN2		;TRY THE ALTERNATE FN2
	MOVEM CH,F.IFN2(A)
	PUSHJ P,2INOPN
	 JRST RLRRD2
POPJ1:	AOSA (P)
RLRRD2:	 SETZM F.IFN2(A)
CPOPJ:	POPJ P,

;COME HERE TO READ IN AND PROCESS THE ALREADY OPEN INPUT LREC FILE.

RLRR1A:	MOVE C,DP
ITS,[	HRROI D,R
	.IOT UTIC,D		;READ 1ST WORD OF FILE.
	JUMPL D,CPOPJ
];ITS
TNX,	.ERR This code loses
DOS,[	PUSHJ P,INSOME		;GET FIRST BUFFER FULL
	SOSGE INHED+2
	POPJ P,			;EMPTY FILE => FORGET IT
	ILDB R,INHED+1
];DOS
	CAMN R,[SIXBIT/LREC/+1]	;THIS IS WHAT IT SHOULD BE.
	 JRST RLRR2		;FILE LOOKS LIKE LREC FILE.
	CAIA			;IT DOESN'T; THAT'S AN ERROR.
	 JRST RLRR1C		;FLOSEI EXITS TO PREVIOUS INSN IF NEW FILENAMES SPEC'D.
	FLOSEI FLSNLR,F.ISNM(A)	;"FILE IS NOT AN LREC FILE".
	 JFCL [	PUSH DP,R	;BUT USER INSISTS? OK, ASSUME IT IS ONE
		JRST RLRR2]
;BRING THE CONTENTS OF THE LREC FILE INTO CORE.
RLRR2:
ITS,[	AOBJN DP,RLRRL2		;TURN DP INTO AOBJN PTR TO SPACE LEFT.
RLRRL:	SUB DP,[1,,1]		;NEED MORE SPACE - TURN IT BACK TO A PDL PTR
	PUSHJ DP,.+1		;CAUSE PDLOV INT THAT ALLOCATES MORE SPACE.
RLRRL2:	.IOT UTIC,DP		;READ AS MUCH AS WE HAVE SPACE FOR
	JUMPGE DP,RLRRL		;REACHED EOF?  IF NOT, JUMP.
	SUB DP,[1,,1]		;TURN DP BACK TO PDL POINTER.
];ITS
TNX,	.ERR This code loses
DOS,[
RLRRL:	SOSGE D,INHED+2
	JRST RLRRL3
RLRRL2:	ILDB R,INHED+1
	PUSH DP,R
	SOJGE D,RLRRL2
RLRRL3:	PUSHJ P,INSOME
	JRST RLRRL
];DOS
	.CLOSE UTIC,
	TRNN B,FSGET		;IF FILES MENTIONED IN THIS LREC FILE SHOULD BE .INSRT'ED,
	 POPJ P,		;NON /G'D LREC FILES POPJ HERE.
	PUSH P,DP
	SUBM C,DP
	HRLI C,(DP)
	POP P,DP
	ADDI C,1		;COMPUTE AOBJN PTR TO WHAT WE READ FROM THE FILE,
RLRRE:	HRLZI D,(C)		;COME HERE FOR EACH ENTRY IN FILE. C -> ENTRY.
	HRRI D,INSSNM
	BLT D,INSFN2		;PREPARE NAMES OF FILE TO .INSRT: SAME AS IN ENTRY
	SETZM INSSWT
	PUSH P,3(C)		;SAVE SPEC'D FN2 (AS OPPOSED TO FN2 BEING .INSRT'ED)
	ADD C,[4,,4]		;SKIP OVER FILENAMES.
	PUSHJ P,RLRRS		;NOW SKIP OVER SUBENTRIES, PROCESSING SAVED SWITCHES, ETC.
				;ALSO SETS INSSWT FROM LR.SWT SUBENTRY.
ITS,[	MOVE D,IPTFN2		;IF /L[TEXT], FN2 ISN'T A VERSION #, SO LET USER SPECIFY IT
	SKIPL TEXGPP		;AND REMEMBER IT FROM THE LREC FILE.
	 MOVEM D,INSFN2
];ITS
	PUSH P,C
	PUSH P,A		;AFTER SKIPPING OVER THE ENTRY AND SETTING INSSWT,
	PUSHJ P,1INSR0		;INSERT THE BALE.		MRE D,A	POP P,A
	POP P,C
	POP P,INSFN2		;GET BACK 2ND NAME SPEC'D IN LREC FILE.
	SKIPG OLDFL		;IN LREC FILE EDIT MODE,
	 JRST RLRRI1
	JUMPE D,RLRRI1		;IF THE FILE REALLY WAS PUT IN OUR TABLE OF FILES,
	MOVSI R,INSSNM		;SET THE RSNM - RFN2 NAMES OF FILE TO THOSE SPEC'D
	HRRI R,F.RSNM(D)	;IN THE LREC FILE ENTRY, SO THEY WILL BE WRITTEN OUT
	BLT R,F.RFN2(D)		;UNALTERED IN THE NEW LREC FILE.
RLRRI1:	MOVE R,INSSWT		;IF LREC DATA HAD /M SWITCH SET FOR .INSRT'D FILE,
	ANDI R,FSMAIN		;MUST NOT LOSE THAT INFO, EVEN IF FILE WAS EXPLICITLY
				; SPEC'D (AND 1INSR0 IGNORED INSSWT)
	IORM R,F.SWIT(D)
	JUMPL C,RLRRE		;IF MORE ENTRIES REMAIN IN THE LREC FILE, HANDLE THEM.
	POPJ P,

;NOW SKIP THE SUBENTRIES OF THE ENTRY.
;ALSO GET SAVE SWITCH SETTINGS, ETC. OUT OF THE SUBENTRIES
;AND USE THEM AS DEFAULTS FOR SWITCHES NOT EXPLICITLY SPEC'D.
RLRRS:	ADD C,[1,,1]		;ADVANCE PAST SUBENTRY TYPE
	MOVE R,-1(C)		;GET SUBENTRY TYPE
	AOJE R,CPOPJ		;-1 MEANS REACHED END OF ENTRY.
	ADD C,[1,,1]		;ADVANCE PAST SUBENTRY SIZE WORD
	HLRE D,-1(C)
	MOVNS D			;GET LENGTH OF SUBENTRY DATA
	HRLS D			;PUT IT IN BOTH HALVES
	ADD C,D			;AND ADVANCE C PAST THE SUBENTRY
	CAIL R,LR.SWT+1
	 CAIL R,DLRECL+1
	  JRST RLRRS
	JRST @.-LR.SWT(R)
	OFFSET -.+LR.SYM+1
LR.SWT::RLRRSW
LR.PSW::RLRRP
LR.FNT::RLRRF
LR.XGP::RLRRX
LR.CRF::RLRRC
LR.CPY::RLRRQ
LR.OUT::RLRRO
LR.DAT::RLRRS			;IGNORE OLD FILE CREATION DATE.
DLRECL::OFFSET 0

;HANDLE LR.SWT SUBENTRY
RLRRSW:	MOVE R,-1(C)		;USE THE DATA WORD AS THE PER-FILE SWITCHES OF THE FILE.
	ANDCMI R,FSSUBT+FSAUX+FSNCHG+FSLALL+FSLRNM
	SKIPE EMSWT
	 ANDCMI R,FSMAIN
	MOVEM R,INSSWT		;USE DATA WORD AS DESIRED F.SWIT FOR .INSRT'ED FILE.
	JRST RLRRS

;HANDLE LR.CRF SUBENTRY.
RLRRC:	SKIPE ECRFF
	 JRST RLRRS
	MOVSI R,-5(C)
	HRRI R,CRFFIL
	BLT R,CRFOFL
	JRST RLRRS

;HANDLE LR.OUT SUBENTRY
RLRRO:	SKIPE EOUTFIL
	 JRST RLRRS
	MOVSI R,-4(C)
	HRRI R,OUTFIL
	BLT R,OUTFIL+3
	JRST RLRRS

;HANDLE LR.CPY SUBENTRY
RLRRQ:	MOVE R,EF
	TLNE R,FLQPYM
	 JRST RLRRS
	SETZM CPYMSG		;FIRST CLEAR OUT COPYRIGHT MESSAGE AREA
	MOVE R,[CPYMSG,,CPYMSG+1]
	BLT R,CPYMSG+LCPYMSG-1
	MOVEI R,CPYMSG-1(D)	;IF MESSAGE TOO LONG, JUST FILL AREA
	CAILE R,CPYMSG+LCPYMSG-1
	 MOVEI R,CPYMSG+LCPYMSG-1
	SUBM C,D
	MOVSI D,(D)
	HRRI D,CPYMSG
	BLT D,(R)		;COPY LREC COPYRIGHT INTO COPYRIGHT AREA
	JRST RLRRS

;HANDLE LR.PSW SUBENTRY.
RLRRP:	HRRZ R,C
	SUBM R,D		;D GETS -<LENGTH>,,< -> 1ST DATA WORD OF SUBENTRY>
	HLLO R,EF
	AND F,R			;THROW AWAY ALL SWITCHES IN LH(F) NOT EXPLICITLY SPEC'D.
	HLLZ R,(D)		;GET SAVED VALUE OF SWITCHES IN F.
	ANDCM R,EF		;MASK TO THOSE NOT SPEC'D THIS TIME.
	IOR F,R			;MERGE: EXPLICITLY SPEC'D FROM F, ALL OTHERS FROM SUBENTRY.
IRPS X,,[LINEL PAGEL UNIVCT CODTYP TRUNCP SINGLE PRLSN SYMLEN QUEUE]
	AOBJP D,RLRRS
	MOVE R,(D)
    IFE X-SYMLEN, MOVMS R	;COMPATABILITY FOR SYMLEN WHICH WAS ONCE NEGATIVE
    IFE <X-LINEL>*<X-PAGEL>,[	;LINEL AND PAGEL ARE OVERRIDDEN IF DEVICE WAS CHANGED.
	SKIPE EDEVICE
	 JRST .+3
    ]
 	SKIPN E!X		;SET THOSE NUMERIC SWITCHES USER DIDN'T OVERRIDE.
	 MOVEM R,X
    IFE X-CODTYP, SETOM ECODTYP	;IF CODTYP IS SET HERE, INHIBIT FPDLNG.
TERMIN
;FIX UP OBSOLETE VALUES OF VARIABLE "QUEUE".
	SKIPG QUEUE .SEE QU.GLD
	 JRST RLRRP1
	SETZM QUEUE
	MOVEI R,DEVGLD
	SKIPN EDEVICE
	 MOVEM R,DEVICE
RLRRP1:	AOBJP D,RLRRS		;NEXT WORD IN LR.PSW IS A WORD OF BITS, WHICH WE MUST DECODE.
	LDB R,[.BP 1,(D)]	;BIT 1.1 IS SET IFF NOTITLE SHOULD BE NONZERO.
	SKIPN ENOTIT
	 MOVEM R,NOTITL
	LDB R,[.BP 2,(D)]	;BIT 1.2 IS SET IF REALPG SHOULD BE NONZERO.
	SKIPN EREALPG
	 MOVEM R,REALPG
	LDB R,[.BP 14,(D)]	;BITS 1.3, 1.4 GO INTO TOP 2 BITS OF NXFDSP,
	ROT R,-2
	SKIPN ENXFDSP
	 MOVEM R,NXFDSP		;THUS SETTING NXFDSP TO EITHER SIGN OR ZERO
	LDB R,[.BP 60,(D)]	;BITS 1.5, 1.6 GO INTO TOP 2 BITS OF FISORF
	ROT R,-2
	SKIPN EFISORF
	 MOVEM R,FISORF
	LDB R,[.BP 100,(D)]	;BIT 1.7 IS SET IFF NORFNM SHOULD BE NONZERO.
	SKIPN ENORFNM
	 MOVEM R,NORFNM
IRPS X,,[SYMTRN DEVICE HEDING]
	AOBJP D,RLRRS
	MOVE R,(D)
 	SKIPN E!X		;SET THOSE NUMERIC SWITCHES USER DIDN'T OVERRIDE.
	 MOVEM R,X
TERMIN
	JRST RLRRS

;HANDLE LR.XGP SUBENTRY
RLRRX:	HRRZ R,C
	SUBM R,D
	MOVE R,(D)		;GET THE DATA WORD
	SKIPN EFNTVSP		;AND SET VSP, UNLESS USER ALREADY DID.
	 MOVEM R,FNTVSP
	AOBJP D,RLRRS
	CAMLE D,[-4,,-1]	;THERE SHOULD BE AT LEAST FOUR MORE WORDS IF THERE ARE ANY
	 .VALUE
	SKIPE EMARGIN
	 JRST RLRRS
	HRRZI R,MARGIN		;WHICH ARE THE MARGIN SETTINGS
	HRLI R,(D)
	BLT R,MARGIN+4-1
	CAMG D,[-5,,-1]		;IF THERE IS A FIFTH WORD
	 SKIPA R,4(D)		; THEN USE IT AS THE HOLE MARGIN
	  SETZ R,		; OTHERWISE USE ZERO FOR COMPATIBILITY
	MOVEM R,MARG.H
	JRST RLRRS

;HANDLE LR.FNT SUBENTRY
RLRRF:	SETOM FNTSPC		;MAKE SURE FONTS GO IN OUTPUT FILES.
	SUB C,D			;POINT AT START OF DATA WORDS.
	MOVEI R,FNTF0-1		;SET UP R AS PDL POINTER TO PUSH DATA INTO FONT TABLE.
RLRRF0:	CAIN R,FNTFE-1
	 JRST RLRRF1		;FILLED UP THE FONT TABLE; IGNORE REST OF SUBENTRY.
	JUMPE D,RLRRF1		;END OF SUBENTRY => STOP.
	SKIPE 1+FNTID(R)	;WAS NEXT FONT FILE SPEC'D BY USER?
	 JRST [	ADDI R,FNTFL	;YES, SKIP THE FILE IN SUBENTRY.
		JRST RLRRF2]
	REPEAT FNTFL,PUSH R,.RPCNT(C)	;NO COPY FILE FROM SUBENTRY TO FONT TABLE.
	SKIPGE FNTID-FNTFL+1(R)	;UNLESS WE HAVE A KSTID SQUIRRELLED AWAY THERE
	 SETZM FNTID-FNTFL+1(R)	;MAKE SURE FNTID ISN'T CHANGED IN PROCESS.
RLRRF2:	ADD C,[FNTFL,,FNTFL]	;SKIP TO NEXT FILE IN SUBENTRY.
	SUB D,[FNTFL,,FNTFL]
	ANDI R,-1		;MAKE SURE CAIE R, WILL WORK.
	JRST RLRRF0

RLRRF1:	ADD C,D			;SKIP REMAINING UNUSED PART OF SUBENTRY.
	JRST RLRRS

SUBTTL	LREC FILE MATCHING ROUTINES

;LOOK THRU THE INPUT LISTING RECORD INFO, ASSOCIATING THE ENTRIES
;WITH THE FILES THAT THEY CORRESPOND TO. THIS IS DONE AFTER PASS 1,
;WHEN ALL FILES TO BE HANDLED HAVE ALREADY BEEN ENCOUNTERED, AND
;FILE BLOCKS CREATED FOR THEM.

MLREC:	SKIPN NOCOMP		;DON'T BOTHER MATCHING IF WE WANT TO LIST EVERYTHING
MLREC0:	 SKIPL B,OLRECA		;OR THERE IS NO OLD LREC INFO TO MATCH WITH
	  POPJ P,
MLREC1:	PUSH P,[[0]]		;IF LR.DAT FOUND, ITS ADDRESS GOES HERE
	PUSH P,B		;ADDRESS OF BEGINNING OF LREC ENTRY
	PUSH P,[0]		;IF LR.PAG SUBENTRY FOUND, ITS ADDRESS GOES HERE.
	PUSH P,[0]		;LR.SYM SUBENTRY ADDRESS GOES HERE.
	ADD B,[4,,4]		;ADVANCE PAST FILENAMES AT BEGINNING OF ENTRY.
;ADVANCE PAST THE NEXT SUBENTRY.
MLREC2:	MOVE C,(B)		;GET NEXT SUBENTRY TYPE
	AOJE C,MLREC3		;-1 MEANS REACHED END OF ENTRY.
	HRLZI A,2(B)		;FORM IN A A SWAPPED AOBJN PTR TO DATA WORDS
	HLR A,1(B)		;OF THE SUBENTRY.
	CAIN C,LR.SYM+1
	 MOVSM A,(P)		;AND IF THE SUBENTRY IS LR.PAG OR LR.SYM,
	CAIN C,LR.PAG+1
	 MOVSM A,-1(P)		;REMEMBER WHERE IT IS.
	CAIN C,LR.DAT+1
	 HLRZM A,-3(P)
	MOVNI A,-2(A)		;GET TOTAL SIZE OF SUBENTRY
	HRLI A,(A)		;IN BOTH HALVES
	ADD B,A			;SKIP OVER IT
	JUMPL B,MLREC2		;AND LOOP
	.VALUE			;UNLESS WE LOST UTTERLY

;COME HERE ON REACHING THE END OF AN ENTRY.
MLREC3:	MOVE C,-2(P)		;GET ADDRESS OF START OF ENTRY
	MOVE C,2(C)		;GET THE FN1 FROM THE FILENAMES AT THE FRONT.
	MOVEI A,FILES		;NOW LOOK AT ALL FILES KNOWN WITH THAT FN1.
MLREC4:	 CAME C,F.IFN1(A)
	  JRST MLREC5
	MOVE H,F.SWIT(A)
	MOVE D,-2(P)
	MOVE D,3(D)		;GET FN2 FROM THE ENTRY
	SKIPE F.OLRC(A)		;IF THIS IS NOT THE FIRST ENTRY TO MATCH
	 CAMN D,F.IFN2(A)	;AND IT IS NOT AN EXACT MATCH,
	  TRNE H,FSLREC		;OR IT'S AN LREC FILE,
	   JRST MLREC5		;THEN IT SHOULDN'T GET THIS OLREC INFO.
	MOVE D,-2(P)
	MOVEM D,F.OLRC(A)	;REMEMBER ADDR OF OLREC INFO FOR FILE.
	MOVE D,@-3(P)		;ALSO SAVE OLD FILE DATE
	MOVEM D,F.OCRD(A)
	SKIPE D,(P)		;SET F.OSMT FROM SUBENTRY WE FOUND, MAKING SURE THAT
	 MOVEM D,F.OSMT(A)	;IF THERE WAS NO SUBENTRY IN THIS ENTRY, BUT WAS ONE
	TRNE H,FSLALL		;IF WANT FULL LISTING OF THIS FILE, FORGET THE OLD
	 JRST MLREC5		;CHECKSUMS.
	SKIPE D,-1(P)		;IN A PREVIOUS ENTRY, WE DON'T FORGET THE OLD ONE.
	 MOVEM D,F.OPGT(A)	;ALSO SAVE PAGE TABLE SUBENTRY.
MLREC5:	ADDI A,LFBLOK
	CAMGE A,SFILE
	 JRST MLREC4
	SUB P,[4,,4]		;NO APPROPRIATE FILE => THROW AWAY SAVED INFO.
	AOBJN B,MLREC1		;LOOP IF ANY MORE ENTRIES
	POPJ P,

;;; IN LREC FILE EDIT MODE, PERFORM ALTERATIONS OF REMEMBERED FILENAMES
;;; AS SPEC'D BY THE COMMAND STRING.

XLREC:	MOVEI A,FILES
XLREC1:	MOVE B,F.OPGT(A)
	MOVEM B,F.PAGT(A)
	MOVE B,F.OLRC(A)		;"REAL FN2" IN OUTPUT LREC FILE IS SAME AS IT WAS IN INPUT.
	MOVE B,F.IFN2(B)
	MOVEM B,F.RFN2(A)
	MOVE B,F.SWIT(A)		;EVERY NON-LREC FILE WHICH HAD A "_" IN ITS SPEC
	TRNN B,FSLREC
	 TRZN B,FSARW
	  JRST XLREC2
	MOVEM B,F.SWIT(A)		;HAS FSARW CLEARED SO WLREC WON'T CONSIDER THIS A
					;BACKARROW-SINGLEQUOTE FILE EVEN IF SINGLEQUOTE FLAG IS SET,
	MOVSI B,F.OSNM(A)		;AND HAS THE SPEC'D OUTPUT NAMES
	HRRI B,F.RSNM(A)		;REPLACE THE REMEMBERED NAMES FROM THE OLD LREC FILE
	BLT B,F.RFN1(A)
	SKIPE B,F.OFN2(A)		;BUT THE FN2 IS HACKED ONLY IF IT WAS SPEC'D.
	 MOVEM B,F.RFN2(A)
XLREC2:	ADDI A,LFBLOK
	CAMGE A,SFILE
	 JRST XLREC1
	POPJ P,


;;; DEFAULT THE LREC OUTPUT FN2.  CALLED AFTER RLREC, SO IF THERE'S A /M'D FILE
;;; WE ALREADY KNOW ABOUT IT.

WLRDF:	SKIPE A,WLRECP
	 SKIPE C,F.OFN2(A)
	  POPJ P,
	MOVEI B,FILES			;OUTPUT LREC FN2 NOT SPEC'D: LOOP FOR "MAIN" FILE.
WLREC1:	MOVE D,F.SWIT(B)
	TRNN D,FSMAIN
	 JRST WLREC3
	MOVE D,F.RFN1(B)		;FOUND THE MAIN FILE. UNLESS ITS SNAME AND FN1
	MOVE CH,F.RSNM(B)		;ARE THE SAME AS THE LREC FILE'S,
	CAMN D,F.OFN1(A)
	 CAME CH,F.OSNM(A)
	  SKIPA C,F.RFN2(B)		;USE THE MAIN FILE'S FN2 AS LREC OUTPUT'S FN2.
	   JRST [			;OTHERWISE, TRY USING "LR" FOLLOWED BY MAIN FILE'S FN2
		LDB C,[143000,,F.RFN2(B)]
		TLO C,'LR_6
		CAMN C,F.RFN2(B)	;BUT CATCH SCREW CASE THAT FN2 IS "LRLRLR"!?!?
		 SETZ C,
		JRST WLREC3]
WLREC3:	ADDI B,LFBLOK
	CAMGE B,SFILE
	 JRST WLREC1
	SKIPN C				;LAST RESORT DEFAULT FOR FN2 IS "LREC" OR "LRC"
	 MOVE C,LRCFN2
	MOVEM C(FDJ"A)		OPJ P,

SUBTTL	LREC DUMPING ROUTINES (FOR DEBUGGING)

;FOR /_, OUTPUT AN ASCII TRANSLATION OF THE INPUT LREC INFO,
;CONTAINING ALL THE INFORMATION THE INPUT LREC FILES HAD.
DLREC:	PUSH P,2PUTX ? MOVSI A,(JFCL) ? MOVEM A,2PUTX
	PUSH P,2PUTNX ? MOVSI A,(CAIA) ? MOVEM A,2PUTNX
	PUSH P,DEVICE ? SETZM DEVICE
PRESS,	PUSH P,PRESSP ? SETZM PRESSP
REPEAT 4,[
	SKIPE B,OUTFIL+.RPCNT	;XFER /O-SPECIFIED DEFAULT DEV AND SNAME INTO FILENAME BLOCK.
	 MOVEM B,DLRECF+.RPCNT
];REPEAT 4
	MOVSI B,'DSK		;IF IT DOESN'T SAY, WE HAVE FURTHER DEFAULTS.
	SKIPN DLRECF+1		;NOTE 2LOOPD WILL DEFAULT THE SNAME.  FN1 AND FN2 FIXED.
	 MOVEM B,DLRECF+1
	MOVEI A,DLRECF-F.OSNM
	PUSHJ P,2LOOPO
	SETZB CC,OUTVP
	MOVEI B,[ASCIZ /Disassembly of LREC file /]
	PUSHJ P,ASCOUT
	MOVE L,RLRECP
	PUSHJ P,FILOUT
	PUSHJ P,CRLOUT
	MOVE C,OLRECA
	JUMPGE C,DLRCLS
;PROCESS THE NEXT ENTRY IN THE INPUT LREC DATA.
DLREC1:	PUSHJ P,CRLOUT
	MOVEI B,[ASCIZ/File: /]
	PUSHJ P,ASCOUT
	MOVEI L,-F.RSNM(C)
	PUSHJ P,FILOUT
	ADD C,[4,,4]
DLREC5:	PUSHJ P,CRLOUT
;HANDLE NEXT SUBENTRY.
DLREC3:	SKIPGE (C)
	 JRST DLRE		;JUMP IF END OF ENTRY.
	PUSHJ P,2OUTPJ		;EMPTY BUFFER IF NECESSARY.
	PUSHJ P,CRLOUT
	MOVEI B,[ASCIZ/Subentry: /]
	PUSHJ P,ASCOUT
	MOVE A,(C)
	PUSHJ P,OCTP
	HLRE A,1(C)
	MOVNS A
	2PATCH ":
	PUSHJ P,OCTP
	PUSHJ P,SPCOUT
	SKIPLE A,(C)
	 CAIL A,DLRECL
	  SKIPA B,['LOSE..]
	   MOVE B,DLRECT-1(A)
	JSP H,SIXOUT
	PUSHJ P,CRLOUT
	MOVE A,(C)
	ADD C,[2,,2]
	HLRE D,-1(C)
	CAIGE A,DLRECL
	 JUMPG A,@DLREC4-1(A)
DLREC2:	MOVE A,(C)
	PUSHJ P,OCTP
	PUSHJ P,CRLOUT
	PUSHJ P,2OUTPJ
	AOBJP C,DLRCLS
	AOJL D,DLREC2
	JRST DLREC3

DLREC4:	OFFSET -.+1
LR.PAG::DLRP
LR.SYM::DLRSY
LR.SWT::DLRSW
LR.PSW::DLRPS
LR.FNT::DLRF
LR.XGP::DLRX
LR.CRF::DLRC
LR.CPY::DLRCP
LR.OUT::DLRO
LR.DAT::DLRDAT
DLRECL::OFFSET 0

DLRECT:	OFFSET -.+1
LR.PAG::'LR.PAG
LR.SYM::'LR.SYM
LR.SWT::'LR.SWT
LR.PSW::'LR.PSW
LR.FNT::'LR.FNT
LR.XGP::'LR.XGP
LR.CRF::'LR.CRF
LR.CPY::'LR.CPY
LR.OUT::'LR.OUT
LR.DAT::'LR.DAT
DLRECL::OFFSET 0

;COME HERE ON REACHING THE -1 THAT ENDS AN ENTRY
DLRE:	PUSHJ P,CRLOUT		;SAY THIS IS THE END OF AN ENTRY
	MOVE B,[SIXBIT/END/]
	JSP H,SIXOUT
	PUSHJ P,CRLOUT
	AOBJN C,DLREC1		;IF THERE ARE MORE ENTRIES, HANDLE THEM.
DLRCLS:	MOVE A,OFILE		;ELSE CLOSE FILE.
	PUSHJ P,2OCLS
PRESS,	POP P,PRESSP
	POP P,DEVICE
	POP P,2PUTNX
	POP P,2PUTX
	POPJ P,

;HANDLE A PAGE-TABLE SUBENTRY.
DLRP:	MOVE A,(C)
	PUSHJ P,OCTP
	MOVEI B,[ASCIZ /	Page /]
	PUSHJ P,ASCOUT
	PUSH P,D
	MOVEI D,(C)
	PUSHJ P,MJMNR1
	POP P,D
	MOVEI CH,"#
	HRRZ L,1(C)
	TRNE L,NEWPAG
	 PUSHJ P,CHROUT
	HLRZ A,1(C)
	JUMPE A,DLRP1
	PUSHJ P,SPCOUT
	MOVEI CH,"(
	PUSHJ P,CH000X
	2PATCH ")
DLRP1:	PUSHJ P,CRLOUT
	PUSHJ P,2OUTPJ
	ADD C,[2,,2]
	ADDI D,2
	JUMPL D,DLRP
	JUMPL C,DLREC3
	JRST DLRCLS

;HANDLE A SYMBOL TABLE SUBENTRY - PRINT ONE LINE PER SYMBOL.
DLRSY:	MOVE R,C
	MOVE C,LINEL
	PUSHJ P,SYMOUT		;OUTPUT SYMBOL NAME.
	MOVEI CH,^I
	PUSHJ P,CHROUT
	HRRZ A,S.TYPE(C)
	HRRZ B,(A)
	PUSHJ P,ASCOUT		;OUTPUT SYMBOL TYPE.
	HLRZ A,S.PAGE(C)
	PUSHJ P,SP000X
	HRRZ A,S.LINE(C)
	ADDI A,1
	MOVEI CH,"-
	PUSHJ P,CH000X
	MOVEI B,[ASCIZ/ (FILE /]	;SAY WHICH FILE DEFINITION IS IN
	PUSHJ P,ASCOUT
	HLRZ A,S.FILE(C) 	;FIND AND PRINT FN1 OF THE FILE.
	MOVE B,F.RFN1(A)
	JSP H,SIXOUT
	2PATCH ")
	HLRZ A,S.BITS(C)
	JUMPE A,DLRSY1		;IF THE S.BITS FIELD IS NON-NULL, PRINT IT TOO.
	PUSHJ P,SPCOUT
	PUSHJ P,OCTP
DLRSY1:	PUSHJ P,CRLOUT
	PUSHJ P,2OUTPJ
	ADD C,[LSENT,,LSENT]
	ADDI D,LSENT
	JUMPGE C,DLRCLS
	JUMPL D,DLRSY
	JRST DLREC3

;HANDLE A QOPYRIGHT SUBENTRY
DLRCP:	MOVSI B,(440700,,(C))
	MOVEI L,5
DLRCP1:	ILDB CH,B
	PUSHJ P,CHROUT
	SOJG L,DLRCP1
	ADD C,[1,,1]
	AOJL D,DLRCP
	PUSHJ P,CRLOUT
	JUMPL C,DLREC3
	JRST DLRCLS

;HANDLE LR.PSW SUBENTRY.
DLRPS:	HRLZS D
DLRPS2:	SKIPL B,DLRPS1(D)	;SKIP UNLESS PAST LAST KNOWN ENTRY NAME
	 HRRI D,-1(D)		;DON'T ADVANCE BEYOND THE "?"
	CAME B,DLRPSD
	 JRST DLRPS3
	MOVE A,(C)		;WHEN WE COME TO THE DEVICE CODE, SAVE IT AWAY
	MOVEM A,DLRDEV		;SO WE CAN KNOW HOW TO PRINT THE FONTS.
DLRPS3:	JSP H,SIXOUT
	2PATCH "=
	SKIPGE A,(C)		;IF THE VALUE IS POSITIVE
	 JRST DLRPS4
	PUSHJ P,SP000X		;THEN PRINT IT IN DECIMAL
	MOVEI B,[ASCIZ/. = /]
	PUSHJ P,ASCOUT
DLRPS4:	MOVE A,(C)
	PUSHJ P,OCTP
	PUSHJ P,CRLOUT		;WE PROBABLY SHOULD ALSO INTERPRET THE BITS (SIGH)
	AOBJP C,DLRCLS
	AOBJN D,DLRPS2
	JRST DLREC3

DLRPS1:	SIXBIT/F/
	SIXBIT/LINEL/
	SIXBIT/PAGEL/
	SIXBIT/UNIVCT/
	SIXBIT/CODTYP/
	SIXBIT/TRUNCP/
	SIXBIT/SINGLE/
	SIXBIT/PRLSN/
	SIXBIT/SYMLEN/
	SIXBIT/NOQUEU/
	SIXBIT/BITS/
	SIXBIT/SYMTRN/
DLRPSD:	SIXBIT/DEVICE/
	SIXBIT/HEDING/
	SIXBIT/?/		;SPECIAL FOR ANY EXTRAS

;HANDLE LR.SWT SUBENTRY
DLRSW:	MOVEI B,[ASCIZ/F.SWIT=/]
	PUSHJ P,ASCOUT
	MOVE A,(C)
	PUSHJ P,OCTP
	PUSHJ P,CRLOUT		;WE PROBABLY SHOULD ALSO INTERPRET THE BITS (SIGH)
DLRDUN:	ADD C,[1,,1]
	AOJE D,DLREC3
	MOVNS A,D
	PUSHJ P,000X
	MOVEI B,[ASCIZ / Extra words follow the meaningful data in this block.
/]
	PUSHJ P,ASCOUT
	HRLI D,(D)
	ADD C,D
	JRST DLREC3

;HANDLE LR.FNT SUBENTRY.
DLRF:	SKIPN FNTSIZ(C)
	 JRST DLRF1		;NOTHING KNOWN FOR THIS FONT => PRINT NOTHING.
	PUSHJ P,DLRF2		;PRINT THE FONT'S NAME
	MOVSI B,(SIXBIT/ (/)
	JSP H,SIXOUT
	MOVE A,FNTSIZ(C)	;AND SIZE WORD.
	PUSHJ P,OCTP
	2PATCH ")
DLRF1:	ADD C,[FNTFL,,FNTFL]
	ADDI D,FNTFL
	JUMPL D,[MOVEI CH,", ? PUSHJ P,CSPOUT ? JRST DLRF]
	PUSHJ P,CRLOUT
	JUMPGE C,DLRCLS
	JRST DLREC3

DLRF2:
PRESS,[	MOVE CH,DLRDEV		;IF OUR DEVICE WANTS PRESS FILES, FONT NAMES AREN'T FILENAMES.
	SKIPGE FRCXGP(CH)	;DON'T USE PRESSP HERE!  SEE DLREC.
	 JRST [	MOVEI L,(C)
		MOVE A,[PUSHJ P,CHROUT]	;PRINT OUT PRESS FILE FONT NAME.
		JRST PRSPFN ]
];PRESS
	MOVEI L,-F.RSNM(C)
	JRST FNTOUT

;HANDLE LR.CRF SUBENTRY.
DLRC:	SKIPN 4(C)		;IF ENTRY SAYS "NO FILE IS SPEC'D",
	 JRST DLRC1		;IT'S THE SAME AS NO ENTRY AT ALL.
;HANDLE LR.OUT SUBENTRY.
DLRO:	MOVEI L,-F.RSNM(C)
	PUSHJ P,FILOUT		;ELSE LIST NAMES THAT ARE SPEC'D.
DLRC2:	MOVN L,-1(C)
	HLRS L
	ADD C,L
	PUSHJ P,CRLOUT
	JUMPGE C,DLRCLS
	JRST DLREC3

DLRC1:	MOVE B,[SIXBIT/NONE:/]
	JSP H,SIXOUT
	JRST DLRC2		;MUST PASS OVER THE ENTRY EVEN IF IT SAYS NOTHING.

;HANDLE LR.XGP SUBENTRY.
DLRX:	MOVE B,[SIXBIT/VSP=/]
	JSP H,SIXOUT
	MOVE A,(C)
	PUSHJ P,000XCR
	CAML D,[-4]		;IF THERE ARE FOUR MORE WORDS
	 JRST DLRDUN
	MOVEI B,[ASCIZ/MARGINS=/] ;THEN WE HAVE MARGINS TO PRINT
	PUSHJ P,ASCOUT
REPEAT 4,[
	MOVE A,1+.RPCNT(C)
IFE .RPCNT, PUSHJ P,000X
IFN .RPCNT, PUSHJ P,CM000X
];REPEAT 4
	ADD C,[5,,5]
	ADDI D,5
	JUMPE D,DLREC5
	MOVE A,(C)
	PUSHJ P,CM000X
	PUSHJ P,CRLOUT
	JRST DLRDUN

;HANDLE AN LR.DAT SUBENTRY.  PRINT DATE AS DATE (ACCORDING TO SYSTEM RUNNING ON) AND AS OCTAL.
DLRDAT:	PUSH P,D
	MOVEI B,[ASCIZ /File date as octal word = /]
	PUSHJ P,ASCOUT
	HLRZ A,(C)
	PUSHJ P,OCTP
	MOVEI B,[ASCIZ /,,/]
	PUSHJ P,ASCOUT
	HRRZ A,(C)
	PUSHJ P,OCTP
	PUSHJ P,CRLOUT
	MOVE R,(C)
	PUSH P,C
	PUSHJ P,PTQDAT
	PUSHJ P,CRLOUT
	POP P,C
	POP P,D
	JRST DLRDUN

SUBTTL	LREC FILE OUTPUT

;WRITE 1 WORD INTO LREC FILE (USING BUFFER) FROM ACCUMULATOR X.
ITS,[
DEFINE WLRWWD X,(Y)
IFNB [Y]MOVE X,Y
	IDPB X,C
	SOSG D
	 PUSHJ P,WLRWO
TERMIN
];ITS
DOS,[
DEFINE WLRWWD X,(Y)
IFNB [Y]MOVE X,Y
	SOSGE OUTHED+2
	 PUSHJ P,WLRWO
	IDPB X,OUTHED+1
TERMIN
];DOS

DEFINE WLRWWI HALF,(VAL)		;IMMEDIATE RIGHT OR LEFT HALF WLRWWD. USES B.
	HR!HALF!ZI B,VAL
	WLRWWD B
TERMIN

;;; WRITE AN OUTPUT LREC FILE, IF THAT'S REQUESTED.

WLREC:	SKIPN A,WLRECP
	 POPJ P,
	PUSHJ P,WLRECR			;RENAME OLD LREC FILE AS OLREC.
	MOVEI R,.BIO			;WE WANT IMAGE OUTPUT.
ITS,	MOVE H,[SIXBIT/LREC/]		;OPEN _@_ LREC ON ITS.
DOS,	;H WAS SET UP IN WLRECR
	PUSHJ P,2OUTOP
	 FLOSE UTOC,F.OSNM(A)
	  JFCL CPOPJITS$K	MKVE A(S(a2IUZc:'+A)A	+HA/%QA=A%A1\%-$AYM+w&A( =$	0AA&A'!A(\):w)L!AA %m%5$A=+)!+PA%A,A		FI0A%5/@Q=A)LR\%/%/]AYm'1%(_%^Vctvc'PA/%AA1%AA%&A'a(_)E,b%Y1&$w,A(AA%&X4/%dt5-AY]'Q$)'NA	1'%%!+'(A Y/1%.$w/%QAAQ%2A=$AAIA(		$AY4A1'A)%'(ARH!U'A@Y/%%U!+(A](OLA+"A'1+\4!@A Y4%M(@e&b$w%9AA1'AQAPQ#I8(w+'&A)!A+Q!+(A1%AdA"|0A%A92A1%')AA/A]+;'+!I'	#M E%D\(/I$tIM16"!1]8dQR+)! 9I9 DXAY7'BQ<|_:eAA])AMA9AAY%/%T90AA!A@X5!Y' %m'A%A(@ER\M3'0A	)Y7]	AR|A]'1Q$@~A)F ~A]='QS:$A0'1%'Y @] ~A]=dQR@~A]'AR|A]'1Q$@~A1%etA)):w)L	LY6'ZA!%o7XAaPA!%Q)  )t7e&RSYJ(-AY]	XQR(-!1%!Vb(	-$A XQA,b	%m	%Oe	-
~$A!8A%Y%N%)%2A'=%5A!\4@AA!A@X1'A Xbb\$wA'%A 	)A	(L5XQ@R5-AY]=bQR5Y%&1,]%!4AY]=dQRAYId(A%M(A/Ip(&!1%%V]%	1((-AY]'4QR(-!1%%V]%	!!)'$X=+ AIYI0w)I2A1Q	A-+ $A%'PA6=-AY%I9%wt7otKH$-+ A%9Y%&1,]%$A%'PA/%%f2@mn2P8@`Y6A	I'A+1	A=$A\%Y%9MX%!AX4'X-4AX4:w@`(A=-A Y]"Q$5Y%9	SIMFIL+.RBDEV
		JRST .+1 ]
	HLLZ H,RNMFIL+.RBPRV		;Get the old protection for the new .LRC file
	TLZ H,777			;But not the "M" or "TIME" fields
	MOVE CH,F.ODEV(A)
	CAMN CH,[SIXBIT /DSK/]		;Was the device DSK?
	 MOVE CH,RNMFIL+.RBDEV		;yes, use the real device
	EXCH CH,F.ODEV(A)		;when ENTERing the .LRC file
	MOVEM CH,DELCHN+1		;But use the DSK for deleting
	OPEN DELC,DELCHN
	 .VALUE				;DEVICES SHOULDN'T JUST DISAPPEAR!!!
	MOVE CH,F.OFN1(A)
	MOVEM CH,DELFIL+.RBNAM
	MOVE CH,OLRFN2
	HLLZM CH,DELFIL+.RBEXT
	MOVE CH,F.OSNM(A)
	MOVEM CH,DELFIL+.RBNAM+3	;Funny Place because
	LOOKUP DELC,DELFIL+.RBNAM	;Non extended lookup
	 JRST WLREC6
	SETZM DELFIL+.RBNAM
	RENAME DELC,DELFIL+.RBNAM
	 JFCL				;WELL, WE TRIED ANYHOW
WLREC6:	RELEASE DELC,
	SKIPL (P)			;DECTAPE?
	 JRST WLREC5			;NO, NO NEED TO RE LOOKUP
	LOOKUP RNMC,RNMFIL+.RBNAM	;DECTAPE FORGETS MORE THAN ONE LOOKUP!!! (SIGH)
	 JRST WLREC8			;I WONDER WHAT HAPPENED
	CLOSE RNMC,			;DECTAPE ALSO LIKES A CLOSE FIRST, ACCORDING TO THE MANUAL
WLREC5:	MOVE CH,OLRFN2
	HLLM CH,RNMFIL+.RBEXT		;CHANGE EXT WITHOUT CLOBBERING DATES
	MOVE CH,F.OSNM(A)
	MOVEM CH,RNMFIL+.RBNAM+3	;LOSING NON EXTENDED LOOKUP CLOBBERS THIS WORD
	RENAME RNMC,RNMFIL+.RBNAM
	 JFCL				;WELL, WE TRIED ANYHOW
WLREC8:	RELEASE RNMC,
];DOS
	POPJ P,

;EMPTY THE BUFFERED DATA FROM SLBUF INTO THE FILE, AND RE-INIT C AND D.
WLRWO:
ITS,[	SUBI C,SLBUF-1		;# WDS OF DATA PUT IN SLBUF.
	MOVNS C
	HRLZI C,(C)
	HRRI C,SLBUF		;AOBJN PTR TO USED PART OF SLBUF.
	JUMPGE C,WLRWO2
	 .IOT UTOC,C		;WRITE IT OUT.
WLRWO2:	MOVE C,[004400,,SLBUF-1]
	MOVEI D,LSLBUF		;BUFFER NOW EMPTY; RE-INIT STORING IN IT.
	POPJ P,
];ITS
TNX,	.ERR This code loses
DOS,[	OUT UTOC,
	 JRST WLRWO2
	PUSH P,N
	GETSTS UTOC,N
	.VALUE
	TRZ N,740000
	SETSTS UTOC,(N)
	POP P,N
WLRWO2:	SOSGE OUTHED+2
	 .VALUE
	POPJ P,
];DOS

;WRITE AN LREC ENTRY FOR THE FILE WHOSE BLOCK A POINTS TO.
WLRW:	TRC B,FSQUOT+FSARW
	TRCN B,FSARW+FSQUOT	;NO LREC ENTRY FOR OUTPUT-ONLY FILES.
	 POPJ P,
	MOVE B,F.IDEV(A)	;WRITE NO INFO ABOUT FILES ON DEVICE NONE:,
	CAMN B,[SIXBIT/NONE/]	;SO LREC EDIT MODE CAN GET RID OF FILE BY CHANGING DEV TO NONE:.
	 POPJ P,
	SKIPN NORFNM
	 SKIPN B,F.RSNM(A)	;WRITE THE SNAME
	  MOVE B,F.ISNM(A)
	WLRWWD B
NOCMU,[				;UNDER CMU, USE THE SPECIFIED DEVICE, NOT THE REAL DEVICE
	SKIPN NORFNM
	 SKIPN B,F.RDEV(A)	;WRITE THE DEV
];NOCMU
	  MOVE B,F.IDEV(A)
	WLRWWD B
	SKIPN NORFNM
	 SKIPN B,F.RFN1(A)	;WRITE THE FN1
	  MOVE B,F.IFN1(A)
	WLRWWD B
	SKIPN NORFNM
	 SKIPN B,F.RFN2(A)	;WRITE THE FN2
	  MOVE B,F.IFN2(A)
	WLRWWD B
	WLRWWI R,LR.PSW		;SAVE ALL SWITCH SETTINGS.
	WLRWWI L,-14.		;-14. IN L.H.
	INSIRP WLRWWD B,REALF LINEL PAGEL UNIVCT CODTYP TRUNCP SINGLE PRLSN SYMLEN QUEUE
	SETZ B,			;FROM NOW ON, ALL THOSE 1 BIT PER WORD FLAGS GET ENCODED:
	SKIPE NOTITL		;BIT 1.1 OF WORD 11 MEANS NOTITL IS NONZERO.
	 TRO B,1
	SKIPE REALPG		;BIT 1.2 MEANS REALPG IS NONZERO (/Y).
	 TRO B,2
	SKIPE NXFDSP		;BIT 1.3 REFLECTS NONZERONESS OF NXFDSP.
	 TRO B,4
	SKIPGE NXFDSP		;BIT 1.4 IS SIGN BIT OF NXFDSP.
	 TRO B,10
	SKIPE FISORF		;BIT 1.5 REFLECTS NONZERONESS OF FISORF
	 TRO B,20
	SKIPGE FISORF		;BIT 1.6 IS SIGN BIT OF FISORF.
	 TRO B,40
	SKIPE NORFNM		;BIT 1.7 MEANS NORFNM IS NONZERO
	 TRO B,100
	WLRWWD B		;OUTPUT THE ENCODED WORD.
	INSIRP WLRWWD B,SYMTRN DEVICE HEDING
	WLRWWI R,LR.SWT		;WRITE F.SWIT IN AN LR.SWT SUBENTRY.
	WLRWWI L,-1
	WLRWWD B,F.SWIT(A)
	SKIPN OUTFIL
	 SKIPE OUTFIL+1
	  JRST WLRWX4
	SKIPN OUTFIL+2
	 SKIPE OUTFIL+3
	  JRST WLRWX4
	JRST WLRWX5

WLRWX4:	WLRWWI R,LR.OUT
	WLRWWI L,-4
WLRWX6:	WLRWWD CH,OUTFIL(B)
	AOBJN B,WLRWX6
WLRWX5:	SKIPN CRFOFL		;IF A SEPARATE CREF OUTPUT FILE IS ENABLED,
	 JRST WLRWX2
	WLRWWI R,LR.CRF		;REMEMBER INFO ABOUT THAT.
	WLRWWI L,-5
WLRWX3:	WLRWWD CH,CRFFIL(B)
	AOBJN B,WLRWX3
	DROPTHRUTO WLRWX2

;DROPS THROUGH
WLRWX2:	WLRWWI R,LR.XGP		;WRITE OUT THE VSP AND MARGIN INFO
	WLRWWI L,-6
	WLRWWD B,FNTVSP		;VSP GOES IN LR.XGP
REPEAT 5,[
	MOVE B,MARGIN+.RPCNT	;AS DO THE MARGINS
	WLRWWD B
];REPEAT 5
	SKIPN FNTSPC
	 JRST WLRWX
	WLRWWI R,LR.FNT		;FONT TABLE GOES IN LR.FNT
	WLRWWI L,-NFNTS*FNTFL
WLRWX1:	WLRWWD CH,FNTF0(B)
	AOBJN B,WLRWX1
WLRWX:	MOVE R,REALF		;CHECK IF COPYRIGHT MESSAGE BEING PRINTED
	TLNN R,FLQPYM
	 JRST WLRWD		;AND DON'T DUMP ONE IF NOT
	WLRWWI R,LR.CPY		;OUTPUT QOPYRIGHT MESSAGE IN LR.CPY
	WLRWWI L,-LCPYMSG
WLRWQ:	WLRWWD CH,CPYMSG(B)
	AOBJN B,WLRWQ
WLRWD:	WLRWWI R,LR.DAT		;OUTPUT CREATION DATE OF SOURCE FILE.
	WLRWWI L,-1
	SKIPN CH,F.CRDT(A)
	 MOVE CH,F.OCRD(A)
	WLRWWD CH
	MOVE B,F.SWIT(A)
	TRNN B,FSNOIN+FSQUOT	;MAYBE WE DON'T WANT SYM TAB OR PAGE TABLE.
	 SKIPL CH,F.PAGT(A)	;IF FILE IS OUTPUT, USE NEW PAGE TABLE IF ANY.
	  MOVE CH,F.OPGT(A)	;ELSE DON'T ABANDON ANY OLD ONE.
	JUMPGE CH,WLRW2		;NO PAGE TABLE => NO LR.PAG SUBENTRY.
	WLRWWI R,LR.PAG		;WRITE THE PAGE-TABLE SUBENTRY.
	WLRWWD B,CH		;AFTER THE SUBENTRY TYPE, THE AOBJN PTR
WLRW1:	MOVE CH,(B)		;AND WHAT IT POINTS TO.
	WLRWWD CH
	AOBJN B,WLRW1
WLRW2:
IFN 0,[	;WE NO LONGER KEEP SYMBOL TABLES IN THE LREC FILE.
	SKIPGE F.OSMT(A)	;IF WE HAVE EITHER AN OLD OR A NEW SYMBOL TABLE,
	 JRST WLRW8
	MOVE B,F.SWIT(A)
	TRNN B,FSNOIN+FSQUOT
	 SKIPN F.NSYM(A)
	  JRST WLRW5
WLRW8:	MOVEI B,LR.SYM		;WRITE A SYMBOL TABLE SUBENTRY.
	WLRWWD B
	MOVN B,F.NSYM(A)
	JUMPE B,WLRW6		;NO NEW SYMTAB => WRITE OLD.
	LSH B,18.+2		;HAVE NEW SYMTAB: LH(B) HAS -4*<# SYMBOLS> = -<LENGTH OF DATA>
	WLRWWD B
	MOVE CH,SYMAOB		;LOOK AT ALL SYMBOLS,
WLRW3:	HLRZ B,1(CH)
	CAIE B,(A)		;OUTPUTTING THE ENTRIES FOR THOSE IN THIS FILE.
	 JRST WLRW4
REPEAT 4,[
	MOVE B,.RPCNT(CH)
	WLRWWD B
];REPEAT 4
WLRW4:	ADDI CH,3
	AOBJN CH,WLRW3
];IFN 0
WLRW5:	SETO B,			;WRITE THE END-OF-ENTRY MARKER.
	WLRWWD B
	POPJ P,

IFN 0,[
WLRW6:	HLLZ B,F.OSMT(A)	;WRITE OUT LENGTH AND DATA FROM OLD SYMTAB.
	WLRWWD B
	MOVE CH,F.OSMT(A)
WLRW7:	MOVE B,(CH)
	WLRWWD B
	AOBJN CH,WLRW7
	JRST WLRW5
];IFN 0

SUBTTL	COMPARISON LISTING ROUTINES

;PERFORM COMPARISONS, DECIDING WHICH PAGES OF EACH FILE NEED TO BE LISTED.

CPR:	MOVEI A,FILES
CPR1:	MOVE B,F.SWIT(A)
	TRNN B,FSLREC+FSNOIN
	 PUSHJ P,CPRF		;COMPARE ONE FILE.
	ADDI A,LFBLOK
	CAMGE A,SFILE
	 JRST CPR1
	POPJ P,

;COMPARE THE FILE WHOSE FILE BLOCK <- A.
CPRF:	TRC B,FSARW+FSQUOT
	TRCE B,FSARW+FSQUOT
	 SKIPL F.PAGT(A)
	  POPJ P,
	PUSHJ P,CPRFP		;FIND NEW PAGES WHOSE CHECKSUMS MATCH OLD ONES.
ITSXGP,[MOVE B,F.PAGT(A)
	MOVE D,DEVICE
	SKIPE TEXGPP		;IF /L[TEXT] AND /D[XGP ITS], MARK 1ST PAGE AS CHANGED, SINCE
	 CAIE D,DEVIXG		;IT PROBABLY CONTAINS XGP COMMANDS WHOSE LOSS WOULD SCREW.
	  CAIA
	   SETZM (B)
];ITSXGP
	MOVE D,F.SWIT(A)
	PUSHJ P,[ SKIPE REALPG	;IF /Y, ASSIGN EACH PAGE ITS REAL # AS ITS VIRTUAL #
		   JRST CPRY
		  PUSHJ P,CPRC	;ELSE RESOLVE ORDERING CONFLICTS AND
		  JRST CPRA]	;ASSIGN INTERPOLATED PAGE #'S TO PAGES THAT NEED THEM.
	PUSHJ P,CPRL		;SET UP LINE # OFFSETS.
	PUSHJ P,CPRU		;DECIDE WHETHER FILE HAS CHANGED SINCE PREVIOUS LISTING.
	POPJ P,

;LOOK THRU OLD AND NEW PAGE TABLES, FINDING NEW FILE PAGES WITH SAME CHECKSUM
;AS OLD FILE PAGES. PUT IN LH OF 2ND WORD OF NEW PAGE TABLE ENTRY THE NUMBER
;OF THE CORRESPONDING OLD PAGE.
CPRFP:	SKIPL C,F.OPGT(A)	;CAN'T HACK THIS IF NO OLD PAGE TABLE.
	 POPJ P,
CPRFP5:	HRRZS 1(C)		;IN OLD PAGE TABLE, CLEAR LH(2ND WORD) OF ALL WORDS
	ADD C,[2,,2]
	JUMPL C,CPRFP5
	MOVE C,F.OPGT(A)	;RELOAD OLD PAGE TABLE POINTER
	SKIPL B,F.PAGT(A) 	;CAN'T HACK THIS IF NO NEW PAGE TABLE.
	 POPJ P,
	MOVE L,F.SWIT(A)
	SKIPN NORENUM
	 TRNE L,FSLRNM		;IF WE WANT TO AVOID NONZERO MINOR PAGE NUMBERS,
	  JRST CPRFR		;THERE'S A SPECIAL SEARCH ALGORITHM.
	HRLZI L,-1		;MAKE IT EASY TO TEST THE LEFT HALF OF WORDS
CPRFP1:	MOVE D,(B)		;GET CHECKSUM OF NEXT NEW PAGE.
	MOVE C,F.OPGT(A)	;SCAN OLD PAGE TABLE FOR EQUAL OLD PAGE.
CPRFP4:	CAMN D,(C)		;THIS OLD PAGE HAD SAME CKSUM AS NEW PAGE?
	 TDNE L,1(C)		;(DON'T MATCH SAME PAGE TWICE, IF /Y.  IF /-Y, CPRC FIXES THAT)
	  AOBJN C,[AOBJN C,CPRFP4 ;NO, TRY ANOTHER OLD PAGE.
		   JRST CPRFP2]	;ALL OLD PAGES TRIED - NO CORRESPONDING OLD PAGE.
CPRFP3:	HRRZ D,1(C)		;YES, GET MAJOR AND MINOR PG NOS. OF OLD PAGE,
	ANDCMI D,NEWPAG		; AND MAKE NEW PAGE POINT TO THEM
	HRRM D,1(B)
	SKIPE REALPG
	 HRLM B,1(C)		;MAKE OLD PAGE POINT AT WHICH NEW PAGE IT IS BECOMING (FOR /Y).
CPRFP2:	AOBJP B,CPOPJ
	AOBJP B,CPOPJ		;LOOK AT ALL NEW FILE'S PAGES THIS WAY.
	MOVE D,(B)		;ATTEMPT TO MAP CONSECUTIVE NEW PAGES
	ADD C,[2,,2]
	SKIPGE 1(C)
	 JRST CPRFP1
	CAMN D,(C)		;INTO CONSECUTIVE OLD PAGES.
	 JUMPL C,CPRFP3
	JRST CPRFP1		;NEXT NEW NOT EQUAL TO NEXT OLD; TRY OTHER OLD PAGES.

;SCAN FOR NEW PAGES THAT MATCH THE OLD PAGE WITH THE SAME PHYSICAL PAGE NUMBER.
;CAUSES ENOUGH RELISTING TO MAKE SURE LOGICAL PAGE # ALWAYS EQUALS PHYSICAL.
CPRFR:	MOVEI L,.DPB 1,MAJPAG,0	;Init real page number counter
CPRFR2:	HRRZ D,1(C)		;See if Old page number geq real page number
	ANDCMI D,NEWPAG
	CAIGE D,(L)
	 JRST [	ADD C,[2,,2]	;If not, loop until it is
		JUMPL C,CPRFR2
		POPJ P, ]	;Unless, of course, if we run out
	CAIE D,(L)		;Is it now equal?
	 JRST CPRFR1		; if not, cant match
	MOVE R,(B)		;Otherwise, if checksums match
	CAMN R,(C)
	 HRRM D,1(B)		;Then mark new page table as such
CPRFR1:	ADDI L,.DPB 1,MAJPAG,0	;And loop to the next new page
	ADD B,[2,,2]
	JUMPL B,CPRFR2
	POPJ P,

;HERE TO ASSIGN SEQUENTIAL VIRTUAL PAGE #S TO ALL NEW PAGES (IE, VIRT # = REAL #).
;ALSO SETTING THE NEWPAG BITS OF CHANGED PAGES (THOSE WITH NO OLD PAGE NUMBERS FOUND).
CPRY:	SKIPL B,F.PAGT(A)
	 POPJ P,
	MOVEI C,.DPB 1,MAJPAG,0
	MOVEI D,NEWPAG
CPRY1:	HRRZ L,1(B)		;IF PAGE HAS NO OLD PAGE EQUIVALENT, TURN ON NEWPAG BIT.
	SKIPN L
	 IORM D,1(B)
	DPB C,[.BP <<.BM MAJPAG>\.BM MINPAG>,1(B)]
	ADD B,[2,,2]
	ADDI C,.DPB 1,MAJPAG,0
	JUMPL B,CPRY1
	POPJ P,

;COME AFTER ASSIGNING MAJOR AND MINOR PAGE #S TO ALL PAGES.
;PUT IN THE LH OF 2ND WORD OF PAGTAB ENTRY FOR EACH PAGE
;THE NUMBER OF THE 1ST LINE ON THAT PAGE, MINUS 1.
;WHEN CPRL CALLED, THAT LH. CONTAINS # LINES ON PAGE.
CPRL:	SKIPL B,F.PAGT(A)
	 POPJ P,
	SETZ C,
;C HAS # OF LAST LINE ON PREVIOUS PAGE.
CPRL1:	HLRZ D,1(B)		;# LINES ON THIS PAGE.
	HRRZ R,1(B)
	SKIPG TEXTP		;IF /L[RANDOM], ALL PAGES START WITH "LINE 1".
	 TRNN R,.BM MINPAG	;IF THIS IS MINOR PAGE 0,
	  SETZ C,		;IT STARTS AT LINE 1.
	HRLM C,1(B)		;STORE <1ST LINE ON PAGE>-1
	ADD C,D			;MAKE <LAST LINE ON PAGE>
	AOBJP B,CPOPJ
	AOBJN B,CPRL1
	POPJ P,

;SEE WHETHER FILE HAS CHANGED AT ALL SINCE THE OLREC
;INFO FOR IT WAS WRITTEN. IF NOT, SET FSNCHG FOR FILE.
CPRU:	SKIPGE B,F.PAGT(A)
	 SKIPL C,F.OPGT(A)
	  POPJ P,
CPRU1:	MOVE D,(B)		;LOOK FOR CHANGES BY COMPARING NEW AND OLD PAGE TABLES.
	MOVE L,1(B)		;COMPARE BOTH THE PAGE NUMBERS
	XOR L,1(C)
	TRNN L,<.BM MAJPAG>\.BM MINPAG
	 CAME D,(C)		;AND THE CHECKSUMS
	  POPJ P,		;IF THEY DIFFER, FILE HAS CHANGED.
	ADD B,[2,,2]
	ADD C,[2,,2]
	JUMPGE B,CPRU3
	JUMPL C,CPRU1
	POPJ P,			;FILE HAS BEEN EXTENDED AT THE END => IT HAS CHANGED.

CPRU3:	JUMPL C,CPOPJ		;HERE IF FILE HAS BEEN TRUNCATED?
	MOVEI D,FSNCHG		;IF THEY DIFFER IN LENGTH, FILE HAS CHANGED.
	IORM D,F.SWIT(A)
	POPJ P,

;RESOLVE CONFLICTS IN ASSIGNMENTS MADE BY CPRFP.
;A CONFLICT IS WHERE NEW PAGE <N> CORRESPONDS TO OLD PAGE <M>
;AND  NEW PAGE <N>+<X> CORRESPONDS TO OLD PAGE <M>-<Y>.
;IN OTHER WORDS, PAGES HAVE BEEN SHUFFLED.
;ONE OR ANOTHER GROUP OF PAGES MUST BE RE-LISTED WITH NEW NUMBERS
;EVEN IF NOT CHANGED. CPRC DECIDES WHICH WAY TO DO THAT SO AS
;TO REDUCE THE AMOUNT OF LOSSAGE THAT RESULTS. IT DOES THAT BY MARKING
;THE PAGES THAT NEED TO BE RELISTED AS HAVING NO CORRESPONDING OLD PAGE.

CPRC:	SKIPL B,F.PAGT(A)
	 POPJ P,
	HRRZ C,1(B)		;FIRST, SCAN THRU NEW PAGE TABLE, LOOKING FOR CONFLICT.
	MOVE R,B		;R POINTS TO PAGE WHOSE OLD PAGE # IS IN C.
	ADD B,[2,,2]
	JUMPGE B,CPOPJ
CPRC1:	HRRZ D,1(B)
	JUMPE D,CPRC3
	CAMG D,C		;CONFLICT FOUND.
	 JRST CPRC2
	MOVE C,D
	MOVE R,B
CPRC3:	AOBJP B,CPOPJ
	AOBJN B,CPRC1
	POPJ P,

;A CONFLICT HAS BEEN FOUND.
CPRC2:	MOVE H,B		;H -> PAGE WHOSE NEW PAGE # IS IN D.
	SETZB CH,L		;COMPUTE COSTS OF 2 WAYS OF HACKING IN CH,L.
CPRC5:	ADD B,[2,,2]
	JUMPGE B,CPRC4
	HRRZ D,1(B)		;COMPUTE IN CH COST OF RELISTING UPPER GROUP OF PGS.
	JUMPE D,CPRC5
	CAMG D,C
	 AOJA CH,CPRC5
CPRC4:	MOVE B,R
	HRRZ C,1(H)
CPRC6:	CAMN B,F.PAGT(A)
	 JRST CPRC7
	SUB B,[2,,2]		;CPT. IN L COST OF RELISTING LOWER GROUP.
	HRRZ D,1(B)
	JUMPE D,CPRC6
	CAML D,C
	 AOJA L,CPRC6
CPRC7:	CAML L,CH		;WHICH GROUP WOULD COST LESS TO RE-LIST?
	 JRST CPRCU		;THE UPPER GROUP WOULD.
CPRCL:	MOVE B,R		;THE LOWER GROUP WOULD.
	HRRZ C,1(H)		;GET LOWEST PAGE NUM IN UPPER GROUP
CPRCL1:	HRRZ D,1(B)
	JUMPE D,CPRCL2		;IS THIS PAGE TO BE LISTED?
	CAMGE D,C		;YES, IS IT STILL IN CONFLICT RANGE?
	 JRST CPRC		;NO, WE'RE DONE. LOOK FOR ANOTHER CONFLICT.
	HLLZS 1(B)		;REQUIRE PAGE TO BE RELISTED.
CPRCL2:	CAMN B,F.PAGT(A)
	 JRST CPRC
	SUB B,[2,,2]		;THIS ISN'T THE FIRST PAGE
	JRST CPRCL1		;SO LOOK AT PREVIOUS ONES.

;IT'S CHEAPER TO RELIST THE UPPER GROUP.
CPRCU:	MOVE B,H		;-> 1ST PAGE OF UPPER GROUP.
	HRRZ C,1(R)		;PAGE # OF TOP OF LOWER GROUP.
;UPPER GROUP CONSISTS OF ALL PAGES FROM C(B) ON
;UNTIL THE FIRST WHOSE PAGNUM IS > C(C).
CPRCU1:	HRRZ D,1(B)
	JUMPE D,CPRCU2
	CAMLE D,C		;REACHED END OF UPPER GROUP?
	 JRST CPRC		;YES, LOOK FOR ANOTHER CONFLICT.
	HLLZS 1(B)		;SAY THIS PAGE MUST BE RELISTED.
CPRCU2:	ADD B,[2,,2]
	JUMPL B,CPRCU1		;AND KEEP SCANNING UPPER GROUP.
	JRST CPRC

;CPRA ASSIGNS PAGE NUMBERS TO ALL THE PAGES OF THE FILE THAT DON'T HAVE
;CORRESPONDING OLD PAGES, AND SETS THEIR NEWPAG BITS. A PAGE HAS A CORRESPONDING
;OLD PAGE IFF AT THIS POINT IT HAS NONZERO PAGE NUMBERS.
;ALSO, CPRA MAKES SURE THAT FOLLOWING ANY RELISTED PAGE, ALL PAGES WITH THE
;SAME MAJOR PAGE NUMBER ARE ALSO RELISTED. THIS IS BECAUSE THEIR LINE NUMBER OFFSETS
;MAY HAVE CHANGED, AND ANYWAY WE AREN'T SMART ENOUGH TO HANDLE ASSIGNING LINE #S OTHERWISE.

CPRA9:	HLLZS 1(L)		;COME HERE AFTER FINDING AN ALTERED RANGE, WHEN IT
				;IS NECESSARY TO RE-LIST THE UNALTERED PAGE AFTER IT.

;COME HERE AFTER FINDING AN ALTERED PAGE.
;B HAS MAJOR AND MINOR PAGE #S, AND C -> ENTRY FOR,
;THE LAST UNALTERED PAGE FOUND.
CPRA1:	MOVE D,1(L)		;LOOK FOR NEXT UNALTERED PAGE
	TRNE D,-1		;THAT ENDS RUN OF ALTERED ONES.
	 JRST CPRA2
	ADD L,[2,,2]
	JUMPL L,CPRA1
	MOVEI D,.BM MAJPAG	;THERE IS NONE, PRETEND THERE'S A PAGE -#$gK+)ij*g f"i"b( cbH")*g'c S*"i"Q	VEQ$ iH2 g"3( cQt'djEa!P iH j!T(,F:5)'T!&P&Rg( cB1#$i)j*g!dg#bb( cbH")*g4'd'i(cbPKBP%*u!h) \HD]fUij)Vf$iU*$ U( cQ
P"f)QP+bSQ#bj( cbHP+' bP'EDDB+T'SP c*i'SUaFEfgk"RP)DD]R'kP&Pg,P S*"i"Q( cQiP$gIP)YijaP)!TFEr)XDB]j$ U	fZH$
Kf"!'-fPe( cKWFf"!!d-ST V".B!'j$f*"iD biP U)	)YEagfbH$"i"Hi)Y' f*i"b cbiH!"j+QY*""b(cbiWr'kP*$j*gf*"iD bP jY!Xg)P P&Pe'iFijaP!d'FEige"H!d!T) \B]dciP''H*g*iQD`'i(cbPH!"j+QbgED]T*$`H(#PiP!,PTV*"gED]j$P f*i"b cbiH&jij$ k"H)`fbH2
BD`iP*"P()8$#P*gf*"ib'gWEQr!1$$P!d)DB]^Pf*"iD bi_OP kdf`e'i_EB]adHAS BASIC # OF PAGES FOR EACH MAJOR PG #.
		;CC HAS # OF MAJOR PG #S THAT NEED 1 EXTRA PG.
	IORI B,NEWPAG
CPRA6:	IORI B,.BM MINPAG	;INCREMENT TO NEXT MAJOR PAGE #.
	MOVEI R,(CH)
	SOSL CC
	 ADDI R,1		;R HAS # PAGES TO GET THIS MAJOR PG #.
CPRA7:	ADDI C,2
	CAIL C,(L)
	 JRST CPRA4
	ADDI B,1
	HRRM B,1(C)
	SOJG R,CPRA7		;INCREMENT EITHER MINOR PAGE #
	JRST CPRA6		;OR MAJOR PAGE #.

CPRA8:	JUMPE B,CPRA9		;PAGE INSERTED BEFORE PAGE 1? DON'T CALL IT 0/1; RELIST PG 1.
	IORI B,NEWPAG		;MARK ALTERED PAGES AS NEEDING LISTING.
CPRA3:	ADDI C,2		;POINT TO NEXT OF THEM.
	CAIL C,(L)
	 JRST CPRA4		;ALL OF THEM HANDLED.
	ADDI B,1		;GIVE EACH ALTERED PAGE SOME PAGE #S.
	HRRM B,1(C)		;INCREMENTING THE MINOR PG # EACH TIME.
	JRST CPRA3

CPRA:	SETZ B,			;B HAS MAJOR AND MINOR PG #S OF LAST UNCHANGED PAGE.
	SKIPL L,F.PAGT(A)
	 .VALUE
	MOVEI C,-2(L)		;C -> ENTRY FOR LAST UNCHANGED PG.
	DROPTHRUTO CPRA4	;WE START IN STATE OF LOOKING FOR NEW PG.

;AFTER HANDLING ONE RUN OF ALTERED PAGES, OR AT THE BEGINNING,
;SEARCH FOR THE BEGINNING OF THE NEXT.
CPRA4:	JUMPGE L,CPOPJ
	HRRZ D,1(L)
	JUMPE D,CPRA1
	HRRZ B,D
	HRRZ C,L
	ADD L,[2,,2]
	JRST CPRA4

SUBTTL	PASS 1 MAIN LOOP

1START:	SKIPN 1CKSFL		;IF WE DON'T NEED ANY CHECKSUMMING
	 SKIPN TEXTP		;AND WE DON'T HAVE ANY SYMBOLS,
	  JRST 1STAR1
	TLNE F,FLSUBT		;AND DON'T NEED TO SCAN FOR SUBTITLES
	 SKIPG TEXTP		;IN /L[RANDOM]
	  POPJ P,		;WE CAN SKIP PASS 1.
1STAR1:	MOVEI A,FILES
	MOVEM A,CFILE
	SETOM 1FCNT
	SETZM SUBTLS		;INITIALLY NO SUBTITLES IN LIST
	SETZM ADEFLS		;INITIALLY NO @DEFINE CRUD
	JRST 1LOOP

1DONE:	.CLOSE UTIC,		;DONE WITH A FILE
	MOVE P,PSAVE
	HRRZ A,CFILE
	MOVE B,NSYMSF		;REMEMBER HOW MANY SYMS AND HOW MANY PAGES
	MOVEM B,F.NSYM(A)	;THERE WERE IN THIS FILE.
	HLRZM N,F.NPGS(A)
	EXCH DP,LRCPTR		;PUSHES INTO SPACES MUST BE ON DP, SP, P - SEE PDLEXT.
	HRLZ CH,1CKSLN		;IF THERE WAS NO ^L AT THE END OF THE FILE,
	MOVE C,1CKSUM
	TLNE N,-1		;MAKE SURE A NULL FILE DOESN'T PRODUCE A ZERO-LENGTH PAGE TABLE.
	 JUMPE CH,1DONE2
				;MAKE A PAGETABLE ENTRY FOR THE UNTERMINATED PAGE.
	ADDI C,^L		;PRETEND THE PAGE WAS ENDED BY ^L, IN THE CHECKSUM, SO THAT
	ROT C,7			;MAKING A FOLLOWING PAGE WON'T MAKE THIS ONE BE RELISTED.
	PUSH DP,C
	PUSH DP,CH
1DONE2:	HRRZ B,F.PAGT(A)	;GET -LENGTH OF FILE'S PAGE TABLE
	SUBI B,1(DP)
	HRLM B,F.PAGT(A)	;STORE INTO LENGTH FIELD OF AOBJN PTR IN F.PAGT
	EXCH DP,LRCPTR
1DONE1:
ITS,	.SUSET [.SWHO1,,[0]]
	ADDI A,LFBLOK		;ADVANCE CURRENT FILE POINTER TO NEXT FILE.
	MOVEM A,CFILE
	DROPTHRUTO 1LOOP

;DROPS THROUGH.
;SET UP FOR PASS 1 PROCESSING OF FILE IN A.
1LOOP:	HRRZ A,CFILE		;GET POINTER TO NEXT FILE BLOCK
	CAML A,SFILE
	 POPJ P,		;JUMP OUT IF NO MORE
	MOVEM P,PSAVE
	SETZM 1CKSUM
	SETZM 1CKSLN
	SETZM 1CKSCF
	SETZM 1CKSNF
	SETZM 1CKSNN
	SETZM NSYMSF
	SETZM 1CKSIF
	SKIPGE TEXTP
	 SETOM 1CKSIF
	ANDCMI F,TEMPF		;FETCH INTO F THE TEMP. FLAGS OF THIS FILE.
	MOVE B,F.SWIT(A)
	ANDI B,TEMPF
	IOR F,B
	TRC F,FSARW+FSQUOT
	TRCE F,FSARW+FSQUOT	;DON'T DO PASS 1 ON OUTPUT-ONLY FILES.
	 TRNE F,FSLREC+FSNOIN	;OR OTHER FILES WE SHOULD IGNORE
	  JRST 1DONE1
	AOSE 1FCNT
	 SETOM MULTI		;DETECT THE PRESENCE OF MORE THAN 1 INPUT FILE.
	SKIPE TEXTP		;FOR /L[TEXT] AND /L[RANDOM]
	 SKIPL B,F.OLRC(A)	;WHERE THERE IS AN OLD LREC FILE
	  JRST 1LOOP3
	SKIPN NORENUM		;AND WE DON'T HAVE TO DROP GAPS
	 TRNE F,FSLALL+FSLRNM
	  JRST 1LOOP3
	MOVE B,3(B)
	CAME B,F.RFN2(A)	;AND THE EXTENSIONS MATCH
	 JRST 1LOOP3
	SKIPE B,F.OCRD(A)	;AND THE CREATION DATES AND TIMES MATCH
	 CAME B,F.CRDT(A)
	  JRST 1LOOP3
1NOCHG:	MOVEI B,FSNCHG		;WE CAN SKIP COMPARING.
	IORM B,F.SWIT(A)
	JRST 1DONE1

1LOOP3:	MOVEI R,.BAI
	PUSHJ P,2INOPN		;OPEN THE FILE.
	 JRST 1NOCHG		;DOESN'T EXIST => DON'T COMPLAIN NOW.  WE COMPLAINED BEFORE.
	PUSHJ P,2RDAHD		;INIT 1-WORD READ AHEAD FOR SAKE OF FLUSHING PADDING AT EOF.
	HRRZ B,LRCPTR
	ADDI B,1
	MOVEM B,F.PAGT(A)	;REMEMBER WHERE FILE'S PAGE TABLE STARTS.
	PUSHJ P,DOINPT		;FILL UP INPUT BUFFER.
	 JRST 1DONE
ITS,[	MOVE B,F.RFN1(A)
	.SUSET [.SWHO2,,B]
	.SUSET [.SWHO3,,[SIXBIT/P1 /+1]]
	.SUSET [.SWHO1,,[.BYTE 8 ? 166 ? 0 ? 165 ? 0]]
];ITS
	PUSHJ P,LNMTST		;SET LNDFIL IF LINE NUMBERS. SET ETVFIL IF ETV DIRECTORY
	SKIPE 1CKSFL		;IF CHECKSUMMING IS BEING DONE,
	 PUSHJ P,1CKS		;HANDLE WHAT THAT 1ST CALL TO INPUT GOT.
	MOVSI N,1		;INITIALIZE <PAGE #>,,<LINE #>-1
	SKIPN ETVFIL		;IF THERE'S A DIRECTORY, DON'T CHECK IT FOR SYMBOL DEFNS
	 JRST 1LOOP1
1LOOP2:	1GETCH			;SO READ THROUGH THE 1ST PAGE AS IF FOR /L[RANDOM]
	CAIN CH,^C
	 PUSHJ P,1MORE1
	CAIE CH,^L
	 JRST 1LOOP2
	MOVSI N,2
1LOOP1:	SKIPL A,CODTYP		;DISPATCH ACCORDING TO LANGUAGE FILE IS WRITTEN IN.
	 CAIL A,CODMAX
	  .VALUE
	JRST @.+1(A)
	OFFSET -.
CODMID::1MIDAS
CODRND::1RANDM
CODFAI::1FAIL
CODP11::1MIDAS			;MACRO-11/PALX IS SIMILAR TO MIDAS
CODLSP::1LISP
CODM10::1FAIL			;MACRO-10 IS SIMILAR TO FAIL
CODUCO::1UCONS
CODTXT::1RANDM
CODMDL::1MUDDL			;MUDDLE CODE
CODDAP::1DAPX			;DAPX16 CODE
CODMAX::OFFSET 0

SUBTTL PASS 1 CHECKSUMMING

;AFTER A BUFFERFUL (OR PART) HAS BEEN READ IN, DO PAGE-CHECKSUM
;PROCESSING ON IT, ADDING ENTRIES TO PAGE TABLE WHEN NECESSARY.
1CKS:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,IP
	AOSN 1CKSNF		;WERE WE IGNORING LINE NUMBERS?
	 SOJA IP,[IBP IP	;YES, MAKE SURE LH(IP) ISN'T 440700 CROCK
		PUSHJ P,1CKLN5	;AND KEEP CHECKING
		SKIPE 1CKSNF	;IF WE SKIPPED RIGHT THROUGH THE WHOLE BUFFER
		 JRST 1CKS6	;THEN GET OUT FAST
		JRST .+1 ]
	EXCH DP,LRCPTR
	MOVE A,1CKSLN		;COUNT OF # LINES IN PAGE KEPT IN A.
	HRRZ B,LASTIP		;PUT LASTIP WHERE IT CAN BE COMPARED WITH RH(IP)
	MOVE C,1CKSUM		;CHECKSUM ACCUMULATES IN C.
XGP,[	SKIPE 1CKXAD		;IF INSIDE 1CKXGP, REENTER IT.
	 JRST 1CKXRE
	SKIPE TEXGPP		;FOR XGP TEXT FILES SINCE ^L ISN'T ALWAYS END OF PAGE,
				;WE MUST USE A SPECIAL HAIRY PARSE ROUTINE.
	 JRST 1CKXGP		;DO THIS BEFORE CHECKING 1CKSIF, ETC, SINCE WE USE THEM DIFFERENTLY.
];XGP
	SKIPE 1CKSIF		;IF IGNORING 1ST LINE OF PAGE, KEEP IGNORING.
	 JRST 1CKSI1
	AOSN 1CKSCF		;IF PREVIOUS BUFFERFUL ENDED WITH CR
	 JRST 1CKSC3		;START THIS AS IF HANDLING A CR.
1CKS1:	ILDB CH,IP		;GET NEXT CHAR.
1CKS3:	ADDI C,(CH)		;UPDATE CHECKSUM WITH NEW CHAR.
	ROT C,7
	CAILE CH,^M		;IF CHAR IS DEFINITELY NOT SPECIAL,
	 JRST 1CKS1		;JUST GO ON TO NEXT ONE.
	JRST @1CKSTB(CH)	;CR, LF, FF AND ^C NEED EXTRA PROCESSING.

1CKSTB:		1CKSC		;^@
REPEAT 2,	1CKS1		;^A-^B
		1CKSC		;^C
REPEAT 6,	1CKS1		;^D-^I
		1CKSLF		;^J
		1CKS1		;^K
		1CKSFF		;^L
		1CKSCR		;^M
IFN .-1CKSTB-^M-1,.ERR WRONG TABLE LENGTH

1CKSFF:	PUSH DP,C		;^L - PUSH CHECKSUM AND LINE COUNT OF PAGE
	HRLZI A,(A)		;(THE LATTER ACTUALLY IN LH OF WORD)
	PUSH DP,A
	SETZB A,C		;THEN RE-INIT BOTH OF THEM.
	SKIPE LNDFIL
	 PUSHJ P,1CKLNM
	SKIPL TEXTP
	 JRST 1CKS1
	SETZM 1CKSNN		;SAY WE HAVEN'T YET FOUND A NON-NULL LINE.
	SETOM 1CKSIF		;IGNORE UP TO THE FIRST NON-NULL LINE OF EVERY PAGE.
1CKSI1:	CAIN B,(IP)		;END OF BUFFER => RETURN, BUT 1CKSIF IS SET SO WILL COME BACK.
	 JRST 1CKS5
	ILDB CH,IP
	CAIN CH,^L
	 JRST 1CKS1A		;DON'T BE CONFUSED BY PAGES CONTAINING NO NON-NULL LINES.
	CAIN CH,^J
	 JRST 1CKSI2		;END OF LINE => IS IT NON-NULL?
	CAIE CH,^M
	 SETOM 1CKSNN		;ANYTHING BUT ^M OR ^J INDICATES A NON-NULL LINE.
	JRST 1CKSI1

1CKSI2:	SKIPE LNDFIL		;GET HERE ON ^J
	 PUSHJ P,1CKLNM
	SKIPN 1CKSNN		;IF IT WAS NON-NULL, WE'RE FINISHED.
	 JRST 1CKSI1
	SETZM 1CKSIF		;AND DON'T COME BACK TO IGNORING.
	JRST 1CKS1

1CKSLF:	TLNE F,FLSCR		;LF - IF FLSCR SET, EVERY LF COUNTS AS A LINE.
	 ADDI A,1		;OTHERWISE, LINES ARE DETECTED BY THE CR-HANDLER
1CKS1A:	SKIPE LNDFIL
	 PUSHJ P,1CKLNM
	JRST 1CKS1

1CKSCR:	TLNE F,FLSCR		;CR - SEE IF IT'S PART OF A CRLF,
	 JRST 1CKS1		;(IF FLSCR SET, THE LINEFEED WILL TAKE CARE OF EVERYTHING)
1CKSC3:	ILDB CH,IP
	CAIN CH,^J
	 AOJA A,1CKS3		;IF IT'S A CRLF, INCREMENT THE LINE COUNT.
	CAIN CH,^C
	 CAIE B,(IP)
	  JRST 1CKS3		;IN ANY CASE, DON'T FORGET TO PUT ILDB'D CHAR IN THE CHECKSUM.
	SETOM 1CKSCF		;LOOK AHEAD FAILS DUE TO END OF BUFFER - SET FLAG
	JRST 1CKS3		;TO TRY 1CKSCR AGAIN WHEN NEXT BUFFER IS CHECKSUMMED.

;COME HERE WHEN ^C OR ^@ SEEN WHILE CHECKSUMMING.
1CKSC:	CAIN B,(IP)		;FIRST, MAYBE THE ^C MEANS END OF BUFFER.
	 JRST 1CKS4
	SKIPLE LFILE		;IF EOF HASN'T BEEN REACHED BY INPUT-BUFFER FILLING YET,
	 JRST 1CKSC4		;MUST ASSUME ^C IS NOT EOF.
	PUSH P,IP
1CKSC1:	CAIN B,(IP)		;LOOK AHEAD AT REST OF INPUT BUFFER.
	 JRST 1CKSC2		;REACH END WITHOUT SEEING ANYTHING BUT ^C AND ^@ => AT EOF.
	ILDB CH,IP
	JUMPE CH,1CKSC1
	CAIE CH,^L
	 CAIN CH,^C
	  JRST 1CKSC1
	POP P,IP		;CHAR. OTHER THAN ^C OR ^@ FOLLOWS =>
1CKSC4:	MOVEI CH,^C
ITSXGP,[SKIPE 1CKXAD		;IF THE ^C WAS SEEN INSIDE 1CKXGP, RETURN TO IT.
	 JRST @1CKXAD
];ITSXGP
	JRST 1CKS1		;THE ^C DOES NOT MEAN EOF.

;WE REACHED A ^C OR ^@ THAT MEANS EOF; ACT LIKE END-OF-PAGE.
1CKSC2:	POP P,IP
	LDB CH,IP

;THE WHOLE INPUT BUFFER HAS BEEN CHECKSUMMED, PLUS ONE ^C OR ^@ WHICH MEANT EOF OR EOB.
1CKS4:	ROT C,-7		;REMOVE SPURIOUS ^C FROM CHECKSUM.
	SUBI C,(CH)
1CKS5:	MOVEM C,1CKSUM
	MOVEM A,1CKSLN
	EXCH DP,LRCPTR
1CKS6:	POP P,IP		;RESET FOR PASS 1 READING
	POP P,C
POPBAJ:	POP P,B
POPAJ:	POP P,A
	POPJ P,

XGP,[
;CHECKSUMMING ROUTINE THAT KNOWS HOW TO FIND THE PAGE BREAKS IN XGP TEXT FILES.
1CKXGP:	PUSHJ P,1CKXGT
	CAIN CH,^L		;^L IS ONLY A PAGE BREAK IF READ HERE (NOT WITHIN AN XGP COMMAND)
	 JRST 1CKXFF
	CAIN CH,177		;XGP LIKE NON-XGP EXCEPT DETECT THE ESCAPE CHARACTER.
	 JRST 1CKXCM
1CKXNN:	SKIPN 1CKSIF		;SKIP IF STILL IGNORING UP TO 1ST NON-NULL LINE.
	 JRST 1CKXGP
	CAIE CH,^J
	 CAIN CH,^M
	  JRST 1CKXIF
	SETOM 1CKSNN		;NON-NULL-NESS SEEN WHILE IGNORING:
	JRST 1CKXGP		;  THIS IS LAST LINE TO IGNORE.

1CKXIF:	SKIPE 1CKSNN		;END OF IGNORED LINE: NON-NULL-NESS SEEN => STOP IGNORING.
	 SETZM 1CKSIF
	JRST 1CKXGP

1CKXCM:	PUSHJ P,1CKXGT		;HERE AFTER AN ESCAPE:  READ THE FOLLOWING CHARACTER
	CAILE CH,XGPMAX
	 JRST 1CKXGP
	XCT 1CKXTB(CH)		;AND DECODE IT ACCORDING TO THE XGP FORMAT WE KNOW ABOUT.
	 SETOM 1CKSNN		;NO SKIP MEANS THIS ESCAPE CODE CONSTITUTES NON-NULL DATA.
1CKXIG:	SOJL A,1CKXGP		;IGNORE (SKIP OVER NOT PARSING) THE NUMBER OF CHARS IN A.
	PUSHJ P,1CKXGT
	JRST 1CKXIG

1CKXIC:	PUSHJ P,1CKXGT		;READ CHAR, AND THAT IS NUMBER OF FOLLOWING CHARS TO SKIP.
	MOVEI A,(CH)
	JRST 1CKXIG

1CKXFF:	SKIPE LNDFIL		;ALTHOUGH LNDFIL SHOULDN'T HAPPEN
	 PUSHJ P,1CKLNM		;WE SHOULD CHECK ANYWAY
	PUSH DP,C		;FF: PUSH CHECKSUM INTO PAGE TABLE,
	PUSH DP,[0]		;AND A 0 INSTEAD OF THE LINE COUNT WHICH IS UNUSED IN THIS MODE,
	SETZ C,
	SETOM 1CKSIF		;SAY MUST NOW IGNORE PAST FIRST NON-NULL LINE.
	SETZM 1CKSNN		;AND SAY THAT WE HAVEN'T FOUND ANY NON-NULL-NESS YET.
	JRST 1CKXGP

;HERE TO REENTER 1CKXGT FOR A NEW BUFFERFULL.
1CKXRE:	PUSH P,1CKXAD
	MOVE A,1CKXA

;READ-CHARACTER ROUTINE FOR CHECKSUMMING OF /L[TEXT]/X FILES.
;IF REACH END OF BUFFER, RETURNS SAVING CALLER'S ADDRESS IN 1CKXAD
;AND A IN 1CKXA.
1CKXGT:	ILDB CH,IP
	SKIPE 1CKSIF		;IF IGNORING TEXT NOW, DON'T CHECKSUM THIS CHAR.
	 JRST 1CKXGX
	ADDI C,(CH)		;READ CHARACTER AND ADD INTO CHECKSUM.
	ROT C,7
1CKXGX:	CAIE CH,^C
	 POPJ P,
	POP P,1CKXAD		;PROCESS ^C AS USUAL, BUT REMEMBER WHERE TO COME BACK TO.
	MOVEM A,1CKXA
	JRST 1CKSC
];XGP

ITSXGP,[
1CKXTB:	JRST 1CKXGP	;RUBOUT-^@
	JRST 1CKXE1	;^A IS XGP ESCAPE 1
	SKIPA A,[1]	;^B IS XGP ESCAPE 2
	SKIPA A,[2]	;^C IS XGP ESCAPE 3
	SKIPA A,[9.]	;^D IS XGP ESCAPE 4
XGPMAX==:.-1CKXTB-1

;HERE TO READ THE CHARACTER AFTER THE SEQUENCE RUBOUT-^A
1CKXE1:	PUSHJ P,1CKXGT
	CAIGE CH,40	;RUBOUT-^A CODES LESS THAN SPACE TAKE NO ARGUMENT.
	 JRST 1CKXGP
	CAIN CH,40	;RUBOUT-^A-SPACE TAKES 2 CHARS OF ARGUMENT.
	 JRST 1CKXI2
	CAIN CH,42	;CODE 42 IS SPECIAL, SINCE IT ENDS A LINE.
	 JRST 1CKXLS
	CAIGE CH,44	;CODES 41 AND 43 TAKE ONE CHAR OF ARGUMENT.
	 JRST 1CKXI1
	CAIN CH,45	;CODE 45 FOLLOWED BY BYTE CONTAINING THE NUMBER
	 JRST 1CKXIC	;OF FOLLOWING BYTES TO IGNORE.
	CAIGE CH,47
	 JRST 1CKXGP	;CODES 44 AND 46 TAKE NO ARGUMENTS.
	CAIG CH,50
	 JRST 1CKXI1
	CAIN CH,51
	 JRST 1CKXI2
	CAIE CH,52
	 JRST 1CKXGP
1CKXI1:	SKIPA A,[1]
1CKXI2:	 MOVEI A,2
	JRST 1CKXIG

1CKXLS:	PUSHJ P,1CKXGT	;RUBOUT-^A-" TAKES ONE BYTE OF ARGUMENT.  SKIP IT.
	MOVEI CH,^J	;A LINE-SPACE COMMAND IS LIKE A LINEFEED,
	JRST 1CKXNN	;SO WE MUST CHECK WHETHER IT ENDS THE FIRST NON-NULL LINE.
];ITSXGP

CMUXGP,[	.SEE 2TEXGT
1CKXTB:	JRST 1CKXGP	;0  EOF
	SKIPA A,[2]	;1  VS
	SKIPA A,[2]	;2  LM
	SKIPA A,[2]	;3  TM
	SKIPA A,[2]	;4  BM
	SKIPA A,[2]	;5  LIN		-obsolete
	JRST 1CKXGP	;6  CUT
	JRST 1CKXGP	;7  NOCUT
	SKIPA A,[1]	;10 AK		-obsolete
	SKIPA A,[1]	;11 BK		-obsglE4e	PSD 	
7aQ^At1 (%'P@c#DfA'	[:e &O-0QQJA1 )SE1b+RQ c1	vTA+('AAY]DlA.4'AA-%lbnA!Y6cd&)SE1dI'(@c1 $vddA%7aQ^At1 (%'P@c#HfA20Ai^A'dA!JA1@I'(@c1 $vdhA#	t0A<CgeH0w2,#))jael#T]YH"afBv2z2HH4:2y7v:7H&'geH0w2,#))jael#T]Y!!fBv2z2C2)DaYP!UI3FiedTV-+]e))UaeVz]XP)"+t:2y7v:7H&'geH0w2,#))jael#T]YY!%'g2)Da6h!%fgkdP VD]YZ(jgj3g"dP KD]YMP'k)2)DaY[&gcVZy7:7	P0w2:42P#hEe))jr#.P!!gVtw2y70[:7P'gePw2:2P,#TBidh PV-Y.B]Z-4PM996CVh94Me[+Q[#$D4PM99Q3#Z*!4\M
6+PK[(JB	m4PM996C28h*%"4]Dz[#B,AVNwvz	IytZ!MTD=Q LU*:B.=	"]g&/-lbdy4vDFF*b:!%z K[Vu4InnLWvD&z	It|Zf"MRDzPPM99bQ3+
bX!4\M
6PK[V4,tAQ LU*:B.L16S"h*%"]1[+TUD,4PM996S2Xh*%"]1[+JliAQ LU*:B.L16c2`!4\M
6+PK[(JB	m'4PM996c6h94M	ekPK[fD4hP**5"95DL133*J4(JB	mVhh*%"4]Dz[3tduAVNwvz	IytZ!MTD=Q LU*:B.=6sJ*Q!UQ9bJ9`hlV4]E	i4Q9bJkB$c.=A8t-"Jtz+D*>uAQ!l}IB(Je9	cqQ!-"QF4]DzAPPLHD!b&|Dc.=9U,eIeJ9u,uD%JhJ4Bi&
$I	cAH!%&8hm[hAQ%,*JDb5	DLtT	e,l9X4ZJZ$Ltt4D,.&r8!Q hS94dsJBq2L(I9y(MH5}(HH9hU4-$4\MrJ4|rid-MI>	&r*	jYT-*1PS.bsW&B	c;K\Jdt8T$zr"	xd<}(APS.bt!4\M9BMQ J>R
	Aa92q5<}(D|2	jTdeij	yd}J	ddtJ`&d4Bc$HK&r*	jYT-'qPPJ	uRA`H9dzb*	zZB|d	-QQ L6)9K3et7e#}bVPK\YhB|d%,4!UQ:i%t(JBq2L$IhRuYX$-4	rI	&b+(I	BQ$HKiuBH4BYhB|d%,4hZ"dR*&-I59Nr0%YXYT-$t**	(&B	c;$HKX4*8Dd-$5}DDD*r"xeT,hhU>xh	uRA`hQ'5&F3~M~vNvt6~&TN6z^<V":ipK2{]nMb~-in6^Ow6/$FF*r"xeT,hhU '=2	DLtUYe,l(Z"FF*mDfdv2<j)4\'4&FTF4Q}!dFF*.V66q	^ahRluYX$-m~BTf!dvAQ#[F|D~26LT.<W*Mv/m~BT7\B>-wRz5h<MZc~=]lLN^5b=VNf-GJbB
<UYX_m~BD
