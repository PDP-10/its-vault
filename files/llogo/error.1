;;; Hey, Zwei, this file contains -*- Mode: Lisp; Package: User; Base: 10. ; -*-

(DEFCLASS ERROR OBJECT-CLASS (ERROR-MESSAGE PRODUCED-BY PRODUCED-HOW IN-ENVIRONMENT NAME))

;; Errors have to respond to many of the same messages as RESULTs.

(DEFMETHOD (ERROR :CODE) () (<- (<- SELF ':FORM) ':CODE))

(DEFMETHOD (ERROR :FORM) () (<- (<- SELF ':PRODUCED-BY) ':FORM))

(DEFMETHOD (ERROR :VALUE) (&OPTIONAL ENVIRONMENT) SELF)

(DEFMETHOD (ERROR :YOUR-VALUE) (&OPTIONAL ENVIRONMENT) SELF)

(DEFMETHOD (ERROR :RESULT) (&OPTIONAL ENVIRONMENT) SELF)

(DEFMETHOD (ERROR :RECREATE) () `(AN ERROR ,ERROR-MESSAGE))

(DEFMETHOD (ERROR :ARE-YOU) (WHAT) (EQ WHAT 'ERROR))

(DEFMETHOD (ERROR :ENVIRONMENT) () (<- SELF ':IN-ENVIRONMENT))

(DEFMETHOD (ERROR :ADVERTISEMENT) ()
	   (SQUEEZE-INTO (FUNCALL TINKER-SNAPSHOT-PANE ':SIZE-IN-CHARACTERS)
			 (FORMAT NIL "Error: ~A, Code: ~A"
				 (<- SELF ':ERROR-MESSAGE)
				 ;; Must produce STRINGS for values.
				 (FORMAT NIL "~S" (<- SELF ':CODE)))))

(DEFUN ERROR-CATCHING-EVAL (FORM)
       (*CATCH 'ERROR-CATCHER
	       (CONDITION-BIND ((NIL 'ERROR-CATCHER))
			       (LIST 'EVALUATION-SUCCEEDED (EVAL FORM)))))

(DEFUN ERROR-CATCHING-APPLY (FUNCTION ARGUMENTS)
       (*CATCH 'ERROR-CATCHER
	       (CONDITION-BIND ((NIL 'ERROR-CATCHER))
			       (LIST 'EVALUATION-SUCCEEDED (APPLY FUNCTION ARGUMENTS)))))

(DEFUN ERROR-CATCHER (ERROR-TYPE &REST ERROR-ARGS)
       (*THROW 'ERROR-CATCHER
	       (LIST 'EVALUATION-FAILED
		     ;; (ERROR-MESSAGE SI:%CURRENT-STACK-GROUP)
		     (FORMAT NIL "~A with ~A" ERROR-TYPE ERROR-ARGS)
		     )))

(DEFUN ERROR-MESSAGE (SG)
       ;; Magic function, given a stack group which caused an error,
       ;; produces the error message.
       ;; Loses for WRONG-NUMBER-OF-ARGUMENTS messages.
       (LET ((ETE (EH:SG-TRAP-TAG SG)))
	    (COND ((EQ (CAR ETE) 'EH:FUNCTION-ENTRY)
		   (ERROR-MESSAGE-WRONG-NUMBER-OF-ARGUMENTS SG))
		  ((WITH-OUTPUT-TO-STRING
		    (ERROR-MESSAGE)
		    (LET ((EH:ERROR-HANDLER-IO ERROR-MESSAGE)
			  (TERMINAL-IO ERROR-MESSAGE)
			  (STANDARD-OUTPUT ERROR-MESSAGE))
			 (FUNCALL (GET (CAR ETE) 'EH:INFORM) SG ETE)))))))

(DEFUN ERROR-MESSAGE-WRONG-NUMBER-OF-ARGUMENTS (SG)
       (LET* ((LOSING-FUNCTION
	       (EH:FUNCTION-NAME (AREF (EH:SG-REGULAR-PDL SG) (EH:SG-AP SG))))
	      (LOSING-ARGLIST (ARGLIST LOSING-FUNCTION)))
	     (FORMAT NIL "~S expected ~S arguments."
		     LOSING-FUNCTION
		     (COND ((NULL LOSING-ARGLIST) 0.)
			   ((LISTP LOSING-ARGLIST) (LENGTH LOSING-ARGLIST))
			   ('?)))))

(DEFUN LISP-ERROR? (OBJECT)
       (AND (ENTITYP OBJECT)
	    (<- OBJECT ':ARE-YOU 'ERROR)))

(DEFUN APPLY-LOOKING-FOR-ERROR (FUNCTION ARGUMENTS)
       ;; If any of the arguments is an error object, return the error object. 
       (COND ((ERROR-IN-LIST? ARGUMENTS))
	     (T (LET ((APPLIED-VALUE (ERROR-CATCHING-APPLY FUNCTION ARGUMENTS)))
		     (COND ((AND (LISTP APPLIED-VALUE)
				 (EQ (CAR APPLIED-VALUE) 'EVALUATION-SUCCEEDED))
			    (CADR APPLIED-VALUE))
			   ((<- ERROR ':NEW
				':ERROR-MESSAGE (CADR APPLIED-VALUE)
				':PRODUCED-BY (CONS FUNCTION ARGUMENTS))))))))

(DEFUN ERROR-IN-LIST? (ARGUMENT-LIST)
       ;; Depends on (CAR NIL) is NIL.
       (CAR (MEM #'(LAMBDA (IGNORE ARGUMENT) (LISP-ERROR? ARGUMENT))
		 NIL 
		 ARGUMENT-LIST)))

(DEFUN EVAL-BREAK-ON-ERROR (FORM)
       "Evaluates FORM, but if there's an error uses the cold-load-stream for a break."
       (CONDITION-BIND ((NIL
			 #'(LAMBDA (ERROR-TYPE &REST ERROR-ARGS)
				   (EVAL-BINDING-STREAM
				    TV:COLD-LOAD-STREAM
				    (LIST 'BREAK
					  (FORMAT NIL
						  "An ~S error: ~S"
						  ERROR-TYPE
						  ERROR-ARGS)))
				   ;; Refreshes the Tinker frame on the way back.
				   ;; Cold load stream messed it up.
				   (<- TINKER-FRAME ':REFRESH)
				   (VALUES 'EH:RETURN-VALUE T))))
		       (EVAL FORM)))

(DEFUN SEND-BREAK-ON-ERROR (TARGET MESSAGE)
       "Sends MESSAGE to TARGET, but if there's an error uses the
        cold-load-stream for a break."
       (CONDITION-BIND ((NIL
			 #'(LAMBDA (ERROR-TYPE &REST ERROR-ARGS)
				   (EVAL-BINDING-STREAM
				    TV:COLD-LOAD-STREAM
				    (LIST 'BREAK
					  (FORMAT NIL
						  "An ~S error: ~S"
						  ERROR-TYPE
						  ERROR-ARGS)))
				   (<- TINKER-FRAME ':REFRESH)
				   (VALUES 'EH:RETURN-VALUE T))))
		       (<- TARGET MESSAGE)))

(COMMENT
 
 ;;; Old try at it...
 
 (DEFUN TRY-CATCHING-ERRORS ()
	;; Uses Chineual documented error protocol. Doesn't work.
	(PRINC "> ")
	(DO ((FORM (READ) (READ)))
	    ((NULL FORM) 'DONE)
	    (CONDITION-BIND ((NIL ERROR-HANLDER))
			    (PRINT (EVAL FORM)))
	    (TERPRI)
	    (PRINC "> ")))
 
 (DEFUN TRY-CATCHING-ERRORS-SIMPLY NIL
	;; Snarfs all args given to error handler.
	(PRINC "> ")
	(DO ((FORM (READ) (READ)))
	    ((NULL FORM) 'DONE)
	    (CONDITION-BIND ((NIL (LAMBDA (&REST REST)
					  (PRINT REST)
					  (PROG NIL
						(RETURN 'RETURN 'COMMENT)))))
			    (PRINT (EVAL FORM)))
	    (TERPRI)
	    (PRINC "> ")))
 
 (DEFUN ERROR-HANDLER (CONDITION FORMAT-STRING PROCEEDABLE? RESTARTABLE? WHILE-IN-FUNCTION
		       &REST ERROR-OBJECTS)
	(TERPRI)
	(LEXPR-FUNCALL #'FORMAT T FORMAT-STRING ERROR-OBJECTS)
	(TERPRI)
	(FORMAT
	 T
	 "Condition: ~S ~%Proceedable?: ~S ~%Restartable: ~S ~%While-in-function: ~S ~%"
	 CONDITION PROCEEDABLE? RESTARTABLE? WHILE-IN-FUNCTION)
	;; Protocol for returning.
	(PROG NIL (RETURN ':RETURN 'COMMENT)))
 
 (DEFUN PROMPT-READ ()
	(TERPRI)
	(PRINC "> ")
	(READ))
 
 (DEFUN BREAK-ON-ERROR ()
	;; Snarfs all args given to error handler.
	(PRINC "> ")
	(DO ((FORM (READ) (READ)))
	    ((NULL FORM) 'DONE)
	    (CONDITION-BIND ((NIL (LAMBDA (&REST REST)
					  (FORMAT T "Error: ~s" REST)
					  (BREAK ERROR)
					  (PROG NIL
						(RETURN 'RETURN 'COMMENT)))))
			    (PRINT (EVAL FORM)))
	    (TERPRI)
	    (PRINC "> ")))
 
 
 (DEFUN ERROR-STACK-GROUP ()
	(SETQ ERROR-STACK-GROUP (MAKE-STACK-GROUP 'ERROR-STACK-GROUP))
	(STACK-GROUP-PRESET ERROR-STACK-GROUP
			    '(LAMBDA NIL (DO NIL
					     (NIL)
					     (LET ((SG THIS-STACK-GROUP))
						  (BREAK ERROR-STACK-GROUP)))))
	(SETQ THIS-STACK-GROUP SI:%CURRENT-STACK-GROUP)) 
 
 (DEFUN PRINT-ERROR ()
	(SI:EH-PRINT-ERROR-MESSAGE THIS-STACK-GROUP (SI:SG-TRAP-TAG THIS-STACK-GROUP) T))
 
 
 (DECLARE (SPECIAL COLLECT-OUTPUT-LIST OLD-TERMINAL-IO))
 
 (DEFUN EVAL-COLLECTING-OUTPUT (FORM)
	;; EVALs the FORM, returning a list of returned value, and string printed.
	(LET ((COLLECT-OUTPUT-LIST NIL))
	     (LET ((OLD-TERMINAL-IO TERMINAL-IO)
		   (STANDARD-OUTPUT #'COLLECT-OUTPUT-STREAM)
		   (ERROR-OUTPUT #'COLLECT-OUTPUT-STREAM)
		   ;; (SI:ERROR-HANDLER-IO #'COLLECT-OUTPUT-STREAM)
		   ;; (TERMINAL-IO #'COLLECT-OUTPUT-STREAM)
		   ;; (QUERY-IO #'COLLECT-OUTPUT-STREAM)
		   )
		  (LIST (EVAL FORM)
			(APPLY 'STRING-APPEND (NREVERSE COLLECT-OUTPUT-LIST))))))
 
 (DEFUN COLLECT-OUTPUT-STREAM (OP &OPTIONAL ARG &REST REST-ARGS)
	(SELECTQ OP
		 (:WHICH-OPERATIONS (FUNCALL OLD-TERMINAL-IO ':WHICH-OPERATIONS))
		 (:TYO (PUSH ARG COLLECT-OUTPUT-LIST))
		 (:STRING-OUT (PUSH ARG COLLECT-OUTPUT-LIST))
		 (OTHERWISE
		  ;; (STREAM-DEFAULT-HANDLER #'COLLECT-OUTPUT-STREAM OPERATION ARG REST-ARGS)
		  (COND (ARG (LEXPR-FUNCALL OLD-TERMINAL-IO OP ARG REST-ARGS))
			((LEXPR-FUNCALL OLD-TERMINAL-IO OP))))))
 
 
 
 
 (DEFUN EVAL-IN-ANOTHER-STACK-GROUP (FORM)
	(COND ((NOT (BOUNDP 'REMOTE-EVAL-STACK-GROUP))
	       (SETQ REMOTE-EVAL-STACK-GROUP
		     (MAKE-STACK-GROUP "Remote Eval Stack Group"))))
	(COND ((NOT (BOUNDP 'MAIN-STACK-GROUP))
	       (SETQ MAIN-STACK-GROUP SI:%CURRENT-STACK-GROUP)))
	(STACK-GROUP-PRESET REMOTE-EVAL-STACK-GROUP
			    #'EVAL-AND-STACK-GROUP-RETURN
			    FORM)
	(FUNCALL REMOTE-EVAL-STACK-GROUP))
 
 (DEFUN EVAL-AND-STACK-GROUP-RETURN (FORM)
	(CONDITION-BIND ((NIL STACK-GROUP-ERROR-HANDLER))
			(LET ((GOOD-VALUE (EVAL FORM)))
			     (FUNCALL MAIN-STACK-GROUP GOOD-VALUE))))
 
 (DEFUN STACK-GROUP-ERROR-HANDLER (&REST ERROR-ARGS)
	(LET ((ERROR-VALUE (FUNCALL MAIN-STACK-GROUP (LIST "Error happened!" ERROR-ARGS))))
	     (PROG NIL (RETURN 'EH:RETURN-VALUE ERROR-VALUE))))
 
 )
