
TITLE TENLOD

.INSRT DSK:JSF;STNDRD MACROS

MOBY==0		;FOR 16K

OLDSW==1	;0 OR 1, 1 => LOADING INTO PDP10 FROM PDP6

SUDTSW==1	;INCLUDE SUDTAP MONITORING


;AC DEFINITIONS

FF=0
A=1
AA=2
B=3
C=4
D=5
E=6
F=7	;TEMPORARY FLAGS
G=10
S=13	;.SLEEP AC, SOMETIMES CLOBBERED TO -1 BY INTERRUPT ROUTINE
T=14
TT=15
Q=16
P=17

;IO CHANNELS

UTYIC==3	;LOADER IN
UTYOC==4	;DUMPER OUT
USRIC==6	;PDP10 IN
USROC==7	;PDP10 OUT

;FLAG DEFINITIONS

GETTY==RHF FF,1		;ONE => GE TTY
PDPO==RHF FF,2		;ONE => PDP10 IS OPEN
ARGF==RHF FF,4		;ARGUMENT TYPED
ARGCF==RHF FF,10	;ARGUMENT COMPLETED
UTYIO==RHF FF,20	;CLOSE UTYIC ON ERROR
FFFLG==RHF FF,40	;USED BY GETFIL
LAFLG==RHF FF,100	;NOT USED BUT LOOKED AT BY GETFIL
MINUSF==RHF FF,200	;MINUS SIGN TYPED
RTYIF==RHF FF,400	;RUBOUT TYPED AT RTYI, OTHERWISE AVAIL. FOR MISC.
NTYO==RHF FF,1000	;CERTAIN ROUTINES SHOULD TYPE TO ALTERNATE LOCATION INSTEAD OF TYO
SDTSW==RHF FF,2000	;IN AND NOT ABOUT TO LEAVE SUDTAP MODE
SILNT==RHF FF,4000	;SILENCE TYPEOUT
WAKUPF==RHF FF,10000	;USED BY 10SLP AND TSINT TO CONTROL WAKING UP FROM SLEEP
SDTSW2==RHF FF,20000	;ENTER SUDTAP MODE ON NEXT SLEEP THIS COMMAND
UNECHF==RHF FF,40000	;TYI NOT TO ECHO
	;LH(FF) USED BY SUDTAP MONITOR

;RANDOM

DDT=MOBY+34000	;STARTING ADDRESS OF DDT
10HIGH=MOBY+40000	;1 MORE THAN TOP OF PDP10 MEMORY
MACAC==4	;AC DDT PICKS UP STARTING ADDRESS FROM
MACQ==6		;HEH, HEH
10T==5		;AC T IN DDT
10P==1		;AC P IN DDT
MACCR=37777+MOBY	;MACDMP COMMAND POINTER
LPDL==40	;LENGTH OF PDL
UTIBFL==200	;LENGTH OF LOADER BUFFER
TOBS==10	;QUANTUM (NUMBER OF WORDS) FOR TYPOC (PSEUDO-TYO)
LCMBUF==40	;LENGTH OF TYPEIN BUFFER
PDPTTY==4	;PDP10 CONSOLE (TTY) NUMBER
IODEV PI,PI	;SO TSDDT WILL PRINT IT OUT
SIGN==400000	;18. BIT TWO'S COMPLEMENT SIGN BIT

	;TEMPORARY FLAGS

	;LOADER

CLRCF==RHF F,1		;CLEAR CORE
CLRDF==RHF F,2		;CLEAR CORE BELOW DDT
KSYMF==RHF F,4		;KILL SYMS DDT ALREADY HAS
LSYMF==RHF F,10		;LOAD SYMBOLS
LOADF==RHF F,20		;LOAD PROGRAM
LDDTF==RHF F,40		;CLEAR CORE AND LOAD DDT FIRST
STRTF==RHF F,100	;SET STARTING ADDRESS
GOF==RHF F,200		;START UP PROGRAM
DDTGF==RHF F,400	;START UP DDT
DDTPGF==RHF F,1000	;START UP PROGRAM VIA DDT
NRLODF==RHF F,200000	;DON'T READ FILE FOR PROGRAM LOAD
DCCDF==RHF F,400000	;DON'T CLOSE UTYIC WHEN DONE LOADING

P2MSK==CLRDF\KSYMF\LSYMF\GOF\DDTGF

	;MACROS

	;COMMAND DEFINITION MACRO

DEFINE CMD CHAR,ROUT,BLURB
DEF CHR,\<CHAR>-40,[
ROUT
]
IFSE [BLURB],CONCAT CHB,\<CHAR>-40,==0
IFSN [BLURB],CONCAT CHB,\<CHAR>-40,==[ASCIZ \BLURB\]
TERMIN

	;INITIALIZE COMMAND DISPATCH AND BLURB TABLES

IF1,[REPEAT 100,[CONCAT CHR,\.RPCNT,==0
CONCAT CHB,\.RPCNT,==0
]
]

	;MACRO TO GIVE SYMBOLIC NAMES TO PDP10 LOCATIONS ENDING (RATHER
	;THAN BEGINNING) AT A CERTAIN LOCATION

DEFINE TAG ADR
ADR=TGOFST+.
TERMIN

DEFINE TGPREP LOCTN
TGOFST==LOCTN-.
TERMIN

		;INTERRUPT THE PDP10

DEFINE IPDP10
.IPDP USROC,
TERMIN

FOO==.
LOC	41
	JSR UUOH
LOC	FOO

DEFINE UUOIRP A
IRPS UUO,,[GET BGET PUT BPUT
ACCESS CTYPE TYPE ERR]
A
TERMIN
TERMIN

UUOIRP MINUUO==77-.IRPCNT,	;GET OP CODE OF MINIMUM UUO
UUOIRP UUO=<MINUUO+.IRPCNT>_33,	;DEFINE UUO'S

UUOH:	0		;UUO PROCESSOR
	PUSH P,A	;SAVE A
	PUSH P,AA	;SAVE AA
	PUSH P,B	;SAVE B
	PUSH P,C
	MOVEI C,-C(P)	;FOR ACRLOC
	HRRZ B,40	;GET EFFECTIVE ADDRESS FOR UUO ROUTINE
	LDB AA,[270400,,40]	;GET AC FIELD FOR UUO PROCESSOR
	LDB A,[331100,,40]	;GET OP CODE
	CAIGE A,MINUUO	;IF TOO SMALL,
ILUUO:	.VALUE		;THEN COMPLAIN
	PUSHJ P,@UUODTB-MINUUO(A)	;CALL ROUTINE FOR INDIVIDUAL UUO
	JRST .+2	;NON-SKIP RETURN POINT
	AOS UUOH	;ROUTINE SKIPPED, INCREMENT RETURN POINT
	POP P,C		;RESTORE C
	POP P,B		;RESTORE B
	POP P,AA	;RESTORE AA
	POP P,A		;RESTORE A
	JRST 2,@UUOH	;RETURN

UUODTB:	UUOIRP A!UUO	;DISPATCH TABLE

		;MAYBE RELOCATE AA (DOESN'T WORK FOR 0)

ACRLOC:	CAIG AA,C	;IF .LE. MAXIMUM PUSHED AC,
	ADDI AA,(C)	;THEN RELOCATE TO POINT TO AC ON PDL
	POPJ P,

		;GET THE CONTENTS OF THE AC POINTED TO BY AA INTO A

GETAC:	PUSHJ P,ACRLOC	;RELOCATE AA
	MOVE A,(AA)	;GET THE AC
	POPJ P,

		;RELOCATE AA, HRRO IT INTO A, AND SKIP-RETURN

GETACP:	PUSHJ P,ACRLOC	;RELOCATE AA
	HRROI A,(AA)	;GET THE AOBJN POINTER TO IT
	JRST POPJ1	;SKIP-RETURN

	;GET AC,ADR	;GETS THE CONTENTS OF ADR (IN THE PDP10) INTO AC
	;BGET AC,ADR	;GETS PDP10 CORE BLOCK STARTING AT ADR INTO BLOCK IN PDL6SPECIFIED BY AOBJN POINTER IN AC

AGET:	PUSHJ P,GETACP	;GET AOBJN POINTER TO AC, SKIP OVER .+1
ABGET:	PUSHJ P,GETAC	;GET AOBJN POINTER FROM AC
	.ACCESS USRIC,B	;SET UP POINTER TO PDP10 CORE
	.IOT USRIC,A	;DO THE TRANSFER
	POPJ P,

	;PUT AC,ADR	;PUT CONTENTS OF AC INTO PDP10 LOCATION ADR
	;BPUT AC,ADR	;PUT PDP6 BLOCK SPECIFIED BY AOBJN POINTER IN AC INTO PDP10 BLOCK STARTING AT ADR

APUT:	PUSHJ P,GETACP	;GET AOBJN POINTER TO AC, SKIP-RETURN
ABPUT:	PUSHJ P,GETAC	;GET AOBJN POINTER FROM AC
	.ACCESS USROC,B	;SET UP POINTER TO PDP10 CORE
	.IOT USROC,A	;DO THE TRANSFER
	POPJ P,

		;ACCESS IOCH,ADR	;SAME AS OLD VERSION OF .ACCESS

AACCES:	DPB AA,[270400,,.+1]	;DEPOSIT IO CHANNEL
	.ACCESS B	;DO THE ACCESS
	POPJ P,

		;CTYPE "CH	;TYPE OUT THE ASCII CHARACTER CH (PUSHJ TO TYO)

ACTYPE:	MOVE A,B	;GET CHARACTER IN A
	JRST TYO	;TYPE IT OUT AND RETURN

		;TYPE [ASCIZ /STRING/]	;TYPE OUT "STRING" CALLING TO TYO

ATYPE:	JUMPE B,CPOPJ	;IF EFFECTIVE ADDRESS ZERO THEN JUST RETURN
	HRLI B,(ASBP)	;TURN INTO BYTE POINTER
TYPEL:	ILDB A,B	;GET CHARACTER
	JUMPE A,CPOPJ	;IF ZERO THEN THAT'S ALL
	PUSHJ P,TYO	;NON-ZERO, TYPE IT OUT
	JRST TYPEL

AERR:	TESTF E,UTYIO	;IF UTYIC SHOULD BE CLOSED,
	.IOPDL		;THEN RESET IO PDL,
	TMODF ZE,UTYIO	;...
	.CLOSE UTYIC,	;AND CLOSE IT
	PUSHJ P,ATYPE	;TYPE OUT THE TEXT STRING,
	LDB A,[270400,,40]	;GET AC FIELD,
	CAIL A,NERRS	;IF ILLEGAL AC FIELD,
ILLERR:	.VALUE		;THEN COMPLAIN
	MOVE P,[-LPDL,,PDL]	;RESTORE PDL,
	JRST @ERRDTB(A)	;GO TO RETURN POINT

ERRDTB:	ERRET		;0, NORMAL ERROR RETURN POINT
NERRS==.-ERRDTB
IFGE NERRS-20,[PRINTC /TOO MANY ERR DISPATCHES.
/]

IF1,[
TYIC==1
TYOC==2
TYIMOD==30	;DDT MODE, OLD MODE
TYOMOD==1	;ASCII OUTPUT
]

INITTY:	CLEARF UNECHF	;TENLOD TO ECHO WHAT THE SYSTEM DOESN'T
	MOVEI A,TYIMOD
ISITTY:	HRLM A,TYIOPN
	.OPEN TYIC,TYIOPN
	.VALUE
	.OPEN TYOC,TYOOPN
	.VALUE
	.STATUS TYOC,A
	TRNN A,77#2	;SKIP IF NOT GE (OR CHANNEL CLOSED)
	TMODF OA,GETTY	;GE CONSOLE
	CLEARF GETTY	;PROBABLY NEVER USED BUT IT LOOKS LIKE A GOOD IDEA
	POPJ P,

IMITTY:	SETF UNECHF	;TENLOD NOT TO ECHO ANYTHING
	MOVEI A,24
	HRLM A,TYIOPN
	.OPEN TYIC,TYIOPN
	.VALUE
	POPJ P,

TYIOPN:	SIXBIT /   TTYTENLODINPUT/
TYOOPN:	TYOMOD,,SIXBIT /   TTYTENLODOUTPUT/

CRLF:	JSP A,CRCFT	;TTY => TYPE CRLF, GE => TYPE CRLF ALSO
	12

CRFF:	JSP A,CRCFT	;GE => TYPE CRFF
	14

CRRR:	JSP A,CRCFT	;GE => TYPE CR*
	"*

CRCFT:	PUSH P,(A)	;SAVE CHARACTER TO TYPE OUT IF GE
	MOVEI A,15	;GET CARRIAGE RETURN IN A
	PUSHJ P,TYO	;TYPE IT OUT
	POP P,A		;RESTORE CHARACTER TO TYPE OUT IF GE
	TESTF N,GETTY	;IF TELETYPE RATHER THAN GE,
	MOVEI A,12	;THEN USE LINE FEED INSTEAD

		;TYPE OUT THE CHARACTER IN A IF TYPEOUT NOT SILENCED

TYO:	TESTF N,SILNT
TYOAE:	.IOT TYOC,A
CPOPJ:	POPJ P,

SPACE4:	PUSHJ P,.+1	;TYPE FOUR SPACES
SPACE2:	PUSHJ P,.+1	;TYPE TWO SPACES
SPACE:	MOVEI A,40	;SPACE
	JRST TYO

		;ROUTINE TO TYPE OUT THE SIXBIT WORD IN AA

SIXTYO:	JUMPE AA,CPOPJ	;IF AA CLEAR THEN RETURN
	MOVEI A,0	;CLEAR A
	LSHC A,6	;SHIFT CHARACTER INTO A
	ADDI A,40	;CONVERT TO ASCII
	PUSHJ P,TYO	;TYPE IT OUT
	JRST SIXTYO	;GO GET REST

CTLSI:	CLEARF SILNT	;CONTROL S READ BY TYI, UN-SILENCE TYPEOUT
	PUSHJ P,CRLF	;ACKNOWLEDGE WITH CRLF
IFN SUDTSW,[TESTF E,SDTSW	;IF IN SUDTAP MODE,
	POPJ P,]	;THEN RETURN WITH CHARACTER
		;DROPS THROUGH
	;GET A TYPED IN CHARACTER IN A, ECHO IT IF NECESSARY

TYI:	.IOT TYIC,A	;GET THE CHARACTER
	CAIN A,^S	;IF CHARACTER IS CONTROL S,
	JRST CTLSI	;THEN UN-SILENCE TYPEOUT, TYPE CRLF, AND TRY AGAIN
IFN SUDTSW,[
	TESTF E,UNECHF	;IF ECHO SUPPRESSED,
	POPJ P,		;THEN DON'T LET IT HAPPEN
]
	CAIE A,11	;IF CHARACTER IS TAB,
	CAIN A,^R	;OR IF CHARACTER IS CONTROL R,
	JRST TYOAE	;THEN ECHO AND RETURN
	CAIE A,15	;IF CHARACTER IS CARRIAGE RETURN,
	CAIN A,12	;OR LINE FEED,
	JRST TYOAE	;THEN ECHO AND RETURN
	POPJ P,		;NONE OF THESE, NOT NECESSARY TO ECHO

	;ROUTINE TO INPUT CHARACTERS FROM TTY ALLOWING RUBOUT BACK TO CARRIAGE RETURN
		;LCMBUF=LENGTH OF COMMAND BUFFER

RTYI:	ILDB A,CMDPTR	;GET CHARACTER
	JUMPN A,CPOPJ	;IF NON-ZERO THEN THAT'S ALL
	PUSH P,B	;SAVE B
	PUSHJ P,RTYI0	;READ IN STRING
	POP P,B
	JRST RTYI	;NOW TRY IT AGAIN

RTYI0:	MOVE B,[010700,,CMDBUF-1]
	MOVEM B,CMDPTR	;INITIALIZE COMMAND POINTER
RTYI1:	PUSHJ P,TYI	;GET CHARACTER
	CAIN A,177	;IF RUBOUT,
	JRST RTYIRB	;THEN RUB OUT
	IDPB A,B	;NOT RUBOUT, USE IT
	CLEARF RTYIF	;INDICATE LAST CHARACTER WAS NOT RUBOUT
RTYIDL:	CAIE A,15	;IF NOT CR (OR OTHER DELIMITER (RH MAYBE MODIFIED)),
	JRST RTYI1	;THEN GO BACK FOR MORE
	MOVEI A,0
	IDPB A,B	;MARK END OF STRING
	POPJ P,

RTYIRB:	CAMN B,[010700,,CMDBUF-1]	;IF AT BEGINNING OF STRING,
	JRST RTYIR1	;THEN TYPE CRLF AND GET MORE
	LDB A,B		;GET PREVIOUS CHARACTER,
	PUSHJ P,TYO	;TYPE IT OUT
	ADD B,[070000,,0]	;DECREMENT POINTER
	JUMPGE B,RTYI1	;NO WORD BOUNDARY PROBLEMS
	SUB B,[430000,,1]	;MAKE POINT TO PREVIOUS WORD
	JRST RTYI1

RTYIR1:	TMODF OE,RTYIF	;SET "RUBOUT TO BEGINNING OF BUFFER" FLAG, AND IF ALREADY SET,
IFE SUDTSW,	ERR HUH		;RETURN TO COMMAND LEVEL ON ERROR CONDITION
IFN SUDTSW,	JRST RTYIR2
	PUSHJ P,CRLF	;BEGINNING OF STRING, TYPE CRLF
	JRST RTYI1	;GET MORE CHARACTERS

CMDPTR:	0		;POINTER FOR RTYI TYPEIN PASS 2
CMDBUF:	BLOCK LCMBUF	;BUFFER FOR COMMAND TYPEIN

GETFIL:	PUSHJ P,SPACE	;TYPE OUT A SPACE
	SETF FFFLG	;USED TO KEEP TRACK OF FILENAME COUNT
GFIL1:	MOVEI C,0	;INITIALIZE WORD
	MOVE B,[440600,,C]	;SET UP BP FOR INPUT
GFIL2:	PUSHJ P,RTYI	;GET CHARACTER IN A
	CAIN A,":	;IF COLON...
	JRST GCOL	;THEN PROCESS AS SUCH
	CAIN A,";	;SIMILARLY FOR SEMICOLON
	JRST GSEMC
	CAIN A,15	;IF CARRIAGE RETURN...
	MOVEI A,0	;THEN CLEAR A
	CAIN A,"	;IF CONTROL Q...
	JRST GFILCQ	;THEN GET NEXT CHARACTER AND TREAT AS NON-SYNTACTICAL
	CAILE A,40	;LOGICAL SPACE? (INCLUDING CR)
	JRST GFILC
	JUMPE C,GFIL5	;IGNORE NULL FILENAMES
	EXCH C,FN2
	TMODF ZE,FFFLG
	MOVSI C,(SIXBIT /@/)
	MOVEM C,FN1	;MOVE SECOND TO FIRST
GFIL5:	JUMPN A,GFIL1	;A=0 IF CHARACTER=CR OR ENABLED LA
	POPJ P,		;DONE
GCOL:	JUMPE C,GFIL1	;IF HE WANTS THE NULL DEVICE HE GETS TO TYPE IT IN
	HLRM C,DNAM	;MOVE TO RH OF DEVICE LOCATION
	JRST GFIL1	;LOOP
GSEMC:	JUMPE C,GFIL1	;NO NULL SYSTEM NAMES PLEASE
	MOVEM C,SNAM	;MOVE TO SYSTEM NAME LOCATION
	JRST GFIL1	;LOOP
GFILCQ:	PUSHJ P,RTYI	;CONTROL Q EATS UP THE NEXT CHARACTER
GFILC:	SUBI A,40	;CONVERT CHARACTER TO SIXBIT
	TLNE B,770000	;TOO MANY CHARACTERS?
	IDPB A,B	;NO
	JRST GFIL2	;LOOP

	;FFFLG USED TO SORT OUT FILENAMES

DNAM:	(SIXBIT /DSK/)	;ROUTINE OUTPUTS HERE
FN1:	SIXBIT /@/
FN2:	SIXBIT /@/
SNAM:	0		;SYSTEM NAME

BEG:	MOVEI FF,0	;INITIALIZE FLAGS
	MOVE P,[-LPDL,,PDL]
	.SUSET [.RSNAM,,SNAM]	;GET INITIAL SYSTEM NAME
	.SUSET [.SMASK,,IMSK]	;SET INTERRUPT MASK
	.SUSET [.SMSK2,,IMSK2]	;ALSO FOR SECOND WORD
	.SUSET [.SPICL,,[-1]]	;NOT PROCESSING INTERRUPTS
	PUSHJ P,INITTY	;INITIALIZE TTY
	PUSHJ P,KSYMS	;KILL SYMBOLS IF ANY
	SETZM SVSYMP	;INDICATE NO POINTER TO DDT INITIAL SYMS BEING SAVED
	IFN SUDTSW,PUSHJ P,SUDINI	;INITIALIZE SUDTAP MONITOR
	PUSHJ P,CRFF	;TYPE CRLF OR CRFF
	TYPE [ASCIZ /TENLOD./]
	MOVE AA,[.FNAM2]
	PUSHJ P,SIXTYO
	PUSHJ P,10INIT	;MUST BE LAST IN INITIALIZATION DUE TO POSSIBILITY OF FAILURE

GCMD1:	PUSHJ P,CRRR
ERRET:	CLEARF ARGF\ARGCF\MINUSF\RTYIF\NTYO\SDTSW\WAKUPF\SDTSW2\UNECHF
	SETZM OVAL
	SETZM DVAL
	SETZM VALUE
	SETZM CMDPTR	;COMMAND POINTER FOR TYPEIN WITH RUBOUT
	MOVEI A,15
	HRRM A,RTYIDL	;INITIALIZE DELIMITER FOR RTYI
GCMD:	PUSHJ P,TYI
	CAIL A,40
	CAILE A,140
	JRST N6B	;NOT SIXBIT
	MOVEI T,-40(A)
	IDIVI T,3
	LDB T,DTBP(TT)
	JUMPE T,ERRET	;IF NOT COMMAND THEN CLEAR STATUS OF ARG, BUT OTHERWISE IGNORE
	PUSHJ P,(T)
	JRST GCMD1	;ROUTINE DIDN'T SKIP, REINITIALIZE ARGUMENTS
	JRST GCMD	;ROUTINE SKIPPED, DON'T REINITIALIZE
	JRST ERRET	;ROUTINE SKIPPED TWICE, REINITIALIZE BUT DON'T TYPE CRRR

N6B:	CAIN A,177	;IF RUBOUT,
	ERR HUH		;THEN RESET COMMAND STATUS
IFN SUDTSW,[CAIN A,^X	;IF THE NON-SIXBIT WAKE-UP CHARACTER,
	JRST GCMD1	;THEN GO KERCHINK
]
		;INSERT OTHER NON-SIXBIT COMMANDS HERE
	JRST ERRET	;REINITIALIZE ARGUMENT STATUS, OTHERWISE IGNORE

		;COMMAND DISPATCH TABLE

DTBP:	POINTS 12.,DTB(T)

DTB:	.BYTE 12.
	REPEAT 100,[CONCAT CHR,\.RPCNT
]
	.WALGN
	.BYTE

	CMD "?,QUEST,LIST COMMANDS

QUEST:	MOVE B,[441400,,BTB]
	MOVEI T,40
	PUSHJ P,CRFF
	TYPE [ASCIZ /   SILENCE TYPEOUT
   WAKE UP FROM SLEEP
/]
QUESTL:	ILDB AA,B
	CAIN AA,7777	;DONE?
	POPJ P,		;YES
	JUMPE AA,QUSTL2	;NO, BUT JUMP IF INACTIVE CHARACTER
	MOVE A,T	;GET COMMAND CHARACTER IN A
	PUSHJ P,TYO	;TYPE OUT THE CHARACTER
	PUSHJ P,SPACE4	;TYPE 4 SPACES
	TYPE (AA)	;TYPE THE BLURB
	PUSHJ P,CRLF	;NEW LINE
QUSTL2:	AOJA T,QUESTL

		;GET THE CURRENT VALUE INTO A AND SKIP, OR DON'T SKIP IF NO VALUE

ARGET:	TESTF N,MINUSF	;IF MINUS NOT TYPED,
	SKIPA A,VALUE	;THEN RETURN VALUE
	MOVN A,VALUE	;RETURN NEGATIVE OF VALUE
	TESTF E,ARGF
POPJ1:	AOS (P)		;ARGUMENT EXISTS
	POPJ P,

		;NUMBERS

	REPEAT 10.,CMD "0+.RPCNT,NUM

NUM:	TESTF E,ARGCF
	ERR HUH		;ERROR IF CURRENT VALUE COMPLETED
	SUBI A,"0	;CONVERT CHARACTER TO DIGIT
	MOVEI AA,10	;UPDATE OCTAL VALUE
	IMULM AA,OVAL
	ADDM A,OVAL
	MOVEI AA,10.	;UPDATE DECIMAL VALUE
	IMULM AA,DVAL
	ADDM A,DVAL
	MOVE AA,CRADIX	;UPDATE VALUE IN CURRENT RADIX
	IMULM AA,VALUE
	ADDM A,VALUE
	SETF ARGF
	JRST POPJ1	;SKIP-RETURN SO NOT TO KILL CURRENT VALUE

	CMD ".,PT,FORCE CURRENT VALUE TO DECIMAL
	CMD "',SQUOT,FORCE CURRENT VALUE TO OCTAL
PT:	SKIPA A,DVAL
SQUOT:	MOVE A,OVAL
	TMODF ZE,ARGF	;BARF IF NO ARGUMENT
VALRET:	TMODF OE,ARGF	;ENTRY TO RETURN VALUE IN A, BARF IF ARGUMENT
	ERR HUH
	TMODF OE,ARGCF	;BARF IF CURRENT VALUE COMPLETE
	ERR HUH		;ERROR IF NO CURRENT VALUE OR CURRENT VALUE COMPLETED
	MOVEM A,VALUE
	JRST POPJ1

OVAL:	0	;CURRENT VALUE, UPDATED IN OCTAL
DVAL:	0	;CURRENT VALUE, UPDATED IN DECIMAL
VALUE:	0	;CURRENT VALUE, UPDATED IN CURRENT RADIX, OR FINAL
CRADIX:	8	;CURRENT RADIX
RCHAR:	"'	;CHARACTER TO DOCUMENT RADIX ON TYPEOUT


	CMD "R,RDXSEL,SELECT DEFAULT RADIX

RDXSEL:	PUSHJ P,ARGET	;GET ARGUMENT IN A
	ERR HUH		;NO ARGUMENT SPECIFIED
	MOVEM A,CRADIX	;SET RADIX
	MOVEI B,177	;DEFAULT "RADIX IDENTIFICATION CHARACTER" NON-PRINTING
	CAIN A,8	;IF OCTAL,
	MOVEI B,"'	;THEN USE SINGLE QUOTE
	CAIN A,10.	;IF DECIMAL,
	MOVEI B,".	;THEN USE PERIOD
	MOVEM B,RCHAR
	POPJ P,

	CMD "=,EQLS,PRINT OUT VALUE IN CURRENT RADIX

EQLS:	PUSHJ P,ARGET	;GET ARGUMENT
	ERR HUH		;TYPE OUT VALUE OF NOTHING?
	PUSHJ P,RTYO	;TYPE IT OUT
	MOVE A,RCHAR	;GET RADIX IDENTIFICATION CHARACTER,
	JRST TYO	;TYPE IT OUT AND RETURN

RTYO:	LSHC A,-35.	;SET UP A AND AA,
	LSH AA,-1	;TO BOTH ARE POSITIVE AND BIT 1.1(A) HAS "SIGN" BIT
	DIV A,CRADIX	;DO INITIAL DIVISION
	JRST RTYO2	;TRANSFER TO REST OF ROUTINE

RDXTYO:	IDIV A,CRADIX
RTYO2:	JUMPE A,RDXTY2
	HRLM AA,(P)
	PUSHJ P,RDXTYO
	HLRZ AA,(P)
RDXTY2:	MOVEI A,60(AA)
	TESTF N,NTYO	;IF TYPEOUT HACK FLAG NOT SET,
	JRST TYO	;THEN USE NORMAL TYPEOUT
ALTYO:	JRST		;ALTERNATE TYPEOUT

	CMD "-,MINUS

MINUS:	TESTF E,ARGF	;IF ARGUMENT,
	ERR HUH		;THEN COMPLAIN
	SETF MINUSF	;SET FLAG,
	JRST POPJ1	;RETURN

	CMD "Q,WIPOUT,VALRET AN ALTX. REQUIRES .

WIPOUT:	PUSHJ P,LOSSNP	;LOSE IF USER TYPES OTHER THAN A .
	.VALUE [ASCIZ /:KILL/]
	POPJ P,

	CMD "X,RETTY,RETURN TTY TO DDT

RETTY:	PUSHJ P,PDPCLS	;GIVE UP PDP10 WHENEVER GIVING UP TTY
	.VALUE [0]
	JRST 10INIT	;TRY TO OPEN THE PDP10 UP AGAIN

	CMD "O,CMDO,OPEN THE PDP10 FOR MUNGING

CMDO:	PUSHJ P,ARGET	;O TAKES OPTIONAL ARGUMENT
	JRST 10INIT	;WITHOUT ARGUMENT IT DOES WHAT THE DOCUMENTATION SAYS
	ANDI A,1	;WITH ARGUMENT, IT SELECTS NORMAL (0) OR CROCK (1) DDT
	MOVE A,[SIXBIT /DDT   RDDT/](A)	;EVER SEE AN INDEXED CONSTANT BEFORE?
	MOVEM A,DDTFN2
	POPJ P,

10INIT:	.SUSET [.RUNAM,,UNAME]
	MOVEI A,6	;BLOCK IMAGE INPUT
	HRLM A,PDPNAM
	.OPEN USRIC,PDPNAM	;OPEN IT FOR INPUT
	ERR [ASCIZ /  PDP10 NOT AVAILABLE.
/]
IFE SUDTSW,	MOVEI A,7	;BLOCK IMAGE OUTPUT
IFN SUDTSW,[	MOVEI A,27	;" " ", INFERIOR
	HRLM A,PDPNAM		;STORE AS MODE FOR .OPEN
	.OPEN USROC,PDPNAM	;TRY TO OPEN IT
	TRZA A,20		;LOSE, NOW TRY NOT AS INFERIOR
	JRST 10INI2		;WIN
]
	HRLM A,PDPNAM		;STORE NEW MODE FOR OPEN
	.OPEN USROC,PDPNAM	;OPEN IT FOR OUTPUT
	ERR [ASCIZ /  PDP10 NOT AVAILABLE FOR OUTPUT.
/]
10INI2:	SETF PDPO		;DOCUMENT FACT THAT PDP10 OPEN
	POPJ P,

	CMD "C,PDPCLS,CLOSE THE PDP10

PDPCLS:	CLEARF PDPO	;INDICATE NO LONGER OPEN
	.CLOSE USRIC,	;CLOSE INPUT
	.CLOSE USROC,	;CLOSE OUTPUT
	POPJ P,

LOSSNP:	PUSHJ P,TYI	;LOSE IF NEXT CHARACTER IS NOT A PERIOD
	CAIE A,".
	ERR HUH
	POPJ P,

	CMD "E,SSA,STARTING ADR (SET IT OR HAS VALUE OF)

SSA:	PUSHJ P,ARGET	;GET ARGUMENT,
	JRST STADR	;NO ARG => RETURN VALUE
	TLNN A,777000	;IF INSTRUCTION PART ZERO,
	TLO A,(JRST)	;THEN TURN INTO JRST
	MOVEM A,GOINST	;DEPOSIT AS STARTING INSTRUCTION
	POPJ P,

STADR:	SKIPN GOINST	;IF NO STARTING ADDRESS,
	ERR [ASCIZ /  NO CURRENT STARTING ADDRESS.
/]
	HRRZ A,GOINST	;GET IT
	JRST VALRET

	CMD "Z,ZEROC,[CLEAR CORE, REQUIRES PERIOD]

ZEROC:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,LOSSNP	;LOSE IF NEXT CHARACTER NOT PERIOD.
	JRST RESET	;WIPE IT OUT

	;ROUTINE TO GENERATE ERROR IF PDP10 NOT OPEN

LOSSNO:	TESTF N,PDPO
	ERR [ASCIZ /  PDP10 NOT OPEN.
/]
	POPJ P,

	CMD "L,LOAD,LOAD PROGRAM WITH DDT

LOAD:	PUSHJ P,ARGET	;GET ARGUMENT (INTERPRETED AS MASK),
	MOVEI A,LSYMF\LDDTF\STRTF\LOADF\CLRCF
	MOVE F,A	;SAVE AS MASK FOR LOAD
ALOAD:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,GETFIL	;READ FILE DESCRIPTION
	MOVEI A,6	;MODE FOR OPEN
	HRLM A,DNAM
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	.OPEN UTYIC,DNAM	;OPEN THE FILE
	ERR [ASCIZ /FNF?   /]	;NOT FOUND?
	SETF UTYIO	;TELL ERR TO CLOSE FILE IF OPEN
	TESTF E,LDDTF	;IF DDT SHOULD BE LOADED,
	PUSHJ P,LODDT	;THEN LOAD DDT
BLOAD:	TESTF E,CLRDF\KSYMF	;IF PDP10 CORE SHOULD BE MUNGED (OTHER THAN COMPLETELY)
	PUSHJ P,MNGCOR	;THEN DO SO
	TESTF E,CLRCF	;IF CORE SHOULD BE COMPLETELY CLEARED,
	PUSHJ P,RESET	;ZAP!
	TESTF N,LOADF\LSYMF\STRTF	;IF NOTHING REQUIRES READING FROM FILE,
	JRST CLOAD	;THEN BYPASS FOLLOWING
	TESTF N,NRLODF	;IF FILE SHOULD BE READ FOR READING,
	PUSHJ P,LODPGM	;THEN READ IT, AND LOAD IT IF DESIRED
	TESTF E,LSYMF	;IF SYMS SHOULD BE LOADED,
	PUSHJ P,LOADS	;THEN LOAD SYMS
CLOAD:	TESTF N,DCCDF	;IF INPUT FILE SHOULD BE CLOSED,
	.CLOSE UTYIC,	;CLOSE INPUT FILE
	TESTF N,DCCDF	;AND IF IT WAS CLOSED,
	CLEARF UTYIO	;DOCUMENT SAME
	TESTF E,GOF	;IF PROGRAM SHOULD BE STARTED UP,
	JRST STST	;THEN START UP PROGRAM
	TESTF E,DDTGF	;IF DDT SHOULD BE STARTED UP,
	JRST STDDT	;THEN START UP DDT
	TESTF E,DDTPGF	;IF PROGRAM SHOULD BE STARTED UP VIA DDT,
	JRST STPDT2	;THEN DO IT
	POPJ P,


	CMD "M,LDCC,LOAD BUT DON'T CLEAR CORE (NO SYMS)
	CMD "T,LCCDS,[KILL SYMS,CLEAR CORE < DDT,LOAD W/SYMS]	;BH'S IDEA (THE <)

LDCC:	SKIPA F,[STRTF\LOADF]	;LOAD AND SET STARTING ADDRESS
LCCDS:	MOVEI F,KSYMS\CLRDF\LOADF\LSYMF\STRTF	;KILL SYMS, CLEAR CORE BELOW DDT, LOAD, LOAD SYMS, SET STARTING ADDRESS
	JRST ALOAD	;GO DO IT

	CMD "N,LWS,LOAD WITH SYMS
	CMD "K,KKL,KLEAR KORE AND LOAD (NO SYMS)

LWS:	SKIPA F,[LSYMF\STRTF\LOADF]	;LOAD SYMS, SET STARTING ADDRESS, LOAD
KKL:	MOVEI F,CLRCF,\STRTF\LOADF	;CLEAR CORE, SET STARTING ADDRESS, LOAD
	JRST ALOAD	;GO DO IT

		;CLEAR CORE BELOW DDT AND/OR KILL SYMBOLS

MNGCOR:	TESTF N,KSYMF	;IF NOT KILLING SYMS,
	JRST LOAD3	;THEN GET DDT-2 IN A AND GO TO LOAD4
	MOVE T,[-2,,SVSYMP]	;SET UP AOBJN POINTER TO PDP6 VERSION OF DDT-2,DDT-1
	BPUT T,DDT-2	;CLOBBER DDT LOCATIONS (NEW SYMBOL POINTER AND CLOBBERAGE DOCUMENTATION)
	MOVE A,SVSYMP	;GET NEW SYMBOL POINTER IN A
LOAD4:	TESTF N,CLRDF	;IF NOT CLEARING CORE BELOW DDT,
	JRST LOAD5	;THEN GET LH(SVSYMP) INTO LH(B) AND GO TO LOAD6
	SETZM 10SV41	;CLEARING CORE BELOW DDT, MAKE IT INCLUDE 41
	IFN SUDTSW,SETZM 10TYOL	;CLEAR TYO STATUS
	IFN SUDTSW,SETZM 10TYIL	;ALSO CLEAR TYI STATUS
	HRLZ B,A	;B:=LAST LOCATION TO CLEAR+1,,0
	MOVE A,[30,,30]	;30 IS FIRST LOCATION CLEARED
LOAD6:	SUB A,B		;CALCULATE AOBJN POINTER TO CORE TO CLEAR
	JRST CLRCOR	;CLEAR IT AND RETURN

		;RANDOM FROBS FOR ABOVE
LOAD3:	GET A,DDT-2	;GET DDT SYMBOL POINTER IN A
	JRST LOAD4	;GO BACK TO ROUTINE

LOAD5:	HLLZ B,SVSYMP	;GET LH(SVSYMP) IN B
	JRST LOAD6	;GO BACK AND PROCESS

		;ROUTINE TO CLEAR SELECTED CORE
		;ARGUMENT IN A, AOBJN POINTER TO CORE TO CLEAR

CLRCOR:	PUSH P,SYMP	;SAVE CURRENT SYMBOL POINTER
	ACCESS USROC,(A)	;BEGINNING OF CORE TO CLEAR
	HLRES A		;-# WORDS TO CLEAR
	IDIVI A,2000	;GET -# BLOCKS IN A,- # EXTRA WORDS IN AA
	MOVN B,A	;SAVE # BLOCKS
	MOVEI E,[ASCIZ /NOT ENOUGH CORE TO CLEAR CORE.
/]			;ERROR MESSAGE IF LOSSAGE
	MOVSI A,-2000	;# WORDS IN ONE BLOCK
	JUMPE B,.+2	;IF LESS THAN ONE BLOCK,
	HRLZ A,AA	;THEN USE -# WORDS TOTAL
	PUSHJ P,ACORE	;GET THE CORE?
	HLRE T,A	;- # WORDS LOCAL TO CLEAR
	MOVE C,A	;AOBJN POINTER TO LOCAL CORE
	SUBM A,T	;RH(T):=LAST LOCATION LOCALLY TO CLEAR -1
	HRLI A,1(A)	;SET UP BLT POINTER,
	SETZM (A)	;CLEAR FIRST LOCATION
	BLT A,-1(T)	;CLEAR LOCAL CORE
	JRST CLRC3	;PUT LOCAL CORE INTO PDP10 CORE

CLRC2:	MOVE A,C	;AOBJN POINTER TO LOCAL CLEAR CORE
	.IOT USROC,A	;CLEAR PDP10 CORE
CLRC3:	SOJGE B,CLRC2	;DO IT # TIMES EQUAL TO NUMBER OF BLOCKS
	MOVE A,C	;RH HAS POINTER TO LOCAL CLEAR CORE
	HLL A,AA	;-# WORDS LEFT OVER
	.IOT USROC,A	;CLEAR REMAINDER OF CORE
	POP P,SYMP	;RESTORE OLD SYMBOL POINTER
	MOVEI E,[ASCIZ /LOST ON FLUSHING CORE.
/]
	JRST ACOR2	;GIVE IT UP AND RETURN
		;LOAD PROGRAM WITH DDT

LODDT:	PUSH P,F	;SAVE F
	CLEARF P2MSK	;CLEAR BITS NOT TO BE SET DURING LOAD OF PROGRAM
	SETF DCCDF	;TELL LOADER NOT TO CLOSE UTYIC WHEN DONE
	PUSHJ P,BLOAD	;LOAD PROGRAM
	.IOPUSH UTYIC,	;SAVE UTYIC
	SKIPE DDTFIL+3	;SAVE A LITTLE TIME IF SYSTEM NAME IRRELEVANT
	.SUSET [.SSNAM,,DDTFIL+3]	;PREPARE TO OPEN DDT FILE
	.OPEN UTYIC,DDTFIL	;TRY TO DO SO
	ERR [ASCIZ /DDT FILE NOT FOUND.
/]
	MOVEI F,LOADF	;MASK FOR ACTUALLY LOADING DDT
	PUSHJ P,BLOAD	;LOAD DDT
	GET T,DDT-2	;GET INITIAL SYMS POINTER
	MOVEM T,SVSYMP	;SAVE IT WHERE IT BELONGS
	.IOPOP UTYIC,	;RESTORE UTYIC
	POP P,F		;RESTORE F
	ANDI F,P2MSK	;MASK TO BITS TO BE EXAMINED DURING SYMLOD ETC.
	SETF NRLODF	;PROG. ALREADY READ, DON'T READ IT AGAIN
	POPJ P,

GWD:	HRROI T,A	;GET A WORD IN A
GBLK:	.IOT UTYIC,T	;ENTRY TO INPUT A BLOCK
	JUMPGE T,CPOPJ	;IF ENTIRE BLOCK WAS TRANSFERED THEN RETURN
	ERR [ASCIZ /EOF?   /]	;END OF FILE ENCOUNTERED

LODRED:	MOVE T,A	;READ IN A BLOCK IN SBLK FORMAT
	PUSHJ P,GBLK	;GET THE BLOCK
	MOVE B,A	;SO NOT TO MUNG A
LODRD1:	ROT C,1		;CHECKSUM IN C, UPDATE IT
	ADD C,(B)	;" " "
	AOBJN B,LODRD1	;DO IT FOR THE ENTIRE BLOCK
	POPJ P,		;RETURN WITH CALCULATED CHECKSUM IN C

		;CLEAR CORE

RESET:	SETZM 10SV41
	IFN SUDTSW,SETZM 10TYOL	;CLEAR TYO STATUS
	IFN SUDTSW,SETZM 10TYIL	;ALSO CLEAR TYI STATUS
	.RESET USROC,
	POPJ P,

		;READ FILE AND MAYBE LOAD PROGRAM FROM IT

LODPGM:	MOVEI AA,41	;FOR CAIX'S
	TESTF E,LOADF	;IF LOADING,
	SETOM 41SW	;THEN INDICATE TENLOD HAS THE REAL 41
	MOVEI E,0	;INITIALIZE LOADER COUNT
	PUSHJ P,GWD	;GET A WORD
	CAME A,[JRST 1]	;IF NOT END OF LOADER,
	AOJA E,.-2	;E NOT CLOBBERED BY REST OF LOAD, SYMS NOT LOADED
			;IF NO SBLK LOADER AND JUMP BLOCK NOT JUMPA
LOAD1:	PUSHJ P,GWD	;GET A WORD
	JUMPGE A,LDJBLK	;IF POSITIVE THEN JUMP BLOCK
	MOVE C,A	;INITIALIZE CHECKSUM
	MOVE D,A
LOAD2:	CAMGE A,[-UTIBFL,,0]	;IF BIGGER THAN BUFFER,
	HRLI A,-UTIBFL	;THEN USE BUFFER LENGTH
	HRRI A,UTIBUF	;MAKE IT POINT TO THE BUFFER
	PUSHJ P,LODRED	;READ IN A BLOCK
	TESTF N,LOADF	;IF PROG NOT TO BE LOADED,
	JRST NOLOD	;THEN DON'T MUNG INTO PDP10 CORE
	ADDI B,(D)	;C(B)+UTIBUF=1+LAST LOCATION IN BLOCK
	CAIL AA,(D)	;IF 41 LOWER THAN FIRST WORD IN BLOCK,
	CAIG B,UTIBUF+41	;OR 1+LAST LOCATION IN BLOCK .LE. 41,
	JRST NOLD41	;THEN DON'T LOAD 41
	MOVEI TT,41	;LOAD INTO 41
	SUBI TT,(D)	;MAKE TT POINT TO RELEVANT WORD IN BLOCK
	MOVEI T,0	;WORD TO BE SUBSTITUTED
	EXCH T,UTIBUF(TT)	;SUBSTITUTE AND SAVE ORIGINAL
	MOVEM T,10SV41	;SAVE FOR STARTING IT UP
NOLD41:	BPUT A,(D)	;LOAD INTO PDP10 CORE
NOLOD:	HLRS A		; -NUMBER OF WORDS PROCESSED
	HRLI A,-1(A)	;C(A):=<-# PROCESSED-1,,-# PROCESSED> = -<# PROCESSED,,# PROCESSED>
	SUBB D,A	;D HAD ORIGINAL AOBJN POINTER, ANSWER=NEW AOBJN POINTER
	JUMPL A,LOAD2	;JUMP IF MORE BUFFERINGS IN THIS BLOCK
	PUSHJ P,GWD	;GET FILE'S VERSION OF CHECKSUM
	CAME A,C	;IF NOT EQUAL TO CALCULATED ONE,
	ERR [ASCIZ /CHECKSUM ERROR.   /]	;THEN COMPLAIN
	JRST LOAD1	;GO GET ANOTHER BLOCK

		;JUMP BLOCK ENCOUNTERED DURING LOAD

LDJBLK:	TESTF E,STRTF	;IF STARTING INSTRUCTION SHOULD BE SET,
	MOVEM A,GOINST	;THEN DO SO
	POPJ P,		;FILE READ AND MAYBE PROGRAM LOADED, RETURN

		;LOAD SYMBOLS

LOADS:	TLC A,(JUMPA)	;IF JUMP BLOCK JUMPA THEN LH(LH):=0
	TLNE A,777000	;IF JUMP BLOCK NOT JUMPA,
	JUMPE E,CPOPJ	;AND NO SBLK LOADER, THEN REFUSE TO LOAD SYMBOLS
	HRRZS SYMP	;KILL ANY PREVIOUS
	MOVEI E,[ASCIZ /CORE FOR SYMS?/]	;ERROR MESSAGE IF CORE UNOBTAINABLE
	SKIPE SVSYMP	;IF NO DDT INITIAL SYMS POINTER,
	JRST LODS1	;...
	GET A,DDT-2	;THEN GET ONE
	MOVEM A,SVSYMP	;STORE IT WHERE IT BELONGS
LODS1:	PUSHJ P,GWD	;GET HEADER
	JUMPGE A,LODS2	;END OF SYMS IF POSITIVE
	MOVE C,A	;INITIALIZE CHECKSUM
	PUSHJ P,ACORE	;GET CORE FOR THIS BLOCK
	PUSHJ P,LODRED	;READ IN BLOCK AND CALCULATE CHECKSUM
	PUSHJ P,GWD	;GET CHECKSUM FROM FILE
	CAME A,C	;COMPARE WITH CALCULATED
	ERR [ASCIZ /CKS ON SYMS.
/]
	JRST LODS1	;DO IT AGAIN

LODS2:	GET B,DDT-2	;GET DDT POINTER INTO B
	HLRZ A,SYMP	;0,,-# SYMS TO BE LOADED
	HRLI A,-1(A)	;-# SYMS-1,,-# SYMS
	ADD A,B		;BIT CARRIES OVER INTO LH, RESULT=-TOTAL # SYMS,,LOWEST LOCATION SYMS
	MOVEI C,10HIGH	;GET MEMTOP IN C
	CAILE C,(A)	;IF .LE. LAST LOC TO BE LOADED,
	CAIG C,(B)	;OR IF .LE. LAST LOC TO BE LOADED,
	JRST LODS3	;THEN KILL SYMS AND COMPLAIN
	PUT A,DDT-2	;PUT IT BACK IN DDT
	MOVE T,DDT1C	;GET WORD TELLING DDT ITS SYMBOL TABLE WAS MUNGED
	PUT T,DDT-1	;PUT IT IN PDP10 CORE
	SKIPGE B,SYMP	;POINTER TO SYMS TO BE LOADED
	BPUT B,(A)	;LOAD INTO PDP10
	JRST KSYMS	;KILL SYMBOLS AND RETURN

LODS3:	PUSHJ P,KSYMS	;SYMS WERE ABOUT TO BE LOADED INTO NON-EXISTANT CORE
	ERR [ASCIZ /DDT IN CORE?	/]	;ERROR CONDITION

		;MAKE ROOM FOR SYMS

ACORE:	HLRE T,SYMP	;TAKES -ARGUMENT IN LH(A)
	HLLZS A		;MASK TO ARGUMENT
	ADDM A,SYMP	;UPDATE POINTER
	HRRI A,SYMS	;A:=-# NEW SYMS,,SYMS
	SUB A,T		;A:= -# NEW SYMS,,SYMS+# OLD SYMS
ACOR2:	HLRE T,SYMP	;-TOTAL # SYMS (ENTRY TO CORE TO WHAT INDICATED BY SYMP)
	SUBI T,SYMS	;-LAST LOC. SYMS -1
	IDIV T,[-2000]	;T:=# BLOCKS CORE NEEDED
	.CORE 1(T)	;TRY TO GET CORE
	ERR (E)		;COMPLAIN WITH RELEVANT MESSAGE
	POPJ P,

KSYMS:	HRRZS SYMP	;KILL SYMBOLS
	.CORE SYMS_<-10.>+1
	.VALUE		;LOST ON FLUSHING CORE?
	POPJ P,

	CMD "F,STDDT,START UP DDT
	CMD "S,SSLP,PUT TTY TO SLEEP (AUTOMATIC ON GO)
	CMD "W,CPOPJ,(OR ) WAKE UP FROM SLEEP

STST:	SKIPN GOINST	;START UP PROGRAM AT STARTING ADDRESS,
	ERR [ASCIZ /  NO CURRENT STARTING ADDRESS.
/]			;BUT COMPLAIN IF NONE
START1:	SKIPA B,[10PGO]	;B:=INSTRUCTION TO PUT INTO 41
STDDT:	MOVEI B,DDTGO	;ENTRY TO START UP DDT
STRND:	HRRM B,10DSP	;SET ROUTINE FOR APR INITIALIZER TO TRANSFER TO
	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	AOSN 41SW	;IF LOCAL 41 ACCURATE VIA LOAD,
	JRST START2	;THEN USE IT,
	GET T,41	;OTHERWISE USE THE ONE IN IN THE PDP10
	MOVEM T,10SV41	;PUT IT WHERE IT BELONGS
START2:	MOVE C,[GOBEG-GOEND,,GOBEG]	;LOCAL LOCATION OF STARTING ROUTINE
	BPUT C,37400+MOBY	;PUT IT WHERE IT BELONGS
	MOVE T,[JRST 10ST]	;WORD TO PUT IN 41 TO START UP START ROUTINE
	PUT T,41	;START IT UP
	MOVEI B,15.	;1/2 SECOND (IN THIRTIETHS)
	.SLEEP B,	;WAIT,
	GET B,DUNSW	;AND SEE IF IT STARTED PROPERLY
	AOJE B,START3	;JUMP IF STARTED PROPERLY
	MOVE T,10SV41	;DIDN'T START PROPERLY, GET PROPER CONTENTS OF 41
	PUT T,41	;PUT THEN BACK IN 41
	TYPE [ASCIZ /  RUNNING?/]	;LET USER KNOW THERE'S DOUBT
START3:	IFN SUDTSW,[TESTF E,SDTSW2
	JRST TSLEEP	;SLEEP REGARDLESS OF CONSOLE IF ENTERING SUDTAP MONITOR MODE
]
	.SUSET [.RTTY,,A]	;GET SYSTEM TTY STATUS
	HRRZS A		;MASK TO RIGHT HALF (SHOULD BE TTY #, IF NOT THEN HE DESERVES TO LOSE)
	CAIE A,PDPTTY	;IF NOT PDP10 TTY,
	POPJ P,		;THEN JUST RETURN
SSLP1:	PUSHJ P,CRRR	;TYPE CR TO TELL USER DONE STARTING
	PUSHJ P,IMITTY	;OPEN TELETYPE FOR IMAGE MODE INPUT (NO ECHO)
STARTW:	PUSHJ P,TYIBK5	;GET CHARACTER
	CAIE A,^X	;ALSO ALLOW CONTROL X
	CAIN A,"W	;W ORIGINAL CHARACTER BEFORE TYI CROCK
	JRST .+2	;W OR CONTROL X, TIME TO WAKE UP
	JRST STARTW	;NEITHER, GO BACK FOR MORE,
	PUSHJ P,TYOAE	;W, WAKE UP, ECHO THE W,
	JRST INITTY	;AND OPEN THE TELETYPE RIGHT

IFE SUDTSW,SSLP=SSLP1
IFN SUDTSW,[

SSLP:	TESTF N,SDTSW2	;S COMMAND
	JRST SSLP1	;NOT ENTERING SUDTAP MODE

TSLEEP:	PUSHJ P,CRRR	;TYPE CR TO ACKNOWLEDGE COMMAND
	PUSHJ P,IPITTY	;INITIALIZE TYI MODE PROPERLY FOR OCCASION
	.SUSET [.SPICL,,[0]]	;TRY TO AVOID TIMING ERROR ON FOLLOWING
	.RESET TYIC,	;CAUSE TYPEIN TO BEHAVE
	SETOB S,SNCHAR	;CAUSE CHARACTER COUNT TO AGREE (ALSO SHORT-CIRCUIT FIRST .SLEEP)
	CLEARF SDTSW2
	SETF SDTSW
	.DISMIS [SUDTAP]
]

	CMD "G,START,START UP PROGRAM

START:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,ARGET	;SEE IF ARGUMENT,
	JRST STST	;IF NOT THE USE STARTING ADDRESS,
	TLNN A,777000	;IF SO THEN USE SUPPLIED: IF INSTRUCTION PART ZERO,
	TLO A,(JRST)	;THEN USE JRST AS INSTRUCTION
	PUSH P,GOINST	;SAVE STARTING INSTRUCTION
	MOVEM A,GOINST	;TEMPORARILY USE SUPPLIED TO START IT UP
	PUSHJ P,START1	;START IT UP
	POP P,GOINST	;RESTORE STARTING INSTRUCTION
	POPJ P,

	CMD "H,STPDDT,START PROG VIA DDT

STPDDT:	PUSHJ P,LOSSNO	;LOSS IF PDP10 NOT OPEN
	PUSHJ P,ARGET	;GET ARGUMENT IF ANY
STPDT2:	SKIPA A,GOINST	;NO ARGUMENT, USE STARTING ADDRESS (ENTRY FROM LOADER)
	TLNE A,777000	;ARGUMENT SPECIFIED, LOOK AT LEFT HALF
	JRST .+2	;IF LH NON-ZERO OR USING STARTING INSTRUCTION, THEN DON'T MODIFY
	TLO A,(JRST)	;INSTRUCTION PART ZERO, TURN INTO JRST
	MOVEI B,DEPDDT	;ADDRESS OF ROUTINE...
	HRRM B,ALTYO	;FOR ALTYO TO TRANSFER TO INSTEAD OF TYO
	SETF NTYO	;TELL ALTYO TO USE ALTERNATE ROUTINE
	MOVE B,[440700,,DDSTRI]	;BYTE POINTER TO DDT COMMAND STRING (LOCAL VERSION)
	PUSH P,CRADIX	;SAVE CURRENT RADIX,
	MOVEI AA,8	;AND REPLACE,
	MOVEM AA,CRADIX	;WITH OCTAL
	PUSHJ P,RTYO	;TYPE OUT STARTING INSTRUCTION IN OCTAL
	MOVE C,[440700,,[ASCIZ /X/]]
STPDT3:	ILDB A,C
	PUSHJ P,ALTYO
	JUMPN A,STPDT3
	POP P,CRADIX	;RESTORE CURRENT RADIX
	CLEARF NTYO	;MAY AS WELL
	MOVEI B,FGO	;TELL STARTER WHERE TO GO
	JRST STRND	;START IT UP

DEPDDT:	IDPB A,B	;DEPOSIT CHARACTER INTO DDT COMMAND STRING
	POPJ P,

		;INTERRUPT HACKERY

IMSK:	201001		;INTERRUPT MASK

	IFE SUDTSW,FOO==0
	IFN SUDTSW,FOO==1_<USROC>	;FOR PDP10 INTERRUPTS
IMSK2:	FOO		;SECOND WORD INTERRUPT MASK

TMPLOC 42,JSR TSINT

TSINT:	0
	0
	AOS INTLEV	;INCREMENT INTERRUPT LEVEL (SOMETIMES .DISMISSES TO SUBROUTINE THEN RETURNS)
	PUSH P,G	;SAVE G,
	SKIPGE G,TSINT	;GET INTERRUPT REQUEST WORD IN G (WHERE IT STAYS UNTIL DISMISSAL)
IFE SUDTSW,WRD2I:	.VALUE		;WRONG WORD
IFN SUDTSW,	JRST WRD2I	;SECOND WORD, PROCESS SEPARATELY (RETURN TO WRD2IR)
	TRNE G,200000	;PDL OVERFLOW
	MOVE P,[-LPDL-1,,PDL+1]	;RE-INITIALIZE PDL (COMPLAIN LATER)
	PUSH P,A	;SAVE A
	TRZE G,201000	;ERROR CONDITIONS?
	JRST ERRBRK	;YES (RETURNS TO ERBKRT)
ERBKRT:	TRZE G,1	;CONSOLE TYI INTERRUPT
	JRST TYIBRK	;YES
TYBKRT:	SKIPE G
RNDB1:	.VALUE		;RANDOM BIT(S) IN (FIRST WORD) INTERRUPT WORD
	POP P,A		;RESTORE A
WRD2IR:	SOSL INTLEV	;DECREMENT INTERRUPT LEVEL
	JRST TSINT2	;NOT ABOUT TO DISMISS TO MAIN PROGRAM LEVEL
	SKIPE G,INTRET	;DISMISSING TO MAIN PROGRAM LEVEL, GET RETURN POINT CLOBBERAGE, SKIP IF NONE
	HRRM G,TSINT+1	;CLOBBER IT
	SETZM INTRET	;DESTRUCTIVE READOUT
TSINT2:	POP P,G		;RESTORE G
	.DISMIS TSINT+1	;RETURN TO LOWER LEVEL

IFN SUDTSW,[
		;SECOND WORD INTERRUPT

WRD2I:	TRZE G,1_<USROC>	;PDP10 INTERRUPT?
	MOVNI S,1	;YES => TERMINATE .SLEEP EARLY IF ANY
	TDNE G,[SETZ-1]	;RANDOM BITS?
RNDB2:	.VALUE		;YES
	JRST WRD2IR
]

		;ERROR INTERRUPT BITS (RETURN TO ERBKRT)

ERRBRK:	MOVEI A,0
	EXCH A,INTLEV	;RETURN TO MAIN PROGRAM LEVEL, GET FORMER INTLEV
	MOVEM A,ERRLEV	;SAVE LEVEL FOR ERROR PRINTOUT
	MOVEI A,ERRDSM	;DISMISS TO ERRDSM
	MOVEM A,INTRET	;" " "
	MOVE A,[TSINT,,ERRPIR]
	BLT A,ERRPCW	;SAVE PIRQC WORD AND GUILTY PC
	JRST ERBKRT	;THAT'S ALL FOR NOW, SEE YOU LATER AT...

		;MAIN PROGRAM LEVEL ROUTINE DISMISSED TO ON ERROR CONDITIONS

ERRDSM:	PUSHJ P,INITTY	;RE-INITIALIZE TTY
	CLEARF SILNT	;MAKE BEGINNING OF MESSAGE TYPE OUT
	PUSHJ P,CRLF	;START AT BEGINNING OF LINE
	MOVE A,ERRPIR	;GET THE PIRQC WORD
	TRNE A,200000	;CHECK PDL OVERFLOW
	TYPE [ASCIZ /PDLOV, /]
	TRNE A,1000	;CHECK ILLEGAL USER ADDRESS (.ACCESS POINTER ABOVE PDP10 MEMORY)
	TYPE [ASCIZ /ILUADR, /]
		;INSERT OTHER CONDITIONS HERE
	TYPE [ASCIZ /PC=/]
	PUSH P,CRADIX	;TYPE OUT THE PC IN OCTAL
	MOVEI A,8
	MOVEM A,CRADIX
	HRRZ A,ERRPCW
	PUSHJ P,RTYO	;TYPE OUT THE PC
	SKIPN A,ERRLEV
	JRST .+3	;INTERRUPTED FROM MAIN PROGRAM LEVEL => DON'T MENTION IT
	TYPE [ASCIZ /', INTLEV=/]
	PUSHJ P,RTYO
	POP P,CRADIX	;RESTORE FORMER TYPEOUT RADIX
	ERR [ASCIZ /' .
/]

ERRLEV:	0		;INTLEV WHEN ERROR CONDITION NOTICED (0 => INTERRUPTED FROM TOP LEVEL)

		;FOLLOWING TWO WORDS BLT'ED FROM TSINT AND TSINT+1
ERRPIR:	0		;PIRQC AT RELEVANT INTERRUPT
ERRPCW:	0		;PC WORD STORED

		;TYI BREAK (RETURN TO TYBKRT)

TYIBRK:	.ITYI A,	;GET CHARACTER TYPED
	JRST TYBKRT	;NOT REALLY THERE
	CAIN A,^S	;IF CONTROL S,
	PUSHJ P,CTLSBK	;THEN MAYBE SILENCE TYPEOUT
IFE SUDTSW,JRST TYBKRT	;IF SUDTAP MODE DOESN'T EXIST, THEN THAT'S ALL
IFN SUDTSW,[TESTF N,SDTSW	;IF NOT IN SUDTAP MODE,
	JRST TYBKRT	;THEN THAT'S ALL
	SKIPN 10TYIL	;IF NOT IN CROCK TYI MODE,
	CAIE A,"W	;AND TYPED IN CHARACTER IS W,
	CAIN A,^X	;OR IF CHARACTER IS CONTROL S,
	JRST WAKUPB	;THEN WAKE UP
	AOSLE SNCHAR	;ANOTHER CHARACTER: THE FIRST?
	JRST TYBKRT	;NO
	PUSH P,TSINT	;YES
	PUSH P,TSINT+1
	PUSH P,G
	SKIPN 10TYIL	;IF NOT IN CROCK TYI MODE,
	TDZA G,G	;THEN SET INDEX TO ZERO
	MOVEI G,1	;IN TYI MODE, SET INDEX TO 1
	.DISMIS [TYIBK4]	;PROCESS CHARACTERS WHILE REMAINING INTERRUPTABLE

TYIBK4:	.STATUS TYIC,A		;GET TYI STATUS (FOR DISOWNED-ATTACHED CHECK)
	PUSHJ P,@TYWTDS(G)	;PROCESS A CHARACTER
	.SUSET [.SPICL,,[0]]	;TURN OFF INTERRUPTS (PREVENT PDL BUILDUP)
	SOSL SNCHAR		;ANOTHER CHARACTER PROCESSED: THE LAST ONE?
	.DISMIS [TYIBK4]	;NO, DO IT AGAIN
	POP P,G		;YES, RETURN TO INTERRUPT ROUTINE
	POP P,TSINT+1
	POP P,TSINT
	JRST TYBKRT

TYWTDS:	TYIBK2	;INACTIVE
	TYIBK3	;ACTIVE (IN CROCK TYI MODE)

		;WAKEUP CHARACTER TYPED

WAKUPB:	CLEARF SDTSW	;LEAVING SUDTAP MODE SOON
	SKIPN INTRET	;IF GOING TO DISMISS TO ERROR ROUTINE,
	TMODF CN,WAKUPF	;OR IF NOT SLEEPING,
	JRST TYBKRT	;THEN THAT'S ALL (IF NOT SLEEPING, 10SLP WILL SEE WAKUPF SET)
	MOVEI A,10SLP2	;NOT DISMISSING TO ERROR ROUTINE, AND MAIN PROGRAM SLEEPING
	MOVEM A,INTRET	;CLOBBER RETURN TO DISMISS TO 10SLP2, CAUSING WAKE-UP
	JRST TYBKRT

SNCHAR:	-1		;1 LESS THAN NUMBER OF CHARACTERS TYIBK4 TO EAT UP BEFORE RETURNING TO INTERRUPT ROUTINE
]			;END SUDTAP MODE CONDITIONAL

INTLEV:	-1		;1 LESS THAN NUMBER OF INTERRUPT LEVEL PUSH-DOWNS
INTRET:	0		;0 => DISMISS NORMALLY, NON-ZERO => PLACE IN MAIN PROGRAM TO DISMISS TO

CTLSBK:	.RESET TYOC,	;CONTROL S BREAK, RESET TYPEOUT
	SETF SILNT	;SILENCE TYPEOUT
	HRRZ A,TSINT+1	;GET PLACE THIS INTERRUPT CAME FROM (DON'T WORRY ABOUT INTLEV)
	CAIN A,TYOAE	;IF IT WAS HUNG ON TYPEOUT,
	AOS TSINT+1	;THEN SKIP THIS CHARACTER
	MOVEI A,^S	;RESTORE A
	POPJ P,

IFN SUDTSW,[
	;ROUTINES TO GOBBLE DOWN .ITYI'ED CHARACTERS WITH .IOTS THEN RETURN TO INTERRUPT ROUTINE

		;ROUTINE NUMBER 1: REALLY ASLEEP, EAT UP CHARACTER BUT IGNORE IT (EMPTY SYSTEM BUFFER)

TYIBK2:	.STATUS TYIC,A	;GET CHANNEL STATUS
	JUMPN A,TYIBK5	;IF DISOWNED THEN RE-ATTACHED,
	PUSHJ P,IMITTY	;THEN RE-OPEN TTY FIRST
]
TYIBK5:	PUSHJ P,TYI	;GET CHARACTER
	CAIN A,14	;IF FORM FEED
	PUSHJ P,TYOAE	;THEN ECHO
	POPJ P,		;RETURN

IFN SUDTSW,[
		;ROUTINE NUMBER 2: IN CROCK TYI MODE, GIVE CHARACTER TO PDP10
		;SEE 10TYIL FOR DESCRIPTION OF WHAT'S GOING ON

TYIBK3:	.STATUS TYIC,A	;GET CHANNEL STATUS
	PUSH P,T	;SAVE T (IN CASE IPITTY NEEDED)
	JUMPN A,.+2	;IF DISOWNED THEN RE-ATTACHED,
	PUSHJ P,IPITTY	;THEN RE-INITIALIZE TTY
	PUSHJ P,TYI	;GET THE CHARACTER (AND ECHO IT IF NECESSARY)
	CAIE A,^S	;IF CHARACTER IS CONTROL S,
	CAIN A,14	;OR IF CHARACTER IS FORM FEED,
	JRST POPTJ	;THEN DON'T PASS IT ON TO THE OTHER PROCESSOR
	PUSH P,B	;SAVE SOME AC'S
	PUSH P,C
	PUSH P,TT
	PUSH P,40	;SAVE 40,
	PUSH P,UUOH	;AND UUOH FOR UUOS EXECUTED HERE
	MOVE B,10TYIL	;GET LOCATION OF BUFFER DESCRIPTOR AREA
	GET C,2(B)	;GET THE SWITCH
	MOVEM C,10TYSW	;STORE IT AWAY
	TLZ C,777000	;TURN OFF INSTRUCTION PART
	TLO C,(TRN)	;TURN INTO NO-OP
	PUT C,2(B)	;PUT BACK (DON'T LET HIM MUNG  AREA)
	MOVE T,[-2,,10TIIC]	;SET UP AOBJN POINTER
	BGET T,(B)	;GET FIRST TWO WORDS OF DESCRIPTOR AREA
	AOS T,10TICC	;INCREMENT CHARACTER COUNT
	CAILE T,@10TIBS	;IF GREATER THAN BUFFER SIZE,
	JRST 10BFL	;THEN BUFFER FULL
		;NOW TO DEPOSIT THE CHARACTER
	AOS T,10TIIC	;INCREMENT CHARACTER ADDRESS AND GET IT IN T
10TIBS:	CAIL T,		;RH BUFFER SIZE (CHARACTERS)
	SETZB T,10TIIC	;OUT OF RANGE, SET TO BEGINNING OF BUFFER
	IDIVI T,5	;GET WORD NUMBER IN T, POSITION IN WORD IN TT
10TBLC:	GET B,(T)	;RH LOCATION OF TYI BUFFER IN PDP10
	DPB A,10TTBL(TT)	;DEPOSIT THE BYTE
	PUT B,@10TBLC	;PUT BACK THE WORD
10UTYI:	MOVE T,10TYIL	;GET TYI BUFFER DESCRIPTOR LOCATION
	MOVE A,[-3,,10TIIC]
	BPUT A,(T)	;UNLOCK BUFFER DESCRIPTOR AREA
	POP P,UUOH	;NOW RESTORE THE THINGS THAT WERE PUSHED
	POP P,40
	POP P,TT	;RESTORE THE SAVED AC'S
	POP P,C
	POP P,B
POPTJ:	POP P,T
	POPJ P,

10BFL:	TYPE [ASCIZ / BUFFER FULL.
/]
	SOS 10TICC	;DECREMENT CHARACTER COUNT BEFORE RESTORING BUFFER STATUS TO 10
	JRST 10UTYI	;UNLOCK VARIABLES AND RETURN

10TTBL:	POINTS 7,B	;TABLE OF BYTE POINTERS FOR DPB'ING INTO PDP10

	CMD "P,SDTPRP,PREPARE TO PSEUDO-TAPE ON SLEEP

SDTPRP:	PUSHJ P,LOSSNO		;LOSS IF PDP10 NOT OPEN
	.SUSET [.RIOC+USROC,,A]	;GET IOC WORD FOR USROC
	JUMPGE A,[ERR [ASCIZ /  DON'T HAVE PDP10 AS INFERIOR.
/]]
	SETF SDTSW2
	JRST POPJ1

..INSRT 6STAP FILE

		;DO A .SLEEP T, , BUT WAKE UP IF A WAKE-UP CHARACTER TYPED, SKIP UNLESS AWAKEN

10SLP:	TMODF CE,WAKUPF	;COMPLEMENT STATUS OF FLAG, IF ALREADY SET THEN TIME TO WAKE UP
	JRST 10SLP2	;ALREADY SET, NOW CLEAR
	EXCH S,T
	SKIPL T
	.SLEEP S,	;FLAG NOW SET, IF WAKEUP CHARACTER TYPED THEN TSINT WILL DISMISS TO 10SLP2 WITH WAKUPF OFF
	CLEARF WAKUPF	;SURVIVED THIS SLEEP, CLEAR FLAG,
	JRST POPJ1	;RETURN STILL ASLEEP

		;WAKE UP (WAKUPF NOW OFF) (USUALLY DISMISSED TO FROM TSINT)

10SLP2:	PUSHJ P,TYI	;GET CHARACTER FOR REAL
	SKIPN T,10TYIL	;GET TYPEIN PSEUDO-MODE DESCRIPTOR WORD, SKIP UNLESS INACTIVE
	JRST 10SLP3	;INACTIVE => IN IMAGE MODE, ECHO CHARACTER
	LDB T,[240200,,T]	;GET TYPEIN PSEUDO-MODE
	XCT EKCKTB(T)	;SKIP IF CHARACTER SHOULD NOT BE ECHOED NOW
10SLP3:	PUSHJ P,TYOAE	;ECHO CHARACTER
	JRST INITTY	;NOW OPEN TTY RIGHT AND RETURN

		;SKIP IF CHARACTER SHOULD NOT BE ECHOED

EKCKTB:	CAIA		;NORMAL MODE
	JFCL		;IMAGE MODE
	CAIA		;DDT MODE
	TESTF E,GETTY	;TECO MODE => ECHO IF GE
]

IFE SDTSW,[
	CMD "P,SDTPRP
	CMD "U,SDTPRP

SDTPRP:	ERR [ASCIZ /  NOT IMPLEMENTED THIS VERSION.
/]
]

IFN SUDTSW,[
	;CROCK TYI COMMANDS INITIATED BY PDP10

		;OPEN OR CLOSE TYI MODE, BUFFER DESCRIPTION LOCATION IN RH (FN1)
			;MODE AS MODIFIED IN LH(FN1)

STTYC:	MOVE A,SFN1
	PUSHJ P,STTYC1	;DO THE WORK
	JRST 10OPNR	;DIDN'T SKIP, SOMETHING LOST, A SET PROPERLY FOR DOCUMENTATION
	JRST SETSWJ	;RETURN INDICATING SUCCESS


IPITTY:	MOVE A,10TYIL	;ROUTINE TO RE-ENTER MODE
	ADD A,10TYOL	;INITIALIZE AC
	PUSHJ P,STTYC1	;DO THE WORK
	.VALUE		;DIDN'T SKIP => SOMETHING WRONG (PROBABLY LOST TTY)
	POPJ P,		;SKIPPED => WIN (OF COURSE), RETURN

		;ACTUAL ROUTINE TO OPEN TTY

STTYC1:	JUMPL A,STYOCX	;JUMP IF NOT SETTING TYO MODE
	LDB T,[331100,,A]	;GET TYO MODE
	TLZ A,777000	;CLEAR OUT GARBAGE SO TYI OPEN WILL WORK
	TRO T,1		;SET OUTPUT
	TRZ T,2		;FLUSH BLOCK MODE
	HRLM T,TYOOPN	;STORE FOR .OPEN ATTEMPT
	.OPEN TYOC,TYOOPN	;TRY TO OPEN IT
	JRST STYOC2	;LOST
STYOC3:	LSH T,9		;SHIFT OVER
	HRLZM T,10TYOL'	;STORE IN WORD DESCRIBING OUTPUT MODE (LOOKS TO SUDTAP LIKE LEFT 9 BITS OF 10TYIL)
STYOCX:	TLNE A,400	;SKIP IF SETTING TYI MODE
	JRST POPJ1	;NOT SETTING TYI MODE
	PUSH P,TT	;SAVE TT (AREN'T MODIFICATIONS FUN?)
	MOVE TT,A	;GET COPY OF WORD FOR MAYBE PUTTING INTO 10TYIL
	TRNN A,-1	;IF ADDRESS PART ZERO,
	JRST STTYC2	;THEN CLOSING
	LDB T,[240200,,A]	;<10,,> AND <20,,> BITS
	SETF UNECHF	;MOST MODES DON'T WANT TENLOD-SUPPLIED ECHO
	TLZ A,17	;CLEAR RANDOM BITS
	JRST .+1(T)	;DISPATCH ON PSEUDO-MODE
	TMODF ZA,UNECHF	;0 => NORMAL TENLOD INPUT MODE
	TLOA A,4	;4 => IMAGE MODE (NO ECHO)
	TLOA A,10	;10 => DDT MODE (ALSO 0)
	JFCL		;14 => TECO MODE (ALSO 4)
	HLLM A,TYIOPN	;NOW SAVE CALCULATED MODE FOR OPEN
	.OPEN TYIC,TYIOPN	;TRY IT
	JRST STTYC3	;LOST
STTYC4:	GET A,3(A)	;WON, GET BUFFER DESCRIPTOR
	HLRM A,10TIBS	;SAVE NUMBER OF CHARACTERS BUFFER SIZE
	HRRM A,10TBLC	;SAVE BUFFER LOCATION
	MOVEM TT,10TYIL	;SAVE AS TYI OPEN MODE
	POP P,TT	;RESTORE TT
	JRST POPJ1	;RETURN SKIPPING (SUCCESS)

		;.OPEN FOR OUTPUT LOST

STYOC2:	SETZM 10TYOL	;CLEAR WORD FOR DOCUMENTATION
	MOVEI T,TYOMOD
	HRLM T,TYOOPN
	.OPEN TYOC,TYOOPN
	.VALUE
	PUSHJ P,STYOCX	;PROCESS TYI OPEN
	JFCL
	MOVEI A,STYOC3	;MAYBE TELL 10OPNR WHERE .OPEN WAS
	POPJ P,

		;TYI .OPEN LOST, OR CLOSING TYI MODE

STTYC2:	AOS -1(P)	;CLOSING TYI MODE
STTYC3:	SETZM 10TYIL	;OPEN LOST, CLEAR 10TYIL
	PUSHJ P,IMITTY	;OPEN TYI IN IMAGE MODE
	SETF UNECHF	;SET FLAG NOT TO ECHO
	MOVEI A,STTYC4	;SET LOCATION FOR 10OPNR, MAYBE
	POP P,TT	;RESTORE TT (DIDN'T REALLY NEED IT, BUT...)
	POPJ P,		;RETURN, IF ERROR THEN NOT SKIPPING

		;RETURN (IN FN1) THE BUFFER LOCATION FOR TYI (ALSO MODE BITS IN LEFT HALF)

RTTYC:	MOVE T,10TYIL	;GET THE WORD
	ADD T,10TYOL	;ADD IN OUTPUT WORD (LEFT 9 BITS BELONG TO OUTPUT WORD, WORDS SEPARATED ONLY FOR TENLOD'S CONVENIENCE)
	PUT T,10FN1	;GIVE IT TO PDP10 PROGRAM
	JRST SETSWJ

;IF THIS THING EVER GETS DEBUGGED, A PROGRAM ON THE PDP10 WILL BE ABLE TO TAKE
;TYPEIN FROM THE PDP6. RESPONSE SHOULD BE REASONABLY FAST. THIS COMMUNICATION
;IS NOT HANDLED LIKE NORMAL SUDTAP COMMANDS, HOWEVER: IN OPERATION
;THE NORMAL COMMUNICATIONS AREA IS NOT USED. THE "SPECIAL COMMUNICATIONS AREA"
;IS NOT FIXED (DUE TO POSSIBILITY OF PROGRAM AND DDT BOTH WANTING TO DO TYI).
;IT IS SELECTED BY THE STTYC (SENSITIZE OR OPEN TTY), AND IT IS A FOUR WORD BLOCK IN THE 10.
;THE STTYC SPECIFIES THE LOCATION OF THE FIRST WORD IN THE BLOCK.

;THE FOURTH WORD IN THE BLOCK SHOULD CONTAIN A CONSTANT: THE LEFT HALF
	;SHOULD BE THE NUMBER OF CHARACTERS THE BUFFER ACCOMODATES; THE RIGHT
	;HALF SHOULD BE THE LOCATION OF THE BUFFER ITSELF.

	;THE BUFFER ITSELF IS A RING BUFFER. NOTE THAT IT IS ENTIRELY FILLED WITH NO WASTE.

;THE FIRST WORD IN THE BLOCK HAS THE CHARACTER ADDRESS OF THE LAST CHARACTER
	;DEPOSITED BY THE 6 INTO THE 10.

;THE SECOND WORD IN THE BLOCK HAS THE NUMBER OF CHARACTERS CURRENTLY IN THE BUFFER.

;THE THIRD WORD IN THE BLOCK IS AN INSTRUCTION. THE PROGRAM ON THE 10 SHOULD HAVE
	;THIS WORD INITIALIZED AS A SOSA OF THE CHARACTER COUNT, AND IT SHOULD
	;EXECUTE IT WHENEVER IT WANTS TO DECREMENT THE CHARACTER COUNT.
	;WHEN THE PDP6 PROGRAM IS HACKING THE AREA, IT MUNGS THIS LOCATION TO A 
	;(NEGATIVE) NO-OP WHICH, UNLIKE THE SOSA, WILL NOT SKIP.

10TYIL:	0		;0 => NOT IN TYI MODE, NON-ZERO => LOCATION OF BUFFER DESCRIPTOR AREA
			;BITS 3.1, 3.2 ALWAYS ZERO
			;BITS 3.4, 3.3 ECHO MODE
				;00 => NORMAL MODE (DDT MODE WITH TENLOD ECHOING WHAT ITS DOESN'T)
				;01 => IMAGE MODE (NO ECHO)
				;10 => DDT MODE
				;11 => TECO MODE INPUT
			;NOTE THE DIFFERENCE IN FUNCTION OF BITS 3.4, 3.3 BETWEEN THIS USAGE
				;AND THAT OF SAME BITS IN TTY .OPEN DEVICE WORD

10TIIC:	0		;CHARACTER ADDRESS OF LAST TYI CHARACTER DEPOSITED BY PDP6
10TICC:	0		;CHARACTER COUNT FOR TYI HACK
10TYSW:	0		;SWITCH FOR TYI HACK (SEE COMMENTS ABOVE)

		;TYPE OUT THE CHARACTER STRING IN THE PDP10 STARTING AT THE SPECIFIED LOCATION
		;CHARACTER STRING ENDS WITH CONTROL C OR CONTROL @

TYPOC:	HRRZ D,SCMD	;GET LOCATION OF STRING
	CAIL D,10SSW	;IF ABOVE SUDTAP COMMUNICATIONS AREA (NEAR TOP OF CORE),
	JRST 10ER3	;THEN COMPLAIN (CALL IT A MEMORY PROTECTION VIOLATION)
	ACCESS USRIC,(D)	;SET UP THE .ACCESS POINTER
TYPOC1:	MOVE T,[-TOBS,,UTIBUF]	;SEP UP POINTER FOR QUANTUM TRANSFER
	ADDI D,TOBS	;LOOK AT WHERE IT IS
	CAIL D,10SSW
	JRST TYPOC2	;ABOUT TO RUN INTO COMMUNICATIONS AREA, FORCE STOPPAGE (RETURNS TO TYPOC3)
TYPOC3:	.IOT USRIC,T	;GET QUANTUM FROM PDP10 CORE
	SETZM (T)	;MAKE SURE IT STOPS WHEN DONE WITH QUANTUM
	SKIPA B,[440700,,UTIBUF]	;SET UP TYPEOUT BYTE POINTER
TYPOC4:	PUSHJ P,TYO	;TYPE OUT CHARACTER (LOOP POINT FOR TYPEOUT)
	TESTF E,SILNT	;IF TYPEOUT SILENCED,
	JRST 10ER2	;THEN QUIT NOW; ALSO LET PDP10 PROGRAM KNOW TYPEOUT SILENCED
	ILDB A,B	;GET NEXT CHARACTER
	CAIE A,3	;IF CONTROL C,
	JUMPN A,TYPOC4	;OR IF CONTROL @ THEN DROP THROUGH, OTHERWISE LOOP FOR NEXT CHARACTER
	CAMN B,[350700,,UTIBUF+TOBS]	;IF AT END OF QUANTUM,
	JRST TYPOC1	;THEN MORE TO COME
	JRST SETSWJ	;NOT AT END OF QUANTUM, THEREFORE DONE

TYPOC2:	MOVSI D,-<10SSW-1>(D)	;MEMORY PROTECTION VIOLATION HANDLING ROUTINE
	ADD T,D
	JRST TYPOC3

		;GET A TYPED IN CHARACTER STRING ALLOWING RUBOUT

RTYPIC:	SKIPE A,SFN1
	HRRM A,RTYIDL	;DELIMITER
	CLEARF SDTSW\RTYIF	;FOR TYI AND EVENTUALLY INTERRUPT ROUTINE
	PUSH P,10TYIL	;SAVE FOR FOLLOWING HACK
	LDB A,[240200,,10TYIL]
	CAIE A,3
	MOVEI A,0
	DPB A,[240200,,10TYIL]
	PUSHJ P,IPITTY
	POP P,10TYIL	;RESTORE
	PUSHJ P,RTYI0	;READ IN THE STRING
RTYPC1:	MOVEI D,SETSWJ
		;FOLLOWING 2 INSTRUCTIONS DO 2'S COMPLEMENT BY SUBTRACTING 1
		;AND TAKING 1'S COMPLEMENT
	MOVSI T,-CMDBUF(B)	;NUMBER OF WORDS TO TRANSFER+1
	EQVI T,<-1>#CMDBUF	;FINISH BLOCK .IOT POINTER
	HRRZ A,SCMD
	BPUT T,(A)
RTYPC2:	MOVEI A,15	;RESTORE OLD DELIMITER
	HRRM A,RTYIDL
	PUSHJ P,IPITTY	;RE-INITIALIZE TTY
	SETF SDTSW	;POSSIBILITY OF TIMING ERROR ON WAKE-UP
	JRST (D)

		;RUBBED OUT TO BEFORE BEGINNING OF STRING

RTYIR2:	HRRZ A,(P)	;GET RETURN LOCATION
	CAIE A,RTYPC1
	ERR HUH		;BACK TO COMMAND LEVEL
	POP P,A
	MOVEI D,10ER2
	JRST RTYPC2
]		;END IFN SUDTSW,[] CONDITIONAL

	;PDP10 INTERNAL ROUTINES

TGPREP 37400+MOBY

TAG 10ST,
GOBEG:	SETZM MACCR
	CONO 635550+40000*OLDSW	;IO RESET, NXMEM OFF, AND FRIENDS
	CONO PI,11577+700000*OLDSW	;PI OFF, ETC.
	MOVE MACAC,10R41
	MOVEM MACAC,41	;GIVE PROGRAM ITS DESIRED C(41)
	SETOM DUNSW	;DOCUMENT RUNNAGE OF THIS ROUTINE
10DSP:	JSP MACQ,	;ACTUAL DISPATCH TO RELEVANT ROUTINE

TAG FGO,		;START HERE TO START UP PROGRAM VIA DDT
	MOVEI MACAC,10IRT	;ADDRESS OF ROUTINE...
	MOVEM MACAC,@DDT	;FOR DDT TO CALL FOR INPUT
TAG DDTGO,			;START HERE TO START UP DDT
	MOVE MACAC,10PGO	;GIVE STARTING INSTRUCTION TO DDT
	JRST DDT+1	;START UP DDT

TAG 10IRT,		;ROUTINE CALLED BY DDT FOR INPUT
	ILDB 10T,10BP	;GET CHARACTER IN "T"
	CAIN 10T,"X	;IF CHARACTER LAST IN STRING,
	SETZM @DDT	;THEN PREVENT THIS ROUTINE FROM BEING CALLED AGAIN
	POPJ 10P,

TAG 10STRI,		;TEXT OF COMMAND TO DDT FOR STARTING PROGRAM VIA DDT
DDSTRI:	ASCIZ /254000000100X/	;PROGRAM STARTED BY SAYING <INST> ALT X

TAG 10R41,
10SV41:	0		;SAVES LOCATION 41 FOR PROGRAM

TAG DUNSW,
	0		;-1 => THIS ROUTINE SUCCESSFULLY TRANSFERED TO

TAG 10PGO,
GOINST:	0		;ACTUAL INSTRUCTION USED TO START UP PROGRAM

TAG 10BP,
	440700,,10STRI	;DDT COMMAND POINTER

GOEND:

PRINTA START ROUTINE ,\GOEND-GOBEG, WORDS LONG.

PDPNAM:	(SIXBIT /USR/)
UNAME:	0
JNAME:	SIXBIT /PDP10/

DDTFIL:	6,,(SIXBIT /SYS/)
	SIXBIT /PDP10/
DDTFN2:	SIXBIT /DDT/	;CLOBBERED BY 1O AND 0O
	0		;SYSTEM NAME UNIMPORTANT

41SW:	0		;-1=> 10SV41 HAS C(41) VIA LOAD

		;FOLLOWING TWO LOCATIONS MUST REMAIN CONSECUTIVE

DDT1C:	-40,,DDT-2	;PUT INTO DDT-1 DURING SYMLOD
SVSYMP:	0		;SAVES DDT-2 FOR KILLING SYMS

SYMP:	SYMS		;AOBJN POINTER TO SYMBOL AREA

HUH:	ASCIZ /?   /	;FREQUENT ERROR "MESSAGE"

PDL:	BLOCK LPDL+16	;EXTRA FOR "WORST CASE" PDL OVERFLOW DETECTION AND PROCESSING

UTIBUF:	BLOCK UTIBFL	;LOADER BUFFER

PAT:
PATCH:	BLOCK 100	;PATCH AREA
PATCHE=.-1



		;BLURB TABLE

BTB:	.BYTE 12.
	REPEAT 100,[CONCAT CHB,\.RPCNT
]
	-1		;FOR END OF TABLE DETECTION
	.WALGN
	.BYTE

CONST1:	CONSTANTS	;CONSTANTS AREA
	VARIABLES



PRINTA HIGHEST USED = ,\.-1

SYMS:	END BEG		;BEGINNING OF SYMBOL AREA
SINT+1
ERRPIR:	0		;PIRQC AT RELEVANT INTERRUPT
ERRPCW:	0		;PC WORD STORED

		;TYI BREAK (RETURN TO TYBKRT)

TYIBRK:	.ITYI A,	;GET CHARACTER TYPED
	JRST TYBKRT	;NOT REALLY THERE
	CAIN A,^S	;IF CONTROL S,
	PUSHJ P,CTLSBK	;THEN MAYBE SILENCE TYPEOUT
IFE SUDTSW,JRST TYBKRT	;IF SUDTAP MODE DOESN'T EXIST, THEN THAT'S ALL
IFN SUDTSW,[TESTF N,SDTSW	;IF NOT IN SUDTAP MODE,
	JRST TYBKRT	;THEN THAT'S ALL
	SKIPN 10TYIL	;IF NOT IN CROCK TYI MODE,
	CAIE A,"W	;AND TYPED IN CHARACTER IS W,
	CAIN A,^X	;OR IF CHARACTER IS CONTROL S,
	JRST WAKUPB	;THEN WAKE UP
	AOSLE SNCHAR	;ANOTHER CHARACTER: THE FIRST?
	JRST TYBKRT	;NO
	PUSH P,TSINT	;YES
	PUSH P,TSINT+1
	PUSH P,G
	SKIPN 10TYIL	;IF NOT IN CROCK TYI MODE,
	TDZA G,G	;THEN SET INDEX TO ZERO
	MOVEI G,1	;IN TYI MODE, SET INDEX TO 1
	.DISMIS [TYIBK4]	;PROCESS CHARACTERS WHILE REMAINING INTERRUPTABLE

TYIBK4:	.STATUS TYIC,A		;GET TYI STATUS (FOR DISOWNED-ATTACHED CHECK)
	PUSHJ P,@TYWTDS(G)	;PROCESS A CHARACTER
	.SUSET [.SPICL,,[0]]	;TURN OFF INTERRUPTS (PREVENT PDL BUILDUP)
	SOSL SNCHAR		;ANOTHER CHARACTER PROCESSED: THE LAST ONE?
	.DISMIS [TYIBK4]	;NO, DO IT AGAIN
	POP P,G		;YES, RETURN TO INTERRUPT ROUTINE
	POP P,TSINT+1
	POP P,TSINT
	JRST TYBKRT

TYWTDS:	TYIBK2	;INACTIVE
	TYIBK3	;ACTIVE (IN CROCK TYI MODE)

		;WAKEUP CHARACTER TYPED

WAKUPB:	CLEARF SDTSW	;LEAVING SUDTAP MODE SOON
	SKIPN INTRET	;IF GOING TO DISMISS TO ERROR ROUTINE,
	TMODF CN,WAKUPF	;OR IF NOT SLEEPING,
	JRST TYBKRT	;THEN THAT'S ALL (IF NOT SLEEPING, 10SLP WILL SEE WAKUPF SET)
	MOVEI A,10SLP2	;NOT DISMISSING TO ERROR ROUTINE, AND MAIN PROGRAM SLEEPING
	MOVEM A,INTRET	;CLOBBER RETURN TO DISMISS TO 10SLP2, CAUSING WAKE-UP
	JRST TYBKRT

SNCHAR:	-1		;1 LESS THAN NUMBER OF CHARACTERS TYIBK4 TO EAT UP BEFORE RETURNING TO INTERRUPT ROUTINE
]			;END SUDTAP MODE CONDITIONAL

INTLEV:	-1		;1 LESS THAN NUMBER OF INTERRUPT LEVEL PUSH-DOWNS
INTRET:	0		;0 => DISMISS NORMALLY, NON-ZERO => PLACE IN MAIN PROGRAM TO DISMISS TO

CTLSBK:	.RESET TYOC,	;CONTROL S BREAK, RESET TYPEOUT
	SETF SILNT	;SILENCE TYPEOUT
	HRRZ A,TSINT+1	;GET PLACE THIS INTERRUPT CAME FROM (DON'T WORRY ABOUT INTLEV)
	CAIN A,TYOAE	;IF IT WAS HUNG ON TYP