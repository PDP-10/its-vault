.SBTTL	DIAGNOSTIC CONSOLE UTILITY PROGRAM CONTROL

	.=PRGSRT

;STARTING ADDRESSES AND CONTROL

$ILOAD:	JMP	UTILITY		;IF STARTED HERE RETURN TO CONSOLE
				;AFTER IDENTIFING SELF

;UTILITY IDENTIFICATION PARAMETERS

PID:	.RAD50	/KLDCPU/	;PROGRAM IDENTIFICATION
PDVER:	DECVER			;DEC VERSION NUMBER
PMVER:	MCNVER			;MCN VERSION NUMBER

	0
	0

;UTILITY SUB-PROGRAM STARTING ADDRESSES

PTABLE:	RXCOPY			;FLOPPY COPY
	DTCOPY			;DECTAPE COPY
	WFILE			;WRITE FILE FROM DECTAPE/FLOPPY TO RP04
	TAPT			;TRANSFER FILE FROM APT10 TO RP04
	DSKDIR			;RP04 DISK DIRECTORY
	REMOTE			;REMOTE TELETYPE COMMUNICATIONS
;UTILITY PROGRAM IDENTIFICATION

UTILITY:PFORCE

	PMSG	<\DECSYSTEM10 DIAGNOSTIC CONSOLE UTILITY\VERSION >

	MOV	#MCNVER,R0
	PNTOCS

	PNTCI
	'.

	MOV	#DECVER,R0
	PNTOCS

	PCRLF

	JMP	CONSOL		;RETURN TO CONSOLE
.SBTTL	FILE TRANSFER FROM APT10 TO RP04

;COMMAND - TA FILE.EXT
;MUST HAVE PREVIOUSLY SELECTED RP04

TAPT:	NAMEXT			;SETUP NAME & EXT

	RPFILE			;LOOKUP FILE ON RP04
	BCS	21$

12$:	MOV	#DVBUF,CDADR	;INIT BUFFER POINTER

	SETFLG
	  DEVLC			;INIT LINE COUNT

	COMENQ			;REQUEST APT10 SERVICE

	MOV	#$INBUF,R0
	MOV	#" P,(R0)	;CHANGE COMMAND TO "P"
	INC 	R0
	COMCMD			;TRANSMIT TO ACT10
	BCS	21$		;FILE NOT FOUND

11$:	INC	DEVLC		;COUNT LINE
	MOV	DEVLC,SWR	;DISPLAY

	MOV	#CINBF,R1	;TRANSFER TO DATA BUFFER
	MOV	CDADR,R0
1$:	CMP	#DVBUF+<256.*2>,R0	;FULL ?
	BEQ	2$		;YES

	MOVB	(R1)+,(R0)
	CMPB	#LF,(R0)+	;IF LF, END OF LINE
	BNE	1$

	MOV	R0,CDADR
	COMACK			;ACK ACT10
	BCC	11$
	BR	20$

2$:	PUSH	<R0,R1>
	MOV	#256.,BUFSIZ	;WRITE DATA BLOCK TO RP04
	MOV	#FILDSB,R0
	RPWRFL
	BCC	3$
	RPERROR			;WRITE ERROR

3$:	POP	<R1,R0>
	MOV	#DVBUF,R0	;REINIT POINTER
	MOV	R0,CDADR
	BR	1$

20$:	COMCLR
	JMP	$TARP2		;WRITE LAST BLOCK & EOF

21$:	JMP	$NONXF

$TARP2:	MOV	CDADR,R0
1$:	CLRB	(R0)+
	CMP	#DVBUF+<256.*2>,R0
	BNE	1$

2$:	MOV	CDADR,R0	;COMPUTE WORD COUNT
	SUB	#DVBUF,R0
	INC	R0
	BIC	#1,R0
	SR	R0,1
	MOV	R0,BUFSIZ	;SET AS BUFFER SIZE
	COM	RPEOF		;WRITE END-OF-FILE

	MOV	#FILDSB,R0
	RPWRFL			;WRITE LAST FILE DATA BLOCK
	BCS	$TADVR		;ERROR

	JMP	$CONSL		;WHEW !, ALL DONE

$TADVR:	RPERROR
.SBTTL	WRITE FILE FROM DECTAPE/FLOPPY TO RP04

;COMMAND - WF FILE.EXT
;MUST HAVE PREVIOUSLY SELECTED DECTAPE OR FLOPPY THEN RP04

WFILE:	NAMEXT			;SETUP NAME.EXT

	RPFILE			;LOOK UP FILE ON RP04
	BCS	10$

	TST	FLOPPY
	BEQ	20$
	RXFILE			;LOOKUP FILE ON FLOPPY
	BR	21$
20$:	DTAFILE			;LOOKUP FILE ON DECTAPE
21$:	BCS	10$

	MOV	#DTBUF1,R4	;USE THIS FOR DISK BUFFER
	MOV	R4,BUFADR
	MOV	#DVBUF+2,R5	;DECTAPE/FLOPPY BUFFER
	TST	FLOPPY
	BEQ	30$
	RXRDFL			;READ FIRST BLOCK FROM FLOPPY
	BR	31$
30$:	DTRDFL			;READ FIRST BLOCK FROM DECTAPE
31$:	 BCS	11$		;EOF, SHOULDN'T HAPPEN

1$:	CMP	#DTBUF1+<256.*2>,R4
	BEQ	2$		;DISK BUFFER FILLED

	CMP	#DVBUF+<256.*2>,R5
	BEQ	3$		;DECTAPE BUFFER EMPTY

	MOV	(R5)+,(R4)+	;MOVE DTA DATA TO DISK
	BR	1$

2$:	MOV	#FILDSB,R0
	RPWRFL			;WRITE DATA BLOCK TO RP04
	 BCS	12$		;ERROR

	MOV	#DTBUF1,R4
	BR	1$
3$:	TST	FLOPPY
	BEQ	40$
	RXRDFL			;READ FLOPPY BLOCK
	BR	41$
40$:	DTRDFL			;READ DECTAPE BLOCK
41$:	BCS	4$		;EOF

	MOV	#DVBUF+2,R5
	BR	1$

4$:	MOV	R4,R3
5$:	CLR	(R3)+		;CLEAR REMAINDER OF BUFFER
	CMP	#DTBUF1+<256.*2>,R3
	BNE	5$

	SUB	#DTBUF1,R4	;COMPUTE WORD COUNT
	SR	R4,1
	MOV	R4,BUFSIZ	;SET AS BUFFER SIZE
	COM	RPEOF		;WRITE RP04 END OF FILE

	MOV	#FILDSB,R0
	RPWRFL			;WRITE EOF
	 BCS	12$
	JMP	$CONSL

10$:	JMP	$NONXF

11$:	PMSG	<?PREMATURE EOF>
	JMP	$CNTLC

12$:	RPERROR			;RP04 ERROR

$NONXF:	PMSG	<NON-EX FILE>
	JMP	$CNTLC
.SBTTL	DECTAPE COPY ROUTINE

;COPY AND VERIFIES MASTER TAPE ON UNIT 0
;WITH NEW TAPE ON UNIT 1.

DTBUF1=70000
DTBUF2=DTBUF1+4000

DTCOPY:	$PMSG
	  $DTCOPY		;PRINT MESSAGE

1$:	TTALTM			;WAIT FOR ALTMODE
	 BCC	10$
	CMPB	#003,R0
	BNE	1$
	JMP	$CNTLC

;FORWARD COPY, COPY 4 BLOCKS, SKIP 4

10$:	PMSG	<$\>
	CLR	DTBLK		;START WITH BLOCK 0
	MOV	#72.,R5		;DO 72 TIMES
	MOV	#-1024.,WCSAV	;4 BLOCKS = 1024 WORDS
	MOV	#DTBUF1,CASAV	;SETUP BUFFER ADDRESS

2$:	JSR	PC,DTRDWT	;READ & WRITE

	ADD	#8.,DTBLK	;SKIP 4 BLOCKS
	DEC	R5		;DONE 72 TIMES
	BNE	2$		;NOT YET

	MOV	#-512.,WCSAV	;DO LAST TWO BLOCKS
	JSR	PC,DTRDWT

;REVERSE COPY, SKIPPED BLOCKS READ & WRITTEN IN REVERSE

	MOV	#-575.,DTBLK	;START WITH BLOCK 575
	MOV	#72.,R5		;DO 72 TIMES
	MOV	#-1024.,WCSAV	;4 BLOCKS

3$:	JSR	PC,DTRDWT	;READ & WRITE

	ADD	#8.,DTBLK	;BACKWARDS SKIP 4 BLOCKS
	DEC	R5		;DONE YET ?
	BNE	3$
;FORWARD VERIFY

	CLR	DTBLK
	MOV	#72.,R5
	MOV	#-1024.,WCSAV

4$:	JSR	PC,DTRDCMP	;READ & COMPARE

	ADD	#8.,DTBLK
	DEC	R5
	BNE	4$

	MOV	#-512.,WCSAV
	JSR	PC,DTRDCMP	;DO LAST 2 BLOCKS

;REVERSE VERIFY

	MOV	#-575.,DTBLK
	MOV	#72.,R5
	MOV	#-1024.,WCSAV

5$:	JSR	PC,DTRDCMP	;READ & COMPARE

	ADD	#8.,DTBLK
	DEC	R5
	BNE	5$

	PMSG	<\COPY COMPLETE>
	JMP	$CNTLC

$DTCOPY: .ASCII	'\MOUNT MASTER DECTAPE ON UNIT 0.'
	.ASCII	'\MOUNT NEW DECTAPE ON UNIT 1.'
	.ASCIZ	'\TYPE ALTMODE - _'
	.EVEN
DTRDWT:	CLR	DTUNIT		;UNIT 0
	DTREAD			;READ
	 BCS	BAD0
	MOVB	#1,DTUNIT+1	;UNIT 1
	DTWRT			;WRITE
	 BCS	BAD1
	RTS	PC

DTRDCMP:CLR	DTUNIT		;UNIT 0
	MOV	#DTBUF1,CASAV
	DTREAD			;READ
	 BCS	BAD0
	MOVB	#1,DTUNIT+1	;UNIT 1
	MOV	#DTBUF2,CASAV
	DTREAD			;READ
	 BCS	BAD1

	MOV	#DTBUF1,R0
	MOV	#DTBUF2,R1
	MOV	WCSAV,R2

1$:	CMP	(R0)+,(R1)+	;COMPARE UNIT 0 WITH UNIT 1
	BNE	2$		;ERROR
	INC	R2
	BNE	1$
	RTS	PC

2$:	PMSG	<\VERIFY ERROR>
DTCOPX:	JMP	$CNTLC

BAD0:	PMSG	<\BAD MASTER>
	BR	DTCOPX

BAD1:	PMSG	<\BAD UNIT 1>
	BR	DTCOPX
.SBTTL	FLOPPY COPY ROUTINE

;COPY AND VERIFIES MASTER FLOPPY ON UNIT 0
;WITH NEW FLOPPY ON UNIT 1.

RXBUF1=70000
RXBUF2=RXBUF1+4000

RXCOPY:	$PMSG
	  $RXCOPY		;PRINT MESSAGE

1$:	TTALTM			;WAIT FOR ALTMODE
	 BCC	10$
	CMPB	#003,R0
	BNE	1$
	JMP	$CNTLC

;COPY ONE BLOCK AT A TIME

10$:	PMSG	<$\>
	CLR	RXBLK		;START WITH BLOCK 0
	MOV	#494.,R5	;NUMBER OF READ/WRITES

2$:	CLR	RXUNIT		;READ FROM UNIT 0
	MOV	#256.,WCSAV	;1 BLOCK = 256 WORDS
	MOV	#RXBUF1,CASAV	;SETUP BUFFER ADDRESS

	RXREAD			;READ FLOPPY
	BCS	BAD0

	MOV	#RXU1,RXUNIT	;WRITE TO UNIT 1
	MOV	#256.,WCSAV
	MOV	#RXBUF1,CASAV

	RXWRT			;WRITE FLOPPY
	BCS	BAD1

	INC	RXBLK		;INCREMENT BLOCK NUMBER
	DEC	R5
	BNE	2$
;VERIFY 1 BLOCK AT A TIME

	PMSG	<STARTING VERIFICATION\>
	CLR	RXBLK
	MOV	#494.,R5
3$:	CLR	RXUNIT
	MOV	#256.,WCSAV
	MOV	#RXBUF1,CASAV

	RXREAD			;READ MASTER
	BCS	BAD0

	MOV	#RXU1,RXUNIT
	MOV	#256.,WCSAV
	MOV	#RXBUF2,CASAV

	RXREAD			;READ NEW COPY
	BCS	BAD1

	MOV	#RXBUF1,R0
	MOV	#RXBUF2,R1
	MOV	#256.,R2

4$:	CMP	(R0)+,(R1)+	;CHECK MASTER AND NEW COPY
	BNE	5$		;DATA ERROR
	DEC	R2
	BNE	4$

	INC	RXBLK
	DEC	R5
	BNE	3$
	PMSG	<\COPY COMPLETED>
	JMP	$CNTLC

5$:	PMSG	<\VERIFY ERROR>
	JMP	$CNTLC

$RXCOPY: .ASCII	'\MOUNT MASTER FLOPPY ON UNIT 0.'
	.ASCII	'\MOUNT NEW FLOPPY ON UNIT 1.'
	.ASCIZ	'\TYPE ALTMODE - _'
	.EVEN
.SBTTL	RP04 DIRECTORY ROUTINE

DSKDIR:	MOV	#FILDSB,R5	;SETUP FILE DESCRIPTOR POINTER
	MOV	#RPFDCY,R4	;SETUP DIRECTORY START
	MOV	(R4)+,4*2(R5)
	MOV	(R4)+,5*2(R5)
	MOV	(R4),R0		;CHANGE DIR BLOCK COUNT
	SHIFTL			;TO WORD COUNT
	  8.
	MOV	R0,9.*2(R5)
	CLR	8.*2(R5)

	MOV	R5,R4
	ADD	#FDESIZ*2,R4
	CLR	(R4)+		;CLEAR CURRENT POSITION
	CLR	(R4)

	PCRLF
	$PMSG
	  $$RPHDR
	PTAB
	PTAB
	$PMSG
	  $$RPHDR
	PCRLF
	PCRLF
	CLR	R1
1$:	MOV	R5,R0
	RPRDFL			;READ DIRECTORY DATA BLOCK
	 BCS	3$

	MOV	(R0)+,R4	;DATA BUFFER POSITION
	MOV	(R0),R3		;BYTE COUNT

2$:	MOV	0*2(R4),DIRST0	;PICKUP RAD50 "FILE.EXT"
	MOV	1*2(R4),DIRST1
	MOV	2*2(R4),DTEXT
	TST	DIRST0		;DON'T PRINT IF BLANK
	BEQ	6$
	CMP	#-1,DIRST0
	BEQ	6$
	CMP	#-2,DIRST0
	BEQ	6$

	R50UPK			;CONVERT TO ASCII
	 DIRST0,DIRST2
	  BCS	5$
	R50UPK
	 DIRST1,DIRST3+1
	  BCS	5$
	R50UPK
	 DTEXT,DTEXTS
	  BCS	5$
	CLR	NAMBF
	CLR	DTEXT
	CMP	#020040,DIRST2	;DON'T PRINT IF SPACES
	BEQ	6$
	$PMSG			;PRINT "FILE"
	  DIRST2
	PSPACE
	$PMSG			;PRINT "EXT"
	  DTEXTS
	PTAB
	MOV	6*2(R4),R2
	SWAB	R2
	BISB	<7*2>+1(R4),R2
	TSTB	7*2(R4)
	BEQ	10$
	INC	R2
10$:	MOV	R2,R0
	PNTDEC			;PRINT ALLOCATED BLOCKS
	PTAB
	MOV	8.*2(R4),R2
	SWAB	R2
	BISB	<9.*2>+1(R4),R2
	TSTB	9.*2(R4)
	BEQ	11$
	INC	R2
11$:	MOV	R2,R0
	PNTDEC			;PRINT BLOCKS WRITTEN
	INC	R1
	BIT	#1,R1
	BEQ	12$
	PTAB
	PTAB
	BR	6$
12$:	PCRLF
6$:	ADD	#FDESIZ*2,R4	;FINISHED THIS DIR BLOCK ?
	SUB	#FDESIZ*2,R3
	BHI	2$		;NO
	BR	1$		;YES, GO READ NEXT
3$:	CMP	#1,R0		;EOF ?
	BNE	4$
	PCRLF
	JMP	$CONSL		;YES
4$:	RPERROR			;NO, ERROR
5$:	MOV	#-25,R0		;RAD50 CONVERSION ERROR
	BR	4$
$$RPHDR:.ASCIZ	%FILE   EXT	ALLOCB	WRTB%
.EVEN
.SBTTL	REMOTE TELETYPE COMMUNICATIONS ROUTINE

TOUTBF=70000		;OUTPUT BUFFER ADDRESS
TOUTBL=TOUTBF+100.	;OUTPUT BUFFER LIMIT
TINBF=TOUTBL+2		;INPUT BUFFER ADDRESS
TINBL=CONSOL-4		;INPUT BUFFER LIMIT

;CONTROL A RETURNS TO COMMAND LEVEL
;CONTROL L CONTROLS LINE PRINTER

REMOTE:	PNORML
	CLR	CONSOL-2	;CLEAR OVERLAY IN-USE INDICATOR
	MOV	#TOUTBF,R5	;SETUP TTY TO COMM POINTERS
	MOV	R5,R4
	MOV	#TINBF,R3	;SETUP COMM TO TTY POINTERS
	MOV	R3,R2

TTLP:	TSTB	@$TKS		;ANY TTY TYPE-IN ?
	BPL	TTLP1		;NO
	MOVB	@$TKB,R0	;YES, GET TYPED CHAR
	BIC	#200,R0
	CMPB	#CNTRLA,R0	;IS IT A CONTROL A ?
	BEQ	TTCMD		;YES, RETURN TO COMMAND LEVEL
	CMPB	#CNTRLL,R0	;IS IT CONTROL L ?
	BEQ	TTLPT		;YES
	MOVB	R0,(R5)+	;PUT CHAR IN BUFFER
	CMP	#TOUTBL,R5	;REACHED LIMIT ?
	BNE	TTLP1		;NO
	MOV	#TOUTBF,R5	;YES, RESET INSERTION POINTER

TTLP1:	CMP	R4,R5		;INSERTION & SEND POINTERS EQUAL ?
	BEQ	TTLP2		;YES, NOTHING TO SEND
	TSTB	@$CMTPS		;CAN WE SEND ?
	BPL	TTLP2		;NO, NOT THRU WITH PREVIOUS CHAR
	MOVB	(R4)+,@$CMTPB	;YES, SEND CHAR OUT
	CMP	#TOUTBL,R4	;REACHED LIMIT ?
	BNE	TTLP2		;NO
	MOV	#TOUTBF,R4	;YES, RESET SEND POINTER

TTLP2:	TSTB	@$CMTKS		;ANY COMM INPUT ?
	BPL	TTLP3		;NO
	MOVB	@$CMTKB,(R3)	;YES, STORE CHAR
	BICB	#200,(R3)+
	CMP	#TINBL,R3	;REACHED LIMIT ?
	BNE	TTLP3		;NO
	MOV	#TINBF,R3	;YES, RESET COMM INPUT POINTER
TTLP3:	CMP	R2,R3		;COMM INPUT & PRINT POINTERS EQUAL ?
	BEQ	TTLP		;YES, NOTHING TO PRINT
	TST	LPTFLG		;PRINT ON LPT ?
	BMI	3$		;YES
1$:	TSTB	@$TPS		;CAN WE PRINT ?
	BMI	TTLP		;NO, NOT YET
	MOVB	(R2)+,@$TPB	;YES, PRINT CHAR

2$:	CMP	#TINBL,R2	;REACHED LIMIT ?
	BNE	TTLP		;NO
	MOV	#TINBF,R2	;YES, RESET PRINT POINTER
	BR	TTLP

3$:	TSTB	LPTFLG		;CONTROL L'ED TO ALLOW LPT ?
	BEQ	1$		;NO
	TST	LPTYPE
	BNE	10$
	TSTB	@$LPS		;LPT READY ?
	BPL	TTLP		;NO
	CMPB	(R2),#RUBOUT	;DUMP RUBOUTS
	BEQ	4$
	MOVB	(R2)+,@$LPB	;SEND CHAR TO LPT
	BR	2$

4$:	INC	R2		;RUBOUT, BYPASS IT
	BR	2$

10$:	MOV	LPTYPE,R1	;LP20
	BIT	#LPERR!LPPZRO!LPUCHR,(R1) ;ANY ERROR ?
	BNE	TTLPT		;YES, TURN OFF LPT
	TSTB	(R1)		;LP20 DONE ?
	BPL	TTLP
	CMPB	(R2),#RUBOUT	;DUMP RUBOUTS
	BEQ	4$
	MOVB	(R2)+,$TNCHR	;PUT CHAR IN OUTPUT LOCATION
	MOV	#$TNCHR,LPBSAD(R1)
	MOV	#-1,LPBCTR(R1)
	MOV	#LPGO,(R1)	;PRINT ONE CHARACTER ON LP20
	BR	2$
TTLPT:	COMB	LPTFLG		;CONTROL L, COMPLEMENT
	BR	TTLP		;ALLOW LPT FLAG

TTCMD:	JMP	CONSOL		;RETURN TO COMMAND LEVEL
 