.title TINTE is not TECO either
;warning, this program suffers from an overdose of local symbols

.sbttl definitions
.if nz 5
;rt11=1
;sits=0
lsi=1
sits=1
gt2500=1
.endc

.iif ndf sits,sits=1		;if =1, use sits system calls
.iif ndf rt11,rt11=0		;if =1, use rt11 system calls
.iif ndf lsi,lsi=0		;if =1, on lsi, independent of rt11 vs sits
.iif ndf frp,frp=0		;if =1 use french prompts
.iif ndf gt2500,gt2500=0
tvs=0
.iif nz sits, .iif z lsi, tvs=1

.if nz rt11
.mcall .lookup,.enter,.readw,.scca,.ttyout,.writw,.date,.gtim,.exit
.mcall .ttyin,.close,.delete,.lookup,.purge,.rename,.fetch,.lock
.mcall .qset,.rctrlo,.settop,.ttinr,.gtim
.enabl lc

jsw=44
 jswlc=40000			;enable lower case
 jswren=20000			;enable reenter
 jswspm=10000			;special tty mode
 jswntw=100			;always return on tty call
 jswene=20			;enable escape sequence processing

rtmemh=50			;highest address rt11 thinks we use
rterrb=52			;error byte

.endc

.if z rt11
.iif z lsi,prtnum=14		;on 11/45, printer tty number
.iif nz lsi,prtnum=1		;on the lsi
.iff
prtnum=0			;no printer
.endc

.iif z rt11,vern=%fnam2

.if nz sits
.macro dcs name,val
name==val
.endm
.insrt sits;sitss syms
.endc	;nz sits

a=%0
b=%1
c=%2
d=%3
e=%4
f=%5
p=%6
pc=%7


.macro save things
	.irp  x,<things>
		.if b x
			tst -(p)
		.iff
			.if idn x,#0
				clr -(p)
			.iff
				mov x,-(p)
			.endc
		.endc
	.endm
.endm

.macro rest things
	.irp x,<things>
		.if b x
			tst (p)+
		.iff
			mov (p)+,x
		.endc
	.endm
.endm

;Macro to assemble code for english
.macro eng foo
.iif z frp,	foo
.endm

;Macro to assemble code for french
.macro fr foo
.iif nz frp,	foo
.endm

.sbttl miscelaneous storage

bptbrv=14
trpbrv=34

.iif nz rt11, .asect
.=bptbrv
	.+2
	baderr
.=trpbrv
	trpbrk

.iif nz rt11, .csect

.if z rt11
.=40

.if nz lsi
	trpbrk			;special trap at 40 on the lsi
.=300
	jmp start
	jmp zstart
.=400
.endc	;nz lsi
.endc	;z rt11

.if nz sits&lsi
lstty=2
lsline=0
lsdisk=1
lsprnt=0
lsmap=0
lsclk=1
.iif ndf rkdsk
rkdsk==0
smsdsk==1
.endc
.insrt rjl;flopdf
.insrt nlogo;lsitvr
.insrt nlogo;lsits
.endc	;nz sits&lsi


pdle:	123456			;for debugging, to see if pdl overflew
	.blkw 200
pdl:	0			;pdl for normal editing job
				;pointer stored here when print job running
patch:
pat:	.blkw 400
memtop:	spacey			;for non-lsi sits spacey is just the top location
				;on the lsi, this is set to the memory top
free:	0			;pointer to first block in the free chain
minmem:	0			;1/16th of free memory
minme2:	0			;1/8 of free memory
ran:	0			;if non-zero we have ben started once

ctrl=200			;control bit
meta=400			;meta bit
ctmtbt:	0			;meta and control bits
lastch:	0			;last (currently being processed) character typed in
rescan:	0			;character to be re-read
tyisav:	0			;for RT11, the character input by the last tyip
repcnt:	0			;repeat count for the command
noun:	char			;what type of object to act on, for certain operations
;**** don't change these without changing the dispatch tables in the code
 char=0				;single character
 word=2				;word
 line=4				;line
 senten=6			;sentence
 para=10			;paragraph

;Character set used by TINTE in the buffer and in files:

pagchr=14			;never appears in buffer; in file => end of page
eolchr=15			;never appears in the buffer; in a file=> end of line

;40-176	regular ASCII set

;201-217 upper case accent characters
;230	accent grave
;231 accent circomflex
;232 trema
;233 accent ague
;241-257 lower case accent characters
fixchr=300			;fixed space
subchr=301			;downarrow, subscript
supchr=302			;uparrow, superscript
lftchr=303			;left arrow, something exists before left margin
rgtchr=304			;right arrow, line overflows screen
cmdchr=305			;command indication
ohpchr=306			;optional hyphen character

atribc=360			;this and above are the set-attribute characters
atrund=1			;underline bit
atrbld=2			;bold (reverse video) bit

.sbttl screen and buffer variables
zero:	0			;on first start or zstart this page is set to zero
ibufsz=100			;intial size of a buffer
ilinsz=10			;intial size of a line
bufinc=100			;amount to increment buffer size by
lininc=10			;amount to increment line size by

buffer:	0			;pointer to the currently selected buffer
bufend:	0			;line number of first non-ex line
ubufep:	0			;used by update, pointer to the first non-ex line
statln:	.blkb 128.		;image of status line
dstcar:	0			;temp used by dstat
pchr:	0			;either htyo or stypec

defstr:	0			;pointer to the string to use if zero-length string given
maxstr=60.
maxstl:	0			;maximum string length to allow
strtrc:	0			;terminating character other in normal range
string:	.blkb maxstr-1		;string input
strine:	.byte 0			;end of string
strarg:	.blkb 20.		;string arguments, like measurements and yes/no
prtcms:	.blkb maxstr		;the printer command string from the source
maxsrs=60.			;max search string
serdir:	0			;search direction
serstr:	.blkb maxsrs		;the search string


maxlin=35.			;biggest possible screen
screen:	.blkw maxlin		;pointers to lines currently displayed
scrend:	;(end mark)		;if a line in the buffer is going to get modified
				;and is on the screen it gets copied first
				;unless whoever updates it also updates the screen
				;a zero pointer implies we don't know what is on the
				;line.
blank=1				;a 1 indicates that the line is known to be blank

screeb:	.blkw maxlin		;if non-zero the cooresponding screen line is also
				;an active buffer line => don't delete it
screls:	.blkw maxlin		;display character number in real line that starts this line
screle:	.blkw maxlin		;ending display character number
nscren:	.blkw maxlin		;new screen
nscrls:	.blkw maxlin		;new starts
nscrle:	.blkw maxlin		;and new ends
nline:	.blkw 100.		;place to put the line about to be printed
oline:	.blkw 100.		;place to put the line that is already on the screen

lftmar:	0			;start displaying characters >= this positon
				;used with chop to see the right side of long lines
				;changing this invalidates the whole screen
toplin:	0			;line number of the top line displayed
ntopln:	0			;temporary for the new top line number
nscres:	0			;the new display char starting point
screes:	0			;character number in first line where display starts
screee:	0			;character number in last line where screen ends

curlin:	0			;line number the cursor is on in the current barfer
curcar:	0			;character number in the above line
goalcl:	0			;goal column (character number in line)
linst:	0			;a temp used by dislin


				;rather than continueing them
;kill ring buffer
kstlin:	0			;starting line number of thing on the top
kenlin:	0			;ending line number of thing at the top
kstcar:	0			;starting character pos of thing at the top
kencar:	0			;ending character pos of thing at the top
ktopp:	0			;pointer (index) to the top
kcount:	0			;count of things in the ring buffer
maxkil=10.			;maximum number of things on the kill ring
kbuf:	.blkw maxkil		;pointers to the objects
kfline=1			;if this bit is set the thing is a line
				;if the bit is clear it is a buffer
kflags:	.blkw maxkil		;flags about the objects

kiltln:	0			;temp place to put the kill line
zeroe:				;end of stuff that gets zeroed

autofl:	70.			;place to auto fill
tabmod:	rt11			;if non-zero tabs get inserted, else they insert fixed spaces
fixspp:	0			;if non-zero print fixed spaces so they can be seen
boldmd:	0			;if yes all text is entered bold
undrmd:	0			;if yes all text is entered underlined
shtlck:	0			;if yes translate all lower case input to upper case
chop:	0			;if nono-zero chop the lines at the right margin

ttybfl=400.
ttybuf:	.blkb ttybfl		;buffer to make tty output fast
ttybfc:	0			;count of used space in buffer
ttybfp:	ttybuf			;pointer to free place in buffer

ttemp:	0			;totally random temporary
ftemp:	0			;used by gfile

linpos:	-1			;line number of screen the cursor is on (doesn't count stat)
rlinps:	0			;real line it is on (maintained by terminal routines)
carpos:	0			;character number on the line the cursor is on
linspd:	1			;line speed in milliseconds/character

;terminal dependent stuff
rnmlin:	24.			;number of lines that fit on our screen
numlin:	23.			;number of lines not counting status line
numcar:	80.			;number of characters per line
idline:	1			;if non-zero we have insert/delete line capability
maxid:	4			;maximum number of insert/deletes to do
idchar:	1			;if non-zero we have insert/delete char capability

;dispatches to routines
abspos:	c1absp			;absolute cursor positioning
tinlin:	c1tinl			;insert a line
tdelin:	c1tdel			;delete a line
typec:	c1type			;type a single character on the screen
				;this will keep track of the cursor position if the
				;terminal needs that and will translate accent
				;and any other funny printing characters
				;it does not take care of line overflow
terint:	c1teri			;init the terminal, including clearing the screen
clrscr:	c1clrs			;clear screen, set cursor to zero
eosclr:	c1eosc			;clear to end of screen
clreol:	c1clre			;clear from cursor position to end of line
sclrel:	c1sclr			;special minimal padding version
underl:	c1unde			;turn on underlining
nundrl:	c1nund			;turn off underlining
blink:	c1blin			;turn on blinking
nblink:	c1nbli			;turn off blinking
revvid:	c1revv			;reverse video
nrevid:	c1nrev			;turn off reverse video
setatr:	c1seta			;set attributes

;termty: c1tab			;the terminal type
.iif nz gt2500, termty: 25tab

ctab:	c1ctab			;the character dispatch table

;Macro to define a terminal.
;Note that term has to be at most two characters
.macro termd name,term,lin,car,idlin,max,idcar,disptb
name'tab:
	.irp x,<rnmlin,lin,numlin,lin-1,numcar,car,idline,idlin,idchar,idcar,maxid,max>
	x
	.endr

	.irp x,<abspos,tinlin,tdelin,typec,terint,clrscr,eosclr,clreol,sclrel,underl,nundrl,blink,nblink,revvid,nrevid,setatr>
	x
	term''x
	.endr
	ctab
	disptb
	0
.endm

yes=1				;yess must ALWAYS be NON-ZERO!!!
no=0				;no must ALWAYS be ZERO!!!

;termd c1,c1,24.,80.,yes,4,yes,c1ctab
;termd tt,tt,30.,72.,no,0,no,ttctab
;termd tc,tt,30.,72.,no,0,no,c1ctab
.iif nz tvs, termd tv,tv,38.,96.,no,0,no,tvctab
.iif nz gt2500, termd 25,25,30.,72.,no,0,no,25ctab

;atribute translation for c100
c1atrs:	.byte 10,14,50,54,10,14,50,54,10,14,50,54,10,14,50,54

c1spcc:	.byte 36,26,27,34,35,37,0,0	;special character translation

catrib:	0			;the current atributes for the c-100
c1fnt:	0			;the currently selected font
atrtem:	0			;temp to store an atribute in



;menu stuff
;a menu item looks like:
menufl=0			;flags
 menuex=1			;exists
 menuti=2			;title
 menuio=4			;set this bit for insert-only frobs in print menu
menudp=2			;dispatch address if item selected
menuvr=4			;variable associated with item
menuvp=6			;routine that knows how to print the variable
menud1=10			;default value for first word of variable
menuir=12			;insert routine for this item
menuoh=14			;overhead, where the text starts

.macro menui text,dispat,var,varprt,def1,insrot,io
.if df pass2
.if nb dispat
.if ndf dispat
.error ;dispat not defined
dispat=chrund
.endc
.endc
.endc
foo=menuex
.iif b dispat,.iif b insrot,foo=menuti
.iif nb io,foo=menuio
	foo
	dispat
.iif b dispat,0
	var
.iif b var,0
	varprt
.iif b varprt,0
	def1
.iif b def1,0
	insrot
.iif b insrot,0
	.asciz &text&
	.even
.endm

bits:	.asciz &BITS&		;for finding the bit table

filep:
eng <	.asciz &File:&>		;file prompt
fr  <	.asciz &Fichier:&>		;file prompt

disknp:
eng <	.asciz &Disk number:&>	;disk number prompt
fr  <	.asciz &Numero du disque:&>	;disk number prompt

searcp:
eng <	.asciz &Search:&>
fr  <	.asciz &Cherche:&>

rsercp:
eng <	.asciz &Reverse search:&>
fr  <	.asciz &Cherche en arriere:&>

savep:
eng <	.asciz &Save file:&>
fr  <	.asciz &Fichier pour sauver:&>

yesstr:
eng <	.asciz &Yes&>
fr  <	.asciz &Oui&>

nostr:
eng <	.asciz &No&>
fr  <	.asciz &Non&>

modep:
eng <	.asciz &Select entry modes:&>
fr  <	.asciz &Choisir modes d'entr/ee:&>

excmdp:
eng <	.asciz &General commands:&>
fr  <	.asciz &Commandes g/en/erales:&>

argstr:
eng <	.asciz &Argument:&>
fr  <	.asciz &Argument:&>

printp:
eng <	.asciz &Printer:&>
fr  <	.asciz &Imprimante:&>

deletp:
eng <	.asciz &Delete file?&>
fr  <	.asciz &D/etruis fichier?&>

eng <	inches:	.asciz & in&>
fr  <	inches:	.asciz & po&>
cm:	.asciz & cm&

	.even





filehl:
eng <	menui <File commands:>>
fr  <	menui <Commandes du fichier:>>
eng <	menui <Edit>,fedit>
fr  <	menui <Edite>,fedit>
eng <	menui <Read>,fread>
fr  <	menui <Ram\ene>,fread>
eng <	menui <Save>,fsave>
fr  <	menui <Sauve>,fsave>
eng <	menui <Delete>,fdelet>
fr  <	menui <D/etruis>,fdelet>
.if nz sits
eng <	menui <Directory delete>,ddelet>
fr  <	menui <Index \a d/etruire>,ddelet>
.endc
.if nz lsi&sits
eng <	menui <Chain>,fchain>
fr  <	menui <Encha^ine>,fchain>
.endc
.if nz sits
eng <	menui <Create index>,icreat>
fr  <	menui <Cr/ee index>,icreat>
.endc
eng <	menui <Show index>,sindex>
fr  <	menui <Montre index>,sindex>
eng <	menui <Insert>,finsrt>
fr  <	menui <Insert>,finsrt>
eng <	menui <Append>,fappen>
fr  <	menui <Ajoute>,fappen>
	0


;entry modes
emodem:
eng <	menui <Entry modes:>>
fr  <	menui <Modes d'entr/ee:>>
eng <	menui <Auto fill column>,msetnm,autofl,mprtnm,70.>
fr  <	menui <Retour automatique>,msetnm,autofl,mprtnm,70.>
eng <	menui <French input>,msetyn,french,mprtyn,no>
fr  <	menui <Accents fran/cais>,msetyn,french,mprtyn,yes>
eng <	menui <Show fixed spaces>,msetsf,fixspp,mprtyn,no>
fr  <	menui <Espaces fixes>,msetsf,fixspp,mprtyn,no>
eng <	menui <Shift lock>,msetsl,shtlck,mprtyn,no>
fr  <	menui <Majuscules>,msetsl,shtlck,mprtyn,no>
;eng <	menui <Chop lines>,msetyn,chop,mprtyn,no>
;fr  <	menui <Lignes bris/ees>,msetyn,chop,mprtyn,no>
eng <	menui <Bold entry>,msetyn,boldmd,mprtyn,no>
fr  <	menui <Caract\eres gras>,msetyn,boldmd,mprtyn,no>
eng <	menui <Underline entry>,msetyn,undrmd,mprtyn,no>
fr  <	menui <Souligner>,msetyn,undrmd,mprtyn,no>
eng <	menui <Reset entry modes>,mreset>
fr  <	menui <Modes de d/epart>,mreset>
	0
;extended commands
excmdm:
eng <	menui <General commands:>>
fr  <	menui <Commandes g/en/erales:>>
eng <	menui <Delete memory>,kilbuf>
fr  <	menui <Efface tout>,kilbuf>
eng <	menui <Reset everything>,reseta>
fr  <	menui <Mise \a z/ero de tout>,reseta>
	0

.if nz prtnum
;print menu
printm:
eng <	menui <Printer commands:>>
fr  <	menui <Commandes de l'imprimante:>>
setpmp=.+menuoh			;make a pointer to the next string, for chrspr
eng <	menui <Set modes>,setpmd>
fr  <	menui <Fixe les modalit/es>,setpmd>
inspmp=.+menuoh			;make a pointer to the next string, for chripr
eng <	menui <Insert print command>,inspcm>
fr  <	menui <Ins\ere les commandes d'impression>,inspcm>
eng <	menui <Verbatim print memory>,chrvpr>
fr  <	menui <M/emoire imprim/ee telle quelle>,chrvpr>
eng <	menui <Print memory>,chrprj>
fr  <	menui <Imprime m/emorie>,chrprj>
eng <	menui <Verbatim print file>,filprt>
fr  <	menui <Fichier imprim/e tel quel>,filprt>
eng <	menui <Print file>,filjpr>
fr  <	menui <Imprime le fichier>,filjpr>
	0

;printer modes menu
prtmdm:
eng <	menui <Printer:>>
fr  <	menui <Imprimante:>>
eng <	menui <Justify>,msetju,pradjm,mprtyn,no,minscn>
fr  <	menui <Justifie>,msetju,pradjm,mprtyn,no,minscn>
eng <	menui <Fill>,msetyn,prfilm,mprtyn,yes,minsyn>
fr  <	menui <Remplis>,msetyn,prfilm,mprtyn,yes,minsyn>
eng <	menui <Center>,msetcn,prcenm,mprtyn,no,minscn>
fr  <	menui <Centre>,msetcn,prcenm,mprtyn,no,minscn>
eng <	menui <Right adjust>,msetcn,prrgtm,mprtyn,no,minscn>
fr  <	menui <Ajuste \a droite>,msetcn,prrgtm,mprtyn,no,minscn>
eng <	menui <Left adjust>,msetcn,prlftm,mprtyn,no,minscn>
fr  <	menui <Ajuste \a gauche>,msetcn,prlftm,mprtyn,no,minscn>
eng <	menui <French typewheel>,msetyn,prfrfm,mprtyn,no,minsyn>
fr  <	menui <Marguerite fran/caise>,msetyn,prfrfm,mprtyn,yes,minsyn>
eng <	menui <Pitch>,msetpt,prpitc,mprtnm,10.,minspt>
fr  <	menui <Pas d'impression>,msetpt,prpitc,mprtnm,10.,minspt>
eng <	menui <Metric measurements>,msetyn,prmetm,mprtyn,no>
fr  <	menui <Mesures m/etriques>,msetyn,prmetm,mprtyn,yes>
eng <	menui <Continous paper>,msetyn,prcnpm,mprtyn,no>
fr  <	menui <Papier continu>,msetyn,prcnpm,mprtyn,no>
eng <	menui <Page width>,msetms,piwidt,mprtms,8500.,minsms>
fr  <	menui <Largeur de page>,msetms,piwidt,mprtms,8500.,minsms>
eng <	menui <Text width>,msetms,pitwid,mprtms,6250.,minsms>
fr  <	menui <Largeur du texte>,msetms,pitwid,mprtms,6250.,minsms>
eng <	menui <Page length>,msetms,pilent,mprtms,11000.,minsms>
fr  <	menui <Longueur de page>,msetms,pilent,mprtms,11000.,minsms>
eng <	menui <Text length>,msettl,pitlen,mprtms,9000.,minsms>
fr  <	menui <Longueur du texte>,msettl,pitlen,mprtms,9000.,minsms>
eng <	menui <Lines per page>,msetlp,plinpp,mprtnm,48.,minsnm>
fr  <	menui <Nombre de lignes par page>,msetlp,plinpp,mprtnm,48.,minsnm>
eng <	menui <Interline spacing>,msetis,plinis,mprtms,187.,minsms>
fr  <	menui <Espacement d'interligne>,msetis,plinis,mprtms,187.,minsms>
eng <	menui <Indent>,msetms,pindnt,,0,minsms,io>
fr  <	menui <Alin/ea>,msetms,pindnt,,0,minsms,io>
eng <	menui <Printer pause>,prstop,,,,minscn,io>
fr  <	menui <Pause d'impression>,prstop,,,,minscn,io>
eng <	menui <New page>,prnpag,,,,minscn,io>
fr  <	menui <Nouvelle page>,prnpag,,,,minscn,io>
eng <	menui <Start quote>,prstqu,,,,minscn,io>
fr  <	menui <Citation d/ebut>,prstqu,,,,minscn,io>
eng <	menui <End quote>,prenqu,,,,minscn,io>
fr  <	menui <Citation fin>,prenqu,,,,minscn,io>
eng <	menui <Reset printer modes>,preset>
fr  <	menui <Mise \a z/ero>,preset>
	0

prtsav:	.blkw 30.		;this must be at least as long as there are variables in the
				;printer menu
.endc ;nz prtnum

quitrt:	chrqui			;quit routine

menusv:	0			;temp to keep menu pointer
menueq:	0			;temp for menu stuff
prtspc:	0			;special for print menu

;status array: pointers to asciz strings to print on the status line
statar:	greet			;name of the crock
slstat:	0			;shift locked message
erstat:	0			;error message
filein:	0			;file name open for input
filout:	0			;file name open for output
prompt:	0			;prompting for file, menu, etc.
strech:	0			;string being input
prstat:	0			;printer status (for background printer)
statae:				;end of whatever you like
greet:	.asciz /Pro Plus V0/	;boy, is this EVER version 0!!!
eng <slmes:	.asciz /SL/>		;shift locked
fr  <slmes:	.asciz /MAJ/>
;variables for tabs
tabs:	.blkb 200./8.		;allow for up to 200. tab stops on character positions
	.even
tabe:				;here kitty, kitty
bmt:	.byte 1,2,4,10,20,40,100,200	;tabs stops are bits


;variables for sits file stuff
.ifnz sits
eword:	0			;error word from last .gerrw
curcap:	0			;cabability to current directory
curdsk:	0			;number of current disk
rotref:	.blkw 4			;reference count for root caps
.iif z lsi,	rotcps:	10,11,12,13	;for non-lsi sits
.iif nz lsi,	rotcps:	.blkw 4
maxdnm=60.			;maximum length of directory path
maxfnm=16.			;maximum lenght of a file name
curnam:	.asciz /USERS /		;default starting name
	.=curnam
	.blkb maxdnm		;path to current directory
dname:	.blkb maxfnm		;name of current disk
incap:	0			;capability to input file
outcap:	0			;capability to output file
tmpcap:	0			;temporary cap
prfcap:	0			;capability to a file to print
writen:	0			;if non-zero something has been writen the file
;kludgy "flag" for open input/output for status line
inflag:	.ascii /In: /
inname:	.blkb maxfnm		;input file name
outflg:	.ascii /Out: /
outnam:	.blkb maxfnm		;output file name
tmpnam:	.blkb maxfnm		;temp name
	.even

filblk:	0			;file block for .fari call, flag word
	filhln:	0		;high word of length
	fillln:	0		;low word of length
	fildat:	0		;date
	filtim:	0		;time
	filnam:	.blkb maxfnm	;file name
	filbll=.-filblk		;length of block

strdir:	0			;where to start listing directory
dirend:	0			;last entry in directory
				;entry block for directory listing purposes
entry:	0			;header word
tvern:	0			;version number
entefh:	0			;high order eof word
enteof:	0			;low order eof word
date:	0
time:	0
enname:	.blkw 10.		;name and descriptor
entend:
mxenln=.-entry			;max entry length in bytes

sstats::			;the sits status area
svern:	0			;sits version
stime:	.blkw 2			;time since sys start in 60ths
scsr:	0			;consloe switchs
looksw:	0
rands:	.blkw 10		;potentially there are more

;date-time table
;bit format of date & time words is:
;     yr  mo  da        hr  min  sec/2
;	date: 7   4   5   time: 5   6     5

dttab:	-5,177760,0,'/
	0,177740,0,'/
	-9.,177600,0,' 
	-11.,177740,0,':
	-5,177700,0,':
	0,177740,1,40

dbufl=400			;input/output buffer lengths
dibufp:	0			;pointer into input buffer
dibufe:	0			;pointer to first invalid character in buffer
dibuf:	.blkb dbufl		;input buffer
dobufp:	0			;pointer into output buffer
dobuf:	.blkb dbufl		;output buffer


.endc ;nz sits

.if nz rt11
emttmp:	.blkw 2
stime:	.blkw 2
.endc

.sbttl french accent stuff
french:	frp			;if non-zero do french translations
prfrfm:	frp			;if non-zero we have a french printwheel

frtab:	.byte '?,243		;c cedila
	.byte '/,247		;e ague
	.byte '~,'?		;this is just a simple translate
	.byte '`,'/		;as is this
frtaba:	.byte '{,230
	.byte '},231
	.byte '|,232
frtabe:				;end of table marker
fratab=.-frtaba			;offset from accents
	frgrve			;grave
	frcirc			;circomflex
	frtrem			;trema

frgrve:	.byte 'A,201
	.byte 'E,204
	.byte 'O,212
	.byte 'U,215
	.byte 'a,241
	.byte 'e,244
	.byte 'o,252
	.byte 'u,255
	0

frcirc:	.byte 'A,202
	.byte 'E,205
	.byte 'I,210
	.byte 'O,213
	.byte 'U,216
	.byte 'a,242
	.byte 'e,245
	.byte 'i,250
	.byte 'o,253
	.byte 'u,256
	0

frtrem:	.byte 'E,206
	.byte 'I,211
	.byte 'O,214
	.byte 'U,217
	.byte 'e,246
	.byte 'i,251
	.byte 'o,254
	.byte 'u,257
	0

;for search, translate accent chars to equiv non-accent, since search can't input accents
acctrn:	.byte 0,'A,'A,'C,'E,'E,'E,'E,'I,'I,'O,'O,'O,'U,'U,'U
	.blkb 20
	.byte 0,'a,'a,'c,'e,'e,'e,'e,'i,'i,'o,'o,'o,'u,'u,'u
	.blkb 20

;for printing, this table is indexed by 2*accent character
;upper and lower case both print as lower case
;for french prestige qubic
fntfr:	0,'@,"^a,'\,"`e,"^e,"~e,'{,"^i,"~i,"`o,"^o,"~o,"`u,"^u,"~u
	.blkw 20

;for courier 10
fnteng:	0,"\a,"^a,",c,"/e,"^e,""e,"\e,"^i,""i,"\o,"^o,""o,"\u,"^u,""u
	.blkw 20

.if nz frp
frptmp:	0

frptab:	.byte '/,' ,'e,247,'c,243
	.byte '\,' ,'e,244,'a,241
	.byte '^,' ,'i,250
	0
.endc

.sbttl error messages and tables

.macro errdef name
name=104400+foo			;trap foo
foo=foo+1
er'name				;routine to call
.endm

foo=200
ertab:	errdef ding		;just ring the bell
	errdef noroom		;buffer full
	errdef baderr		;shouldn't happen!!
	errdef undef		;underfined key or function
	errdef serfai		;search failed
	errdef badarg		;bad argument
.if z rt11
	errdef prtntr		;printer not ready
	errdef prabor		;printer quit out
	errdef filerr		;file error
.endc

;table of filing errors

.macro dferr c,text
	c
	.asciz &text&
	.even
.endm

.if nz sits
filert:
eng <	dferr .efnf,<File not found>>
fr  <	dferr .efnf,<N'ai pas trouv/e ce fichier>>
eng <	dferr .ebfn,<Bad file name>>
fr  <	dferr .ebfn,<Mauvais nom de fichier>>
eng <	dferr .ecdd,<Can't delete a non-empty directory>>
fr  <	dferr .ecdd,<Fichiers encore pr/esents>>
eng <	dferr .edfl,<Disk is full>>
fr  <	dferr .edfl,<Disque rempli>>
eng <	dferr .edrf,<Directory full>>
fr  <	dferr .edrf,<Trop des fichiers>>
eng <	dferr .edske,<Disk error>>
fr  <	dferr .edske,<Erreur du disque>>
eng <	dferr .edvbe,<Bad disk error, check disk>>
fr  <	dferr .edvbe,<V/erifier le disque>>
eng <	dferr 0,<Strange file error>>
fr  <	dferr 0,<Erreur /etrange du disque>>
.endc ;nz sits

bufful:
eng <	.asciz &Memory full&>
fr  <	.asciz &Memoire rempli&>
bufnfl:
eng <	.asciz &Memory almost full&>
fr  <	.asciz &Memoire presque rempli&>
serfms:
eng <	.asciz &Search failed&>
fr  <	.asciz &Pas trouv/e&>
badams:
eng <	.asciz &Bad argument&>
fr  <	.asciz &Mauvais argument&>
undfms:
eng <	.asciz &Undefined function&>
fr  <	.asciz &Fonction inexistante&>
prtnms:
eng <	.asciz &Printer not ready&>
fr  <	.asciz &Imprimante n'est pas pret&>
prstms:
eng <	.asciz &Printer stopped&>
fr  <	.asciz &Imprimante arette&>
prpagm:
eng <	.asciz &Next page&>
fr  <	.asciz &Page suivante&>
prabms:
eng <	.asciz &Printing aborted&>
fr  <	.asciz &Imprimerie avort/ee&>
frblms:
eng <	.asciz & free blocks on disk #&>
fr  <	.asciz & blocs libres sur le disque #&>
	.even

.if nz prtnum
;printing variables

prpdle:	123456			;for debugging, to see if pdl overflew
	.blkw 200
prtpdl:	0			;pdl for printer
				;pointer stored here when edit job running

prclin:	0			;pointer to the current line buffer (printer line
				;which is being constructed)
prclpt:	0			;index into the prclin where the next character should go

prton:	0			;if non-zero there is a print job
				;this is only set for parallel printing/editing
				;not for printing the buffer
prtcap:	0			;cap to the printer
prttyp:	0			;zero=> simple lineprinter, 1=> multiwriter

prbufp:	prbuf			;pointer into printer buffer
prbufc:	0			;count of characters now in buffer
prblkc:	0			;number of outstanding print blocks
prtwai:	0			;seconds we have waited for printer ack
nprblk=4			;maximum number of outstanding print blocks
;prblsz=768./<nprblk+1>		;size of each block, plus safety
prblsz=300./<nprblk+1>		;don't use too much buffering, for quick stops
prbuf:	.blkb prblsz+10		;buffer here for one block+slop for commands
	.even

prfbfl=200.			;printer file buffer length
prfbuf:	.blkb prfbfl		;printer file buffer

pradjm:	0			;adjust mode (implies fill mode on, right and center off)
prfilm:	0			;fill mode
prcenm:	0			;center mode (implies fill off (though it could be on))
prrgtm:	0			;right adjust (implies fill off (though it could be on))
prlftm:	0			;left adjust (implies fill off)
prcnpm:	0			;continous paper
prmetm:	0			;metric measurements

;variables for printer pseudo-coroutines
prslnc:	0			;count of lines left to go in the buffer
prlpnt:	0			;pointer to the next line
prgetl:	0			;routine to call to get the next line

njobs:	1			;temporary pending timesharing



;Printer mode stuff. All measurements are kept here in 1/1000ths of
;a totally random measurement unit (inches). If the user enters data
;in reasonable units it gets translated into inches. It also gets
;translated into whatever units the printer in use happens to like.
;This stuff gets set to the defaults by PRESET
pihinc:	100.			;character width
piwidt:	0			;paper width
pitwid:	0			;text width
spitwi:	0			;saved value during a quote
pilent:	0			;paper height
pitlen:	0			;text length
plinpp:	0			;number of text lines on a page
plinis:	0			;interline spaceing
splini:	0			;saved value during a quote
pindnt:	0			;indent from left margin
;these are computed from the values above
pitopm:	0			;top margin
pibotm:	0			;bottom margin
pilmar:	0			;left margin
pirmar:	0			;right margin


;table for driving some converstion
prcnvt:	pihinc,120.,prhinc	;horizontal increment
	pihinc,120.,prvhin	;virtual horizontal increment
	plinis,48.,prvinc	;vertical increment
	pitopm,48.,prtopm	;top margin
	pibotm,48.,prbotm	;bottom margin
	pilent,48.,prbot	;bottom of page
	pilmar,120.,prlefm	;left margin
	pirmar,120.,prrmar	;right margin
	0			;end of table

prpitc:	0			;pitch, i.e. characters per inch
				;this also gives the default interline spaceing


;printer position stuff, reflecting current state of the printer
;all units are printer units, and thus device dependant
prhinc:	0			;horizontal incremtn the printer is currently using
				;(will be negative if in reverse print mode)
prvinc:	0			;vertical increment
prlefm:	0			;left margin, in printer units
prrmar:	0			;right margin in printer units
prtopm:	0			;top margin
prbotm:	0			;bottom margin
prbot:	0			;real bottom of the page

prhpos:	0			;current horizontal position
prvpos:	0			;current vertical position on page

prvhin:	0			;virtual horizontal incremtent for justifing
prvhps:	0			;virtual hpos, used while justifing
prvvps:	0			;virtual vertical position
.endc ;nz prtnum

.sbttl start the world
zstart:	clr ran			;clear storage too
.iif nz rt11!lsi, debug:
start:	mov #pdl,p
.iif nz lsi&sits,	reset
	jsr pc,hinit		;hardware init as needed
	tst ran			;don't clear storage if already started once
	bne 1$			;also avoids reseting to defaults
	jsr pc,sinit		;init the storage stuff
	jsr pc,tabint		;set tab stops
	jsr pc,reseta		;reset all defaults
	mov p,ran		;for the next time
1$:	jsr pc,ttyint		;init the tty
	jsr pc,tertpi		;init the terminal type
	jsr pc,@terint		;init the terminal
	jsr pc,update		;make the screen pretty
	jsr pc,ttyfls		;make sure the init stuff gets out
	jmp mloop		;go to the main loop

;init for the terminal type
tertpi:	
.if nz tvs
	save <,,#2>
	bis #.tttyp*400,(p)	;get flags from tty table
	$invok
	bit #200,(p)+		;bit 200 is the tv flag
	beq 1$			;is not a tv
	mov #tvtab,termty	;set the terminal type to tv
	save <,#1,#2>
	bis #.tvfnt*400,(p)
	.invok
	bne 1$
	bpt
1$:
.endc
	mov termty,a		;the terminal table
2$:	mov (a)+,b		;a word to set
	beq 3$			;at the end
	mov (a)+,(b)		;set the word
	br 2$
3$:	rts pc


;random cleanup, called before updating
;does things like shrink the buffer if there is a lot of unused space
;and set warning flags if storage is low
;may clobber any registers
cleanu:	mov buffer,a
	mov #bufinc,f		;allowable free space
	jsr pc,shrink		;make it smaller if too big
	mov #free,a
	clr b			;used to accumlate amount of free space
1$:	mov (a),a		;next free block
	beq 2$			;done
	add bllen(a),b		;add in this block
	cmp minmem,b		;have lots?
	bhi 1$			;nope, keep looking
	cmp #bufnfl,erstat	;is the message buffer near full?
	bne 4$			;nope
	cmp minme2,b		;have things gotten much better?
	bhi 1$			;well, maybe not
	clr erstat		;flush message
	br 3$
2$:	mov #bufnfl,erstat	;display this error message
3$:
4$:
;flush extra whitespace off the end of the curlin
cleanw:	mov curlin,d		;current line number
	cmp bufend,d		;at the end of the buffer?
	beq 4$			;yup
	asl d
	add buffer,d
	add #blhead,d		;get a pointer to the current line
	mov (d),f		;pointer to the line
	mov blused(f),e		;count of chars on the line
	add e,f			;pointer to the end of the line
	sub curcar,e		;count of possibly flushable characters
	beq 4$
	movb blhead-1(f),c	;end of line char
	jsr pc,whitep		;whitespace?
	bne 4$			;nope
	cmp #1,e		;only one character?
	beq 1$
	movb blhead-2(f),c	;end of line-1
	jsr pc,atribp		;atribute char?
	beq 4$			;yup, don't delete anything
1$:	jsr pc,invlin		;looks like we will clobber the line
	mov (d),f		;pointer to the line
	mov f,a			;copy it
	mov #-1,blplen(a)	;invalidate the print length
	add blused(a),f		;count of chars on the line
	add #blhead,f
2$:	movb -(f),c		;get the character
	jsr pc,whitep		;is it whitespace?
	bne 4$			;nope, keep it
	cmp #1,blused(a)	;only one character left?
	beq 3$			;delete it
	cmpb #atribc,-1(f)	;atribute char before it?
	blos 4$			;yup
3$:	dec blused(a)		;one less char in line
	sob e,2$

4$:	rts pc


.sbttl storage allocation
;storage allocation stuff

;free storage is composed of a list of linked blocks
;the first word of each block is the link to the next, and the second word
;is the length in bytes NOT counting the header, of the block
;the word free points to the head of this list

;definitions for all blocks
bllink=0			;link word, code assumes this is zero
bllen=2				;length word
blused=4			;amount of space really used in the block
blplen=6			;in lines, this is the print length, or zero if not known
blhead=10			;header length
bltiny=ilinsz+blhead		;never leave a free block around that is this small
;a used block also has it's length not counting the header in
;the second word. The first word is currently free, maybe it will be
;a back pointer for use by the storage relocator
;any other "header" words are counted in the count
;buffers and lines have the wthird word used for a "used count" of
;how much of the block is actually used. This count does not include
;the regular header or the buffer block header, so it is just
;a count of lines*2 in a buffer or characters in a line

;start up storage init
sinit:	mov #zero,a		;the aread to be zeroed on fresh start
	mov #<zeroe-zero>/2,b	;number of words to zero
1$:	clr (a)+		;zero one
	sob b,1$
	mov space,free		;make all space free
	mov free,a
	clr (a)+		;no link pointer
	mov memtop,(a)		;compute amount of free space
	sub space,(a)
	sub #100,(a)		;leave some for palying around
	mov (a),a		;the free memory
	ash #-3,a		;1/8th
	bic #160000,a		;bag biting ash!!!
	mov a,minme2		;for almost full tests
	asr a			;1/16
	mov a,minmem
	jsr pc,crbuff		;create a new buffer
	mov a,buffer		;and make it the default buffer
	clr bufend
	rts pc

;create a new buffer, return the address in a
;set z if you fail
crbuff:	mov #ibufsz,a
	jsr pc,getblk		;for now, just get the block
	beq 1$
	clz
1$:	rts pc

;grab a block of storage. Requested size is in a, returns with poitner to block in a
;if it fails to find a block, sets z, else clears
;it is assumed that everyone asks for at least 4 bytes, which are cleared.
;the length requested doen't include the blhead byte header (link and real length)
getblk:	save <a,b,c>
1$:	mov #free,b		;pointer to the free list pointer
2$:	mov b,c			;save the back pointer
	mov (b),b		;go to the next block
	bne 3$			;and see if it is big enough
	rest <c,b,a>
	sez
	rts pc			;lose, return with z set
				;later, this should consolidate free space

3$:	cmp bllen(b),a		;big enough?
	blo 2$			;no, lose

4$:	save d
	mov a,d			;amount of space wanted
	sub bllen(b),d		;minus amount gotten
	neg d			;amount left over
	cmp #bltiny,d		;only a tiny amount left over?
	bhis 5$			;yeah, take the whole thing
	add a,(c)		;move previous pointer up by amoutn being gobbled
	add #blhead,(c)		;plus amount for header
	mov (c),c
	sub d,bllen(b)		;new size of the block being gobbled
	sub #blhead,d		;lose blhead in the header
	mov d,bllen(c)		;set size of the free block

5$:	mov (b),(c)		;link the block out of the free list
	rest d
	mov b,a
	clr (b)			;clear out the link word
	clr blused(b)		;nothing used
	mov #-1,blplen(b)	;unknown print length
	rest <c,b,>		;don't restore a
	clz
	rts pc

;free the block pointed to by a
freeb:	save <a,b,c,d>
	cmp space,a		;make sure this is a good block address
	blos 1$		;yup
	bpt			;somebody lost
1$:	mov #free,b		;start of the free list
2$:	mov (b),c		;address of a free block
	beq 3$			;end of the free list
	mov c,b			;for the next time around
	mov c,d			;copy pointer
	add bllen(c),d		;end of the block
	add #blhead,d		;plus the header words
	cmp d,a			;is the new free block at the end of an old free block?
	bne 2$			;not this one anyway
	add bllen(a),bllen(c)	;add the new space into the old block
	add #blhead,bllen(c)	;and the header space (only need one header)
	mov c,a			;for 4$
	br 4$			;do something about running into the next block
3$:	mov free,(a)		;the block didn't get absorbed, put it on the free list
	mov a,free		;set the block at the head of the free list
;here, see if the block pointed to by a runs into any other block on the free list
4$:	mov #free,d		;the free list
	mov a,b			;pointer to block
	add bllen(a),b		;add in the size of the block
	add #blhead,b		;and the header
5$:	cmp b,(d)		;is the next block at the end of me?
	beq 9$			;yes, go splice it on
	mov (d),d		;next?
	bne 5$
6$:	mov #free,b		;now put the new thing in the right place
7$:	mov b,a			;next
	mov (a),b		;get the next thing
	beq 8$			;no next thing
	tst (b)			;is there somthing after that?
	beq 8$			;nope
	cmp b,(b)		;is the current thing before the next thing?
	blo 7$			;yup, nothing to do
	mov (b),c		;pointer to the next block
	mov c,(a)		;fix the previous pointer
	mov (c),(b)		;the former previous block becomes the next block
	mov b,(c)		;and vica-worser
	mov c,b
	br 7$			;bubble down the chain
8$:	rest <d,c,b,a>
	rts pc

9$:	mov (d),c		;pointer to the extra block
	mov (c),(d)		;link out the block
	add bllen(c),bllen(a)	;give the space to the rmaining block
	add #blhead,bllen(a)	;including the header
	br 6$

;expand the block pointed to by a by the amount in b
;set z if failure
;return a pointer to the new (maybe not the same) block in a
;as a special case, if the pointer passed is a zero a new block is simply created
expand:	save <b,c,d,e>
	cmp #blhead,b		;always make him take at least a header worth
	blos 1$		;branch if he is asking for more
	mov #blhead,b		;force that much
1$:	mov a,c			;pointer to the block
	cmp space,a		;check for bugs
	blos 2$			;don't try to expand block below real space
	bpt
2$:	add bllen(a),c		;pointer to the end of the block
	add #blhead,c		;plus the header
	br 7$			;punt, pending debugging of this feature
	mov #free,d		;free list pointer
3$:	cmp c,(d)		;does this free block begin at our end?
	beq 4$			;yes!!!
	mov (d),d		;point to the next one
	bne 3$
	br 7$			;punt, have to copy the block

4$:	mov (d),e		;pointer to the free block
	cmp b,bllen(e)		;is there enough space there?
	bhi 7$			;nope, punt
	mov bllen(e),c		;size of the free block
	sub b,c			;size of free block when done
	cmp #bltiny,c		;tiny?
	blo 6$			;no, make a new free block
	mov (e),(d)		;splice out this block
	add bllen(e),bllen(a)	;add in the space
	add #blhead,bllen(a)	;and the header
5$:	rest <e,d,c,b>
	clz
	rts pc

6$:	add b,bllen(a)		;give him the requested space
	add b,(d)		;move up the free list pointer
	mov e,c			;pointer the block we are taking from
	add b,c			;new free block
	mov (e),(c)		;chain for the free list
	mov bllen(e),bllen(c)	;free space
	sub b,bllen(c)		;minus amount taken
	br 5$			;return

;come here if we can't annex space from the next block => we have to copy
7$:	mov a,c			;pointer to the old block
	mov b,a			;space increment desired
	add bllen(c),a		;size of the old block
	jsr pc,getblk		;try to get a block of the new size
	beq 10$			;lose!!
	mov c,e			;save a pointer to the old
	mov bllen(c),d		;size of the old block
	asr d			;in words
	beq 9$			;previous thing was zero length
	mov a,b			;pointer to the new
	mov blused(c),blused(b)	;same amount of space used in both
	add #blhead,b		;get past the header in the new
	add #blhead,c		;get past the header in the old
8$:	mov (c)+,(b)+		;copy the words
	sob d,8$
9$:	save a
	mov e,a			;get the old pointer back
	jsr pc,freeb		;free the old block
	rest a			;get back the new block pointer
	br 5$			;and return sucessfully

10$:	rest <e,d,c,b>
	sez			;failing return
	rts pc

;if the block pointed to by a has more than f extra space, release the space
shrink:	save <a,b,c>
	mov bllen(a),b		;total buffer length
	mov blused(a),c
	inc c			;do a .even
	bic #1,c
	sub c,b			;giving the amount not used
	cmp f,b			;more than we incremtent by?
	bhi 1$			;nope
	mov c,bllen(a)		;it will be set to exactly the right size
	add a,c
	add #blhead,c		;pointer to the first unused word
	sub #blhead,b		;give room for the header
	mov b,bllen(c)		;set the length of the block to be freed
	mov c,a
	jsr pc,freeb		;free that space
1$:	rest <c,b,a>
	rts pc

;copy the block pointed to by a. Return a pointer to the new block in a
;return with z clear unless failure
copy:	save <c,b>
	mov a,b			;copy the pointer
	bne 1$			;check for zero pointer
	bpt			;somebody lost
1$:	mov bllen(b),a		;get the length
	mov a,c			;might as well copy it while we have it
	jsr pc,getblk		;get the new block
	beq 4$			;failed
	save a			;the new block pointer
	mov blused(b),blused(a)	;same amount of used space in both
	mov #-1,blplen(a)	;but the new one might have different print lenght
	add #blhead,a		;get to the good stuff
	add #blhead,b
	asr c			;count in words
	beq 3$			;branch if zero words
2$:	mov (b)+,(a)+
	sob c,2$
3$:	rest <a,b,c>
	clz
	rts pc

4$:	rest <b,c>
	sez
	rts pc

.sbttl screen updating routines
update:	jsr pc,tyip		;any pending input?
	beq 1$			;nope
	rts pc			;abort the redisplay
1$:	jsr pc,dstat		;update the status line if it needs it
updatf:	jsr f,acsav		;save all the register
	jsr pc,cleanu		;random cleanup
	tst ntopln		;did someone set a topline value?
	bne updats		;actually update the screen, we know what top line to use
	mov toplin,a		;starting with this top line
	mov a,ntopln		;assume this will be the new top line
	cmp a,curlin		;is the cursor on the top line?
	bne 1$			;nope, go find the cursor
	bhi updatp		;if the cursor is above the top line just forget it
	cmp curcar,screes	;is the cursor before the starting character?
				;note that both curcar and screes are character
				;positions not screen positions
	blo updatp		;yup, need a new window
	br updats		;ok, we will keep this window

;now loop through counting lines to see if the cursor will be on the screen
1$:	mov screls,b		;the first line starts here instead of zero
	clr f			;line number we are at
2$:	cmp a,curlin		;are we on the right line?
	beq 3$			;yup
	cmp a,bufend		;is the old top line below the buffer end?
	bhis updatp		;yes, punt for a new window
	mov #-1,d		;get length to end of line
	jsr pc,getlnl		;get the length in lines in c
	clr b			;for the next time around
	add c,f			;total length
	cmp f,numlin		;have we exceeded our space?
	bhis updatp		;yup, go choose a new window
	inc a
	br 2$			;loop to bottom of screen

3$:	mov curcar,d		;if we terminate at the cursor
	cmp a,bufend		;off the end of the buffer?
	bne 4$			;nope
	inc f			;add one for a blank line
	br 5$
4$:	jsr pc,getlnl		;will it fit?
	add c,f			;number of lines added
5$:	cmp f,numlin		;fit?
	bhi updatp		;nope, have to choose a new window
	br updats		;yes, the toplin we have is ok

;We have decided that the toplin we have won't work, so we compute a new ntopln
updatp:	mov curlin,a		;the line the cursor is on
	clr b			;start from position zero
	mov numlin,f		;the number of lines that will fit on the screen
	mov f,e			;the full screen
	asr f			;half the screen
	cmp a,bufend		;is the cursor at the end of the buffer?
	beq 5$			;yup, start by moving up a line
	mov curcar,d		;the cursor
	jsr pc,getdps		;get that as a display character position in the line in a
	jsr pc,getlnl		;does the current line take more space than we have?
	cmp c,f
	blos 2$			;no, it will all fit on the screen
1$:	add numcar,b		;one line's worth
	jsr pc,getlnl		;will it fit now?
	cmp c,f
	bhi 1$			;nope, keep trying
	br 4$			;go set ntopln and go to redisplay

2$:	mov #-1,d		;take full lines
	jsr pc,getlnl		;how much this line will take up
	sub c,e			;too much?
	blt 4$			;yup, don't display it
	sub c,f			;take this much
	ble 4$			;pretty much done
3$:	dec a			;go up one line
	bgt 2$			;try the next line up
	clr a			;start on line zero then

4$:	mov b,nscres		;this will be the start of the top line
	mov a,ntopln
	br updats		;actually update the screen

5$:	cmpb -(e),-(f)		;decrement
	br 3$

;Now we have the new values for toplin and screes (ntopln and nscres) and
;we want to fill in nscren, nscrls and nscrle with good stuff. Then we will
;next go on to display that stuff.
updats:	mov ntopln,f		;the new top line
	mov buffer,a
	asl f			;a word index
	add a,f
	add #blhead,f		;a pointer into the buffer
	save f			;put it where its (somewhat) handy
	add blused(a),a		;get an end pointer
	add #blhead,a
	mov a,ubufep		;and save it
	mov numlin,c		;a counter
	clr f			;the current line index
	mov nscres,b		;current starting point
	mov b,e
	add numcar,e		;current ending point
1$:	cmp (p),ubufep		;end of the buffer?
	bhis 4$			;yup
	mov b,nscrls(f)		;the start of this line
	mov e,d			;ending
	mov @(p),a		;get the current line
	mov a,nscren(f)		;this line will be displayed here
	save c			;getlen clobbers c
	jsr pc,getlen		;does this make it all on this line?
	rest c
	mov d,nscrle(f)		;in any case this is the end
	cmp e,d			;did it fill the line?
	beq 2$			;yup, use this line next time
	add #2,(p)		;next line
	clr b
	mov numcar,e		;a new line
	br 3$
2$:	add numcar,b		;next line
	add numcar,e
3$:	tst (f)+		;next screen line
	sob c,1$		;for as long as there are lines
	br 9$

4$:	mov #blank,nscren(f)	;blank out the end of the screen
	clr nscrls(f)
	clr nscrle(f)
	tst (f)+
	sob c,4$
9$:	tst (p)+		;flush temp
	br updatd		;now we know what to put up, put it up!


;Now we have the old screen and the new screen and have to make them
;identical.
updatd:	clr a			;this will be where we are in the old screen
	clr b			;and this will be in the new screen
	mov numlin,c		;this will be the fence to stop against
	asl c			;as words
1$:	jsr pc,upcmpl		;compare lines
	bne 3$
2$:	cmp (a)+,(b)+		;advance both pointers
	cmp a,c			;at the end?
	bne 1$			;nope
	mov ntopln,toplin
	br updatc		;done, go update the cursor

;we need to fix the line displayed at a on the real screen
3$:	tst idline		;do we have insert/delete?
	beq 12$			;nope, just do standard thing
;now see if we can do delete lines to move a correct line up
	save a			;save the current place
	mov maxid,d		;maximum number of inserts or deletes to do
	cmp #blank,nscren(b)	;is the new line just a blank?
	beq 7$			;yes, don't go to any trouble for it
4$:	tst (a)+		;next in the old screen
	cmp a,c			;at the end?
	beq 7$			;yup
	jsr pc,upcmpl		;are these lines the same?
	bne 6$			;nope
	mov (p),a		;restore a
5$:	jsr pc,updell		;delete a line
	jsr pc,upcmpl		;are we to the line that was the same?
	bne 5$			;nope
	rest a
	br 2$			;loop around, line is now correct
6$:	sob d,4$		;do for maxid

;Now we couldn't win with delete line so we will have to rewrite the
;current line. Check to see if the current old line will be useful within
;maxid lines of where it is.
7$:	mov (p),a		;saved above
	mov maxid,d		;maximum number of insert lines to allow
	save b			;pointer into new frob
	bit #177776,screen(a)	;is the old line unkown or blank?
	beq 10$			;don't worry about it then
8$:	tst (b)+		;next
	cmp b,c			;at end?
	beq 10$			;yup, have to just redisplay
	jsr pc,upcmpl		;are these lines the same?
	bne 11$			;nope
	mov (p),b		;recover new screen pointer
9$:	jsr pc,upinsl		;insert a blank line
	cmp (a)+,(b)+		;old line got moved by one
	jsr pc,upcmpl		;are we to the line that was the same?
	bne 9$			;nope
10$:	rest <b,a>
	br 12$			;loop around
11$:	sob d,8$
	rest <b,a>

12$:	jsr pc,redisl		;redisplay the line at (b), clobber (a)
	br 2$			;do next line

;Now put the cursor at the right place
updatc:	mov curcar,d		;the cursor character address
	mov curlin,a
	cmp a,bufend		;last line?
	beq 1$			;yup, just use curcar
	jsr pc,getdps		;get it as a display address
1$:	clr a			;screen pointer
	mov curlin,b
	sub toplin,b		;number of lines down the screen
	beq 4$			;on the first line
2$:	tst screls(a)		;is this a begining of a new line?
	bne 3$			;nope
	dec b			;a new line
	blt 4$			;found the right line
3$:	tst (a)+
	br 2$
4$:	cmp d,screle(a)		;before the end of this line?
	blos 5$			;yup, on this screen line
	tst (a)+
	br 4$
5$:	blo 6$			;branch if not eq
	cmp #blank,screen(a)	;special case
	beq 6$
	cmp screen(a),screen+2(a)	;does the line overflow?
	bne 6$			;nope
	tst (a)+		;yup, display on the next line
6$:	mov d,b
	sub screls(a),b		;right position on the line
	asr a
	jsr pc,babsps		;put the cursor there
	clr ntopln
	jsr pc,ttyfls		;make sure everything gets to the screen
	jsr f,acres		;and we are done!
	rts pc

;Given a line pointer in a make the thing in nscren replace the thing in screen.
redisl:	jsr f,acsav		;just in case
	mov screls(a),d		;starting here
	mov screen(a),e		;"print" this line
	mov #oline,f		;to here
	jsr pc,redprt		;print the line into the buffer
	save f
	mov nscrls(a),d		;starting here
	mov nscren(a),e		;"print" this line
	mov #nline,f		;to here
	jsr pc,redprt		;print the line into the buffer
	save f			;last address used
	jsr pc,upkill		;kill the previously displayed line
	mov nscren(a),screen(a)	;this will be displayed
	mov nscrls(a),screls(a)
	mov nscrle(a),screle(a)
	mov p,screeb(a)	;this line is in the buffer
	mov #oline,e
	mov #nline,f
1$:	cmp e,2(p)		;at the end of the old line?
	beq 2$			;yup
	cmp f,(p)		;how about the end of the new line?
	beq 3$
	cmp (e)+,(f)+		;do the lines match?
	beq 1$			;yup
	cmp -(e),-(f)		;back to the unmatched characters
2$:	cmp f,(p)		;at the end of the new line too?
	beq 5$			;yup, nothing to do then
3$:	asr a			;the line we are on
	mov f,b
	sub #nline,b
	asr b
	jsr pc,babsps
	cmp e,2(p)		;was it the old line that ended first?
	beq 4$			;yup, don't need to clear
	save a
	mov 4(p),a
	sub e,a			;number of characters to clear
	asr a
	jsr pc,@sclrel		;kill to the end of the line, with special padding
	rest a
4$:	cmp f,(p)		;at the end?
	beq 5$			;nope
	mov (f)+,c		;get a character
	jsr pc,dischr		;display it
	br 4$
5$:	clr c
	jsr pc,@setatr		;make sure the atributes are clear
	cmp (p)+,(p)+
	jsr f,acres
	rts pc


;This routine prints a line into a buffer
;The line pointer is in e, the character position to start at is in d
;f points to the buffer to put the line into
redprt:	save <a,b,c,d>
	mov numcar,a		;all lines are this long
	cmp #blank,e		;is there a line to print?
	beq 8$			;no, exit
	tst e			;is the line garbage?
	beq 9$			;yup, fill with garbage

1$:	save a
	mov e,a
	jsr pc,getchp		;convert from display position to character
	rest a
	mov e,b			;copy the line pointer
	add blused(b),b
	add #blhead,b		;pointer to the last real character
	add #blhead,e
	add d,e			;point to the first character to be displayed
2$:	clr (f)
3$:	cmp e,b			;at the end?
	beq 8$			;exit
	cmpb #11,(e)		;tab?
	bne 5$			;nope
4$:	mov #40,(f)+		;put in a space
	dec a			;put in a char
	beq 6$			;done the line
	inc (p)			;the character pos
	bit #7,(p)		;mult of 8?
	bne 4$
	br 2$

5$:	movb (e)+,(f)		;put the character in the line buffer
	inc (p)			;indicate one space taken
	cmpb #atribc,(f)	;attributes?
	blos 7$			;yup
	tst (f)+		;next place
	sob a,2$		;one more place taken
6$:	tst -(f)		;go back
	mov #rgtchr,(f)+	;clobber to continue character
	br 8$			;and return
7$:	bisb (f),1(f)		;set in the bits
	br 3$

8$:	rest <,c,b,a>
	rts pc

9$:	mov #-1,(f)+
	sob a,9$
	br 8$

;Display the character in c on the screen. Assume the cursor is positioned properly.
dischr:	swab c
	jsr pc,@setatr		;set atributes
	swab c
	jsr pc,@typec		;for now just call type routine
				;later, take care of attribute bits
	rts pc

;Utilities for screen updateing

;compare the line pointed to by a and b and set z if they are the same
upcmpl:	cmp screen(a),nscren(b)	;same line?
	bne 1$			;nope
	cmp screls(a),nscrls(b)	;same start?
	bne 1$			;nope
	cmp screle(a),nscrle(b)	;same end?
1$:	rts pc
	
;Insert a blank line at line a
;Assumes c is a pointer to the end of the screen
upinsl:	save b
	asr a
	clr b
	jsr pc,babsps		;put the cursor at the right place
	jsr pc,@tinlin
	asl a
	mov c,b			;copy the end pointer
	tst -(b)		;don't copy the end line
	save a
	mov b,a			;the line we are about to push off the screen
	jsr pc,upkill
	rest a
1$:	sub #2,b		;one up
	cmp a,b			;at the place to insert?
	bgt 2$			;yup
	mov screen(b),screen+2(b)
	mov screls(b),screls+2(b)
	mov screle(b),screle+2(b)
	mov screeb(b),screeb+2(b)
	br 1$

2$:	mov #blank,screen(a)	;blank the line
	clr screls(a)
	clr screle(a)
	clr screeb(a)
	rest b
	rts pc

;Delete the line at a, moving up all the other lines and putting a blank at the bottom.
;Assumes c is the end of screen pointer.
updell:	save <a,b>
	asr a
	clr b
	jsr pc,babsps		;put the cursor at the right place
	jsr pc,@tdelin		;actually delete the line
	asl a
	jsr pc,upkill		;the line that is about to be deleted from the screen
	rest b
1$:	tst (a)+
	cmp a,c			;at end?
	beq 2$			;yup
 	mov screen(a),screen-2(a)
	mov screls(a),screls-2(a)
	mov screle(a),screle-2(a)
	mov screeb(a),screeb-2(a)
	br 1$
2$:	mov #blank,screen(a)	;blank the line
	clr screls(a)
	clr screle(a)
	clr screeb(a)
	rest a
	rts pc

;The line at (a) has been clobbered on the screen. If it is not part of
;the buffer it should be killed.
upkill:	tst screeb(a)		;part of the buffer?
	bne 1$			;yes, never kill
	cmp screen(a),screen+2(a)	;same as the next line?
	beq 1$			;yup, don't kill till next line flushed
	bit #177776,screen(a)	;blank or don't know?
	beq 1$
	save a
	mov screen(a),a		;get the pointer
	jsr pc,freeb
	rest a
1$:	rts pc

;Clear the screen.
scrclr:	jsr pc,@clrscr		;clear the hardware
	clr statln		;status line gets clobbered
	save c
	mov #blank,c
scrcl1:	jsr pc,scrclx
	rest c
	rts pc

;Flush the screen to garbage
scrfls:	save c
	clr c			;zero => unknown stuff
	br scrcl1

;Clobber the screen to the thing in c
scrclx:	save <a,b>
	mov numlin,b
	clr a
1$:	jsr pc,upkill		;about to kill line, maybe do a freeb
	mov c,screen(a)		;blank or garbage the line
	clr screls(a)
	clr screle(a)
	tst (a)+
	sob b,1$
	rest <b,a>
	rts pc






;Get the length of the buffer line whose number is in a. Just calls getlen.
getlnl:	save a
	asl a
	add buffer,a
	mov blhead(a),a
	jsr pc,getlen
	rest a
	rts pc

;Get the length in lines of the line pointed to by a, starting at character
;position in b and ending at c. The length of the whole line in display characters
;is normally found in BLPLEN, but this is invalidated if the line is changed.
;The length is returned in c. Also, the last character position needed is returned in d.
getlen:	save <e,f>
1$:	mov blplen(a),f		;get the stored lenght
	bge 5$			;we have a valid stored length
	clr f			;length
	save a
	mov blused(a),e		;count of real characters
	beq 4$			;none, zero length
	add #blhead,a		;get to the data
2$:	movb (a)+,c		;get a character
	cmp #11,c		;tab?
	bne 9$			;nope
10$:	inc f
	bit #7,f		;mult of 8?
	bne 10$
	br 11$
9$:	jsr pc,charsz		;get it's size
	add c,f			;add to the line length
11$:	sob e,2$
	mov numcar,c		;number of characters on a line
	dec c			;leave room for the continue character
	cmp c,f			;is this line smaller than one line?
	bhis 4$			;yup, simple case
	div c,e			;get the number of lines it takes
	save f			;save the remainder
	bne 3$			;branch if there are any characters on the next line
	dec (p)			;don't need a continue line then
3$:	mul numcar,e		;now get the number of chars including the continue char
	add (p)+,f		;total
4$:	rest a
	mov f,blplen(a)		;the print length
	br 1$			;go try that again

5$:	mov #1,c		;most lines are one long
	cmp d,f			;is the ending place beyond the line?
	bhis 6$			;yes, ignore the ending
	mov d,f			;end at the right place
6$:	mov f,d			;tell the caller where we ended
	tst chop		;all are if chop is set
	bne 7$			;yup, done
	cmp numcar,f		;less than one line?
	bhis 7$			;yup
	sub b,f			;starting place
	clr e			;for the divide
	dec f			;fencepost
	div numcar,e
	mov e,c			;number of lines
	inc c
7$:	rest <f,e>
	rts pc

;Return in c the number of print positions taken by the character in c.
charsz:	cmpb #atribc,c		;is it an atribute character?
	blos 1$			;yup, takes zero space
	mov #1,c		;everything else takes one
	rts pc

1$:	clr c
	rts pc

;Get display position. Given a line number in a and a character number in d,
;return the screen character position of that in d.

getdps:	save <a,b,c,f>
	clr -(p)		;counter
	tst d			;zero?
	beq 8$			;just return zero
	asl a
	add buffer,a
	mov blhead(a),a
	clr b
	cmp d,blused(a)		;using the whole line?
	bne 2$			;nope
1$:	mov blplen(a),(p)	;using the whole line, just give the print length
	bge 8$			;had a valid length
	save d
	jsr pc,getlen		;to set blplen
	rest d
	br 1$
2$:	add #blhead,a		;point to the data
	mov numcar,f
	dec f
3$:	movb (a)+,c		;get a character
	cmp #11,c		;tab?
	bne 6$			;nope
4$:	inc (p)
	inc b
	cmp f,b			;overflew?
	bhi 5$
	sub f,b
	inc (p)
5$:	bit #7,(p)		;multiple of 8?
	beq 7$
	br 4$
6$:	jsr pc,charsz		;get it's size
	add c,(p)		;count
	add c,b			;count for this line
	cmp f,b			;overflew a line?
	bhi 7$			;nope
	sub f,b
	inc (p)
7$:	sob d,3$
8$:	rest <d,f,c,b,a>
	rts pc

;Get character position. Given a screen character position in d and a line
;pointer in a, return the character number of the first character at that
;position.
;if we run off the end of the line, set z, else clear
getchp:	save <a,c,e,d>
	mov blused(a),e		;length of the line
	add a,e
	add #blhead,e
	cmp numcar,d		;more than one line?
	bhi 1$			;no, simple
	clr c
	div numcar,c		;get the number of lines
	mov (p),d		;get back the desired number
	sub c,d			;flush the continuation characters
1$:	add #blhead,a
2$:	cmp a,e			;at end of line?
	beq 4$			;yup
	tst d			;zero?
	ble 3$			;just return count then
	movb (a)+,c		;get a character
.error **** work here!!
	jsr pc,charsz		;how big is it?
	sub c,d
	br 2$
3$:	mov a,d
	sub #blhead,d
	rest <,e,c,a>
	sub a,d			;get the count
	clz
	rts pc

4$:	tst d			;where we all set anyway?
	ble 3$			;yup
	mov a,d
	sub #blhead,d
	rest <,e,c,a>
	sub a,d			;get the count
	sez
	rts pc

;display the status line if it needs it

dstat:	jsr f,acsav
	clr c
	jsr pc,@setatr		;make sure the atributes are clear
	mov #statln,f		;f points to the image of the old status line
	clr e			;clear the changed flag
	clr dstcar		;start at the beggining of the line
	mov #statar,a		;the status array
1$:	mov (a)+,b		;get an item
	beq 3$			;null
	jsr pc,stype		;type it out
2$:	mov #40,c
	jsr pc,stypec		;separate with spaces
3$:	cmp #erstat,a		;about to do the error message?
	bne 4$			;nope
	mov (a)+,b		;get an the error message
	beq 4$			;null
	movb #377,(f)+		;kludge to ensure that the line gets cleared each time
	jsr pc,@blink		;turn on blink
	jsr pc,stype		;type it out
	jsr pc,@nblink		;turn blink off
	br 2$			;go type the space, etc
4$:	cmp #strech+2,a		;just did echo string?
	bne 5$			;nope
	save dstcar		;to position cursor
5$:	cmp #statae,a		;done?
	bne 1$			;next one
	mov #40,c
	mov numcar,a		;size of the line
	sub dstcar,a		;space left
	sub #2,a		;one space for !, one for fencepost
	ble 7$			;no space
6$:	jsr pc,stypec		;type a space
	sob a,6$		;to get a full underline
	rest b
	dec b
	clr a
	tst strech		;are we echoing input?
	beq 7$			;nope
	jsr pc,@abspos		;put the cursor at the end of the good stuff
7$:	jsr pc,@nundrl		;turn off underline
	jsr pc,ttyfls
	clr c
	jsr pc,@setatr		;make sure the atributes are clear
	jsr f,acres
dstatr:	rts pc

;type an asciz string with htyo
;pointer to string in b
htype:	mov #htyo,pchr
	br stype1

;special typeout routine for dstat
stype:	mov #stypec,pchr
stype1:	movb (b)+,c		;get a character
	beq 1$			;end of the item
.if nz frp
	jsr pc,frppre		;is it an accent prefix?
	bne 2$			;nope
	movb (b)+,c		;get the next character
	jsr pc,frptrn		;translate
2$:
.endc
	jsr pc,@pchr
	br stype1
1$:	rts pc

.if nz frp
frppre:	cmpb #'\,c
	beq 3$
	cmpb #'^,c
	beq 3$
	cmpb #'A,c		;is it puncuation?
	blos 9$			;no, can't be in table
3$:	save a
	mov #frptab,a
1$:	cmpb c,(a)+
	beq 2$			;found one
	tstb (a)+		;next
	bne 1$
	rest a
9$:	clz
	rts pc
2$:	mov a,frptmp
	rest a
	sez
	rts pc

frptrn:	save a
	mov frptmp,a
1$:	tstb (a)+
	beq 9$
	cmpb (a)+,c
	bne 1$
	movb (a)+,c
2$:	rest a
	rts pc
9$:	movb #'?,c
	br 2$
.endc

stypec:	cmp dstcar,numcar	;at the end of the line?
	beq 1$			;yup, don't type anything
	tst e			;still not different from old?
	bne 3$			;different, type it
	inc dstcar		;everything better take one space
	cmpb c,(f)+		;same as what was there?
	beq 1$			;same, do nothing
	mov pc,e		;different, set flag
	save <a,b>
	dec f			;move pointer back
	dec dstcar		;fix the postion word
	mov dstcar,b
	clr a			;line number
	jsr pc,@abspos		;put cursor there
	jsr pc,@clreol		;clear rest of line
	jsr pc,@underl		;and set underlining
	rest <b,a>
3$:	movb c,(f)+		;save for next update
	jsr pc,@typec		;type the character
	add #2,dstcar		;if we go one more
	cmp dstcar,numcar	;will we hit the end?
	bne 2$			;nope
	mov #rgtchr,c		;say so
	jsr pc,@typec
2$:	dec dstcar
1$:	rts pc

acsav:	save <e,d,c,b,a>
	jmp (f)

acres:	tst (p)+
	rest <a,b,c,d,e>
	rts f



;babsps is just like @abspos except it can fake out the screen location
;to leave room for the status line on the top
babsps:	save a
	mov a,linpos		;for screen routines
	inc a			;leave the top line free
	jsr pc,@abspos		;do the actual positioning
	rest a
	rts pc

.sbttl general tty handling routines
;general tty handling routines and macros

;these routines are the lowest level => somebody up there is keeping trakc of things
;like the cursor and outputing control characters
;output the character given by the argument
.macro tyo x
	save x
	jsr pc,tyostk
.endm

;output the character given by the argument plus 40
.macro tyo40 x
	save x
	jsr pc,tyos40
.endm

;output the character given by the argument after an esc
.macro tyoesc x
	save x
	jsr pc,tyoses
.endm

;pad for the number of milliseconds given as argument
.macro pad mills
	save mills
	jsr pc,padstk
.endm

;output the character under the return address
tyostk:	mov (p),ttemp		;save return address
	mov c,(p)		;save c on the stack
	mov 2(p),c		;get the character
	mov ttemp,2(p)		;put the return address back
	jsr pc,.tyo		;actually type the character
	rest c
	rts pc

;like tyostk, but add 40 to the character first
tyos40:	add #40,2(p)
	br tyostk

;like tyostk, but output an esc first
tyoses:	tyo #33
	br tyostk

;pad for the number of milliseconds given on the stack
padstk:	mov (p),ttemp		;save return address
	mov b,(p)		;save b on the stack
	mov 2(p),b		;get the time
	mov ttemp,2(p)		;put the return address back
	save a
	clr a
	div linspd,a		;divide by line speed in milliseconds/character
	beq 2$			;no padding to do
1$:	tyo #0			;output a null
	sob a,1$
2$:	rest <a,b>
	rts pc

.sbttl concept 100 terminal dependant stuff
;here are the concept 100 terminal dependant routines

;set up all the magic modes and such
c1teri:	tyoesc #'U		;set programmer mode or abs move won't work!
	tyoesc #'f		;set text mode (for ins/del line to work!)
	tyoesc #'7		;set character mode (as opposed to block)
	tyoesc #'5		;set upper-lower case mode
	tyoesc #'8		;set full duplex
	tyoesc #'l		;reset auto linefeed (normal cr)
	tyoesc #'N		;send set attribute word command
	tyo #110		;attribute word with all zeros, except
				;protect = 1 (no protection)
	clr catrib		;clear the current atributes
	clr c1fnt		;nope, set it
	tyoesc #'j		;select character set
	tyo40 c1fnt		;set to the right thing
	tyoesc #'$		;reset all function keys
	tyoesc #'o		;change message character
	tyo #46			;eom
	tyo #0			;gets changed to null
	tyoesc #'X		;set function pad to xmit
	mov #24,a		;this will set shifted keys 1-16 and unshifted 1-5
				;all we really need is (un)shifted 1-5
1$:	tyoesc #'4		;set function key
	tyo #40			;zero message length
	tyo40 a			;this key
	tyo #40			;send the default sequence
	dec a
	bge 1$
	tyoesc #'W		;set the cursor to the blinking block
	jmp scrclr		;clear the screen image

c1clrs:	tyo #14			;clear the screen
	pad #50.		;cretinous padding
	mov #-1,linpos		;pseudo cursor is off the top
	clr rlinps		;cursur is set to zero
	clr carpos
	rts pc

;clear to end of screen
c1eosc:	tyoesc #3		;send clear to end of screen character
	save b			;get a register
	mov #24.,b		;number of lines on the screen
	sub rlinps,b		;number of lines we will clear
;	mul #16.,b		;ungodly long padding
	ash #4,b		;quicker than the mul
	pad b
	rest b
	rts pc

;position cursor at line (a), character (b)
c1absp:	cmp a,rlinps		;already on the line?
	bne 1$			;nope, do the position
	cmp b,carpos		;already on that character?
	beq 2$			;yes, do nothing then
1$:	tyoesc #'a		;command to abs position
	tyo40 a			;line number plus 40
	mov a,rlinps		;keep this updated
	dec a			;minus one
	mov a,linpos		;for linpos
	inc a
	tyo40 b			;likewise character
	mov b,carpos		;this too
2$:	rts pc

;insert a line at the current cursor position
c1tinl:	tyoesc #22		;send the insert line command
c1idlp:	save b			;get a register
	mov #24.,b		;number of lines on the screen
	sub rlinps,b		;number of lines we will clear
;	mul #3.,b		;ungodly long padding
	save b			;avoid ungodly long multiply
	asl b
	add (p)+,b		;multiply by 3
	pad b
	rest b
	rts pc

;delete the line at the current cursor postion
c1tdel:	tyoesc #2		;send the delete line command
	br c1idlp		;go pad it

;clear from the cursor to the end of the line
c1clre:	tyoesc #25		;send the command
c1clr1:	pad #16.		;infinite padding
	rts pc

;kludegy special clear eol that gets number of chars being cleared in a
;and therefore can pad cleverly
c1sclr:	tyoesc #25		;clear the line
	ash #2,a		;divide the number of characters by 4
	add #2,a
	cmp #16.,a		;over the max?
	ble c1clr1
	pad a
	rts pc

;turn on underlineing
c1unde:	bit #atrund,catrib	;already underlining?
	bne 1$			;yup
	bis #atrund,catrib
	tyoesc #'G
1$:	rts pc

;turn off underline
c1nund:	bit #atrund,catrib	;already not underlining?
	beq 1$			;yup
	bic #atrund,catrib
	tyoesc #'g
1$:	rts pc

;turn on blink
c1blin:	tyoesc #'C
	rts pc

;turn off blink
c1nbli:	tyoesc #'c
	rts pc

;reverse video
c1revv:	bit #atrbld,catrib	;bold already set?
	bne 1$
	tyoesc #'D
	bis #atrbld,catrib
1$:	rts pc

;regualr video
c1nrev:	bit #atrbld,catrib	;bold already clear
	beq 1$
	tyoesc #'d
	bic #atrbld,catrib
1$:	rts pc

;set attribute word to the value in c
c1seta:	save c
	bic #177760,c		;4 bits of attributes
	cmp c,catrib		;are these the current atributes?
	beq 1$
	mov c,catrib		;they are now
	movb c1atrs(c),c	;translate
	tyoesc #'N		;set attribute word
	tyo c
1$:	rest c
	rts pc

;type a character in c, keeping track of the effect on the cursor
;and translating accent characters appropriately
;the only characters that should come here are cr,lf, and simple
;printing characters (including accents). Overflowing of lines is
;not handled
c1type:	cmp #15,c		;is it a carrige return?
	beq 4$			;yup
	cmp #12,c		;linefeed?
	beq 5$
	cmp #7,c		;bell?
	beq 2$			;just type it
	inc carpos		;move one character pos
	cmp numcar,carpos	;got to be off the screen?
	bhi 2$			;nope
	clr carpos		;goes to zero
	cmp rnmlin,rlinps	;on the last line?
	beq 1$			;yes, don't inc
	inc linpos		;down one line
	inc rlinps
	br 2$

1$:	tyoesc #'S		;page mode so we don't get screwed on last line
	jsr pc,2$		;call the rest as a subroutine
	tyoesc #'s		;go out of page mode
	rts pc

2$:	bit #200,c		;special graphic (accent character)?
	bne 6$			;yup
	jsr pc,c1fnt0		;make sure we are in font zero
3$:	jsr pc,.tyo		;nothing special, just output it
	rts pc

4$:	clr carpos		;return to zero
	br 3$			;output the cr

5$:	inc linpos		;down one line
	inc rlinps
	jsr pc,.tyo		;output the lf
	rts pc

6$:	save c
	cmpb #300,c		;in the accent range?
	blos 9$		;nope, some special
	bic #177600,c		;flush special bit
7$:	jsr pc,c1fnt1		;make sure we are in font 1
8$:	tyo40 c			;and type it normally
	inc carpos
	rest c
	rts pc

9$:	bne 10$			;if z is set, fixed space
	tst fixspp		;print fixed spaces?
	bne 10$			;yup, print it special
	clr c			;so we output a space
	jsr pc,c1fnt0		;in font zero
	br 8$
10$:	cmpb #310,c		;better be less than this
	bhi 11$
	bpt			;who trie dto type that???
11$:	bic #177770,c		;one of 8 specials
	movb c1spcc(c),c	;translate
	br 7$			;go type it

;make sure the terminal is set to font 0
c1fnt0:	tst c1fnt		;is it zero?
	beq c1fntx		;yup
	clr c1fnt		;nope, set it
c1fnts:	tyoesc #'j		;select character set
	tyo40 c1fnt		;set to the right thing
c1fntx:	rts pc

;make sure the terminal is set to font 1
c1fnt1:	cmp #1,c1fnt		;is it one?
	beq c1fntx		;yup
	mov #1,c1fnt		;nope, set it
	br c1fnts

.sbttl tt2500 terminal dependant stuff

.if nz gt2500

;clearscreen
25clrs:	tyo #35			;homeup
25eosc:	tyo #37			;clear to end of screen
	rts pc

;terminal init
25teri:	jmp scrclr

;clear to end of line
25sclr:
25clre:	tyo #36
	rts pc

;type the char in c, keeping track of the cursor
25type:	cmp #15,c		;cr?
	beq 1$			;yup
	cmp #12,c		;lf?
	beq 2$			;that's special too
	cmp #7,c		;bell?
	beq 5$			;then no new cursor position
	inc curpos		;normal char, next position
5$:	jsr pc,.tyo		;print the char
1$:	clr carpos		;cr
	br 5$
2$:	inc linpos		;lf
	inc rlinps
	br 5$

;set the cursor to the address in a,b
25absp:	cmp a,rlinps		;already on that line?
	bne 1$			;nope
	cmp b,carpos		;already on that char?
	beq 2$			;yup, do nothing

1$:	mov a,rlinps		;set the line position
	mov a,linpos		;and linpos
	dec linpos		;(minus 1)
	mov b,carpos		;and the car pos

	tyo #35			;homeup (to 0,0)
	tst a			;right line?
	bne 4$			;not yet
3$:	tyo #12			;down 1 line
	sob a,3$		;til we get there
4$:	tst b			;right char pos?
	bne 6$			;not yet
5$:	tyo #30			;fd 1 char
	sob b,5$		;til we get there

	mov rlinps,a		;restore a,b
	mov carpos,b
2$:	rts pc

;insert/delete lines shouldn't be called
25tinl:
25tdel:	halt

;just ignore these
25unde:	25nund:	25blin:	25nbli:	25revv:	25nrev:	25seta:	rts pc

.endc	;nz gt2500

.if nz tvs
.sbttl TV terminal dependant stuff

;initialize the tv
tvteri:	jmp scrclr		;just clear the screen

;clear the screen
tvclrs:	tyo #14			;just output a formfeed
	rts pc

;clear from cursor to end of screen
tveosc:	save <a,b>
	mov rlinps,a		;get the line number the cursor is on
	save <a,carpos>
1$:	jsr pc,tvclre		;clear to end of current line
	inc a			;should we go to next line?
	cmp a,numlin		;is it beyond the last?
	bhis 2$			;yup, don't go
	tyo #15			;go to beg of line
	tyo #12			;next line
	br 1$
2$:	mov #-1,rlinps		;make sure the line pos happens
	rest <b,a>		;old character,line
	jsr pc,tvabsp		;put cursor there
	rest <b,a>
	rts pc

;set the cursor to the address in a,b
tvabsp:	cmp a,rlinps		;already on that line?
	bne 1$			;nope
	cmp b,carpos		;already on that char?
	beq 2$			;yup, do nothing
1$:	jsr pc,ttyfls		;since the cursor pos isn't in the character stream!
	save <b,a,#<.tvset+.ttwrt>*400+2>
	$invok			;set the tty
	mov a,rlinps		;set the line pos
	dec a			;minus one
	mov a,linpos		;for linpos
	inc a
	mov b,carpos		;and the car pos
2$:	rts pc

;insert and delete line routines shouldn't get called
tvtinl:	tvtdel:	halt

;clear to end of current line
tvsclr:
tvclre:	tyo #36
	rts pc

;silly stuff that the tv can't do
tvunde:	tvnund:	tvblin:	tvnbli:	tvrevv:	tvnrev:	tvseta:	rts pc	;just ignore

;type a character in c on the tv, keeping track of the cursor
tvtype:	cmp #15,c		;cr?
	beq 1$			;yup
	cmp #12,c		;lf?
	beq 2$			;that's special too
	cmp #7,c		;bell?
	beq 3$			;do something special
	inc carpos		;normal character
5$:	jsr pc,.tyo		;just output it
	rts pc

1$:	clr carpos		;return
	br 5$

2$:	inc linpos		;down one line
	inc rlinps
	br 5$			;output it

3$:	tyo #22			;flash screen
	jsr pc,ttyfls		;flash!
	save <#0,#15.>		;1/4 second
	$sleep
	tyo #22			;flashback
	jsr pc,ttyfls
	rts pc
.endc	;tvs

schtyi:				;temporary pending timesharing
tyi:	mov rescan,a		;character to be rescaned?
	bne 1$			;yup
	jsr pc,rtyi		;do a real tyi
	bic #177600,a		;flush to 7 bits
1$:	clr rescan
	rts pc

.if nz sits
.sbttl SITS i/o routines
;here are the sits i/o routines
;init the TTY status
ttyint:	save <,#.timgi!.timgo,#.ttmov*400+2>	;set status to image in, image out, no echo
	$invok
	rts	pc

rtyi:	save #2			;the capability to the tty for input
	$byti			;get a character
	rest a			;pop it off the stack
	rts pc

;return with z set if no characaters are in the tty input buffer
tyip:	tst rescan		;is there a character to be rescaned?
	bne 1$			;yup
	cmp -(p),-(p)
	save #2
	movb #.ttpek,1(p)	;
	$invok			;find out if there is a character
	tst (p)+		;negative if none
	bge 1$			;yes return true
	sez
	rts pc
1$:	clz
	rts pc

;put a character into the output buffer, flushing it if full
.tyo:	movb c,@ttybfp		;put char into the tty buffer
	inc ttybfp		;next spot
	inc ttybfc		;one more character
	cmp #ttybfl,ttybfc	;full?
	bgt 1$			;not full yet
	jsr pc,ttyfls		;full, flush it out
1$:	rts pc

;flush out the tty buffer
ttyfls:	save <#ttybuf,ttybfc>
	neg (p)			;turn into negative count
	beq ttyfl2
	save #2
	$blko
ttyfl1:	mov #ttybuf,ttybfp	;restore pointer
	clr ttybfc		;and space used
	rts pc
ttyfl2:	cmp (p)+,(p)+		;flush, nothing to output
	br ttyfl1

;"hardware" init
.if nz lsi
hinit:	mov #lsitrp,lsitrv	;make sure traps trap to the right place
	mov #100,lsrcs0		;turn on tty interupts
.iif nz smsdsk,	mov #smscle,smscsr	;and clock interrupts
	save 4			;save whatever was there
	mov #2$,4		;place to trap to
	mov space,a		;end of the world
1$:	tst (a)+		;look for the end of memory
	br 1$

2$:	cmp (p)+,(p)+		;flush trap info
	rest 4			;restore old break
	sub #4,a		;correct for overenthusiasim
	mov a,memtop		;last existing location
	rts pc
.iff
hinit:	save <,#.timgo+.timgi,#2>
	bis #.ttmov*400,(p)
	$invok
	rts pc
.endc

;special sits starting place for debugging
;not for lsi
.if z lsi

debug:	mov #pdl,p
	save <#-1,#16,#.ttcap*400>	;create tty number 14.
	.invok
	beq 1$			;failed, he must be on the tty
	save <,,#2+.delcp>
	$invok			;delete in cap
	save <,,#3+.delcp>
	$invok			;delete out cap
	rest a			;get the new cap
	save <#2,,#.cpycp>	;copy it
	bis a,(p)
	$invok
	save <,,#.delcp>
	bis a,(p)		;delete the extra cap
	$invok
	save <#3,,#.cpycp+2>	;copy the tty cap
	$invok
	mov linspd,a		;what is the speed (only 4800 or 9600)
	asl a
	save <,speeds(a),#2+<.ttspd*400>>	;and set the speed to 4800
	$invok
1$:	jmp start

speeds:	0
	33503			;9600 baud
	31403			;4800 baud

.endc	;lsi
.endc	;sits

.if nz rt11
hinit:	bis #jswspm!jswlc!jswntw,@#jsw	;set special mode, lower case, no wait state
	bic #jswene,@#jsw	;turn off escape processing
	.settop #-2		;get all memory
	mov r0,memtop
	rts pc

.tyo:	save a
	mov c,a
	.ttyout
	rest a
	rts pc

ttyfls:	rts pc			;for now all tty output is immediate

ttyint:	rts pc			;hinit does tty init too

rtyi:	mov tyisav,a		;is there a saved character?
	bne 2$			;yup, use it
	.ttyin			;get a character
2$:	cmp #15,a		;is it a cr?
	bne 1$			;nope
	.ttyin			;flush the !%#$'$!! LF
	mov #15,a		;restore the CR
1$:	clr tyisav
	rts pc

tyip:	tst tyisav		;already got one?
	bne 2$			;yup
	save a			;otherwise known as r0
	.ttinr			;chara available?
	bcc 1$			;yup
	rest a
	sez
	rts pc
1$:	mov a,tyisav		;save the gd thing
	rest a
2$:	clz
	rts pc

.endc ;nz rt11


.sbttl main loop and character dispatch
mloop:	clr ctmtbt		;clear the control and meta bits
	mov #1,repcnt		;set the repeat count
	mov #char,noun		;we are hacking characters
	mov #chrqui,quitrt	;normal quit routinte
1$:	jsr pc,cdisp		;read a character and dispatch on it
	tst lastch		;did the last thing set an argument or prefix?
	beq 2$			;yup
	jsr pc,repkey		;if the repeat count is set...
2$:	jsr pc,update		;update the screen if no characters waiting
	jsr pc,ttyfls		;make sure all the characters are out there
	tst lastch		;should we clear stuff? (special use of lastch, see chrmta)
	beq 1$			;nope
	br mloop



;dispatch on a input character
;this is called from mloop
cdisp:	jsr pc,getkey		;get a key code, complete with control & meta bits
				;and dispatch address in f
	mov a,lastch		;for them what cares (e.g. insert character)
	jsr pc,getnam		;get the dispatch address
	jsr pc,keycal		;call a key routine
	rts pc

;for the things that don't handle repcnt themselves
repkey:	dec repcnt		;any more to do?
	ble 1$			;nope
	mov lastch,a		;get the character
	jsr pc,getnam		;get the routine name
	jsr pc,keycal		;call it
	br repkey		;until the count goes to zero
1$:	rts pc

;Get A Key Code. This reads a key and if it is not a contol or meta
;setter sets the control and meta bits into it and returns with the
;character in a
getkey:	save f
	clr ctmtbt		;clear old control and meta
1$:	jsr pc,schtyi		;read a character, maybe running print job if none available
	bis ctmtbt,a		;set any control and meta bits
	jsr pc,getnam		;get it's "name", the dispatch address
	cmp #chrctl,f		;does it set control?
	beq 2$			;yup, set it
	cmp #chrmta,f		;does it set meta?
	beq 2$			;yup
	rest f
	rts pc			;return with  character in a

2$:	jsr pc,skeycl		;call the key
	br 1$			;and get the next one

;get a key "name" of the character in a. Returns the dispatch address in f
getnam:	mov a,f			;copy key
	asl f
	add ctab,f
	mov (f),f		;get the dipatch address
	rts pc

;call a key handling routine, setting up the standard registers
;can clobber any and all registers
;call with the routine address in f
keycal:	mov buffer,a		;pointer to the buffer
	mov curlin,b		;line the cursor is on
	mov curcar,c		;character the cursor is on
	mov b,d			;copy the line number
	asl d			;make it a word index
	add a,d			;into the buffer
	add #blhead,d		;pointing to the line
	mov (d),e		;pointr to the line we are on
	jsr pc,(f)		;dispatch to a routine
	rts pc

;register preserving version of above
;call with address in f, f might get clobbered but a, b, c, d, and e are saved
skeycl:	save <a,b,c,d,e>
	jsr pc,keycal
	rest <e,d,c,b,a>
	rts pc

;errors trap to here, whcih is pretty simple at the moment
trpbrk:	rest <b,>		;get the pc
	mov -(b),b		;get the trap inst
	bic #177600,b		;get the error code
	mov #pdl,p		;reset the pdl
	jsr pc,bell		;ring the bell
	clr prompt		;flush any prompting
	clr strech		;and don't echo the string anymore either
	asl b
	jmp @ertab(b)		;call the error routine

erding:
erbade:	jsr pc,dstat
ercome:	jsr pc,updatf
	jmp mloop		;and go back to main loop

;no room in buffer
ernoro:	mov #bufful,erstat	;set an error into the status line
	jsr pc,erdisp		;display the error
	br ercome		;return to main loop

.if z rt11
;fileing error
erfile:	jsr pc,glerr		;get last error code
	mov #filert,b		;file error table
1$:	cmp a,(b)+		;this code?
	beq berdis		;yup
	tst -2(b)		;end of table?
	beq berdis		;yup
3$:	tstb (b)+		;go through the string
	bne 3$
	inc b
	bic #1,b		;do a .even
	br 1$
.endc

berdis:	mov b,erstat		;this will be the error message
	jsr pc,erdisp		;display it
	br ercome		;ding and return to top level

erserf:	mov #serfms,b		;message
	br berdis

erbada:	mov #badams,b
	br berdis

erunde:	mov #undfms,b
	br berdis

.if nz prtnum
erprtn:	mov #prtnms,b
	br berdis

erprab:	jsr pc,clsprt
	jsr pc,resprm		;restore printer modes
	mov #prabms,b
	br berdis
.endc

erdisp:	jsr pc,dstat		;display the change
	clr erstat		;flush error message
1$:	jsr pc,tyip		;typeahead?
	beq 2$			;nope
	jsr pc,tyi		;flush it
	br 1$
2$:	jsr f,acsav		;save the registers
	jmp updatc		;and go put the cursor in the right place

.sbttl character dispatch table

.macro dctab name
name'ctab:
crctab=.
	.rept 1000
	chrund
	.endr
crctbe=.
.endm

.macro dk key,routine
.=crctab+<key*2>
.if ndf routine
.error ;routine not defined
routine=chrund
.endc
	routine
.endm

.macro dkc key,routine
.=crctab+<key*2>+400
.if ndf routine
.error ;routine not defined
routine=chrund
.endc
	routine
.endm

.macro dkm key,routine
.=crctab+<key*2>+1000
.if ndf routine
.error ;routine not defined
routine=chrund
.endc
	routine
.endm

.macro dkcm key,routine
.=crctab+<key*2>+1400
.if ndf routine
.error ;routine not defined
routine=chrund
.endc
	routine
.endm

	dctab c1		;dispatch table for the concept 100
.if df pass2			;no need to waste time on pass 1

;define all the normal keys
foo=40
.rept 95.
	dk foo,chrnrm
foo=foo+1
.endr

;on c100, the following keys might get swapped in french mode:
;these overlay the normal key definitions
	dk '{,chrfsw
	dk '},chrfsw
	dk '|,chrfsw
	dk '/,chrfsw
	dk '?,chrfsw
	dk '~,chrfsw
	dk '`,chrfsw

	dk 15,chrcr		;go to the next line
	dk 33,chrmta		;escape
	dk 34,chrctl		;fs, what function key prefixes
	dk 177,chrdel		;rubout
	dk 10,chrlt		;backspace is the same as left arrow
	dk 11,chrtab		;tab key
	dkm '',chrbtb		;shift tab, go back one tab stop
	dk 7,chrqui		;control-g, quit for perverts
	dk 12,chrlin		;linefeed, break up line at .
	dk '_,chrudl		;underline

;special for debugging
	dkm 1,chrlot		; esc control a inserts lots of characters
	dkm 2,chrltl		;esc cntl-banother to insert lots of lines
	dkm 54,die		;special for debugging, RESET dies
	dk 53,scrclr		;for debugging, clear screen
	dk 25,chrml4		;perverted argument

;function pad definitions
	dkm 73,chrup		;cursor up
	dkm '<,chrdn		;cursor down
	dkm '>,chrlt		;cursor left
	dkm '=,chrrt		;cursor right
	dkm '?,chrhom		;home key
	dkm ':,chrfil		;filing operations		(mult code)
	dkm '`,chrqui		;quit				(tape)
	dkm '\,chrscu		;scroll up
	dkm '[,chrscd		;scroll down
	dkm '.,chrpag		;go to next page
	dkm '-,chrpag		;on both page and shift page
.if nz prtnum
	dkm '{,chrprt		;print modes			(print)
	dkm '|,chrspr		;set print modes		(shift print)
	dkm '},chripr		;insert print command		(control print)
	dkm '~,chrprj		;print memory			(control-shift print)
.endc
	dkm '],chrstt		;set tab
	dkm '_,chrclt		;clear tab

;real function keys (the type preceeded by FS, whcih sets the control bit)
	dkc '0,chrmod		;set entry modes		(insrt)
	dkc 40,chrecm		;extended commands		(INSRT)
.if nz prtnum
	dkc '1,chrprq		;stop print			(del char)
	dkc '!,chrprc		;continue print			(DEL CHAR)
.endc
	dkc '2,chrshl		;complement shift lock		(insert line)
	dkc ':,chrbld		;boldify			(f6)
	dkc 73,chrser		;search				(f7)
	dkc '+,chrrse		;reverse search			(F7)
	dkc 74,chrswo		;set word operation		(f8)
	dkc '=,chrsli		;line				(f9)
	dkc '>,chrsse		;sentence			(f10)
	dkc '?,chrspa		;paragraph			(f11)
	dkc 'B,chrdlf		;delete forward			(f14)
	dkc '@,chrno		;no				(f12)
	dkc 'C,chryes		;yes				(F12)
	dkc 'A,chrarg		;argument			(f13)
;	dkc 'E,chrrec		;recover			(F13)

.endc	;pass2
.=crctbe

.if nz tvs
	dctab tv		;dispatch table for tvs
.if df pass2

;define all the normal keys
.rept 95.
	dk 40+.rpcnt,chrnrm
.endr

	dk 15,chrcr		;go to the next line
	dkm 15,chrlin		;do a line break
	dk 37,chrctl		;aux
	dk 33,chrmta		;do it
	dkm 37,chrctl		;aux
	dkm 33,chrmta		;do it
	dkc 37,chrctl		;aux
	dkc 33,chrmta		;do it
	dkcm 37,chrctl		;aux
	dkcm 33,chrmta		;do it
	dk 177,chrdel		;rubout
	dk 4,chrdlf		;delete forward
	dk 11,chrtab		;tab key
	dk 7,chrqui		;stop
	dkm 7,die		;meta stop dies
	dk 14,scrclr		;for debugging, clear screen

;function pad definitions
	dk 136,chrup		;cursor up
	dk 12,chrdn		;cursor down
	dk 134,chrlt		;cursor left
	dk 6,chrrt		;cursor right

	dkm 'h,chrhom		;home key
	dkm 'f,chrfil		;filing operations
	dkm 'V,chrscu		;scroll up
	dkm 'v,chrscd		;scroll down
	dkm 'p,chrpag		;go to next page
	dkm '{,chrprt		;print
	dkm 't,chrstt		;set tab
	dkm 'T,chrclt		;clear tab
	dkm 's,chrser		;search
	dk 34,chrswo		;word
	dk 35,chrsli		;line
	dk 36,chrsse		;sentence
	dkm 'n,chrno		;no
	dkm 'y,chryes		;yes

.endc	;df pass2
.=crctbe
.endc	;nz tv

.if nz gt2500
	dctab 25		;dispatch table for tvs
.if df pass2

;define all the normal keys
.rept 95.
	dk 40+.rpcnt,chrnrm
.endr

	dk 15,chrcr		;go to the next line
	dkm 15,chrlin		;do a line break
	dk 33,chrmta		;do it
	dkm 33,chrmta		;do it
	dkc 33,chrmta		;do it
	dkcm 33,chrmta		;do it
	dk 177,chrdel		;rubout
	dkc 'D,chrdlf		;delete forward
	dk 11,chrtab		;tab key
	dk 7,chrqui		;stop
	dkm 7,die		;meta stop dies
	dk 14,scrclr		;for debugging, clear screen

;function pad definitions
	dkc 'P,chrup		;cursor up
	dkc 'N,chrdn		;cursor down
	dkc 'B,chrlt		;cursor left
	dk 8,chrlt
	dkc 'F,chrrt		;cursor right

	dkm 'h,chrhom		;home key
	dkm 'f,chrfil		;filing operations
	dkm 'V,chrscu		;scroll up
	dkm 'v,chrscd		;scroll down
	dkm 'p,chrpag		;go to next page
	dkm '{,chrprt		;print
	dkm 't,chrstt		;set tab
	dkm 'T,chrclt		;clear tab
	dkm 's,chrser		;search
	dkc 'W,chrswo		;word
	dkc 'L,chrsli		;line
	dkc 'S,chrsse		;sentence
	dkm 'n,chrno		;no
	dkm 'y,chryes		;yes

.endc	;df pass2
.=crctbe
.endc	;nz gt2500

.sbttl character routines
;these are the character routines
;they can munge any ac's they want to
;all undefined characters come here
chrund:	undef			;undefined key or function

;special undefined, for other people to get key names on
chryes:	ding
chrno:	ding

;normal quit routine
chrqui:	ding

;set the meta bit, escape is the cursor pag prefix
chrmta:	bis #meta,ctmtbt	;set the bit
chrmt1:	clr lastch		;flag to say don't clear stuff
	rts pc

;set the control bit, put on the fs character whcich is the function key prefix
chrctl:	bis #ctrl,ctmtbt
	br chrmt1		;now dispatch on the next key with the bit set

;set the various types of objects and re-dispatch
chrsch:	mov #char,a		;this is default anyway
chrsc1:	mov a,noun		;set the noun
	clr ctmtbt		;flush control and meta bits
	br chrmt1

chrswo:	mov #word,a		;set to word
	br chrsc1

chrsli:	mov #line,a		;set to line
	br chrsc1

chrsse:	mov #senten,a		;set to sentence
	br chrsc1

chrspa:	mov #para,a		;set to paragraph
	br chrsc1

;multiply last arg by 4
chrml4:	mov repcnt,a		;get old rept count
	ash #2,a		;shift it
	ble 1$			;lost, overflowed
	mov a,repcnt
	br chrmt1		;return clearing lastch
1$:	badarg			;can't set arg too big

;get a numeric argument for the next command
chrarg:	mov #argstr,prompt
	jsr pc,mgetnm
	mov b,repcnt
	clr prompt
	clr lastch
	rts pc


;die for debugging
die:	tyoesc #'x		;c-100 kludge, restore function keys
	jsr pc,ttyfls
	bpt
	jsr pc,@terint		;reset the terminal
	rts pc

;for debugging, insert lots of characters
chrlot:	mov #95.,a
	mov #40,c
1$:	jsr pc,inschr
	inc c
	sob a,1$
	rts pc

chrltl:	mov #95.,a
	mov #40,c
1$:	jsr pc,inschr
	inc c
	mov #chrdn,f
	jsr pc,skeycl
	sob a,1$
	rts pc

;move the cursor up and to the goal column
chrup:	tst b			;already at the top?
	beq toofar		;error
	jsr pc,valgol		;make sure we have a valid goalcl
	dec curlin		;up one
	jsr pc,chkgol		;check that goal is not beyond the line and set curcar
	inc b			;next line number
	cmp b,bufend		;did we just leave the last buffer line?
	bne 1$			;nope
	dec b			;back to the line we were on
	mov (d),e		;get the pointer to the line
	tst blused(e)		;is it a blank line?
	bne 1$			;nope
	mov b,c			;starting line to flush
	mov c,e			;ending line
	inc e			;is next one down
	clr d			;character zero
	clr f			;ending too
	jsr pc,delran		;delete last line in buffer, which is blank
1$:	rts pc

toofar:	ding			;ring the bell

;move the cursor down one line
chrdn:	cmp b,bufend		;at the end of the buffer?
	bhis toofar
	jsr pc,valgol		;make sure we have a valid goalcl
	inc curlin		;next line
	jsr pc,chkgol		;check gaol and set curcar to it
	rts pc

chkgol:	jsr f,acsav
	clr d
	mov curlin,a
	cmp a,bufend		;off the end of the buffer?
	beq 1$
	mov goalcl,d
	asl a
	add buffer,a
	mov blhead(a),a		;get the line
	jsr pc,getchp		;get the right thing
1$:	mov d,curcar		;set the curcar to be right
2$:	jsr f,acres
	rts pc

valgol:	tst goalcl		;is it already valid?
	bge 1$			;yup
	jsr f,acsav
	mov curlin,a		;the current line number
	mov curcar,d		;where the cursor is now
	jsr pc,getdps		;convert to a screen pos
	mov d,goalcl
	jsr f,acres
1$:	rts pc

;move the cursor right one object
chrrt:	jsr pc,nright		;move right over current noun
chrrt1:	beq toofar		;sets z if no where to go
	mov e,curlin		;set the new line
	mov f,curcar		;returns starting pointer in f
invgol:	mov #-1,goalcl		;invalidate goal
	rts pc

;move the cursor left one object
chrlt:	jsr pc,nleft		;mov left over current noun
	br chrrt1

;scroll the screen down so the current bottom line becomes the top line
chrscd:	mov ntopln,a		;if a new toplin has already been determined
	bne 2$			;use it
	mov toplin,a		;top line number
2$:	clr b
	mov #-1,d
	mov numlin,f
	dec f
1$:	inc a			;next line up
	cmp a,bufend		;off the end of the buffer?
	bhis chrsc2		;then don't do anything
	jsr pc,getlnl
	sub c,f			;takes that many lines
	bge 1$
	dec a
chrsu1:	mov a,ntopln
	mov a,curlin
	clr curcar
	clr goalcl
chrsc2:	rts pc

;scroll the screen up so the current top line is on the bottom
chrscu:	mov ntopln,a		;if a new toplin has already been determined
	bne 2$			;use it
	mov toplin,a		;top line number
	beq 8$
2$:	clr b
	mov #-1,d
	mov numlin,f
	dec f
1$:	dec a			;next line up
	beq 8$			;off the top
	jsr pc,getlnl
	sub c,f			;takes that many lines
	bge 1$
	inc a
8$:	br chrsu1

;delete the previous noun from the buffer
chrdel:	jsr pc,nleft		;move left over the object
chrdl1:	beq toofar		;no object
	mov e,c			;starting place
	mov f,d
	mov curlin,e		;ending place
	mov curcar,f		;line, character
	save <c,d>		;save starting place
	jsr pc,delran		;delete that range of the buffer
	rest <curcar,curlin>	;put the cursor there
	jmp invgol		;go clobber goalcl

;delete the next noun from the buffer
chrdlf:	jsr pc,nright		;move right
	beq chrdl1		;nothing to delete
	mov curlin,c		;starting place
	mov curcar,d		;line, character
	jsr pc,delran		;delete this range
	jmp invgol

;if cursor is in the middle of the line, put it to the left
;if it is at the left, put it on the top line

chrhom:	tst c			;already at the left?
	beq 1$			;yup
	clr curcar		;no, put it there
	clr goalcl		;and clear the goal too
	rts pc
1$:	cmp toplin,curlin	;already on the top line?
	beq 2$			;yes, put it to the top of the buffer
	mov toplin,curlin	;put it on the top line
	rts pc
2$:	clr curlin
	rts pc

;insert a random character into the buffer
chrnrm:	mov #atribc,c		;atribute character
	tst boldmd		;boldify everthing?
	beq 1$			;nope
	bis #atrbld,c		;set the bold bit
1$:	tst undrmd		;underline everything?
	beq 2$			;nope
	bis #atrund,c		;set the underline bit
2$:	bit #17,c		;any bits set?
	beq 3$			;nope
	jsr pc,inschr		;insert the atribute character first
3$:	mov lastch,c		;character to insert
	jsr pc,upcasp		;upper case if case lock is set
	jsr pc,inschr		;insert a character at curlin, curcar
	tst autofl		;auto fill?
	beq 5$			;nope, ignore
	mov #-1,goalcl		;invalidate the goal col
	jsr pc,valgol		;and re-validate it
	cmp goalcl,autofl	;past (possibly infinite) autofill column?
	blo 5$			;nope
	mov curlin,a		;the current line number
	asl a
	add buffer,a
	mov blhead(a),a
	mov a,f
	mov curcar,e
	mov e,d			;extra copy
	add e,f
	add #blhead,f		;point to where the cursor is
4$:	dec e			;down curcar
	ble 5$			;can't find a space
	cmpb #40,-(f)		;try to find a space
	bne 4$			;nope
	sub e,d			;number of characters we moved back
	dec d			;minus the one we will delete
	mov e,curcar		;set the cursor there
	beq 6$			;at the beg of the line
	inc curcar
	movb -(f),c		;get the previous character
	jsr pc,atribp		;was it an atribute?
	beq 7$			;yup, don't delete
	dec curcar
6$:	mov #char,noun		;character operation
	mov #chrdlf,f		;delete forward
	jsr pc,skeycl		;call the key routine
7$:	mov #chrlin,f		;break up the line
	jsr pc,skeycl
	mov d,curcar
	inc curlin
	jmp invgol

5$:	rts pc

chrnre:	noroom

;insert the character in c in the line at curlin, at the curcar position

inschr:	jsr f,acsav
	mov curlin,b		;the current line
	mov buffer,a		;pointer to the buffer
	asl b			;make it a word index
	cmp b,blused(a)		;is in in the used part of the buffer?
	blo 2$			;yes, just modify the line
	beq 1$			;have to add a new line
	bpt			;shouldn't have the cursor below the last line
1$:	jsr pc,addlin		;add a line to the buffer
	beq chrnre		;no room
;now we have a line to put the character in, one way or another
2$:	mov b,d			;copy the line number
	add buffer,d		;pointer into the buffer
	add #blhead,d
	jsr pc,invlin		;invalid the line on the screen
	beq chrnre		;had to copy to invalidate, and failed
	mov (d),a		;pointer to the line itself
	cmp blused(a),bllen(a)	;are we about to run out of room?
	blo 3$			;nope, all set
	mov #lininc,b		;amount to add
	jsr pc,expand		;add it
	beq chrnre		;no room
	mov a,(d)		;make the buffer happy too
3$:	mov blused(a),d		;have to shift the line
	mov d,e			;some number of characters
	add a,d			;pointer to the old end of the line
	add #blhead,d
	mov d,f
	inc d			;pointer to the new end of the line
	sub curcar,e
	beq 5$			;zero!
4$:	movb -(f),-(d)
	sob e,4$
5$:	inc blused(a)		;one more space used
	movb c,-(d)
	tst blplen(a)		;is the old length known?
	blt 6$			;nope
	jsr pc,charsz		;how big
	add c,blplen(a)
6$:	inc curcar		;move cursor past here
	jsr f,acres
	rts pc

;Delete the character in front of the cursor
delchr:	jsr f,acsav
	mov curlin,b		;the current line
	mov buffer,a		;pointer to the buffer
	asl b			;make it a word index
	cmp b,blused(a)		;is in in the used part of the buffer?
	bhis 9$			;no, do nothing
	mov b,d			;copy the line number
	add buffer,d		;pointer into the buffer
	add #blhead,d
	jsr pc,invlin		;invalid the line on the screen
	beq chrnre		;had to copy to invalidate, and failed
	mov (d),a		;get a pointer to the line
	mov curcar,b		;the character to delete
	cmp b,blused(a)		;is it on the line?
	bhis 9$			;no, do nothing
	dec blused(a)		;one less char on the line
	mov a,d			;get a pointer to the flushed char
	add b,d
	add #blhead,d
	movb (d),c		;get the character
	jsr pc,charsz		;get its size
	sub c,blplen(a)		;line is that much shorter
	mov blused(a),e		;total chars on the line
	sub b,e			;number that need moving
	beq 9$			;none
	mov d,b			;copy pointer
	inc b			;this is where the chars come from
1$:	movb (b)+,(d)+		;shift line down
	sob e,1$
9$:	jsr f,acres
	rts pc

;special french stuff
chrfsw:	tst french		;are we in french mode?
	bne 1$			;yup
	jmp chrnrm		;no, do normal character thing
1$:	mov lastch,a		;the character that got us here
	mov #frtab,b		;table of coorespondence
2$:	cmpb a,(b)		;match?
	beq 3$			;yup
	tst (b)+		;next word
	cmp #frtabe,b		;end?
	bne 2$
	badarg			;strange

3$:	movb 1(b),lastch	;the character to be inserted
	mov #chrnrm,f		;normal insert routine
	jsr pc,skeycl		;call, saving registers
	cmp #frtaba,b		;are we in the accent-only range?
	blos 4$			;yup, more stuff to do
	rts pc

4$:	mov #char,noun
	mov #chrlt,f		;move the cursor back one space
	jsr pc,skeycl
	jsr pc,update		;make sure the screen is ok
	jsr pc,getkey		;get the next character
	mov fratab(b),c		;table for this accent
5$:	tstb (c)		;at end?
	beq 6$			;yup, flush char and ding
	cmpb (c),a		;this it?
	beq 6$			;yup
	tst (c)+		;next word
	br 5$

6$:	mov #chrdlf,f		;delete the accent
	jsr pc,skeycl
	movb 1(c),lastch	;translated character
	beq 7$			;none, ring bell
	mov #chrnrm,f
	jsr pc,keycal		;insert it
	rts pc

7$:	badarg


;set to boldface
chrbld:	mov #atrbld,atrtem	;want to hack bold
	br chratr

;underline
chrudl:	mov #atrund,atrtem	;set the attribute to be hacked
chratr:	jsr pc,invlin		;invalidate the line
	mov (d),e		;get the current line
	cmp blused(e),c		;are we at the end of the line?
	beq 9$			;yup, something special
	mov e,f			;copy line pointer
	add #blhead,f
	add c,f
	cmpb #atribc,(f)	;is the character an atribute character?
	blos 1$			;yup
	mov #atribc,c
	jsr pc,inschr		;insert an atribute character
	dec curcar		;back over inserted character
1$:	mov curlin,a
	asl a
	add buffer,a		;get the buffer
	mov blhead(a),a		;get the pointer to the current line
	add #blhead,a
	add curcar,a		;get a pointer to the attribute character
	movb (a),b
	mov atrtem,c		;set the apropriate atribute
	xor c,b
	movb b,(a)		;xor the underline bit and replace the character
	bitb #17,(a)		;any atritutes set?
	bne 2$			;yup
	jsr pc,delchr		;no, flush the atribute char
2$:	save noun
	mov #char,noun
	mov #chrrt,f
	jsr pc,keycal
	rest noun
	rts pc

9$:	ding

;carriage return: go to the next line, making a new one if at the end of the buffer
;Probably chrcr should insert blank lines in the middle of the buffer too
chrcr:	asl b			;the line number we are at
	cmp b,blused(a)		;at the end of the buffer?
	bhis 2$			;yes, add a line at the end
	tst (b)+		;the next line
	cmp b,blused(a)		;is that at the end of the buffer?
	bhis 1$			;yes, just go there
	mov 2(d),e		;the next line
	tst blused(e)		;blank?
	beq 1$			;yes, just gobble it down
2$:	jsr pc,addlin		;add a line to the buffer
	beq noroo1		;success?
1$:	inc curlin		;next line
	clr curcar		;at the begining
	clr goalcl		;goal is here too
	rts pc

noroo1:	noroom

;line feed: break up line into two lines
chrlin:	cmp b,bufend		;are we at the end of the buffer?
	beq 9$			;yup, do nothing
	jsr pc,invlin		;invalidate the current line
	inc b			;go to the next line
	asl b
	sub buffer,d		;make d relative
	jsr pc,addlin		;and cram in a new line
	beq noroo1
	add buffer,d		;in case the buffer moved
;now (d) is the line to breakk and 2(d) is the lien to put the overflow into
	mov (d),f		;line to break
	mov blused(f),b		;total characters
	sub c,b			;number of characters that will go on next line
	save b			;save it
	mov 2(d),a		;next line
	sub blused(a),b		;number of characters needed to fit the stuff
	ble 1$			;right or more than enough
	inc b			;do a .even
	bic #1,b
	jsr pc,expand		;expand the line
	beq 19$			;lost
	mov a,2(d)		;the expanded line
1$:	mov c,blused(f)		;the old line will have just this many chars
	rest e			;get back number of characters to move
	save f			;save pointer to the old line
	mov e,blused(a)		;this is the number in the new line
	beq 8$			;none, done
	add #blhead,a		;point to data part
	add #blhead,f		;point to data part
	add c,f			;point to part to be copied
2$:	movb (f)+,(a)+
	sob e,2$
8$:	rest a			;get back pointer to the old line
	mov #bltiny,f		;limit on allowed free space
	jsr pc,shrink		;make it smaller if it is very large
9$:	rts pc

19$:	noroom

;tab stop stuff
;init tabs to every five characters
tabint:	mov #5,c		;place to set a tab
	mov c,b
	mov #tabs,a		;the tab table
2$:	clrb (a)+		;clear it out
	cmp #tabe,a		;at end?
	bne 2$
	mov #tabs,a
1$:	bisb bmt(b),(a)		;set the tab
	add #5,b		;to the next one
4$:	cmp #10,b		;into the next byte?
	bgt 3$			;nope
	sub #10,b
	inc a			;next byte
	br 4$
3$:	add #5,c		;every 5
	cmp numcar,c		;for the size of the screen only
	bgt 1$
	rts pc

;set a tab at the current character position
chrstt:	jsr pc,tabsoc		;compute the frob
	jsr pc,tabso1
	bisb bmt(b),(a)		;set the bit
	rts pc

;clear a tab at the current character position
chrclt:	jsr pc,tabsoc		;compute the frob
	jsr pc,tabso1
	bicb bmt(b),(a)		;clear the bit
	rts pc

tabsoc:	mov #-1,goalcl		;flush the old goal
	jsr pc,valgol		;get the current display pos into goalcl
	mov goalcl,c
	rts pc
;tab set or clear computation
tabso1:	mov c,b			;put it into an odd register
	clr a
	div #8.,a		;get quotient and remanider
	add #tabs,a
	cmp #tabe,a		;past the end of the table?
	blos tabdng		;yup, lose
	rts pc
tabdng:	ding

;go to the next tab stop
chrtab:	tst tabmod		;are we inserting tabs or fixed spaces?
	beq 1$			;insert fixed spaces
	jmp chrnrm		;insert normally
1$:	jsr pc,tabsoc		;get the pointers
2$:	inc c
	jsr pc,tabso1
	bitb bmt(b),(a)		;tab stop there?
	beq 2$			;nope
	mov d,f			;save pointer into buffer
	mov c,e			;save our goal
	cmp curlin,bufend	;are we on the first non-ex line?
	beq 4$			;go insert spaces
3$:	mov (f),a		;the current line
	mov e,d			;get the goal back
	jsr pc,getchp		;get the character position
	bne tabfnd		;got a good one
	mov d,curcar		;set us as far as possible
4$:	save c
	mov #fixchr,c		;for inserting fixed space
	sub buffer,f		;in case the buffer moves
	jsr pc,inschr
	add buffer,f
	rest c
	br 3$			;try again
tabfnd:	mov d,curcar
	jmp invgol

;go back to the previous tab stop
chrbtb:	jsr pc,tabsoc		;get the current display pos
1$:	dec c
	beq 2$			;done
	blt tabdng		;over done
	jsr pc,tabso1		;get the bit
	bitb bmt(b),(a)		;test it
	beq 1$			;not there
2$:	mov (d),a		;the current line
	mov c,d			;the position we want
	jsr pc,getchp		;convert to character pos
	br tabfnd

;reverse search
chrrse:	mov #rsercp,prompt	;put up the prompt
	mov p,serdir		;reverse
	br chrse1

;search for string
;inputs a number of words from the user, then searches for that
;sequence of words withput regard to case or whitespace
chrser:	mov #searcp,prompt	;put up the prompt
	clr serdir		;search forward
chrse1:	clr string		;flush out any old string
1$:	mov #maxsrs,maxstl	;set up the max length
	mov #serstr,defstr	;and the defualt string
	mov #-1,strtrc		;don't terminate on space
	jsr pc,strgec		;continue gobbling down string
	jsr pc,getnam		;get the name of the character
	cmp #chrcr,f		;was the terminator a cr?
	beq 2$			;yup, go search
	jsr pc,bell		;ding
	br 1$			;and continue

;we don't touch curcar and curlin until we find something so we don't need to worry
;if we lose totally
2$:	mov #string,a		;the typed in string
	mov #serstr,b		;the search string
3$:	movb (a)+,(b)+		;copy it
	bne 3$
	mov curlin,a		;the starting line
	mov curcar,b		;the starting character
	asl a			;word index
	add buffer,a		;pointer into buffer
	add #blhead,a		;pointer to the data
	mov buffer,f		;get a pointer
	add #blhead,f
	add bufend,f
	add bufend,f		;to the last line in the buffer
	mov f,ubufep		;the end of buffer
	tst serdir		;forward or reverse?
	bne serls1		;reverse search starts by backing up
serlop:	save <a,b>		;starting point
	mov #serstr,d		;also for the user's string
serlo1:	movb (d)+,c		;get the user's character
	beq serwin		;end of user's string, done!
	cmp #40,c		;is this a whitespace matcher?
	beq serwhi		;yes, go match whitespace
1$:	mov (a),e		;pointer to the line
	cmp b,blused(e)		;at end of the line?
	beq serlos		;lost the match
	add #blhead,e		;point to data part
	add b,e			;point to right character
	inc b			;go past it
	movb (e),e		;get the character
	bge 2$			;branch if not accent char
	bic #177400,e		;get an 8 bit char
	cmp #atribc,e		;is it an atribute character?
	blos 1$			;yes, ignore it
	cmp #300,e		;is it in the alpha range?
	blos 2$			;nope
	movb acctrn-200(e),e	;translate it
2$:	sub c,e			;get the difference
	beq serlo1		;none, win
	cmp #40,e		;just upper/lower difference?
	beq serlo1
	cmp #-40,e
	beq serlo1
;fall through to serlos
;falls in
serlos:	rest <b,a>		;get back where we started
serls1:	tst serdir		;forward or rverse?
	bne 2$			;reverse
	inc b			;next character
	mov (a),e		;pointer to the line
	cmp b,blused(e)		;off end of line?
	blo serlop			;no, try again
	tst (a)+		;next line
	clr b			;character zero
	cmp a,ubufep		;at the end of the buffer?
	blo serlop
1$:	serfai			;lost the search

2$:	dec b			;previous character
	bge serlop		;go try again if not off beg
	tst -(a)		;previous line
	mov a,e			;copy
	sub #blhead,e		;ignore the header
	cmp e,buffer		;are we before the beg of the buffer?
	blo 1$			;yup, lost
	mov (a),e		;get the line pointer
	mov blused(e),b		;get the char count
	br 2$			;and go back one

;found the string
serwin:	tst serdir		;forward or reverse?
	bne 2$			;reverse
	cmp (p)+,(p)+		;flush the save start
1$:	sub #blhead,a		;turn this back into a line number
	sub buffer,a
	asr a
	mov b,curcar		;set the cursor to the end
	mov a,curlin
	clr prompt
	jmp invgol

2$:	rest <b,a>		;get back the start of the item
	br 1$

;come here when a whitespace is found in the search string
serwhi:	cmpb #40,(d)+		;all spaces in search string are treated as one
	beq serwhi
	dec d			;point to first non-space
	clr f			;flag for whitespace found
1$:	mov (a),e		;pointer to the line
	cmp b,blused(e)		;at the end?
	beq 2$			;yup, that's white space
	add #blhead,e		;point to the data
	add b,e
	movb (e),c		;get the character
	jsr pc,whitep		;is it whitespace?
	bne 3$			;nope, time to exit
	inc f			;found some whitespace
	inc b			;pass it
	br 1$
2$:	inc f			;found whitespace
	tst (a)+		;one more line
	clr b			;character zero on the line
	cmp a,ubufep		;at end of buffer?
	bne 1$			;no, keep skipping whitespace
	tstb (d)		;end of search string?
	beq 3$			;yup, win if found whitespace
	serfai

3$:	tst f			;any whitespace?
	bne serlo1		;yup, win
	br serlos		;nope, lose

;move right over the current noun
;called with the same initial conditions as a chr routine
;returns with ending line in e, character in f
nright:	save <a,b,c,d>
	inc b
	cmp b,bufend		;are we on the last line?
	blo 1$			;nope
	mov (d),e		;pointer to the line
	cmp c,blused(e)		;at the end of the line?
	beq rtszrx		;yes, can't move right, return with z set
1$:	dec b			;back to the real cursor
	mov b,e			;line number
	mov c,f			;character number
	mov noun,a		;current noun
	jmp @2$(a)		;dispatch to proper routine
2$:	rchar
	rword
	rline
	rsent
	rpara

rchar:	mov (d),a		;pointer to the line
	cmp f,blused(a)		;are we on the last character?
	beq rtszrx		;return with z set
	inc f			;move one character
	cmp f,blused(a)		;now on the last char?
	beq rtczrx		;yup
	add #blhead,a		;get to the data
	add f,a
	cmpb #atribc,-1(a)	;did we just skip an atribute char?
	blos rchar		;yup, go skip another
	br rtczrx		;and return

rword:	mov (d),b		;pointer to the line
	cmp f,blused(b)		;are we on the last character?
	beq rline		;then pretend it was a line move
	mov f,a			;position in the line
	add b,a			;pointer to the data
	add #blhead,a		;in the line
1$:	movb (a)+,c		;get the character
	inc f			;we are at the next character
	jsr pc,atribp		;is it an atribute?
	beq 7$			;yup, ignore it
	jsr pc,wdelim		;is it a word delimiter?
	bne 2$
7$:	cmp f,blused(b)		;at the end of the line?
	bne 1$			;not yet
	br rtczrx

2$:	cmp f,blused(b)		;at the end of the line?
	beq rtczrx		;return
	movb (a)+,c		;get next character
	jsr pc,wdelim		;delimiter?
	beq 3$			;yup
4$:	inc f			;next character
	br 2$

3$:	dec a			;get before delimiter
6$:	movb -(a),c		;get the character before it
	jsr pc,atribp		;atribute character?
	bne rtczrx		;nope, we are at the right place
5$:	dec f			;leaving us at the last word delimiter
	beq rtczrx		;back to the beg of the line
	br 6$			;check for multiple atributes

rline:	mov (d),b		;pointer to the line
	cmp c,blused(b)		;are we on the last character?
	bne 1$			;no, go to the end of the line
	inc e			;go to the next line
	clr f			;go the beggining
	br rtczrx
1$:	mov blused(b),f		;put us on the last character
	br rtczrx		;and return

rtczrx:	br rtczrt
rtszrx:	br rtszrt

rsent:	mov (d),b		;pointer to the line
	mov b,a			;copy the line pointer
	add f,a			;point into the line
	add #blhead,a		;this will get us there
1$:	cmp f,blused(b)		;are we on the last character?
	beq 8$			;go look for another line
	movb (a)+,c		;is this a sentence delimiter?
	inc f
	jsr pc,sdelim
	bne 1$			;nope, keep looking for one
3$:	cmp f,blused(b)		;is it at the end of the line?
	beq rtczrt		;yup, we have a sentence!
	movb (a),c		;get the next character
	jsr pc,sdelim		;another senentece delimiter?
	bne 2$			;nope
13$:	inc a			;skip over
	inc f			;multiple sentence delimiters
	br 3$
2$:	cmp #atribc,c		;is it an atribute character?
	blos 13$		;yup, ignore
	jsr pc,whitep		;is it white space?
	bne 1$			;nope
	inc f			;include delimiter in the sentence
	jmp lexit		;yes, that's a sentence

8$:	inc e			;go to the next line
	tst (d)+
	cmp e,bufend		;are we at the end of the buffer?
	beq 9$
	clr f			;go to beggining of next line
	br rsent		;and try again

9$:	dec e
	br rtczrt		;yup, return succesful


rpara:	clr ttemp
2$:	inc e			;go to the next line
	clr f			;go to beggining of next line
	tst (d)+
	cmp e,bufend		;are we at the end of the buffer?
	bhis rtczrt
	mov (d),a
	tst blused(a)		;is the line blank?
	beq 3$			;yup, para end
	tst ttemp
	bne rtczrt
	add #blhead,a		;get to the data
1$:	movb (a)+,c		;get a character
	jsr pc,atribp		;atribute?
	beq 1$			;just skip
	jsr pc,whitep		;whitespace?
	beq rtczrt		;yup, win here
	br 2$			;get next line

3$:	inc ttemp
	br 2$

rtczrt:	rest <d,c,b,a>
	clz			;clear z
	rts pc			;return

rtszrt:	rest <d,c,b,a>
	sez			;clear z
	rts pc			;return

;like nright, only move left
nleft:	save <a,b,c,d>
	tst b			;are we on the first line?
	bne 1$			;nope
	tst c			;at the beggining of the first line?
	beq rtszrt		;yes, can't move right, return with z set
1$:	mov b,e			;line number
	mov c,f			;character number
	mov noun,a		;current noun
	jmp @2$(a)		;dispatch to proper routine
2$:	lchar
	lword
	lline
	lsent
	lpara

lchar:	tst f			;are we in the first position?
	beq rtszrt		;yes, return failure
	dec f			;move back one
lexit:	tst f			;on the first char now?
	beq rtczrt		;yup
	mov (d),b
	add #blhead,b		;get to the data
	add f,b
	cmpb #atribc,-1(b)	;do we have an artibute character in front of us?
	blos lchar		;yup, go skip another
	br rtczrt		;that's all

lword:	tst c			;are we on the first character?
	beq lline		;yes, do a line move
	mov c,a			;position in the line
	add (d),a		;pointer to the data
	add #blhead,a		;in the line
1$:	movb -(a),c		;get the character
	dec f			;we are at the next character
	jsr pc,wdelim		;is it a word delimiter?
	bne 2$			;nope, part of the word
	tst f			;at the begging of the line?
	bne 1$			;not yet
	br lexit

2$:	tst f			;at the beggining of the line?
	beq lexit		;return
	dec f
	movb -(a),c		;get next character
	jsr pc,wdelim		;delimiter?
	beq lexit		;yup
	br 2$

lline:	tst c			;already at the beggining?
	bne 1$			;nope
	mov -(d),b		;get the previous line
	dec e
	mov blused(b),f		;go to the end of it
	br rtczrt
1$:	clr f
	br rtczrt		;just go to the beggining and return

rtczry:	br rtczrt
rtszry:	br rtszry

lsent:	clr ttemp		;havn't found non-whitespace yet
2$:	mov (d),b		;pointer to the line
	mov b,a			;copy the line pointer
	add f,a			;point into the line
	add #blhead,a		;this will get us there
1$:	tst f			;are we on the last character?
	beq 8$			;go look for another line
	cmp #1,ttemp		;got a line break?
	beq 3$			;yes, look for sent delmiter
	movb -(a),c		;is this whitespace?
	dec f
	beq 8$			;hit the beggining of a line
	jsr pc,whitep
	beq 3$			;yes
4$:	mov p,ttemp		;found something not whitespace
	br 1$			;keep looking for delimiters
3$:	tst ttemp		;have we already found a non-whitespace?
	beq 1$			;no, so skip this delimiter
	movb -1(a),c		;get the previous character
	jsr pc,sdelim		;is it a sentence delimiter?
	bne 4$			;nope
				;have a senetence
	br lexit		;and return winning

8$:	dec e			;go to the previous line
	bge 9$			;not off the top yet
	clr e			;set to the top
	br lexit		;off the top return

9$:	mov -(d),b		;get the line pointer
	mov blused(b),f		;get to the end of the line
	mov #1,ttemp		;the begining of a line is a word delimiter
	br 2$

lpara:	clr ttemp		;havn't found non-whitespace yet
3$:	mov (d),a		;get the line pointer
	tst blused(a)		;is it blank?
	beq 2$			;yup
	add #blhead,a
4$:	movb (a)+,c		;get a character from the front of the line
	jsr pc,atribp		;atribute character?
	beq 4$			;yup
	jsr pc,whitep		;whitespace?
	bne 5$			;nope
2$:	inc ttemp		;found a paragraph break
5$:	dec e			;go to the next line up
	bge 1$			;got one
	clr e			;set to the top line
	clr f			;character zero
	br rtczry		;return winning

1$:	mov -(d),b		;get previous line
	mov blused(b),f		;is it blank?
	beq 2$			;yup, keep going
	tst ttemp		;have we found a boundary?
	beq 3$			;not yet
	br rtczry		;win
	


;set z if the character in c is a word terminator
wdelim:	cmpb #'A-1,c		;is it A or above?
	blo 1$			;yup, not word deliminter
	cmpb #'9,c		;is it a number
	blo 2$			;nope, above 9
	cmp #'0-1,c		;maybe number
	blo 1$
2$:	sez			;everything else delimits words
1$:	rts pc

;set z if the character in c is a sentence terminator
sdelim:	cmpb #'.,c		;period
	beq 1$
	cmpb #'?,c		;question mark
	beq 1$
	cmpb #'!,c		;exclamation
1$:	rts pc

;set z if the character in c is white space
whitep:	cmpb #40,c		;space
	beq 1$			;is whitespace
	cmpb #fixchr,c		;so is fixed space
1$:	rts pc

;set z if the character in c is an atribute character
atribp:	cmpb #atribc,c
	bhi 1$			;not
	sez
1$:	rts pc

;make the character in c upper case if shtlck is set
upcasp:	tst shtlck
	beq upcas1

;make the character in c upper case
upcase:	cmpb #'a,c		;is it in the lower case range
	bhi upcas1		;nope, below a
	cmpb #'z,c
	bhis upcas2		;yup, below z
	cmpb #241,c		;is it accented lower case?
	bhi upcas1		;nope
	cmpb #257,c
	blo upcas1
upcas2:	sub #40,c
upcas1:	rts pc

;upper case the sting in b
upstrn:	save <b,c>
1$:	movb (b),c		;get a character
	jsr pc,upcase		;upper case it
	movb c,(b)+		;and put it back
	bne 1$			;until the end of the string
	rest <c,b>
	rts pc
;given a line pointer in (d), if it is on the screen copy it and indicate that
;the screen line is no longer in the buffer
invlin:	save <a,c,f>
	mov (d),a		;get the line pointer
	tst blplen(a)		;does it have a valid display length?
	blt 3$			;if not it can't be on the screen
	mov #screen,a
	mov numlin,c
1$:	cmp (a)+,(d)		;is this the line?
	beq 2$
	sob c,1$		;look through the whole screen
3$:	rest <f,c,a>
	clz
	rts pc
2$:	save a
	mov (d),a		;the line being modified
	jsr pc,copy		;make a copy
	beq 9$			;arg! failed
	mov (d),f		;save what's there
	mov a,(d)		;the copy is put into the buffer
	rest a
	tst -(a)
4$:	cmp f,(a)+		;is this line here? (always should be the first time)
	bne 3$			;nope, done
	clr <screeb-screen>-2(a)	;say this line is not in the buffer
	sob c,4$		;check for continuation lines
	br 3$			;and return

9$:	rest <,f,c,a>
	sez
	rts pc

;add a line to the buffer; index to place to put it is in b
;pointer to buffer is in a
addlin:	jsr f,acsav
	mov blused(a),c		;amount used currently
	tst (c)+		;want to add one
	cmp c,bllen(a)		;is there room left?
	blo 3$			;yes
	mov b,e			;save the curlin*2
	mov #bufinc,b		;add a small amount to the buffer size
	jsr pc,expand		;expand the buffer
	beq 9$			;lost
	mov a,buffer		;in case it moved
	mov e,b
3$:	mov #ilinsz,a		;initial line size
	jsr pc,getblk		;get one
	beq 9$
	mov a,e			;new line pointer
	mov buffer,a
	mov a,c
	add #blhead,c
	mov c,f			;copy buffer pointer
	add blused(a),f		;get an end pointer
	add b,c			;now we have a pointer to where the new line goes
4$:	mov (c),d		;get what was there
	mov e,(c)+		;put in the new thing
	mov d,e			;now this is the new one
	cmp c,f			;past the end?
	blos 4$
	add #2,blused(a)	;one more word used
	inc bufend		;it now ends further down
	jsr f,acres
	clz
	rts pc

9$:	jsr f,acres
	sez
	rts pc


;delete a range of stuff from the buffer, starting at c,d and ending at e,f (line,char)
;then take that and if it was ajacent to the top thing on the kill ring
;add it to the top thing on the kill ring; otherwise make it be the new top thing
;clobbers all registers
delran:	save <c,d,e,f>		;save all these
2$:	mov c,d			;get the start line
	asl d			;a word index
	add buffer,d
	add #blhead,d		;a pointer to the line pointer
	cmp c,e			;are we past the last line to change?
	blo 10$			;nope
	bhi 11$			;off the end
	tst f			;do we change any characters on the last line?
	beq 11$			;no, nothing to do
10$:	inc c			;next line
	jsr pc,invlin		;we are going to damage this line
	bne 2$
	noroom			;not enough room!

11$:

;here we should put the stuff into the kill buffer
;this is done in a single operation without affecting hte real buffer
;so if a failure occurs the buffer isn't screwed

;here we actually flush the stuff from the buffer. the buffer area
;is garenteed not shared by anyone, we can mung the lines all we like
delrfl:	rest <f,e,d,c>		;get back the limits
	tst d			;start at character zero?
	bne 10$			;nope
	tst f			;end at zero too?
	bne 10$			;nope
;in this case we don't make any new line, just flush existing ones
	mov c,b			;line number to start at
	asl b
	add buffer,b
	add #blhead,b		;get a pointer into the buffer
	br 18$			;go flush the lines and squeeze the buffer

10$:	mov c,a			;get the start line
	asl a
	add buffer,a
	add #blhead,a
	mov (a),a		;actual pointer to the line
	jsr pc,copy		;make a copy of it
	beq dnoro1		;no room
	mov d,blused(a)		;the amount used equals the number of characters no flushed on the first line
	cmp e,bufend		;is the ending line the first non-ex line?
	beq 17$			;yes, nothing on it to copy then
	mov e,b			;ending line
	asl b
	add buffer,b
	add #blhead,b
	mov (b),b
	mov blused(b),b		;get the amount of used space
	sub f,b			;minus ending character
				;is amount of extra space needed in copy line
	add blused(a),b		;space used in copy line
	sub bllen(a),b		;sapce available in copy line
	ble 1$			;more than enough available
	inc b			;make this
	bic #1,b		;even
	jsr pc,expand		;and try to expand the line
	beq dnorom		;ugh, not enough room
;now we can't lose, it is safe to mung the buffer
1$:	mov e,b			;ending line
	asl b
	add buffer,b
	add #blhead,b
	mov (b),b		;this is the line that goes on the end
	save <c,d>
	mov blused(b),c		;total stuff on the end line
	sub f,c			;amount to copy
	add c,blused(a)		;extra amount used
	mov a,d			;copy pointer to new line
	add (p),d		;point to end of used portion
	add #blhead,d
	add f,b			;point to part we want to save
	add #blhead,b
	tst c			;any to copy?
	beq 3$			;nope
2$:	movb (b)+,(d)+
	sob c,2$
3$:	rest <d,c>
;falls in to next page

;falls through from previous page
;now a has a pointer to the line that will subsitute for everything we are flushing
17$:	mov c,b			;line number we start at
	asl b
	add buffer,b
	add #blhead,b
	save (b)		;save line to be flushed
	mov a,(b)+		;stuff in the new line
	rest a			;get back the line to be flushed
	jsr pc,freeb		;free the last lineflushed
	cmp e,bufend		;is the ending line the end of the buffer?
	bne 18$			;nope
	dec e			;don't flush a non-ex line
18$:	sub c,e			;number of lines to flush
	ble 29$			;no lines to flush, done
	sub e,bufend		;move the end
	mov buffer,c
	sub e,blused(c)		;flushing stuff from the buffer
	sub e,blused(c)
	mov c,f			;copy pointer to buffer
	add blused(c),f		;make a pointer
	add #blhead,f		;to the end
	mov b,d			;copy pointer
4$:	mov (b),a		;next line
	dec e			;any more?
	blt 8$			;nope
	jsr pc,freeb		;free the last line flushed
	clr (b)+
	br 4$
8$:	cmp b,d			;anything to do?
	beq 6$			;nope
5$:	cmp d,f			;at end?
	bhis 7$
	mov (b)+,(d)+		;move word down
	br 5$
7$:	clr -(b)
6$:	cmp curlin,bufend	;curlin past end of buffer?
	blos 29$		;nope, ok
	mov bufend,curlin	;set at new end of buffer
	clr curcar		;and reset character number too
29$:	rts pc

dnorom:	jsr pc,freeb		;free the thing in a
dnoro1:	noroom

;special case of delran, kill the whole buffer
;when delran starts saving the last thing killed this should
;somehow avoid that saving
kilbuf:	jsr f,acsav
	clr c
	clr d			;from zero zero
	mov bufend,e		;to the end of the buffer
	clr f
	jsr pc,delran
	clr curcar
	clr curlin
	clr goalcl
	jsr f,acres
	rts pc


.iif z rt11, .insrt tnfile >
.sbttl mode and command stuff
;set entry modes
chrmod:	mov #modep,a		;entry mode prompt
	mov #emodem,e		;entry mode menu
chrmo1:	jsr pc,dmenu		;display it and gobble down the settings
	rts pc

;Extended editor commands
chrecm:	mov #excmdp,a		;extended command prompt
	mov #excmdm,e		;extended command menu
	br chrmo1
.iif z rt11,.insrt tnprin >

.sbttl menu routines
;read a sting in the status line and do completion for the menu in e
;a contains the thing to put in the status line
;f contians the amount to time out before displaying the menu
dmenu:	clr prtspc		;special flag for print menu
dmenu1:	mov a,prompt		;set up the prompt for the status line
	jsr pc,dstat		;display the status line
	mov e,menusv		;save the menu
	mov #tmenu,e		;type saved menu if time out
	mov #90.,f		;time to wait
	clr string		;start with null string
1$:	mov #maxstr,maxstl	;set the max length
	mov #40,strtrc		;terminate on a space
	jsr pc,strgec		;get a string
	jsr pc,quread		;quit read if not legal terminated
	jsr pc,mmenu		;do a match on the menu
	bcs 2$			;carry set means bad match
	beq 1$			;not a complete match, continue
	clr string		;equal to the string
	jsr pc,dstat		;display it
	clr strarg		;call to get tty input, if input needed
	jsr pc,(a)		;got a match, call it
	clr prompt		;done, don't display this any more
	rts pc

2$:	jsr pc,bell
	br 1$

quread:	cmp #40,a		;terminated on space?
	beq 1$			;yup
	cmp #15,a		;cr?
	beq 1$			;yup
	jsr pc,getnam		;get the name
	cmp #chrfsw,f		;french accent?
	beq 1$			;yup
	cmp #chryes,f		;also allow yes and no as terminators
	beq 1$
	cmp #chrno,f
	beq 1$
	mov a,rescan		;will re-read
	ding
1$:	rts pc

mmenu:	save <e,f>
	mov menusv,a		;get back the menu pointer
	clr menueq		;if we find multiple matches, this points past the
				;the space in the first one where the match ends
	clr b			;this is the menu item we've found that matches
1$:	mov #string,c
	tst (a)
	beq 18$			;off the end of the menu
	add #menuoh,a		;go to the string part by adding in the overhead
	cmp #menuti,menufl-menuoh(a)	;is this just a title line?
	beq 8$			;yup, skip it
	tst prtspc		;special?
	beq 4$			;nope
	blt 2$			;if < 0 do only insert commands
	bit #menuio,-menuoh(a)	;is it insert only?
	bne 8$			;yup, ignore
	br 4$
2$:	tst menuir-menuoh(a)	;is there a an insert routine?
3$:	beq 8$			;nope, skip it
4$:	save a
5$:	movb (a)+,e		;get a character
.if nz frp
	save c
	mov e,c
	jsr pc,frppre
	bne 6$
	movb (a)+,e
6$:	rest c
.endc
	movb (c)+,f		;get one from the user's string
	beq 9$			;end of user's string
.if nz frp
	save c
	mov f,c
	jsr pc,frppre
	bne 7$
	movb @(p),f
	inc (p)
7$:	rest c
.endc
	sub e,f			;difference
	beq 5$			;equal so far
	cmp #40,f		;difference only in case?
	beq 5$			;yup
	cmp #-40,f		;this way too...
	beq 5$
	rest a			;get back pointer to start
8$:	tstb (a)+		;find the end of the item
	bne 8$
	inc a			;do a .even
	bic #1,a
	br 1$			;try for another


9$:	tst e			;end of menu string too?
	beq 17$			;perfect match
	tst b			;have we already found one thing that matches?
	beq 17$			;nope
	sub #string+1,c		;giving number of matched characters
	dec a			;undo the ()+
	add b,c			;getting pointer into first matched thing at end of match
10$:	cmpb (c)+,(a)+		;do the two menu items match?
	bne 14$			;no, ambigious so far
	cmpb #40,-1(a)		;space?
	beq 11$			;yes, matched to space
	tstb -1(a)		;zero would be good too
	bne 10$			;keep looking
11$:	mov c,menueq		;only go this far in the completion
12$:	cmpb (c)+,(a)+		;more match?
	bne 13$			;nope
	cmpb #40,-1(a)		;match to another space?
	beq 11$			;yup
	tstb -1(a)		;how about a zero?
	bne 12$
	mov c,menueq		;ok, this is the end
13$:	tst (p)+		;flush saved thing
	br 8$

14$:	tst (p)+		;flush saved thing
15$:	rest <f,e>
	sez
	sec
	rts pc

16$:	rest <f,e>
	sez
	rts pc			;return ambigous

17$:	rest b			;pop the found thing
	br 8$

;here we have found a match which is at least partly unambigous
;or else no match at all
18$:	tst b			;any match?
	beq 15$			;nope
	mov b,f
	mov #string,d
19$:	movb (b)+,(d)+		;move the matched thing into the string
	beq 20$			;end of thing
	cmp b,menueq		;end of valid match?
	bne 19$
	clrb (d)+
	br 16$			;go get the rest

20$:	mov f,prompt		;this becomes the prompt
	sub #menuoh,f
	mov f,a			;copy it
	tst prtspc		;special?
	bge 21$			;regular or direct
	add #menuir-menudp,a
21$:	mov menudp(a),a		;the dispatch address
	rest <,e>
	clz
	rts pc

;Wait until a character is typed or the time in f has elapsed
ptyip:	save <a,b,c>
.if z rt11
	save #sstats
	$sstat			;get the system time
	mov stime,b		;low order part
	mov stime+2,c		;high order part
.iff
	.gtim #emttmp,#stime
	mov stime+2,b		;low order part
	mov stime,c		;high order part
.endc
	add f,b
	adc c			;get the time to give up

1$:	jsr pc,tyip		;any characters?
	bne 9$			;yup, return
.if z rt11
	save <#0,#1>		;sleep for 1 60th
	$sleep
	save #sstats
	$sstat
	cmp stime+2,c		;is the high order part equal?
	bhi 8$			;above, done
	blo 1$
	cmp stime,b		;low order part
	blo 1$			;not done yet
				;done, fall in to 8$
.iff
	.gtim #emttmp,#stime
	cmp stime,c		;is the high order part equal?
	bhi 8$			;above, done
	blo 1$
	cmp stime+2,b		;low order part
	blo 1$			;not done yet
				;done, fall in to 8$
.endc
8$:	rest <c,b,a>
	sez			;no characters
	rts pc
9$:	rest <c,b,a>
	clz
	rts pc

;type out a help text, pointer to it in menusv
tmenu:	save <a,c,b>
	clr a
	clr b
	jsr pc,babsps		;set to zero, zero
	jsr pc,@clreol		;clear the top line
	mov menusv,b		;recover pointer to text
1$:	tst (b)			;at the end?
	beq 12$			;off the end of the menu
	mov b,a			;save pointer to menu item
	add #menuoh,b		;skip menu item header
	cmp #menuti,(a)		;title?
	bne 2$			;nope
	jsr pc,.crlf		;return the carrige
	br 8$			;and print it
2$:	tst prtspc		;special?
	beq 5$			;nope
	blt 3$			;if < 0 do only insert commands
	bit #menuio,(a)		;is it insert only?
	beq 5$			;nope, print it
	br 11$			;yes, ignore it
3$:	tst menuir(a)		;is there a an insert routine?
4$:	beq 11$			;nope, skip it
5$:	cmp #35.,carpos		;is the cursor at < 35?
	blo 6$			;nope
	save <a,b>
	mov linpos,a		;the line we are on
	mov #37.,b		;chara to go to
	jsr pc,babsps
	rest <b,a>
	br 7$
6$:	jsr pc,.crlf
7$:	jsr pc,.space
	jsr pc,.space
8$:	jsr pc,htype
	tst menuvp(a)		;is there a variable print routine?
	beq 9$			;nope
	jsr pc,.space		;type a space
	jsr f,acsav
	jsr pc,@menuvp(a)	;go print the variable
	jsr f,acres
9$:	cmp #menuti,(a)		;was it a title?
	bne 10$			;nope
	mov #40.,carpos		;kludge to force cr
10$:	dec b			;go back to the zero
11$:	tstb (b)+
	bne 11$			;find the end of the string
	inc b			;do a .even
	bic #1,b
	br 1$			;and type the next menu item
12$:	jsr pc,scrfls		;clobber the whole screen
	jsr pc,@eosclr		;clear to the end of the screen
	jsr pc,ttyfls		;make sure the screen gets updated
	rest <b,c,a>
	rts pc

;type a character in c on the screen
;clobbers the screen image to indicate we don't know what's there
htyo:	save a
	tst carpos		;are we at pos zero?
	bne 1$			;nope
	jsr pc,@clreol		;clear out the lien before typing on it
1$:	cmp #15,c		;carrige return?
	beq 4$
	cmp #12,c		;linefeed?
	beq 3$			;ignore
	mov carpos,a		;current character positon
	add #2,a		;this will be the new one, leave room for !
	cmp a,numcar		;fit on the line?
	bne 2$			;yup
	save c
	mov #rgtchr,c		;mark the continuation
	jsr pc,@typec		;call typec directly to avoid a loop
	mov #15,c		;return the carriage
	jsr pc,@typec
	rest c
2$:	jsr pc,@typec		;type the character
3$:	rest a
	rts pc

4$:	jsr pc,@typec		;type the cr
	mov #12,c
	jsr pc,@typec		;type a lf
	br 3$			;done

;ring the terminal bell
bell:	save c
	mov #7,c
	jsr pc,@typec
	jsr pc,ttyfls		;make sure it gets out
	rest c
	rts pc

.space:	save c
	mov #40,c
	jsr pc,htyo
	rest c
	rts pc

.tab:	jsr pc,.space
	bit #7,curcar
	bne .tab
	rts pc

.crlf:	save c
	mov #15,c
	jsr pc,htyo
	rest c
	rts pc


;get a string into the array "string". If the user pauses more than f/60 seconds call
;the routine in e. Return with an asciz string in string, terminating character in a

strget:	mov #40,strtrc		;if we enter her we terminate with a space
strge2:	save d
	mov #string,d
	clr (d)			;clobber old string
	mov d,strech		;so it will be echoed
strge1:	jsr pc,dstat		;always display status
	save <c,b,f>		;save the other registers
1$:	mov (p),f		;recover possibly clobbered f
	jsr pc,ptyip		;character?
	beq 12$			;nope
2$:	jsr pc,getkey		;get a key
	jsr pc,getnam		;get it's name
	cmp strtrc,a		;space?
	beq 7$			;that's a terminator
	cmp #chrnrm,f		;just normal character?
	beq 3$			;yup
	cmp #chrfsw,f		;accents are normal too
	bne 6$			;nope
3$:	sub #string,d		;get the character count
	cmp maxstl,d		;is it more than the max allowed?
	bhi 4$			;nope
	add #string,d		;fix it
	jsr pc,bell		;ring the bell
	br 1$			;and loop back
4$:	add #string,d
	movb a,(d)+		;save in the string
	clrb (d)		;terminate string
5$:	jsr pc,tyip		;another already?
	bne 2$			;yup
	jsr pc,dstat		;nope, update status
	br 1$

6$:	cmp #chrdel,f		;rubout?
	beq 10$			;yup
	cmp #chrqui,f		;quit character
	beq 11$			;yup
7$:	tstb string		;anything typed?
	bne 9$			;yup
	mov defstr,b		;get the default string
	beq 9$			;none
	mov #string,c
8$:	movb (b)+,(c)+		;move the default string in
	bne 8$
	jsr pc,dstat		;get the string displayed
9$:	clr defstr		;flush any old default string
	clr strech		;don't redisplay on next status update
	rest <f,b,c,d>
	rts pc

10$:	cmp #string,d		;at beggining?
	beq 1$			;do nothing
	clrb -(d)		;flush last character
	br 5$			;redisplay

11$:	jsr pc,@quitrt		;call the quit routine, whatever it is
;if it return just fall through to ignore the quit

12$:	tst e			;prompt routine?
	beq 1$			;nope
	jsr pc,(e)		;call it
	clr e			;but not twice
	br 1$

;continue a string get that was broken
strgec:	save d
	mov #string,d		;pointer to the partial string
	mov d,strech		;so it will be echoed
1$:	tstb (d)+		;find the end
	bne 1$
	dec d			;point at the zero
	br strge1

;reset the whole world
reseta:	jsr pc,kilbuf		;flush the buffer
.if z rt11
	jsr pc,incls		;close any input file
	jsr pc,outcls		;close any output file
.endc
	jsr pc,mreset		;reset the entry modes
;	jsr pc,kreset		;reset all user defined keys
.iif nz prtnum,	jsr pc,preset	;reset the printer stuff
	rts pc

.if nz prtnum
;reset all print modes to the defaults
preset:	mov #prtmdm,f		;printer mode menu
	br mrese1
.endc

;reset all the entry modes to the defaults
mreset:	mov #emodem,f		;gobble the menu pointer
mrese1:	mov menuvr(f),b		;pointer to the menu variable
	beq 1$			;no variable
	mov menud1(f),(b)+	;set the defauult
1$:	jsr pc,getnmi		;move a to next menu item
	bne mrese1		;loop if not at end
	rts pc

getnmi:	add #menuoh,f
3$:	tstb (f)+
	bne 3$
	inc f
	bic #1,f		;do a .even
	tst (f)			;at end?
	rts pc

;general print number routine
;call with a clear, number to be printed in b
;minimum number of digits to print in c
;and radix to print in (=< 10.) in d
prn:	div d,a
	save <b,#prndig>
	mov a,b
	clr a
	dec c
	bgt prn
	tst b
	bne prn
	rts pc		;return to prndig

prndig:	rest c		;digit to print
	add #60,c
	jmp htyo
	
;print a decimial number in d with at least 2 digits
zprdn:	save c
	mov #2,c	;at least 2 digits
	br prdn2

;print a decimial number in d with at least 3 digits
xprdn:	save c
	mov #3,c	;at least 3 digits
	br prdn2

prdn:	save c
	clr c
prdn2:	save <a,b,d>
	mov d,b
1$:	mov #10.,d
	clr a
prdn1:	jsr pc,prn
	rest <d,b,a,c>
	rts pc


;print the decimal value of a menu variable
mprtnm:	mov @menuvr(a),d	;get the value
	jsr pc,prdn		;print it
	rts pc

;accept a decimal number from the status line and set it into the variable
msetnm:	save f			;for later
	jsr pc,mgetnm		;get a number
msetn1:	rest f
	mov b,@menuvr(f)
	rts pc

.if nz prtnum
;Accept a measurement and set the variable to it
msetms:	save f
	jsr pc,mgetms
	br msetn1
.endc

;Get an integer from the loser
mgetnm:	clr e			;no prompt
	mov #5,maxstl		;don't want the number too long now, do we?
	jsr pc,mstrgt		;get the string
	mov #strarg,a		;pointer into string
	jsr pc,parsnm		;parse a number
	tstb -1(a)		;was the terminator the end of the string?
	bne 1$			;nope
	rts pc			;yup, got number

1$:	badarg

parsnm:	clr b			;accumlate number here
1$:	movb (a)+,c		;get a character
	beq 2$
	sub #60,c
	blt 2$
	cmp #9.,c
	blo 2$			;illegal character
	mul #10.,b		;old thing gets shifted
	bcs 3$			;overflow?
	add c,b
	bcs 3$			;overflow?
	br 1$

2$:	rts pc

3$:	badarg

;print the value of a yes-no menu variable
mprtyn:	mov #nostr,b		;assume no
	tst @menuvr(a)		;yes or no?
	beq 1$			;no
	mov #yesstr,b
1$:	jsr pc,htype
	rts pc

;Set the show fixed spaces flag
msetsf:	jsr pc,scrfls		;so the screen will get redisplayed
;set the value of a yes-no menu item
msetyn:	jsr pc,mgetyn		;get a yes or no answer
	mov c,@menuvr(f)	;set the variable
	rts pc			;and return

mgetyn:	jsr f,acsav
	clr e
	mov #3,maxstl		;maximum string is 3 characters
	jsr pc,mstrgt
	mov #yes,c
	jsr pc,getnam		;get the name of the terminator key
	cmp #chryes,f		;was it terminated by a yes?
	beq 3$			;yup
	cmp #chrno,f		;how about a no?
	beq 2$			;yup
	mov #yesstr,b		;pointer to yes
	jsr pc,mgetsc		;do a string compare, set z if true
	beq 3$
	mov #nostr,b
	mov #no,c
	jsr pc,mgetsc		;likewise for no
	beq 3$
	badarg			;not yes or no (or oui or non, depending on frp)

2$:	mov #no,c
3$:	mov c,4(p)
	jsr f,acres
	rts pc

mgetsc:	mov #strarg,a		;pointer to the string
1$:	cmpb #40,(a)+		;skip spaces
	beq 1$
	cmpb #fixchr,-1(a)	;was it fixed space?
	beq 1$
	dec a
mgets1:	movb (a)+,d		;from the user's string
	movb (b)+,e
	sub d,e			;difference
	beq 2$			;same
	cmpb #'A,d		;is it probably alphabetic?
	bhi 1$			;nope, definitly not
	cmp #40,e		;same except for case?
	beq 2$			;yup
	cmp #-40,e
	beq 2$
1$:	rts pc			;not the same, return with z clear

2$:	tstb (a)		;end of the user's string?
	bne mgets1		;not yet
	rts pc			;return with z set

;frobs that need special routines
;this stuff is here becuase it is a special case of yes/no
;set/reset shift lock
msetsl:	jsr pc,msetyn		;set the variable
msets1:	clr slstat		;clear the status line
	tst shtlck		;is shift locked?
	beq 1$			;nope, fine
	mov #slmes,slstat	;set it in the status line
1$:	rts pc

;shift lock complement
chrshl:	mov #yes,a		;the yes bit
	xor a,shtlck		;complement it
	br msets1		;set the status line

.if nz prtnum
;set the mode to justify
msetju:	mov #yes,prfilm		;turn on fill
	br msetc1		;clear everything else and set justify

;set center or right or left mode
msetcn:	clr prfilm		;clear fill
msetc1:	clr prlftm		;clear left
	clr prcenm		;clear center
	clr prrgtm		;clear right
	clr pradjm		;clear justify
	mov #yes,@menuvr(f)	;set center or right
	rts pc

;set the interline spacing
msetis:
;set the text length
msettl:	jsr pc,msetms		;do the regular thing
	clr a
	mov pitlen,b		;get the new length
	div plinis,a		;divide by the interline spaceing
	mov a,plinpp		;and set the lines per page
	rts pc

;set the lines per page
msetlp:	jsr pc,msetnm		;set it normally
	clr a
	mov pitlen,b		;get the text length
	div plinpp,a		;divide by the new lines per page
	mov a,plinis		;gives the new interline spacing
	rts pc

;Start a quotation => half the interline, reduce text width
prstqu:	tst splini		;already quoteing?
	bne 1$			;yup, loser
	mov plinis,splini	;save interline
	mov pitwid,spitwi	;save text width
	asr plinis		;half the interline
	mov pitwid,a		;get the text width
	ash #-3,a		;get 12.5% of the line width
	sub a,pitwid		;reduce width by that much
1$:	rts pc

;End quote by restoring old frobs
prenqu:	tst splini		;anythign to restore?
	beq 1$			;nope
	mov splini,plinis	;restore interline
	mov spitwi,pitwid	;restore text width
	clr splini		;clear flag
1$:	rts pc

;Get pitch
mgetpt:	jsr pc,mgetnm		;get a number
	cmp #10.,b		;is it 10?
	beq 1$			;yup
	cmp #12.,b		;how about 12?
	beq 1$
	badarg
1$:	rts pc

;set the pitch
msetpt:	save f
	jsr pc,mgetpt
	clr c
	mov #1000.,d		;one inch
	div b,c
	mov c,pihinc		;the width of a character
	jmp msetn1
.endc ;prtnum

mstrgt:	tst strarg		;is there already an strarg?
	bne 1$			;yes, just return
	mov #-1,strtrc		;don't terminate on a space
	jsr pc,strge2		;get a string from the tty
	jsr pc,quread		;quit on illegal terminator
	save <a,b>
	mov #string,a		;pointer to input string
	mov #strarg,b
2$:	movb (a)+,(b)+		;copy
	bne 2$
	rest <b,a>
1$:	rts pc

.if nz prtnum
;Print a measurement value, in the current units.
;All units internally are in 1/1000'ths of inches. However, if the
;units are set to metric these are typed out in centimeters.
mprtms:	mov @menuvr(a),d	;the low order part
mprtm1:	clr c			;the high order part
	tst prmetm		;metric?
	bne mprtmm		;print metirc
mprtme:	div #1000.,c		;get the inches in c and the thous in d
	save d
	mov c,d			;the inches
	jsr pc,prdn		;print
	mov #'.,c		;decimal point
	jsr pc,htyo
	rest d
	jsr pc,xprdn		;print with 3 digits
	mov #inches,b
	jsr pc,htype
	rts pc

mprtmm:	mov d,c			;get the thous
	mul #254.,c		;gets us cm X 1000. X 1000.
	div #1000.,c		;gives us cm X 100. in c
	cmp #500.,d		;we will round up
	bgt 1$
	inc c
1$:	mov c,d
	clr c
	div #100.,c		;gives use cm in c and 1/100 cm in d
	save d
	mov c,d			;the cm
	jsr pc,prdn		;print
	mov #'.,c		;decimal point
	jsr pc,htyo
	rest d
	jsr pc,zprdn		;print with 2 digits
	mov #cm,b
	jsr pc,htype
	rts pc

;Get a measurement. If it isn't specified to be in or cm it is assumed
;to be whatever the current defualt for printing is
mgetms:	clr e
	mov #10.,maxstl		;maximum string is 10 characters
	jsr pc,mstrgt		;go gobble a string
	mov #strarg,a		;the beg of the string
4$:	cmpb #40,(a)+		;space?
	beq 4$			;yup, flush it
	cmpb #fixchr,-1(a)	;fixed space?
	beq 4$
	dec a			;back to non-space
	jsr pc,parsnm		;get the first part
	save b			;this is the high order part
	save #0			;this is the low order part
	cmpb #'.,-1(a)		;decimal point?
	bne 2$			;nope, somthing else
	save a			;to count digits
	jsr pc,parsnm		;termianted by decimal point, get low order part
	mov a,c			;terminator
	sub (p)+,c		;number of digits in low order part
	sub #3+1,c		;we want three
	beq 1$			;ok
	bgt mgetbd		;too many
5$:	mul #10.,b		;add a digit
	inc c
	bne 5$
1$:	mov b,(p)		;stuff in the low order part
2$:	dec a
3$:	mov a,f			;save this pointer
	tstb (a)		;go back to terminator
	beq mgtcmd		;get in current mode then
	cmpb #40,(a)+		;is there a space?
	beq 3$			;yup, skip it
	cmpb #fixchr,-1(a)
	beq 3$
	dec a			;go back to the non-space
	mov #inches+1,b		;is it inches?
	jsr pc,mgets1		;do a compare
	beq mgetin		;get inches then
	mov f,a			;get the pointer back
	mov #cm+1,b		;is it cm?
	jsr pc,mgets1
	beq mgetcm		;yup, get cms
mgetbd:	badarg

mgtcmd:	tst prmetm		;metric?
	bne mgetcm		;yup
mgetin:	mov 2(p),b		;the high order part
	mul #1000.,b		;make it into thousanths
	bcs mgetbd
	add (p)+,b		;total
	bcs mgetbd
	tst (p)+
	mov #inches,d		;WARNING! This is used by minsms!
	mov f,e			;and so it this
	rts pc

mgetcm:	mov (p)+,b		;get the low order part
	clr a
	div #10.,a		;make it .xx instead of .xxx
	rest b			;get the high order part
	mul #100.,b		;hundredths
	bcs mgetbd
	add a,b
	bcs mgetbd
	mov b,a
	mul #3937.,a		;get inches X 10000. X 100.
	div #1000.,a
	bvs mgetbd
	cmp #500.,b		;round the divide result up
	bgt 1$
	inc a
1$:	mov a,b
	mov #cm,d		;WARNING! This is used by minsms!
	mov f,e			;and so it this
	rts pc
.endc ;nz prtnum

.if nz prtnum
;Insert a pitch set command
minspt:	save @menuvr(f)		;save old value
	jsr pc,mgetpt		;get the value
	br minscm

;Insert an integer setting command
minsnm:	save @menuvr(f)		;save the old value
	jsr pc,msetnm		;get the new value
minscm:	rest @menuvr(f)		;restore the old value
minsc1:	mov #cmdchr,c		;the magic command character
	jsr pc,inschr		;insert it
	mov f,b
	add #menuoh,b		;pointer to the string
	jsr pc,minsst		;insert the string
	mov #strarg,b		;whatever the string was
	tstb (b)		;anything to insert?
	beq 1$			;nope
	mov #fixchr,c
	jsr pc,inschr		;insert a space
	jsr pc,minsst		;insert that
1$:	mov #cmdchr,c		;terminate with another comamnd char
	jsr pc,inschr
	rts pc

;Insert a command with no argument
minscn:	clr strarg		;no argument
	br minsc1		;insert it

;Insert the string pointer to by b into the buffer
minsst:	movb (b)+,c
	beq 3$
	cmpb #40,c		;regular space?
	bne 1$			;nope
	mov #fixchr,c		;translate to fixed space
1$:
.if nz frp
	jsr pc,frppre		;is it a prefix?
	bne 2$			;nope
	movb (b)+,c		;get next char
	jsr pc,frptrn		;translate it
2$:
.endc
	jsr pc,inschr
	br minsst
3$:	rts pc

;Insert a yes-no
minsyn:	save @menuvr(f)		;save the old one
	jsr pc,msetyn		;set the thing
	mov #strarg,a
	mov #yesstr,b		;assume yes
	tst @menuvr(f)		;yes or no?
	bne minsy1		;ok, yes
	mov #nostr,b		;no
minsy1:	movb (b)+,(a)+		;copy string
	bne minsy1
	br minscm		;insert it

;Insert a measurement command
minsms:	save @menuvr(f)		;save the old value
	jsr pc,msetms		;set the value
	mov d,b			;WARNING! This is set deep in mgetms
	mov e,a			;as is this
	br minsy1		;go copy the right measurment unit in
.endc ;prtnum

.if nz rt11
.sbttl file routines for RT11
chrfil:	mov #filep,a		;thing to prompt with
	mov #filehl,e		;thing to prompt with if he delays 
	jsr pc,dmenu		;do a standard menu thingy
	rts pc
















.endc ;nz rt11

.if z rt11
space:	.+2			;from here up is free space
.iff
	.limit
space=.-2
.endc

.if z lsi
.if nz sits
.=<.!17777>+1
.rept 8
.if nz .-140000
-1				;make sure we have some free space
.=.-2
.=.+20000			;kludge
.endc
.endr
.endc
.endc
spacey:
pass2=1
.end debug			;change to start some day
