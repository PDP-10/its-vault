.TITLE NETWRK			;MIT-XX Network -11 -*-MIDAS-*-


;126	Fixed to handle IN packets right on LCSNet wrt new addressing
;132	Fixed to do IN routing correctly
;133	First shot a fix of LNI hanging up
;134	Fix to have errors go to DDT
;135	Fixed bug in fix in 133
;136	Glitch catcher for no buffers on LNI queue
;137	Punt fucked CHAOS packets, printing subr, start list of things to do
;138	Found the infamous "I'm losing my buffers" bug (I hope..)
;139	Rear end at it again - CHAOS packet, type 17. Also label on wait loop
;140	Fix to string printing routine, added number printing
;141	Updated to reflect new hardware configuration
;142	First shot at not losing with multiple pkts to same guy
;143	Conditionalize to work for both XX's and EE's front ends
;	(defaults to XX's)
;144	Fix bug in checksum hack where it was losing the carry
;145	Fix lossage with LCSNet down, and to force packets when down
;146	Fixed Chaos packet-received bug where it was turning off rcvr
;	interrupts for every packet received.  Also turned "no buffer
;	available" into "slow" (software), so that status counts reflect
;	reality
;147	Add entry to IN routing tables for VII gateway
;148	?
;149	?
;150	Fix to bug in IN checksum routines with INC lossage, also
;	fixed bug in CHAOS code where bad packets from the -10
;	were getting thrown away and not acked
;151	Spurious debugging
;152	Likewise
;153	Fix where packets to subnet with no CHAOS routing info were getting
;	broadcast
;154	Spurious debugging
;155	Diked MUPPET and PUP support, many fixes to IN routing. Actually
;	throws out bad packets, does range checking on table lookups, etc
;156	Removed a final remnant of MUPPET support, added V4 header checking
;	and GGP ping ability
;157	OZ version. Fixed bug in CHAOS routing tables where non XX machine
;	had bogus length tables because of bad LLL entries, also bad initial
;	entry for gateway to EE. Removed LLL ARPA relay crap
;158	Added debugging code to look for bug with buffer lossage
;159	Upped number of CHAOS subnets
;160	Fixed complete lossage in change in 159 with bad costs
;161	Fixed infamous routing no-age bug, updated OZ configuration
;162	Fixed bogus delay algorithm in LNI
;163	Hopefully fixed another 11-losing-buffers screw when NFE is busy
;164	Updated to place OZ on new subnet
;165	Added serial line net and changed LNI address


; Things to do:
; Thow this piece of junk out and replace with new GW code
;
; Flush IN packets if they are bad (checksums?)
; Add support for MPW and thus IN on CHAOS net (obsolete already)
; Clean up conditionals so all combinations work
; V2LNI support
; Redo CHAOS to not have timer kludges


.ENABL	ISD			;Add in local symbols for debugging

CHAOSP==1			;Has CHAOSNET interface
DTEONP==1			;Turn on DTE code
DDTP==1				;Linking with DDT

;;;Site-dependent settings
.IF NDF XX			;For XX by default
	XX==1
	LCSNTP==1		;Has LCSNET interface
	EE==0
	OZ==0
	BESN = 5		;Subnet for back end
.ENDC

.IF NE EE			;For EE,
	LCSNTP==0		; no LCSNET interface
	OZ==0
	BESN = 13		; and this is our back-end subnet
.ENDC

.IF NE OZ			; For OZ
	LCSNTP==0		; Yaaah, team!
	EE==0
	BESN = 23		; Wicked witches of the west
.ENDC

.IF NE, DDTP
	.GLOBL DDT		; For known transfer address
	.GLOBL	D.ERRT, D.NXMT	; For setting up the error vectors
	.GLOBL	D.ILGT, D.BRK
.ENDC

.MACRO PUSH X
.IRP Y,<X>
	MOV Y,-(SP)
.ENDM
.ENDM

.MACRO POP X
.IRP Y,<X>
	MOV (SP)+,Y
.ENDM
.ENDM

.MACRO CALL X
	JSR PC,X
.ENDM

.MACRO RET
	RTS PC
.ENDM

PS==177776			;Why isn't this defined?

.MACRO MASK LEVEL
	PUSH PS
	MOV #<LEVEL>_5,PS
.ENDM

.MACRO UNMASK
	POP PS
.ENDM

.MACRO .IREPT N,BOD
.REPT N
BOD
.ENDR
.ENDM

;;;Format of internal buffer header
BUFNXT==0			;Link to next
BUFSRC==2			;Source of this buffer
 BUFFIN==377			;From internals
 BUFF10==0			;From the -10
 BUFF11==1			;From the -11
 BUFFCH==2			;From the CHAOSNET
 BUFFLN==3			;From the LNI
BUFSDV==3			;Source device for -10
BUFDST==4			;Destination for this buffer (e.g. cable address)
BUFDTA==6			;Buffer address (later in the buffer)
BUFDAT==10+4			;Start of data portion

;;;Format of data portion
BUFBCT==-4			;Byte (word) count of data portion
BUFTYP==-2			;Type
 BUFI11==-1			;Internal in -11
 BUFPKT==0			;Packet data
 BUFRQS==1			;Request status
 BUFHST==2			;Here's status
 BUFACK==3			;Packet disposed of
BUFDEV==-1			;"Device", i.e. network
 DTPCHA==0			;CHAOSNET
 DTPMUP==1			;MUPPET
 DTPINT==2			;INTERNET
 DTPPUP==3			;PUP (=MPPETH)

MSGLEN==576.			;Length of a message
LNIHDR==16			;Header needed for sending to LCSNET
MAXHDR==LNIHDR			;Maximum length of header to append on
BUFLEN==BUFDAT+MSGLEN+MAXHDR	;Size of a buffer
BSTRT==40000			;Buffer pool starts here

.SBTTL Low core

LOC0:

.IF NE, DDTP			; Allow DDT to get control in errors
	D.ERRT			; Bad interrupt
	7_5
	D.NXMT			; NXM
	7_5
	D.ILGT			; Illegal intruction
	7_5
	D.BRK			; BPT (and we got a lot of them, boss)
	7_5
.ENDC

	.BLKB 100-<.-LOC0>
	CLKINT			;Clock interrupt
	6_5

.IF NE,CHAOSP
CHINT0==270			;Address of chaosnet interrupt vector
	.BLKB CHINT0-<.-LOC0>
	CHAINT			;Chaosnet interrupt
	6_5			;Priority 6
.ENDC	;CHAOSP

.IF NE,LCSNTP
LNIIN0==400			;Address of LNI interrupt vector
	.BLKB LNIIN0-<.-LOC0>
	LNIINT			;LCSNET interrupt
	6_5			;Priority 6
.ENDC	;LCSNTP

.IF NE,DDTP
	.BLKB 600-<.-LOC0>	;Go to DDT if started at 600
	JMP DDT
.ENDC

DTINT1==770			;Address of DTE #1 interrupt vector
	.BLKB DTINT1-<.-LOC0>
	DTEINT			;DTE interrupt
	6_5			;Priority 6

	.BLKB 1000-<.-LOC0>	;Rest of program starts at 1000

.SBTTL Main program

;;; Initialize things
$START::MOV #BSTRT,R0		;Init free list
	MOV #FRELST,R1
	MOV #20.,R2		;Make 20 of them
10$:	MOV R0,@R1
	MOV R0,R1
	ADD #BUFLEN,R0
	SOB R2,10$
	CLR @R1			;Mark the end of the list

.IF NE,DTEONP
	MOV DTECSR,R0
	MOV #INT11C,(R0)	;Clear -11 doorbell
20$:	BIT #TO11DB,(R0)	;Got doorbell?
	BEQ 20$			;No, wait for it
	CALL DTEINI		;Yes, can now read data
	BCS INIERR
	BIS #MCBINI,STSTT	;In initialization phase
	CALL SNDSTT		;Tell -10 that
	BIC #MCBINI,STSTT	;No longer in initialization
	MOV #INT11C!TO10DB,@DTECSR	;Ring doorbell
	INC TO11BF		;Flag as not needing buffer
.ENDC

	MOV #100,@#CLKCSR	;Enable clock interrupts

.IF NE,CHAOSP
	MOV CHAMYN,MYCHAD	;Get my address from interface
	MOV CHAMYN,CHAADR
	MOVB #BESN,CHAADR+1	;Form his address on the DTE subnet
	BIS #CHSREN,CHACSR	;Turn on chaos receiver interrupts
.ENDC	;CHAOSP

.IF NE,LCSNTP
	CALL LNIINI
.ENDC	;LCSNTP

WTLP:	WAIT			;Just let things happen
	BR WTLP

INIERR:	BPT

;;; Allocate a new buffer, source in R3, returned in R1
GETBUF::MOV FRELST,R1		;Get head of free list
	BEQ 10$
	MOV @R1,FRELST		;Unlink it
	MOV R1,R2
	CLR (R2)+		;Clear link
	MOV R3,(R2)+		;Save source
	ADD #LNIHDR+BUFDAT-BUFDST,R2	;Point to start of data
	MOV R2,BUFDTA(R1)
10$:	RET

;;; Free a buffer after sending complete, address in R1
FREBUF::PUSH <@R1>		;Save forward link
	CLR (R1)		;Clear it
	TSTB BUFSRC(R1)		;Really a buffer?
	BMI 10$			;Nope
	MOV FRELST,@R1		;Return to free list
	MOV R1,FRELST
10$:	TSTB BUFSRC(R1)		;Came from the -10?
	BNE 30$			;No, no ack needed
	MOV BUFSRC(R1),R3	;Get device in high byte
	BIS #BUFF11,R3		;Mark new source as internal
	CALL GETBUF		;Allocate a buffer
	CLR BUFBCT(R2)		;No data bytes
	MOVB BUFSDV(R1),BUFDEV(R2)
	MOVB #BUFACK,BUFTYP(R2)
	CALL TOTENQ		;Queue it to the -10
20$:	POP R1			;Return old forward link
	RET

30$:
.IF	NE, DTEONP
	TST TO11BF		;Left needing a buffer?
	BNE 31$			;No, try next guy
	MOV TO11ND,R4		;Restore number of bytes needed
	MOV #DTEADR,R0		;163 GETT11 assumes r0 set up
	CALL GETT11		;And start a tranfer
	BR 20$
.ENDC	; DTEONP
31$:
.IF	NE, LCSNTP
	TST LNIIBF		;Left needing a buffer?
	BNE 32$			;No, try next guy
	MOV #LNIADR,R0		;F***ing LNISIP wants this here
	CALL LNISIP		;And start a tranfer
	BR 20$
.ENDC	; LCSNTP
32$:
	BR 20$


.SBTTL Routines to print things on the console

;;; DL interface register bits
DLRCSR==177560
DLRBUF==177562
DLTCSR==177564
DLTBUF==177566
DONE=200

;;; Called with R0 pointing to an ASCIZ string.

PRF:	TSTB @R0			; End of the string?
	BNE 1$				; Yup, punt
	RET
1$:	BIT #DONE,@#DLTCSR		; Xmttr done?
	BEQ 1$
	MOVB (R0)+,@#DLTBUF		; Yup, zap out char
	BR PRF

;;; Called with R0 containing a number to be printed in octal

PRN:	PUSH <R1,R2>
	MOV #6,R2			; Six digits max

PRNLP:	MOV R0,R1			; Get remainder mod 8
	BIC #-10,R1
	ADD #60,R1			; Convert to ASCII digit
	PUSH R1				; and save it
	.IREPT 3,<ASR R0>		; Divide by 8
	DEC R2				; Last digit?
	BNE 1$				; Yup, type out
	BIC #6,@SP			; Patch last digit to 1
	BR PRNTP
1$:	TST R0				; No bits left?
	BEQ PRNTP			; Also typing time
	CALL PRNLP			; Call self recursively

PRNTP:	BIT #DONE,@#DLTCSR		; Printer done?
	BEQ PRNTP
	POP @#DLTBUF			; Yup, print char
	INC R2
	CMP R2,#6			; Done?
	BNE PRNTC			; No, next char
	POP <R2,R1>			; Yup, pop regs and punt
PRNTC:	RET



.SBTTL DTE pseudo-subnet to -10

;;; DTE definitions
DTE0==174400			;Address of first DTE
DTE1==DTE0+40			;Address of the DTE to use

;; DTE protocol word offsets
;PIDENT=0			;Processor identification word
;CHNPNT=1			;Pointer to comm area of next processor (circ list)
;CYCLS=2			;Clock cps count
;TOD=3				;Time of day
;DATE=4				;Date
PSWW1=5				;Processor status word1 (keep alive)
;PSWW2=6			;Processor status word2
;PSWW3=7			;Processor status word3
;PSWW4=10			;Processor status word4
;PSWW5=11			;Processor status word5
;PSWW6=12			;Processor status word6
;PSWW7=13			;Processor status word7
;PSWW10=14			;Processor status word10
;PSWW11=15			;Processor status word11
;PSWW12=16			;Processor status word12
;PSWW13=17			;Processor status word13
FORPRO=20			;For processor identificaton word
PROPNT=21			;Pointer to comm area of the processor assoc with this block
STATUS=22			;Communication status word
QSIZE=23			;Queue size word
;CTY0CW=24			;CTY #0 command word
;CTY0RW=25			;CTY #0 response word
;CTY1CW=26			;CTY #1 command word
;CTY1RW=27			;CTY #1 response word
;MISCW=30			;Miscellaneous command word for non-queue protocol
;MISRW=31			;Miscellaneous response word
;UNASG1=32			;Unassigned word1
;UNASG2=33			;Unassigned word2
;UNASG3=34			;Unassigned word3
;UNASG4=35			;Unassigned word4
;UNASG5=36			;Unassigned word5
;UNASG6=37			;Unassigned word6

;; DTE protocol status definitions
TOIT=1				;In process of processing queue
TOIP=2				;To him indirect in progress
TOBM=4				;To him word mode requested
MCBINI=2			;Init bit for MCB protocol
LOAD11=4			;Load eleven
KLPWRF=10			;KL is powerfailing

;; DTE registers
DLYCNT=0			;Delay counter
;BUSA17=100000			;Unibus address bit 17
;BUSA16=040000			;Unibus address bit 16
;DLYMSK=037777			;Delay counter
DEXWD3=2			;Deposit/examine word 3
DEXWD2=4			;word 2
DEXWD1=6			;word 1
TENAD1=10			;-10 memory address 1
;PHYS=100000			;Physical address
;XUPT=040000			;Via UPT
;EXVIRT=020000			;Exec virtual address
;USEVIR=060000			;User virtual address
DEP=010000			;Deposit
;PRTOFF=004000			;Protection off
;XEPT=0				;Via EPT
TENAD2=12			;address 2
TO10BC=14			;To -10 byte count
TO11BC=16			;To -11 byte count
 TO11IB=100000			;Interrupt both -10 and -11 when done
;ZSTOP=040000			;Stop on null byte
 TO11BM=020000			;To -11 byte mode
 TO11CM=007777			;Byte count
TO10AD=20			;To -10 address
TO11AD=22			;To -11 address
TO10DT=24			;To -10 data word
TO11DT=26			;To -11 data word
DIAG1=30			;Diagnostic control register 1
;DS00=100000			;Diagnostic status (W)
;DS01=040000
;DS02=020000
;DS03=010000
;DS04=004000
;DS05=002000
;DS06=001000
;DFUNC=000200			;Doing diagnostic function (W)
;D1011=000040			;Interface diagnostic mode (W)
;PULSE=000020			;Single pulse 10/11 clock (W)
;DIKL10=000010			;KL10 diagnostic mode (W)
;DSEND=000004			;Send the EBUS during diagnostic fcn (W)
;DCSRT=000001			;Diagnostic command start (W)
;ERRSTP=004000			;EBOX stopped by error
;KLRUN=002000			;KL is running (R)
;HALTLP=001000			;KL in halt loop (R)
;DEX=000400			;Deposit/examine in progress (R)
;TO10=000200			;Doing to -10 transfer (R)
;TO11=000100			;Doing to -11 transfer (R)
;VECO4=000020			;Vector interrupt address bit 4 (R)
;VECO3=000010			;bit 3 (R)
;VECO2=000004			;bit 2 (R) 
DIAG2=32			;register 2
;EDONES=040000			;Set EBUS done (W)
;DRESET=000100			;DTE20 reset (W)
STAT=34				;Control status register
 TO10DN=100000			;To -10 transfer done (R/W)
 DON10C=040000			;Clear to -10 done (W)
 TO10ER=020000			;To -10 transfer error (R/W)
 ERR10C=010000			;Clear to -10 error (W)
;RAMIS0=010000			;Data out of ram is all 0 (R)
 TO11DB=004000			;To -11 doorbell (R/W)
 INT11C=002000			;Clear to -11 doorbell (W)
;DXWRD1=002000			;Deposit/examine word one (R)
;PERCLR=001000			;Clear -11 MPE (W)
;D11MPE=001000			;-11 MPE (R)
 TO10DB=000400			;To -10 doorbell (R/W)
 TO11DN=000200			;To -11 transfer done (R/W)
 DON11C=000100			;Clear to -11 transfer done (W)
;EBSEL=000100			;E buffer select (R)
 INTRON=000040			;DTE interrupt on (W)
;NULSTP=000040			;Null stop (R)
;EBUSPC=000020			;Clear EBUS parity error (W)
;BPARER=000020			;EBUS parity error
 INTROF=000010			;DTE interrupt off (W)
;RSMODE=000010			;Restricted mode (R)
;EBUSPS=000004			;Set EBUS parity error (W)
 DEXDON=000004			;Deposit/examinne done (R)
 TO11ER=000002			;To -11 transfer error (R/W)
 ERR11C=000001			;Clear to -11 error (W)
 INTSON=000001			;Interrupts on (R)
DIAG3=36			;register 3
;SCD=000040			;Shift parerr data (W)
;CDD=000020			;Clear DUPE and DURE error flags (W)
;WEP=000010			;Write even (bad) parity (W)
;CNUPE=000002			;Clear NUPE (W)
 TO10BM=000001			;To -10 byte mode (W)
;SWSLFT=100000			;Swap select left (R)
;CAB08=040000			;Captured unibus address bit 8 (R)
;DUPE=000020			;DATO unibus parity error (R)
;DURE=000004			;DATO unibus receiver error (R)
;NUPE=000002			;NPR unibus parity error (R)
;UPECD=037000			;Unibus parity error, captured data (R)

;;; DTE interrupt routine
DTEINT::PUSH <R0,R1,R2,R3,R4,R5>

INTLPS:	MOV DTEADR,R0		;Point to our DTE
	BIT #TO10DN!TO10ER,@DTECSR	;Done to -10 or error?
	BNE TOTNDN		;Yes, handle that
	BITB #TO11DN!TO11ER,@DTECSR	;Done to -11 or error?
	BNE TOELDN		;Yes, handle that
	BIT #TO11DB,@DTECSR	;No tranfers, check for doorbell
	BNE DBLRNG		;Doorbell rang

INTRET:	POP <R5,R4,R3,R2,R1,R0>
	RTI

;;; To -10 done interrupt
TOTNDN::BMI 10$			;Was it an error?
	BPT			;Yes, handle that cleverly
10$:	MOV #DON10C,@DTECSR	;Clear done flags
	MOV TENLST,R1		;Get top of queue
	CALL FREBUF		;Free it
	MOV R1,TENLST		;New end of queue
	BEQ INTLPS		;None, return
	CALL TOTNSQ		;Start next to -10 queue
	BR INTLPS		;Back to check on other things

;;; To -11 done interrupt
TOELDN::BMI 10$
	BPT			;Error
10$:	MOV #DON11C,@DTECSR	;Clear done flags
	MOV TO11BF,R1		;Get buffer used
	MOV BUFDTA(R1),R2	;Point to data portion
	MOVB BUFTYP(R2),R3	;Get message type
	BNE 20$			;Is it a packet?
	ADD #1,NPKTNR		;Yes, one more packet from the -10
	ADC HPKTNR
20$:	MOVB BUFDEV(R2),R4	;Get device type
	MOVB R4,BUFSDV(R1)	;Save device
	ASL R3			;Make word index
	ASL R4
	ADD NETTBL(R4),R3	;Point to device table
	CALL @(R3)		;Call device routine
	BR INTLPS

;;; Network dispatch for messages from the -10,
;;; points to type dispatches
NETTBL:	CHATBL			;0 CHAOSNET
	ILLNET			;1 MUPPET
	INTTBL			;2 Internet
	ILLNET			;3 PUP
.IREPT 3,ILLNET			;Just in case

ILLNET:	.IREPT 4,ILLMSG		;For undefined network

ILLMSG::BPT

;;; Doorbell interrupt
DBLRNG::CLR TENAD1(R0)		;Prepare to read his status
	MOV #STATUS-FORPRO,R2
	ADD DTEHSM,R2
	MOV R2,TENAD2(R0)
	CALL WFED
	BCS 20$
	MOV DEXWD1(R0),STATI
	MOV DEXWD2(R0),STATI+2
	MOV DEXWD3(R0),STATI+4
	TST STATI		;Valid examine?
	BNE DBLSTS
20$:	BPT

DBLSTS:	BIT #16,STATI		;-10 crashed or something?
	BEQ 10$
	BPT
10$:	CMPB STATI+4,TO10QC	;Count the same as last time?
	BNE 20$			;No, something to do then
	BIS #TOIT,STSTT+2	;Else just send our status
	CALL SNDSTT
	MOV #INT11C!TO10DB,@DTECSR
	JMP INTLPS		;And process some more interrupts
20$:	BIS #TOIT,STSTT+2
	INCB TO10QC		;Increment count
	CMPB STATI+4,TO10QC	;Same now?
	BEQ 30$
	BPT			;No, something messed up
30$:	CALL SNDSTT		;Send our status
	MOV #INT11C,@DTECSR
	MOV #QSIZE-FORPRO,R2
	ADD DTEHSM,R2
	CLR TENAD1(R0)
	MOV R2,TENAD2(R0)
	CALL WFED
	BCS 40$
	MOV DEXWD3(R0),R4	;Get queue size
	CMP DEXWD2(R0),R4	;Sent all in one piece?
	BEQ 50$			;Yes, all ok
40$:	BPT
50$:	CALL GETT11		;Start to -11 transfer
	JMP INTLPS

;; Start a transfer to the -11 if there is a buffer, else setup to try
;; when one is freed.  Byte count needed in R4
GETT11:	CLR R3			;From the -10
	CALL GETBUF		;Get a buffer from the free pool
	MOV R1,TO11BF		;Save address
	BEQ 20$			;None left, -10 run wild
	ADD #0,R2		;Reserve room for additional headers
	MOV R2,BUFDTA(R1)	;Save it
	SUB #-BUFBCT,R2		;-10 stores starting at  byte count
	MOV R2,TO11AD(R0)	;-10 starts storing with byte count
	ASR R4			;Make count of words
	NEG R4			;Make count negative
	BIC #^C<7777+TO11IB>,R4
	MOV R4,TO11BC(R0)	;Start transfer
10$:	RET

20$:	MOV R4,TO11ND		;Save number of bytes for later
	BR 10$

;;; Send status to -10
SNDSTT::MOV #DEP,TENAD1(R0)
	MOV STSTT,DEXWD1(R0)
	MOV STSTT+2,DEXWD2(R0)
	MOV STSTT+4,DEXWD3(R0)
	MOV #STATUS-FORPRO,R2
	ADD DTEMYD,R2
	MOV R2,TENAD2(R0)	;Start transfer
	BR WFED

;;; Do deposit/examine from -10
;;; R0 has DTE pointer, R1 high order address, R2 low order address
;;; R3 pointer to block to move into
SWFED::	PUSH R3			;Save this just in case
	BIT #DEP,R1		;Deposit?
	BNE 10$
	MOV R1,TENAD1(R0)	;Transfer from -10
	MOV R2,TENAD2(R0)
	CALL WFED		;Wait for deposit/examine
	BCS 20$			;Failed
	MOV DEXWD3(R0),(R3)+	;Store what was transferred
	MOV DEXWD2(R0),(R3)+
	MOV DEXWD1(R0),(R3)+
	BR 20$			;And return

10$:	MOV (R3)+,DEXWD3(R0)	;Transfer to -10
	MOV (R3)+,DEXWD2(R0)
	MOV (R3)+,DEXWD1(R0)
	MOV R1,TENAD1(R0)
	MOV R2,TENAD2(R0)
	CALL WFED

20$:	POP R3			;Restore start of block
	RET

;;; Wait for a deposit/examine to finish
;;; R0 has address of DTE CC-C set if error
WFED::	MOV #3000,DEXST		;Nominal timeout
10$:	BIT #DEXDON,STAT(R0)
	BNE 20$			;Done, return
	DEC DEXST
	BNE 10$			;Keep waiting
	SEC
20$:	RET			;Return

;;; Initialize DTE protocol communication regions
DTEINI::MOV DTECSR,R0		;Point to DTE we'll use
	MOV #INT11C,(R0)	;Clear -11 doorbell
5$:	BIT #TO11DB,(R0)	;Got doorbell?
	BEQ 5$			;No, wait for it
	MOV #DON10C!INT11C!DON11C,(R0) ;Clear it
	MOV #DTE1,R0		;Now just point to DTE
	CLR R1			;Find the processor number
	CLR R2
	MOV #DEXTM3,R3		;Some temporary space
	CALL SWFED		;Do examine
	BCS 10$			;Error, return
	MOV @R3,R4		;Find offset to my R/W area
	MOVB @#DEXTM2+1,R2	;Get processor number
	BIC #177760,R2		;Clear junk
	MOV R2,PRMEMN		;Save it
	INC R2
	MOV R2,COMBSE		;Save base of communications area
	ADD R4,R2		;Offset to deposit area
	MOV R2,DEPOF		;Save that too
	CALL SWFED		;Wait for transfer
10$:	BCS 45$
	MOV @#DEXTM2,R5
	BIC #177770,R5
	SUB #2,R5
	PUSH <R2,R5>
15$:	ADD #FORPRO,2(SP)	;Look at communications area
	MOV 2(SP),R2
	CALL SWFED		;Wait for it
	BCS 45$
	MOV @R3,R4
	MOV #PROTBL,R5
	BIC #177770,R4
	BEQ 25$
20$:	ADD #5*2,R5
	SOB R4,20$
25$:	MOV @#DEXTM2,R4		;Number of 8 word blocks
	BIC #177770,R4
	SUB R4,@SP		;Update count
	CLR @R5			;Say no DTE at first
	MOV @#DEXTM1,R4		;Get DTE number
	BIT #4,R4
	BEQ 30$			;Not there, forget it
	SWAB R4			;Multiply by 40
	ROR R4
	ROR R4
	ROR R4
	BIC #177637,R4
	ADD #DTE0,R4
	MOV R4,@R5		;Save address of DTE
	MOV #37777,@R4		;Set delay counter
	MOV #INTRON,STAT(R4)	;Enable interrupts
30$:	MOV R2,EMYN(R5)		;Save address to examine in
	MOV R2,DMYN(R5)		;And deposit in ...
	SUB DEPOF,DMYN(R5)	;is less offset
	ADD #PROPNT-FORPRO,R2	;Read pointer to his comm area
	CALL SWFED
	BCS 45$
	MOV @R3,R2
	ADD COMBSE,R2
	MOV R2,EHSG(R5)		;Save it
	ADD #FORPRO,R2
35$:	CALL SWFED
	BCS 45$
	CMPB PRMEMN,@R3		;Same processor number?
	BEQ 40$			;Yes, found my entry
	MOV @#DEXTM2,R4
	BIC #177770,R4
	ASL R4
	ASL R4
	ASL R4
	ADD R4,R2		;Read next block
	BR 35$

40$:	MOV R2,EHSM(R5)		;Save it
	MOV @SP,R5
	BGT 15$			;Go do more if any
	CLC			;Say success
45$:	MOV (SP)+,(SP)+		;Flush garbage from stack
	RET			;Return


;;; CHAOSNET packet for the -10, maybe unpack it, then queue it there
TENSBN::CLR BUFTYP(R2)		;This is a CHAOSNET packet
	MOV BUFBCT(R2),R4	;Get word count
	CALL CHASWB		;Maybe swab the data portion
				;Fall through to queue a packet

;;; Queue an actual packet to the -10, address in R1
TENPKT::ADD #1,NPKTNS		;One more packet sent to -10
	ADC HPKTNS

;;; Queue something to the -10, address in R1
TOTENQ::MOV TENLST,R2		;Get head of queue
	BEQ 50$			;None, start this one right away
10$:	MOV R2,R3
	MOV @R2,R2
	BNE 10$			;Find the end of the list
	MOV R1,@R3		;Link new thing in
	RET
50$:	MOV R1,TENLST		;Fall thru to start this transfer

;;; Start sending to the -10, address in R1
TOTNSQ::MOV DTEADR,R0		;Point to appropriate DTE
	INCB STSTT+5		;One more in queue
	MOV BUFDTA(R1),R2	;Get data pointer
	MOV BUFBCT(R2),R4	;Get size
	ASL R4			;And make it a byte count
	ADD #-BUFBCT,R4		;Count for size and type
	SUB #-BUFBCT,R2		;Point to it also
	MOV R2,TO10AD(R0)	;Setup address
	MOV #2,DEXWD1(R0)	;Word mode transfer
	MOV R4,DEXWD2(R0)
	MOV R4,DEXWD3(R0)	;Store byte count
	MOV #DEP,TENAD1(R0)
	MOV #QSIZE-FORPRO,R2
	ADD DTEMYD,R2
	MOV R2,TENAD2(R0)
	CALL WFED
	CALL SNDSTT
	CLR DIAG3(R0)		;Ensure transfers will be word mode
	MOV #TO10DB,@DTECSR	;Ring up the -10
10$:	RET

;;; Internet packet for the -10
INTTEN::MOV #DTPINT*400,BUFTYP(R2)	;Type is internet
	BR TENPKT

;;; DTE storage

FRELST::.WORD 0			;Buffer free list

TENLST:	.WORD 0			;To -10 queue
TO11BF:	.WORD 0			;Current to -11 buffer
TO11ND:	.WORD 0			;Byte count needed for transfer and no buffers
KPALIV:	.BLKW 3			;Keep alive counter
KPALCN:	.WORD 5.*30.		;Time till keep alive increment
DEXST:	.WORD 0			;Timeout for waiting for DTE
DEXTM3:	.WORD 0			;Temporary storage for DTE setup
DEXTM2:	.WORD 0
DEXTM1:	.WORD 0
DTECSR:	DTE1+STAT		;CSR for the main DTE
STATI:	.BLKW 3			;-10 status
STSTT:	.WORD 1,0,0		;-11 status
TO10QC:	.WORD 0			;Count of transfers
COMBSE:	.WORD 0			;Base of communications area
PRMEMN:	.WORD 0			;Processor number
DEPOF:	.WORD 0			;Offset for deposit
PROTBL::.BLKW 16.*5		;5 Words per processor, max 16 processors
 DTENM==0			;Address of DTE
 EMYN==2			;Address to communiate (examine)
 DMYN==4			;(deposit)
 EHSG==6			;Address for general
 EHSM==10			;Address for specific
DTEADR=PROTBL			;Addresses we want for our main DTE
DTEMYE=PROTBL+EMYN
DTEMYD=PROTBL+DMYN
DTEHSG=PROTBL+EHSG
DTEHSM=PROTBL+EHSM
TNSBSB==.			;This is the data on the -10 subnet
NPKTNR:	.WORD 0			;Packets received from -10 (low)
HPKTNR:	.WORD 0			;Packets received from -10 (high)
NPKTNS:	.WORD 0			;Packets sent to the -10 (low)
HPKTNS:	.WORD 0			;Packets sent to the -10 (high)
TNSBSS==.-TNSBSB

.SBTTL Internet handling

IN.TYP==0			;Type  of service
IN.IHL==1			;Length of header
 INIHLM==017
IN.VER==1			;Internet version number
 INVERM==360
IN.LEN==2			;Length of whole datagram
IN.IDX==4			;Index
IN.FOF==6			;Fragment offset
 INFOFM==037777
IN.FLG==7			;Flags
 INFLGM==340
IN.PTC==10			;Protocol
IN.TTL==11			;Time to live
IN.CKS==12			;Header checksum
IN.SHH==14			;Source address high
IN.SHL==16			;Source address low
IN.DHH==20			;Destination address high
IN.DHL==22			;Destination address low
IN.OPT==24			;Beginning of options

PT.V4==100			;Version 4 (left shifted in byte)
PT.GGP==3			;GGP
GGP.EC==10			;GGP Echo packet
GGP.ER==0			;GGP Echo reply

NW.CHS==7			;CHAOSNET number
NW.LCS==22			;LCSNET number
NW.MYH==<<22 * 400> + 10>	;My IN address (high part in byte swapped form)
NW.MYL==<<0 * 400> + 40>	;My IN address (high part in byte swapped form)

INTTBL:	INTDAT			;Internet packet
	.IREPT 3,ILLMSG

;;; Internet packet from the -10
INTDAT::MOVB IN.DHH+1(R2),R3	;Get network it is addressed to
	CMP R3,#NW.CHS		;CHAOSNET?
	BEQ INTPKT
	CMP R3,#NW.LCS		;Or LCSNET
	BEQ INTPKT
	BPT			;Neither, back end blew it

;;; Handle internet packet from someplace
INTPKT::MOVB IN.VER(R2),R0	;Really IN V4?
	BIC #INIHLM,R0
	CMPB R0,#PT.V4
	BNE INBAD		;Nope, throw away

	DECB IN.TTL(R2)		;Dead yet?
	BNE 1$			;No, send it along
	BR INBAD		;Flush packet
1$:	ADD #400,IN.CKS(R2)	;Adjust checksum by adding 1 to left-half byte
	ADC IN.CKS(R2)		;and make it in 1's comp

	CMP IN.DHH(R2),#NW.MYH	;Is packet for me?
	BNE 4$			;Nope, process
	CMP IN.DHL(R2),#NW.MYL
	BNE 4$			;If for me, maybe it's a ping?
	CMPB IN.PTC(R2),#PT.GGP
	BNE INBAD		;Nope, throw away
	CMPB IN.OPT+1(R2),#GGP.EC	;Kludge way of checking first data byte
	BNE INBAD		;Not an echo request?
	MOVB #GGP.ER,IN.OPT+1(R2)	;F(*&ing swapped data....
	PUSH IN.DHH(R2)
	PUSH IN.DHL(R2)
	MOV IN.SHH(R2),IN.DHH(R2)
	MOV IN.SHL(R2),IN.DHL(R2)
	POP IN.SHL(R2)
	POP IN.SHH(R2)		; Needn't do chksum; header data same

4$:	MOVB IN.DHH(R2),R3	;Get destination subnet
	CMPB IN.DHH+1(R2),#NW.CHS	;CHAOSNET?
	BEQ 3$
	CMPB IN.DHH+1(R2),#NW.LCS	;Or LCSNET
	BEQ 3$
	CLR R3			;Neither, route to -10 by using subnet 0
3$:	MOV IN.LEN(R2),R4	;Length of packet
	INC R4
	ASR R4
	MOV R4,BUFBCT(R2)	;Store length
	CMP R3,#INTMAX		;Bad subnet number?
	BLO 2$
	BR INBAD		;Throw away
2$:	ASL R3			;This is the subnet or a fake to go to the -10
	MOV INTSBN(R3),R4	;Get right Internet transmission routine
	BNE 10$			;If one existed, send it off, otherwise forward
	MOV INTGW(R3),BUFDST(R1);Send packet to gateway host
	MOVB INTGW+1(R3),R3	;And get his subnet
	BEQ INBAD		;No gateway, punt
	ASL R3
	MOV INTSBN(R3),R4	;Once again, try for a routing routine
	BNE 11$			;Should be a routing entry for gateways, but..
	BR INBAD		;** BARF - can't get there from here

10$:	MOVB IN.DHL(R2),BUFDST(R1)	;Send to destination host
	MOVB IN.DHH(R2),BUFDST+1(R1)	;And subnet

11$:	JMP @R4			;Zap it on its way

INBAD::	CALL FREBUF
	TST R1			;158
	BEQ 1$			;158
	 BPT			;158
1$:	RET			;158

.SBTTL InterNet Routing tables
;;; All tables indexed by subnet number
;;; These tables will not work for any machine other than XX

;; Routing for internet packets
INTSBN::INTTEN			;0
	0			;1 Main Campus CHAOSNet
	0			;2 Tech Square EtherNet
	0			;3
	0			;4
	INTTEN			;5 XX DTENet
	0			;6 TS CHAOSNet
	0			;7
.IIF NE LCSNTP, INTLCS		;10 TS LCSNet
.IIF EQ LCSNTP, 0
	0			;11 Serial Line Net
	0			;12 TS VIILCSNet
	.IREPT 5,0		;13-17
	.IREPT 14,0		;20-33 LLL nets
	.IREPT 4,0		;34-37

	INTMAX = <.-INTSBN>/2

;; Gateways for internet packets
INTGW::	0			;0 - Error - shouldn't be looking here
	.BYTE 5,10		;1 - CSR Bridge (may have to fragment)
	.BYTE 5,10		;2 - CSR Bridge (avoid fragmentation)
	0			;3
	0			;4
	0			;5 - Err
	.BYTE 5,10		;6 - CSR Bridge
	0			;7
	0			;10 - Err
	.BYTE 5,10		;11 - CSR Bridge
	.BYTE 5,10		;12 - CSR Bridge
	.IREPT 5,0		;13-17
	.IREPT 14,0		;20-33
	.IREPT 4,0		;34-37



.IF NE,CHAOSP

.SBTTL Chaosnet

;Hardware registers
CHAEXP=164140			;External addr of chaos net interface
CHACSR=CHAEXP			;Command status register
 CHSRDN=100000			;Receive done
 CHSERR=040000			;Crc error
 CHSRST=020000			;I/O reset
 CHSTCL=000400			;Clear transmitter
 CHSTDN=000200			;Transmit done
 CHSTAB=000100			;Transmit aborted
 CHSTEN=000040			;Transmit interrupt enable
 CHSREN=000020			;Receive interrupt enable
 CHSRCL=000010			;Clear receiver
 CHSSPY=000004			;Receive-all
 CHSLUP=000002			;Loop-back
 CHSBSY=000001			;Transmit busy
CHAMYN=CHAEXP+2			;Host number for this interface
CHAWBF=CHAEXP+2			;Write buffer
CHARBF=CHAEXP+4			;Read buffer
CHARBC=CHAEXP+6			;Receive bit count
CHAXMT=CHAEXP+12		;Initiate transmission

PKMAX=256.			;Maximum length of packet in words
DATMAX=488.			;Maximum number of data bytes
PKNHDR=10			;Number of header words
PK.OP=1				;Opcode field
PK.NBT=2			;Word of number of bytes
 PKTNBT==170000
PK.FC=2				;Also for forward count
 PKTFC==7777
PK.DHS=4			;Destination host
PK.DIX=6			;Destination index
PK.SHS=10			;Source host
PK.SIX=12			;Source index
PK.PKN=14			;Packet number
PK.AKN=16			;Ack number
PK.DAT=20			;Start of actual data

;Packet opcodes
.CORFC=1			;Request for connect
.COOPN=2			;Open
.COCLS=3			;Close
.COFWD=4			;Forward
.COANS=5			;Answer
.COSNS=6			;Sense status
.COSTS=7			;Report status
.CORUT=10			;Routing info
.COLOS=11			;You are losing
.COLSN=12			;Listen (never used)
.COMNT=13			;Maintenance
.COMAX=14			;Maximum opcode+1
.CODAT=200			;First data opcode


CHATBL:	CHADAT			;Chaosnet data
	CHARQS			;Chaosnet request for status
	.IREPT 5,ILCMSG
	CHABDP			;F&^%ing back end again
	.IREPT 7,ILCMSG
	CHABDP			;F&^%ing back end again

;;; Back end is at it again...
ILCMSG:	BPT

;;; Chaos packet from the -10
CHADAT::CALL CHIHDR		;Process header

;;; Here with packet size all set up, figure out where it goes
CHAPKT::MOV BUFBCT(R2),R4	;Get word count
	CMP R4,#PKMAX		;Within limit?
	BHI CHAPKF		;No, flush it
	TSTB BUFSRC(R1)		;Did this come from the -10?
	BNE 10$			;No, dont swab it
	CALL CHASWB		;Swab the data portion maybe
	MOV BUFDTA(R1),R2	;Point to actual data again
10$:	MOVB PK.DHS+1(R2),R3	;Get destination subnet
	BMI CHAPKF		;Range check it
	CMP #SBNMAX,R3
	BLE CHAPKF
	ASL R3
	MOV SBNRUT(R3),R4	;Get correct routing method
	BEQ CHASBN		;Foreign chaosnet subnet
	JMP @R4			;Call it

;;; Here is a packet looks like garbage
CHAPKF:	CALL FREBUF		;Free with routine which will ack from -10
	TST R1			;158
	BEQ 1$			;158
	 BPT			;158
1$:	RET			;158

;;; The back end sent us another garbage packet. Throw
;;; it on the floor, after bitching.
CHABDP:	MOV #10$,R0
	CALL PRF
	MOVB BUFTYP(R2),R0
	CALL PRN
	BR CHAPKF

10$:	.ASCIZ /Bad CHAOS pkt from -20, type=/
	.EVEN

;;; Here for a packet addressed to a local chaosnet subnet,
;;; see if it for the -11 itself
CHALCL::CMP PK.DHS(R2),MYCHAD	;Matches my address?
	BNE 10$
	JMP CHAFME		;Yes, packet for me then

;;; Here is a packet for a local subnet
10$:	MOV PK.DHS(R2),BUFDST(R1)	;Address to correct host
	BR CHAQUE		;Queue to chaos interface

;;; Here is a packet for a foreign CHAOSNET subnet
CHASBN::MOV SBNHST(R3),BUFDST(R1)	;Address to appropriate host
	BEQ CHAPKF		;Junk if no route there

;;; Here to queue a packet to the CHAOSNET interface
;;; Address of buffer in R1
CHAQUE::MOV CHALST,R2		;Get head of queue
	BEQ 30$			;None, start this one right away
10$:	MOV R2,R3
	MOV @R2,R2
	BNE 10$			;Find the end of the list
	MOV R1,@R3		;Link new thing in
20$:	RET
30$:	MOV R1,CHALST

;;; Start a packet on the way to the aether
CHASND::MOV R1,CHOBFP		;Save pointer in case cable jammed
	ADD #1,NPKSOU		;One more packet output
	ADC HPKSOU
	INC CHOSTS		;Transmission in progress

;;Initiate transmission
CHAXM0::MOV CHOBFP,R1		;Get pointer to packet
	MOV BUFDTA(R1),R2	;Get data pointer
	MOV BUFBCT(R2),R4	;Get word count
	MOV #CHAWBF,R3		;Write data register
	CALL MOVR23		;Copy data into hardware
	MOV BUFDST(R1),(R3)	;Cable destination
	TST CHAXMT		;Prod transmitter
	BIS #CHSTEN,CHACSR	;Enable transmit done interrupts
	RET

;;; Process the header of a CHAOSNET packet
;;; Returns with V set is packet should be flushed
CHIHDR::MOV #PKNHDR,CHIHDL	;Set header length
	ADD #PKTFC+1,PK.FC(R2)	;Increment fwd count
	BIT #-PKTFC-1,PK.FC(R2)
	BEQ 50$			;Flush if forwarding loop
	MOV PK.NBT(R2),R4	;Get byte count
	BIC #PKTNBT,R4
	CMP R4,#DATMAX
	BHI 50$
	INC R4
	ASR R4			;Make word count
	ADD CHIHDL,R4		;Include header
	MOV R4,BUFBCT(R2)	;Save count for later
40$:	RET
50$:	SEV
	BR 40$

;;; SWAB the data portion of the packet
;;; Packet in R2, number of data words in R4
CHASWB::TST R4
	BLE 30$
	MOV #PK.DAT,CHIHDL
	MOVB PK.OP(R2),R3	;Get the opcode
	BPL 40$			;Control opcode
	BIT #100,R3		;Does this want to be swabbed?
	BEQ 50$			;Yes, go do so
30$:	RET			;No, return

40$:	TSTB CHABIN(R3)
	BNE 30$			;Binary, dont swab it
50$:	ADD CHIHDL,R2		;Point to data portion of packet
60$:	SWAB (R2)+
	SOB R4,60$
	RET

;;Byte table indexed by opcode, non-zero if binary
;;Binary operations are 2 (.COOPN), 7 (.COSTS), 10 (.CORUT)
CHABIN:	.BYTE 0,0,2,0,0,0,0,7,10,0,0,0
	.EVEN

;;Fast block move
;;These can move at most 256. words

;MOV (R3),(R2)+
;SOB R4,.-2
MOVR32:	SUB #256.,R4		;GET -#WDS LESS THAN MAXIMUM
	ADD R4,R4		;CONVERT TO BYTES
	SUB R4,PC		;JUMP INTO MOVE TABLE
.REPT 256.
	MOV (R3),(R2)+
.ENDR
	RET

;MOV (R2)+,(R3)
;SOB R4,.-2
MOVR23:	SUB #256.,R4		;GET -#WDS LESS THAN MAXIMUM
	ADD R4,R4		;CONVERT TO BYTES
	SUB R4,PC		;JUMP INTO MOVE TABLE
.REPT 256.
	MOV (R2)+,(R3)
.ENDR
	RET

;;; CHAOSNET device interrupt

CHAINT::PUSH <R0,R1,R2,R3,R4,R5>
	MOV CHACSR,R1		;Read status register
	BPL CHAIN1		;Branch if not receive done
	BIT #CHSERR,R1		;CRC error?
	BNE CHICRC		;Yes, go handle that
	MOV #BUFFCH,R3		;From the CHAOSNET
	CALL GETBUF		;Get a free buffer
	BEQ CHIFL2		;None, forget it for now
	MOV #CHARBF,R3		;Point to receive data register
	ADD #1,NPKSIN		;One more packet in from interface
	ADC HPKSIN
	MOV CHARBC,R4		;Bit count -1
	SUB #47.,R4		;Add 1, then subtract 3*16. for hardware words
.IREPT 4,<ASR R4>		;Convert to number of words
	CMP R4,#PKMAX
	BHI CHIFLS		;This can only happen if hardware broken
	CALL MOVR32		;Copy in the whole packet
	MOV BUFDTA(R1),R2	;Point back to data
	CALL CHIHDR		;Process header
	BVS CHIFLS		;Software count too long
	CMP (R3),(R3)
	TST (R3)		;Flush 3 hardware leader words
	BIT #CHSERR,CHACSR	;Was there an error reading it out?
	BNE CHIGBG		;Yes, flush it
	CMP CHARBC,#7777	;Was packet correct length?
	BNE CHIBBC		;No good

	CALL CHARCV		;Message received successfully
	BR CHIFL1		;Go clear receiver and check on output

;;Packet received with crc error at start
CHICRC:	ADD #1,NPKSER
	ADC HPKSER
	BR CHIFL1

;;Packet read out as gubbish
CHIGBG:	ADD #1,NPKSRE
	ADC HPKSRE
	BR CHIFL0

;;Bad bit-count
CHIBBC:	ADD #1,NPKSBB
	ADC HPKSBB
	BR CHIFL0

;;Here to ignore an input packet
CHIFLS:	ADD #1,NPKSIG
	ADC HPKSIG
;;Here when we aren't going to queue a packet
CHIFL0:	MOV FRELST,@R1		;Return to free list
	MOV R1,FRELST
;;Here when all done with packet
CHIFL1:	MOVB CHACSR+1,R4	;Get lost count
	ASR R4
	BIC #-20,R4		;Bits 9-12
CHIF1A:	ADD R4,NPKSLS
	ADC HPKSLS
	BIS #CHSRCL,CHACSR	;Clear receiver for another message
	BR CHAIN1

;;Here when there's no buffer for a packet
CHIFL2:	MOV #1,R4		;Treat it as "slow" (software)
	BR CHIF1A

;;Now check on the output side of things
CHAIN1:	TSTB CHACSR		;Transmit done?
	BPL CHAINZ		;Nope, dont worry about it
	MOV CHOSTS,R1		;Was there output in progress?
	BNE 20$			;Yes, go check on how it went
	TST CHXRUT		;Time to send routing packet?
	BGT 10$			;No, not yet
	CALL CHORUT		;Yes, send it
	BR CHITEN		;But don't arm xmit interrupt

10$:	TST CHPLSP		;Pulsar feature enabled?
	BEQ CHITEN		;No, forget it
	CMP CHPLSR,CHPLSP	;Time for a pulse?
	BNE CHITEN		;No, just turn off interrupt
	MOV #CHAWBF,R3		;Write data register
	MOV #52525,(R3)		;Alternating one'S
	CLR (R3)		;Followed by all zeros
	MOV #-1,(R3)		;To host -1
	TST CHAXMT		;Send it
	BR CHITEN		;But still clear transmit interrupt enable

20$:	CMP R1,#2		;Transmit abort delay completed?
	BNE 30$
	MOV #-1,CHOSTS		;Yes, try to transmit it again
	CALL CHAXM0
	BR CHAINZ

30$:	BIT #CHSTAB,CHACSR	;Transmit aborted?
	BEQ CHITDN		;No
	ADD #1,NPKSAB		;One more aborted
	ADC HPKSAB
	INC CHOSTS
	BNE CHITEN		;If this is the first time, delay for a while

CHITDN::CLR CHOSTS		;Clear transmit in progress flag
	MOV CHALST,R1		;Get head of transmit list
	BEQ CHITEN
	CALL FREBUF		;Free it
	MOV R1,CHALST		;New head of the queue
	BEQ CHITEN
	CALL CHASND		;Start some more packets transmitting
CHITEN::BIC #CHSTEN,CHACSR	;Clear transmit interrupt enable
CHAINZ:	JMP INTRET		;Restore regs and return from interrupt

;;Packet received correctly, queue it to somewhere
CHARCV::BIS #CHSREN,CHACSR	;Turn on receive interrupts too
	TST PK.DHS(R2)		;Broadcast packet?
	BNE 40$			;No
	PUSH R1
	CMPB PK.OP(R2),#.CORUT	;Yes, routing packet?
	BNE 20$			;No, ignore it then
	CALL CHARUT		;Yes, handle it specially
20$:	POP R1
	JMP CHAPKF		;Return to free list

40$:	CALL CHAPKT		;Here is a packet, queue it
	RET

;;Routing packet
CHARUT::MOV BUFBCT(R2),R4	;Get number of data words
	SUB #PKNHDR,R4		;Subtract off header
	ASR R4			;Make number of 2 word pairs
	MOV PK.SHS(R2),R5	;Host address this came from
	ADD #PK.DAT,R2		;Point to start of packet's data
10$:	MOV (R2)+,R3		;Get subnet being talked about
	CMP #SBNMAX,R3		;One we know about?
	BLE 20$			;No, forget it
	ASL R3			;Make word index
	TST SBNRUT(R3)		;Foreign CHAOSNET subnet?
	BNE 20$			;No, do not change it then
	CMP (R2),SBNCST(R3)	;Compare costs
	BHI 20$			;New one no better
	MOV (R2),SBNCST(R3)	;Save best cost
	MOV R5,SBNHST(R3)	;And host address this came from as best
20$:	TST (R2)+
	SOB R4,10$
	RET

;;; Packet addressed to the -11 itself
CHAFME::MOV R1,CHIBUF		;Save packet address
	CMPB PK.OP(R2),#.CORFC	;RFC?
	BNE 10$			;No, just flush it
	CALL SERVE		;Else try to handle it here
	BEQ 10$			;Nothing special
	MOV ANSBUF,R1		;Address of the ANS
	MOV BUFDTA(R1),R2	;And actual data
	CALL CHADAT		;Queue it to cable
10$:	MOV CHIBUF,R1		;Get back buffer
	CALL FREBUF		;Free the packet
	TST R1			;158
	BEQ 1$			;158
	 BPT			;158
1$:	RET			;158

;;RFC, see if something -11 should handle
SERVE::	MOV CHIBUF,R1
	MOV #SRVTBL,R3		;Address of server table
10$:	MOV (R3)+,R4		;Address of contact name for that server
	BEQ 30$			;Exit if table exhausted, 'EQ' in cond code
	MOV BUFDTA(R1),R2
	ADD #PK.DAT,R2		;Address of contact name in this RFC
20$:	TSTB (R4)		;End of string?
	BEQ 40$			;Yup, run this server
	CMPB (R2)+,(R4)+	;Do string compare
	BEQ 20$			;Matches
	TST (R3)+		;Doesn't match, try next
	BR 10$

30$:	RET

40$:	JMP @(R3)		;Call server, it can return EQ or NE

SRVTBL:	.WORD 10$,STSSRV	;STATUS - return host name and meters
	.WORD 20$,PLSSRV	;PULSAR - set and get pulsar rate
	.WORD 0			;End of table
10$:	.ASCIZ /STATUS/
20$:	.ASCIZ /PULSAR/
	.EVEN

;;STATUS, send name and meters
STSSRV::MOV #32.+CHSSBS+4+TNSBSS+4,R4	;32 bytes/name, plus meters
.IIF NE LCSNTP, ADD #LNSBSS+4,R4
	CALL GETANS		;Allocate a packet to send as an ANS
	MOV #MYNAME,R3		;Get pointer to our name
	MOV #MYNAML,R4		;And size of it
10$:	MOVB (R3)+,(R2)+	;Stick in next byte
	SOB R4,10$
	MOV #32.-MYNAML,R4
20$:	CLRB (R2)+		;Pad with nulls
	SOB R4,20$
	MOVB MYCHAD+1,(R2)+	;Next comes our subnet number
	MOVB #1,(R2)+		;Signal new-style meters (32-bit)
	MOV #CHSSBS/2,R4
	MOV R4,(R2)+		;Then size of rest of info
	MOV #CHSSBL,R3		;Meter block
30$:	MOV (R3)+,(R2)+
	SOB R4,30$
	MOVB #BESN,(R2)+	;Next comes data on -10 queue
	MOVB #1,(R2)+
	MOV #TNSBSS/2,R4
	MOV R4,(R2)+
	MOV #TNSBSB,R3
40$:	MOV (R3)+,(R2)+
	SOB R4,40$
.IF NE, LCSNTP
	MOV #410,(R2)+		;Next comes data on LNI queue
	MOV #LNSBSS/2,R4
	MOV R4,(R2)+
	MOV #LNSBSB,R3
50$:	MOV (R3)+,(R2)+
	SOB R4,50$
.ENDC
	CLZ			;Set 'NE' cond code
	RET

;;PULSAR
PLSSRV::MOV CHIBUF,R1
	MOV BUFDTA(R1),R2
	MOVB PK.NBT(R2),R4	;Get byte count, should be small
	CMP R4,#8.		;6 for pulsar, 1 for space, 1 for character
	BLO 10$			;Not given an argument, just read status
	MOVB PK.DAT+7(R2),R3	;Yes, get the argument
	SUB #'0,R3		;Convert to octal
	MOV R3,CHPLSP		;Change pulsar status
10$:	MOV #1,R4		;Just one byte
	CALL GETANS
	MOV CHPLSP,R3		;Return pulsar status
	ADD #'0,R3		;In ASCII
	MOVB R3,(R2)
	RET			;Note 'NE' set

;;Get a packet for an ANS, number of bytes needed in R4
;;Returns with R2 pointing to data portion of packet
GETANS::MOV CHIBUF,R1
	MOV BUFDTA(R1),R5	;Save source pointer
	MOV #BUFF11,R3
	CALL GETBUF		;Get a buffer
	BNE 10$
	BPT			;Could not get one, die
10$:	MOV R1,ANSBUF		;Save where the ANS is
	MOV #.COANS*400,(R2)+	;Opcode
	MOV R4,(R2)+		;Byte count
	MOV PK.SHS(R5),(R2)+	;Destination host
	MOV PK.SIX(R5),(R2)+	;Destination index
	MOV MYCHAD,(R2)+	;Source host
	CLR (R2)+		;Source index
	CLR (R2)+		;Packet number
	CLR (R2)+		;Ack number
	RET

;;; Broadcast a packet full of routing information
CHORUT::MOV #CHAWBF,R3		;Write buffer
	MOV #.CORUT*400,(R3)	;Opcode
	MOV #SBNCNT,R1		;Count subnets which we know anything about
	CLR R2
10$:	CMP SBNCST(R1),#1000
	BHIS 20$
	ADD #4,R2		;This one will generate 2 words
20$:	SUB #2,R1
	BPL 10$
	MOV R2,(R3)		;Byte count
	CLR (R3)		;Destination
	CLR (R3)		;...
	MOV (R3),(R3)		;Source = me
	CLR (R3)		;Source index
	CLR (R3)		;Packet number
	CLR (R3)		;ACK number
	MOV #SBNCNT,R1		;Go through subnet tables
	MOVB 1(R3),R4		;Get subnet this is going out on
	ASL R4
	MOV SBNCST(R4),R4	;Get cost of getting to us from guy who receives this
30$:	CMP SBNCST(R1),#1000	;Was this one included in byte count?
	BHIS 40$		;No, don't put it in packet
	MOV R1,R2		;First word is subnet number
	ASR R2
	MOV R2,(R3)
	MOV SBNCST(R1),R2	;Second word is cost
	ADD R4,R2		;Which must include cost of getting to us
	MOV R2,(R3)
40$:	SUB #2,R1		;Next subnet
	BPL 30$
	CLR (R3)		;Broadcast this packet
	TST CHAXMT		;Transmit it
	MOV #15.*60.,CHXRUT	;Not needed for a while now
	RET

;;Request for our status from the -10
CHARQS::MOV #CHASBL,R1		;Internal block
	TST (R1)		;Is it in use?
	BEQ 10$			;No, ok to send then
	RET

10$:	MOV CHACSR,CHASDS	;Read device status for it
	JMP TOTENQ		;Queue it to -10

;;Time to age routing table cost
CHACLK::MOV #4*60.,CHRTIM
	PUSH <R1,R2>
	CLR R1
	MOV #SBNMAX,R2		;Number of subnets we can know about
10$:	TST SBNRUT(R1)		;Routing though network?
	BNE 20$			;No, don't age
	CMP SBNCST(R1),#1000	;Don't wrap around
	BHIS 20$
	INC SBNCST(R1)		;Age this one
20$:	TST (R1)+
	SOB R2,10$
30$:	POP <R2,R1>
	RET

;;Common variables
CHALST:	.WORD 0			;Transmit queue
MYCHAD:	.WORD 0			;My address on the network
CHIBUF:	.WORD 0			;Current input buffer
CHIHDL:	.WORD 0			;Length of current header
ANSBUF:	.WORD 0			;Pointer to an ANS to RFC
CHOBFP:	.WORD 0			;Packet address
CHOSTS:	.WORD 0			;Status of output 0=none 1=starting 2=failed,delay -1=2nd time

CHASBL:	.WORD 0			;Status block to send to -10
	.WORD BUFFIN		;Internal, stay off free list
	.WORD 0			;Destination
	.WORD CHASDS		;Pointer to data portion
	.WORD CHASBS/2		;Size
	.WORD BUFHST		;Type is not a buffer
CHASDS:	.WORD 0			;Device status
CHAADR:	.WORD 0			;His address on the network
CHSSBL==.			;Status RFC info block
NPKSIN:	.WORD 0			;Number of packets in from interface (low)
HPKSIN:	.WORD 0			;Number of packets in from interface (high)
NPKSOU:	.WORD 0			;Number of packets output to interface (low)
HPKSOU:	.WORD 0			;Number of packets output to interface (high)
NPKSAB:	.WORD 0			;Number of transmissions aborted (low)
HPKSAB:	.WORD 0			;Number of transmissions aborted (high)
NPKSLS:	.WORD 0			;Number lost to busy interface (low)
HPKSLS:	.WORD 0			;Number lost to busy interface (high)
NPKSER:	.WORD 0			;Number with CRC errors at first (low)
HPKSER:	.WORD 0			;Number with CRC errors at first (high)
NPKSRE:	.WORD 0			;Number read out with CRC errors (low)
HPKSRE:	.WORD 0			;Number read out with CRC errors (high)
NPKSBB:	.WORD 0			;Number with bad bit-count (low)
HPKSBB:	.WORD 0			;Number with bad bit-count (high)
NPKSIG:	.WORD 0			;Number of packets ignored for misc reasons (low)
HPKSIG:	.WORD 0			;Number of packets ignored for misc reasons (high)
CHSSBS==.-CHSSBL		;Length of status RFC block
CHASBS==.-CHASBL		;Length of to -10 status block

;;Pulsar variables
CHPLSP:	.WORD 0			;Rate at which to tweak cable
CHPLSR:	.WORD 0			;Cable pulsar count

CHRTIM:	.WORD 4*60.

CHXRUT:	.WORD 15.*60.		;Count for transmitting routing info

.ENDC	;CHAOSP

.SBTTL Routing tables
;;; All tables indexed by subnet number

;; Routing methods:
;    0       1      2     3    4       5      6     7     10      11   12    13
;    --,  Campus, Ether,  MC,  AI,     XX,    9th, --,  LCSnet,  ARPA, --,   EE
SBNRUT:
.IF NE XX
.WORD  0,      0,     0,   0,   0, TENSBN, CHALCL,   0,  LCSLCL,   0, 0,   0
.ENDC
.IF NE EE
.WORD  0, CHALCL,     0,   0,   0,      0,      0,   0,       0,   0, 0, TENSBN
.ENDC
.IF NE OZ
.WORD  0, CHALCL,     0,   0,   0,      0,      0,   0,       0,   0, 0,    0
.ENDC
	.IREPT 4,0		;14-17
	.IREPT 3,0		;20-22
.IIF NE OZ, TENSBN		;Where are we, Toto?
.IIF EQ OZ, 0			;23 OZ DTE link
	.IREPT 10,0		;24-33
	.IREPT 4,0		;34-37
	.IREPT 7,0		;40-46
	.IREPT 32,0		;47-100

SBNMAX==<.-SBNRUT>/2		;Number of subnets we know about
SBNCNT==2*<SBNMAX-1>		;Count for routing


;; Host numbers
;    0      1      2      3     4     5      6    7      10      11   12    13
;    --, Campus, Ether,   MC,   AI,   XX,    9th, --,  LCSnet,  ARPA, --,   EE
SBNHST::

.IF NE XX ;AI11   AI11  MC11  AI11    --      --  --       --     --  --   AI11
.WORD 0,   3072,  3072, 3040, 3072,    0,      0,  0,       0,     0,  0,  3072
.ENDC
.IF NE EE ;  --   AI11  MC11  AI11  XX11    AI11  --     XX11     --  --     --
.WORD 0,      0,  3072, 3040, 3072, 3020,   3072,  0,    3020,     0,  0,     0
.ENDC
.IF NE OZ ;AI11   AI11  MC11  AI11  XX11      --  --     XX11     --  --   AI11
.WORD 0,      0,  3072, 3040, 3072, 3020,   3072,  0,    3020,     0,  0,  3072
.ENDC
	.IREPT 4,0		;14-17
	.IREPT 4,0		;20-23
	.IREPT 10,0		;24-33
	.IREPT 4,0		;34-37
	.IREPT 7,0		;40-46
	.IREPT 32,0		;47-100

.IF NE <SBNMAX - <<. - SBNHST> / 2>>	;Some schumck fuck up the tables?
.ERROR	Hey turkey, you blew it when you pawed over the tables
.ENDC


;; Costs
;    0    1     2      3     4     5     6      7    10        11    12     13
;    --, Camp, Ether, MC,   AI,   XX,   9th,   --, LCSnet,   ARPA,  --,     EE
SBNCST::
.IF NE XX
.WORD 0, 1000, 1000, 1000, 1000,  10.,   11., 1000,   11.,  1000,   1000,  1000
.ENDC
.IF NE EE
.WORD 0,  11., 1000, 1000, 1000, 1000,  1000, 1000,  1000,  1000,   1000,   10.
.ENDC
.IF NE OZ
.WORD 0,  11., 1000, 1000, 1000, 1000,  1000, 1000,  1000,  1000,   1000,  1000
.ENDC
	.IREPT 4,1000		;14-17
	.IREPT 3,1000		;20-22
.IIF NE OZ, 10.			;Kansas, schmuck.
.IIF EQ OZ, 1000		;23 OZ DTE link
	.IREPT 10,1000		;24-33
	.IREPT 4,1000		;34-37
	.IREPT 7,1000		;40-46
	.IREPT 32,1000		;47-100

.IF NE <SBNMAX - <<. - SBNCST> / 2>>
.ERROR	Hey turkey, you blew it when you pawed over the tables
.ENDC


 MYNAME:
.IIF NE XX, .ASCII /XX-NETWORK-11/
.IIF NE EE, .ASCII /EE-NETWORK-11/
.IIF NE OZ, .ASCII /OZ-NETWORK-11/
MYNAML==.-MYNAME
	.EVEN


.IF NE,LCSNTP

.SBTTL LCS NET

LNIADR==175100			;LNI CSR address
;;; Unibus register offsets
LNICSR=0			;Command register
LNIRSR=2			;Status register
LNIOAL=10			;Output addr reg
LNIOAH=12			;Output addr reg
LNIIAL=14			;Input addr reg
LNIIAH=16			;Output addr reg
LNIOBC=20			;Output byte count reg
LNIIBC=22			;Input byte count reg

;;; CSR bits

LNSROK=100000			;Ring ok
LNSOFI=40000			;Output fifo input ready
LNSOFO=20000			;Output ready
LNSIFI=10000			;Input fifo input ready
LNSIFO=4000			;Output ready
LNSCOF=2000			;Clear output fifo
LNSDEN=1000			;Enable dma
LNSDIE=400			;DMA done interrupt
LNSCNT=200			;Clear NT
LNSRST=140			;Read and reset
LNSRNT=100			;Remove from NT
LNSANT=40			;Add to NT
LNSFTK=20			;Force token output
LNSOIE=10			;Output done interrupt
LNSOEN=4			;Output enable
LNSIIE=2			;Input done interrupt
LNSIEN=1			;Enable input

;;; RSR bits

LNSOFE=100000			;Output format err
LNSBMA=40000			;Bad match/accept
LNSCNM=20000			;CRC no match
LSNCRC=10000			;Rcvd O/P CRC bad
LNSOUR=4000			;Output underrun
LNSMER=2000			;Message err
LNSIFE=1000			;Input format err
LNSICB=400			;Input CRC bad
LNSIOR=200			;Input overrun
LNSNTB=100			;Name table busy
LNSNTE=40			;NT err
LNSRRF=20			;RR find
LNSACC=10			;Accept
LNSMCH=4			;Match
LNSOPC=2			;Output complete
LNSIPC=1			;Input complete

LNIIER=LNSIFE!LNSICB!LNSIOR	;Input and output errors
LNIOER=LNSOFE!LNSBMA!LNSCNM!LSNCRC!LNSOUR

;;; Hardware header format
LNBDPM==-16			;Destination mask
LNBDPN==-12			;Destination process
 LNBPTC==-12			;Protocol
  LNPINT==1			;INTERNET
  LNPCHA==2			;CHAOSNET
  LNPMUP==3			;MUPPET
 LNBSNT==-11			;Subnet number
 LNBRSV==-10			;Reserved
 LNBHST==-7			;Host number
LNBOPN==-6			;Originating process
LNBLEN==-2			;Length
LNHLEN==16			;Length of header

;;; Initialize the interface
LNIINI::MOV #LNIADR,R0
	MOV #LNSCOF!LNSCNT,LNICSR(R0)	;Clear out output fifo and name table
	CLR LNIIAH(R0)
	CLR LNIOAH(R0)

	MOV #LNINM,LNIOAL(R0)	;Load my name into FIFO
	MOV #LNINL,LNIOBC(R0)
	MOV #LNSDEN,LNICSR(R0)	;Start DMA
	MOV #LNINDT,R1		;Time for it take place
5$:	TST LNIOBC(R0)		;Done yet?
	BEQ 10$
	SOB R1,5$
	BPT			;Did not finish in time

10$:	MOV #LNINTN,R2		;Number of name table entries
15$:	MOV #LNSANT,LNICSR(R0)	;Stick FIFO into name table
	MOV #LNINTT,R1
20$:	BIT #LNSNTB,LNIRSR(R0)	;Loaded yet?
	BEQ 25$
	SOB R1,20$
	BPT			;Did not finish in time

25$:	BIT #LNSNTE,LNIRSR(R0)	;Made it ok?
	BEQ 30$
	BPT			;No, failed

30$:	SOB R2,15$		;Load entire name table
	MOV #LNSDEN,LNICSR(R0)	;Enable DMA again
	BIT #LNSROK,LNICSR(R0)	;Ring up?
	BNE LNISIP		;Yes, setup an input buffer
	MOV #LNITM,LNIOAL(R0)	;Load token message into FIFO
	MOV #LNITML,LNIOBC(R0)
	MOV #LNITDT,R1
35$:	TST LNIOBC(R0)
	BEQ 40$
	SOB R1,35$
	BPT

40$:	BIS #LNSFTK!LNSOEN,LNICSR(R0)	;Output, forcing token
	MOV #LNITTT,R1
45$:	BIT #LNSOPC,LNIRSR(R0)	;Output complete?
	BNE 50$
	SOB R1,45$
	BPT

50$:	BIT #LNSROK,LNICSR(R0)	;Token appeared?
	BNE LNISIP		;Yes, can start input then
	PUSH R0			;Piss, moan and wail
	MOV #66$,R0
	CALL PRF
	POP R0	
	BR LNISIP

66$:	.ASCIZ  /LCSNet down, ignoring/
	.EVEN


;;; Setup an input buffer for the LNI now, since there is
;;; no packet buffer.  Address of CSR in R0.
LNISIP::BIC #LNIIAC,LNISTS	;No input in progress
	MOV #BUFFLN,R3
	CALL GETBUF		;Get a free buffer
	MOV R1,LNIIBF		;Save address
	BEQ LNISIR		;Could not get one
LNISI1:	CLR LNIIBC(R0)
	SUB #LNIHDR,R2		;Account for LCSNET header
	MOV R2,LNIIAL(R0)
	MOV #MSGLEN,LNIIBC(R0)
	BIS #LNSIEN!LNSIIE,LNICSR(R0)	;Start input, enable interrupt
	BIS #LNIIAC,LNISTS
LNISIR:	RET

;;; Device interrupt
LNIINT::PUSH <R0,R1,R2,R3,R4,R5>
	MOV #LNIADR,R0
	TST LNISTS		;Input active?
	BPL LNIIN1		;PL if not
	BIT #LNSIPC,LNIRSR(R0)	;Did it complete?
	BEQ LNIIN1

LNIIFT=200			;Time for I/P FIFO to empty after interrupt
	MOV #LNIIFT,R1		;Must wait
10$:	BIT #LNSIFO,LNICSR(R0)
	BEQ 20$
	TST LNIIBC(R0)
	BEQ 20$
	SOB R1,10$
	BPT

20$:	BIC #LNIIAC,LNISTS	;Input operation complete
	MOV LNIIBF,R1		;Get buffer used
	BNE 21$			;Should always be one
	BPT
21$:	MOV BUFDTA(R1),R2
	BIT #LNSIFO,LNICSR(R0)
	BNE 30$
	BIT #LNIIER,LNIRSR(R0)	;Any errors?
	BEQ 40$

30$:	ADD #1,LNIIEC		;One more error
	ADC LNIIEC+2
	CALL LNISI1		;Restart input, same buffer
	BR LNIIN1		;Check output

40$:	ADD #1,NPKLNI		;One more packet in
	ADC HPKLNI
	CALL LNIRCV		;Packet received
	MOV #LNIADR,R0		;Output routine may have clobbered this
	TST LNISTS		;Make sure we have a new input buffer
	BMI LNIIN1		;Yes, must have reused failing one
	CALL LNISIP		;Else start one going

;;; Check on output
LNIIN1::TSTB LNISTS		;Output active?
	BPL 30$			;No, return
	BIT #LNSOPC,LNIRSR(R0)	;Output complete?
	BEQ 30$
	BIT #LNSOUR,LNIRSR(R0)
	BEQ 10$
	BPT

10$:	BIT #LNIOER,LNIRSR(R0)	;Output errors?
	BEQ 20$			;No
	ADD #1,LNIOEC		;One more output error
	ADC LNIOEC+2
20$:	BIC #LNIOAC,LNISTS	;Clear output active
	MOV LNILST,R1		;Get head of queue
	BNE 21$			;Better be one
	BPT
21$:	CALL FREBUF		;Free it
	MOV R1,LNILST		;Get head of remaining queue
	BEQ 30$
	MOV BUFDTA(R1),R2	;Pointer to data portion
	CMPB BUFDST(R1),LNIOHS	;Going to same host?
	BNE 22$			;No, get going
	MOV #LNIOHT,LNIOHL	;Yes, hold output
	BNE 30$			;temporarily if enabled
22$:	CALL LNIXMT		;Start some more packets transmitting
30$:	JMP INTRET

;;; Packet received ok, process it
LNIRCV::MOVB LNBPTC(R2),R3	;Get protocol type
	ASL R3
	JMP @LNIPTC(R3)		;Process

LNIPTC:	10$			;0 Illegal
	LNIIIN			;1 Internet
	LNICHA			;2 CHAOSNET
	10$			;3 MUPPET
	.IREPT 3,10$
10$:	BPT

;; CHAOSNET packet from the LCSNET
LNICHA::CALL CHIHDR		;Process header
	BVS 10$			;Bad, flush it
	JMP CHARCV		;Queue to someplace and return

10$:	JMP LNISI1		;No good, reuse input buffer

;; Internet packet from the LCSnet, reorder it and hand off
LNIIIN::MOV LNBLEN(R2),R4	;Get length of packet
	INC R4
	ASR R4			;Count in words
10$:	SWAB (R2)+		;Reorder off the ring net
	SOB R4,10$
	MOV BUFDTA(R1),R2	;Point to data portion again
	JMP INTPKT		;Do routing




;;; Send an internet packet to the LCSNET
INTLCS::MOV BUFBCT(R2),R4	;Get length in words
10$:	SWAB (R2)+		;Reorder for going onto the network
	SOB R4,10$
	MOV #LNPINT,R3
	BR LNIPKT

;;; CHAOSNET packet for the LCSNET
LCSLCL::MOV PK.DHS(R2),BUFDST(R1)	;Address to correct host
	MOV #LNPCHA,R3

;;; Queue a packet to the LCS net, pointer in R1, size now correct
LNIPKT::MOV BUFDTA(R1),R2	;Point to data portion again
	MOVB R3,BUFDEV(R2)	;Source device is protocol
	ADD #1,NPKLNO		;One more packet out
	ADC HPKLNO

LNIQUE::MOV LNILST,R2		;Get head of queue
	BEQ 20$			;Empty, transmit immediately
10$:	MOV R2,R3		;Find end of queue
	MOV @R2,R2		;Die, luser scum
	BNE 10$
	MOV R1,@R3		;Link in new packet
	RET
20$:	MOV R1,LNILST		;Make it the top of the list
	CLR LNIOHS		;And tell him to go right away

;;; Start a packet on its way to the ring, address of packet in R1
;;; size assumed correct by now
LNIXMT::MOV #LNIADR,R0		;Point to CSR
	BIS #LNSCOF,LNICSR(R0)	;Remove any garbage from output fifo
	CLR LNIOBC(R0)
	MOV BUFDTA(R1),R2	;Pointer to data portion
	MOVB BUFDEV(R2),R3	;Protocol type
	MOV BUFBCT(R2),R4	;Length field
	ASL R4
	MOV R4,-(R2)		;Length
	CLR -(R2)		;Originating process
	CLR -(R2)		;...
	MOVB BUFDST(R1),-(R2)	;Host
	MOVB BUFDST(R1),LNIOHS	;Remember to prevent overflow..
	CLRB -(R2)
	MOVB BUFDST+1(R1),-(R2)	;Subnet
	MOVB R3,-(R2)		;Protocol
	CLR -(R2)		;Destination mask
	CLR -(R2)		;...
	MOV R2,LNIOAL(R0)
	ADD #LNHLEN,R4		;Include header into network
	MOV R4,LNIOBC(R0)
	BIS #LNSOIE!LNSOEN,LNICSR(R0)
	BIS #LNIOAC,LNISTS	;Say output active
	BIT #LNSROK,LNICSR(R0)	;Ring down?
	BNE 66$
	BIS #LNSFTK,LNICSR(R0)	;Zap a token
	MOV #100,R4		;Magic number ride
65$:	DEC R4
	BGT 65$
	BIC #LNSFTK,LNICSR(R0)	;Fucking turkey design
66$:	RET


LNILST:	.WORD 0			;Output queue
LNISTS:	.WORD 0
 LNIIAC==100000			;Input active
 LNIOAC==000200			;Output active
LNIIBF:	.WORD 0			;Input buffer
 LNIOHT = 0			;Number of ticks to hold (if zero, disable)
LNIOHL:	.WORD 0			;This many ticks left in output hold
LNIOHS:	.WORD 0			;Address of last host sent to
LNSBSB==.
NPKLNI:	.WORD 0			;Number of packets input (low)
HPKLNI:	.WORD 0			;Number of packets input (high)
NPKLNO:	.WORD 0			;Number of packets output (low)
HPKLNO:	.WORD 0			;Number of packets output (high)
LNIOEC:	.WORD 0,0		;Output error count
	.WORD 0,0,0,0,0,0,0,0	;Lost count, CRC1, CRC2, BBC
LNIIEC:	.WORD 0,0		;Input error count
LNSBSS==.-LNSBSB

;; Name table entry
LNINTT==100			;Time to add to name table
LNINM::	.BYTE 77,0,0,0		;All packets addressed to me
.IIF NE XX,	.BYTE 0,10,0,40
.IIF NE OZ,	.BYTE 0,10,0,41
LNINL==.-LNINM			;Length of name table
LNINDT==LNINL*2			;Time for DMA of that to complete
LNINTN==LNINL/8.		;Number of entries

;; Token message
LNITM:	.WORD 0,0,0,0,0,0,2,72727
LNITML=.-LNITM			;Length of token message
LNITDT=LNITML*2			;Time for DMA
LNITTT=1000			;Time to send it
.ENDC	;LCSNTP

.SBTTL Clock interrupt

CLKCSR==177546			;Clock register

CLKINT::DEC KPALCN		;Count for keep alive
	BGT 10$			;Still waiting
	MOV #5.*60.,KPALCN
	INCB KPALIV		;Increment keep alive counter
.IF NE,DTEONP
	PUSH <R0,R1,R2,R3>	;Save registers
	MOV #DTE1,R0
	MOV #DEP,R1
	MOV #PSWW1-FORPRO,R2
	ADD DTEMYD,R2
	MOV #KPALIV,R3
	CALL SWFED		;And send it over
	POP <R3,R2,R1,R0>	;Restore registers
.ENDC

10$:
.IF NE,CHAOSP
	TST CHOSTS		;Is there output in progress?
	BNE 20$			;Yes, go turn on transmit interrupt
	DEC CHXRUT		;Maybe time for a routing packet
	BLE 20$
	DEC CHPLSR		;Else see if time to hack cable
	BGT 30$			;If count exhausted,
	MOV CHPLSP,CHPLSR	;Reset counter
20$:	BIS #CHSTEN,CHACSR	;Turn on transmit interrupt enable
30$:	DEC CHRTIM		;Time to age routing table?
	BGT 40$
	CALL CHACLK
.ENDC	;CHAOSP


40$:

.IF NE,LCSNTP			;Kludge to prevent overruns
	TST LNIOHL		;Output held?
	BEQ 42$			;Nope, continue on way
	DEC LNIOHL		;Wind down hold
	BGT 42$			;Still non zero
	PUSH <R0,R1,R2,R3,R4>	;Save registers
	MOV LNILST,R1		;Get head of remaining queue
	BNE 41$			;Better be one
	BPT			;Barf, wasn't one
41$:	CALL LNIXMT		;Start packet transmitting
	POP <R4,R3,R2,R1,R0>	;Restore registers
42$:
.ENDC

	RTI

.END $START
